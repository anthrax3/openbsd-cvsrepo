head	1.21;
access;
symbols
	PERL_5_24_2:1.1.1.17
	OPENBSD_6_1:1.21.0.4
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.18.0.4
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.15.0.10
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.8
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.6
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.21
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.20;
commitid	cxJ08BvJA9Pt2PTM;

1.20
date	2016.07.25.10.53.04;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	FHUgABTHZQuYQh2B;

1.19
date	2016.07.03.01.08.01;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	GzHqjSTnBjdF7Wcw;

1.18
date	2014.11.17.20.57.06;	author afresh1;	state Exp;
branches
	1.18.4.1
	1.18.6.1;
next	1.17;
commitid	QP75iYx42Uo7mMxO;

1.17
date	2014.03.24.15.05.27;	author afresh1;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.25.20.40.55;	author sthen;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.24.15.06.59;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.13.01.25.48;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.12.18.24.38;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.29.17.36.10;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.19.23.05;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.15.21.30.31;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.09.28;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.04;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.36;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.25;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.15;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.47;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.06;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.35;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.35;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.39.56;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.38;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.23;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.59;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.14;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.46.43;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.17.11;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.48.37;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.30;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.49;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.35;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.08.53;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.59.03;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.53.08;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	B31cAbBIXiCqnL97;

1.1.1.17
date	2017.08.14.13.46.14;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;

1.18.4.1
date	2016.08.05.01.01.40;	author afresh1;	state Exp;
branches;
next	;
commitid	HjAJx2yjL4A8HWon;

1.18.6.1
date	2016.08.05.01.00.56;	author afresh1;	state Exp;
branches;
next	;
commitid	wK3bUiy9jNch0Key;


desc
@@


1.21
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@
=head1 NAME

perl5db.pl - the perl debugger

=head1 SYNOPSIS

    perl -d  your_Perl_script

=head1 DESCRIPTION

C<perl5db.pl> is the perl debugger. It is loaded automatically by Perl when
you invoke a script with C<perl -d>. This documentation tries to outline the
structure and services provided by C<perl5db.pl>, and to describe how you
can use them.

=head1 GENERAL NOTES

The debugger can look pretty forbidding to many Perl programmers. There are
a number of reasons for this, many stemming out of the debugger's history.

When the debugger was first written, Perl didn't have a lot of its nicer
features - no references, no lexical variables, no closures, no object-oriented
programming. So a lot of the things one would normally have done using such
features was done using global variables, globs and the C<local()> operator
in creative ways.

Some of these have survived into the current debugger; a few of the more
interesting and still-useful idioms are noted in this section, along with notes
on the comments themselves.

=head2 Why not use more lexicals?

Experienced Perl programmers will note that the debugger code tends to use
mostly package globals rather than lexically-scoped variables. This is done
to allow a significant amount of control of the debugger from outside the
debugger itself.

Unfortunately, though the variables are accessible, they're not well
documented, so it's generally been a decision that hasn't made a lot of
difference to most users. Where appropriate, comments have been added to
make variables more accessible and usable, with the understanding that these
I<are> debugger internals, and are therefore subject to change. Future
development should probably attempt to replace the globals with a well-defined
API, but for now, the variables are what we've got.

=head2 Automated variable stacking via C<local()>

As you may recall from reading C<perlfunc>, the C<local()> operator makes a
temporary copy of a variable in the current scope. When the scope ends, the
old copy is restored. This is often used in the debugger to handle the
automatic stacking of variables during recursive calls:

     sub foo {
        local $some_global++;

        # Do some stuff, then ...
        return;
     }

What happens is that on entry to the subroutine, C<$some_global> is localized,
then altered. When the subroutine returns, Perl automatically undoes the
localization, restoring the previous value. Voila, automatic stack management.

The debugger uses this trick a I<lot>. Of particular note is C<DB::eval>,
which lets the debugger get control inside of C<eval>'ed code. The debugger
localizes a saved copy of C<$@@> inside the subroutine, which allows it to
keep C<$@@> safe until it C<DB::eval> returns, at which point the previous
value of C<$@@> is restored. This makes it simple (well, I<simpler>) to keep
track of C<$@@> inside C<eval>s which C<eval> other C<eval's>.

In any case, watch for this pattern. It occurs fairly often.

=head2 The C<^> trick

This is used to cleverly reverse the sense of a logical test depending on
the value of an auxiliary variable. For instance, the debugger's C<S>
(search for subroutines by pattern) allows you to negate the pattern
like this:

   # Find all non-'foo' subs:
   S !/foo/

Boolean algebra states that the truth table for XOR looks like this:

=over 4

=item * 0 ^ 0 = 0

(! not present and no match) --> false, don't print

=item * 0 ^ 1 = 1

(! not present and matches) --> true, print

=item * 1 ^ 0 = 1

(! present and no match) --> true, print

=item * 1 ^ 1 = 0

(! present and matches) --> false, don't print

=back

As you can see, the first pair applies when C<!> isn't supplied, and
the second pair applies when it is. The XOR simply allows us to
compact a more complicated if-then-elseif-else into a more elegant
(but perhaps overly clever) single test. After all, it needed this
explanation...

=head2 FLAGS, FLAGS, FLAGS

There is a certain C programming legacy in the debugger. Some variables,
such as C<$single>, C<$trace>, and C<$frame>, have I<magical> values composed
of 1, 2, 4, etc. (powers of 2) OR'ed together. This allows several pieces
of state to be stored independently in a single scalar.

A test like

    if ($scalar & 4) ...

is checking to see if the appropriate bit is on. Since each bit can be
"addressed" independently in this way, C<$scalar> is acting sort of like
an array of bits. Obviously, since the contents of C<$scalar> are just a
bit-pattern, we can save and restore it easily (it will just look like
a number).

The problem, is of course, that this tends to leave magic numbers scattered
all over your program whenever a bit is set, cleared, or checked. So why do
it?

=over 4

=item *

First, doing an arithmetical or bitwise operation on a scalar is
just about the fastest thing you can do in Perl: C<use constant> actually
creates a subroutine call, and array and hash lookups are much slower. Is
this over-optimization at the expense of readability? Possibly, but the
debugger accesses these  variables a I<lot>. Any rewrite of the code will
probably have to benchmark alternate implementations and see which is the
best balance of readability and speed, and then document how it actually
works.

=item *

Second, it's very easy to serialize a scalar number. This is done in
the restart code; the debugger state variables are saved in C<%ENV> and then
restored when the debugger is restarted. Having them be just numbers makes
this trivial.

=item *

Third, some of these variables are being shared with the Perl core
smack in the middle of the interpreter's execution loop. It's much faster for
a C program (like the interpreter) to check a bit in a scalar than to access
several different variables (or a Perl array).

=back

=head2 What are those C<XXX> comments for?

Any comment containing C<XXX> means that the comment is either somewhat
speculative - it's not exactly clear what a given variable or chunk of
code is doing, or that it is incomplete - the basics may be clear, but the
subtleties are not completely documented.

Send in a patch if you can clear up, fill out, or clarify an C<XXX>.

=head1 DATA STRUCTURES MAINTAINED BY CORE

There are a number of special data structures provided to the debugger by
the Perl interpreter.

The array C<@@{$main::{'_<'.$filename}}> (aliased locally to C<@@dbline>
via glob assignment) contains the text from C<$filename>, with each
element corresponding to a single line of C<$filename>. Additionally,
breakable lines will be dualvars with the numeric component being the
memory address of a COP node. Non-breakable lines are dualvar to 0.

The hash C<%{'_<'.$filename}> (aliased locally to C<%dbline> via glob
assignment) contains breakpoints and actions.  The keys are line numbers;
you can set individual values, but not the whole hash. The Perl interpreter
uses this hash to determine where breakpoints have been set. Any true value is
considered to be a breakpoint; C<perl5db.pl> uses C<$break_condition\0$action>.
Values are magical in numeric context: 1 if the line is breakable, 0 if not.

The scalar C<${"_<$filename"}> simply contains the string C<$filename>.
This is also the case for evaluated strings that contain subroutines, or
which are currently being executed.  The $filename for C<eval>ed strings looks
like C<(eval 34)>.

=head1 DEBUGGER STARTUP

When C<perl5db.pl> starts, it reads an rcfile (C<perl5db.ini> for
non-interactive sessions, C<.perldb> for interactive ones) that can set a number
of options. In addition, this file may define a subroutine C<&afterinit>
that will be executed (in the debugger's context) after the debugger has
initialized itself.

Next, it checks the C<PERLDB_OPTS> environment variable and treats its
contents as the argument of a C<o> command in the debugger.

=head2 STARTUP-ONLY OPTIONS

The following options can only be specified at startup.
To set them in your rcfile, add a call to
C<&parse_options("optionName=new_value")>.

=over 4

=item * TTY

the TTY to use for debugging i/o.

=item * noTTY

if set, goes in NonStop mode.  On interrupt, if TTY is not set,
uses the value of noTTY or F<$HOME/.perldbtty$$> to find TTY using
Term::Rendezvous.  Current variant is to have the name of TTY in this
file.

=item * ReadLine

if false, a dummy ReadLine is used, so you can debug
ReadLine applications.

=item * NonStop

if true, no i/o is performed until interrupt.

=item * LineInfo

file or pipe to print line number info to.  If it is a
pipe, a short "emacs like" message is used.

=item * RemotePort

host:port to connect to on remote host for remote debugging.

=item * HistFile

file to store session history to. There is no default and so no
history file is written unless this variable is explicitly set.

=item * HistSize

number of commands to store to the file specified in C<HistFile>.
Default is 100.

=back

=head3 SAMPLE RCFILE

 &parse_options("NonStop=1 LineInfo=db.out");
  sub afterinit { $trace = 1; }

The script will run without human intervention, putting trace
information into C<db.out>.  (If you interrupt it, you had better
reset C<LineInfo> to something I<interactive>!)

=head1 INTERNALS DESCRIPTION

=head2 DEBUGGER INTERFACE VARIABLES

Perl supplies the values for C<%sub>.  It effectively inserts
a C<&DB::DB();> in front of each place that can have a
breakpoint. At each subroutine call, it calls C<&DB::sub> with
C<$DB::sub> set to the called subroutine. It also inserts a C<BEGIN
{require 'perl5db.pl'}> before the first line.

After each C<require>d file is compiled, but before it is executed, a
call to C<&DB::postponed($main::{'_<'.$filename})> is done. C<$filename>
is the expanded name of the C<require>d file (as found via C<%INC>).

=head3 IMPORTANT INTERNAL VARIABLES

=head4 C<$CreateTTY>

Used to control when the debugger will attempt to acquire another TTY to be
used for input.

=over

=item * 1 -  on C<fork()>

=item * 2 - debugger is started inside debugger

=item * 4 -  on startup

=back

=head4 C<$doret>

The value -2 indicates that no return value should be printed.
Any other positive value causes C<DB::sub> to print return values.

=head4 C<$evalarg>

The item to be eval'ed by C<DB::eval>. Used to prevent messing with the current
contents of C<@@_> when C<DB::eval> is called.

=head4 C<$frame>

Determines what messages (if any) will get printed when a subroutine (or eval)
is entered or exited.

=over 4

=item * 0 -  No enter/exit messages

=item * 1 - Print I<entering> messages on subroutine entry

=item * 2 - Adds exit messages on subroutine exit. If no other flag is on, acts like 1+2.

=item * 4 - Extended messages: C<< <in|out> I<context>=I<fully-qualified sub name> from I<file>:I<line> >>. If no other flag is on, acts like 1+4.

=item * 8 - Adds parameter information to messages, and overloaded stringify and tied FETCH is enabled on the printed arguments. Ignored if C<4> is not on.

=item * 16 - Adds C<I<context> return from I<subname>: I<value>> messages on subroutine/eval exit. Ignored if C<4> is not on.

=back

To get everything, use C<$frame=30> (or C<o f=30> as a debugger command).
The debugger internally juggles the value of C<$frame> during execution to
protect external modules that the debugger uses from getting traced.

=head4 C<$level>

Tracks current debugger nesting level. Used to figure out how many
C<E<lt>E<gt>> pairs to surround the line number with when the debugger
outputs a prompt. Also used to help determine if the program has finished
during command parsing.

=head4 C<$onetimeDump>

Controls what (if anything) C<DB::eval()> will print after evaluating an
expression.

=over 4

=item * C<undef> - don't print anything

=item * C<dump> - use C<dumpvar.pl> to display the value returned

=item * C<methods> - print the methods callable on the first item returned

=back

=head4 C<$onetimeDumpDepth>

Controls how far down C<dumpvar.pl> will go before printing C<...> while
dumping a structure. Numeric. If C<undef>, print all levels.

=head4 C<$signal>

Used to track whether or not an C<INT> signal has been detected. C<DB::DB()>,
which is called before every statement, checks this and puts the user into
command mode if it finds C<$signal> set to a true value.

=head4 C<$single>

Controls behavior during single-stepping. Stacked in C<@@stack> on entry to
each subroutine; popped again at the end of each subroutine.

=over 4

=item * 0 - run continuously.

=item * 1 - single-step, go into subs. The C<s> command.

=item * 2 - single-step, don't go into subs. The C<n> command.

=item * 4 - print current sub depth (turned on to force this when C<too much
recursion> occurs.

=back

=head4 C<$trace>

Controls the output of trace information.

=over 4

=item * 1 - The C<t> command was entered to turn on tracing (every line executed is printed)

=item * 2 - watch expressions are active

=item * 4 - user defined a C<watchfunction()> in C<afterinit()>

=back

=head4 C<$slave_editor>

1 if C<LINEINFO> was directed to a pipe; 0 otherwise.

=head4 C<@@cmdfhs>

Stack of filehandles that C<DB::readline()> will read commands from.
Manipulated by the debugger's C<source> command and C<DB::readline()> itself.

=head4 C<@@dbline>

Local alias to the magical line array, C<@@{$main::{'_<'.$filename}}> ,
supplied by the Perl interpreter to the debugger. Contains the source.

=head4 C<@@old_watch>

Previous values of watch expressions. First set when the expression is
entered; reset whenever the watch expression changes.

=head4 C<@@saved>

Saves important globals (C<$@@>, C<$!>, C<$^E>, C<$,>, C<$/>, C<$\>, C<$^W>)
so that the debugger can substitute safe values while it's running, and
restore them when it returns control.

=head4 C<@@stack>

Saves the current value of C<$single> on entry to a subroutine.
Manipulated by the C<c> command to turn off tracing in all subs above the
current one.

=head4 C<@@to_watch>

The 'watch' expressions: to be evaluated before each line is executed.

=head4 C<@@typeahead>

The typeahead buffer, used by C<DB::readline>.

=head4 C<%alias>

Command aliases. Stored as character strings to be substituted for a command
entered.

=head4 C<%break_on_load>

Keys are file names, values are 1 (break when this file is loaded) or undef
(don't break when it is loaded).

=head4 C<%dbline>

Keys are line numbers, values are C<condition\0action>. If used in numeric
context, values are 0 if not breakable, 1 if breakable, no matter what is
in the actual hash entry.

=head4 C<%had_breakpoints>

Keys are file names; values are bitfields:

=over 4

=item * 1 - file has a breakpoint in it.

=item * 2 - file has an action in it.

=back

A zero or undefined value means this file has neither.

=head4 C<%option>

Stores the debugger options. These are character string values.

=head4 C<%postponed>

Saves breakpoints for code that hasn't been compiled yet.
Keys are subroutine names, values are:

=over 4

=item * C<compile> - break when this sub is compiled

=item * C<< break +0 if <condition> >> - break (conditionally) at the start of this routine. The condition will be '1' if no condition was specified.

=back

=head4 C<%postponed_file>

This hash keeps track of breakpoints that need to be set for files that have
not yet been compiled. Keys are filenames; values are references to hashes.
Each of these hashes is keyed by line number, and its values are breakpoint
definitions (C<condition\0action>).

=head1 DEBUGGER INITIALIZATION

The debugger's initialization actually jumps all over the place inside this
package. This is because there are several BEGIN blocks (which of course
execute immediately) spread through the code. Why is that?

The debugger needs to be able to change some things and set some things up
before the debugger code is compiled; most notably, the C<$deep> variable that
C<DB::sub> uses to tell when a program has recursed deeply. In addition, the
debugger has to turn off warnings while the debugger code is compiled, but then
restore them to their original setting before the program being debugged begins
executing.

The first C<BEGIN> block simply turns off warnings by saving the current
setting of C<$^W> and then setting it to zero. The second one initializes
the debugger variables that are needed before the debugger begins executing.
The third one puts C<$^X> back to its former value.

We'll detail the second C<BEGIN> block later; just remember that if you need
to initialize something before the debugger starts really executing, that's
where it has to go.

=cut

package DB;

use strict;

use Cwd ();

my $_initial_cwd;

BEGIN {eval 'use IO::Handle'}; # Needed for flush only? breaks under miniperl

BEGIN {
    require feature;
    $^V =~ /^v(\d+\.\d+)/;
    feature->import(":$1");
    $_initial_cwd = Cwd::getcwd();
}

# Debugger for Perl 5.00x; perl5db.pl patch level:
use vars qw($VERSION $header);

$VERSION = '1.49_05';

$header = "perl5db.pl version $VERSION";

=head1 DEBUGGER ROUTINES

=head2 C<DB::eval()>

This function replaces straight C<eval()> inside the debugger; it simplifies
the process of evaluating code in the user's context.

The code to be evaluated is passed via the package global variable
C<$DB::evalarg>; this is done to avoid fiddling with the contents of C<@@_>.

Before we do the C<eval()>, we preserve the current settings of C<$trace>,
C<$single>, C<$^D> and C<$usercontext>.  The latter contains the
preserved values of C<$@@>, C<$!>, C<$^E>, C<$,>, C<$/>, C<$\>, C<$^W> and the
user's current package, grabbed when C<DB::DB> got control.  This causes the
proper context to be used when the eval is actually done.  Afterward, we
restore C<$trace>, C<$single>, and C<$^D>.

Next we need to handle C<$@@> without getting confused. We save C<$@@> in a
local lexical, localize C<$saved[0]> (which is where C<save()> will put
C<$@@>), and then call C<save()> to capture C<$@@>, C<$!>, C<$^E>, C<$,>,
C<$/>, C<$\>, and C<$^W>) and set C<$,>, C<$/>, C<$\>, and C<$^W> to values
considered sane by the debugger. If there was an C<eval()> error, we print
it on the debugger's output. If C<$onetimedump> is defined, we call
C<dumpit> if it's set to 'dump', or C<methods> if it's set to
'methods'. Setting it to something else causes the debugger to do the eval
but not print the result - handy if you want to do something else with it
(the "watch expressions" code does this to get the value of the watch
expression but not show it unless it matters).

In any case, we then return the list of output from C<eval> to the caller,
and unwinding restores the former version of C<$@@> in C<@@saved> as well
(the localization of C<$saved[0]> goes away at the end of this scope).

=head3 Parameters and variables influencing execution of DB::eval()

C<DB::eval> isn't parameterized in the standard way; this is to keep the
debugger's calls to C<DB::eval()> from mucking with C<@@_>, among other things.
The variables listed below influence C<DB::eval()>'s execution directly.

=over 4

=item C<$evalarg> - the thing to actually be eval'ed

=item C<$trace> - Current state of execution tracing

=item C<$single> - Current state of single-stepping

=item C<$onetimeDump> - what is to be displayed after the evaluation

=item C<$onetimeDumpDepth> - how deep C<dumpit()> should go when dumping results

=back

The following variables are altered by C<DB::eval()> during its execution. They
are "stacked" via C<local()>, enabling recursive calls to C<DB::eval()>.

=over 4

=item C<@@res> - used to capture output from actual C<eval>.

=item C<$otrace> - saved value of C<$trace>.

=item C<$osingle> - saved value of C<$single>.

=item C<$od> - saved value of C<$^D>.

=item C<$saved[0]> - saved value of C<$@@>.

=item $\ - for output of C<$@@> if there is an evaluation error.

=back

=head3 The problem of lexicals

The context of C<DB::eval()> presents us with some problems. Obviously,
we want to be 'sandboxed' away from the debugger's internals when we do
the eval, but we need some way to control how punctuation variables and
debugger globals are used.

We can't use local, because the code inside C<DB::eval> can see localized
variables; and we can't use C<my> either for the same reason. The code
in this routine compromises and uses C<my>.

After this routine is over, we don't have user code executing in the debugger's
context, so we can use C<my> freely.

=cut

############################################## Begin lexical danger zone

# 'my' variables used here could leak into (that is, be visible in)
# the context that the code being evaluated is executing in. This means that
# the code could modify the debugger's variables.
#
# Fiddling with the debugger's context could be Bad. We insulate things as
# much as we can.

use vars qw(
    @@args
    %break_on_load
    $CommandSet
    $CreateTTY
    $DBGR
    @@dbline
    $dbline
    %dbline
    $dieLevel
    $filename
    $histfile
    $histsize
    $IN
    $inhibit_exit
    @@ini_INC
    $ini_warn
    $maxtrace
    $od
    @@options
    $osingle
    $otrace
    $pager
    $post
    %postponed
    $prc
    $pre
    $pretype
    $psh
    @@RememberOnROptions
    $remoteport
    @@res
    $rl
    @@saved
    $signalLevel
    $sub
    $term
    $usercontext
    $warnLevel
);

our (
    @@cmdfhs,
    $evalarg,
    $frame,
    $hist,
    $ImmediateStop,
    $line,
    $onetimeDump,
    $onetimedumpDepth,
    %option,
    $OUT,
    $packname,
    $signal,
    $single,
    $start,
    %sub,
    $subname,
    $trace,
    $window,
);

# Used to save @@ARGV and extract any debugger-related flags.
use vars qw(@@ARGS);

# Used to prevent multiple entries to diesignal()
# (if for instance diesignal() itself dies)
use vars qw($panic);

# Used to prevent the debugger from running nonstop
# after a restart
our ($second_time);

sub _calc_usercontext {
    my ($package) = @@_;

    # Cancel strict completely for the evaluated code, so the code
    # the user evaluates won't be affected by it. (Shlomi Fish)
    return 'no strict; ($@@, $!, $^E, $,, $/, $\, $^W) = @@DB::saved;'
    . "package $package;";    # this won't let them modify, alas
}

sub eval {

    # 'my' would make it visible from user code
    #    but so does local! --tchrist
    # Remember: this localizes @@DB::res, not @@main::res.
    local @@res;
    {

        # Try to keep the user code from messing  with us. Save these so that
        # even if the eval'ed code changes them, we can put them back again.
        # Needed because the user could refer directly to the debugger's
        # package globals (and any 'my' variables in this containing scope)
        # inside the eval(), and we want to try to stay safe.
        local $otrace  = $trace;
        local $osingle = $single;
        local $od      = $^D;

        # Untaint the incoming eval() argument.
        { ($evalarg) = $evalarg =~ /(.*)/s; }

        # $usercontext built in DB::DB near the comment
        # "set up the context for DB::eval ..."
        # Evaluate and save any results.
        @@res = eval "$usercontext $evalarg;\n";  # '\n' for nice recursive debug

        # Restore those old values.
        $trace  = $otrace;
        $single = $osingle;
        $^D     = $od;
    }

    # Save the current value of $@@, and preserve it in the debugger's copy
    # of the saved precious globals.
    my $at = $@@;

    # Since we're only saving $@@, we only have to localize the array element
    # that it will be stored in.
    local $saved[0];    # Preserve the old value of $@@
    eval { &DB::save };

    # Now see whether we need to report an error back to the user.
    if ($at) {
        local $\ = '';
        print $OUT $at;
    }

    # Display as required by the caller. $onetimeDump and $onetimedumpDepth
    # are package globals.
    elsif ($onetimeDump) {
        if ( $onetimeDump eq 'dump' ) {
            local $option{dumpDepth} = $onetimedumpDepth
              if defined $onetimedumpDepth;
            dumpit( $OUT, \@@res );
        }
        elsif ( $onetimeDump eq 'methods' ) {
            methods( $res[0] );
        }
    } ## end elsif ($onetimeDump)
    @@res;
} ## end sub eval

############################################## End lexical danger zone

# After this point it is safe to introduce lexicals.
# The code being debugged will be executing in its own context, and
# can't see the inside of the debugger.
#
# However, one should not overdo it: leave as much control from outside as
# possible. If you make something a lexical, it's not going to be addressable
# from outside the debugger even if you know its name.

# This file is automatically included if you do perl -d.
# It's probably not useful to include this yourself.
#
# Before venturing further into these twisty passages, it is
# wise to read the perldebguts man page or risk the ire of dragons.
#
# (It should be noted that perldebguts will tell you a lot about
# the underlying mechanics of how the debugger interfaces into the
# Perl interpreter, but not a lot about the debugger itself. The new
# comments in this code try to address this problem.)

# Note that no subroutine call is possible until &DB::sub is defined
# (for subroutines defined outside of the package DB). In fact the same is
# true if $deep is not defined.

# Enhanced by ilya@@math.ohio-state.edu (Ilya Zakharevich)

# modified Perl debugger, to be run from Emacs in perldb-mode
# Ray Lischner (uunet!mntgfx!lisch) as of 5 Nov 1990
# Johan Vromans -- upgrade to 4.0 pl 10
# Ilya Zakharevich -- patches after 5.001 (and some before ;-)
########################################################################

=head1 DEBUGGER INITIALIZATION

The debugger starts up in phases.

=head2 BASIC SETUP

First, it initializes the environment it wants to run in: turning off
warnings during its own compilation, defining variables which it will need
to avoid warnings later, setting itself up to not exit when the program
terminates, and defaulting to printing return values for the C<r> command.

=cut

# Needed for the statement after exec():
#
# This BEGIN block is simply used to switch off warnings during debugger
# compilation. Probably it would be better practice to fix the warnings,
# but this is how it's done at the moment.

BEGIN {
    $ini_warn = $^W;
    $^W       = 0;
}    # Switch compilation warnings off until another BEGIN.

local ($^W) = 0;    # Switch run-time warnings off during init.

=head2 THREADS SUPPORT

If we are running under a threaded Perl, we require threads and threads::shared
if the environment variable C<PERL5DB_THREADED> is set, to enable proper
threaded debugger control.  C<-dt> can also be used to set this.

Each new thread will be announced and the debugger prompt will always inform
you of each new thread created.  It will also indicate the thread id in which
we are currently running within the prompt like this:

    [tid] DB<$i>

Where C<[tid]> is an integer thread id and C<$i> is the familiar debugger
command prompt.  The prompt will show: C<[0]> when running under threads, but
not actually in a thread.  C<[tid]> is consistent with C<gdb> usage.

While running under threads, when you set or delete a breakpoint (etc.), this
will apply to all threads, not just the currently running one.  When you are
in a currently executing thread, you will stay there until it completes.  With
the current implementation it is not currently possible to hop from one thread
to another.

The C<e> and C<E> commands are currently fairly minimal - see C<h e> and C<h E>.

Note that threading support was built into the debugger as of Perl version
C<5.8.6> and debugger version C<1.2.8>.

=cut

BEGIN {
    # ensure we can share our non-threaded variables or no-op
    if ($ENV{PERL5DB_THREADED}) {
        require threads;
        require threads::shared;
        import threads::shared qw(share);
        $DBGR;
        share(\$DBGR);
        lock($DBGR);
        print "Threads support enabled\n";
    } else {
        *lock = sub(*) {};
        *share = sub(\[$@@%]) {};
    }
}

# These variables control the execution of 'dumpvar.pl'.
{
    package dumpvar;
    use vars qw(
    $hashDepth
    $arrayDepth
    $dumpDBFiles
    $dumpPackages
    $quoteHighBit
    $printUndef
    $globPrint
    $usageOnly
    );
}

# used to control die() reporting in diesignal()
{
    package Carp;
    use vars qw($CarpLevel);
}

# without threads, $filename is not defined until DB::DB is called
share($main::{'_<'.$filename}) if defined $filename;

# Command-line + PERLLIB:
# Save the contents of @@INC before they are modified elsewhere.
@@ini_INC = @@INC;

# This was an attempt to clear out the previous values of various
# trapped errors. Apparently it didn't help. XXX More info needed!
# $prevwarn = $prevdie = $prevbus = $prevsegv = ''; # Does not help?!

# We set these variables to safe values. We don't want to blindly turn
# off warnings, because other packages may still want them.
$trace = $signal = $single = 0;    # Uninitialized warning suppression
                                   # (local $^W cannot help - other packages!).

# Default to not exiting when program finishes; print the return
# value when the 'r' command is used to return from a subroutine.
$inhibit_exit = $option{PrintRet} = 1;

use vars qw($trace_to_depth);

# Default to 1E9 so it won't be limited to a certain recursion depth.
$trace_to_depth = 1E9;

=head1 OPTION PROCESSING

The debugger's options are actually spread out over the debugger itself and
C<dumpvar.pl>; some of these are variables to be set, while others are
subs to be called with a value. To try to make this a little easier to
manage, the debugger uses a few data structures to define what options
are legal and how they are to be processed.

First, the C<@@options> array defines the I<names> of all the options that
are to be accepted.

=cut

@@options = qw(
  CommandSet   HistFile      HistSize
  hashDepth    arrayDepth    dumpDepth
  DumpDBFiles  DumpPackages  DumpReused
  compactDump  veryCompact   quote
  HighBit      undefPrint    globPrint
  PrintRet     UsageOnly     frame
  AutoTrace    TTY           noTTY
  ReadLine     NonStop       LineInfo
  maxTraceLen  recallCommand ShellBang
  pager        tkRunning     ornaments
  signalLevel  warnLevel     dieLevel
  inhibit_exit ImmediateStop bareStringify
  CreateTTY    RemotePort    windowSize
  DollarCaretP
);

@@RememberOnROptions = qw(DollarCaretP);

=pod

Second, C<optionVars> lists the variables that each option uses to save its
state.

=cut

use vars qw(%optionVars);

%optionVars = (
    hashDepth     => \$dumpvar::hashDepth,
    arrayDepth    => \$dumpvar::arrayDepth,
    CommandSet    => \$CommandSet,
    DumpDBFiles   => \$dumpvar::dumpDBFiles,
    DumpPackages  => \$dumpvar::dumpPackages,
    DumpReused    => \$dumpvar::dumpReused,
    HighBit       => \$dumpvar::quoteHighBit,
    undefPrint    => \$dumpvar::printUndef,
    globPrint     => \$dumpvar::globPrint,
    UsageOnly     => \$dumpvar::usageOnly,
    CreateTTY     => \$CreateTTY,
    bareStringify => \$dumpvar::bareStringify,
    frame         => \$frame,
    AutoTrace     => \$trace,
    inhibit_exit  => \$inhibit_exit,
    maxTraceLen   => \$maxtrace,
    ImmediateStop => \$ImmediateStop,
    RemotePort    => \$remoteport,
    windowSize    => \$window,
    HistFile      => \$histfile,
    HistSize      => \$histsize,
);

=pod

Third, C<%optionAction> defines the subroutine to be called to process each
option.

=cut

use vars qw(%optionAction);

%optionAction = (
    compactDump   => \&dumpvar::compactDump,
    veryCompact   => \&dumpvar::veryCompact,
    quote         => \&dumpvar::quote,
    TTY           => \&TTY,
    noTTY         => \&noTTY,
    ReadLine      => \&ReadLine,
    NonStop       => \&NonStop,
    LineInfo      => \&LineInfo,
    recallCommand => \&recallCommand,
    ShellBang     => \&shellBang,
    pager         => \&pager,
    signalLevel   => \&signalLevel,
    warnLevel     => \&warnLevel,
    dieLevel      => \&dieLevel,
    tkRunning     => \&tkRunning,
    ornaments     => \&ornaments,
    RemotePort    => \&RemotePort,
    DollarCaretP  => \&DollarCaretP,
);

=pod

Last, the C<%optionRequire> notes modules that must be C<require>d if an
option is used.

=cut

# Note that this list is not complete: several options not listed here
# actually require that dumpvar.pl be loaded for them to work, but are
# not in the table. A subsequent patch will correct this problem; for
# the moment, we're just recommenting, and we are NOT going to change
# function.
use vars qw(%optionRequire);

%optionRequire = (
    compactDump => 'dumpvar.pl',
    veryCompact => 'dumpvar.pl',
    quote       => 'dumpvar.pl',
);

=pod

There are a number of initialization-related variables which can be set
by putting code to set them in a BEGIN block in the C<PERL5DB> environment
variable. These are:

=over 4

=item C<$rl> - readline control XXX needs more explanation

=item C<$warnLevel> - whether or not debugger takes over warning handling

=item C<$dieLevel> - whether or not debugger takes over die handling

=item C<$signalLevel> - whether or not debugger takes over signal handling

=item C<$pre> - preprompt actions (array reference)

=item C<$post> - postprompt actions (array reference)

=item C<$pretype>

=item C<$CreateTTY> - whether or not to create a new TTY for this debugger

=item C<$CommandSet> - which command set to use (defaults to new, documented set)

=back

=cut

# These guys may be defined in $ENV{PERL5DB} :
$rl          = 1     unless defined $rl;
$warnLevel   = 1     unless defined $warnLevel;
$dieLevel    = 1     unless defined $dieLevel;
$signalLevel = 1     unless defined $signalLevel;
$pre         = []    unless defined $pre;
$post        = []    unless defined $post;
$pretype     = []    unless defined $pretype;
$CreateTTY   = 3     unless defined $CreateTTY;
$CommandSet  = '580' unless defined $CommandSet;

share($rl);
share($warnLevel);
share($dieLevel);
share($signalLevel);
share($pre);
share($post);
share($pretype);
share($rl);
share($CreateTTY);
share($CommandSet);

=pod

The default C<die>, C<warn>, and C<signal> handlers are set up.

=cut

warnLevel($warnLevel);
dieLevel($dieLevel);
signalLevel($signalLevel);

=pod

The pager to be used is needed next. We try to get it from the
environment first.  If it's not defined there, we try to find it in
the Perl C<Config.pm>.  If it's not there, we default to C<more>. We
then call the C<pager()> function to save the pager name.

=cut

# This routine makes sure $pager is set up so that '|' can use it.
pager(

    # If PAGER is defined in the environment, use it.
    defined $ENV{PAGER}
    ? $ENV{PAGER}

      # If not, see if Config.pm defines it.
    : eval { require Config }
      && defined $Config::Config{pager}
    ? $Config::Config{pager}

      # If not, fall back to 'more'.
    : 'more'
  )
  unless defined $pager;

=pod

We set up the command to be used to access the man pages, the command
recall character (C<!> unless otherwise defined) and the shell escape
character (C<!> unless otherwise defined). Yes, these do conflict, and
neither works in the debugger at the moment.

=cut

setman();

# Set up defaults for command recall and shell escape (note:
# these currently don't work in linemode debugging).
recallCommand("!") unless defined $prc;
shellBang("!")     unless defined $psh;

=pod

We then set up the gigantic string containing the debugger help.
We also set the limit on the number of arguments we'll display during a
trace.

=cut

sethelp();

# If we didn't get a default for the length of eval/stack trace args,
# set it here.
$maxtrace = 400 unless defined $maxtrace;

=head2 SETTING UP THE DEBUGGER GREETING

The debugger I<greeting> helps to inform the user how many debuggers are
running, and whether the current debugger is the primary or a child.

If we are the primary, we just hang onto our pid so we'll have it when
or if we start a child debugger. If we are a child, we'll set things up
so we'll have a unique greeting and so the parent will give us our own
TTY later.

We save the current contents of the C<PERLDB_PIDS> environment variable
because we mess around with it. We'll also need to hang onto it because
we'll need it if we restart.

Child debuggers make a label out of the current PID structure recorded in
PERLDB_PIDS plus the new PID. They also mark themselves as not having a TTY
yet so the parent will give them one later via C<resetterm()>.

=cut

# Save the current contents of the environment; we're about to
# much with it. We'll need this if we have to restart.
use vars qw($ini_pids);
$ini_pids = $ENV{PERLDB_PIDS};

use vars qw ($pids $term_pid);

if ( defined $ENV{PERLDB_PIDS} ) {

    # We're a child. Make us a label out of the current PID structure
    # recorded in PERLDB_PIDS plus our (new) PID. Mark us as not having
    # a term yet so the parent will give us one later via resetterm().

    my $env_pids = $ENV{PERLDB_PIDS};
    $pids = "[$env_pids]";

    # Unless we are on OpenVMS, all programs under the DCL shell run under
    # the same PID.

    if (($^O eq 'VMS') && ($env_pids =~ /\b$$\b/)) {
        $term_pid         = $$;
    }
    else {
        $ENV{PERLDB_PIDS} .= "->$$";
        $term_pid = -1;
    }

} ## end if (defined $ENV{PERLDB_PIDS...
else {

    # We're the parent PID. Initialize PERLDB_PID in case we end up with a
    # child debugger, and mark us as the parent, so we'll know to set up
    # more TTY's is we have to.
    $ENV{PERLDB_PIDS} = "$$";
    $pids             = "[pid=$$]";
    $term_pid         = $$;
}

use vars qw($pidprompt);
$pidprompt = '';

# Sets up $emacs as a synonym for $slave_editor.
our ($slave_editor);
*emacs = $slave_editor if $slave_editor;    # May be used in afterinit()...

=head2 READING THE RC FILE

The debugger will read a file of initialization options if supplied. If
running interactively, this is C<.perldb>; if not, it's C<perldb.ini>.

=cut

# As noted, this test really doesn't check accurately that the debugger
# is running at a terminal or not.

use vars qw($rcfile);
{
    my $dev_tty = (($^O eq 'VMS') ? 'TT:' : '/dev/tty');
    # this is the wrong metric!
    $rcfile = ((-e $dev_tty) ? ".perldb" : "perldb.ini");
}

=pod

The debugger does a safety test of the file to be read. It must be owned
either by the current user or root, and must only be writable by the owner.

=cut

# This wraps a safety test around "do" to read and evaluate the init file.
#
# This isn't really safe, because there's a race
# between checking and opening.  The solution is to
# open and fstat the handle, but then you have to read and
# eval the contents.  But then the silly thing gets
# your lexical scope, which is unfortunate at best.
sub safe_do {
    my $file = shift;

    # Just exactly what part of the word "CORE::" don't you understand?
    local $SIG{__WARN__};
    local $SIG{__DIE__};

    unless ( is_safe_file($file) ) {
        CORE::warn <<EO_GRIPE;
perldb: Must not source insecure rcfile $file.
        You or the superuser must be the owner, and it must not
        be writable by anyone but its owner.
EO_GRIPE
        return;
    } ## end unless (is_safe_file($file...

    do $file;
    CORE::warn("perldb: couldn't parse $file: $@@") if $@@;
} ## end sub safe_do

# This is the safety test itself.
#
# Verifies that owner is either real user or superuser and that no
# one but owner may write to it.  This function is of limited use
# when called on a path instead of upon a handle, because there are
# no guarantees that filename (by dirent) whose file (by ino) is
# eventually accessed is the same as the one tested.
# Assumes that the file's existence is not in doubt.
sub is_safe_file {
    my $path = shift;
    stat($path) || return;    # mysteriously vaporized
    my ( $dev, $ino, $mode, $nlink, $uid, $gid ) = stat(_);

    return 0 if $uid != 0 && $uid != $<;
    return 0 if $mode & 022;
    return 1;
} ## end sub is_safe_file

# If the rcfile (whichever one we decided was the right one to read)
# exists, we safely do it.
if ( -f $rcfile ) {
    safe_do("./$rcfile");
}

# If there isn't one here, try the user's home directory.
elsif ( defined $ENV{HOME} && -f "$ENV{HOME}/$rcfile" ) {
    safe_do("$ENV{HOME}/$rcfile");
}

# Else try the login directory.
elsif ( defined $ENV{LOGDIR} && -f "$ENV{LOGDIR}/$rcfile" ) {
    safe_do("$ENV{LOGDIR}/$rcfile");
}

# If the PERLDB_OPTS variable has options in it, parse those out next.
if ( defined $ENV{PERLDB_OPTS} ) {
    parse_options( $ENV{PERLDB_OPTS} );
}

=pod

The last thing we do during initialization is determine which subroutine is
to be used to obtain a new terminal when a new debugger is started. Right now,
the debugger only handles TCP sockets, X11, OS/2, amd Mac OS X
(darwin).

=cut

# Set up the get_fork_TTY subroutine to be aliased to the proper routine.
# Works if you're running an xterm or xterm-like window, or you're on
# OS/2, or on Mac OS X. This may need some expansion.

if (not defined &get_fork_TTY)       # only if no routine exists
{
    if ( defined $remoteport ) {
                                                 # Expect an inetd-like server
        *get_fork_TTY = \&socket_get_fork_TTY;   # to listen to us
    }
    elsif (defined $ENV{TERM}                    # If we know what kind
                                                 # of terminal this is,
        and $ENV{TERM} eq 'xterm'                # and it's an xterm,
        and defined $ENV{DISPLAY}                # and what display it's on,
      )
    {
        *get_fork_TTY = \&xterm_get_fork_TTY;    # use the xterm version
    }
    elsif ( $ENV{TMUX} ) {
        *get_fork_TTY = \&tmux_get_fork_TTY;
    }
    elsif ( $^O eq 'os2' ) {                     # If this is OS/2,
        *get_fork_TTY = \&os2_get_fork_TTY;      # use the OS/2 version
    }
    elsif ( $^O eq 'darwin'                      # If this is Mac OS X
            and defined $ENV{TERM_PROGRAM}       # and we're running inside
            and $ENV{TERM_PROGRAM}
                eq 'Apple_Terminal'              # Terminal.app
            )
    {
        *get_fork_TTY = \&macosx_get_fork_TTY;   # use the Mac OS X version
    }
} ## end if (not defined &get_fork_TTY...

# untaint $^O, which may have been tainted by the last statement.
# see bug [perl #24674]
$^O =~ m/^(.*)\z/;
$^O = $1;

# Here begin the unreadable code.  It needs fixing.

=head2 RESTART PROCESSING

This section handles the restart command. When the C<R> command is invoked, it
tries to capture all of the state it can into environment variables, and
then sets C<PERLDB_RESTART>. When we start executing again, we check to see
if C<PERLDB_RESTART> is there; if so, we reload all the information that
the R command stuffed into the environment variables.

  PERLDB_RESTART   - flag only, contains no restart data itself.
  PERLDB_HIST      - command history, if it's available
  PERLDB_ON_LOAD   - breakpoints set by the rc file
  PERLDB_POSTPONE  - subs that have been loaded/not executed,
                     and have actions
  PERLDB_VISITED   - files that had breakpoints
  PERLDB_FILE_...  - breakpoints for a file
  PERLDB_OPT       - active options
  PERLDB_INC       - the original @@INC
  PERLDB_PRETYPE   - preprompt debugger actions
  PERLDB_PRE       - preprompt Perl code
  PERLDB_POST      - post-prompt Perl code
  PERLDB_TYPEAHEAD - typeahead captured by readline()

We chug through all these variables and plug the values saved in them
back into the appropriate spots in the debugger.

=cut

use vars qw(%postponed_file @@typeahead);

our (@@hist, @@truehist);

sub _restore_shared_globals_after_restart
{
    @@hist          = get_list('PERLDB_HIST');
    %break_on_load = get_list("PERLDB_ON_LOAD");
    %postponed     = get_list("PERLDB_POSTPONE");

    share(@@hist);
    share(@@truehist);
    share(%break_on_load);
    share(%postponed);
}

sub _restore_breakpoints_and_actions {

    my @@had_breakpoints = get_list("PERLDB_VISITED");

    for my $file_idx ( 0 .. $#had_breakpoints ) {
        my $filename = $had_breakpoints[$file_idx];
        my %pf = get_list("PERLDB_FILE_$file_idx");
        $postponed_file{ $filename } = \%pf if %pf;
        my @@lines = sort {$a <=> $b} keys(%pf);
        my @@enabled_statuses = get_list("PERLDB_FILE_ENABLED_$file_idx");
        for my $line_idx (0 .. $#lines) {
            _set_breakpoint_enabled_status(
                $filename,
                $lines[$line_idx],
                ($enabled_statuses[$line_idx] ? 1 : ''),
            );
        }
    }

    return;
}

sub _restore_options_after_restart
{
    my %options_map = get_list("PERLDB_OPT");

    while ( my ( $opt, $val ) = each %options_map ) {
        $val =~ s/[\\\']/\\$1/g;
        parse_options("$opt'$val'");
    }

    return;
}

sub _restore_globals_after_restart
{
    # restore original @@INC
    @@INC     = get_list("PERLDB_INC");
    @@ini_INC = @@INC;

    # return pre/postprompt actions and typeahead buffer
    $pretype   = [ get_list("PERLDB_PRETYPE") ];
    $pre       = [ get_list("PERLDB_PRE") ];
    $post      = [ get_list("PERLDB_POST") ];
    @@typeahead = get_list( "PERLDB_TYPEAHEAD", @@typeahead );

    return;
}


if ( exists $ENV{PERLDB_RESTART} ) {

    # We're restarting, so we don't need the flag that says to restart anymore.
    delete $ENV{PERLDB_RESTART};

    # $restart = 1;
    _restore_shared_globals_after_restart();

    _restore_breakpoints_and_actions();

    # restore options
    _restore_options_after_restart();

    _restore_globals_after_restart();
} ## end if (exists $ENV{PERLDB_RESTART...

=head2 SETTING UP THE TERMINAL

Now, we'll decide how the debugger is going to interact with the user.
If there's no TTY, we set the debugger to run non-stop; there's not going
to be anyone there to enter commands.

=cut

use vars qw($notty $console $tty $LINEINFO);
use vars qw($lineinfo $doccmd);

our ($runnonstop);

# Local autoflush to avoid rt#116769,
# as calling IO::File methods causes an unresolvable loop
# that results in debugger failure.
sub _autoflush {
    my $o = select($_[0]);
    $|++;
    select($o);
}

if ($notty) {
    $runnonstop = 1;
    share($runnonstop);
}

=pod

If there is a TTY, we have to determine who it belongs to before we can
proceed. If this is a slave editor or graphical debugger (denoted by
the first command-line switch being '-emacs'), we shift this off and
set C<$rl> to 0 (XXX ostensibly to do straight reads).

=cut

else {

    # Is Perl being run from a slave editor or graphical debugger?
    # If so, don't use readline, and set $slave_editor = 1.
    if ($slave_editor = ( @@main::ARGV && ( $main::ARGV[0] eq '-emacs' ) )) {
        $rl = 0;
        shift(@@main::ARGV);
    }

    #require Term::ReadLine;

=pod

We then determine what the console should be on various systems:

=over 4

=item * Cygwin - We use C<stdin> instead of a separate device.

=cut

    if ( $^O eq 'cygwin' ) {

        # /dev/tty is binary. use stdin for textmode
        undef $console;
    }

=item * Unix - use F</dev/tty>.

=cut

    elsif ( -e "/dev/tty" ) {
        $console = "/dev/tty";
    }

=item * Windows or MSDOS - use C<con>.

=cut

    elsif ( $^O eq 'dos' or -e "con" or $^O eq 'MSWin32' ) {
        $console = "con";
    }

=item * AmigaOS - use C<CONSOLE:>.

=cut

    elsif ( $^O eq 'amigaos' ) {
        $console = "CONSOLE:";
    }

=item * VMS - use C<sys$command>.

=cut

    elsif ($^O eq 'VMS') {
        $console = 'sys$command';
    }

# Keep this last.

    else {
        _db_warn("Can't figure out your console, using stdin");
        undef $console;
    }

=pod

=back

Several other systems don't use a specific console. We C<undef $console>
for those (Windows using a slave editor/graphical debugger, NetWare, OS/2
with a slave editor).

=cut

    if ( ( $^O eq 'MSWin32' ) and ( $slave_editor or defined $ENV{EMACS} ) ) {

        # /dev/tty is binary. use stdin for textmode
        $console = undef;
    }

    if ( $^O eq 'NetWare' ) {

        # /dev/tty is binary. use stdin for textmode
        $console = undef;
    }

    # In OS/2, we need to use STDIN to get textmode too, even though
    # it pretty much looks like Unix otherwise.
    if ( defined $ENV{OS2_SHELL} and ( $slave_editor or $ENV{WINDOWID} ) )
    {    # In OS/2
        $console = undef;
    }

=pod

If there is a TTY hanging around from a parent, we use that as the console.

=cut

    $console = $tty if defined $tty;

=head2 SOCKET HANDLING

The debugger is capable of opening a socket and carrying out a debugging
session over the socket.

If C<RemotePort> was defined in the options, the debugger assumes that it
should try to start a debugging session on that port. It builds the socket
and then tries to connect the input and output filehandles to it.

=cut

    # Handle socket stuff.

    if ( defined $remoteport ) {

        # If RemotePort was defined in the options, connect input and output
        # to the socket.
        $IN = $OUT = connect_remoteport();
    } ## end if (defined $remoteport)

=pod

If no C<RemotePort> was defined, and we want to create a TTY on startup,
this is probably a situation where multiple debuggers are running (for example,
a backticked command that starts up another debugger). We create a new IN and
OUT filehandle, and do the necessary mojo to create a new TTY if we know how
and if we can.

=cut

    # Non-socket.
    else {

        # Two debuggers running (probably a system or a backtick that invokes
        # the debugger itself under the running one). create a new IN and OUT
        # filehandle, and do the necessary mojo to create a new tty if we
        # know how, and we can.
        create_IN_OUT(4) if $CreateTTY & 4;
        if ($console) {

            # If we have a console, check to see if there are separate ins and
            # outs to open. (They are assumed identical if not.)

            my ( $i, $o ) = split /,/, $console;
            $o = $i unless defined $o;

            # read/write on in, or just read, or read on STDIN.
            open( IN,      "+<$i" )
              || open( IN, "<$i" )
              || open( IN, "<&STDIN" );

            # read/write/create/clobber out, or write/create/clobber out,
            # or merge with STDERR, or merge with STDOUT.
                 open( OUT, "+>$o" )
              || open( OUT, ">$o" )
              || open( OUT, ">&STDERR" )
              || open( OUT, ">&STDOUT" );    # so we don't dongle stdout

        } ## end if ($console)
        elsif ( not defined $console ) {

            # No console. Open STDIN.
            open( IN, "<&STDIN" );

            # merge with STDERR, or with STDOUT.
            open( OUT,      ">&STDERR" )
              || open( OUT, ">&STDOUT" );    # so we don't dongle stdout
            $console = 'STDIN/OUT';
        } ## end elsif (not defined $console)

        # Keep copies of the filehandles so that when the pager runs, it
        # can close standard input without clobbering ours.
        if ($console or (not defined($console))) {
            $IN = \*IN;
            $OUT = \*OUT;
        }
    } ## end elsif (from if(defined $remoteport))

    # Unbuffer DB::OUT. We need to see responses right away.
    _autoflush($OUT);

    # Line info goes to debugger output unless pointed elsewhere.
    # Pointing elsewhere makes it possible for slave editors to
    # keep track of file and position. We have both a filehandle
    # and a I/O description to keep track of.
    $LINEINFO = $OUT     unless defined $LINEINFO;
    $lineinfo = $console unless defined $lineinfo;
    # share($LINEINFO); # <- unable to share globs
    share($lineinfo);   #

=pod

To finish initialization, we show the debugger greeting,
and then call the C<afterinit()> subroutine if there is one.

=cut

    # Show the debugger greeting.
    $header =~ s/.Header: ([^,]+),v(\s+\S+\s+\S+).*$/$1$2/;
    unless ($runnonstop) {
        local $\ = '';
        local $, = '';
        if ( $term_pid eq '-1' ) {
            print $OUT "\nDaughter DB session started...\n";
        }
        else {
            print $OUT "\nLoading DB routines from $header\n";
            print $OUT (
                "Editor support ",
                $slave_editor ? "enabled" : "available", ".\n"
            );
            print $OUT
"\nEnter h or 'h h' for help, or '$doccmd perldebug' for more help.\n\n";
        } ## end else [ if ($term_pid eq '-1')
    } ## end unless ($runnonstop)
} ## end else [ if ($notty)

# XXX This looks like a bug to me.
# Why copy to @@ARGS and then futz with @@args?
@@ARGS = @@ARGV;
# for (@@args) {
    # Make sure backslashes before single quotes are stripped out, and
    # keep args unless they are numeric (XXX why?)
    # s/\'/\\\'/g;                      # removed while not justified understandably
    # s/(.*)/'$1'/ unless /^-?[\d.]+$/; # ditto
# }

# If there was an afterinit() sub defined, call it. It will get
# executed in our scope, so it can fiddle with debugger globals.
if ( defined &afterinit ) {    # May be defined in $rcfile
    afterinit();
}

# Inform us about "Stack dump during die enabled ..." in dieLevel().
use vars qw($I_m_init);

$I_m_init = 1;

############################################################ Subroutines

=head1 SUBROUTINES

=head2 DB

This gigantic subroutine is the heart of the debugger. Called before every
statement, its job is to determine if a breakpoint has been reached, and
stop if so; read commands from the user, parse them, and execute
them, and then send execution off to the next statement.

Note that the order in which the commands are processed is very important;
some commands earlier in the loop will actually alter the C<$cmd> variable
to create other commands to be executed later. This is all highly I<optimized>
but can be confusing. Check the comments for each C<$cmd ... && do {}> to
see what's happening in any given command.

=cut

# $cmd cannot be an our() variable unfortunately (possible perl bug?).

use vars qw(
    $action
    $cmd
    $file
    $filename_ini
    $finished
    %had_breakpoints
    $level
    $max
    $package
    $try
);

our (
    %alias,
    $doret,
    $end,
    $fall_off_end,
    $incr,
    $laststep,
    $rc,
    $sh,
    $stack_depth,
    @@stack,
    @@to_watch,
    @@old_watch,
);

sub _DB__determine_if_we_should_break
{
    # if we have something here, see if we should break.
    # $stop is lexical and local to this block - $action on the other hand
    # is global.
    my $stop;

    if ( $dbline{$line}
        && _is_breakpoint_enabled($filename, $line)
        && (( $stop, $action ) = split( /\0/, $dbline{$line} ) ) )
    {

        # Stop if the stop criterion says to just stop.
        if ( $stop eq '1' ) {
            $signal |= 1;
        }

        # It's a conditional stop; eval it in the user's context and
        # see if we should stop. If so, remove the one-time sigil.
        elsif ($stop) {
            $evalarg = "\$DB::signal |= 1 if do {$stop}";
            # The &-call is here to ascertain the mutability of @@_.
            &DB::eval;
            # If the breakpoint is temporary, then delete its enabled status.
            if ($dbline{$line} =~ s/;9($|\0)/$1/) {
                _cancel_breakpoint_temp_enabled_status($filename, $line);
            }
        }
    } ## end if ($dbline{$line} && ...
}

sub _DB__is_finished {
    if ($finished and $level <= 1) {
        end_report();
        return 1;
    }
    else {
        return;
    }
}

sub _DB__read_next_cmd
{
    my ($tid) = @@_;

    # We have a terminal, or can get one ...
    if (!$term) {
        setterm();
    }

    # ... and it belongs to this PID or we get one for this PID ...
    if ($term_pid != $$) {
        resetterm(1);
    }

    # ... and we got a line of command input ...
    $cmd = DB::readline(
        "$pidprompt $tid DB"
        . ( '<' x $level )
        . ( $#hist + 1 )
        . ( '>' x $level ) . " "
    );

    return defined($cmd);
}

sub _DB__trim_command_and_return_first_component {
    my ($obj) = @@_;

    $cmd =~ s/\A\s+//s;    # trim annoying leading whitespace
    $cmd =~ s/\s+\z//s;    # trim annoying trailing whitespace

    my ($verb, $args) = $cmd =~ m{\A(\S*)\s*(.*)}s;

    $obj->cmd_verb($verb);
    $obj->cmd_args($args);

    return;
}

sub _DB__handle_f_command {
    my ($obj) = @@_;

    if ($file = $obj->cmd_args) {
        # help for no arguments (old-style was return from sub).
        if ( !$file ) {
            print $OUT
            "The old f command is now the r command.\n";    # hint
            print $OUT "The new f command switches filenames.\n";
            next CMD;
        } ## end if (!$file)

        # if not in magic file list, try a close match.
        if ( !defined $main::{ '_<' . $file } ) {
            if ( ($try) = grep( m#^_<.*$file#, keys %main:: ) ) {
                {
                    $try = substr( $try, 2 );
                    print $OUT "Choosing $try matching '$file':\n";
                    $file = $try;
                }
            } ## end if (($try) = grep(m#^_<.*$file#...
        } ## end if (!defined $main::{ ...

        # If not successfully switched now, we failed.
        if ( !defined $main::{ '_<' . $file } ) {
            print $OUT "No file matching '$file' is loaded.\n";
            next CMD;
        }

        # We switched, so switch the debugger internals around.
        elsif ( $file ne $filename ) {
            *dbline   = $main::{ '_<' . $file };
            $max      = $#dbline;
            $filename = $file;
            $start    = 1;
            $cmd      = "l";
        } ## end elsif ($file ne $filename)

        # We didn't switch; say we didn't.
        else {
            print $OUT "Already in $file.\n";
            next CMD;
        }
    }

    return;
}

sub _DB__handle_dot_command {
    my ($obj) = @@_;

    # . command.
    if ($obj->_is_full('.')) {
        $incr = -1;    # stay at current line

        # Reset everything to the old location.
        $start    = $line;
        $filename = $filename_ini;
        *dbline   = $main::{ '_<' . $filename };
        $max      = $#dbline;

        # Now where are we?
        print_lineinfo($obj->position());
        next CMD;
    }

    return;
}

sub _DB__handle_y_command {
    my ($obj) = @@_;

    if (my ($match_level, $match_vars)
        = $obj->cmd_args =~ /\A(?:(\d*)\s*(.*))?\z/) {

        # See if we've got the necessary support.
        if (!eval {
            local @@INC = @@INC;
            pop @@INC if $INC[-1] eq '.';
            require PadWalker; PadWalker->VERSION(0.08) }) {
            my $Err = $@@;
            _db_warn(
                $Err =~ /locate/
                ? "PadWalker module not found - please install\n"
                : $Err
            );
            next CMD;
        }

        # Load up dumpvar if we don't have it. If we can, that is.
        do 'dumpvar.pl' || die $@@ unless defined &main::dumpvar;
        defined &main::dumpvar
            or print $OUT "dumpvar.pl not available.\n"
            and next CMD;

        # Got all the modules we need. Find them and print them.
        my @@vars = split( ' ', $match_vars || '' );

        # Find the pad.
        my $h = eval { PadWalker::peek_my( ( $match_level || 0 ) + 2 ) };

        # Oops. Can't find it.
        if (my $Err = $@@) {
            $Err =~ s/ at .*//;
            _db_warn($Err);
            next CMD;
        }

        # Show the desired vars with dumplex().
        my $savout = select($OUT);

        # Have dumplex dump the lexicals.
        foreach my $key (sort keys %$h) {
            dumpvar::dumplex( $key, $h->{$key},
                defined $option{dumpDepth} ? $option{dumpDepth} : -1,
                @@vars );
        }
        select($savout);
        next CMD;
    }
}

sub _DB__handle_c_command {
    my ($obj) = @@_;

    my $i = $obj->cmd_args;

    if ($i =~ m#\A[\w:]*\z#) {

        # Hey, show's over. The debugged program finished
        # executing already.
        next CMD if _DB__is_finished();

        # Capture the place to put a one-time break.
        $subname = $i;

        #  Probably not needed, since we finish an interactive
        #  sub-session anyway...
        # local $filename = $filename;
        # local *dbline = *dbline; # XXX Would this work?!
        #
        # The above question wonders if localizing the alias
        # to the magic array works or not. Since it's commented
        # out, we'll just leave that to speculation for now.

        # If the "subname" isn't all digits, we'll assume it
        # is a subroutine name, and try to find it.
        if ( $subname =~ /\D/ ) {    # subroutine name
            # Qualify it to the current package unless it's
            # already qualified.
            $subname = $package . "::" . $subname
            unless $subname =~ /::/;

            # find_sub will return "file:line_number" corresponding
            # to where the subroutine is defined; we call find_sub,
            # break up the return value, and assign it in one
            # operation.
            ( $file, $i ) = ( find_sub($subname) =~ /^(.*):(.*)$/ );

            # Force the line number to be numeric.
            $i = $i + 0;

            # If we got a line number, we found the sub.
            if ($i) {

                # Switch all the debugger's internals around so
                # we're actually working with that file.
                $filename = $file;
                *dbline   = $main::{ '_<' . $filename };

                # Mark that there's a breakpoint in this file.
                $had_breakpoints{$filename} |= 1;

                # Scan forward to the first executable line
                # after the 'sub whatever' line.
                $max = $#dbline;
                my $_line_num = $i;
                while ($dbline[$_line_num] == 0 && $_line_num< $max)
                {
                    $_line_num++;
                }
                $i = $_line_num;
            } ## end if ($i)

            # We didn't find a sub by that name.
            else {
                print $OUT "Subroutine $subname not found.\n";
                next CMD;
            }
        } ## end if ($subname =~ /\D/)

        # At this point, either the subname was all digits (an
        # absolute line-break request) or we've scanned through
        # the code following the definition of the sub, looking
        # for an executable, which we may or may not have found.
        #
        # If $i (which we set $subname from) is non-zero, we
        # got a request to break at some line somewhere. On
        # one hand, if there wasn't any real subroutine name
        # involved, this will be a request to break in the current
        # file at the specified line, so we have to check to make
        # sure that the line specified really is breakable.
        #
        # On the other hand, if there was a subname supplied, the
        # preceding block has moved us to the proper file and
        # location within that file, and then scanned forward
        # looking for the next executable line. We have to make
        # sure that one was found.
        #
        # On the gripping hand, we can't do anything unless the
        # current value of $i points to a valid breakable line.
        # Check that.
        if ($i) {

            # Breakable?
            if ( $dbline[$i] == 0 ) {
                print $OUT "Line $i not breakable.\n";
                next CMD;
            }

            # Yes. Set up the one-time-break sigil.
            $dbline{$i} =~ s/($|\0)/;9$1/;  # add one-time-only b.p.
            _enable_breakpoint_temp_enabled_status($filename, $i);
        } ## end if ($i)

        # Turn off stack tracing from here up.
        for my $j (0 .. $stack_depth) {
            $stack[ $j ] &= ~1;
        }
        last CMD;
    }

    return;
}

sub _DB__handle_forward_slash_command {
    my ($obj) = @@_;

    # The pattern as a string.
    use vars qw($inpat);

    if (($inpat) = $cmd =~ m#\A/(.*)\z#) {

        # Remove the final slash.
        $inpat =~ s:([^\\])/$:$1:;

        # If the pattern isn't null ...
        if ( $inpat ne "" ) {

            # Turn off warn and die processing for a bit.
            local $SIG{__DIE__};
            local $SIG{__WARN__};

            # Create the pattern.
            eval 'no strict q/vars/; $inpat =~ m' . "\a$inpat\a";
            if ( $@@ ne "" ) {

                # Oops. Bad pattern. No biscuit.
                # Print the eval error and go back for more
                # commands.
                print {$OUT} "$@@";
                next CMD;
            }
            $obj->pat($inpat);
        } ## end if ($inpat ne "")

        # Set up to stop on wrap-around.
        $end = $start;

        # Don't move off the current line.
        $incr = -1;

        my $pat = $obj->pat;

        # Done in eval so nothing breaks if the pattern
        # does something weird.
        eval
        {
            no strict q/vars/;
            for (;;) {
                # Move ahead one line.
                ++$start;

                # Wrap if we pass the last line.
                if ($start > $max) {
                    $start = 1;
                }

                # Stop if we have gotten back to this line again,
                last if ($start == $end);

                # A hit! (Note, though, that we are doing
                # case-insensitive matching. Maybe a qr//
                # expression would be better, so the user could
                # do case-sensitive matching if desired.
                if ($dbline[$start] =~ m/$pat/i) {
                    if ($slave_editor) {
                        # Handle proper escaping in the slave.
                        print {$OUT} "\032\032$filename:$start:0\n";
                    }
                    else {
                        # Just print the line normally.
                        print {$OUT} "$start:\t",$dbline[$start],"\n";
                    }
                    # And quit since we found something.
                    last;
                }
            }
        };

        if ($@@) {
            warn $@@;
        }

        # If we wrapped, there never was a match.
        if ( $start == $end ) {
            print {$OUT} "/$pat/: not found\n";
        }
        next CMD;
    }

    return;
}

sub _DB__handle_question_mark_command {
    my ($obj) = @@_;

    # ? - backward pattern search.
    if (my ($inpat) = $cmd =~ m#\A\?(.*)\z#) {

        # Get the pattern, remove trailing question mark.
        $inpat =~ s:([^\\])\?$:$1:;

        # If we've got one ...
        if ( $inpat ne "" ) {

            # Turn off die & warn handlers.
            local $SIG{__DIE__};
            local $SIG{__WARN__};
            eval '$inpat =~ m' . "\a$inpat\a";

            if ( $@@ ne "" ) {

                # Ouch. Not good. Print the error.
                print $OUT $@@;
                next CMD;
            }
            $obj->pat($inpat);
        } ## end if ($inpat ne "")

        # Where we are now is where to stop after wraparound.
        $end = $start;

        # Don't move away from this line.
        $incr = -1;

        my $pat = $obj->pat;
        # Search inside the eval to prevent pattern badness
        # from killing us.
        eval {
            no strict q/vars/;
            for (;;) {
                # Back up a line.
                --$start;

                # Wrap if we pass the first line.

                $start = $max if ($start <= 0);

                # Quit if we get back where we started,
                last if ($start == $end);

                # Match?
                if ($dbline[$start] =~ m/$pat/i) {
                    if ($slave_editor) {
                        # Yep, follow slave editor requirements.
                        print $OUT "\032\032$filename:$start:0\n";
                    }
                    else {
                        # Yep, just print normally.
                        print $OUT "$start:\t",$dbline[$start],"\n";
                    }

                    # Found, so done.
                    last;
                }
            }
        };

        # Say we failed if the loop never found anything,
        if ( $start == $end ) {
            print {$OUT} "?$pat?: not found\n";
        }
        next CMD;
    }

    return;
}

sub _DB__handle_restart_and_rerun_commands {
    my ($obj) = @@_;

    my $cmd_cmd = $obj->cmd_verb;
    my $cmd_params = $obj->cmd_args;
    # R - restart execution.
    # rerun - controlled restart execution.
    if ($cmd_cmd eq 'rerun' or $cmd_params eq '') {

        # Change directory to the initial current working directory on
        # the script startup, so if the debugged program changed the
        # directory, then we will still be able to find the path to the
        # the program. (perl 5 RT #121509 ).
        chdir ($_initial_cwd);

        my @@args = ($cmd_cmd eq 'R' ? restart() : rerun($cmd_params));

        # Close all non-system fds for a clean restart.  A more
        # correct method would be to close all fds that were not
        # open when the process started, but this seems to be
        # hard.  See "debugger 'R'estart and open database
        # connections" on p5p.

        my $max_fd = 1024; # default if POSIX can't be loaded
        if (eval { require POSIX }) {
            eval { $max_fd = POSIX::sysconf(POSIX::_SC_OPEN_MAX()) };
        }

        if (defined $max_fd) {
            foreach ($^F+1 .. $max_fd-1) {
                next unless open FD_TO_CLOSE, "<&=$_";
                close(FD_TO_CLOSE);
            }
        }

        # And run Perl again.  We use exec() to keep the
        # PID stable (and that way $ini_pids is still valid).
        exec(@@args) or print {$OUT} "exec failed: $!\n";

        last CMD;
    }

    return;
}

sub _DB__handle_run_command_in_pager_command {
    my ($obj) = @@_;

    if ($cmd =~ m#\A\|\|?\s*[^|]#) {
        if ( $pager =~ /^\|/ ) {

            # Default pager is into a pipe. Redirect I/O.
            open( SAVEOUT, ">&STDOUT" )
            || _db_warn("Can't save STDOUT");
            open( STDOUT, ">&OUT" )
            || _db_warn("Can't redirect STDOUT");
        } ## end if ($pager =~ /^\|/)
        else {

            # Not into a pipe. STDOUT is safe.
            open( SAVEOUT, ">&OUT" ) || _db_warn("Can't save DB::OUT");
        }

        # Fix up environment to record we have less if so.
        fix_less();

        unless ( $obj->piped(scalar ( open( OUT, $pager ) ) ) ) {

            # Couldn't open pipe to pager.
            _db_warn("Can't pipe output to '$pager'");
            if ( $pager =~ /^\|/ ) {

                # Redirect I/O back again.
                open( OUT, ">&STDOUT" )    # XXX: lost message
                || _db_warn("Can't restore DB::OUT");
                open( STDOUT, ">&SAVEOUT" )
                || _db_warn("Can't restore STDOUT");
                close(SAVEOUT);
            } ## end if ($pager =~ /^\|/)
            else {

                # Redirect I/O. STDOUT already safe.
                open( OUT, ">&STDOUT" )    # XXX: lost message
                || _db_warn("Can't restore DB::OUT");
            }
            next CMD;
        } ## end unless ($piped = open(OUT,...

        # Set up broken-pipe handler if necessary.
        $SIG{PIPE} = \&DB::catch
        if $pager =~ /^\|/
        && ( "" eq $SIG{PIPE} || "DEFAULT" eq $SIG{PIPE} );

        _autoflush(\*OUT);
        # Save current filehandle, and put it back.
        $obj->selected(scalar( select(OUT) ));
        # Don't put it back if pager was a pipe.
        if ($cmd !~ /\A\|\|/)
        {
            select($obj->selected());
            $obj->selected("");
        }

        # Trim off the pipe symbols and run the command now.
        $cmd =~ s#\A\|+\s*##;
        redo PIPE;
    }

    return;
}

sub _DB__handle_m_command {
    my ($obj) = @@_;

    if ($cmd =~ s#\Am\s+([\w:]+)\s*\z# #) {
        methods($1);
        next CMD;
    }

    # m expr - set up DB::eval to do the work
    if ($cmd =~ s#\Am\b# #) {    # Rest gets done by DB::eval()
        $onetimeDump = 'methods';   #  method output gets used there
    }

    return;
}

sub _DB__at_end_of_every_command {
    my ($obj) = @@_;

    # At the end of every command:
    if ($obj->piped) {

        # Unhook the pipe mechanism now.
        if ( $pager =~ /^\|/ ) {

            # No error from the child.
            $? = 0;

            # we cannot warn here: the handle is missing --tchrist
            close(OUT) || print SAVEOUT "\nCan't close DB::OUT\n";

            # most of the $? crud was coping with broken cshisms
            # $? is explicitly set to 0, so this never runs.
            if ($?) {
                print SAVEOUT "Pager '$pager' failed: ";
                if ( $? == -1 ) {
                    print SAVEOUT "shell returned -1\n";
                }
                elsif ( $? >> 8 ) {
                    print SAVEOUT ( $? & 127 )
                    ? " (SIG#" . ( $? & 127 ) . ")"
                    : "", ( $? & 128 ) ? " -- core dumped" : "", "\n";
                }
                else {
                    print SAVEOUT "status ", ( $? >> 8 ), "\n";
                }
            } ## end if ($?)

            # Reopen filehandle for our output (if we can) and
            # restore STDOUT (if we can).
            open( OUT, ">&STDOUT" ) || _db_warn("Can't restore DB::OUT");
            open( STDOUT, ">&SAVEOUT" )
            || _db_warn("Can't restore STDOUT");

            # Turn off pipe exception handler if necessary.
            $SIG{PIPE} = "DEFAULT" if $SIG{PIPE} eq \&DB::catch;

            # Will stop ignoring SIGPIPE if done like nohup(1)
            # does SIGINT but Perl doesn't give us a choice.
        } ## end if ($pager =~ /^\|/)
        else {

            # Non-piped "pager". Just restore STDOUT.
            open( OUT, ">&SAVEOUT" ) || _db_warn("Can't restore DB::OUT");
        }

        # Let Readline know about the new filehandles.
        reset_IN_OUT( \*IN, \*OUT );

        # Close filehandle pager was using, restore the normal one
        # if necessary,
        close(SAVEOUT);

        if ($obj->selected() ne "") {
            select($obj->selected);
            $obj->selected("");
        }

        # No pipes now.
        $obj->piped("");
    } ## end if ($piped)

    return;
}

sub _DB__handle_watch_expressions
{
    my $self = shift;

    if ( $DB::trace & 2 ) {
        for my $n (0 .. $#DB::to_watch) {
            $DB::evalarg = $DB::to_watch[$n];
            local $DB::onetimeDump;    # Tell DB::eval() to not output results

            # Fix context DB::eval() wants to return an array, but
            # we need a scalar here.
            my ($val) = join( "', '", DB::eval(@@_) );
            $val = ( ( defined $val ) ? "'$val'" : 'undef' );

            # Did it change?
            if ( $val ne $DB::old_watch[$n] ) {

                # Yep! Show the difference, and fake an interrupt.
                $DB::signal = 1;
                print {$DB::OUT} <<EOP;
Watchpoint $n:\t$DB::to_watch[$n] changed:
    old value:\t$DB::old_watch[$n]
    new value:\t$val
EOP
                $DB::old_watch[$n] = $val;
            } ## end if ($val ne $old_watch...
        } ## end for my $n (0 ..
    } ## end if ($trace & 2)

    return;
}

# 't' is type.
# 'm' is method.
# 'v' is the value (i.e: method name or subroutine ref).
# 's' is subroutine.
my %cmd_lookup;

BEGIN
{
    %cmd_lookup =
(
    '-' => { t => 'm', v => '_handle_dash_command', },
    '.' => { t => 's', v => \&_DB__handle_dot_command, },
    '=' => { t => 'm', v => '_handle_equal_sign_command', },
    'H' => { t => 'm', v => '_handle_H_command', },
    'S' => { t => 'm', v => '_handle_S_command', },
    'T' => { t => 'm', v => '_handle_T_command', },
    'W' => { t => 'm', v => '_handle_W_command', },
    'c' => { t => 's', v => \&_DB__handle_c_command, },
    'f' => { t => 's', v => \&_DB__handle_f_command, },
    'm' => { t => 's', v => \&_DB__handle_m_command, },
    'n' => { t => 'm', v => '_handle_n_command', },
    'p' => { t => 'm', v => '_handle_p_command', },
    'q' => { t => 'm', v => '_handle_q_command', },
    'r' => { t => 'm', v => '_handle_r_command', },
    's' => { t => 'm', v => '_handle_s_command', },
    'save' => { t => 'm', v => '_handle_save_command', },
    'source' => { t => 'm', v => '_handle_source_command', },
    't' => { t => 'm', v => '_handle_t_command', },
    'w' => { t => 'm', v => '_handle_w_command', },
    'x' => { t => 'm', v => '_handle_x_command', },
    'y' => { t => 's', v => \&_DB__handle_y_command, },
    (map { $_ => { t => 'm', v => '_handle_V_command_and_X_command', }, }
        ('X', 'V')),
    (map { $_ => { t => 'm', v => '_handle_enable_disable_commands', }, }
        qw(enable disable)),
    (map { $_ =>
        { t => 's', v => \&_DB__handle_restart_and_rerun_commands, },
        } qw(R rerun)),
    (map { $_ => {t => 'm', v => '_handle_cmd_wrapper_commands' }, }
        qw(a A b B e E h i l L M o O v w W)),
);
};

sub DB {

    # lock the debugger and get the thread id for the prompt
    lock($DBGR);
    my $tid;
    my $position;
    my ($prefix, $after, $infix);
    my $pat;
    my $explicit_stop;
    my $piped;
    my $selected;

    if ($ENV{PERL5DB_THREADED}) {
        $tid = eval { "[".threads->tid."]" };
    }

    my $cmd_verb;
    my $cmd_args;

    my $obj = DB::Obj->new(
        {
            position => \$position,
            prefix => \$prefix,
            after => \$after,
            explicit_stop => \$explicit_stop,
            infix => \$infix,
            cmd_args => \$cmd_args,
            cmd_verb => \$cmd_verb,
            pat => \$pat,
            piped => \$piped,
            selected => \$selected,
        },
    );

    $obj->_DB_on_init__initialize_globals(@@_);

    # Preserve current values of $@@, $!, $^E, $,, $/, $\, $^W.
    # The code being debugged may have altered them.
    DB::save();

    # Since DB::DB gets called after every line, we can use caller() to
    # figure out where we last were executing. Sneaky, eh? This works because
    # caller is returning all the extra information when called from the
    # debugger.
    local ( $package, $filename, $line ) = caller;
    $filename_ini = $filename;

    # set up the context for DB::eval, so it can properly execute
    # code on behalf of the user. We add the package in so that the
    # code is eval'ed in the proper package (not in the debugger!).
    local $usercontext = _calc_usercontext($package);

    # Create an alias to the active file magical array to simplify
    # the code here.
    local (*dbline) = $main::{ '_<' . $filename };

    # Last line in the program.
    $max = $#dbline;

    # The &-call is here to ascertain the mutability of @@_.
    &_DB__determine_if_we_should_break;

    # Preserve the current stop-or-not, and see if any of the W
    # (watch expressions) has changed.
    my $was_signal = $signal;

    # If we have any watch expressions ...
    _DB__handle_watch_expressions($obj);

=head2 C<watchfunction()>

C<watchfunction()> is a function that can be defined by the user; it is a
function which will be run on each entry to C<DB::DB>; it gets the
current package, filename, and line as its parameters.

The watchfunction can do anything it likes; it is executing in the
debugger's context, so it has access to all of the debugger's internal
data structures and functions.

C<watchfunction()> can control the debugger's actions. Any of the following
will cause the debugger to return control to the user's program after
C<watchfunction()> executes:

=over 4

=item *

Returning a false value from the C<watchfunction()> itself.

=item *

Altering C<$single> to a false value.

=item *

Altering C<$signal> to a false value.

=item *

Turning off the C<4> bit in C<$trace> (this also disables the
check for C<watchfunction()>. This can be done with

    $trace &= ~4;

=back

=cut

    # If there's a user-defined DB::watchfunction, call it with the
    # current package, filename, and line. The function executes in
    # the DB:: package.
    if ( $trace & 4 ) {    # User-installed watch
        return
          if watchfunction( $package, $filename, $line )
          and not $single
          and not $was_signal
          and not( $trace & ~4 );
    } ## end if ($trace & 4)

    # Pick up any alteration to $signal in the watchfunction, and
    # turn off the signal now.
    $was_signal = $signal;
    $signal     = 0;

=head2 GETTING READY TO EXECUTE COMMANDS

The debugger decides to take control if single-step mode is on, the
C<t> command was entered, or the user generated a signal. If the program
has fallen off the end, we set things up so that entering further commands
won't cause trouble, and we say that the program is over.

=cut

    # Make sure that we always print if asked for explicitly regardless
    # of $trace_to_depth .
    $explicit_stop = ($single || $was_signal);

    # Check to see if we should grab control ($single true,
    # trace set appropriately, or we got a signal).
    if ( $explicit_stop || ( $trace & 1 ) ) {
        $obj->_DB__grab_control(@@_);
    } ## end if ($single || ($trace...

=pod

If there's an action to be executed for the line we stopped at, execute it.
If there are any preprompt actions, execute those as well.

=cut

    # If there's an action, do it now.
    if ($action) {
        $evalarg = $action;
        # The &-call is here to ascertain the mutability of @@_.
        &DB::eval;
    }

    # Are we nested another level (e.g., did we evaluate a function
    # that had a breakpoint in it at the debugger prompt)?
    if ( $single || $was_signal ) {

        # Yes, go down a level.
        local $level = $level + 1;

        # Do any pre-prompt actions.
        foreach $evalarg (@@$pre) {
            # The &-call is here to ascertain the mutability of @@_.
            &DB::eval;
        }

        # Complain about too much recursion if we passed the limit.
        if ($single & 4) {
            print $OUT $stack_depth . " levels deep in subroutine calls!\n";
        }

        # The line we're currently on. Set $incr to -1 to stay here
        # until we get a command that tells us to advance.
        $start = $line;
        $incr  = -1;      # for backward motion.

        # Tack preprompt debugger actions ahead of any actual input.
        @@typeahead = ( @@$pretype, @@typeahead );

=head2 WHERE ARE WE?

XXX Relocate this section?

The debugger normally shows the line corresponding to the current line of
execution. Sometimes, though, we want to see the next line, or to move elsewhere
in the file. This is done via the C<$incr>, C<$start>, and C<$max> variables.

C<$incr> controls by how many lines the I<current> line should move forward
after a command is executed. If set to -1, this indicates that the I<current>
line shouldn't change.

C<$start> is the I<current> line. It is used for things like knowing where to
move forwards or backwards from when doing an C<L> or C<-> command.

C<$max> tells the debugger where the last line of the current file is. It's
used to terminate loops most often.

=head2 THE COMMAND LOOP

Most of C<DB::DB> is actually a command parsing and dispatch loop. It comes
in two parts:

=over 4

=item *

The outer part of the loop, starting at the C<CMD> label. This loop
reads a command and then executes it.

=item *

The inner part of the loop, starting at the C<PIPE> label. This part
is wholly contained inside the C<CMD> block and only executes a command.
Used to handle commands running inside a pager.

=back

So why have two labels to restart the loop? Because sometimes, it's easier to
have a command I<generate> another command and then re-execute the loop to do
the new command. This is faster, but perhaps a bit more convoluted.

=cut

        # The big command dispatch loop. It keeps running until the
        # user yields up control again.
        #
        # If we have a terminal for input, and we get something back
        # from readline(), keep on processing.

      CMD:
        while (_DB__read_next_cmd($tid))
        {

            share($cmd);
            # ... try to execute the input as debugger commands.

            # Don't stop running.
            $single = 0;

            # No signal is active.
            $signal = 0;

            # Handle continued commands (ending with \):
            if ($cmd =~ s/\\\z/\n/) {
                $cmd .= DB::readline("  cont: ");
                redo CMD;
            }

=head4 The null command

A newline entered by itself means I<re-execute the last command>. We grab the
command out of C<$laststep> (where it was recorded previously), and copy it
back into C<$cmd> to be executed below. If there wasn't any previous command,
we'll do nothing below (no command will match). If there was, we also save it
in the command history and fall through to allow the command parsing to pick
it up.

=cut

            # Empty input means repeat the last command.
            if ($cmd eq '') {
                $cmd = $laststep;
            }
            chomp($cmd);    # get rid of the annoying extra newline
            if (length($cmd) >= 2) {
                push( @@hist, $cmd );
            }
            push( @@truehist, $cmd );
            share(@@hist);
            share(@@truehist);

            # This is a restart point for commands that didn't arrive
            # via direct user input. It allows us to 'redo PIPE' to
            # re-execute command processing without reading a new command.
          PIPE: {
                _DB__trim_command_and_return_first_component($obj);

=head3 COMMAND ALIASES

The debugger can create aliases for commands (these are stored in the
C<%alias> hash). Before a command is executed, the command loop looks it up
in the alias hash and substitutes the contents of the alias for the command,
completely replacing it.

=cut

                # See if there's an alias for the command, and set it up if so.
                if ( $alias{$cmd_verb} ) {

                    # Squelch signal handling; we want to keep control here
                    # if something goes loco during the alias eval.
                    local $SIG{__DIE__};
                    local $SIG{__WARN__};

                    # This is a command, so we eval it in the DEBUGGER's
                    # scope! Otherwise, we can't see the special debugger
                    # variables, or get to the debugger's subs. (Well, we
                    # _could_, but why make it even more complicated?)
                    eval "\$cmd =~ $alias{$cmd_verb}";
                    if ($@@) {
                        local $\ = '';
                        print $OUT "Couldn't evaluate '$cmd_verb' alias: $@@";
                        next CMD;
                    }
                    _DB__trim_command_and_return_first_component($obj);
                } ## end if ($alias{$cmd_verb})

=head3 MAIN-LINE COMMANDS

All of these commands work up to and after the program being debugged has
terminated.

=head4 C<q> - quit

Quit the debugger. This entails setting the C<$fall_off_end> flag, so we don't
try to execute further, cleaning any restart-related stuff out of the
environment, and executing with the last value of C<$?>.

=cut

                # All of these commands were remapped in perl 5.8.0;
                # we send them off to the secondary dispatcher (see below).
                $obj->_handle_special_char_cmd_wrapper_commands;
                _DB__trim_command_and_return_first_component($obj);

                if (my $cmd_rec = $cmd_lookup{$cmd_verb}) {
                    my $type = $cmd_rec->{t};
                    my $val = $cmd_rec->{v};
                    if ($type eq 'm') {
                        $obj->$val();
                    }
                    elsif ($type eq 's') {
                        $val->($obj);
                    }
                }

=head4 C<t> - trace [n]

Turn tracing on or off. Inverts the appropriate bit in C<$trace> (q.v.).
If level is specified, set C<$trace_to_depth>.

=head4 C<S> - list subroutines matching/not matching a pattern

Walks through C<%sub>, checking to see whether or not to print the name.

=head4 C<X> - list variables in current package

Since the C<V> command actually processes this, just change this to the
appropriate C<V> command and fall through.

=head4 C<V> - list variables

Uses C<dumpvar.pl> to dump out the current values for selected variables.

=head4 C<x> - evaluate and print an expression

Hands the expression off to C<DB::eval>, setting it up to print the value
via C<dumpvar.pl> instead of just printing it directly.

=head4 C<m> - print methods

Just uses C<DB::methods> to determine what methods are available.

=head4 C<f> - switch files

Switch to a different filename.

=head4 C<.> - return to last-executed line.

We set C<$incr> to -1 to indicate that the debugger shouldn't move ahead,
and then we look up the line in the magical C<%dbline> hash.

=head4 C<-> - back one window

We change C<$start> to be one window back; if we go back past the first line,
we set it to be the first line. We ser C<$incr> to put us back at the
currently-executing line, and then put a C<l $start +> (list one window from
C<$start>) in C<$cmd> to be executed later.

=head3 PRE-580 COMMANDS VS. NEW COMMANDS: C<a, A, b, B, h, l, L, M, o, O, P, v, w, W, E<lt>, E<lt>E<lt>, E<0x7B>, E<0x7B>E<0x7B>>

In Perl 5.8.0, a realignment of the commands was done to fix up a number of
problems, most notably that the default case of several commands destroying
the user's work in setting watchpoints, actions, etc. We wanted, however, to
retain the old commands for those who were used to using them or who preferred
them. At this point, we check for the new commands and call C<cmd_wrapper> to
deal with them instead of processing them in-line.

=head4 C<y> - List lexicals in higher scope

Uses C<PadWalker> to find the lexicals supplied as arguments in a scope
above the current one and then displays then using C<dumpvar.pl>.

=head3 COMMANDS NOT WORKING AFTER PROGRAM ENDS

All of the commands below this point don't work after the program being
debugged has ended. All of them check to see if the program has ended; this
allows the commands to be relocated without worrying about a 'line of
demarcation' above which commands can be entered anytime, and below which
they can't.

=head4 C<n> - single step, but don't trace down into subs

Done by setting C<$single> to 2, which forces subs to execute straight through
when entered (see C<DB::sub>). We also save the C<n> command in C<$laststep>,
so a null command knows what to re-execute.

=head4 C<s> - single-step, entering subs

Sets C<$single> to 1, which causes C<DB::sub> to continue tracing inside
subs. Also saves C<s> as C<$lastcmd>.

=head4 C<c> - run continuously, setting an optional breakpoint

Most of the code for this command is taken up with locating the optional
breakpoint, which is either a subroutine name or a line number. We set
the appropriate one-time-break in C<@@dbline> and then turn off single-stepping
in this and all call levels above this one.

=head4 C<r> - return from a subroutine

For C<r> to work properly, the debugger has to stop execution again
immediately after the return is executed. This is done by forcing
single-stepping to be on in the call level above the current one. If
we are printing return values when a C<r> is executed, set C<$doret>
appropriately, and force us out of the command loop.

=head4 C<T> - stack trace

Just calls C<DB::print_trace>.

=head4 C<w> - List window around current line.

Just calls C<DB::cmd_w>.

=head4 C<W> - watch-expression processing.

Just calls C<DB::cmd_W>.

=head4 C</> - search forward for a string in the source

We take the argument and treat it as a pattern. If it turns out to be a
bad one, we return the error we got from trying to C<eval> it and exit.
If not, we create some code to do the search and C<eval> it so it can't
mess us up.

=cut

                _DB__handle_forward_slash_command($obj);

=head4 C<?> - search backward for a string in the source

Same as for C</>, except the loop runs backwards.

=cut

                _DB__handle_question_mark_command($obj);

=head4 C<$rc> - Recall command

Manages the commands in C<@@hist> (which is created if C<Term::ReadLine> reports
that the terminal supports history). It finds the command required, puts it
into C<$cmd>, and redoes the loop to execute it.

=cut

                # $rc - recall command.
                $obj->_handle_rc_recall_command;

=head4 C<$sh$sh> - C<system()> command

Calls the C<_db_system()> to handle the command. This keeps the C<STDIN> and
C<STDOUT> from getting messed up.

=cut

                $obj->_handle_sh_command;

=head4 C<$rc I<pattern> $rc> - Search command history

Another command to manipulate C<@@hist>: this one searches it with a pattern.
If a command is found, it is placed in C<$cmd> and executed via C<redo>.

=cut

                $obj->_handle_rc_search_history_command;

=head4 C<$sh> - Invoke a shell

Uses C<_db_system()> to invoke a shell.

=cut

=head4 C<$sh I<command>> - Force execution of a command in a shell

Like the above, but the command is passed to the shell. Again, we use
C<_db_system()> to avoid problems with C<STDIN> and C<STDOUT>.

=head4 C<H> - display commands in history

Prints the contents of C<@@hist> (if any).

=head4 C<man, doc, perldoc> - look up documentation

Just calls C<runman()> to print the appropriate document.

=cut

                $obj->_handle_doc_command;

=head4 C<p> - print

Builds a C<print EXPR> expression in the C<$cmd>; this will get executed at
the bottom of the loop.

=head4 C<=> - define command alias

Manipulates C<%alias> to add or list command aliases.

=head4 C<source> - read commands from a file.

Opens a lexical filehandle and stacks it on C<@@cmdfhs>; C<DB::readline> will
pick it up.

=head4 C<enable> C<disable> - enable or disable breakpoints

This enables or disables breakpoints.

=head4 C<save> - send current history to a file

Takes the complete history, (not the shrunken version you see with C<H>),
and saves it to the given filename, so it can be replayed using C<source>.

Note that all C<^(save|source)>'s are commented out with a view to minimise recursion.

=head4 C<R> - restart

Restart the debugger session.

=head4 C<rerun> - rerun the current session

Return to any given position in the B<true>-history list

=head4 C<|, ||> - pipe output through the pager.

For C<|>, we save C<OUT> (the debugger's output filehandle) and C<STDOUT>
(the program's standard output). For C<||>, we only save C<OUT>. We open a
pipe to the pager (restoring the output filehandles if this fails). If this
is the C<|> command, we also set up a C<SIGPIPE> handler which will simply
set C<$signal>, sending us back into the debugger.

We then trim off the pipe symbols and C<redo> the command loop at the
C<PIPE> label, causing us to evaluate the command in C<$cmd> without
reading another.

=cut

                # || - run command in the pager, with output to DB::OUT.
                _DB__handle_run_command_in_pager_command($obj);

=head3 END OF COMMAND PARSING

Anything left in C<$cmd> at this point is a Perl expression that we want to
evaluate. We'll always evaluate in the user's context, and fully qualify
any variables we might want to address in the C<DB> package.

=cut

            }    # PIPE:

            # trace an expression
            $cmd =~ s/^t\s/\$DB::trace |= 1;\n/;

            # Make sure the flag that says "the debugger's running" is
            # still on, to make sure we get control again.
            $evalarg = "\$^D = \$^D | \$DB::db_stop;\n$cmd";

            # Run *our* eval that executes in the caller's context.
            # The &-call is here to ascertain the mutability of @@_.
            &DB::eval;

            # Turn off the one-time-dump stuff now.
            if ($onetimeDump) {
                $onetimeDump      = undef;
                $onetimedumpDepth = undef;
            }
            elsif ( $term_pid == $$ ) {
                eval { # May run under miniperl, when not available...
                    STDOUT->flush();
                    STDERR->flush();
                };

                # XXX If this is the master pid, print a newline.
                print {$OUT} "\n";
            }
        } ## end while (($term || &setterm...

=head3 POST-COMMAND PROCESSING

After each command, we check to see if the command output was piped anywhere.
If so, we go through the necessary code to unhook the pipe and go back to
our standard filehandles for input and output.

=cut

        continue {    # CMD:
            _DB__at_end_of_every_command($obj);
        }    # CMD:

=head3 COMMAND LOOP TERMINATION

When commands have finished executing, we come here. If the user closed the
input filehandle, we turn on C<$fall_off_end> to emulate a C<q> command. We
evaluate any post-prompt items. We restore C<$@@>, C<$!>, C<$^E>, C<$,>, C<$/>,
C<$\>, and C<$^W>, and return a null list as expected by the Perl interpreter.
The interpreter will then execute the next line and then return control to us
again.

=cut

        # No more commands? Quit.
        $fall_off_end = 1 unless defined $cmd;    # Emulate 'q' on EOF

        # Evaluate post-prompt commands.
        foreach $evalarg (@@$post) {
            # The &-call is here to ascertain the mutability of @@_.
            &DB::eval;
        }
    }    # if ($single || $signal)

    # Put the user's globals back where you found them.
    ( $@@, $!, $^E, $,, $/, $\, $^W ) = @@saved;
    ();
} ## end sub DB

# Because DB::Obj is used above,
#
#   my $obj = DB::Obj->new(
#
# The following package declaration must come before that,
# or else runtime errors will occur with
#
#   PERLDB_OPTS="autotrace nonstop"
#
# ( rt#116771 )
BEGIN {

package DB::Obj;

sub new {
    my $class = shift;

    my $self = bless {}, $class;

    $self->_init(@@_);

    return $self;
}

sub _init {
    my ($self, $args) = @@_;

    %{$self} = (%$self, %$args);

    return;
}

{
    no strict 'refs';
    foreach my $slot_name (qw(
        after explicit_stop infix pat piped position prefix selected cmd_verb
        cmd_args
        )) {
        my $slot = $slot_name;
        *{$slot} = sub {
            my $self = shift;

            if (@@_) {
                ${ $self->{$slot} } = shift;
            }

            return ${ $self->{$slot} };
        };

        *{"append_to_$slot"} = sub {
            my $self = shift;
            my $s = shift;

            return $self->$slot($self->$slot . $s);
        };
    }
}

sub _DB_on_init__initialize_globals
{
    my $self = shift;

    # Check for whether we should be running continuously or not.
    # _After_ the perl program is compiled, $single is set to 1:
    if ( $single and not $second_time++ ) {

        # Options say run non-stop. Run until we get an interrupt.
        if ($runnonstop) {    # Disable until signal
                # If there's any call stack in place, turn off single
                # stepping into subs throughout the stack.
            for my $i (0 .. $stack_depth) {
                $stack[ $i ] &= ~1;
            }

            # And we are now no longer in single-step mode.
            $single = 0;

            # If we simply returned at this point, we wouldn't get
            # the trace info. Fall on through.
            # return;
        } ## end if ($runnonstop)

        elsif ($ImmediateStop) {

            # We are supposed to stop here; XXX probably a break.
            $ImmediateStop = 0;    # We've processed it; turn it off
            $signal        = 1;    # Simulate an interrupt to force
                                   # us into the command loop
        }
    } ## end if ($single and not $second_time...

    # If we're in single-step mode, or an interrupt (real or fake)
    # has occurred, turn off non-stop mode.
    $runnonstop = 0 if $single or $signal;

    return;
}

sub _my_print_lineinfo
{
    my ($self, $i, $incr_pos) = @@_;

    if ($frame) {
        # Print it indented if tracing is on.
        DB::print_lineinfo( ' ' x $stack_depth,
            "$i:\t$DB::dbline[$i]" . $self->after );
    }
    else {
        DB::depth_print_lineinfo($self->explicit_stop, $incr_pos);
    }
}

sub _curr_line {
    return $DB::dbline[$line];
}

sub _is_full {
    my ($self, $letter) = @@_;

    return ($DB::cmd eq $letter);
}

sub _DB__grab_control
{
    my $self = shift;

    # Yes, grab control.
    if ($slave_editor) {

        # Tell the editor to update its position.
        $self->position("\032\032${DB::filename}:$line:0\n");
        DB::print_lineinfo($self->position());
    }

=pod

Special check: if we're in package C<DB::fake>, we've gone through the
C<END> block at least once. We set up everything so that we can continue
to enter commands and have a valid context to be in.

=cut

    elsif ( $DB::package eq 'DB::fake' ) {

        # Fallen off the end already.
        if (!$DB::term) {
            DB::setterm();
        }

        DB::print_help(<<EOP);
Debugged program terminated.  Use B<q> to quit or B<R> to restart,
use B<o> I<inhibit_exit> to avoid stopping after program termination,
B<h q>, B<h R> or B<h o> to get additional info.
EOP

        # Set the DB::eval context appropriately.
        # At program termination disable any user actions.
        $DB::action = undef;

        $DB::package     = 'main';
        $DB::usercontext = DB::_calc_usercontext($DB::package);
    } ## end elsif ($package eq 'DB::fake')

=pod

If the program hasn't finished executing, we scan forward to the
next executable line, print that out, build the prompt from the file and line
number information, and print that.

=cut

    else {


        # Still somewhere in the midst of execution. Set up the
        #  debugger prompt.
        $DB::sub =~ s/\'/::/;    # Swap Perl 4 package separators (') to
                             # Perl 5 ones (sorry, we don't print Klingon
                             #module names)

        $self->prefix($DB::sub =~ /::/ ? "" : ($DB::package . '::'));
        $self->append_to_prefix( "$DB::sub(${DB::filename}:" );
        $self->after( $self->_curr_line =~ /\n$/ ? '' : "\n" );

        # Break up the prompt if it's really long.
        if ( length($self->prefix()) > 30 ) {
            $self->position($self->prefix . "$line):\n$line:\t" . $self->_curr_line . $self->after);
            $self->prefix("");
            $self->infix(":\t");
        }
        else {
            $self->infix("):\t");
            $self->position(
                $self->prefix . $line. $self->infix
                . $self->_curr_line . $self->after
            );
        }

        # Print current line info, indenting if necessary.
        $self->_my_print_lineinfo($line, $self->position);

        my $i;
        my $line_i = sub { return $DB::dbline[$i]; };

        # Scan forward, stopping at either the end or the next
        # unbreakable line.
        for ( $i = $line + 1 ; $i <= $DB::max && $line_i->() == 0 ; ++$i )
        {    #{ vi

            # Drop out on null statements, block closers, and comments.
            last if $line_i->() =~ /^\s*[\;\}\#\n]/;

            # Drop out if the user interrupted us.
            last if $signal;

            # Append a newline if the line doesn't have one. Can happen
            # in eval'ed text, for instance.
            $self->after( $line_i->() =~ /\n$/ ? '' : "\n" );

            # Next executable line.
            my $incr_pos = $self->prefix . $i . $self->infix . $line_i->()
                . $self->after;
            $self->append_to_position($incr_pos);
            $self->_my_print_lineinfo($i, $incr_pos);
        } ## end for ($i = $line + 1 ; $i...
    } ## end else [ if ($slave_editor)

    return;
}

sub _handle_t_command {
    my $self = shift;

    my $levels = $self->cmd_args();

    if ((!length($levels)) or ($levels !~ /\D/)) {
        $trace ^= 1;
        local $\ = '';
        $DB::trace_to_depth = $levels ? $stack_depth + $levels : 1E9;
        print {$OUT} "Trace = "
        . ( ( $trace & 1 )
            ? ( $levels ? "on (to level $DB::trace_to_depth)" : "on" )
            : "off" ) . "\n";
        next CMD;
    }

    return;
}


sub _handle_S_command {
    my $self = shift;

    if (my ($print_all_subs, $should_reverse, $Spatt)
        = $self->cmd_args =~ /\A((!)?(.+))?\z/) {
        # $Spatt is the pattern (if any) to use.
        # Reverse scan?
        my $Srev     = defined $should_reverse;
        # No args - print all subs.
        my $Snocheck = !defined $print_all_subs;

        # Need to make these sane here.
        local $\ = '';
        local $, = '';

        # Search through the debugger's magical hash of subs.
        # If $nocheck is true, just print the sub name.
        # Otherwise, check it against the pattern. We then use
        # the XOR trick to reverse the condition as required.
        foreach $subname ( sort( keys %sub ) ) {
            if ( $Snocheck or $Srev ^ ( $subname =~ /$Spatt/ ) ) {
                print $OUT $subname, "\n";
            }
        }
        next CMD;
    }

    return;
}

sub _handle_V_command_and_X_command {
    my $self = shift;

    $DB::cmd =~ s/^X\b/V $DB::package/;

    # Bare V commands get the currently-being-debugged package
    # added.
    if ($self->_is_full('V')) {
        $DB::cmd = "V $DB::package";
    }

    # V - show variables in package.
    if (my ($new_packname, $new_vars_str) =
        $DB::cmd =~ /\AV\b\s*(\S+)\s*(.*)/) {

        # Save the currently selected filehandle and
        # force output to debugger's filehandle (dumpvar
        # just does "print" for output).
        my $savout = select($OUT);

        # Grab package name and variables to dump.
        $packname = $new_packname;
        my @@vars     = split( ' ', $new_vars_str );

        # If main::dumpvar isn't here, get it.
        do 'dumpvar.pl' || die $@@ unless defined &main::dumpvar;
        if ( defined &main::dumpvar ) {

            # We got it. Turn off subroutine entry/exit messages
            # for the moment, along with return values.
            local $frame = 0;
            local $doret = -2;

            # must detect sigpipe failures  - not catching
            # then will cause the debugger to die.
            eval {
                main::dumpvar(
                    $packname,
                    defined $option{dumpDepth}
                    ? $option{dumpDepth}
                    : -1,    # assume -1 unless specified
                    @@vars
                );
            };

            # The die doesn't need to include the $@@, because
            # it will automatically get propagated for us.
            if ($@@) {
                die unless $@@ =~ /dumpvar print failed/;
            }
        } ## end if (defined &main::dumpvar)
        else {

            # Couldn't load dumpvar.
            print $OUT "dumpvar.pl not available.\n";
        }

        # Restore the output filehandle, and go round again.
        select($savout);
        next CMD;
    }

    return;
}

sub _handle_dash_command {
    my $self = shift;

    if ($self->_is_full('-')) {

        # back up by a window; go to 1 if back too far.
        $start -= $incr + $window + 1;
        $start = 1 if $start <= 0;
        $incr  = $window - 1;

        # Generate and execute a "l +" command (handled below).
        $DB::cmd = 'l ' . ($start) . '+';
        redo CMD;
    }
    return;
}

sub _n_or_s_commands_generic {
    my ($self, $new_val) = @@_;
    # n - next
    next CMD if DB::_DB__is_finished();

    # Single step, but don't enter subs.
    $single = $new_val;

    # Save for empty command (repeat last).
    $laststep = $DB::cmd;
    last CMD;
}

sub _n_or_s {
    my ($self, $letter, $new_val) = @@_;

    if ($self->_is_full($letter)) {
        $self->_n_or_s_commands_generic($new_val);
    }
    else {
        $self->_n_or_s_and_arg_commands_generic($letter, $new_val);
    }

    return;
}

sub _handle_n_command {
    my $self = shift;

    return $self->_n_or_s('n', 2);
}

sub _handle_s_command {
    my $self = shift;

    return $self->_n_or_s('s', 1);
}

sub _handle_r_command {
    my $self = shift;

    # r - return from the current subroutine.
    if ($self->_is_full('r')) {

        # Can't do anything if the program's over.
        next CMD if DB::_DB__is_finished();

        # Turn on stack trace.
        $stack[$stack_depth] |= 1;

        # Print return value unless the stack is empty.
        $doret = $option{PrintRet} ? $stack_depth - 1 : -2;
        last CMD;
    }

    return;
}

sub _handle_T_command {
    my $self = shift;

    if ($self->_is_full('T')) {
        DB::print_trace( $OUT, 1 );    # skip DB
        next CMD;
    }

    return;
}

sub _handle_w_command {
    my $self = shift;

    DB::cmd_w( 'w', $self->cmd_args() );
    next CMD;

    return;
}

sub _handle_W_command {
    my $self = shift;

    if (my $arg = $self->cmd_args) {
        DB::cmd_W( 'W', $arg );
        next CMD;
    }

    return;
}

sub _handle_rc_recall_command {
    my $self = shift;

    # $rc - recall command.
    if (my ($minus, $arg) = $DB::cmd =~ m#\A$rc+\s*(-)?(\d+)?\z#) {

        # No arguments, take one thing off history.
        pop(@@hist) if length($DB::cmd) > 1;

        # Relative (- found)?
        #  Y - index back from most recent (by 1 if bare minus)
        #  N - go to that particular command slot or the last
        #      thing if nothing following.

        $self->cmd_verb(
            scalar($minus ? ( $#hist - ( $arg || 1 ) ) : ( $arg || $#hist ))
        );

        # Pick out the command desired.
        $DB::cmd = $hist[$self->cmd_verb];

        # Print the command to be executed and restart the loop
        # with that command in the buffer.
        print {$OUT} $DB::cmd, "\n";
        redo CMD;
    }

    return;
}

sub _handle_rc_search_history_command {
    my $self = shift;

    # $rc pattern $rc - find a command in the history.
    if (my ($arg) = $DB::cmd =~ /\A$rc([^$rc].*)\z/) {

        # Create the pattern to use.
        my $pat = "^$arg";
        $self->pat($pat);

        # Toss off last entry if length is >1 (and it always is).
        pop(@@hist) if length($DB::cmd) > 1;

        my $i;

        # Look backward through the history.
        SEARCH_HIST:
        for ( $i = $#hist ; $i ; --$i ) {
            # Stop if we find it.
            last SEARCH_HIST if $hist[$i] =~ /$pat/;
        }

        if ( !$i ) {

            # Never found it.
            print $OUT "No such command!\n\n";
            next CMD;
        }

        # Found it. Put it in the buffer, print it, and process it.
        $DB::cmd = $hist[$i];
        print $OUT $DB::cmd, "\n";
        redo CMD;
    }

    return;
}

sub _handle_H_command {
    my $self = shift;

    if ($self->cmd_args =~ m#\A\*#) {
        @@hist = @@truehist = ();
        print $OUT "History cleansed\n";
        next CMD;
    }

    if (my ($num) = $self->cmd_args =~ /\A(?:-(\d+))?/) {

        # Anything other than negative numbers is ignored by
        # the (incorrect) pattern, so this test does nothing.
        $end = $num ? ( $#hist - $num ) : 0;

        # Set to the minimum if less than zero.
        $hist = 0 if $hist < 0;

        # Start at the end of the array.
        # Stay in while we're still above the ending value.
        # Tick back by one each time around the loop.
        my $i;

        for ( $i = $#hist ; $i > $end ; $i-- ) {

            # Print the command  unless it has no arguments.
            print $OUT "$i: ", $hist[$i], "\n"
            unless $hist[$i] =~ /^.?$/;
        }

        next CMD;
    }

    return;
}

sub _handle_doc_command {
    my $self = shift;

    # man, perldoc, doc - show manual pages.
    if (my ($man_page)
        = $DB::cmd =~ /\A(?:man|(?:perl)?doc)\b(?:\s+([^(]*))?\z/) {
        DB::runman($man_page);
        next CMD;
    }

    return;
}

sub _handle_p_command {
    my $self = shift;

    my $print_cmd = 'print {$DB::OUT} ';
    # p - print (no args): print $_.
    if ($self->_is_full('p')) {
        $DB::cmd = $print_cmd . '$_';
    }
    else {
        # p - print the given expression.
        $DB::cmd =~ s/\Ap\b/$print_cmd /;
    }

    return;
}

sub _handle_equal_sign_command {
    my $self = shift;

    if ($DB::cmd =~ s/\A=\s*//) {
        my @@keys;
        if ( length $DB::cmd == 0 ) {

            # No args, get current aliases.
            @@keys = sort keys %alias;
        }
        elsif ( my ( $k, $v ) = ( $DB::cmd =~ /^(\S+)\s+(\S.*)/ ) ) {

            # Creating a new alias. $k is alias name, $v is
            # alias value.

            # can't use $_ or kill //g state
            for my $x ( $k, $v ) {

                # Escape "alarm" characters.
                $x =~ s/\a/\\a/g;
            }

            # Substitute key for value, using alarm chars
            # as separators (which is why we escaped them in
            # the command).
            $alias{$k} = "s\a$k\a$v\a";

            # Turn off standard warn and die behavior.
            local $SIG{__DIE__};
            local $SIG{__WARN__};

            # Is it valid Perl?
            unless ( eval "sub { s\a$k\a$v\a }; 1" ) {

                # Nope. Bad alias. Say so and get out.
                print $OUT "Can't alias $k to $v: $@@\n";
                delete $alias{$k};
                next CMD;
            }

            # We'll only list the new one.
            @@keys = ($k);
        } ## end elsif (my ($k, $v) = ($DB::cmd...

        # The argument is the alias to list.
        else {
            @@keys = ($DB::cmd);
        }

        # List aliases.
        for my $k (@@keys) {

            # Messy metaquoting: Trim the substitution code off.
            # We use control-G as the delimiter because it's not
            # likely to appear in the alias.
            if ( ( my $v = $alias{$k} ) =~ ss\a$k\a(.*)\a$1 ) {

                # Print the alias.
                print $OUT "$k\t= $1\n";
            }
            elsif ( defined $alias{$k} ) {

                # Couldn't trim it off; just print the alias code.
                print $OUT "$k\t$alias{$k}\n";
            }
            else {

                # No such, dude.
                print "No alias for $k\n";
            }
        } ## end for my $k (@@keys)
        next CMD;
    }

    return;
}

sub _handle_source_command {
    my $self = shift;

    # source - read commands from a file (or pipe!) and execute.
    if (my $sourced_fn = $self->cmd_args) {
        if ( open my $fh, $sourced_fn ) {

            # Opened OK; stick it in the list of file handles.
            push @@cmdfhs, $fh;
        }
        else {

            # Couldn't open it.
            DB::_db_warn("Can't execute '$sourced_fn': $!\n");
        }
        next CMD;
    }

    return;
}

sub _handle_enable_disable_commands {
    my $self = shift;

    my $which_cmd = $self->cmd_verb;
    my $position = $self->cmd_args;

    if ($position !~ /\s/) {
        my ($fn, $line_num);
        if ($position =~ m{\A\d+\z})
        {
            $fn = $DB::filename;
            $line_num = $position;
        }
        elsif (my ($new_fn, $new_line_num)
            = $position =~ m{\A(.*):(\d+)\z}) {
            ($fn, $line_num) = ($new_fn, $new_line_num);
        }
        else
        {
            DB::_db_warn("Wrong spec for enable/disable argument.\n");
        }

        if (defined($fn)) {
            if (DB::_has_breakpoint_data_ref($fn, $line_num)) {
                DB::_set_breakpoint_enabled_status($fn, $line_num,
                    ($which_cmd eq 'enable' ? 1 : '')
                );
            }
            else {
                DB::_db_warn("No breakpoint set at ${fn}:${line_num}\n");
            }
        }

        next CMD;
    }

    return;
}

sub _handle_save_command {
    my $self = shift;

    if (my $new_fn = $self->cmd_args) {
        my $filename = $new_fn || '.perl5dbrc';    # default?
        if ( open my $fh, '>', $filename ) {

            # chomp to remove extraneous newlines from source'd files
            chomp( my @@truelist =
                map { m/\A\s*(save|source)/ ? "#$_" : $_ }
                @@truehist );
            print {$fh} join( "\n", @@truelist );
            print "commands saved in $filename\n";
        }
        else {
            DB::_db_warn("Can't save debugger commands in '$new_fn': $!\n");
        }
        next CMD;
    }

    return;
}

sub _n_or_s_and_arg_commands_generic {
    my ($self, $letter, $new_val) = @@_;

    # s - single-step. Remember the last command was 's'.
    if ($DB::cmd =~ s#\A\Q$letter\E\s#\$DB::single = $new_val;\n#) {
        $laststep = $letter;
    }

    return;
}

sub _handle_sh_command {
    my $self = shift;

    # $sh$sh - run a shell command (if it's all ASCII).
    # Can't run shell commands with Unicode in the debugger, hmm.
    my $my_cmd = $DB::cmd;
    if ($my_cmd =~ m#\A$sh#gms) {

        if ($my_cmd =~ m#\G\z#cgms) {
            # Run the user's shell. If none defined, run Bourne.
            # We resume execution when the shell terminates.
            DB::_db_system( $ENV{SHELL} || "/bin/sh" );
            next CMD;
        }
        elsif ($my_cmd =~ m#\G$sh\s*(.*)#cgms) {
            # System it.
            DB::_db_system($1);
            next CMD;
        }
        elsif ($my_cmd =~ m#\G\s*(.*)#cgms) {
            DB::_db_system( $ENV{SHELL} || "/bin/sh", "-c", $1 );
            next CMD;
        }
    }
}

sub _handle_x_command {
    my $self = shift;

    if ($DB::cmd =~ s#\Ax\b# #) {    # Remainder gets done by DB::eval()
        $onetimeDump = 'dump';    # main::dumpvar shows the output

        # handle special  "x 3 blah" syntax XXX propagate
        # doc back to special variables.
        if ( $DB::cmd =~ s#\A\s*(\d+)(?=\s)# #) {
            $onetimedumpDepth = $1;
        }
    }

    return;
}

sub _handle_q_command {
    my $self = shift;

    if ($self->_is_full('q')) {
        $fall_off_end = 1;
        DB::clean_ENV();
        exit $?;
    }

    return;
}

sub _handle_cmd_wrapper_commands {
    my $self = shift;

    DB::cmd_wrapper( $self->cmd_verb, $self->cmd_args, $line );
    next CMD;
}

sub _handle_special_char_cmd_wrapper_commands {
    my $self = shift;

    # All of these commands were remapped in perl 5.8.0;
    # we send them off to the secondary dispatcher (see below).
    if (my ($cmd_letter, $my_arg) = $DB::cmd =~ /\A([<>\{]{1,2})\s*(.*)/so) {
        DB::cmd_wrapper( $cmd_letter, $my_arg, $line );
        next CMD;
    }

    return;
}

} ## end DB::Obj

package DB;

# The following code may be executed now:
# BEGIN {warn 4}

=head2 sub

C<sub> is called whenever a subroutine call happens in the program being
debugged. The variable C<$DB::sub> contains the name of the subroutine
being called.

The core function of this subroutine is to actually call the sub in the proper
context, capturing its output. This of course causes C<DB::DB> to get called
again, repeating until the subroutine ends and returns control to C<DB::sub>
again. Once control returns, C<DB::sub> figures out whether or not to dump the
return value, and returns its captured copy of the return value as its own
return value. The value then feeds back into the program being debugged as if
C<DB::sub> hadn't been there at all.

C<sub> does all the work of printing the subroutine entry and exit messages
enabled by setting C<$frame>. It notes what sub the autoloader got called for,
and also prints the return value if needed (for the C<r> command and if
the 16 bit is set in C<$frame>).

It also tracks the subroutine call depth by saving the current setting of
C<$single> in the C<@@stack> package global; if this exceeds the value in
C<$deep>, C<sub> automatically turns on printing of the current depth by
setting the C<4> bit in C<$single>. In any case, it keeps the current setting
of stop/don't stop on entry to subs set as it currently is set.

=head3 C<caller()> support

If C<caller()> is called from the package C<DB>, it provides some
additional data, in the following order:

=over 4

=item * C<$package>

The package name the sub was in

=item * C<$filename>

The filename it was defined in

=item * C<$line>

The line number it was defined on

=item * C<$subroutine>

The subroutine name; C<(eval)> if an C<eval>().

=item * C<$hasargs>

1 if it has arguments, 0 if not

=item * C<$wantarray>

1 if array context, 0 if scalar context

=item * C<$evaltext>

The C<eval>() text, if any (undefined for C<eval BLOCK>)

=item * C<$is_require>

frame was created by a C<use> or C<require> statement

=item * C<$hints>

pragma information; subject to change between versions

=item * C<$bitmask>

pragma information; subject to change between versions

=item * C<@@DB::args>

arguments with which the subroutine was invoked

=back

=cut

use vars qw($deep);

# We need to fully qualify the name ("DB::sub") to make "use strict;"
# happy. -- Shlomi Fish

sub _indent_print_line_info {
    my ($offset, $str) = @@_;

    print_lineinfo( ' ' x ($stack_depth - $offset), $str);

    return;
}

sub _print_frame_message {
    my ($al) = @@_;

    if ($frame) {
        if ($frame & 4) {   # Extended frame entry message
            _indent_print_line_info(-1, "in  ");

            # Why -1? But it works! :-(
            # Because print_trace will call add 1 to it and then call
            # dump_trace; this results in our skipping -1+1 = 0 stack frames
            # in dump_trace.
            #
            # Now it's 0 because we extracted a function.
            print_trace( $LINEINFO, 0, 1, 1, "$sub$al" );
        }
        else {
            _indent_print_line_info(-1, "entering $sub$al\n" );
        }
    }

    return;
}

sub DB::sub {
    # lock ourselves under threads
    lock($DBGR);

    # Whether or not the autoloader was running, a scalar to put the
    # sub's return value in (if needed), and an array to put the sub's
    # return value in (if needed).
    my ( $al, $ret, @@ret ) = "";
    if ($sub eq 'threads::new' && $ENV{PERL5DB_THREADED}) {
        print "creating new thread\n";
    }

    # If the last ten characters are '::AUTOLOAD', note we've traced
    # into AUTOLOAD for $sub.
    if ( length($sub) > 10 && substr( $sub, -10, 10 ) eq '::AUTOLOAD' ) {
        no strict 'refs';
        $al = " for $$sub" if defined $$sub;
    }

    # We stack the stack pointer and then increment it to protect us
    # from a situation that might unwind a whole bunch of call frames
    # at once. Localizing the stack pointer means that it will automatically
    # unwind the same amount when multiple stack frames are unwound.
    local $stack_depth = $stack_depth + 1;    # Protect from non-local exits

    # Expand @@stack.
    $#stack = $stack_depth;

    # Save current single-step setting.
    $stack[-1] = $single;

    # Turn off all flags except single-stepping.
    $single &= 1;

    # If we've gotten really deeply recursed, turn on the flag that will
    # make us stop with the 'deep recursion' message.
    $single |= 4 if $stack_depth == $deep;

    # If frame messages are on ...

    _print_frame_message($al);
    # standard frame entry message

    my $print_exit_msg = sub {
        # Check for exit trace messages...
        if ($frame & 2)
        {
            if ($frame & 4)    # Extended exit message
            {
                _indent_print_line_info(0, "out ");
                print_trace( $LINEINFO, 0, 1, 1, "$sub$al" );
            }
            else
            {
                _indent_print_line_info(0, "exited $sub$al\n" );
            }
        }
        return;
    };

    # Determine the sub's return type, and capture appropriately.
    if (wantarray) {

        # Called in array context. call sub and capture output.
        # DB::DB will recursively get control again if appropriate; we'll come
        # back here when the sub is finished.
        {
            no strict 'refs';
            @@ret = &$sub;
        }

        # Pop the single-step value back off the stack.
        $single |= $stack[ $stack_depth-- ];

        $print_exit_msg->();

        # Print the return info if we need to.
        if ( $doret eq $stack_depth or $frame & 16 ) {

            # Turn off output record separator.
            local $\ = '';
            my $fh = ( $doret eq $stack_depth ? $OUT : $LINEINFO );

            # Indent if we're printing because of $frame tracing.
            if ($frame & 16)
            {
                print {$fh} ' ' x $stack_depth;
            }

            # Print the return value.
            print {$fh} "list context return from $sub:\n";
            dumpit( $fh, \@@ret );

            # And don't print it again.
            $doret = -2;
        } ## end if ($doret eq $stack_depth...
            # And we have to return the return value now.
        @@ret;
    } ## end if (wantarray)

    # Scalar context.
    else {
        if ( defined wantarray ) {
            no strict 'refs';
            # Save the value if it's wanted at all.
            $ret = &$sub;
        }
        else {
            no strict 'refs';
            # Void return, explicitly.
            &$sub;
            undef $ret;
        }

        # Pop the single-step value off the stack.
        $single |= $stack[ $stack_depth-- ];

        # If we're doing exit messages...
        $print_exit_msg->();

        # If we are supposed to show the return value... same as before.
        if ( $doret eq $stack_depth or $frame & 16 and defined wantarray ) {
            local $\ = '';
            my $fh = ( $doret eq $stack_depth ? $OUT : $LINEINFO );
            print $fh ( ' ' x $stack_depth ) if $frame & 16;
            print $fh (
                defined wantarray
                ? "scalar context return from $sub: "
                : "void context return from $sub\n"
            );
            dumpit( $fh, $ret ) if defined wantarray;
            $doret = -2;
        } ## end if ($doret eq $stack_depth...

        # Return the appropriate scalar value.
        $ret;
    } ## end else [ if (wantarray)
} ## end sub _sub

sub lsub : lvalue {

    no strict 'refs';

    # lock ourselves under threads
    lock($DBGR);

    # Whether or not the autoloader was running, a scalar to put the
    # sub's return value in (if needed), and an array to put the sub's
    # return value in (if needed).
    my ( $al, $ret, @@ret ) = "";
    if ($sub =~ /^threads::new$/ && $ENV{PERL5DB_THREADED}) {
        print "creating new thread\n";
    }

    # If the last ten characters are C'::AUTOLOAD', note we've traced
    # into AUTOLOAD for $sub.
    if ( length($sub) > 10 && substr( $sub, -10, 10 ) eq '::AUTOLOAD' ) {
        $al = " for $$sub";
    }

    # We stack the stack pointer and then increment it to protect us
    # from a situation that might unwind a whole bunch of call frames
    # at once. Localizing the stack pointer means that it will automatically
    # unwind the same amount when multiple stack frames are unwound.
    local $stack_depth = $stack_depth + 1;    # Protect from non-local exits

    # Expand @@stack.
    $#stack = $stack_depth;

    # Save current single-step setting.
    $stack[-1] = $single;

    # Turn off all flags except single-stepping.
    # Use local so the single-step value is popped back off the
    # stack for us.
    local $single = $single & 1;

    # If we've gotten really deeply recursed, turn on the flag that will
    # make us stop with the 'deep recursion' message.
    $single |= 4 if $stack_depth == $deep;

    # If frame messages are on ...
    _print_frame_message($al);

    # call the original lvalue sub.
    &$sub;
}

# Abstracting common code from multiple places elsewhere:
sub depth_print_lineinfo {
    my $always_print = shift;

    print_lineinfo( @@_ ) if ($always_print or $stack_depth < $trace_to_depth);
}

=head1 EXTENDED COMMAND HANDLING AND THE COMMAND API

In Perl 5.8.0, there was a major realignment of the commands and what they did,
Most of the changes were to systematize the command structure and to eliminate
commands that threw away user input without checking.

The following sections describe the code added to make it easy to support
multiple command sets with conflicting command names. This section is a start
at unifying all command processing to make it simpler to develop commands.

Note that all the cmd_[a-zA-Z] subroutines require the command name, a line
number, and C<$dbline> (the current line) as arguments.

Support functions in this section which have multiple modes of failure C<die>
on error; the rest simply return a false value.

The user-interface functions (all of the C<cmd_*> functions) just output
error messages.

=head2 C<%set>

The C<%set> hash defines the mapping from command letter to subroutine
name suffix.

C<%set> is a two-level hash, indexed by set name and then by command name.
Note that trying to set the CommandSet to C<foobar> simply results in the
5.8.0 command set being used, since there's no top-level entry for C<foobar>.

=cut

### The API section

my %set = (    #
    'pre580' => {
        'a' => 'pre580_a',
        'A' => 'pre580_null',
        'b' => 'pre580_b',
        'B' => 'pre580_null',
        'd' => 'pre580_null',
        'D' => 'pre580_D',
        'h' => 'pre580_h',
        'M' => 'pre580_null',
        'O' => 'o',
        'o' => 'pre580_null',
        'v' => 'M',
        'w' => 'v',
        'W' => 'pre580_W',
    },
    'pre590' => {
        '<'  => 'pre590_prepost',
        '<<' => 'pre590_prepost',
        '>'  => 'pre590_prepost',
        '>>' => 'pre590_prepost',
        '{'  => 'pre590_prepost',
        '{{' => 'pre590_prepost',
    },
);

my %breakpoints_data;

sub _has_breakpoint_data_ref {
    my ($filename, $line) = @@_;

    return (
        exists( $breakpoints_data{$filename} )
            and
        exists( $breakpoints_data{$filename}{$line} )
    );
}

sub _get_breakpoint_data_ref {
    my ($filename, $line) = @@_;

    return ($breakpoints_data{$filename}{$line} ||= +{});
}

sub _delete_breakpoint_data_ref {
    my ($filename, $line) = @@_;

    delete($breakpoints_data{$filename}{$line});
    if (! scalar(keys( %{$breakpoints_data{$filename}} )) ) {
        delete($breakpoints_data{$filename});
    }

    return;
}

sub _set_breakpoint_enabled_status {
    my ($filename, $line, $status) = @@_;

    _get_breakpoint_data_ref($filename, $line)->{'enabled'} =
        ($status ? 1 : '')
        ;

    return;
}

sub _enable_breakpoint_temp_enabled_status {
    my ($filename, $line) = @@_;

    _get_breakpoint_data_ref($filename, $line)->{'temp_enabled'} = 1;

    return;
}

sub _cancel_breakpoint_temp_enabled_status {
    my ($filename, $line) = @@_;

    my $ref = _get_breakpoint_data_ref($filename, $line);

    delete ($ref->{'temp_enabled'});

    if (! %$ref) {
        _delete_breakpoint_data_ref($filename, $line);
    }

    return;
}

sub _is_breakpoint_enabled {
    my ($filename, $line) = @@_;

    my $data_ref = _get_breakpoint_data_ref($filename, $line);
    return ($data_ref->{'enabled'} || $data_ref->{'temp_enabled'});
}

=head2 C<cmd_wrapper()> (API)

C<cmd_wrapper()> allows the debugger to switch command sets
depending on the value of the C<CommandSet> option.

It tries to look up the command in the C<%set> package-level I<lexical>
(which means external entities can't fiddle with it) and create the name of
the sub to call based on the value found in the hash (if it's there). I<All>
of the commands to be handled in a set have to be added to C<%set>; if they
aren't found, the 5.8.0 equivalent is called (if there is one).

This code uses symbolic references.

=cut

sub cmd_wrapper {
    my $cmd      = shift;
    my $line     = shift;
    my $dblineno = shift;

    # Assemble the command subroutine's name by looking up the
    # command set and command name in %set. If we can't find it,
    # default to the older version of the command.
    my $call = 'cmd_'
      . ( $set{$CommandSet}{$cmd}
          || ( $cmd =~ /\A[<>{]+/o ? 'prepost' : $cmd ) );

    # Call the command subroutine, call it by name.
    return __PACKAGE__->can($call)->( $cmd, $line, $dblineno );
} ## end sub cmd_wrapper

=head3 C<cmd_a> (command)

The C<a> command handles pre-execution actions. These are associated with a
particular line, so they're stored in C<%dbline>. We default to the current
line if none is specified.

=cut

sub cmd_a {
    my $cmd    = shift;
    my $line   = shift || '';    # [.|line] expr
    my $dbline = shift;

    # If it's dot (here), or not all digits,  use the current line.
    $line =~ s/\A\./$dbline/;

    # Should be a line number followed by an expression.
    if ( my ($lineno, $expr) = $line =~ /^\s*(\d*)\s*(\S.+)/ ) {

        if (! length($lineno)) {
            $lineno = $dbline;
        }

        # If we have an expression ...
        if ( length $expr ) {

            # ... but the line isn't breakable, complain.
            if ( $dbline[$lineno] == 0 ) {
                print $OUT
                  "Line $lineno($dbline[$lineno]) does not have an action?\n";
            }
            else {

                # It's executable. Record that the line has an action.
                $had_breakpoints{$filename} |= 2;

                # Remove any action, temp breakpoint, etc.
                $dbline{$lineno} =~ s/\0[^\0]*//;

                # Add the action to the line.
                $dbline{$lineno} .= "\0" . action($expr);

                _set_breakpoint_enabled_status($filename, $lineno, 1);
            }
        } ## end if (length $expr)
    } ## end if ($line =~ /^\s*(\d*)\s*(\S.+)/)
    else {

        # Syntax wrong.
        print $OUT
          "Adding an action requires an optional lineno and an expression\n"
          ;    # hint
    }
} ## end sub cmd_a

=head3 C<cmd_A> (command)

Delete actions. Similar to above, except the delete code is in a separate
subroutine, C<delete_action>.

=cut

sub cmd_A {
    my $cmd    = shift;
    my $line   = shift || '';
    my $dbline = shift;

    # Dot is this line.
    $line =~ s/^\./$dbline/;

    # Call delete_action with a null param to delete them all.
    # The '1' forces the eval to be true. It'll be false only
    # if delete_action blows up for some reason, in which case
    # we print $@@ and get out.
    if ( $line eq '*' ) {
        if (! eval { _delete_all_actions(); 1 }) {
            print {$OUT} $@@;
            return;
        }
    }

    # There's a real line  number. Pass it to delete_action.
    # Error trapping is as above.
    elsif ( $line =~ /^(\S.*)/ ) {
        if (! eval { delete_action($1); 1 }) {
            print {$OUT} $@@;
            return;
        }
    }

    # Swing and a miss. Bad syntax.
    else {
        print $OUT
          "Deleting an action requires a line number, or '*' for all\n" ; # hint
    }
} ## end sub cmd_A

=head3 C<delete_action> (API)

C<delete_action> accepts either a line number or C<undef>. If a line number
is specified, we check for the line being executable (if it's not, it
couldn't have had an  action). If it is, we just take the action off (this
will get any kind of an action, including breakpoints).

=cut

sub _remove_action_from_dbline {
    my $i = shift;

    $dbline{$i} =~ s/\0[^\0]*//;    # \^a
    delete $dbline{$i} if $dbline{$i} eq '';

    return;
}

sub _delete_all_actions {
    print {$OUT} "Deleting all actions...\n";

    for my $file ( keys %had_breakpoints ) {
        local *dbline = $main::{ '_<' . $file };
        $max = $#dbline;
        my $was;
        for my $i (1 .. $max) {
            if ( defined $dbline{$i} ) {
                _remove_action_from_dbline($i);
            }
        }

        unless ( $had_breakpoints{$file} &= ~2 ) {
            delete $had_breakpoints{$file};
        }
    }

    return;
}

sub delete_action {
    my $i = shift;

    if ( defined($i) ) {
        # Can there be one?
        die "Line $i has no action .\n" if $dbline[$i] == 0;

        # Nuke whatever's there.
        _remove_action_from_dbline($i);
    }
    else {
        _delete_all_actions();
    }
}

=head3 C<cmd_b> (command)

Set breakpoints. Since breakpoints can be set in so many places, in so many
ways, conditionally or not, the breakpoint code is kind of complex. Mostly,
we try to parse the command type, and then shuttle it off to an appropriate
subroutine to actually do the work of setting the breakpoint in the right
place.

=cut

sub cmd_b {
    my $cmd    = shift;
    my $line   = shift;    # [.|line] [cond]
    my $dbline = shift;

    my $default_cond = sub {
        my $cond = shift;
        return length($cond) ? $cond : '1';
    };

    # Make . the current line number if it's there..
    $line =~ s/^\.(\s|\z)/$dbline$1/;

    # No line number, no condition. Simple break on current line.
    if ( $line =~ /^\s*$/ ) {
        cmd_b_line( $dbline, 1 );
    }

    # Break on load for a file.
    elsif ( my ($file) = $line =~ /^load\b\s*(.*)/ ) {
        $file =~ s/\s+\z//;
        cmd_b_load($file);
    }

    # b compile|postpone <some sub> [<condition>]
    # The interpreter actually traps this one for us; we just put the
    # necessary condition in the %postponed hash.
    elsif ( my ($action, $subname, $cond)
        = $line =~ /^(postpone|compile)\b\s*([':A-Za-z_][':\w]*)\s*(.*)/ ) {

        # De-Perl4-ify the name - ' separators to ::.
        $subname =~ s/'/::/g;

        # Qualify it into the current package unless it's already qualified.
        $subname = "${package}::" . $subname unless $subname =~ /::/;

        # Add main if it starts with ::.
        $subname = "main" . $subname if substr( $subname, 0, 2 ) eq "::";

        # Save the break type for this sub.
        $postponed{$subname} = (($action eq 'postpone')
            ? ( "break +0 if " . $default_cond->($cond) )
            : "compile");
    } ## end elsif ($line =~ ...
    # b <filename>:<line> [<condition>]
    elsif (my ($filename, $line_num, $cond)
        = $line =~ /\A(\S+[^:]):(\d+)\s*(.*)/ms) {
        cmd_b_filename_line(
            $filename,
            $line_num,
            (length($cond) ? $cond : '1'),
        );
    }
    # b <sub name> [<condition>]
    elsif ( my ($new_subname, $new_cond) =
        $line =~ /^([':A-Za-z_][':\w]*(?:\[.*\])?)\s*(.*)/ ) {

        #
        $subname = $new_subname;
        cmd_b_sub( $subname, $default_cond->($new_cond) );
    }

    # b <line> [<condition>].
    elsif ( my ($line_n, $cond) = $line =~ /^(\d*)\s*(.*)/ ) {

        # Capture the line. If none, it's the current line.
        $line = $line_n || $dbline;

        # Break on line.
        cmd_b_line( $line, $default_cond->($cond) );
    }

    # Line didn't make sense.
    else {
        print "confused by line($line)?\n";
    }

    return;
} ## end sub cmd_b

=head3 C<break_on_load> (API)

We want to break when this file is loaded. Mark this file in the
C<%break_on_load> hash, and note that it has a breakpoint in
C<%had_breakpoints>.

=cut

sub break_on_load {
    my $file = shift;
    $break_on_load{$file} = 1;
    $had_breakpoints{$file} |= 1;
}

=head3 C<report_break_on_load> (API)

Gives us an array of filenames that are set to break on load. Note that
only files with break-on-load are in here, so simply showing the keys
suffices.

=cut

sub report_break_on_load {
    sort keys %break_on_load;
}

=head3 C<cmd_b_load> (command)

We take the file passed in and try to find it in C<%INC> (which maps modules
to files they came from). We mark those files for break-on-load via
C<break_on_load> and then report that it was done.

=cut

sub cmd_b_load {
    my $file = shift;
    my @@files;

    # This is a block because that way we can use a redo inside it
    # even without there being any looping structure at all outside it.
    {

        # Save short name and full path if found.
        push @@files, $file;
        push @@files, $::INC{$file} if $::INC{$file};

        # Tack on .pm and do it again unless there was a '.' in the name
        # already.
        $file .= '.pm', redo unless $file =~ /\./;
    }

    # Do the real work here.
    break_on_load($_) for @@files;

    # All the files that have break-on-load breakpoints.
    @@files = report_break_on_load;

    # Normalize for the purposes of our printing this.
    local $\ = '';
    local $" = ' ';
    print $OUT "Will stop on load of '@@files'.\n";
} ## end sub cmd_b_load

=head3 C<$filename_error> (API package global)

Several of the functions we need to implement in the API need to work both
on the current file and on other files. We don't want to duplicate code, so
C<$filename_error> is used to contain the name of the file that's being
worked on (if it's not the current one).

We can now build functions in pairs: the basic function works on the current
file, and uses C<$filename_error> as part of its error message. Since this is
initialized to C<"">, no filename will appear when we are working on the
current file.

The second function is a wrapper which does the following:

=over 4

=item *

Localizes C<$filename_error> and sets it to the name of the file to be processed.

=item *

Localizes the C<*dbline> glob and reassigns it to point to the file we want to process.

=item *

Calls the first function.

The first function works on the I<current> file (i.e., the one we changed to),
and prints C<$filename_error> in the error message (the name of the other file)
if it needs to. When the functions return, C<*dbline> is restored to point
to the actual current file (the one we're executing in) and
C<$filename_error> is restored to C<"">. This restores everything to
the way it was before the second function was called at all.

See the comments in C<breakable_line> and C<breakable_line_in_file> for more
details.

=back

=cut

use vars qw($filename_error);
$filename_error = '';

=head3 breakable_line(from, to) (API)

The subroutine decides whether or not a line in the current file is breakable.
It walks through C<@@dbline> within the range of lines specified, looking for
the first line that is breakable.

If C<$to> is greater than C<$from>, the search moves forwards, finding the
first line I<after> C<$to> that's breakable, if there is one.

If C<$from> is greater than C<$to>, the search goes I<backwards>, finding the
first line I<before> C<$to> that's breakable, if there is one.

=cut

sub breakable_line {

    my ( $from, $to ) = @@_;

    # $i is the start point. (Where are the FORTRAN programs of yesteryear?)
    my $i = $from;

    # If there are at least 2 arguments, we're trying to search a range.
    if ( @@_ >= 2 ) {

        # $delta is positive for a forward search, negative for a backward one.
        my $delta = $from < $to ? +1 : -1;

        # Keep us from running off the ends of the file.
        my $limit = $delta > 0 ? $#dbline : 1;

        # Clever test. If you're a mathematician, it's obvious why this
        # test works. If not:
        # If $delta is positive (going forward), $limit will be $#dbline.
        #    If $to is less than $limit, ($limit - $to) will be positive, times
        #    $delta of 1 (positive), so the result is > 0 and we should use $to
        #    as the stopping point.
        #
        #    If $to is greater than $limit, ($limit - $to) is negative,
        #    times $delta of 1 (positive), so the result is < 0 and we should
        #    use $limit ($#dbline) as the stopping point.
        #
        # If $delta is negative (going backward), $limit will be 1.
        #    If $to is zero, ($limit - $to) will be 1, times $delta of -1
        #    (negative) so the result is > 0, and we use $to as the stopping
        #    point.
        #
        #    If $to is less than zero, ($limit - $to) will be positive,
        #    times $delta of -1 (negative), so the result is not > 0, and
        #    we use $limit (1) as the stopping point.
        #
        #    If $to is 1, ($limit - $to) will zero, times $delta of -1
        #    (negative), still giving zero; the result is not > 0, and
        #    we use $limit (1) as the stopping point.
        #
        #    if $to is >1, ($limit - $to) will be negative, times $delta of -1
        #    (negative), giving a positive (>0) value, so we'll set $limit to
        #    $to.

        $limit = $to if ( $limit - $to ) * $delta > 0;

        # The real search loop.
        # $i starts at $from (the point we want to start searching from).
        # We move through @@dbline in the appropriate direction (determined
        # by $delta: either -1 (back) or +1 (ahead).
        # We stay in as long as we haven't hit an executable line
        # ($dbline[$i] == 0 means not executable) and we haven't reached
        # the limit yet (test similar to the above).
        $i += $delta while $dbline[$i] == 0 and ( $limit - $i ) * $delta > 0;

    } ## end if (@@_ >= 2)

    # If $i points to a line that is executable, return that.
    return $i unless $dbline[$i] == 0;

    # Format the message and print it: no breakable lines in range.
    my ( $pl, $upto ) = ( '', '' );
    ( $pl, $upto ) = ( 's', "..$to" ) if @@_ >= 2 and $from != $to;

    # If there's a filename in filename_error, we'll see it.
    # If not, not.
    die "Line$pl $from$upto$filename_error not breakable\n";
} ## end sub breakable_line

=head3 breakable_line_in_filename(file, from, to) (API)

Like C<breakable_line>, but look in another file.

=cut

sub breakable_line_in_filename {

    # Capture the file name.
    my ($f) = shift;

    # Swap the magic line array over there temporarily.
    local *dbline = $main::{ '_<' . $f };

    # If there's an error, it's in this other file.
    local $filename_error = " of '$f'";

    # Find the breakable line.
    breakable_line(@@_);

    # *dbline and $filename_error get restored when this block ends.

} ## end sub breakable_line_in_filename

=head3 break_on_line(lineno, [condition]) (API)

Adds a breakpoint with the specified condition (or 1 if no condition was
specified) to the specified line. Dies if it can't.

=cut

sub break_on_line {
    my $i = shift;
    my $cond = @@_ ? shift(@@_) : 1;

    my $inii  = $i;
    my $after = '';
    my $pl    = '';

    # Woops, not a breakable line. $filename_error allows us to say
    # if it was in a different file.
    die "Line $i$filename_error not breakable.\n" if $dbline[$i] == 0;

    # Mark this file as having breakpoints in it.
    $had_breakpoints{$filename} |= 1;

    # If there is an action or condition here already ...
    if ( $dbline{$i} ) {

        # ... swap this condition for the existing one.
        $dbline{$i} =~ s/^[^\0]*/$cond/;
    }
    else {

        # Nothing here - just add the condition.
        $dbline{$i} = $cond;

        _set_breakpoint_enabled_status($filename, $i, 1);
    }

    return;
} ## end sub break_on_line

=head3 cmd_b_line(line, [condition]) (command)

Wrapper for C<break_on_line>. Prints the failure message if it
doesn't work.

=cut

sub cmd_b_line {
    if (not eval { break_on_line(@@_); 1 }) {
        local $\ = '';
        print $OUT $@@ and return;
    }

    return;
} ## end sub cmd_b_line

=head3 cmd_b_filename_line(line, [condition]) (command)

Wrapper for C<break_on_filename_line>. Prints the failure message if it
doesn't work.

=cut

sub cmd_b_filename_line {
    if (not eval { break_on_filename_line(@@_); 1 }) {
        local $\ = '';
        print $OUT $@@ and return;
    }

    return;
}

=head3 break_on_filename_line(file, line, [condition]) (API)

Switches to the file specified and then calls C<break_on_line> to set
the breakpoint.

=cut

sub break_on_filename_line {
    my $f = shift;
    my $i = shift;
    my $cond = @@_ ? shift(@@_) : 1;

    # Switch the magical hash temporarily.
    local *dbline = $main::{ '_<' . $f };

    # Localize the variables that break_on_line uses to make its message.
    local $filename_error = " of '$f'";
    local $filename       = $f;

    # Add the breakpoint.
    break_on_line( $i, $cond );

    return;
} ## end sub break_on_filename_line

=head3 break_on_filename_line_range(file, from, to, [condition]) (API)

Switch to another file, search the range of lines specified for an
executable one, and put a breakpoint on the first one you find.

=cut

sub break_on_filename_line_range {
    my $f = shift;
    my $from = shift;
    my $to = shift;
    my $cond = @@_ ? shift(@@_) : 1;

    # Find a breakable line if there is one.
    my $i = breakable_line_in_filename( $f, $from, $to );

    # Add the breakpoint.
    break_on_filename_line( $f, $i, $cond );

    return;
} ## end sub break_on_filename_line_range

=head3 subroutine_filename_lines(subname, [condition]) (API)

Search for a subroutine within a given file. The condition is ignored.
Uses C<find_sub> to locate the desired subroutine.

=cut

sub subroutine_filename_lines {
    my ( $subname ) = @@_;

    # Returned value from find_sub() is fullpathname:startline-endline.
    # The match creates the list (fullpathname, start, end).
    return (find_sub($subname) =~ /^(.*):(\d+)-(\d+)$/);
} ## end sub subroutine_filename_lines

=head3 break_subroutine(subname) (API)

Places a break on the first line possible in the specified subroutine. Uses
C<subroutine_filename_lines> to find the subroutine, and
C<break_on_filename_line_range> to place the break.

=cut

sub break_subroutine {
    my $subname = shift;

    # Get filename, start, and end.
    my ( $file, $s, $e ) = subroutine_filename_lines($subname)
      or die "Subroutine $subname not found.\n";


    # Null condition changes to '1' (always true).
    my $cond = @@_ ? shift(@@_) : 1;

    # Put a break the first place possible in the range of lines
    # that make up this subroutine.
    break_on_filename_line_range( $file, $s, $e, $cond );

    return;
} ## end sub break_subroutine

=head3 cmd_b_sub(subname, [condition]) (command)

We take the incoming subroutine name and fully-qualify it as best we can.

=over 4

=item 1. If it's already fully-qualified, leave it alone.

=item 2. Try putting it in the current package.

=item 3. If it's not there, try putting it in CORE::GLOBAL if it exists there.

=item 4. If it starts with '::', put it in 'main::'.

=back

After all this cleanup, we call C<break_subroutine> to try to set the
breakpoint.

=cut

sub cmd_b_sub {
    my $subname = shift;
    my $cond = @@_ ? shift : 1;

    # If the subname isn't a code reference, qualify it so that
    # break_subroutine() will work right.
    if ( ref($subname) ne 'CODE' ) {

        # Not Perl 4.
        $subname =~ s/'/::/g;
        my $s = $subname;

        # Put it in this package unless it's already qualified.
        if ($subname !~ /::/)
        {
            $subname = $package . '::' . $subname;
        };

        # Requalify it into CORE::GLOBAL if qualifying it into this
        # package resulted in its not being defined, but only do so
        # if it really is in CORE::GLOBAL.
        my $core_name = "CORE::GLOBAL::$s";
        if ((!defined(&$subname))
                and ($s !~ /::/)
                and (defined &{$core_name}))
        {
            $subname = $core_name;
        }

        # Put it in package 'main' if it has a leading ::.
        if ($subname =~ /\A::/)
        {
            $subname = "main" . $subname;
        }
    } ## end if ( ref($subname) ne 'CODE' ) {

    # Try to set the breakpoint.
    if (not eval { break_subroutine( $subname, $cond ); 1 }) {
        local $\ = '';
        print {$OUT} $@@;
        return;
    }

    return;
} ## end sub cmd_b_sub

=head3 C<cmd_B> - delete breakpoint(s) (command)

The command mostly parses the command line and tries to turn the argument
into a line spec. If it can't, it uses the current line. It then calls
C<delete_breakpoint> to actually do the work.

If C<*> is  specified, C<cmd_B> calls C<delete_breakpoint> with no arguments,
thereby deleting all the breakpoints.

=cut

sub cmd_B {
    my $cmd = shift;

    # No line spec? Use dbline.
    # If there is one, use it if it's non-zero, or wipe it out if it is.
    my $line   = ( $_[0] =~ /\A\./ ) ? $dbline : (shift || '');
    my $dbline = shift;

    # If the line was dot, make the line the current one.
    $line =~ s/^\./$dbline/;

    # If it's * we're deleting all the breakpoints.
    if ( $line eq '*' ) {
        if (not eval { delete_breakpoint(); 1 }) {
            print {$OUT} $@@;
        }
    }

    # If there is a line spec, delete the breakpoint on that line.
    elsif ( $line =~ /\A(\S.*)/ ) {
        if (not eval { delete_breakpoint( $line || $dbline ); 1 }) {
            local $\ = '';
            print {$OUT} $@@;
        }
    } ## end elsif ($line =~ /^(\S.*)/)

    # No line spec.
    else {
        print {$OUT}
          "Deleting a breakpoint requires a line number, or '*' for all\n"
          ;    # hint
    }

    return;
} ## end sub cmd_B

=head3 delete_breakpoint([line]) (API)

This actually does the work of deleting either a single breakpoint, or all
of them.

For a single line, we look for it in C<@@dbline>. If it's nonbreakable, we
just drop out with a message saying so. If it is, we remove the condition
part of the 'condition\0action' that says there's a breakpoint here. If,
after we've done that, there's nothing left, we delete the corresponding
line in C<%dbline> to signal that no action needs to be taken for this line.

For all breakpoints, we iterate through the keys of C<%had_breakpoints>,
which lists all currently-loaded files which have breakpoints. We then look
at each line in each of these files, temporarily switching the C<%dbline>
and C<@@dbline> structures to point to the files in question, and do what
we did in the single line case: delete the condition in C<@@dbline>, and
delete the key in C<%dbline> if nothing's left.

We then wholesale delete C<%postponed>, C<%postponed_file>, and
C<%break_on_load>, because these structures contain breakpoints for files
and code that haven't been loaded yet. We can just kill these off because there
are no magical debugger structures associated with them.

=cut

sub _remove_breakpoint_entry {
    my ($fn, $i) = @@_;

    delete $dbline{$i};
    _delete_breakpoint_data_ref($fn, $i);

    return;
}

sub _delete_all_breakpoints {
    print {$OUT} "Deleting all breakpoints...\n";

    # %had_breakpoints lists every file that had at least one
    # breakpoint in it.
    for my $fn ( keys %had_breakpoints ) {

        # Switch to the desired file temporarily.
        local *dbline = $main::{ '_<' . $fn };

        $max = $#dbline;

        # For all lines in this file ...
        for my $i (1 .. $max) {

            # If there's a breakpoint or action on this line ...
            if ( defined $dbline{$i} ) {

                # ... remove the breakpoint.
                $dbline{$i} =~ s/\A[^\0]+//;
                if ( $dbline{$i} =~ s/\A\0?\z// ) {
                    # Remove the entry altogether if no action is there.
                    _remove_breakpoint_entry($fn, $i);
                }
            } ## end if (defined $dbline{$i...
        } ## end for $i (1 .. $max)

        # If, after we turn off the "there were breakpoints in this file"
        # bit, the entry in %had_breakpoints for this file is zero,
        # we should remove this file from the hash.
        if ( not $had_breakpoints{$fn} &= (~1) ) {
            delete $had_breakpoints{$fn};
        }
    } ## end for my $fn (keys %had_breakpoints)

    # Kill off all the other breakpoints that are waiting for files that
    # haven't been loaded yet.
    undef %postponed;
    undef %postponed_file;
    undef %break_on_load;

    return;
}

sub _delete_breakpoint_from_line {
    my ($i) = @@_;

    # Woops. This line wasn't breakable at all.
    die "Line $i not breakable.\n" if $dbline[$i] == 0;

    # Kill the condition, but leave any action.
    $dbline{$i} =~ s/\A[^\0]*//;

    # Remove the entry entirely if there's no action left.
    if ($dbline{$i} eq '') {
        _remove_breakpoint_entry($filename, $i);
    }

    return;
}

sub delete_breakpoint {
    my $i = shift;

    # If we got a line, delete just that one.
    if ( defined($i) ) {
        _delete_breakpoint_from_line($i);
    }
    # No line; delete them all.
    else {
        _delete_all_breakpoints();
    }

    return;
}

=head3 cmd_stop (command)

This is meant to be part of the new command API, but it isn't called or used
anywhere else in the debugger. XXX It is probably meant for use in development
of new commands.

=cut

sub cmd_stop {    # As on ^C, but not signal-safy.
    $signal = 1;
}

=head3 C<cmd_e> - threads

Display the current thread id:

    e

This could be how (when implemented) to send commands to this thread id (e cmd)
or that thread id (e tid cmd).

=cut

sub cmd_e {
    my $cmd  = shift;
    my $line = shift;
    unless (exists($INC{'threads.pm'})) {
        print "threads not loaded($ENV{PERL5DB_THREADED})
        please run the debugger with PERL5DB_THREADED=1 set in the environment\n";
    } else {
        my $tid = threads->tid;
        print "thread id: $tid\n";
    }
} ## end sub cmd_e

=head3 C<cmd_E> - list of thread ids

Display the list of available thread ids:

    E

This could be used (when implemented) to send commands to all threads (E cmd).

=cut

sub cmd_E {
    my $cmd  = shift;
    my $line = shift;
    unless (exists($INC{'threads.pm'})) {
        print "threads not loaded($ENV{PERL5DB_THREADED})
        please run the debugger with PERL5DB_THREADED=1 set in the environment\n";
    } else {
        my $tid = threads->tid;
        print "thread ids: ".join(', ',
            map { ($tid == $_->tid ? '<'.$_->tid.'>' : $_->tid) } threads->list
        )."\n";
    }
} ## end sub cmd_E

=head3 C<cmd_h> - help command (command)

Does the work of either

=over 4

=item *

Showing all the debugger help

=item *

Showing help for a specific command

=back

=cut

use vars qw($help);
use vars qw($summary);

sub cmd_h {
    my $cmd = shift;

    # If we have no operand, assume null.
    my $line = shift || '';

    # 'h h'. Print the long-format help.
    if ( $line =~ /\Ah\s*\z/ ) {
        print_help($help);
    }

    # 'h <something>'. Search for the command and print only its help.
    elsif ( my ($asked) = $line =~ /\A(\S.*)\z/ ) {

        # support long commands; otherwise bogus errors
        # happen when you ask for h on <CR> for example
        my $qasked = quotemeta($asked);    # for searching; we don't
                                           # want to use it as a pattern.
                                           # XXX: finds CR but not <CR>

        # Search the help string for the command.
        if (
            $help =~ /^                    # Start of a line
                      <?                   # Optional '<'
                      (?:[IB]<)            # Optional markup
                      $qasked              # The requested command
                     /mx
          )
        {

            # It's there; pull it out and print it.
            while (
                $help =~ /^
                              (<?            # Optional '<'
                                 (?:[IB]<)   # Optional markup
                                 $qasked     # The command
                                 ([\s\S]*?)  # Description line(s)
                              \n)            # End of last description line
                              (?!\s)         # Next line not starting with
                                             # whitespace
                             /mgx
              )
            {
                print_help($1);
            }
        }

        # Not found; not a debugger command.
        else {
            print_help("B<$asked> is not a debugger command.\n");
        }
    } ## end elsif ($line =~ /^(\S.*)$/)

    # 'h' - print the summary help.
    else {
        print_help($summary);
    }
} ## end sub cmd_h

=head3 C<cmd_i> - inheritance display

Display the (nested) parentage of the module or object given.

=cut

sub cmd_i {
    my $cmd  = shift;
    my $line = shift;
    foreach my $isa ( split( /\s+/, $line ) ) {
        $evalarg = $isa;
        # The &-call is here to ascertain the mutability of @@_.
        ($isa) = &DB::eval;
        no strict 'refs';
        print join(
            ', ',
            map {
                "$_"
                  . (
                    defined( ${"$_\::VERSION"} )
                    ? ' ' . ${"$_\::VERSION"}
                    : undef )
              } @@{mro::get_linear_isa(ref($isa) || $isa)}
        );
        print "\n";
    }
} ## end sub cmd_i

=head3 C<cmd_l> - list lines (command)

Most of the command is taken up with transforming all the different line
specification syntaxes into 'start-stop'. After that is done, the command
runs a loop over C<@@dbline> for the specified range of lines. It handles
the printing of each line and any markers (C<==E<gt>> for current line,
C<b> for break on this line, C<a> for action on this line, C<:> for this
line breakable).

We save the last line listed in the C<$start> global for further listing
later.

=cut

sub _min {
    my $min = shift;
    foreach my $v (@@_) {
        if ($min > $v) {
            $min = $v;
        }
    }
    return $min;
}

sub _max {
    my $max = shift;
    foreach my $v (@@_) {
        if ($max < $v) {
            $max = $v;
        }
    }
    return $max;
}

sub _minify_to_max {
    my $ref = shift;

    $$ref = _min($$ref, $max);

    return;
}

sub _cmd_l_handle_var_name {
    my $var_name = shift;

    $evalarg = $var_name;

    my ($s) = DB::eval();

    # Ooops. Bad scalar.
    if ($@@) {
        print {$OUT} "Error: $@@\n";
        next CMD;
    }

    # Good scalar. If it's a reference, find what it points to.
    $s = CvGV_name($s);
    print {$OUT} "Interpreted as: $1 $s\n";
    $line = "$1 $s";

    # Call self recursively to really do the command.
    return _cmd_l_main( $s );
}

sub _cmd_l_handle_subname {

    my $s = $subname;

    # De-Perl4.
    $subname =~ s/\'/::/;

    # Put it in this package unless it starts with ::.
    $subname = $package . "::" . $subname unless $subname =~ /::/;

    # Put it in CORE::GLOBAL if t doesn't start with :: and
    # it doesn't live in this package and it lives in CORE::GLOBAL.
    $subname = "CORE::GLOBAL::$s"
    if not defined &$subname
        and $s !~ /::/
        and defined &{"CORE::GLOBAL::$s"};

    # Put leading '::' names into 'main::'.
    $subname = "main" . $subname if substr( $subname, 0, 2 ) eq "::";

    # Get name:start-stop from find_sub, and break this up at
    # colons.
    my @@pieces = split( /:/, find_sub($subname) || $sub{$subname} );

    # Pull off start-stop.
    my $subrange = pop @@pieces;

    # If the name contained colons, the split broke it up.
    # Put it back together.
    $file = join( ':', @@pieces );

    # If we're not in that file, switch over to it.
    if ( $file ne $filename ) {
        if (! $slave_editor) {
            print {$OUT} "Switching to file '$file'.\n";
        }

        # Switch debugger's magic structures.
        *dbline   = $main::{ '_<' . $file };
        $max      = $#dbline;
        $filename = $file;
    } ## end if ($file ne $filename)

    # Subrange is 'start-stop'. If this is less than a window full,
    # swap it to 'start+', which will list a window from the start point.
    if ($subrange) {
        if ( eval($subrange) < -$window ) {
            $subrange =~ s/-.*/+/;
        }

        # Call self recursively to list the range.
        return _cmd_l_main( $subrange );
    } ## end if ($subrange)

    # Couldn't find it.
    else {
        print {$OUT} "Subroutine $subname not found.\n";
        return;
    }
}

sub _cmd_l_empty {
    # Compute new range to list.
    $incr = $window - 1;

    # Recurse to do it.
    return _cmd_l_main( $start . '-' . ( $start + $incr ) );
}

sub _cmd_l_plus {
    my ($new_start, $new_incr) = @@_;

    # Don't reset start for 'l +nnn'.
    $start = $new_start if $new_start;

    # Increment for list. Use window size if not specified.
    # (Allows 'l +' to work.)
    $incr = $new_incr || ($window - 1);

    # Create a line range we'll understand, and recurse to do it.
    return _cmd_l_main( $start . '-' . ( $start + $incr ) );
}

sub _cmd_l_calc_initial_end_and_i {
    my ($spec, $start_match, $end_match) = @@_;

    # Determine end point; use end of file if not specified.
    my $end = ( !defined $start_match ) ? $max :
    ( $end_match ? $end_match : $start_match );

    # Go on to the end, and then stop.
    _minify_to_max(\$end);

    # Determine start line.
    my $i = $start_match;

    if ($i eq '.') {
        $i = $spec;
    }

    $i = _max($i, 1);

    $incr = $end - $i;

    return ($end, $i);
}

sub _cmd_l_range {
    my ($spec, $current_line, $start_match, $end_match) = @@_;

    my ($end, $i) =
        _cmd_l_calc_initial_end_and_i($spec, $start_match, $end_match);

    # If we're running under a slave editor, force it to show the lines.
    if ($slave_editor) {
        print {$OUT} "\032\032$filename:$i:0\n";
        $i = $end;
    }
    # We're doing it ourselves. We want to show the line and special
    # markers for:
    # - the current line in execution
    # - whether a line is breakable or not
    # - whether a line has a break or not
    # - whether a line has an action or not
    else {
        I_TO_END:
        for ( ; $i <= $end ; $i++ ) {

            # Check for breakpoints and actions.
            my ( $stop, $action );
            if ($dbline{$i}) {
                ( $stop, $action ) = split( /\0/, $dbline{$i} );
            }

            # ==> if this is the current line in execution,
            # : if it's breakable.
            my $arrow =
            ( $i == $current_line and $filename eq $filename_ini )
            ? '==>'
            : ( $dbline[$i] + 0 ? ':' : ' ' );

            # Add break and action indicators.
            $arrow .= 'b' if $stop;
            $arrow .= 'a' if $action;

            # Print the line.
            print {$OUT} "$i$arrow\t", $dbline[$i];

            # Move on to the next line. Drop out on an interrupt.
            if ($signal) {
                $i++;
                last I_TO_END;
            }
        } ## end for (; $i <= $end ; $i++)

        # Line the prompt up; print a newline if the last line listed
        # didn't have a newline.
        if ($dbline[ $i - 1 ] !~ /\n\z/) {
            print {$OUT} "\n";
        }
    } ## end else [ if ($slave_editor)

    # Save the point we last listed to in case another relative 'l'
    # command is desired. Don't let it run off the end.
    $start = $i;
    _minify_to_max(\$start);

    return;
}

sub _cmd_l_main {
    my $spec = shift;

    # If this is '-something', delete any spaces after the dash.
    $spec =~ s/\A-\s*\z/-/;

    # If the line is '$something', assume this is a scalar containing a
    # line number.
    # Set up for DB::eval() - evaluate in *user* context.
    if ( my ($var_name) = $spec =~ /\A(\$.*)/s ) {
        return _cmd_l_handle_var_name($var_name);
    }
    # l name. Try to find a sub by that name.
    elsif ( ($subname) = $spec =~ /\A([\':A-Za-z_][\':\w]*(?:\[.*\])?)/s ) {
        return _cmd_l_handle_subname();
    }
    # Bare 'l' command.
    elsif ( $spec !~ /\S/ ) {
        return _cmd_l_empty();
    }
    # l [start]+number_of_lines
    elsif ( my ($new_start, $new_incr) = $spec =~ /\A(\d*)\+(\d*)\z/ ) {
        return _cmd_l_plus($new_start, $new_incr);
    }
    # l start-stop or l start,stop
    elsif (my ($s, $e) = $spec =~ /^(?:(-?[\d\$\.]+)(?:[-,]([\d\$\.]+))?)?/ ) {
        return _cmd_l_range($spec, $line, $s, $e);
    }

    return;
} ## end sub cmd_l

sub cmd_l {
    my (undef, $line) = @@_;

    return _cmd_l_main($line);
}

=head3 C<cmd_L> - list breakpoints, actions, and watch expressions (command)

To list breakpoints, the command has to look determine where all of them are
first. It starts a C<%had_breakpoints>, which tells us what all files have
breakpoints and/or actions. For each file, we switch the C<*dbline> glob (the
magic source and breakpoint data structures) to the file, and then look
through C<%dbline> for lines with breakpoints and/or actions, listing them
out. We look through C<%postponed> not-yet-compiled subroutines that have
breakpoints, and through C<%postponed_file> for not-yet-C<require>'d files
that have breakpoints.

Watchpoints are simpler: we just list the entries in C<@@to_watch>.

=cut

sub _cmd_L_calc_arg {
    # If no argument, list everything. Pre-5.8.0 version always lists
    # everything
    my $arg = shift || 'abw';
    if ($CommandSet ne '580')
    {
        $arg = 'abw';
    }

    return $arg;
}

sub _cmd_L_calc_wanted_flags {
    my $arg = _cmd_L_calc_arg(shift);

    return (map { index($arg, $_) >= 0 ? 1 : 0 } qw(a b w));
}


sub _cmd_L_handle_breakpoints {
    my ($handle_db_line) = @@_;

    BREAKPOINTS_SCAN:
    # Look in all the files with breakpoints...
    for my $file ( keys %had_breakpoints ) {

        # Temporary switch to this file.
        local *dbline = $main::{ '_<' . $file };

        # Set up to look through the whole file.
        $max = $#dbline;
        my $was;    # Flag: did we print something
        # in this file?

        # For each line in the file ...
        for my $i (1 .. $max) {

            # We've got something on this line.
            if ( defined $dbline{$i} ) {

                # Print the header if we haven't.
                if (not $was++) {
                    print {$OUT} "$file:\n";
                }

                # Print the line.
                print {$OUT} " $i:\t", $dbline[$i];

                $handle_db_line->($dbline{$i});

                # Quit if the user hit interrupt.
                if ($signal) {
                    last BREAKPOINTS_SCAN;
                }
            } ## end if (defined $dbline{$i...
        } ## end for my $i (1 .. $max)
    } ## end for my $file (keys %had_breakpoints)

    return;
}

sub _cmd_L_handle_postponed_breakpoints {
    my ($handle_db_line) = @@_;

    print {$OUT} "Postponed breakpoints in files:\n";

    POSTPONED_SCANS:
    for my $file ( keys %postponed_file ) {
        my $db = $postponed_file{$file};
        print {$OUT} " $file:\n";
        for my $line ( sort { $a <=> $b } keys %$db ) {
            print {$OUT} "  $line:\n";

            $handle_db_line->($db->{$line});

            if ($signal) {
                last POSTPONED_SCANS;
            }
        }
        if ($signal) {
            last POSTPONED_SCANS;
        }
    }

    return;
}


sub cmd_L {
    my $cmd = shift;

    my ($action_wanted, $break_wanted, $watch_wanted) =
        _cmd_L_calc_wanted_flags(shift);

    my $handle_db_line = sub {
        my ($l) = @@_;

        my ( $stop, $action ) = split( /\0/, $l );

        if ($stop and $break_wanted) {
            print {$OUT} "    break if (", $stop, ")\n"
        }

        if ($action && $action_wanted) {
            print {$OUT} "    action:  ", $action, "\n"
        }

        return;
    };

    # Breaks and actions are found together, so we look in the same place
    # for both.
    if ( $break_wanted or $action_wanted ) {
        _cmd_L_handle_breakpoints($handle_db_line);
    }

    # Look for breaks in not-yet-compiled subs:
    if ( %postponed and $break_wanted ) {
        print {$OUT} "Postponed breakpoints in subroutines:\n";
        my $subname;
        SUBS_SCAN:
        for $subname ( keys %postponed ) {
            print {$OUT} " $subname\t$postponed{$subname}\n";
            if ($signal) {
                last SUBS_SCAN;
            }
        }
    } ## end if (%postponed and $break_wanted)

    # Find files that have not-yet-loaded breaks:
    my @@have = map {    # Combined keys
        keys %{ $postponed_file{$_} }
    } keys %postponed_file;

    # If there are any, list them.
    if ( @@have and ( $break_wanted or $action_wanted ) ) {
        _cmd_L_handle_postponed_breakpoints($handle_db_line);
    } ## end if (@@have and ($break_wanted...

    if ( %break_on_load and $break_wanted ) {
        print {$OUT} "Breakpoints on load:\n";
        BREAK_ON_LOAD: for my $filename ( keys %break_on_load ) {
            print {$OUT} " $filename\n";
            last BREAK_ON_LOAD if $signal;
        }
    } ## end if (%break_on_load and...

    if ($watch_wanted and ( $trace & 2 )) {
        print {$OUT} "Watch-expressions:\n" if @@to_watch;
        TO_WATCH: for my $expr (@@to_watch) {
            print {$OUT} " $expr\n";
            last TO_WATCH if $signal;
        }
    }

    return;
} ## end sub cmd_L

=head3 C<cmd_M> - list modules (command)

Just call C<list_modules>.

=cut

sub cmd_M {
    list_modules();

    return;
}

=head3 C<cmd_o> - options (command)

If this is just C<o> by itself, we list the current settings via
C<dump_option>. If there's a nonblank value following it, we pass that on to
C<parse_options> for processing.

=cut

sub cmd_o {
    my $cmd = shift;
    my $opt = shift || '';    # opt[=val]

    # Nonblank. Try to parse and process.
    if ( $opt =~ /^(\S.*)/ ) {
        parse_options($1);
    }

    # Blank. List the current option settings.
    else {
        for (@@options) {
            dump_option($_);
        }
    }
} ## end sub cmd_o

=head3 C<cmd_O> - nonexistent in 5.8.x (command)

Advises the user that the O command has been renamed.

=cut

sub cmd_O {
    print $OUT "The old O command is now the o command.\n";             # hint
    print $OUT "Use 'h' to get current command help synopsis or\n";     #
    print $OUT "use 'o CommandSet=pre580' to revert to old usage\n";    #
}

=head3 C<cmd_v> - view window (command)

Uses the C<$preview> variable set in the second C<BEGIN> block (q.v.) to
move back a few lines to list the selected line in context. Uses C<cmd_l>
to do the actual listing after figuring out the range of line to request.

=cut

use vars qw($preview);

sub cmd_v {
    my $cmd  = shift;
    my $line = shift;

    # Extract the line to list around. (Astute readers will have noted that
    # this pattern will match whether or not a numeric line is specified,
    # which means that we'll always enter this loop (though a non-numeric
    # argument results in no action at all)).
    if ( $line =~ /^(\d*)$/ ) {

        # Total number of lines to list (a windowful).
        $incr = $window - 1;

        # Set the start to the argument given (if there was one).
        $start = $1 if $1;

        # Back up by the context amount.
        $start -= $preview;

        # Put together a linespec that cmd_l will like.
        $line = $start . '-' . ( $start + $incr );

        # List the lines.
        cmd_l( 'l', $line );
    } ## end if ($line =~ /^(\d*)$/)
} ## end sub cmd_v

=head3 C<cmd_w> - add a watch expression (command)

The 5.8 version of this command adds a watch expression if one is specified;
it does nothing if entered with no operands.

We extract the expression, save it, evaluate it in the user's context, and
save the value. We'll re-evaluate it each time the debugger passes a line,
and will stop (see the code at the top of the command loop) if the value
of any of the expressions changes.

=cut

sub _add_watch_expr {
    my $expr = shift;

    # ... save it.
    push @@to_watch, $expr;

    # Parameterize DB::eval and call it to get the expression's value
    # in the user's context. This version can handle expressions which
    # return a list value.
    $evalarg = $expr;
    # The &-call is here to ascertain the mutability of @@_.
    my ($val) = join( ' ', &DB::eval);
    $val = ( defined $val ) ? "'$val'" : 'undef';

    # Save the current value of the expression.
    push @@old_watch, $val;

    # We are now watching expressions.
    $trace |= 2;

    return;
}

sub cmd_w {
    my $cmd = shift;

    # Null expression if no arguments.
    my $expr = shift || '';

    # If expression is not null ...
    if ( $expr =~ /\A\S/ ) {
        _add_watch_expr($expr);
    } ## end if ($expr =~ /^(\S.*)/)

    # You have to give one to get one.
    else {
        print $OUT "Adding a watch-expression requires an expression\n";  # hint
    }

    return;
}

=head3 C<cmd_W> - delete watch expressions (command)

This command accepts either a watch expression to be removed from the list
of watch expressions, or C<*> to delete them all.

If C<*> is specified, we simply empty the watch expression list and the
watch expression value list. We also turn off the bit that says we've got
watch expressions.

If an expression (or partial expression) is specified, we pattern-match
through the expressions and remove the ones that match. We also discard
the corresponding values. If no watch expressions are left, we turn off
the I<watching expressions> bit.

=cut

sub cmd_W {
    my $cmd  = shift;
    my $expr = shift || '';

    # Delete them all.
    if ( $expr eq '*' ) {

        # Not watching now.
        $trace &= ~2;

        print $OUT "Deleting all watch expressions ...\n";

        # And all gone.
        @@to_watch = @@old_watch = ();
    }

    # Delete one of them.
    elsif ( $expr =~ /^(\S.*)/ ) {

        # Where we are in the list.
        my $i_cnt = 0;

        # For each expression ...
        foreach (@@to_watch) {
            my $val = $to_watch[$i_cnt];

            # Does this one match the command argument?
            if ( $val eq $expr ) {    # =~ m/^\Q$i$/) {
                                      # Yes. Turn it off, and its value too.
                splice( @@to_watch,  $i_cnt, 1 );
                splice( @@old_watch, $i_cnt, 1 );
            }
            $i_cnt++;
        } ## end foreach (@@to_watch)

        # We don't bother to turn watching off because
        #  a) we don't want to stop calling watchfunction() if it exists
        #  b) foreach over a null list doesn't do anything anyway

    } ## end elsif ($expr =~ /^(\S.*)/)

    # No command arguments entered.
    else {
        print $OUT
          "Deleting a watch-expression requires an expression, or '*' for all\n"
          ;    # hint
    }
} ## end sub cmd_W

### END of the API section

=head1 SUPPORT ROUTINES

These are general support routines that are used in a number of places
throughout the debugger.

=head2 save

save() saves the user's versions of globals that would mess us up in C<@@saved>,
and installs the versions we like better.

=cut

sub save {

    # Save eval failure, command failure, extended OS error, output field
    # separator, input record separator, output record separator and
    # the warning setting.
    @@saved = ( $@@, $!, $^E, $,, $/, $\, $^W );

    $,  = "";      # output field separator is null string
    $/  = "\n";    # input record separator is newline
    $\  = "";      # output record separator is null string
    $^W = 0;       # warnings are off
} ## end sub save

=head2 C<print_lineinfo> - show where we are now

print_lineinfo prints whatever it is that it is handed; it prints it to the
C<$LINEINFO> filehandle instead of just printing it to STDOUT. This allows
us to feed line information to a slave editor without messing up the
debugger output.

=cut

sub print_lineinfo {

    # Make the terminal sensible if we're not the primary debugger.
    resetterm(1) if $LINEINFO eq $OUT and $term_pid != $$;
    local $\ = '';
    local $, = '';
    # $LINEINFO may be undef if $noTTY is set or some other issue.
    if ($LINEINFO)
    {
        print {$LINEINFO} @@_;
    }
} ## end sub print_lineinfo

=head2 C<postponed_sub>

Handles setting postponed breakpoints in subroutines once they're compiled.
For breakpoints, we use C<DB::find_sub> to locate the source file and line
range for the subroutine, then mark the file as having a breakpoint,
temporarily switch the C<*dbline> glob over to the source file, and then
search the given range of lines to find a breakable line. If we find one,
we set the breakpoint on it, deleting the breakpoint from C<%postponed>.

=cut

# The following takes its argument via $evalarg to preserve current @@_

sub postponed_sub {

    # Get the subroutine name.
    my $subname = shift;

    # If this is a 'break +<n> if <condition>' ...
    if ( $postponed{$subname} =~ s/^break\s([+-]?\d+)\s+if\s// ) {

        # If there's no offset, use '+0'.
        my $offset = $1 || 0;

        # find_sub's value is 'fullpath-filename:start-stop'. It's
        # possible that the filename might have colons in it too.
        my ( $file, $i ) = ( find_sub($subname) =~ /^(.*):(\d+)-.*$/ );
        if ($i) {

            # We got the start line. Add the offset '+<n>' from
            # $postponed{subname}.
            $i += $offset;

            # Switch to the file this sub is in, temporarily.
            local *dbline = $main::{ '_<' . $file };

            # No warnings, please.
            local $^W = 0;    # != 0 is magical below

            # This file's got a breakpoint in it.
            $had_breakpoints{$file} |= 1;

            # Last line in file.
            $max = $#dbline;

            # Search forward until we hit a breakable line or get to
            # the end of the file.
            ++$i until $dbline[$i] != 0 or $i >= $max;

            # Copy the breakpoint in and delete it from %postponed.
            $dbline{$i} = delete $postponed{$subname};
        } ## end if ($i)

        # find_sub didn't find the sub.
        else {
            local $\ = '';
            print $OUT "Subroutine $subname not found.\n";
        }
        return;
    } ## end if ($postponed{$subname...
    elsif ( $postponed{$subname} eq 'compile' ) { $signal = 1 }

    #print $OUT "In postponed_sub for '$subname'.\n";
} ## end sub postponed_sub

=head2 C<postponed>

Called after each required file is compiled, but before it is executed;
also called if the name of a just-compiled subroutine is a key of
C<%postponed>. Propagates saved breakpoints (from C<b compile>, C<b load>,
etc.) into the just-compiled code.

If this is a C<require>'d file, the incoming parameter is the glob
C<*{"_<$filename"}>, with C<$filename> the name of the C<require>'d file.

If it's a subroutine, the incoming parameter is the subroutine name.

=cut

sub postponed {

    # If there's a break, process it.
    if ($ImmediateStop) {

        # Right, we've stopped. Turn it off.
        $ImmediateStop = 0;

        # Enter the command loop when DB::DB gets called.
        $signal = 1;
    }

    # If this is a subroutine, let postponed_sub() deal with it.
    if (ref(\$_[0]) ne 'GLOB') {
        return postponed_sub(@@_);
    }

    # Not a subroutine. Deal with the file.
    local *dbline = shift;
    my $filename = $dbline;
    $filename =~ s/^_<//;
    local $\ = '';
    $signal = 1, print $OUT "'$filename' loaded...\n"
      if $break_on_load{$filename};
    print_lineinfo( ' ' x $stack_depth, "Package $filename.\n" ) if $frame;

    # Do we have any breakpoints to put in this file?
    return unless $postponed_file{$filename};

    # Yes. Mark this file as having breakpoints.
    $had_breakpoints{$filename} |= 1;

    # "Cannot be done: insufficient magic" - we can't just put the
    # breakpoints saved in %postponed_file into %dbline by assigning
    # the whole hash; we have to do it one item at a time for the
    # breakpoints to be set properly.
    #%dbline = %{$postponed_file{$filename}};

    # Set the breakpoints, one at a time.
    my $key;

    for $key ( keys %{ $postponed_file{$filename} } ) {

        # Stash the saved breakpoint into the current file's magic line array.
        $dbline{$key} = ${ $postponed_file{$filename} }{$key};
    }

    # This file's been compiled; discard the stored breakpoints.
    delete $postponed_file{$filename};

} ## end sub postponed

=head2 C<dumpit>

C<dumpit> is the debugger's wrapper around dumpvar.pl.

It gets a filehandle (to which C<dumpvar.pl>'s output will be directed) and
a reference to a variable (the thing to be dumped) as its input.

The incoming filehandle is selected for output (C<dumpvar.pl> is printing to
the currently-selected filehandle, thank you very much). The current
values of the package globals C<$single> and C<$trace> are backed up in
lexicals, and they are turned off (this keeps the debugger from trying
to single-step through C<dumpvar.pl> (I think.)). C<$frame> is localized to
preserve its current value and it is set to zero to prevent entry/exit
messages from printing, and C<$doret> is localized as well and set to -2 to
prevent return values from being shown.

C<dumpit()> then checks to see if it needs to load C<dumpvar.pl> and
tries to load it (note: if you have a C<dumpvar.pl>  ahead of the
installed version in C<@@INC>, yours will be used instead. Possible security
problem?).

It then checks to see if the subroutine C<main::dumpValue> is now defined
it should have been defined by C<dumpvar.pl>). If it has, C<dumpit()>
localizes the globals necessary for things to be sane when C<main::dumpValue()>
is called, and picks up the variable to be dumped from the parameter list.

It checks the package global C<%options> to see if there's a C<dumpDepth>
specified. If not, -1 is assumed; if so, the supplied value gets passed on to
C<dumpvar.pl>. This tells C<dumpvar.pl> where to leave off when dumping a
structure: -1 means dump everything.

C<dumpValue()> is then called if possible; if not, C<dumpit()>just prints a
warning.

In either case, C<$single>, C<$trace>, C<$frame>, and C<$doret> are restored
and we then return to the caller.

=cut

sub dumpit {

    # Save the current output filehandle and switch to the one
    # passed in as the first parameter.
    my $savout = select(shift);

    # Save current settings of $single and $trace, and then turn them off.
    my $osingle = $single;
    my $otrace  = $trace;
    $single = $trace = 0;

    # XXX Okay, what do $frame and $doret do, again?
    local $frame = 0;
    local $doret = -2;

    # Load dumpvar.pl unless we've already got the sub we need from it.
    unless ( defined &main::dumpValue ) {
        do 'dumpvar.pl' or die $@@;
    }

    # If the load succeeded (or we already had dumpvalue()), go ahead
    # and dump things.
    if ( defined &main::dumpValue ) {
        local $\ = '';
        local $, = '';
        local $" = ' ';
        my $v = shift;
        my $maxdepth = shift || $option{dumpDepth};
        $maxdepth = -1 unless defined $maxdepth;    # -1 means infinite depth
        main::dumpValue( $v, $maxdepth );
    } ## end if (defined &main::dumpValue)

    # Oops, couldn't load dumpvar.pl.
    else {
        local $\ = '';
        print $OUT "dumpvar.pl not available.\n";
    }

    # Reset $single and $trace to their old values.
    $single = $osingle;
    $trace  = $otrace;

    # Restore the old filehandle.
    select($savout);
} ## end sub dumpit

=head2 C<print_trace>

C<print_trace>'s job is to print a stack trace. It does this via the
C<dump_trace> routine, which actually does all the ferreting-out of the
stack trace data. C<print_trace> takes care of formatting it nicely and
printing it to the proper filehandle.

Parameters:

=over 4

=item *

The filehandle to print to.

=item *

How many frames to skip before starting trace.

=item *

How many frames to print.

=item *

A flag: if true, print a I<short> trace without filenames, line numbers, or arguments

=back

The original comment below seems to be noting that the traceback may not be
correct if this routine is called in a tied method.

=cut

# Tied method do not create a context, so may get wrong message:

sub print_trace {
    local $\ = '';
    my $fh = shift;

    # If this is going to a slave editor, but we're not the primary
    # debugger, reset it first.
    resetterm(1)
      if $fh        eq $LINEINFO    # slave editor
      and $LINEINFO eq $OUT         # normal output
      and $term_pid != $$;          # not the primary

    # Collect the actual trace information to be formatted.
    # This is an array of hashes of subroutine call info.
    my @@sub = dump_trace( $_[0] + 1, $_[1] );

    # Grab the "short report" flag from @@_.
    my $short = $_[2];              # Print short report, next one for sub name

    # Run through the traceback info, format it, and print it.
    my $s;
    for my $i (0 .. $#sub) {

        # Drop out if the user has lost interest and hit control-C.
        last if $signal;

        # Set the separator so arrays print nice.
        local $" = ', ';

        # Grab and stringify the arguments if they are there.
        my $args =
          defined $sub[$i]{args}
          ? "(@@{ $sub[$i]{args} })"
          : '';

        # Shorten them up if $maxtrace says they're too long.
        $args = ( substr $args, 0, $maxtrace - 3 ) . '...'
          if length $args > $maxtrace;

        # Get the file name.
        my $file = $sub[$i]{file};

        # Put in a filename header if short is off.
        $file = $file eq '-e' ? $file : "file '$file'" unless $short;

        # Get the actual sub's name, and shorten to $maxtrace's requirement.
        $s = $sub[$i]{'sub'};
        $s = ( substr $s, 0, $maxtrace - 3 ) . '...' if length $s > $maxtrace;

        # Short report uses trimmed file and sub names.
        if ($short) {
            my $sub = @@_ >= 4 ? $_[3] : $s;
            print $fh "$sub[$i]{context}=$sub$args from $file:$sub[$i]{line}\n";
        } ## end if ($short)

        # Non-short report includes full names.
        else {
            print $fh "$sub[$i]{context} = $s$args"
              . " called from $file"
              . " line $sub[$i]{line}\n";
        }
    } ## end for my $i (0 .. $#sub)
} ## end sub print_trace

=head2 dump_trace(skip[,count])

Actually collect the traceback information available via C<caller()>. It does
some filtering and cleanup of the data, but mostly it just collects it to
make C<print_trace()>'s job easier.

C<skip> defines the number of stack frames to be skipped, working backwards
from the most current. C<count> determines the total number of frames to
be returned; all of them (well, the first 10^9) are returned if C<count>
is omitted.

This routine returns a list of hashes, from most-recent to least-recent
stack frame. Each has the following keys and values:

=over 4

=item * C<context> - C<.> (null), C<$> (scalar), or C<@@> (array)

=item * C<sub> - subroutine name, or C<eval> information

=item * C<args> - undef, or a reference to an array of arguments

=item * C<file> - the file in which this item was defined (if any)

=item * C<line> - the line on which it was defined

=back

=cut

sub _dump_trace_calc_saved_single_arg
{
    my ($nothard, $arg) = @@_;

    my $type;
    if ( not defined $arg ) {    # undefined parameter
        return "undef";
    }

    elsif ( $nothard and tied $arg ) {    # tied parameter
        return "tied";
    }
    elsif ( $nothard and $type = ref $arg ) {    # reference
        return "ref($type)";
    }
    else {                                       # can be stringified
        local $_ =
        "$arg";    # Safe to stringify now - should not call f().

        # Backslash any single-quotes or backslashes.
        s/([\'\\])/\\$1/g;

        # Single-quote it unless it's a number or a colon-separated
        # name.
        s/(.*)/'$1'/s
        unless /^(?: -?[\d.]+ | \*[\w:]* )$/x;

        # Turn high-bit characters into meta-whatever, and controls into like
        # '^D'.
        require 'meta_notation.pm';
        $_ = _meta_notation($_) if /[[:^print:]]/a;

        return $_;
    }
}

sub _dump_trace_calc_save_args {
    my ($nothard) = @@_;

    return [
        map { _dump_trace_calc_saved_single_arg($nothard, $_) } @@args
    ];
}

sub dump_trace {

    # How many levels to skip.
    my $skip = shift;

    # How many levels to show. (1e9 is a cheap way of saying "all of them";
    # it's unlikely that we'll have more than a billion stack frames. If you
    # do, you've got an awfully big machine...)
    my $count = shift || 1e9;

    # We increment skip because caller(1) is the first level *back* from
    # the current one.  Add $skip to the count of frames so we have a
    # simple stop criterion, counting from $skip to $count+$skip.
    $skip++;
    $count += $skip;

    # These variables are used to capture output from caller();
    my ( $p, $file, $line, $sub, $h, $context );

    my ( $e, $r, @@sub, $args );

    # XXX Okay... why'd we do that?
    my $nothard = not $frame & 8;
    local $frame = 0;

    # Do not want to trace this.
    my $otrace = $trace;
    $trace = 0;

    # Start out at the skip count.
    # If we haven't reached the number of frames requested, and caller() is
    # still returning something, stay in the loop. (If we pass the requested
    # number of stack frames, or we run out - caller() returns nothing - we
    # quit.
    # Up the stack frame index to go back one more level each time.
    for (
        my $i = $skip ;
        $i < $count
        and ( $p, $file, $line, $sub, $h, $context, $e, $r ) = caller($i) ;
        $i++
    )
    {

        # Go through the arguments and save them for later.
        my $save_args = _dump_trace_calc_save_args($nothard);

        # If context is true, this is array (@@)context.
        # If context is false, this is scalar ($) context.
        # If neither, context isn't defined. (This is apparently a 'can't
        # happen' trap.)
        $context = $context ? '@@' : ( defined $context ? "\$" : '.' );

        # if the sub has args ($h true), make an anonymous array of the
        # dumped args.
        $args = $h ? $save_args : undef;

        # remove trailing newline-whitespace-semicolon-end of line sequence
        # from the eval text, if any.
        $e =~ s/\n\s*\;\s*\Z// if $e;

        # Escape backslashed single-quotes again if necessary.
        $e =~ s/([\\\'])/\\$1/g if $e;

        # if the require flag is true, the eval text is from a require.
        if ($r) {
            $sub = "require '$e'";
        }

        # if it's false, the eval text is really from an eval.
        elsif ( defined $r ) {
            $sub = "eval '$e'";
        }

        # If the sub is '(eval)', this is a block eval, meaning we don't
        # know what the eval'ed text actually was.
        elsif ( $sub eq '(eval)' ) {
            $sub = "eval {...}";
        }

        # Stick the collected information into @@sub as an anonymous hash.
        push(
            @@sub,
            {
                context => $context,
                sub     => $sub,
                args    => $args,
                file    => $file,
                line    => $line
            }
        );

        # Stop processing frames if the user hit control-C.
        last if $signal;
    } ## end for ($i = $skip ; $i < ...

    # Restore the trace value again.
    $trace = $otrace;
    @@sub;
} ## end sub dump_trace

=head2 C<action()>

C<action()> takes input provided as the argument to an add-action command,
either pre- or post-, and makes sure it's a complete command. It doesn't do
any fancy parsing; it just keeps reading input until it gets a string
without a trailing backslash.

=cut

sub action {
    my $action = shift;

    while ( $action =~ s/\\$// ) {

        # We have a backslash on the end. Read more.
        $action .= gets();
    } ## end while ($action =~ s/\\$//)

    # Return the assembled action.
    $action;
} ## end sub action

=head2 unbalanced

This routine mostly just packages up a regular expression to be used
to check that the thing it's being matched against has properly-matched
curly braces.

Of note is the definition of the C<$balanced_brace_re> global via C<||=>, which
speeds things up by only creating the qr//'ed expression once; if it's
already defined, we don't try to define it again. A speed hack.

=cut

use vars qw($balanced_brace_re);

sub unbalanced {

    # I hate using globals!
    $balanced_brace_re ||= qr{
        ^ \{
             (?:
                 (?> [^{}] + )              # Non-parens without backtracking
                |
                 (??{ $balanced_brace_re }) # Group with matching parens
              ) *
          \} $
   }x;
    return $_[0] !~ m/$balanced_brace_re/;
} ## end sub unbalanced

=head2 C<gets()>

C<gets()> is a primitive (very primitive) routine to read continuations.
It was devised for reading continuations for actions.
it just reads more input with C<readline()> and returns it.

=cut

sub gets {
    return DB::readline("cont: ");
}

=head2 C<_db_system()> - handle calls to<system()> without messing up the debugger

The C<system()> function assumes that it can just go ahead and use STDIN and
STDOUT, but under the debugger, we want it to use the debugger's input and
outout filehandles.

C<_db_system()> socks away the program's STDIN and STDOUT, and then substitutes
the debugger's IN and OUT filehandles for them. It does the C<system()> call,
and then puts everything back again.

=cut

sub _db_system {

    # We save, change, then restore STDIN and STDOUT to avoid fork() since
    # some non-Unix systems can do system() but have problems with fork().
    open( SAVEIN,  "<&STDIN" )  || _db_warn("Can't save STDIN");
    open( SAVEOUT, ">&STDOUT" ) || _db_warn("Can't save STDOUT");
    open( STDIN,   "<&IN" )     || _db_warn("Can't redirect STDIN");
    open( STDOUT,  ">&OUT" )    || _db_warn("Can't redirect STDOUT");

    # XXX: using csh or tcsh destroys sigint retvals!
    system(@@_);
    open( STDIN,  "<&SAVEIN" )  || _db_warn("Can't restore STDIN");
    open( STDOUT, ">&SAVEOUT" ) || _db_warn("Can't restore STDOUT");
    close(SAVEIN);
    close(SAVEOUT);

    # most of the $? crud was coping with broken cshisms
    if ( $? >> 8 ) {
        _db_warn( "(Command exited ", ( $? >> 8 ), ")\n" );
    }
    elsif ($?) {
        _db_warn(
            "(Command died of SIG#",
            ( $? & 127 ),
            ( ( $? & 128 ) ? " -- core dumped" : "" ),
            ")", "\n"
        );
    } ## end elsif ($?)

    return $?;

} ## end sub system

*system = \&_db_system;

=head1 TTY MANAGEMENT

The subs here do some of the terminal management for multiple debuggers.

=head2 setterm

Top-level function called when we want to set up a new terminal for use
by the debugger.

If the C<noTTY> debugger option was set, we'll either use the terminal
supplied (the value of the C<noTTY> option), or we'll use C<Term::Rendezvous>
to find one. If we're a forked debugger, we call C<resetterm> to try to
get a whole new terminal if we can.

In either case, we set up the terminal next. If the C<ReadLine> option was
true, we'll get a C<Term::ReadLine> object for the current terminal and save
the appropriate attributes. We then

=cut

use vars qw($ornaments);
use vars qw($rl_attribs);

sub setterm {

    # Load Term::Readline, but quietly; don't debug it and don't trace it.
    local $frame = 0;
    local $doret = -2;
    require Term::ReadLine;

    # If noTTY is set, but we have a TTY name, go ahead and hook up to it.
    if ($notty) {
        if ($tty) {
            my ( $i, $o ) = split $tty, /,/;
            $o = $i unless defined $o;
            open( IN,  "<$i" ) or die "Cannot open TTY '$i' for read: $!";
            open( OUT, ">$o" ) or die "Cannot open TTY '$o' for write: $!";
            $IN  = \*IN;
            $OUT = \*OUT;
            _autoflush($OUT);
        } ## end if ($tty)

        # We don't have a TTY - try to find one via Term::Rendezvous.
        else {
            require Term::Rendezvous;

            # See if we have anything to pass to Term::Rendezvous.
            # Use $HOME/.perldbtty$$ if not.
            my $rv = $ENV{PERLDB_NOTTY} || "$ENV{HOME}/.perldbtty$$";

            # Rendezvous and get the filehandles.
            my $term_rv = Term::Rendezvous->new( $rv );
            $IN  = $term_rv->IN;
            $OUT = $term_rv->OUT;
        } ## end else [ if ($tty)
    } ## end if ($notty)

    # We're a daughter debugger. Try to fork off another TTY.
    if ( $term_pid eq '-1' ) {    # In a TTY with another debugger
        resetterm(2);
    }

    # If we shouldn't use Term::ReadLine, don't.
    if ( !$rl ) {
        $term = Term::ReadLine::Stub->new( 'perldb', $IN, $OUT );
    }

    # We're using Term::ReadLine. Get all the attributes for this terminal.
    else {
        $term = Term::ReadLine->new( 'perldb', $IN, $OUT );

        $rl_attribs = $term->Attribs;
        $rl_attribs->{basic_word_break_characters} .= '-:+/*,[])}'
          if defined $rl_attribs->{basic_word_break_characters}
          and index( $rl_attribs->{basic_word_break_characters}, ":" ) == -1;
        $rl_attribs->{special_prefixes} = '$@@&%';
        $rl_attribs->{completer_word_break_characters} .= '$@@&%';
        $rl_attribs->{completion_function} = \&db_complete;
    } ## end else [ if (!$rl)

    # Set up the LINEINFO filehandle.
    $LINEINFO = $OUT     unless defined $LINEINFO;
    $lineinfo = $console unless defined $lineinfo;

    $term->MinLine(2);

    load_hist();

    if ( $term->Features->{setHistory} and "@@hist" ne "?" ) {
        $term->SetHistory(@@hist);
    }

    # XXX Ornaments are turned on unconditionally, which is not
    # always a good thing.
    ornaments($ornaments) if defined $ornaments;
    $term_pid = $$;
} ## end sub setterm

sub load_hist {
    $histfile //= option_val("HistFile", undef);
    return unless defined $histfile;
    open my $fh, "<", $histfile or return;
    local $/ = "\n";
    @@hist = ();
    while (<$fh>) {
        chomp;
        push @@hist, $_;
    }
    close $fh;
}

sub save_hist {
    return unless defined $histfile;
    eval { require File::Path } or return;
    eval { require File::Basename } or return;
    File::Path::mkpath(File::Basename::dirname($histfile));
    open my $fh, ">", $histfile or die "Could not open '$histfile': $!";
    $histsize //= option_val("HistSize",100);
    my @@copy = grep { $_ ne '?' } @@hist;
    my $start = scalar(@@copy) > $histsize ? scalar(@@copy)-$histsize : 0;
    for ($start .. $#copy) {
        print $fh "$copy[$_]\n";
    }
    close $fh or die "Could not write '$histfile': $!";
}

=head1 GET_FORK_TTY EXAMPLE FUNCTIONS

When the process being debugged forks, or the process invokes a command
via C<system()> which starts a new debugger, we need to be able to get a new
C<IN> and C<OUT> filehandle for the new debugger. Otherwise, the two processes
fight over the terminal, and you can never quite be sure who's going to get the
input you're typing.

C<get_fork_TTY> is a glob-aliased function which calls the real function that
is tasked with doing all the necessary operating system mojo to get a new
TTY (and probably another window) and to direct the new debugger to read and
write there.

The debugger provides C<get_fork_TTY> functions which work for TCP
socket servers, X11, OS/2, and Mac OS X. Other systems are not
supported. You are encouraged to write C<get_fork_TTY> functions which
work for I<your> platform and contribute them.

=head3 C<socket_get_fork_TTY>

=cut

sub connect_remoteport {
    require IO::Socket;

    my $socket = IO::Socket::INET->new(
        Timeout  => '10',
        PeerAddr => $remoteport,
        Proto    => 'tcp',
    );
    if ( ! $socket ) {
        die "Unable to connect to remote host: $remoteport\n";
    }
    return $socket;
}

sub socket_get_fork_TTY {
    $tty = $LINEINFO = $IN = $OUT = connect_remoteport();

    # Do I need to worry about setting $term?

    reset_IN_OUT( $IN, $OUT );
    return '';
}

=head3 C<xterm_get_fork_TTY>

This function provides the C<get_fork_TTY> function for X11. If a
program running under the debugger forks, a new <xterm> window is opened and
the subsidiary debugger is directed there.

The C<open()> call is of particular note here. We have the new C<xterm>
we're spawning route file number 3 to STDOUT, and then execute the C<tty>
command (which prints the device name of the TTY we'll want to use for input
and output to STDOUT, then C<sleep> for a very long time, routing this output
to file number 3. This way we can simply read from the <XT> filehandle (which
is STDOUT from the I<commands> we ran) to get the TTY we want to use.

Only works if C<xterm> is in your path and C<$ENV{DISPLAY}>, etc. are
properly set up.

=cut

sub xterm_get_fork_TTY {
    ( my $name = $0 ) =~ s,^.*[/\\],,s;
    open XT,
qq[3>&1 xterm -title "Daughter Perl debugger $pids $name" -e sh -c 'tty 1>&3;\
 sleep 10000000' |];

    # Get the output from 'tty' and clean it up a little.
    my $tty = <XT>;
    chomp $tty;

    $pidprompt = '';    # Shown anyway in titlebar

    # We need $term defined or we can not switch to the newly created xterm
    if ($tty ne '' && !defined $term) {
        require Term::ReadLine;
        if ( !$rl ) {
            $term = Term::ReadLine::Stub->new( 'perldb', $IN, $OUT );
        }
        else {
            $term = Term::ReadLine->new( 'perldb', $IN, $OUT );
        }
    }
    # There's our new TTY.
    return $tty;
} ## end sub xterm_get_fork_TTY

=head3 C<os2_get_fork_TTY>

XXX It behooves an OS/2 expert to write the necessary documentation for this!

=cut

# This example function resets $IN, $OUT itself
my $c_pipe = 0;
sub os2_get_fork_TTY { # A simplification of the following (and works without):
    local $\  = '';
    ( my $name = $0 ) =~ s,^.*[/\\],,s;
    my %opt = ( title => "Daughter Perl debugger $pids $name",
        ($rl ? (read_by_key => 1) : ()) );
    require OS2::Process;
    my ($in, $out, $pid) = eval { OS2::Process::io_term(related => 0, %opt) }
      or return;
    $pidprompt = '';    # Shown anyway in titlebar
    reset_IN_OUT($in, $out);
    $tty = '*reset*';
    return '';          # Indicate that reset_IN_OUT is called
} ## end sub os2_get_fork_TTY

=head3 C<macosx_get_fork_TTY>

The Mac OS X version uses AppleScript to tell Terminal.app to create
a new window.

=cut

# Notes about Terminal.app's AppleScript support,
# (aka things that might break in future OS versions).
#
# The "do script" command doesn't return a reference to the new window
# it creates, but since it appears frontmost and windows are enumerated
# front to back, we can use "first window" === "window 1".
#
# Since "do script" is implemented by supplying the argument (plus a
# return character) as terminal input, there's a potential race condition
# where the debugger could beat the shell to reading the command.
# To prevent this, we wait for the screen to clear before proceeding.
#
# 10.3 and 10.4:
# There's no direct accessor for the tty device name, so we fiddle
# with the window title options until it says what we want.
#
# 10.5:
# There _is_ a direct accessor for the tty device name, _and_ there's
# a new possible component of the window title (the name of the settings
# set).  A separate version is needed.

my @@script_versions=

    ([237, <<'__LEOPARD__'],
tell application "Terminal"
    do script "clear;exec sleep 100000"
    tell first tab of first window
        copy tty to thetty
        set custom title to "forked perl debugger"
        set title displays custom title to true
        repeat while (length of first paragraph of (get contents)) > 0
            delay 0.1
        end repeat
    end tell
end tell
thetty
__LEOPARD__

     [100, <<'__JAGUAR_TIGER__'],
tell application "Terminal"
    do script "clear;exec sleep 100000"
    tell first window
        set title displays shell path to false
        set title displays window size to false
        set title displays file name to false
        set title displays device name to true
        set title displays custom title to true
        set custom title to ""
        copy "/dev/" & name to thetty
        set custom title to "forked perl debugger"
        repeat while (length of first paragraph of (get contents)) > 0
            delay 0.1
        end repeat
    end tell
end tell
thetty
__JAGUAR_TIGER__

);

sub macosx_get_fork_TTY
{
    my($version,$script,$pipe,$tty);

    return unless $version=$ENV{TERM_PROGRAM_VERSION};
    foreach my $entry (@@script_versions) {
        if ($version>=$entry->[0]) {
            $script=$entry->[1];
            last;
        }
    }
    return unless defined($script);
    return unless open($pipe,'-|','/usr/bin/osascript','-e',$script);
    $tty=readline($pipe);
    close($pipe);
    return unless defined($tty) && $tty =~ m(^/dev/);
    chomp $tty;
    return $tty;
}

=head3 C<tmux_get_fork_TTY>

Creates a split window for subprocesses when a process running under the
perl debugger in Tmux forks.

=cut

sub tmux_get_fork_TTY {
    return unless $ENV{TMUX};

    my $pipe;

    my $status = open $pipe, '-|', 'tmux', 'split-window',
        '-P', '-F', '#{pane_tty}', 'sleep 100000';

    if ( !$status ) {
        return;
    }

    my $tty = <$pipe>;
    close $pipe;

    if ( $tty ) {
        chomp $tty;

        if ( !defined $term ) {
            require Term::ReadLine;
            if ( !$rl ) {
                $term = Term::ReadLine::Stub->new( 'perldb', $IN, $OUT );
            }
            else {
                $term = Term::ReadLine->new( 'perldb', $IN, $OUT );
            }
        }
    }

    return $tty;
}

=head2 C<create_IN_OUT($flags)>

Create a new pair of filehandles, pointing to a new TTY. If impossible,
try to diagnose why.

Flags are:

=over 4

=item * 1 - Don't know how to create a new TTY.

=item * 2 - Debugger has forked, but we can't get a new TTY.

=item * 4 - standard debugger startup is happening.

=back

=cut

use vars qw($fork_TTY);

sub create_IN_OUT {    # Create a window with IN/OUT handles redirected there

    # If we know how to get a new TTY, do it! $in will have
    # the TTY name if get_fork_TTY works.
    my $in = get_fork_TTY(@@_) if defined &get_fork_TTY;

    # It used to be that
    $in = $fork_TTY if defined $fork_TTY;    # Backward compatibility

    if ( not defined $in ) {
        my $why = shift;

        # We don't know how.
        print_help(<<EOP) if $why == 1;
I<#########> Forked, but do not know how to create a new B<TTY>. I<#########>
EOP

        # Forked debugger.
        print_help(<<EOP) if $why == 2;
I<#########> Daughter session, do not know how to change a B<TTY>. I<#########>
  This may be an asynchronous session, so the parent debugger may be active.
EOP

        # Note that both debuggers are fighting over the same input.
        print_help(<<EOP) if $why != 4;
  Since two debuggers fight for the same TTY, input is severely entangled.

EOP
        print_help(<<EOP);
  I know how to switch the output to a different window in xterms, OS/2
  consoles, and Mac OS X Terminal.app only.  For a manual switch, put the name
  of the created I<TTY> in B<\$DB::fork_TTY>, or define a function
  B<DB::get_fork_TTY()> returning this.

  On I<UNIX>-like systems one can get the name of a I<TTY> for the given window
  by typing B<tty>, and disconnect the I<shell> from I<TTY> by B<sleep 1000000>.

EOP
    } ## end if (not defined $in)
    elsif ( $in ne '' ) {
        TTY($in);
    }
    else {
        $console = '';    # Indicate no need to open-from-the-console
    }
    undef $fork_TTY;
} ## end sub create_IN_OUT

=head2 C<resetterm>

Handles rejiggering the prompt when we've forked off a new debugger.

If the new debugger happened because of a C<system()> that invoked a
program under the debugger, the arrow between the old pid and the new
in the prompt has I<two> dashes instead of one.

We take the current list of pids and add this one to the end. If there
isn't any list yet, we make one up out of the initial pid associated with
the terminal and our new pid, sticking an arrow (either one-dashed or
two dashed) in between them.

If C<CreateTTY> is off, or C<resetterm> was called with no arguments,
we don't try to create a new IN and OUT filehandle. Otherwise, we go ahead
and try to do that.

=cut

sub resetterm {    # We forked, so we need a different TTY

    # Needs to be passed to create_IN_OUT() as well.
    my $in = shift;

    # resetterm(2): got in here because of a system() starting a debugger.
    # resetterm(1): just forked.
    my $systemed = $in > 1 ? '-' : '';

    # If there's already a list of pids, add this to the end.
    if ($pids) {
        $pids =~ s/\]/$systemed->$$]/;
    }

    # No pid list. Time to make one.
    else {
        $pids = "[$term_pid->$$]";
    }

    # The prompt we're going to be using for this debugger.
    $pidprompt = $pids;

    # We now 0wnz this terminal.
    $term_pid = $$;

    # Just return if we're not supposed to try to create a new TTY.
    return unless $CreateTTY & $in;

    # Try to create a new IN/OUT pair.
    create_IN_OUT($in);
} ## end sub resetterm

=head2 C<readline>

First, we handle stuff in the typeahead buffer. If there is any, we shift off
the next line, print a message saying we got it, add it to the terminal
history (if possible), and return it.

If there's nothing in the typeahead buffer, check the command filehandle stack.
If there are any filehandles there, read from the last one, and return the line
if we got one. If not, we pop the filehandle off and close it, and try the
next one up the stack.

If we've emptied the filehandle stack, we check to see if we've got a socket
open, and we read that and return it if we do. If we don't, we just call the
core C<readline()> and return its value.

=cut

sub readline {

    # Localize to prevent it from being smashed in the program being debugged.
    local $.;

    # If there are stacked filehandles to read from ...
    # (Handle it before the typeahead, because we may call source/etc. from
    # the typeahead.)
    while (@@cmdfhs) {

        # Read from the last one in the stack.
        my $line = CORE::readline( $cmdfhs[-1] );

        # If we got a line ...
        defined $line
          ? ( print $OUT ">> $line" and return $line )    # Echo and return
          : close pop @@cmdfhs;                            # Pop and close
    } ## end while (@@cmdfhs)

    # Pull a line out of the typeahead if there's stuff there.
    if (@@typeahead) {

        # How many lines left.
        my $left = @@typeahead;

        # Get the next line.
        my $got = shift @@typeahead;

        # Print a message saying we got input from the typeahead.
        local $\ = '';
        print $OUT "auto(-$left)", shift, $got, "\n";

        # Add it to the terminal history (if possible).
        $term->AddHistory($got)
          if length($got) > 1
          and defined $term->Features->{addHistory};
        return $got;
    } ## end if (@@typeahead)

    # We really need to read some input. Turn off entry/exit trace and
    # return value printing.
    local $frame = 0;
    local $doret = -2;

    # Nothing on the filehandle stack. Socket?
    if ( ref $OUT and UNIVERSAL::isa( $OUT, 'IO::Socket::INET' ) ) {

        # Send anything we have to send.
        $OUT->write( join( '', @@_ ) );

        # Receive anything there is to receive.
        my $stuff = '';
        my $buf;
        my $first_time = 1;

        while ($first_time or (length($buf) && ($stuff .= $buf) !~ /\n/))
        {
            $first_time = 0;
            $IN->recv( $buf = '', 2048 );   # XXX "what's wrong with sysread?"
                                            # XXX Don't know. You tell me.
        }

        # What we got.
        return $stuff;
    } ## end if (ref $OUT and UNIVERSAL::isa...

    # No socket. Just read from the terminal.
    else {
        return $term->readline(@@_);
    }
} ## end sub readline

=head1 OPTIONS SUPPORT ROUTINES

These routines handle listing and setting option values.

=head2 C<dump_option> - list the current value of an option setting

This routine uses C<option_val> to look up the value for an option.
It cleans up escaped single-quotes and then displays the option and
its value.

=cut

sub dump_option {
    my ( $opt, $val ) = @@_;
    $val = option_val( $opt, 'N/A' );
    $val =~ s/([\\\'])/\\$1/g;
    printf $OUT "%20s = '%s'\n", $opt, $val;
} ## end sub dump_option

sub options2remember {
    foreach my $k (@@RememberOnROptions) {
        $option{$k} = option_val( $k, 'N/A' );
    }
    return %option;
}

=head2 C<option_val> - find the current value of an option

This can't just be a simple hash lookup because of the indirect way that
the option values are stored. Some are retrieved by calling a subroutine,
some are just variables.

You must supply a default value to be used in case the option isn't set.

=cut

sub option_val {
    my ( $opt, $default ) = @@_;
    my $val;

    # Does this option exist, and is it a variable?
    # If so, retrieve the value via the value in %optionVars.
    if (    defined $optionVars{$opt}
        and defined ${ $optionVars{$opt} } )
    {
        $val = ${ $optionVars{$opt} };
    }

    # Does this option exist, and it's a subroutine?
    # If so, call the subroutine via the ref in %optionAction
    # and capture the value.
    elsif ( defined $optionAction{$opt}
        and defined &{ $optionAction{$opt} } )
    {
        $val = &{ $optionAction{$opt} }();
    }

    # If there's an action or variable for the supplied option,
    # but no value was set, use the default.
    elsif (defined $optionAction{$opt} and not defined $option{$opt}
        or defined $optionVars{$opt} and not defined ${ $optionVars{$opt} } )
    {
        $val = $default;
    }

    # Otherwise, do the simple hash lookup.
    else {
        $val = $option{$opt};
    }

    # If the value isn't defined, use the default.
    # Then return whatever the value is.
    $val = $default unless defined $val;
    $val;
} ## end sub option_val

=head2 C<parse_options>

Handles the parsing and execution of option setting/displaying commands.

An option entered by itself is assumed to be I<set me to 1> (the default value)
if the option is a boolean one. If not, the user is prompted to enter a valid
value or to query the current value (via C<option? >).

If C<option=value> is entered, we try to extract a quoted string from the
value (if it is quoted). If it's not, we just use the whole value as-is.

We load any modules required to service this option, and then we set it: if
it just gets stuck in a variable, we do that; if there's a subroutine to
handle setting the option, we call that.

Finally, if we're running in interactive mode, we display the effect of the
user's command back to the terminal, skipping this if we're setting things
during initialization.

=cut

sub parse_options {
    my ($s) = @@_;
    local $\ = '';

    my $option;

    # These options need a value. Don't allow them to be clobbered by accident.
    my %opt_needs_val = map { ( $_ => 1 ) } qw{
      dumpDepth arrayDepth hashDepth LineInfo maxTraceLen ornaments windowSize
      pager quote ReadLine recallCommand RemotePort ShellBang TTY CommandSet
    };

    while (length($s)) {
        my $val_defaulted;

        # Clean off excess leading whitespace.
        $s =~ s/^\s+// && next;

        # Options are always all word characters, followed by a non-word
        # separator.
        if ($s !~ s/^(\w+)(\W?)//) {
            print {$OUT} "Invalid option '$s'\n";
            last;
        }
        my ( $opt, $sep ) = ( $1, $2 );

        # Make sure that such an option exists.
        my $matches = ( grep { /^\Q$opt/ && ( $option = $_ ) } @@options )
          || ( grep { /^\Q$opt/i && ( $option = $_ ) } @@options );

        unless ($matches) {
            print {$OUT} "Unknown option '$opt'\n";
            next;
        }
        if ($matches > 1) {
            print {$OUT} "Ambiguous option '$opt'\n";
            next;
        }
        my $val;

        # '?' as separator means query, but must have whitespace after it.
        if ( "?" eq $sep ) {
            if ($s =~ /\A\S/) {
                print {$OUT} "Option query '$opt?' followed by non-space '$s'\n" ;

                last;
            }

            #&dump_option($opt);
        } ## end if ("?" eq $sep)

        # Separator is whitespace (or just a carriage return).
        # They're going for a default, which we assume is 1.
        elsif ( $sep !~ /\S/ ) {
            $val_defaulted = 1;
            $val           = "1";   #  this is an evil default; make 'em set it!
        }

        # Separator is =. Trying to set a value.
        elsif ( $sep eq "=" ) {

            # If quoted, extract a quoted string.
            if ($s =~ s/ (["']) ( (?: \\. | (?! \1 ) [^\\] )* ) \1 //x) {
                my $quote = $1;
                ( $val = $2 ) =~ s/\\([$quote\\])/$1/g;
            }

            # Not quoted. Use the whole thing. Warn about 'option='.
            else {
                $s =~ s/^(\S*)//;
                $val = $1;
                print OUT qq(Option better cleared using $opt=""\n)
                  unless length $val;
            } ## end else [ if (s/ (["']) ( (?: \\. | (?! \1 ) [^\\] )* ) \1 //x)

        } ## end elsif ($sep eq "=")

        # "Quoted" with [], <>, or {}.
        else {    #{ to "let some poor schmuck bounce on the % key in B<vi>."
            my ($end) =
              "\\" . substr( ")]>}$sep", index( "([<{", $sep ), 1 );    #}
            $s =~ s/^(([^\\$end]|\\[\\$end])*)$end($|\s+)//
              or print( $OUT "Unclosed option value '$opt$sep$_'\n" ), last;
            ( $val = $1 ) =~ s/\\([\\$end])/$1/g;
        } ## end else [ if ("?" eq $sep)

        # Exclude non-booleans from getting set to 1 by default.
        if ( $opt_needs_val{$option} && $val_defaulted ) {
            my $cmd = ( $CommandSet eq '580' ) ? 'o' : 'O';
            print {$OUT}
"Option '$opt' is non-boolean.  Use '$cmd $option=VAL' to set, '$cmd $option?' to query\n";
            next;
        } ## end if ($opt_needs_val{$option...

        # Save the option value.
        $option{$option} = $val if defined $val;

        # Load any module that this option requires.
        if ( defined($optionRequire{$option}) && defined($val) ) {
            eval qq{
            local \$frame = 0;
            local \$doret = -2;
            require '$optionRequire{$option}';
            1;
            } || die $@@   # XXX: shouldn't happen
        }

        # Set it.
        # Stick it in the proper variable if it goes in a variable.
        if (defined($optionVars{$option}) && defined($val)) {
            ${ $optionVars{$option} } = $val;
        }

        # Call the appropriate sub if it gets set via sub.
        if (defined($optionAction{$option})
          && defined (&{ $optionAction{$option} })
          && defined ($val))
        {
          &{ $optionAction{$option} }($val);
        }

        # Not initialization - echo the value we set it to.
        dump_option($option) if ($OUT ne \*STDERR);
    } ## end while (length)
} ## end sub parse_options

=head1 RESTART SUPPORT

These routines are used to store (and restore) lists of items in environment
variables during a restart.

=head2 set_list

Set_list packages up items to be stored in a set of environment variables
(VAR_n, containing the number of items, and VAR_0, VAR_1, etc., containing
the values). Values outside the standard ASCII charset are stored by encoding
them as hexadecimal values.

=cut

sub set_list {
    my ( $stem, @@list ) = @@_;
    my $val;

    # VAR_n: how many we have. Scalar assignment gets the number of items.
    $ENV{"${stem}_n"} = @@list;

    # Grab each item in the list, escape the backslashes, encode the non-ASCII
    # as hex, and then save in the appropriate VAR_0, VAR_1, etc.
    for my $i ( 0 .. $#list ) {
        $val = $list[$i];
        $val =~ s/\\/\\\\/g;
        no warnings 'experimental::regex_sets';
        $val =~ s/ ( (?[ [\000-\xFF] & [:^print:] ]) ) /
                                                "\\0x" . unpack('H2',$1)/xaeg;
        $ENV{"${stem}_$i"} = $val;
    } ## end for $i (0 .. $#list)
} ## end sub set_list

=head2 get_list

Reverse the set_list operation: grab VAR_n to see how many we should be getting
back, and then pull VAR_0, VAR_1. etc. back out.

=cut

sub get_list {
    my $stem = shift;
    my @@list;
    my $n = delete $ENV{"${stem}_n"};
    my $val;
    for my $i ( 0 .. $n - 1 ) {
        $val = delete $ENV{"${stem}_$i"};
        $val =~ s/\\((\\)|0x(..))/ $2 ? $2 : pack('H2', $3) /ge;
        push @@list, $val;
    }
    @@list;
} ## end sub get_list

=head1 MISCELLANEOUS SIGNAL AND I/O MANAGEMENT

=head2 catch()

The C<catch()> subroutine is the essence of fast and low-impact. We simply
set an already-existing global scalar variable to a constant value. This
avoids allocating any memory possibly in the middle of something that will
get all confused if we do, particularly under I<unsafe signals>.

=cut

sub catch {
    $signal = 1;
    return;    # Put nothing on the stack - malloc/free land!
}

=head2 C<warn()>

C<warn> emits a warning, by joining together its arguments and printing
them, with couple of fillips.

If the composited message I<doesn't> end with a newline, we automatically
add C<$!> and a newline to the end of the message. The subroutine expects $OUT
to be set to the filehandle to be used to output warnings; it makes no
assumptions about what filehandles are available.

=cut

sub _db_warn {
    my ($msg) = join( "", @@_ );
    $msg .= ": $!\n" unless $msg =~ /\n$/;
    local $\ = '';
    print $OUT $msg;
} ## end sub warn

*warn = \&_db_warn;

=head1 INITIALIZATION TTY SUPPORT

=head2 C<reset_IN_OUT>

This routine handles restoring the debugger's input and output filehandles
after we've tried and failed to move them elsewhere.  In addition, it assigns
the debugger's output filehandle to $LINEINFO if it was already open there.

=cut

sub reset_IN_OUT {
    my $switch_li = $LINEINFO eq $OUT;

    # If there's a term and it's able to get a new tty, try to get one.
    if ( $term and $term->Features->{newTTY} ) {
        ( $IN, $OUT ) = ( shift, shift );
        $term->newTTY( $IN, $OUT );
    }

    # This term can't get a new tty now. Better luck later.
    elsif ($term) {
        _db_warn("Too late to set IN/OUT filehandles, enabled on next 'R'!\n");
    }

    # Set the filehndles up as they were.
    else {
        ( $IN, $OUT ) = ( shift, shift );
    }

    # Unbuffer the output filehandle.
    _autoflush($OUT);

    # Point LINEINFO to the same output filehandle if it was there before.
    $LINEINFO = $OUT if $switch_li;
} ## end sub reset_IN_OUT

=head1 OPTION SUPPORT ROUTINES

The following routines are used to process some of the more complicated
debugger options.

=head2 C<TTY>

Sets the input and output filehandles to the specified files or pipes.
If the terminal supports switching, we go ahead and do it. If not, and
there's already a terminal in place, we save the information to take effect
on restart.

If there's no terminal yet (for instance, during debugger initialization),
we go ahead and set C<$console> and C<$tty> to the file indicated.

=cut

sub TTY {

    if ( @@_ and $term and $term->Features->{newTTY} ) {

        # This terminal supports switching to a new TTY.
        # Can be a list of two files, or on string containing both names,
        # comma-separated.
        # XXX Should this perhaps be an assignment from @@_?
        my ( $in, $out ) = shift;
        if ( $in =~ /,/ ) {

            # Split list apart if supplied.
            ( $in, $out ) = split /,/, $in, 2;
        }
        else {

            # Use the same file for both input and output.
            $out = $in;
        }

        # Open file onto the debugger's filehandles, if you can.
        open IN,  $in     or die "cannot open '$in' for read: $!";
        open OUT, ">$out" or die "cannot open '$out' for write: $!";

        # Swap to the new filehandles.
        reset_IN_OUT( \*IN, \*OUT );

        # Save the setting for later.
        return $tty = $in;
    } ## end if (@@_ and $term and $term...

    # Terminal doesn't support new TTY, or doesn't support readline.
    # Can't do it now, try restarting.
    if ($term and @@_) {
        _db_warn("Too late to set TTY, enabled on next 'R'!\n");
    }

    # Useful if done through PERLDB_OPTS:
    $console = $tty = shift if @@_;

    # Return whatever the TTY is.
    $tty or $console;
} ## end sub TTY

=head2 C<noTTY>

Sets the C<$notty> global, controlling whether or not the debugger tries to
get a terminal to read from. If called after a terminal is already in place,
we save the value to use it if we're restarted.

=cut

sub noTTY {
    if ($term) {
        _db_warn("Too late to set noTTY, enabled on next 'R'!\n") if @@_;
    }
    $notty = shift if @@_;
    $notty;
} ## end sub noTTY

=head2 C<ReadLine>

Sets the C<$rl> option variable. If 0, we use C<Term::ReadLine::Stub>
(essentially, no C<readline> processing on this I<terminal>). Otherwise, we
use C<Term::ReadLine>. Can't be changed after a terminal's in place; we save
the value in case a restart is done so we can change it then.

=cut

sub ReadLine {
    if ($term) {
        _db_warn("Too late to set ReadLine, enabled on next 'R'!\n") if @@_;
    }
    $rl = shift if @@_;
    $rl;
} ## end sub ReadLine

=head2 C<RemotePort>

Sets the port that the debugger will try to connect to when starting up.
If the terminal's already been set up, we can't do it, but we remember the
setting in case the user does a restart.

=cut

sub RemotePort {
    if ($term) {
        _db_warn("Too late to set RemotePort, enabled on next 'R'!\n") if @@_;
    }
    $remoteport = shift if @@_;
    $remoteport;
} ## end sub RemotePort

=head2 C<tkRunning>

Checks with the terminal to see if C<Tk> is running, and returns true or
false. Returns false if the current terminal doesn't support C<readline>.

=cut

sub tkRunning {
    if ( ${ $term->Features }{tkRunning} ) {
        return $term->tkRunning(@@_);
    }
    else {
        local $\ = '';
        print $OUT "tkRunning not supported by current ReadLine package.\n";
        0;
    }
} ## end sub tkRunning

=head2 C<NonStop>

Sets nonstop mode. If a terminal's already been set up, it's too late; the
debugger remembers the setting in case you restart, though.

=cut

sub NonStop {
    if ($term) {
        _db_warn("Too late to set up NonStop mode, enabled on next 'R'!\n")
          if @@_;
    }
    $runnonstop = shift if @@_;
    $runnonstop;
} ## end sub NonStop

sub DollarCaretP {
    if ($term) {
        _db_warn("Some flag changes could not take effect until next 'R'!\n")
          if @@_;
    }
    $^P = parse_DollarCaretP_flags(shift) if @@_;
    expand_DollarCaretP_flags($^P);
}

=head2 C<pager>

Set up the C<$pager> variable. Adds a pipe to the front unless there's one
there already.

=cut

sub pager {
    if (@@_) {
        $pager = shift;
        $pager = "|" . $pager unless $pager =~ /^(\+?\>|\|)/;
    }
    $pager;
} ## end sub pager

=head2 C<shellBang>

Sets the shell escape command, and generates a printable copy to be used
in the help.

=cut

sub shellBang {

    # If we got an argument, meta-quote it, and add '\b' if it
    # ends in a word character.
    if (@@_) {
        $sh = quotemeta shift;
        $sh .= "\\b" if $sh =~ /\w$/;
    }

    # Generate the printable version for the help:
    $psh = $sh;    # copy it
    $psh =~ s/\\b$//;        # Take off trailing \b if any
    $psh =~ s/\\(.)/$1/g;    # De-escape
    $psh;                    # return the printable version
} ## end sub shellBang

=head2 C<ornaments>

If the terminal has its own ornaments, fetch them. Otherwise accept whatever
was passed as the argument. (This means you can't override the terminal's
ornaments.)

=cut

sub ornaments {
    if ( defined $term ) {

        # We don't want to show warning backtraces, but we do want die() ones.
        local $warnLevel = 0;
        local $dieLevel = 1;

        # No ornaments if the terminal doesn't support them.
        if (not $term->Features->{ornaments}) {
            return '';
        }

        return (eval { $term->ornaments(@@_) } || '');
    }

    # Use what was passed in if we can't determine it ourselves.
    else {
        $ornaments = shift;

        return $ornaments;
    }

} ## end sub ornaments

=head2 C<recallCommand>

Sets the recall command, and builds a printable version which will appear in
the help text.

=cut

sub recallCommand {

    # If there is input, metaquote it. Add '\b' if it ends with a word
    # character.
    if (@@_) {
        $rc = quotemeta shift;
        $rc .= "\\b" if $rc =~ /\w$/;
    }

    # Build it into a printable version.
    $prc = $rc;              # Copy it
    $prc =~ s/\\b$//;        # Remove trailing \b
    $prc =~ s/\\(.)/$1/g;    # Remove escapes
    return $prc;             # Return the printable version
} ## end sub recallCommand

=head2 C<LineInfo> - where the line number information goes

Called with no arguments, returns the file or pipe that line info should go to.

Called with an argument (a file or a pipe), it opens that onto the
C<LINEINFO> filehandle, unbuffers the filehandle, and then returns the
file or pipe again to the caller.

=cut

sub LineInfo {
    if (@@_) {
        $lineinfo = shift;

        #  If this is a valid "thing to be opened for output", tack a
        # '>' onto the front.
        my $stream = ( $lineinfo =~ /^(\+?\>|\|)/ ) ? $lineinfo : ">$lineinfo";

        # If this is a pipe, the stream points to a slave editor.
        $slave_editor = ( $stream =~ /^\|/ );

        my $new_lineinfo_fh;
        # Open it up and unbuffer it.
        open ($new_lineinfo_fh , $stream )
            or _db_warn("Cannot open '$stream' for write");
        $LINEINFO = $new_lineinfo_fh;
        _autoflush($LINEINFO);
    }

    return $lineinfo;
} ## end sub LineInfo

=head1 COMMAND SUPPORT ROUTINES

These subroutines provide functionality for various commands.

=head2 C<list_modules>

For the C<M> command: list modules loaded and their versions.
Essentially just runs through the keys in %INC, picks each package's
C<$VERSION> variable, gets the file name, and formats the information
for output.

=cut

sub list_modules {    # versions
    my %version;
    my $file;

    # keys are the "as-loaded" name, values are the fully-qualified path
    # to the file itself.
    for ( keys %INC ) {
        $file = $_;                                # get the module name
        s,\.p[lm]$,,i;                             # remove '.pl' or '.pm'
        s,/,::,g;                                  # change '/' to '::'
        s/^perl5db$/DB/;                           # Special case: debugger
                                                   # moves to package DB
        s/^Term::ReadLine::readline$/readline/;    # simplify readline

        # If the package has a $VERSION package global (as all good packages
        # should!) decode it and save as partial message.
        my $pkg_version = do { no strict 'refs'; ${ $_ . '::VERSION' } };
        if ( defined $pkg_version ) {
            $version{$file} = "$pkg_version from ";
        }

        # Finish up the message with the file the package came from.
        $version{$file} .= $INC{$file};
    } ## end for (keys %INC)

    # Hey, dumpit() formats a hash nicely, so why not use it?
    dumpit( $OUT, \%version );
} ## end sub list_modules

=head2 C<sethelp()>

Sets up the monster string used to format and print the help.

=head3 HELP MESSAGE FORMAT

The help message is a peculiar format unto itself; it mixes C<pod> I<ornaments>
(C<< B<> >> C<< I<> >>) with tabs to come up with a format that's fairly
easy to parse and portable, but which still allows the help to be a little
nicer than just plain text.

Essentially, you define the command name (usually marked up with C<< B<> >>
and C<< I<> >>), followed by a tab, and then the descriptive text, ending in a
newline. The descriptive text can also be marked up in the same way. If you
need to continue the descriptive text to another line, start that line with
just tabs and then enter the marked-up text.

If you are modifying the help text, I<be careful>. The help-string parser is
not very sophisticated, and if you don't follow these rules it will mangle the
help beyond hope until you fix the string.

=cut

use vars qw($pre580_help);
use vars qw($pre580_summary);

sub sethelp {

    # XXX: make sure there are tabs between the command and explanation,
    #      or print_help will screw up your formatting if you have
    #      eeevil ornaments enabled.  This is an insane mess.

    $help = "
Help is currently only available for the new 5.8 command set.
No help is available for the old command set.
We assume you know what you're doing if you switch to it.

B<T>        Stack trace.
B<s> [I<expr>]    Single step [in I<expr>].
B<n> [I<expr>]    Next, steps over subroutine calls [in I<expr>].
<B<CR>>        Repeat last B<n> or B<s> command.
B<r>        Return from current subroutine.
B<c> [I<line>|I<sub>]    Continue; optionally inserts a one-time-only breakpoint
        at the specified position.
B<l> I<min>B<+>I<incr>    List I<incr>+1 lines starting at I<min>.
B<l> I<min>B<->I<max>    List lines I<min> through I<max>.
B<l> I<line>        List single I<line>.
B<l> I<subname>    List first window of lines from subroutine.
B<l> I<\$var>        List first window of lines from subroutine referenced by I<\$var>.
B<l>        List next window of lines.
B<->        List previous window of lines.
B<v> [I<line>]    View window around I<line>.
B<.>        Return to the executed line.
B<f> I<filename>    Switch to viewing I<filename>. File must be already loaded.
        I<filename> may be either the full name of the file, or a regular
        expression matching the full file name:
        B<f> I</home/me/foo.pl> and B<f> I<oo\\.> may access the same file.
        Evals (with saved bodies) are considered to be filenames:
        B<f> I<(eval 7)> and B<f> I<eval 7\\b> access the body of the 7th eval
        (in the order of execution).
B</>I<pattern>B</>    Search forwards for I<pattern>; final B</> is optional.
B<?>I<pattern>B<?>    Search backwards for I<pattern>; final B<?> is optional.
B<L> [I<a|b|w>]        List actions and or breakpoints and or watch-expressions.
B<S> [[B<!>]I<pattern>]    List subroutine names [not] matching I<pattern>.
B<t> [I<n>]       Toggle trace mode (to max I<n> levels below current stack depth).
B<t> [I<n>] I<expr>        Trace through execution of I<expr>.
B<b>        Sets breakpoint on current line)
B<b> [I<line>] [I<condition>]
        Set breakpoint; I<line> defaults to the current execution line;
        I<condition> breaks if it evaluates to true, defaults to '1'.
B<b> I<subname> [I<condition>]
        Set breakpoint at first line of subroutine.
B<b> I<\$var>        Set breakpoint at first line of subroutine referenced by I<\$var>.
B<b> B<load> I<filename> Set breakpoint on 'require'ing the given file.
B<b> B<postpone> I<subname> [I<condition>]
        Set breakpoint at first line of subroutine after
        it is compiled.
B<b> B<compile> I<subname>
        Stop after the subroutine is compiled.
B<B> [I<line>]    Delete the breakpoint for I<line>.
B<B> I<*>             Delete all breakpoints.
B<a> [I<line>] I<command>
        Set an action to be done before the I<line> is executed;
        I<line> defaults to the current execution line.
        Sequence is: check for breakpoint/watchpoint, print line
        if necessary, do action, prompt user if necessary,
        execute line.
B<a>        Does nothing
B<A> [I<line>]    Delete the action for I<line>.
B<A> I<*>             Delete all actions.
B<w> I<expr>        Add a global watch-expression.
B<w>             Does nothing
B<W> I<expr>        Delete a global watch-expression.
B<W> I<*>             Delete all watch-expressions.
B<V> [I<pkg> [I<vars>]]    List some (default all) variables in package (default current).
        Use B<~>I<pattern> and B<!>I<pattern> for positive and negative regexps.
B<X> [I<vars>]    Same as \"B<V> I<currentpackage> [I<vars>]\".
B<x> I<expr>        Evals expression in list context, dumps the result.
B<m> I<expr>        Evals expression in list context, prints methods callable
        on the first element of the result.
B<m> I<class>        Prints methods callable via the given class.
B<M>        Show versions of loaded modules.
B<i> I<class>       Prints nested parents of given class.
B<e>         Display current thread id.
B<E>         Display all thread ids the current one will be identified: <n>.
B<y> [I<n> [I<Vars>]]   List lexicals in higher scope <n>.  Vars same as B<V>.

B<<> ?            List Perl commands to run before each prompt.
B<<> I<expr>        Define Perl command to run before each prompt.
B<<<> I<expr>        Add to the list of Perl commands to run before each prompt.
B<< *>                Delete the list of perl commands to run before each prompt.
B<>> ?            List Perl commands to run after each prompt.
B<>> I<expr>        Define Perl command to run after each prompt.
B<>>B<>> I<expr>        Add to the list of Perl commands to run after each prompt.
B<>>B< *>        Delete the list of Perl commands to run after each prompt.
B<{> I<db_command>    Define debugger command to run before each prompt.
B<{> ?            List debugger commands to run before each prompt.
B<{{> I<db_command>    Add to the list of debugger commands to run before each prompt.
B<{ *>             Delete the list of debugger commands to run before each prompt.
B<$prc> I<number>    Redo a previous command (default previous command).
B<$prc> I<-number>    Redo number'th-to-last command.
B<$prc> I<pattern>    Redo last command that started with I<pattern>.
        See 'B<O> I<recallCommand>' too.
B<$psh$psh> I<cmd>      Run cmd in a subprocess (reads from DB::IN, writes to DB::OUT)"
      . (
        $rc eq $sh
        ? ""
        : "
B<$psh> [I<cmd>] Run I<cmd> in subshell (forces \"\$SHELL -c 'cmd'\")."
      ) . "
        See 'B<O> I<shellBang>' too.
B<source> I<file>     Execute I<file> containing debugger commands (may nest).
B<save> I<file>       Save current debugger session (actual history) to I<file>.
B<rerun>           Rerun session to current position.
B<rerun> I<n>         Rerun session to numbered command.
B<rerun> I<-n>        Rerun session to number'th-to-last command.
B<H> I<-number>    Display last number commands (default all).
B<H> I<*>          Delete complete history.
B<p> I<expr>        Same as \"I<print {DB::OUT} expr>\" in current package.
B<|>I<dbcmd>        Run debugger command, piping DB::OUT to current pager.
B<||>I<dbcmd>        Same as B<|>I<dbcmd> but DB::OUT is temporarily select()ed as well.
B<\=> [I<alias> I<value>]    Define a command alias, or list current aliases.
I<command>        Execute as a perl statement in current package.
B<R>        Pure-man-restart of debugger, some of debugger state
        and command-line options may be lost.
        Currently the following settings are preserved:
        history, breakpoints and actions, debugger B<O>ptions
        and the following command-line options: I<-w>, I<-I>, I<-e>.

B<o> [I<opt>] ...    Set boolean option to true
B<o> [I<opt>B<?>]    Query options
B<o> [I<opt>B<=>I<val>] [I<opt>=B<\">I<val>B<\">] ...
        Set options.  Use quotes if spaces in value.
    I<recallCommand>, I<ShellBang>    chars used to recall command or spawn shell;
    I<pager>            program for output of \"|cmd\";
    I<tkRunning>            run Tk while prompting (with ReadLine);
    I<signalLevel> I<warnLevel> I<dieLevel>    level of verbosity;
    I<inhibit_exit>        Allows stepping off the end of the script.
    I<ImmediateStop>        Debugger should stop as early as possible.
    I<RemotePort>            Remote hostname:port for remote debugging
  The following options affect what happens with B<V>, B<X>, and B<x> commands:
    I<arrayDepth>, I<hashDepth>     print only first N elements ('' for all);
    I<compactDump>, I<veryCompact>     change style of array and hash dump;
    I<globPrint>             whether to print contents of globs;
    I<DumpDBFiles>         dump arrays holding debugged files;
    I<DumpPackages>         dump symbol tables of packages;
    I<DumpReused>             dump contents of \"reused\" addresses;
    I<quote>, I<HighBit>, I<undefPrint>     change style of string dump;
    I<bareStringify>         Do not print the overload-stringified value;
  Other options include:
    I<PrintRet>        affects printing of return value after B<r> command,
    I<frame>        affects printing messages on subroutine entry/exit.
    I<AutoTrace>    affects printing messages on possible breaking points.
    I<maxTraceLen>    gives max length of evals/args listed in stack trace.
    I<ornaments>     affects screen appearance of the command line.
    I<CreateTTY>     bits control attempts to create a new TTY on events:
            1: on fork()    2: debugger is started inside debugger
            4: on startup
    During startup options are initialized from \$ENV{PERLDB_OPTS}.
    You can put additional initialization options I<TTY>, I<noTTY>,
    I<ReadLine>, I<NonStop>, and I<RemotePort> there (or use
    B<R> after you set them).

B<q> or B<^D>        Quit. Set B<\$DB::finished = 0> to debug global destruction.
B<h>        Summary of debugger commands.
B<h> [I<db_command>]    Get help [on a specific debugger command], enter B<|h> to page.
B<h h>        Long help for debugger commands
B<$doccmd> I<manpage>    Runs the external doc viewer B<$doccmd> command on the
        named Perl I<manpage>, or on B<$doccmd> itself if omitted.
        Set B<\$DB::doccmd> to change viewer.

Type '|h h' for a paged display if this was too hard to read.

";    # Fix balance of vi % matching: }}}}

    #  note: tabs in the following section are not-so-helpful
    $summary = <<"END_SUM";
I<List/search source lines:>               I<Control script execution:>
  B<l> [I<ln>|I<sub>]  List source code            B<T>           Stack trace
  B<-> or B<.>      List previous/current line  B<s> [I<expr>]    Single step [in expr]
  B<v> [I<line>]    View around line            B<n> [I<expr>]    Next, steps over subs
  B<f> I<filename>  View source in file         <B<CR>/B<Enter>>  Repeat last B<n> or B<s>
  B</>I<pattern>B</> B<?>I<patt>B<?>   Search forw/backw    B<r>           Return from subroutine
  B<M>           Show module versions        B<c> [I<ln>|I<sub>]  Continue until position
I<Debugger controls:>                        B<L>           List break/watch/actions
  B<o> [...]     Set debugger options        B<t> [I<n>] [I<expr>] Toggle trace [max depth] ][trace expr]
  B<<>[B<<>]|B<{>[B<{>]|B<>>[B<>>] [I<cmd>] Do pre/post-prompt B<b> [I<ln>|I<event>|I<sub>] [I<cnd>] Set breakpoint
  B<$prc> [I<N>|I<pat>]   Redo a previous command     B<B> I<ln|*>      Delete a/all breakpoints
  B<H> [I<-num>]    Display last num commands   B<a> [I<ln>] I<cmd>  Do cmd before line
  B<=> [I<a> I<val>]   Define/list an alias        B<A> I<ln|*>      Delete a/all actions
  B<h> [I<db_cmd>]  Get help on command         B<w> I<expr>      Add a watch expression
  B<h h>         Complete help page          B<W> I<expr|*>    Delete a/all watch exprs
  B<|>[B<|>]I<db_cmd>  Send output to pager        B<$psh>\[B<$psh>\] I<syscmd> Run cmd in a subprocess
  B<q> or B<^D>     Quit                        B<R>           Attempt a restart
I<Data Examination:>     B<expr>     Execute perl code, also see: B<s>,B<n>,B<t> I<expr>
  B<x>|B<m> I<expr>       Evals expr in list context, dumps the result or lists methods.
  B<p> I<expr>         Print expression (uses script's current package).
  B<S> [[B<!>]I<pat>]     List subroutine names [not] matching pattern
  B<V> [I<Pk> [I<Vars>]]  List Variables in Package.  Vars can be ~pattern or !pattern.
  B<X> [I<Vars>]       Same as \"B<V> I<current_package> [I<Vars>]\".  B<i> I<class> inheritance tree.
  B<y> [I<n> [I<Vars>]]   List lexicals in higher scope <n>.  Vars same as B<V>.
  B<e>     Display thread id     B<E> Display all thread ids.
For more help, type B<h> I<cmd_letter>, or run B<$doccmd perldebug> for all docs.
END_SUM

    # ')}}; # Fix balance of vi % matching

    # and this is really numb...
    $pre580_help = "
B<T>        Stack trace.
B<s> [I<expr>]    Single step [in I<expr>].
B<n> [I<expr>]    Next, steps over subroutine calls [in I<expr>].
B<CR>>        Repeat last B<n> or B<s> command.
B<r>        Return from current subroutine.
B<c> [I<line>|I<sub>]    Continue; optionally inserts a one-time-only breakpoint
        at the specified position.
B<l> I<min>B<+>I<incr>    List I<incr>+1 lines starting at I<min>.
B<l> I<min>B<->I<max>    List lines I<min> through I<max>.
B<l> I<line>        List single I<line>.
B<l> I<subname>    List first window of lines from subroutine.
B<l> I<\$var>        List first window of lines from subroutine referenced by I<\$var>.
B<l>        List next window of lines.
B<->        List previous window of lines.
B<w> [I<line>]    List window around I<line>.
B<.>        Return to the executed line.
B<f> I<filename>    Switch to viewing I<filename>. File must be already loaded.
        I<filename> may be either the full name of the file, or a regular
        expression matching the full file name:
        B<f> I</home/me/foo.pl> and B<f> I<oo\\.> may access the same file.
        Evals (with saved bodies) are considered to be filenames:
        B<f> I<(eval 7)> and B<f> I<eval 7\\b> access the body of the 7th eval
        (in the order of execution).
B</>I<pattern>B</>    Search forwards for I<pattern>; final B</> is optional.
B<?>I<pattern>B<?>    Search backwards for I<pattern>; final B<?> is optional.
B<L>        List all breakpoints and actions.
B<S> [[B<!>]I<pattern>]    List subroutine names [not] matching I<pattern>.
B<t> [I<n>]       Toggle trace mode (to max I<n> levels below current stack depth) .
B<t> [I<n>] I<expr>        Trace through execution of I<expr>.
B<b> [I<line>] [I<condition>]
        Set breakpoint; I<line> defaults to the current execution line;
        I<condition> breaks if it evaluates to true, defaults to '1'.
B<b> I<subname> [I<condition>]
        Set breakpoint at first line of subroutine.
B<b> I<\$var>        Set breakpoint at first line of subroutine referenced by I<\$var>.
B<b> B<load> I<filename> Set breakpoint on 'require'ing the given file.
B<b> B<postpone> I<subname> [I<condition>]
        Set breakpoint at first line of subroutine after
        it is compiled.
B<b> B<compile> I<subname>
        Stop after the subroutine is compiled.
B<d> [I<line>]    Delete the breakpoint for I<line>.
B<D>        Delete all breakpoints.
B<a> [I<line>] I<command>
        Set an action to be done before the I<line> is executed;
        I<line> defaults to the current execution line.
        Sequence is: check for breakpoint/watchpoint, print line
        if necessary, do action, prompt user if necessary,
        execute line.
B<a> [I<line>]    Delete the action for I<line>.
B<A>        Delete all actions.
B<W> I<expr>        Add a global watch-expression.
B<W>        Delete all watch-expressions.
B<V> [I<pkg> [I<vars>]]    List some (default all) variables in package (default current).
        Use B<~>I<pattern> and B<!>I<pattern> for positive and negative regexps.
B<X> [I<vars>]    Same as \"B<V> I<currentpackage> [I<vars>]\".
B<x> I<expr>        Evals expression in list context, dumps the result.
B<m> I<expr>        Evals expression in list context, prints methods callable
        on the first element of the result.
B<m> I<class>        Prints methods callable via the given class.

B<<> ?            List Perl commands to run before each prompt.
B<<> I<expr>        Define Perl command to run before each prompt.
B<<<> I<expr>        Add to the list of Perl commands to run before each prompt.
B<>> ?            List Perl commands to run after each prompt.
B<>> I<expr>        Define Perl command to run after each prompt.
B<>>B<>> I<expr>        Add to the list of Perl commands to run after each prompt.
B<{> I<db_command>    Define debugger command to run before each prompt.
B<{> ?            List debugger commands to run before each prompt.
B<{{> I<db_command>    Add to the list of debugger commands to run before each prompt.
B<$prc> I<number>    Redo a previous command (default previous command).
B<$prc> I<-number>    Redo number'th-to-last command.
B<$prc> I<pattern>    Redo last command that started with I<pattern>.
        See 'B<O> I<recallCommand>' too.
B<$psh$psh> I<cmd>      Run cmd in a subprocess (reads from DB::IN, writes to DB::OUT)"
      . (
        $rc eq $sh
        ? ""
        : "
B<$psh> [I<cmd>]     Run I<cmd> in subshell (forces \"\$SHELL -c 'cmd'\")."
      ) . "
        See 'B<O> I<shellBang>' too.
B<source> I<file>        Execute I<file> containing debugger commands (may nest).
B<H> I<-number>    Display last number commands (default all).
B<p> I<expr>        Same as \"I<print {DB::OUT} expr>\" in current package.
B<|>I<dbcmd>        Run debugger command, piping DB::OUT to current pager.
B<||>I<dbcmd>        Same as B<|>I<dbcmd> but DB::OUT is temporarilly select()ed as well.
B<\=> [I<alias> I<value>]    Define a command alias, or list current aliases.
I<command>        Execute as a perl statement in current package.
B<v>        Show versions of loaded modules.
B<R>        Pure-man-restart of debugger, some of debugger state
        and command-line options may be lost.
        Currently the following settings are preserved:
        history, breakpoints and actions, debugger B<O>ptions
        and the following command-line options: I<-w>, I<-I>, I<-e>.

B<O> [I<opt>] ...    Set boolean option to true
B<O> [I<opt>B<?>]    Query options
B<O> [I<opt>B<=>I<val>] [I<opt>=B<\">I<val>B<\">] ...
        Set options.  Use quotes if spaces in value.
    I<recallCommand>, I<ShellBang>    chars used to recall command or spawn shell;
    I<pager>            program for output of \"|cmd\";
    I<tkRunning>            run Tk while prompting (with ReadLine);
    I<signalLevel> I<warnLevel> I<dieLevel>    level of verbosity;
    I<inhibit_exit>        Allows stepping off the end of the script.
    I<ImmediateStop>        Debugger should stop as early as possible.
    I<RemotePort>            Remote hostname:port for remote debugging
  The following options affect what happens with B<V>, B<X>, and B<x> commands:
    I<arrayDepth>, I<hashDepth>     print only first N elements ('' for all);
    I<compactDump>, I<veryCompact>     change style of array and hash dump;
    I<globPrint>             whether to print contents of globs;
    I<DumpDBFiles>         dump arrays holding debugged files;
    I<DumpPackages>         dump symbol tables of packages;
    I<DumpReused>             dump contents of \"reused\" addresses;
    I<quote>, I<HighBit>, I<undefPrint>     change style of string dump;
    I<bareStringify>         Do not print the overload-stringified value;
  Other options include:
    I<PrintRet>        affects printing of return value after B<r> command,
    I<frame>        affects printing messages on subroutine entry/exit.
    I<AutoTrace>    affects printing messages on possible breaking points.
    I<maxTraceLen>    gives max length of evals/args listed in stack trace.
    I<ornaments>     affects screen appearance of the command line.
    I<CreateTTY>     bits control attempts to create a new TTY on events:
            1: on fork()    2: debugger is started inside debugger
            4: on startup
    During startup options are initialized from \$ENV{PERLDB_OPTS}.
    You can put additional initialization options I<TTY>, I<noTTY>,
    I<ReadLine>, I<NonStop>, and I<RemotePort> there (or use
    B<R> after you set them).

B<q> or B<^D>        Quit. Set B<\$DB::finished = 0> to debug global destruction.
B<h> [I<db_command>]    Get help [on a specific debugger command], enter B<|h> to page.
B<h h>        Summary of debugger commands.
B<$doccmd> I<manpage>    Runs the external doc viewer B<$doccmd> command on the
        named Perl I<manpage>, or on B<$doccmd> itself if omitted.
        Set B<\$DB::doccmd> to change viewer.

Type '|h' for a paged display if this was too hard to read.

";    # Fix balance of vi % matching: }}}}

    #  note: tabs in the following section are not-so-helpful
    $pre580_summary = <<"END_SUM";
I<List/search source lines:>               I<Control script execution:>
  B<l> [I<ln>|I<sub>]  List source code            B<T>           Stack trace
  B<-> or B<.>      List previous/current line  B<s> [I<expr>]    Single step [in expr]
  B<w> [I<line>]    List around line            B<n> [I<expr>]    Next, steps over subs
  B<f> I<filename>  View source in file         <B<CR>/B<Enter>>  Repeat last B<n> or B<s>
  B</>I<pattern>B</> B<?>I<patt>B<?>   Search forw/backw    B<r>           Return from subroutine
  B<v>           Show versions of modules    B<c> [I<ln>|I<sub>]  Continue until position
I<Debugger controls:>                        B<L>           List break/watch/actions
  B<O> [...]     Set debugger options        B<t> [I<expr>]    Toggle trace [trace expr]
  B<<>[B<<>]|B<{>[B<{>]|B<>>[B<>>] [I<cmd>] Do pre/post-prompt B<b> [I<ln>|I<event>|I<sub>] [I<cnd>] Set breakpoint
  B<$prc> [I<N>|I<pat>]   Redo a previous command     B<d> [I<ln>] or B<D> Delete a/all breakpoints
  B<H> [I<-num>]    Display last num commands   B<a> [I<ln>] I<cmd>  Do cmd before line
  B<=> [I<a> I<val>]   Define/list an alias        B<W> I<expr>      Add a watch expression
  B<h> [I<db_cmd>]  Get help on command         B<A> or B<W>      Delete all actions/watch
  B<|>[B<|>]I<db_cmd>  Send output to pager        B<$psh>\[B<$psh>\] I<syscmd> Run cmd in a subprocess
  B<q> or B<^D>     Quit                        B<R>           Attempt a restart
I<Data Examination:>     B<expr>     Execute perl code, also see: B<s>,B<n>,B<t> I<expr>
  B<x>|B<m> I<expr>       Evals expr in list context, dumps the result or lists methods.
  B<p> I<expr>         Print expression (uses script's current package).
  B<S> [[B<!>]I<pat>]     List subroutine names [not] matching pattern
  B<V> [I<Pk> [I<Vars>]]  List Variables in Package.  Vars can be ~pattern or !pattern.
  B<X> [I<Vars>]       Same as \"B<V> I<current_package> [I<Vars>]\".
  B<y> [I<n> [I<Vars>]]   List lexicals in higher scope <n>.  Vars same as B<V>.
For more help, type B<h> I<cmd_letter>, or run B<$doccmd perldebug> for all docs.
END_SUM

    # ')}}; # Fix balance of vi % matching

} ## end sub sethelp

=head2 C<print_help()>

Most of what C<print_help> does is just text formatting. It finds the
C<B> and C<I> ornaments, cleans them off, and substitutes the proper
terminal control characters to simulate them (courtesy of
C<Term::ReadLine::TermCap>).

=cut

sub print_help {
    my $help_str = shift;

    # Restore proper alignment destroyed by eeevil I<> and B<>
    # ornaments: A pox on both their houses!
    #
    # A help command will have everything up to and including
    # the first tab sequence padded into a field 16 (or if indented 20)
    # wide.  If it's wider than that, an extra space will be added.
    $help_str =~ s{
        ^                       # only matters at start of line
          ( \ {4} | \t )*       # some subcommands are indented
          ( < ?                 # so <CR> works
            [BI] < [^\t\n] + )  # find an eeevil ornament
          ( \t+ )               # original separation, discarded
          ( .* )                # this will now start (no earlier) than
                                # column 16
    } {
        my($leadwhite, $command, $midwhite, $text) = ($1, $2, $3, $4);
        my $clean = $command;
        $clean =~ s/[BI]<([^>]*)>/$1/g;

        # replace with this whole string:
        ($leadwhite ? " " x 4 : "")
      . $command
      . ((" " x (16 + ($leadwhite ? 4 : 0) - length($clean))) || " ")
      . $text;

    }mgex;

    $help_str =~ s{                          # handle bold ornaments
       B < ( [^>] + | > ) >
    } {
          $Term::ReadLine::TermCap::rl_term_set[2]
        . $1
        . $Term::ReadLine::TermCap::rl_term_set[3]
    }gex;

    $help_str =~ s{                         # handle italic ornaments
       I < ( [^>] + | > ) >
    } {
          $Term::ReadLine::TermCap::rl_term_set[0]
        . $1
        . $Term::ReadLine::TermCap::rl_term_set[1]
    }gex;

    local $\ = '';
    print {$OUT} $help_str;

    return;
} ## end sub print_help

=head2 C<fix_less>

This routine does a lot of gyrations to be sure that the pager is C<less>.
It checks for C<less> masquerading as C<more> and records the result in
C<$fixed_less> so we don't have to go through doing the stats again.

=cut

use vars qw($fixed_less);

sub _calc_is_less {
    if ($pager =~ /\bless\b/)
    {
        return 1;
    }
    elsif ($pager =~ /\bmore\b/)
    {
        # Nope, set to more. See what's out there.
        my @@st_more = stat('/usr/bin/more');
        my @@st_less = stat('/usr/bin/less');

        # is it really less, pretending to be more?
        return (
            @@st_more
            && @@st_less
            && $st_more[0] == $st_less[0]
            && $st_more[1] == $st_less[1]
        );
    }
    else {
        return;
    }
}

sub fix_less {

    # We already know if this is set.
    return if $fixed_less;

    # changes environment!
    # 'r' added so we don't do (slow) stats again.
    $fixed_less = 1 if _calc_is_less();

    return;
} ## end sub fix_less

=head1 DIE AND WARN MANAGEMENT

=head2 C<diesignal>

C<diesignal> is a just-drop-dead C<die> handler. It's most useful when trying
to debug a debugger problem.

It does its best to report the error that occurred, and then forces the
program, debugger, and everything to die.

=cut

sub diesignal {

    # No entry/exit messages.
    local $frame = 0;

    # No return value prints.
    local $doret = -2;

    # set the abort signal handling to the default (just terminate).
    $SIG{'ABRT'} = 'DEFAULT';

    # If we enter the signal handler recursively, kill myself with an
    # abort signal (so we just terminate).
    kill 'ABRT', $$ if $panic++;

    # If we can show detailed info, do so.
    if ( defined &Carp::longmess ) {

        # Don't recursively enter the warn handler, since we're carping.
        local $SIG{__WARN__} = '';

        # Skip two levels before reporting traceback: we're skipping
        # mydie and confess.
        local $Carp::CarpLevel = 2;    # mydie + confess

        # Tell us all about it.
        _db_warn( Carp::longmess("Signal @@_") );
    }

    # No Carp. Tell us about the signal as best we can.
    else {
        local $\ = '';
        print $DB::OUT "Got signal @@_\n";
    }

    # Drop dead.
    kill 'ABRT', $$;
} ## end sub diesignal

=head2 C<dbwarn>

The debugger's own default C<$SIG{__WARN__}> handler. We load C<Carp> to
be able to get a stack trace, and output the warning message vi C<DB::dbwarn()>.

=cut

sub dbwarn {

    # No entry/exit trace.
    local $frame = 0;

    # No return value printing.
    local $doret = -2;

    # Turn off warn and die handling to prevent recursive entries to this
    # routine.
    local $SIG{__WARN__} = '';
    local $SIG{__DIE__}  = '';

    # Load Carp if we can. If $^S is false (current thing being compiled isn't
    # done yet), we may not be able to do a require.
    eval { require Carp }
      if defined $^S;    # If error/warning during compilation,
                         # require may be broken.

    # Use the core warn() unless Carp loaded OK.
    CORE::warn( @@_,
        "\nCannot print stack trace, load with -MCarp option to see stack" ),
      return
      unless defined &Carp::longmess;

    # Save the current values of $single and $trace, and then turn them off.
    my ( $mysingle, $mytrace ) = ( $single, $trace );
    $single = 0;
    $trace  = 0;

    # We can call Carp::longmess without its being "debugged" (which we
    # don't want - we just want to use it!). Capture this for later.
    my $mess = Carp::longmess(@@_);

    # Restore $single and $trace to their original values.
    ( $single, $trace ) = ( $mysingle, $mytrace );

    # Use the debugger's own special way of printing warnings to print
    # the stack trace message.
    _db_warn($mess);
} ## end sub dbwarn

=head2 C<dbdie>

The debugger's own C<$SIG{__DIE__}> handler. Handles providing a stack trace
by loading C<Carp> and calling C<Carp::longmess()> to get it. We turn off
single stepping and tracing during the call to C<Carp::longmess> to avoid
debugging it - we just want to use it.

If C<dieLevel> is zero, we let the program being debugged handle the
exceptions. If it's 1, you get backtraces for any exception. If it's 2,
the debugger takes over all exception handling, printing a backtrace and
displaying the exception via its C<dbwarn()> routine.

=cut

sub dbdie {
    local $frame         = 0;
    local $doret         = -2;
    local $SIG{__DIE__}  = '';
    local $SIG{__WARN__} = '';
    if ( $dieLevel > 2 ) {
        local $SIG{__WARN__} = \&dbwarn;
        _db_warn(@@_);    # Yell no matter what
        return;
    }
    if ( $dieLevel < 2 ) {
        die @@_ if $^S;    # in eval propagate
    }

    # The code used to check $^S to see if compilation of the current thing
    # hadn't finished. We don't do it anymore, figuring eval is pretty stable.
    eval { require Carp };

    die( @@_,
        "\nCannot print stack trace, load with -MCarp option to see stack" )
      unless defined &Carp::longmess;

    # We do not want to debug this chunk (automatic disabling works
    # inside DB::DB, but not in Carp). Save $single and $trace, turn them off,
    # get the stack trace from Carp::longmess (if possible), restore $signal
    # and $trace, and then die with the stack trace.
    my ( $mysingle, $mytrace ) = ( $single, $trace );
    $single = 0;
    $trace  = 0;
    my $mess = "@@_";
    {

        package Carp;    # Do not include us in the list
        eval { $mess = Carp::longmess(@@_); };
    }
    ( $single, $trace ) = ( $mysingle, $mytrace );
    die $mess;
} ## end sub dbdie

=head2 C<warnlevel()>

Set the C<$DB::warnLevel> variable that stores the value of the
C<warnLevel> option. Calling C<warnLevel()> with a positive value
results in the debugger taking over all warning handlers. Setting
C<warnLevel> to zero leaves any warning handlers set up by the program
being debugged in place.

=cut

sub warnLevel {
    if (@@_) {
        my $prevwarn = $SIG{__WARN__} unless $warnLevel;
        $warnLevel = shift;
        if ($warnLevel) {
            $SIG{__WARN__} = \&DB::dbwarn;
        }
        elsif ($prevwarn) {
            $SIG{__WARN__} = $prevwarn;
        } else {
            undef $SIG{__WARN__};
        }
    } ## end if (@@_)
    $warnLevel;
} ## end sub warnLevel

=head2 C<dielevel>

Similar to C<warnLevel>. Non-zero values for C<dieLevel> result in the
C<DB::dbdie()> function overriding any other C<die()> handler. Setting it to
zero lets you use your own C<die()> handler.

=cut

sub dieLevel {
    local $\ = '';
    if (@@_) {
        my $prevdie = $SIG{__DIE__} unless $dieLevel;
        $dieLevel = shift;
        if ($dieLevel) {

            # Always set it to dbdie() for non-zero values.
            $SIG{__DIE__} = \&DB::dbdie;    # if $dieLevel < 2;

            # No longer exists, so don't try  to use it.
            #$SIG{__DIE__} = \&DB::diehard if $dieLevel >= 2;

            # If we've finished initialization, mention that stack dumps
            # are enabled, If dieLevel is 1, we won't stack dump if we die
            # in an eval().
            print $OUT "Stack dump during die enabled",
              ( $dieLevel == 1 ? " outside of evals" : "" ), ".\n"
              if $I_m_init;

            # XXX This is probably obsolete, given that diehard() is gone.
            print $OUT "Dump printed too.\n" if $dieLevel > 2;
        } ## end if ($dieLevel)

        # Put the old one back if there was one.
        elsif ($prevdie) {
            $SIG{__DIE__} = $prevdie;
            print $OUT "Default die handler restored.\n";
        } else {
            undef $SIG{__DIE__};
            print $OUT "Die handler removed.\n";
        }
    } ## end if (@@_)
    $dieLevel;
} ## end sub dieLevel

=head2 C<signalLevel>

Number three in a series: set C<signalLevel> to zero to keep your own
signal handler for C<SIGSEGV> and/or C<SIGBUS>. Otherwise, the debugger
takes over and handles them with C<DB::diesignal()>.

=cut

sub signalLevel {
    if (@@_) {
        my $prevsegv = $SIG{SEGV} unless $signalLevel;
        my $prevbus  = $SIG{BUS}  unless $signalLevel;
        $signalLevel = shift;
        if ($signalLevel) {
            $SIG{SEGV} = \&DB::diesignal;
            $SIG{BUS}  = \&DB::diesignal;
        }
        else {
            $SIG{SEGV} = $prevsegv;
            $SIG{BUS}  = $prevbus;
        }
    } ## end if (@@_)
    $signalLevel;
} ## end sub signalLevel

=head1 SUBROUTINE DECODING SUPPORT

These subroutines are used during the C<x> and C<X> commands to try to
produce as much information as possible about a code reference. They use
L<Devel::Peek> to try to find the glob in which this code reference lives
(if it does) - this allows us to actually code references which correspond
to named subroutines (including those aliased via glob assignment).

=head2 C<CvGV_name()>

Wrapper for C<CvGV_name_or_bust>; tries to get the name of a reference
via that routine. If this fails, return the reference again (when the
reference is stringified, it'll come out as C<SOMETHING(0x...)>).

=cut

sub CvGV_name {
    my $in   = shift;
    my $name = CvGV_name_or_bust($in);
    defined $name ? $name : $in;
}

=head2 C<CvGV_name_or_bust> I<coderef>

Calls L<Devel::Peek> to try to find the glob the ref lives in; returns
C<undef> if L<Devel::Peek> can't be loaded, or if C<Devel::Peek::CvGV> can't
find a glob for this ref.

Returns C<< I<package>::I<glob name> >> if the code ref is found in a glob.

=cut

use vars qw($skipCvGV);

sub CvGV_name_or_bust {
    my $in = shift;
    return if $skipCvGV;    # Backdoor to avoid problems if XS broken...
    return unless ref $in;
    $in = \&$in;            # Hard reference...
    eval { require Devel::Peek; 1 } or return;
    my $gv = Devel::Peek::CvGV($in) or return;
    *$gv{PACKAGE} . '::' . *$gv{NAME};
} ## end sub CvGV_name_or_bust

=head2 C<find_sub>

A utility routine used in various places; finds the file where a subroutine
was defined, and returns that filename and a line-number range.

Tries to use C<@@sub> first; if it can't find it there, it tries building a
reference to the subroutine and uses C<CvGV_name_or_bust> to locate it,
loading it into C<@@sub> as a side effect (XXX I think). If it can't find it
this way, it brute-force searches C<%sub>, checking for identical references.

=cut

sub _find_sub_helper {
    my $subr = shift;

    return unless defined &$subr;
    my $name = CvGV_name_or_bust($subr);
    my $data;
    $data = $sub{$name} if defined $name;
    return $data if defined $data;

    # Old stupid way...
    $subr = \&$subr;    # Hard reference
    my $s;
    for ( keys %sub ) {
        $s = $_, last if $subr eq \&$_;
    }
    if ($s)
    {
        return $sub{$s};
    }
    else
    {
        return;
    }

}

sub find_sub {
    my $subr = shift;
    return ( $sub{$subr} || _find_sub_helper($subr) );
} ## end sub find_sub

=head2 C<methods>

A subroutine that uses the utility function C<methods_via> to find all the
methods in the class corresponding to the current reference and in
C<UNIVERSAL>.

=cut

use vars qw(%seen);

sub methods {

    # Figure out the class - either this is the class or it's a reference
    # to something blessed into that class.
    my $class = shift;
    $class = ref $class if ref $class;

    local %seen;

    # Show the methods that this class has.
    methods_via( $class, '', 1 );

    # Show the methods that UNIVERSAL has.
    methods_via( 'UNIVERSAL', 'UNIVERSAL', 0 );
} ## end sub methods

=head2 C<methods_via($class, $prefix, $crawl_upward)>

C<methods_via> does the work of crawling up the C<@@ISA> tree and reporting
all the parent class methods. C<$class> is the name of the next class to
try; C<$prefix> is the message prefix, which gets built up as we go up the
C<@@ISA> tree to show parentage; C<$crawl_upward> is 1 if we should try to go
higher in the C<@@ISA> tree, 0 if we should stop.

=cut

sub methods_via {

    # If we've processed this class already, just quit.
    my $class = shift;
    return if $seen{$class}++;

    # This is a package that is contributing the methods we're about to print.
    my $prefix  = shift;
    my $prepend = $prefix ? "via $prefix: " : '';
    my @@to_print;

    # Extract from all the symbols in this class.
    my $class_ref = do { no strict "refs"; \%{$class . '::'} };
    while (my ($name, $glob) = each %$class_ref) {
        # references directly in the symbol table are Proxy Constant
        # Subroutines, and are by their very nature defined
        # Otherwise, check if the thing is a typeglob, and if it is, it decays
        # to a subroutine reference, which can be tested by defined.
        # $glob might also be the value -1  (from sub foo;)
        # or (say) '$$' (from sub foo ($$);)
        # \$glob will be SCALAR in both cases.
        if ((ref $glob || ($glob && ref \$glob eq 'GLOB' && defined &$glob))
            && !$seen{$name}++) {
            push @@to_print, "$prepend$name\n";
        }
    }

    {
        local $\ = '';
        local $, = '';
        print $DB::OUT $_ foreach sort @@to_print;
    }

    # If the $crawl_upward argument is false, just quit here.
    return unless shift;

    # $crawl_upward true: keep going up the tree.
    # Find all the classes this one is a subclass of.
    my $class_ISA_ref = do { no strict "refs"; \@@{"${class}::ISA"} };
    for my $name ( @@$class_ISA_ref ) {

        # Set up the new prefix.
        $prepend = $prefix ? $prefix . " -> $name" : $name;

        # Crawl up the tree and keep trying to crawl up.
        methods_via( $name, $prepend, 1 );
    }
} ## end sub methods_via

=head2 C<setman> - figure out which command to use to show documentation

Just checks the contents of C<$^O> and sets the C<$doccmd> global accordingly.

=cut

sub setman {
    $doccmd = $^O !~ /^(?:MSWin32|VMS|os2|dos|amigaos|riscos|NetWare)\z/s
      ? "man"         # O Happy Day!
      : "perldoc";    # Alas, poor unfortunates
} ## end sub setman

=head2 C<runman> - run the appropriate command to show documentation

Accepts a man page name; runs the appropriate command to display it (set up
during debugger initialization). Uses C<_db_system()> to avoid mucking up the
program's STDIN and STDOUT.

=cut

sub runman {
    my $page = shift;
    unless ($page) {
        _db_system("$doccmd $doccmd");
        return;
    }

    # this way user can override, like with $doccmd="man -Mwhatever"
    # or even just "man " to disable the path check.
    if ( $doccmd ne 'man' ) {
        _db_system("$doccmd $page");
        return;
    }

    $page = 'perl' if lc($page) eq 'help';

    require Config;
    my $man1dir = $Config::Config{man1direxp};
    my $man3dir = $Config::Config{man3direxp};
    for ( $man1dir, $man3dir ) { s#/[^/]*\z## if /\S/ }
    my $manpath = '';
    $manpath .= "$man1dir:" if $man1dir =~ /\S/;
    $manpath .= "$man3dir:" if $man3dir =~ /\S/ && $man1dir ne $man3dir;
    chop $manpath if $manpath;

    # harmless if missing, I figure
    local $ENV{MANPATH} = $manpath if $manpath;
    my $nopathopt = $^O =~ /dunno what goes here/;
    if (
        CORE::system(
            $doccmd,

            # I just *know* there are men without -M
            ( ( $manpath && !$nopathopt ) ? ( "-M", $manpath ) : () ),
            split ' ', $page
        )
      )
    {
        unless ( $page =~ /^perl\w/ ) {
            # Previously the debugger contained a list which it slurped in,
            # listing the known "perl" manpages. However, it was out of date,
            # with errors both of omission and inclusion. This approach is
            # considerably less complex. The failure mode on a butchered
            # install is simply that the user has to run man or perldoc
            # "manually" with the full manpage name.

            # There is a list of $^O values in installperl to determine whether
            # the directory is 'pods' or 'pod'. However, we can avoid tight
            # coupling to that by simply checking the "non-standard" 'pods'
            # first.
            my $pods = "$Config::Config{privlibexp}/pods";
            $pods = "$Config::Config{privlibexp}/pod"
                unless -d $pods;
            if (-f "$pods/perl$page.pod") {
                CORE::system( $doccmd,
                    ( ( $manpath && !$nopathopt ) ? ( "-M", $manpath ) : () ),
                    "perl$page" );
            }
        }
    } ## end if (CORE::system($doccmd...
} ## end sub runman

#use Carp;                          # This did break, left for debugging

=head1 DEBUGGER INITIALIZATION - THE SECOND BEGIN BLOCK

Because of the way the debugger interface to the Perl core is designed, any
debugger package globals that C<DB::sub()> requires have to be defined before
any subroutines can be called. These are defined in the second C<BEGIN> block.

This block sets things up so that (basically) the world is sane
before the debugger starts executing. We set up various variables that the
debugger has to have set up before the Perl core starts running:

=over 4

=item *

The debugger's own filehandles (copies of STD and STDOUT for now).

=item *

Characters for shell escapes, the recall command, and the history command.

=item *

The maximum recursion depth.

=item *

The size of a C<w> command's window.

=item *

The before-this-line context to be printed in a C<v> (view a window around this line) command.

=item *

The fact that we're not in a sub at all right now.

=item *

The default SIGINT handler for the debugger.

=item *

The appropriate value of the flag in C<$^D> that says the debugger is running

=item *

The current debugger recursion level

=item *

The list of postponed items and the C<$single> stack (XXX define this)

=item *

That we want no return values and no subroutine entry/exit trace.

=back

=cut

# The following BEGIN is very handy if debugger goes havoc, debugging debugger?

use vars qw($db_stop);

BEGIN {    # This does not compile, alas. (XXX eh?)
    $IN  = \*STDIN;     # For bugs before DB::OUT has been opened
    $OUT = \*STDERR;    # For errors before DB::OUT has been opened

    # Define characters used by command parsing.
    $sh       = '!';      # Shell escape (does not work)
    $rc       = ',';      # Recall command (does not work)
    @@hist     = ('?');    # Show history (does not work)
    @@truehist = ();       # Can be saved for replay (per session)

    # This defines the point at which you get the 'deep recursion'
    # warning. It MUST be defined or the debugger will not load.
    $deep = 1000;

    # Number of lines around the current one that are shown in the
    # 'w' command.
    $window = 10;

    # How much before-the-current-line context the 'v' command should
    # use in calculating the start of the window it will display.
    $preview = 3;

    # We're not in any sub yet, but we need this to be a defined value.
    $sub = '';

    # Set up the debugger's interrupt handler. It simply sets a flag
    # ($signal) that DB::DB() will check before each command is executed.
    $SIG{INT} = \&DB::catch;

    # The following lines supposedly, if uncommented, allow the debugger to
    # debug itself. Perhaps we can try that someday.
    # This may be enabled to debug debugger:
    #$warnLevel = 1 unless defined $warnLevel;
    #$dieLevel = 1 unless defined $dieLevel;
    #$signalLevel = 1 unless defined $signalLevel;

    # This is the flag that says "a debugger is running, please call
    # DB::DB and DB::sub". We will turn it on forcibly before we try to
    # execute anything in the user's context, because we always want to
    # get control back.
    $db_stop = 0;          # Compiler warning ...
    $db_stop = 1 << 30;    # ... because this is only used in an eval() later.

    # This variable records how many levels we're nested in debugging. Used
    # Used in the debugger prompt, and in determining whether it's all over or
    # not.
    $level = 0;            # Level of recursive debugging

    # "Triggers bug (?) in perl if we postpone this until runtime."
    # XXX No details on this yet, or whether we should fix the bug instead
    # of work around it. Stay tuned.
    @@stack = (0);

    # Used to track the current stack depth using the auto-stacked-variable
    # trick.
    $stack_depth = 0;      # Localized repeatedly; simple way to track $#stack

    # Don't print return values on exiting a subroutine.
    $doret = -2;

    # No extry/exit tracing.
    $frame = 0;

} ## end BEGIN

BEGIN { $^W = $ini_warn; }    # Switch warnings back

=head1 READLINE SUPPORT - COMPLETION FUNCTION

=head2 db_complete

C<readline> support - adds command completion to basic C<readline>.

Returns a list of possible completions to C<readline> when invoked. C<readline>
will print the longest common substring following the text already entered.

If there is only a single possible completion, C<readline> will use it in full.

This code uses C<map> and C<grep> heavily to create lists of possible
completion. Think LISP in this section.

=cut

sub db_complete {

    # Specific code for b c l V m f O, &blah, $blah, @@blah, %blah
    # $text is the text to be completed.
    # $line is the incoming line typed by the user.
    # $start is the start of the text to be completed in the incoming line.
    my ( $text, $line, $start ) = @@_;

    # Save the initial text.
    # The search pattern is current package, ::, extract the next qualifier
    # Prefix and pack are set to undef.
    my ( $itext, $search, $prefix, $pack ) =
      ( $text, "^\Q${package}::\E([^:]+)\$" );

=head3 C<b postpone|compile>

=over 4

=item *

Find all the subroutines that might match in this package

=item *

Add C<postpone>, C<load>, and C<compile> as possibles (we may be completing the keyword itself)

=item *

Include all the rest of the subs that are known

=item *

C<grep> out the ones that match the text we have so far

=item *

Return this as the list of possible completions

=back

=cut

    return sort grep /^\Q$text/, ( keys %sub ),
      qw(postpone load compile),    # subroutines
      ( map { /$search/ ? ($1) : () } keys %sub )
      if ( substr $line, 0, $start ) =~ /^\|*[blc]\s+((postpone|compile)\s+)?$/;

=head3 C<b load>

Get all the possible files from C<@@INC> as it currently stands and
select the ones that match the text so far.

=cut

    return sort grep /^\Q$text/, values %INC    # files
      if ( substr $line, 0, $start ) =~ /^\|*b\s+load\s+$/;

=head3  C<V> (list variable) and C<m> (list modules)

There are two entry points for these commands:

=head4 Unqualified package names

Get the top-level packages and grab everything that matches the text
so far. For each match, recursively complete the partial packages to
get all possible matching packages. Return this sorted list.

=cut

    return sort map { ( $_, db_complete( $_ . "::", "V ", 2 ) ) }
      grep /^\Q$text/, map { /^(.*)::$/ ? ($1) : () } keys %::    # top-packages
      if ( substr $line, 0, $start ) =~ /^\|*[Vm]\s+$/ and $text =~ /^\w*$/;

=head4 Qualified package names

Take a partially-qualified package and find all subpackages for it
by getting all the subpackages for the package so far, matching all
the subpackages against the text, and discarding all of them which
start with 'main::'. Return this list.

=cut

    return sort map { ( $_, db_complete( $_ . "::", "V ", 2 ) ) }
      grep !/^main::/, grep /^\Q$text/,
      map { /^(.*)::$/ ? ( $prefix . "::$1" ) : () }
      do { no strict 'refs'; keys %{ $prefix . '::' } }
      if ( substr $line, 0, $start ) =~ /^\|*[Vm]\s+$/
      and $text =~ /^(.*[^:])::?(\w*)$/
      and $prefix = $1;

=head3 C<f> - switch files

Here, we want to get a fully-qualified filename for the C<f> command.
Possibilities are:

=over 4

=item 1. The original source file itself

=item 2. A file from C<@@INC>

=item 3. An C<eval> (the debugger gets a C<(eval N)> fake file for each C<eval>).

=back

=cut

    if ( $line =~ /^\|*f\s+(.*)/ ) {    # Loaded files
           # We might possibly want to switch to an eval (which has a "filename"
           # like '(eval 9)'), so we may need to clean up the completion text
           # before proceeding.
        $prefix = length($1) - length($text);
        $text   = $1;

=pod

Under the debugger, source files are represented as C<_E<lt>/fullpath/to/file>
(C<eval>s are C<_E<lt>(eval NNN)>) keys in C<%main::>. We pull all of these
out of C<%main::>, add the initial source file, and extract the ones that
match the completion text so far.

=cut

        return sort
          map { substr $_, 2 + $prefix } grep /^_<\Q$text/, ( keys %main:: ),
          $0;
    } ## end if ($line =~ /^\|*f\s+(.*)/)

=head3 Subroutine name completion

We look through all of the defined subs (the keys of C<%sub>) and
return both all the possible matches to the subroutine name plus
all the matches qualified to the current package.

=cut

    if ( ( substr $text, 0, 1 ) eq '&' ) {    # subroutines
        $text = substr $text, 1;
        $prefix = "&";
        return sort map "$prefix$_", grep /^\Q$text/, ( keys %sub ),
          (
            map { /$search/ ? ($1) : () }
              keys %sub
          );
    } ## end if ((substr $text, 0, ...

=head3  Scalar, array, and hash completion: partially qualified package

Much like the above, except we have to do a little more cleanup:

=cut

    if ( $text =~ /^[\$@@%](.*)::(.*)/ ) {    # symbols in a package

=pod

=over 4

=item *

Determine the package that the symbol is in. Put it in C<::> (effectively C<main::>) if no package is specified.

=cut

        $pack = ( $1 eq 'main' ? '' : $1 ) . '::';

=pod

=item *

Figure out the prefix vs. what needs completing.

=cut

        $prefix = ( substr $text, 0, 1 ) . $1 . '::';
        $text   = $2;

=pod

=item *

Look through all the symbols in the package. C<grep> out all the possible hashes/arrays/scalars, and then C<grep> the possible matches out of those. C<map> the prefix onto all the possibilities.

=cut

        my @@out = do {
            no strict 'refs';
            map "$prefix$_", grep /^\Q$text/, grep /^_?[a-zA-Z]/,
            keys %$pack;
        };

=pod

=item *

If there's only one hit, and it's a package qualifier, and it's not equal to the initial text, re-complete it using the symbol we actually found.

=cut

        if ( @@out == 1 and $out[0] =~ /::$/ and $out[0] ne $itext ) {
            return db_complete( $out[0], $line, $start );
        }

        # Return the list of possibles.
        return sort @@out;

    } ## end if ($text =~ /^[\$@@%](.*)::(.*)/)

=pod

=back

=head3 Symbol completion: current package or package C<main>.

=cut

    if ( $text =~ /^[\$@@%]/ ) {    # symbols (in $package + packages in main)
=pod

=over 4

=item *

If it's C<main>, delete main to just get C<::> leading.

=cut

        $pack = ( $package eq 'main' ? '' : $package ) . '::';

=pod

=item *

We set the prefix to the item's sigil, and trim off the sigil to get the text to be completed.

=cut

        $prefix = substr $text, 0, 1;
        $text   = substr $text, 1;

        my @@out;

=pod

=item *

We look for the lexical scope above DB::DB and auto-complete lexical variables
if PadWalker could be loaded.

=cut

        if (not $text =~ /::/ and eval {
            local @@INC = @@INC;
            pop @@INC if $INC[-1] eq '.';
            require PadWalker } ) {
            my $level = 1;
            while (1) {
                my @@info = caller($level);
                $level++;
                $level = -1, last
                  if not @@info;
                last if $info[3] eq 'DB::DB';
            }
            if ($level > 0) {
                my $lexicals = PadWalker::peek_my($level);
                push @@out, grep /^\Q$prefix$text/, keys %$lexicals;
            }
        }

=pod

=item *

If the package is C<::> (C<main>), create an empty list; if it's something else, create a list of all the packages known.  Append whichever list to a list of all the possible symbols in the current package. C<grep> out the matches to the text entered so far, then C<map> the prefix back onto the symbols.

=cut

        push @@out, map "$prefix$_", grep /^\Q$text/,
          ( grep /^_?[a-zA-Z]/, do { no strict 'refs'; keys %$pack } ),
          ( $pack eq '::' ? () : ( grep /::$/, keys %:: ) );

=item *

If there's only one hit, it's a package qualifier, and it's not equal to the initial text, recomplete using this symbol.

=back

=cut

        if ( @@out == 1 and $out[0] =~ /::$/ and $out[0] ne $itext ) {
            return db_complete( $out[0], $line, $start );
        }

        # Return the list of possibles.
        return sort @@out;
    } ## end if ($text =~ /^[\$@@%]/)

=head3 Options

We use C<option_val()> to look up the current value of the option. If there's
only a single value, we complete the command in such a way that it is a
complete command for setting the option in question. If there are multiple
possible values, we generate a command consisting of the option plus a trailing
question mark, which, if executed, will list the current value of the option.

=cut

    if ( ( substr $line, 0, $start ) =~ /^\|*[oO]\b.*\s$/ )
    {    # Options after space
           # We look for the text to be matched in the list of possible options,
           # and fetch the current value.
        my @@out = grep /^\Q$text/, @@options;
        my $val = option_val( $out[0], undef );

        # Set up a 'query option's value' command.
        my $out = '? ';
        if ( not defined $val or $val =~ /[\n\r]/ ) {

            # There's really nothing else we can do.
        }

        # We have a value. Create a proper option-setting command.
        elsif ( $val =~ /\s/ ) {

            # XXX This may be an extraneous variable.
            my $found;

            # We'll want to quote the string (because of the embedded
            # whtespace), but we want to make sure we don't end up with
            # mismatched quote characters. We try several possibilities.
            foreach my $l ( split //, qq/\"\'\#\|/ ) {

                # If we didn't find this quote character in the value,
                # quote it using this quote character.
                $out = "$l$val$l ", last if ( index $val, $l ) == -1;
            }
        } ## end elsif ($val =~ /\s/)

        # Don't need any quotes.
        else {
            $out = "=$val ";
        }

        # If there were multiple possible values, return '? ', which
        # makes the command into a query command. If there was just one,
        # have readline append that.
        $rl_attribs->{completer_terminator_character} =
          ( @@out == 1 ? $out : '? ' );

        # Return list of possibilities.
        return sort @@out;
    } ## end if ((substr $line, 0, ...

=head3 Filename completion

For entering filenames. We simply call C<readline>'s C<filename_list()>
method with the completion text to get the possible completions.

=cut

    return $term->filename_list($text);    # filenames

} ## end sub db_complete

=head1 MISCELLANEOUS SUPPORT FUNCTIONS

Functions that possibly ought to be somewhere else.

=head2 end_report

Say we're done.

=cut

sub end_report {
    local $\ = '';
    print $OUT "Use 'q' to quit or 'R' to restart.  'h q' for details.\n";
}

=head2 clean_ENV

If we have $ini_pids, save it in the environment; else remove it from the
environment. Used by the C<R> (restart) command.

=cut

sub clean_ENV {
    if ( defined($ini_pids) ) {
        $ENV{PERLDB_PIDS} = $ini_pids;
    }
    else {
        delete( $ENV{PERLDB_PIDS} );
    }
} ## end sub clean_ENV

# PERLDBf_... flag names from perl.h
our ( %DollarCaretP_flags, %DollarCaretP_flags_r );

BEGIN {
    %DollarCaretP_flags = (
        PERLDBf_SUB       => 0x01,     # Debug sub enter/exit
        PERLDBf_LINE      => 0x02,     # Keep line #
        PERLDBf_NOOPT     => 0x04,     # Switch off optimizations
        PERLDBf_INTER     => 0x08,     # Preserve more data
        PERLDBf_SUBLINE   => 0x10,     # Keep subr source lines
        PERLDBf_SINGLE    => 0x20,     # Start with single-step on
        PERLDBf_NONAME    => 0x40,     # For _SUB: no name of the subr
        PERLDBf_GOTO      => 0x80,     # Report goto: call DB::goto
        PERLDBf_NAMEEVAL  => 0x100,    # Informative names for evals
        PERLDBf_NAMEANON  => 0x200,    # Informative names for anon subs
        PERLDBf_SAVESRC   => 0x400,    # Save source lines into @@{"_<$filename"}
        PERLDB_ALL        => 0x33f,    # No _NONAME, _GOTO
    );
    # PERLDBf_LINE also enables the actions of PERLDBf_SAVESRC, so the debugger
    # doesn't need to set it. It's provided for the benefit of profilers and
    # other code analysers.

    %DollarCaretP_flags_r = reverse %DollarCaretP_flags;
}

sub parse_DollarCaretP_flags {
    my $flags = shift;
    $flags =~ s/^\s+//;
    $flags =~ s/\s+$//;
    my $acu = 0;
    foreach my $f ( split /\s*\|\s*/, $flags ) {
        my $value;
        if ( $f =~ /^0x([[:xdigit:]]+)$/ ) {
            $value = hex $1;
        }
        elsif ( $f =~ /^(\d+)$/ ) {
            $value = int $1;
        }
        elsif ( $f =~ /^DEFAULT$/i ) {
            $value = $DollarCaretP_flags{PERLDB_ALL};
        }
        else {
            $f =~ /^(?:PERLDBf_)?(.*)$/i;
            $value = $DollarCaretP_flags{ 'PERLDBf_' . uc($1) };
            unless ( defined $value ) {
                print $OUT (
                    "Unrecognized \$^P flag '$f'!\n",
                    "Acceptable flags are: "
                      . join( ', ', sort keys %DollarCaretP_flags ),
                    ", and hexadecimal and decimal numbers.\n"
                );
                return undef;
            }
        }
        $acu |= $value;
    }
    $acu;
}

sub expand_DollarCaretP_flags {
    my $DollarCaretP = shift;
    my @@bits         = (
        map {
            my $n = ( 1 << $_ );
            ( $DollarCaretP & $n )
              ? ( $DollarCaretP_flags_r{$n}
                  || sprintf( '0x%x', $n ) )
              : ()
          } 0 .. 31
    );
    return @@bits ? join( '|', @@bits ) : 0;
}

=over 4

=item rerun

Rerun the current session to:

    rerun        current position

    rerun 4      command number 4

    rerun -4     current command minus 4 (go back 4 steps)

Whether this always makes sense, in the current context is unknowable, and is
in part left as a useful exercise for the reader.  This sub returns the
appropriate arguments to rerun the current session.

=cut

sub rerun {
    my $i = shift;
    my @@args;
    pop(@@truehist);                      # strim
    unless (defined $truehist[$i]) {
        print "Unable to return to non-existent command: $i\n";
    } else {
        $#truehist = ($i < 0 ? $#truehist + $i : $i > 0 ? $i : $#truehist);
        my @@temp = @@truehist;            # store
        push(@@DB::typeahead, @@truehist); # saved
        @@truehist = @@hist = ();          # flush
        @@args = restart();              # setup
        get_list("PERLDB_HIST");        # clean
        set_list("PERLDB_HIST", @@temp); # reset
    }
    return @@args;
}

=item restart

Restarting the debugger is a complex operation that occurs in several phases.
First, we try to reconstruct the command line that was used to invoke Perl
and the debugger.

=cut

sub restart {
    # I may not be able to resurrect you, but here goes ...
    print $OUT
"Warning: some settings and command-line options may be lost!\n";
    my ( @@script, @@flags, $cl );

    # If warn was on before, turn it on again.
    push @@flags, '-w' if $ini_warn;

    # Rebuild the -I flags that were on the initial
    # command line.
    for (@@ini_INC) {
        push @@flags, '-I', $_;
    }

    # Turn on taint if it was on before.
    push @@flags, '-T' if ${^TAINT};

    # Arrange for setting the old INC:
    # Save the current @@init_INC in the environment.
    set_list( "PERLDB_INC", @@ini_INC );

    # If this was a perl one-liner, go to the "file"
    # corresponding to the one-liner read all the lines
    # out of it (except for the first one, which is going
    # to be added back on again when 'perl -d' runs: that's
    # the 'require perl5db.pl;' line), and add them back on
    # to the command line to be executed.
    if ( $0 eq '-e' ) {
        my $lines = *{$main::{'_<-e'}}{ARRAY};
        for ( 1 .. $#$lines ) {  # The first line is PERL5DB
            chomp( $cl = $lines->[$_] );
            push @@script, '-e', $cl;
        }
    } ## end if ($0 eq '-e')

    # Otherwise we just reuse the original name we had
    # before.
    else {
        @@script = $0;
    }

=pod

After the command line  has been reconstructed, the next step is to save
the debugger's status in environment variables. The C<DB::set_list> routine
is used to save aggregate variables (both hashes and arrays); scalars are
just popped into environment variables directly.

=cut

    # If the terminal supported history, grab it and
    # save that in the environment.
    set_list( "PERLDB_HIST",
          $term->Features->{getHistory}
        ? $term->GetHistory
        : @@hist );

    # Find all the files that were visited during this
    # session (i.e., the debugger had magic hashes
    # corresponding to them) and stick them in the environment.
    my @@had_breakpoints = keys %had_breakpoints;
    set_list( "PERLDB_VISITED", @@had_breakpoints );

    # Save the debugger options we chose.
    set_list( "PERLDB_OPT", %option );
    # set_list( "PERLDB_OPT", options2remember() );

    # Save the break-on-loads.
    set_list( "PERLDB_ON_LOAD", %break_on_load );

=pod

The most complex part of this is the saving of all of the breakpoints. They
can live in an awful lot of places, and we have to go through all of them,
find the breakpoints, and then save them in the appropriate environment
variable via C<DB::set_list>.

=cut

    # Go through all the breakpoints and make sure they're
    # still valid.
    my @@hard;
    for ( 0 .. $#had_breakpoints ) {

        # We were in this file.
        my $file = $had_breakpoints[$_];

        # Grab that file's magic line hash.
        *dbline = $main::{ '_<' . $file };

        # Skip out if it doesn't exist, or if the breakpoint
        # is in a postponed file (we'll do postponed ones
        # later).
        next unless %dbline or $postponed_file{$file};

        # In an eval. This is a little harder, so we'll
        # do more processing on that below.
        ( push @@hard, $file ), next
          if $file =~ /^\(\w*eval/;

        # XXX I have no idea what this is doing. Yet.
        my @@add;
        @@add = %{ $postponed_file{$file} }
          if $postponed_file{$file};

        # Save the list of all the breakpoints for this file.
        set_list( "PERLDB_FILE_$_", %dbline, @@add );

        # Serialize the extra data %breakpoints_data hash.
        # That's a bug fix.
        set_list( "PERLDB_FILE_ENABLED_$_",
            map { _is_breakpoint_enabled($file, $_) ? 1 : 0 }
            sort { $a <=> $b } keys(%dbline)
        )
    } ## end for (0 .. $#had_breakpoints)

    # The breakpoint was inside an eval. This is a little
    # more difficult. XXX and I don't understand it.
    foreach my $hard_file (@@hard) {
        # Get over to the eval in question.
        *dbline = $main::{ '_<' . $hard_file };
        my $quoted = quotemeta $hard_file;
        my %subs;
        for my $sub ( keys %sub ) {
            if (my ($n1, $n2) = $sub{$sub} =~ /\A$quoted:(\d+)-(\d+)\z/) {
                $subs{$sub} = [ $n1, $n2 ];
            }
        }
        unless (%subs) {
            print {$OUT}
            "No subroutines in $hard_file, ignoring breakpoints.\n";
            next;
        }
        LINES: foreach my $line ( keys %dbline ) {

            # One breakpoint per sub only:
            my ( $offset, $found );
            SUBS: foreach my $sub ( keys %subs ) {
                if (
                    $subs{$sub}->[1] >= $line    # Not after the subroutine
                    and (
                        not defined $offset    # Not caught
                            or $offset < 0
                    )
                )
                {                              # or badly caught
                    $found  = $sub;
                    $offset = $line - $subs{$sub}->[0];
                    if ($offset >= 0) {
                        $offset = "+$offset";
                        last SUBS;
                    }
                } ## end if ($subs{$sub}->[1] >=...
            } ## end for $sub (keys %subs)
            if ( defined $offset ) {
                $postponed{$found} =
                "break $offset if $dbline{$line}";
            }
            else {
                print {$OUT}
                ("Breakpoint in ${hard_file}:$line ignored:"
                . " after all the subroutines.\n");
            }
        } ## end for $line (keys %dbline)
    } ## end for (@@hard)

    # Save the other things that don't need to be
    # processed.
    set_list( "PERLDB_POSTPONE",  %postponed );
    set_list( "PERLDB_PRETYPE",   @@$pretype );
    set_list( "PERLDB_PRE",       @@$pre );
    set_list( "PERLDB_POST",      @@$post );
    set_list( "PERLDB_TYPEAHEAD", @@typeahead );

    # We are officially restarting.
    $ENV{PERLDB_RESTART} = 1;

    # We are junking all child debuggers.
    delete $ENV{PERLDB_PIDS};    # Restore ini state

    # Set this back to the initial pid.
    $ENV{PERLDB_PIDS} = $ini_pids if defined $ini_pids;

=pod

After all the debugger status has been saved, we take the command we built up
and then return it, so we can C<exec()> it. The debugger will spot the
C<PERLDB_RESTART> environment variable and realize it needs to reload its state
from the environment.

=cut

    # And run Perl again. Add the "-d" flag, all the
    # flags we built up, the script (whether a one-liner
    # or a file), add on the -emacs flag for a slave editor,
    # and then the old arguments.

    return ($^X, '-d', @@flags, @@script, ($slave_editor ? '-emacs' : ()), @@ARGS);

};  # end restart

=back

=head1 END PROCESSING - THE C<END> BLOCK

Come here at the very end of processing. We want to go into a
loop where we allow the user to enter commands and interact with the
debugger, but we don't want anything else to execute.

First we set the C<$finished> variable, so that some commands that
shouldn't be run after the end of program quit working.

We then figure out whether we're truly done (as in the user entered a C<q>
command, or we finished execution while running nonstop). If we aren't,
we set C<$single> to 1 (causing the debugger to get control again).

We then call C<DB::fake::at_exit()>, which returns the C<Use 'q' to quit ...>
message and returns control to the debugger. Repeat.

When the user finally enters a C<q> command, C<$fall_off_end> is set to
1 and the C<END> block simply exits with C<$single> set to 0 (don't
break, run to completion.).

=cut

END {
    $finished = 1 if $inhibit_exit;    # So that some commands may be disabled.
    $fall_off_end = 1 unless $inhibit_exit;

    # Do not stop in at_exit() and destructors on exit:
    if ($fall_off_end or $runnonstop) {
        save_hist();
    } else {
        $DB::single = 1;
        DB::fake::at_exit();
    }
} ## end END

=head1 PRE-5.8 COMMANDS

Some of the commands changed function quite a bit in the 5.8 command
realignment, so much so that the old code had to be replaced completely.
Because we wanted to retain the option of being able to go back to the
former command set, we moved the old code off to this section.

There's an awful lot of duplicated code here. We've duplicated the
comments to keep things clear.

=head2 Null command

Does nothing. Used to I<turn off> commands.

=cut

sub cmd_pre580_null {

    # do nothing...
}

=head2 Old C<a> command.

This version added actions if you supplied them, and deleted them
if you didn't.

=cut

sub cmd_pre580_a {
    my $xcmd = shift;
    my $cmd  = shift;

    # Argument supplied. Add the action.
    if ( $cmd =~ /^(\d*)\s*(.*)/ ) {

        # If the line isn't there, use the current line.
        my $i = $1 || $line;
        my $j = $2;

        # If there is an action ...
        if ( length $j ) {

            # ... but the line isn't breakable, skip it.
            if ( $dbline[$i] == 0 ) {
                print $OUT "Line $i may not have an action.\n";
            }
            else {

                # ... and the line is breakable:
                # Mark that there's an action in this file.
                $had_breakpoints{$filename} |= 2;

                # Delete any current action.
                $dbline{$i} =~ s/\0[^\0]*//;

                # Add the new action, continuing the line as needed.
                $dbline{$i} .= "\0" . action($j);
            }
        } ## end if (length $j)

        # No action supplied.
        else {

            # Delete the action.
            $dbline{$i} =~ s/\0[^\0]*//;

            # Mark as having no break or action if nothing's left.
            delete $dbline{$i} if $dbline{$i} eq '';
        }
    } ## end if ($cmd =~ /^(\d*)\s*(.*)/)
} ## end sub cmd_pre580_a

=head2 Old C<b> command

Add breakpoints.

=cut

sub cmd_pre580_b {
    my $xcmd   = shift;
    my $cmd    = shift;
    my $dbline = shift;

    # Break on load.
    if ( $cmd =~ /^load\b\s*(.*)/ ) {
        my $file = $1;
        $file =~ s/\s+$//;
        cmd_b_load($file);
    }

    # b compile|postpone <some sub> [<condition>]
    # The interpreter actually traps this one for us; we just put the
    # necessary condition in the %postponed hash.
    elsif ( $cmd =~ /^(postpone|compile)\b\s*([':A-Za-z_][':\w]*)\s*(.*)/ ) {

        # Capture the condition if there is one. Make it true if none.
        my $cond = length $3 ? $3 : '1';

        # Save the sub name and set $break to 1 if $1 was 'postpone', 0
        # if it was 'compile'.
        my ( $subname, $break ) = ( $2, $1 eq 'postpone' );

        # De-Perl4-ify the name - ' separators to ::.
        $subname =~ s/\'/::/g;

        # Qualify it into the current package unless it's already qualified.
        $subname = "${package}::" . $subname
          unless $subname =~ /::/;

        # Add main if it starts with ::.
        $subname = "main" . $subname if substr( $subname, 0, 2 ) eq "::";

        # Save the break type for this sub.
        $postponed{$subname} = $break ? "break +0 if $cond" : "compile";
    } ## end elsif ($cmd =~ ...

    # b <sub name> [<condition>]
    elsif ( $cmd =~ /^([':A-Za-z_][':\w]*(?:\[.*\])?)\s*(.*)/ ) {
        my $subname = $1;
        my $cond = length $2 ? $2 : '1';
        cmd_b_sub( $subname, $cond );
    }
    # b <line> [<condition>].
    elsif ( $cmd =~ /^(\d*)\s*(.*)/ ) {
        my $i = $1 || $dbline;
        my $cond = length $2 ? $2 : '1';
        cmd_b_line( $i, $cond );
    }
} ## end sub cmd_pre580_b

=head2 Old C<D> command.

Delete all breakpoints unconditionally.

=cut

sub cmd_pre580_D {
    my $xcmd = shift;
    my $cmd  = shift;
    if ( $cmd =~ /^\s*$/ ) {
        print $OUT "Deleting all breakpoints...\n";

        # %had_breakpoints lists every file that had at least one
        # breakpoint in it.
        my $file;
        for $file ( keys %had_breakpoints ) {

            # Switch to the desired file temporarily.
            local *dbline = $main::{ '_<' . $file };

            $max = $#dbline;
            my $was;

            # For all lines in this file ...
            for my $i (1 .. $max) {

                # If there's a breakpoint or action on this line ...
                if ( defined $dbline{$i} ) {

                    # ... remove the breakpoint.
                    $dbline{$i} =~ s/^[^\0]+//;
                    if ( $dbline{$i} =~ s/^\0?$// ) {

                        # Remove the entry altogether if no action is there.
                        delete $dbline{$i};
                    }
                } ## end if (defined $dbline{$i...
            } ## end for my $i (1 .. $max)

            # If, after we turn off the "there were breakpoints in this file"
            # bit, the entry in %had_breakpoints for this file is zero,
            # we should remove this file from the hash.
            if ( not $had_breakpoints{$file} &= ~1 ) {
                delete $had_breakpoints{$file};
            }
        } ## end for $file (keys %had_breakpoints)

        # Kill off all the other breakpoints that are waiting for files that
        # haven't been loaded yet.
        undef %postponed;
        undef %postponed_file;
        undef %break_on_load;
    } ## end if ($cmd =~ /^\s*$/)
} ## end sub cmd_pre580_D

=head2 Old C<h> command

Print help. Defaults to printing the long-form help; the 5.8 version
prints the summary by default.

=cut

sub cmd_pre580_h {
    my $xcmd = shift;
    my $cmd  = shift;

    # Print the *right* help, long format.
    if ( $cmd =~ /^\s*$/ ) {
        print_help($pre580_help);
    }

    # 'h h' - explicitly-requested summary.
    elsif ( $cmd =~ /^h\s*/ ) {
        print_help($pre580_summary);
    }

    # Find and print a command's help.
    elsif ( $cmd =~ /^h\s+(\S.*)$/ ) {
        my $asked  = $1;                   # for proper errmsg
        my $qasked = quotemeta($asked);    # for searching
                                           # XXX: finds CR but not <CR>
        if (
            $pre580_help =~ /^
                              <?           # Optional '<'
                              (?:[IB]<)    # Optional markup
                              $qasked      # The command name
                            /mx
          )
        {

            while (
                $pre580_help =~ /^
                                  (             # The command help:
                                   <?           # Optional '<'
                                   (?:[IB]<)    # Optional markup
                                   $qasked      # The command name
                                   ([\s\S]*?)   # Lines starting with tabs
                                   \n           # Final newline
                                  )
                                  (?!\s)/mgx
              )    # Line not starting with space
                   # (Next command's help)
            {
                print_help($1);
            }
        } ## end if ($pre580_help =~ /^<?(?:[IB]<)$qasked/m)

        # Help not found.
        else {
            print_help("B<$asked> is not a debugger command.\n");
        }
    } ## end elsif ($cmd =~ /^h\s+(\S.*)$/)
} ## end sub cmd_pre580_h

=head2 Old C<W> command

C<W E<lt>exprE<gt>> adds a watch expression, C<W> deletes them all.

=cut

sub cmd_pre580_W {
    my $xcmd = shift;
    my $cmd  = shift;

    # Delete all watch expressions.
    if ( $cmd =~ /^$/ ) {

        # No watching is going on.
        $trace &= ~2;

        # Kill all the watch expressions and values.
        @@to_watch = @@old_watch = ();
    }

    # Add a watch expression.
    elsif ( $cmd =~ /^(.*)/s ) {

        # add it to the list to be watched.
        push @@to_watch, $1;

        # Get the current value of the expression.
        # Doesn't handle expressions returning list values!
        $evalarg = $1;
        # The &-call is here to ascertain the mutability of @@_.
        my ($val) = &DB::eval;
        $val = ( defined $val ) ? "'$val'" : 'undef';

        # Save it.
        push @@old_watch, $val;

        # We're watching stuff.
        $trace |= 2;

    } ## end elsif ($cmd =~ /^(.*)/s)
} ## end sub cmd_pre580_W

=head1 PRE-AND-POST-PROMPT COMMANDS AND ACTIONS

The debugger used to have a bunch of nearly-identical code to handle
the pre-and-post-prompt action commands. C<cmd_pre590_prepost> and
C<cmd_prepost> unify all this into one set of code to handle the
appropriate actions.

=head2 C<cmd_pre590_prepost>

A small wrapper around C<cmd_prepost>; it makes sure that the default doesn't
do something destructive. In pre 5.8 debuggers, the default action was to
delete all the actions.

=cut

sub cmd_pre590_prepost {
    my $cmd    = shift;
    my $line   = shift || '*';
    my $dbline = shift;

    return cmd_prepost( $cmd, $line, $dbline );
} ## end sub cmd_pre590_prepost

=head2 C<cmd_prepost>

Actually does all the handling for C<E<lt>>, C<E<gt>>, C<{{>, C<{>, etc.
Since the lists of actions are all held in arrays that are pointed to by
references anyway, all we have to do is pick the right array reference and
then use generic code to all, delete, or list actions.

=cut

sub cmd_prepost {
    my $cmd = shift;

    # No action supplied defaults to 'list'.
    my $line = shift || '?';

    # Figure out what to put in the prompt.
    my $which = '';

    # Make sure we have some array or another to address later.
    # This means that if for some reason the tests fail, we won't be
    # trying to stash actions or delete them from the wrong place.
    my $aref = [];

    # < - Perl code to run before prompt.
    if ( $cmd =~ /^\</o ) {
        $which = 'pre-perl';
        $aref  = $pre;
    }

    # > - Perl code to run after prompt.
    elsif ( $cmd =~ /^\>/o ) {
        $which = 'post-perl';
        $aref  = $post;
    }

    # { - first check for properly-balanced braces.
    elsif ( $cmd =~ /^\{/o ) {
        if ( $cmd =~ /^\{.*\}$/o && unbalanced( substr( $cmd, 1 ) ) ) {
            print $OUT
"$cmd is now a debugger command\nuse ';$cmd' if you mean Perl code\n";
        }

        # Properly balanced. Pre-prompt debugger actions.
        else {
            $which = 'pre-debugger';
            $aref  = $pretype;
        }
    } ## end elsif ( $cmd =~ /^\{/o )

    # Did we find something that makes sense?
    unless ($which) {
        print $OUT "Confused by command: $cmd\n";
    }

    # Yes.
    else {

        # List actions.
        if ( $line =~ /^\s*\?\s*$/o ) {
            unless (@@$aref) {

                # Nothing there. Complain.
                print $OUT "No $which actions.\n";
            }
            else {

                # List the actions in the selected list.
                print $OUT "$which commands:\n";
                foreach my $action (@@$aref) {
                    print $OUT "\t$cmd -- $action\n";
                }
            } ## end else
        } ## end if ( $line =~ /^\s*\?\s*$/o)

        # Might be a delete.
        else {
            if ( length($cmd) == 1 ) {
                if ( $line =~ /^\s*\*\s*$/o ) {

                    # It's a delete. Get rid of the old actions in the
                    # selected list..
                    @@$aref = ();
                    print $OUT "All $cmd actions cleared.\n";
                }
                else {

                    # Replace all the actions. (This is a <, >, or {).
                    @@$aref = action($line);
                }
            } ## end if ( length($cmd) == 1)
            elsif ( length($cmd) == 2 ) {

                # Add the action to the line. (This is a <<, >>, or {{).
                push @@$aref, action($line);
            }
            else {

                # <<<, >>>>, {{{{{{ ... something not a command.
                print $OUT
                  "Confused by strange length of $which command($cmd)...\n";
            }
        } ## end else [ if ( $line =~ /^\s*\?\s*$/o)
    } ## end else
} ## end sub cmd_prepost

=head1 C<DB::fake>

Contains the C<at_exit> routine that the debugger uses to issue the
C<Debugged program terminated ...> message after the program completes. See
the C<END> block documentation for more details.

=cut

package DB::fake;

sub at_exit {
    "Debugged program terminated.  Use 'q' to quit or 'R' to restart.";
}

package DB;    # Do not trace this 1; below!

1;


@


1.20
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.


ok deraadt@@
@
text
@d192 1
a192 1
like C<(eval 34).
d515 4
d525 1
d531 1
a531 1
$VERSION = '1.44_02';
d1340 3
d1551 8
d1563 6
d1570 2
a1571 3

        # everything else is ...
        $console = "sys\$command";
d1977 1
a1977 1
        my $h = eval { PadWalker::peek_my( ( $match_level || 0 ) + 1 ) };
d2285 7
d2509 5
a2513 1
my %cmd_lookup =
d2546 1
d3343 3
d6568 4
a6571 5
        # Turn high-bit characters into meta-whatever.
        s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;

        # Turn control characters into ^-whatever.
        s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
d6764 4
a6767 4
    open( SAVEIN,  "<&STDIN" )  || db_warn("Can't save STDIN");
    open( SAVEOUT, ">&STDOUT" ) || db_warn("Can't save STDOUT");
    open( STDIN,   "<&IN" )     || db_warn("Can't redirect STDIN");
    open( STDOUT,  ">&OUT" )    || db_warn("Can't redirect STDOUT");
d6771 2
a6772 2
    open( STDIN,  "<&SAVEIN" )  || db_warn("Can't restore STDIN");
    open( STDOUT, ">&SAVEOUT" ) || db_warn("Can't restore STDOUT");
d6778 1
a6778 1
        db_warn( "(Command exited ", ( $? >> 8 ), ")\n" );
d6781 1
a6781 1
        db_warn(
d7119 39
d7600 1
a7600 1
then as hexadecimal values.
d7616 3
a7618 1
        $val =~ s/([\0-\37\177\200-\377])/"\\0x" . unpack('H2',$1)/eg;
d8458 1
a8458 1
          ( \040{4} | \t )*     # some subcommands are indented
@


1.19
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d526 1
a526 1
$VERSION = '1.44_01';
d1933 4
a1936 1
        if (!eval { require PadWalker; PadWalker->VERSION(0.08) }) {
d9371 4
a9374 1
        if (not $text =~ /::/ and eval { require PadWalker } ) {
@


1.18
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d526 1
a526 1
$VERSION = '1.44';
d869 1
@


1.18.4.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d526 1
a526 1
$VERSION = '1.44_01';
d1932 1
a1932 4
        if (!eval {
            local @@INC = @@INC;
            pop @@INC if $INC[-1] eq '.';
            require PadWalker; PadWalker->VERSION(0.08) }) {
d9367 1
a9367 4
        if (not $text =~ /::/ and eval {
            local @@INC = @@INC;
            pop @@INC if $INC[-1] eq '.';
            require PadWalker } ) {
@


1.18.6.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d526 1
a526 1
$VERSION = '1.44_01';
d1932 1
a1932 4
        if (!eval {
            local @@INC = @@INC;
            pop @@INC if $INC[-1] eq '.';
            require PadWalker; PadWalker->VERSION(0.08) }) {
d9367 1
a9367 4
        if (not $text =~ /::/ and eval {
            local @@INC = @@INC;
            pop @@INC if $INC[-1] eq '.';
            require PadWalker } ) {
@


1.17
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d321 1
a321 1
=item * 16 - Adds C<I<context> return from I<subname>: I<value>> messages on subroutine/eval exit. Ignored if C<4> is is not on.
d526 1
a526 1
$VERSION = '1.39_10';
d1365 2
a1366 1
  PERLDB_POSTPONE  - subs that have been loaded/not executed, and have actions
d1826 1
a1826 1
    # ... and it belogs to this PID or we get one for this PID ...
d2102 1
a2102 1
            # Turn of warn and die procesing for a bit.
d2422 3
d2508 1
a2508 1
    qw(a A b B e E h i l L M o O P v w W)),
d2976 1
a2976 1
that the terminal supports history). It find the command required, puts it
d3154 1
a3154 1
# The following package declaraton must come before that,
a4099 3
    # Do not use a regex in this subroutine -> results in corrupted memory
    # See: [perl #66110]

d4272 3
a4274 1
    $single &= 1;
a4282 3
    # Pop the single-step value back off the stack.
    $single |= $stack[ $stack_depth-- ];

d6094 1
a6094 1
        #  a) we don't want to stop calling watchfunction() it it exists
d6149 5
a6153 1
    print $LINEINFO @@_;
d6433 1
a6433 1
        # Set the separator so arrys print nice.
a8904 133
my %_is_in_pods = (map { $_ => 1 }
    qw(
    5004delta
    5005delta
    561delta
    56delta
    570delta
    571delta
    572delta
    573delta
    58delta
    581delta
    582delta
    583delta
    584delta
    590delta
    591delta
    592delta
    aix
    amiga
    apio
    api
    artistic
    book
    boot
    bot
    bs2000
    call
    ce
    cheat
    clib
    cn
    compile
    cygwin
    data
    dbmfilter
    debguts
    debtut
    debug
    delta
    dgux
    diag
    doc
    dos
    dsc
    ebcdic
    embed
    faq1
    faq2
    faq3
    faq4
    faq5
    faq6
    faq7
    faq8
    faq9
    faq
    filter
    fork
    form
    freebsd
    func
    gpl
    guts
    hack
    hist
    hpux
    hurd
    intern
    intro
    iol
    ipc
    irix
    jp
    ko
    lexwarn
    locale
    lol
    macos
    macosx
    modinstall
    modlib
    mod
    modstyle
    netware
    newmod
    number
    obj
    opentut
    op
    os2
    os390
    os400
    packtut
    plan9
    pod
    podspec
    port
    qnx
    ref
    reftut
    re
    requick
    reref
    retut
    run
    sec
    solaris
    style
    sub
    syn
    thrtut
    tie
    toc
    todo
    tooc
    toot
    trap
    tru64
    tw
    unicode
    uniintro
    util
    uts
    var
    vms
    vos
    win32
    xs
    xstut
    )
);

d8922 2
a8923 2
    my $man1dir = $Config::Config{'man1dir'};
    my $man3dir = $Config::Config{'man3dir'};
d8931 1
a8931 2
    my $oldpath = $ENV{MANPATH};
    $ENV{MANPATH} = $manpath if $manpath;
d8944 15
a8958 2
# do it this way because its easier to slurp in to keep up to date - clunky though.
            if (exists($_is_in_pods{$page})) {
a8964 6
    if ( defined $oldpath ) {
        $ENV{MANPATH} = $manpath;
    }
    else {
        delete $ENV{MANPATH};
    }
d9045 1
a9045 1
    $deep = 100;
d9391 1
a9391 1
          ( grep /^_?[a-zA-Z]/, keys %$pack ),
d10192 1
a10192 1
    # This means that if ssome reason the tests fail, we won't be
@


1.16
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d2 1
a2 1
=head1 NAME 
d25 1
a25 1
features was done using global variables, globs and the C<local()> operator 
d37 1
a37 1
debugger itself.       
d49 1
a49 1
As you may recall from reading C<perlfunc>, the C<local()> operator makes a 
d51 1
a51 1
old copy is restored. This is often used in the debugger to handle the 
d62 1
a62 1
then altered. When the subroutine returns, Perl automatically undoes the 
d65 1
a65 1
The debugger uses this trick a I<lot>. Of particular note is C<DB::eval>, 
d69 1
a69 1
value of C<$@@> is restored. This makes it simple (well, I<simpler>) to keep 
d76 1
a76 1
This is used to cleverly reverse the sense of a logical test depending on 
d78 1
a78 1
(search for subroutines by pattern) allows you to negate the pattern 
d82 1
a82 1
   S !/foo/      
d88 1
a88 1
=item * 0 ^ 0 = 0 
d92 1
a92 1
=item * 0 ^ 1 = 1 
d96 1
a96 1
=item * 1 ^ 0 = 1 
d100 1
a100 1
=item * 1 ^ 1 = 0 
d108 1
a108 1
compact a more complicated if-then-elseif-else into a more elegant 
d117 1
a117 1
of state to be stored independently in a single scalar. 
d123 1
a123 1
is checking to see if the appropriate bit is on. Since each bit can be 
d125 1
a125 1
an array of bits. Obviously, since the contents of C<$scalar> are just a 
d130 1
a130 1
all over your program whenever a bit is set, cleared, or checked. So why do 
d140 1
a140 1
this over-optimization at the expense of readability? Possibly, but the 
d143 1
a143 1
best balance of readability and speed, and then document how it actually 
d148 1
a148 1
Second, it's very easy to serialize a scalar number. This is done in 
d151 1
a151 1
this trivial. 
d155 3
a157 3
Third, some of these variables are being shared with the Perl core 
smack in the middle of the interpreter's execution loop. It's much faster for 
a C program (like the interpreter) to check a bit in a scalar than to access 
d165 1
a165 1
speculative - it's not exactly clear what a given variable or chunk of 
d171 1
a171 1
=head1 DATA STRUCTURES MAINTAINED BY CORE         
d182 3
a184 3
The hash C<%{'_<'.$filename}> (aliased locally to C<%dbline> via glob 
assignment) contains breakpoints and actions.  The keys are line numbers; 
you can set individual values, but not the whole hash. The Perl interpreter 
d189 1
a189 1
The scalar C<${"_<$filename"}> simply contains the string C<_<$filename>.
d192 1
a192 1
like C<(eval 34)> or C<(re_eval 19)>.
d199 1
a199 1
that will be executed (in the debugger's context) after the debugger has 
d202 1
a202 1
Next, it checks the C<PERLDB_OPTS> environment variable and treats its 
d213 1
a213 1
=item * TTY 
d217 1
a217 1
=item * noTTY 
d224 1
a224 1
=item * ReadLine 
d229 1
a229 1
=item * NonStop 
d233 1
a233 1
=item * LineInfo 
d238 1
a238 1
=item * RemotePort 
d282 1
a282 1
used for input. 
d284 1
a284 1
=over   
d307 1
a307 1
is entered or exited. 
d331 2
a332 2
Tracks current debugger nesting level. Used to figure out how many 
C<E<lt>E<gt>> pairs to surround the line number with when the debugger 
d367 1
a367 1
=over 4 
d382 1
a382 1
Controls the output of trace information. 
d405 1
a405 1
Local alias to the magical line array, C<@@{$main::{'_<'.$filename}}> , 
d453 1
a453 1
=over 4 
d490 2
a491 2
package. This is because there are several BEGIN blocks (which of course 
execute immediately) spread through the code. Why is that? 
d493 1
a493 1
The debugger needs to be able to change some things and set some things up 
d503 1
a503 1
The third one puts C<$^X> back to its former value. 
d513 3
a515 1
BEGIN {eval 'use IO::Handle'};	# Needed for flush only? breaks under miniperl
d524 3
a526 1
$VERSION = '1.37';
d537 1
a537 1
The code to be evaluated is passed via the package global variable 
d548 2
a549 2
local lexical, localize C<$saved[0]> (which is where C<save()> will put 
C<$@@>), and then call C<save()> to capture C<$@@>, C<$!>, C<$^E>, C<$,>, 
d551 5
a555 5
considered sane by the debugger. If there was an C<eval()> error, we print 
it on the debugger's output. If C<$onetimedump> is defined, we call 
C<dumpit> if it's set to 'dump', or C<methods> if it's set to 
'methods'. Setting it to something else causes the debugger to do the eval 
but not print the result - handy if you want to do something else with it 
d559 2
a560 2
In any case, we then return the list of output from C<eval> to the caller, 
and unwinding restores the former version of C<$@@> in C<@@saved> as well 
d567 1
a567 1
The variables listed below influence C<DB::eval()>'s execution directly. 
d577 1
a577 1
=item C<$onetimeDump> - what is to be displayed after the evaluation 
d584 1
a584 1
are "stacked" via C<local()>, enabling recursive calls to C<DB::eval()>. 
d592 1
a592 1
=item C<$osingle> - saved value of C<$single>.      
d598 1
a598 1
=item $\ - for output of C<$@@> if there is an evaluation error.      
d607 1
a607 1
debugger globals are used. 
d627 82
d839 1
a839 1
	[tid] DB<$i>
d846 1
a846 1
will apply to all threads, not just the currently running one.  When you are 
d859 34
a892 45
  # ensure we can share our non-threaded variables or no-op
  if ($ENV{PERL5DB_THREADED}) {
	require threads;
	require threads::shared;
	import threads::shared qw(share);
	$DBGR;
	share(\$DBGR);
	lock($DBGR);
	print "Threads support enabled\n";
  } else {
	*lock  = sub(*) {};
	*share = sub(*) {};
  }
}

# This would probably be better done with "use vars", but that wasn't around
# when this code was originally written. (Neither was "use strict".) And on
# the principle of not fiddling with something that was working, this was
# left alone.
warn(               # Do not ;-)
    # These variables control the execution of 'dumpvar.pl'.
    $dumpvar::hashDepth,
    $dumpvar::arrayDepth,
    $dumpvar::dumpDBFiles,
    $dumpvar::dumpPackages,
    $dumpvar::quoteHighBit,
    $dumpvar::printUndef,
    $dumpvar::globPrint,
    $dumpvar::usageOnly,

    # used to save @@ARGV and extract any debugger-related flags.
    @@ARGS,

    # used to control die() reporting in diesignal()
    $Carp::CarpLevel,

    # used to prevent multiple entries to diesignal()
    # (if for instance diesignal() itself dies)
    $panic,

    # used to prevent the debugger from running nonstop
    # after a restart
    $second_time,
  )
  if 0;
d895 1
a895 3
foreach my $k (keys (%INC)) {
	&share(\$main::{'_<'.$filename}) if defined $filename;
};
d914 4
a917 2
# Default to 1 so the prompt will display the first line.
$trace_to_depth = 1;
d921 2
a922 2
The debugger's options are actually spread out over the debugger itself and 
C<dumpvar.pl>; some of these are variables to be set, while others are 
d958 2
d989 3
a991 1
=cut 
d1026 2
d1135 2
a1136 2
&recallCommand("!") unless defined $prc;
&shellBang("!")     unless defined $psh;
d1174 1
d1177 2
d1210 1
d1214 1
d1219 1
a1219 1
The debugger will read a file of initialization options if supplied. If    
d1222 1
a1222 1
=cut      
d1227 5
a1231 7
my $dev_tty = '/dev/tty';
   $dev_tty = 'TT:' if ($^O eq 'VMS');
if ( -e $dev_tty ) {                      # this is the wrong metric!
    $rcfile = ".perldb";
}
else {
    $rcfile = "perldb.ini";
d1258 1
a1258 1
        You or the superuser must be the owner, and it must not 
d1322 1
a1322 1
    if ( defined $remoteport ) {                 
d1362 1
a1362 1
  PERLDB_RESTART   - flag only, contains no restart data itself.       
d1380 1
a1380 1
if ( exists $ENV{PERLDB_RESTART} ) {
d1382 1
a1382 2
    # We're restarting, so we don't need the flag that says to restart anymore.
    delete $ENV{PERLDB_RESTART};
d1384 2
a1385 1
    # $restart = 1;
d1390 7
a1396 4
	share(@@hist);
	share(@@truehist);
	share(%break_on_load);
	share(%postponed);
a1397 1
    # restore breakpoints/actions
d1399 1
d1415 8
a1422 4
    # restore options
    my %opt = get_list("PERLDB_OPT");
    my ( $opt, $val );
    while ( ( $opt, $val ) = each %opt ) {
d1427 5
d1441 19
d1470 14
d1486 1
a1486 1
	share($runnonstop);
d1502 4
a1505 3
    $slave_editor =
      ( ( defined $main::ARGV[0] ) and ( $main::ARGV[0] eq '-emacs' ) );
    $rl = 0, shift(@@main::ARGV) if $slave_editor;
d1525 1
a1525 1
=item * Unix - use C</dev/tty>.
d1557 1
a1557 1
with a slave editor, Epoc).
a1579 5
    # EPOC also falls into the 'got to use STDIN' camp.
    if ( $^O eq 'epoc' ) {
        $console = undef;
    }

d1588 1
a1588 1
=head2 SOCKET HANDLING   
d1660 4
a1663 1
        $IN = \*IN, $OUT = \*OUT if $console or not defined $console;
d1667 1
a1667 3
    my $previous = select($OUT);
    $| = 1;                                  # for DB::OUT
    select($previous);
d1675 2
a1676 2
	# share($LINEINFO); # <- unable to share globs
	share($lineinfo);   # 
d1708 1
a1708 1
for (@@args) {
d1713 1
a1713 1
}
d1718 1
a1718 1
    &afterinit();
d1722 2
d1745 1
a1745 1
sub DB {
d1747 12
a1758 6
    # lock the debugger and get the thread id for the prompt
	lock($DBGR);
	my $tid;
	if ($ENV{PERL5DB_THREADED}) {
		$tid = eval { "[".threads->tid."]" };
	}
d1760 14
a1773 3
    # Check for whether we should be running continuously or not.
    # _After_ the perl program is compiled, $single is set to 1:
    if ( $single and not $second_time++ ) {
d1775 6
a1780 52
        # Options say run non-stop. Run until we get an interrupt.
        if ($runnonstop) {    # Disable until signal
                # If there's any call stack in place, turn off single
                # stepping into subs throughout the stack.
            for ( $i = 0 ; $i <= $stack_depth ; ) {
                $stack[ $i++ ] &= ~1;
            }

            # And we are now no longer in single-step mode.
            $single = 0;

            # If we simply returned at this point, we wouldn't get
            # the trace info. Fall on through.
            # return;
        } ## end if ($runnonstop)

        elsif ($ImmediateStop) {

            # We are supposed to stop here; XXX probably a break.
            $ImmediateStop = 0;    # We've processed it; turn it off
            $signal        = 1;    # Simulate an interrupt to force
                                   # us into the command loop
        }
    } ## end if ($single and not $second_time...

    # If we're in single-step mode, or an interrupt (real or fake)
    # has occurred, turn off non-stop mode.
    $runnonstop = 0 if $single or $signal;

    # Preserve current values of $@@, $!, $^E, $,, $/, $\, $^W.
    # The code being debugged may have altered them.
    &save;

    # Since DB::DB gets called after every line, we can use caller() to
    # figure out where we last were executing. Sneaky, eh? This works because
    # caller is returning all the extra information when called from the
    # debugger.
    local ( $package, $filename, $line ) = caller;
    local $filename_ini = $filename;

    # set up the context for DB::eval, so it can properly execute
    # code on behalf of the user. We add the package in so that the
    # code is eval'ed in the proper package (not in the debugger!).
    local $usercontext =
      '($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;' . "package $package;";

    # Create an alias to the active file magical array to simplify
    # the code here.
    local (*dbline) = $main::{ '_<' . $filename };

    # Last line in the program.
    local $max = $#dbline;
a1781 1
    # if we have something here, see if we should break.
d1784 1
a1784 1
        && ( ( $stop, $action ) = split( /\0/, $dbline{$line} ) ) )
d1796 2
a1797 1
            &eval;
d1804 1
d1806 9
a1814 3
    # Preserve the current stop-or-not, and see if any of the W
    # (watch expressions) has changed.
    my $was_signal = $signal;
d1816 3
a1818 5
    # If we have any watch expressions ...
    if ( $trace & 2 ) {
        for ( my $n = 0 ; $n <= $#to_watch ; $n++ ) {
            $evalarg = $to_watch[$n];
            local $onetimeDump;    # Tell DB::eval() to not output results
d1820 4
a1823 4
            # Fix context DB::eval() wants to return an array, but
            # we need a scalar here.
            my ($val) = join( "', '", &eval );
            $val = ( ( defined $val ) ? "'$val'" : 'undef' );
d1825 4
a1828 2
            # Did it change?
            if ( $val ne $old_watch[$n] ) {
d1830 7
a1836 11
                # Yep! Show the difference, and fake an interrupt.
                $signal = 1;
                print $OUT <<EOP;
Watchpoint $n:\t$to_watch[$n] changed:
    old value:\t$old_watch[$n]
    new value:\t$val
EOP
                $old_watch[$n] = $val;
            } ## end if ($val ne $old_watch...
        } ## end for (my $n = 0 ; $n <= ...
    } ## end if ($trace & 2)
d1838 2
a1839 1
=head2 C<watchfunction()>
d1841 2
a1842 3
C<watchfunction()> is a function that can be defined by the user; it is a
function which will be run on each entry to C<DB::DB>; it gets the 
current package, filename, and line as its parameters.
d1844 2
a1845 3
The watchfunction can do anything it likes; it is executing in the 
debugger's context, so it has access to all of the debugger's internal
data structures and functions.
d1847 1
a1847 3
C<watchfunction()> can control the debugger's actions. Any of the following
will cause the debugger to return control to the user's program after
C<watchfunction()> executes:
d1849 2
a1850 1
=over 4 
d1852 2
a1853 1
=item *
d1855 2
a1856 1
Returning a false value from the C<watchfunction()> itself.
d1858 19
a1876 1
=item *
d1878 5
a1882 1
Altering C<$single> to a false value.
d1884 8
a1891 1
=item *
d1893 6
a1898 1
Altering C<$signal> to a false value.
d1900 2
a1901 1
=item *
d1903 2
a1904 2
Turning off the C<4> bit in C<$trace> (this also disables the
check for C<watchfunction()>. This can be done with
d1906 14
a1919 1
    $trace &= ~4;
d1921 2
a1922 1
=back
d1924 2
a1925 1
=cut
d1927 2
a1928 10
    # If there's a user-defined DB::watchfunction, call it with the
    # current package, filename, and line. The function executes in
    # the DB:: package.
    if ( $trace & 4 ) {    # User-installed watch
        return
          if watchfunction( $package, $filename, $line )
          and not $single
          and not $was_signal
          and not( $trace & ~4 );
    } ## end if ($trace & 4)
d1930 10
a1939 4
    # Pick up any alteration to $signal in the watchfunction, and
    # turn off the signal now.
    $was_signal = $signal;
    $signal     = 0;
d1941 5
a1945 1
=head2 GETTING READY TO EXECUTE COMMANDS
d1947 2
a1948 4
The debugger decides to take control if single-step mode is on, the
C<t> command was entered, or the user generated a signal. If the program
has fallen off the end, we set things up so that entering further commands
won't cause trouble, and we say that the program is over.
d1950 2
a1951 1
=cut
d1953 6
a1958 7
    # Make sure that we always print if asked for explicitly regardless
    # of $trace_to_depth .
    my $explicit_stop = ($single || $was_signal);

    # Check to see if we should grab control ($single true,
    # trace set appropriately, or we got a signal).
    if ( $explicit_stop || ( $trace & 1 ) ) {
d1960 2
a1961 2
        # Yes, grab control.
        if ($slave_editor) {
d1963 5
a1967 3
            # Tell the editor to update its position.
            $position = "\032\032$filename:$line:0\n";
            print_lineinfo($position);
d1969 4
d1974 2
a1975 1
=pod
d1977 1
a1977 3
Special check: if we're in package C<DB::fake>, we've gone through the 
C<END> block at least once. We set up everything so that we can continue
to enter commands and have a valid context to be in.
d1979 1
a1979 1
=cut
d1981 3
a1983 1
        elsif ( $package eq 'DB::fake' ) {
d1985 2
a1986 7
            # Fallen off the end already.
            $term || &setterm;
            print_help(<<EOP);
Debugged program terminated.  Use B<q> to quit or B<R> to restart,
  use B<o> I<inhibit_exit> to avoid stopping after program termination,
  B<h q>, B<h R> or B<h o> to get additional info.  
EOP
d1988 47
a2034 6
            # Set the DB::eval context appropriately.
            $package     = 'main';
            $usercontext =
                '($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;'
              . "package $package;";    # this won't let them modify, alas
        } ## end elsif ($package eq 'DB::fake')
d2036 6
a2041 1
=pod
d2043 22
a2064 3
If the program hasn't finished executing, we scan forward to the
next executable line, print that out, build the prompt from the file and line
number information, and print that.   
d2066 5
a2070 1
=cut
d2072 4
a2075 1
        else {
d2077 6
d2084 2
a2085 20
            # Still somewhere in the midst of execution. Set up the
            #  debugger prompt.
            $sub =~ s/\'/::/;    # Swap Perl 4 package separators (') to
                                 # Perl 5 ones (sorry, we don't print Klingon
                                 #module names)

            $prefix = $sub =~ /::/ ? "" : "${'package'}::";
            $prefix .= "$sub($filename:";
            $after = ( $dbline[$line] =~ /\n$/ ? '' : "\n" );

            # Break up the prompt if it's really long.
            if ( length($prefix) > 30 ) {
                $position = "$prefix$line):\n$line:\t$dbline[$line]$after";
                $prefix   = "";
                $infix    = ":\t";
            }
            else {
                $infix    = "):\t";
                $position = "$prefix$line$infix$dbline[$line]$after";
            }
d2087 2
a2088 8
            # Print current line info, indenting if necessary.
            if ($frame) {
                print_lineinfo( ' ' x $stack_depth,
                    "$line:\t$dbline[$line]$after" );
            }
            else {
                depth_print_lineinfo($explicit_stop, $position);
            }
d2090 2
a2091 4
            # Scan forward, stopping at either the end or the next
            # unbreakable line.
            for ( $i = $line + 1 ; $i <= $max && $dbline[$i] == 0 ; ++$i )
            {    #{ vi
d2093 1
a2093 2
                # Drop out on null statements, block closers, and comments.
                last if $dbline[$i] =~ /^\s*[\;\}\#\n]/;
d2095 2
a2096 2
                # Drop out if the user interrupted us.
                last if $signal;
d2098 2
a2099 3
                # Append a newline if the line doesn't have one. Can happen
                # in eval'ed text, for instance.
                $after = ( $dbline[$i] =~ /\n$/ ? '' : "\n" );
d2101 3
a2103 4
                # Next executable line.
                $incr_pos = "$prefix$i$infix$dbline[$i]$after";
                $position .= $incr_pos;
                if ($frame) {
d2105 292
a2396 3
                    # Print it indented if tracing is on.
                    print_lineinfo( ' ' x $stack_depth,
                        "$i:\t$dbline[$i]$after" );
d2399 1
a2399 1
                    depth_print_lineinfo($explicit_stop, $incr_pos);
d2401 247
a2647 2
            } ## end for ($i = $line + 1 ; $i...
        } ## end else [ if ($slave_editor)
d2653 1
a2653 1
If there are any preprompt actions, execute those as well.      
d2658 5
a2662 1
    $evalarg = $action, &eval if $action;
d2673 2
a2674 1
            &eval;
d2678 3
a2680 2
        print $OUT $stack_depth . " levels deep in subroutine calls!\n"
          if $single & 4;
d2739 1
d2741 1
a2741 18
        while (

            # We have a terminal, or can get one ...
            ( $term || &setterm ),

            # ... and it belogs to this PID or we get one for this PID ...
            ( $term_pid == $$ or resetterm(1) ),

            # ... and we got a line of command input ...
            defined(
                $cmd = &readline(
                        "$pidprompt $tid DB"
                      . ( '<' x $level )
                      . ( $#hist + 1 )
                      . ( '>' x $level ) . " "
                )
            )
          )
d2744 1
a2744 1
			share($cmd);
d2754 2
a2755 2
            $cmd =~ s/\\$/\n/ && do {
                $cmd .= &readline("  cont: ");
d2757 1
a2757 1
            };
d2771 3
a2773 1
            $cmd =~ /^$/ && ( $cmd = $laststep );
d2775 3
a2777 1
            push( @@hist, $cmd ) if length($cmd) > 1;
d2779 2
a2780 2
			share(@@hist);
			share(@@truehist);
d2786 1
a2786 3
                $cmd =~ s/^\s+//s;    # trim annoying leading whitespace
                $cmd =~ s/\s+$//s;    # trim annoying trailing whitespace
                ($i) = split( /\s+/, $cmd );
d2798 1
a2798 1
                if ( $alias{$i} ) {
d2809 1
a2809 1
                    eval "\$cmd =~ $alias{$i}";
d2812 1
a2812 1
                        print $OUT "Couldn't evaluate '$i' alias: $@@";
d2815 2
a2816 1
                } ## end if ($alias{$i})
d2821 1
a2821 1
terminated. 
d2825 1
a2825 1
Quit the debugger. This entails setting the C<$fall_off_end> flag, so we don't 
d2831 15
a2845 5
                $cmd =~ /^q$/ && do {
                    $fall_off_end = 1;
                    clean_ENV();
                    exit $?;
                };
a2851 14
=cut

                $cmd =~ /^t(?:\s+(\d+))?$/ && do {
                    my $levels = $1;
                    $trace ^= 1;
                    local $\ = '';
                    $trace_to_depth = $levels ? $stack_depth + $levels : 1E9;
                    print $OUT "Trace = "
                      . ( ( $trace & 1 )
                      ? ( $levels ? "on (to level $trace_to_depth)" : "on" )
                      : "off" ) . "\n";
                    next CMD;
                };

d2856 1
a2856 1
=cut
d2858 1
a2858 25
                $cmd =~ /^S(\s+(!)?(.+))?$/ && do {

                    $Srev     = defined $2;     # Reverse scan?
                    $Spatt    = $3;             # The pattern (if any) to use.
                    $Snocheck = !defined $1;    # No args - print all subs.

                    # Need to make these sane here.
                    local $\ = '';
                    local $, = '';

                    # Search through the debugger's magical hash of subs.
                    # If $nocheck is true, just print the sub name.
                    # Otherwise, check it against the pattern. We then use
                    # the XOR trick to reverse the condition as required.
                    foreach $subname ( sort( keys %sub ) ) {
                        if ( $Snocheck or $Srev ^ ( $subname =~ /$Spatt/ ) ) {
                            print $OUT $subname, "\n";
                        }
                    }
                    next CMD;
                };

=head4 C<X> - list variables in current package

Since the C<V> command actually processes this, just change this to the 
a2860 4
=cut

                $cmd =~ s/^X\b/V $package/;

d2863 1
a2863 59
Uses C<dumpvar.pl> to dump out the current values for selected variables. 

=cut

                # Bare V commands get the currently-being-debugged package
                # added.
                $cmd =~ /^V$/ && do {
                    $cmd = "V $package";
                };

                # V - show variables in package.
                $cmd =~ /^V\b\s*(\S+)\s*(.*)/ && do {

                    # Save the currently selected filehandle and
                    # force output to debugger's filehandle (dumpvar
                    # just does "print" for output).
                    local ($savout) = select($OUT);

                    # Grab package name and variables to dump.
                    $packname = $1;
                    @@vars     = split( ' ', $2 );

                    # If main::dumpvar isn't here, get it.
                    do 'dumpvar.pl' || die $@@ unless defined &main::dumpvar;
                    if ( defined &main::dumpvar ) {

                        # We got it. Turn off subroutine entry/exit messages
                        # for the moment, along with return values.
                        local $frame = 0;
                        local $doret = -2;

                        # must detect sigpipe failures  - not catching
                        # then will cause the debugger to die.
                        eval {
                            &main::dumpvar(
                                $packname,
                                defined $option{dumpDepth}
                                ? $option{dumpDepth}
                                : -1,    # assume -1 unless specified
                                @@vars
                            );
                        };

                        # The die doesn't need to include the $@@, because
                        # it will automatically get propagated for us.
                        if ($@@) {
                            die unless $@@ =~ /dumpvar print failed/;
                        }
                    } ## end if (defined &main::dumpvar)
                    else {

                        # Couldn't load dumpvar.
                        print $OUT "dumpvar.pl not available.\n";
                    }

                    # Restore the output filehandle, and go round again.
                    select($savout);
                    next CMD;
                };
a2869 12
=cut

                $cmd =~ s/^x\b/ / && do {    # Remainder gets done by DB::eval()
                    $onetimeDump = 'dump';    # main::dumpvar shows the output

                    # handle special  "x 3 blah" syntax XXX propagate
                    # doc back to special variables.
                    if ( $cmd =~ s/^\s*(\d+)(?=\s)/ / ) {
                        $onetimedumpDepth = $1;
                    }
                };

a2873 12
=cut

                $cmd =~ s/^m\s+([\w:]+)\s*$/ / && do {
                    methods($1);
                    next CMD;
                };

                # m expr - set up DB::eval to do the work
                $cmd =~ s/^m\b/ / && do {    # Rest gets done by DB::eval()
                    $onetimeDump = 'methods';   #  method output gets used there
                };

d2876 1
a2876 46
=cut

                $cmd =~ /^f\b\s*(.*)/ && do {
                    $file = $1;
                    $file =~ s/\s+$//;

                    # help for no arguments (old-style was return from sub).
                    if ( !$file ) {
                        print $OUT
                          "The old f command is now the r command.\n";    # hint
                        print $OUT "The new f command switches filenames.\n";
                        next CMD;
                    } ## end if (!$file)

                    # if not in magic file list, try a close match.
                    if ( !defined $main::{ '_<' . $file } ) {
                        if ( ($try) = grep( m#^_<.*$file#, keys %main:: ) ) {
                            {
                                $try = substr( $try, 2 );
                                print $OUT "Choosing $try matching '$file':\n";
                                $file = $try;
                            }
                        } ## end if (($try) = grep(m#^_<.*$file#...
                    } ## end if (!defined $main::{ ...

                    # If not successfully switched now, we failed.
                    if ( !defined $main::{ '_<' . $file } ) {
                        print $OUT "No file matching '$file' is loaded.\n";
                        next CMD;
                    }

                    # We switched, so switch the debugger internals around.
                    elsif ( $file ne $filename ) {
                        *dbline   = $main::{ '_<' . $file };
                        $max      = $#dbline;
                        $filename = $file;
                        $start    = 1;
                        $cmd      = "l";
                    } ## end elsif ($file ne $filename)

                    # We didn't switch; say we didn't.
                    else {
                        print $OUT "Already in $file.\n";
                        next CMD;
                    }
                };
a2882 17
=cut

                # . command.
                $cmd =~ /^\.$/ && do {
                    $incr = -1;    # stay at current line

                    # Reset everything to the old location.
                    $start    = $line;
                    $filename = $filename_ini;
                    *dbline   = $main::{ '_<' . $filename };
                    $max      = $#dbline;

                    # Now where are we?
                    print_lineinfo($position);
                    next CMD;
                };

d2890 1
a2890 15
=cut

                # - - back a window.
                $cmd =~ /^-$/ && do {

                    # back up by a window; go to 1 if back too far.
                    $start -= $incr + $window + 1;
                    $start = 1 if $start <= 0;
                    $incr  = $window - 1;

                    # Generate and execute a "l +" command (handled below).
                    $cmd = 'l ' . ($start) . '+';
                };

=head3 PRE-580 COMMANDS VS. NEW COMMANDS: C<a, A, b, B, h, l, L, M, o, O, P, v, w, W, E<lt>, E<lt>E<lt>, {, {{>
a2898 9
=cut

                # All of these commands were remapped in perl 5.8.0;
                # we send them off to the secondary dispatcher (see below).
                $cmd =~ /^([aAbBeEhilLMoOPvwW]\b|[<>\{]{1,2})\s*(.*)/so && do {
                    &cmd_wrapper( $1, $2, $line );
                    next CMD;
                };

d2901 1
a2901 1
Uses C<PadWalker> to find the lexicals supplied as arguments in a scope    
a2903 40
=cut

                $cmd =~ /^y(?:\s+(\d*)\s*(.*))?$/ && do {

                    # See if we've got the necessary support.
                    eval { require PadWalker; PadWalker->VERSION(0.08) }
                      or &warn(
                        $@@ =~ /locate/
                        ? "PadWalker module not found - please install\n"
                        : $@@
                      )
                      and next CMD;

                    # Load up dumpvar if we don't have it. If we can, that is.
                    do 'dumpvar.pl' || die $@@ unless defined &main::dumpvar;
                    defined &main::dumpvar
                      or print $OUT "dumpvar.pl not available.\n"
                      and next CMD;

                    # Got all the modules we need. Find them and print them.
                    my @@vars = split( ' ', $2 || '' );

                    # Find the pad.
                    my $h = eval { PadWalker::peek_my( ( $1 || 0 ) + 1 ) };

                    # Oops. Can't find it.
                    $@@ and $@@ =~ s/ at .*//, &warn($@@), next CMD;

                    # Show the desired vars with dumplex().
                    my $savout = select($OUT);

                    # Have dumplex dump the lexicals.
                    dumpvar::dumplex( $_, $h->{$_},
                        defined $option{dumpDepth} ? $option{dumpDepth} : -1,
                        @@vars )
                      for sort keys %$h;
                    select($savout);
                    next CMD;
                };

d2916 1
a2916 15
so a null command knows what to re-execute. 

=cut

                # n - next
                $cmd =~ /^n$/ && do {
                    end_report(), next CMD if $finished and $level <= 1;

                    # Single step, but don't enter subs.
                    $single = 2;

                    # Save for empty command (repeat last).
                    $laststep = $cmd;
                    last CMD;
                };
d2920 1
a2920 1
Sets C<$single> to 1, which causes C<DB::sub> to continue tracing inside     
a2922 17
=cut

                # s - single step.
                $cmd =~ /^s$/ && do {

                    # Get out and restart the command loop if program
                    # has finished.
                    end_report(), next CMD if $finished and $level <= 1;

                    # Single step should enter subs.
                    $single = 1;

                    # Save for empty command (repeat last).
                    $laststep = $cmd;
                    last CMD;
                };

a2929 103
=cut

                # c - start continuous execution.
                $cmd =~ /^c\b\s*([\w:]*)\s*$/ && do {

                    # Hey, show's over. The debugged program finished
                    # executing already.
                    end_report(), next CMD if $finished and $level <= 1;

                    # Capture the place to put a one-time break.
                    $subname = $i = $1;

                    #  Probably not needed, since we finish an interactive
                    #  sub-session anyway...
                    # local $filename = $filename;
                    # local *dbline = *dbline; # XXX Would this work?!
                    #
                    # The above question wonders if localizing the alias
                    # to the magic array works or not. Since it's commented
                    # out, we'll just leave that to speculation for now.

                    # If the "subname" isn't all digits, we'll assume it
                    # is a subroutine name, and try to find it.
                    if ( $subname =~ /\D/ ) {    # subroutine name
                            # Qualify it to the current package unless it's
                            # already qualified.
                        $subname = $package . "::" . $subname
                          unless $subname =~ /::/;

                        # find_sub will return "file:line_number" corresponding
                        # to where the subroutine is defined; we call find_sub,
                        # break up the return value, and assign it in one
                        # operation.
                        ( $file, $i ) = ( find_sub($subname) =~ /^(.*):(.*)$/ );

                        # Force the line number to be numeric.
                        $i += 0;

                        # If we got a line number, we found the sub.
                        if ($i) {

                            # Switch all the debugger's internals around so
                            # we're actually working with that file.
                            $filename = $file;
                            *dbline   = $main::{ '_<' . $filename };

                            # Mark that there's a breakpoint in this file.
                            $had_breakpoints{$filename} |= 1;

                            # Scan forward to the first executable line
                            # after the 'sub whatever' line.
                            $max = $#dbline;
                            ++$i while $dbline[$i] == 0 && $i < $max;
                        } ## end if ($i)

                        # We didn't find a sub by that name.
                        else {
                            print $OUT "Subroutine $subname not found.\n";
                            next CMD;
                        }
                    } ## end if ($subname =~ /\D/)

                    # At this point, either the subname was all digits (an
                    # absolute line-break request) or we've scanned through
                    # the code following the definition of the sub, looking
                    # for an executable, which we may or may not have found.
                    #
                    # If $i (which we set $subname from) is non-zero, we
                    # got a request to break at some line somewhere. On
                    # one hand, if there wasn't any real subroutine name
                    # involved, this will be a request to break in the current
                    # file at the specified line, so we have to check to make
                    # sure that the line specified really is breakable.
                    #
                    # On the other hand, if there was a subname supplied, the
                    # preceding block has moved us to the proper file and
                    # location within that file, and then scanned forward
                    # looking for the next executable line. We have to make
                    # sure that one was found.
                    #
                    # On the gripping hand, we can't do anything unless the
                    # current value of $i points to a valid breakable line.
                    # Check that.
                    if ($i) {

                        # Breakable?
                        if ( $dbline[$i] == 0 ) {
                            print $OUT "Line $i not breakable.\n";
                            next CMD;
                        }

                        # Yes. Set up the one-time-break sigil.
                        $dbline{$i} =~ s/($|\0)/;9$1/;  # add one-time-only b.p.
                        _enable_breakpoint_temp_enabled_status($filename, $i);
                    } ## end if ($i)

                    # Turn off stack tracing from here up.
                    for ( $i = 0 ; $i <= $stack_depth ; ) {
                        $stack[ $i++ ] &= ~1;
                    }
                    last CMD;
                };

a2937 16
=cut

                # r - return from the current subroutine.
                $cmd =~ /^r$/ && do {

                    # Can't do anything if the program's over.
                    end_report(), next CMD if $finished and $level <= 1;

                    # Turn on stack trace.
                    $stack[$stack_depth] |= 1;

                    # Print return value unless the stack is empty.
                    $doret = $option{PrintRet} ? $stack_depth - 1 : -2;
                    last CMD;
                };

a2941 7
=cut

                $cmd =~ /^T$/ && do {
                    print_trace( $OUT, 1 );    # skip DB
                    next CMD;
                };

a2945 4
=cut

                $cmd =~ /^w\b\s*(.*)/s && do { &cmd_w( 'w', $1 ); next CMD; };

d2948 1
a2948 5
Just calls C<DB::cmd_W>. 

=cut

                $cmd =~ /^W\b\s*(.*)/s && do { &cmd_W( 'W', $1 ); next CMD; };
d2952 1
a2952 1
We take the argument and treat it as a pattern. If it turns out to be a 
d2954 1
a2954 1
If not, we create some code to do the search and C<eval> it so it can't 
d2959 1
a2959 69
                $cmd =~ /^\/(.*)$/ && do {

                    # The pattern as a string.
                    $inpat = $1;

                    # Remove the final slash.
                    $inpat =~ s:([^\\])/$:$1:;

                    # If the pattern isn't null ...
                    if ( $inpat ne "" ) {

                        # Turn of warn and die procesing for a bit.
                        local $SIG{__DIE__};
                        local $SIG{__WARN__};

                        # Create the pattern.
                        eval '$inpat =~ m' . "\a$inpat\a";
                        if ( $@@ ne "" ) {

                            # Oops. Bad pattern. No biscuit.
                            # Print the eval error and go back for more
                            # commands.
                            print $OUT "$@@";
                            next CMD;
                        }
                        $pat = $inpat;
                    } ## end if ($inpat ne "")

                    # Set up to stop on wrap-around.
                    $end = $start;

                    # Don't move off the current line.
                    $incr = -1;

                    # Done in eval so nothing breaks if the pattern
                    # does something weird.
                    eval '
                        for (;;) {
                            # Move ahead one line.
                            ++$start;

                            # Wrap if we pass the last line.
                            $start = 1 if ($start > $max);

                            # Stop if we have gotten back to this line again,
                            last if ($start == $end);

                            # A hit! (Note, though, that we are doing
                            # case-insensitive matching. Maybe a qr//
                            # expression would be better, so the user could
                            # do case-sensitive matching if desired.
                            if ($dbline[$start] =~ m' . "\a$pat\a" . 'i) {
                                if ($slave_editor) {
                                    # Handle proper escaping in the slave.
                                    print $OUT "\032\032$filename:$start:0\n";
                                } 
                                else {
                                    # Just print the line normally.
                                    print $OUT "$start:\t",$dbline[$start],"\n";
                                }
                                # And quit since we found something.
                                last;
                            }
                         } ';

                    # If we wrapped, there never was a match.
                    print $OUT "/$pat/: not found\n" if ( $start == $end );
                    next CMD;
                };
d2967 1
a2967 64
                # ? - backward pattern search.
                $cmd =~ /^\?(.*)$/ && do {

                    # Get the pattern, remove trailing question mark.
                    $inpat = $1;
                    $inpat =~ s:([^\\])\?$:$1:;

                    # If we've got one ...
                    if ( $inpat ne "" ) {

                        # Turn off die & warn handlers.
                        local $SIG{__DIE__};
                        local $SIG{__WARN__};
                        eval '$inpat =~ m' . "\a$inpat\a";

                        if ( $@@ ne "" ) {

                            # Ouch. Not good. Print the error.
                            print $OUT $@@;
                            next CMD;
                        }
                        $pat = $inpat;
                    } ## end if ($inpat ne "")

                    # Where we are now is where to stop after wraparound.
                    $end = $start;

                    # Don't move away from this line.
                    $incr = -1;

                    # Search inside the eval to prevent pattern badness
                    # from killing us.
                    eval '
                        for (;;) {
                            # Back up a line.
                            --$start;

                            # Wrap if we pass the first line.

                            $start = $max if ($start <= 0);

                            # Quit if we get back where we started,
                            last if ($start == $end);

                            # Match?
                            if ($dbline[$start] =~ m' . "\a$pat\a" . 'i) {
                                if ($slave_editor) {
                                    # Yep, follow slave editor requirements.
                                    print $OUT "\032\032$filename:$start:0\n";
                                } 
                                else {
                                    # Yep, just print normally.
                                    print $OUT "$start:\t",$dbline[$start],"\n";
                                }

                                # Found, so done.
                                last;
                            }
                        } ';

                    # Say we failed if the loop never found anything,
                    print $OUT "?$pat?: not found\n" if ( $start == $end );
                    next CMD;
                };
d2978 1
a2978 19
                $cmd =~ /^$rc+\s*(-)?(\d+)?$/ && do {

                    # No arguments, take one thing off history.
                    pop(@@hist) if length($cmd) > 1;

                    # Relative (- found)?
                    #  Y - index back from most recent (by 1 if bare minus)
                    #  N - go to that particular command slot or the last
                    #      thing if nothing following.
                    $i = $1 ? ( $#hist - ( $2 || 1 ) ) : ( $2 || $#hist );

                    # Pick out the command desired.
                    $cmd = $hist[$i];

                    # Print the command to be executed and restart the loop
                    # with that command in the buffer.
                    print $OUT $cmd, "\n";
                    redo CMD;
                };
d2982 1
a2982 1
Calls the C<DB::system()> to handle the command. This keeps the C<STDIN> and
d2987 1
a2987 8
                # $sh$sh - run a shell command (if it's all ASCII).
                # Can't run shell commands with Unicode in the debugger, hmm.
                $cmd =~ /^$sh$sh\s*([\x00-\xff]*)/ && do {

                    # System it.
                    &system($1);
                    next CMD;
                };
d2996 1
a2996 2
                # $rc pattern $rc - find a command in the history.
                $cmd =~ /^$rc([^$rc].*)$/ && do {
d2998 1
a2998 2
                    # Create the pattern to use.
                    $pat = "^$1";
d3000 1
a3000 2
                    # Toss off last entry if length is >1 (and it always is).
                    pop(@@hist) if length($cmd) > 1;
d3002 1
a3002 2
                    # Look backward through the history.
                    for ( $i = $#hist ; $i ; --$i ) {
d3004 1
a3004 3
                        # Stop if we find it.
                        last if $hist[$i] =~ /$pat/;
                    }
d3006 2
a3007 1
                    if ( !$i ) {
d3009 1
a3009 4
                        # Never found it.
                        print $OUT "No such command!\n\n";
                        next CMD;
                    }
d3011 1
a3011 5
                    # Found it. Put it in the buffer, print it, and process it.
                    $cmd = $hist[$i];
                    print $OUT $cmd, "\n";
                    redo CMD;
                };
d3013 1
a3013 1
=head4 C<$sh> - Invoke a shell     
d3015 1
a3015 1
Uses C<DB::system> to invoke a shell.
d3019 26
a3044 2
                # $sh - start a shell.
                $cmd =~ /^$sh$/ && do {
d3046 24
a3069 5
                    # Run the user's shell. If none defined, run Bourne.
                    # We resume execution when the shell terminates.
                    &system( $ENV{SHELL} || "/bin/sh" );
                    next CMD;
                };
d3071 1
a3071 1
=head4 C<$sh I<command>> - Force execution of a command in a shell
d3073 3
a3075 2
Like the above, but the command is passed to the shell. Again, we use
C<DB::system> to avoid problems with C<STDIN> and C<STDOUT>.
d3079 1
a3079 2
                # $sh command - start a shell and run a command in it.
                $cmd =~ /^$sh\s*([\x00-\xff]*)/ && do {
d3081 2
a3082 2
                    # XXX: using csh or tcsh destroys sigint retvals!
                    #&system($1);  # use this instead
d3084 17
a3100 3
                    # use the user's shell, or Bourne if none defined.
                    &system( $ENV{SHELL} || "/bin/sh", "-c", $1 );
                    next CMD;
d3103 18
a3120 1
=head4 C<H> - display commands in history
d3122 6
a3127 1
Prints the contents of C<@@hist> (if any).
d3131 140
a3270 5
                $cmd =~ /^H\b\s*\*/ && do {
                    @@hist = @@truehist = ();
                    print $OUT "History cleansed\n";
                    next CMD;
                };
d3272 2
a3273 1
                $cmd =~ /^H\b\s*(-(\d+))?/ && do {
d3275 4
a3278 18
                    # Anything other than negative numbers is ignored by
                    # the (incorrect) pattern, so this test does nothing.
                    $end = $2 ? ( $#hist - $2 ) : 0;

                    # Set to the minimum if less than zero.
                    $hist = 0 if $hist < 0;

                    # Start at the end of the array.
                    # Stay in while we're still above the ending value.
                    # Tick back by one each time around the loop.
                    for ( $i = $#hist ; $i > $end ; $i-- ) {

                        # Print the command  unless it has no arguments.
                        print $OUT "$i: ", $hist[$i], "\n"
                          unless $hist[$i] =~ /^.?$/;
                    }
                    next CMD;
                };
d3280 1
a3280 1
=head4 C<man, doc, perldoc> - look up documentation
d3282 3
a3284 1
Just calls C<runman()> to print the appropriate document.
d3288 17
a3304 5
                # man, perldoc, doc - show manual pages.
                $cmd =~ /^(?:man|(?:perl)?doc)\b(?:\s+([^(]*))?$/ && do {
                    runman($1);
                    next CMD;
                };
d3306 1
a3306 1
=head4 C<p> - print
d3308 3
a3310 2
Builds a C<print EXPR> expression in the C<$cmd>; this will get executed at
the bottom of the loop.
d3314 63
a3376 2
                # p - print (no args): print $_.
                $cmd =~ s/^p$/print {\$DB::OUT} \$_/;
d3378 164
a3541 2
                # p - print the given expression.
                $cmd =~ s/^p\b/print {\$DB::OUT} /;
d3543 68
a3610 1
=head4 C<=> - define command alias
d3612 2
a3613 1
Manipulates C<%alias> to add or list command aliases.
d3615 5
a3619 1
=cut
d3621 2
a3622 4
                # = - set up a command alias.
                $cmd =~ s/^=\s*// && do {
                    my @@keys;
                    if ( length $cmd == 0 ) {
d3624 2
a3625 4
                        # No args, get current aliases.
                        @@keys = sort keys %alias;
                    }
                    elsif ( my ( $k, $v ) = ( $cmd =~ /^(\S+)\s+(\S.*)/ ) ) {
d3627 2
a3628 2
                        # Creating a new alias. $k is alias name, $v is
                        # alias value.
d3630 3
a3632 2
                        # can't use $_ or kill //g state
                        for my $x ( $k, $v ) {
d3634 2
a3635 3
                            # Escape "alarm" characters.
                            $x =~ s/\a/\\a/g;
                        }
d3637 1
a3637 4
                        # Substitute key for value, using alarm chars
                        # as separators (which is why we escaped them in
                        # the command).
                        $alias{$k} = "s\a$k\a$v\a";
d3639 6
a3644 3
                        # Turn off standard warn and die behavior.
                        local $SIG{__DIE__};
                        local $SIG{__WARN__};
d3646 1
a3646 2
                        # Is it valid Perl?
                        unless ( eval "sub { s\a$k\a$v\a }; 1" ) {
d3648 4
a3651 5
                            # Nope. Bad alias. Say so and get out.
                            print $OUT "Can't alias $k to $v: $@@\n";
                            delete $alias{$k};
                            next CMD;
                        }
d3653 5
a3657 3
                        # We'll only list the new one.
                        @@keys = ($k);
                    } ## end elsif (my ($k, $v) = ($cmd...
d3659 2
a3660 4
                    # The argument is the alias to list.
                    else {
                        @@keys = ($cmd);
                    }
d3662 2
a3663 2
                    # List aliases.
                    for my $k (@@keys) {
d3665 5
a3669 21
                        # Messy metaquoting: Trim the substitution code off.
                        # We use control-G as the delimiter because it's not
                        # likely to appear in the alias.
                        if ( ( my $v = $alias{$k} ) =~ ss\a$k\a(.*)\a$1 ) {

                            # Print the alias.
                            print $OUT "$k\t= $1\n";
                        }
                        elsif ( defined $alias{$k} ) {

                            # Couldn't trim it off; just print the alias code.
                            print $OUT "$k\t$alias{$k}\n";
                        }
                        else {

                            # No such, dude.
                            print "No alias for $k\n";
                        }
                    } ## end for my $k (@@keys)
                    next CMD;
                };
d3671 1
a3671 1
=head4 C<source> - read commands from a file.
d3673 3
a3675 2
Opens a lexical filehandle and stacks it on C<@@cmdfhs>; C<DB::readline> will
pick it up.
d3677 2
a3678 1
=cut
d3680 4
a3683 3
                # source - read commands from a file (or pipe!) and execute.
                $cmd =~ /^source\s+(.*\S)/ && do {
                    if ( open my $fh, $1 ) {
d3685 1
a3685 4
                        # Opened OK; stick it in the list of file handles.
                        push @@cmdfhs, $fh;
                    }
                    else {
d3687 4
a3690 5
                        # Couldn't open it.
                        &warn("Can't execute '$1': $!\n");
                    }
                    next CMD;
                };
d3692 2
a3693 2
                $cmd =~ /^(enable|disable)\s+(\S+)\s*$/ && do {
                    my ($cmd, $position) = ($1, $2);
d3695 2
a3696 14
                    my ($fn, $line_num);
                    if ($position =~ m{\A\d+\z})
                    {
                        $fn = $filename;
                        $line_num = $position;
                    }
                    elsif ($position =~ m{\A(.*):(\d+)\z})
                    {
                        ($fn, $line_num) = ($1, $2);
                    }
                    else
                    {
                        &warn("Wrong spec for enable/disable argument.\n");
                    }
d3698 2
a3699 10
                    if (defined($fn)) {
                        if (_has_breakpoint_data_ref($fn, $line_num)) {
                            _set_breakpoint_enabled_status($fn, $line_num,
                                ($cmd eq 'enable' ? 1 : '')
                            );
                        }
                        else {
                            &warn("No breakpoint set at ${fn}:${line_num}\n");
                        }
                    }
d3701 6
a3706 2
                    next CMD;
                };
d3708 2
a3709 1
=head4 C<save> - send current history to a file
d3711 2
a3712 2
Takes the complete history, (not the shrunken version you see with C<H>),
and saves it to the given filename, so it can be replayed using C<source>.
d3714 9
a3722 1
Note that all C<^(save|source)>'s are commented out with a view to minimise recursion.
d3724 2
a3725 1
=cut
d3727 2
a3728 17
                # save source - write commands to a file for later use
                $cmd =~ /^save\s*(.*)$/ && do {
                    my $file = $1 || '.perl5dbrc';    # default?
                    if ( open my $fh, "> $file" ) {

                       # chomp to remove extraneous newlines from source'd files
                        chomp( my @@truelist =
                              map { m/^\s*(save|source)/ ? "#$_" : $_ }
                              @@truehist );
                        print $fh join( "\n", @@truelist );
                        print "commands saved in $file\n";
                    }
                    else {
                        &warn("Can't save debugger commands in '$1': $!\n");
                    }
                    next CMD;
                };
d3730 3
a3732 1
=head4 C<R> - restart
d3734 4
a3737 1
Restart the debugger session. 
d3739 2
a3740 1
=head4 C<rerun> - rerun the current session
d3742 2
a3743 1
Return to any given position in the B<true>-history list
d3745 3
a3747 1
=cut
d3749 17
a3765 15
                # R - restart execution.
                # rerun - controlled restart execution.
                $cmd =~ /^(R|rerun\s*(.*))$/ && do {
                    my @@args = ($1 eq 'R' ? restart() : rerun($2));

                    # Close all non-system fds for a clean restart.  A more
                    # correct method would be to close all fds that were not
                    # open when the process started, but this seems to be
                    # hard.  See "debugger 'R'estart and open database
                    # connections" on p5p.

                    my $max_fd = 1024; # default if POSIX can't be loaded
                    if (eval { require POSIX }) {
                        eval { $max_fd = POSIX::sysconf(POSIX::_SC_OPEN_MAX()) };
                    }
d3767 3
a3769 6
                    if (defined $max_fd) {
                        foreach ($^F+1 .. $max_fd-1) {
                            next unless open FD_TO_CLOSE, "<&=$_";
                            close(FD_TO_CLOSE);
                        }
                    }
d3771 4
a3774 3
                    # And run Perl again.  We use exec() to keep the
                    # PID stable (and that way $ini_pids is still valid).
                    exec(@@args) || print $OUT "exec failed: $!\n";
d3776 2
a3777 2
                    last CMD;
                };
d3779 4
a3782 1
=head4 C<|, ||> - pipe output through the pager.
d3784 4
a3787 5
For C<|>, we save C<OUT> (the debugger's output filehandle) and C<STDOUT>
(the program's standard output). For C<||>, we only save C<OUT>. We open a
pipe to the pager (restoring the output filehandles if this fails). If this
is the C<|> command, we also set up a C<SIGPIPE> handler which will simply 
set C<$signal>, sending us back into the debugger.
d3789 4
a3792 3
We then trim off the pipe symbols and C<redo> the command loop at the
C<PIPE> label, causing us to evaluate the command in C<$cmd> without
reading another.
d3794 6
a3799 1
=cut
d3801 2
a3802 3
                # || - run command in the pager, with output to DB::OUT.
                $cmd =~ /^\|\|?\s*[^|]/ && do {
                    if ( $pager =~ /^\|/ ) {
d3804 2
a3805 7
                        # Default pager is into a pipe. Redirect I/O.
                        open( SAVEOUT, ">&STDOUT" )
                          || &warn("Can't save STDOUT");
                        open( STDOUT, ">&OUT" )
                          || &warn("Can't redirect STDOUT");
                    } ## end if ($pager =~ /^\|/)
                    else {
d3807 3
a3809 3
                        # Not into a pipe. STDOUT is safe.
                        open( SAVEOUT, ">&OUT" ) || &warn("Can't save DB::OUT");
                    }
d3811 4
a3814 2
                    # Fix up environment to record we have less if so.
                    fix_less();
d3816 5
a3820 1
                    unless ( $piped = open( OUT, $pager ) ) {
d3822 2
a3823 19
                        # Couldn't open pipe to pager.
                        &warn("Can't pipe output to '$pager'");
                        if ( $pager =~ /^\|/ ) {

                            # Redirect I/O back again.
                            open( OUT, ">&STDOUT" )    # XXX: lost message
                              || &warn("Can't restore DB::OUT");
                            open( STDOUT, ">&SAVEOUT" )
                              || &warn("Can't restore STDOUT");
                            close(SAVEOUT);
                        } ## end if ($pager =~ /^\|/)
                        else {

                            # Redirect I/O. STDOUT already safe.
                            open( OUT, ">&STDOUT" )    # XXX: lost message
                              || &warn("Can't restore DB::OUT");
                        }
                        next CMD;
                    } ## end unless ($piped = open(OUT,...
d3825 2
a3826 16
                    # Set up broken-pipe handler if necessary.
                    $SIG{PIPE} = \&DB::catch
                      if $pager =~ /^\|/
                      && ( "" eq $SIG{PIPE} || "DEFAULT" eq $SIG{PIPE} );

                    # Save current filehandle, unbuffer out, and put it back.
                    $selected = select(OUT);
                    $|        = 1;

                    # Don't put it back if pager was a pipe.
                    select($selected), $selected = "" unless $cmd =~ /^\|\|/;

                    # Trim off the pipe symbols and run the command now.
                    $cmd =~ s/^\|+\s*//;
                    redo PIPE;
                };
d3828 2
a3829 1
=head3 END OF COMMAND PARSING
d3831 15
a3845 3
Anything left in C<$cmd> at this point is a Perl expression that we want to 
evaluate. We'll always evaluate in the user's context, and fully qualify 
any variables we might want to address in the C<DB> package.
d3847 10
a3856 1
=cut
d3858 2
a3859 4
                # t - turn trace on.
                $cmd =~ s/^t\s+(\d+)?/\$DB::trace |= 1;\n/ && do {
                    $trace_to_depth = $1 ? $stack_depth||0 + $1 : 1E9;
                };
d3861 2
a3862 2
                # s - single-step. Remember the last command was 's'.
                $cmd =~ s/^s\s/\$DB::single = 1;\n/ && do { $laststep = 's' };
d3864 2
a3865 3
                # n - single-step, but not into subs. Remember last command
                # was 'n'.
                $cmd =~ s/^n\s/\$DB::single = 2;\n/ && do { $laststep = 'n' };
d3867 16
a3882 1
            }    # PIPE:
d3884 2
a3885 3
            # Make sure the flag that says "the debugger's running" is
            # still on, to make sure we get control again.
            $evalarg = "\$^D = \$^D | \$DB::db_stop;\n$cmd";
d3887 2
a3888 2
            # Run *our* eval that executes in the caller's context.
            &eval;
d3890 4
a3893 10
            # Turn off the one-time-dump stuff now.
            if ($onetimeDump) {
                $onetimeDump      = undef;
                $onetimedumpDepth = undef;
            }
            elsif ( $term_pid == $$ ) {
		eval {		# May run under miniperl, when not available...
                    STDOUT->flush();
                    STDERR->flush();
		};
d3895 2
a3896 4
                # XXX If this is the master pid, print a newline.
                print $OUT "\n";
            }
        } ## end while (($term || &setterm...
d3898 2
a3899 1
=head3 POST-COMMAND PROCESSING
d3901 4
a3904 3
After each command, we check to see if the command output was piped anywhere.
If so, we go through the necessary code to unhook the pipe and go back to
our standard filehandles for input and output.
d3906 17
a3922 1
=cut
d3924 2
a3925 1
        continue {    # CMD:
d3927 2
a3928 2
            # At the end of every command:
            if ($piped) {
d3930 6
a3935 2
                # Unhook the pipe mechanism now.
                if ( $pager =~ /^\|/ ) {
d3937 2
a3938 2
                    # No error from the child.
                    $? = 0;
d3940 2
a3941 33
                    # we cannot warn here: the handle is missing --tchrist
                    close(OUT) || print SAVEOUT "\nCan't close DB::OUT\n";

                    # most of the $? crud was coping with broken cshisms
                    # $? is explicitly set to 0, so this never runs.
                    if ($?) {
                        print SAVEOUT "Pager '$pager' failed: ";
                        if ( $? == -1 ) {
                            print SAVEOUT "shell returned -1\n";
                        }
                        elsif ( $? >> 8 ) {
                            print SAVEOUT ( $? & 127 )
                              ? " (SIG#" . ( $? & 127 ) . ")"
                              : "", ( $? & 128 ) ? " -- core dumped" : "", "\n";
                        }
                        else {
                            print SAVEOUT "status ", ( $? >> 8 ), "\n";
                        }
                    } ## end if ($?)

                    # Reopen filehandle for our output (if we can) and
                    # restore STDOUT (if we can).
                    open( OUT, ">&STDOUT" ) || &warn("Can't restore DB::OUT");
                    open( STDOUT, ">&SAVEOUT" )
                      || &warn("Can't restore STDOUT");

                    # Turn off pipe exception handler if necessary.
                    $SIG{PIPE} = "DEFAULT" if $SIG{PIPE} eq \&DB::catch;

                    # Will stop ignoring SIGPIPE if done like nohup(1)
                    # does SIGINT but Perl doesn't give us a choice.
                } ## end if ($pager =~ /^\|/)
                else {
d3943 5
a3947 3
                    # Non-piped "pager". Just restore STDOUT.
                    open( OUT, ">&SAVEOUT" ) || &warn("Can't restore DB::OUT");
                }
d3949 2
a3950 4
                # Close filehandle pager was using, restore the normal one
                # if necessary,
                close(SAVEOUT);
                select($selected), $selected = "" unless $selected eq "";
d3952 2
a3953 4
                # No pipes now.
                $piped = "";
            } ## end if ($piped)
        }    # CMD:
d3955 3
a3957 1
=head3 COMMAND LOOP TERMINATION
d3959 2
a3960 6
When commands have finished executing, we come here. If the user closed the
input filehandle, we turn on C<$fall_off_end> to emulate a C<q> command. We
evaluate any post-prompt items. We restore C<$@@>, C<$!>, C<$^E>, C<$,>, C<$/>,
C<$\>, and C<$^W>, and return a null list as expected by the Perl interpreter.
The interpreter will then execute the next line and then return control to us
again.
d3962 6
a3967 1
=cut
d3969 2
a3970 2
        # No more commands? Quit.
        $fall_off_end = 1 unless defined $cmd;    # Emulate 'q' on EOF
d3972 1
a3972 5
        # Evaluate post-prompt commands.
        foreach $evalarg (@@$post) {
            &eval;
        }
    }    # if ($single || $signal)
d3974 1
a3974 4
    # Put the user's globals back where you found them.
    ( $@@, $!, $^E, $,, $/, $\, $^W ) = @@saved;
    ();
} ## end sub DB
d3981 1
a3981 1
C<sub> is called whenever a subroutine call happens in the program being 
d3995 1
a3995 1
and also prints the return value if needed (for the C<r> command and if 
d4059 32
a4090 3
sub sub {
	# Do not use a regex in this subroutine -> results in corrupted memory
	# See: [perl #66110]
d4092 9
a4100 2
	# lock ourselves under threads
	lock($DBGR);
d4106 3
a4108 3
	if ($sub eq 'threads::new' && $ENV{PERL5DB_THREADED}) {
		print "creating new thread\n"; 
	}
d4113 1
a4136 4
    (
        $frame & 4    # Extended frame entry message
        ? (
            print_lineinfo( ' ' x ( $stack_depth - 1 ), "in  " ),
d4138 2
a4139 7
            # Why -1? But it works! :-(
            # Because print_trace will call add 1 to it and then call
            # dump_trace; this results in our skipping -1+1 = 0 stack frames
            # in dump_trace.
            print_trace( $LINEINFO, -1, 1, 1, "$sub$al" )
          )
        : print_lineinfo( ' ' x ( $stack_depth - 1 ), "entering $sub$al\n" )
d4141 16
a4156 3
          # standard frame entry message
      )
      if $frame;
d4164 4
a4167 1
	@@ret = &$sub;
d4172 1
a4172 12
        # Check for exit trace messages...
        (
            $frame & 4    # Extended exit message
            ? (
                print_lineinfo( ' ' x $stack_depth, "out " ),
                print_trace( $LINEINFO, -1, 1, 1, "$sub$al" )
              )
            : print_lineinfo( ' ' x $stack_depth, "exited $sub$al\n" )

              # Standard exit message
          )
          if $frame & 2;
d4182 4
a4185 1
            print $fh ' ' x $stack_depth if $frame & 16;
d4188 1
a4188 1
            print $fh "list context return from $sub:\n";
d4200 11
a4210 11
	if ( defined wantarray ) {

	    # Save the value if it's wanted at all.
	    $ret = &$sub;
	}
	else {

	    # Void return, explicitly.
	    &$sub;
	    undef $ret;
	}
d4216 1
a4216 11
        (
            $frame & 4    # Extended messages
            ? (
                print_lineinfo( ' ' x $stack_depth, "out " ),
                print_trace( $LINEINFO, -1, 1, 1, "$sub$al" )
              )
            : print_lineinfo( ' ' x $stack_depth, "exited $sub$al\n" )

              # Standard messages
          )
          if $frame & 2;
d4235 1
a4235 1
} ## end sub sub
d4239 4
a4242 2
	# lock ourselves under threads
	lock($DBGR);
d4248 3
a4250 3
	if ($sub =~ /^threads::new$/ && $ENV{PERL5DB_THREADED}) {
		print "creating new thread\n";
	}
d4278 1
a4278 16
    (
        $frame & 4    # Extended frame entry message
        ? (
            print_lineinfo( ' ' x ( $stack_depth - 1 ), "in  " ),

            # Why -1? But it works! :-(
            # Because print_trace will call add 1 to it and then call
            # dump_trace; this results in our skipping -1+1 = 0 stack frames
            # in dump_trace.
            print_trace( $LINEINFO, -1, 1, 1, "$sub$al" )
          )
        : print_lineinfo( ' ' x ( $stack_depth - 1 ), "entering $sub$al\n" )

          # standard frame entry message
      )
      if $frame;
d4300 2
a4301 2
The following sections describe the code added to make it easy to support 
multiple command sets with conflicting command names. This section is a start 
d4304 1
a4304 1
Note that all the cmd_[a-zA-Z] subroutines require the command name, a line 
d4307 1
a4307 1
Support functions in this section which have multiple modes of failure C<die> 
d4316 1
a4316 1
name suffix. 
d4322 1
a4322 1
=cut 
d4403 1
a4403 1
    
d4422 2
a4423 2
C<cmd_wrapper()> allows the debugger to switch command sets 
depending on the value of the C<CommandSet> option. 
d4426 3
a4428 3
(which means external entities can't fiddle with it) and create the name of 
the sub to call based on the value found in the hash (if it's there). I<All> 
of the commands to be handled in a set have to be added to C<%set>; if they 
d4431 1
a4431 1
This code uses symbolic references. 
d4445 1
a4445 1
          || ( $cmd =~ /^[<>{]+/o ? 'prepost' : $cmd ) );
d4448 1
a4448 1
    return &$call( $cmd, $line, $dblineno );
d4454 2
a4455 2
particular line, so they're stored in C<%dbline>. We default to the current 
line if none is specified. 
d4465 1
a4465 1
    $line =~ s/^(\.|(?:[^\d]))/$dbline/;
d4468 5
a4472 2
    if ( $line =~ /^\s*(\d*)\s*(\S.+)/ ) {
        my ( $lineno, $expr ) = ( $1, $2 );
d4492 2
d4526 4
a4529 1
        eval { &delete_action(); 1 } or print $OUT $@@ and return;
d4535 4
a4538 1
        eval { &delete_action($1); 1 } or print $OUT $@@ and return;
d4551 1
a4551 1
is specified, we check for the line being executable (if it's not, it 
d4557 30
d4589 1
a4590 1

d4595 1
a4595 2
        $dbline{$i} =~ s/\0[^\0]*//;    # \^a
        delete $dbline{$i} if $dbline{$i} eq '';
d4598 3
a4600 17
        print $OUT "Deleting all actions...\n";
        for my $file ( keys %had_breakpoints ) {
            local *dbline = $main::{ '_<' . $file };
            my $max = $#dbline;
            my $was;
            for ( $i = 1 ; $i <= $max ; $i++ ) {
                if ( defined $dbline{$i} ) {
                    $dbline{$i} =~ s/\0[^\0]*//;
                    delete $dbline{$i} if $dbline{$i} eq '';
                }
                unless ( $had_breakpoints{$file} &= ~2 ) {
                    delete $had_breakpoints{$file};
                }
            } ## end for ($i = 1 ; $i <= $max...
        } ## end for my $file (keys %had_breakpoints)
    } ## end else [ if (defined($i))
} ## end sub delete_action
d4617 5
d4627 1
a4627 1
        &cmd_b_line( $dbline, 1 );
d4631 3
a4633 4
    elsif ( $line =~ /^load\b\s*(.*)/ ) {
        my $file = $1;
        $file =~ s/\s+$//;
        &cmd_b_load($file);
d4639 2
a4640 8
    elsif ( $line =~ /^(postpone|compile)\b\s*([':A-Za-z_][':\w]*)\s*(.*)/ ) {

        # Capture the condition if there is one. Make it true if none.
        my $cond = length $3 ? $3 : '1';

        # Save the sub name and set $break to 1 if $1 was 'postpone', 0
        # if it was 'compile'.
        my ( $subname, $break ) = ( $2, $1 eq 'postpone' );
d4643 1
a4643 1
        $subname =~ s/\'/::/g;
d4646 1
a4646 1
        $subname = "${'package'}::" . $subname unless $subname =~ /::/;
d4652 3
a4654 1
        $postponed{$subname} = $break ? "break +0 if $cond" : "compile";
d4657 2
a4658 2
    elsif ($line =~ /\A(\S+[^:]):(\d+)\s*(.*)/ms) {
        my ($filename, $line_num, $cond) = ($1, $2, $3);
d4661 1
a4661 1
            $line_num, 
d4666 2
a4667 1
    elsif ( $line =~ /^([':A-Za-z_][':\w]*(?:\[.*\])?)\s*(.*)/ ) {
d4670 2
a4671 3
        $subname = $1;
        $cond = length $2 ? $2 : '1';
        &cmd_b_sub( $subname, $cond );
d4675 1
a4675 1
    elsif ( $line =~ /^(\d*)\s*(.*)/ ) {
d4678 1
a4678 4
        $line = $1 || $dbline;

        # If there's no condition, make it '1'.
        $cond = length $2 ? $2 : '1';
d4681 1
a4681 1
        &cmd_b_line( $line, $cond );
d4688 2
d4695 1
a4695 1
C<%break_on_load> hash, and note that it has a breakpoint in 
d4708 1
a4708 1
Gives us an array of filenames that are set to break on load. Note that 
d4721 1
a4721 1
to files they came from). We mark those files for break-on-load via 
d4759 1
a4759 1
C<$filename_error> is used to contain the name of the file that's being 
d4769 1
a4769 1
=over 4 
d4777 1
a4777 1
Localizes the C<*dbline> glob and reassigns it to point to the file we want to process. 
d4781 1
a4781 1
Calls the first function. 
d4797 1
d4806 1
a4806 1
If C<$to> is greater than C<$from>, the search moves forwards, finding the 
d4909 1
a4909 1
Adds a breakpoint with the specified condition (or 1 if no condition was 
d4915 2
a4916 4
    my ( $i, $cond ) = @@_;

    # Always true if no condition supplied.
    $cond = 1 unless @@_ >= 2;
d4942 2
d4948 1
a4948 1
Wrapper for C<break_on_line>. Prints the failure message if it 
d4951 1
a4951 1
=cut 
d4954 1
a4954 1
    eval { break_on_line(@@_); 1 } or do {
d4957 3
a4959 1
    };
d4964 1
a4964 1
Wrapper for C<break_on_filename_line>. Prints the failure message if it 
d4967 1
a4967 1
=cut 
d4970 1
a4970 1
    eval { break_on_filename_line(@@_); 1 } or do {
d4973 3
a4975 1
    };
d4980 1
a4980 1
Switches to the file specified and then calls C<break_on_line> to set 
d4986 3
a4988 4
    my ( $f, $i, $cond ) = @@_;

    # Always true if condition left off.
    $cond = 1 unless @@_ >= 3;
d4999 2
d5005 1
a5005 1
Switch to another file, search the range of lines specified for an 
d5011 4
a5014 1
    my ( $f, $from, $to, $cond ) = @@_;
a5018 3
    # Always true if missing.
    $cond = 1 unless @@_ >= 3;

d5021 2
d5033 1
a5033 1
    my ( $subname, $cond ) = @@_;
d5036 2
a5037 3
    # The match creates the list (fullpathname, start, end). Falling off
    # the end of the subroutine returns this implicitly.
    find_sub($subname) =~ /^(.*):(\d+)-(\d+)$/;
d5043 1
a5043 1
C<subroutine_filename_lines> to find the subroutine, and 
d5055 1
d5057 1
a5057 1
    $cond = 1 unless @@_ >= 2;
d5061 3
a5063 1
    break_on_filename_line_range( $file, $s, $e, @@_ );
d5072 1
a5072 1
=item 1. If it's already fully-qualified, leave it alone. 
d5082 1
a5082 1
After all this cleanup, we call C<break_subroutine> to try to set the 
d5088 2
a5089 4
    my ( $subname, $cond ) = @@_;

    # Add always-true condition if we have none.
    $cond = 1 unless @@_ >= 2;
d5093 1
a5093 1
    unless ( ref $subname eq 'CODE' ) {
d5095 2
a5096 2
        # Not Perl4.
        $subname =~ s/\'/::/g;
d5100 4
a5103 2
        $subname = "${'package'}::" . $subname
          unless $subname =~ /::/;
d5108 7
a5114 4
        $subname = "CORE::GLOBAL::$s"
          if not defined &$subname
          and $s !~ /::/
          and defined &{"CORE::GLOBAL::$s"};
d5117 5
a5121 3
        $subname = "main" . $subname if substr( $subname, 0, 2 ) eq "::";

    } ## end unless (ref $subname eq 'CODE')
d5124 1
a5124 1
    eval { break_subroutine( $subname, $cond ); 1 } or do {
d5126 5
a5130 2
        print $OUT $@@ and return;
      }
d5149 1
a5149 1
    my $line   = ( $_[0] =~ /^\./ ) ? $dbline : shift || '';
d5157 3
a5159 1
        eval { &delete_breakpoint(); 1 } or print $OUT $@@ and return;
d5163 2
a5164 2
    elsif ( $line =~ /^(\S.*)/ ) {
        eval { &delete_breakpoint( $line || $dbline ); 1 } or do {
d5166 2
a5167 2
            print $OUT $@@ and return;
        };
d5172 1
a5172 1
        print $OUT
d5176 2
d5191 1
a5191 1
For all breakpoints, we iterate through the keys of C<%had_breakpoints>, 
d5198 1
a5198 1
We then wholesale delete C<%postponed>, C<%postponed_file>, and 
d5205 15
a5219 2
sub delete_breakpoint {
    my $i = shift;
d5221 2
a5222 1
    my $fn = $filename;
d5224 1
a5224 2
    # If we got a line, delete just that one.
    if ( defined($i) ) {
d5226 2
a5227 2
        # Woops. This line wasn't breakable at all.
        die "Line $i not breakable.\n" if $dbline[$i] == 0;
d5229 2
a5230 2
        # Kill the condition, but leave any action.
        $dbline{$i} =~ s/^[^\0]*//;
d5232 8
a5239 6
        # Remove the entry entirely if there's no action left.
        if ($dbline{$i} eq '') {
            delete $dbline{$i};
            _delete_breakpoint_data_ref($fn, $i);
        }
    }
d5241 13
a5253 3
    # No line; delete them all.
    else {
        print $OUT "Deleting all breakpoints...\n";
d5255 2
a5256 3
        # %had_breakpoints lists every file that had at least one
        # breakpoint in it.
        for my $file ( keys %had_breakpoints ) {
d5258 2
a5259 2
            # Switch to the desired file temporarily.
            local *dbline = $main::{ '_<' . $file };
d5261 2
a5262 2
            my $max = $#dbline;
            my $was;
d5264 2
a5265 2
            # For all lines in this file ...
            for ( $i = 1 ; $i <= $max ; $i++ ) {
d5267 4
a5270 2
                # If there's a breakpoint or action on this line ...
                if ( defined $dbline{$i} ) {
d5272 2
a5273 3
                    # ... remove the breakpoint.
                    $dbline{$i} =~ s/^[^\0]+//;
                    if ( $dbline{$i} =~ s/^\0?$// ) {
d5275 2
a5276 6
                        # Remove the entry altogether if no action is there.
                        delete $dbline{$i};
                        _delete_breakpoint_data_ref($file, $i);
                    }
                } ## end if (defined $dbline{$i...
            } ## end for ($i = 1 ; $i <= $max...
d5278 8
a5285 7
            # If, after we turn off the "there were breakpoints in this file"
            # bit, the entry in %had_breakpoints for this file is zero,
            # we should remove this file from the hash.
            if ( not $had_breakpoints{$file} &= ~1 ) {
                delete $had_breakpoints{$file};
            }
        } ## end for my $file (keys %had_breakpoints)
d5287 2
a5288 7
        # Kill off all the other breakpoints that are waiting for files that
        # haven't been loaded yet.
        undef %postponed;
        undef %postponed_file;
        undef %break_on_load;
    } ## end else [ if (defined($i))
} ## end sub delete_breakpoint
d5306 1
a5306 1
	e
d5316 7
a5322 7
	unless (exists($INC{'threads.pm'})) {
		print "threads not loaded($ENV{PERL5DB_THREADED})
		please run the debugger with PERL5DB_THREADED=1 set in the environment\n";
	} else {
		my $tid = threads->tid;
		print "thread id: $tid\n";
	}
d5329 1
a5329 1
	E
d5338 9
a5346 9
	unless (exists($INC{'threads.pm'})) { 
		print "threads not loaded($ENV{PERL5DB_THREADED})
		please run the debugger with PERL5DB_THREADED=1 set in the environment\n";
	} else {
		my $tid = threads->tid;
		print "thread ids: ".join(', ', 
			map { ($tid == $_->tid ? '<'.$_->tid.'>' : $_->tid) } threads->list
		)."\n"; 
	}
d5367 3
d5377 1
a5377 1
    if ( $line =~ /^h\s*/ ) {
d5382 1
a5382 1
    elsif ( $line =~ /^(\S.*)$/ ) {
a5385 3
        my $asked = $1;    # the command requested
                           # (for proper error message)

d5408 1
a5408 1
                              (?!\s)         # Next line not starting with 
d5440 2
a5441 1
        ($isa) = &eval;
d5461 1
a5461 1
runs a loop over C<@@dbline> for the specified range of lines. It handles 
d5464 1
a5464 1
line breakable). 
d5471 34
a5504 4
sub cmd_l {
    my $current_line = $line;
    my $cmd  = shift;
    my $line = shift;
d5506 5
a5510 2
    # If this is '-something', delete any spaces after the dash.
    $line =~ s/^-\s*$/-/;
d5512 4
a5515 3
    # If the line is '$something', assume this is a scalar containing a
    # line number.
    if ( $line =~ /^(\$.*)/s ) {
d5517 3
a5519 4
        # Set up for DB::eval() - evaluate in *user* context.
        $evalarg = $1;
        # $evalarg = $2;
        my ($s) = &eval;
d5521 1
a5521 2
        # Ooops. Bad scalar.
        print( $OUT "Error: $@@\n" ), next CMD if $@@;
d5523 1
a5523 8
        # Good scalar. If it's a reference, find what it points to.
        $s = CvGV_name($s);
        print( $OUT "Interpreted as: $1 $s\n" );
        $line = "$1 $s";

        # Call self recursively to really do the command.
        &cmd_l( 'l', $s );
    } ## end if ($line =~ /^(\$.*)/s)
d5525 2
a5526 3
    # l name. Try to find a sub by that name.
    elsif ( $line =~ /^([\':A-Za-z_][\':\w]*(\[.*\])?)/s ) {
        my $s = $subname = $1;
d5528 2
a5529 2
        # De-Perl4.
        $subname =~ s/\'/::/;
d5531 6
a5536 2
        # Put it in this package unless it starts with ::.
        $subname = $package . "::" . $subname unless $subname =~ /::/;
d5538 2
a5539 6
        # Put it in CORE::GLOBAL if t doesn't start with :: and
        # it doesn't live in this package and it lives in CORE::GLOBAL.
        $subname = "CORE::GLOBAL::$s"
          if not defined &$subname
          and $s !~ /::/
          and defined &{"CORE::GLOBAL::$s"};
d5541 3
a5543 2
        # Put leading '::' names into 'main::'.
        $subname = "main" . $subname if substr( $subname, 0, 2 ) eq "::";
d5545 2
a5546 15
        # Get name:start-stop from find_sub, and break this up at
        # colons.
        @@pieces = split( /:/, find_sub($subname) || $sub{$subname} );

        # Pull off start-stop.
        $subrange = pop @@pieces;

        # If the name contained colons, the split broke it up.
        # Put it back together.
        $file = join( ':', @@pieces );

        # If we're not in that file, switch over to it.
        if ( $file ne $filename ) {
            print $OUT "Switching to file '$file'.\n"
              unless $slave_editor;
d5548 3
a5550 5
            # Switch debugger's magic structures.
            *dbline   = $main::{ '_<' . $file };
            $max      = $#dbline;
            $filename = $file;
        } ## end if ($file ne $filename)
d5552 5
a5556 6
        # Subrange is 'start-stop'. If this is less than a window full,
        # swap it to 'start+', which will list a window from the start point.
        if ($subrange) {
            if ( eval($subrange) < -$window ) {
                $subrange =~ s/-.*/+/;
            }
d5558 5
a5562 4
            # Call self recursively to list the range.
            $line = $subrange;
            &cmd_l( 'l', $subrange );
        } ## end if ($subrange)
d5564 5
a5568 3
        # Couldn't find it.
        else {
            print $OUT "Subroutine $subname not found.\n";
a5569 1
    } ## end elsif ($line =~ /^([\':A-Za-z_][\':\w]*(\[.*\])?)/s)
d5571 42
a5612 2
    # Bare 'l' command.
    elsif ( $line =~ /^\s*$/ ) {
d5614 2
a5615 3
        # Compute new range to list.
        $incr = $window - 1;
        $line = $start . '-' . ( $start + $incr );
d5617 2
a5618 2
        # Recurse to do it.
        &cmd_l( 'l', $line );
d5621 9
a5629 2
    # l [start]+number_of_lines
    elsif ( $line =~ /^(\d*)\+(\d*)$/ ) {
d5631 2
a5632 2
        # Don't reset start for 'l +nnn'.
        $start = $1 if $1;
d5634 14
a5647 4
        # Increment for list. Use window size if not specified.
        # (Allows 'l +' to work.)
        $incr = $2;
        $incr = $window - 1 unless $incr;
d5649 5
a5653 4
        # Create a line range we'll understand, and recurse to do it.
        $line = $start . '-' . ( $start + $incr );
        &cmd_l( 'l', $line );
    } ## end elsif ($line =~ /^(\d*)\+(\d*)$/)
d5655 20
a5674 2
    # l start-stop or l start,stop
    elsif ( $line =~ /^((-?[\d\$\.]+)([-,]([\d\$\.]+))?)?/ ) {
d5676 11
a5686 2
        # Determine end point; use end of file if not specified.
        $end = ( !defined $2 ) ? $max : ( $4 ? $4 : $2 );
d5688 2
a5689 2
        # Go on to the end, and then stop.
        $end = $max if $end > $max;
d5691 2
a5692 20
        # Determine start line.
        $i    = $2;
        $i    = $line if $i eq '.';
        $i    = 1 if $i < 1;
        $incr = $end - $i;

        # If we're running under a slave editor, force it to show the lines.
        if ($slave_editor) {
            print $OUT "\032\032$filename:$i:0\n";
            $i = $end;
        }

        # We're doing it ourselves. We want to show the line and special
        # markers for:
        # - the current line in execution
        # - whether a line is breakable or not
        # - whether a line has a break or not
        # - whether a line has an action or not
        else {
            for ( ; $i <= $end ; $i++ ) {
d5694 2
a5695 15
                # Check for breakpoints and actions.
                my ( $stop, $action );
                ( $stop, $action ) = split( /\0/, $dbline{$i} )
                  if $dbline{$i};

                # ==> if this is the current line in execution,
                # : if it's breakable.
                $arrow =
                  ( $i == $current_line and $filename eq $filename_ini )
                  ? '==>'
                  : ( $dbline[$i] + 0 ? ':' : ' ' );

                # Add break and action indicators.
                $arrow .= 'b' if $stop;
                $arrow .= 'a' if $action;
d5697 22
a5718 2
                # Print the line.
                print $OUT "$i$arrow\t", $dbline[$i];
d5720 1
a5720 14
                # Move on to the next line. Drop out on an interrupt.
                $i++, last if $signal;
            } ## end for (; $i <= $end ; $i++)

            # Line the prompt up; print a newline if the last line listed
            # didn't have a newline.
            print $OUT "\n" unless $dbline[ $i - 1 ] =~ /\n$/;
        } ## end else [ if ($slave_editor)

        # Save the point we last listed to in case another relative 'l'
        # command is desired. Don't let it run off the end.
        $start = $i;
        $start = $max if $start > $max;
    } ## end elsif ($line =~ /^((-?[\d\$\.]+)([-,]([\d\$\.]+))?)?/)
d5723 6
d5733 5
a5737 5
breakpoints and/or actions. For each file, we switch the C<*dbline> glob (the 
magic source and breakpoint data structures) to the file, and then look 
through C<%dbline> for lines with breakpoints and/or actions, listing them 
out. We look through C<%postponed> not-yet-compiled subroutines that have 
breakpoints, and through C<%postponed_file> for not-yet-C<require>'d files 
d5744 1
a5744 3
sub cmd_L {
    my $cmd = shift;

d5748 43
a5790 1
    $arg = 'abw' unless $CommandSet eq '580';    # sigh...
d5792 1
a5792 4
    # See what is wanted.
    my $action_wanted = ( $arg =~ /a/ ) ? 1 : 0;
    my $break_wanted  = ( $arg =~ /b/ ) ? 1 : 0;
    my $watch_wanted  = ( $arg =~ /w/ ) ? 1 : 0;
d5794 33
a5826 3
    # Breaks and actions are found together, so we look in the same place
    # for both.
    if ( $break_wanted or $action_wanted ) {
d5828 2
a5829 2
        # Look in all the files with breakpoints...
        for my $file ( keys %had_breakpoints ) {
a5830 2
            # Temporary switch to this file.
            local *dbline = $main::{ '_<' . $file };
d5832 2
a5833 4
            # Set up to look through the whole file.
            my $max = $#dbline;
            my $was;    # Flag: did we print something
                        # in this file?
d5835 2
a5836 2
            # For each line in the file ...
            for ( $i = 1 ; $i <= $max ; $i++ ) {
d5838 2
a5839 2
                # We've got something on this line.
                if ( defined $dbline{$i} ) {
d5841 1
a5841 2
                    # Print the header if we haven't.
                    print $OUT "$file:\n" unless $was++;
d5843 3
a5845 2
                    # Print the line.
                    print $OUT " $i:\t", $dbline[$i];
d5847 3
a5849 2
                    # Pull out the condition and the action.
                    ( $stop, $action ) = split( /\0/, $dbline{$i} );
d5851 2
a5852 9
                    # Print the break if there is one and it's wanted.
                    print $OUT "   break if (", $stop, ")\n"
                      if $stop
                      and $break_wanted;

                    # Print the action if there is one and it's wanted.
                    print $OUT "   action:  ", $action, "\n"
                      if $action
                      and $action_wanted;
d5854 5
a5858 6
                    # Quit if the user hit interrupt.
                    last if $signal;
                } ## end if (defined $dbline{$i...
            } ## end for ($i = 1 ; $i <= $max...
        } ## end for my $file (keys %had_breakpoints)
    } ## end if ($break_wanted or $action_wanted)
d5862 1
a5862 1
        print $OUT "Postponed breakpoints in subroutines:\n";
d5864 1
d5866 4
a5869 2
            print $OUT " $subname\t$postponed{$subname}\n";
            last if $signal;
d5880 2
a5881 2
        print $OUT "Postponed breakpoints in files:\n";
        my ( $file, $line );
a5882 17
        for $file ( keys %postponed_file ) {
            my $db = $postponed_file{$file};
            print $OUT " $file:\n";
            for $line ( sort { $a <=> $b } keys %$db ) {
                print $OUT "  $line:\n";
                my ( $stop, $action ) = split( /\0/, $$db{$line} );
                print $OUT "    break if (", $stop, ")\n"
                  if $stop
                  and $break_wanted;
                print $OUT "    action:  ", $action, "\n"
                  if $action
                  and $action_wanted;
                last if $signal;
            } ## end for $line (sort { $a <=>...
            last if $signal;
        } ## end for $file (keys %postponed_file)
    } ## end if (@@have and ($break_wanted...
d5884 4
a5887 5
        print $OUT "Breakpoints on load:\n";
        my $file;
        for $file ( keys %break_on_load ) {
            print $OUT " $file\n";
            last if $signal;
d5890 10
a5899 9
    if ($watch_wanted) {
        if ( $trace & 2 ) {
            print $OUT "Watch-expressions:\n" if @@to_watch;
            for my $expr (@@to_watch) {
                print $OUT " $expr\n";
                last if $signal;
            }
        } ## end if ($trace & 2)
    } ## end if ($watch_wanted)
d5909 3
a5911 1
    &list_modules();
d5916 1
a5916 1
If this is just C<o> by itself, we list the current settings via 
d5928 1
a5928 1
        &parse_options($1);
d5934 1
a5934 1
            &dump_option($_);
d5957 3
a5959 1
=cut 
d5984 1
a5984 1
        &cmd_l( 'l', $line );
d6000 23
d6030 2
a6031 17
    if ( $expr =~ /^(\S.*)/ ) {

        # ... save it.
        push @@to_watch, $expr;

        # Parameterize DB::eval and call it to get the expression's value
        # in the user's context. This version can handle expressions which
        # return a list value.
        $evalarg = $expr;
        my ($val) = join( ' ', &eval );
        $val = ( defined $val ) ? "'$val'" : 'undef';

        # Save the current value of the expression.
        push @@old_watch, $val;

        # We are now watching expressions.
        $trace |= 2;
d6038 3
a6040 1
} ## end sub cmd_w
d6047 2
a6048 2
If C<*> is specified, we simply empty the watch expression list and the 
watch expression value list. We also turn off the bit that says we've got 
d6053 1
a6053 1
the corresponding values. If no watch expressions are left, we turn off 
d6117 1
a6117 1
and installs the versions we like better. 
d6138 1
a6138 1
us to feed line information to a slave editor without messing up the 
d6157 1
a6157 1
temporarily switch the C<*dbline> glob over to the source file, and then 
d6161 1
a6161 1
=cut 
d6195 1
a6195 1
            my $max = $#dbline;
d6220 1
a6220 1
also called if the name of a just-compiled subroutine is a key of 
d6224 1
a6224 1
If this is a C<require>'d file, the incoming parameter is the glob 
d6244 3
a6246 1
    return &postponed_sub unless ref \$_[0] eq 'GLOB';
d6285 1
a6285 1
C<dumpit> is the debugger's wrapper around dumpvar.pl. 
d6288 1
a6288 1
a reference to a variable (the thing to be dumped) as its input. 
d6292 1
a6292 1
values of the package globals C<$single> and C<$trace> are backed up in 
d6296 1
a6296 1
messages from printing, and C<$doret> is localized as well and set to -2 to 
d6299 3
a6301 3
C<dumpit()> then checks to see if it needs to load C<dumpvar.pl> and 
tries to load it (note: if you have a C<dumpvar.pl>  ahead of the 
installed version in C<@@INC>, yours will be used instead. Possible security 
d6305 1
a6305 1
(it should have been defined by C<dumpvar.pl>). If it has, C<dumpit()> 
d6307 1
a6307 1
is called, and picks up the variable to be dumped from the parameter list. 
d6309 3
a6311 3
It checks the package global C<%options> to see if there's a C<dumpDepth> 
specified. If not, -1 is assumed; if so, the supplied value gets passed on to 
C<dumpvar.pl>. This tells C<dumpvar.pl> where to leave off when dumping a 
d6314 1
a6314 1
C<dumpValue()> is then called if possible; if not, C<dumpit()>just prints a 
d6326 1
a6326 1
    local ($savout) = select(shift);
d6351 1
a6351 1
        &main::dumpValue( $v, $maxdepth );
d6370 1
a6370 1
C<print_trace>'s job is to print a stack trace. It does this via the 
d6424 1
a6424 1
    for ( $i = 0 ; $i <= $#sub ; $i++ ) {
d6449 1
a6449 1
        $s = $sub[$i]{sub};
d6464 1
a6464 1
    } ## end for ($i = 0 ; $i <= $#sub...
d6474 1
a6474 1
from the most current. C<count> determines the total number of frames to 
d6497 45
d6561 1
a6561 1
    my ( $e, $r, @@a, @@sub, $args );
d6578 1
a6578 1
        $i = $skip ;
d6582 1
a6582 1
      )
d6586 1
a6586 34
        @@a = ();
        for $arg (@@args) {
            my $type;
            if ( not defined $arg ) {    # undefined parameter
                push @@a, "undef";
            }

            elsif ( $nothard and tied $arg ) {    # tied parameter
                push @@a, "tied";
            }
            elsif ( $nothard and $type = ref $arg ) {    # reference
                push @@a, "ref($type)";
            }
            else {                                       # can be stringified
                local $_ =
                  "$arg";    # Safe to stringify now - should not call f().

                # Backslash any single-quotes or backslashes.
                s/([\'\\])/\\$1/g;

                # Single-quote it unless it's a number or a colon-separated
                # name.
                s/(.*)/'$1'/s
                  unless /^(?: -?[\d.]+ | \*[\w:]* )$/x;

                # Turn high-bit characters into meta-whatever.
                s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;

                # Turn control characters into ^-whatever.
                s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;

                push( @@a, $_ );
            } ## end else [ if (not defined $arg)
        } ## end for $arg (@@args)
d6596 1
a6596 1
        $args = $h ? [@@a] : undef;
d6657 1
a6657 1
        $action .= &gets;
d6671 1
a6671 1
speeds things up by only creating the qr//'ed expression once; if it's 
d6676 2
d6681 1
a6681 1
    $balanced_brace_re ||= qr{ 
d6702 1
a6702 1
    &readline("cont: ");
d6705 1
a6705 1
=head2 C<DB::system()> - handle calls to<system()> without messing up the debugger
d6708 2
a6709 2
STDOUT, but under the debugger, we want it to use the debugger's input and 
outout filehandles. 
d6711 1
a6711 1
C<DB::system()> socks away the program's STDIN and STDOUT, and then substitutes
d6717 1
a6717 1
sub system {
d6721 4
a6724 4
    open( SAVEIN,  "<&STDIN" )  || &warn("Can't save STDIN");
    open( SAVEOUT, ">&STDOUT" ) || &warn("Can't save STDOUT");
    open( STDIN,   "<&IN" )     || &warn("Can't redirect STDIN");
    open( STDOUT,  ">&OUT" )    || &warn("Can't redirect STDOUT");
d6728 2
a6729 2
    open( STDIN,  "<&SAVEIN" )  || &warn("Can't restore STDIN");
    open( STDOUT, ">&SAVEOUT" ) || &warn("Can't restore STDOUT");
d6735 1
a6735 1
        &warn( "(Command exited ", ( $? >> 8 ), ")\n" );
d6738 1
a6738 1
        &warn(
d6750 2
d6763 2
a6764 2
to find one. If we're a forked debugger, we call C<resetterm> to try to 
get a whole new terminal if we can. 
d6768 1
a6768 1
the appropriate attributes. We then 
d6772 3
d6791 1
a6791 3
            my $sel = select($OUT);
            $| = 1;
            select($sel);
d6838 1
a6838 1
    &load_hist();
d6886 2
a6887 2
C<get_fork_TTY> is a glob-aliased function which calls the real function that 
is tasked with doing all the necessary operating system mojo to get a new 
d6898 1
a6898 1
=cut 
d6925 1
a6925 1
This function provides the C<get_fork_TTY> function for X11. If a 
d6930 2
a6931 2
we're spawning route file number 3 to STDOUT, and then execute the C<tty> 
command (which prints the device name of the TTY we'll want to use for input 
d6934 1
a6934 1
is STDOUT from the I<commands> we ran) to get the TTY we want to use. 
d6936 1
a6936 1
Only works if C<xterm> is in your path and C<$ENV{DISPLAY}>, etc. are 
d6978 2
a6979 2
    my %opt = (	title => "Daughter Perl debugger $pids $name",
		($rl ? (read_by_key => 1) : ()) );
d7062 4
a7065 4
	if ($version>=$entry->[0]) {
	    $script=$entry->[1];
	    last;
	}
d7095 2
d7101 1
a7101 1
    my $in = &get_fork_TTY if defined &get_fork_TTY;
d7149 1
a7149 1
If the new debugger happened because of a C<system()> that invoked a 
d7154 2
a7155 2
isn't any list yet, we make one up out of the initial pid associated with 
the terminal and our new pid, sticking an arrow (either one-dashed or 
d7207 2
a7208 2
If we've emptied the filehandle stack, we check to see if we've got a socket 
open, and we read that and return it if we do. If we don't, we just call the 
d7218 14
a7256 12
    # If there are stacked filehandles to read from ...
    while (@@cmdfhs) {

        # Read from the last one in the stack.
        my $line = CORE::readline( $cmdfhs[-1] );

        # If we got a line ...
        defined $line
          ? ( print $OUT ">> $line" and return $line )    # Echo and return
          : close pop @@cmdfhs;                            # Pop and close
    } ## end while (@@cmdfhs)

a7263 1
        $stuff;
d7266 5
a7270 1
        do {
d7273 1
a7273 1
        } while length $buf and ($stuff .= $buf) !~ /\n/;
d7276 1
a7276 1
        $stuff;
d7281 1
a7281 1
        $term->readline(@@_);
d7373 1
a7373 1
it just gets stuck in a variable, we do that; if there's a subroutine to 
d7383 1
a7383 1
    local ($_) = @@_;
d7386 2
d7394 1
a7394 1
    while (length) {
d7398 1
a7398 1
        s/^\s+// && next;
d7402 4
a7405 1
        s/^(\w+)(\W?)// or print( $OUT "Invalid option '$_'\n" ), last;
d7409 2
a7410 2
        my $matches = grep( /^\Q$opt/ && ( $option = $_ ), @@options )
          || grep( /^\Q$opt/i && ( $option = $_ ), @@options );
d7412 8
a7419 2
        print( $OUT "Unknown option '$opt'\n" ), next unless $matches;
        print( $OUT "Ambiguous option '$opt'\n" ), next if $matches > 1;
d7424 5
a7428 3
            print( $OUT "Option query '$opt?' followed by non-space '$_'\n" ),
              last
              if /^\S/;
d7444 1
a7444 1
            if (s/ (["']) ( (?: \\. | (?! \1 ) [^\\] )* ) \1 //x) {
d7451 1
a7451 1
                s/^(\S*)//;
d7463 1
a7463 1
            s/^(([^\\$end]|\\[\\$end])*)$end($|\s+)//
d7471 1
a7471 1
            print $OUT
d7480 8
a7487 8
        eval qq{
                local \$frame = 0; 
                local \$doret = -2; 
                require '$optionRequire{$option}';
                1;
               } || die $@@   # XXX: shouldn't happen
          if defined $optionRequire{$option}
          && defined $val;
d7491 3
a7493 3
        ${ $optionVars{$option} } = $val
          if defined $optionVars{$option}
          && defined $val;
d7496 6
a7501 4
        &{ $optionAction{$option} }($val)
          if defined $optionAction{$option}
          && defined &{ $optionAction{$option} }
          && defined $val;
d7504 1
a7504 1
        dump_option($option) unless $OUT eq \*STDERR;
d7510 1
a7510 1
These routines are used to store (and restore) lists of items in environment 
d7531 1
a7531 1
    for $i ( 0 .. $#list ) {
d7544 1
a7544 1
=cut 
d7551 1
a7551 1
    for $i ( 0 .. $n - 1 ) {
d7564 1
a7564 1
set an already-existing global scalar variable to a constant value. This 
d7580 3
a7582 3
If the composited message I<doesn't> end with a newline, we automatically 
add C<$!> and a newline to the end of the message. The subroutine expects $OUT 
to be set to the filehandle to be used to output warnings; it makes no 
d7587 1
a7587 1
sub warn {
d7594 2
d7601 1
a7601 1
after we've tried and failed to move them elsewhere.  In addition, it assigns 
d7617 1
a7617 1
        &warn("Too late to set IN/OUT filehandles, enabled on next 'R'!\n");
d7626 1
a7626 3
    my $o = select $OUT;
    $| = 1;
    select $o;
d7634 1
a7634 1
The following routines are used to process some of the more complicated 
d7682 3
a7684 1
    &warn("Too late to set TTY, enabled on next 'R'!\n") if $term and @@_;
d7703 1
a7703 1
        &warn("Too late to set noTTY, enabled on next 'R'!\n") if @@_;
d7711 1
a7711 1
Sets the C<$rl> option variable. If 0, we use C<Term::ReadLine::Stub> 
d7720 1
a7720 1
        &warn("Too late to set ReadLine, enabled on next 'R'!\n") if @@_;
d7736 1
a7736 1
        &warn("Too late to set RemotePort, enabled on next 'R'!\n") if @@_;
d7769 1
a7769 1
        &warn("Too late to set up NonStop mode, enabled on next 'R'!\n")
d7778 1
a7778 1
        &warn("Some flag changes could not take effect until next 'R'!\n")
d7802 1
a7802 1
Sets the shell escape command, and generates a printable copy to be used 
d7829 1
a7829 1
=cut 
d7835 2
a7836 1
        local ( $warnLevel, $dieLevel ) = ( 0, 1 );
d7839 5
a7843 2
        return '' unless $term->Features->{ornaments};
        eval { $term->ornaments(@@_) } || '';
d7849 2
d7852 1
d7872 1
a7872 1
    $prc = $rc;    # Copy it
d7875 1
a7875 1
    $prc;                    # Return the printable version
d7882 2
a7883 2
Called with an argument (a file or a pipe), it opens that onto the 
C<LINEINFO> filehandle, unbuffers the filehandle, and then returns the 
d7889 9
a7897 2
    return $lineinfo unless @@_;
    $lineinfo = shift;
d7899 7
a7905 13
    #  If this is a valid "thing to be opened for output", tack a
    # '>' onto the front.
    my $stream = ( $lineinfo =~ /^(\+?\>|\|)/ ) ? $lineinfo : ">$lineinfo";

    # If this is a pipe, the stream points to a slave editor.
    $slave_editor = ( $stream =~ /^\|/ );

    # Open it up and unbuffer it.
    open( LINEINFO, "$stream" ) || &warn("Cannot open '$stream' for write");
    $LINEINFO = \*LINEINFO;
    my $save = select($LINEINFO);
    $| = 1;
    select($save);
d7907 1
a7907 2
    # Hand the file or pipe back again.
    $lineinfo;
d7939 3
a7941 2
        if ( defined ${ $_ . '::VERSION' } ) {
            $version{$file} = "${ $_ . '::VERSION' } from ";
d7969 2
a7970 2
If you are modifying the help text, I<be careful>. The help-string parser is 
not very sophisticated, and if you don't follow these rules it will mangle the 
d7975 3
d7985 2
a7986 2
Help is currently only available for the new 5.8 command set. 
No help is available for the old command set. 
d8027 1
a8027 1
        Set breakpoint at first line of subroutine after 
d8098 1
a8098 1
        history, breakpoints and actions, debugger B<O>ptions 
d8103 1
a8103 1
B<o> [I<opt>B<=>I<val>] [I<opt>=B<\">I<val>B<\">] ... 
d8139 1
a8139 1
B<$doccmd> I<manpage>    Runs the external doc viewer B<$doccmd> command on the 
d8218 1
a8218 1
        Set breakpoint at first line of subroutine after 
d8274 1
a8274 1
        history, breakpoints and actions, debugger B<O>ptions 
d8279 1
a8279 1
B<O> [I<opt>B<=>I<val>] [I<opt>=B<\">I<val>B<\">] ... 
d8314 1
a8314 1
B<$doccmd> I<manpage>    Runs the external doc viewer B<$doccmd> command on the 
d8358 1
a8358 1
terminal control characters to simulate them (courtesy of 
d8364 1
a8364 1
    local $_ = shift;
d8372 1
a8372 1
    s{
d8378 1
a8378 1
          ( .* )                # this will now start (no earlier) than 
d8383 1
a8383 1
        $clean =~ s/[BI]<([^>]*)>/$1/g;  
d8393 1
a8393 1
    s{                          # handle bold ornaments
d8396 1
a8396 1
          $Term::ReadLine::TermCap::rl_term_set[2] 
d8401 1
a8401 1
    s{                         # handle italic ornaments
d8404 1
a8404 1
          $Term::ReadLine::TermCap::rl_term_set[0] 
d8410 3
a8412 1
    print $OUT $_;
d8415 1
a8415 1
=head2 C<fix_less> 
d8423 1
a8423 8
sub fix_less {

    # We already know if this is set.
    return if $fixed_less;

    # Pager is less for sure.
    my $is_less = $pager =~ /\bless\b/;
    if ( $pager =~ /\bmore\b/ ) {
d8425 7
d8437 16
a8452 5
             $is_less = @@st_more
          && @@st_less
          && $st_more[0] == $st_less[0]
          && $st_more[1] == $st_less[1];
    } ## end if ($pager =~ /\bmore\b/)
d8456 3
a8458 1
    $fixed_less = 1 if $is_less;
d8499 1
a8499 1
        &warn( Carp::longmess("Signal @@_") );
d8558 1
a8558 1
    &warn($mess);
d8564 2
a8565 2
by loading C<Carp> and calling C<Carp::longmess()> to get it. We turn off 
single stepping and tracing during the call to C<Carp::longmess> to avoid 
d8571 1
a8571 1
displaying the exception via its C<dbwarn()> routine. 
a8579 3
    my $i      = 0;
    my $ineval = 0;
    my $sub;
d8582 1
a8582 1
        &warn(@@_);    # Yell no matter what
d8626 1
a8626 1
        $prevwarn = $SIG{__WARN__} unless $warnLevel;
d8642 1
a8642 1
Similar to C<warnLevel>. Non-zero values for C<dieLevel> result in the 
d8651 1
a8651 1
        $prevdie = $SIG{__DIE__} unless $dieLevel;
d8687 1
a8687 1
signal handler for C<SIGSEGV> and/or C<SIGBUS>. Otherwise, the debugger 
d8694 2
a8695 2
        $prevsegv = $SIG{SEGV} unless $signalLevel;
        $prevbus  = $SIG{BUS}  unless $signalLevel;
d8741 2
d8755 1
a8755 1
A utility routine used in various places; finds the file where a subroutine 
d8765 26
d8793 1
a8793 15
    $sub{$subr} or do {
        return unless defined &$subr;
        my $name = CvGV_name_or_bust($subr);
        my $data;
        $data = $sub{$name} if defined $name;
        return $data if defined $data;

        # Old stupid way...
        $subr = \&$subr;    # Hard reference
        my $s;
        for ( keys %sub ) {
            $s = $_, last if $subr eq \&$_;
        }
        $sub{$s} if $s;
      } ## end do
d8799 1
a8799 1
methods in the class corresponding to the current reference and in 
d8804 2
d8844 13
a8856 12
    while (my ($name, $glob) = each %{"${class}::"}) {
	# references directly in the symbol table are Proxy Constant
	# Subroutines, and are by their very nature defined
	# Otherwise, check if the thing is a typeglob, and if it is, it decays
	# to a subroutine reference, which can be tested by defined.
	# $glob might also be the value -1  (from sub foo;)
	# or (say) '$$' (from sub foo ($$);)
	# \$glob will be SCALAR in both cases.
	if ((ref $glob || ($glob && ref \$glob eq 'GLOB' && defined &$glob))
	    && !$seen{$name}++) {
	    push @@to_print, "$prepend$name\n";
	}
d8860 3
a8862 3
	local $\ = '';
	local $, = '';
	print $DB::OUT $_ foreach sort @@to_print;
d8870 2
a8871 1
    for $name ( @@{"${class}::ISA"} ) {
d8896 1
a8896 1
during debugger initialization). Uses C<DB::system> to avoid mucking up the
d8901 2
a8902 42
sub runman {
    my $page = shift;
    unless ($page) {
        &system("$doccmd $doccmd");
        return;
    }

    # this way user can override, like with $doccmd="man -Mwhatever"
    # or even just "man " to disable the path check.
    unless ( $doccmd eq 'man' ) {
        &system("$doccmd $page");
        return;
    }

    $page = 'perl' if lc($page) eq 'help';

    require Config;
    my $man1dir = $Config::Config{'man1dir'};
    my $man3dir = $Config::Config{'man3dir'};
    for ( $man1dir, $man3dir ) { s#/[^/]*\z## if /\S/ }
    my $manpath = '';
    $manpath .= "$man1dir:" if $man1dir =~ /\S/;
    $manpath .= "$man3dir:" if $man3dir =~ /\S/ && $man1dir ne $man3dir;
    chop $manpath if $manpath;

    # harmless if missing, I figure
    my $oldpath = $ENV{MANPATH};
    $ENV{MANPATH} = $manpath if $manpath;
    my $nopathopt = $^O =~ /dunno what goes here/;
    if (
        CORE::system(
            $doccmd,

            # I just *know* there are men without -M
            ( ( $manpath && !$nopathopt ) ? ( "-M", $manpath ) : () ),
            split ' ', $page
        )
      )
    {
        unless ( $page =~ /^perl\w/ ) {
# do it this way because its easier to slurp in to keep up to date - clunky though.
my @@pods = qw(
a8923 1
    beos
a8947 1
    epoc
a8984 1
    mpeix
a9025 1
    vmesa
d9031 1
d9033 43
a9075 2
            if (grep { $page eq $_ } @@pods) {
                $page =~ s/^/perl/;
d9078 3
a9080 3
                    $page );
            } ## end if (grep { $page eq $_...
        } ## end unless ($page =~ /^perl\w/)
d9102 1
a9102 1
=over 4 
d9154 2
d9207 1
a9207 1
    @@postponed = @@stack = (0);
d9227 1
a9227 1
C<readline> support - adds command completion to basic C<readline>. 
d9230 1
a9230 1
will print the longest common substring following the text already entered. 
d9234 1
a9234 1
This code uses C<map> and C<grep> heavily to create lists of possible 
d9251 1
a9251 1
      ( $text, "^\Q${'package'}::\E([^:]+)\$" );
d9253 1
a9253 1
=head3 C<b postpone|compile> 
d9279 1
a9279 1
=cut 
d9316 1
a9316 1
the subpackages against the text, and discarding all of them which 
d9323 2
a9324 1
      map { /^(.*)::$/ ? ( $prefix . "::$1" ) : () } keys %{ $prefix . '::' }
d9355 3
a9357 3
Under the debugger, source files are represented as C<_E<lt>/fullpath/to/file> 
(C<eval>s are C<_E<lt>(eval NNN)>) keys in C<%main::>. We pull all of these 
out of C<%main::>, add the initial source file, and extract the ones that 
d9395 1
a9395 1
=over 4 
d9424 5
a9428 2
        my @@out = map "$prefix$_", grep /^\Q$text/, grep /^_?[a-zA-Z]/,
          keys %$pack;
d9533 1
a9533 1
=head3 Options 
d9536 1
a9536 1
only a single value, we complete the command in such a way that it is a 
d9566 1
a9566 1
            foreach $l ( split //, qq/\"\'\#\|/ ) {
d9723 1
a9723 1
    my $i = shift; 
d9733 3
a9735 3
        @@args = &restart();              # setup
        &get_list("PERLDB_HIST");        # clean
        &set_list("PERLDB_HIST", @@temp); # reset
d9777 3
a9779 2
        for ( 1 .. $#{'::_<-e'} ) {  # The first line is PERL5DB
            chomp( $cl = ${'::_<-e'}[$_] );
d9819 1
a9819 1
=pod 
d9859 1
a9859 1
        set_list( "PERLDB_FILE_ENABLED_$_", 
d9867 1
a9867 1
    for (@@hard) {
d9869 7
a9875 5
        *dbline = $main::{ '_<' . $_ };
        my ( $quoted, $sub, %subs, $line ) = quotemeta $_;
        for $sub ( keys %sub ) {
            next unless $sub{$sub} =~ /^$quoted:(\d+)-(\d+)$/;
            $subs{$sub} = [ $1, $2 ];
d9878 2
a9879 2
            print $OUT
              "No subroutines in $_, ignoring breakpoints.\n";
d9882 1
a9882 1
      LINES: for $line ( keys %dbline ) {
d9885 2
a9886 2
            my ( $offset, $sub, $found );
          SUBS: for $sub ( keys %subs ) {
d9888 1
a9888 2
                    $subs{$sub}->[1] >=
                    $line    # Not after the subroutine
d9891 1
a9891 1
                        or $offset < 0
d9893 1
a9893 1
                  )
d9897 4
a9900 2
                    $offset = "+$offset", last SUBS
                      if $offset >= 0;
d9905 1
a9905 1
                  "break $offset if $dbline{$line}";
d9908 3
a9910 2
                print $OUT
"Breakpoint in $_:$line ignored: after all the subroutines.\n";
d9932 1
a9932 1
=pod 
d9944 1
a9944 1
    # and then the old arguments. 
d9954 3
a9956 3
Come here at the very end of processing. We want to go into a 
loop where we allow the user to enter commands and interact with the 
debugger, but we don't want anything else to execute. 
d9969 1
a9969 1
1 and the C<END> block simply exits with C<$single> set to 0 (don't 
d9980 1
a9980 1
        &save_hist();
d9989 1
a9989 1
Some of the commands changed function quite a bit in the 5.8 command 
d9994 1
a9994 1
There's an awful lot of duplicated code here. We've duplicated the 
d10023 2
a10024 2
        $i = $1 || $line;
        $j = $2;
d10059 1
a10059 1
=head2 Old C<b> command 
d10074 1
a10074 1
        &cmd_b_load($file);
d10093 1
a10093 1
        $subname = "${'package'}::" . $subname
d10107 1
a10107 1
        &cmd_b_sub( $subname, $cond );
d10113 1
a10113 1
        &cmd_b_line( $i, $cond );
d10137 1
a10137 1
            my $max = $#dbline;
d10141 1
a10141 1
            for ( $i = 1 ; $i <= $max ; $i++ ) {
d10154 1
a10154 1
            } ## end for ($i = 1 ; $i <= $max...
d10174 1
a10174 1
Print help. Defaults to printing the long-form help; the 5.8 version 
d10260 2
a10261 1
        my ($val) = &eval;
d10275 1
a10275 1
The debugger used to have a bunch of nearly-identical code to handle 
d10277 1
a10277 1
C<cmd_prepost> unify all this into one set of code to handle the 
d10293 1
a10293 1
    return &cmd_prepost( $cmd, $line, $dbline );
@


1.15
log
@merge in perl 5.12.2 plus local changes
@
text
@d176 5
a180 3
The array C<@@{$main::{'_<'.$filename}}> (aliased locally to C<@@dbline> via glob
assignment) contains the text from C<$filename>, with each element
corresponding to a single line of C<$filename>.
d515 6
d522 1
a522 1
$VERSION = '1.33';
a714 248

# (We have made efforts to  clarify the comments in the change log
# in other places; some of them may seem somewhat obscure as they
# were originally written, and explaining them away from the code
# in question seems conterproductive.. -JM)

########################################################################
# Changes: 0.94
#   + A lot of things changed after 0.94. First of all, core now informs
#     debugger about entry into XSUBs, overloaded operators, tied operations,
#     BEGIN and END. Handy with `O f=2'.
#   + This can make debugger a little bit too verbose, please be patient
#     and report your problems promptly.
#   + Now the option frame has 3 values: 0,1,2. XXX Document!
#   + Note that if DESTROY returns a reference to the object (or object),
#     the deletion of data may be postponed until the next function call,
#     due to the need to examine the return value.
#
# Changes: 0.95
#   + `v' command shows versions.
#
# Changes: 0.96
#   + `v' command shows version of readline.
#     primitive completion works (dynamic variables, subs for `b' and `l',
#     options). Can `p %var'
#   + Better help (`h <' now works). New commands <<, >>, {, {{.
#     {dump|print}_trace() coded (to be able to do it from <<cmd).
#   + `c sub' documented.
#   + At last enough magic combined to stop after the end of debuggee.
#   + !! should work now (thanks to Emacs bracket matching an extra
#     `]' in a regexp is caught).
#   + `L', `D' and `A' span files now (as documented).
#   + Breakpoints in `require'd code are possible (used in `R').
#   +  Some additional words on internal work of debugger.
#   + `b load filename' implemented.
#   + `b postpone subr' implemented.
#   + now only `q' exits debugger (overwritable on $inhibit_exit).
#   + When restarting debugger breakpoints/actions persist.
#   + Buglet: When restarting debugger only one breakpoint/action per
#             autoloaded function persists.
#
# Changes: 0.97: NonStop will not stop in at_exit().
#   + Option AutoTrace implemented.
#   + Trace printed differently if frames are printed too.
#   + new `inhibitExit' option.
#   + printing of a very long statement interruptible.
# Changes: 0.98: New command `m' for printing possible methods
#   + 'l -' is a synonym for `-'.
#   + Cosmetic bugs in printing stack trace.
#   +  `frame' & 8 to print "expanded args" in stack trace.
#   + Can list/break in imported subs.
#   + new `maxTraceLen' option.
#   + frame & 4 and frame & 8 granted.
#   + new command `m'
#   + nonstoppable lines do not have `:' near the line number.
#   + `b compile subname' implemented.
#   + Will not use $` any more.
#   + `-' behaves sane now.
# Changes: 0.99: Completion for `f', `m'.
#   +  `m' will remove duplicate names instead of duplicate functions.
#   + `b load' strips trailing whitespace.
#     completion ignores leading `|'; takes into account current package
#     when completing a subroutine name (same for `l').
# Changes: 1.07: Many fixed by tchrist 13-March-2000
#   BUG FIXES:
#   + Added bare minimal security checks on perldb rc files, plus
#     comments on what else is needed.
#   + Fixed the ornaments that made "|h" completely unusable.
#     They are not used in print_help if they will hurt.  Strip pod
#     if we're paging to less.
#   + Fixed mis-formatting of help messages caused by ornaments
#     to restore Larry's original formatting.
#   + Fixed many other formatting errors.  The code is still suboptimal,
#     and needs a lot of work at restructuring.  It's also misindented
#     in many places.
#   + Fixed bug where trying to look at an option like your pager
#     shows "1".
#   + Fixed some $? processing.  Note: if you use csh or tcsh, you will
#     lose.  You should consider shell escapes not using their shell,
#     or else not caring about detailed status.  This should really be
#     unified into one place, too.
#   + Fixed bug where invisible trailing whitespace on commands hoses you,
#     tricking Perl into thinking you weren't calling a debugger command!
#   + Fixed bug where leading whitespace on commands hoses you.  (One
#     suggests a leading semicolon or any other irrelevant non-whitespace
#     to indicate literal Perl code.)
#   + Fixed bugs that ate warnings due to wrong selected handle.
#   + Fixed a precedence bug on signal stuff.
#   + Fixed some unseemly wording.
#   + Fixed bug in help command trying to call perl method code.
#   + Fixed to call dumpvar from exception handler.  SIGPIPE killed us.
#   ENHANCEMENTS:
#   + Added some comments.  This code is still nasty spaghetti.
#   + Added message if you clear your pre/post command stacks which was
#     very easy to do if you just typed a bare >, <, or {.  (A command
#     without an argument should *never* be a destructive action; this
#     API is fundamentally screwed up; likewise option setting, which
#     is equally buggered.)
#   + Added command stack dump on argument of "?" for >, <, or {.
#   + Added a semi-built-in doc viewer command that calls man with the
#     proper %Config::Config path (and thus gets caching, man -k, etc),
#     or else perldoc on obstreperous platforms.
#   + Added to and rearranged the help information.
#   + Detected apparent misuse of { ... } to declare a block; this used
#     to work but now is a command, and mysteriously gave no complaint.
#
# Changes: 1.08: Apr 25, 2001  Jon Eveland <jweveland@@yahoo.com>
#   BUG FIX:
#   + This patch to perl5db.pl cleans up formatting issues on the help
#     summary (h h) screen in the debugger.  Mostly columnar alignment
#     issues, plus converted the printed text to use all spaces, since
#     tabs don't seem to help much here.
#
# Changes: 1.09: May 19, 2001  Ilya Zakharevich <ilya@@math.ohio-state.edu>
#   Minor bugs corrected;
#   + Support for auto-creation of new TTY window on startup, either
#     unconditionally, or if started as a kid of another debugger session;
#   + New `O'ption CreateTTY
#       I<CreateTTY>      bits control attempts to create a new TTY on events:
#                         1: on fork()
#                         2: debugger is started inside debugger
#                         4: on startup
#   + Code to auto-create a new TTY window on OS/2 (currently one
#     extra window per session - need named pipes to have more...);
#   + Simplified interface for custom createTTY functions (with a backward
#     compatibility hack); now returns the TTY name to use; return of ''
#     means that the function reset the I/O handles itself;
#   + Better message on the semantic of custom createTTY function;
#   + Convert the existing code to create a TTY into a custom createTTY
#     function;
#   + Consistent support for TTY names of the form "TTYin,TTYout";
#   + Switch line-tracing output too to the created TTY window;
#   + make `b fork' DWIM with CORE::GLOBAL::fork;
#   + High-level debugger API cmd_*():
#      cmd_b_load($filenamepart)            # b load filenamepart
#      cmd_b_line($lineno [, $cond])        # b lineno [cond]
#      cmd_b_sub($sub [, $cond])            # b sub [cond]
#      cmd_stop()                           # Control-C
#      cmd_d($lineno)                       # d lineno (B)
#      The cmd_*() API returns FALSE on failure; in this case it outputs
#      the error message to the debugging output.
#   + Low-level debugger API
#      break_on_load($filename)             # b load filename
#      @@files = report_break_on_load()      # List files with load-breakpoints
#      breakable_line_in_filename($name, $from [, $to])
#                                           # First breakable line in the
#                                           # range $from .. $to.  $to defaults
#                                           # to $from, and may be less than
#                                           # $to
#      breakable_line($from [, $to])        # Same for the current file
#      break_on_filename_line($name, $lineno [, $cond])
#                                           # Set breakpoint,$cond defaults to
#                                           # 1
#      break_on_filename_line_range($name, $from, $to [, $cond])
#                                           # As above, on the first
#                                           # breakable line in range
#      break_on_line($lineno [, $cond])     # As above, in the current file
#      break_subroutine($sub [, $cond])     # break on the first breakable line
#      ($name, $from, $to) = subroutine_filename_lines($sub)
#                                           # The range of lines of the text
#      The low-level API returns TRUE on success, and die()s on failure.
#
# Changes: 1.10: May 23, 2001  Daniel Lewart <d-lewart@@uiuc.edu>
#   BUG FIXES:
#   + Fixed warnings generated by "perl -dWe 42"
#   + Corrected spelling errors
#   + Squeezed Help (h) output into 80 columns
#
# Changes: 1.11: May 24, 2001  David Dyck <dcd@@tc.fluke.com>
#   + Made "x @@INC" work like it used to
#
# Changes: 1.12: May 24, 2001  Daniel Lewart <d-lewart@@uiuc.edu>
#   + Fixed warnings generated by "O" (Show debugger options)
#   + Fixed warnings generated by "p 42" (Print expression)
# Changes: 1.13: Jun 19, 2001 Scott.L.Miller@@compaq.com
#   + Added windowSize option
# Changes: 1.14: Oct  9, 2001 multiple
#   + Clean up after itself on VMS (Charles Lane in 12385)
#   + Adding "@@ file" syntax (Peter Scott in 12014)
#   + Debug reloading selfloaded stuff (Ilya Zakharevich in 11457)
#   + $^S and other debugger fixes (Ilya Zakharevich in 11120)
#   + Forgot a my() declaration (Ilya Zakharevich in 11085)
# Changes: 1.15: Nov  6, 2001 Michael G Schwern <schwern@@pobox.com>
#   + Updated 1.14 change log
#   + Added *dbline explainatory comments
#   + Mentioning perldebguts man page
# Changes: 1.16: Feb 15, 2002 Mark-Jason Dominus <mjd@@plover.com>
#   + $onetimeDump improvements
# Changes: 1.17: Feb 20, 2002 Richard Foley <richard.foley@@rfi.net>
#   Moved some code to cmd_[.]()'s for clarity and ease of handling,
#   rationalised the following commands and added cmd_wrapper() to
#   enable switching between old and frighteningly consistent new
#   behaviours for diehards: 'o CommandSet=pre580' (sigh...)
#     a(add),       A(del)            # action expr   (added del by line)
#   + b(add),       B(del)            # break  [line] (was b,D)
#   + w(add),       W(del)            # watch  expr   (was W,W)
#                                     # added del by expr
#   + h(summary), h h(long)           # help (hh)     (was h h,h)
#   + m(methods),   M(modules)        # ...           (was m,v)
#   + o(option)                       # lc            (was O)
#   + v(view code), V(view Variables) # ...           (was w,V)
# Changes: 1.18: Mar 17, 2002 Richard Foley <richard.foley@@rfi.net>
#   + fixed missing cmd_O bug
# Changes: 1.19: Mar 29, 2002 Spider Boardman
#   + Added missing local()s -- DB::DB is called recursively.
# Changes: 1.20: Feb 17, 2003 Richard Foley <richard.foley@@rfi.net>
#   + pre'n'post commands no longer trashed with no args
#   + watch val joined out of eval()
# Changes: 1.21: Jun 04, 2003 Joe McMahon <mcmahon@@ibiblio.org>
#   + Added comments and reformatted source. No bug fixes/enhancements.
#   + Includes cleanup by Robin Barker and Jarkko Hietaniemi.
# Changes: 1.22  Jun 09, 2003 Alex Vandiver <alexmv@@MIT.EDU>
#   + Flush stdout/stderr before the debugger prompt is printed.
# Changes: 1.23: Dec 21, 2003 Dominique Quatravaux
#   + Fix a side-effect of bug #24674 in the perl debugger ("odd taint bug")
# Changes: 1.24: Mar 03, 2004 Richard Foley <richard.foley@@rfi.net>
#   + Added command to save all debugger commands for sourcing later.
#   + Added command to display parent inheritance tree of given class.
#   + Fixed minor newline in history bug.
# Changes: 1.25: Apr 17, 2004 Richard Foley <richard.foley@@rfi.net>
#   + Fixed option bug (setting invalid options + not recognising valid short forms)
# Changes: 1.26: Apr 22, 2004 Richard Foley <richard.foley@@rfi.net>
#   + unfork the 5.8.x and 5.9.x debuggers.
#   + whitespace and assertions call cleanup across versions 
#   + H * deletes (resets) history
#   + i now handles Class + blessed objects
# Changes: 1.27: May 09, 2004 Richard Foley <richard.foley@@rfi.net>
#   + updated pod page references - clunky.
#   + removed windowid restriction for forking into an xterm.
#   + more whitespace again.
#   + wrapped restart and enabled rerun [-n] (go back n steps) command.
# Changes: 1.28: Oct 12, 2004 Richard Foley <richard.foley@@rfi.net>
#   + Added threads support (inc. e and E commands)
# Changes: 1.29: Nov 28, 2006 Bo Lindbergh <blgl@@hagernas.com> 
#   + Added macosx_get_fork_TTY support 
# Changes: 1.30: Mar 06, 2007 Andreas Koenig <andk@@cpan.org>
#   + Added HistFile, HistSize
# Changes: 1.31
#   + Remove support for assertions and -A
#   + stop NEXT::AUTOLOAD from emitting warnings under the debugger. RT #25053
#   + "update for Mac OS X 10.5" [finding the tty device]
#   + "What I needed to get the forked debugger to work" [on VMS]
#   + [perl #57016] debugger: o warn=0 die=0 ignored
#   + Note, but don't use, PERLDBf_SAVESRC
#   + Fix #7013: lvalue subs not working inside debugger
# Changes: 1.32: Jun 03, 2009 Jonathan Leto <jonathan@@leto.net>
#   + Fix bug where a key _< with undefined value was put into the symbol table
#   +   when the $filename variable is not set
d733 1
a733 1
# compiliation. Probably it would be better practice to fix the warnings,
d841 3
d1227 2
a1228 1
the debugger only handles X Windows, OS/2, and Mac OS X (darwin).
d1238 5
a1242 1
    if (defined $ENV{TERM}                       # If we know what kind
d1313 13
a1325 3
    for ( 0 .. $#had_breakpoints ) {
        my %pf = get_list("PERLDB_FILE_$_");
        $postponed_file{ $had_breakpoints[$_] } = \%pf if %pf;
a1410 17
=item * MacOS - use C<Dev:Console:Perl Debug> if this is the MPW version; C<Dev:
Console> if not.

Note that Mac OS X returns C<darwin>, not C<MacOS>. Also note that the debugger doesn't do anything special for C<darwin>. Maybe it should.

=cut

    elsif ( $^O eq 'MacOS' ) {
        if ( $MacPerl::Version !~ /MPW/ ) {
            $console =
              "Dev:Console:Perl Debug";    # Separate window for application
        }
        else {
            $console = "Dev:Console";
        }
    } ## end elsif ($^O eq 'MacOS')

d1480 1
a1480 8
        require IO::Socket;
        $OUT = new IO::Socket::INET(
            Timeout  => '10',
            PeerAddr => $remoteport,
            Proto    => 'tcp',
        );
        if ( !$OUT ) { die "Unable to connect to remote host: $remoteport\n"; }
        $IN = $OUT;
d1574 1
a1574 1
"\nEnter h or `h h' for help, or `$doccmd perldebug' for more help.\n\n";
a1679 7
    # we need to check for pseudofiles on Mac OS (these are files
    # not attached to a filename, but instead stored in Dev:Pseudo)
    if ( $^O eq 'MacOS' && $#dbline < 0 ) {
        $filename_ini = $filename = 'Dev:Pseudo';
        *dbline = $main::{ '_<' . $filename };
    }

d1685 1
d1699 4
a1702 1
            $dbline{$line} =~ s/;9($|\0)/$1/;
d1800 4
d1806 1
a1806 1
    if ( $single || ( $trace & 1 ) || $was_signal ) {
d1851 1
d1879 1
a1879 1
                print_lineinfo($position);
d1907 1
a1907 1
                    print_lineinfo($incr_pos);
d2083 1
a2083 1
                        print $OUT "Couldn't evaluate `$i' alias: $@@";
d2107 1
a2107 1
=head4 C<t> - trace
d2110 1
d2114 2
a2115 1
                $cmd =~ /^t$/ && do {
d2118 1
d2120 3
a2122 1
                      . ( ( $trace & 1 ) ? "on" : "off" ) . "\n";
d2279 1
a2279 1
                                print $OUT "Choosing $try matching `$file':\n";
d2287 1
a2287 1
                        print $OUT "No file matching `$file' is loaded.\n";
d2563 1
d2586 1
a2586 1
                    # Can't do anythign if the program's over.
d3002 1
a3002 1
                        # Messy metaquoting: Trim the substiution code off.
d3041 1
a3041 1
                        &warn("Can't execute `$1': $!\n");
d3046 32
d3128 1
a3128 1
                        $max_fd = POSIX::sysconf(POSIX::_SC_OPEN_MAX());
d3181 1
a3181 1
                        &warn("Can't pipe output to `$pager'");
d3226 3
a3228 1
                $cmd =~ s/^t\s/\$DB::trace |= 1;\n/;
d3287 1
a3287 1
                        print SAVEOUT "Pager `$pager' failed: ";
d3341 1
a3341 1
        $fall_off_end = 1 unless defined $cmd;    # Emulate `q' on EOF
d3495 1
a3495 1
    # Determine the sub's return type,and capture approppriately.
d3559 1
a3559 1
            $frame & 4    # Extended messsages
d3652 7
d3717 68
d3957 1
a3957 1
    $line =~ s/^\./$dbline/;
d3995 9
a4003 1

d4092 1
a4092 1
    print $OUT "Will stop on load of `@@files'.\n";
d4237 1
a4237 1
    local $filename_error = " of `$f'";
d4280 2
d4299 14
d4330 1
a4330 1
    local $filename_error = " of `$f'";
d4526 2
d4538 4
a4541 1
        delete $dbline{$i} if $dbline{$i} eq '';
d4570 1
d5381 1
a5381 1
    #print $OUT "In postponed_sub for `$subname'.\n";
d5428 1
a5428 1
    # "Cannot be done: unsufficient magic" - we can't just put the
d5611 1
a5611 1
        $file = $file eq '-e' ? $file : "file `$file'" unless $short;
d5926 1
a5926 1
    eval { require Term::ReadLine } or die $@@;
d5933 2
a5934 2
            open( IN,  "<$i" ) or die "Cannot open TTY `$i' for read: $!";
            open( OUT, ">$o" ) or die "Cannot open TTY `$o' for write: $!";
d5944 1
a5944 1
            eval "require Term::Rendezvous;" or die;
d5951 1
a5951 1
            my $term_rv = new Term::Rendezvous $rv;
d5964 1
a5964 1
        $term = new Term::ReadLine::Stub 'perldb', $IN, $OUT;
d5969 1
a5969 1
        $term = new Term::ReadLine 'perldb', $IN, $OUT;
d6039 31
a6069 4
The debugger provides C<get_fork_TTY> functions which work for X Windows,
OS/2, and Mac OS X. Other systems are not supported. You are encouraged
to write C<get_fork_TTY> functions which work for I<your> platform
and contribute them.
d6073 1
a6073 1
This function provides the C<get_fork_TTY> function for X windows. If a 
d6103 1
a6103 1
        eval { require Term::ReadLine } or die $@@;
d6105 1
a6105 1
            $term = new Term::ReadLine::Stub 'perldb', $IN, $OUT;
d6108 1
a6108 1
            $term = new Term::ReadLine 'perldb', $IN, $OUT;
d6404 1
a6404 1
        # Send anyting we have to send.
d6541 1
a6541 1
        s/^(\w+)(\W?)// or print( $OUT "Invalid option `$_'\n" ), last;
d6548 2
a6549 2
        print( $OUT "Unknown option `$opt'\n" ), next unless $matches;
        print( $OUT "Ambiguous option `$opt'\n" ), next if $matches > 1;
d6554 1
a6554 1
            print( $OUT "Option query `$opt?' followed by non-space `$_'\n" ),
d6592 1
a6592 1
              or print( $OUT "Unclosed option value `$opt$sep$_'\n" ), last;
d6600 1
a6600 1
"Option `$opt' is non-boolean.  Use `$cmd $option=VAL' to set, `$cmd $option?' to query\n";
d6613 1
a6613 1
               } || die    # XXX: shouldn't happen
d6741 1
a6741 1
        &warn("Too late to set IN/OUT filehandles, enabled on next `R'!\n");
d6796 2
a6797 2
        open IN,  $in     or die "cannot open `$in' for read: $!";
        open OUT, ">$out" or die "cannot open `$out' for write: $!";
d6808 1
a6808 1
    &warn("Too late to set TTY, enabled on next `R'!\n") if $term and @@_;
d6827 1
a6827 1
        &warn("Too late to set noTTY, enabled on next `R'!\n") if @@_;
d6844 1
a6844 1
        &warn("Too late to set ReadLine, enabled on next `R'!\n") if @@_;
d6893 1
a6893 1
        &warn("Too late to set up NonStop mode, enabled on next `R'!\n")
d7017 1
a7017 1
    open( LINEINFO, "$stream" ) || &warn("Cannot open `$stream' for write");
d7129 2
a7130 2
B<t>        Toggle trace mode.
B<t> I<expr>        Trace through execution of I<expr>.
d7205 1
a7205 1
B<||>I<dbcmd>        Same as B<|>I<dbcmd> but DB::OUT is temporarilly select()ed as well.
d7246 1
a7246 1
    `B<R>' after you set them).
d7256 1
a7256 1
Type `|h h' for a paged display if this was too hard to read.
d7270 1
a7270 1
  B<o> [...]     Set debugger options        B<t> [I<expr>]    Toggle trace [trace expr]
d7321 2
a7322 2
B<t>        Toggle trace mode.
B<t> I<expr>        Trace through execution of I<expr>.
d7329 1
a7329 1
B<b> B<load> I<filename> Set breakpoint on `require'ing the given file.
d7422 1
a7422 1
    `B<R>' after you set them).
d7431 1
a7431 1
Type `|h' for a paged display if this was too hard to read.
d7530 1
a7530 1
C<$ENV{LESS}> so we don't have to go through doing the stats again.
d7537 1
a7537 1
    return if defined $ENV{LESS} && $ENV{LESS} =~ /r/;
d7556 1
a7556 1
    $ENV{LESS} .= 'r' if $is_less;
d7690 1
a7690 1
    # The code used to check $^S to see if compiliation of the current thing
d7971 1
a7971 1
    $doccmd = $^O !~ /^(?:MSWin32|VMS|os2|dos|amigaos|riscos|MacOS|NetWare)\z/s
a8045 1
    apollo
d8569 1
a8569 1
        if (not $text =~ /::/ and eval "require PadWalker; 1" and not $@@ ) {
d8691 1
a8691 1
    print $OUT "Use `q' to quit or `R' to restart.  `h q' for details.\n";
d8796 1
a8796 1
in part left as a useful exersize for the reader.  This sub returns the
d8934 7
d8997 1
a8997 1
    # We are oficially restarting.
a9182 1

d9408 1
a9408 1
"$cmd is now a debugger command\nuse `;$cmd' if you mean Perl code\n";
d9485 1
a9485 1
    "Debugged program terminated.  Use `q' to quit or `R' to restart.";
@


1.14
log
@Merge in some local changes that got lost.
@
text
@d514 1
a514 1
$VERSION = 1.32;
d952 3
d1059 1
d1061 1
a1061 1
	&share(\$main::{'_<'.$filename});
d1853 1
a1853 1
them, and hen send execution off to the next statement.
d4838 15
a4852 24
    eval { require Class::ISA };
    if ($@@) {
        &warn( $@@ =~ /locate/
            ? "Class::ISA module not found - please install\n"
            : $@@ );
    }
    else {
      ISA:
        foreach my $isa ( split( /\s+/, $line ) ) {
            $evalarg = $isa;
            ($isa) = &eval;
            no strict 'refs';
            print join(
                ', ',
                map {    # snaffled unceremoniously from Class::ISA
                    "$_"
                      . (
                        defined( ${"$_\::VERSION"} )
                        ? ' ' . ${"$_\::VERSION"}
                        : undef )
                  } Class::ISA::self_and_super_path(ref($isa) || $isa)
            );
            print "\n";
        }
a8176 1
    machten
a8178 1
    mint
a8192 1
    othrtut
a8607 1

d8631 26
d8665 1
a8665 1
        my @@out = map "$prefix$_", grep /^\Q$text/,
@


1.13
log
@Merge in perl 5.10.1
@
text
@d3011 1
a3011 1
that the terminal supports history). It find the the command required, puts it
@


1.12
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d514 1
a514 1
$VERSION = 1.30;
d944 8
d1374 3
a1376 1
if ( -e "/dev/tty" ) {                      # this is the wrong metric!
d3011 1
a3011 1
that the terminal supports history). It find the command required, puts it
d3638 2
d3648 1
a3648 1
	if ($sub =~ /^threads::new$/ && $ENV{PERL5DB_THREADED}) {
d3789 63
d6178 10
a6853 12
    # With VMS we can get here with $term undefined, so we do not
    # switch to this terminal.  There may be a better place to make
    # sure that $term is defined on VMS
    if ( @@_ and ($^O eq 'VMS') and !defined($term) ) {
	eval { require Term::ReadLine } or die $@@;
        if ( !$rl ) {
	    $term = new Term::ReadLine::Stub 'perldb', $IN, $OUT;
	}
	else {
	    $term = new Term::ReadLine 'perldb', $IN, $OUT;
	}
    }
d7811 2
d7854 3
d8003 1
d8005 14
a8018 5
    my $name;
    for $name (

        # Keep if this is a defined subroutine in this class.
        grep { defined &{ ${"${class}::"}{$_} } }
a8019 3
        # Extract from all the symbols in this class.
        sort keys %{"${class}::"}
      )
d8021 4
a8024 9

        # If we printed this already, skip it.
        next if $seen{$name}++;

        # Print the new method name.
        local $\ = '';
        local $, = '';
        print $DB::OUT "$prepend$name\n";
    } ## end for $name (grep { defined...
d8781 1
d8784 3
@


1.11
log
@merge in perl 5.8.8
@
text
@d224 1
a224 1
If false, a dummy  ReadLine is used, so you can debug
d240 10
d511 1
a511 1
use IO::Handle;
d514 1
a514 1
$VERSION = 1.28;
a699 18
#
# $Log: perl5db.pl,v $
# Revision 1.10  2005/01/15 21:30:31  millert
# sync in-tree perl with 5.8.6
#
# Revision 1.9  2004/08/09 18:09:28  millert
# merge 5.8.5 into HEAD
# remove now-unused files
# crank libperl shared library major number
# update Makefile.bsd-wrapper
# tweak openbsd hints file for arm and m68k
#
# Revision 1.8  2004/04/07 21:33:04  millert
# merge local changes into perl-5.8.3
#
# Revision 1.7  2003/12/03 03:02:36  millert
# Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
#
d940 5
a944 1
####################################################################
a969 9
# test if assertions are supported and actived:
BEGIN {
    $ini_assertion = eval "sub asserting_test : assertion {1}; 1";

    # $ini_assertion = undef => assertions unsupported,
    #        "       = 1     => assertions supported
    # print "\$ini_assertion=$ini_assertion\n";
}

d1083 1
a1083 1
  CommandSet
d1096 1
a1096 1
  DollarCaretP OnlyAssertions WarnAssertions
d1099 1
a1099 1
@@RememberOnROptions = qw(DollarCaretP OnlyAssertions);
d1128 2
a1129 1
    WarnAssertions => \$warnassertions,
a1157 1
    OnlyAssertions=> \&OnlyAssertions,
d1243 1
a1243 1
environment first.  if it's not defined there, we try to find it in
d1325 15
a1339 3
    $pids = "[$ENV{PERLDB_PIDS}]";
    $ENV{PERLDB_PIDS} .= "->$$";
    $term_pid = -1;
d1347 1
a1347 1
    $pids             = "{pid=$$}";
d1450 1
a1450 1
the debugger only handles X Windows and OS/2.
d1456 1
a1456 2
# OS/2. This may need some expansion: for instance, this doesn't handle
# OS X Terminal windows.
d1458 1
a1458 8
if (
    not defined &get_fork_TTY    # no routine exists,
    and defined $ENV{TERM}       # and we know what kind
                                 # of terminal this is,
    and $ENV{TERM} eq 'xterm'    # and it's an xterm,
#   and defined $ENV{WINDOWID}   # and we know what window this is, <- wrong metric
    and defined $ENV{DISPLAY}    # and what display it's on,
  )
d1460 19
a1478 1
    *get_fork_TTY = \&xterm_get_fork_TTY;    # use the xterm version
a1479 3
elsif ( $^O eq 'os2' ) {                     # If this is OS/2,
    *get_fork_TTY = \&os2_get_fork_TTY;      # use the OS/2 version
}
d1736 1
a1736 1
            # outs to open. (They are assumed identiical if not.)
d1855 1
a1855 1
		$tid = eval { "[".threads->self->tid."]" };
d2413 1
a2413 1
                    do 'dumpvar.pl' unless defined &main::dumpvar;
d2612 1
a2612 1
                    do 'dumpvar.pl' unless defined &main::dumpvar;
d3442 4
a3445 2
                STDOUT->flush();
                STDERR->flush();
d3640 1
a3640 1
    # If the last ten characters are C'::AUTOLOAD', note we've traced
d3643 1
a3643 1
        $al = " for $$sub";
d3689 1
a3689 11
        if ($assertion) {
            $assertion = 0;
            eval { @@ret = &$sub; };
            if ($@@) {
                print $OUT $@@;
                $signal = 1 unless $warnassertions;
            }
        }
        else {
            @@ret = &$sub;
        }
d3730 1
a3730 3
        if ($assertion) {
            $assertion = 0;
            eval {
d3732 4
a3735 11
                # Save the value if it's wanted at all.
                $ret = &$sub;
            };
            if ($@@) {
                print $OUT $@@;
                $signal = 1 unless $warnassertions;
            }
            $ret = undef unless defined wantarray;
        }
        else {
            if ( defined wantarray ) {
d3737 4
a3740 10
                # Save the value if it's wanted at all.
                $ret = &$sub;
            }
            else {

                # Void return, explicitly.
                &$sub;
                undef $ret;
            }
        }    # if assertion
d4641 1
a4641 1
		my $tid = threads->self->tid;
d4663 1
a4663 1
		my $tid = threads->self->tid;
a5309 32
=over 4

=item cmd_P

Something to do with assertions

=back

=cut

sub cmd_P {
    unless ($ini_assertion) {
        print $OUT "Assertions not supported in this Perl interpreter\n";
    } else {
        if ( $cmd =~ /^.\b\s*([+-]?)\s*(~?)\s*(\w+(\s*\|\s*\w+)*)\s*$/ ) {
            my ( $how, $neg, $flags ) = ( $1, $2, $3 );
            my $acu = parse_DollarCaretP_flags($flags);
            if ( defined $acu ) {
                $acu = ~$acu if $neg;
                if ( $how eq '+' ) { $^P |= $acu }
                elsif ( $how eq '-' ) { $^P &= ~$acu }
                else { $^P = $acu }
            }

            # else { print $OUT "undefined acu\n" }
        }
        my $expanded = expand_DollarCaretP_flags($^P);
        print $OUT "Internal Perl debugger flags:\n\$^P=$expanded\n";
        $expanded;
    }
}

d5533 1
a5533 1
        do 'dumpvar.pl';
d6015 2
d6027 28
d6068 4
a6071 3
The debugger provides C<get_fork_TTY> functions which work for X Windows and
OS/2. Other systems are not supported. You are encouraged to write 
C<get_fork_TTY> functions which work for I<your> platform and contribute them.
d6114 2
a6115 2
sub os2_get_fork_TTY {
    local $^F = 40;    # XXXX Fixme!
d6117 11
a6127 1
    my ( $in1, $out1, $in2, $out2 );
d6129 66
a6194 10
    # Having -d in PERL5OPT would lead to a disaster...
    local $ENV{PERL5OPT} = $ENV{PERL5OPT} if $ENV{PERL5OPT};
    $ENV{PERL5OPT} =~ s/(?:^|(?<=\s))-d\b//  if $ENV{PERL5OPT};
    $ENV{PERL5OPT} =~ s/(?:^|(?<=\s))-d\B/-/ if $ENV{PERL5OPT};
    print $OUT "Making kid PERL5OPT->`$ENV{PERL5OPT}'.\n" if $ENV{PERL5OPT};
    local $ENV{PERL5LIB} = $ENV{PERL5LIB} ? $ENV{PERL5LIB} : $ENV{PERLLIB};
    $ENV{PERL5LIB} = '' unless defined $ENV{PERL5LIB};
    $ENV{PERL5LIB} = join ';', @@ini_INC, split /;/, $ENV{PERL5LIB};
    ( my $name = $0 ) =~ s,^.*[/\\],,s;
    my @@args;
d6196 3
a6198 3
    if (
            pipe $in1, $out1
        and pipe $in2, $out2
d6200 15
a6214 39
        # system P_SESSION will fail if there is another process
        # in the same session with a "dependent" asynchronous child session.
        and @@args = (
            $rl, fileno $in1, fileno $out2, "Daughter Perl debugger $pids $name"
        )
        and (
            ( $kpid = CORE::system 4, $^X, '-we',
                <<'ES', @@args ) >= 0    # P_SESSION
END {sleep 5 unless $loaded}
BEGIN {open STDIN,  '</dev/con' or warn "reopen stdin: $!"}
use OS2::Process;

my ($rl, $in) = (shift, shift);        # Read from $in and pass through
set_title pop;
system P_NOWAIT, $^X, '-we', <<EOS or die "Cannot start a grandkid";
  open IN, '<&=$in' or die "open <&=$in: \$!";
  \$| = 1; print while sysread IN, \$_, 1<<16;
EOS

my $out = shift;
open OUT, ">&=$out" or die "Cannot open &=$out for writing: $!";
select OUT;    $| = 1;
require Term::ReadKey if $rl;
Term::ReadKey::ReadMode(4) if $rl; # Nodelay on kbd.  Pipe is automatically nodelay...
print while sysread STDIN, $_, 1<<($rl ? 16 : 0);
ES
            or warn "system P_SESSION: $!, $^E" and 0
        )
        and close $in1
        and close $out2
      )
    {
        $pidprompt = '';    # Shown anyway in titlebar
        reset_IN_OUT( $in2, $out1 );
        $tty = '*reset*';
        return '';          # Indicate that reset_IN_OUT is called
    } ## end if (pipe $in1, $out1 and...
    return;
} ## end sub os2_get_fork_TTY
d6264 4
a6267 3
  I know how to switch the output to a different window in xterms
  and OS/2 consoles only.  For a manual switch, put the name of the created I<TTY>
  in B<\$DB::fork_TTY>, or define a function B<DB::get_fork_TTY()> returning this.
d6400 7
a6406 3
        my $stuff;
        $IN->recv( $stuff, 2048 );    # XXX "what's wrong with sysread?"
                                      # XXX Don't know. You tell me.
d6768 13
a6912 27
sub OnlyAssertions {
    if ($term) {
        &warn("Too late to set up OnlyAssertions mode, enabled on next 'R'!\n")
          if @@_;
    }
    if (@@_) {
        unless ( defined $ini_assertion ) {
            if ($term) {
                &warn("Current Perl interpreter doesn't support assertions");
            }
            return 0;
        }
        if (shift) {
            unless ($ini_assertion) {
                print "Assertions will be active on next 'R'!\n";
                $ini_assertion = 1;
            }
            $^P &= ~$DollarCaretP_flags{PERLDBf_SUB};
            $^P |= $DollarCaretP_flags{PERLDBf_ASSERTION};
        }
        else {
            $^P |= $DollarCaretP_flags{PERLDBf_SUB};
        }
    }
    !( $^P & $DollarCaretP_flags{PERLDBf_SUB} ) || 0;
}

a7174 1
B<P> Something to do with assertions...
d7221 1
a7221 1
        Set options.  Use quotes in spaces in value.
d7397 1
a7397 1
        Set options.  Use quotes in spaces in value.
d8701 1
a8701 2
        PERLDBf_ASSERTION => 0x400,    # Debug assertion subs enter/exit
        PERLDB_ALL        => 0x33f,    # No _NONAME, _GOTO, _ASSERTION
a8806 5
    if ( $ini_assertion and @@{^ASSERTING} ) {
        push @@flags,
          ( map { /\:\^\(\?\:(.*)\)\$\)/ ? "-A$1" : "-A$_" }
              @@{^ASSERTING} );
    }
d9018 6
a9023 2
    $DB::single = !$fall_off_end && !$runnonstop;
    DB::fake::at_exit() unless $fall_off_end or $runnonstop;
@


1.10
log
@sync in-tree perl with 5.8.6
@
text
@d218 1
a218 1
uses the value of noTTY or F</tmp/perldbtty$$> to find TTY using
d692 3
d932 1
a932 1
#   + Added command to display parent inheritence tree of given class.
d2055 2
a2056 2
  use B<O> I<inhibit_exit> to avoid stopping after program termination,
  B<h q>, B<h R> or B<h O> to get additional info.  
d2764 1
a2764 1
                    # preceeding block has moved us to the proper file and
d6025 2
a6026 2
            # Use /tmp/perldbtty$$ if not.
            my $rv = $ENV{PERLDB_NOTTY} || "/tmp/perldbtty$$";
d6655 1
a6655 1
get all confused if we do, particularily under I<unsafe signals>.
d8333 1
a8333 1
Add C<postpone>, C<load>, and C<compile> as possibles (we may be completing the keyword itself
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d4 1
a4 1
C<perl5db.pl> - the perl debugger
d43 1
a43 1
i<are> debugger internals, and are therefore subject to change. Future
d107 1
a107 1
the second pair applies when it isn't. The XOR simply allows us to
d115 1
a115 1
such as C<$single>, C<$trace>, and C<$frame>, have "magical" values composed
d135 1
d137 1
a137 1
=item * First, doing an arithmetical or bitwise operation on a scalar is
d139 1
a139 1
creates a subroutine call, and array hand hash lookups are much slower. Is
d146 3
a148 1
=item * Second, it's very easy to serialize a scalar number. This is done in 
d153 3
a155 1
=item * Third, some of these variables are being shared with the Perl core 
d184 1
a184 1
considered to be a breakpoint; C<perl5db.pl> uses "$break_condition\0$action".
d187 4
a190 1
The scalar ${'_<'.$filename} contains $filename  XXX What?
d201 1
a201 1
contents as the argument of a debugger <C<o> command.
d218 1
a218 1
uses the value of noTTY or "/tmp/perldbtty$$" to find TTY using
d249 1
a249 1
reset C<LineInfo> to something "interactive"!)
d256 1
a256 1
a C<&DB'DB();> in front of each place that can have a
d301 1
a301 1
=item * 1 - Print "entering" messages on subroutine entry
d305 1
a305 1
=item * 4 - Extended messages: C<in|out> I<context>=I<fully-qualified sub name> from I<file>:I<line>>. If no other flag is on, acts like 1+4.
d313 1
a313 1
To get everything, use C<$frame=30> (or C<o f-30> as a debugger command).
d341 1
a341 1
Controls how far down C<dumpvar.pl> will go before printing '...' while
d359 1
a359 1
=item * 1 - single-step, go into subs. The 's' command.
d361 1
a361 1
=item * 2 - single-step, don't go into subs. The 'n' command.
d363 2
a364 2
=item * 4 - print current sub depth (turned on to force this when "too much
recursion" occurs.
d433 1
a433 1
Keys are line numbers, values are "condition\0action". If used in numeric
d462 1
a462 1
=item * 'compile' - break when this sub is compiled
d464 1
a464 1
=item * 'break +0 if <condition>' - break (conditionally) at the start of this routine. The condition will be '1' if no condition was specified.
d473 1
a473 1
definitions ("condition\0action").
d504 1
a504 1
$VERSION = 1.27;
d518 6
a523 6
We preserve the current settings of X<C<$trace>>, X<C<$single>>, and X<C<$^D>>;
add the X<C<$usercontext>> (that's the preserved values of C<$@@>, C<$!>,
C<$^E>, C<$,>, C<$/>, C<$\>, and C<$^W>, grabbed when C<DB::DB> got control,
and the user's current package) and a add a newline before we do the C<eval()>.
This causes the proper context to be used when the eval is actually done.
Afterward, we restore C<$trace>, C<$single>, and C<$^D>.
d530 2
a531 2
it on the debugger's output. If X<C<$onetimedump>> is defined, we call 
X<C<dumpit>> if it's set to 'dump', or X<C<methods>> if it's set to 
d551 1
a551 1
=item C<$trace> - Current state of execution tracing (see X<$trace>)
d553 1
a553 1
=item C<$single> - Current state of single-stepping (see X<$single>)        
d692 7
d943 2
d982 45
d1032 1
a1032 1
                    # These variables control the execution of 'dumpvar.pl'.
d1058 4
d1229 11
d1279 2
a1280 2
recall character ("!" unless otherwise defined) and the shell escape
character ("!" unless otherwise defined). Yes, these do conflict, and
d1308 1
a1308 1
The debugger 'greeting'  helps to inform the user how many debuggers are
d1515 5
d1556 1
d1611 3
a1613 1
Console> if not. (Note that Mac OS X returns 'darwin', not 'MacOS'. Also note that the debugger doesn't do anything special for 'darwin'. Maybe it should.)
d1772 2
d1834 1
a1834 1
to create other commands to be executed later. This is all highly "optimized"
d1842 7
d1978 7
a1984 1
=item * Returning a false value from the C<watchfunction()> itself.
d1986 1
a1986 1
=item * Altering C<$single> to a false value.
d1988 1
a1988 1
=item * Altering C<$signal> to a false value.
d1990 3
a1992 1
=item *  Turning off the '4' bit in C<$trace> (this also disables the
d2176 2
a2177 2
C<$incr> controls by how many lines the "current" line should move forward
after a command is executed. If set to -1, this indicates that the "current"
d2180 1
a2180 1
C<$start> is the "current" line. It is used for things like knowing where to
d2193 3
a2195 1
=item * The outer part of the loop, starting at the C<CMD> label. This loop
d2198 3
a2200 1
=item * The inner part of the loop, starting at the C<PIPE> label. This part
d2229 1
a2229 1
                        "$pidprompt  DB"
d2238 1
d2255 1
a2255 1
A newline entered by itself means "re-execute the last command". We grab the
d2269 2
d2579 1
a2579 1
                $cmd =~ /^([aAbBhilLMoOPvwW]\b|[<>\{]{1,2})\s*(.*)/so && do {
d2640 1
a2640 1
when entered (see X<DB::sub>). We also save the C<n> command in C<$laststep>,
d2659 1
a2659 1
Sets C<$single> to 1, which causes X<DB::sub> to continue tracing inside     
d3037 1
a3037 1
If a command is found, it is placed in C<$cmd> and executed via <redo>.
d3303 18
d3330 1
a3330 1
FOR C<|>, we save C<OUT> (the debugger's output filehandle) and C<STDOUT>
d3558 1
a3558 1
setting the 4 bit in C<$single>. In any case, it keeps the current setting
d3582 1
a3582 1
The subroutine name; C<'(eval)'> if an C<eval>().
d3606 1
a3606 1
pragma information: subject to change between versions
d3618 3
d3625 3
d3816 2
a3817 2
Note that trying to set the CommandSet to 'foobar' simply results in the
5.8.0 command set being used, since there's no top-level entry for 'foobar'.
d3854 1
a3854 1
It tries to look up the command in the X<C<%set>> package-level I<lexical>
d4160 1
a4160 1
initialized to C<''>, no filename will appear when we are working on the
d4167 5
a4171 1
=item * Localizes C<$filename_error> and sets it to the name of the file to be processed.
d4173 1
a4173 1
=item * Localizes the C<*dbline> glob and reassigns it to point to the file we want to process. 
d4175 1
a4175 1
=item * Calls the first function. 
d4177 3
a4179 1
The first function works on the "current" (i.e., the one we changed to) file,
d4181 4
a4184 3
if it needs to. When the functions return, C<*dbline> is restored to point to the actual current file (the one we're executing in) and C<$filename_error> is 
restored to C<''>. This restores everything to the way it was before the 
second function was called at all.
d4195 1
a4195 1
=head3 breakable_line($from, $to) (API)
d4278 1
a4278 1
=head3 breakable_line_in_filename($file, $from, $to) (API)
d4637 47
d4690 3
a4692 1
=item * Showing all the debugger help
d4694 3
a4696 1
=item * Showing help for a specific command
d5264 1
a5264 1
the 'watching expressions' bit.
d5324 2
d5330 2
d5541 1
a5541 1
installed version in @@INC, yours will be used instead. Possible security 
d5619 9
a5627 1
=item * The filehandle to print to.
d5629 1
a5629 1
=item * How many frames to skip before starting trace.
d5631 1
a5631 1
=item * How many frames to print.
d5633 1
a5633 1
=item * A flag: if true, print a "short" trace without filenames, line numbers, or arguments
d5898 1
a5898 1
Of note is the definition of the $balanced_brace_re global via ||=, which
d5923 1
a5923 1
it just reads more input with X<C<readline()>> and returns it.
d6466 1
a6466 1
An option entered by itself is assumed to be 'set me to 1' (the default value)
d6468 1
a6468 1
value or to query the current value (via 'option? ').
d6470 1
a6470 1
If 'option=value' is entered, we try to extract a quoted string from the
d6652 1
a6652 1
get all confused if we do.
d6795 1
a6795 1
(essentially, no C<readline> processing on this "terminal"). Otherwise, we
d7020 3
a7022 3
Essentially just runs through the keys in %INC, picks up the 
$VERSION package globals from each package, gets the file name, and formats the
information for output.
d7060 2
a7061 2
The help message is a peculiar format unto itself; it mixes C<pod> 'ornaments'
(BE<lt>E<gt>, IE<gt>E<lt>) with tabs to come up with a format that's fairly
d7065 4
a7068 3
Essentially, you define the command name (usually marked up with BE<gt>E<lt>
and IE<gt>E<lt>), followed by a tab, and then the descriptive text, ending in a newline. The descriptive text can also be marked up in the same way. If you 
need to continue the descriptive text to another line, start that line with 
d7154 2
d7273 1
d7459 1
a7459 1
<Term::ReadLine::TermCap>).
d7802 1
a7802 1
Wrapper for X<CvGV_name_or_bust>; tries to get the name of a reference
d7804 1
a7804 1
reference is stringified, it'll come out as "SOMETHING(0X...)").
d7820 1
a7820 1
Returns "I<package>::I<glob name>" if the code ref is found in a glob.
d7839 4
a7842 4
Tries to use X<@@sub> first; if it can't find it there, it tries building a
reference to the subroutine and uses X<CvGV_name_or_bust> to locate it,
loading it into X<@@sub> as a side effect (XXX I think). If it can't find it
this way, it brute-force searches X<%sub>, checking for identical references.
d7867 1
a7867 1
A subroutine that uses the utility function X<methods_via> to find all the
d8173 11
a8183 1
=item * The debugger's own filehandles (copies of STD and STDOUT for now).
d8185 1
a8185 1
=item * Characters for shell escapes, the recall command, and the history command.
d8187 1
a8187 1
=item * The maximum recursion depth.
d8189 1
a8189 1
=item * The size of a C<w> command's window.
d8191 1
a8191 1
=item * The before-this-line context to be printed in a C<v> (view a window around this line) command.
d8193 1
a8193 1
=item * The fact that we're not in a sub at all right now.
d8195 1
a8195 1
=item * The default SIGINT handler for the debugger.
d8197 1
a8197 1
=item * The appropriate value of the flag in C<$^D> that says the debugger is running
d8199 1
a8199 1
=item * The current debugger recursion level
d8201 1
a8201 1
=item * The list of postponed (XXX define) items and the C<$single> stack
d8203 13
a8215 1
=item * That we want no return values and no subroutine entry/exit trace.
d8324 1
a8324 1
=item * Find all the subroutines that might match in this package
d8326 1
a8326 1
=item * Add "postpone", "load", and "compile" as possibles (we may be completing the keyword itself
d8328 1
a8328 1
=item * Include all the rest of the subs that are known
d8330 1
a8330 1
=item * C<grep> out the ones that match the text we have so far
d8332 11
a8342 1
=item * Return this as the list of possible completions
d8355 1
a8355 1
Get all the possible files from @@INC as it currently stands and
d8463 3
a8465 1
=item * Determine the package that the symbol is in. Put it in C<::> (effectively C<main::>) if no package is specified.
d8473 3
a8475 1
=item * Figure out the prefix vs. what needs completing.
d8484 3
a8486 1
=item * Look through all the symbols in the package. C<grep> out all the possible hashes/arrays/scalars, and then C<grep> the possible matches out of those. C<map> the prefix onto all the possibilities.
d8495 3
a8497 1
=item * If there's only one hit, and it's a package qualifier, and it's not equal to the initial text, re-complete it using the symbol we actually found.
d8524 3
a8526 1
=item * If it's C<main>, delete main to just get C<::> leading.
d8534 3
a8536 1
=item * We set the prefix to the item's sigil, and trim off the sigil to get the text to be completed.
d8545 3
a8547 1
=item * If the package is C<::> (C<main>), create an empty list; if it's something else, create a list of all the packages known.  Append whichever list to a list of all the possible symbols in the current package. C<grep> out the matches to the text entered so far, then C<map> the prefix back onto the symbols.
d8555 3
a8557 1
=item * If there's only one hit, it's a package qualifier, and it's not equal to the initial text, recomplete using this symbol.
d8739 2
d8978 2
d8993 1
a8993 1
We then call C<DB::fake::at_exit()>, which returns the C<Use 'q' to quit ...">
d9023 1
a9023 1
Does nothing. Used to 'turn off' commands.
d9322 1
a9322 1
Actually does all the handling foe C<E<lt>>, C<E<gt>>, C<{{>, C<{>, etc.
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d1 1
d193 1
a193 1
contents as the argument of a debugger <C<O> command.
d496 1
a496 1
$VERSION = 1.23;
d498 1
a498 1
$header  = "perl5db.pl version $VERSION";
d600 1
a600 1
    #    but so does local! --tchrist  
d604 4
a607 3
        # Try to keep the user code from messing  with us. Save these so that 
        # even if the eval'ed code changes them, we can put them back again. 
        # Needed because the user could refer directly to the debugger's 
d610 1
a610 1
        local $otrace  = $trace; 
d617 1
a617 1
        # $usercontext built in DB::DB near the comment 
d620 1
a620 2
        @@res =
          eval "$usercontext $evalarg;\n";    # '\n' for nice recursive debug
d634 1
a634 1
    local $saved[0];                          # Preserve the old value of $@@
d646 1
a646 1
        if ($onetimeDump eq 'dump') {
d649 1
a649 1
            dumpit($OUT, \@@res);
d651 2
a652 2
        elsif ($onetimeDump eq 'methods') {
            methods($res[0]);
d661 1
a661 1
# The code being debugged will be executing in its own context, and 
d664 1
a664 1
# However, one should not overdo it: leave as much control from outside as    
d671 1
a671 1
# Before venturing further into these twisty passages, it is 
d675 1
a675 1
# the uderlying mechanics of how the debugger interfaces into the
d684 3
d718 1
a718 1
# Changes: 0.96 
d735 1
a735 1
#   + Buglet: When restarting debugger only one breakpoint/action per 
d768 2
a769 2
#     to restore Larry's original formatting.  
#   + Fixed many other formatting errors.  The code is still suboptimal, 
d773 1
a773 1
#     shows "1".  
d816 1
a816 1
#                         1: on fork()   
d844 1
a844 1
#                                           # to $from, and may be less than 
d848 1
a848 1
#                                           # Set breakpoint,$cond defaults to 
d872 1
a872 1
#   + Added windowSize option 
d887 2
a888 2
#   rationalised the following commands and added cmd_wrapper() to 
#   enable switching between old and frighteningly consistent new 
d892 1
a892 1
#   + w(add),       W(del)            # watch  expr   (was W,W) 
d912 16
a927 1

d954 9
d970 1
a970 1
    # These variables control the execution of 'dumpvar.pl'.
d1006 2
a1007 2
$trace = $signal = $single = 0;   # Uninitialized warning suppression
                                  # (local $^W cannot help - other packages!).
d1027 17
a1043 14
             CommandSet
             hashDepth    arrayDepth    dumpDepth
             DumpDBFiles  DumpPackages  DumpReused
             compactDump  veryCompact   quote
             HighBit      undefPrint    globPrint 
             PrintRet     UsageOnly     frame
             AutoTrace    TTY           noTTY 
             ReadLine     NonStop       LineInfo 
             maxTraceLen  recallCommand ShellBang
             pager        tkRunning     ornaments
             signalLevel  warnLevel     dieLevel 
             inhibit_exit ImmediateStop bareStringify 
             CreateTTY    RemotePort    windowSize
           );
d1072 2
a1073 1
    );
d1100 3
a1102 1
    );
d1120 1
a1120 1
    );
d1184 1
d1186 2
a1187 2
    defined $ENV{PAGER} 
      ? $ENV{PAGER}
d1190 3
a1192 2
      : eval { require Config } && defined $Config::Config{pager} 
        ? $Config::Config{pager}
d1195 1
a1195 1
        : 'more'
d1249 1
a1249 1
# Save the current contents of the environment; we're about to 
d1253 2
a1254 1
if (defined $ENV{PERLDB_PIDS}) { 
d1256 1
a1256 1
    # recorded in PERLDB_PIDS plus our (new) PID. Mark us as not having 
d1263 2
a1264 1
    # We're the parent PID. Initialize PERLDB_PID in case we end up with a 
d1268 2
a1269 2
    $pids     = "{pid=$$}";
    $term_pid = $$;
d1275 1
a1275 1
*emacs     = $slave_editor if $slave_editor;   # May be used in afterinit()...
d1286 2
a1287 1
if (-e "/dev/tty") {                           # this is the wrong metric!
d1315 1
a1315 1
    unless (is_safe_file($file)) {
d1334 1
a1334 1
# eventually accessed is the same as the one tested. 
d1339 1
a1339 1
    my ($dev, $ino, $mode, $nlink, $uid, $gid) = stat(_);
d1347 2
a1348 2
# exists, we safely do it. 
if (-f $rcfile) {
d1351 1
d1353 1
a1353 1
elsif (defined $ENV{HOME} && -f "$ENV{HOME}/$rcfile") {
d1356 1
d1358 1
a1358 1
elsif (defined $ENV{LOGDIR} && -f "$ENV{LOGDIR}/$rcfile") {
d1363 2
a1364 2
if (defined $ENV{PERLDB_OPTS}) {
    parse_options($ENV{PERLDB_OPTS});
d1378 1
a1378 1
# OS X Terminal windows.       
d1380 8
a1387 8
if (not defined &get_fork_TTY                        # no routine exists,
    and defined $ENV{TERM}                           # and we know what kind
                                                     # of terminal this is,
    and $ENV{TERM} eq 'xterm'                        # and it's an xterm,
    and defined $ENV{WINDOWID}                       # and we know what
                                                     # window this is,
    and defined $ENV{DISPLAY})                       # and what display it's
                                                     # on,
d1389 1
a1389 1
    *get_fork_TTY = \&xterm_get_fork_TTY;            # use the xterm version
d1391 2
a1392 2
elsif ($^O eq 'os2') {                               # If this is OS/2,
    *get_fork_TTY = \&os2_get_fork_TTY;              # use the OS/2 version
d1394 1
d1397 2
a1398 1
$^O =~ m/^(.*)\z/; $^O = $1;
d1400 1
a1400 1
# "Here begin the unreadable code.  It needs fixing." 
d1428 2
a1429 1
if (exists $ENV{PERLDB_RESTART}) {
d1432 1
d1440 1
a1440 1
    for (0 .. $#had_breakpoints) {
d1447 2
a1448 2
    my ($opt, $val);
    while (($opt, $val) = each %opt) {
d1454 2
a1455 2
    @@INC       = get_list("PERLDB_INC");
    @@ini_INC   = @@INC;
d1458 4
a1461 4
    $pretype   = [get_list("PERLDB_PRETYPE")];
    $pre       = [get_list("PERLDB_PRE")];
    $post      = [get_list("PERLDB_POST")];
    @@typeahead = get_list("PERLDB_TYPEAHEAD", @@typeahead);
d1486 1
d1490 3
a1492 2
      ((defined $main::ARGV[0]) and ($main::ARGV[0] eq '-emacs'));
    $rl = 0, shift (@@main::ARGV) if $slave_editor;
d1505 1
a1506 1
    if ($^O eq 'cygwin') {
d1515 1
a1515 1
    elsif (-e "/dev/tty") {
d1523 1
a1523 1
    elsif ($^O eq 'dos' or -e "con" or $^O eq 'MSWin32') {
d1532 2
a1533 2
    elsif ($^O eq 'MacOS') {
        if ($MacPerl::Version !~ /MPW/) {
d1547 1
d1562 2
a1563 1
    if (($^O eq 'MSWin32') and ($slave_editor or defined $ENV{EMACS})) {
d1568 2
a1569 1
    if ($^O eq 'NetWare') {
d1576 1
a1576 1
    if (defined $ENV{OS2_SHELL} and ($slave_editor or $ENV{WINDOWID}))
d1580 1
d1582 1
a1582 1
    if ($^O eq 'epoc') {
d1606 3
a1608 1
    if (defined $remoteport) {
d1616 2
a1617 2
            );
        if (!$OUT) { die "Unable to connect to remote host: $remoteport\n"; }
d1633 1
d1636 1
a1636 1
        # filehandle, and do the necessary mojo to create a new tty if we 
d1640 1
d1643 2
a1644 1
            my ($i, $o) = split /,/, $console;
d1648 3
a1650 3
            open(IN, "+<$i") || 
             open(IN, "<$i") || 
              open(IN, "<&STDIN");
d1654 4
a1657 4
            open(OUT,   "+>$o")     ||
              open(OUT, ">$o")      ||
              open(OUT, ">&STDERR") ||
              open(OUT, ">&STDOUT");    # so we don't dongle stdout
d1660 4
a1663 7
        elsif (not defined $console) {
           # No console. Open STDIN.
            open(IN,    "<&STDIN");

           # merge with STDERR, or with STDOUT.
            open(OUT,   ">&STDERR") ||
              open(OUT, ">&STDOUT");     # so we don't dongle stdout
d1665 3
d1676 1
a1676 1
    # Unbuffer DB::OUT. We need to see responses right away. 
d1678 1
a1678 1
    $| = 1;                              # for DB::OUT
d1683 1
a1683 1
    # keep track of file and position. We have both a filehandle 
d1700 1
a1700 1
        if ($term_pid eq '-1') {
d1708 1
a1708 1
                );
d1721 2
a1722 2
    s/\'/\\\'/g;
    s/(.*)/'$1'/ unless /^-?[\d.]+$/;
d1725 1
a1725 1
# If there was an afterinit() sub defined, call it. It will get 
d1727 1
a1727 1
if (defined &afterinit) {    # May be defined in $rcfile
d1730 1
d1757 2
a1758 1
    if ($single and not $second_time++) {
d1761 4
a1764 4
            # If there's any call stack in place, turn off single
            # stepping into subs throughout the stack.
            for ($i = 0 ; $i <= $stack_depth ;) {
                $stack[$i++] &= ~1;
d1766 1
d1772 1
a1772 1
            # return; 
d1776 5
a1780 4
            # We are supposed to stop here; XXX probably a break. 
            $ImmediateStop = 0;               # We've processed it; turn it off
            $signal        = 1;               # Simulate an interrupt to force
                                              # us into the command loop
d1794 1
a1794 1
    # caller is returning all the extra information when called from the 
d1796 1
a1796 1
    local ($package, $filename, $line) = caller;
d1802 2
a1803 3
    local $usercontext  =
      '($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;' .
      "package $package;"; 
d1811 1
a1811 1
    if ($^O eq 'MacOS' && $#dbline < 0) {
d1820 4
a1823 1
    if ($dbline{$line} && (($stop, $action) = split (/\0/, $dbline{$line}))) {
d1825 1
a1825 1
        if ($stop eq '1') {
d1828 1
d1843 2
a1844 2
    if ($trace & 2) {
        for (my $n = 0 ; $n <= $#to_watch ; $n++) {
d1850 2
a1851 3
            my ($val) =
              join ( "', '", &eval );
            $val = ((defined $val) ? "'$val'" : 'undef');
d1854 2
a1855 1
            if ($val ne $old_watch[$n]) {
d1860 2
a1861 2
	old value:\t$old_watch[$n]
	new value:\t$val
d1899 1
a1899 1
    # If there's a user-defined DB::watchfunction, call it with the 
d1902 1
a1902 1
    if ($trace & 4) {    # User-installed watch
d1904 1
a1904 1
          if watchfunction($package, $filename, $line)
d1907 1
a1907 1
          and not($trace & ~4);
d1910 1
a1910 2

    # Pick up any alteration to $signal in the watchfunction, and 
d1926 2
a1927 1
    if ($single || ($trace & 1) || $was_signal) {
d1930 1
d1944 2
a1945 1
        elsif ($package eq 'DB::fake') {
d1957 2
a1958 2
              '($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;' .
              "package $package;";    # this won't let them modify, alas
d1970 1
d1974 1
a1974 1
                                 # Perl 5 ones (sorry, we don't print Klingon 
d1979 1
a1979 1
            $after = ($dbline[$line] =~ /\n$/ ? '' : "\n");
d1982 1
a1982 1
            if (length($prefix) > 30) {
d1994 2
a1995 2
                print_lineinfo(' ' x $stack_depth,
                    "$line:\t$dbline[$line]$after");
d2003 1
a2003 1
            for ($i = $line + 1 ; $i <= $max && $dbline[$i] == 0 ; ++$i)
d2011 1
a2011 1
               
d2014 1
a2014 1
                $after = ($dbline[$i] =~ /\n$/ ? '' : "\n");
d2020 1
d2022 2
a2023 2
                    print_lineinfo(' ' x $stack_depth,
                        "$i:\t$dbline[$i]$after");
d2044 2
a2045 1
    if ($single || $was_signal) {
d2060 2
a2061 2
        $start     = $line;
        $incr      = -1;                        # for backward motion.
d2064 1
a2064 1
        @@typeahead = (@@$pretype, @@typeahead);
d2113 1
d2115 2
a2116 1
            ($term || &setterm),
d2118 2
a2119 1
            ($term_pid == $$ or resetterm(1)),
d2123 4
a2126 2
                    "$pidprompt  DB" . ('<' x $level) . ($#hist + 1) .
                      ('>' x $level) . " "
d2131 1
d2158 8
a2165 7
            $cmd =~ /^$/ && ($cmd = $laststep);
            push (@@hist, $cmd) if length($cmd) > 1;


          # This is a restart point for commands that didn't arrive
          # via direct user input. It allows us to 'redo PIPE' to
          # re-execute command processing without reading a new command.
d2169 1
a2169 1
                ($i) = split (/\s+/, $cmd);
d2181 2
a2182 1
                if ($alias{$i}) {
d2228 2
a2229 2
                    print $OUT "Trace = " . (($trace & 1) ? "on" : "off") .
                      "\n";
d2241 1
a2241 1
                    $Srev     = defined $2;     # Reverse scan? 
d2253 2
a2254 2
                    foreach $subname (sort(keys %sub)) {
                        if ($Snocheck or $Srev ^ ($subname =~ /$Spatt/)) {
a2281 1

d2284 1
d2292 1
a2292 1
                    @@vars = split (' ', $2);
d2296 2
a2297 1
                    if (defined &main::dumpvar) {
d2310 1
a2310 1
                                : -1,          # assume -1 unless specified
d2312 1
a2312 1
                                );
d2315 1
a2315 1
                        # The die doesn't need to include the $@@, because 
d2322 1
d2326 1
d2339 2
a2340 2
                $cmd =~ s/^x\b/ / && do {   # Remainder gets done by DB::eval()
                    $onetimeDump = 'dump';  # main::dumpvar shows the output
d2344 1
a2344 1
                    if ($cmd =~ s/^\s*(\d+)(?=\s)/ /) {
d2361 2
a2362 2
                $cmd =~ s/^m\b/ / && do {     # Rest gets done by DB::eval()
                    $onetimeDump = 'methods'; #  method output gets used there
d2374 1
a2374 1
                    if (!$file) {
d2376 1
a2376 1
                          "The old f command is now the r command.\n";  # hint
d2382 2
a2383 2
                    if (!defined $main::{ '_<' . $file }) {
                        if (($try) = grep(m#^_<.*$file#, keys %main::)) {
d2385 2
a2386 3
                                $try = substr($try, 2);
                                print $OUT
                                  "Choosing $try matching `$file':\n";
d2393 1
a2393 1
                    if (!defined $main::{ '_<' . $file }) {
d2399 1
a2399 1
                    elsif ($file ne $filename) {
d2423 1
a2423 1
                    $incr     = -1;              # stay at current line
d2428 2
a2429 2
                    *dbline = $main::{ '_<' . $filename };
                    $max    = $#dbline;
d2447 1
d2451 1
a2451 1
                    $incr = $window - 1;
d2469 3
a2471 3
                # we send them off to the secondary dispatcher (see below). 
                $cmd =~ /^([aAbBhlLMoOvwW]\b|[<>\{]{1,2})\s*(.*)/so && do {
                    &cmd_wrapper($1, $2, $line);
d2500 1
a2500 1
                    my @@vars = split (' ', $2 || '');
d2503 1
a2503 1
                    my $h = eval { PadWalker::peek_my(($1 || 0) + 1) };
d2512 1
a2512 3
                    dumpvar::dumplex(
                        $_,
                        $h->{$_},
d2514 2
a2515 2
                        @@vars
                    ) for sort keys %$h;
d2536 1
a2536 1
                # n - next 
d2539 1
d2541 2
a2542 1
                    $single   = 2;
d2557 1
d2561 1
d2563 2
a2564 1
                    $single   = 1;
d2581 1
d2600 3
a2602 3
                    if ($subname =~ /\D/) {    # subroutine name
                        # Qualify it to the current package unless it's
                        # already qualified.
d2605 1
d2608 1
a2608 1
                        # break up the return value, and assign it in one 
d2610 1
a2610 1
                        ($file, $i) = (find_sub($subname) =~ /^(.*):(.*)$/);
d2617 1
d2622 1
d2625 1
d2645 4
a2648 4
                    # got a request to break at some line somewhere. On 
                    # one hand, if there wasn't any real subroutine name 
                    # involved, this will be a request to break in the current 
                    # file at the specified line, so we have to check to make 
d2661 1
d2663 1
a2663 1
                        if ($dbline[$i] == 0) {
d2667 1
d2669 1
a2669 2
                        $dbline{$i} =~
                          s/($|\0)/;9$1/;    # add one-time-only b.p.
d2673 2
a2674 2
                    for ($i = 0 ; $i <= $stack_depth ;) {
                        $stack[$i++] &= ~1;
d2691 1
d2694 1
d2697 1
a2702 197
=head4 C<R> - restart

Restarting the debugger is a complex operation that occurs in several phases.
First, we try to reconstruct the command line that was used to invoke Perl
and the debugger.

=cut

                # R - restart execution.
                $cmd =~ /^R$/ && do {
                    # I may not be able to resurrect you, but here goes ...
                    print $OUT
"Warning: some settings and command-line options may be lost!\n";
                    my (@@script, @@flags, $cl);

                    # If warn was on before, turn it on again.
                    push @@flags, '-w' if $ini_warn;

                    # Rebuild the -I flags that were on the initial
                    # command line.
                    for (@@ini_INC) {
                        push @@flags, '-I', $_;
                    }

                    # Turn on taint if it was on before.
                    push @@flags, '-T' if ${^TAINT};

                    # Arrange for setting the old INC:
                    # Save the current @@init_INC in the environment.
                    set_list("PERLDB_INC", @@ini_INC);

                    # If this was a perl one-liner, go to the "file"
                    # corresponding to the one-liner read all the lines
                    # out of it (except for the first one, which is going
                    # to be added back on again when 'perl -d' runs: that's
                    # the 'require perl5db.pl;' line), and add them back on
                    # to the command line to be executed.
                    if ($0 eq '-e') {
                        for (1 .. $#{'::_<-e'}) {  # The first line is PERL5DB
                            chomp($cl = ${'::_<-e'}[$_]);
                            push @@script, '-e', $cl;
                        }
                    } ## end if ($0 eq '-e')

                    # Otherwise we just reuse the original name we had 
                    # before.
                    else {
                        @@script = $0;
                    }

=pod

After the command line  has been reconstructed, the next step is to save
the debugger's status in environment variables. The C<DB::set_list> routine
is used to save aggregate variables (both hashes and arrays); scalars are
just popped into environment variables directly.

=cut

                    # If the terminal supported history, grab it and
                    # save that in the environment.
                    set_list("PERLDB_HIST",
                        $term->Features->{getHistory}
                        ? $term->GetHistory
                        : @@hist);
                    # Find all the files that were visited during this
                    # session (i.e., the debugger had magic hashes
                    # corresponding to them) and stick them in the environment.
                    my @@had_breakpoints = keys %had_breakpoints;
                    set_list("PERLDB_VISITED", @@had_breakpoints);

                    # Save the debugger options we chose.
                    set_list("PERLDB_OPT",     %option);

                    # Save the break-on-loads.
                    set_list("PERLDB_ON_LOAD", %break_on_load);

=pod 

The most complex part of this is the saving of all of the breakpoints. They
can live in an awful lot of places, and we have to go through all of them,
find the breakpoints, and then save them in the appropriate environment
variable via C<DB::set_list>.

=cut

                    # Go through all the breakpoints and make sure they're
                    # still valid.
                    my @@hard;
                    for (0 .. $#had_breakpoints) {
                        # We were in this file.
                        my $file = $had_breakpoints[$_];

                        # Grab that file's magic line hash.
                        *dbline = $main::{ '_<' . $file };

                        # Skip out if it doesn't exist, or if the breakpoint
                        # is in a postponed file (we'll do postponed ones 
                        # later).
                        next unless %dbline or $postponed_file{$file};

                        # In an eval. This is a little harder, so we'll
                        # do more processing on that below.
                        (push @@hard, $file), next
                          if $file =~ /^\(\w*eval/;
                        # XXX I have no idea what this is doing. Yet. 
                        my @@add;
                        @@add = %{ $postponed_file{$file} }
                          if $postponed_file{$file};

                        # Save the list of all the breakpoints for this file.
                        set_list("PERLDB_FILE_$_", %dbline, @@add);
                    } ## end for (0 .. $#had_breakpoints)

                    # The breakpoint was inside an eval. This is a little
                    # more difficult. XXX and I don't understand it.
                    for (@@hard) {    
                        # Get over to the eval in question.
                        *dbline = $main::{ '_<' . $_ };
                        my ($quoted, $sub, %subs, $line) = quotemeta $_;
                        for $sub (keys %sub) {
                            next unless $sub{$sub} =~ /^$quoted:(\d+)-(\d+)$/;
                            $subs{$sub} = [$1, $2];
                        }
                        unless (%subs) {
                            print $OUT
                              "No subroutines in $_, ignoring breakpoints.\n";
                            next;
                        }
                      LINES: for $line (keys %dbline) {

                            # One breakpoint per sub only:
                            my ($offset, $sub, $found);
                          SUBS: for $sub (keys %subs) {
                                if (
                                    $subs{$sub}->[1] >=
                                    $line    # Not after the subroutine
                                    and (
                                        not defined $offset    # Not caught
                                        or $offset < 0
                                    )
                                  )
                                {    # or badly caught
                                    $found  = $sub;
                                    $offset = $line - $subs{$sub}->[0];
                                    $offset = "+$offset", last SUBS
                                      if $offset >= 0;
                                } ## end if ($subs{$sub}->[1] >=...
                            } ## end for $sub (keys %subs)
                            if (defined $offset) {
                                $postponed{$found} =
                                  "break $offset if $dbline{$line}";
                            }
                            else {
                                print $OUT
"Breakpoint in $_:$line ignored: after all the subroutines.\n";
                            }
                        } ## end for $line (keys %dbline)
                    } ## end for (@@hard)

                    # Save the other things that don't need to be 
                    # processed.
                    set_list("PERLDB_POSTPONE",  %postponed);
                    set_list("PERLDB_PRETYPE",   @@$pretype);
                    set_list("PERLDB_PRE",       @@$pre);
                    set_list("PERLDB_POST",      @@$post);
                    set_list("PERLDB_TYPEAHEAD", @@typeahead);

                    # We are oficially restarting.
                    $ENV{PERLDB_RESTART} = 1;

                    # We are junking all child debuggers.
                    delete $ENV{PERLDB_PIDS};    # Restore ini state

                    # Set this back to the initial pid.
                    $ENV{PERLDB_PIDS} = $ini_pids if defined $ini_pids;

=pod 

After all the debugger status has been saved, we take the command we built
up and then C<exec()> it. The debugger will spot the C<PERLDB_RESTART>
environment variable and realize it needs to reload its state from the
environment.

=cut

                    # And run Perl again. Add the "-d" flag, all the 
                    # flags we built up, the script (whether a one-liner
                    # or a file), add on the -emacs flag for a slave editor,
                    # and then the old arguments. We use exec() to keep the
                    # PID stable (and that way $ini_pids is still valid).
                    exec($^X, '-d', @@flags, @@script,
                        ($slave_editor ? '-emacs' : ()), @@ARGS) ||
                      print $OUT "exec failed: $!\n";
                    last CMD;
                };

d2710 1
a2710 1
                    print_trace($OUT, 1);        # skip DB
d2720 1
a2720 1
                $cmd =~ /^w\b\s*(.*)/s && do { &cmd_w('w', $1); next CMD; };
d2728 1
a2728 1
                $cmd =~ /^W\b\s*(.*)/s && do { &cmd_W('W', $1); next CMD; };
d2739 1
a2739 1
                $cmd =~ /^\/(.*)$/     && do {
d2748 1
a2748 1
                    if ($inpat ne "") {
d2756 2
a2757 1
                        if ($@@ ne "") {
d2759 1
a2759 1
                            # Print the eval error and go back for more 
d2768 1
a2768 1
                    $end  = $start;
d2803 1
d2805 1
a2805 1
                    print $OUT "/$pat/: not found\n" if ($start == $end);
d2823 1
a2823 1
                    if ($inpat ne "") {
d2830 2
a2831 1
                        if ($@@ ne "") {
d2840 1
a2840 1
                    $end  = $start;
d2853 1
d2876 1
a2876 1
                    print $OUT "?$pat?: not found\n" if ($start == $end);
d2888 1
a2888 1
                # $rc - recall command. 
d2892 1
a2892 1
                    pop (@@hist) if length($cmd) > 1;
d2894 1
a2894 1
                    # Relative (- found)? 
d2896 1
a2896 1
                    #  N - go to that particular command slot or the last 
d2898 1
a2898 1
                    $i = $1 ? ($#hist - ($2 || 1)) : ($2 || $#hist);
d2919 1
d2932 1
a2932 1
                # $rc pattern $rc - find a command in the history. 
d2934 1
d2939 1
a2939 1
                    pop (@@hist) if length($cmd) > 1;
d2942 2
a2943 1
                    for ($i = $#hist ; $i ; --$i) {
d2948 2
a2949 1
                    if (!$i) {
d2969 1
d2972 1
a2972 1
                    &system($ENV{SHELL} || "/bin/sh");
d2985 1
d2990 1
a2990 1
                    &system($ENV{SHELL} || "/bin/sh", "-c", $1);
d3000 6
d3007 2
a3008 1
                    # Anything other than negative numbers is ignored by 
d3010 1
a3010 1
                    $end = $2 ? ($#hist - $2) : 0;
d3015 1
a3015 1
                    # Start at the end of the array. 
d3018 1
a3018 1
                    for ($i = $#hist ; $i > $end ; $i--) {
d3033 1
a3033 1
                # man, perldoc, doc - show manual pages.               
d3058 1
a3058 1
                 # = - set up a command alias.
d3061 2
a3062 1
                    if (length $cmd == 0) {
d3066 2
a3067 1
                    elsif (my ($k, $v) = ($cmd =~ /^(\S+)\s+(\S.*)/)) {
d3072 4
a3075 3
                        for my $x ($k, $v) { 
                          # Escape "alarm" characters.
                          $x =~ s/\a/\\a/g 
d3079 1
a3079 1
                        # as separators (which is why we escaped them in 
d3088 2
a3089 1
                        unless (eval "sub { s\a$k\a$v\a }; 1") {
d3095 1
d3107 1
d3111 2
a3112 1
                        if ((my $v = $alias{$k}) =~ ss\a$k\a(.*)\a$1) {
d3116 2
a3117 1
                        elsif (defined $alias{$k}) {
d3122 1
d3137 1
a3137 1
                # source - read commands from a file (or pipe!) and execute. 
d3139 2
a3140 1
                    if (open my $fh, $1) {
d3145 2
a3146 1
                        # Couldn't open it. 
d3152 49
d3217 2
a3218 1
                    if ($pager =~ /^\|/) {
d3220 4
a3223 4
                        open(SAVEOUT, ">&STDOUT") ||
                          &warn("Can't save STDOUT");
                        open(STDOUT, ">&OUT") ||
                          &warn("Can't redirect STDOUT");
d3226 1
d3228 1
a3228 1
                        open(SAVEOUT, ">&OUT") || &warn("Can't save DB::OUT");
d3234 2
a3235 1
                    unless ($piped = open(OUT, $pager)) {
d3238 2
a3239 1
                        if ($pager =~ /^\|/) {
d3241 1
a3241 1
                            open(OUT, ">&STDOUT")    # XXX: lost message
d3243 2
a3244 2
                            open(STDOUT, ">&SAVEOUT") ||
                              &warn("Can't restore STDOUT");
d3248 1
d3250 1
a3250 1
                            open(OUT, ">&STDOUT")    # XXX: lost message
d3258 2
a3259 2
                      if $pager =~ /^\|/ &&
                      ("" eq $SIG{PIPE} || "DEFAULT" eq $SIG{PIPE});
a3272 1

d3293 1
a3293 1
            # Make sure the flag that says "the debugger's running" is 
d3305 1
a3305 1
            elsif ($term_pid == $$) {
d3308 1
d3326 1
d3328 2
a3329 1
                if ($pager =~ /^\|/) {
d3340 1
a3340 1
                        if ($? == -1) {
d3343 4
a3346 4
                        elsif ($? >> 8) {
                            print SAVEOUT ($? & 127)
                              ? " (SIG#" . ($? & 127) . ")"
                              : "", ($? & 128) ? " -- core dumped" : "", "\n";
d3349 1
a3349 1
                            print SAVEOUT "status ", ($? >> 8), "\n";
d3353 1
a3353 1
                    # Reopen filehandle for our output (if we can) and 
d3355 3
a3357 3
                    open(OUT, ">&STDOUT") || &warn("Can't restore DB::OUT");
                    open(STDOUT, ">&SAVEOUT") ||
                      &warn("Can't restore STDOUT");
d3366 1
d3368 1
a3368 1
                    open(OUT, ">&SAVEOUT") || &warn("Can't restore DB::OUT");
d3402 1
a3402 1
    ($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;
d3494 1
a3494 1
    my ($al, $ret, @@ret) = "";
d3498 1
a3498 1
    if (length($sub) > 10 && substr($sub, -10, 10) eq '::AUTOLOAD') {
d3514 1
a3514 1
    # Turn off all flags except single-stepping. 
d3525 1
a3525 1
            print_lineinfo(' ' x ($stack_depth - 1), "in  "),
d3531 1
a3531 1
            print_trace($LINEINFO, -1, 1, 1, "$sub$al")
d3533 2
a3534 1
        : print_lineinfo(' ' x ($stack_depth - 1), "entering $sub$al\n")
d3541 1
d3545 11
a3555 1
        @@ret = &$sub;
d3558 1
a3558 1
        $single |= $stack[$stack_depth--];
d3562 1
a3562 1
            $frame & 4         # Extended exit message
d3564 2
a3565 2
                print_lineinfo(' ' x $stack_depth, "out "),
                print_trace($LINEINFO, -1, 1, 1, "$sub$al")
d3567 2
a3568 1
            : print_lineinfo(' ' x $stack_depth, "exited $sub$al\n")
d3574 2
a3575 1
        if ($doret eq $stack_depth or $frame & 16) {
d3578 1
a3578 1
            my $fh = ($doret eq $stack_depth ? $OUT : $LINEINFO);
d3585 1
a3585 1
            dumpit($fh, \@@ret);
d3590 1
a3590 1
        # And we have to return the return value now.
a3591 1

d3596 12
a3607 3
        if (defined wantarray) {
            # Save the value if it's wanted at all. 
            $ret = &$sub;
d3610 12
a3621 4
            # Void return, explicitly.
            &$sub;
            undef $ret;
        }
d3624 1
a3624 1
        $single |= $stack[$stack_depth--];
d3628 1
a3628 1
            $frame & 4                        # Extended messsages
d3630 2
a3631 2
                print_lineinfo(' ' x $stack_depth, "out "),
                print_trace($LINEINFO, -1, 1, 1, "$sub$al")
d3633 3
a3635 2
            : print_lineinfo(' ' x $stack_depth, "exited $sub$al\n")
                                              # Standard messages
d3640 1
a3640 1
        if ($doret eq $stack_depth or $frame & 16 and defined wantarray) {
d3642 2
a3643 2
            my $fh = ($doret eq $stack_depth ? $OUT : $LINEINFO);
            print $fh (' ' x $stack_depth) if $frame & 16;
d3648 2
a3649 2
                );
            dumpit($fh, $ret) if defined wantarray;
d3714 1
a3714 1
  );
d3736 1
a3736 1
    # Assemble the command subroutine's name by looking up the 
d3744 1
a3744 1
    return &$call($cmd, $line, $dblineno);
d3756 2
a3757 2
    my $cmd  = shift;
    my $line = shift || '';    # [.|line] expr
d3763 3
a3765 3
    # Should be a line number followed by an expression. 
    if ($line =~ /^\s*(\d*)\s*(\S.+)/) {
        my ($lineno, $expr) = ($1, $2);
d3768 2
a3769 1
        if (length $expr) {
d3771 1
a3771 1
            if ($dbline[$lineno] == 0) {
d3776 1
d3789 1
d3805 2
a3806 2
    my $cmd  = shift;
    my $line = shift || '';
d3816 1
a3816 1
    if ($line eq '*') {
d3822 1
a3822 1
    elsif ($line =~ /^(\S.*)/) {
d3829 1
a3829 2
          "Deleting an action requires a line number, or '*' for all\n"
          ;    # hint
d3844 2
a3845 1
    if (defined($i)) {
d3855 1
a3855 1
        for my $file (keys %had_breakpoints) {
d3859 2
a3860 2
            for ($i = 1 ; $i <= $max ; $i++) {
                if (defined $dbline{$i}) {
d3864 1
a3864 1
                unless ($had_breakpoints{$file} &= ~2) {
d3890 3
a3892 3
    # No line number, no condition. Simple break on current line. 
    if ($line =~ /^\s*$/) {
        &cmd_b_line($dbline, 1);
d3896 1
a3896 1
    elsif ($line =~ /^load\b\s*(.*)/) {
d3903 1
a3903 1
    # The interpreter actually traps this one for us; we just put the 
d3905 2
a3906 1
    elsif ($line =~ /^(postpone|compile)\b\s*([':A-Za-z_][':\w]*)\s*(.*)/) {
d3912 1
a3912 1
        my ($subname, $break) = ($2, $1 eq 'postpone');
d3921 1
a3921 1
        $subname = "main" . $subname if substr($subname, 0, 2) eq "::";
d3928 3
a3930 2
    elsif ($line =~ /^([':A-Za-z_][':\w]*(?:\[.*\])?)\s*(.*)/) {
        # 
d3933 1
a3933 1
        &cmd_b_sub($subname, $cond);
d3937 2
a3938 1
    elsif ($line =~ /^(\d*)\s*(.*)/) {
d3946 1
a3946 1
        &cmd_b_line($line, $cond);
d3996 1
d4001 1
a4001 1
        # Tack on .pm and do it again unless there was a '.' in the name 
d4070 2
a4071 2
    
    my ($from, $to) = @@_;
d4077 1
a4077 1
    if (@@_ >= 2) {
d4090 1
a4090 1
        #    as the stopping point. 
d4093 1
a4093 1
        #    times $delta of 1 (positive), so the result is < 0 and we should 
d4096 1
a4096 1
        # If $delta is negative (going backward), $limit will be 1. 
d4102 2
a4103 2
        #    times $delta of -1 (negative), so the result is not > 0, and 
        #    we use $limit (1) as the stopping point. 
d4106 1
a4106 1
        #    (negative), still giving zero; the result is not > 0, and 
d4112 2
a4113 2
        
        $limit = $to if ($limit - $to) * $delta > 0;
d4118 2
a4119 2
        # by $delta: either -1 (back) or +1 (ahead). 
        # We stay in as long as we haven't hit an executable line 
d4122 1
a4122 1
        $i += $delta while $dbline[$i] == 0 and ($limit - $i) * $delta > 0;
d4130 2
a4131 2
    my ($pl, $upto) = ('', '');
    ($pl, $upto) = ('s', "..$to") if @@_ >= 2 and $from != $to;
d4145 1
d4150 1
a4150 1
    local *dbline         = $main::{ '_<' . $f };
d4170 1
a4170 1
    my ($i, $cond) = @@_;
d4186 3
a4188 2
    # If there is an action or condition here already ... 
    if ($dbline{$i}) { 
d4190 1
a4190 1
        $dbline{$i} =~ s/^[^\0]*/$cond/; 
d4192 2
a4193 1
    else { 
d4195 1
a4195 1
        $dbline{$i} = $cond; 
d4221 1
a4221 1
    my ($f, $i, $cond) = @@_;
d4227 1
a4227 1
    local *dbline         = $main::{ '_<' . $f };
d4234 1
a4234 1
    break_on_line($i, $cond);
d4245 1
a4245 1
    my ($f, $from, $to, $cond) = @@_;
d4248 1
a4248 1
    my $i = breakable_line_in_filename($f, $from, $to);
d4254 1
a4254 1
    break_on_filename_line($f, $i, $cond);
d4265 1
a4265 1
    my ($subname, $cond) = @@_;
d4285 1
a4285 1
    my ($file, $s, $e) = subroutine_filename_lines($subname)
d4293 1
a4293 1
    break_on_filename_line_range($file, $s, $e, @@_);
d4318 1
a4318 1
    my ($subname, $cond) = @@_;
d4323 1
a4323 1
    # If the subname isn't a code reference, qualify it so that 
d4325 2
a4326 1
    unless (ref $subname eq 'CODE') {
d4344 1
a4344 1
        $subname = "main" . $subname if substr($subname, 0, 2) eq "::";
d4349 1
a4349 1
    eval { break_subroutine($subname, $cond); 1 } or do {
d4367 1
a4367 1
    my $cmd  = shift;
d4369 1
a4369 1
    # No line spec? Use dbline. 
d4371 1
a4371 1
    my $line = ($_[0] =~ /^\./) ? $dbline : shift || '';
d4378 1
a4378 1
    if ($line eq '*') {
d4383 2
a4384 2
    elsif ($line =~ /^(\S.*)/) {
        eval { &delete_breakpoint($line || $dbline); 1 } or do {
d4390 1
a4390 1
    # No line spec. 
d4427 1
a4427 1
    if (defined($i)) {
d4445 2
a4446 1
        for my $file (keys %had_breakpoints) {
d4454 2
a4455 1
            for ($i = 1 ; $i <= $max ; $i++) {
d4457 2
a4458 1
                if (defined $dbline{$i}) {
d4461 2
a4462 1
                    if ($dbline{$i} =~ s/^\0?$//) {
d4470 1
a4470 1
            # bit, the entry in %had_breakpoints for this file is zero, 
d4472 1
a4472 1
            if (not $had_breakpoints{$file} &= ~1) {
d4512 1
a4512 1
    my $cmd  = shift;
d4518 1
a4518 1
    if ($line =~ /^h\s*/) {
d4523 1
a4523 1
    elsif ($line =~ /^(\S.*)$/) {
d4527 2
a4528 2
        my $asked  = $1;                   # the command requested
                                           # (for proper error message)
d4535 2
a4536 1
        if ($help =~ /^                    # Start of a line
d4540 4
a4543 1
                     /mx) {
d4545 2
a4546 1
            while ($help =~ /^
d4554 3
a4556 1
                             /mgx) {
d4573 36
d4624 3
a4626 4
    my $current_line  = $line;

    my $cmd           = shift;
    my $line          = shift;
d4631 1
a4631 1
    # If the line is '$something', assume this is a scalar containing a 
d4633 1
a4633 1
    if ($line =~ /^(\$.*)/s) {
d4637 1
d4641 1
a4641 1
        print($OUT "Error: $@@\n"), next CMD if $@@;
d4645 1
a4645 1
        print($OUT "Interpreted as: $1 $s\n");
d4649 1
a4649 1
        &cmd_l('l', $s);
d4652 2
a4653 2
    # l name. Try to find a sub by that name. 
    elsif ($line =~ /^([\':A-Za-z_][\':\w]*(\[.*\])?)/s) {
d4670 1
a4670 1
        $subname = "main" . $subname if substr($subname, 0, 2) eq "::";
d4672 1
a4672 1
        # Get name:start-stop from find_sub, and break this up at 
d4674 1
a4674 1
        @@pieces = split (/:/, find_sub($subname) || $sub{$subname});
d4681 1
a4681 1
        $file     = join (':', @@pieces);
d4684 1
a4684 1
        if ($file ne $filename) {
d4697 1
a4697 1
            if (eval($subrange) < -$window) {
d4700 1
d4703 1
a4703 1
            &cmd_l('l', $subrange);
d4713 2
a4714 1
    elsif ($line =~ /^\s*$/) {
d4717 2
a4718 1
        $line = $start . '-' . ($start + $incr);
d4720 1
a4720 1
        &cmd_l('l', $line);
d4724 2
a4725 1
    elsif ($line =~ /^(\d*)\+(\d*)$/) {
d4735 2
a4736 2
        $line = $start . '-' . ($start + $incr);
        &cmd_l('l', $line);
d4740 1
a4740 1
    elsif ($line =~ /^((-?[\d\$\.]+)([-,]([\d\$\.]+))?)?/) {
d4743 1
a4743 1
        $end = (!defined $2) ? $max : ($4 ? $4 : $2);
d4748 4
a4751 4
        # Determine start line.  
        $i = $2;
        $i = $line if $i eq '.';
        $i = 1 if $i < 1;
d4762 1
a4762 1
        # - the current line in execution 
d4767 2
a4768 1
            for (; $i <= $end ; $i++) {
d4770 2
a4771 2
                my ($stop, $action);
                ($stop, $action) = split (/\0/, $dbline{$i})
d4777 1
a4777 1
                  ($i == $current_line and $filename eq $filename_ini)
d4779 1
a4779 1
                  : ($dbline[$i] + 0 ? ':' : ' ');
d4794 1
a4794 1
            print $OUT "\n" unless $dbline[$i - 1] =~ /\n$/;
d4822 1
a4822 1
    # If no argument, list everything. Pre-5.8.0 version always lists 
d4828 3
a4830 3
    my $action_wanted = ($arg =~ /a/) ? 1 : 0;
    my $break_wanted  = ($arg =~ /b/) ? 1 : 0;
    my $watch_wanted  = ($arg =~ /w/) ? 1 : 0;
d4834 2
a4835 1
    if ($break_wanted or $action_wanted) {
d4837 2
a4838 1
        for my $file (keys %had_breakpoints) {
d4844 2
a4845 2
            my $was;                         # Flag: did we print something
                                             # in this file?
d4848 2
a4849 1
            for ($i = 1 ; $i <= $max ; $i++) {
d4851 2
a4852 1
                if (defined $dbline{$i}) {
d4860 1
a4860 1
                    ($stop, $action) = split (/\0/, $dbline{$i});
d4880 1
a4880 1
    if (%postponed and $break_wanted) {
d4883 1
a4883 1
        for $subname (keys %postponed) {
d4895 1
a4895 1
    if (@@have and ($break_wanted or $action_wanted)) {
d4897 1
a4897 1
        my ($file, $line);
d4899 1
a4899 1
        for $file (keys %postponed_file) {
d4902 1
a4902 1
            for $line (sort { $a <=> $b } keys %$db) {
d4904 1
a4904 1
                my ($stop, $action) = split (/\0/, $$db{$line});
d4916 1
a4916 1
    if (%break_on_load and $break_wanted) {
d4919 1
a4919 1
        for $file (keys %break_on_load) {
d4925 1
a4925 1
        if ($trace & 2) {
d4958 1
a4958 1
    if ($opt =~ /^(\S.*)/) {
d4998 2
a4999 1
    if ($line =~ /^(\d*)$/) {
d5004 1
a5004 1
       $start = $1 if $1;
d5010 1
a5010 1
        $line = $start . '-' . ($start + $incr);
d5013 1
a5013 1
        &cmd_l('l', $line);
d5030 1
a5030 1
    my $cmd  = shift;
d5036 2
a5037 1
    if ($expr =~ /^(\S.*)/) {
d5045 2
a5046 2
        my ($val) = join(' ', &eval);
        $val = (defined $val) ? "'$val'" : 'undef';
d5057 1
a5057 2
        print $OUT
          "Adding a watch-expression requires an expression\n";    # hint
d5082 2
a5083 1
    if ($expr eq '*') {
d5094 2
a5095 1
    elsif ($expr =~ /^(\S.*)/) {
d5104 4
a5107 4
            if ($val eq $expr) {    # =~ m/^\Q$i$/) {
                # Yes. Turn it off, and its value too.
                splice(@@to_watch, $i_cnt, 1);
                splice(@@old_watch, $i_cnt, 1);
d5121 2
a5122 2
"Deleting a watch-expression requires an expression, or '*' for all\n"
          ;                         # hint
d5133 28
d5169 3
a5171 2
    # Save eval failure, command failure, extended OS error, output field 
    # separator, input record separator, output record separator and 
d5173 1
a5173 1
    @@saved = ($@@, $!, $^E, $,, $/, $\, $^W);
d5175 4
a5178 4
    $,     = "";             # output field separator is null string
    $/     = "\n";           # input record separator is newline
    $\     = "";             # output record separator is null string
    $^W    = 0;              # warnings are off
d5191 1
d5213 1
d5218 2
a5219 1
    if ($postponed{$subname} =~ s/^break\s([+-]?\d+)\s+if\s//) {
d5225 1
a5225 1
        my ($file, $i) = (find_sub($subname) =~ /^(.*):(\d+)-.*$/);
d5227 2
a5228 1
            # We got the start line. Add the offset '+<n>' from 
d5236 1
a5236 1
            local $^W     = 0;                         # != 0 is magical below
d5259 1
a5259 1
    elsif ($postponed{$subname} eq 'compile') { $signal = 1 }
d5279 1
d5282 1
d5287 1
a5287 1
        $signal        = 1;
d5300 1
a5300 1
    print_lineinfo(' ' x $stack_depth, "Package $filename.\n") if $frame;
d5312 1
a5312 1
    #%dbline = %{$postponed_file{$filename}}; 
d5317 2
a5318 1
    for $key (keys %{ $postponed_file{$filename} }) {
d5368 1
d5383 1
a5383 1
    unless (defined &main::dumpValue) {
d5389 1
a5389 1
    if (defined &main::dumpValue) {
d5396 1
a5396 1
        &main::dumpValue($v, $maxdepth);
d5444 1
d5448 3
a5450 3
      if $fh eq $LINEINFO          # slave editor
      and $LINEINFO eq $OUT        # normal output
      and $term_pid != $$;         # not the primary
d5454 1
a5454 1
    my @@sub = dump_trace($_[0] + 1, $_[1]);
d5457 1
a5457 1
    my $short = $_[2];    # Print short report, next one for sub name
d5461 2
a5462 1
    for ($i = 0 ; $i <= $#sub ; $i++) {
d5466 1
a5466 1
        # Set the separator so arrys print nice. 
d5474 1
d5476 1
a5476 1
        $args = (substr $args, 0, $maxtrace - 3) . '...'
d5487 1
a5487 1
        $s = (substr $s, 0, $maxtrace - 3) . '...' if length $s > $maxtrace;
d5492 1
a5492 2
            print $fh
              "$sub[$i]{context}=$sub$args from $file:$sub[$i]{line}\n";
d5497 3
a5499 2
            print $fh "$sub[$i]{context} = $s$args" . " called from $file" .
              " line $sub[$i]{line}\n";
d5545 1
a5545 1
    # the current one.  Add $skip to the count of frames so we have a 
d5551 1
a5551 1
    my ($p, $file, $line, $sub, $h, $context);
d5553 1
a5553 1
    my ($e, $r, @@a, @@sub, $args);
d5557 1
a5557 1
    local $frame = 0;    
d5572 1
a5572 1
        and ($p, $file, $line, $sub, $h, $context, $e, $r) = caller($i) ;
d5581 1
a5581 1
            if (not defined $arg) {                    # undefined parameter
d5585 1
a5585 1
            elsif ($nothard and tied $arg) {           # tied parameter
d5588 1
a5588 1
            elsif ($nothard and $type = ref $arg) {    # reference
d5591 1
a5591 1
            else {                                     # can be stringified
d5609 1
a5609 1
                push (@@a, $_);
d5615 1
a5615 1
        # If neither, context isn't defined. (This is apparently a 'can't 
d5617 1
a5617 1
        $context = $context ? '@@' : (defined $context ? "\$" : '.');
d5625 1
a5625 1
        $e =~ s/\n\s*\;\s*\Z//  if $e;
d5634 1
d5636 1
a5636 1
        elsif (defined $r) {
d5642 1
a5642 1
        elsif ($sub eq '(eval)') {
d5647 1
a5647 1
        push (
d5656 1
a5656 1
            );
d5679 2
a5680 1
    while ($action =~ s/\\$//) {
d5744 4
a5747 4
    open(SAVEIN,  "<&STDIN")  || &warn("Can't save STDIN");
    open(SAVEOUT, ">&STDOUT") || &warn("Can't save STDOUT");
    open(STDIN,   "<&IN")     || &warn("Can't redirect STDIN");
    open(STDOUT,  ">&OUT")    || &warn("Can't redirect STDOUT");
d5751 2
a5752 2
    open(STDIN,  "<&SAVEIN")  || &warn("Can't restore STDIN");
    open(STDOUT, ">&SAVEOUT") || &warn("Can't restore STDOUT");
d5757 2
a5758 2
    if ($? >> 8) {
        &warn("(Command exited ", ($? >> 8), ")\n");
d5763 2
a5764 2
            ($? & 127),
            (($? & 128) ? " -- core dumped" : ""),
d5766 1
a5766 1
            );
d5794 1
d5803 1
a5803 1
            my ($i, $o) = split $tty, /,/;
d5805 2
a5806 2
            open(IN,  "<$i") or die "Cannot open TTY `$i' for read: $!";
            open(OUT, ">$o") or die "Cannot open TTY `$o' for write: $!";
d5817 1
a5828 1

d5830 1
a5830 1
    if ($term_pid eq '-1') {    # In a TTY with another debugger
d5835 1
a5835 1
    if (!$rl) {
d5846 1
a5846 1
          and index($rl_attribs->{basic_word_break_characters}, ":") == -1;
d5858 1
a5858 1
    if ($term->Features->{setHistory} and "@@hist" ne "?") {
d5904 1
a5904 1
    (my $name = $0) =~ s,^.*[/\\],,s;
d5927 1
a5927 1
    local $^F = 40;     # XXXX Fixme!
d5929 1
a5929 1
    my ($in1, $out1, $in2, $out2);
d5939 1
a5939 1
    (my $name = $0) =~ s,^.*[/\\],,s;
d5949 1
a5949 2
            $rl, fileno $in1, fileno $out2,
            "Daughter Perl debugger $pids $name"
d5952 2
a5953 2
            ($kpid = CORE::system 4, $^X, '-we',
                <<'ES', @@args) >= 0    # P_SESSION
d5979 1
a5979 1
        reset_IN_OUT($in2, $out1);
d6011 1
a6011 1
    # It used to be that 
d6014 1
a6014 1
    if (not defined $in) {
d6043 1
a6043 1
    elsif ($in ne '') {
d6071 1
a6071 1
sub resetterm {           # We forked, so we need a different TTY
d6094 1
a6094 1
    $term_pid  = $$;
d6127 1
d6132 1
a6132 1
        my $got  = shift @@typeahead;
d6145 1
a6145 1
    # We really need to read some input. Turn off entry/exit trace and 
d6152 1
d6154 2
a6155 1
        my $line = CORE::readline($cmdfhs[-1]);
d6158 2
a6159 2
          ? (print $OUT ">> $line" and return $line)  # Echo and return
          : close pop @@cmdfhs;                        # Pop and close
d6163 2
a6164 1
    if (ref $OUT and UNIVERSAL::isa($OUT, 'IO::Socket::INET')) {
d6166 1
a6166 1
        $OUT->write(join ('', @@_));
d6170 2
a6171 2
        $IN->recv($stuff, 2048);    # XXX "what's wrong with sysread?"
                                    # XXX Don't know. You tell me.
d6196 2
a6197 2
    my ($opt, $val) = @@_;
    $val = option_val($opt, 'N/A');
d6202 7
d6220 1
a6220 1
    my ($opt, $default) = @@_;
d6226 2
a6227 1
        and defined ${ $optionVars{$opt} }) {
d6235 2
a6236 1
        and defined &{ $optionAction{$opt} }) {
d6243 1
a6243 1
        or defined $optionVars{$opt} and not defined ${ $optionVars{$opt} })
d6285 1
a6285 1
    my %opt_needs_val = map { ($_ => 1) } qw{
d6288 1
a6288 1
      };
d6298 2
a6299 2
        s/^(\w+)(\W?)// or print($OUT "Invalid option `$_'\n"), last;
        my ($opt, $sep) = ($1, $2);
d6302 2
a6303 5
        my $matches = grep(/^\Q$opt/ && ($option = $_), @@options) ||
          grep(/^\Q$opt/i && ($option = $_), @@options);

        print($OUT "Unknown option `$opt'\n"), next unless $matches;
        print($OUT "Ambiguous option `$opt'\n"), next if $matches > 1;
d6305 2
d6310 2
a6311 2
        if ("?" eq $sep) {
            print($OUT "Option query `$opt?' followed by non-space `$_'\n"),
d6320 1
a6320 1
        elsif ($sep !~ /\S/) {
d6322 1
a6322 1
            $val           = "1"; #  this is an evil default; make 'em set it!
d6326 2
a6327 1
        elsif ($sep eq "=") {
d6331 1
a6331 1
                ($val = $2) =~ s/\\([$quote\\])/$1/g;
d6344 1
a6344 1
        # "Quoted" with [], <>, or {}.  
d6346 2
a6347 1
            my ($end) = "\\" . substr(")]>}$sep", index("([<{", $sep), 1);  #}
d6349 2
a6350 2
              or print($OUT "Unclosed option value `$opt$sep$_'\n"), last;
            ($val = $1) =~ s/\\([\\$end])/$1/g;
a6352 3
        # Impedance-match the code above to the code below.
        my $option = $opt;

d6354 2
a6355 2
        if ($opt_needs_val{$option} && $val_defaulted) {
            my $cmd = ($CommandSet eq '580') ? 'o' : 'O';
d6371 2
a6372 2
          if defined $optionRequire{$option} &&
             defined $val;
d6374 1
a6374 1
        # Set it. 
d6377 2
a6378 2
          if defined $optionVars{$option} &&
          defined $val;
d6382 3
a6384 3
          if defined $optionAction{$option} &&
          defined &{ $optionAction{$option} } &&
          defined $val;
d6406 1
a6406 1
    my ($stem, @@list) = @@_;
d6414 1
a6414 1
    for $i (0 .. $#list) {
d6434 1
a6434 1
    for $i (0 .. $n - 1) {
d6471 1
a6471 1
    my ($msg) = join ("", @@_);
d6491 3
a6493 3
    if ($term and $term->Features->{newTTY}) {
        ($IN, $OUT) = (shift, shift);
        $term->newTTY($IN, $OUT);
d6503 1
a6503 1
        ($IN, $OUT) = (shift, shift);
d6533 2
a6534 1
    if (@@_ and $term and $term->Features->{newTTY}) {
d6539 3
a6541 2
        my ($in, $out) = shift; 
        if ($in =~ /,/) {
d6543 1
a6543 1
            ($in, $out) = split /,/, $in, 2;
d6546 1
d6552 1
a6552 1
        open IN, $in or die "cannot open `$in' for read: $!";
d6556 1
a6556 1
        reset_IN_OUT(\*IN, \*OUT);
d6565 1
a6565 1
    
d6630 1
a6630 1
    if (${ $term->Features }{tkRunning}) {
d6656 36
d6724 4
a6727 4
    $psh = $sh;                       # copy it
    $psh =~ s/\\b$//;                 # Take off trailing \b if any
    $psh =~ s/\\(.)/$1/g;             # De-escape
    $psh;                             # return the printable version
d6739 2
a6740 1
    if (defined $term) {
d6742 1
a6742 1
        local ($warnLevel, $dieLevel) = (0, 1);
d6772 4
a6775 4
    $prc = $rc;                             # Copy it
    $prc =~ s/\\b$//;                       # Remove trailing \b
    $prc =~ s/\\(.)/$1/g;                   # Remove escapes
    $prc;                                   # Return the printable version
d6792 1
a6792 1
    #  If this is a valid "thing to be opened for output", tack a 
d6794 1
a6794 1
    my $stream = ($lineinfo =~ /^(\+?\>|\|)/) ? $lineinfo : ">$lineinfo";
d6797 1
a6797 1
    $slave_editor = ($stream =~ /^\|/);
d6800 1
a6800 1
    open(LINEINFO, "$stream") || &warn("Cannot open `$stream' for write");
d6826 1
d6829 1
a6829 1
    for (keys %INC) {
d6839 1
a6839 1
        if (defined ${ $_ . '::VERSION' }) {
d6848 1
a6848 1
    dumpit($OUT, \%version);
d6884 30
a6913 30
B<T>		Stack trace.
B<s> [I<expr>]	Single step [in I<expr>].
B<n> [I<expr>]	Next, steps over subroutine calls [in I<expr>].
<B<CR>>		Repeat last B<n> or B<s> command.
B<r>		Return from current subroutine.
B<c> [I<line>|I<sub>]	Continue; optionally inserts a one-time-only breakpoint
		at the specified position.
B<l> I<min>B<+>I<incr>	List I<incr>+1 lines starting at I<min>.
B<l> I<min>B<->I<max>	List lines I<min> through I<max>.
B<l> I<line>		List single I<line>.
B<l> I<subname>	List first window of lines from subroutine.
B<l> I<\$var>		List first window of lines from subroutine referenced by I<\$var>.
B<l>		List next window of lines.
B<->		List previous window of lines.
B<v> [I<line>]	View window around I<line>.
B<.>		Return to the executed line.
B<f> I<filename>	Switch to viewing I<filename>. File must be already loaded.
		I<filename> may be either the full name of the file, or a regular
		expression matching the full file name:
		B<f> I</home/me/foo.pl> and B<f> I<oo\\.> may access the same file.
		Evals (with saved bodies) are considered to be filenames:
		B<f> I<(eval 7)> and B<f> I<eval 7\\b> access the body of the 7th eval
		(in the order of execution).
B</>I<pattern>B</>	Search forwards for I<pattern>; final B</> is optional.
B<?>I<pattern>B<?>	Search backwards for I<pattern>; final B<?> is optional.
B<L> [I<a|b|w>]		List actions and or breakpoints and or watch-expressions.
B<S> [[B<!>]I<pattern>]	List subroutine names [not] matching I<pattern>.
B<t>		Toggle trace mode.
B<t> I<expr>		Trace through execution of I<expr>.
B<b>		Sets breakpoint on current line)
d6915 2
a6916 2
		Set breakpoint; I<line> defaults to the current execution line;
		I<condition> breaks if it evaluates to true, defaults to '1'.
d6918 2
a6919 2
		Set breakpoint at first line of subroutine.
B<b> I<\$var>		Set breakpoint at first line of subroutine referenced by I<\$var>.
d6922 2
a6923 2
		Set breakpoint at first line of subroutine after 
		it is compiled.
d6925 2
a6926 2
		Stop after the subroutine is compiled.
B<B> [I<line>]	Delete the breakpoint for I<line>.
d6929 7
a6935 7
		Set an action to be done before the I<line> is executed;
		I<line> defaults to the current execution line.
		Sequence is: check for breakpoint/watchpoint, print line
		if necessary, do action, prompt user if necessary,
		execute line.
B<a>		Does nothing
B<A> [I<line>]	Delete the action for I<line>.
d6937 3
a6939 3
B<w> I<expr>		Add a global watch-expression.
B<w>     		Does nothing
B<W> I<expr>		Delete a global watch-expression.
d6941 9
a6949 8
B<V> [I<pkg> [I<vars>]]	List some (default all) variables in package (default current).
		Use B<~>I<pattern> and B<!>I<pattern> for positive and negative regexps.
B<X> [I<vars>]	Same as \"B<V> I<currentpackage> [I<vars>]\".
B<x> I<expr>		Evals expression in list context, dumps the result.
B<m> I<expr>		Evals expression in list context, prints methods callable
		on the first element of the result.
B<m> I<class>		Prints methods callable via the given class.
B<M>		Show versions of loaded modules.
d6951 1
d6953 17
a6969 17
B<<> ?			List Perl commands to run before each prompt.
B<<> I<expr>		Define Perl command to run before each prompt.
B<<<> I<expr>		Add to the list of Perl commands to run before each prompt.
B<< *>				Delete the list of perl commands to run before each prompt.
B<>> ?			List Perl commands to run after each prompt.
B<>> I<expr>		Define Perl command to run after each prompt.
B<>>B<>> I<expr>		Add to the list of Perl commands to run after each prompt.
B<>>B< *>		Delete the list of Perl commands to run after each prompt.
B<{> I<db_command>	Define debugger command to run before each prompt.
B<{> ?			List debugger commands to run before each prompt.
B<{ *>				Delete the list of debugger commands to run before each prompt.
B<{{> I<db_command>	Add to the list of debugger commands to run before each prompt.
B<$prc> I<number>	Redo a previous command (default previous command).
B<$prc> I<-number>	Redo number'th-to-last command.
B<$prc> I<pattern>	Redo last command that started with I<pattern>.
		See 'B<O> I<recallCommand>' too.
B<$psh$psh> I<cmd>  	Run cmd in a subprocess (reads from DB::IN, writes to DB::OUT)"
d6974 20
a6993 16
B<$psh> [I<cmd>] 	Run I<cmd> in subshell (forces \"\$SHELL -c 'cmd'\")."
      ) 
      . "
		See 'B<O> I<shellBang>' too.
B<source> I<file>		Execute I<file> containing debugger commands (may nest).
B<H> I<-number>	Display last number commands (default all).
B<p> I<expr>		Same as \"I<print {DB::OUT} expr>\" in current package.
B<|>I<dbcmd>		Run debugger command, piping DB::OUT to current pager.
B<||>I<dbcmd>		Same as B<|>I<dbcmd> but DB::OUT is temporarilly select()ed as well.
B<\=> [I<alias> I<value>]	Define a command alias, or list current aliases.
I<command>		Execute as a perl statement in current package.
B<R>		Pure-man-restart of debugger, some of debugger state
		and command-line options may be lost.
		Currently the following settings are preserved:
		history, breakpoints and actions, debugger B<O>ptions 
		and the following command-line options: I<-w>, I<-I>, I<-e>.
d6995 2
a6996 2
B<o> [I<opt>] ...	Set boolean option to true
B<o> [I<opt>B<?>]	Query options
d6998 8
a7005 8
		Set options.  Use quotes in spaces in value.
    I<recallCommand>, I<ShellBang>	chars used to recall command or spawn shell;
    I<pager>			program for output of \"|cmd\";
    I<tkRunning>			run Tk while prompting (with ReadLine);
    I<signalLevel> I<warnLevel> I<dieLevel>	level of verbosity;
    I<inhibit_exit>		Allows stepping off the end of the script.
    I<ImmediateStop>		Debugger should stop as early as possible.
    I<RemotePort>			Remote hostname:port for remote debugging
d7007 8
a7014 8
    I<arrayDepth>, I<hashDepth> 	print only first N elements ('' for all);
    I<compactDump>, I<veryCompact> 	change style of array and hash dump;
    I<globPrint> 			whether to print contents of globs;
    I<DumpDBFiles> 		dump arrays holding debugged files;
    I<DumpPackages> 		dump symbol tables of packages;
    I<DumpReused> 			dump contents of \"reused\" addresses;
    I<quote>, I<HighBit>, I<undefPrint> 	change style of string dump;
    I<bareStringify> 		Do not print the overload-stringified value;
d7016 20
a7035 20
    I<PrintRet>		affects printing of return value after B<r> command,
    I<frame>		affects printing messages on subroutine entry/exit.
    I<AutoTrace>	affects printing messages on possible breaking points.
    I<maxTraceLen>	gives max length of evals/args listed in stack trace.
    I<ornaments> 	affects screen appearance of the command line.
    I<CreateTTY> 	bits control attempts to create a new TTY on events:
			1: on fork()	2: debugger is started inside debugger
			4: on startup
	During startup options are initialized from \$ENV{PERLDB_OPTS}.
	You can put additional initialization options I<TTY>, I<noTTY>,
	I<ReadLine>, I<NonStop>, and I<RemotePort> there (or use
	`B<R>' after you set them).

B<q> or B<^D>		Quit. Set B<\$DB::finished = 0> to debug global destruction.
B<h>		Summary of debugger commands.
B<h> [I<db_command>]	Get help [on a specific debugger command], enter B<|h> to page.
B<h h>		Long help for debugger commands
B<$doccmd> I<manpage>	Runs the external doc viewer B<$doccmd> command on the 
		named Perl I<manpage>, or on B<$doccmd> itself if omitted.
		Set B<\$DB::doccmd> to change viewer.
d7065 1
a7065 1
  B<X> [I<Vars>]       Same as \"B<V> I<current_package> [I<Vars>]\".
d7074 29
a7102 29
B<T>		Stack trace.
B<s> [I<expr>]	Single step [in I<expr>].
B<n> [I<expr>]	Next, steps over subroutine calls [in I<expr>].
B<CR>>			Repeat last B<n> or B<s> command.
B<r>		Return from current subroutine.
B<c> [I<line>|I<sub>]	Continue; optionally inserts a one-time-only breakpoint
		at the specified position.
B<l> I<min>B<+>I<incr>	List I<incr>+1 lines starting at I<min>.
B<l> I<min>B<->I<max>	List lines I<min> through I<max>.
B<l> I<line>		List single I<line>.
B<l> I<subname>	List first window of lines from subroutine.
B<l> I<\$var>		List first window of lines from subroutine referenced by I<\$var>.
B<l>		List next window of lines.
B<->		List previous window of lines.
B<w> [I<line>]	List window around I<line>.
B<.>		Return to the executed line.
B<f> I<filename>	Switch to viewing I<filename>. File must be already loaded.
		I<filename> may be either the full name of the file, or a regular
		expression matching the full file name:
		B<f> I</home/me/foo.pl> and B<f> I<oo\\.> may access the same file.
		Evals (with saved bodies) are considered to be filenames:
		B<f> I<(eval 7)> and B<f> I<eval 7\\b> access the body of the 7th eval
		(in the order of execution).
B</>I<pattern>B</>	Search forwards for I<pattern>; final B</> is optional.
B<?>I<pattern>B<?>	Search backwards for I<pattern>; final B<?> is optional.
B<L>		List all breakpoints and actions.
B<S> [[B<!>]I<pattern>]	List subroutine names [not] matching I<pattern>.
B<t>		Toggle trace mode.
B<t> I<expr>		Trace through execution of I<expr>.
d7104 2
a7105 2
		Set breakpoint; I<line> defaults to the current execution line;
		I<condition> breaks if it evaluates to true, defaults to '1'.
d7107 2
a7108 2
		Set breakpoint at first line of subroutine.
B<b> I<\$var>		Set breakpoint at first line of subroutine referenced by I<\$var>.
d7111 2
a7112 2
		Set breakpoint at first line of subroutine after 
		it is compiled.
d7114 3
a7116 3
		Stop after the subroutine is compiled.
B<d> [I<line>]	Delete the breakpoint for I<line>.
B<D>		Delete all breakpoints.
d7118 31
a7148 31
		Set an action to be done before the I<line> is executed;
		I<line> defaults to the current execution line.
		Sequence is: check for breakpoint/watchpoint, print line
		if necessary, do action, prompt user if necessary,
		execute line.
B<a> [I<line>]	Delete the action for I<line>.
B<A>		Delete all actions.
B<W> I<expr>		Add a global watch-expression.
B<W>		Delete all watch-expressions.
B<V> [I<pkg> [I<vars>]]	List some (default all) variables in package (default current).
		Use B<~>I<pattern> and B<!>I<pattern> for positive and negative regexps.
B<X> [I<vars>]	Same as \"B<V> I<currentpackage> [I<vars>]\".
B<x> I<expr>		Evals expression in list context, dumps the result.
B<m> I<expr>		Evals expression in list context, prints methods callable
		on the first element of the result.
B<m> I<class>		Prints methods callable via the given class.

B<<> ?			List Perl commands to run before each prompt.
B<<> I<expr>		Define Perl command to run before each prompt.
B<<<> I<expr>		Add to the list of Perl commands to run before each prompt.
B<>> ?			List Perl commands to run after each prompt.
B<>> I<expr>		Define Perl command to run after each prompt.
B<>>B<>> I<expr>		Add to the list of Perl commands to run after each prompt.
B<{> I<db_command>	Define debugger command to run before each prompt.
B<{> ?			List debugger commands to run before each prompt.
B<{{> I<db_command>	Add to the list of debugger commands to run before each prompt.
B<$prc> I<number>	Redo a previous command (default previous command).
B<$prc> I<-number>	Redo number'th-to-last command.
B<$prc> I<pattern>	Redo last command that started with I<pattern>.
		See 'B<O> I<recallCommand>' too.
B<$psh$psh> I<cmd>  	Run cmd in a subprocess (reads from DB::IN, writes to DB::OUT)"
d7153 16
a7168 17
B<$psh> [I<cmd>] 	Run I<cmd> in subshell (forces \"\$SHELL -c 'cmd'\")."
      ) .
      "
		See 'B<O> I<shellBang>' too.
B<source> I<file>		Execute I<file> containing debugger commands (may nest).
B<H> I<-number>	Display last number commands (default all).
B<p> I<expr>		Same as \"I<print {DB::OUT} expr>\" in current package.
B<|>I<dbcmd>		Run debugger command, piping DB::OUT to current pager.
B<||>I<dbcmd>		Same as B<|>I<dbcmd> but DB::OUT is temporarilly select()ed as well.
B<\=> [I<alias> I<value>]	Define a command alias, or list current aliases.
I<command>		Execute as a perl statement in current package.
B<v>		Show versions of loaded modules.
B<R>		Pure-man-restart of debugger, some of debugger state
		and command-line options may be lost.
		Currently the following settings are preserved:
		history, breakpoints and actions, debugger B<O>ptions 
		and the following command-line options: I<-w>, I<-I>, I<-e>.
d7170 2
a7171 2
B<O> [I<opt>] ...	Set boolean option to true
B<O> [I<opt>B<?>]	Query options
d7173 8
a7180 8
		Set options.  Use quotes in spaces in value.
    I<recallCommand>, I<ShellBang>	chars used to recall command or spawn shell;
    I<pager>			program for output of \"|cmd\";
    I<tkRunning>			run Tk while prompting (with ReadLine);
    I<signalLevel> I<warnLevel> I<dieLevel>	level of verbosity;
    I<inhibit_exit>		Allows stepping off the end of the script.
    I<ImmediateStop>		Debugger should stop as early as possible.
    I<RemotePort>			Remote hostname:port for remote debugging
d7182 8
a7189 8
    I<arrayDepth>, I<hashDepth> 	print only first N elements ('' for all);
    I<compactDump>, I<veryCompact> 	change style of array and hash dump;
    I<globPrint> 			whether to print contents of globs;
    I<DumpDBFiles> 		dump arrays holding debugged files;
    I<DumpPackages> 		dump symbol tables of packages;
    I<DumpReused> 			dump contents of \"reused\" addresses;
    I<quote>, I<HighBit>, I<undefPrint> 	change style of string dump;
    I<bareStringify> 		Do not print the overload-stringified value;
d7191 19
a7209 19
    I<PrintRet>		affects printing of return value after B<r> command,
    I<frame>		affects printing messages on subroutine entry/exit.
    I<AutoTrace>	affects printing messages on possible breaking points.
    I<maxTraceLen>	gives max length of evals/args listed in stack trace.
    I<ornaments> 	affects screen appearance of the command line.
    I<CreateTTY> 	bits control attempts to create a new TTY on events:
			1: on fork()	2: debugger is started inside debugger
			4: on startup
	During startup options are initialized from \$ENV{PERLDB_OPTS}.
	You can put additional initialization options I<TTY>, I<noTTY>,
	I<ReadLine>, I<NonStop>, and I<RemotePort> there (or use
	`B<R>' after you set them).

B<q> or B<^D>		Quit. Set B<\$DB::finished = 0> to debug global destruction.
B<h> [I<db_command>]	Get help [on a specific debugger command], enter B<|h> to page.
B<h h>		Summary of debugger commands.
B<$doccmd> I<manpage>	Runs the external doc viewer B<$doccmd> command on the 
		named Perl I<manpage>, or on B<$doccmd> itself if omitted.
		Set B<\$DB::doccmd> to change viewer.
d7321 2
a7322 1
    if ($pager =~ /\bmore\b/) {
d7328 4
a7331 4
        $is_less = @@st_more &&
          @@st_less &&
          $st_more[0] == $st_less[0] &&
          $st_more[1] == $st_less[1];
d7352 1
d7367 2
a7368 1
    if (defined &Carp::longmess) {
d7372 2
a7373 2
        # Skip two levels before reporting traceback: we're skipping 
        # mydie and confess. 
d7377 1
a7377 1
        &warn(Carp::longmess("Signal @@_"));
d7398 2
a7399 1
    # No entry/exit trace. 
d7417 2
a7418 2
    CORE::warn(@@_,
        "\nCannot print stack trace, load with -MCarp option to see stack"),
d7423 1
a7423 1
    my ($mysingle, $mytrace) = ($single, $trace);
d7427 1
a7427 1
    # We can call Carp::longmess without its being "debugged" (which we 
d7432 1
a7432 1
    ($single, $trace) = ($mysingle, $mytrace);
d7454 2
a7455 2
    local $frame = 0;
    local $doret = -2;
d7461 1
a7461 1
    if ($dieLevel > 2) {
d7466 1
a7466 1
    if ($dieLevel < 2) {
d7472 1
a7472 1
    eval { require Carp }; 
d7474 2
a7475 2
    die (@@_,
        "\nCannot print stack trace, load with -MCarp option to see stack")
d7482 1
a7482 1
    my ($mysingle, $mytrace) = ($single, $trace);
d7491 1
a7491 1
    ($single, $trace) = ($mysingle, $mytrace);
d7533 1
d7537 2
a7538 2
           # No longer exists, so don't try  to use it.
           #$SIG{__DIE__} = \&DB::diehard if $dieLevel >= 2;
d7544 1
a7544 1
              ($dieLevel == 1 ? " outside of evals" : ""), ".\n"
d7651 1
a7651 1
        for (keys %sub) {
a7673 1
    local %packs;
d7676 1
a7676 1
    methods_via($class, '', 1);
d7679 1
a7679 1
    methods_via('UNIVERSAL', 'UNIVERSAL', 0);
d7693 1
d7698 2
a7699 2
    # This is a package that is contributing the methods we're about to print. 
    my $prefix = shift;
d7704 1
d7707 6
a7712 3
             # Extract from all the symbols in this class.
             sort keys %{"${class}::"}
      ) {
d7715 1
a7715 1
 
d7723 1
a7723 1
    return unless shift; 
d7727 2
a7728 1
    for $name (@@{"${class}::ISA"}) {
d7731 3
a7733 2
        # Crawl up the tree and keep trying to crawl up. 
        methods_via($name, $prepend, 1);
d7744 3
a7746 4
    $doccmd =
      $^O !~ /^(?:MSWin32|VMS|os2|dos|amigaos|riscos|MacOS|NetWare)\z/s
      ? "man"               # O Happy Day!
      : "perldoc";          # Alas, poor unfortunates
d7766 1
a7766 1
    unless ($doccmd eq 'man') {
d7776 1
a7776 1
    for ($man1dir, $man3dir) { s#/[^/]*\z## if /\S/ }
d7791 1
a7791 1
            (($manpath && !$nopathopt) ? ("-M", $manpath) : ()),
d7796 141
a7936 14
        unless ($page =~ /^perl\w/) {
            if (
                grep { $page eq $_ }
                qw{
                5004delta 5005delta amiga api apio book boot bot call compile
                cygwin data dbmfilter debug debguts delta diag doc dos dsc embed
                faq faq1 faq2 faq3 faq4 faq5 faq6 faq7 faq8 faq9 filter fork
                form func guts hack hist hpux intern ipc lexwarn locale lol mod
                modinstall modlib number obj op opentut os2 os390 pod port
                ref reftut run sec style sub syn thrtut tie toc todo toot tootc
                trap unicode var vms win32 xs xstut
                }
              )
            {
d7938 3
a7940 3
                CORE::system($doccmd,
                    (($manpath && !$nopathopt) ? ("-M", $manpath) : ()),
                    $page);
d7944 1
a7944 1
    if (defined $oldpath) {
d7995 2
a7996 2
    $IN      = \*STDIN;     # For bugs before DB::OUT has been opened
    $OUT     = \*STDERR;    # For errors before DB::OUT has been opened
d7998 5
a8002 4
    # Define characters used by command parsing. 
    $sh      = '!';         # Shell escape (does not work)
    $rc      = ',';         # Recall command (does not work)
    @@hist    = ('?');       # Show history (does not work)
d8004 1
a8004 1
    # This defines the point at which you get the 'deep recursion' 
d8006 1
a8006 1
    $deep    = 100;
d8008 1
a8008 1
    # Number of lines around the current one that are shown in the 
d8010 1
a8010 1
    $window  = 10;
d8017 1
a8017 1
    $sub     = '';
d8019 1
a8019 1
    # Set up the debugger's interrupt handler. It simply sets a flag 
d8024 1
a8024 1
    # debug itself. Perhaps we can try that someday. 
d8034 2
a8035 2
    $db_stop = 0;           # Compiler warning ...
    $db_stop = 1 << 30;     # ... because this is only used in an eval() later.
d8038 1
a8038 1
    # Used in the debugger prompt, and in determining whether it's all over or 
d8040 1
a8040 1
    $level   = 0;           # Level of recursive debugging
d8044 1
a8044 1
    # of work around it. Stay tuned. 
d8049 1
a8049 1
    $stack_depth = 0;    # Localized repeatedly; simple way to track $#stack
d8052 1
a8052 1
    $doret       = -2;
d8055 1
a8055 1
    $frame       = 0;
d8083 1
a8083 1
    my ($text, $line, $start) = @@_;
d8088 2
a8089 2
    my ($itext, $search, $prefix, $pack) =
      ($text, "^\Q${'package'}::\E([^:]+)\$");
d8109 1
a8109 1
    return sort grep /^\Q$text/, (keys %sub),
d8111 2
a8112 2
      (map { /$search/ ? ($1) : () } keys %sub)
      if (substr $line, 0, $start) =~ /^\|*[blc]\s+((postpone|compile)\s+)?$/;
d8122 1
a8122 1
      if (substr $line, 0, $start) =~ /^\|*b\s+load\s+$/;
d8136 3
a8138 3
    return sort map { ($_, db_complete($_ . "::", "V ", 2)) }
      grep /^\Q$text/, map { /^(.*)::$/ ? ($1) : () } keys %::  # top-packages
      if (substr $line, 0, $start) =~ /^\|*[Vm]\s+$/ and $text =~ /^\w*$/;
d8149 1
a8149 1
    return sort map { ($_, db_complete($_ . "::", "V ", 2)) }
d8151 4
a8154 4
        map { /^(.*)::$/ ? ($prefix . "::$1") : () } keys %{ $prefix . '::' }
          if (substr $line, 0, $start) =~ /^\|*[Vm]\s+$/
              and $text =~ /^(.*[^:])::?(\w*)$/
              and $prefix = $1;
d8173 4
a8176 4
    if ($line =~ /^\|*f\s+(.*)/) {                              # Loaded files
        # We might possibly want to switch to an eval (which has a "filename"
        # like '(eval 9)'), so we may need to clean up the completion text 
        # before proceeding. 
d8190 1
a8190 1
          map { substr $_, 2 + $prefix } grep /^_<\Q$text/, (keys %main::),
d8202 1
a8202 1
    if ((substr $text, 0, 1) eq '&') {    # subroutines
d8205 1
a8205 1
        return sort map "$prefix$_", grep /^\Q$text/, (keys %sub),
d8209 1
a8209 1
              );
d8218 1
a8218 1
    if ($text =~ /^[\$@@%](.*)::(.*)/) {    # symbols in a package
d8228 1
a8228 1
        $pack = ($1 eq 'main' ? '' : $1) . '::';
d8236 2
a8237 2
        $prefix = (substr $text, 0, 1) . $1 . '::';
        $text = $2;
d8254 2
a8255 2
        if (@@out == 1 and $out[0] =~ /::$/ and $out[0] ne $itext) {
            return db_complete($out[0], $line, $start);
d8271 1
a8271 2

    if ($text =~ /^[\$@@%]/) {    # symbols (in $package + packages in main)
d8281 1
a8281 1
        $pack = ($package eq 'main' ? '' : $package) . '::';
d8290 1
a8290 1
        $text = substr $text, 1;
d8299 2
a8300 2
          (grep /^_?[a-zA-Z]/, keys %$pack),
          ($pack eq '::' ? () : (grep /::$/, keys %::));
d8308 2
a8309 2
        if (@@out == 1 and $out[0] =~ /::$/ and $out[0] ne $itext) {
            return db_complete($out[0], $line, $start);
d8326 4
a8329 4
    my $cmd = ($CommandSet eq '580') ? 'o' : 'O';
    if ((substr $line, 0, $start) =~ /^\|*$cmd\b.*\s$/) { # Options after space
        # We look for the text to be matched in the list of possible options, 
        # and fetch the current value. 
d8331 1
a8331 1
        my $val = option_val($out[0], undef);
d8335 3
a8337 2
        if (not defined $val or $val =~ /[\n\r]/) {
           # There's really nothing else we can do.
d8341 2
a8342 1
        elsif ($val =~ /\s/) {
d8349 2
a8350 1
            foreach $l (split //, qq/\"\'\#\|/) {
d8353 1
a8353 1
                $out = "$l$val$l ", last if (index $val, $l) == -1;
d8366 1
a8366 1
          (@@out == 1 ? $out : '? ');
d8406 1
a8406 1
    if (defined($ini_pids)) {
d8410 1
a8410 1
        delete($ENV{PERLDB_PIDS});
d8414 307
d8785 1
a8785 1
    if ($cmd =~ /^(\d*)\s*(.*)/) {
d8792 1
a8792 1
        if (length $j) {
d8795 1
a8795 1
            if ($dbline[$i] == 0) {
d8799 1
d8814 1
d8817 1
d8831 2
a8832 2
    my $xcmd    = shift;
    my $cmd     = shift;
d8836 1
a8836 1
    if ($cmd =~ /^load\b\s*(.*)/) {
d8843 1
a8843 1
    # The interpreter actually traps this one for us; we just put the 
d8845 2
a8846 1
    elsif ($cmd =~ /^(postpone|compile)\b\s*([':A-Za-z_][':\w]*)\s*(.*)/) {
d8852 1
a8852 1
        my ($subname, $break) = ($2, $1 eq 'postpone');
d8862 1
a8862 1
        $subname = "main" . $subname if substr($subname, 0, 2) eq "::";
d8869 1
a8869 1
    elsif ($cmd =~ /^([':A-Za-z_][':\w]*(?:\[.*\])?)\s*(.*)/) {
d8872 1
a8872 1
        &cmd_b_sub($subname, $cond);
d8876 1
a8876 1
    elsif ($cmd =~ /^(\d*)\s*(.*)/) {
d8879 1
a8879 1
        &cmd_b_line($i, $cond);
d8892 1
a8892 1
    if ($cmd =~ /^\s*$/) {
d8898 2
a8899 1
        for $file (keys %had_breakpoints) {
d8907 2
a8908 1
            for ($i = 1 ; $i <= $max ; $i++) {
d8910 2
a8911 1
                if (defined $dbline{$i}) {
d8914 2
a8915 1
                    if ($dbline{$i} =~ s/^\0?$//) {
d8923 1
a8923 1
            # bit, the entry in %had_breakpoints for this file is zero, 
d8925 1
a8925 1
            if (not $had_breakpoints{$file} &= ~1) {
d8950 1
a8950 1
    if ($cmd =~ /^\s*$/) {
d8954 2
a8955 2
    # 'h h' - explicitly-requested summary. 
    elsif ($cmd =~ /^h\s*/) {
d8960 1
a8960 1
    elsif ($cmd =~ /^h\s+(\S.*)$/) {
d8964 2
a8965 1
        if ($pre580_help =~ /^
d8969 3
a8971 1
                            /mx) {
d8982 3
a8984 2
                                  (?!\s)/mgx)   # Line not starting with space
                                                # (Next command's help)
d9008 2
a9009 1
    if ($cmd =~ /^$/) {
d9012 1
d9018 2
a9019 1
    elsif ($cmd =~ /^(.*)/s) {
d9023 1
a9023 1
        # Get the current value of the expression. 
d9027 1
a9027 1
        $val = (defined $val) ? "'$val'" : 'undef';
d9070 2
a9071 1
sub cmd_prepost { my $cmd = shift;
d9082 1
a9082 1
    my $aref  = [];
d9084 1
a9084 1
   # < - Perl code to run before prompt.
d9115 1
a9115 1
    # Yes. 
d9117 1
d9121 1
d9126 1
d9139 2
a9140 1
                    # It's a delete. Get rid of the old actions in the 
d9146 1
d9151 2
a9152 1
            elsif ( length($cmd) == 2 ) { 
d9157 1
a9165 1

d9183 1
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d495 2
a496 1
$VERSION = 1.22;
d682 4
a685 1
# $Log:	perldb.pl,v $
d906 2
d1353 3
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d1 489
d492 2
d495 1
a495 1
$VERSION = 1.19;
d498 97
a594 1
# It is crucial that there is no lexicals in scope of `eval ""' down below
d596 1
d598 2
a599 1
    #    but so does local! --tchrist  [... into @@DB::res, not @@res. IZ]
d602 22
a623 8
	local $otrace = $trace;
	local $osingle = $single;
	local $od = $^D;
	{ ($evalarg) = $evalarg =~ /(.*)/s; }
	@@res = eval "$usercontext $evalarg;\n"; # '\n' for nice recursive debug
	$trace = $otrace;
	$single = $osingle;
	$^D = $od;
d625 3
d629 4
a632 1
    local $saved[0];		# Preserve the old value of $@@
d634 2
d637 2
a638 10
	local $\ = '';
	print $OUT $at;
    } elsif ($onetimeDump) {
      if ($onetimeDump eq 'dump')  {
        local $option{dumpDepth} = $onetimedumpDepth 
          if defined $onetimedumpDepth;
	dumpit($OUT, \@@res);
      } elsif ($onetimeDump eq 'methods') {
	methods($res[0]) ;
      }
d640 13
d654 3
a656 1
}
d658 3
a660 2
# After this point it is safe to introduce lexicals
# However, one should not overdo it: leave as much control from outside as possible
d662 4
d672 5
a676 28
# Perl supplies the values for %sub.  It effectively inserts
# a &DB::DB(); in front of every place that can have a
# breakpoint. Instead of a subroutine call it calls &DB::sub with
# $DB::sub being the called subroutine. It also inserts a BEGIN
# {require 'perl5db.pl'} before the first line.
#
# After each `require'd file is compiled, but before it is executed, a
# call to DB::postponed($main::{'_<'.$filename}) is emulated. Here the
# $filename is the expanded name of the `require'd file (as found as
# value of %INC).
#
# Additional services from Perl interpreter:
#
# if caller() is called from the package DB, it provides some
# additional data.
#
# The array @@{$main::{'_<'.$filename}} (herein called @@dbline) is the
# line-by-line contents of $filename.
#
# The hash %{'_<'.$filename} (herein called %dbline) contains
# breakpoints and action (it is keyed by line number), and individual
# entries are settable (as opposed to the whole hash). Only true/false
# is important to the interpreter, though the values used by
# perl5db.pl have the form "$break_condition\0$action". Values are
# magical in numeric context.
#
# The scalar ${'_<'.$filename} contains $filename.
#
a682 39
#
# At start reads $rcfile that may set important options.  This file
# may define a subroutine &afterinit that will be executed after the
# debugger is initialized.
#
# After $rcfile is read reads environment variable PERLDB_OPTS and parses
# it as a rest of `O ...' line in debugger prompt.
#
# The options that can be specified only at startup:
# [To set in $rcfile, call &parse_options("optionName=new_value").]
#
# TTY  - the TTY to use for debugging i/o.
#
# noTTY - if set, goes in NonStop mode.  On interrupt if TTY is not set
# uses the value of noTTY or "/tmp/perldbtty$$" to find TTY using
# Term::Rendezvous.  Current variant is to have the name of TTY in this
# file.
#
# ReadLine - If false, dummy ReadLine is used, so you can debug
# ReadLine applications.
#
# NonStop - if true, no i/o is performed until interrupt.
#
# LineInfo - file or pipe to print line number info to.  If it is a
# pipe, a short "emacs like" message is used.
#
# RemotePort - host:port to connect to on remote host for remote debugging.
#
# Example $rcfile: (delete leading hashes!)
#
# &parse_options("NonStop=1 LineInfo=db.out");
# sub afterinit { $trace = 1; }
#
# The script will run without human intervention, putting trace
# information into db.out.  (If you interrupt it, you would better
# reset LineInfo to something "interactive"!)
#
##################################################################

d690 40
a729 34
# Changelog:

# A lot of things changed after 0.94. First of all, core now informs
# debugger about entry into XSUBs, overloaded operators, tied operations,
# BEGIN and END. Handy with `O f=2'.

# This can make debugger a little bit too verbose, please be patient
# and report your problems promptly.

# Now the option frame has 3 values: 0,1,2.

# Note that if DESTROY returns a reference to the object (or object),
# the deletion of data may be postponed until the next function call,
# due to the need to examine the return value.

# Changes: 0.95: `v' command shows versions.
# Changes: 0.96: `v' command shows version of readline.
#	primitive completion works (dynamic variables, subs for `b' and `l',
#		options). Can `p %var'
#	Better help (`h <' now works). New commands <<, >>, {, {{.
#	{dump|print}_trace() coded (to be able to do it from <<cmd).
#	`c sub' documented.
#	At last enough magic combined to stop after the end of debuggee.
#	!! should work now (thanks to Emacs bracket matching an extra
#	`]' in a regexp is caught).
#	`L', `D' and `A' span files now (as documented).
#	Breakpoints in `require'd code are possible (used in `R').
#	Some additional words on internal work of debugger.
#	`b load filename' implemented.
#	`b postpone subr' implemented.
#	now only `q' exits debugger (overwritable on $inhibit_exit).
#	When restarting debugger breakpoints/actions persist.
#     Buglet: When restarting debugger only one breakpoint/action per 
#		autoloaded function persists.
d731 4
a734 4
#	Option AutoTrace implemented.
#	Trace printed differently if frames are printed too.
#	new `inhibitExit' option.
#	printing of a very long statement interruptible.
d736 11
a746 11
#	'l -' is a synonym for `-'.
#	Cosmetic bugs in printing stack trace.
#	`frame' & 8 to print "expanded args" in stack trace.
#	Can list/break in imported subs.
#	new `maxTraceLen' option.
#	frame & 4 and frame & 8 granted.
#	new command `m'
#	nonstoppable lines do not have `:' near the line number.
#	`b compile subname' implemented.
#	Will not use $` any more.
#	`-' behaves sane now.
d748 4
a751 4
#	`m' will remove duplicate names instead of duplicate functions.
#	`b load' strips trailing whitespace.
#	completion ignores leading `|'; takes into account current package
#	when completing a subroutine name (same for `l').
d803 20
a822 19
#   0) Minor bugs corrected;
#   a) Support for auto-creation of new TTY window on startup, either
#      unconditionally, or if started as a kid of another debugger session;
#   b) New `O'ption CreateTTY
#       I<CreateTTY>       bits control attempts to create a new TTY on events:
#                          1: on fork()   2: debugger is started inside debugger
#                          4: on startup
#   c) Code to auto-create a new TTY window on OS/2 (currently one
#      extra window per session - need named pipes to have more...);
#   d) Simplified interface for custom createTTY functions (with a backward
#      compatibility hack); now returns the TTY name to use; return of ''
#      means that the function reset the I/O handles itself;
#   d') Better message on the semantic of custom createTTY function;
#   e) Convert the existing code to create a TTY into a custom createTTY
#      function;
#   f) Consistent support for TTY names of the form "TTYin,TTYout";
#   g) Switch line-tracing output too to the created TTY window;
#   h) make `b fork' DWIM with CORE::GLOBAL::fork;
#   i) High-level debugger API cmd_*():
d830 1
a830 1
#   j) Low-level debugger API
d836 2
a837 1
#                                           # to $from, and may be less than $to
d840 2
a841 1
#                                           # Set breakpoint,$cond defaults to 1
d876 1
a876 1
#	+ $onetimeDump improvements
d884 2
a885 1
#   + w(add),       W(del)            # watch  expr   (was W,W) added del by expr
d894 9
a902 1
# 
d905 13
d919 42
a960 17

BEGIN { $ini_warn = $^W; $^W = 0 } # Switch compilation warnings off until another BEGIN.
local($^W) = 0;			# Switch run-time warnings off during init.
warn (			# Do not ;-)
      $dumpvar::hashDepth,     
      $dumpvar::arrayDepth,    
      $dumpvar::dumpDBFiles,   
      $dumpvar::dumpPackages,  
      $dumpvar::quoteHighBit,  
      $dumpvar::printUndef,    
      $dumpvar::globPrint,     
      $dumpvar::usageOnly,
      @@ARGS,
      $Carp::CarpLevel,
      $panic,
      $second_time,
     ) if 0;
d963 1
d966 2
d970 7
a976 2
$trace = $signal = $single = 0;	# Uninitialized warning suppression
                                # (local $^W cannot help - other packages!).
d979 1
a979 51
@@options     = qw(hashDepth arrayDepth CommandSet dumpDepth
                  DumpDBFiles DumpPackages DumpReused
		  compactDump veryCompact quote HighBit undefPrint
		  globPrint PrintRet UsageOnly frame AutoTrace
		  TTY noTTY ReadLine NonStop LineInfo maxTraceLen
		  recallCommand ShellBang pager tkRunning ornaments
		  signalLevel warnLevel dieLevel inhibit_exit
		  ImmediateStop bareStringify CreateTTY
		  RemotePort windowSize);

%optionVars    = (
		 hashDepth	=> \$dumpvar::hashDepth,
		 arrayDepth	=> \$dumpvar::arrayDepth,
		 CommandSet => \$CommandSet,
		 DumpDBFiles	=> \$dumpvar::dumpDBFiles,
		 DumpPackages	=> \$dumpvar::dumpPackages,
		 DumpReused	=> \$dumpvar::dumpReused,
		 HighBit	=> \$dumpvar::quoteHighBit,
		 undefPrint	=> \$dumpvar::printUndef,
		 globPrint	=> \$dumpvar::globPrint,
		 UsageOnly	=> \$dumpvar::usageOnly,
		 CreateTTY	=> \$CreateTTY,
		 bareStringify	=> \$dumpvar::bareStringify,
		 frame          => \$frame,
		 AutoTrace      => \$trace,
		 inhibit_exit   => \$inhibit_exit,
		 maxTraceLen	=> \$maxtrace,
		 ImmediateStop	=> \$ImmediateStop,
		 RemotePort	=> \$remoteport,
		 windowSize	=> \$window,
);

%optionAction  = (
		  compactDump	=> \&dumpvar::compactDump,
		  veryCompact	=> \&dumpvar::veryCompact,
		  quote		=> \&dumpvar::quote,
		  TTY		=> \&TTY,
		  noTTY		=> \&noTTY,
		  ReadLine	=> \&ReadLine,
		  NonStop	=> \&NonStop,
		  LineInfo	=> \&LineInfo,
		  recallCommand	=> \&recallCommand,
		  ShellBang	=> \&shellBang,
		  pager		=> \&pager,
		  signalLevel	=> \&signalLevel,
		  warnLevel	=> \&warnLevel,
		  dieLevel	=> \&dieLevel,
		  tkRunning	=> \&tkRunning,
		  ornaments	=> \&ornaments,
		  RemotePort	=> \&RemotePort,
		 );
d981 95
d1077 34
a1110 4
		  compactDump	=> 'dumpvar.pl',
		  veryCompact	=> 'dumpvar.pl',
		  quote		=> 'dumpvar.pl',
		 );
d1113 15
a1127 9
$rl		= 1	unless defined $rl;
$warnLevel	= 1	unless defined $warnLevel;
$dieLevel	= 1	unless defined $dieLevel;
$signalLevel	= 1	unless defined $signalLevel;
$pre		= []	unless defined $pre;
$post		= []	unless defined $post;
$pretype	= []	unless defined $pretype;
$CreateTTY	= 3	unless defined $CreateTTY;
$CommandSet = '580'	unless defined $CommandSet;
d1133 10
d1144 22
a1165 5
      defined $ENV{PAGER}              ? $ENV{PAGER} :
      eval { require Config } && 
        defined $Config::Config{pager} ? $Config::Config{pager}
                                       : 'more'
     ) unless defined $pager;
d1167 3
d1171 10
a1180 1
&shellBang("!") unless defined $psh;
d1182 3
d1186 23
d1210 16
a1225 8
if (defined $ENV{PERLDB_PIDS}) {
  $pids = "[$ENV{PERLDB_PIDS}]";
  $ENV{PERLDB_PIDS} .= "->$$";
  $term_pid = -1;
} else {
  $ENV{PERLDB_PIDS} = "$$";
  $pids = "{pid=$$}";
  $term_pid = $$;
d1227 1
a1228 1
*emacs = $slave_editor if $slave_editor;	# May be used in afterinit()...
d1230 14
a1243 4
if (-e "/dev/tty") {  # this is the wrong metric!
  $rcfile=".perldb";
} else {
  $rcfile="perldb.ini";
d1245 5
d1251 7
d1262 2
a1263 2
# your lexical scope, which is unfortunately at best.
sub safe_do { 
d1267 2
a1268 2
    local $SIG{__WARN__};  
    local $SIG{__DIE__};    
d1271 1
a1271 1
	CORE::warn <<EO_GRIPE;
d1274 1
a1274 1
	be writable by anyone but its owner.
d1276 2
a1277 2
	return;
    } 
d1281 1
a1281 2
}

d1283 2
d1293 2
a1294 2
    stat($path) || return;	# mysteriously vaporized
    my($dev,$ino,$mode,$nlink,$uid,$gid) = stat(_);
d1299 1
a1299 1
}
d1301 2
d1305 2
a1306 1
} 
d1310 1
d1315 1
d1317 1
a1317 1
  parse_options($ENV{PERLDB_OPTS});
d1320 53
a1372 6
if ( not defined &get_fork_TTY and defined $ENV{TERM} and $ENV{TERM} eq 'xterm'
     and defined $ENV{WINDOWID} and defined $ENV{DISPLAY} ) { # _inside_ XTERM?
    *get_fork_TTY = \&xterm_get_fork_TTY;
} elsif ($^O eq 'os2') {
    *get_fork_TTY = \&os2_get_fork_TTY;
}
d1374 1
a1374 1
# Here begin the unreadable code.  It needs fixing.
d1377 43
a1419 22
  delete $ENV{PERLDB_RESTART};
  # $restart = 1;
  @@hist = get_list('PERLDB_HIST');
  %break_on_load = get_list("PERLDB_ON_LOAD");
  %postponed = get_list("PERLDB_POSTPONE");
  my @@had_breakpoints= get_list("PERLDB_VISITED");
  for (0 .. $#had_breakpoints) {
    my %pf = get_list("PERLDB_FILE_$_");
    $postponed_file{$had_breakpoints[$_]} = \%pf if %pf;
  }
  my %opt = get_list("PERLDB_OPT");
  my ($opt,$val);
  while (($opt,$val) = each %opt) {
    $val =~ s/[\\\']/\\$1/g;
    parse_options("$opt'$val'");
  }
  @@INC = get_list("PERLDB_INC");
  @@ini_INC = @@INC;
  $pretype = [get_list("PERLDB_PRETYPE")];
  $pre = [get_list("PERLDB_PRE")];
  $post = [get_list("PERLDB_POST")];
  @@typeahead = get_list("PERLDB_TYPEAHEAD", @@typeahead);
d1422 87
a1508 72
if ($notty) {
  $runnonstop = 1;
} else {
  # Is Perl being run from a slave editor or graphical debugger?
  $slave_editor = ((defined $main::ARGV[0]) and ($main::ARGV[0] eq '-emacs'));
  $rl = 0, shift(@@main::ARGV) if $slave_editor;

  #require Term::ReadLine;

  if ($^O eq 'cygwin') {
    # /dev/tty is binary. use stdin for textmode
    undef $console;
  } elsif (-e "/dev/tty") {
    $console = "/dev/tty";
  } elsif ($^O eq 'dos' or -e "con" or $^O eq 'MSWin32') {
    $console = "con";
  } elsif ($^O eq 'MacOS') {
    if ($MacPerl::Version !~ /MPW/) {
      $console = "Dev:Console:Perl Debug"; # Separate window for application
    } else {
      $console = "Dev:Console";
    }
  } else {
    $console = "sys\$command";
  }

  if (($^O eq 'MSWin32') and ($slave_editor or defined $ENV{EMACS})) {
    $console = undef;
  }

  if ($^O eq 'NetWare') {
	$console = undef;
  }

  # Around a bug:
  if (defined $ENV{OS2_SHELL} and ($slave_editor or $ENV{WINDOWID})) { # In OS/2
    $console = undef;
  }

  if ($^O eq 'epoc') {
    $console = undef;
  }

  $console = $tty if defined $tty;

  if (defined $remoteport) {
    require IO::Socket;
    $OUT = new IO::Socket::INET( Timeout  => '10',
                                 PeerAddr => $remoteport,
                                 Proto    => 'tcp',
                               );
    if (!$OUT) { die "Unable to connect to remote host: $remoteport\n"; }
    $IN = $OUT;
  } else {
    create_IN_OUT(4) if $CreateTTY & 4;
    if ($console) {
      my ($i, $o) = split /,/, $console;
      $o = $i unless defined $o;
      open(IN,"+<$i") || open(IN,"<$i") || open(IN,"<&STDIN");
      open(OUT,"+>$o") || open(OUT,">$o") || open(OUT,">&STDERR")
        || open(OUT,">&STDOUT");	# so we don't dongle stdout
    } elsif (not defined $console) {
      open(IN,"<&STDIN");
      open(OUT,">&STDERR") || open(OUT,">&STDOUT"); # so we don't dongle stdout
      $console = 'STDIN/OUT';
    }
    # so open("|more") can read from STDOUT and so we don't dingle stdin
    $IN = \*IN, $OUT = \*OUT if $console or not defined $console;
  }
  my $previous = select($OUT);
  $| = 1;			# for DB::OUT
  select($previous);
d1510 4
a1513 2
  $LINEINFO = $OUT unless defined $LINEINFO;
  $lineinfo = $console unless defined $lineinfo;
d1515 9
a1523 12
  $header =~ s/.Header: ([^,]+),v(\s+\S+\s+\S+).*$/$1$2/;
  unless ($runnonstop) {
    local $\ = '';
    local $, = '';
    if ($term_pid eq '-1') {
      print $OUT "\nDaughter DB session started...\n";
    } else {
      print $OUT "\nLoading DB routines from $header\n";
      print $OUT ("Editor support ",
		  $slave_editor ? "enabled" : "available",
		  ".\n");
      print $OUT "\nEnter h or `h h' for help, or `$doccmd perldebug' for more help.\n\n";
a1524 2
  }
}
d1526 126
d1654 2
d1660 4
a1663 2
if (defined &afterinit) {	# May be defined in $rcfile
  &afterinit();
d1665 1
a1665 1

d1670 17
d1688 2
d1692 29
a1720 12
      if ($runnonstop) {	# Disable until signal
	for ($i=0; $i <= $stack_depth; ) {
	    $stack[$i++] &= ~1;
	}
	$single = 0;
	# return;			# Would not print trace!
      } elsif ($ImmediateStop) {
	$ImmediateStop = 0;
	$signal = 1;
      }
    }
    $runnonstop = 0 if $single or $signal; # Disable it if interactive.
d1722 6
a1727 1
    local($package, $filename, $line) = caller;
d1729 11
a1739 3
    local $usercontext = '($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;' .
      "package $package;";	# this won't let them modify, alas
    local(*dbline) = $main::{'_<' . $filename};
d1744 2
a1745 2
	$filename_ini = $filename = 'Dev:Pseudo';
	*dbline = $main::{'_<' . $filename};
d1748 1
d1750 18
a1767 8
    if ($dbline{$line} && (($stop,$action) = split(/\0/,$dbline{$line}))) {
		if ($stop eq '1') {
			$signal |= 1;
		} elsif ($stop) {
			$evalarg = "\$DB::signal |= 1 if do {$stop}"; &eval;
			$dbline{$line} =~ s/;9($|\0)/$1/;
		}
    }
d1769 2
d1772 15
a1786 8
      for (my $n = 0; $n <= $#to_watch; $n++) {
		$evalarg = $to_watch[$n];
		local $onetimeDump;	# Do not output results
		my ($val) = &eval;	# Fix context (&eval is doing array)?
		$val = ( (defined $val) ? "'$val'" : 'undef' );
		if ($val ne $old_watch[$n]) {
		  $signal = 1;
		  print $OUT <<EOP;
d1791 50
a1840 8
		  $old_watch[$n] = $val;
		}
      }
    }
    if ($trace & 4) {		# User-installed watch
      return if watchfunction($package, $filename, $line) 
	and not $single and not $was_signal and not ($trace & ~4);
    }
d1842 13
a1854 1
    $signal = 0;
d1856 19
a1874 6
	if ($slave_editor) {
	    $position = "\032\032$filename:$line:0\n";
	    print_lineinfo($position);
	} elsif ($package eq 'DB::fake') {
	  $term || &setterm;
	  print_help(<<EOP);
d1879 85
a1963 35
	  $package = 'main';
	  $usercontext = '($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;' .
	    "package $package;";	# this won't let them modify, alas
	} else {
	    $sub =~ s/\'/::/;
	    $prefix = $sub =~ /::/ ? "" : "${'package'}::";
	    $prefix .= "$sub($filename:";
	    $after = ($dbline[$line] =~ /\n$/ ? '' : "\n");
	    if (length($prefix) > 30) {
	        $position = "$prefix$line):\n$line:\t$dbline[$line]$after";
			$prefix = "";
			$infix = ":\t";
	    } else {
			$infix = "):\t";
			$position = "$prefix$line$infix$dbline[$line]$after";
	    }
	    if ($frame) {
			print_lineinfo(' ' x $stack_depth, "$line:\t$dbline[$line]$after");
	    } else {
			print_lineinfo($position);
	    }
	    for ($i = $line + 1; $i <= $max && $dbline[$i] == 0; ++$i) { #{ vi
			last if $dbline[$i] =~ /^\s*[\;\}\#\n]/;
			last if $signal;
			$after = ($dbline[$i] =~ /\n$/ ? '' : "\n");
			$incr_pos = "$prefix$i$infix$dbline[$i]$after";
			$position .= $incr_pos;
			if ($frame) {
				print_lineinfo(' ' x $stack_depth, "$i:\t$dbline[$i]$after");
			} else {
				print_lineinfo($incr_pos);
			}
	    }
	}
    }
d1965 3
d1969 79
a2047 14
	  local $level = $level + 1;
	  foreach $evalarg (@@$pre) {
	    &eval;
	  }
	  print $OUT $stack_depth . " levels deep in subroutine calls!\n"
              if $single & 4;
		$start = $line;
		$incr = -1;		# for backward motion.
		@@typeahead = (@@$pretype, @@typeahead);
    CMD:
	while (($term || &setterm),
	       ($term_pid == $$ or resetterm(1)),
	       defined ($cmd=&readline("$pidprompt  DB" . ('<' x $level) .
				       ($#hist+1) . ('>' x $level) . " "))) 
d2049 1
a2049 594
		$single = 0;
		$signal = 0;
		$cmd =~ s/\\$/\n/ && do {
		    $cmd .= &readline("  cont: ");
		    redo CMD;
		};
		$cmd =~ /^$/ && ($cmd = $laststep);
		push(@@hist,$cmd) if length($cmd) > 1;
	      PIPE: {
		    $cmd =~ s/^\s+//s;   # trim annoying leading whitespace
		    $cmd =~ s/\s+$//s;   # trim annoying trailing whitespace
		    ($i) = split(/\s+/,$cmd);
		    if ($alias{$i}) { 
					# squelch the sigmangler
					local $SIG{__DIE__};
					local $SIG{__WARN__};
					eval "\$cmd =~ $alias{$i}";
					if ($@@) {
                                                local $\ = '';
						print $OUT "Couldn't evaluate `$i' alias: $@@";
						next CMD;
					} 
		    }
                    $cmd =~ /^q$/ && do {
                        $fall_off_end = 1;
                        clean_ENV();
                        exit $?;
                    };
		    $cmd =~ /^t$/ && do {
			$trace ^= 1;
			local $\ = '';
			print $OUT "Trace = " .
			    (($trace & 1) ? "on" : "off" ) . "\n";
			next CMD; };
		    $cmd =~ /^S(\s+(!)?(.+))?$/ && do {
			$Srev = defined $2; $Spatt = $3; $Snocheck = ! defined $1;
			local $\ = '';
			local $, = '';
			foreach $subname (sort(keys %sub)) {
			    if ($Snocheck or $Srev^($subname =~ /$Spatt/)) {
				print $OUT $subname,"\n";
			    }
			}
			next CMD; };
		    $cmd =~ s/^X\b/V $package/;
		    $cmd =~ /^V$/ && do {
			$cmd = "V $package"; };
		    $cmd =~ /^V\b\s*(\S+)\s*(.*)/ && do {
			local ($savout) = select($OUT);
			$packname = $1;
			@@vars = split(' ',$2);
			do 'dumpvar.pl' unless defined &main::dumpvar;
			if (defined &main::dumpvar) {
			    local $frame = 0;
			    local $doret = -2;
			    # must detect sigpipe failures
                           eval { &main::dumpvar($packname,
                                                 defined $option{dumpDepth}
                                                  ? $option{dumpDepth} : -1,
                                                 @@vars) };
			    if ($@@) {
				die unless $@@ =~ /dumpvar print failed/;
			    } 
			} else {
			    print $OUT "dumpvar.pl not available.\n";
			}
			select ($savout);
			next CMD; };
		    $cmd =~ s/^x\b/ / && do { # So that will be evaled
			$onetimeDump = 'dump'; 
                        # handle special  "x 3 blah" syntax
                        if ($cmd =~ s/^\s*(\d+)(?=\s)/ /) {
                          $onetimedumpDepth = $1;
                        }
                      };
		    $cmd =~ s/^m\s+([\w:]+)\s*$/ / && do {
			methods($1); next CMD};
		    $cmd =~ s/^m\b/ / && do { # So this will be evaled
			$onetimeDump = 'methods'; };
		    $cmd =~ /^f\b\s*(.*)/ && do {
			$file = $1;
			$file =~ s/\s+$//;
			if (!$file) {
			    print $OUT "The old f command is now the r command.\n"; # hint
			    print $OUT "The new f command switches filenames.\n";
			    next CMD;
			}
			if (!defined $main::{'_<' . $file}) {
			    if (($try) = grep(m#^_<.*$file#, keys %main::)) {{
					      $try = substr($try,2);
					      print $OUT "Choosing $try matching `$file':\n";
					      $file = $try;
					  }}
			}
			if (!defined $main::{'_<' . $file}) {
			    print $OUT "No file matching `$file' is loaded.\n";
			    next CMD;
			} elsif ($file ne $filename) {
			    *dbline = $main::{'_<' . $file};
			    $max = $#dbline;
			    $filename = $file;
			    $start = 1;
			    $cmd = "l";
			  } else {
			    print $OUT "Already in $file.\n";
			    next CMD;
			  }
		      };
		    $cmd =~ /^\.$/ && do {
			$incr = -1;		# for backward motion.
			$start = $line;
			$filename = $filename_ini;
			*dbline = $main::{'_<' . $filename};
			$max = $#dbline;
			print_lineinfo($position);
			next CMD };
		    $cmd =~ /^-$/ && do {
			$start -= $incr + $window + 1;
			$start = 1 if $start <= 0;
			$incr = $window - 1;
			$cmd = 'l ' . ($start) . '+'; };
			# rjsf ->
		  $cmd =~ /^([aAbBhlLMoOvwW])\b\s*(.*)/s && do { 
				&cmd_wrapper($1, $2, $line); 
				next CMD; 
			};
			# <- rjsf
		  $cmd =~ /^\<\<\s*(.*)/ && do { # \<\< for CPerl sake: not HERE
			push @@$pre, action($1);
			next CMD; };
		    $cmd =~ /^>>\s*(.*)/ && do {
			push @@$post, action($1);
			next CMD; };
		    $cmd =~ /^<\s*(.*)/ && do {
			unless ($1) {
			    print $OUT "All < actions cleared.\n";
			    $pre = [];
			    next CMD;
			} 
			if ($1 eq '?') {
			    unless (@@$pre) {
				print $OUT "No pre-prompt Perl actions.\n";
				next CMD;
			    } 
			    print $OUT "Perl commands run before each prompt:\n";
			    for my $action ( @@$pre ) {
				print $OUT "\t< -- $action\n";
			    } 
			    next CMD;
			} 
			$pre = [action($1)];
			next CMD; };
		    $cmd =~ /^>\s*(.*)/ && do {
			unless ($1) {
			    print $OUT "All > actions cleared.\n";
			    $post = [];
			    next CMD;
			}
			if ($1 eq '?') {
			    unless (@@$post) {
				print $OUT "No post-prompt Perl actions.\n";
				next CMD;
			    } 
			    print $OUT "Perl commands run after each prompt:\n";
			    for my $action ( @@$post ) {
				print $OUT "\t> -- $action\n";
			    } 
			    next CMD;
			} 
			$post = [action($1)];
			next CMD; };
		    $cmd =~ /^\{\{\s*(.*)/ && do {
			if ($cmd =~ /^\{.*\}$/ && unbalanced(substr($cmd,2))) { 
			    print $OUT "{{ is now a debugger command\n",
				"use `;{{' if you mean Perl code\n";
			    $cmd = "h {{";
			    redo CMD;
			} 
			push @@$pretype, $1;
			next CMD; };
		    $cmd =~ /^\{\s*(.*)/ && do {
			unless ($1) {
			    print $OUT "All { actions cleared.\n";
			    $pretype = [];
			    next CMD;
			}
			if ($1 eq '?') {
			    unless (@@$pretype) {
				print $OUT "No pre-prompt debugger actions.\n";
				next CMD;
			    } 
			    print $OUT "Debugger commands run before each prompt:\n";
			    for my $action ( @@$pretype ) {
				print $OUT "\t{ -- $action\n";
			    } 
			    next CMD;
			} 
			if ($cmd =~ /^\{.*\}$/ && unbalanced(substr($cmd,1))) { 
			    print $OUT "{ is now a debugger command\n",
				"use `;{' if you mean Perl code\n";
			    $cmd = "h {";
			    redo CMD;
			} 
			$pretype = [$1];
			next CMD; };
                   $cmd =~ /^y(?:\s+(\d*)\s*(.*))?$/ && do {
                       eval { require PadWalker; PadWalker->VERSION(0.08) }
                         or &warn($@@ =~ /locate/
                            ? "PadWalker module not found - please install\n"
                            : $@@)
                          and next CMD;
                       do 'dumpvar.pl' unless defined &main::dumpvar;
                       defined &main::dumpvar
                          or print $OUT "dumpvar.pl not available.\n"
                          and next CMD;
                       my @@vars = split(' ', $2 || '');
                       my $h = eval { PadWalker::peek_my(($1 || 0) + 1) };
                       $@@ and $@@ =~ s/ at .*//, &warn($@@), next CMD;
                       my $savout = select($OUT);
                       dumpvar::dumplex($_, $h->{$_}, 
                                       defined $option{dumpDepth}
                                       ? $option{dumpDepth} : -1,
                                       @@vars)
                           for sort keys %$h;
                       select($savout);
                       next CMD; };
                   $cmd =~ /^n$/ && do {
		        end_report(), next CMD if $finished and $level <= 1;
			$single = 2;
			$laststep = $cmd;
			last CMD; };
		    $cmd =~ /^s$/ && do {
		        end_report(), next CMD if $finished and $level <= 1;
			$single = 1;
			$laststep = $cmd;
			last CMD; };
		    $cmd =~ /^c\b\s*([\w:]*)\s*$/ && do {
		        end_report(), next CMD if $finished and $level <= 1;
			$subname = $i = $1;
			#  Probably not needed, since we finish an interactive
			#  sub-session anyway...
			# local $filename = $filename;
			# local *dbline = *dbline;	# XXX Would this work?!
			if ($subname =~ /\D/) { # subroutine name
			    $subname = $package."::".$subname 
			        unless $subname =~ /::/;
			    ($file,$i) = (find_sub($subname) =~ /^(.*):(.*)$/);
			    $i += 0;
			    if ($i) {
			        $filename = $file;
				*dbline = $main::{'_<' . $filename};
				$had_breakpoints{$filename} |= 1;
				$max = $#dbline;
				++$i while $dbline[$i] == 0 && $i < $max;
			    } else {
				print $OUT "Subroutine $subname not found.\n";
				next CMD; 
			    }
			}
			if ($i) {
			    if ($dbline[$i] == 0) {
				print $OUT "Line $i not breakable.\n";
				next CMD;
			    }
			    $dbline{$i} =~ s/($|\0)/;9$1/; # add one-time-only b.p.
			}
			for ($i=0; $i <= $stack_depth; ) {
			    $stack[$i++] &= ~1;
			}
			last CMD; };
		    $cmd =~ /^r$/ && do {
		        end_report(), next CMD if $finished and $level <= 1;
			$stack[$stack_depth] |= 1;
			$doret = $option{PrintRet} ? $stack_depth - 1 : -2;
			last CMD; };
		    $cmd =~ /^R$/ && do {
		        print $OUT "Warning: some settings and command-line options may be lost!\n";
			my (@@script, @@flags, $cl);
			push @@flags, '-w' if $ini_warn;
			# Put all the old includes at the start to get
			# the same debugger.
			for (@@ini_INC) {
			  push @@flags, '-I', $_;
			}
			push @@flags, '-T' if ${^TAINT};
			# Arrange for setting the old INC:
			set_list("PERLDB_INC", @@ini_INC);
			if ($0 eq '-e') {
			  for (1..$#{'::_<-e'}) { # The first line is PERL5DB
			        chomp ($cl =  ${'::_<-e'}[$_]);
			    push @@script, '-e', $cl;
			  }
			} else {
			  @@script = $0;
			}
			set_list("PERLDB_HIST", 
				 $term->Features->{getHistory} 
				 ? $term->GetHistory : @@hist);
			my @@had_breakpoints = keys %had_breakpoints;
			set_list("PERLDB_VISITED", @@had_breakpoints);
			set_list("PERLDB_OPT", %option);
			set_list("PERLDB_ON_LOAD", %break_on_load);
			my @@hard;
			for (0 .. $#had_breakpoints) {
			  my $file = $had_breakpoints[$_];
			  *dbline = $main::{'_<' . $file};
			  next unless %dbline or $postponed_file{$file};
			  (push @@hard, $file), next 
			    if $file =~ /^\(\w*eval/;
			  my @@add;
			  @@add = %{$postponed_file{$file}}
			    if $postponed_file{$file};
			  set_list("PERLDB_FILE_$_", %dbline, @@add);
			}
			for (@@hard) { # Yes, really-really...
			  # Find the subroutines in this eval
			  *dbline = $main::{'_<' . $_};
			  my ($quoted, $sub, %subs, $line) = quotemeta $_;
			  for $sub (keys %sub) {
			    next unless $sub{$sub} =~ /^$quoted:(\d+)-(\d+)$/;
			    $subs{$sub} = [$1, $2];
			  }
			  unless (%subs) {
			    print $OUT
			      "No subroutines in $_, ignoring breakpoints.\n";
			    next;
			  }
			LINES: for $line (keys %dbline) {
			    # One breakpoint per sub only:
			    my ($offset, $sub, $found);
			  SUBS: for $sub (keys %subs) {
			      if ($subs{$sub}->[1] >= $line # Not after the subroutine
				  and (not defined $offset # Not caught
				       or $offset < 0 )) { # or badly caught
				$found = $sub;
				$offset = $line - $subs{$sub}->[0];
				$offset = "+$offset", last SUBS if $offset >= 0;
			      }
			    }
			    if (defined $offset) {
			      $postponed{$found} =
				"break $offset if $dbline{$line}";
			    } else {
			      print $OUT "Breakpoint in $_:$line ignored: after all the subroutines.\n";
			    }
			  }
			}
			set_list("PERLDB_POSTPONE", %postponed);
			set_list("PERLDB_PRETYPE", @@$pretype);
			set_list("PERLDB_PRE", @@$pre);
			set_list("PERLDB_POST", @@$post);
			set_list("PERLDB_TYPEAHEAD", @@typeahead);
			$ENV{PERLDB_RESTART} = 1;
			delete $ENV{PERLDB_PIDS}; # Restore ini state
			$ENV{PERLDB_PIDS} = $ini_pids if defined $ini_pids;
			#print "$^X, '-d', @@flags, @@script, ($slave_editor ? '-emacs' : ()), @@ARGS";
			exec($^X, '-d', @@flags, @@script, ($slave_editor ? '-emacs' : ()), @@ARGS) ||
			print $OUT "exec failed: $!\n";
			last CMD; };
		    $cmd =~ /^T$/ && do {
			print_trace($OUT, 1); # skip DB
			next CMD; };
		    $cmd =~ /^w\b\s*(.*)/s && do { &cmd_w($1); next CMD; };
		    $cmd =~ /^W\b\s*(.*)/s && do { &cmd_W($1); next CMD; };
		    $cmd =~ /^\/(.*)$/ && do {
			$inpat = $1;
			$inpat =~ s:([^\\])/$:$1:;
			if ($inpat ne "") {
			    # squelch the sigmangler
			    local $SIG{__DIE__};
			    local $SIG{__WARN__};
			    eval '$inpat =~ m'."\a$inpat\a";	
			    if ($@@ ne "") {
				print $OUT "$@@";
				next CMD;
			    }
			    $pat = $inpat;
			}
			$end = $start;
			$incr = -1;
			eval '
			    for (;;) {
				++$start;
				$start = 1 if ($start > $max);
				last if ($start == $end);
				if ($dbline[$start] =~ m' . "\a$pat\a" . 'i) {
				    if ($slave_editor) {
					print $OUT "\032\032$filename:$start:0\n";
				    } else {
					print $OUT "$start:\t", $dbline[$start], "\n";
				    }
				    last;
				}
			    } ';
			print $OUT "/$pat/: not found\n" if ($start == $end);
			next CMD; };
		    $cmd =~ /^\?(.*)$/ && do {
			$inpat = $1;
			$inpat =~ s:([^\\])\?$:$1:;
			if ($inpat ne "") {
			    # squelch the sigmangler
			    local $SIG{__DIE__};
			    local $SIG{__WARN__};
			    eval '$inpat =~ m'."\a$inpat\a";	
			    if ($@@ ne "") {
				print $OUT $@@;
				next CMD;
			    }
			    $pat = $inpat;
			}
			$end = $start;
			$incr = -1;
			eval '
			    for (;;) {
				--$start;
				$start = $max if ($start <= 0);
				last if ($start == $end);
				if ($dbline[$start] =~ m' . "\a$pat\a" . 'i) {
				    if ($slave_editor) {
					print $OUT "\032\032$filename:$start:0\n";
				    } else {
					print $OUT "$start:\t", $dbline[$start], "\n";
				    }
				    last;
				}
			    } ';
			print $OUT "?$pat?: not found\n" if ($start == $end);
			next CMD; };
		    $cmd =~ /^$rc+\s*(-)?(\d+)?$/ && do {
			pop(@@hist) if length($cmd) > 1;
			$i = $1 ? ($#hist-($2||1)) : ($2||$#hist);
			$cmd = $hist[$i];
			print $OUT $cmd, "\n";
			redo CMD; };
		    $cmd =~ /^$sh$sh\s*([\x00-\xff]*)/ && do {
			&system($1);
			next CMD; };
		    $cmd =~ /^$rc([^$rc].*)$/ && do {
			$pat = "^$1";
			pop(@@hist) if length($cmd) > 1;
			for ($i = $#hist; $i; --$i) {
			    last if $hist[$i] =~ /$pat/;
			}
			if (!$i) {
			    print $OUT "No such command!\n\n";
			    next CMD;
			}
			$cmd = $hist[$i];
			print $OUT $cmd, "\n";
			redo CMD; };
		    $cmd =~ /^$sh$/ && do {
			&system($ENV{SHELL}||"/bin/sh");
			next CMD; };
		    $cmd =~ /^$sh\s*([\x00-\xff]*)/ && do {
			# XXX: using csh or tcsh destroys sigint retvals!
			#&system($1);  # use this instead
			&system($ENV{SHELL}||"/bin/sh","-c",$1);
			next CMD; };
		    $cmd =~ /^H\b\s*(-(\d+))?/ && do {
			$end = $2 ? ($#hist-$2) : 0;
			$hist = 0 if $hist < 0;
			for ($i=$#hist; $i>$end; $i--) {
			    print $OUT "$i: ",$hist[$i],"\n"
			      unless $hist[$i] =~ /^.?$/;
			};
			next CMD; };
		    $cmd =~ /^(?:man|(?:perl)?doc)\b(?:\s+([^(]*))?$/ && do {
			runman($1);
			next CMD; };
		    $cmd =~ s/^p$/print {\$DB::OUT} \$_/;
		    $cmd =~ s/^p\b/print {\$DB::OUT} /;
		    $cmd =~ s/^=\s*// && do {
			my @@keys;
			if (length $cmd == 0) {
			    @@keys = sort keys %alias;
			} elsif (my($k,$v) = ($cmd =~ /^(\S+)\s+(\S.*)/)) {
			    # can't use $_ or kill //g state
			    for my $x ($k, $v) { $x =~ s/\a/\\a/g }
			    $alias{$k} = "s\a$k\a$v\a";
			    # squelch the sigmangler
			    local $SIG{__DIE__};
			    local $SIG{__WARN__};
			    unless (eval "sub { s\a$k\a$v\a }; 1") {
				print $OUT "Can't alias $k to $v: $@@\n"; 
				delete $alias{$k};
				next CMD;
			    } 
			    @@keys = ($k);
			} else {
			    @@keys = ($cmd);
			} 
			for my $k (@@keys) {
			    if ((my $v = $alias{$k}) =~ ss\a$k\a(.*)\a$1) {
				print $OUT "$k\t= $1\n";
			    } 
			    elsif (defined $alias{$k}) {
				    print $OUT "$k\t$alias{$k}\n";
			    } 
			    else {
				print "No alias for $k\n";
			    } 
			}
			next CMD; };
                    $cmd =~ /^source\s+(.*\S)/ && do {
		      if (open my $fh, $1) {
			push @@cmdfhs, $fh;
		      } else {
			&warn("Can't execute `$1': $!\n");
		      }
		      next CMD; };
		    $cmd =~ /^\|\|?\s*[^|]/ && do {
			if ($pager =~ /^\|/) {
			    open(SAVEOUT,">&STDOUT") || &warn("Can't save STDOUT");
			    open(STDOUT,">&OUT") || &warn("Can't redirect STDOUT");
			} else {
			    open(SAVEOUT,">&OUT") || &warn("Can't save DB::OUT");
			}
			fix_less();
			unless ($piped=open(OUT,$pager)) {
			    &warn("Can't pipe output to `$pager'");
			    if ($pager =~ /^\|/) {
				open(OUT,">&STDOUT") # XXX: lost message
				    || &warn("Can't restore DB::OUT");
				open(STDOUT,">&SAVEOUT")
				  || &warn("Can't restore STDOUT");
				close(SAVEOUT);
			    } else {
				open(OUT,">&STDOUT") # XXX: lost message
				    || &warn("Can't restore DB::OUT");
			    }
			    next CMD;
			}
			$SIG{PIPE}= \&DB::catch if $pager =~ /^\|/
			    && ("" eq $SIG{PIPE}  ||  "DEFAULT" eq $SIG{PIPE});
			$selected= select(OUT);
			$|= 1;
			select( $selected ), $selected= "" unless $cmd =~ /^\|\|/;
			$cmd =~ s/^\|+\s*//;
			redo PIPE; 
		    };
		    # XXX Local variants do not work!
		    $cmd =~ s/^t\s/\$DB::trace |= 1;\n/;
		    $cmd =~ s/^s\s/\$DB::single = 1;\n/ && do {$laststep = 's'};
		    $cmd =~ s/^n\s/\$DB::single = 2;\n/ && do {$laststep = 'n'};
		}		# PIPE:
	    $evalarg = "\$^D = \$^D | \$DB::db_stop;\n$cmd"; &eval;
	    if ($onetimeDump) {
		$onetimeDump = undef;
                $onetimedumpDepth = undef;
	    } elsif ($term_pid == $$) {
		print $OUT "\n";
	    }
	} continue {		# CMD:
	    if ($piped) {
		if ($pager =~ /^\|/) {
		    $? = 0;  
		    # we cannot warn here: the handle is missing --tchrist
		    close(OUT) || print SAVEOUT "\nCan't close DB::OUT\n";

		    # most of the $? crud was coping with broken cshisms
		    if ($?) {
			print SAVEOUT "Pager `$pager' failed: ";
			if ($? == -1) {
			    print SAVEOUT "shell returned -1\n";
			} elsif ($? >> 8) {
			    print SAVEOUT 
			      ( $? & 127 ) ? " (SIG#".($?&127).")" : "", 
			      ( $? & 128 ) ? " -- core dumped" : "", "\n";
			} else {
			    print SAVEOUT "status ", ($? >> 8), "\n";
			} 
		    } 

		    open(OUT,">&STDOUT") || &warn("Can't restore DB::OUT");
		    open(STDOUT,">&SAVEOUT") || &warn("Can't restore STDOUT");
		    $SIG{PIPE} = "DEFAULT" if $SIG{PIPE} eq \&DB::catch;
		    # Will stop ignoring SIGPIPE if done like nohup(1)
		    # does SIGINT but Perl doesn't give us a choice.
		} else {
		    open(OUT,">&SAVEOUT") || &warn("Can't restore DB::OUT");
		}
		close(SAVEOUT);
		select($selected), $selected= "" unless $selected eq "";
		$piped= "";
	    }
	}			# CMD:
    $fall_off_end = 1 unless defined $cmd; # Emulate `q' on EOF
	foreach $evalarg (@@$post) {
	  &eval;
	}
    }				# if ($single || $signal)
    ($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;
    ();
}
d2051 2
a2052 2
# The following code may be executed now:
# BEGIN {warn 4}
d2054 2
a2055 55
sub sub {
    my ($al, $ret, @@ret) = "";
    if (length($sub) > 10 && substr($sub, -10, 10) eq '::AUTOLOAD') {
	$al = " for $$sub";
    }
    local $stack_depth = $stack_depth + 1; # Protect from non-local exits
    $#stack = $stack_depth;
    $stack[-1] = $single;
    $single &= 1;
    $single |= 4 if $stack_depth == $deep;
    ($frame & 4 
     ? ( print_lineinfo(' ' x ($stack_depth - 1), "in  "),
	 # Why -1? But it works! :-(
	 print_trace($LINEINFO, -1, 1, 1, "$sub$al") )
     : print_lineinfo(' ' x ($stack_depth - 1), "entering $sub$al\n")) if $frame;
    if (wantarray) {
	@@ret = &$sub;
	$single |= $stack[$stack_depth--];
	($frame & 4 
	 ? ( print_lineinfo(' ' x $stack_depth, "out "), 
	     print_trace($LINEINFO, -1, 1, 1, "$sub$al") )
	 : print_lineinfo(' ' x $stack_depth, "exited $sub$al\n")) if $frame & 2;
	if ($doret eq $stack_depth or $frame & 16) {
	    local $\ = '';
            my $fh = ($doret eq $stack_depth ? $OUT : $LINEINFO);
	    print $fh ' ' x $stack_depth if $frame & 16;
	    print $fh "list context return from $sub:\n"; 
	    dumpit($fh, \@@ret );
	    $doret = -2;
	}
	@@ret;
    } else {
        if (defined wantarray) {
	    $ret = &$sub;
        } else {
            &$sub; undef $ret;
        };
	$single |= $stack[$stack_depth--];
	($frame & 4 
	 ? (  print_lineinfo(' ' x $stack_depth, "out "),
	      print_trace($LINEINFO, -1, 1, 1, "$sub$al") )
	 : print_lineinfo(' ' x $stack_depth, "exited $sub$al\n")) if $frame & 2;
	if ($doret eq $stack_depth or $frame & 16 and defined wantarray) {
	    local $\ = '';
            my $fh = ($doret eq $stack_depth ? $OUT : $LINEINFO);
	    print $fh (' ' x $stack_depth) if $frame & 16;
	    print $fh (defined wantarray 
			 ? "scalar context return from $sub: " 
			 : "void context return from $sub\n");
	    dumpit( $fh, $ret ) if defined wantarray;
	    $doret = -2;
	}
	$ret;
    }
}
d2057 76
a2132 1
### The API section
d2134 1
a2134 23
### Functions with multiple modes of failure die on error, the rest
### returns FALSE on error.
### User-interface functions cmd_* output error message.

### Note all cmd_[a-zA-Z]'s require $line, $dblineno as first arguments

my %set = ( # 
	'pre580'	=> {
		'a'	=> 'pre580_a', 
		'A'	=> 'pre580_null',
		'b'	=> 'pre580_b', 
		'B'	=> 'pre580_null',
		'd'	=> 'pre580_null',
		'D'	=> 'pre580_D',
		'h'	=> 'pre580_h',
		'M'	=> 'pre580_null',
		'O'	=> 'o',
		'o'	=> 'pre580_null',
		'v'	=> 'M',
		'w'	=> 'v',
		'W'	=> 'pre580_W',
	},
);
d2136 1
a2136 12
sub cmd_wrapper {
	my $cmd      = shift;
	my $line     = shift;
	my $dblineno = shift;

	# with this level of indirection we can wrap 
	# to old (pre580) or other command sets easily
	# 
	my $call = 'cmd_'.(
		$set{$CommandSet}{$cmd} || $cmd
	);
	# print "cmd_wrapper($cmd): $CommandSet($set{$CommandSet}{$cmd}) => call($call)\n";
d2138 1
a2138 2
	return &$call($line, $dblineno);
}
d2140 7
a2146 18
sub cmd_a {
	my $line   = shift || ''; # [.|line] expr
	my $dbline = shift; $line =~ s/^(\.|(?:[^\d]))/$dbline/;
	if ($line =~ /^\s*(\d*)\s*(\S.+)/) {
		my ($lineno, $expr) = ($1, $2);
		if (length $expr) {
			if ($dbline[$lineno] == 0) {
				print $OUT "Line $lineno($dbline[$lineno]) does not have an action?\n";
			} else {
				$had_breakpoints{$filename} |= 2;
				$dbline{$lineno} =~ s/\0[^\0]*//;
				$dbline{$lineno} .= "\0" . action($expr);
			}
		}
	} else {
		print $OUT "Adding an action requires an optional lineno and an expression\n"; # hint
	}
}
d2148 1
a2148 11
sub cmd_A {
	my $line   = shift || '';
	my $dbline = shift; $line =~ s/^\./$dbline/;
	if ($line eq '*') {
		eval { &delete_action(); 1 } or print $OUT $@@ and return;
	} elsif ($line =~ /^(\S.*)/) {
		eval { &delete_action($1); 1 } or print $OUT $@@ and return;
	} else {
		print $OUT "Deleting an action requires a line number, or '*' for all\n"; # hint
	}
}
d2150 1
a2150 24
sub delete_action {
  my $i = shift;
  if (defined($i)) {
		die "Line $i has no action .\n" if $dbline[$i] == 0;
		$dbline{$i} =~ s/\0[^\0]*//; # \^a
		delete $dbline{$i} if $dbline{$i} eq '';
	} else {
		print $OUT "Deleting all actions...\n";
		for my $file (keys %had_breakpoints) {
			local *dbline = $main::{'_<' . $file};
			my $max = $#dbline;
			my $was;
			for ($i = 1; $i <= $max ; $i++) {
					if (defined $dbline{$i}) {
							$dbline{$i} =~ s/\0[^\0]*//;
							delete $dbline{$i} if $dbline{$i} eq '';
					}
				unless ($had_breakpoints{$file} &= ~2) {
						delete $had_breakpoints{$file};
				}
			}
		}
	}
}
d2152 1
a2152 27
sub cmd_b {
	my $line   = shift; # [.|line] [cond]
	my $dbline = shift; $line =~ s/^\./$dbline/;
	if ($line =~ /^\s*$/) {
		&cmd_b_line($dbline, 1);
	} elsif ($line =~ /^load\b\s*(.*)/) {
		my $file = $1; $file =~ s/\s+$//;
		&cmd_b_load($file);
	} elsif ($line =~ /^(postpone|compile)\b\s*([':A-Za-z_][':\w]*)\s*(.*)/) {
		my $cond = length $3 ? $3 : '1';
		my ($subname, $break) = ($2, $1 eq 'postpone');
		$subname =~ s/\'/::/g;
		$subname = "${'package'}::" . $subname unless $subname =~ /::/;
		$subname = "main".$subname if substr($subname,0,2) eq "::";
		$postponed{$subname} = $break ? "break +0 if $cond" : "compile";
	} elsif ($line =~ /^([':A-Za-z_][':\w]*(?:\[.*\])?)\s*(.*)/) { 
		$subname = $1;
		$cond = length $2 ? $2 : '1';
		&cmd_b_sub($subname, $cond);
	} elsif ($line =~ /^(\d*)\s*(.*)/) { 
		$line = $1 || $dbline;
		$cond = length $2 ? $2 : '1';
		&cmd_b_line($line, $cond);
	} else {
		print "confused by line($line)?\n";
	}
}
d2154 1
a2154 5
sub break_on_load {
  my $file = shift;
  $break_on_load{$file} = 1;
  $had_breakpoints{$file} |= 1;
}
d2156 3
a2158 3
sub report_break_on_load {
  sort keys %break_on_load;
}
d2160 3
a2162 14
sub cmd_b_load {
  my $file = shift;
  my @@files;
  {
    push @@files, $file;
    push @@files, $::INC{$file} if $::INC{$file};
    $file .= '.pm', redo unless $file =~ /\./;
  }
  break_on_load($_) for @@files;
  @@files = report_break_on_load;
  local $\ = '';
  local $" = ' ';
  print $OUT "Will stop on load of `@@files'.\n";
}
d2164 11
a2174 1
$filename_error = '';
d2176 1
a2176 14
sub breakable_line {
  my ($from, $to) = @@_;
  my $i = $from;
  if (@@_ >= 2) {
    my $delta = $from < $to ? +1 : -1;
    my $limit = $delta > 0 ? $#dbline : 1;
    $limit = $to if ($limit - $to) * $delta > 0;
    $i += $delta while $dbline[$i] == 0 and ($limit - $i) * $delta > 0;
  }
  return $i unless $dbline[$i] == 0;
  my ($pl, $upto) = ('', '');
  ($pl, $upto) = ('s', "..$to") if @@_ >=2 and $from != $to;
  die "Line$pl $from$upto$filename_error not breakable\n";
}
d2178 2
a2179 6
sub breakable_line_in_filename {
  my ($f) = shift;
  local *dbline = $main::{'_<' . $f};
  local $filename_error = " of `$f'";
  breakable_line(@@_);
}
d2181 1
a2181 11
sub break_on_line {
  my ($i, $cond) = @@_;
  $cond = 1 unless @@_ >= 2;
  my $inii = $i;
  my $after = '';
  my $pl = '';
  die "Line $i$filename_error not breakable.\n" if $dbline[$i] == 0;
  $had_breakpoints{$filename} |= 1;
  if ($dbline{$i}) { $dbline{$i} =~ s/^[^\0]*/$cond/; }
  else { $dbline{$i} = $cond; }
}
d2183 1
a2183 6
sub cmd_b_line {
  eval { break_on_line(@@_); 1 } or do {
    local $\ = '';
    print $OUT $@@ and return;
  };
}
d2185 1
a2185 8
sub break_on_filename_line {
  my ($f, $i, $cond) = @@_;
  $cond = 1 unless @@_ >= 3;
  local *dbline = $main::{'_<' . $f};
  local $filename_error = " of `$f'";
  local $filename = $f;
  break_on_line($i, $cond);
}
d2187 1
a2187 6
sub break_on_filename_line_range {
  my ($f, $from, $to, $cond) = @@_;
  my $i = breakable_line_in_filename($f, $from, $to);
  $cond = 1 unless @@_ >= 3;
  break_on_filename_line($f,$i,$cond);
}
d2189 1
a2189 5
sub subroutine_filename_lines {
  my ($subname,$cond) = @@_;
  # Filename below can contain ':'
  find_sub($subname) =~ /^(.*):(\d+)-(\d+)$/;
}
d2191 5
a2195 7
sub break_subroutine {
  my $subname = shift;
  my ($file,$s,$e) = subroutine_filename_lines($subname) or
    die "Subroutine $subname not found.\n";
  $cond = 1 unless @@_ >= 2;
  break_on_filename_line_range($file,$s,$e,@@_);
}
a2196 17
sub cmd_b_sub {
  my ($subname,$cond) = @@_;
  $cond = 1 unless @@_ >= 2;
  unless (ref $subname eq 'CODE') {
    $subname =~ s/\'/::/g;
    my $s = $subname;
    $subname = "${'package'}::" . $subname
      unless $subname =~ /::/;
    $subname = "CORE::GLOBAL::$s"
      if not defined &$subname and $s !~ /::/ and defined &{"CORE::GLOBAL::$s"};
    $subname = "main".$subname if substr($subname,0,2) eq "::";
  }
  eval { break_subroutine($subname,$cond); 1 } or do {
    local $\ = '';
    print $OUT $@@ and return;
  }
}
d2198 44
a2241 9
sub cmd_B {
	my $line   = ($_[0] =~ /^\./) ? $dbline : shift || ''; 
	my $dbline = shift; $line =~ s/^\./$dbline/;
	if ($line eq '*') {
		eval { &delete_breakpoint(); 1 } or print $OUT $@@ and return;
	} elsif ($line =~ /^(\S.*)/) {
		eval { &delete_breakpoint($line || $dbline); 1 } or do {
                    local $\ = '';
                    print $OUT $@@ and return;
a2242 4
	} else {
		print $OUT "Deleting a breakpoint requires a line number, or '*' for all\n"; # hint
	}
}
d2244 1
a2244 29
sub delete_breakpoint {
  my $i = shift;
  if (defined($i)) {
	  die "Line $i not breakable.\n" if $dbline[$i] == 0;
	  $dbline{$i} =~ s/^[^\0]*//;
	  delete $dbline{$i} if $dbline{$i} eq '';
  } else {
		  print $OUT "Deleting all breakpoints...\n";
		  for my $file (keys %had_breakpoints) {
					local *dbline = $main::{'_<' . $file};
					my $max = $#dbline;
					my $was;
					for ($i = 1; $i <= $max ; $i++) {
							if (defined $dbline{$i}) {
						$dbline{$i} =~ s/^[^\0]+//;
						if ($dbline{$i} =~ s/^\0?$//) {
								delete $dbline{$i};
						}
							}
					}
					if (not $had_breakpoints{$file} &= ~1) {
							delete $had_breakpoints{$file};
					}
		  }
		  undef %postponed;
		  undef %postponed_file;
		  undef %break_on_load;
	}
}
d2246 2
a2247 3
sub cmd_stop {			# As on ^C, but not signal-safy.
  $signal = 1;
}
d2249 1
a2249 21
sub cmd_h {
	my $line   = shift || '';
	if ($line  =~ /^h\s*/) {
		print_help($help);
	} elsif ($line =~ /^(\S.*)$/) { 
			# support long commands; otherwise bogus errors
			# happen when you ask for h on <CR> for example
			my $asked = $1;			# for proper errmsg
			my $qasked = quotemeta($asked); # for searching
			# XXX: finds CR but not <CR>
			if ($help =~ /^<?(?:[IB]<)$qasked/m) {
			  while ($help =~ /^(<?(?:[IB]<)$qasked([\s\S]*?)\n)(?!\s)/mg) {
			    print_help($1);
			  }
			} else {
			    print_help("B<$asked> is not a debugger command.\n");
			}
	} else {
			print_help($summary);
	}
}
d2251 2
a2252 79
sub cmd_l {
	my $line = shift;
	$line =~ s/^-\s*$/-/;
	if ($line =~ /^(\$.*)/s) {
		$evalarg = $2;
		my ($s) = &eval;
		print($OUT "Error: $@@\n"), next CMD if $@@;
		$s = CvGV_name($s);
		print($OUT "Interpreted as: $1 $s\n");
		$line = "$1 $s";
		&cmd_l($s);
	} elsif ($line =~ /^([\':A-Za-z_][\':\w]*(\[.*\])?)/s) { 
		my $s = $subname = $1;
		$subname =~ s/\'/::/;
		$subname = $package."::".$subname 
		unless $subname =~ /::/;
		$subname = "CORE::GLOBAL::$s"
		if not defined &$subname and $s !~ /::/
			 and defined &{"CORE::GLOBAL::$s"};
		$subname = "main".$subname if substr($subname,0,2) eq "::";
		@@pieces = split(/:/,find_sub($subname) || $sub{$subname});
		$subrange = pop @@pieces;
		$file = join(':', @@pieces);
		if ($file ne $filename) {
			print $OUT "Switching to file '$file'.\n"
		unless $slave_editor;
			*dbline = $main::{'_<' . $file};
			$max = $#dbline;
			$filename = $file;
		}
		if ($subrange) {
			if (eval($subrange) < -$window) {
		$subrange =~ s/-.*/+/;
			}
			$line = $subrange;
			&cmd_l($subrange);
		} else {
			print $OUT "Subroutine $subname not found.\n";
		}
	} elsif ($line =~ /^\s*$/) {
		$incr = $window - 1;
		$line = $start . '-' . ($start + $incr); 
		&cmd_l($line);
	} elsif ($line =~ /^(\d*)\+(\d*)$/) { 
		$start = $1 if $1;
		$incr = $2;
		$incr = $window - 1 unless $incr;
		$line = $start . '-' . ($start + $incr); 
		&cmd_l($line);	
	} elsif ($line =~ /^((-?[\d\$\.]+)([-,]([\d\$\.]+))?)?/) { 
		$end = (!defined $2) ? $max : ($4 ? $4 : $2);
		$end = $max if $end > $max;
		$i = $2;
		$i = $line if $i eq '.';
		$i = 1 if $i < 1;
		$incr = $end - $i;
		if ($slave_editor) {
			print $OUT "\032\032$filename:$i:0\n";
			$i = $end;
		} else {
			for (; $i <= $end; $i++) {
				my ($stop,$action);
				($stop,$action) = split(/\0/, $dbline{$i}) if
						$dbline{$i};
							$arrow = ($i==$line 
						and $filename eq $filename_ini) 
					?  '==>' 
						: ($dbline[$i]+0 ? ':' : ' ') ;
				$arrow .= 'b' if $stop;
				$arrow .= 'a' if $action;
				print $OUT "$i$arrow\t", $dbline[$i];
				$i++, last if $signal;
			}
			print $OUT "\n" unless $dbline[$i-1] =~ /\n$/;
		}
		$start = $i; # remember in case they want more
		$start = $max if $start > $max;
	}
}
d2254 6
a2259 72
sub cmd_L {
	my $arg    = shift || 'abw'; $arg = 'abw' unless $CommandSet eq '580'; # sigh...
	my $action_wanted = ($arg =~ /a/) ? 1 : 0;
	my $break_wanted  = ($arg =~ /b/) ? 1 : 0;
	my $watch_wanted  = ($arg =~ /w/) ? 1 : 0;

	if ($break_wanted or $action_wanted) {
		for my $file (keys %had_breakpoints) {
			local *dbline = $main::{'_<' . $file};
			my $max = $#dbline;
			my $was;
			for ($i = 1; $i <= $max; $i++) {
				if (defined $dbline{$i}) {
					print $OUT "$file:\n" unless $was++;
					print $OUT " $i:\t", $dbline[$i];
					($stop,$action) = split(/\0/, $dbline{$i});
					print $OUT "   break if (", $stop, ")\n"
						if $stop and $break_wanted;
					print $OUT "   action:  ", $action, "\n"
						if $action and $action_wanted;
					last if $signal;
				}
			}
		}
	}
	if (%postponed and $break_wanted) {
		print $OUT "Postponed breakpoints in subroutines:\n";
		my $subname;
		for $subname (keys %postponed) {
		  print $OUT " $subname\t$postponed{$subname}\n";
		  last if $signal;
		}
	}
	my @@have = map { # Combined keys
			keys %{$postponed_file{$_}}
	} keys %postponed_file;
	if (@@have and ($break_wanted or $action_wanted)) {
		print $OUT "Postponed breakpoints in files:\n";
		my ($file, $line);
		for $file (keys %postponed_file) {
		  my $db = $postponed_file{$file};
		  print $OUT " $file:\n";
		  for $line (sort {$a <=> $b} keys %$db) {
			print $OUT "  $line:\n";
			my ($stop,$action) = split(/\0/, $$db{$line});
			print $OUT "    break if (", $stop, ")\n"
			  if $stop and $break_wanted;
			print $OUT "    action:  ", $action, "\n"
			  if $action and $action_wanted;
			last if $signal;
		  }
		  last if $signal;
		}
	}
  if (%break_on_load and $break_wanted) {
		print $OUT "Breakpoints on load:\n";
		my $file;
		for $file (keys %break_on_load) {
		  print $OUT " $file\n";
		  last if $signal;
		}
  }
  if ($watch_wanted) {
	if ($trace & 2) {
		print $OUT "Watch-expressions:\n" if @@to_watch;
		for my $expr (@@to_watch) {
			print $OUT " $expr\n";
			last if $signal;
		}
	}
  }
}
d2261 1
a2261 3
sub cmd_M {
	&list_modules();
}
d2263 1
a2263 10
sub cmd_o {
	my $opt      = shift || ''; # opt[=val]
	if ($opt =~ /^(\S.*)/) {
		&parse_options($1);
	} else {
		for (@@options) {
			&dump_option($_);
		}
	}
}
d2265 1
a2265 5
sub cmd_O {
	print $OUT "The old O command is now the o command.\n";        # hint
	print $OUT "Use 'h' to get current command help synopsis or\n"; # 
	print $OUT "use 'o CommandSet=pre580' to revert to old usage\n"; # 
}
d2267 4
a2270 2
sub cmd_v {
	my $line = shift;
d2272 4
a2275 8
	if ($line =~ /^(\d*)$/) {
		$incr = $window - 1;
		$start = $1 if $1;
		$start -= $preview;
		$line = $start . '-' . ($start + $incr);
		&cmd_l($line);
	}
}
d2277 1
a2277 13
sub cmd_w {
	my $expr     = shift || '';
	if ($expr =~ /^(\S.*)/) {
		push @@to_watch, $expr;
		$evalarg = $expr;
		my ($val) = &eval;
		$val = (defined $val) ? "'$val'" : 'undef' ;
		push @@old_watch, $val;
		$trace |= 2;
	} else {
		print $OUT "Adding a watch-expression requires an expression\n"; # hint
	}
}
d2279 49
a2327 19
sub cmd_W {
	my $expr     = shift || '';
	if ($expr eq '*') {
		$trace &= ~2;
		print $OUT "Deleting all watch expressions ...\n";
		@@to_watch = @@old_watch = ();
	} elsif ($expr =~ /^(\S.*)/) {
		my $i_cnt = 0;
		foreach (@@to_watch) {
			my $val = $to_watch[$i_cnt];
			if ($val eq $expr) { # =~ m/^\Q$i$/) {
				splice(@@to_watch, $i_cnt, 1);
			}
			$i_cnt++;
		}
	} else {
		print $OUT "Deleting a watch-expression requires an expression, or '*' for all\n"; # hint
	}
}
d2329 2
a2330 1
### END of the API section
d2332 1
a2332 4
sub save {
    @@saved = ($@@, $!, $^E, $,, $/, $\, $^W);
    $, = ""; $/ = "\n"; $\ = ""; $^W = 0;
}
d2334 14
a2347 6
sub print_lineinfo {
  resetterm(1) if $LINEINFO eq $OUT and $term_pid != $$;
  local $\ = '';
  local $, = '';
  print $LINEINFO @@_;
}
d2349 1
a2349 1
# The following takes its argument via $evalarg to preserve current @@_
d2351 13
a2363 23
sub postponed_sub {
  my $subname = shift;
  if ($postponed{$subname} =~ s/^break\s([+-]?\d+)\s+if\s//) {
    my $offset = $1 || 0;
    # Filename below can contain ':'
    my ($file,$i) = (find_sub($subname) =~ /^(.*):(\d+)-.*$/);
    if ($i) {
      $i += $offset;
      local *dbline = $main::{'_<' . $file};
      local $^W = 0;		# != 0 is magical below
      $had_breakpoints{$file} |= 1;
      my $max = $#dbline;
      ++$i until $dbline[$i] != 0 or $i >= $max;
      $dbline{$i} = delete $postponed{$subname};
    } else {
      local $\ = '';
      print $OUT "Subroutine $subname not found.\n";
    }
    return;
  }
  elsif ($postponed{$subname} eq 'compile') { $signal = 1 }
  #print $OUT "In postponed_sub for `$subname'.\n";
}
d2365 3
a2367 24
sub postponed {
  if ($ImmediateStop) {
    $ImmediateStop = 0;
    $signal = 1;
  }
  return &postponed_sub
    unless ref \$_[0] eq 'GLOB'; # A subroutine is compiled.
  # Cannot be done before the file is compiled
  local *dbline = shift;
  my $filename = $dbline;
  $filename =~ s/^_<//;
  local $\ = '';
  $signal = 1, print $OUT "'$filename' loaded...\n"
    if $break_on_load{$filename};
  print_lineinfo(' ' x $stack_depth, "Package $filename.\n") if $frame;
  return unless $postponed_file{$filename};
  $had_breakpoints{$filename} |= 1;
  #%dbline = %{$postponed_file{$filename}}; # Cannot be done: unsufficient magic
  my $key;
  for $key (keys %{$postponed_file{$filename}}) {
    $dbline{$key} = ${$postponed_file{$filename}}{$key};
  }
  delete $postponed_file{$filename};
}
d2369 1
a2369 26
sub dumpit {
    local ($savout) = select(shift);
    my $osingle = $single;
    my $otrace = $trace;
    $single = $trace = 0;
    local $frame = 0;
    local $doret = -2;
    unless (defined &main::dumpValue) {
	do 'dumpvar.pl';
    }
    if (defined &main::dumpValue) {
        local $\ = '';
        local $, = '';
        local $" = ' ';
        my $v = shift;
        my $maxdepth = shift || $option{dumpDepth};
        $maxdepth = -1 unless defined $maxdepth;   # -1 means infinite depth
	&main::dumpValue($v, $maxdepth);
    } else {
        local $\ = '';
	print $OUT "dumpvar.pl not available.\n";
    }
    $single = $osingle;
    $trace = $otrace;
    select ($savout);    
}
d2371 15
a2385 1
# Tied method do not create a context, so may get wrong message:
d2387 1
a2387 29
sub print_trace {
  local $\ = '';
  my $fh = shift;
  resetterm(1) if $fh eq $LINEINFO and $LINEINFO eq $OUT and $term_pid != $$;
  my @@sub = dump_trace($_[0] + 1, $_[1]);
  my $short = $_[2];		# Print short report, next one for sub name
  my $s;
  for ($i=0; $i <= $#sub; $i++) {
    last if $signal;
    local $" = ', ';
    my $args = defined $sub[$i]{args} 
    ? "(@@{ $sub[$i]{args} })"
      : '' ;
    $args = (substr $args, 0, $maxtrace - 3) . '...' 
      if length $args > $maxtrace;
    my $file = $sub[$i]{file};
    $file = $file eq '-e' ? $file : "file `$file'" unless $short;
    $s = $sub[$i]{sub};
    $s = (substr $s, 0, $maxtrace - 3) . '...' if length $s > $maxtrace;    
    if ($short) {
      my $sub = @@_ >= 4 ? $_[3] : $s;
      print $fh "$sub[$i]{context}=$sub$args from $file:$sub[$i]{line}\n";
    } else {
      print $fh "$sub[$i]{context} = $s$args" .
	" called from $file" . 
	  " line $sub[$i]{line}\n";
    }
  }
}
d2389 2
a2390 50
sub dump_trace {
  my $skip = shift;
  my $count = shift || 1e9;
  $skip++;
  $count += $skip;
  my ($p,$file,$line,$sub,$h,$args,$e,$r,@@a,@@sub,$context);
  my $nothard = not $frame & 8;
  local $frame = 0;		# Do not want to trace this.
  my $otrace = $trace;
  $trace = 0;
  for ($i = $skip; 
       $i < $count and ($p,$file,$line,$sub,$h,$context,$e,$r) = caller($i); 
       $i++) {
    @@a = ();
    for $arg (@@args) {
      my $type;
      if (not defined $arg) {
	push @@a, "undef";
      } elsif ($nothard and tied $arg) {
	push @@a, "tied";
      } elsif ($nothard and $type = ref $arg) {
	push @@a, "ref($type)";
      } else {
	local $_ = "$arg";	# Safe to stringify now - should not call f().
	s/([\'\\])/\\$1/g;
	s/(.*)/'$1'/s
	  unless /^(?: -?[\d.]+ | \*[\w:]* )$/x;
	s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;
	s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
	push(@@a, $_);
      }
    }
    $context = $context ? '@@' : (defined $context ? "\$" : '.');
    $args = $h ? [@@a] : undef;
    $e =~ s/\n\s*\;\s*\Z// if $e;
    $e =~ s/([\\\'])/\\$1/g if $e;
    if ($r) {
      $sub = "require '$e'";
    } elsif (defined $r) {
      $sub = "eval '$e'";
    } elsif ($sub eq '(eval)') {
      $sub = "eval {...}";
    }
    push(@@sub, {context => $context, sub => $sub, args => $args,
		file => $file, line => $line});
    last if $signal;
  }
  $trace = $otrace;
  @@sub;
}
d2392 1
a2392 9
sub action {
    my $action = shift;
    while ($action =~ s/\\$//) {
	#print $OUT "+ ";
	#$action .= "\n";
	$action .= &gets;
    }
    $action;
}
d2394 1
a2394 13
sub unbalanced { 
    # i hate using globals!
    $balanced_brace_re ||= qr{ 
	^ \{
	      (?:
		 (?> [^{}] + )    	    # Non-parens without backtracking
	       |
		 (??{ $balanced_brace_re }) # Group with matching parens
	      ) *
	  \} $
   }x;
   return $_[0] !~ m/$balanced_brace_re/;
}
d2396 37
a2432 3
sub gets {
    &readline("cont: ");
}
d2434 1
a2434 7
sub system {
    # We save, change, then restore STDIN and STDOUT to avoid fork() since
    # some non-Unix systems can do system() but have problems with fork().
    open(SAVEIN,"<&STDIN") || &warn("Can't save STDIN");
    open(SAVEOUT,">&STDOUT") || &warn("Can't save STDOUT");
    open(STDIN,"<&IN") || &warn("Can't redirect STDIN");
    open(STDOUT,">&OUT") || &warn("Can't redirect STDOUT");
d2436 23
a2458 6
    # XXX: using csh or tcsh destroys sigint retvals!
    system(@@_);
    open(STDIN,"<&SAVEIN") || &warn("Can't restore STDIN");
    open(STDOUT,">&SAVEOUT") || &warn("Can't restore STDOUT");
    close(SAVEIN); 
    close(SAVEOUT);
d2460 1
d2462 2
a2463 7
    # most of the $? crud was coping with broken cshisms
    if ($? >> 8) {
	&warn("(Command exited ", ($? >> 8), ")\n");
    } elsif ($?) { 
	&warn( "(Command died of SIG#",  ($? & 127),
	    (($? & 128) ? " -- core dumped" : "") , ")", "\n");
    } 
d2465 1
a2465 1
    return $?;
d2467 11
a2477 1
}
d2479 1
a2479 48
sub setterm {
    local $frame = 0;
    local $doret = -2;
    eval { require Term::ReadLine } or die $@@;
    if ($notty) {
	if ($tty) {
	    my ($i, $o) = split $tty, /,/;
	    $o = $i unless defined $o;
	    open(IN,"<$i") or die "Cannot open TTY `$i' for read: $!";
	    open(OUT,">$o") or die "Cannot open TTY `$o' for write: $!";
	    $IN = \*IN;
	    $OUT = \*OUT;
	    my $sel = select($OUT);
	    $| = 1;
	    select($sel);
	} else {
	    eval "require Term::Rendezvous;" or die;
	    my $rv = $ENV{PERLDB_NOTTY} || "/tmp/perldbtty$$";
	    my $term_rv = new Term::Rendezvous $rv;
	    $IN = $term_rv->IN;
	    $OUT = $term_rv->OUT;
	}
    }
    if ($term_pid eq '-1') {		# In a TTY with another debugger
	resetterm(2);
    }
    if (!$rl) {
	$term = new Term::ReadLine::Stub 'perldb', $IN, $OUT;
    } else {
	$term = new Term::ReadLine 'perldb', $IN, $OUT;

	$rl_attribs = $term->Attribs;
	$rl_attribs->{basic_word_break_characters} .= '-:+/*,[])}' 
	  if defined $rl_attribs->{basic_word_break_characters} 
	    and index($rl_attribs->{basic_word_break_characters}, ":") == -1;
	$rl_attribs->{special_prefixes} = '$@@&%';
	$rl_attribs->{completer_word_break_characters} .= '$@@&%';
	$rl_attribs->{completion_function} = \&db_complete; 
    }
    $LINEINFO = $OUT unless defined $LINEINFO;
    $lineinfo = $console unless defined $lineinfo;
    $term->MinLine(2);
    if ($term->Features->{setHistory} and "@@hist" ne "?") {
      $term->SetHistory(@@hist);
    }
    ornaments($ornaments) if defined $ornaments;
    $term_pid = $$;
}
d2481 61
a2541 10
# Example get_fork_TTY functions
sub xterm_get_fork_TTY {
  (my $name = $0) =~ s,^.*[/\\],,s;
  open XT, qq[3>&1 xterm -title "Daughter Perl debugger $pids $name" -e sh -c 'tty 1>&3;\
 sleep 10000000' |];
  my $tty = <XT>;
  chomp $tty;
  $pidprompt = '';		# Shown anyway in titlebar
  return $tty;
}
d2543 38
a2580 24
# This example function resets $IN, $OUT itself
sub os2_get_fork_TTY {
  local $^F = 40;			# XXXX Fixme!
  local $\ = '';
  my ($in1, $out1, $in2, $out2);
  # Having -d in PERL5OPT would lead to a disaster...
  local $ENV{PERL5OPT} = $ENV{PERL5OPT}    if $ENV{PERL5OPT};
  $ENV{PERL5OPT} =~ s/(?:^|(?<=\s))-d\b//  if $ENV{PERL5OPT};
  $ENV{PERL5OPT} =~ s/(?:^|(?<=\s))-d\B/-/ if $ENV{PERL5OPT};
  print $OUT "Making kid PERL5OPT->`$ENV{PERL5OPT}'.\n" if $ENV{PERL5OPT};
  local $ENV{PERL5LIB} = $ENV{PERL5LIB} ? $ENV{PERL5LIB} : $ENV{PERLLIB};
  $ENV{PERL5LIB} = '' unless defined $ENV{PERL5LIB};
  $ENV{PERL5LIB} = join ';', @@ini_INC, split /;/, $ENV{PERL5LIB};
  (my $name = $0) =~ s,^.*[/\\],,s;
  my @@args;
  if ( pipe $in1, $out1 and pipe $in2, $out2
       # system P_SESSION will fail if there is another process
       # in the same session with a "dependent" asynchronous child session.
       and @@args = ($rl, fileno $in1, fileno $out2,
		    "Daughter Perl debugger $pids $name") and
       (($kpid = CORE::system 4, $^X, '-we', <<'ES', @@args) >= 0 # P_SESSION
END {sleep 5 unless $loaded}
BEGIN {open STDIN,  '</dev/con' or warn "reopen stdin: $!"}
use OS2::Process;
d2582 1
a2582 6
my ($rl, $in) = (shift, shift);		# Read from $in and pass through
set_title pop;
system P_NOWAIT, $^X, '-we', <<EOS or die "Cannot start a grandkid";
  open IN, '<&=$in' or die "open <&=$in: \$!";
  \$| = 1; print while sysread IN, \$_, 1<<16;
EOS
d2584 18
a2601 16
my $out = shift;
open OUT, ">&=$out" or die "Cannot open &=$out for writing: $!";
select OUT;    $| = 1;
require Term::ReadKey if $rl;
Term::ReadKey::ReadMode(4) if $rl; # Nodelay on kbd.  Pipe is automatically nodelay...
print while sysread STDIN, $_, 1<<($rl ? 16 : 0);
ES
	 or warn "system P_SESSION: $!, $^E" and 0)
	and close $in1 and close $out2 ) {
      $pidprompt = '';			# Shown anyway in titlebar
      reset_IN_OUT($in2, $out1);
      $tty = '*reset*';
      return '';			# Indicate that reset_IN_OUT is called
   }
   return;
}
d2603 1
a2603 14
sub create_IN_OUT {	# Create a window with IN/OUT handles redirected there
    my $in = &get_fork_TTY if defined &get_fork_TTY;
    $in = $fork_TTY if defined $fork_TTY; # Backward compatibility
    if (not defined $in) {
      my $why = shift;
      print_help(<<EOP) if $why == 1;
I<#########> Forked, but do not know how to create a new B<TTY>. I<#########>
EOP
      print_help(<<EOP) if $why == 2;
I<#########> Daughter session, do not know how to change a B<TTY>. I<#########>
  This may be an asynchronous session, so the parent debugger may be active.
EOP
      print_help(<<EOP) if $why != 4;
  Since two debuggers fight for the same TTY, input is severely entangled.
d2605 41
a2645 5
EOP
      print_help(<<EOP);
  I know how to switch the output to a different window in xterms
  and OS/2 consoles only.  For a manual switch, put the name of the created I<TTY>
  in B<\$DB::fork_TTY>, or define a function B<DB::get_fork_TTY()> returning this.
d2647 86
a2732 2
  On I<UNIX>-like systems one can get the name of a I<TTY> for the given window
  by typing B<tty>, and disconnect the I<shell> from I<TTY> by B<sleep 1000000>.
d2734 65
a2798 8
EOP
    } elsif ($in ne '') {
      TTY($in);
    } else {
      $console = '';		# Indicate no need to open-from-the-console 
    }
    undef $fork_TTY;
}
d2800 1
a2800 13
sub resetterm {			# We forked, so we need a different TTY
    my $in = shift;
    my $systemed = $in > 1 ? '-' : '';
    if ($pids) {
      $pids =~ s/\]/$systemed->$$]/;
    } else {
      $pids = "[$term_pid->$$]";
    }
    $pidprompt = $pids;
    $term_pid = $$;
    return unless $CreateTTY & $in;
    create_IN_OUT($in);
}
d2802 1
a2802 28
sub readline {
  local $.;
  if (@@typeahead) {
    my $left = @@typeahead;
    my $got = shift @@typeahead;
    local $\ = '';
    print $OUT "auto(-$left)", shift, $got, "\n";
    $term->AddHistory($got) 
      if length($got) > 1 and defined $term->Features->{addHistory};
    return $got;
  }
  local $frame = 0;
  local $doret = -2;
  while (@@cmdfhs) {
    my $line = CORE::readline($cmdfhs[-1]);
    defined $line ? (print $OUT ">> $line" and return $line)
                  : close pop @@cmdfhs;
  }
  if (ref $OUT and UNIVERSAL::isa($OUT, 'IO::Socket::INET')) {
    $OUT->write(join('', @@_));
    my $stuff;
    $IN->recv( $stuff, 2048 );  # XXX: what's wrong with sysread?
    $stuff;
  }
  else {
    $term->readline(@@_);
  }
}
d2804 1
a2804 6
sub dump_option {
    my ($opt, $val)= @@_;
    $val = option_val($opt,'N/A');
    $val =~ s/([\\\'])/\\$1/g;
    printf $OUT "%20s = '%s'\n", $opt, $val;
}
d2806 4
a2809 20
sub option_val {
    my ($opt, $default)= @@_;
    my $val;
    if (defined $optionVars{$opt}
	and defined ${$optionVars{$opt}}) {
	$val = ${$optionVars{$opt}};
    } elsif (defined $optionAction{$opt}
	and defined &{$optionAction{$opt}}) {
	$val = &{$optionAction{$opt}}();
    } elsif (defined $optionAction{$opt}
	     and not defined $option{$opt}
	     or defined $optionVars{$opt}
	     and not defined ${$optionVars{$opt}}) {
	$val = $default;
    } else {
	$val = $option{$opt};
    }
    $val = $default unless defined $val;
    $val
}
d2811 1
a2811 72
sub parse_options {
    local($_)= @@_;
    local $\ = '';
    # too dangerous to let intuitive usage overwrite important things
    # defaultion should never be the default
    my %opt_needs_val = map { ( $_ => 1 ) } qw{
        dumpDepth arrayDepth hashDepth LineInfo maxTraceLen ornaments windowSize
        pager quote ReadLine recallCommand RemotePort ShellBang TTY
    };
    while (length) {
	my $val_defaulted;
	s/^\s+// && next;
	s/^(\w+)(\W?)// or print($OUT "Invalid option `$_'\n"), last;
	my ($opt,$sep) = ($1,$2);
	my $val;
	if ("?" eq $sep) {
	    print($OUT "Option query `$opt?' followed by non-space `$_'\n"), last
	      if /^\S/;
	    #&dump_option($opt);
	} elsif ($sep !~ /\S/) {
	    $val_defaulted = 1;
	    $val = "1";  #  this is an evil default; make 'em set it!
	} elsif ($sep eq "=") {
            if (s/ (["']) ( (?: \\. | (?! \1 ) [^\\] )* ) \1 //x) { 
                my $quote = $1;
                ($val = $2) =~ s/\\([$quote\\])/$1/g;
	    } else { 
		s/^(\S*)//;
	    $val = $1;
		print OUT qq(Option better cleared using $opt=""\n)
		    unless length $val;
	    }

	} else { #{ to "let some poor schmuck bounce on the % key in B<vi>."
	    my ($end) = "\\" . substr( ")]>}$sep", index("([<{",$sep), 1 ); #}
	    s/^(([^\\$end]|\\[\\$end])*)$end($|\s+)// or
	      print($OUT "Unclosed option value `$opt$sep$_'\n"), last;
	    ($val = $1) =~ s/\\([\\$end])/$1/g;
	}

	my $option;
	my $matches = grep( /^\Q$opt/  && ($option = $_),  @@options  )
		   || grep( /^\Q$opt/i && ($option = $_),  @@options  );

	print($OUT "Unknown option `$opt'\n"), next 	unless $matches;
	print($OUT "Ambiguous option `$opt'\n"), next 	if $matches > 1;

       if ($opt_needs_val{$option} && $val_defaulted) {
			 my $cmd = ($CommandSet eq '580') ? 'o' : 'O';
	    print $OUT "Option `$opt' is non-boolean.  Use `$cmd $option=VAL' to set, `$cmd $option?' to query\n";
	    next;
	} 

	$option{$option} = $val if defined $val;

	eval qq{
		local \$frame = 0; 
		local \$doret = -2; 
	        require '$optionRequire{$option}';
		1;
	 } || die  # XXX: shouldn't happen
	    if  defined $optionRequire{$option}	    &&
	        defined $val;

	${$optionVars{$option}} = $val 	    
	    if  defined $optionVars{$option}        &&
		defined $val;

	&{$optionAction{$option}} ($val)    
	    if defined $optionAction{$option}	    &&
               defined &{$optionAction{$option}}    &&
               defined $val;
d2813 1
a2813 4
	# Not $rcfile
	dump_option($option) 	unless $OUT eq \*STDERR; 
    }
}
d2815 1
a2815 11
sub set_list {
  my ($stem,@@list) = @@_;
  my $val;
  $ENV{"${stem}_n"} = @@list;
  for $i (0 .. $#list) {
    $val = $list[$i];
    $val =~ s/\\/\\\\/g;
    $val =~ s/([\0-\37\177\200-\377])/"\\0x" . unpack('H2',$1)/eg;
    $ENV{"${stem}_$i"} = $val;
  }
}
d2817 1
a2817 12
sub get_list {
  my $stem = shift;
  my @@list;
  my $n = delete $ENV{"${stem}_n"};
  my $val;
  for $i (0 .. $n - 1) {
    $val = delete $ENV{"${stem}_$i"};
    $val =~ s/\\((\\)|0x(..))/ $2 ? $2 : pack('H2', $3) /ge;
    push @@list, $val;
  }
  @@list;
}
d2819 1
a2819 4
sub catch {
    $signal = 1;
    return;			# Put nothing on the stack - malloc/free land!
}
d2821 1
a2821 6
sub warn {
    my($msg)= join("",@@_);
    $msg .= ": $!\n" unless $msg =~ /\n$/;
    local $\ = '';
    print $OUT $msg;
}
d2823 1
a2823 15
sub reset_IN_OUT {
    my $switch_li = $LINEINFO eq $OUT;
    if ($term and $term->Features->{newTTY}) {
      ($IN, $OUT) = (shift, shift);
      $term->newTTY($IN, $OUT);
    } elsif ($term) {
	&warn("Too late to set IN/OUT filehandles, enabled on next `R'!\n");
    } else {
      ($IN, $OUT) = (shift, shift);
    }
    my $o = select $OUT;
    $| = 1;
    select $o;
    $LINEINFO = $OUT if $switch_li;
}
d2825 1
a2825 18
sub TTY {
    if (@@_ and $term and $term->Features->{newTTY}) {
      my ($in, $out) = shift;
      if ($in =~ /,/) {
	($in, $out) = split /,/, $in, 2;
      } else {
	$out = $in;
      }
      open IN, $in or die "cannot open `$in' for read: $!";
      open OUT, ">$out" or die "cannot open `$out' for write: $!";
      reset_IN_OUT(\*IN,\*OUT);
      return $tty = $in;
    }
    &warn("Too late to set TTY, enabled on next `R'!\n") if $term and @@_;
    # Useful if done through PERLDB_OPTS:
    $console = $tty = shift if @@_;
    $tty or $console;
}
d2827 1
a2827 7
sub noTTY {
    if ($term) {
	&warn("Too late to set noTTY, enabled on next `R'!\n") if @@_;
    }
    $notty = shift if @@_;
    $notty;
}
d2829 4
a2832 7
sub ReadLine {
    if ($term) {
	&warn("Too late to set ReadLine, enabled on next `R'!\n") if @@_;
    }
    $rl = shift if @@_;
    $rl;
}
d2834 1
a2834 7
sub RemotePort {
    if ($term) {
        &warn("Too late to set RemotePort, enabled on next 'R'!\n") if @@_;
    }
    $remoteport = shift if @@_;
    $remoteport;
}
d2836 1
a2836 9
sub tkRunning {
    if (${$term->Features}{tkRunning}) {
        return $term->tkRunning(@@_);
    } else {
	local $\ = '';
	print $OUT "tkRunning not supported by current ReadLine package.\n";
	0;
    }
}
d2838 2
a2839 7
sub NonStop {
    if ($term) {
	&warn("Too late to set up NonStop mode, enabled on next `R'!\n") if @@_;
    }
    $runnonstop = shift if @@_;
    $runnonstop;
}
d2841 2
a2842 7
sub pager {
    if (@@_) {
	$pager = shift;
	$pager="|".$pager unless $pager =~ /^(\+?\>|\|)/;
    }
    $pager;
}
d2844 2
a2845 10
sub shellBang {
    if (@@_) {
	$sh = quotemeta shift;
	$sh .= "\\b" if $sh =~ /\w$/;
    }
    $psh = $sh;
    $psh =~ s/\\b$//;
    $psh =~ s/\\(.)/$1/g;
    $psh;
}
d2847 3
a2849 9
sub ornaments {
  if (defined $term) {
    local ($warnLevel,$dieLevel) = (0, 1);
    return '' unless $term->Features->{ornaments};
    eval { $term->ornaments(@@_) } || '';
  } else {
    $ornaments = shift;
  }
}
d2851 11
a2861 10
sub recallCommand {
    if (@@_) {
	$rc = quotemeta shift;
	$rc .= "\\b" if $rc =~ /\w$/;
    }
    $prc = $rc;
    $prc =~ s/\\b$//;
    $prc =~ s/\\(.)/$1/g;
    $prc;
}
d2863 2
a2864 12
sub LineInfo {
    return $lineinfo unless @@_;
    $lineinfo = shift;
    my $stream = ($lineinfo =~ /^(\+?\>|\|)/) ? $lineinfo : ">$lineinfo";
    $slave_editor = ($stream =~ /^\|/);
    open(LINEINFO, "$stream") || &warn("Cannot open `$stream' for write");
    $LINEINFO = \*LINEINFO;
    my $save = select($LINEINFO);
    $| = 1;
    select($save);
    $lineinfo;
}
d2866 2
a2867 16
sub list_modules { # versions
  my %version;
  my $file;
  for (keys %INC) {
    $file = $_;
    s,\.p[lm]$,,i ;
    s,/,::,g ;
    s/^perl5db$/DB/;
    s/^Term::ReadLine::readline$/readline/;
    if (defined ${ $_ . '::VERSION' }) {
      $version{$file} = "${ $_ . '::VERSION' } from ";
    } 
    $version{$file} .= $INC{$file};
  }
  dumpit($OUT,\%version);
}
d2869 5067
a7935 4
sub sethelp {
    # XXX: make sure there are tabs between the command and explanation,
    #      or print_help will screw up your formatting if you have
    #      eeevil ornaments enabled.  This is an insane mess.
d7937 1
a7937 4
    $help = "
Help is currently only available for the new 580 CommandSet, 
if you really want old behaviour, presumably you know what 
you're doing ?-)
d7939 1
a7939 65
B<T>		Stack trace.
B<s> [I<expr>]	Single step [in I<expr>].
B<n> [I<expr>]	Next, steps over subroutine calls [in I<expr>].
<B<CR>>		Repeat last B<n> or B<s> command.
B<r>		Return from current subroutine.
B<c> [I<line>|I<sub>]	Continue; optionally inserts a one-time-only breakpoint
		at the specified position.
B<l> I<min>B<+>I<incr>	List I<incr>+1 lines starting at I<min>.
B<l> I<min>B<->I<max>	List lines I<min> through I<max>.
B<l> I<line>		List single I<line>.
B<l> I<subname>	List first window of lines from subroutine.
B<l> I<\$var>		List first window of lines from subroutine referenced by I<\$var>.
B<l>		List next window of lines.
B<->		List previous window of lines.
B<v> [I<line>]	View window around I<line>.
B<.>		Return to the executed line.
B<f> I<filename>	Switch to viewing I<filename>. File must be already loaded.
		I<filename> may be either the full name of the file, or a regular
		expression matching the full file name:
		B<f> I</home/me/foo.pl> and B<f> I<oo\\.> may access the same file.
		Evals (with saved bodies) are considered to be filenames:
		B<f> I<(eval 7)> and B<f> I<eval 7\\b> access the body of the 7th eval
		(in the order of execution).
B</>I<pattern>B</>	Search forwards for I<pattern>; final B</> is optional.
B<?>I<pattern>B<?>	Search backwards for I<pattern>; final B<?> is optional.
B<L> [I<a|b|w>]		List actions and or breakpoints and or watch-expressions.
B<S> [[B<!>]I<pattern>]	List subroutine names [not] matching I<pattern>.
B<t>		Toggle trace mode.
B<t> I<expr>		Trace through execution of I<expr>.
B<b>		Sets breakpoint on current line)
B<b> [I<line>] [I<condition>]
		Set breakpoint; I<line> defaults to the current execution line;
		I<condition> breaks if it evaluates to true, defaults to '1'.
B<b> I<subname> [I<condition>]
		Set breakpoint at first line of subroutine.
B<b> I<\$var>		Set breakpoint at first line of subroutine referenced by I<\$var>.
B<b> B<load> I<filename> Set breakpoint on 'require'ing the given file.
B<b> B<postpone> I<subname> [I<condition>]
		Set breakpoint at first line of subroutine after 
		it is compiled.
B<b> B<compile> I<subname>
		Stop after the subroutine is compiled.
B<B> [I<line>]	Delete the breakpoint for I<line>.
B<B> I<*>             Delete all breakpoints.
B<a> [I<line>] I<command>
		Set an action to be done before the I<line> is executed;
		I<line> defaults to the current execution line.
		Sequence is: check for breakpoint/watchpoint, print line
		if necessary, do action, prompt user if necessary,
		execute line.
B<a>		Does nothing
B<A> [I<line>]	Delete the action for I<line>.
B<A> I<*>             Delete all actions.
B<w> I<expr>		Add a global watch-expression.
B<w>     		Does nothing
B<W> I<expr>		Delete a global watch-expression.
B<W> I<*>             Delete all watch-expressions.
B<V> [I<pkg> [I<vars>]]	List some (default all) variables in package (default current).
		Use B<~>I<pattern> and B<!>I<pattern> for positive and negative regexps.
B<X> [I<vars>]	Same as \"B<V> I<currentpackage> [I<vars>]\".
B<x> I<expr>		Evals expression in list context, dumps the result.
B<m> I<expr>		Evals expression in list context, prints methods callable
		on the first element of the result.
B<m> I<class>		Prints methods callable via the given class.
B<M>		Show versions of loaded modules.
d7941 1
a7941 29
B<<> ?			List Perl commands to run before each prompt.
B<<> I<expr>		Define Perl command to run before each prompt.
B<<<> I<expr>		Add to the list of Perl commands to run before each prompt.
B<>> ?			List Perl commands to run after each prompt.
B<>> I<expr>		Define Perl command to run after each prompt.
B<>>B<>> I<expr>		Add to the list of Perl commands to run after each prompt.
B<{> I<db_command>	Define debugger command to run before each prompt.
B<{> ?			List debugger commands to run before each prompt.
B<{{> I<db_command>	Add to the list of debugger commands to run before each prompt.
B<$prc> I<number>	Redo a previous command (default previous command).
B<$prc> I<-number>	Redo number'th-to-last command.
B<$prc> I<pattern>	Redo last command that started with I<pattern>.
		See 'B<O> I<recallCommand>' too.
B<$psh$psh> I<cmd>  	Run cmd in a subprocess (reads from DB::IN, writes to DB::OUT)"
  . ( $rc eq $sh ? "" : "
B<$psh> [I<cmd>] 	Run I<cmd> in subshell (forces \"\$SHELL -c 'cmd'\")." ) . "
		See 'B<O> I<shellBang>' too.
B<source> I<file>		Execute I<file> containing debugger commands (may nest).
B<H> I<-number>	Display last number commands (default all).
B<p> I<expr>		Same as \"I<print {DB::OUT} expr>\" in current package.
B<|>I<dbcmd>		Run debugger command, piping DB::OUT to current pager.
B<||>I<dbcmd>		Same as B<|>I<dbcmd> but DB::OUT is temporarilly select()ed as well.
B<\=> [I<alias> I<value>]	Define a command alias, or list current aliases.
I<command>		Execute as a perl statement in current package.
B<R>		Pure-man-restart of debugger, some of debugger state
		and command-line options may be lost.
		Currently the following settings are preserved:
		history, breakpoints and actions, debugger B<O>ptions 
		and the following command-line options: I<-w>, I<-I>, I<-e>.
d7943 1
a7943 33
B<o> [I<opt>] ...	Set boolean option to true
B<o> [I<opt>B<?>]	Query options
B<o> [I<opt>B<=>I<val>] [I<opt>=B<\">I<val>B<\">] ... 
		Set options.  Use quotes in spaces in value.
    I<recallCommand>, I<ShellBang>	chars used to recall command or spawn shell;
    I<pager>			program for output of \"|cmd\";
    I<tkRunning>			run Tk while prompting (with ReadLine);
    I<signalLevel> I<warnLevel> I<dieLevel>	level of verbosity;
    I<inhibit_exit>		Allows stepping off the end of the script.
    I<ImmediateStop>		Debugger should stop as early as possible.
    I<RemotePort>			Remote hostname:port for remote debugging
  The following options affect what happens with B<V>, B<X>, and B<x> commands:
    I<arrayDepth>, I<hashDepth> 	print only first N elements ('' for all);
    I<compactDump>, I<veryCompact> 	change style of array and hash dump;
    I<globPrint> 			whether to print contents of globs;
    I<DumpDBFiles> 		dump arrays holding debugged files;
    I<DumpPackages> 		dump symbol tables of packages;
    I<DumpReused> 			dump contents of \"reused\" addresses;
    I<quote>, I<HighBit>, I<undefPrint> 	change style of string dump;
    I<bareStringify> 		Do not print the overload-stringified value;
  Other options include:
    I<PrintRet>		affects printing of return value after B<r> command,
    I<frame>		affects printing messages on subroutine entry/exit.
    I<AutoTrace>	affects printing messages on possible breaking points.
    I<maxTraceLen>	gives max length of evals/args listed in stack trace.
    I<ornaments> 	affects screen appearance of the command line.
    I<CreateTTY> 	bits control attempts to create a new TTY on events:
			1: on fork()	2: debugger is started inside debugger
			4: on startup
	During startup options are initialized from \$ENV{PERLDB_OPTS}.
	You can put additional initialization options I<TTY>, I<noTTY>,
	I<ReadLine>, I<NonStop>, and I<RemotePort> there (or use
	`B<R>' after you set them).
a7944 7
B<q> or B<^D>		Quit. Set B<\$DB::finished = 0> to debug global destruction.
B<h>		Summary of debugger commands.
B<h> [I<db_command>]	Get help [on a specific debugger command], enter B<|h> to page.
B<h h>		Long help for debugger commands
B<$doccmd> I<manpage>	Runs the external doc viewer B<$doccmd> command on the 
		named Perl I<manpage>, or on B<$doccmd> itself if omitted.
		Set B<\$DB::doccmd> to change viewer.
d7946 1
a7946 1
Type `|h h' for a paged display if this was too hard to read.
d7948 1
a7948 1
"; # Fix balance of vi % matching: }}}}
d7950 1
a7950 29
    #  note: tabs in the following section are not-so-helpful
    $summary = <<"END_SUM";
I<List/search source lines:>               I<Control script execution:>
  B<l> [I<ln>|I<sub>]  List source code            B<T>           Stack trace
  B<-> or B<.>      List previous/current line  B<s> [I<expr>]    Single step [in expr]
  B<v> [I<line>]    View around line            B<n> [I<expr>]    Next, steps over subs
  B<f> I<filename>  View source in file         <B<CR>/B<Enter>>  Repeat last B<n> or B<s>
  B</>I<pattern>B</> B<?>I<patt>B<?>   Search forw/backw    B<r>           Return from subroutine
  B<M>           Show module versions        B<c> [I<ln>|I<sub>]  Continue until position
I<Debugger controls:>                        B<L>           List break/watch/actions
  B<o> [...]     Set debugger options        B<t> [I<expr>]    Toggle trace [trace expr]
  B<<>[B<<>]|B<{>[B<{>]|B<>>[B<>>] [I<cmd>] Do pre/post-prompt B<b> [I<ln>|I<event>|I<sub>] [I<cnd>] Set breakpoint
  B<$prc> [I<N>|I<pat>]   Redo a previous command     B<B> I<ln|*>      Delete a/all breakpoints
  B<H> [I<-num>]    Display last num commands   B<a> [I<ln>] I<cmd>  Do cmd before line
  B<=> [I<a> I<val>]   Define/list an alias        B<A> I<ln|*>      Delete a/all actions
  B<h> [I<db_cmd>]  Get help on command         B<w> I<expr>      Add a watch expression
  B<h h>         Complete help page          B<W> I<expr|*>    Delete a/all watch exprs
  B<|>[B<|>]I<db_cmd>  Send output to pager        B<$psh>\[B<$psh>\] I<syscmd> Run cmd in a subprocess
  B<q> or B<^D>     Quit                        B<R>           Attempt a restart
I<Data Examination:>     B<expr>     Execute perl code, also see: B<s>,B<n>,B<t> I<expr>
  B<x>|B<m> I<expr>       Evals expr in list context, dumps the result or lists methods.
  B<p> I<expr>         Print expression (uses script's current package).
  B<S> [[B<!>]I<pat>]     List subroutine names [not] matching pattern
  B<V> [I<Pk> [I<Vars>]]  List Variables in Package.  Vars can be ~pattern or !pattern.
  B<X> [I<Vars>]       Same as \"B<V> I<current_package> [I<Vars>]\".
  B<y> [I<n> [I<Vars>]]   List lexicals in higher scope <n>.  Vars same as B<V>.
For more help, type B<h> I<cmd_letter>, or run B<$doccmd perldebug> for all docs.
END_SUM
				# ')}}; # Fix balance of vi % matching
d7952 1
a7952 62
	# and this is really numb...
	$pre580_help = "
B<T>		Stack trace.
B<s> [I<expr>]	Single step [in I<expr>].
B<n> [I<expr>]	Next, steps over subroutine calls [in I<expr>].
<B<CR>>		Repeat last B<n> or B<s> command.
B<r>		Return from current subroutine.
B<c> [I<line>|I<sub>]	Continue; optionally inserts a one-time-only breakpoint
		at the specified position.
B<l> I<min>B<+>I<incr>	List I<incr>+1 lines starting at I<min>.
B<l> I<min>B<->I<max>	List lines I<min> through I<max>.
B<l> I<line>		List single I<line>.
B<l> I<subname>	List first window of lines from subroutine.
B<l> I<\$var>		List first window of lines from subroutine referenced by I<\$var>.
B<l>		List next window of lines.
B<->		List previous window of lines.
B<w> [I<line>]	List window around I<line>.
B<.>		Return to the executed line.
B<f> I<filename>	Switch to viewing I<filename>. File must be already loaded.
		I<filename> may be either the full name of the file, or a regular
		expression matching the full file name:
		B<f> I</home/me/foo.pl> and B<f> I<oo\\.> may access the same file.
		Evals (with saved bodies) are considered to be filenames:
		B<f> I<(eval 7)> and B<f> I<eval 7\\b> access the body of the 7th eval
		(in the order of execution).
B</>I<pattern>B</>	Search forwards for I<pattern>; final B</> is optional.
B<?>I<pattern>B<?>	Search backwards for I<pattern>; final B<?> is optional.
B<L>		List all breakpoints and actions.
B<S> [[B<!>]I<pattern>]	List subroutine names [not] matching I<pattern>.
B<t>		Toggle trace mode.
B<t> I<expr>		Trace through execution of I<expr>.
B<b> [I<line>] [I<condition>]
		Set breakpoint; I<line> defaults to the current execution line;
		I<condition> breaks if it evaluates to true, defaults to '1'.
B<b> I<subname> [I<condition>]
		Set breakpoint at first line of subroutine.
B<b> I<\$var>		Set breakpoint at first line of subroutine referenced by I<\$var>.
B<b> B<load> I<filename> Set breakpoint on `require'ing the given file.
B<b> B<postpone> I<subname> [I<condition>]
		Set breakpoint at first line of subroutine after 
		it is compiled.
B<b> B<compile> I<subname>
		Stop after the subroutine is compiled.
B<d> [I<line>]	Delete the breakpoint for I<line>.
B<D>		Delete all breakpoints.
B<a> [I<line>] I<command>
		Set an action to be done before the I<line> is executed;
		I<line> defaults to the current execution line.
		Sequence is: check for breakpoint/watchpoint, print line
		if necessary, do action, prompt user if necessary,
		execute line.
B<a> [I<line>]	Delete the action for I<line>.
B<A>		Delete all actions.
B<W> I<expr>		Add a global watch-expression.
B<W>		Delete all watch-expressions.
B<V> [I<pkg> [I<vars>]]	List some (default all) variables in package (default current).
		Use B<~>I<pattern> and B<!>I<pattern> for positive and negative regexps.
B<X> [I<vars>]	Same as \"B<V> I<currentpackage> [I<vars>]\".
B<x> I<expr>		Evals expression in list context, dumps the result.
B<m> I<expr>		Evals expression in list context, prints methods callable
		on the first element of the result.
B<m> I<class>		Prints methods callable via the given class.
d7954 1
a7954 30
B<<> ?			List Perl commands to run before each prompt.
B<<> I<expr>		Define Perl command to run before each prompt.
B<<<> I<expr>		Add to the list of Perl commands to run before each prompt.
B<>> ?			List Perl commands to run after each prompt.
B<>> I<expr>		Define Perl command to run after each prompt.
B<>>B<>> I<expr>		Add to the list of Perl commands to run after each prompt.
B<{> I<db_command>	Define debugger command to run before each prompt.
B<{> ?			List debugger commands to run before each prompt.
B<{{> I<db_command>	Add to the list of debugger commands to run before each prompt.
B<$prc> I<number>	Redo a previous command (default previous command).
B<$prc> I<-number>	Redo number'th-to-last command.
B<$prc> I<pattern>	Redo last command that started with I<pattern>.
		See 'B<O> I<recallCommand>' too.
B<$psh$psh> I<cmd>  	Run cmd in a subprocess (reads from DB::IN, writes to DB::OUT)"
  . ( $rc eq $sh ? "" : "
B<$psh> [I<cmd>] 	Run I<cmd> in subshell (forces \"\$SHELL -c 'cmd'\")." ) . "
		See 'B<O> I<shellBang>' too.
B<source> I<file>		Execute I<file> containing debugger commands (may nest).
B<H> I<-number>	Display last number commands (default all).
B<p> I<expr>		Same as \"I<print {DB::OUT} expr>\" in current package.
B<|>I<dbcmd>		Run debugger command, piping DB::OUT to current pager.
B<||>I<dbcmd>		Same as B<|>I<dbcmd> but DB::OUT is temporarilly select()ed as well.
B<\=> [I<alias> I<value>]	Define a command alias, or list current aliases.
I<command>		Execute as a perl statement in current package.
B<v>		Show versions of loaded modules.
B<R>		Pure-man-restart of debugger, some of debugger state
		and command-line options may be lost.
		Currently the following settings are preserved:
		history, breakpoints and actions, debugger B<O>ptions 
		and the following command-line options: I<-w>, I<-I>, I<-e>.
d7956 1
a7956 33
B<O> [I<opt>] ...	Set boolean option to true
B<O> [I<opt>B<?>]	Query options
B<O> [I<opt>B<=>I<val>] [I<opt>=B<\">I<val>B<\">] ... 
		Set options.  Use quotes in spaces in value.
    I<recallCommand>, I<ShellBang>	chars used to recall command or spawn shell;
    I<pager>			program for output of \"|cmd\";
    I<tkRunning>			run Tk while prompting (with ReadLine);
    I<signalLevel> I<warnLevel> I<dieLevel>	level of verbosity;
    I<inhibit_exit>		Allows stepping off the end of the script.
    I<ImmediateStop>		Debugger should stop as early as possible.
    I<RemotePort>			Remote hostname:port for remote debugging
  The following options affect what happens with B<V>, B<X>, and B<x> commands:
    I<arrayDepth>, I<hashDepth> 	print only first N elements ('' for all);
    I<compactDump>, I<veryCompact> 	change style of array and hash dump;
    I<globPrint> 			whether to print contents of globs;
    I<DumpDBFiles> 		dump arrays holding debugged files;
    I<DumpPackages> 		dump symbol tables of packages;
    I<DumpReused> 			dump contents of \"reused\" addresses;
    I<quote>, I<HighBit>, I<undefPrint> 	change style of string dump;
    I<bareStringify> 		Do not print the overload-stringified value;
  Other options include:
    I<PrintRet>		affects printing of return value after B<r> command,
    I<frame>		affects printing messages on subroutine entry/exit.
    I<AutoTrace>	affects printing messages on possible breaking points.
    I<maxTraceLen>	gives max length of evals/args listed in stack trace.
    I<ornaments> 	affects screen appearance of the command line.
    I<CreateTTY> 	bits control attempts to create a new TTY on events:
			1: on fork()	2: debugger is started inside debugger
			4: on startup
	During startup options are initialized from \$ENV{PERLDB_OPTS}.
	You can put additional initialization options I<TTY>, I<noTTY>,
	I<ReadLine>, I<NonStop>, and I<RemotePort> there (or use
	`B<R>' after you set them).
d7958 1
a7958 6
B<q> or B<^D>		Quit. Set B<\$DB::finished = 0> to debug global destruction.
B<h> [I<db_command>]	Get help [on a specific debugger command], enter B<|h> to page.
B<h h>		Summary of debugger commands.
B<$doccmd> I<manpage>	Runs the external doc viewer B<$doccmd> command on the 
		named Perl I<manpage>, or on B<$doccmd> itself if omitted.
		Set B<\$DB::doccmd> to change viewer.
d7960 1
a7960 1
Type `|h' for a paged display if this was too hard to read.
d7962 1
a7962 1
"; # Fix balance of vi % matching: }}}}
d7964 2
a7965 28
    #  note: tabs in the following section are not-so-helpful
    $pre580_summary = <<"END_SUM";
I<List/search source lines:>               I<Control script execution:>
  B<l> [I<ln>|I<sub>]  List source code            B<T>           Stack trace
  B<-> or B<.>      List previous/current line  B<s> [I<expr>]    Single step [in expr]
  B<w> [I<line>]    List around line            B<n> [I<expr>]    Next, steps over subs
  B<f> I<filename>  View source in file         <B<CR>/B<Enter>>  Repeat last B<n> or B<s>
  B</>I<pattern>B</> B<?>I<patt>B<?>   Search forw/backw    B<r>           Return from subroutine
  B<v>           Show versions of modules    B<c> [I<ln>|I<sub>]  Continue until position
I<Debugger controls:>                        B<L>           List break/watch/actions
  B<O> [...]     Set debugger options        B<t> [I<expr>]    Toggle trace [trace expr]
  B<<>[B<<>]|B<{>[B<{>]|B<>>[B<>>] [I<cmd>] Do pre/post-prompt B<b> [I<ln>|I<event>|I<sub>] [I<cnd>] Set breakpoint
  B<$prc> [I<N>|I<pat>]   Redo a previous command     B<d> [I<ln>] or B<D> Delete a/all breakpoints
  B<H> [I<-num>]    Display last num commands   B<a> [I<ln>] I<cmd>  Do cmd before line
  B<=> [I<a> I<val>]   Define/list an alias        B<W> I<expr>      Add a watch expression
  B<h> [I<db_cmd>]  Get help on command         B<A> or B<W>      Delete all actions/watch
  B<|>[B<|>]I<db_cmd>  Send output to pager        B<$psh>\[B<$psh>\] I<syscmd> Run cmd in a subprocess
  B<q> or B<^D>     Quit                        B<R>           Attempt a restart
I<Data Examination:>     B<expr>     Execute perl code, also see: B<s>,B<n>,B<t> I<expr>
  B<x>|B<m> I<expr>       Evals expr in list context, dumps the result or lists methods.
  B<p> I<expr>         Print expression (uses script's current package).
  B<S> [[B<!>]I<pat>]     List subroutine names [not] matching pattern
  B<V> [I<Pk> [I<Vars>]]  List Variables in Package.  Vars can be ~pattern or !pattern.
  B<X> [I<Vars>]       Same as \"B<V> I<current_package> [I<Vars>]\".
  B<y> [I<n> [I<Vars>]]   List lexicals in higher scope <n>.  Vars same as B<V>.
For more help, type B<h> I<cmd_letter>, or run B<$doccmd perldebug> for all docs.
END_SUM
				# ')}}; # Fix balance of vi % matching
d7967 1
a7967 1
}
d7969 1
a7969 2
sub print_help {
    local $_ = shift;
d7971 1
a7971 23
    # Restore proper alignment destroyed by eeevil I<> and B<>
    # ornaments: A pox on both their houses!
    #
    # A help command will have everything up to and including
    # the first tab sequence padded into a field 16 (or if indented 20)
    # wide.  If it's wider than that, an extra space will be added.
    s{
	^ 		    	# only matters at start of line
	  ( \040{4} | \t )*	# some subcommands are indented
	  ( < ? 		# so <CR> works
	    [BI] < [^\t\n] + )  # find an eeevil ornament
	  ( \t+ )		# original separation, discarded
	  ( .* )		# this will now start (no earlier) than 
				# column 16
    } {
	my($leadwhite, $command, $midwhite, $text) = ($1, $2, $3, $4);
	my $clean = $command;
	$clean =~ s/[BI]<([^>]*)>/$1/g;  
    # replace with this whole string:
	($leadwhite ? " " x 4 : "")
      . $command
      . ((" " x (16 + ($leadwhite ? 4 : 0) - length($clean))) || " ")
      . $text;
d7973 3
a7975 1
    }mgex;
d7977 1
a7977 7
    s{				# handle bold ornaments
	B < ( [^>] + | > ) >
    } {
	  $Term::ReadLine::TermCap::rl_term_set[2] 
	. $1
	. $Term::ReadLine::TermCap::rl_term_set[3]
    }gex;
d7979 1
a7979 7
    s{				# handle italic ornaments
	I < ( [^>] + | > ) >
    } {
	  $Term::ReadLine::TermCap::rl_term_set[0] 
	. $1
	. $Term::ReadLine::TermCap::rl_term_set[1]
    }gex;
d7981 1
a7981 3
    local $\ = '';
    print $OUT $_;
}
d7983 3
a7985 13
sub fix_less {
    return if defined $ENV{LESS} && $ENV{LESS} =~ /r/;
    my $is_less = $pager =~ /\bless\b/;
    if ($pager =~ /\bmore\b/) { 
	my @@st_more = stat('/usr/bin/more');
	my @@st_less = stat('/usr/bin/less');
	$is_less = @@st_more    && @@st_less 
		&& $st_more[0] == $st_less[0] 
		&& $st_more[1] == $st_less[1];
    }
    # changes environment!
    $ENV{LESS} .= 'r' 	if $is_less;
}
d7987 3
a7989 16
sub diesignal {
    local $frame = 0;
    local $doret = -2;
    $SIG{'ABRT'} = 'DEFAULT';
    kill 'ABRT', $$ if $panic++;
    if (defined &Carp::longmess) {
	local $SIG{__WARN__} = '';
	local $Carp::CarpLevel = 2;		# mydie + confess
	&warn(Carp::longmess("Signal @@_"));
    }
    else {
	local $\ = '';
	print $DB::OUT "Got signal @@_\n";
    }
    kill 'ABRT', $$;
}
d7991 1
a7991 15
sub dbwarn { 
  local $frame = 0;
  local $doret = -2;
  local $SIG{__WARN__} = '';
  local $SIG{__DIE__} = '';
  eval { require Carp } if defined $^S;	# If error/warning during compilation,
                                        # require may be broken.
  CORE::warn(@@_, "\nCannot print stack trace, load with -MCarp option to see stack"),
    return unless defined &Carp::longmess;
  my ($mysingle,$mytrace) = ($single,$trace);
  $single = 0; $trace = 0;
  my $mess = Carp::longmess(@@_);
  ($single,$trace) = ($mysingle,$mytrace);
  &warn($mess); 
}
d7993 5
a7997 35
sub dbdie {
  local $frame = 0;
  local $doret = -2;
  local $SIG{__DIE__} = '';
  local $SIG{__WARN__} = '';
  my $i = 0; my $ineval = 0; my $sub;
  if ($dieLevel > 2) {
      local $SIG{__WARN__} = \&dbwarn;
      &warn(@@_);		# Yell no matter what
      return;
  }
  if ($dieLevel < 2) {
    die @@_ if $^S;		# in eval propagate
  }
  # No need to check $^S, eval is much more robust nowadays
  eval { require Carp }; #if defined $^S;# If error/warning during compilation,
                                	# require may be broken.

  die(@@_, "\nCannot print stack trace, load with -MCarp option to see stack")
    unless defined &Carp::longmess;

  # We do not want to debug this chunk (automatic disabling works
  # inside DB::DB, but not in Carp).
  my ($mysingle,$mytrace) = ($single,$trace);
  $single = 0; $trace = 0;
  my $mess = "@@_";
  { 
    package Carp;		# Do not include us in the list
    eval {
      $mess = Carp::longmess(@@_);
    };
  }
  ($single,$trace) = ($mysingle,$mytrace);
  die $mess;
}
d7999 1
a7999 12
sub warnLevel {
  if (@@_) {
    $prevwarn = $SIG{__WARN__} unless $warnLevel;
    $warnLevel = shift;
    if ($warnLevel) {
      $SIG{__WARN__} = \&DB::dbwarn;
    } elsif ($prevwarn) {
      $SIG{__WARN__} = $prevwarn;
    }
  }
  $warnLevel;
}
d8001 6
a8006 19
sub dieLevel {
  local $\ = '';
  if (@@_) {
    $prevdie = $SIG{__DIE__} unless $dieLevel;
    $dieLevel = shift;
    if ($dieLevel) {
      $SIG{__DIE__} = \&DB::dbdie; # if $dieLevel < 2;
      #$SIG{__DIE__} = \&DB::diehard if $dieLevel >= 2;
      print $OUT "Stack dump during die enabled", 
        ( $dieLevel == 1 ? " outside of evals" : ""), ".\n"
	  if $I_m_init;
      print $OUT "Dump printed too.\n" if $dieLevel > 2;
    } elsif ($prevdie) {
      $SIG{__DIE__} = $prevdie;
      print $OUT "Default die handler restored.\n";
    }
  }
  $dieLevel;
}
d8008 5
a8012 15
sub signalLevel {
  if (@@_) {
    $prevsegv = $SIG{SEGV} unless $signalLevel;
    $prevbus = $SIG{BUS} unless $signalLevel;
    $signalLevel = shift;
    if ($signalLevel) {
      $SIG{SEGV} = \&DB::diesignal;
      $SIG{BUS} = \&DB::diesignal;
    } else {
      $SIG{SEGV} = $prevsegv;
      $SIG{BUS} = $prevbus;
    }
  }
  $signalLevel;
}
d8014 4
a8017 5
sub CvGV_name {
  my $in = shift;
  my $name = CvGV_name_or_bust($in);
  defined $name ? $name : $in;
}
d8019 9
a8027 9
sub CvGV_name_or_bust {
  my $in = shift;
  return if $skipCvGV;		# Backdoor to avoid problems if XS broken...
  return unless ref $in;
  $in = \&$in;			# Hard reference...
  eval {require Devel::Peek; 1} or return;
  my $gv = Devel::Peek::CvGV($in) or return;
  *$gv{PACKAGE} . '::' . *$gv{NAME};
}
d8029 4
a8032 8
sub find_sub {
  my $subr = shift;
  $sub{$subr} or do {
    return unless defined &$subr;
    my $name = CvGV_name_or_bust($subr);
    my $data;
    $data = $sub{$name} if defined $name;
    return $data if defined $data;
d8034 5
a8038 9
    # Old stupid way...
    $subr = \&$subr;		# Hard reference
    my $s;
    for (keys %sub) {
      $s = $_, last if $subr eq \&$_;
    }
    $sub{$s} if $s;
  }
}
d8040 3
a8042 8
sub methods {
  my $class = shift;
  $class = ref $class if ref $class;
  local %seen;
  local %packs;
  methods_via($class, '', 1);
  methods_via('UNIVERSAL', 'UNIVERSAL', 0);
}
d8044 1
a8044 19
sub methods_via {
  my $class = shift;
  return if $packs{$class}++;
  my $prefix = shift;
  my $prepend = $prefix ? "via $prefix: " : '';
  my $name;
  for $name (grep {defined &{${"${class}::"}{$_}}} 
	     sort keys %{"${class}::"}) {
    next if $seen{ $name }++;
    local $\ = '';
    local $, = '';
    print $DB::OUT "$prepend$name\n";
  }
  return unless shift;		# Recurse?
  for $name (@@{"${class}::ISA"}) {
    $prepend = $prefix ? $prefix . " -> $name" : $name;
    methods_via($name, $prepend, 1);
  }
}
d8046 2
a8047 5
sub setman { 
    $doccmd = $^O !~ /^(?:MSWin32|VMS|os2|dos|amigaos|riscos|MacOS|NetWare)\z/s
		? "man"             # O Happy Day!
		: "perldoc";        # Alas, poor unfortunates
}
d8049 1
a8049 12
sub runman {
    my $page = shift;
    unless ($page) {
	&system("$doccmd $doccmd");
	return;
    } 
    # this way user can override, like with $doccmd="man -Mwhatever"
    # or even just "man " to disable the path check.
    unless ($doccmd eq 'man') {
	&system("$doccmd $page");
	return;
    } 
d8051 1
a8051 1
    $page = 'perl' if lc($page) eq 'help';
d8053 1
a8053 41
    require Config;
    my $man1dir = $Config::Config{'man1dir'};
    my $man3dir = $Config::Config{'man3dir'};
    for ($man1dir, $man3dir) { s#/[^/]*\z## if /\S/ } 
    my $manpath = '';
    $manpath .= "$man1dir:" if $man1dir =~ /\S/;
    $manpath .= "$man3dir:" if $man3dir =~ /\S/ && $man1dir ne $man3dir;
    chop $manpath if $manpath;
    # harmless if missing, I figure
    my $oldpath = $ENV{MANPATH};
    $ENV{MANPATH} = $manpath if $manpath;
    my $nopathopt = $^O =~ /dunno what goes here/;
    if (CORE::system($doccmd, 
		# I just *know* there are men without -M
		(($manpath && !$nopathopt) ? ("-M", $manpath) : ()),  
	    split ' ', $page) )
    {
	unless ($page =~ /^perl\w/) {
	    if (grep { $page eq $_ } qw{ 
		5004delta 5005delta amiga api apio book boot bot call compile
		cygwin data dbmfilter debug debguts delta diag doc dos dsc embed
		faq faq1 faq2 faq3 faq4 faq5 faq6 faq7 faq8 faq9 filter fork
		form func guts hack hist hpux intern ipc lexwarn locale lol mod
		modinstall modlib number obj op opentut os2 os390 pod port 
		ref reftut run sec style sub syn thrtut tie toc todo toot tootc
		trap unicode var vms win32 xs xstut
	      }) 
	    {
		$page =~ s/^/perl/;
		CORE::system($doccmd, 
			(($manpath && !$nopathopt) ? ("-M", $manpath) : ()),  
			$page);
	    }
	}
    } 
    if (defined $oldpath) {
	$ENV{MANPATH} = $manpath;
    } else {
	delete $ENV{MANPATH};
    } 
} 
d8055 1
a8055 1
# The following BEGIN is very handy if debugger goes havoc, debugging debugger?
d8057 1
a8057 26
BEGIN {			# This does not compile, alas.
  $IN = \*STDIN;		# For bugs before DB::OUT has been opened
  $OUT = \*STDERR;		# For errors before DB::OUT has been opened
  $sh = '!';
  $rc = ',';
  @@hist = ('?');
  $deep = 100;			# warning if stack gets this deep
  $window = 10;
  $preview = 3;
  $sub = '';
  $SIG{INT} = \&DB::catch;
  # This may be enabled to debug debugger:
  #$warnLevel = 1 unless defined $warnLevel;
  #$dieLevel = 1 unless defined $dieLevel;
  #$signalLevel = 1 unless defined $signalLevel;

  $db_stop = 0;			# Compiler warning
  $db_stop = 1 << 30;
  $level = 0;			# Level of recursive debugging
  # @@stack and $doret are needed in sub sub, which is called for DB::postponed.
  # Triggers bug (?) in perl is we postpone this until runtime:
  @@postponed = @@stack = (0);
  $stack_depth = 0;		# Localized $#stack
  $doret = -2;
  $frame = 0;
}
d8059 1
a8059 1
BEGIN {$^W = $ini_warn;}	# Switch warnings back
d8061 1
a8061 1
#use Carp;			# This did break, left for debugging
d8063 1
a8063 79
sub db_complete {
  # Specific code for b c l V m f O, &blah, $blah, @@blah, %blah
  my($text, $line, $start) = @@_;
  my ($itext, $search, $prefix, $pack) =
    ($text, "^\Q${'package'}::\E([^:]+)\$");
  
  return sort grep /^\Q$text/, (keys %sub), qw(postpone load compile), # subroutines
                               (map { /$search/ ? ($1) : () } keys %sub)
    if (substr $line, 0, $start) =~ /^\|*[blc]\s+((postpone|compile)\s+)?$/;
  return sort grep /^\Q$text/, values %INC # files
    if (substr $line, 0, $start) =~ /^\|*b\s+load\s+$/;
  return sort map {($_, db_complete($_ . "::", "V ", 2))}
    grep /^\Q$text/, map { /^(.*)::$/ ? ($1) : ()} keys %:: # top-packages
      if (substr $line, 0, $start) =~ /^\|*[Vm]\s+$/ and $text =~ /^\w*$/;
  return sort map {($_, db_complete($_ . "::", "V ", 2))}
    grep !/^main::/,
      grep /^\Q$text/, map { /^(.*)::$/ ? ($prefix . "::$1") : ()} keys %{$prefix . '::'}
				 # packages
	if (substr $line, 0, $start) =~ /^\|*[Vm]\s+$/ 
	  and $text =~ /^(.*[^:])::?(\w*)$/  and $prefix = $1;
  if ( $line =~ /^\|*f\s+(.*)/ ) { # Loaded files
    # We may want to complete to (eval 9), so $text may be wrong
    $prefix = length($1) - length($text);
    $text = $1;
    return sort 
	map {substr $_, 2 + $prefix} grep /^_<\Q$text/, (keys %main::), $0
  }
  if ((substr $text, 0, 1) eq '&') { # subroutines
    $text = substr $text, 1;
    $prefix = "&";
    return sort map "$prefix$_", 
               grep /^\Q$text/, 
                 (keys %sub),
                 (map { /$search/ ? ($1) : () } 
		    keys %sub);
  }
  if ($text =~ /^[\$@@%](.*)::(.*)/) { # symbols in a package
    $pack = ($1 eq 'main' ? '' : $1) . '::';
    $prefix = (substr $text, 0, 1) . $1 . '::';
    $text = $2;
    my @@out 
      = map "$prefix$_", grep /^\Q$text/, grep /^_?[a-zA-Z]/, keys %$pack ;
    if (@@out == 1 and $out[0] =~ /::$/ and $out[0] ne $itext) {
      return db_complete($out[0], $line, $start);
    }
    return sort @@out;
  }
  if ($text =~ /^[\$@@%]/) { # symbols (in $package + packages in main)
    $pack = ($package eq 'main' ? '' : $package) . '::';
    $prefix = substr $text, 0, 1;
    $text = substr $text, 1;
    my @@out = map "$prefix$_", grep /^\Q$text/, 
       (grep /^_?[a-zA-Z]/, keys %$pack), 
       ( $pack eq '::' ? () : (grep /::$/, keys %::) ) ;
    if (@@out == 1 and $out[0] =~ /::$/ and $out[0] ne $itext) {
      return db_complete($out[0], $line, $start);
    }
    return sort @@out;
  }
  if ((substr $line, 0, $start) =~ /^\|*O\b.*\s$/) { # Options after a space
    my @@out = grep /^\Q$text/, @@options;
    my $val = option_val($out[0], undef);
    my $out = '? ';
    if (not defined $val or $val =~ /[\n\r]/) {
      # Can do nothing better
    } elsif ($val =~ /\s/) {
      my $found;
      foreach $l (split //, qq/\"\'\#\|/) {
	$out = "$l$val$l ", last if (index $val, $l) == -1;
      }
    } else {
      $out = "=$val ";
    }
    # Default to value if one completion, to question if many
    $rl_attribs->{completer_terminator_character} = (@@out == 1 ? $out : '? ');
    return sort @@out;
  }
  return $term->filename_list($text); # filenames
}
d8066 2
a8067 2
  local $\ = '';
  print $OUT "Use `q' to quit or `R' to restart.  `h q' for details.\n"
d8070 7
d8080 2
a8081 1
    } else {
d8084 23
a8106 1
}
d8109 19
a8127 6
  $finished = 1 if $inhibit_exit;      # So that some keys may be disabled.
  $fall_off_end = 1 unless $inhibit_exit;
  # Do not stop in at_exit() and destructors on exit:
  $DB::single = !$fall_off_end && !$runnonstop;
  DB::fake::at_exit() unless $fall_off_end or $runnonstop;
}
d8129 1
d8131 1
a8131 3
# ===================================== pre580 ================================
# this is very sad below here...
#
d8134 2
a8135 1
	# do nothing...
d8138 7
d8146 45
a8190 17
	my $cmd = shift;
	if ($cmd =~ /^(\d*)\s*(.*)/) {
		$i = $1 || $line; $j = $2;
		if (length $j) {
			if ($dbline[$i] == 0) {
				print $OUT "Line $i may not have an action.\n";
			} else {
				$had_breakpoints{$filename} |= 2;
				$dbline{$i} =~ s/\0[^\0]*//;
				$dbline{$i} .= "\0" . action($j);
			}
		} else {
			$dbline{$i} =~ s/\0[^\0]*//;
			delete $dbline{$i} if $dbline{$i} eq '';
		}
	}
}
d8193 56
a8248 23
	my $cmd    = shift;
	my $dbline = shift;
	if ($cmd =~ /^load\b\s*(.*)/) {
		my $file = $1; $file =~ s/\s+$//;
		&cmd_b_load($file);
	} elsif ($cmd =~ /^(postpone|compile)\b\s*([':A-Za-z_][':\w]*)\s*(.*)/) {
		my $cond = length $3 ? $3 : '1';
		my ($subname, $break) = ($2, $1 eq 'postpone');
		$subname =~ s/\'/::/g;
		$subname = "${'package'}::" . $subname
		unless $subname =~ /::/;
		$subname = "main".$subname if substr($subname,0,2) eq "::";
		$postponed{$subname} = $break ? "break +0 if $cond" : "compile";
	} elsif ($cmd =~ /^([':A-Za-z_][':\w]*(?:\[.*\])?)\s*(.*)/) { 
		my $subname = $1;
		my $cond = length $2 ? $2 : '1';
		&cmd_b_sub($subname, $cond);
	} elsif ($cmd =~ /^(\d*)\s*(.*)/) {
		my $i = $1 || $dbline;
		my $cond = length $2 ? $2 : '1';
		&cmd_b_line($i, $cond);
	}
}
d8251 50
a8300 27
	my $cmd = shift;
	if ($cmd =~ /^\s*$/) {
		print $OUT "Deleting all breakpoints...\n";
		my $file;
		for $file (keys %had_breakpoints) {
			local *dbline = $main::{'_<' . $file};
			my $max = $#dbline;
			my $was;

			for ($i = 1; $i <= $max ; $i++) {
				if (defined $dbline{$i}) {
					$dbline{$i} =~ s/^[^\0]+//;
					if ($dbline{$i} =~ s/^\0?$//) {
						delete $dbline{$i};
					}
				}
			}

			if (not $had_breakpoints{$file} &= ~1) {
				delete $had_breakpoints{$file};
			}
		}
		undef %postponed;
		undef %postponed_file;
		undef %break_on_load;
	}
}
d8303 52
a8354 18
	my $cmd = shift;
	if ($cmd =~ /^\s*$/) {
		print_help($pre580_help);
	} elsif ($cmd =~ /^h\s*/) {
		print_help($pre580_summary);
	} elsif ($cmd =~ /^h\s+(\S.*)$/) { 
		my $asked = $1;			# for proper errmsg
		my $qasked = quotemeta($asked); # for searching
		# XXX: finds CR but not <CR>
		if ($pre580_help =~ /^<?(?:[IB]<)$qasked/m) {
			while ($pre580_help =~ /^(<?(?:[IB]<)$qasked([\s\S]*?)\n)(?!\s)/mg) {
				print_help($1);
			}
		} else {
			print_help("B<$asked> is not a debugger command.\n");
		}
	}
}
d8357 159
a8515 13
	my $cmd = shift;
	if ($cmd =~ /^$/) { 
		$trace &= ~2;
		@@to_watch = @@old_watch = ();
	} elsif ($cmd =~ /^(.*)/s) {
		push @@to_watch, $1;
		$evalarg = $1;
		my ($val) = &eval;
		$val = (defined $val) ? "'$val'" : 'undef' ;
		push @@old_watch, $val;
		$trace |= 2;
	}
}
d8520 1
a8520 1
  "Debugged program terminated.  Use `q' to quit or `R' to restart.";
d8523 1
a8523 1
package DB;			# Do not trace this 1; below!
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d4 2
d7 32
a38 2
$VERSION = 1.07;
$header = "perl5db.pl version $VERSION";
d40 2
d46 3
d50 1
a50 1
# a &DB'DB(); in front of every place that can have a
d65 2
a66 2
# The array @@{$main::{'_<'.$filename}} is the line-by-line contents of
# $filename.
d68 6
a73 5
# The hash %{'_<'.$filename} contains breakpoints and action (it is
# keyed by line number), and individual entries are settable (as
# opposed to the whole hash). Only true/false is important to the
# interpreter, though the values used by perl5db.pl have the form
# "$break_condition\0$action". Values are magical in numeric context.
a122 1
# Latest version available: ftp://ftp.math.ohio-state.edu/pub/users/ilya/perl
d159 1
a159 1
#	now only `q' exits debugger (overwriteable on $inhibit_exit).
d169 1
a169 1
#	'l -' is a synonim for `-'.
d187 1
a187 1
#   + Added bare mimimal security checks on perldb rc files, plus
d195 1
a195 1
#     and needs a lot of work at restructuing. It's also misindented
d204 1
a204 1
#     tricking Perl into thinking you wern't calling a debugger command!
d227 97
a323 1

d354 2
a355 1
@@options     = qw(hashDepth arrayDepth DumpDBFiles DumpPackages DumpReused
d361 2
a362 2
		  ImmediateStop bareStringify
		  RemotePort);
d367 1
d374 2
a375 1
		 UsageOnly	=> \$dumpvar::usageOnly,     
d383 1
d414 2
a415 2
$warnLevel	= 0	unless defined $warnLevel;
$dieLevel	= 0	unless defined $dieLevel;
d420 2
d427 6
a432 6
&pager(
    (defined($ENV{PAGER}) 
	? $ENV{PAGER}
	: ($^O eq 'os2' 
	   ? 'cmd /c more' 
	   : 'more'))) unless defined $pager;
d436 1
d438 12
d513 7
d577 4
d600 7
a606 5
  }
  else {
    if (defined $console) {
      open(IN,"+<$console") || open(IN,"<$console") || open(IN,"<&STDIN");
      open(OUT,"+>$console") || open(OUT,">$console") || open(OUT,">&STDERR")
d608 1
a608 1
    } else {
d614 1
a614 3
    $IN = \*IN;

    $OUT = \*OUT;
d616 1
a616 1
  select($OUT);
d618 1
a618 1
  select(STDOUT);
a622 2
  $| = 1;			# for real STDOUT

d625 11
a635 5
    print $OUT "\nLoading DB routines from $header\n";
    print $OUT ("Editor support ",
		$slave_editor ? "enabled" : "available",
		".\n");
    print $OUT "\nEnter h or `h h' for help, or `$doccmd perldebug' for more help.\n\n";
d669 3
a671 3
    ($package, $filename, $line) = caller;
    $filename_ini = $filename;
    $usercontext = '($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;' .
d674 16
a689 8
    $max = $#dbline;
    if (($stop,$action) = split(/\0/,$dbline{$line})) {
	if ($stop eq '1') {
	    $signal |= 1;
	} elsif ($stop) {
	    $evalarg = "\$DB::signal |= 1 if do {$stop}"; &eval;
	    $dbline{$line} =~ s/;9($|\0)/$1/;
	}
d694 7
a700 7
	$evalarg = $to_watch[$n];
	local $onetimeDump;	# Do not output results
	my ($val) = &eval;	# Fix context (&eval is doing array)?
	$val = ( (defined $val) ? "'$val'" : 'undef' );
	if ($val ne $old_watch[$n]) {
	  $signal = 1;
	  print $OUT <<EOP;
d702 2
a703 2
    old value:\t$old_watch[$n]
    new value:\t$val
d705 2
a706 2
	  $old_watch[$n] = $val;
	}
d718 1
a718 1
	    print $LINEINFO $position;
d736 2
a737 2
		$prefix = "";
		$infix = ":\t";
d739 2
a740 2
		$infix = "):\t";
		$position = "$prefix$line$infix$dbline[$line]$after";
d743 1
a743 1
		print $LINEINFO ' ' x $stack_depth, "$line:\t$dbline[$line]$after";
d745 1
a745 1
		print $LINEINFO $position;
d748 10
a757 10
		last if $dbline[$i] =~ /^\s*[\;\}\#\n]/;
		last if $signal;
		$after = ($dbline[$i] =~ /\n$/ ? '' : "\n");
		$incr_pos = "$prefix$i$infix$dbline[$i]$after";
		$position .= $incr_pos;
		if ($frame) {
		    print $LINEINFO ' ' x $stack_depth, "$i:\t$dbline[$i]$after";
		} else {
		    print $LINEINFO $incr_pos;
		}
d763 10
a772 10
	local $level = $level + 1;
	foreach $evalarg (@@$pre) {
	  &eval;
	}
	print $OUT $stack_depth . " levels deep in subroutine calls!\n"
	  if $single & 4;
	$start = $line;
	$incr = -1;		# for backward motion.
	@@typeahead = (@@$pretype, @@typeahead);
      CMD:
d774 3
a776 4
	       ($term_pid == $$ or &resetterm),
	       defined ($cmd=&readline("  DB" . ('<' x $level) .
				       ($#hist+1) . ('>' x $level) .
				       " "))) 
d791 9
a799 8
			# squelch the sigmangler
			local $SIG{__DIE__};
			local $SIG{__WARN__};
			eval "\$cmd =~ $alias{$i}";
			if ($@@) {
			    print $OUT "Couldn't evaluate `$i' alias: $@@";
			    next CMD;
			} 
d801 5
a805 21
                   $cmd =~ /^q$/ && ($fall_off_end = 1) && exit $?;
		    $cmd =~ /^h$/ && do {
			print_help($help);
			next CMD; };
		    $cmd =~ /^h\s+h$/ && do {
			print_help($summary);
			next CMD; };
		    # support long commands; otherwise bogus errors
		    # happen when you ask for h on <CR> for example
		    $cmd =~ /^h\s+(\S.*)$/ && do {      
			my $asked = $1;			# for proper errmsg
			my $qasked = quotemeta($asked); # for searching
			# XXX: finds CR but not <CR>
			if ($help =~ /^<?(?:[IB]<)$qasked/m) {
			  while ($help =~ /^(<?(?:[IB]<)$qasked([\s\S]*?)\n)(?!\s)/mg) {
			    print_help($1);
			  }
			} else {
			    print_help("B<$asked> is not a debugger command.\n");
			}
			next CMD; };
d808 1
d814 2
a821 2
		    $cmd =~ /^v$/ && do {
			list_versions(); next CMD};
d834 4
a837 1
			    eval { &main::dumpvar($packname,@@vars) };
d847 6
a852 1
			$onetimeDump = 'dump'; };
d861 1
a861 1
			    print $OUT "The old f command is now the r command.\n";
a885 34
		    $cmd =~ s/^l\s+-\s*$/-/;
		    $cmd =~ /^([lb])\b\s*(\$.*)/s && do {
			$evalarg = $2;
			my ($s) = &eval;
			print($OUT "Error: $@@\n"), next CMD if $@@;
			$s = CvGV_name($s);
			print($OUT "Interpreted as: $1 $s\n");
			$cmd = "$1 $s";
		    };
		    $cmd =~ /^l\b\s*([\':A-Za-z_][\':\w]*(\[.*\])?)/s && do {
			$subname = $1;
			$subname =~ s/\'/::/;
			$subname = $package."::".$subname 
			  unless $subname =~ /::/;
			$subname = "main".$subname if substr($subname,0,2) eq "::";
			@@pieces = split(/:/,find_sub($subname) || $sub{$subname});
			$subrange = pop @@pieces;
			$file = join(':', @@pieces);
			if ($file ne $filename) {
			    print $OUT "Switching to file '$file'.\n"
				unless $slave_editor;
			    *dbline = $main::{'_<' . $file};
			    $max = $#dbline;
			    $filename = $file;
			}
			if ($subrange) {
			    if (eval($subrange) < -$window) {
				$subrange =~ s/-.*/+/;
			    }
			    $cmd = "l $subrange";
			} else {
			    print $OUT "Subroutine $subname not found.\n";
			    next CMD;
			} };
d892 1
a892 1
			print $LINEINFO $position;
a893 6
		    $cmd =~ /^w\b\s*(\d*)$/ && do {
			$incr = $window - 1;
			$start = $1 if $1;
			$start -= $preview;
			#print $OUT 'l ' . $start . '-' . ($start + $incr);
			$cmd = 'l ' . $start . '-' . ($start + $incr); };
d899 7
a905 215
		    $cmd =~ /^l$/ && do {
			$incr = $window - 1;
			$cmd = 'l ' . $start . '-' . ($start + $incr); };
		    $cmd =~ /^l\b\s*(\d*)\+(\d*)$/ && do {
			$start = $1 if $1;
			$incr = $2;
			$incr = $window - 1 unless $incr;
			$cmd = 'l ' . $start . '-' . ($start + $incr); };
		    $cmd =~ /^l\b\s*((-?[\d\$\.]+)([-,]([\d\$\.]+))?)?/ && do {
			$end = (!defined $2) ? $max : ($4 ? $4 : $2);
			$end = $max if $end > $max;
			$i = $2;
			$i = $line if $i eq '.';
			$i = 1 if $i < 1;
			$incr = $end - $i;
			if ($slave_editor) {
			    print $OUT "\032\032$filename:$i:0\n";
			    $i = $end;
			} else {
			    for (; $i <= $end; $i++) {
			        ($stop,$action) = split(/\0/, $dbline{$i});
			        $arrow = ($i==$line 
					  and $filename eq $filename_ini) 
				  ?  '==>' 
				    : ($dbline[$i]+0 ? ':' : ' ') ;
				$arrow .= 'b' if $stop;
				$arrow .= 'a' if $action;
				print $OUT "$i$arrow\t", $dbline[$i];
				$i++, last if $signal;
			    }
			    print $OUT "\n" unless $dbline[$i-1] =~ /\n$/;
			}
			$start = $i; # remember in case they want more
			$start = $max if $start > $max;
			next CMD; };
		    $cmd =~ /^D$/ && do {
		      print $OUT "Deleting all breakpoints...\n";
		      my $file;
		      for $file (keys %had_breakpoints) {
			local *dbline = $main::{'_<' . $file};
			my $max = $#dbline;
			my $was;
			
			for ($i = 1; $i <= $max ; $i++) {
			    if (defined $dbline{$i}) {
				$dbline{$i} =~ s/^[^\0]+//;
				if ($dbline{$i} =~ s/^\0?$//) {
				    delete $dbline{$i};
				}
			    }
			}
			
			if (not $had_breakpoints{$file} &= ~1) {
			    delete $had_breakpoints{$file};
			}
		      }
		      undef %postponed;
		      undef %postponed_file;
		      undef %break_on_load;
		      next CMD; };
		    $cmd =~ /^L$/ && do {
		      my $file;
		      for $file (keys %had_breakpoints) {
			local *dbline = $main::{'_<' . $file};
			my $max = $#dbline;
			my $was;
			
			for ($i = 1; $i <= $max; $i++) {
			    if (defined $dbline{$i}) {
			        print $OUT "$file:\n" unless $was++;
				print $OUT " $i:\t", $dbline[$i];
				($stop,$action) = split(/\0/, $dbline{$i});
				print $OUT "   break if (", $stop, ")\n"
				  if $stop;
				print $OUT "   action:  ", $action, "\n"
				  if $action;
				last if $signal;
			    }
			}
		      }
		      if (%postponed) {
			print $OUT "Postponed breakpoints in subroutines:\n";
			my $subname;
			for $subname (keys %postponed) {
			  print $OUT " $subname\t$postponed{$subname}\n";
			  last if $signal;
			}
		      }
		      my @@have = map { # Combined keys
			keys %{$postponed_file{$_}}
		      } keys %postponed_file;
		      if (@@have) {
			print $OUT "Postponed breakpoints in files:\n";
			my ($file, $line);
			for $file (keys %postponed_file) {
			  my $db = $postponed_file{$file};
			  print $OUT " $file:\n";
			  for $line (sort {$a <=> $b} keys %$db) {
				print $OUT "  $line:\n";
				my ($stop,$action) = split(/\0/, $$db{$line});
				print $OUT "    break if (", $stop, ")\n"
				  if $stop;
				print $OUT "    action:  ", $action, "\n"
				  if $action;
				last if $signal;
			  }
			  last if $signal;
			}
		      }
		      if (%break_on_load) {
			print $OUT "Breakpoints on load:\n";
			my $file;
			for $file (keys %break_on_load) {
			  print $OUT " $file\n";
			  last if $signal;
			}
		      }
		      if ($trace & 2) {
			print $OUT "Watch-expressions:\n";
			my $expr;
			for $expr (@@to_watch) {
			  print $OUT " $expr\n";
			  last if $signal;
			}
		      }
		      next CMD; };
		    $cmd =~ /^b\b\s*load\b\s*(.*)/ && do {
			my $file = $1; $file =~ s/\s+$//;
			{
			  $break_on_load{$file} = 1;
			  $break_on_load{$::INC{$file}} = 1 if $::INC{$file};
			  $file .= '.pm', redo unless $file =~ /\./;
			}
			$had_breakpoints{$file} |= 1;
			print $OUT "Will stop on load of `@@{[join '\', `', sort keys %break_on_load]}'.\n";
			next CMD; };
		    $cmd =~ /^b\b\s*(postpone|compile)\b\s*([':A-Za-z_][':\w]*)\s*(.*)/ && do {
			my $cond = length $3 ? $3 : '1';
			my ($subname, $break) = ($2, $1 eq 'postpone');
			$subname =~ s/\'/::/g;
			$subname = "${'package'}::" . $subname
			  unless $subname =~ /::/;
			$subname = "main".$subname if substr($subname,0,2) eq "::";
			$postponed{$subname} = $break 
			  ? "break +0 if $cond" : "compile";
			next CMD; };
		    $cmd =~ /^b\b\s*([':A-Za-z_][':\w]*(?:\[.*\])?)\s*(.*)/ && do {
			$subname = $1;
			$cond = length $2 ? $2 : '1';
			$subname =~ s/\'/::/g;
			$subname = "${'package'}::" . $subname
			  unless $subname =~ /::/;
			$subname = "main".$subname if substr($subname,0,2) eq "::";
			# Filename below can contain ':'
			($file,$i) = (find_sub($subname) =~ /^(.*):(.*)$/);
			$i += 0;
			if ($i) {
			    local $filename = $file;
			    local *dbline = $main::{'_<' . $filename};
			    $had_breakpoints{$filename} |= 1;
			    $max = $#dbline;
			    ++$i while $dbline[$i] == 0 && $i < $max;
			    $dbline{$i} =~ s/^[^\0]*/$cond/;
			} else {
			    print $OUT "Subroutine $subname not found.\n";
			}
			next CMD; };
		    $cmd =~ /^b\b\s*(\d*)\s*(.*)/ && do {
			$i = $1 || $line;
			$cond = length $2 ? $2 : '1';
			if ($dbline[$i] == 0) {
			    print $OUT "Line $i not breakable.\n";
			} else {
			    $had_breakpoints{$filename} |= 1;
			    $dbline{$i} =~ s/^[^\0]*/$cond/;
			}
			next CMD; };
		    $cmd =~ /^d\b\s*(\d*)/ && do {
			$i = $1 || $line;
                        if ($dbline[$i] == 0) {
                            print $OUT "Line $i not breakable.\n";
                        } else {
			    $dbline{$i} =~ s/^[^\0]*//;
			    delete $dbline{$i} if $dbline{$i} eq '';
                        }
			next CMD; };
		    $cmd =~ /^A$/ && do {
		      print $OUT "Deleting all actions...\n";
		      my $file;
		      for $file (keys %had_breakpoints) {
			local *dbline = $main::{'_<' . $file};
			my $max = $#dbline;
			my $was;
			
			for ($i = 1; $i <= $max ; $i++) {
			    if (defined $dbline{$i}) {
				$dbline{$i} =~ s/\0[^\0]*//;
				delete $dbline{$i} if $dbline{$i} eq '';
			    }
			}
			
			unless ($had_breakpoints{$file} &= ~2) {
			    delete $had_breakpoints{$file};
			}
		      }
		      next CMD; };
		    $cmd =~ /^O\s*$/ && do {
			for (@@options) {
			    &dump_option($_);
			}
			next CMD; };
		    $cmd =~ /^O\s*(\S.*)/ && do {
			parse_options($1);
			next CMD; };
		    $cmd =~ /^\<\<\s*(.*)/ && do { # \<\< for CPerl sake: not HERE
d983 22
a1004 16
		    $cmd =~ /^a\b\s*(\d*)\s*(.*)/ && do {
			$i = $1 || $line; $j = $2;
			if (length $j) {
			    if ($dbline[$i] == 0) {
				print $OUT "Line $i may not have an action.\n";
			    } else {
				$had_breakpoints{$filename} |= 2;
				$dbline{$i} =~ s/\0[^\0]*//;
				$dbline{$i} .= "\0" . action($j);
			    }
			} else {
			    $dbline{$i} =~ s/\0[^\0]*//;
			    delete $dbline{$i} if $dbline{$i} eq '';
			}
			next CMD; };
		    $cmd =~ /^n$/ && do {
d1021 1
a1021 1
			if ($i =~ /\D/) { # subroutine name
d1062 1
d1086 1
a1086 1
			    if $file =~ /^\(eval \d+\)$/;
d1131 2
d1134 1
a1134 1
			exec $^X, '-d', @@flags, @@script, ($slave_editor ? '-emacs' : ()), @@ARGS;
d1140 2
a1141 12
		    $cmd =~ /^W\s*$/ && do {
			$trace &= ~2;
			@@to_watch = @@old_watch = ();
			next CMD; };
		    $cmd =~ /^W\b\s*(.*)/s && do {
			push @@to_watch, $1;
			$evalarg = $1;
			my ($val) = &eval;
			$val = (defined $val) ? "'$val'" : 'undef' ;
			push @@old_watch, $val;
			$trace |= 2;
			next CMD; };
d1253 1
a1253 2
			} 
                        elsif (my($k,$v) = ($cmd =~ /^(\S+)\s+(\S.*)/)) {
d1266 1
a1266 2
			} 
			else {
d1281 7
d1326 1
d1364 1
a1364 1
       $fall_off_end = 1 unless defined $cmd; # Emulate `q' on EOF
d1387 1
a1387 1
     ? ( (print $LINEINFO ' ' x ($stack_depth - 1), "in  "), 
d1390 1
a1390 1
     : print $LINEINFO ' ' x ($stack_depth - 1), "entering $sub$al\n") if $frame;
d1395 1
a1395 1
	 ? ( (print $LINEINFO ' ' x $stack_depth, "out "), 
d1397 1
a1397 1
	 : print $LINEINFO ' ' x $stack_depth, "exited $sub$al\n") if $frame & 2;
d1399 1
d1407 555
a1961 19
    } else {
        if (defined wantarray) {
	    $ret = &$sub;
        } else {
            &$sub; undef $ret;
        };
	$single |= $stack[$stack_depth--];
	($frame & 4 
	 ? ( (print $LINEINFO ' ' x $stack_depth, "out "), 
	      print_trace($LINEINFO, -1, 1, 1, "$sub$al") )
	 : print $LINEINFO ' ' x $stack_depth, "exited $sub$al\n") if $frame & 2;
	if ($doret eq $stack_depth or $frame & 16 and defined wantarray) {
            my $fh = ($doret eq $stack_depth ? $OUT : $LINEINFO);
	    print $fh (' ' x $stack_depth) if $frame & 16;
	    print $fh (defined wantarray 
			 ? "scalar context return from $sub: " 
			 : "void context return from $sub\n");
	    dumpit( $fh, $ret ) if defined wantarray;
	    $doret = -2;
a1962 2
	$ret;
    }
d1965 2
d1972 7
a1980 27
sub eval {
    # 'my' would make it visible from user code
    #    but so does local! --tchrist  
    local @@res;			
    {
	local $otrace = $trace;
	local $osingle = $single;
	local $od = $^D;
	{ ($evalarg) = $evalarg =~ /(.*)/s; }
	@@res = eval "$usercontext $evalarg;\n"; # '\n' for nice recursive debug
	$trace = $otrace;
	$single = $osingle;
	$^D = $od;
    }
    my $at = $@@;
    local $saved[0];		# Preserve the old value of $@@
    eval { &DB::save };
    if ($at) {
	print $OUT $at;
    } elsif ($onetimeDump eq 'dump') {
	dumpit($OUT, \@@res);
    } elsif ($onetimeDump eq 'methods') {
	methods($res[0]);
    }
    @@res;
}

d1996 1
d2016 1
d2019 1
a2019 1
  print $LINEINFO ' ' x $stack_depth, "Package $filename.\n" if $frame;
d2041 7
a2047 1
	&main::dumpValue(shift);
d2049 1
d2060 1
d2062 1
d2202 4
a2205 2
	    open(IN,"<$tty") or die "Cannot open TTY `$TTY' for read: $!";
	    open(OUT,">$tty") or die "Cannot open TTY `$TTY' for write: $!";
d2219 3
d2245 4
a2248 9
sub resetterm {			# We forked, so we need a different TTY
    $term_pid = $$;
    if (defined &get_fork_TTY) {
      &get_fork_TTY;
    } elsif (not defined $fork_TTY 
	     and defined $ENV{TERM} and $ENV{TERM} eq 'xterm' 
	     and defined $ENV{WINDOWID} and defined $ENV{DISPLAY}) { 
        # Possibly _inside_ XTERM
        open XT, q[3>&1 xterm -title 'Forked Perl debugger' -e sh -c 'tty 1>&3;\
d2250 71
a2320 7
        $fork_TTY = <XT>;
        chomp $fork_TTY;
    }
    if (defined $fork_TTY) {
      TTY($fork_TTY);
      undef $fork_TTY;
    } else {
d2322 4
a2325 4
I<#########> Forked, but do not know how to change a B<TTY>. I<#########>
  Define B<\$DB::fork_TTY> 
       - or a function B<DB::get_fork_TTY()> which will set B<\$DB::fork_TTY>.
  The value of B<\$DB::fork_TTY> should be the name of I<TTY> to use.
d2328 1
d2330 4
d2335 15
d2357 1
d2365 5
d2405 1
d2411 1
d2415 1
a2415 1
        arrayDepth hashDepth LineInfo maxTraceLen ornaments
a2431 1

d2457 2
a2458 1
	    print $OUT "Option `$opt' is non-boolean.  Use `O $option=VAL' to set, `O $option?' to query\n";
d2520 1
d2524 16
d2550 1
a2550 3
      $term->newTTY(\*IN, \*OUT);
      $IN	= \*IN;
      $OUT	= \*OUT;
d2552 4
a2555 4
    } elsif ($term and @@_) {
	&warn("Too late to set TTY, enabled on next `R'!\n");
    } 
    $tty = shift if @@_;
d2587 1
a2616 1
    &sethelp;
a2637 1
    &sethelp;
d2654 1
a2654 1
sub list_versions {
d2672 1
a2672 1
    # XXX: make sure these are tabs between the command and explantion,
d2677 178
a2923 1
B<<> I<expr>		Define Perl command to run before each prompt.
d2933 1
d2943 1
a2943 1
		Currently the following setting are preserved: 
d2969 3
a2971 3
    I<frame>		affects printing messages on entry and exit from subroutines.
    I<AutoTrace>	affects printing messages on every possible breaking point.
    I<maxTraceLen>	gives maximal length of evals/args listed in stack trace.
d2973 3
d2990 1
a2990 1
"; # Fix balance of vi % matching: } }}
d2992 2
a2993 1
    $summary = <<"END_SUM";
d3000 1
a3000 1
  B<v>	      Show versions of modules    B<c> [I<ln>|I<sub>]  Continue until position
d3009 8
a3016 7
  B<q> or B<^D>     Quit			  B<R>	      Attempt a restart
I<Data Examination:>	      B<expr>     Execute perl code, also see: B<s>,B<n>,B<t> I<expr>
  B<x>|B<m> I<expr>	Evals expr in list context, dumps the result or lists methods.
  B<p> I<expr>	Print expression (uses script's current package).
  B<S> [[B<!>]I<pat>]	List subroutine names [not] matching pattern
  B<V> [I<Pk> [I<Vars>]]	List Variables in Package.  Vars can be ~pattern or !pattern.
  B<X> [I<Vars>]	Same as \"B<V> I<current_package> [I<Vars>]\".
d3020 1
d3030 2
a3031 2
    # the first tab sequence paddeed into a field 16 (or if indented 20)
    # wide.  If it's wide than that, an extra space will be added.
d3045 1
a3045 1
	(length($leadwhite) ? " " x 4 : "")
d3047 1
a3047 1
      . ((" " x (16 + (length($leadwhite) ? 4 : 0) - length($clean))) || " ")
d3068 1
d3097 1
d3110 1
a3110 1
  warn(@@_, "\nCannot print stack trace, load with -MCarp option to see stack"),
d3133 2
a3134 1
  eval { require Carp } if defined $^S;	# If error/warning during compilation,
d3144 7
a3150 1
  my $mess = Carp::longmess(@@_);
d3161 1
a3161 1
    } else {
d3169 1
d3180 1
a3180 1
    } else {
d3213 1
d3257 2
d3269 1
a3269 1
    $doccmd = $^O !~ /^(?:MSWin32|VMS|os2|dos|amigaos|riscos|MacOS)\z/s
d3301 1
a3301 1
    if (system($doccmd, 
d3318 1
a3318 1
		system($doccmd, 
d3362 1
a3362 1
#use Carp;			# This did break, left for debuggin
d3445 1
d3449 8
d3465 117
d3591 1
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d28 1
a28 1
# The array @@{$main::{'_<'.$filename} is the line-by-line contents of
d37 1
a37 1
# The scalar ${'_<'.$filename} contains "_<$filename".
d404 6
d435 1
a435 1
    if (!$OUT) { die "Could not create socket to connect to remote host."; }
d626 1
a626 1
		    $cmd =~ /^q$/ && ($exiting = 1) && exit 0;
d908 1
a908 1
			my $cond = $3 || '1';
d910 1
a910 1
			$subname =~ s/\'/::/;
d919 2
a920 2
			$cond = $2 || '1';
			$subname =~ s/\'/::/;
d940 1
a940 1
			$cond = $2 || '1';
d950 6
a955 2
			$dbline{$i} =~ s/^[^\0]*//;
			delete $dbline{$i} if $dbline{$i} eq '';
d993 1
a993 1
			    print OUT "All < actions cleared.\n";
d999 1
a999 1
				print OUT "No pre-prompt Perl actions.\n";
d1002 1
a1002 1
			    print OUT "Perl commands run before each prompt:\n";
d1004 1
a1004 1
				print "\t< -- $action\n";
d1012 1
a1012 1
			    print OUT "All > actions cleared.\n";
d1018 1
a1018 1
				print OUT "No post-prompt Perl actions.\n";
d1021 1
a1021 1
			    print OUT "Perl commands run after each prompt:\n";
d1023 1
a1023 1
				print "\t> -- $action\n";
d1031 1
a1031 1
			    print OUT "{{ is now a debugger command\n",
d1040 1
a1040 1
			    print OUT "All { actions cleared.\n";
d1046 1
a1046 1
				print OUT "No pre-prompt debugger actions.\n";
d1049 1
a1049 1
			    print OUT "Debugger commands run before each prompt:\n";
d1051 1
a1051 1
				print "\t{ -- $action\n";
d1056 1
a1056 1
			    print OUT "{ is now a debugger command\n",
d1439 1
a1439 1
	$exiting = 1 unless defined $cmd;
d1520 1
a1711 2
    local($.);
    #<IN>;
d1816 1
d1828 1
a1828 1
    print $OUT @@_;
d2174 2
a2175 2
B<x> I<expr>		Evals expression in array context, dumps the result.
B<m> I<expr>		Evals expression in array context, prints methods callable
d2270 1
a2270 1
  B<x>|B<m> I<expr>	Evals expr in array context, dumps the result or lists methods.
d2693 2
a2694 1
  $finished = $inhibit_exit;	# So that some keys may be disabled.
d2696 2
a2697 2
  $DB::single = !$exiting && !$runnonstop;
  DB::fake::at_exit() unless $exiting or $runnonstop;
@


1.3
log
@perl5.005_03 (stock)
@
text
@d5 1
a5 1
$VERSION = 1.0402;
a7 8
# Enhanced by ilya@@math.ohio-state.edu (Ilya Zakharevich)
# Latest version available: ftp://ftp.math.ohio-state.edu/pub/users/ilya/perl

# modified Perl debugger, to be run from Emacs in perldb-mode
# Ray Lischner (uunet!mntgfx!lisch) as of 5 Nov 1990
# Johan Vromans -- upgrade to 4.0 pl 10
# Ilya Zakharevich -- patches after 5.001 (and some before ;-)

d71 2
d83 9
d148 42
d227 2
a228 1
		  ImmediateStop bareStringify);
d246 1
d266 1
d276 8
a283 7
$rl = 1 unless defined $rl;
$warnLevel = 1 unless defined $warnLevel;
$dieLevel = 1 unless defined $dieLevel;
$signalLevel = 1 unless defined $signalLevel;
$pre = [] unless defined $pre;
$post = [] unless defined $post;
$pretype = [] unless defined $pretype;
d287 3
a289 1
&pager((defined($ENV{PAGER}) 
d294 1
d299 1
a299 1
if (-e "/dev/tty") {
d305 42
d348 7
a354 5
    do "./$rcfile";
} elsif (defined $ENV{LOGDIR} and -f "$ENV{LOGDIR}/$rcfile") {
    do "$ENV{LOGDIR}/$rcfile";
} elsif (defined $ENV{HOME} and -f "$ENV{HOME}/$rcfile") {
    do "$ENV{HOME}/$rcfile";
d361 2
d391 3
a393 3
  # Is Perl being run from Emacs?
  $emacs = ((defined $main::ARGV[0]) and ($main::ARGV[0] eq '-emacs'));
  $rl = 0, shift(@@main::ARGV) if $emacs;
d397 4
a400 1
  if (-e "/dev/tty") {
d408 1
a408 1
  if (($^O eq 'MSWin32') and ($emacs or defined $ENV{EMACS})) {
d413 5
a417 1
  if (defined $ENV{OS2_SHELL} and ($emacs or $ENV{WINDOWID})) { # In OS/2
d423 23
a445 8
  if (defined $console) {
    open(IN,"+<$console") || open(IN,"<$console") || open(IN,"<&STDIN");
    open(OUT,"+>$console") || open(OUT,">$console") || open(OUT,">&STDERR")
      || open(OUT,">&STDOUT");	# so we don't dongle stdout
  } else {
    open(IN,"<&STDIN");
    open(OUT,">&STDERR") || open(OUT,">&STDOUT"); # so we don't dongle stdout
    $console = 'STDIN/OUT';
a446 4
  # so open("|more") can read from STDOUT and so we don't dingle stdin
  $IN = \*IN;

  $OUT = \*OUT;
d459 2
a460 2
    print $OUT ("Emacs support ",
		$emacs ? "enabled" : "available",
d462 1
a462 1
    print $OUT "\nEnter h or `h h' for help.\n\n";
d535 1
a535 1
	if ($emacs) {
d546 1
a546 1
	  $usercontext = '($@@, $!, $,, $/, $\, $^W) = @@saved;' .
d590 1
a590 1
	@@typeahead = @@$pretype, @@typeahead;
d596 2
a597 1
				       " "))) {
d607 2
d610 10
a619 1
		    eval "\$cmd =~ $alias{$i}", print $OUT $@@ if $alias{$i};
d627 8
a634 4
		    $cmd =~ /^h\s+(\S)$/ && do {
			my $asked = "\Q$1";
			if ($help =~ /^(?:[IB]<)$asked/m) {
			  while ($help =~ /^((?:[IB]<)$asked([\s\S]*?)\n)(?!\s)/mg) {
d642 1
a642 1
			($trace & 1) ? ($trace &= ~1) : ($trace |= 1);
d667 5
a671 1
			    &main::dumpvar($packname,@@vars);
d713 9
a721 1
		    $cmd =~ /^l\b\s*([\':A-Za-z_][\':\w]*)/ && do {
d727 1
a727 1
			@@pieces = split(/:/,find_sub($subname));
d731 2
d780 1
a780 1
			if ($emacs) {
d816 4
a823 1
		      undef %had_breakpoints;
d834 1
a834 1
			        print "$file:\n" unless $was++;
d898 1
a898 1
			$had_breakpoints{$file} = 1;
d911 1
a911 1
		    $cmd =~ /^b\b\s*([':A-Za-z_][':\w]*)\s*(.*)/ && do {
d922 3
a924 3
			    $filename = $file;
			    *dbline = $main::{'_<' . $filename};
			    $had_breakpoints{$filename} = 1;
d933 1
a933 1
			$i = ($1?$1:$line);
d938 1
a938 1
			    $had_breakpoints{$filename} = 1;
d942 2
a943 2
		    $cmd =~ /^d\b\s*(\d+)?/ && do {
			$i = ($1?$1:$line);
d948 1
d961 4
d982 16
a997 1
		        $pre = [], next CMD unless $1;
d1001 16
a1016 1
		        $post = [], next CMD unless $1;
d1020 6
d1029 22
a1050 1
		        $pretype = [], next CMD unless $1;
d1053 10
a1062 4
		    $cmd =~ /^a\b\s*(\d+)(\s+(.*))?/ && do {
			$i = $1; $j = $3;
			if ($dbline[$i] == 0) {
			    print $OUT "Line $i may not have an action.\n";
d1065 1
a1065 1
			    $dbline{$i} .= "\0" . action($j);
d1081 4
d1093 1
a1093 1
				$had_breakpoints{$filename}++;
d1130 1
a1130 1
			    chomp ($cl =  $ {'::_<-e'}[$_]);
d1194 2
a1195 2
			#print "$^X, '-d', @@flags, @@script, ($emacs ? '-emacs' : ()), @@ARGS";
			exec $^X, '-d', @@flags, @@script, ($emacs ? '-emacs' : ()), @@ARGS;
d1217 3
d1235 1
a1235 1
				    if ($emacs) {
d1249 3
d1254 1
a1254 1
				print $OUT "$@@";
d1267 1
a1267 1
				    if ($emacs) {
d1279 1
a1279 1
			$i = $1 ? ($#hist-($2?$2:1)) : ($2?$2:$#hist);
d1281 1
a1281 1
			print $OUT $cmd;
d1297 1
a1297 1
			print $OUT $cmd;
d1303 2
d1308 1
a1308 1
			$end = $2?($#hist-$2):0;
d1315 3
d1320 27
a1346 9
		    $cmd =~ /^=/ && do {
			if (local($k,$v) = ($cmd =~ /^=\s*(\S+)\s+(.*)/)) {
			    $alias{$k}="s~$k~$v~";
			    print $OUT "$k = $v\n";
			} elsif ($cmd =~ /^=\s*$/) {
			    foreach $k (sort keys(%alias)) {
				if (($v = $alias{$k}) =~ s~^s\~$k\~(.*)\~$~$1~) {
				    print $OUT "$k = $v\n";
				} else {
d1348 5
a1352 3
				};
			    };
			};
d1361 1
d1365 2
a1366 1
				open(OUT,">&STDOUT") || &warn("Can't restore DB::OUT");
d1371 2
a1372 1
				open(OUT,">&STDOUT") || &warn("Can't restore DB::OUT");
d1377 1
a1377 1
			  && "" eq $SIG{PIPE}  ||  "DEFAULT" eq $SIG{PIPE};
d1382 2
a1383 1
			redo PIPE; };
d1398 18
a1415 5
		    $?= 0;  close(OUT) || &warn("Can't close DB::OUT");
		    &warn( "Pager `$pager' failed: ",
			  ($?>>8) > 128 ? ($?>>8)-256 : ($?>>8),
			  ( $? & 128 ) ? " (core dumped)" : "",
			  ( $? & 127 ) ? " (SIG ".($?&127).")" : "", "\n" ) if $?;
d1418 1
a1418 1
		    $SIG{PIPE}= "DEFAULT" if $SIG{PIPE} eq \&DB::catch;
d1503 3
a1505 1
    my @@res;
d1507 3
a1509 3
	my $otrace = $trace;
	my $osingle = $single;
	my $od = $^D;
d1538 1
a1538 1
      $had_breakpoints{$file}++;
d1566 1
a1566 1
  $had_breakpoints{$filename}++;
d1570 1
a1570 1
    $dbline{$key} = $ {$postponed_file{$filename}}{$key};
d1686 14
d1708 1
a1708 1
    # many non-Unix systems can do system() but have problems with fork().
d1713 2
d1718 14
a1731 5
    close(SAVEIN); close(SAVEOUT);
    &warn( "(Command returned ", ($?>>8) > 128 ? ($?>>8)-256 : ($?>>8), ")",
	  ( $? & 128 ) ? " (core dumped)" : "",
	  ( $? & 127 ) ? " (SIG ".($?&127).")" : "", "\n" ) if $?;
    $?;
d1748 1
a1748 1
	    eval "require Term::Rendezvous;" or die $@@;
d1817 9
a1825 1
  $term->readline(@@_);
d1839 2
a1840 2
	and defined $ {$optionVars{$opt}}) {
	$val = $ {$optionVars{$opt}};
d1847 1
a1847 1
	     and not defined $ {$optionVars{$opt}}) {
d1857 10
a1866 2
    while ($_ ne "") {
	s/^(\w+)(\s*$|\W)// or print($OUT "Invalid option `$_'\n"), last;
d1874 2
a1875 1
	    $val = "1";
d1877 6
a1882 1
	    s/^(\S*)($|\s+)//;
d1884 4
d1892 1
a1892 2
	    $val = $1;
	    $val =~ s/\\([\\$end])/$1/g;
d1894 35
a1928 20
	my ($option);
	my $matches =
	  grep(  /^\Q$opt/ && ($option = $_),  @@options  );
	$matches =  grep(  /^\Q$opt/i && ($option = $_),  @@options  )
	  unless $matches;
	print $OUT "Unknown option `$opt'\n" unless $matches;
	print $OUT "Ambiguous option `$opt'\n" if $matches > 1;
	$option{$option} = $val if $matches == 1 and defined $val;
	eval "local \$frame = 0; local \$doret = -2; 
	      require '$optionRequire{$option}'"
	  if $matches == 1 and defined $optionRequire{$option} and defined $val;
	$ {$optionVars{$option}} = $val 
	  if $matches == 1
	    and defined $optionVars{$option} and defined $val;
	& {$optionAction{$option}} ($val) 
	  if $matches == 1
	    and defined $optionAction{$option}
	      and defined &{$optionAction{$option}} and defined $val;
	&dump_option($option) if $matches == 1 && $OUT ne \*STDERR; # Not $rcfile
        s/^\s+//;
d1935 1
a1935 1
  $ENV{"$ {stem}_n"} = @@list;
d1940 1
a1940 1
    $ENV{"$ {stem}_$i"} = $val;
d1947 1
a1947 1
  my $n = delete $ENV{"$ {stem}_n"};
d1950 1
a1950 1
    $val = delete $ENV{"$ {stem}_$i"};
d2005 8
d2014 1
a2014 1
    if ($ {$term->Features}{tkRunning}) {
d2076 1
a2076 1
    $emacs = ($stream =~ /^\|/);
d2094 2
a2095 2
    if (defined $ { $_ . '::VERSION' }) {
      $version{$file} = "$ { $_ . '::VERSION' } from ";
d2103 4
d2119 1
d2124 7
a2130 1
B<f> I<filename>	Switch to viewing I<filename>. Must be loaded.
d2142 1
d2152 2
a2153 1
		Set an action to be done before the I<line> is executed.
d2156 2
a2157 1
		execute expression.
d2168 2
a2169 26
B<O> [I<opt>[B<=>I<val>]] [I<opt>B<\">I<val>B<\">] [I<opt>B<?>]...
		Set or query values of options.  I<val> defaults to 1.  I<opt> can
		be abbreviated.  Several options can be listed.
    I<recallCommand>, I<ShellBang>:	chars used to recall command or spawn shell;
    I<pager>:			program for output of \"|cmd\";
    I<tkRunning>:			run Tk while prompting (with ReadLine);
    I<signalLevel> I<warnLevel> I<dieLevel>:	level of verbosity;
    I<inhibit_exit>		Allows stepping off the end of the script.
    I<ImmediateStop>		Debugger should stop as early as possible.
  The following options affect what happens with B<V>, B<X>, and B<x> commands:
    I<arrayDepth>, I<hashDepth>:	print only first N elements ('' for all);
    I<compactDump>, I<veryCompact>:	change style of array and hash dump;
    I<globPrint>:			whether to print contents of globs;
    I<DumpDBFiles>:		dump arrays holding debugged files;
    I<DumpPackages>:		dump symbol tables of packages;
    I<DumpReused>:		dump contents of \"reused\" addresses;
    I<quote>, I<HighBit>, I<undefPrint>:	change style of string dump;
    I<bareStringify>:		Do not print the overload-stringified value;
  Option I<PrintRet> affects printing of return value after B<r> command,
         I<frame>    affects printing messages on entry and exit from subroutines.
         I<AutoTrace> affects printing messages on every possible breaking point.
	 I<maxTraceLen> gives maximal length of evals/args listed in stack trace.
	 I<ornaments> affects screen appearance of the command line.
		During startup options are initialized from \$ENV{PERLDB_OPTS}.
		You can put additional initialization options I<TTY>, I<noTTY>,
		I<ReadLine>, and I<NonStop> there (or use `B<R>' after you set them).
d2172 1
d2174 1
a2174 1
B<>>B<>> I<expr>	Add to the list of Perl commands to run after each prompt.
d2176 2
d2199 33
d2234 7
a2240 1
B<q> or B<^D>		Quit. Set B<\$DB::finished = 0> to debug global destruction.
a2241 1
";
d2247 1
a2247 1
  B<f> I<filename>  View source in file         <B<CR>>        Repeat last B<n> or B<s>
d2252 1
a2252 2
  B<<>[B<<>] or B<{>[B<{>] [I<cmd>]   Do before prompt   B<b> [I<ln>|I<event>] [I<cnd>]  Set breakpoint
  B<>>[B<>>] [I<cmd>]  Do after prompt             B<b> I<sub> [I<cnd>] Set breakpoint for sub
d2257 1
a2257 1
  B<|>[B<|>]I<dbcmd>   Send output to pager        B<$psh>\[B<$psh>\] I<syscmd> Run cmd in a subprocess
d2265 1
d2267 1
a2267 1
				# ')}}; # Fix balance of Emacs parsing
d2271 59
a2329 6
  my $message = shift;
  if (@@Term::ReadLine::TermCap::rl_term_set) {
    $message =~ s/B<([^>]+|>)>/$Term::ReadLine::TermCap::rl_term_set[2]$1$Term::ReadLine::TermCap::rl_term_set[3]/g;
    $message =~ s/I<([^>]+|>)>/$Term::ReadLine::TermCap::rl_term_set[0]$1$Term::ReadLine::TermCap::rl_term_set[1]/g;
  }
  print $OUT $message;
d2380 1
d2383 1
d2441 15
a2457 1
  return unless defined &$subr;
d2459 7
d2490 2
a2491 2
  for $name (grep {defined &{$ {"$ {class}::"}{$_}}} 
	     sort keys %{"$ {class}::"}) {
d2496 1
a2496 1
  for $name (@@{"$ {class}::ISA"}) {
d2502 63
d2602 1
a2602 1
    ($text, "^\Q$ {'package'}::\E([^:]+)\$");
@


1.2
log
@perl 5.004_04
@
text
@d5 1
a5 1
$VERSION = 1.01;
d176 1
a176 1
@@options     = qw(hashDepth arrayDepth DumpDBFiles DumpPackages 
d181 2
a182 1
		  signalLevel warnLevel dieLevel inhibit_exit);
d189 1
d194 1
d199 1
d238 5
a242 1
&pager(defined($ENV{PAGER}) ? $ENV{PAGER} : "|more") unless defined $pager;
d301 1
a301 1
  } elsif (-e "con" or $^O eq 'MSWin32') {
d368 1
a368 1
	for ($i=0; $i <= $#stack; ) {
d373 3
d382 1
a382 1
    $usercontext = '($@@, $!, $,, $/, $\, $^W) = @@saved;' .
d390 1
a390 1
	    $evalarg = "\$DB::signal |= do {$stop;}"; &eval;
d395 22
d418 1
a418 2
    if ($single || $trace || $was_signal) {
	$term || &setterm;
d422 10
d446 1
a446 1
		print $LINEINFO ' ' x $#stack, "$line:\t$dbline[$line]$after";
d457 1
a457 1
		    print $LINEINFO ' ' x $#stack, "$i:\t$dbline[$i]$after";
d470 1
a470 1
	print $OUT $#stack . " levels deep in subroutine calls!\n"
d494 1
a494 1
			print $OUT $help;
d497 1
a497 1
			print $OUT $summary;
d501 3
a503 3
			if ($help =~ /^$asked/m) {
			  while ($help =~ /^($asked([\s\S]*?)\n)(\Z|[^\s$asked])/mg) {
			    print $OUT $1;
d506 1
a506 1
			    print $OUT "`$asked' is not a debugger command.\n";
d510 3
a512 2
			$trace = !$trace;
			print $OUT "Trace = ".($trace?"on":"off")."\n";
d647 1
a647 1
				last if $signal;
d649 1
d733 8
d887 1
a887 1
			for ($i=0; $i <= $#stack; ) {
d893 2
a894 2
			$stack[$#stack] |= 1;
			$doret = $option{PrintRet} ? $#stack - 1 : -2;
d980 12
d1053 1
a1053 1
			$cmd = $hist[$i] . "\n";
d1069 1
a1069 1
			$cmd = $hist[$i] . "\n";
d1129 1
a1129 1
		    $cmd =~ s/^t\s/\$DB::trace = 1;\n/;
d1165 1
a1165 1
    ($@@, $!, $,, $/, $\, $^W) = @@saved;
d1177 3
a1179 1
    push(@@stack, $single);
d1181 1
a1181 1
    $single |= 4 if $#stack == $deep;
d1183 1
a1183 1
     ? ( (print $LINEINFO ' ' x ($#stack - 1), "in  "), 
d1186 1
a1186 1
     : print $LINEINFO ' ' x ($#stack - 1), "entering $sub$al\n") if $frame;
d1189 1
a1189 1
	$single |= pop(@@stack);
d1191 1
a1191 1
	 ? ( (print $LINEINFO ' ' x $#stack, "out "), 
d1193 8
a1200 4
	 : print $LINEINFO ' ' x $#stack, "exited $sub$al\n") if $frame & 2;
	print ($OUT ($frame & 16 ? ' ' x $#stack : ""),
		    "list context return from $sub:\n"), dumpit( \@@ret ),
	  $doret = -2 if $doret eq $#stack or $frame & 16;
d1208 1
a1208 1
	$single |= pop(@@stack);
d1210 1
a1210 1
	 ? ( (print $LINEINFO ' ' x $#stack, "out "), 
d1212 10
a1221 4
	 : print $LINEINFO ' ' x $#stack, "exited $sub$al\n") if $frame & 2;
	print ($OUT ($frame & 16 ? ' ' x $#stack : ""),
		    "scalar context return from $sub: "), dumpit( $ret ),
	  $doret = -2 if $doret eq $#stack or $frame & 16;
d1227 1
a1227 1
    @@saved = ($@@, $!, $,, $/, $\, $^W);
a1235 1
	local (@@stack) = @@stack; # guard against recursive debugging
d1246 1
a1246 1
    eval "&DB::save";
d1250 1
a1250 1
	dumpit(\@@res);
d1254 1
d1281 4
d1293 1
a1293 1
  print $LINEINFO ' ' x $#stack, "Package $filename.\n" if $frame;
d1305 1
a1305 1
    local ($savout) = select($OUT);
d1386 1
a1386 1
    $context = $context ? '@@' : "\$";
d1425 1
a1425 1
    open(SAVEOUT,">&OUT") || &warn("Can't save STDOUT");
a1440 1
    local @@stack = @@stack;		# Prevent growth by failing `use'.
d1499 8
a1506 2
      print $OUT "Forked, but do not know how to change a TTY.\n",
          "Define \$DB::fork_TTY or get_fork_TTY().\n";
d1755 1
a1755 7
  do 'dumpvar.pl' unless defined &main::dumpValue;
  if (defined &main::dumpValue) {
    local $frame = 0;
    &main::dumpValue(\%version);
  } else {
    print $OUT "dumpvar.pl not available.\n";
  }
d1760 6
a1765 6
T		Stack trace.
s [expr]	Single step [in expr].
n [expr]	Next, steps over subroutine calls [in expr].
<CR>		Repeat last n or s command.
r		Return from current subroutine.
c [line|sub]	Continue; optionally inserts a one-time-only breakpoint
d1767 19
a1785 19
l min+incr	List incr+1 lines starting at min.
l min-max	List lines min through max.
l line		List single line.
l subname	List first window of lines from subroutine.
l		List next window of lines.
-		List previous window of lines.
w [line]	List window around line.
.		Return to the executed line.
f filename	Switch to viewing filename. Must be loaded.
/pattern/	Search forwards for pattern; final / is optional.
?pattern?	Search backwards for pattern; final ? is optional.
L		List all breakpoints and actions.
S [[!]pattern]	List subroutine names [not] matching pattern.
t		Toggle trace mode.
t expr		Trace through execution of expr.
b [line] [condition]
		Set breakpoint; line defaults to the current execution line;
		condition breaks if it evaluates to true, defaults to '1'.
b subname [condition]
d1787 2
a1788 2
b load filename Set breakpoint on `require'ing the given file.
b postpone subname [condition]
d1791 1
a1791 1
b compile subname
d1793 15
a1807 12
d [line]	Delete the breakpoint for line.
D		Delete all breakpoints.
a [line] command
		Set an action to be done before the line is executed.
		Sequence is: check for breakpoint, print line if necessary,
		do action, prompt user if breakpoint or step, evaluate line.
A		Delete all actions.
V [pkg [vars]]	List some (default all) variables in package (default current).
		Use ~pattern and !pattern for positive and negative regexps.
X [vars]	Same as \"V currentpackage [vars]\".
x expr		Evals expression in array context, dumps the result.
m expr		Evals expression in array context, prints methods callable
d1809 3
a1811 3
m class		Prints methods callable via the given class.
O [opt[=val]] [opt\"val\"] [opt?]...
		Set or query values of options.  val defaults to 1.  opt can
d1813 20
a1832 17
    recallCommand, ShellBang:	chars used to recall command or spawn shell;
    pager:			program for output of \"|cmd\";
    tkRunning:			run Tk while prompting (with ReadLine);
    signalLevel warnLevel dieLevel:	level of verbosity;
    inhibit_exit		Allows stepping off the end of the script.
  The following options affect what happens with V, X, and x commands:
    arrayDepth, hashDepth:	print only first N elements ('' for all);
    compactDump, veryCompact:	change style of array and hash dump;
    globPrint:			whether to print contents of globs;
    DumpDBFiles:		dump arrays holding debugged files;
    DumpPackages:		dump symbol tables of packages;
    quote, HighBit, undefPrint:	change style of string dump;
  Option PrintRet affects printing of return value after r command,
         frame    affects printing messages on entry and exit from subroutines.
         AutoTrace affects printing messages on every possible breaking point.
	 maxTraceLen gives maximal length of evals/args listed in stack trace.
	 ornaments affects screen appearance of the command line.
d1834 13
a1846 13
		You can put additional initialization options TTY, noTTY,
		ReadLine, and NonStop there (or use `R' after you set them).
< command	Define Perl command to run before each prompt.
<< command	Add to the list of Perl commands to run before each prompt.
> command	Define Perl command to run after each prompt.
>> command	Add to the list of Perl commands to run after each prompt.
\{ commandline	Define debugger command to run before each prompt.
\{{ commandline	Add to the list of debugger commands to run before each prompt.
$prc number	Redo a previous command (default previous command).
$prc -number	Redo number'th-to-last command.
$prc pattern	Redo last command that started with pattern.
		See 'O recallCommand' too.
$psh$psh cmd  	Run cmd in a subprocess (reads from DB::IN, writes to DB::OUT)"
d1848 10
a1857 10
$psh [cmd] 	Run cmd in subshell (forces \"\$SHELL -c 'cmd'\")." ) . "
		See 'O shellBang' too.
H -number	Display last number commands (default all).
p expr		Same as \"print {DB::OUT} expr\" in current package.
|dbcmd		Run debugger command, piping DB::OUT to current pager.
||dbcmd		Same as |dbcmd but DB::OUT is temporarilly select()ed as well.
\= [alias value]	Define a command alias, or list current aliases.
command		Execute as a perl statement in current package.
v		Show versions of loaded modules.
R		Pure-man-restart of debugger, some of debugger state
d1860 5
a1864 5
		history, breakpoints and actions, debugger Options 
		and the following command-line options: -w, -I, -e.
h [db_command]	Get help [on a specific debugger command], enter |h to page.
h h		Summary of debugger commands.
q or ^D		Quit. Set \$DB::finished to 0 to debug global destruction.
d1868 23
a1890 23
List/search source lines:               Control script execution:
  l [ln|sub]  List source code            T           Stack trace
  - or .      List previous/current line  s [expr]    Single step [in expr]
  w [line]    List around line            n [expr]    Next, steps over subs
  f filename  View source in file         <CR>        Repeat last n or s
  /pattern/ ?patt?   Search forw/backw    r           Return from subroutine
  v	      Show versions of modules    c [ln|sub]  Continue until position
Debugger controls:                        L           List break pts & actions
  O [...]     Set debugger options        t [expr]    Toggle trace [trace expr]
  <[<] or {[{] [cmd]   Do before prompt   b [ln/event] [c]     Set breakpoint
  >[>] [cmd]  Do after prompt             b sub [c]   Set breakpoint for sub
  $prc [N|pat]   Redo a previous command     d [line]    Delete a breakpoint
  H [-num]    Display last num commands   D           Delete all breakpoints
  = [a val]   Define/list an alias        a [ln] cmd  Do cmd before line
  h [db_cmd]  Get help on command         A           Delete all actions
  |[|]dbcmd   Send output to pager        $psh\[$psh\] syscmd Run cmd in a subprocess
  q or ^D     Quit			  R	      Attempt a restart
Data Examination:	      expr     Execute perl code, also see: s,n,t expr
  x|m expr	Evals expr in array context, dumps the result or lists methods.
  p expr	Print expression (uses script's current package).
  S [[!]pat]	List subroutine names [not] matching pattern
  V [Pk [Vars]]	List Variables in Package.  Vars can be ~pattern or !pattern.
  X [Vars]	Same as \"V current_package [Vars]\".
d1895 9
d2075 1
@


1.1
log
@Initial revision
@
text
@d5 2
a6 1
$header = 'perl5db.pl patch level 0.94';
d20 2
a21 2
# Perl supplies the values for @@line and %sub.  It effectively inserts
# a &DB'DB(<linenum>); in front of every place that can have a
d26 21
d48 1
a48 1
# (for subroutines defined outside this file). In fact the same is
d88 59
a159 1
      $readline::Tk_toloop,    
d164 1
a164 1
      $first_time,
d174 1
a174 3
@@stack = (0);

$option{PrintRet} = 1;
d178 4
a181 4
		  globPrint PrintRet UsageOnly frame
		  TTY noTTY ReadLine NonStop LineInfo
		  recallCommand ShellBang pager tkRunning
		  signalLevel warnLevel dieLevel);
a190 1
		 tkRunning	=> \$readline::Tk_toloop,
d192 4
a195 1
		  frame           => \$frame,
d213 2
d225 6
d237 1
d261 6
a266 3
  my @@visited = get_list("PERLDB_VISITED");
  for (0 .. $#visited) {
    %{$postponed{$visited[$_]}} = get_list("PERLDB_FILE_$_");
d276 4
d293 1
a293 1
  } elsif (-e "con") {
d299 4
d304 1
a304 1
  if (defined $ENV{OS2_SHELL} and $emacs) { # In OS/2
d352 2
d357 3
a359 2
    unless ($first_time++) {	# Do when-running init
      if ($runnonstop) {		# Disable until signal
d364 1
a364 1
	return;
a365 8
      # Define a subroutine in which we will stop
#       eval <<'EOE';
# sub at_end::db {"Debuggee terminating";}
# END {
#   $DB::step = 1; 
#   print $OUT "Debuggee terminating.\n"; 
#   &at_end::db;}
# EOE
d367 1
a368 8
    if ($doret) {
	$doret = 0;
	if ($option{PrintRet}) {
	    print $OUT "$retctx context return from $lastsub:", 
	      ($retctx eq 'list') ? "\n" : " " ;
	    dumpit( ($retctx eq 'list') ? \@@ret : $ret );
	}
    }
d373 1
a373 2
    local(*dbline) = "::_<$filename";
    install_breakpoints($filename) unless $visited{$filename}++;
d383 3
a385 1
    if ($single || $trace || $signal) {
a396 1
		print $LINEINFO $position;
d402 4
d410 1
a412 1
		print $LINEINFO $incr_pos;
d414 5
d423 1
a423 1
    if ($single || $signal) {
d425 3
a427 1
	$evalarg = $pre, &eval if $pre;
d431 2
d435 1
a438 1
	    #{			# <-- Do we know what this brace is for?
a444 1
		$cmd =~ /^q$/ && exit 0;
d450 1
d459 2
a460 1
			if ($help =~ /^($asked([\s\S]*?)\n)(\Z|[^\s$asked])/m) {
d462 1
d479 2
d491 1
d499 5
a503 1
			$onetimeDump = 1; };
d506 1
d514 3
a516 2
					      $file = substr($try,2);
					      print "\n$file:\n";
d520 1
a520 1
			    print $OUT "There's no code here matching $file.\n";
d523 1
a523 2
			    *dbline = "::_<$file";
			    $visited{$file}++;
d528 6
a533 1
			} };
d537 2
a538 1
			$subname = "main::".$subname unless $subname =~ /::/;
d540 1
a540 1
			@@pieces = split(/:/,$sub{$subname});
d544 1
a544 2
			    *dbline = "::_<$file";
			    $visited{$file}++;
d558 1
d561 1
a561 1
			*dbline = "::_<$filename";
d572 2
d575 1
a575 1
			$cmd = 'l ' . ($start-$window*2) . '+'; };
d590 1
d600 1
a600 1
				    : ':' ;
d611 7
a617 1
			print $OUT "Deleting all breakpoints...\n";
d626 6
a631 1
			next CMD; };
d633 6
d641 2
a642 1
				print $OUT "$i:\t", $dbline[$i];
d644 1
a644 1
				print $OUT "  break if (", $stop, ")\n"
d646 1
a646 1
				print $OUT "  action:  ", $action, "\n"
d651 58
d718 1
a718 1
			($file,$i) = ($sub{$subname} =~ /^(.*):(.*)$/);
d722 2
a723 2
			    *dbline = "::_<$filename";
			    $visited{$filename}++;
d737 1
d747 6
d759 2
a760 1
			next CMD; };
d769 6
d776 2
a777 1
			$pre = action($1);
d780 9
a788 1
			$post = action($1);
d800 1
d805 1
d810 2
a811 1
			$i = $1;
d813 3
a815 1
			    ($file,$i) = ($sub{$i} =~ /^(.*):(.*)$/);
d819 2
a820 2
				*dbline = "::_<$filename";
				$visited{$filename}++;
d840 1
d842 1
a842 1
			$doret = 1;
d845 1
a845 1
		        print $OUT "Warning: a lot of settings and command-line options may be lost!\n";
d866 2
a867 2
			my @@visited = keys %visited;
			set_list("PERLDB_VISITED", @@visited);
d869 45
a913 3
			for (0 .. $#visited) {
			  *dbline = "::_<$visited[$_]";
			  set_list("PERLDB_FILE_$_", %dbline);
d915 5
d926 1
a926 33
			local($p,$f,$l,$s,$h,$a,$e,$r,@@a,@@sub);
			for ($i = 1; 
			     ($p,$f,$l,$s,$h,$w,$e,$r) = caller($i); 
			     $i++) {
			    @@a = ();
			    for $arg (@@args) {
				$_ = "$arg";
				s/([\'\\])/\\$1/g;
				s/([^\0]*)/'$1'/
				  unless /^(?: -?[\d.]+ | \*[\w:]* )$/x;
				s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;
				s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
				push(@@a, $_);
			    }
			    $w = $w ? '@@ = ' : '$ = ';
			    $a = $h ? '(' . join(', ', @@a) . ')' : '';
			    $e =~ s/\n\s*\;\s*\Z// if $e;
			    $e =~ s/[\\\']/\\$1/g if $e;
			    if ($r) {
			      $s = "require '$e'";
			    } elsif (defined $r) {
			      $s = "eval '$e'";
			    } elsif ($s eq '(eval)') {
			      $s = "eval {...}";
			    }
			    $f = "file `$f'" unless $f eq '-e';
			    push(@@sub, "$w$s$a called from $f line $l\n");
			    last if $signal;
			}
			for ($i=0; $i <= $#sub; $i++) {
			    last if $signal;
			    print $OUT $sub[$i];
			}
d940 1
d969 1
d992 2
a993 2
		    $cmd =~ /^$sh$sh\s*/ && do {
			&system($');
d1011 2
a1012 2
		    $cmd =~ /^$sh\s*/ && do {
			&system($ENV{SHELL}||"/bin/sh","-c",$');
d1022 2
a1023 2
		    $cmd =~ s/^p$/print \$DB::OUT \$_/;
		    $cmd =~ s/^p\b/print \$DB::OUT /;
d1057 1
a1057 1
			$SIG{PIPE}= "DB::catch" if $pager =~ /^\|/
a1068 1
	    #}			# <-- Do we know what this brace is for?
d1072 1
a1072 1
	    } else {
d1085 1
a1085 1
		    $SIG{PIPE}= "DEFAULT" if $SIG{PIPE} eq "DB::catch";
d1096 3
a1098 2
	if ($post) {
	    $evalarg = $post; &eval;
d1109 4
a1112 1
    print $LINEINFO ' ' x $#stack, "entering $sub\n" if $frame;
d1116 5
d1124 7
a1130 3
	$retctx = "list";
	$lastsub = $sub;
print $LINEINFO ' ' x $#stack, "exited $sub\n" if $frame;
d1133 5
a1137 1
	$ret = &$sub;
d1139 7
a1145 3
	$retctx = "scalar";
	$lastsub = $sub;
print $LINEINFO ' ' x $#stack, "exited $sub\n" if $frame;
d1170 1
d1174 1
a1174 1
    } elsif ($onetimeDump) {
d1176 2
d1181 18
a1198 9
sub install_breakpoints {
  my $filename = shift;
  return unless exists $postponed{$filename};
  my %break = %{$postponed{$filename}};
  for (keys %break) {
    my $i = $_;
    #if (/\D/) {			# Subroutine name
    #} 
    $dbline{$i} = $break{$_};	# Cannot be done before the file is around
d1200 22
d1226 8
a1233 1
    do 'dumpvar.pl' unless defined &main::dumpValue;
a1234 1
        local $frame = 0;
d1239 2
d1244 81
d1360 3
a1362 1
    eval "require Term::ReadLine;" or die $@@;
d1385 7
a1391 3
	$readline::rl_basic_word_break_characters .= "[:" 
	  if defined $readline::rl_basic_word_break_characters 
	    and index($readline::rl_basic_word_break_characters, ":") == -1;
d1399 24
d1435 1
d1441 8
d1459 1
a1459 1
	$val = 'N/A';
d1463 1
a1463 2
    $val =~ s/[\\\']/\\$&/g;
    printf $OUT "%20s = '%s'\n", $opt, $val;
d1496 2
a1497 1
	eval "local \$frame = 0; require '$optionRequire{$option}'"
d1518 1
a1518 1
    $val =~ s/[\0-\37\177\200-\377]/"\\0x" . unpack('H2',$&)/eg;
d1538 1
d1548 17
a1564 5
    if ($term) {
	&warn("Too late to set TTY!\n") if @@_;
    } else {
	$tty = shift if @@_;
    }
d1570 1
a1570 3
	&warn("Too late to set noTTY!\n") if @@_;
    } else {
	$notty = shift if @@_;
d1572 1
d1578 9
a1586 1
	&warn("Too late to set ReadLine!\n") if @@_;
d1588 2
a1589 1
	$rl = shift if @@_;
a1590 1
    $rl;
d1595 1
a1595 3
	&warn("Too late to set up NonStop mode!\n") if @@_;
    } else {
	$runnonstop = shift if @@_;
d1597 1
d1621 10
d1656 23
d1686 2
a1687 2
c [line]	Continue; optionally inserts a one-time-only breakpoint
		at the specified line.
d1696 1
a1696 1
f filename	Switch to viewing filename.
d1699 1
a1699 1
L		List all breakpoints and actions for the current file.
d1708 6
d1725 3
d1733 3
a1742 2
    tkRunning:			run Tk while prompting (with ReadLine);
    signalLevel warnLevel dieLevel:	level of verbosity;
d1745 3
d1750 7
a1756 3
		ReadLine, and NonStop there.
< command	Define command to run before each prompt.
> command	Define command to run after each prompt.
d1766 1
a1766 1
p expr		Same as \"print DB::OUT expr\" in current package.
d1771 6
a1776 2
R		Pure-man-restart of debugger, debugger state and command-line
		options are lost.
d1779 1
a1779 1
q or ^D		Quit.
d1788 2
a1789 2
  /pattern/   Search forward              r           Return from subroutine
  ?pattern?   Search backward             c [line]    Continue until line
d1792 2
a1793 2
  < command   Command for before prompt   b [ln] [c]  Set breakpoint
  > command   Command for after prompt    b sub [c]   Set breakpoint for sub
d1801 2
a1805 2
  x expr	Evals expression in array context, dumps the result.
  p expr	Print expression (uses script's current package).
d1807 1
a1807 1
				# '); # Fix balance of Emacs parsing
d1812 2
a1813 1
    $SIG{'ABRT'} = DEFAULT;
d1815 8
a1822 5
    print $DB::OUT "Got $_[0]!\n";	# in the case cannot continue
    local $SIG{__WARN__} = '';
    require Carp; 
    local $Carp::CarpLevel = 2;		# mydie + confess
    &warn(Carp::longmess("Signal @@_"));
d1828 1
d1830 5
a1834 2
  require Carp; 
  #&warn("Entering dbwarn\n");
a1838 1
  #&warn("Warning in dbwarn\n");
a1839 1
  #&warn("Exiting dbwarn\n");
d1844 1
d1848 1
a1848 6
  #&warn("Entering dbdie\n");
  if ($dieLevel != 2) {
    while ((undef,undef,undef,$sub) = caller(++$i)) {
      $ineval = 1, last if $sub eq '(eval)';
    }
    {
d1850 5
a1854 4
      &warn(@@_) if $dieLevel > 2; # Ineval is false during destruction?
    }
    #&warn("dieing quietly in dbdie\n") if $ineval and $dieLevel < 2;
    die @@_ if $ineval and $dieLevel < 2;
d1856 4
a1859 1
  require Carp; 
a1865 1
  #&warn("dieing loudly in dbdie\n");
d1874 1
a1874 1
      $SIG{__WARN__} = 'DB::dbwarn';
d1887 2
a1888 2
      $SIG{__DIE__} = 'DB::dbdie'; # if $dieLevel < 2;
      #$SIG{__DIE__} = 'DB::diehard' if $dieLevel >= 2;
d1890 2
a1891 1
        ( $dieLevel == 1 ? " outside of evals" : ""), ".\n";
d1907 2
a1908 2
      $SIG{SEGV} = 'DB::diesignal';
      $SIG{BUS} = 'DB::diesignal';
d1917 40
d1969 5
a1973 10
  #$SIG{__WARN__} = "DB::dbwarn";
  #$SIG{__DIE__} = 'DB::dbdie';
  #$SIG{SEGV} = "DB::diesignal";
  #$SIG{BUS} = "DB::diesignal";
  $SIG{INT} = "DB::catch";
  #$SIG{FPE} = "DB::catch";
  #warn "SIGFPE installed";
  $warnLevel = 1 unless defined $warnLevel;
  $dieLevel = 1 unless defined $dieLevel;
  $signalLevel = 1 unless defined $signalLevel;
d1978 5
d1988 99
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d5 1
a5 2
$VERSION = 1.0402;
$header = "perl5db.pl version $VERSION";
d19 2
a20 2
# Perl supplies the values for %sub.  It effectively inserts
# a &DB'DB(); in front of every place that can have a
a24 21
# After each `require'd file is compiled, but before it is executed, a
# call to DB::postponed($main::{'_<'.$filename}) is emulated. Here the
# $filename is the expanded name of the `require'd file (as found as
# value of %INC).
#
# Additional services from Perl interpreter:
#
# if caller() is called from the package DB, it provides some
# additional data.
#
# The array @@{$main::{'_<'.$filename} is the line-by-line contents of
# $filename.
#
# The hash %{'_<'.$filename} contains breakpoints and action (it is
# keyed by line number), and individual entries are settable (as
# opposed to the whole hash). Only true/false is important to the
# interpreter, though the values used by perl5db.pl have the form
# "$break_condition\0$action". Values are magical in numeric context.
#
# The scalar ${'_<'.$filename} contains "_<$filename".
#
d26 1
a26 1
# (for subroutines defined outside of the package DB). In fact the same is
a65 59
##################################################################
# Changelog:

# A lot of things changed after 0.94. First of all, core now informs
# debugger about entry into XSUBs, overloaded operators, tied operations,
# BEGIN and END. Handy with `O f=2'.

# This can make debugger a little bit too verbose, please be patient
# and report your problems promptly.

# Now the option frame has 3 values: 0,1,2.

# Note that if DESTROY returns a reference to the object (or object),
# the deletion of data may be postponed until the next function call,
# due to the need to examine the return value.

# Changes: 0.95: `v' command shows versions.
# Changes: 0.96: `v' command shows version of readline.
#	primitive completion works (dynamic variables, subs for `b' and `l',
#		options). Can `p %var'
#	Better help (`h <' now works). New commands <<, >>, {, {{.
#	{dump|print}_trace() coded (to be able to do it from <<cmd).
#	`c sub' documented.
#	At last enough magic combined to stop after the end of debuggee.
#	!! should work now (thanks to Emacs bracket matching an extra
#	`]' in a regexp is caught).
#	`L', `D' and `A' span files now (as documented).
#	Breakpoints in `require'd code are possible (used in `R').
#	Some additional words on internal work of debugger.
#	`b load filename' implemented.
#	`b postpone subr' implemented.
#	now only `q' exits debugger (overwriteable on $inhibit_exit).
#	When restarting debugger breakpoints/actions persist.
#     Buglet: When restarting debugger only one breakpoint/action per 
#		autoloaded function persists.
# Changes: 0.97: NonStop will not stop in at_exit().
#	Option AutoTrace implemented.
#	Trace printed differently if frames are printed too.
#	new `inhibitExit' option.
#	printing of a very long statement interruptible.
# Changes: 0.98: New command `m' for printing possible methods
#	'l -' is a synonim for `-'.
#	Cosmetic bugs in printing stack trace.
#	`frame' & 8 to print "expanded args" in stack trace.
#	Can list/break in imported subs.
#	new `maxTraceLen' option.
#	frame & 4 and frame & 8 granted.
#	new command `m'
#	nonstoppable lines do not have `:' near the line number.
#	`b compile subname' implemented.
#	Will not use $` any more.
#	`-' behaves sane now.
# Changes: 0.99: Completion for `f', `m'.
#	`m' will remove duplicate names instead of duplicate functions.
#	`b load' strips trailing whitespace.
#	completion ignores leading `|'; takes into account current package
#	when completing a subroutine name (same for `l').

####################################################################
d79 1
d84 1
a84 1
      $second_time,
d94 3
a96 1
$inhibit_exit = $option{PrintRet} = 1;
d98 1
a98 1
@@options     = qw(hashDepth arrayDepth DumpDBFiles DumpPackages DumpReused
d100 4
a103 5
		  globPrint PrintRet UsageOnly frame AutoTrace
		  TTY noTTY ReadLine NonStop LineInfo maxTraceLen
		  recallCommand ShellBang pager tkRunning ornaments
		  signalLevel warnLevel dieLevel inhibit_exit
		  ImmediateStop bareStringify);
a109 1
		 DumpReused	=> \$dumpvar::dumpReused,
d113 1
d115 1
a115 6
		 bareStringify	=> \$dumpvar::bareStringify,
		 frame          => \$frame,
		 AutoTrace      => \$trace,
		 inhibit_exit   => \$inhibit_exit,
		 maxTraceLen	=> \$maxtrace,
		 ImmediateStop	=> \$ImmediateStop,
a132 2
		  tkRunning	=> \&tkRunning,
		  ornaments	=> \&ornaments,
a142 6
$warnLevel = 1 unless defined $warnLevel;
$dieLevel = 1 unless defined $dieLevel;
$signalLevel = 1 unless defined $signalLevel;
$pre = [] unless defined $pre;
$post = [] unless defined $post;
$pretype = [] unless defined $pretype;
d146 1
a146 5
&pager((defined($ENV{PAGER}) 
	? $ENV{PAGER}
	: ($^O eq 'os2' 
	   ? 'cmd /c more' 
	   : 'more'))) unless defined $pager;
a148 1
$maxtrace = 400 unless defined $maxtrace;
d172 3
a174 6
  %break_on_load = get_list("PERLDB_ON_LOAD");
  %postponed = get_list("PERLDB_POSTPONE");
  my @@had_breakpoints= get_list("PERLDB_VISITED");
  for (0 .. $#had_breakpoints) {
    my %pf = get_list("PERLDB_FILE_$_");
    $postponed_file{$had_breakpoints[$_]} = \%pf if %pf;
a183 4
  $pretype = [get_list("PERLDB_PRETYPE")];
  $pre = [get_list("PERLDB_PRE")];
  $post = [get_list("PERLDB_POST")];
  @@typeahead = get_list("PERLDB_TYPEAHEAD", @@typeahead);
d197 1
a197 1
  } elsif ($^O eq 'dos' or -e "con" or $^O eq 'MSWin32') {
a202 4
  if (($^O eq 'MSWin32') and ($emacs or defined $ENV{EMACS})) {
    $console = undef;
  }

d204 1
a204 1
  if (defined $ENV{OS2_SHELL} and ($emacs or $ENV{WINDOWID})) { # In OS/2
a251 2
$I_m_init = 1;

d255 3
a257 4
    # _After_ the perl program is compiled, $single is set to 1:
    if ($single and not $second_time++) {
      if ($runnonstop) {	# Disable until signal
	for ($i=0; $i <= $stack_depth; ) {
d261 1
a261 4
	# return;			# Would not print trace!
      } elsif ($ImmediateStop) {
	$ImmediateStop = 0;
	$signal = 1;
d263 8
a271 1
    $runnonstop = 0 if $single or $signal; # Disable it if interactive.
d273 8
d283 1
a283 1
    $usercontext = '($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;' .
d285 2
a286 1
    local(*dbline) = $main::{'_<' . $filename};
d292 1
a292 1
	    $evalarg = "\$DB::signal |= 1 if do {$stop}"; &eval;
d296 2
a297 25
    my $was_signal = $signal;
    if ($trace & 2) {
      for (my $n = 0; $n <= $#to_watch; $n++) {
	$evalarg = $to_watch[$n];
	local $onetimeDump;	# Do not output results
	my ($val) = &eval;	# Fix context (&eval is doing array)?
	$val = ( (defined $val) ? "'$val'" : 'undef' );
	if ($val ne $old_watch[$n]) {
	  $signal = 1;
	  print $OUT <<EOP;
Watchpoint $n:\t$to_watch[$n] changed:
    old value:\t$old_watch[$n]
    new value:\t$val
EOP
	  $old_watch[$n] = $val;
	}
      }
    }
    if ($trace & 4) {		# User-installed watch
      return if watchfunction($package, $filename, $line) 
	and not $single and not $was_signal and not ($trace & ~4);
    }
    $was_signal = $signal;
    $signal = 0;
    if ($single || ($trace & 1) || $was_signal) {
a300 10
	} elsif ($package eq 'DB::fake') {
	  $term || &setterm;
	  print_help(<<EOP);
Debugged program terminated.  Use B<q> to quit or B<R> to restart,
  use B<O> I<inhibit_exit> to avoid stopping after program termination,
  B<h q>, B<h R> or B<h O> to get additional info.  
EOP
	  $package = 'main';
	  $usercontext = '($@@, $!, $,, $/, $\, $^W) = @@saved;' .
	    "package $package;";	# this won't let them modify, alas
d308 1
a313 4
	    }
	    if ($frame) {
		print $LINEINFO ' ' x $stack_depth, "$line:\t$dbline[$line]$after";
	    } else {
a317 1
		last if $signal;
d320 1
a321 5
		if ($frame) {
		    print $LINEINFO ' ' x $stack_depth, "$i:\t$dbline[$i]$after";
		} else {
		    print $LINEINFO $incr_pos;
		}
d326 1
a326 1
    if ($single || $was_signal) {
d328 2
a329 4
	foreach $evalarg (@@$pre) {
	  &eval;
	}
	print $OUT $stack_depth . " levels deep in subroutine calls!\n"
a331 2
	$incr = -1;		# for backward motion.
	@@typeahead = @@$pretype, @@typeahead;
a333 1
	       ($term_pid == $$ or &resetterm),
d337 1
d344 1
a349 1
		    $cmd =~ /^q$/ && ($exiting = 1) && exit 0;
d351 1
a351 1
			print_help($help);
d354 1
a354 1
			print_help($summary);
d358 2
a359 4
			if ($help =~ /^(?:[IB]<)$asked/m) {
			  while ($help =~ /^((?:[IB]<)$asked([\s\S]*?)\n)(?!\s)/mg) {
			    print_help($1);
			  }
d361 1
a361 1
			    print_help("B<$asked> is not a debugger command.\n");
d365 2
a366 3
			($trace & 1) ? ($trace &= ~1) : ($trace |= 1);
			print $OUT "Trace = " .
			    (($trace & 1) ? "on" : "off" ) . "\n";
a375 2
		    $cmd =~ /^v$/ && do {
			list_versions(); next CMD};
a385 1
			    local $doret = -2;
d393 1
a393 5
			$onetimeDump = 'dump'; };
		    $cmd =~ s/^m\s+([\w:]+)\s*$/ / && do {
			methods($1); next CMD};
		    $cmd =~ s/^m\b/ / && do { # So this will be evaled
			$onetimeDump = 'methods'; };
a395 1
			$file =~ s/\s+$//;
d403 2
a404 3
					      $try = substr($try,2);
					      print $OUT "Choosing $try matching `$file':\n";
					      $file = $try;
d408 1
a408 1
			    print $OUT "No file matching `$file' is loaded.\n";
d411 2
a412 1
			    *dbline = $main::{'_<' . $file};
d417 1
a417 6
			  } else {
			    print $OUT "Already in $file.\n";
			    next CMD;
			  }
		      };
		    $cmd =~ s/^l\s+-\s*$/-/;
d421 1
a421 2
			$subname = $package."::".$subname 
			  unless $subname =~ /::/;
d423 1
a423 1
			@@pieces = split(/:/,find_sub($subname));
d427 2
a428 1
			    *dbline = $main::{'_<' . $file};
a441 1
			$incr = -1;		# for backward motion.
d444 1
a444 1
			*dbline = $main::{'_<' . $filename};
a454 2
			$start -= $incr + $window + 1;
			$start = 1 if $start <= 0;
d456 1
a456 1
			$cmd = 'l ' . ($start) . '+'; };
a470 1
			$incr = $end - $i;
d480 1
a480 1
				    : ($dbline[$i]+0 ? ':' : ' ') ;
d484 1
a484 1
				$i++, last if $signal;
a485 1
			    print $OUT "\n" unless $dbline[$i-1] =~ /\n$/;
d491 1
a491 7
		      print $OUT "Deleting all breakpoints...\n";
		      my $file;
		      for $file (keys %had_breakpoints) {
			local *dbline = $main::{'_<' . $file};
			my $max = $#dbline;
			my $was;
			
d500 1
a500 6
		      }
		      undef %postponed;
		      undef %postponed_file;
		      undef %break_on_load;
		      undef %had_breakpoints;
		      next CMD; };
a501 6
		      my $file;
		      for $file (keys %had_breakpoints) {
			local *dbline = $main::{'_<' . $file};
			my $max = $#dbline;
			my $was;
			
d504 1
a504 2
			        print "$file:\n" unless $was++;
				print $OUT " $i:\t", $dbline[$i];
d506 1
a506 1
				print $OUT "   break if (", $stop, ")\n"
d508 1
a508 1
				print $OUT "   action:  ", $action, "\n"
a512 66
		      }
		      if (%postponed) {
			print $OUT "Postponed breakpoints in subroutines:\n";
			my $subname;
			for $subname (keys %postponed) {
			  print $OUT " $subname\t$postponed{$subname}\n";
			  last if $signal;
			}
		      }
		      my @@have = map { # Combined keys
			keys %{$postponed_file{$_}}
		      } keys %postponed_file;
		      if (@@have) {
			print $OUT "Postponed breakpoints in files:\n";
			my ($file, $line);
			for $file (keys %postponed_file) {
			  my $db = $postponed_file{$file};
			  print $OUT " $file:\n";
			  for $line (sort {$a <=> $b} keys %$db) {
				print $OUT "  $line:\n";
				my ($stop,$action) = split(/\0/, $$db{$line});
				print $OUT "    break if (", $stop, ")\n"
				  if $stop;
				print $OUT "    action:  ", $action, "\n"
				  if $action;
				last if $signal;
			  }
			  last if $signal;
			}
		      }
		      if (%break_on_load) {
			print $OUT "Breakpoints on load:\n";
			my $file;
			for $file (keys %break_on_load) {
			  print $OUT " $file\n";
			  last if $signal;
			}
		      }
		      if ($trace & 2) {
			print $OUT "Watch-expressions:\n";
			my $expr;
			for $expr (@@to_watch) {
			  print $OUT " $expr\n";
			  last if $signal;
			}
		      }
		      next CMD; };
		    $cmd =~ /^b\b\s*load\b\s*(.*)/ && do {
			my $file = $1; $file =~ s/\s+$//;
			{
			  $break_on_load{$file} = 1;
			  $break_on_load{$::INC{$file}} = 1 if $::INC{$file};
			  $file .= '.pm', redo unless $file =~ /\./;
			}
			$had_breakpoints{$file} = 1;
			print $OUT "Will stop on load of `@@{[join '\', `', sort keys %break_on_load]}'.\n";
			next CMD; };
		    $cmd =~ /^b\b\s*(postpone|compile)\b\s*([':A-Za-z_][':\w]*)\s*(.*)/ && do {
			my $cond = $3 || '1';
			my ($subname, $break) = ($2, $1 eq 'postpone');
			$subname =~ s/\'/::/;
			$subname = "${'package'}::" . $subname
			  unless $subname =~ /::/;
			$subname = "main".$subname if substr($subname,0,2) eq "::";
			$postponed{$subname} = $break 
			  ? "break +0 if $cond" : "compile";
d522 1
a522 1
			($file,$i) = (find_sub($subname) =~ /^(.*):(.*)$/);
d526 2
a527 2
			    *dbline = $main::{'_<' . $filename};
			    $had_breakpoints{$filename} = 1;
a540 1
			    $had_breakpoints{$filename} = 1;
a549 6
		      my $file;
		      for $file (keys %had_breakpoints) {
			local *dbline = $main::{'_<' . $file};
			my $max = $#dbline;
			my $was;
			
d556 1
a556 2
		      }
		      next CMD; };
a564 6
		    $cmd =~ /^\<\<\s*(.*)/ && do { # \<\< for CPerl sake: not HERE
			push @@$pre, action($1);
			next CMD; };
		    $cmd =~ /^>>\s*(.*)/ && do {
			push @@$post, action($1);
			next CMD; };
d566 1
a566 2
		        $pre = [], next CMD unless $1;
			$pre = [action($1)];
d569 1
a569 9
		        $post = [], next CMD unless $1;
			$post = [action($1)];
			next CMD; };
		    $cmd =~ /^\{\{\s*(.*)/ && do {
			push @@$pretype, $1;
			next CMD; };
		    $cmd =~ /^\{\s*(.*)/ && do {
		        $pretype = [], next CMD unless $1;
			$pretype = [$1];
a580 1
		        end_report(), next CMD if $finished and $level <= 1;
a584 1
		        end_report(), next CMD if $finished and $level <= 1;
d589 1
a589 2
		        end_report(), next CMD if $finished and $level <= 1;
			$subname = $i = $1;
d591 1
a591 3
			    $subname = $package."::".$subname 
			        unless $subname =~ /::/;
			    ($file,$i) = (find_sub($subname) =~ /^(.*):(.*)$/);
d595 2
a596 2
				*dbline = $main::{'_<' . $filename};
				$had_breakpoints{$filename}++;
d611 1
a611 1
			for ($i=0; $i <= $stack_depth; ) {
d616 2
a617 3
		        end_report(), next CMD if $finished and $level <= 1;
			$stack[$stack_depth] |= 1;
			$doret = $option{PrintRet} ? $stack_depth - 1 : -2;
d620 1
a620 1
		        print $OUT "Warning: some settings and command-line options may be lost!\n";
d641 2
a642 2
			my @@had_breakpoints = keys %had_breakpoints;
			set_list("PERLDB_VISITED", @@had_breakpoints);
d644 3
a646 45
			set_list("PERLDB_ON_LOAD", %break_on_load);
			my @@hard;
			for (0 .. $#had_breakpoints) {
			  my $file = $had_breakpoints[$_];
			  *dbline = $main::{'_<' . $file};
			  next unless %dbline or $postponed_file{$file};
			  (push @@hard, $file), next 
			    if $file =~ /^\(eval \d+\)$/;
			  my @@add;
			  @@add = %{$postponed_file{$file}}
			    if $postponed_file{$file};
			  set_list("PERLDB_FILE_$_", %dbline, @@add);
			}
			for (@@hard) { # Yes, really-really...
			  # Find the subroutines in this eval
			  *dbline = $main::{'_<' . $_};
			  my ($quoted, $sub, %subs, $line) = quotemeta $_;
			  for $sub (keys %sub) {
			    next unless $sub{$sub} =~ /^$quoted:(\d+)-(\d+)$/;
			    $subs{$sub} = [$1, $2];
			  }
			  unless (%subs) {
			    print $OUT
			      "No subroutines in $_, ignoring breakpoints.\n";
			    next;
			  }
			LINES: for $line (keys %dbline) {
			    # One breakpoint per sub only:
			    my ($offset, $sub, $found);
			  SUBS: for $sub (keys %subs) {
			      if ($subs{$sub}->[1] >= $line # Not after the subroutine
				  and (not defined $offset # Not caught
				       or $offset < 0 )) { # or badly caught
				$found = $sub;
				$offset = $line - $subs{$sub}->[0];
				$offset = "+$offset", last SUBS if $offset >= 0;
			      }
			    }
			    if (defined $offset) {
			      $postponed{$found} =
				"break $offset if $dbline{$line}";
			    } else {
			      print $OUT "Breakpoint in $_:$line ignored: after all the subroutines.\n";
			    }
			  }
a647 5
			set_list("PERLDB_POSTPONE", %postponed);
			set_list("PERLDB_PRETYPE", @@$pretype);
			set_list("PERLDB_PRE", @@$pre);
			set_list("PERLDB_POST", @@$post);
			set_list("PERLDB_TYPEAHEAD", @@typeahead);
d654 33
a686 13
			print_trace($OUT, 1); # skip DB
			next CMD; };
		    $cmd =~ /^W\s*$/ && do {
			$trace &= ~2;
			@@to_watch = @@old_watch = ();
			next CMD; };
		    $cmd =~ /^W\b\s*(.*)/s && do {
			push @@to_watch, $1;
			$evalarg = $1;
			my ($val) = &eval;
			$val = (defined $val) ? "'$val'" : 'undef' ;
			push @@old_watch, $val;
			$trace |= 2;
a699 1
			$incr = -1;
a727 1
			$incr = -1;
d747 1
a747 1
			$cmd = $hist[$i];
d750 2
a751 2
		    $cmd =~ /^$sh$sh\s*([\x00-\xff]*)/ && do {
			&system($1);
d763 1
a763 1
			$cmd = $hist[$i];
d769 2
a770 2
		    $cmd =~ /^$sh\s*([\x00-\xff]*)/ && do {
			&system($ENV{SHELL}||"/bin/sh","-c",$1);
d780 2
a781 2
		    $cmd =~ s/^p$/print {\$DB::OUT} \$_/;
		    $cmd =~ s/^p\b/print {\$DB::OUT} /;
d815 1
a815 1
			$SIG{PIPE}= \&DB::catch if $pager =~ /^\|/
d823 1
a823 1
		    $cmd =~ s/^t\s/\$DB::trace |= 1;\n/;
d827 1
d831 1
a831 1
	    } elsif ($term_pid == $$) {
d844 1
a844 1
		    $SIG{PIPE}= "DEFAULT" if $SIG{PIPE} eq \&DB::catch;
d855 2
a856 3
	$exiting = 1 unless defined $cmd;
	foreach $evalarg (@@$post) {
	  &eval;
d859 1
a859 1
    ($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;
d867 2
a868 7
    my ($al, $ret, @@ret) = "";
    if (length($sub) > 10 && substr($sub, -10, 10) eq '::AUTOLOAD') {
	$al = " for $$sub";
    }
    local $stack_depth = $stack_depth + 1; # Protect from non-local exits
    $#stack = $stack_depth;
    $stack[-1] = $single;
d870 1
a870 6
    $single |= 4 if $stack_depth == $deep;
    ($frame & 4 
     ? ( (print $LINEINFO ' ' x ($stack_depth - 1), "in  "), 
	 # Why -1? But it works! :-(
	 print_trace($LINEINFO, -1, 1, 1, "$sub$al") )
     : print $LINEINFO ' ' x ($stack_depth - 1), "entering $sub$al\n") if $frame;
d873 4
a876 12
	$single |= $stack[$stack_depth--];
	($frame & 4 
	 ? ( (print $LINEINFO ' ' x $stack_depth, "out "), 
	     print_trace($LINEINFO, -1, 1, 1, "$sub$al") )
	 : print $LINEINFO ' ' x $stack_depth, "exited $sub$al\n") if $frame & 2;
	if ($doret eq $stack_depth or $frame & 16) {
            my $fh = ($doret eq $stack_depth ? $OUT : $LINEINFO);
	    print $fh ' ' x $stack_depth if $frame & 16;
	    print $fh "list context return from $sub:\n"; 
	    dumpit($fh, \@@ret );
	    $doret = -2;
	}
d879 5
a883 19
        if (defined wantarray) {
	    $ret = &$sub;
        } else {
            &$sub; undef $ret;
        };
	$single |= $stack[$stack_depth--];
	($frame & 4 
	 ? ( (print $LINEINFO ' ' x $stack_depth, "out "), 
	      print_trace($LINEINFO, -1, 1, 1, "$sub$al") )
	 : print $LINEINFO ' ' x $stack_depth, "exited $sub$al\n") if $frame & 2;
	if ($doret eq $stack_depth or $frame & 16 and defined wantarray) {
            my $fh = ($doret eq $stack_depth ? $OUT : $LINEINFO);
	    print $fh (' ' x $stack_depth) if $frame & 16;
	    print $fh (defined wantarray 
			 ? "scalar context return from $sub: " 
			 : "void context return from $sub\n");
	    dumpit( $fh, $ret ) if defined wantarray;
	    $doret = -2;
	}
d889 1
a889 1
    @@saved = ($@@, $!, $^E, $,, $/, $\, $^W);
d898 1
d908 1
a908 2
    local $saved[0];		# Preserve the old value of $@@
    eval { &DB::save };
d911 2
a912 24
    } elsif ($onetimeDump eq 'dump') {
	dumpit($OUT, \@@res);
    } elsif ($onetimeDump eq 'methods') {
	methods($res[0]);
    }
    @@res;
}

sub postponed_sub {
  my $subname = shift;
  if ($postponed{$subname} =~ s/^break\s([+-]?\d+)\s+if\s//) {
    my $offset = $1 || 0;
    # Filename below can contain ':'
    my ($file,$i) = (find_sub($subname) =~ /^(.*):(\d+)-.*$/);
    if ($i) {
      $i += $offset;
      local *dbline = $main::{'_<' . $file};
      local $^W = 0;		# != 0 is magical below
      $had_breakpoints{$file}++;
      my $max = $#dbline;
      ++$i until $dbline[$i] != 0 or $i >= $max;
      $dbline{$i} = delete $postponed{$subname};
    } else {
      print $OUT "Subroutine $subname not found.\n";
a913 4
    return;
  }
  elsif ($postponed{$subname} eq 'compile') { $signal = 1 }
  #print $OUT "In postponed_sub for `$subname'.\n";
d916 9
a924 20
sub postponed {
  if ($ImmediateStop) {
    $ImmediateStop = 0;
    $signal = 1;
  }
  return &postponed_sub
    unless ref \$_[0] eq 'GLOB'; # A subroutine is compiled.
  # Cannot be done before the file is compiled
  local *dbline = shift;
  my $filename = $dbline;
  $filename =~ s/^_<//;
  $signal = 1, print $OUT "'$filename' loaded...\n"
    if $break_on_load{$filename};
  print $LINEINFO ' ' x $stack_depth, "Package $filename.\n" if $frame;
  return unless $postponed_file{$filename};
  $had_breakpoints{$filename}++;
  #%dbline = %{$postponed_file{$filename}}; # Cannot be done: unsufficient magic
  my $key;
  for $key (keys %{$postponed_file{$filename}}) {
    $dbline{$key} = $ {$postponed_file{$filename}}{$key};
a925 1
  delete $postponed_file{$filename};
d929 2
a930 9
    local ($savout) = select(shift);
    my $osingle = $single;
    my $otrace = $trace;
    $single = $trace = 0;
    local $frame = 0;
    local $doret = -2;
    unless (defined &main::dumpValue) {
	do 'dumpvar.pl';
    }
d932 1
a936 2
    $single = $osingle;
    $trace = $otrace;
a939 81
# Tied method do not create a context, so may get wrong message:

sub print_trace {
  my $fh = shift;
  my @@sub = dump_trace($_[0] + 1, $_[1]);
  my $short = $_[2];		# Print short report, next one for sub name
  my $s;
  for ($i=0; $i <= $#sub; $i++) {
    last if $signal;
    local $" = ', ';
    my $args = defined $sub[$i]{args} 
    ? "(@@{ $sub[$i]{args} })"
      : '' ;
    $args = (substr $args, 0, $maxtrace - 3) . '...' 
      if length $args > $maxtrace;
    my $file = $sub[$i]{file};
    $file = $file eq '-e' ? $file : "file `$file'" unless $short;
    $s = $sub[$i]{sub};
    $s = (substr $s, 0, $maxtrace - 3) . '...' if length $s > $maxtrace;    
    if ($short) {
      my $sub = @@_ >= 4 ? $_[3] : $s;
      print $fh "$sub[$i]{context}=$sub$args from $file:$sub[$i]{line}\n";
    } else {
      print $fh "$sub[$i]{context} = $s$args" .
	" called from $file" . 
	  " line $sub[$i]{line}\n";
    }
  }
}

sub dump_trace {
  my $skip = shift;
  my $count = shift || 1e9;
  $skip++;
  $count += $skip;
  my ($p,$file,$line,$sub,$h,$args,$e,$r,@@a,@@sub,$context);
  my $nothard = not $frame & 8;
  local $frame = 0;		# Do not want to trace this.
  my $otrace = $trace;
  $trace = 0;
  for ($i = $skip; 
       $i < $count and ($p,$file,$line,$sub,$h,$context,$e,$r) = caller($i); 
       $i++) {
    @@a = ();
    for $arg (@@args) {
      my $type;
      if (not defined $arg) {
	push @@a, "undef";
      } elsif ($nothard and tied $arg) {
	push @@a, "tied";
      } elsif ($nothard and $type = ref $arg) {
	push @@a, "ref($type)";
      } else {
	local $_ = "$arg";	# Safe to stringify now - should not call f().
	s/([\'\\])/\\$1/g;
	s/(.*)/'$1'/s
	  unless /^(?: -?[\d.]+ | \*[\w:]* )$/x;
	s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;
	s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
	push(@@a, $_);
      }
    }
    $context = $context ? '@@' : (defined $context ? "\$" : '.');
    $args = $h ? [@@a] : undef;
    $e =~ s/\n\s*\;\s*\Z// if $e;
    $e =~ s/([\\\'])/\\$1/g if $e;
    if ($r) {
      $sub = "require '$e'";
    } elsif (defined $r) {
      $sub = "eval '$e'";
    } elsif ($sub eq '(eval)') {
      $sub = "eval {...}";
    }
    push(@@sub, {context => $context, sub => $sub, args => $args,
		file => $file, line => $line});
    last if $signal;
  }
  $trace = $otrace;
  @@sub;
}

d960 1
a960 1
    open(SAVEOUT,">&STDOUT") || &warn("Can't save STDOUT");
d975 1
a975 2
    local $doret = -2;
    eval { require Term::ReadLine } or die $@@;
d998 3
a1000 7
	$rl_attribs = $term->Attribs;
	$rl_attribs->{basic_word_break_characters} .= '-:+/*,[])}' 
	  if defined $rl_attribs->{basic_word_break_characters} 
	    and index($rl_attribs->{basic_word_break_characters}, ":") == -1;
	$rl_attribs->{special_prefixes} = '$@@&%';
	$rl_attribs->{completer_word_break_characters} .= '$@@&%';
	$rl_attribs->{completion_function} = \&db_complete; 
a1007 30
    ornaments($ornaments) if defined $ornaments;
    $term_pid = $$;
}

sub resetterm {			# We forked, so we need a different TTY
    $term_pid = $$;
    if (defined &get_fork_TTY) {
      &get_fork_TTY;
    } elsif (not defined $fork_TTY 
	     and defined $ENV{TERM} and $ENV{TERM} eq 'xterm' 
	     and defined $ENV{WINDOWID} and defined $ENV{DISPLAY}) { 
        # Possibly _inside_ XTERM
        open XT, q[3>&1 xterm -title 'Forked Perl debugger' -e sh -c 'tty 1>&3;\
 sleep 10000000' |];
        $fork_TTY = <XT>;
        chomp $fork_TTY;
    }
    if (defined $fork_TTY) {
      TTY($fork_TTY);
      undef $fork_TTY;
    } else {
      print_help(<<EOP);
I<#########> Forked, but do not know how to change a B<TTY>. I<#########>
  Define B<\$DB::fork_TTY> 
       - or a function B<DB::get_fork_TTY()> which will set B<\$DB::fork_TTY>.
  The value of B<\$DB::fork_TTY> should be the name of I<TTY> to use.
  On I<UNIX>-like systems one can get the name of a I<TTY> for the given window
  by typing B<tty>, and disconnect the I<shell> from I<TTY> by B<sleep 1000000>.
EOP
    }
a1019 1
  local $doret = -2;
a1024 8
    $val = option_val($opt,'N/A');
    $val =~ s/([\\\'])/\\$1/g;
    printf $OUT "%20s = '%s'\n", $opt, $val;
}

sub option_val {
    my ($opt, $default)= @@_;
    my $val;
d1035 1
a1035 1
	$val = $default;
d1039 2
a1040 1
    $val
d1073 1
a1073 2
	eval "local \$frame = 0; local \$doret = -2; 
	      require '$optionRequire{$option}'"
d1094 1
a1094 1
    $val =~ s/([\0-\37\177\200-\377])/"\\0x" . unpack('H2',$1)/eg;
a1113 1
    return;			# Put nothing on the stack - malloc/free land!
d1123 5
a1127 17
    if (@@_ and $term and $term->Features->{newTTY}) {
      my ($in, $out) = shift;
      if ($in =~ /,/) {
	($in, $out) = split /,/, $in, 2;
      } else {
	$out = $in;
      }
      open IN, $in or die "cannot open `$in' for read: $!";
      open OUT, ">$out" or die "cannot open `$out' for write: $!";
      $term->newTTY(\*IN, \*OUT);
      $IN	= \*IN;
      $OUT	= \*OUT;
      return $tty = $in;
    } elsif ($term and @@_) {
	&warn("Too late to set TTY, enabled on next `R'!\n");
    } 
    $tty = shift if @@_;
d1133 3
a1135 1
	&warn("Too late to set noTTY, enabled on next `R'!\n") if @@_;
a1136 1
    $notty = shift if @@_;
d1142 3
a1144 1
	&warn("Too late to set ReadLine, enabled on next `R'!\n") if @@_;
a1145 1
    $rl = shift if @@_;
a1148 9
sub tkRunning {
    if ($ {$term->Features}{tkRunning}) {
        return $term->tkRunning(@@_);
    } else {
	print $OUT "tkRunning not supported by current ReadLine package.\n";
	0;
    }
}

d1151 3
a1153 1
	&warn("Too late to set up NonStop mode, enabled on next `R'!\n") if @@_;
a1154 1
    $runnonstop = shift if @@_;
a1177 10
sub ornaments {
  if (defined $term) {
    local ($warnLevel,$dieLevel) = (0, 1);
    return '' unless $term->Features->{ornaments};
    eval { $term->ornaments(@@_) } || '';
  } else {
    $ornaments = shift;
  }
}

a1202 17
sub list_versions {
  my %version;
  my $file;
  for (keys %INC) {
    $file = $_;
    s,\.p[lm]$,,i ;
    s,/,::,g ;
    s/^perl5db$/DB/;
    s/^Term::ReadLine::readline$/readline/;
    if (defined $ { $_ . '::VERSION' }) {
      $version{$file} = "$ { $_ . '::VERSION' } from ";
    } 
    $version{$file} .= $INC{$file};
  }
  dumpit($OUT,\%version);
}

d1205 26
a1230 26
B<T>		Stack trace.
B<s> [I<expr>]	Single step [in I<expr>].
B<n> [I<expr>]	Next, steps over subroutine calls [in I<expr>].
<B<CR>>		Repeat last B<n> or B<s> command.
B<r>		Return from current subroutine.
B<c> [I<line>|I<sub>]	Continue; optionally inserts a one-time-only breakpoint
		at the specified position.
B<l> I<min>B<+>I<incr>	List I<incr>+1 lines starting at I<min>.
B<l> I<min>B<->I<max>	List lines I<min> through I<max>.
B<l> I<line>		List single I<line>.
B<l> I<subname>	List first window of lines from subroutine.
B<l>		List next window of lines.
B<->		List previous window of lines.
B<w> [I<line>]	List window around I<line>.
B<.>		Return to the executed line.
B<f> I<filename>	Switch to viewing I<filename>. Must be loaded.
B</>I<pattern>B</>	Search forwards for I<pattern>; final B</> is optional.
B<?>I<pattern>B<?>	Search backwards for I<pattern>; final B<?> is optional.
B<L>		List all breakpoints and actions.
B<S> [[B<!>]I<pattern>]	List subroutine names [not] matching I<pattern>.
B<t>		Toggle trace mode.
B<t> I<expr>		Trace through execution of I<expr>.
B<b> [I<line>] [I<condition>]
		Set breakpoint; I<line> defaults to the current execution line;
		I<condition> breaks if it evaluates to true, defaults to '1'.
B<b> I<subname> [I<condition>]
d1232 13
a1244 25
B<b> B<load> I<filename> Set breakpoint on `require'ing the given file.
B<b> B<postpone> I<subname> [I<condition>]
		Set breakpoint at first line of subroutine after 
		it is compiled.
B<b> B<compile> I<subname>
		Stop after the subroutine is compiled.
B<d> [I<line>]	Delete the breakpoint for I<line>.
B<D>		Delete all breakpoints.
B<a> [I<line>] I<command>
		Set an action to be done before the I<line> is executed.
		Sequence is: check for breakpoint/watchpoint, print line
		if necessary, do action, prompt user if necessary,
		execute expression.
B<A>		Delete all actions.
B<W> I<expr>		Add a global watch-expression.
B<W>		Delete all watch-expressions.
B<V> [I<pkg> [I<vars>]]	List some (default all) variables in package (default current).
		Use B<~>I<pattern> and B<!>I<pattern> for positive and negative regexps.
B<X> [I<vars>]	Same as \"B<V> I<currentpackage> [I<vars>]\".
B<x> I<expr>		Evals expression in array context, dumps the result.
B<m> I<expr>		Evals expression in array context, prints methods callable
		on the first element of the result.
B<m> I<class>		Prints methods callable via the given class.
B<O> [I<opt>[B<=>I<val>]] [I<opt>B<\">I<val>B<\">] [I<opt>B<?>]...
		Set or query values of options.  I<val> defaults to 1.  I<opt> can
d1246 13
a1258 20
    I<recallCommand>, I<ShellBang>:	chars used to recall command or spawn shell;
    I<pager>:			program for output of \"|cmd\";
    I<tkRunning>:			run Tk while prompting (with ReadLine);
    I<signalLevel> I<warnLevel> I<dieLevel>:	level of verbosity;
    I<inhibit_exit>		Allows stepping off the end of the script.
    I<ImmediateStop>		Debugger should stop as early as possible.
  The following options affect what happens with B<V>, B<X>, and B<x> commands:
    I<arrayDepth>, I<hashDepth>:	print only first N elements ('' for all);
    I<compactDump>, I<veryCompact>:	change style of array and hash dump;
    I<globPrint>:			whether to print contents of globs;
    I<DumpDBFiles>:		dump arrays holding debugged files;
    I<DumpPackages>:		dump symbol tables of packages;
    I<DumpReused>:		dump contents of \"reused\" addresses;
    I<quote>, I<HighBit>, I<undefPrint>:	change style of string dump;
    I<bareStringify>:		Do not print the overload-stringified value;
  Option I<PrintRet> affects printing of return value after B<r> command,
         I<frame>    affects printing messages on entry and exit from subroutines.
         I<AutoTrace> affects printing messages on every possible breaking point.
	 I<maxTraceLen> gives maximal length of evals/args listed in stack trace.
	 I<ornaments> affects screen appearance of the command line.
d1260 9
a1268 13
		You can put additional initialization options I<TTY>, I<noTTY>,
		I<ReadLine>, and I<NonStop> there (or use `B<R>' after you set them).
B<<> I<expr>		Define Perl command to run before each prompt.
B<<<> I<expr>		Add to the list of Perl commands to run before each prompt.
B<>> I<expr>		Define Perl command to run after each prompt.
B<>>B<>> I<expr>	Add to the list of Perl commands to run after each prompt.
B<{> I<db_command>	Define debugger command to run before each prompt.
B<{{> I<db_command>	Add to the list of debugger commands to run before each prompt.
B<$prc> I<number>	Redo a previous command (default previous command).
B<$prc> I<-number>	Redo number'th-to-last command.
B<$prc> I<pattern>	Redo last command that started with I<pattern>.
		See 'B<O> I<recallCommand>' too.
B<$psh$psh> I<cmd>  	Run cmd in a subprocess (reads from DB::IN, writes to DB::OUT)"
d1270 13
a1282 17
B<$psh> [I<cmd>] 	Run I<cmd> in subshell (forces \"\$SHELL -c 'cmd'\")." ) . "
		See 'B<O> I<shellBang>' too.
B<H> I<-number>	Display last number commands (default all).
B<p> I<expr>		Same as \"I<print {DB::OUT} expr>\" in current package.
B<|>I<dbcmd>		Run debugger command, piping DB::OUT to current pager.
B<||>I<dbcmd>		Same as B<|>I<dbcmd> but DB::OUT is temporarilly select()ed as well.
B<\=> [I<alias> I<value>]	Define a command alias, or list current aliases.
I<command>		Execute as a perl statement in current package.
B<v>		Show versions of loaded modules.
B<R>		Pure-man-restart of debugger, some of debugger state
		and command-line options may be lost.
		Currently the following setting are preserved: 
		history, breakpoints and actions, debugger B<O>ptions 
		and the following command-line options: I<-w>, I<-I>, I<-e>.
B<h> [I<db_command>]	Get help [on a specific debugger command], enter B<|h> to page.
B<h h>		Summary of debugger commands.
B<q> or B<^D>		Quit. Set B<\$DB::finished = 0> to debug global destruction.
d1286 23
a1308 23
I<List/search source lines:>               I<Control script execution:>
  B<l> [I<ln>|I<sub>]  List source code            B<T>           Stack trace
  B<-> or B<.>      List previous/current line  B<s> [I<expr>]    Single step [in expr]
  B<w> [I<line>]    List around line            B<n> [I<expr>]    Next, steps over subs
  B<f> I<filename>  View source in file         <B<CR>>        Repeat last B<n> or B<s>
  B</>I<pattern>B</> B<?>I<patt>B<?>   Search forw/backw    B<r>           Return from subroutine
  B<v>	      Show versions of modules    B<c> [I<ln>|I<sub>]  Continue until position
I<Debugger controls:>                        B<L>           List break/watch/actions
  B<O> [...]     Set debugger options        B<t> [I<expr>]    Toggle trace [trace expr]
  B<<>[B<<>] or B<{>[B<{>] [I<cmd>]   Do before prompt   B<b> [I<ln>|I<event>] [I<cnd>]  Set breakpoint
  B<>>[B<>>] [I<cmd>]  Do after prompt             B<b> I<sub> [I<cnd>] Set breakpoint for sub
  B<$prc> [I<N>|I<pat>]   Redo a previous command     B<d> [I<ln>] or B<D> Delete a/all breakpoints
  B<H> [I<-num>]    Display last num commands   B<a> [I<ln>] I<cmd>  Do cmd before line
  B<=> [I<a> I<val>]   Define/list an alias        B<W> I<expr>      Add a watch expression
  B<h> [I<db_cmd>]  Get help on command         B<A> or B<W>      Delete all actions/watch
  B<|>[B<|>]I<dbcmd>   Send output to pager        B<$psh>\[B<$psh>\] I<syscmd> Run cmd in a subprocess
  B<q> or B<^D>     Quit			  B<R>	      Attempt a restart
I<Data Examination:>	      B<expr>     Execute perl code, also see: B<s>,B<n>,B<t> I<expr>
  B<x>|B<m> I<expr>	Evals expr in array context, dumps the result or lists methods.
  B<p> I<expr>	Print expression (uses script's current package).
  B<S> [[B<!>]I<pat>]	List subroutine names [not] matching pattern
  B<V> [I<Pk> [I<Vars>]]	List Variables in Package.  Vars can be ~pattern or !pattern.
  B<X> [I<Vars>]	Same as \"B<V> I<current_package> [I<Vars>]\".
d1310 1
a1310 10
				# ')}}; # Fix balance of Emacs parsing
}

sub print_help {
  my $message = shift;
  if (@@Term::ReadLine::TermCap::rl_term_set) {
    $message =~ s/B<([^>]+|>)>/$Term::ReadLine::TermCap::rl_term_set[2]$1$Term::ReadLine::TermCap::rl_term_set[3]/g;
    $message =~ s/I<([^>]+|>)>/$Term::ReadLine::TermCap::rl_term_set[0]$1$Term::ReadLine::TermCap::rl_term_set[1]/g;
  }
  print $OUT $message;
d1315 1
a1315 2
    local $doret = -2;
    $SIG{'ABRT'} = 'DEFAULT';
d1317 5
a1321 8
    if (defined &Carp::longmess) {
	local $SIG{__WARN__} = '';
	local $Carp::CarpLevel = 2;		# mydie + confess
	&warn(Carp::longmess("Signal @@_"));
    }
    else {
	print $DB::OUT "Got signal @@_\n";
    }
a1326 1
  local $doret = -2;
d1328 2
a1329 5
  local $SIG{__DIE__} = '';
  eval { require Carp } if defined $^S;	# If error/warning during compilation,
                                        # require may be broken.
  warn(@@_, "\nCannot print stack trace, load with -MCarp option to see stack"),
    return unless defined &Carp::longmess;
d1334 1
d1336 1
a1340 1
  local $doret = -2;
d1344 6
a1349 1
  if ($dieLevel > 2) {
d1351 4
a1354 2
      &warn(@@_);		# Yell no matter what
      return;
d1356 1
a1356 7
  if ($dieLevel < 2) {
    die @@_ if $^S;		# in eval propagate
  }
  eval { require Carp } if defined $^S;	# If error/warning during compilation,
                                	# require may be broken.
  die(@@_, "\nCannot print stack trace, load with -MCarp option to see stack")
    unless defined &Carp::longmess;
d1363 1
d1372 1
a1372 1
      $SIG{__WARN__} = \&DB::dbwarn;
d1385 2
a1386 2
      $SIG{__DIE__} = \&DB::dbdie; # if $dieLevel < 2;
      #$SIG{__DIE__} = \&DB::diehard if $dieLevel >= 2;
d1388 1
a1388 2
        ( $dieLevel == 1 ? " outside of evals" : ""), ".\n"
	  if $I_m_init;
d1404 2
a1405 2
      $SIG{SEGV} = \&DB::diesignal;
      $SIG{BUS} = \&DB::diesignal;
a1413 40
sub find_sub {
  my $subr = shift;
  return unless defined &$subr;
  $sub{$subr} or do {
    $subr = \&$subr;		# Hard reference
    my $s;
    for (keys %sub) {
      $s = $_, last if $subr eq \&$_;
    }
    $sub{$s} if $s;
  }
}

sub methods {
  my $class = shift;
  $class = ref $class if ref $class;
  local %seen;
  local %packs;
  methods_via($class, '', 1);
  methods_via('UNIVERSAL', 'UNIVERSAL', 0);
}

sub methods_via {
  my $class = shift;
  return if $packs{$class}++;
  my $prefix = shift;
  my $prepend = $prefix ? "via $prefix: " : '';
  my $name;
  for $name (grep {defined &{$ {"$ {class}::"}{$_}}} 
	     sort keys %{"$ {class}::"}) {
    next if $seen{ $name }++;
    print $DB::OUT "$prepend$name\n";
  }
  return unless shift;		# Recurse?
  for $name (@@{"$ {class}::ISA"}) {
    $prepend = $prefix ? $prefix . " -> $name" : $name;
    methods_via($name, $prepend, 1);
  }
}

d1426 10
a1435 5
  $SIG{INT} = \&DB::catch;
  # This may be enabled to debug debugger:
  #$warnLevel = 1 unless defined $warnLevel;
  #$dieLevel = 1 unless defined $dieLevel;
  #$signalLevel = 1 unless defined $signalLevel;
a1439 6
  # @@stack and $doret are needed in sub sub, which is called for DB::postponed.
  # Triggers bug (?) in perl is we postpone this until runtime:
  @@postponed = @@stack = (0);
  $stack_depth = 0;		# Localized $#stack
  $doret = -2;
  $frame = 0;
a1444 99

sub db_complete {
  # Specific code for b c l V m f O, &blah, $blah, @@blah, %blah
  my($text, $line, $start) = @@_;
  my ($itext, $search, $prefix, $pack) =
    ($text, "^\Q$ {'package'}::\E([^:]+)\$");
  
  return sort grep /^\Q$text/, (keys %sub), qw(postpone load compile), # subroutines
                               (map { /$search/ ? ($1) : () } keys %sub)
    if (substr $line, 0, $start) =~ /^\|*[blc]\s+((postpone|compile)\s+)?$/;
  return sort grep /^\Q$text/, values %INC # files
    if (substr $line, 0, $start) =~ /^\|*b\s+load\s+$/;
  return sort map {($_, db_complete($_ . "::", "V ", 2))}
    grep /^\Q$text/, map { /^(.*)::$/ ? ($1) : ()} keys %:: # top-packages
      if (substr $line, 0, $start) =~ /^\|*[Vm]\s+$/ and $text =~ /^\w*$/;
  return sort map {($_, db_complete($_ . "::", "V ", 2))}
    grep !/^main::/,
      grep /^\Q$text/, map { /^(.*)::$/ ? ($prefix . "::$1") : ()} keys %{$prefix . '::'}
				 # packages
	if (substr $line, 0, $start) =~ /^\|*[Vm]\s+$/ 
	  and $text =~ /^(.*[^:])::?(\w*)$/  and $prefix = $1;
  if ( $line =~ /^\|*f\s+(.*)/ ) { # Loaded files
    # We may want to complete to (eval 9), so $text may be wrong
    $prefix = length($1) - length($text);
    $text = $1;
    return sort 
	map {substr $_, 2 + $prefix} grep /^_<\Q$text/, (keys %main::), $0
  }
  if ((substr $text, 0, 1) eq '&') { # subroutines
    $text = substr $text, 1;
    $prefix = "&";
    return sort map "$prefix$_", 
               grep /^\Q$text/, 
                 (keys %sub),
                 (map { /$search/ ? ($1) : () } 
		    keys %sub);
  }
  if ($text =~ /^[\$@@%](.*)::(.*)/) { # symbols in a package
    $pack = ($1 eq 'main' ? '' : $1) . '::';
    $prefix = (substr $text, 0, 1) . $1 . '::';
    $text = $2;
    my @@out 
      = map "$prefix$_", grep /^\Q$text/, grep /^_?[a-zA-Z]/, keys %$pack ;
    if (@@out == 1 and $out[0] =~ /::$/ and $out[0] ne $itext) {
      return db_complete($out[0], $line, $start);
    }
    return sort @@out;
  }
  if ($text =~ /^[\$@@%]/) { # symbols (in $package + packages in main)
    $pack = ($package eq 'main' ? '' : $package) . '::';
    $prefix = substr $text, 0, 1;
    $text = substr $text, 1;
    my @@out = map "$prefix$_", grep /^\Q$text/, 
       (grep /^_?[a-zA-Z]/, keys %$pack), 
       ( $pack eq '::' ? () : (grep /::$/, keys %::) ) ;
    if (@@out == 1 and $out[0] =~ /::$/ and $out[0] ne $itext) {
      return db_complete($out[0], $line, $start);
    }
    return sort @@out;
  }
  if ((substr $line, 0, $start) =~ /^\|*O\b.*\s$/) { # Options after a space
    my @@out = grep /^\Q$text/, @@options;
    my $val = option_val($out[0], undef);
    my $out = '? ';
    if (not defined $val or $val =~ /[\n\r]/) {
      # Can do nothing better
    } elsif ($val =~ /\s/) {
      my $found;
      foreach $l (split //, qq/\"\'\#\|/) {
	$out = "$l$val$l ", last if (index $val, $l) == -1;
      }
    } else {
      $out = "=$val ";
    }
    # Default to value if one completion, to question if many
    $rl_attribs->{completer_terminator_character} = (@@out == 1 ? $out : '? ');
    return sort @@out;
  }
  return $term->filename_list($text); # filenames
}

sub end_report {
  print $OUT "Use `q' to quit or `R' to restart.  `h q' for details.\n"
}

END {
  $finished = $inhibit_exit;	# So that some keys may be disabled.
  # Do not stop in at_exit() and destructors on exit:
  $DB::single = !$exiting && !$runnonstop;
  DB::fake::at_exit() unless $exiting or $runnonstop;
}

package DB::fake;

sub at_exit {
  "Debugged program terminated.  Use `q' to quit or `R' to restart.";
}

package DB;			# Do not trace this 1; below!
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d5 1
a5 1
$VERSION = 1.07;
d8 8
a78 2
# RemotePort - host:port to connect to on remote host for remote debugging.
#
a88 9

# Enhanced by ilya@@math.ohio-state.edu (Ilya Zakharevich)
# Latest version available: ftp://ftp.math.ohio-state.edu/pub/users/ilya/perl

# modified Perl debugger, to be run from Emacs in perldb-mode
# Ray Lischner (uunet!mntgfx!lisch) as of 5 Nov 1990
# Johan Vromans -- upgrade to 4.0 pl 10
# Ilya Zakharevich -- patches after 5.001 (and some before ;-)

a144 42
# Changes: 1.07: Many fixed by tchrist 13-March-2000
#   BUG FIXES:
#   + Added bare mimimal security checks on perldb rc files, plus
#     comments on what else is needed.
#   + Fixed the ornaments that made "|h" completely unusable.
#     They are not used in print_help if they will hurt.  Strip pod
#     if we're paging to less.
#   + Fixed mis-formatting of help messages caused by ornaments
#     to restore Larry's original formatting.  
#   + Fixed many other formatting errors.  The code is still suboptimal, 
#     and needs a lot of work at restructuing. It's also misindented
#     in many places.
#   + Fixed bug where trying to look at an option like your pager
#     shows "1".  
#   + Fixed some $? processing.  Note: if you use csh or tcsh, you will
#     lose.  You should consider shell escapes not using their shell,
#     or else not caring about detailed status.  This should really be
#     unified into one place, too.
#   + Fixed bug where invisible trailing whitespace on commands hoses you,
#     tricking Perl into thinking you wern't calling a debugger command!
#   + Fixed bug where leading whitespace on commands hoses you.  (One
#     suggests a leading semicolon or any other irrelevant non-whitespace
#     to indicate literal Perl code.)
#   + Fixed bugs that ate warnings due to wrong selected handle.
#   + Fixed a precedence bug on signal stuff.
#   + Fixed some unseemly wording.
#   + Fixed bug in help command trying to call perl method code.
#   + Fixed to call dumpvar from exception handler.  SIGPIPE killed us.
#   ENHANCEMENTS:
#   + Added some comments.  This code is still nasty spaghetti.
#   + Added message if you clear your pre/post command stacks which was
#     very easy to do if you just typed a bare >, <, or {.  (A command
#     without an argument should *never* be a destructive action; this
#     API is fundamentally screwed up; likewise option setting, which
#     is equally buggered.)
#   + Added command stack dump on argument of "?" for >, <, or {.
#   + Added a semi-built-in doc viewer command that calls man with the
#     proper %Config::Config path (and thus gets caching, man -k, etc),
#     or else perldoc on obstreperous platforms.
#   + Added to and rearranged the help information.
#   + Detected apparent misuse of { ... } to declare a block; this used
#     to work but now is a command, and mysteriously gave no complaint.
d182 1
a182 2
		  ImmediateStop bareStringify
		  RemotePort);
a199 1
		 RemotePort	=> \$remoteport,
a218 1
		  RemotePort	=> \&RemotePort,
d228 7
a234 8
$rl		= 1	unless defined $rl;
$warnLevel	= 0	unless defined $warnLevel;
$dieLevel	= 0	unless defined $dieLevel;
$signalLevel	= 1	unless defined $signalLevel;
$pre		= []	unless defined $pre;
$post		= []	unless defined $post;
$pretype	= []	unless defined $pretype;

d238 1
a238 3

&pager(
    (defined($ENV{PAGER}) 
a242 1
setman();
d247 1
a247 1
if (-e "/dev/tty") {  # this is the wrong metric!
a252 42
# This isn't really safe, because there's a race
# between checking and opening.  The solution is to
# open and fstat the handle, but then you have to read and
# eval the contents.  But then the silly thing gets
# your lexical scope, which is unfortunately at best.
sub safe_do { 
    my $file = shift;

    # Just exactly what part of the word "CORE::" don't you understand?
    local $SIG{__WARN__};  
    local $SIG{__DIE__};    

    unless (is_safe_file($file)) {
	CORE::warn <<EO_GRIPE;
perldb: Must not source insecure rcfile $file.
        You or the superuser must be the owner, and it must not 
	be writable by anyone but its owner.
EO_GRIPE
	return;
    } 

    do $file;
    CORE::warn("perldb: couldn't parse $file: $@@") if $@@;
}


# Verifies that owner is either real user or superuser and that no
# one but owner may write to it.  This function is of limited use
# when called on a path instead of upon a handle, because there are
# no guarantees that filename (by dirent) whose file (by ino) is
# eventually accessed is the same as the one tested. 
# Assumes that the file's existence is not in doubt.
sub is_safe_file {
    my $path = shift;
    stat($path) || return;	# mysteriously vaporized
    my($dev,$ino,$mode,$nlink,$uid,$gid) = stat(_);

    return 0 if $uid != 0 && $uid != $<;
    return 0 if $mode & 022;
    return 1;
}

d254 5
a258 7
    safe_do("./$rcfile");
} 
elsif (defined $ENV{HOME} && -f "$ENV{HOME}/$rcfile") {
    safe_do("$ENV{HOME}/$rcfile");
}
elsif (defined $ENV{LOGDIR} && -f "$ENV{LOGDIR}/$rcfile") {
    safe_do("$ENV{LOGDIR}/$rcfile");
a264 2
# Here begin the unreadable code.  It needs fixing.

d293 3
a295 3
  # Is Perl being run from a slave editor or graphical debugger?
  $slave_editor = ((defined $main::ARGV[0]) and ($main::ARGV[0] eq '-emacs'));
  $rl = 0, shift(@@main::ARGV) if $slave_editor;
d299 1
a299 4
  if ($^O eq 'cygwin') {
    # /dev/tty is binary. use stdin for textmode
    undef $console;
  } elsif (-e "/dev/tty") {
d307 1
a307 1
  if (($^O eq 'MSWin32') and ($slave_editor or defined $ENV{EMACS})) {
d312 1
a312 5
  if (defined $ENV{OS2_SHELL} and ($slave_editor or $ENV{WINDOWID})) { # In OS/2
    $console = undef;
  }

  if ($^O eq 'epoc') {
d318 11
a328 21
  if (defined $remoteport) {
    require IO::Socket;
    $OUT = new IO::Socket::INET( Timeout  => '10',
                                 PeerAddr => $remoteport,
                                 Proto    => 'tcp',
                               );
    if (!$OUT) { die "Could not create socket to connect to remote host."; }
    $IN = $OUT;
  }
  else {
    if (defined $console) {
      open(IN,"+<$console") || open(IN,"<$console") || open(IN,"<&STDIN");
      open(OUT,"+>$console") || open(OUT,">$console") || open(OUT,">&STDERR")
        || open(OUT,">&STDOUT");	# so we don't dongle stdout
    } else {
      open(IN,"<&STDIN");
      open(OUT,">&STDERR") || open(OUT,">&STDOUT"); # so we don't dongle stdout
      $console = 'STDIN/OUT';
    }
    # so open("|more") can read from STDOUT and so we don't dingle stdin
    $IN = \*IN;
d330 1
a330 2
    $OUT = \*OUT;
  }
d343 2
a344 2
    print $OUT ("Editor support ",
		$slave_editor ? "enabled" : "available",
d346 1
a346 1
    print $OUT "\nEnter h or `h h' for help, or `$doccmd perldebug' for more help.\n\n";
d419 1
a419 1
	if ($slave_editor) {
d430 1
a430 1
	  $usercontext = '($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;' .
d474 1
a474 1
	@@typeahead = (@@$pretype, @@typeahead);
d480 1
a480 2
				       " "))) 
        {
a489 2
		    $cmd =~ s/^\s+//s;   # trim annoying leading whitespace
		    $cmd =~ s/\s+$//s;   # trim annoying trailing whitespace
d491 1
a491 10
		    if ($alias{$i}) { 
			# squelch the sigmangler
			local $SIG{__DIE__};
			local $SIG{__WARN__};
			eval "\$cmd =~ $alias{$i}";
			if ($@@) {
			    print $OUT "Couldn't evaluate `$i' alias: $@@";
			    next CMD;
			} 
		    }
d499 4
a502 8
		    # support long commands; otherwise bogus errors
		    # happen when you ask for h on <CR> for example
		    $cmd =~ /^h\s+(\S.*)$/ && do {      
			my $asked = $1;			# for proper errmsg
			my $qasked = quotemeta($asked); # for searching
			# XXX: finds CR but not <CR>
			if ($help =~ /^<?(?:[IB]<)$qasked/m) {
			  while ($help =~ /^(<?(?:[IB]<)$qasked([\s\S]*?)\n)(?!\s)/mg) {
d510 1
a510 1
			$trace ^= 1;
d535 1
a535 5
			    # must detect sigpipe failures
			    eval { &main::dumpvar($packname,@@vars) };
			    if ($@@) {
				die unless $@@ =~ /dumpvar print failed/;
			    } 
d577 1
a577 9
		    $cmd =~ /^([lb])\b\s*(\$.*)/s && do {
			$evalarg = $2;
			my ($s) = &eval;
			print($OUT "Error: $@@\n"), next CMD if $@@;
			$s = CvGV_name($s);
			print($OUT "Interpreted as: $1 $s\n");
			$cmd = "$1 $s";
		    };
		    $cmd =~ /^l\b\s*([\':A-Za-z_][\':\w]*(\[.*\])?)/s && do {
d583 1
a583 1
			@@pieces = split(/:/,find_sub($subname) || $sub{$subname});
a586 2
			    print $OUT "Switching to file '$file'.\n"
				unless $slave_editor;
d634 1
a634 1
			if ($slave_editor) {
a669 4
			
			if (not $had_breakpoints{$file} &= ~1) {
			    delete $had_breakpoints{$file};
			}
d674 1
d685 1
a685 1
			        print $OUT "$file:\n" unless $was++;
d749 1
a749 1
			$had_breakpoints{$file} |= 1;
d762 1
a762 1
		    $cmd =~ /^b\b\s*([':A-Za-z_][':\w]*(?:\[.*\])?)\s*(.*)/ && do {
d773 3
a775 3
			    local $filename = $file;
			    local *dbline = $main::{'_<' . $filename};
			    $had_breakpoints{$filename} |= 1;
d784 1
a784 1
			$i = $1 || $line;
d789 1
a789 1
			    $had_breakpoints{$filename} |= 1;
d793 2
a794 2
		    $cmd =~ /^d\b\s*(\d*)/ && do {
			$i = $1 || $line;
a798 1
		      print $OUT "Deleting all actions...\n";
a810 4
			
			unless ($had_breakpoints{$file} &= ~2) {
			    delete $had_breakpoints{$file};
			}
d828 1
a828 16
			unless ($1) {
			    print OUT "All < actions cleared.\n";
			    $pre = [];
			    next CMD;
			} 
			if ($1 eq '?') {
			    unless (@@$pre) {
				print OUT "No pre-prompt Perl actions.\n";
				next CMD;
			    } 
			    print OUT "Perl commands run before each prompt:\n";
			    for my $action ( @@$pre ) {
				print "\t< -- $action\n";
			    } 
			    next CMD;
			} 
d832 1
a832 16
			unless ($1) {
			    print OUT "All > actions cleared.\n";
			    $post = [];
			    next CMD;
			}
			if ($1 eq '?') {
			    unless (@@$post) {
				print OUT "No post-prompt Perl actions.\n";
				next CMD;
			    } 
			    print OUT "Perl commands run after each prompt:\n";
			    for my $action ( @@$post ) {
				print "\t> -- $action\n";
			    } 
			    next CMD;
			} 
a835 6
			if ($cmd =~ /^\{.*\}$/ && unbalanced(substr($cmd,2))) { 
			    print OUT "{{ is now a debugger command\n",
				"use `;{{' if you mean Perl code\n";
			    $cmd = "h {{";
			    redo CMD;
			} 
d839 1
a839 22
			unless ($1) {
			    print OUT "All { actions cleared.\n";
			    $pretype = [];
			    next CMD;
			}
			if ($1 eq '?') {
			    unless (@@$pretype) {
				print OUT "No pre-prompt debugger actions.\n";
				next CMD;
			    } 
			    print OUT "Debugger commands run before each prompt:\n";
			    for my $action ( @@$pretype ) {
				print "\t{ -- $action\n";
			    } 
			    next CMD;
			} 
			if ($cmd =~ /^\{.*\}$/ && unbalanced(substr($cmd,1))) { 
			    print OUT "{ is now a debugger command\n",
				"use `;{' if you mean Perl code\n";
			    $cmd = "h {";
			    redo CMD;
			} 
d842 4
a845 10
		    $cmd =~ /^a\b\s*(\d*)\s*(.*)/ && do {
			$i = $1 || $line; $j = $2;
			if (length $j) {
			    if ($dbline[$i] == 0) {
				print $OUT "Line $i may not have an action.\n";
			    } else {
				$had_breakpoints{$filename} |= 2;
				$dbline{$i} =~ s/\0[^\0]*//;
				$dbline{$i} .= "\0" . action($j);
			    }
d848 1
a848 1
			    delete $dbline{$i} if $dbline{$i} eq '';
a863 4
			#  Probably not needed, since we finish an interactive
			#  sub-session anyway...
			# local $filename = $filename;
			# local *dbline = *dbline;	# XXX Would this work?!
d872 1
a872 1
				$had_breakpoints{$filename} |= 1;
d909 1
a909 1
			        chomp ($cl =  ${'::_<-e'}[$_]);
d973 2
a974 2
			#print "$^X, '-d', @@flags, @@script, ($slave_editor ? '-emacs' : ()), @@ARGS";
			exec $^X, '-d', @@flags, @@script, ($slave_editor ? '-emacs' : ()), @@ARGS;
a995 3
			    # squelch the sigmangler
			    local $SIG{__DIE__};
			    local $SIG{__WARN__};
d1011 1
a1011 1
				    if ($slave_editor) {
a1024 3
			    # squelch the sigmangler
			    local $SIG{__DIE__};
			    local $SIG{__WARN__};
d1027 1
a1027 1
				print $OUT $@@;
d1040 1
a1040 1
				    if ($slave_editor) {
d1052 1
a1052 1
			$i = $1 ? ($#hist-($2||1)) : ($2||$#hist);
d1054 1
a1054 1
			print $OUT $cmd, "\n";
d1070 1
a1070 1
			print $OUT $cmd, "\n";
a1075 2
			# XXX: using csh or tcsh destroys sigint retvals!
			#&system($1);  # use this instead
d1079 1
a1079 1
			$end = $2 ? ($#hist-$2) : 0;
a1085 3
		    $cmd =~ /^(?:man|(?:perl)?doc)\b(?:\s+([^(]*))?$/ && do {
			runman($1);
			next CMD; };
d1088 9
a1096 27
		    $cmd =~ s/^=\s*// && do {
			my @@keys;
			if (length $cmd == 0) {
			    @@keys = sort keys %alias;
			} 
                        elsif (my($k,$v) = ($cmd =~ /^(\S+)\s+(\S.*)/)) {
			    # can't use $_ or kill //g state
			    for my $x ($k, $v) { $x =~ s/\a/\\a/g }
			    $alias{$k} = "s\a$k\a$v\a";
			    # squelch the sigmangler
			    local $SIG{__DIE__};
			    local $SIG{__WARN__};
			    unless (eval "sub { s\a$k\a$v\a }; 1") {
				print $OUT "Can't alias $k to $v: $@@\n"; 
				delete $alias{$k};
				next CMD;
			    } 
			    @@keys = ($k);
			} 
			else {
			    @@keys = ($cmd);
			} 
			for my $k (@@keys) {
			    if ((my $v = $alias{$k}) =~ ss\a$k\a(.*)\a$1) {
				print $OUT "$k\t= $1\n";
			    } 
			    elsif (defined $alias{$k}) {
d1098 3
a1100 5
			    } 
			    else {
				print "No alias for $k\n";
			    } 
			}
a1108 1
			fix_less();
d1112 1
a1112 2
				open(OUT,">&STDOUT") # XXX: lost message
				    || &warn("Can't restore DB::OUT");
d1117 1
a1117 2
				open(OUT,">&STDOUT") # XXX: lost message
				    || &warn("Can't restore DB::OUT");
d1122 1
a1122 1
			    && ("" eq $SIG{PIPE}  ||  "DEFAULT" eq $SIG{PIPE});
d1127 1
a1127 2
			redo PIPE; 
		    };
d1142 5
a1146 18
		    $? = 0;  
		    # we cannot warn here: the handle is missing --tchrist
		    close(OUT) || print SAVEOUT "\nCan't close DB::OUT\n";

		    # most of the $? crud was coping with broken cshisms
		    if ($?) {
			print SAVEOUT "Pager `$pager' failed: ";
			if ($? == -1) {
			    print SAVEOUT "shell returned -1\n";
			} elsif ($? >> 8) {
			    print SAVEOUT 
			      ( $? & 127 ) ? " (SIG#".($?&127).")" : "", 
			      ( $? & 128 ) ? " -- core dumped" : "", "\n";
			} else {
			    print SAVEOUT "status ", ($? >> 8), "\n";
			} 
		    } 

d1149 1
a1149 1
		    $SIG{PIPE} = "DEFAULT" if $SIG{PIPE} eq \&DB::catch;
d1234 1
a1234 3
    # 'my' would make it visible from user code
    #    but so does local! --tchrist  
    local @@res;			
d1236 3
a1238 3
	local $otrace = $trace;
	local $osingle = $single;
	local $od = $^D;
d1267 1
a1267 1
      $had_breakpoints{$file} |= 1;
d1295 1
a1295 1
  $had_breakpoints{$filename} |= 1;
d1299 1
a1299 1
    $dbline{$key} = ${$postponed_file{$filename}}{$key};
a1414 14
sub unbalanced { 
    # i hate using globals!
    $balanced_brace_re ||= qr{ 
	^ \{
	      (?:
		 (?> [^{}] + )    	    # Non-parens without backtracking
	       |
		 (??{ $balanced_brace_re }) # Group with matching parens
	      ) *
	  \} $
   }x;
   return $_[0] !~ m/$balanced_brace_re/;
}

d1423 1
a1423 1
    # some non-Unix systems can do system() but have problems with fork().
a1427 2

    # XXX: using csh or tcsh destroys sigint retvals!
d1431 5
a1435 14
    close(SAVEIN); 
    close(SAVEOUT);


    # most of the $? crud was coping with broken cshisms
    if ($? >> 8) {
	&warn("(Command exited ", ($? >> 8), ")\n");
    } elsif ($?) { 
	&warn( "(Command died of SIG#",  ($? & 127),
	    (($? & 128) ? " -- core dumped" : "") , ")", "\n");
    } 

    return $?;

d1452 1
a1452 1
	    eval "require Term::Rendezvous;" or die;
d1521 1
a1521 9
  if (ref $OUT and UNIVERSAL::isa($OUT, 'IO::Socket::INET')) {
    print $OUT @@_;
    my $stuff;
    $IN->recv( $stuff, 2048 );  # XXX: what's wrong with sysread?
    $stuff;
  }
  else {
    $term->readline(@@_);
  }
d1535 2
a1536 2
	and defined ${$optionVars{$opt}}) {
	$val = ${$optionVars{$opt}};
d1543 1
a1543 1
	     and not defined ${$optionVars{$opt}}) {
d1553 2
a1554 10
    # too dangerous to let intuitive usage overwrite important things
    # defaultion should never be the default
    my %opt_needs_val = map { ( $_ => 1 ) } qw{
        arrayDepth hashDepth LineInfo maxTraceLen ornaments
        pager quote ReadLine recallCommand RemotePort ShellBang TTY
    };
    while (length) {
	my $val_defaulted;
	s/^\s+// && next;
	s/^(\w+)(\W?)// or print($OUT "Invalid option `$_'\n"), last;
d1562 1
a1562 2
	    $val_defaulted = 1;
	    $val = "1";  #  this is an evil default; make 'em set it!
d1564 1
a1564 6

            if (s/ (["']) ( (?: \\. | (?! \1 ) [^\\] )* ) \1 //x) { 
                my $quote = $1;
                ($val = $2) =~ s/\\([$quote\\])/$1/g;
	    } else { 
		s/^(\S*)//;
a1565 4
		print OUT qq(Option better cleared using $opt=""\n)
		    unless length $val;
	    }

d1570 2
a1571 1
	    ($val = $1) =~ s/\\([\\$end])/$1/g;
d1573 20
a1592 35

	my $option;
	my $matches = grep( /^\Q$opt/  && ($option = $_),  @@options  )
		   || grep( /^\Q$opt/i && ($option = $_),  @@options  );

	print($OUT "Unknown option `$opt'\n"), next 	unless $matches;
	print($OUT "Ambiguous option `$opt'\n"), next 	if $matches > 1;

       if ($opt_needs_val{$option} && $val_defaulted) {
	    print $OUT "Option `$opt' is non-boolean.  Use `O $option=VAL' to set, `O $option?' to query\n";
	    next;
	} 

	$option{$option} = $val if defined $val;

	eval qq{
		local \$frame = 0; 
		local \$doret = -2; 
	        require '$optionRequire{$option}';
		1;
	 } || die  # XXX: shouldn't happen
	    if  defined $optionRequire{$option}	    &&
	        defined $val;

	${$optionVars{$option}} = $val 	    
	    if  defined $optionVars{$option}        &&
		defined $val;

	&{$optionAction{$option}} ($val)    
	    if defined $optionAction{$option}	    &&
               defined &{$optionAction{$option}}    &&
               defined $val;

	# Not $rcfile
	dump_option($option) 	unless $OUT eq \*STDERR; 
d1599 1
a1599 1
  $ENV{"${stem}_n"} = @@list;
d1604 1
a1604 1
    $ENV{"${stem}_$i"} = $val;
d1611 1
a1611 1
  my $n = delete $ENV{"${stem}_n"};
d1614 1
a1614 1
    $val = delete $ENV{"${stem}_$i"};
a1668 8
sub RemotePort {
    if ($term) {
        &warn("Too late to set RemotePort, enabled on next 'R'!\n") if @@_;
    }
    $remoteport = shift if @@_;
    $remoteport;
}

d1670 1
a1670 1
    if (${$term->Features}{tkRunning}) {
d1732 1
a1732 1
    $slave_editor = ($stream =~ /^\|/);
d1750 2
a1751 2
    if (defined ${ $_ . '::VERSION' }) {
      $version{$file} = "${ $_ . '::VERSION' } from ";
a1758 4
    # XXX: make sure these are tabs between the command and explantion,
    #      or print_help will screw up your formatting if you have
    #      eeevil ornaments enabled.  This is an insane mess.

a1770 1
B<l> I<\$var>		List first window of lines from subroutine referenced by I<\$var>.
d1775 1
a1775 7
B<f> I<filename>	Switch to viewing I<filename>. File must be already loaded.
		I<filename> may be either the full name of the file, or a regular
		expression matching the full file name:
		B<f> I</home/me/foo.pl> and B<f> I<oo\\.> may access the same file.
		Evals (with saved bodies) are considered to be filenames:
		B<f> I<(eval 7)> and B<f> I<eval 7\\b> access the body of the 7th eval
		(in the order of execution).
a1786 1
B<b> I<\$var>		Set breakpoint at first line of subroutine referenced by I<\$var>.
d1796 1
a1796 2
		Set an action to be done before the I<line> is executed;
		I<line> defaults to the current execution line.
d1799 1
a1799 2
		execute line.
B<a> [I<line>]	Delete the action for I<line>.
d1810 26
a1835 2

B<<> ?			List Perl commands to run before each prompt.
a1837 1
B<>> ?			List Perl commands to run after each prompt.
d1839 1
a1839 1
B<>>B<>> I<expr>		Add to the list of Perl commands to run after each prompt.
a1840 2
B<{> ?			List debugger commands to run before each prompt.
B<<> I<expr>		Define Perl command to run before each prompt.
a1861 33

B<O> [I<opt>] ...	Set boolean option to true
B<O> [I<opt>B<?>]	Query options
B<O> [I<opt>B<=>I<val>] [I<opt>=B<\">I<val>B<\">] ... 
		Set options.  Use quotes in spaces in value.
    I<recallCommand>, I<ShellBang>	chars used to recall command or spawn shell;
    I<pager>			program for output of \"|cmd\";
    I<tkRunning>			run Tk while prompting (with ReadLine);
    I<signalLevel> I<warnLevel> I<dieLevel>	level of verbosity;
    I<inhibit_exit>		Allows stepping off the end of the script.
    I<ImmediateStop>		Debugger should stop as early as possible.
    I<RemotePort>			Remote hostname:port for remote debugging
  The following options affect what happens with B<V>, B<X>, and B<x> commands:
    I<arrayDepth>, I<hashDepth> 	print only first N elements ('' for all);
    I<compactDump>, I<veryCompact> 	change style of array and hash dump;
    I<globPrint> 			whether to print contents of globs;
    I<DumpDBFiles> 		dump arrays holding debugged files;
    I<DumpPackages> 		dump symbol tables of packages;
    I<DumpReused> 			dump contents of \"reused\" addresses;
    I<quote>, I<HighBit>, I<undefPrint> 	change style of string dump;
    I<bareStringify> 		Do not print the overload-stringified value;
  Other options include:
    I<PrintRet>		affects printing of return value after B<r> command,
    I<frame>		affects printing messages on entry and exit from subroutines.
    I<AutoTrace>	affects printing messages on every possible breaking point.
    I<maxTraceLen>	gives maximal length of evals/args listed in stack trace.
    I<ornaments> 	affects screen appearance of the command line.
	During startup options are initialized from \$ENV{PERLDB_OPTS}.
	You can put additional initialization options I<TTY>, I<noTTY>,
	I<ReadLine>, I<NonStop>, and I<RemotePort> there (or use
	`B<R>' after you set them).

B<q> or B<^D>		Quit. Set B<\$DB::finished = 0> to debug global destruction.
d1864 1
a1864 7
B<$doccmd> I<manpage>	Runs the external doc viewer B<$doccmd> command on the 
		named Perl I<manpage>, or on B<$doccmd> itself if omitted.
		Set B<\$DB::doccmd> to change viewer.

Type `|h' for a paged display if this was too hard to read.

"; # Fix balance of vi % matching: } }}
d1866 1
d1872 1
a1872 1
  B<f> I<filename>  View source in file         <B<CR>/B<Enter>>  Repeat last B<n> or B<s>
d1877 2
a1878 1
  B<<>[B<<>]|B<{>[B<{>]|B<>>[B<>>] [I<cmd>] Do pre/post-prompt B<b> [I<ln>|I<event>|I<sub>] [I<cnd>] Set breakpoint
d1883 1
a1883 1
  B<|>[B<|>]I<db_cmd>  Send output to pager        B<$psh>\[B<$psh>\] I<syscmd> Run cmd in a subprocess
a1890 1
For more help, type B<h> I<cmd_letter>, or run B<$doccmd perldebug> for all docs.
d1892 1
a1892 1
				# ')}}; # Fix balance of vi % matching
d1896 6
a1901 59
    local $_ = shift;

    # Restore proper alignment destroyed by eeevil I<> and B<>
    # ornaments: A pox on both their houses!
    #
    # A help command will have everything up to and including
    # the first tab sequence paddeed into a field 16 (or if indented 20)
    # wide.  If it's wide than that, an extra space will be added.
    s{
	^ 		    	# only matters at start of line
	  ( \040{4} | \t )*	# some subcommands are indented
	  ( < ? 		# so <CR> works
	    [BI] < [^\t\n] + )  # find an eeevil ornament
	  ( \t+ )		# original separation, discarded
	  ( .* )		# this will now start (no earlier) than 
				# column 16
    } {
	my($leadwhite, $command, $midwhite, $text) = ($1, $2, $3, $4);
	my $clean = $command;
	$clean =~ s/[BI]<([^>]*)>/$1/g;  
    # replace with this whole string:
	(length($leadwhite) ? " " x 4 : "")
      . $command
      . ((" " x (16 + (length($leadwhite) ? 4 : 0) - length($clean))) || " ")
      . $text;

    }mgex;

    s{				# handle bold ornaments
	B < ( [^>] + | > ) >
    } {
	  $Term::ReadLine::TermCap::rl_term_set[2] 
	. $1
	. $Term::ReadLine::TermCap::rl_term_set[3]
    }gex;

    s{				# handle italic ornaments
	I < ( [^>] + | > ) >
    } {
	  $Term::ReadLine::TermCap::rl_term_set[0] 
	. $1
	. $Term::ReadLine::TermCap::rl_term_set[1]
    }gex;

    print $OUT $_;
}

sub fix_less {
    return if defined $ENV{LESS} && $ENV{LESS} =~ /r/;
    my $is_less = $pager =~ /\bless\b/;
    if ($pager =~ /\bmore\b/) { 
	my @@st_more = stat('/usr/bin/more');
	my @@st_less = stat('/usr/bin/less');
	$is_less = @@st_more    && @@st_less 
		&& $st_more[0] == $st_less[0] 
		&& $st_more[1] == $st_less[1];
    }
    # changes environment!
    $ENV{LESS} .= 'r' 	if $is_less;
a1951 1

a1953 1

a2010 15
sub CvGV_name {
  my $in = shift;
  my $name = CvGV_name_or_bust($in);
  defined $name ? $name : $in;
}

sub CvGV_name_or_bust {
  my $in = shift;
  return if $skipCvGV;		# Backdoor to avoid problems if XS broken...
  $in = \&$in;			# Hard reference...
  eval {require Devel::Peek; 1} or return;
  my $gv = Devel::Peek::CvGV($in) or return;
  *$gv{PACKAGE} . '::' . *$gv{NAME};
}

d2013 1
a2014 7
    return unless defined &$subr;
    my $name = CvGV_name_or_bust($subr);
    my $data;
    $data = $sub{$name} if defined $name;
    return $data if defined $data;

    # Old stupid way...
d2039 2
a2040 2
  for $name (grep {defined &{${"${class}::"}{$_}}} 
	     sort keys %{"${class}::"}) {
d2045 1
a2045 1
  for $name (@@{"${class}::ISA"}) {
a2050 63
sub setman { 
    $doccmd = $^O !~ /^(?:MSWin32|VMS|os2|dos|amigaos|riscos|MacOS)\z/s
		? "man"             # O Happy Day!
		: "perldoc";        # Alas, poor unfortunates
}

sub runman {
    my $page = shift;
    unless ($page) {
	&system("$doccmd $doccmd");
	return;
    } 
    # this way user can override, like with $doccmd="man -Mwhatever"
    # or even just "man " to disable the path check.
    unless ($doccmd eq 'man') {
	&system("$doccmd $page");
	return;
    } 

    $page = 'perl' if lc($page) eq 'help';

    require Config;
    my $man1dir = $Config::Config{'man1dir'};
    my $man3dir = $Config::Config{'man3dir'};
    for ($man1dir, $man3dir) { s#/[^/]*\z## if /\S/ } 
    my $manpath = '';
    $manpath .= "$man1dir:" if $man1dir =~ /\S/;
    $manpath .= "$man3dir:" if $man3dir =~ /\S/ && $man1dir ne $man3dir;
    chop $manpath if $manpath;
    # harmless if missing, I figure
    my $oldpath = $ENV{MANPATH};
    $ENV{MANPATH} = $manpath if $manpath;
    my $nopathopt = $^O =~ /dunno what goes here/;
    if (system($doccmd, 
		# I just *know* there are men without -M
		(($manpath && !$nopathopt) ? ("-M", $manpath) : ()),  
	    split ' ', $page) )
    {
	unless ($page =~ /^perl\w/) {
	    if (grep { $page eq $_ } qw{ 
		5004delta 5005delta amiga api apio book boot bot call compile
		cygwin data dbmfilter debug debguts delta diag doc dos dsc embed
		faq faq1 faq2 faq3 faq4 faq5 faq6 faq7 faq8 faq9 filter fork
		form func guts hack hist hpux intern ipc lexwarn locale lol mod
		modinstall modlib number obj op opentut os2 os390 pod port 
		ref reftut run sec style sub syn thrtut tie toc todo toot tootc
		trap unicode var vms win32 xs xstut
	      }) 
	    {
		$page =~ s/^/perl/;
		system($doccmd, 
			(($manpath && !$nopathopt) ? ("-M", $manpath) : ()),  
			$page);
	    }
	}
    } 
    if (defined $oldpath) {
	$ENV{MANPATH} = $manpath;
    } else {
	delete $ENV{MANPATH};
    } 
} 

d2088 1
a2088 1
    ($text, "^\Q${'package'}::\E([^:]+)\$");
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d28 1
a28 1
# The array @@{$main::{'_<'.$filename}} is the line-by-line contents of
d37 1
a37 1
# The scalar ${'_<'.$filename} contains $filename.
a403 6
  } elsif ($^O eq 'MacOS') {
    if ($MacPerl::Version !~ /MPW/) {
      $console = "Dev:Console:Perl Debug"; # Separate window for application
    } else {
      $console = "Dev:Console";
    }
d429 1
a429 1
    if (!$OUT) { die "Unable to connect to remote host: $remoteport\n"; }
d620 1
a620 1
                   $cmd =~ /^q$/ && ($fall_off_end = 1) && exit $?;
d902 1
a902 1
			my $cond = length $3 ? $3 : '1';
d904 1
a904 1
			$subname =~ s/\'/::/g;
d913 2
a914 2
			$cond = length $2 ? $2 : '1';
			$subname =~ s/\'/::/g;
d934 1
a934 1
			$cond = length $2 ? $2 : '1';
d944 2
a945 6
                        if ($dbline[$i] == 0) {
                            print $OUT "Line $i not breakable.\n";
                        } else {
			    $dbline{$i} =~ s/^[^\0]*//;
			    delete $dbline{$i} if $dbline{$i} eq '';
                        }
d983 1
a983 1
			    print $OUT "All < actions cleared.\n";
d989 1
a989 1
				print $OUT "No pre-prompt Perl actions.\n";
d992 1
a992 1
			    print $OUT "Perl commands run before each prompt:\n";
d994 1
a994 1
				print $OUT "\t< -- $action\n";
d1002 1
a1002 1
			    print $OUT "All > actions cleared.\n";
d1008 1
a1008 1
				print $OUT "No post-prompt Perl actions.\n";
d1011 1
a1011 1
			    print $OUT "Perl commands run after each prompt:\n";
d1013 1
a1013 1
				print $OUT "\t> -- $action\n";
d1021 1
a1021 1
			    print $OUT "{{ is now a debugger command\n",
d1030 1
a1030 1
			    print $OUT "All { actions cleared.\n";
d1036 1
a1036 1
				print $OUT "No pre-prompt debugger actions.\n";
d1039 1
a1039 1
			    print $OUT "Debugger commands run before each prompt:\n";
d1041 1
a1041 1
				print $OUT "\t{ -- $action\n";
d1046 1
a1046 1
			    print $OUT "{ is now a debugger command\n",
d1429 1
a1429 1
       $fall_off_end = 1 unless defined $cmd; # Emulate `q' on EOF
a1509 1
	{ ($evalarg) = $evalarg =~ /(.*)/s; }
d1701 2
a1806 1
  local $.;
d1818 1
a1818 1
    $OUT->write(join('', @@_));
d2164 2
a2165 2
B<x> I<expr>		Evals expression in list context, dumps the result.
B<m> I<expr>		Evals expression in list context, prints methods callable
d2260 1
a2260 1
  B<x>|B<m> I<expr>	Evals expr in list context, dumps the result or lists methods.
d2683 1
a2683 2
  $finished = 1 if $inhibit_exit;      # So that some keys may be disabled.
  $fall_off_end = 1 unless $inhibit_exit;
d2685 2
a2686 2
  $DB::single = !$fall_off_end && !$runnonstop;
  DB::fake::at_exit() unless $fall_off_end or $runnonstop;
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a3 2
$VERSION = 1.19;
$header  = "perl5db.pl version $VERSION";
d5 2
a6 32
# It is crucial that there is no lexicals in scope of `eval ""' down below
sub eval {
    # 'my' would make it visible from user code
    #    but so does local! --tchrist  [... into @@DB::res, not @@res. IZ]
    local @@res;
    {
	local $otrace = $trace;
	local $osingle = $single;
	local $od = $^D;
	{ ($evalarg) = $evalarg =~ /(.*)/s; }
	@@res = eval "$usercontext $evalarg;\n"; # '\n' for nice recursive debug
	$trace = $otrace;
	$single = $osingle;
	$^D = $od;
    }
    my $at = $@@;
    local $saved[0];		# Preserve the old value of $@@
    eval { &DB::save };
    if ($at) {
	local $\ = '';
	print $OUT $at;
    } elsif ($onetimeDump) {
      if ($onetimeDump eq 'dump')  {
        local $option{dumpDepth} = $onetimedumpDepth 
          if defined $onetimedumpDepth;
	dumpit($OUT, \@@res);
      } elsif ($onetimeDump eq 'methods') {
	methods($res[0]) ;
      }
    }
    @@res;
}
a7 2
# After this point it is safe to introduce lexicals
# However, one should not overdo it: leave as much control from outside as possible
a11 3
# Before venturing further into these twisty passages, it is 
# wise to read the perldebguts man page or risk the ire of dragons.
#
d13 1
a13 1
# a &DB::DB(); in front of every place that can have a
d28 2
a29 2
# The array @@{$main::{'_<'.$filename}} (herein called @@dbline) is the
# line-by-line contents of $filename.
d31 5
a35 6
# The hash %{'_<'.$filename} (herein called %dbline) contains
# breakpoints and action (it is keyed by line number), and individual
# entries are settable (as opposed to the whole hash). Only true/false
# is important to the interpreter, though the values used by
# perl5db.pl have the form "$break_condition\0$action". Values are
# magical in numeric context.
d85 1
d122 1
a122 1
#	now only `q' exits debugger (overwritable on $inhibit_exit).
d132 1
a132 1
#	'l -' is a synonym for `-'.
d150 1
a150 1
#   + Added bare minimal security checks on perldb rc files, plus
d158 1
a158 1
#     and needs a lot of work at restructuring.  It's also misindented
d167 1
a167 1
#     tricking Perl into thinking you weren't calling a debugger command!
d190 1
a190 97
#
# Changes: 1.08: Apr 25, 2001  Jon Eveland <jweveland@@yahoo.com>
#   BUG FIX:
#   + This patch to perl5db.pl cleans up formatting issues on the help
#     summary (h h) screen in the debugger.  Mostly columnar alignment
#     issues, plus converted the printed text to use all spaces, since
#     tabs don't seem to help much here.
#
# Changes: 1.09: May 19, 2001  Ilya Zakharevich <ilya@@math.ohio-state.edu>
#   0) Minor bugs corrected;
#   a) Support for auto-creation of new TTY window on startup, either
#      unconditionally, or if started as a kid of another debugger session;
#   b) New `O'ption CreateTTY
#       I<CreateTTY>       bits control attempts to create a new TTY on events:
#                          1: on fork()   2: debugger is started inside debugger
#                          4: on startup
#   c) Code to auto-create a new TTY window on OS/2 (currently one
#      extra window per session - need named pipes to have more...);
#   d) Simplified interface for custom createTTY functions (with a backward
#      compatibility hack); now returns the TTY name to use; return of ''
#      means that the function reset the I/O handles itself;
#   d') Better message on the semantic of custom createTTY function;
#   e) Convert the existing code to create a TTY into a custom createTTY
#      function;
#   f) Consistent support for TTY names of the form "TTYin,TTYout";
#   g) Switch line-tracing output too to the created TTY window;
#   h) make `b fork' DWIM with CORE::GLOBAL::fork;
#   i) High-level debugger API cmd_*():
#      cmd_b_load($filenamepart)            # b load filenamepart
#      cmd_b_line($lineno [, $cond])        # b lineno [cond]
#      cmd_b_sub($sub [, $cond])            # b sub [cond]
#      cmd_stop()                           # Control-C
#      cmd_d($lineno)                       # d lineno (B)
#      The cmd_*() API returns FALSE on failure; in this case it outputs
#      the error message to the debugging output.
#   j) Low-level debugger API
#      break_on_load($filename)             # b load filename
#      @@files = report_break_on_load()      # List files with load-breakpoints
#      breakable_line_in_filename($name, $from [, $to])
#                                           # First breakable line in the
#                                           # range $from .. $to.  $to defaults
#                                           # to $from, and may be less than $to
#      breakable_line($from [, $to])        # Same for the current file
#      break_on_filename_line($name, $lineno [, $cond])
#                                           # Set breakpoint,$cond defaults to 1
#      break_on_filename_line_range($name, $from, $to [, $cond])
#                                           # As above, on the first
#                                           # breakable line in range
#      break_on_line($lineno [, $cond])     # As above, in the current file
#      break_subroutine($sub [, $cond])     # break on the first breakable line
#      ($name, $from, $to) = subroutine_filename_lines($sub)
#                                           # The range of lines of the text
#      The low-level API returns TRUE on success, and die()s on failure.
#
# Changes: 1.10: May 23, 2001  Daniel Lewart <d-lewart@@uiuc.edu>
#   BUG FIXES:
#   + Fixed warnings generated by "perl -dWe 42"
#   + Corrected spelling errors
#   + Squeezed Help (h) output into 80 columns
#
# Changes: 1.11: May 24, 2001  David Dyck <dcd@@tc.fluke.com>
#   + Made "x @@INC" work like it used to
#
# Changes: 1.12: May 24, 2001  Daniel Lewart <d-lewart@@uiuc.edu>
#   + Fixed warnings generated by "O" (Show debugger options)
#   + Fixed warnings generated by "p 42" (Print expression)
# Changes: 1.13: Jun 19, 2001 Scott.L.Miller@@compaq.com
#   + Added windowSize option 
# Changes: 1.14: Oct  9, 2001 multiple
#   + Clean up after itself on VMS (Charles Lane in 12385)
#   + Adding "@@ file" syntax (Peter Scott in 12014)
#   + Debug reloading selfloaded stuff (Ilya Zakharevich in 11457)
#   + $^S and other debugger fixes (Ilya Zakharevich in 11120)
#   + Forgot a my() declaration (Ilya Zakharevich in 11085)
# Changes: 1.15: Nov  6, 2001 Michael G Schwern <schwern@@pobox.com>
#   + Updated 1.14 change log
#   + Added *dbline explainatory comments
#   + Mentioning perldebguts man page
# Changes: 1.16: Feb 15, 2002 Mark-Jason Dominus <mjd@@plover.com>
#	+ $onetimeDump improvements
# Changes: 1.17: Feb 20, 2002 Richard Foley <richard.foley@@rfi.net>
#   Moved some code to cmd_[.]()'s for clarity and ease of handling,
#   rationalised the following commands and added cmd_wrapper() to 
#   enable switching between old and frighteningly consistent new 
#   behaviours for diehards: 'o CommandSet=pre580' (sigh...)
#     a(add),       A(del)            # action expr   (added del by line)
#   + b(add),       B(del)            # break  [line] (was b,D)
#   + w(add),       W(del)            # watch  expr   (was W,W) added del by expr
#   + h(summary), h h(long)           # help (hh)     (was h h,h)
#   + m(methods),   M(modules)        # ...           (was m,v)
#   + o(option)                       # lc            (was O)
#   + v(view code), V(view Variables) # ...           (was w,V)
# Changes: 1.18: Mar 17, 2002 Richard Foley <richard.foley@@rfi.net>
#   + fixed missing cmd_O bug
# Changes: 1.19: Mar 29, 2002 Spider Boardman
#   + Added missing local()s -- DB::DB is called recursively.
# 
d221 1
a221 2
@@options     = qw(hashDepth arrayDepth CommandSet dumpDepth
                  DumpDBFiles DumpPackages DumpReused
d227 2
a228 2
		  ImmediateStop bareStringify CreateTTY
		  RemotePort windowSize);
a232 1
		 CommandSet => \$CommandSet,
d239 1
a239 2
		 UsageOnly	=> \$dumpvar::usageOnly,
		 CreateTTY	=> \$CreateTTY,
a246 1
		 windowSize	=> \$window,
d277 2
a278 2
$warnLevel	= 1	unless defined $warnLevel;
$dieLevel	= 1	unless defined $dieLevel;
a282 2
$CreateTTY	= 3	unless defined $CreateTTY;
$CommandSet = '580'	unless defined $CommandSet;
d288 6
a293 6
pager(
      defined $ENV{PAGER}              ? $ENV{PAGER} :
      eval { require Config } && 
        defined $Config::Config{pager} ? $Config::Config{pager}
                                       : 'more'
     ) unless defined $pager;
a296 1
sethelp();
a297 12
$ini_pids = $ENV{PERLDB_PIDS};
if (defined $ENV{PERLDB_PIDS}) {
  $pids = "[$ENV{PERLDB_PIDS}]";
  $ENV{PERLDB_PIDS} .= "->$$";
  $term_pid = -1;
} else {
  $ENV{PERLDB_PIDS} = "$$";
  $pids = "{pid=$$}";
  $term_pid = $$;
}
$pidprompt = '';
*emacs = $slave_editor if $slave_editor;	# May be used in afterinit()...
a360 7
if ( not defined &get_fork_TTY and defined $ENV{TERM} and $ENV{TERM} eq 'xterm'
     and defined $ENV{WINDOWID} and defined $ENV{DISPLAY} ) { # _inside_ XTERM?
    *get_fork_TTY = \&xterm_get_fork_TTY;
} elsif ($^O eq 'os2') {
    *get_fork_TTY = \&os2_get_fork_TTY;
}

a417 4
  if ($^O eq 'NetWare') {
	$console = undef;
  }

d437 5
a441 7
  } else {
    create_IN_OUT(4) if $CreateTTY & 4;
    if ($console) {
      my ($i, $o) = split /,/, $console;
      $o = $i unless defined $o;
      open(IN,"+<$i") || open(IN,"<$i") || open(IN,"<&STDIN");
      open(OUT,"+>$o") || open(OUT,">$o") || open(OUT,">&STDERR")
d443 1
a443 1
    } elsif (not defined $console) {
d449 3
a451 1
    $IN = \*IN, $OUT = \*OUT if $console or not defined $console;
d453 1
a453 1
  my $previous = select($OUT);
d455 1
a455 1
  select($previous);
d460 2
d464 5
a468 11
    local $\ = '';
    local $, = '';
    if ($term_pid eq '-1') {
      print $OUT "\nDaughter DB session started...\n";
    } else {
      print $OUT "\nLoading DB routines from $header\n";
      print $OUT ("Editor support ",
		  $slave_editor ? "enabled" : "available",
		  ".\n");
      print $OUT "\nEnter h or `h h' for help, or `$doccmd perldebug' for more help.\n\n";
    }
d502 3
a504 3
    local($package, $filename, $line) = caller;
    local $filename_ini = $filename;
    local $usercontext = '($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;' .
d507 8
a514 16

    # we need to check for pseudofiles on Mac OS (these are files
    # not attached to a filename, but instead stored in Dev:Pseudo)
    if ($^O eq 'MacOS' && $#dbline < 0) {
	$filename_ini = $filename = 'Dev:Pseudo';
	*dbline = $main::{'_<' . $filename};
    }

    local $max = $#dbline;
    if ($dbline{$line} && (($stop,$action) = split(/\0/,$dbline{$line}))) {
		if ($stop eq '1') {
			$signal |= 1;
		} elsif ($stop) {
			$evalarg = "\$DB::signal |= 1 if do {$stop}"; &eval;
			$dbline{$line} =~ s/;9($|\0)/$1/;
		}
d519 7
a525 7
		$evalarg = $to_watch[$n];
		local $onetimeDump;	# Do not output results
		my ($val) = &eval;	# Fix context (&eval is doing array)?
		$val = ( (defined $val) ? "'$val'" : 'undef' );
		if ($val ne $old_watch[$n]) {
		  $signal = 1;
		  print $OUT <<EOP;
d527 2
a528 2
	old value:\t$old_watch[$n]
	new value:\t$val
d530 2
a531 2
		  $old_watch[$n] = $val;
		}
d543 1
a543 1
	    print_lineinfo($position);
d561 2
a562 2
			$prefix = "";
			$infix = ":\t";
d564 2
a565 2
			$infix = "):\t";
			$position = "$prefix$line$infix$dbline[$line]$after";
d568 1
a568 1
			print_lineinfo(' ' x $stack_depth, "$line:\t$dbline[$line]$after");
d570 1
a570 1
			print_lineinfo($position);
d573 10
a582 10
			last if $dbline[$i] =~ /^\s*[\;\}\#\n]/;
			last if $signal;
			$after = ($dbline[$i] =~ /\n$/ ? '' : "\n");
			$incr_pos = "$prefix$i$infix$dbline[$i]$after";
			$position .= $incr_pos;
			if ($frame) {
				print_lineinfo(' ' x $stack_depth, "$i:\t$dbline[$i]$after");
			} else {
				print_lineinfo($incr_pos);
			}
d588 10
a597 10
	  local $level = $level + 1;
	  foreach $evalarg (@@$pre) {
	    &eval;
	  }
	  print $OUT $stack_depth . " levels deep in subroutine calls!\n"
              if $single & 4;
		$start = $line;
		$incr = -1;		# for backward motion.
		@@typeahead = (@@$pretype, @@typeahead);
    CMD:
d599 4
a602 3
	       ($term_pid == $$ or resetterm(1)),
	       defined ($cmd=&readline("$pidprompt  DB" . ('<' x $level) .
				       ($#hist+1) . ('>' x $level) . " "))) 
d617 8
a624 9
					# squelch the sigmangler
					local $SIG{__DIE__};
					local $SIG{__WARN__};
					eval "\$cmd =~ $alias{$i}";
					if ($@@) {
                                                local $\ = '';
						print $OUT "Couldn't evaluate `$i' alias: $@@";
						next CMD;
					} 
d626 21
a646 5
                    $cmd =~ /^q$/ && do {
                        $fall_off_end = 1;
                        clean_ENV();
                        exit $?;
                    };
a648 1
			local $\ = '';
a653 2
			local $\ = '';
			local $, = '';
d660 2
d674 1
a674 4
                           eval { &main::dumpvar($packname,
                                                 defined $option{dumpDepth}
                                                  ? $option{dumpDepth} : -1,
                                                 @@vars) };
d684 1
a684 6
			$onetimeDump = 'dump'; 
                        # handle special  "x 3 blah" syntax
                        if ($cmd =~ s/^\s*(\d+)(?=\s)/ /) {
                          $onetimedumpDepth = $1;
                        }
                      };
d693 1
a693 1
			    print $OUT "The old f command is now the r command.\n"; # hint
d718 34
d758 1
a758 1
			print_lineinfo($position);
d760 6
d771 215
a985 7
			# rjsf ->
		  $cmd =~ /^([aAbBhlLMoOvwW])\b\s*(.*)/s && do { 
				&cmd_wrapper($1, $2, $line); 
				next CMD; 
			};
			# <- rjsf
		  $cmd =~ /^\<\<\s*(.*)/ && do { # \<\< for CPerl sake: not HERE
d1063 16
a1078 22
                   $cmd =~ /^y(?:\s+(\d*)\s*(.*))?$/ && do {
                       eval { require PadWalker; PadWalker->VERSION(0.08) }
                         or &warn($@@ =~ /locate/
                            ? "PadWalker module not found - please install\n"
                            : $@@)
                          and next CMD;
                       do 'dumpvar.pl' unless defined &main::dumpvar;
                       defined &main::dumpvar
                          or print $OUT "dumpvar.pl not available.\n"
                          and next CMD;
                       my @@vars = split(' ', $2 || '');
                       my $h = eval { PadWalker::peek_my(($1 || 0) + 1) };
                       $@@ and $@@ =~ s/ at .*//, &warn($@@), next CMD;
                       my $savout = select($OUT);
                       dumpvar::dumplex($_, $h->{$_}, 
                                       defined $option{dumpDepth}
                                       ? $option{dumpDepth} : -1,
                                       @@vars)
                           for sort keys %$h;
                       select($savout);
                       next CMD; };
                   $cmd =~ /^n$/ && do {
d1095 1
a1095 1
			if ($subname =~ /\D/) { # subroutine name
a1135 1
			push @@flags, '-T' if ${^TAINT};
d1159 1
a1159 1
			    if $file =~ /^\(\w*eval/;
a1203 2
			delete $ENV{PERLDB_PIDS}; # Restore ini state
			$ENV{PERLDB_PIDS} = $ini_pids if defined $ini_pids;
d1205 1
a1205 1
			exec($^X, '-d', @@flags, @@script, ($slave_editor ? '-emacs' : ()), @@ARGS) ||
d1211 12
a1222 2
		    $cmd =~ /^w\b\s*(.*)/s && do { &cmd_w($1); next CMD; };
		    $cmd =~ /^W\b\s*(.*)/s && do { &cmd_W($1); next CMD; };
d1334 2
a1335 1
			} elsif (my($k,$v) = ($cmd =~ /^(\S+)\s+(\S.*)/)) {
d1348 2
a1349 1
			} else {
a1363 7
                    $cmd =~ /^source\s+(.*\S)/ && do {
		      if (open my $fh, $1) {
			push @@cmdfhs, $fh;
		      } else {
			&warn("Can't execute `$1': $!\n");
		      }
		      next CMD; };
a1401 1
                $onetimedumpDepth = undef;
d1439 1
a1439 1
    $fall_off_end = 1 unless defined $cmd; # Emulate `q' on EOF
d1462 1
a1462 1
     ? ( print_lineinfo(' ' x ($stack_depth - 1), "in  "),
d1465 1
a1465 1
     : print_lineinfo(' ' x ($stack_depth - 1), "entering $sub$al\n")) if $frame;
d1470 1
a1470 1
	 ? ( print_lineinfo(' ' x $stack_depth, "out "), 
d1472 1
a1472 1
	 : print_lineinfo(' ' x $stack_depth, "exited $sub$al\n")) if $frame & 2;
a1473 1
	    local $\ = '';
d1489 1
a1489 1
	 ? (  print_lineinfo(' ' x $stack_depth, "out "),
d1491 1
a1491 1
	 : print_lineinfo(' ' x $stack_depth, "exited $sub$al\n")) if $frame & 2;
a1492 1
	    local $\ = '';
d1501 2
a1502 535
	$ret;
    }
}

### The API section

### Functions with multiple modes of failure die on error, the rest
### returns FALSE on error.
### User-interface functions cmd_* output error message.

### Note all cmd_[a-zA-Z]'s require $line, $dblineno as first arguments

my %set = ( # 
	'pre580'	=> {
		'a'	=> 'pre580_a', 
		'A'	=> 'pre580_null',
		'b'	=> 'pre580_b', 
		'B'	=> 'pre580_null',
		'd'	=> 'pre580_null',
		'D'	=> 'pre580_D',
		'h'	=> 'pre580_h',
		'M'	=> 'pre580_null',
		'O'	=> 'o',
		'o'	=> 'pre580_null',
		'v'	=> 'M',
		'w'	=> 'v',
		'W'	=> 'pre580_W',
	},
);

sub cmd_wrapper {
	my $cmd      = shift;
	my $line     = shift;
	my $dblineno = shift;

	# with this level of indirection we can wrap 
	# to old (pre580) or other command sets easily
	# 
	my $call = 'cmd_'.(
		$set{$CommandSet}{$cmd} || $cmd
	);
	# print "cmd_wrapper($cmd): $CommandSet($set{$CommandSet}{$cmd}) => call($call)\n";

	return &$call($line, $dblineno);
}

sub cmd_a {
	my $line   = shift || ''; # [.|line] expr
	my $dbline = shift; $line =~ s/^(\.|(?:[^\d]))/$dbline/;
	if ($line =~ /^\s*(\d*)\s*(\S.+)/) {
		my ($lineno, $expr) = ($1, $2);
		if (length $expr) {
			if ($dbline[$lineno] == 0) {
				print $OUT "Line $lineno($dbline[$lineno]) does not have an action?\n";
			} else {
				$had_breakpoints{$filename} |= 2;
				$dbline{$lineno} =~ s/\0[^\0]*//;
				$dbline{$lineno} .= "\0" . action($expr);
			}
		}
	} else {
		print $OUT "Adding an action requires an optional lineno and an expression\n"; # hint
	}
}

sub cmd_A {
	my $line   = shift || '';
	my $dbline = shift; $line =~ s/^\./$dbline/;
	if ($line eq '*') {
		eval { &delete_action(); 1 } or print $OUT $@@ and return;
	} elsif ($line =~ /^(\S.*)/) {
		eval { &delete_action($1); 1 } or print $OUT $@@ and return;
	} else {
		print $OUT "Deleting an action requires a line number, or '*' for all\n"; # hint
	}
}

sub delete_action {
  my $i = shift;
  if (defined($i)) {
		die "Line $i has no action .\n" if $dbline[$i] == 0;
		$dbline{$i} =~ s/\0[^\0]*//; # \^a
		delete $dbline{$i} if $dbline{$i} eq '';
	} else {
		print $OUT "Deleting all actions...\n";
		for my $file (keys %had_breakpoints) {
			local *dbline = $main::{'_<' . $file};
			my $max = $#dbline;
			my $was;
			for ($i = 1; $i <= $max ; $i++) {
					if (defined $dbline{$i}) {
							$dbline{$i} =~ s/\0[^\0]*//;
							delete $dbline{$i} if $dbline{$i} eq '';
					}
				unless ($had_breakpoints{$file} &= ~2) {
						delete $had_breakpoints{$file};
				}
			}
		}
	}
}

sub cmd_b {
	my $line   = shift; # [.|line] [cond]
	my $dbline = shift; $line =~ s/^\./$dbline/;
	if ($line =~ /^\s*$/) {
		&cmd_b_line($dbline, 1);
	} elsif ($line =~ /^load\b\s*(.*)/) {
		my $file = $1; $file =~ s/\s+$//;
		&cmd_b_load($file);
	} elsif ($line =~ /^(postpone|compile)\b\s*([':A-Za-z_][':\w]*)\s*(.*)/) {
		my $cond = length $3 ? $3 : '1';
		my ($subname, $break) = ($2, $1 eq 'postpone');
		$subname =~ s/\'/::/g;
		$subname = "${'package'}::" . $subname unless $subname =~ /::/;
		$subname = "main".$subname if substr($subname,0,2) eq "::";
		$postponed{$subname} = $break ? "break +0 if $cond" : "compile";
	} elsif ($line =~ /^([':A-Za-z_][':\w]*(?:\[.*\])?)\s*(.*)/) { 
		$subname = $1;
		$cond = length $2 ? $2 : '1';
		&cmd_b_sub($subname, $cond);
	} elsif ($line =~ /^(\d*)\s*(.*)/) { 
		$line = $1 || $dbline;
		$cond = length $2 ? $2 : '1';
		&cmd_b_line($line, $cond);
	} else {
		print "confused by line($line)?\n";
	}
}

sub break_on_load {
  my $file = shift;
  $break_on_load{$file} = 1;
  $had_breakpoints{$file} |= 1;
}

sub report_break_on_load {
  sort keys %break_on_load;
}

sub cmd_b_load {
  my $file = shift;
  my @@files;
  {
    push @@files, $file;
    push @@files, $::INC{$file} if $::INC{$file};
    $file .= '.pm', redo unless $file =~ /\./;
  }
  break_on_load($_) for @@files;
  @@files = report_break_on_load;
  local $\ = '';
  local $" = ' ';
  print $OUT "Will stop on load of `@@files'.\n";
}

$filename_error = '';

sub breakable_line {
  my ($from, $to) = @@_;
  my $i = $from;
  if (@@_ >= 2) {
    my $delta = $from < $to ? +1 : -1;
    my $limit = $delta > 0 ? $#dbline : 1;
    $limit = $to if ($limit - $to) * $delta > 0;
    $i += $delta while $dbline[$i] == 0 and ($limit - $i) * $delta > 0;
  }
  return $i unless $dbline[$i] == 0;
  my ($pl, $upto) = ('', '');
  ($pl, $upto) = ('s', "..$to") if @@_ >=2 and $from != $to;
  die "Line$pl $from$upto$filename_error not breakable\n";
}

sub breakable_line_in_filename {
  my ($f) = shift;
  local *dbline = $main::{'_<' . $f};
  local $filename_error = " of `$f'";
  breakable_line(@@_);
}

sub break_on_line {
  my ($i, $cond) = @@_;
  $cond = 1 unless @@_ >= 2;
  my $inii = $i;
  my $after = '';
  my $pl = '';
  die "Line $i$filename_error not breakable.\n" if $dbline[$i] == 0;
  $had_breakpoints{$filename} |= 1;
  if ($dbline{$i}) { $dbline{$i} =~ s/^[^\0]*/$cond/; }
  else { $dbline{$i} = $cond; }
}

sub cmd_b_line {
  eval { break_on_line(@@_); 1 } or do {
    local $\ = '';
    print $OUT $@@ and return;
  };
}

sub break_on_filename_line {
  my ($f, $i, $cond) = @@_;
  $cond = 1 unless @@_ >= 3;
  local *dbline = $main::{'_<' . $f};
  local $filename_error = " of `$f'";
  local $filename = $f;
  break_on_line($i, $cond);
}

sub break_on_filename_line_range {
  my ($f, $from, $to, $cond) = @@_;
  my $i = breakable_line_in_filename($f, $from, $to);
  $cond = 1 unless @@_ >= 3;
  break_on_filename_line($f,$i,$cond);
}

sub subroutine_filename_lines {
  my ($subname,$cond) = @@_;
  # Filename below can contain ':'
  find_sub($subname) =~ /^(.*):(\d+)-(\d+)$/;
}

sub break_subroutine {
  my $subname = shift;
  my ($file,$s,$e) = subroutine_filename_lines($subname) or
    die "Subroutine $subname not found.\n";
  $cond = 1 unless @@_ >= 2;
  break_on_filename_line_range($file,$s,$e,@@_);
}

sub cmd_b_sub {
  my ($subname,$cond) = @@_;
  $cond = 1 unless @@_ >= 2;
  unless (ref $subname eq 'CODE') {
    $subname =~ s/\'/::/g;
    my $s = $subname;
    $subname = "${'package'}::" . $subname
      unless $subname =~ /::/;
    $subname = "CORE::GLOBAL::$s"
      if not defined &$subname and $s !~ /::/ and defined &{"CORE::GLOBAL::$s"};
    $subname = "main".$subname if substr($subname,0,2) eq "::";
  }
  eval { break_subroutine($subname,$cond); 1 } or do {
    local $\ = '';
    print $OUT $@@ and return;
  }
}

sub cmd_B {
	my $line   = ($_[0] =~ /^\./) ? $dbline : shift || ''; 
	my $dbline = shift; $line =~ s/^\./$dbline/;
	if ($line eq '*') {
		eval { &delete_breakpoint(); 1 } or print $OUT $@@ and return;
	} elsif ($line =~ /^(\S.*)/) {
		eval { &delete_breakpoint($line || $dbline); 1 } or do {
                    local $\ = '';
                    print $OUT $@@ and return;
                };
	} else {
		print $OUT "Deleting a breakpoint requires a line number, or '*' for all\n"; # hint
	}
}

sub delete_breakpoint {
  my $i = shift;
  if (defined($i)) {
	  die "Line $i not breakable.\n" if $dbline[$i] == 0;
	  $dbline{$i} =~ s/^[^\0]*//;
	  delete $dbline{$i} if $dbline{$i} eq '';
  } else {
		  print $OUT "Deleting all breakpoints...\n";
		  for my $file (keys %had_breakpoints) {
					local *dbline = $main::{'_<' . $file};
					my $max = $#dbline;
					my $was;
					for ($i = 1; $i <= $max ; $i++) {
							if (defined $dbline{$i}) {
						$dbline{$i} =~ s/^[^\0]+//;
						if ($dbline{$i} =~ s/^\0?$//) {
								delete $dbline{$i};
						}
							}
					}
					if (not $had_breakpoints{$file} &= ~1) {
							delete $had_breakpoints{$file};
					}
		  }
		  undef %postponed;
		  undef %postponed_file;
		  undef %break_on_load;
	}
}

sub cmd_stop {			# As on ^C, but not signal-safy.
  $signal = 1;
}

sub cmd_h {
	my $line   = shift || '';
	if ($line  =~ /^h\s*/) {
		print_help($help);
	} elsif ($line =~ /^(\S.*)$/) { 
			# support long commands; otherwise bogus errors
			# happen when you ask for h on <CR> for example
			my $asked = $1;			# for proper errmsg
			my $qasked = quotemeta($asked); # for searching
			# XXX: finds CR but not <CR>
			if ($help =~ /^<?(?:[IB]<)$qasked/m) {
			  while ($help =~ /^(<?(?:[IB]<)$qasked([\s\S]*?)\n)(?!\s)/mg) {
			    print_help($1);
			  }
			} else {
			    print_help("B<$asked> is not a debugger command.\n");
			}
	} else {
			print_help($summary);
	}
}

sub cmd_l {
	my $line = shift;
	$line =~ s/^-\s*$/-/;
	if ($line =~ /^(\$.*)/s) {
		$evalarg = $2;
		my ($s) = &eval;
		print($OUT "Error: $@@\n"), next CMD if $@@;
		$s = CvGV_name($s);
		print($OUT "Interpreted as: $1 $s\n");
		$line = "$1 $s";
		&cmd_l($s);
	} elsif ($line =~ /^([\':A-Za-z_][\':\w]*(\[.*\])?)/s) { 
		my $s = $subname = $1;
		$subname =~ s/\'/::/;
		$subname = $package."::".$subname 
		unless $subname =~ /::/;
		$subname = "CORE::GLOBAL::$s"
		if not defined &$subname and $s !~ /::/
			 and defined &{"CORE::GLOBAL::$s"};
		$subname = "main".$subname if substr($subname,0,2) eq "::";
		@@pieces = split(/:/,find_sub($subname) || $sub{$subname});
		$subrange = pop @@pieces;
		$file = join(':', @@pieces);
		if ($file ne $filename) {
			print $OUT "Switching to file '$file'.\n"
		unless $slave_editor;
			*dbline = $main::{'_<' . $file};
			$max = $#dbline;
			$filename = $file;
		}
		if ($subrange) {
			if (eval($subrange) < -$window) {
		$subrange =~ s/-.*/+/;
			}
			$line = $subrange;
			&cmd_l($subrange);
		} else {
			print $OUT "Subroutine $subname not found.\n";
		}
	} elsif ($line =~ /^\s*$/) {
		$incr = $window - 1;
		$line = $start . '-' . ($start + $incr); 
		&cmd_l($line);
	} elsif ($line =~ /^(\d*)\+(\d*)$/) { 
		$start = $1 if $1;
		$incr = $2;
		$incr = $window - 1 unless $incr;
		$line = $start . '-' . ($start + $incr); 
		&cmd_l($line);	
	} elsif ($line =~ /^((-?[\d\$\.]+)([-,]([\d\$\.]+))?)?/) { 
		$end = (!defined $2) ? $max : ($4 ? $4 : $2);
		$end = $max if $end > $max;
		$i = $2;
		$i = $line if $i eq '.';
		$i = 1 if $i < 1;
		$incr = $end - $i;
		if ($slave_editor) {
			print $OUT "\032\032$filename:$i:0\n";
			$i = $end;
		} else {
			for (; $i <= $end; $i++) {
				my ($stop,$action);
				($stop,$action) = split(/\0/, $dbline{$i}) if
						$dbline{$i};
							$arrow = ($i==$line 
						and $filename eq $filename_ini) 
					?  '==>' 
						: ($dbline[$i]+0 ? ':' : ' ') ;
				$arrow .= 'b' if $stop;
				$arrow .= 'a' if $action;
				print $OUT "$i$arrow\t", $dbline[$i];
				$i++, last if $signal;
			}
			print $OUT "\n" unless $dbline[$i-1] =~ /\n$/;
		}
		$start = $i; # remember in case they want more
		$start = $max if $start > $max;
	}
}

sub cmd_L {
	my $arg    = shift || 'abw'; $arg = 'abw' unless $CommandSet eq '580'; # sigh...
	my $action_wanted = ($arg =~ /a/) ? 1 : 0;
	my $break_wanted  = ($arg =~ /b/) ? 1 : 0;
	my $watch_wanted  = ($arg =~ /w/) ? 1 : 0;

	if ($break_wanted or $action_wanted) {
		for my $file (keys %had_breakpoints) {
			local *dbline = $main::{'_<' . $file};
			my $max = $#dbline;
			my $was;
			for ($i = 1; $i <= $max; $i++) {
				if (defined $dbline{$i}) {
					print $OUT "$file:\n" unless $was++;
					print $OUT " $i:\t", $dbline[$i];
					($stop,$action) = split(/\0/, $dbline{$i});
					print $OUT "   break if (", $stop, ")\n"
						if $stop and $break_wanted;
					print $OUT "   action:  ", $action, "\n"
						if $action and $action_wanted;
					last if $signal;
				}
			}
		}
	}
	if (%postponed and $break_wanted) {
		print $OUT "Postponed breakpoints in subroutines:\n";
		my $subname;
		for $subname (keys %postponed) {
		  print $OUT " $subname\t$postponed{$subname}\n";
		  last if $signal;
		}
	}
	my @@have = map { # Combined keys
			keys %{$postponed_file{$_}}
	} keys %postponed_file;
	if (@@have and ($break_wanted or $action_wanted)) {
		print $OUT "Postponed breakpoints in files:\n";
		my ($file, $line);
		for $file (keys %postponed_file) {
		  my $db = $postponed_file{$file};
		  print $OUT " $file:\n";
		  for $line (sort {$a <=> $b} keys %$db) {
			print $OUT "  $line:\n";
			my ($stop,$action) = split(/\0/, $$db{$line});
			print $OUT "    break if (", $stop, ")\n"
			  if $stop and $break_wanted;
			print $OUT "    action:  ", $action, "\n"
			  if $action and $action_wanted;
			last if $signal;
		  }
		  last if $signal;
		}
	}
  if (%break_on_load and $break_wanted) {
		print $OUT "Breakpoints on load:\n";
		my $file;
		for $file (keys %break_on_load) {
		  print $OUT " $file\n";
		  last if $signal;
		}
  }
  if ($watch_wanted) {
	if ($trace & 2) {
		print $OUT "Watch-expressions:\n" if @@to_watch;
		for my $expr (@@to_watch) {
			print $OUT " $expr\n";
			last if $signal;
		}
	}
  }
}

sub cmd_M {
	&list_modules();
}

sub cmd_o {
	my $opt      = shift || ''; # opt[=val]
	if ($opt =~ /^(\S.*)/) {
		&parse_options($1);
	} else {
		for (@@options) {
			&dump_option($_);
		}
	}
}

sub cmd_O {
	print $OUT "The old O command is now the o command.\n";        # hint
	print $OUT "Use 'h' to get current command help synopsis or\n"; # 
	print $OUT "use 'o CommandSet=pre580' to revert to old usage\n"; # 
}

sub cmd_v {
	my $line = shift;

	if ($line =~ /^(\d*)$/) {
		$incr = $window - 1;
		$start = $1 if $1;
		$start -= $preview;
		$line = $start . '-' . ($start + $incr);
		&cmd_l($line);
	}
}

sub cmd_w {
	my $expr     = shift || '';
	if ($expr =~ /^(\S.*)/) {
		push @@to_watch, $expr;
		$evalarg = $expr;
		my ($val) = &eval;
		$val = (defined $val) ? "'$val'" : 'undef' ;
		push @@old_watch, $val;
		$trace |= 2;
	} else {
		print $OUT "Adding a watch-expression requires an expression\n"; # hint
	}
}

sub cmd_W {
	my $expr     = shift || '';
	if ($expr eq '*') {
		$trace &= ~2;
		print $OUT "Deleting all watch expressions ...\n";
		@@to_watch = @@old_watch = ();
	} elsif ($expr =~ /^(\S.*)/) {
		my $i_cnt = 0;
		foreach (@@to_watch) {
			my $val = $to_watch[$i_cnt];
			if ($val eq $expr) { # =~ m/^\Q$i$/) {
				splice(@@to_watch, $i_cnt, 1);
			}
			$i_cnt++;
		}
	} else {
		print $OUT "Deleting a watch-expression requires an expression, or '*' for all\n"; # hint
	}
a1504 2
### END of the API section

d1510 27
a1536 5
sub print_lineinfo {
  resetterm(1) if $LINEINFO eq $OUT and $term_pid != $$;
  local $\ = '';
  local $, = '';
  print $LINEINFO @@_;
a1538 2
# The following takes its argument via $evalarg to preserve current @@_

a1553 1
      local $\ = '';
a1572 1
  local $\ = '';
d1575 1
a1575 1
  print_lineinfo(' ' x $stack_depth, "Package $filename.\n") if $frame;
d1597 1
a1597 7
        local $\ = '';
        local $, = '';
        local $" = ' ';
        my $v = shift;
        my $maxdepth = shift || $option{dumpDepth};
        $maxdepth = -1 unless defined $maxdepth;   # -1 means infinite depth
	&main::dumpValue($v, $maxdepth);
a1598 1
        local $\ = '';
a1608 1
  local $\ = '';
a1609 1
  resetterm(1) if $fh eq $LINEINFO and $LINEINFO eq $OUT and $term_pid != $$;
d1749 2
a1750 4
	    my ($i, $o) = split $tty, /,/;
	    $o = $i unless defined $o;
	    open(IN,"<$i") or die "Cannot open TTY `$i' for read: $!";
	    open(OUT,">$o") or die "Cannot open TTY `$o' for write: $!";
a1763 3
    if ($term_pid eq '-1') {		# In a TTY with another debugger
	resetterm(2);
    }
d1787 9
a1795 4
# Example get_fork_TTY functions
sub xterm_get_fork_TTY {
  (my $name = $0) =~ s,^.*[/\\],,s;
  open XT, qq[3>&1 xterm -title "Daughter Perl debugger $pids $name" -e sh -c 'tty 1>&3;\
d1797 7
a1803 71
  my $tty = <XT>;
  chomp $tty;
  $pidprompt = '';		# Shown anyway in titlebar
  return $tty;
}

# This example function resets $IN, $OUT itself
sub os2_get_fork_TTY {
  local $^F = 40;			# XXXX Fixme!
  local $\ = '';
  my ($in1, $out1, $in2, $out2);
  # Having -d in PERL5OPT would lead to a disaster...
  local $ENV{PERL5OPT} = $ENV{PERL5OPT}    if $ENV{PERL5OPT};
  $ENV{PERL5OPT} =~ s/(?:^|(?<=\s))-d\b//  if $ENV{PERL5OPT};
  $ENV{PERL5OPT} =~ s/(?:^|(?<=\s))-d\B/-/ if $ENV{PERL5OPT};
  print $OUT "Making kid PERL5OPT->`$ENV{PERL5OPT}'.\n" if $ENV{PERL5OPT};
  local $ENV{PERL5LIB} = $ENV{PERL5LIB} ? $ENV{PERL5LIB} : $ENV{PERLLIB};
  $ENV{PERL5LIB} = '' unless defined $ENV{PERL5LIB};
  $ENV{PERL5LIB} = join ';', @@ini_INC, split /;/, $ENV{PERL5LIB};
  (my $name = $0) =~ s,^.*[/\\],,s;
  my @@args;
  if ( pipe $in1, $out1 and pipe $in2, $out2
       # system P_SESSION will fail if there is another process
       # in the same session with a "dependent" asynchronous child session.
       and @@args = ($rl, fileno $in1, fileno $out2,
		    "Daughter Perl debugger $pids $name") and
       (($kpid = CORE::system 4, $^X, '-we', <<'ES', @@args) >= 0 # P_SESSION
END {sleep 5 unless $loaded}
BEGIN {open STDIN,  '</dev/con' or warn "reopen stdin: $!"}
use OS2::Process;

my ($rl, $in) = (shift, shift);		# Read from $in and pass through
set_title pop;
system P_NOWAIT, $^X, '-we', <<EOS or die "Cannot start a grandkid";
  open IN, '<&=$in' or die "open <&=$in: \$!";
  \$| = 1; print while sysread IN, \$_, 1<<16;
EOS

my $out = shift;
open OUT, ">&=$out" or die "Cannot open &=$out for writing: $!";
select OUT;    $| = 1;
require Term::ReadKey if $rl;
Term::ReadKey::ReadMode(4) if $rl; # Nodelay on kbd.  Pipe is automatically nodelay...
print while sysread STDIN, $_, 1<<($rl ? 16 : 0);
ES
	 or warn "system P_SESSION: $!, $^E" and 0)
	and close $in1 and close $out2 ) {
      $pidprompt = '';			# Shown anyway in titlebar
      reset_IN_OUT($in2, $out1);
      $tty = '*reset*';
      return '';			# Indicate that reset_IN_OUT is called
   }
   return;
}

sub create_IN_OUT {	# Create a window with IN/OUT handles redirected there
    my $in = &get_fork_TTY if defined &get_fork_TTY;
    $in = $fork_TTY if defined $fork_TTY; # Backward compatibility
    if (not defined $in) {
      my $why = shift;
      print_help(<<EOP) if $why == 1;
I<#########> Forked, but do not know how to create a new B<TTY>. I<#########>
EOP
      print_help(<<EOP) if $why == 2;
I<#########> Daughter session, do not know how to change a B<TTY>. I<#########>
  This may be an asynchronous session, so the parent debugger may be active.
EOP
      print_help(<<EOP) if $why != 4;
  Since two debuggers fight for the same TTY, input is severely entangled.

EOP
d1805 4
a1808 4
  I know how to switch the output to a different window in xterms
  and OS/2 consoles only.  For a manual switch, put the name of the created I<TTY>
  in B<\$DB::fork_TTY>, or define a function B<DB::get_fork_TTY()> returning this.

a1810 1

a1811 4
    } elsif ($in ne '') {
      TTY($in);
    } else {
      $console = '';		# Indicate no need to open-from-the-console 
a1812 15
    undef $fork_TTY;
}

sub resetterm {			# We forked, so we need a different TTY
    my $in = shift;
    my $systemed = $in > 1 ? '-' : '';
    if ($pids) {
      $pids =~ s/\]/$systemed->$$]/;
    } else {
      $pids = "[$term_pid->$$]";
    }
    $pidprompt = $pids;
    $term_pid = $$;
    return unless $CreateTTY & $in;
    create_IN_OUT($in);
a1819 1
    local $\ = '';
a1826 5
  while (@@cmdfhs) {
    my $line = CORE::readline($cmdfhs[-1]);
    defined $line ? (print $OUT ">> $line" and return $line)
                  : close pop @@cmdfhs;
  }
a1861 1
    $val = $default unless defined $val;
a1866 1
    local $\ = '';
d1870 1
a1870 1
        dumpDepth arrayDepth hashDepth LineInfo maxTraceLen ornaments windowSize
d1887 1
d1913 1
a1913 2
			 my $cmd = ($CommandSet eq '580') ? 'o' : 'O';
	    print $OUT "Option `$opt' is non-boolean.  Use `$cmd $option=VAL' to set, `$cmd $option?' to query\n";
a1974 1
    local $\ = '';
a1977 16
sub reset_IN_OUT {
    my $switch_li = $LINEINFO eq $OUT;
    if ($term and $term->Features->{newTTY}) {
      ($IN, $OUT) = (shift, shift);
      $term->newTTY($IN, $OUT);
    } elsif ($term) {
	&warn("Too late to set IN/OUT filehandles, enabled on next `R'!\n");
    } else {
      ($IN, $OUT) = (shift, shift);
    }
    my $o = select $OUT;
    $| = 1;
    select $o;
    $LINEINFO = $OUT if $switch_li;
}

d1988 3
a1990 1
      reset_IN_OUT(\*IN,\*OUT);
d1992 4
a1995 4
    }
    &warn("Too late to set TTY, enabled on next `R'!\n") if $term and @@_;
    # Useful if done through PERLDB_OPTS:
    $console = $tty = shift if @@_;
a2026 1
	local $\ = '';
d2056 1
d2078 1
d2095 1
a2095 1
sub list_modules { # versions
d2113 1
a2113 1
    # XXX: make sure there are tabs between the command and explanation,
a2117 178
Help is currently only available for the new 580 CommandSet, 
if you really want old behaviour, presumably you know what 
you're doing ?-)

B<T>		Stack trace.
B<s> [I<expr>]	Single step [in I<expr>].
B<n> [I<expr>]	Next, steps over subroutine calls [in I<expr>].
<B<CR>>		Repeat last B<n> or B<s> command.
B<r>		Return from current subroutine.
B<c> [I<line>|I<sub>]	Continue; optionally inserts a one-time-only breakpoint
		at the specified position.
B<l> I<min>B<+>I<incr>	List I<incr>+1 lines starting at I<min>.
B<l> I<min>B<->I<max>	List lines I<min> through I<max>.
B<l> I<line>		List single I<line>.
B<l> I<subname>	List first window of lines from subroutine.
B<l> I<\$var>		List first window of lines from subroutine referenced by I<\$var>.
B<l>		List next window of lines.
B<->		List previous window of lines.
B<v> [I<line>]	View window around I<line>.
B<.>		Return to the executed line.
B<f> I<filename>	Switch to viewing I<filename>. File must be already loaded.
		I<filename> may be either the full name of the file, or a regular
		expression matching the full file name:
		B<f> I</home/me/foo.pl> and B<f> I<oo\\.> may access the same file.
		Evals (with saved bodies) are considered to be filenames:
		B<f> I<(eval 7)> and B<f> I<eval 7\\b> access the body of the 7th eval
		(in the order of execution).
B</>I<pattern>B</>	Search forwards for I<pattern>; final B</> is optional.
B<?>I<pattern>B<?>	Search backwards for I<pattern>; final B<?> is optional.
B<L> [I<a|b|w>]		List actions and or breakpoints and or watch-expressions.
B<S> [[B<!>]I<pattern>]	List subroutine names [not] matching I<pattern>.
B<t>		Toggle trace mode.
B<t> I<expr>		Trace through execution of I<expr>.
B<b>		Sets breakpoint on current line)
B<b> [I<line>] [I<condition>]
		Set breakpoint; I<line> defaults to the current execution line;
		I<condition> breaks if it evaluates to true, defaults to '1'.
B<b> I<subname> [I<condition>]
		Set breakpoint at first line of subroutine.
B<b> I<\$var>		Set breakpoint at first line of subroutine referenced by I<\$var>.
B<b> B<load> I<filename> Set breakpoint on 'require'ing the given file.
B<b> B<postpone> I<subname> [I<condition>]
		Set breakpoint at first line of subroutine after 
		it is compiled.
B<b> B<compile> I<subname>
		Stop after the subroutine is compiled.
B<B> [I<line>]	Delete the breakpoint for I<line>.
B<B> I<*>             Delete all breakpoints.
B<a> [I<line>] I<command>
		Set an action to be done before the I<line> is executed;
		I<line> defaults to the current execution line.
		Sequence is: check for breakpoint/watchpoint, print line
		if necessary, do action, prompt user if necessary,
		execute line.
B<a>		Does nothing
B<A> [I<line>]	Delete the action for I<line>.
B<A> I<*>             Delete all actions.
B<w> I<expr>		Add a global watch-expression.
B<w>     		Does nothing
B<W> I<expr>		Delete a global watch-expression.
B<W> I<*>             Delete all watch-expressions.
B<V> [I<pkg> [I<vars>]]	List some (default all) variables in package (default current).
		Use B<~>I<pattern> and B<!>I<pattern> for positive and negative regexps.
B<X> [I<vars>]	Same as \"B<V> I<currentpackage> [I<vars>]\".
B<x> I<expr>		Evals expression in list context, dumps the result.
B<m> I<expr>		Evals expression in list context, prints methods callable
		on the first element of the result.
B<m> I<class>		Prints methods callable via the given class.
B<M>		Show versions of loaded modules.

B<<> ?			List Perl commands to run before each prompt.
B<<> I<expr>		Define Perl command to run before each prompt.
B<<<> I<expr>		Add to the list of Perl commands to run before each prompt.
B<>> ?			List Perl commands to run after each prompt.
B<>> I<expr>		Define Perl command to run after each prompt.
B<>>B<>> I<expr>		Add to the list of Perl commands to run after each prompt.
B<{> I<db_command>	Define debugger command to run before each prompt.
B<{> ?			List debugger commands to run before each prompt.
B<{{> I<db_command>	Add to the list of debugger commands to run before each prompt.
B<$prc> I<number>	Redo a previous command (default previous command).
B<$prc> I<-number>	Redo number'th-to-last command.
B<$prc> I<pattern>	Redo last command that started with I<pattern>.
		See 'B<O> I<recallCommand>' too.
B<$psh$psh> I<cmd>  	Run cmd in a subprocess (reads from DB::IN, writes to DB::OUT)"
  . ( $rc eq $sh ? "" : "
B<$psh> [I<cmd>] 	Run I<cmd> in subshell (forces \"\$SHELL -c 'cmd'\")." ) . "
		See 'B<O> I<shellBang>' too.
B<source> I<file>		Execute I<file> containing debugger commands (may nest).
B<H> I<-number>	Display last number commands (default all).
B<p> I<expr>		Same as \"I<print {DB::OUT} expr>\" in current package.
B<|>I<dbcmd>		Run debugger command, piping DB::OUT to current pager.
B<||>I<dbcmd>		Same as B<|>I<dbcmd> but DB::OUT is temporarilly select()ed as well.
B<\=> [I<alias> I<value>]	Define a command alias, or list current aliases.
I<command>		Execute as a perl statement in current package.
B<R>		Pure-man-restart of debugger, some of debugger state
		and command-line options may be lost.
		Currently the following settings are preserved:
		history, breakpoints and actions, debugger B<O>ptions 
		and the following command-line options: I<-w>, I<-I>, I<-e>.

B<o> [I<opt>] ...	Set boolean option to true
B<o> [I<opt>B<?>]	Query options
B<o> [I<opt>B<=>I<val>] [I<opt>=B<\">I<val>B<\">] ... 
		Set options.  Use quotes in spaces in value.
    I<recallCommand>, I<ShellBang>	chars used to recall command or spawn shell;
    I<pager>			program for output of \"|cmd\";
    I<tkRunning>			run Tk while prompting (with ReadLine);
    I<signalLevel> I<warnLevel> I<dieLevel>	level of verbosity;
    I<inhibit_exit>		Allows stepping off the end of the script.
    I<ImmediateStop>		Debugger should stop as early as possible.
    I<RemotePort>			Remote hostname:port for remote debugging
  The following options affect what happens with B<V>, B<X>, and B<x> commands:
    I<arrayDepth>, I<hashDepth> 	print only first N elements ('' for all);
    I<compactDump>, I<veryCompact> 	change style of array and hash dump;
    I<globPrint> 			whether to print contents of globs;
    I<DumpDBFiles> 		dump arrays holding debugged files;
    I<DumpPackages> 		dump symbol tables of packages;
    I<DumpReused> 			dump contents of \"reused\" addresses;
    I<quote>, I<HighBit>, I<undefPrint> 	change style of string dump;
    I<bareStringify> 		Do not print the overload-stringified value;
  Other options include:
    I<PrintRet>		affects printing of return value after B<r> command,
    I<frame>		affects printing messages on subroutine entry/exit.
    I<AutoTrace>	affects printing messages on possible breaking points.
    I<maxTraceLen>	gives max length of evals/args listed in stack trace.
    I<ornaments> 	affects screen appearance of the command line.
    I<CreateTTY> 	bits control attempts to create a new TTY on events:
			1: on fork()	2: debugger is started inside debugger
			4: on startup
	During startup options are initialized from \$ENV{PERLDB_OPTS}.
	You can put additional initialization options I<TTY>, I<noTTY>,
	I<ReadLine>, I<NonStop>, and I<RemotePort> there (or use
	`B<R>' after you set them).

B<q> or B<^D>		Quit. Set B<\$DB::finished = 0> to debug global destruction.
B<h>		Summary of debugger commands.
B<h> [I<db_command>]	Get help [on a specific debugger command], enter B<|h> to page.
B<h h>		Long help for debugger commands
B<$doccmd> I<manpage>	Runs the external doc viewer B<$doccmd> command on the 
		named Perl I<manpage>, or on B<$doccmd> itself if omitted.
		Set B<\$DB::doccmd> to change viewer.

Type `|h h' for a paged display if this was too hard to read.

"; # Fix balance of vi % matching: }}}}

    #  note: tabs in the following section are not-so-helpful
    $summary = <<"END_SUM";
I<List/search source lines:>               I<Control script execution:>
  B<l> [I<ln>|I<sub>]  List source code            B<T>           Stack trace
  B<-> or B<.>      List previous/current line  B<s> [I<expr>]    Single step [in expr]
  B<v> [I<line>]    View around line            B<n> [I<expr>]    Next, steps over subs
  B<f> I<filename>  View source in file         <B<CR>/B<Enter>>  Repeat last B<n> or B<s>
  B</>I<pattern>B</> B<?>I<patt>B<?>   Search forw/backw    B<r>           Return from subroutine
  B<M>           Show module versions        B<c> [I<ln>|I<sub>]  Continue until position
I<Debugger controls:>                        B<L>           List break/watch/actions
  B<o> [...]     Set debugger options        B<t> [I<expr>]    Toggle trace [trace expr]
  B<<>[B<<>]|B<{>[B<{>]|B<>>[B<>>] [I<cmd>] Do pre/post-prompt B<b> [I<ln>|I<event>|I<sub>] [I<cnd>] Set breakpoint
  B<$prc> [I<N>|I<pat>]   Redo a previous command     B<B> I<ln|*>      Delete a/all breakpoints
  B<H> [I<-num>]    Display last num commands   B<a> [I<ln>] I<cmd>  Do cmd before line
  B<=> [I<a> I<val>]   Define/list an alias        B<A> I<ln|*>      Delete a/all actions
  B<h> [I<db_cmd>]  Get help on command         B<w> I<expr>      Add a watch expression
  B<h h>         Complete help page          B<W> I<expr|*>    Delete a/all watch exprs
  B<|>[B<|>]I<db_cmd>  Send output to pager        B<$psh>\[B<$psh>\] I<syscmd> Run cmd in a subprocess
  B<q> or B<^D>     Quit                        B<R>           Attempt a restart
I<Data Examination:>     B<expr>     Execute perl code, also see: B<s>,B<n>,B<t> I<expr>
  B<x>|B<m> I<expr>       Evals expr in list context, dumps the result or lists methods.
  B<p> I<expr>         Print expression (uses script's current package).
  B<S> [[B<!>]I<pat>]     List subroutine names [not] matching pattern
  B<V> [I<Pk> [I<Vars>]]  List Variables in Package.  Vars can be ~pattern or !pattern.
  B<X> [I<Vars>]       Same as \"B<V> I<current_package> [I<Vars>]\".
  B<y> [I<n> [I<Vars>]]   List lexicals in higher scope <n>.  Vars same as B<V>.
For more help, type B<h> I<cmd_letter>, or run B<$doccmd perldebug> for all docs.
END_SUM
				# ')}}; # Fix balance of vi % matching

	# and this is really numb...
	$pre580_help = "
d2187 1
a2196 1
B<source> I<file>		Execute I<file> containing debugger commands (may nest).
d2206 1
a2206 1
		Currently the following settings are preserved:
d2232 3
a2234 3
    I<frame>		affects printing messages on subroutine entry/exit.
    I<AutoTrace>	affects printing messages on possible breaking points.
    I<maxTraceLen>	gives max length of evals/args listed in stack trace.
a2235 3
    I<CreateTTY> 	bits control attempts to create a new TTY on events:
			1: on fork()	2: debugger is started inside debugger
			4: on startup
d2250 1
a2250 1
"; # Fix balance of vi % matching: }}}}
d2252 1
a2252 2
    #  note: tabs in the following section are not-so-helpful
    $pre580_summary = <<"END_SUM";
d2259 1
a2259 1
  B<v>           Show versions of modules    B<c> [I<ln>|I<sub>]  Continue until position
d2268 7
a2274 8
  B<q> or B<^D>     Quit                        B<R>           Attempt a restart
I<Data Examination:>     B<expr>     Execute perl code, also see: B<s>,B<n>,B<t> I<expr>
  B<x>|B<m> I<expr>       Evals expr in list context, dumps the result or lists methods.
  B<p> I<expr>         Print expression (uses script's current package).
  B<S> [[B<!>]I<pat>]     List subroutine names [not] matching pattern
  B<V> [I<Pk> [I<Vars>]]  List Variables in Package.  Vars can be ~pattern or !pattern.
  B<X> [I<Vars>]       Same as \"B<V> I<current_package> [I<Vars>]\".
  B<y> [I<n> [I<Vars>]]   List lexicals in higher scope <n>.  Vars same as B<V>.
a2277 1

d2287 2
a2288 2
    # the first tab sequence padded into a field 16 (or if indented 20)
    # wide.  If it's wider than that, an extra space will be added.
d2302 1
a2302 1
	($leadwhite ? " " x 4 : "")
d2304 1
a2304 1
      . ((" " x (16 + ($leadwhite ? 4 : 0) - length($clean))) || " ")
a2324 1
    local $\ = '';
a2352 1
	local $\ = '';
d2365 1
a2365 1
  CORE::warn(@@_, "\nCannot print stack trace, load with -MCarp option to see stack"),
d2388 1
a2388 2
  # No need to check $^S, eval is much more robust nowadays
  eval { require Carp }; #if defined $^S;# If error/warning during compilation,
d2398 1
a2398 7
  my $mess = "@@_";
  { 
    package Carp;		# Do not include us in the list
    eval {
      $mess = Carp::longmess(@@_);
    };
  }
d2409 1
a2409 1
    } elsif ($prevwarn) {
a2416 1
  local $\ = '';
d2427 1
a2427 1
    } elsif ($prevdie) {
a2459 1
  return unless ref $in;
a2502 2
    local $\ = '';
    local $, = '';
d2513 1
a2513 1
    $doccmd = $^O !~ /^(?:MSWin32|VMS|os2|dos|amigaos|riscos|MacOS|NetWare)\z/s
d2545 1
a2545 1
    if (CORE::system($doccmd, 
d2562 1
a2562 1
		CORE::system($doccmd, 
d2606 1
a2606 1
#use Carp;			# This did break, left for debugging
a2688 1
  local $\ = '';
a2691 8
sub clean_ENV {
    if (defined($ini_pids)) {
        $ENV{PERLDB_PIDS} = $ini_pids;
    } else {
        delete($ENV{PERLDB_PIDS});
    }
}

a2699 117

# ===================================== pre580 ================================
# this is very sad below here...
#

sub cmd_pre580_null {
	# do nothing...
}

sub cmd_pre580_a {
	my $cmd = shift;
	if ($cmd =~ /^(\d*)\s*(.*)/) {
		$i = $1 || $line; $j = $2;
		if (length $j) {
			if ($dbline[$i] == 0) {
				print $OUT "Line $i may not have an action.\n";
			} else {
				$had_breakpoints{$filename} |= 2;
				$dbline{$i} =~ s/\0[^\0]*//;
				$dbline{$i} .= "\0" . action($j);
			}
		} else {
			$dbline{$i} =~ s/\0[^\0]*//;
			delete $dbline{$i} if $dbline{$i} eq '';
		}
	}
}

sub cmd_pre580_b {
	my $cmd    = shift;
	my $dbline = shift;
	if ($cmd =~ /^load\b\s*(.*)/) {
		my $file = $1; $file =~ s/\s+$//;
		&cmd_b_load($file);
	} elsif ($cmd =~ /^(postpone|compile)\b\s*([':A-Za-z_][':\w]*)\s*(.*)/) {
		my $cond = length $3 ? $3 : '1';
		my ($subname, $break) = ($2, $1 eq 'postpone');
		$subname =~ s/\'/::/g;
		$subname = "${'package'}::" . $subname
		unless $subname =~ /::/;
		$subname = "main".$subname if substr($subname,0,2) eq "::";
		$postponed{$subname} = $break ? "break +0 if $cond" : "compile";
	} elsif ($cmd =~ /^([':A-Za-z_][':\w]*(?:\[.*\])?)\s*(.*)/) { 
		my $subname = $1;
		my $cond = length $2 ? $2 : '1';
		&cmd_b_sub($subname, $cond);
	} elsif ($cmd =~ /^(\d*)\s*(.*)/) {
		my $i = $1 || $dbline;
		my $cond = length $2 ? $2 : '1';
		&cmd_b_line($i, $cond);
	}
}

sub cmd_pre580_D {
	my $cmd = shift;
	if ($cmd =~ /^\s*$/) {
		print $OUT "Deleting all breakpoints...\n";
		my $file;
		for $file (keys %had_breakpoints) {
			local *dbline = $main::{'_<' . $file};
			my $max = $#dbline;
			my $was;

			for ($i = 1; $i <= $max ; $i++) {
				if (defined $dbline{$i}) {
					$dbline{$i} =~ s/^[^\0]+//;
					if ($dbline{$i} =~ s/^\0?$//) {
						delete $dbline{$i};
					}
				}
			}

			if (not $had_breakpoints{$file} &= ~1) {
				delete $had_breakpoints{$file};
			}
		}
		undef %postponed;
		undef %postponed_file;
		undef %break_on_load;
	}
}

sub cmd_pre580_h {
	my $cmd = shift;
	if ($cmd =~ /^\s*$/) {
		print_help($pre580_help);
	} elsif ($cmd =~ /^h\s*/) {
		print_help($pre580_summary);
	} elsif ($cmd =~ /^h\s+(\S.*)$/) { 
		my $asked = $1;			# for proper errmsg
		my $qasked = quotemeta($asked); # for searching
		# XXX: finds CR but not <CR>
		if ($pre580_help =~ /^<?(?:[IB]<)$qasked/m) {
			while ($pre580_help =~ /^(<?(?:[IB]<)$qasked([\s\S]*?)\n)(?!\s)/mg) {
				print_help($1);
			}
		} else {
			print_help("B<$asked> is not a debugger command.\n");
		}
	}
}

sub cmd_pre580_W {
	my $cmd = shift;
	if ($cmd =~ /^$/) { 
		$trace &= ~2;
		@@to_watch = @@old_watch = ();
	} elsif ($cmd =~ /^(.*)/s) {
		push @@to_watch, $1;
		$evalarg = $1;
		my ($val) = &eval;
		$val = (defined $val) ? "'$val'" : 'undef' ;
		push @@old_watch, $val;
		$trace |= 2;
	}
}

a2708 1

@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@a0 489
=head1 NAME 

C<perl5db.pl> - the perl debugger

=head1 SYNOPSIS

    perl -d  your_Perl_script

=head1 DESCRIPTION

C<perl5db.pl> is the perl debugger. It is loaded automatically by Perl when
you invoke a script with C<perl -d>. This documentation tries to outline the
structure and services provided by C<perl5db.pl>, and to describe how you
can use them.

=head1 GENERAL NOTES

The debugger can look pretty forbidding to many Perl programmers. There are
a number of reasons for this, many stemming out of the debugger's history.

When the debugger was first written, Perl didn't have a lot of its nicer
features - no references, no lexical variables, no closures, no object-oriented
programming. So a lot of the things one would normally have done using such
features was done using global variables, globs and the C<local()> operator 
in creative ways.

Some of these have survived into the current debugger; a few of the more
interesting and still-useful idioms are noted in this section, along with notes
on the comments themselves.

=head2 Why not use more lexicals?

Experienced Perl programmers will note that the debugger code tends to use
mostly package globals rather than lexically-scoped variables. This is done
to allow a significant amount of control of the debugger from outside the
debugger itself.       

Unfortunately, though the variables are accessible, they're not well
documented, so it's generally been a decision that hasn't made a lot of
difference to most users. Where appropriate, comments have been added to
make variables more accessible and usable, with the understanding that these
i<are> debugger internals, and are therefore subject to change. Future
development should probably attempt to replace the globals with a well-defined
API, but for now, the variables are what we've got.

=head2 Automated variable stacking via C<local()>

As you may recall from reading C<perlfunc>, the C<local()> operator makes a 
temporary copy of a variable in the current scope. When the scope ends, the
old copy is restored. This is often used in the debugger to handle the 
automatic stacking of variables during recursive calls:

     sub foo {
        local $some_global++;

        # Do some stuff, then ...
        return;
     }

What happens is that on entry to the subroutine, C<$some_global> is localized,
then altered. When the subroutine returns, Perl automatically undoes the 
localization, restoring the previous value. Voila, automatic stack management.

The debugger uses this trick a I<lot>. Of particular note is C<DB::eval>, 
which lets the debugger get control inside of C<eval>'ed code. The debugger
localizes a saved copy of C<$@@> inside the subroutine, which allows it to
keep C<$@@> safe until it C<DB::eval> returns, at which point the previous
value of C<$@@> is restored. This makes it simple (well, I<simpler>) to keep 
track of C<$@@> inside C<eval>s which C<eval> other C<eval's>.

In any case, watch for this pattern. It occurs fairly often.

=head2 The C<^> trick

This is used to cleverly reverse the sense of a logical test depending on 
the value of an auxiliary variable. For instance, the debugger's C<S>
(search for subroutines by pattern) allows you to negate the pattern 
like this:

   # Find all non-'foo' subs:
   S !/foo/      

Boolean algebra states that the truth table for XOR looks like this:

=over 4

=item * 0 ^ 0 = 0 

(! not present and no match) --> false, don't print

=item * 0 ^ 1 = 1 

(! not present and matches) --> true, print

=item * 1 ^ 0 = 1 

(! present and no match) --> true, print

=item * 1 ^ 1 = 0 

(! present and matches) --> false, don't print

=back

As you can see, the first pair applies when C<!> isn't supplied, and
the second pair applies when it isn't. The XOR simply allows us to
compact a more complicated if-then-elseif-else into a more elegant 
(but perhaps overly clever) single test. After all, it needed this
explanation...

=head2 FLAGS, FLAGS, FLAGS

There is a certain C programming legacy in the debugger. Some variables,
such as C<$single>, C<$trace>, and C<$frame>, have "magical" values composed
of 1, 2, 4, etc. (powers of 2) OR'ed together. This allows several pieces
of state to be stored independently in a single scalar. 

A test like

    if ($scalar & 4) ...

is checking to see if the appropriate bit is on. Since each bit can be 
"addressed" independently in this way, C<$scalar> is acting sort of like
an array of bits. Obviously, since the contents of C<$scalar> are just a 
bit-pattern, we can save and restore it easily (it will just look like
a number).

The problem, is of course, that this tends to leave magic numbers scattered
all over your program whenever a bit is set, cleared, or checked. So why do 
it?

=over 4


=item * First, doing an arithmetical or bitwise operation on a scalar is
just about the fastest thing you can do in Perl: C<use constant> actually
creates a subroutine call, and array hand hash lookups are much slower. Is
this over-optimization at the expense of readability? Possibly, but the 
debugger accesses these  variables a I<lot>. Any rewrite of the code will
probably have to benchmark alternate implementations and see which is the
best balance of readability and speed, and then document how it actually 
works.

=item * Second, it's very easy to serialize a scalar number. This is done in 
the restart code; the debugger state variables are saved in C<%ENV> and then
restored when the debugger is restarted. Having them be just numbers makes
this trivial. 

=item * Third, some of these variables are being shared with the Perl core 
smack in the middle of the interpreter's execution loop. It's much faster for 
a C program (like the interpreter) to check a bit in a scalar than to access 
several different variables (or a Perl array).

=back

=head2 What are those C<XXX> comments for?

Any comment containing C<XXX> means that the comment is either somewhat
speculative - it's not exactly clear what a given variable or chunk of 
code is doing, or that it is incomplete - the basics may be clear, but the
subtleties are not completely documented.

Send in a patch if you can clear up, fill out, or clarify an C<XXX>.

=head1 DATA STRUCTURES MAINTAINED BY CORE         

There are a number of special data structures provided to the debugger by
the Perl interpreter.

The array C<@@{$main::{'_<'.$filename}}> (aliased locally to C<@@dbline> via glob
assignment) contains the text from C<$filename>, with each element
corresponding to a single line of C<$filename>.

The hash C<%{'_<'.$filename}> (aliased locally to C<%dbline> via glob 
assignment) contains breakpoints and actions.  The keys are line numbers; 
you can set individual values, but not the whole hash. The Perl interpreter 
uses this hash to determine where breakpoints have been set. Any true value is
considered to be a breakpoint; C<perl5db.pl> uses "$break_condition\0$action".
Values are magical in numeric context: 1 if the line is breakable, 0 if not.

The scalar ${'_<'.$filename} contains $filename  XXX What?

=head1 DEBUGGER STARTUP

When C<perl5db.pl> starts, it reads an rcfile (C<perl5db.ini> for
non-interactive sessions, C<.perldb> for interactive ones) that can set a number
of options. In addition, this file may define a subroutine C<&afterinit>
that will be executed (in the debugger's context) after the debugger has 
initialized itself.

Next, it checks the C<PERLDB_OPTS> environment variable and treats its 
contents as the argument of a debugger <C<O> command.

=head2 STARTUP-ONLY OPTIONS

The following options can only be specified at startup.
To set them in your rcfile, add a call to
C<&parse_options("optionName=new_value")>.

=over 4

=item * TTY 

the TTY to use for debugging i/o.

=item * noTTY 

if set, goes in NonStop mode.  On interrupt, if TTY is not set,
uses the value of noTTY or "/tmp/perldbtty$$" to find TTY using
Term::Rendezvous.  Current variant is to have the name of TTY in this
file.

=item * ReadLine 

If false, a dummy  ReadLine is used, so you can debug
ReadLine applications.

=item * NonStop 

if true, no i/o is performed until interrupt.

=item * LineInfo 

file or pipe to print line number info to.  If it is a
pipe, a short "emacs like" message is used.

=item * RemotePort 

host:port to connect to on remote host for remote debugging.

=back

=head3 SAMPLE RCFILE

 &parse_options("NonStop=1 LineInfo=db.out");
  sub afterinit { $trace = 1; }

The script will run without human intervention, putting trace
information into C<db.out>.  (If you interrupt it, you had better
reset C<LineInfo> to something "interactive"!)

=head1 INTERNALS DESCRIPTION

=head2 DEBUGGER INTERFACE VARIABLES

Perl supplies the values for C<%sub>.  It effectively inserts
a C<&DB'DB();> in front of each place that can have a
breakpoint. At each subroutine call, it calls C<&DB::sub> with
C<$DB::sub> set to the called subroutine. It also inserts a C<BEGIN
{require 'perl5db.pl'}> before the first line.

After each C<require>d file is compiled, but before it is executed, a
call to C<&DB::postponed($main::{'_<'.$filename})> is done. C<$filename>
is the expanded name of the C<require>d file (as found via C<%INC>).

=head3 IMPORTANT INTERNAL VARIABLES

=head4 C<$CreateTTY>

Used to control when the debugger will attempt to acquire another TTY to be
used for input. 

=over   

=item * 1 -  on C<fork()>

=item * 2 - debugger is started inside debugger

=item * 4 -  on startup

=back

=head4 C<$doret>

The value -2 indicates that no return value should be printed.
Any other positive value causes C<DB::sub> to print return values.

=head4 C<$evalarg>

The item to be eval'ed by C<DB::eval>. Used to prevent messing with the current
contents of C<@@_> when C<DB::eval> is called.

=head4 C<$frame>

Determines what messages (if any) will get printed when a subroutine (or eval)
is entered or exited. 

=over 4

=item * 0 -  No enter/exit messages

=item * 1 - Print "entering" messages on subroutine entry

=item * 2 - Adds exit messages on subroutine exit. If no other flag is on, acts like 1+2.

=item * 4 - Extended messages: C<in|out> I<context>=I<fully-qualified sub name> from I<file>:I<line>>. If no other flag is on, acts like 1+4.

=item * 8 - Adds parameter information to messages, and overloaded stringify and tied FETCH is enabled on the printed arguments. Ignored if C<4> is not on.

=item * 16 - Adds C<I<context> return from I<subname>: I<value>> messages on subroutine/eval exit. Ignored if C<4> is is not on.

=back

To get everything, use C<$frame=30> (or C<o f-30> as a debugger command).
The debugger internally juggles the value of C<$frame> during execution to
protect external modules that the debugger uses from getting traced.

=head4 C<$level>

Tracks current debugger nesting level. Used to figure out how many 
C<E<lt>E<gt>> pairs to surround the line number with when the debugger 
outputs a prompt. Also used to help determine if the program has finished
during command parsing.

=head4 C<$onetimeDump>

Controls what (if anything) C<DB::eval()> will print after evaluating an
expression.

=over 4

=item * C<undef> - don't print anything

=item * C<dump> - use C<dumpvar.pl> to display the value returned

=item * C<methods> - print the methods callable on the first item returned

=back

=head4 C<$onetimeDumpDepth>

Controls how far down C<dumpvar.pl> will go before printing '...' while
dumping a structure. Numeric. If C<undef>, print all levels.

=head4 C<$signal>

Used to track whether or not an C<INT> signal has been detected. C<DB::DB()>,
which is called before every statement, checks this and puts the user into
command mode if it finds C<$signal> set to a true value.

=head4 C<$single>

Controls behavior during single-stepping. Stacked in C<@@stack> on entry to
each subroutine; popped again at the end of each subroutine.

=over 4 

=item * 0 - run continuously.

=item * 1 - single-step, go into subs. The 's' command.

=item * 2 - single-step, don't go into subs. The 'n' command.

=item * 4 - print current sub depth (turned on to force this when "too much
recursion" occurs.

=back

=head4 C<$trace>

Controls the output of trace information. 

=over 4

=item * 1 - The C<t> command was entered to turn on tracing (every line executed is printed)

=item * 2 - watch expressions are active

=item * 4 - user defined a C<watchfunction()> in C<afterinit()>

=back

=head4 C<$slave_editor>

1 if C<LINEINFO> was directed to a pipe; 0 otherwise.

=head4 C<@@cmdfhs>

Stack of filehandles that C<DB::readline()> will read commands from.
Manipulated by the debugger's C<source> command and C<DB::readline()> itself.

=head4 C<@@dbline>

Local alias to the magical line array, C<@@{$main::{'_<'.$filename}}> , 
supplied by the Perl interpreter to the debugger. Contains the source.

=head4 C<@@old_watch>

Previous values of watch expressions. First set when the expression is
entered; reset whenever the watch expression changes.

=head4 C<@@saved>

Saves important globals (C<$@@>, C<$!>, C<$^E>, C<$,>, C<$/>, C<$\>, C<$^W>)
so that the debugger can substitute safe values while it's running, and
restore them when it returns control.

=head4 C<@@stack>

Saves the current value of C<$single> on entry to a subroutine.
Manipulated by the C<c> command to turn off tracing in all subs above the
current one.

=head4 C<@@to_watch>

The 'watch' expressions: to be evaluated before each line is executed.

=head4 C<@@typeahead>

The typeahead buffer, used by C<DB::readline>.

=head4 C<%alias>

Command aliases. Stored as character strings to be substituted for a command
entered.

=head4 C<%break_on_load>

Keys are file names, values are 1 (break when this file is loaded) or undef
(don't break when it is loaded).

=head4 C<%dbline>

Keys are line numbers, values are "condition\0action". If used in numeric
context, values are 0 if not breakable, 1 if breakable, no matter what is
in the actual hash entry.

=head4 C<%had_breakpoints>

Keys are file names; values are bitfields:

=over 4 

=item * 1 - file has a breakpoint in it.

=item * 2 - file has an action in it.

=back

A zero or undefined value means this file has neither.

=head4 C<%option>

Stores the debugger options. These are character string values.

=head4 C<%postponed>

Saves breakpoints for code that hasn't been compiled yet.
Keys are subroutine names, values are:

=over 4

=item * 'compile' - break when this sub is compiled

=item * 'break +0 if <condition>' - break (conditionally) at the start of this routine. The condition will be '1' if no condition was specified.

=back

=head4 C<%postponed_file>

This hash keeps track of breakpoints that need to be set for files that have
not yet been compiled. Keys are filenames; values are references to hashes.
Each of these hashes is keyed by line number, and its values are breakpoint
definitions ("condition\0action").

=head1 DEBUGGER INITIALIZATION

The debugger's initialization actually jumps all over the place inside this
package. This is because there are several BEGIN blocks (which of course 
execute immediately) spread through the code. Why is that? 

The debugger needs to be able to change some things and set some things up 
before the debugger code is compiled; most notably, the C<$deep> variable that
C<DB::sub> uses to tell when a program has recursed deeply. In addition, the
debugger has to turn off warnings while the debugger code is compiled, but then
restore them to their original setting before the program being debugged begins
executing.

The first C<BEGIN> block simply turns off warnings by saving the current
setting of C<$^W> and then setting it to zero. The second one initializes
the debugger variables that are needed before the debugger begins executing.
The third one puts C<$^X> back to its former value. 

We'll detail the second C<BEGIN> block later; just remember that if you need
to initialize something before the debugger starts really executing, that's
where it has to go.

=cut

a2 2
use IO::Handle;

d4 1
a4 1
$VERSION = 1.22;
d7 1
a7 97
=head1 DEBUGGER ROUTINES

=head2 C<DB::eval()>

This function replaces straight C<eval()> inside the debugger; it simplifies
the process of evaluating code in the user's context.

The code to be evaluated is passed via the package global variable 
C<$DB::evalarg>; this is done to avoid fiddling with the contents of C<@@_>.

We preserve the current settings of X<C<$trace>>, X<C<$single>>, and X<C<$^D>>;
add the X<C<$usercontext>> (that's the preserved values of C<$@@>, C<$!>,
C<$^E>, C<$,>, C<$/>, C<$\>, and C<$^W>, grabbed when C<DB::DB> got control,
and the user's current package) and a add a newline before we do the C<eval()>.
This causes the proper context to be used when the eval is actually done.
Afterward, we restore C<$trace>, C<$single>, and C<$^D>.

Next we need to handle C<$@@> without getting confused. We save C<$@@> in a
local lexical, localize C<$saved[0]> (which is where C<save()> will put 
C<$@@>), and then call C<save()> to capture C<$@@>, C<$!>, C<$^E>, C<$,>, 
C<$/>, C<$\>, and C<$^W>) and set C<$,>, C<$/>, C<$\>, and C<$^W> to values
considered sane by the debugger. If there was an C<eval()> error, we print 
it on the debugger's output. If X<C<$onetimedump>> is defined, we call 
X<C<dumpit>> if it's set to 'dump', or X<C<methods>> if it's set to 
'methods'. Setting it to something else causes the debugger to do the eval 
but not print the result - handy if you want to do something else with it 
(the "watch expressions" code does this to get the value of the watch
expression but not show it unless it matters).

In any case, we then return the list of output from C<eval> to the caller, 
and unwinding restores the former version of C<$@@> in C<@@saved> as well 
(the localization of C<$saved[0]> goes away at the end of this scope).

=head3 Parameters and variables influencing execution of DB::eval()

C<DB::eval> isn't parameterized in the standard way; this is to keep the
debugger's calls to C<DB::eval()> from mucking with C<@@_>, among other things.
The variables listed below influence C<DB::eval()>'s execution directly. 

=over 4

=item C<$evalarg> - the thing to actually be eval'ed

=item C<$trace> - Current state of execution tracing (see X<$trace>)

=item C<$single> - Current state of single-stepping (see X<$single>)        

=item C<$onetimeDump> - what is to be displayed after the evaluation 

=item C<$onetimeDumpDepth> - how deep C<dumpit()> should go when dumping results

=back

The following variables are altered by C<DB::eval()> during its execution. They
are "stacked" via C<local()>, enabling recursive calls to C<DB::eval()>. 

=over 4

=item C<@@res> - used to capture output from actual C<eval>.

=item C<$otrace> - saved value of C<$trace>.

=item C<$osingle> - saved value of C<$single>.      

=item C<$od> - saved value of C<$^D>.

=item C<$saved[0]> - saved value of C<$@@>.

=item $\ - for output of C<$@@> if there is an evaluation error.      

=back

=head3 The problem of lexicals

The context of C<DB::eval()> presents us with some problems. Obviously,
we want to be 'sandboxed' away from the debugger's internals when we do
the eval, but we need some way to control how punctuation variables and
debugger globals are used. 

We can't use local, because the code inside C<DB::eval> can see localized
variables; and we can't use C<my> either for the same reason. The code
in this routine compromises and uses C<my>.

After this routine is over, we don't have user code executing in the debugger's
context, so we can use C<my> freely.

=cut

############################################## Begin lexical danger zone

# 'my' variables used here could leak into (that is, be visible in)
# the context that the code being evaluated is executing in. This means that
# the code could modify the debugger's variables.
#
# Fiddling with the debugger's context could be Bad. We insulate things as
# much as we can.

a8 1

d10 1
a10 2
    #    but so does local! --tchrist  
    # Remember: this localizes @@DB::res, not @@main::res.
d13 8
a20 22
        # Try to keep the user code from messing  with us. Save these so that 
        # even if the eval'ed code changes them, we can put them back again. 
        # Needed because the user could refer directly to the debugger's 
        # package globals (and any 'my' variables in this containing scope)
        # inside the eval(), and we want to try to stay safe.
        local $otrace  = $trace; 
        local $osingle = $single;
        local $od      = $^D;

        # Untaint the incoming eval() argument.
        { ($evalarg) = $evalarg =~ /(.*)/s; }

        # $usercontext built in DB::DB near the comment 
        # "set up the context for DB::eval ..."
        # Evaluate and save any results.
        @@res =
          eval "$usercontext $evalarg;\n";    # '\n' for nice recursive debug

        # Restore those old values.
        $trace  = $otrace;
        $single = $osingle;
        $^D     = $od;
a21 3

    # Save the current value of $@@, and preserve it in the debugger's copy
    # of the saved precious globals.
d23 1
a23 4

    # Since we're only saving $@@, we only have to localize the array element
    # that it will be stored in.
    local $saved[0];                          # Preserve the old value of $@@
a24 2

    # Now see whether we need to report an error back to the user.
d26 10
a35 2
        local $\ = '';
        print $OUT $at;
a36 13

    # Display as required by the caller. $onetimeDump and $onetimedumpDepth
    # are package globals.
    elsif ($onetimeDump) {
        if ($onetimeDump eq 'dump') {
            local $option{dumpDepth} = $onetimedumpDepth
              if defined $onetimedumpDepth;
            dumpit($OUT, \@@res);
        }
        elsif ($onetimeDump eq 'methods') {
            methods($res[0]);
        }
    } ## end elsif ($onetimeDump)
d38 1
a38 3
} ## end sub eval

############################################## End lexical danger zone
d40 2
a41 3
# After this point it is safe to introduce lexicals.
# The code being debugged will be executing in its own context, and 
# can't see the inside of the debugger.
a42 4
# However, one should not overdo it: leave as much control from outside as    
# possible. If you make something a lexical, it's not going to be addressable
# from outside the debugger even if you know its name.

d49 28
a76 5
# (It should be noted that perldebguts will tell you a lot about
# the uderlying mechanics of how the debugger interfaces into the
# Perl interpreter, but not a lot about the debugger itself. The new
# comments in this code try to address this problem.)

d83 39
d129 34
a162 40
# (We have made efforts to  clarify the comments in the change log
# in other places; some of them may seem somewhat obscure as they
# were originally written, and explaining them away from the code
# in question seems conterproductive.. -JM)

########################################################################
# Changes: 0.94
#   + A lot of things changed after 0.94. First of all, core now informs
#     debugger about entry into XSUBs, overloaded operators, tied operations,
#     BEGIN and END. Handy with `O f=2'.
#   + This can make debugger a little bit too verbose, please be patient
#     and report your problems promptly.
#   + Now the option frame has 3 values: 0,1,2. XXX Document!
#   + Note that if DESTROY returns a reference to the object (or object),
#     the deletion of data may be postponed until the next function call,
#     due to the need to examine the return value.
#
# Changes: 0.95
#   + `v' command shows versions.
#
# Changes: 0.96 
#   + `v' command shows version of readline.
#     primitive completion works (dynamic variables, subs for `b' and `l',
#     options). Can `p %var'
#   + Better help (`h <' now works). New commands <<, >>, {, {{.
#     {dump|print}_trace() coded (to be able to do it from <<cmd).
#   + `c sub' documented.
#   + At last enough magic combined to stop after the end of debuggee.
#   + !! should work now (thanks to Emacs bracket matching an extra
#     `]' in a regexp is caught).
#   + `L', `D' and `A' span files now (as documented).
#   + Breakpoints in `require'd code are possible (used in `R').
#   +  Some additional words on internal work of debugger.
#   + `b load filename' implemented.
#   + `b postpone subr' implemented.
#   + now only `q' exits debugger (overwritable on $inhibit_exit).
#   + When restarting debugger breakpoints/actions persist.
#   + Buglet: When restarting debugger only one breakpoint/action per 
#             autoloaded function persists.
#
d164 4
a167 4
#   + Option AutoTrace implemented.
#   + Trace printed differently if frames are printed too.
#   + new `inhibitExit' option.
#   + printing of a very long statement interruptible.
d169 11
a179 11
#   + 'l -' is a synonym for `-'.
#   + Cosmetic bugs in printing stack trace.
#   +  `frame' & 8 to print "expanded args" in stack trace.
#   + Can list/break in imported subs.
#   + new `maxTraceLen' option.
#   + frame & 4 and frame & 8 granted.
#   + new command `m'
#   + nonstoppable lines do not have `:' near the line number.
#   + `b compile subname' implemented.
#   + Will not use $` any more.
#   + `-' behaves sane now.
d181 4
a184 4
#   +  `m' will remove duplicate names instead of duplicate functions.
#   + `b load' strips trailing whitespace.
#     completion ignores leading `|'; takes into account current package
#     when completing a subroutine name (same for `l').
d236 19
a254 20
#   Minor bugs corrected;
#   + Support for auto-creation of new TTY window on startup, either
#     unconditionally, or if started as a kid of another debugger session;
#   + New `O'ption CreateTTY
#       I<CreateTTY>      bits control attempts to create a new TTY on events:
#                         1: on fork()   
#                         2: debugger is started inside debugger
#                         4: on startup
#   + Code to auto-create a new TTY window on OS/2 (currently one
#     extra window per session - need named pipes to have more...);
#   + Simplified interface for custom createTTY functions (with a backward
#     compatibility hack); now returns the TTY name to use; return of ''
#     means that the function reset the I/O handles itself;
#   + Better message on the semantic of custom createTTY function;
#   + Convert the existing code to create a TTY into a custom createTTY
#     function;
#   + Consistent support for TTY names of the form "TTYin,TTYout";
#   + Switch line-tracing output too to the created TTY window;
#   + make `b fork' DWIM with CORE::GLOBAL::fork;
#   + High-level debugger API cmd_*():
d262 1
a262 1
#   + Low-level debugger API
d268 1
a268 2
#                                           # to $from, and may be less than 
#                                           # $to
d271 1
a271 2
#                                           # Set breakpoint,$cond defaults to 
#                                           # 1
d306 1
a306 1
#   + $onetimeDump improvements
d314 1
a314 2
#   + w(add),       W(del)            # watch  expr   (was W,W) 
#                                     # added del by expr
d323 1
a323 9
# Changes: 1.20: Feb 17, 2003 Richard Foley <richard.foley@@rfi.net>
#   + pre'n'post commands no longer trashed with no args
#   + watch val joined out of eval()
# Changes: 1.21: Jun 04, 2003 Joe McMahon <mcmahon@@ibiblio.org>
#   + Added comments and reformatted source. No bug fixes/enhancements.
#   + Includes cleanup by Robin Barker and Jarkko Hietaniemi.
# Changes: 1.22  Jun 09, 2003 Alex Vandiver <alexmv@@MIT.EDU>
#   + Flush stdout/stderr before the debugger prompt is printed.

d326 1
a326 10
=head1 DEBUGGER INITIALIZATION

The debugger starts up in phases.

=head2 BASIC SETUP

First, it initializes the environment it wants to run in: turning off
warnings during its own compilation, defining variables which it will need
to avoid warnings later, setting itself up to not exit when the program
terminates, and defaulting to printing return values for the C<r> command.
d328 16
a343 45
=cut

# Needed for the statement after exec():
#
# This BEGIN block is simply used to switch off warnings during debugger
# compiliation. Probably it would be better practice to fix the warnings,
# but this is how it's done at the moment.

BEGIN {
    $ini_warn = $^W;
    $^W       = 0;
}    # Switch compilation warnings off until another BEGIN.

local ($^W) = 0;    # Switch run-time warnings off during init.

# This would probably be better done with "use vars", but that wasn't around
# when this code was originally written. (Neither was "use strict".) And on
# the principle of not fiddling with something that was working, this was
# left alone.
warn(               # Do not ;-)
    # These variables control the execution of 'dumpvar.pl'.
    $dumpvar::hashDepth,
    $dumpvar::arrayDepth,
    $dumpvar::dumpDBFiles,
    $dumpvar::dumpPackages,
    $dumpvar::quoteHighBit,
    $dumpvar::printUndef,
    $dumpvar::globPrint,
    $dumpvar::usageOnly,

    # used to save @@ARGV and extract any debugger-related flags.
    @@ARGS,

    # used to control die() reporting in diesignal()
    $Carp::CarpLevel,

    # used to prevent multiple entries to diesignal()
    # (if for instance diesignal() itself dies)
    $panic,

    # used to prevent the debugger from running nonstop
    # after a restart
    $second_time,
  )
  if 0;
a345 1
# Save the contents of @@INC before they are modified elsewhere.
a347 2
# This was an attempt to clear out the previous values of various
# trapped errors. Apparently it didn't help. XXX More info needed!
d350 2
a351 7
# We set these variables to safe values. We don't want to blindly turn
# off warnings, because other packages may still want them.
$trace = $signal = $single = 0;   # Uninitialized warning suppression
                                  # (local $^W cannot help - other packages!).

# Default to not exiting when program finishes; print the return
# value when the 'r' command is used to return from a subroutine.
d354 51
a404 1
=head1 OPTION PROCESSING
a405 95
The debugger's options are actually spread out over the debugger itself and 
C<dumpvar.pl>; some of these are variables to be set, while others are 
subs to be called with a value. To try to make this a little easier to
manage, the debugger uses a few data structures to define what options
are legal and how they are to be processed.

First, the C<@@options> array defines the I<names> of all the options that
are to be accepted.

=cut

@@options = qw(
             CommandSet
             hashDepth    arrayDepth    dumpDepth
             DumpDBFiles  DumpPackages  DumpReused
             compactDump  veryCompact   quote
             HighBit      undefPrint    globPrint 
             PrintRet     UsageOnly     frame
             AutoTrace    TTY           noTTY 
             ReadLine     NonStop       LineInfo 
             maxTraceLen  recallCommand ShellBang
             pager        tkRunning     ornaments
             signalLevel  warnLevel     dieLevel 
             inhibit_exit ImmediateStop bareStringify 
             CreateTTY    RemotePort    windowSize
           );

=pod

Second, C<optionVars> lists the variables that each option uses to save its
state.

=cut

%optionVars = (
    hashDepth     => \$dumpvar::hashDepth,
    arrayDepth    => \$dumpvar::arrayDepth,
    CommandSet    => \$CommandSet,
    DumpDBFiles   => \$dumpvar::dumpDBFiles,
    DumpPackages  => \$dumpvar::dumpPackages,
    DumpReused    => \$dumpvar::dumpReused,
    HighBit       => \$dumpvar::quoteHighBit,
    undefPrint    => \$dumpvar::printUndef,
    globPrint     => \$dumpvar::globPrint,
    UsageOnly     => \$dumpvar::usageOnly,
    CreateTTY     => \$CreateTTY,
    bareStringify => \$dumpvar::bareStringify,
    frame         => \$frame,
    AutoTrace     => \$trace,
    inhibit_exit  => \$inhibit_exit,
    maxTraceLen   => \$maxtrace,
    ImmediateStop => \$ImmediateStop,
    RemotePort    => \$remoteport,
    windowSize    => \$window,
    );

=pod

Third, C<%optionAction> defines the subroutine to be called to process each
option.

=cut 

%optionAction = (
    compactDump   => \&dumpvar::compactDump,
    veryCompact   => \&dumpvar::veryCompact,
    quote         => \&dumpvar::quote,
    TTY           => \&TTY,
    noTTY         => \&noTTY,
    ReadLine      => \&ReadLine,
    NonStop       => \&NonStop,
    LineInfo      => \&LineInfo,
    recallCommand => \&recallCommand,
    ShellBang     => \&shellBang,
    pager         => \&pager,
    signalLevel   => \&signalLevel,
    warnLevel     => \&warnLevel,
    dieLevel      => \&dieLevel,
    tkRunning     => \&tkRunning,
    ornaments     => \&ornaments,
    RemotePort    => \&RemotePort,
    );

=pod

Last, the C<%optionRequire> notes modules that must be C<require>d if an
option is used.

=cut

# Note that this list is not complete: several options not listed here
# actually require that dumpvar.pl be loaded for them to work, but are
# not in the table. A subsequent patch will correct this problem; for
# the moment, we're just recommenting, and we are NOT going to change
# function.
d407 4
a410 34
    compactDump => 'dumpvar.pl',
    veryCompact => 'dumpvar.pl',
    quote       => 'dumpvar.pl',
    );

=pod

There are a number of initialization-related variables which can be set
by putting code to set them in a BEGIN block in the C<PERL5DB> environment
variable. These are:

=over 4

=item C<$rl> - readline control XXX needs more explanation

=item C<$warnLevel> - whether or not debugger takes over warning handling

=item C<$dieLevel> - whether or not debugger takes over die handling

=item C<$signalLevel> - whether or not debugger takes over signal handling

=item C<$pre> - preprompt actions (array reference)

=item C<$post> - postprompt actions (array reference)

=item C<$pretype>

=item C<$CreateTTY> - whether or not to create a new TTY for this debugger

=item C<$CommandSet> - which command set to use (defaults to new, documented set)

=back

=cut
d413 9
a421 15
$rl          = 1     unless defined $rl;
$warnLevel   = 1     unless defined $warnLevel;
$dieLevel    = 1     unless defined $dieLevel;
$signalLevel = 1     unless defined $signalLevel;
$pre         = []    unless defined $pre;
$post        = []    unless defined $post;
$pretype     = []    unless defined $pretype;
$CreateTTY   = 3     unless defined $CreateTTY;
$CommandSet  = '580' unless defined $CommandSet;

=pod

The default C<die>, C<warn>, and C<signal> handlers are set up.

=cut
a426 10
=pod

The pager to be used is needed next. We try to get it from the
environment first.  if it's not defined there, we try to find it in
the Perl C<Config.pm>.  If it's not there, we default to C<more>. We
then call the C<pager()> function to save the pager name.

=cut

# This routine makes sure $pager is set up so that '|' can use it.
d428 5
a432 22
    # If PAGER is defined in the environment, use it.
    defined $ENV{PAGER} 
      ? $ENV{PAGER}

      # If not, see if Config.pm defines it.
      : eval { require Config } && defined $Config::Config{pager} 
        ? $Config::Config{pager}

      # If not, fall back to 'more'.
        : 'more'
  )
  unless defined $pager;

=pod

We set up the command to be used to access the man pages, the command
recall character ("!" unless otherwise defined) and the shell escape
character ("!" unless otherwise defined). Yes, these do conflict, and
neither works in the debugger at the moment.

=cut

a433 3

# Set up defaults for command recall and shell escape (note:
# these currently don't work in linemode debugging).
d435 1
a435 10
&shellBang("!")     unless defined $psh;

=pod

We then set up the gigantic string containing the debugger help.
We also set the limit on the number of arguments we'll display during a
trace.

=cut

a436 3

# If we didn't get a default for the length of eval/stack trace args,
# set it here.
a437 23

=head2 SETTING UP THE DEBUGGER GREETING

The debugger 'greeting'  helps to inform the user how many debuggers are
running, and whether the current debugger is the primary or a child.

If we are the primary, we just hang onto our pid so we'll have it when
or if we start a child debugger. If we are a child, we'll set things up
so we'll have a unique greeting and so the parent will give us our own
TTY later.

We save the current contents of the C<PERLDB_PIDS> environment variable
because we mess around with it. We'll also need to hang onto it because
we'll need it if we restart.

Child debuggers make a label out of the current PID structure recorded in
PERLDB_PIDS plus the new PID. They also mark themselves as not having a TTY
yet so the parent will give them one later via C<resetterm()>.

=cut

# Save the current contents of the environment; we're about to 
# much with it. We'll need this if we have to restart.
d439 8
a446 16

if (defined $ENV{PERLDB_PIDS}) { 
    # We're a child. Make us a label out of the current PID structure
    # recorded in PERLDB_PIDS plus our (new) PID. Mark us as not having 
    # a term yet so the parent will give us one later via resetterm().
    $pids = "[$ENV{PERLDB_PIDS}]";
    $ENV{PERLDB_PIDS} .= "->$$";
    $term_pid = -1;
} ## end if (defined $ENV{PERLDB_PIDS...
else {
    # We're the parent PID. Initialize PERLDB_PID in case we end up with a 
    # child debugger, and mark us as the parent, so we'll know to set up
    # more TTY's is we have to.
    $ENV{PERLDB_PIDS} = "$$";
    $pids     = "{pid=$$}";
    $term_pid = $$;
a447 1

d449 1
d451 4
a454 14
# Sets up $emacs as a synonym for $slave_editor.
*emacs     = $slave_editor if $slave_editor;   # May be used in afterinit()...

=head2 READING THE RC FILE

The debugger will read a file of initialization options if supplied. If    
running interactively, this is C<.perldb>; if not, it's C<perldb.ini>.

=cut      

# As noted, this test really doesn't check accurately that the debugger
# is running at a terminal or not.
if (-e "/dev/tty") {                           # this is the wrong metric!
    $rcfile = ".perldb";
a455 5
else {
    $rcfile = "perldb.ini";
}

=pod
a456 7
The debugger does a safety test of the file to be read. It must be owned
either by the current user or root, and must only be writable by the owner.

=cut

# This wraps a safety test around "do" to read and evaluate the init file.
#
d461 2
a462 2
# your lexical scope, which is unfortunate at best.
sub safe_do {
d466 2
a467 2
    local $SIG{__WARN__};
    local $SIG{__DIE__};
d470 1
a470 1
        CORE::warn <<EO_GRIPE;
d473 1
a473 1
        be writable by anyone but its owner.
d475 2
a476 2
        return;
    } ## end unless (is_safe_file($file...
d480 2
a481 1
} ## end sub safe_do
a482 2
# This is the safety test itself.
#
d491 2
a492 2
    stat($path) || return;    # mysteriously vaporized
    my ($dev, $ino, $mode, $nlink, $uid, $gid) = stat(_);
d497 1
a497 1
} ## end sub is_safe_file
a498 2
# If the rcfile (whichever one we decided was the right one to read)
# exists, we safely do it. 
d501 1
a501 2
}
# If there isn't one here, try the user's home directory.
a504 1
# Else try the login directory.
a508 1
# If the PERLDB_OPTS variable has options in it, parse those out next.
d510 1
a510 1
    parse_options($ENV{PERLDB_OPTS});
d513 6
a518 50
=pod

The last thing we do during initialization is determine which subroutine is
to be used to obtain a new terminal when a new debugger is started. Right now,
the debugger only handles X Windows and OS/2.

=cut

# Set up the get_fork_TTY subroutine to be aliased to the proper routine.
# Works if you're running an xterm or xterm-like window, or you're on
# OS/2. This may need some expansion: for instance, this doesn't handle
# OS X Terminal windows.       

if (not defined &get_fork_TTY                        # no routine exists,
    and defined $ENV{TERM}                           # and we know what kind
                                                     # of terminal this is,
    and $ENV{TERM} eq 'xterm'                        # and it's an xterm,
    and defined $ENV{WINDOWID}                       # and we know what
                                                     # window this is,
    and defined $ENV{DISPLAY})                       # and what display it's
                                                     # on,
{
    *get_fork_TTY = \&xterm_get_fork_TTY;            # use the xterm version
} ## end if (not defined &get_fork_TTY...
elsif ($^O eq 'os2') {                               # If this is OS/2,
    *get_fork_TTY = \&os2_get_fork_TTY;              # use the OS/2 version
}

# "Here begin the unreadable code.  It needs fixing." 

=head2 RESTART PROCESSING

This section handles the restart command. When the C<R> command is invoked, it
tries to capture all of the state it can into environment variables, and
then sets C<PERLDB_RESTART>. When we start executing again, we check to see
if C<PERLDB_RESTART> is there; if so, we reload all the information that
the R command stuffed into the environment variables.

  PERLDB_RESTART   - flag only, contains no restart data itself.       
  PERLDB_HIST      - command history, if it's available
  PERLDB_ON_LOAD   - breakpoints set by the rc file
  PERLDB_POSTPONE  - subs that have been loaded/not executed, and have actions
  PERLDB_VISITED   - files that had breakpoints
  PERLDB_FILE_...  - breakpoints for a file
  PERLDB_OPT       - active options
  PERLDB_INC       - the original @@INC
  PERLDB_PRETYPE   - preprompt debugger actions
  PERLDB_PRE       - preprompt Perl code
  PERLDB_POST      - post-prompt Perl code
  PERLDB_TYPEAHEAD - typeahead captured by readline()
d520 1
a520 4
We chug through all these variables and plug the values saved in them
back into the appropriate spots in the debugger.

=cut
d523 23
a545 40
    # We're restarting, so we don't need the flag that says to restart anymore.
    delete $ENV{PERLDB_RESTART};
    # $restart = 1;
    @@hist          = get_list('PERLDB_HIST');
    %break_on_load = get_list("PERLDB_ON_LOAD");
    %postponed     = get_list("PERLDB_POSTPONE");

    # restore breakpoints/actions
    my @@had_breakpoints = get_list("PERLDB_VISITED");
    for (0 .. $#had_breakpoints) {
        my %pf = get_list("PERLDB_FILE_$_");
        $postponed_file{ $had_breakpoints[$_] } = \%pf if %pf;
    }

    # restore options
    my %opt = get_list("PERLDB_OPT");
    my ($opt, $val);
    while (($opt, $val) = each %opt) {
        $val =~ s/[\\\']/\\$1/g;
        parse_options("$opt'$val'");
    }

    # restore original @@INC
    @@INC       = get_list("PERLDB_INC");
    @@ini_INC   = @@INC;

    # return pre/postprompt actions and typeahead buffer
    $pretype   = [get_list("PERLDB_PRETYPE")];
    $pre       = [get_list("PERLDB_PRE")];
    $post      = [get_list("PERLDB_POST")];
    @@typeahead = get_list("PERLDB_TYPEAHEAD", @@typeahead);
} ## end if (exists $ENV{PERLDB_RESTART...

=head2 SETTING UP THE TERMINAL

Now, we'll decide how the debugger is going to interact with the user.
If there's no TTY, we set the debugger to run non-stop; there's not going
to be anyone there to enter commands.

=cut
d548 71
a618 2
    $runnonstop = 1;
}
d620 2
a621 1
=pod
d623 12
a634 29
If there is a TTY, we have to determine who it belongs to before we can
proceed. If this is a slave editor or graphical debugger (denoted by
the first command-line switch being '-emacs'), we shift this off and
set C<$rl> to 0 (XXX ostensibly to do straight reads).

=cut

else {
    # Is Perl being run from a slave editor or graphical debugger?
    # If so, don't use readline, and set $slave_editor = 1.
    $slave_editor =
      ((defined $main::ARGV[0]) and ($main::ARGV[0] eq '-emacs'));
    $rl = 0, shift (@@main::ARGV) if $slave_editor;
    #require Term::ReadLine;

=pod

We then determine what the console should be on various systems:

=over 4

=item * Cygwin - We use C<stdin> instead of a separate device.

=cut


    if ($^O eq 'cygwin') {
        # /dev/tty is binary. use stdin for textmode
        undef $console;
d636 2
a638 197
=item * Unix - use C</dev/tty>.

=cut

    elsif (-e "/dev/tty") {
        $console = "/dev/tty";
    }

=item * Windows or MSDOS - use C<con>.

=cut

    elsif ($^O eq 'dos' or -e "con" or $^O eq 'MSWin32') {
        $console = "con";
    }

=item * MacOS - use C<Dev:Console:Perl Debug> if this is the MPW version; C<Dev:
Console> if not. (Note that Mac OS X returns 'darwin', not 'MacOS'. Also note that the debugger doesn't do anything special for 'darwin'. Maybe it should.)

=cut

    elsif ($^O eq 'MacOS') {
        if ($MacPerl::Version !~ /MPW/) {
            $console =
              "Dev:Console:Perl Debug";    # Separate window for application
        }
        else {
            $console = "Dev:Console";
        }
    } ## end elsif ($^O eq 'MacOS')

=item * VMS - use C<sys$command>.

=cut

    else {
        # everything else is ...
        $console = "sys\$command";
    }

=pod

=back

Several other systems don't use a specific console. We C<undef $console>
for those (Windows using a slave editor/graphical debugger, NetWare, OS/2
with a slave editor, Epoc).

=cut

    if (($^O eq 'MSWin32') and ($slave_editor or defined $ENV{EMACS})) {
        # /dev/tty is binary. use stdin for textmode
        $console = undef;
    }

    if ($^O eq 'NetWare') {
        # /dev/tty is binary. use stdin for textmode
        $console = undef;
    }

    # In OS/2, we need to use STDIN to get textmode too, even though
    # it pretty much looks like Unix otherwise.
    if (defined $ENV{OS2_SHELL} and ($slave_editor or $ENV{WINDOWID}))
    {    # In OS/2
        $console = undef;
    }
    # EPOC also falls into the 'got to use STDIN' camp.
    if ($^O eq 'epoc') {
        $console = undef;
    }

=pod

If there is a TTY hanging around from a parent, we use that as the console.

=cut

    $console = $tty if defined $tty;

=head2 SOCKET HANDLING   

The debugger is capable of opening a socket and carrying out a debugging
session over the socket.

If C<RemotePort> was defined in the options, the debugger assumes that it
should try to start a debugging session on that port. It builds the socket
and then tries to connect the input and output filehandles to it.

=cut

    # Handle socket stuff.
    if (defined $remoteport) {
        # If RemotePort was defined in the options, connect input and output
        # to the socket.
        require IO::Socket;
        $OUT = new IO::Socket::INET(
            Timeout  => '10',
            PeerAddr => $remoteport,
            Proto    => 'tcp',
            );
        if (!$OUT) { die "Unable to connect to remote host: $remoteport\n"; }
        $IN = $OUT;
    } ## end if (defined $remoteport)

=pod

If no C<RemotePort> was defined, and we want to create a TTY on startup,
this is probably a situation where multiple debuggers are running (for example,
a backticked command that starts up another debugger). We create a new IN and
OUT filehandle, and do the necessary mojo to create a new TTY if we know how
and if we can.

=cut

    # Non-socket.
    else {
        # Two debuggers running (probably a system or a backtick that invokes
        # the debugger itself under the running one). create a new IN and OUT
        # filehandle, and do the necessary mojo to create a new tty if we 
        # know how, and we can.
        create_IN_OUT(4) if $CreateTTY & 4;
        if ($console) {
            # If we have a console, check to see if there are separate ins and
            # outs to open. (They are assumed identiical if not.)
            my ($i, $o) = split /,/, $console;
            $o = $i unless defined $o;

            # read/write on in, or just read, or read on STDIN.
            open(IN, "+<$i") || 
             open(IN, "<$i") || 
              open(IN, "<&STDIN");

            # read/write/create/clobber out, or write/create/clobber out,
            # or merge with STDERR, or merge with STDOUT.
            open(OUT,   "+>$o")     ||
              open(OUT, ">$o")      ||
              open(OUT, ">&STDERR") ||
              open(OUT, ">&STDOUT");    # so we don't dongle stdout

        } ## end if ($console)
        elsif (not defined $console) {
           # No console. Open STDIN.
            open(IN,    "<&STDIN");

           # merge with STDERR, or with STDOUT.
            open(OUT,   ">&STDERR") ||
              open(OUT, ">&STDOUT");     # so we don't dongle stdout

            $console = 'STDIN/OUT';
        } ## end elsif (not defined $console)

        # Keep copies of the filehandles so that when the pager runs, it
        # can close standard input without clobbering ours.
        $IN = \*IN, $OUT = \*OUT if $console or not defined $console;
    } ## end elsif (from if(defined $remoteport))

    # Unbuffer DB::OUT. We need to see responses right away. 
    my $previous = select($OUT);
    $| = 1;                              # for DB::OUT
    select($previous);

    # Line info goes to debugger output unless pointed elsewhere.
    # Pointing elsewhere makes it possible for slave editors to
    # keep track of file and position. We have both a filehandle 
    # and a I/O description to keep track of.
    $LINEINFO = $OUT     unless defined $LINEINFO;
    $lineinfo = $console unless defined $lineinfo;

=pod

To finish initialization, we show the debugger greeting,
and then call the C<afterinit()> subroutine if there is one.

=cut

    # Show the debugger greeting.
    $header =~ s/.Header: ([^,]+),v(\s+\S+\s+\S+).*$/$1$2/;
    unless ($runnonstop) {
        local $\ = '';
        local $, = '';
        if ($term_pid eq '-1') {
            print $OUT "\nDaughter DB session started...\n";
        }
        else {
            print $OUT "\nLoading DB routines from $header\n";
            print $OUT (
                "Editor support ",
                $slave_editor ? "enabled" : "available", ".\n"
                );
            print $OUT
"\nEnter h or `h h' for help, or `$doccmd perldebug' for more help.\n\n";
        } ## end else [ if ($term_pid eq '-1')
    } ## end unless ($runnonstop)
} ## end else [ if ($notty)

# XXX This looks like a bug to me.
# Why copy to @@ARGS and then futz with @@args?
a640 2
    # Make sure backslashes before single quotes are stripped out, and
    # keep args unless they are numeric (XXX why?)
d645 2
a646 4
# If there was an afterinit() sub defined, call it. It will get 
# executed in our scope, so it can fiddle with debugger globals.
if (defined &afterinit) {    # May be defined in $rcfile
    &afterinit();
d648 1
a648 1
# Inform us about "Stack dump during die enabled ..." in dieLevel().
a652 17
=head1 SUBROUTINES

=head2 DB

This gigantic subroutine is the heart of the debugger. Called before every
statement, its job is to determine if a breakpoint has been reached, and
stop if so; read commands from the user, parse them, and execute
them, and hen send execution off to the next statement.

Note that the order in which the commands are processed is very important;
some commands earlier in the loop will actually alter the C<$cmd> variable
to create other commands to be executed later. This is all highly "optimized"
but can be confusing. Check the comments for each C<$cmd ... && do {}> to
see what's happening in any given command.

=cut

a653 2

    # Check for whether we should be running continuously or not.
d656 12
a667 29
        # Options say run non-stop. Run until we get an interrupt.
        if ($runnonstop) {    # Disable until signal
            # If there's any call stack in place, turn off single
            # stepping into subs throughout the stack.
            for ($i = 0 ; $i <= $stack_depth ;) {
                $stack[$i++] &= ~1;
            }
            # And we are now no longer in single-step mode.
            $single = 0;

            # If we simply returned at this point, we wouldn't get
            # the trace info. Fall on through.
            # return; 
        } ## end if ($runnonstop)

        elsif ($ImmediateStop) {
            # We are supposed to stop here; XXX probably a break. 
            $ImmediateStop = 0;               # We've processed it; turn it off
            $signal        = 1;               # Simulate an interrupt to force
                                              # us into the command loop
        }
    } ## end if ($single and not $second_time...

    # If we're in single-step mode, or an interrupt (real or fake)
    # has occurred, turn off non-stop mode.
    $runnonstop = 0 if $single or $signal;

    # Preserve current values of $@@, $!, $^E, $,, $/, $\, $^W.
    # The code being debugged may have altered them.
d669 1
a669 6

    # Since DB::DB gets called after every line, we can use caller() to
    # figure out where we last were executing. Sneaky, eh? This works because
    # caller is returning all the extra information when called from the 
    # debugger.
    local ($package, $filename, $line) = caller;
d671 3
a673 11

    # set up the context for DB::eval, so it can properly execute
    # code on behalf of the user. We add the package in so that the
    # code is eval'ed in the proper package (not in the debugger!).
    local $usercontext  =
      '($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;' .
      "package $package;"; 

    # Create an alias to the active file magical array to simplify
    # the code here.
    local (*dbline) = $main::{ '_<' . $filename };
d678 2
a679 2
        $filename_ini = $filename = 'Dev:Pseudo';
        *dbline = $main::{ '_<' . $filename };
a681 1
    # Last line in the program.
d683 8
a690 18

    # if we have something here, see if we should break.
    if ($dbline{$line} && (($stop, $action) = split (/\0/, $dbline{$line}))) {
        # Stop if the stop criterion says to just stop.
        if ($stop eq '1') {
            $signal |= 1;
        }
        # It's a conditional stop; eval it in the user's context and
        # see if we should stop. If so, remove the one-time sigil.
        elsif ($stop) {
            $evalarg = "\$DB::signal |= 1 if do {$stop}";
            &eval;
            $dbline{$line} =~ s/;9($|\0)/$1/;
        }
    } ## end if ($dbline{$line} && ...

    # Preserve the current stop-or-not, and see if any of the W
    # (watch expressions) has changed.
a691 2

    # If we have any watch expressions ...
d693 8
a700 15
        for (my $n = 0 ; $n <= $#to_watch ; $n++) {
            $evalarg = $to_watch[$n];
            local $onetimeDump;    # Tell DB::eval() to not output results

            # Fix context DB::eval() wants to return an array, but
            # we need a scalar here.
            my ($val) =
              join ( "', '", &eval );
            $val = ((defined $val) ? "'$val'" : 'undef');

            # Did it change?
            if ($val ne $old_watch[$n]) {
                # Yep! Show the difference, and fake an interrupt.
                $signal = 1;
                print $OUT <<EOP;
d705 8
a712 50
                $old_watch[$n] = $val;
            } ## end if ($val ne $old_watch...
        } ## end for (my $n = 0 ; $n <= ...
    } ## end if ($trace & 2)

=head2 C<watchfunction()>

C<watchfunction()> is a function that can be defined by the user; it is a
function which will be run on each entry to C<DB::DB>; it gets the 
current package, filename, and line as its parameters.

The watchfunction can do anything it likes; it is executing in the 
debugger's context, so it has access to all of the debugger's internal
data structures and functions.

C<watchfunction()> can control the debugger's actions. Any of the following
will cause the debugger to return control to the user's program after
C<watchfunction()> executes:

=over 4 

=item * Returning a false value from the C<watchfunction()> itself.

=item * Altering C<$single> to a false value.

=item * Altering C<$signal> to a false value.

=item *  Turning off the '4' bit in C<$trace> (this also disables the
check for C<watchfunction()>. This can be done with

    $trace &= ~4;

=back

=cut

    # If there's a user-defined DB::watchfunction, call it with the 
    # current package, filename, and line. The function executes in
    # the DB:: package.
    if ($trace & 4) {    # User-installed watch
        return
          if watchfunction($package, $filename, $line)
          and not $single
          and not $was_signal
          and not($trace & ~4);
    } ## end if ($trace & 4)


    # Pick up any alteration to $signal in the watchfunction, and 
    # turn off the signal now.
d714 1
a714 13
    $signal     = 0;

=head2 GETTING READY TO EXECUTE COMMANDS

The debugger decides to take control if single-step mode is on, the
C<t> command was entered, or the user generated a signal. If the program
has fallen off the end, we set things up so that entering further commands
won't cause trouble, and we say that the program is over.

=cut

    # Check to see if we should grab control ($single true,
    # trace set appropriately, or we got a signal).
d716 6
a721 19
        # Yes, grab control.
        if ($slave_editor) {
            # Tell the editor to update its position.
            $position = "\032\032$filename:$line:0\n";
            print_lineinfo($position);
        }

=pod

Special check: if we're in package C<DB::fake>, we've gone through the 
C<END> block at least once. We set up everything so that we can continue
to enter commands and have a valid context to be in.

=cut

        elsif ($package eq 'DB::fake') {
            # Fallen off the end already.
            $term || &setterm;
            print_help(<<EOP);
d726 35
a760 85

            # Set the DB::eval context appropriately.
            $package     = 'main';
            $usercontext =
              '($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;' .
              "package $package;";    # this won't let them modify, alas
        } ## end elsif ($package eq 'DB::fake')

=pod

If the program hasn't finished executing, we scan forward to the
next executable line, print that out, build the prompt from the file and line
number information, and print that.   

=cut

        else {
            # Still somewhere in the midst of execution. Set up the
            #  debugger prompt.
            $sub =~ s/\'/::/;    # Swap Perl 4 package separators (') to
                                 # Perl 5 ones (sorry, we don't print Klingon 
                                 #module names)

            $prefix = $sub =~ /::/ ? "" : "${'package'}::";
            $prefix .= "$sub($filename:";
            $after = ($dbline[$line] =~ /\n$/ ? '' : "\n");

            # Break up the prompt if it's really long.
            if (length($prefix) > 30) {
                $position = "$prefix$line):\n$line:\t$dbline[$line]$after";
                $prefix   = "";
                $infix    = ":\t";
            }
            else {
                $infix    = "):\t";
                $position = "$prefix$line$infix$dbline[$line]$after";
            }

            # Print current line info, indenting if necessary.
            if ($frame) {
                print_lineinfo(' ' x $stack_depth,
                    "$line:\t$dbline[$line]$after");
            }
            else {
                print_lineinfo($position);
            }

            # Scan forward, stopping at either the end or the next
            # unbreakable line.
            for ($i = $line + 1 ; $i <= $max && $dbline[$i] == 0 ; ++$i)
            {    #{ vi

                # Drop out on null statements, block closers, and comments.
                last if $dbline[$i] =~ /^\s*[\;\}\#\n]/;

                # Drop out if the user interrupted us.
                last if $signal;
               
                # Append a newline if the line doesn't have one. Can happen
                # in eval'ed text, for instance.
                $after = ($dbline[$i] =~ /\n$/ ? '' : "\n");

                # Next executable line.
                $incr_pos = "$prefix$i$infix$dbline[$i]$after";
                $position .= $incr_pos;
                if ($frame) {
                    # Print it indented if tracing is on.
                    print_lineinfo(' ' x $stack_depth,
                        "$i:\t$dbline[$i]$after");
                }
                else {
                    print_lineinfo($incr_pos);
                }
            } ## end for ($i = $line + 1 ; $i...
        } ## end else [ if ($slave_editor)
    } ## end if ($single || ($trace...

=pod

If there's an action to be executed for the line we stopped at, execute it.
If there are any preprompt actions, execute those as well.      

=cut

    # If there's an action, do it now.
a761 3

    # Are we nested another level (e.g., did we evaluate a function
    # that had a breakpoint in it at the debugger prompt)?
d763 14
a776 79
        # Yes, go down a level.
        local $level = $level + 1;

        # Do any pre-prompt actions.
        foreach $evalarg (@@$pre) {
            &eval;
        }

        # Complain about too much recursion if we passed the limit.
        print $OUT $stack_depth . " levels deep in subroutine calls!\n"
          if $single & 4;

        # The line we're currently on. Set $incr to -1 to stay here
        # until we get a command that tells us to advance.
        $start     = $line;
        $incr      = -1;                        # for backward motion.

        # Tack preprompt debugger actions ahead of any actual input.
        @@typeahead = (@@$pretype, @@typeahead);

=head2 WHERE ARE WE?

XXX Relocate this section?

The debugger normally shows the line corresponding to the current line of
execution. Sometimes, though, we want to see the next line, or to move elsewhere
in the file. This is done via the C<$incr>, C<$start>, and C<$max> variables.

C<$incr> controls by how many lines the "current" line should move forward
after a command is executed. If set to -1, this indicates that the "current"
line shouldn't change.

C<$start> is the "current" line. It is used for things like knowing where to
move forwards or backwards from when doing an C<L> or C<-> command.

C<$max> tells the debugger where the last line of the current file is. It's
used to terminate loops most often.

=head2 THE COMMAND LOOP

Most of C<DB::DB> is actually a command parsing and dispatch loop. It comes
in two parts:

=over 4

=item * The outer part of the loop, starting at the C<CMD> label. This loop
reads a command and then executes it.

=item * The inner part of the loop, starting at the C<PIPE> label. This part
is wholly contained inside the C<CMD> block and only executes a command.
Used to handle commands running inside a pager.

=back

So why have two labels to restart the loop? Because sometimes, it's easier to
have a command I<generate> another command and then re-execute the loop to do
the new command. This is faster, but perhaps a bit more convoluted.

=cut

        # The big command dispatch loop. It keeps running until the
        # user yields up control again.
        #
        # If we have a terminal for input, and we get something back
        # from readline(), keep on processing.
      CMD:
        while (
            # We have a terminal, or can get one ...
            ($term || &setterm),
            # ... and it belogs to this PID or we get one for this PID ...
            ($term_pid == $$ or resetterm(1)),
            # ... and we got a line of command input ...
            defined(
                $cmd = &readline(
                    "$pidprompt  DB" . ('<' x $level) . ($#hist + 1) .
                      ('>' x $level) . " "
                )
            )
          )
d778 594
a1371 1
            # ... try to execute the input as debugger commands.
d1373 2
a1374 2
            # Don't stop running.
            $single = 0;
d1376 55
a1430 2
            # No signal is active.
            $signal = 0;
d1432 1
a1432 76
            # Handle continued commands (ending with \):
            $cmd =~ s/\\$/\n/ && do {
                $cmd .= &readline("  cont: ");
                redo CMD;
            };

=head4 The null command

A newline entered by itself means "re-execute the last command". We grab the
command out of C<$laststep> (where it was recorded previously), and copy it
back into C<$cmd> to be executed below. If there wasn't any previous command,
we'll do nothing below (no command will match). If there was, we also save it
in the command history and fall through to allow the command parsing to pick
it up.

=cut

            # Empty input means repeat the last command.
            $cmd =~ /^$/ && ($cmd = $laststep);
            push (@@hist, $cmd) if length($cmd) > 1;


          # This is a restart point for commands that didn't arrive
          # via direct user input. It allows us to 'redo PIPE' to
          # re-execute command processing without reading a new command.
          PIPE: {
                $cmd =~ s/^\s+//s;    # trim annoying leading whitespace
                $cmd =~ s/\s+$//s;    # trim annoying trailing whitespace
                ($i) = split (/\s+/, $cmd);

=head3 COMMAND ALIASES

The debugger can create aliases for commands (these are stored in the
C<%alias> hash). Before a command is executed, the command loop looks it up
in the alias hash and substitutes the contents of the alias for the command,
completely replacing it.

=cut

                # See if there's an alias for the command, and set it up if so.
                if ($alias{$i}) {
                    # Squelch signal handling; we want to keep control here
                    # if something goes loco during the alias eval.
                    local $SIG{__DIE__};
                    local $SIG{__WARN__};

                    # This is a command, so we eval it in the DEBUGGER's
                    # scope! Otherwise, we can't see the special debugger
                    # variables, or get to the debugger's subs. (Well, we
                    # _could_, but why make it even more complicated?)
                    eval "\$cmd =~ $alias{$i}";
                    if ($@@) {
                        local $\ = '';
                        print $OUT "Couldn't evaluate `$i' alias: $@@";
                        next CMD;
                    }
                } ## end if ($alias{$i})

=head3 MAIN-LINE COMMANDS

All of these commands work up to and after the program being debugged has
terminated. 

=head4 C<q> - quit

Quit the debugger. This entails setting the C<$fall_off_end> flag, so we don't 
try to execute further, cleaning any restart-related stuff out of the
environment, and executing with the last value of C<$?>.

=cut

                $cmd =~ /^q$/ && do {
                    $fall_off_end = 1;
                    clean_ENV();
                    exit $?;
                };
d1434 23
a1456 1
=head4 C<t> - trace
d1458 12
a1469 1
Turn tracing on or off. Inverts the appropriate bit in C<$trace> (q.v.).
d1471 2
a1472 1
=cut
d1474 18
a1491 7
                $cmd =~ /^t$/ && do {
                    $trace ^= 1;
                    local $\ = '';
                    print $OUT "Trace = " . (($trace & 1) ? "on" : "off") .
                      "\n";
                    next CMD;
                };
d1493 11
a1503 1
=head4 C<S> - list subroutines matching/not matching a pattern
d1505 24
a1528 1
Walks through C<%sub>, checking to see whether or not to print the name.
d1530 27
a1556 1
=cut
d1558 5
a1562 1
                $cmd =~ /^S(\s+(!)?(.+))?$/ && do {
d1564 3
a1566 3
                    $Srev     = defined $2;     # Reverse scan? 
                    $Spatt    = $3;             # The pattern (if any) to use.
                    $Snocheck = !defined $1;    # No args - print all subs.
d1568 14
a1581 3
                    # Need to make these sane here.
                    local $\ = '';
                    local $, = '';
d1583 1
a1583 11
                    # Search through the debugger's magical hash of subs.
                    # If $nocheck is true, just print the sub name.
                    # Otherwise, check it against the pattern. We then use
                    # the XOR trick to reverse the condition as required.
                    foreach $subname (sort(keys %sub)) {
                        if ($Snocheck or $Srev ^ ($subname =~ /$Spatt/)) {
                            print $OUT $subname, "\n";
                        }
                    }
                    next CMD;
                };
d1585 14
a1598 1
=head4 C<X> - list variables in current package
d1600 6
a1605 2
Since the C<V> command actually processes this, just change this to the 
appropriate C<V> command and fall through.
d1607 11
a1617 1
=cut
d1619 6
a1624 1
                $cmd =~ s/^X\b/V $package/;
d1626 8
a1633 1
=head4 C<V> - list variables
d1635 6
a1640 1
Uses C<dumpvar.pl> to dump out the current values for selected variables. 
d1642 5
a1646 1
=cut
d1648 7
a1654 5
                # Bare V commands get the currently-being-debugged package
                # added.
                $cmd =~ /^V$/ && do {
                    $cmd = "V $package";
                };
d1656 17
d1674 9
a1682 44
                # V - show variables in package.
                $cmd =~ /^V\b\s*(\S+)\s*(.*)/ && do {
                    # Save the currently selected filehandle and
                    # force output to debugger's filehandle (dumpvar
                    # just does "print" for output).
                    local ($savout) = select($OUT);

                    # Grab package name and variables to dump.
                    $packname = $1;
                    @@vars = split (' ', $2);

                    # If main::dumpvar isn't here, get it.
                    do 'dumpvar.pl' unless defined &main::dumpvar;
                    if (defined &main::dumpvar) {
                        # We got it. Turn off subroutine entry/exit messages
                        # for the moment, along with return values.
                        local $frame = 0;
                        local $doret = -2;

                        # must detect sigpipe failures  - not catching
                        # then will cause the debugger to die.
                        eval {
                            &main::dumpvar(
                                $packname,
                                defined $option{dumpDepth}
                                ? $option{dumpDepth}
                                : -1,          # assume -1 unless specified
                                @@vars
                                );
                        };

                        # The die doesn't need to include the $@@, because 
                        # it will automatically get propagated for us.
                        if ($@@) {
                            die unless $@@ =~ /dumpvar print failed/;
                        }
                    } ## end if (defined &main::dumpvar)
                    else {
                        # Couldn't load dumpvar.
                        print $OUT "dumpvar.pl not available.\n";
                    }
                    # Restore the output filehandle, and go round again.
                    select($savout);
                    next CMD;
d1684 4
d1689 29
a1717 1
=head4 C<x> - evaluate and print an expression
d1719 3
a1721 2
Hands the expression off to C<DB::eval>, setting it up to print the value
via C<dumpvar.pl> instead of just printing it directly.
d1723 21
a1743 1
=cut
d1745 79
a1823 2
                $cmd =~ s/^x\b/ / && do {   # Remainder gets done by DB::eval()
                    $onetimeDump = 'dump';  # main::dumpvar shows the output
d1825 72
a1896 6
                    # handle special  "x 3 blah" syntax XXX propagate
                    # doc back to special variables.
                    if ($cmd =~ s/^\s*(\d+)(?=\s)/ /) {
                        $onetimedumpDepth = $1;
                    }
                };
d1898 3
a1900 1
=head4 C<m> - print methods
d1902 10
a1911 1
Just uses C<DB::methods> to determine what methods are available.
d1913 5
a1917 1
=cut
d1919 2
a1920 4
                $cmd =~ s/^m\s+([\w:]+)\s*$/ / && do {
                    methods($1);
                    next CMD;
                };
d1922 8
a1929 4
                # m expr - set up DB::eval to do the work
                $cmd =~ s/^m\b/ / && do {     # Rest gets done by DB::eval()
                    $onetimeDump = 'methods'; #  method output gets used there
                };
d1931 13
a1943 1
=head4 C<f> - switch files
d1945 18
a1962 2615
=cut

                $cmd =~ /^f\b\s*(.*)/ && do {
                    $file = $1;
                    $file =~ s/\s+$//;

                    # help for no arguments (old-style was return from sub).
                    if (!$file) {
                        print $OUT
                          "The old f command is now the r command.\n";  # hint
                        print $OUT "The new f command switches filenames.\n";
                        next CMD;
                    } ## end if (!$file)

                    # if not in magic file list, try a close match.
                    if (!defined $main::{ '_<' . $file }) {
                        if (($try) = grep(m#^_<.*$file#, keys %main::)) {
                            {
                                $try = substr($try, 2);
                                print $OUT
                                  "Choosing $try matching `$file':\n";
                                $file = $try;
                            }
                        } ## end if (($try) = grep(m#^_<.*$file#...
                    } ## end if (!defined $main::{ ...

                    # If not successfully switched now, we failed.
                    if (!defined $main::{ '_<' . $file }) {
                        print $OUT "No file matching `$file' is loaded.\n";
                        next CMD;
                    }

                    # We switched, so switch the debugger internals around.
                    elsif ($file ne $filename) {
                        *dbline   = $main::{ '_<' . $file };
                        $max      = $#dbline;
                        $filename = $file;
                        $start    = 1;
                        $cmd      = "l";
                    } ## end elsif ($file ne $filename)

                    # We didn't switch; say we didn't.
                    else {
                        print $OUT "Already in $file.\n";
                        next CMD;
                    }
                };

=head4 C<.> - return to last-executed line.

We set C<$incr> to -1 to indicate that the debugger shouldn't move ahead,
and then we look up the line in the magical C<%dbline> hash.

=cut

                # . command.
                $cmd =~ /^\.$/ && do {
                    $incr     = -1;              # stay at current line

                    # Reset everything to the old location.
                    $start    = $line;
                    $filename = $filename_ini;
                    *dbline = $main::{ '_<' . $filename };
                    $max    = $#dbline;

                    # Now where are we?
                    print_lineinfo($position);
                    next CMD;
                };

=head4 C<-> - back one window

We change C<$start> to be one window back; if we go back past the first line,
we set it to be the first line. We ser C<$incr> to put us back at the
currently-executing line, and then put a C<l $start +> (list one window from
C<$start>) in C<$cmd> to be executed later.

=cut

                # - - back a window.
                $cmd =~ /^-$/ && do {
                    # back up by a window; go to 1 if back too far.
                    $start -= $incr + $window + 1;
                    $start = 1 if $start <= 0;
                    $incr = $window - 1;

                    # Generate and execute a "l +" command (handled below).
                    $cmd = 'l ' . ($start) . '+';
                };

=head3 PRE-580 COMMANDS VS. NEW COMMANDS: C<a, A, b, B, h, l, L, M, o, O, P, v, w, W, E<lt>, E<lt>E<lt>, {, {{>

In Perl 5.8.0, a realignment of the commands was done to fix up a number of
problems, most notably that the default case of several commands destroying
the user's work in setting watchpoints, actions, etc. We wanted, however, to
retain the old commands for those who were used to using them or who preferred
them. At this point, we check for the new commands and call C<cmd_wrapper> to
deal with them instead of processing them in-line.

=cut

                # All of these commands were remapped in perl 5.8.0;
                # we send them off to the secondary dispatcher (see below). 
                $cmd =~ /^([aAbBhlLMoOvwW]\b|[<>\{]{1,2})\s*(.*)/so && do {
                    &cmd_wrapper($1, $2, $line);
                    next CMD;
                };

=head4 C<y> - List lexicals in higher scope

Uses C<PadWalker> to find the lexicals supplied as arguments in a scope    
above the current one and then displays then using C<dumpvar.pl>.

=cut

                $cmd =~ /^y(?:\s+(\d*)\s*(.*))?$/ && do {

                    # See if we've got the necessary support.
                    eval { require PadWalker; PadWalker->VERSION(0.08) }
                      or &warn(
                        $@@ =~ /locate/
                        ? "PadWalker module not found - please install\n"
                        : $@@
                      )
                      and next CMD;

                    # Load up dumpvar if we don't have it. If we can, that is.
                    do 'dumpvar.pl' unless defined &main::dumpvar;
                    defined &main::dumpvar
                      or print $OUT "dumpvar.pl not available.\n"
                      and next CMD;

                    # Got all the modules we need. Find them and print them.
                    my @@vars = split (' ', $2 || '');

                    # Find the pad.
                    my $h = eval { PadWalker::peek_my(($1 || 0) + 1) };

                    # Oops. Can't find it.
                    $@@ and $@@ =~ s/ at .*//, &warn($@@), next CMD;

                    # Show the desired vars with dumplex().
                    my $savout = select($OUT);

                    # Have dumplex dump the lexicals.
                    dumpvar::dumplex(
                        $_,
                        $h->{$_},
                        defined $option{dumpDepth} ? $option{dumpDepth} : -1,
                        @@vars
                    ) for sort keys %$h;
                    select($savout);
                    next CMD;
                };

=head3 COMMANDS NOT WORKING AFTER PROGRAM ENDS

All of the commands below this point don't work after the program being
debugged has ended. All of them check to see if the program has ended; this
allows the commands to be relocated without worrying about a 'line of
demarcation' above which commands can be entered anytime, and below which
they can't.

=head4 C<n> - single step, but don't trace down into subs

Done by setting C<$single> to 2, which forces subs to execute straight through
when entered (see X<DB::sub>). We also save the C<n> command in C<$laststep>,
so a null command knows what to re-execute. 

=cut

                # n - next 
                $cmd =~ /^n$/ && do {
                    end_report(), next CMD if $finished and $level <= 1;
                    # Single step, but don't enter subs.
                    $single   = 2;
                    # Save for empty command (repeat last).
                    $laststep = $cmd;
                    last CMD;
                };

=head4 C<s> - single-step, entering subs

Sets C<$single> to 1, which causes X<DB::sub> to continue tracing inside     
subs. Also saves C<s> as C<$lastcmd>.

=cut

                # s - single step.
                $cmd =~ /^s$/ && do {
                    # Get out and restart the command loop if program
                    # has finished.
                    end_report(), next CMD if $finished and $level <= 1;
                    # Single step should enter subs.
                    $single   = 1;
                    # Save for empty command (repeat last).
                    $laststep = $cmd;
                    last CMD;
                };

=head4 C<c> - run continuously, setting an optional breakpoint

Most of the code for this command is taken up with locating the optional
breakpoint, which is either a subroutine name or a line number. We set
the appropriate one-time-break in C<@@dbline> and then turn off single-stepping
in this and all call levels above this one.

=cut

                # c - start continuous execution.
                $cmd =~ /^c\b\s*([\w:]*)\s*$/ && do {
                    # Hey, show's over. The debugged program finished
                    # executing already.
                    end_report(), next CMD if $finished and $level <= 1;

                    # Capture the place to put a one-time break.
                    $subname = $i = $1;

                    #  Probably not needed, since we finish an interactive
                    #  sub-session anyway...
                    # local $filename = $filename;
                    # local *dbline = *dbline; # XXX Would this work?!
                    #
                    # The above question wonders if localizing the alias
                    # to the magic array works or not. Since it's commented
                    # out, we'll just leave that to speculation for now.

                    # If the "subname" isn't all digits, we'll assume it
                    # is a subroutine name, and try to find it.
                    if ($subname =~ /\D/) {    # subroutine name
                        # Qualify it to the current package unless it's
                        # already qualified.
                        $subname = $package . "::" . $subname
                          unless $subname =~ /::/;
                        # find_sub will return "file:line_number" corresponding
                        # to where the subroutine is defined; we call find_sub,
                        # break up the return value, and assign it in one 
                        # operation.
                        ($file, $i) = (find_sub($subname) =~ /^(.*):(.*)$/);

                        # Force the line number to be numeric.
                        $i += 0;

                        # If we got a line number, we found the sub.
                        if ($i) {
                            # Switch all the debugger's internals around so
                            # we're actually working with that file.
                            $filename = $file;
                            *dbline   = $main::{ '_<' . $filename };
                            # Mark that there's a breakpoint in this file.
                            $had_breakpoints{$filename} |= 1;
                            # Scan forward to the first executable line
                            # after the 'sub whatever' line.
                            $max = $#dbline;
                            ++$i while $dbline[$i] == 0 && $i < $max;
                        } ## end if ($i)

                        # We didn't find a sub by that name.
                        else {
                            print $OUT "Subroutine $subname not found.\n";
                            next CMD;
                        }
                    } ## end if ($subname =~ /\D/)

                    # At this point, either the subname was all digits (an
                    # absolute line-break request) or we've scanned through
                    # the code following the definition of the sub, looking
                    # for an executable, which we may or may not have found.
                    #
                    # If $i (which we set $subname from) is non-zero, we
                    # got a request to break at some line somewhere. On 
                    # one hand, if there wasn't any real subroutine name 
                    # involved, this will be a request to break in the current 
                    # file at the specified line, so we have to check to make 
                    # sure that the line specified really is breakable.
                    #
                    # On the other hand, if there was a subname supplied, the
                    # preceeding block has moved us to the proper file and
                    # location within that file, and then scanned forward
                    # looking for the next executable line. We have to make
                    # sure that one was found.
                    #
                    # On the gripping hand, we can't do anything unless the
                    # current value of $i points to a valid breakable line.
                    # Check that.
                    if ($i) {
                        # Breakable?
                        if ($dbline[$i] == 0) {
                            print $OUT "Line $i not breakable.\n";
                            next CMD;
                        }
                        # Yes. Set up the one-time-break sigil.
                        $dbline{$i} =~
                          s/($|\0)/;9$1/;    # add one-time-only b.p.
                    } ## end if ($i)

                    # Turn off stack tracing from here up.
                    for ($i = 0 ; $i <= $stack_depth ;) {
                        $stack[$i++] &= ~1;
                    }
                    last CMD;
                };

=head4 C<r> - return from a subroutine

For C<r> to work properly, the debugger has to stop execution again
immediately after the return is executed. This is done by forcing
single-stepping to be on in the call level above the current one. If
we are printing return values when a C<r> is executed, set C<$doret>
appropriately, and force us out of the command loop.

=cut

                # r - return from the current subroutine.
                $cmd =~ /^r$/ && do {
                    # Can't do anythign if the program's over.
                    end_report(), next CMD if $finished and $level <= 1;
                    # Turn on stack trace.
                    $stack[$stack_depth] |= 1;
                    # Print return value unless the stack is empty.
                    $doret = $option{PrintRet} ? $stack_depth - 1 : -2;
                    last CMD;
                };

=head4 C<R> - restart

Restarting the debugger is a complex operation that occurs in several phases.
First, we try to reconstruct the command line that was used to invoke Perl
and the debugger.

=cut

                # R - restart execution.
                $cmd =~ /^R$/ && do {
                    # I may not be able to resurrect you, but here goes ...
                    print $OUT
"Warning: some settings and command-line options may be lost!\n";
                    my (@@script, @@flags, $cl);

                    # If warn was on before, turn it on again.
                    push @@flags, '-w' if $ini_warn;

                    # Rebuild the -I flags that were on the initial
                    # command line.
                    for (@@ini_INC) {
                        push @@flags, '-I', $_;
                    }

                    # Turn on taint if it was on before.
                    push @@flags, '-T' if ${^TAINT};

                    # Arrange for setting the old INC:
                    # Save the current @@init_INC in the environment.
                    set_list("PERLDB_INC", @@ini_INC);

                    # If this was a perl one-liner, go to the "file"
                    # corresponding to the one-liner read all the lines
                    # out of it (except for the first one, which is going
                    # to be added back on again when 'perl -d' runs: that's
                    # the 'require perl5db.pl;' line), and add them back on
                    # to the command line to be executed.
                    if ($0 eq '-e') {
                        for (1 .. $#{'::_<-e'}) {  # The first line is PERL5DB
                            chomp($cl = ${'::_<-e'}[$_]);
                            push @@script, '-e', $cl;
                        }
                    } ## end if ($0 eq '-e')

                    # Otherwise we just reuse the original name we had 
                    # before.
                    else {
                        @@script = $0;
                    }

=pod

After the command line  has been reconstructed, the next step is to save
the debugger's status in environment variables. The C<DB::set_list> routine
is used to save aggregate variables (both hashes and arrays); scalars are
just popped into environment variables directly.

=cut

                    # If the terminal supported history, grab it and
                    # save that in the environment.
                    set_list("PERLDB_HIST",
                        $term->Features->{getHistory}
                        ? $term->GetHistory
                        : @@hist);
                    # Find all the files that were visited during this
                    # session (i.e., the debugger had magic hashes
                    # corresponding to them) and stick them in the environment.
                    my @@had_breakpoints = keys %had_breakpoints;
                    set_list("PERLDB_VISITED", @@had_breakpoints);

                    # Save the debugger options we chose.
                    set_list("PERLDB_OPT",     %option);

                    # Save the break-on-loads.
                    set_list("PERLDB_ON_LOAD", %break_on_load);

=pod 

The most complex part of this is the saving of all of the breakpoints. They
can live in an awful lot of places, and we have to go through all of them,
find the breakpoints, and then save them in the appropriate environment
variable via C<DB::set_list>.

=cut

                    # Go through all the breakpoints and make sure they're
                    # still valid.
                    my @@hard;
                    for (0 .. $#had_breakpoints) {
                        # We were in this file.
                        my $file = $had_breakpoints[$_];

                        # Grab that file's magic line hash.
                        *dbline = $main::{ '_<' . $file };

                        # Skip out if it doesn't exist, or if the breakpoint
                        # is in a postponed file (we'll do postponed ones 
                        # later).
                        next unless %dbline or $postponed_file{$file};

                        # In an eval. This is a little harder, so we'll
                        # do more processing on that below.
                        (push @@hard, $file), next
                          if $file =~ /^\(\w*eval/;
                        # XXX I have no idea what this is doing. Yet. 
                        my @@add;
                        @@add = %{ $postponed_file{$file} }
                          if $postponed_file{$file};

                        # Save the list of all the breakpoints for this file.
                        set_list("PERLDB_FILE_$_", %dbline, @@add);
                    } ## end for (0 .. $#had_breakpoints)

                    # The breakpoint was inside an eval. This is a little
                    # more difficult. XXX and I don't understand it.
                    for (@@hard) {    
                        # Get over to the eval in question.
                        *dbline = $main::{ '_<' . $_ };
                        my ($quoted, $sub, %subs, $line) = quotemeta $_;
                        for $sub (keys %sub) {
                            next unless $sub{$sub} =~ /^$quoted:(\d+)-(\d+)$/;
                            $subs{$sub} = [$1, $2];
                        }
                        unless (%subs) {
                            print $OUT
                              "No subroutines in $_, ignoring breakpoints.\n";
                            next;
                        }
                      LINES: for $line (keys %dbline) {

                            # One breakpoint per sub only:
                            my ($offset, $sub, $found);
                          SUBS: for $sub (keys %subs) {
                                if (
                                    $subs{$sub}->[1] >=
                                    $line    # Not after the subroutine
                                    and (
                                        not defined $offset    # Not caught
                                        or $offset < 0
                                    )
                                  )
                                {    # or badly caught
                                    $found  = $sub;
                                    $offset = $line - $subs{$sub}->[0];
                                    $offset = "+$offset", last SUBS
                                      if $offset >= 0;
                                } ## end if ($subs{$sub}->[1] >=...
                            } ## end for $sub (keys %subs)
                            if (defined $offset) {
                                $postponed{$found} =
                                  "break $offset if $dbline{$line}";
                            }
                            else {
                                print $OUT
"Breakpoint in $_:$line ignored: after all the subroutines.\n";
                            }
                        } ## end for $line (keys %dbline)
                    } ## end for (@@hard)

                    # Save the other things that don't need to be 
                    # processed.
                    set_list("PERLDB_POSTPONE",  %postponed);
                    set_list("PERLDB_PRETYPE",   @@$pretype);
                    set_list("PERLDB_PRE",       @@$pre);
                    set_list("PERLDB_POST",      @@$post);
                    set_list("PERLDB_TYPEAHEAD", @@typeahead);

                    # We are oficially restarting.
                    $ENV{PERLDB_RESTART} = 1;

                    # We are junking all child debuggers.
                    delete $ENV{PERLDB_PIDS};    # Restore ini state

                    # Set this back to the initial pid.
                    $ENV{PERLDB_PIDS} = $ini_pids if defined $ini_pids;

=pod 

After all the debugger status has been saved, we take the command we built
up and then C<exec()> it. The debugger will spot the C<PERLDB_RESTART>
environment variable and realize it needs to reload its state from the
environment.

=cut

                    # And run Perl again. Add the "-d" flag, all the 
                    # flags we built up, the script (whether a one-liner
                    # or a file), add on the -emacs flag for a slave editor,
                    # and then the old arguments. We use exec() to keep the
                    # PID stable (and that way $ini_pids is still valid).
                    exec($^X, '-d', @@flags, @@script,
                        ($slave_editor ? '-emacs' : ()), @@ARGS) ||
                      print $OUT "exec failed: $!\n";
                    last CMD;
                };

=head4 C<T> - stack trace

Just calls C<DB::print_trace>.

=cut

                $cmd =~ /^T$/ && do {
                    print_trace($OUT, 1);        # skip DB
                    next CMD;
                };

=head4 C<w> - List window around current line.

Just calls C<DB::cmd_w>.

=cut

                $cmd =~ /^w\b\s*(.*)/s && do { &cmd_w('w', $1); next CMD; };

=head4 C<W> - watch-expression processing.

Just calls C<DB::cmd_W>. 

=cut

                $cmd =~ /^W\b\s*(.*)/s && do { &cmd_W('W', $1); next CMD; };

=head4 C</> - search forward for a string in the source

We take the argument and treat it as a pattern. If it turns out to be a 
bad one, we return the error we got from trying to C<eval> it and exit.
If not, we create some code to do the search and C<eval> it so it can't 
mess us up.

=cut

                $cmd =~ /^\/(.*)$/     && do {

                    # The pattern as a string.
                    $inpat = $1;

                    # Remove the final slash.
                    $inpat =~ s:([^\\])/$:$1:;

                    # If the pattern isn't null ...
                    if ($inpat ne "") {

                        # Turn of warn and die procesing for a bit.
                        local $SIG{__DIE__};
                        local $SIG{__WARN__};

                        # Create the pattern.
                        eval '$inpat =~ m' . "\a$inpat\a";
                        if ($@@ ne "") {
                            # Oops. Bad pattern. No biscuit.
                            # Print the eval error and go back for more 
                            # commands.
                            print $OUT "$@@";
                            next CMD;
                        }
                        $pat = $inpat;
                    } ## end if ($inpat ne "")

                    # Set up to stop on wrap-around.
                    $end  = $start;

                    # Don't move off the current line.
                    $incr = -1;

                    # Done in eval so nothing breaks if the pattern
                    # does something weird.
                    eval '
                        for (;;) {
                            # Move ahead one line.
                            ++$start;

                            # Wrap if we pass the last line.
                            $start = 1 if ($start > $max);

                            # Stop if we have gotten back to this line again,
                            last if ($start == $end);

                            # A hit! (Note, though, that we are doing
                            # case-insensitive matching. Maybe a qr//
                            # expression would be better, so the user could
                            # do case-sensitive matching if desired.
                            if ($dbline[$start] =~ m' . "\a$pat\a" . 'i) {
                                if ($slave_editor) {
                                    # Handle proper escaping in the slave.
                                    print $OUT "\032\032$filename:$start:0\n";
                                } 
                                else {
                                    # Just print the line normally.
                                    print $OUT "$start:\t",$dbline[$start],"\n";
                                }
                                # And quit since we found something.
                                last;
                            }
                         } ';
                    # If we wrapped, there never was a match.
                    print $OUT "/$pat/: not found\n" if ($start == $end);
                    next CMD;
                };

=head4 C<?> - search backward for a string in the source

Same as for C</>, except the loop runs backwards.

=cut

                # ? - backward pattern search.
                $cmd =~ /^\?(.*)$/ && do {

                    # Get the pattern, remove trailing question mark.
                    $inpat = $1;
                    $inpat =~ s:([^\\])\?$:$1:;

                    # If we've got one ...
                    if ($inpat ne "") {

                        # Turn off die & warn handlers.
                        local $SIG{__DIE__};
                        local $SIG{__WARN__};
                        eval '$inpat =~ m' . "\a$inpat\a";

                        if ($@@ ne "") {
                            # Ouch. Not good. Print the error.
                            print $OUT $@@;
                            next CMD;
                        }
                        $pat = $inpat;
                    } ## end if ($inpat ne "")

                    # Where we are now is where to stop after wraparound.
                    $end  = $start;

                    # Don't move away from this line.
                    $incr = -1;

                    # Search inside the eval to prevent pattern badness
                    # from killing us.
                    eval '
                        for (;;) {
                            # Back up a line.
                            --$start;

                            # Wrap if we pass the first line.
                            $start = $max if ($start <= 0);

                            # Quit if we get back where we started,
                            last if ($start == $end);

                            # Match?
                            if ($dbline[$start] =~ m' . "\a$pat\a" . 'i) {
                                if ($slave_editor) {
                                    # Yep, follow slave editor requirements.
                                    print $OUT "\032\032$filename:$start:0\n";
                                } 
                                else {
                                    # Yep, just print normally.
                                    print $OUT "$start:\t",$dbline[$start],"\n";
                                }

                                # Found, so done.
                                last;
                            }
                        } ';

                    # Say we failed if the loop never found anything,
                    print $OUT "?$pat?: not found\n" if ($start == $end);
                    next CMD;
                };

=head4 C<$rc> - Recall command

Manages the commands in C<@@hist> (which is created if C<Term::ReadLine> reports
that the terminal supports history). It find the the command required, puts it
into C<$cmd>, and redoes the loop to execute it.

=cut

                # $rc - recall command. 
                $cmd =~ /^$rc+\s*(-)?(\d+)?$/ && do {

                    # No arguments, take one thing off history.
                    pop (@@hist) if length($cmd) > 1;

                    # Relative (- found)? 
                    #  Y - index back from most recent (by 1 if bare minus)
                    #  N - go to that particular command slot or the last 
                    #      thing if nothing following.
                    $i = $1 ? ($#hist - ($2 || 1)) : ($2 || $#hist);

                    # Pick out the command desired.
                    $cmd = $hist[$i];

                    # Print the command to be executed and restart the loop
                    # with that command in the buffer.
                    print $OUT $cmd, "\n";
                    redo CMD;
                };

=head4 C<$sh$sh> - C<system()> command

Calls the C<DB::system()> to handle the command. This keeps the C<STDIN> and
C<STDOUT> from getting messed up.

=cut

                # $sh$sh - run a shell command (if it's all ASCII).
                # Can't run shell commands with Unicode in the debugger, hmm.
                $cmd =~ /^$sh$sh\s*([\x00-\xff]*)/ && do {
                    # System it.
                    &system($1);
                    next CMD;
                };

=head4 C<$rc I<pattern> $rc> - Search command history

Another command to manipulate C<@@hist>: this one searches it with a pattern.
If a command is found, it is placed in C<$cmd> and executed via <redo>.

=cut

                # $rc pattern $rc - find a command in the history. 
                $cmd =~ /^$rc([^$rc].*)$/ && do {
                    # Create the pattern to use.
                    $pat = "^$1";

                    # Toss off last entry if length is >1 (and it always is).
                    pop (@@hist) if length($cmd) > 1;

                    # Look backward through the history.
                    for ($i = $#hist ; $i ; --$i) {
                        # Stop if we find it.
                        last if $hist[$i] =~ /$pat/;
                    }

                    if (!$i) {
                        # Never found it.
                        print $OUT "No such command!\n\n";
                        next CMD;
                    }

                    # Found it. Put it in the buffer, print it, and process it.
                    $cmd = $hist[$i];
                    print $OUT $cmd, "\n";
                    redo CMD;
                };

=head4 C<$sh> - Invoke a shell     

Uses C<DB::system> to invoke a shell.

=cut

                # $sh - start a shell.
                $cmd =~ /^$sh$/ && do {
                    # Run the user's shell. If none defined, run Bourne.
                    # We resume execution when the shell terminates.
                    &system($ENV{SHELL} || "/bin/sh");
                    next CMD;
                };

=head4 C<$sh I<command>> - Force execution of a command in a shell

Like the above, but the command is passed to the shell. Again, we use
C<DB::system> to avoid problems with C<STDIN> and C<STDOUT>.

=cut

                # $sh command - start a shell and run a command in it.
                $cmd =~ /^$sh\s*([\x00-\xff]*)/ && do {
                    # XXX: using csh or tcsh destroys sigint retvals!
                    #&system($1);  # use this instead

                    # use the user's shell, or Bourne if none defined.
                    &system($ENV{SHELL} || "/bin/sh", "-c", $1);
                    next CMD;
                };

=head4 C<H> - display commands in history

Prints the contents of C<@@hist> (if any).

=cut

                $cmd =~ /^H\b\s*(-(\d+))?/ && do {
                    # Anything other than negative numbers is ignored by 
                    # the (incorrect) pattern, so this test does nothing.
                    $end = $2 ? ($#hist - $2) : 0;

                    # Set to the minimum if less than zero.
                    $hist = 0 if $hist < 0;

                    # Start at the end of the array. 
                    # Stay in while we're still above the ending value.
                    # Tick back by one each time around the loop.
                    for ($i = $#hist ; $i > $end ; $i--) {

                        # Print the command  unless it has no arguments.
                        print $OUT "$i: ", $hist[$i], "\n"
                          unless $hist[$i] =~ /^.?$/;
                    }
                    next CMD;
                };

=head4 C<man, doc, perldoc> - look up documentation

Just calls C<runman()> to print the appropriate document.

=cut

                # man, perldoc, doc - show manual pages.               
                $cmd =~ /^(?:man|(?:perl)?doc)\b(?:\s+([^(]*))?$/ && do {
                    runman($1);
                    next CMD;
                };

=head4 C<p> - print

Builds a C<print EXPR> expression in the C<$cmd>; this will get executed at
the bottom of the loop.

=cut

                # p - print (no args): print $_.
                $cmd =~ s/^p$/print {\$DB::OUT} \$_/;

                # p - print the given expression.
                $cmd =~ s/^p\b/print {\$DB::OUT} /;

=head4 C<=> - define command alias

Manipulates C<%alias> to add or list command aliases.

=cut

                 # = - set up a command alias.
                $cmd =~ s/^=\s*// && do {
                    my @@keys;
                    if (length $cmd == 0) {
                        # No args, get current aliases.
                        @@keys = sort keys %alias;
                    }
                    elsif (my ($k, $v) = ($cmd =~ /^(\S+)\s+(\S.*)/)) {
                        # Creating a new alias. $k is alias name, $v is
                        # alias value.

                        # can't use $_ or kill //g state
                        for my $x ($k, $v) { 
                          # Escape "alarm" characters.
                          $x =~ s/\a/\\a/g 
                        }

                        # Substitute key for value, using alarm chars
                        # as separators (which is why we escaped them in 
                        # the command).
                        $alias{$k} = "s\a$k\a$v\a";

                        # Turn off standard warn and die behavior.
                        local $SIG{__DIE__};
                        local $SIG{__WARN__};

                        # Is it valid Perl?
                        unless (eval "sub { s\a$k\a$v\a }; 1") {
                            # Nope. Bad alias. Say so and get out.
                            print $OUT "Can't alias $k to $v: $@@\n";
                            delete $alias{$k};
                            next CMD;
                        }
                        # We'll only list the new one.
                        @@keys = ($k);
                    } ## end elsif (my ($k, $v) = ($cmd...

                    # The argument is the alias to list.
                    else {
                        @@keys = ($cmd);
                    }

                    # List aliases.
                    for my $k (@@keys) {
                        # Messy metaquoting: Trim the substiution code off.
                        # We use control-G as the delimiter because it's not
                        # likely to appear in the alias.
                        if ((my $v = $alias{$k}) =~ ss\a$k\a(.*)\a$1) {
                            # Print the alias.
                            print $OUT "$k\t= $1\n";
                        }
                        elsif (defined $alias{$k}) {
                            # Couldn't trim it off; just print the alias code.
                            print $OUT "$k\t$alias{$k}\n";
                        }
                        else {
                            # No such, dude.
                            print "No alias for $k\n";
                        }
                    } ## end for my $k (@@keys)
                    next CMD;
                };

=head4 C<source> - read commands from a file.

Opens a lexical filehandle and stacks it on C<@@cmdfhs>; C<DB::readline> will
pick it up.

=cut

                # source - read commands from a file (or pipe!) and execute. 
                $cmd =~ /^source\s+(.*\S)/ && do {
                    if (open my $fh, $1) {
                        # Opened OK; stick it in the list of file handles.
                        push @@cmdfhs, $fh;
                    }
                    else {
                        # Couldn't open it. 
                        &warn("Can't execute `$1': $!\n");
                    }
                    next CMD;
                };

=head4 C<|, ||> - pipe output through the pager.

FOR C<|>, we save C<OUT> (the debugger's output filehandle) and C<STDOUT>
(the program's standard output). For C<||>, we only save C<OUT>. We open a
pipe to the pager (restoring the output filehandles if this fails). If this
is the C<|> command, we also set up a C<SIGPIPE> handler which will simply 
set C<$signal>, sending us back into the debugger.

We then trim off the pipe symbols and C<redo> the command loop at the
C<PIPE> label, causing us to evaluate the command in C<$cmd> without
reading another.

=cut

                # || - run command in the pager, with output to DB::OUT.
                $cmd =~ /^\|\|?\s*[^|]/ && do {
                    if ($pager =~ /^\|/) {
                        # Default pager is into a pipe. Redirect I/O.
                        open(SAVEOUT, ">&STDOUT") ||
                          &warn("Can't save STDOUT");
                        open(STDOUT, ">&OUT") ||
                          &warn("Can't redirect STDOUT");
                    } ## end if ($pager =~ /^\|/)
                    else {
                        # Not into a pipe. STDOUT is safe.
                        open(SAVEOUT, ">&OUT") || &warn("Can't save DB::OUT");
                    }

                    # Fix up environment to record we have less if so.
                    fix_less();

                    unless ($piped = open(OUT, $pager)) {
                        # Couldn't open pipe to pager.
                        &warn("Can't pipe output to `$pager'");
                        if ($pager =~ /^\|/) {
                            # Redirect I/O back again.
                            open(OUT, ">&STDOUT")    # XXX: lost message
                              || &warn("Can't restore DB::OUT");
                            open(STDOUT, ">&SAVEOUT") ||
                              &warn("Can't restore STDOUT");
                            close(SAVEOUT);
                        } ## end if ($pager =~ /^\|/)
                        else {
                            # Redirect I/O. STDOUT already safe.
                            open(OUT, ">&STDOUT")    # XXX: lost message
                              || &warn("Can't restore DB::OUT");
                        }
                        next CMD;
                    } ## end unless ($piped = open(OUT,...

                    # Set up broken-pipe handler if necessary.
                    $SIG{PIPE} = \&DB::catch
                      if $pager =~ /^\|/ &&
                      ("" eq $SIG{PIPE} || "DEFAULT" eq $SIG{PIPE});

                    # Save current filehandle, unbuffer out, and put it back.
                    $selected = select(OUT);
                    $|        = 1;

                    # Don't put it back if pager was a pipe.
                    select($selected), $selected = "" unless $cmd =~ /^\|\|/;

                    # Trim off the pipe symbols and run the command now.
                    $cmd =~ s/^\|+\s*//;
                    redo PIPE;
                };


=head3 END OF COMMAND PARSING

Anything left in C<$cmd> at this point is a Perl expression that we want to 
evaluate. We'll always evaluate in the user's context, and fully qualify 
any variables we might want to address in the C<DB> package.

=cut

                # t - turn trace on.
                $cmd =~ s/^t\s/\$DB::trace |= 1;\n/;

                # s - single-step. Remember the last command was 's'.
                $cmd =~ s/^s\s/\$DB::single = 1;\n/ && do { $laststep = 's' };

                # n - single-step, but not into subs. Remember last command
                # was 'n'.
                $cmd =~ s/^n\s/\$DB::single = 2;\n/ && do { $laststep = 'n' };

            }    # PIPE:

            # Make sure the flag that says "the debugger's running" is 
            # still on, to make sure we get control again.
            $evalarg = "\$^D = \$^D | \$DB::db_stop;\n$cmd";

            # Run *our* eval that executes in the caller's context.
            &eval;

            # Turn off the one-time-dump stuff now.
            if ($onetimeDump) {
                $onetimeDump      = undef;
                $onetimedumpDepth = undef;
            }
            elsif ($term_pid == $$) {
                STDOUT->flush();
                STDERR->flush();
                # XXX If this is the master pid, print a newline.
                print $OUT "\n";
            }
        } ## end while (($term || &setterm...

=head3 POST-COMMAND PROCESSING

After each command, we check to see if the command output was piped anywhere.
If so, we go through the necessary code to unhook the pipe and go back to
our standard filehandles for input and output.

=cut

        continue {    # CMD:

            # At the end of every command:
            if ($piped) {
                # Unhook the pipe mechanism now.
                if ($pager =~ /^\|/) {
                    # No error from the child.
                    $? = 0;

                    # we cannot warn here: the handle is missing --tchrist
                    close(OUT) || print SAVEOUT "\nCan't close DB::OUT\n";

                    # most of the $? crud was coping with broken cshisms
                    # $? is explicitly set to 0, so this never runs.
                    if ($?) {
                        print SAVEOUT "Pager `$pager' failed: ";
                        if ($? == -1) {
                            print SAVEOUT "shell returned -1\n";
                        }
                        elsif ($? >> 8) {
                            print SAVEOUT ($? & 127)
                              ? " (SIG#" . ($? & 127) . ")"
                              : "", ($? & 128) ? " -- core dumped" : "", "\n";
                        }
                        else {
                            print SAVEOUT "status ", ($? >> 8), "\n";
                        }
                    } ## end if ($?)

                    # Reopen filehandle for our output (if we can) and 
                    # restore STDOUT (if we can).
                    open(OUT, ">&STDOUT") || &warn("Can't restore DB::OUT");
                    open(STDOUT, ">&SAVEOUT") ||
                      &warn("Can't restore STDOUT");

                    # Turn off pipe exception handler if necessary.
                    $SIG{PIPE} = "DEFAULT" if $SIG{PIPE} eq \&DB::catch;

                    # Will stop ignoring SIGPIPE if done like nohup(1)
                    # does SIGINT but Perl doesn't give us a choice.
                } ## end if ($pager =~ /^\|/)
                else {
                    # Non-piped "pager". Just restore STDOUT.
                    open(OUT, ">&SAVEOUT") || &warn("Can't restore DB::OUT");
                }

                # Close filehandle pager was using, restore the normal one
                # if necessary,
                close(SAVEOUT);
                select($selected), $selected = "" unless $selected eq "";

                # No pipes now.
                $piped = "";
            } ## end if ($piped)
        }    # CMD:

=head3 COMMAND LOOP TERMINATION

When commands have finished executing, we come here. If the user closed the
input filehandle, we turn on C<$fall_off_end> to emulate a C<q> command. We
evaluate any post-prompt items. We restore C<$@@>, C<$!>, C<$^E>, C<$,>, C<$/>,
C<$\>, and C<$^W>, and return a null list as expected by the Perl interpreter.
The interpreter will then execute the next line and then return control to us
again.

=cut

        # No more commands? Quit.
        $fall_off_end = 1 unless defined $cmd;    # Emulate `q' on EOF

        # Evaluate post-prompt commands.
        foreach $evalarg (@@$post) {
            &eval;
        }
    }    # if ($single || $signal)

    # Put the user's globals back where you found them.
    ($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;
    ();
} ## end sub DB

# The following code may be executed now:
# BEGIN {warn 4}

=head2 sub

C<sub> is called whenever a subroutine call happens in the program being 
debugged. The variable C<$DB::sub> contains the name of the subroutine
being called.

The core function of this subroutine is to actually call the sub in the proper
context, capturing its output. This of course causes C<DB::DB> to get called
again, repeating until the subroutine ends and returns control to C<DB::sub>
again. Once control returns, C<DB::sub> figures out whether or not to dump the
return value, and returns its captured copy of the return value as its own
return value. The value then feeds back into the program being debugged as if
C<DB::sub> hadn't been there at all.

C<sub> does all the work of printing the subroutine entry and exit messages
enabled by setting C<$frame>. It notes what sub the autoloader got called for,
and also prints the return value if needed (for the C<r> command and if 
the 16 bit is set in C<$frame>).

It also tracks the subroutine call depth by saving the current setting of
C<$single> in the C<@@stack> package global; if this exceeds the value in
C<$deep>, C<sub> automatically turns on printing of the current depth by
setting the 4 bit in C<$single>. In any case, it keeps the current setting
of stop/don't stop on entry to subs set as it currently is set.

=head3 C<caller()> support

If C<caller()> is called from the package C<DB>, it provides some
additional data, in the following order:

=over 4

=item * C<$package>

The package name the sub was in

=item * C<$filename>

The filename it was defined in

=item * C<$line>

The line number it was defined on

=item * C<$subroutine>

The subroutine name; C<'(eval)'> if an C<eval>().

=item * C<$hasargs>

1 if it has arguments, 0 if not

=item * C<$wantarray>

1 if array context, 0 if scalar context

=item * C<$evaltext>

The C<eval>() text, if any (undefined for C<eval BLOCK>)

=item * C<$is_require>

frame was created by a C<use> or C<require> statement

=item * C<$hints>

pragma information; subject to change between versions

=item * C<$bitmask>

pragma information: subject to change between versions

=item * C<@@DB::args>

arguments with which the subroutine was invoked

=back

=cut

sub sub {

    # Whether or not the autoloader was running, a scalar to put the
    # sub's return value in (if needed), and an array to put the sub's
    # return value in (if needed).
    my ($al, $ret, @@ret) = "";

    # If the last ten characters are C'::AUTOLOAD', note we've traced
    # into AUTOLOAD for $sub.
    if (length($sub) > 10 && substr($sub, -10, 10) eq '::AUTOLOAD') {
        $al = " for $$sub";
    }

    # We stack the stack pointer and then increment it to protect us
    # from a situation that might unwind a whole bunch of call frames
    # at once. Localizing the stack pointer means that it will automatically
    # unwind the same amount when multiple stack frames are unwound.
    local $stack_depth = $stack_depth + 1;    # Protect from non-local exits

    # Expand @@stack.
    $#stack = $stack_depth;

    # Save current single-step setting.
    $stack[-1] = $single;

    # Turn off all flags except single-stepping. 
    $single &= 1;

    # If we've gotten really deeply recursed, turn on the flag that will
    # make us stop with the 'deep recursion' message.
    $single |= 4 if $stack_depth == $deep;

    # If frame messages are on ...
    (
        $frame & 4    # Extended frame entry message
        ? (
            print_lineinfo(' ' x ($stack_depth - 1), "in  "),

            # Why -1? But it works! :-(
            # Because print_trace will call add 1 to it and then call
            # dump_trace; this results in our skipping -1+1 = 0 stack frames
            # in dump_trace.
            print_trace($LINEINFO, -1, 1, 1, "$sub$al")
          )
        : print_lineinfo(' ' x ($stack_depth - 1), "entering $sub$al\n")
          # standard frame entry message
      )
      if $frame;

    # Determine the sub's return type,and capture approppriately.
    if (wantarray) {
        # Called in array context. call sub and capture output.
        # DB::DB will recursively get control again if appropriate; we'll come
        # back here when the sub is finished.
        @@ret = &$sub;

        # Pop the single-step value back off the stack.
        $single |= $stack[$stack_depth--];

        # Check for exit trace messages...
        (
            $frame & 4         # Extended exit message
            ? (
                print_lineinfo(' ' x $stack_depth, "out "),
                print_trace($LINEINFO, -1, 1, 1, "$sub$al")
              )
            : print_lineinfo(' ' x $stack_depth, "exited $sub$al\n")
              # Standard exit message
          )
          if $frame & 2;

        # Print the return info if we need to.
        if ($doret eq $stack_depth or $frame & 16) {
            # Turn off output record separator.
            local $\ = '';
            my $fh = ($doret eq $stack_depth ? $OUT : $LINEINFO);

            # Indent if we're printing because of $frame tracing.
            print $fh ' ' x $stack_depth if $frame & 16;

            # Print the return value.
            print $fh "list context return from $sub:\n";
            dumpit($fh, \@@ret);

            # And don't print it again.
            $doret = -2;
        } ## end if ($doret eq $stack_depth...
        # And we have to return the return value now.
        @@ret;

    } ## end if (wantarray)

    # Scalar context.
    else {
        if (defined wantarray) {
            # Save the value if it's wanted at all. 
            $ret = &$sub;
        }
        else {
            # Void return, explicitly.
            &$sub;
            undef $ret;
        }

        # Pop the single-step value off the stack.
        $single |= $stack[$stack_depth--];

        # If we're doing exit messages...
        (
            $frame & 4                        # Extended messsages
            ? (
                print_lineinfo(' ' x $stack_depth, "out "),
                print_trace($LINEINFO, -1, 1, 1, "$sub$al")
              )
            : print_lineinfo(' ' x $stack_depth, "exited $sub$al\n")
                                              # Standard messages
          )
          if $frame & 2;

        # If we are supposed to show the return value... same as before.
        if ($doret eq $stack_depth or $frame & 16 and defined wantarray) {
            local $\ = '';
            my $fh = ($doret eq $stack_depth ? $OUT : $LINEINFO);
            print $fh (' ' x $stack_depth) if $frame & 16;
            print $fh (
                defined wantarray
                ? "scalar context return from $sub: "
                : "void context return from $sub\n"
                );
            dumpit($fh, $ret) if defined wantarray;
            $doret = -2;
        } ## end if ($doret eq $stack_depth...

        # Return the appropriate scalar value.
        $ret;
    } ## end else [ if (wantarray)
} ## end sub sub

=head1 EXTENDED COMMAND HANDLING AND THE COMMAND API

In Perl 5.8.0, there was a major realignment of the commands and what they did,
Most of the changes were to systematize the command structure and to eliminate
commands that threw away user input without checking.

The following sections describe the code added to make it easy to support 
multiple command sets with conflicting command names. This section is a start 
at unifying all command processing to make it simpler to develop commands.

Note that all the cmd_[a-zA-Z] subroutines require the command name, a line 
number, and C<$dbline> (the current line) as arguments.

Support functions in this section which have multiple modes of failure C<die> 
on error; the rest simply return a false value.

The user-interface functions (all of the C<cmd_*> functions) just output
error messages.

=head2 C<%set>

The C<%set> hash defines the mapping from command letter to subroutine
name suffix. 

C<%set> is a two-level hash, indexed by set name and then by command name.
Note that trying to set the CommandSet to 'foobar' simply results in the
5.8.0 command set being used, since there's no top-level entry for 'foobar'.

=cut 

### The API section

my %set = (    #
    'pre580' => {
        'a' => 'pre580_a',
        'A' => 'pre580_null',
        'b' => 'pre580_b',
        'B' => 'pre580_null',
        'd' => 'pre580_null',
        'D' => 'pre580_D',
        'h' => 'pre580_h',
        'M' => 'pre580_null',
        'O' => 'o',
        'o' => 'pre580_null',
        'v' => 'M',
        'w' => 'v',
        'W' => 'pre580_W',
    },
    'pre590' => {
        '<'  => 'pre590_prepost',
        '<<' => 'pre590_prepost',
        '>'  => 'pre590_prepost',
        '>>' => 'pre590_prepost',
        '{'  => 'pre590_prepost',
        '{{' => 'pre590_prepost',
    },
  );

=head2 C<cmd_wrapper()> (API)

C<cmd_wrapper()> allows the debugger to switch command sets 
depending on the value of the C<CommandSet> option. 

It tries to look up the command in the X<C<%set>> package-level I<lexical>
(which means external entities can't fiddle with it) and create the name of 
the sub to call based on the value found in the hash (if it's there). I<All> 
of the commands to be handled in a set have to be added to C<%set>; if they 
aren't found, the 5.8.0 equivalent is called (if there is one).

This code uses symbolic references. 

=cut

sub cmd_wrapper {
    my $cmd      = shift;
    my $line     = shift;
    my $dblineno = shift;

    # Assemble the command subroutine's name by looking up the 
    # command set and command name in %set. If we can't find it,
    # default to the older version of the command.
    my $call = 'cmd_'
      . ( $set{$CommandSet}{$cmd}
          || ( $cmd =~ /^[<>{]+/o ? 'prepost' : $cmd ) );

    # Call the command subroutine, call it by name.
    return &$call($cmd, $line, $dblineno);
} ## end sub cmd_wrapper

=head3 C<cmd_a> (command)

The C<a> command handles pre-execution actions. These are associated with a
particular line, so they're stored in C<%dbline>. We default to the current 
line if none is specified. 

=cut

sub cmd_a {
    my $cmd  = shift;
    my $line = shift || '';    # [.|line] expr
    my $dbline = shift;

    # If it's dot (here), or not all digits,  use the current line.
    $line =~ s/^(\.|(?:[^\d]))/$dbline/;

    # Should be a line number followed by an expression. 
    if ($line =~ /^\s*(\d*)\s*(\S.+)/) {
        my ($lineno, $expr) = ($1, $2);

        # If we have an expression ...
        if (length $expr) {
            # ... but the line isn't breakable, complain.
            if ($dbline[$lineno] == 0) {
                print $OUT
                  "Line $lineno($dbline[$lineno]) does not have an action?\n";
            }
            else {
                # It's executable. Record that the line has an action.
                $had_breakpoints{$filename} |= 2;

                # Remove any action, temp breakpoint, etc.
                $dbline{$lineno} =~ s/\0[^\0]*//;

                # Add the action to the line.
                $dbline{$lineno} .= "\0" . action($expr);
            }
        } ## end if (length $expr)
    } ## end if ($line =~ /^\s*(\d*)\s*(\S.+)/)
    else {
        # Syntax wrong.
        print $OUT
          "Adding an action requires an optional lineno and an expression\n"
          ;    # hint
    }
} ## end sub cmd_a

=head3 C<cmd_A> (command)

Delete actions. Similar to above, except the delete code is in a separate
subroutine, C<delete_action>.

=cut

sub cmd_A {
    my $cmd  = shift;
    my $line = shift || '';
    my $dbline = shift;

    # Dot is this line.
    $line =~ s/^\./$dbline/;

    # Call delete_action with a null param to delete them all.
    # The '1' forces the eval to be true. It'll be false only
    # if delete_action blows up for some reason, in which case
    # we print $@@ and get out.
    if ($line eq '*') {
        eval { &delete_action(); 1 } or print $OUT $@@ and return;
    }

    # There's a real line  number. Pass it to delete_action.
    # Error trapping is as above.
    elsif ($line =~ /^(\S.*)/) {
        eval { &delete_action($1); 1 } or print $OUT $@@ and return;
    }

    # Swing and a miss. Bad syntax.
    else {
        print $OUT
          "Deleting an action requires a line number, or '*' for all\n"
          ;    # hint
    }
} ## end sub cmd_A

=head3 C<delete_action> (API)

C<delete_action> accepts either a line number or C<undef>. If a line number
is specified, we check for the line being executable (if it's not, it 
couldn't have had an  action). If it is, we just take the action off (this
will get any kind of an action, including breakpoints).

=cut

sub delete_action {
    my $i = shift;
    if (defined($i)) {
        # Can there be one?
        die "Line $i has no action .\n" if $dbline[$i] == 0;

        # Nuke whatever's there.
        $dbline{$i} =~ s/\0[^\0]*//;    # \^a
        delete $dbline{$i} if $dbline{$i} eq '';
    }
    else {
        print $OUT "Deleting all actions...\n";
        for my $file (keys %had_breakpoints) {
            local *dbline = $main::{ '_<' . $file };
            my $max = $#dbline;
            my $was;
            for ($i = 1 ; $i <= $max ; $i++) {
                if (defined $dbline{$i}) {
                    $dbline{$i} =~ s/\0[^\0]*//;
                    delete $dbline{$i} if $dbline{$i} eq '';
                }
                unless ($had_breakpoints{$file} &= ~2) {
                    delete $had_breakpoints{$file};
                }
            } ## end for ($i = 1 ; $i <= $max...
        } ## end for my $file (keys %had_breakpoints)
    } ## end else [ if (defined($i))
} ## end sub delete_action

=head3 C<cmd_b> (command)

Set breakpoints. Since breakpoints can be set in so many places, in so many
ways, conditionally or not, the breakpoint code is kind of complex. Mostly,
we try to parse the command type, and then shuttle it off to an appropriate
subroutine to actually do the work of setting the breakpoint in the right
place.

=cut

sub cmd_b {
    my $cmd    = shift;
    my $line   = shift;    # [.|line] [cond]
    my $dbline = shift;

    # Make . the current line number if it's there..
    $line =~ s/^\./$dbline/;

    # No line number, no condition. Simple break on current line. 
    if ($line =~ /^\s*$/) {
        &cmd_b_line($dbline, 1);
    }

    # Break on load for a file.
    elsif ($line =~ /^load\b\s*(.*)/) {
        my $file = $1;
        $file =~ s/\s+$//;
        &cmd_b_load($file);
    }

    # b compile|postpone <some sub> [<condition>]
    # The interpreter actually traps this one for us; we just put the 
    # necessary condition in the %postponed hash.
    elsif ($line =~ /^(postpone|compile)\b\s*([':A-Za-z_][':\w]*)\s*(.*)/) {
        # Capture the condition if there is one. Make it true if none.
        my $cond = length $3 ? $3 : '1';

        # Save the sub name and set $break to 1 if $1 was 'postpone', 0
        # if it was 'compile'.
        my ($subname, $break) = ($2, $1 eq 'postpone');

        # De-Perl4-ify the name - ' separators to ::.
        $subname =~ s/\'/::/g;

        # Qualify it into the current package unless it's already qualified.
        $subname = "${'package'}::" . $subname unless $subname =~ /::/;

        # Add main if it starts with ::.
        $subname = "main" . $subname if substr($subname, 0, 2) eq "::";

        # Save the break type for this sub.
        $postponed{$subname} = $break ? "break +0 if $cond" : "compile";
    } ## end elsif ($line =~ ...

    # b <sub name> [<condition>]
    elsif ($line =~ /^([':A-Za-z_][':\w]*(?:\[.*\])?)\s*(.*)/) {
        # 
        $subname = $1;
        $cond = length $2 ? $2 : '1';
        &cmd_b_sub($subname, $cond);
    }

    # b <line> [<condition>].
    elsif ($line =~ /^(\d*)\s*(.*)/) {
        # Capture the line. If none, it's the current line.
        $line = $1 || $dbline;

        # If there's no condition, make it '1'.
        $cond = length $2 ? $2 : '1';

        # Break on line.
        &cmd_b_line($line, $cond);
    }

    # Line didn't make sense.
    else {
        print "confused by line($line)?\n";
    }
} ## end sub cmd_b

=head3 C<break_on_load> (API)

We want to break when this file is loaded. Mark this file in the
C<%break_on_load> hash, and note that it has a breakpoint in 
C<%had_breakpoints>.

=cut

sub break_on_load {
    my $file = shift;
    $break_on_load{$file} = 1;
    $had_breakpoints{$file} |= 1;
}

=head3 C<report_break_on_load> (API)

Gives us an array of filenames that are set to break on load. Note that 
only files with break-on-load are in here, so simply showing the keys
suffices.

=cut

sub report_break_on_load {
    sort keys %break_on_load;
}

=head3 C<cmd_b_load> (command)

We take the file passed in and try to find it in C<%INC> (which maps modules
to files they came from). We mark those files for break-on-load via 
C<break_on_load> and then report that it was done.

=cut

sub cmd_b_load {
    my $file = shift;
    my @@files;

    # This is a block because that way we can use a redo inside it
    # even without there being any looping structure at all outside it.
    {
        # Save short name and full path if found.
        push @@files, $file;
        push @@files, $::INC{$file} if $::INC{$file};

        # Tack on .pm and do it again unless there was a '.' in the name 
        # already.
        $file .= '.pm', redo unless $file =~ /\./;
    }

    # Do the real work here.
    break_on_load($_) for @@files;

    # All the files that have break-on-load breakpoints.
    @@files = report_break_on_load;

    # Normalize for the purposes of our printing this.
    local $\ = '';
    local $" = ' ';
    print $OUT "Will stop on load of `@@files'.\n";
} ## end sub cmd_b_load

=head3 C<$filename_error> (API package global)

Several of the functions we need to implement in the API need to work both
on the current file and on other files. We don't want to duplicate code, so
C<$filename_error> is used to contain the name of the file that's being 
worked on (if it's not the current one).

We can now build functions in pairs: the basic function works on the current
file, and uses C<$filename_error> as part of its error message. Since this is
initialized to C<''>, no filename will appear when we are working on the
current file.

The second function is a wrapper which does the following:

=over 4 

=item * Localizes C<$filename_error> and sets it to the name of the file to be processed.

=item * Localizes the C<*dbline> glob and reassigns it to point to the file we want to process. 

=item * Calls the first function. 

The first function works on the "current" (i.e., the one we changed to) file,
and prints C<$filename_error> in the error message (the name of the other file)
if it needs to. When the functions return, C<*dbline> is restored to point to the actual current file (the one we're executing in) and C<$filename_error> is 
restored to C<''>. This restores everything to the way it was before the 
second function was called at all.

See the comments in C<breakable_line> and C<breakable_line_in_file> for more
details.

=back

=cut

$filename_error = '';

=head3 breakable_line($from, $to) (API)

The subroutine decides whether or not a line in the current file is breakable.
It walks through C<@@dbline> within the range of lines specified, looking for
the first line that is breakable.

If C<$to> is greater than C<$from>, the search moves forwards, finding the 
first line I<after> C<$to> that's breakable, if there is one.

If C<$from> is greater than C<$to>, the search goes I<backwards>, finding the
first line I<before> C<$to> that's breakable, if there is one.

=cut

sub breakable_line {
    
    my ($from, $to) = @@_;

    # $i is the start point. (Where are the FORTRAN programs of yesteryear?)
    my $i = $from;

    # If there are at least 2 arguments, we're trying to search a range.
    if (@@_ >= 2) {

        # $delta is positive for a forward search, negative for a backward one.
        my $delta = $from < $to ? +1 : -1;

        # Keep us from running off the ends of the file.
        my $limit = $delta > 0 ? $#dbline : 1;

        # Clever test. If you're a mathematician, it's obvious why this
        # test works. If not:
        # If $delta is positive (going forward), $limit will be $#dbline.
        #    If $to is less than $limit, ($limit - $to) will be positive, times
        #    $delta of 1 (positive), so the result is > 0 and we should use $to
        #    as the stopping point. 
        #
        #    If $to is greater than $limit, ($limit - $to) is negative,
        #    times $delta of 1 (positive), so the result is < 0 and we should 
        #    use $limit ($#dbline) as the stopping point.
        #
        # If $delta is negative (going backward), $limit will be 1. 
        #    If $to is zero, ($limit - $to) will be 1, times $delta of -1
        #    (negative) so the result is > 0, and we use $to as the stopping
        #    point.
        #
        #    If $to is less than zero, ($limit - $to) will be positive,
        #    times $delta of -1 (negative), so the result is not > 0, and 
        #    we use $limit (1) as the stopping point. 
        #
        #    If $to is 1, ($limit - $to) will zero, times $delta of -1
        #    (negative), still giving zero; the result is not > 0, and 
        #    we use $limit (1) as the stopping point.
        #
        #    if $to is >1, ($limit - $to) will be negative, times $delta of -1
        #    (negative), giving a positive (>0) value, so we'll set $limit to
        #    $to.
        
        $limit = $to if ($limit - $to) * $delta > 0;

        # The real search loop.
        # $i starts at $from (the point we want to start searching from).
        # We move through @@dbline in the appropriate direction (determined
        # by $delta: either -1 (back) or +1 (ahead). 
        # We stay in as long as we haven't hit an executable line 
        # ($dbline[$i] == 0 means not executable) and we haven't reached
        # the limit yet (test similar to the above).
        $i += $delta while $dbline[$i] == 0 and ($limit - $i) * $delta > 0;

    } ## end if (@@_ >= 2)

    # If $i points to a line that is executable, return that.
    return $i unless $dbline[$i] == 0;

    # Format the message and print it: no breakable lines in range.
    my ($pl, $upto) = ('', '');
    ($pl, $upto) = ('s', "..$to") if @@_ >= 2 and $from != $to;

    # If there's a filename in filename_error, we'll see it.
    # If not, not.
    die "Line$pl $from$upto$filename_error not breakable\n";
} ## end sub breakable_line

=head3 breakable_line_in_filename($file, $from, $to) (API)

Like C<breakable_line>, but look in another file.

=cut

sub breakable_line_in_filename {
    # Capture the file name.
    my ($f) = shift;

    # Swap the magic line array over there temporarily.
    local *dbline         = $main::{ '_<' . $f };

    # If there's an error, it's in this other file.
    local $filename_error = " of `$f'";

    # Find the breakable line.
    breakable_line(@@_);

    # *dbline and $filename_error get restored when this block ends.

} ## end sub breakable_line_in_filename

=head3 break_on_line(lineno, [condition]) (API)

Adds a breakpoint with the specified condition (or 1 if no condition was 
specified) to the specified line. Dies if it can't.

=cut

sub break_on_line {
    my ($i, $cond) = @@_;

    # Always true if no condition supplied.
    $cond = 1 unless @@_ >= 2;

    my $inii  = $i;
    my $after = '';
    my $pl    = '';

    # Woops, not a breakable line. $filename_error allows us to say
    # if it was in a different file.
    die "Line $i$filename_error not breakable.\n" if $dbline[$i] == 0;

    # Mark this file as having breakpoints in it.
    $had_breakpoints{$filename} |= 1;

    # If there is an action or condition here already ... 
    if ($dbline{$i}) { 
        # ... swap this condition for the existing one.
        $dbline{$i} =~ s/^[^\0]*/$cond/; 
    }
    else { 
        # Nothing here - just add the condition.
        $dbline{$i} = $cond; 
    }
} ## end sub break_on_line

=head3 cmd_b_line(line, [condition]) (command)

Wrapper for C<break_on_line>. Prints the failure message if it 
doesn't work.

=cut 

sub cmd_b_line {
    eval { break_on_line(@@_); 1 } or do {
        local $\ = '';
        print $OUT $@@ and return;
    };
} ## end sub cmd_b_line

=head3 break_on_filename_line(file, line, [condition]) (API)

Switches to the file specified and then calls C<break_on_line> to set 
the breakpoint.

=cut

sub break_on_filename_line {
    my ($f, $i, $cond) = @@_;

    # Always true if condition left off.
    $cond = 1 unless @@_ >= 3;

    # Switch the magical hash temporarily.
    local *dbline         = $main::{ '_<' . $f };

    # Localize the variables that break_on_line uses to make its message.
    local $filename_error = " of `$f'";
    local $filename       = $f;

    # Add the breakpoint.
    break_on_line($i, $cond);
} ## end sub break_on_filename_line

=head3 break_on_filename_line_range(file, from, to, [condition]) (API)

Switch to another file, search the range of lines specified for an 
executable one, and put a breakpoint on the first one you find.

=cut

sub break_on_filename_line_range {
    my ($f, $from, $to, $cond) = @@_;

    # Find a breakable line if there is one.
    my $i = breakable_line_in_filename($f, $from, $to);

    # Always true if missing.
    $cond = 1 unless @@_ >= 3;

    # Add the breakpoint.
    break_on_filename_line($f, $i, $cond);
} ## end sub break_on_filename_line_range

=head3 subroutine_filename_lines(subname, [condition]) (API)

Search for a subroutine within a given file. The condition is ignored.
Uses C<find_sub> to locate the desired subroutine.

=cut

sub subroutine_filename_lines {
    my ($subname, $cond) = @@_;

    # Returned value from find_sub() is fullpathname:startline-endline.
    # The match creates the list (fullpathname, start, end). Falling off
    # the end of the subroutine returns this implicitly.
    find_sub($subname) =~ /^(.*):(\d+)-(\d+)$/;
} ## end sub subroutine_filename_lines

=head3 break_subroutine(subname) (API)

Places a break on the first line possible in the specified subroutine. Uses
C<subroutine_filename_lines> to find the subroutine, and 
C<break_on_filename_line_range> to place the break.

=cut

sub break_subroutine {
    my $subname = shift;

    # Get filename, start, and end.
    my ($file, $s, $e) = subroutine_filename_lines($subname)
      or die "Subroutine $subname not found.\n";

    # Null condition changes to '1' (always true).
    $cond = 1 unless @@_ >= 2;

    # Put a break the first place possible in the range of lines
    # that make up this subroutine.
    break_on_filename_line_range($file, $s, $e, @@_);
} ## end sub break_subroutine

=head3 cmd_b_sub(subname, [condition]) (command)

We take the incoming subroutine name and fully-qualify it as best we can.

=over 4

=item 1. If it's already fully-qualified, leave it alone. 

=item 2. Try putting it in the current package.

=item 3. If it's not there, try putting it in CORE::GLOBAL if it exists there.

=item 4. If it starts with '::', put it in 'main::'.

=back

After all this cleanup, we call C<break_subroutine> to try to set the 
breakpoint.

=cut

sub cmd_b_sub {
    my ($subname, $cond) = @@_;

    # Add always-true condition if we have none.
    $cond = 1 unless @@_ >= 2;

    # If the subname isn't a code reference, qualify it so that 
    # break_subroutine() will work right.
    unless (ref $subname eq 'CODE') {
        # Not Perl4.
        $subname =~ s/\'/::/g;
        my $s = $subname;

        # Put it in this package unless it's already qualified.
        $subname = "${'package'}::" . $subname
          unless $subname =~ /::/;

        # Requalify it into CORE::GLOBAL if qualifying it into this
        # package resulted in its not being defined, but only do so
        # if it really is in CORE::GLOBAL.
        $subname = "CORE::GLOBAL::$s"
          if not defined &$subname
          and $s !~ /::/
          and defined &{"CORE::GLOBAL::$s"};

        # Put it in package 'main' if it has a leading ::.
        $subname = "main" . $subname if substr($subname, 0, 2) eq "::";

    } ## end unless (ref $subname eq 'CODE')

    # Try to set the breakpoint.
    eval { break_subroutine($subname, $cond); 1 } or do {
        local $\ = '';
        print $OUT $@@ and return;
      }
} ## end sub cmd_b_sub

=head3 C<cmd_B> - delete breakpoint(s) (command)

The command mostly parses the command line and tries to turn the argument
into a line spec. If it can't, it uses the current line. It then calls
C<delete_breakpoint> to actually do the work.

If C<*> is  specified, C<cmd_B> calls C<delete_breakpoint> with no arguments,
thereby deleting all the breakpoints.

=cut

sub cmd_B {
    my $cmd  = shift;

    # No line spec? Use dbline. 
    # If there is one, use it if it's non-zero, or wipe it out if it is.
    my $line = ($_[0] =~ /^\./) ? $dbline : shift || '';
    my $dbline = shift;

    # If the line was dot, make the line the current one.
    $line =~ s/^\./$dbline/;

    # If it's * we're deleting all the breakpoints.
    if ($line eq '*') {
        eval { &delete_breakpoint(); 1 } or print $OUT $@@ and return;
    }

    # If there is a line spec, delete the breakpoint on that line.
    elsif ($line =~ /^(\S.*)/) {
        eval { &delete_breakpoint($line || $dbline); 1 } or do {
            local $\ = '';
            print $OUT $@@ and return;
        };
    } ## end elsif ($line =~ /^(\S.*)/)

    # No line spec. 
    else {
        print $OUT
          "Deleting a breakpoint requires a line number, or '*' for all\n"
          ;    # hint
    }
} ## end sub cmd_B

=head3 delete_breakpoint([line]) (API)

This actually does the work of deleting either a single breakpoint, or all
of them.

For a single line, we look for it in C<@@dbline>. If it's nonbreakable, we
just drop out with a message saying so. If it is, we remove the condition
part of the 'condition\0action' that says there's a breakpoint here. If,
after we've done that, there's nothing left, we delete the corresponding
line in C<%dbline> to signal that no action needs to be taken for this line.

For all breakpoints, we iterate through the keys of C<%had_breakpoints>, 
which lists all currently-loaded files which have breakpoints. We then look
at each line in each of these files, temporarily switching the C<%dbline>
and C<@@dbline> structures to point to the files in question, and do what
we did in the single line case: delete the condition in C<@@dbline>, and
delete the key in C<%dbline> if nothing's left.

We then wholesale delete C<%postponed>, C<%postponed_file>, and 
C<%break_on_load>, because these structures contain breakpoints for files
and code that haven't been loaded yet. We can just kill these off because there
are no magical debugger structures associated with them.

=cut

sub delete_breakpoint {
    my $i = shift;

    # If we got a line, delete just that one.
    if (defined($i)) {

        # Woops. This line wasn't breakable at all.
        die "Line $i not breakable.\n" if $dbline[$i] == 0;

        # Kill the condition, but leave any action.
        $dbline{$i} =~ s/^[^\0]*//;

        # Remove the entry entirely if there's no action left.
        delete $dbline{$i} if $dbline{$i} eq '';
    }

    # No line; delete them all.
    else {
        print $OUT "Deleting all breakpoints...\n";

        # %had_breakpoints lists every file that had at least one
        # breakpoint in it.
        for my $file (keys %had_breakpoints) {
            # Switch to the desired file temporarily.
            local *dbline = $main::{ '_<' . $file };

            my $max = $#dbline;
            my $was;

            # For all lines in this file ...
            for ($i = 1 ; $i <= $max ; $i++) {
                # If there's a breakpoint or action on this line ...
                if (defined $dbline{$i}) {
                    # ... remove the breakpoint.
                    $dbline{$i} =~ s/^[^\0]+//;
                    if ($dbline{$i} =~ s/^\0?$//) {
                        # Remove the entry altogether if no action is there.
                        delete $dbline{$i};
                    }
                } ## end if (defined $dbline{$i...
            } ## end for ($i = 1 ; $i <= $max...

            # If, after we turn off the "there were breakpoints in this file"
            # bit, the entry in %had_breakpoints for this file is zero, 
            # we should remove this file from the hash.
            if (not $had_breakpoints{$file} &= ~1) {
                delete $had_breakpoints{$file};
            }
        } ## end for my $file (keys %had_breakpoints)

        # Kill off all the other breakpoints that are waiting for files that
        # haven't been loaded yet.
        undef %postponed;
        undef %postponed_file;
        undef %break_on_load;
    } ## end else [ if (defined($i))
} ## end sub delete_breakpoint

=head3 cmd_stop (command)

This is meant to be part of the new command API, but it isn't called or used
anywhere else in the debugger. XXX It is probably meant for use in development
of new commands.

=cut

sub cmd_stop {    # As on ^C, but not signal-safy.
    $signal = 1;
}

=head3 C<cmd_h> - help command (command)

Does the work of either

=over 4

=item * Showing all the debugger help

=item * Showing help for a specific command

=back

=cut

sub cmd_h {
    my $cmd  = shift;

    # If we have no operand, assume null.
    my $line = shift || '';

    # 'h h'. Print the long-format help.
    if ($line =~ /^h\s*/) {
        print_help($help);
    }

    # 'h <something>'. Search for the command and print only its help.
    elsif ($line =~ /^(\S.*)$/) {

        # support long commands; otherwise bogus errors
        # happen when you ask for h on <CR> for example
        my $asked  = $1;                   # the command requested
                                           # (for proper error message)

        my $qasked = quotemeta($asked);    # for searching; we don't
                                           # want to use it as a pattern.
                                           # XXX: finds CR but not <CR>

        # Search the help string for the command.
        if ($help =~ /^                    # Start of a line
                      <?                   # Optional '<'
                      (?:[IB]<)            # Optional markup
                      $qasked              # The requested command
                     /mx) {
            # It's there; pull it out and print it.
            while ($help =~ /^
                              (<?            # Optional '<'
                                 (?:[IB]<)   # Optional markup
                                 $qasked     # The command
                                 ([\s\S]*?)  # Description line(s)
                              \n)            # End of last description line
                              (?!\s)         # Next line not starting with 
                                             # whitespace
                             /mgx) {
                print_help($1);
            }
        }

        # Not found; not a debugger command.
        else {
            print_help("B<$asked> is not a debugger command.\n");
        }
    } ## end elsif ($line =~ /^(\S.*)$/)

    # 'h' - print the summary help.
    else {
        print_help($summary);
    }
} ## end sub cmd_h

=head3 C<cmd_l> - list lines (command)

Most of the command is taken up with transforming all the different line
specification syntaxes into 'start-stop'. After that is done, the command
runs a loop over C<@@dbline> for the specified range of lines. It handles 
the printing of each line and any markers (C<==E<gt>> for current line,
C<b> for break on this line, C<a> for action on this line, C<:> for this
line breakable). 

We save the last line listed in the C<$start> global for further listing
later.

=cut

sub cmd_l {
    my $current_line  = $line;

    my $cmd           = shift;
    my $line          = shift;

    # If this is '-something', delete any spaces after the dash.
    $line =~ s/^-\s*$/-/;

    # If the line is '$something', assume this is a scalar containing a 
    # line number.
    if ($line =~ /^(\$.*)/s) {

        # Set up for DB::eval() - evaluate in *user* context.
        $evalarg = $1;
        my ($s) = &eval;

        # Ooops. Bad scalar.
        print($OUT "Error: $@@\n"), next CMD if $@@;

        # Good scalar. If it's a reference, find what it points to.
        $s = CvGV_name($s);
        print($OUT "Interpreted as: $1 $s\n");
        $line = "$1 $s";

        # Call self recursively to really do the command.
        &cmd_l('l', $s);
    } ## end if ($line =~ /^(\$.*)/s)

    # l name. Try to find a sub by that name. 
    elsif ($line =~ /^([\':A-Za-z_][\':\w]*(\[.*\])?)/s) {
        my $s = $subname = $1;

        # De-Perl4.
        $subname =~ s/\'/::/;

        # Put it in this package unless it starts with ::.
        $subname = $package . "::" . $subname unless $subname =~ /::/;

        # Put it in CORE::GLOBAL if t doesn't start with :: and
        # it doesn't live in this package and it lives in CORE::GLOBAL.
        $subname = "CORE::GLOBAL::$s"
          if not defined &$subname
          and $s !~ /::/
          and defined &{"CORE::GLOBAL::$s"};

        # Put leading '::' names into 'main::'.
        $subname = "main" . $subname if substr($subname, 0, 2) eq "::";

        # Get name:start-stop from find_sub, and break this up at 
        # colons.
        @@pieces = split (/:/, find_sub($subname) || $sub{$subname});

        # Pull off start-stop.
        $subrange = pop @@pieces;

        # If the name contained colons, the split broke it up.
        # Put it back together.
        $file     = join (':', @@pieces);

        # If we're not in that file, switch over to it.
        if ($file ne $filename) {
            print $OUT "Switching to file '$file'.\n"
              unless $slave_editor;

            # Switch debugger's magic structures.
            *dbline   = $main::{ '_<' . $file };
            $max      = $#dbline;
            $filename = $file;
        } ## end if ($file ne $filename)

        # Subrange is 'start-stop'. If this is less than a window full,
        # swap it to 'start+', which will list a window from the start point.
        if ($subrange) {
            if (eval($subrange) < -$window) {
                $subrange =~ s/-.*/+/;
            }
            # Call self recursively to list the range.
            $line = $subrange;
            &cmd_l('l', $subrange);
        } ## end if ($subrange)

        # Couldn't find it.
        else {
            print $OUT "Subroutine $subname not found.\n";
        }
    } ## end elsif ($line =~ /^([\':A-Za-z_][\':\w]*(\[.*\])?)/s)

    # Bare 'l' command.
    elsif ($line =~ /^\s*$/) {
        # Compute new range to list.
        $incr = $window - 1;
        $line = $start . '-' . ($start + $incr);
        # Recurse to do it.
        &cmd_l('l', $line);
    }

    # l [start]+number_of_lines
    elsif ($line =~ /^(\d*)\+(\d*)$/) {
        # Don't reset start for 'l +nnn'.
        $start = $1 if $1;

        # Increment for list. Use window size if not specified.
        # (Allows 'l +' to work.)
        $incr = $2;
        $incr = $window - 1 unless $incr;

        # Create a line range we'll understand, and recurse to do it.
        $line = $start . '-' . ($start + $incr);
        &cmd_l('l', $line);
    } ## end elsif ($line =~ /^(\d*)\+(\d*)$/)

    # l start-stop or l start,stop
    elsif ($line =~ /^((-?[\d\$\.]+)([-,]([\d\$\.]+))?)?/) {

        # Determine end point; use end of file if not specified.
        $end = (!defined $2) ? $max : ($4 ? $4 : $2);

        # Go on to the end, and then stop.
        $end = $max if $end > $max;

        # Determine start line.  
        $i = $2;
        $i = $line if $i eq '.';
        $i = 1 if $i < 1;
        $incr = $end - $i;

        # If we're running under a slave editor, force it to show the lines.
        if ($slave_editor) {
            print $OUT "\032\032$filename:$i:0\n";
            $i = $end;
        }

        # We're doing it ourselves. We want to show the line and special
        # markers for:
        # - the current line in execution 
        # - whether a line is breakable or not
        # - whether a line has a break or not
        # - whether a line has an action or not
        else {
            for (; $i <= $end ; $i++) {
                # Check for breakpoints and actions.
                my ($stop, $action);
                ($stop, $action) = split (/\0/, $dbline{$i})
                  if $dbline{$i};

                # ==> if this is the current line in execution,
                # : if it's breakable.
                $arrow =
                  ($i == $current_line and $filename eq $filename_ini)
                  ? '==>'
                  : ($dbline[$i] + 0 ? ':' : ' ');

                # Add break and action indicators.
                $arrow .= 'b' if $stop;
                $arrow .= 'a' if $action;

                # Print the line.
                print $OUT "$i$arrow\t", $dbline[$i];

                # Move on to the next line. Drop out on an interrupt.
                $i++, last if $signal;
            } ## end for (; $i <= $end ; $i++)

            # Line the prompt up; print a newline if the last line listed
            # didn't have a newline.
            print $OUT "\n" unless $dbline[$i - 1] =~ /\n$/;
        } ## end else [ if ($slave_editor)

        # Save the point we last listed to in case another relative 'l'
        # command is desired. Don't let it run off the end.
        $start = $i;
        $start = $max if $start > $max;
    } ## end elsif ($line =~ /^((-?[\d\$\.]+)([-,]([\d\$\.]+))?)?/)
} ## end sub cmd_l

=head3 C<cmd_L> - list breakpoints, actions, and watch expressions (command)

To list breakpoints, the command has to look determine where all of them are
first. It starts a C<%had_breakpoints>, which tells us what all files have
breakpoints and/or actions. For each file, we switch the C<*dbline> glob (the 
magic source and breakpoint data structures) to the file, and then look 
through C<%dbline> for lines with breakpoints and/or actions, listing them 
out. We look through C<%postponed> not-yet-compiled subroutines that have 
breakpoints, and through C<%postponed_file> for not-yet-C<require>'d files 
that have breakpoints.

Watchpoints are simpler: we just list the entries in C<@@to_watch>.

=cut

sub cmd_L {
    my $cmd = shift;

    # If no argument, list everything. Pre-5.8.0 version always lists 
    # everything
    my $arg = shift || 'abw';
    $arg = 'abw' unless $CommandSet eq '580';    # sigh...

    # See what is wanted.
    my $action_wanted = ($arg =~ /a/) ? 1 : 0;
    my $break_wanted  = ($arg =~ /b/) ? 1 : 0;
    my $watch_wanted  = ($arg =~ /w/) ? 1 : 0;

    # Breaks and actions are found together, so we look in the same place
    # for both.
    if ($break_wanted or $action_wanted) {
        # Look in all the files with breakpoints...
        for my $file (keys %had_breakpoints) {
            # Temporary switch to this file.
            local *dbline = $main::{ '_<' . $file };

            # Set up to look through the whole file.
            my $max = $#dbline;
            my $was;                         # Flag: did we print something
                                             # in this file?

            # For each line in the file ...
            for ($i = 1 ; $i <= $max ; $i++) {
                # We've got something on this line.
                if (defined $dbline{$i}) {
                    # Print the header if we haven't.
                    print $OUT "$file:\n" unless $was++;

                    # Print the line.
                    print $OUT " $i:\t", $dbline[$i];

                    # Pull out the condition and the action.
                    ($stop, $action) = split (/\0/, $dbline{$i});

                    # Print the break if there is one and it's wanted.
                    print $OUT "   break if (", $stop, ")\n"
                      if $stop
                      and $break_wanted;

                    # Print the action if there is one and it's wanted.
                    print $OUT "   action:  ", $action, "\n"
                      if $action
                      and $action_wanted;

                    # Quit if the user hit interrupt.
                    last if $signal;
                } ## end if (defined $dbline{$i...
            } ## end for ($i = 1 ; $i <= $max...
        } ## end for my $file (keys %had_breakpoints)
    } ## end if ($break_wanted or $action_wanted)

    # Look for breaks in not-yet-compiled subs:
    if (%postponed and $break_wanted) {
        print $OUT "Postponed breakpoints in subroutines:\n";
        my $subname;
        for $subname (keys %postponed) {
            print $OUT " $subname\t$postponed{$subname}\n";
            last if $signal;
        }
    } ## end if (%postponed and $break_wanted)

    # Find files that have not-yet-loaded breaks:
    my @@have = map {    # Combined keys
        keys %{ $postponed_file{$_} }
    } keys %postponed_file;

    # If there are any, list them.
    if (@@have and ($break_wanted or $action_wanted)) {
        print $OUT "Postponed breakpoints in files:\n";
        my ($file, $line);

        for $file (keys %postponed_file) {
            my $db = $postponed_file{$file};
            print $OUT " $file:\n";
            for $line (sort { $a <=> $b } keys %$db) {
                print $OUT "  $line:\n";
                my ($stop, $action) = split (/\0/, $$db{$line});
                print $OUT "    break if (", $stop, ")\n"
                  if $stop
                  and $break_wanted;
                print $OUT "    action:  ", $action, "\n"
                  if $action
                  and $action_wanted;
                last if $signal;
            } ## end for $line (sort { $a <=>...
            last if $signal;
        } ## end for $file (keys %postponed_file)
    } ## end if (@@have and ($break_wanted...
    if (%break_on_load and $break_wanted) {
        print $OUT "Breakpoints on load:\n";
        my $file;
        for $file (keys %break_on_load) {
            print $OUT " $file\n";
            last if $signal;
        }
    } ## end if (%break_on_load and...
    if ($watch_wanted) {
        if ($trace & 2) {
            print $OUT "Watch-expressions:\n" if @@to_watch;
            for my $expr (@@to_watch) {
                print $OUT " $expr\n";
                last if $signal;
            }
        } ## end if ($trace & 2)
    } ## end if ($watch_wanted)
} ## end sub cmd_L

=head3 C<cmd_M> - list modules (command)

Just call C<list_modules>.

=cut

sub cmd_M {
    &list_modules();
}

=head3 C<cmd_o> - options (command)

If this is just C<o> by itself, we list the current settings via 
C<dump_option>. If there's a nonblank value following it, we pass that on to
C<parse_options> for processing.

=cut

sub cmd_o {
    my $cmd = shift;
    my $opt = shift || '';    # opt[=val]

    # Nonblank. Try to parse and process.
    if ($opt =~ /^(\S.*)/) {
        &parse_options($1);
    }

    # Blank. List the current option settings.
    else {
        for (@@options) {
            &dump_option($_);
        }
    }
} ## end sub cmd_o

=head3 C<cmd_O> - nonexistent in 5.8.x (command)

Advises the user that the O command has been renamed.

=cut

sub cmd_O {
    print $OUT "The old O command is now the o command.\n";             # hint
    print $OUT "Use 'h' to get current command help synopsis or\n";     #
    print $OUT "use 'o CommandSet=pre580' to revert to old usage\n";    #
a1964 141
=head3 C<cmd_v> - view window (command)

Uses the C<$preview> variable set in the second C<BEGIN> block (q.v.) to
move back a few lines to list the selected line in context. Uses C<cmd_l>
to do the actual listing after figuring out the range of line to request.

=cut 

sub cmd_v {
    my $cmd  = shift;
    my $line = shift;

    # Extract the line to list around. (Astute readers will have noted that
    # this pattern will match whether or not a numeric line is specified,
    # which means that we'll always enter this loop (though a non-numeric
    # argument results in no action at all)).
    if ($line =~ /^(\d*)$/) {
        # Total number of lines to list (a windowful).
        $incr = $window - 1;

        # Set the start to the argument given (if there was one).
       $start = $1 if $1;

        # Back up by the context amount.
        $start -= $preview;

        # Put together a linespec that cmd_l will like.
        $line = $start . '-' . ($start + $incr);

        # List the lines.
        &cmd_l('l', $line);
    } ## end if ($line =~ /^(\d*)$/)
} ## end sub cmd_v

=head3 C<cmd_w> - add a watch expression (command)

The 5.8 version of this command adds a watch expression if one is specified;
it does nothing if entered with no operands.

We extract the expression, save it, evaluate it in the user's context, and
save the value. We'll re-evaluate it each time the debugger passes a line,
and will stop (see the code at the top of the command loop) if the value
of any of the expressions changes.

=cut

sub cmd_w {
    my $cmd  = shift;

    # Null expression if no arguments.
    my $expr = shift || '';

    # If expression is not null ...
    if ($expr =~ /^(\S.*)/) {
        # ... save it.
        push @@to_watch, $expr;

        # Parameterize DB::eval and call it to get the expression's value
        # in the user's context. This version can handle expressions which
        # return a list value.
        $evalarg = $expr;
        my ($val) = join(' ', &eval);
        $val = (defined $val) ? "'$val'" : 'undef';

        # Save the current value of the expression.
        push @@old_watch, $val;

        # We are now watching expressions.
        $trace |= 2;
    } ## end if ($expr =~ /^(\S.*)/)

    # You have to give one to get one.
    else {
        print $OUT
          "Adding a watch-expression requires an expression\n";    # hint
    }
} ## end sub cmd_w

=head3 C<cmd_W> - delete watch expressions (command)

This command accepts either a watch expression to be removed from the list
of watch expressions, or C<*> to delete them all.

If C<*> is specified, we simply empty the watch expression list and the 
watch expression value list. We also turn off the bit that says we've got 
watch expressions.

If an expression (or partial expression) is specified, we pattern-match
through the expressions and remove the ones that match. We also discard
the corresponding values. If no watch expressions are left, we turn off 
the 'watching expressions' bit.

=cut

sub cmd_W {
    my $cmd  = shift;
    my $expr = shift || '';

    # Delete them all.
    if ($expr eq '*') {
        # Not watching now.
        $trace &= ~2;

        print $OUT "Deleting all watch expressions ...\n";

        # And all gone.
        @@to_watch = @@old_watch = ();
    }

    # Delete one of them.
    elsif ($expr =~ /^(\S.*)/) {
        # Where we are in the list.
        my $i_cnt = 0;

        # For each expression ...
        foreach (@@to_watch) {
            my $val = $to_watch[$i_cnt];

            # Does this one match the command argument?
            if ($val eq $expr) {    # =~ m/^\Q$i$/) {
                # Yes. Turn it off, and its value too.
                splice(@@to_watch, $i_cnt, 1);
                splice(@@old_watch, $i_cnt, 1);
            }
            $i_cnt++;
        } ## end foreach (@@to_watch)

        # We don't bother to turn watching off because
        #  a) we don't want to stop calling watchfunction() it it exists
        #  b) foreach over a null list doesn't do anything anyway

    } ## end elsif ($expr =~ /^(\S.*)/)

    # No command arguments entered.
    else {
        print $OUT
"Deleting a watch-expression requires an expression, or '*' for all\n"
          ;                         # hint
    }
} ## end sub cmd_W

a1966 12
=head1 SUPPORT ROUTINES

These are general support routines that are used in a number of places
throughout the debugger.

=head2 save

save() saves the user's versions of globals that would mess us up in C<@@saved>,
and installs the versions we like better. 

=cut

a1967 3
    # Save eval failure, command failure, extended OS error, output field 
    # separator, input record separator, output record separator and 
    # the warning setting.
d1969 2
a1970 15

    $,     = "";             # output field separator is null string
    $/     = "\n";           # input record separator is newline
    $\     = "";             # output record separator is null string
    $^W    = 0;              # warnings are off
} ## end sub save

=head2 C<print_lineinfo> - show where we are now

print_lineinfo prints whatever it is that it is handed; it prints it to the
C<$LINEINFO> filehandle instead of just printing it to STDOUT. This allows
us to feed line information to a slave editor without messing up the 
debugger output.

=cut
d1973 5
a1977 17
    # Make the terminal sensible if we're not the primary debugger.
    resetterm(1) if $LINEINFO eq $OUT and $term_pid != $$;
    local $\ = '';
    local $, = '';
    print $LINEINFO @@_;
} ## end sub print_lineinfo

=head2 C<postponed_sub>

Handles setting postponed breakpoints in subroutines once they're compiled.
For breakpoints, we use C<DB::find_sub> to locate the source file and line
range for the subroutine, then mark the file as having a breakpoint,
temporarily switch the C<*dbline> glob over to the source file, and then 
search the given range of lines to find a breakable line. If we find one,
we set the breakpoint on it, deleting the breakpoint from C<%postponed>.

=cut 
d1982 22
a2003 61
    # Get the subroutine name.
    my $subname = shift;

    # If this is a 'break +<n> if <condition>' ...
    if ($postponed{$subname} =~ s/^break\s([+-]?\d+)\s+if\s//) {
        # If there's no offset, use '+0'.
        my $offset = $1 || 0;

        # find_sub's value is 'fullpath-filename:start-stop'. It's
        # possible that the filename might have colons in it too.
        my ($file, $i) = (find_sub($subname) =~ /^(.*):(\d+)-.*$/);
        if ($i) {
            # We got the start line. Add the offset '+<n>' from 
            # $postponed{subname}.
            $i += $offset;

            # Switch to the file this sub is in, temporarily.
            local *dbline = $main::{ '_<' . $file };

            # No warnings, please.
            local $^W     = 0;                         # != 0 is magical below

            # This file's got a breakpoint in it.
            $had_breakpoints{$file} |= 1;

            # Last line in file.
            my $max = $#dbline;

            # Search forward until we hit a breakable line or get to
            # the end of the file.
            ++$i until $dbline[$i] != 0 or $i >= $max;

            # Copy the breakpoint in and delete it from %postponed.
            $dbline{$i} = delete $postponed{$subname};
        } ## end if ($i)

        # find_sub didn't find the sub.
        else {
            local $\ = '';
            print $OUT "Subroutine $subname not found.\n";
        }
        return;
    } ## end if ($postponed{$subname...
    elsif ($postponed{$subname} eq 'compile') { $signal = 1 }

    #print $OUT "In postponed_sub for `$subname'.\n";
} ## end sub postponed_sub

=head2 C<postponed>

Called after each required file is compiled, but before it is executed;
also called if the name of a just-compiled subroutine is a key of 
C<%postponed>. Propagates saved breakpoints (from C<b compile>, C<b load>,
etc.) into the just-compiled code.

If this is a C<require>'d file, the incoming parameter is the glob 
C<*{"_<$filename"}>, with C<$filename> the name of the C<require>'d file.

If it's a subroutine, the incoming parameter is the subroutine name.

=cut
d2006 23
a2028 84
    # If there's a break, process it.
    if ($ImmediateStop) {
        # Right, we've stopped. Turn it off.
        $ImmediateStop = 0;

        # Enter the command loop when DB::DB gets called.
        $signal        = 1;
    }

    # If this is a subroutine, let postponed_sub() deal with it.
    return &postponed_sub unless ref \$_[0] eq 'GLOB';

    # Not a subroutine. Deal with the file.
    local *dbline = shift;
    my $filename = $dbline;
    $filename =~ s/^_<//;
    local $\ = '';
    $signal = 1, print $OUT "'$filename' loaded...\n"
      if $break_on_load{$filename};
    print_lineinfo(' ' x $stack_depth, "Package $filename.\n") if $frame;

    # Do we have any breakpoints to put in this file?
    return unless $postponed_file{$filename};

    # Yes. Mark this file as having breakpoints.
    $had_breakpoints{$filename} |= 1;

    # "Cannot be done: unsufficient magic" - we can't just put the
    # breakpoints saved in %postponed_file into %dbline by assigning
    # the whole hash; we have to do it one item at a time for the
    # breakpoints to be set properly.
    #%dbline = %{$postponed_file{$filename}}; 

    # Set the breakpoints, one at a time.
    my $key;

    for $key (keys %{ $postponed_file{$filename} }) {
        # Stash the saved breakpoint into the current file's magic line array.
        $dbline{$key} = ${ $postponed_file{$filename} }{$key};
    }

    # This file's been compiled; discard the stored breakpoints.
    delete $postponed_file{$filename};

} ## end sub postponed

=head2 C<dumpit>

C<dumpit> is the debugger's wrapper around dumpvar.pl. 

It gets a filehandle (to which C<dumpvar.pl>'s output will be directed) and
a reference to a variable (the thing to be dumped) as its input. 

The incoming filehandle is selected for output (C<dumpvar.pl> is printing to
the currently-selected filehandle, thank you very much). The current
values of the package globals C<$single> and C<$trace> are backed up in 
lexicals, and they are turned off (this keeps the debugger from trying
to single-step through C<dumpvar.pl> (I think.)). C<$frame> is localized to
preserve its current value and it is set to zero to prevent entry/exit
messages from printing, and C<$doret> is localized as well and set to -2 to 
prevent return values from being shown.

C<dumpit()> then checks to see if it needs to load C<dumpvar.pl> and 
tries to load it (note: if you have a C<dumpvar.pl>  ahead of the 
installed version in @@INC, yours will be used instead. Possible security 
problem?).

It then checks to see if the subroutine C<main::dumpValue> is now defined
(it should have been defined by C<dumpvar.pl>). If it has, C<dumpit()> 
localizes the globals necessary for things to be sane when C<main::dumpValue()>
is called, and picks up the variable to be dumped from the parameter list. 

It checks the package global C<%options> to see if there's a C<dumpDepth> 
specified. If not, -1 is assumed; if so, the supplied value gets passed on to 
C<dumpvar.pl>. This tells C<dumpvar.pl> where to leave off when dumping a 
structure: -1 means dump everything.

C<dumpValue()> is then called if possible; if not, C<dumpit()>just prints a 
warning.

In either case, C<$single>, C<$trace>, C<$frame>, and C<$doret> are restored
and we then return to the caller.

=cut
a2030 2
    # Save the current output filehandle and switch to the one
    # passed in as the first parameter.
a2031 2

    # Save current settings of $single and $trace, and then turn them off.
d2033 1
a2033 1
    my $otrace  = $trace;
a2034 2

    # XXX Okay, what do $frame and $doret do, again?
a2036 2

    # Load dumpvar.pl unless we've already got the sub we need from it.
d2038 1
a2038 1
        do 'dumpvar.pl';
a2039 3

    # If the load succeeded (or we already had dumpvalue()), go ahead
    # and dump things.
d2046 3
a2048 6
        $maxdepth = -1 unless defined $maxdepth;    # -1 means infinite depth
        &main::dumpValue($v, $maxdepth);
    } ## end if (defined &main::dumpValue)

    # Oops, couldn't load dumpvar.pl.
    else {
d2050 1
a2050 1
        print $OUT "dumpvar.pl not available.\n";
a2051 2

    # Reset $single and $trace to their old values.
d2053 3
a2055 31
    $trace  = $otrace;

    # Restore the old filehandle.
    select($savout);
} ## end sub dumpit

=head2 C<print_trace>

C<print_trace>'s job is to print a stack trace. It does this via the 
C<dump_trace> routine, which actually does all the ferreting-out of the
stack trace data. C<print_trace> takes care of formatting it nicely and
printing it to the proper filehandle.

Parameters:

=over 4

=item * The filehandle to print to.

=item * How many frames to skip before starting trace.

=item * How many frames to print.

=item * A flag: if true, print a "short" trace without filenames, line numbers, or arguments

=back

The original comment below seems to be noting that the traceback may not be
correct if this routine is called in a tied method.

=cut
d2060 28
a2087 88
    local $\ = '';
    my $fh = shift;
    # If this is going to a slave editor, but we're not the primary
    # debugger, reset it first.
    resetterm(1)
      if $fh eq $LINEINFO          # slave editor
      and $LINEINFO eq $OUT        # normal output
      and $term_pid != $$;         # not the primary

    # Collect the actual trace information to be formatted.
    # This is an array of hashes of subroutine call info.
    my @@sub = dump_trace($_[0] + 1, $_[1]);

    # Grab the "short report" flag from @@_.
    my $short = $_[2];    # Print short report, next one for sub name

    # Run through the traceback info, format it, and print it.
    my $s;
    for ($i = 0 ; $i <= $#sub ; $i++) {
        # Drop out if the user has lost interest and hit control-C.
        last if $signal;

        # Set the separator so arrys print nice. 
        local $" = ', ';

        # Grab and stringify the arguments if they are there.
        my $args =
          defined $sub[$i]{args}
          ? "(@@{ $sub[$i]{args} })"
          : '';
        # Shorten them up if $maxtrace says they're too long.
        $args = (substr $args, 0, $maxtrace - 3) . '...'
          if length $args > $maxtrace;

        # Get the file name.
        my $file = $sub[$i]{file};

        # Put in a filename header if short is off.
        $file = $file eq '-e' ? $file : "file `$file'" unless $short;

        # Get the actual sub's name, and shorten to $maxtrace's requirement.
        $s = $sub[$i]{sub};
        $s = (substr $s, 0, $maxtrace - 3) . '...' if length $s > $maxtrace;

        # Short report uses trimmed file and sub names.
        if ($short) {
            my $sub = @@_ >= 4 ? $_[3] : $s;
            print $fh
              "$sub[$i]{context}=$sub$args from $file:$sub[$i]{line}\n";
        } ## end if ($short)

        # Non-short report includes full names.
        else {
            print $fh "$sub[$i]{context} = $s$args" . " called from $file" .
              " line $sub[$i]{line}\n";
        }
    } ## end for ($i = 0 ; $i <= $#sub...
} ## end sub print_trace

=head2 dump_trace(skip[,count])

Actually collect the traceback information available via C<caller()>. It does
some filtering and cleanup of the data, but mostly it just collects it to
make C<print_trace()>'s job easier.

C<skip> defines the number of stack frames to be skipped, working backwards
from the most current. C<count> determines the total number of frames to 
be returned; all of them (well, the first 10^9) are returned if C<count>
is omitted.

This routine returns a list of hashes, from most-recent to least-recent
stack frame. Each has the following keys and values:

=over 4

=item * C<context> - C<.> (null), C<$> (scalar), or C<@@> (array)

=item * C<sub> - subroutine name, or C<eval> information

=item * C<args> - undef, or a reference to an array of arguments

=item * C<file> - the file in which this item was defined (if any)

=item * C<line> - the line on which it was defined

=back

=cut
d2090 49
a2138 139

    # How many levels to skip.
    my $skip = shift;

    # How many levels to show. (1e9 is a cheap way of saying "all of them";
    # it's unlikely that we'll have more than a billion stack frames. If you
    # do, you've got an awfully big machine...)
    my $count = shift || 1e9;

    # We increment skip because caller(1) is the first level *back* from
    # the current one.  Add $skip to the count of frames so we have a 
    # simple stop criterion, counting from $skip to $count+$skip.
    $skip++;
    $count += $skip;

    # These variables are used to capture output from caller();
    my ($p, $file, $line, $sub, $h, $context);

    my ($e, $r, @@a, @@sub, $args);

    # XXX Okay... why'd we do that?
    my $nothard = not $frame & 8;
    local $frame = 0;    

    # Do not want to trace this.
    my $otrace = $trace;
    $trace = 0;

    # Start out at the skip count.
    # If we haven't reached the number of frames requested, and caller() is
    # still returning something, stay in the loop. (If we pass the requested
    # number of stack frames, or we run out - caller() returns nothing - we
    # quit.
    # Up the stack frame index to go back one more level each time.
    for (
        $i = $skip ;
        $i < $count
        and ($p, $file, $line, $sub, $h, $context, $e, $r) = caller($i) ;
        $i++
      )
    {

        # Go through the arguments and save them for later.
        @@a = ();
        for $arg (@@args) {
            my $type;
            if (not defined $arg) {                    # undefined parameter
                push @@a, "undef";
            }

            elsif ($nothard and tied $arg) {           # tied parameter
                push @@a, "tied";
            }
            elsif ($nothard and $type = ref $arg) {    # reference
                push @@a, "ref($type)";
            }
            else {                                     # can be stringified
                local $_ =
                  "$arg";    # Safe to stringify now - should not call f().

                # Backslash any single-quotes or backslashes.
                s/([\'\\])/\\$1/g;

                # Single-quote it unless it's a number or a colon-separated
                # name.
                s/(.*)/'$1'/s
                  unless /^(?: -?[\d.]+ | \*[\w:]* )$/x;

                # Turn high-bit characters into meta-whatever.
                s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;

                # Turn control characters into ^-whatever.
                s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;

                push (@@a, $_);
            } ## end else [ if (not defined $arg)
        } ## end for $arg (@@args)

        # If context is true, this is array (@@)context.
        # If context is false, this is scalar ($) context.
        # If neither, context isn't defined. (This is apparently a 'can't 
        # happen' trap.)
        $context = $context ? '@@' : (defined $context ? "\$" : '.');

        # if the sub has args ($h true), make an anonymous array of the
        # dumped args.
        $args = $h ? [@@a] : undef;

        # remove trailing newline-whitespace-semicolon-end of line sequence
        # from the eval text, if any.
        $e =~ s/\n\s*\;\s*\Z//  if $e;

        # Escape backslashed single-quotes again if necessary.
        $e =~ s/([\\\'])/\\$1/g if $e;

        # if the require flag is true, the eval text is from a require.
        if ($r) {
            $sub = "require '$e'";
        }
        # if it's false, the eval text is really from an eval.
        elsif (defined $r) {
            $sub = "eval '$e'";
        }

        # If the sub is '(eval)', this is a block eval, meaning we don't
        # know what the eval'ed text actually was.
        elsif ($sub eq '(eval)') {
            $sub = "eval {...}";
        }

        # Stick the collected information into @@sub as an anonymous hash.
        push (
            @@sub,
            {
                context => $context,
                sub     => $sub,
                args    => $args,
                file    => $file,
                line    => $line
            }
            );

        # Stop processing frames if the user hit control-C.
        last if $signal;
    } ## end for ($i = $skip ; $i < ...

    # Restore the trace value again.
    $trace = $otrace;
    @@sub;
} ## end sub dump_trace

=head2 C<action()>

C<action()> takes input provided as the argument to an add-action command,
either pre- or post-, and makes sure it's a complete command. It doesn't do
any fancy parsing; it just keeps reading input until it gets a string
without a trailing backslash.

=cut
a2141 1

d2143 4
a2146 5
        # We have a backslash on the end. Read more.
        $action .= &gets;
    } ## end while ($action =~ s/\\$//)

    # Return the assembled action.
d2148 1
a2148 7
} ## end sub action

=head2 unbalanced

This routine mostly just packages up a regular expression to be used
to check that the thing it's being matched against has properly-matched
curly braces.
d2150 2
a2151 9
Of note is the definition of the $balanced_brace_re global via ||=, which
speeds things up by only creating the qr//'ed expression once; if it's 
already defined, we don't try to define it again. A speed hack.

=cut

sub unbalanced {

    # I hate using globals!
d2153 7
a2159 7
        ^ \{
             (?:
                 (?> [^{}] + )              # Non-parens without backtracking
                |
                 (??{ $balanced_brace_re }) # Group with matching parens
              ) *
          \} $
d2161 2
a2162 10
    return $_[0] !~ m/$balanced_brace_re/;
} ## end sub unbalanced

=head2 C<gets()>

C<gets()> is a primitive (very primitive) routine to read continuations.
It was devised for reading continuations for actions.
it just reads more input with X<C<readline()>> and returns it.

=cut
a2167 12
=head2 C<DB::system()> - handle calls to<system()> without messing up the debugger

The C<system()> function assumes that it can just go ahead and use STDIN and
STDOUT, but under the debugger, we want it to use the debugger's input and 
outout filehandles. 

C<DB::system()> socks away the program's STDIN and STDOUT, and then substitutes
the debugger's IN and OUT filehandles for them. It does the C<system()> call,
and then puts everything back again.

=cut

a2168 1

d2171 4
a2174 4
    open(SAVEIN,  "<&STDIN")  || &warn("Can't save STDIN");
    open(SAVEOUT, ">&STDOUT") || &warn("Can't save STDOUT");
    open(STDIN,   "<&IN")     || &warn("Can't redirect STDIN");
    open(STDOUT,  ">&OUT")    || &warn("Can't redirect STDOUT");
d2178 3
a2180 3
    open(STDIN,  "<&SAVEIN")  || &warn("Can't restore STDIN");
    open(STDOUT, ">&SAVEOUT") || &warn("Can't restore STDOUT");
    close(SAVEIN);
d2183 1
d2186 5
a2190 10
        &warn("(Command exited ", ($? >> 8), ")\n");
    }
    elsif ($?) {
        &warn(
            "(Command died of SIG#",
            ($? & 127),
            (($? & 128) ? " -- core dumped" : ""),
            ")", "\n"
            );
    } ## end elsif ($?)
d2194 1
a2194 21
} ## end sub system

=head1 TTY MANAGEMENT

The subs here do some of the terminal management for multiple debuggers.

=head2 setterm

Top-level function called when we want to set up a new terminal for use
by the debugger.

If the C<noTTY> debugger option was set, we'll either use the terminal
supplied (the value of the C<noTTY> option), or we'll use C<Term::Rendezvous>
to find one. If we're a forked debugger, we call C<resetterm> to try to 
get a whole new terminal if we can. 

In either case, we set up the terminal next. If the C<ReadLine> option was
true, we'll get a C<Term::ReadLine> object for the current terminal and save
the appropriate attributes. We then 

=cut
a2196 1
    # Load Term::Readline, but quietly; don't debug it and don't trace it.
a2199 2

    # If noTTY is set, but we have a TTY name, go ahead and hook up to it.
d2201 20
a2220 30
        if ($tty) {
            my ($i, $o) = split $tty, /,/;
            $o = $i unless defined $o;
            open(IN,  "<$i") or die "Cannot open TTY `$i' for read: $!";
            open(OUT, ">$o") or die "Cannot open TTY `$o' for write: $!";
            $IN  = \*IN;
            $OUT = \*OUT;
            my $sel = select($OUT);
            $| = 1;
            select($sel);
        } ## end if ($tty)

        # We don't have a TTY - try to find one via Term::Rendezvous.
        else {
            eval "require Term::Rendezvous;" or die;
            # See if we have anything to pass to Term::Rendezvous.
            # Use /tmp/perldbtty$$ if not.
            my $rv = $ENV{PERLDB_NOTTY} || "/tmp/perldbtty$$";

            # Rendezvous and get the filehandles.
            my $term_rv = new Term::Rendezvous $rv;
            $IN  = $term_rv->IN;
            $OUT = $term_rv->OUT;
        } ## end else [ if ($tty)
    } ## end if ($notty)


    # We're a daughter debugger. Try to fork off another TTY.
    if ($term_pid eq '-1') {    # In a TTY with another debugger
        resetterm(2);
a2221 2

    # If we shouldn't use Term::ReadLine, don't.
d2223 11
a2233 1
        $term = new Term::ReadLine::Stub 'perldb', $IN, $OUT;
d2235 1
a2235 16

    # We're using Term::ReadLine. Get all the attributes for this terminal.
    else {
        $term = new Term::ReadLine 'perldb', $IN, $OUT;

        $rl_attribs = $term->Attribs;
        $rl_attribs->{basic_word_break_characters} .= '-:+/*,[])}'
          if defined $rl_attribs->{basic_word_break_characters}
          and index($rl_attribs->{basic_word_break_characters}, ":") == -1;
        $rl_attribs->{special_prefixes} = '$@@&%';
        $rl_attribs->{completer_word_break_characters} .= '$@@&%';
        $rl_attribs->{completion_function} = \&db_complete;
    } ## end else [ if (!$rl)

    # Set up the LINEINFO filehandle.
    $LINEINFO = $OUT     unless defined $LINEINFO;
a2236 1

a2237 1

d2239 1
a2239 1
        $term->SetHistory(@@hist);
a2240 3

    # XXX Ornaments are turned on unconditionally, which is not
    # always a good thing.
d2243 1
a2243 36
} ## end sub setterm

=head1 GET_FORK_TTY EXAMPLE FUNCTIONS

When the process being debugged forks, or the process invokes a command
via C<system()> which starts a new debugger, we need to be able to get a new
C<IN> and C<OUT> filehandle for the new debugger. Otherwise, the two processes
fight over the terminal, and you can never quite be sure who's going to get the
input you're typing.

C<get_fork_TTY> is a glob-aliased function which calls the real function that 
is tasked with doing all the necessary operating system mojo to get a new 
TTY (and probably another window) and to direct the new debugger to read and
write there.

The debugger provides C<get_fork_TTY> functions which work for X Windows and
OS/2. Other systems are not supported. You are encouraged to write 
C<get_fork_TTY> functions which work for I<your> platform and contribute them.

=head3 C<xterm_get_fork_TTY>

This function provides the C<get_fork_TTY> function for X windows. If a 
program running under the debugger forks, a new <xterm> window is opened and
the subsidiary debugger is directed there.

The C<open()> call is of particular note here. We have the new C<xterm>
we're spawning route file number 3 to STDOUT, and then execute the C<tty> 
command (which prints the device name of the TTY we'll want to use for input 
and output to STDOUT, then C<sleep> for a very long time, routing this output
to file number 3. This way we can simply read from the <XT> filehandle (which
is STDOUT from the I<commands> we ran) to get the TTY we want to use. 

Only works if C<xterm> is in your path and C<$ENV{DISPLAY}>, etc. are 
properly set up.

=cut
d2245 1
d2247 2
a2248 3
    (my $name = $0) =~ s,^.*[/\\],,s;
    open XT,
qq[3>&1 xterm -title "Daughter Perl debugger $pids $name" -e sh -c 'tty 1>&3;\
d2250 5
a2254 16

    # Get the output from 'tty' and clean it up a little.
    my $tty = <XT>;
    chomp $tty;

    $pidprompt = '';    # Shown anyway in titlebar

    # There's our new TTY.
    return $tty;
} ## end sub xterm_get_fork_TTY

=head3 C<os2_get_fork_TTY>

XXX It behooves an OS/2 expert to write the necessary documentation for this!

=cut
d2258 19
a2276 28
    local $^F = 40;     # XXXX Fixme!
    local $\  = '';
    my ($in1, $out1, $in2, $out2);

    # Having -d in PERL5OPT would lead to a disaster...
    local $ENV{PERL5OPT} = $ENV{PERL5OPT} if $ENV{PERL5OPT};
    $ENV{PERL5OPT} =~ s/(?:^|(?<=\s))-d\b//  if $ENV{PERL5OPT};
    $ENV{PERL5OPT} =~ s/(?:^|(?<=\s))-d\B/-/ if $ENV{PERL5OPT};
    print $OUT "Making kid PERL5OPT->`$ENV{PERL5OPT}'.\n" if $ENV{PERL5OPT};
    local $ENV{PERL5LIB} = $ENV{PERL5LIB} ? $ENV{PERL5LIB} : $ENV{PERLLIB};
    $ENV{PERL5LIB} = '' unless defined $ENV{PERL5LIB};
    $ENV{PERL5LIB} = join ';', @@ini_INC, split /;/, $ENV{PERL5LIB};
    (my $name = $0) =~ s,^.*[/\\],,s;
    my @@args;

    if (
            pipe $in1, $out1
        and pipe $in2, $out2

        # system P_SESSION will fail if there is another process
        # in the same session with a "dependent" asynchronous child session.
        and @@args = (
            $rl, fileno $in1, fileno $out2,
            "Daughter Perl debugger $pids $name"
        )
        and (
            ($kpid = CORE::system 4, $^X, '-we',
                <<'ES', @@args) >= 0    # P_SESSION
d2281 1
a2281 1
my ($rl, $in) = (shift, shift);        # Read from $in and pass through
d2295 9
a2303 15
            or warn "system P_SESSION: $!, $^E" and 0
        )
        and close $in1
        and close $out2
      )
    {
        $pidprompt = '';    # Shown anyway in titlebar
        reset_IN_OUT($in2, $out1);
        $tty = '*reset*';
        return '';          # Indicate that reset_IN_OUT is called
    } ## end if (pipe $in1, $out1 and...
    return;
} ## end sub os2_get_fork_TTY

=head2 C<create_IN_OUT($flags)>
d2305 1
a2305 21
Create a new pair of filehandles, pointing to a new TTY. If impossible,
try to diagnose why.

Flags are:

=over 4

=item * 1 - Don't know how to create a new TTY.

=item * 2 - Debugger has forked, but we can't get a new TTY.

=item * 4 - standard debugger startup is happening.

=back

=cut

sub create_IN_OUT {    # Create a window with IN/OUT handles redirected there

    # If we know how to get a new TTY, do it! $in will have
    # the TTY name if get_fork_TTY works.
d2307 1
a2307 4

    # It used to be that 
    $in = $fork_TTY if defined $fork_TTY;    # Backward compatibility

d2309 2
a2310 4
        my $why = shift;

        # We don't know how.
        print_help(<<EOP) if $why == 1;
d2313 1
a2313 3

        # Forked debugger.
        print_help(<<EOP) if $why == 2;
d2317 1
a2317 3

        # Note that both debuggers are fighting over the same input.
        print_help(<<EOP) if $why != 4;
d2320 5
a2324 111
EOP
        print_help(<<EOP);
  I know how to switch the output to a different window in xterms
  and OS/2 consoles only.  For a manual switch, put the name of the created I<TTY>
  in B<\$DB::fork_TTY>, or define a function B<DB::get_fork_TTY()> returning this.

  On I<UNIX>-like systems one can get the name of a I<TTY> for the given window
  by typing B<tty>, and disconnect the I<shell> from I<TTY> by B<sleep 1000000>.

EOP
    } ## end if (not defined $in)
    elsif ($in ne '') {
        TTY($in);
    }
    else {
        $console = '';    # Indicate no need to open-from-the-console
    }
    undef $fork_TTY;
} ## end sub create_IN_OUT

=head2 C<resetterm>

Handles rejiggering the prompt when we've forked off a new debugger.

If the new debugger happened because of a C<system()> that invoked a 
program under the debugger, the arrow between the old pid and the new
in the prompt has I<two> dashes instead of one.

We take the current list of pids and add this one to the end. If there
isn't any list yet, we make one up out of the initial pid associated with 
the terminal and our new pid, sticking an arrow (either one-dashed or 
two dashed) in between them.

If C<CreateTTY> is off, or C<resetterm> was called with no arguments,
we don't try to create a new IN and OUT filehandle. Otherwise, we go ahead
and try to do that.

=cut

sub resetterm {           # We forked, so we need a different TTY

    # Needs to be passed to create_IN_OUT() as well.
    my $in = shift;

    # resetterm(2): got in here because of a system() starting a debugger.
    # resetterm(1): just forked.
    my $systemed = $in > 1 ? '-' : '';

    # If there's already a list of pids, add this to the end.
    if ($pids) {
        $pids =~ s/\]/$systemed->$$]/;
    }

    # No pid list. Time to make one.
    else {
        $pids = "[$term_pid->$$]";
    }

    # The prompt we're going to be using for this debugger.
    $pidprompt = $pids;

    # We now 0wnz this terminal.
    $term_pid  = $$;

    # Just return if we're not supposed to try to create a new TTY.
    return unless $CreateTTY & $in;

    # Try to create a new IN/OUT pair.
    create_IN_OUT($in);
} ## end sub resetterm

=head2 C<readline>

First, we handle stuff in the typeahead buffer. If there is any, we shift off
the next line, print a message saying we got it, add it to the terminal
history (if possible), and return it.

If there's nothing in the typeahead buffer, check the command filehandle stack.
If there are any filehandles there, read from the last one, and return the line
if we got one. If not, we pop the filehandle off and close it, and try the
next one up the stack.

If we've emptied the filehandle stack, we check to see if we've got a socket 
open, and we read that and return it if we do. If we don't, we just call the 
core C<readline()> and return its value.

=cut

sub readline {

    # Localize to prevent it from being smashed in the program being debugged.
    local $.;

    # Pull a line out of the typeahead if there's stuff there.
    if (@@typeahead) {
        # How many lines left.
        my $left = @@typeahead;

        # Get the next line.
        my $got  = shift @@typeahead;

        # Print a message saying we got input from the typeahead.
        local $\ = '';
        print $OUT "auto(-$left)", shift, $got, "\n";

        # Add it to the terminal history (if possible).
        $term->AddHistory($got)
          if length($got) > 1
          and defined $term->Features->{addHistory};
        return $got;
    } ## end if (@@typeahead)
d2326 2
a2327 4
    # We really need to read some input. Turn off entry/exit trace and 
    # return value printing.
    local $frame = 0;
    local $doret = -2;
d2329 8
a2336 23
    # If there are stacked filehandles to read from ...
    while (@@cmdfhs) {
        # Read from the last one in the stack.
        my $line = CORE::readline($cmdfhs[-1]);
        # If we got a line ...
        defined $line
          ? (print $OUT ">> $line" and return $line)  # Echo and return
          : close pop @@cmdfhs;                        # Pop and close
    } ## end while (@@cmdfhs)

    # Nothing on the filehandle stack. Socket?
    if (ref $OUT and UNIVERSAL::isa($OUT, 'IO::Socket::INET')) {
        # Send anyting we have to send.
        $OUT->write(join ('', @@_));

        # Receive anything there is to receive.
        my $stuff;
        $IN->recv($stuff, 2048);    # XXX "what's wrong with sysread?"
                                    # XXX Don't know. You tell me.

        # What we got.
        $stuff;
    } ## end if (ref $OUT and UNIVERSAL::isa...
d2338 7
a2344 3
    # No socket. Just read from the terminal.
    else {
        $term->readline(@@_);
d2346 5
a2350 1
} ## end sub readline
d2352 28
a2379 11
=head1 OPTIONS SUPPORT ROUTINES

These routines handle listing and setting option values.

=head2 C<dump_option> - list the current value of an option setting

This routine uses C<option_val> to look up the value for an option.
It cleans up escaped single-quotes and then displays the option and
its value.

=cut
d2382 2
a2383 2
    my ($opt, $val) = @@_;
    $val = option_val($opt, 'N/A');
d2386 1
a2386 11
} ## end sub dump_option

=head2 C<option_val> - find the current value of an option

This can't just be a simple hash lookup because of the indirect way that
the option values are stored. Some are retrieved by calling a subroutine,
some are just variables.

You must supply a default value to be used in case the option isn't set.

=cut
d2389 1
a2389 1
    my ($opt, $default) = @@_;
d2391 13
a2403 27

    # Does this option exist, and is it a variable?
    # If so, retrieve the value via the value in %optionVars.
    if (    defined $optionVars{$opt}
        and defined ${ $optionVars{$opt} }) {
        $val = ${ $optionVars{$opt} };
    }

    # Does this option exist, and it's a subroutine?
    # If so, call the subroutine via the ref in %optionAction
    # and capture the value.
    elsif ( defined $optionAction{$opt}
        and defined &{ $optionAction{$opt} }) {
        $val = &{ $optionAction{$opt} }();
    }

    # If there's an action or variable for the supplied option,
    # but no value was set, use the default.
    elsif (defined $optionAction{$opt} and not defined $option{$opt}
        or defined $optionVars{$opt} and not defined ${ $optionVars{$opt} })
    {
        $val = $default;
    }

    # Otherwise, do the simple hash lookup.
    else {
        $val = $option{$opt};
a2404 3

    # If the value isn't defined, use the default.
    # Then return whatever the value is.
d2406 2
a2407 23
    $val;
} ## end sub option_val

=head2 C<parse_options>

Handles the parsing and execution of option setting/displaying commands.

An option entered by itself is assumed to be 'set me to 1' (the default value)
if the option is a boolean one. If not, the user is prompted to enter a valid
value or to query the current value (via 'option? ').

If 'option=value' is entered, we try to extract a quoted string from the
value (if it is quoted). If it's not, we just use the whole value as-is.

We load any modules required to service this option, and then we set it: if
it just gets stuck in a variable, we do that; if there's a subroutine to 
handle setting the option, we call that.

Finally, if we're running in interactive mode, we display the effect of the
user's command back to the terminal, skipping this if we're setting things
during initialization.

=cut
d2410 1
a2410 1
    local ($_) = @@_;
d2412 6
a2417 7

    # These options need a value. Don't allow them to be clobbered by accident.
    my %opt_needs_val = map { ($_ => 1) } qw{
      dumpDepth arrayDepth hashDepth LineInfo maxTraceLen ornaments windowSize
      pager quote ReadLine recallCommand RemotePort ShellBang TTY CommandSet
      };

d2419 14
a2432 39
        my $val_defaulted;

        # Clean off excess leading whitespace.
        s/^\s+// && next;

        # Options are always all word characters, followed by a non-word
        # separator.
        s/^(\w+)(\W?)// or print($OUT "Invalid option `$_'\n"), last;
        my ($opt, $sep) = ($1, $2);

        # Make sure that such an option exists.
        my $matches = grep(/^\Q$opt/ && ($option = $_), @@options) ||
          grep(/^\Q$opt/i && ($option = $_), @@options);

        print($OUT "Unknown option `$opt'\n"), next unless $matches;
        print($OUT "Ambiguous option `$opt'\n"), next if $matches > 1;

        my $val;

        # '?' as separator means query, but must have whitespace after it.
        if ("?" eq $sep) {
            print($OUT "Option query `$opt?' followed by non-space `$_'\n"),
              last
              if /^\S/;

            #&dump_option($opt);
        } ## end if ("?" eq $sep)

        # Separator is whitespace (or just a carriage return).
        # They're going for a default, which we assume is 1.
        elsif ($sep !~ /\S/) {
            $val_defaulted = 1;
            $val           = "1"; #  this is an evil default; make 'em set it!
        }

        # Separator is =. Trying to set a value.
        elsif ($sep eq "=") {
            # If quoted, extract a quoted string.
            if (s/ (["']) ( (?: \\. | (?! \1 ) [^\\] )* ) \1 //x) {
d2435 46
a2480 1
            }
d2482 4
a2485 72
            # Not quoted. Use the whole thing. Warn about 'option='.
            else {
                s/^(\S*)//;
                $val = $1;
                print OUT qq(Option better cleared using $opt=""\n)
                  unless length $val;
            } ## end else [ if (s/ (["']) ( (?: \\. | (?! \1 ) [^\\] )* ) \1 //x)

        } ## end elsif ($sep eq "=")

        # "Quoted" with [], <>, or {}.  
        else {    #{ to "let some poor schmuck bounce on the % key in B<vi>."
            my ($end) = "\\" . substr(")]>}$sep", index("([<{", $sep), 1);  #}
            s/^(([^\\$end]|\\[\\$end])*)$end($|\s+)//
              or print($OUT "Unclosed option value `$opt$sep$_'\n"), last;
            ($val = $1) =~ s/\\([\\$end])/$1/g;
        } ## end else [ if ("?" eq $sep)

        # Impedance-match the code above to the code below.
        my $option = $opt;

        # Exclude non-booleans from getting set to 1 by default.
        if ($opt_needs_val{$option} && $val_defaulted) {
            my $cmd = ($CommandSet eq '580') ? 'o' : 'O';
            print $OUT
"Option `$opt' is non-boolean.  Use `$cmd $option=VAL' to set, `$cmd $option?' to query\n";
            next;
        } ## end if ($opt_needs_val{$option...

        # Save the option value.
        $option{$option} = $val if defined $val;

        # Load any module that this option requires.
        eval qq{
                local \$frame = 0; 
                local \$doret = -2; 
                require '$optionRequire{$option}';
                1;
               } || die    # XXX: shouldn't happen
          if defined $optionRequire{$option} &&
             defined $val;

        # Set it. 
        # Stick it in the proper variable if it goes in a variable.
        ${ $optionVars{$option} } = $val
          if defined $optionVars{$option} &&
          defined $val;

        # Call the appropriate sub if it gets set via sub.
        &{ $optionAction{$option} }($val)
          if defined $optionAction{$option} &&
          defined &{ $optionAction{$option} } &&
          defined $val;

        # Not initialization - echo the value we set it to.
        dump_option($option) unless $OUT eq \*STDERR;
    } ## end while (length)
} ## end sub parse_options

=head1 RESTART SUPPORT

These routines are used to store (and restore) lists of items in environment 
variables during a restart.

=head2 set_list

Set_list packages up items to be stored in a set of environment variables
(VAR_n, containing the number of items, and VAR_0, VAR_1, etc., containing
the values). Values outside the standard ASCII charset are stored by encoding
then as hexadecimal values.

=cut
d2488 10
a2497 22
    my ($stem, @@list) = @@_;
    my $val;

    # VAR_n: how many we have. Scalar assignment gets the number of items.
    $ENV{"${stem}_n"} = @@list;

    # Grab each item in the list, escape the backslashes, encode the non-ASCII
    # as hex, and then save in the appropriate VAR_0, VAR_1, etc.
    for $i (0 .. $#list) {
        $val = $list[$i];
        $val =~ s/\\/\\\\/g;
        $val =~ s/([\0-\37\177\200-\377])/"\\0x" . unpack('H2',$1)/eg;
        $ENV{"${stem}_$i"} = $val;
    } ## end for $i (0 .. $#list)
} ## end sub set_list

=head2 get_list

Reverse the set_list operation: grab VAR_n to see how many we should be getting
back, and then pull VAR_0, VAR_1. etc. back out.

=cut 
d2500 11
a2510 22
    my $stem = shift;
    my @@list;
    my $n = delete $ENV{"${stem}_n"};
    my $val;
    for $i (0 .. $n - 1) {
        $val = delete $ENV{"${stem}_$i"};
        $val =~ s/\\((\\)|0x(..))/ $2 ? $2 : pack('H2', $3) /ge;
        push @@list, $val;
    }
    @@list;
} ## end sub get_list

=head1 MISCELLANEOUS SIGNAL AND I/O MANAGEMENT

=head2 catch()

The C<catch()> subroutine is the essence of fast and low-impact. We simply
set an already-existing global scalar variable to a constant value. This 
avoids allocating any memory possibly in the middle of something that will
get all confused if we do.

=cut
d2514 1
a2514 1
    return;    # Put nothing on the stack - malloc/free land!
a2516 12
=head2 C<warn()>

C<warn> emits a warning, by joining together its arguments and printing
them, with couple of fillips.

If the composited message I<doesn't> end with a newline, we automatically 
add C<$!> and a newline to the end of the message. The subroutine expects $OUT 
to be set to the filehandle to be used to output warnings; it makes no 
assumptions about what filehandles are available.

=cut

d2518 1
a2518 1
    my ($msg) = join ("", @@_);
d2522 1
a2522 11
} ## end sub warn

=head1 INITIALIZATION TTY SUPPORT

=head2 C<reset_IN_OUT>

This routine handles restoring the debugger's input and output filehandles
after we've tried and failed to move them elsewhere.  In addition, it assigns 
the debugger's output filehandle to $LINEINFO if it was already open there.

=cut
a2525 2

    # If there's a term and it's able to get a new tty, try to get one.
d2527 6
a2532 12
        ($IN, $OUT) = (shift, shift);
        $term->newTTY($IN, $OUT);
    }

    # This term can't get a new tty now. Better luck later.
    elsif ($term) {
        &warn("Too late to set IN/OUT filehandles, enabled on next `R'!\n");
    }

    # Set the filehndles up as they were.
    else {
        ($IN, $OUT) = (shift, shift);
a2533 2

    # Unbuffer the output filehandle.
a2536 2

    # Point LINEINFO to the same output filehandle if it was there before.
d2538 1
a2538 18
} ## end sub reset_IN_OUT

=head1 OPTION SUPPORT ROUTINES

The following routines are used to process some of the more complicated 
debugger options.

=head2 C<TTY>

Sets the input and output filehandles to the specified files or pipes.
If the terminal supports switching, we go ahead and do it. If not, and
there's already a terminal in place, we save the information to take effect
on restart.

If there's no terminal yet (for instance, during debugger initialization),
we go ahead and set C<$console> and C<$tty> to the file indicated.

=cut
d2542 11
a2552 27
        # This terminal supports switching to a new TTY.
        # Can be a list of two files, or on string containing both names,
        # comma-separated.
        # XXX Should this perhaps be an assignment from @@_?
        my ($in, $out) = shift; 
        if ($in =~ /,/) {
            # Split list apart if supplied.
            ($in, $out) = split /,/, $in, 2;
        }
        else {
            # Use the same file for both input and output.
            $out = $in;
        }

        # Open file onto the debugger's filehandles, if you can.
        open IN, $in or die "cannot open `$in' for read: $!";
        open OUT, ">$out" or die "cannot open `$out' for write: $!";

        # Swap to the new filehandles.
        reset_IN_OUT(\*IN, \*OUT);

        # Save the setting for later.
        return $tty = $in;
    } ## end if (@@_ and $term and $term...

    # Terminal doesn't support new TTY, or doesn't support readline.
    # Can't do it now, try restarting.
a2553 1
    
a2555 2

    # Return whatever the TTY is.
d2557 1
a2557 9
} ## end sub TTY

=head2 C<noTTY>

Sets the C<$notty> global, controlling whether or not the debugger tries to
get a terminal to read from. If called after a terminal is already in place,
we save the value to use it if we're restarted.

=cut
d2561 1
a2561 1
        &warn("Too late to set noTTY, enabled on next `R'!\n") if @@_;
d2565 1
a2565 10
} ## end sub noTTY

=head2 C<ReadLine>

Sets the C<$rl> option variable. If 0, we use C<Term::ReadLine::Stub> 
(essentially, no C<readline> processing on this "terminal"). Otherwise, we
use C<Term::ReadLine>. Can't be changed after a terminal's in place; we save
the value in case a restart is done so we can change it then.

=cut
d2569 1
a2569 1
        &warn("Too late to set ReadLine, enabled on next `R'!\n") if @@_;
d2573 1
a2573 9
} ## end sub ReadLine

=head2 C<RemotePort>

Sets the port that the debugger will try to connect to when starting up.
If the terminal's already been set up, we can't do it, but we remember the
setting in case the user does a restart.

=cut
d2581 1
a2581 8
} ## end sub RemotePort

=head2 C<tkRunning>

Checks with the terminal to see if C<Tk> is running, and returns true or
false. Returns false if the current terminal doesn't support C<readline>.

=cut
d2584 1
a2584 1
    if (${ $term->Features }{tkRunning}) {
d2586 4
d2591 1
a2591 13
    else {
        local $\ = '';
        print $OUT "tkRunning not supported by current ReadLine package.\n";
        0;
    }
} ## end sub tkRunning

=head2 C<NonStop>

Sets nonstop mode. If a terminal's already been set up, it's too late; the
debugger remembers the setting in case you restart, though.

=cut
d2595 1
a2595 2
        &warn("Too late to set up NonStop mode, enabled on next `R'!\n")
          if @@_;
d2599 1
a2599 8
} ## end sub NonStop

=head2 C<pager>

Set up the C<$pager> variable. Adds a pipe to the front unless there's one
there already.

=cut
d2603 2
a2604 2
        $pager = shift;
        $pager = "|" . $pager unless $pager =~ /^(\+?\>|\|)/;
d2607 1
a2607 8
} ## end sub pager

=head2 C<shellBang>

Sets the shell escape command, and generates a printable copy to be used 
in the help.

=cut
a2609 3

    # If we got an argument, meta-quote it, and add '\b' if it
    # ends in a word character.
d2611 2
a2612 2
        $sh = quotemeta shift;
        $sh .= "\\b" if $sh =~ /\w$/;
d2614 5
a2618 15

    # Generate the printable version for the help:
    $psh = $sh;                       # copy it
    $psh =~ s/\\b$//;                 # Take off trailing \b if any
    $psh =~ s/\\(.)/$1/g;             # De-escape
    $psh;                             # return the printable version
} ## end sub shellBang

=head2 C<ornaments>

If the terminal has its own ornaments, fetch them. Otherwise accept whatever
was passed as the argument. (This means you can't override the terminal's
ornaments.)

=cut 
d2621 8
a2628 21
    if (defined $term) {
        # We don't want to show warning backtraces, but we do want die() ones.
        local ($warnLevel, $dieLevel) = (0, 1);

        # No ornaments if the terminal doesn't support them.
        return '' unless $term->Features->{ornaments};
        eval { $term->ornaments(@@_) } || '';
    }

    # Use what was passed in if we can't determine it ourselves.
    else {
        $ornaments = shift;
    }
} ## end sub ornaments

=head2 C<recallCommand>

Sets the recall command, and builds a printable version which will appear in
the help text.

=cut
a2630 3

    # If there is input, metaquote it. Add '\b' if it ends with a word
    # character.
d2632 2
a2633 2
        $rc = quotemeta shift;
        $rc .= "\\b" if $rc =~ /\w$/;
d2635 5
a2639 17

    # Build it into a printable version.
    $prc = $rc;                             # Copy it
    $prc =~ s/\\b$//;                       # Remove trailing \b
    $prc =~ s/\\(.)/$1/g;                   # Remove escapes
    $prc;                                   # Return the printable version
} ## end sub recallCommand

=head2 C<LineInfo> - where the line number information goes

Called with no arguments, returns the file or pipe that line info should go to.

Called with an argument (a file or a pipe), it opens that onto the 
C<LINEINFO> filehandle, unbuffers the filehandle, and then returns the 
file or pipe again to the caller.

=cut
a2643 3

    #  If this is a valid "thing to be opened for output", tack a 
    # '>' onto the front.
a2644 2

    # If this is a pipe, the stream points to a slave editor.
a2645 2

    # Open it up and unbuffer it.
a2650 2

    # Hand the file or pipe back again.
d2652 1
a2652 1
} ## end sub LineInfo
d2654 16
a2669 61
=head1 COMMAND SUPPORT ROUTINES

These subroutines provide functionality for various commands.

=head2 C<list_modules>

For the C<M> command: list modules loaded and their versions.
Essentially just runs through the keys in %INC, picks up the 
$VERSION package globals from each package, gets the file name, and formats the
information for output.

=cut

sub list_modules {    # versions
    my %version;
    my $file;
    # keys are the "as-loaded" name, values are the fully-qualified path
    # to the file itself.
    for (keys %INC) {
        $file = $_;                                # get the module name
        s,\.p[lm]$,,i;                             # remove '.pl' or '.pm'
        s,/,::,g;                                  # change '/' to '::'
        s/^perl5db$/DB/;                           # Special case: debugger
                                                   # moves to package DB
        s/^Term::ReadLine::readline$/readline/;    # simplify readline

        # If the package has a $VERSION package global (as all good packages
        # should!) decode it and save as partial message.
        if (defined ${ $_ . '::VERSION' }) {
            $version{$file} = "${ $_ . '::VERSION' } from ";
        }

        # Finish up the message with the file the package came from.
        $version{$file} .= $INC{$file};
    } ## end for (keys %INC)

    # Hey, dumpit() formats a hash nicely, so why not use it?
    dumpit($OUT, \%version);
} ## end sub list_modules

=head2 C<sethelp()>

Sets up the monster string used to format and print the help.

=head3 HELP MESSAGE FORMAT

The help message is a peculiar format unto itself; it mixes C<pod> 'ornaments'
(BE<lt>E<gt>, IE<gt>E<lt>) with tabs to come up with a format that's fairly
easy to parse and portable, but which still allows the help to be a little
nicer than just plain text.

Essentially, you define the command name (usually marked up with BE<gt>E<lt>
and IE<gt>E<lt>), followed by a tab, and then the descriptive text, ending in a newline. The descriptive text can also be marked up in the same way. If you 
need to continue the descriptive text to another line, start that line with 
just tabs and then enter the marked-up text.

If you are modifying the help text, I<be careful>. The help-string parser is 
not very sophisticated, and if you don't follow these rules it will mangle the 
help beyond hope until you fix the string.

=cut
a2671 1

d2677 3
a2679 3
Help is currently only available for the new 5.8 command set. 
No help is available for the old command set. 
We assume you know what you're doing if you switch to it.
a2745 1
B<y> [I<n> [I<Vars>]]   List lexicals in higher scope <n>.  Vars same as B<V>.
a2749 1
B<< *>				Delete the list of perl commands to run before each prompt.
a2752 1
B<>>B< *>		Delete the list of Perl commands to run after each prompt.
a2754 1
B<{ *>				Delete the list of debugger commands to run before each prompt.
d2761 2
a2762 7
      . (
        $rc eq $sh
        ? ""
        : "
B<$psh> [I<cmd>] 	Run I<cmd> in subshell (forces \"\$SHELL -c 'cmd'\")."
      ) 
      . "
d2821 1
a2821 1
";    # Fix balance of vi % matching: }}}}
d2851 1
d2853 2
a2854 4
    # ')}}; # Fix balance of vi % matching

    # and this is really numb...
    $pre580_help = "
d2858 1
a2858 1
B<CR>>			Repeat last B<n> or B<s> command.
d2930 2
a2931 7
      . (
        $rc eq $sh
        ? ""
        : "
B<$psh> [I<cmd>] 	Run I<cmd> in subshell (forces \"\$SHELL -c 'cmd'\")."
      ) .
      "
d2990 1
a2990 1
";    # Fix balance of vi % matching: }}}}
d3019 1
d3021 1
a3021 12
    # ')}}; # Fix balance of vi % matching

} ## end sub sethelp

=head2 C<print_help()>

Most of what C<print_help> does is just text formatting. It finds the
C<B> and C<I> ornaments, cleans them off, and substitutes the proper
terminal control characters to simulate them (courtesy of 
<Term::ReadLine::TermCap>).

=cut
d3033 7
a3039 7
        ^                       # only matters at start of line
          ( \040{4} | \t )*     # some subcommands are indented
          ( < ?                 # so <CR> works
            [BI] < [^\t\n] + )  # find an eeevil ornament
          ( \t+ )               # original separation, discarded
          ( .* )                # this will now start (no earlier) than 
                                # column 16
d3041 5
a3045 6
        my($leadwhite, $command, $midwhite, $text) = ($1, $2, $3, $4);
        my $clean = $command;
        $clean =~ s/[BI]<([^>]*)>/$1/g;  

        # replace with this whole string:
        ($leadwhite ? " " x 4 : "")
d3052 2
a3053 2
    s{                          # handle bold ornaments
       B < ( [^>] + | > ) >
d3055 3
a3057 3
          $Term::ReadLine::TermCap::rl_term_set[2] 
        . $1
        . $Term::ReadLine::TermCap::rl_term_set[3]
d3060 2
a3061 2
    s{                         # handle italic ornaments
       I < ( [^>] + | > ) >
d3063 3
a3065 3
          $Term::ReadLine::TermCap::rl_term_set[0] 
        . $1
        . $Term::ReadLine::TermCap::rl_term_set[1]
d3070 1
a3070 9
} ## end sub print_help

=head2 C<fix_less> 

This routine does a lot of gyrations to be sure that the pager is C<less>.
It checks for C<less> masquerading as C<more> and records the result in
C<$ENV{LESS}> so we don't have to go through doing the stats again.

=cut
a3072 2

    # We already know if this is set.
a3073 2

    # Pager is less for sure.
d3075 7
a3081 12
    if ($pager =~ /\bmore\b/) {
        # Nope, set to more. See what's out there.
        my @@st_more = stat('/usr/bin/more');
        my @@st_less = stat('/usr/bin/less');

        # is it really less, pretending to be more?
        $is_less = @@st_more &&
          @@st_less &&
          $st_more[0] == $st_less[0] &&
          $st_more[1] == $st_less[1];
    } ## end if ($pager =~ /\bmore\b/)

d3083 2
a3084 15
    # 'r' added so we don't do (slow) stats again.
    $ENV{LESS} .= 'r' if $is_less;
} ## end sub fix_less

=head1 DIE AND WARN MANAGEMENT

=head2 C<diesignal>

C<diesignal> is a just-drop-dead C<die> handler. It's most useful when trying
to debug a debugger problem.

It does its best to report the error that occurred, and then forces the
program, debugger, and everything to die.

=cut
a3086 1
    # No entry/exit messages.
a3087 2

    # No return value prints.
a3088 2

    # set the abort signal handling to the default (just terminate).
a3089 3

    # If we enter the signal handler recursively, kill myself with an
    # abort signal (so we just terminate).
a3090 2

    # If we can show detailed info, do so.
d3092 3
a3094 9
        # Don't recursively enter the warn handler, since we're carping.
        local $SIG{__WARN__} = '';

        # Skip two levels before reporting traceback: we're skipping 
        # mydie and confess. 
        local $Carp::CarpLevel = 2;    # mydie + confess

        # Tell us all about it.
        &warn(Carp::longmess("Signal @@_"));
a3095 2

    # No Carp. Tell us about the signal as best we can.
d3097 2
a3098 2
        local $\ = '';
        print $DB::OUT "Got signal @@_\n";
a3099 2

    # Drop dead.
d3101 1
a3101 1
} ## end sub diesignal
d3103 15
a3117 61
=head2 C<dbwarn>

The debugger's own default C<$SIG{__WARN__}> handler. We load C<Carp> to
be able to get a stack trace, and output the warning message vi C<DB::dbwarn()>.

=cut

sub dbwarn {
    # No entry/exit trace. 
    local $frame = 0;

    # No return value printing.
    local $doret = -2;

    # Turn off warn and die handling to prevent recursive entries to this
    # routine.
    local $SIG{__WARN__} = '';
    local $SIG{__DIE__}  = '';

    # Load Carp if we can. If $^S is false (current thing being compiled isn't
    # done yet), we may not be able to do a require.
    eval { require Carp }
      if defined $^S;    # If error/warning during compilation,
                         # require may be broken.

    # Use the core warn() unless Carp loaded OK.
    CORE::warn(@@_,
        "\nCannot print stack trace, load with -MCarp option to see stack"),
      return
      unless defined &Carp::longmess;

    # Save the current values of $single and $trace, and then turn them off.
    my ($mysingle, $mytrace) = ($single, $trace);
    $single = 0;
    $trace  = 0;

    # We can call Carp::longmess without its being "debugged" (which we 
    # don't want - we just want to use it!). Capture this for later.
    my $mess = Carp::longmess(@@_);

    # Restore $single and $trace to their original values.
    ($single, $trace) = ($mysingle, $mytrace);

    # Use the debugger's own special way of printing warnings to print
    # the stack trace message.
    &warn($mess);
} ## end sub dbwarn

=head2 C<dbdie>

The debugger's own C<$SIG{__DIE__}> handler. Handles providing a stack trace
by loading C<Carp> and calling C<Carp::longmess()> to get it. We turn off 
single stepping and tracing during the call to C<Carp::longmess> to avoid 
debugging it - we just want to use it.

If C<dieLevel> is zero, we let the program being debugged handle the
exceptions. If it's 1, you get backtraces for any exception. If it's 2,
the debugger takes over all exception handling, printing a backtrace and
displaying the exception via its C<dbwarn()> routine. 

=cut
d3120 34
a3153 33
    local $frame = 0;
    local $doret = -2;
    local $SIG{__DIE__}  = '';
    local $SIG{__WARN__} = '';
    my $i      = 0;
    my $ineval = 0;
    my $sub;
    if ($dieLevel > 2) {
        local $SIG{__WARN__} = \&dbwarn;
        &warn(@@_);    # Yell no matter what
        return;
    }
    if ($dieLevel < 2) {
        die @@_ if $^S;    # in eval propagate
    }

    # The code used to check $^S to see if compiliation of the current thing
    # hadn't finished. We don't do it anymore, figuring eval is pretty stable.
    eval { require Carp }; 

    die (@@_,
        "\nCannot print stack trace, load with -MCarp option to see stack")
      unless defined &Carp::longmess;

    # We do not want to debug this chunk (automatic disabling works
    # inside DB::DB, but not in Carp). Save $single and $trace, turn them off,
    # get the stack trace from Carp::longmess (if possible), restore $signal
    # and $trace, and then die with the stack trace.
    my ($mysingle, $mytrace) = ($single, $trace);
    $single = 0;
    $trace  = 0;
    my $mess = "@@_";
    {
d3155 8
a3162 2
        package Carp;    # Do not include us in the list
        eval { $mess = Carp::longmess(@@_); };
d3164 3
a3166 35
    ($single, $trace) = ($mysingle, $mytrace);
    die $mess;
} ## end sub dbdie

=head2 C<warnlevel()>

Set the C<$DB::warnLevel> variable that stores the value of the
C<warnLevel> option. Calling C<warnLevel()> with a positive value
results in the debugger taking over all warning handlers. Setting
C<warnLevel> to zero leaves any warning handlers set up by the program
being debugged in place.

=cut

sub warnLevel {
    if (@@_) {
        $prevwarn = $SIG{__WARN__} unless $warnLevel;
        $warnLevel = shift;
        if ($warnLevel) {
            $SIG{__WARN__} = \&DB::dbwarn;
        }
        elsif ($prevwarn) {
            $SIG{__WARN__} = $prevwarn;
        }
    } ## end if (@@_)
    $warnLevel;
} ## end sub warnLevel

=head2 C<dielevel>

Similar to C<warnLevel>. Non-zero values for C<dieLevel> result in the 
C<DB::dbdie()> function overriding any other C<die()> handler. Setting it to
zero lets you use your own C<die()> handler.

=cut
d3169 18
a3186 38
    local $\ = '';
    if (@@_) {
        $prevdie = $SIG{__DIE__} unless $dieLevel;
        $dieLevel = shift;
        if ($dieLevel) {
            # Always set it to dbdie() for non-zero values.
            $SIG{__DIE__} = \&DB::dbdie;    # if $dieLevel < 2;

           # No longer exists, so don't try  to use it.
           #$SIG{__DIE__} = \&DB::diehard if $dieLevel >= 2;

            # If we've finished initialization, mention that stack dumps
            # are enabled, If dieLevel is 1, we won't stack dump if we die
            # in an eval().
            print $OUT "Stack dump during die enabled",
              ($dieLevel == 1 ? " outside of evals" : ""), ".\n"
              if $I_m_init;

            # XXX This is probably obsolete, given that diehard() is gone.
            print $OUT "Dump printed too.\n" if $dieLevel > 2;
        } ## end if ($dieLevel)

        # Put the old one back if there was one.
        elsif ($prevdie) {
            $SIG{__DIE__} = $prevdie;
            print $OUT "Default die handler restored.\n";
        }
    } ## end if (@@_)
    $dieLevel;
} ## end sub dieLevel

=head2 C<signalLevel>

Number three in a series: set C<signalLevel> to zero to keep your own
signal handler for C<SIGSEGV> and/or C<SIGBUS>. Otherwise, the debugger 
takes over and handles them with C<DB::diesignal()>.

=cut
d3189 14
a3202 31
    if (@@_) {
        $prevsegv = $SIG{SEGV} unless $signalLevel;
        $prevbus  = $SIG{BUS}  unless $signalLevel;
        $signalLevel = shift;
        if ($signalLevel) {
            $SIG{SEGV} = \&DB::diesignal;
            $SIG{BUS}  = \&DB::diesignal;
        }
        else {
            $SIG{SEGV} = $prevsegv;
            $SIG{BUS}  = $prevbus;
        }
    } ## end if (@@_)
    $signalLevel;
} ## end sub signalLevel

=head1 SUBROUTINE DECODING SUPPORT

These subroutines are used during the C<x> and C<X> commands to try to
produce as much information as possible about a code reference. They use
L<Devel::Peek> to try to find the glob in which this code reference lives
(if it does) - this allows us to actually code references which correspond
to named subroutines (including those aliased via glob assignment).

=head2 C<CvGV_name()>

Wrapper for X<CvGV_name_or_bust>; tries to get the name of a reference
via that routine. If this fails, return the reference again (when the
reference is stringified, it'll come out as "SOMETHING(0X...)").

=cut
d3205 3
a3207 3
    my $in   = shift;
    my $name = CvGV_name_or_bust($in);
    defined $name ? $name : $in;
a3209 10
=head2 C<CvGV_name_or_bust> I<coderef>

Calls L<Devel::Peek> to try to find the glob the ref lives in; returns
C<undef> if L<Devel::Peek> can't be loaded, or if C<Devel::Peek::CvGV> can't
find a glob for this ref.

Returns "I<package>::I<glob name>" if the code ref is found in a glob.

=cut

d3211 8
a3218 20
    my $in = shift;
    return if $skipCvGV;    # Backdoor to avoid problems if XS broken...
    return unless ref $in;
    $in = \&$in;            # Hard reference...
    eval { require Devel::Peek; 1 } or return;
    my $gv = Devel::Peek::CvGV($in) or return;
    *$gv{PACKAGE} . '::' . *$gv{NAME};
} ## end sub CvGV_name_or_bust

=head2 C<find_sub>

A utility routine used in various places; finds the file where a subroutine 
was defined, and returns that filename and a line-number range.

Tries to use X<@@sub> first; if it can't find it there, it tries building a
reference to the subroutine and uses X<CvGV_name_or_bust> to locate it,
loading it into X<@@sub> as a side effect (XXX I think). If it can't find it
this way, it brute-force searches X<%sub>, checking for identical references.

=cut
d3221 7
a3227 23
    my $subr = shift;
    $sub{$subr} or do {
        return unless defined &$subr;
        my $name = CvGV_name_or_bust($subr);
        my $data;
        $data = $sub{$name} if defined $name;
        return $data if defined $data;

        # Old stupid way...
        $subr = \&$subr;    # Hard reference
        my $s;
        for (keys %sub) {
            $s = $_, last if $subr eq \&$_;
        }
        $sub{$s} if $s;
      } ## end do
} ## end sub find_sub

=head2 C<methods>

A subroutine that uses the utility function X<methods_via> to find all the
methods in the class corresponding to the current reference and in 
C<UNIVERSAL>.
d3229 5
a3233 64
=cut

sub methods {

    # Figure out the class - either this is the class or it's a reference
    # to something blessed into that class.
    my $class = shift;
    $class = ref $class if ref $class;

    local %seen;
    local %packs;

    # Show the methods that this class has.
    methods_via($class, '', 1);

    # Show the methods that UNIVERSAL has.
    methods_via('UNIVERSAL', 'UNIVERSAL', 0);
} ## end sub methods

=head2 C<methods_via($class, $prefix, $crawl_upward)>

C<methods_via> does the work of crawling up the C<@@ISA> tree and reporting
all the parent class methods. C<$class> is the name of the next class to
try; C<$prefix> is the message prefix, which gets built up as we go up the
C<@@ISA> tree to show parentage; C<$crawl_upward> is 1 if we should try to go
higher in the C<@@ISA> tree, 0 if we should stop.

=cut

sub methods_via {
    # If we've processed this class already, just quit.
    my $class = shift;
    return if $seen{$class}++;

    # This is a package that is contributing the methods we're about to print. 
    my $prefix = shift;
    my $prepend = $prefix ? "via $prefix: " : '';

    my $name;
    for $name (
        # Keep if this is a defined subroutine in this class.
        grep { defined &{ ${"${class}::"}{$_} } }
             # Extract from all the symbols in this class.
             sort keys %{"${class}::"}
      ) {
        # If we printed this already, skip it.
        next if $seen{$name}++;
 
        # Print the new method name.
        local $\ = '';
        local $, = '';
        print $DB::OUT "$prepend$name\n";
    } ## end for $name (grep { defined...

    # If the $crawl_upward argument is false, just quit here.
    return unless shift; 

    # $crawl_upward true: keep going up the tree.
    # Find all the classes this one is a subclass of.
    for $name (@@{"${class}::ISA"}) {
        # Set up the new prefix.
        $prepend = $prefix ? $prefix . " -> $name" : $name;
        # Crawl up the tree and keep trying to crawl up. 
        methods_via($name, $prepend, 1);
d3235 3
a3237 7
} ## end sub methods_via

=head2 C<setman> - figure out which command to use to show documentation

Just checks the contents of C<$^O> and sets the C<$doccmd> global accordingly.

=cut
d3239 8
a3246 6
sub setman {
    $doccmd =
      $^O !~ /^(?:MSWin32|VMS|os2|dos|amigaos|riscos|MacOS|NetWare)\z/s
      ? "man"               # O Happy Day!
      : "perldoc";          # Alas, poor unfortunates
} ## end sub setman
d3248 19
a3266 1
=head2 C<runman> - run the appropriate command to show documentation
d3268 5
a3272 5
Accepts a man page name; runs the appropriate command to display it (set up
during debugger initialization). Uses C<DB::system> to avoid mucking up the
program's STDIN and STDOUT.

=cut
d3277 3
a3279 4
        &system("$doccmd $doccmd");
        return;
    }

d3283 3
a3285 3
        &system("$doccmd $page");
        return;
    }
d3292 1
a3292 1
    for ($man1dir, $man3dir) { s#/[^/]*\z## if /\S/ }
a3296 1

d3301 4
a3304 9
    if (
        CORE::system(
            $doccmd,

            # I just *know* there are men without -M
            (($manpath && !$nopathopt) ? ("-M", $manpath) : ()),
            split ' ', $page
        )
      )
d3306 18
a3323 21
        unless ($page =~ /^perl\w/) {
            if (
                grep { $page eq $_ }
                qw{
                5004delta 5005delta amiga api apio book boot bot call compile
                cygwin data dbmfilter debug debguts delta diag doc dos dsc embed
                faq faq1 faq2 faq3 faq4 faq5 faq6 faq7 faq8 faq9 filter fork
                form func guts hack hist hpux intern ipc lexwarn locale lol mod
                modinstall modlib number obj op opentut os2 os390 pod port
                ref reftut run sec style sub syn thrtut tie toc todo toot tootc
                trap unicode var vms win32 xs xstut
                }
              )
            {
                $page =~ s/^/perl/;
                CORE::system($doccmd,
                    (($manpath && !$nopathopt) ? ("-M", $manpath) : ()),
                    $page);
            } ## end if (grep { $page eq $_...
        } ## end unless ($page =~ /^perl\w/)
    } ## end if (CORE::system($doccmd...
d3325 5
a3329 46
        $ENV{MANPATH} = $manpath;
    }
    else {
        delete $ENV{MANPATH};
    }
} ## end sub runman

#use Carp;                          # This did break, left for debugging

=head1 DEBUGGER INITIALIZATION - THE SECOND BEGIN BLOCK

Because of the way the debugger interface to the Perl core is designed, any
debugger package globals that C<DB::sub()> requires have to be defined before
any subroutines can be called. These are defined in the second C<BEGIN> block.

This block sets things up so that (basically) the world is sane
before the debugger starts executing. We set up various variables that the
debugger has to have set up before the Perl core starts running:

=over 4 

=item * The debugger's own filehandles (copies of STD and STDOUT for now).

=item * Characters for shell escapes, the recall command, and the history command.

=item * The maximum recursion depth.

=item * The size of a C<w> command's window.

=item * The before-this-line context to be printed in a C<v> (view a window around this line) command.

=item * The fact that we're not in a sub at all right now.

=item * The default SIGINT handler for the debugger.

=item * The appropriate value of the flag in C<$^D> that says the debugger is running

=item * The current debugger recursion level

=item * The list of postponed (XXX define) items and the C<$single> stack

=item * That we want no return values and no subroutine entry/exit trace.

=back

=cut
d3333 26
a3358 63
BEGIN {    # This does not compile, alas. (XXX eh?)
    $IN      = \*STDIN;     # For bugs before DB::OUT has been opened
    $OUT     = \*STDERR;    # For errors before DB::OUT has been opened

    # Define characters used by command parsing. 
    $sh      = '!';         # Shell escape (does not work)
    $rc      = ',';         # Recall command (does not work)
    @@hist    = ('?');       # Show history (does not work)

    # This defines the point at which you get the 'deep recursion' 
    # warning. It MUST be defined or the debugger will not load.
    $deep    = 100;

    # Number of lines around the current one that are shown in the 
    # 'w' command.
    $window  = 10;

    # How much before-the-current-line context the 'v' command should
    # use in calculating the start of the window it will display.
    $preview = 3;

    # We're not in any sub yet, but we need this to be a defined value.
    $sub     = '';

    # Set up the debugger's interrupt handler. It simply sets a flag 
    # ($signal) that DB::DB() will check before each command is executed.
    $SIG{INT} = \&DB::catch;

    # The following lines supposedly, if uncommented, allow the debugger to
    # debug itself. Perhaps we can try that someday. 
    # This may be enabled to debug debugger:
    #$warnLevel = 1 unless defined $warnLevel;
    #$dieLevel = 1 unless defined $dieLevel;
    #$signalLevel = 1 unless defined $signalLevel;

    # This is the flag that says "a debugger is running, please call
    # DB::DB and DB::sub". We will turn it on forcibly before we try to
    # execute anything in the user's context, because we always want to
    # get control back.
    $db_stop = 0;           # Compiler warning ...
    $db_stop = 1 << 30;     # ... because this is only used in an eval() later.

    # This variable records how many levels we're nested in debugging. Used
    # Used in the debugger prompt, and in determining whether it's all over or 
    # not.
    $level   = 0;           # Level of recursive debugging

    # "Triggers bug (?) in perl if we postpone this until runtime."
    # XXX No details on this yet, or whether we should fix the bug instead
    # of work around it. Stay tuned. 
    @@postponed = @@stack = (0);

    # Used to track the current stack depth using the auto-stacked-variable
    # trick.
    $stack_depth = 0;    # Localized repeatedly; simple way to track $#stack

    # Don't print return values on exiting a subroutine.
    $doret       = -2;

    # No extry/exit tracing.
    $frame       = 0;

} ## end BEGIN
d3360 1
a3360 1
BEGIN { $^W = $ini_warn; }    # Switch warnings back
d3362 1
a3362 15
=head1 READLINE SUPPORT - COMPLETION FUNCTION

=head2 db_complete

C<readline> support - adds command completion to basic C<readline>. 

Returns a list of possible completions to C<readline> when invoked. C<readline>
will print the longest common substring following the text already entered. 

If there is only a single possible completion, C<readline> will use it in full.

This code uses C<map> and C<grep> heavily to create lists of possible 
completion. Think LISP in this section.

=cut
d3365 12
a3376 60

    # Specific code for b c l V m f O, &blah, $blah, @@blah, %blah
    # $text is the text to be completed.
    # $line is the incoming line typed by the user.
    # $start is the start of the text to be completed in the incoming line.
    my ($text, $line, $start) = @@_;

    # Save the initial text.
    # The search pattern is current package, ::, extract the next qualifier
    # Prefix and pack are set to undef.
    my ($itext, $search, $prefix, $pack) =
      ($text, "^\Q${'package'}::\E([^:]+)\$");

=head3 C<b postpone|compile> 

=over 4

=item * Find all the subroutines that might match in this package

=item * Add "postpone", "load", and "compile" as possibles (we may be completing the keyword itself

=item * Include all the rest of the subs that are known

=item * C<grep> out the ones that match the text we have so far

=item * Return this as the list of possible completions

=back

=cut 

    return sort grep /^\Q$text/, (keys %sub),
      qw(postpone load compile),    # subroutines
      (map { /$search/ ? ($1) : () } keys %sub)
      if (substr $line, 0, $start) =~ /^\|*[blc]\s+((postpone|compile)\s+)?$/;

=head3 C<b load>

Get all the possible files from @@INC as it currently stands and
select the ones that match the text so far.

=cut

    return sort grep /^\Q$text/, values %INC    # files
      if (substr $line, 0, $start) =~ /^\|*b\s+load\s+$/;

=head3  C<V> (list variable) and C<m> (list modules)

There are two entry points for these commands:

=head4 Unqualified package names

Get the top-level packages and grab everything that matches the text
so far. For each match, recursively complete the partial packages to
get all possible matching packages. Return this sorted list.

=cut

    return sort map { ($_, db_complete($_ . "::", "V ", 2)) }
      grep /^\Q$text/, map { /^(.*)::$/ ? ($1) : () } keys %::  # top-packages
d3378 65
a3442 251

=head4 Qualified package names

Take a partially-qualified package and find all subpackages for it
by getting all the subpackages for the package so far, matching all
the subpackages against the text, and discarding all of them which 
start with 'main::'. Return this list.

=cut

    return sort map { ($_, db_complete($_ . "::", "V ", 2)) }
      grep !/^main::/, grep /^\Q$text/,
        map { /^(.*)::$/ ? ($prefix . "::$1") : () } keys %{ $prefix . '::' }
          if (substr $line, 0, $start) =~ /^\|*[Vm]\s+$/
              and $text =~ /^(.*[^:])::?(\w*)$/
              and $prefix = $1;

=head3 C<f> - switch files

Here, we want to get a fully-qualified filename for the C<f> command.
Possibilities are:

=over 4

=item 1. The original source file itself

=item 2. A file from C<@@INC>

=item 3. An C<eval> (the debugger gets a C<(eval N)> fake file for each C<eval>).

=back

=cut

    if ($line =~ /^\|*f\s+(.*)/) {                              # Loaded files
        # We might possibly want to switch to an eval (which has a "filename"
        # like '(eval 9)'), so we may need to clean up the completion text 
        # before proceeding. 
        $prefix = length($1) - length($text);
        $text   = $1;

=pod

Under the debugger, source files are represented as C<_E<lt>/fullpath/to/file> 
(C<eval>s are C<_E<lt>(eval NNN)>) keys in C<%main::>. We pull all of these 
out of C<%main::>, add the initial source file, and extract the ones that 
match the completion text so far.

=cut

        return sort
          map { substr $_, 2 + $prefix } grep /^_<\Q$text/, (keys %main::),
          $0;
    } ## end if ($line =~ /^\|*f\s+(.*)/)

=head3 Subroutine name completion

We look through all of the defined subs (the keys of C<%sub>) and
return both all the possible matches to the subroutine name plus
all the matches qualified to the current package.

=cut

    if ((substr $text, 0, 1) eq '&') {    # subroutines
        $text = substr $text, 1;
        $prefix = "&";
        return sort map "$prefix$_", grep /^\Q$text/, (keys %sub),
          (
            map { /$search/ ? ($1) : () }
              keys %sub
              );
    } ## end if ((substr $text, 0, ...

=head3  Scalar, array, and hash completion: partially qualified package

Much like the above, except we have to do a little more cleanup:

=cut

    if ($text =~ /^[\$@@%](.*)::(.*)/) {    # symbols in a package

=pod

=over 4 

=item * Determine the package that the symbol is in. Put it in C<::> (effectively C<main::>) if no package is specified.

=cut

        $pack = ($1 eq 'main' ? '' : $1) . '::';

=pod

=item * Figure out the prefix vs. what needs completing.

=cut

        $prefix = (substr $text, 0, 1) . $1 . '::';
        $text = $2;

=pod

=item * Look through all the symbols in the package. C<grep> out all the possible hashes/arrays/scalars, and then C<grep> the possible matches out of those. C<map> the prefix onto all the possibilities.

=cut

        my @@out = map "$prefix$_", grep /^\Q$text/, grep /^_?[a-zA-Z]/,
          keys %$pack;

=pod

=item * If there's only one hit, and it's a package qualifier, and it's not equal to the initial text, re-complete it using the symbol we actually found.

=cut

        if (@@out == 1 and $out[0] =~ /::$/ and $out[0] ne $itext) {
            return db_complete($out[0], $line, $start);
        }

        # Return the list of possibles.
        return sort @@out;

    } ## end if ($text =~ /^[\$@@%](.*)::(.*)/)

=pod

=back

=head3 Symbol completion: current package or package C<main>.

=cut


    if ($text =~ /^[\$@@%]/) {    # symbols (in $package + packages in main)

=pod

=over 4

=item * If it's C<main>, delete main to just get C<::> leading.

=cut

        $pack = ($package eq 'main' ? '' : $package) . '::';

=pod

=item * We set the prefix to the item's sigil, and trim off the sigil to get the text to be completed.

=cut

        $prefix = substr $text, 0, 1;
        $text = substr $text, 1;

=pod

=item * If the package is C<::> (C<main>), create an empty list; if it's something else, create a list of all the packages known.  Append whichever list to a list of all the possible symbols in the current package. C<grep> out the matches to the text entered so far, then C<map> the prefix back onto the symbols.

=cut

        my @@out = map "$prefix$_", grep /^\Q$text/,
          (grep /^_?[a-zA-Z]/, keys %$pack),
          ($pack eq '::' ? () : (grep /::$/, keys %::));

=item * If there's only one hit, it's a package qualifier, and it's not equal to the initial text, recomplete using this symbol.

=back

=cut

        if (@@out == 1 and $out[0] =~ /::$/ and $out[0] ne $itext) {
            return db_complete($out[0], $line, $start);
        }

        # Return the list of possibles.
        return sort @@out;
    } ## end if ($text =~ /^[\$@@%]/)

=head3 Options 

We use C<option_val()> to look up the current value of the option. If there's
only a single value, we complete the command in such a way that it is a 
complete command for setting the option in question. If there are multiple
possible values, we generate a command consisting of the option plus a trailing
question mark, which, if executed, will list the current value of the option.

=cut

    my $cmd = ($CommandSet eq '580') ? 'o' : 'O';
    if ((substr $line, 0, $start) =~ /^\|*$cmd\b.*\s$/) { # Options after space
        # We look for the text to be matched in the list of possible options, 
        # and fetch the current value. 
        my @@out = grep /^\Q$text/, @@options;
        my $val = option_val($out[0], undef);

        # Set up a 'query option's value' command.
        my $out = '? ';
        if (not defined $val or $val =~ /[\n\r]/) {
           # There's really nothing else we can do.
        }

        # We have a value. Create a proper option-setting command.
        elsif ($val =~ /\s/) {
            # XXX This may be an extraneous variable.
            my $found;

            # We'll want to quote the string (because of the embedded
            # whtespace), but we want to make sure we don't end up with
            # mismatched quote characters. We try several possibilities.
            foreach $l (split //, qq/\"\'\#\|/) {
                # If we didn't find this quote character in the value,
                # quote it using this quote character.
                $out = "$l$val$l ", last if (index $val, $l) == -1;
            }
        } ## end elsif ($val =~ /\s/)

        # Don't need any quotes.
        else {
            $out = "=$val ";
        }

        # If there were multiple possible values, return '? ', which
        # makes the command into a query command. If there was just one,
        # have readline append that.
        $rl_attribs->{completer_terminator_character} =
          (@@out == 1 ? $out : '? ');

        # Return list of possibilities.
        return sort @@out;
    } ## end if ((substr $line, 0, ...

=head3 Filename completion

For entering filenames. We simply call C<readline>'s C<filename_list()>
method with the completion text to get the possible completions.

=cut

    return $term->filename_list($text);    # filenames

} ## end sub db_complete

=head1 MISCELLANEOUS SUPPORT FUNCTIONS

Functions that possibly ought to be somewhere else.

=head2 end_report

Say we're done.

=cut
d3445 2
a3446 2
    local $\ = '';
    print $OUT "Use `q' to quit or `R' to restart.  `h q' for details.\n";
a3448 7
=head2 clean_ENV

If we have $ini_pids, save it in the environment; else remove it from the
environment. Used by the C<R> (restart) command.

=cut

d3452 1
a3452 2
    }
    else {
d3455 1
a3455 23
} ## end sub clean_ENV

=head1 END PROCESSING - THE C<END> BLOCK

Come here at the very end of processing. We want to go into a 
loop where we allow the user to enter commands and interact with the 
debugger, but we don't want anything else to execute. 

First we set the C<$finished> variable, so that some commands that
shouldn't be run after the end of program quit working.

We then figure out whether we're truly done (as in the user entered a C<q>
command, or we finished execution while running nonstop). If we aren't,
we set C<$single> to 1 (causing the debugger to get control again).

We then call C<DB::fake::at_exit()>, which returns the C<Use 'q' to quit ...">
message and returns control to the debugger. Repeat.

When the user finally enters a C<q> command, C<$fall_off_end> is set to
1 and the C<END> block simply exits with C<$single> set to 0 (don't 
break, run to completion.).

=cut
d3458 6
a3463 2
    $finished = 1 if $inhibit_exit;    # So that some commands may be disabled.
    $fall_off_end = 1 unless $inhibit_exit;
a3464 4
    # Do not stop in at_exit() and destructors on exit:
    $DB::single = !$fall_off_end && !$runnonstop;
    DB::fake::at_exit() unless $fall_off_end or $runnonstop;
} ## end END
d3466 3
a3468 15
=head1 PRE-5.8 COMMANDS

Some of the commands changed function quite a bit in the 5.8 command 
realignment, so much so that the old code had to be replaced completely.
Because we wanted to retain the option of being able to go back to the
former command set, we moved the old code off to this section.

There's an awful lot of duplicated code here. We've duplicated the 
comments to keep things clear.

=head2 Null command

Does nothing. Used to 'turn off' commands.

=cut
d3471 1
a3471 2

    # do nothing...
a3473 7
=head2 Old C<a> command.

This version added actions if you supplied them, and deleted them
if you didn't.

=cut

d3475 17
a3491 45
    my $xcmd = shift;
    my $cmd  = shift;

    # Argument supplied. Add the action.
    if ($cmd =~ /^(\d*)\s*(.*)/) {

        # If the line isn't there, use the current line.
        $i = $1 || $line;
        $j = $2;

        # If there is an action ...
        if (length $j) {

            # ... but the line isn't breakable, skip it.
            if ($dbline[$i] == 0) {
                print $OUT "Line $i may not have an action.\n";
            }
            else {
                # ... and the line is breakable:
                # Mark that there's an action in this file.
                $had_breakpoints{$filename} |= 2;

                # Delete any current action.
                $dbline{$i} =~ s/\0[^\0]*//;

                # Add the new action, continuing the line as needed.
                $dbline{$i} .= "\0" . action($j);
            }
        } ## end if (length $j)

        # No action supplied.
        else {
            # Delete the action.
            $dbline{$i} =~ s/\0[^\0]*//;
            # Mark as having no break or action if nothing's left.
            delete $dbline{$i} if $dbline{$i} eq '';
        }
    } ## end if ($cmd =~ /^(\d*)\s*(.*)/)
} ## end sub cmd_pre580_a

=head2 Old C<b> command 

Add breakpoints.

=cut
d3494 23
a3516 56
    my $xcmd    = shift;
    my $cmd     = shift;
    my $dbline = shift;

    # Break on load.
    if ($cmd =~ /^load\b\s*(.*)/) {
        my $file = $1;
        $file =~ s/\s+$//;
        &cmd_b_load($file);
    }

    # b compile|postpone <some sub> [<condition>]
    # The interpreter actually traps this one for us; we just put the 
    # necessary condition in the %postponed hash.
    elsif ($cmd =~ /^(postpone|compile)\b\s*([':A-Za-z_][':\w]*)\s*(.*)/) {
        # Capture the condition if there is one. Make it true if none.
        my $cond = length $3 ? $3 : '1';

        # Save the sub name and set $break to 1 if $1 was 'postpone', 0
        # if it was 'compile'.
        my ($subname, $break) = ($2, $1 eq 'postpone');

        # De-Perl4-ify the name - ' separators to ::.
        $subname =~ s/\'/::/g;

        # Qualify it into the current package unless it's already qualified.
        $subname = "${'package'}::" . $subname
          unless $subname =~ /::/;

        # Add main if it starts with ::.
        $subname = "main" . $subname if substr($subname, 0, 2) eq "::";

        # Save the break type for this sub.
        $postponed{$subname} = $break ? "break +0 if $cond" : "compile";
    } ## end elsif ($cmd =~ ...

    # b <sub name> [<condition>]
    elsif ($cmd =~ /^([':A-Za-z_][':\w]*(?:\[.*\])?)\s*(.*)/) {
        my $subname = $1;
        my $cond = length $2 ? $2 : '1';
        &cmd_b_sub($subname, $cond);
    }

    # b <line> [<condition>].
    elsif ($cmd =~ /^(\d*)\s*(.*)/) {
        my $i = $1 || $dbline;
        my $cond = length $2 ? $2 : '1';
        &cmd_b_line($i, $cond);
    }
} ## end sub cmd_pre580_b

=head2 Old C<D> command.

Delete all breakpoints unconditionally.

=cut
d3519 27
a3545 50
    my $xcmd = shift;
    my $cmd  = shift;
    if ($cmd =~ /^\s*$/) {
        print $OUT "Deleting all breakpoints...\n";

        # %had_breakpoints lists every file that had at least one
        # breakpoint in it.
        my $file;
        for $file (keys %had_breakpoints) {
            # Switch to the desired file temporarily.
            local *dbline = $main::{ '_<' . $file };

            my $max = $#dbline;
            my $was;

            # For all lines in this file ...
            for ($i = 1 ; $i <= $max ; $i++) {
                # If there's a breakpoint or action on this line ...
                if (defined $dbline{$i}) {
                    # ... remove the breakpoint.
                    $dbline{$i} =~ s/^[^\0]+//;
                    if ($dbline{$i} =~ s/^\0?$//) {
                        # Remove the entry altogether if no action is there.
                        delete $dbline{$i};
                    }
                } ## end if (defined $dbline{$i...
            } ## end for ($i = 1 ; $i <= $max...

            # If, after we turn off the "there were breakpoints in this file"
            # bit, the entry in %had_breakpoints for this file is zero, 
            # we should remove this file from the hash.
            if (not $had_breakpoints{$file} &= ~1) {
                delete $had_breakpoints{$file};
            }
        } ## end for $file (keys %had_breakpoints)

        # Kill off all the other breakpoints that are waiting for files that
        # haven't been loaded yet.
        undef %postponed;
        undef %postponed_file;
        undef %break_on_load;
    } ## end if ($cmd =~ /^\s*$/)
} ## end sub cmd_pre580_D

=head2 Old C<h> command

Print help. Defaults to printing the long-form help; the 5.8 version 
prints the summary by default.

=cut
d3548 18
a3565 52
    my $xcmd = shift;
    my $cmd  = shift;

    # Print the *right* help, long format.
    if ($cmd =~ /^\s*$/) {
        print_help($pre580_help);
    }

    # 'h h' - explicitly-requested summary. 
    elsif ($cmd =~ /^h\s*/) {
        print_help($pre580_summary);
    }

    # Find and print a command's help.
    elsif ($cmd =~ /^h\s+(\S.*)$/) {
        my $asked  = $1;                   # for proper errmsg
        my $qasked = quotemeta($asked);    # for searching
                                           # XXX: finds CR but not <CR>
        if ($pre580_help =~ /^
                              <?           # Optional '<'
                              (?:[IB]<)    # Optional markup
                              $qasked      # The command name
                            /mx) {

            while (
                $pre580_help =~ /^
                                  (             # The command help:
                                   <?           # Optional '<'
                                   (?:[IB]<)    # Optional markup
                                   $qasked      # The command name
                                   ([\s\S]*?)   # Lines starting with tabs
                                   \n           # Final newline
                                  )
                                  (?!\s)/mgx)   # Line not starting with space
                                                # (Next command's help)
            {
                print_help($1);
            }
        } ## end if ($pre580_help =~ /^<?(?:[IB]<)$qasked/m)

        # Help not found.
        else {
            print_help("B<$asked> is not a debugger command.\n");
        }
    } ## end elsif ($cmd =~ /^h\s+(\S.*)$/)
} ## end sub cmd_pre580_h

=head2 Old C<W> command

C<W E<lt>exprE<gt>> adds a watch expression, C<W> deletes them all.

=cut
d3568 13
a3580 159
    my $xcmd = shift;
    my $cmd  = shift;

    # Delete all watch expressions.
    if ($cmd =~ /^$/) {
        # No watching is going on.
        $trace &= ~2;
        # Kill all the watch expressions and values.
        @@to_watch = @@old_watch = ();
    }

    # Add a watch expression.
    elsif ($cmd =~ /^(.*)/s) {
        # add it to the list to be watched.
        push @@to_watch, $1;

        # Get the current value of the expression. 
        # Doesn't handle expressions returning list values!
        $evalarg = $1;
        my ($val) = &eval;
        $val = (defined $val) ? "'$val'" : 'undef';

        # Save it.
        push @@old_watch, $val;

        # We're watching stuff.
        $trace |= 2;

    } ## end elsif ($cmd =~ /^(.*)/s)
} ## end sub cmd_pre580_W

=head1 PRE-AND-POST-PROMPT COMMANDS AND ACTIONS

The debugger used to have a bunch of nearly-identical code to handle 
the pre-and-post-prompt action commands. C<cmd_pre590_prepost> and
C<cmd_prepost> unify all this into one set of code to handle the 
appropriate actions.

=head2 C<cmd_pre590_prepost>

A small wrapper around C<cmd_prepost>; it makes sure that the default doesn't
do something destructive. In pre 5.8 debuggers, the default action was to
delete all the actions.

=cut

sub cmd_pre590_prepost {
    my $cmd    = shift;
    my $line   = shift || '*';
    my $dbline = shift;

    return &cmd_prepost( $cmd, $line, $dbline );
} ## end sub cmd_pre590_prepost

=head2 C<cmd_prepost>

Actually does all the handling foe C<E<lt>>, C<E<gt>>, C<{{>, C<{>, etc.
Since the lists of actions are all held in arrays that are pointed to by
references anyway, all we have to do is pick the right array reference and
then use generic code to all, delete, or list actions.

=cut

sub cmd_prepost { my $cmd = shift;

    # No action supplied defaults to 'list'.
    my $line = shift || '?';

    # Figure out what to put in the prompt.
    my $which = '';

    # Make sure we have some array or another to address later.
    # This means that if ssome reason the tests fail, we won't be
    # trying to stash actions or delete them from the wrong place.
    my $aref  = [];

   # < - Perl code to run before prompt.
    if ( $cmd =~ /^\</o ) {
        $which = 'pre-perl';
        $aref  = $pre;
    }

    # > - Perl code to run after prompt.
    elsif ( $cmd =~ /^\>/o ) {
        $which = 'post-perl';
        $aref  = $post;
    }

    # { - first check for properly-balanced braces.
    elsif ( $cmd =~ /^\{/o ) {
        if ( $cmd =~ /^\{.*\}$/o && unbalanced( substr( $cmd, 1 ) ) ) {
            print $OUT
"$cmd is now a debugger command\nuse `;$cmd' if you mean Perl code\n";
        }

        # Properly balanced. Pre-prompt debugger actions.
        else {
            $which = 'pre-debugger';
            $aref  = $pretype;
        }
    } ## end elsif ( $cmd =~ /^\{/o )

    # Did we find something that makes sense?
    unless ($which) {
        print $OUT "Confused by command: $cmd\n";
    }

    # Yes. 
    else {
        # List actions.
        if ( $line =~ /^\s*\?\s*$/o ) {
            unless (@@$aref) {
                # Nothing there. Complain.
                print $OUT "No $which actions.\n";
            }
            else {
                # List the actions in the selected list.
                print $OUT "$which commands:\n";
                foreach my $action (@@$aref) {
                    print $OUT "\t$cmd -- $action\n";
                }
            } ## end else
        } ## end if ( $line =~ /^\s*\?\s*$/o)

        # Might be a delete.
        else {
            if ( length($cmd) == 1 ) {
                if ( $line =~ /^\s*\*\s*$/o ) {
                    # It's a delete. Get rid of the old actions in the 
                    # selected list..
                    @@$aref = ();
                    print $OUT "All $cmd actions cleared.\n";
                }
                else {
                    # Replace all the actions. (This is a <, >, or {).
                    @@$aref = action($line);
                }
            } ## end if ( length($cmd) == 1)
            elsif ( length($cmd) == 2 ) { 
                # Add the action to the line. (This is a <<, >>, or {{).
                push @@$aref, action($line);
            }
            else {
                # <<<, >>>>, {{{{{{ ... something not a command.
                print $OUT
                  "Confused by strange length of $which command($cmd)...\n";
            }
        } ## end else [ if ( $line =~ /^\s*\?\s*$/o)
    } ## end else
} ## end sub cmd_prepost


=head1 C<DB::fake>

Contains the C<at_exit> routine that the debugger uses to issue the
C<Debugged program terminated ...> message after the program completes. See
the C<END> block documentation for more details.

=cut
d3585 1
a3585 1
    "Debugged program terminated.  Use `q' to quit or `R' to restart.";
d3588 1
a3588 1
package DB;    # Do not trace this 1; below!
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d495 1
a495 2
$VERSION = 1.23;

a901 2
# Changes: 1.23: Dec 21, 2003 Dominique Quatravaux
#   + Fix a side-effect of bug #24674 in the perl debugger ("odd taint bug")
a1346 3
# untaint $^O, which may have been tainted by the last statement.
# see bug [perl #24674]
$^O =~ m/^(.*)\z/; $^O = $1;
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@a0 1

d192 1
a192 1
contents as the argument of a debugger <C<o> command.
d495 1
a495 1
$VERSION = 1.27;
d497 1
a497 1
$header = "perl5db.pl version $VERSION";
d599 1
a599 1
    #    but so does local! --tchrist
d603 3
a605 4

        # Try to keep the user code from messing  with us. Save these so that
        # even if the eval'ed code changes them, we can put them back again.
        # Needed because the user could refer directly to the debugger's
d608 1
a608 1
        local $otrace  = $trace;
d615 1
a615 1
        # $usercontext built in DB::DB near the comment
d618 2
a619 1
        @@res = eval "$usercontext $evalarg;\n";  # '\n' for nice recursive debug
d633 1
a633 1
    local $saved[0];    # Preserve the old value of $@@
d645 1
a645 1
        if ( $onetimeDump eq 'dump' ) {
d648 1
a648 1
            dumpit( $OUT, \@@res );
d650 2
a651 2
        elsif ( $onetimeDump eq 'methods' ) {
            methods( $res[0] );
d660 1
a660 1
# The code being debugged will be executing in its own context, and
d663 1
a663 1
# However, one should not overdo it: leave as much control from outside as
d670 1
a670 1
# Before venturing further into these twisty passages, it is
d674 1
a674 1
# the underlying mechanics of how the debugger interfaces into the
d682 1
a682 7
# $Log: perl5db.pl,v $
# Revision 1.8  2004/04/07 21:33:04  millert
# merge local changes into perl-5.8.3
#
# Revision 1.7  2003/12/03 03:02:36  millert
# Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
#
d711 1
a711 1
# Changes: 0.96
d728 1
a728 1
#   + Buglet: When restarting debugger only one breakpoint/action per
d761 2
a762 2
#     to restore Larry's original formatting.
#   + Fixed many other formatting errors.  The code is still suboptimal,
d766 1
a766 1
#     shows "1".
d809 1
a809 1
#                         1: on fork()
d837 1
a837 1
#                                           # to $from, and may be less than
d841 1
a841 1
#                                           # Set breakpoint,$cond defaults to
d865 1
a865 1
#   + Added windowSize option
d880 2
a881 2
#   rationalised the following commands and added cmd_wrapper() to
#   enable switching between old and frighteningly consistent new
d885 1
a885 1
#   + w(add),       W(del)            # watch  expr   (was W,W)
d905 1
a905 16
# Changes: 1.24: Mar 03, 2004 Richard Foley <richard.foley@@rfi.net>
#   + Added command to save all debugger commands for sourcing later.
#   + Added command to display parent inheritence tree of given class.
#   + Fixed minor newline in history bug.
# Changes: 1.25: Apr 17, 2004 Richard Foley <richard.foley@@rfi.net>
#   + Fixed option bug (setting invalid options + not recognising valid short forms)
# Changes: 1.26: Apr 22, 2004 Richard Foley <richard.foley@@rfi.net>
#   + unfork the 5.8.x and 5.9.x debuggers.
#   + whitespace and assertions call cleanup across versions 
#   + H * deletes (resets) history
#   + i now handles Class + blessed objects
# Changes: 1.27: May 09, 2004 Richard Foley <richard.foley@@rfi.net>
#   + updated pod page references - clunky.
#   + removed windowid restriction for forking into an xterm.
#   + more whitespace again.
#   + wrapped restart and enabled rerun [-n] (go back n steps) command.
a931 9
# test if assertions are supported and actived:
BEGIN {
    $ini_assertion = eval "sub asserting_test : assertion {1}; 1";

    # $ini_assertion = undef => assertions unsupported,
    #        "       = 1     => assertions supported
    # print "\$ini_assertion=$ini_assertion\n";
}

d939 1
a939 1
                    # These variables control the execution of 'dumpvar.pl'.
d975 2
a976 2
$trace = $signal = $single = 0;    # Uninitialized warning suppression
                                   # (local $^W cannot help - other packages!).
d996 14
a1009 17
  CommandSet
  hashDepth    arrayDepth    dumpDepth
  DumpDBFiles  DumpPackages  DumpReused
  compactDump  veryCompact   quote
  HighBit      undefPrint    globPrint
  PrintRet     UsageOnly     frame
  AutoTrace    TTY           noTTY
  ReadLine     NonStop       LineInfo
  maxTraceLen  recallCommand ShellBang
  pager        tkRunning     ornaments
  signalLevel  warnLevel     dieLevel
  inhibit_exit ImmediateStop bareStringify
  CreateTTY    RemotePort    windowSize
  DollarCaretP OnlyAssertions WarnAssertions
);

@@RememberOnROptions = qw(DollarCaretP OnlyAssertions);
d1038 1
a1038 2
    WarnAssertions => \$warnassertions,
);
d1065 1
a1065 3
    DollarCaretP  => \&DollarCaretP,
    OnlyAssertions=> \&OnlyAssertions,
);
d1083 1
a1083 1
);
a1146 1

d1148 2
a1149 2
    defined $ENV{PAGER}
    ? $ENV{PAGER}
d1152 2
a1153 3
    : eval { require Config }
      && defined $Config::Config{pager}
    ? $Config::Config{pager}
d1156 1
a1156 1
    : 'more'
d1210 1
a1210 1
# Save the current contents of the environment; we're about to
d1214 1
a1214 2
if ( defined $ENV{PERLDB_PIDS} ) {

d1216 1
a1216 1
    # recorded in PERLDB_PIDS plus our (new) PID. Mark us as not having
d1223 1
a1223 2

    # We're the parent PID. Initialize PERLDB_PID in case we end up with a
d1227 2
a1228 2
    $pids             = "{pid=$$}";
    $term_pid         = $$;
d1234 1
a1234 1
*emacs = $slave_editor if $slave_editor;    # May be used in afterinit()...
d1245 1
a1245 2

if ( -e "/dev/tty" ) {                      # this is the wrong metric!
d1273 1
a1273 1
    unless ( is_safe_file($file) ) {
d1292 1
a1292 1
# eventually accessed is the same as the one tested.
d1297 1
a1297 1
    my ( $dev, $ino, $mode, $nlink, $uid, $gid ) = stat(_);
d1305 2
a1306 2
# exists, we safely do it.
if ( -f $rcfile ) {
a1308 1

d1310 1
a1310 1
elsif ( defined $ENV{HOME} && -f "$ENV{HOME}/$rcfile" ) {
a1312 1

d1314 1
a1314 1
elsif ( defined $ENV{LOGDIR} && -f "$ENV{LOGDIR}/$rcfile" ) {
d1319 2
a1320 2
if ( defined $ENV{PERLDB_OPTS} ) {
    parse_options( $ENV{PERLDB_OPTS} );
d1334 1
a1334 1
# OS X Terminal windows.
d1336 8
a1343 8
if (
    not defined &get_fork_TTY    # no routine exists,
    and defined $ENV{TERM}       # and we know what kind
                                 # of terminal this is,
    and $ENV{TERM} eq 'xterm'    # and it's an xterm,
#   and defined $ENV{WINDOWID}   # and we know what window this is, <- wrong metric
    and defined $ENV{DISPLAY}    # and what display it's on,
  )
d1345 1
a1345 1
    *get_fork_TTY = \&xterm_get_fork_TTY;    # use the xterm version
d1347 2
a1348 2
elsif ( $^O eq 'os2' ) {                     # If this is OS/2,
    *get_fork_TTY = \&os2_get_fork_TTY;      # use the OS/2 version
a1349 1

d1352 1
a1352 2
$^O =~ m/^(.*)\z/;
$^O = $1;
d1354 1
a1354 1
# Here begin the unreadable code.  It needs fixing.
d1382 1
a1382 2
if ( exists $ENV{PERLDB_RESTART} ) {

a1384 1

d1392 1
a1392 1
    for ( 0 .. $#had_breakpoints ) {
d1399 2
a1400 2
    my ( $opt, $val );
    while ( ( $opt, $val ) = each %opt ) {
d1406 2
a1407 2
    @@INC     = get_list("PERLDB_INC");
    @@ini_INC = @@INC;
d1410 4
a1413 4
    $pretype   = [ get_list("PERLDB_PRETYPE") ];
    $pre       = [ get_list("PERLDB_PRE") ];
    $post      = [ get_list("PERLDB_POST") ];
    @@typeahead = get_list( "PERLDB_TYPEAHEAD", @@typeahead );
a1437 1

d1441 2
a1442 3
      ( ( defined $main::ARGV[0] ) and ( $main::ARGV[0] eq '-emacs' ) );
    $rl = 0, shift(@@main::ARGV) if $slave_editor;

a1454 1
    if ( $^O eq 'cygwin' ) {
d1456 1
d1465 1
a1465 1
    elsif ( -e "/dev/tty" ) {
d1473 1
a1473 1
    elsif ( $^O eq 'dos' or -e "con" or $^O eq 'MSWin32' ) {
d1482 2
a1483 2
    elsif ( $^O eq 'MacOS' ) {
        if ( $MacPerl::Version !~ /MPW/ ) {
a1496 1

d1511 1
a1511 2
    if ( ( $^O eq 'MSWin32' ) and ( $slave_editor or defined $ENV{EMACS} ) ) {

d1516 1
a1516 2
    if ( $^O eq 'NetWare' ) {

d1523 1
a1523 1
    if ( defined $ENV{OS2_SHELL} and ( $slave_editor or $ENV{WINDOWID} ) )
a1526 1

d1528 1
a1528 1
    if ( $^O eq 'epoc' ) {
d1552 1
a1552 3

    if ( defined $remoteport ) {

d1560 2
a1561 2
        );
        if ( !$OUT ) { die "Unable to connect to remote host: $remoteport\n"; }
a1576 1

d1579 1
a1579 1
        # filehandle, and do the necessary mojo to create a new tty if we
a1582 1

d1585 1
a1585 2

            my ( $i, $o ) = split /,/, $console;
d1589 3
a1591 3
            open( IN,      "+<$i" )
              || open( IN, "<$i" )
              || open( IN, "<&STDIN" );
d1595 4
a1598 4
                 open( OUT, "+>$o" )
              || open( OUT, ">$o" )
              || open( OUT, ">&STDERR" )
              || open( OUT, ">&STDOUT" );    # so we don't dongle stdout
d1601 7
a1607 1
        elsif ( not defined $console ) {
a1608 6
            # No console. Open STDIN.
            open( IN, "<&STDIN" );

            # merge with STDERR, or with STDOUT.
            open( OUT,      ">&STDERR" )
              || open( OUT, ">&STDOUT" );    # so we don't dongle stdout
d1617 1
a1617 1
    # Unbuffer DB::OUT. We need to see responses right away.
d1619 1
a1619 1
    $| = 1;                                  # for DB::OUT
d1624 1
a1624 1
    # keep track of file and position. We have both a filehandle
d1641 1
a1641 1
        if ( $term_pid eq '-1' ) {
d1649 1
a1649 1
            );
d1662 2
a1663 2
    # s/\'/\\\'/g;                      # removed while not justified understandably
    # s/(.*)/'$1'/ unless /^-?[\d.]+$/; # ditto
d1666 1
a1666 1
# If there was an afterinit() sub defined, call it. It will get
d1668 1
a1668 1
if ( defined &afterinit ) {    # May be defined in $rcfile
a1670 1

d1697 1
a1697 2
    if ( $single and not $second_time++ ) {

d1700 4
a1703 4
                # If there's any call stack in place, turn off single
                # stepping into subs throughout the stack.
            for ( $i = 0 ; $i <= $stack_depth ; ) {
                $stack[ $i++ ] &= ~1;
a1704 1

d1710 1
a1710 1
            # return;
d1714 4
a1717 5

            # We are supposed to stop here; XXX probably a break.
            $ImmediateStop = 0;    # We've processed it; turn it off
            $signal        = 1;    # Simulate an interrupt to force
                                   # us into the command loop
d1731 1
a1731 1
    # caller is returning all the extra information when called from the
d1733 1
a1733 1
    local ( $package, $filename, $line ) = caller;
d1739 3
a1741 2
    local $usercontext =
      '($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;' . "package $package;";
d1749 1
a1749 1
    if ( $^O eq 'MacOS' && $#dbline < 0 ) {
d1758 1
a1758 4
    if ( $dbline{$line}
        && ( ( $stop, $action ) = split( /\0/, $dbline{$line} ) ) )
    {

d1760 1
a1760 1
        if ( $stop eq '1' ) {
a1762 1

d1777 2
a1778 2
    if ( $trace & 2 ) {
        for ( my $n = 0 ; $n <= $#to_watch ; $n++ ) {
d1784 3
a1786 2
            my ($val) = join( "', '", &eval );
            $val = ( ( defined $val ) ? "'$val'" : 'undef' );
d1789 1
a1789 2
            if ( $val ne $old_watch[$n] ) {

d1794 2
a1795 2
    old value:\t$old_watch[$n]
    new value:\t$val
d1833 1
a1833 1
    # If there's a user-defined DB::watchfunction, call it with the
d1836 1
a1836 1
    if ( $trace & 4 ) {    # User-installed watch
d1838 1
a1838 1
          if watchfunction( $package, $filename, $line )
d1841 1
a1841 1
          and not( $trace & ~4 );
d1844 2
a1845 1
    # Pick up any alteration to $signal in the watchfunction, and
d1861 1
a1861 2
    if ( $single || ( $trace & 1 ) || $was_signal ) {

a1863 1

d1877 1
a1877 2
        elsif ( $package eq 'DB::fake' ) {

d1889 2
a1890 2
                '($@@, $!, $^E, $,, $/, $\, $^W) = @@saved;'
              . "package $package;";    # this won't let them modify, alas
a1901 1

d1905 1
a1905 1
                                 # Perl 5 ones (sorry, we don't print Klingon
d1910 1
a1910 1
            $after = ( $dbline[$line] =~ /\n$/ ? '' : "\n" );
d1913 1
a1913 1
            if ( length($prefix) > 30 ) {
d1925 2
a1926 2
                print_lineinfo( ' ' x $stack_depth,
                    "$line:\t$dbline[$line]$after" );
d1934 1
a1934 1
            for ( $i = $line + 1 ; $i <= $max && $dbline[$i] == 0 ; ++$i )
d1942 1
a1942 1

d1945 1
a1945 1
                $after = ( $dbline[$i] =~ /\n$/ ? '' : "\n" );
a1950 1

d1952 2
a1953 2
                    print_lineinfo( ' ' x $stack_depth,
                        "$i:\t$dbline[$i]$after" );
d1974 1
a1974 2
    if ( $single || $was_signal ) {

d1989 2
a1990 2
        $start = $line;
        $incr  = -1;      # for backward motion.
d1993 1
a1993 1
        @@typeahead = ( @@$pretype, @@typeahead );
a2041 1

d2043 1
a2043 2
            ( $term || &setterm ),

d2045 1
a2045 2
            ( $term_pid == $$ or resetterm(1) ),

d2049 2
a2050 4
                        "$pidprompt  DB"
                      . ( '<' x $level )
                      . ( $#hist + 1 )
                      . ( '>' x $level ) . " "
a2054 1

d2081 7
a2087 8
            $cmd =~ /^$/ && ( $cmd = $laststep );
            chomp($cmd);    # get rid of the annoying extra newline
            push( @@hist, $cmd ) if length($cmd) > 1;
            push( @@truehist, $cmd );

            # This is a restart point for commands that didn't arrive
            # via direct user input. It allows us to 'redo PIPE' to
            # re-execute command processing without reading a new command.
d2091 1
a2091 1
                ($i) = split( /\s+/, $cmd );
d2103 1
a2103 2
                if ( $alias{$i} ) {

d2149 2
a2150 2
                    print $OUT "Trace = "
                      . ( ( $trace & 1 ) ? "on" : "off" ) . "\n";
d2162 1
a2162 1
                    $Srev     = defined $2;     # Reverse scan?
d2174 2
a2175 2
                    foreach $subname ( sort( keys %sub ) ) {
                        if ( $Snocheck or $Srev ^ ( $subname =~ /$Spatt/ ) ) {
d2203 1
a2205 1

d2213 1
a2213 1
                    @@vars     = split( ' ', $2 );
d2217 1
a2217 2
                    if ( defined &main::dumpvar ) {

d2230 1
a2230 1
                                : -1,    # assume -1 unless specified
d2232 1
a2232 1
                            );
d2235 1
a2235 1
                        # The die doesn't need to include the $@@, because
a2241 1

a2244 1

d2257 2
a2258 2
                $cmd =~ s/^x\b/ / && do {    # Remainder gets done by DB::eval()
                    $onetimeDump = 'dump';    # main::dumpvar shows the output
d2262 1
a2262 1
                    if ( $cmd =~ s/^\s*(\d+)(?=\s)/ / ) {
d2279 2
a2280 2
                $cmd =~ s/^m\b/ / && do {    # Rest gets done by DB::eval()
                    $onetimeDump = 'methods';   #  method output gets used there
d2292 1
a2292 1
                    if ( !$file ) {
d2294 1
a2294 1
                          "The old f command is now the r command.\n";    # hint
d2300 2
a2301 2
                    if ( !defined $main::{ '_<' . $file } ) {
                        if ( ($try) = grep( m#^_<.*$file#, keys %main:: ) ) {
d2303 3
a2305 2
                                $try = substr( $try, 2 );
                                print $OUT "Choosing $try matching `$file':\n";
d2312 1
a2312 1
                    if ( !defined $main::{ '_<' . $file } ) {
d2318 1
a2318 1
                    elsif ( $file ne $filename ) {
d2342 1
a2342 1
                    $incr = -1;    # stay at current line
d2347 2
a2348 2
                    *dbline   = $main::{ '_<' . $filename };
                    $max      = $#dbline;
a2365 1

d2369 1
a2369 1
                    $incr  = $window - 1;
d2387 3
a2389 3
                # we send them off to the secondary dispatcher (see below).
                $cmd =~ /^([aAbBhilLMoOPvwW]\b|[<>\{]{1,2})\s*(.*)/so && do {
                    &cmd_wrapper( $1, $2, $line );
d2418 1
a2418 1
                    my @@vars = split( ' ', $2 || '' );
d2421 1
a2421 1
                    my $h = eval { PadWalker::peek_my( ( $1 || 0 ) + 1 ) };
d2430 3
a2432 1
                    dumpvar::dumplex( $_, $h->{$_},
d2434 2
a2435 2
                        @@vars )
                      for sort keys %$h;
d2456 1
a2456 1
                # n - next
a2458 1

d2460 1
a2460 2
                    $single = 2;

a2474 1

a2477 1

d2479 1
a2479 2
                    $single = 1;

a2495 1

d2514 3
a2516 3
                    if ( $subname =~ /\D/ ) {    # subroutine name
                            # Qualify it to the current package unless it's
                            # already qualified.
a2518 1

d2521 1
a2521 1
                        # break up the return value, and assign it in one
d2523 1
a2523 1
                        ( $file, $i ) = ( find_sub($subname) =~ /^(.*):(.*)$/ );
a2529 1

a2533 1

a2535 1

d2555 4
a2558 4
                    # got a request to break at some line somewhere. On
                    # one hand, if there wasn't any real subroutine name
                    # involved, this will be a request to break in the current
                    # file at the specified line, so we have to check to make
a2570 1

d2572 1
a2572 1
                        if ( $dbline[$i] == 0 ) {
a2575 1

d2577 2
a2578 1
                        $dbline{$i} =~ s/($|\0)/;9$1/;  # add one-time-only b.p.
d2582 2
a2583 2
                    for ( $i = 0 ; $i <= $stack_depth ; ) {
                        $stack[ $i++ ] &= ~1;
a2599 1

a2601 1

a2603 1

d2609 197
d2813 1
a2813 1
                    print_trace( $OUT, 1 );    # skip DB
d2823 1
a2823 1
                $cmd =~ /^w\b\s*(.*)/s && do { &cmd_w( 'w', $1 ); next CMD; };
d2831 1
a2831 1
                $cmd =~ /^W\b\s*(.*)/s && do { &cmd_W( 'W', $1 ); next CMD; };
d2842 1
a2842 1
                $cmd =~ /^\/(.*)$/ && do {
d2851 1
a2851 1
                    if ( $inpat ne "" ) {
d2859 1
a2859 2
                        if ( $@@ ne "" ) {

d2861 1
a2861 1
                            # Print the eval error and go back for more
d2870 1
a2870 1
                    $end = $start;
a2904 1

d2906 1
a2906 1
                    print $OUT "/$pat/: not found\n" if ( $start == $end );
d2924 1
a2924 1
                    if ( $inpat ne "" ) {
d2931 1
a2931 2
                        if ( $@@ ne "" ) {

d2940 1
a2940 1
                    $end = $start;
a2952 1

d2975 1
a2975 1
                    print $OUT "?$pat?: not found\n" if ( $start == $end );
d2982 1
a2982 1
that the terminal supports history). It find the command required, puts it
d2987 1
a2987 1
                # $rc - recall command.
d2991 1
a2991 1
                    pop(@@hist) if length($cmd) > 1;
d2993 1
a2993 1
                    # Relative (- found)?
d2995 1
a2995 1
                    #  N - go to that particular command slot or the last
d2997 1
a2997 1
                    $i = $1 ? ( $#hist - ( $2 || 1 ) ) : ( $2 || $#hist );
a3017 1

d3030 1
a3030 1
                # $rc pattern $rc - find a command in the history.
a3031 1

d3036 1
a3036 1
                    pop(@@hist) if length($cmd) > 1;
d3039 1
a3039 2
                    for ( $i = $#hist ; $i ; --$i ) {

d3044 1
a3044 2
                    if ( !$i ) {

a3063 1

d3066 1
a3066 1
                    &system( $ENV{SHELL} || "/bin/sh" );
a3078 1

d3083 1
a3083 1
                    &system( $ENV{SHELL} || "/bin/sh", "-c", $1 );
a3092 6
                $cmd =~ /^H\b\s*\*/ && do {
                    @@hist = @@truehist = ();
                    print $OUT "History cleansed\n";
                    next CMD;
                };

d3094 1
a3094 2

                    # Anything other than negative numbers is ignored by
d3096 1
a3096 1
                    $end = $2 ? ( $#hist - $2 ) : 0;
d3101 1
a3101 1
                    # Start at the end of the array.
d3104 1
a3104 1
                    for ( $i = $#hist ; $i > $end ; $i-- ) {
d3119 1
a3119 1
                # man, perldoc, doc - show manual pages.
d3144 1
a3144 1
                # = - set up a command alias.
d3147 1
a3147 2
                    if ( length $cmd == 0 ) {

d3151 1
a3151 2
                    elsif ( my ( $k, $v ) = ( $cmd =~ /^(\S+)\s+(\S.*)/ ) ) {

d3156 3
a3158 4
                        for my $x ( $k, $v ) {

                            # Escape "alarm" characters.
                            $x =~ s/\a/\\a/g;
d3162 1
a3162 1
                        # as separators (which is why we escaped them in
d3171 1
a3171 2
                        unless ( eval "sub { s\a$k\a$v\a }; 1" ) {

a3176 1

a3187 1

d3191 1
a3191 2
                        if ( ( my $v = $alias{$k} ) =~ ss\a$k\a(.*)\a$1 ) {

d3195 1
a3195 2
                        elsif ( defined $alias{$k} ) {

a3199 1

d3214 1
a3214 1
                # source - read commands from a file (or pipe!) and execute.
d3216 1
a3216 2
                    if ( open my $fh, $1 ) {

d3221 1
a3221 2

                        # Couldn't open it.
a3226 49
=head4 C<save> - send current history to a file

Takes the complete history, (not the shrunken version you see with C<H>),
and saves it to the given filename, so it can be replayed using C<source>.

Note that all C<^(save|source)>'s are commented out with a view to minimise recursion.

=cut

                # save source - write commands to a file for later use
                $cmd =~ /^save\s*(.*)$/ && do {
                    my $file = $1 || '.perl5dbrc';    # default?
                    if ( open my $fh, "> $file" ) {

                       # chomp to remove extraneous newlines from source'd files
                        chomp( my @@truelist =
                              map { m/^\s*(save|source)/ ? "#$_" : $_ }
                              @@truehist );
                        print $fh join( "\n", @@truelist );
                        print "commands saved in $file\n";
                    }
                    else {
                        &warn("Can't save debugger commands in '$1': $!\n");
                    }
                    next CMD;
                };

=head4 C<R> - restart

Restart the debugger session. 

=head4 C<rerun> - rerun the current session

Return to any given position in the B<true>-history list

=cut

                # R - restart execution.
                # rerun - controlled restart execution.
                $cmd =~ /^(R|rerun\s*(.*))$/ && do {
                    my @@args = ($1 eq 'R' ? restart() : rerun($2));

                    # And run Perl again.  We use exec() to keep the
                    # PID stable (and that way $ini_pids is still valid).
                    exec(@@args) || print $OUT "exec failed: $!\n";

                    last CMD;
                };

d3243 1
a3243 2
                    if ( $pager =~ /^\|/ ) {

d3245 4
a3248 4
                        open( SAVEOUT, ">&STDOUT" )
                          || &warn("Can't save STDOUT");
                        open( STDOUT, ">&OUT" )
                          || &warn("Can't redirect STDOUT");
a3250 1

d3252 1
a3252 1
                        open( SAVEOUT, ">&OUT" ) || &warn("Can't save DB::OUT");
d3258 1
a3258 2
                    unless ( $piped = open( OUT, $pager ) ) {

d3261 1
a3261 2
                        if ( $pager =~ /^\|/ ) {

d3263 1
a3263 1
                            open( OUT, ">&STDOUT" )    # XXX: lost message
d3265 2
a3266 2
                            open( STDOUT, ">&SAVEOUT" )
                              || &warn("Can't restore STDOUT");
a3269 1

d3271 1
a3271 1
                            open( OUT, ">&STDOUT" )    # XXX: lost message
d3279 2
a3280 2
                      if $pager =~ /^\|/
                      && ( "" eq $SIG{PIPE} || "DEFAULT" eq $SIG{PIPE} );
d3294 1
d3315 1
a3315 1
            # Make sure the flag that says "the debugger's running" is
d3327 1
a3327 1
            elsif ( $term_pid == $$ ) {
a3329 1

a3346 1

d3348 1
a3348 2
                if ( $pager =~ /^\|/ ) {

d3359 1
a3359 1
                        if ( $? == -1 ) {
d3362 4
a3365 4
                        elsif ( $? >> 8 ) {
                            print SAVEOUT ( $? & 127 )
                              ? " (SIG#" . ( $? & 127 ) . ")"
                              : "", ( $? & 128 ) ? " -- core dumped" : "", "\n";
d3368 1
a3368 1
                            print SAVEOUT "status ", ( $? >> 8 ), "\n";
d3372 1
a3372 1
                    # Reopen filehandle for our output (if we can) and
d3374 3
a3376 3
                    open( OUT, ">&STDOUT" ) || &warn("Can't restore DB::OUT");
                    open( STDOUT, ">&SAVEOUT" )
                      || &warn("Can't restore STDOUT");
a3384 1

d3386 1
a3386 1
                    open( OUT, ">&SAVEOUT" ) || &warn("Can't restore DB::OUT");
d3420 1
a3420 1
    ( $@@, $!, $^E, $,, $/, $\, $^W ) = @@saved;
d3512 1
a3512 1
    my ( $al, $ret, @@ret ) = "";
d3516 1
a3516 1
    if ( length($sub) > 10 && substr( $sub, -10, 10 ) eq '::AUTOLOAD' ) {
d3532 1
a3532 1
    # Turn off all flags except single-stepping.
d3543 1
a3543 1
            print_lineinfo( ' ' x ( $stack_depth - 1 ), "in  " ),
d3549 1
a3549 1
            print_trace( $LINEINFO, -1, 1, 1, "$sub$al" )
d3551 1
a3551 2
        : print_lineinfo( ' ' x ( $stack_depth - 1 ), "entering $sub$al\n" )

a3557 1

d3561 1
a3561 11
        if ($assertion) {
            $assertion = 0;
            eval { @@ret = &$sub; };
            if ($@@) {
                print $OUT $@@;
                $signal = 1 unless $warnassertions;
            }
        }
        else {
            @@ret = &$sub;
        }
d3564 1
a3564 1
        $single |= $stack[ $stack_depth-- ];
d3568 1
a3568 1
            $frame & 4    # Extended exit message
d3570 2
a3571 2
                print_lineinfo( ' ' x $stack_depth, "out " ),
                print_trace( $LINEINFO, -1, 1, 1, "$sub$al" )
d3573 1
a3573 2
            : print_lineinfo( ' ' x $stack_depth, "exited $sub$al\n" )

d3579 1
a3579 2
        if ( $doret eq $stack_depth or $frame & 16 ) {

d3582 1
a3582 1
            my $fh = ( $doret eq $stack_depth ? $OUT : $LINEINFO );
d3589 1
a3589 1
            dumpit( $fh, \@@ret );
d3594 1
a3594 1
            # And we have to return the return value now.
d3596 1
d3601 3
a3603 12
        if ($assertion) {
            $assertion = 0;
            eval {

                # Save the value if it's wanted at all.
                $ret = &$sub;
            };
            if ($@@) {
                print $OUT $@@;
                $signal = 1 unless $warnassertions;
            }
            $ret = undef unless defined wantarray;
d3606 4
a3609 12
            if ( defined wantarray ) {

                # Save the value if it's wanted at all.
                $ret = &$sub;
            }
            else {

                # Void return, explicitly.
                &$sub;
                undef $ret;
            }
        }    # if assertion
d3612 1
a3612 1
        $single |= $stack[ $stack_depth-- ];
d3616 1
a3616 1
            $frame & 4    # Extended messsages
d3618 2
a3619 2
                print_lineinfo( ' ' x $stack_depth, "out " ),
                print_trace( $LINEINFO, -1, 1, 1, "$sub$al" )
d3621 2
a3622 3
            : print_lineinfo( ' ' x $stack_depth, "exited $sub$al\n" )

              # Standard messages
d3627 1
a3627 1
        if ( $doret eq $stack_depth or $frame & 16 and defined wantarray ) {
d3629 2
a3630 2
            my $fh = ( $doret eq $stack_depth ? $OUT : $LINEINFO );
            print $fh ( ' ' x $stack_depth ) if $frame & 16;
d3635 2
a3636 2
            );
            dumpit( $fh, $ret ) if defined wantarray;
d3701 1
a3701 1
);
d3723 1
a3723 1
    # Assemble the command subroutine's name by looking up the
d3731 1
a3731 1
    return &$call( $cmd, $line, $dblineno );
d3743 2
a3744 2
    my $cmd    = shift;
    my $line   = shift || '';    # [.|line] expr
d3750 3
a3752 3
    # Should be a line number followed by an expression.
    if ( $line =~ /^\s*(\d*)\s*(\S.+)/ ) {
        my ( $lineno, $expr ) = ( $1, $2 );
d3755 1
a3755 2
        if ( length $expr ) {

d3757 1
a3757 1
            if ( $dbline[$lineno] == 0 ) {
a3761 1

a3773 1

d3789 2
a3790 2
    my $cmd    = shift;
    my $line   = shift || '';
d3800 1
a3800 1
    if ( $line eq '*' ) {
d3806 1
a3806 1
    elsif ( $line =~ /^(\S.*)/ ) {
d3813 2
a3814 1
          "Deleting an action requires a line number, or '*' for all\n" ; # hint
d3829 1
a3829 2
    if ( defined($i) ) {

d3839 1
a3839 1
        for my $file ( keys %had_breakpoints ) {
d3843 2
a3844 2
            for ( $i = 1 ; $i <= $max ; $i++ ) {
                if ( defined $dbline{$i} ) {
d3848 1
a3848 1
                unless ( $had_breakpoints{$file} &= ~2 ) {
d3874 3
a3876 3
    # No line number, no condition. Simple break on current line.
    if ( $line =~ /^\s*$/ ) {
        &cmd_b_line( $dbline, 1 );
d3880 1
a3880 1
    elsif ( $line =~ /^load\b\s*(.*)/ ) {
d3887 1
a3887 1
    # The interpreter actually traps this one for us; we just put the
d3889 1
a3889 2
    elsif ( $line =~ /^(postpone|compile)\b\s*([':A-Za-z_][':\w]*)\s*(.*)/ ) {

d3895 1
a3895 1
        my ( $subname, $break ) = ( $2, $1 eq 'postpone' );
d3904 1
a3904 1
        $subname = "main" . $subname if substr( $subname, 0, 2 ) eq "::";
d3911 2
a3912 3
    elsif ( $line =~ /^([':A-Za-z_][':\w]*(?:\[.*\])?)\s*(.*)/ ) {

        #
d3915 1
a3915 1
        &cmd_b_sub( $subname, $cond );
d3919 1
a3919 2
    elsif ( $line =~ /^(\d*)\s*(.*)/ ) {

d3927 1
a3927 1
        &cmd_b_line( $line, $cond );
a3976 1

d3981 1
a3981 1
        # Tack on .pm and do it again unless there was a '.' in the name
d4050 2
a4051 2

    my ( $from, $to ) = @@_;
d4057 1
a4057 1
    if ( @@_ >= 2 ) {
d4070 1
a4070 1
        #    as the stopping point.
d4073 1
a4073 1
        #    times $delta of 1 (positive), so the result is < 0 and we should
d4076 1
a4076 1
        # If $delta is negative (going backward), $limit will be 1.
d4082 2
a4083 2
        #    times $delta of -1 (negative), so the result is not > 0, and
        #    we use $limit (1) as the stopping point.
d4086 1
a4086 1
        #    (negative), still giving zero; the result is not > 0, and
d4092 2
a4093 2

        $limit = $to if ( $limit - $to ) * $delta > 0;
d4098 2
a4099 2
        # by $delta: either -1 (back) or +1 (ahead).
        # We stay in as long as we haven't hit an executable line
d4102 1
a4102 1
        $i += $delta while $dbline[$i] == 0 and ( $limit - $i ) * $delta > 0;
d4110 2
a4111 2
    my ( $pl, $upto ) = ( '', '' );
    ( $pl, $upto ) = ( 's', "..$to" ) if @@_ >= 2 and $from != $to;
a4124 1

d4129 1
a4129 1
    local *dbline = $main::{ '_<' . $f };
d4149 1
a4149 1
    my ( $i, $cond ) = @@_;
d4165 2
a4166 3
    # If there is an action or condition here already ...
    if ( $dbline{$i} ) {

d4168 1
a4168 1
        $dbline{$i} =~ s/^[^\0]*/$cond/;
d4170 1
a4170 2
    else {

d4172 1
a4172 1
        $dbline{$i} = $cond;
d4198 1
a4198 1
    my ( $f, $i, $cond ) = @@_;
d4204 1
a4204 1
    local *dbline = $main::{ '_<' . $f };
d4211 1
a4211 1
    break_on_line( $i, $cond );
d4222 1
a4222 1
    my ( $f, $from, $to, $cond ) = @@_;
d4225 1
a4225 1
    my $i = breakable_line_in_filename( $f, $from, $to );
d4231 1
a4231 1
    break_on_filename_line( $f, $i, $cond );
d4242 1
a4242 1
    my ( $subname, $cond ) = @@_;
d4262 1
a4262 1
    my ( $file, $s, $e ) = subroutine_filename_lines($subname)
d4270 1
a4270 1
    break_on_filename_line_range( $file, $s, $e, @@_ );
d4295 1
a4295 1
    my ( $subname, $cond ) = @@_;
d4300 1
a4300 1
    # If the subname isn't a code reference, qualify it so that
d4302 1
a4302 2
    unless ( ref $subname eq 'CODE' ) {

d4320 1
a4320 1
        $subname = "main" . $subname if substr( $subname, 0, 2 ) eq "::";
d4325 1
a4325 1
    eval { break_subroutine( $subname, $cond ); 1 } or do {
d4343 1
a4343 1
    my $cmd = shift;
d4345 1
a4345 1
    # No line spec? Use dbline.
d4347 1
a4347 1
    my $line   = ( $_[0] =~ /^\./ ) ? $dbline : shift || '';
d4354 1
a4354 1
    if ( $line eq '*' ) {
d4359 2
a4360 2
    elsif ( $line =~ /^(\S.*)/ ) {
        eval { &delete_breakpoint( $line || $dbline ); 1 } or do {
d4366 1
a4366 1
    # No line spec.
d4403 1
a4403 1
    if ( defined($i) ) {
d4421 1
a4421 2
        for my $file ( keys %had_breakpoints ) {

d4429 1
a4429 2
            for ( $i = 1 ; $i <= $max ; $i++ ) {

d4431 1
a4431 2
                if ( defined $dbline{$i} ) {

d4434 1
a4434 2
                    if ( $dbline{$i} =~ s/^\0?$// ) {

d4442 1
a4442 1
            # bit, the entry in %had_breakpoints for this file is zero,
d4444 1
a4444 1
            if ( not $had_breakpoints{$file} &= ~1 ) {
d4484 1
a4484 1
    my $cmd = shift;
d4490 1
a4490 1
    if ( $line =~ /^h\s*/ ) {
d4495 1
a4495 1
    elsif ( $line =~ /^(\S.*)$/ ) {
d4499 2
a4500 2
        my $asked = $1;    # the command requested
                           # (for proper error message)
d4507 1
a4507 2
        if (
            $help =~ /^                    # Start of a line
d4511 1
a4511 4
                     /mx
          )
        {

d4513 1
a4513 2
            while (
                $help =~ /^
d4521 1
a4521 3
                             /mgx
              )
            {
a4537 36
=head3 C<cmd_i> - inheritance display

Display the (nested) parentage of the module or object given.

=cut

sub cmd_i {
    my $cmd  = shift;
    my $line = shift;
    eval { require Class::ISA };
    if ($@@) {
        &warn( $@@ =~ /locate/
            ? "Class::ISA module not found - please install\n"
            : $@@ );
    }
    else {
      ISA:
        foreach my $isa ( split( /\s+/, $line ) ) {
            $evalarg = $isa;
            ($isa) = &eval;
            no strict 'refs';
            print join(
                ', ',
                map {    # snaffled unceremoniously from Class::ISA
                    "$_"
                      . (
                        defined( ${"$_\::VERSION"} )
                        ? ' ' . ${"$_\::VERSION"}
                        : undef )
                  } Class::ISA::self_and_super_path(ref($isa) || $isa)
            );
            print "\n";
        }
    }
} ## end sub cmd_i

d4553 4
a4556 3
    my $current_line = $line;
    my $cmd  = shift;
    my $line = shift;
d4561 1
a4561 1
    # If the line is '$something', assume this is a scalar containing a
d4563 1
a4563 1
    if ( $line =~ /^(\$.*)/s ) {
a4566 1
        # $evalarg = $2;
d4570 1
a4570 1
        print( $OUT "Error: $@@\n" ), next CMD if $@@;
d4574 1
a4574 1
        print( $OUT "Interpreted as: $1 $s\n" );
d4578 1
a4578 1
        &cmd_l( 'l', $s );
d4581 2
a4582 2
    # l name. Try to find a sub by that name.
    elsif ( $line =~ /^([\':A-Za-z_][\':\w]*(\[.*\])?)/s ) {
d4599 1
a4599 1
        $subname = "main" . $subname if substr( $subname, 0, 2 ) eq "::";
d4601 1
a4601 1
        # Get name:start-stop from find_sub, and break this up at
d4603 1
a4603 1
        @@pieces = split( /:/, find_sub($subname) || $sub{$subname} );
d4610 1
a4610 1
        $file = join( ':', @@pieces );
d4613 1
a4613 1
        if ( $file ne $filename ) {
d4626 1
a4626 1
            if ( eval($subrange) < -$window ) {
a4628 1

d4631 1
a4631 1
            &cmd_l( 'l', $subrange );
d4641 1
a4641 2
    elsif ( $line =~ /^\s*$/ ) {

d4644 1
a4644 2
        $line = $start . '-' . ( $start + $incr );

d4646 1
a4646 1
        &cmd_l( 'l', $line );
d4650 1
a4650 2
    elsif ( $line =~ /^(\d*)\+(\d*)$/ ) {

d4660 2
a4661 2
        $line = $start . '-' . ( $start + $incr );
        &cmd_l( 'l', $line );
d4665 1
a4665 1
    elsif ( $line =~ /^((-?[\d\$\.]+)([-,]([\d\$\.]+))?)?/ ) {
d4668 1
a4668 1
        $end = ( !defined $2 ) ? $max : ( $4 ? $4 : $2 );
d4673 4
a4676 4
        # Determine start line.
        $i    = $2;
        $i    = $line if $i eq '.';
        $i    = 1 if $i < 1;
d4687 1
a4687 1
        # - the current line in execution
d4692 1
a4692 2
            for ( ; $i <= $end ; $i++ ) {

d4694 2
a4695 2
                my ( $stop, $action );
                ( $stop, $action ) = split( /\0/, $dbline{$i} )
d4701 1
a4701 1
                  ( $i == $current_line and $filename eq $filename_ini )
d4703 1
a4703 1
                  : ( $dbline[$i] + 0 ? ':' : ' ' );
d4718 1
a4718 1
            print $OUT "\n" unless $dbline[ $i - 1 ] =~ /\n$/;
d4746 1
a4746 1
    # If no argument, list everything. Pre-5.8.0 version always lists
d4752 3
a4754 3
    my $action_wanted = ( $arg =~ /a/ ) ? 1 : 0;
    my $break_wanted  = ( $arg =~ /b/ ) ? 1 : 0;
    my $watch_wanted  = ( $arg =~ /w/ ) ? 1 : 0;
d4758 1
a4758 2
    if ( $break_wanted or $action_wanted ) {

d4760 1
a4760 2
        for my $file ( keys %had_breakpoints ) {

d4766 2
a4767 2
            my $was;    # Flag: did we print something
                        # in this file?
d4770 1
a4770 2
            for ( $i = 1 ; $i <= $max ; $i++ ) {

d4772 1
a4772 2
                if ( defined $dbline{$i} ) {

d4780 1
a4780 1
                    ( $stop, $action ) = split( /\0/, $dbline{$i} );
d4800 1
a4800 1
    if ( %postponed and $break_wanted ) {
d4803 1
a4803 1
        for $subname ( keys %postponed ) {
d4815 1
a4815 1
    if ( @@have and ( $break_wanted or $action_wanted ) ) {
d4817 1
a4817 1
        my ( $file, $line );
d4819 1
a4819 1
        for $file ( keys %postponed_file ) {
d4822 1
a4822 1
            for $line ( sort { $a <=> $b } keys %$db ) {
d4824 1
a4824 1
                my ( $stop, $action ) = split( /\0/, $$db{$line} );
d4836 1
a4836 1
    if ( %break_on_load and $break_wanted ) {
d4839 1
a4839 1
        for $file ( keys %break_on_load ) {
d4845 1
a4845 1
        if ( $trace & 2 ) {
d4878 1
a4878 1
    if ( $opt =~ /^(\S.*)/ ) {
d4918 1
a4918 2
    if ( $line =~ /^(\d*)$/ ) {

d4923 1
a4923 1
        $start = $1 if $1;
d4929 1
a4929 1
        $line = $start . '-' . ( $start + $incr );
d4932 1
a4932 1
        &cmd_l( 'l', $line );
d4949 1
a4949 1
    my $cmd = shift;
d4955 1
a4955 2
    if ( $expr =~ /^(\S.*)/ ) {

d4963 2
a4964 2
        my ($val) = join( ' ', &eval );
        $val = ( defined $val ) ? "'$val'" : 'undef';
d4975 2
a4976 1
        print $OUT "Adding a watch-expression requires an expression\n";  # hint
d5001 1
a5001 2
    if ( $expr eq '*' ) {

d5012 1
a5012 2
    elsif ( $expr =~ /^(\S.*)/ ) {

d5021 4
a5024 4
            if ( $val eq $expr ) {    # =~ m/^\Q$i$/) {
                                      # Yes. Turn it off, and its value too.
                splice( @@to_watch,  $i_cnt, 1 );
                splice( @@old_watch, $i_cnt, 1 );
d5038 2
a5039 2
          "Deleting a watch-expression requires an expression, or '*' for all\n"
          ;    # hint
a5049 28
=item cmd_P

Something to do with assertions

=cut

sub cmd_P {
    unless ($ini_assertion) {
        print $OUT "Assertions not supported in this Perl interpreter\n";
    } else {
        if ( $cmd =~ /^.\b\s*([+-]?)\s*(~?)\s*(\w+(\s*\|\s*\w+)*)\s*$/ ) {
            my ( $how, $neg, $flags ) = ( $1, $2, $3 );
            my $acu = parse_DollarCaretP_flags($flags);
            if ( defined $acu ) {
                $acu = ~$acu if $neg;
                if ( $how eq '+' ) { $^P |= $acu }
                elsif ( $how eq '-' ) { $^P &= ~$acu }
                else { $^P = $acu }
            }

            # else { print $OUT "undefined acu\n" }
        }
        my $expanded = expand_DollarCaretP_flags($^P);
        print $OUT "Internal Perl debugger flags:\n\$^P=$expanded\n";
        $expanded;
    }
}

d5058 2
a5059 3

    # Save eval failure, command failure, extended OS error, output field
    # separator, input record separator, output record separator and
d5061 1
a5061 1
    @@saved = ( $@@, $!, $^E, $,, $/, $\, $^W );
d5063 4
a5066 4
    $,  = "";      # output field separator is null string
    $/  = "\n";    # input record separator is newline
    $\  = "";      # output record separator is null string
    $^W = 0;       # warnings are off
a5078 1

a5099 1

d5104 1
a5104 2
    if ( $postponed{$subname} =~ s/^break\s([+-]?\d+)\s+if\s// ) {

d5110 1
a5110 1
        my ( $file, $i ) = ( find_sub($subname) =~ /^(.*):(\d+)-.*$/ );
d5112 1
a5112 2

            # We got the start line. Add the offset '+<n>' from
d5120 1
a5120 1
            local $^W = 0;    # != 0 is magical below
d5143 1
a5143 1
    elsif ( $postponed{$subname} eq 'compile' ) { $signal = 1 }
a5162 1

a5164 1

d5169 1
a5169 1
        $signal = 1;
d5182 1
a5182 1
    print_lineinfo( ' ' x $stack_depth, "Package $filename.\n" ) if $frame;
d5194 1
a5194 1
    #%dbline = %{$postponed_file{$filename}};
d5199 1
a5199 2
    for $key ( keys %{ $postponed_file{$filename} } ) {

a5248 1

d5263 1
a5263 1
    unless ( defined &main::dumpValue ) {
d5269 1
a5269 1
    if ( defined &main::dumpValue ) {
d5276 1
a5276 1
        &main::dumpValue( $v, $maxdepth );
a5323 1

d5327 3
a5329 3
      if $fh        eq $LINEINFO    # slave editor
      and $LINEINFO eq $OUT         # normal output
      and $term_pid != $$;          # not the primary
d5333 1
a5333 1
    my @@sub = dump_trace( $_[0] + 1, $_[1] );
d5336 1
a5336 1
    my $short = $_[2];              # Print short report, next one for sub name
d5340 1
a5340 2
    for ( $i = 0 ; $i <= $#sub ; $i++ ) {

d5344 1
a5344 1
        # Set the separator so arrys print nice.
a5351 1

d5353 1
a5353 1
        $args = ( substr $args, 0, $maxtrace - 3 ) . '...'
d5364 1
a5364 1
        $s = ( substr $s, 0, $maxtrace - 3 ) . '...' if length $s > $maxtrace;
d5369 2
a5370 1
            print $fh "$sub[$i]{context}=$sub$args from $file:$sub[$i]{line}\n";
d5375 2
a5376 3
            print $fh "$sub[$i]{context} = $s$args"
              . " called from $file"
              . " line $sub[$i]{line}\n";
d5422 1
a5422 1
    # the current one.  Add $skip to the count of frames so we have a
d5428 1
a5428 1
    my ( $p, $file, $line, $sub, $h, $context );
d5430 1
a5430 1
    my ( $e, $r, @@a, @@sub, $args );
d5434 1
a5434 1
    local $frame = 0;
d5449 1
a5449 1
        and ( $p, $file, $line, $sub, $h, $context, $e, $r ) = caller($i) ;
d5458 1
a5458 1
            if ( not defined $arg ) {    # undefined parameter
d5462 1
a5462 1
            elsif ( $nothard and tied $arg ) {    # tied parameter
d5465 1
a5465 1
            elsif ( $nothard and $type = ref $arg ) {    # reference
d5468 1
a5468 1
            else {                                       # can be stringified
d5486 1
a5486 1
                push( @@a, $_ );
d5492 1
a5492 1
        # If neither, context isn't defined. (This is apparently a 'can't
d5494 1
a5494 1
        $context = $context ? '@@' : ( defined $context ? "\$" : '.' );
d5502 1
a5502 1
        $e =~ s/\n\s*\;\s*\Z// if $e;
a5510 1

d5512 1
a5512 1
        elsif ( defined $r ) {
d5518 1
a5518 1
        elsif ( $sub eq '(eval)' ) {
d5523 1
a5523 1
        push(
d5532 1
a5532 1
        );
d5555 1
a5555 2
    while ( $action =~ s/\\$// ) {

d5619 4
a5622 4
    open( SAVEIN,  "<&STDIN" )  || &warn("Can't save STDIN");
    open( SAVEOUT, ">&STDOUT" ) || &warn("Can't save STDOUT");
    open( STDIN,   "<&IN" )     || &warn("Can't redirect STDIN");
    open( STDOUT,  ">&OUT" )    || &warn("Can't redirect STDOUT");
d5626 2
a5627 2
    open( STDIN,  "<&SAVEIN" )  || &warn("Can't restore STDIN");
    open( STDOUT, ">&SAVEOUT" ) || &warn("Can't restore STDOUT");
d5632 2
a5633 2
    if ( $? >> 8 ) {
        &warn( "(Command exited ", ( $? >> 8 ), ")\n" );
d5638 2
a5639 2
            ( $? & 127 ),
            ( ( $? & 128 ) ? " -- core dumped" : "" ),
d5641 1
a5641 1
        );
a5668 1

d5677 1
a5677 1
            my ( $i, $o ) = split $tty, /,/;
d5679 2
a5680 2
            open( IN,  "<$i" ) or die "Cannot open TTY `$i' for read: $!";
            open( OUT, ">$o" ) or die "Cannot open TTY `$o' for write: $!";
a5690 1

d5702 1
d5704 1
a5704 1
    if ( $term_pid eq '-1' ) {    # In a TTY with another debugger
d5709 1
a5709 1
    if ( !$rl ) {
d5720 1
a5720 1
          and index( $rl_attribs->{basic_word_break_characters}, ":" ) == -1;
d5732 1
a5732 1
    if ( $term->Features->{setHistory} and "@@hist" ne "?" ) {
d5778 1
a5778 1
    ( my $name = $0 ) =~ s,^.*[/\\],,s;
d5801 1
a5801 1
    local $^F = 40;    # XXXX Fixme!
d5803 1
a5803 1
    my ( $in1, $out1, $in2, $out2 );
d5813 1
a5813 1
    ( my $name = $0 ) =~ s,^.*[/\\],,s;
d5823 2
a5824 1
            $rl, fileno $in1, fileno $out2, "Daughter Perl debugger $pids $name"
d5827 2
a5828 2
            ( $kpid = CORE::system 4, $^X, '-we',
                <<'ES', @@args ) >= 0    # P_SESSION
d5854 1
a5854 1
        reset_IN_OUT( $in2, $out1 );
d5886 1
a5886 1
    # It used to be that
d5889 1
a5889 1
    if ( not defined $in ) {
d5918 1
a5918 1
    elsif ( $in ne '' ) {
d5946 1
a5946 1
sub resetterm {    # We forked, so we need a different TTY
d5969 1
a5969 1
    $term_pid = $$;
a6001 1

d6006 1
a6006 1
        my $got = shift @@typeahead;
d6019 1
a6019 1
    # We really need to read some input. Turn off entry/exit trace and
a6025 1

d6027 1
a6027 2
        my $line = CORE::readline( $cmdfhs[-1] );

d6030 2
a6031 2
          ? ( print $OUT ">> $line" and return $line )    # Echo and return
          : close pop @@cmdfhs;                            # Pop and close
d6035 1
a6035 2
    if ( ref $OUT and UNIVERSAL::isa( $OUT, 'IO::Socket::INET' ) ) {

d6037 1
a6037 1
        $OUT->write( join( '', @@_ ) );
d6041 2
a6042 2
        $IN->recv( $stuff, 2048 );    # XXX "what's wrong with sysread?"
                                      # XXX Don't know. You tell me.
d6067 2
a6068 2
    my ( $opt, $val ) = @@_;
    $val = option_val( $opt, 'N/A' );
a6072 7
sub options2remember {
    foreach my $k (@@RememberOnROptions) {
        $option{$k} = option_val( $k, 'N/A' );
    }
    return %option;
}

d6084 1
a6084 1
    my ( $opt, $default ) = @@_;
d6090 1
a6090 2
        and defined ${ $optionVars{$opt} } )
    {
d6098 1
a6098 2
        and defined &{ $optionAction{$opt} } )
    {
d6105 1
a6105 1
        or defined $optionVars{$opt} and not defined ${ $optionVars{$opt} } )
d6147 1
a6147 1
    my %opt_needs_val = map { ( $_ => 1 ) } qw{
d6150 1
a6150 1
    };
d6160 2
a6161 2
        s/^(\w+)(\W?)// or print( $OUT "Invalid option `$_'\n" ), last;
        my ( $opt, $sep ) = ( $1, $2 );
d6164 5
a6168 2
        my $matches = grep( /^\Q$opt/ && ( $option = $_ ), @@options )
          || grep( /^\Q$opt/i && ( $option = $_ ), @@options );
a6169 2
        print( $OUT "Unknown option `$opt'\n" ), next unless $matches;
        print( $OUT "Ambiguous option `$opt'\n" ), next if $matches > 1;
d6173 2
a6174 2
        if ( "?" eq $sep ) {
            print( $OUT "Option query `$opt?' followed by non-space `$_'\n" ),
d6183 1
a6183 1
        elsif ( $sep !~ /\S/ ) {
d6185 1
a6185 1
            $val           = "1";   #  this is an evil default; make 'em set it!
d6189 1
a6189 2
        elsif ( $sep eq "=" ) {

d6193 1
a6193 1
                ( $val = $2 ) =~ s/\\([$quote\\])/$1/g;
d6206 1
a6206 1
        # "Quoted" with [], <>, or {}.
d6208 1
a6208 2
            my ($end) =
              "\\" . substr( ")]>}$sep", index( "([<{", $sep ), 1 );    #}
d6210 2
a6211 2
              or print( $OUT "Unclosed option value `$opt$sep$_'\n" ), last;
            ( $val = $1 ) =~ s/\\([\\$end])/$1/g;
d6214 3
d6218 2
a6219 2
        if ( $opt_needs_val{$option} && $val_defaulted ) {
            my $cmd = ( $CommandSet eq '580' ) ? 'o' : 'O';
d6235 2
a6236 2
          if defined $optionRequire{$option}
          && defined $val;
d6238 1
a6238 1
        # Set it.
d6241 2
a6242 2
          if defined $optionVars{$option}
          && defined $val;
d6246 3
a6248 3
          if defined $optionAction{$option}
          && defined &{ $optionAction{$option} }
          && defined $val;
d6270 1
a6270 1
    my ( $stem, @@list ) = @@_;
d6278 1
a6278 1
    for $i ( 0 .. $#list ) {
d6298 1
a6298 1
    for $i ( 0 .. $n - 1 ) {
d6335 1
a6335 1
    my ($msg) = join( "", @@_ );
d6355 3
a6357 3
    if ( $term and $term->Features->{newTTY} ) {
        ( $IN, $OUT ) = ( shift, shift );
        $term->newTTY( $IN, $OUT );
d6367 1
a6367 1
        ( $IN, $OUT ) = ( shift, shift );
d6397 1
a6397 2
    if ( @@_ and $term and $term->Features->{newTTY} ) {

d6402 2
a6403 3
        my ( $in, $out ) = shift;
        if ( $in =~ /,/ ) {

d6405 1
a6405 1
            ( $in, $out ) = split /,/, $in, 2;
a6407 1

d6413 1
a6413 1
        open IN,  $in     or die "cannot open `$in' for read: $!";
d6417 1
a6417 1
        reset_IN_OUT( \*IN, \*OUT );
d6426 1
a6426 1

d6491 1
a6491 1
    if ( ${ $term->Features }{tkRunning} ) {
a6516 36
sub DollarCaretP {
    if ($term) {
        &warn("Some flag changes could not take effect until next 'R'!\n")
          if @@_;
    }
    $^P = parse_DollarCaretP_flags(shift) if @@_;
    expand_DollarCaretP_flags($^P);
}

sub OnlyAssertions {
    if ($term) {
        &warn("Too late to set up OnlyAssertions mode, enabled on next 'R'!\n")
          if @@_;
    }
    if (@@_) {
        unless ( defined $ini_assertion ) {
            if ($term) {
                &warn("Current Perl interpreter doesn't support assertions");
            }
            return 0;
        }
        if (shift) {
            unless ($ini_assertion) {
                print "Assertions will be active on next 'R'!\n";
                $ini_assertion = 1;
            }
            $^P &= ~$DollarCaretP_flags{PERLDBf_SUB};
            $^P |= $DollarCaretP_flags{PERLDBf_ASSERTION};
        }
        else {
            $^P |= $DollarCaretP_flags{PERLDBf_SUB};
        }
    }
    !( $^P & $DollarCaretP_flags{PERLDBf_SUB} ) || 0;
}

d6549 4
a6552 4
    $psh = $sh;    # copy it
    $psh =~ s/\\b$//;        # Take off trailing \b if any
    $psh =~ s/\\(.)/$1/g;    # De-escape
    $psh;                    # return the printable version
d6564 1
a6564 2
    if ( defined $term ) {

d6566 1
a6566 1
        local ( $warnLevel, $dieLevel ) = ( 0, 1 );
d6596 4
a6599 4
    $prc = $rc;    # Copy it
    $prc =~ s/\\b$//;        # Remove trailing \b
    $prc =~ s/\\(.)/$1/g;    # Remove escapes
    $prc;                    # Return the printable version
d6616 1
a6616 1
    #  If this is a valid "thing to be opened for output", tack a
d6618 1
a6618 1
    my $stream = ( $lineinfo =~ /^(\+?\>|\|)/ ) ? $lineinfo : ">$lineinfo";
d6621 1
a6621 1
    $slave_editor = ( $stream =~ /^\|/ );
d6624 1
a6624 1
    open( LINEINFO, "$stream" ) || &warn("Cannot open `$stream' for write");
a6649 1

d6652 1
a6652 1
    for ( keys %INC ) {
d6662 1
a6662 1
        if ( defined ${ $_ . '::VERSION' } ) {
d6671 1
a6671 1
    dumpit( $OUT, \%version );
d6707 30
a6736 30
B<T>        Stack trace.
B<s> [I<expr>]    Single step [in I<expr>].
B<n> [I<expr>]    Next, steps over subroutine calls [in I<expr>].
<B<CR>>        Repeat last B<n> or B<s> command.
B<r>        Return from current subroutine.
B<c> [I<line>|I<sub>]    Continue; optionally inserts a one-time-only breakpoint
        at the specified position.
B<l> I<min>B<+>I<incr>    List I<incr>+1 lines starting at I<min>.
B<l> I<min>B<->I<max>    List lines I<min> through I<max>.
B<l> I<line>        List single I<line>.
B<l> I<subname>    List first window of lines from subroutine.
B<l> I<\$var>        List first window of lines from subroutine referenced by I<\$var>.
B<l>        List next window of lines.
B<->        List previous window of lines.
B<v> [I<line>]    View window around I<line>.
B<.>        Return to the executed line.
B<f> I<filename>    Switch to viewing I<filename>. File must be already loaded.
        I<filename> may be either the full name of the file, or a regular
        expression matching the full file name:
        B<f> I</home/me/foo.pl> and B<f> I<oo\\.> may access the same file.
        Evals (with saved bodies) are considered to be filenames:
        B<f> I<(eval 7)> and B<f> I<eval 7\\b> access the body of the 7th eval
        (in the order of execution).
B</>I<pattern>B</>    Search forwards for I<pattern>; final B</> is optional.
B<?>I<pattern>B<?>    Search backwards for I<pattern>; final B<?> is optional.
B<L> [I<a|b|w>]        List actions and or breakpoints and or watch-expressions.
B<S> [[B<!>]I<pattern>]    List subroutine names [not] matching I<pattern>.
B<t>        Toggle trace mode.
B<t> I<expr>        Trace through execution of I<expr>.
B<b>        Sets breakpoint on current line)
d6738 2
a6739 2
        Set breakpoint; I<line> defaults to the current execution line;
        I<condition> breaks if it evaluates to true, defaults to '1'.
d6741 2
a6742 2
        Set breakpoint at first line of subroutine.
B<b> I<\$var>        Set breakpoint at first line of subroutine referenced by I<\$var>.
d6745 2
a6746 2
        Set breakpoint at first line of subroutine after 
        it is compiled.
d6748 2
a6749 2
        Stop after the subroutine is compiled.
B<B> [I<line>]    Delete the breakpoint for I<line>.
d6752 7
a6758 7
        Set an action to be done before the I<line> is executed;
        I<line> defaults to the current execution line.
        Sequence is: check for breakpoint/watchpoint, print line
        if necessary, do action, prompt user if necessary,
        execute line.
B<a>        Does nothing
B<A> [I<line>]    Delete the action for I<line>.
d6760 3
a6762 3
B<w> I<expr>        Add a global watch-expression.
B<w>             Does nothing
B<W> I<expr>        Delete a global watch-expression.
d6764 8
a6771 9
B<V> [I<pkg> [I<vars>]]    List some (default all) variables in package (default current).
        Use B<~>I<pattern> and B<!>I<pattern> for positive and negative regexps.
B<X> [I<vars>]    Same as \"B<V> I<currentpackage> [I<vars>]\".
B<x> I<expr>        Evals expression in list context, dumps the result.
B<m> I<expr>        Evals expression in list context, prints methods callable
        on the first element of the result.
B<m> I<class>        Prints methods callable via the given class.
B<M>        Show versions of loaded modules.
B<i> I<class>       Prints nested parents of given class.
a6772 1
B<P> Something to do with assertions...
d6774 17
a6790 17
B<<> ?            List Perl commands to run before each prompt.
B<<> I<expr>        Define Perl command to run before each prompt.
B<<<> I<expr>        Add to the list of Perl commands to run before each prompt.
B<< *>                Delete the list of perl commands to run before each prompt.
B<>> ?            List Perl commands to run after each prompt.
B<>> I<expr>        Define Perl command to run after each prompt.
B<>>B<>> I<expr>        Add to the list of Perl commands to run after each prompt.
B<>>B< *>        Delete the list of Perl commands to run after each prompt.
B<{> I<db_command>    Define debugger command to run before each prompt.
B<{> ?            List debugger commands to run before each prompt.
B<{{> I<db_command>    Add to the list of debugger commands to run before each prompt.
B<{ *>             Delete the list of debugger commands to run before each prompt.
B<$prc> I<number>    Redo a previous command (default previous command).
B<$prc> I<-number>    Redo number'th-to-last command.
B<$prc> I<pattern>    Redo last command that started with I<pattern>.
        See 'B<O> I<recallCommand>' too.
B<$psh$psh> I<cmd>      Run cmd in a subprocess (reads from DB::IN, writes to DB::OUT)"
d6795 16
a6810 20
B<$psh> [I<cmd>] Run I<cmd> in subshell (forces \"\$SHELL -c 'cmd'\")."
      ) . "
        See 'B<O> I<shellBang>' too.
B<source> I<file>     Execute I<file> containing debugger commands (may nest).
B<save> I<file>       Save current debugger session (actual history) to I<file>.
B<rerun>           Rerun session to current position.
B<rerun> I<n>         Rerun session to numbered command.
B<rerun> I<-n>        Rerun session to number'th-to-last command.
B<H> I<-number>    Display last number commands (default all).
B<H> I<*>          Delete complete history.
B<p> I<expr>        Same as \"I<print {DB::OUT} expr>\" in current package.
B<|>I<dbcmd>        Run debugger command, piping DB::OUT to current pager.
B<||>I<dbcmd>        Same as B<|>I<dbcmd> but DB::OUT is temporarilly select()ed as well.
B<\=> [I<alias> I<value>]    Define a command alias, or list current aliases.
I<command>        Execute as a perl statement in current package.
B<R>        Pure-man-restart of debugger, some of debugger state
        and command-line options may be lost.
        Currently the following settings are preserved:
        history, breakpoints and actions, debugger B<O>ptions 
        and the following command-line options: I<-w>, I<-I>, I<-e>.
d6812 2
a6813 2
B<o> [I<opt>] ...    Set boolean option to true
B<o> [I<opt>B<?>]    Query options
d6815 8
a6822 8
        Set options.  Use quotes in spaces in value.
    I<recallCommand>, I<ShellBang>    chars used to recall command or spawn shell;
    I<pager>            program for output of \"|cmd\";
    I<tkRunning>            run Tk while prompting (with ReadLine);
    I<signalLevel> I<warnLevel> I<dieLevel>    level of verbosity;
    I<inhibit_exit>        Allows stepping off the end of the script.
    I<ImmediateStop>        Debugger should stop as early as possible.
    I<RemotePort>            Remote hostname:port for remote debugging
d6824 8
a6831 8
    I<arrayDepth>, I<hashDepth>     print only first N elements ('' for all);
    I<compactDump>, I<veryCompact>     change style of array and hash dump;
    I<globPrint>             whether to print contents of globs;
    I<DumpDBFiles>         dump arrays holding debugged files;
    I<DumpPackages>         dump symbol tables of packages;
    I<DumpReused>             dump contents of \"reused\" addresses;
    I<quote>, I<HighBit>, I<undefPrint>     change style of string dump;
    I<bareStringify>         Do not print the overload-stringified value;
d6833 20
a6852 20
    I<PrintRet>        affects printing of return value after B<r> command,
    I<frame>        affects printing messages on subroutine entry/exit.
    I<AutoTrace>    affects printing messages on possible breaking points.
    I<maxTraceLen>    gives max length of evals/args listed in stack trace.
    I<ornaments>     affects screen appearance of the command line.
    I<CreateTTY>     bits control attempts to create a new TTY on events:
            1: on fork()    2: debugger is started inside debugger
            4: on startup
    During startup options are initialized from \$ENV{PERLDB_OPTS}.
    You can put additional initialization options I<TTY>, I<noTTY>,
    I<ReadLine>, I<NonStop>, and I<RemotePort> there (or use
    `B<R>' after you set them).

B<q> or B<^D>        Quit. Set B<\$DB::finished = 0> to debug global destruction.
B<h>        Summary of debugger commands.
B<h> [I<db_command>]    Get help [on a specific debugger command], enter B<|h> to page.
B<h h>        Long help for debugger commands
B<$doccmd> I<manpage>    Runs the external doc viewer B<$doccmd> command on the 
        named Perl I<manpage>, or on B<$doccmd> itself if omitted.
        Set B<\$DB::doccmd> to change viewer.
d6882 1
a6882 1
  B<X> [I<Vars>]       Same as \"B<V> I<current_package> [I<Vars>]\".  B<i> I<class> inheritance tree.
d6891 29
a6919 29
B<T>        Stack trace.
B<s> [I<expr>]    Single step [in I<expr>].
B<n> [I<expr>]    Next, steps over subroutine calls [in I<expr>].
B<CR>>        Repeat last B<n> or B<s> command.
B<r>        Return from current subroutine.
B<c> [I<line>|I<sub>]    Continue; optionally inserts a one-time-only breakpoint
        at the specified position.
B<l> I<min>B<+>I<incr>    List I<incr>+1 lines starting at I<min>.
B<l> I<min>B<->I<max>    List lines I<min> through I<max>.
B<l> I<line>        List single I<line>.
B<l> I<subname>    List first window of lines from subroutine.
B<l> I<\$var>        List first window of lines from subroutine referenced by I<\$var>.
B<l>        List next window of lines.
B<->        List previous window of lines.
B<w> [I<line>]    List window around I<line>.
B<.>        Return to the executed line.
B<f> I<filename>    Switch to viewing I<filename>. File must be already loaded.
        I<filename> may be either the full name of the file, or a regular
        expression matching the full file name:
        B<f> I</home/me/foo.pl> and B<f> I<oo\\.> may access the same file.
        Evals (with saved bodies) are considered to be filenames:
        B<f> I<(eval 7)> and B<f> I<eval 7\\b> access the body of the 7th eval
        (in the order of execution).
B</>I<pattern>B</>    Search forwards for I<pattern>; final B</> is optional.
B<?>I<pattern>B<?>    Search backwards for I<pattern>; final B<?> is optional.
B<L>        List all breakpoints and actions.
B<S> [[B<!>]I<pattern>]    List subroutine names [not] matching I<pattern>.
B<t>        Toggle trace mode.
B<t> I<expr>        Trace through execution of I<expr>.
d6921 2
a6922 2
        Set breakpoint; I<line> defaults to the current execution line;
        I<condition> breaks if it evaluates to true, defaults to '1'.
d6924 2
a6925 2
        Set breakpoint at first line of subroutine.
B<b> I<\$var>        Set breakpoint at first line of subroutine referenced by I<\$var>.
d6928 2
a6929 2
        Set breakpoint at first line of subroutine after 
        it is compiled.
d6931 3
a6933 3
        Stop after the subroutine is compiled.
B<d> [I<line>]    Delete the breakpoint for I<line>.
B<D>        Delete all breakpoints.
d6935 31
a6965 31
        Set an action to be done before the I<line> is executed;
        I<line> defaults to the current execution line.
        Sequence is: check for breakpoint/watchpoint, print line
        if necessary, do action, prompt user if necessary,
        execute line.
B<a> [I<line>]    Delete the action for I<line>.
B<A>        Delete all actions.
B<W> I<expr>        Add a global watch-expression.
B<W>        Delete all watch-expressions.
B<V> [I<pkg> [I<vars>]]    List some (default all) variables in package (default current).
        Use B<~>I<pattern> and B<!>I<pattern> for positive and negative regexps.
B<X> [I<vars>]    Same as \"B<V> I<currentpackage> [I<vars>]\".
B<x> I<expr>        Evals expression in list context, dumps the result.
B<m> I<expr>        Evals expression in list context, prints methods callable
        on the first element of the result.
B<m> I<class>        Prints methods callable via the given class.

B<<> ?            List Perl commands to run before each prompt.
B<<> I<expr>        Define Perl command to run before each prompt.
B<<<> I<expr>        Add to the list of Perl commands to run before each prompt.
B<>> ?            List Perl commands to run after each prompt.
B<>> I<expr>        Define Perl command to run after each prompt.
B<>>B<>> I<expr>        Add to the list of Perl commands to run after each prompt.
B<{> I<db_command>    Define debugger command to run before each prompt.
B<{> ?            List debugger commands to run before each prompt.
B<{{> I<db_command>    Add to the list of debugger commands to run before each prompt.
B<$prc> I<number>    Redo a previous command (default previous command).
B<$prc> I<-number>    Redo number'th-to-last command.
B<$prc> I<pattern>    Redo last command that started with I<pattern>.
        See 'B<O> I<recallCommand>' too.
B<$psh$psh> I<cmd>      Run cmd in a subprocess (reads from DB::IN, writes to DB::OUT)"
d6970 17
a6986 16
B<$psh> [I<cmd>]     Run I<cmd> in subshell (forces \"\$SHELL -c 'cmd'\")."
      ) . "
        See 'B<O> I<shellBang>' too.
B<source> I<file>        Execute I<file> containing debugger commands (may nest).
B<H> I<-number>    Display last number commands (default all).
B<p> I<expr>        Same as \"I<print {DB::OUT} expr>\" in current package.
B<|>I<dbcmd>        Run debugger command, piping DB::OUT to current pager.
B<||>I<dbcmd>        Same as B<|>I<dbcmd> but DB::OUT is temporarilly select()ed as well.
B<\=> [I<alias> I<value>]    Define a command alias, or list current aliases.
I<command>        Execute as a perl statement in current package.
B<v>        Show versions of loaded modules.
B<R>        Pure-man-restart of debugger, some of debugger state
        and command-line options may be lost.
        Currently the following settings are preserved:
        history, breakpoints and actions, debugger B<O>ptions 
        and the following command-line options: I<-w>, I<-I>, I<-e>.
d6988 2
a6989 2
B<O> [I<opt>] ...    Set boolean option to true
B<O> [I<opt>B<?>]    Query options
d6991 8
a6998 8
        Set options.  Use quotes in spaces in value.
    I<recallCommand>, I<ShellBang>    chars used to recall command or spawn shell;
    I<pager>            program for output of \"|cmd\";
    I<tkRunning>            run Tk while prompting (with ReadLine);
    I<signalLevel> I<warnLevel> I<dieLevel>    level of verbosity;
    I<inhibit_exit>        Allows stepping off the end of the script.
    I<ImmediateStop>        Debugger should stop as early as possible.
    I<RemotePort>            Remote hostname:port for remote debugging
d7000 8
a7007 8
    I<arrayDepth>, I<hashDepth>     print only first N elements ('' for all);
    I<compactDump>, I<veryCompact>     change style of array and hash dump;
    I<globPrint>             whether to print contents of globs;
    I<DumpDBFiles>         dump arrays holding debugged files;
    I<DumpPackages>         dump symbol tables of packages;
    I<DumpReused>             dump contents of \"reused\" addresses;
    I<quote>, I<HighBit>, I<undefPrint>     change style of string dump;
    I<bareStringify>         Do not print the overload-stringified value;
d7009 19
a7027 19
    I<PrintRet>        affects printing of return value after B<r> command,
    I<frame>        affects printing messages on subroutine entry/exit.
    I<AutoTrace>    affects printing messages on possible breaking points.
    I<maxTraceLen>    gives max length of evals/args listed in stack trace.
    I<ornaments>     affects screen appearance of the command line.
    I<CreateTTY>     bits control attempts to create a new TTY on events:
            1: on fork()    2: debugger is started inside debugger
            4: on startup
    During startup options are initialized from \$ENV{PERLDB_OPTS}.
    You can put additional initialization options I<TTY>, I<noTTY>,
    I<ReadLine>, I<NonStop>, and I<RemotePort> there (or use
    `B<R>' after you set them).

B<q> or B<^D>        Quit. Set B<\$DB::finished = 0> to debug global destruction.
B<h> [I<db_command>]    Get help [on a specific debugger command], enter B<|h> to page.
B<h h>        Summary of debugger commands.
B<$doccmd> I<manpage>    Runs the external doc viewer B<$doccmd> command on the 
        named Perl I<manpage>, or on B<$doccmd> itself if omitted.
        Set B<\$DB::doccmd> to change viewer.
d7139 1
a7139 2
    if ( $pager =~ /\bmore\b/ ) {

d7145 4
a7148 4
             $is_less = @@st_more
          && @@st_less
          && $st_more[0] == $st_less[0]
          && $st_more[1] == $st_less[1];
a7168 1

d7183 1
a7183 2
    if ( defined &Carp::longmess ) {

d7187 2
a7188 2
        # Skip two levels before reporting traceback: we're skipping
        # mydie and confess.
d7192 1
a7192 1
        &warn( Carp::longmess("Signal @@_") );
d7213 1
a7213 2

    # No entry/exit trace.
d7231 2
a7232 2
    CORE::warn( @@_,
        "\nCannot print stack trace, load with -MCarp option to see stack" ),
d7237 1
a7237 1
    my ( $mysingle, $mytrace ) = ( $single, $trace );
d7241 1
a7241 1
    # We can call Carp::longmess without its being "debugged" (which we
d7246 1
a7246 1
    ( $single, $trace ) = ( $mysingle, $mytrace );
d7268 2
a7269 2
    local $frame         = 0;
    local $doret         = -2;
d7275 1
a7275 1
    if ( $dieLevel > 2 ) {
d7280 1
a7280 1
    if ( $dieLevel < 2 ) {
d7286 1
a7286 1
    eval { require Carp };
d7288 2
a7289 2
    die( @@_,
        "\nCannot print stack trace, load with -MCarp option to see stack" )
d7296 1
a7296 1
    my ( $mysingle, $mytrace ) = ( $single, $trace );
d7305 1
a7305 1
    ( $single, $trace ) = ( $mysingle, $mytrace );
a7346 1

d7350 2
a7351 2
            # No longer exists, so don't try  to use it.
            #$SIG{__DIE__} = \&DB::diehard if $dieLevel >= 2;
d7357 1
a7357 1
              ( $dieLevel == 1 ? " outside of evals" : "" ), ".\n"
d7464 1
a7464 1
        for ( keys %sub ) {
d7487 1
d7490 1
a7490 1
    methods_via( $class, '', 1 );
d7493 1
a7493 1
    methods_via( 'UNIVERSAL', 'UNIVERSAL', 0 );
a7506 1

d7511 2
a7512 2
    # This is a package that is contributing the methods we're about to print.
    my $prefix  = shift;
a7516 1

d7519 3
a7521 6

        # Extract from all the symbols in this class.
        sort keys %{"${class}::"}
      )
    {

d7524 1
a7524 1

d7532 1
a7532 1
    return unless shift;
d7536 1
a7536 2
    for $name ( @@{"${class}::ISA"} ) {

d7539 2
a7540 3

        # Crawl up the tree and keep trying to crawl up.
        methods_via( $name, $prepend, 1 );
d7551 4
a7554 3
    $doccmd = $^O !~ /^(?:MSWin32|VMS|os2|dos|amigaos|riscos|MacOS|NetWare)\z/s
      ? "man"         # O Happy Day!
      : "perldoc";    # Alas, poor unfortunates
d7574 1
a7574 1
    unless ( $doccmd eq 'man' ) {
d7584 1
a7584 1
    for ( $man1dir, $man3dir ) { s#/[^/]*\z## if /\S/ }
d7599 1
a7599 1
            ( ( $manpath && !$nopathopt ) ? ( "-M", $manpath ) : () ),
d7604 14
a7617 141
        unless ( $page =~ /^perl\w/ ) {
# do it this way because its easier to slurp in to keep up to date - clunky though.
my @@pods = qw(
    5004delta
    5005delta
    561delta
    56delta
    570delta
    571delta
    572delta
    573delta
    58delta
    581delta
    582delta
    583delta
    584delta
    590delta
    591delta
    592delta
    aix
    amiga
    apio
    api
    apollo
    artistic
    beos
    book
    boot
    bot
    bs2000
    call
    ce
    cheat
    clib
    cn
    compile
    cygwin
    data
    dbmfilter
    debguts
    debtut
    debug
    delta
    dgux
    diag
    doc
    dos
    dsc
    ebcdic
    embed
    epoc
    faq1
    faq2
    faq3
    faq4
    faq5
    faq6
    faq7
    faq8
    faq9
    faq
    filter
    fork
    form
    freebsd
    func
    gpl
    guts
    hack
    hist
    hpux
    hurd
    intern
    intro
    iol
    ipc
    irix
    jp
    ko
    lexwarn
    locale
    lol
    machten
    macos
    macosx
    mint
    modinstall
    modlib
    mod
    modstyle
    mpeix
    netware
    newmod
    number
    obj
    opentut
    op
    os2
    os390
    os400
    othrtut
    packtut
    plan9
    pod
    podspec
    port
    qnx
    ref
    reftut
    re
    requick
    reref
    retut
    run
    sec
    solaris
    style
    sub
    syn
    thrtut
    tie
    toc
    todo
    tooc
    toot
    trap
    tru64
    tw
    unicode
    uniintro
    util
    uts
    var
    vmesa
    vms
    vos
    win32
    xs
    xstut
);
            if (grep { $page eq $_ } @@pods) {
d7619 3
a7621 3
                CORE::system( $doccmd,
                    ( ( $manpath && !$nopathopt ) ? ( "-M", $manpath ) : () ),
                    $page );
d7625 1
a7625 1
    if ( defined $oldpath ) {
d7676 2
a7677 2
    $IN  = \*STDIN;     # For bugs before DB::OUT has been opened
    $OUT = \*STDERR;    # For errors before DB::OUT has been opened
d7679 4
a7682 5
    # Define characters used by command parsing.
    $sh       = '!';      # Shell escape (does not work)
    $rc       = ',';      # Recall command (does not work)
    @@hist     = ('?');    # Show history (does not work)
    @@truehist = ();       # Can be saved for replay (per session)
d7684 1
a7684 1
    # This defines the point at which you get the 'deep recursion'
d7686 1
a7686 1
    $deep = 100;
d7688 1
a7688 1
    # Number of lines around the current one that are shown in the
d7690 1
a7690 1
    $window = 10;
d7697 1
a7697 1
    $sub = '';
d7699 1
a7699 1
    # Set up the debugger's interrupt handler. It simply sets a flag
d7704 1
a7704 1
    # debug itself. Perhaps we can try that someday.
d7714 2
a7715 2
    $db_stop = 0;          # Compiler warning ...
    $db_stop = 1 << 30;    # ... because this is only used in an eval() later.
d7718 1
a7718 1
    # Used in the debugger prompt, and in determining whether it's all over or
d7720 1
a7720 1
    $level = 0;            # Level of recursive debugging
d7724 1
a7724 1
    # of work around it. Stay tuned.
d7729 1
a7729 1
    $stack_depth = 0;      # Localized repeatedly; simple way to track $#stack
d7732 1
a7732 1
    $doret = -2;
d7735 1
a7735 1
    $frame = 0;
d7763 1
a7763 1
    my ( $text, $line, $start ) = @@_;
d7768 2
a7769 2
    my ( $itext, $search, $prefix, $pack ) =
      ( $text, "^\Q${'package'}::\E([^:]+)\$" );
d7789 1
a7789 1
    return sort grep /^\Q$text/, ( keys %sub ),
d7791 2
a7792 2
      ( map { /$search/ ? ($1) : () } keys %sub )
      if ( substr $line, 0, $start ) =~ /^\|*[blc]\s+((postpone|compile)\s+)?$/;
d7802 1
a7802 1
      if ( substr $line, 0, $start ) =~ /^\|*b\s+load\s+$/;
d7816 3
a7818 3
    return sort map { ( $_, db_complete( $_ . "::", "V ", 2 ) ) }
      grep /^\Q$text/, map { /^(.*)::$/ ? ($1) : () } keys %::    # top-packages
      if ( substr $line, 0, $start ) =~ /^\|*[Vm]\s+$/ and $text =~ /^\w*$/;
d7829 1
a7829 1
    return sort map { ( $_, db_complete( $_ . "::", "V ", 2 ) ) }
d7831 4
a7834 4
      map { /^(.*)::$/ ? ( $prefix . "::$1" ) : () } keys %{ $prefix . '::' }
      if ( substr $line, 0, $start ) =~ /^\|*[Vm]\s+$/
      and $text =~ /^(.*[^:])::?(\w*)$/
      and $prefix = $1;
d7853 4
a7856 4
    if ( $line =~ /^\|*f\s+(.*)/ ) {    # Loaded files
           # We might possibly want to switch to an eval (which has a "filename"
           # like '(eval 9)'), so we may need to clean up the completion text
           # before proceeding.
d7870 1
a7870 1
          map { substr $_, 2 + $prefix } grep /^_<\Q$text/, ( keys %main:: ),
d7882 1
a7882 1
    if ( ( substr $text, 0, 1 ) eq '&' ) {    # subroutines
d7885 1
a7885 1
        return sort map "$prefix$_", grep /^\Q$text/, ( keys %sub ),
d7889 1
a7889 1
          );
d7898 1
a7898 1
    if ( $text =~ /^[\$@@%](.*)::(.*)/ ) {    # symbols in a package
d7908 1
a7908 1
        $pack = ( $1 eq 'main' ? '' : $1 ) . '::';
d7916 2
a7917 2
        $prefix = ( substr $text, 0, 1 ) . $1 . '::';
        $text   = $2;
d7934 2
a7935 2
        if ( @@out == 1 and $out[0] =~ /::$/ and $out[0] ne $itext ) {
            return db_complete( $out[0], $line, $start );
d7951 2
a7952 1
    if ( $text =~ /^[\$@@%]/ ) {    # symbols (in $package + packages in main)
d7962 1
a7962 1
        $pack = ( $package eq 'main' ? '' : $package ) . '::';
d7971 1
a7971 1
        $text   = substr $text, 1;
d7980 2
a7981 2
          ( grep /^_?[a-zA-Z]/, keys %$pack ),
          ( $pack eq '::' ? () : ( grep /::$/, keys %:: ) );
d7989 2
a7990 2
        if ( @@out == 1 and $out[0] =~ /::$/ and $out[0] ne $itext ) {
            return db_complete( $out[0], $line, $start );
d8007 4
a8010 4
    if ( ( substr $line, 0, $start ) =~ /^\|*[oO]\b.*\s$/ )
    {    # Options after space
           # We look for the text to be matched in the list of possible options,
           # and fetch the current value.
d8012 1
a8012 1
        my $val = option_val( $out[0], undef );
d8016 2
a8017 3
        if ( not defined $val or $val =~ /[\n\r]/ ) {

            # There's really nothing else we can do.
d8021 1
a8021 2
        elsif ( $val =~ /\s/ ) {

d8028 1
a8028 2
            foreach $l ( split //, qq/\"\'\#\|/ ) {

d8031 1
a8031 1
                $out = "$l$val$l ", last if ( index $val, $l ) == -1;
d8044 1
a8044 1
          ( @@out == 1 ? $out : '? ' );
d8084 1
a8084 1
    if ( defined($ini_pids) ) {
d8088 1
a8088 1
        delete( $ENV{PERLDB_PIDS} );
a8091 307
# PERLDBf_... flag names from perl.h
our ( %DollarCaretP_flags, %DollarCaretP_flags_r );

BEGIN {
    %DollarCaretP_flags = (
        PERLDBf_SUB       => 0x01,     # Debug sub enter/exit
        PERLDBf_LINE      => 0x02,     # Keep line #
        PERLDBf_NOOPT     => 0x04,     # Switch off optimizations
        PERLDBf_INTER     => 0x08,     # Preserve more data
        PERLDBf_SUBLINE   => 0x10,     # Keep subr source lines
        PERLDBf_SINGLE    => 0x20,     # Start with single-step on
        PERLDBf_NONAME    => 0x40,     # For _SUB: no name of the subr
        PERLDBf_GOTO      => 0x80,     # Report goto: call DB::goto
        PERLDBf_NAMEEVAL  => 0x100,    # Informative names for evals
        PERLDBf_NAMEANON  => 0x200,    # Informative names for anon subs
        PERLDBf_ASSERTION => 0x400,    # Debug assertion subs enter/exit
        PERLDB_ALL        => 0x33f,    # No _NONAME, _GOTO, _ASSERTION
    );

    %DollarCaretP_flags_r = reverse %DollarCaretP_flags;
}

sub parse_DollarCaretP_flags {
    my $flags = shift;
    $flags =~ s/^\s+//;
    $flags =~ s/\s+$//;
    my $acu = 0;
    foreach my $f ( split /\s*\|\s*/, $flags ) {
        my $value;
        if ( $f =~ /^0x([[:xdigit:]]+)$/ ) {
            $value = hex $1;
        }
        elsif ( $f =~ /^(\d+)$/ ) {
            $value = int $1;
        }
        elsif ( $f =~ /^DEFAULT$/i ) {
            $value = $DollarCaretP_flags{PERLDB_ALL};
        }
        else {
            $f =~ /^(?:PERLDBf_)?(.*)$/i;
            $value = $DollarCaretP_flags{ 'PERLDBf_' . uc($1) };
            unless ( defined $value ) {
                print $OUT (
                    "Unrecognized \$^P flag '$f'!\n",
                    "Acceptable flags are: "
                      . join( ', ', sort keys %DollarCaretP_flags ),
                    ", and hexadecimal and decimal numbers.\n"
                );
                return undef;
            }
        }
        $acu |= $value;
    }
    $acu;
}

sub expand_DollarCaretP_flags {
    my $DollarCaretP = shift;
    my @@bits         = (
        map {
            my $n = ( 1 << $_ );
            ( $DollarCaretP & $n )
              ? ( $DollarCaretP_flags_r{$n}
                  || sprintf( '0x%x', $n ) )
              : ()
          } 0 .. 31
    );
    return @@bits ? join( '|', @@bits ) : 0;
}

=item rerun

Rerun the current session to:

    rerun        current position

    rerun 4      command number 4

    rerun -4     current command minus 4 (go back 4 steps)

Whether this always makes sense, in the current context is unknowable, and is
in part left as a useful exersize for the reader.  This sub returns the
appropriate arguments to rerun the current session.

=cut

sub rerun {
    my $i = shift; 
    my @@args;
    pop(@@truehist);                      # strim
    unless (defined $truehist[$i]) {
        print "Unable to return to non-existent command: $i\n";
    } else {
        $#truehist = ($i < 0 ? $#truehist + $i : $i > 0 ? $i : $#truehist);
        my @@temp = @@truehist;            # store
        push(@@DB::typeahead, @@truehist); # saved
        @@truehist = @@hist = ();          # flush
        @@args = &restart();              # setup
        &get_list("PERLDB_HIST");        # clean
        &set_list("PERLDB_HIST", @@temp); # reset
    }
    return @@args;
}

=item restart

Restarting the debugger is a complex operation that occurs in several phases.
First, we try to reconstruct the command line that was used to invoke Perl
and the debugger.

=cut

sub restart {
    # I may not be able to resurrect you, but here goes ...
    print $OUT
"Warning: some settings and command-line options may be lost!\n";
    my ( @@script, @@flags, $cl );

    # If warn was on before, turn it on again.
    push @@flags, '-w' if $ini_warn;
    if ( $ini_assertion and @@{^ASSERTING} ) {
        push @@flags,
          ( map { /\:\^\(\?\:(.*)\)\$\)/ ? "-A$1" : "-A$_" }
              @@{^ASSERTING} );
    }

    # Rebuild the -I flags that were on the initial
    # command line.
    for (@@ini_INC) {
        push @@flags, '-I', $_;
    }

    # Turn on taint if it was on before.
    push @@flags, '-T' if ${^TAINT};

    # Arrange for setting the old INC:
    # Save the current @@init_INC in the environment.
    set_list( "PERLDB_INC", @@ini_INC );

    # If this was a perl one-liner, go to the "file"
    # corresponding to the one-liner read all the lines
    # out of it (except for the first one, which is going
    # to be added back on again when 'perl -d' runs: that's
    # the 'require perl5db.pl;' line), and add them back on
    # to the command line to be executed.
    if ( $0 eq '-e' ) {
        for ( 1 .. $#{'::_<-e'} ) {  # The first line is PERL5DB
            chomp( $cl = ${'::_<-e'}[$_] );
            push @@script, '-e', $cl;
        }
    } ## end if ($0 eq '-e')

    # Otherwise we just reuse the original name we had
    # before.
    else {
        @@script = $0;
    }

=pod

After the command line  has been reconstructed, the next step is to save
the debugger's status in environment variables. The C<DB::set_list> routine
is used to save aggregate variables (both hashes and arrays); scalars are
just popped into environment variables directly.

=cut

    # If the terminal supported history, grab it and
    # save that in the environment.
    set_list( "PERLDB_HIST",
          $term->Features->{getHistory}
        ? $term->GetHistory
        : @@hist );

    # Find all the files that were visited during this
    # session (i.e., the debugger had magic hashes
    # corresponding to them) and stick them in the environment.
    my @@had_breakpoints = keys %had_breakpoints;
    set_list( "PERLDB_VISITED", @@had_breakpoints );

    # Save the debugger options we chose.
    set_list( "PERLDB_OPT", %option );
    # set_list( "PERLDB_OPT", options2remember() );

    # Save the break-on-loads.
    set_list( "PERLDB_ON_LOAD", %break_on_load );

=pod 

The most complex part of this is the saving of all of the breakpoints. They
can live in an awful lot of places, and we have to go through all of them,
find the breakpoints, and then save them in the appropriate environment
variable via C<DB::set_list>.

=cut

    # Go through all the breakpoints and make sure they're
    # still valid.
    my @@hard;
    for ( 0 .. $#had_breakpoints ) {

        # We were in this file.
        my $file = $had_breakpoints[$_];

        # Grab that file's magic line hash.
        *dbline = $main::{ '_<' . $file };

        # Skip out if it doesn't exist, or if the breakpoint
        # is in a postponed file (we'll do postponed ones
        # later).
        next unless %dbline or $postponed_file{$file};

        # In an eval. This is a little harder, so we'll
        # do more processing on that below.
        ( push @@hard, $file ), next
          if $file =~ /^\(\w*eval/;

        # XXX I have no idea what this is doing. Yet.
        my @@add;
        @@add = %{ $postponed_file{$file} }
          if $postponed_file{$file};

        # Save the list of all the breakpoints for this file.
        set_list( "PERLDB_FILE_$_", %dbline, @@add );
    } ## end for (0 .. $#had_breakpoints)

    # The breakpoint was inside an eval. This is a little
    # more difficult. XXX and I don't understand it.
    for (@@hard) {
        # Get over to the eval in question.
        *dbline = $main::{ '_<' . $_ };
        my ( $quoted, $sub, %subs, $line ) = quotemeta $_;
        for $sub ( keys %sub ) {
            next unless $sub{$sub} =~ /^$quoted:(\d+)-(\d+)$/;
            $subs{$sub} = [ $1, $2 ];
        }
        unless (%subs) {
            print $OUT
              "No subroutines in $_, ignoring breakpoints.\n";
            next;
        }
      LINES: for $line ( keys %dbline ) {

            # One breakpoint per sub only:
            my ( $offset, $sub, $found );
          SUBS: for $sub ( keys %subs ) {
                if (
                    $subs{$sub}->[1] >=
                    $line    # Not after the subroutine
                    and (
                        not defined $offset    # Not caught
                        or $offset < 0
                    )
                  )
                {                              # or badly caught
                    $found  = $sub;
                    $offset = $line - $subs{$sub}->[0];
                    $offset = "+$offset", last SUBS
                      if $offset >= 0;
                } ## end if ($subs{$sub}->[1] >=...
            } ## end for $sub (keys %subs)
            if ( defined $offset ) {
                $postponed{$found} =
                  "break $offset if $dbline{$line}";
            }
            else {
                print $OUT
"Breakpoint in $_:$line ignored: after all the subroutines.\n";
            }
        } ## end for $line (keys %dbline)
    } ## end for (@@hard)

    # Save the other things that don't need to be
    # processed.
    set_list( "PERLDB_POSTPONE",  %postponed );
    set_list( "PERLDB_PRETYPE",   @@$pretype );
    set_list( "PERLDB_PRE",       @@$pre );
    set_list( "PERLDB_POST",      @@$post );
    set_list( "PERLDB_TYPEAHEAD", @@typeahead );

    # We are oficially restarting.
    $ENV{PERLDB_RESTART} = 1;

    # We are junking all child debuggers.
    delete $ENV{PERLDB_PIDS};    # Restore ini state

    # Set this back to the initial pid.
    $ENV{PERLDB_PIDS} = $ini_pids if defined $ini_pids;

=pod 

After all the debugger status has been saved, we take the command we built up
and then return it, so we can C<exec()> it. The debugger will spot the
C<PERLDB_RESTART> environment variable and realize it needs to reload its state
from the environment.

=cut

    # And run Perl again. Add the "-d" flag, all the
    # flags we built up, the script (whether a one-liner
    # or a file), add on the -emacs flag for a slave editor,
    # and then the old arguments. 

    return ($^X, '-d', @@flags, @@script, ($slave_editor ? '-emacs' : ()), @@ARGS);

};  # end restart

d8156 1
a8156 1
    if ( $cmd =~ /^(\d*)\s*(.*)/ ) {
d8163 1
a8163 1
        if ( length $j ) {
d8166 1
a8166 1
            if ( $dbline[$i] == 0 ) {
a8169 1

a8183 1

a8185 1

d8199 2
a8200 2
    my $xcmd   = shift;
    my $cmd    = shift;
d8204 1
a8204 1
    if ( $cmd =~ /^load\b\s*(.*)/ ) {
d8211 1
a8211 1
    # The interpreter actually traps this one for us; we just put the
d8213 1
a8213 2
    elsif ( $cmd =~ /^(postpone|compile)\b\s*([':A-Za-z_][':\w]*)\s*(.*)/ ) {

d8219 1
a8219 1
        my ( $subname, $break ) = ( $2, $1 eq 'postpone' );
d8229 1
a8229 1
        $subname = "main" . $subname if substr( $subname, 0, 2 ) eq "::";
d8236 1
a8236 1
    elsif ( $cmd =~ /^([':A-Za-z_][':\w]*(?:\[.*\])?)\s*(.*)/ ) {
d8239 1
a8239 1
        &cmd_b_sub( $subname, $cond );
d8243 1
a8243 1
    elsif ( $cmd =~ /^(\d*)\s*(.*)/ ) {
d8246 1
a8246 1
        &cmd_b_line( $i, $cond );
d8259 1
a8259 1
    if ( $cmd =~ /^\s*$/ ) {
d8265 1
a8265 2
        for $file ( keys %had_breakpoints ) {

d8273 1
a8273 2
            for ( $i = 1 ; $i <= $max ; $i++ ) {

d8275 1
a8275 2
                if ( defined $dbline{$i} ) {

d8278 1
a8278 2
                    if ( $dbline{$i} =~ s/^\0?$// ) {

d8286 1
a8286 1
            # bit, the entry in %had_breakpoints for this file is zero,
d8288 1
a8288 1
            if ( not $had_breakpoints{$file} &= ~1 ) {
d8313 1
a8313 1
    if ( $cmd =~ /^\s*$/ ) {
d8317 2
a8318 2
    # 'h h' - explicitly-requested summary.
    elsif ( $cmd =~ /^h\s*/ ) {
d8323 1
a8323 1
    elsif ( $cmd =~ /^h\s+(\S.*)$/ ) {
d8327 1
a8327 2
        if (
            $pre580_help =~ /^
d8331 1
a8331 3
                            /mx
          )
        {
d8342 2
a8343 3
                                  (?!\s)/mgx
              )    # Line not starting with space
                   # (Next command's help)
d8367 1
a8367 2
    if ( $cmd =~ /^$/ ) {

a8369 1

d8375 1
a8375 2
    elsif ( $cmd =~ /^(.*)/s ) {

d8379 1
a8379 1
        # Get the current value of the expression.
d8383 1
a8383 1
        $val = ( defined $val ) ? "'$val'" : 'undef';
d8426 1
a8426 2
sub cmd_prepost {
    my $cmd = shift;
d8437 1
a8437 1
    my $aref = [];
d8439 1
a8439 1
    # < - Perl code to run before prompt.
d8470 1
a8470 1
    # Yes.
a8471 1

a8474 1

a8478 1

d8491 1
a8491 2

                    # It's a delete. Get rid of the old actions in the
a8496 1

d8501 1
a8501 2
            elsif ( length($cmd) == 2 ) {

a8505 1

d8514 1
a8531 1

@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@d4 1
a4 1
perl5db.pl - the perl debugger
d43 1
a43 1
I<are> debugger internals, and are therefore subject to change. Future
d107 1
a107 1
the second pair applies when it is. The XOR simply allows us to
d115 1
a115 1
such as C<$single>, C<$trace>, and C<$frame>, have I<magical> values composed
a134 1
=item *
d136 1
a136 1
First, doing an arithmetical or bitwise operation on a scalar is
d138 1
a138 1
creates a subroutine call, and array and hash lookups are much slower. Is
d145 1
a145 3
=item *

Second, it's very easy to serialize a scalar number. This is done in 
d150 1
a150 3
=item *

Third, some of these variables are being shared with the Perl core 
d179 1
a179 1
considered to be a breakpoint; C<perl5db.pl> uses C<$break_condition\0$action>.
d182 1
a182 4
The scalar C<${"_<$filename"}> simply contains the string C<_<$filename>.
This is also the case for evaluated strings that contain subroutines, or
which are currently being executed.  The $filename for C<eval>ed strings looks
like C<(eval 34)> or C<(re_eval 19)>.
d193 1
a193 1
contents as the argument of a C<o> command in the debugger.
d210 1
a210 1
uses the value of noTTY or F</tmp/perldbtty$$> to find TTY using
d241 1
a241 1
reset C<LineInfo> to something I<interactive>!)
d248 1
a248 1
a C<&DB::DB();> in front of each place that can have a
d293 1
a293 1
=item * 1 - Print I<entering> messages on subroutine entry
d297 1
a297 1
=item * 4 - Extended messages: C<< <in|out> I<context>=I<fully-qualified sub name> from I<file>:I<line> >>. If no other flag is on, acts like 1+4.
d305 1
a305 1
To get everything, use C<$frame=30> (or C<o f=30> as a debugger command).
d333 1
a333 1
Controls how far down C<dumpvar.pl> will go before printing C<...> while
d351 1
a351 1
=item * 1 - single-step, go into subs. The C<s> command.
d353 1
a353 1
=item * 2 - single-step, don't go into subs. The C<n> command.
d355 2
a356 2
=item * 4 - print current sub depth (turned on to force this when C<too much
recursion> occurs.
d425 1
a425 1
Keys are line numbers, values are C<condition\0action>. If used in numeric
d454 1
a454 1
=item * C<compile> - break when this sub is compiled
d456 1
a456 1
=item * C<< break +0 if <condition> >> - break (conditionally) at the start of this routine. The condition will be '1' if no condition was specified.
d465 1
a465 1
definitions (C<condition\0action>).
d496 1
a496 1
$VERSION = 1.28;
d510 6
a515 6
Before we do the C<eval()>, we preserve the current settings of C<$trace>,
C<$single>, C<$^D> and C<$usercontext>.  The latter contains the
preserved values of C<$@@>, C<$!>, C<$^E>, C<$,>, C<$/>, C<$\>, C<$^W> and the
user's current package, grabbed when C<DB::DB> got control.  This causes the
proper context to be used when the eval is actually done.  Afterward, we
restore C<$trace>, C<$single>, and C<$^D>.
d522 2
a523 2
it on the debugger's output. If C<$onetimedump> is defined, we call 
C<dumpit> if it's set to 'dump', or C<methods> if it's set to 
d543 1
a543 1
=item C<$trace> - Current state of execution tracing
d545 1
a545 1
=item C<$single> - Current state of single-stepping
d682 8
a927 2
# Changes: 1.28: Oct 12, 2004 Richard Foley <richard.foley@@rfi.net>
#   + Added threads support (inc. e and E commands)
a964 45
=head2 THREADS SUPPORT

If we are running under a threaded Perl, we require threads and threads::shared
if the environment variable C<PERL5DB_THREADED> is set, to enable proper
threaded debugger control.  C<-dt> can also be used to set this.

Each new thread will be announced and the debugger prompt will always inform
you of each new thread created.  It will also indicate the thread id in which
we are currently running within the prompt like this:

	[tid] DB<$i>

Where C<[tid]> is an integer thread id and C<$i> is the familiar debugger
command prompt.  The prompt will show: C<[0]> when running under threads, but
not actually in a thread.  C<[tid]> is consistent with C<gdb> usage.

While running under threads, when you set or delete a breakpoint (etc.), this
will apply to all threads, not just the currently running one.  When you are 
in a currently executing thread, you will stay there until it completes.  With
the current implementation it is not currently possible to hop from one thread
to another.

The C<e> and C<E> commands are currently fairly minimal - see C<h e> and C<h E>.

Note that threading support was built into the debugger as of Perl version
C<5.8.6> and debugger version C<1.2.8>.

=cut

BEGIN {
  # ensure we can share our non-threaded variables or no-op
  if ($ENV{PERL5DB_THREADED}) {
	require threads;
	require threads::shared;
	import threads::shared qw(share);
	$DBGR;
	share(\$DBGR);
	lock($DBGR);
	print "Threads support enabled\n";
  } else {
	*lock  = sub(*) {};
	*share = sub(*) {};
  }
}

d970 1
a970 1
    # These variables control the execution of 'dumpvar.pl'.
a995 4
foreach my $k (keys (%INC)) {
	&share(\$main::{'_<'.$filename});
};

a1162 11
share($rl);
share($warnLevel);
share($dieLevel);
share($signalLevel);
share($pre);
share($post);
share($pretype);
share($rl);
share($CreateTTY);
share($CommandSet);

d1202 2
a1203 2
recall character (C<!> unless otherwise defined) and the shell escape
character (C<!> unless otherwise defined). Yes, these do conflict, and
d1231 1
a1231 1
The debugger I<greeting> helps to inform the user how many debuggers are
a1437 5
	share(@@hist);
	share(@@truehist);
	share(%break_on_load);
	share(%postponed);

a1473 1
	share($runnonstop);
d1528 1
a1528 3
Console> if not.

Note that Mac OS X returns C<darwin>, not C<MacOS>. Also note that the debugger doesn't do anything special for C<darwin>. Maybe it should.
a1686 2
	# share($LINEINFO); # <- unable to share globs
	share($lineinfo);   # 
d1747 1
a1747 1
to create other commands to be executed later. This is all highly I<optimized>
a1754 7
    # lock the debugger and get the thread id for the prompt
	lock($DBGR);
	my $tid;
	if ($ENV{PERL5DB_THREADED}) {
		$tid = eval { "[".threads->self->tid."]" };
	}

d1884 1
a1884 3
=item *

Returning a false value from the C<watchfunction()> itself.
d1886 1
a1886 1
=item *
d1888 1
a1888 1
Altering C<$single> to a false value.
d1890 1
a1890 7
=item *

Altering C<$signal> to a false value.

=item *

Turning off the C<4> bit in C<$trace> (this also disables the
d2074 2
a2075 2
C<$incr> controls by how many lines the I<current> line should move forward
after a command is executed. If set to -1, this indicates that the I<current>
d2078 1
a2078 1
C<$start> is the I<current> line. It is used for things like knowing where to
d2091 1
a2091 3
=item *

The outer part of the loop, starting at the C<CMD> label. This loop
d2094 1
a2094 3
=item *

The inner part of the loop, starting at the C<PIPE> label. This part
d2123 1
a2123 1
                        "$pidprompt $tid DB"
a2131 1
			share($cmd);
d2148 1
a2148 1
A newline entered by itself means I<re-execute the last command>. We grab the
a2161 2
			share(@@hist);
			share(@@truehist);
d2470 1
a2470 1
                $cmd =~ /^([aAbBeEhilLMoOPvwW]\b|[<>\{]{1,2})\s*(.*)/so && do {
d2531 1
a2531 1
when entered (see C<DB::sub>). We also save the C<n> command in C<$laststep>,
d2550 1
a2550 1
Sets C<$single> to 1, which causes C<DB::sub> to continue tracing inside     
d2883 1
a2883 1
that the terminal supports history). It find the the command required, puts it
d2928 1
a2928 1
If a command is found, it is placed in C<$cmd> and executed via C<redo>.
a3193 18
                    # Close all non-system fds for a clean restart.  A more
                    # correct method would be to close all fds that were not
                    # open when the process started, but this seems to be
                    # hard.  See "debugger 'R'estart and open database
                    # connections" on p5p.

                    my $max_fd = 1024; # default if POSIX can't be loaded
                    if (eval { require POSIX }) {
                        $max_fd = POSIX::sysconf(POSIX::_SC_OPEN_MAX());
                    }

                    if (defined $max_fd) {
                        foreach ($^F+1 .. $max_fd-1) {
                            next unless open FD_TO_CLOSE, "<&=$_";
                            close(FD_TO_CLOSE);
                        }
                    }

d3203 1
a3203 1
For C<|>, we save C<OUT> (the debugger's output filehandle) and C<STDOUT>
d3431 1
a3431 1
setting the C<4> bit in C<$single>. In any case, it keeps the current setting
d3455 1
a3455 1
The subroutine name; C<(eval)> if an C<eval>().
d3479 1
a3479 1
pragma information; subject to change between versions
a3490 3
	# lock ourselves under threads
	lock($DBGR);

a3494 3
	if ($sub =~ /^threads::new$/ && $ENV{PERL5DB_THREADED}) {
		print "creating new thread\n"; 
	}
d3683 2
a3684 2
Note that trying to set the CommandSet to C<foobar> simply results in the
5.8.0 command set being used, since there's no top-level entry for C<foobar>.
d3721 1
a3721 1
It tries to look up the command in the C<%set> package-level I<lexical>
d4027 1
a4027 1
initialized to C<"">, no filename will appear when we are working on the
d4034 1
a4034 1
=item *
d4036 1
a4036 1
Localizes C<$filename_error> and sets it to the name of the file to be processed.
d4038 1
a4038 1
=item *
d4040 1
a4040 7
Localizes the C<*dbline> glob and reassigns it to point to the file we want to process. 

=item *

Calls the first function. 

The first function works on the I<current> file (i.e., the one we changed to),
d4042 3
a4044 4
if it needs to. When the functions return, C<*dbline> is restored to point
to the actual current file (the one we're executing in) and
C<$filename_error> is restored to C<"">. This restores everything to
the way it was before the second function was called at all.
d4055 1
a4055 1
=head3 breakable_line(from, to) (API)
d4138 1
a4138 1
=head3 breakable_line_in_filename(file, from, to) (API)
a4496 47
=head3 C<cmd_e> - threads

Display the current thread id:

	e

This could be how (when implemented) to send commands to this thread id (e cmd)
or that thread id (e tid cmd).

=cut

sub cmd_e {
    my $cmd  = shift;
    my $line = shift;
	unless (exists($INC{'threads.pm'})) {
		print "threads not loaded($ENV{PERL5DB_THREADED})
		please run the debugger with PERL5DB_THREADED=1 set in the environment\n";
	} else {
		my $tid = threads->self->tid;
		print "thread id: $tid\n";
	}
} ## end sub cmd_e

=head3 C<cmd_E> - list of thread ids

Display the list of available thread ids:

	E

This could be used (when implemented) to send commands to all threads (E cmd).

=cut

sub cmd_E {
    my $cmd  = shift;
    my $line = shift;
	unless (exists($INC{'threads.pm'})) { 
		print "threads not loaded($ENV{PERL5DB_THREADED})
		please run the debugger with PERL5DB_THREADED=1 set in the environment\n";
	} else {
		my $tid = threads->self->tid;
		print "thread ids: ".join(', ', 
			map { ($tid == $_->tid ? '<'.$_->tid.'>' : $_->tid) } threads->list
		)."\n"; 
	}
} ## end sub cmd_E

d4503 1
a4503 1
=item *
d4505 1
a4505 5
Showing all the debugger help

=item *

Showing help for a specific command
d5073 1
a5073 1
the I<watching expressions> bit.
a5132 2
=over 4

a5136 2
=back

d5346 1
a5346 1
installed version in C<@@INC>, yours will be used instead. Possible security 
d5424 1
a5424 7
=item *

The filehandle to print to.

=item *

How many frames to skip before starting trace.
d5426 1
a5426 1
=item *
d5428 1
a5428 1
How many frames to print.
d5430 1
a5430 3
=item *

A flag: if true, print a I<short> trace without filenames, line numbers, or arguments
d5695 1
a5695 1
Of note is the definition of the C<$balanced_brace_re> global via C<||=>, which
d5720 1
a5720 1
it just reads more input with C<readline()> and returns it.
d6263 1
a6263 1
An option entered by itself is assumed to be I<set me to 1> (the default value)
d6265 1
a6265 1
value or to query the current value (via C<option? >).
d6267 1
a6267 1
If C<option=value> is entered, we try to extract a quoted string from the
d6449 1
a6449 1
get all confused if we do, particularily under I<unsafe signals>.
d6592 1
a6592 1
(essentially, no C<readline> processing on this I<terminal>). Otherwise, we
d6817 3
a6819 3
Essentially just runs through the keys in %INC, picks each package's
C<$VERSION> variable, gets the file name, and formats the information
for output.
d6857 2
a6858 2
The help message is a peculiar format unto itself; it mixes C<pod> I<ornaments>
(C<< B<> >> C<< I<> >>) with tabs to come up with a format that's fairly
d6862 3
a6864 4
Essentially, you define the command name (usually marked up with C<< B<> >>
and C<< I<> >>), followed by a tab, and then the descriptive text, ending in a
newline. The descriptive text can also be marked up in the same way. If you
need to continue the descriptive text to another line, start that line with
a6949 2
B<e>         Display current thread id.
B<E>         Display all thread ids the current one will be identified: <n>.
a7066 1
  B<e>     Display thread id     B<E> Display all thread ids.
d7252 1
a7252 1
C<Term::ReadLine::TermCap>).
d7595 1
a7595 1
Wrapper for C<CvGV_name_or_bust>; tries to get the name of a reference
d7597 1
a7597 1
reference is stringified, it'll come out as C<SOMETHING(0x...)>).
d7613 1
a7613 1
Returns C<< I<package>::I<glob name> >> if the code ref is found in a glob.
d7632 4
a7635 4
Tries to use C<@@sub> first; if it can't find it there, it tries building a
reference to the subroutine and uses C<CvGV_name_or_bust> to locate it,
loading it into C<@@sub> as a side effect (XXX I think). If it can't find it
this way, it brute-force searches C<%sub>, checking for identical references.
d7660 1
a7660 1
A subroutine that uses the utility function C<methods_via> to find all the
d7966 1
a7966 11
=item *

The debugger's own filehandles (copies of STD and STDOUT for now).

=item *

Characters for shell escapes, the recall command, and the history command.

=item *

The maximum recursion depth.
d7968 1
a7968 1
=item *
d7970 1
a7970 1
The size of a C<w> command's window.
d7972 1
a7972 1
=item *
d7974 1
a7974 1
The before-this-line context to be printed in a C<v> (view a window around this line) command.
d7976 1
a7976 1
=item *
d7978 1
a7978 1
The fact that we're not in a sub at all right now.
d7980 1
a7980 1
=item *
d7982 1
a7982 1
The default SIGINT handler for the debugger.
d7984 1
a7984 1
=item *
d7986 1
a7986 13
The appropriate value of the flag in C<$^D> that says the debugger is running

=item *

The current debugger recursion level

=item *

The list of postponed items and the C<$single> stack (XXX define this)

=item *

That we want no return values and no subroutine entry/exit trace.
d8095 1
a8095 1
=item *
d8097 1
a8097 1
Find all the subroutines that might match in this package
d8099 1
a8099 1
=item *
d8101 1
a8101 1
Add C<postpone>, C<load>, and C<compile> as possibles (we may be completing the keyword itself
d8103 1
a8103 11
=item *

Include all the rest of the subs that are known

=item *

C<grep> out the ones that match the text we have so far

=item *

Return this as the list of possible completions
d8116 1
a8116 1
Get all the possible files from C<@@INC> as it currently stands and
d8224 1
a8224 3
=item *

Determine the package that the symbol is in. Put it in C<::> (effectively C<main::>) if no package is specified.
d8232 1
a8232 3
=item *

Figure out the prefix vs. what needs completing.
d8241 1
a8241 3
=item *

Look through all the symbols in the package. C<grep> out all the possible hashes/arrays/scalars, and then C<grep> the possible matches out of those. C<map> the prefix onto all the possibilities.
d8250 1
a8250 3
=item *

If there's only one hit, and it's a package qualifier, and it's not equal to the initial text, re-complete it using the symbol we actually found.
d8277 1
a8277 3
=item *

If it's C<main>, delete main to just get C<::> leading.
d8285 1
a8285 3
=item *

We set the prefix to the item's sigil, and trim off the sigil to get the text to be completed.
d8294 1
a8294 3
=item *

If the package is C<::> (C<main>), create an empty list; if it's something else, create a list of all the packages known.  Append whichever list to a list of all the possible symbols in the current package. C<grep> out the matches to the text entered so far, then C<map> the prefix back onto the symbols.
d8302 1
a8302 3
=item *

If there's only one hit, it's a package qualifier, and it's not equal to the initial text, recomplete using this symbol.
a8483 2
=over 4

a8720 2
=back

d8734 1
a8734 1
We then call C<DB::fake::at_exit()>, which returns the C<Use 'q' to quit ...>
d8764 1
a8764 1
Does nothing. Used to I<turn off> commands.
d9063 1
a9063 1
Actually does all the handling for C<E<lt>>, C<E<gt>>, C<{{>, C<{>, etc.
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d218 1
a218 1
uses the value of noTTY or F<$HOME/.perldbtty$$> to find TTY using
d914 1
a914 1
#   + Added command to display parent inheritance tree of given class.
d2037 2
a2038 2
  use B<o> I<inhibit_exit> to avoid stopping after program termination,
  B<h q>, B<h R> or B<h o> to get additional info.  
d2746 1
a2746 1
                    # preceding block has moved us to the proper file and
d6007 2
a6008 2
            # Use $HOME/.perldbtty$$ if not.
            my $rv = $ENV{PERLDB_NOTTY} || "$ENV{HOME}/.perldbtty$$";
d6637 1
a6637 1
get all confused if we do, particularly under I<unsafe signals>.
d8315 1
a8315 1
Add C<postpone>, C<load>, and C<compile> as possibles (we may be completing the keyword itself)
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d224 1
a224 1
if false, a dummy ReadLine is used, so you can debug
a239 10
=item * HistFile

file to store session history to. There is no default and so no
history file is written unless this variable is explicitly set.

=item * HistSize

number of commands to store to the file specified in C<HistFile>.
Default is 100.

d501 1
a501 1
BEGIN {eval 'use IO::Handle'};	# Needed for flush only? breaks under miniperl
d504 1
a504 1
$VERSION = 1.30;
d930 1
a930 5
# Changes: 1.29: Nov 28, 2006 Bo Lindbergh <blgl@@hagernas.com> 
#   + Added macosx_get_fork_TTY support 
# Changes: 1.30: Mar 06, 2007 Andreas Koenig <andk@@cpan.org>
#   + Added HistFile, HistSize
########################################################################
d956 9
d1078 1
a1078 1
  CommandSet   HistFile      HistSize
d1091 1
a1091 1
  DollarCaretP
d1094 1
a1094 1
@@RememberOnROptions = qw(DollarCaretP);
d1123 1
a1123 2
    HistFile      => \$histfile,
    HistSize      => \$histsize,
d1152 1
d1238 1
a1238 1
environment first.  If it's not defined there, we try to find it in
d1320 3
a1322 15

    my $env_pids = $ENV{PERLDB_PIDS};
    $pids = "[$env_pids]";

    # Unless we are on OpenVMS, all programs under the DCL shell run under
    # the same PID.

    if (($^O eq 'VMS') && ($env_pids =~ /\b$$\b/)) {
        $term_pid         = $$;
    }
    else {
        $ENV{PERLDB_PIDS} .= "->$$";
        $term_pid = -1;
    }

d1330 1
a1330 1
    $pids             = "[pid=$$]";
d1433 1
a1433 1
the debugger only handles X Windows, OS/2, and Mac OS X (darwin).
d1439 2
a1440 1
# OS/2, or on Mac OS X. This may need some expansion.
d1442 8
a1449 1
if (not defined &get_fork_TTY)       # only if no routine exists
d1451 1
a1451 19
    if (defined $ENV{TERM}                       # If we know what kind
                                                 # of terminal this is,
        and $ENV{TERM} eq 'xterm'                # and it's an xterm,
        and defined $ENV{DISPLAY}                # and what display it's on,
      )
    {
        *get_fork_TTY = \&xterm_get_fork_TTY;    # use the xterm version
    }
    elsif ( $^O eq 'os2' ) {                     # If this is OS/2,
        *get_fork_TTY = \&os2_get_fork_TTY;      # use the OS/2 version
    }
    elsif ( $^O eq 'darwin'                      # If this is Mac OS X
            and defined $ENV{TERM_PROGRAM}       # and we're running inside
            and $ENV{TERM_PROGRAM}
                eq 'Apple_Terminal'              # Terminal.app
            )
    {
        *get_fork_TTY = \&macosx_get_fork_TTY;   # use the Mac OS X version
    }
d1453 3
d1712 1
a1712 1
            # outs to open. (They are assumed identical if not.)
d1831 1
a1831 1
		$tid = eval { "[".threads->tid."]" };
d2389 1
a2389 1
                    do 'dumpvar.pl' || die $@@ unless defined &main::dumpvar;
d2588 1
a2588 1
                    do 'dumpvar.pl' || die $@@ unless defined &main::dumpvar;
d3418 2
a3419 4
		eval {		# May run under miniperl, when not available...
                    STDOUT->flush();
                    STDERR->flush();
		};
d3614 1
a3614 1
    # If the last ten characters are '::AUTOLOAD', note we've traced
d3617 1
a3617 1
        $al = " for $$sub" if defined $$sub;
d3663 11
a3673 1
	@@ret = &$sub;
d3714 3
a3716 1
	if ( defined wantarray ) {
d3718 16
a3733 4
	    # Save the value if it's wanted at all.
	    $ret = &$sub;
	}
	else {
d3735 5
a3739 4
	    # Void return, explicitly.
	    &$sub;
	    undef $ret;
	}
d4640 1
a4640 1
		my $tid = threads->tid;
d4662 1
a4662 1
		my $tid = threads->tid;
d5309 32
d5564 1
a5564 1
        do 'dumpvar.pl' or die $@@;
a6045 2
    &load_hist();

a6055 28
sub load_hist {
    $histfile //= option_val("HistFile", undef);
    return unless defined $histfile;
    open my $fh, "<", $histfile or return;
    local $/ = "\n";
    @@hist = ();
    while (<$fh>) {
        chomp;
        push @@hist, $_;
    }
    close $fh;
}

sub save_hist {
    return unless defined $histfile;
    eval { require File::Path } or return;
    eval { require File::Basename } or return;
    File::Path::mkpath(File::Basename::dirname($histfile));
    open my $fh, ">", $histfile or die "Could not open '$histfile': $!";
    $histsize //= option_val("HistSize",100);
    my @@copy = grep { $_ ne '?' } @@hist;
    my $start = scalar(@@copy) > $histsize ? scalar(@@copy)-$histsize : 0;
    for ($start .. $#copy) {
        print $fh "$copy[$_]\n";
    }
    close $fh or die "Could not write '$histfile': $!";
}

d6069 3
a6071 4
The debugger provides C<get_fork_TTY> functions which work for X Windows,
OS/2, and Mac OS X. Other systems are not supported. You are encouraged
to write C<get_fork_TTY> functions which work for I<your> platform
and contribute them.
d6114 2
a6115 2
my $c_pipe = 0;
sub os2_get_fork_TTY { # A simplification of the following (and works without):
d6117 10
d6128 1
a6128 10
    my %opt = (	title => "Daughter Perl debugger $pids $name",
		($rl ? (read_by_key => 1) : ()) );
    require OS2::Process;
    my ($in, $out, $pid) = eval { OS2::Process::io_term(related => 0, %opt) }
      or return;
    $pidprompt = '';    # Shown anyway in titlebar
    reset_IN_OUT($in, $out);
    $tty = '*reset*';
    return '';          # Indicate that reset_IN_OUT is called
} ## end sub os2_get_fork_TTY
d6130 3
a6132 1
=head3 C<macosx_get_fork_TTY>
d6134 39
a6172 84
The Mac OS X version uses AppleScript to tell Terminal.app to create
a new window.

=cut

# Notes about Terminal.app's AppleScript support,
# (aka things that might break in future OS versions).
#
# The "do script" command doesn't return a reference to the new window
# it creates, but since it appears frontmost and windows are enumerated
# front to back, we can use "first window" === "window 1".
#
# Since "do script" is implemented by supplying the argument (plus a
# return character) as terminal input, there's a potential race condition
# where the debugger could beat the shell to reading the command.
# To prevent this, we wait for the screen to clear before proceeding.
#
# 10.3 and 10.4:
# There's no direct accessor for the tty device name, so we fiddle
# with the window title options until it says what we want.
#
# 10.5:
# There _is_ a direct accessor for the tty device name, _and_ there's
# a new possible component of the window title (the name of the settings
# set).  A separate version is needed.

my @@script_versions=

    ([237, <<'__LEOPARD__'],
tell application "Terminal"
    do script "clear;exec sleep 100000"
    tell first tab of first window
        copy tty to thetty
        set custom title to "forked perl debugger"
        set title displays custom title to true
        repeat while (length of first paragraph of (get contents)) > 0
            delay 0.1
        end repeat
    end tell
end tell
thetty
__LEOPARD__

     [100, <<'__JAGUAR_TIGER__'],
tell application "Terminal"
    do script "clear;exec sleep 100000"
    tell first window
        set title displays shell path to false
        set title displays window size to false
        set title displays file name to false
        set title displays device name to true
        set title displays custom title to true
        set custom title to ""
        copy "/dev/" & name to thetty
        set custom title to "forked perl debugger"
        repeat while (length of first paragraph of (get contents)) > 0
            delay 0.1
        end repeat
    end tell
end tell
thetty
__JAGUAR_TIGER__

);

sub macosx_get_fork_TTY
{
    my($version,$script,$pipe,$tty);

    return unless $version=$ENV{TERM_PROGRAM_VERSION};
    foreach my $entry (@@script_versions) {
	if ($version>=$entry->[0]) {
	    $script=$entry->[1];
	    last;
	}
    }
    return unless defined($script);
    return unless open($pipe,'-|','/usr/bin/osascript','-e',$script);
    $tty=readline($pipe);
    close($pipe);
    return unless defined($tty) && $tty =~ m(^/dev/);
    chomp $tty;
    return $tty;
}
d6222 3
a6224 4
  I know how to switch the output to a different window in xterms, OS/2
  consoles, and Mac OS X Terminal.app only.  For a manual switch, put the name
  of the created I<TTY> in B<\$DB::fork_TTY>, or define a function
  B<DB::get_fork_TTY()> returning this.
d6357 3
a6359 7
        $stuff;
        my $stuff = '';
        my $buf;
        do {
            $IN->recv( $buf = '', 2048 );   # XXX "what's wrong with sysread?"
                                            # XXX Don't know. You tell me.
        } while length $buf and ($stuff .= $buf) !~ /\n/;
a6720 13

    # With VMS we can get here with $term undefined, so we do not
    # switch to this terminal.  There may be a better place to make
    # sure that $term is defined on VMS
    if ( @@_ and ($^O eq 'VMS') and !defined($term) ) {
	eval { require Term::ReadLine } or die $@@;
        if ( !$rl ) {
	    $term = new Term::ReadLine::Stub 'perldb', $IN, $OUT;
	}
	else {
	    $term = new Term::ReadLine 'perldb', $IN, $OUT;
	}
    }
d6853 27
d7142 1
d7189 1
a7189 1
        Set options.  Use quotes if spaces in value.
d7365 1
a7365 1
        Set options.  Use quotes if spaces in value.
d8669 2
a8670 1
        PERLDB_ALL        => 0x33f,    # No _NONAME, _GOTO
d8776 5
d8992 2
a8993 6
    if ($fall_off_end or $runnonstop) {
        &save_hist();
    } else {
        $DB::single = 1;
        DB::fake::at_exit();
    }
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d514 1
a514 1
$VERSION = 1.32;
a943 8
# Changes: 1.31
#   + Remove support for assertions and -A
#   + stop NEXT::AUTOLOAD from emitting warnings under the debugger. RT #25053
#   + "update for Mac OS X 10.5" [finding the tty device]
#   + "What I needed to get the forked debugger to work" [on VMS]
#   + [perl #57016] debugger: o warn=0 die=0 ignored
#   + Note, but don't use, PERLDBf_SAVESRC
#   + Fix #7013: lvalue subs not working inside debugger
d1366 1
a1366 3
my $dev_tty = '/dev/tty';
   $dev_tty = 'TT:' if ($^O eq 'VMS');
if ( -e $dev_tty ) {                      # this is the wrong metric!
a3627 2
	# Do not use a regex in this subroutine -> results in corrupted memory
	# See: [perl #66110]
d3636 1
a3636 1
	if ($sub eq 'threads::new' && $ENV{PERL5DB_THREADED}) {
a3776 63
sub lsub : lvalue {

	# lock ourselves under threads
	lock($DBGR);

    # Whether or not the autoloader was running, a scalar to put the
    # sub's return value in (if needed), and an array to put the sub's
    # return value in (if needed).
    my ( $al, $ret, @@ret ) = "";
	if ($sub =~ /^threads::new$/ && $ENV{PERL5DB_THREADED}) {
		print "creating new thread\n";
	}

    # If the last ten characters are C'::AUTOLOAD', note we've traced
    # into AUTOLOAD for $sub.
    if ( length($sub) > 10 && substr( $sub, -10, 10 ) eq '::AUTOLOAD' ) {
        $al = " for $$sub";
    }

    # We stack the stack pointer and then increment it to protect us
    # from a situation that might unwind a whole bunch of call frames
    # at once. Localizing the stack pointer means that it will automatically
    # unwind the same amount when multiple stack frames are unwound.
    local $stack_depth = $stack_depth + 1;    # Protect from non-local exits

    # Expand @@stack.
    $#stack = $stack_depth;

    # Save current single-step setting.
    $stack[-1] = $single;

    # Turn off all flags except single-stepping.
    $single &= 1;

    # If we've gotten really deeply recursed, turn on the flag that will
    # make us stop with the 'deep recursion' message.
    $single |= 4 if $stack_depth == $deep;

    # If frame messages are on ...
    (
        $frame & 4    # Extended frame entry message
        ? (
            print_lineinfo( ' ' x ( $stack_depth - 1 ), "in  " ),

            # Why -1? But it works! :-(
            # Because print_trace will call add 1 to it and then call
            # dump_trace; this results in our skipping -1+1 = 0 stack frames
            # in dump_trace.
            print_trace( $LINEINFO, -1, 1, 1, "$sub$al" )
          )
        : print_lineinfo( ' ' x ( $stack_depth - 1 ), "entering $sub$al\n" )

          # standard frame entry message
      )
      if $frame;

    # Pop the single-step value back off the stack.
    $single |= $stack[ $stack_depth-- ];

    # call the original lvalue sub.
    &$sub;
}

a6102 10
    # We need $term defined or we can not switch to the newly created xterm
    if ($tty ne '' && !defined $term) {
        eval { require Term::ReadLine } or die $@@;
        if ( !$rl ) {
            $term = new Term::ReadLine::Stub 'perldb', $IN, $OUT;
        }
        else {
            $term = new Term::ReadLine 'perldb', $IN, $OUT;
        }
    }
d6769 12
a7737 2
        } else {
            undef $SIG{__WARN__};
a7778 3
        } else {
            undef $SIG{__DIE__};
            print $OUT "Die handler removed.\n";
a7924 1
    my @@to_print;
d7926 5
a7930 14
    # Extract from all the symbols in this class.
    while (my ($name, $glob) = each %{"${class}::"}) {
	# references directly in the symbol table are Proxy Constant
	# Subroutines, and are by their very nature defined
	# Otherwise, check if the thing is a typeglob, and if it is, it decays
	# to a subroutine reference, which can be tested by defined.
	# $glob might also be the value -1  (from sub foo;)
	# or (say) '$$' (from sub foo ($$);)
	# \$glob will be SCALAR in both cases.
	if ((ref $glob || ($glob && ref \$glob eq 'GLOB' && defined &$glob))
	    && !$seen{$name}++) {
	    push @@to_print, "$prepend$name\n";
	}
    }
d7932 3
d7936 9
a7944 4
	local $\ = '';
	local $, = '';
	print $DB::OUT $_ foreach sort @@to_print;
    }
a8700 1
        PERLDBf_SAVESRC   => 0x400,    # Save source lines into @@{"_<$filename"}
a8702 3
    # PERLDBf_LINE also enables the actions of PERLDBf_SAVESRC, so the debugger
    # doesn't need to set it. It's provided for the benefit of profilers and
    # other code analysers.
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@d514 1
a514 1
$VERSION = '1.33';
a951 3
# Changes: 1.32: Jun 03, 2009 Jonathan Leto <jonathan@@leto.net>
#   + Fix bug where a key _< with undefined value was put into the symbol table
#   +   when the $filename variable is not set
a1055 1
# without threads, $filename is not defined until DB::DB is called
d1057 1
a1057 1
	&share(\$main::{'_<'.$filename}) if defined $filename;
d1849 1
a1849 1
them, and then send execution off to the next statement.
d4834 24
a4857 15
    foreach my $isa ( split( /\s+/, $line ) ) {
        $evalarg = $isa;
        ($isa) = &eval;
        no strict 'refs';
        print join(
            ', ',
            map {
                "$_"
                  . (
                    defined( ${"$_\::VERSION"} )
                    ? ' ' . ${"$_\::VERSION"}
                    : undef )
              } @@{mro::get_linear_isa(ref($isa) || $isa)}
        );
        print "\n";
d8182 1
d8185 1
d8200 1
d8616 1
a8639 26
        my @@out;

=pod

=item *

We look for the lexical scope above DB::DB and auto-complete lexical variables
if PadWalker could be loaded.

=cut

        if (not $text =~ /::/ and eval "require PadWalker; 1" and not $@@ ) {
            my $level = 1;
            while (1) {
                my @@info = caller($level);
                $level++;
                $level = -1, last
                  if not @@info;
                last if $info[3] eq 'DB::DB';
            }
            if ($level > 0) {
                my $lexicals = PadWalker::peek_my($level);
                push @@out, grep /^\Q$prefix$text/, keys %$lexicals;
            }
        }

d8648 1
a8648 1
        push @@out, map "$prefix$_", grep /^\Q$text/,
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d176 3
a178 5
The array C<@@{$main::{'_<'.$filename}}> (aliased locally to C<@@dbline>
via glob assignment) contains the text from C<$filename>, with each
element corresponding to a single line of C<$filename>. Additionally,
breakable lines will be dualvars with the numeric component being the
memory address of a COP node. Non-breakable lines are dualvar to 0.
a512 6
BEGIN {
    require feature;
    $^V =~ /^v(\d+\.\d+)/;
    feature->import(":$1");
}

d514 1
a514 1
$VERSION = '1.37';
d707 248
d973 1
a973 1
# compilation. Probably it would be better practice to fix the warnings,
a1080 3
# Default to 1 so the prompt will display the first line.
$trace_to_depth = 1;

d1464 1
a1464 2
the debugger only handles TCP sockets, X11, OS/2, amd Mac OS X
(darwin).
d1474 1
a1474 5
    if ( defined $remoteport ) {                 
                                                 # Expect an inetd-like server
        *get_fork_TTY = \&socket_get_fork_TTY;   # to listen to us
    }
    elsif (defined $ENV{TERM}                    # If we know what kind
d1545 3
a1547 13
    for my $file_idx ( 0 .. $#had_breakpoints ) {
        my $filename = $had_breakpoints[$file_idx];
        my %pf = get_list("PERLDB_FILE_$file_idx");
        $postponed_file{ $filename } = \%pf if %pf;
        my @@lines = sort {$a <=> $b} keys(%pf);
        my @@enabled_statuses = get_list("PERLDB_FILE_ENABLED_$file_idx");
        for my $line_idx (0 .. $#lines) {
            _set_breakpoint_enabled_status(
                $filename,
                $lines[$line_idx],
                ($enabled_statuses[$line_idx] ? 1 : ''),
            );
        }
d1633 17
d1719 8
a1726 1
        $IN = $OUT = connect_remoteport();
d1820 1
a1820 1
"\nEnter h or 'h h' for help, or '$doccmd perldebug' for more help.\n\n";
d1926 7
a1937 1
        && _is_breakpoint_enabled($filename, $line)
d1951 1
a1951 4
            # If the breakpoint is temporary, then delete its enabled status.
            if ($dbline{$line} =~ s/;9($|\0)/$1/) {
                _cancel_breakpoint_temp_enabled_status($filename, $line);
            }
a2048 4
    # Make sure that we always print if asked for explicitly regardless
    # of $trace_to_depth .
    my $explicit_stop = ($single || $was_signal);

d2051 1
a2051 1
    if ( $explicit_stop || ( $trace & 1 ) ) {
a2095 1

d2123 1
a2123 1
                depth_print_lineinfo($explicit_stop, $position);
d2151 1
a2151 1
                    depth_print_lineinfo($explicit_stop, $incr_pos);
d2327 1
a2327 1
                        print $OUT "Couldn't evaluate '$i' alias: $@@";
d2351 1
a2351 1
=head4 C<t> - trace [n]
a2353 1
If level is specified, set C<$trace_to_depth>.
d2357 1
a2357 2
                $cmd =~ /^t(?:\s+(\d+))?$/ && do {
                    my $levels = $1;
a2359 1
                    $trace_to_depth = $levels ? $stack_depth + $levels : 1E9;
d2361 1
a2361 3
                      . ( ( $trace & 1 )
                      ? ( $levels ? "on (to level $trace_to_depth)" : "on" )
                      : "off" ) . "\n";
d2518 1
a2518 1
                                print $OUT "Choosing $try matching '$file':\n";
d2526 1
a2526 1
                        print $OUT "No file matching '$file' is loaded.\n";
a2801 1
                        _enable_breakpoint_temp_enabled_status($filename, $i);
d2824 1
a2824 1
                    # Can't do anything if the program's over.
d3240 1
a3240 1
                        # Messy metaquoting: Trim the substitution code off.
d3279 1
a3279 1
                        &warn("Can't execute '$1': $!\n");
a3283 32
                $cmd =~ /^(enable|disable)\s+(\S+)\s*$/ && do {
                    my ($cmd, $position) = ($1, $2);

                    my ($fn, $line_num);
                    if ($position =~ m{\A\d+\z})
                    {
                        $fn = $filename;
                        $line_num = $position;
                    }
                    elsif ($position =~ m{\A(.*):(\d+)\z})
                    {
                        ($fn, $line_num) = ($1, $2);
                    }
                    else
                    {
                        &warn("Wrong spec for enable/disable argument.\n");
                    }

                    if (defined($fn)) {
                        if (_has_breakpoint_data_ref($fn, $line_num)) {
                            _set_breakpoint_enabled_status($fn, $line_num,
                                ($cmd eq 'enable' ? 1 : '')
                            );
                        }
                        else {
                            &warn("No breakpoint set at ${fn}:${line_num}\n");
                        }
                    }

                    next CMD;
                };

d3334 1
a3334 1
                        eval { $max_fd = POSIX::sysconf(POSIX::_SC_OPEN_MAX()) };
d3387 1
a3387 1
                        &warn("Can't pipe output to '$pager'");
d3432 1
a3432 3
                $cmd =~ s/^t\s+(\d+)?/\$DB::trace |= 1;\n/ && do {
                    $trace_to_depth = $1 ? $stack_depth||0 + $1 : 1E9;
                };
d3491 1
a3491 1
                        print SAVEOUT "Pager '$pager' failed: ";
d3545 1
a3545 1
        $fall_off_end = 1 unless defined $cmd;    # Emulate 'q' on EOF
d3699 1
a3699 1
    # Determine the sub's return type, and capture appropriately.
d3763 1
a3763 1
            $frame & 4    # Extended messages
a3855 7
# Abstracting common code from multiple places elsewhere:
sub depth_print_lineinfo {
    my $always_print = shift;

    print_lineinfo( @@_ ) if ($always_print or $stack_depth < $trace_to_depth);
}

a3913 68
my %breakpoints_data;

sub _has_breakpoint_data_ref {
    my ($filename, $line) = @@_;

    return (
        exists( $breakpoints_data{$filename} )
            and
        exists( $breakpoints_data{$filename}{$line} )
    );
}

sub _get_breakpoint_data_ref {
    my ($filename, $line) = @@_;

    return ($breakpoints_data{$filename}{$line} ||= +{});
}

sub _delete_breakpoint_data_ref {
    my ($filename, $line) = @@_;

    delete($breakpoints_data{$filename}{$line});
    if (! scalar(keys( %{$breakpoints_data{$filename}} )) ) {
        delete($breakpoints_data{$filename});
    }

    return;
}

sub _set_breakpoint_enabled_status {
    my ($filename, $line, $status) = @@_;

    _get_breakpoint_data_ref($filename, $line)->{'enabled'} =
        ($status ? 1 : '')
        ;

    return;
}

sub _enable_breakpoint_temp_enabled_status {
    my ($filename, $line) = @@_;

    _get_breakpoint_data_ref($filename, $line)->{'temp_enabled'} = 1;

    return;
}

sub _cancel_breakpoint_temp_enabled_status {
    my ($filename, $line) = @@_;

    my $ref = _get_breakpoint_data_ref($filename, $line);
    
    delete ($ref->{'temp_enabled'});

    if (! %$ref) {
        _delete_breakpoint_data_ref($filename, $line);
    }

    return;
}

sub _is_breakpoint_enabled {
    my ($filename, $line) = @@_;

    my $data_ref = _get_breakpoint_data_ref($filename, $line);
    return ($data_ref->{'enabled'} || $data_ref->{'temp_enabled'});
}

d4086 1
a4086 1
    $line =~ s/^\.(\s|\z)/$dbline$1/;
d4124 1
a4124 9
    # b <filename>:<line> [<condition>]
    elsif ($line =~ /\A(\S+[^:]):(\d+)\s*(.*)/ms) {
        my ($filename, $line_num, $cond) = ($1, $2, $3);
        cmd_b_filename_line(
            $filename,
            $line_num, 
            (length($cond) ? $cond : '1'),
        );
    }
d4213 1
a4213 1
    print $OUT "Will stop on load of '@@files'.\n";
d4358 1
a4358 1
    local $filename_error = " of '$f'";
a4400 2

        _set_breakpoint_enabled_status($filename, $i, 1);
a4417 14
=head3 cmd_b_filename_line(line, [condition]) (command)

Wrapper for C<break_on_filename_line>. Prints the failure message if it 
doesn't work.

=cut 

sub cmd_b_filename_line {
    eval { break_on_filename_line(@@_); 1 } or do {
        local $\ = '';
        print $OUT $@@ and return;
    };
}

d4435 1
a4435 1
    local $filename_error = " of '$f'";
a4630 2
    my $fn = $filename;

d4641 1
a4641 4
        if ($dbline{$i} eq '') {
            delete $dbline{$i};
            _delete_breakpoint_data_ref($fn, $i);
        }
a4669 1
                        _delete_breakpoint_data_ref($file, $i);
d5480 1
a5480 1
    #print $OUT "In postponed_sub for '$subname'.\n";
d5527 1
a5527 1
    # "Cannot be done: insufficient magic" - we can't just put the
d5710 1
a5710 1
        $file = $file eq '-e' ? $file : "file '$file'" unless $short;
d6025 1
a6025 1
    require Term::ReadLine;
d6032 2
a6033 2
            open( IN,  "<$i" ) or die "Cannot open TTY '$i' for read: $!";
            open( OUT, ">$o" ) or die "Cannot open TTY '$o' for write: $!";
d6043 1
a6043 1
            require Term::Rendezvous;
d6050 1
a6050 1
            my $term_rv = Term::Rendezvous->new( $rv );
d6063 1
a6063 1
        $term = Term::ReadLine::Stub->new( 'perldb', $IN, $OUT );
d6068 1
a6068 1
        $term = Term::ReadLine->new( 'perldb', $IN, $OUT );
d6138 4
a6141 31
The debugger provides C<get_fork_TTY> functions which work for TCP
socket servers, X11, OS/2, and Mac OS X. Other systems are not
supported. You are encouraged to write C<get_fork_TTY> functions which
work for I<your> platform and contribute them.

=head3 C<socket_get_fork_TTY>

=cut 

sub connect_remoteport {
    require IO::Socket;

    my $socket = IO::Socket::INET->new(
        Timeout  => '10',
        PeerAddr => $remoteport,
        Proto    => 'tcp',
    );
    if ( ! $socket ) {
        die "Unable to connect to remote host: $remoteport\n";
    }
    return $socket;
}

sub socket_get_fork_TTY {
    $tty = $LINEINFO = $IN = $OUT = connect_remoteport();

    # Do I need to worry about setting $term?

    reset_IN_OUT( $IN, $OUT );
    return '';
}
d6145 1
a6145 1
This function provides the C<get_fork_TTY> function for X11. If a 
d6175 1
a6175 1
        require Term::ReadLine;
d6177 1
a6177 1
            $term = Term::ReadLine::Stub->new( 'perldb', $IN, $OUT );
d6180 1
a6180 1
            $term = Term::ReadLine->new( 'perldb', $IN, $OUT );
d6476 1
a6476 1
        # Send anything we have to send.
d6613 1
a6613 1
        s/^(\w+)(\W?)// or print( $OUT "Invalid option '$_'\n" ), last;
d6620 2
a6621 2
        print( $OUT "Unknown option '$opt'\n" ), next unless $matches;
        print( $OUT "Ambiguous option '$opt'\n" ), next if $matches > 1;
d6626 1
a6626 1
            print( $OUT "Option query '$opt?' followed by non-space '$_'\n" ),
d6664 1
a6664 1
              or print( $OUT "Unclosed option value '$opt$sep$_'\n" ), last;
d6672 1
a6672 1
"Option '$opt' is non-boolean.  Use '$cmd $option=VAL' to set, '$cmd $option?' to query\n";
d6685 1
a6685 1
               } || die $@@   # XXX: shouldn't happen
d6813 1
a6813 1
        &warn("Too late to set IN/OUT filehandles, enabled on next 'R'!\n");
d6868 2
a6869 2
        open IN,  $in     or die "cannot open '$in' for read: $!";
        open OUT, ">$out" or die "cannot open '$out' for write: $!";
d6880 1
a6880 1
    &warn("Too late to set TTY, enabled on next 'R'!\n") if $term and @@_;
d6899 1
a6899 1
        &warn("Too late to set noTTY, enabled on next 'R'!\n") if @@_;
d6916 1
a6916 1
        &warn("Too late to set ReadLine, enabled on next 'R'!\n") if @@_;
d6965 1
a6965 1
        &warn("Too late to set up NonStop mode, enabled on next 'R'!\n")
d7089 1
a7089 1
    open( LINEINFO, "$stream" ) || &warn("Cannot open '$stream' for write");
d7201 2
a7202 2
B<t> [I<n>]       Toggle trace mode (to max I<n> levels below current stack depth).
B<t> [I<n>] I<expr>        Trace through execution of I<expr>.
d7277 1
a7277 1
B<||>I<dbcmd>        Same as B<|>I<dbcmd> but DB::OUT is temporarily select()ed as well.
d7318 1
a7318 1
    B<R> after you set them).
d7328 1
a7328 1
Type '|h h' for a paged display if this was too hard to read.
d7342 1
a7342 1
  B<o> [...]     Set debugger options        B<t> [I<n>] [I<expr>] Toggle trace [max depth] ][trace expr]
d7393 2
a7394 2
B<t> [I<n>]       Toggle trace mode (to max I<n> levels below current stack depth) .
B<t> [I<n>] I<expr>        Trace through execution of I<expr>.
d7401 1
a7401 1
B<b> B<load> I<filename> Set breakpoint on 'require'ing the given file.
d7494 1
a7494 1
    B<R> after you set them).
d7503 1
a7503 1
Type '|h' for a paged display if this was too hard to read.
d7602 1
a7602 1
C<$fixed_less> so we don't have to go through doing the stats again.
d7609 1
a7609 1
    return if $fixed_less;
d7628 1
a7628 1
    $fixed_less = 1 if $is_less;
d7762 1
a7762 1
    # The code used to check $^S to see if compilation of the current thing
d8043 1
a8043 1
    $doccmd = $^O !~ /^(?:MSWin32|VMS|os2|dos|amigaos|riscos|NetWare)\z/s
d8118 1
d8642 1
a8642 1
        if (not $text =~ /::/ and eval { require PadWalker } ) {
d8764 1
a8764 1
    print $OUT "Use 'q' to quit or 'R' to restart.  'h q' for details.\n";
d8869 1
a8869 1
in part left as a useful exercise for the reader.  This sub returns the
a9006 7

        # Serialize the extra data %breakpoints_data hash.
        # That's a bug fix.
        set_list( "PERLDB_FILE_ENABLED_$_", 
            map { _is_breakpoint_enabled($file, $_) ? 1 : 0 }
            sort { $a <=> $b } keys(%dbline)
        )
d9063 1
a9063 1
    # We are officially restarting.
d9249 1
d9475 1
a9475 1
"$cmd is now a debugger command\nuse ';$cmd' if you mean Perl code\n";
d9552 1
a9552 1
    "Debugged program terminated.  Use 'q' to quit or 'R' to restart.";
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d2 1
a2 1
=head1 NAME
d25 1
a25 1
features was done using global variables, globs and the C<local()> operator
d37 1
a37 1
debugger itself.
d49 1
a49 1
As you may recall from reading C<perlfunc>, the C<local()> operator makes a
d51 1
a51 1
old copy is restored. This is often used in the debugger to handle the
d62 1
a62 1
then altered. When the subroutine returns, Perl automatically undoes the
d65 1
a65 1
The debugger uses this trick a I<lot>. Of particular note is C<DB::eval>,
d69 1
a69 1
value of C<$@@> is restored. This makes it simple (well, I<simpler>) to keep
d76 1
a76 1
This is used to cleverly reverse the sense of a logical test depending on
d78 1
a78 1
(search for subroutines by pattern) allows you to negate the pattern
d82 1
a82 1
   S !/foo/
d88 1
a88 1
=item * 0 ^ 0 = 0
d92 1
a92 1
=item * 0 ^ 1 = 1
d96 1
a96 1
=item * 1 ^ 0 = 1
d100 1
a100 1
=item * 1 ^ 1 = 0
d108 1
a108 1
compact a more complicated if-then-elseif-else into a more elegant
d117 1
a117 1
of state to be stored independently in a single scalar.
d123 1
a123 1
is checking to see if the appropriate bit is on. Since each bit can be
d125 1
a125 1
an array of bits. Obviously, since the contents of C<$scalar> are just a
d130 1
a130 1
all over your program whenever a bit is set, cleared, or checked. So why do
d140 1
a140 1
this over-optimization at the expense of readability? Possibly, but the
d143 1
a143 1
best balance of readability and speed, and then document how it actually
d148 1
a148 1
Second, it's very easy to serialize a scalar number. This is done in
d151 1
a151 1
this trivial.
d155 3
a157 3
Third, some of these variables are being shared with the Perl core
smack in the middle of the interpreter's execution loop. It's much faster for
a C program (like the interpreter) to check a bit in a scalar than to access
d165 1
a165 1
speculative - it's not exactly clear what a given variable or chunk of
d171 1
a171 1
=head1 DATA STRUCTURES MAINTAINED BY CORE
d182 3
a184 3
The hash C<%{'_<'.$filename}> (aliased locally to C<%dbline> via glob
assignment) contains breakpoints and actions.  The keys are line numbers;
you can set individual values, but not the whole hash. The Perl interpreter
d189 1
a189 1
The scalar C<${"_<$filename"}> simply contains the string C<$filename>.
d192 1
a192 1
like C<(eval 34).
d199 1
a199 1
that will be executed (in the debugger's context) after the debugger has
d202 1
a202 1
Next, it checks the C<PERLDB_OPTS> environment variable and treats its
d213 1
a213 1
=item * TTY
d217 1
a217 1
=item * noTTY
d224 1
a224 1
=item * ReadLine
d229 1
a229 1
=item * NonStop
d233 1
a233 1
=item * LineInfo
d238 1
a238 1
=item * RemotePort
d282 1
a282 1
used for input.
d284 1
a284 1
=over
d307 1
a307 1
is entered or exited.
d331 2
a332 2
Tracks current debugger nesting level. Used to figure out how many
C<E<lt>E<gt>> pairs to surround the line number with when the debugger
d367 1
a367 1
=over 4
d382 1
a382 1
Controls the output of trace information.
d405 1
a405 1
Local alias to the magical line array, C<@@{$main::{'_<'.$filename}}> ,
d453 1
a453 1
=over 4
d490 2
a491 2
package. This is because there are several BEGIN blocks (which of course
execute immediately) spread through the code. Why is that?
d493 1
a493 1
The debugger needs to be able to change some things and set some things up
d503 1
a503 1
The third one puts C<$^X> back to its former value.
d513 1
a513 3
use strict;

BEGIN {eval 'use IO::Handle'}; # Needed for flush only? breaks under miniperl
d522 1
a522 3
use vars qw($VERSION $header);

$VERSION = '1.39_10';
d533 1
a533 1
The code to be evaluated is passed via the package global variable
d544 2
a545 2
local lexical, localize C<$saved[0]> (which is where C<save()> will put
C<$@@>), and then call C<save()> to capture C<$@@>, C<$!>, C<$^E>, C<$,>,
d547 5
a551 5
considered sane by the debugger. If there was an C<eval()> error, we print
it on the debugger's output. If C<$onetimedump> is defined, we call
C<dumpit> if it's set to 'dump', or C<methods> if it's set to
'methods'. Setting it to something else causes the debugger to do the eval
but not print the result - handy if you want to do something else with it
d555 2
a556 2
In any case, we then return the list of output from C<eval> to the caller,
and unwinding restores the former version of C<$@@> in C<@@saved> as well
d563 1
a563 1
The variables listed below influence C<DB::eval()>'s execution directly.
d573 1
a573 1
=item C<$onetimeDump> - what is to be displayed after the evaluation
d580 1
a580 1
are "stacked" via C<local()>, enabling recursive calls to C<DB::eval()>.
d588 1
a588 1
=item C<$osingle> - saved value of C<$single>.
d594 1
a594 1
=item $\ - for output of C<$@@> if there is an evaluation error.
d603 1
a603 1
debugger globals are used.
a622 82
use vars qw(
    @@args
    %break_on_load
    $CommandSet
    $CreateTTY
    $DBGR
    @@dbline
    $dbline
    %dbline
    $dieLevel
    $filename
    $histfile
    $histsize
    $IN
    $inhibit_exit
    @@ini_INC
    $ini_warn
    $maxtrace
    $od
    @@options
    $osingle
    $otrace
    $pager
    $post
    %postponed
    $prc
    $pre
    $pretype
    $psh
    @@RememberOnROptions
    $remoteport
    @@res
    $rl
    @@saved
    $signalLevel
    $sub
    $term
    $usercontext
    $warnLevel
);

our (
    @@cmdfhs,
    $evalarg,
    $frame,
    $hist,
    $ImmediateStop,
    $line,
    $onetimeDump,
    $onetimedumpDepth,
    %option,
    $OUT,
    $packname,
    $signal,
    $single,
    $start,
    %sub,
    $subname,
    $trace,
    $window,
);

# Used to save @@ARGV and extract any debugger-related flags.
use vars qw(@@ARGS);

# Used to prevent multiple entries to diesignal()
# (if for instance diesignal() itself dies)
use vars qw($panic);

# Used to prevent the debugger from running nonstop
# after a restart
our ($second_time);

sub _calc_usercontext {
    my ($package) = @@_;

    # Cancel strict completely for the evaluated code, so the code
    # the user evaluates won't be affected by it. (Shlomi Fish)
    return 'no strict; ($@@, $!, $^E, $,, $/, $\, $^W) = @@DB::saved;'
    . "package $package;";    # this won't let them modify, alas
}

d753 1
a753 1
    [tid] DB<$i>
d760 1
a760 1
will apply to all threads, not just the currently running one.  When you are
d773 45
a817 34
    # ensure we can share our non-threaded variables or no-op
    if ($ENV{PERL5DB_THREADED}) {
        require threads;
        require threads::shared;
        import threads::shared qw(share);
        $DBGR;
        share(\$DBGR);
        lock($DBGR);
        print "Threads support enabled\n";
    } else {
        *share = sub(\[$@@%]) {};
    }
}

# These variables control the execution of 'dumpvar.pl'.
{
    package dumpvar;
    use vars qw(
    $hashDepth
    $arrayDepth
    $dumpDBFiles
    $dumpPackages
    $quoteHighBit
    $printUndef
    $globPrint
    $usageOnly
    );
}

# used to control die() reporting in diesignal()
{
    package Carp;
    use vars qw($CarpLevel);
}
d820 3
a822 1
share($main::{'_<'.$filename}) if defined $filename;
d841 2
a842 4
use vars qw($trace_to_depth);

# Default to 1E9 so it won't be limited to a certain recursion depth.
$trace_to_depth = 1E9;
d846 2
a847 2
The debugger's options are actually spread out over the debugger itself and
C<dumpvar.pl>; some of these are variables to be set, while others are
a882 2
use vars qw(%optionVars);

d912 1
a912 3
=cut

use vars qw(%optionAction);
a946 2
use vars qw(%optionRequire);

d1054 2
a1055 2
recallCommand("!") unless defined $prc;
shellBang("!")     unless defined $psh;
a1092 1
use vars qw($ini_pids);
a1094 2
use vars qw ($pids $term_pid);

a1125 1
use vars qw($pidprompt);
a1128 1
our ($slave_editor);
d1133 1
a1133 1
The debugger will read a file of initialization options if supplied. If
d1136 1
a1136 1
=cut
d1141 7
a1147 5
use vars qw($rcfile);
{
    my $dev_tty = (($^O eq 'VMS') ? 'TT:' : '/dev/tty');
    # this is the wrong metric!
    $rcfile = ((-e $dev_tty) ? ".perldb" : "perldb.ini");
d1174 1
a1174 1
        You or the superuser must be the owner, and it must not
d1238 1
a1238 1
    if ( defined $remoteport ) {
d1278 1
a1278 1
  PERLDB_RESTART   - flag only, contains no restart data itself.
d1296 1
a1296 1
use vars qw(%postponed_file @@typeahead);
d1298 2
a1299 1
our (@@hist, @@truehist);
d1301 1
a1301 2
sub _restore_shared_globals_after_restart
{
d1306 4
a1309 7
    share(@@hist);
    share(@@truehist);
    share(%break_on_load);
    share(%postponed);
}

sub _restore_breakpoints_and_actions {
d1311 1
a1312 1

d1328 4
a1331 8
    return;
}

sub _restore_options_after_restart
{
    my %options_map = get_list("PERLDB_OPT");

    while ( my ( $opt, $val ) = each %options_map ) {
a1335 5
    return;
}

sub _restore_globals_after_restart
{
a1344 19

    return;
}


if ( exists $ENV{PERLDB_RESTART} ) {

    # We're restarting, so we don't need the flag that says to restart anymore.
    delete $ENV{PERLDB_RESTART};

    # $restart = 1;
    _restore_shared_globals_after_restart();

    _restore_breakpoints_and_actions();

    # restore options
    _restore_options_after_restart();

    _restore_globals_after_restart();
a1354 14
use vars qw($notty $console $tty $LINEINFO);
use vars qw($lineinfo $doccmd);

our ($runnonstop);

# Local autoflush to avoid rt#116769,
# as calling IO::File methods causes an unresolvable loop
# that results in debugger failure.
sub _autoflush {
    my $o = select($_[0]);
    $|++;
    select($o);
}

d1357 1
a1357 1
    share($runnonstop);
d1373 3
a1375 4
    if ($slave_editor = ( @@main::ARGV && ( $main::ARGV[0] eq '-emacs' ) )) {
        $rl = 0;
        shift(@@main::ARGV);
    }
d1395 1
a1395 1
=item * Unix - use F</dev/tty>.
d1427 1
a1427 1
with a slave editor).
d1450 5
d1463 1
a1463 1
=head2 SOCKET HANDLING
d1535 1
a1535 4
        if ($console or (not defined($console))) {
            $IN = \*IN;
            $OUT = \*OUT;
        }
d1539 3
a1541 1
    _autoflush($OUT);
d1549 2
a1550 2
    # share($LINEINFO); # <- unable to share globs
    share($lineinfo);   #
d1582 1
a1582 1
# for (@@args) {
d1587 1
a1587 1
# }
d1592 1
a1592 1
    afterinit();
a1595 2
use vars qw($I_m_init);

d1617 58
a1674 1
# $cmd cannot be an our() variable unfortunately (possible perl bug?).
d1676 3
a1678 12
use vars qw(
    $action
    $cmd
    $file
    $filename_ini
    $finished
    %had_breakpoints
    $level
    $max
    $package
    $try
);
d1680 2
a1681 14
our (
    %alias,
    $doret,
    $end,
    $fall_off_end,
    $incr,
    $laststep,
    $rc,
    $sh,
    $stack_depth,
    @@stack,
    @@to_watch,
    @@old_watch,
);
a1682 2
sub _DB__determine_if_we_should_break
{
a1683 4
    # $stop is lexical and local to this block - $action on the other hand
    # is global.
    my $stop;

d1686 1
a1686 1
        && (( $stop, $action ) = split( /\0/, $dbline{$line} ) ) )
d1698 1
a1698 2
            # The &-call is here to ascertain the mutability of @@_.
            &DB::eval;
a1704 1
}
d1706 9
a1714 9
sub _DB__is_finished {
    if ($finished and $level <= 1) {
        end_report();
        return 1;
    }
    else {
        return;
    }
}
d1716 4
a1719 3
sub _DB__read_next_cmd
{
    my ($tid) = @@_;
d1721 2
a1722 4
    # We have a terminal, or can get one ...
    if (!$term) {
        setterm();
    }
d1724 11
a1734 4
    # ... and it belogs to this PID or we get one for this PID ...
    if ($term_pid != $$) {
        resetterm(1);
    }
d1736 1
a1736 7
    # ... and we got a line of command input ...
    $cmd = DB::readline(
        "$pidprompt $tid DB"
        . ( '<' x $level )
        . ( $#hist + 1 )
        . ( '>' x $level ) . " "
    );
d1738 3
a1740 2
    return defined($cmd);
}
d1742 3
a1744 2
sub _DB__trim_command_and_return_first_component {
    my ($obj) = @@_;
d1746 3
a1748 2
    $cmd =~ s/\A\s+//s;    # trim annoying leading whitespace
    $cmd =~ s/\s+\z//s;    # trim annoying trailing whitespace
d1750 1
a1750 1
    my ($verb, $args) = $cmd =~ m{\A(\S*)\s*(.*)}s;
d1752 1
a1752 2
    $obj->cmd_verb($verb);
    $obj->cmd_args($args);
d1754 1
a1754 2
    return;
}
d1756 1
a1756 2
sub _DB__handle_f_command {
    my ($obj) = @@_;
d1758 1
a1758 19
    if ($file = $obj->cmd_args) {
        # help for no arguments (old-style was return from sub).
        if ( !$file ) {
            print $OUT
            "The old f command is now the r command.\n";    # hint
            print $OUT "The new f command switches filenames.\n";
            next CMD;
        } ## end if (!$file)

        # if not in magic file list, try a close match.
        if ( !defined $main::{ '_<' . $file } ) {
            if ( ($try) = grep( m#^_<.*$file#, keys %main:: ) ) {
                {
                    $try = substr( $try, 2 );
                    print $OUT "Choosing $try matching '$file':\n";
                    $file = $try;
                }
            } ## end if (($try) = grep(m#^_<.*$file#...
        } ## end if (!defined $main::{ ...
d1760 1
a1760 5
        # If not successfully switched now, we failed.
        if ( !defined $main::{ '_<' . $file } ) {
            print $OUT "No file matching '$file' is loaded.\n";
            next CMD;
        }
d1762 1
a1762 8
        # We switched, so switch the debugger internals around.
        elsif ( $file ne $filename ) {
            *dbline   = $main::{ '_<' . $file };
            $max      = $#dbline;
            $filename = $file;
            $start    = 1;
            $cmd      = "l";
        } ## end elsif ($file ne $filename)
d1764 1
a1764 6
        # We didn't switch; say we didn't.
        else {
            print $OUT "Already in $file.\n";
            next CMD;
        }
    }
d1766 2
a1767 2
    return;
}
d1769 1
a1769 2
sub _DB__handle_dot_command {
    my ($obj) = @@_;
d1771 1
a1771 14
    # . command.
    if ($obj->_is_full('.')) {
        $incr = -1;    # stay at current line

        # Reset everything to the old location.
        $start    = $line;
        $filename = $filename_ini;
        *dbline   = $main::{ '_<' . $filename };
        $max      = $#dbline;

        # Now where are we?
        print_lineinfo($obj->position());
        next CMD;
    }
d1773 1
a1773 2
    return;
}
d1775 10
a1784 2
sub _DB__handle_y_command {
    my ($obj) = @@_;
d1786 4
a1789 2
    if (my ($match_level, $match_vars)
        = $obj->cmd_args =~ /\A(?:(\d*)\s*(.*))?\z/) {
d1791 1
a1791 10
        # See if we've got the necessary support.
        if (!eval { require PadWalker; PadWalker->VERSION(0.08) }) {
            my $Err = $@@;
            _db_warn(
                $Err =~ /locate/
                ? "PadWalker module not found - please install\n"
                : $Err
            );
            next CMD;
        }
d1793 4
a1796 5
        # Load up dumpvar if we don't have it. If we can, that is.
        do 'dumpvar.pl' || die $@@ unless defined &main::dumpvar;
        defined &main::dumpvar
            or print $OUT "dumpvar.pl not available.\n"
            and next CMD;
d1798 1
a1798 2
        # Got all the modules we need. Find them and print them.
        my @@vars = split( ' ', $match_vars || '' );
d1800 3
a1802 2
        # Find the pad.
        my $h = eval { PadWalker::peek_my( ( $match_level || 0 ) + 1 ) };
d1804 3
a1806 6
        # Oops. Can't find it.
        if (my $Err = $@@) {
            $Err =~ s/ at .*//;
            _db_warn($Err);
            next CMD;
        }
d1808 2
a1809 2
        # Show the desired vars with dumplex().
        my $savout = select($OUT);
d1811 3
a1813 5
        # Have dumplex dump the lexicals.
        foreach my $key (sort keys %$h) {
            dumpvar::dumplex( $key, $h->{$key},
                defined $option{dumpDepth} ? $option{dumpDepth} : -1,
                @@vars );
a1814 4
        select($savout);
        next CMD;
    }
}
d1816 1
a1816 2
sub _DB__handle_c_command {
    my ($obj) = @@_;
d1818 3
a1820 1
    my $i = $obj->cmd_args;
d1822 1
a1822 1
    if ($i =~ m#\A[\w:]*\z#) {
d1824 1
a1824 3
        # Hey, show's over. The debugged program finished
        # executing already.
        next CMD if _DB__is_finished();
d1826 7
a1832 2
        # Capture the place to put a one-time break.
        $subname = $i;
d1834 6
a1839 47
        #  Probably not needed, since we finish an interactive
        #  sub-session anyway...
        # local $filename = $filename;
        # local *dbline = *dbline; # XXX Would this work?!
        #
        # The above question wonders if localizing the alias
        # to the magic array works or not. Since it's commented
        # out, we'll just leave that to speculation for now.

        # If the "subname" isn't all digits, we'll assume it
        # is a subroutine name, and try to find it.
        if ( $subname =~ /\D/ ) {    # subroutine name
            # Qualify it to the current package unless it's
            # already qualified.
            $subname = $package . "::" . $subname
            unless $subname =~ /::/;

            # find_sub will return "file:line_number" corresponding
            # to where the subroutine is defined; we call find_sub,
            # break up the return value, and assign it in one
            # operation.
            ( $file, $i ) = ( find_sub($subname) =~ /^(.*):(.*)$/ );

            # Force the line number to be numeric.
            $i = $i + 0;

            # If we got a line number, we found the sub.
            if ($i) {

                # Switch all the debugger's internals around so
                # we're actually working with that file.
                $filename = $file;
                *dbline   = $main::{ '_<' . $filename };

                # Mark that there's a breakpoint in this file.
                $had_breakpoints{$filename} |= 1;

                # Scan forward to the first executable line
                # after the 'sub whatever' line.
                $max = $#dbline;
                my $_line_num = $i;
                while ($dbline[$_line_num] == 0 && $_line_num< $max)
                {
                    $_line_num++;
                }
                $i = $_line_num;
            } ## end if ($i)
d1841 1
a1841 6
            # We didn't find a sub by that name.
            else {
                print $OUT "Subroutine $subname not found.\n";
                next CMD;
            }
        } ## end if ($subname =~ /\D/)
d1843 3
a1845 22
        # At this point, either the subname was all digits (an
        # absolute line-break request) or we've scanned through
        # the code following the definition of the sub, looking
        # for an executable, which we may or may not have found.
        #
        # If $i (which we set $subname from) is non-zero, we
        # got a request to break at some line somewhere. On
        # one hand, if there wasn't any real subroutine name
        # involved, this will be a request to break in the current
        # file at the specified line, so we have to check to make
        # sure that the line specified really is breakable.
        #
        # On the other hand, if there was a subname supplied, the
        # preceding block has moved us to the proper file and
        # location within that file, and then scanned forward
        # looking for the next executable line. We have to make
        # sure that one was found.
        #
        # On the gripping hand, we can't do anything unless the
        # current value of $i points to a valid breakable line.
        # Check that.
        if ($i) {
d1847 1
a1847 5
            # Breakable?
            if ( $dbline[$i] == 0 ) {
                print $OUT "Line $i not breakable.\n";
                next CMD;
            }
d1849 1
a1849 4
            # Yes. Set up the one-time-break sigil.
            $dbline{$i} =~ s/($|\0)/;9$1/;  # add one-time-only b.p.
            _enable_breakpoint_temp_enabled_status($filename, $i);
        } ## end if ($i)
a1850 6
        # Turn off stack tracing from here up.
        for my $j (0 .. $stack_depth) {
            $stack[ $j ] &= ~1;
        }
        last CMD;
    }
d1852 20
a1871 2
    return;
}
d1873 8
a1880 2
sub _DB__handle_forward_slash_command {
    my ($obj) = @@_;
d1882 4
a1885 2
    # The pattern as a string.
    use vars qw($inpat);
d1887 2
a1888 1
    if (($inpat) = $cmd =~ m#\A/(.*)\z#) {
d1890 2
a1891 2
        # Remove the final slash.
        $inpat =~ s:([^\\])/$:$1:;
d1893 3
a1895 2
        # If the pattern isn't null ...
        if ( $inpat ne "" ) {
d1897 4
a1900 3
            # Turn of warn and die procesing for a bit.
            local $SIG{__DIE__};
            local $SIG{__WARN__};
d1902 3
a1904 292
            # Create the pattern.
            eval 'no strict q/vars/; $inpat =~ m' . "\a$inpat\a";
            if ( $@@ ne "" ) {

                # Oops. Bad pattern. No biscuit.
                # Print the eval error and go back for more
                # commands.
                print {$OUT} "$@@";
                next CMD;
            }
            $obj->pat($inpat);
        } ## end if ($inpat ne "")

        # Set up to stop on wrap-around.
        $end = $start;

        # Don't move off the current line.
        $incr = -1;

        my $pat = $obj->pat;

        # Done in eval so nothing breaks if the pattern
        # does something weird.
        eval
        {
            no strict q/vars/;
            for (;;) {
                # Move ahead one line.
                ++$start;

                # Wrap if we pass the last line.
                if ($start > $max) {
                    $start = 1;
                }

                # Stop if we have gotten back to this line again,
                last if ($start == $end);

                # A hit! (Note, though, that we are doing
                # case-insensitive matching. Maybe a qr//
                # expression would be better, so the user could
                # do case-sensitive matching if desired.
                if ($dbline[$start] =~ m/$pat/i) {
                    if ($slave_editor) {
                        # Handle proper escaping in the slave.
                        print {$OUT} "\032\032$filename:$start:0\n";
                    }
                    else {
                        # Just print the line normally.
                        print {$OUT} "$start:\t",$dbline[$start],"\n";
                    }
                    # And quit since we found something.
                    last;
                }
            }
        };

        if ($@@) {
            warn $@@;
        }

        # If we wrapped, there never was a match.
        if ( $start == $end ) {
            print {$OUT} "/$pat/: not found\n";
        }
        next CMD;
    }

    return;
}

sub _DB__handle_question_mark_command {
    my ($obj) = @@_;

    # ? - backward pattern search.
    if (my ($inpat) = $cmd =~ m#\A\?(.*)\z#) {

        # Get the pattern, remove trailing question mark.
        $inpat =~ s:([^\\])\?$:$1:;

        # If we've got one ...
        if ( $inpat ne "" ) {

            # Turn off die & warn handlers.
            local $SIG{__DIE__};
            local $SIG{__WARN__};
            eval '$inpat =~ m' . "\a$inpat\a";

            if ( $@@ ne "" ) {

                # Ouch. Not good. Print the error.
                print $OUT $@@;
                next CMD;
            }
            $obj->pat($inpat);
        } ## end if ($inpat ne "")

        # Where we are now is where to stop after wraparound.
        $end = $start;

        # Don't move away from this line.
        $incr = -1;

        my $pat = $obj->pat;
        # Search inside the eval to prevent pattern badness
        # from killing us.
        eval {
            no strict q/vars/;
            for (;;) {
                # Back up a line.
                --$start;

                # Wrap if we pass the first line.

                $start = $max if ($start <= 0);

                # Quit if we get back where we started,
                last if ($start == $end);

                # Match?
                if ($dbline[$start] =~ m/$pat/i) {
                    if ($slave_editor) {
                        # Yep, follow slave editor requirements.
                        print $OUT "\032\032$filename:$start:0\n";
                    }
                    else {
                        # Yep, just print normally.
                        print $OUT "$start:\t",$dbline[$start],"\n";
                    }

                    # Found, so done.
                    last;
                }
            }
        };

        # Say we failed if the loop never found anything,
        if ( $start == $end ) {
            print {$OUT} "?$pat?: not found\n";
        }
        next CMD;
    }

    return;
}

sub _DB__handle_restart_and_rerun_commands {
    my ($obj) = @@_;

    my $cmd_cmd = $obj->cmd_verb;
    my $cmd_params = $obj->cmd_args;
    # R - restart execution.
    # rerun - controlled restart execution.
    if ($cmd_cmd eq 'rerun' or $cmd_params eq '') {
        my @@args = ($cmd_cmd eq 'R' ? restart() : rerun($cmd_params));

        # Close all non-system fds for a clean restart.  A more
        # correct method would be to close all fds that were not
        # open when the process started, but this seems to be
        # hard.  See "debugger 'R'estart and open database
        # connections" on p5p.

        my $max_fd = 1024; # default if POSIX can't be loaded
        if (eval { require POSIX }) {
            eval { $max_fd = POSIX::sysconf(POSIX::_SC_OPEN_MAX()) };
        }

        if (defined $max_fd) {
            foreach ($^F+1 .. $max_fd-1) {
                next unless open FD_TO_CLOSE, "<&=$_";
                close(FD_TO_CLOSE);
            }
        }

        # And run Perl again.  We use exec() to keep the
        # PID stable (and that way $ini_pids is still valid).
        exec(@@args) or print {$OUT} "exec failed: $!\n";

        last CMD;
    }

    return;
}

sub _DB__handle_run_command_in_pager_command {
    my ($obj) = @@_;

    if ($cmd =~ m#\A\|\|?\s*[^|]#) {
        if ( $pager =~ /^\|/ ) {

            # Default pager is into a pipe. Redirect I/O.
            open( SAVEOUT, ">&STDOUT" )
            || _db_warn("Can't save STDOUT");
            open( STDOUT, ">&OUT" )
            || _db_warn("Can't redirect STDOUT");
        } ## end if ($pager =~ /^\|/)
        else {

            # Not into a pipe. STDOUT is safe.
            open( SAVEOUT, ">&OUT" ) || _db_warn("Can't save DB::OUT");
        }

        # Fix up environment to record we have less if so.
        fix_less();

        unless ( $obj->piped(scalar ( open( OUT, $pager ) ) ) ) {

            # Couldn't open pipe to pager.
            _db_warn("Can't pipe output to '$pager'");
            if ( $pager =~ /^\|/ ) {

                # Redirect I/O back again.
                open( OUT, ">&STDOUT" )    # XXX: lost message
                || _db_warn("Can't restore DB::OUT");
                open( STDOUT, ">&SAVEOUT" )
                || _db_warn("Can't restore STDOUT");
                close(SAVEOUT);
            } ## end if ($pager =~ /^\|/)
            else {

                # Redirect I/O. STDOUT already safe.
                open( OUT, ">&STDOUT" )    # XXX: lost message
                || _db_warn("Can't restore DB::OUT");
            }
            next CMD;
        } ## end unless ($piped = open(OUT,...

        # Set up broken-pipe handler if necessary.
        $SIG{PIPE} = \&DB::catch
        if $pager =~ /^\|/
        && ( "" eq $SIG{PIPE} || "DEFAULT" eq $SIG{PIPE} );

        _autoflush(\*OUT);
        # Save current filehandle, and put it back.
        $obj->selected(scalar( select(OUT) ));
        # Don't put it back if pager was a pipe.
        if ($cmd !~ /\A\|\|/)
        {
            select($obj->selected());
            $obj->selected("");
        }

        # Trim off the pipe symbols and run the command now.
        $cmd =~ s#\A\|+\s*##;
        redo PIPE;
    }

    return;
}

sub _DB__handle_m_command {
    my ($obj) = @@_;

    if ($cmd =~ s#\Am\s+([\w:]+)\s*\z# #) {
        methods($1);
        next CMD;
    }

    # m expr - set up DB::eval to do the work
    if ($cmd =~ s#\Am\b# #) {    # Rest gets done by DB::eval()
        $onetimeDump = 'methods';   #  method output gets used there
    }

    return;
}

sub _DB__at_end_of_every_command {
    my ($obj) = @@_;

    # At the end of every command:
    if ($obj->piped) {

        # Unhook the pipe mechanism now.
        if ( $pager =~ /^\|/ ) {

            # No error from the child.
            $? = 0;

            # we cannot warn here: the handle is missing --tchrist
            close(OUT) || print SAVEOUT "\nCan't close DB::OUT\n";

            # most of the $? crud was coping with broken cshisms
            # $? is explicitly set to 0, so this never runs.
            if ($?) {
                print SAVEOUT "Pager '$pager' failed: ";
                if ( $? == -1 ) {
                    print SAVEOUT "shell returned -1\n";
                }
                elsif ( $? >> 8 ) {
                    print SAVEOUT ( $? & 127 )
                    ? " (SIG#" . ( $? & 127 ) . ")"
                    : "", ( $? & 128 ) ? " -- core dumped" : "", "\n";
d1907 1
a1907 1
                    print SAVEOUT "status ", ( $? >> 8 ), "\n";
d1909 2
a1910 247
            } ## end if ($?)

            # Reopen filehandle for our output (if we can) and
            # restore STDOUT (if we can).
            open( OUT, ">&STDOUT" ) || _db_warn("Can't restore DB::OUT");
            open( STDOUT, ">&SAVEOUT" )
            || _db_warn("Can't restore STDOUT");

            # Turn off pipe exception handler if necessary.
            $SIG{PIPE} = "DEFAULT" if $SIG{PIPE} eq \&DB::catch;

            # Will stop ignoring SIGPIPE if done like nohup(1)
            # does SIGINT but Perl doesn't give us a choice.
        } ## end if ($pager =~ /^\|/)
        else {

            # Non-piped "pager". Just restore STDOUT.
            open( OUT, ">&SAVEOUT" ) || _db_warn("Can't restore DB::OUT");
        }

        # Close filehandle pager was using, restore the normal one
        # if necessary,
        close(SAVEOUT);

        if ($obj->selected() ne "") {
            select($obj->selected);
            $obj->selected("");
        }

        # No pipes now.
        $obj->piped("");
    } ## end if ($piped)

    return;
}

sub _DB__handle_watch_expressions
{
    my $self = shift;

    if ( $DB::trace & 2 ) {
        for my $n (0 .. $#DB::to_watch) {
            $DB::evalarg = $DB::to_watch[$n];
            local $DB::onetimeDump;    # Tell DB::eval() to not output results

            # Fix context DB::eval() wants to return an array, but
            # we need a scalar here.
            my ($val) = join( "', '", DB::eval(@@_) );
            $val = ( ( defined $val ) ? "'$val'" : 'undef' );

            # Did it change?
            if ( $val ne $DB::old_watch[$n] ) {

                # Yep! Show the difference, and fake an interrupt.
                $DB::signal = 1;
                print {$DB::OUT} <<EOP;
Watchpoint $n:\t$DB::to_watch[$n] changed:
    old value:\t$DB::old_watch[$n]
    new value:\t$val
EOP
                $DB::old_watch[$n] = $val;
            } ## end if ($val ne $old_watch...
        } ## end for my $n (0 ..
    } ## end if ($trace & 2)

    return;
}

# 't' is type.
# 'm' is method.
# 'v' is the value (i.e: method name or subroutine ref).
# 's' is subroutine.
my %cmd_lookup =
(
    '-' => { t => 'm', v => '_handle_dash_command', },
    '.' => { t => 's', v => \&_DB__handle_dot_command, },
    '=' => { t => 'm', v => '_handle_equal_sign_command', },
    'H' => { t => 'm', v => '_handle_H_command', },
    'S' => { t => 'm', v => '_handle_S_command', },
    'T' => { t => 'm', v => '_handle_T_command', },
    'W' => { t => 'm', v => '_handle_W_command', },
    'c' => { t => 's', v => \&_DB__handle_c_command, },
    'f' => { t => 's', v => \&_DB__handle_f_command, },
    'm' => { t => 's', v => \&_DB__handle_m_command, },
    'n' => { t => 'm', v => '_handle_n_command', },
    'p' => { t => 'm', v => '_handle_p_command', },
    'q' => { t => 'm', v => '_handle_q_command', },
    'r' => { t => 'm', v => '_handle_r_command', },
    's' => { t => 'm', v => '_handle_s_command', },
    'save' => { t => 'm', v => '_handle_save_command', },
    'source' => { t => 'm', v => '_handle_source_command', },
    't' => { t => 'm', v => '_handle_t_command', },
    'w' => { t => 'm', v => '_handle_w_command', },
    'x' => { t => 'm', v => '_handle_x_command', },
    'y' => { t => 's', v => \&_DB__handle_y_command, },
    (map { $_ => { t => 'm', v => '_handle_V_command_and_X_command', }, }
        ('X', 'V')),
    (map { $_ => { t => 'm', v => '_handle_enable_disable_commands', }, }
        qw(enable disable)),
    (map { $_ =>
        { t => 's', v => \&_DB__handle_restart_and_rerun_commands, },
        } qw(R rerun)),
    (map { $_ => {t => 'm', v => '_handle_cmd_wrapper_commands' }, }
    qw(a A b B e E h i l L M o O P v w W)),
);

sub DB {

    # lock the debugger and get the thread id for the prompt
    lock($DBGR);
    my $tid;
    my $position;
    my ($prefix, $after, $infix);
    my $pat;
    my $explicit_stop;
    my $piped;
    my $selected;

    if ($ENV{PERL5DB_THREADED}) {
        $tid = eval { "[".threads->tid."]" };
    }

    my $cmd_verb;
    my $cmd_args;

    my $obj = DB::Obj->new(
        {
            position => \$position,
            prefix => \$prefix,
            after => \$after,
            explicit_stop => \$explicit_stop,
            infix => \$infix,
            cmd_args => \$cmd_args,
            cmd_verb => \$cmd_verb,
            pat => \$pat,
            piped => \$piped,
            selected => \$selected,
        },
    );

    $obj->_DB_on_init__initialize_globals(@@_);

    # Preserve current values of $@@, $!, $^E, $,, $/, $\, $^W.
    # The code being debugged may have altered them.
    DB::save();

    # Since DB::DB gets called after every line, we can use caller() to
    # figure out where we last were executing. Sneaky, eh? This works because
    # caller is returning all the extra information when called from the
    # debugger.
    local ( $package, $filename, $line ) = caller;
    $filename_ini = $filename;

    # set up the context for DB::eval, so it can properly execute
    # code on behalf of the user. We add the package in so that the
    # code is eval'ed in the proper package (not in the debugger!).
    local $usercontext = _calc_usercontext($package);

    # Create an alias to the active file magical array to simplify
    # the code here.
    local (*dbline) = $main::{ '_<' . $filename };

    # Last line in the program.
    $max = $#dbline;

    # The &-call is here to ascertain the mutability of @@_.
    &_DB__determine_if_we_should_break;

    # Preserve the current stop-or-not, and see if any of the W
    # (watch expressions) has changed.
    my $was_signal = $signal;

    # If we have any watch expressions ...
    _DB__handle_watch_expressions($obj);

=head2 C<watchfunction()>

C<watchfunction()> is a function that can be defined by the user; it is a
function which will be run on each entry to C<DB::DB>; it gets the
current package, filename, and line as its parameters.

The watchfunction can do anything it likes; it is executing in the
debugger's context, so it has access to all of the debugger's internal
data structures and functions.

C<watchfunction()> can control the debugger's actions. Any of the following
will cause the debugger to return control to the user's program after
C<watchfunction()> executes:

=over 4

=item *

Returning a false value from the C<watchfunction()> itself.

=item *

Altering C<$single> to a false value.

=item *

Altering C<$signal> to a false value.

=item *

Turning off the C<4> bit in C<$trace> (this also disables the
check for C<watchfunction()>. This can be done with

    $trace &= ~4;

=back

=cut

    # If there's a user-defined DB::watchfunction, call it with the
    # current package, filename, and line. The function executes in
    # the DB:: package.
    if ( $trace & 4 ) {    # User-installed watch
        return
          if watchfunction( $package, $filename, $line )
          and not $single
          and not $was_signal
          and not( $trace & ~4 );
    } ## end if ($trace & 4)

    # Pick up any alteration to $signal in the watchfunction, and
    # turn off the signal now.
    $was_signal = $signal;
    $signal     = 0;

=head2 GETTING READY TO EXECUTE COMMANDS

The debugger decides to take control if single-step mode is on, the
C<t> command was entered, or the user generated a signal. If the program
has fallen off the end, we set things up so that entering further commands
won't cause trouble, and we say that the program is over.

=cut

    # Make sure that we always print if asked for explicitly regardless
    # of $trace_to_depth .
    $explicit_stop = ($single || $was_signal);

    # Check to see if we should grab control ($single true,
    # trace set appropriately, or we got a signal).
    if ( $explicit_stop || ( $trace & 1 ) ) {
        $obj->_DB__grab_control(@@_);
d1916 1
a1916 1
If there are any preprompt actions, execute those as well.
d1921 1
a1921 5
    if ($action) {
        $evalarg = $action;
        # The &-call is here to ascertain the mutability of @@_.
        &DB::eval;
    }
d1932 1
a1932 2
            # The &-call is here to ascertain the mutability of @@_.
            &DB::eval;
d1936 2
a1937 3
        if ($single & 4) {
            print $OUT $stack_depth . " levels deep in subroutine calls!\n";
        }
d1996 5
d2002 13
a2014 2
      CMD:
        while (_DB__read_next_cmd($tid))
d2017 1
a2017 1
            share($cmd);
d2027 2
a2028 2
            if ($cmd =~ s/\\\z/\n/) {
                $cmd .= DB::readline("  cont: ");
d2030 1
a2030 1
            }
d2044 1
a2044 3
            if ($cmd eq '') {
                $cmd = $laststep;
            }
d2046 1
a2046 3
            if (length($cmd) >= 2) {
                push( @@hist, $cmd );
            }
d2048 2
a2049 2
            share(@@hist);
            share(@@truehist);
d2055 3
a2057 1
                _DB__trim_command_and_return_first_component($obj);
d2069 1
a2069 1
                if ( $alias{$cmd_verb} ) {
d2080 1
a2080 1
                    eval "\$cmd =~ $alias{$cmd_verb}";
d2083 1
a2083 1
                        print $OUT "Couldn't evaluate '$cmd_verb' alias: $@@";
d2086 1
a2086 2
                    _DB__trim_command_and_return_first_component($obj);
                } ## end if ($alias{$cmd_verb})
d2091 1
a2091 1
terminated.
d2095 1
a2095 1
Quit the debugger. This entails setting the C<$fall_off_end> flag, so we don't
d2101 5
a2105 15
                # All of these commands were remapped in perl 5.8.0;
                # we send them off to the secondary dispatcher (see below).
                $obj->_handle_special_char_cmd_wrapper_commands;
                _DB__trim_command_and_return_first_component($obj);

                if (my $cmd_rec = $cmd_lookup{$cmd_verb}) {
                    my $type = $cmd_rec->{t};
                    my $val = $cmd_rec->{v};
                    if ($type eq 'm') {
                        $obj->$val();
                    }
                    elsif ($type eq 's') {
                        $val->($obj);
                    }
                }
d2112 14
d2130 1
a2130 1
=head4 C<X> - list variables in current package
d2132 25
a2156 1
Since the C<V> command actually processes this, just change this to the
d2159 4
d2165 59
a2223 1
Uses C<dumpvar.pl> to dump out the current values for selected variables.
d2230 12
d2246 12
d2260 46
a2305 1
Switch to a different filename.
d2312 17
d2336 15
a2350 1
=head3 PRE-580 COMMANDS VS. NEW COMMANDS: C<a, A, b, B, h, l, L, M, o, O, P, v, w, W, E<lt>, E<lt>E<lt>, E<0x7B>, E<0x7B>E<0x7B>>
d2359 9
d2370 1
a2370 1
Uses C<PadWalker> to find the lexicals supplied as arguments in a scope
d2373 40
d2425 15
a2439 1
so a null command knows what to re-execute.
d2443 1
a2443 1
Sets C<$single> to 1, which causes C<DB::sub> to continue tracing inside
d2446 17
d2470 103
d2581 16
d2601 7
d2612 4
d2618 5
a2622 1
Just calls C<DB::cmd_W>.
d2626 1
a2626 1
We take the argument and treat it as a pattern. If it turns out to be a
d2628 1
a2628 1
If not, we create some code to do the search and C<eval> it so it can't
d2633 69
a2701 1
                _DB__handle_forward_slash_command($obj);
d2709 64
a2772 1
                _DB__handle_question_mark_command($obj);
d2783 19
a2801 1
                $obj->_handle_rc_recall_command;
d2805 1
a2805 1
Calls the C<_db_system()> to handle the command. This keeps the C<STDIN> and
d2810 8
a2817 1
                $obj->_handle_sh_command;
d2826 2
a2827 1
                $obj->_handle_rc_search_history_command;
d2829 2
a2830 1
=head4 C<$sh> - Invoke a shell
d2832 2
a2833 1
Uses C<_db_system()> to invoke a shell.
d2835 2
a2836 1
=cut
d2838 3
a2840 1
=head4 C<$sh I<command>> - Force execution of a command in a shell
d2842 1
a2842 2
Like the above, but the command is passed to the shell. Again, we use
C<_db_system()> to avoid problems with C<STDIN> and C<STDOUT>.
d2844 4
a2847 1
=head4 C<H> - display commands in history
d2849 5
a2853 1
Prints the contents of C<@@hist> (if any).
d2855 1
a2855 1
=head4 C<man, doc, perldoc> - look up documentation
d2857 1
a2857 1
Just calls C<runman()> to print the appropriate document.
d2861 2
a2862 1
                $obj->_handle_doc_command;
d2864 5
a2868 1
=head4 C<p> - print
d2870 1
a2870 2
Builds a C<print EXPR> expression in the C<$cmd>; this will get executed at
the bottom of the loop.
d2872 2
a2873 1
=head4 C<=> - define command alias
d2875 1
a2875 1
Manipulates C<%alias> to add or list command aliases.
d2877 2
a2878 1
=head4 C<source> - read commands from a file.
d2880 2
a2881 2
Opens a lexical filehandle and stacks it on C<@@cmdfhs>; C<DB::readline> will
pick it up.
d2883 4
a2886 1
=head4 C<enable> C<disable> - enable or disable breakpoints
d2888 1
a2888 1
This enables or disables breakpoints.
d2890 1
a2890 26
=head4 C<save> - send current history to a file

Takes the complete history, (not the shrunken version you see with C<H>),
and saves it to the given filename, so it can be replayed using C<source>.

Note that all C<^(save|source)>'s are commented out with a view to minimise recursion.

=head4 C<R> - restart

Restart the debugger session.

=head4 C<rerun> - rerun the current session

Return to any given position in the B<true>-history list

=head4 C<|, ||> - pipe output through the pager.

For C<|>, we save C<OUT> (the debugger's output filehandle) and C<STDOUT>
(the program's standard output). For C<||>, we only save C<OUT>. We open a
pipe to the pager (restoring the output filehandles if this fails). If this
is the C<|> command, we also set up a C<SIGPIPE> handler which will simply
set C<$signal>, sending us back into the debugger.

We then trim off the pipe symbols and C<redo> the command loop at the
C<PIPE> label, causing us to evaluate the command in C<$cmd> without
reading another.
d2894 5
a2898 2
                # || - run command in the pager, with output to DB::OUT.
                _DB__handle_run_command_in_pager_command($obj);
d2900 1
a2900 1
=head3 END OF COMMAND PARSING
d2902 17
a2918 28
Anything left in C<$cmd> at this point is a Perl expression that we want to
evaluate. We'll always evaluate in the user's context, and fully qualify
any variables we might want to address in the C<DB> package.

=cut

            }    # PIPE:

            # trace an expression
            $cmd =~ s/^t\s/\$DB::trace |= 1;\n/;

            # Make sure the flag that says "the debugger's running" is
            # still on, to make sure we get control again.
            $evalarg = "\$^D = \$^D | \$DB::db_stop;\n$cmd";

            # Run *our* eval that executes in the caller's context.
            # The &-call is here to ascertain the mutability of @@_.
            &DB::eval;

            # Turn off the one-time-dump stuff now.
            if ($onetimeDump) {
                $onetimeDump      = undef;
                $onetimedumpDepth = undef;
            }
            elsif ( $term_pid == $$ ) {
                eval { # May run under miniperl, when not available...
                    STDOUT->flush();
                    STDERR->flush();
d2921 1
a2921 4
                # XXX If this is the master pid, print a newline.
                print {$OUT} "\n";
            }
        } ## end while (($term || &setterm...
d2923 1
a2923 5
=head3 POST-COMMAND PROCESSING

After each command, we check to see if the command output was piped anywhere.
If so, we go through the necessary code to unhook the pipe and go back to
our standard filehandles for input and output.
d2927 5
a2931 3
        continue {    # CMD:
            _DB__at_end_of_every_command($obj);
        }    # CMD:
d2933 1
a2933 1
=head3 COMMAND LOOP TERMINATION
d2935 2
a2936 6
When commands have finished executing, we come here. If the user closed the
input filehandle, we turn on C<$fall_off_end> to emulate a C<q> command. We
evaluate any post-prompt items. We restore C<$@@>, C<$!>, C<$^E>, C<$,>, C<$/>,
C<$\>, and C<$^W>, and return a null list as expected by the Perl interpreter.
The interpreter will then execute the next line and then return control to us
again.
d2940 2
a2941 2
        # No more commands? Quit.
        $fall_off_end = 1 unless defined $cmd;    # Emulate 'q' on EOF
d2943 2
a2944 6
        # Evaluate post-prompt commands.
        foreach $evalarg (@@$post) {
            # The &-call is here to ascertain the mutability of @@_.
            &DB::eval;
        }
    }    # if ($single || $signal)
d2946 1
a2946 4
    # Put the user's globals back where you found them.
    ( $@@, $!, $^E, $,, $/, $\, $^W ) = @@saved;
    ();
} ## end sub DB
d2948 1
a2948 11
# Because DB::Obj is used above,
#
#   my $obj = DB::Obj->new(
#
# The following package declaraton must come before that,
# or else runtime errors will occur with
#
#   PERLDB_OPTS="autotrace nonstop"
#
# ( rt#116771 )
BEGIN {
d2950 1
a2950 1
package DB::Obj;
d2952 4
a2955 2
sub new {
    my $class = shift;
d2957 4
a2960 1
    my $self = bless {}, $class;
d2962 2
a2963 1
    $self->_init(@@_);
d2965 2
a2966 2
    return $self;
}
d2968 3
a2970 2
sub _init {
    my ($self, $args) = @@_;
d2972 4
a2975 1
    %{$self} = (%$self, %$args);
d2977 3
a2979 2
    return;
}
d2981 2
a2982 9
{
    no strict 'refs';
    foreach my $slot_name (qw(
        after explicit_stop infix pat piped position prefix selected cmd_verb
        cmd_args
        )) {
        my $slot = $slot_name;
        *{$slot} = sub {
            my $self = shift;
d2984 5
a2988 3
            if (@@_) {
                ${ $self->{$slot} } = shift;
            }
d2990 3
a2992 2
            return ${ $self->{$slot} };
        };
d2994 4
a2997 3
        *{"append_to_$slot"} = sub {
            my $self = shift;
            my $s = shift;
d2999 2
a3000 4
            return $self->$slot($self->$slot . $s);
        };
    }
}
d3002 21
a3022 3
sub _DB_on_init__initialize_globals
{
    my $self = shift;
d3024 1
a3024 3
    # Check for whether we should be running continuously or not.
    # _After_ the perl program is compiled, $single is set to 1:
    if ( $single and not $second_time++ ) {
d3026 2
a3027 73
        # Options say run non-stop. Run until we get an interrupt.
        if ($runnonstop) {    # Disable until signal
                # If there's any call stack in place, turn off single
                # stepping into subs throughout the stack.
            for my $i (0 .. $stack_depth) {
                $stack[ $i ] &= ~1;
            }

            # And we are now no longer in single-step mode.
            $single = 0;

            # If we simply returned at this point, we wouldn't get
            # the trace info. Fall on through.
            # return;
        } ## end if ($runnonstop)

        elsif ($ImmediateStop) {

            # We are supposed to stop here; XXX probably a break.
            $ImmediateStop = 0;    # We've processed it; turn it off
            $signal        = 1;    # Simulate an interrupt to force
                                   # us into the command loop
        }
    } ## end if ($single and not $second_time...

    # If we're in single-step mode, or an interrupt (real or fake)
    # has occurred, turn off non-stop mode.
    $runnonstop = 0 if $single or $signal;

    return;
}

sub _my_print_lineinfo
{
    my ($self, $i, $incr_pos) = @@_;

    if ($frame) {
        # Print it indented if tracing is on.
        DB::print_lineinfo( ' ' x $stack_depth,
            "$i:\t$DB::dbline[$i]" . $self->after );
    }
    else {
        DB::depth_print_lineinfo($self->explicit_stop, $incr_pos);
    }
}

sub _curr_line {
    return $DB::dbline[$line];
}

sub _is_full {
    my ($self, $letter) = @@_;

    return ($DB::cmd eq $letter);
}

sub _DB__grab_control
{
    my $self = shift;

    # Yes, grab control.
    if ($slave_editor) {

        # Tell the editor to update its position.
        $self->position("\032\032${DB::filename}:$line:0\n");
        DB::print_lineinfo($self->position());
    }

=pod

Special check: if we're in package C<DB::fake>, we've gone through the
C<END> block at least once. We set up everything so that we can continue
to enter commands and have a valid context to be in.
d3031 3
a3033 1
    elsif ( $DB::package eq 'DB::fake' ) {
d3035 4
a3038 4
        # Fallen off the end already.
        if (!$DB::term) {
            DB::setterm();
        }
d3040 5
a3044 5
        DB::print_help(<<EOP);
Debugged program terminated.  Use B<q> to quit or B<R> to restart,
use B<o> I<inhibit_exit> to avoid stopping after program termination,
B<h q>, B<h R> or B<h o> to get additional info.
EOP
d3046 2
a3047 4
        # Set the DB::eval context appropriately.
        $DB::package     = 'main';
        $DB::usercontext = DB::_calc_usercontext($DB::package);
    } ## end elsif ($package eq 'DB::fake')
d3049 14
a3062 388
=pod

If the program hasn't finished executing, we scan forward to the
next executable line, print that out, build the prompt from the file and line
number information, and print that.

=cut

    else {


        # Still somewhere in the midst of execution. Set up the
        #  debugger prompt.
        $DB::sub =~ s/\'/::/;    # Swap Perl 4 package separators (') to
                             # Perl 5 ones (sorry, we don't print Klingon
                             #module names)

        $self->prefix($DB::sub =~ /::/ ? "" : ($DB::package . '::'));
        $self->append_to_prefix( "$DB::sub(${DB::filename}:" );
        $self->after( $self->_curr_line =~ /\n$/ ? '' : "\n" );

        # Break up the prompt if it's really long.
        if ( length($self->prefix()) > 30 ) {
            $self->position($self->prefix . "$line):\n$line:\t" . $self->_curr_line . $self->after);
            $self->prefix("");
            $self->infix(":\t");
        }
        else {
            $self->infix("):\t");
            $self->position(
                $self->prefix . $line. $self->infix
                . $self->_curr_line . $self->after
            );
        }

        # Print current line info, indenting if necessary.
        $self->_my_print_lineinfo($line, $self->position);

        my $i;
        my $line_i = sub { return $DB::dbline[$i]; };

        # Scan forward, stopping at either the end or the next
        # unbreakable line.
        for ( $i = $line + 1 ; $i <= $DB::max && $line_i->() == 0 ; ++$i )
        {    #{ vi

            # Drop out on null statements, block closers, and comments.
            last if $line_i->() =~ /^\s*[\;\}\#\n]/;

            # Drop out if the user interrupted us.
            last if $signal;

            # Append a newline if the line doesn't have one. Can happen
            # in eval'ed text, for instance.
            $self->after( $line_i->() =~ /\n$/ ? '' : "\n" );

            # Next executable line.
            my $incr_pos = $self->prefix . $i . $self->infix . $line_i->()
                . $self->after;
            $self->append_to_position($incr_pos);
            $self->_my_print_lineinfo($i, $incr_pos);
        } ## end for ($i = $line + 1 ; $i...
    } ## end else [ if ($slave_editor)

    return;
}

sub _handle_t_command {
    my $self = shift;

    my $levels = $self->cmd_args();

    if ((!length($levels)) or ($levels !~ /\D/)) {
        $trace ^= 1;
        local $\ = '';
        $DB::trace_to_depth = $levels ? $stack_depth + $levels : 1E9;
        print {$OUT} "Trace = "
        . ( ( $trace & 1 )
            ? ( $levels ? "on (to level $DB::trace_to_depth)" : "on" )
            : "off" ) . "\n";
        next CMD;
    }

    return;
}


sub _handle_S_command {
    my $self = shift;

    if (my ($print_all_subs, $should_reverse, $Spatt)
        = $self->cmd_args =~ /\A((!)?(.+))?\z/) {
        # $Spatt is the pattern (if any) to use.
        # Reverse scan?
        my $Srev     = defined $should_reverse;
        # No args - print all subs.
        my $Snocheck = !defined $print_all_subs;

        # Need to make these sane here.
        local $\ = '';
        local $, = '';

        # Search through the debugger's magical hash of subs.
        # If $nocheck is true, just print the sub name.
        # Otherwise, check it against the pattern. We then use
        # the XOR trick to reverse the condition as required.
        foreach $subname ( sort( keys %sub ) ) {
            if ( $Snocheck or $Srev ^ ( $subname =~ /$Spatt/ ) ) {
                print $OUT $subname, "\n";
            }
        }
        next CMD;
    }

    return;
}

sub _handle_V_command_and_X_command {
    my $self = shift;

    $DB::cmd =~ s/^X\b/V $DB::package/;

    # Bare V commands get the currently-being-debugged package
    # added.
    if ($self->_is_full('V')) {
        $DB::cmd = "V $DB::package";
    }

    # V - show variables in package.
    if (my ($new_packname, $new_vars_str) =
        $DB::cmd =~ /\AV\b\s*(\S+)\s*(.*)/) {

        # Save the currently selected filehandle and
        # force output to debugger's filehandle (dumpvar
        # just does "print" for output).
        my $savout = select($OUT);

        # Grab package name and variables to dump.
        $packname = $new_packname;
        my @@vars     = split( ' ', $new_vars_str );

        # If main::dumpvar isn't here, get it.
        do 'dumpvar.pl' || die $@@ unless defined &main::dumpvar;
        if ( defined &main::dumpvar ) {

            # We got it. Turn off subroutine entry/exit messages
            # for the moment, along with return values.
            local $frame = 0;
            local $doret = -2;

            # must detect sigpipe failures  - not catching
            # then will cause the debugger to die.
            eval {
                main::dumpvar(
                    $packname,
                    defined $option{dumpDepth}
                    ? $option{dumpDepth}
                    : -1,    # assume -1 unless specified
                    @@vars
                );
            };

            # The die doesn't need to include the $@@, because
            # it will automatically get propagated for us.
            if ($@@) {
                die unless $@@ =~ /dumpvar print failed/;
            }
        } ## end if (defined &main::dumpvar)
        else {

            # Couldn't load dumpvar.
            print $OUT "dumpvar.pl not available.\n";
        }

        # Restore the output filehandle, and go round again.
        select($savout);
        next CMD;
    }

    return;
}

sub _handle_dash_command {
    my $self = shift;

    if ($self->_is_full('-')) {

        # back up by a window; go to 1 if back too far.
        $start -= $incr + $window + 1;
        $start = 1 if $start <= 0;
        $incr  = $window - 1;

        # Generate and execute a "l +" command (handled below).
        $DB::cmd = 'l ' . ($start) . '+';
        redo CMD;
    }
    return;
}

sub _n_or_s_commands_generic {
    my ($self, $new_val) = @@_;
    # n - next
    next CMD if DB::_DB__is_finished();

    # Single step, but don't enter subs.
    $single = $new_val;

    # Save for empty command (repeat last).
    $laststep = $DB::cmd;
    last CMD;
}

sub _n_or_s {
    my ($self, $letter, $new_val) = @@_;

    if ($self->_is_full($letter)) {
        $self->_n_or_s_commands_generic($new_val);
    }
    else {
        $self->_n_or_s_and_arg_commands_generic($letter, $new_val);
    }

    return;
}

sub _handle_n_command {
    my $self = shift;

    return $self->_n_or_s('n', 2);
}

sub _handle_s_command {
    my $self = shift;

    return $self->_n_or_s('s', 1);
}

sub _handle_r_command {
    my $self = shift;

    # r - return from the current subroutine.
    if ($self->_is_full('r')) {

        # Can't do anything if the program's over.
        next CMD if DB::_DB__is_finished();

        # Turn on stack trace.
        $stack[$stack_depth] |= 1;

        # Print return value unless the stack is empty.
        $doret = $option{PrintRet} ? $stack_depth - 1 : -2;
        last CMD;
    }

    return;
}

sub _handle_T_command {
    my $self = shift;

    if ($self->_is_full('T')) {
        DB::print_trace( $OUT, 1 );    # skip DB
        next CMD;
    }

    return;
}

sub _handle_w_command {
    my $self = shift;

    DB::cmd_w( 'w', $self->cmd_args() );
    next CMD;

    return;
}

sub _handle_W_command {
    my $self = shift;

    if (my $arg = $self->cmd_args) {
        DB::cmd_W( 'W', $arg );
        next CMD;
    }

    return;
}

sub _handle_rc_recall_command {
    my $self = shift;

    # $rc - recall command.
    if (my ($minus, $arg) = $DB::cmd =~ m#\A$rc+\s*(-)?(\d+)?\z#) {

        # No arguments, take one thing off history.
        pop(@@hist) if length($DB::cmd) > 1;

        # Relative (- found)?
        #  Y - index back from most recent (by 1 if bare minus)
        #  N - go to that particular command slot or the last
        #      thing if nothing following.

        $self->cmd_verb(
            scalar($minus ? ( $#hist - ( $arg || 1 ) ) : ( $arg || $#hist ))
        );

        # Pick out the command desired.
        $DB::cmd = $hist[$self->cmd_verb];

        # Print the command to be executed and restart the loop
        # with that command in the buffer.
        print {$OUT} $DB::cmd, "\n";
        redo CMD;
    }

    return;
}

sub _handle_rc_search_history_command {
    my $self = shift;

    # $rc pattern $rc - find a command in the history.
    if (my ($arg) = $DB::cmd =~ /\A$rc([^$rc].*)\z/) {

        # Create the pattern to use.
        my $pat = "^$arg";
        $self->pat($pat);

        # Toss off last entry if length is >1 (and it always is).
        pop(@@hist) if length($DB::cmd) > 1;

        my $i;

        # Look backward through the history.
        SEARCH_HIST:
        for ( $i = $#hist ; $i ; --$i ) {
            # Stop if we find it.
            last SEARCH_HIST if $hist[$i] =~ /$pat/;
        }

        if ( !$i ) {

            # Never found it.
            print $OUT "No such command!\n\n";
            next CMD;
        }

        # Found it. Put it in the buffer, print it, and process it.
        $DB::cmd = $hist[$i];
        print $OUT $DB::cmd, "\n";
        redo CMD;
    }

    return;
}

sub _handle_H_command {
    my $self = shift;

    if ($self->cmd_args =~ m#\A\*#) {
        @@hist = @@truehist = ();
        print $OUT "History cleansed\n";
        next CMD;
    }

    if (my ($num) = $self->cmd_args =~ /\A(?:-(\d+))?/) {

        # Anything other than negative numbers is ignored by
        # the (incorrect) pattern, so this test does nothing.
        $end = $num ? ( $#hist - $num ) : 0;

        # Set to the minimum if less than zero.
        $hist = 0 if $hist < 0;

        # Start at the end of the array.
        # Stay in while we're still above the ending value.
        # Tick back by one each time around the loop.
        my $i;

        for ( $i = $#hist ; $i > $end ; $i-- ) {

            # Print the command  unless it has no arguments.
            print $OUT "$i: ", $hist[$i], "\n"
            unless $hist[$i] =~ /^.?$/;
        }

        next CMD;
    }
d3064 10
a3073 2
    return;
}
d3075 2
a3076 2
sub _handle_doc_command {
    my $self = shift;
d3078 1
a3078 6
    # man, perldoc, doc - show manual pages.
    if (my ($man_page)
        = $DB::cmd =~ /\A(?:man|(?:perl)?doc)\b(?:\s+([^(]*))?\z/) {
        DB::runman($man_page);
        next CMD;
    }
d3080 2
a3081 2
    return;
}
d3083 1
a3083 2
sub _handle_p_command {
    my $self = shift;
d3085 1
a3085 9
    my $print_cmd = 'print {$DB::OUT} ';
    # p - print (no args): print $_.
    if ($self->_is_full('p')) {
        $DB::cmd = $print_cmd . '$_';
    }
    else {
        # p - print the given expression.
        $DB::cmd =~ s/\Ap\b/$print_cmd /;
    }
d3087 17
a3103 2
    return;
}
d3105 1
a3105 2
sub _handle_equal_sign_command {
    my $self = shift;
d3107 1
a3107 3
    if ($DB::cmd =~ s/\A=\s*//) {
        my @@keys;
        if ( length $DB::cmd == 0 ) {
d3109 1
a3109 4
            # No args, get current aliases.
            @@keys = sort keys %alias;
        }
        elsif ( my ( $k, $v ) = ( $DB::cmd =~ /^(\S+)\s+(\S.*)/ ) ) {
d3111 1
a3111 2
            # Creating a new alias. $k is alias name, $v is
            # alias value.
d3113 1
a3113 2
            # can't use $_ or kill //g state
            for my $x ( $k, $v ) {
d3115 15
a3129 3
                # Escape "alarm" characters.
                $x =~ s/\a/\\a/g;
            }
d3131 6
a3136 17
            # Substitute key for value, using alarm chars
            # as separators (which is why we escaped them in
            # the command).
            $alias{$k} = "s\a$k\a$v\a";

            # Turn off standard warn and die behavior.
            local $SIG{__DIE__};
            local $SIG{__WARN__};

            # Is it valid Perl?
            unless ( eval "sub { s\a$k\a$v\a }; 1" ) {

                # Nope. Bad alias. Say so and get out.
                print $OUT "Can't alias $k to $v: $@@\n";
                delete $alias{$k};
                next CMD;
            }
d3138 3
a3140 3
            # We'll only list the new one.
            @@keys = ($k);
        } ## end elsif (my ($k, $v) = ($DB::cmd...
d3142 2
a3143 4
        # The argument is the alias to list.
        else {
            @@keys = ($DB::cmd);
        }
d3145 1
a3145 2
        # List aliases.
        for my $k (@@keys) {
d3147 5
a3151 4
            # Messy metaquoting: Trim the substitution code off.
            # We use control-G as the delimiter because it's not
            # likely to appear in the alias.
            if ( ( my $v = $alias{$k} ) =~ ss\a$k\a(.*)\a$1 ) {
d3153 3
a3155 4
                # Print the alias.
                print $OUT "$k\t= $1\n";
            }
            elsif ( defined $alias{$k} ) {
d3157 1
a3157 4
                # Couldn't trim it off; just print the alias code.
                print $OUT "$k\t$alias{$k}\n";
            }
            else {
d3159 3
a3161 6
                # No such, dude.
                print "No alias for $k\n";
            }
        } ## end for my $k (@@keys)
        next CMD;
    }
d3163 7
a3169 2
    return;
}
d3171 3
a3173 2
sub _handle_source_command {
    my $self = shift;
d3175 2
a3176 3
    # source - read commands from a file (or pipe!) and execute.
    if (my $sourced_fn = $self->cmd_args) {
        if ( open my $fh, $sourced_fn ) {
d3178 1
a3178 4
            # Opened OK; stick it in the list of file handles.
            push @@cmdfhs, $fh;
        }
        else {
d3180 19
a3198 5
            # Couldn't open it.
            DB::_db_warn("Can't execute '$sourced_fn': $!\n");
        }
        next CMD;
    }
d3200 16
a3215 2
    return;
}
d3217 1
a3217 2
sub _handle_enable_disable_commands {
    my $self = shift;
d3219 3
a3221 2
    my $which_cmd = $self->cmd_verb;
    my $position = $self->cmd_args;
d3223 1
a3223 15
    if ($position !~ /\s/) {
        my ($fn, $line_num);
        if ($position =~ m{\A\d+\z})
        {
            $fn = $DB::filename;
            $line_num = $position;
        }
        elsif (my ($new_fn, $new_line_num)
            = $position =~ m{\A(.*):(\d+)\z}) {
            ($fn, $line_num) = ($new_fn, $new_line_num);
        }
        else
        {
            DB::_db_warn("Wrong spec for enable/disable argument.\n");
        }
d3225 4
a3228 10
        if (defined($fn)) {
            if (DB::_has_breakpoint_data_ref($fn, $line_num)) {
                DB::_set_breakpoint_enabled_status($fn, $line_num,
                    ($which_cmd eq 'enable' ? 1 : '')
                );
            }
            else {
                DB::_db_warn("No breakpoint set at ${fn}:${line_num}\n");
            }
        }
d3230 2
a3231 2
        next CMD;
    }
d3233 3
a3235 2
    return;
}
d3237 1
a3237 2
sub _handle_save_command {
    my $self = shift;
d3239 3
a3241 16
    if (my $new_fn = $self->cmd_args) {
        my $filename = $new_fn || '.perl5dbrc';    # default?
        if ( open my $fh, '>', $filename ) {

            # chomp to remove extraneous newlines from source'd files
            chomp( my @@truelist =
                map { m/\A\s*(save|source)/ ? "#$_" : $_ }
                @@truehist );
            print {$fh} join( "\n", @@truelist );
            print "commands saved in $filename\n";
        }
        else {
            DB::_db_warn("Can't save debugger commands in '$new_fn': $!\n");
        }
        next CMD;
    }
d3243 2
a3244 2
    return;
}
d3246 10
a3255 2
sub _n_or_s_and_arg_commands_generic {
    my ($self, $letter, $new_val) = @@_;
d3257 4
a3260 4
    # s - single-step. Remember the last command was 's'.
    if ($DB::cmd =~ s#\A\Q$letter\E\s#\$DB::single = $new_val;\n#) {
        $laststep = $letter;
    }
d3262 1
a3262 2
    return;
}
d3264 3
a3266 2
sub _handle_sh_command {
    my $self = shift;
d3268 1
a3268 4
    # $sh$sh - run a shell command (if it's all ASCII).
    # Can't run shell commands with Unicode in the debugger, hmm.
    my $my_cmd = $DB::cmd;
    if ($my_cmd =~ m#\A$sh#gms) {
d3270 1
a3270 17
        if ($my_cmd =~ m#\G\z#cgms) {
            # Run the user's shell. If none defined, run Bourne.
            # We resume execution when the shell terminates.
            DB::_db_system( $ENV{SHELL} || "/bin/sh" );
            next CMD;
        }
        elsif ($my_cmd =~ m#\G$sh\s*(.*)#cgms) {
            # System it.
            DB::_db_system($1);
            next CMD;
        }
        elsif ($my_cmd =~ m#\G\s*(.*)#cgms) {
            DB::_db_system( $ENV{SHELL} || "/bin/sh", "-c", $1 );
            next CMD;
        }
    }
}
d3272 2
a3273 2
sub _handle_x_command {
    my $self = shift;
d3275 2
a3276 2
    if ($DB::cmd =~ s#\Ax\b# #) {    # Remainder gets done by DB::eval()
        $onetimeDump = 'dump';    # main::dumpvar shows the output
d3278 2
a3279 6
        # handle special  "x 3 blah" syntax XXX propagate
        # doc back to special variables.
        if ( $DB::cmd =~ s#\A\s*(\d+)(?=\s)# #) {
            $onetimedumpDepth = $1;
        }
    }
d3281 33
a3313 2
    return;
}
d3315 3
a3317 2
sub _handle_q_command {
    my $self = shift;
d3319 4
a3322 5
    if ($self->_is_full('q')) {
        $fall_off_end = 1;
        DB::clean_ENV();
        exit $?;
    }
d3324 4
a3327 2
    return;
}
d3329 1
a3329 2
sub _handle_cmd_wrapper_commands {
    my $self = shift;
d3331 6
a3336 3
    DB::cmd_wrapper( $self->cmd_verb, $self->cmd_args, $line );
    next CMD;
}
d3338 1
a3338 2
sub _handle_special_char_cmd_wrapper_commands {
    my $self = shift;
d3340 2
a3341 6
    # All of these commands were remapped in perl 5.8.0;
    # we send them off to the secondary dispatcher (see below).
    if (my ($cmd_letter, $my_arg) = $DB::cmd =~ /\A([<>\{]{1,2})\s*(.*)/so) {
        DB::cmd_wrapper( $cmd_letter, $my_arg, $line );
        next CMD;
    }
d3343 5
a3347 2
    return;
}
d3349 4
a3352 3
} ## end DB::Obj

package DB;
d3359 1
a3359 1
C<sub> is called whenever a subroutine call happens in the program being
d3373 1
a3373 1
and also prints the return value if needed (for the C<r> command and if
d3437 3
a3439 39
use vars qw($deep);

# We need to fully qualify the name ("DB::sub") to make "use strict;"
# happy. -- Shlomi Fish

sub _indent_print_line_info {
    my ($offset, $str) = @@_;

    print_lineinfo( ' ' x ($stack_depth - $offset), $str);

    return;
}

sub _print_frame_message {
    my ($al) = @@_;

    if ($frame) {
        if ($frame & 4) {   # Extended frame entry message
            _indent_print_line_info(-1, "in  ");

            # Why -1? But it works! :-(
            # Because print_trace will call add 1 to it and then call
            # dump_trace; this results in our skipping -1+1 = 0 stack frames
            # in dump_trace.
            #
            # Now it's 0 because we extracted a function.
            print_trace( $LINEINFO, 0, 1, 1, "$sub$al" );
        }
        else {
            _indent_print_line_info(-1, "entering $sub$al\n" );
        }
    }

    return;
}

sub DB::sub {
    # Do not use a regex in this subroutine -> results in corrupted memory
    # See: [perl #66110]
d3441 2
a3442 2
    # lock ourselves under threads
    lock($DBGR);
d3448 3
a3450 3
    if ($sub eq 'threads::new' && $ENV{PERL5DB_THREADED}) {
        print "creating new thread\n";
    }
a3454 1
        no strict 'refs';
d3478 4
d3483 7
a3489 2
    _print_frame_message($al);
    # standard frame entry message
d3491 3
a3493 16
    my $print_exit_msg = sub {
        # Check for exit trace messages...
        if ($frame & 2)
        {
            if ($frame & 4)    # Extended exit message
            {
                _indent_print_line_info(0, "out ");
                print_trace( $LINEINFO, 0, 1, 1, "$sub$al" );
            }
            else
            {
                _indent_print_line_info(0, "exited $sub$al\n" );
            }
        }
        return;
    };
d3501 1
a3501 4
        {
            no strict 'refs';
            @@ret = &$sub;
        }
d3506 12
a3517 1
        $print_exit_msg->();
d3527 1
a3527 4
            if ($frame & 16)
            {
                print {$fh} ' ' x $stack_depth;
            }
d3530 1
a3530 1
            print {$fh} "list context return from $sub:\n";
d3542 11
a3552 11
        if ( defined wantarray ) {
            no strict 'refs';
            # Save the value if it's wanted at all.
            $ret = &$sub;
        }
        else {
            no strict 'refs';
            # Void return, explicitly.
            &$sub;
            undef $ret;
        }
d3558 11
a3568 1
        $print_exit_msg->();
d3587 1
a3587 1
} ## end sub _sub
d3591 2
a3592 4
    no strict 'refs';

    # lock ourselves under threads
    lock($DBGR);
d3598 3
a3600 3
    if ($sub =~ /^threads::new$/ && $ENV{PERL5DB_THREADED}) {
        print "creating new thread\n";
    }
d3628 16
a3643 1
    _print_frame_message($al);
d3665 2
a3666 2
The following sections describe the code added to make it easy to support
multiple command sets with conflicting command names. This section is a start
d3669 1
a3669 1
Note that all the cmd_[a-zA-Z] subroutines require the command name, a line
d3672 1
a3672 1
Support functions in this section which have multiple modes of failure C<die>
d3681 1
a3681 1
name suffix.
d3687 1
a3687 1
=cut
d3768 1
a3768 1

d3787 2
a3788 2
C<cmd_wrapper()> allows the debugger to switch command sets
depending on the value of the C<CommandSet> option.
d3791 3
a3793 3
(which means external entities can't fiddle with it) and create the name of
the sub to call based on the value found in the hash (if it's there). I<All>
of the commands to be handled in a set have to be added to C<%set>; if they
d3796 1
a3796 1
This code uses symbolic references.
d3810 1
a3810 1
          || ( $cmd =~ /\A[<>{]+/o ? 'prepost' : $cmd ) );
d3813 1
a3813 1
    return __PACKAGE__->can($call)->( $cmd, $line, $dblineno );
d3819 2
a3820 2
particular line, so they're stored in C<%dbline>. We default to the current
line if none is specified.
d3830 1
a3830 1
    $line =~ s/\A\./$dbline/;
d3833 2
a3834 5
    if ( my ($lineno, $expr) = $line =~ /^\s*(\d*)\s*(\S.+)/ ) {

        if (! length($lineno)) {
            $lineno = $dbline;
        }
a3853 2

                _set_breakpoint_enabled_status($filename, $lineno, 1);
d3886 1
a3886 4
        if (! eval { _delete_all_actions(); 1 }) {
            print {$OUT} $@@;
            return;
        }
d3892 1
a3892 4
        if (! eval { delete_action($1); 1 }) {
            print {$OUT} $@@;
            return;
        }
d3905 1
a3905 1
is specified, we check for the line being executable (if it's not, it
a3910 30
sub _remove_action_from_dbline {
    my $i = shift;

    $dbline{$i} =~ s/\0[^\0]*//;    # \^a
    delete $dbline{$i} if $dbline{$i} eq '';

    return;
}

sub _delete_all_actions {
    print {$OUT} "Deleting all actions...\n";

    for my $file ( keys %had_breakpoints ) {
        local *dbline = $main::{ '_<' . $file };
        $max = $#dbline;
        my $was;
        for my $i (1 .. $max) {
            if ( defined $dbline{$i} ) {
                _remove_action_from_dbline($i);
            }
        }

        unless ( $had_breakpoints{$file} &= ~2 ) {
            delete $had_breakpoints{$file};
        }
    }

    return;
}

d3913 1
a3914 1
    if ( defined($i) ) {
d3919 2
a3920 1
        _remove_action_from_dbline($i);
d3923 17
a3939 3
        _delete_all_actions();
    }
}
a3955 5
    my $default_cond = sub {
        my $cond = shift;
        return length($cond) ? $cond : '1';
    };

d3961 1
a3961 1
        cmd_b_line( $dbline, 1 );
d3965 4
a3968 3
    elsif ( my ($file) = $line =~ /^load\b\s*(.*)/ ) {
        $file =~ s/\s+\z//;
        cmd_b_load($file);
d3973 9
a3981 3
    # necessary condition in the %postponed hash.
    elsif ( my ($action, $subname, $cond)
        = $line =~ /^(postpone|compile)\b\s*([':A-Za-z_][':\w]*)\s*(.*)/ ) {
d3984 1
a3984 1
        $subname =~ s/'/::/g;
d3987 1
a3987 1
        $subname = "${package}::" . $subname unless $subname =~ /::/;
d3993 1
a3993 3
        $postponed{$subname} = (($action eq 'postpone')
            ? ( "break +0 if " . $default_cond->($cond) )
            : "compile");
d3996 2
a3997 2
    elsif (my ($filename, $line_num, $cond)
        = $line =~ /\A(\S+[^:]):(\d+)\s*(.*)/ms) {
d4000 1
a4000 1
            $line_num,
d4005 1
a4005 2
    elsif ( my ($new_subname, $new_cond) =
        $line =~ /^([':A-Za-z_][':\w]*(?:\[.*\])?)\s*(.*)/ ) {
d4008 3
a4010 2
        $subname = $new_subname;
        cmd_b_sub( $subname, $default_cond->($new_cond) );
d4014 1
a4014 1
    elsif ( my ($line_n, $cond) = $line =~ /^(\d*)\s*(.*)/ ) {
d4017 4
a4020 1
        $line = $line_n || $dbline;
d4023 1
a4023 1
        cmd_b_line( $line, $default_cond->($cond) );
a4029 2

    return;
d4035 1
a4035 1
C<%break_on_load> hash, and note that it has a breakpoint in
d4048 1
a4048 1
Gives us an array of filenames that are set to break on load. Note that
d4061 1
a4061 1
to files they came from). We mark those files for break-on-load via
d4099 1
a4099 1
C<$filename_error> is used to contain the name of the file that's being
d4109 1
a4109 1
=over 4
d4117 1
a4117 1
Localizes the C<*dbline> glob and reassigns it to point to the file we want to process.
d4121 1
a4121 1
Calls the first function.
a4136 1
use vars qw($filename_error);
d4145 1
a4145 1
If C<$to> is greater than C<$from>, the search moves forwards, finding the
d4248 1
a4248 1
Adds a breakpoint with the specified condition (or 1 if no condition was
d4254 4
a4257 2
    my $i = shift;
    my $cond = @@_ ? shift(@@_) : 1;
a4282 2

    return;
d4287 1
a4287 1
Wrapper for C<break_on_line>. Prints the failure message if it
d4290 1
a4290 1
=cut
d4293 1
a4293 1
    if (not eval { break_on_line(@@_); 1 }) {
d4296 1
a4296 3
    }

    return;
d4301 1
a4301 1
Wrapper for C<break_on_filename_line>. Prints the failure message if it
d4304 1
a4304 1
=cut
d4307 1
a4307 1
    if (not eval { break_on_filename_line(@@_); 1 }) {
d4310 1
a4310 3
    }

    return;
d4315 1
a4315 1
Switches to the file specified and then calls C<break_on_line> to set
d4321 4
a4324 3
    my $f = shift;
    my $i = shift;
    my $cond = @@_ ? shift(@@_) : 1;
a4334 2

    return;
d4339 1
a4339 1
Switch to another file, search the range of lines specified for an
d4345 1
a4345 4
    my $f = shift;
    my $from = shift;
    my $to = shift;
    my $cond = @@_ ? shift(@@_) : 1;
d4350 3
a4354 2

    return;
d4365 1
a4365 1
    my ( $subname ) = @@_;
d4368 3
a4370 2
    # The match creates the list (fullpathname, start, end).
    return (find_sub($subname) =~ /^(.*):(\d+)-(\d+)$/);
d4376 1
a4376 1
C<subroutine_filename_lines> to find the subroutine, and
a4387 1

d4389 1
a4389 1
    my $cond = @@_ ? shift(@@_) : 1;
d4393 1
a4393 3
    break_on_filename_line_range( $file, $s, $e, $cond );

    return;
d4402 1
a4402 1
=item 1. If it's already fully-qualified, leave it alone.
d4412 1
a4412 1
After all this cleanup, we call C<break_subroutine> to try to set the
d4418 4
a4421 2
    my $subname = shift;
    my $cond = @@_ ? shift : 1;
d4425 1
a4425 1
    if ( ref($subname) ne 'CODE' ) {
d4427 2
a4428 2
        # Not Perl 4.
        $subname =~ s/'/::/g;
d4432 2
a4433 4
        if ($subname !~ /::/)
        {
            $subname = $package . '::' . $subname;
        };
d4438 4
a4441 7
        my $core_name = "CORE::GLOBAL::$s";
        if ((!defined(&$subname))
                and ($s !~ /::/)
                and (defined &{$core_name}))
        {
            $subname = $core_name;
        }
d4444 3
a4446 5
        if ($subname =~ /\A::/)
        {
            $subname = "main" . $subname;
        }
    } ## end if ( ref($subname) ne 'CODE' ) {
d4449 1
a4449 1
    if (not eval { break_subroutine( $subname, $cond ); 1 }) {
d4451 2
a4452 5
        print {$OUT} $@@;
        return;
    }

    return;
d4471 1
a4471 1
    my $line   = ( $_[0] =~ /\A\./ ) ? $dbline : (shift || '');
d4479 1
a4479 3
        if (not eval { delete_breakpoint(); 1 }) {
            print {$OUT} $@@;
        }
d4483 2
a4484 2
    elsif ( $line =~ /\A(\S.*)/ ) {
        if (not eval { delete_breakpoint( $line || $dbline ); 1 }) {
d4486 2
a4487 2
            print {$OUT} $@@;
        }
d4492 1
a4492 1
        print {$OUT}
a4495 2

    return;
d4509 1
a4509 1
For all breakpoints, we iterate through the keys of C<%had_breakpoints>,
d4516 1
a4516 1
We then wholesale delete C<%postponed>, C<%postponed_file>, and
d4523 2
a4524 2
sub _remove_breakpoint_entry {
    my ($fn, $i) = @@_;
d4526 1
a4526 2
    delete $dbline{$i};
    _delete_breakpoint_data_ref($fn, $i);
d4528 2
a4529 2
    return;
}
d4531 2
a4532 2
sub _delete_all_breakpoints {
    print {$OUT} "Deleting all breakpoints...\n";
d4534 2
a4535 3
    # %had_breakpoints lists every file that had at least one
    # breakpoint in it.
    for my $fn ( keys %had_breakpoints ) {
d4537 6
a4542 2
        # Switch to the desired file temporarily.
        local *dbline = $main::{ '_<' . $fn };
d4544 3
a4546 1
        $max = $#dbline;
d4548 3
a4550 2
        # For all lines in this file ...
        for my $i (1 .. $max) {
d4552 2
a4553 2
            # If there's a breakpoint or action on this line ...
            if ( defined $dbline{$i} ) {
d4555 2
a4556 8
                # ... remove the breakpoint.
                $dbline{$i} =~ s/\A[^\0]+//;
                if ( $dbline{$i} =~ s/\A\0?\z// ) {
                    # Remove the entry altogether if no action is there.
                    _remove_breakpoint_entry($fn, $i);
                }
            } ## end if (defined $dbline{$i...
        } ## end for $i (1 .. $max)
d4558 2
a4559 13
        # If, after we turn off the "there were breakpoints in this file"
        # bit, the entry in %had_breakpoints for this file is zero,
        # we should remove this file from the hash.
        if ( not $had_breakpoints{$fn} &= (~1) ) {
            delete $had_breakpoints{$fn};
        }
    } ## end for my $fn (keys %had_breakpoints)

    # Kill off all the other breakpoints that are waiting for files that
    # haven't been loaded yet.
    undef %postponed;
    undef %postponed_file;
    undef %break_on_load;
d4561 2
a4562 2
    return;
}
d4564 3
a4566 2
sub _delete_breakpoint_from_line {
    my ($i) = @@_;
d4568 6
a4573 2
    # Woops. This line wasn't breakable at all.
    die "Line $i not breakable.\n" if $dbline[$i] == 0;
d4575 7
a4581 2
    # Kill the condition, but leave any action.
    $dbline{$i} =~ s/\A[^\0]*//;
d4583 7
a4589 22
    # Remove the entry entirely if there's no action left.
    if ($dbline{$i} eq '') {
        _remove_breakpoint_entry($filename, $i);
    }

    return;
}

sub delete_breakpoint {
    my $i = shift;

    # If we got a line, delete just that one.
    if ( defined($i) ) {
        _delete_breakpoint_from_line($i);
    }
    # No line; delete them all.
    else {
        _delete_all_breakpoints();
    }

    return;
}
d4607 1
a4607 1
    e
d4617 7
a4623 7
    unless (exists($INC{'threads.pm'})) {
        print "threads not loaded($ENV{PERL5DB_THREADED})
        please run the debugger with PERL5DB_THREADED=1 set in the environment\n";
    } else {
        my $tid = threads->tid;
        print "thread id: $tid\n";
    }
d4630 1
a4630 1
    E
d4639 9
a4647 9
    unless (exists($INC{'threads.pm'})) {
        print "threads not loaded($ENV{PERL5DB_THREADED})
        please run the debugger with PERL5DB_THREADED=1 set in the environment\n";
    } else {
        my $tid = threads->tid;
        print "thread ids: ".join(', ',
            map { ($tid == $_->tid ? '<'.$_->tid.'>' : $_->tid) } threads->list
        )."\n";
    }
a4667 3
use vars qw($help);
use vars qw($summary);

d4675 1
a4675 1
    if ( $line =~ /\Ah\s*\z/ ) {
d4680 1
a4680 1
    elsif ( my ($asked) = $line =~ /\A(\S.*)\z/ ) {
d4684 3
d4709 1
a4709 1
                              (?!\s)         # Next line not starting with
d4741 1
a4741 2
        # The &-call is here to ascertain the mutability of @@_.
        ($isa) = &DB::eval;
d4761 1
a4761 1
runs a loop over C<@@dbline> for the specified range of lines. It handles
d4764 1
a4764 1
line breakable).
d4771 4
a4774 9
sub _min {
    my $min = shift;
    foreach my $v (@@_) {
        if ($min > $v) {
            $min = $v;
        }
    }
    return $min;
}
d4776 2
a4777 9
sub _max {
    my $max = shift;
    foreach my $v (@@_) {
        if ($max < $v) {
            $max = $v;
        }
    }
    return $max;
}
d4779 3
a4781 2
sub _minify_to_max {
    my $ref = shift;
d4783 4
a4786 1
    $$ref = _min($$ref, $max);
d4788 2
a4789 2
    return;
}
d4791 8
a4798 2
sub _cmd_l_handle_var_name {
    my $var_name = shift;
d4800 3
a4802 1
    $evalarg = $var_name;
d4804 2
a4805 1
    my ($s) = DB::eval();
d4807 2
a4808 5
    # Ooops. Bad scalar.
    if ($@@) {
        print {$OUT} "Error: $@@\n";
        next CMD;
    }
d4810 6
a4815 4
    # Good scalar. If it's a reference, find what it points to.
    $s = CvGV_name($s);
    print {$OUT} "Interpreted as: $1 $s\n";
    $line = "$1 $s";
d4817 2
a4818 3
    # Call self recursively to really do the command.
    return _cmd_l_main( $s );
}
d4820 15
a4834 1
sub _cmd_l_handle_subname {
d4836 5
a4840 1
    my $s = $subname;
d4842 6
a4847 2
    # De-Perl4.
    $subname =~ s/\'/::/;
d4849 4
a4852 2
    # Put it in this package unless it starts with ::.
    $subname = $package . "::" . $subname unless $subname =~ /::/;
d4854 3
a4856 25
    # Put it in CORE::GLOBAL if t doesn't start with :: and
    # it doesn't live in this package and it lives in CORE::GLOBAL.
    $subname = "CORE::GLOBAL::$s"
    if not defined &$subname
        and $s !~ /::/
        and defined &{"CORE::GLOBAL::$s"};

    # Put leading '::' names into 'main::'.
    $subname = "main" . $subname if substr( $subname, 0, 2 ) eq "::";

    # Get name:start-stop from find_sub, and break this up at
    # colons.
    my @@pieces = split( /:/, find_sub($subname) || $sub{$subname} );

    # Pull off start-stop.
    my $subrange = pop @@pieces;

    # If the name contained colons, the split broke it up.
    # Put it back together.
    $file = join( ':', @@pieces );

    # If we're not in that file, switch over to it.
    if ( $file ne $filename ) {
        if (! $slave_editor) {
            print {$OUT} "Switching to file '$file'.\n";
d4858 1
d4860 2
a4861 5
        # Switch debugger's magic structures.
        *dbline   = $main::{ '_<' . $file };
        $max      = $#dbline;
        $filename = $file;
    } ## end if ($file ne $filename)
d4863 3
a4865 6
    # Subrange is 'start-stop'. If this is less than a window full,
    # swap it to 'start+', which will list a window from the start point.
    if ($subrange) {
        if ( eval($subrange) < -$window ) {
            $subrange =~ s/-.*/+/;
        }
d4867 2
a4868 8
        # Call self recursively to list the range.
        return _cmd_l_main( $subrange );
    } ## end if ($subrange)

    # Couldn't find it.
    else {
        print {$OUT} "Subroutine $subname not found.\n";
        return;
a4869 1
}
d4871 2
a4872 3
sub _cmd_l_empty {
    # Compute new range to list.
    $incr = $window - 1;
d4874 2
a4875 3
    # Recurse to do it.
    return _cmd_l_main( $start . '-' . ( $start + $incr ) );
}
d4877 4
a4880 2
sub _cmd_l_plus {
    my ($new_start, $new_incr) = @@_;
d4882 4
a4885 2
    # Don't reset start for 'l +nnn'.
    $start = $new_start if $new_start;
d4887 2
a4888 3
    # Increment for list. Use window size if not specified.
    # (Allows 'l +' to work.)
    $incr = $new_incr || ($window - 1);
d4890 2
a4891 3
    # Create a line range we'll understand, and recurse to do it.
    return _cmd_l_main( $start . '-' . ( $start + $incr ) );
}
d4893 2
a4894 2
sub _cmd_l_calc_initial_end_and_i {
    my ($spec, $start_match, $end_match) = @@_;
d4896 20
a4915 3
    # Determine end point; use end of file if not specified.
    my $end = ( !defined $start_match ) ? $max :
    ( $end_match ? $end_match : $start_match );
d4917 15
a4931 2
    # Go on to the end, and then stop.
    _minify_to_max(\$end);
d4933 2
a4934 105
    # Determine start line.
    my $i = $start_match;

    if ($i eq '.') {
        $i = $spec;
    }

    $i = _max($i, 1);

    $incr = $end - $i;

    return ($end, $i);
}

sub _cmd_l_range {
    my ($spec, $current_line, $start_match, $end_match) = @@_;

    my ($end, $i) =
        _cmd_l_calc_initial_end_and_i($spec, $start_match, $end_match);

    # If we're running under a slave editor, force it to show the lines.
    if ($slave_editor) {
        print {$OUT} "\032\032$filename:$i:0\n";
        $i = $end;
    }
    # We're doing it ourselves. We want to show the line and special
    # markers for:
    # - the current line in execution
    # - whether a line is breakable or not
    # - whether a line has a break or not
    # - whether a line has an action or not
    else {
        I_TO_END:
        for ( ; $i <= $end ; $i++ ) {

            # Check for breakpoints and actions.
            my ( $stop, $action );
            if ($dbline{$i}) {
                ( $stop, $action ) = split( /\0/, $dbline{$i} );
            }

            # ==> if this is the current line in execution,
            # : if it's breakable.
            my $arrow =
            ( $i == $current_line and $filename eq $filename_ini )
            ? '==>'
            : ( $dbline[$i] + 0 ? ':' : ' ' );

            # Add break and action indicators.
            $arrow .= 'b' if $stop;
            $arrow .= 'a' if $action;

            # Print the line.
            print {$OUT} "$i$arrow\t", $dbline[$i];

            # Move on to the next line. Drop out on an interrupt.
            if ($signal) {
                $i++;
                last I_TO_END;
            }
        } ## end for (; $i <= $end ; $i++)

        # Line the prompt up; print a newline if the last line listed
        # didn't have a newline.
        if ($dbline[ $i - 1 ] !~ /\n\z/) {
            print {$OUT} "\n";
        }
    } ## end else [ if ($slave_editor)

    # Save the point we last listed to in case another relative 'l'
    # command is desired. Don't let it run off the end.
    $start = $i;
    _minify_to_max(\$start);

    return;
}

sub _cmd_l_main {
    my $spec = shift;

    # If this is '-something', delete any spaces after the dash.
    $spec =~ s/\A-\s*\z/-/;

    # If the line is '$something', assume this is a scalar containing a
    # line number.
    # Set up for DB::eval() - evaluate in *user* context.
    if ( my ($var_name) = $spec =~ /\A(\$.*)/s ) {
        return _cmd_l_handle_var_name($var_name);
    }
    # l name. Try to find a sub by that name.
    elsif ( ($subname) = $spec =~ /\A([\':A-Za-z_][\':\w]*(?:\[.*\])?)/s ) {
        return _cmd_l_handle_subname();
    }
    # Bare 'l' command.
    elsif ( $spec !~ /\S/ ) {
        return _cmd_l_empty();
    }
    # l [start]+number_of_lines
    elsif ( my ($new_start, $new_incr) = $spec =~ /\A(\d*)\+(\d*)\z/ ) {
        return _cmd_l_plus($new_start, $new_incr);
    }
    # l start-stop or l start,stop
    elsif (my ($s, $e) = $spec =~ /^(?:(-?[\d\$\.]+)(?:[-,]([\d\$\.]+))?)?/ ) {
        return _cmd_l_range($spec, $line, $s, $e);
    }
d4936 14
a4949 1
    return;
a4951 6
sub cmd_l {
    my (undef, $line) = @@_;

    return _cmd_l_main($line);
}

d4956 5
a4960 5
breakpoints and/or actions. For each file, we switch the C<*dbline> glob (the
magic source and breakpoint data structures) to the file, and then look
through C<%dbline> for lines with breakpoints and/or actions, listing them
out. We look through C<%postponed> not-yet-compiled subroutines that have
breakpoints, and through C<%postponed_file> for not-yet-C<require>'d files
d4967 3
a4969 1
sub _cmd_L_calc_arg {
d4973 1
a4973 4
    if ($CommandSet ne '580')
    {
        $arg = 'abw';
    }
d4975 4
a4978 2
    return $arg;
}
d4980 3
a4982 2
sub _cmd_L_calc_wanted_flags {
    my $arg = _cmd_L_calc_arg(shift);
d4984 2
a4985 2
    return (map { index($arg, $_) >= 0 ? 1 : 0 } qw(a b w));
}
d4987 2
d4990 4
a4993 2
sub _cmd_L_handle_breakpoints {
    my ($handle_db_line) = @@_;
d4995 2
a4996 3
    BREAKPOINTS_SCAN:
    # Look in all the files with breakpoints...
    for my $file ( keys %had_breakpoints ) {
d4998 2
a4999 7
        # Temporary switch to this file.
        local *dbline = $main::{ '_<' . $file };

        # Set up to look through the whole file.
        $max = $#dbline;
        my $was;    # Flag: did we print something
        # in this file?
d5001 2
a5002 2
        # For each line in the file ...
        for my $i (1 .. $max) {
d5004 2
a5005 2
            # We've got something on this line.
            if ( defined $dbline{$i} ) {
d5007 2
a5008 7
                # Print the header if we haven't.
                if (not $was++) {
                    print {$OUT} "$file:\n";
                }

                # Print the line.
                print {$OUT} " $i:\t", $dbline[$i];
d5010 9
a5018 1
                $handle_db_line->($dbline{$i});
d5020 6
a5025 65
                # Quit if the user hit interrupt.
                if ($signal) {
                    last BREAKPOINTS_SCAN;
                }
            } ## end if (defined $dbline{$i...
        } ## end for my $i (1 .. $max)
    } ## end for my $file (keys %had_breakpoints)

    return;
}

sub _cmd_L_handle_postponed_breakpoints {
    my ($handle_db_line) = @@_;

    print {$OUT} "Postponed breakpoints in files:\n";

    POSTPONED_SCANS:
    for my $file ( keys %postponed_file ) {
        my $db = $postponed_file{$file};
        print {$OUT} " $file:\n";
        for my $line ( sort { $a <=> $b } keys %$db ) {
            print {$OUT} "  $line:\n";

            $handle_db_line->($db->{$line});

            if ($signal) {
                last POSTPONED_SCANS;
            }
        }
        if ($signal) {
            last POSTPONED_SCANS;
        }
    }

    return;
}


sub cmd_L {
    my $cmd = shift;

    my ($action_wanted, $break_wanted, $watch_wanted) =
        _cmd_L_calc_wanted_flags(shift);

    my $handle_db_line = sub {
        my ($l) = @@_;

        my ( $stop, $action ) = split( /\0/, $l );

        if ($stop and $break_wanted) {
            print {$OUT} "    break if (", $stop, ")\n"
        }

        if ($action && $action_wanted) {
            print {$OUT} "    action:  ", $action, "\n"
        }

        return;
    };

    # Breaks and actions are found together, so we look in the same place
    # for both.
    if ( $break_wanted or $action_wanted ) {
        _cmd_L_handle_breakpoints($handle_db_line);
    }
d5029 1
a5029 1
        print {$OUT} "Postponed breakpoints in subroutines:\n";
a5030 1
        SUBS_SCAN:
d5032 2
a5033 4
            print {$OUT} " $subname\t$postponed{$subname}\n";
            if ($signal) {
                last SUBS_SCAN;
            }
d5044 19
a5062 1
        _cmd_L_handle_postponed_breakpoints($handle_db_line);
a5063 1

d5065 5
a5069 4
        print {$OUT} "Breakpoints on load:\n";
        BREAK_ON_LOAD: for my $filename ( keys %break_on_load ) {
            print {$OUT} " $filename\n";
            last BREAK_ON_LOAD if $signal;
d5072 9
a5080 10

    if ($watch_wanted and ( $trace & 2 )) {
        print {$OUT} "Watch-expressions:\n" if @@to_watch;
        TO_WATCH: for my $expr (@@to_watch) {
            print {$OUT} " $expr\n";
            last TO_WATCH if $signal;
        }
    }

    return;
d5090 1
a5090 3
    list_modules();

    return;
d5095 1
a5095 1
If this is just C<o> by itself, we list the current settings via
d5107 1
a5107 1
        parse_options($1);
d5113 1
a5113 1
            dump_option($_);
d5136 1
a5136 3
=cut

use vars qw($preview);
d5161 1
a5161 1
        cmd_l( 'l', $line );
a5176 23
sub _add_watch_expr {
    my $expr = shift;

    # ... save it.
    push @@to_watch, $expr;

    # Parameterize DB::eval and call it to get the expression's value
    # in the user's context. This version can handle expressions which
    # return a list value.
    $evalarg = $expr;
    # The &-call is here to ascertain the mutability of @@_.
    my ($val) = join( ' ', &DB::eval);
    $val = ( defined $val ) ? "'$val'" : 'undef';

    # Save the current value of the expression.
    push @@old_watch, $val;

    # We are now watching expressions.
    $trace |= 2;

    return;
}

d5184 17
a5200 2
    if ( $expr =~ /\A\S/ ) {
        _add_watch_expr($expr);
d5207 1
a5207 3

    return;
}
d5214 2
a5215 2
If C<*> is specified, we simply empty the watch expression list and the
watch expression value list. We also turn off the bit that says we've got
d5220 1
a5220 1
the corresponding values. If no watch expressions are left, we turn off
d5284 1
a5284 1
and installs the versions we like better.
d5305 1
a5305 1
us to feed line information to a slave editor without messing up the
d5324 1
a5324 1
temporarily switch the C<*dbline> glob over to the source file, and then
d5328 1
a5328 1
=cut
d5362 1
a5362 1
            $max = $#dbline;
d5387 1
a5387 1
also called if the name of a just-compiled subroutine is a key of
d5391 1
a5391 1
If this is a C<require>'d file, the incoming parameter is the glob
d5411 1
a5411 3
    if (ref(\$_[0]) ne 'GLOB') {
        return postponed_sub(@@_);
    }
d5450 1
a5450 1
C<dumpit> is the debugger's wrapper around dumpvar.pl.
d5453 1
a5453 1
a reference to a variable (the thing to be dumped) as its input.
d5457 1
a5457 1
values of the package globals C<$single> and C<$trace> are backed up in
d5461 1
a5461 1
messages from printing, and C<$doret> is localized as well and set to -2 to
d5464 3
a5466 3
C<dumpit()> then checks to see if it needs to load C<dumpvar.pl> and
tries to load it (note: if you have a C<dumpvar.pl>  ahead of the
installed version in C<@@INC>, yours will be used instead. Possible security
d5470 1
a5470 1
it should have been defined by C<dumpvar.pl>). If it has, C<dumpit()>
d5472 1
a5472 1
is called, and picks up the variable to be dumped from the parameter list.
d5474 3
a5476 3
It checks the package global C<%options> to see if there's a C<dumpDepth>
specified. If not, -1 is assumed; if so, the supplied value gets passed on to
C<dumpvar.pl>. This tells C<dumpvar.pl> where to leave off when dumping a
d5479 1
a5479 1
C<dumpValue()> is then called if possible; if not, C<dumpit()>just prints a
d5491 1
a5491 1
    my $savout = select(shift);
d5516 1
a5516 1
        main::dumpValue( $v, $maxdepth );
d5535 1
a5535 1
C<print_trace>'s job is to print a stack trace. It does this via the
d5589 1
a5589 1
    for my $i (0 .. $#sub) {
d5614 1
a5614 1
        $s = $sub[$i]{'sub'};
d5629 1
a5629 1
    } ## end for my $i (0 .. $#sub)
d5639 1
a5639 1
from the most current. C<count> determines the total number of frames to
a5661 45
sub _dump_trace_calc_saved_single_arg
{
    my ($nothard, $arg) = @@_;

    my $type;
    if ( not defined $arg ) {    # undefined parameter
        return "undef";
    }

    elsif ( $nothard and tied $arg ) {    # tied parameter
        return "tied";
    }
    elsif ( $nothard and $type = ref $arg ) {    # reference
        return "ref($type)";
    }
    else {                                       # can be stringified
        local $_ =
        "$arg";    # Safe to stringify now - should not call f().

        # Backslash any single-quotes or backslashes.
        s/([\'\\])/\\$1/g;

        # Single-quote it unless it's a number or a colon-separated
        # name.
        s/(.*)/'$1'/s
        unless /^(?: -?[\d.]+ | \*[\w:]* )$/x;

        # Turn high-bit characters into meta-whatever.
        s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;

        # Turn control characters into ^-whatever.
        s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;

        return $_;
    }
}

sub _dump_trace_calc_save_args {
    my ($nothard) = @@_;

    return [
        map { _dump_trace_calc_saved_single_arg($nothard, $_) } @@args
    ];
}

d5681 1
a5681 1
    my ( $e, $r, @@sub, $args );
d5698 1
a5698 1
        my $i = $skip ;
d5702 1
a5702 1
    )
d5706 34
a5739 1
        my $save_args = _dump_trace_calc_save_args($nothard);
d5749 1
a5749 1
        $args = $h ? $save_args : undef;
d5810 1
a5810 1
        $action .= gets();
d5824 1
a5824 1
speeds things up by only creating the qr//'ed expression once; if it's
a5828 2
use vars qw($balanced_brace_re);

d5832 1
a5832 1
    $balanced_brace_re ||= qr{
d5853 1
a5853 1
    return DB::readline("cont: ");
d5856 1
a5856 1
=head2 C<_db_system()> - handle calls to<system()> without messing up the debugger
d5859 2
a5860 2
STDOUT, but under the debugger, we want it to use the debugger's input and
outout filehandles.
d5862 1
a5862 1
C<_db_system()> socks away the program's STDIN and STDOUT, and then substitutes
d5868 1
a5868 1
sub _db_system {
d5872 4
a5875 4
    open( SAVEIN,  "<&STDIN" )  || db_warn("Can't save STDIN");
    open( SAVEOUT, ">&STDOUT" ) || db_warn("Can't save STDOUT");
    open( STDIN,   "<&IN" )     || db_warn("Can't redirect STDIN");
    open( STDOUT,  ">&OUT" )    || db_warn("Can't redirect STDOUT");
d5879 2
a5880 2
    open( STDIN,  "<&SAVEIN" )  || db_warn("Can't restore STDIN");
    open( STDOUT, ">&SAVEOUT" ) || db_warn("Can't restore STDOUT");
d5886 1
a5886 1
        db_warn( "(Command exited ", ( $? >> 8 ), ")\n" );
d5889 1
a5889 1
        db_warn(
a5900 2
*system = \&_db_system;

d5912 2
a5913 2
to find one. If we're a forked debugger, we call C<resetterm> to try to
get a whole new terminal if we can.
d5917 1
a5917 1
the appropriate attributes. We then
a5920 3
use vars qw($ornaments);
use vars qw($rl_attribs);

d5937 3
a5939 1
            _autoflush($OUT);
d5986 1
a5986 1
    load_hist();
d6034 2
a6035 2
C<get_fork_TTY> is a glob-aliased function which calls the real function that
is tasked with doing all the necessary operating system mojo to get a new
d6046 1
a6046 1
=cut
d6073 1
a6073 1
This function provides the C<get_fork_TTY> function for X11. If a
d6078 2
a6079 2
we're spawning route file number 3 to STDOUT, and then execute the C<tty>
command (which prints the device name of the TTY we'll want to use for input
d6082 1
a6082 1
is STDOUT from the I<commands> we ran) to get the TTY we want to use.
d6084 1
a6084 1
Only works if C<xterm> is in your path and C<$ENV{DISPLAY}>, etc. are
d6126 2
a6127 2
    my %opt = ( title => "Daughter Perl debugger $pids $name",
        ($rl ? (read_by_key => 1) : ()) );
d6210 4
a6213 4
        if ($version>=$entry->[0]) {
            $script=$entry->[1];
            last;
        }
a6242 2
use vars qw($fork_TTY);

d6247 1
a6247 1
    my $in = get_fork_TTY(@@_) if defined &get_fork_TTY;
d6295 1
a6295 1
If the new debugger happened because of a C<system()> that invoked a
d6300 2
a6301 2
isn't any list yet, we make one up out of the initial pid associated with
the terminal and our new pid, sticking an arrow (either one-dashed or
d6353 2
a6354 2
If we've emptied the filehandle stack, we check to see if we've got a socket
open, and we read that and return it if we do. If we don't, we just call the
a6363 14
    # If there are stacked filehandles to read from ...
    # (Handle it before the typeahead, because we may call source/etc. from
    # the typeahead.)
    while (@@cmdfhs) {

        # Read from the last one in the stack.
        my $line = CORE::readline( $cmdfhs[-1] );

        # If we got a line ...
        defined $line
          ? ( print $OUT ">> $line" and return $line )    # Echo and return
          : close pop @@cmdfhs;                            # Pop and close
    } ## end while (@@cmdfhs)

d6389 12
d6408 1
d6411 1
a6411 5
        my $first_time = 1;

        while ($first_time or (length($buf) && ($stuff .= $buf) !~ /\n/))
        {
            $first_time = 0;
d6414 1
a6414 1
        }
d6417 1
a6417 1
        return $stuff;
d6422 1
a6422 1
        return $term->readline(@@_);
d6514 1
a6514 1
it just gets stuck in a variable, we do that; if there's a subroutine to
d6524 1
a6524 1
    my ($s) = @@_;
a6526 2
    my $option;

d6533 1
a6533 1
    while (length($s)) {
d6537 1
a6537 1
        $s =~ s/^\s+// && next;
d6541 1
a6541 4
        if ($s !~ s/^(\w+)(\W?)//) {
            print {$OUT} "Invalid option '$s'\n";
            last;
        }
d6545 2
a6546 2
        my $matches = ( grep { /^\Q$opt/ && ( $option = $_ ) } @@options )
          || ( grep { /^\Q$opt/i && ( $option = $_ ) } @@options );
d6548 2
a6549 8
        unless ($matches) {
            print {$OUT} "Unknown option '$opt'\n";
            next;
        }
        if ($matches > 1) {
            print {$OUT} "Ambiguous option '$opt'\n";
            next;
        }
d6554 3
a6556 5
            if ($s =~ /\A\S/) {
                print {$OUT} "Option query '$opt?' followed by non-space '$s'\n" ;

                last;
            }
d6572 1
a6572 1
            if ($s =~ s/ (["']) ( (?: \\. | (?! \1 ) [^\\] )* ) \1 //x) {
d6579 1
a6579 1
                $s =~ s/^(\S*)//;
d6591 1
a6591 1
            $s =~ s/^(([^\\$end]|\\[\\$end])*)$end($|\s+)//
d6599 1
a6599 1
            print {$OUT}
d6608 8
a6615 8
        if ( defined($optionRequire{$option}) && defined($val) ) {
            eval qq{
            local \$frame = 0;
            local \$doret = -2;
            require '$optionRequire{$option}';
            1;
            } || die $@@   # XXX: shouldn't happen
        }
d6619 3
a6621 3
        if (defined($optionVars{$option}) && defined($val)) {
            ${ $optionVars{$option} } = $val;
        }
d6624 4
a6627 6
        if (defined($optionAction{$option})
          && defined (&{ $optionAction{$option} })
          && defined ($val))
        {
          &{ $optionAction{$option} }($val);
        }
d6630 1
a6630 1
        dump_option($option) if ($OUT ne \*STDERR);
d6636 1
a6636 1
These routines are used to store (and restore) lists of items in environment
d6657 1
a6657 1
    for my $i ( 0 .. $#list ) {
d6670 1
a6670 1
=cut
d6677 1
a6677 1
    for my $i ( 0 .. $n - 1 ) {
d6690 1
a6690 1
set an already-existing global scalar variable to a constant value. This
d6706 3
a6708 3
If the composited message I<doesn't> end with a newline, we automatically
add C<$!> and a newline to the end of the message. The subroutine expects $OUT
to be set to the filehandle to be used to output warnings; it makes no
d6713 1
a6713 1
sub _db_warn {
a6719 2
*warn = \&_db_warn;

d6725 1
a6725 1
after we've tried and failed to move them elsewhere.  In addition, it assigns
d6741 1
a6741 1
        _db_warn("Too late to set IN/OUT filehandles, enabled on next 'R'!\n");
d6750 3
a6752 1
    _autoflush($OUT);
d6760 1
a6760 1
The following routines are used to process some of the more complicated
d6808 1
a6808 3
    if ($term and @@_) {
        _db_warn("Too late to set TTY, enabled on next 'R'!\n");
    }
d6827 1
a6827 1
        _db_warn("Too late to set noTTY, enabled on next 'R'!\n") if @@_;
d6835 1
a6835 1
Sets the C<$rl> option variable. If 0, we use C<Term::ReadLine::Stub>
d6844 1
a6844 1
        _db_warn("Too late to set ReadLine, enabled on next 'R'!\n") if @@_;
d6860 1
a6860 1
        _db_warn("Too late to set RemotePort, enabled on next 'R'!\n") if @@_;
d6893 1
a6893 1
        _db_warn("Too late to set up NonStop mode, enabled on next 'R'!\n")
d6902 1
a6902 1
        _db_warn("Some flag changes could not take effect until next 'R'!\n")
d6926 1
a6926 1
Sets the shell escape command, and generates a printable copy to be used
d6953 1
a6953 1
=cut
d6959 1
a6959 2
        local $warnLevel = 0;
        local $dieLevel = 1;
d6962 2
a6963 5
        if (not $term->Features->{ornaments}) {
            return '';
        }

        return (eval { $term->ornaments(@@_) } || '');
a6968 2

        return $ornaments;
a6969 1

d6989 1
a6989 1
    $prc = $rc;              # Copy it
d6992 1
a6992 1
    return $prc;             # Return the printable version
d6999 2
a7000 2
Called with an argument (a file or a pipe), it opens that onto the
C<LINEINFO> filehandle, unbuffers the filehandle, and then returns the
d7006 2
a7007 9
    if (@@_) {
        $lineinfo = shift;

        #  If this is a valid "thing to be opened for output", tack a
        # '>' onto the front.
        my $stream = ( $lineinfo =~ /^(\+?\>|\|)/ ) ? $lineinfo : ">$lineinfo";

        # If this is a pipe, the stream points to a slave editor.
        $slave_editor = ( $stream =~ /^\|/ );
d7009 13
a7021 7
        my $new_lineinfo_fh;
        # Open it up and unbuffer it.
        open ($new_lineinfo_fh , $stream )
            or _db_warn("Cannot open '$stream' for write");
        $LINEINFO = $new_lineinfo_fh;
        _autoflush($LINEINFO);
    }
d7023 2
a7024 1
    return $lineinfo;
d7056 2
a7057 3
        my $pkg_version = do { no strict 'refs'; ${ $_ . '::VERSION' } };
        if ( defined $pkg_version ) {
            $version{$file} = "$pkg_version from ";
d7085 2
a7086 2
If you are modifying the help text, I<be careful>. The help-string parser is
not very sophisticated, and if you don't follow these rules it will mangle the
a7090 3
use vars qw($pre580_help);
use vars qw($pre580_summary);

d7098 2
a7099 2
Help is currently only available for the new 5.8 command set.
No help is available for the old command set.
d7140 1
a7140 1
        Set breakpoint at first line of subroutine after
d7211 1
a7211 1
        history, breakpoints and actions, debugger B<O>ptions
d7216 1
a7216 1
B<o> [I<opt>B<=>I<val>] [I<opt>=B<\">I<val>B<\">] ...
d7252 1
a7252 1
B<$doccmd> I<manpage>    Runs the external doc viewer B<$doccmd> command on the
d7331 1
a7331 1
        Set breakpoint at first line of subroutine after
d7387 1
a7387 1
        history, breakpoints and actions, debugger B<O>ptions
d7392 1
a7392 1
B<O> [I<opt>B<=>I<val>] [I<opt>=B<\">I<val>B<\">] ...
d7427 1
a7427 1
B<$doccmd> I<manpage>    Runs the external doc viewer B<$doccmd> command on the
d7471 1
a7471 1
terminal control characters to simulate them (courtesy of
d7477 1
a7477 1
    my $help_str = shift;
d7485 1
a7485 1
    $help_str =~ s{
d7491 1
a7491 1
          ( .* )                # this will now start (no earlier) than
d7496 1
a7496 1
        $clean =~ s/[BI]<([^>]*)>/$1/g;
d7506 1
a7506 1
    $help_str =~ s{                          # handle bold ornaments
d7509 1
a7509 1
          $Term::ReadLine::TermCap::rl_term_set[2]
d7514 1
a7514 1
    $help_str =~ s{                         # handle italic ornaments
d7517 1
a7517 1
          $Term::ReadLine::TermCap::rl_term_set[0]
d7523 1
a7523 3
    print {$OUT} $help_str;

    return;
d7526 1
a7526 1
=head2 C<fix_less>
d7534 8
a7541 1
use vars qw($fixed_less);
a7542 7
sub _calc_is_less {
    if ($pager =~ /\bless\b/)
    {
        return 1;
    }
    elsif ($pager =~ /\bmore\b/)
    {
d7548 5
a7552 16
        return (
            @@st_more
            && @@st_less
            && $st_more[0] == $st_less[0]
            && $st_more[1] == $st_less[1]
        );
    }
    else {
        return;
    }
}

sub fix_less {

    # We already know if this is set.
    return if $fixed_less;
d7556 1
a7556 3
    $fixed_less = 1 if _calc_is_less();

    return;
d7597 1
a7597 1
        _db_warn( Carp::longmess("Signal @@_") );
d7656 1
a7656 1
    _db_warn($mess);
d7662 2
a7663 2
by loading C<Carp> and calling C<Carp::longmess()> to get it. We turn off
single stepping and tracing during the call to C<Carp::longmess> to avoid
d7669 1
a7669 1
displaying the exception via its C<dbwarn()> routine.
d7678 3
d7683 1
a7683 1
        _db_warn(@@_);    # Yell no matter what
d7727 1
a7727 1
        my $prevwarn = $SIG{__WARN__} unless $warnLevel;
d7743 1
a7743 1
Similar to C<warnLevel>. Non-zero values for C<dieLevel> result in the
d7752 1
a7752 1
        my $prevdie = $SIG{__DIE__} unless $dieLevel;
d7788 1
a7788 1
signal handler for C<SIGSEGV> and/or C<SIGBUS>. Otherwise, the debugger
d7795 2
a7796 2
        my $prevsegv = $SIG{SEGV} unless $signalLevel;
        my $prevbus  = $SIG{BUS}  unless $signalLevel;
a7841 2
use vars qw($skipCvGV);

d7854 1
a7854 1
A utility routine used in various places; finds the file where a subroutine
a7863 26
sub _find_sub_helper {
    my $subr = shift;

    return unless defined &$subr;
    my $name = CvGV_name_or_bust($subr);
    my $data;
    $data = $sub{$name} if defined $name;
    return $data if defined $data;

    # Old stupid way...
    $subr = \&$subr;    # Hard reference
    my $s;
    for ( keys %sub ) {
        $s = $_, last if $subr eq \&$_;
    }
    if ($s)
    {
        return $sub{$s};
    }
    else
    {
        return;
    }

}

d7866 15
a7880 1
    return ( $sub{$subr} || _find_sub_helper($subr) );
d7886 1
a7886 1
methods in the class corresponding to the current reference and in
a7890 2
use vars qw(%seen);

d7929 12
a7940 13
    my $class_ref = do { no strict "refs"; \%{$class . '::'} };
    while (my ($name, $glob) = each %$class_ref) {
        # references directly in the symbol table are Proxy Constant
        # Subroutines, and are by their very nature defined
        # Otherwise, check if the thing is a typeglob, and if it is, it decays
        # to a subroutine reference, which can be tested by defined.
        # $glob might also be the value -1  (from sub foo;)
        # or (say) '$$' (from sub foo ($$);)
        # \$glob will be SCALAR in both cases.
        if ((ref $glob || ($glob && ref \$glob eq 'GLOB' && defined &$glob))
            && !$seen{$name}++) {
            push @@to_print, "$prepend$name\n";
        }
d7944 3
a7946 3
        local $\ = '';
        local $, = '';
        print $DB::OUT $_ foreach sort @@to_print;
d7954 1
a7954 2
    my $class_ISA_ref = do { no strict "refs"; \@@{"${class}::ISA"} };
    for my $name ( @@$class_ISA_ref ) {
d7979 1
a7979 1
during debugger initialization). Uses C<_db_system()> to avoid mucking up the
d7984 42
a8025 2
my %_is_in_pods = (map { $_ => 1 }
    qw(
d8047 1
d8072 1
d8110 1
d8152 1
a8157 1
    )
d8159 2
a8160 43

sub runman {
    my $page = shift;
    unless ($page) {
        _db_system("$doccmd $doccmd");
        return;
    }

    # this way user can override, like with $doccmd="man -Mwhatever"
    # or even just "man " to disable the path check.
    if ( $doccmd ne 'man' ) {
        _db_system("$doccmd $page");
        return;
    }

    $page = 'perl' if lc($page) eq 'help';

    require Config;
    my $man1dir = $Config::Config{'man1dir'};
    my $man3dir = $Config::Config{'man3dir'};
    for ( $man1dir, $man3dir ) { s#/[^/]*\z## if /\S/ }
    my $manpath = '';
    $manpath .= "$man1dir:" if $man1dir =~ /\S/;
    $manpath .= "$man3dir:" if $man3dir =~ /\S/ && $man1dir ne $man3dir;
    chop $manpath if $manpath;

    # harmless if missing, I figure
    my $oldpath = $ENV{MANPATH};
    $ENV{MANPATH} = $manpath if $manpath;
    my $nopathopt = $^O =~ /dunno what goes here/;
    if (
        CORE::system(
            $doccmd,

            # I just *know* there are men without -M
            ( ( $manpath && !$nopathopt ) ? ( "-M", $manpath ) : () ),
            split ' ', $page
        )
      )
    {
        unless ( $page =~ /^perl\w/ ) {
# do it this way because its easier to slurp in to keep up to date - clunky though.
            if (exists($_is_in_pods{$page})) {
d8163 3
a8165 3
                    "perl$page" );
            }
        }
d8187 1
a8187 1
=over 4
a8238 2
use vars qw($db_stop);

d8290 1
a8290 1
    @@stack = (0);
d8310 1
a8310 1
C<readline> support - adds command completion to basic C<readline>.
d8313 1
a8313 1
will print the longest common substring following the text already entered.
d8317 1
a8317 1
This code uses C<map> and C<grep> heavily to create lists of possible
d8334 1
a8334 1
      ( $text, "^\Q${package}::\E([^:]+)\$" );
d8336 1
a8336 1
=head3 C<b postpone|compile>
d8362 1
a8362 1
=cut
d8399 1
a8399 1
the subpackages against the text, and discarding all of them which
d8406 1
a8406 2
      map { /^(.*)::$/ ? ( $prefix . "::$1" ) : () }
      do { no strict 'refs'; keys %{ $prefix . '::' } }
d8437 3
a8439 3
Under the debugger, source files are represented as C<_E<lt>/fullpath/to/file>
(C<eval>s are C<_E<lt>(eval NNN)>) keys in C<%main::>. We pull all of these
out of C<%main::>, add the initial source file, and extract the ones that
d8477 1
a8477 1
=over 4
d8506 2
a8507 5
        my @@out = do {
            no strict 'refs';
            map "$prefix$_", grep /^\Q$text/, grep /^_?[a-zA-Z]/,
            keys %$pack;
        };
d8612 1
a8612 1
=head3 Options
d8615 1
a8615 1
only a single value, we complete the command in such a way that it is a
d8645 1
a8645 1
            foreach my $l ( split //, qq/\"\'\#\|/ ) {
d8802 1
a8802 1
    my $i = shift;
d8812 3
a8814 3
        @@args = restart();              # setup
        get_list("PERLDB_HIST");        # clean
        set_list("PERLDB_HIST", @@temp); # reset
d8856 2
a8857 3
        my $lines = *{$main::{'_<-e'}}{ARRAY};
        for ( 1 .. $#$lines ) {  # The first line is PERL5DB
            chomp( $cl = $lines->[$_] );
d8897 1
a8897 1
=pod
d8937 1
a8937 1
        set_list( "PERLDB_FILE_ENABLED_$_",
d8945 1
a8945 1
    foreach my $hard_file (@@hard) {
d8947 5
a8951 7
        *dbline = $main::{ '_<' . $hard_file };
        my $quoted = quotemeta $hard_file;
        my %subs;
        for my $sub ( keys %sub ) {
            if (my ($n1, $n2) = $sub{$sub} =~ /\A$quoted:(\d+)-(\d+)\z/) {
                $subs{$sub} = [ $n1, $n2 ];
            }
d8954 2
a8955 2
            print {$OUT}
            "No subroutines in $hard_file, ignoring breakpoints.\n";
d8958 1
a8958 1
        LINES: foreach my $line ( keys %dbline ) {
d8961 2
a8962 2
            my ( $offset, $found );
            SUBS: foreach my $sub ( keys %subs ) {
d8964 2
a8965 1
                    $subs{$sub}->[1] >= $line    # Not after the subroutine
d8968 1
a8968 1
                            or $offset < 0
d8970 1
a8970 1
                )
d8974 2
a8975 4
                    if ($offset >= 0) {
                        $offset = "+$offset";
                        last SUBS;
                    }
d8980 1
a8980 1
                "break $offset if $dbline{$line}";
d8983 2
a8984 3
                print {$OUT}
                ("Breakpoint in ${hard_file}:$line ignored:"
                . " after all the subroutines.\n");
d9006 1
a9006 1
=pod
d9018 1
a9018 1
    # and then the old arguments.
d9028 3
a9030 3
Come here at the very end of processing. We want to go into a
loop where we allow the user to enter commands and interact with the
debugger, but we don't want anything else to execute.
d9043 1
a9043 1
1 and the C<END> block simply exits with C<$single> set to 0 (don't
d9054 1
a9054 1
        save_hist();
d9063 1
a9063 1
Some of the commands changed function quite a bit in the 5.8 command
d9068 1
a9068 1
There's an awful lot of duplicated code here. We've duplicated the
d9097 2
a9098 2
        my $i = $1 || $line;
        my $j = $2;
d9133 1
a9133 1
=head2 Old C<b> command
d9148 1
a9148 1
        cmd_b_load($file);
d9167 1
a9167 1
        $subname = "${package}::" . $subname
d9181 1
a9181 1
        cmd_b_sub( $subname, $cond );
d9187 1
a9187 1
        cmd_b_line( $i, $cond );
d9211 1
a9211 1
            $max = $#dbline;
d9215 1
a9215 1
            for my $i (1 .. $max) {
d9228 1
a9228 1
            } ## end for my $i (1 .. $max)
d9248 1
a9248 1
Print help. Defaults to printing the long-form help; the 5.8 version
d9334 1
a9334 2
        # The &-call is here to ascertain the mutability of @@_.
        my ($val) = &DB::eval;
d9348 1
a9348 1
The debugger used to have a bunch of nearly-identical code to handle
d9350 1
a9350 1
C<cmd_prepost> unify all this into one set of code to handle the
d9366 1
a9366 1
    return cmd_prepost( $cmd, $line, $dbline );
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@d321 1
a321 1
=item * 16 - Adds C<I<context> return from I<subname>: I<value>> messages on subroutine/eval exit. Ignored if C<4> is not on.
d526 1
a526 1
$VERSION = '1.44';
d1365 1
a1365 2
  PERLDB_POSTPONE  - subs that have been loaded/not executed,
                     and have actions
d1825 1
a1825 1
    # ... and it belongs to this PID or we get one for this PID ...
d2101 1
a2101 1
            # Turn off warn and die processing for a bit.
a2420 3
        # Let Readline know about the new filehandles.
        reset_IN_OUT( \*IN, \*OUT );

d2504 1
a2504 1
        qw(a A b B e E h i l L M o O v w W)),
d2972 1
a2972 1
that the terminal supports history). It finds the command required, puts it
d3150 1
a3150 1
# The following package declaration must come before that,
d4096 3
d4271 1
a4271 3
    # Use local so the single-step value is popped back off the
    # stack for us.
    local $single = $single & 1;
d4280 3
d6094 1
a6094 1
        #  a) we don't want to stop calling watchfunction() if it exists
d6149 1
a6149 5
    # $LINEINFO may be undef if $noTTY is set or some other issue.
    if ($LINEINFO)
    {
        print {$LINEINFO} @@_;
    }
d6429 1
a6429 1
        # Set the separator so arrays print nice.
d8901 133
d9051 2
a9052 2
    my $man1dir = $Config::Config{man1direxp};
    my $man3dir = $Config::Config{man3direxp};
d9060 2
a9061 1
    local $ENV{MANPATH} = $manpath if $manpath;
d9074 2
a9075 15
            # Previously the debugger contained a list which it slurped in,
            # listing the known "perl" manpages. However, it was out of date,
            # with errors both of omission and inclusion. This approach is
            # considerably less complex. The failure mode on a butchered
            # install is simply that the user has to run man or perldoc
            # "manually" with the full manpage name.

            # There is a list of $^O values in installperl to determine whether
            # the directory is 'pods' or 'pod'. However, we can avoid tight
            # coupling to that by simply checking the "non-standard" 'pods'
            # first.
            my $pods = "$Config::Config{privlibexp}/pods";
            $pods = "$Config::Config{privlibexp}/pod"
                unless -d $pods;
            if (-f "$pods/perl$page.pod") {
d9082 6
d9168 1
a9168 1
    $deep = 1000;
d9514 1
a9514 1
          ( grep /^_?[a-zA-Z]/, do { no strict 'refs'; keys %$pack } ),
d10315 1
a10315 1
    # This means that if for some reason the tests fail, we won't be
@


1.1.1.17
log
@Import perl-5.24.2
@
text
@d192 1
a192 1
like C<(eval 34)>.
a514 4
use Cwd ();

my $_initial_cwd;

a520 1
    $_initial_cwd = Cwd::getcwd();
d526 1
a526 1
$VERSION = '1.49_05';
a868 1
        *lock = sub(*) {};
a1333 3
    elsif ( $ENV{TMUX} ) {
        *get_fork_TTY = \&tmux_get_fork_TTY;
    }
a1541 8
=item * AmigaOS - use C<CONSOLE:>.

=cut

    elsif ( $^O eq 'amigaos' ) {
        $console = "CONSOLE:";
    }

d1546 1
a1546 3
    elsif ($^O eq 'VMS') {
        $console = 'sys$command';
    }
d1548 2
a1549 5
# Keep this last.

    else {
        _db_warn("Can't figure out your console, using stdin");
        undef $console;
d1932 1
a1932 4
        if (!eval {
            local @@INC = @@INC;
            pop @@INC if $INC[-1] eq '.';
            require PadWalker; PadWalker->VERSION(0.08) }) {
d1952 1
a1952 1
        my $h = eval { PadWalker::peek_my( ( $match_level || 0 ) + 2 ) };
a2259 7

        # Change directory to the initial current working directory on
        # the script startup, so if the debugged program changed the
        # directory, then we will still be able to find the path to the
        # the program. (perl 5 RT #121509 ).
        chdir ($_initial_cwd);

d2477 1
a2477 5
my %cmd_lookup;

BEGIN
{
    %cmd_lookup =
a2509 1
};
a3305 3
        # At program termination disable any user actions.
        $DB::action = undef;

d6528 5
a6532 4
        # Turn high-bit characters into meta-whatever, and controls into like
        # '^D'.
        require 'meta_notation.pm';
        $_ = _meta_notation($_) if /[[:^print:]]/a;
d6725 4
a6728 4
    open( SAVEIN,  "<&STDIN" )  || _db_warn("Can't save STDIN");
    open( SAVEOUT, ">&STDOUT" ) || _db_warn("Can't save STDOUT");
    open( STDIN,   "<&IN" )     || _db_warn("Can't redirect STDIN");
    open( STDOUT,  ">&OUT" )    || _db_warn("Can't redirect STDOUT");
d6732 2
a6733 2
    open( STDIN,  "<&SAVEIN" )  || _db_warn("Can't restore STDIN");
    open( STDOUT, ">&SAVEOUT" ) || _db_warn("Can't restore STDOUT");
d6739 1
a6739 1
        _db_warn( "(Command exited ", ( $? >> 8 ), ")\n" );
d6742 1
a6742 1
        _db_warn(
a7079 39
=head3 C<tmux_get_fork_TTY>

Creates a split window for subprocesses when a process running under the
perl debugger in Tmux forks.

=cut

sub tmux_get_fork_TTY {
    return unless $ENV{TMUX};

    my $pipe;

    my $status = open $pipe, '-|', 'tmux', 'split-window',
        '-P', '-F', '#{pane_tty}', 'sleep 100000';

    if ( !$status ) {
        return;
    }

    my $tty = <$pipe>;
    close $pipe;

    if ( $tty ) {
        chomp $tty;

        if ( !defined $term ) {
            require Term::ReadLine;
            if ( !$rl ) {
                $term = Term::ReadLine::Stub->new( 'perldb', $IN, $OUT );
            }
            else {
                $term = Term::ReadLine->new( 'perldb', $IN, $OUT );
            }
        }
    }

    return $tty;
}

d7522 1
a7522 1
them as hexadecimal values.
d7538 1
a7538 3
        no warnings 'experimental::regex_sets';
        $val =~ s/ ( (?[ [\000-\xFF] & [:^print:] ]) ) /
                                                "\\0x" . unpack('H2',$1)/xaeg;
d8378 1
a8378 1
          ( \ {4} | \t )*       # some subcommands are indented
d9367 1
a9367 4
        if (not $text =~ /::/ and eval {
            local @@INC = @@INC;
            pop @@INC if $INC[-1] eq '.';
            require PadWalker } ) {
@


