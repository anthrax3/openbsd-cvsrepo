head	1.4;
access;
symbols
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.2.0.6
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	PERL_5_10_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.4
date	2010.09.24.14.59.36;	author millert;	state dead;
branches;
next	1.3;

1.3
date	2009.10.12.18.24.39;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2008.09.29.21.41.37;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.29.17.18.48;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.29.17.18.48;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.10.12.18.11.04;	author millert;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package CPANPLUS::Dist::Build;

use strict;
use warnings;
use vars    qw[@@ISA $STATUS $VERSION];
@@ISA =      qw[CPANPLUS::Dist];

use CPANPLUS::Internals::Constants;

### these constants were exported by CPANPLUS::Internals::Constants
### in previous versions.. they do the same though. If we want to have
### a normal 'use' here, up the dependency to CPANPLUS 0.056 or higher
BEGIN { 
    require CPANPLUS::Dist::Build::Constants;
    CPANPLUS::Dist::Build::Constants->import()
        if not __PACKAGE__->can('BUILD') && __PACKAGE__->can('BUILD_DIR');
}

use CPANPLUS::Error;

use Config;
use FileHandle;
use Cwd;
use version;

use IPC::Cmd                    qw[run];
use Params::Check               qw[check];
use Module::Load::Conditional   qw[can_load check_install];
use Locale::Maketext::Simple    Class => 'CPANPLUS', Style => 'gettext';

local $Params::Check::VERBOSE = 1;

$VERSION = '0.36';

=pod

=head1 NAME

CPANPLUS::Dist::Build - CPANPLUS plugin to install packages that use Build.PL

=head1 SYNOPSIS

    my $build = CPANPLUS::Dist->new(
                                format  => 'CPANPLUS::Dist::Build',
                                module  => $modobj,
                            );
                            
    $build->prepare;    # runs Build.PL                            
    $build->create;     # runs build && build test
    $build->install;    # runs build install


=head1 DESCRIPTION

C<CPANPLUS::Dist::Build> is a distribution class for C<Module::Build>
related modules.
Using this package, you can create, install and uninstall perl
modules. It inherits from C<CPANPLUS::Dist>.

Normal users won't have to worry about the interface to this module,
as it functions transparently as a plug-in to C<CPANPLUS> and will 
just C<Do The Right Thing> when it's loaded.

=head1 ACCESSORS

=over 4

=item C<parent()>

Returns the C<CPANPLUS::Module> object that parented this object.

=item C<status()>

Returns the C<Object::Accessor> object that keeps the status for
this module.

=back

=head1 STATUS ACCESSORS

All accessors can be accessed as follows:
    $build->status->ACCESSOR

=over 4

=item C<build_pl ()>

Location of the Build file.
Set to 0 explicitly if something went wrong.

=item C<build ()>

BOOL indicating if the C<Build> command was successful.

=item C<test ()>

BOOL indicating if the C<Build test> command was successful.

=item C<prepared ()>

BOOL indicating if the C<prepare> call exited succesfully
This gets set after C<perl Build.PL>

=item C<distdir ()>

Full path to the directory in which the C<prepare> call took place,
set after a call to C<prepare>. 

=item C<created ()>

BOOL indicating if the C<create> call exited succesfully. This gets
set after C<Build> and C<Build test>.

=item C<installed ()>

BOOL indicating if the module was installed. This gets set after
C<Build install> exits successfully.

=item uninstalled ()

BOOL indicating if the module was uninstalled properly.

=item C<_create_args ()>

Storage of the arguments passed to C<create> for this object. Used
for recursive calls when satisfying prerequisites.

=item C<_install_args ()>

Storage of the arguments passed to C<install> for this object. Used
for recursive calls when satisfying prerequisites.

=back

=cut

=head1 METHODS

=head2 $bool = CPANPLUS::Dist::Build->format_available();

Returns a boolean indicating whether or not you can use this package
to create and install modules in your environment.

=cut

### check if the format is available ###
sub format_available {
    my $mod = "Module::Build";
    unless( can_load( modules => { $mod => '0.2611' } ) ) {
        error( loc( "You do not have '%1' -- '%2' not available",
                    $mod, __PACKAGE__ ) );
        return;
    }

    return 1;
}


=head2 $bool = $dist->init();

Sets up the C<CPANPLUS::Dist::Build> object for use.
Effectively creates all the needed status accessors.

Called automatically whenever you create a new C<CPANPLUS::Dist> object.

=cut

sub init {
    my $dist    = shift;
    my $status  = $dist->status;

    $status->mk_accessors(qw[build_pl build test created installed uninstalled
                             _create_args _install_args _prepare_args
                             _mb_object _buildflags
                            ]);

    ### just in case 'format_available' didn't get called
    require Module::Build;

    return 1;
}

=pod

=head2 $bool = $dist->prepare([perl => '/path/to/perl', buildflags => 'EXTRA=FLAGS', force => BOOL, verbose => BOOL])

C<prepare> prepares a distribution, running C<Build.PL> 
and establishing any prerequisites this
distribution has.

The variable C<PERL5_CPANPLUS_IS_EXECUTING> will be set to the full path 
of the C<Build.PL> that is being executed. This enables any code inside
the C<Build.PL> to know that it is being installed via CPANPLUS.

After a succcesfull C<prepare> you may call C<create> to create the
distribution, followed by C<install> to actually install it.

Returns true on success and false on failure.

=cut

sub prepare {
    ### just in case you already did a create call for this module object
    ### just via a different dist object
    my $dist = shift;
    my $self = $dist->parent;

    ### we're also the cpan_dist, since we don't need to have anything
    ### prepared from another installer
    $dist    = $self->status->dist_cpan if      $self->status->dist_cpan;
    $self->status->dist_cpan( $dist )   unless  $self->status->dist_cpan;

    my $cb   = $self->parent;
    my $conf = $cb->configure_object;
    my %hash = @@_;

    my $dir;
    unless( $dir = $self->status->extract ) {
        error( loc( "No dir found to operate on!" ) );
        return;
    }

    my $args;
    my( $force, $verbose, $buildflags, $perl, $prereq_target, $prereq_format,
        $prereq_build );
    {   local $Params::Check::ALLOW_UNKNOWN = 1;
        my $tmpl = {
            force           => {    default => $conf->get_conf('force'),
                                    store   => \$force },
            verbose         => {    default => $conf->get_conf('verbose'),
                                    store   => \$verbose },
            perl            => {    default => $^X, store => \$perl },
            buildflags      => {    default => $conf->get_conf('buildflags'),
                                    store   => \$buildflags },
            prereq_target   => {    default => '', store => \$prereq_target }, 
            prereq_format   => {    default => '',
                                    store   => \$prereq_format },   
            prereq_build    => {    default => 0, store => \$prereq_build },
        };

        $args = check( $tmpl, \%hash ) or return;
    }

    return 1 if $dist->status->prepared && !$force;

    $dist->status->_prepare_args( $args );

    ### chdir to work directory ###
    my $orig = cwd();
    unless( $cb->_chdir( dir => $dir ) ) {
        error( loc( "Could not chdir to build directory '%1'", $dir ) );
        return;
    }

    ### by now we've loaded module::build, and we're using the API, so
    ### it's safe to remove CPANPLUS::inc from our inc path, especially
    ### because it can trip up tests run under taint (just like EU::MM).
    ### turn off our PERL5OPT so no modules from CPANPLUS::inc get
    ### included in make test -- it should build without.
    ### also, modules that run in taint mode break if we leave
    ### our code ref in perl5opt
    ### XXX we've removed the ENV settings from cp::inc, so only need
    ### to reset the @@INC
    #local $ENV{PERL5OPT} = CPANPLUS::inc->original_perl5opt;
    #local $ENV{PERL5LIB} = CPANPLUS::inc->original_perl5lib;
    #local @@INC           = CPANPLUS::inc->original_inc;

    ### this will generate warnings under anything lower than M::B 0.2606
    my @@buildflags = $dist->_buildflags_as_list( $buildflags );
    $dist->status->_buildflags( $buildflags );

    my $fail;
    RUN: {
        # 0.85_01
        ### we resolve 'configure requires' here, so we can run the 'perl
        ### Makefile.PL' command
        ### XXX for tests: mock f_c_r to something that *can* resolve and
        ### something that *doesnt* resolve. Check the error log for ok
        ### on this step or failure
        ### XXX make a seperate tarball to test for this scenario: simply
        ### containing a makefile.pl/build.pl for test purposes?
        my $safe_ver = version->new('0.85_01');
        if ( version->new($CPANPLUS::Internals::VERSION) >= $safe_ver )
        {   my $configure_requires = $dist->find_configure_requires;     
            my $ok = $dist->_resolve_prereqs(
                            format          => $prereq_format,
                            verbose         => $verbose,
                            prereqs         => $configure_requires,
                            target          => $prereq_target,
                            force           => $force,
                            prereq_build    => $prereq_build,
                    );    
    
            unless( $ok ) {
           
                #### use $dist->flush to reset the cache ###
                error( loc( "Unable to satisfy '%1' for '%2' " .
                            "-- aborting install", 
                            'configure_requires', $self->module ) );    
                $dist->status->prepared(0);
                $fail++; 
                last RUN;
            } 
            ### end of prereq resolving ###
        }

        # Wrap the exception that may be thrown here (should likely be
        # done at a much higher level).
        my $prep_output;

        my $env = ENV_CPANPLUS_IS_EXECUTING;
        local $ENV{$env} = BUILD_PL->( $dir );
        my $run_perl    = $conf->get_program('perlwrapper');
        my $cmd = [$perl, $run_perl, BUILD_PL->($dir), @@buildflags];

        unless ( scalar run(    command => $cmd,
                                buffer  => \$prep_output,
                                verbose => $verbose ) 
        ) {
            error( loc( "Build.PL failed: %1", $prep_output ) );
            $fail++; last RUN;
        }

        msg( $prep_output, 0 );

        my $prereqs = $self->status->prereqs;

        $prereqs ||= $dist->_find_prereqs( verbose => $verbose, 
                                           dir => $dir, 
                                           perl => $perl,
                                           buildflags => $buildflags );

    }
    
    ### send out test report? ###
    if( $fail and $conf->get_conf('cpantest') ) {
           $cb->_send_report( 
            module  => $self,
            failed  => $fail,
            buffer  => CPANPLUS::Error->stack_as_string,
            verbose => $verbose,
            force   => $force,
        ) or error(loc("Failed to send test report for '%1'",
                    $self->module ) );
    }

    unless( $cb->_chdir( dir => $orig ) ) {
        error( loc( "Could not chdir back to start dir '%1'", $orig ) );
    }

    ### save where we wrote this stuff -- same as extract dir in normal
    ### installer circumstances
    $dist->status->distdir( $self->status->extract );

    return $dist->status->prepared( $fail ? 0 : 1 );
}

sub _find_prereqs {
    my $dist = shift;
    my $self = $dist->parent;
    my $cb   = $self->parent;
    my $conf = $cb->configure_object;
    my %hash = @@_;

    my ($verbose, $dir, $buildflags, $perl);
    my $tmpl = {
        verbose => { default => $conf->get_conf('verbose'), store => \$verbose },
        dir     => { default => $self->status->extract, store => \$dir },
        perl    => { default => $^X, store => \$perl },
        buildflags => { default => $conf->get_conf('buildflags'),
                        store   => \$buildflags },
    };
    
    my $args = check( $tmpl, \%hash ) or return;

    my $prereqs = {};

    my $safe_ver = version->new('0.31_03');

    my $content;

    if ( version->new( $Module::Build::VERSION ) >= $safe_ver and IPC::Cmd->can_capture_buffer ) {
        my @@buildflags = $dist->_buildflags_as_list( $buildflags );

        # Use the new Build action 'prereq_data'
        my $run_perl    = $conf->get_program('perlwrapper');

        unless ( scalar run(    command => [$perl, $run_perl, BUILD->($dir), 'prereq_data', @@buildflags],
                                buffer  => \$content,
                                verbose => 0 ) 
        ) {
            error( loc( "Build 'prereq_data' failed: %1 %2", $!, $content ) );
            return;
        }

    }
    else {
        my $file = File::Spec->catfile( $dir, '_build', 'prereqs' );
        return unless -f $file;

        my $fh = FileHandle->new();

        unless( $fh->open( $file ) ) {
           error( loc( "Cannot open '%1': %2", $file, $! ) );
           return;
        }
        
        $content = do { local $/; <$fh> };
    }

    return unless $content;
    my $bphash = eval $content;
    return unless $bphash and ref $bphash eq 'HASH';
    foreach my $type ('requires', 'build_requires') {
       next unless $bphash->{$type} and ref $bphash->{$type} eq 'HASH';
       $prereqs->{$_} = $bphash->{$type}->{$_} for keys %{ $bphash->{$type} };
    }

    # Temporary fix
    delete $prereqs->{'perl'};

    ### allows for a user defined callback to filter the prerequisite
    ### list as they see fit, to remove (or add) any prereqs they see
    ### fit. The default installed callback will return the hashref in
    ### an unmodified form
    ### this callback got added after cpanplus 0.0562, so use a 'can'
    ### to find out if it's supported. For older versions, we'll just
    ### return the hashref as is ourselves.
    my $href    = $cb->_callbacks->can('filter_prereqs')
                    ? $cb->_callbacks->filter_prereqs->( $cb, $prereqs )
                    : $prereqs;

    $self->status->prereqs( $href );

    ### make sure it's not the same ref
    return { %$href };
}

=pod

=head2 $dist->create([perl => '/path/to/perl', buildflags => 'EXTRA=FLAGS', prereq_target => TARGET, force => BOOL, verbose => BOOL, skiptest => BOOL])

C<create> preps a distribution for installation. This means it will
run C<Build> and C<Build test>.
This will also satisfy any prerequisites the module may have.

If you set C<skiptest> to true, it will skip the C<Build test> stage.
If you set C<force> to true, it will go over all the stages of the
C<Build> process again, ignoring any previously cached results. It
will also ignore a bad return value from C<Build test> and still allow
the operation to return true.

Returns true on success and false on failure.

You may then call C<< $dist->install >> on the object to actually
install it.

=cut

sub create {
    ### just in case you already did a create call for this module object
    ### just via a different dist object
    my $dist = shift;
    my $self = $dist->parent;

    ### we're also the cpan_dist, since we don't need to have anything
    ### prepared from another installer
    $dist    = $self->status->dist_cpan if      $self->status->dist_cpan;
    $self->status->dist_cpan( $dist )   unless  $self->status->dist_cpan;

    my $cb   = $self->parent;
    my $conf = $cb->configure_object;
    my %hash = @@_;

    my $dir;
    unless( $dir = $self->status->extract ) {
        error( loc( "No dir found to operate on!" ) );
        return;
    }

    my $args;
    my( $force, $verbose, $buildflags, $skiptest, $prereq_target,
        $perl, $prereq_format, $prereq_build);
    {   local $Params::Check::ALLOW_UNKNOWN = 1;
        my $tmpl = {
            force           => {    default => $conf->get_conf('force'),
                                    store   => \$force },
            verbose         => {    default => $conf->get_conf('verbose'),
                                    store   => \$verbose },
            perl            => {    default => $^X, store => \$perl },
            buildflags      => {    default => $conf->get_conf('buildflags'),
                                    store   => \$buildflags },
            skiptest        => {    default => $conf->get_conf('skiptest'),
                                    store   => \$skiptest },
            prereq_target   => {    default => '', store => \$prereq_target },
            ### don't set the default format to 'build' -- that is wrong!
            prereq_format   => {    #default => $self->status->installer_type,
                                    default => '',
                                    store   => \$prereq_format },
            prereq_build    => {    default => 0, store => \$prereq_build },                                    
        };

        $args = check( $tmpl, \%hash ) or return;
    }

    # restore the state as we have created this already.
    if ( $dist->status->created && !$force ) {
        ### add this directory to your lib ###
        $self->add_to_includepath();
        return 1;
    }

    $dist->status->_create_args( $args );

    ### is this dist prepared?
    unless( $dist->status->prepared ) {
        error( loc( "You have not successfully prepared a '%2' distribution ".
                    "yet -- cannot create yet", __PACKAGE__ ) );
        return;
    }

    ### chdir to work directory ###
    my $orig = cwd();
    unless( $cb->_chdir( dir => $dir ) ) {
        error( loc( "Could not chdir to build directory '%1'", $dir ) );
        return;
    }

    ### by now we've loaded module::build, and we're using the API, so
    ### it's safe to remove CPANPLUS::inc from our inc path, especially
    ### because it can trip up tests run under taint (just like EU::MM).
    ### turn off our PERL5OPT so no modules from CPANPLUS::inc get
    ### included in make test -- it should build without.
    ### also, modules that run in taint mode break if we leave
    ### our code ref in perl5opt
    ### XXX we've removed the ENV settings from cp::inc, so only need
    ### to reset the @@INC
    #local $ENV{PERL5OPT} = CPANPLUS::inc->original_perl5opt;
    #local $ENV{PERL5LIB} = CPANPLUS::inc->original_perl5lib;
    #local @@INC           = CPANPLUS::inc->original_inc;

    ### but do it *before* the new_from_context, as M::B seems
    ### to be actually running the file...
    ### an unshift in the block seems to be ignored.. somehow...
    #{   my $lib = $self->best_path_to_module_build;
    #    unshift @@INC, $lib if $lib;
    #}
    unshift @@INC, $self->best_path_to_module_build
                if $self->best_path_to_module_build;

    ### this will generate warnings under anything lower than M::B 0.2606
    my @@buildflags = $dist->_buildflags_as_list( $buildflags );
    $dist->status->_buildflags( $buildflags );

    my $fail; my $prereq_fail; my $test_fail;
    RUN: {

        my $run_perl    = $conf->get_program('perlwrapper');

        ### this will set the directory back to the start
        ### dir, so we must chdir /again/
        my $ok = $dist->_resolve_prereqs(
                        force           => $force,
                        format          => $prereq_format,
                        verbose         => $verbose,
                        prereqs         => $self->status->prereqs,
                        target          => $prereq_target,
                        prereq_build    => $prereq_build,
                    );

        unless( $cb->_chdir( dir => $dir ) ) {
            error( loc( "Could not chdir to build directory '%1'", $dir ) );
            return;
        }

        unless( $ok ) {
            #### use $dist->flush to reset the cache ###
            error( loc( "Unable to satisfy prerequisites for '%1' " .
                        "-- aborting install", $self->module ) );
            $dist->status->build(0);
            $fail++; $prereq_fail++;
            last RUN;
        }

        my ($captured, $cmd);
        if ( ON_VMS ) {
            $cmd = [$perl, BUILD->($dir), @@buildflags];
        }
        else {
            $cmd = [$perl, $run_perl, BUILD->($dir), @@buildflags];
        }

        unless ( scalar run(    command => $cmd,
                                buffer  => \$captured,
                                verbose => $verbose ) 
        ) {
            error( loc( "MAKE failed:\n%1", $captured ) );
            $dist->status->build(0);
            $fail++; last RUN;
        }

        msg( $captured, 0 );

        $dist->status->build(1);

        ### add this directory to your lib ###
        $self->add_to_includepath();

        ### this buffer will not include what tests failed due to a 
        ### M::B/Test::Harness bug. Reported as #9793 with patch 
        ### against 0.2607 on 26/1/2005
        unless( $skiptest ) {
            my $test_output;
            if ( ON_VMS ) {
                $cmd     = [$perl, BUILD->($dir), "test", @@buildflags];
            }
            else {
                $cmd     = [$perl, $run_perl, BUILD->($dir), "test", @@buildflags];
            }
            unless ( scalar run(    command => $cmd,
                                    buffer  => \$test_output,
                                    verbose => $verbose ) 
            ) {
                error( loc( "MAKE TEST failed:\n%1 ", $test_output ) );

                ### mark specifically *test* failure.. so we dont
                ### send success on force...
                $test_fail++;

                if( !$force and !$cb->_callbacks->proceed_on_test_failure->(
                                      $self, $@@ )
                ) {
                    $dist->status->test(0);
                    $fail++; last RUN;
                }

            } 
            else {
                msg( $test_output, 0 );
                $dist->status->test(1);
            }
        } 
        else {
            msg(loc("Tests skipped"), $verbose);
        }
    }

    unless( $cb->_chdir( dir => $orig ) ) {
        error( loc( "Could not chdir back to start dir '%1'", $orig ) );
    }

    ### send out test report? ###
    if( $conf->get_conf('cpantest') and not $prereq_fail ) {
        $cb->_send_report(
            module          => $self,
            failed          => $test_fail || $fail,
            buffer          => CPANPLUS::Error->stack_as_string,
            verbose         => $verbose,
            force           => $force,
            tests_skipped   => $skiptest,
        ) or error(loc("Failed to send test report for '%1'",
                    $self->module ) );
    }

    return $dist->status->created( $fail ? 0 : 1 );
}

=head2 $dist->install([verbose => BOOL, perl => /path/to/perl])

Actually installs the created dist.

Returns true on success and false on failure.

=cut

sub install {
    ### just in case you already did a create call for this module object
    ### just via a different dist object
    my $dist = shift;
    my $self = $dist->parent;

    ### we're also the cpan_dist, since we don't need to have anything
    ### prepared from another installer
    $dist    = $self->status->dist_cpan if $self->status->dist_cpan;

    my $cb   = $self->parent;
    my $conf = $cb->configure_object;
    my %hash = @@_;

    
    my $verbose; my $perl; my $force; my $buildflags;
    {   local $Params::Check::ALLOW_UNKNOWN = 1;
        my $tmpl = {
            verbose => { default => $conf->get_conf('verbose'),
                         store   => \$verbose },
            force   => { default => $conf->get_conf('force'),
                         store   => \$force },
            buildflags => { default => $conf->get_conf('buildflags'),
                            store   => \$buildflags },
            perl    => { default => $^X, store   => \$perl },
        };
    
        my $args = check( $tmpl, \%hash ) or return;
        $dist->status->_install_args( $args );
    }

    my $dir;
    unless( $dir = $self->status->extract ) {
        error( loc( "No dir found to operate on!" ) );
        return;
    }

    my $orig = cwd();

    unless( $cb->_chdir( dir => $dir ) ) {
        error( loc( "Could not chdir to build directory '%1'", $dir ) );
        return;
    }

    ### value set and false -- means failure ###
    if( defined $self->status->installed && 
        !$self->status->installed && !$force
    ) {
        error( loc( "Module '%1' has failed to install before this session " .
                    "-- aborting install", $self->module ) );
        return;
    }

    my $fail;
    my @@buildflags = $dist->_buildflags_as_list( $buildflags );
    my $run_perl    = $conf->get_program('perlwrapper');

    ### hmm, how is this going to deal with sudo?
    ### for now, check effective uid, if it's not root,
    ### shell out, otherwise use the method
    if( $> ) {

        ### don't worry about loading the right version of M::B anymore
        ### the 'new_from_context' already added the 'right' path to
        ### M::B at the top of the build.pl
        my $cmd;
        if ( ON_VMS ) {
            $cmd     = [$perl, BUILD->($dir), "install", @@buildflags];
        }
        else {
            $cmd     = [$perl, $run_perl, BUILD->($dir), "install", @@buildflags];
        }
        my $sudo    = $conf->get_program('sudo');
        unshift @@$cmd, $sudo if $sudo;


        my $buffer;
        unless( scalar run( command => $cmd,
                            buffer  => \$buffer,
                            verbose => $verbose )
        ) {
            error(loc("Could not run '%1': %2", 'Build install', $buffer));
            $fail++;
        }
    } else {
        my ($install_output, $cmd);
        if ( ON_VMS ) {
            $cmd     = [$perl, BUILD->($dir), "install", @@buildflags];
        }
        else {
            $cmd     = [$perl, $run_perl, BUILD->($dir), "install", @@buildflags];
        }
        unless( scalar run( command => $cmd,
                            buffer  => \$install_output,
                            verbose => $verbose )
        ) {
            error(loc("Could not run '%1': %2", 'Build install', $install_output));
            $fail++;
        }
        else {
            msg( $install_output, 0 );
        }
    }


    unless( $cb->_chdir( dir => $orig ) ) {
        error( loc( "Could not chdir back to start dir '%1'", $orig ) );
    }

    return $dist->status->installed( $fail ? 0 : 1 );
}

### returns the string 'foo=bar --zot quux'
###        as the list 'foo=bar', '--zot', 'qux'
sub _buildflags_as_list {
    my $self    = shift;
    my $flags   = shift or return;

    return Module::Build->split_like_shell($flags);
}

=head1 AUTHOR

Originally by Jos Boumans E<lt>kane@@cpan.orgE<gt>.  Brought to working
condition by Ken Williams E<lt>kwilliams@@cpan.orgE<gt>.

Other hackery and currently maintained by Chris C<BinGOs> Williams ( no relation ). E<lt>bingos@@cpan.orgE<gt>.

=head1 LICENSE

The CPAN++ interface (of which this module is a part of) is
copyright (c) 2001, 2002, 2003, 2004, 2005 Jos Boumans E<lt>kane@@cpan.orgE<gt>.
All rights reserved.

This library is free software;
you may redistribute and/or modify it under the same
terms as Perl itself.

=cut

qq[Putting the Module::Build into CPANPLUS];


# Local variables:
# c-indentation-style: bsd
# c-basic-offset: 4
# indent-tabs-mode: nil
# End:
# vim: expandtab shiftwidth=4:

@


1.3
log
@Merge in perl 5.10.1
@
text
@@


1.2
log
@Remove bogus man pages and fix the NAME lines for many more.
@
text
@d4 1
a7 1
use CPANPLUS::inc;
d24 1
d33 1
a33 1
$VERSION = '0.06_02';
d39 1
a39 1
CPANPLUS::Dist::Build - distribution class for Module::Build
d48 1
a48 1
    $build->prepare;    # runs Module::Build->new_from_context;                            
d68 1
a68 1
=item parent()
d72 1
a72 1
=item status()
d86 1
a86 1
=item build_pl ()
d91 1
a91 1
=item build ()
d95 1
a95 1
=item test ()
d99 1
a99 1
=item prepared ()
d104 1
a104 1
=item distdir ()
d109 1
a109 1
=item created ()
d114 1
a114 1
=item installed ()
d123 1
a123 1
=item _create_args ()
d128 1
a128 1
=item _install_args ()
a132 4
=item _mb_object ()

Storage of the C<Module::Build> object we used for this installation.

a136 1

d187 2
a188 2
C<prepare> prepares a distribution, running C<Module::Build>'s 
C<new_from_context> method, and establishing any prerequisites this
d191 1
a191 2
When running C<< Module::Build->new_from_context >>, the environment 
variable C<PERL5_CPANPLUS_IS_EXECUTING> will be set to the full path 
d224 2
a225 1
    my( $force, $verbose, $buildflags, $perl);
d235 4
d266 1
a266 1
    local @@INC           = CPANPLUS::inc->original_inc;
d269 1
a269 1
    my %buildflags = $dist->_buildflags_as_hash( $buildflags );
d274 33
d309 12
a320 7
        my $mb = eval { 
            my $env = 'ENV_CPANPLUS_IS_EXECUTING';
            local $ENV{$env} = BUILD_PL->( $dir );
            Module::Build->new_from_context( %buildflags ) 
        };
        if( !$mb or $@@ ) {
            error(loc("Could not create Module::Build object: %1","$@@"));
d324 3
a326 1
        $dist->status->_mb_object( $mb );
d328 4
a331 1
        $self->status->prereqs( $dist->_find_prereqs( verbose => $verbose ) );
a359 1
    my $mb   = $dist->status->_mb_object;
d362 13
d377 37
d415 2
a416 2
      my $p = $mb->$type() || {};
      $prereqs->{$_} = $p->{$_} foreach keys %$p;
d419 3
a438 28
sub prereq_satisfied {
  # Return true if this prereq is satisfied.  Return false if it's
  # not.  Also issue an error if the latest CPAN version doesn't
  # satisfy it.
  
  my ($dist, %args) = @@_;
  my $mb   = $dist->status->_mb_object;
  my $cb   = $dist->parent->parent;
  my $mod = $args{modobj}->module;
  
  my $status = $mb->check_installed_status($mod, $args{version});
  return 1 if $status->{ok};
  
  # Check the latest version from the CPAN index
  {
    no strict 'refs';
    local ${$mod . '::VERSION'} = $args{modobj}->version;
    $status = $mb->check_installed_status($mod, $args{version});
  }
  unless( $status->{ok} ) {
    error(loc("This distribution depends on $mod, but the latest version of $mod on CPAN ".
	      "doesn't satisfy the specific version dependency ($args{version}). ".
	      "Please try to resolve this dependency manually."));
  }
  
  return 0;
}

d444 1
a444 1
run C<Build> and C<Build test>, via the C<Module::Build> API.
a472 1
    my $mb   = $dist->status->_mb_object;
d506 6
a511 1
    return 1 if $dist->status->created && !$force;
d540 1
a540 1
    local @@INC           = CPANPLUS::inc->original_inc;
d552 1
a552 1
    my %buildflags = $dist->_buildflags_as_hash( $buildflags );
d558 2
d585 13
a597 3
        eval { $mb->dispatch('build', %buildflags) };
        if( $@@ ) {
            error(loc("Could not run '%1': %2", 'Build', "$@@"));
d602 2
d607 1
a607 3
        $cb->_add_to_includepath(
            directories => [ BLIB_LIBDIR->( $self->status->extract ) ]
        );
d613 12
a624 3
            eval { $mb->dispatch('test', %buildflags) };
            if( $@@ ) {
                error(loc("Could not run '%1': %2", 'Build test', "$@@"));
d631 1
a631 1
                                      $self, $@@ ) 
d633 2
a634 2
                    $dist->status->test(0);                 
                    $fail++; last RUN;     
d636 4
a639 2
                
            } else {
d642 2
a643 1
        } else {
d645 1
a645 1
        }            
a684 1
    my $mb   = $dist->status->_mb_object;
d691 1
a691 1
    my $verbose; my $perl; my $force;
d698 2
d730 3
a732 1
    my $buildflags = $dist->status->_buildflags;
d741 7
a747 3
        ### On VMS, flags need to be quoted
        my $flag    = ON_VMS ? '"install"' : 'install';
        my $cmd     = [$perl, BUILD->($dir), $flag, $buildflags];
d761 12
a772 5
        my %buildflags = $dist->_buildflags_as_hash($buildflags);

        eval { $mb->dispatch('install', %buildflags) };
        if( $@@ ) {
            error(loc("Could not run '%1': %2", 'Build install', "$@@"));
d775 3
d788 3
a790 2
### returns the string 'foo=bar zot=quux' as (foo => bar, zot => quux)
sub _buildflags_as_hash {
d794 1
a794 4
    my @@argv    = Module::Build->split_like_shell($flags);
    my ($argv)  = Module::Build->read_args(@@argv);

    return %$argv;
a796 85

sub dist_dir {
    ### just in case you already did a create call for this module object
    ### just via a different dist object
    my $dist = shift;
    my $self = $dist->parent;

    ### we're also the cpan_dist, since we don't need to have anything
    ### prepared from another installer
    $dist    = $self->status->dist_cpan if $self->status->dist_cpan;
    my $mb   = $dist->status->_mb_object;

    my $cb   = $self->parent;
    my $conf = $cb->configure_object;
    my %hash = @@_;

    
    my $dir;
    unless( $dir = $self->status->extract ) {
        error( loc( "No dir found to operate on!" ) );
        return;
    }
    
    ### chdir to work directory ###
    my $orig = cwd();
    unless( $cb->_chdir( dir => $dir ) ) {
        error( loc( "Could not chdir to build directory '%1'", $dir ) );
        return;
    }

    my $fail; my $distdir;
    TRY: {    
        $dist->prepare( @@_ ) or (++$fail, last TRY);


        eval { $mb->dispatch('distdir') };
        if( $@@ ) {
            error(loc("Could not run '%1': %2", 'Build distdir', "$@@"));
            ++$fail, last TRY;
        }

        ### /path/to/Foo-Bar-1.2/Foo-Bar-1.2
        $distdir = File::Spec->catdir( $dir, $self->package_name . '-' .
                                                $self->package_version );

        unless( -d $distdir ) {
            error(loc("Do not know where '%1' got created", 'distdir'));
            ++$fail, last TRY;
        }
    }

    unless( $cb->_chdir( dir => $orig ) ) {
        error( loc( "Could not chdir to start directory '%1'", $orig ) );
        return;
    }

    return if $fail;
    return $distdir;
}    

=head1 KNOWN ISSUES

Below are some of the known issues with Module::Build, that we hope 
the authors will resolve at some point, so we can make full use of
Module::Build's power. 
The number listed is the bug number on C<rt.cpan.org>.

=over 4

=item * Module::Build can not be upgraded using its own API (#13169)

This is due to the fact that the Build file insists on adding a path
to C<@@INC> which force the loading of the C<not yet installed>
Module::Build when it shells out to run it's own build procedure:

=item * Module::Build does not provide access to install history (#9793)

C<Module::Build> runs the create, test and install procedures in it's
own processes, but does not provide access to any diagnostic messages of
those processes. As an end result, we can not offer these diagnostic 
messages when, for example, reporting automated build failures to sites
like C<testers.cpan.org>.

=back

d800 1
a800 1
condition and currently maintained by Ken Williams E<lt>kwilliams@@cpan.orgE<gt>.
d802 3
a804 1
=head1 COPYRIGHT
d816 2
a817 1
1;
d825 1
@


1.1
log
@Initial revision
@
text
@d38 1
a38 1
CPANPLUS::Dist::Build
@


1.1.1.1
log
@import perl 5.10.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.1
@
text
@a3 1
use warnings;
d7 1
a23 1
use version;
d32 1
a32 1
$VERSION = '0.36';
d38 1
a38 1
CPANPLUS::Dist::Build - CPANPLUS plugin to install packages that use Build.PL
d47 1
a47 1
    $build->prepare;    # runs Build.PL                            
d67 1
a67 1
=item C<parent()>
d71 1
a71 1
=item C<status()>
d85 1
a85 1
=item C<build_pl ()>
d90 1
a90 1
=item C<build ()>
d94 1
a94 1
=item C<test ()>
d98 1
a98 1
=item C<prepared ()>
d103 1
a103 1
=item C<distdir ()>
d108 1
a108 1
=item C<created ()>
d113 1
a113 1
=item C<installed ()>
d122 1
a122 1
=item C<_create_args ()>
d127 1
a127 1
=item C<_install_args ()>
d132 4
d140 1
d191 2
a192 2
C<prepare> prepares a distribution, running C<Build.PL> 
and establishing any prerequisites this
d195 2
a196 1
The variable C<PERL5_CPANPLUS_IS_EXECUTING> will be set to the full path 
d229 1
a229 2
    my( $force, $verbose, $buildflags, $perl, $prereq_target, $prereq_format,
        $prereq_build );
a238 4
            prereq_target   => {    default => '', store => \$prereq_target }, 
            prereq_format   => {    default => '',
                                    store   => \$prereq_format },   
            prereq_build    => {    default => 0, store => \$prereq_build },
d266 1
a266 1
    #local @@INC           = CPANPLUS::inc->original_inc;
d269 1
a269 1
    my @@buildflags = $dist->_buildflags_as_list( $buildflags );
a273 33
        # 0.85_01
        ### we resolve 'configure requires' here, so we can run the 'perl
        ### Makefile.PL' command
        ### XXX for tests: mock f_c_r to something that *can* resolve and
        ### something that *doesnt* resolve. Check the error log for ok
        ### on this step or failure
        ### XXX make a seperate tarball to test for this scenario: simply
        ### containing a makefile.pl/build.pl for test purposes?
        my $safe_ver = version->new('0.85_01');
        if ( version->new($CPANPLUS::Internals::VERSION) >= $safe_ver )
        {   my $configure_requires = $dist->find_configure_requires;     
            my $ok = $dist->_resolve_prereqs(
                            format          => $prereq_format,
                            verbose         => $verbose,
                            prereqs         => $configure_requires,
                            target          => $prereq_target,
                            force           => $force,
                            prereq_build    => $prereq_build,
                    );    
    
            unless( $ok ) {
           
                #### use $dist->flush to reset the cache ###
                error( loc( "Unable to satisfy '%1' for '%2' " .
                            "-- aborting install", 
                            'configure_requires', $self->module ) );    
                $dist->status->prepared(0);
                $fail++; 
                last RUN;
            } 
            ### end of prereq resolving ###
        }

d276 7
a282 12
        my $prep_output;

        my $env = ENV_CPANPLUS_IS_EXECUTING;
        local $ENV{$env} = BUILD_PL->( $dir );
        my $run_perl    = $conf->get_program('perlwrapper');
        my $cmd = [$perl, $run_perl, BUILD_PL->($dir), @@buildflags];

        unless ( scalar run(    command => $cmd,
                                buffer  => \$prep_output,
                                verbose => $verbose ) 
        ) {
            error( loc( "Build.PL failed: %1", $prep_output ) );
d286 1
a286 3
        msg( $prep_output, 0 );

        my $prereqs = $self->status->prereqs;
d288 1
a288 4
        $prereqs ||= $dist->_find_prereqs( verbose => $verbose, 
                                           dir => $dir, 
                                           perl => $perl,
                                           buildflags => $buildflags );
d317 1
a319 13
    my $conf = $cb->configure_object;
    my %hash = @@_;

    my ($verbose, $dir, $buildflags, $perl);
    my $tmpl = {
        verbose => { default => $conf->get_conf('verbose'), store => \$verbose },
        dir     => { default => $self->status->extract, store => \$dir },
        perl    => { default => $^X, store => \$perl },
        buildflags => { default => $conf->get_conf('buildflags'),
                        store   => \$buildflags },
    };
    
    my $args = check( $tmpl, \%hash ) or return;
a321 37

    my $safe_ver = version->new('0.31_03');

    my $content;

    if ( version->new( $Module::Build::VERSION ) >= $safe_ver and IPC::Cmd->can_capture_buffer ) {
        my @@buildflags = $dist->_buildflags_as_list( $buildflags );

        # Use the new Build action 'prereq_data'
        my $run_perl    = $conf->get_program('perlwrapper');

        unless ( scalar run(    command => [$perl, $run_perl, BUILD->($dir), 'prereq_data', @@buildflags],
                                buffer  => \$content,
                                verbose => 0 ) 
        ) {
            error( loc( "Build 'prereq_data' failed: %1 %2", $!, $content ) );
            return;
        }

    }
    else {
        my $file = File::Spec->catfile( $dir, '_build', 'prereqs' );
        return unless -f $file;

        my $fh = FileHandle->new();

        unless( $fh->open( $file ) ) {
           error( loc( "Cannot open '%1': %2", $file, $! ) );
           return;
        }
        
        $content = do { local $/; <$fh> };
    }

    return unless $content;
    my $bphash = eval $content;
    return unless $bphash and ref $bphash eq 'HASH';
d323 2
a324 2
       next unless $bphash->{$type} and ref $bphash->{$type} eq 'HASH';
       $prereqs->{$_} = $bphash->{$type}->{$_} for keys %{ $bphash->{$type} };
a326 3
    # Temporary fix
    delete $prereqs->{'perl'};

d344 28
d377 1
a377 1
run C<Build> and C<Build test>.
d406 1
d440 1
a440 6
    # restore the state as we have created this already.
    if ( $dist->status->created && !$force ) {
        ### add this directory to your lib ###
        $self->add_to_includepath();
        return 1;
    }
d469 1
a469 1
    #local @@INC           = CPANPLUS::inc->original_inc;
d481 1
a481 1
    my @@buildflags = $dist->_buildflags_as_list( $buildflags );
a486 2
        my $run_perl    = $conf->get_program('perlwrapper');

d512 3
a514 13
        my ($captured, $cmd);
        if ( ON_VMS ) {
            $cmd = [$perl, BUILD->($dir), @@buildflags];
        }
        else {
            $cmd = [$perl, $run_perl, BUILD->($dir), @@buildflags];
        }

        unless ( scalar run(    command => $cmd,
                                buffer  => \$captured,
                                verbose => $verbose ) 
        ) {
            error( loc( "MAKE failed:\n%1", $captured ) );
a518 2
        msg( $captured, 0 );

d522 3
a524 1
        $self->add_to_includepath();
d530 3
a532 12
            my $test_output;
            if ( ON_VMS ) {
                $cmd     = [$perl, BUILD->($dir), "test", @@buildflags];
            }
            else {
                $cmd     = [$perl, $run_perl, BUILD->($dir), "test", @@buildflags];
            }
            unless ( scalar run(    command => $cmd,
                                    buffer  => \$test_output,
                                    verbose => $verbose ) 
            ) {
                error( loc( "MAKE TEST failed:\n%1 ", $test_output ) );
d539 1
a539 1
                                      $self, $@@ )
d541 2
a542 2
                    $dist->status->test(0);
                    $fail++; last RUN;
d544 2
a545 4

            } 
            else {
                msg( $test_output, 0 );
d548 1
a548 2
        } 
        else {
d550 1
a550 1
        }
d590 1
d597 1
a597 1
    my $verbose; my $perl; my $force; my $buildflags;
a603 2
            buildflags => { default => $conf->get_conf('buildflags'),
                            store   => \$buildflags },
d634 1
a634 3
    my @@buildflags = $dist->_buildflags_as_list( $buildflags );
    my $run_perl    = $conf->get_program('perlwrapper');

d643 3
a645 7
        my $cmd;
        if ( ON_VMS ) {
            $cmd     = [$perl, BUILD->($dir), "install", @@buildflags];
        }
        else {
            $cmd     = [$perl, $run_perl, BUILD->($dir), "install", @@buildflags];
        }
d659 5
a663 12
        my ($install_output, $cmd);
        if ( ON_VMS ) {
            $cmd     = [$perl, BUILD->($dir), "install", @@buildflags];
        }
        else {
            $cmd     = [$perl, $run_perl, BUILD->($dir), "install", @@buildflags];
        }
        unless( scalar run( command => $cmd,
                            buffer  => \$install_output,
                            verbose => $verbose )
        ) {
            error(loc("Could not run '%1': %2", 'Build install', $install_output));
a665 3
        else {
            msg( $install_output, 0 );
        }
d676 2
a677 3
### returns the string 'foo=bar --zot quux'
###        as the list 'foo=bar', '--zot', 'qux'
sub _buildflags_as_list {
d681 4
a684 1
    return Module::Build->split_like_shell($flags);
d687 85
d775 1
a775 1
condition by Ken Williams E<lt>kwilliams@@cpan.orgE<gt>.
d777 1
a777 3
Other hackery and currently maintained by Chris C<BinGOs> Williams ( no relation ). E<lt>bingos@@cpan.orgE<gt>.

=head1 LICENSE
d789 1
a789 2
qq[Putting the Module::Build into CPANPLUS];

a796 1

@

