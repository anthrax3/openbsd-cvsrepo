head	1.21;
access;
symbols
	OPENBSD_6_2_BASE:1.21
	PERL_5_24_2:1.1.1.15
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.17.0.8
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.12.0.16
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.12
	OPENBSD_5_4_BASE:1.12
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.21
date	2017.08.14.13.49.43;	author afresh1;	state Exp;
branches;
next	1.20;
commitid	AOpGtCFzbfdujI88;

1.20
date	2017.08.14.13.48.45;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	CrMEpTqBUsxCMTjx;

1.19
date	2017.02.05.00.33.38;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	7JLVNm1wwPgqSqTa;

1.18
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	cxJ08BvJA9Pt2PTM;

1.17
date	2015.04.25.19.26.15;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	3qGYFVvfrExB70FB;

1.16
date	2015.04.25.19.14.37;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	XRK22kO4se3v2i2I;

1.15
date	2014.11.17.21.00.55;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	LnErp1MFKSuew5Fr;

1.14
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	QP75iYx42Uo7mMxO;

1.13
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.24.15.06.39;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.24.20;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.35.56;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.22.56;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.15.21.30.18;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.20;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.46;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.03.48;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.50.57;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.27;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.38;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.38;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.08;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.34;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.21.58;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.46;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.28;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.38;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.16.23;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.47.24;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.04;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.33;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.17;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.58.44;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.52.35;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	B31cAbBIXiCqnL97;

1.1.1.15
date	2017.08.14.13.45.25;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.21
log
@Apply local patches - perl-5.24.2

OK bluhm@@, Reads ok sthen@@
@
text
@/*    deb.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * 'Didst thou think that the eyes of the White Tower were blind?  Nay,
 *  I have seen more than thou knowest, Grey Fool.'        --Denethor
 *
 *     [p.853 of _The Lord of the Rings_, V/vii: "The Pyre of Denethor"]
 */

/*
 * This file contains various utilities for producing debugging output
 * (mainly related to displaying the stack)
 */

#include "EXTERN.h"
#define PERL_IN_DEB_C
#include "perl.h"

#if defined(PERL_IMPLICIT_CONTEXT)
void
Perl_deb_nocontext(const char *pat, ...)
{
#ifdef DEBUGGING
    dTHX;
    va_list args;
    PERL_ARGS_ASSERT_DEB_NOCONTEXT;
    va_start(args, pat);
    vdeb(pat, &args);
    va_end(args);
#else
    PERL_UNUSED_ARG(pat);
#endif /* DEBUGGING */
}
#endif

void
Perl_deb(pTHX_ const char *pat, ...)
{
    va_list args;
    PERL_ARGS_ASSERT_DEB;
    va_start(args, pat);
#ifdef DEBUGGING
    vdeb(pat, &args);
#else
    PERL_UNUSED_CONTEXT;
#endif /* DEBUGGING */
    va_end(args);
}

void
Perl_vdeb(pTHX_ const char *pat, va_list *args)
{
#ifdef DEBUGGING
    const char* const file = PL_curcop ? OutCopFILE(PL_curcop) : "<null>";
    const char* const display_file = file ? file : "<free>";
    const long line = PL_curcop ? (long)CopLINE(PL_curcop) : 0;

    PERL_ARGS_ASSERT_VDEB;

    if (DEBUG_v_TEST)
	PerlIO_printf(Perl_debug_log, "(%ld:%s:%ld)\t",
		      (long)PerlProc_getpid(), display_file, line);
    else
	PerlIO_printf(Perl_debug_log, "(%s:%ld)\t", display_file, line);
    (void) PerlIO_vprintf(Perl_debug_log, pat, *args);
#else
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(pat);
    PERL_UNUSED_ARG(args);
#endif /* DEBUGGING */
}

I32
Perl_debstackptrs(pTHX)
{
#ifdef DEBUGGING
    PerlIO_printf(Perl_debug_log,
		  "%8"UVxf" %8"UVxf" %8"IVdf" %8"IVdf" %8"IVdf"\n",
		  PTR2UV(PL_curstack), PTR2UV(PL_stack_base),
		  (IV)*PL_markstack_ptr, (IV)(PL_stack_sp-PL_stack_base),
		  (IV)(PL_stack_max-PL_stack_base));
    PerlIO_printf(Perl_debug_log,
		  "%8"UVxf" %8"UVxf" %8"UVuf" %8"UVuf" %8"UVuf"\n",
		  PTR2UV(PL_mainstack), PTR2UV(AvARRAY(PL_curstack)),
		  PTR2UV(PL_mainstack), PTR2UV(AvFILLp(PL_curstack)),
		  PTR2UV(AvMAX(PL_curstack)));
#else
    PERL_UNUSED_CONTEXT;
#endif /* DEBUGGING */
    return 0;
}


/* dump the contents of a particular stack
 * Display stack_base[stack_min+1 .. stack_max],
 * and display the marks whose offsets are contained in addresses
 * PL_markstack[mark_min+1 .. mark_max] and whose values are in the range
 * of the stack values being displayed
 *
 * Only displays top 30 max
 */

STATIC void
S_deb_stack_n(pTHX_ SV** stack_base, I32 stack_min, I32 stack_max,
	I32 mark_min, I32 mark_max)
{
#ifdef DEBUGGING
    I32 i = stack_max - 30;
    const I32 *markscan = PL_markstack + mark_min;

    PERL_ARGS_ASSERT_DEB_STACK_N;

    if (i < stack_min)
	i = stack_min;
    
    while (++markscan <= PL_markstack + mark_max)
	if (*markscan >= i)
	    break;

    if (i > stack_min)
	PerlIO_printf(Perl_debug_log, "... ");

    if (stack_base[0] != &PL_sv_undef || stack_max < 0)
	PerlIO_printf(Perl_debug_log, " [STACK UNDERFLOW!!!]\n");
    do {
	++i;
	if (markscan <= PL_markstack + mark_max && *markscan < i) {
	    do {
		++markscan;
		(void)PerlIO_putc(Perl_debug_log, '*');
	    }
	    while (markscan <= PL_markstack + mark_max && *markscan < i);
	    PerlIO_printf(Perl_debug_log, "  ");
	}
	if (i > stack_max)
	    break;
	PerlIO_printf(Perl_debug_log, "%-4s  ", SvPEEK(stack_base[i]));
    }
    while (1);
    PerlIO_printf(Perl_debug_log, "\n");
#else
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(stack_base);
    PERL_UNUSED_ARG(stack_min);
    PERL_UNUSED_ARG(stack_max);
    PERL_UNUSED_ARG(mark_min);
    PERL_UNUSED_ARG(mark_max);
#endif /* DEBUGGING */
}


/* dump the current stack */

I32
Perl_debstack(pTHX)
{
#ifndef SKIP_DEBUGGING
    if (CopSTASH_eq(PL_curcop, PL_debstash) && !DEBUG_J_TEST_)
	return 0;

    PerlIO_printf(Perl_debug_log, "    =>  ");
    deb_stack_n(PL_stack_base,
		0,
		PL_stack_sp - PL_stack_base,
		PL_curstackinfo->si_markoff,
		PL_markstack_ptr - PL_markstack);


#endif /* SKIP_DEBUGGING */
    return 0;
}


#ifdef DEBUGGING
static const char * const si_names[] = {
    "UNKNOWN",
    "UNDEF",
    "MAIN",
    "MAGIC",
    "SORT",
    "SIGNAL",
    "OVERLOAD",
    "DESTROY",
    "WARNHOOK",
    "DIEHOOK",
    "REQUIRE",
    "MULTICALL"
};
#endif

/* display all stacks */


void
Perl_deb_stack_all(pTHX)
{
#ifdef DEBUGGING
    I32 si_ix;
    const PERL_SI *si;

    /* rewind to start of chain */
    si = PL_curstackinfo;
    while (si->si_prev)
	si = si->si_prev;

    si_ix=0;
    for (;;)
    {
        const size_t si_name_ix = si->si_type+1; /* -1 is a valid index */
        const char * const si_name =
            si_name_ix < C_ARRAY_LENGTH(si_names) ?
            si_names[si_name_ix] : "????";
	I32 ix;
	PerlIO_printf(Perl_debug_log, "STACK %"IVdf": %s\n",
						(IV)si_ix, si_name);

	for (ix=0; ix<=si->si_cxix; ix++) {

	    const PERL_CONTEXT * const cx = &(si->si_cxstack[ix]);
	    PerlIO_printf(Perl_debug_log,
		    "  CX %"IVdf": %-6s => ",
		    (IV)ix, PL_block_type[CxTYPE(cx)]
	    );
	    /* substitution contexts don't save stack pointers etc) */
	    if (CxTYPE(cx) == CXt_SUBST)
		PerlIO_printf(Perl_debug_log, "\n");
	    else {

		/* Find the current context's stack range by searching
		 * forward for any higher contexts using this stack; failing
		 * that, it will be equal to the size of the stack for old
		 * stacks, or PL_stack_sp for the current stack
		 */

		I32 i, stack_min, stack_max, mark_min, mark_max;
		const PERL_CONTEXT *cx_n = NULL;
		const PERL_SI *si_n;

		/* there's a separate stack per SI, so only search
		 * this one */

		for (i=ix+1; i<=si->si_cxix; i++) {
		    if (CxTYPE(cx) == CXt_SUBST)
			continue;
		    cx_n = &(si->si_cxstack[i]);
		    break;
		}

		stack_min = cx->blk_oldsp;

		if (cx_n) {
		    stack_max = cx_n->blk_oldsp;
		}
		else if (si == PL_curstackinfo) {
		    stack_max = PL_stack_sp - AvARRAY(si->si_stack);
		}
		else {
		    stack_max = AvFILLp(si->si_stack);
		}

		/* for the other stack types, there's only one stack
		 * shared between all SIs */

		si_n = si;
		i = ix;
		cx_n = NULL;
		for (;;) {
		    i++;
		    if (i > si_n->si_cxix) {
			if (si_n == PL_curstackinfo)
			    break;
			else {
			    si_n = si_n->si_next;
			    i = 0;
			}
		    }
		    if (CxTYPE(&(si_n->si_cxstack[i])) == CXt_SUBST)
			continue;
		    cx_n = &(si_n->si_cxstack[i]);
		    break;
		}

		mark_min  = cx->blk_oldmarksp;
		if (cx_n) {
		    mark_max  = cx_n->blk_oldmarksp;
		}
		else {
		    mark_max = PL_markstack_ptr - PL_markstack;
		}

		deb_stack_n(AvARRAY(si->si_stack),
			stack_min, stack_max, mark_min, mark_max);

		if (CxTYPE(cx) == CXt_EVAL || CxTYPE(cx) == CXt_SUB
			|| CxTYPE(cx) == CXt_FORMAT)
		{
		    const OP * const retop = cx->blk_sub.retop;

		    PerlIO_printf(Perl_debug_log, "  retop=%s\n",
			    retop ? OP_NAME(retop) : "(null)"
		    );
		}
	    }
	} /* next context */


	if (si == PL_curstackinfo)
	    break;
	si = si->si_next;
	si_ix++;
	if (!si)
	    break; /* shouldn't happen, but just in case.. */
    } /* next stackinfo */

    PerlIO_printf(Perl_debug_log, "\n");
#else
    PERL_UNUSED_CONTEXT;
#endif /* DEBUGGING */
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.20
log
@Fix merge issues, remove excess files - match perl-5.24.2 dist

OK bluhm@@, Reads ok sthen@@
@
text
@d237 1
a237 1
		/* Find the the current context's stack range by searching
@


1.19
log
@Apply local patches - perl-5.24.1
@
text
@d237 1
a237 1
		/* Find the current context's stack range by searching
@


1.18
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@d237 1
a237 1
		/* Find the the current context's stack range by searching
@


1.17
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@a61 1
    dVAR;
a84 1
    dVAR;
d95 2
a115 1
    dVAR;
d138 1
a138 1
		PerlIO_putc(Perl_debug_log, '*');
a165 1
    dVAR;
d194 2
a195 1
    "REQUIRE"
a205 1
    dVAR;
d237 1
a237 1
		/* Find the current context's stack range by searching
a329 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.16
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d239 1
a239 1
		/* Find the the current context's stack range by searching
@


1.15
log
@Apply local patches to perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d239 1
a239 1
		/* Find the current context's stack range by searching
@


1.14
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d239 1
a239 1
		/* Find the the current context's stack range by searching
@


1.13
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d220 3
a222 1
        const char * const si_name = (si_name_ix >= sizeof(si_names)) ? "????" : si_names[si_name_ix];
d239 1
a239 1
		/* Find the current context's stack range by searching
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@d117 1
a117 1
    register I32 i = stack_max - 30;
d333 1
a333 1
 * indent-tabs-mode: t
d336 1
a336 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.11
log
@Merge in perl 5.10.1
@
text
@d305 1
a305 2
		    const OP * const retop = (CxTYPE(cx) == CXt_EVAL)
			    ? cx->blk_eval.retop : cx->blk_sub.retop;
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d12 4
a15 2
 * "Didst thou think that the eyes of the White Tower were blind?  Nay, I
 * have seen more than thou knowest, Gray Fool."  --Denethor
d34 1
d48 1
d67 2
d119 3
@


1.9
log
@merge in perl 5.8.8
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, by Larry Wall and others
d35 2
a43 1
#ifdef DEBUGGING
d46 1
d48 3
a51 1
#endif /* DEBUGGING */
d58 11
a68 7
    char* file = OutCopFILE(PL_curcop);

#ifdef USE_5005THREADS
    PerlIO_printf(Perl_debug_log, "0x%"UVxf" (%s:%ld)\t",
		  PTR2UV(thr),
		  (file ? file : "<free>"),
		  (long)CopLINE(PL_curcop));
d70 3
a72 4
    PerlIO_printf(Perl_debug_log, "(%s:%ld)\t", (file ? file : "<free>"),
		  (long)CopLINE(PL_curcop));
#endif /* USE_5005THREADS */
    (void) PerlIO_vprintf(Perl_debug_log, pat, *args);
d80 1
d110 1
d141 7
d158 1
d176 1
a176 1
static const char * si_names[] = {
d198 3
a200 2
    I32		 ix, si_ix;
    PERL_SI	 *si;
d210 3
a212 2
        const int si_name_ix = si->si_type+1; /* -1 is a valid index */
        const char *si_name = (si_name_ix>= sizeof(si_names)) ? "????" : si_names[si_name_ix];
d218 1
a218 1
	    const PERL_CONTEXT *cx = &(si->si_cxstack[ix]);
d235 2
a236 5
		I32 ret_min, ret_max;
		PERL_CONTEXT *cx_n;
		PERL_SI      *si_n;

		cx_n = Null(PERL_CONTEXT*);
d265 1
a265 1
		cx_n = Null(PERL_CONTEXT*);
a282 1
		ret_min   = cx->blk_oldretsp;
a284 1
		    ret_max   = cx_n->blk_oldretsp;
a287 1
		    ret_max  = PL_retstack_ix;
d293 6
a298 1
		if (ret_max > ret_min) {
d300 1
a300 3
			    PL_retstack[ret_min]
				? OP_NAME(PL_retstack[ret_min])
				: "(null)"
a302 1

d316 2
@


1.8
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, by Larry Wall and others
d103 1
a103 1
    I32 *markscan = PL_markstack + mark_min;
d159 1
a159 1
static char * si_names[] = {
a182 1
    PERL_CONTEXT *cx;
d192 2
a193 6
	char *si_name;
	int si_name_ix = si->si_type+1; /* -1 is a valid index */
	if (si_name_ix>= sizeof(si_names))
	    si_name = "????";
	else
	    si_name = si_names[si_name_ix];
d199 1
a199 1
	    cx = &(si->si_cxstack[ix]);
d304 9
a312 1

@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d16 5
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
a81 7
I32
Perl_debstack(pTHX)
{
#ifndef SKIP_DEBUGGING
    I32 top = PL_stack_sp - PL_stack_base;
    register I32 i = top - 30;
    I32 *markscan = PL_markstack + PL_curstackinfo->si_markoff;
d83 8
a90 2
    if (CopSTASH_eq(PL_curcop, PL_debstash) && !DEBUG_J_TEST_)
	return 0;
d92 9
a100 2
    if (i < 0)
	i = 0;
d102 1
a102 1
    while (++markscan <= PL_markstack_ptr)
d106 4
a109 8
#ifdef USE_5005THREADS
    PerlIO_printf(Perl_debug_log,
		  i ? "0x%"UVxf"    =>  ...  " : "0x%lx    =>  ",
		  PTR2UV(thr));
#else
    PerlIO_printf(Perl_debug_log, i ? "    =>  ...  " : "    =>  ");
#endif /* USE_5005THREADS */
    if (PL_stack_base[0] != &PL_sv_undef || PL_stack_sp < PL_stack_base)
d113 1
a113 1
	if (markscan <= PL_markstack_ptr && *markscan < i) {
d118 1
a118 1
	    while (markscan <= PL_markstack_ptr && *markscan < i);
d121 1
a121 1
	if (i > top)
d123 1
a123 1
	PerlIO_printf(Perl_debug_log, "%-4s  ", SvPEEK(PL_stack_base[i]));
d127 21
d151 154
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d48 1
a48 1
    char* file = CopFILE(PL_curcop);
d50 1
a50 1
#ifdef USE_THREADS
d58 1
a58 1
#endif /* USE_THREADS */
d84 1
a84 1
#ifdef DEBUGGING
d89 3
d99 1
a99 1
#ifdef USE_THREADS
d105 1
a105 1
#endif /* USE_THREADS */
d124 1
a124 1
#endif /* DEBUGGING */
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a47 1
    dTHR;
a66 1
    dTHR;
a84 1
    dTHR;
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d16 1
d19 1
d21 1
a21 1
deb(const char *pat, ...)
d24 1
a24 1
    dTHR;
d26 6
a31 15
    register I32 i;
    GV* gv = PL_curcop->cop_filegv;

#ifdef USE_THREADS
    PerlIO_printf(Perl_debug_log, "0x%lx (%s:%ld)\t",
		  (unsigned long) thr,
		  SvTYPE(gv) == SVt_PVGV ? SvPVX(GvSV(gv)) : "<free>",
		  (long)PL_curcop->cop_line);
#else
    PerlIO_printf(Perl_debug_log, "(%s:%ld)\t",
	SvTYPE(gv) == SVt_PVGV ? SvPVX(GvSV(gv)) : "<free>",
	(long)PL_curcop->cop_line);
#endif /* USE_THREADS */
    for (i=0; i<PL_dlevel; i++)
	PerlIO_printf(Perl_debug_log, "%c%c ",PL_debname[i],PL_debdelim[i]);
d33 5
d39 2
a40 2
    (void) PerlIO_vprintf(Perl_debug_log,pat,args);
    va_end( args );
d45 1
a45 1
deb_growlevel(void)
d48 13
a60 3
    PL_dlmax += 128;
    Renew(PL_debname, PL_dlmax, char);
    Renew(PL_debdelim, PL_dlmax, char);
d65 1
a65 1
debstackptrs(void)
d69 10
a78 7
    PerlIO_printf(Perl_debug_log, "%8lx %8lx %8ld %8ld %8ld\n",
	(unsigned long)PL_curstack, (unsigned long)PL_stack_base,
	(long)*PL_markstack_ptr, (long)(PL_stack_sp-PL_stack_base),
	(long)(PL_stack_max-PL_stack_base));
    PerlIO_printf(Perl_debug_log, "%8lx %8lx %8ld %8ld %8ld\n",
	(unsigned long)PL_mainstack, (unsigned long)AvARRAY(PL_curstack),
	(long)PL_mainstack, (long)AvFILLp(PL_curstack), (long)AvMAX(PL_curstack));
d84 1
a84 1
debstack(void)
d90 1
a90 1
    I32 *markscan = PL_curstackinfo->si_markbase;
d100 3
a102 2
    PerlIO_printf(Perl_debug_log, i ? "0x%lx    =>  ...  " : "0x%lx    =>  ",
		  (unsigned long) thr);
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
a17 26
#ifdef DEBUGGING
#if !defined(I_STDARG) && !defined(I_VARARGS)

/*
 * Fallback on the old hackers way of doing varargs
 */

/*VARARGS1*/
void
deb(pat,a1,a2,a3,a4,a5,a6,a7,a8)
    char *pat;
{
    register I32 i;
    GV* gv = curcop->cop_filegv;

    PerlIO_printf(Perl_debug_log, "(%s:%ld)\t",
	SvTYPE(gv) == SVt_PVGV ? SvPVX(GvSV(gv)) : "<free>",
	(long)curcop->cop_line);
    for (i=0; i<dlevel; i++)
	PerlIO_printf(Perl_debug_log, "%c%c ",debname[i],debdelim[i]);
    PerlIO_printf(Perl_debug_log, pat,a1,a2,a3,a4,a5,a6,a7,a8);
}

#else /* !defined(I_STDARG) && !defined(I_VARARGS) */

#  ifdef I_STDARG
a19 7
#  else
/*VARARGS1*/
void
deb(pat, va_alist)
    const char *pat;
    va_dcl
#  endif
d21 2
d25 1
a25 1
    GV* gv = curcop->cop_filegv;
d27 6
d35 4
a38 3
	(long)curcop->cop_line);
    for (i=0; i<dlevel; i++)
	PerlIO_printf(Perl_debug_log, "%c%c ",debname[i],debdelim[i]);
a39 1
#  ifdef I_STDARG
a40 3
#  else
    va_start(args);
#  endif
d43 1
a44 1
#endif /* !defined(I_STDARG) && !defined(I_VARARGS) */
d47 1
a47 1
deb_growlevel()
d49 5
a53 3
    dlmax += 128;
    Renew(debname, dlmax, char);
    Renew(debdelim, dlmax, char);
d57 1
a57 1
debstackptrs()
d59 2
d62 3
a64 3
	(unsigned long)curstack, (unsigned long)stack_base,
	(long)*markstack_ptr, (long)(stack_sp-stack_base),
	(long)(stack_max-stack_base));
d66 3
a68 2
	(unsigned long)mainstack, (unsigned long)AvARRAY(curstack),
	(long)mainstack, (long)AvFILL(curstack), (long)AvMAX(curstack));
d73 1
a73 1
debstack()
d75 3
a77 1
    I32 top = stack_sp - stack_base;
d79 1
a79 1
    I32 *markscan = markstack;
d84 1
a84 1
    while (++markscan <= markstack_ptr)
d88 4
d93 2
a94 1
    if (stack_base[0] != &sv_undef || stack_sp < stack_base)
d98 1
a98 1
	if (markscan <= markstack_ptr && *markscan < i) {
d103 1
a103 1
	    while (markscan <= markstack_ptr && *markscan < i);
d108 1
a108 1
	PerlIO_printf(Perl_debug_log, "%-4s  ", SvPEEK(stack_base[i]));
d112 1
a114 3
#else
static int dummy; /* avoid totally empty deb.o file */
#endif /* DEBUGGING */
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d33 1
a33 1
    fprintf(stderr,"(%s:%ld)\t",
d37 2
a38 2
	fprintf(stderr,"%c%c ",debname[i],debdelim[i]);
    fprintf(stderr,pat,a1,a2,a3,a4,a5,a6,a7,a8);
d45 1
a45 1
deb(char *pat, ...)
d50 1
a50 1
    char *pat;
d58 1
a58 1
    fprintf(stderr,"(%s:%ld)\t",
d62 1
a62 1
	fprintf(stderr,"%c%c ",debname[i],debdelim[i]);
d69 1
a69 1
    (void) vfprintf(stderr,pat,args);
d85 2
a86 2
    fprintf(stderr, "%8lx %8lx %8ld %8ld %8ld\n",
	(unsigned long)stack, (unsigned long)stack_base,
d89 3
a91 3
    fprintf(stderr, "%8lx %8lx %8ld %8ld %8ld\n",
	(unsigned long)mainstack, (unsigned long)AvARRAY(stack),
	(long)mainstack, (long)AvFILL(stack), (long)AvMAX(stack));
d109 1
a109 1
    fprintf(stderr, i ? "    =>  ...  " : "    =>  ");
d111 1
a111 1
	fprintf(stderr, " [STACK UNDERFLOW!!!]\n");
d117 1
a117 1
		putc('*', stderr);
d120 1
a120 1
	    fprintf(stderr, "  ");
d124 1
a124 1
	fprintf(stderr, "%-4s  ", SvPEEK(stack_base[i]));
d127 1
a127 1
    fprintf(stderr, "\n");
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d18 26
d45 8
a52 1
deb(const char *pat, ...)
a53 2
#ifdef DEBUGGING
    dTHR;
d56 1
a56 1
    GV* gv = PL_curcop->cop_filegv;
d58 1
a58 7
#ifdef USE_THREADS
    PerlIO_printf(Perl_debug_log, "0x%lx (%s:%ld)\t",
		  (unsigned long) thr,
		  SvTYPE(gv) == SVt_PVGV ? SvPVX(GvSV(gv)) : "<free>",
		  (long)PL_curcop->cop_line);
#else
    PerlIO_printf(Perl_debug_log, "(%s:%ld)\t",
d60 3
a62 4
	(long)PL_curcop->cop_line);
#endif /* USE_THREADS */
    for (i=0; i<PL_dlevel; i++)
	PerlIO_printf(Perl_debug_log, "%c%c ",PL_debname[i],PL_debdelim[i]);
d64 1
d66 4
a69 1
    (void) PerlIO_vprintf(Perl_debug_log,pat,args);
a70 1
#endif /* DEBUGGING */
d72 1
d75 1
a75 1
deb_growlevel(void)
d77 3
a79 5
#ifdef DEBUGGING
    PL_dlmax += 128;
    Renew(PL_debname, PL_dlmax, char);
    Renew(PL_debdelim, PL_dlmax, char);
#endif /* DEBUGGING */
d83 1
a83 1
debstackptrs(void)
d85 7
a91 10
#ifdef DEBUGGING
    dTHR;
    PerlIO_printf(Perl_debug_log, "%8lx %8lx %8ld %8ld %8ld\n",
	(unsigned long)PL_curstack, (unsigned long)PL_stack_base,
	(long)*PL_markstack_ptr, (long)(PL_stack_sp-PL_stack_base),
	(long)(PL_stack_max-PL_stack_base));
    PerlIO_printf(Perl_debug_log, "%8lx %8lx %8ld %8ld %8ld\n",
	(unsigned long)PL_mainstack, (unsigned long)AvARRAY(PL_curstack),
	(long)PL_mainstack, (long)AvFILLp(PL_curstack), (long)AvMAX(PL_curstack));
#endif /* DEBUGGING */
d96 1
a96 1
debstack(void)
d98 1
a98 3
#ifdef DEBUGGING
    dTHR;
    I32 top = PL_stack_sp - PL_stack_base;
d100 1
a100 1
    I32 *markscan = PL_curstackinfo->si_markbase;
d105 1
a105 1
    while (++markscan <= PL_markstack_ptr)
d109 3
a111 8
#ifdef USE_THREADS
    PerlIO_printf(Perl_debug_log, i ? "0x%lx    =>  ...  " : "0x%lx    =>  ",
		  (unsigned long) thr);
#else
    PerlIO_printf(Perl_debug_log, i ? "    =>  ...  " : "    =>  ");
#endif /* USE_THREADS */
    if (PL_stack_base[0] != &PL_sv_undef || PL_stack_sp < PL_stack_base)
	PerlIO_printf(Perl_debug_log, " [STACK UNDERFLOW!!!]\n");
d114 1
a114 1
	if (markscan <= PL_markstack_ptr && *markscan < i) {
d117 1
a117 1
		PerlIO_putc(Perl_debug_log, '*');
d119 2
a120 2
	    while (markscan <= PL_markstack_ptr && *markscan < i);
	    PerlIO_printf(Perl_debug_log, "  ");
d124 1
a124 1
	PerlIO_printf(Perl_debug_log, "%-4s  ", SvPEEK(PL_stack_base[i]));
d127 1
a127 2
    PerlIO_printf(Perl_debug_log, "\n");
#endif /* DEBUGGING */
d130 3
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a15 1
#define PERL_IN_DEB_C
a17 1
#if defined(PERL_IMPLICIT_CONTEXT)
d19 1
a19 1
Perl_deb_nocontext(const char *pat, ...)
d22 1
a22 1
    dTHX;
d24 15
a38 6
    va_start(args, pat);
    vdeb(pat, &args);
    va_end(args);
#endif /* DEBUGGING */
}
#endif
a39 5
void
Perl_deb(pTHX_ const char *pat, ...)
{
#ifdef DEBUGGING
    va_list args;
d41 2
a42 2
    vdeb(pat, &args);
    va_end(args);
d47 1
a47 1
Perl_vdeb(pTHX_ const char *pat, va_list *args)
d50 3
a52 13
    dTHR;
    char* file = CopFILE(PL_curcop);

#ifdef USE_THREADS
    PerlIO_printf(Perl_debug_log, "0x%"UVxf" (%s:%ld)\t",
		  PTR2UV(thr),
		  (file ? file : "<free>"),
		  (long)CopLINE(PL_curcop));
#else
    PerlIO_printf(Perl_debug_log, "(%s:%ld)\t", (file ? file : "<free>"),
		  (long)CopLINE(PL_curcop));
#endif /* USE_THREADS */
    (void) PerlIO_vprintf(Perl_debug_log, pat, *args);
d57 1
a57 1
Perl_debstackptrs(pTHX)
d61 7
a67 10
    PerlIO_printf(Perl_debug_log,
		  "%8"UVxf" %8"UVxf" %8"IVdf" %8"IVdf" %8"IVdf"\n",
		  PTR2UV(PL_curstack), PTR2UV(PL_stack_base),
		  (IV)*PL_markstack_ptr, (IV)(PL_stack_sp-PL_stack_base),
		  (IV)(PL_stack_max-PL_stack_base));
    PerlIO_printf(Perl_debug_log,
		  "%8"UVxf" %8"UVxf" %8"UVuf" %8"UVuf" %8"UVuf"\n",
		  PTR2UV(PL_mainstack), PTR2UV(AvARRAY(PL_curstack)),
		  PTR2UV(PL_mainstack), PTR2UV(AvFILLp(PL_curstack)),
		  PTR2UV(AvMAX(PL_curstack)));
d73 1
a73 1
Perl_debstack(pTHX)
d79 1
a79 1
    I32 *markscan = PL_markstack + PL_curstackinfo->si_markoff;
d89 2
a90 3
    PerlIO_printf(Perl_debug_log,
		  i ? "0x%"UVxf"    =>  ...  " : "0x%lx    =>  ",
		  PTR2UV(thr));
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d48 1
d68 1
d87 1
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
d48 1
a48 1
    char* file = OutCopFILE(PL_curcop);
d50 1
a50 1
#ifdef USE_5005THREADS
d58 1
a58 1
#endif /* USE_5005THREADS */
d84 1
a84 1
#ifndef SKIP_DEBUGGING
a88 3
    if (CopSTASH_eq(PL_curcop, PL_debstash) && !DEBUG_J_TEST_)
	return 0;

d96 1
a96 1
#ifdef USE_5005THREADS
d102 1
a102 1
#endif /* USE_5005THREADS */
d121 1
a121 1
#endif /* SKIP_DEBUGGING */
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
 *    2000, 2001, 2002, by Larry Wall and others
d81 7
d89 2
a90 8
/* dump the contents of a particular stack
 * Display stack_base[stack_min+1 .. stack_max],
 * and display the marks whose offsets are contained in addresses
 * PL_markstack[mark_min+1 .. mark_max] and whose values are in the range
 * of the stack values being displayed
 *
 * Only displays top 30 max
 */
d92 2
a93 9
STATIC void
S_deb_stack_n(pTHX_ SV** stack_base, I32 stack_min, I32 stack_max,
	I32 mark_min, I32 mark_max)
{
#ifdef DEBUGGING
    register I32 i = stack_max - 30;
    I32 *markscan = PL_markstack + mark_min;
    if (i < stack_min)
	i = stack_min;
d95 1
a95 1
    while (++markscan <= PL_markstack + mark_max)
d99 8
a106 4
    if (i > stack_min)
	PerlIO_printf(Perl_debug_log, "... ");

    if (stack_base[0] != &PL_sv_undef || stack_max < 0)
d110 1
a110 1
	if (markscan <= PL_markstack + mark_max && *markscan < i) {
d115 1
a115 1
	    while (markscan <= PL_markstack + mark_max && *markscan < i);
d118 1
a118 1
	if (i > stack_max)
d120 1
a120 1
	PerlIO_printf(Perl_debug_log, "%-4s  ", SvPEEK(stack_base[i]));
a123 21
#endif /* DEBUGGING */
}


/* dump the current stack */

I32
Perl_debstack(pTHX)
{
#ifndef SKIP_DEBUGGING
    if (CopSTASH_eq(PL_curcop, PL_debstash) && !DEBUG_J_TEST_)
	return 0;

    PerlIO_printf(Perl_debug_log, "    =>  ");
    deb_stack_n(PL_stack_base,
		0,
		PL_stack_sp - PL_stack_base,
		PL_curstackinfo->si_markoff,
		PL_markstack_ptr - PL_markstack);


a126 154


#ifdef DEBUGGING
static char * si_names[] = {
    "UNKNOWN",
    "UNDEF",
    "MAIN",
    "MAGIC",
    "SORT",
    "SIGNAL",
    "OVERLOAD",
    "DESTROY",
    "WARNHOOK",
    "DIEHOOK",
    "REQUIRE"
};
#endif

/* display all stacks */


void
Perl_deb_stack_all(pTHX)
{
#ifdef DEBUGGING
    I32		 ix, si_ix;
    PERL_SI	 *si;
    PERL_CONTEXT *cx;

    /* rewind to start of chain */
    si = PL_curstackinfo;
    while (si->si_prev)
	si = si->si_prev;

    si_ix=0;
    for (;;)
    {
	char *si_name;
	int si_name_ix = si->si_type+1; /* -1 is a valid index */
	if (si_name_ix>= sizeof(si_names))
	    si_name = "????";
	else
	    si_name = si_names[si_name_ix];
	PerlIO_printf(Perl_debug_log, "STACK %"IVdf": %s\n",
						(IV)si_ix, si_name);

	for (ix=0; ix<=si->si_cxix; ix++) {

	    cx = &(si->si_cxstack[ix]);
	    PerlIO_printf(Perl_debug_log,
		    "  CX %"IVdf": %-6s => ",
		    (IV)ix, PL_block_type[CxTYPE(cx)]
	    );
	    /* substitution contexts don't save stack pointers etc) */
	    if (CxTYPE(cx) == CXt_SUBST)
		PerlIO_printf(Perl_debug_log, "\n");
	    else {

		/* Find the the current context's stack range by searching
		 * forward for any higher contexts using this stack; failing
		 * that, it will be equal to the size of the stack for old
		 * stacks, or PL_stack_sp for the current stack
		 */

		I32 i, stack_min, stack_max, mark_min, mark_max;
		I32 ret_min, ret_max;
		PERL_CONTEXT *cx_n;
		PERL_SI      *si_n;

		cx_n = Null(PERL_CONTEXT*);

		/* there's a separate stack per SI, so only search
		 * this one */

		for (i=ix+1; i<=si->si_cxix; i++) {
		    if (CxTYPE(cx) == CXt_SUBST)
			continue;
		    cx_n = &(si->si_cxstack[i]);
		    break;
		}

		stack_min = cx->blk_oldsp;

		if (cx_n) {
		    stack_max = cx_n->blk_oldsp;
		}
		else if (si == PL_curstackinfo) {
		    stack_max = PL_stack_sp - AvARRAY(si->si_stack);
		}
		else {
		    stack_max = AvFILLp(si->si_stack);
		}

		/* for the other stack types, there's only one stack
		 * shared between all SIs */

		si_n = si;
		i = ix;
		cx_n = Null(PERL_CONTEXT*);
		for (;;) {
		    i++;
		    if (i > si_n->si_cxix) {
			if (si_n == PL_curstackinfo)
			    break;
			else {
			    si_n = si_n->si_next;
			    i = 0;
			}
		    }
		    if (CxTYPE(&(si_n->si_cxstack[i])) == CXt_SUBST)
			continue;
		    cx_n = &(si_n->si_cxstack[i]);
		    break;
		}

		mark_min  = cx->blk_oldmarksp;
		ret_min   = cx->blk_oldretsp;
		if (cx_n) {
		    mark_max  = cx_n->blk_oldmarksp;
		    ret_max   = cx_n->blk_oldretsp;
		}
		else {
		    mark_max = PL_markstack_ptr - PL_markstack;
		    ret_max  = PL_retstack_ix;
		}

		deb_stack_n(AvARRAY(si->si_stack),
			stack_min, stack_max, mark_min, mark_max);

		if (ret_max > ret_min) {
		    PerlIO_printf(Perl_debug_log, "  retop=%s\n",
			    PL_retstack[ret_min]
				? OP_NAME(PL_retstack[ret_min])
				: "(null)"
		    );
		}

	    }
	} /* next context */


	if (si == PL_curstackinfo)
	    break;
	si = si->si_next;
	si_ix++;
	if (!si)
	    break; /* shouldn't happen, but just in case.. */
    } /* next stackinfo */

    PerlIO_printf(Perl_debug_log, "\n");
#endif /* DEBUGGING */
}


@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d209 1
a209 1
		/* Find the current context's stack range by searching
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@a15 5
/*
 * This file contains various utilities for producing debugging output
 * (mainly related to displaying the stack)
 */

d209 1
a209 1
		/* Find the the current context's stack range by searching
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, by Larry Wall and others
d103 1
a103 1
    const I32 *markscan = PL_markstack + mark_min;
d159 1
a159 1
static const char * si_names[] = {
d183 1
d193 6
a198 2
        const int si_name_ix = si->si_type+1; /* -1 is a valid index */
        const char *si_name = (si_name_ix>= sizeof(si_names)) ? "????" : si_names[si_name_ix];
d204 1
a204 1
	    const PERL_CONTEXT *cx = &(si->si_cxstack[ix]);
d309 1
a309 9
/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
a34 2
#else
    PERL_UNUSED_ARG(pat);
d42 1
a44 1
#ifdef DEBUGGING
d46 1
a46 2
#else
    PERL_UNUSED_CONTEXT;
a47 1
    va_end(args);
d54 11
a64 10
    dVAR;
    const char* const file = PL_curcop ? OutCopFILE(PL_curcop) : "<null>";
    const char* const display_file = file ? file : "<free>";
    const long line = PL_curcop ? (long)CopLINE(PL_curcop) : 0;

    if (DEBUG_v_TEST)
	PerlIO_printf(Perl_debug_log, "(%ld:%s:%ld)\t",
		      (long)PerlProc_getpid(), display_file, line);
    else
	PerlIO_printf(Perl_debug_log, "(%s:%ld)\t", display_file, line);
a65 4
#else
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(pat);
    PERL_UNUSED_ARG(args);
a72 1
    dVAR;
a101 1
    dVAR;
a131 7
#else
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(stack_base);
    PERL_UNUSED_ARG(stack_min);
    PERL_UNUSED_ARG(stack_max);
    PERL_UNUSED_ARG(mark_min);
    PERL_UNUSED_ARG(mark_max);
a141 1
    dVAR;
d159 1
a159 1
static const char * const si_names[] = {
d181 2
a182 3
    dVAR;
    I32 si_ix;
    const PERL_SI *si;
d192 2
a193 3
        const size_t si_name_ix = si->si_type+1; /* -1 is a valid index */
        const char * const si_name = (si_name_ix >= sizeof(si_names)) ? "????" : si_names[si_name_ix];
	I32 ix;
d199 1
a199 1
	    const PERL_CONTEXT * const cx = &(si->si_cxstack[ix]);
d216 5
a220 2
		const PERL_CONTEXT *cx_n = NULL;
		const PERL_SI *si_n;
d249 1
a249 1
		cx_n = NULL;
d267 1
d270 1
d274 1
d280 1
a280 6
		if (CxTYPE(cx) == CXt_EVAL || CxTYPE(cx) == CXt_SUB
			|| CxTYPE(cx) == CXt_FORMAT)
		{
		    const OP * const retop = (CxTYPE(cx) == CXt_EVAL)
			    ? cx->blk_eval.retop : cx->blk_sub.retop;

d282 3
a284 1
			    retop ? OP_NAME(retop) : "(null)"
d287 1
a300 2
#else
    PERL_UNUSED_CONTEXT;
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d12 2
a13 4
 * 'Didst thou think that the eyes of the White Tower were blind?  Nay,
 *  I have seen more than thou knowest, Grey Fool.'        --Denethor
 *
 *     [p.853 of _The Lord of the Rings_, V/vii: "The Pyre of Denethor"]
a31 1
    PERL_ARGS_ASSERT_DEB_NOCONTEXT;
a44 1
    PERL_ARGS_ASSERT_DEB;
a62 2
    PERL_ARGS_ASSERT_VDEB;

a112 3

    PERL_ARGS_ASSERT_DEB_STACK_N;

@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d305 2
a306 1
		    const OP * const retop = cx->blk_sub.retop;
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d117 1
a117 1
    I32 i = stack_max - 30;
d333 1
a333 1
 * indent-tabs-mode: nil
d336 1
a336 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d220 1
a220 3
        const char * const si_name =
            si_name_ix < C_ARRAY_LENGTH(si_names) ?
            si_names[si_name_ix] : "????";
@


1.1.1.15
log
@Import perl-5.24.2
@
text
@d62 1
d86 1
a96 2
#else
    PERL_UNUSED_CONTEXT;
d116 1
d139 1
a139 1
		(void)PerlIO_putc(Perl_debug_log, '*');
d167 1
d196 1
a196 2
    "REQUIRE",
    "MULTICALL"
d207 1
d332 6
@


