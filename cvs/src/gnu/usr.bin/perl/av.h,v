head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.6
	OPENBSD_6_2_BASE:1.14
	PERL_5_24_2:1.1.1.13
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.10
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.10.0.10
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.20
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.18
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.16
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.14
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.12
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.14
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	cxJ08BvJA9Pt2PTM;

1.13
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	QP75iYx42Uo7mMxO;

1.12
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.25.20.40.43;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.24.15.06.39;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.12.18.24.20;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.35.56;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.19;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.45;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.03.43;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.50.55;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.18;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.36;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.36;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.03;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.32;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.21.55;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.39;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.04;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.04;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.33;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.09.24.14.48.26;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.06.16;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.24.14.58.42;	author afresh1;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.52.31;	author afresh1;	state Exp;
branches;
next	1.1.1.13;
commitid	B31cAbBIXiCqnL97;

1.1.1.13
date	2017.08.14.13.45.22;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.14
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    av.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2005, 2006, 2007, 2008, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

struct xpvav {
    HV*		xmg_stash;	/* class package */
    union _xmgu	xmg_u;
    SSize_t	xav_fill;       /* Index of last element present */
    SSize_t	xav_max;        /* max index for which array has space */
    SV**	xav_alloc;	/* pointer to beginning of C array of SVs */
};

/* SV*	xav_arylen; */

/* SVpav_REAL is set for all AVs whose xav_array contents are refcounted.
 * Some things like "@@_" and the scratchpad list do not set this, to
 * indicate that they are cheating (for efficiency) by not refcounting
 * the AV's contents.
 * 
 * SVpav_REIFY is only meaningful on such "fake" AVs (i.e. where SVpav_REAL
 * is not set).  It indicates that the fake AV is capable of becoming
 * real if the array needs to be modified in some way.  Functions that
 * modify fake AVs check both flags to call av_reify() as appropriate.
 *
 * Note that the Perl stack has neither flag set. (Thus,
 * items that go on the stack are never refcounted.)
 *
 * These internal details are subject to change any time.  AV
 * manipulations external to perl should not care about any of this.
 * GSAR 1999-09-10
 */

/*
=head1 Handy Values

=for apidoc AmU||Nullav
Null AV pointer.

(deprecated - use C<(AV *)NULL> instead)

=head1 Array Manipulation Functions

=for apidoc Am|int|AvFILL|AV* av
Same as C<av_top_index()>.  Deprecated, use C<av_top_index()> instead.

=for apidoc Am|int|av_tindex|AV* av
Same as C<av_top_index()>.

=cut
*/

#ifndef PERL_CORE
#  define Nullav Null(AV*)
#endif

#define AvARRAY(av)	((av)->sv_u.svu_array)
#define AvALLOC(av)	((XPVAV*)  SvANY(av))->xav_alloc
#define AvMAX(av)	((XPVAV*)  SvANY(av))->xav_max
#define AvFILLp(av)	((XPVAV*)  SvANY(av))->xav_fill
#define AvARYLEN(av)	(*Perl_av_arylen_p(aTHX_ MUTABLE_AV(av)))

#define AvREAL(av)	(SvFLAGS(av) & SVpav_REAL)
#define AvREAL_on(av)	(SvFLAGS(av) |= SVpav_REAL)
#define AvREAL_off(av)	(SvFLAGS(av) &= ~SVpav_REAL)
#define AvREAL_only(av)	(AvREIFY_off(av), SvFLAGS(av) |= SVpav_REAL)
#define AvREIFY(av)	(SvFLAGS(av) & SVpav_REIFY)
#define AvREIFY_on(av)	(SvFLAGS(av) |= SVpav_REIFY)
#define AvREIFY_off(av)	(SvFLAGS(av) &= ~SVpav_REIFY)
#define AvREIFY_only(av)	(AvREAL_off(av), SvFLAGS(av) |= SVpav_REIFY)


#define AvREALISH(av)	(SvFLAGS(av) & (SVpav_REAL|SVpav_REIFY))
                                          
#define AvFILL(av)	((SvRMAGICAL((const SV *) (av))) \
			 ? mg_size(MUTABLE_SV(av)) : AvFILLp(av))
#define av_tindex(av)   av_top_index(av)

#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_UTF8_C)
/* Note that it doesn't make sense to do this:
 *      SvGETMAGIC(av); IV x = av_tindex_nomg(av);
 * This name is controversial, and so is restricted by the #ifdef to the places
 * it already occurs
 */
#   define av_tindex_nomg(av)  (__ASSERT_(SvTYPE(av) == SVt_PVAV) AvFILLp(av))
#endif

#define NEGATIVE_INDICES_VAR "NEGATIVE_INDICES"

/*
=for apidoc newAV

Creates a new AV.  The reference count is set to 1.

Perl equivalent: C<my @@array;>.

=cut
*/

#define newAV()	MUTABLE_AV(newSV_type(SVt_PVAV))

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.13
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a75 2
#define AvPAD_NAMELIST(av)	(SvFLAGS(av) & SVpad_NAMELIST)
#define AvPAD_NAMELIST_on(av)	(SvFLAGS(av) |= SVpad_NAMELIST)
d84 9
a107 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.12
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d76 3
@


1.11
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d50 4
a53 1
Same as C<av_len()>.  Deprecated, use C<av_len()> instead.
d81 1
d101 1
a101 1
 * indent-tabs-mode: t
d104 1
a104 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.10
log
@merge in perl 5.12.2 plus local changes
@
text
@d12 2
a13 1
    union _xnvu xnv_u;
d16 1
a16 1
    _XPVMG_HEAD;
a18 2
/* SV**	xav_alloc; */
#define xav_alloc xiv_u.xivu_p1
d31 1
a31 1
 * Note that the Perl stack and @@DB::args have neither flag set. (Thus,
d60 1
a60 1
#define AvALLOC(av)	(*((SV***)&((XPVAV*)  SvANY(av))->xav_alloc))
d85 2
@


1.9
log
@Merge in perl 5.10.1
@
text
@d12 1
a12 13
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
d15 1
a15 12
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */
a17 17
typedef struct {
    SSize_t	xav_fill;       /* Index of last element present */
    SSize_t	xav_max;        /* max index for which array has space */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */
} xpvav_allocated;

d46 2
d56 3
a58 1
#define Nullav Null(AV*)
@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2005, 2006, 2007, by Larry Wall and others
d100 1
a100 1
#define AvARYLEN(av)	(*Perl_av_arylen_p(aTHX_ (AV*)av))
d113 2
a114 2
#define AvFILL(av)	((SvRMAGICAL((SV *) (av))) \
			  ? mg_size((SV *) av) : AvFILLp(av))
d117 10
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, by Larry Wall and others
d12 13
a24 1
    char*	xav_array;      /* pointer to first array element */
d27 11
a37 3
    IV		xof_off;	/* ptr is incremented by offset */
    NV		xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* magic for scalar array */
d39 1
d41 16
a56 4
    SV**	xav_alloc;	/* pointer to beginning of C array of SVs */
    SV*		xav_arylen;
    U8		xav_flags;
};
d58 3
d62 1
a62 1
/* AVf_REAL is set for all AVs whose xav_array contents are refcounted.
d67 1
a67 1
 * AVf_REIFY is only meaningful on such "fake" AVs (i.e. where AVf_REAL
a78 5
#define AVf_REAL 1	/* free old entries */
#define AVf_REIFY 2	/* can become real */

/* XXX this is not used anywhere */
#define AVf_REUSED 4	/* got undeffed--don't turn old memory into SVs now */
d96 2
a97 2
#define AvARRAY(av)	((SV**)((XPVAV*)  SvANY(av))->xav_array)
#define AvALLOC(av)	((XPVAV*)  SvANY(av))->xav_alloc
d100 1
a100 2
#define AvARYLEN(av)	((XPVAV*)  SvANY(av))->xav_arylen
#define AvFLAGS(av)	((XPVAV*)  SvANY(av))->xav_flags
d102 8
a109 9
#define AvREAL(av)	(AvFLAGS(av) & AVf_REAL)
#define AvREAL_on(av)	(AvFLAGS(av) |= AVf_REAL)
#define AvREAL_off(av)	(AvFLAGS(av) &= ~AVf_REAL)
#define AvREIFY(av)	(AvFLAGS(av) & AVf_REIFY)
#define AvREIFY_on(av)	(AvFLAGS(av) |= AVf_REIFY)
#define AvREIFY_off(av)	(AvFLAGS(av) &= ~AVf_REIFY)
#define AvREUSED(av)	(AvFLAGS(av) & AVf_REUSED)
#define AvREUSED_on(av)	(AvFLAGS(av) |= AVf_REUSED)
#define AvREUSED_off(av) (AvFLAGS(av) &= ~AVf_REUSED)
d111 1
a111 1
#define AvREALISH(av)	(AvFLAGS(av) & (AVf_REAL|AVf_REIFY))
d117 10
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d87 1
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d19 1
a19 1
    SV**	xav_alloc;	/* pointer to malloced string */
d49 2
d53 2
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d35 2
a36 2
 * Note that the Perl stack has neither flag set. (Thus, items that go
 * on the stack are never refcounted.)
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d13 1
a13 1
    SSize_t	xav_max;        /* Number of elements for which array has space */
d15 1
a15 1
    double	xnv_nv;		/* numeric value, if any */
d24 18
d44 2
d47 10
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d12 2
a13 2
    SSize_t	xav_fill;
    SSize_t	xav_max;
d33 1
a33 1
#define AvFILL(av)	((XPVAV*)  SvANY(av))->xav_fill
d48 3
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d11 1
a11 1
    char*	xav_array;	/* pointer to malloced string */
d19 1
a19 1
    SV**	xav_alloc;
d47 1
a47 1
#define AvREALISH(av)	AvFLAGS(av)	/* REAL or REIFY -- shortcut */
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d11 3
a13 3
    char*	xav_array;      /* pointer to first array element */
    SSize_t	xav_fill;       /* Index of last element present */
    SSize_t	xav_max;        /* Number of elements for which array has space */
d19 1
a19 1
    SV**	xav_alloc;	/* pointer to malloced string */
d33 1
a33 1
#define AvFILLp(av)	((XPVAV*)  SvANY(av))->xav_fill
d47 1
a47 4
#define AvREALISH(av)	(AvFLAGS(av) & (AVf_REAL|AVf_REIFY))
                                          
#define AvFILL(av)	((SvRMAGICAL((SV *) (av))) \
			  ? mg_size((SV *) av) : AvFILLp(av))
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d13 1
a13 1
    SSize_t	xav_max;        /* max index for which array has space */
d15 1
a15 1
    NV		xnv_nv;		/* numeric value, if any */
a23 18

/* AVf_REAL is set for all AVs whose xav_array contents are refcounted.
 * Some things like "@@_" and the scratchpad list do not set this, to
 * indicate that they are cheating (for efficiency) by not refcounting
 * the AV's contents.
 * 
 * AVf_REIFY is only meaningful on such "fake" AVs (i.e. where AVf_REAL
 * is not set).  It indicates that the fake AV is capable of becoming
 * real if the array needs to be modified in some way.  Functions that
 * modify fake AVs check both flags to call av_reify() as appropriate.
 *
 * Note that the Perl stack has neither flag set. (Thus, items that go
 * on the stack are never refcounted.)
 *
 * These internal details are subject to change any time.  AV
 * manipulations external to perl should not care about any of this.
 * GSAR 1999-09-10
 */
a25 2

/* XXX this is not used anywhere */
a26 10

/*
=for apidoc AmU||Nullav
Null AV pointer.

=for apidoc Am|int|AvFILL|AV* av
Same as C<av_len()>.  Deprecated, use C<av_len()> instead.

=cut
*/
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d35 2
a36 2
 * Note that the Perl stack and @@DB::args have neither flag set. (Thus,
 * items that go on the stack are never refcounted.)
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
d19 1
a19 1
    SV**	xav_alloc;	/* pointer to beginning of C array of SVs */
a48 2
=head1 Handy Values

a50 2

=head1 Array Manipulation Functions
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, by Larry Wall and others
a85 1
#define NEGATIVE_INDICES_VAR "NEGATIVE_INDICES"
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2005, 2006, 2007, by Larry Wall and others
d12 1
a12 13
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
d15 3
a17 11
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
d19 4
a24 20
typedef struct {
    SSize_t	xav_fill;       /* Index of last element present */
    SSize_t	xav_max;        /* max index for which array has space */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */
} xpvav_allocated;

/* SV**	xav_alloc; */
#define xav_alloc xiv_u.xivu_p1
/* SV*	xav_arylen; */
d26 1
a26 1
/* SVpav_REAL is set for all AVs whose xav_array contents are refcounted.
d31 1
a31 1
 * SVpav_REIFY is only meaningful on such "fake" AVs (i.e. where SVpav_REAL
d43 5
d65 2
a66 2
#define AvARRAY(av)	((av)->sv_u.svu_array)
#define AvALLOC(av)	(*((SV***)&((XPVAV*)  SvANY(av))->xav_alloc))
d69 2
a70 1
#define AvARYLEN(av)	(*Perl_av_arylen_p(aTHX_ (AV*)av))
d72 9
a80 8
#define AvREAL(av)	(SvFLAGS(av) & SVpav_REAL)
#define AvREAL_on(av)	(SvFLAGS(av) |= SVpav_REAL)
#define AvREAL_off(av)	(SvFLAGS(av) &= ~SVpav_REAL)
#define AvREAL_only(av)	(AvREIFY_off(av), SvFLAGS(av) |= SVpav_REAL)
#define AvREIFY(av)	(SvFLAGS(av) & SVpav_REIFY)
#define AvREIFY_on(av)	(SvFLAGS(av) |= SVpav_REIFY)
#define AvREIFY_off(av)	(SvFLAGS(av) &= ~SVpav_REIFY)
#define AvREIFY_only(av)	(AvREAL_off(av), SvFLAGS(av) |= SVpav_REIFY)
d82 1
a82 1
#define AvREALISH(av)	(SvFLAGS(av) & (SVpav_REAL|SVpav_REIFY))
a87 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2005, 2006, 2007, 2008, by Larry Wall and others
d100 1
a100 1
#define AvARYLEN(av)	(*Perl_av_arylen_p(aTHX_ MUTABLE_AV(av)))
d113 2
a114 2
#define AvFILL(av)	((SvRMAGICAL((const SV *) (av))) \
			 ? mg_size(MUTABLE_SV(av)) : AvFILLp(av))
a116 10

/*
=for apidoc newAV

Creates a new AV.  The reference count is set to 1.

=cut
*/

#define newAV()	MUTABLE_AV(newSV_type(SVt_PVAV))
@


1.1.1.9
log
@Perl 5.12.2 from CPAN
@
text
@d12 13
a24 1
    union _xnvu xnv_u;
d27 12
a38 1
    _XPVMG_HEAD;
d41 17
a85 2
(deprecated - use C<(AV *)NULL> instead)

d94 1
a94 3
#ifndef PERL_CORE
#  define Nullav Null(AV*)
#endif
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d12 1
a12 2
    HV*		xmg_stash;	/* class package */
    union _xmgu	xmg_u;
d15 1
a15 1
    SV**	xav_alloc;	/* pointer to beginning of C array of SVs */
d18 2
d32 1
a32 1
 * Note that the Perl stack has neither flag set. (Thus,
d61 1
a61 1
#define AvALLOC(av)	((XPVAV*)  SvANY(av))->xav_alloc
a85 2

Perl equivalent: C<my @@array;>.
@


1.1.1.11
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d50 1
a50 4
Same as C<av_top_index()>.  Deprecated, use C<av_top_index()> instead.

=for apidoc Am|int|av_tindex|AV* av
Same as C<av_top_index()>.
a77 1
#define av_tindex(av)   av_top_index(av)
d97 1
a97 1
 * indent-tabs-mode: nil
d100 1
a100 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@a75 3
#define AvPAD_NAMELIST(av)	(SvFLAGS(av) & SVpad_NAMELIST)
#define AvPAD_NAMELIST_on(av)	(SvFLAGS(av) |= SVpad_NAMELIST)

@


1.1.1.13
log
@Import perl-5.24.2
@
text
@d76 2
a85 9
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_UTF8_C)
/* Note that it doesn't make sense to do this:
 *      SvGETMAGIC(av); IV x = av_tindex_nomg(av);
 * This name is controversial, and so is restricted by the #ifdef to the places
 * it already occurs
 */
#   define av_tindex_nomg(av)  (__ASSERT_(SvTYPE(av) == SVt_PVAV) AvFILLp(av))
#endif

d101 6
@


