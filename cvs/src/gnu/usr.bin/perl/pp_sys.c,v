head	1.19;
access;
symbols
	OPENBSD_6_2_BASE:1.19
	PERL_5_24_2:1.1.1.17
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.19
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	cxJ08BvJA9Pt2PTM;

1.18
date	2016.07.03.01.07.48;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	GzHqjSTnBjdF7Wcw;

1.17
date	2015.04.25.19.14.38;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	XRK22kO4se3v2i2I;

1.16
date	2014.11.17.20.56.48;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.06.42;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.35.58;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.22.58;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.21;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.56;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.55;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.19;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.08;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.12;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.47;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.47;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.47;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.45;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.19;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.50;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.34;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.46;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.16.33;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.47.39;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.09;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.32;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.33;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.06.34;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.58.46;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.52.38;	author afresh1;	state Exp;
branches;
next	1.1.1.16;
commitid	B31cAbBIXiCqnL97;

1.1.1.16
date	2015.04.25.19.10.11;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.17
date	2017.08.14.13.45.28;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.19
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    pp_sys.c
 *
 *    Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
 *    2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * But only a short way ahead its floor and the walls on either side were
 * cloven by a great fissure, out of which the red glare came, now leaping
 * up, now dying down into darkness; and all the while far below there was
 * a rumour and a trouble as of great engines throbbing and labouring.
 *
 *     [p.945 of _The Lord of the Rings_, VI/iii: "Mount Doom"]
 */

/* This file contains system pp ("push/pop") functions that
 * execute the opcodes that make up a perl program. A typical pp function
 * expects to find its arguments on the stack, and usually pushes its
 * results onto the stack, hence the 'pp' terminology. Each OP structure
 * contains a pointer to the relevant pp_foo() function.
 *
 * By 'system', we mean ops which interact with the OS, such as pp_open().
 */

#include "EXTERN.h"
#define PERL_IN_PP_SYS_C
#include "perl.h"
#include "time64.h"

#ifdef I_SHADOW
/* Shadow password support for solaris - pdo@@cs.umd.edu
 * Not just Solaris: at least HP-UX, IRIX, Linux.
 * The API is from SysV.
 *
 * There are at least two more shadow interfaces,
 * see the comments in pp_gpwent().
 *
 * --jhi */
#   ifdef __hpux__
/* There is a MAXINT coming from <shadow.h> <- <hpsecurity.h> <- <values.h>
 * and another MAXINT from "perl.h" <- <sys/param.h>. */
#       undef MAXINT
#   endif
#   include <shadow.h>
#endif

#ifdef I_SYS_RESOURCE
# include <sys/resource.h>
#endif

#ifdef NETWARE
NETDB_DEFINE_CONTEXT
#endif

#ifdef HAS_SELECT
# ifdef I_SYS_SELECT
#  include <sys/select.h>
# endif
#endif

/* XXX Configure test needed.
   h_errno might not be a simple 'int', especially for multi-threaded
   applications, see "extern int errno in perl.h".  Creating such
   a test requires taking into account the differences between
   compiling multithreaded and singlethreaded ($ccflags et al).
   HOST_NOT_FOUND is typically defined in <netdb.h>.
*/
#if defined(HOST_NOT_FOUND) && !defined(h_errno) && !defined(__CYGWIN__)
extern int h_errno;
#endif

#ifdef HAS_PASSWD
# ifdef I_PWD
#  include <pwd.h>
# else
#  if !defined(VMS)
    struct passwd *getpwnam (char *);
    struct passwd *getpwuid (Uid_t);
#  endif
# endif
# ifdef HAS_GETPWENT
#ifndef getpwent
  struct passwd *getpwent (void);
#elif defined (VMS) && defined (my_getpwent)
  struct passwd *Perl_my_getpwent (pTHX);
#endif
# endif
#endif

#ifdef HAS_GROUP
# ifdef I_GRP
#  include <grp.h>
# else
    struct group *getgrnam (char *);
    struct group *getgrgid (Gid_t);
# endif
# ifdef HAS_GETGRENT
#ifndef getgrent
    struct group *getgrent (void);
#endif
# endif
#endif

#ifdef I_UTIME
#  if defined(_MSC_VER) || defined(__MINGW32__)
#    include <sys/utime.h>
#  else
#    include <utime.h>
#  endif
#endif

#ifdef HAS_CHSIZE
# ifdef my_chsize  /* Probably #defined to Perl_my_chsize in embed.h */
#   undef my_chsize
# endif
# define my_chsize PerlLIO_chsize
#else
# ifdef HAS_TRUNCATE
#   define my_chsize PerlLIO_chsize
# else
I32 my_chsize(int fd, Off_t length);
# endif
#endif

#ifdef HAS_FLOCK
#  define FLOCK flock
#else /* no flock() */

   /* fcntl.h might not have been included, even if it exists, because
      the current Configure only sets I_FCNTL if it's needed to pick up
      the *_OK constants.  Make sure it has been included before testing
      the fcntl() locking constants. */
#  if defined(HAS_FCNTL) && !defined(I_FCNTL)
#    include <fcntl.h>
#  endif

#  if defined(HAS_FCNTL) && defined(FCNTL_CAN_LOCK)
#    define FLOCK fcntl_emulate_flock
#    define FCNTL_EMULATE_FLOCK
#  else /* no flock() or fcntl(F_SETLK,...) */
#    ifdef HAS_LOCKF
#      define FLOCK lockf_emulate_flock
#      define LOCKF_EMULATE_FLOCK
#    endif /* lockf */
#  endif /* no flock() or fcntl(F_SETLK,...) */

#  ifdef FLOCK
     static int FLOCK (int, int);

    /*
     * These are the flock() constants.  Since this sytems doesn't have
     * flock(), the values of the constants are probably not available.
     */
#    ifndef LOCK_SH
#      define LOCK_SH 1
#    endif
#    ifndef LOCK_EX
#      define LOCK_EX 2
#    endif
#    ifndef LOCK_NB
#      define LOCK_NB 4
#    endif
#    ifndef LOCK_UN
#      define LOCK_UN 8
#    endif
#  endif /* emulating flock() */

#endif /* no flock() */

#define ZBTLEN 10
static const char zero_but_true[ZBTLEN + 1] = "0 but true";

#if defined(I_SYS_ACCESS) && !defined(R_OK)
#  include <sys/access.h>
#endif

#include "reentr.h"

#ifdef __Lynx__
/* Missing protos on LynxOS */
void sethostent(int);
void endhostent(void);
void setnetent(int);
void endnetent(void);
void setprotoent(int);
void endprotoent(void);
void setservent(int);
void endservent(void);
#endif

#ifdef __amigaos4__
#  include "amigaos4/amigaio.h"
#endif

#undef PERL_EFF_ACCESS	/* EFFective uid/gid ACCESS */

/* F_OK unused: if stat() cannot find it... */

#if !defined(PERL_EFF_ACCESS) && defined(HAS_ACCESS) && defined(EFF_ONLY_OK) && !defined(NO_EFF_ONLY_OK)
    /* Digital UNIX (when the EFF_ONLY_OK gets fixed), UnixWare */
#   define PERL_EFF_ACCESS(p,f) (access((p), (f) | EFF_ONLY_OK))
#endif

#if !defined(PERL_EFF_ACCESS) && defined(HAS_EACCESS)
#   ifdef I_SYS_SECURITY
#       include <sys/security.h>
#   endif
#   ifdef ACC_SELF
        /* HP SecureWare */
#       define PERL_EFF_ACCESS(p,f) (eaccess((p), (f), ACC_SELF))
#   else
        /* SCO */
#       define PERL_EFF_ACCESS(p,f) (eaccess((p), (f)))
#   endif
#endif

#if !defined(PERL_EFF_ACCESS) && defined(HAS_ACCESSX) && defined(ACC_SELF)
    /* AIX */
#   define PERL_EFF_ACCESS(p,f) (accessx((p), (f), ACC_SELF))
#endif


#if !defined(PERL_EFF_ACCESS) && defined(HAS_ACCESS)	\
    && (defined(HAS_SETREUID) || defined(HAS_SETRESUID)		\
	|| defined(HAS_SETREGID) || defined(HAS_SETRESGID))
/* The Hard Way. */
STATIC int
S_emulate_eaccess(pTHX_ const char* path, Mode_t mode)
{
    const Uid_t ruid = getuid();
    const Uid_t euid = geteuid();
    const Gid_t rgid = getgid();
    const Gid_t egid = getegid();
    int res;

#if !defined(HAS_SETREUID) && !defined(HAS_SETRESUID)
    Perl_croak(aTHX_ "switching effective uid is not implemented");
#else
#ifdef HAS_SETREUID
    if (setreuid(euid, ruid))
#else
#ifdef HAS_SETRESUID
    if (setresuid(euid, ruid, (Uid_t)-1))
#endif
#endif
	/* diag_listed_as: entering effective %s failed */
	Perl_croak(aTHX_ "entering effective uid failed");
#endif

#if !defined(HAS_SETREGID) && !defined(HAS_SETRESGID)
    Perl_croak(aTHX_ "switching effective gid is not implemented");
#else
#ifdef HAS_SETREGID
    if (setregid(egid, rgid))
#else
#ifdef HAS_SETRESGID
    if (setresgid(egid, rgid, (Gid_t)-1))
#endif
#endif
	/* diag_listed_as: entering effective %s failed */
	Perl_croak(aTHX_ "entering effective gid failed");
#endif

    res = access(path, mode);

#ifdef HAS_SETREUID
    if (setreuid(ruid, euid))
#else
#ifdef HAS_SETRESUID
    if (setresuid(ruid, euid, (Uid_t)-1))
#endif
#endif
	/* diag_listed_as: leaving effective %s failed */
	Perl_croak(aTHX_ "leaving effective uid failed");

#ifdef HAS_SETREGID
    if (setregid(rgid, egid))
#else
#ifdef HAS_SETRESGID
    if (setresgid(rgid, egid, (Gid_t)-1))
#endif
#endif
	/* diag_listed_as: leaving effective %s failed */
	Perl_croak(aTHX_ "leaving effective gid failed");

    return res;
}
#   define PERL_EFF_ACCESS(p,f) (S_emulate_eaccess(aTHX_ (p), (f)))
#endif

PP(pp_backtick)
{
    dSP; dTARGET;
    PerlIO *fp;
    const char * const tmps = POPpconstx;
    const U8 gimme = GIMME_V;
    const char *mode = "r";

    TAINT_PROPER("``");
    if (PL_op->op_private & OPpOPEN_IN_RAW)
	mode = "rb";
    else if (PL_op->op_private & OPpOPEN_IN_CRLF)
	mode = "rt";
    fp = PerlProc_popen(tmps, mode);
    if (fp) {
        const char * const type = Perl_PerlIO_context_layers(aTHX_ NULL);
	if (type && *type)
	    PerlIO_apply_layers(aTHX_ fp,mode,type);

	if (gimme == G_VOID) {
	    char tmpbuf[256];
	    while (PerlIO_read(fp, tmpbuf, sizeof tmpbuf) > 0)
		NOOP;
	}
	else if (gimme == G_SCALAR) {
	    ENTER_with_name("backtick");
	    SAVESPTR(PL_rs);
	    PL_rs = &PL_sv_undef;
	    sv_setpvs(TARG, "");	/* note that this preserves previous buffer */
	    while (sv_gets(TARG, fp, SvCUR(TARG)) != NULL)
		NOOP;
	    LEAVE_with_name("backtick");
	    XPUSHs(TARG);
	    SvTAINTED_on(TARG);
	}
	else {
	    for (;;) {
		SV * const sv = newSV(79);
		if (sv_gets(sv, fp, 0) == NULL) {
		    SvREFCNT_dec(sv);
		    break;
		}
		mXPUSHs(sv);
		if (SvLEN(sv) - SvCUR(sv) > 20) {
		    SvPV_shrink_to_cur(sv);
		}
		SvTAINTED_on(sv);
	    }
	}
	STATUS_NATIVE_CHILD_SET(PerlProc_pclose(fp));
	TAINT;		/* "I believe that this is not gratuitous!" */
    }
    else {
	STATUS_NATIVE_CHILD_SET(-1);
	if (gimme == G_SCALAR)
	    RETPUSHUNDEF;
    }

    RETURN;
}

PP(pp_glob)
{
    OP *result;
    dSP;
    GV * const gv = (PL_op->op_flags & OPf_SPECIAL) ? NULL : (GV *)POPs;

    PUTBACK;

    /* make a copy of the pattern if it is gmagical, to ensure that magic
     * is called once and only once */
    if (SvGMAGICAL(TOPs)) TOPs = sv_2mortal(newSVsv(TOPs));

    tryAMAGICunTARGETlist(iter_amg, (PL_op->op_flags & OPf_SPECIAL));

    if (PL_op->op_flags & OPf_SPECIAL) {
	/* call Perl-level glob function instead. Stack args are:
	 * MARK, wildcard
	 * and following OPs should be: gv(CORE::GLOBAL::glob), entersub
	 * */
	return NORMAL;
    }
    if (PL_globhook) {
	PL_globhook(aTHX);
	return NORMAL;
    }

    /* Note that we only ever get here if File::Glob fails to load
     * without at the same time croaking, for some reason, or if
     * perl was built with PERL_EXTERNAL_GLOB */

    ENTER_with_name("glob");

#ifndef VMS
    if (TAINTING_get) {
	/*
	 * The external globbing program may use things we can't control,
	 * so for security reasons we must assume the worst.
	 */
	TAINT;
	taint_proper(PL_no_security, "glob");
    }
#endif /* !VMS */

    SAVESPTR(PL_last_in_gv);	/* We don't want this to be permanent. */
    PL_last_in_gv = gv;

    SAVESPTR(PL_rs);		/* This is not permanent, either. */
    PL_rs = newSVpvs_flags("\000", SVs_TEMP);
#ifndef DOSISH
#ifndef CSH
    *SvPVX(PL_rs) = '\n';
#endif	/* !CSH */
#endif	/* !DOSISH */

    result = do_readline();
    LEAVE_with_name("glob");
    return result;
}

PP(pp_rcatline)
{
    PL_last_in_gv = cGVOP_gv;
    return do_readline();
}

PP(pp_warn)
{
    dSP; dMARK;
    SV *exsv;
    STRLEN len;
    if (SP - MARK > 1) {
	dTARGET;
	do_join(TARG, &PL_sv_no, MARK, SP);
	exsv = TARG;
	SP = MARK + 1;
    }
    else if (SP == MARK) {
	exsv = &PL_sv_no;
	EXTEND(SP, 1);
	SP = MARK + 1;
    }
    else {
	exsv = TOPs;
	if (SvGMAGICAL(exsv)) exsv = sv_mortalcopy(exsv);
    }

    if (SvROK(exsv) || (SvPV_const(exsv, len), len)) {
	/* well-formed exception supplied */
    }
    else {
      SV * const errsv = ERRSV;
      SvGETMAGIC(errsv);
      if (SvROK(errsv)) {
	if (SvGMAGICAL(errsv)) {
	    exsv = sv_newmortal();
	    sv_setsv_nomg(exsv, errsv);
	}
	else exsv = errsv;
      }
      else if (SvPOKp(errsv) ? SvCUR(errsv) : SvNIOKp(errsv)) {
	exsv = sv_newmortal();
	sv_setsv_nomg(exsv, errsv);
	sv_catpvs(exsv, "\t...caught");
      }
      else {
	exsv = newSVpvs_flags("Warning: something's wrong", SVs_TEMP);
      }
    }
    if (SvROK(exsv) && !PL_warnhook)
	 Perl_warn(aTHX_ "%"SVf, SVfARG(exsv));
    else warn_sv(exsv);
    RETSETYES;
}

PP(pp_die)
{
    dSP; dMARK;
    SV *exsv;
    STRLEN len;
#ifdef VMS
    VMSISH_HUSHED  =
	VMSISH_HUSHED || (PL_curcop->op_private & OPpHUSH_VMSISH);
#endif
    if (SP - MARK != 1) {
	dTARGET;
	do_join(TARG, &PL_sv_no, MARK, SP);
	exsv = TARG;
	SP = MARK + 1;
    }
    else {
	exsv = TOPs;
    }

    if (SvROK(exsv) || (SvPV_const(exsv, len), len)) {
	/* well-formed exception supplied */
    }
    else {
	SV * const errsv = ERRSV;
	SvGETMAGIC(errsv);
	if (SvROK(errsv)) {
	    exsv = errsv;
	    if (sv_isobject(exsv)) {
		HV * const stash = SvSTASH(SvRV(exsv));
		GV * const gv = gv_fetchmethod(stash, "PROPAGATE");
		if (gv) {
		    SV * const file = sv_2mortal(newSVpv(CopFILE(PL_curcop),0));
		    SV * const line = sv_2mortal(newSVuv(CopLINE(PL_curcop)));
		    EXTEND(SP, 3);
		    PUSHMARK(SP);
		    PUSHs(exsv);
		    PUSHs(file);
		    PUSHs(line);
		    PUTBACK;
		    call_sv(MUTABLE_SV(GvCV(gv)),
			    G_SCALAR|G_EVAL|G_KEEPERR);
		    exsv = sv_mortalcopy(*PL_stack_sp--);
		}
	    }
	}
	else if (SvPOK(errsv) && SvCUR(errsv)) {
	    exsv = sv_mortalcopy(errsv);
	    sv_catpvs(exsv, "\t...propagated");
	}
	else {
	    exsv = newSVpvs_flags("Died", SVs_TEMP);
	}
    }
    die_sv(exsv);
    NOT_REACHED; /* NOTREACHED */
    return NULL; /* avoid missing return from non-void function warning */
}

/* I/O. */

OP *
Perl_tied_method(pTHX_ SV *methname, SV **sp, SV *const sv,
		 const MAGIC *const mg, const U32 flags, U32 argc, ...)
{
    SV **orig_sp = sp;
    I32 ret_args;
    SSize_t extend_size;

    PERL_ARGS_ASSERT_TIED_METHOD;

    /* Ensure that our flag bits do not overlap.  */
    STATIC_ASSERT_STMT((TIED_METHOD_MORTALIZE_NOT_NEEDED & G_WANT) == 0);
    STATIC_ASSERT_STMT((TIED_METHOD_ARGUMENTS_ON_STACK & G_WANT) == 0);
    STATIC_ASSERT_STMT((TIED_METHOD_SAY & G_WANT) == 0);

    PUTBACK; /* sp is at *foot* of args, so this pops args from old stack */
    PUSHSTACKi(PERLSI_MAGIC);
    /* extend for object + args. If argc might wrap/truncate when cast
     * to SSize_t and incremented, set to -1, which will trigger a panic in
     * EXTEND().
     * The weird way this is written is because g++ is dumb enough to
     * warn "comparison is always false" on something like:
     *
     * sizeof(a) >= sizeof(b) && a >= B_t_MAX -1
     *
     * (where the LH condition is false)
     */
    extend_size =
        (argc > (sizeof(argc) >= sizeof(SSize_t) ? SSize_t_MAX - 1 : argc))
            ? -1 : (SSize_t)argc + 1;
    EXTEND(SP, extend_size);
    PUSHMARK(sp);
    PUSHs(SvTIED_obj(sv, mg));
    if (flags & TIED_METHOD_ARGUMENTS_ON_STACK) {
	Copy(orig_sp + 2, sp + 1, argc, SV*); /* copy args to new stack */
	sp += argc;
    }
    else if (argc) {
	const U32 mortalize_not_needed
	    = flags & TIED_METHOD_MORTALIZE_NOT_NEEDED;
	va_list args;
	va_start(args, argc);
	do {
	    SV *const arg = va_arg(args, SV *);
	    if(mortalize_not_needed)
		PUSHs(arg);
	    else
		mPUSHs(arg);
	} while (--argc);
	va_end(args);
    }

    PUTBACK;
    ENTER_with_name("call_tied_method");
    if (flags & TIED_METHOD_SAY) {
	/* local $\ = "\n" */
	SAVEGENERICSV(PL_ors_sv);
	PL_ors_sv = newSVpvs("\n");
    }
    ret_args = call_sv(methname, (flags & G_WANT)|G_METHOD_NAMED);
    SPAGAIN;
    orig_sp = sp;
    POPSTACK;
    SPAGAIN;
    if (ret_args) { /* copy results back to original stack */
	EXTEND(sp, ret_args);
	Copy(orig_sp - ret_args + 1, sp + 1, ret_args, SV*);
	sp += ret_args;
	PUTBACK;
    }
    LEAVE_with_name("call_tied_method");
    return NORMAL;
}

#define tied_method0(a,b,c,d)		\
    Perl_tied_method(aTHX_ a,b,c,d,G_SCALAR,0)
#define tied_method1(a,b,c,d,e)		\
    Perl_tied_method(aTHX_ a,b,c,d,G_SCALAR,1,e)
#define tied_method2(a,b,c,d,e,f)	\
    Perl_tied_method(aTHX_ a,b,c,d,G_SCALAR,2,e,f)

PP(pp_open)
{
    dSP;
    dMARK; dORIGMARK;
    dTARGET;
    SV *sv;
    IO *io;
    const char *tmps;
    STRLEN len;
    bool  ok;

    GV * const gv = MUTABLE_GV(*++MARK);

    if (!isGV(gv) && !(SvTYPE(gv) == SVt_PVLV && isGV_with_GP(gv)))
	DIE(aTHX_ PL_no_usym, "filehandle");

    if ((io = GvIOp(gv))) {
	const MAGIC *mg;
	IoFLAGS(GvIOp(gv)) &= ~IOf_UNTAINT;

	if (IoDIRP(io))
	    Perl_ck_warner_d(aTHX_ packWARN2(WARN_IO, WARN_DEPRECATED),
			     "Opening dirhandle %"HEKf" also as a file",
			     HEKfARG(GvENAME_HEK(gv)));

	mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    /* Method's args are same as ours ... */
	    /* ... except handle is replaced by the object */
	    return Perl_tied_method(aTHX_ SV_CONST(OPEN), mark - 1, MUTABLE_SV(io), mg,
				    G_SCALAR | TIED_METHOD_ARGUMENTS_ON_STACK,
				    sp - mark);
	}
    }

    if (MARK < SP) {
	sv = *++MARK;
    }
    else {
	sv = GvSVn(gv);
    }

    tmps = SvPV_const(sv, len);
    ok = do_open6(gv, tmps, len, NULL, MARK+1, (SP-MARK));
    SP = ORIGMARK;
    if (ok)
	PUSHi( (I32)PL_forkprocess );
    else if (PL_forkprocess == 0)		/* we are a new child */
	PUSHi(0);
    else
	RETPUSHUNDEF;
    RETURN;
}

PP(pp_close)
{
    dSP;
    GV * const gv =
	MAXARG == 0 || (!TOPs && !POPs) ? PL_defoutgv : MUTABLE_GV(POPs);

    if (MAXARG == 0)
	EXTEND(SP, 1);

    if (gv) {
	IO * const io = GvIO(gv);
	if (io) {
	    const MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
	    if (mg) {
		return tied_method0(SV_CONST(CLOSE), SP, MUTABLE_SV(io), mg);
	    }
	}
    }
    PUSHs(boolSV(do_close(gv, TRUE)));
    RETURN;
}

PP(pp_pipe_op)
{
#ifdef HAS_PIPE
    dSP;
    IO *rstio;
    IO *wstio;
    int fd[2];

    GV * const wgv = MUTABLE_GV(POPs);
    GV * const rgv = MUTABLE_GV(POPs);

    rstio = GvIOn(rgv);
    if (IoIFP(rstio))
	do_close(rgv, FALSE);

    wstio = GvIOn(wgv);
    if (IoIFP(wstio))
	do_close(wgv, FALSE);

    if (PerlProc_pipe(fd) < 0)
	goto badexit;

    IoIFP(rstio) = PerlIO_fdopen(fd[0], "r"PIPE_OPEN_MODE);
    IoOFP(wstio) = PerlIO_fdopen(fd[1], "w"PIPE_OPEN_MODE);
    IoOFP(rstio) = IoIFP(rstio);
    IoIFP(wstio) = IoOFP(wstio);
    IoTYPE(rstio) = IoTYPE_RDONLY;
    IoTYPE(wstio) = IoTYPE_WRONLY;

    if (!IoIFP(rstio) || !IoOFP(wstio)) {
	if (IoIFP(rstio))
	    PerlIO_close(IoIFP(rstio));
	else
	    PerlLIO_close(fd[0]);
	if (IoOFP(wstio))
	    PerlIO_close(IoOFP(wstio));
	else
	    PerlLIO_close(fd[1]);
	goto badexit;
    }
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
    /* ensure close-on-exec */
    if ((fd[0] > PL_maxsysfd && fcntl(fd[0], F_SETFD, FD_CLOEXEC) < 0) ||
        (fd[1] > PL_maxsysfd && fcntl(fd[1], F_SETFD, FD_CLOEXEC) < 0))
        goto badexit;
#endif
    RETPUSHYES;

  badexit:
    RETPUSHUNDEF;
#else
    DIE(aTHX_ PL_no_func, "pipe");
#endif
}

PP(pp_fileno)
{
    dSP; dTARGET;
    GV *gv;
    IO *io;
    PerlIO *fp;
    const MAGIC *mg;

    if (MAXARG < 1)
	RETPUSHUNDEF;
    gv = MUTABLE_GV(POPs);
    io = GvIO(gv);

    if (io
	&& (mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar)))
    {
	return tied_method0(SV_CONST(FILENO), SP, MUTABLE_SV(io), mg);
    }

    if (io && IoDIRP(io)) {
#if defined(HAS_DIRFD) || defined(HAS_DIR_DD_FD)
        PUSHi(my_dirfd(IoDIRP(io)));
        RETURN;
#elif defined(ENOTSUP)
        errno = ENOTSUP;        /* Operation not supported */
        RETPUSHUNDEF;
#elif defined(EOPNOTSUPP)
        errno = EOPNOTSUPP;     /* Operation not supported on socket */
        RETPUSHUNDEF;
#else
        errno = EINVAL;         /* Invalid argument */
        RETPUSHUNDEF;
#endif
    }

    if (!io || !(fp = IoIFP(io))) {
	/* Can't do this because people seem to do things like
	   defined(fileno($foo)) to check whether $foo is a valid fh.

	   report_evil_fh(gv);
	    */
	RETPUSHUNDEF;
    }

    PUSHi(PerlIO_fileno(fp));
    RETURN;
}

PP(pp_umask)
{
    dSP;
#ifdef HAS_UMASK
    dTARGET;
    Mode_t anum;

    if (MAXARG < 1 || (!TOPs && !POPs)) {
	anum = PerlLIO_umask(022);
	/* setting it to 022 between the two calls to umask avoids
	 * to have a window where the umask is set to 0 -- meaning
	 * that another thread could create world-writeable files. */
	if (anum != 022)
	    (void)PerlLIO_umask(anum);
    }
    else
	anum = PerlLIO_umask(POPi);
    TAINT_PROPER("umask");
    XPUSHi(anum);
#else
    /* Only DIE if trying to restrict permissions on "user" (self).
     * Otherwise it's harmless and more useful to just return undef
     * since 'group' and 'other' concepts probably don't exist here. */
    if (MAXARG >= 1 && (TOPs||POPs) && (POPi & 0700))
	DIE(aTHX_ "umask not implemented");
    XPUSHs(&PL_sv_undef);
#endif
    RETURN;
}

PP(pp_binmode)
{
    dSP;
    GV *gv;
    IO *io;
    PerlIO *fp;
    SV *discp = NULL;

    if (MAXARG < 1)
	RETPUSHUNDEF;
    if (MAXARG > 1) {
	discp = POPs;
    }

    gv = MUTABLE_GV(POPs);
    io = GvIO(gv);

    if (io) {
	const MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    /* This takes advantage of the implementation of the varargs
	       function, which I don't think that the optimiser will be able to
	       figure out. Although, as it's a static function, in theory it
	       could.  */
	    return Perl_tied_method(aTHX_ SV_CONST(BINMODE), SP, MUTABLE_SV(io), mg,
				    G_SCALAR|TIED_METHOD_MORTALIZE_NOT_NEEDED,
				    discp ? 1 : 0, discp);
	}
    }

    if (!io || !(fp = IoIFP(io))) {
	report_evil_fh(gv);
	SETERRNO(EBADF,RMS_IFI);
        RETPUSHUNDEF;
    }

    PUTBACK;
    {
	STRLEN len = 0;
	const char *d = NULL;
	int mode;
	if (discp)
	    d = SvPV_const(discp, len);
	mode = mode_from_discipline(d, len);
	if (PerlIO_binmode(aTHX_ fp, IoTYPE(io), mode, d)) {
	    if (IoOFP(io) && IoOFP(io) != IoIFP(io)) {
		if (!PerlIO_binmode(aTHX_ IoOFP(io), IoTYPE(io), mode, d)) {
		    SPAGAIN;
		    RETPUSHUNDEF;
		}
	    }
	    SPAGAIN;
	    RETPUSHYES;
	}
	else {
	    SPAGAIN;
	    RETPUSHUNDEF;
	}
    }
}

PP(pp_tie)
{
    dSP; dMARK;
    HV* stash;
    GV *gv = NULL;
    SV *sv;
    const I32 markoff = MARK - PL_stack_base;
    const char *methname;
    int how = PERL_MAGIC_tied;
    U32 items;
    SV *varsv = *++MARK;

    switch(SvTYPE(varsv)) {
	case SVt_PVHV:
	{
	    HE *entry;
	    methname = "TIEHASH";
	    if (HvLAZYDEL(varsv) && (entry = HvEITER((HV *)varsv))) {
		HvLAZYDEL_off(varsv);
		hv_free_ent((HV *)varsv, entry);
	    }
	    HvEITER_set(MUTABLE_HV(varsv), 0);
	    break;
	}
	case SVt_PVAV:
	    methname = "TIEARRAY";
	    if (!AvREAL(varsv)) {
		if (!AvREIFY(varsv))
		    Perl_croak(aTHX_ "Cannot tie unreifiable array");
		av_clear((AV *)varsv);
		AvREIFY_off(varsv);
		AvREAL_on(varsv);
	    }
	    break;
	case SVt_PVGV:
	case SVt_PVLV:
	    if (isGV_with_GP(varsv) && !SvFAKE(varsv)) {
		methname = "TIEHANDLE";
		how = PERL_MAGIC_tiedscalar;
		/* For tied filehandles, we apply tiedscalar magic to the IO
		   slot of the GP rather than the GV itself. AMS 20010812 */
		if (!GvIOp(varsv))
		    GvIOp(varsv) = newIO();
		varsv = MUTABLE_SV(GvIOp(varsv));
		break;
	    }
	    if (SvTYPE(varsv) == SVt_PVLV && LvTYPE(varsv) == 'y') {
		vivify_defelem(varsv);
		varsv = LvTARG(varsv);
	    }
	    /* FALLTHROUGH */
	default:
	    methname = "TIESCALAR";
	    how = PERL_MAGIC_tiedscalar;
	    break;
    }
    items = SP - MARK++;
    if (sv_isobject(*MARK)) { /* Calls GET magic. */
	ENTER_with_name("call_TIE");
	PUSHSTACKi(PERLSI_MAGIC);
	PUSHMARK(SP);
	EXTEND(SP,(I32)items);
	while (items--)
	    PUSHs(*MARK++);
	PUTBACK;
	call_method(methname, G_SCALAR);
    }
    else {
	/* Can't use call_method here, else this: fileno FOO; tie @@a, "FOO"
	 * will attempt to invoke IO::File::TIEARRAY, with (best case) the
	 * wrong error message, and worse case, supreme action at a distance.
	 * (Sorry obfuscation writers. You're not going to be given this one.)
	 */
       stash = gv_stashsv(*MARK, 0);
       if (!stash || !(gv = gv_fetchmethod(stash, methname))) {
	    DIE(aTHX_ "Can't locate object method \"%s\" via package \"%"SVf"\"",
		 methname, SVfARG(SvOK(*MARK) ? *MARK : &PL_sv_no));
	}
	ENTER_with_name("call_TIE");
	PUSHSTACKi(PERLSI_MAGIC);
	PUSHMARK(SP);
	EXTEND(SP,(I32)items);
	while (items--)
	    PUSHs(*MARK++);
	PUTBACK;
	call_sv(MUTABLE_SV(GvCV(gv)), G_SCALAR);
    }
    SPAGAIN;

    sv = TOPs;
    POPSTACK;
    if (sv_isobject(sv)) {
	sv_unmagic(varsv, how);
	/* Croak if a self-tie on an aggregate is attempted. */
	if (varsv == SvRV(sv) &&
	    (SvTYPE(varsv) == SVt_PVAV ||
	     SvTYPE(varsv) == SVt_PVHV))
	    Perl_croak(aTHX_
		       "Self-ties of arrays and hashes are not supported");
	sv_magic(varsv, (SvRV(sv) == varsv ? NULL : sv), how, NULL, 0);
    }
    LEAVE_with_name("call_TIE");
    SP = PL_stack_base + markoff;
    PUSHs(sv);
    RETURN;
}


/* also used for: pp_dbmclose() */

PP(pp_untie)
{
    dSP;
    MAGIC *mg;
    SV *sv = POPs;
    const char how = (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV)
		? PERL_MAGIC_tied : PERL_MAGIC_tiedscalar;

    if (isGV_with_GP(sv) && !SvFAKE(sv) && !(sv = MUTABLE_SV(GvIOp(sv))))
	RETPUSHYES;

    if (SvTYPE(sv) == SVt_PVLV && LvTYPE(sv) == 'y' &&
	!(sv = defelem_target(sv, NULL))) RETPUSHUNDEF;

    if ((mg = SvTIED_mg(sv, how))) {
	SV * const obj = SvRV(SvTIED_obj(sv, mg));
        if (obj) {
	    GV * const gv = gv_fetchmethod_autoload(SvSTASH(obj), "UNTIE", FALSE);
	    CV *cv;
	    if (gv && isGV(gv) && (cv = GvCV(gv))) {
	       PUSHMARK(SP);
	       PUSHs(SvTIED_obj(MUTABLE_SV(gv), mg));
	       mXPUSHi(SvREFCNT(obj) - 1);
	       PUTBACK;
	       ENTER_with_name("call_UNTIE");
	       call_sv(MUTABLE_SV(cv), G_VOID);
	       LEAVE_with_name("call_UNTIE");
	       SPAGAIN;
            }
	    else if (mg && SvREFCNT(obj) > 1) {
		Perl_ck_warner(aTHX_ packWARN(WARN_UNTIE),
			       "untie attempted while %"UVuf" inner references still exist",
			       (UV)SvREFCNT(obj) - 1 ) ;
	    }
        }
    }
    sv_unmagic(sv, how) ;
    RETPUSHYES;
}

PP(pp_tied)
{
    dSP;
    const MAGIC *mg;
    dTOPss;
    const char how = (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV)
		? PERL_MAGIC_tied : PERL_MAGIC_tiedscalar;

    if (isGV_with_GP(sv) && !SvFAKE(sv) && !(sv = MUTABLE_SV(GvIOp(sv))))
	goto ret_undef;

    if (SvTYPE(sv) == SVt_PVLV && LvTYPE(sv) == 'y' &&
	!(sv = defelem_target(sv, NULL))) goto ret_undef;

    if ((mg = SvTIED_mg(sv, how))) {
	SETs(SvTIED_obj(sv, mg));
	return NORMAL; /* PUTBACK not needed, pp_tied never moves SP */
    }
    ret_undef:
    SETs(&PL_sv_undef);
    return NORMAL;
}

PP(pp_dbmopen)
{
    dSP;
    dPOPPOPssrl;
    HV* stash;
    GV *gv = NULL;

    HV * const hv = MUTABLE_HV(POPs);
    SV * const sv = newSVpvs_flags("AnyDBM_File", SVs_TEMP);
    stash = gv_stashsv(sv, 0);
    if (!stash || !(gv = gv_fetchmethod(stash, "TIEHASH"))) {
	PUTBACK;
	require_pv("AnyDBM_File.pm");
	SPAGAIN;
	if (!stash || !(gv = gv_fetchmethod(stash, "TIEHASH")))
	    DIE(aTHX_ "No dbm on this machine");
    }

    ENTER;
    PUSHMARK(SP);

    EXTEND(SP, 5);
    PUSHs(sv);
    PUSHs(left);
    if (SvIV(right))
	mPUSHu(O_RDWR|O_CREAT);
    else
    {
	mPUSHu(O_RDWR);
	if (!SvOK(right)) right = &PL_sv_no;
    }
    PUSHs(right);
    PUTBACK;
    call_sv(MUTABLE_SV(GvCV(gv)), G_SCALAR);
    SPAGAIN;

    if (!sv_isobject(TOPs)) {
	SP--;
	PUSHMARK(SP);
	PUSHs(sv);
	PUSHs(left);
	mPUSHu(O_RDONLY);
	PUSHs(right);
	PUTBACK;
	call_sv(MUTABLE_SV(GvCV(gv)), G_SCALAR);
	SPAGAIN;
        if (sv_isobject(TOPs))
            goto retie;
    }
    else {
        retie:
	sv_unmagic(MUTABLE_SV(hv), PERL_MAGIC_tied);
	sv_magic(MUTABLE_SV(hv), TOPs, PERL_MAGIC_tied, NULL, 0);
    }
    LEAVE;
    RETURN;
}

PP(pp_sselect)
{
#ifdef HAS_SELECT
    dSP; dTARGET;
    I32 i;
    I32 j;
    char *s;
    SV *sv;
    NV value;
    I32 maxlen = 0;
    I32 nfound;
    struct timeval timebuf;
    struct timeval *tbuf = &timebuf;
    I32 growsize;
    char *fd_sets[4];
#if BYTEORDER != 0x1234 && BYTEORDER != 0x12345678
	I32 masksize;
	I32 offset;
	I32 k;

#   if BYTEORDER & 0xf0000
#	define ORDERBYTE (0x88888888 - BYTEORDER)
#   else
#	define ORDERBYTE (0x4444 - BYTEORDER)
#   endif

#endif

    SP -= 4;
    for (i = 1; i <= 3; i++) {
	SV * const sv = SP[i];
	SvGETMAGIC(sv);
	if (!SvOK(sv))
	    continue;
	if (SvREADONLY(sv)) {
	    if (!(SvPOK(sv) && SvCUR(sv) == 0))
		Perl_croak_no_modify();
	}
	else if (SvIsCOW(sv)) sv_force_normal_flags(sv, 0);
	if (!SvPOK(sv)) {
	    if (!SvPOKp(sv))
		Perl_ck_warner(aTHX_ packWARN(WARN_MISC),
				    "Non-string passed as bitmask");
	    SvPV_force_nomg_nolen(sv);	/* force string conversion */
	}
	j = SvCUR(sv);
	if (maxlen < j)
	    maxlen = j;
    }

/* little endians can use vecs directly */
#if BYTEORDER != 0x1234 && BYTEORDER != 0x12345678
#  ifdef NFDBITS

#    ifndef NBBY
#     define NBBY 8
#    endif

    masksize = NFDBITS / NBBY;
#  else
    masksize = sizeof(long);	/* documented int, everyone seems to use long */
#  endif
    Zero(&fd_sets[0], 4, char*);
#endif

#  if SELECT_MIN_BITS == 1
    growsize = sizeof(fd_set);
#  else
#   if defined(__GLIBC__) && defined(__FD_SETSIZE)
#      undef SELECT_MIN_BITS
#      define SELECT_MIN_BITS __FD_SETSIZE
#   endif
    /* If SELECT_MIN_BITS is greater than one we most probably will want
     * to align the sizes with SELECT_MIN_BITS/8 because for example
     * in many little-endian (Intel, Alpha) systems (Linux, OS/2, Digital
     * UNIX, Solaris, Darwin) the smallest quantum select() operates
     * on (sets/tests/clears bits) is 32 bits.  */
    growsize = maxlen + (SELECT_MIN_BITS/8 - (maxlen % (SELECT_MIN_BITS/8)));
#  endif

    sv = SP[4];
    SvGETMAGIC(sv);
    if (SvOK(sv)) {
	value = SvNV_nomg(sv);
	if (value < 0.0)
	    value = 0.0;
	timebuf.tv_sec = (long)value;
	value -= (NV)timebuf.tv_sec;
	timebuf.tv_usec = (long)(value * 1000000.0);
    }
    else
	tbuf = NULL;

    for (i = 1; i <= 3; i++) {
	sv = SP[i];
	if (!SvOK(sv) || SvCUR(sv) == 0) {
	    fd_sets[i] = 0;
	    continue;
	}
	assert(SvPOK(sv));
	j = SvLEN(sv);
	if (j < growsize) {
	    Sv_Grow(sv, growsize);
	}
	j = SvCUR(sv);
	s = SvPVX(sv) + j;
	while (++j <= growsize) {
	    *s++ = '\0';
	}

#if BYTEORDER != 0x1234 && BYTEORDER != 0x12345678
	s = SvPVX(sv);
	Newx(fd_sets[i], growsize, char);
	for (offset = 0; offset < growsize; offset += masksize) {
	    for (j = 0, k=ORDERBYTE; j < masksize; j++, (k >>= 4))
		fd_sets[i][j+offset] = s[(k % masksize) + offset];
	}
#else
	fd_sets[i] = SvPVX(sv);
#endif
    }

#ifdef PERL_IRIX5_SELECT_TIMEVAL_VOID_CAST
    /* Can't make just the (void*) conditional because that would be
     * cpp #if within cpp macro, and not all compilers like that. */
    nfound = PerlSock_select(
	maxlen * 8,
	(Select_fd_set_t) fd_sets[1],
	(Select_fd_set_t) fd_sets[2],
	(Select_fd_set_t) fd_sets[3],
	(void*) tbuf); /* Workaround for compiler bug. */
#else
    nfound = PerlSock_select(
	maxlen * 8,
	(Select_fd_set_t) fd_sets[1],
	(Select_fd_set_t) fd_sets[2],
	(Select_fd_set_t) fd_sets[3],
	tbuf);
#endif
    for (i = 1; i <= 3; i++) {
	if (fd_sets[i]) {
	    sv = SP[i];
#if BYTEORDER != 0x1234 && BYTEORDER != 0x12345678
	    s = SvPVX(sv);
	    for (offset = 0; offset < growsize; offset += masksize) {
		for (j = 0, k=ORDERBYTE; j < masksize; j++, (k >>= 4))
		    s[(k % masksize) + offset] = fd_sets[i][j+offset];
	    }
	    Safefree(fd_sets[i]);
#endif
	    SvSETMAGIC(sv);
	}
    }

    PUSHi(nfound);
    if (GIMME_V == G_ARRAY && tbuf) {
	value = (NV)(timebuf.tv_sec) +
		(NV)(timebuf.tv_usec) / 1000000.0;
	mPUSHn(value);
    }
    RETURN;
#else
    DIE(aTHX_ "select not implemented");
#endif
}

/*

=head1 GV Functions

=for apidoc setdefout

Sets C<PL_defoutgv>, the default file handle for output, to the passed in
typeglob.  As C<PL_defoutgv> "owns" a reference on its typeglob, the reference
count of the passed in typeglob is increased by one, and the reference count
of the typeglob that C<PL_defoutgv> points to is decreased by one.

=cut
*/

void
Perl_setdefout(pTHX_ GV *gv)
{
    GV *oldgv = PL_defoutgv;

    PERL_ARGS_ASSERT_SETDEFOUT;

    SvREFCNT_inc_simple_void_NN(gv);
    PL_defoutgv = gv;
    SvREFCNT_dec(oldgv);
}

PP(pp_select)
{
    dSP; dTARGET;
    HV *hv;
    GV * const newdefout = (PL_op->op_private > 0) ? (MUTABLE_GV(POPs)) : NULL;
    GV * egv = GvEGVx(PL_defoutgv);
    GV * const *gvp;

    if (!egv)
	egv = PL_defoutgv;
    hv = isGV_with_GP(egv) ? GvSTASH(egv) : NULL;
    gvp = hv && HvENAME(hv)
		? (GV**)hv_fetch(hv, GvNAME(egv), HEK_UTF8(GvNAME_HEK(egv)) ? -GvNAMELEN(egv) : GvNAMELEN(egv), FALSE)
		: NULL;
    if (gvp && *gvp == egv) {
	    gv_efullname4(TARG, PL_defoutgv, NULL, TRUE);
	    XPUSHTARG;
    }
    else {
	    mXPUSHs(newRV(MUTABLE_SV(egv)));
    }

    if (newdefout) {
	if (!GvIO(newdefout))
	    gv_IOadd(newdefout);
	setdefout(newdefout);
    }

    RETURN;
}

PP(pp_getc)
{
    dSP; dTARGET;
    GV * const gv =
	MAXARG==0 || (!TOPs && !POPs) ? PL_stdingv : MUTABLE_GV(POPs);
    IO *const io = GvIO(gv);

    if (MAXARG == 0)
	EXTEND(SP, 1);

    if (io) {
	const MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    const U8 gimme = GIMME_V;
	    Perl_tied_method(aTHX_ SV_CONST(GETC), SP, MUTABLE_SV(io), mg, gimme, 0);
	    if (gimme == G_SCALAR) {
		SPAGAIN;
		SvSetMagicSV_nosteal(TARG, TOPs);
	    }
	    return NORMAL;
	}
    }
    if (!gv || do_eof(gv)) { /* make sure we have fp with something */
	if (!io || (!IoIFP(io) && IoTYPE(io) != IoTYPE_WRONLY))
	    report_evil_fh(gv);
	SETERRNO(EBADF,RMS_IFI);
	RETPUSHUNDEF;
    }
    TAINT;
    sv_setpvs(TARG, " ");
    *SvPVX(TARG) = PerlIO_getc(IoIFP(GvIOp(gv))); /* should never be EOF */
    if (PerlIO_isutf8(IoIFP(GvIOp(gv)))) {
	/* Find out how many bytes the char needs */
	Size_t len = UTF8SKIP(SvPVX_const(TARG));
	if (len > 1) {
	    SvGROW(TARG,len+1);
	    len = PerlIO_read(IoIFP(GvIOp(gv)),SvPVX(TARG)+1,len-1);
	    SvCUR_set(TARG,1+len);
	}
	SvUTF8_on(TARG);
    }
    else SvUTF8_off(TARG);
    PUSHTARG;
    RETURN;
}

STATIC OP *
S_doform(pTHX_ CV *cv, GV *gv, OP *retop)
{
    PERL_CONTEXT *cx;
    const U8 gimme = GIMME_V;

    PERL_ARGS_ASSERT_DOFORM;

    if (CvCLONE(cv))
	cv = MUTABLE_CV(sv_2mortal(MUTABLE_SV(cv_clone(cv))));

    cx = cx_pushblock(CXt_FORMAT, gimme, PL_stack_sp, PL_savestack_ix);
    cx_pushformat(cx, cv, retop, gv);
    if (CvDEPTH(cv) >= 2)
	pad_push(CvPADLIST(cv), CvDEPTH(cv));
    PAD_SET_CUR_NOSAVE(CvPADLIST(cv), CvDEPTH(cv));

    setdefout(gv);	    /* locally select filehandle so $% et al work */
    return CvSTART(cv);
}

PP(pp_enterwrite)
{
    dSP;
    GV *gv;
    IO *io;
    GV *fgv;
    CV *cv = NULL;
    SV *tmpsv = NULL;

    if (MAXARG == 0) {
	EXTEND(SP, 1);
	gv = PL_defoutgv;
    }
    else {
	gv = MUTABLE_GV(POPs);
	if (!gv)
	    gv = PL_defoutgv;
    }
    io = GvIO(gv);
    if (!io) {
	RETPUSHNO;
    }
    if (IoFMT_GV(io))
	fgv = IoFMT_GV(io);
    else
	fgv = gv;

    assert(fgv);

    cv = GvFORM(fgv);
    if (!cv) {
	tmpsv = sv_newmortal();
	gv_efullname4(tmpsv, fgv, NULL, FALSE);
	DIE(aTHX_ "Undefined format \"%"SVf"\" called", SVfARG(tmpsv));
    }
    IoFLAGS(io) &= ~IOf_DIDTOP;
    RETURNOP(doform(cv,gv,PL_op->op_next));
}

PP(pp_leavewrite)
{
    dSP;
    GV * const gv = CX_CUR()->blk_format.gv;
    IO * const io = GvIOp(gv);
    PerlIO *ofp;
    PerlIO *fp;
    PERL_CONTEXT *cx;
    OP *retop;
    bool is_return = cBOOL(PL_op->op_type == OP_RETURN);

    if (is_return || !io || !(ofp = IoOFP(io)))
        goto forget_top;

    DEBUG_f(PerlIO_printf(Perl_debug_log, "left=%ld, todo=%ld\n",
	  (long)IoLINES_LEFT(io), (long)FmLINES(PL_formtarget)));

    if (IoLINES_LEFT(io) < FmLINES(PL_formtarget) &&
	PL_formtarget != PL_toptarget)
    {
	GV *fgv;
	CV *cv;
	if (!IoTOP_GV(io)) {
	    GV *topgv;

	    if (!IoTOP_NAME(io)) {
		SV *topname;
		if (!IoFMT_NAME(io))
		    IoFMT_NAME(io) = savepv(GvNAME(gv));
		topname = sv_2mortal(Perl_newSVpvf(aTHX_ "%"HEKf"_TOP",
                                        HEKfARG(GvNAME_HEK(gv))));
		topgv = gv_fetchsv(topname, 0, SVt_PVFM);
		if ((topgv && GvFORM(topgv)) ||
		  !gv_fetchpvs("top", GV_NOTQUAL, SVt_PVFM))
		    IoTOP_NAME(io) = savesvpv(topname);
		else
		    IoTOP_NAME(io) = savepvs("top");
	    }
	    topgv = gv_fetchpv(IoTOP_NAME(io), 0, SVt_PVFM);
	    if (!topgv || !GvFORM(topgv)) {
		IoLINES_LEFT(io) = IoPAGE_LEN(io);
		goto forget_top;
	    }
	    IoTOP_GV(io) = topgv;
	}
	if (IoFLAGS(io) & IOf_DIDTOP) {	/* Oh dear.  It still doesn't fit. */
	    I32 lines = IoLINES_LEFT(io);
	    const char *s = SvPVX_const(PL_formtarget);
	    if (lines <= 0)		/* Yow, header didn't even fit!!! */
		goto forget_top;
	    while (lines-- > 0) {
		s = strchr(s, '\n');
		if (!s)
		    break;
		s++;
	    }
	    if (s) {
		const STRLEN save = SvCUR(PL_formtarget);
		SvCUR_set(PL_formtarget, s - SvPVX_const(PL_formtarget));
		do_print(PL_formtarget, ofp);
		SvCUR_set(PL_formtarget, save);
		sv_chop(PL_formtarget, s);
		FmLINES(PL_formtarget) -= IoLINES_LEFT(io);
	    }
	}
	if (IoLINES_LEFT(io) >= 0 && IoPAGE(io) > 0)
	    do_print(GvSV(gv_fetchpvs("\f", GV_ADD, SVt_PV)), ofp);
	IoLINES_LEFT(io) = IoPAGE_LEN(io);
	IoPAGE(io)++;
	PL_formtarget = PL_toptarget;
	IoFLAGS(io) |= IOf_DIDTOP;
	fgv = IoTOP_GV(io);
	assert(fgv); /* IoTOP_GV(io) should have been set above */
	cv = GvFORM(fgv);
	if (!cv) {
	    SV * const sv = sv_newmortal();
	    gv_efullname4(sv, fgv, NULL, FALSE);
	    DIE(aTHX_ "Undefined top format \"%"SVf"\" called", SVfARG(sv));
	}
	return doform(cv, gv, PL_op);
    }

  forget_top:
    cx = CX_CUR();
    assert(CxTYPE(cx) == CXt_FORMAT);
    SP = PL_stack_base + cx->blk_oldsp; /* ignore retval of formline */
    CX_LEAVE_SCOPE(cx);
    cx_popformat(cx);
    cx_popblock(cx);
    retop = cx->blk_sub.retop;
    CX_POP(cx);

    if (is_return)
        /* XXX the semantics of doing 'return' in a format aren't documented.
         * Currently we ignore any args to 'return' and just return
         * a single undef in both scalar and list contexts
         */
	PUSHs(&PL_sv_undef);
    else if (!io || !(fp = IoOFP(io))) {
	if (io && IoIFP(io))
	    report_wrongway_fh(gv, '<');
	else
	    report_evil_fh(gv);
	PUSHs(&PL_sv_no);
    }
    else {
	if ((IoLINES_LEFT(io) -= FmLINES(PL_formtarget)) < 0) {
	    Perl_ck_warner(aTHX_ packWARN(WARN_IO), "page overflow");
	}
	if (!do_print(PL_formtarget, fp))
	    PUSHs(&PL_sv_no);
	else {
	    FmLINES(PL_formtarget) = 0;
	    SvCUR_set(PL_formtarget, 0);
	    *SvEND(PL_formtarget) = '\0';
	    if (IoFLAGS(io) & IOf_FLUSH)
		(void)PerlIO_flush(fp);
	    PUSHs(&PL_sv_yes);
	}
    }
    PL_formtarget = PL_bodytarget;
    RETURNOP(retop);
}

PP(pp_prtf)
{
    dSP; dMARK; dORIGMARK;
    PerlIO *fp;

    GV * const gv
	= (PL_op->op_flags & OPf_STACKED) ? MUTABLE_GV(*++MARK) : PL_defoutgv;
    IO *const io = GvIO(gv);

    /* Treat empty list as "" */
    if (MARK == SP) XPUSHs(&PL_sv_no);

    if (io) {
	const MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    if (MARK == ORIGMARK) {
		MEXTEND(SP, 1);
		++MARK;
		Move(MARK, MARK + 1, (SP - MARK) + 1, SV*);
		++SP;
	    }
	    return Perl_tied_method(aTHX_ SV_CONST(PRINTF), mark - 1, MUTABLE_SV(io),
				    mg,
				    G_SCALAR | TIED_METHOD_ARGUMENTS_ON_STACK,
				    sp - mark);
	}
    }

    if (!io) {
	report_evil_fh(gv);
	SETERRNO(EBADF,RMS_IFI);
	goto just_say_no;
    }
    else if (!(fp = IoOFP(io))) {
	if (IoIFP(io))
	    report_wrongway_fh(gv, '<');
	else if (ckWARN(WARN_CLOSED))
	    report_evil_fh(gv);
	SETERRNO(EBADF,IoIFP(io)?RMS_FAC:RMS_IFI);
	goto just_say_no;
    }
    else {
	SV *sv = sv_newmortal();
	do_sprintf(sv, SP - MARK, MARK + 1);
	if (!do_print(sv, fp))
	    goto just_say_no;

	if (IoFLAGS(io) & IOf_FLUSH)
	    if (PerlIO_flush(fp) == EOF)
		goto just_say_no;
    }
    SP = ORIGMARK;
    PUSHs(&PL_sv_yes);
    RETURN;

  just_say_no:
    SP = ORIGMARK;
    PUSHs(&PL_sv_undef);
    RETURN;
}

PP(pp_sysopen)
{
    dSP;
    const int perm = (MAXARG > 3 && (TOPs || POPs)) ? POPi : 0666;
    const int mode = POPi;
    SV * const sv = POPs;
    GV * const gv = MUTABLE_GV(POPs);
    STRLEN len;

    /* Need TIEHANDLE method ? */
    const char * const tmps = SvPV_const(sv, len);
    if (do_open_raw(gv, tmps, len, mode, perm)) {
	IoLINES(GvIOp(gv)) = 0;
	PUSHs(&PL_sv_yes);
    }
    else {
	PUSHs(&PL_sv_undef);
    }
    RETURN;
}


/* also used for: pp_read() and pp_recv() (where supported) */

PP(pp_sysread)
{
    dSP; dMARK; dORIGMARK; dTARGET;
    SSize_t offset;
    IO *io;
    char *buffer;
    STRLEN orig_size;
    SSize_t length;
    SSize_t count;
    SV *bufsv;
    STRLEN blen;
    int fp_utf8;
    int buffer_utf8;
    SV *read_target;
    Size_t got = 0;
    Size_t wanted;
    bool charstart = FALSE;
    STRLEN charskip = 0;
    STRLEN skip = 0;
    GV * const gv = MUTABLE_GV(*++MARK);
    int fd;

    if ((PL_op->op_type == OP_READ || PL_op->op_type == OP_SYSREAD)
	&& gv && (io = GvIO(gv)) )
    {
	const MAGIC *const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    return Perl_tied_method(aTHX_ SV_CONST(READ), mark - 1, MUTABLE_SV(io), mg,
				    G_SCALAR | TIED_METHOD_ARGUMENTS_ON_STACK,
				    sp - mark);
	}
    }

    if (!gv)
	goto say_undef;
    bufsv = *++MARK;
    if (! SvOK(bufsv))
	sv_setpvs(bufsv, "");
    length = SvIVx(*++MARK);
    if (length < 0)
	DIE(aTHX_ "Negative length");
    SETERRNO(0,0);
    if (MARK < SP)
	offset = SvIVx(*++MARK);
    else
	offset = 0;
    io = GvIO(gv);
    if (!io || !IoIFP(io)) {
	report_evil_fh(gv);
	SETERRNO(EBADF,RMS_IFI);
	goto say_undef;
    }

    /* Note that fd can here validly be -1, don't check it yet. */
    fd = PerlIO_fileno(IoIFP(io));

    if ((fp_utf8 = PerlIO_isutf8(IoIFP(io))) && !IN_BYTES) {
        if (PL_op->op_type == OP_SYSREAD || PL_op->op_type == OP_RECV) {
            Perl_ck_warner(aTHX_ packWARN(WARN_DEPRECATED),
                           "%s() is deprecated on :utf8 handles",
                           OP_DESC(PL_op));
        }
	buffer = SvPVutf8_force(bufsv, blen);
	/* UTF-8 may not have been set if they are all low bytes */
	SvUTF8_on(bufsv);
	buffer_utf8 = 0;
    }
    else {
	buffer = SvPV_force(bufsv, blen);
	buffer_utf8 = !IN_BYTES && SvUTF8(bufsv);
    }
    if (DO_UTF8(bufsv)) {
	blen = sv_len_utf8_nomg(bufsv);
    }

    charstart = TRUE;
    charskip  = 0;
    skip = 0;
    wanted = length;

#ifdef HAS_SOCKET
    if (PL_op->op_type == OP_RECV) {
	Sock_size_t bufsize;
	char namebuf[MAXPATHLEN];
        if (fd < 0) {
            SETERRNO(EBADF,SS_IVCHAN);
            RETPUSHUNDEF;
        }
#if (defined(VMS_DO_SOCKETS) && defined(DECCRTL_SOCKETS)) || defined(__QNXNTO__)
	bufsize = sizeof (struct sockaddr_in);
#else
	bufsize = sizeof namebuf;
#endif
#ifdef OS2	/* At least Warp3+IAK: only the first byte of bufsize set */
	if (bufsize >= 256)
	    bufsize = 255;
#endif
	buffer = SvGROW(bufsv, (STRLEN)(length+1));
	/* 'offset' means 'flags' here */
	count = PerlSock_recvfrom(fd, buffer, length, offset,
				  (struct sockaddr *)namebuf, &bufsize);
	if (count < 0)
	    RETPUSHUNDEF;
	/* MSG_TRUNC can give oversized count; quietly lose it */
	if (count > length)
	    count = length;
	SvCUR_set(bufsv, count);
	*SvEND(bufsv) = '\0';
	(void)SvPOK_only(bufsv);
	if (fp_utf8)
	    SvUTF8_on(bufsv);
	SvSETMAGIC(bufsv);
	/* This should not be marked tainted if the fp is marked clean */
	if (!(IoFLAGS(io) & IOf_UNTAINT))
	    SvTAINTED_on(bufsv);
	SP = ORIGMARK;
#if defined(__CYGWIN__)
        /* recvfrom() on cygwin doesn't set bufsize at all for
           connected sockets, leaving us with trash in the returned
           name, so use the same test as the Win32 code to check if it
           wasn't set, and set it [perl #118843] */
        if (bufsize == sizeof namebuf)
            bufsize = 0;
#endif
	sv_setpvn(TARG, namebuf, bufsize);
	PUSHs(TARG);
	RETURN;
    }
#endif
    if (offset < 0) {
	if (-offset > (SSize_t)blen)
	    DIE(aTHX_ "Offset outside string");
	offset += blen;
    }
    if (DO_UTF8(bufsv)) {
	/* convert offset-as-chars to offset-as-bytes */
	if (offset >= (SSize_t)blen)
	    offset += SvCUR(bufsv) - blen;
	else
	    offset = utf8_hop((U8 *)buffer,offset) - (U8 *) buffer;
    }

 more_bytes:
    /* Reestablish the fd in case it shifted from underneath us. */
    fd = PerlIO_fileno(IoIFP(io));

    orig_size = SvCUR(bufsv);
    /* Allocating length + offset + 1 isn't perfect in the case of reading
       bytes from a byte file handle into a UTF8 buffer, but it won't harm us
       unduly.
       (should be 2 * length + offset + 1, or possibly something longer if
       IN_ENCODING Is true) */
    buffer  = SvGROW(bufsv, (STRLEN)(length+offset+1));
    if (offset > 0 && offset > (SSize_t)orig_size) { /* Zero any newly allocated space */
    	Zero(buffer+orig_size, offset-orig_size, char);
    }
    buffer = buffer + offset;
    if (!buffer_utf8) {
	read_target = bufsv;
    } else {
	/* Best to read the bytes into a new SV, upgrade that to UTF8, then
	   concatenate it to the current buffer.  */

	/* Truncate the existing buffer to the start of where we will be
	   reading to:  */
	SvCUR_set(bufsv, offset);

	read_target = sv_newmortal();
	SvUPGRADE(read_target, SVt_PV);
	buffer = SvGROW(read_target, (STRLEN)(length + 1));
    }

    if (PL_op->op_type == OP_SYSREAD) {
#ifdef PERL_SOCK_SYSREAD_IS_RECV
	if (IoTYPE(io) == IoTYPE_SOCKET) {
            if (fd < 0) {
                SETERRNO(EBADF,SS_IVCHAN);
                count = -1;
            }
            else
                count = PerlSock_recv(fd, buffer, length, 0);
	}
	else
#endif
	{
            if (fd < 0) {
                SETERRNO(EBADF,RMS_IFI);
                count = -1;
            }
            else
                count = PerlLIO_read(fd, buffer, length);
	}
    }
    else
    {
	count = PerlIO_read(IoIFP(io), buffer, length);
	/* PerlIO_read() - like fread() returns 0 on both error and EOF */
	if (count == 0 && PerlIO_error(IoIFP(io)))
	    count = -1;
    }
    if (count < 0) {
	if (IoTYPE(io) == IoTYPE_WRONLY)
	    report_wrongway_fh(gv, '>');
	goto say_undef;
    }
    SvCUR_set(read_target, count+(buffer - SvPVX_const(read_target)));
    *SvEND(read_target) = '\0';
    (void)SvPOK_only(read_target);
    if (fp_utf8 && !IN_BYTES) {
	/* Look at utf8 we got back and count the characters */
	const char *bend = buffer + count;
	while (buffer < bend) {
	    if (charstart) {
	        skip = UTF8SKIP(buffer);
		charskip = 0;
	    }
	    if (buffer - charskip + skip > bend) {
		/* partial character - try for rest of it */
		length = skip - (bend-buffer);
		offset = bend - SvPVX_const(bufsv);
		charstart = FALSE;
		charskip += count;
		goto more_bytes;
	    }
	    else {
		got++;
		buffer += skip;
		charstart = TRUE;
		charskip  = 0;
	    }
        }
	/* If we have not 'got' the number of _characters_ we 'wanted' get some more
	   provided amount read (count) was what was requested (length)
	 */
	if (got < wanted && count == length) {
	    length = wanted - got;
	    offset = bend - SvPVX_const(bufsv);
	    goto more_bytes;
	}
	/* return value is character count */
	count = got;
	SvUTF8_on(bufsv);
    }
    else if (buffer_utf8) {
	/* Let svcatsv upgrade the bytes we read in to utf8.
	   The buffer is a mortal so will be freed soon.  */
	sv_catsv_nomg(bufsv, read_target);
    }
    SvSETMAGIC(bufsv);
    /* This should not be marked tainted if the fp is marked clean */
    if (!(IoFLAGS(io) & IOf_UNTAINT))
	SvTAINTED_on(bufsv);
    SP = ORIGMARK;
    PUSHi(count);
    RETURN;

  say_undef:
    SP = ORIGMARK;
    RETPUSHUNDEF;
}


/* also used for: pp_send() where defined */

PP(pp_syswrite)
{
    dSP; dMARK; dORIGMARK; dTARGET;
    SV *bufsv;
    const char *buffer;
    SSize_t retval;
    STRLEN blen;
    STRLEN orig_blen_bytes;
    const int op_type = PL_op->op_type;
    bool doing_utf8;
    U8 *tmpbuf = NULL;
    GV *const gv = MUTABLE_GV(*++MARK);
    IO *const io = GvIO(gv);
    int fd;

    if (op_type == OP_SYSWRITE && io) {
	const MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    if (MARK == SP - 1) {
		SV *sv = *SP;
		mXPUSHi(sv_len(sv));
		PUTBACK;
	    }

	    return Perl_tied_method(aTHX_ SV_CONST(WRITE), mark - 1, MUTABLE_SV(io), mg,
				    G_SCALAR | TIED_METHOD_ARGUMENTS_ON_STACK,
				    sp - mark);
	}
    }
    if (!gv)
	goto say_undef;

    bufsv = *++MARK;

    SETERRNO(0,0);
    if (!io || !IoIFP(io) || IoTYPE(io) == IoTYPE_RDONLY) {
	retval = -1;
	if (io && IoIFP(io))
	    report_wrongway_fh(gv, '<');
	else
	    report_evil_fh(gv);
	SETERRNO(EBADF,RMS_IFI);
	goto say_undef;
    }
    fd = PerlIO_fileno(IoIFP(io));
    if (fd < 0) {
        SETERRNO(EBADF,SS_IVCHAN);
        retval = -1;
        goto say_undef;
    }

    /* Do this first to trigger any overloading.  */
    buffer = SvPV_const(bufsv, blen);
    orig_blen_bytes = blen;
    doing_utf8 = DO_UTF8(bufsv);

    if (PerlIO_isutf8(IoIFP(io))) {
        Perl_ck_warner(aTHX_ packWARN(WARN_DEPRECATED),
                       "%s() is deprecated on :utf8 handles",
                       OP_DESC(PL_op));
	if (!SvUTF8(bufsv)) {
	    /* We don't modify the original scalar.  */
	    tmpbuf = bytes_to_utf8((const U8*) buffer, &blen);
	    buffer = (char *) tmpbuf;
	    doing_utf8 = TRUE;
	}
    }
    else if (doing_utf8) {
	STRLEN tmplen = blen;
	U8 * const result = bytes_from_utf8((const U8*) buffer, &tmplen, &doing_utf8);
	if (!doing_utf8) {
	    tmpbuf = result;
	    buffer = (char *) tmpbuf;
	    blen = tmplen;
	}
	else {
	    assert((char *)result == buffer);
	    Perl_croak(aTHX_ "Wide character in %s", OP_DESC(PL_op));
	}
    }

#ifdef HAS_SOCKET
    if (op_type == OP_SEND) {
	const int flags = SvIVx(*++MARK);
	if (SP > MARK) {
	    STRLEN mlen;
	    char * const sockbuf = SvPVx(*++MARK, mlen);
	    retval = PerlSock_sendto(fd, buffer, blen,
				     flags, (struct sockaddr *)sockbuf, mlen);
	}
	else {
	    retval = PerlSock_send(fd, buffer, blen, flags);
	}
    }
    else
#endif
    {
	Size_t length = 0; /* This length is in characters.  */
	STRLEN blen_chars;
	IV offset;

	if (doing_utf8) {
	    if (tmpbuf) {
		/* The SV is bytes, and we've had to upgrade it.  */
		blen_chars = orig_blen_bytes;
	    } else {
		/* The SV really is UTF-8.  */
		/* Don't call sv_len_utf8 on a magical or overloaded
		   scalar, as we might get back a different result.  */
		blen_chars = sv_or_pv_len_utf8(bufsv, buffer, blen);
	    }
	} else {
	    blen_chars = blen;
	}

	if (MARK >= SP) {
	    length = blen_chars;
	} else {
#if Size_t_size > IVSIZE
	    length = (Size_t)SvNVx(*++MARK);
#else
	    length = (Size_t)SvIVx(*++MARK);
#endif
	    if ((SSize_t)length < 0) {
		Safefree(tmpbuf);
		DIE(aTHX_ "Negative length");
	    }
	}

	if (MARK < SP) {
	    offset = SvIVx(*++MARK);
	    if (offset < 0) {
		if (-offset > (IV)blen_chars) {
		    Safefree(tmpbuf);
		    DIE(aTHX_ "Offset outside string");
		}
		offset += blen_chars;
	    } else if (offset > (IV)blen_chars) {
		Safefree(tmpbuf);
		DIE(aTHX_ "Offset outside string");
	    }
	} else
	    offset = 0;
	if (length > blen_chars - offset)
	    length = blen_chars - offset;
	if (doing_utf8) {
	    /* Here we convert length from characters to bytes.  */
	    if (tmpbuf || SvGMAGICAL(bufsv) || SvAMAGIC(bufsv)) {
		/* Either we had to convert the SV, or the SV is magical, or
		   the SV has overloading, in which case we can't or mustn't
		   or mustn't call it again.  */

		buffer = (const char*)utf8_hop((const U8 *)buffer, offset);
		length = utf8_hop((U8 *)buffer, length) - (U8 *)buffer;
	    } else {
		/* It's a real UTF-8 SV, and it's not going to change under
		   us.  Take advantage of any cache.  */
		I32 start = offset;
		I32 len_I32 = length;

		/* Convert the start and end character positions to bytes.
		   Remember that the second argument to sv_pos_u2b is relative
		   to the first.  */
		sv_pos_u2b(bufsv, &start, &len_I32);

		buffer += start;
		length = len_I32;
	    }
	}
	else {
	    buffer = buffer+offset;
	}
#ifdef PERL_SOCK_SYSWRITE_IS_SEND
	if (IoTYPE(io) == IoTYPE_SOCKET) {
	    retval = PerlSock_send(fd, buffer, length, 0);
	}
	else
#endif
	{
	    /* See the note at doio.c:do_print about filesize limits. --jhi */
            retval = PerlLIO_write(fd, buffer, length);
	}
    }

    if (retval < 0)
	goto say_undef;
    SP = ORIGMARK;
    if (doing_utf8)
        retval = utf8_length((U8*)buffer, (U8*)buffer + retval);

    Safefree(tmpbuf);
#if Size_t_size > IVSIZE
    PUSHn(retval);
#else
    PUSHi(retval);
#endif
    RETURN;

  say_undef:
    Safefree(tmpbuf);
    SP = ORIGMARK;
    RETPUSHUNDEF;
}

PP(pp_eof)
{
    dSP;
    GV *gv;
    IO *io;
    const MAGIC *mg;
    /*
     * in Perl 5.12 and later, the additional parameter is a bitmask:
     * 0 = eof
     * 1 = eof(FH)
     * 2 = eof()  <- ARGV magic
     *
     * I'll rely on the compiler's trace flow analysis to decide whether to
     * actually assign this out here, or punt it into the only block where it is
     * used. Doing it out here is DRY on the condition logic.
     */
    unsigned int which;

    if (MAXARG) {
	gv = PL_last_in_gv = MUTABLE_GV(POPs);	/* eof(FH) */
	which = 1;
    }
    else {
	EXTEND(SP, 1);

	if (PL_op->op_flags & OPf_SPECIAL) {
	    gv = PL_last_in_gv = GvEGVx(PL_argvgv);	/* eof() - ARGV magic */
	    which = 2;
	}
	else {
	    gv = PL_last_in_gv;			/* eof */
	    which = 0;
	}
    }

    if (!gv)
	RETPUSHNO;

    if ((io = GvIO(gv)) && (mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar))) {
	return tied_method1(SV_CONST(EOF), SP, MUTABLE_SV(io), mg, newSVuv(which));
    }

    if (!MAXARG && (PL_op->op_flags & OPf_SPECIAL)) {	/* eof() */
	if (io && !IoIFP(io)) {
	    if ((IoFLAGS(io) & IOf_START) && av_tindex(GvAVn(gv)) < 0) {
		SV ** svp;
		IoLINES(io) = 0;
		IoFLAGS(io) &= ~IOf_START;
		do_open6(gv, "-", 1, NULL, NULL, 0);
		svp = &GvSV(gv);
		if (*svp) {
		    SV * sv = *svp;
		    sv_setpvs(sv, "-");
		    SvSETMAGIC(sv);
		}
		else
		    *svp = newSVpvs("-");
	    }
	    else if (!nextargv(gv, FALSE))
		RETPUSHYES;
	}
    }

    PUSHs(boolSV(do_eof(gv)));
    RETURN;
}

PP(pp_tell)
{
    dSP; dTARGET;
    GV *gv;
    IO *io;

    if (MAXARG != 0 && (TOPs || POPs))
	PL_last_in_gv = MUTABLE_GV(POPs);
    else
	EXTEND(SP, 1);
    gv = PL_last_in_gv;

    io = GvIO(gv);
    if (io) {
	const MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    return tied_method0(SV_CONST(TELL), SP, MUTABLE_SV(io), mg);
	}
    }
    else if (!gv) {
	if (!errno)
	    SETERRNO(EBADF,RMS_IFI);
	PUSHi(-1);
	RETURN;
    }

#if LSEEKSIZE > IVSIZE
    PUSHn( do_tell(gv) );
#else
    PUSHi( do_tell(gv) );
#endif
    RETURN;
}


/* also used for: pp_seek() */

PP(pp_sysseek)
{
    dSP;
    const int whence = POPi;
#if LSEEKSIZE > IVSIZE
    const Off_t offset = (Off_t)SvNVx(POPs);
#else
    const Off_t offset = (Off_t)SvIVx(POPs);
#endif

    GV * const gv = PL_last_in_gv = MUTABLE_GV(POPs);
    IO *const io = GvIO(gv);

    if (io) {
	const MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
	if (mg) {
#if LSEEKSIZE > IVSIZE
	    SV *const offset_sv = newSVnv((NV) offset);
#else
	    SV *const offset_sv = newSViv(offset);
#endif

	    return tied_method2(SV_CONST(SEEK), SP, MUTABLE_SV(io), mg, offset_sv,
				newSViv(whence));
	}
    }

    if (PL_op->op_type == OP_SEEK)
	PUSHs(boolSV(do_seek(gv, offset, whence)));
    else {
	const Off_t sought = do_sysseek(gv, offset, whence);
        if (sought < 0)
            PUSHs(&PL_sv_undef);
        else {
            SV* const sv = sought ?
#if LSEEKSIZE > IVSIZE
                newSVnv((NV)sought)
#else
                newSViv(sought)
#endif
                : newSVpvn(zero_but_true, ZBTLEN);
            mPUSHs(sv);
        }
    }
    RETURN;
}

PP(pp_truncate)
{
    dSP;
    /* There seems to be no consensus on the length type of truncate()
     * and ftruncate(), both off_t and size_t have supporters. In
     * general one would think that when using large files, off_t is
     * at least as wide as size_t, so using an off_t should be okay. */
    /* XXX Configure probe for the length type of *truncate() needed XXX */
    Off_t len;

#if Off_t_size > IVSIZE
    len = (Off_t)POPn;
#else
    len = (Off_t)POPi;
#endif
    /* Checking for length < 0 is problematic as the type might or
     * might not be signed: if it is not, clever compilers will moan. */
    /* XXX Configure probe for the signedness of the length type of *truncate() needed? XXX */
    SETERRNO(0,0);
    {
	SV * const sv = POPs;
	int result = 1;
	GV *tmpgv;
	IO *io;

	if (PL_op->op_flags & OPf_SPECIAL
	               ? (tmpgv = gv_fetchsv(sv, 0, SVt_PVIO), 1)
	               : !!(tmpgv = MAYBE_DEREF_GV(sv)) ) {
	    io = GvIO(tmpgv);
	    if (!io)
		result = 0;
	    else {
		PerlIO *fp;
	    do_ftruncate_io:
		TAINT_PROPER("truncate");
		if (!(fp = IoIFP(io))) {
		    result = 0;
		}
		else {
                    int fd = PerlIO_fileno(fp);
                    if (fd < 0) {
                        SETERRNO(EBADF,RMS_IFI);
                        result = 0;
                    } else {
                        if (len < 0) {
                            SETERRNO(EINVAL, LIB_INVARG);
                            result = 0;
                        } else {
                           PerlIO_flush(fp);
#ifdef HAS_TRUNCATE
                           if (ftruncate(fd, len) < 0)
#else
                           if (my_chsize(fd, len) < 0)
#endif
                               result = 0;
                        }
                    }
		}
	    }
	}
	else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVIO) {
		io = MUTABLE_IO(SvRV(sv)); /* *main::FRED{IO} for example */
		goto do_ftruncate_io;
	}
	else {
	    const char * const name = SvPV_nomg_const_nolen(sv);
	    TAINT_PROPER("truncate");
#ifdef HAS_TRUNCATE
	    if (truncate(name, len) < 0)
	        result = 0;
#else
	    {
                int mode = O_RDWR;
                int tmpfd;

#if defined(USE_64_BIT_RAWIO) && defined(O_LARGEFILE)
                mode |= O_LARGEFILE;	/* Transparently largefiley. */
#endif
#ifdef O_BINARY
                /* On open(), the Win32 CRT tries to seek around text
                 * files using 32-bit offsets, which causes the open()
                 * to fail on large files, so open in binary mode.
                 */
                mode |= O_BINARY;
#endif
                tmpfd = PerlLIO_open(name, mode);

		if (tmpfd < 0) {
		    result = 0;
		} else {
		    if (my_chsize(tmpfd, len) < 0)
		        result = 0;
		    PerlLIO_close(tmpfd);
		}
	    }
#endif
	}

	if (result)
	    RETPUSHYES;
	if (!errno)
	    SETERRNO(EBADF,RMS_IFI);
	RETPUSHUNDEF;
    }
}


/* also used for: pp_fcntl() */

PP(pp_ioctl)
{
    dSP; dTARGET;
    SV * const argsv = POPs;
    const unsigned int func = POPu;
    int optype;
    GV * const gv = MUTABLE_GV(POPs);
    IO * const io = GvIOn(gv);
    char *s;
    IV retval;

    if (!IoIFP(io)) {
	report_evil_fh(gv);
	SETERRNO(EBADF,RMS_IFI);	/* well, sort of... */
	RETPUSHUNDEF;
    }

    if (SvPOK(argsv) || !SvNIOK(argsv)) {
	STRLEN len;
	STRLEN need;
	s = SvPV_force(argsv, len);
	need = IOCPARM_LEN(func);
	if (len < need) {
	    s = Sv_Grow(argsv, need + 1);
	    SvCUR_set(argsv, need);
	}

	s[SvCUR(argsv)] = 17;	/* a little sanity check here */
    }
    else {
	retval = SvIV(argsv);
	s = INT2PTR(char*,retval);		/* ouch */
    }

    optype = PL_op->op_type;
    TAINT_PROPER(PL_op_desc[optype]);

    if (optype == OP_IOCTL)
#ifdef HAS_IOCTL
	retval = PerlLIO_ioctl(PerlIO_fileno(IoIFP(io)), func, s);
#else
	DIE(aTHX_ "ioctl is not implemented");
#endif
    else
#ifndef HAS_FCNTL
      DIE(aTHX_ "fcntl is not implemented");
#else
#if defined(OS2) && defined(__EMX__)
	retval = fcntl(PerlIO_fileno(IoIFP(io)), func, (int)s);
#else
	retval = fcntl(PerlIO_fileno(IoIFP(io)), func, s);
#endif
#endif

#if defined(HAS_IOCTL) || defined(HAS_FCNTL)
    if (SvPOK(argsv)) {
	if (s[SvCUR(argsv)] != 17)
	    DIE(aTHX_ "Possible memory corruption: %s overflowed 3rd argument",
		OP_NAME(PL_op));
	s[SvCUR(argsv)] = 0;		/* put our null back */
	SvSETMAGIC(argsv);		/* Assume it has changed */
    }

    if (retval == -1)
	RETPUSHUNDEF;
    if (retval != 0) {
	PUSHi(retval);
    }
    else {
	PUSHp(zero_but_true, ZBTLEN);
    }
#endif
    RETURN;
}

PP(pp_flock)
{
#ifdef FLOCK
    dSP; dTARGET;
    I32 value;
    const int argtype = POPi;
    GV * const gv = MUTABLE_GV(POPs);
    IO *const io = GvIO(gv);
    PerlIO *const fp = io ? IoIFP(io) : NULL;

    /* XXX Looks to me like io is always NULL at this point */
    if (fp) {
	(void)PerlIO_flush(fp);
	value = (I32)(PerlLIO_flock(PerlIO_fileno(fp), argtype) >= 0);
    }
    else {
	report_evil_fh(gv);
	value = 0;
	SETERRNO(EBADF,RMS_IFI);
    }
    PUSHi(value);
    RETURN;
#else
    DIE(aTHX_ PL_no_func, "flock");
#endif
}

/* Sockets. */

#ifdef HAS_SOCKET

PP(pp_socket)
{
    dSP;
    const int protocol = POPi;
    const int type = POPi;
    const int domain = POPi;
    GV * const gv = MUTABLE_GV(POPs);
    IO * const io = GvIOn(gv);
    int fd;

    if (IoIFP(io))
	do_close(gv, FALSE);

    TAINT_PROPER("socket");
    fd = PerlSock_socket(domain, type, protocol);
    if (fd < 0) {
        SETERRNO(EBADF,RMS_IFI);
	RETPUSHUNDEF;
    }
    IoIFP(io) = PerlIO_fdopen(fd, "r"SOCKET_OPEN_MODE);	/* stdio gets confused about sockets */
    IoOFP(io) = PerlIO_fdopen(fd, "w"SOCKET_OPEN_MODE);
    IoTYPE(io) = IoTYPE_SOCKET;
    if (!IoIFP(io) || !IoOFP(io)) {
	if (IoIFP(io)) PerlIO_close(IoIFP(io));
	if (IoOFP(io)) PerlIO_close(IoOFP(io));
	if (!IoIFP(io) && !IoOFP(io)) PerlLIO_close(fd);
	RETPUSHUNDEF;
    }
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
    /* ensure close-on-exec */
    if (fd > PL_maxsysfd && fcntl(fd, F_SETFD, FD_CLOEXEC) < 0)
	RETPUSHUNDEF;
#endif

    RETPUSHYES;
}
#endif

PP(pp_sockpair)
{
#if defined (HAS_SOCKETPAIR) || (defined (HAS_SOCKET) && defined(SOCK_DGRAM) && defined(AF_INET) && defined(PF_INET))
    dSP;
    int fd[2];
    const int protocol = POPi;
    const int type = POPi;
    const int domain = POPi;

    GV * const gv2 = MUTABLE_GV(POPs);
    IO * const io2 = GvIOn(gv2);
    GV * const gv1 = MUTABLE_GV(POPs);
    IO * const io1 = GvIOn(gv1);

    if (IoIFP(io1))
	do_close(gv1, FALSE);
    if (IoIFP(io2))
	do_close(gv2, FALSE);

    TAINT_PROPER("socketpair");
    if (PerlSock_socketpair(domain, type, protocol, fd) < 0)
	RETPUSHUNDEF;
    IoIFP(io1) = PerlIO_fdopen(fd[0], "r"SOCKET_OPEN_MODE);
    IoOFP(io1) = PerlIO_fdopen(fd[0], "w"SOCKET_OPEN_MODE);
    IoTYPE(io1) = IoTYPE_SOCKET;
    IoIFP(io2) = PerlIO_fdopen(fd[1], "r"SOCKET_OPEN_MODE);
    IoOFP(io2) = PerlIO_fdopen(fd[1], "w"SOCKET_OPEN_MODE);
    IoTYPE(io2) = IoTYPE_SOCKET;
    if (!IoIFP(io1) || !IoOFP(io1) || !IoIFP(io2) || !IoOFP(io2)) {
	if (IoIFP(io1)) PerlIO_close(IoIFP(io1));
	if (IoOFP(io1)) PerlIO_close(IoOFP(io1));
	if (!IoIFP(io1) && !IoOFP(io1)) PerlLIO_close(fd[0]);
	if (IoIFP(io2)) PerlIO_close(IoIFP(io2));
	if (IoOFP(io2)) PerlIO_close(IoOFP(io2));
	if (!IoIFP(io2) && !IoOFP(io2)) PerlLIO_close(fd[1]);
	RETPUSHUNDEF;
    }
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
    /* ensure close-on-exec */
    if ((fd[0] > PL_maxsysfd && fcntl(fd[0], F_SETFD, FD_CLOEXEC) < 0) ||
        (fd[1] > PL_maxsysfd && fcntl(fd[1], F_SETFD, FD_CLOEXEC) < 0))
	RETPUSHUNDEF;
#endif

    RETPUSHYES;
#else
    DIE(aTHX_ PL_no_sock_func, "socketpair");
#endif
}

#ifdef HAS_SOCKET

/* also used for: pp_connect() */

PP(pp_bind)
{
    dSP;
    SV * const addrsv = POPs;
    /* OK, so on what platform does bind modify addr?  */
    const char *addr;
    GV * const gv = MUTABLE_GV(POPs);
    IO * const io = GvIOn(gv);
    STRLEN len;
    int op_type;
    int fd;

    if (!IoIFP(io))
	goto nuts;
    fd = PerlIO_fileno(IoIFP(io));
    if (fd < 0)
        goto nuts;

    addr = SvPV_const(addrsv, len);
    op_type = PL_op->op_type;
    TAINT_PROPER(PL_op_desc[op_type]);
    if ((op_type == OP_BIND
	 ? PerlSock_bind(fd, (struct sockaddr *)addr, len)
	 : PerlSock_connect(fd, (struct sockaddr *)addr, len))
	>= 0)
	RETPUSHYES;
    else
	RETPUSHUNDEF;

  nuts:
    report_evil_fh(gv);
    SETERRNO(EBADF,SS_IVCHAN);
    RETPUSHUNDEF;
}

PP(pp_listen)
{
    dSP;
    const int backlog = POPi;
    GV * const gv = MUTABLE_GV(POPs);
    IO * const io = GvIOn(gv);

    if (!IoIFP(io))
	goto nuts;

    if (PerlSock_listen(PerlIO_fileno(IoIFP(io)), backlog) >= 0)
	RETPUSHYES;
    else
	RETPUSHUNDEF;

  nuts:
    report_evil_fh(gv);
    SETERRNO(EBADF,SS_IVCHAN);
    RETPUSHUNDEF;
}

PP(pp_accept)
{
    dSP; dTARGET;
    IO *nstio;
    char namebuf[MAXPATHLEN];
#if (defined(VMS_DO_SOCKETS) && defined(DECCRTL_SOCKETS)) || defined(__QNXNTO__)
    Sock_size_t len = sizeof (struct sockaddr_in);
#else
    Sock_size_t len = sizeof namebuf;
#endif
    GV * const ggv = MUTABLE_GV(POPs);
    GV * const ngv = MUTABLE_GV(POPs);
    int fd;

    IO * const gstio = GvIO(ggv);
    if (!gstio || !IoIFP(gstio))
	goto nuts;

    nstio = GvIOn(ngv);
    fd = PerlSock_accept(PerlIO_fileno(IoIFP(gstio)), (struct sockaddr *) namebuf, &len);
#if defined(OEMVS)
    if (len == 0) {
	/* Some platforms indicate zero length when an AF_UNIX client is
	 * not bound. Simulate a non-zero-length sockaddr structure in
	 * this case. */
	namebuf[0] = 0;        /* sun_len */
	namebuf[1] = AF_UNIX;  /* sun_family */
	len = 2;
    }
#endif

    if (fd < 0)
	goto badexit;
    if (IoIFP(nstio))
	do_close(ngv, FALSE);
    IoIFP(nstio) = PerlIO_fdopen(fd, "r"SOCKET_OPEN_MODE);
    IoOFP(nstio) = PerlIO_fdopen(fd, "w"SOCKET_OPEN_MODE);
    IoTYPE(nstio) = IoTYPE_SOCKET;
    if (!IoIFP(nstio) || !IoOFP(nstio)) {
	if (IoIFP(nstio)) PerlIO_close(IoIFP(nstio));
	if (IoOFP(nstio)) PerlIO_close(IoOFP(nstio));
	if (!IoIFP(nstio) && !IoOFP(nstio)) PerlLIO_close(fd);
	goto badexit;
    }
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
    /* ensure close-on-exec */
    if (fd > PL_maxsysfd && fcntl(fd, F_SETFD, FD_CLOEXEC) < 0)
        goto badexit;
#endif

#ifdef __SCO_VERSION__
    len = sizeof (struct sockaddr_in); /* OpenUNIX 8 somehow truncates info */
#endif

    PUSHp(namebuf, len);
    RETURN;

  nuts:
    report_evil_fh(ggv);
    SETERRNO(EBADF,SS_IVCHAN);

  badexit:
    RETPUSHUNDEF;

}

PP(pp_shutdown)
{
    dSP; dTARGET;
    const int how = POPi;
    GV * const gv = MUTABLE_GV(POPs);
    IO * const io = GvIOn(gv);

    if (!IoIFP(io))
	goto nuts;

    PUSHi( PerlSock_shutdown(PerlIO_fileno(IoIFP(io)), how) >= 0 );
    RETURN;

  nuts:
    report_evil_fh(gv);
    SETERRNO(EBADF,SS_IVCHAN);
    RETPUSHUNDEF;
}


/* also used for: pp_gsockopt() */

PP(pp_ssockopt)
{
    dSP;
    const int optype = PL_op->op_type;
    SV * const sv = (optype == OP_GSOCKOPT) ? sv_2mortal(newSV(257)) : POPs;
    const unsigned int optname = (unsigned int) POPi;
    const unsigned int lvl = (unsigned int) POPi;
    GV * const gv = MUTABLE_GV(POPs);
    IO * const io = GvIOn(gv);
    int fd;
    Sock_size_t len;

    if (!IoIFP(io))
	goto nuts;

    fd = PerlIO_fileno(IoIFP(io));
    if (fd < 0)
        goto nuts;
    switch (optype) {
    case OP_GSOCKOPT:
	SvGROW(sv, 257);
	(void)SvPOK_only(sv);
	SvCUR_set(sv,256);
	*SvEND(sv) ='\0';
	len = SvCUR(sv);
	if (PerlSock_getsockopt(fd, lvl, optname, SvPVX(sv), &len) < 0)
	    goto nuts2;
#if defined(_AIX)
        /* XXX Configure test: does getsockopt set the length properly? */
        if (len == 256)
            len = sizeof(int);
#endif
	SvCUR_set(sv, len);
	*SvEND(sv) ='\0';
	PUSHs(sv);
	break;
    case OP_SSOCKOPT: {
#if defined(__SYMBIAN32__)
# define SETSOCKOPT_OPTION_VALUE_T void *
#else
# define SETSOCKOPT_OPTION_VALUE_T const char *
#endif
	/* XXX TODO: We need to have a proper type (a Configure probe,
	 * etc.) for what the C headers think of the third argument of
	 * setsockopt(), the option_value read-only buffer: is it
	 * a "char *", or a "void *", const or not.  Some compilers
	 * don't take kindly to e.g. assuming that "char *" implicitly
	 * promotes to a "void *", or to explicitly promoting/demoting
	 * consts to non/vice versa.  The "const void *" is the SUS
	 * definition, but that does not fly everywhere for the above
	 * reasons. */
	    SETSOCKOPT_OPTION_VALUE_T buf;
	    int aint;
	    if (SvPOKp(sv)) {
		STRLEN l;
		buf = (SETSOCKOPT_OPTION_VALUE_T) SvPV_const(sv, l);
		len = l;
	    }
	    else {
		aint = (int)SvIV(sv);
		buf = (SETSOCKOPT_OPTION_VALUE_T) &aint;
		len = sizeof(int);
	    }
	    if (PerlSock_setsockopt(fd, lvl, optname, buf, len) < 0)
		goto nuts2;
	    PUSHs(&PL_sv_yes);
	}
	break;
    }
    RETURN;

  nuts:
    report_evil_fh(gv);
    SETERRNO(EBADF,SS_IVCHAN);
  nuts2:
    RETPUSHUNDEF;

}


/* also used for: pp_getsockname() */

PP(pp_getpeername)
{
    dSP;
    const int optype = PL_op->op_type;
    GV * const gv = MUTABLE_GV(POPs);
    IO * const io = GvIOn(gv);
    Sock_size_t len;
    SV *sv;
    int fd;

    if (!IoIFP(io))
	goto nuts;

    sv = sv_2mortal(newSV(257));
    (void)SvPOK_only(sv);
    len = 256;
    SvCUR_set(sv, len);
    *SvEND(sv) ='\0';
    fd = PerlIO_fileno(IoIFP(io));
    if (fd < 0)
        goto nuts;
    switch (optype) {
    case OP_GETSOCKNAME:
	if (PerlSock_getsockname(fd, (struct sockaddr *)SvPVX(sv), &len) < 0)
	    goto nuts2;
	break;
    case OP_GETPEERNAME:
	if (PerlSock_getpeername(fd, (struct sockaddr *)SvPVX(sv), &len) < 0)
	    goto nuts2;
#if defined(VMS_DO_SOCKETS) && defined (DECCRTL_SOCKETS)
	{
	    static const char nowhere[] = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
	    /* If the call succeeded, make sure we don't have a zeroed port/addr */
	    if (((struct sockaddr *)SvPVX_const(sv))->sa_family == AF_INET &&
		!memcmp(SvPVX_const(sv) + sizeof(u_short), nowhere,
			sizeof(u_short) + sizeof(struct in_addr))) {
		goto nuts2;	
	    }
	}
#endif
	break;
    }
#ifdef BOGUS_GETNAME_RETURN
    /* Interactive Unix, getpeername() and getsockname()
      does not return valid namelen */
    if (len == BOGUS_GETNAME_RETURN)
	len = sizeof(struct sockaddr);
#endif
    SvCUR_set(sv, len);
    *SvEND(sv) ='\0';
    PUSHs(sv);
    RETURN;

  nuts:
    report_evil_fh(gv);
    SETERRNO(EBADF,SS_IVCHAN);
  nuts2:
    RETPUSHUNDEF;
}

#endif

/* Stat calls. */

/* also used for: pp_lstat() */

PP(pp_stat)
{
    dSP;
    GV *gv = NULL;
    IO *io = NULL;
    U8 gimme;
    I32 max = 13;
    SV* sv;

    if (PL_op->op_flags & OPf_REF ? (gv = cGVOP_gv, 1)
                                  : !!(sv=POPs, gv = MAYBE_DEREF_GV(sv))) {
	if (PL_op->op_type == OP_LSTAT) {
	    if (gv != PL_defgv) {
	    do_fstat_warning_check:
		Perl_ck_warner(aTHX_ packWARN(WARN_IO),
			       "lstat() on filehandle%s%"SVf,
				gv ? " " : "",
				SVfARG(gv
                                        ? sv_2mortal(newSVhek(GvENAME_HEK(gv)))
                                        : &PL_sv_no));
	    } else if (PL_laststype != OP_LSTAT)
		/* diag_listed_as: The stat preceding %s wasn't an lstat */
		Perl_croak(aTHX_ "The stat preceding lstat() wasn't an lstat");
	}

	if (gv != PL_defgv) {
	    bool havefp;
          do_fstat_have_io:
	    havefp = FALSE;
	    PL_laststype = OP_STAT;
	    PL_statgv = gv ? gv : (GV *)io;
	    sv_setpvs(PL_statname, "");
            if(gv) {
                io = GvIO(gv);
	    }
            if (io) {
                    if (IoIFP(io)) {
                        int fd = PerlIO_fileno(IoIFP(io));
                        if (fd < 0) {
                            PL_laststatval = -1;
                            SETERRNO(EBADF,RMS_IFI);
                        } else {
                            PL_laststatval = PerlLIO_fstat(fd, &PL_statcache);
                            havefp = TRUE;
                        }
                    } else if (IoDIRP(io)) {
                        PL_laststatval =
                            PerlLIO_fstat(my_dirfd(IoDIRP(io)), &PL_statcache);
                        havefp = TRUE;
                    } else {
                        PL_laststatval = -1;
                    }
            }
	    else PL_laststatval = -1;
	    if (PL_laststatval < 0 && !havefp) report_evil_fh(gv);
        }

	if (PL_laststatval < 0) {
	    max = 0;
	}
    }
    else {
        const char *file;
	if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVIO) { 
            io = MUTABLE_IO(SvRV(sv));
            if (PL_op->op_type == OP_LSTAT)
                goto do_fstat_warning_check;
            goto do_fstat_have_io; 
        }
        
	SvTAINTED_off(PL_statname); /* previous tainting irrelevant */
	sv_setpv(PL_statname, SvPV_nomg_const_nolen(sv));
	PL_statgv = NULL;
	PL_laststype = PL_op->op_type;
        file = SvPV_nolen_const(PL_statname);
	if (PL_op->op_type == OP_LSTAT)
	    PL_laststatval = PerlLIO_lstat(file, &PL_statcache);
	else
	    PL_laststatval = PerlLIO_stat(file, &PL_statcache);
	if (PL_laststatval < 0) {
	    if (ckWARN(WARN_NEWLINE) && should_warn_nl(file)) {
                /* PL_warn_nl is constant */
                GCC_DIAG_IGNORE(-Wformat-nonliteral);
		Perl_warner(aTHX_ packWARN(WARN_NEWLINE), PL_warn_nl, "stat");
                GCC_DIAG_RESTORE;
            }
	    max = 0;
	}
    }

    gimme = GIMME_V;
    if (gimme != G_ARRAY) {
	if (gimme != G_VOID)
	    XPUSHs(boolSV(max));
	RETURN;
    }
    if (max) {
	EXTEND(SP, max);
	EXTEND_MORTAL(max);
	mPUSHi(PL_statcache.st_dev);
#if ST_INO_SIZE > IVSIZE
	mPUSHn(PL_statcache.st_ino);
#else
#   if ST_INO_SIGN <= 0
	mPUSHi(PL_statcache.st_ino);
#   else
	mPUSHu(PL_statcache.st_ino);
#   endif
#endif
	mPUSHu(PL_statcache.st_mode);
	mPUSHu(PL_statcache.st_nlink);
	
        sv_setuid(PUSHmortal, PL_statcache.st_uid);
        sv_setgid(PUSHmortal, PL_statcache.st_gid);

#ifdef USE_STAT_RDEV
	mPUSHi(PL_statcache.st_rdev);
#else
	PUSHs(newSVpvs_flags("", SVs_TEMP));
#endif
#if Off_t_size > IVSIZE
	mPUSHn(PL_statcache.st_size);
#else
	mPUSHi(PL_statcache.st_size);
#endif
#ifdef BIG_TIME
	mPUSHn(PL_statcache.st_atime);
	mPUSHn(PL_statcache.st_mtime);
	mPUSHn(PL_statcache.st_ctime);
#else
	mPUSHi(PL_statcache.st_atime);
	mPUSHi(PL_statcache.st_mtime);
	mPUSHi(PL_statcache.st_ctime);
#endif
#ifdef USE_STAT_BLOCKS
	mPUSHu(PL_statcache.st_blksize);
	mPUSHu(PL_statcache.st_blocks);
#else
	PUSHs(newSVpvs_flags("", SVs_TEMP));
	PUSHs(newSVpvs_flags("", SVs_TEMP));
#endif
    }
    RETURN;
}

/* All filetest ops avoid manipulating the perl stack pointer in their main
   bodies (since commit d2c4d2d1e22d3125), and return using either
   S_ft_return_false() or S_ft_return_true().  These two helper functions are
   the only two which manipulate the perl stack.  To ensure that no stack
   manipulation macros are used, the filetest ops avoid defining a local copy
   of the stack pointer with dSP.  */

/* If the next filetest is stacked up with this one
   (PL_op->op_private & OPpFT_STACKING), we leave
   the original argument on the stack for success,
   and skip the stacked operators on failure.
   The next few macros/functions take care of this.
*/

static OP *
S_ft_return_false(pTHX_ SV *ret) {
    OP *next = NORMAL;
    dSP;

    if (PL_op->op_flags & OPf_REF) XPUSHs(ret);
    else			   SETs(ret);
    PUTBACK;

    if (PL_op->op_private & OPpFT_STACKING) {
        while (OP_IS_FILETEST(next->op_type)
               && next->op_private & OPpFT_STACKED)
            next = next->op_next;
    }
    return next;
}

PERL_STATIC_INLINE OP *
S_ft_return_true(pTHX_ SV *ret) {
    dSP;
    if (PL_op->op_flags & OPf_REF)
        XPUSHs(PL_op->op_private & OPpFT_STACKING ? (SV *)cGVOP_gv : (ret));
    else if (!(PL_op->op_private & OPpFT_STACKING))
        SETs(ret);
    PUTBACK;
    return NORMAL;
}

#define FT_RETURNNO	return S_ft_return_false(aTHX_ &PL_sv_no)
#define FT_RETURNUNDEF	return S_ft_return_false(aTHX_ &PL_sv_undef)
#define FT_RETURNYES	return S_ft_return_true(aTHX_ &PL_sv_yes)

#define tryAMAGICftest_MG(chr) STMT_START { \
	if ( (SvFLAGS(*PL_stack_sp) & (SVf_ROK|SVs_GMG)) \
		&& PL_op->op_flags & OPf_KIDS) {     \
	    OP *next = S_try_amagic_ftest(aTHX_ chr);	\
	    if (next) return next;			  \
	}						   \
    } STMT_END

STATIC OP *
S_try_amagic_ftest(pTHX_ char chr) {
    SV *const arg = *PL_stack_sp;

    assert(chr != '?');
    if (!(PL_op->op_private & OPpFT_STACKING)) SvGETMAGIC(arg);

    if (SvAMAGIC(arg))
    {
	const char tmpchr = chr;
	SV * const tmpsv = amagic_call(arg,
				newSVpvn_flags(&tmpchr, 1, SVs_TEMP),
				ftest_amg, AMGf_unary);

	if (!tmpsv)
	    return NULL;

	return SvTRUE(tmpsv)
            ? S_ft_return_true(aTHX_ tmpsv) : S_ft_return_false(aTHX_ tmpsv);
    }
    return NULL;
}


/* also used for: pp_fteexec() pp_fteread() pp_ftewrite() pp_ftrexec()
 *                pp_ftrwrite() */

PP(pp_ftrread)
{
    I32 result;
    /* Not const, because things tweak this below. Not bool, because there's
       no guarantee that OPpFT_ACCESS is <= CHAR_MAX  */
#if defined(HAS_ACCESS) || defined (PERL_EFF_ACCESS)
    I32 use_access = PL_op->op_private & OPpFT_ACCESS;
    /* Giving some sort of initial value silences compilers.  */
#  ifdef R_OK
    int access_mode = R_OK;
#  else
    int access_mode = 0;
#  endif
#else
    /* access_mode is never used, but leaving use_access in makes the
       conditional compiling below much clearer.  */
    I32 use_access = 0;
#endif
    Mode_t stat_mode = S_IRUSR;

    bool effective = FALSE;
    char opchar = '?';

    switch (PL_op->op_type) {
    case OP_FTRREAD:	opchar = 'R'; break;
    case OP_FTRWRITE:	opchar = 'W'; break;
    case OP_FTREXEC:	opchar = 'X'; break;
    case OP_FTEREAD:	opchar = 'r'; break;
    case OP_FTEWRITE:	opchar = 'w'; break;
    case OP_FTEEXEC:	opchar = 'x'; break;
    }
    tryAMAGICftest_MG(opchar);

    switch (PL_op->op_type) {
    case OP_FTRREAD:
#if !(defined(HAS_ACCESS) && defined(R_OK))
	use_access = 0;
#endif
	break;

    case OP_FTRWRITE:
#if defined(HAS_ACCESS) && defined(W_OK)
	access_mode = W_OK;
#else
	use_access = 0;
#endif
	stat_mode = S_IWUSR;
	break;

    case OP_FTREXEC:
#if defined(HAS_ACCESS) && defined(X_OK)
	access_mode = X_OK;
#else
	use_access = 0;
#endif
	stat_mode = S_IXUSR;
	break;

    case OP_FTEWRITE:
#ifdef PERL_EFF_ACCESS
	access_mode = W_OK;
#endif
	stat_mode = S_IWUSR;
	/* FALLTHROUGH */

    case OP_FTEREAD:
#ifndef PERL_EFF_ACCESS
	use_access = 0;
#endif
	effective = TRUE;
	break;

    case OP_FTEEXEC:
#ifdef PERL_EFF_ACCESS
	access_mode = X_OK;
#else
	use_access = 0;
#endif
	stat_mode = S_IXUSR;
	effective = TRUE;
	break;
    }

    if (use_access) {
#if defined(HAS_ACCESS) || defined (PERL_EFF_ACCESS)
	const char *name = SvPV_nolen(*PL_stack_sp);
	if (effective) {
#  ifdef PERL_EFF_ACCESS
	    result = PERL_EFF_ACCESS(name, access_mode);
#  else
	    DIE(aTHX_ "panic: attempt to call PERL_EFF_ACCESS in %s",
		OP_NAME(PL_op));
#  endif
	}
	else {
#  ifdef HAS_ACCESS
	    result = access(name, access_mode);
#  else
	    DIE(aTHX_ "panic: attempt to call access() in %s", OP_NAME(PL_op));
#  endif
	}
	if (result == 0)
	    FT_RETURNYES;
	if (result < 0)
	    FT_RETURNUNDEF;
	FT_RETURNNO;
#endif
    }

    result = my_stat_flags(0);
    if (result < 0)
	FT_RETURNUNDEF;
    if (cando(stat_mode, effective, &PL_statcache))
	FT_RETURNYES;
    FT_RETURNNO;
}


/* also used for: pp_ftatime() pp_ftctime() pp_ftmtime() pp_ftsize() */

PP(pp_ftis)
{
    I32 result;
    const int op_type = PL_op->op_type;
    char opchar = '?';

    switch (op_type) {
    case OP_FTIS:	opchar = 'e'; break;
    case OP_FTSIZE:	opchar = 's'; break;
    case OP_FTMTIME:	opchar = 'M'; break;
    case OP_FTCTIME:	opchar = 'C'; break;
    case OP_FTATIME:	opchar = 'A'; break;
    }
    tryAMAGICftest_MG(opchar);

    result = my_stat_flags(0);
    if (result < 0)
	FT_RETURNUNDEF;
    if (op_type == OP_FTIS)
	FT_RETURNYES;
    {
	/* You can't dTARGET inside OP_FTIS, because you'll get
	   "panic: pad_sv po" - the op is not flagged to have a target.  */
	dTARGET;
	switch (op_type) {
	case OP_FTSIZE:
#if Off_t_size > IVSIZE
	    sv_setnv(TARG, (NV)PL_statcache.st_size);
#else
	    sv_setiv(TARG, (IV)PL_statcache.st_size);
#endif
	    break;
	case OP_FTMTIME:
	    sv_setnv(TARG,
		    ((NV)PL_basetime - PL_statcache.st_mtime) / 86400.0 );
	    break;
	case OP_FTATIME:
	    sv_setnv(TARG,
		    ((NV)PL_basetime - PL_statcache.st_atime) / 86400.0 );
	    break;
	case OP_FTCTIME:
	    sv_setnv(TARG,
		    ((NV)PL_basetime - PL_statcache.st_ctime) / 86400.0 );
	    break;
	}
	SvSETMAGIC(TARG);
	return SvTRUE_nomg(TARG)
            ? S_ft_return_true(aTHX_ TARG) : S_ft_return_false(aTHX_ TARG);
    }
}


/* also used for: pp_ftblk() pp_ftchr() pp_ftdir() pp_fteowned()
 *                pp_ftfile() pp_ftpipe() pp_ftsgid() pp_ftsock()
 *                pp_ftsuid() pp_ftsvtx() pp_ftzero() */

PP(pp_ftrowned)
{
    I32 result;
    char opchar = '?';

    switch (PL_op->op_type) {
    case OP_FTROWNED:	opchar = 'O'; break;
    case OP_FTEOWNED:	opchar = 'o'; break;
    case OP_FTZERO:	opchar = 'z'; break;
    case OP_FTSOCK:	opchar = 'S'; break;
    case OP_FTCHR:	opchar = 'c'; break;
    case OP_FTBLK:	opchar = 'b'; break;
    case OP_FTFILE:	opchar = 'f'; break;
    case OP_FTDIR:	opchar = 'd'; break;
    case OP_FTPIPE:	opchar = 'p'; break;
    case OP_FTSUID:	opchar = 'u'; break;
    case OP_FTSGID:	opchar = 'g'; break;
    case OP_FTSVTX:	opchar = 'k'; break;
    }
    tryAMAGICftest_MG(opchar);

    /* I believe that all these three are likely to be defined on most every
       system these days.  */
#ifndef S_ISUID
    if(PL_op->op_type == OP_FTSUID) {
	FT_RETURNNO;
    }
#endif
#ifndef S_ISGID
    if(PL_op->op_type == OP_FTSGID) {
	FT_RETURNNO;
    }
#endif
#ifndef S_ISVTX
    if(PL_op->op_type == OP_FTSVTX) {
	FT_RETURNNO;
    }
#endif

    result = my_stat_flags(0);
    if (result < 0)
	FT_RETURNUNDEF;
    switch (PL_op->op_type) {
    case OP_FTROWNED:
	if (PL_statcache.st_uid == PerlProc_getuid())
	    FT_RETURNYES;
	break;
    case OP_FTEOWNED:
	if (PL_statcache.st_uid == PerlProc_geteuid())
	    FT_RETURNYES;
	break;
    case OP_FTZERO:
	if (PL_statcache.st_size == 0)
	    FT_RETURNYES;
	break;
    case OP_FTSOCK:
	if (S_ISSOCK(PL_statcache.st_mode))
	    FT_RETURNYES;
	break;
    case OP_FTCHR:
	if (S_ISCHR(PL_statcache.st_mode))
	    FT_RETURNYES;
	break;
    case OP_FTBLK:
	if (S_ISBLK(PL_statcache.st_mode))
	    FT_RETURNYES;
	break;
    case OP_FTFILE:
	if (S_ISREG(PL_statcache.st_mode))
	    FT_RETURNYES;
	break;
    case OP_FTDIR:
	if (S_ISDIR(PL_statcache.st_mode))
	    FT_RETURNYES;
	break;
    case OP_FTPIPE:
	if (S_ISFIFO(PL_statcache.st_mode))
	    FT_RETURNYES;
	break;
#ifdef S_ISUID
    case OP_FTSUID:
	if (PL_statcache.st_mode & S_ISUID)
	    FT_RETURNYES;
	break;
#endif
#ifdef S_ISGID
    case OP_FTSGID:
	if (PL_statcache.st_mode & S_ISGID)
	    FT_RETURNYES;
	break;
#endif
#ifdef S_ISVTX
    case OP_FTSVTX:
	if (PL_statcache.st_mode & S_ISVTX)
	    FT_RETURNYES;
	break;
#endif
    }
    FT_RETURNNO;
}

PP(pp_ftlink)
{
    I32 result;

    tryAMAGICftest_MG('l');
    result = my_lstat_flags(0);

    if (result < 0)
	FT_RETURNUNDEF;
    if (S_ISLNK(PL_statcache.st_mode))
	FT_RETURNYES;
    FT_RETURNNO;
}

PP(pp_fttty)
{
    int fd;
    GV *gv;
    char *name = NULL;
    STRLEN namelen;
    UV uv;

    tryAMAGICftest_MG('t');

    if (PL_op->op_flags & OPf_REF)
	gv = cGVOP_gv;
    else {
      SV *tmpsv = *PL_stack_sp;
      if (!(gv = MAYBE_DEREF_GV_nomg(tmpsv))) {
	name = SvPV_nomg(tmpsv, namelen);
	gv = gv_fetchpvn_flags(name, namelen, SvUTF8(tmpsv), SVt_PVIO);
      }
    }

    if (GvIO(gv) && IoIFP(GvIOp(gv)))
	fd = PerlIO_fileno(IoIFP(GvIOp(gv)));
    else if (name && isDIGIT(*name) && grok_atoUV(name, &uv, NULL) && uv <= PERL_INT_MAX)
        fd = (int)uv;
    else
	FT_RETURNUNDEF;
    if (fd < 0) {
        SETERRNO(EBADF,RMS_IFI);
	FT_RETURNUNDEF;
    }
    if (PerlLIO_isatty(fd))
	FT_RETURNYES;
    FT_RETURNNO;
}


/* also used for: pp_ftbinary() */

PP(pp_fttext)
{
    I32 i;
    SSize_t len;
    I32 odd = 0;
    STDCHAR tbuf[512];
    STDCHAR *s;
    IO *io;
    SV *sv = NULL;
    GV *gv;
    PerlIO *fp;

    tryAMAGICftest_MG(PL_op->op_type == OP_FTTEXT ? 'T' : 'B');

    if (PL_op->op_flags & OPf_REF)
	gv = cGVOP_gv;
    else if ((PL_op->op_private & (OPpFT_STACKED|OPpFT_AFTER_t))
	     == OPpFT_STACKED)
	gv = PL_defgv;
    else {
	sv = *PL_stack_sp;
	gv = MAYBE_DEREF_GV_nomg(sv);
    }

    if (gv) {
	if (gv == PL_defgv) {
	    if (PL_statgv)
		io = SvTYPE(PL_statgv) == SVt_PVIO
		    ? (IO *)PL_statgv
		    : GvIO(PL_statgv);
	    else {
		goto really_filename;
	    }
	}
	else {
	    PL_statgv = gv;
	    sv_setpvs(PL_statname, "");
	    io = GvIO(PL_statgv);
	}
	PL_laststatval = -1;
	PL_laststype = OP_STAT;
	if (io && IoIFP(io)) {
	    int fd;
	    if (! PerlIO_has_base(IoIFP(io)))
		DIE(aTHX_ "-T and -B not implemented on filehandles");
	    fd = PerlIO_fileno(IoIFP(io));
	    if (fd < 0) {
                SETERRNO(EBADF,RMS_IFI);
		FT_RETURNUNDEF;
            }
	    PL_laststatval = PerlLIO_fstat(fd, &PL_statcache);
	    if (PL_laststatval < 0)
		FT_RETURNUNDEF;
	    if (S_ISDIR(PL_statcache.st_mode)) { /* handle NFS glitch */
		if (PL_op->op_type == OP_FTTEXT)
		    FT_RETURNNO;
		else
		    FT_RETURNYES;
            }
	    if (PerlIO_get_cnt(IoIFP(io)) <= 0) {
		i = PerlIO_getc(IoIFP(io));
		if (i != EOF)
		    (void)PerlIO_ungetc(IoIFP(io),i);
                else
                    /* null file is anything */
                    FT_RETURNYES;
	    }
	    len = PerlIO_get_bufsiz(IoIFP(io));
	    s = (STDCHAR *) PerlIO_get_base(IoIFP(io));
	    /* sfio can have large buffers - limit to 512 */
	    if (len > 512)
		len = 512;
	}
	else {
	    SETERRNO(EBADF,RMS_IFI);
	    report_evil_fh(gv);
	    SETERRNO(EBADF,RMS_IFI);
	    FT_RETURNUNDEF;
	}
    }
    else {
        const char *file;
        int fd; 

        assert(sv);
	sv_setpv(PL_statname, SvPV_nomg_const_nolen(sv));
      really_filename:
        file = SvPVX_const(PL_statname);
	PL_statgv = NULL;
	if (!(fp = PerlIO_open(file, "r"))) {
	    if (!gv) {
		PL_laststatval = -1;
		PL_laststype = OP_STAT;
	    }
	    if (ckWARN(WARN_NEWLINE) && should_warn_nl(file)) {
                /* PL_warn_nl is constant */
                GCC_DIAG_IGNORE(-Wformat-nonliteral);
		Perl_warner(aTHX_ packWARN(WARN_NEWLINE), PL_warn_nl, "open");
                GCC_DIAG_RESTORE;
            }
	    FT_RETURNUNDEF;
	}
	PL_laststype = OP_STAT;
        fd = PerlIO_fileno(fp);
        if (fd < 0) {
	    (void)PerlIO_close(fp);
            SETERRNO(EBADF,RMS_IFI);
	    FT_RETURNUNDEF;
        }
	PL_laststatval = PerlLIO_fstat(fd, &PL_statcache);
	if (PL_laststatval < 0)	{
	    (void)PerlIO_close(fp);
            SETERRNO(EBADF,RMS_IFI);
	    FT_RETURNUNDEF;
	}
	PerlIO_binmode(aTHX_ fp, '<', O_BINARY, NULL);
	len = PerlIO_read(fp, tbuf, sizeof(tbuf));
	(void)PerlIO_close(fp);
	if (len <= 0) {
	    if (S_ISDIR(PL_statcache.st_mode) && PL_op->op_type == OP_FTTEXT)
		FT_RETURNNO;		/* special case NFS directories */
	    FT_RETURNYES;		/* null file is anything */
	}
	s = tbuf;
    }

    /* now scan s to look for textiness */

#if defined(DOSISH) || defined(USEMYBINMODE)
    /* ignore trailing ^Z on short files */
    if (len && len < (I32)sizeof(tbuf) && tbuf[len-1] == 26)
	--len;
#endif

    assert(len);
    if (! is_invariant_string((U8 *) s, len)) {
        const U8 *ep;

        /* Here contains a variant under UTF-8 .  See if the entire string is
         * UTF-8.  But the buffer may end in a partial character, so consider
         * it UTF-8 if the first non-UTF8 char is an ending partial */
        if (is_utf8_string_loc((U8 *) s, len, &ep)
            || ep + UTF8SKIP(ep)  > (U8 *) (s + len))
        {
            if (PL_op->op_type == OP_FTTEXT) {
                FT_RETURNYES;
            }
            else {
                FT_RETURNNO;
            }
        }
    }

    /* Here, is not UTF-8 or is entirely ASCII.  Look through the buffer for
     * things that wouldn't be in ASCII text or rich ASCII text.  Count these
     * in 'odd' */
    for (i = 0; i < len; i++, s++) {
	if (!*s) {			/* null never allowed in text */
	    odd += len;
	    break;
	}
#ifdef USE_LOCALE_CTYPE
        if (IN_LC_RUNTIME(LC_CTYPE)) {
            if ( isPRINT_LC(*s) || isSPACE_LC(*s)) {
		continue;
            }
        }
        else
#endif
        if (isPRINT_A(*s)
                   /* VT occurs so rarely in text, that we consider it odd */
                || (isSPACE_A(*s) && *s != VT_NATIVE)

                    /* But there is a fair amount of backspaces and escapes in
                     * some text */
                || *s == '\b'
                || *s == ESC_NATIVE)
        {
            continue;
        }
        odd++;
    }

    if ((odd * 3 > len) == (PL_op->op_type == OP_FTTEXT)) /* allow 1/3 odd */
	FT_RETURNNO;
    else
	FT_RETURNYES;
}

/* File calls. */

PP(pp_chdir)
{
    dSP; dTARGET;
    const char *tmps = NULL;
    GV *gv = NULL;

    if( MAXARG == 1 ) {
	SV * const sv = POPs;
	if (PL_op->op_flags & OPf_SPECIAL) {
	    gv = gv_fetchsv(sv, 0, SVt_PVIO);
            if (!gv) {
                if (ckWARN(WARN_UNOPENED)) {
                    Perl_warner(aTHX_ packWARN(WARN_UNOPENED),
                                "chdir() on unopened filehandle %" SVf, sv);
                }
                SETERRNO(EBADF,RMS_IFI);
                PUSHi(0);
                TAINT_PROPER("chdir");
                RETURN;
            }
	}
        else if (!(gv = MAYBE_DEREF_GV(sv)))
		tmps = SvPV_nomg_const_nolen(sv);
    }
    else {
	HV * const table = GvHVn(PL_envgv);
	SV **svp;

        if (    (svp = hv_fetchs(table, "HOME", FALSE))
             || (svp = hv_fetchs(table, "LOGDIR", FALSE))
#ifdef VMS
             || (svp = hv_fetchs(table, "SYS$LOGIN", FALSE))
#endif
           )
        {
            tmps = SvPV_nolen_const(*svp);
        }
        else {
            PUSHi(0);
            SETERRNO(EINVAL, LIB_INVARG);
            TAINT_PROPER("chdir");
            RETURN;
        }
    }

    TAINT_PROPER("chdir");
    if (gv) {
#ifdef HAS_FCHDIR
	IO* const io = GvIO(gv);
	if (io) {
	    if (IoDIRP(io)) {
		PUSHi(fchdir(my_dirfd(IoDIRP(io))) >= 0);
	    } else if (IoIFP(io)) {
                int fd = PerlIO_fileno(IoIFP(io));
                if (fd < 0) {
                    goto nuts;
                }
                PUSHi(fchdir(fd) >= 0);
	    }
	    else {
                goto nuts;
	    }
        } else {
            goto nuts;
        }

#else
	DIE(aTHX_ PL_no_func, "fchdir");
#endif
    }
    else 
        PUSHi( PerlDir_chdir(tmps) >= 0 );
#ifdef VMS
    /* Clear the DEFAULT element of ENV so we'll get the new value
     * in the future. */
    hv_delete(GvHVn(PL_envgv),"DEFAULT",7,G_DISCARD);
#endif
    RETURN;

#ifdef HAS_FCHDIR
 nuts:
    report_evil_fh(gv);
    SETERRNO(EBADF,RMS_IFI);
    PUSHi(0);
    RETURN;
#endif
}


/* also used for: pp_chmod() pp_kill() pp_unlink() pp_utime() */

PP(pp_chown)
{
    dSP; dMARK; dTARGET;
    const I32 value = (I32)apply(PL_op->op_type, MARK, SP);

    SP = MARK;
    XPUSHi(value);
    RETURN;
}

PP(pp_chroot)
{
#ifdef HAS_CHROOT
    dSP; dTARGET;
    char * const tmps = POPpx;
    TAINT_PROPER("chroot");
    PUSHi( chroot(tmps) >= 0 );
    RETURN;
#else
    DIE(aTHX_ PL_no_func, "chroot");
#endif
}

PP(pp_rename)
{
    dSP; dTARGET;
    int anum;
#ifndef HAS_RENAME
    Stat_t statbuf;
#endif
    const char * const tmps2 = POPpconstx;
    const char * const tmps = SvPV_nolen_const(TOPs);
    TAINT_PROPER("rename");
#ifdef HAS_RENAME
    anum = PerlLIO_rename(tmps, tmps2);
#else
    if (!(anum = PerlLIO_stat(tmps, &statbuf))) {
	if (same_dirent(tmps2, tmps))	/* can always rename to same name */
	    anum = 1;
	else {
	    if (PerlProc_geteuid() || PerlLIO_stat(tmps2, &statbuf) < 0 || !S_ISDIR(statbuf.st_mode))
		(void)UNLINK(tmps2);
	    if (!(anum = link(tmps, tmps2)))
		anum = UNLINK(tmps);
	}
    }
#endif
    SETi( anum >= 0 );
    RETURN;
}


/* also used for: pp_symlink() */

#if defined(HAS_LINK) || defined(HAS_SYMLINK)
PP(pp_link)
{
    dSP; dTARGET;
    const int op_type = PL_op->op_type;
    int result;

#  ifndef HAS_LINK
    if (op_type == OP_LINK)
	DIE(aTHX_ PL_no_func, "link");
#  endif
#  ifndef HAS_SYMLINK
    if (op_type == OP_SYMLINK)
	DIE(aTHX_ PL_no_func, "symlink");
#  endif

    {
	const char * const tmps2 = POPpconstx;
	const char * const tmps = SvPV_nolen_const(TOPs);
	TAINT_PROPER(PL_op_desc[op_type]);
	result =
#  if defined(HAS_LINK)
#    if defined(HAS_SYMLINK)
	    /* Both present - need to choose which.  */
	    (op_type == OP_LINK) ?
	    PerlLIO_link(tmps, tmps2) : symlink(tmps, tmps2);
#    else
    /* Only have link, so calls to pp_symlink will have DIE()d above.  */
	PerlLIO_link(tmps, tmps2);
#    endif
#  else
#    if defined(HAS_SYMLINK)
    /* Only have symlink, so calls to pp_link will have DIE()d above.  */
	symlink(tmps, tmps2);
#    endif
#  endif
    }

    SETi( result >= 0 );
    RETURN;
}
#else

/* also used for: pp_symlink() */

PP(pp_link)
{
    /* Have neither.  */
    DIE(aTHX_ PL_no_func, PL_op_desc[PL_op->op_type]);
}
#endif

PP(pp_readlink)
{
    dSP;
#ifdef HAS_SYMLINK
    dTARGET;
    const char *tmps;
    char buf[MAXPATHLEN];
    SSize_t len;

    TAINT;
    tmps = POPpconstx;
    /* NOTE: if the length returned by readlink() is sizeof(buf) - 1,
     * it is impossible to know whether the result was truncated. */
    len = readlink(tmps, buf, sizeof(buf) - 1);
    if (len < 0)
	RETPUSHUNDEF;
    if (len != -1)
        buf[len] = '\0';
    PUSHp(buf, len);
    RETURN;
#else
    EXTEND(SP, 1);
    RETSETUNDEF;		/* just pretend it's a normal file */
#endif
}

#if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)
STATIC int
S_dooneliner(pTHX_ const char *cmd, const char *filename)
{
    char * const save_filename = filename;
    char *cmdline;
    char *s;
    PerlIO *myfp;
    int anum = 1;
    Size_t size = strlen(cmd) + (strlen(filename) * 2) + 10;

    PERL_ARGS_ASSERT_DOONELINER;

    Newx(cmdline, size, char);
    my_strlcpy(cmdline, cmd, size);
    my_strlcat(cmdline, " ", size);
    for (s = cmdline + strlen(cmdline); *filename; ) {
	*s++ = '\\';
	*s++ = *filename++;
    }
    if (s - cmdline < size)
	my_strlcpy(s, " 2>&1", size - (s - cmdline));
    myfp = PerlProc_popen(cmdline, "r");
    Safefree(cmdline);

    if (myfp) {
	SV * const tmpsv = sv_newmortal();
	/* Need to save/restore 'PL_rs' ?? */
	s = sv_gets(tmpsv, myfp, 0);
	(void)PerlProc_pclose(myfp);
	if (s != NULL) {
	    int e;
	    for (e = 1;
#ifdef HAS_SYS_ERRLIST
		 e <= sys_nerr
#endif
		 ; e++)
	    {
		/* you don't see this */
		const char * const errmsg = Strerror(e) ;
		if (!errmsg)
		    break;
		if (instr(s, errmsg)) {
		    SETERRNO(e,0);
		    return 0;
		}
	    }
	    SETERRNO(0,0);
#ifndef EACCES
#define EACCES EPERM
#endif
	    if (instr(s, "cannot make"))
		SETERRNO(EEXIST,RMS_FEX);
	    else if (instr(s, "existing file"))
		SETERRNO(EEXIST,RMS_FEX);
	    else if (instr(s, "ile exists"))
		SETERRNO(EEXIST,RMS_FEX);
	    else if (instr(s, "non-exist"))
		SETERRNO(ENOENT,RMS_FNF);
	    else if (instr(s, "does not exist"))
		SETERRNO(ENOENT,RMS_FNF);
	    else if (instr(s, "not empty"))
		SETERRNO(EBUSY,SS_DEVOFFLINE);
	    else if (instr(s, "cannot access"))
		SETERRNO(EACCES,RMS_PRV);
	    else
		SETERRNO(EPERM,RMS_PRV);
	    return 0;
	}
	else {	/* some mkdirs return no failure indication */
	    Stat_t statbuf;
	    anum = (PerlLIO_stat(save_filename, &statbuf) >= 0);
	    if (PL_op->op_type == OP_RMDIR)
		anum = !anum;
	    if (anum)
		SETERRNO(0,0);
	    else
		SETERRNO(EACCES,RMS_PRV);	/* a guess */
	}
	return anum;
    }
    else
	return 0;
}
#endif

/* This macro removes trailing slashes from a directory name.
 * Different operating and file systems take differently to
 * trailing slashes.  According to POSIX 1003.1 1996 Edition
 * any number of trailing slashes should be allowed.
 * Thusly we snip them away so that even non-conforming
 * systems are happy.
 * We should probably do this "filtering" for all
 * the functions that expect (potentially) directory names:
 * -d, chdir(), chmod(), chown(), chroot(), fcntl()?,
 * (mkdir()), opendir(), rename(), rmdir(), stat(). --jhi */

#define TRIMSLASHES(tmps,len,copy) (tmps) = SvPV_const(TOPs, (len)); \
    if ((len) > 1 && (tmps)[(len)-1] == '/') { \
	do { \
	    (len)--; \
	} while ((len) > 1 && (tmps)[(len)-1] == '/'); \
	(tmps) = savepvn((tmps), (len)); \
	(copy) = TRUE; \
    }

PP(pp_mkdir)
{
    dSP; dTARGET;
    STRLEN len;
    const char *tmps;
    bool copy = FALSE;
    const unsigned int mode = (MAXARG > 1 && (TOPs||((void)POPs,0))) ? POPu : 0777;

    TRIMSLASHES(tmps,len,copy);

    TAINT_PROPER("mkdir");
#ifdef HAS_MKDIR
    SETi( PerlDir_mkdir(tmps, mode) >= 0 );
#else
    {
    int oldumask;
    SETi( dooneliner("mkdir", tmps) );
    oldumask = PerlLIO_umask(0);
    PerlLIO_umask(oldumask);
    PerlLIO_chmod(tmps, (mode & ~oldumask) & 0777);
    }
#endif
    if (copy)
	Safefree(tmps);
    RETURN;
}

PP(pp_rmdir)
{
    dSP; dTARGET;
    STRLEN len;
    const char *tmps;
    bool copy = FALSE;

    TRIMSLASHES(tmps,len,copy);
    TAINT_PROPER("rmdir");
#ifdef HAS_RMDIR
    SETi( PerlDir_rmdir(tmps) >= 0 );
#else
    SETi( dooneliner("rmdir", tmps) );
#endif
    if (copy)
	Safefree(tmps);
    RETURN;
}

/* Directory calls. */

PP(pp_open_dir)
{
#if defined(Direntry_t) && defined(HAS_READDIR)
    dSP;
    const char * const dirname = POPpconstx;
    GV * const gv = MUTABLE_GV(POPs);
    IO * const io = GvIOn(gv);

    if ((IoIFP(io) || IoOFP(io)))
	Perl_ck_warner_d(aTHX_ packWARN2(WARN_IO, WARN_DEPRECATED),
			 "Opening filehandle %"HEKf" also as a directory",
			     HEKfARG(GvENAME_HEK(gv)) );
    if (IoDIRP(io))
	PerlDir_close(IoDIRP(io));
    if (!(IoDIRP(io) = PerlDir_open(dirname)))
	goto nope;

    RETPUSHYES;
  nope:
    if (!errno)
	SETERRNO(EBADF,RMS_DIR);
    RETPUSHUNDEF;
#else
    DIE(aTHX_ PL_no_dir_func, "opendir");
#endif
}

PP(pp_readdir)
{
#if !defined(Direntry_t) || !defined(HAS_READDIR)
    DIE(aTHX_ PL_no_dir_func, "readdir");
#else
#if !defined(I_DIRENT) && !defined(VMS)
    Direntry_t *readdir (DIR *);
#endif
    dSP;

    SV *sv;
    const U8 gimme = GIMME_V;
    GV * const gv = MUTABLE_GV(POPs);
    const Direntry_t *dp;
    IO * const io = GvIOn(gv);

    if (!IoDIRP(io)) {
	Perl_ck_warner(aTHX_ packWARN(WARN_IO),
		       "readdir() attempted on invalid dirhandle %"HEKf,
                            HEKfARG(GvENAME_HEK(gv)));
        goto nope;
    }

    do {
        dp = (Direntry_t *)PerlDir_read(IoDIRP(io));
        if (!dp)
            break;
#ifdef DIRNAMLEN
        sv = newSVpvn(dp->d_name, dp->d_namlen);
#else
        sv = newSVpv(dp->d_name, 0);
#endif
        if (!(IoFLAGS(io) & IOf_UNTAINT))
            SvTAINTED_on(sv);
        mXPUSHs(sv);
    } while (gimme == G_ARRAY);

    if (!dp && gimme != G_ARRAY)
        RETPUSHUNDEF;

    RETURN;

  nope:
    if (!errno)
	SETERRNO(EBADF,RMS_ISI);
    if (gimme == G_ARRAY)
	RETURN;
    else
	RETPUSHUNDEF;
#endif
}

PP(pp_telldir)
{
#if defined(HAS_TELLDIR) || defined(telldir)
    dSP; dTARGET;
 /* XXX does _anyone_ need this? --AD 2/20/1998 */
 /* XXX netbsd still seemed to.
    XXX HAS_TELLDIR_PROTO is new style, NEED_TELLDIR_PROTO is old style.
    --JHI 1999-Feb-02 */
# if !defined(HAS_TELLDIR_PROTO) || defined(NEED_TELLDIR_PROTO)
    long telldir (DIR *);
# endif
    GV * const gv = MUTABLE_GV(POPs);
    IO * const io = GvIOn(gv);

    if (!IoDIRP(io)) {
	Perl_ck_warner(aTHX_ packWARN(WARN_IO),
		       "telldir() attempted on invalid dirhandle %"HEKf,
                            HEKfARG(GvENAME_HEK(gv)));
        goto nope;
    }

    PUSHi( PerlDir_tell(IoDIRP(io)) );
    RETURN;
  nope:
    if (!errno)
	SETERRNO(EBADF,RMS_ISI);
    RETPUSHUNDEF;
#else
    DIE(aTHX_ PL_no_dir_func, "telldir");
#endif
}

PP(pp_seekdir)
{
#if defined(HAS_SEEKDIR) || defined(seekdir)
    dSP;
    const long along = POPl;
    GV * const gv = MUTABLE_GV(POPs);
    IO * const io = GvIOn(gv);

    if (!IoDIRP(io)) {
	Perl_ck_warner(aTHX_ packWARN(WARN_IO),
		       "seekdir() attempted on invalid dirhandle %"HEKf,
                                HEKfARG(GvENAME_HEK(gv)));
        goto nope;
    }
    (void)PerlDir_seek(IoDIRP(io), along);

    RETPUSHYES;
  nope:
    if (!errno)
	SETERRNO(EBADF,RMS_ISI);
    RETPUSHUNDEF;
#else
    DIE(aTHX_ PL_no_dir_func, "seekdir");
#endif
}

PP(pp_rewinddir)
{
#if defined(HAS_REWINDDIR) || defined(rewinddir)
    dSP;
    GV * const gv = MUTABLE_GV(POPs);
    IO * const io = GvIOn(gv);

    if (!IoDIRP(io)) {
	Perl_ck_warner(aTHX_ packWARN(WARN_IO),
		       "rewinddir() attempted on invalid dirhandle %"HEKf,
                                HEKfARG(GvENAME_HEK(gv)));
	goto nope;
    }
    (void)PerlDir_rewind(IoDIRP(io));
    RETPUSHYES;
  nope:
    if (!errno)
	SETERRNO(EBADF,RMS_ISI);
    RETPUSHUNDEF;
#else
    DIE(aTHX_ PL_no_dir_func, "rewinddir");
#endif
}

PP(pp_closedir)
{
#if defined(Direntry_t) && defined(HAS_READDIR)
    dSP;
    GV * const gv = MUTABLE_GV(POPs);
    IO * const io = GvIOn(gv);

    if (!IoDIRP(io)) {
	Perl_ck_warner(aTHX_ packWARN(WARN_IO),
		       "closedir() attempted on invalid dirhandle %"HEKf,
                                HEKfARG(GvENAME_HEK(gv)));
        goto nope;
    }
#ifdef VOID_CLOSEDIR
    PerlDir_close(IoDIRP(io));
#else
    if (PerlDir_close(IoDIRP(io)) < 0) {
	IoDIRP(io) = 0; /* Don't try to close again--coredumps on SysV */
	goto nope;
    }
#endif
    IoDIRP(io) = 0;

    RETPUSHYES;
  nope:
    if (!errno)
	SETERRNO(EBADF,RMS_IFI);
    RETPUSHUNDEF;
#else
    DIE(aTHX_ PL_no_dir_func, "closedir");
#endif
}

/* Process control. */

PP(pp_fork)
{
#ifdef HAS_FORK
    dSP; dTARGET;
    Pid_t childpid;
#ifdef HAS_SIGPROCMASK
    sigset_t oldmask, newmask;
#endif

    EXTEND(SP, 1);
    PERL_FLUSHALL_FOR_CHILD;
#ifdef HAS_SIGPROCMASK
    sigfillset(&newmask);
    sigprocmask(SIG_SETMASK, &newmask, &oldmask);
#endif
    childpid = PerlProc_fork();
    if (childpid == 0) {
	int sig;
	PL_sig_pending = 0;
	if (PL_psig_pend)
	    for (sig = 1; sig < SIG_SIZE; sig++)
		PL_psig_pend[sig] = 0;
    }
#ifdef HAS_SIGPROCMASK
    {
	dSAVE_ERRNO;
	sigprocmask(SIG_SETMASK, &oldmask, NULL);
	RESTORE_ERRNO;
    }
#endif
    if (childpid < 0)
	RETPUSHUNDEF;
    if (!childpid) {
#ifdef PERL_USES_PL_PIDSTATUS
	hv_clear(PL_pidstatus);	/* no kids, so don't wait for 'em */
#endif
    }
    PUSHi(childpid);
    RETURN;
#else
#  if (defined(USE_ITHREADS) && defined(PERL_IMPLICIT_SYS)) || defined(__amigaos4__)
    dSP; dTARGET;
    Pid_t childpid;

    EXTEND(SP, 1);
    PERL_FLUSHALL_FOR_CHILD;
    childpid = PerlProc_fork();
    if (childpid == -1)
	RETPUSHUNDEF;
    PUSHi(childpid);
    RETURN;
#  else
    DIE(aTHX_ PL_no_func, "fork");
#  endif
#endif
}

PP(pp_wait)
{
#if (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(__LIBCATAMOUNT__)
    dSP; dTARGET;
    Pid_t childpid;
    int argflags;

    if (PL_signals & PERL_SIGNALS_UNSAFE_FLAG)
        childpid = wait4pid(-1, &argflags, 0);
    else {
        while ((childpid = wait4pid(-1, &argflags, 0)) == -1 &&
	       errno == EINTR) {
	  PERL_ASYNC_CHECK();
	}
    }
#  if defined(USE_ITHREADS) && defined(PERL_IMPLICIT_SYS)
    /* 0 and -1 are both error returns (the former applies to WNOHANG case) */
    STATUS_NATIVE_CHILD_SET((childpid && childpid != -1) ? argflags : -1);
#  else
    STATUS_NATIVE_CHILD_SET((childpid > 0) ? argflags : -1);
#  endif
    XPUSHi(childpid);
    RETURN;
#else
    DIE(aTHX_ PL_no_func, "wait");
#endif
}

PP(pp_waitpid)
{
#if (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(__LIBCATAMOUNT__)
    dSP; dTARGET;
    const int optype = POPi;
    const Pid_t pid = TOPi;
    Pid_t result;
#ifdef __amigaos4__
    int argflags = 0;
    result = amigaos_waitpid(aTHX_ optype, pid, &argflags);
    STATUS_NATIVE_CHILD_SET((result >= 0) ? argflags : -1);
    result = result == 0 ? pid : -1;
#else
    int argflags;

    if (PL_signals & PERL_SIGNALS_UNSAFE_FLAG)
        result = wait4pid(pid, &argflags, optype);
    else {
        while ((result = wait4pid(pid, &argflags, optype)) == -1 &&
	       errno == EINTR) {
	  PERL_ASYNC_CHECK();
	}
    }
#  if defined(USE_ITHREADS) && defined(PERL_IMPLICIT_SYS)
    /* 0 and -1 are both error returns (the former applies to WNOHANG case) */
    STATUS_NATIVE_CHILD_SET((result && result != -1) ? argflags : -1);
#  else
    STATUS_NATIVE_CHILD_SET((result > 0) ? argflags : -1);
#  endif
# endif /* __amigaos4__ */
    SETi(result);
    RETURN;
#else
    DIE(aTHX_ PL_no_func, "waitpid");
#endif
}

PP(pp_system)
{
    dSP; dMARK; dORIGMARK; dTARGET;
#if defined(__LIBCATAMOUNT__)
    PL_statusvalue = -1;
    SP = ORIGMARK;
    XPUSHi(-1);
#else
    I32 value;
# ifdef __amigaos4__
    void * result;
# else
    int result;
# endif

    if (TAINTING_get) {
	TAINT_ENV();
	while (++MARK <= SP) {
	    (void)SvPV_nolen_const(*MARK);      /* stringify for taint check */
	    if (TAINT_get)
		break;
	}
	MARK = ORIGMARK;
	TAINT_PROPER("system");
    }
    PERL_FLUSHALL_FOR_CHILD;
#if (defined(HAS_FORK) || defined(__amigaos4__)) && !defined(VMS) && !defined(OS2) || defined(PERL_MICRO)
    {
#ifdef __amigaos4__
        struct UserData userdata;
        pthread_t proc;
#else
	Pid_t childpid;
#endif
	int pp[2];
	I32 did_pipes = 0;
        bool child_success = FALSE;
#ifdef HAS_SIGPROCMASK
	sigset_t newset, oldset;
#endif

	if (PerlProc_pipe(pp) >= 0)
	    did_pipes = 1;
#ifdef __amigaos4__
        amigaos_fork_set_userdata(aTHX_
                                  &userdata,
                                  did_pipes,
                                  pp[1],
                                  SP,
                                  mark);
        pthread_create(&proc,NULL,amigaos_system_child,(void *)&userdata);
        child_success = proc > 0;
#else
#ifdef HAS_SIGPROCMASK
	sigemptyset(&newset);
	sigaddset(&newset, SIGCHLD);
	sigprocmask(SIG_BLOCK, &newset, &oldset);
#endif
	while ((childpid = PerlProc_fork()) == -1) {
	    if (errno != EAGAIN) {
		value = -1;
		SP = ORIGMARK;
		XPUSHi(value);
		if (did_pipes) {
		    PerlLIO_close(pp[0]);
		    PerlLIO_close(pp[1]);
		}
#ifdef HAS_SIGPROCMASK
		sigprocmask(SIG_SETMASK, &oldset, NULL);
#endif
		RETURN;
	    }
	    sleep(5);
	}
        child_success = childpid > 0;
#endif
	if (child_success) {
	    Sigsave_t ihand,qhand; /* place to save signals during system() */
	    int status;

#ifndef __amigaos4__
	    if (did_pipes)
		PerlLIO_close(pp[1]);
#endif
#ifndef PERL_MICRO
	    rsignal_save(SIGINT,  (Sighandler_t) SIG_IGN, &ihand);
	    rsignal_save(SIGQUIT, (Sighandler_t) SIG_IGN, &qhand);
#endif
#ifdef __amigaos4__
            result = pthread_join(proc, (void **)&status);
#else
	    do {
		result = wait4pid(childpid, &status, 0);
	    } while (result == -1 && errno == EINTR);
#endif
#ifndef PERL_MICRO
#ifdef HAS_SIGPROCMASK
	    sigprocmask(SIG_SETMASK, &oldset, NULL);
#endif
	    (void)rsignal_restore(SIGINT, &ihand);
	    (void)rsignal_restore(SIGQUIT, &qhand);
#endif
	    STATUS_NATIVE_CHILD_SET(result == -1 ? -1 : status);
	    do_execfree();	/* free any memory child malloced on fork */
	    SP = ORIGMARK;
	    if (did_pipes) {
		int errkid;
		unsigned n = 0;
		SSize_t n1;

		while (n < sizeof(int)) {
		    n1 = PerlLIO_read(pp[0],
				      (void*)(((char*)&errkid)+n),
				      (sizeof(int)) - n);
		    if (n1 <= 0)
			break;
		    n += n1;
		}
		PerlLIO_close(pp[0]);
		if (n) {			/* Error */
		    if (n != sizeof(int))
			DIE(aTHX_ "panic: kid popen errno read, n=%u", n);
		    errno = errkid;		/* Propagate errno from kid */
#ifdef __amigaos4__
                    /* The pipe always has something in it
                     * so n alone is not enough. */
                    if (errno > 0)
#endif
                    {
                        STATUS_NATIVE_CHILD_SET(-1);
                    }
		}
	    }
	    XPUSHi(STATUS_CURRENT);
	    RETURN;
	}
#ifndef __amigaos4__
#ifdef HAS_SIGPROCMASK
	sigprocmask(SIG_SETMASK, &oldset, NULL);
#endif
	if (did_pipes) {
	    PerlLIO_close(pp[0]);
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
	    if (fcntl(pp[1], F_SETFD, FD_CLOEXEC) < 0)
                RETPUSHUNDEF;
#endif
	}
	if (PL_op->op_flags & OPf_STACKED) {
	    SV * const really = *++MARK;
	    value = (I32)do_aexec5(really, MARK, SP, pp[1], did_pipes);
	}
	else if (SP - MARK != 1)
	    value = (I32)do_aexec5(NULL, MARK, SP, pp[1], did_pipes);
	else {
	    value = (I32)do_exec3(SvPVx_nolen(sv_mortalcopy(*SP)), pp[1], did_pipes);
	}
#endif /* __amigaos4__ */
	PerlProc__exit(-1);
    }
#else /* ! FORK or VMS or OS/2 */
    PL_statusvalue = 0;
    result = 0;
    if (PL_op->op_flags & OPf_STACKED) {
	SV * const really = *++MARK;
#  if defined(WIN32) || defined(OS2) || defined(__SYMBIAN32__) || defined(__VMS)
	value = (I32)do_aspawn(really, MARK, SP);
#  else
	value = (I32)do_aspawn(really, (void **)MARK, (void **)SP);
#  endif
    }
    else if (SP - MARK != 1) {
#  if defined(WIN32) || defined(OS2) || defined(__SYMBIAN32__) || defined(__VMS)
	value = (I32)do_aspawn(NULL, MARK, SP);
#  else
	value = (I32)do_aspawn(NULL, (void **)MARK, (void **)SP);
#  endif
    }
    else {
	value = (I32)do_spawn(SvPVx_nolen(sv_mortalcopy(*SP)));
    }
    if (PL_statusvalue == -1)	/* hint that value must be returned as is */
	result = 1;
    STATUS_NATIVE_CHILD_SET(value);
    do_execfree();
    SP = ORIGMARK;
    XPUSHi(result ? value : STATUS_CURRENT);
#endif /* !FORK or VMS or OS/2 */
#endif
    RETURN;
}

PP(pp_exec)
{
    dSP; dMARK; dORIGMARK; dTARGET;
    I32 value;

    if (TAINTING_get) {
	TAINT_ENV();
	while (++MARK <= SP) {
	    (void)SvPV_nolen_const(*MARK);      /* stringify for taint check */
	    if (TAINT_get)
		break;
	}
	MARK = ORIGMARK;
	TAINT_PROPER("exec");
    }

    PERL_FLUSHALL_FOR_CHILD;
    if (PL_op->op_flags & OPf_STACKED) {
	SV * const really = *++MARK;
	value = (I32)do_aexec(really, MARK, SP);
    }
    else if (SP - MARK != 1)
#ifdef VMS
	value = (I32)vms_do_aexec(NULL, MARK, SP);
#else
	value = (I32)do_aexec(NULL, MARK, SP);
#endif
    else {
#ifdef VMS
	value = (I32)vms_do_exec(SvPVx_nolen(sv_mortalcopy(*SP)));
#else
	value = (I32)do_exec(SvPVx_nolen(sv_mortalcopy(*SP)));
#endif
    }
    SP = ORIGMARK;
    XPUSHi(value);
    RETURN;
}

PP(pp_getppid)
{
#ifdef HAS_GETPPID
    dSP; dTARGET;
    XPUSHi( getppid() );
    RETURN;
#else
    DIE(aTHX_ PL_no_func, "getppid");
#endif
}

PP(pp_getpgrp)
{
#ifdef HAS_GETPGRP
    dSP; dTARGET;
    Pid_t pgrp;
    const Pid_t pid =
	(MAXARG < 1) ? 0 : TOPs ? SvIVx(POPs) : ((void)POPs, 0);

#ifdef BSD_GETPGRP
    pgrp = (I32)BSD_GETPGRP(pid);
#else
    if (pid != 0 && pid != PerlProc_getpid())
	DIE(aTHX_ "POSIX getpgrp can't take an argument");
    pgrp = getpgrp();
#endif
    XPUSHi(pgrp);
    RETURN;
#else
    DIE(aTHX_ PL_no_func, "getpgrp");
#endif
}

PP(pp_setpgrp)
{
#ifdef HAS_SETPGRP
    dSP; dTARGET;
    Pid_t pgrp;
    Pid_t pid;
    pgrp = MAXARG == 2 && (TOPs||POPs) ? POPi : 0;
    if (MAXARG > 0) pid = TOPs ? TOPi : 0;
    else {
	pid = 0;
	EXTEND(SP,1);
	SP++;
    }

    TAINT_PROPER("setpgrp");
#ifdef BSD_SETPGRP
    SETi( BSD_SETPGRP(pid, pgrp) >= 0 );
#else
    if ((pgrp != 0 && pgrp != PerlProc_getpid())
	|| (pid != 0 && pid != PerlProc_getpid()))
    {
	DIE(aTHX_ "setpgrp can't take arguments");
    }
    SETi( setpgrp() >= 0 );
#endif /* USE_BSDPGRP */
    RETURN;
#else
    DIE(aTHX_ PL_no_func, "setpgrp");
#endif
}

#if defined(__GLIBC__) && ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3) || (__GLIBC__ > 2))
#  define PRIORITY_WHICH_T(which) (__priority_which_t)which
#else
#  define PRIORITY_WHICH_T(which) which
#endif

PP(pp_getpriority)
{
#ifdef HAS_GETPRIORITY
    dSP; dTARGET;
    const int who = POPi;
    const int which = TOPi;
    SETi( getpriority(PRIORITY_WHICH_T(which), who) );
    RETURN;
#else
    DIE(aTHX_ PL_no_func, "getpriority");
#endif
}

PP(pp_setpriority)
{
#ifdef HAS_SETPRIORITY
    dSP; dTARGET;
    const int niceval = POPi;
    const int who = POPi;
    const int which = TOPi;
    TAINT_PROPER("setpriority");
    SETi( setpriority(PRIORITY_WHICH_T(which), who, niceval) >= 0 );
    RETURN;
#else
    DIE(aTHX_ PL_no_func, "setpriority");
#endif
}

#undef PRIORITY_WHICH_T

/* Time calls. */

PP(pp_time)
{
    dSP; dTARGET;
#ifdef BIG_TIME
    XPUSHn( time(NULL) );
#else
    XPUSHi( time(NULL) );
#endif
    RETURN;
}

PP(pp_tms)
{
#ifdef HAS_TIMES
    dSP;
    struct tms timesbuf;

    EXTEND(SP, 4);
    (void)PerlProc_times(&timesbuf);

    mPUSHn(((NV)timesbuf.tms_utime)/(NV)PL_clocktick);
    if (GIMME_V == G_ARRAY) {
	mPUSHn(((NV)timesbuf.tms_stime)/(NV)PL_clocktick);
	mPUSHn(((NV)timesbuf.tms_cutime)/(NV)PL_clocktick);
	mPUSHn(((NV)timesbuf.tms_cstime)/(NV)PL_clocktick);
    }
    RETURN;
#else
#   ifdef PERL_MICRO
    dSP;
    mPUSHn(0.0);
    EXTEND(SP, 4);
    if (GIMME_V == G_ARRAY) {
	 mPUSHn(0.0);
	 mPUSHn(0.0);
	 mPUSHn(0.0);
    }
    RETURN;
#   else
    DIE(aTHX_ "times not implemented");
#   endif
#endif /* HAS_TIMES */
}

/* The 32 bit int year limits the times we can represent to these
   boundaries with a few days wiggle room to account for time zone
   offsets
*/
/* Sat Jan  3 00:00:00 -2147481748 */
#define TIME_LOWER_BOUND -67768100567755200.0
/* Sun Dec 29 12:00:00  2147483647 */
#define TIME_UPPER_BOUND  67767976233316800.0


/* also used for: pp_localtime() */

PP(pp_gmtime)
{
    dSP;
    Time64_T when;
    struct TM tmbuf;
    struct TM *err;
    const char *opname = PL_op->op_type == OP_LOCALTIME ? "localtime" : "gmtime";
    static const char * const dayname[] =
	{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    static const char * const monname[] =
	{"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

    if (MAXARG < 1 || (!TOPs && ((void)POPs, 1))) {
	time_t now;
	(void)time(&now);
	when = (Time64_T)now;
    }
    else {
	NV input = Perl_floor(POPn);
	const bool pl_isnan = Perl_isnan(input);
	when = (Time64_T)input;
	if (UNLIKELY(pl_isnan || when != input)) {
	    /* diag_listed_as: gmtime(%f) too large */
	    Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW),
			   "%s(%.0" NVff ") too large", opname, input);
	    if (pl_isnan) {
		err = NULL;
		goto failed;
	    }
	}
    }

    if ( TIME_LOWER_BOUND > when ) {
	/* diag_listed_as: gmtime(%f) too small */
	Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW),
		       "%s(%.0" NVff ") too small", opname, when);
	err = NULL;
    }
    else if( when > TIME_UPPER_BOUND ) {
	/* diag_listed_as: gmtime(%f) too small */
	Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW),
		       "%s(%.0" NVff ") too large", opname, when);
	err = NULL;
    }
    else {
	if (PL_op->op_type == OP_LOCALTIME)
	    err = Perl_localtime64_r(&when, &tmbuf);
	else
	    err = Perl_gmtime64_r(&when, &tmbuf);
    }

    if (err == NULL) {
	/* diag_listed_as: gmtime(%f) failed */
	/* XXX %lld broken for quads */
      failed:
	Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW),
		       "%s(%.0" NVff ") failed", opname, when);
    }

    if (GIMME_V != G_ARRAY) {	/* scalar context */
        EXTEND(SP, 1);
	if (err == NULL)
	    RETPUSHUNDEF;
       else {
           dTARGET;
           PUSHs(TARG);
           Perl_sv_setpvf_mg(aTHX_ TARG, "%s %s %2d %02d:%02d:%02d %"IVdf,
                                dayname[tmbuf.tm_wday],
                                monname[tmbuf.tm_mon],
                                tmbuf.tm_mday,
                                tmbuf.tm_hour,
                                tmbuf.tm_min,
                                tmbuf.tm_sec,
                                (IV)tmbuf.tm_year + 1900);
        }
    }
    else {			/* list context */
	if ( err == NULL )
	    RETURN;

        EXTEND(SP, 9);
        EXTEND_MORTAL(9);
        mPUSHi(tmbuf.tm_sec);
	mPUSHi(tmbuf.tm_min);
	mPUSHi(tmbuf.tm_hour);
	mPUSHi(tmbuf.tm_mday);
	mPUSHi(tmbuf.tm_mon);
	mPUSHn(tmbuf.tm_year);
	mPUSHi(tmbuf.tm_wday);
	mPUSHi(tmbuf.tm_yday);
	mPUSHi(tmbuf.tm_isdst);
    }
    RETURN;
}

PP(pp_alarm)
{
#ifdef HAS_ALARM
    dSP; dTARGET;
    /* alarm() takes an unsigned int number of seconds, and return the
     * unsigned int number of seconds remaining in the previous alarm
     * (alarms don't stack).  Therefore negative return values are not
     * possible. */
    int anum = POPi;
    if (anum < 0) {
        /* Note that while the C library function alarm() as such has
         * no errors defined (or in other words, properly behaving client
         * code shouldn't expect any), alarm() being obsoleted by
         * setitimer() and often being implemented in terms of
         * setitimer(), can fail. */
        /* diag_listed_as: %s() with negative argument */
        Perl_ck_warner_d(aTHX_ packWARN(WARN_MISC),
                         "alarm() with negative argument");
        SETERRNO(EINVAL, LIB_INVARG);
        RETPUSHUNDEF;
    }
    else {
        unsigned int retval = alarm(anum);
        if ((int)retval < 0) /* Strictly speaking "cannot happen". */
            RETPUSHUNDEF;
        PUSHu(retval);
        RETURN;
    }
#else
    DIE(aTHX_ PL_no_func, "alarm");
#endif
}

PP(pp_sleep)
{
    dSP; dTARGET;
    I32 duration;
    Time_t lasttime;
    Time_t when;

    (void)time(&lasttime);
    if (MAXARG < 1 || (!TOPs && !POPs))
	PerlProc_pause();
    else {
	duration = POPi;
        if (duration < 0) {
          /* diag_listed_as: %s() with negative argument */
          Perl_ck_warner_d(aTHX_ packWARN(WARN_MISC),
                           "sleep() with negative argument");
          SETERRNO(EINVAL, LIB_INVARG);
          XPUSHi(0);
          RETURN;
        } else {
          PerlProc_sleep((unsigned int)duration);
        }
    }
    (void)time(&when);
    XPUSHi(when - lasttime);
    RETURN;
}

/* Shared memory. */
/* Merged with some message passing. */

/* also used for: pp_msgrcv() pp_msgsnd() pp_semop() pp_shmread() */

PP(pp_shmwrite)
{
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
    dSP; dMARK; dTARGET;
    const int op_type = PL_op->op_type;
    I32 value;

    switch (op_type) {
    case OP_MSGSND:
	value = (I32)(do_msgsnd(MARK, SP) >= 0);
	break;
    case OP_MSGRCV:
	value = (I32)(do_msgrcv(MARK, SP) >= 0);
	break;
    case OP_SEMOP:
	value = (I32)(do_semop(MARK, SP) >= 0);
	break;
    default:
	value = (I32)(do_shmio(op_type, MARK, SP) >= 0);
	break;
    }

    SP = MARK;
    PUSHi(value);
    RETURN;
#else
    return Perl_pp_semget(aTHX);
#endif
}

/* Semaphores. */

/* also used for: pp_msgget() pp_shmget() */

PP(pp_semget)
{
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
    dSP; dMARK; dTARGET;
    const int anum = do_ipcget(PL_op->op_type, MARK, SP);
    SP = MARK;
    if (anum == -1)
	RETPUSHUNDEF;
    PUSHi(anum);
    RETURN;
#else
    DIE(aTHX_ "System V IPC is not implemented on this machine");
#endif
}

/* also used for: pp_msgctl() pp_shmctl() */

PP(pp_semctl)
{
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
    dSP; dMARK; dTARGET;
    const int anum = do_ipcctl(PL_op->op_type, MARK, SP);
    SP = MARK;
    if (anum == -1)
	RETPUSHUNDEF;
    if (anum != 0) {
	PUSHi(anum);
    }
    else {
	PUSHp(zero_but_true, ZBTLEN);
    }
    RETURN;
#else
    return Perl_pp_semget(aTHX);
#endif
}

/* I can't const this further without getting warnings about the types of
   various arrays passed in from structures.  */
static SV *
S_space_join_names_mortal(pTHX_ char *const *array)
{
    SV *target;

    PERL_ARGS_ASSERT_SPACE_JOIN_NAMES_MORTAL;

    if (*array) {
	target = newSVpvs_flags("", SVs_TEMP);
	while (1) {
	    sv_catpv(target, *array);
	    if (!*++array)
		break;
	    sv_catpvs(target, " ");
	}
    } else {
	target = sv_mortalcopy(&PL_sv_no);
    }
    return target;
}

/* Get system info. */

/* also used for: pp_ghbyaddr() pp_ghbyname() */

PP(pp_ghostent)
{
#if defined(HAS_GETHOSTBYNAME) || defined(HAS_GETHOSTBYADDR) || defined(HAS_GETHOSTENT)
    dSP;
    I32 which = PL_op->op_type;
    char **elem;
    SV *sv;
#ifndef HAS_GETHOST_PROTOS /* XXX Do we need individual probes? */
    struct hostent *gethostbyaddr(Netdb_host_t, Netdb_hlen_t, int);
    struct hostent *gethostbyname(Netdb_name_t);
    struct hostent *gethostent(void);
#endif
    struct hostent *hent = NULL;
    unsigned long len;

    EXTEND(SP, 10);
    if (which == OP_GHBYNAME) {
#ifdef HAS_GETHOSTBYNAME
	const char* const name = POPpbytex;
	hent = PerlSock_gethostbyname(name);
#else
	DIE(aTHX_ PL_no_sock_func, "gethostbyname");
#endif
    }
    else if (which == OP_GHBYADDR) {
#ifdef HAS_GETHOSTBYADDR
	const int addrtype = POPi;
	SV * const addrsv = POPs;
	STRLEN addrlen;
	const char *addr = (char *)SvPVbyte(addrsv, addrlen);

	hent = PerlSock_gethostbyaddr(addr, (Netdb_hlen_t) addrlen, addrtype);
#else
	DIE(aTHX_ PL_no_sock_func, "gethostbyaddr");
#endif
    }
    else
#ifdef HAS_GETHOSTENT
	hent = PerlSock_gethostent();
#else
	DIE(aTHX_ PL_no_sock_func, "gethostent");
#endif

#ifdef HOST_NOT_FOUND
	if (!hent) {
#ifdef USE_REENTRANT_API
#   ifdef USE_GETHOSTENT_ERRNO
	    h_errno = PL_reentrant_buffer->_gethostent_errno;
#   endif
#endif
	    STATUS_UNIX_SET(h_errno);
	}
#endif

    if (GIMME_V != G_ARRAY) {
	PUSHs(sv = sv_newmortal());
	if (hent) {
	    if (which == OP_GHBYNAME) {
		if (hent->h_addr)
		    sv_setpvn(sv, hent->h_addr, hent->h_length);
	    }
	    else
		sv_setpv(sv, (char*)hent->h_name);
	}
	RETURN;
    }

    if (hent) {
	mPUSHs(newSVpv((char*)hent->h_name, 0));
	PUSHs(space_join_names_mortal(hent->h_aliases));
	mPUSHi(hent->h_addrtype);
	len = hent->h_length;
	mPUSHi(len);
#ifdef h_addr
	for (elem = hent->h_addr_list; elem && *elem; elem++) {
	    mXPUSHp(*elem, len);
	}
#else
	if (hent->h_addr)
	    mPUSHp(hent->h_addr, len);
	else
	    PUSHs(sv_mortalcopy(&PL_sv_no));
#endif /* h_addr */
    }
    RETURN;
#else
    DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
#endif
}

/* also used for: pp_gnbyaddr() pp_gnbyname() */

PP(pp_gnetent)
{
#if defined(HAS_GETNETBYNAME) || defined(HAS_GETNETBYADDR) || defined(HAS_GETNETENT)
    dSP;
    I32 which = PL_op->op_type;
    SV *sv;
#ifndef HAS_GETNET_PROTOS /* XXX Do we need individual probes? */
    struct netent *getnetbyaddr(Netdb_net_t, int);
    struct netent *getnetbyname(Netdb_name_t);
    struct netent *getnetent(void);
#endif
    struct netent *nent;

    if (which == OP_GNBYNAME){
#ifdef HAS_GETNETBYNAME
	const char * const name = POPpbytex;
	nent = PerlSock_getnetbyname(name);
#else
        DIE(aTHX_ PL_no_sock_func, "getnetbyname");
#endif
    }
    else if (which == OP_GNBYADDR) {
#ifdef HAS_GETNETBYADDR
	const int addrtype = POPi;
	const Netdb_net_t addr = (Netdb_net_t) (U32)POPu;
	nent = PerlSock_getnetbyaddr(addr, addrtype);
#else
	DIE(aTHX_ PL_no_sock_func, "getnetbyaddr");
#endif
    }
    else
#ifdef HAS_GETNETENT
	nent = PerlSock_getnetent();
#else
        DIE(aTHX_ PL_no_sock_func, "getnetent");
#endif

#ifdef HOST_NOT_FOUND
	if (!nent) {
#ifdef USE_REENTRANT_API
#   ifdef USE_GETNETENT_ERRNO
	     h_errno = PL_reentrant_buffer->_getnetent_errno;
#   endif
#endif
	    STATUS_UNIX_SET(h_errno);
	}
#endif

    EXTEND(SP, 4);
    if (GIMME_V != G_ARRAY) {
	PUSHs(sv = sv_newmortal());
	if (nent) {
	    if (which == OP_GNBYNAME)
		sv_setiv(sv, (IV)nent->n_net);
	    else
		sv_setpv(sv, nent->n_name);
	}
	RETURN;
    }

    if (nent) {
	mPUSHs(newSVpv(nent->n_name, 0));
	PUSHs(space_join_names_mortal(nent->n_aliases));
	mPUSHi(nent->n_addrtype);
	mPUSHi(nent->n_net);
    }

    RETURN;
#else
    DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
#endif
}


/* also used for: pp_gpbyname() pp_gpbynumber() */

PP(pp_gprotoent)
{
#if defined(HAS_GETPROTOBYNAME) || defined(HAS_GETPROTOBYNUMBER) || defined(HAS_GETPROTOENT)
    dSP;
    I32 which = PL_op->op_type;
    SV *sv;
#ifndef HAS_GETPROTO_PROTOS /* XXX Do we need individual probes? */
    struct protoent *getprotobyname(Netdb_name_t);
    struct protoent *getprotobynumber(int);
    struct protoent *getprotoent(void);
#endif
    struct protoent *pent;

    if (which == OP_GPBYNAME) {
#ifdef HAS_GETPROTOBYNAME
	const char* const name = POPpbytex;
	pent = PerlSock_getprotobyname(name);
#else
	DIE(aTHX_ PL_no_sock_func, "getprotobyname");
#endif
    }
    else if (which == OP_GPBYNUMBER) {
#ifdef HAS_GETPROTOBYNUMBER
	const int number = POPi;
	pent = PerlSock_getprotobynumber(number);
#else
	DIE(aTHX_ PL_no_sock_func, "getprotobynumber");
#endif
    }
    else
#ifdef HAS_GETPROTOENT
	pent = PerlSock_getprotoent();
#else
	DIE(aTHX_ PL_no_sock_func, "getprotoent");
#endif

    EXTEND(SP, 3);
    if (GIMME_V != G_ARRAY) {
	PUSHs(sv = sv_newmortal());
	if (pent) {
	    if (which == OP_GPBYNAME)
		sv_setiv(sv, (IV)pent->p_proto);
	    else
		sv_setpv(sv, pent->p_name);
	}
	RETURN;
    }

    if (pent) {
	mPUSHs(newSVpv(pent->p_name, 0));
	PUSHs(space_join_names_mortal(pent->p_aliases));
	mPUSHi(pent->p_proto);
    }

    RETURN;
#else
    DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
#endif
}


/* also used for: pp_gsbyname() pp_gsbyport() */

PP(pp_gservent)
{
#if defined(HAS_GETSERVBYNAME) || defined(HAS_GETSERVBYPORT) || defined(HAS_GETSERVENT)
    dSP;
    I32 which = PL_op->op_type;
    SV *sv;
#ifndef HAS_GETSERV_PROTOS /* XXX Do we need individual probes? */
    struct servent *getservbyname(Netdb_name_t, Netdb_name_t);
    struct servent *getservbyport(int, Netdb_name_t);
    struct servent *getservent(void);
#endif
    struct servent *sent;

    if (which == OP_GSBYNAME) {
#ifdef HAS_GETSERVBYNAME
	const char * const proto = POPpbytex;
	const char * const name = POPpbytex;
	sent = PerlSock_getservbyname(name, (proto && !*proto) ? NULL : proto);
#else
	DIE(aTHX_ PL_no_sock_func, "getservbyname");
#endif
    }
    else if (which == OP_GSBYPORT) {
#ifdef HAS_GETSERVBYPORT
	const char * const proto = POPpbytex;
	unsigned short port = (unsigned short)POPu;
	port = PerlSock_htons(port);
	sent = PerlSock_getservbyport(port, (proto && !*proto) ? NULL : proto);
#else
	DIE(aTHX_ PL_no_sock_func, "getservbyport");
#endif
    }
    else
#ifdef HAS_GETSERVENT
	sent = PerlSock_getservent();
#else
	DIE(aTHX_ PL_no_sock_func, "getservent");
#endif

    EXTEND(SP, 4);
    if (GIMME_V != G_ARRAY) {
	PUSHs(sv = sv_newmortal());
	if (sent) {
	    if (which == OP_GSBYNAME) {
		sv_setiv(sv, (IV)PerlSock_ntohs(sent->s_port));
	    }
	    else
		sv_setpv(sv, sent->s_name);
	}
	RETURN;
    }

    if (sent) {
	mPUSHs(newSVpv(sent->s_name, 0));
	PUSHs(space_join_names_mortal(sent->s_aliases));
	mPUSHi(PerlSock_ntohs(sent->s_port));
	mPUSHs(newSVpv(sent->s_proto, 0));
    }

    RETURN;
#else
    DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
#endif
}


/* also used for: pp_snetent() pp_sprotoent() pp_sservent() */

PP(pp_shostent)
{
    dSP;
    const int stayopen = TOPi;
    switch(PL_op->op_type) {
    case OP_SHOSTENT:
#ifdef HAS_SETHOSTENT
	PerlSock_sethostent(stayopen);
#else
	DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
#endif
	break;
#ifdef HAS_SETNETENT
    case OP_SNETENT:
	PerlSock_setnetent(stayopen);
#else
	DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
#endif
	break;
    case OP_SPROTOENT:
#ifdef HAS_SETPROTOENT
	PerlSock_setprotoent(stayopen);
#else
	DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
#endif
	break;
    case OP_SSERVENT:
#ifdef HAS_SETSERVENT
	PerlSock_setservent(stayopen);
#else
	DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
#endif
	break;
    }
    RETSETYES;
}


/* also used for: pp_egrent() pp_enetent() pp_eprotoent() pp_epwent()
 *                pp_eservent() pp_sgrent() pp_spwent() */

PP(pp_ehostent)
{
    dSP;
    switch(PL_op->op_type) {
    case OP_EHOSTENT:
#ifdef HAS_ENDHOSTENT
	PerlSock_endhostent();
#else
	DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
#endif
	break;
    case OP_ENETENT:
#ifdef HAS_ENDNETENT
	PerlSock_endnetent();
#else
	DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
#endif
	break;
    case OP_EPROTOENT:
#ifdef HAS_ENDPROTOENT
	PerlSock_endprotoent();
#else
	DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
#endif
	break;
    case OP_ESERVENT:
#ifdef HAS_ENDSERVENT
	PerlSock_endservent();
#else
	DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
#endif
	break;
    case OP_SGRENT:
#if defined(HAS_GROUP) && defined(HAS_SETGRENT)
	setgrent();
#else
	DIE(aTHX_ PL_no_func, PL_op_desc[PL_op->op_type]);
#endif
	break;
    case OP_EGRENT:
#if defined(HAS_GROUP) && defined(HAS_ENDGRENT)
	endgrent();
#else
	DIE(aTHX_ PL_no_func, PL_op_desc[PL_op->op_type]);
#endif
	break;
    case OP_SPWENT:
#if defined(HAS_PASSWD) && defined(HAS_SETPWENT)
	setpwent();
#else
	DIE(aTHX_ PL_no_func, PL_op_desc[PL_op->op_type]);
#endif
	break;
    case OP_EPWENT:
#if defined(HAS_PASSWD) && defined(HAS_ENDPWENT)
	endpwent();
#else
	DIE(aTHX_ PL_no_func, PL_op_desc[PL_op->op_type]);
#endif
	break;
    }
    EXTEND(SP,1);
    RETPUSHYES;
}


/* also used for: pp_gpwnam() pp_gpwuid() */

PP(pp_gpwent)
{
#ifdef HAS_PASSWD
    dSP;
    I32 which = PL_op->op_type;
    SV *sv;
    struct passwd *pwent  = NULL;
    /*
     * We currently support only the SysV getsp* shadow password interface.
     * The interface is declared in <shadow.h> and often one needs to link
     * with -lsecurity or some such.
     * This interface is used at least by Solaris, HP-UX, IRIX, and Linux.
     * (and SCO?)
     *
     * AIX getpwnam() is clever enough to return the encrypted password
     * only if the caller (euid?) is root.
     *
     * There are at least three other shadow password APIs.  Many platforms
     * seem to contain more than one interface for accessing the shadow
     * password databases, possibly for compatibility reasons.
     * The getsp*() is by far he simplest one, the other two interfaces
     * are much more complicated, but also very similar to each other.
     *
     * <sys/types.h>
     * <sys/security.h>
     * <prot.h>
     * struct pr_passwd *getprpw*();
     * The password is in
     * char getprpw*(...).ufld.fd_encrypt[]
     * Mention HAS_GETPRPWNAM here so that Configure probes for it.
     *
     * <sys/types.h>
     * <sys/security.h>
     * <prot.h>
     * struct es_passwd *getespw*();
     * The password is in
     * char *(getespw*(...).ufld.fd_encrypt)
     * Mention HAS_GETESPWNAM here so that Configure probes for it.
     *
     * <userpw.h> (AIX)
     * struct userpw *getuserpw();
     * The password is in
     * char *(getuserpw(...)).spw_upw_passwd
     * (but the de facto standard getpwnam() should work okay)
     *
     * Mention I_PROT here so that Configure probes for it.
     *
     * In HP-UX for getprpw*() the manual page claims that one should include
     * <hpsecurity.h> instead of <sys/security.h>, but that is not needed
     * if one includes <shadow.h> as that includes <hpsecurity.h>,
     * and pp_sys.c already includes <shadow.h> if there is such.
     *
     * Note that <sys/security.h> is already probed for, but currently
     * it is only included in special cases.
     *
     * In Digital UNIX/Tru64 if using the getespw*() (which seems to be
     * be preferred interface, even though also the getprpw*() interface
     * is available) one needs to link with -lsecurity -ldb -laud -lm.
     * One also needs to call set_auth_parameters() in main() before
     * doing anything else, whether one is using getespw*() or getprpw*().
     *
     * Note that accessing the shadow databases can be magnitudes
     * slower than accessing the standard databases.
     *
     * --jhi
     */

#   if defined(__CYGWIN__) && defined(USE_REENTRANT_API)
    /* Cygwin 1.5.3-1 has buggy getpwnam_r() and getpwuid_r():
     * the pw_comment is left uninitialized. */
    PL_reentrant_buffer->_pwent_struct.pw_comment = NULL;
#   endif

    switch (which) {
    case OP_GPWNAM:
      {
	const char* const name = POPpbytex;
	pwent  = getpwnam(name);
      }
      break;
    case OP_GPWUID:
      {
	Uid_t uid = POPi;
	pwent = getpwuid(uid);
      }
	break;
    case OP_GPWENT:
#   ifdef HAS_GETPWENT
	pwent  = getpwent();
#ifdef POSIX_BC   /* In some cases pw_passwd has invalid addresses */
	if (pwent) pwent = getpwnam(pwent->pw_name);
#endif
#   else
	DIE(aTHX_ PL_no_func, "getpwent");
#   endif
	break;
    }

    EXTEND(SP, 10);
    if (GIMME_V != G_ARRAY) {
	PUSHs(sv = sv_newmortal());
	if (pwent) {
	    if (which == OP_GPWNAM)
	        sv_setuid(sv, pwent->pw_uid);
	    else
		sv_setpv(sv, pwent->pw_name);
	}
	RETURN;
    }

    if (pwent) {
	mPUSHs(newSVpv(pwent->pw_name, 0));

	sv = newSViv(0);
	mPUSHs(sv);
	/* If we have getspnam(), we try to dig up the shadow
	 * password.  If we are underprivileged, the shadow
	 * interface will set the errno to EACCES or similar,
	 * and return a null pointer.  If this happens, we will
	 * use the dummy password (usually "*" or "x") from the
	 * standard password database.
	 *
	 * In theory we could skip the shadow call completely
	 * if euid != 0 but in practice we cannot know which
	 * security measures are guarding the shadow databases
	 * on a random platform.
	 *
	 * Resist the urge to use additional shadow interfaces.
	 * Divert the urge to writing an extension instead.
	 *
	 * --jhi */
	/* Some AIX setups falsely(?) detect some getspnam(), which
	 * has a different API than the Solaris/IRIX one. */
#   if defined(HAS_GETSPNAM) && !defined(_AIX)
	{
	    dSAVE_ERRNO;
	    const struct spwd * const spwent = getspnam(pwent->pw_name);
			  /* Save and restore errno so that
			   * underprivileged attempts seem
			   * to have never made the unsuccessful
			   * attempt to retrieve the shadow password. */
	    RESTORE_ERRNO;
	    if (spwent && spwent->sp_pwdp)
		sv_setpv(sv, spwent->sp_pwdp);
	}
#   endif
#   ifdef PWPASSWD
	if (!SvPOK(sv)) /* Use the standard password, then. */
	    sv_setpv(sv, pwent->pw_passwd);
#   endif

	/* passwd is tainted because user himself can diddle with it.
	 * admittedly not much and in a very limited way, but nevertheless. */
	SvTAINTED_on(sv);

        sv_setuid(PUSHmortal, pwent->pw_uid);
        sv_setgid(PUSHmortal, pwent->pw_gid);

	/* pw_change, pw_quota, and pw_age are mutually exclusive--
	 * because of the poor interface of the Perl getpw*(),
	 * not because there's some standard/convention saying so.
	 * A better interface would have been to return a hash,
	 * but we are accursed by our history, alas. --jhi.  */
#   ifdef PWCHANGE
	mPUSHi(pwent->pw_change);
#   else
#       ifdef PWQUOTA
	mPUSHi(pwent->pw_quota);
#       else
#           ifdef PWAGE
	mPUSHs(newSVpv(pwent->pw_age, 0));
#	    else
	/* I think that you can never get this compiled, but just in case.  */
	PUSHs(sv_mortalcopy(&PL_sv_no));
#           endif
#       endif
#   endif

	/* pw_class and pw_comment are mutually exclusive--.
	 * see the above note for pw_change, pw_quota, and pw_age. */
#   ifdef PWCLASS
	mPUSHs(newSVpv(pwent->pw_class, 0));
#   else
#       ifdef PWCOMMENT
	mPUSHs(newSVpv(pwent->pw_comment, 0));
#	else
	/* I think that you can never get this compiled, but just in case.  */
	PUSHs(sv_mortalcopy(&PL_sv_no));
#       endif
#   endif

#   ifdef PWGECOS
	PUSHs(sv = sv_2mortal(newSVpv(pwent->pw_gecos, 0)));
#   else
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
#   endif
	/* pw_gecos is tainted because user himself can diddle with it. */
	SvTAINTED_on(sv);

	mPUSHs(newSVpv(pwent->pw_dir, 0));

	PUSHs(sv = sv_2mortal(newSVpv(pwent->pw_shell, 0)));
	/* pw_shell is tainted because user himself can diddle with it. */
	SvTAINTED_on(sv);

#   ifdef PWEXPIRE
	mPUSHi(pwent->pw_expire);
#   endif
    }
    RETURN;
#else
    DIE(aTHX_ PL_no_func, PL_op_desc[PL_op->op_type]);
#endif
}


/* also used for: pp_ggrgid() pp_ggrnam() */

PP(pp_ggrent)
{
#ifdef HAS_GROUP
    dSP;
    const I32 which = PL_op->op_type;
    const struct group *grent;

    if (which == OP_GGRNAM) {
	const char* const name = POPpbytex;
	grent = (const struct group *)getgrnam(name);
    }
    else if (which == OP_GGRGID) {
#if Gid_t_sign == 1
	const Gid_t gid = POPu;
#elif Gid_t_sign == -1
	const Gid_t gid = POPi;
#else
#  error "Unexpected Gid_t_sign"
#endif
	grent = (const struct group *)getgrgid(gid);
    }
    else
#ifdef HAS_GETGRENT
	grent = (struct group *)getgrent();
#else
        DIE(aTHX_ PL_no_func, "getgrent");
#endif

    EXTEND(SP, 4);
    if (GIMME_V != G_ARRAY) {
	SV * const sv = sv_newmortal();

	PUSHs(sv);
	if (grent) {
	    if (which == OP_GGRNAM)
		sv_setgid(sv, grent->gr_gid);
	    else
		sv_setpv(sv, grent->gr_name);
	}
	RETURN;
    }

    if (grent) {
	mPUSHs(newSVpv(grent->gr_name, 0));

#ifdef GRPASSWD
	mPUSHs(newSVpv(grent->gr_passwd, 0));
#else
	PUSHs(sv_mortalcopy(&PL_sv_no));
#endif

        sv_setgid(PUSHmortal, grent->gr_gid);

#if !(defined(_CRAYMPP) && defined(USE_REENTRANT_API))
	/* In UNICOS/mk (_CRAYMPP) the multithreading
	 * versions (getgrnam_r, getgrgid_r)
	 * seem to return an illegal pointer
	 * as the group members list, gr_mem.
	 * getgrent() doesn't even have a _r version
	 * but the gr_mem is poisonous anyway.
	 * So yes, you cannot get the list of group
	 * members if building multithreaded in UNICOS/mk. */
	PUSHs(space_join_names_mortal(grent->gr_mem));
#endif
    }

    RETURN;
#else
    DIE(aTHX_ PL_no_func, PL_op_desc[PL_op->op_type]);
#endif
}

PP(pp_getlogin)
{
#ifdef HAS_GETLOGIN
    dSP; dTARGET;
    char *tmps;
    EXTEND(SP, 1);
    if (!(tmps = PerlProc_getlogin()))
	RETPUSHUNDEF;
    sv_setpv_mg(TARG, tmps);
    PUSHs(TARG);
    RETURN;
#else
    DIE(aTHX_ PL_no_func, "getlogin");
#endif
}

/* Miscellaneous. */

PP(pp_syscall)
{
#ifdef HAS_SYSCALL
    dSP; dMARK; dORIGMARK; dTARGET;
    I32 items = SP - MARK;
    unsigned long a[20];
    I32 i = 0;
    IV retval = -1;

    if (TAINTING_get) {
	while (++MARK <= SP) {
	    if (SvTAINTED(*MARK)) {
		TAINT;
		break;
	    }
	}
	MARK = ORIGMARK;
	TAINT_PROPER("syscall");
    }

    /* This probably won't work on machines where sizeof(long) != sizeof(int)
     * or where sizeof(long) != sizeof(char*).  But such machines will
     * not likely have syscall implemented either, so who cares?
     */
    while (++MARK <= SP) {
	if (SvNIOK(*MARK) || !i)
	    a[i++] = SvIV(*MARK);
	else if (*MARK == &PL_sv_undef)
	    a[i++] = 0;
	else
	    a[i++] = (unsigned long)SvPV_force_nolen(*MARK);
	if (i > 15)
	    break;
    }
    switch (items) {
    default:
	DIE(aTHX_ "Too many args to syscall");
    case 0:
	DIE(aTHX_ "Too few args to syscall");
    case 1:
	retval = syscall(a[0]);
	break;
    case 2:
	retval = syscall(a[0],a[1]);
	break;
    case 3:
	retval = syscall(a[0],a[1],a[2]);
	break;
    case 4:
	retval = syscall(a[0],a[1],a[2],a[3]);
	break;
    case 5:
	retval = syscall(a[0],a[1],a[2],a[3],a[4]);
	break;
    case 6:
	retval = syscall(a[0],a[1],a[2],a[3],a[4],a[5]);
	break;
    case 7:
	retval = syscall(a[0],a[1],a[2],a[3],a[4],a[5],a[6]);
	break;
    case 8:
	retval = syscall(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7]);
	break;
    }
    SP = ORIGMARK;
    PUSHi(retval);
    RETURN;
#else
    DIE(aTHX_ PL_no_func, "syscall");
#endif
}

#ifdef FCNTL_EMULATE_FLOCK

/*  XXX Emulate flock() with fcntl().
    What's really needed is a good file locking module.
*/

static int
fcntl_emulate_flock(int fd, int operation)
{
    int res;
    struct flock flock;

    switch (operation & ~LOCK_NB) {
    case LOCK_SH:
	flock.l_type = F_RDLCK;
	break;
    case LOCK_EX:
	flock.l_type = F_WRLCK;
	break;
    case LOCK_UN:
	flock.l_type = F_UNLCK;
	break;
    default:
	errno = EINVAL;
	return -1;
    }
    flock.l_whence = SEEK_SET;
    flock.l_start = flock.l_len = (Off_t)0;

    res = fcntl(fd, (operation & LOCK_NB) ? F_SETLK : F_SETLKW, &flock);
    if (res == -1 && ((errno == EAGAIN) || (errno == EACCES)))
	errno = EWOULDBLOCK;
    return res;
}

#endif /* FCNTL_EMULATE_FLOCK */

#ifdef LOCKF_EMULATE_FLOCK

/*  XXX Emulate flock() with lockf().  This is just to increase
    portability of scripts.  The calls are not completely
    interchangeable.  What's really needed is a good file
    locking module.
*/

/*  The lockf() constants might have been defined in <unistd.h>.
    Unfortunately, <unistd.h> causes troubles on some mixed
    (BSD/POSIX) systems, such as SunOS 4.1.3.

   Further, the lockf() constants aren't POSIX, so they might not be
   visible if we're compiling with _POSIX_SOURCE defined.  Thus, we'll
   just stick in the SVID values and be done with it.  Sigh.
*/

# ifndef F_ULOCK
#  define F_ULOCK	0	/* Unlock a previously locked region */
# endif
# ifndef F_LOCK
#  define F_LOCK	1	/* Lock a region for exclusive use */
# endif
# ifndef F_TLOCK
#  define F_TLOCK	2	/* Test and lock a region for exclusive use */
# endif
# ifndef F_TEST
#  define F_TEST	3	/* Test a region for other processes locks */
# endif

static int
lockf_emulate_flock(int fd, int operation)
{
    int i;
    Off_t pos;
    dSAVE_ERRNO;

    /* flock locks entire file so for lockf we need to do the same	*/
    pos = PerlLIO_lseek(fd, (Off_t)0, SEEK_CUR);    /* get pos to restore later */
    if (pos > 0)	/* is seekable and needs to be repositioned	*/
	if (PerlLIO_lseek(fd, (Off_t)0, SEEK_SET) < 0)
	    pos = -1;	/* seek failed, so don't seek back afterwards	*/
    RESTORE_ERRNO;

    switch (operation) {

	/* LOCK_SH - get a shared lock */
	case LOCK_SH:
	/* LOCK_EX - get an exclusive lock */
	case LOCK_EX:
	    i = lockf (fd, F_LOCK, 0);
	    break;

	/* LOCK_SH|LOCK_NB - get a non-blocking shared lock */
	case LOCK_SH|LOCK_NB:
	/* LOCK_EX|LOCK_NB - get a non-blocking exclusive lock */
	case LOCK_EX|LOCK_NB:
	    i = lockf (fd, F_TLOCK, 0);
	    if (i == -1)
		if ((errno == EAGAIN) || (errno == EACCES))
		    errno = EWOULDBLOCK;
	    break;

	/* LOCK_UN - unlock (non-blocking is a no-op) */
	case LOCK_UN:
	case LOCK_UN|LOCK_NB:
	    i = lockf (fd, F_ULOCK, 0);
	    break;

	/* Default - can't decipher operation */
	default:
	    i = -1;
	    errno = EINVAL;
	    break;
    }

    if (pos > 0)      /* need to restore position of the handle	*/
	PerlLIO_lseek(fd, pos, SEEK_SET);	/* ignore error here	*/

    return (i);
}

#endif /* LOCKF_EMULATE_FLOCK */

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.18
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@a32 1
#include "time64.c"
a180 4
#if defined(HAS_FCNTL) && defined(F_SETFD) && !defined(FD_CLOEXEC)
#  define FD_CLOEXEC 1		/* NeXT needs this */
#endif

d195 4
d297 1
a297 1
    dVAR; dSP; dTARGET;
d300 1
a300 1
    const I32 gimme = GIMME_V;
a357 1
    dVAR;
a416 1
    dVAR;
d423 1
a423 1
    dVAR; dSP; dMARK;
d472 1
a472 1
    dVAR; dSP; dMARK;
d523 3
a525 1
    return die_sv(exsv);
d536 1
d541 3
a543 3
    assert((TIED_METHOD_MORTALIZE_NOT_NEEDED & G_WANT) == 0);
    assert((TIED_METHOD_ARGUMENTS_ON_STACK & G_WANT) == 0);
    assert((TIED_METHOD_SAY & G_WANT) == 0);
d547 14
a560 1
    EXTEND(SP, argc+1); /* object + args */
d613 1
a613 1
    dVAR; dSP;
d667 1
a667 1
    dVAR; dSP;
a689 1
    dVAR;
a697 2
    assert (isGV_with_GP(rgv));
    assert (isGV_with_GP(wgv));
d727 5
a731 3
#if defined(HAS_FCNTL) && defined(F_SETFD)
    fcntl(fd[0],F_SETFD,fd[0] > PL_maxsysfd);	/* ensure close-on-exec */
    fcntl(fd[1],F_SETFD,fd[1] > PL_maxsysfd);	/* ensure close-on-exec */
d735 1
a735 1
badexit:
d744 1
a744 1
    dVAR; dSP; dTARGET;
d761 16
a791 1
    dVAR;
d822 1
a822 1
    dVAR; dSP;
d883 1
a883 1
    dVAR; dSP; dMARK;
d931 1
a931 1
	    /* FALL THROUGH */
d988 3
d993 1
a993 1
    dVAR; dSP;
a1032 1
    dVAR;
d1035 1
a1035 1
    SV *sv = POPs;
d1040 1
a1040 1
	RETPUSHUNDEF;
d1043 1
a1043 1
	!(sv = defelem_target(sv, NULL))) RETPUSHUNDEF;
d1046 2
a1047 2
	PUSHs(SvTIED_obj(sv, mg));
	RETURN;
d1049 3
a1051 1
    RETPUSHUNDEF;
d1056 1
a1056 1
    dVAR; dSP;
d1100 2
d1103 2
a1104 2

    if (sv_isobject(TOPs)) {
d1115 1
a1115 1
    dVAR; dSP; dTARGET;
d1187 1
a1187 1
     * UNIX, Solaris, NeXT, Darwin) the smallest quantum select() operates
d1267 1
a1267 1
    if (GIMME == G_ARRAY && tbuf) {
d1279 3
d1284 2
a1285 2
Sets PL_defoutgv, the default file handle for output, to the passed in
typeglob.  As PL_defoutgv "owns" a reference on its typeglob, the reference
d1287 1
a1287 1
of the typeglob that PL_defoutgv points to is decreased by one.
d1295 2
a1296 1
    dVAR;
d1298 1
a1299 1
    SvREFCNT_dec(PL_defoutgv);
d1301 1
d1306 1
a1306 1
    dVAR; dSP; dTARGET;
d1337 1
a1337 1
    dVAR; dSP; dTARGET;
d1348 1
a1348 1
	    const U32 gimme = GIMME_V;
a1383 1
    dVAR;
d1385 1
a1385 1
    const I32 gimme = GIMME_V;
d1392 3
a1394 7
    ENTER;
    SAVETMPS;

    PUSHBLOCK(cx, CXt_FORMAT, PL_stack_sp);
    PUSHFORMAT(cx, retop);
    if (CvDEPTH(cv) >= 2) {
	PERL_STACK_OVERFLOW_CHECK();
a1395 2
    }
    SAVECOMPPAD();
a1403 1
    dVAR;
d1443 2
a1444 2
    dVAR; dSP;
    GV * const gv = cxstack[cxstack_ix].blk_format.gv;
a1447 2
    SV **newsp;
    I32 gimme;
d1450 1
d1452 1
a1452 1
    if (!io || !(ofp = IoOFP(io)))
d1524 6
a1529 1
    POPBLOCK(cx,PL_curpm);
d1531 1
a1531 3
    POPFORMAT(cx);
    SP = newsp; /* ignore retval of formline */
    LEAVE;
d1533 7
a1539 1
    if (!io || !(fp = IoOFP(io))) {
a1561 1
    PERL_UNUSED_VAR(gimme);
d1567 1
a1567 1
    dVAR; dSP; dMARK; dORIGMARK;
a1627 1
    dVAR;
d1647 3
d1652 1
a1652 1
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
d1669 2
a1671 1
    GV * const gv = MUTABLE_GV(*++MARK);
d1702 4
d1707 5
d1734 4
d1749 1
a1749 1
	count = PerlSock_recvfrom(PerlIO_fileno(IoIFP(io)), buffer, length, offset,
d1791 1
d1793 3
d1801 1
a1801 1
       PL_encoding is true) */
d1825 6
a1830 2
	    count = PerlSock_recv(PerlIO_fileno(IoIFP(io)),
				   buffer, length, 0);
d1835 6
a1840 2
	    count = PerlLIO_read(PerlIO_fileno(IoIFP(io)),
				  buffer, length);
d1911 3
d1916 1
a1916 1
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
d1927 1
d1958 6
d1971 3
d2001 1
a2001 1
	    retval = PerlSock_sendto(PerlIO_fileno(IoIFP(io)), buffer, blen,
d2005 1
a2005 2
	    retval
		= PerlSock_send(PerlIO_fileno(IoIFP(io)), buffer, blen, flags);
d2088 1
a2088 2
	    retval = PerlSock_send(PerlIO_fileno(IoIFP(io)),
				   buffer, length, 0);
d2094 1
a2094 2
	    retval = PerlLIO_write(PerlIO_fileno(IoIFP(io)),
				   buffer, length);
d2120 1
a2120 1
    dVAR; dSP;
d2163 1
d2167 6
a2172 2
		if (GvSV(gv))
		    sv_setpvs(GvSV(gv), "-");
d2174 1
a2174 2
		    GvSV(gv) = newSVpvs("-");
		SvSETMAGIC(GvSV(gv));
d2176 1
a2176 1
	    else if (!nextargv(gv))
d2187 1
a2187 1
    dVAR; dSP; dTARGET;
d2219 3
d2224 1
a2224 1
    dVAR; dSP;
a2270 1
    dVAR;
d2308 10
a2317 1
		    PerlIO_flush(fp);
d2319 1
a2319 1
		    if (ftruncate(PerlIO_fileno(fp), len) < 0)
d2321 1
a2321 1
		    if (my_chsize(PerlIO_fileno(fp), len) < 0)
d2323 3
a2325 1
			result = 0;
d2341 2
a2342 1
		const int tmpfd = PerlLIO_open(name, O_RDWR);
d2344 13
a2356 1
		if (tmpfd < 0)
d2358 1
a2358 1
		else {
d2375 3
d2380 1
a2380 1
    dVAR; dSP; dTARGET;
d2456 1
a2456 1
    dVAR; dSP; dTARGET;
d2476 1
a2476 1
    DIE(aTHX_ PL_no_func, "flock()");
d2486 1
a2486 1
    dVAR; dSP;
d2499 2
a2500 1
    if (fd < 0)
d2502 1
d2512 4
a2515 2
#if defined(HAS_FCNTL) && defined(F_SETFD)
    fcntl(fd, F_SETFD, fd > PL_maxsysfd);	/* ensure close-on-exec */
d2525 1
a2525 1
    dVAR; dSP;
d2559 5
a2563 3
#if defined(HAS_FCNTL) && defined(F_SETFD)
    fcntl(fd[0],F_SETFD,fd[0] > PL_maxsysfd);	/* ensure close-on-exec */
    fcntl(fd[1],F_SETFD,fd[1] > PL_maxsysfd);	/* ensure close-on-exec */
d2574 2
d2578 1
a2578 1
    dVAR; dSP;
d2586 1
d2590 3
d2598 2
a2599 2
	 ? PerlSock_bind(PerlIO_fileno(IoIFP(io)), (struct sockaddr *)addr, len)
	 : PerlSock_connect(PerlIO_fileno(IoIFP(io)), (struct sockaddr *)addr, len))
d2605 1
a2605 1
nuts:
d2613 1
a2613 1
    dVAR; dSP;
d2626 1
a2626 1
nuts:
d2634 1
a2634 1
    dVAR; dSP; dTARGET;
d2676 4
a2679 2
#if defined(HAS_FCNTL) && defined(F_SETFD)
    fcntl(fd, F_SETFD, fd > PL_maxsysfd);	/* ensure close-on-exec */
d2689 1
a2689 1
nuts:
d2693 1
a2693 1
badexit:
d2700 1
a2700 1
    dVAR; dSP; dTARGET;
d2711 1
a2711 1
nuts:
d2717 3
d2722 1
a2722 1
    dVAR; dSP;
d2736 2
d2791 1
a2791 1
nuts:
d2794 1
a2794 1
nuts2:
d2799 3
d2804 1
a2804 1
    dVAR; dSP;
d2821 2
d2855 1
a2855 1
nuts:
d2858 1
a2858 1
nuts2:
d2866 2
a2869 1
    dVAR;
d2873 1
a2873 1
    I32 gimme;
d2905 8
a2912 3
                        PL_laststatval = 
                            PerlLIO_fstat(PerlIO_fileno(IoIFP(io)), &PL_statcache);   
                        havefp = TRUE;
d2930 1
d2942 1
d2944 1
a2944 1
	    PL_laststatval = PerlLIO_lstat(SvPV_nolen_const(PL_statname), &PL_statcache);
d2946 1
a2946 1
	    PL_laststatval = PerlLIO_stat(SvPV_nolen_const(PL_statname), &PL_statcache);
d2948 1
a2948 3
	    if (ckWARN(WARN_NEWLINE) &&
                    strchr(SvPV_nolen_const(PL_statname), '\n'))
            {
a3068 1
    dVAR;
d3091 3
a3095 1
    dVAR;
d3098 1
a3098 1
       no guarantee that OPp_FT_ACCESS is <= CHAR_MAX  */
d3157 1
a3157 1
	/* fall through */
d3211 3
a3215 1
    dVAR;
d3265 5
a3271 1
    dVAR;
a3372 1
    dVAR;
a3386 1
    dVAR;
d3391 1
d3407 2
a3408 2
    else if (name && isDIGIT(*name))
	    fd = atoi(name);
d3411 4
d3420 3
a3424 1
    dVAR;
d3465 1
d3468 6
a3473 1
	    PL_laststatval = PerlLIO_fstat(PerlIO_fileno(IoIFP(io)), &PL_statcache);
d3486 3
a3489 2
	    if (PerlIO_get_cnt(IoIFP(io)) <= 0)	/* null file is anything */
		FT_RETURNYES;
d3504 4
d3510 1
d3512 1
a3512 1
	if (!(fp = PerlIO_open(SvPVX_const(PL_statname), "r"))) {
d3517 1
a3517 3
	    if (ckWARN(WARN_NEWLINE) && strchr(SvPV_nolen_const(PL_statname),
					       '\n'))
            {
d3526 7
a3532 1
	PL_laststatval = PerlLIO_fstat(PerlIO_fileno(fp), &PL_statcache);
d3535 1
a3549 1
    /*   XXX ASCII dependent code */
d3557 22
d3584 3
a3586 7
#ifdef EBCDIC
        else if (!(isPRINT(*s) || isSPACE(*s)))
            odd++;
#else
	else if (*s & 128) {
#ifdef USE_LOCALE
	    if (IN_LOCALE_RUNTIME && isALPHA_LC(*s))
d3588 3
d3592 12
a3603 23
	    /* utf8 characters don't count as odd */
	    if (UTF8_IS_START(*s)) {
		int ulen = UTF8SKIP(s);
		if (ulen < len - i) {
		    int j;
		    for (j = 1; j < ulen; j++) {
			if (!UTF8_IS_CONTINUATION(s[j]))
			    goto not_utf8;
		    }
		    --ulen;	/* loop does extra increment */
		    s += ulen;
		    i += ulen;
		    continue;
		}
	    }
	  not_utf8:
	    odd++;
	}
	else if (*s < 32 &&
	  *s != '\n' && *s != '\r' && *s != '\b' &&
	  *s != '\t' && *s != '\f' && *s != 27)
	    odd++;
#endif
d3616 1
a3616 1
    dVAR; dSP; dTARGET;
d3624 10
d3638 1
a3638 2

    if( !gv && (!tmps || !*tmps) ) {
a3648 2
            if( MAXARG == 1 )
                deprecate("chdir('') or chdir(undef) as chdir()");
d3653 1
d3667 5
a3671 1
                PUSHi(fchdir(PerlIO_fileno(IoIFP(io))) >= 0);
d3674 1
a3674 3
		report_evil_fh(gv);
		SETERRNO(EBADF, RMS_IFI);
		PUSHi(0);
d3676 2
d3679 1
a3679 5
	else {
	    report_evil_fh(gv);
	    SETERRNO(EBADF,RMS_IFI);
	    PUSHi(0);
	}
d3692 8
d3702 3
d3707 1
a3707 1
    dVAR; dSP; dMARK; dTARGET;
d3718 1
a3718 1
    dVAR; dSP; dTARGET;
d3730 1
a3730 1
    dVAR; dSP; dTARGET;
d3732 3
d3741 1
a3741 1
    if (!(anum = PerlLIO_stat(tmps, &PL_statbuf))) {
d3745 1
a3745 1
	    if (PerlProc_geteuid() || PerlLIO_stat(tmps2, &PL_statbuf) < 0 || !S_ISDIR(PL_statbuf.st_mode))
d3756 3
d3762 1
a3762 1
    dVAR; dSP; dTARGET;
d3801 3
a3812 1
    dVAR;
d3818 1
a3818 1
    int len;
d3822 2
d3827 2
d3907 2
a3908 1
	    anum = (PerlLIO_stat(save_filename, &PL_statbuf) >= 0);
d3945 1
a3945 1
    dVAR; dSP; dTARGET;
d3949 1
a3949 1
    const int mode = (MAXARG > 1 && (TOPs||((void)POPs,0))) ? POPi : 0777;
d3972 1
a3972 1
    dVAR; dSP; dTARGET;
d3994 1
a3994 1
    dVAR; dSP;
d4009 1
a4009 1
nope:
a4025 1
    dVAR;
d4029 1
a4029 1
    const I32 gimme = GIMME;
d4060 1
a4060 1
nope:
d4063 1
a4063 1
    if (GIMME == G_ARRAY)
d4073 1
a4073 1
    dVAR; dSP; dTARGET;
d4093 1
a4093 1
nope:
d4105 1
a4105 1
    dVAR; dSP;
d4119 1
a4119 1
nope:
d4131 1
a4131 1
    dVAR; dSP;
d4143 1
a4143 1
nope:
d4155 1
a4155 1
    dVAR; dSP;
d4176 1
a4176 1
nope:
d4190 1
a4190 1
    dVAR; dSP; dTARGET;
d4227 1
a4227 1
#  if defined(USE_ITHREADS) && defined(PERL_IMPLICIT_SYS)
d4247 1
a4247 1
    dVAR; dSP; dTARGET;
d4275 1
a4275 1
    dVAR; dSP; dTARGET;
d4279 6
d4301 1
d4311 1
a4311 1
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
d4318 3
d4322 1
d4335 1
a4335 1
#if (defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(OS2) || defined(PERL_MICRO)
d4337 4
d4342 1
d4345 1
d4352 10
d4383 3
a4385 1
	if (childpid > 0) {
d4389 1
d4392 1
d4397 3
d4403 1
d4432 8
a4439 1
		    STATUS_NATIVE_CHILD_SET(-1);
d4445 1
d4451 3
a4453 2
#if defined(HAS_FCNTL) && defined(F_SETFD)
	    fcntl(pp[1], F_SETFD, FD_CLOEXEC);
d4465 1
d4502 1
a4502 1
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
d4515 1
a4533 1

d4542 1
a4542 1
    dVAR; dSP; dTARGET;
d4553 1
a4553 1
    dVAR; dSP; dTARGET;
d4568 1
a4568 1
    DIE(aTHX_ PL_no_func, "getpgrp()");
d4575 1
a4575 1
    dVAR; dSP; dTARGET;
d4582 2
a4583 1
	XPUSHi(-1);
d4599 1
a4599 1
    DIE(aTHX_ PL_no_func, "setpgrp()");
d4612 1
a4612 1
    dVAR; dSP; dTARGET;
d4618 1
a4618 1
    DIE(aTHX_ PL_no_func, "getpriority()");
d4625 1
a4625 1
    dVAR; dSP; dTARGET;
d4633 1
a4633 1
    DIE(aTHX_ PL_no_func, "setpriority()");
d4643 1
a4643 1
    dVAR; dSP; dTARGET;
a4654 1
    dVAR;
d4662 1
a4662 1
    if (GIMME == G_ARRAY) {
d4673 1
a4673 1
    if (GIMME == G_ARRAY) {
d4694 3
a4698 1
    dVAR;
d4744 1
a4744 1
	    err = S_localtime64_r(&when, &tmbuf);
d4746 1
a4746 1
	    err = S_gmtime64_r(&when, &tmbuf);
d4757 1
a4757 1
    if (GIMME != G_ARRAY) {	/* scalar context */
a4758 1
        EXTEND_MORTAL(1);
d4762 3
a4764 1
           mPUSHs(Perl_newSVpvf(aTHX_ "%s %s %2d %02d:%02d:%02d %.0f",
d4771 1
a4771 3
                                /* XXX newSVpvf()'s %lld type is broken,
                                 * so cheat with a double */
                                (double)tmbuf.tm_year + 1900));
d4796 25
a4820 8
    dVAR; dSP; dTARGET;
    int anum;
    anum = POPi;
    anum = alarm((unsigned int)anum);
    if (anum < 0)
	RETPUSHUNDEF;
    PUSHi(anum);
    RETURN;
d4828 1
a4828 1
    dVAR; dSP; dTARGET;
d4838 10
a4847 1
	PerlProc_sleep((unsigned int)duration);
d4857 2
d4862 1
a4862 1
    dVAR; dSP; dMARK; dTARGET;
d4891 2
d4896 1
a4896 1
    dVAR; dSP; dMARK; dTARGET;
d4908 2
d4913 1
a4913 1
    dVAR; dSP; dMARK; dTARGET;
d4917 1
a4917 1
	RETSETUNDEF;
d4939 1
a4939 1
    if (array && *array) {
d4955 2
d4960 1
a4960 1
    dVAR; dSP;
d5011 1
a5011 1
    if (GIMME != G_ARRAY) {
d5047 2
d5052 1
a5052 1
    dVAR; dSP;
d5098 1
a5098 1
    if (GIMME != G_ARRAY) {
d5122 3
d5128 1
a5128 1
    dVAR; dSP;
d5162 1
a5162 1
    if (GIMME != G_ARRAY) {
d5185 3
d5191 1
a5191 1
    dVAR; dSP;
d5228 1
a5228 1
    if (GIMME != G_ARRAY) {
d5253 3
d5258 1
a5258 1
    dVAR; dSP;
d5293 4
d5299 1
a5299 1
    dVAR; dSP;
d5362 3
d5368 1
a5368 1
    dVAR; dSP;
d5464 1
a5464 1
    if (GIMME != G_ARRAY) {
d5580 3
d5586 1
a5586 1
    dVAR; dSP;
d5595 3
d5599 3
d5612 1
a5612 1
    if (GIMME != G_ARRAY) {
d5658 1
a5658 1
    dVAR; dSP; dTARGET;
d5676 1
a5676 1
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
a5866 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.17
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d4327 1
a4327 1
    if (MAXARG > 0) pid = TOPs && TOPi;
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d2620 5
d4463 1
d4465 1
a4465 1
	if (when != input) {
d4469 4
d4498 1
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d479 2
a480 1
    VMSISH_HUSHED  = VMSISH_HUSHED || (PL_op->op_private & OPpHUSH_VMSISH);
d532 1
a532 1
Perl_tied_method(pTHX_ const char *const methname, SV **sp, SV *const sv,
d576 1
a576 1
    ret_args = call_method(methname, flags & G_WANT);
d627 1
a627 1
	    return Perl_tied_method(aTHX_ "OPEN", mark - 1, MUTABLE_SV(io), mg,
d641 1
a641 1
    ok = do_openn(gv, tmps, len, FALSE, O_RDONLY, 0, NULL, MARK+1, (SP-MARK));
d666 1
a666 1
		return tied_method0("CLOSE", SP, MUTABLE_SV(io), mg);
d686 2
a687 5
    if (!rgv || !wgv)
	goto badexit;

    if (!isGV_with_GP(rgv) || !isGV_with_GP(wgv))
	DIE(aTHX_ PL_no_usym, "filehandle");
a688 2
    wstio = GvIOn(wgv);

d691 2
d746 1
a746 1
	return tied_method0("FILENO", SP, MUTABLE_SV(io), mg);
d817 1
a817 1
	    return Perl_tied_method(aTHX_ "BINMODE", SP, MUTABLE_SV(io), mg,
d900 4
d972 3
d1013 3
d1113 2
a1114 3
	if (SvIsCOW(sv))
		sv_force_normal_flags(sv, 0);
	if (SvREADONLY(sv) && !(SvPOK(sv) && SvCUR(sv) == 0))
d1116 2
d1160 1
d1162 1
a1162 1
	value = SvNV(sv);
d1249 1
a1249 1
typeglob. As PL_defoutgv "owns" a reference on its typeglob, the reference
d1311 1
a1311 1
	    Perl_tied_method(aTHX_ "GETC", SP, MUTABLE_SV(io), mg, gimme, 0);
d1338 1
d1352 1
a1352 1
    if (cv && CvCLONE(cv))
d1382 1
a1383 1
	EXTEND(SP, 1);
d1484 1
a1484 2
	if (!fgv)
	    DIE(aTHX_ "bad top format reference");
d1496 1
a1497 1
    retop = cx->blk_sub.retop;
d1549 1
a1549 1
	    return Perl_tied_method(aTHX_ "PRINTF", mark - 1, MUTABLE_SV(io),
d1601 1
a1601 2
    /* FIXME? do_open should do const  */
    if (do_open(gv, tmps, len, TRUE, mode, perm, NULL)) {
d1637 1
a1637 1
	    return Perl_tied_method(aTHX_ "READ", mark - 1, MUTABLE_SV(io), mg,
d1713 8
a1778 14
#ifdef HAS_SOCKET__bad_code_maybe
    if (IoTYPE(io) == IoTYPE_SOCKET) {
	Sock_size_t bufsize;
	char namebuf[MAXPATHLEN];
#if defined(VMS_DO_SOCKETS) && defined(DECCRTL_SOCKETS)
	bufsize = sizeof (struct sockaddr_in);
#else
	bufsize = sizeof namebuf;
#endif
	count = PerlSock_recvfrom(PerlIO_fileno(IoIFP(io)), buffer, length, 0,
			  (struct sockaddr *)namebuf, &bufsize);
    }
    else
#endif
d1869 1
a1869 1
	    return Perl_tied_method(aTHX_ "WRITE", mark - 1, MUTABLE_SV(io), mg,
d2082 1
a2082 1
	return tied_method1("EOF", SP, MUTABLE_SV(io), mg, newSVuv(which));
d2087 1
a2087 1
	    if ((IoFLAGS(io) & IOf_START) && av_len(GvAVn(gv)) < 0) {
d2090 1
a2090 1
		do_open(gv, "-", 1, FALSE, O_RDONLY, 0, NULL);
d2122 1
a2122 1
	    return tied_method0("TELL", SP, MUTABLE_SV(io), mg);
d2162 1
a2162 1
	    return tied_method2("SEEK", SP, MUTABLE_SV(io), mg, offset_sv,
d2275 1
a2275 1
    const int optype = PL_op->op_type;
d2277 1
a2277 1
    IO * const io = gv ? GvIOn(gv) : NULL;
d2281 1
a2281 1
    if (!io || !argsv || !IoIFP(io)) {
d2304 1
d2383 1
a2383 1
    IO * const io = gv ? GvIOn(gv) : NULL;
a2385 8
    if (!io) {
	report_evil_fh(gv);
	if (io && IoIFP(io))
	    do_close(gv, FALSE);
	SETERRNO(EBADF,LIB_INVARG);
	RETPUSHUNDEF;
    }

d2414 1
d2418 1
d2420 1
d2422 1
a2422 8
    IO * const io1 = gv1 ? GvIOn(gv1) : NULL;
    IO * const io2 = gv2 ? GvIOn(gv2) : NULL;
    int fd[2];

    if (!io1)
	report_evil_fh(gv1);
    if (!io2)
	report_evil_fh(gv2);
d2424 1
a2424 1
    if (io1 && IoIFP(io1))
d2426 1
a2426 1
    if (io2 && IoIFP(io2))
a2428 3
    if (!io1 || !io2)
	RETPUSHUNDEF;

d2469 1
a2469 1
    const int op_type = PL_op->op_type;
d2471 1
a2471 1
    if (!io || !IoIFP(io))
d2475 1
d2496 1
a2496 1
    IO * const io = gv ? GvIOn(gv) : NULL;
d2498 1
a2498 1
    if (!io || !IoIFP(io))
a2515 1
    IO *gstio;
d2526 1
a2526 6
    if (!ngv)
	goto badexit;
    if (!ggv)
	goto nuts;

    gstio = GvIO(ggv);
d2583 1
a2583 1
    if (!io || !IoIFP(io))
d2607 1
a2607 1
    if (!io || !IoIFP(io))
d2677 1
a2677 1
    if (!io || !IoIFP(io))
d2803 5
a2807 1
	    if (ckWARN(WARN_NEWLINE) && strchr(SvPV_nolen_const(PL_statname), '\n'))
d2809 2
d2836 4
a2839 18
#if Uid_t_size > IVSIZE
	mPUSHn(PL_statcache.st_uid);
#else
#   if Uid_t_sign <= 0
	mPUSHi(PL_statcache.st_uid);
#   else
	mPUSHu(PL_statcache.st_uid);
#   endif
#endif
#if Gid_t_size > IVSIZE
	mPUSHn(PL_statcache.st_gid);
#else
#   if Gid_t_sign <= 0
	mPUSHi(PL_statcache.st_gid);
#   else
	mPUSHu(PL_statcache.st_gid);
#   endif
#endif
d3271 1
a3271 1
    I32 len;
d3352 3
d3356 2
a3611 1
#ifndef INCOMPLETE_TAINTS
a3612 1
#endif
d3664 1
a3664 7
		const char * const errmsg =
#ifdef HAS_SYS_ERRLIST
		    sys_errlist[e]
#else
		    strerror(e)
#endif
		    ;
a3785 3
    if (!io)
	goto nope;

d3822 1
a3822 1
    if (!io || !IoDIRP(io)) {
a3837 1
#ifndef INCOMPLETE_TAINTS
a3839 1
#endif
d3844 1
a3844 1
        goto nope;
d3872 1
a3872 1
    if (!io || !IoDIRP(io)) {
d3898 1
a3898 1
    if (!io || !IoDIRP(io)) {
d3923 1
a3923 1
    if (!io || !IoDIRP(io)) {
d3947 1
a3947 1
    if (!io || !IoDIRP(io)) {
d3980 1
a3980 1
#if defined(HAS_SIGPROCMASK) && !defined(PERL_MICRO)
d3986 1
a3986 1
#if defined(HAS_SIGPROCMASK) && !defined(PERL_MICRO)
d3998 1
a3998 1
#if defined(HAS_SIGPROCMASK) && !defined(PERL_MICRO)
d4117 1
a4117 1
#if (defined(HAS_SIGPROCMASK) && !defined(PERL_MICRO))
d4123 1
a4123 1
#if (defined(HAS_SIGPROCMASK) && !defined(PERL_MICRO))
d4137 1
a4137 1
#if (defined(HAS_SIGPROCMASK) && !defined(PERL_MICRO))
d4191 1
a4191 1
#if (defined(HAS_SIGPROCMASK) && !defined(PERL_MICRO))
d4399 2
d4402 1
a4402 7
#ifndef VMS
    (void)PerlProc_times(&PL_timesbuf);
#else
    (void)PerlProc_times((tbuffer_t *)&PL_timesbuf);  /* time.h uses different name for */
                                                   /* struct tms, though same data   */
                                                   /* is returned.                   */
#endif
d4404 1
a4404 1
    mPUSHn(((NV)PL_timesbuf.tms_utime)/(NV)PL_clocktick);
d4406 3
a4408 3
	mPUSHn(((NV)PL_timesbuf.tms_stime)/(NV)PL_clocktick);
	mPUSHn(((NV)PL_timesbuf.tms_cutime)/(NV)PL_clocktick);
	mPUSHn(((NV)PL_timesbuf.tms_cstime)/(NV)PL_clocktick);
d4486 1
a4492 4
	SV *tsv;
	/* XXX newSVpvf()'s %lld type is broken, so cheat with a double */
	double year = (double)tmbuf.tm_year + 1900;

d4497 12
a4508 10

	tsv = Perl_newSVpvf(aTHX_ "%s %s %2d %02d:%02d:%02d %.0f",
			    dayname[tmbuf.tm_wday],
			    monname[tmbuf.tm_mon],
			    tmbuf.tm_mday,
			    tmbuf.tm_hour,
			    tmbuf.tm_min,
			    tmbuf.tm_sec,
			    year);
	mPUSHs(tsv);
a4907 1
#ifdef HAS_HTONS
a4908 1
#endif
a4925 1
#ifdef HAS_NTOHS
a4926 3
#else
		sv_setiv(sv, (IV)(sent->s_port));
#endif
a4936 1
#ifdef HAS_NTOHS
a4937 3
#else
	mPUSHi(sent->s_port);
#endif
d5152 1
a5152 5
#   if Uid_t_sign <= 0
		sv_setiv(sv, (IV)pwent->pw_uid);
#   else
		sv_setuv(sv, (UV)pwent->pw_uid);
#   endif
a5199 1
#   ifndef INCOMPLETE_TAINTS
a5202 1
#   endif
d5204 2
a5205 5
#   if Uid_t_sign <= 0
	mPUSHi(pwent->pw_uid);
#   else
	mPUSHu(pwent->pw_uid);
#   endif
a5206 5
#   if Uid_t_sign <= 0
	mPUSHi(pwent->pw_gid);
#   else
	mPUSHu(pwent->pw_gid);
#   endif
a5244 1
#   ifndef INCOMPLETE_TAINTS
a5246 1
#   endif
a5250 1
#   ifndef INCOMPLETE_TAINTS
a5252 1
#   endif
d5293 1
a5293 5
#if Gid_t_sign <= 0
		sv_setiv(sv, (IV)grent->gr_gid);
#else
		sv_setuv(sv, (UV)grent->gr_gid);
#endif
d5309 1
a5309 5
#if Gid_t_sign <= 0
	mPUSHi(grent->gr_gid);
#else
	mPUSHu(grent->gr_gid);
#endif
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d362 4
d368 1
a368 1
    if (SvGMAGICAL(TOPm1s)) TOPm1s = sv_2mortal(newSVsv(TOPm1s));
d370 1
a370 1
    tryAMAGICunTARGET(iter_amg, -1, (PL_op->op_flags & OPf_SPECIAL));
d374 1
a374 1
	 * MARK, wildcard, csh_glob context index
a378 2
    /* stack args are: wildcard, gv(_GEN_n) */

a379 1
	SETs(GvSV(TOPs));
d391 1
a391 1
    if (PL_tainting) {
d402 1
a402 1
    PL_last_in_gv = MUTABLE_GV(*PL_stack_sp--);
d442 1
d448 13
a460 5
    else if (SvROK(ERRSV)) {
	exsv = ERRSV;
    }
    else if (SvPOK(ERRSV) && SvCUR(ERRSV)) {
	exsv = sv_mortalcopy(ERRSV);
d462 2
a463 2
    }
    else {
d465 1
d494 21
a514 17
    else if (SvROK(ERRSV)) {
	exsv = ERRSV;
	if (sv_isobject(exsv)) {
	    HV * const stash = SvSTASH(SvRV(exsv));
	    GV * const gv = gv_fetchmethod(stash, "PROPAGATE");
	    if (gv) {
		SV * const file = sv_2mortal(newSVpv(CopFILE(PL_curcop),0));
		SV * const line = sv_2mortal(newSVuv(CopLINE(PL_curcop)));
		EXTEND(SP, 3);
		PUSHMARK(SP);
		PUSHs(exsv);
		PUSHs(file);
		PUSHs(line);
		PUTBACK;
		call_sv(MUTABLE_SV(GvCV(gv)),
			G_SCALAR|G_EVAL|G_KEEPERR);
		exsv = sv_mortalcopy(*PL_stack_sp--);
d517 7
a523 7
    }
    else if (SvPV_const(ERRSV, len), len) {
	exsv = sv_mortalcopy(ERRSV);
	sv_catpvs(exsv, "\t...propagated");
    }
    else {
	exsv = newSVpvs_flags("Died", SVs_TEMP);
d678 2
a679 2
    register IO *rstio;
    register IO *wstio;
d870 2
d873 4
d879 1
d1075 4
a1078 4
    register I32 i;
    register I32 j;
    register char *s;
    register SV *sv;
d1105 1
a1105 2
	if (SvREADONLY(sv)) {
	    if (SvIsCOW(sv))
d1107 2
a1108 3
	    if (SvREADONLY(sv) && !(SvPOK(sv) && SvCUR(sv) == 0))
		Perl_croak_no_modify(aTHX);
	}
d1250 2
a1251 1
    SvREFCNT_inc_simple_void(gv);
d1336 1
a1336 1
    register PERL_CONTEXT *cx;
d1349 4
d1354 1
a1354 1
    PAD_SET_CUR_NOSAVE(CvPADLIST(cv), 1);
d1364 2
a1365 2
    register GV *gv;
    register IO *io;
d1388 1
a1388 2
    if (!fgv)
	goto not_a_format_reference;
d1394 1
a1394 5
	if (SvPOK(tmpsv) && *SvPV_nolen_const(tmpsv))
	    DIE(aTHX_ "Undefined format \"%"SVf"\" called", SVfARG(tmpsv));

	not_a_format_reference:
	DIE(aTHX_ "Not a format reference");
d1397 1
a1397 1
    return doform(cv,gv,PL_op->op_next);
d1404 1
a1404 1
    register IO * const io = GvIOp(gv);
d1409 1
a1409 1
    register PERL_CONTEXT *cx;
d1467 1
a1467 1
	    do_print(PL_formfeed, ofp);
d1479 1
a1479 4
	    if (SvPOK(sv) && *SvPV_nolen_const(sv))
		DIE(aTHX_ "Undefined top format \"%"SVf"\" called", SVfARG(sv));
	    else
		DIE(aTHX_ "Undefined top format called");
d1488 1
d1491 2
a1492 3
    fp = IoOFP(io);
    if (!fp) {
	if (IoIFP(io))
a1512 1
    /* bad_ofp: */
a1513 2
    PUTBACK;
    PERL_UNUSED_VAR(newsp);
d1515 1
a1515 1
    return retop;
a1521 1
    SV *sv;
d1527 3
a1545 1
    sv = newSV(0);
d1560 1
a1568 1
    SvREFCNT_dec(sv);
a1573 1
    SvREFCNT_dec(sv);
d1640 2
d1663 3
a1665 3
    if (length < 0)
	DIE(aTHX_ "Negative length");
    wanted = length;
d1670 1
d1676 1
a1676 1
#if (defined(VMS_DO_SOCKETS) && defined(DECCRTL_SOCKETS)) || defined(MPE) || defined(__QNXNTO__)
a1693 4
#ifdef EPOC
        /* Bogus return without padding */
	bufsize = sizeof (struct sockaddr_in);
#endif
a1708 4
    if (DO_UTF8(bufsv)) {
	/* offset adjust in characters not bytes */
	blen = sv_len_utf8(bufsv);
    }
d1716 1
a1716 1
	if (offset >= (int)blen)
d1941 3
a1943 9
		if (SvGMAGICAL(bufsv) || SvAMAGIC(bufsv)) {
		    /* Don't call sv_len_utf8 again because it will call magic
		       or overloading a second time, and we might get back a
		       different result.  */
		    blen_chars = utf8_length((U8*)buffer, (U8*)buffer + blen);
		} else {
		    /* It's safe, and it may well be cached.  */
		    blen_chars = sv_len_utf8(bufsv);
		}
d2210 3
a2212 3
	if ((tmpgv = PL_op->op_flags & OPf_SPECIAL
	               ? gv_fetchsv(sv, 0, SVt_PVIO)
	               : MAYBE_DEREF_GV(sv) )) {
d2379 1
a2379 1
    register IO * const io = gv ? GvIOn(gv) : NULL;
a2409 4
#ifdef EPOC
    setbuf( IoIFP(io), NULL); /* EPOC gets confused about sockets */
#endif

d2423 2
a2424 2
    register IO * const io1 = gv1 ? GvIOn(gv1) : NULL;
    register IO * const io2 = gv2 ? GvIOn(gv2) : NULL;
d2478 1
a2478 1
    register IO * const io = GvIOn(gv);
d2506 1
a2506 1
    register IO * const io = gv ? GvIOn(gv) : NULL;
d2525 2
a2526 2
    register IO *nstio;
    register IO *gstio;
d2528 1
a2528 1
#if (defined(VMS_DO_SOCKETS) && defined(DECCRTL_SOCKETS)) || defined(MPE) || defined(__QNXNTO__)
a2575 4
#ifdef EPOC
    len = sizeof (struct sockaddr_in); /* EPOC somehow truncates info */
    setbuf( IoIFP(nstio), NULL); /* EPOC gets confused about sockets */
#endif
d2597 1
a2597 1
    register IO * const io = GvIOn(gv);
d2619 1
a2619 1
    register IO * const io = GvIOn(gv);
d2688 1
a2688 1
    register IO * const io = GvIOn(gv);
d2810 1
d2894 7
d2909 2
a2910 1
S_ft_stacking_return_false(pTHX_ SV *ret) {
d2912 2
a2913 5
    OP *next = NORMAL;
    while (OP_IS_FILETEST(next->op_type)
	&& next->op_private & OPpFT_STACKED)
	next = next->op_next;
    if (PL_op->op_flags & OPf_REF) PUSHs(ret);
d2916 6
d2925 14
a2938 18
#define FT_RETURN_FALSE(X)			     \
    STMT_START {				      \
	if (PL_op->op_private & OPpFT_STACKING)	       \
	    return S_ft_stacking_return_false(aTHX_ X);	\
	RETURNX(PUSHs(X));				 \
    } STMT_END
#define FT_RETURN_TRUE(X)		 \
    RETURNX((void)(			  \
	PL_op->op_private & OPpFT_STACKING \
	    ? PL_op->op_flags & OPf_REF	    \
		? PUSHs((SV *)cGVOP_gv)	     \
		: 0			      \
	    : PUSHs(X)			       \
    ))

#define FT_RETURNNO	FT_RETURN_FALSE(&PL_sv_no)
#define FT_RETURNUNDEF	FT_RETURN_FALSE(&PL_sv_undef)
#define FT_RETURNYES	FT_RETURN_TRUE(&PL_sv_yes)
d2941 1
a2941 1
	if ( (SvFLAGS(TOPs) & (SVf_ROK|SVs_GMG)) \
d2951 1
a2951 2
    dSP;
    SV* const arg = TOPs;
d2956 1
a2956 1
    if (SvAMAGIC(TOPs))
d2966 2
a2967 8
	if (PL_op->op_private & OPpFT_STACKING) {
	    if (SvTRUE(tmpsv)) return NORMAL;
	    return S_ft_stacking_return_false(aTHX_ tmpsv);
	}

	SPAGAIN;

	RETURNX(SETs(tmpsv));
a2995 1
    dSP;
d3059 1
a3059 1
	const char *name = POPpx;
d3076 1
a3076 1
	    RETPUSHYES;
d3078 2
a3079 2
	    RETPUSHUNDEF;
	RETPUSHNO;
a3083 1
    SPAGAIN;
a3096 1
    dSP;
a3107 1
    SPAGAIN;
d3138 2
a3139 2
	if (SvTRUE_nomg(TARG)) FT_RETURN_TRUE(TARG);
	else		       FT_RETURN_FALSE(TARG);
a3147 1
    dSP;
a3168 2
	if ((PL_op->op_flags & OPf_REF) == 0 && !(PL_op->op_private & OPpFT_STACKING))
	    (void) POPs;
a3173 2
	if ((PL_op->op_flags & OPf_REF) == 0 && !(PL_op->op_private & OPpFT_STACKING))
	    (void) POPs;
a3178 2
	if ((PL_op->op_flags & OPf_REF) == 0 && !(PL_op->op_private & OPpFT_STACKING))
	    (void) POPs;
a3183 1
    SPAGAIN;
a3247 1
    dSP;
a3251 1
    SPAGAIN;
a3262 1
    dSP;
d3273 1
a3273 1
      SV *tmpsv = PL_op->op_private & OPpFT_STACKING ? TOPs : POPs;
a3290 8
#if defined(atarist) /* this will work with atariST. Configure will
			make guesses for other systems. */
# define FILE_base(f) ((f)->_base)
# define FILE_ptr(f) ((f)->_ptr)
# define FILE_cnt(f) ((f)->_cnt)
# define FILE_bufsiz(f) ((f)->_cnt + ((f)->_ptr - (f)->_base))
#endif

a3293 1
    dSP;
d3298 3
a3300 3
    register STDCHAR *s;
    register IO *io;
    register SV *sv = NULL;
a3306 1
    {
d3308 1
a3308 5
	EXTEND(SP, 1);
    }
    else {
      sv = PL_op->op_private & OPpFT_STACKING ? TOPs : POPs;
      if ((PL_op->op_private & (OPpFT_STACKED|OPpFT_AFTER_t))
d3311 3
a3313 1
      else gv = MAYBE_DEREF_GV_nomg(sv);
d3811 1
a3811 1
    register IO * const io = GvIOn(gv);
d3849 2
a3850 2
    register const Direntry_t *dp;
    register IO * const io = GvIOn(gv);
d3902 1
a3902 1
    register IO * const io = GvIOn(gv);
d3928 1
a3928 1
    register IO * const io = GvIOn(gv);
d3953 1
a3953 1
    register IO * const io = GvIOn(gv);
d3977 1
a3977 1
    register IO * const io = GvIOn(gv);
d4012 3
d4018 4
d4023 14
d4038 1
a4038 1
	RETSETUNDEF;
d4055 1
a4055 1
	RETSETUNDEF;
d4133 1
a4133 1
    if (PL_tainting) {
d4137 1
a4137 1
	    if (PL_tainted)
d4280 1
a4280 1
    if (PL_tainting) {
d4284 1
a4284 1
	    if (PL_tainted)
a4298 6
#  ifdef __OPEN_VM
	{
	   (void ) do_aspawn(NULL, MARK, SP);
	   value = 0;
	}
#  else
a4299 1
#  endif
a4304 4
#  ifdef __OPEN_VM
	(void) do_spawn(SvPVx_nolen(sv_mortalcopy(*SP)));
	value = 0;
#  else
a4305 1
#  endif
d4701 2
a4702 2
    register char **elem;
    register SV *sv;
d4791 1
a4791 1
    register SV *sv;
d4864 1
a4864 1
    register SV *sv;
d4924 1
a4924 1
    register SV *sv;
d5101 1
a5101 1
    register SV *sv;
d5425 1
a5425 1
    register I32 items = SP - MARK;
d5427 2
a5428 2
    register I32 i = 0;
    I32 retval = -1;
d5430 1
a5430 1
    if (PL_tainting) {
a5483 24
#ifdef atarist
    case 9:
	retval = syscall(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	break;
    case 10:
	retval = syscall(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9]);
	break;
    case 11:
	retval = syscall(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],
	  a[10]);
	break;
    case 12:
	retval = syscall(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],
	  a[10],a[11]);
	break;
    case 13:
	retval = syscall(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],
	  a[10],a[11],a[12]);
	break;
    case 14:
	retval = syscall(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],
	  a[10],a[11],a[12],a[13]);
	break;
#endif /* atarist */
d5618 1
a5618 1
 * indent-tabs-mode: t
d5621 1
a5621 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@a51 4
#ifdef I_SYS_WAIT
# include <sys/wait.h>
#endif

d251 1
d265 1
d278 1
d288 1
d361 21
a381 1
    tryAMAGICunTARGET(iter, -1);
d426 1
a426 2
    SV *tmpsv;
    const char *tmps;
d431 1
a431 1
	tmpsv = TARG;
d435 1
a435 1
	tmpsv = &PL_sv_no;
d440 8
a447 1
	tmpsv = TOPs;
d449 3
a451 8
    tmps = SvPV_const(tmpsv, len);
    if ((!tmps || !len) && PL_errgv) {
  	SV * const error = ERRSV;
	SvUPGRADE(error, SVt_PV);
	if (SvPOK(error) && SvCUR(error))
	    sv_catpvs(error, "\t...caught");
	tmpsv = error;
	tmps = SvPV_const(tmpsv, len);
d453 6
a458 4
    if (!tmps || !len)
	tmpsv = newSVpvs_flags("Warning: something's wrong", SVs_TEMP);

    Perl_warn(aTHX_ "%"SVf, SVfARG(tmpsv));
d465 1
a465 2
    const char *tmps;
    SV *tmpsv;
a466 1
    bool multiarg = 0;
d473 1
a473 3
	tmpsv = TARG;
	tmps = SvPV_const(tmpsv, len);
	multiarg = 1;
d477 1
a477 2
	tmpsv = TOPs;
        tmps = SvROK(tmpsv) ? (const char *)NULL : SvPV_const(tmpsv, len);
d479 21
a499 22
    if (!tmps || !len) {
	SV * const error = ERRSV;
	SvUPGRADE(error, SVt_PV);
	if (multiarg ? SvROK(error) : SvROK(tmpsv)) {
	    if (!multiarg)
		SvSetSV(error,tmpsv);
	    else if (sv_isobject(error)) {
		HV * const stash = SvSTASH(SvRV(error));
		GV * const gv = gv_fetchmethod(stash, "PROPAGATE");
		if (gv) {
		    SV * const file = sv_2mortal(newSVpv(CopFILE(PL_curcop),0));
		    SV * const line = sv_2mortal(newSVuv(CopLINE(PL_curcop)));
		    EXTEND(SP, 3);
		    PUSHMARK(SP);
		    PUSHs(error);
		    PUSHs(file);
 		    PUSHs(line);
		    PUTBACK;
		    call_sv(MUTABLE_SV(GvCV(gv)),
			    G_SCALAR|G_EVAL|G_KEEPERR);
		    sv_setsv(error,*PL_stack_sp--);
		}
a500 1
	    DIE(aTHX_ NULL);
d502 45
a546 6
	else {
	    if (SvPOK(error) && SvCUR(error))
		sv_catpvs(error, "\t...propagated");
	    tmpsv = error;
	    if (SvOK(tmpsv))
		tmps = SvPV_const(tmpsv, len);
d548 3
a550 2
		tmps = NULL;
	}
a551 2
    if (!tmps || !len)
	tmpsv = newSVpvs_flags("Died", SVs_TEMP);
d553 20
a572 2
    DIE(aTHX_ "%"SVf, SVfARG(tmpsv));
    RETURN;
d575 6
a580 1
/* I/O. */
d595 1
a595 1
    if (!isGV(gv))
d599 1
a599 1
	MAGIC *mg;
d604 2
a605 2
			     "Opening dirhandle %s also as a file",
			     GvENAME(gv));
d611 3
a613 8
	    *MARK-- = SvTIED_obj(MUTABLE_SV(io), mg);
	    PUSHMARK(MARK);
	    PUTBACK;
	    ENTER_with_name("call_OPEN");
	    call_method("OPEN", G_SCALAR);
	    LEAVE_with_name("call_OPEN");
	    SPAGAIN;
	    RETURN;
d639 5
a643 1
    GV * const gv = (MAXARG == 0) ? PL_defoutgv : MUTABLE_GV(POPs);
d648 1
a648 1
	    MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d650 1
a650 8
		PUSHMARK(SP);
		XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
		PUTBACK;
		ENTER_with_name("call_CLOSE");
		call_method("CLOSE", G_SCALAR);
		LEAVE_with_name("call_CLOSE");
		SPAGAIN;
		RETURN;
a653 1
    EXTEND(SP, 1);
a713 1
    return NORMAL;
d723 1
a723 1
    MAGIC  *mg;
d728 1
d730 1
a730 1
    if (gv && (io = GvIO(gv))
d733 1
a733 8
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
	PUTBACK;
	ENTER_with_name("call_FILENO");
	call_method("FILENO", G_SCALAR);
	LEAVE_with_name("call_FILENO");
	SPAGAIN;
	RETURN;
d736 1
a736 1
    if (!gv || !(io = GvIO(gv)) || !(fp = IoIFP(io))) {
d739 2
a740 2
	  if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	      report_evil_fh(gv, io, PL_op->op_type);
d757 1
a757 1
    if (MAXARG < 1) {
d773 1
a773 1
    if (MAXARG >= 1 && (POPi & 0700))
d795 1
d797 2
a798 2
    if (gv && (io = GvIO(gv))) {
	MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d800 7
a806 10
	    PUSHMARK(SP);
	    XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
	    if (discp)
		XPUSHs(discp);
	    PUTBACK;
	    ENTER_with_name("call_BINMODE");
	    call_method("BINMODE", G_SCALAR);
	    LEAVE_with_name("call_BINMODE");
	    SPAGAIN;
	    RETURN;
d810 2
a811 4
    EXTEND(SP, 1);
    if (!(io = GvIO(gv)) || !(fp = IoIFP(io))) {
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
d860 7
d869 2
a870 1
	    if (isGV_with_GP(varsv)) {
d898 4
a901 2
	/* Not clear why we don't call call_method here too.
	 * perhaps to get different error message ?
d903 2
a904 4
	STRLEN len;
	const char *name = SvPV_nomg_const(*MARK, len);
	stash = gv_stashpvn(name, len, 0);
	if (!stash || !(gv = gv_fetchmethod(stash, methname))) {
d945 1
a945 1
    if (isGV_with_GP(sv) && !(sv = MUTABLE_SV(GvIOp(sv))))
d955 1
a955 1
	       XPUSHs(SvTIED_obj(MUTABLE_SV(gv), mg));
d983 1
a983 1
    if (isGV_with_GP(sv) && !(sv = MUTABLE_SV(GvIOp(sv))))
d987 1
a987 4
	SV *osv = SvTIED_obj(sv, mg);
	if (osv == mg->mg_obj)
	    osv = sv_mortalcopy(osv);
	PUSHs(osv);
d1020 1
d1022 2
d1080 1
d1087 1
a1087 1
		DIE(aTHX_ "%s", PL_no_modify);
d1090 4
a1093 2
	    Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "Non-string passed as bitmask");
	    SvPV_force_nolen(sv);	/* force string conversion */
a1211 1
    return NORMAL;
d1240 2
a1241 1
    GV * egv = GvEGV(PL_defoutgv);
d1245 5
a1249 6
    hv = GvSTASH(egv);
    if (! hv)
	XPUSHs(&PL_sv_undef);
    else {
	GV * const * const gvp = (GV**)hv_fetch(hv, GvNAME(egv), GvNAMELEN(egv), FALSE);
	if (gvp && *gvp == egv) {
d1252 2
a1253 2
	}
	else {
a1254 1
	}
d1269 3
a1271 2
    IO *io = NULL;
    GV * const gv = (MAXARG==0) ? PL_stdingv : MUTABLE_GV(POPs);
d1276 2
a1277 2
    if (gv && (io = GvIO(gv))) {
	MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d1279 4
a1282 9
	    const I32 gimme = GIMME_V;
	    PUSHMARK(SP);
	    XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
	    PUTBACK;
	    ENTER;
	    call_method("GETC", gimme);
	    LEAVE;
	    SPAGAIN;
	    if (gimme == G_SCALAR)
d1284 2
a1285 1
	    RETURN;
d1289 2
a1290 3
	if ((!io || (!IoIFP(io) && IoTYPE(io) != IoTYPE_WRONLY))
	  && ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
d1320 3
d1345 1
a1345 1
    if (MAXARG == 0)
d1347 2
a1353 1
    EXTEND(SP, 1);
a1367 1
	const char *name;
d1370 2
a1371 3
	name = SvPV_nolen_const(tmpsv);
	if (name && *name)
	    DIE(aTHX_ "Undefined format \"%s\" called", name);
a1375 3
    if (CvCLONE(cv))
	cv = MUTABLE_CV(sv_2mortal(MUTABLE_SV(cv_clone(cv))));

d1390 1
d1410 2
a1411 1
		topname = sv_2mortal(Perl_newSVpvf(aTHX_ "%s_TOP", GvNAME(gv)));
a1457 1
	    const char *name;
d1459 2
a1460 3
	    name = SvPV_nolen_const(sv);
	    if (name && *name)
		DIE(aTHX_ "Undefined top format \"%s\" called", name);
a1463 2
	if (cv && CvCLONE(cv))
	    cv = MUTABLE_CV(sv_2mortal(MUTABLE_SV(cv_clone(cv))));
d1470 1
d1475 4
a1478 6
	if (ckWARN2(WARN_CLOSED,WARN_IO)) {
	    if (IoIFP(io))
		report_evil_fh(gv, io, OP_phoney_INPUT_ONLY);
	    else if (ckWARN(WARN_CLOSED))
		report_evil_fh(gv, io, PL_op->op_type);
	}
d1501 1
a1501 1
    return cx->blk_sub.retop;
a1506 1
    IO *io;
d1512 1
d1514 2
a1515 2
    if (gv && (io = GvIO(gv))) {
	MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d1523 4
a1526 11
	    PUSHMARK(MARK - 1);
	    *MARK = SvTIED_obj(MUTABLE_SV(io), mg);
	    PUTBACK;
	    ENTER;
	    call_method("PRINTF", G_SCALAR);
	    LEAVE;
	    SPAGAIN;
	    MARK = ORIGMARK + 1;
	    *MARK = *SP;
	    SP = MARK;
	    RETURN;
d1531 2
a1532 3
    if (!(io = GvIO(gv))) {
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
d1537 4
a1540 6
	if (ckWARN2(WARN_CLOSED,WARN_IO))  {
	    if (IoIFP(io))
		report_evil_fh(gv, io, OP_phoney_INPUT_ONLY);
	    else if (ckWARN(WARN_CLOSED))
		report_evil_fh(gv, io, PL_op->op_type);
	}
a1544 2
	if (SvTAINTED(MARK[1]))
	    TAINT_PROPER("printf");
d1569 1
a1569 1
    const int perm = (MAXARG > 3) ? POPi : 0666;
d1591 1
a1591 1
    int offset;
d1594 1
a1596 1
    Sock_size_t bufsize;
d1612 1
a1612 1
	const MAGIC * mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d1614 3
a1616 11
	    SV *sv;
	    PUSHMARK(MARK-1);
	    *MARK = SvTIED_obj(MUTABLE_SV(io), mg);
	    ENTER;
	    call_method("READ", G_SCALAR);
	    LEAVE;
	    SPAGAIN;
	    sv = POPs;
	    SP = ORIGMARK;
	    PUSHs(sv);
	    RETURN;
d1633 1
a1633 2
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
d1657 1
d1674 3
a1694 3
#else
    if (PL_op->op_type == OP_RECV)
	DIE(aTHX_ PL_no_sock_func, "recv");
d1701 1
a1701 1
	if (-offset > (int)blen)
d1713 1
a1713 1
    bufsize = SvCUR(bufsv);
d1720 2
a1721 2
    if (offset > 0 && (Sock_size_t)offset > bufsize) { /* Zero any newly allocated space */
    	Zero(buffer+bufsize, offset-bufsize, char);
d1755 1
d1774 2
a1775 2
	if ((IoTYPE(io) == IoTYPE_WRONLY) && ckWARN(WARN_IO))
		report_evil_fh(gv, io, OP_phoney_OUTPUT_ONLY);
d1834 1
a1834 1
PP(pp_send)
a1836 1
    IO *io;
a1844 1
    
d1846 4
a1849 3
    if (PL_op->op_type == OP_SYSWRITE
	&& gv && (io = GvIO(gv))) {
	MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
a1850 2
	    SV *sv;

d1852 1
a1852 1
		sv = *SP;
d1857 3
a1859 10
	    PUSHMARK(ORIGMARK);
	    *(ORIGMARK+1) = SvTIED_obj(MUTABLE_SV(io), mg);
	    ENTER;
	    call_method("WRITE", G_SCALAR);
	    LEAVE;
	    SPAGAIN;
	    sv = POPs;
	    SP = ORIGMARK;
	    PUSHs(sv);
	    RETURN;
a1867 1
    io = GvIO(gv);
d1870 4
a1873 6
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED)) {
	    if (io && IoIFP(io))
		report_evil_fh(gv, io, OP_phoney_INPUT_ONLY);
	    else
		report_evil_fh(gv, io, PL_op->op_type);
	}
d1905 17
a1921 1
    if (op_type == OP_SYSWRITE) {
a2015 18
#ifdef HAS_SOCKET
    else {
	const int flags = SvIVx(*++MARK);
	if (SP > MARK) {
	    STRLEN mlen;
	    char * const sockbuf = SvPVx(*++MARK, mlen);
	    retval = PerlSock_sendto(PerlIO_fileno(IoIFP(io)), buffer, blen,
				     flags, (struct sockaddr *)sockbuf, mlen);
	}
	else {
	    retval
		= PerlSock_send(PerlIO_fileno(IoIFP(io)), buffer, blen, flags);
	}
    }
#else
    else
	DIE(aTHX_ PL_no_sock_func, "send");
#endif
d2042 12
a2053 1
    MAGIC *mg;
d2055 1
a2055 1
    if (MAXARG)
d2057 2
d2062 5
a2066 3
	if (PL_op->op_flags & OPf_SPECIAL)
	    gv = PL_last_in_gv = GvEGV(PL_argvgv);	/* eof() - ARGV magic */
	else
d2068 2
d2076 1
a2076 21
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
	/*
	 * in Perl 5.12 and later, the additional paramter is a bitmask:
	 * 0 = eof
	 * 1 = eof(FH)
	 * 2 = eof()  <- ARGV magic
	 */
	EXTEND(SP, 1);
	if (MAXARG)
	    mPUSHi(1);		/* 1 = eof(FH) - simple, explicit FH */
	else if (PL_op->op_flags & OPf_SPECIAL)
	    mPUSHi(2);		/* 2 = eof()   - ARGV magic */
	else
	    mPUSHi(0);		/* 0 = eof     - simple, implicit FH */
	PUTBACK;
	ENTER;
	call_method("EOF", G_SCALAR);
	LEAVE;
	SPAGAIN;
	RETURN;
d2106 1
a2106 1
    if (MAXARG != 0)
d2112 3
a2114 2
    if (gv && (io = GvIO(gv))) {
	MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d2116 1
a2116 8
	    PUSHMARK(SP);
	    XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
	    PUTBACK;
	    ENTER;
	    call_method("TELL", G_SCALAR);
	    LEAVE;
	    SPAGAIN;
	    RETURN;
d2145 1
a2145 1
    IO *io;
d2147 2
a2148 2
    if (gv && (io = GvIO(gv))) {
	MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
a2149 2
	    PUSHMARK(SP);
	    XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
d2151 1
a2151 1
	    mXPUSHn((NV) offset);
d2153 1
a2153 1
	    mXPUSHi(offset);
d2155 3
a2157 7
	    mXPUSHi(whence);
	    PUTBACK;
	    ENTER;
	    call_method("SEEK", G_SCALAR);
	    LEAVE;
	    SPAGAIN;
	    RETURN;
d2202 1
d2207 5
a2211 5
	if (PL_op->op_flags & OPf_SPECIAL) {
	    tmpgv = gv_fetchsv(POPs, 0, SVt_PVIO);

	do_ftruncate_gv:
	    if (!GvIO(tmpgv))
a2214 1
		io = GvIOp(tmpgv);
d2231 1
a2231 13
	else {
	    SV * const sv = POPs;
	    const char *name;

	    if (isGV_with_GP(sv)) {
	        tmpgv = MUTABLE_GV(sv);		/* *main::FRED for example */
		goto do_ftruncate_gv;
	    }
	    else if (SvROK(sv) && isGV_with_GP(SvRV(sv))) {
	        tmpgv = MUTABLE_GV(SvRV(sv));	/* \*main::FRED for example */
		goto do_ftruncate_gv;
	    }
	    else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVIO) {
d2234 3
a2236 3
	    }

	    name = SvPV_nolen_const(sv);
d2276 1
a2276 2
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
a2342 2
    IO *io = NULL;
    PerlIO *fp;
d2344 3
a2346 1
    GV * const gv = (MAXARG == 0) ? PL_last_in_gv : MUTABLE_GV(POPs);
a2347 6
    if (gv && (io = GvIO(gv)))
	fp = IoIFP(io);
    else {
	fp = NULL;
	io = NULL;
    }
d2354 1
a2354 2
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
a2361 1
    return NORMAL;
d2367 2
a2370 1
#ifdef HAS_SOCKET
d2379 2
a2380 3
    if (!gv || !io) {
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
d2412 1
a2412 3
#else
    DIE(aTHX_ PL_no_sock_func, "socket");
    return NORMAL;
a2413 1
}
d2428 4
a2431 13
    if (!gv1 || !gv2 || !io1 || !io2) {
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED)) {
	    if (!gv1 || !io1)
		report_evil_fh(gv1, io1, PL_op->op_type);
	    if (!gv2 || !io2)
		report_evil_fh(gv1, io2, PL_op->op_type);
	}
	if (io1 && IoIFP(io1))
	    do_close(gv1, FALSE);
	if (io2 && IoIFP(io2))
	    do_close(gv2, FALSE);
	RETPUSHUNDEF;
    }
d2433 1
a2433 1
    if (IoIFP(io1))
d2435 1
a2435 1
    if (IoIFP(io2))
d2438 3
a2466 1
    return NORMAL;
d2470 2
a2473 1
#ifdef HAS_SOCKET
d2481 1
d2487 5
a2491 2
    TAINT_PROPER("bind");
    if (PerlSock_bind(PerlIO_fileno(IoIFP(io)), (struct sockaddr *)addr, len) >= 0)
d2497 1
a2497 2
    if (ckWARN(WARN_CLOSED))
	report_evil_fh(gv, io, PL_op->op_type);
a2499 35
#else
    DIE(aTHX_ PL_no_sock_func, "bind");
    return NORMAL;
#endif
}

PP(pp_connect)
{
#ifdef HAS_SOCKET
    dVAR; dSP;
    SV * const addrsv = POPs;
    GV * const gv = MUTABLE_GV(POPs);
    register IO * const io = GvIOn(gv);
    const char *addr;
    STRLEN len;

    if (!io || !IoIFP(io))
	goto nuts;

    addr = SvPV_const(addrsv, len);
    TAINT_PROPER("connect");
    if (PerlSock_connect(PerlIO_fileno(IoIFP(io)), (struct sockaddr *)addr, len) >= 0)
	RETPUSHYES;
    else
	RETPUSHUNDEF;

nuts:
    if (ckWARN(WARN_CLOSED))
	report_evil_fh(gv, io, PL_op->op_type);
    SETERRNO(EBADF,SS_IVCHAN);
    RETPUSHUNDEF;
#else
    DIE(aTHX_ PL_no_sock_func, "connect");
    return NORMAL;
#endif
a2503 1
#ifdef HAS_SOCKET
d2509 1
a2509 1
    if (!gv || !io || !IoIFP(io))
d2518 1
a2518 2
    if (ckWARN(WARN_CLOSED))
	report_evil_fh(gv, io, PL_op->op_type);
a2520 4
#else
    DIE(aTHX_ PL_no_sock_func, "listen");
    return NORMAL;
#endif
a2524 1
#ifdef HAS_SOCKET
d2589 1
a2589 2
    if (ckWARN(WARN_CLOSED))
	report_evil_fh(ggv, ggv ? GvIO(ggv) : 0, PL_op->op_type);
a2594 4
#else
    DIE(aTHX_ PL_no_sock_func, "accept");
    return NORMAL;
#endif
a2598 1
#ifdef HAS_SOCKET
d2611 1
a2611 2
    if (ckWARN(WARN_CLOSED))
	report_evil_fh(gv, io, PL_op->op_type);
a2613 4
#else
    DIE(aTHX_ PL_no_sock_func, "shutdown");
    return NORMAL;
#endif
a2617 1
#ifdef HAS_SOCKET
d2681 1
a2681 2
    if (ckWARN(WARN_CLOSED))
	report_evil_fh(gv, io, optype);
a2685 4
#else
    DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
    return NORMAL;
#endif
a2689 1
#ifdef HAS_SOCKET
d2740 1
a2740 2
    if (ckWARN(WARN_CLOSED))
	report_evil_fh(gv, io, optype);
d2744 1
a2745 3
#else
    DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
    return NORMAL;
a2746 1
}
d2755 1
a2755 1
    IO *io;
d2758 1
d2760 2
a2761 2
    if (PL_op->op_flags & OPf_REF) {
	gv = cGVOP_gv;
d2766 5
a2770 1
			       "lstat() on filehandle %s", gv ? GvENAME(gv) : "");
d2772 1
a2775 1
      do_fstat:
d2777 3
d2781 1
a2781 1
	    PL_statgv = gv;
d2785 2
a2786 2
                do_fstat_have_io:
                if (io) {
d2790 1
d2794 1
a2797 1
	        }
d2799 2
a2803 2
	    if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
		report_evil_fh(gv, GvIO(gv), PL_op->op_type);
d2808 1
a2808 10
	SV* const sv = POPs;
	if (isGV_with_GP(sv)) {
	    gv = MUTABLE_GV(sv);
	    goto do_fstat;
	} else if(SvROK(sv) && isGV_with_GP(SvRV(sv))) {
            gv = MUTABLE_GV(SvRV(sv));
            if (PL_op->op_type == OP_LSTAT)
                goto do_fstat_warning_check;
            goto do_fstat;
        } else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVIO) { 
d2815 1
a2815 1
	sv_setpv(PL_statname, SvPV_nolen_const(sv));
d2839 4
d2844 4
d2898 74
a2971 7
/* This macro is used by the stacked filetest operators :
 * if the previous filetest failed, short-circuit and pass its value.
 * Else, discard it from the stack and continue. --rgs
 */
#define STACKED_FTEST_CHECK if (PL_op->op_private & OPpFT_STACKED) { \
	if (!SvTRUE(TOPs)) { RETURN; } \
	else { (void)POPs; PUTBACK; } \
d2973 3
d2996 1
a2996 1
    int stat_mode = S_IRUSR;
d3010 1
a3010 3
    tryAMAGICftest(opchar);

    STACKED_FTEST_CHECK;
d3088 1
a3088 1
    result = my_stat();
d3091 1
a3091 1
	RETPUSHUNDEF;
d3093 2
a3094 2
	RETPUSHYES;
    RETPUSHNO;
d3112 1
a3112 1
    tryAMAGICftest(opchar);
d3114 1
a3114 3
    STACKED_FTEST_CHECK;

    result = my_stat();
d3117 1
a3117 1
	RETPUSHUNDEF;
d3119 1
a3119 1
	RETPUSHYES;
d3127 1
a3127 1
	    PUSHn(PL_statcache.st_size);
d3129 1
a3129 1
	    PUSHi(PL_statcache.st_size);
d3133 2
a3134 1
	    PUSHn( (((NV)PL_basetime - PL_statcache.st_mtime)) / 86400.0 );
d3137 2
a3138 1
	    PUSHn( (((NV)PL_basetime - PL_statcache.st_atime)) / 86400.0 );
d3141 2
a3142 1
	    PUSHn( (((NV)PL_basetime - PL_statcache.st_ctime)) / 86400.0 );
d3145 3
a3148 1
    RETURN;
d3172 1
a3172 1
    tryAMAGICftest(opchar);
d3177 5
a3181 2
    if(PL_op->op_type == OP_FTSUID)
	RETPUSHNO;
d3184 5
a3188 2
    if(PL_op->op_type == OP_FTSGID)
	RETPUSHNO;
d3191 5
a3195 2
    if(PL_op->op_type == OP_FTSVTX)
	RETPUSHNO;
d3198 1
a3198 3
    STACKED_FTEST_CHECK;

    result = my_stat();
d3201 1
a3201 1
	RETPUSHUNDEF;
d3204 2
a3205 2
	if (PL_statcache.st_uid == PL_uid)
	    RETPUSHYES;
d3208 2
a3209 2
	if (PL_statcache.st_uid == PL_euid)
	    RETPUSHYES;
d3213 1
a3213 1
	    RETPUSHYES;
d3217 1
a3217 1
	    RETPUSHYES;
d3221 1
a3221 1
	    RETPUSHYES;
d3225 1
a3225 1
	    RETPUSHYES;
d3229 1
a3229 1
	    RETPUSHYES;
d3233 1
a3233 1
	    RETPUSHYES;
d3237 1
a3237 1
	    RETPUSHYES;
d3242 1
a3242 1
	    RETPUSHYES;
d3248 1
a3248 1
	    RETPUSHYES;
d3254 1
a3254 1
	    RETPUSHYES;
d3258 1
a3258 1
    RETPUSHNO;
d3267 2
a3268 2
    tryAMAGICftest('l');
    result = my_lstat();
d3272 1
a3272 1
	RETPUSHUNDEF;
d3274 2
a3275 2
	RETPUSHYES;
    RETPUSHNO;
d3284 2
a3285 3
    SV *tmpsv = NULL;

    tryAMAGICftest('t');
d3287 1
a3287 1
    STACKED_FTEST_CHECK;
d3291 7
a3297 6
    else if (isGV(TOPs))
	gv = MUTABLE_GV(POPs);
    else if (SvROK(TOPs) && isGV(SvRV(TOPs)))
	gv = MUTABLE_GV(SvRV(POPs));
    else
	gv = gv_fetchsv(tmpsv = POPs, 0, SVt_PVIO);
d3301 2
a3302 7
    else if (tmpsv && SvOK(tmpsv)) {
	const char *tmps = SvPV_nolen_const(tmpsv);
	if (isDIGIT(*tmps))
	    fd = atoi(tmps);
	else 
	    RETPUSHUNDEF;
    }
d3304 1
a3304 1
	RETPUSHUNDEF;
d3306 2
a3307 2
	RETPUSHYES;
    RETPUSHNO;
d3328 1
a3328 1
    register SV *sv;
d3332 1
a3332 3
    tryAMAGICftest(PL_op->op_type == OP_FTTEXT ? 'T' : 'B');

    STACKED_FTEST_CHECK;
d3335 1
d3337 9
a3345 6
    else if (isGV(TOPs))
	gv = MUTABLE_GV(POPs);
    else if (SvROK(TOPs) && isGV(SvRV(TOPs)))
	gv = MUTABLE_GV(SvRV(POPs));
    else
	gv = NULL;
a3347 1
	EXTEND(SP, 1);
d3350 3
a3352 1
		io = GvIO(PL_statgv);
a3353 1
		sv = PL_statname;
a3358 1
	    PL_laststatval = -1;
d3362 2
d3369 1
a3369 1
		RETPUSHUNDEF;
d3372 1
a3372 1
		    RETPUSHNO;
d3374 1
a3374 1
		    RETPUSHYES;
d3382 1
a3382 1
		RETPUSHYES;
a3389 4
	    if (ckWARN2(WARN_UNOPENED,WARN_CLOSED)) {
		gv = cGVOP_gv;
		report_evil_fh(gv, GvIO(gv), PL_op->op_type);
	    }
d3391 3
a3393 1
	    RETPUSHUNDEF;
d3397 1
a3397 1
	sv = POPs;
a3399 2
	PL_laststype = OP_STAT;
	sv_setpv(PL_statname, SvPV_nolen_const(sv));
d3401 4
d3408 1
a3408 1
	    RETPUSHUNDEF;
d3410 1
d3414 1
a3414 1
	    RETPUSHUNDEF;
d3421 2
a3422 2
		RETPUSHNO;		/* special case NFS directories */
	    RETPUSHYES;		/* null file is anything */
d3476 1
a3476 1
	RETPUSHNO;
d3478 1
a3478 1
	RETPUSHYES;
d3494 2
a3495 9
        else if (isGV_with_GP(sv)) {
	    gv = MUTABLE_GV(sv);
        }
	else if (SvROK(sv) && isGV_with_GP(SvRV(sv))) {
            gv = MUTABLE_GV(SvRV(sv));
        }
        else {
	    tmps = SvPV_nolen_const(sv);
	}
d3531 1
a3531 2
		if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
		    report_evil_fh(gv, io, PL_op->op_type);
d3537 1
a3537 2
	    if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
		report_evil_fh(gv, io, PL_op->op_type);
a3574 1
    return NORMAL;
d3592 1
a3592 1
	    if (PL_euid || PerlLIO_stat(tmps2, &PL_statbuf) < 0 || !S_ISDIR(PL_statbuf.st_mode))
a3648 1
    return NORMAL;
a3666 1
    EXTEND(SP, 1);
d3794 1
a3794 1
    const int mode = (MAXARG > 1) ? POPi : 0777;
d3849 2
a3850 2
			 "Opening filehandle %s also as a directory",
			 GvENAME(gv));
a3862 1
    return NORMAL;
a3869 1
    return NORMAL;
d3885 2
a3886 1
		       "readdir() attempted on invalid dirhandle %s", GvENAME(gv));
d3937 2
a3938 1
		       "telldir() attempted on invalid dirhandle %s", GvENAME(gv));
a3949 1
    return NORMAL;
d3963 2
a3964 1
		       "seekdir() attempted on invalid dirhandle %s", GvENAME(gv));
a3975 1
    return NORMAL;
d3988 2
a3989 1
		       "rewinddir() attempted on invalid dirhandle %s", GvENAME(gv));
a3999 1
    return NORMAL;
d4012 2
a4013 1
		       "closedir() attempted on invalid dirhandle %s", GvENAME(gv));
a4032 1
    return NORMAL;
a4049 9
	GV * const tmpgv = gv_fetchpvs("$", GV_ADD|GV_NOTQUAL, SVt_PV);
	if (tmpgv) {
            SvREADONLY_off(GvSV(tmpgv));
	    sv_setiv(GvSV(tmpgv), (IV)PerlProc_getpid());
            SvREADONLY_on(GvSV(tmpgv));
        }
#ifdef THREADS_HAVE_PIDS
	PL_ppid = (IV)getppid();
#endif
a4069 1
    return NORMAL;
a4098 1
    return NORMAL;
a4128 1
    return NORMAL;
d4159 3
d4165 5
d4179 3
d4200 3
d4225 1
a4225 1
			DIE(aTHX_ "panic: kid popen errno read");
d4233 3
a4339 6
#   ifdef THREADS_HAVE_PIDS
    if (PL_ppid != 1 && getppid() == 1)
	/* maybe the parent process has died. Refresh ppid cache */
	PL_ppid = 1;
    XPUSHi( PL_ppid );
#   else
a4340 1
#   endif
a4343 1
    return NORMAL;
d4352 2
a4353 1
    const Pid_t pid = (MAXARG < 1) ? 0 : SvIVx(POPs);
a4365 1
    return NORMAL;
d4375 3
a4377 2
    if (MAXARG < 2) {
	pgrp = 0;
a4380 4
    else {
	pgrp = POPi;
	pid = TOPi;
    }
a4395 1
    return NORMAL;
d4399 6
d4411 1
a4411 1
    SETi( getpriority(which, who) );
a4414 1
    return NORMAL;
d4426 1
a4426 1
    SETi( setpriority(which, who, niceval) >= 0 );
a4429 1
    return NORMAL;
d4433 2
a4481 1
    return NORMAL;
d4509 1
a4509 1
    if (MAXARG < 1) {
d4515 1
a4515 1
	double input = Perl_floor(POPn);
d4518 1
d4520 1
a4520 1
			   "%s(%.0f) too large", opname, input);
d4525 1
d4527 1
a4527 1
		       "%s(%.0f) too small", opname, when);
d4531 1
d4533 1
a4533 1
		       "%s(%.0f) too large", opname, when);
d4546 1
a4546 1
		       "%s(%.0f) failed", opname, (double)when);
a4594 1
    EXTEND(SP, 1);
a4600 1
    return NORMAL;
d4612 1
a4612 1
    if (MAXARG < 1)
d4652 1
a4652 1
    return pp_semget();
a4669 1
    return NORMAL;
d4689 1
a4689 1
    return pp_semget();
d4804 1
a4804 2
    DIE(aTHX_ PL_no_sock_func, "gethostent");
    return NORMAL;
d4877 1
a4877 2
    DIE(aTHX_ PL_no_sock_func, "getnetent");
    return NORMAL;
d4937 1
a4937 2
    DIE(aTHX_ PL_no_sock_func, "getprotoent");
    return NORMAL;
d5012 1
a5012 2
    DIE(aTHX_ PL_no_sock_func, "getservent");
    return NORMAL;
d5018 4
d5023 1
a5023 3
    dVAR; dSP;
    PerlSock_sethostent(TOPi);
    RETSETYES;
d5025 1
a5025 2
    DIE(aTHX_ PL_no_sock_func, "sethostent");
    return NORMAL;
d5027 1
a5027 4
}

PP(pp_snetent)
{
d5029 2
a5030 3
    dVAR; dSP;
    (void)PerlSock_setnetent(TOPi);
    RETSETYES;
d5032 1
a5032 2
    DIE(aTHX_ PL_no_sock_func, "setnetent");
    return NORMAL;
d5034 2
a5035 4
}

PP(pp_sprotoent)
{
d5037 1
a5037 3
    dVAR; dSP;
    (void)PerlSock_setprotoent(TOPi);
    RETSETYES;
d5039 1
a5039 2
    DIE(aTHX_ PL_no_sock_func, "setprotoent");
    return NORMAL;
d5041 2
a5042 4
}

PP(pp_sservent)
{
d5044 1
a5044 3
    dVAR; dSP;
    (void)PerlSock_setservent(TOPi);
    RETSETYES;
d5046 1
a5046 2
    DIE(aTHX_ PL_no_sock_func, "setservent");
    return NORMAL;
d5048 3
d5055 3
d5059 1
a5059 4
    dVAR; dSP;
    PerlSock_endhostent();
    EXTEND(SP,1);
    RETPUSHYES;
d5061 1
a5061 2
    DIE(aTHX_ PL_no_sock_func, "endhostent");
    return NORMAL;
d5063 2
a5064 4
}

PP(pp_enetent)
{
d5066 1
a5066 4
    dVAR; dSP;
    PerlSock_endnetent();
    EXTEND(SP,1);
    RETPUSHYES;
d5068 1
a5068 2
    DIE(aTHX_ PL_no_sock_func, "endnetent");
    return NORMAL;
d5070 2
a5071 4
}

PP(pp_eprotoent)
{
d5073 1
a5073 4
    dVAR; dSP;
    PerlSock_endprotoent();
    EXTEND(SP,1);
    RETPUSHYES;
d5075 1
a5075 2
    DIE(aTHX_ PL_no_sock_func, "endprotoent");
    return NORMAL;
d5077 2
a5078 4
}

PP(pp_eservent)
{
d5080 34
a5113 2
    dVAR; dSP;
    PerlSock_endservent();
a5115 4
#else
    DIE(aTHX_ PL_no_sock_func, "endservent");
    return NORMAL;
#endif
d5261 1
a5261 1
			   * to have never made the unsccessful
a5347 25
    return NORMAL;
#endif
}

PP(pp_spwent)
{
#if defined(HAS_PASSWD) && defined(HAS_SETPWENT)
    dVAR; dSP;
    setpwent();
    RETPUSHYES;
#else
    DIE(aTHX_ PL_no_func, "setpwent");
    return NORMAL;
#endif
}

PP(pp_epwent)
{
#if defined(HAS_PASSWD) && defined(HAS_ENDPWENT)
    dVAR; dSP;
    endpwent();
    RETPUSHYES;
#else
    DIE(aTHX_ PL_no_func, "endpwent");
    return NORMAL;
a5421 25
    return NORMAL;
#endif
}

PP(pp_sgrent)
{
#if defined(HAS_GROUP) && defined(HAS_SETGRENT)
    dVAR; dSP;
    setgrent();
    RETPUSHYES;
#else
    DIE(aTHX_ PL_no_func, "setgrent");
    return NORMAL;
#endif
}

PP(pp_egrent)
{
#if defined(HAS_GROUP) && defined(HAS_ENDGRENT)
    dVAR; dSP;
    endgrent();
    RETPUSHYES;
#else
    DIE(aTHX_ PL_no_func, "endgrent");
    return NORMAL;
d5433 2
a5434 1
    PUSHp(tmps, strlen(tmps));
a5437 1
    return NORMAL;
a5535 1
    return NORMAL;
@


1.12
log
@Merge in perl 5.10.1
@
text
@d32 2
a205 9
/* AIX 5.2 and below use mktime for localtime, and defines the edge case
 * for time 0x7fffffff to be valid only in UTC. AIX 5.3 provides localtime64
 * available in the 32bit environment, which could warrant Configure
 * checks in the future.
 */
#ifdef  _AIX
#define LOCALTIME_EDGECASE_BROKEN
#endif

a244 1
    LOCK_CRED_MUTEX;
a289 1
    UNLOCK_CRED_MUTEX;
d321 1
a321 1
	    ENTER;
d327 1
a327 1
	    LEAVE;
d367 1
a367 1
    ENTER;
d392 1
a392 1
    LEAVE;
d500 1
d525 4
a528 3
	if (IoDIRP(io) && ckWARN2(WARN_IO, WARN_DEPRECATED))
	    Perl_warner(aTHX_ packWARN2(WARN_IO, WARN_DEPRECATED),
		    "Opening dirhandle %s also as a file", GvENAME(gv));
d537 1
a537 1
	    ENTER;
d539 1
a539 1
	    LEAVE;
d577 1
a577 1
		ENTER;
d579 1
a579 1
		LEAVE;
d646 1
d668 1
a668 1
	ENTER;
d670 1
a670 1
	LEAVE;
d743 1
a743 1
	    ENTER;
d745 1
a745 1
	    LEAVE;
d761 6
a766 2
	const int mode = mode_from_discipline(discp);
	const char *const d = (discp ? SvPV_nolen_const(discp) : NULL);
d788 1
a788 1
    GV *gv;
a805 5
#ifdef GV_UNIQUE_CHECK
		if (GvUNIQUE((const GV *)varsv)) {
		    Perl_croak(aTHX_ "Attempt to tie unique GV");
		}
#endif
d823 1
a823 1
	ENTER;
d843 1
a843 1
	ENTER;
d866 1
a866 1
    LEAVE;
d893 1
a893 1
	       ENTER;
d895 1
a895 1
	       LEAVE;
d898 4
a901 4
	    else if (mg && SvREFCNT(obj) > 1 && ckWARN(WARN_UNTIE)) {
		  Perl_warner(aTHX_ packWARN(WARN_UNTIE),
		      "untie attempted while %"UVuf" inner references still exist",
		       (UV)SvREFCNT(obj) - 1 ) ;
d936 1
a936 1
    GV *gv;
d945 1
a945 1
	if (!(gv = gv_fetchmethod(stash, "TIEHASH")))
d1024 1
a1024 2
	    if (ckWARN(WARN_MISC))
                Perl_warner(aTHX_ packWARN(WARN_MISC), "Non-string passed as bitmask");
d1144 1
d1148 11
d1164 1
a1164 2
    if (PL_defoutgv)
	SvREFCNT_dec(PL_defoutgv);
d1206 3
d1262 1
a1262 2
    PUSHFORMAT(cx);
    cx->blk_sub.retop = retop;
d1277 2
a1278 2
    CV *cv;
    SV * tmpsv = NULL;
d1322 1
a1322 1
    GV * const gv = cxstack[cxstack_ix].blk_sub.gv;
d1425 1
a1425 2
	    if (ckWARN(WARN_IO))
		Perl_warner(aTHX_ packWARN(WARN_IO), "page overflow");
d1926 1
a1926 1
	    } else if (offset >= (IV)blen_chars && blen_chars > 0) {
d2017 7
d2025 2
a2026 22
    if (MAXARG == 0) {
	if (PL_op->op_flags & OPf_SPECIAL) {	/* eof() */
	    IO *io;
	    gv = PL_last_in_gv = GvEGV(PL_argvgv);
	    io = GvIO(gv);
	    if (io && !IoIFP(io)) {
		if ((IoFLAGS(io) & IOf_START) && av_len(GvAVn(gv)) < 0) {
		    IoLINES(io) = 0;
		    IoFLAGS(io) &= ~IOf_START;
		    do_open(gv, "-", 1, FALSE, O_RDONLY, 0, NULL);
		    if ( GvSV(gv) ) {
			sv_setpvs(GvSV(gv), "-");
		    }
		    else {
			GvSV(gv) = newSVpvs("-");
		    }
		    SvSETMAGIC(GvSV(gv));
		}
		else if (!nextargv(gv))
		    RETPUSHYES;
	    }
	}
a2029 2
    else
	gv = PL_last_in_gv = MUTABLE_GV(POPs);	/* eof(FH) */
d2031 41
a2071 12
    if (gv) {
	IO * const io = GvIO(gv);
	MAGIC * mg;
	if (io && (mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar))) {
	    PUSHMARK(SP);
	    XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
	    PUTBACK;
	    ENTER;
	    call_method("EOF", G_SCALAR);
	    LEAVE;
	    SPAGAIN;
	    RETURN;
d2075 1
a2075 1
    PUSHs(boolSV(!gv || do_eof(gv)));
d2087 2
d2104 6
d2373 1
d2426 1
d2488 1
d2520 1
d2551 1
d2578 1
d2658 1
d2683 1
d2761 1
d2826 1
d2846 2
a2847 3
		if (ckWARN(WARN_IO))
		    Perl_warner(aTHX_ packWARN(WARN_IO),
			"lstat() on filehandle %s", gv ? GvENAME(gv) : "");
d3003 1
d3006 10
d3048 1
a3048 1
	/* Fall through  */
d3108 1
d3110 10
d3121 1
d3158 1
d3161 16
d3193 1
a3259 1
    I32 result = my_lstat();
d3261 6
d3282 2
d3333 2
d3581 1
d3656 1
d3856 4
a3859 3
    if ((IoIFP(io) || IoOFP(io)) && ckWARN2(WARN_IO, WARN_DEPRECATED))
	Perl_warner(aTHX_ packWARN2(WARN_IO, WARN_DEPRECATED),
		"Opening filehandle %s also as a directory", GvENAME(gv));
d3872 1
d3880 1
d3895 2
a3896 4
        if(ckWARN(WARN_IO)) {
            Perl_warner(aTHX_ packWARN(WARN_IO),
                "readdir() attempted on invalid dirhandle %s", GvENAME(gv));
        }
d3946 2
a3947 4
        if(ckWARN(WARN_IO)) {
            Perl_warner(aTHX_ packWARN(WARN_IO),
	        "telldir() attempted on invalid dirhandle %s", GvENAME(gv));
        }
d3959 1
d3972 2
a3973 4
	if(ckWARN(WARN_IO)) {
	    Perl_warner(aTHX_ packWARN(WARN_IO),
                "seekdir() attempted on invalid dirhandle %s", GvENAME(gv));
        }
d3985 1
d3997 2
a3998 4
	if(ckWARN(WARN_IO)) {
	    Perl_warner(aTHX_ packWARN(WARN_IO),
	        "rewinddir() attempted on invalid dirhandle %s", GvENAME(gv));
	}
d4009 1
d4021 2
a4022 4
	if(ckWARN(WARN_IO)) {
	    Perl_warner(aTHX_ packWARN(WARN_IO),
                "closedir() attempted on invalid dirhandle %s", GvENAME(gv));
        }
d4042 1
d4089 1
d4096 1
a4096 1
#if (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(MACOS_TRADITIONAL) && !defined(__LIBCATAMOUNT__)
d4119 1
d4125 1
a4125 1
#if (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(MACOS_TRADITIONAL) && !defined(__LIBCATAMOUNT__)
d4150 1
d4356 1
d4378 1
d4412 1
d4426 1
d4442 1
d4493 1
d4498 8
a4505 39
#ifdef LOCALTIME_EDGECASE_BROKEN
static struct tm *S_my_localtime (pTHX_ Time_t *tp)
{
    auto time_t     T;
    auto struct tm *P;

    /* No workarounds in the valid range */
    if (!tp || *tp < 0x7fff573f || *tp >= 0x80000000)
	return (localtime (tp));

    /* This edge case is to workaround the undefined behaviour, where the
     * TIMEZONE makes the time go beyond the defined range.
     * gmtime (0x7fffffff) => 2038-01-19 03:14:07
     * If there is a negative offset in TZ, like MET-1METDST, some broken
     * implementations of localtime () (like AIX 5.2) barf with bogus
     * return values:
     * 0x7fffffff gmtime               2038-01-19 03:14:07
     * 0x7fffffff localtime            1901-12-13 21:45:51
     * 0x7fffffff mylocaltime          2038-01-19 04:14:07
     * 0x3c19137f gmtime               2001-12-13 20:45:51
     * 0x3c19137f localtime            2001-12-13 21:45:51
     * 0x3c19137f mylocaltime          2001-12-13 21:45:51
     * Given that legal timezones are typically between GMT-12 and GMT+12
     * we turn back the clock 23 hours before calling the localtime
     * function, and add those to the return value. This will never cause
     * day wrapping problems, since the edge case is Tue Jan *19*
     */
    T = *tp - 82800; /* 23 hour. allows up to GMT-23 */
    P = localtime (&T);
    P->tm_hour += 23;
    if (P->tm_hour >= 24) {
	P->tm_hour -= 24;
	P->tm_mday++;	/* 18  -> 19  */
	P->tm_wday++;	/* Mon -> Tue */
	P->tm_yday++;	/* 18  -> 19  */
    }
    return (P);
} /* S_my_localtime */
#endif
d4511 4
a4514 2
    Time_t when;
    const struct tm *tmbuf;
d4521 30
a4550 8
    if (MAXARG < 1)
	(void)time(&when);
    else
#ifdef BIG_TIME
	when = (Time_t)SvNVx(POPs);
#else
	when = (Time_t)SvIVx(POPs);
#endif
d4552 5
a4556 8
    if (PL_op->op_type == OP_LOCALTIME)
#ifdef LOCALTIME_EDGECASE_BROKEN
	tmbuf = S_my_localtime(aTHX_ &when);
#else
	tmbuf = localtime(&when);
#endif
    else
	tmbuf = gmtime(&when);
d4558 1
a4558 1
    if (GIMME != G_ARRAY) {
d4560 3
d4565 1
a4565 1
	if (!tmbuf)
d4567 9
a4575 8
	tsv = Perl_newSVpvf(aTHX_ "%s %s %2d %02d:%02d:%02d %d",
			    dayname[tmbuf->tm_wday],
			    monname[tmbuf->tm_mon],
			    tmbuf->tm_mday,
			    tmbuf->tm_hour,
			    tmbuf->tm_min,
			    tmbuf->tm_sec,
			    tmbuf->tm_year + 1900);
d4578 4
a4581 1
    else if (tmbuf) {
d4584 9
a4592 9
        mPUSHi(tmbuf->tm_sec);
	mPUSHi(tmbuf->tm_min);
	mPUSHi(tmbuf->tm_hour);
	mPUSHi(tmbuf->tm_mday);
	mPUSHi(tmbuf->tm_mon);
	mPUSHi(tmbuf->tm_year);
	mPUSHi(tmbuf->tm_wday);
	mPUSHi(tmbuf->tm_yday);
	mPUSHi(tmbuf->tm_isdst);
d4611 1
d4681 1
d4742 1
a4742 1
    struct hostent *hent;
d4817 1
d4891 1
d4952 1
d5028 1
d5040 1
d5052 1
d5064 1
d5076 1
d5089 1
d5102 1
d5115 1
d5128 1
d5362 1
d5374 1
d5386 1
d5461 1
d5473 1
d5485 1
d5501 1
d5600 1
d5613 1
d5633 4
a5636 1
    return fcntl(fd, (operation & LOCK_NB) ? F_SETLK : F_SETLKW, &flock);
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d4 1
a4 1
 *    2004, 2005, 2006, 2007 by Larry Wall and others
d16 2
d333 1
a333 1
	    sv_setpvn(TARG, "", 0);	/* note that this preserves previous buffer */
d347 1
a347 1
		XPUSHs(sv_2mortal(sv));
d390 1
a390 1
    PL_last_in_gv = (GV*)*PL_stack_sp--;
d393 1
a393 1
    PL_rs = sv_2mortal(newSVpvs("\000"));
d442 1
a442 1
	tmpsv = sv_2mortal(newSVpvs("Warning: something's wrong"));
d488 1
a488 1
		    call_sv((SV*)GvCV(gv),
d506 1
a506 1
	tmpsv = sv_2mortal(newSVpvs("Died"));
d524 1
a524 1
    GV * const gv = (GV *)*++MARK;
d537 1
a537 1
	mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
d541 1
a541 1
	    *MARK-- = SvTIED_obj((SV*)io, mg);
d574 1
a574 1
    GV * const gv = (MAXARG == 0) ? PL_defoutgv : (GV*)POPs;
d579 1
a579 1
	    MAGIC * const mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
d582 1
a582 1
		XPUSHs(SvTIED_obj((SV*)io, mg));
d606 2
a607 2
    GV * const wgv = (GV*)POPs;
    GV * const rgv = (GV*)POPs;
d612 1
a612 1
    if (SvTYPE(rgv) != SVt_PVGV || SvTYPE(wgv) != SVt_PVGV)
d666 1
a666 1
    gv = (GV*)POPs;
d669 1
a669 1
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
d672 1
a672 1
	XPUSHs(SvTIED_obj((SV*)io, mg));
d739 1
a739 1
    gv = (GV*)POPs;
d742 1
a742 1
	MAGIC * const mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
d745 1
a745 1
	    XPUSHs(SvTIED_obj((SV*)io, mg));
d801 1
a801 1
	    HvEITER_set((HV *)varsv, 0);
d807 1
d809 12
a820 2
	    if (GvUNIQUE((GV*)varsv)) {
                Perl_croak(aTHX_ "Attempt to tie unique GV");
d822 1
a822 9
#endif
	    methname = "TIEHANDLE";
	    how = PERL_MAGIC_tiedscalar;
	    /* For tied filehandles, we apply tiedscalar magic to the IO
	       slot of the GP rather than the GV itself. AMS 20010812 */
	    if (!GvIOp(varsv))
		GvIOp(varsv) = newIO();
	    varsv = (SV *)GvIOp(varsv);
	    break;
d829 1
a829 1
    if (sv_isobject(*MARK)) {
d843 3
a845 1
	stash = gv_stashsv(*MARK, 0);
d848 1
a848 1
		 methname, SVfARG(*MARK));
d857 1
a857 1
	call_sv((SV*)GvCV(gv), G_SCALAR);
d887 1
a887 1
    if (SvTYPE(sv) == SVt_PVGV && !(sv = (SV *)GvIOp(sv)))
d897 2
a898 2
	       XPUSHs(SvTIED_obj((SV*)gv, mg));
	       XPUSHs(sv_2mortal(newSViv(SvREFCNT(obj)-1)));
d901 1
a901 1
	       call_sv((SV *)cv, G_VOID);
d925 1
a925 1
    if (SvTYPE(sv) == SVt_PVGV && !(sv = (SV *)GvIOp(sv)))
d945 2
a946 2
    HV * const hv = (HV*)POPs;
    SV * const sv = sv_2mortal(newSVpvs("AnyDBM_File"));
d963 1
a963 1
	PUSHs(sv_2mortal(newSVuv(O_RDWR|O_CREAT)));
d965 1
a965 1
	PUSHs(sv_2mortal(newSVuv(O_RDWR)));
d968 1
a968 1
    call_sv((SV*)GvCV(gv), G_SCALAR);
d976 1
a976 1
	PUSHs(sv_2mortal(newSVuv(O_RDONLY)));
d979 1
a979 1
	call_sv((SV*)GvCV(gv), G_SCALAR);
d984 2
a985 2
	sv_unmagic((SV *) hv, PERL_MAGIC_tied);
	sv_magic((SV*)hv, TOPs, PERL_MAGIC_tied, NULL, 0);
d1028 1
a1028 1
		DIE(aTHX_ PL_no_modify);
d1147 1
a1147 1
	PUSHs(sv_2mortal(newSVnv(value)));
d1169 1
a1169 1
    GV * const newdefout = (PL_op->op_private > 0) ? ((GV *) POPs) : NULL;
d1184 1
a1184 1
	    XPUSHs(sv_2mortal(newRV((SV*)egv)));
d1201 1
a1201 1
    GV * const gv = (MAXARG==0) ? PL_stdingv : (GV*)POPs;
d1204 1
a1204 1
	MAGIC * const mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
d1208 1
a1208 1
	    XPUSHs(SvTIED_obj((SV*)io, mg));
d1227 1
a1227 1
    sv_setpvn(TARG, " ", 1);
d1250 2
d1278 1
a1278 1
	gv = (GV*)POPs;
d1308 1
a1308 1
	cv = (CV*)sv_2mortal((SV*)cv_clone(cv));
d1399 1
a1399 1
	    cv = (CV*)sv_2mortal((SV*)cv_clone(cv));
d1449 2
a1450 1
    GV * const gv = (PL_op->op_flags & OPf_STACKED) ? (GV*)*++MARK : PL_defoutgv;
d1453 1
a1453 1
	MAGIC * const mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
d1462 1
a1462 1
	    *MARK = SvTIED_obj((SV*)io, mg);
d1522 1
a1522 1
    GV * const gv = (GV *)POPs;
d1558 1
a1558 1
    GV * const gv = (GV*)*++MARK;
d1562 1
a1562 1
	const MAGIC * mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
d1566 1
a1566 1
	    *MARK = SvTIED_obj((SV*)io, mg);
d1582 1
a1582 1
	sv_setpvn(bufsv, "", 0);
d1804 1
a1804 1
    GV *const gv = (GV*)*++MARK;
d1807 1
a1807 1
	MAGIC * const mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
d1812 2
a1813 3
		EXTEND(SP, 1000);
		sv = sv_2mortal(newSViv(sv_len(*SP)));
		PUSHs(sv);
d1818 1
a1818 1
	    *(ORIGMARK+1) = SvTIED_obj((SV*)io, mg);
d2025 1
a2025 1
			sv_setpvn(GvSV(gv), "-", 1);
d2028 1
a2028 1
			GvSV(gv) = newSVpvn("-", 1);
d2040 1
a2040 1
	gv = PL_last_in_gv = (GV*)POPs;		/* eof(FH) */
d2045 1
a2045 1
	if (io && (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar))) {
d2047 1
a2047 1
	    XPUSHs(SvTIED_obj((SV*)io, mg));
d2068 1
a2068 1
	PL_last_in_gv = (GV*)POPs;
d2072 1
a2072 1
	MAGIC * const mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
d2075 1
a2075 1
	    XPUSHs(SvTIED_obj((SV*)io, mg));
d2103 1
a2103 1
    GV * const gv = PL_last_in_gv = (GV*)POPs;
d2107 1
a2107 1
	MAGIC * const mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
d2110 1
a2110 1
	    XPUSHs(SvTIED_obj((SV*)io, mg));
d2112 1
a2112 1
	    XPUSHs(sv_2mortal(newSVnv((NV) offset)));
d2114 1
a2114 1
	    XPUSHs(sv_2mortal(newSViv(offset)));
d2116 1
a2116 1
	    XPUSHs(sv_2mortal(newSViv(whence)));
d2140 1
a2140 1
            PUSHs(sv_2mortal(sv));
d2200 2
a2201 2
	    if (SvTYPE(sv) == SVt_PVGV) {
	        tmpgv = (GV*)sv;		/* *main::FRED for example */
d2204 2
a2205 2
	    else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVGV) {
	        tmpgv = (GV*) SvRV(sv);	/* \*main::FRED for example */
d2209 1
a2209 1
		io = (IO*) SvRV(sv); /* *main::FRED{IO} for example */
d2247 1
a2247 1
    GV * const gv = (GV*)POPs;
d2324 1
a2324 1
    GV * const gv = (MAXARG == 0) ? PL_last_in_gv : (GV*)POPs;
d2359 1
a2359 1
    GV * const gv = (GV*)POPs;
d2409 2
a2410 2
    GV * const gv2 = (GV*)POPs;
    GV * const gv1 = (GV*)POPs;
d2470 1
a2470 1
    GV * const gv = (GV*)POPs;
d2499 1
a2499 1
    GV * const gv = (GV*)POPs;
d2529 1
a2529 1
    GV * const gv = (GV*)POPs;
d2562 2
a2563 2
    GV * const ggv = (GV*)POPs;
    GV * const ngv = (GV*)POPs;
d2634 1
a2634 1
    GV * const gv = (GV*)POPs;
d2661 1
a2661 1
    GV * const gv = (GV*)POPs;
d2735 1
a2735 1
    GV * const gv = (GV*)POPs;
d2821 1
a2821 1
	    sv_setpvn(PL_statname, "", 0);
d2847 2
a2848 2
	if (SvTYPE(sv) == SVt_PVGV) {
	    gv = (GV*)sv;
d2850 2
a2851 2
	} else if(SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVGV) {
            gv = (GV*)SvRV(sv);
d2856 1
a2856 1
            io = (IO*)SvRV(sv);
d2885 4
a2888 4
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_dev)));
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_ino)));
	PUSHs(sv_2mortal(newSVuv(PL_statcache.st_mode)));
	PUSHs(sv_2mortal(newSVuv(PL_statcache.st_nlink)));
d2890 1
a2890 1
	PUSHs(sv_2mortal(newSVnv(PL_statcache.st_uid)));
d2893 1
a2893 1
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_uid)));
d2895 1
a2895 1
	PUSHs(sv_2mortal(newSVuv(PL_statcache.st_uid)));
d2899 1
a2899 1
	PUSHs(sv_2mortal(newSVnv(PL_statcache.st_gid)));
d2902 1
a2902 1
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_gid)));
d2904 1
a2904 1
	PUSHs(sv_2mortal(newSVuv(PL_statcache.st_gid)));
d2908 1
a2908 1
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_rdev)));
d2910 1
a2910 1
	PUSHs(sv_2mortal(newSVpvs("")));
d2913 1
a2913 1
	PUSHs(sv_2mortal(newSVnv((NV)PL_statcache.st_size)));
d2915 1
a2915 1
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_size)));
d2918 7
a2924 7
	PUSHs(sv_2mortal(newSVnv(PL_statcache.st_atime)));
	PUSHs(sv_2mortal(newSVnv(PL_statcache.st_mtime)));
	PUSHs(sv_2mortal(newSVnv(PL_statcache.st_ctime)));
#else
	PUSHs(sv_2mortal(newSViv((IV)PL_statcache.st_atime)));
	PUSHs(sv_2mortal(newSViv((IV)PL_statcache.st_mtime)));
	PUSHs(sv_2mortal(newSViv((IV)PL_statcache.st_ctime)));
d2927 2
a2928 2
	PUSHs(sv_2mortal(newSVuv(PL_statcache.st_blksize)));
	PUSHs(sv_2mortal(newSVuv(PL_statcache.st_blocks)));
d2930 2
a2931 2
	PUSHs(sv_2mortal(newSVpvs("")));
	PUSHs(sv_2mortal(newSVpvs("")));
d2942 1
a2942 1
	if (TOPs == &PL_sv_no || TOPs == &PL_sv_undef) { RETURN; } \
a3010 1

d3013 1
a3013 1
	access_mode = W_OK;
d3206 1
a3206 1
	gv = (GV*)POPs;
d3208 1
a3208 1
	gv = (GV*)SvRV(POPs);
d3255 1
a3255 1
	gv = (GV*)POPs;
d3257 1
a3257 1
	gv = (GV*)SvRV(POPs);
d3274 1
a3274 1
	    sv_setpvn(PL_statname, "", 0);
d3406 2
a3407 2
        else if (SvTYPE(sv) == SVt_PVGV) {
	    gv = (GV*)sv;
d3409 2
a3410 2
	else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVGV) {
            gv = (GV*)SvRV(sv);
d3610 2
d3763 1
a3763 1
    GV * const gv = (GV*)POPs;
d3800 1
a3800 1
    GV * const gv = (GV *)POPs;
d3825 1
a3825 1
        XPUSHs(sv_2mortal(sv));
d3854 1
a3854 1
    GV * const gv = (GV*)POPs;
d3881 1
a3881 1
    GV * const gv = (GV*)POPs;
d3907 1
a3907 1
    GV * const gv = (GV*)POPs;
d3932 1
a3932 1
    GV * const gv = (GV*)POPs;
d4176 1
a4176 1
#  if defined(WIN32) || defined(OS2) || defined(__SYMBIAN32__)
d4183 1
a4183 1
#  if defined(WIN32) || defined(OS2) || defined(__SYMBIAN32__)
d4302 1
d4381 1
a4381 1
    PUSHs(sv_2mortal(newSVnv(((NV)PL_timesbuf.tms_utime)/(NV)PL_clocktick)));
d4383 3
a4385 3
	PUSHs(sv_2mortal(newSVnv(((NV)PL_timesbuf.tms_stime)/(NV)PL_clocktick)));
	PUSHs(sv_2mortal(newSVnv(((NV)PL_timesbuf.tms_cutime)/(NV)PL_clocktick)));
	PUSHs(sv_2mortal(newSVnv(((NV)PL_timesbuf.tms_cstime)/(NV)PL_clocktick)));
d4391 1
a4391 1
    PUSHs(sv_2mortal(newSVnv((NV)0.0)));
d4394 3
a4396 3
	 PUSHs(sv_2mortal(newSVnv((NV)0.0)));
	 PUSHs(sv_2mortal(newSVnv((NV)0.0)));
	 PUSHs(sv_2mortal(newSVnv((NV)0.0)));
d4489 1
a4489 1
	PUSHs(sv_2mortal(tsv));
d4494 9
a4502 9
        PUSHs(sv_2mortal(newSViv(tmbuf->tm_sec)));
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_min)));
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_hour)));
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_mday)));
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_mon)));
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_year)));
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_wday)));
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_yday)));
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_isdst)));
d4620 2
d4623 1
a4623 1
	target = sv_2mortal(newSVpvs(""));
d4706 1
a4706 1
	PUSHs(sv_2mortal(newSVpv((char*)hent->h_name, 0)));
d4708 1
a4708 1
	PUSHs(sv_2mortal(newSViv((IV)hent->h_addrtype)));
d4710 1
a4710 1
	PUSHs(sv_2mortal(newSViv((IV)len)));
d4713 1
a4713 1
	    XPUSHs(sv_2mortal(newSVpvn(*elem, len)));
d4717 1
a4717 1
	    PUSHs(newSVpvn(hent->h_addr, len));
d4789 1
a4789 1
	PUSHs(sv_2mortal(newSVpv(nent->n_name, 0)));
d4791 2
a4792 2
	PUSHs(sv_2mortal(newSViv((IV)nent->n_addrtype)));
	PUSHs(sv_2mortal(newSViv((IV)nent->n_net)));
d4850 1
a4850 1
	PUSHs(sv_2mortal(newSVpv(pent->p_name, 0)));
d4852 1
a4852 1
	PUSHs(sv_2mortal(newSViv((IV)pent->p_proto)));
d4920 1
a4920 1
	PUSHs(sv_2mortal(newSVpv(sent->s_name, 0)));
d4923 1
a4923 1
	PUSHs(sv_2mortal(newSViv((IV)PerlSock_ntohs(sent->s_port))));
d4925 1
a4925 1
	PUSHs(sv_2mortal(newSViv((IV)(sent->s_port))));
d4927 1
a4927 1
	PUSHs(sv_2mortal(newSVpv(sent->s_proto, 0)));
d4951 1
a4951 1
    PerlSock_setnetent(TOPi);
d4962 1
a4962 1
    PerlSock_setprotoent(TOPi);
d4973 1
a4973 1
    PerlSock_setservent(TOPi);
d5143 1
a5143 1
	PUSHs(sv_2mortal(newSVpv(pwent->pw_name, 0)));
d5145 2
a5146 1
	PUSHs(sv = sv_2mortal(newSViv(0)));
d5167 1
a5167 1
	    const int saverrno = errno;
d5173 1
a5173 1
	    errno = saverrno;
d5190 1
a5190 1
	PUSHs(sv_2mortal(newSViv((IV)pwent->pw_uid)));
d5192 1
a5192 1
	PUSHs(sv_2mortal(newSVuv((UV)pwent->pw_uid)));
d5196 1
a5196 1
	PUSHs(sv_2mortal(newSViv((IV)pwent->pw_gid)));
d5198 1
a5198 1
	PUSHs(sv_2mortal(newSVuv((UV)pwent->pw_gid)));
d5206 1
a5206 1
	PUSHs(sv_2mortal(newSViv((IV)pwent->pw_change)));
d5209 1
a5209 1
	PUSHs(sv_2mortal(newSViv((IV)pwent->pw_quota)));
d5212 1
a5212 1
	PUSHs(sv_2mortal(newSVpv(pwent->pw_age, 0)));
d5223 1
a5223 1
	PUSHs(sv_2mortal(newSVpv(pwent->pw_class, 0)));
d5226 1
a5226 1
	PUSHs(sv_2mortal(newSVpv(pwent->pw_comment, 0)));
d5243 1
a5243 1
	PUSHs(sv_2mortal(newSVpv(pwent->pw_dir, 0)));
d5252 1
a5252 1
	PUSHs(sv_2mortal(newSViv((IV)pwent->pw_expire)));
d5312 1
d5314 3
d5324 1
a5324 1
	PUSHs(sv_2mortal(newSVpv(grent->gr_name, 0)));
d5327 1
a5327 1
	PUSHs(sv_2mortal(newSVpv(grent->gr_passwd, 0)));
d5332 5
a5336 1
	PUSHs(sv_2mortal(newSViv((IV)grent->gr_gid)));
a5558 1
    const int save_errno = errno;
d5560 1
d5567 1
a5567 1
    errno = save_errno;
@


1.10
log
@merge in perl 5.8.8
@
text
@d3 2
a4 2
 *    Copyright (C) 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d200 1
a200 3
#undef PERL_EFF_ACCESS_R_OK	/* EFFective uid/gid ACCESS R_OK */
#undef PERL_EFF_ACCESS_W_OK
#undef PERL_EFF_ACCESS_X_OK
d213 1
a213 1
#if !defined(PERL_EFF_ACCESS_R_OK) && defined(HAS_ACCESS) && defined(EFF_ONLY_OK) && !defined(NO_EFF_ONLY_OK)
d215 1
a215 3
#   define PERL_EFF_ACCESS_R_OK(p) (access((p), R_OK | EFF_ONLY_OK))
#   define PERL_EFF_ACCESS_W_OK(p) (access((p), W_OK | EFF_ONLY_OK))
#   define PERL_EFF_ACCESS_X_OK(p) (access((p), X_OK | EFF_ONLY_OK))
d218 1
a218 1
#if !defined(PERL_EFF_ACCESS_R_OK) && defined(HAS_EACCESS)
d224 1
a224 3
#       define PERL_EFF_ACCESS_R_OK(p) (eaccess((p), R_OK, ACC_SELF))
#       define PERL_EFF_ACCESS_W_OK(p) (eaccess((p), W_OK, ACC_SELF))
#       define PERL_EFF_ACCESS_X_OK(p) (eaccess((p), X_OK, ACC_SELF))
d227 1
a227 3
#       define PERL_EFF_ACCESS_R_OK(p) (eaccess((p), R_OK))
#       define PERL_EFF_ACCESS_W_OK(p) (eaccess((p), W_OK))
#       define PERL_EFF_ACCESS_X_OK(p) (eaccess((p), X_OK))
d231 1
a231 1
#if !defined(PERL_EFF_ACCESS_R_OK) && defined(HAS_ACCESSX) && defined(ACC_SELF)
d233 1
a233 3
#   define PERL_EFF_ACCESS_R_OK(p) (accessx((p), R_OK, ACC_SELF))
#   define PERL_EFF_ACCESS_W_OK(p) (accessx((p), W_OK, ACC_SELF))
#   define PERL_EFF_ACCESS_X_OK(p) (accessx((p), X_OK, ACC_SELF))
d236 2
a237 1
#if !defined(PERL_EFF_ACCESS_R_OK) && defined(HAS_ACCESS)	\
d244 4
a247 4
    Uid_t ruid = getuid();
    Uid_t euid = geteuid();
    Gid_t rgid = getgid();
    Gid_t egid = getegid();
d300 1
a300 18
#   define PERL_EFF_ACCESS_R_OK(p) (emulate_eaccess((p), R_OK))
#   define PERL_EFF_ACCESS_W_OK(p) (emulate_eaccess((p), W_OK))
#   define PERL_EFF_ACCESS_X_OK(p) (emulate_eaccess((p), X_OK))
#endif

#if !defined(PERL_EFF_ACCESS_R_OK)
/* With it or without it: anyway you get a warning: either that
   it is unused, or it is declared static and never defined.
 */
STATIC int
S_emulate_eaccess(pTHX_ const char* path, Mode_t mode)
{
    (void)path;
    (void)mode;
    Perl_croak(aTHX_ "switching effective uid is not implemented");
    /*NOTREACHED*/
    return -1;
}
d305 1
a305 1
    dSP; dTARGET;
d316 1
a316 1
    fp = PerlProc_popen((char*)tmps, (char *)mode);
d318 1
a318 4
        const char *type = NULL;
	if (PL_curcop->cop_io) {
	    type = SvPV_nolen_const(PL_curcop->cop_io);
	}
d325 1
a325 1
		;
d332 2
a333 2
	    while (sv_gets(TARG, fp, SvCUR(TARG)) != Nullch)
		;
d340 2
a341 2
		SV * const sv = NEWSV(56, 79);
		if (sv_gets(sv, fp, 0) == Nullch) {
d352 1
a352 1
	STATUS_NATIVE_SET(PerlProc_pclose(fp));
d356 1
a356 1
	STATUS_NATIVE_SET(-1);
d366 1
d391 1
a391 1
    PL_rs = sv_2mortal(newSVpvn("\000", 1));
d405 1
d412 1
a412 1
    dSP; dMARK;
d425 1
d433 1
a433 1
	(void)SvUPGRADE(error, SVt_PV);
d435 1
a435 1
	    sv_catpv(error, "\t...caught");
d440 1
a440 1
	tmpsv = sv_2mortal(newSVpvn("Warning: something's wrong", 26));
d442 1
a442 1
    Perl_warn(aTHX_ "%"SVf, tmpsv);
d448 1
a448 1
    dSP; dMARK;
d466 1
a466 1
        tmps = SvROK(tmpsv) ? Nullch : SvPV_const(tmpsv, len);
d469 2
a470 2
  	SV *error = ERRSV;
	(void)SvUPGRADE(error, SVt_PV);
d475 2
a476 2
		HV *stash = SvSTASH(SvRV(error));
		GV *gv = gv_fetchmethod(stash, "PROPAGATE");
d478 2
a479 2
		    SV *file = sv_2mortal(newSVpv(CopFILE(PL_curcop),0));
		    SV *line = sv_2mortal(newSVuv(CopLINE(PL_curcop)));
d491 1
a491 1
	    DIE(aTHX_ Nullch);
d495 1
a495 1
		sv_catpv(error, "\t...propagated");
d500 1
a500 1
		tmps = Nullch;
d504 1
a504 1
	tmpsv = sv_2mortal(newSVpvn("Died", 4));
d506 1
a506 1
    DIE(aTHX_ "%"SVf, tmpsv);
d513 1
a513 1
    dSP;
a515 1
    GV *gv;
a519 1
    MAGIC *mg;
d522 2
a523 1
    gv = (GV *)*++MARK;
d526 3
a528 1
    if ((io = GvIOp(gv)))
d531 17
a547 11
    if (io && (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar))) {
	/* Method's args are same as ours ... */
	/* ... except handle is replaced by the object */
	*MARK-- = SvTIED_obj((SV*)io, mg);
	PUSHMARK(MARK);
	PUTBACK;
	ENTER;
	call_method("OPEN", G_SCALAR);
	LEAVE;
	SPAGAIN;
	RETURN;
d558 1
a558 1
    ok = do_openn(gv, (char *)tmps, len, FALSE, O_RDONLY, 0, Nullfp, MARK+1, (SP-MARK));
d571 2
a572 4
    dSP;
    GV *gv;
    IO *io;
    MAGIC *mg;
d574 15
a588 16
    if (MAXARG == 0)
	gv = PL_defoutgv;
    else
	gv = (GV*)POPs;

    if (gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)io, mg));
	PUTBACK;
	ENTER;
	call_method("CLOSE", G_SCALAR);
	LEAVE;
	SPAGAIN;
	RETURN;
d598 1
a599 2
    GV *rgv;
    GV *wgv;
d604 2
a605 2
    wgv = (GV*)POPs;
    rgv = (GV*)POPs;
d631 8
a638 4
	if (IoIFP(rstio)) PerlIO_close(IoIFP(rstio));
	else PerlLIO_close(fd[0]);
	if (IoOFP(wstio)) PerlIO_close(IoOFP(wstio));
	else PerlLIO_close(fd[1]);
d656 1
a656 1
    dSP; dTARGET;
d694 1
d701 6
a706 2
	anum = PerlLIO_umask(0);
	(void)PerlLIO_umask(anum);
d725 1
a725 1
    dSP;
d729 1
a729 2
    MAGIC *mg;
    SV *discp = Nullsv;
d739 14
a752 13
    if (gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)io, mg));
	if (discp)
	    XPUSHs(discp);
	PUTBACK;
	ENTER;
	call_method("BINMODE", G_SCALAR);
	LEAVE;
	SPAGAIN;
	RETURN;
d764 16
a779 9
    if (PerlIO_binmode(aTHX_ fp,IoTYPE(io),mode_from_discipline(discp),
                       (discp) ? SvPV_nolen_const(discp) : Nullch)) {
	if (IoOFP(io) && IoOFP(io) != IoIFP(io)) {
	     if (!PerlIO_binmode(aTHX_ IoOFP(io),IoTYPE(io),
			mode_from_discipline(discp),
                       (discp) ? SvPV_nolen_const(discp) : Nullch)) {
		SPAGAIN;
		RETPUSHUNDEF;
	     }
a780 6
	SPAGAIN;
	RETPUSHYES;
    }
    else {
	SPAGAIN;
	RETPUSHUNDEF;
d786 1
a786 2
    dSP; dMARK;
    SV *varsv;
d794 1
a795 1
    varsv = *++MARK;
d838 1
a838 1
	stash = gv_stashsv(*MARK, FALSE);
d841 1
a841 1
		 methname, *MARK);
d864 1
a864 1
	sv_magic(varsv, (SvRV(sv) == varsv ? Nullsv : sv), how, Nullch, 0);
d874 1
a874 1
    dSP;
a884 2
	GV *gv;
	CV *cv = NULL;
d886 3
a888 2
	    if ((gv = gv_fetchmethod_autoload(SvSTASH(obj), "UNTIE", FALSE)) &&
               isGV(gv) && (cv = GvCV(gv))) {
d902 1
a902 1
           }
d911 1
d933 1
a933 1
    dSP;
a936 1
    SV *sv;
d939 2
a940 4

    sv = sv_mortalcopy(&PL_sv_no);
    sv_setpv(sv, "AnyDBM_File");
    stash = gv_stashsv(sv, FALSE);
d978 1
a978 1
	sv_magic((SV*)hv, TOPs, PERL_MAGIC_tied, Nullch, 0);
a983 5
PP(pp_dbmclose)
{
    return pp_untie();
}

d987 1
a987 1
    dSP; dTARGET;
d1014 1
a1014 1
	SV *sv = SP[i];
d1073 1
a1073 1
	tbuf = Null(struct timeval*);
d1140 1
a1140 2
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setnv(sv, value);
d1151 2
a1152 2
    if (gv)
	(void)SvREFCNT_inc(gv);
d1160 1
a1160 2
    dSP; dTARGET;
    GV *egv;
d1162 2
a1164 3
    GV * const newdefout = (PL_op->op_private > 0) ? ((GV *) POPs) : (GV *) NULL;

    egv = GvEGV(PL_defoutgv);
d1171 1
a1171 1
	GV ** const gvp = (GV**)hv_fetch(hv, GvNAME(egv), GvNAMELEN(egv), FALSE);
d1173 1
a1173 1
	    gv_efullname4(TARG, PL_defoutgv, Nullch, TRUE);
d1192 1
a1192 1
    dSP; dTARGET;
a1193 1
    MAGIC *mg;
d1196 15
a1210 14
    if (gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
	const I32 gimme = GIMME_V;
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)io, mg));
	PUTBACK;
	ENTER;
	call_method("GETC", gimme);
	LEAVE;
	SPAGAIN;
	if (gimme == G_SCALAR)
	    SvSetMagicSV_nosteal(TARG, TOPs);
	RETURN;
a1235 5
PP(pp_read)
{
    return pp_sysread();
}

d1239 1
a1245 1
    push_return(retop);
d1248 1
d1258 1
d1264 1
d1283 3
d1288 8
a1295 8
	if (fgv) {
	    SV * const tmpsv = sv_newmortal();
	    const char *name;
	    gv_efullname4(tmpsv, fgv, Nullch, FALSE);
	    name = SvPV_nolen_const(tmpsv);
	    if (name && *name)
		DIE(aTHX_ "Undefined format \"%s\" called", name);
	}
d1307 1
a1307 1
    dSP;
d1310 1
a1310 1
    PerlIO * const ofp = IoOFP(io);
d1316 3
d1321 1
a1321 2
    if (!io || !ofp)
	goto forget_top;
d1335 1
a1335 1
		topgv = gv_fetchpv(SvPVX(topname), FALSE, SVt_PVFM);
d1337 1
a1337 1
		  !gv_fetchpv("top",FALSE,SVt_PVFM))
d1340 1
a1340 1
		    IoTOP_NAME(io) = savepv("top");
d1342 1
a1342 1
	    topgv = gv_fetchpv(IoTOP_NAME(io),FALSE, SVt_PVFM);
d1365 1
a1365 1
		sv_chop(PL_formtarget, (char *)s);
d1382 1
a1382 1
	    gv_efullname4(sv, fgv, Nullch, FALSE);
d1385 3
a1387 1
		DIE(aTHX_ "Undefined top format \"%s\" called",name);
d1389 1
a1389 5
	/* why no:
	else
	    DIE(aTHX_ "Undefined top format called");
	?*/
	if (CvCLONE(cv))
d1391 1
a1391 1
	return doform(cv,gv,PL_op);
d1430 1
a1430 1
    return pop_return();
d1435 1
a1435 2
    dSP; dMARK; dORIGMARK;
    GV *gv;
a1438 1
    MAGIC *mg;
d1440 1
a1440 4
    if (PL_op->op_flags & OPf_STACKED)
	gv = (GV*)*++MARK;
    else
	gv = PL_defoutgv;
d1442 20
a1461 8
    if (gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
	if (MARK == ORIGMARK) {
	    MEXTEND(SP, 1);
	    ++MARK;
	    Move(MARK, MARK + 1, (SP - MARK) + 1, SV*);
	    ++SP;
a1462 11
	PUSHMARK(MARK - 1);
	*MARK = SvTIED_obj((SV*)io, mg);
	PUTBACK;
	ENTER;
	call_method("PRINTF", G_SCALAR);
	LEAVE;
	SPAGAIN;
	MARK = ORIGMARK + 1;
	*MARK = *SP;
	SP = MARK;
	RETURN;
d1465 1
a1465 1
    sv = NEWSV(0,0);
d1483 2
d1507 1
d1518 1
a1518 1
    if (do_open(gv, (char*)tmps, len, TRUE, mode, perm, Nullfp)) {
d1530 1
a1530 1
    dSP; dMARK; dORIGMARK; dTARGET;
d1619 1
a1619 1
			  (struct sockaddr *)namebuf, &bufsize);
d1683 1
a1683 1
	(void)SvUPGRADE(read_target, SVt_PV);
a1780 14
PP(pp_syswrite)
{
    dSP;
    const int items = (SP - PL_stack_base) - TOPMARK;
    if (items == 2) {
	SV *sv;
        EXTEND(SP, 1);
	sv = sv_2mortal(newSViv(sv_len(*SP)));
	PUSHs(sv);
        PUTBACK;
    }
    return pp_send();
}

d1783 1
a1783 2
    dSP; dMARK; dORIGMARK; dTARGET;
    GV *gv;
a1786 1
    Size_t length;
d1789 18
a1806 1
    MAGIC *mg;
d1808 11
a1818 17
    gv = (GV*)*++MARK;
    if (PL_op->op_type == OP_SYSWRITE
	&& gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
	SV *sv;
	
	PUSHMARK(MARK-1);
	*MARK = SvTIED_obj((SV*)io, mg);
	ENTER;
	call_method("WRITE", G_SCALAR);
	LEAVE;
	SPAGAIN;
	sv = POPs;
	SP = ORIGMARK;
	PUSHs(sv);
	RETURN;
d1822 1
d1824 1
a1824 7
#if Size_t_size > IVSIZE
    length = (Size_t)SvNVx(*++MARK);
#else
    length = (Size_t)SvIVx(*++MARK);
#endif
    if ((SSize_t)length < 0)
	DIE(aTHX_ "Negative length");
d1827 1
a1827 1
    if (!io || !IoIFP(io)) {
d1829 6
a1834 2
	if (ckWARN(WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
d1839 5
d1846 5
a1850 4
	    bufsv = sv_2mortal(newSVsv(bufsv));
	    buffer = sv_2pvutf8(bufsv, &blen);
	} else
	    buffer = SvPV_const(bufsv, blen);
d1852 12
a1863 7
    else {
	 if (DO_UTF8(bufsv)) {
	      /* Not modifying source SV, so making a temporary copy. */
	      bufsv = sv_2mortal(newSVsv(bufsv));
	      sv_utf8_downgrade(bufsv, FALSE);
	 }
	 buffer = SvPV_const(bufsv, blen);
d1866 3
a1868 1
    if (PL_op->op_type == OP_SYSWRITE) {
d1870 33
a1902 3
	if (DO_UTF8(bufsv)) {
	    /* length and offset are in chars */
	    blen   = sv_len_utf8(bufsv);
d1904 1
d1908 2
a1909 1
		if (-offset > (IV)blen)
d1911 4
a1914 2
		offset += blen;
	    } else if (offset >= (IV)blen && blen > 0)
d1916 1
d1919 25
a1943 5
	if (length > blen - offset)
	    length = blen - offset;
	if (DO_UTF8(bufsv)) {
	    buffer = (const char*)utf8_hop((U8 *)buffer, offset);
	    length = utf8_hop((U8 *)buffer, length) - (U8 *)buffer;
d1962 12
a1973 6
    else if (SP > MARK) {
	STRLEN mlen;
	char * const sockbuf = SvPVx(*++MARK, mlen);
	/* length is really flags */
	retval = PerlSock_sendto(PerlIO_fileno(IoIFP(io)), buffer, blen,
				 length, (struct sockaddr *)sockbuf, mlen);
a1974 3
    else
	/* length is really flags */
	retval = PerlSock_send(PerlIO_fileno(IoIFP(io)), buffer, blen, length);
d1979 1
d1983 1
a1983 1
    if (DO_UTF8(bufsv))
d1985 2
d1995 1
a1999 5
PP(pp_recv)
{
    return pp_sysread();
}

d2002 1
a2002 1
    dSP;
a2003 2
    IO *io;
    MAGIC *mg;
d2014 7
a2020 2
		    do_open(gv, (char *)"-", 1, FALSE, O_RDONLY, 0, Nullfp);
		    sv_setpvn(GvSV(gv), "-", 1);
d2033 13
a2045 11
    if (gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)io, mg));
	PUTBACK;
	ENTER;
	call_method("EOF", G_SCALAR);
	LEAVE;
	SPAGAIN;
	RETURN;
d2054 1
a2054 1
    dSP; dTARGET;
a2056 1
    MAGIC *mg;
d2058 16
a2073 16
    if (MAXARG == 0)
	gv = PL_last_in_gv;
    else
	gv = PL_last_in_gv = (GV*)POPs;

    if (gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)io, mg));
	PUTBACK;
	ENTER;
	call_method("TELL", G_SCALAR);
	LEAVE;
	SPAGAIN;
	RETURN;
a2083 5
PP(pp_seek)
{
    return pp_sysseek();
}

d2086 1
a2086 3
    dSP;
    GV *gv;
    IO *io;
d2089 1
a2089 1
    Off_t offset = (Off_t)SvNVx(POPs);
d2091 1
a2091 1
    Off_t offset = (Off_t)SvIVx(POPs);
a2092 1
    MAGIC *mg;
d2094 2
a2095 1
    gv = PL_last_in_gv = (GV*)POPs;
d2097 5
a2101 5
    if (gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)io, mg));
d2103 1
a2103 1
	XPUSHs(sv_2mortal(newSVnv((NV) offset)));
d2105 1
a2105 1
	XPUSHs(sv_2mortal(newSViv(offset)));
d2107 8
a2114 7
	XPUSHs(sv_2mortal(newSViv(whence)));
	PUTBACK;
	ENTER;
	call_method("SEEK", G_SCALAR);
	LEAVE;
	SPAGAIN;
	RETURN;
d2120 1
a2120 1
	Off_t sought = do_sysseek(gv, offset, whence);
d2124 1
a2124 1
            SV* sv = sought ?
d2139 1
d2163 1
a2163 1
	    tmpgv = gv_fetchpv(POPpx, FALSE, SVt_PVIO);
d2188 3
a2190 3
	    SV *sv = POPs;
	    const  char *name;
	
d2211 1
a2211 1
	        int tmpfd;
d2213 1
a2213 1
		if ((tmpfd = PerlLIO_open(name, O_RDWR)) < 0)
a2231 5
PP(pp_fcntl)
{
    return pp_ioctl();
}

d2234 2
a2235 2
    dSP; dTARGET;
    SV *argsv = POPs;
d2238 2
a2241 2
    GV *gv = (GV*)POPs;
    IO *io = gv ? GvIOn(gv) : 0;
d2267 1
a2267 1
    TAINT_PROPER(optype == OP_IOCTL ? "ioctl" : "fcntl");
d2310 1
a2310 1
    dSP; dTARGET;
a2311 2
    int argtype;
    GV *gv;
d2314 2
a2316 5
    argtype = POPi;
    if (MAXARG == 0)
	gv = PL_last_in_gv;
    else
	gv = (GV*)POPs;
d2320 1
a2320 1
	fp = Nullfp;
d2323 1
d2346 6
a2351 6
    dSP;
    GV *gv;
    register IO *io;
    int protocol = POPi;
    int type = POPi;
    int domain = POPi;
a2353 3
    gv = (GV*)POPs;
    io = gv ? GvIOn(gv) : NULL;

d2357 1
a2357 1
	if (IoIFP(io))
d2396 8
a2403 8
    dSP;
    GV *gv1;
    GV *gv2;
    register IO *io1;
    register IO *io2;
    int protocol = POPi;
    int type = POPi;
    int domain = POPi;
a2405 4
    gv2 = (GV*)POPs;
    gv1 = (GV*)POPs;
    io1 = gv1 ? GvIOn(gv1) : NULL;
    io2 = gv2 ? GvIOn(gv2) : NULL;
d2413 1
a2413 1
	if (IoIFP(io1))
d2415 1
a2415 1
	if (IoIFP(io2))
d2457 2
a2458 2
    dSP;
    SV *addrsv = POPs;
d2461 2
a2462 2
    GV *gv = (GV*)POPs;
    register IO *io = GvIOn(gv);
a2463 1
    int bind_ok = 0;
d2470 1
a2470 6
    if (PerlSock_bind(PerlIO_fileno(IoIFP(io)),
		      (struct sockaddr *)addr, len) >= 0)
	bind_ok = 1;


    if (bind_ok)
d2488 4
a2491 2
    dSP;
    SV *addrsv = POPs;
a2492 2
    GV *gv = (GV*)POPs;
    register IO *io = GvIOn(gv);
d2518 4
a2521 4
    dSP;
    int backlog = POPi;
    GV *gv = (GV*)POPs;
    register IO *io = gv ? GvIOn(gv) : NULL;
d2544 1
a2544 3
    dSP; dTARGET;
    GV *ngv;
    GV *ggv;
d2553 2
a2556 3
    ggv = (GV*)POPs;
    ngv = (GV*)POPs;

d2568 11
d2623 4
a2626 4
    dSP; dTARGET;
    int how = POPi;
    GV *gv = (GV*)POPs;
    register IO *io = GvIOn(gv);
a2643 9
PP(pp_gsockopt)
{
#ifdef HAS_SOCKET
    return pp_ssockopt();
#else
    DIE(aTHX_ PL_no_sock_func, "getsockopt");
#endif
}

d2647 7
a2653 3
    dSP;
    int optype = PL_op->op_type;
    SV *sv;
a2654 4
    unsigned int optname;
    unsigned int lvl;
    GV *gv;
    register IO *io;
a2656 9
    if (optype == OP_GSOCKOPT)
	sv = sv_2mortal(NEWSV(22, 257));
    else
	sv = POPs;
    optname = (unsigned int) POPi;
    lvl = (unsigned int) POPi;

    gv = (GV*)POPs;
    io = GvIOn(gv);
d2675 15
a2689 1
	    const char *buf;
d2693 1
a2693 1
		buf = SvPV_const(sv, l);
d2698 1
a2698 1
		buf = (const char*)&aint;
d2717 1
a2717 10
    DIE(aTHX_ PL_no_sock_func, "setsockopt");
#endif
}

PP(pp_getsockname)
{
#ifdef HAS_SOCKET
    return pp_getpeername();
#else
    DIE(aTHX_ PL_no_sock_func, "getsockname");
d2724 5
a2728 2
    dSP;
    int optype = PL_op->op_type;
a2730 3
    GV *gv = (GV*)POPs;
    register IO *io = GvIOn(gv);
    Sock_size_t len;
d2735 1
a2735 1
    sv = sv_2mortal(NEWSV(22, 257));
d2754 1
a2754 1
		!memcmp((char *)SvPVX_const(sv) + sizeof(u_short), nowhere,
d2781 1
a2781 1
    DIE(aTHX_ PL_no_sock_func, "getpeername");
a2786 5
PP(pp_lstat)
{
    return pp_stat();
}

d2789 1
d2791 2
a2792 1
    GV *gv;
d2800 1
d2803 1
a2803 1
			"lstat() on filehandle %s", GvENAME(gv));
d2813 17
a2829 3
	    PL_laststatval = (GvIO(gv) && IoIFP(GvIOp(gv))
		? PerlLIO_fstat(PerlIO_fileno(IoIFP(GvIOn(gv))), &PL_statcache) : -1);
	}
d2837 1
a2837 1
	SV* sv = POPs;
d2841 12
a2852 8
	}
	else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVGV) {
	    gv = (GV*)SvRV(sv);
	    if (PL_op->op_type == OP_LSTAT && ckWARN(WARN_IO))
		Perl_warner(aTHX_ packWARN(WARN_IO),
			"lstat() on filehandle %s", GvENAME(gv));
	    goto do_fstat;
	}
d2854 1
a2854 1
	PL_statgv = Nullgv;
d2901 1
a2901 1
	PUSHs(sv_2mortal(newSVpvn("", 0)));
d2913 3
a2915 3
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_atime)));
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_mtime)));
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_ctime)));
d2921 2
a2922 2
	PUSHs(sv_2mortal(newSVpvn("", 0)));
	PUSHs(sv_2mortal(newSVpvn("", 0)));
d2928 9
d2939 1
d2941 10
a2950 12
    dSP;
#if defined(HAS_ACCESS) && defined(R_OK)
    if ((PL_op->op_private & OPpFT_ACCESS) && SvPOK(TOPs)) {
	result = access(POPpx, R_OK);
	if (result == 0)
	    RETPUSHYES;
	if (result < 0)
	    RETPUSHUNDEF;
	RETPUSHNO;
    }
    else
	result = my_stat();
d2952 3
a2954 1
    result = my_stat();
d2956 1
a2956 7
    SPAGAIN;
    if (result < 0)
	RETPUSHUNDEF;
    if (cando(S_IRUSR, 0, &PL_statcache))
	RETPUSHYES;
    RETPUSHNO;
}
d2958 1
a2958 3
PP(pp_ftrwrite)
{
    I32 result;
d2960 11
d2972 1
a2972 10
    if ((PL_op->op_private & OPpFT_ACCESS) && SvPOK(TOPs)) {
	result = access(POPpx, W_OK);
	if (result == 0)
	    RETPUSHYES;
	if (result < 0)
	    RETPUSHUNDEF;
	RETPUSHNO;
    }
    else
	result = my_stat();
d2974 1
a2974 1
    result = my_stat();
d2976 2
a2977 7
    SPAGAIN;
    if (result < 0)
	RETPUSHUNDEF;
    if (cando(S_IWUSR, 0, &PL_statcache))
	RETPUSHYES;
    RETPUSHNO;
}
d2979 1
a2979 4
PP(pp_ftrexec)
{
    I32 result;
    dSP;
d2981 1
a2981 10
    if ((PL_op->op_private & OPpFT_ACCESS) && SvPOK(TOPs)) {
	result = access(POPpx, X_OK);
	if (result == 0)
	    RETPUSHYES;
	if (result < 0)
	    RETPUSHUNDEF;
	RETPUSHNO;
    }
    else
	result = my_stat();
d2983 15
a2997 1
    result = my_stat();
d2999 3
a3001 7
    SPAGAIN;
    if (result < 0)
	RETPUSHUNDEF;
    if (cando(S_IXUSR, 0, &PL_statcache))
	RETPUSHYES;
    RETPUSHNO;
}
d3003 3
a3005 15
PP(pp_fteread)
{
    I32 result;
    dSP;
#ifdef PERL_EFF_ACCESS_R_OK
    if ((PL_op->op_private & OPpFT_ACCESS) && SvPOK(TOPs)) {
	result = PERL_EFF_ACCESS_R_OK(POPpx);
	if (result == 0)
	    RETPUSHYES;
	if (result < 0)
	    RETPUSHUNDEF;
	RETPUSHNO;
    }
    else
	result = my_stat();
d3007 1
a3007 1
    result = my_stat();
d3009 4
a3012 7
    SPAGAIN;
    if (result < 0)
	RETPUSHUNDEF;
    if (cando(S_IRUSR, 1, &PL_statcache))
	RETPUSHYES;
    RETPUSHNO;
}
d3014 18
a3031 7
PP(pp_ftewrite)
{
    I32 result;
    dSP;
#ifdef PERL_EFF_ACCESS_W_OK
    if ((PL_op->op_private & OPpFT_ACCESS) && SvPOK(TOPs)) {
	result = PERL_EFF_ACCESS_W_OK(POPpx);
d3037 1
d3039 1
a3039 3
    else
	result = my_stat();
#else
a3040 1
#endif
d3044 1
a3044 1
    if (cando(S_IWUSR, 1, &PL_statcache))
d3049 1
a3049 1
PP(pp_fteexec)
d3051 1
d3053 1
d3055 1
a3055 12
#ifdef PERL_EFF_ACCESS_X_OK
    if ((PL_op->op_private & OPpFT_ACCESS) && SvPOK(TOPs)) {
	result = PERL_EFF_ACCESS_X_OK(POPpx);
	if (result == 0)
	    RETPUSHYES;
	if (result < 0)
	    RETPUSHUNDEF;
	RETPUSHNO;
    }
    else
	result = my_stat();
#else
a3056 1
#endif
d3060 1
a3060 1
    if (cando(S_IXUSR, 1, &PL_statcache))
d3062 6
a3067 46
    RETPUSHNO;
}

PP(pp_ftis)
{
    I32 result = my_stat();
    dSP;
    if (result < 0)
	RETPUSHUNDEF;
    RETPUSHYES;
}

PP(pp_fteowned)
{
    return pp_ftrowned();
}

PP(pp_ftrowned)
{
    I32 result = my_stat();
    dSP;
    if (result < 0)
	RETPUSHUNDEF;
    if (PL_statcache.st_uid == (PL_op->op_type == OP_FTEOWNED ?
				PL_euid : PL_uid) )
	RETPUSHYES;
    RETPUSHNO;
}

PP(pp_ftzero)
{
    I32 result = my_stat();
    dSP;
    if (result < 0)
	RETPUSHUNDEF;
    if (PL_statcache.st_size == 0)
	RETPUSHYES;
    RETPUSHNO;
}

PP(pp_ftsize)
{
    I32 result = my_stat();
    dSP; dTARGET;
    if (result < 0)
	RETPUSHUNDEF;
d3069 1
a3069 1
    PUSHn(PL_statcache.st_size);
d3071 1
a3071 1
    PUSHi(PL_statcache.st_size);
d3073 12
d3088 1
a3088 1
PP(pp_ftmtime)
d3090 2
a3091 31
    I32 result = my_stat();
    dSP; dTARGET;
    if (result < 0)
	RETPUSHUNDEF;
    PUSHn( (((NV)PL_basetime - PL_statcache.st_mtime)) / 86400.0 );
    RETURN;
}

PP(pp_ftatime)
{
    I32 result = my_stat();
    dSP; dTARGET;
    if (result < 0)
	RETPUSHUNDEF;
    PUSHn( (((NV)PL_basetime - PL_statcache.st_atime)) / 86400.0 );
    RETURN;
}

PP(pp_ftctime)
{
    I32 result = my_stat();
    dSP; dTARGET;
    if (result < 0)
	RETPUSHUNDEF;
    PUSHn( (((NV)PL_basetime - PL_statcache.st_ctime)) / 86400.0 );
    RETURN;
}

PP(pp_ftsock)
{
    I32 result = my_stat();
a3092 6
    if (result < 0)
	RETPUSHUNDEF;
    if (S_ISSOCK(PL_statcache.st_mode))
	RETPUSHYES;
    RETPUSHNO;
}
d3094 14
a3107 10
PP(pp_ftchr)
{
    I32 result = my_stat();
    dSP;
    if (result < 0)
	RETPUSHUNDEF;
    if (S_ISCHR(PL_statcache.st_mode))
	RETPUSHYES;
    RETPUSHNO;
}
d3109 3
a3111 4
PP(pp_ftblk)
{
    I32 result = my_stat();
    dSP;
d3114 37
a3150 52
    if (S_ISBLK(PL_statcache.st_mode))
	RETPUSHYES;
    RETPUSHNO;
}

PP(pp_ftfile)
{
    I32 result = my_stat();
    dSP;
    if (result < 0)
	RETPUSHUNDEF;
    if (S_ISREG(PL_statcache.st_mode))
	RETPUSHYES;
    RETPUSHNO;
}

PP(pp_ftdir)
{
    I32 result = my_stat();
    dSP;
    if (result < 0)
	RETPUSHUNDEF;
    if (S_ISDIR(PL_statcache.st_mode))
	RETPUSHYES;
    RETPUSHNO;
}

PP(pp_ftpipe)
{
    I32 result = my_stat();
    dSP;
    if (result < 0)
	RETPUSHUNDEF;
    if (S_ISFIFO(PL_statcache.st_mode))
	RETPUSHYES;
    RETPUSHNO;
}

PP(pp_ftlink)
{
    I32 result = my_lstat();
    dSP;
    if (result < 0)
	RETPUSHUNDEF;
    if (S_ISLNK(PL_statcache.st_mode))
	RETPUSHYES;
    RETPUSHNO;
}

PP(pp_ftsuid)
{
    dSP;
d3152 4
a3155 6
    I32 result = my_stat();
    SPAGAIN;
    if (result < 0)
	RETPUSHUNDEF;
    if (PL_statcache.st_mode & S_ISUID)
	RETPUSHYES;
a3156 6
    RETPUSHNO;
}

PP(pp_ftsgid)
{
    dSP;
d3158 10
a3167 6
    I32 result = my_stat();
    SPAGAIN;
    if (result < 0)
	RETPUSHUNDEF;
    if (PL_statcache.st_mode & S_ISGID)
	RETPUSHYES;
d3169 1
d3173 1
a3173 1
PP(pp_ftsvtx)
d3175 2
a3177 3
#ifdef S_ISVTX
    I32 result = my_stat();
    SPAGAIN;
d3180 1
a3180 1
    if (PL_statcache.st_mode & S_ISVTX)
a3181 1
#endif
d3187 1
d3191 3
a3193 1
    char *tmps = Nullch;
d3202 1
a3202 1
	gv = gv_fetchpv(tmps = POPpx, FALSE, SVt_PVIO);
d3206 7
a3212 2
    else if (tmps && isDIGIT(*tmps))
	fd = atoi(tmps);
d3230 1
d3242 2
d3251 1
a3251 1
	gv = Nullgv;
d3306 1
a3306 1
	PL_statgv = Nullgv;
d3320 1
a3320 1
	PerlIO_binmode(aTHX_ fp, '<', O_BINARY, Nullch);
d3336 1
a3336 1
    if (len && len < sizeof(tbuf) && tbuf[len-1] == 26)
a3384 5
PP(pp_ftbinary)
{
    return pp_fttext();
}

d3389 3
a3391 4
    dSP; dTARGET;
    const char *tmps = 0;
    GV *gv = 0;
    SV **svp;
d3394 5
a3398 2
	SV *sv = POPs;
        if (SvTYPE(sv) == SVt_PVGV) {
d3405 1
a3405 1
	    tmps = SvPVx_nolen_const(sv);
d3410 5
a3414 2
        if (    (svp = hv_fetch(GvHVn(PL_envgv), "HOME", 4, FALSE))
             || (svp = hv_fetch(GvHVn(PL_envgv), "LOGDIR", 6, FALSE))
d3416 1
a3416 1
             || (svp = hv_fetch(GvHVn(PL_envgv), "SYS$LOGIN", 9, FALSE))
d3434 1
a3434 1
	IO* io = GvIO(gv);
d3436 4
a3439 9
	    if (IoIFP(io)) {
		PUSHi(fchdir(PerlIO_fileno(IoIFP(io))) >= 0);
	    }
	    else if (IoDIRP(io)) {
#ifdef HAS_DIRFD
		PUSHi(fchdir(dirfd(IoDIRP(io))) >= 0);
#else
		DIE(aTHX_ PL_no_func, "dirfd");
#endif
d3442 3
d3449 3
d3459 1
a3459 1
	PUSHi( PerlDir_chdir((char *)tmps) >= 0 );
d3470 2
a3471 3
#ifdef HAS_CHOWN
    dSP; dMARK; dTARGET;
    I32 value = (I32)apply(PL_op->op_type, MARK, SP);
a3475 3
#else
    DIE(aTHX_ PL_no_func, "chown");
#endif
d3481 2
a3482 2
    dSP; dTARGET;
    char *tmps = POPpx;
a3490 30
PP(pp_unlink)
{
    dSP; dMARK; dTARGET;
    I32 value;
    value = (I32)apply(PL_op->op_type, MARK, SP);
    SP = MARK;
    PUSHi(value);
    RETURN;
}

PP(pp_chmod)
{
    dSP; dMARK; dTARGET;
    I32 value;
    value = (I32)apply(PL_op->op_type, MARK, SP);
    SP = MARK;
    PUSHi(value);
    RETURN;
}

PP(pp_utime)
{
    dSP; dMARK; dTARGET;
    I32 value;
    value = (I32)apply(PL_op->op_type, MARK, SP);
    SP = MARK;
    PUSHi(value);
    RETURN;
}

d3493 1
a3493 1
    dSP; dTARGET;
d3495 2
a3496 2
    const char *tmps2 = POPpconstx;
    const char *tmps = SvPV_nolen_const(TOPs);
d3516 1
d3519 36
a3554 6
#ifdef HAS_LINK
    dSP; dTARGET;
    const char *tmps2 = POPpconstx;
    const char *tmps = SvPV_nolen_const(TOPs);
    TAINT_PROPER("link");
    SETi( PerlLIO_link(tmps, tmps2) >= 0 );
d3556 1
d3558 4
a3561 2
    DIE(aTHX_ PL_no_func, "link");
#endif
a3562 12

PP(pp_symlink)
{
#ifdef HAS_SYMLINK
    dSP; dTARGET;
    const char *tmps2 = POPpconstx;
    const char *tmps = SvPV_nolen_const(TOPs);
    TAINT_PROPER("symlink");
    SETi( symlink(tmps, tmps2) >= 0 );
    RETURN;
#else
    DIE(aTHX_ PL_no_func, "symlink");
a3563 1
}
d3567 1
d3600 1
d3602 3
a3604 3
    Newx(cmdline, strlen(cmd) + (strlen(filename) * 2) + 10, char);
    strcpy(cmdline, cmd);
    strcat(cmdline, " ");
d3609 2
a3610 1
    strcpy(s, " 2>&1");
d3615 1
a3615 1
	SV *tmpsv = sv_newmortal();
d3619 1
a3619 1
	if (s != Nullch) {
d3628 1
a3628 1
		char *errmsg =
d3702 1
a3702 5
    dSP; dTARGET;
    int mode;
#ifndef HAS_MKDIR
    int oldumask;
#endif
d3706 1
a3706 5

    if (MAXARG > 1)
	mode = POPi;
    else
	mode = 0777;
d3712 1
a3712 1
    SETi( PerlDir_mkdir((char *)tmps, mode) >= 0 );
d3714 2
d3720 1
d3729 1
a3729 1
    dSP; dTARGET;
d3737 1
a3737 1
    SETi( PerlDir_rmdir((char *)tmps) >= 0 );
d3751 4
a3754 4
    dSP;
    const char *dirname = POPpconstx;
    GV *gv = (GV*)POPs;
    register IO *io = GvIOn(gv);
d3759 3
d3764 1
a3764 1
    if (!(IoDIRP(io) = PerlDir_open((char *)dirname)))
d3785 1
d3790 3
a3792 3
    GV *gv = (GV *)POPs;
    register Direntry_t *dp;
    register IO *io = GvIOn(gv);
d3794 7
a3800 2
    if (!io || !IoDIRP(io))
	goto nope;
d3816 1
a3816 2
    }
    while (gimme == G_ARRAY);
d3836 1
a3836 1
    dSP; dTARGET;
d3844 2
a3845 2
    GV *gv = (GV*)POPs;
    register IO *io = GvIOn(gv);
d3847 7
a3853 2
    if (!io || !IoDIRP(io))
	goto nope;
d3869 12
a3880 8
    dSP;
    long along = POPl;
    GV *gv = (GV*)POPs;
    register IO *io = GvIOn(gv);

    if (!io || !IoDIRP(io))
	goto nope;

d3896 9
a3904 5
    dSP;
    GV *gv = (GV*)POPs;
    register IO *io = GvIOn(gv);

    if (!io || !IoDIRP(io))
d3906 1
a3906 1

d3921 11
a3931 7
    dSP;
    GV *gv = (GV*)POPs;
    register IO *io = GvIOn(gv);

    if (!io || !IoDIRP(io))
	goto nope;

d3957 1
a3957 1
    dSP; dTARGET;
a3958 1
    GV *tmpgv;
d3966 2
a3967 1
	if ((tmpgv = gv_fetchpv("$", TRUE, SVt_PV))) {
d3975 1
d3977 1
d4001 2
a4002 2
#if (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(MACOS_TRADITIONAL)
    dSP; dTARGET;
d4016 1
a4016 1
    STATUS_NATIVE_SET((childpid && childpid != -1) ? argflags : -1);
d4018 1
a4018 1
    STATUS_NATIVE_SET((childpid > 0) ? argflags : -1);
d4029 4
a4032 3
#if (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(MACOS_TRADITIONAL)
    dSP; dTARGET;
    Pid_t pid;
a4033 1
    int optype;
a4035 2
    optype = POPi;
    pid = TOPi;
d4046 1
a4046 1
    STATUS_NATIVE_SET((result && result != -1) ? argflags : -1);
d4048 1
a4048 1
    STATUS_NATIVE_SET((result > 0) ? argflags : -1);
d4059 6
a4064 1
    dSP; dMARK; dORIGMARK; dTARGET;
d4107 2
a4108 2
	    rsignal_save(SIGINT, SIG_IGN, &ihand);
	    rsignal_save(SIGQUIT, SIG_IGN, &qhand);
d4117 1
a4117 1
	    STATUS_NATIVE_SET(result == -1 ? -1 : status);
d4122 2
a4123 1
		int n = 0, n1;
d4138 1
a4138 1
		    STATUS_CURRENT = -1;
d4151 1
a4151 1
	    SV *really = *++MARK;
d4155 1
a4155 1
	    value = (I32)do_aexec5(Nullsv, MARK, SP, pp[1], did_pipes);
d4165 2
a4166 2
	SV *really = *++MARK;
#  if defined(WIN32) || defined(OS2) || defined(SYMBIAN)
d4173 2
a4174 2
#  if defined(WIN32) || defined(OS2) || defined(SYMBIAN)
	value = (I32)do_aspawn(Nullsv, MARK, SP);
d4176 1
a4176 1
	value = (I32)do_aspawn(Nullsv, (void **)MARK, (void **)SP);
d4184 1
a4184 1
    STATUS_NATIVE_SET(value);
d4188 2
a4189 1
#endif /* !FORK or VMS */
d4195 1
a4195 1
    dSP; dMARK; dORIGMARK; dTARGET;
d4210 1
a4210 1
	SV *really = *++MARK;
d4215 1
a4215 1
	value = (I32)vms_do_aexec(Nullsv, MARK, SP);
d4219 1
a4219 1
	   (void ) do_aspawn(Nullsv, MARK, SP);
d4223 1
a4223 1
	value = (I32)do_aexec(Nullsv, MARK, SP);
a4243 14
PP(pp_kill)
{
#ifdef HAS_KILL
    dSP; dMARK; dTARGET;
    I32 value;
    value = (I32)apply(PL_op->op_type, MARK, SP);
    SP = MARK;
    PUSHi(value);
    RETURN;
#else
    DIE(aTHX_ PL_no_func, "kill");
#endif
}

d4247 1
a4247 1
    dSP; dTARGET;
d4265 1
a4265 2
    dSP; dTARGET;
    Pid_t pid;
d4267 1
a4268 4
    if (MAXARG < 1)
	pid = 0;
    else
	pid = SvIVx(POPs);
d4286 1
a4286 1
    dSP; dTARGET;
d4318 3
a4320 3
    dSP; dTARGET;
    int who = POPi;
    int which = TOPi;
d4331 4
a4334 4
    dSP; dTARGET;
    int niceval = POPi;
    int who = POPi;
    int which = TOPi;
d4347 1
a4347 1
    dSP; dTARGET;
d4349 1
a4349 1
    XPUSHn( time(Null(Time_t*)) );
d4351 1
a4351 1
    XPUSHi( time(Null(Time_t*)) );
d4359 1
a4393 5
PP(pp_localtime)
{
    return pp_gmtime();
}

d4436 1
d4499 1
a4499 1
    dSP; dTARGET;
d4515 1
a4515 1
    dSP; dTARGET;
d4533 1
a4533 15

PP(pp_shmget)
{
    return pp_semget();
}

PP(pp_shmctl)
{
    return pp_semctl();
}

PP(pp_shmread)
{
    return pp_shmwrite();
}
d4538 3
a4540 9
    dSP; dMARK; dTARGET;
    I32 value = (I32)(do_shmio(PL_op->op_type, MARK, SP) >= 0);
    SP = MARK;
    PUSHi(value);
    RETURN;
#else
    return pp_semget();
#endif
}
d4542 14
a4555 24
/* Message passing. */

PP(pp_msgget)
{
    return pp_semget();
}

PP(pp_msgctl)
{
    return pp_semctl();
}

PP(pp_msgsnd)
{
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
    dSP; dMARK; dTARGET;
    I32 value = (I32)(do_msgsnd(MARK, SP) >= 0);
    SP = MARK;
    PUSHi(value);
    RETURN;
#else
    return pp_semget();
#endif
}
a4556 5
PP(pp_msgrcv)
{
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
    dSP; dMARK; dTARGET;
    I32 value = (I32)(do_msgrcv(MARK, SP) >= 0);
d4570 2
a4571 2
    dSP; dMARK; dTARGET;
    int anum = do_ipcget(PL_op->op_type, MARK, SP);
d4585 2
a4586 2
    dSP; dMARK; dTARGET;
    int anum = do_ipcctl(PL_op->op_type, MARK, SP);
d4602 19
a4620 11
PP(pp_semop)
{
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
    dSP; dMARK; dTARGET;
    I32 value = (I32)(do_semop(MARK, SP) >= 0);
    SP = MARK;
    PUSHi(value);
    RETURN;
#else
    return pp_semget();
#endif
a4624 18
PP(pp_ghbyname)
{
#ifdef HAS_GETHOSTBYNAME
    return pp_ghostent();
#else
    DIE(aTHX_ PL_no_sock_func, "gethostbyname");
#endif
}

PP(pp_ghbyaddr)
{
#ifdef HAS_GETHOSTBYADDR
    return pp_ghostent();
#else
    DIE(aTHX_ PL_no_sock_func, "gethostbyaddr");
#endif
}

d4628 1
a4628 1
    dSP;
d4643 1
a4643 1
        char* name = POPpbytex;
d4651 2
a4652 2
	int addrtype = POPi;
	SV *addrsv = POPs;
d4654 1
a4654 1
	Netdb_host_t addr = (Netdb_host_t) SvPVbyte(addrsv, addrlen);
d4675 1
a4675 1
	    STATUS_NATIVE_SET(h_errno);
d4693 3
a4695 11
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setpv(sv, (char*)hent->h_name);
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	for (elem = hent->h_aliases; elem && *elem; elem++) {
	    sv_catpv(sv, *elem);
	    if (elem[1])
		sv_catpvn(sv, " ", 1);
	}
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setiv(sv, (IV)hent->h_addrtype);
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d4697 1
a4697 1
	sv_setiv(sv, (IV)len);
d4700 1
a4700 2
	    XPUSHs(sv = sv_mortalcopy(&PL_sv_no));
	    sv_setpvn(sv, *elem, len);
a4702 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d4704 3
a4706 1
	    sv_setpvn(sv, hent->h_addr, len);
a4714 18
PP(pp_gnbyname)
{
#ifdef HAS_GETNETBYNAME
    return pp_gnetent();
#else
    DIE(aTHX_ PL_no_sock_func, "getnetbyname");
#endif
}

PP(pp_gnbyaddr)
{
#ifdef HAS_GETNETBYADDR
    return pp_gnetent();
#else
    DIE(aTHX_ PL_no_sock_func, "getnetbyaddr");
#endif
}

d4718 1
a4718 1
    dSP;
a4719 1
    register char **elem;
d4730 1
a4730 1
        char *name = POPpbytex;
d4738 2
a4739 2
	int addrtype = POPi;
	Netdb_net_t addr = (Netdb_net_t) (U32)POPu;
d4759 1
a4759 1
	    STATUS_NATIVE_SET(h_errno);
d4776 4
a4779 12
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setpv(sv, nent->n_name);
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	for (elem = nent->n_aliases; elem && *elem; elem++) {
	    sv_catpv(sv, *elem);
	    if (elem[1])
		sv_catpvn(sv, " ", 1);
	}
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setiv(sv, (IV)nent->n_addrtype);
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setiv(sv, (IV)nent->n_net);
a4787 18
PP(pp_gpbyname)
{
#ifdef HAS_GETPROTOBYNAME
    return pp_gprotoent();
#else
    DIE(aTHX_ PL_no_sock_func, "getprotobyname");
#endif
}

PP(pp_gpbynumber)
{
#ifdef HAS_GETPROTOBYNUMBER
    return pp_gprotoent();
#else
    DIE(aTHX_ PL_no_sock_func, "getprotobynumber");
#endif
}

d4791 1
a4791 1
    dSP;
a4792 1
    register char **elem;
d4803 1
a4803 1
        char* name = POPpbytex;
d4811 1
a4811 1
        int number = POPi;
d4837 3
a4839 10
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setpv(sv, pent->p_name);
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	for (elem = pent->p_aliases; elem && *elem; elem++) {
	    sv_catpv(sv, *elem);
	    if (elem[1])
		sv_catpvn(sv, " ", 1);
	}
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setiv(sv, (IV)pent->p_proto);
a4847 18
PP(pp_gsbyname)
{
#ifdef HAS_GETSERVBYNAME
    return pp_gservent();
#else
    DIE(aTHX_ PL_no_sock_func, "getservbyname");
#endif
}

PP(pp_gsbyport)
{
#ifdef HAS_GETSERVBYPORT
    return pp_gservent();
#else
    DIE(aTHX_ PL_no_sock_func, "getservbyport");
#endif
}

d4851 1
a4851 1
    dSP;
a4852 1
    register char **elem;
d4863 3
a4865 7
	char *proto = POPpbytex;
	char *name = POPpbytex;

	if (proto && !*proto)
	    proto = Nullch;

	sent = PerlSock_getservbyname(name, proto);
d4872 1
a4872 1
	char *proto = POPpbytex;
a4873 4

	if (proto && !*proto)
	    proto = Nullch;

d4877 1
a4877 1
	sent = PerlSock_getservbyport(port, proto);
d4907 2
a4908 9
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setpv(sv, sent->s_name);
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	for (elem = sent->s_aliases; elem && *elem; elem++) {
	    sv_catpv(sv, *elem);
	    if (elem[1])
		sv_catpvn(sv, " ", 1);
	}
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d4910 1
a4910 1
	sv_setiv(sv, (IV)PerlSock_ntohs(sent->s_port));
d4912 1
a4912 1
	sv_setiv(sv, (IV)(sent->s_port));
d4914 1
a4914 2
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setpv(sv, sent->s_proto);
d4926 1
a4926 1
    dSP;
d4937 1
a4937 1
    dSP;
d4948 1
a4948 1
    dSP;
d4959 1
a4959 1
    dSP;
d4970 1
a4970 1
    dSP;
d4982 1
a4982 1
    dSP;
d4994 1
a4994 1
    dSP;
d5006 1
a5006 1
    dSP;
a5014 18
PP(pp_gpwnam)
{
#ifdef HAS_PASSWD
    return pp_gpwent();
#else
    DIE(aTHX_ PL_no_func, "getpwnam");
#endif
}

PP(pp_gpwuid)
{
#ifdef HAS_PASSWD
    return pp_gpwent();
#else
    DIE(aTHX_ PL_no_func, "getpwuid");
#endif
}

d5018 1
a5018 1
    dSP;
d5091 1
a5091 1
	char* name = POPpbytex;
d5130 1
a5130 2
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setpv(sv, pwent->pw_name);
d5132 1
a5132 2
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	SvPOK_off(sv);
d5153 3
a5155 2
	    struct spwd *spwent;
	    int saverrno; /* Save and restore errno so that
a5158 3

	    saverrno = errno;
	    spwent = getspnam(pwent->pw_name);
a5174 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d5176 1
a5176 1
	sv_setiv(sv, (IV)pwent->pw_uid);
d5178 1
a5178 1
	sv_setuv(sv, (UV)pwent->pw_uid);
a5180 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d5182 1
a5182 1
	sv_setiv(sv, (IV)pwent->pw_gid);
d5184 1
a5184 1
	sv_setuv(sv, (UV)pwent->pw_gid);
a5190 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d5192 1
a5192 1
	sv_setiv(sv, (IV)pwent->pw_change);
d5195 1
a5195 1
	sv_setiv(sv, (IV)pwent->pw_quota);
d5198 4
a5201 1
	sv_setpv(sv, pwent->pw_age);
a5207 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d5209 1
a5209 1
	sv_setpv(sv, pwent->pw_class);
d5212 4
a5215 1
	sv_setpv(sv, pwent->pw_comment);
d5219 3
a5222 2
#   ifdef PWGECOS
	sv_setpv(sv, pwent->pw_gecos);
d5229 1
a5229 2
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setpv(sv, pwent->pw_dir);
d5231 1
a5231 2
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setpv(sv, pwent->pw_shell);
d5238 1
a5238 2
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setiv(sv, (IV)pwent->pw_expire);
d5243 1
a5243 1
    DIE(aTHX_ PL_no_func, "getpwent");
d5250 1
a5250 1
    dSP;
d5261 1
a5261 1
    dSP;
a5268 18
PP(pp_ggrnam)
{
#ifdef HAS_GROUP
    return pp_ggrent();
#else
    DIE(aTHX_ PL_no_func, "getgrnam");
#endif
}

PP(pp_ggrgid)
{
#ifdef HAS_GROUP
    return pp_ggrent();
#else
    DIE(aTHX_ PL_no_func, "getgrgid");
#endif
}

d5272 3
a5274 5
    dSP;
    I32 which = PL_op->op_type;
    register char **elem;
    register SV *sv;
    struct group *grent;
d5277 2
a5278 2
        char* name = POPpbytex;
	grent = (struct group *)getgrnam(name);
d5281 2
a5282 2
        Gid_t gid = POPi;
	grent = (struct group *)getgrgid(gid);
d5293 3
a5295 1
	PUSHs(sv = sv_newmortal());
d5306 1
a5306 2
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setpv(sv, grent->gr_name);
a5307 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d5309 3
a5311 1
	sv_setpv(sv, grent->gr_passwd);
d5314 1
a5314 2
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setiv(sv, (IV)grent->gr_gid);
a5316 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d5325 1
a5325 5
	for (elem = grent->gr_mem; elem && *elem; elem++) {
	    sv_catpv(sv, *elem);
	    if (elem[1])
		sv_catpvn(sv, " ", 1);
	}
d5331 1
a5331 1
    DIE(aTHX_ PL_no_func, "getgrent");
d5338 1
a5338 1
    dSP;
d5349 1
a5349 1
    dSP;
d5360 1
a5360 1
    dSP; dTARGET;
d5377 1
a5377 1
    dSP; dMARK; dORIGMARK; dTARGET;
d5537 1
a5537 1
    int save_errno;
a5540 1
    save_errno = errno;
@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
a47 6
#ifdef HAS_SYSCALL
#ifdef __cplusplus
extern "C" int syscall(unsigned long,...);
#endif
#endif

d90 1
a90 1
  struct passwd *Perl_my_getpwent (void);
d122 6
d176 1
a176 1
static char zero_but_true[ZBTLEN + 1] = "0 but true";
d204 9
d321 2
d333 3
a335 4
    STRLEN n_a;
    char *tmps = POPpx;
    I32 gimme = GIMME_V;
    char *mode = "r";
d342 1
a342 1
    fp = PerlProc_popen(tmps, mode);
d344 1
a344 1
	char *type = NULL;
d346 1
a346 1
	    type = SvPV_nolen(PL_curcop->cop_io);
a353 1
		/*SUPPRESS 530*/
d357 2
a358 1
	    SV *oldrs = PL_rs;
d360 1
a360 1
	    sv_setpv(TARG, "");	/* note that this preserves previous buffer */
a361 1
		/*SUPPRESS 530*/
d363 1
a363 1
	    PL_rs = oldrs;
a367 2
	    SV *sv;

d369 1
a369 1
		sv = NEWSV(56, 79);
d376 1
a376 2
		    SvLEN_set(sv, SvCUR(sv)+1);
		    Renew(SvPVX(sv), SvLEN(sv), char);
d441 1
a441 1
    char *tmps;
d443 1
a443 1
    if (SP - MARK != 1) {
d449 4
d456 1
a456 1
    tmps = SvPV(tmpsv, len);
d458 1
a458 1
  	SV *error = ERRSV;
d463 1
a463 1
	tmps = SvPV(tmpsv, len);
d475 1
a475 1
    char *tmps;
d486 1
a486 1
	tmps = SvPV(tmpsv, len);
d492 1
a492 1
        tmps = SvROK(tmpsv) ? Nullch : SvPV(tmpsv, len);
d517 1
a517 1
	    DIE(aTHX_ Nullformat);
d523 4
a526 1
	    tmps = SvPV(tmpsv, len);
d545 1
a545 1
    char *tmps;
d573 1
a573 1
	sv = GvSV(gv);
d576 2
a577 2
    tmps = SvPV(sv, len);
    ok = do_openn(gv, tmps, len, FALSE, O_RDONLY, 0, Nullfp, MARK+1, (SP-MARK));
d713 1
a713 1
    dSP; dTARGET;
d715 1
d727 1
a727 1
    /* Only DIE if trying to restrict permissions on `user' (self).
d779 1
a779 1
                       (discp) ? SvPV_nolen(discp) : Nullch)) {
d783 1
a783 1
                       (discp) ? SvPV_nolen(discp) : Nullch)) {
d799 1
a799 2
    dSP;
    dMARK;
d804 2
a805 2
    I32 markoff = MARK - PL_stack_base;
    char *methname;
d813 1
a813 1
	    HvEITER((HV *)varsv) = Null(HE *);
d891 1
a891 1
    char how = (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV)
d898 1
a898 1
	SV *obj = SvRV(SvTIED_obj(sv, mg));
d913 1
a913 2
           else if (ckWARN(WARN_UNTIE)) {
	       if (mg && SvREFCNT(obj) > 1)
d927 1
a927 1
    MAGIC *mg;
d929 1
a929 1
    char how = (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV)
a947 1
    HV *hv;
d953 1
a953 1
    hv = (HV*)POPs;
a1020 1
    STRLEN n_a;
d1036 2
a1037 1
	if (!SvPOK(SP[i]))
d1039 12
a1050 1
	j = SvCUR(SP[i]);
d1099 1
a1099 1
	if (!SvOK(sv)) {
d1103 1
a1103 2
	else if (!SvPOK(sv))
	    SvPV_force(sv,n_a);	/* force string conversion */
d1116 1
a1116 1
	New(403, fd_sets[i], growsize, char);
d1184 1
a1184 1
    GV *newdefout, *egv;
d1187 1
a1187 1
    newdefout = (PL_op->op_private > 0) ? ((GV *) POPs) : (GV *) NULL;
d1196 1
a1196 1
	GV **gvp = (GV**)hv_fetch(hv, GvNAME(egv), GvNAMELEN(egv), FALSE);
a1217 1
    GV *gv;
d1220 1
a1220 5

    if (MAXARG == 0)
	gv = PL_stdingv;
    else
	gv = (GV*)POPs;
d1225 1
a1225 1
	I32 gimme = GIMME_V;
d1238 2
a1239 2
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED)
		&& (!io || (!IoIFP(io) && IoTYPE(io) != IoTYPE_WRONLY)))
d1245 1
a1245 1
    sv_setpv(TARG, " ");
d1249 1
a1249 1
	Size_t len = UTF8SKIP(SvPVX(TARG));
d1270 1
a1270 1
    I32 gimme = GIMME_V;
d1278 2
a1279 1
    PAD_SET_CUR(CvPADLIST(cv), 1);
a1311 1
        char *name = NULL;
d1313 2
a1314 1
	    SV *tmpsv = sv_newmortal();
d1316 3
a1318 1
	    name = SvPV_nolen(tmpsv);
a1319 2
	if (name && *name)
	    DIE(aTHX_ "Undefined format \"%s\" called", name);
d1332 3
a1334 3
    GV *gv = cxstack[cxstack_ix].blk_sub.gv;
    register IO *io = GvIOp(gv);
    PerlIO *ofp = IoOFP(io);
a1350 1
	    SV *topname;
d1353 1
d1360 1
a1360 1
		    IoTOP_NAME(io) = savepv(SvPVX(topname));
d1366 1
a1366 1
		IoLINES_LEFT(io) = 100000000;
d1373 1
a1373 1
	    char *s = SvPVX(PL_formtarget);
d1383 2
a1384 2
		STRLEN save = SvCUR(PL_formtarget);
		SvCUR_set(PL_formtarget, s - SvPVX(PL_formtarget));
d1387 1
a1387 1
		sv_chop(PL_formtarget, s);
d1401 5
a1405 7
	{
	    char *name = NULL;
	    if (!cv) {
	        SV *sv = sv_newmortal();
		gv_efullname4(sv, fgv, Nullch, FALSE);
		name = SvPV_nolen(sv);
	    }
d1407 1
a1407 5
	        DIE(aTHX_ "Undefined top format \"%s\" called",name);
	    /* why no:
	    else
	        DIE(aTHX_ "Undefined top format called");
	    ?*/
d1409 4
d1452 2
d1534 4
a1537 3
    GV *gv;
    SV *sv;
    char *tmps;
a1538 9
    int mode, perm;

    if (MAXARG > 3)
	perm = POPi;
    else
	perm = 0666;
    mode = POPi;
    sv = POPs;
    gv = (GV *)POPs;
d1541 3
a1543 3

    tmps = SvPV(sv, len);
    if (do_open(gv, tmps, len, TRUE, mode, perm, Nullfp)) {
a1556 1
    GV *gv;
a1563 1
    MAGIC *mg;
d1565 2
d1573 1
a1573 1
    gv = (GV*)*++MARK;
d1575 1
a1575 2
	&& gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
d1577 14
a1590 12
	SV *sv;
	
	PUSHMARK(MARK-1);
	*MARK = SvTIED_obj((SV*)io, mg);
	ENTER;
	call_method("READ", G_SCALAR);
	LEAVE;
	SPAGAIN;
	sv = POPs;
	SP = ORIGMARK;
	PUSHs(sv);
	RETURN;
d1615 1
d1619 1
d1687 5
d1693 1
a1693 1
    if (offset > bufsize) { /* Zero any newly allocated space */
d1697 14
d1750 3
a1752 3
    SvCUR_set(bufsv, count+(buffer - SvPVX(bufsv)));
    *SvEND(bufsv) = '\0';
    (void)SvPOK_only(bufsv);
d1755 1
a1755 1
	char *bend = buffer + count;
d1764 1
a1764 1
		offset = bend - SvPVX(bufsv);
d1781 1
a1781 1
	    offset = bend - SvPVX(bufsv);
d1788 5
d1809 1
a1809 1
    int items = (SP - PL_stack_base) - TOPMARK;
d1826 1
a1826 1
    char *buffer;
d1875 1
a1875 1
	    buffer = SvPV(bufsv, blen);
d1883 1
a1883 1
	 buffer = SvPV(bufsv, blen);
d1905 1
a1905 1
	    buffer = (char*)utf8_hop((U8 *)buffer, offset);
a1925 1
	char *sockbuf;
d1927 1
a1927 1
	sockbuf = SvPVx(*++MARK, mlen);
d1977 1
a1977 1
		    do_open(gv, "-", 1, FALSE, O_RDONLY, 0, Nullfp);
d2051 1
a2051 1
    int whence = POPi;
a2118 1
#if defined(HAS_TRUNCATE) || defined(HAS_CHSIZE) || defined(F_FREESP)
a2119 1
        STRLEN n_a;
d2151 1
a2151 1
	    char *name;
d2166 1
a2166 1
	    name = SvPV(sv, n_a);
a2191 3
#else
    DIE(aTHX_ "truncate not implemented");
#endif
d2203 2
a2204 2
    unsigned int func = POPu;
    int optype = PL_op->op_type;
a2435 4
#ifdef MPE /* Requires PRIV mode to bind() to ports < 1024 */
    extern void GETPRIVMODE();
    extern void GETUSERMODE();
#endif
d2437 2
a2438 1
    char *addr;
a2442 3
#ifdef MPE
    int mpeprivmode = 0;
#endif
d2447 1
a2447 1
    addr = SvPV(addrsv, len);
a2448 12
#ifdef MPE /* Deal with MPE bind() peculiarities */
    if (((struct sockaddr *)addr)->sa_family == AF_INET) {
        /* The address *MUST* stupidly be zero. */
        ((struct sockaddr_in *)addr)->sin_addr.s_addr = INADDR_ANY;
        /* PRIV mode is required to bind() to ports < 1024. */
        if (((struct sockaddr_in *)addr)->sin_port < 1024 &&
            ((struct sockaddr_in *)addr)->sin_port > 0) {
            GETPRIVMODE(); /* If this fails, we are aborted by MPE/iX. */
	    mpeprivmode = 1;
	}
    }
#endif /* MPE */
a2452 4
#ifdef MPE /* Switch back to USER mode */
    if (mpeprivmode)
	GETUSERMODE();
#endif /* MPE */
d2474 1
a2474 1
    char *addr;
d2482 1
a2482 1
    addr = SvPV(addrsv, len);
d2669 1
a2669 1
	    char *buf;
d2673 1
a2673 1
		buf = SvPV(sv, l);
d2678 1
a2678 1
		buf = (char*)&aint;
d2742 2
a2743 2
	    if (((struct sockaddr *)SvPVX(sv))->sa_family == AF_INET &&
		!memcmp((char *)SvPVX(sv) + sizeof(u_short), nowhere,
a2786 1
    STRLEN n_a;
d2803 1
a2803 1
	    sv_setpv(PL_statname, "");
d2826 1
a2826 1
	sv_setpv(PL_statname, SvPV(sv,n_a));
a2827 1
#ifdef HAS_LSTAT
d2830 1
a2830 1
	    PL_laststatval = PerlLIO_lstat(SvPV(PL_statname, n_a), &PL_statcache);
d2832 1
a2832 2
#endif
	    PL_laststatval = PerlLIO_stat(SvPV(PL_statname, n_a), &PL_statcache);
d2834 1
a2834 1
	    if (ckWARN(WARN_NEWLINE) && strchr(SvPV(PL_statname, n_a), '\n'))
a2905 1
    STRLEN n_a;
a2931 1
    STRLEN n_a;
a2957 1
    STRLEN n_a;
a2983 1
    STRLEN n_a;
a3009 1
    STRLEN n_a;
a3035 1
    STRLEN n_a;
a3262 1
    STRLEN n_a;
a3302 1
    STRLEN n_a;
d3327 1
a3327 1
	    sv_setpv(PL_statname, "");
a3367 1
	PL_laststatval = -1;
d3369 4
a3372 3
	sv_setpv(PL_statname, SvPV(sv, n_a));
	if (!(fp = PerlIO_open(SvPVX(PL_statname), "r"))) {
	    if (ckWARN(WARN_NEWLINE) && strchr(SvPV(PL_statname, n_a), '\n'))
d3456 2
a3457 1
    char *tmps;
a3458 1
    STRLEN n_a;
d3460 12
a3471 4
    if( MAXARG == 1 )
        tmps = POPpx;
    else
        tmps = 0;
d3473 1
a3473 1
    if( !tmps || !*tmps ) {
d3483 1
a3483 1
            tmps = SvPV(*svp, n_a);
d3493 27
a3519 1
    PUSHi( PerlDir_chdir(tmps) >= 0 );
d3535 1
a3535 1
    PUSHi(value);
a3545 1
    STRLEN n_a;
d3589 2
a3590 4
    STRLEN n_a;

    char *tmps2 = POPpx;
    char *tmps = SvPV(TOPs, n_a);
d3614 2
a3615 3
    STRLEN n_a;
    char *tmps2 = POPpx;
    char *tmps = SvPV(TOPs, n_a);
d3628 2
a3629 3
    STRLEN n_a;
    char *tmps2 = POPpx;
    char *tmps = SvPV(TOPs, n_a);
d3643 1
a3643 1
    char *tmps;
a3645 1
    STRLEN n_a;
d3650 1
a3650 1
    tmps = POPpx;
d3665 1
a3665 1
S_dooneliner(pTHX_ char *cmd, char *filename)
d3667 1
a3667 1
    char *save_filename = filename;
d3673 1
a3673 1
    New(666, cmdline, strlen(cmd) + (strlen(filename) * 2) + 10, char);
d3761 1
a3761 1
#define TRIMSLASHES(tmps,len,copy) (tmps) = SvPV(TOPs, (len)); \
d3778 1
a3778 1
    char *tmps;
d3790 1
a3790 1
    SETi( PerlDir_mkdir(tmps, mode) >= 0 );
d3806 1
a3806 1
    char *tmps;
d3812 1
a3812 1
    SETi( PerlDir_rmdir(tmps) >= 0 );
d3827 1
a3827 2
    STRLEN n_a;
    char *dirname = POPpx;
d3836 1
a3836 1
    if (!(IoDIRP(io) = PerlDir_open(dirname)))
d3860 1
a3860 1
    I32 gimme = GIMME;
a4016 1
	/*SUPPRESS 560*/
a4110 1
    STRLEN n_a;
a4111 1
    I32 did_pipes = 0;
d4116 1
a4116 1
	    (void)SvPV_nolen(*MARK);      /* stringify for taint check */
d4128 1
d4136 1
a4136 1
		PUSHi(value);
d4185 1
a4185 1
	    PUSHi(STATUS_CURRENT);
d4201 1
a4201 1
	    value = (I32)do_exec3(SvPVx(sv_mortalcopy(*SP), n_a), pp[1], did_pipes);
d4210 1
a4210 1
#  if defined(WIN32) || defined(OS2)
d4217 1
a4217 1
#  if defined(WIN32) || defined(OS2)
d4224 1
a4224 1
	value = (I32)do_spawn(SvPVx(sv_mortalcopy(*SP), n_a));
d4231 1
a4231 1
    PUSHi(result ? value : STATUS_CURRENT);
a4239 1
    STRLEN n_a;
d4244 1
a4244 1
	    (void)SvPV_nolen(*MARK);      /* stringify for taint check */
d4271 1
a4271 1
	value = (I32)vms_do_exec(SvPVx(sv_mortalcopy(*SP), n_a));
d4274 1
a4274 1
	(void) do_spawn(SvPVx(sv_mortalcopy(*SP), n_a));
d4277 1
a4277 1
	value = (I32)do_exec(SvPVx(sv_mortalcopy(*SP), n_a));
d4283 1
a4283 1
    PUSHi(value);
d4306 3
d4459 40
d4503 6
a4508 4
    struct tm *tmbuf;
    static char *dayname[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    static char *monname[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
			      "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
d4520 3
d4524 1
a4747 1
    STRLEN n_a;
a4862 1
    STRLEN n_a;
a4962 1
    STRLEN n_a;
a5048 1
    STRLEN n_a;
a5243 1
    STRLEN n_a;
a5521 1
    STRLEN n_a;
a5632 1
    STRLEN n_a;
d5655 1
a5655 1
	    a[i++] = (unsigned long)SvPV_force(*MARK, n_a);
d5838 10
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d18 9
d1668 4
a1671 1
	offset = utf8_hop((U8 *)buffer,offset) - (U8 *) buffer;
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d1330 1
a1330 1
		topname = sv_2mortal(Perl_newSVpvf(aTHX_ "%s_TOP", IoFMT_NAME(io)));
d1823 5
a1827 1
	buffer = SvPVutf8(bufsv, blen);
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d179 12
d438 1
a438 1
    if (!tmps || !len) {
d473 1
a473 1
        tmps = (SvROK(tmpsv) && PL_in_eval) ? Nullch : SvPV(tmpsv, len);
d624 2
a625 2
    IoIFP(rstio) = PerlIO_fdopen(fd[0], "r");
    IoOFP(wstio) = PerlIO_fdopen(fd[1], "w");
d750 1
d757 8
a785 1
    STRLEN n_a;
d832 2
a833 2
	    DIE(aTHX_ "Can't locate object method \"%s\" via package \"%s\"",
		 methname, SvPV(*MARK,n_a));
d876 1
a876 1
	SV *obj = SvRV(mg->mg_obj);
a897 1
	sv_unmagic(sv, how) ;
d899 1
d1039 7
a1045 1
#  if SELECT_MIN_BITS > 1
a1051 2
#  else
    growsize = sizeof(fd_set);
d1096 10
d1112 1
d1216 1
a1245 2
    AV* padlist = CvPADLIST(cv);
    SV** svp = AvARRAY(padlist);
d1253 1
a1253 2
    SAVEVPTR(PL_curpad);
    PL_curpad = AvARRAY((AV*)svp[1]);
d1402 2
a1403 15
	    if (IoIFP(io)) {
		/* integrate with report_evil_fh()? */
	        char *name = NULL;
		if (isGV(gv)) {
		    SV* sv = sv_newmortal();
		    gv_efullname4(sv, gv, Nullch, FALSE);
		    name = SvPV_nolen(sv);
		}
		if (name && *name)
		    Perl_warner(aTHX_ packWARN(WARN_IO),
				"Filehandle %s opened only for input", name);
		else
		    Perl_warner(aTHX_ packWARN(WARN_IO),
				"Filehandle opened only for input");
	    }
d1471 1
a1471 1
	SETERRNO(EBADF,RMS$_IFI);
d1476 2
a1477 14
	    /* integrate with report_evil_fh()? */
	    if (IoIFP(io)) {
	        char *name = NULL;
		if (isGV(gv)) {
		    gv_efullname4(sv, gv, Nullch, FALSE);
		    name = SvPV_nolen(sv);
		}
		if (name && *name)
		    Perl_warner(aTHX_ packWARN(WARN_IO),
				"Filehandle %s opened only for input", name);
		else
		    Perl_warner(aTHX_ packWARN(WARN_IO),
				"Filehandle opened only for input");
	    }
d1481 1
a1481 1
	SETERRNO(EBADF,IoIFP(io)?RMS$_FAC:RMS$_IFI);
d1586 4
a1589 1
    if (!io || !IoIFP(io))
d1591 1
d1594 1
a1594 1
	/* UTF8 may not have been set if they are all low bytes */
d1704 1
a1704 15
	{
	    /* integrate with report_evil_fh()? */
	    char *name = NULL;
	    if (isGV(gv)) {
		SV* sv = sv_newmortal();
		gv_efullname4(sv, gv, Nullch, FALSE);
		name = SvPV_nolen(sv);
	    }
	    if (name && *name)
		Perl_warner(aTHX_ packWARN(WARN_IO),
			    "Filehandle %s opened only for output", name);
	    else
		Perl_warner(aTHX_ packWARN(WARN_IO),
			    "Filehandle opened only for output");
	}
d1818 1
d1826 6
a1831 3
	if (DO_UTF8(bufsv))
	    sv_utf8_downgrade(bufsv, FALSE);
	buffer = SvPV(bufsv, blen);
d2073 2
a2074 1
	
d2078 3
a2080 4
	do_ftruncate:
	    TAINT_PROPER("truncate");
	    if (!GvIO(tmpgv) || !IoIFP(GvIOp(tmpgv)))
	        result = 0;
d2082 9
a2090 1
	        PerlIO_flush(IoIFP(GvIOp(tmpgv)));
d2092 1
a2092 1
		if (ftruncate(PerlIO_fileno(IoIFP(GvIOn(tmpgv))), len) < 0)
d2094 1
a2094 1
		if (my_chsize(PerlIO_fileno(IoIFP(GvIOn(tmpgv))), len) < 0)
d2096 2
a2097 1
		    result = 0;
d2106 1
a2106 1
		goto do_ftruncate;
d2110 5
a2114 1
		goto do_ftruncate;
d2140 1
a2140 1
	    SETERRNO(EBADF,RMS$_IFI);
d2167 1
a2167 1
	SETERRNO(EBADF,RMS$_IFI);	/* well, sort of... */
d2205 1
d2207 1
d2257 1
a2257 1
	SETERRNO(EBADF,RMS$_IFI);
d2287 1
a2287 1
	SETERRNO(EBADF,LIB$_INVARG);
d2298 2
a2299 2
    IoIFP(io) = PerlIO_fdopen(fd, "r");	/* stdio gets confused about sockets */
    IoOFP(io) = PerlIO_fdopen(fd, "w");
d2360 2
a2361 2
    IoIFP(io1) = PerlIO_fdopen(fd[0], "r");
    IoOFP(io1) = PerlIO_fdopen(fd[0], "w");
d2363 2
a2364 2
    IoIFP(io2) = PerlIO_fdopen(fd[1], "r");
    IoOFP(io2) = PerlIO_fdopen(fd[1], "w");
d2438 1
a2438 1
    SETERRNO(EBADF,SS$_IVCHAN);
d2468 1
a2468 1
    SETERRNO(EBADF,SS$_IVCHAN);
d2494 1
a2494 1
    SETERRNO(EBADF,SS$_IVCHAN);
d2509 6
a2514 2
    struct sockaddr saddr;	/* use a struct to avoid alignment problems */
    Sock_size_t len = sizeof saddr;
a2515 1
    int fd2;
d2530 1
a2530 1
    fd = PerlSock_accept(PerlIO_fileno(IoIFP(gstio)), (struct sockaddr *)&saddr, &len);
d2535 2
a2536 6
    IoIFP(nstio) = PerlIO_fdopen(fd, "r");
    /* FIXME: we dup(fd) here so that refcounting of fd's does not inhibit
       fclose of IoOFP's FILE * - and hence leak memory.
       Special treatment of _this_ case of IoIFP != IoOFP seems wrong.
     */
    IoOFP(nstio) = PerlIO_fdopen(fd2 = PerlLIO_dup(fd), "w");
a2545 1
    fcntl(fd2, F_SETFD, fd2 > PL_maxsysfd);	/* ensure close-on-exec */
d2549 1
a2549 1
    len = sizeof saddr;          /* EPOC somehow truncates info */
d2552 3
d2556 1
a2556 1
    PUSHp((char *)&saddr, len);
d2562 1
a2562 1
    SETERRNO(EBADF,SS$_IVCHAN);
d2589 1
a2589 1
    SETERRNO(EBADF,SS$_IVCHAN);
d2668 1
a2668 1
    SETERRNO(EBADF,SS$_IVCHAN);
d2741 1
a2741 1
    SETERRNO(EBADF,SS$_IVCHAN);
d2856 1
a2856 1
	PUSHs(sv_2mortal(newSVnv(PL_statcache.st_size)));
d2886 2
a2887 2
    if ((PL_hints & HINT_FILETEST_ACCESS) && SvPOK(TOPs)) {
	result = access(TOPpx, R_OK);
d2913 2
a2914 2
    if ((PL_hints & HINT_FILETEST_ACCESS) && SvPOK(TOPs)) {
	result = access(TOPpx, W_OK);
d2940 2
a2941 2
    if ((PL_hints & HINT_FILETEST_ACCESS) && SvPOK(TOPs)) {
	result = access(TOPpx, X_OK);
d2967 2
a2968 2
    if ((PL_hints & HINT_FILETEST_ACCESS) && SvPOK(TOPs)) {
	result = PERL_EFF_ACCESS_R_OK(TOPpx);
d2994 2
a2995 2
    if ((PL_hints & HINT_FILETEST_ACCESS) && SvPOK(TOPs)) {
	result = PERL_EFF_ACCESS_W_OK(TOPpx);
d3021 2
a3022 2
    if ((PL_hints & HINT_FILETEST_ACCESS) && SvPOK(TOPs)) {
	result = PERL_EFF_ACCESS_X_OK(TOPpx);
d3099 1
a3099 1
    PUSHn( (PL_basetime - PL_statcache.st_mtime) / 86400.0 );
d3109 1
a3109 1
    PUSHn( (PL_basetime - PL_statcache.st_atime) / 86400.0 );
d3119 1
a3119 1
    PUSHn( (PL_basetime - PL_statcache.st_ctime) / 86400.0 );
d3347 1
a3347 1
	    SETERRNO(EBADF,RMS$_IFI);
d3359 1
a3359 1
	    if (ckWARN(WARN_NEWLINE) && strchr(SvPV(sv, n_a), '\n'))
d3676 1
a3676 1
		SETERRNO(EEXIST,RMS$_FEX);
d3678 1
a3678 1
		SETERRNO(EEXIST,RMS$_FEX);
d3680 1
a3680 1
		SETERRNO(EEXIST,RMS$_FEX);
d3682 1
a3682 1
		SETERRNO(ENOENT,RMS$_FNF);
d3684 1
a3684 1
		SETERRNO(ENOENT,RMS$_FNF);
d3686 1
a3686 1
		SETERRNO(EBUSY,SS$_DEVOFFLINE);
d3688 1
a3688 1
		SETERRNO(EACCES,RMS$_PRV);
d3690 1
a3690 1
		SETERRNO(EPERM,RMS$_PRV);
d3700 1
a3700 1
		SETERRNO(EACCES,RMS$_PRV);	/* a guess */
d3709 20
d3745 1
a3745 16
    tmps = SvPV(TOPs, len);
    /* Different operating and file systems take differently to
     * trailing slashes.  According to POSIX 1003.1 1996 Edition
     * any number of trailing slashes should be allowed.
     * Thusly we snip them away so that even non-conforming
     * systems are happy. */
    /* We should probably do this "filtering" for all
     * the functions that expect (potentially) directory names:
     * -d, chdir(), chmod(), chown(), chroot(), fcntl()?,
     * (mkdir()), opendir(), rename(), rmdir(), stat(). --jhi */
    if (len > 1 && tmps[len-1] == '/') {
	while (tmps[len] == '/' && len > 1)
	    len--;
	tmps = savepvn(tmps, len);
	copy = TRUE;
    }
d3764 1
d3766 1
a3766 1
    STRLEN n_a;
d3768 1
a3768 1
    tmps = POPpx;
d3771 1
a3771 1
    XPUSHi( PerlDir_rmdir(tmps) >= 0 );
d3773 1
a3773 1
    XPUSHi( dooneliner("rmdir", tmps) );
d3775 2
d3802 1
a3802 1
	SETERRNO(EBADF,RMS$_DIR);
d3811 3
a3813 2
#if defined(Direntry_t) && defined(HAS_READDIR)
    dSP;
d3817 5
a3822 1
    GV *gv = (GV*)POPs;
a3823 1
    SV *sv;
d3828 4
a3831 3
    if (GIMME == G_ARRAY) {
	/*SUPPRESS 560*/
	while ((dp = (Direntry_t *)PerlDir_read(IoDIRP(io)))) {
d3833 1
a3833 1
	    sv = newSVpvn(dp->d_name, dp->d_namlen);
d3835 1
a3835 1
	    sv = newSVpv(dp->d_name, 0);
d3838 2
a3839 2
	    if (!(IoFLAGS(io) & IOf_UNTAINT))
		SvTAINTED_on(sv);
d3841 1
a3841 16
	    XPUSHs(sv_2mortal(sv));
	}
    }
    else {
	if (!(dp = (Direntry_t *)PerlDir_read(IoDIRP(io))))
	    goto nope;
#ifdef DIRNAMLEN
	sv = newSVpvn(dp->d_name, dp->d_namlen);
#else
	sv = newSVpv(dp->d_name, 0);
#endif
#ifndef INCOMPLETE_TAINTS
	if (!(IoFLAGS(io) & IOf_UNTAINT))
	    SvTAINTED_on(sv);
#endif
	XPUSHs(sv_2mortal(sv));
d3843 5
d3852 1
a3852 1
	SETERRNO(EBADF,RMS$_ISI);
a3856 2
#else
    DIE(aTHX_ PL_no_dir_func, "readdir");
d3881 1
a3881 1
	SETERRNO(EBADF,RMS$_ISI);
d3904 1
a3904 1
	SETERRNO(EBADF,RMS$_ISI);
d3925 1
a3925 1
	SETERRNO(EBADF,RMS$_ISI);
d3955 1
a3955 1
	SETERRNO(EBADF,RMS$_IFI);
d3983 3
d4015 7
a4021 5
#ifdef PERL_OLD_SIGNALS
    childpid = wait4pid(-1, &argflags, 0);
#else
    while ((childpid = wait4pid(-1, &argflags, 0)) == -1 && errno == EINTR) {
	PERL_ASYNC_CHECK();
a4022 1
#endif
d4040 2
a4041 1
    Pid_t childpid;
d4046 8
a4053 6
    childpid = TOPi;
#ifdef PERL_OLD_SIGNALS
    childpid = wait4pid(childpid, &argflags, optype);
#else
    while ((childpid = wait4pid(childpid, &argflags, optype)) == -1 && errno == EINTR) {
	PERL_ASYNC_CHECK();
a4054 1
#endif
d4057 1
a4057 1
    STATUS_NATIVE_SET((childpid && childpid != -1) ? argflags : -1);
d4059 1
a4059 1
    STATUS_NATIVE_SET((childpid > 0) ? argflags : -1);
d4061 1
a4061 1
    SETi(childpid);
a4076 1
	int some_arg_tainted = 0;
d4080 1
a4080 2
	    if (PL_tainted) {
		some_arg_tainted = 1;
a4081 1
	    }
d4084 1
a4084 8
	/* XXX Remove warning at end of deprecation cycle --RD 2002-02  */
	if (SP - MARK == 1) {
	    TAINT_PROPER("system");
	}
	else if (some_arg_tainted && ckWARN2(WARN_TAINT, WARN_DEPRECATED)) {
	    Perl_warner(aTHX_ packWARN2(WARN_TAINT, WARN_DEPRECATED),
		"Use of tainted arguments in %s is deprecated", "system");
	}
d4172 1
a4172 1
#  ifdef WIN32
d4179 1
a4179 1
#  ifdef WIN32
a4204 1
	int some_arg_tainted = 0;
d4208 1
a4208 2
	    if (PL_tainted) {
		some_arg_tainted = 1;
a4209 1
	    }
d4212 1
a4212 8
	/* XXX Remove warning at end of deprecation cycle --RD 2002-02  */
	if (SP - MARK == 1) {
	    TAINT_PROPER("exec");
	}
	else if (some_arg_tainted && ckWARN2(WARN_TAINT, WARN_DEPRECATED)) {
	    Perl_warner(aTHX_ packWARN2(WARN_TAINT, WARN_DEPRECATED),
		"Use of tainted arguments in %s is deprecated", "exec");
	}
d4268 3
d4272 1
a4376 20
/* XXX The POSIX name is CLK_TCK; it is to be preferred
   to HZ.  Probably.  For now, assume that if the system
   defines HZ, it does so correctly.  (Will this break
   on VMS?)
   Probably we ought to use _sysconf(_SC_CLK_TCK), if
   it's supported.    --AD  9/96.
*/

#ifdef __BEOS__
#  define HZ 1000000
#endif

#ifndef HZ
#  ifdef CLK_TCK
#    define HZ CLK_TCK
#  else
#    define HZ 60
#  endif
#endif

d4390 1
a4390 1
    PUSHs(sv_2mortal(newSVnv(((NV)PL_timesbuf.tms_utime)/HZ)));
d4392 3
a4394 3
	PUSHs(sv_2mortal(newSVnv(((NV)PL_timesbuf.tms_stime)/HZ)));
	PUSHs(sv_2mortal(newSVnv(((NV)PL_timesbuf.tms_cutime)/HZ)));
	PUSHs(sv_2mortal(newSVnv(((NV)PL_timesbuf.tms_cstime)/HZ)));
d4398 11
d4410 1
d4986 3
d5174 1
a5174 1
     * There are at least two other shadow password APIs.  Many platforms
d5196 6
d5224 6
d5293 3
a5295 1
#   ifdef HAS_GETSPNAM
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d52 4
d77 1
d80 1
d83 1
d85 3
d99 1
d101 1
a112 5
/* Put this after #includes because fork and vfork prototypes may conflict. */
#ifndef HAS_VFORK
#   define vfork fork
#endif

d176 2
d284 3
d312 7
d326 2
d332 1
a402 9
#if 0		/* XXX never used! */
PP(pp_indread)
{
    STRLEN n_a;
    PL_last_in_gv = gv_fetchpv(SvPVx(GvSV((GV*)(*PL_stack_sp--)), n_a), TRUE,SVt_PVIO);
    return do_readline();
}
#endif

d447 3
d460 1
a460 1
	tmps = SvROK(tmpsv) ? Nullch : SvPV(tmpsv, len);
d485 1
a485 1
	    DIE(aTHX_ Nullch);
d504 3
a506 1
    dSP; dTARGET;
d509 1
a509 2
    SV *name = Nullsv;
    I32 have_name = 0;
d513 1
d515 1
a515 11
    if (MAXARG > 2) {
	name = POPs;
	have_name = 1;
    }
    if (MAXARG > 1)
	sv = POPs;
    if (!isGV(TOPs))
	DIE(aTHX_ PL_no_usym, "filehandle");
    if (MAXARG <= 1)
	sv = GvSV(TOPs);
    gv = (GV*)POPs;
d518 1
a518 1
    if (GvIOp(gv))
d521 5
a525 6
    if ((mg = SvTIED_mg((SV*)gv, 'q'))) {
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)gv, mg));
	XPUSHs(sv);
	if (have_name)
	    XPUSHs(name);
d534 7
d542 3
a544 1
    if (do_open9(gv, tmps, len, FALSE, O_RDONLY, 0, Nullfp, name, have_name))
d557 1
d565 3
a567 1
    if ((mg = SvTIED_mg((SV*)gv, 'q'))) {
d569 1
a569 1
	XPUSHs(SvTIED_obj((SV*)gv, mg));
d584 1
a585 1
#ifdef HAS_PIPE
d613 1
d650 3
a652 1
    if (gv && (mg = SvTIED_mg((SV*)gv, 'q'))) {
d654 1
a654 1
	XPUSHs(SvTIED_obj((SV*)gv, mg));
d663 6
a668 1
    if (!gv || !(io = GvIO(gv)) || !(fp = IoIFP(io)))
d670 2
d679 1
a681 1
#ifdef HAS_UMASK
d712 1
a712 1
    if (MAXARG > 1)
d714 1
d718 3
a720 1
    if (gv && (mg = SvTIED_mg((SV*)gv, 'q'))) {
d722 1
a722 1
	XPUSHs(SvTIED_obj((SV*)gv, mg));
d734 5
a738 2
    if (!(io = GvIO(gv)) || !(fp = IoIFP(io)))
	RETPUSHUNDEF;
d740 4
a743 1
    if (do_binmode(fp,IoTYPE(io),mode_from_discipline(discp)))
d745 3
a747 1
    else
d749 1
d762 1
a762 1
    int how = 'P';
d770 1
d776 5
d782 6
a787 1
	    how = 'q';
d791 1
a791 1
	    how = 'q';
d799 1
a799 1
	EXTEND(SP,items);
d817 1
a817 1
	EXTEND(SP,items);
d829 6
d846 1
d848 2
a849 1
    char how = (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV) ? 'P' : 'q';
d851 4
a854 2
        MAGIC * mg ;
        if ((mg = SvTIED_mg(sv, how))) {
d858 18
a875 16
	if ((gv = gv_fetchmethod_autoload(SvSTASH(obj), "UNTIE", FALSE)) &&
            isGV(gv) && (cv = GvCV(gv))) {
	    PUSHMARK(SP);
	    XPUSHs(SvTIED_obj((SV*)gv, mg));
	    XPUSHs(sv_2mortal(newSViv(SvREFCNT(obj)-1)));
	    PUTBACK;
	    ENTER;
	    call_sv((SV *)cv, G_VOID);
	    LEAVE;
	    SPAGAIN;
        }
        else if (ckWARN(WARN_UNTIE)) {
	    if (mg && SvREFCNT(obj) > 1)
		Perl_warner(aTHX_ WARN_UNTIE,
		    "untie attempted while %"UVuf" inner references still exist",
		    (UV)SvREFCNT(obj) - 1 ) ;
d877 1
a878 1
    sv_unmagic(sv, how);
d885 1
d887 5
a891 2
    char how = (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV) ? 'P' : 'q';
    MAGIC *mg;
d953 2
a954 2
	sv_unmagic((SV *) hv, 'P');
	sv_magic((SV*)hv, TOPs, 'P', Nullch, 0);
d967 1
a968 1
#ifdef HAS_SELECT
d1004 1
a1004 12
#if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678
#  if SELECT_MIN_BITS > 1
    /* If SELECT_MIN_BITS is greater than one we most probably will want
     * to align the sizes with SELECT_MIN_BITS/8 because for example
     * in many little-endian (Intel, Alpha) systems (Linux, OS/2, Digital
     * UNIX, Solaris, NeXT, Darwin) the smallest quantum select() operates
     * on (sets/tests/clears bits) is 32 bits.  */
    growsize = maxlen + (SELECT_MIN_BITS/8 - (maxlen % (SELECT_MIN_BITS/8)));
#  else
    growsize = sizeof(fd_set);
#  endif
# else
a1014 1
    growsize = maxlen + (masksize - (maxlen % masksize));
d1018 11
d1153 1
d1161 3
a1163 1
    if ((mg = SvTIED_mg((SV*)gv, 'q'))) {
d1166 1
a1166 1
	XPUSHs(SvTIED_obj((SV*)gv, mg));
d1176 4
a1179 1
    if (!gv || do_eof(gv)) /* make sure we have fp with something */
d1181 1
d1185 10
d1282 2
d1323 4
a1326 1
		PerlIO_write(ofp, SvPVX(PL_formtarget), s - SvPVX(PL_formtarget));
d1332 1
a1332 1
	    PerlIO_write(ofp, SvPVX(PL_formfeed), SvCUR(PL_formfeed));
d1377 1
a1377 1
		    Perl_warner(aTHX_ WARN_IO,
d1380 1
a1380 1
		    Perl_warner(aTHX_ WARN_IO,
d1391 1
a1391 1
		Perl_warner(aTHX_ WARN_IO, "page overflow");
d1393 1
a1393 2
	if (!PerlIO_write(ofp, SvPVX(PL_formtarget), SvCUR(PL_formtarget)) ||
		PerlIO_error(fp))
d1404 1
a1417 1
    STRLEN n_a;
d1424 3
a1426 1
    if ((mg = SvTIED_mg((SV*)gv, 'q'))) {
d1434 1
a1434 1
	*MARK = SvTIED_obj((SV*)gv, mg);
d1463 1
a1463 1
		    Perl_warner(aTHX_ WARN_IO,
d1466 1
a1466 1
		    Perl_warner(aTHX_ WARN_IO,
d1534 1
d1539 6
d1547 3
a1549 2
    if ((PL_op->op_type == OP_READ || PL_op->op_type == OP_SYSREAD) &&
	(mg = SvTIED_mg((SV*)gv, 'q')))
d1554 1
a1554 1
	*MARK = SvTIED_obj((SV*)gv, mg);
a1569 1
    buffer = SvPV_force(bufsv, blen);
a1570 2
    if (length < 0)
	DIE(aTHX_ "Negative length");
d1579 16
d1598 1
a1598 1
#if (defined(VMS_DO_SOCKETS) && defined(DECCRTL_SOCKETS)) || defined(MPE)
d1607 1
a1607 1
	buffer = SvGROW(bufsv, length+1);
d1609 1
a1609 1
	length = PerlSock_recvfrom(PerlIO_fileno(IoIFP(io)), buffer, length, offset,
d1611 1
a1611 1
	if (length < 0)
d1614 1
a1614 1
	/* Bogus return without padding */
d1617 1
a1617 1
	SvCUR_set(bufsv, length);
d1620 2
d1635 4
d1640 1
a1640 1
	if (-offset > blen)
d1644 5
d1650 1
a1650 1
    buffer = SvGROW(bufsv, length+offset+1);
d1654 2
d1659 2
a1660 2
	    length = PerlSock_recv(PerlIO_fileno(IoIFP(io)),
				   buffer+offset, length, 0);
d1665 2
a1666 2
	    length = PerlLIO_read(PerlIO_fileno(IoIFP(io)),
				  buffer+offset, length);
d1678 1
a1678 1
	length = PerlSock_recvfrom(PerlIO_fileno(IoIFP(io)), buffer+offset, length, 0,
d1684 7
a1690 8
	length = PerlIO_read(IoIFP(io), buffer+offset, length);
	/* fread() returns 0 on both error and EOF */
	if (length == 0 && PerlIO_error(IoIFP(io)))
	    length = -1;
    }
    if (length < 0) {
	if ((IoTYPE(io) == IoTYPE_WRONLY || IoIFP(io) == PerlIO_stdout()
	    || IoIFP(io) == PerlIO_stderr()) && ckWARN(WARN_IO))
d1700 1
a1700 1
		Perl_warner(aTHX_ WARN_IO,
d1703 1
a1703 1
		Perl_warner(aTHX_ WARN_IO,
d1708 1
a1708 1
    SvCUR_set(bufsv, length+offset);
d1711 35
d1751 1
a1751 1
    PUSHi(length);
a1781 1
    IV offset;
d1786 4
a1789 1
    if (PL_op->op_type == OP_SYSWRITE && (mg = SvTIED_mg((SV*)gv, 'q'))) {
d1793 1
a1793 1
	*MARK = SvTIED_obj((SV*)gv, mg);
a1805 1
    buffer = SvPV(bufsv, blen);
d1819 1
d1821 16
a1836 1
    else if (PL_op->op_type == OP_SYSWRITE) {
d1840 1
a1840 1
		if (-offset > blen)
d1843 1
a1843 1
	    } else if (offset >= blen && blen > 0)
d1849 7
d1859 1
a1859 1
				   buffer+offset, length, 0);
d1866 1
a1866 1
				   buffer+offset, length);
d1874 1
d1879 1
a1880 1

d1888 2
d1911 1
d1917 1
a1917 1
	    gv = PL_last_in_gv = PL_argvgv;
d1937 3
a1939 1
    if (gv && (mg = SvTIED_mg((SV*)gv, 'q'))) {
d1941 1
a1941 1
	XPUSHs(SvTIED_obj((SV*)gv, mg));
d1958 1
d1966 3
a1968 1
    if (gv && (mg = SvTIED_mg((SV*)gv, 'q'))) {
d1970 1
a1970 1
	XPUSHs(SvTIED_obj((SV*)gv, mg));
d1996 1
d2007 3
a2009 1
    if (gv && (mg = SvTIED_mg((SV*)gv, 'q'))) {
d2011 1
a2011 1
	XPUSHs(SvTIED_obj((SV*)gv, mg));
a2054 3
    int result = 1;
    GV *tmpgv;
    STRLEN n_a;
d2056 1
a2056 1
#if Size_t_size > IVSIZE
d2066 14
a2079 8
    if (PL_op->op_flags & OPf_SPECIAL) {
	tmpgv = gv_fetchpv(POPpx, FALSE, SVt_PVIO);
    do_ftruncate:
	TAINT_PROPER("truncate");
	if (!GvIO(tmpgv) || !IoIFP(GvIOp(tmpgv)))
	    result = 0;
	else {
	    PerlIO_flush(IoIFP(GvIOp(tmpgv)));
d2081 1
a2081 1
	    if (ftruncate(PerlIO_fileno(IoIFP(GvIOn(tmpgv))), len) < 0)
d2083 1
a2083 1
	    if (my_chsize(PerlIO_fileno(IoIFP(GvIOn(tmpgv))), len) < 0)
d2085 2
a2086 1
		result = 0;
d2088 12
a2099 5
    }
    else {
	SV *sv = POPs;
	char *name;
	STRLEN n_a;
d2101 2
a2102 11
	if (SvTYPE(sv) == SVt_PVGV) {
	    tmpgv = (GV*)sv;		/* *main::FRED for example */
	    goto do_ftruncate;
	}
	else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVGV) {
	    tmpgv = (GV*) SvRV(sv);	/* \*main::FRED for example */
	    goto do_ftruncate;
	}

	name = SvPV(sv, n_a);
	TAINT_PROPER("truncate");
d2104 2
a2105 2
	if (truncate(name, len) < 0)
	    result = 0;
d2107 4
a2110 6
	{
	    int tmpfd;
	    if ((tmpfd = PerlLIO_open(name, O_RDWR)) < 0)
		result = 0;
	    else {
		if (my_chsize(tmpfd, len) < 0)
d2112 5
a2116 1
		PerlLIO_close(tmpfd);
d2118 1
d2120 6
a2125 1
#endif
a2126 6

    if (result)
	RETPUSHYES;
    if (!errno)
	SETERRNO(EBADF,RMS$_IFI);
    RETPUSHUNDEF;
d2141 1
a2141 1
    unsigned int func = U_I(POPn);
d2146 1
a2146 1
    IO *io = GvIOn(gv);
d2149 2
d2181 3
a2183 1
#ifdef HAS_FCNTL
a2188 3
#else
	DIE(aTHX_ "fcntl is not implemented");
#endif
d2193 1
a2193 1
		PL_op_name[optype]);
d2206 1
d2212 1
a2219 1
#ifdef FLOCK
d2252 1
a2253 1
#ifdef HAS_SOCKET
d2262 1
d2264 5
a2268 1
    if (!gv) {
a2272 1
    io = GvIOn(gv);
d2305 1
a2306 1
#ifdef HAS_SOCKETPAIR
d2318 13
a2330 1
    if (!gv1 || !gv2)
d2332 1
a2333 2
    io1 = GvIOn(gv1);
    io2 = GvIOn(gv2);
d2370 1
a2371 1
#ifdef HAS_SOCKET
d2373 2
a2374 2
    extern GETPRIVMODE();
    extern GETUSERMODE();
d2429 1
a2430 1
#ifdef HAS_SOCKET
d2459 1
a2460 1
#ifdef HAS_SOCKET
d2463 1
a2463 1
    register IO *io = GvIOn(gv);
d2465 1
a2465 1
    if (!io || !IoIFP(io))
d2485 1
a2486 1
#ifdef HAS_SOCKET
d2494 1
a2508 3
    if (IoIFP(nstio))
	do_close(ngv, FALSE);

d2512 2
d2515 5
a2519 1
    IoOFP(nstio) = PerlIO_fdopen(fd, "w");
d2529 1
d2555 1
a2556 1
#ifdef HAS_SOCKET
d2588 1
a2589 1
#ifdef HAS_SOCKET
d2669 1
a2670 1
#ifdef HAS_SOCKET
d2748 9
d2779 3
d2795 1
a2795 1
		Perl_warner(aTHX_ WARN_NEWLINE, PL_warn_nl, "stat");
d3304 1
a3304 1
	    if (S_ISDIR(PL_statcache.st_mode))	/* handle NFS glitch */
d3309 1
d3337 1
d3341 1
a3341 1
		Perl_warner(aTHX_ WARN_NEWLINE, PL_warn_nl, "open");
d3349 1
a3349 1
	do_binmode(fp, '<', O_BINARY);
d3380 1
a3380 1
	    if ((PL_op->op_private & OPpLOCALE) && isALPHA_LC(*s))
d3428 2
a3429 2
    if (MAXARG < 1)
	tmps = Nullch;
d3431 5
a3435 11
	tmps = POPpx;
    if (!tmps || !*tmps) {
	svp = hv_fetch(GvHVn(PL_envgv), "HOME", 4, FALSE);
	if (svp)
	    tmps = SvPV(*svp, n_a);
    }
    if (!tmps || !*tmps) {
	svp = hv_fetch(GvHVn(PL_envgv), "LOGDIR", 6, FALSE);
	if (svp)
	    tmps = SvPV(*svp, n_a);
    }
d3437 13
a3449 4
    if (!tmps || !*tmps) {
       svp = hv_fetch(GvHVn(PL_envgv), "SYS$LOGIN", 9, FALSE);
       if (svp)
           tmps = SvPV(*svp, n_a);
d3451 1
a3451 1
#endif
d3464 1
d3466 2
a3467 3
    I32 value;
#ifdef HAS_CHOWN
    value = (I32)apply(PL_op->op_type, MARK, SP);
d3472 1
a3472 1
    DIE(aTHX_ PL_no_func, "Unsupported function chown");
d3478 1
a3479 2
    char *tmps;
#ifdef HAS_CHROOT
d3481 1
a3481 1
    tmps = POPpx;
d3549 1
a3550 1
#ifdef HAS_LINK
d3556 1
d3558 1
a3558 1
    DIE(aTHX_ PL_no_func, "Unsupported function link");
a3559 1
    RETURN;
d3564 1
a3565 1
#ifdef HAS_SYMLINK
d3579 1
a3579 1
    dSP; dTARGET;
d3581 1
d3591 1
a3591 1
    len = readlink(tmps, buf, sizeof buf);
d3697 1
a3697 1
    STRLEN n_a;
d3699 1
d3706 16
a3721 1
    tmps = SvPV(TOPs, n_a);
d3732 2
d3757 1
a3758 1
#if defined(Direntry_t) && defined(HAS_READDIR)
d3784 1
d3786 1
a3786 2
#if defined(Direntry_t) && defined(HAS_READDIR)
#ifndef I_DIRENT
d3842 1
a3843 1
#if defined(HAS_TELLDIR) || defined(telldir)
d3870 1
a3871 1
#if defined(HAS_SEEKDIR) || defined(seekdir)
d3893 1
a3894 1
#if defined(HAS_REWINDDIR) || defined(rewinddir)
d3914 1
a3915 1
#if defined(Direntry_t) && defined(HAS_READDIR)
d3953 1
a3953 1
    childpid = fork();
d3958 2
a3959 1
	if ((tmpgv = gv_fetchpv("$", TRUE, SVt_PV)))
d3961 2
d3980 1
a3980 1
    DIE(aTHX_ PL_no_func, "Unsupported function fork");
d3992 1
d3994 5
d4008 1
a4008 1
    DIE(aTHX_ PL_no_func, "Unsupported function wait");
d4022 1
d4024 5
d4038 1
a4038 1
    DIE(aTHX_ PL_no_func, "Unsupported function waitpid");
d4046 1
a4046 1
    Pid_t childpid;
a4047 3
    int status;
    Sigsave_t ihand,qhand;     /* place to save signals during system() */
    STRLEN n_a;
a4048 1
    int pp[2];
d4050 13
a4062 4
    if (SP - MARK == 1) {
	if (PL_tainting) {
	    char *junk = SvPV(TOPs, n_a);
	    TAINT_ENV();
d4065 4
d4071 39
a4109 6
#if (defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(OS2) && !defined(__CYGWIN__)
    if (PerlProc_pipe(pp) >= 0)
	did_pipes = 1;
    while ((childpid = vfork()) == -1) {
	if (errno != EAGAIN) {
	    value = -1;
a4110 1
	    PUSHi(value);
d4112 11
d4124 6
a4129 1
		PerlLIO_close(pp[1]);
d4131 1
a4133 15
	sleep(5);
    }
    if (childpid > 0) {
	if (did_pipes)
	    PerlLIO_close(pp[1]);
	rsignal_save(SIGINT, SIG_IGN, &ihand);
	rsignal_save(SIGQUIT, SIG_IGN, &qhand);
	do {
	    result = wait4pid(childpid, &status, 0);
	} while (result == -1 && errno == EINTR);
	(void)rsignal_restore(SIGINT, &ihand);
	(void)rsignal_restore(SIGQUIT, &qhand);
	STATUS_NATIVE_SET(result == -1 ? -1 : status);
	do_execfree();	/* free any memory child malloced on vfork */
	SP = ORIGMARK;
a4134 11
	    int errkid;
	    int n = 0, n1;

	    while (n < sizeof(int)) {
		n1 = PerlLIO_read(pp[0],
				  (void*)(((char*)&errkid)+n),
				  (sizeof(int)) - n);
		if (n1 <= 0)
		    break;
		n += n1;
	    }
a4135 12
	    if (n) {			/* Error */
		if (n != sizeof(int))
		    DIE(aTHX_ "panic: kid popen errno read");
		errno = errkid;		/* Propagate errno from kid */
		STATUS_CURRENT = -1;
	    }
	}
	PUSHi(STATUS_CURRENT);
	RETURN;
    }
    if (did_pipes) {
	PerlLIO_close(pp[0]);
d4137 1
a4137 1
	fcntl(pp[1], F_SETFD, FD_CLOEXEC);
d4139 11
a4150 10
    if (PL_op->op_flags & OPf_STACKED) {
	SV *really = *++MARK;
	value = (I32)do_aexec5(really, MARK, SP, pp[1], did_pipes);
    }
    else if (SP - MARK != 1)
	value = (I32)do_aexec5(Nullsv, MARK, SP, pp[1], did_pipes);
    else {
	value = (I32)do_exec3(SvPVx(sv_mortalcopy(*SP), n_a), pp[1], did_pipes);
    }
    PerlProc__exit(-1);
d4156 3
d4160 1
d4162 4
a4165 1
    else if (SP - MARK != 1)
d4167 2
d4188 20
a4226 5
	if (PL_tainting) {
	    char *junk = SvPV(*SP, n_a);
	    TAINT_ENV();
	    TAINT_PROPER("exec");
	}
a4238 5
#if !defined(HAS_FORK) && defined(USE_ITHREADS) && defined(PERL_IMPLICIT_SYS)
    if (value >= 0)
	my_exit(value);
#endif

d4246 1
a4248 1
#ifdef HAS_KILL
d4254 1
a4254 1
    DIE(aTHX_ PL_no_func, "Unsupported function kill");
d4328 1
d4330 2
a4331 5
    int which;
    int who;
#ifdef HAS_GETPRIORITY
    who = POPi;
    which = TOPi;
d4341 1
d4343 3
a4345 7
    int which;
    int who;
    int niceval;
#ifdef HAS_SETPRIORITY
    niceval = POPi;
    who = POPi;
    which = TOPi;
d4375 4
d4389 1
a4390 4

#ifndef HAS_TIMES
    DIE(aTHX_ "times not implemented");
#else
a4391 1

d4407 2
a4439 2
    EXTEND(SP, 9);
    EXTEND_MORTAL(9);
d4442 2
d4457 3
a4459 1
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_sec)));
d4474 1
a4476 1
#ifdef HAS_ALARM
d4485 1
a4485 1
    DIE(aTHX_ PL_no_func, "Unsupported function alarm");
d4648 1
a4649 1
#if defined(HAS_GETHOSTBYNAME) || defined(HAS_GETHOSTBYADDR) || defined(HAS_GETHOSTENT)
d4654 3
a4656 3
    struct hostent *PerlSock_gethostbyaddr(Netdb_host_t, Netdb_hlen_t, int);
    struct hostent *PerlSock_gethostbyname(Netdb_name_t);
    struct hostent *PerlSock_gethostent(void);
d4663 1
a4663 1
    if (which == OP_GHBYNAME)
d4665 2
a4666 1
	hent = PerlSock_gethostbyname(POPpx);
d4670 1
d4676 1
a4676 1
	Netdb_host_t addr = (Netdb_host_t) SvPV(addrsv, addrlen);
d4691 8
a4698 2
    if (!hent)
	STATUS_NATIVE_SET(h_errno);
d4765 1
a4766 1
#if defined(HAS_GETNETBYNAME) || defined(HAS_GETNETBYADDR) || defined(HAS_GETNETENT)
d4771 3
a4773 3
    struct netent *PerlSock_getnetbyaddr(Netdb_net_t, int);
    struct netent *PerlSock_getnetbyname(Netdb_name_t);
    struct netent *PerlSock_getnetent(void);
d4778 1
a4778 1
    if (which == OP_GNBYNAME)
d4780 2
a4781 1
	nent = PerlSock_getnetbyname(POPpx);
d4785 1
d4789 1
a4789 1
	Netdb_net_t addr = (Netdb_net_t) U_L(POPn);
d4802 11
d4866 1
a4867 1
#if defined(HAS_GETPROTOBYNAME) || defined(HAS_GETPROTOBYNUMBER) || defined(HAS_GETPROTOENT)
d4872 3
a4874 3
    struct protoent *PerlSock_getprotobyname(Netdb_name_t);
    struct protoent *PerlSock_getprotobynumber(int);
    struct protoent *PerlSock_getprotoent(void);
d4879 1
a4879 1
    if (which == OP_GPBYNAME)
d4881 2
a4882 1
	pent = PerlSock_getprotobyname(POPpx);
d4886 2
a4887 1
    else if (which == OP_GPBYNUMBER)
d4889 2
a4890 1
	pent = PerlSock_getprotobynumber(POPi);
d4892 1
a4892 1
    DIE(aTHX_ PL_no_sock_func, "getprotobynumber");
d4894 1
d4953 1
a4954 1
#if defined(HAS_GETSERVBYNAME) || defined(HAS_GETSERVBYPORT) || defined(HAS_GETSERVENT)
d4959 3
a4961 3
    struct servent *PerlSock_getservbyname(Netdb_name_t, Netdb_name_t);
    struct servent *PerlSock_getservbyport(int, Netdb_name_t);
    struct servent *PerlSock_getservent(void);
d4968 2
a4969 2
	char *proto = POPpx;
	char *name = POPpx;
d4981 2
a4982 2
	char *proto = POPpx;
	unsigned short port = POPu;
d5043 1
a5044 1
#ifdef HAS_SETHOSTENT
d5054 1
a5055 1
#ifdef HAS_SETNETENT
d5065 1
a5066 1
#ifdef HAS_SETPROTOENT
d5076 1
a5077 1
#ifdef HAS_SETSERVENT
d5087 1
a5088 1
#ifdef HAS_ENDHOSTENT
d5099 1
a5100 1
#ifdef HAS_ENDNETENT
d5111 1
a5112 1
#ifdef HAS_ENDPROTOENT
d5123 1
a5124 1
#ifdef HAS_ENDSERVENT
d5153 1
a5154 1
#ifdef HAS_PASSWD
d5215 5
a5219 2
	pwent  = getpwnam(POPpx);
	break;
d5221 4
a5224 1
	pwent = getpwuid((Uid_t)POPi);
d5227 1
a5227 1
#  ifdef HAS_GETPWENT
d5229 4
a5232 1
#  else
d5234 1
a5234 1
#  endif
d5243 1
a5243 1
#  if Uid_t_sign <= 0
d5245 1
a5245 1
#  else
d5247 1
a5247 1
#  endif
d5276 1
a5276 1
#  ifdef HAS_GETSPNAM
d5290 1
a5290 1
#  endif
d5296 1
a5296 1
#  ifndef INCOMPLETE_TAINTS
d5300 1
a5300 1
#  endif
d5303 1
a5303 1
#  if Uid_t_sign <= 0
d5305 1
a5305 1
#  else
d5307 1
a5307 1
#  endif
d5310 1
a5310 1
#  if Uid_t_sign <= 0
d5312 1
a5312 1
#  else
d5314 1
a5314 1
#  endif
d5321 1
a5321 1
#  ifdef PWCHANGE
d5323 2
a5324 2
#  else
#    ifdef PWQUOTA
d5326 2
a5327 2
#    else
#      ifdef PWAGE
d5329 3
a5331 3
#      endif
#    endif
#  endif
d5336 1
a5336 1
#  ifdef PWCLASS
d5338 2
a5339 2
#  else
#    ifdef PWCOMMENT
d5341 2
a5342 2
#    endif
#  endif
d5345 1
a5345 1
#  ifdef PWGECOS
d5347 2
a5348 2
#  endif
#  ifndef INCOMPLETE_TAINTS
d5351 1
a5351 1
#  endif
d5358 1
a5358 1
#  ifndef INCOMPLETE_TAINTS
d5361 1
a5361 1
#  endif
d5363 1
a5363 1
#  ifdef PWEXPIRE
d5366 1
a5366 1
#  endif
d5376 1
a5377 1
#if defined(HAS_PASSWD) && defined(HAS_SETPWENT)
d5387 1
a5388 1
#if defined(HAS_PASSWD) && defined(HAS_ENDPWENT)
d5416 1
a5417 1
#ifdef HAS_GROUP
d5424 8
a5431 4
    if (which == OP_GGRNAM)
	grent = (struct group *)getgrnam(POPpx);
    else if (which == OP_GGRGID)
	grent = (struct group *)getgrgid(POPi);
d5463 1
d5465 8
d5478 1
d5489 1
a5490 1
#if defined(HAS_GROUP) && defined(HAS_SETGRENT)
d5500 1
a5501 1
#if defined(HAS_GROUP) && defined(HAS_ENDGRENT)
d5511 1
a5512 1
#ifdef HAS_GETLOGIN
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d24 7
a30 2
 * the API is from SysV. --jhi */
#ifdef __hpux__
d32 4
a35 4
 * and another MAXINT from "perl.h" <- <sys/param.h>. */ 
#undef MAXINT
#endif
#include <shadow.h>
d38 2
a39 7
/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
#ifdef I_UNISTD
# include <unistd.h>
#endif

#ifdef HAS_SYSCALL   
#ifdef __cplusplus              
d52 3
a54 12
#if defined(HAS_SOCKET) && !defined(VMS) /* VMS handles sockets via vmsish.h */
# include <sys/socket.h>
# if defined(USE_SOCKS) && defined(I_SOCKS)
#   include <socks.h>
# endif 
# ifdef I_NETDB
#  include <netdb.h>
# endif
# ifndef ENOTSOCK
#  ifdef I_NET_ERRNO
#   include <net/errno.h>
#  endif
a57 6
#ifdef HAS_SELECT
#ifdef I_SYS_SELECT
#include <sys/select.h>
#endif
#endif

d125 1
a125 1
#  if defined(HAS_FCNTL) && defined(F_SETLK) && defined (F_SETLKW)
d183 1
a183 1
#   if defined(I_SYS_SECURITY)
a185 1
    /* XXX Configure test needed for eaccess */
d286 1
a286 1
    djSP; dTARGET;
d398 1
a398 1
    djSP; dMARK;
d429 1
a429 1
    djSP; dMARK;
d488 1
a488 1
    djSP; dTARGET;
d491 1
a491 1
    SV *name;
d539 1
a539 1
    djSP;
d565 1
a565 1
    djSP;
d595 2
a596 2
    IoTYPE(rstio) = '<';
    IoTYPE(wstio) = '>';
d620 1
a620 1
    djSP; dTARGET;
d649 1
a649 1
    djSP; dTARGET;
d674 1
a674 1
    djSP;
d686 1
a686 1
    gv = (GV*)POPs; 
d705 1
a705 1
    if (do_binmode(fp,IoTYPE(io),mode_from_discipline(discp))) 
d713 1
a713 1
    djSP;
d752 1
a752 1
    } 
d760 1
a760 1
		 methname, SvPV(*MARK,n_a));                   
d787 1
a787 1
    djSP;
a790 1
    if (ckWARN(WARN_UNTIE)) {
d793 16
a808 1
            if (mg && SvREFCNT(SvRV(mg->mg_obj)) > 1)  
d811 1
a811 1
		    (UV)SvREFCNT(SvRV(mg->mg_obj)) - 1 ) ;
a813 1
 
d820 1
a820 1
    djSP;
d837 1
a837 1
    djSP;
d885 1
a885 1
	sv_unmagic((SV *) hv, 'P');            
d899 1
a899 1
    djSP; dTARGET;
a1040 1
    dTHR;
d1050 1
a1050 1
    djSP; dTARGET;
d1065 1
a1065 1
	    gv_efullname3(TARG, PL_defoutgv, Nullch);
d1084 1
a1084 1
    djSP; dTARGET;
a1122 1
    dTHR;
d1143 1
a1143 1
    djSP;
d1168 1
d1171 2
a1172 2
	    gv_efullname3(tmpsv, fgv, Nullch);
	    DIE(aTHX_ "Undefined format \"%s\" called",SvPVX(tmpsv));
d1174 2
d1187 1
a1187 1
    djSP;
d1252 13
a1264 4
	if (!cv) {
	    SV *tmpsv = sv_newmortal();
	    gv_efullname3(tmpsv, fgv, Nullch);
	    DIE(aTHX_ "Undefined top format \"%s\" called",SvPVX(tmpsv));
d1280 13
a1292 5
		SV* sv = sv_newmortal();
		gv_efullname3(sv, gv, Nullch);
		Perl_warner(aTHX_ WARN_IO,
			    "Filehandle %s opened only for input",
			    SvPV_nolen(sv));
d1295 1
a1295 1
		report_closed_fh(gv, io, "write", "filehandle");
d1323 1
a1323 1
    djSP; dMARK; dORIGMARK;
d1358 2
a1359 5
	if (ckWARN(WARN_UNOPENED)) {
	    gv_efullname3(sv, gv, Nullch);
	    Perl_warner(aTHX_ WARN_UNOPENED,
			"Filehandle %s never opened", SvPV(sv,n_a));
	}
d1365 1
d1367 11
a1377 4
		gv_efullname3(sv, gv, Nullch);
		Perl_warner(aTHX_ WARN_IO,
			    "Filehandle %s opened only for input",
			    SvPV(sv,n_a));
d1380 1
a1380 1
		report_closed_fh(gv, io, "printf", "filehandle");
d1408 1
a1408 1
    djSP;
d1438 1
a1438 1
    djSP; dMARK; dORIGMARK; dTARGET;
a1495 4
#ifdef OS2	/* At least Warp3+IAK: only the first byte of bufsize set */
	if (bufsize >= 256)
	    bufsize = 255;
#endif
d1502 4
d1534 1
a1534 1
	if (IoTYPE(io) == 's') {
d1547 1
a1547 1
    if (IoTYPE(io) == 's') {
d1566 1
a1566 1
	if ((IoTYPE(io) == '>' || IoIFP(io) == PerlIO_stdout()
d1569 13
a1581 4
	    SV* sv = sv_newmortal();
	    gv_efullname3(sv, gv, Nullch);
	    Perl_warner(aTHX_ WARN_IO, "Filehandle %s opened only for output",
			SvPV_nolen(sv));
d1603 1
a1603 1
    djSP;
d1617 1
a1617 1
    djSP; dMARK; dORIGMARK; dTARGET;
d1658 2
a1659 6
	if (ckWARN(WARN_CLOSED)) {
	    if (PL_op->op_type == OP_SYSWRITE)
		report_closed_fh(gv, io, "syswrite", "filehandle");
	    else
		report_closed_fh(gv, io, "send", "socket");
	}
d1675 1
a1675 1
	if (IoTYPE(io) == 's') {
d1724 1
a1724 1
    djSP;
d1768 2
a1769 2
    djSP; dTARGET;
    GV *gv;     
d1803 1
a1803 1
    djSP;
d1854 1
a1854 1
    djSP;
d1871 1
a1871 1
     * might not be signed: if it is not, clever compilers will moan. */ 
d1885 1
a1885 1
#else 
d1941 1
a1941 1
    djSP; dTARGET;
d1986 1
a1986 1
#endif 
d2012 1
a2012 1
    djSP; dTARGET;
d2016 1
d2025 3
a2027 3
    if (gv && GvIO(gv))
	fp = IoIFP(GvIOp(gv));
    else
d2029 2
d2036 2
a2039 2
	if (ckWARN(WARN_CLOSED))
	    report_closed_fh(gv, GvIO(gv), "flock", "filehandle");
d2052 1
a2052 1
    djSP;
d2078 1
a2078 1
    IoTYPE(io) = 's';
d2089 4
d2101 1
a2101 1
    djSP;
d2129 1
a2129 1
    IoTYPE(io1) = 's';
d2132 1
a2132 1
    IoTYPE(io2) = 's';
d2155 1
a2155 1
    djSP;
d2204 1
a2204 1
	report_closed_fh(gv, io, "bind", "socket");
d2214 1
a2214 1
    djSP;
d2234 1
a2234 1
	report_closed_fh(gv, io, "connect", "socket");
d2244 1
a2244 1
    djSP;
d2260 1
a2260 1
	report_closed_fh(gv, io, "listen", "socket");
d2270 1
a2270 1
    djSP; dTARGET;
d2301 1
a2301 1
    IoTYPE(nstio) = 's';
d2312 5
d2322 1
a2322 1
	report_closed_fh(ggv, ggv ? GvIO(ggv) : 0, "accept", "socket");
d2335 1
a2335 1
    djSP; dTARGET;
d2349 1
a2349 1
	report_closed_fh(gv, io, "shutdown", "socket");
d2368 1
a2368 1
    djSP;
d2428 1
a2428 3
	report_closed_fh(gv, io,
			 optype == OP_GSOCKOPT ? "getsockopt" : "setsockopt",
			 "socket");
d2449 1
a2449 1
    djSP;
d2482 1
a2482 1
		goto nuts2;	    
d2501 1
a2501 4
	report_closed_fh(gv, io,
			 optype == OP_GETSOCKNAME ? "getsockname"
						  : "getpeername",
			 "socket");
d2520 2
a2521 2
    djSP;
    GV *tmpgv;
d2527 1
a2527 1
	tmpgv = cGVOP_gv;
d2529 1
a2529 1
	if (tmpgv != PL_defgv) {
d2531 1
a2531 1
	    PL_statgv = tmpgv;
d2533 2
a2534 2
	    PL_laststatval = (GvIO(tmpgv) && IoIFP(GvIOp(tmpgv))
		? PerlLIO_fstat(PerlIO_fileno(IoIFP(GvIOn(tmpgv))), &PL_statcache) : -1);
d2536 3
a2538 1
	if (PL_laststatval < 0)
d2540 1
d2545 1
a2545 1
	    tmpgv = (GV*)sv;
d2549 1
a2549 1
	    tmpgv = (GV*)SvRV(sv);
d2590 1
a2590 1
#if Gid_t_size > IVSIZE 
d2632 1
a2632 1
    djSP;
d2659 1
a2659 1
    djSP;
d2686 1
a2686 1
    djSP;
d2713 1
a2713 1
    djSP;
d2740 1
a2740 1
    djSP;
d2767 1
a2767 1
    djSP;
d2794 1
a2794 1
    djSP;
d2808 1
a2808 1
    djSP;
d2820 1
a2820 1
    djSP;
d2831 1
a2831 1
    djSP; dTARGET;
d2845 1
a2845 1
    djSP; dTARGET;
d2855 1
a2855 1
    djSP; dTARGET;
d2865 1
a2865 1
    djSP; dTARGET;
d2875 1
a2875 1
    djSP;
d2886 1
a2886 1
    djSP;
d2897 1
a2897 1
    djSP;
d2908 1
a2908 1
    djSP;
d2919 1
a2919 1
    djSP;
d2930 1
a2930 1
    djSP;
d2941 1
a2941 1
    djSP;
d2951 1
a2951 1
    djSP;
d2965 1
a2965 1
    djSP;
d2979 1
a2979 1
    djSP;
d2993 1
a2993 1
    djSP;
d3029 1
a3029 1
    djSP;
d3091 1
a3091 1
	    if (ckWARN(WARN_UNOPENED)) {
d3093 1
a3093 2
		Perl_warner(aTHX_ WARN_UNOPENED, "Test on unopened file <%s>",
			    GvENAME(gv));
d3115 1
a3115 1
	do_binmode(fp, '<', TRUE);
d3141 1
a3141 1
        else if (!(isPRINT(*s) || isSPACE(*s))) 
d3150 1
a3150 1
	    if (*s & 0x40) {
d3155 1
a3155 1
			if ((s[j] & 0xc0) != 0x80)
d3189 1
a3189 1
    djSP; dTARGET;
d3227 1
a3227 1
    djSP; dMARK; dTARGET;
d3241 1
a3241 1
    djSP; dTARGET;
d3256 1
a3256 1
    djSP; dMARK; dTARGET;
d3266 1
a3266 1
    djSP; dMARK; dTARGET;
d3276 1
a3276 1
    djSP; dMARK; dTARGET;
d3286 1
a3286 1
    djSP; dTARGET;
d3313 1
a3313 1
    djSP; dTARGET;
d3328 1
a3328 1
    djSP; dTARGET;
d3343 1
a3343 1
    djSP; dTARGET;
d3455 1
a3455 1
    djSP; dTARGET;
d3484 1
a3484 1
    djSP; dTARGET;
d3502 1
a3502 1
    djSP;
d3529 1
a3529 1
    djSP;
d3587 1
a3587 1
    djSP; dTARGET;
d3615 1
a3615 1
    djSP;
d3638 1
a3638 1
    djSP;
d3659 1
a3659 1
    djSP;
d3692 1
a3692 1
    djSP; dTARGET;
d3711 1
a3711 1
    djSP; dTARGET;
d3717 2
d3729 2
a3730 2
#if (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(MACOS_TRADITIONAL) 
    djSP; dTARGET;
d3735 4
d3740 1
d3750 2
a3751 2
#if (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(MACOS_TRADITIONAL) 
    djSP; dTARGET;
d3759 4
d3764 1
d3774 1
a3774 1
    djSP; dMARK; dORIGMARK; dTARGET;
d3792 1
a3792 1
#if (defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(OS2)
d3861 2
d3872 2
d3877 1
a3877 1
    PUSHi(STATUS_CURRENT);
d3884 1
a3884 1
    djSP; dMARK; dORIGMARK; dTARGET;
d3936 1
a3936 1
    djSP; dMARK; dTARGET;
d3951 1
a3951 1
    djSP; dTARGET;
d3962 1
a3962 1
    djSP; dTARGET;
d3987 1
a3987 1
    djSP; dTARGET;
d4018 1
a4018 1
    djSP; dTARGET;
d4033 1
a4033 1
    djSP; dTARGET;
d4053 1
a4053 1
    djSP; dTARGET;
d4080 1
a4080 1
    djSP;
d4112 1
a4112 1
    djSP;
d4165 1
a4165 1
    djSP; dTARGET;
d4182 1
a4182 1
    djSP; dTARGET;
d4219 1
a4219 1
    djSP; dMARK; dTARGET;
d4244 1
a4244 1
    djSP; dMARK; dTARGET;
d4257 1
a4257 1
    djSP; dMARK; dTARGET;
d4272 1
a4272 1
    djSP; dMARK; dTARGET;
d4287 1
a4287 1
    djSP; dMARK; dTARGET;
d4307 1
a4307 1
    djSP; dMARK; dTARGET;
d4339 1
a4339 1
    djSP;
d4448 1
a4448 1
    djSP;
d4536 1
a4536 1
    djSP;
d4540 1
a4540 1
    register SV *sv;  
d4619 1
a4619 1
    djSP;
d4709 1
a4709 1
    djSP;
d4720 1
a4720 1
    djSP;
d4731 1
a4731 1
    djSP;
d4742 1
a4742 1
    djSP;
d4753 1
a4753 1
    djSP;
d4765 1
a4765 1
    djSP;
d4777 1
a4777 1
    djSP;
d4789 1
a4789 1
    djSP;
d4819 1
a4819 1
    djSP;
a4822 1
    struct passwd *pwent;
d4824 54
a4877 3
#if defined(HAS_GETSPENT) || defined(HAS_GETSPNAM)
    struct spwd *spwent = NULL;
#endif
d4879 11
a4889 8
    if (which == OP_GPWNAM)
	pwent = getpwnam(POPpx);
    else if (which == OP_GPWUID)
	pwent = getpwuid(POPi);
    else
#ifdef HAS_GETPWENT
	pwent = (struct passwd *)getpwent();
#else
d4891 2
a4892 6
#endif

#ifdef HAS_GETSPNAM
    if (which == OP_GPWNAM) {
	if (pwent)
	    spwent = getspnam(pwent->pw_name);
a4893 11
#  ifdef HAS_GETSPUID /* AFAIK there isn't any anywhere. --jhi */ 
    else if (which == OP_GPWUID) {
	if (pwent)
	    spwent = getspnam(pwent->pw_name);
    }
#  endif
#  ifdef HAS_GETSPENT
    else
	spwent = (struct spwd *)getspent();
#  endif
#endif
d4900 1
a4900 1
#if Uid_t_sign <= 0
d4902 1
a4902 1
#else
d4904 1
a4904 1
#endif
d4916 35
a4950 8
#ifdef PWPASSWD
#   if defined(HAS_GETSPENT) || defined(HAS_GETSPNAM)
      if (spwent)
              sv_setpv(sv, spwent->sp_pwdp);
      else
              sv_setpv(sv, pwent->pw_passwd);
#   else
	sv_setpv(sv, pwent->pw_passwd);
d4952 4
a4955 3
#endif
#ifndef INCOMPLETE_TAINTS
	/* passwd is tainted because user himself can diddle with it. */
d4957 1
a4957 1
#endif
d4960 1
a4960 1
#if Uid_t_sign <= 0
d4962 1
a4962 1
#else
d4964 1
a4964 1
#endif
d4967 1
a4967 1
#if Uid_t_sign <= 0
d4969 1
a4969 1
#else
d4971 6
a4976 2
#endif
	/* pw_change, pw_quota, and pw_age are mutually exclusive. */
d4978 1
a4978 1
#ifdef PWCHANGE
d4980 2
a4981 2
#else
#   ifdef PWQUOTA
d4983 2
a4984 2
#   else
#       ifdef PWAGE
d4986 3
a4988 3
#       endif
#   endif
#endif
d4990 2
a4991 1
	/* pw_class and pw_comment are mutually exclusive. */
d4993 1
a4993 1
#ifdef PWCLASS
d4995 2
a4996 2
#else
#   ifdef PWCOMMENT
d4998 2
a4999 2
#   endif
#endif
d5002 1
a5002 1
#ifdef PWGECOS
d5004 2
a5005 2
#endif
#ifndef INCOMPLETE_TAINTS
d5008 1
a5008 1
#endif
d5015 1
a5015 1
#ifndef INCOMPLETE_TAINTS
d5018 1
a5018 1
#endif
d5020 1
a5020 1
#ifdef PWEXPIRE
d5023 1
a5023 1
#endif
d5033 1
a5033 1
    djSP;
a5035 3
#   ifdef HAS_SETSPENT
    setspent();
#   endif
d5044 1
a5044 1
    djSP;
a5046 3
#   ifdef HAS_ENDSPENT
    endspent();
#   endif
d5073 1
a5073 1
    djSP;
d5132 1
a5132 1
    djSP;
d5143 1
a5143 1
    djSP;
d5154 1
a5154 1
    djSP; dTARGET;
d5172 1
a5172 1
    djSP; dMARK; dORIGMARK; dTARGET;
d5199 1
a5199 1
	else 
d5267 1
a5267 1
 
d5276 1
a5276 1
 
d5293 1
a5293 1
 
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d18 1
d21 12
d54 3
d80 1
a80 1
#if defined(HOST_NOT_FOUND) && !defined(h_errno)
d88 2
a89 2
    struct passwd *getpwnam _((char *));
    struct passwd *getpwuid _((Uid_t));
d92 1
a92 1
  struct passwd *getpwent _((void));
d100 2
a101 2
    struct group *getgrnam _((char *));
    struct group *getgrgid _((Gid_t));
d104 1
a104 1
    struct group *getgrent _((void));
a114 6
#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif
a120 13
/* Put this after #includes because <unistd.h> defines _XOPEN_*. */
#ifndef Sock_size_t
#  if _XOPEN_VERSION >= 5 || defined(_XOPEN_SOURCE_EXTENDED) || defined(__GLIBC__)
#    define Sock_size_t Size_t
#  else
#    define Sock_size_t int
#  endif
#endif

#if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)
static int dooneliner _((char *cmd, char *filename));
#endif

d151 1
a151 1
     static int FLOCK _((int, int));
d173 106
a278 6
#ifndef MAXPATHLEN
#  ifdef PATH_MAX
#    define MAXPATHLEN PATH_MAX
#  else
#    define MAXPATHLEN 1024
#  endif
d280 2
d283 6
a288 2
#define ZBTLEN 10
static char zero_but_true[ZBTLEN + 1] = "0 but true";
d290 9
a298 1
/* Pushy I/O. */
d307 1
d310 5
a314 1
    fp = PerlProc_popen(tmps, "r");
d362 6
d377 1
a377 1
	taint_proper(no_security, "glob");
d385 1
a385 1
    PL_rs = sv_2mortal(newSVpv("", 1));
d408 1
a408 1
    PL_last_in_gv = cGVOP->op_gv;
d415 1
d417 1
a417 1
    STRLEN n_a;
d421 1
a421 1
	tmps = SvPV(TARG, n_a);
d425 1
a425 1
	tmps = SvPV(TOPs, n_a);
d427 2
a428 1
    if (!tmps || !*tmps) {
d433 2
a434 1
	tmps = SvPV(error, n_a);
d436 4
a439 3
    if (!tmps || !*tmps)
	tmps = "Warning: something's wrong";
    warn("%s", tmps);
d447 3
a449 3
    SV *tmpsv = Nullsv;
    char *pat = "%s";
    STRLEN n_a;
d453 3
a455 1
	tmps = SvPV(TARG, n_a);
d460 1
a460 1
	tmps = SvROK(tmpsv) ? Nullch : SvPV(tmpsv, n_a);
d462 1
a462 1
    if (!tmps || !*tmps) {
d465 2
a466 2
	if(tmpsv ? SvROK(tmpsv) : SvROK(error)) {
	    if(tmpsv)
d468 1
a468 1
	    else if(sv_isobject(error)) {
d472 2
a473 2
		    SV *file = sv_2mortal(newSVsv(GvSV(PL_curcop->cop_filegv)));
		    SV *line = sv_2mortal(newSViv(PL_curcop->cop_line));
d480 2
a481 2
		    perl_call_sv((SV*)GvCV(gv),
				 G_SCALAR|G_EVAL|G_KEEPERR);
d485 1
a485 1
	    pat = Nullch;
d490 2
a491 1
	    tmps = SvPV(error, n_a);
d494 4
a497 3
    if (!tmps || !*tmps)
	tmps = "Died";
    DIE(pat, tmps);
d507 2
d511 1
d513 4
d520 1
a520 1
	DIE(no_usym, "filehandle");
d525 1
a525 1
	DIE(no_usym, "filehandle");
d528 15
d544 1
a544 1
    if (do_open(gv, tmps, len, FALSE, O_RDONLY, 0, Nullfp))
d564 1
a564 1
    if (mg = SvTIED_mg((SV*)gv, 'q')) {
d569 1
a569 1
	perl_call_method("CLOSE", G_SCALAR);
d596 1
a596 1
	DIE(no_usym, "filehandle");
d630 1
a630 1
    DIE(no_func, "pipe");
d640 2
d645 12
d666 1
a666 1
    int anum;
d682 1
a682 1
	DIE("umask not implemented");
d694 2
d699 4
d704 12
a715 1
    gv = (GV*)POPs;
d721 1
a721 1
    if (do_binmode(fp,IoTYPE(io),TRUE)) 
a726 1

d739 1
d767 1
a767 1
	perl_call_method(methname, G_SCALAR);
d770 1
a770 1
	/* Not clear why we don't call perl_call_method here too.
d775 1
a775 2
	    STRLEN n_a;
	    DIE("Can't locate object method \"%s\" via package \"%s\"",
d785 1
a785 1
	perl_call_sv((SV*)GvCV(gv), G_SCALAR);
d807 7
a813 6
    if (PL_dowarn) {
        MAGIC *mg;
        if (mg = SvTIED_mg(sv, how)) {
            if (mg->mg_obj && SvREFCNT(SvRV(mg->mg_obj)) > 1)  
		warn("untie attempted while %lu inner references still exist",
			(unsigned long)SvREFCNT(SvRV(mg->mg_obj)) - 1 ) ;
d828 1
a828 1
    if (mg = SvTIED_mg(sv, how)) {
d854 1
a854 1
	perl_require_pv("AnyDBM_File.pm");
d857 1
a857 1
	    DIE("No dbm on this machine");
d867 1
a867 1
	PUSHs(sv_2mortal(newSViv(O_RDWR|O_CREAT)));
d869 1
a869 1
	PUSHs(sv_2mortal(newSViv(O_RDWR)));
d872 1
a872 1
    perl_call_sv((SV*)GvCV(gv), G_SCALAR);
d880 1
a880 1
	PUSHs(sv_2mortal(newSViv(O_RDONLY)));
d883 1
a883 1
	perl_call_sv((SV*)GvCV(gv), G_SCALAR);
d897 1
a897 1
    return pp_untie(ARGS);
d908 1
a908 1
    double value;
d944 2
a945 2
     * UNIX, Solaris, NeXT) the smallest quantum select() operates on
     * (sets bit) is 32 bits.  */
d947 1
a947 1
#else
d949 3
a951 3
#endif
#else
#ifdef NFDBITS
d953 3
a955 3
#ifndef NBBY
#define NBBY 8
#endif
d958 1
a958 1
#else
d960 1
a960 1
#endif
d971 1
a971 1
	value -= (double)timebuf.tv_sec;
d1030 2
a1031 2
	value = (double)(timebuf.tv_sec) +
		(double)(timebuf.tv_usec) / 1000000.0;
d1037 1
a1037 1
    DIE("select not implemented");
d1042 1
a1042 1
setdefout(GV *gv)
d1092 1
a1092 1
    if (MAXARG <= 0)
a1095 2
    if (!gv)
	gv = PL_argvgv;
d1097 1
a1097 1
    if (mg = SvTIED_mg((SV*)gv, 'q')) {
d1103 1
a1103 1
	perl_call_method("GETC", gimme);
d1121 1
a1121 1
    return pp_sysread(ARGS);
d1125 1
a1125 1
doform(CV *cv, GV *gv, OP *retop)
d1137 1
a1137 1
    PUSHBLOCK(cx, CXt_SUB, PL_stack_sp);
d1139 1
a1139 1
    SAVESPTR(PL_curpad);
d1176 1
a1176 1
	    DIE("Undefined format \"%s\" called",SvPVX(tmpsv));
d1178 1
a1178 1
	DIE("Not a format reference");
d1212 1
a1212 1
		topname = sv_2mortal(newSVpvf("%s_TOP", IoFMT_NAME(io)));
d1252 1
a1252 1
	    DIE("bad top format reference");
d1257 1
a1257 1
	    DIE("Undefined top format \"%s\" called",SvPVX(tmpsv));
d1271 10
a1280 5
	if (PL_dowarn) {
	    if (IoIFP(io))
		warn("Filehandle only opened for input");
	    else
		warn("Write on closed filehandle");
d1286 2
a1287 2
	    if (PL_dowarn)
		warn("page overflow");
d1321 1
a1321 1
    if (mg = SvTIED_mg((SV*)gv, 'q')) {
d1332 1
a1332 1
	perl_call_method("PRINTF", G_SCALAR);
d1343 4
a1346 3
	if (PL_dowarn) {
	    gv_fullname3(sv, gv, Nullch);
	    warn("Filehandle %s never opened", SvPV(sv,n_a));
d1352 9
a1360 6
	if (PL_dowarn)  {
	    gv_fullname3(sv, gv, Nullch);
	    if (IoIFP(io))
		warn("Filehandle %s opened only for input", SvPV(sv,n_a));
	    else
		warn("printf on closed filehandle %s", SvPV(sv,n_a));
a1365 6
#ifdef USE_LOCALE_NUMERIC
	if (PL_op->op_private & OPpLOCALE)
	    SET_NUMERIC_LOCAL();
	else
	    SET_NUMERIC_STANDARD();
#endif
d1403 2
d1438 1
a1438 1
	perl_call_method("READ", G_SCALAR);
d1455 1
a1455 1
	DIE("Negative length");
d1472 8
d1500 1
a1500 1
	DIE(no_sock_func, "recv");
d1504 1
a1504 1
	    DIE("Offset outside string");
d1545 9
a1553 1
    if (length < 0)
d1555 1
d1580 1
a1580 1
        PUSHs(sv);
d1583 1
a1583 1
    return pp_send(ARGS);
a1590 1
    int offset;
d1593 3
a1595 1
    int length;
d1606 1
a1606 1
	perl_call_method("WRITE", G_SCALAR);
d1618 7
a1624 3
    length = SvIVx(*++MARK);
    if (length < 0)
	DIE("Negative length");
d1628 2
a1629 2
	length = -1;
	if (PL_dowarn) {
d1631 1
a1631 1
		warn("Syswrite on closed filehandle");
d1633 1
a1633 1
		warn("Send on closed socket");
d1641 1
a1641 1
		    DIE("Offset outside string");
d1644 1
a1644 1
		DIE("Offset outside string");
d1651 1
a1651 1
	    length = PerlSock_send(PerlIO_fileno(IoIFP(io)),
d1657 2
a1658 1
	    length = PerlLIO_write(PerlIO_fileno(IoIFP(io)),
d1667 2
a1668 2
	length = PerlSock_sendto(PerlIO_fileno(IoIFP(io)), buffer, blen, length,
				(struct sockaddr *)sockbuf, mlen);
d1671 1
a1671 1
	length = PerlSock_send(PerlIO_fileno(IoIFP(io)), buffer, blen, length);
d1675 1
a1675 1
	DIE(no_sock_func, "send");
d1677 1
a1677 1
    if (length < 0)
d1680 5
a1684 1
    PUSHi(length);
d1694 1
a1694 1
    return pp_sysread(ARGS);
d1701 1
d1703 20
a1722 2
    if (MAXARG <= 0)
	gv = PL_last_in_gv;
d1724 13
a1736 1
	gv = PL_last_in_gv = (GV*)POPs;
d1744 2
a1745 1
    GV *gv;
d1747 1
a1747 1
    if (MAXARG <= 0)
d1751 15
d1767 1
d1773 1
a1773 1
    return pp_sysseek(ARGS);
d1781 6
a1786 1
    long offset = POPl;
d1789 18
d1810 13
a1822 4
	long n = do_sysseek(gv, offset, whence);
	PUSHs((n < 0) ? &PL_sv_undef
	      : sv_2mortal(n ? newSViv((IV)n)
			   : newSVpv(zero_but_true, ZBTLEN)));
d1830 6
a1835 1
    Off_t len = (Off_t)POPn;
d1840 8
d1854 4
a1857 1
	if (!GvIO(tmpgv) || !IoIFP(GvIOp(tmpgv)) ||
d1859 1
a1859 1
	  ftruncate(PerlIO_fileno(IoIFP(GvIOn(tmpgv))), len) < 0)
d1861 1
a1861 1
	  my_chsize(PerlIO_fileno(IoIFP(GvIOn(tmpgv))), len) < 0)
d1863 2
a1864 1
	    result = 0;
d1869 1
d1905 1
a1905 1
    DIE("truncate not implemented");
d1911 1
a1911 1
    return pp_ioctl(ARGS);
d1944 1
a1944 1
	s = (char*)retval;		/* ouch */
d1953 1
a1953 1
	DIE("ioctl is not implemented");
d1963 1
a1963 1
	DIE("fcntl is not implemented");
d1968 2
a1969 2
	    DIE("Possible memory corruption: %s overflowed 3rd argument",
		op_name[optype]);
d1995 1
a1995 1
    if (MAXARG <= 0)
d2007 1
a2007 1
    else
d2009 4
d2016 1
a2016 1
    DIE(no_func, "flock()");
d2057 3
d2063 1
a2063 1
    DIE(no_sock_func, "socket");
d2110 4
d2117 1
a2117 1
    DIE(no_sock_func, "socketpair");
d2171 2
a2172 2
    if (PL_dowarn)
	warn("bind() on closed fd");
d2176 1
a2176 1
    DIE(no_sock_func, "bind");
d2201 2
a2202 2
    if (PL_dowarn)
	warn("connect() on closed fd");
d2206 1
a2206 1
    DIE(no_sock_func, "connect");
d2227 2
a2228 2
    if (PL_dowarn)
	warn("listen() on closed fd");
d2232 1
a2232 1
    DIE(no_sock_func, "listen");
d2276 3
d2284 2
a2285 2
    if (PL_dowarn)
	warn("accept() on closed fd");
d2292 1
a2292 1
    DIE(no_sock_func, "accept");
d2311 2
a2312 2
    if (PL_dowarn)
	warn("shutdown() on closed fd");
d2316 1
a2316 1
    DIE(no_sock_func, "shutdown");
d2323 1
a2323 1
    return pp_ssockopt(ARGS);
d2325 1
a2325 1
    DIE(no_sock_func, "getsockopt");
d2390 4
a2393 2
    if (PL_dowarn)
	warn("[gs]etsockopt() on closed fd");
d2399 1
a2399 1
    DIE(no_sock_func, "setsockopt");
d2406 1
a2406 1
    return pp_getpeername(ARGS);
d2408 1
a2408 1
    DIE(no_sock_func, "getsockname");
d2465 5
a2469 2
    if (PL_dowarn)
	warn("get{sock, peer}name() on closed fd");
d2475 1
a2475 1
    DIE(no_sock_func, "getpeername");
d2483 1
a2483 1
    return pp_stat(ARGS);
d2495 1
a2495 1
	tmpgv = cGVOP->op_gv;
d2527 2
a2528 2
	    if (PL_dowarn && strchr(SvPV(PL_statname, n_a), '\n'))
		warn(warn_nl, "stat");
d2542 22
a2563 6
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_dev)));
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_ino)));
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_mode)));
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_nlink)));
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_uid)));
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_gid)));
d2565 6
a2570 1
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_rdev)));
d2572 1
a2572 1
	PUSHs(sv_2mortal(newSVpv("", 0)));
a2573 1
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_size)));
d2575 7
a2581 7
	PUSHs(sv_2mortal(newSVnv((U32)PL_statcache.st_atime)));
	PUSHs(sv_2mortal(newSVnv((U32)PL_statcache.st_mtime)));
	PUSHs(sv_2mortal(newSVnv((U32)PL_statcache.st_ctime)));
#else
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_atime)));
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_mtime)));
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_ctime)));
d2584 2
a2585 2
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_blksize)));
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_blocks)));
d2587 2
a2588 2
	PUSHs(sv_2mortal(newSVpv("", 0)));
	PUSHs(sv_2mortal(newSVpv("", 0)));
d2596 1
a2596 1
    I32 result = my_stat(ARGS);
d2598 16
d2623 1
a2623 1
    I32 result = my_stat(ARGS);
d2625 16
d2650 1
a2650 1
    I32 result = my_stat(ARGS);
d2652 16
d2677 1
a2677 1
    I32 result = my_stat(ARGS);
d2679 16
d2704 1
a2704 1
    I32 result = my_stat(ARGS);
d2706 16
d2731 1
a2731 1
    I32 result = my_stat(ARGS);
d2733 16
d2758 1
a2758 1
    I32 result = my_stat(ARGS);
d2767 1
a2767 1
    return pp_ftrowned(ARGS);
d2772 1
a2772 1
    I32 result = my_stat(ARGS);
d2776 2
a2777 1
    if (PL_statcache.st_uid == (PL_op->op_type == OP_FTEOWNED ? PL_euid : PL_uid) )
d2784 1
a2784 1
    I32 result = my_stat(ARGS);
d2788 1
a2788 1
    if (!PL_statcache.st_size)
d2795 1
a2795 1
    I32 result = my_stat(ARGS);
d2799 3
d2803 1
d2809 1
a2809 1
    I32 result = my_stat(ARGS);
d2813 1
a2813 1
    PUSHn( ((I32)PL_basetime - (I32)PL_statcache.st_mtime) / 86400.0 );
d2819 1
a2819 1
    I32 result = my_stat(ARGS);
d2823 1
a2823 1
    PUSHn( ((I32)PL_basetime - (I32)PL_statcache.st_atime) / 86400.0 );
d2829 1
a2829 1
    I32 result = my_stat(ARGS);
d2833 1
a2833 1
    PUSHn( ((I32)PL_basetime - (I32)PL_statcache.st_ctime) / 86400.0 );
d2839 1
a2839 1
    I32 result = my_stat(ARGS);
d2850 1
a2850 1
    I32 result = my_stat(ARGS);
d2861 1
a2861 1
    I32 result = my_stat(ARGS);
d2872 1
a2872 1
    I32 result = my_stat(ARGS);
d2883 1
a2883 1
    I32 result = my_stat(ARGS);
d2894 1
a2894 1
    I32 result = my_stat(ARGS);
d2905 1
a2905 1
    I32 result = my_lstat(ARGS);
d2918 1
a2918 1
    I32 result = my_stat(ARGS);
d2932 1
a2932 1
    I32 result = my_stat(ARGS);
d2946 1
a2946 1
    I32 result = my_stat(ARGS);
d2965 1
a2965 1
	gv = cGVOP->op_gv;
d3004 1
d3007 1
a3007 1
	gv = cGVOP->op_gv;
d3033 1
a3033 1
		DIE("-T and -B not implemented on filehandles");
d3056 5
a3060 3
	    if (PL_dowarn)
		warn("Test on unopened file <%s>",
		  GvENAME(cGVOP->op_gv));
d3071 3
a3073 8
#ifdef HAS_OPEN3
	i = PerlLIO_open3(SvPV(sv, n_a), O_RDONLY, 0);
#else
	i = PerlLIO_open(SvPV(sv, n_a), 0);
#endif
	if (i < 0) {
	    if (PL_dowarn && strchr(SvPV(sv, n_a), '\n'))
		warn(warn_nl, "open");
d3076 3
a3078 2
	PL_laststatval = PerlLIO_fstat(i, &PL_statcache);
	if (PL_laststatval < 0)
d3080 4
a3083 2
	len = PerlLIO_read(i, tbuf, 512);
	(void)PerlLIO_close(i);
d3095 6
d3110 21
a3130 1
	else if (*s & 128)
d3132 1
d3148 1
a3148 1
    return pp_fttext(ARGS);
d3201 1
a3201 1
    DIE(no_func, "Unsupported function chown");
d3209 1
a3210 1
#ifdef HAS_CHROOT
d3216 1
a3216 1
    DIE(no_func, "chroot");
d3285 1
a3285 1
    SETi( link(tmps, tmps2) >= 0 );
d3287 1
a3287 1
    DIE(no_func, "Unsupported function link");
d3303 1
a3303 1
    DIE(no_func, "symlink");
d3333 2
a3334 4
static int
dooneliner(cmd, filename)
char *cmd;
char *filename;
d3422 1
a3422 1
    int mode = POPi;
d3427 8
a3434 1
    char *tmps = SvPV(TOPs, n_a);
d3489 1
a3489 1
    DIE(no_dir_func, "opendir");
d3498 1
a3498 1
    Direntry_t *readdir _((DIR *));
d3510 1
a3510 1
	while (dp = (Direntry_t *)PerlDir_read(IoDIRP(io))) {
d3512 1
a3512 1
	    sv = newSVpv(dp->d_name, dp->d_namlen);
d3517 2
a3518 1
  	    SvTAINTED_on(sv);
d3527 1
a3527 1
	sv = newSVpv(dp->d_name, dp->d_namlen);
d3532 2
a3533 1
	SvTAINTED_on(sv);
d3547 1
a3547 1
    DIE(no_dir_func, "readdir");
d3555 6
a3560 2
# ifdef NEED_TELLDIR_PROTO /* XXX does _anyone_ need this? --AD 2/20/1998 */
    long telldir _((DIR *));
d3575 1
a3575 1
    DIE(no_dir_func, "telldir");
d3598 1
a3598 1
    DIE(no_dir_func, "seekdir");
d3619 1
a3619 1
    DIE(no_dir_func, "rewinddir");
d3649 1
a3649 1
    DIE(no_dir_func, "closedir");
d3659 1
a3659 1
    int childpid;
d3663 1
d3669 2
a3670 2
	if (tmpgv = gv_fetchpv("$", TRUE, SVt_PV))
	    sv_setiv(GvSV(tmpgv), (IV)getpid());
d3676 12
a3687 1
    DIE(no_func, "Unsupported function fork");
d3693 1
a3693 1
#if !defined(DOSISH) || defined(OS2) || defined(WIN32)
d3695 1
a3695 1
    int childpid;
d3703 1
a3703 1
    DIE(no_func, "Unsupported function wait");
d3709 1
a3709 1
#if !defined(DOSISH) || defined(OS2) || defined(WIN32)
d3711 1
a3711 1
    int childpid;
d3722 1
a3722 1
    DIE(no_func, "Unsupported function waitpid");
d3730 1
a3730 1
    int childpid;
d3735 2
d3745 1
d3747 2
d3754 4
d3763 2
d3775 20
d3798 6
d3806 1
a3806 1
	value = (I32)do_aexec(really, MARK, SP);
d3809 1
a3809 1
	value = (I32)do_aexec(Nullsv, MARK, SP);
d3811 1
a3811 1
	value = (I32)do_exec(SvPVx(sv_mortalcopy(*SP), n_a));
d3838 1
d3847 6
d3854 1
d3865 4
d3870 1
d3873 6
d3894 1
a3894 1
    DIE(no_func, "Unsupported function kill");
d3905 1
a3905 1
    DIE(no_func, "getppid");
d3913 2
a3914 2
    int pid;
    I32 value;
d3921 1
a3921 1
    value = (I32)BSD_GETPGRP(pid);
d3923 3
a3925 3
    if (pid != 0 && pid != getpid())
	DIE("POSIX getpgrp can't take an argument");
    value = (I32)getpgrp();
d3927 1
a3927 1
    XPUSHi(value);
d3930 1
a3930 1
    DIE(no_func, "getpgrp()");
d3938 2
a3939 2
    int pgrp;
    int pid;
d3953 5
a3957 2
    if ((pgrp != 0 && pgrp != getpid()) || (pid != 0 && pid != getpid()))
	DIE("POSIX setpgrp can't take an argument");
d3962 1
a3962 1
    DIE(no_func, "setpgrp()");
d3977 1
a3977 1
    DIE(no_func, "getpriority()");
d3995 1
a3995 1
    DIE(no_func, "setpriority()");
d4033 1
a4033 1
    DIE("times not implemented");
d4045 1
a4045 1
    PUSHs(sv_2mortal(newSVnv(((double)PL_timesbuf.tms_utime)/HZ)));
d4047 3
a4049 3
	PUSHs(sv_2mortal(newSVnv(((double)PL_timesbuf.tms_stime)/HZ)));
	PUSHs(sv_2mortal(newSVnv(((double)PL_timesbuf.tms_cutime)/HZ)));
	PUSHs(sv_2mortal(newSVnv(((double)PL_timesbuf.tms_cstime)/HZ)));
d4057 1
a4057 1
    return pp_gmtime(ARGS);
a4085 1
	dTARGET;
d4089 8
a4096 8
	tsv = newSVpvf("%s %s %2d %02d:%02d:%02d %d",
		       dayname[tmbuf->tm_wday],
		       monname[tmbuf->tm_mon],
		       tmbuf->tm_mday,
		       tmbuf->tm_hour,
		       tmbuf->tm_min,
		       tmbuf->tm_sec,
		       tmbuf->tm_year + 1900);
d4100 9
a4108 9
	PUSHs(sv_2mortal(newSViv((I32)tmbuf->tm_sec)));
	PUSHs(sv_2mortal(newSViv((I32)tmbuf->tm_min)));
	PUSHs(sv_2mortal(newSViv((I32)tmbuf->tm_hour)));
	PUSHs(sv_2mortal(newSViv((I32)tmbuf->tm_mday)));
	PUSHs(sv_2mortal(newSViv((I32)tmbuf->tm_mon)));
	PUSHs(sv_2mortal(newSViv((I32)tmbuf->tm_year)));
	PUSHs(sv_2mortal(newSViv((I32)tmbuf->tm_wday)));
	PUSHs(sv_2mortal(newSViv((I32)tmbuf->tm_yday)));
	PUSHs(sv_2mortal(newSViv((I32)tmbuf->tm_isdst)));
d4123 1
a4123 1
    PUSHi((I32)anum);
d4126 1
a4126 1
    DIE(no_func, "Unsupported function alarm");
d4153 1
a4153 1
    return pp_semget(ARGS);
d4158 1
a4158 1
    return pp_semctl(ARGS);
d4163 1
a4163 1
    return pp_shmwrite(ARGS);
d4175 1
a4175 1
    return pp_semget(ARGS);
d4183 1
a4183 1
    return pp_semget(ARGS);
d4188 1
a4188 1
    return pp_semctl(ARGS);
d4200 1
a4200 1
    return pp_semget(ARGS);
d4213 1
a4213 1
    return pp_semget(ARGS);
d4230 1
a4230 1
    DIE("System V IPC is not implemented on this machine");
d4250 1
a4250 1
    return pp_semget(ARGS);
d4263 1
a4263 1
    return pp_semget(ARGS);
d4272 1
a4272 1
    return pp_ghostent(ARGS);
d4274 1
a4274 1
    DIE(no_sock_func, "gethostbyname");
d4281 1
a4281 1
    return pp_ghostent(ARGS);
d4283 1
a4283 1
    DIE(no_sock_func, "gethostbyaddr");
d4301 1
d4304 1
a4304 1
    if (which == OP_GHBYNAME) {
a4305 1
	STRLEN n_a;
d4308 1
a4308 1
	DIE(no_sock_func, "gethostbyname");
a4309 1
    }
d4319 1
a4319 1
	DIE(no_sock_func, "gethostbyaddr");
d4326 1
a4326 1
	DIE(no_sock_func, "gethostent");
d4374 1
a4374 1
    DIE(no_sock_func, "gethostent");
d4381 1
a4381 1
    return pp_gnetent(ARGS);
d4383 1
a4383 1
    DIE(no_sock_func, "getnetbyname");
d4390 1
a4390 1
    return pp_gnetent(ARGS);
d4392 1
a4392 1
    DIE(no_sock_func, "getnetbyaddr");
d4409 1
d4411 1
a4411 1
    if (which == OP_GNBYNAME) {
a4412 1
	STRLEN n_a;
d4415 1
a4415 1
        DIE(no_sock_func, "getnetbyname");
a4416 1
    }
d4423 1
a4423 1
	DIE(no_sock_func, "getnetbyaddr");
d4430 1
a4430 1
        DIE(no_sock_func, "getnetent");
d4462 1
a4462 1
    DIE(no_sock_func, "getnetent");
d4469 1
a4469 1
    return pp_gprotoent(ARGS);
d4471 1
a4471 1
    DIE(no_sock_func, "getprotobyname");
d4478 1
a4478 1
    return pp_gprotoent(ARGS);
d4480 1
a4480 1
    DIE(no_sock_func, "getprotobynumber");
d4497 1
d4499 1
a4499 1
    if (which == OP_GPBYNAME) {
a4500 1
	STRLEN n_a;
d4503 1
a4503 1
	DIE(no_sock_func, "getprotobyname");
a4504 1
    }
d4509 1
a4509 1
    DIE(no_sock_func, "getprotobynumber");
d4515 1
a4515 1
	DIE(no_sock_func, "getprotoent");
d4545 1
a4545 1
    DIE(no_sock_func, "getprotoent");
d4552 1
a4552 1
    return pp_gservent(ARGS);
d4554 1
a4554 1
    DIE(no_sock_func, "getservbyname");
d4561 1
a4561 1
    return pp_gservent(ARGS);
d4563 1
a4563 1
    DIE(no_sock_func, "getservbyport");
d4580 1
a4583 1
	STRLEN n_a;
d4592 1
a4592 1
	DIE(no_sock_func, "getservbyname");
a4596 1
	STRLEN n_a;
d4605 1
a4605 1
	DIE(no_sock_func, "getservbyport");
d4612 1
a4612 1
	DIE(no_sock_func, "getservent");
d4653 1
a4653 1
    DIE(no_sock_func, "getservent");
d4664 1
a4664 1
    DIE(no_sock_func, "sethostent");
d4675 1
a4675 1
    DIE(no_sock_func, "setnetent");
d4686 1
a4686 1
    DIE(no_sock_func, "setprotoent");
d4697 1
a4697 1
    DIE(no_sock_func, "setservent");
d4709 1
a4709 1
    DIE(no_sock_func, "endhostent");
d4721 1
a4721 1
    DIE(no_sock_func, "endnetent");
d4733 1
a4733 1
    DIE(no_sock_func, "endprotoent");
d4745 1
a4745 1
    DIE(no_sock_func, "endservent");
d4752 1
a4752 1
    return pp_gpwent(ARGS);
d4754 1
a4754 1
    DIE(no_func, "getpwnam");
d4761 1
a4761 1
    return pp_gpwent(ARGS);
d4763 1
a4763 1
    DIE(no_func, "getpwuid");
d4770 1
a4770 1
#if defined(HAS_PASSWD) && defined(HAS_GETPWENT)
d4775 3
d4784 1
d4786 20
d4812 1
d4814 3
d4829 6
d4836 5
d4844 1
d4846 3
d4851 1
d4853 3
a4855 1

d4894 4
d4906 1
a4906 1
    DIE(no_func, "getpwent");
d4913 1
a4913 1
#if defined(HAS_PASSWD) && defined(HAS_SETPWENT) && !defined(CYGWIN32)
d4915 3
d4920 1
a4920 1
    DIE(no_func, "setpwent");
d4929 3
d4934 1
a4934 1
    DIE(no_func, "endpwent");
d4941 1
a4941 1
    return pp_ggrent(ARGS);
d4943 1
a4943 1
    DIE(no_func, "getgrnam");
d4950 1
a4950 1
    return pp_ggrent(ARGS);
d4952 1
a4952 1
    DIE(no_func, "getgrgid");
d4959 1
a4959 1
#if defined(HAS_GROUP) && defined(HAS_GETGRENT)
d4971 1
d4973 3
d5011 1
a5011 1
    DIE(no_func, "getgrent");
d5022 1
a5022 1
    DIE(no_func, "setgrent");
d5033 1
a5033 1
    DIE(no_func, "endgrent");
d5048 1
a5048 1
    DIE(no_func, "getlogin");
d5062 1
a5062 1
    MAGIC *mg;
d5084 1
a5084 2
	else  {
	    STRLEN n_a;
a5085 1
	}
d5091 1
a5091 1
	DIE("Too many args to syscall");
d5093 1
a5093 1
	DIE("Too few args to syscall");
d5147 1
a5147 1
    DIE(no_func, "syscall");
d5177 1
a5177 1
    flock.l_start = flock.l_len = 0L;
d5215 1
a5215 3
lockf_emulate_flock (fd, operation)
int fd;
int operation;
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d25 6
d41 3
a43 1
# include <netdb.h>
d57 8
a64 1
#ifdef HOST_NOT_FOUND
d75 1
d77 1
d87 1
d89 1
d93 1
a93 1
#  ifdef _MSC_VER
d128 1
a128 1
# define my_chsize chsize
d191 1
a191 1
    dSP; dTARGET;
d193 2
a194 1
    char *tmps = POPp;
d198 1
a198 1
    fp = my_popen(tmps, "r");
d201 2
a202 1
	    while (PerlIO_read(fp, tokenbuf, sizeof tokenbuf) > 0)
d218 1
a218 1
		sv = NEWSV(56, 80);
d231 1
a231 1
	STATUS_NATIVE_SET(my_pclose(fp));
d249 1
a249 1
    if (tainting) {
d259 2
a260 2
    SAVESPTR(last_in_gv);	/* We don't want this to be permanent. */
    last_in_gv = (GV*)*stack_sp--;
d262 2
a263 2
    SAVESPTR(rs);		/* This is not permanent, either. */
    rs = sv_2mortal(newSVpv("", 1));
d266 1
a266 1
    *SvPVX(rs) = '\n';
d275 1
d278 2
a279 1
    last_in_gv = gv_fetchpv(SvPVx(GvSV((GV*)(*stack_sp--)), na), TRUE,SVt_PVIO);
d282 1
d286 1
a286 1
    last_in_gv = cGVOP->op_gv;
d292 1
a292 1
    dSP; dMARK;
d294 1
d297 2
a298 2
	do_join(TARG, &sv_no, MARK, SP);
	tmps = SvPV(TARG, na);
d302 1
a302 1
	tmps = SvPV(TOPs, na);
d305 1
a305 1
	SV *error = GvSV(errgv);
d309 1
a309 1
	tmps = SvPV(error, na);
d319 1
a319 1
    dSP; dMARK;
d321 3
d326 2
a327 2
	do_join(TARG, &sv_no, MARK, SP);
	tmps = SvPV(TARG, na);
d331 2
a332 1
	tmps = SvPV(TOPs, na);
d335 1
a335 1
	SV *error = GvSV(errgv);
d337 27
a363 3
	if (SvPOK(error) && SvCUR(error))
	    sv_catpv(error, "\t...propagated");
	tmps = SvPV(error, na);
d367 1
a367 1
    DIE("%s", tmps);
d374 1
a374 1
    dSP; dTARGET;
d392 3
a394 3
    if (do_open(gv, tmps, len, FALSE, 0, 0, Nullfp))
	PUSHi( (I32)forkprocess );
    else if (forkprocess == 0)		/* we are a new child */
d403 1
a403 1
    dSP;
d405 1
d408 1
a408 1
	gv = defoutgv;
d411 11
d429 1
a429 1
    dSP;
d453 1
a453 1
    if (pipe(fd) < 0)
d464 1
a464 1
	else close(fd[0]);
d466 1
a466 1
	else close(fd[1]);
d469 4
a472 1

d484 1
a484 1
    dSP; dTARGET;
d499 1
a499 1
    dSP; dTARGET;
d504 2
a505 2
	anum = umask(0);
	(void)umask(anum);
d508 1
a508 1
	anum = umask(POPi);
d512 6
a517 1
    DIE(no_func, "Unsupported function umask");
d524 1
a524 1
    dSP;
d538 1
a538 3
#ifdef DOSISH
#ifdef atarist
    if (!PerlIO_flush(fp) && (fp->_flag |= _IOBIN))
d542 1
a542 27
#else
    if (setmode(PerlIO_fileno(fp), OP_BINARY) != -1) {
#if defined(WIN32) && defined(__BORLANDC__)
	/* The translation mode of the stream is maintained independent
	 * of the translation mode of the fd in the Borland RTL (heavy
	 * digging through their runtime sources reveal).  User has to
	 * set the mode explicitly for the stream (though they don't
	 * document this anywhere). GSAR 97-5-24
	 */
	PerlIO_seek(fp,0L,0);
	fp->flags |= _F_BIN;
#endif
	RETPUSHYES;
    }
    else
	RETPUSHUNDEF;
#endif
#else
#if defined(USEMYBINMODE)
    if (my_binmode(fp,IoTYPE(io)) != NULL)
	RETPUSHYES;
	else
	RETPUSHUNDEF;
#else
    RETPUSHYES;
#endif
#endif
a543 1
}
d547 2
a548 1
    dSP;
a551 1
    BINOP myop;
d553 1
a553 2
    SV **mark = stack_base + ++*markstack_ptr;	/* reuse in entersub */
    I32 markoff = mark - stack_base - 1;
d555 2
a556 1
    bool oldcatch = CATCH_GET;
d558 47
a604 32
    varsv = mark[0];
    if (SvTYPE(varsv) == SVt_PVHV)
	methname = "TIEHASH";
    else if (SvTYPE(varsv) == SVt_PVAV)
	methname = "TIEARRAY";
    else if (SvTYPE(varsv) == SVt_PVGV)
	methname = "TIEHANDLE";
    else
	methname = "TIESCALAR";

    stash = gv_stashsv(mark[1], FALSE);
    if (!stash || !(gv = gv_fetchmethod(stash, methname)))
	DIE("Can't locate object method \"%s\" via package \"%s\"",
		methname, SvPV(mark[1],na));

    Zero(&myop, 1, BINOP);
    myop.op_last = (OP *) &myop;
    myop.op_next = Nullop;
    myop.op_flags = OPf_WANT_SCALAR | OPf_STACKED;
    CATCH_SET(TRUE);

    ENTER;
    SAVESPTR(op);
    op = (OP *) &myop;
    if (PERLDB_SUB && curstash != debstash)
	op->op_private |= OPpENTERSUB_DB;

    XPUSHs((SV*)GvCV(gv));
    PUTBACK;

    if (op = pp_entersub())
        runops();
a606 1
    CATCH_SET(oldcatch);
d608 1
d610 2
a611 8
	if (SvTYPE(varsv) == SVt_PVHV || SvTYPE(varsv) == SVt_PVAV) {
	    sv_unmagic(varsv, 'P');
	    sv_magic(varsv, sv, 'P', Nullch, 0);
	}
	else {
	    sv_unmagic(varsv, 'q');
	    sv_magic(varsv, sv, 'q', Nullch, 0);
	}
d614 1
a614 1
    SP = stack_base + markoff;
d621 8
a628 14
    dSP;
    SV * sv ;

    sv = POPs;

    if (dowarn) {
        MAGIC * mg ;
        if (SvMAGICAL(sv)) {
            if (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV)
                mg = mg_find(sv, 'P') ;
            else
                mg = mg_find(sv, 'q') ;
    
            if (mg && SvREFCNT(SvRV(mg->mg_obj)) > 1)  
d634 1
a634 4
    if (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV)
	sv_unmagic(sv, 'P');
    else
	sv_unmagic(sv, 'q');
d640 4
a643 3
    dSP;
    SV * sv ;
    MAGIC * mg ;
d645 6
a650 11
    sv = POPs;
    if (SvMAGICAL(sv)) {
        if (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV)
            mg = mg_find(sv, 'P') ;
        else
            mg = mg_find(sv, 'q') ;

        if (mg)  {
            PUSHs(sv_2mortal(newSVsv(mg->mg_obj))) ; 
            RETURN ;
	}
a651 1

d657 1
a657 1
    dSP;
a661 1
    BINOP myop;
a662 1
    bool oldcatch = CATCH_GET;
d666 1
a666 1
    sv = sv_mortalcopy(&sv_no);
a676 6
    Zero(&myop, 1, BINOP);
    myop.op_last = (OP *) &myop;
    myop.op_next = Nullop;
    myop.op_flags = OPf_WANT_SCALAR | OPf_STACKED;
    CATCH_SET(TRUE);

d678 1
a678 6
    SAVESPTR(op);
    op = (OP *) &myop;
    if (PERLDB_SUB && curstash != debstash)
	op->op_private |= OPpENTERSUB_DB;
    PUTBACK;
    pp_pushmark();
d680 1
a680 1
    EXTEND(sp, 5);
a687 1
    PUSHs((SV*)GvCV(gv));
d689 1
a689 3

    if (op = pp_entersub())
        runops();
d693 2
a694 5
	sp--;
	op = (OP *) &myop;
	PUTBACK;
	pp_pushmark();

a698 1
	PUSHs((SV*)GvCV(gv));
d700 1
a700 3

	if (op = pp_entersub())
	    runops();
d704 2
a705 2
    CATCH_SET(oldcatch);
    if (sv_isobject(TOPs))
d707 1
d719 1
a719 1
    dSP; dTARGET;
d732 1
d755 1
d757 8
a764 1
#if defined(__linux__) || defined(OS2)
a765 2
#else
    growsize = maxlen;		/* little endians can use vecs directly */
d801 1
a801 1
	    SvPV_force(sv,na);	/* force string conversion */
d824 1
a824 1
    nfound = select(
d849 1
a849 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d859 1
a859 2
setdefout(gv)
GV *gv;
d861 1
d864 3
a866 3
    if (defoutgv)
	SvREFCNT_dec(defoutgv);
    defoutgv = gv;
d871 1
a871 1
    dSP; dTARGET;
d875 1
a875 1
    newdefout = (op->op_private > 0) ? ((GV *) POPs) : NULL;
d877 1
a877 1
    egv = GvEGV(defoutgv);
d879 1
a879 1
	egv = defoutgv;
d882 1
a882 1
	XPUSHs(&sv_undef);
d886 1
a886 1
	    gv_efullname3(TARG, defoutgv, Nullch);
d905 1
a905 1
    dSP; dTARGET;
d910 1
a910 1
	gv = stdingv;
d914 1
a914 1
	gv = argvgv;
d916 1
a916 1
    if (SvMAGICAL(gv) && (mg = mg_find((SV*)gv, 'q'))) {
d919 1
a919 1
	XPUSHs(mg->mg_obj);
d943 2
a944 5
static OP *
doform(cv,gv,retop)
CV *cv;
GV *gv;
OP *retop;
d946 2
a947 1
    register CONTEXT *cx;
d956 1
a956 1
    PUSHBLOCK(cx, CXt_SUB, stack_sp);
d958 2
a959 2
    SAVESPTR(curpad);
    curpad = AvARRAY((AV*)svp[1]);
d967 1
a967 1
    dSP;
d974 1
a974 1
	gv = defoutgv;
d978 1
a978 1
	    gv = defoutgv;
d1003 1
a1003 1
    return doform(cv,gv,op->op_next);
d1008 1
a1008 1
    dSP;
d1015 1
a1015 1
    register CONTEXT *cx;
d1018 3
a1020 3
	  (long)IoLINES_LEFT(io), (long)FmLINES(formtarget)));
    if (IoLINES_LEFT(io) < FmLINES(formtarget) &&
	formtarget != toptarget)
d1048 1
a1048 1
	    char *s = SvPVX(formtarget);
d1058 3
a1060 3
		PerlIO_write(ofp, SvPVX(formtarget), s - SvPVX(formtarget));
		sv_chop(formtarget, s);
		FmLINES(formtarget) -= IoLINES_LEFT(io);
d1064 1
a1064 1
	    PerlIO_write(ofp, SvPVX(formfeed), SvCUR(formfeed));
d1067 1
a1067 1
	formtarget = toptarget;
d1080 1
a1080 1
	return doform(cv,gv,op);
d1084 1
a1084 1
    POPBLOCK(cx,curpm);
d1090 1
a1090 1
	if (dowarn) {
d1096 1
a1096 1
	PUSHs(&sv_no);
d1099 2
a1100 2
	if ((IoLINES_LEFT(io) -= FmLINES(formtarget)) < 0) {
	    if (dowarn)
d1103 1
a1103 1
	if (!PerlIO_write(ofp, SvPVX(formtarget), SvCUR(formtarget)) ||
d1105 1
a1105 1
	    PUSHs(&sv_no);
d1107 3
a1109 3
	    FmLINES(formtarget) = 0;
	    SvCUR_set(formtarget, 0);
	    *SvEND(formtarget) = '\0';
d1112 1
a1112 1
	    PUSHs(&sv_yes);
d1115 1
a1115 1
    formtarget = bodytarget;
d1122 1
a1122 1
    dSP; dMARK; dORIGMARK;
d1128 1
d1130 1
a1130 1
    if (op->op_flags & OPf_STACKED)
d1133 1
a1133 1
	gv = defoutgv;
d1135 1
a1135 1
    if (SvMAGICAL(gv) && (mg = mg_find((SV*)gv, 'q'))) {
d1137 1
a1137 1
	    EXTEND(SP, 1);
d1143 1
a1143 1
	*MARK = mg->mg_obj;
d1157 1
a1157 1
	if (dowarn) {
d1159 1
a1159 1
	    warn("Filehandle %s never opened", SvPV(sv,na));
d1165 1
a1165 1
	if (dowarn)  {
d1168 1
a1168 1
		warn("Filehandle %s opened only for input", SvPV(sv,na));
d1170 1
a1170 1
		warn("printf on closed filehandle %s", SvPV(sv,na));
d1177 1
a1177 1
	if (op->op_private & OPpLOCALE)
d1192 1
a1192 1
    PUSHs(&sv_yes);
d1198 1
a1198 1
    PUSHs(&sv_undef);
d1204 1
a1204 1
    dSP;
d1222 1
a1222 1
	PUSHs(&sv_yes);
d1225 1
a1225 1
	PUSHs(&sv_undef);
d1232 1
a1232 1
    dSP; dMARK; dORIGMARK; dTARGET;
d1244 2
a1245 2
    if ((op->op_type == OP_READ || op->op_type == OP_SYSREAD) &&
	SvMAGICAL(gv) && (mg = mg_find((SV*)gv, 'q')))
d1250 1
a1250 1
	*MARK = mg->mg_obj;
d1279 1
a1279 1
    if (op->op_type == OP_RECV) {
d1281 1
a1281 1
#if defined(VMS_DO_SOCKETS) && defined(DECCRTL_SOCKETS)
d1288 1
a1288 1
	length = recvfrom(PerlIO_fileno(IoIFP(io)), buffer, length, offset,
d1305 1
a1305 1
    if (op->op_type == OP_RECV)
d1318 12
a1329 2
    if (op->op_type == OP_SYSREAD) {
	length = read(PerlIO_fileno(IoIFP(io)), buffer+offset, length);
d1340 1
a1340 1
	length = recvfrom(PerlIO_fileno(IoIFP(io)), buffer+offset, length, 0,
d1345 1
d1347 4
d1371 9
d1385 1
a1385 1
    dSP; dMARK; dORIGMARK; dTARGET;
d1393 1
d1396 14
d1421 2
a1422 2
	if (dowarn) {
	    if (op->op_type == OP_SYSWRITE)
d1428 1
a1428 1
    else if (op->op_type == OP_SYSWRITE) {
d1441 11
a1451 1
	length = write(PerlIO_fileno(IoIFP(io)), buffer+offset, length);
d1458 1
a1458 1
	length = sendto(PerlIO_fileno(IoIFP(io)), buffer, blen, length,
d1462 1
a1462 1
	length = send(PerlIO_fileno(IoIFP(io)), buffer, blen, length);
d1486 1
a1486 1
    dSP;
d1490 1
a1490 1
	gv = last_in_gv;
d1492 1
a1492 1
	gv = last_in_gv = (GV*)POPs;
d1499 1
a1499 1
    dSP; dTARGET;
d1503 1
a1503 1
	gv = last_in_gv;
d1505 1
a1505 1
	gv = last_in_gv = (GV*)POPs;
d1517 1
a1517 1
    dSP;
d1522 2
a1523 2
    gv = last_in_gv = (GV*)POPs;
    if (op->op_type == OP_SEEK)
d1527 1
a1527 1
	PUSHs((n < 0) ? &sv_undef
d1536 1
a1536 1
    dSP;
d1540 1
d1544 2
a1545 2
    if (op->op_flags & OPf_SPECIAL) {
	tmpgv = gv_fetchpv(POPp, FALSE, SVt_PVIO);
d1569 1
a1569 1
	name = SvPV(sv, na);
d1577 1
a1577 1
	    if ((tmpfd = open(name, O_RDWR)) < 0)
d1582 1
a1582 1
		close(tmpfd);
d1605 1
a1605 1
    dSP; dTARGET;
d1608 1
a1608 1
    int optype = op->op_type;
d1640 1
a1640 1
	retval = ioctl(PerlIO_fileno(IoIFP(io)), func, s);
d1676 1
a1676 1
    dSP; dTARGET;
d1685 1
a1685 1
	gv = last_in_gv;
d1694 1
a1694 1
	value = (I32)(FLOCK(PerlIO_fileno(fp), argtype) >= 0);
d1709 1
a1709 1
    dSP;
d1730 1
a1730 1
    fd = socket(domain, type, protocol);
d1739 1
a1739 1
	if (!IoIFP(io) && !IoOFP(io)) close(fd);
d1751 1
a1751 1
    dSP;
d1775 1
a1775 1
    if (socketpair(domain, type, protocol, fd) < 0)
d1786 1
a1786 1
	if (!IoIFP(io1) && !IoOFP(io1)) close(fd[0]);
d1789 1
a1789 1
	if (!IoIFP(io2) && !IoOFP(io2)) close(fd[1]);
d1801 1
a1801 1
    dSP;
d1803 4
d1812 4
d1822 22
a1843 1
    if (bind(PerlIO_fileno(IoIFP(io)), (struct sockaddr *)addr, len) >= 0)
d1849 1
a1849 1
    if (dowarn)
d1860 1
a1860 1
    dSP;
d1873 1
a1873 1
    if (connect(PerlIO_fileno(IoIFP(io)), (struct sockaddr *)addr, len) >= 0)
d1879 1
a1879 1
    if (dowarn)
d1890 1
a1890 1
    dSP;
d1899 1
a1899 1
    if (listen(PerlIO_fileno(IoIFP(io)), backlog) >= 0)
d1905 1
a1905 1
    if (dowarn)
d1916 1
a1916 1
    dSP; dTARGET;
d1942 1
a1942 1
    fd = accept(PerlIO_fileno(IoIFP(gstio)), (struct sockaddr *)&saddr, &len);
d1951 1
a1951 1
	if (!IoIFP(nstio) && !IoOFP(nstio)) close(fd);
d1959 1
a1959 1
    if (dowarn)
d1973 1
a1973 1
    dSP; dTARGET;
d1982 1
a1982 1
    PUSHi( shutdown(PerlIO_fileno(IoIFP(io)), how) >= 0 );
d1986 1
a1986 1
    if (dowarn)
d2006 1
a2006 1
    dSP;
d2008 1
a2008 1
    int optype = op->op_type;
d2037 1
a2037 1
	if (getsockopt(fd, lvl, optname, SvPVX(sv), &len) < 0)
d2047 3
a2049 2
		buf = SvPV(sv, na);
		len = na;
d2051 1
a2051 1
	    else if (SvOK(sv)) {
d2056 1
a2056 1
	    if (setsockopt(fd, lvl, optname, buf, len) < 0)
d2058 1
a2058 1
	    PUSHs(&sv_yes);
d2065 1
a2065 1
    if (dowarn)
d2087 1
a2087 1
    dSP;
d2089 1
a2089 1
    int optype = op->op_type;
d2107 1
a2107 1
	if (getsockname(fd, (struct sockaddr *)SvPVX(sv), &len) < 0)
d2111 1
a2111 1
	if (getpeername(fd, (struct sockaddr *)SvPVX(sv), &len) < 0)
d2138 1
a2138 1
    if (dowarn)
d2158 1
a2158 1
    dSP;
d2162 1
d2164 1
a2164 1
    if (op->op_flags & OPf_REF) {
d2167 6
a2172 6
	if (tmpgv != defgv) {
	    laststype = OP_STAT;
	    statgv = tmpgv;
	    sv_setpv(statname, "");
	    laststatval = (GvIO(tmpgv) && IoIFP(GvIOp(tmpgv))
		? Fstat(PerlIO_fileno(IoIFP(GvIOn(tmpgv))), &statcache) : -1);
d2174 1
a2174 1
	if (laststatval < 0)
d2187 2
a2188 2
	sv_setpv(statname, SvPV(sv,na));
	statgv = Nullgv;
d2190 3
a2192 3
	laststype = op->op_type;
	if (op->op_type == OP_LSTAT)
	    laststatval = lstat(SvPV(statname, na), &statcache);
d2195 3
a2197 3
	    laststatval = Stat(SvPV(statname, na), &statcache);
	if (laststatval < 0) {
	    if (dowarn && strchr(SvPV(statname, na), '\n'))
d2212 6
a2217 6
	PUSHs(sv_2mortal(newSViv((I32)statcache.st_dev)));
	PUSHs(sv_2mortal(newSViv((I32)statcache.st_ino)));
	PUSHs(sv_2mortal(newSViv((I32)statcache.st_mode)));
	PUSHs(sv_2mortal(newSViv((I32)statcache.st_nlink)));
	PUSHs(sv_2mortal(newSViv((I32)statcache.st_uid)));
	PUSHs(sv_2mortal(newSViv((I32)statcache.st_gid)));
d2219 1
a2219 1
	PUSHs(sv_2mortal(newSViv((I32)statcache.st_rdev)));
d2223 1
a2223 1
	PUSHs(sv_2mortal(newSViv((I32)statcache.st_size)));
d2225 7
a2231 7
	PUSHs(sv_2mortal(newSVnv((U32)statcache.st_atime)));
	PUSHs(sv_2mortal(newSVnv((U32)statcache.st_mtime)));
	PUSHs(sv_2mortal(newSVnv((U32)statcache.st_ctime)));
#else
	PUSHs(sv_2mortal(newSViv((I32)statcache.st_atime)));
	PUSHs(sv_2mortal(newSViv((I32)statcache.st_mtime)));
	PUSHs(sv_2mortal(newSViv((I32)statcache.st_ctime)));
d2234 2
a2235 2
	PUSHs(sv_2mortal(newSViv((I32)statcache.st_blksize)));
	PUSHs(sv_2mortal(newSViv((I32)statcache.st_blocks)));
d2247 1
a2247 1
    dSP;
d2250 1
a2250 1
    if (cando(S_IRUSR, 0, &statcache))
d2258 1
a2258 1
    dSP;
d2261 1
a2261 1
    if (cando(S_IWUSR, 0, &statcache))
d2269 1
a2269 1
    dSP;
d2272 1
a2272 1
    if (cando(S_IXUSR, 0, &statcache))
d2280 1
a2280 1
    dSP;
d2283 1
a2283 1
    if (cando(S_IRUSR, 1, &statcache))
d2291 1
a2291 1
    dSP;
d2294 1
a2294 1
    if (cando(S_IWUSR, 1, &statcache))
d2302 1
a2302 1
    dSP;
d2305 1
a2305 1
    if (cando(S_IXUSR, 1, &statcache))
d2313 1
a2313 1
    dSP;
d2327 1
a2327 1
    dSP;
d2330 1
a2330 1
    if (statcache.st_uid == (op->op_type == OP_FTEOWNED ? euid : uid) )
d2338 1
a2338 1
    dSP;
d2341 1
a2341 1
    if (!statcache.st_size)
d2349 1
a2349 1
    dSP; dTARGET;
d2352 1
a2352 1
    PUSHi(statcache.st_size);
d2359 1
a2359 1
    dSP; dTARGET;
d2362 1
a2362 1
    PUSHn( ((I32)basetime - (I32)statcache.st_mtime) / 86400.0 );
d2369 1
a2369 1
    dSP; dTARGET;
d2372 1
a2372 1
    PUSHn( ((I32)basetime - (I32)statcache.st_atime) / 86400.0 );
d2379 1
a2379 1
    dSP; dTARGET;
d2382 1
a2382 1
    PUSHn( ((I32)basetime - (I32)statcache.st_ctime) / 86400.0 );
d2389 1
a2389 1
    dSP;
d2392 1
a2392 1
    if (S_ISSOCK(statcache.st_mode))
d2400 1
a2400 1
    dSP;
d2403 1
a2403 1
    if (S_ISCHR(statcache.st_mode))
d2411 1
a2411 1
    dSP;
d2414 1
a2414 1
    if (S_ISBLK(statcache.st_mode))
d2422 1
a2422 1
    dSP;
d2425 1
a2425 1
    if (S_ISREG(statcache.st_mode))
d2433 1
a2433 1
    dSP;
d2436 1
a2436 1
    if (S_ISDIR(statcache.st_mode))
d2444 1
a2444 1
    dSP;
d2447 1
a2447 1
    if (S_ISFIFO(statcache.st_mode))
d2455 1
a2455 1
    dSP;
d2458 1
a2458 1
    if (S_ISLNK(statcache.st_mode))
d2465 1
a2465 1
    dSP;
d2471 1
a2471 1
    if (statcache.st_mode & S_ISUID)
d2479 1
a2479 1
    dSP;
d2485 1
a2485 1
    if (statcache.st_mode & S_ISGID)
d2493 1
a2493 1
    dSP;
d2499 1
a2499 1
    if (statcache.st_mode & S_ISVTX)
d2507 1
a2507 1
    dSP;
d2511 1
d2513 1
a2513 1
    if (op->op_flags & OPf_REF)
d2520 1
a2520 1
	gv = gv_fetchpv(tmps = POPp, FALSE, SVt_PVIO);
d2528 1
a2528 1
    if (isatty(fd))
d2543 1
a2543 1
    dSP;
d2552 1
d2554 1
a2554 1
    if (op->op_flags & OPf_REF)
d2565 3
a2567 3
	if (gv == defgv) {
	    if (statgv)
		io = GvIO(statgv);
d2569 1
a2569 1
		sv = statname;
d2574 4
a2577 4
	    statgv = gv;
	    laststatval = -1;
	    sv_setpv(statname, "");
	    io = GvIO(statgv);
d2582 2
a2583 2
	    laststatval = Fstat(PerlIO_fileno(IoIFP(io)), &statcache);
	    if (laststatval < 0)
d2585 2
a2586 2
	    if (S_ISDIR(statcache.st_mode))	/* handle NFS glitch */
		if (op->op_type == OP_FTTEXT)
d2604 1
a2604 1
	    if (dowarn)
d2614 3
a2616 3
	statgv = Nullgv;
	laststatval = -1;
	sv_setpv(statname, SvPV(sv, na));
d2618 1
a2618 1
	i = open(SvPV(sv, na), O_RDONLY, 0);
d2620 1
a2620 1
	i = open(SvPV(sv, na), 0);
d2623 1
a2623 1
	    if (dowarn && strchr(SvPV(sv, na), '\n'))
d2627 2
a2628 2
	laststatval = Fstat(i, &statcache);
	if (laststatval < 0)
d2630 2
a2631 2
	len = read(i, tbuf, 512);
	(void)close(i);
d2633 1
a2633 1
	    if (S_ISDIR(statcache.st_mode) && op->op_type == OP_FTTEXT)
d2648 4
d2658 1
d2661 1
a2661 1
    if ((odd * 3 > len) == (op->op_type == OP_FTTEXT)) /* allow 1/3 odd */
d2676 1
a2676 1
    dSP; dTARGET;
d2679 1
d2684 1
a2684 1
	tmps = POPp;
d2686 1
a2686 1
	svp = hv_fetch(GvHVn(envgv), "HOME", 4, FALSE);
d2688 1
a2688 1
	    tmps = SvPV(*svp, na);
d2691 1
a2691 1
	svp = hv_fetch(GvHVn(envgv), "LOGDIR", 6, FALSE);
d2693 7
a2699 1
	    tmps = SvPV(*svp, na);
d2701 1
d2703 1
a2703 1
    PUSHi( chdir(tmps) >= 0 );
d2707 1
a2707 1
    hv_delete(GvHVn(envgv),"DEFAULT",7,G_DISCARD);
d2714 1
a2714 1
    dSP; dMARK; dTARGET;
d2717 1
a2717 1
    value = (I32)apply(op->op_type, MARK, SP);
d2728 1
a2728 1
    dSP; dTARGET;
d2730 1
d2732 1
a2732 1
    tmps = POPp;
d2743 1
a2743 1
    dSP; dMARK; dTARGET;
d2745 1
a2745 1
    value = (I32)apply(op->op_type, MARK, SP);
d2753 1
a2753 1
    dSP; dMARK; dTARGET;
d2755 1
a2755 1
    value = (I32)apply(op->op_type, MARK, SP);
d2763 1
a2763 1
    dSP; dMARK; dTARGET;
d2765 1
a2765 1
    value = (I32)apply(op->op_type, MARK, SP);
d2773 1
a2773 1
    dSP; dTARGET;
d2775 1
d2777 2
a2778 2
    char *tmps2 = POPp;
    char *tmps = SvPV(TOPs, na);
d2781 1
a2781 1
    anum = rename(tmps, tmps2);
d2783 1
a2783 1
    if (!(anum = Stat(tmps, &statbuf))) {
d2787 1
a2787 1
	    if (euid || Stat(tmps2, &statbuf) < 0 || !S_ISDIR(statbuf.st_mode))
d2800 1
a2800 1
    dSP; dTARGET;
d2802 3
a2804 2
    char *tmps2 = POPp;
    char *tmps = SvPV(TOPs, na);
d2815 1
a2815 1
    dSP; dTARGET;
d2817 3
a2819 2
    char *tmps2 = POPp;
    char *tmps = SvPV(TOPs, na);
d2830 1
a2830 1
    dSP; dTARGET;
d2835 1
d2840 1
a2840 1
    tmps = POPp;
d2873 1
a2873 1
    myfp = my_popen(cmdline, "r");
d2878 1
a2878 1
	/* Need to save/restore 'rs' ?? */
d2880 1
a2880 1
	(void)my_pclose(myfp);
d2927 2
a2928 2
	    anum = (Stat(save_filename, &statbuf) >= 0);
	    if (op->op_type == OP_RMDIR)
d2944 1
a2944 1
    dSP; dTARGET;
d2949 2
a2950 1
    char *tmps = SvPV(TOPs, na);
d2954 1
a2954 1
    SETi( Mkdir(tmps, mode) >= 0 );
d2957 3
a2959 3
    oldumask = umask(0);
    umask(oldumask);
    chmod(tmps, (mode & ~oldumask) & 0777);
d2966 1
a2966 1
    dSP; dTARGET;
d2968 1
d2970 1
a2970 1
    tmps = POPp;
d2973 1
a2973 1
    XPUSHi( rmdir(tmps) >= 0 );
d2984 1
a2984 1
    dSP;
d2986 2
a2987 1
    char *dirname = POPp;
d2995 2
a2996 2
	closedir(IoDIRP(io));
    if (!(IoDIRP(io) = opendir(dirname)))
d3011 1
a3011 1
    dSP;
d3026 1
a3026 1
	while (dp = (Direntry_t *)readdir(IoDIRP(io))) {
d3039 1
a3039 1
	if (!(dp = (Direntry_t *)readdir(IoDIRP(io))))
d3067 1
a3067 1
    dSP; dTARGET;
d3069 1
a3069 1
#if !defined(telldir) && !defined(HAS_TELLDIR_PROTOTYPE)
d3071 1
a3071 1
#endif
d3078 1
a3078 1
    PUSHi( telldir(IoDIRP(io)) );
d3091 1
a3091 1
    dSP;
d3100 1
a3100 1
    (void)seekdir(IoDIRP(io), along);
d3114 1
a3114 1
    dSP;
d3122 1
a3122 1
    (void)rewinddir(IoDIRP(io));
d3135 1
a3135 1
    dSP;
d3144 1
a3144 1
    closedir(IoDIRP(io));
d3146 1
a3146 1
    if (closedir(IoDIRP(io)) < 0) {
d3168 1
a3168 1
    dSP; dTARGET;
d3180 1
a3180 1
	hv_clear(pidstatus);	/* no kids, so don't wait for 'em */
d3191 2
a3192 2
#if !defined(DOSISH) || defined(OS2)
    dSP; dTARGET;
d3207 2
a3208 2
#if !defined(DOSISH) || defined(OS2)
    dSP; dTARGET;
d3220 1
a3220 1
    DIE(no_func, "Unsupported function wait");
d3226 1
a3226 1
    dSP; dMARK; dORIGMARK; dTARGET;
d3232 1
d3235 2
a3236 2
	if (tainting) {
	    char *junk = SvPV(TOPs, na);
d3265 1
a3265 1
    if (op->op_flags & OPf_STACKED) {
d3272 1
a3272 1
	value = (I32)do_exec(SvPVx(sv_mortalcopy(*SP), na));
d3274 1
a3274 1
    _exit(-1);
d3276 1
a3276 1
    if (op->op_flags & OPf_STACKED) {
d3278 1
a3278 1
	value = (I32)do_aspawn(really, MARK, SP);
d3281 1
a3281 1
	value = (I32)do_aspawn(Nullsv, MARK, SP);
d3283 1
a3283 1
	value = (I32)do_spawn(SvPVx(sv_mortalcopy(*SP), na));
d3295 1
a3295 1
    dSP; dMARK; dORIGMARK; dTARGET;
d3297 1
d3299 1
a3299 1
    if (op->op_flags & OPf_STACKED) {
d3310 2
a3311 2
	if (tainting) {
	    char *junk = SvPV(*SP, na);
d3316 1
a3316 1
	value = (I32)vms_do_exec(SvPVx(sv_mortalcopy(*SP), na));
d3318 1
a3318 1
	value = (I32)do_exec(SvPVx(sv_mortalcopy(*SP), na));
d3328 1
a3328 1
    dSP; dMARK; dTARGET;
d3331 1
a3331 1
    value = (I32)apply(op->op_type, MARK, SP);
d3343 1
a3343 1
    dSP; dTARGET;
d3354 1
a3354 1
    dSP; dTARGET;
d3379 1
a3379 1
    dSP; dTARGET;
d3407 1
a3407 1
    dSP; dTARGET;
d3422 1
a3422 1
    dSP; dTARGET;
d3442 1
a3442 1
    dSP; dTARGET;
d3469 1
a3469 1
    dSP;
d3477 1
a3477 1
    (void)times(&timesbuf);
d3479 3
a3481 3
    (void)times((tbuffer_t *)&timesbuf);  /* time.h uses different name for */
                                          /* struct tms, though same data   */
                                          /* is returned.                   */
d3484 1
a3484 1
    PUSHs(sv_2mortal(newSVnv(((double)timesbuf.tms_utime)/HZ)));
d3486 3
a3488 3
	PUSHs(sv_2mortal(newSVnv(((double)timesbuf.tms_stime)/HZ)));
	PUSHs(sv_2mortal(newSVnv(((double)timesbuf.tms_cutime)/HZ)));
	PUSHs(sv_2mortal(newSVnv(((double)timesbuf.tms_cstime)/HZ)));
d3501 1
a3501 1
    dSP;
d3517 1
a3517 1
    if (op->op_type == OP_LOCALTIME)
d3555 1
a3555 1
    dSP; dTARGET;
d3572 1
a3572 1
    dSP; dTARGET;
d3579 1
a3579 1
	Pause();
d3582 1
a3582 1
	sleep((unsigned int)duration);
d3609 2
a3610 2
    dSP; dMARK; dTARGET;
    I32 value = (I32)(do_shmio(op->op_type, MARK, SP) >= 0);
d3634 1
a3634 1
    dSP; dMARK; dTARGET;
d3647 1
a3647 1
    dSP; dMARK; dTARGET;
d3662 2
a3663 2
    dSP; dMARK; dTARGET;
    int anum = do_ipcget(op->op_type, MARK, SP);
d3677 2
a3678 2
    dSP; dMARK; dTARGET;
    int anum = do_ipcctl(op->op_type, MARK, SP);
d3697 1
a3697 1
    dSP; dMARK; dTARGET;
d3711 1
a3711 1
#ifdef HAS_SOCKET
d3720 1
a3720 1
#ifdef HAS_SOCKET
d3729 3
a3731 3
    dSP;
#ifdef HAS_SOCKET
    I32 which = op->op_type;
d3734 4
a3737 4
    struct hostent *gethostbyname();
    struct hostent *gethostbyaddr();
#ifdef HAS_GETHOSTENT
    struct hostent *gethostent();
d3744 6
a3749 1
	hent = gethostbyname(POPp);
d3752 1
d3756 1
a3756 1
	char *addr = SvPV(addrsv, addrlen);
d3758 4
a3761 1
	hent = gethostbyaddr(addr, addrlen, addrtype);
d3765 1
a3765 1
	hent = gethostent();
d3767 1
a3767 1
	DIE("gethostent not implemented");
d3789 1
a3789 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d3791 1
a3791 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d3797 1
a3797 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d3799 1
a3799 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d3804 1
a3804 1
	    XPUSHs(sv = sv_mortalcopy(&sv_no));
d3808 1
a3808 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d3821 1
a3821 1
#ifdef HAS_SOCKET
d3830 1
a3830 1
#ifdef HAS_SOCKET
d3839 3
a3841 3
    dSP;
#ifdef HAS_SOCKET
    I32 which = op->op_type;
d3844 5
a3848 3
    struct netent *getnetbyname();
    struct netent *getnetbyaddr();
    struct netent *getnetent();
d3851 8
a3858 2
    if (which == OP_GNBYNAME)
	nent = getnetbyname(POPp);
d3860 1
d3862 5
a3866 2
	unsigned long addr = U_L(POPn);
	nent = getnetbyaddr((long)addr, addrtype);
d3869 5
a3873 1
	nent = getnetent();
d3888 1
a3888 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d3890 1
a3890 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d3896 1
a3896 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d3898 1
a3898 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d3910 1
a3910 1
#ifdef HAS_SOCKET
d3919 1
a3919 1
#ifdef HAS_SOCKET
d3928 3
a3930 3
    dSP;
#ifdef HAS_SOCKET
    I32 which = op->op_type;
d3932 6
a3937 4
    register SV *sv;
    struct protoent *getprotobyname();
    struct protoent *getprotobynumber();
    struct protoent *getprotoent();
d3940 8
a3947 2
    if (which == OP_GPBYNAME)
	pent = getprotobyname(POPp);
d3949 5
a3953 1
	pent = getprotobynumber(POPi);
d3955 5
a3959 1
	pent = getprotoent();
d3974 1
a3974 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d3976 1
a3976 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d3982 1
a3982 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d3994 1
a3994 1
#ifdef HAS_SOCKET
d4003 1
a4003 1
#ifdef HAS_SOCKET
d4012 3
a4014 3
    dSP;
#ifdef HAS_SOCKET
    I32 which = op->op_type;
d4017 5
a4021 3
    struct servent *getservbyname();
    struct servent *getservbynumber();
    struct servent *getservent();
d4025 4
a4028 2
	char *proto = POPp;
	char *name = POPp;
d4033 4
a4036 1
	sent = getservbyname(name, proto);
d4039 3
a4041 1
	char *proto = POPp;
d4045 5
a4049 1
	port = htons(port);
a4050 1
	sent = getservbyport(port, proto);
d4053 5
a4057 1
	sent = getservent();
d4065 1
a4065 1
		sv_setiv(sv, (IV)ntohs(sent->s_port));
d4077 1
a4077 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4079 1
a4079 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4085 1
a4085 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4087 1
a4087 1
	sv_setiv(sv, (IV)ntohs(sent->s_port));
d4091 1
a4091 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4103 3
a4105 3
    dSP;
#ifdef HAS_SOCKET
    sethostent(TOPi);
d4114 3
a4116 3
    dSP;
#ifdef HAS_SOCKET
    setnetent(TOPi);
d4125 3
a4127 3
    dSP;
#ifdef HAS_SOCKET
    setprotoent(TOPi);
d4136 3
a4138 3
    dSP;
#ifdef HAS_SOCKET
    setservent(TOPi);
d4147 4
a4150 4
    dSP;
#ifdef HAS_SOCKET
    endhostent();
    EXTEND(sp,1);
d4159 4
a4162 4
    dSP;
#ifdef HAS_SOCKET
    endnetent();
    EXTEND(sp,1);
d4171 4
a4174 4
    dSP;
#ifdef HAS_SOCKET
    endprotoent();
    EXTEND(sp,1);
d4183 4
a4186 4
    dSP;
#ifdef HAS_SOCKET
    endservent();
    EXTEND(sp,1);
d4213 3
a4215 3
    dSP;
#ifdef HAS_PASSWD
    I32 which = op->op_type;
d4218 1
d4221 1
a4221 1
	pwent = getpwnam(POPp);
d4240 1
a4240 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4242 3
a4244 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4246 3
a4248 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4250 2
a4251 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4253 3
a4255 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4259 1
a4259 1
#ifdef PWQUOTA
d4261 2
a4262 2
#else
#ifdef PWAGE
d4264 2
d4267 3
a4269 3
#endif
#endif
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4273 1
a4273 1
#ifdef PWCOMMENT
d4275 1
d4277 4
a4281 2
	PUSHs(sv = sv_mortalcopy(&sv_no));
	sv_setpv(sv, pwent->pw_gecos);
d4283 1
d4286 2
a4287 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4289 2
a4290 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4292 1
d4294 1
a4294 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4306 2
a4307 2
    dSP;
#if defined(HAS_PASSWD) && !defined(CYGWIN32)
d4317 2
a4318 2
    dSP;
#ifdef HAS_PASSWD
d4346 3
a4348 3
    dSP;
#ifdef HAS_GROUP
    I32 which = op->op_type;
d4352 1
d4355 1
a4355 1
	grent = (struct group *)getgrnam(POPp);
d4374 1
a4374 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4376 3
a4378 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4380 3
a4382 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4384 2
a4385 1
	PUSHs(sv = sv_mortalcopy(&sv_no));
d4401 2
a4402 2
    dSP;
#ifdef HAS_GROUP
d4412 2
a4413 2
    dSP;
#ifdef HAS_GROUP
d4423 1
a4423 1
    dSP; dTARGET;
d4427 1
a4427 1
    if (!(tmps = getlogin()))
d4441 1
a4441 1
    dSP; dMARK; dORIGMARK; dTARGET;
d4448 1
a4448 1
    if (tainting) {
d4466 1
a4466 1
	else if (*MARK == &sv_undef)
d4468 4
a4471 2
	else 
	    a[i++] = (unsigned long)SvPV_force(*MARK, na);
d4544 1
a4544 3
fcntl_emulate_flock(fd, operation)
int fd;
int operation;
d4611 1
a4611 1
    pos = lseek(fd, (Off_t)0, SEEK_CUR);    /* get pos to restore later */
d4613 1
a4613 1
	if (lseek(fd, (Off_t)0, SEEK_SET) < 0)
d4650 1
a4650 1
	lseek(fd, pos, SEEK_SET);	/* ignore error here	*/
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d20 7
a26 8
/* XXX Omit this -- it causes too much grief on mixed systems.
   Next time, I should force broken systems to unset i_unistd in
   hint files.
*/
#if 0
# ifdef I_UNISTD
#  include <unistd.h>
# endif
d29 2
a30 5
/* Put this after #includes because fork and vfork prototypes may
   conflict.
*/
#ifndef HAS_VFORK
#   define vfork fork
a44 1
#ifndef I_SYS_TIME
a47 1
#endif
d74 5
a78 1
#include <utime.h>
d87 14
d104 64
d173 1
a173 1
    FILE *fp;
d175 2
d180 7
a186 2
	sv_setpv(TARG, "");	/* note that this preserves previous buffer */
	if (GIMME == G_SCALAR) {
d191 1
d207 1
d210 2
a211 1
	statusvalue = FIXSTATUS(my_pclose(fp));
d214 2
a215 2
	statusvalue = -1;
	if (GIMME == G_SCALAR)
d227 11
d247 1
a247 1
#endif	/* !MSDOS */
d329 3
a331 1
    else if (SvTYPE(TOPs) == SVt_PVGV)
d333 2
a334 1
    else
d336 2
a337 1
    gv = (GV*)POPs;
d339 1
a339 2
    if (do_open(gv, tmps, len, FALSE, 0, 0, Nullfp)) {
	IoLINES(GvIOp(gv)) = 0;
a340 1
    }
d358 1
a358 1
    PUSHs( do_close(gv, TRUE) ? &sv_yes : &sv_no );
d391 2
a392 2
    IoIFP(rstio) = fdopen(fd[0], "r");
    IoOFP(wstio) = fdopen(fd[1], "w");
d398 1
a398 1
	if (IoIFP(rstio)) fclose(IoIFP(rstio));
d400 1
a400 1
	if (IoOFP(wstio)) fclose(IoOFP(wstio));
d419 1
a419 1
    FILE *fp;
d425 1
a425 1
    PUSHi(fileno(fp));
d454 1
a454 1
    FILE *fp;
d463 1
a463 1
	RETSETUNDEF;
d467 1
a467 1
    if (!Fflush(fp) && (fp->_flag |= _IOBIN))
d472 11
a482 1
    if (setmode(fileno(fp), OP_BINARY) != -1)
d484 1
d489 6
d497 2
d512 1
d525 1
a525 1
    if (!stash || !(gv = gv_fetchmethod(stash, methname)) || !GvCV(gv))
d532 2
a533 1
    myop.op_flags = OPf_KNOW|OPf_STACKED;
d538 2
d541 1
a541 1
    XPUSHs(gv);
d548 1
d569 20
a588 2
    if (SvTYPE(TOPs) == SVt_PVHV || SvTYPE(TOPs) == SVt_PVAV)
	sv_unmagic(TOPs, 'P');
d590 2
a591 2
	sv_unmagic(TOPs, 'q');
    RETSETYES;
d625 1
d632 1
a632 1
    if (!stash || !(gv = gv_fetchmethod(stash, "TIEHASH")) || !GvCV(gv)) {
d636 1
a636 1
	if (!(gv = gv_fetchmethod(stash, "TIEHASH")) || !GvCV(gv))
d643 2
a644 1
    myop.op_flags = OPf_KNOW|OPf_STACKED;
d649 2
d662 1
a662 1
    PUSHs(gv);
d679 1
a679 1
	PUSHs(gv);
d687 1
d737 1
a737 1
#ifdef __linux__
d859 8
a866 6
	GV **gvp = hv_fetch(hv, GvNAME(egv), GvNAMELEN(egv), FALSE);
	if (gvp && *gvp == egv)
	    gv_efullname(TARG, defoutgv);
	else
	    sv_setsv(TARG, sv_2mortal(newRV(egv)));
	XPUSHTARG;
d882 1
d890 14
d906 1
a906 1
    TAINT_IF(1);
d908 1
a908 1
    *SvPVX(TARG) = getc(IoIFP(GvIOp(gv))); /* should never be EOF */
d925 1
a925 1
    I32 gimme = GIMME;
a967 1

d971 1
a971 1
	    gv_efullname(tmpsv, gv);
d976 3
a979 1

d988 2
a989 2
    FILE *ofp = IoOFP(io);
    FILE *fp;
d994 1
a994 1
    DEBUG_f(fprintf(stderr,"left=%ld, todo=%ld\n",
d1003 1
a1003 1
	    char tmpbuf[256];
d1008 2
a1009 2
		sprintf(tmpbuf, "%s_TOP", IoFMT_NAME(io));
		topgv = gv_fetchpv(tmpbuf,FALSE, SVt_PVFM);
d1012 1
a1012 1
		    IoTOP_NAME(io) = savepv(tmpbuf);
d1035 1
a1035 1
		fwrite1(SvPVX(formtarget), s - SvPVX(formtarget), 1, ofp);
d1041 1
a1041 1
	    fwrite1(SvPVX(formfeed), SvCUR(formfeed), 1, ofp);
d1052 1
a1052 1
	    gv_efullname(tmpsv, fgv);
d1055 2
d1080 2
a1081 2
	if (!fwrite1(SvPVX(formtarget), 1, SvCUR(formtarget), ofp) ||
		ferror(fp))
d1088 1
a1088 1
		(void)Fflush(fp);
d1102 3
a1104 2
    FILE *fp;
    SV *sv = NEWSV(0,0);
d1110 22
d1134 1
a1134 1
	    gv_fullname(sv,gv);
d1142 1
a1142 1
	    gv_fullname(sv,gv);
d1152 6
d1163 1
a1163 1
	    if (Fflush(fp) == EOF)
d1213 2
a1214 2
    int length;
    int bufsize;
d1217 1
d1220 17
d1240 2
d1256 6
a1261 1
	bufsize = sizeof buf;
d1263 3
a1265 2
	length = recvfrom(fileno(IoIFP(io)), buffer, length, offset,
	    (struct sockaddr *)buf, &bufsize);
d1272 3
a1274 2
	if (tainting)
	    sv_magic(bufsv, Nullsv, 't', Nullch, 0);
d1276 1
a1276 1
	sv_setpvn(TARG, buf, bufsize);
d1284 6
d1291 3
d1295 1
a1295 1
	length = read(fileno(IoIFP(io)), buffer+offset, length);
d1300 8
a1307 3
	bufsize = sizeof buf;
	length = recvfrom(fileno(IoIFP(io)), buffer+offset, length, 0,
	    (struct sockaddr *)buf, &bufsize);
d1311 1
a1311 1
	length = fread(buffer+offset, 1, length, IoIFP(io));
d1318 3
a1320 2
    if (tainting)
	sv_magic(bufsv, Nullsv, 't', Nullch, 0);
d1366 1
a1366 1
	if (MARK < SP)
d1368 7
a1374 1
	else
d1378 1
a1378 1
	length = write(fileno(IoIFP(io)), buffer+offset, length);
d1385 1
a1385 1
	length = sendto(fileno(IoIFP(io)), buffer, blen, length,
d1389 2
a1390 1
	length = send(fileno(IoIFP(io)), buffer, blen, length);
d1420 1
a1420 1
    PUSHs(!gv || do_eof(gv) ? &sv_yes : &sv_no);
d1439 5
d1450 8
a1457 1
    PUSHs( do_seek(gv, offset, whence) ? &sv_yes : &sv_no );
a1469 1
#ifdef HAS_TRUNCATE
d1471 3
a1473 1
	tmpgv = gv_fetchpv(POPp,FALSE, SVt_PVIO);
d1475 5
a1479 10
	  ftruncate(fileno(IoIFP(GvIOn(tmpgv))), len) < 0)
	    result = 0;
    }
    else if (truncate(POPp, len) < 0)
	result = 0;
#else
    if (op->op_flags & OPf_SPECIAL) {
	tmpgv = gv_fetchpv(POPp,FALSE, SVt_PVIO);
	if (!GvIO(tmpgv) || !IoIFP(GvIOp(tmpgv)) ||
	  chsize(fileno(IoIFP(GvIOn(tmpgv))), len) < 0)
d1483 2
a1484 1
	int tmpfd;
d1486 13
a1498 1
	if ((tmpfd = open(POPp, 0)) < 0)
d1500 4
a1503 2
	else {
	    if (chsize(tmpfd, len) < 0)
d1505 5
a1509 1
	    close(tmpfd);
d1511 1
a1512 1
#endif
d1536 1
a1536 1
    int retval;
d1547 1
d1549 4
a1552 4
	retval = IOCPARM_LEN(func);
	if (len < retval) {
	    s = Sv_Grow(argsv, retval+1);
	    SvCUR_set(argsv, retval);
a1558 3
#ifdef DOSISH
	s = (char*)(long)retval;	/* ouch */
#else
a1559 1
#endif
d1566 1
a1566 1
	retval = ioctl(fileno(IoIFP(io)), func, s);
d1571 6
a1576 2
#if defined(DOSISH) && !defined(OS2)
	DIE("fcntl is not implemented");
a1577 7
#   ifdef HAS_FCNTL
#     if defined(OS2) && defined(__EMX__)
	retval = fcntl(fileno(IoIFP(io)), func, (int)s);
#     else
	retval = fcntl(fileno(IoIFP(io)), func, s);
#     endif 
#   else
a1578 1
#   endif
d1595 1
a1595 1
	PUSHp("0 but true", 10);
d1606 1
a1606 5
    FILE *fp;

#if !defined(HAS_FLOCK) && defined(HAS_LOCKF)
#  define flock lockf_emulate_flock
#endif
d1608 1
a1608 1
#if defined(HAS_FLOCK) || defined(flock)
d1619 2
a1620 1
	value = (I32)(flock(fileno(fp), argtype) >= 0);
d1659 2
a1660 2
    IoIFP(io) = fdopen(fd, "r");	/* stdio gets confused about sockets */
    IoOFP(io) = fdopen(fd, "w");
d1663 2
a1664 2
	if (IoIFP(io)) fclose(IoIFP(io));
	if (IoOFP(io)) fclose(IoOFP(io));
d1703 2
a1704 2
    IoIFP(io1) = fdopen(fd[0], "r");
    IoOFP(io1) = fdopen(fd[0], "w");
d1706 2
a1707 2
    IoIFP(io2) = fdopen(fd[1], "r");
    IoOFP(io2) = fdopen(fd[1], "w");
d1710 2
a1711 2
	if (IoIFP(io1)) fclose(IoIFP(io1));
	if (IoOFP(io1)) fclose(IoOFP(io1));
d1713 2
a1714 2
	if (IoIFP(io2)) fclose(IoIFP(io2));
	if (IoOFP(io2)) fclose(IoOFP(io2));
d1740 1
a1740 1
    if (bind(fileno(IoIFP(io)), (struct sockaddr *)addr, len) >= 0)
d1770 1
a1770 1
    if (connect(fileno(IoIFP(io)), (struct sockaddr *)addr, len) >= 0)
d1796 1
a1796 1
    if (listen(fileno(IoIFP(io)), backlog) >= 0)
d1820 1
a1820 1
    int len = sizeof saddr;
d1839 1
a1839 1
    fd = accept(fileno(IoIFP(gstio)), (struct sockaddr *)&saddr, &len);
d1842 2
a1843 2
    IoIFP(nstio) = fdopen(fd, "r");
    IoOFP(nstio) = fdopen(fd, "w");
d1846 2
a1847 2
	if (IoIFP(nstio)) fclose(IoIFP(nstio));
	if (IoOFP(nstio)) fclose(IoOFP(nstio));
d1879 1
a1879 1
    PUSHi( shutdown(fileno(IoIFP(io)), how) >= 0 );
d1912 1
a1912 1
    int aint;
d1926 1
a1926 1
    fd = fileno(IoIFP(io));
d1933 2
a1934 2
	aint = SvCUR(sv);
	if (getsockopt(fd, lvl, optname, SvPVX(sv), &aint) < 0)
d1936 1
a1936 1
	SvCUR_set(sv,aint);
d1941 6
a1946 4
	    STRLEN len = 0;
	    char *buf = 0;
	    if (SvPOKp(sv))
		buf = SvPV(sv, len);
d1952 1
a1952 1
	    if (setsockopt(fd, lvl, optname, buf, (int)len) < 0)
d1990 1
a1990 1
    int aint;
d1997 2
a1998 1
    SvCUR_set(sv,256);
d2000 1
a2000 2
    aint = SvCUR(sv);
    fd = fileno(IoIFP(io));
d2003 1
a2003 1
	if (getsockname(fd, (struct sockaddr *)SvPVX(sv), &aint) < 0)
d2007 1
a2007 1
	if (getpeername(fd, (struct sockaddr *)SvPVX(sv), &aint) < 0)
d2009 11
d2022 7
a2028 1
    SvCUR_set(sv,aint);
d2056 1
d2066 2
a2067 5
	    if (!GvIO(tmpgv) || !IoIFP(GvIOp(tmpgv)) ||
	      Fstat(fileno(IoIFP(GvIOn(tmpgv))), &statcache) < 0) {
		max = 0;
		laststatval = -1;
	    }
d2069 1
a2069 1
	else if (laststatval < 0)
d2098 5
a2102 6
    EXTEND(SP, 13);
    if (GIMME != G_ARRAY) {
	if (max)
	    RETPUSHYES;
	else
	    RETPUSHUNDEF;
d2105 2
d2113 1
d2115 3
d2119 5
d2127 1
d2405 3
a2407 2
    char *tmps;
    if (op->op_flags & OPf_REF) {
d2409 4
a2412 2
	tmps = "";
    }
d2415 1
d2417 2
a2418 2
	fd = fileno(IoIFP(GvIOp(gv)));
    else if (isDIGIT(*tmps))
d2444 11
a2454 1
    SV *sv;
d2456 1
a2456 1
    if (op->op_flags & OPf_REF) {
d2458 1
a2458 1
	if (cGVOP->op_gv == defgv) {
d2467 2
a2468 1
	    statgv = cGVOP->op_gv;
d2473 5
a2477 2
#ifdef FILE_base
	    Fstat(fileno(IoIFP(io)), &statcache);
d2483 2
a2484 2
	    if (FILE_cnt(IoIFP(io)) <= 0) {
		i = getc(IoIFP(io));
d2486 1
a2486 1
		    (void)ungetc(i, IoIFP(io));
d2488 1
a2488 1
	    if (FILE_cnt(IoIFP(io)) <= 0)	/* null file is anything */
d2490 5
a2494 5
	    len = FILE_bufsiz(IoIFP(io));
	    s = FILE_base(IoIFP(io));
#else
	    DIE("-T and -B not implemented on filehandles");
#endif
d2506 1
d2508 1
a2509 1
      really_filename:
d2520 3
a2522 1
	Fstat(i, &statcache);
d2661 9
a2669 7
    if (same_dirent(tmps2, tmps))	/* can always rename to same name */
	anum = 1;
    else {
	if (euid || Stat(tmps2, &statbuf) < 0 || !S_ISDIR(statbuf.st_mode))
	    (void)UNLINK(tmps2);
	if (!(anum = link(tmps, tmps2)))
	    anum = UNLINK(tmps);
d2709 1
d2711 4
d2734 4
a2737 3
    char mybuf[8192];
    char *s,
	 *save_filename = filename;
a2738 1
    FILE *myfp;
d2740 4
a2743 3
    strcpy(mybuf, cmd);
    strcat(mybuf, " ");
    for (s = mybuf+strlen(mybuf); *filename; ) {
d2748 3
a2750 1
    myfp = my_popen(mybuf, "r");
d2752 3
a2754 2
	*mybuf = '\0';
	s = fgets(mybuf, sizeof mybuf, myfp);
d2757 9
a2765 1
	    for (errno = 1; errno < sys_nerr; errno++) {
d2767 1
a2767 2
		if (instr(mybuf, sys_errlist[errno]))	/* you don't see this */
		    return 0;
d2769 7
a2775 4
		char *errmsg;				/* especially if it isn't there */

		if (instr(mybuf,
		          (errmsg = strerror(errno)) ? errmsg : "NoErRoR"))
d2777 1
a2777 1
#endif
d2783 1
a2783 1
	    if (instr(mybuf, "cannot make"))
d2785 1
a2785 1
	    else if (instr(mybuf, "existing file"))
d2787 1
a2787 1
	    else if (instr(mybuf, "ile exists"))
d2789 1
a2789 1
	    else if (instr(mybuf, "non-exist"))
d2791 1
a2791 1
	    else if (instr(mybuf, "does not exist"))
d2793 1
a2793 1
	    else if (instr(mybuf, "not empty"))
d2795 1
a2795 1
	    else if (instr(mybuf, "cannot access"))
d2828 1
a2828 1
    SETi( mkdir(tmps, mode) >= 0 );
d2891 1
d2900 1
a2900 1
	    XPUSHs(sv_2mortal(newSVpv(dp->d_name, dp->d_namlen)));
d2902 4
a2905 1
	    XPUSHs(sv_2mortal(newSVpv(dp->d_name, 0)));
d2907 1
d2914 1
a2914 1
	XPUSHs(sv_2mortal(newSVpv(dp->d_name, dp->d_namlen)));
d2916 1
a2916 1
	XPUSHs(sv_2mortal(newSVpv(dp->d_name, 0)));
d2918 4
d3039 1
a3044 1
#ifdef HAS_FORK
d3051 1
a3051 1
	    sv_setiv(GvSV(tmpgv), (I32)getpid());
d3063 1
a3066 1
    I32 value;
d3068 3
a3070 8
    EXTEND(SP, 1);
#ifdef HAS_WAIT
    childpid = wait(&argflags);
    if (childpid > 0)
	pidgone(childpid, argflags);
    value = (I32)childpid;
    statusvalue = FIXSTATUS(argflags);
    PUSHi(value);
d3079 1
a3083 1
    I32 value;
a3084 1
#ifdef HAS_WAIT
d3088 2
a3089 3
    value = (I32)childpid;
    statusvalue = FIXSTATUS(argflags);
    SETi(value);
d3103 1
a3103 2
    Signal_t (*ihand)();     /* place to save signal during system() */
    Signal_t (*qhand)();     /* place to save signal during system() */
a3104 1
#if defined(HAS_FORK) && !defined(VMS) && !defined(OS2)
d3112 1
d3123 2
a3124 2
	ihand = signal(SIGINT, SIG_IGN);
	qhand = signal(SIGQUIT, SIG_IGN);
d3128 3
a3130 8
	(void)signal(SIGINT, ihand);
	(void)signal(SIGQUIT, qhand);
	statusvalue = FIXSTATUS(status);
	if (result < 0)
	    value = -1;
	else {
	    value = (I32)((unsigned int)status & 0xffff);
	}
d3133 1
a3133 1
	PUSHi(value);
d3156 1
a3156 1
    statusvalue = FIXSTATUS(value);
d3159 1
a3159 1
    PUSHi(value);
d3235 1
a3235 1
    if (pid != 0)
d3265 1
a3265 1
    if ((pgrp != 0) || (pid != 0)) {
a3266 1
    }
d3313 3
d3317 1
d3321 8
d3330 5
a3334 1
#define HZ 60
d3341 1
a3341 1
#if defined(MSDOS) || !defined(HAS_TIMES)
a3351 2
#undef HZ
#define HZ CLK_TCK
d3361 1
a3361 1
#endif /* MSDOS */
d3381 3
d3385 1
d3393 1
d3396 1
a3396 1
	char mybuf[30];
d3399 9
a3407 9
	sprintf(mybuf, "%s %s %2d %02d:%02d:%02d %d",
	    dayname[tmbuf->tm_wday],
	    monname[tmbuf->tm_mon],
	    tmbuf->tm_mday,
	    tmbuf->tm_hour,
	    tmbuf->tm_min,
	    tmbuf->tm_sec,
	    tmbuf->tm_year + 1900);
	PUSHp(mybuf, strlen(mybuf));
d3449 1
a3449 1
	pause();
d3556 1
a3556 1
	PUSHp("0 but true",10);
d3633 1
a3633 1
	statusvalue = FIXSTATUS(h_errno);
d3659 1
a3659 1
	sv_setiv(sv, (I32)hent->h_addrtype);
d3662 1
a3662 1
	sv_setiv(sv, (I32)len);
d3725 1
a3725 1
		sv_setiv(sv, (I32)nent->n_net);
d3736 1
a3736 1
	for (elem = nent->n_aliases; *elem; elem++) {
d3742 1
a3742 1
	sv_setiv(sv, (I32)nent->n_addrtype);
d3744 1
a3744 1
	sv_setiv(sv, (I32)nent->n_net);
d3795 1
a3795 1
		sv_setiv(sv, (I32)pent->p_proto);
d3806 1
a3806 1
	for (elem = pent->p_aliases; *elem; elem++) {
d3812 1
a3812 1
	sv_setiv(sv, (I32)pent->p_proto);
d3862 1
a3862 1
	int port = POPi;
d3864 3
d3878 1
a3878 1
		sv_setiv(sv, (I32)ntohs(sent->s_port));
d3880 1
a3880 1
		sv_setiv(sv, (I32)(sent->s_port));
d3893 1
a3893 1
	for (elem = sent->s_aliases; *elem; elem++) {
d3900 1
a3900 1
	sv_setiv(sv, (I32)ntohs(sent->s_port));
d3902 1
a3902 1
	sv_setiv(sv, (I32)(sent->s_port));
d4044 1
a4044 1
		sv_setiv(sv, (I32)pwent->pw_uid);
d4057 1
a4057 1
	sv_setiv(sv, (I32)pwent->pw_uid);
d4059 1
a4059 1
	sv_setiv(sv, (I32)pwent->pw_gid);
d4062 1
a4062 1
	sv_setiv(sv, (I32)pwent->pw_change);
d4065 1
a4065 1
	sv_setiv(sv, (I32)pwent->pw_quota);
d4082 3
d4091 1
a4091 1
	sv_setiv(sv, (I32)pwent->pw_expire);
d4103 1
a4103 1
#ifdef HAS_PASSWD
d4161 1
a4161 1
		sv_setiv(sv, (I32)grent->gr_gid);
d4174 1
a4174 1
	sv_setiv(sv, (I32)grent->gr_gid);
d4176 1
a4176 1
	for (elem = grent->gr_mem; *elem; elem++) {
d4240 4
a4243 3
	    if (SvGMAGICAL(*MARK) && SvSMAGICAL(*MARK) &&
	      (mg = mg_find(*MARK, 't')) && mg->mg_len & 1)
		tainted = TRUE;
d4325 36
a4360 1
#if !defined(HAS_FLOCK) && defined(HAS_LOCKF)
d4368 3
a4370 6
/*  We might need <unistd.h> because it sometimes defines the lockf()
    constants.  Unfortunately, <unistd.h> causes troubles on some mixed
    (BSD/POSIX) systems, such as SunOS 4.1.3.  We could just try including
    <unistd.h> here in this part of the file, but that might
    conflict with various other #defines and includes above, such as
	#define vfork fork above.
d4390 1
a4390 17
/* These are the flock() constants.  Since this sytems doesn't have
   flock(), the values of the constants are probably not available.
*/
# ifndef LOCK_SH
#  define LOCK_SH 1
# endif
# ifndef LOCK_EX
#  define LOCK_EX 2
# endif
# ifndef LOCK_NB
#  define LOCK_NB 4
# endif
# ifndef LOCK_UN
#  define LOCK_UN 8
# endif

int
d4396 11
d4426 1
a4426 1
	/* LOCK_UN - unlock */
d4428 1
d4438 4
d4444 2
a4445 1
#endif
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d20 8
a27 3
/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
#ifdef I_UNISTD
# include <unistd.h>
d30 5
a34 12
#ifdef HAS_SYSCALL   
#ifdef __cplusplus              
extern "C" int syscall(unsigned long,...);
#endif
#endif

#ifdef I_SYS_WAIT
# include <sys/wait.h>
#endif

#ifdef I_SYS_RESOURCE
# include <sys/resource.h>
d39 1
a39 3
# ifdef I_NETDB
#  include <netdb.h>
# endif
d49 1
d53 1
d55 1
a55 8
/* XXX Configure test needed.
   h_errno might not be a simple 'int', especially for multi-threaded
   applications, see "extern int errno in perl.h".  Creating such
   a test requires taking into account the differences between
   compiling multithreaded and singlethreaded ($ccflags et al).
   HOST_NOT_FOUND is typically defined in <netdb.h>.
*/
#if defined(HOST_NOT_FOUND) && !defined(h_errno)
a65 1
# ifdef HAS_GETPWENT
a66 1
# endif
a75 1
# ifdef HAS_GETGRENT
a76 1
# endif
d80 1
a80 5
#  if defined(_MSC_VER) || defined(__MINGW32__)
#    include <sys/utime.h>
#  else
#    include <utime.h>
#  endif
a88 14
/* Put this after #includes because fork and vfork prototypes may conflict. */
#ifndef HAS_VFORK
#   define vfork fork
#endif

/* Put this after #includes because <unistd.h> defines _XOPEN_*. */
#ifndef Sock_size_t
#  if _XOPEN_VERSION >= 5 || defined(_XOPEN_SOURCE_EXTENDED) || defined(__GLIBC__)
#    define Sock_size_t Size_t
#  else
#    define Sock_size_t int
#  endif
#endif

a91 64

#ifdef HAS_CHSIZE
# ifdef my_chsize  /* Probably #defined to Perl_my_chsize in embed.h */
#   undef my_chsize
# endif
# define my_chsize PerlLIO_chsize
#endif

#ifdef HAS_FLOCK
#  define FLOCK flock
#else /* no flock() */

   /* fcntl.h might not have been included, even if it exists, because
      the current Configure only sets I_FCNTL if it's needed to pick up
      the *_OK constants.  Make sure it has been included before testing
      the fcntl() locking constants. */
#  if defined(HAS_FCNTL) && !defined(I_FCNTL)
#    include <fcntl.h>
#  endif

#  if defined(HAS_FCNTL) && defined(F_SETLK) && defined (F_SETLKW)
#    define FLOCK fcntl_emulate_flock
#    define FCNTL_EMULATE_FLOCK
#  else /* no flock() or fcntl(F_SETLK,...) */
#    ifdef HAS_LOCKF
#      define FLOCK lockf_emulate_flock
#      define LOCKF_EMULATE_FLOCK
#    endif /* lockf */
#  endif /* no flock() or fcntl(F_SETLK,...) */

#  ifdef FLOCK
     static int FLOCK _((int, int));

    /*
     * These are the flock() constants.  Since this sytems doesn't have
     * flock(), the values of the constants are probably not available.
     */
#    ifndef LOCK_SH
#      define LOCK_SH 1
#    endif
#    ifndef LOCK_EX
#      define LOCK_EX 2
#    endif
#    ifndef LOCK_NB
#      define LOCK_NB 4
#    endif
#    ifndef LOCK_UN
#      define LOCK_UN 8
#    endif
#  endif /* emulating flock() */

#endif /* no flock() */

#ifndef MAXPATHLEN
#  ifdef PATH_MAX
#    define MAXPATHLEN PATH_MAX
#  else
#    define MAXPATHLEN 1024
#  endif
#endif

#define ZBTLEN 10
static char zero_but_true[ZBTLEN + 1] = "0 but true";

d96 3
a98 6
    djSP; dTARGET;
    PerlIO *fp;
    STRLEN n_a;
    char *tmps = POPpx;
    I32 gimme = GIMME_V;

d100 1
a100 1
    fp = PerlProc_popen(tmps, "r");
d102 2
a103 8
	if (gimme == G_VOID) {
	    char tmpbuf[256];
	    while (PerlIO_read(fp, tmpbuf, sizeof tmpbuf) > 0)
		/*SUPPRESS 530*/
		;
	}
	else if (gimme == G_SCALAR) {
	    sv_setpv(TARG, "");	/* note that this preserves previous buffer */
a107 1
	    SvTAINTED_on(TARG);
d113 1
a113 1
		sv = NEWSV(56, 79);
a122 1
		SvTAINTED_on(sv);
d125 1
a125 2
	STATUS_NATIVE_SET(PerlProc_pclose(fp));
	TAINT;		/* "I believe that this is not gratuitous!" */
d128 2
a129 2
	STATUS_NATIVE_SET(-1);
	if (gimme == G_SCALAR)
d141 2
a142 13
#ifndef VMS
    if (PL_tainting) {
	/*
	 * The external globbing program may use things we can't control,
	 * so for security reasons we must assume the worst.
	 */
	TAINT;
	taint_proper(no_security, "glob");
    }
#endif /* !VMS */

    SAVESPTR(PL_last_in_gv);	/* We don't want this to be permanent. */
    PL_last_in_gv = (GV*)*PL_stack_sp--;
d144 2
a145 2
    SAVESPTR(PL_rs);		/* This is not permanent, either. */
    PL_rs = sv_2mortal(newSVpv("", 1));
d148 1
a148 1
    *SvPVX(PL_rs) = '\n';
d150 1
a150 1
#endif	/* !DOSISH */
a156 1
#if 0		/* XXX never used! */
d159 1
a159 2
    STRLEN n_a;
    PL_last_in_gv = gv_fetchpv(SvPVx(GvSV((GV*)(*PL_stack_sp--)), n_a), TRUE,SVt_PVIO);
a161 1
#endif
d165 1
a165 1
    PL_last_in_gv = cGVOP->op_gv;
d171 1
a171 1
    djSP; dMARK;
a172 1
    STRLEN n_a;
d175 2
a176 2
	do_join(TARG, &PL_sv_no, MARK, SP);
	tmps = SvPV(TARG, n_a);
d180 1
a180 1
	tmps = SvPV(TOPs, n_a);
d183 1
a183 1
  	SV *error = ERRSV;
d187 1
a187 1
	tmps = SvPV(error, n_a);
d197 1
a197 1
    djSP; dMARK;
a198 3
    SV *tmpsv = Nullsv;
    char *pat = "%s";
    STRLEN n_a;
d201 2
a202 2
	do_join(TARG, &PL_sv_no, MARK, SP);
	tmps = SvPV(TARG, n_a);
d206 1
a206 2
	tmpsv = TOPs;
	tmps = SvROK(tmpsv) ? Nullch : SvPV(tmpsv, n_a);
d209 1
a209 1
  	SV *error = ERRSV;
d211 3
a213 27
	if(tmpsv ? SvROK(tmpsv) : SvROK(error)) {
	    if(tmpsv)
		SvSetSV(error,tmpsv);
	    else if(sv_isobject(error)) {
		HV *stash = SvSTASH(SvRV(error));
		GV *gv = gv_fetchmethod(stash, "PROPAGATE");
		if (gv) {
		    SV *file = sv_2mortal(newSVsv(GvSV(PL_curcop->cop_filegv)));
		    SV *line = sv_2mortal(newSViv(PL_curcop->cop_line));
		    EXTEND(SP, 3);
		    PUSHMARK(SP);
		    PUSHs(error);
		    PUSHs(file);
 		    PUSHs(line);
		    PUTBACK;
		    perl_call_sv((SV*)GvCV(gv),
				 G_SCALAR|G_EVAL|G_KEEPERR);
		    sv_setsv(error,*PL_stack_sp--);
		}
	    }
	    pat = Nullch;
	}
	else {
	    if (SvPOK(error) && SvCUR(error))
		sv_catpv(error, "\t...propagated");
	    tmps = SvPV(error, n_a);
	}
d217 1
a217 1
    DIE(pat, tmps);
d224 1
a224 1
    djSP; dTARGET;
d232 3
a234 1
    if (!isGV(TOPs))
a235 2
    if (MAXARG <= 1)
	sv = GvSV(TOPs);
a236 4
    if (!isGV(gv))
	DIE(no_usym, "filehandle");
    if (GvIOp(gv))
	IoFLAGS(GvIOp(gv)) &= ~IOf_UNTAINT;
d238 5
a242 3
    if (do_open(gv, tmps, len, FALSE, O_RDONLY, 0, Nullfp))
	PUSHi( (I32)PL_forkprocess );
    else if (PL_forkprocess == 0)		/* we are a new child */
d251 1
a251 1
    djSP;
a252 1
    MAGIC *mg;
d255 1
a255 1
	gv = PL_defoutgv;
a257 11

    if (mg = SvTIED_mg((SV*)gv, 'q')) {
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)gv, mg));
	PUTBACK;
	ENTER;
	perl_call_method("CLOSE", G_SCALAR);
	LEAVE;
	SPAGAIN;
	RETURN;
    }
d259 1
a259 1
    PUSHs(boolSV(do_close(gv, TRUE)));
d265 1
a265 1
    djSP;
d289 1
a289 1
    if (PerlProc_pipe(fd) < 0)
d292 2
a293 2
    IoIFP(rstio) = PerlIO_fdopen(fd[0], "r");
    IoOFP(wstio) = PerlIO_fdopen(fd[1], "w");
d299 4
a302 4
	if (IoIFP(rstio)) PerlIO_close(IoIFP(rstio));
	else PerlLIO_close(fd[0]);
	if (IoOFP(wstio)) PerlIO_close(IoOFP(wstio));
	else PerlLIO_close(fd[1]);
d305 1
a305 4
#if defined(HAS_FCNTL) && defined(F_SETFD)
    fcntl(fd[0],F_SETFD,fd[0] > PL_maxsysfd);	/* ensure close-on-exec */
    fcntl(fd[1],F_SETFD,fd[1] > PL_maxsysfd);	/* ensure close-on-exec */
#endif
d317 1
a317 1
    djSP; dTARGET;
d320 1
a320 1
    PerlIO *fp;
d326 1
a326 1
    PUSHi(PerlIO_fileno(fp));
d332 1
a332 1
    djSP; dTARGET;
d337 2
a338 2
	anum = PerlLIO_umask(0);
	(void)PerlLIO_umask(anum);
d341 1
a341 1
	anum = PerlLIO_umask(POPi);
d345 1
a345 6
    /* Only DIE if trying to restrict permissions on `user' (self).
     * Otherwise it's harmless and more useful to just return undef
     * since 'group' and 'other' concepts probably don't exist here. */
    if (MAXARG >= 1 && (POPi & 0700))
	DIE("umask not implemented");
    XPUSHs(&PL_sv_undef);
d352 1
a352 1
    djSP;
d355 1
a355 1
    PerlIO *fp;
d364 7
d372 2
a373 2

    if (do_binmode(fp,IoTYPE(io),TRUE)) 
d377 4
a382 1

d385 1
a385 2
    djSP;
    dMARK;
d389 1
d391 2
a392 1
    I32 markoff = MARK - PL_stack_base;
a393 2
    int how = 'P';
    U32 items;
d395 29
a423 47
    varsv = *++MARK;
    switch(SvTYPE(varsv)) {
	case SVt_PVHV:
	    methname = "TIEHASH";
	    break;
	case SVt_PVAV:
	    methname = "TIEARRAY";
	    break;
	case SVt_PVGV:
	    methname = "TIEHANDLE";
	    how = 'q';
	    break;
	default:
	    methname = "TIESCALAR";
	    how = 'q';
	    break;
    }
    items = SP - MARK++;
    if (sv_isobject(*MARK)) {
	ENTER;
	PUSHSTACKi(PERLSI_MAGIC);
	PUSHMARK(SP);
	EXTEND(SP,items);
	while (items--)
	    PUSHs(*MARK++);
	PUTBACK;
	perl_call_method(methname, G_SCALAR);
    } 
    else {
	/* Not clear why we don't call perl_call_method here too.
	 * perhaps to get different error message ?
	 */
	stash = gv_stashsv(*MARK, FALSE);
	if (!stash || !(gv = gv_fetchmethod(stash, methname))) {
	    STRLEN n_a;
	    DIE("Can't locate object method \"%s\" via package \"%s\"",
		 methname, SvPV(*MARK,n_a));                   
	}
	ENTER;
	PUSHSTACKi(PERLSI_MAGIC);
	PUSHMARK(SP);
	EXTEND(SP,items);
	while (items--)
	    PUSHs(*MARK++);
	PUTBACK;
	perl_call_sv((SV*)GvCV(gv), G_SCALAR);
    }
a426 1
    POPSTACK;
d428 8
a435 2
	sv_unmagic(varsv, how);
	sv_magic(varsv, (SvRV(sv) == varsv ? Nullsv : sv), how, Nullch, 0);
d438 1
a438 1
    SP = PL_stack_base + markoff;
d445 6
a450 15
    djSP;
    SV *sv = POPs;
    char how = (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV) ? 'P' : 'q';

    if (PL_dowarn) {
        MAGIC *mg;
        if (mg = SvTIED_mg(sv, how)) {
            if (mg->mg_obj && SvREFCNT(SvRV(mg->mg_obj)) > 1)  
		warn("untie attempted while %lu inner references still exist",
			(unsigned long)SvREFCNT(SvRV(mg->mg_obj)) - 1 ) ;
        }
    }
 
    sv_unmagic(sv, how);
    RETPUSHYES;
d455 3
a457 4
    djSP;
    SV *sv = POPs;
    char how = (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV) ? 'P' : 'q';
    MAGIC *mg;
d459 11
a469 6
    if (mg = SvTIED_mg(sv, how)) {
	SV *osv = SvTIED_obj(sv, mg);
	if (osv == mg->mg_obj)
	    osv = sv_mortalcopy(osv);
	PUSHs(osv);
	RETURN;
d471 1
d477 1
a477 1
    djSP;
d482 1
d487 1
a487 1
    sv = sv_mortalcopy(&PL_sv_no);
d490 1
a490 1
    if (!stash || !(gv = gv_fetchmethod(stash, "TIEHASH"))) {
d494 1
a494 1
	if (!(gv = gv_fetchmethod(stash, "TIEHASH")))
d498 5
d504 4
a507 1
    PUSHMARK(SP);
d509 1
a509 1
    EXTEND(SP, 5);
d517 1
d519 3
a521 1
    perl_call_sv((SV*)GvCV(gv), G_SCALAR);
d525 5
a529 2
	SP--;
	PUSHMARK(SP);
d534 1
d536 3
a538 1
	perl_call_sv((SV*)GvCV(gv), G_SCALAR);
d542 1
a542 2
    if (sv_isobject(TOPs)) {
	sv_unmagic((SV *) hv, 'P');            
a543 1
    }
d555 1
a555 1
    djSP; dTARGET;
a567 1
    STRLEN n_a;
a589 1
/* little endians can use vecs directly */
d591 2
a592 7
#  if SELECT_MIN_BITS > 1
    /* If SELECT_MIN_BITS is greater than one we most probably will want
     * to align the sizes with SELECT_MIN_BITS/8 because for example
     * in many little-endian (Intel, Alpha) systems (Linux, OS/2, Digital
     * UNIX, Solaris, NeXT) the smallest quantum select() operates on
     * (sets bit) is 32 bits.  */
    growsize = maxlen + (SELECT_MIN_BITS/8 - (maxlen % (SELECT_MIN_BITS/8)));
d594 1
a594 1
    growsize = sizeof(fd_set);
d630 1
a630 1
	    SvPV_force(sv,n_a);	/* force string conversion */
d653 1
a653 1
    nfound = PerlSock_select(
d678 1
a678 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d688 2
a689 1
setdefout(GV *gv)
a690 1
    dTHR;
d693 3
a695 3
    if (PL_defoutgv)
	SvREFCNT_dec(PL_defoutgv);
    PL_defoutgv = gv;
d700 1
a700 1
    djSP; dTARGET;
d704 1
a704 1
    newdefout = (PL_op->op_private > 0) ? ((GV *) POPs) : (GV *) NULL;
d706 1
a706 1
    egv = GvEGV(PL_defoutgv);
d708 1
a708 1
	egv = PL_defoutgv;
d711 1
a711 1
	XPUSHs(&PL_sv_undef);
d713 6
a718 8
	GV **gvp = (GV**)hv_fetch(hv, GvNAME(egv), GvNAMELEN(egv), FALSE);
	if (gvp && *gvp == egv) {
	    gv_efullname3(TARG, PL_defoutgv, Nullch);
	    XPUSHTARG;
	}
	else {
	    XPUSHs(sv_2mortal(newRV((SV*)egv)));
	}
d732 1
a732 1
    djSP; dTARGET;
a733 1
    MAGIC *mg;
d736 1
a736 1
	gv = PL_stdingv;
d740 1
a740 15
	gv = PL_argvgv;

    if (mg = SvTIED_mg((SV*)gv, 'q')) {
	I32 gimme = GIMME_V;
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)gv, mg));
	PUTBACK;
	ENTER;
	perl_call_method("GETC", gimme);
	LEAVE;
	SPAGAIN;
	if (gimme == G_SCALAR)
	    SvSetMagicSV_nosteal(TARG, TOPs);
	RETURN;
    }
d743 1
a743 1
    TAINT;
d745 1
a745 1
    *SvPVX(TARG) = PerlIO_getc(IoIFP(GvIOp(gv))); /* should never be EOF */
d755 5
a759 2
STATIC OP *
doform(CV *cv, GV *gv, OP *retop)
d761 2
a762 3
    dTHR;
    register PERL_CONTEXT *cx;
    I32 gimme = GIMME_V;
d770 1
a770 1
    PUSHBLOCK(cx, CXt_SUB, PL_stack_sp);
d772 2
a773 2
    SAVESPTR(PL_curpad);
    PL_curpad = AvARRAY((AV*)svp[1]);
d781 1
a781 1
    djSP;
d788 1
a788 1
	gv = PL_defoutgv;
d792 1
a792 1
	    gv = PL_defoutgv;
d805 1
d809 1
a809 1
	    gv_efullname3(tmpsv, fgv, Nullch);
d814 1
a814 2
    if (CvCLONE(cv))
	cv = (CV*)sv_2mortal((SV*)cv_clone(cv));
d816 1
a816 2
    IoFLAGS(io) &= ~IOf_DIDTOP;
    return doform(cv,gv,PL_op->op_next);
d821 1
a821 1
    djSP;
d824 2
a825 2
    PerlIO *ofp = IoOFP(io);
    PerlIO *fp;
d828 1
a828 1
    register PERL_CONTEXT *cx;
d830 4
a833 4
    DEBUG_f(PerlIO_printf(Perl_debug_log, "left=%ld, todo=%ld\n",
	  (long)IoLINES_LEFT(io), (long)FmLINES(PL_formtarget)));
    if (IoLINES_LEFT(io) < FmLINES(PL_formtarget) &&
	PL_formtarget != PL_toptarget)
d839 1
a839 1
	    SV *topname;
d844 2
a845 2
		topname = sv_2mortal(newSVpvf("%s_TOP", IoFMT_NAME(io)));
		topgv = gv_fetchpv(SvPVX(topname), FALSE, SVt_PVFM);
d848 1
a848 1
		    IoTOP_NAME(io) = savepv(SvPVX(topname));
d861 1
a861 1
	    char *s = SvPVX(PL_formtarget);
d871 3
a873 3
		PerlIO_write(ofp, SvPVX(PL_formtarget), s - SvPVX(PL_formtarget));
		sv_chop(PL_formtarget, s);
		FmLINES(PL_formtarget) -= IoLINES_LEFT(io);
d877 1
a877 1
	    PerlIO_write(ofp, SvPVX(PL_formfeed), SvCUR(PL_formfeed));
d880 1
a880 1
	PL_formtarget = PL_toptarget;
d888 1
a888 1
	    gv_efullname3(tmpsv, fgv, Nullch);
d891 1
a891 3
	if (CvCLONE(cv))
	    cv = (CV*)sv_2mortal((SV*)cv_clone(cv));
	return doform(cv,gv,PL_op);
d895 1
a895 1
    POPBLOCK(cx,PL_curpm);
d901 1
a901 1
	if (PL_dowarn) {
d907 1
a907 1
	PUSHs(&PL_sv_no);
d910 2
a911 2
	if ((IoLINES_LEFT(io) -= FmLINES(PL_formtarget)) < 0) {
	    if (PL_dowarn)
d914 3
a916 3
	if (!PerlIO_write(ofp, SvPVX(PL_formtarget), SvCUR(PL_formtarget)) ||
		PerlIO_error(fp))
	    PUSHs(&PL_sv_no);
d918 3
a920 3
	    FmLINES(PL_formtarget) = 0;
	    SvCUR_set(PL_formtarget, 0);
	    *SvEND(PL_formtarget) = '\0';
d922 2
a923 2
		(void)PerlIO_flush(fp);
	    PUSHs(&PL_sv_yes);
d926 1
a926 1
    PL_formtarget = PL_bodytarget;
d933 1
a933 1
    djSP; dMARK; dORIGMARK;
d936 2
a937 4
    PerlIO *fp;
    SV *sv;
    MAGIC *mg;
    STRLEN n_a;
d939 1
a939 1
    if (PL_op->op_flags & OPf_STACKED)
d942 1
a942 23
	gv = PL_defoutgv;

    if (mg = SvTIED_mg((SV*)gv, 'q')) {
	if (MARK == ORIGMARK) {
	    MEXTEND(SP, 1);
	    ++MARK;
	    Move(MARK, MARK + 1, (SP - MARK) + 1, SV*);
	    ++SP;
	}
	PUSHMARK(MARK - 1);
	*MARK = SvTIED_obj((SV*)gv, mg);
	PUTBACK;
	ENTER;
	perl_call_method("PRINTF", G_SCALAR);
	LEAVE;
	SPAGAIN;
	MARK = ORIGMARK + 1;
	*MARK = *SP;
	SP = MARK;
	RETURN;
    }

    sv = NEWSV(0,0);
d944 3
a946 3
	if (PL_dowarn) {
	    gv_fullname3(sv, gv, Nullch);
	    warn("Filehandle %s never opened", SvPV(sv,n_a));
d952 2
a953 2
	if (PL_dowarn)  {
	    gv_fullname3(sv, gv, Nullch);
d955 1
a955 1
		warn("Filehandle %s opened only for input", SvPV(sv,n_a));
d957 1
a957 1
		warn("printf on closed filehandle %s", SvPV(sv,n_a));
a962 6
#ifdef USE_LOCALE_NUMERIC
	if (PL_op->op_private & OPpLOCALE)
	    SET_NUMERIC_LOCAL();
	else
	    SET_NUMERIC_STANDARD();
#endif
d968 1
a968 1
	    if (PerlIO_flush(fp) == EOF)
d973 1
a973 1
    PUSHs(&PL_sv_yes);
d979 1
a979 1
    PUSHs(&PL_sv_undef);
d985 1
a985 1
    djSP;
d1003 1
a1003 1
	PUSHs(&PL_sv_yes);
d1006 1
a1006 1
	PUSHs(&PL_sv_undef);
d1013 1
a1013 1
    djSP; dMARK; dORIGMARK; dTARGET;
d1018 2
a1019 2
    SSize_t length;
    Sock_size_t bufsize;
a1021 1
    MAGIC *mg;
a1023 17
    if ((PL_op->op_type == OP_READ || PL_op->op_type == OP_SYSREAD) &&
	(mg = SvTIED_mg((SV*)gv, 'q')))
    {
	SV *sv;
	
	PUSHMARK(MARK-1);
	*MARK = SvTIED_obj((SV*)gv, mg);
	ENTER;
	perl_call_method("READ", G_SCALAR);
	LEAVE;
	SPAGAIN;
	sv = POPs;
	SP = ORIGMARK;
	PUSHs(sv);
	RETURN;
    }

a1026 2
    if (! SvOK(bufsv))
	sv_setpvn(bufsv, "", 0);
d1040 2
a1041 7
    if (PL_op->op_type == OP_RECV) {
	char namebuf[MAXPATHLEN];
#if (defined(VMS_DO_SOCKETS) && defined(DECCRTL_SOCKETS)) || defined(MPE)
	bufsize = sizeof (struct sockaddr_in);
#else
	bufsize = sizeof namebuf;
#endif
d1043 2
a1044 3
	/* 'offset' means 'flags' here */
	length = PerlSock_recvfrom(PerlIO_fileno(IoIFP(io)), buffer, length, offset,
			  (struct sockaddr *)namebuf, &bufsize);
d1051 2
a1052 3
	/* This should not be marked tainted if the fp is marked clean */
	if (!(IoFLAGS(io) & IOf_UNTAINT))
	    SvTAINTED_on(bufsv);
d1054 1
a1054 1
	sv_setpvn(TARG, namebuf, bufsize);
d1059 1
a1059 1
    if (PL_op->op_type == OP_RECV)
a1061 6
    if (offset < 0) {
	if (-offset > blen)
	    DIE("Offset outside string");
	offset += blen;
    }
    bufsize = SvCUR(bufsv);
d1063 2
a1064 15
    if (offset > bufsize) { /* Zero any newly allocated space */
    	Zero(buffer+bufsize, offset-bufsize, char);
    }
    if (PL_op->op_type == OP_SYSREAD) {
#ifdef PERL_SOCK_SYSREAD_IS_RECV
	if (IoTYPE(io) == 's') {
	    length = PerlSock_recv(PerlIO_fileno(IoIFP(io)),
				   buffer+offset, length, 0);
	}
	else
#endif
	{
	    length = PerlLIO_read(PerlIO_fileno(IoIFP(io)),
				  buffer+offset, length);
	}
d1069 3
a1071 8
	char namebuf[MAXPATHLEN];
#if defined(VMS_DO_SOCKETS) && defined(DECCRTL_SOCKETS)
	bufsize = sizeof (struct sockaddr_in);
#else
	bufsize = sizeof namebuf;
#endif
	length = PerlSock_recvfrom(PerlIO_fileno(IoIFP(io)), buffer+offset, length, 0,
			  (struct sockaddr *)namebuf, &bufsize);
d1075 1
a1075 6
    {
	length = PerlIO_read(IoIFP(io), buffer+offset, length);
	/* fread() returns 0 on both error and EOF */
	if (length == 0 && PerlIO_error(IoIFP(io)))
	    length = -1;
    }
d1082 2
a1083 3
    /* This should not be marked tainted if the fp is marked clean */
    if (!(IoFLAGS(io) & IOf_UNTAINT))
	SvTAINTED_on(bufsv);
a1094 9
    djSP;
    int items = (SP - PL_stack_base) - TOPMARK;
    if (items == 2) {
	SV *sv;
        EXTEND(SP, 1);
	sv = sv_2mortal(newSViv(sv_len(*SP)));
        PUSHs(sv);
        PUTBACK;
    }
d1100 1
a1100 1
    djSP; dMARK; dORIGMARK; dTARGET;
a1107 1
    MAGIC *mg;
a1109 14
    if (PL_op->op_type == OP_SYSWRITE && (mg = SvTIED_mg((SV*)gv, 'q'))) {
	SV *sv;
	
	PUSHMARK(MARK-1);
	*MARK = SvTIED_obj((SV*)gv, mg);
	ENTER;
	perl_call_method("WRITE", G_SCALAR);
	LEAVE;
	SPAGAIN;
	sv = POPs;
	SP = ORIGMARK;
	PUSHs(sv);
	RETURN;
    }
d1121 2
a1122 2
	if (PL_dowarn) {
	    if (PL_op->op_type == OP_SYSWRITE)
d1128 2
a1129 2
    else if (PL_op->op_type == OP_SYSWRITE) {
	if (MARK < SP) {
d1131 1
a1131 7
	    if (offset < 0) {
		if (-offset > blen)
		    DIE("Offset outside string");
		offset += blen;
	    } else if (offset >= blen && blen > 0)
		DIE("Offset outside string");
	} else
d1135 1
a1135 11
#ifdef PERL_SOCK_SYSWRITE_IS_SEND
	if (IoTYPE(io) == 's') {
	    length = PerlSock_send(PerlIO_fileno(IoIFP(io)),
				   buffer+offset, length, 0);
	}
	else
#endif
	{
	    length = PerlLIO_write(PerlIO_fileno(IoIFP(io)),
				   buffer+offset, length);
	}
d1142 1
a1142 1
	length = PerlSock_sendto(PerlIO_fileno(IoIFP(io)), buffer, blen, length,
d1146 1
a1146 2
	length = PerlSock_send(PerlIO_fileno(IoIFP(io)), buffer, blen, length);

d1169 1
a1169 1
    djSP;
d1173 1
a1173 1
	gv = PL_last_in_gv;
d1175 2
a1176 2
	gv = PL_last_in_gv = (GV*)POPs;
    PUSHs(boolSV(!gv || do_eof(gv)));
d1182 1
a1182 1
    djSP; dTARGET;
d1186 1
a1186 1
	gv = PL_last_in_gv;
d1188 1
a1188 1
	gv = PL_last_in_gv = (GV*)POPs;
d1195 1
a1195 6
    return pp_sysseek(ARGS);
}

PP(pp_sysseek)
{
    djSP;
d1200 2
a1201 9
    gv = PL_last_in_gv = (GV*)POPs;
    if (PL_op->op_type == OP_SEEK)
	PUSHs(boolSV(do_seek(gv, offset, whence)));
    else {
	long n = do_sysseek(gv, offset, whence);
	PUSHs((n < 0) ? &PL_sv_undef
	      : sv_2mortal(n ? newSViv((IV)n)
			   : newSVpv(zero_but_true, ZBTLEN)));
    }
d1207 1
a1207 1
    djSP;
a1210 1
    STRLEN n_a;
d1214 12
a1225 4
    if (PL_op->op_flags & OPf_SPECIAL) {
	tmpgv = gv_fetchpv(POPpx, FALSE, SVt_PVIO);
    do_ftruncate:
	TAINT_PROPER("truncate");
d1227 1
a1227 5
#ifdef HAS_TRUNCATE
	  ftruncate(PerlIO_fileno(IoIFP(GvIOn(tmpgv))), len) < 0)
#else 
	  my_chsize(PerlIO_fileno(IoIFP(GvIOn(tmpgv))), len) < 0)
#endif
d1231 1
a1231 11
	SV *sv = POPs;
	char *name;

	if (SvTYPE(sv) == SVt_PVGV) {
	    tmpgv = (GV*)sv;		/* *main::FRED for example */
	    goto do_ftruncate;
	}
	else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVGV) {
	    tmpgv = (GV*) SvRV(sv);	/* \*main::FRED for example */
	    goto do_ftruncate;
	}
d1233 1
a1233 4
	name = SvPV(sv, n_a);
	TAINT_PROPER("truncate");
#ifdef HAS_TRUNCATE
	if (truncate(name, len) < 0)
d1235 2
a1236 4
#else
	{
	    int tmpfd;
	    if ((tmpfd = PerlLIO_open(name, O_RDWR)) < 0)
d1238 1
a1238 5
	    else {
		if (my_chsize(tmpfd, len) < 0)
		    result = 0;
		PerlLIO_close(tmpfd);
	    }
d1240 1
a1241 1
    }
d1260 1
a1260 1
    djSP; dTARGET;
d1263 1
a1263 1
    int optype = PL_op->op_type;
d1265 1
a1265 1
    IV retval;
a1275 1
	STRLEN need;
d1277 4
a1280 4
	need = IOCPARM_LEN(func);
	if (len < need) {
	    s = Sv_Grow(argsv, need + 1);
	    SvCUR_set(argsv, need);
d1287 3
d1291 1
d1298 1
a1298 1
	retval = PerlLIO_ioctl(PerlIO_fileno(IoIFP(io)), func, s);
d1303 2
a1304 6
#ifdef HAS_FCNTL
#if defined(OS2) && defined(__EMX__)
	retval = fcntl(PerlIO_fileno(IoIFP(io)), func, (int)s);
#else
	retval = fcntl(PerlIO_fileno(IoIFP(io)), func, s);
#endif 
d1306 7
d1314 1
d1331 1
a1331 1
	PUSHp(zero_but_true, ZBTLEN);
d1338 1
a1338 1
    djSP; dTARGET;
d1342 1
a1342 1
    PerlIO *fp;
d1344 5
a1348 1
#ifdef FLOCK
d1351 1
a1351 1
	gv = PL_last_in_gv;
d1359 1
a1359 2
	(void)PerlIO_flush(fp);
	value = (I32)(PerlLIO_flock(PerlIO_fileno(fp), argtype) >= 0);
d1374 1
a1374 1
    djSP;
d1395 1
a1395 1
    fd = PerlSock_socket(domain, type, protocol);
d1398 2
a1399 2
    IoIFP(io) = PerlIO_fdopen(fd, "r");	/* stdio gets confused about sockets */
    IoOFP(io) = PerlIO_fdopen(fd, "w");
d1402 3
a1404 3
	if (IoIFP(io)) PerlIO_close(IoIFP(io));
	if (IoOFP(io)) PerlIO_close(IoOFP(io));
	if (!IoIFP(io) && !IoOFP(io)) PerlLIO_close(fd);
d1416 1
a1416 1
    djSP;
d1440 1
a1440 1
    if (PerlSock_socketpair(domain, type, protocol, fd) < 0)
d1442 2
a1443 2
    IoIFP(io1) = PerlIO_fdopen(fd[0], "r");
    IoOFP(io1) = PerlIO_fdopen(fd[0], "w");
d1445 2
a1446 2
    IoIFP(io2) = PerlIO_fdopen(fd[1], "r");
    IoOFP(io2) = PerlIO_fdopen(fd[1], "w");
d1449 6
a1454 6
	if (IoIFP(io1)) PerlIO_close(IoIFP(io1));
	if (IoOFP(io1)) PerlIO_close(IoOFP(io1));
	if (!IoIFP(io1) && !IoOFP(io1)) PerlLIO_close(fd[0]);
	if (IoIFP(io2)) PerlIO_close(IoIFP(io2));
	if (IoOFP(io2)) PerlIO_close(IoOFP(io2));
	if (!IoIFP(io2) && !IoOFP(io2)) PerlLIO_close(fd[1]);
d1466 1
a1466 1
    djSP;
a1467 4
#ifdef MPE /* Requires PRIV mode to bind() to ports < 1024 */
    extern GETPRIVMODE();
    extern GETUSERMODE();
#endif
a1472 4
    int bind_ok = 0;
#ifdef MPE
    int mpeprivmode = 0;
#endif
d1479 1
a1479 22
#ifdef MPE /* Deal with MPE bind() peculiarities */
    if (((struct sockaddr *)addr)->sa_family == AF_INET) {
        /* The address *MUST* stupidly be zero. */
        ((struct sockaddr_in *)addr)->sin_addr.s_addr = INADDR_ANY;
        /* PRIV mode is required to bind() to ports < 1024. */
        if (((struct sockaddr_in *)addr)->sin_port < 1024 &&
            ((struct sockaddr_in *)addr)->sin_port > 0) {
            GETPRIVMODE(); /* If this fails, we are aborted by MPE/iX. */
	    mpeprivmode = 1;
	}
    }
#endif /* MPE */
    if (PerlSock_bind(PerlIO_fileno(IoIFP(io)),
		      (struct sockaddr *)addr, len) >= 0)
	bind_ok = 1;

#ifdef MPE /* Switch back to USER mode */
    if (mpeprivmode)
	GETUSERMODE();
#endif /* MPE */

    if (bind_ok)
d1485 1
a1485 1
    if (PL_dowarn)
d1496 1
a1496 1
    djSP;
d1509 1
a1509 1
    if (PerlSock_connect(PerlIO_fileno(IoIFP(io)), (struct sockaddr *)addr, len) >= 0)
d1515 1
a1515 1
    if (PL_dowarn)
d1526 1
a1526 1
    djSP;
d1535 1
a1535 1
    if (PerlSock_listen(PerlIO_fileno(IoIFP(io)), backlog) >= 0)
d1541 1
a1541 1
    if (PL_dowarn)
d1552 1
a1552 1
    djSP; dTARGET;
d1559 1
a1559 1
    Sock_size_t len = sizeof saddr;
d1578 1
a1578 1
    fd = PerlSock_accept(PerlIO_fileno(IoIFP(gstio)), (struct sockaddr *)&saddr, &len);
d1581 2
a1582 2
    IoIFP(nstio) = PerlIO_fdopen(fd, "r");
    IoOFP(nstio) = PerlIO_fdopen(fd, "w");
d1585 3
a1587 3
	if (IoIFP(nstio)) PerlIO_close(IoIFP(nstio));
	if (IoOFP(nstio)) PerlIO_close(IoOFP(nstio));
	if (!IoIFP(nstio) && !IoOFP(nstio)) PerlLIO_close(fd);
d1595 1
a1595 1
    if (PL_dowarn)
d1609 1
a1609 1
    djSP; dTARGET;
d1618 1
a1618 1
    PUSHi( PerlSock_shutdown(PerlIO_fileno(IoIFP(io)), how) >= 0 );
d1622 1
a1622 1
    if (PL_dowarn)
d1642 1
a1642 1
    djSP;
d1644 1
a1644 1
    int optype = PL_op->op_type;
d1651 1
a1651 1
    Sock_size_t len;
d1665 1
a1665 1
    fd = PerlIO_fileno(IoIFP(io));
d1672 2
a1673 2
	len = SvCUR(sv);
	if (PerlSock_getsockopt(fd, lvl, optname, SvPVX(sv), &len) < 0)
d1675 1
a1675 1
	SvCUR_set(sv, len);
d1680 5
a1684 8
	    char *buf;
	    int aint;
	    if (SvPOKp(sv)) {
		STRLEN l;
		buf = SvPV(sv, l);
		len = l;
	    }
	    else {
d1689 1
a1689 1
	    if (PerlSock_setsockopt(fd, lvl, optname, buf, len) < 0)
d1691 1
a1691 1
	    PUSHs(&PL_sv_yes);
d1698 1
a1698 1
    if (PL_dowarn)
d1720 1
a1720 1
    djSP;
d1722 1
a1722 1
    int optype = PL_op->op_type;
d1727 1
a1727 1
    Sock_size_t len;
d1734 1
a1734 2
    len = 256;
    SvCUR_set(sv, len);
d1736 2
a1737 1
    fd = PerlIO_fileno(IoIFP(io));
d1740 1
a1740 1
	if (PerlSock_getsockname(fd, (struct sockaddr *)SvPVX(sv), &len) < 0)
d1744 1
a1744 1
	if (PerlSock_getpeername(fd, (struct sockaddr *)SvPVX(sv), &len) < 0)
a1745 11
#if defined(VMS_DO_SOCKETS) && defined (DECCRTL_SOCKETS)
	{
	    static const char nowhere[] = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
	    /* If the call succeeded, make sure we don't have a zeroed port/addr */
	    if (((struct sockaddr *)SvPVX(sv))->sa_family == AF_INET &&
		!memcmp((char *)SvPVX(sv) + sizeof(u_short), nowhere,
			sizeof(u_short) + sizeof(struct in_addr))) {
		goto nuts2;	    
	    }
	}
#endif
d1748 1
a1748 7
#ifdef BOGUS_GETNAME_RETURN
    /* Interactive Unix, getpeername() and getsockname()
      does not return valid namelen */
    if (len == BOGUS_GETNAME_RETURN)
	len = sizeof(struct sockaddr);
#endif
    SvCUR_set(sv, len);
d1754 1
a1754 1
    if (PL_dowarn)
d1774 1
a1774 1
    djSP;
a1775 1
    I32 gimme;
a1776 1
    STRLEN n_a;
d1778 1
a1778 1
    if (PL_op->op_flags & OPf_REF) {
d1781 9
a1789 6
	if (tmpgv != PL_defgv) {
	    PL_laststype = OP_STAT;
	    PL_statgv = tmpgv;
	    sv_setpv(PL_statname, "");
	    PL_laststatval = (GvIO(tmpgv) && IoIFP(GvIOp(tmpgv))
		? PerlLIO_fstat(PerlIO_fileno(IoIFP(GvIOn(tmpgv))), &PL_statcache) : -1);
d1791 1
a1791 1
	if (PL_laststatval < 0)
d1804 2
a1805 2
	sv_setpv(PL_statname, SvPV(sv,n_a));
	PL_statgv = Nullgv;
d1807 3
a1809 3
	PL_laststype = PL_op->op_type;
	if (PL_op->op_type == OP_LSTAT)
	    PL_laststatval = PerlLIO_lstat(SvPV(PL_statname, n_a), &PL_statcache);
d1812 3
a1814 3
	    PL_laststatval = PerlLIO_stat(SvPV(PL_statname, n_a), &PL_statcache);
	if (PL_laststatval < 0) {
	    if (PL_dowarn && strchr(SvPV(PL_statname, n_a), '\n'))
d1820 6
a1825 5
    gimme = GIMME_V;
    if (gimme != G_ARRAY) {
	if (gimme != G_VOID)
	    XPUSHs(boolSV(max));
	RETURN;
d1828 11
a1838 23
	EXTEND(SP, max);
	EXTEND_MORTAL(max);
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_dev)));
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_ino)));
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_mode)));
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_nlink)));
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_uid)));
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_gid)));
#ifdef USE_STAT_RDEV
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_rdev)));
#else
	PUSHs(sv_2mortal(newSVpv("", 0)));
#endif
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_size)));
#ifdef BIG_TIME
	PUSHs(sv_2mortal(newSVnv((U32)PL_statcache.st_atime)));
	PUSHs(sv_2mortal(newSVnv((U32)PL_statcache.st_mtime)));
	PUSHs(sv_2mortal(newSVnv((U32)PL_statcache.st_ctime)));
#else
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_atime)));
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_mtime)));
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_ctime)));
#endif
d1840 2
a1841 2
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_blksize)));
	PUSHs(sv_2mortal(newSViv((I32)PL_statcache.st_blocks)));
d1853 1
a1853 1
    djSP;
d1856 1
a1856 1
    if (cando(S_IRUSR, 0, &PL_statcache))
d1864 1
a1864 1
    djSP;
d1867 1
a1867 1
    if (cando(S_IWUSR, 0, &PL_statcache))
d1875 1
a1875 1
    djSP;
d1878 1
a1878 1
    if (cando(S_IXUSR, 0, &PL_statcache))
d1886 1
a1886 1
    djSP;
d1889 1
a1889 1
    if (cando(S_IRUSR, 1, &PL_statcache))
d1897 1
a1897 1
    djSP;
d1900 1
a1900 1
    if (cando(S_IWUSR, 1, &PL_statcache))
d1908 1
a1908 1
    djSP;
d1911 1
a1911 1
    if (cando(S_IXUSR, 1, &PL_statcache))
d1919 1
a1919 1
    djSP;
d1933 1
a1933 1
    djSP;
d1936 1
a1936 1
    if (PL_statcache.st_uid == (PL_op->op_type == OP_FTEOWNED ? PL_euid : PL_uid) )
d1944 1
a1944 1
    djSP;
d1947 1
a1947 1
    if (!PL_statcache.st_size)
d1955 1
a1955 1
    djSP; dTARGET;
d1958 1
a1958 1
    PUSHi(PL_statcache.st_size);
d1965 1
a1965 1
    djSP; dTARGET;
d1968 1
a1968 1
    PUSHn( ((I32)PL_basetime - (I32)PL_statcache.st_mtime) / 86400.0 );
d1975 1
a1975 1
    djSP; dTARGET;
d1978 1
a1978 1
    PUSHn( ((I32)PL_basetime - (I32)PL_statcache.st_atime) / 86400.0 );
d1985 1
a1985 1
    djSP; dTARGET;
d1988 1
a1988 1
    PUSHn( ((I32)PL_basetime - (I32)PL_statcache.st_ctime) / 86400.0 );
d1995 1
a1995 1
    djSP;
d1998 1
a1998 1
    if (S_ISSOCK(PL_statcache.st_mode))
d2006 1
a2006 1
    djSP;
d2009 1
a2009 1
    if (S_ISCHR(PL_statcache.st_mode))
d2017 1
a2017 1
    djSP;
d2020 1
a2020 1
    if (S_ISBLK(PL_statcache.st_mode))
d2028 1
a2028 1
    djSP;
d2031 1
a2031 1
    if (S_ISREG(PL_statcache.st_mode))
d2039 1
a2039 1
    djSP;
d2042 1
a2042 1
    if (S_ISDIR(PL_statcache.st_mode))
d2050 1
a2050 1
    djSP;
d2053 1
a2053 1
    if (S_ISFIFO(PL_statcache.st_mode))
d2061 1
a2061 1
    djSP;
d2064 1
a2064 1
    if (S_ISLNK(PL_statcache.st_mode))
d2071 1
a2071 1
    djSP;
d2077 1
a2077 1
    if (PL_statcache.st_mode & S_ISUID)
d2085 1
a2085 1
    djSP;
d2091 1
a2091 1
    if (PL_statcache.st_mode & S_ISGID)
d2099 1
a2099 1
    djSP;
d2105 1
a2105 1
    if (PL_statcache.st_mode & S_ISVTX)
d2113 1
a2113 1
    djSP;
d2116 2
a2117 4
    char *tmps = Nullch;
    STRLEN n_a;

    if (PL_op->op_flags & OPf_REF)
d2119 2
a2120 4
    else if (isGV(TOPs))
	gv = (GV*)POPs;
    else if (SvROK(TOPs) && isGV(SvRV(TOPs)))
	gv = (GV*)SvRV(POPs);
d2122 1
a2122 2
	gv = gv_fetchpv(tmps = POPpx, FALSE, SVt_PVIO);

d2124 2
a2125 2
	fd = PerlIO_fileno(IoIFP(GvIOp(gv)));
    else if (tmps && isDIGIT(*tmps))
d2129 1
a2129 1
    if (PerlLIO_isatty(fd))
d2144 1
a2144 1
    djSP;
d2151 1
a2151 12
    register SV *sv;
    GV *gv;
    STRLEN n_a;

    if (PL_op->op_flags & OPf_REF)
	gv = cGVOP->op_gv;
    else if (isGV(TOPs))
	gv = (GV*)POPs;
    else if (SvROK(TOPs) && isGV(SvRV(TOPs)))
	gv = (GV*)SvRV(POPs);
    else
	gv = Nullgv;
d2153 1
a2153 1
    if (gv) {
d2155 3
a2157 3
	if (gv == PL_defgv) {
	    if (PL_statgv)
		io = GvIO(PL_statgv);
d2159 1
a2159 1
		sv = PL_statname;
d2164 3
a2166 4
	    PL_statgv = gv;
	    PL_laststatval = -1;
	    sv_setpv(PL_statname, "");
	    io = GvIO(PL_statgv);
d2169 4
a2172 7
	    if (! PerlIO_has_base(IoIFP(io)))
		DIE("-T and -B not implemented on filehandles");
	    PL_laststatval = PerlLIO_fstat(PerlIO_fileno(IoIFP(io)), &PL_statcache);
	    if (PL_laststatval < 0)
		RETPUSHUNDEF;
	    if (S_ISDIR(PL_statcache.st_mode))	/* handle NFS glitch */
		if (PL_op->op_type == OP_FTTEXT)
d2176 2
a2177 2
	    if (PerlIO_get_cnt(IoIFP(io)) <= 0) {
		i = PerlIO_getc(IoIFP(io));
d2179 1
a2179 1
		    (void)PerlIO_ungetc(IoIFP(io),i);
d2181 1
a2181 1
	    if (PerlIO_get_cnt(IoIFP(io)) <= 0)	/* null file is anything */
d2183 5
a2187 5
	    len = PerlIO_get_bufsiz(IoIFP(io));
	    s = (STDCHAR *) PerlIO_get_base(IoIFP(io));
	    /* sfio can have large buffers - limit to 512 */
	    if (len > 512)
		len = 512;
d2190 1
a2190 1
	    if (PL_dowarn)
d2199 2
a2201 3
	PL_statgv = Nullgv;
	PL_laststatval = -1;
	sv_setpv(PL_statname, SvPV(sv, n_a));
d2203 1
a2203 1
	i = PerlLIO_open3(SvPV(sv, n_a), O_RDONLY, 0);
d2205 1
a2205 1
	i = PerlLIO_open(SvPV(sv, n_a), 0);
d2208 1
a2208 1
	    if (PL_dowarn && strchr(SvPV(sv, n_a), '\n'))
d2212 3
a2214 5
	PL_laststatval = PerlLIO_fstat(i, &PL_statcache);
	if (PL_laststatval < 0)
	    RETPUSHUNDEF;
	len = PerlLIO_read(i, tbuf, 512);
	(void)PerlLIO_close(i);
d2216 1
a2216 1
	    if (S_ISDIR(PL_statcache.st_mode) && PL_op->op_type == OP_FTTEXT)
a2230 4
#ifdef EBCDIC
        else if (!(isPRINT(*s) || isSPACE(*s))) 
            odd++;
#else
a2236 1
#endif
d2239 1
a2239 1
    if ((odd * 3 > len) == (PL_op->op_type == OP_FTTEXT)) /* allow 1/3 odd */
d2254 1
a2254 1
    djSP; dTARGET;
a2256 1
    STRLEN n_a;
d2261 1
a2261 1
	tmps = POPpx;
d2263 1
a2263 1
	svp = hv_fetch(GvHVn(PL_envgv), "HOME", 4, FALSE);
d2265 1
a2265 1
	    tmps = SvPV(*svp, n_a);
d2268 1
a2268 1
	svp = hv_fetch(GvHVn(PL_envgv), "LOGDIR", 6, FALSE);
d2270 1
a2270 7
	    tmps = SvPV(*svp, n_a);
    }
#ifdef VMS
    if (!tmps || !*tmps) {
       svp = hv_fetch(GvHVn(PL_envgv), "SYS$LOGIN", 9, FALSE);
       if (svp)
           tmps = SvPV(*svp, n_a);
a2271 1
#endif
d2273 1
a2273 1
    PUSHi( PerlDir_chdir(tmps) >= 0 );
d2277 1
a2277 1
    hv_delete(GvHVn(PL_envgv),"DEFAULT",7,G_DISCARD);
d2284 1
a2284 1
    djSP; dMARK; dTARGET;
d2287 1
a2287 1
    value = (I32)apply(PL_op->op_type, MARK, SP);
d2298 1
a2298 1
    djSP; dTARGET;
a2299 1
    STRLEN n_a;
d2301 1
a2301 1
    tmps = POPpx;
d2312 1
a2312 1
    djSP; dMARK; dTARGET;
d2314 1
a2314 1
    value = (I32)apply(PL_op->op_type, MARK, SP);
d2322 1
a2322 1
    djSP; dMARK; dTARGET;
d2324 1
a2324 1
    value = (I32)apply(PL_op->op_type, MARK, SP);
d2332 1
a2332 1
    djSP; dMARK; dTARGET;
d2334 1
a2334 1
    value = (I32)apply(PL_op->op_type, MARK, SP);
d2342 1
a2342 1
    djSP; dTARGET;
a2343 1
    STRLEN n_a;
d2345 2
a2346 2
    char *tmps2 = POPpx;
    char *tmps = SvPV(TOPs, n_a);
d2349 1
a2349 1
    anum = PerlLIO_rename(tmps, tmps2);
d2351 7
a2357 9
    if (!(anum = PerlLIO_stat(tmps, &PL_statbuf))) {
	if (same_dirent(tmps2, tmps))	/* can always rename to same name */
	    anum = 1;
	else {
	    if (PL_euid || PerlLIO_stat(tmps2, &PL_statbuf) < 0 || !S_ISDIR(PL_statbuf.st_mode))
		(void)UNLINK(tmps2);
	    if (!(anum = link(tmps, tmps2)))
		anum = UNLINK(tmps);
	}
d2366 1
a2366 1
    djSP; dTARGET;
d2368 2
a2369 3
    STRLEN n_a;
    char *tmps2 = POPpx;
    char *tmps = SvPV(TOPs, n_a);
d2380 1
a2380 1
    djSP; dTARGET;
d2382 2
a2383 3
    STRLEN n_a;
    char *tmps2 = POPpx;
    char *tmps = SvPV(TOPs, n_a);
d2394 1
a2394 1
    djSP; dTARGET;
a2396 1
    char buf[MAXPATHLEN];
d2398 1
a2398 6
    STRLEN n_a;

#ifndef INCOMPLETE_TAINTS
    TAINT;
#endif
    tmps = POPpx;
d2417 3
a2419 4
    char *save_filename = filename;
    char *cmdline;
    char *s;
    PerlIO *myfp;
d2421 1
d2423 3
a2425 4
    New(666, cmdline, strlen(cmd) + (strlen(filename) * 2) + 10, char);
    strcpy(cmdline, cmd);
    strcat(cmdline, " ");
    for (s = cmdline + strlen(cmdline); *filename; ) {
d2430 1
a2430 3
    myfp = PerlProc_popen(cmdline, "r");
    Safefree(cmdline);

d2432 3
a2434 4
	SV *tmpsv = sv_newmortal();
	/* Need to save/restore 'PL_rs' ?? */
	s = sv_gets(tmpsv, myfp, 0);
	(void)PerlProc_pclose(myfp);
d2436 1
a2436 2
	    int e;
	    for (e = 1;
d2438 2
a2439 8
		 e <= sys_nerr
#endif
		 ; e++)
	    {
		/* you don't see this */
		char *errmsg =
#ifdef HAS_SYS_ERRLIST
		    sys_errlist[e]
d2441 5
a2445 1
		    strerror(e)
a2446 7
		    ;
		if (!errmsg)
		    break;
		if (instr(s, errmsg)) {
		    SETERRNO(e,0);
		    return 0;
		}
d2452 1
a2452 1
	    if (instr(s, "cannot make"))
d2454 1
a2454 1
	    else if (instr(s, "existing file"))
d2456 1
a2456 1
	    else if (instr(s, "ile exists"))
d2458 1
a2458 1
	    else if (instr(s, "non-exist"))
d2460 1
a2460 1
	    else if (instr(s, "does not exist"))
d2462 1
a2462 1
	    else if (instr(s, "not empty"))
d2464 1
a2464 1
	    else if (instr(s, "cannot access"))
d2471 2
a2472 2
	    anum = (PerlLIO_stat(save_filename, &PL_statbuf) >= 0);
	    if (PL_op->op_type == OP_RMDIR)
d2488 1
a2488 1
    djSP; dTARGET;
d2493 1
a2493 2
    STRLEN n_a;
    char *tmps = SvPV(TOPs, n_a);
d2497 1
a2497 1
    SETi( PerlDir_mkdir(tmps, mode) >= 0 );
d2500 3
a2502 3
    oldumask = PerlLIO_umask(0);
    PerlLIO_umask(oldumask);
    PerlLIO_chmod(tmps, (mode & ~oldumask) & 0777);
d2509 1
a2509 1
    djSP; dTARGET;
a2510 1
    STRLEN n_a;
d2512 1
a2512 1
    tmps = POPpx;
d2515 1
a2515 1
    XPUSHi( PerlDir_rmdir(tmps) >= 0 );
d2526 1
a2526 1
    djSP;
d2528 1
a2528 2
    STRLEN n_a;
    char *dirname = POPpx;
d2536 2
a2537 2
	PerlDir_close(IoDIRP(io));
    if (!(IoDIRP(io) = PerlDir_open(dirname)))
d2552 1
a2552 1
    djSP;
a2559 1
    SV *sv;
d2566 1
a2566 1
	while (dp = (Direntry_t *)PerlDir_read(IoDIRP(io))) {
d2568 1
a2568 1
	    sv = newSVpv(dp->d_name, dp->d_namlen);
d2570 1
a2570 1
	    sv = newSVpv(dp->d_name, 0);
a2571 4
#ifndef INCOMPLETE_TAINTS
  	    SvTAINTED_on(sv);
#endif
	    XPUSHs(sv_2mortal(sv));
d2575 1
a2575 1
	if (!(dp = (Direntry_t *)PerlDir_read(IoDIRP(io))))
d2578 1
a2578 1
	sv = newSVpv(dp->d_name, dp->d_namlen);
d2580 1
a2580 4
	sv = newSVpv(dp->d_name, 0);
#endif
#ifndef INCOMPLETE_TAINTS
	SvTAINTED_on(sv);
a2581 1
	XPUSHs(sv_2mortal(sv));
d2599 1
a2599 1
    djSP; dTARGET;
d2601 1
a2601 1
# ifdef NEED_TELLDIR_PROTO /* XXX does _anyone_ need this? --AD 2/20/1998 */
d2603 1
a2603 1
# endif
d2610 1
a2610 1
    PUSHi( PerlDir_tell(IoDIRP(io)) );
d2623 1
a2623 1
    djSP;
d2632 1
a2632 1
    (void)PerlDir_seek(IoDIRP(io), along);
d2646 1
a2646 1
    djSP;
d2654 1
a2654 1
    (void)PerlDir_rewind(IoDIRP(io));
d2667 1
a2667 1
    djSP;
d2676 1
a2676 1
    PerlDir_close(IoDIRP(io));
d2678 1
a2678 1
    if (PerlDir_close(IoDIRP(io)) < 0) {
d2699 1
a2699 2
#ifdef HAS_FORK
    djSP; dTARGET;
d2704 1
d2711 2
a2712 2
	    sv_setiv(GvSV(tmpgv), (IV)getpid());
	hv_clear(PL_pidstatus);	/* no kids, so don't wait for 'em */
d2723 1
a2723 2
#if !defined(DOSISH) || defined(OS2) || defined(WIN32)
    djSP; dTARGET;
d2726 1
d2728 8
a2735 3
    childpid = wait4pid(-1, &argflags, 0);
    STATUS_NATIVE_SET((childpid > 0) ? argflags : -1);
    XPUSHi(childpid);
d2744 1
a2744 2
#if !defined(DOSISH) || defined(OS2) || defined(WIN32)
    djSP; dTARGET;
d2748 1
d2750 1
d2754 3
a2756 2
    STATUS_NATIVE_SET((childpid > 0) ? argflags : -1);
    SETi(childpid);
d2759 1
a2759 1
    DIE(no_func, "Unsupported function waitpid");
d2765 1
a2765 1
    djSP; dMARK; dORIGMARK; dTARGET;
d2770 2
a2771 2
    Sigsave_t ihand,qhand;     /* place to save signals during system() */
    STRLEN n_a;
d2773 1
d2775 2
a2776 2
	if (PL_tainting) {
	    char *junk = SvPV(TOPs, n_a);
a2780 1
#if (defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(OS2)
d2791 2
a2792 2
	rsignal_save(SIGINT, SIG_IGN, &ihand);
	rsignal_save(SIGQUIT, SIG_IGN, &qhand);
d2796 8
a2803 3
	(void)rsignal_restore(SIGINT, &ihand);
	(void)rsignal_restore(SIGQUIT, &qhand);
	STATUS_NATIVE_SET(result == -1 ? -1 : status);
d2806 1
a2806 1
	PUSHi(STATUS_CURRENT);
d2809 1
a2809 1
    if (PL_op->op_flags & OPf_STACKED) {
d2816 1
a2816 1
	value = (I32)do_exec(SvPVx(sv_mortalcopy(*SP), n_a));
d2818 1
a2818 1
    PerlProc__exit(-1);
d2820 1
a2820 1
    if (PL_op->op_flags & OPf_STACKED) {
d2822 1
a2822 1
	value = (I32)do_aspawn(really, (void **)MARK, (void **)SP);
d2825 1
a2825 1
	value = (I32)do_aspawn(Nullsv, (void **)MARK, (void **)SP);
d2827 1
a2827 1
	value = (I32)do_spawn(SvPVx(sv_mortalcopy(*SP), n_a));
d2829 1
a2829 1
    STATUS_NATIVE_SET(value);
d2832 1
a2832 1
    PUSHi(STATUS_CURRENT);
d2839 1
a2839 1
    djSP; dMARK; dORIGMARK; dTARGET;
a2840 1
    STRLEN n_a;
d2842 1
a2842 1
    if (PL_op->op_flags & OPf_STACKED) {
d2853 2
a2854 2
	if (PL_tainting) {
	    char *junk = SvPV(*SP, n_a);
d2859 1
a2859 1
	value = (I32)vms_do_exec(SvPVx(sv_mortalcopy(*SP), n_a));
d2861 1
a2861 1
	value = (I32)do_exec(SvPVx(sv_mortalcopy(*SP), n_a));
d2871 1
a2871 1
    djSP; dMARK; dTARGET;
d2874 1
a2874 1
    value = (I32)apply(PL_op->op_type, MARK, SP);
d2886 1
a2886 1
    djSP; dTARGET;
d2897 1
a2897 1
    djSP; dTARGET;
d2908 1
a2908 1
    if (pid != 0 && pid != getpid())
d2922 1
a2922 1
    djSP; dTARGET;
d2938 1
a2938 1
    if ((pgrp != 0 && pgrp != getpid()) || (pid != 0 && pid != getpid()))
d2940 1
d2951 1
a2951 1
    djSP; dTARGET;
d2966 1
a2966 1
    djSP; dTARGET;
d2986 1
a2986 4
    djSP; dTARGET;
#ifdef BIG_TIME
    XPUSHn( time(Null(Time_t*)) );
#else
a2987 1
#endif
a2990 8
/* XXX The POSIX name is CLK_TCK; it is to be preferred
   to HZ.  Probably.  For now, assume that if the system
   defines HZ, it does so correctly.  (Will this break
   on VMS?)
   Probably we ought to use _sysconf(_SC_CLK_TCK), if
   it's supported.    --AD  9/96.
*/

d2992 1
a2992 5
#  ifdef CLK_TCK
#    define HZ CLK_TCK
#  else
#    define HZ 60
#  endif
d2997 1
a2997 1
    djSP;
d2999 1
a2999 1
#ifndef HAS_TIMES
d3005 1
a3005 1
    (void)PerlProc_times(&PL_timesbuf);
d3007 5
a3011 3
    (void)PerlProc_times((tbuffer_t *)&PL_timesbuf);  /* time.h uses different name for */
                                                   /* struct tms, though same data   */
                                                   /* is returned.                   */
d3014 1
a3014 1
    PUSHs(sv_2mortal(newSVnv(((double)PL_timesbuf.tms_utime)/HZ)));
d3016 3
a3018 3
	PUSHs(sv_2mortal(newSVnv(((double)PL_timesbuf.tms_stime)/HZ)));
	PUSHs(sv_2mortal(newSVnv(((double)PL_timesbuf.tms_cutime)/HZ)));
	PUSHs(sv_2mortal(newSVnv(((double)PL_timesbuf.tms_cstime)/HZ)));
d3021 1
a3021 1
#endif /* HAS_TIMES */
d3031 1
a3031 1
    djSP;
a3040 3
#ifdef BIG_TIME
	when = (Time_t)SvNVx(POPs);
#else
a3041 1
#endif
d3043 1
a3043 1
    if (PL_op->op_type == OP_LOCALTIME)
a3048 1
    EXTEND_MORTAL(9);
d3051 1
a3051 1
	SV *tsv;
d3054 9
a3062 9
	tsv = newSVpvf("%s %s %2d %02d:%02d:%02d %d",
		       dayname[tmbuf->tm_wday],
		       monname[tmbuf->tm_mon],
		       tmbuf->tm_mday,
		       tmbuf->tm_hour,
		       tmbuf->tm_min,
		       tmbuf->tm_sec,
		       tmbuf->tm_year + 1900);
	PUSHs(sv_2mortal(tsv));
d3080 1
a3080 1
    djSP; dTARGET;
d3097 1
a3097 1
    djSP; dTARGET;
d3104 1
a3104 1
	PerlProc_pause();
d3107 1
a3107 1
	PerlProc_sleep((unsigned int)duration);
d3134 2
a3135 2
    djSP; dMARK; dTARGET;
    I32 value = (I32)(do_shmio(PL_op->op_type, MARK, SP) >= 0);
d3159 1
a3159 1
    djSP; dMARK; dTARGET;
d3172 1
a3172 1
    djSP; dMARK; dTARGET;
d3187 2
a3188 2
    djSP; dMARK; dTARGET;
    int anum = do_ipcget(PL_op->op_type, MARK, SP);
d3202 2
a3203 2
    djSP; dMARK; dTARGET;
    int anum = do_ipcctl(PL_op->op_type, MARK, SP);
d3211 1
a3211 1
	PUSHp(zero_but_true, ZBTLEN);
d3222 1
a3222 1
    djSP; dMARK; dTARGET;
d3236 1
a3236 1
#ifdef HAS_GETHOSTBYNAME
d3245 1
a3245 1
#ifdef HAS_GETHOSTBYADDR
d3254 3
a3256 3
    djSP;
#if defined(HAS_GETHOSTBYNAME) || defined(HAS_GETHOSTBYADDR) || defined(HAS_GETHOSTENT)
    I32 which = PL_op->op_type;
d3259 4
a3262 4
#ifndef HAS_GETHOST_PROTOS /* XXX Do we need individual probes? */
    struct hostent *PerlSock_gethostbyaddr(Netdb_host_t, Netdb_hlen_t, int);
    struct hostent *PerlSock_gethostbyname(Netdb_name_t);
    struct hostent *PerlSock_gethostent(void);
d3269 1
a3269 6
#ifdef HAS_GETHOSTBYNAME
	STRLEN n_a;
	hent = PerlSock_gethostbyname(POPpx);
#else
	DIE(no_sock_func, "gethostbyname");
#endif
a3271 1
#ifdef HAS_GETHOSTBYADDR
d3275 1
a3275 1
	Netdb_host_t addr = (Netdb_host_t) SvPV(addrsv, addrlen);
d3277 1
a3277 4
	hent = PerlSock_gethostbyaddr(addr, (Netdb_hlen_t) addrlen, addrtype);
#else
	DIE(no_sock_func, "gethostbyaddr");
#endif
d3281 1
a3281 1
	hent = PerlSock_gethostent();
d3283 1
a3283 1
	DIE(no_sock_func, "gethostent");
d3288 1
a3288 1
	STATUS_NATIVE_SET(h_errno);
d3305 1
a3305 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d3307 1
a3307 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d3313 3
a3315 3
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setiv(sv, (IV)hent->h_addrtype);
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d3317 1
a3317 1
	sv_setiv(sv, (IV)len);
d3320 1
a3320 1
	    XPUSHs(sv = sv_mortalcopy(&PL_sv_no));
d3324 1
a3324 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d3337 1
a3337 1
#ifdef HAS_GETNETBYNAME
d3346 1
a3346 1
#ifdef HAS_GETNETBYADDR
d3355 3
a3357 3
    djSP;
#if defined(HAS_GETNETBYNAME) || defined(HAS_GETNETBYADDR) || defined(HAS_GETNETENT)
    I32 which = PL_op->op_type;
d3360 3
a3362 5
#ifndef HAS_GETNET_PROTOS /* XXX Do we need individual probes? */
    struct netent *PerlSock_getnetbyaddr(Netdb_net_t, int);
    struct netent *PerlSock_getnetbyname(Netdb_name_t);
    struct netent *PerlSock_getnetent(void);
#endif
d3365 2
a3366 8
    if (which == OP_GNBYNAME) {
#ifdef HAS_GETNETBYNAME
	STRLEN n_a;
	nent = PerlSock_getnetbyname(POPpx);
#else
        DIE(no_sock_func, "getnetbyname");
#endif
    }
a3367 1
#ifdef HAS_GETNETBYADDR
d3369 2
a3370 5
	Netdb_net_t addr = (Netdb_net_t) U_L(POPn);
	nent = PerlSock_getnetbyaddr(addr, addrtype);
#else
	DIE(no_sock_func, "getnetbyaddr");
#endif
d3373 1
a3373 5
#ifdef HAS_GETNETENT
	nent = PerlSock_getnetent();
#else
        DIE(no_sock_func, "getnetent");
#endif
d3380 1
a3380 1
		sv_setiv(sv, (IV)nent->n_net);
d3388 1
a3388 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d3390 2
a3391 2
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	for (elem = nent->n_aliases; elem && *elem; elem++) {
d3396 4
a3399 4
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setiv(sv, (IV)nent->n_addrtype);
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setiv(sv, (IV)nent->n_net);
d3410 1
a3410 1
#ifdef HAS_GETPROTOBYNAME
d3419 1
a3419 1
#ifdef HAS_GETPROTOBYNUMBER
d3428 3
a3430 3
    djSP;
#if defined(HAS_GETPROTOBYNAME) || defined(HAS_GETPROTOBYNUMBER) || defined(HAS_GETPROTOENT)
    I32 which = PL_op->op_type;
d3432 4
a3435 6
    register SV *sv;  
#ifndef HAS_GETPROTO_PROTOS /* XXX Do we need individual probes? */
    struct protoent *PerlSock_getprotobyname(Netdb_name_t);
    struct protoent *PerlSock_getprotobynumber(int);
    struct protoent *PerlSock_getprotoent(void);
#endif
d3438 2
a3439 8
    if (which == OP_GPBYNAME) {
#ifdef HAS_GETPROTOBYNAME
	STRLEN n_a;
	pent = PerlSock_getprotobyname(POPpx);
#else
	DIE(no_sock_func, "getprotobyname");
#endif
    }
d3441 1
a3441 5
#ifdef HAS_GETPROTOBYNUMBER
	pent = PerlSock_getprotobynumber(POPi);
#else
    DIE(no_sock_func, "getprotobynumber");
#endif
d3443 1
a3443 5
#ifdef HAS_GETPROTOENT
	pent = PerlSock_getprotoent();
#else
	DIE(no_sock_func, "getprotoent");
#endif
d3450 1
a3450 1
		sv_setiv(sv, (IV)pent->p_proto);
d3458 1
a3458 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d3460 2
a3461 2
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	for (elem = pent->p_aliases; elem && *elem; elem++) {
d3466 2
a3467 2
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setiv(sv, (IV)pent->p_proto);
d3478 1
a3478 1
#ifdef HAS_GETSERVBYNAME
d3487 1
a3487 1
#ifdef HAS_GETSERVBYPORT
d3496 3
a3498 3
    djSP;
#if defined(HAS_GETSERVBYNAME) || defined(HAS_GETSERVBYPORT) || defined(HAS_GETSERVENT)
    I32 which = PL_op->op_type;
d3501 3
a3503 5
#ifndef HAS_GETSERV_PROTOS /* XXX Do we need individual probes? */
    struct servent *PerlSock_getservbyname(Netdb_name_t, Netdb_name_t);
    struct servent *PerlSock_getservbyport(int, Netdb_name_t);
    struct servent *PerlSock_getservent(void);
#endif
d3507 2
a3508 4
#ifdef HAS_GETSERVBYNAME
	STRLEN n_a;
	char *proto = POPpx;
	char *name = POPpx;
d3513 1
a3513 4
	sent = PerlSock_getservbyname(name, proto);
#else
	DIE(no_sock_func, "getservbyname");
#endif
d3516 2
a3517 4
#ifdef HAS_GETSERVBYPORT
	STRLEN n_a;
	char *proto = POPpx;
	unsigned short port = POPu;
d3519 1
a3519 7
#ifdef HAS_HTONS
	port = PerlSock_htons(port);
#endif
	sent = PerlSock_getservbyport(port, proto);
#else
	DIE(no_sock_func, "getservbyport");
#endif
d3522 1
a3522 5
#ifdef HAS_GETSERVENT
	sent = PerlSock_getservent();
#else
	DIE(no_sock_func, "getservent");
#endif
d3530 1
a3530 1
		sv_setiv(sv, (IV)PerlSock_ntohs(sent->s_port));
d3532 1
a3532 1
		sv_setiv(sv, (IV)(sent->s_port));
d3542 1
a3542 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d3544 2
a3545 2
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	for (elem = sent->s_aliases; elem && *elem; elem++) {
d3550 1
a3550 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d3552 1
a3552 1
	sv_setiv(sv, (IV)PerlSock_ntohs(sent->s_port));
d3554 1
a3554 1
	sv_setiv(sv, (IV)(sent->s_port));
d3556 1
a3556 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d3568 3
a3570 3
    djSP;
#ifdef HAS_SETHOSTENT
    PerlSock_sethostent(TOPi);
d3579 3
a3581 3
    djSP;
#ifdef HAS_SETNETENT
    PerlSock_setnetent(TOPi);
d3590 3
a3592 3
    djSP;
#ifdef HAS_SETPROTOENT
    PerlSock_setprotoent(TOPi);
d3601 3
a3603 3
    djSP;
#ifdef HAS_SETSERVENT
    PerlSock_setservent(TOPi);
d3612 4
a3615 4
    djSP;
#ifdef HAS_ENDHOSTENT
    PerlSock_endhostent();
    EXTEND(SP,1);
d3624 4
a3627 4
    djSP;
#ifdef HAS_ENDNETENT
    PerlSock_endnetent();
    EXTEND(SP,1);
d3636 4
a3639 4
    djSP;
#ifdef HAS_ENDPROTOENT
    PerlSock_endprotoent();
    EXTEND(SP,1);
d3648 4
a3651 4
    djSP;
#ifdef HAS_ENDSERVENT
    PerlSock_endservent();
    EXTEND(SP,1);
d3678 3
a3680 3
    djSP;
#if defined(HAS_PASSWD) && defined(HAS_GETPWENT)
    I32 which = PL_op->op_type;
a3682 1
    STRLEN n_a;
d3685 1
a3685 1
	pwent = getpwnam(POPpx);
d3696 1
a3696 1
		sv_setiv(sv, (IV)pwent->pw_uid);
d3704 1
a3704 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d3706 1
a3706 3

	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
#ifdef PWPASSWD
d3708 5
a3712 10
#endif

	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setiv(sv, (IV)pwent->pw_uid);

	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setiv(sv, (IV)pwent->pw_gid);

	/* pw_change, pw_quota, and pw_age are mutually exclusive. */
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d3714 4
a3717 1
	sv_setiv(sv, (IV)pwent->pw_change);
d3719 1
a3719 4
#   ifdef PWQUOTA
	sv_setiv(sv, (IV)pwent->pw_quota);
#   else
#       ifdef PWAGE
a3720 2
#       endif
#   endif
d3722 3
a3724 3

	/* pw_class and pw_comment are mutually exclusive. */
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d3728 1
a3728 1
#   ifdef PWCOMMENT
a3729 1
#   endif
d3731 2
a3732 3

	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
#ifdef PWGECOS
d3734 1
a3734 7
#endif
#ifndef INCOMPLETE_TAINTS
	/* pw_gecos is tainted because user himself can diddle with it. */
	SvTAINTED_on(sv);
#endif

	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d3736 1
a3736 2

	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
a3737 1

d3739 2
a3740 2
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setiv(sv, (IV)pwent->pw_expire);
d3751 2
a3752 2
    djSP;
#if defined(HAS_PASSWD) && defined(HAS_SETPWENT) && !defined(CYGWIN32)
d3762 2
a3763 2
    djSP;
#if defined(HAS_PASSWD) && defined(HAS_ENDPWENT)
d3791 3
a3793 3
    djSP;
#if defined(HAS_GROUP) && defined(HAS_GETGRENT)
    I32 which = PL_op->op_type;
a3796 1
    STRLEN n_a;
d3799 1
a3799 1
	grent = (struct group *)getgrnam(POPpx);
d3810 1
a3810 1
		sv_setiv(sv, (IV)grent->gr_gid);
d3818 1
a3818 1
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d3820 1
a3820 3

	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
#ifdef GRPASSWD
d3822 4
a3825 7
#endif

	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setiv(sv, (IV)grent->gr_gid);

	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	for (elem = grent->gr_mem; elem && *elem; elem++) {
d3840 2
a3841 2
    djSP;
#if defined(HAS_GROUP) && defined(HAS_SETGRENT)
d3851 2
a3852 2
    djSP;
#if defined(HAS_GROUP) && defined(HAS_ENDGRENT)
d3862 1
a3862 1
    djSP; dTARGET;
d3866 1
a3866 1
    if (!(tmps = PerlProc_getlogin()))
d3880 1
a3880 1
    djSP; dMARK; dORIGMARK; dTARGET;
d3887 1
a3887 1
    if (PL_tainting) {
d3889 3
a3891 4
	    if (SvTAINTED(*MARK)) {
		TAINT;
		break;
	    }
d3904 1
a3904 1
	else if (*MARK == &PL_sv_undef)
d3906 2
a3907 4
	else  {
	    STRLEN n_a;
	    a[i++] = (unsigned long)SvPV_force(*MARK, n_a);
	}
d3973 1
a3973 34
#ifdef FCNTL_EMULATE_FLOCK
 
/*  XXX Emulate flock() with fcntl().
    What's really needed is a good file locking module.
*/

static int
fcntl_emulate_flock(int fd, int operation)
{
    struct flock flock;
 
    switch (operation & ~LOCK_NB) {
    case LOCK_SH:
	flock.l_type = F_RDLCK;
	break;
    case LOCK_EX:
	flock.l_type = F_WRLCK;
	break;
    case LOCK_UN:
	flock.l_type = F_UNLCK;
	break;
    default:
	errno = EINVAL;
	return -1;
    }
    flock.l_whence = SEEK_SET;
    flock.l_start = flock.l_len = 0L;
 
    return fcntl(fd, (operation & LOCK_NB) ? F_SETLK : F_SETLKW, &flock);
}

#endif /* FCNTL_EMULATE_FLOCK */

#ifdef LOCKF_EMULATE_FLOCK
d3981 6
a3986 3
/*  The lockf() constants might have been defined in <unistd.h>.
    Unfortunately, <unistd.h> causes troubles on some mixed
    (BSD/POSIX) systems, such as SunOS 4.1.3.
d4006 17
a4022 1
static int
a4027 11
    int save_errno;
    Off_t pos;

    /* flock locks entire file so for lockf we need to do the same	*/
    save_errno = errno;
    pos = PerlLIO_lseek(fd, (Off_t)0, SEEK_CUR);    /* get pos to restore later */
    if (pos > 0)	/* is seekable and needs to be repositioned	*/
	if (PerlLIO_lseek(fd, (Off_t)0, SEEK_SET) < 0)
	    pos = -1;	/* seek failed, so don't seek back afterwards	*/
    errno = save_errno;

d4047 1
a4047 1
	/* LOCK_UN - unlock (non-blocking is a no-op) */
a4048 1
	case LOCK_UN|LOCK_NB:
a4057 4

    if (pos > 0)      /* need to restore position of the handle	*/
	PerlLIO_lseek(fd, pos, SEEK_SET);	/* ignore error here	*/

d4060 1
a4060 2

#endif /* LOCKF_EMULATE_FLOCK */
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a17 1
#define PERL_IN_PP_SYS_C
a19 12
#ifdef I_SHADOW
/* Shadow password support for solaris - pdo@@cs.umd.edu
 * Not just Solaris: at least HP-UX, IRIX, Linux.
 * the API is from SysV. --jhi */
#ifdef __hpux__
/* There is a MAXINT coming from <shadow.h> <- <hpsecurity.h> <- <values.h>
 * and another MAXINT from "perl.h" <- <sys/param.h>. */ 
#undef MAXINT
#endif
#include <shadow.h>
#endif

a40 3
# if defined(USE_SOCKS) && defined(I_SOCKS)
#   include <socks.h>
# endif 
d64 1
a64 1
#if defined(HOST_NOT_FOUND) && !defined(h_errno) && !defined(__CYGWIN__)
d72 2
a73 2
    struct passwd *getpwnam (char *);
    struct passwd *getpwuid (Uid_t);
d76 1
a76 1
  struct passwd *getpwent (void);
d84 2
a85 2
    struct group *getgrnam (char *);
    struct group *getgrgid (Gid_t);
d88 1
a88 1
    struct group *getgrent (void);
d99 6
d111 13
d154 1
a154 1
     static int FLOCK (int, int);
d176 8
d187 1
a187 123
#if defined(I_SYS_ACCESS) && !defined(R_OK)
#  include <sys/access.h>
#endif

#if defined(HAS_FCNTL) && defined(F_SETFD) && !defined(FD_CLOEXEC)
#  define FD_CLOEXEC 1		/* NeXT needs this */
#endif

#undef PERL_EFF_ACCESS_R_OK	/* EFFective uid/gid ACCESS R_OK */
#undef PERL_EFF_ACCESS_W_OK
#undef PERL_EFF_ACCESS_X_OK

/* F_OK unused: if stat() cannot find it... */

#if !defined(PERL_EFF_ACCESS_R_OK) && defined(HAS_ACCESS) && defined(EFF_ONLY_OK) && !defined(NO_EFF_ONLY_OK)
    /* Digital UNIX (when the EFF_ONLY_OK gets fixed), UnixWare */
#   define PERL_EFF_ACCESS_R_OK(p) (access((p), R_OK | EFF_ONLY_OK))
#   define PERL_EFF_ACCESS_W_OK(p) (access((p), W_OK | EFF_ONLY_OK))
#   define PERL_EFF_ACCESS_X_OK(p) (access((p), X_OK | EFF_ONLY_OK))
#endif

#if !defined(PERL_EFF_ACCESS_R_OK) && defined(HAS_EACCESS)
#   if defined(I_SYS_SECURITY)
#       include <sys/security.h>
#   endif
    /* XXX Configure test needed for eaccess */
#   ifdef ACC_SELF
        /* HP SecureWare */
#       define PERL_EFF_ACCESS_R_OK(p) (eaccess((p), R_OK, ACC_SELF))
#       define PERL_EFF_ACCESS_W_OK(p) (eaccess((p), W_OK, ACC_SELF))
#       define PERL_EFF_ACCESS_X_OK(p) (eaccess((p), X_OK, ACC_SELF))
#   else
        /* SCO */
#       define PERL_EFF_ACCESS_R_OK(p) (eaccess((p), R_OK))
#       define PERL_EFF_ACCESS_W_OK(p) (eaccess((p), W_OK))
#       define PERL_EFF_ACCESS_X_OK(p) (eaccess((p), X_OK))
#   endif
#endif

#if !defined(PERL_EFF_ACCESS_R_OK) && defined(HAS_ACCESSX) && defined(ACC_SELF)
    /* AIX */
#   define PERL_EFF_ACCESS_R_OK(p) (accessx((p), R_OK, ACC_SELF))
#   define PERL_EFF_ACCESS_W_OK(p) (accessx((p), W_OK, ACC_SELF))
#   define PERL_EFF_ACCESS_X_OK(p) (accessx((p), X_OK, ACC_SELF))
#endif

#if !defined(PERL_EFF_ACCESS_R_OK) && defined(HAS_ACCESS)	\
    && (defined(HAS_SETREUID) || defined(HAS_SETRESUID)		\
	|| defined(HAS_SETREGID) || defined(HAS_SETRESGID))
/* The Hard Way. */
STATIC int
S_emulate_eaccess(pTHX_ const char* path, Mode_t mode)
{
    Uid_t ruid = getuid();
    Uid_t euid = geteuid();
    Gid_t rgid = getgid();
    Gid_t egid = getegid();
    int res;

    LOCK_CRED_MUTEX;
#if !defined(HAS_SETREUID) && !defined(HAS_SETRESUID)
    Perl_croak(aTHX_ "switching effective uid is not implemented");
#else
#ifdef HAS_SETREUID
    if (setreuid(euid, ruid))
#else
#ifdef HAS_SETRESUID
    if (setresuid(euid, ruid, (Uid_t)-1))
#endif
#endif
	Perl_croak(aTHX_ "entering effective uid failed");
#endif

#if !defined(HAS_SETREGID) && !defined(HAS_SETRESGID)
    Perl_croak(aTHX_ "switching effective gid is not implemented");
#else
#ifdef HAS_SETREGID
    if (setregid(egid, rgid))
#else
#ifdef HAS_SETRESGID
    if (setresgid(egid, rgid, (Gid_t)-1))
#endif
#endif
	Perl_croak(aTHX_ "entering effective gid failed");
#endif

    res = access(path, mode);

#ifdef HAS_SETREUID
    if (setreuid(ruid, euid))
#else
#ifdef HAS_SETRESUID
    if (setresuid(ruid, euid, (Uid_t)-1))
#endif
#endif
	Perl_croak(aTHX_ "leaving effective uid failed");

#ifdef HAS_SETREGID
    if (setregid(rgid, egid))
#else
#ifdef HAS_SETRESGID
    if (setresgid(rgid, egid, (Gid_t)-1))
#endif
#endif
	Perl_croak(aTHX_ "leaving effective gid failed");
    UNLOCK_CRED_MUTEX;

    return res;
}
#   define PERL_EFF_ACCESS_R_OK(p) (emulate_eaccess((p), R_OK))
#   define PERL_EFF_ACCESS_W_OK(p) (emulate_eaccess((p), W_OK))
#   define PERL_EFF_ACCESS_X_OK(p) (emulate_eaccess((p), X_OK))
#endif

#if !defined(PERL_EFF_ACCESS_R_OK)
STATIC int
S_emulate_eaccess(pTHX_ const char* path, Mode_t mode)
{
    Perl_croak(aTHX_ "switching effective uid is not implemented");
    /*NOTREACHED*/
    return -1;
}
#endif
a195 1
    char *mode = "r";
d198 1
a198 5
    if (PL_op->op_private & OPpOPEN_IN_RAW)
	mode = "rb";
    else if (PL_op->op_private & OPpOPEN_IN_CRLF)
	mode = "rt";
    fp = PerlProc_popen(tmps, mode);
a245 6
    tryAMAGICunTARGET(iter, -1);

    /* Note that we only ever get here if File::Glob fails to load
     * without at the same time croaking, for some reason, or if
     * perl was built with PERL_EXTERNAL_GLOB */

d255 1
a255 1
	taint_proper(PL_no_security, "glob");
d263 1
a263 1
    PL_rs = sv_2mortal(newSVpvn("\000", 1));
d286 1
a286 1
    PL_last_in_gv = cGVOP_gv;
a292 1
    SV *tmpsv;
d294 1
a294 1
    STRLEN len;
d298 1
a298 1
	tmpsv = TARG;
d302 1
a302 1
	tmpsv = TOPs;
d304 1
a304 2
    tmps = SvPV(tmpsv, len);
    if (!tmps || !len) {
d309 1
a309 2
	tmpsv = error;
	tmps = SvPV(tmpsv, len);
d311 3
a313 4
    if (!tmps || !len)
	tmpsv = sv_2mortal(newSVpvn("Warning: something's wrong", 26));

    Perl_warn(aTHX_ "%"SVf, tmpsv);
d321 3
a323 3
    SV *tmpsv;
    STRLEN len;
    bool multiarg = 0;
d327 1
a327 3
	tmpsv = TARG;
	tmps = SvPV(tmpsv, len);
	multiarg = 1;
d332 1
a332 1
	tmps = SvROK(tmpsv) ? Nullch : SvPV(tmpsv, len);
d334 1
a334 1
    if (!tmps || !len) {
d337 2
a338 2
	if (multiarg ? SvROK(error) : SvROK(tmpsv)) {
	    if (!multiarg)
d340 1
a340 1
	    else if (sv_isobject(error)) {
d344 2
a345 2
		    SV *file = sv_2mortal(newSVpv(CopFILE(PL_curcop),0));
		    SV *line = sv_2mortal(newSVuv(CopLINE(PL_curcop)));
d352 2
a353 2
		    call_sv((SV*)GvCV(gv),
			    G_SCALAR|G_EVAL|G_KEEPERR);
d357 1
a357 1
	    DIE(aTHX_ Nullch);
d362 1
a362 2
	    tmpsv = error;
	    tmps = SvPV(tmpsv, len);
d365 3
a367 4
    if (!tmps || !len)
	tmpsv = sv_2mortal(newSVpvn("Died", 4));

    DIE(aTHX_ "%"SVf, tmpsv);
a376 2
    SV *name;
    I32 have_name = 0;
a378 1
    MAGIC *mg;
a379 4
    if (MAXARG > 2) {
	name = POPs;
	have_name = 1;
    }
d383 1
a383 1
	DIE(aTHX_ PL_no_usym, "filehandle");
d388 1
a388 1
	DIE(aTHX_ PL_no_usym, "filehandle");
a390 15

    if ((mg = SvTIED_mg((SV*)gv, 'q'))) {
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)gv, mg));
	XPUSHs(sv);
	if (have_name)
	    XPUSHs(name);
	PUTBACK;
	ENTER;
	call_method("OPEN", G_SCALAR);
	LEAVE;
	SPAGAIN;
	RETURN;
    }

d392 1
a392 1
    if (do_open9(gv, tmps, len, FALSE, O_RDONLY, 0, Nullfp, name, have_name))
d412 1
a412 1
    if ((mg = SvTIED_mg((SV*)gv, 'q'))) {
d417 1
a417 1
	call_method("CLOSE", G_SCALAR);
d444 1
a444 1
	DIE(aTHX_ PL_no_usym, "filehandle");
d478 1
a478 1
    DIE(aTHX_ PL_no_func, "pipe");
a487 2
    MAGIC  *mg;

a490 12

    if (gv && (mg = SvTIED_mg((SV*)gv, 'q'))) {
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)gv, mg));
	PUTBACK;
	ENTER;
	call_method("FILENO", G_SCALAR);
	LEAVE;
	SPAGAIN;
	RETURN;
    }

d500 1
a500 1
    Mode_t anum;
d516 1
a516 1
	DIE(aTHX_ "umask not implemented");
a527 2
    MAGIC *mg;
    SV *discp = Nullsv;
a530 2
    if (MAXARG > 1)
	discp = POPs;
d532 1
a532 14
    gv = (GV*)POPs; 

    if (gv && (mg = SvTIED_mg((SV*)gv, 'q'))) {
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)gv, mg));
	if (discp)
	    XPUSHs(discp);
	PUTBACK;
	ENTER;
	call_method("BINMODE", G_SCALAR);
	LEAVE;
	SPAGAIN;
	RETURN;
    }
d538 1
a538 1
    if (do_binmode(fp,IoTYPE(io),mode_from_discipline(discp))) 
d544 1
a556 1
    STRLEN n_a;
d584 1
a584 1
	call_method(methname, G_SCALAR);
d587 1
a587 1
	/* Not clear why we don't call call_method here too.
d592 2
a593 1
	    DIE(aTHX_ "Can't locate object method \"%s\" via package \"%s\"",
d603 1
a603 1
	call_sv((SV*)GvCV(gv), G_SCALAR);
d625 6
a630 7
    if (ckWARN(WARN_UNTIE)) {
        MAGIC * mg ;
        if ((mg = SvTIED_mg(sv, how))) {
            if (mg && SvREFCNT(SvRV(mg->mg_obj)) > 1)  
		Perl_warner(aTHX_ WARN_UNTIE,
		    "untie attempted while %"UVuf" inner references still exist",
		    (UV)SvREFCNT(SvRV(mg->mg_obj)) - 1 ) ;
d645 1
a645 1
    if ((mg = SvTIED_mg(sv, how))) {
d671 1
a671 1
	require_pv("AnyDBM_File.pm");
d674 1
a674 1
	    DIE(aTHX_ "No dbm on this machine");
d684 1
a684 1
	PUSHs(sv_2mortal(newSVuv(O_RDWR|O_CREAT)));
d686 1
a686 1
	PUSHs(sv_2mortal(newSVuv(O_RDWR)));
d689 1
a689 1
    call_sv((SV*)GvCV(gv), G_SCALAR);
d697 1
a697 1
	PUSHs(sv_2mortal(newSVuv(O_RDONLY)));
d700 1
a700 1
	call_sv((SV*)GvCV(gv), G_SCALAR);
d714 1
a714 1
    return pp_untie();
d725 1
a725 1
    NV value;
d761 2
a762 2
     * UNIX, Solaris, NeXT, Darwin) the smallest quantum select() operates
     * on (sets/tests/clears bits) is 32 bits.  */
d764 1
a764 1
#  else
d766 3
a768 3
#  endif
# else
#  ifdef NFDBITS
d770 3
a772 3
#    ifndef NBBY
#     define NBBY 8
#    endif
d775 1
a775 1
#  else
d777 1
a777 1
#  endif
d788 1
a788 1
	value -= (NV)timebuf.tv_sec;
d847 2
a848 2
	value = (NV)(timebuf.tv_sec) +
		(NV)(timebuf.tv_usec) / 1000000.0;
d854 1
a854 1
    DIE(aTHX_ "select not implemented");
d859 1
a859 1
Perl_setdefout(pTHX_ GV *gv)
d909 1
a909 1
    if (MAXARG == 0)
d913 2
d916 1
a916 1
    if ((mg = SvTIED_mg((SV*)gv, 'q'))) {
d922 1
a922 1
	call_method("GETC", gimme);
d940 1
a940 1
    return pp_sysread();
d944 1
a944 1
S_doform(pTHX_ CV *cv, GV *gv, OP *retop)
d956 1
a956 1
    PUSHBLOCK(cx, CXt_FORMAT, PL_stack_sp);
d958 1
a958 1
    SAVEVPTR(PL_curpad);
d995 1
a995 1
	    DIE(aTHX_ "Undefined format \"%s\" called",SvPVX(tmpsv));
d997 1
a997 1
	DIE(aTHX_ "Not a format reference");
d1031 1
a1031 1
		topname = sv_2mortal(Perl_newSVpvf(aTHX_ "%s_TOP", IoFMT_NAME(io)));
d1071 1
a1071 1
	    DIE(aTHX_ "bad top format reference");
d1076 1
a1076 1
	    DIE(aTHX_ "Undefined top format \"%s\" called",SvPVX(tmpsv));
d1090 5
a1094 10
	if (ckWARN2(WARN_CLOSED,WARN_IO)) {
	    if (IoIFP(io)) {
		SV* sv = sv_newmortal();
		gv_efullname3(sv, gv, Nullch);
		Perl_warner(aTHX_ WARN_IO,
			    "Filehandle %s opened only for input",
			    SvPV_nolen(sv));
	    }
	    else if (ckWARN(WARN_CLOSED))
		report_closed_fh(gv, io, "write", "filehandle");
d1100 2
a1101 2
	    if (ckWARN(WARN_IO))
		Perl_warner(aTHX_ WARN_IO, "page overflow");
d1135 1
a1135 1
    if ((mg = SvTIED_mg((SV*)gv, 'q'))) {
d1146 1
a1146 1
	call_method("PRINTF", G_SCALAR);
d1157 3
a1159 4
	if (ckWARN(WARN_UNOPENED)) {
	    gv_efullname3(sv, gv, Nullch);
	    Perl_warner(aTHX_ WARN_UNOPENED,
			"Filehandle %s never opened", SvPV(sv,n_a));
d1165 6
a1170 9
	if (ckWARN2(WARN_CLOSED,WARN_IO))  {
	    if (IoIFP(io)) {
		gv_efullname3(sv, gv, Nullch);
		Perl_warner(aTHX_ WARN_IO,
			    "Filehandle %s opened only for input",
			    SvPV(sv,n_a));
	    }
	    else if (ckWARN(WARN_CLOSED))
		report_closed_fh(gv, io, "printf", "filehandle");
d1176 6
a1218 2
    /* Need TIEHANDLE method ? */

d1252 1
a1252 1
	call_method("READ", G_SCALAR);
d1269 1
a1269 1
	DIE(aTHX_ "Negative length");
a1285 8
#ifdef OS2	/* At least Warp3+IAK: only the first byte of bufsize set */
	if (bufsize >= 256)
	    bufsize = 255;
#endif
#ifdef OS2	/* At least Warp3+IAK: only the first byte of bufsize set */
	if (bufsize >= 256)
	    bufsize = 255;
#endif
d1306 1
a1306 1
	DIE(aTHX_ PL_no_sock_func, "recv");
d1310 1
a1310 1
	    DIE(aTHX_ "Offset outside string");
d1351 1
a1351 9
    if (length < 0) {
	if ((IoTYPE(io) == '>' || IoIFP(io) == PerlIO_stdout()
	    || IoIFP(io) == PerlIO_stderr()) && ckWARN(WARN_IO))
	{
	    SV* sv = sv_newmortal();
	    gv_efullname3(sv, gv, Nullch);
	    Perl_warner(aTHX_ WARN_IO, "Filehandle %s opened only for output",
			SvPV_nolen(sv));
	}
a1352 1
    }
d1377 1
a1377 1
	PUSHs(sv);
d1380 1
a1380 1
    return pp_send();
d1388 1
d1391 1
a1391 3
    Size_t length;
    SSize_t retval;
    IV offset;
d1402 1
a1402 1
	call_method("WRITE", G_SCALAR);
d1414 3
a1416 7
#if Size_t_size > IVSIZE
    length = (Size_t)SvNVx(*++MARK);
#else
    length = (Size_t)SvIVx(*++MARK);
#endif
    if ((SSize_t)length < 0)
	DIE(aTHX_ "Negative length");
d1420 2
a1421 2
	retval = -1;
	if (ckWARN(WARN_CLOSED)) {
d1423 1
a1423 1
		report_closed_fh(gv, io, "syswrite", "filehandle");
d1425 1
a1425 1
		report_closed_fh(gv, io, "send", "socket");
d1433 1
a1433 1
		    DIE(aTHX_ "Offset outside string");
d1436 1
a1436 1
		DIE(aTHX_ "Offset outside string");
d1443 1
a1443 1
	    retval = PerlSock_send(PerlIO_fileno(IoIFP(io)),
d1449 1
a1449 2
	    /* See the note at doio.c:do_print about filesize limits. --jhi */
	    retval = PerlLIO_write(PerlIO_fileno(IoIFP(io)),
d1458 2
a1459 2
	retval = PerlSock_sendto(PerlIO_fileno(IoIFP(io)), buffer, blen,
				 length, (struct sockaddr *)sockbuf, mlen);
d1462 1
a1462 1
	retval = PerlSock_send(PerlIO_fileno(IoIFP(io)), buffer, blen, length);
d1466 1
a1466 1
	DIE(aTHX_ PL_no_sock_func, "send");
d1468 1
a1468 1
    if (retval < 0)
d1471 1
a1471 5
#if Size_t_size > IVSIZE
    PUSHn(retval);
#else
    PUSHi(retval);
#endif
d1481 1
a1481 1
    return pp_sysread();
a1487 1
    MAGIC *mg;
d1489 2
a1490 20
    if (MAXARG == 0) {
	if (PL_op->op_flags & OPf_SPECIAL) {	/* eof() */
	    IO *io;
	    gv = PL_last_in_gv = PL_argvgv;
	    io = GvIO(gv);
	    if (io && !IoIFP(io)) {
		if ((IoFLAGS(io) & IOf_START) && av_len(GvAVn(gv)) < 0) {
		    IoLINES(io) = 0;
		    IoFLAGS(io) &= ~IOf_START;
		    do_open(gv, "-", 1, FALSE, O_RDONLY, 0, Nullfp);
		    sv_setpvn(GvSV(gv), "-", 1);
		    SvSETMAGIC(GvSV(gv));
		}
		else if (!nextargv(gv))
		    RETPUSHYES;
	    }
	}
	else
	    gv = PL_last_in_gv;			/* eof */
    }
d1492 1
a1492 13
	gv = PL_last_in_gv = (GV*)POPs;		/* eof(FH) */

    if (gv && (mg = SvTIED_mg((SV*)gv, 'q'))) {
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)gv, mg));
	PUTBACK;
	ENTER;
	call_method("EOF", G_SCALAR);
	LEAVE;
	SPAGAIN;
	RETURN;
    }

d1500 1
a1500 2
    GV *gv;     
    MAGIC *mg;
d1502 1
a1502 1
    if (MAXARG == 0)
a1505 15

    if (gv && (mg = SvTIED_mg((SV*)gv, 'q'))) {
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)gv, mg));
	PUTBACK;
	ENTER;
	call_method("TELL", G_SCALAR);
	LEAVE;
	SPAGAIN;
	RETURN;
    }

#if LSEEKSIZE > IVSIZE
    PUSHn( do_tell(gv) );
#else
a1506 1
#endif
d1512 1
a1512 1
    return pp_sysseek();
d1520 1
a1520 6
#if LSEEKSIZE > IVSIZE
    Off_t offset = (Off_t)SvNVx(POPs);
#else
    Off_t offset = (Off_t)SvIVx(POPs);
#endif
    MAGIC *mg;
a1522 18

    if (gv && (mg = SvTIED_mg((SV*)gv, 'q'))) {
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)gv, mg));
#if LSEEKSIZE > IVSIZE
	XPUSHs(sv_2mortal(newSVnv((NV) offset)));
#else
	XPUSHs(sv_2mortal(newSViv(offset)));
#endif
	XPUSHs(sv_2mortal(newSViv(whence)));
	PUTBACK;
	ENTER;
	call_method("SEEK", G_SCALAR);
	LEAVE;
	SPAGAIN;
	RETURN;
    }

d1526 4
a1529 13
	Off_t sought = do_sysseek(gv, offset, whence);
        if (sought < 0)
            PUSHs(&PL_sv_undef);
        else {
            SV* sv = sought ?
#if LSEEKSIZE > IVSIZE
                newSVnv((NV)sought)
#else
                newSViv(sought)
#endif
                : newSVpvn(zero_but_true, ZBTLEN);
            PUSHs(sv_2mortal(sv));
        }
d1537 1
a1537 6
    /* There seems to be no consensus on the length type of truncate()
     * and ftruncate(), both off_t and size_t have supporters. In
     * general one would think that when using large files, off_t is
     * at least as wide as size_t, so using an off_t should be okay. */
    /* XXX Configure probe for the length type of *truncate() needed XXX */
    Off_t len;
a1541 8
#if Size_t_size > IVSIZE
    len = (Off_t)POPn;
#else
    len = (Off_t)POPi;
#endif
    /* Checking for length < 0 is problematic as the type might or
     * might not be signed: if it is not, clever compilers will moan. */ 
    /* XXX Configure probe for the signedness of the length type of *truncate() needed? XXX */
d1548 1
a1548 4
	if (!GvIO(tmpgv) || !IoIFP(GvIOp(tmpgv)))
	    result = 0;
	else {
	    PerlIO_flush(IoIFP(GvIOp(tmpgv)));
d1550 1
a1550 1
	    if (ftruncate(PerlIO_fileno(IoIFP(GvIOn(tmpgv))), len) < 0)
d1552 1
a1552 1
	    if (my_chsize(PerlIO_fileno(IoIFP(GvIOn(tmpgv))), len) < 0)
d1554 1
a1554 2
		result = 0;
	}
a1558 1
	STRLEN n_a;
d1594 1
a1594 1
    DIE(aTHX_ "truncate not implemented");
d1600 1
a1600 1
    return pp_ioctl();
d1633 1
a1633 1
	s = INT2PTR(char*,retval);		/* ouch */
d1642 1
a1642 1
	DIE(aTHX_ "ioctl is not implemented");
d1652 1
a1652 1
	DIE(aTHX_ "fcntl is not implemented");
d1657 2
a1658 2
	    DIE(aTHX_ "Possible memory corruption: %s overflowed 3rd argument",
		PL_op_name[optype]);
d1684 1
a1684 1
    if (MAXARG == 0)
d1696 1
a1696 1
    else {
a1697 4
	SETERRNO(EBADF,RMS$_IFI);
	if (ckWARN(WARN_CLOSED))
	    report_closed_fh(gv, GvIO(gv), "flock", "filehandle");
    }
d1701 1
a1701 1
    DIE(aTHX_ PL_no_func, "flock()");
a1741 3
#if defined(HAS_FCNTL) && defined(F_SETFD)
    fcntl(fd, F_SETFD, fd > PL_maxsysfd);	/* ensure close-on-exec */
#endif
d1745 1
a1745 1
    DIE(aTHX_ PL_no_sock_func, "socket");
a1791 4
#if defined(HAS_FCNTL) && defined(F_SETFD)
    fcntl(fd[0],F_SETFD,fd[0] > PL_maxsysfd);	/* ensure close-on-exec */
    fcntl(fd[1],F_SETFD,fd[1] > PL_maxsysfd);	/* ensure close-on-exec */
#endif
d1795 1
a1795 1
    DIE(aTHX_ PL_no_sock_func, "socketpair");
d1849 2
a1850 2
    if (ckWARN(WARN_CLOSED))
	report_closed_fh(gv, io, "bind", "socket");
d1854 1
a1854 1
    DIE(aTHX_ PL_no_sock_func, "bind");
d1879 2
a1880 2
    if (ckWARN(WARN_CLOSED))
	report_closed_fh(gv, io, "connect", "socket");
d1884 1
a1884 1
    DIE(aTHX_ PL_no_sock_func, "connect");
d1905 2
a1906 2
    if (ckWARN(WARN_CLOSED))
	report_closed_fh(gv, io, "listen", "socket");
d1910 1
a1910 1
    DIE(aTHX_ PL_no_sock_func, "listen");
a1953 3
#if defined(HAS_FCNTL) && defined(F_SETFD)
    fcntl(fd, F_SETFD, fd > PL_maxsysfd);	/* ensure close-on-exec */
#endif
d1959 2
a1960 2
    if (ckWARN(WARN_CLOSED))
	report_closed_fh(ggv, ggv ? GvIO(ggv) : 0, "accept", "socket");
d1967 1
a1967 1
    DIE(aTHX_ PL_no_sock_func, "accept");
d1986 2
a1987 2
    if (ckWARN(WARN_CLOSED))
	report_closed_fh(gv, io, "shutdown", "socket");
d1991 1
a1991 1
    DIE(aTHX_ PL_no_sock_func, "shutdown");
d1998 1
a1998 1
    return pp_ssockopt();
d2000 1
a2000 1
    DIE(aTHX_ PL_no_sock_func, "getsockopt");
d2065 2
a2066 4
    if (ckWARN(WARN_CLOSED))
	report_closed_fh(gv, io,
			 optype == OP_GSOCKOPT ? "getsockopt" : "setsockopt",
			 "socket");
d2072 1
a2072 1
    DIE(aTHX_ PL_no_sock_func, "setsockopt");
d2079 1
a2079 1
    return pp_getpeername();
d2081 1
a2081 1
    DIE(aTHX_ PL_no_sock_func, "getsockname");
d2138 2
a2139 5
    if (ckWARN(WARN_CLOSED))
	report_closed_fh(gv, io,
			 optype == OP_GETSOCKNAME ? "getsockname"
						  : "getpeername",
			 "socket");
d2145 1
a2145 1
    DIE(aTHX_ PL_no_sock_func, "getpeername");
d2153 1
a2153 1
    return pp_stat();
d2165 1
a2165 1
	tmpgv = cGVOP_gv;
d2197 2
a2198 2
	    if (ckWARN(WARN_NEWLINE) && strchr(SvPV(PL_statname, n_a), '\n'))
		Perl_warner(aTHX_ WARN_NEWLINE, PL_warn_nl, "stat");
d2212 6
a2217 22
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_dev)));
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_ino)));
	PUSHs(sv_2mortal(newSVuv(PL_statcache.st_mode)));
	PUSHs(sv_2mortal(newSVuv(PL_statcache.st_nlink)));
#if Uid_t_size > IVSIZE
	PUSHs(sv_2mortal(newSVnv(PL_statcache.st_uid)));
#else
#   if Uid_t_sign <= 0
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_uid)));
#   else
	PUSHs(sv_2mortal(newSVuv(PL_statcache.st_uid)));
#   endif
#endif
#if Gid_t_size > IVSIZE 
	PUSHs(sv_2mortal(newSVnv(PL_statcache.st_gid)));
#else
#   if Gid_t_sign <= 0
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_gid)));
#   else
	PUSHs(sv_2mortal(newSVuv(PL_statcache.st_gid)));
#   endif
#endif
d2219 1
a2219 6
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_rdev)));
#else
	PUSHs(sv_2mortal(newSVpvn("", 0)));
#endif
#if Off_t_size > IVSIZE
	PUSHs(sv_2mortal(newSVnv(PL_statcache.st_size)));
d2221 1
a2221 1
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_size)));
d2223 1
d2225 7
a2231 7
	PUSHs(sv_2mortal(newSVnv(PL_statcache.st_atime)));
	PUSHs(sv_2mortal(newSVnv(PL_statcache.st_mtime)));
	PUSHs(sv_2mortal(newSVnv(PL_statcache.st_ctime)));
#else
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_atime)));
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_mtime)));
	PUSHs(sv_2mortal(newSViv(PL_statcache.st_ctime)));
d2234 2
a2235 2
	PUSHs(sv_2mortal(newSVuv(PL_statcache.st_blksize)));
	PUSHs(sv_2mortal(newSVuv(PL_statcache.st_blocks)));
d2237 2
a2238 2
	PUSHs(sv_2mortal(newSVpvn("", 0)));
	PUSHs(sv_2mortal(newSVpvn("", 0)));
d2246 1
a2246 1
    I32 result;
a2247 16
#if defined(HAS_ACCESS) && defined(R_OK)
    STRLEN n_a;
    if ((PL_hints & HINT_FILETEST_ACCESS) && SvPOK(TOPs)) {
	result = access(TOPpx, R_OK);
	if (result == 0)
	    RETPUSHYES;
	if (result < 0)
	    RETPUSHUNDEF;
	RETPUSHNO;
    }
    else
	result = my_stat();
#else
    result = my_stat();
#endif
    SPAGAIN;
d2257 1
a2257 1
    I32 result;
a2258 16
#if defined(HAS_ACCESS) && defined(W_OK)
    STRLEN n_a;
    if ((PL_hints & HINT_FILETEST_ACCESS) && SvPOK(TOPs)) {
	result = access(TOPpx, W_OK);
	if (result == 0)
	    RETPUSHYES;
	if (result < 0)
	    RETPUSHUNDEF;
	RETPUSHNO;
    }
    else
	result = my_stat();
#else
    result = my_stat();
#endif
    SPAGAIN;
d2268 1
a2268 1
    I32 result;
a2269 16
#if defined(HAS_ACCESS) && defined(X_OK)
    STRLEN n_a;
    if ((PL_hints & HINT_FILETEST_ACCESS) && SvPOK(TOPs)) {
	result = access(TOPpx, X_OK);
	if (result == 0)
	    RETPUSHYES;
	if (result < 0)
	    RETPUSHUNDEF;
	RETPUSHNO;
    }
    else
	result = my_stat();
#else
    result = my_stat();
#endif
    SPAGAIN;
d2279 1
a2279 1
    I32 result;
a2280 16
#ifdef PERL_EFF_ACCESS_R_OK
    STRLEN n_a;
    if ((PL_hints & HINT_FILETEST_ACCESS) && SvPOK(TOPs)) {
	result = PERL_EFF_ACCESS_R_OK(TOPpx);
	if (result == 0)
	    RETPUSHYES;
	if (result < 0)
	    RETPUSHUNDEF;
	RETPUSHNO;
    }
    else
	result = my_stat();
#else
    result = my_stat();
#endif
    SPAGAIN;
d2290 1
a2290 1
    I32 result;
a2291 16
#ifdef PERL_EFF_ACCESS_W_OK
    STRLEN n_a;
    if ((PL_hints & HINT_FILETEST_ACCESS) && SvPOK(TOPs)) {
	result = PERL_EFF_ACCESS_W_OK(TOPpx);
	if (result == 0)
	    RETPUSHYES;
	if (result < 0)
	    RETPUSHUNDEF;
	RETPUSHNO;
    }
    else
	result = my_stat();
#else
    result = my_stat();
#endif
    SPAGAIN;
d2301 1
a2301 1
    I32 result;
a2302 16
#ifdef PERL_EFF_ACCESS_X_OK
    STRLEN n_a;
    if ((PL_hints & HINT_FILETEST_ACCESS) && SvPOK(TOPs)) {
	result = PERL_EFF_ACCESS_X_OK(TOPpx);
	if (result == 0)
	    RETPUSHYES;
	if (result < 0)
	    RETPUSHUNDEF;
	RETPUSHNO;
    }
    else
	result = my_stat();
#else
    result = my_stat();
#endif
    SPAGAIN;
d2312 1
a2312 1
    I32 result = my_stat();
d2321 1
a2321 1
    return pp_ftrowned();
d2326 1
a2326 1
    I32 result = my_stat();
d2330 1
a2330 2
    if (PL_statcache.st_uid == (PL_op->op_type == OP_FTEOWNED ?
				PL_euid : PL_uid) )
d2337 1
a2337 1
    I32 result = my_stat();
d2341 1
a2341 1
    if (PL_statcache.st_size == 0)
d2348 1
a2348 1
    I32 result = my_stat();
a2351 3
#if Off_t_size > IVSIZE
    PUSHn(PL_statcache.st_size);
#else
a2352 1
#endif
d2358 1
a2358 1
    I32 result = my_stat();
d2362 1
a2362 1
    PUSHn( (PL_basetime - PL_statcache.st_mtime) / 86400.0 );
d2368 1
a2368 1
    I32 result = my_stat();
d2372 1
a2372 1
    PUSHn( (PL_basetime - PL_statcache.st_atime) / 86400.0 );
d2378 1
a2378 1
    I32 result = my_stat();
d2382 1
a2382 1
    PUSHn( (PL_basetime - PL_statcache.st_ctime) / 86400.0 );
d2388 1
a2388 1
    I32 result = my_stat();
d2399 1
a2399 1
    I32 result = my_stat();
d2410 1
a2410 1
    I32 result = my_stat();
d2421 1
a2421 1
    I32 result = my_stat();
d2432 1
a2432 1
    I32 result = my_stat();
d2443 1
a2443 1
    I32 result = my_stat();
d2454 1
a2454 1
    I32 result = my_lstat();
d2467 1
a2467 1
    I32 result = my_stat();
d2481 1
a2481 1
    I32 result = my_stat();
d2495 1
a2495 1
    I32 result = my_stat();
d2514 1
a2514 1
	gv = cGVOP_gv;
a2552 1
    PerlIO *fp;
d2555 1
a2555 1
	gv = cGVOP_gv;
d2581 1
a2581 1
		DIE(aTHX_ "-T and -B not implemented on filehandles");
d2604 3
a2606 5
	    if (ckWARN(WARN_UNOPENED)) {
		gv = cGVOP_gv;
		Perl_warner(aTHX_ WARN_UNOPENED, "Test on unopened file <%s>",
			    GvENAME(gv));
	    }
d2617 8
a2624 3
	if (!(fp = PerlIO_open(SvPVX(PL_statname), "r"))) {
	    if (ckWARN(WARN_NEWLINE) && strchr(SvPV(sv, n_a), '\n'))
		Perl_warner(aTHX_ WARN_NEWLINE, PL_warn_nl, "open");
d2627 2
a2628 3
	PL_laststatval = PerlLIO_fstat(PerlIO_fileno(fp), &PL_statcache);
	if (PL_laststatval < 0)	{
	    (void)PerlIO_close(fp);
d2630 2
a2631 4
	}
	do_binmode(fp, '<', TRUE);
	len = PerlIO_read(fp, tbuf, sizeof(tbuf));
	(void)PerlIO_close(fp);
a2642 6
#if defined(DOSISH) || defined(USEMYBINMODE)
    /* ignore trailing ^Z on short files */
    if (len && len < sizeof(tbuf) && tbuf[len-1] == 26)
	--len;
#endif

d2652 1
a2652 21
	else if (*s & 128) {
#ifdef USE_LOCALE
	    if ((PL_op->op_private & OPpLOCALE) && isALPHA_LC(*s))
		continue;
#endif
	    /* utf8 characters don't count as odd */
	    if (*s & 0x40) {
		int ulen = UTF8SKIP(s);
		if (ulen < len - i) {
		    int j;
		    for (j = 1; j < ulen; j++) {
			if ((s[j] & 0xc0) != 0x80)
			    goto not_utf8;
		    }
		    --ulen;	/* loop does extra increment */
		    s += ulen;
		    i += ulen;
		    continue;
		}
	    }
	  not_utf8:
a2653 1
	}
d2669 1
a2669 1
    return pp_fttext();
d2722 1
a2722 1
    DIE(aTHX_ PL_no_func, "Unsupported function chown");
d2730 1
a2731 1
    STRLEN n_a;
d2737 1
a2737 1
    DIE(aTHX_ PL_no_func, "chroot");
d2806 1
a2806 1
    SETi( PerlLIO_link(tmps, tmps2) >= 0 );
d2808 1
a2808 1
    DIE(aTHX_ PL_no_func, "Unsupported function link");
d2824 1
a2824 1
    DIE(aTHX_ PL_no_func, "symlink");
d2854 4
a2857 2
STATIC int
S_dooneliner(pTHX_ char *cmd, char *filename)
d2945 1
a2945 1
    int mode;
d2950 1
a2950 8
    char *tmps;

    if (MAXARG > 1)
	mode = POPi;
    else
	mode = 0777;

    tmps = SvPV(TOPs, n_a);
d3005 1
a3005 1
    DIE(aTHX_ PL_no_dir_func, "opendir");
d3014 1
a3014 1
    Direntry_t *readdir (DIR *);
d3026 1
a3026 1
	while ((dp = (Direntry_t *)PerlDir_read(IoDIRP(io)))) {
d3028 1
a3028 1
	    sv = newSVpvn(dp->d_name, dp->d_namlen);
d3033 1
a3033 2
	    if (!(IoFLAGS(io) & IOf_UNTAINT))
		SvTAINTED_on(sv);
d3042 1
a3042 1
	sv = newSVpvn(dp->d_name, dp->d_namlen);
d3047 1
a3047 2
	if (!(IoFLAGS(io) & IOf_UNTAINT))
	    SvTAINTED_on(sv);
d3061 1
a3061 1
    DIE(aTHX_ PL_no_dir_func, "readdir");
d3069 2
a3070 6
 /* XXX does _anyone_ need this? --AD 2/20/1998 */
 /* XXX netbsd still seemed to.
    XXX HAS_TELLDIR_PROTO is new style, NEED_TELLDIR_PROTO is old style.
    --JHI 1999-Feb-02 */
# if !defined(HAS_TELLDIR_PROTO) || defined(NEED_TELLDIR_PROTO)
    long telldir (DIR *);
d3085 1
a3085 1
    DIE(aTHX_ PL_no_dir_func, "telldir");
d3108 1
a3108 1
    DIE(aTHX_ PL_no_dir_func, "seekdir");
d3129 1
a3129 1
    DIE(aTHX_ PL_no_dir_func, "rewinddir");
d3159 1
a3159 1
    DIE(aTHX_ PL_no_dir_func, "closedir");
d3169 1
a3169 1
    Pid_t childpid;
a3172 1
    PERL_FLUSHALL_FOR_CHILD;
d3178 2
a3179 2
	if ((tmpgv = gv_fetchpv("$", TRUE, SVt_PV)))
	    sv_setiv(GvSV(tmpgv), (IV)PerlProc_getpid());
d3185 1
a3185 12
#  if defined(USE_ITHREADS) && defined(PERL_IMPLICIT_SYS)
    djSP; dTARGET;
    Pid_t childpid;

    EXTEND(SP, 1);
    PERL_FLUSHALL_FOR_CHILD;
    childpid = PerlProc_fork();
    PUSHi(childpid);
    RETURN;
#  else
    DIE(aTHX_ PL_no_func, "Unsupported function fork");
#  endif
d3191 1
a3191 1
#if (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(MACOS_TRADITIONAL) 
d3193 1
a3193 1
    Pid_t childpid;
d3201 1
a3201 1
    DIE(aTHX_ PL_no_func, "Unsupported function wait");
d3207 1
a3207 1
#if (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(MACOS_TRADITIONAL) 
d3209 1
a3209 1
    Pid_t childpid;
d3220 1
a3220 1
    DIE(aTHX_ PL_no_func, "Unsupported function waitpid");
d3228 1
a3228 1
    Pid_t childpid;
a3232 2
    I32 did_pipes = 0;
    int pp[2];
a3240 1
    PERL_FLUSHALL_FOR_CHILD;
a3241 2
    if (PerlProc_pipe(pp) >= 0)
	did_pipes = 1;
a3246 4
	    if (did_pipes) {
		PerlLIO_close(pp[0]);
		PerlLIO_close(pp[1]);
	    }
a3251 2
	if (did_pipes)
	    PerlLIO_close(pp[1]);
a3261 20
	if (did_pipes) {
	    int errkid;
	    int n = 0, n1;

	    while (n < sizeof(int)) {
		n1 = PerlLIO_read(pp[0],
				  (void*)(((char*)&errkid)+n),
				  (sizeof(int)) - n);
		if (n1 <= 0)
		    break;
		n += n1;
	    }
	    PerlLIO_close(pp[0]);
	    if (n) {			/* Error */
		if (n != sizeof(int))
		    DIE(aTHX_ "panic: kid popen errno read");
		errno = errkid;		/* Propagate errno from kid */
		STATUS_CURRENT = -1;
	    }
	}
a3264 6
    if (did_pipes) {
	PerlLIO_close(pp[0]);
#if defined(HAS_FCNTL) && defined(F_SETFD)
	fcntl(pp[1], F_SETFD, FD_CLOEXEC);
#endif
    }
d3267 1
a3267 1
	value = (I32)do_aexec5(really, MARK, SP, pp[1], did_pipes);
d3270 1
a3270 1
	value = (I32)do_aexec5(Nullsv, MARK, SP, pp[1], did_pipes);
d3272 1
a3272 1
	value = (I32)do_exec3(SvPVx(sv_mortalcopy(*SP), n_a), pp[1], did_pipes);
a3298 1
    PERL_FLUSHALL_FOR_CHILD;
a3306 6
#  ifdef __OPEN_VM
	{
	   (void ) do_aspawn(Nullsv, MARK, SP);
	   value = 0;
	}
#  else
a3307 1
#  endif
a3317 4
#  ifdef __OPEN_VM
	(void) do_spawn(SvPVx(sv_mortalcopy(*SP), n_a));
	value = 0;
#  else
a3318 1
#  endif
a3320 6

#if !defined(HAS_FORK) && defined(USE_ITHREADS) && defined(PERL_IMPLICIT_SYS)
    if (value >= 0)
	my_exit(value);
#endif

d3336 1
a3336 1
    DIE(aTHX_ PL_no_func, "Unsupported function kill");
d3347 1
a3347 1
    DIE(aTHX_ PL_no_func, "getppid");
d3355 2
a3356 2
    Pid_t pid;
    Pid_t pgrp;
d3363 1
a3363 1
    pgrp = (I32)BSD_GETPGRP(pid);
d3365 3
a3367 3
    if (pid != 0 && pid != PerlProc_getpid())
	DIE(aTHX_ "POSIX getpgrp can't take an argument");
    pgrp = getpgrp();
d3369 1
a3369 1
    XPUSHi(pgrp);
d3372 1
a3372 1
    DIE(aTHX_ PL_no_func, "getpgrp()");
d3380 2
a3381 2
    Pid_t pgrp;
    Pid_t pid;
d3395 2
a3396 5
    if ((pgrp != 0 && pgrp != PerlProc_getpid())
	|| (pid != 0 && pid != PerlProc_getpid()))
    {
	DIE(aTHX_ "setpgrp can't take arguments");
    }
d3401 1
a3401 1
    DIE(aTHX_ PL_no_func, "setpgrp()");
d3416 1
a3416 1
    DIE(aTHX_ PL_no_func, "getpriority()");
d3434 1
a3434 1
    DIE(aTHX_ PL_no_func, "setpriority()");
d3472 1
a3472 1
    DIE(aTHX_ "times not implemented");
d3484 1
a3484 1
    PUSHs(sv_2mortal(newSVnv(((NV)PL_timesbuf.tms_utime)/HZ)));
d3486 3
a3488 3
	PUSHs(sv_2mortal(newSVnv(((NV)PL_timesbuf.tms_stime)/HZ)));
	PUSHs(sv_2mortal(newSVnv(((NV)PL_timesbuf.tms_cutime)/HZ)));
	PUSHs(sv_2mortal(newSVnv(((NV)PL_timesbuf.tms_cstime)/HZ)));
d3496 1
a3496 1
    return pp_gmtime();
d3525 1
d3529 8
a3536 8
	tsv = Perl_newSVpvf(aTHX_ "%s %s %2d %02d:%02d:%02d %d",
			    dayname[tmbuf->tm_wday],
			    monname[tmbuf->tm_mon],
			    tmbuf->tm_mday,
			    tmbuf->tm_hour,
			    tmbuf->tm_min,
			    tmbuf->tm_sec,
			    tmbuf->tm_year + 1900);
d3540 9
a3548 9
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_sec)));
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_min)));
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_hour)));
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_mday)));
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_mon)));
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_year)));
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_wday)));
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_yday)));
	PUSHs(sv_2mortal(newSViv(tmbuf->tm_isdst)));
d3563 1
a3563 1
    PUSHi(anum);
d3566 1
a3566 1
    DIE(aTHX_ PL_no_func, "Unsupported function alarm");
d3593 1
a3593 1
    return pp_semget();
d3598 1
a3598 1
    return pp_semctl();
d3603 1
a3603 1
    return pp_shmwrite();
d3615 1
a3615 1
    return pp_semget();
d3623 1
a3623 1
    return pp_semget();
d3628 1
a3628 1
    return pp_semctl();
d3640 1
a3640 1
    return pp_semget();
d3653 1
a3653 1
    return pp_semget();
d3670 1
a3670 1
    DIE(aTHX_ "System V IPC is not implemented on this machine");
d3690 1
a3690 1
    return pp_semget();
d3703 1
a3703 1
    return pp_semget();
d3712 1
a3712 1
    return pp_ghostent();
d3714 1
a3714 1
    DIE(aTHX_ PL_no_sock_func, "gethostbyname");
d3721 1
a3721 1
    return pp_ghostent();
d3723 1
a3723 1
    DIE(aTHX_ PL_no_sock_func, "gethostbyaddr");
a3740 1
    STRLEN n_a;
d3743 1
a3743 1
    if (which == OP_GHBYNAME)
d3745 1
d3748 1
a3748 1
	DIE(aTHX_ PL_no_sock_func, "gethostbyname");
d3750 1
d3760 1
a3760 1
	DIE(aTHX_ PL_no_sock_func, "gethostbyaddr");
d3767 1
a3767 1
	DIE(aTHX_ PL_no_sock_func, "gethostent");
d3815 1
a3815 1
    DIE(aTHX_ PL_no_sock_func, "gethostent");
d3822 1
a3822 1
    return pp_gnetent();
d3824 1
a3824 1
    DIE(aTHX_ PL_no_sock_func, "getnetbyname");
d3831 1
a3831 1
    return pp_gnetent();
d3833 1
a3833 1
    DIE(aTHX_ PL_no_sock_func, "getnetbyaddr");
a3849 1
    STRLEN n_a;
d3851 1
a3851 1
    if (which == OP_GNBYNAME)
d3853 1
d3856 1
a3856 1
        DIE(aTHX_ PL_no_sock_func, "getnetbyname");
d3858 1
d3865 1
a3865 1
	DIE(aTHX_ PL_no_sock_func, "getnetbyaddr");
d3872 1
a3872 1
        DIE(aTHX_ PL_no_sock_func, "getnetent");
d3904 1
a3904 1
    DIE(aTHX_ PL_no_sock_func, "getnetent");
d3911 1
a3911 1
    return pp_gprotoent();
d3913 1
a3913 1
    DIE(aTHX_ PL_no_sock_func, "getprotobyname");
d3920 1
a3920 1
    return pp_gprotoent();
d3922 1
a3922 1
    DIE(aTHX_ PL_no_sock_func, "getprotobynumber");
a3938 1
    STRLEN n_a;
d3940 1
a3940 1
    if (which == OP_GPBYNAME)
d3942 1
d3945 1
a3945 1
	DIE(aTHX_ PL_no_sock_func, "getprotobyname");
d3947 1
d3952 1
a3952 1
    DIE(aTHX_ PL_no_sock_func, "getprotobynumber");
d3958 1
a3958 1
	DIE(aTHX_ PL_no_sock_func, "getprotoent");
d3988 1
a3988 1
    DIE(aTHX_ PL_no_sock_func, "getprotoent");
d3995 1
a3995 1
    return pp_gservent();
d3997 1
a3997 1
    DIE(aTHX_ PL_no_sock_func, "getservbyname");
d4004 1
a4004 1
    return pp_gservent();
d4006 1
a4006 1
    DIE(aTHX_ PL_no_sock_func, "getservbyport");
a4022 1
    STRLEN n_a;
d4026 1
d4035 1
a4035 1
	DIE(aTHX_ PL_no_sock_func, "getservbyname");
d4040 1
d4049 1
a4049 1
	DIE(aTHX_ PL_no_sock_func, "getservbyport");
d4056 1
a4056 1
	DIE(aTHX_ PL_no_sock_func, "getservent");
d4097 1
a4097 1
    DIE(aTHX_ PL_no_sock_func, "getservent");
d4108 1
a4108 1
    DIE(aTHX_ PL_no_sock_func, "sethostent");
d4119 1
a4119 1
    DIE(aTHX_ PL_no_sock_func, "setnetent");
d4130 1
a4130 1
    DIE(aTHX_ PL_no_sock_func, "setprotoent");
d4141 1
a4141 1
    DIE(aTHX_ PL_no_sock_func, "setservent");
d4153 1
a4153 1
    DIE(aTHX_ PL_no_sock_func, "endhostent");
d4165 1
a4165 1
    DIE(aTHX_ PL_no_sock_func, "endnetent");
d4177 1
a4177 1
    DIE(aTHX_ PL_no_sock_func, "endprotoent");
d4189 1
a4189 1
    DIE(aTHX_ PL_no_sock_func, "endservent");
d4196 1
a4196 1
    return pp_gpwent();
d4198 1
a4198 1
    DIE(aTHX_ PL_no_func, "getpwnam");
d4205 1
a4205 1
    return pp_gpwent();
d4207 1
a4207 1
    DIE(aTHX_ PL_no_func, "getpwuid");
d4214 1
a4214 1
#ifdef HAS_PASSWD
a4218 3
#if defined(HAS_GETSPENT) || defined(HAS_GETSPNAM)
    struct spwd *spwent = NULL;
#endif
a4224 1
#ifdef HAS_GETPWENT
a4225 20
#else
	DIE(aTHX_ PL_no_func, "getpwent");
#endif

#ifdef HAS_GETSPNAM
    if (which == OP_GPWNAM) {
	if (pwent)
	    spwent = getspnam(pwent->pw_name);
    }
#  ifdef HAS_GETSPUID /* AFAIK there isn't any anywhere. --jhi */ 
    else if (which == OP_GPWUID) {
	if (pwent)
	    spwent = getspnam(pwent->pw_name);
    }
#  endif
#  ifdef HAS_GETSPENT
    else
	spwent = (struct spwd *)getspent();
#  endif
#endif
a4231 1
#if Uid_t_sign <= 0
a4232 3
#else
		sv_setuv(sv, (UV)pwent->pw_uid);
#endif
a4244 6
#   if defined(HAS_GETSPENT) || defined(HAS_GETSPNAM)
      if (spwent)
              sv_setpv(sv, spwent->sp_pwdp);
      else
              sv_setpv(sv, pwent->pw_passwd);
#   else
a4245 5
#   endif
#endif
#ifndef INCOMPLETE_TAINTS
	/* passwd is tainted because user himself can diddle with it. */
	SvTAINTED_on(sv);
a4248 1
#if Uid_t_sign <= 0
a4249 3
#else
	sv_setuv(sv, (UV)pwent->pw_uid);
#endif
a4251 1
#if Uid_t_sign <= 0
d4253 1
a4253 3
#else
	sv_setuv(sv, (UV)pwent->pw_gid);
#endif
a4291 4
#ifndef INCOMPLETE_TAINTS
	/* pw_shell is tainted because user himself can diddle with it. */
	SvTAINTED_on(sv);
#endif
d4300 1
a4300 1
    DIE(aTHX_ PL_no_func, "getpwent");
d4307 1
a4307 1
#if defined(HAS_PASSWD) && defined(HAS_SETPWENT)
a4308 3
#   ifdef HAS_SETSPENT
    setspent();
#   endif
d4311 1
a4311 1
    DIE(aTHX_ PL_no_func, "setpwent");
a4319 3
#   ifdef HAS_ENDSPENT
    endspent();
#   endif
d4322 1
a4322 1
    DIE(aTHX_ PL_no_func, "endpwent");
d4329 1
a4329 1
    return pp_ggrent();
d4331 1
a4331 1
    DIE(aTHX_ PL_no_func, "getgrnam");
d4338 1
a4338 1
    return pp_ggrent();
d4340 1
a4340 1
    DIE(aTHX_ PL_no_func, "getgrgid");
d4347 1
a4347 1
#ifdef HAS_GROUP
a4358 1
#ifdef HAS_GETGRENT
a4359 3
#else
        DIE(aTHX_ PL_no_func, "getgrent");
#endif
d4395 1
a4395 1
    DIE(aTHX_ PL_no_func, "getgrent");
d4406 1
a4406 1
    DIE(aTHX_ PL_no_func, "setgrent");
d4417 1
a4417 1
    DIE(aTHX_ PL_no_func, "endgrent");
d4432 1
a4432 1
    DIE(aTHX_ PL_no_func, "getlogin");
d4446 1
a4446 1
    STRLEN n_a;
d4468 2
a4469 1
	else 
d4471 1
d4477 1
a4477 1
	DIE(aTHX_ "Too many args to syscall");
d4479 1
a4479 1
	DIE(aTHX_ "Too few args to syscall");
d4533 1
a4533 1
    DIE(aTHX_ PL_no_func, "syscall");
d4563 1
a4563 1
    flock.l_start = flock.l_len = (Off_t)0;
d4601 3
a4603 1
lockf_emulate_flock(int fd, int operation)
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d24 2
a25 7
 * The API is from SysV.
 *
 * There are at least two more shadow interfaces,
 * see the comments in pp_gpwent().
 *
 * --jhi */
#   ifdef __hpux__
d27 9
a35 4
 * and another MAXINT from "perl.h" <- <sys/param.h>. */
#       undef MAXINT
#   endif
#   include <shadow.h>
d38 2
a39 2
#ifdef HAS_SYSCALL
#ifdef __cplusplus
d52 15
d68 3
a70 3
# ifdef I_SYS_SELECT
#  include <sys/select.h>
# endif
d140 1
a140 1
#  if defined(HAS_FCNTL) && defined(FCNTL_CAN_LOCK)
d198 1
a198 1
#   ifdef I_SYS_SECURITY
d201 1
d302 1
a302 1
    dSP; dTARGET;
d414 1
a414 1
    dSP; dMARK;
d445 1
a445 1
    dSP; dMARK;
d504 1
a504 1
    dSP; dTARGET;
d507 1
a507 1
    SV *name = Nullsv;
d555 1
a555 1
    dSP;
d581 1
a581 1
    dSP;
d611 2
a612 2
    IoTYPE(rstio) = IoTYPE_RDONLY;
    IoTYPE(wstio) = IoTYPE_WRONLY;
d636 1
a636 1
    dSP; dTARGET;
d665 1
a665 1
    dSP; dTARGET;
d690 1
a690 1
    dSP;
d702 1
a702 1
    gv = (GV*)POPs;
d721 1
a721 1
    if (do_binmode(fp,IoTYPE(io),mode_from_discipline(discp)))
d729 1
a729 1
    dSP;
d768 1
a768 1
    }
d776 1
a776 1
		 methname, SvPV(*MARK,n_a));
d803 1
a803 1
    dSP;
d807 1
d810 1
a810 16
	SV *obj = SvRV(mg->mg_obj);
	GV *gv;
	CV *cv = NULL;
	if ((gv = gv_fetchmethod_autoload(SvSTASH(obj), "UNTIE", FALSE)) &&
            isGV(gv) && (cv = GvCV(gv))) {
	    PUSHMARK(SP);
	    XPUSHs(SvTIED_obj((SV*)gv, mg));
	    XPUSHs(sv_2mortal(newSViv(SvREFCNT(obj)-1)));
	    PUTBACK;
	    ENTER;
	    call_sv((SV *)cv, G_VOID);
	    LEAVE;
	    SPAGAIN;
        }
        else if (ckWARN(WARN_UNTIE)) {
	    if (mg && SvREFCNT(obj) > 1)
d813 1
a813 1
		    (UV)SvREFCNT(obj) - 1 ) ;
d816 1
d823 1
a823 1
    dSP;
d840 1
a840 1
    dSP;
d888 1
a888 1
	sv_unmagic((SV *) hv, 'P');
d902 1
a902 1
    dSP; dTARGET;
d1044 1
d1054 1
a1054 1
    dSP; dTARGET;
d1069 1
a1069 1
	    gv_efullname4(TARG, PL_defoutgv, Nullch, TRUE);
d1088 1
a1088 1
    dSP; dTARGET;
d1127 1
d1148 1
a1148 1
    dSP;
a1172 1
        char *name = NULL;
d1175 2
a1176 2
	    gv_efullname4(tmpsv, fgv, Nullch, FALSE);
	    name = SvPV_nolen(tmpsv);
a1177 2
	if (name && *name)
	    DIE(aTHX_ "Undefined format \"%s\" called", name);
d1189 1
a1189 1
    dSP;
d1254 4
a1257 13
	{
	    char *name = NULL;
	    if (!cv) {
	        SV *sv = sv_newmortal();
		gv_efullname4(sv, fgv, Nullch, FALSE);
		name = SvPV_nolen(sv);
	    }
	    if (name && *name)
	        DIE(aTHX_ "Undefined top format \"%s\" called",name);
	    /* why no:
	    else
	        DIE(aTHX_ "Undefined top format called");
	    ?*/
d1273 5
a1277 13
		/* integrate with report_evil_fh()? */
	        char *name = NULL;
		if (isGV(gv)) {
		    SV* sv = sv_newmortal();
		    gv_efullname4(sv, gv, Nullch, FALSE);
		    name = SvPV_nolen(sv);
		}
		if (name && *name)
		    Perl_warner(aTHX_ WARN_IO,
				"Filehandle %s opened only for input", name);
		else
		    Perl_warner(aTHX_ WARN_IO,
				"Filehandle opened only for input");
d1280 1
a1280 1
		report_evil_fh(gv, io, PL_op->op_type);
d1308 1
a1308 1
    dSP; dMARK; dORIGMARK;
d1343 5
a1347 2
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
a1352 1
	    /* integrate with report_evil_fh()? */
d1354 4
a1357 11
	        char *name = NULL;
		if (isGV(gv)) {
		    gv_efullname4(sv, gv, Nullch, FALSE);
		    name = SvPV_nolen(sv);
		}
		if (name && *name)
		    Perl_warner(aTHX_ WARN_IO,
				"Filehandle %s opened only for input", name);
		else
		    Perl_warner(aTHX_ WARN_IO,
				"Filehandle opened only for input");
d1360 1
a1360 1
		report_evil_fh(gv, io, PL_op->op_type);
d1388 1
a1388 1
    dSP;
d1418 1
a1418 1
    dSP; dMARK; dORIGMARK; dTARGET;
d1476 4
a1485 4
#ifdef EPOC
	/* Bogus return without padding */
	bufsize = sizeof (struct sockaddr_in);
#endif
d1514 1
a1514 1
	if (IoTYPE(io) == IoTYPE_SOCKET) {
d1527 1
a1527 1
    if (IoTYPE(io) == IoTYPE_SOCKET) {
d1546 1
a1546 1
	if ((IoTYPE(io) == IoTYPE_WRONLY || IoIFP(io) == PerlIO_stdout()
d1549 4
a1552 13
	    /* integrate with report_evil_fh()? */
	    char *name = NULL;
	    if (isGV(gv)) {
		SV* sv = sv_newmortal();
		gv_efullname4(sv, gv, Nullch, FALSE);
		name = SvPV_nolen(sv);
	    }
	    if (name && *name)
		Perl_warner(aTHX_ WARN_IO,
			    "Filehandle %s opened only for output", name);
	    else
		Perl_warner(aTHX_ WARN_IO,
			    "Filehandle opened only for output");
d1574 1
a1574 1
    dSP;
d1588 1
a1588 1
    dSP; dMARK; dORIGMARK; dTARGET;
d1629 6
a1634 2
	if (ckWARN(WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
d1650 1
a1650 1
	if (IoTYPE(io) == IoTYPE_SOCKET) {
d1699 1
a1699 1
    dSP;
d1743 2
a1744 2
    dSP; dTARGET;
    GV *gv;
d1778 1
a1778 1
    dSP;
d1829 1
a1829 1
    dSP;
d1846 1
a1846 1
     * might not be signed: if it is not, clever compilers will moan. */
d1860 1
a1860 1
#else
d1916 1
a1916 1
    dSP; dTARGET;
d1961 1
a1961 1
#endif
d1987 1
a1987 1
    dSP; dTARGET;
a1990 1
    IO *io = NULL;
d1999 3
a2001 3
    if (gv && (io = GvIO(gv)))
	fp = IoIFP(io);
    else {
a2002 2
	io = NULL;
    }
a2007 2
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
d2010 2
d2024 1
a2024 1
    dSP;
d2050 1
a2050 1
    IoTYPE(io) = IoTYPE_SOCKET;
a2060 4
#ifdef EPOC
    setbuf( IoIFP(io), NULL); /* EPOC gets confused about sockets */
#endif

d2069 1
a2069 1
    dSP;
d2097 1
a2097 1
    IoTYPE(io1) = IoTYPE_SOCKET;
d2100 1
a2100 1
    IoTYPE(io2) = IoTYPE_SOCKET;
d2123 1
a2123 1
    dSP;
d2172 1
a2172 1
	report_evil_fh(gv, io, PL_op->op_type);
d2182 1
a2182 1
    dSP;
d2202 1
a2202 1
	report_evil_fh(gv, io, PL_op->op_type);
d2212 1
a2212 1
    dSP;
d2228 1
a2228 1
	report_evil_fh(gv, io, PL_op->op_type);
d2238 1
a2238 1
    dSP; dTARGET;
d2269 1
a2269 1
    IoTYPE(nstio) = IoTYPE_SOCKET;
a2279 5
#ifdef EPOC
    len = sizeof saddr;          /* EPOC somehow truncates info */
    setbuf( IoIFP(nstio), NULL); /* EPOC gets confused about sockets */
#endif

d2285 1
a2285 1
	report_evil_fh(ggv, ggv ? GvIO(ggv) : 0, PL_op->op_type);
d2298 1
a2298 1
    dSP; dTARGET;
d2312 1
a2312 1
	report_evil_fh(gv, io, PL_op->op_type);
d2331 1
a2331 1
    dSP;
d2391 3
a2393 1
	report_evil_fh(gv, io, optype);
d2414 1
a2414 1
    dSP;
d2447 1
a2447 1
		goto nuts2;	
d2466 4
a2469 1
	report_evil_fh(gv, io, optype);
d2488 2
a2489 2
    dSP;
    GV *gv;
d2495 1
a2495 1
	gv = cGVOP_gv;
d2497 1
a2497 1
	if (gv != PL_defgv) {
d2499 1
a2499 1
	    PL_statgv = gv;
d2501 2
a2502 2
	    PL_laststatval = (GvIO(gv) && IoIFP(GvIOp(gv))
		? PerlLIO_fstat(PerlIO_fileno(IoIFP(GvIOn(gv))), &PL_statcache) : -1);
d2504 1
a2504 3
	if (PL_laststatval < 0) {
	    if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
		report_evil_fh(gv, GvIO(gv), PL_op->op_type);
a2505 1
	}
d2510 1
a2510 1
	    gv = (GV*)sv;
d2514 1
a2514 1
	    gv = (GV*)SvRV(sv);
d2555 1
a2555 1
#if Gid_t_size > IVSIZE
d2597 1
a2597 1
    dSP;
d2624 1
a2624 1
    dSP;
d2651 1
a2651 1
    dSP;
d2678 1
a2678 1
    dSP;
d2705 1
a2705 1
    dSP;
d2732 1
a2732 1
    dSP;
d2759 1
a2759 1
    dSP;
d2773 1
a2773 1
    dSP;
d2785 1
a2785 1
    dSP;
d2796 1
a2796 1
    dSP; dTARGET;
d2810 1
a2810 1
    dSP; dTARGET;
d2820 1
a2820 1
    dSP; dTARGET;
d2830 1
a2830 1
    dSP; dTARGET;
d2840 1
a2840 1
    dSP;
d2851 1
a2851 1
    dSP;
d2862 1
a2862 1
    dSP;
d2873 1
a2873 1
    dSP;
d2884 1
a2884 1
    dSP;
d2895 1
a2895 1
    dSP;
d2906 1
a2906 1
    dSP;
d2916 1
a2916 1
    dSP;
d2930 1
a2930 1
    dSP;
d2944 1
a2944 1
    dSP;
d2958 1
a2958 1
    dSP;
d2994 1
a2994 1
    dSP;
d3056 1
a3056 1
	    if (ckWARN2(WARN_UNOPENED,WARN_CLOSED)) {
d3058 2
a3059 1
		report_evil_fh(gv, GvIO(gv), PL_op->op_type);
d3081 1
a3081 1
	do_binmode(fp, '<', O_BINARY);
d3107 1
a3107 1
        else if (!(isPRINT(*s) || isSPACE(*s)))
d3116 1
a3116 1
	    if (UTF8_IS_START(*s)) {
d3121 1
a3121 1
			if (!UTF8_IS_CONTINUATION(s[j]))
d3155 1
a3155 1
    dSP; dTARGET;
d3193 1
a3193 1
    dSP; dMARK; dTARGET;
d3207 1
a3207 1
    dSP; dTARGET;
d3222 1
a3222 1
    dSP; dMARK; dTARGET;
d3232 1
a3232 1
    dSP; dMARK; dTARGET;
d3242 1
a3242 1
    dSP; dMARK; dTARGET;
d3252 1
a3252 1
    dSP; dTARGET;
d3279 1
a3279 1
    dSP; dTARGET;
d3294 1
a3294 1
    dSP; dTARGET;
d3309 1
a3309 1
    dSP; dTARGET;
d3421 1
a3421 1
    dSP; dTARGET;
d3450 1
a3450 1
    dSP; dTARGET;
d3468 1
a3468 1
    dSP;
d3495 1
a3495 1
    dSP;
d3553 1
a3553 1
    dSP; dTARGET;
d3581 1
a3581 1
    dSP;
d3604 1
a3604 1
    dSP;
d3625 1
a3625 1
    dSP;
d3658 1
a3658 1
    dSP; dTARGET;
d3677 1
a3677 1
    dSP; dTARGET;
a3682 2
    if (childpid == -1)
	RETSETUNDEF;
d3693 2
a3694 2
#if (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(MACOS_TRADITIONAL)
    dSP; dTARGET;
a3698 4
#  if defined(USE_ITHREADS) && defined(PERL_IMPLICIT_SYS)
    /* 0 and -1 are both error returns (the former applies to WNOHANG case) */
    STATUS_NATIVE_SET((childpid && childpid != -1) ? argflags : -1);
#  else
a3699 1
#  endif
d3709 2
a3710 2
#if (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(MACOS_TRADITIONAL)
    dSP; dTARGET;
a3717 4
#  if defined(USE_ITHREADS) && defined(PERL_IMPLICIT_SYS)
    /* 0 and -1 are both error returns (the former applies to WNOHANG case) */
    STATUS_NATIVE_SET((childpid && childpid != -1) ? argflags : -1);
#  else
a3718 1
#  endif
d3728 1
a3728 1
    dSP; dMARK; dORIGMARK; dTARGET;
d3746 1
a3746 1
#if (defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(OS2) && !defined(__CYGWIN__)
a3814 2
    PL_statusvalue = 0;
    result = 0;
a3823 2
    if (PL_statusvalue == -1)	/* hint that value must be returned as is */
	result = 1;
d3827 1
a3827 1
    PUSHi(result ? value : STATUS_CURRENT);
d3834 1
a3834 1
    dSP; dMARK; dORIGMARK; dTARGET;
d3886 1
a3886 1
    dSP; dMARK; dTARGET;
d3901 1
a3901 1
    dSP; dTARGET;
d3912 1
a3912 1
    dSP; dTARGET;
d3937 1
a3937 1
    dSP; dTARGET;
d3968 1
a3968 1
    dSP; dTARGET;
d3983 1
a3983 1
    dSP; dTARGET;
d4003 1
a4003 1
    dSP; dTARGET;
d4030 1
a4030 1
    dSP;
d4062 1
a4062 1
    dSP;
d4115 1
a4115 1
    dSP; dTARGET;
d4132 1
a4132 1
    dSP; dTARGET;
d4169 1
a4169 1
    dSP; dMARK; dTARGET;
d4194 1
a4194 1
    dSP; dMARK; dTARGET;
d4207 1
a4207 1
    dSP; dMARK; dTARGET;
d4222 1
a4222 1
    dSP; dMARK; dTARGET;
d4237 1
a4237 1
    dSP; dMARK; dTARGET;
d4257 1
a4257 1
    dSP; dMARK; dTARGET;
d4289 1
a4289 1
    dSP;
d4398 1
a4398 1
    dSP;
d4486 1
a4486 1
    dSP;
d4490 1
a4490 1
    register SV *sv;
d4569 1
a4569 1
    dSP;
d4659 1
a4659 1
    dSP;
d4670 1
a4670 1
    dSP;
d4681 1
a4681 1
    dSP;
d4692 1
a4692 1
    dSP;
d4703 1
a4703 1
    dSP;
d4715 1
a4715 1
    dSP;
d4727 1
a4727 1
    dSP;
d4739 1
a4739 1
    dSP;
d4769 1
a4769 1
    dSP;
d4773 1
d4775 3
a4777 54
    struct passwd *pwent  = NULL;
    /*
     * We currently support only the SysV getsp* shadow password interface.
     * The interface is declared in <shadow.h> and often one needs to link
     * with -lsecurity or some such.
     * This interface is used at least by Solaris, HP-UX, IRIX, and Linux.
     * (and SCO?)
     *
     * AIX getpwnam() is clever enough to return the encrypted password
     * only if the caller (euid?) is root.
     *
     * There are at least two other shadow password APIs.  Many platforms
     * seem to contain more than one interface for accessing the shadow
     * password databases, possibly for compatibility reasons.
     * The getsp*() is by far he simplest one, the other two interfaces
     * are much more complicated, but also very similar to each other.
     *
     * <sys/types.h>
     * <sys/security.h>
     * <prot.h>
     * struct pr_passwd *getprpw*();
     * The password is in
     * char getprpw*(...).ufld.fd_encrypt[]
     * Mention HAS_GETPRPWNAM here so that Configure probes for it.
     *
     * <sys/types.h>
     * <sys/security.h>
     * <prot.h>
     * struct es_passwd *getespw*();
     * The password is in
     * char *(getespw*(...).ufld.fd_encrypt)
     * Mention HAS_GETESPWNAM here so that Configure probes for it.
     *
     * Mention I_PROT here so that Configure probes for it.
     *
     * In HP-UX for getprpw*() the manual page claims that one should include
     * <hpsecurity.h> instead of <sys/security.h>, but that is not needed
     * if one includes <shadow.h> as that includes <hpsecurity.h>,
     * and pp_sys.c already includes <shadow.h> if there is such.
     *
     * Note that <sys/security.h> is already probed for, but currently
     * it is only included in special cases.
     *
     * In Digital UNIX/Tru64 if using the getespw*() (which seems to be
     * be preferred interface, even though also the getprpw*() interface
     * is available) one needs to link with -lsecurity -ldb -laud -lm.
     * One also needs to call set_auth_parameters() in main() before
     * doing anything else, whether one is using getespw*() or getprpw*().
     *
     * Note that accessing the shadow databases can be magnitudes
     * slower than accessing the standard databases.
     *
     * --jhi
     */
d4779 8
a4786 11
    switch (which) {
    case OP_GPWNAM:
	pwent  = getpwnam(POPpx);
	break;
    case OP_GPWUID:
	pwent = getpwuid((Uid_t)POPi);
	break;
    case OP_GPWENT:
#  ifdef HAS_GETPWENT
	pwent  = getpwent();
#  else
d4788 16
d4805 1
a4805 2
	break;
    }
d4812 1
a4812 1
#  if Uid_t_sign <= 0
d4814 1
a4814 1
#  else
d4816 1
a4816 1
#  endif
d4828 8
a4835 35
	SvPOK_off(sv);
	/* If we have getspnam(), we try to dig up the shadow
	 * password.  If we are underprivileged, the shadow
	 * interface will set the errno to EACCES or similar,
	 * and return a null pointer.  If this happens, we will
	 * use the dummy password (usually "*" or "x") from the
	 * standard password database.
	 *
	 * In theory we could skip the shadow call completely
	 * if euid != 0 but in practice we cannot know which
	 * security measures are guarding the shadow databases
	 * on a random platform.
	 *
	 * Resist the urge to use additional shadow interfaces.
	 * Divert the urge to writing an extension instead.
	 *
	 * --jhi */
#  ifdef HAS_GETSPNAM
	{
	    struct spwd *spwent;
	    int saverrno; /* Save and restore errno so that
			   * underprivileged attempts seem
			   * to have never made the unsccessful
			   * attempt to retrieve the shadow password. */

	    saverrno = errno;
	    spwent = getspnam(pwent->pw_name);
	    errno = saverrno;
	    if (spwent && spwent->sp_pwdp)
		sv_setpv(sv, spwent->sp_pwdp);
	}
#  endif
#   ifdef PWPASSWD
	if (!SvPOK(sv)) /* Use the standard password, then. */
	    sv_setpv(sv, pwent->pw_passwd);
d4837 3
a4839 4

#  ifndef INCOMPLETE_TAINTS
	/* passwd is tainted because user himself can diddle with it.
	 * admittedly not much and in a very limited way, but nevertheless. */
d4841 1
a4841 1
#  endif
d4844 1
a4844 1
#  if Uid_t_sign <= 0
d4846 1
a4846 1
#  else
d4848 1
a4848 1
#  endif
d4851 1
a4851 1
#  if Uid_t_sign <= 0
d4853 1
a4853 1
#  else
d4855 2
a4856 6
#  endif
	/* pw_change, pw_quota, and pw_age are mutually exclusive--
	 * because of the poor interface of the Perl getpw*(),
	 * not because there's some standard/convention saying so.
	 * A better interface would have been to return a hash,
	 * but we are accursed by our history, alas. --jhi.  */
d4858 1
a4858 1
#  ifdef PWCHANGE
d4860 2
a4861 2
#  else
#    ifdef PWQUOTA
d4863 2
a4864 2
#    else
#      ifdef PWAGE
d4866 3
a4868 3
#      endif
#    endif
#  endif
d4870 1
a4870 2
	/* pw_class and pw_comment are mutually exclusive--.
	 * see the above note for pw_change, pw_quota, and pw_age. */
d4872 1
a4872 1
#  ifdef PWCLASS
d4874 2
a4875 2
#  else
#    ifdef PWCOMMENT
d4877 2
a4878 2
#    endif
#  endif
d4881 1
a4881 1
#  ifdef PWGECOS
d4883 2
a4884 2
#  endif
#  ifndef INCOMPLETE_TAINTS
d4887 1
a4887 1
#  endif
d4894 1
a4894 1
#  ifndef INCOMPLETE_TAINTS
d4897 1
a4897 1
#  endif
d4899 1
a4899 1
#  ifdef PWEXPIRE
d4902 1
a4902 1
#  endif
d4912 1
a4912 1
    dSP;
d4915 3
d4926 1
a4926 1
    dSP;
d4929 3
d4958 1
a4958 1
    dSP;
d5017 1
a5017 1
    dSP;
d5028 1
a5028 1
    dSP;
d5039 1
a5039 1
    dSP; dTARGET;
d5057 1
a5057 1
    dSP; dMARK; dORIGMARK; dTARGET;
d5084 1
a5084 1
	else
d5152 1
a5152 1

d5161 1
a5161 1

d5178 1
a5178 1

@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
a51 4
#ifdef NETWARE
NETDB_DEFINE_CONTEXT
#endif

a72 1
#  if !defined(VMS)
a74 1
#  endif
a76 1
#ifndef getpwent
a77 3
#elif defined (VMS) && defined (my_getpwent)
  struct passwd *Perl_my_getpwent (void);
#endif
a88 1
#ifndef getgrent
a89 1
#endif
d101 5
a168 2
#include "reentr.h"

a274 3
/* With it or without it: anyway you get a warning: either that
   it is unused, or it is declared static and never defined.
 */
a299 7
	char *type = NULL;
	if (PL_curcop->cop_io) {
	    type = SvPV_nolen(PL_curcop->cop_io);
	}
	if (type && *type)
	    PerlIO_apply_layers(aTHX_ fp,mode,type);

a306 2
	    SV *oldrs = PL_rs;
	    PL_rs = &PL_sv_undef;
a310 1
	    PL_rs = oldrs;
d381 9
a433 3
#ifdef VMS
    VMSISH_HUSHED  = VMSISH_HUSHED || (PL_op->op_private & OPpHUSH_VMSISH);
#endif
d444 1
a444 1
        tmps = (SvROK(tmpsv) && PL_in_eval) ? Nullch : SvPV(tmpsv, len);
d469 1
a469 1
	    DIE(aTHX_ Nullformat);
d488 1
a488 3
    dSP;
    dMARK; dORIGMARK;
    dTARGET;
d491 2
a492 1
    IO *io;
a495 1
    bool  ok;
d497 11
a507 1
    gv = (GV *)*++MARK;
d510 1
a510 1
    if ((io = GvIOp(gv)))
d513 6
a518 5
    if (io && (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar))) {
	/* Method's args are same as ours ... */
	/* ... except handle is replaced by the object */
	*MARK-- = SvTIED_obj((SV*)io, mg);
	PUSHMARK(MARK);
a526 7
    if (MARK < SP) {
	sv = *++MARK;
    }
    else {
	sv = GvSV(gv);
    }

d528 1
a528 3
    ok = do_openn(gv, tmps, len, FALSE, O_RDONLY, 0, Nullfp, MARK+1, (SP-MARK));
    SP = ORIGMARK;
    if (ok)
a540 1
    IO *io;
d548 1
a548 3
    if (gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
d550 1
a550 1
	XPUSHs(SvTIED_obj((SV*)io, mg));
d565 1
a566 1
    dSP;
a593 1
    IoOFP(rstio) = IoIFP(rstio);
d630 1
a630 3
    if (gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
d632 1
a632 1
	XPUSHs(SvTIED_obj((SV*)io, mg));
d641 1
a641 6
    if (!gv || !(io = GvIO(gv)) || !(fp = IoIFP(io))) {
	/* Can't do this because people seem to do things like
	   defined(fileno($foo)) to check whether $foo is a valid fh.
	  if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	      report_evil_fh(gv, io, PL_op->op_type);
	    */
a642 2
    }

a649 1
#ifdef HAS_UMASK
d652 1
d683 1
a683 1
    if (MAXARG > 1) {
a684 1
    }
d688 1
a688 3
    if (gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
d690 1
a690 1
	XPUSHs(SvTIED_obj((SV*)io, mg));
d702 2
a703 5
    if (!(io = GvIO(gv)) || !(fp = IoIFP(io))) {
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
        RETPUSHUNDEF;
    }
d705 1
a705 4
    PUTBACK;
    if (PerlIO_binmode(aTHX_ fp,IoTYPE(io),mode_from_discipline(discp),
                       (discp) ? SvPV_nolen(discp) : Nullch)) {
	SPAGAIN;
d707 1
a707 3
    }
    else {
	SPAGAIN;
a708 1
    }
d721 1
a721 1
    int how = PERL_MAGIC_tied;
a728 1
	    HvEITER((HV *)varsv) = Null(HE *);
a733 5
#ifdef GV_UNIQUE_CHECK
	    if (GvUNIQUE((GV*)varsv)) {
                Perl_croak(aTHX_ "Attempt to tie unique GV");
	    }
#endif
d735 1
a735 6
	    how = PERL_MAGIC_tiedscalar;
	    /* For tied filehandles, we apply tiedscalar magic to the IO
	       slot of the GP rather than the GV itself. AMS 20010812 */
	    if (!GvIOp(varsv))
		GvIOp(varsv) = newIO();
	    varsv = (SV *)GvIOp(varsv);
d739 1
a739 1
	    how = PERL_MAGIC_tiedscalar;
d747 1
a747 1
	EXTEND(SP,(I32)items);
d765 1
a765 1
	EXTEND(SP,(I32)items);
a776 6
	/* Croak if a self-tie on an aggregate is attempted. */
	if (varsv == SvRV(sv) &&
	    (SvTYPE(varsv) == SVt_PVAV ||
	     SvTYPE(varsv) == SVt_PVHV))
	    Perl_croak(aTHX_
		       "Self-ties of arrays and hashes are not supported");
a787 1
    MAGIC *mg;
d789 1
a789 2
    char how = (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV)
		? PERL_MAGIC_tied : PERL_MAGIC_tiedscalar;
d791 2
a792 4
    if (SvTYPE(sv) == SVt_PVGV && !(sv = (SV *)GvIOp(sv)))
	RETPUSHYES;

    if ((mg = SvTIED_mg(sv, how))) {
d796 16
a811 18
        if (obj) {
	    if ((gv = gv_fetchmethod_autoload(SvSTASH(obj), "UNTIE", FALSE)) &&
               isGV(gv) && (cv = GvCV(gv))) {
	       PUSHMARK(SP);
	       XPUSHs(SvTIED_obj((SV*)gv, mg));
	       XPUSHs(sv_2mortal(newSViv(SvREFCNT(obj)-1)));
	       PUTBACK;
	       ENTER;
	       call_sv((SV *)cv, G_VOID);
	       LEAVE;
	       SPAGAIN;
            }
           else if (ckWARN(WARN_UNTIE)) {
	       if (mg && SvREFCNT(obj) > 1)
		  Perl_warner(aTHX_ packWARN(WARN_UNTIE),
		      "untie attempted while %"UVuf" inner references still exist",
		       (UV)SvREFCNT(obj) - 1 ) ;
           }
a812 1
	sv_unmagic(sv, how) ;
d814 1
d821 2
a823 6
    SV *sv = POPs;
    char how = (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV)
		? PERL_MAGIC_tied : PERL_MAGIC_tiedscalar;

    if (SvTYPE(sv) == SVt_PVGV && !(sv = (SV *)GvIOp(sv)))
	RETPUSHUNDEF;
d885 2
a886 2
	sv_unmagic((SV *) hv, PERL_MAGIC_tied);
	sv_magic((SV*)hv, TOPs, PERL_MAGIC_tied, Nullch, 0);
d899 1
a900 1
    dSP; dTARGET;
d936 12
a947 1
#if BYTEORDER != 0x1234 && BYTEORDER != 0x12345678
d958 1
a961 11
#  if SELECT_MIN_BITS > 1
    /* If SELECT_MIN_BITS is greater than one we most probably will want
     * to align the sizes with SELECT_MIN_BITS/8 because for example
     * in many little-endian (Intel, Alpha) systems (Linux, OS/2, Digital
     * UNIX, Solaris, NeXT, Darwin) the smallest quantum select() operates
     * on (sets/tests/clears bits) is 32 bits.  */
    growsize = maxlen + (SELECT_MIN_BITS/8 - (maxlen % (SELECT_MIN_BITS/8)));
#  else
    growsize = sizeof(fd_set);
#  endif

a1085 1
    IO *io = NULL;
d1093 1
a1093 3
    if (gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
d1096 1
a1096 1
	XPUSHs(SvTIED_obj((SV*)io, mg));
d1106 1
a1106 4
    if (!gv || do_eof(gv)) { /* make sure we have fp with something */
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED)
		&& (!io || (!IoIFP(io) && IoTYPE(io) != IoTYPE_WRONLY)))
	    report_evil_fh(gv, io, PL_op->op_type);
a1107 1
    }
a1110 10
    if (PerlIO_isutf8(IoIFP(GvIOp(gv)))) {
	/* Find out how many bytes the char needs */
	Size_t len = UTF8SKIP(SvPVX(TARG));
	if (len > 1) {
	    SvGROW(TARG,len+1);
	    len = PerlIO_read(IoIFP(GvIOp(gv)),SvPVX(TARG)+1,len-1);
	    SvCUR_set(TARG,1+len);
	}
	SvUTF8_on(TARG);
    }
a1197 2
    if (!io || !ofp)
	goto forget_top;
d1237 1
a1237 4
		STRLEN save = SvCUR(PL_formtarget);
		SvCUR_set(PL_formtarget, s - SvPVX(PL_formtarget));
		do_print(PL_formtarget, ofp);
		SvCUR_set(PL_formtarget, save);
d1243 1
a1243 1
	    do_print(PL_formfeed, ofp);
d1288 1
a1288 1
		    Perl_warner(aTHX_ packWARN(WARN_IO),
d1291 1
a1291 1
		    Perl_warner(aTHX_ packWARN(WARN_IO),
d1302 1
a1302 1
		Perl_warner(aTHX_ packWARN(WARN_IO), "page overflow");
d1304 2
a1305 1
	if (!do_print(PL_formtarget, fp))
a1315 1
    /* bad_ofp: */
d1329 1
d1336 1
a1336 3
    if (gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
d1344 1
a1344 1
	*MARK = SvTIED_obj((SV*)io, mg);
d1373 1
a1373 1
		    Perl_warner(aTHX_ packWARN(WARN_IO),
d1376 1
a1376 1
		    Perl_warner(aTHX_ packWARN(WARN_IO),
a1443 1
    SSize_t count;
a1447 6
    int fp_utf8;
    Size_t got = 0;
    Size_t wanted;
    bool charstart = FALSE;
    STRLEN charskip = 0;
    STRLEN skip = 0;
d1450 2
a1451 3
    if ((PL_op->op_type == OP_READ || PL_op->op_type == OP_SYSREAD)
	&& gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
d1456 1
a1456 1
	*MARK = SvTIED_obj((SV*)io, mg);
d1472 1
d1474 2
a1483 16
    if ((fp_utf8 = PerlIO_isutf8(IoIFP(io))) && !IN_BYTES) {
	buffer = SvPVutf8_force(bufsv, blen);
	/* UTF8 may not have been set if they are all low bytes */
	SvUTF8_on(bufsv);
    }
    else {
	buffer = SvPV_force(bufsv, blen);
    }
    if (length < 0)
	DIE(aTHX_ "Negative length");
    wanted = length;

    charstart = TRUE;
    charskip  = 0;
    skip = 0;

d1487 1
a1487 1
#if (defined(VMS_DO_SOCKETS) && defined(DECCRTL_SOCKETS)) || defined(MPE) || defined(__QNXNTO__)
d1496 1
a1496 1
	buffer = SvGROW(bufsv, (STRLEN)(length+1));
d1498 1
a1498 1
	count = PerlSock_recvfrom(PerlIO_fileno(IoIFP(io)), buffer, length, offset,
d1500 1
a1500 1
	if (count < 0)
d1503 1
a1503 1
        /* Bogus return without padding */
d1506 1
a1506 1
	SvCUR_set(bufsv, count);
a1508 2
	if (fp_utf8)
	    SvUTF8_on(bufsv);
a1521 4
    if (DO_UTF8(bufsv)) {
	/* offset adjust in characters not bytes */
	blen = sv_len_utf8(bufsv);
    }
d1523 1
a1523 1
	if (-offset > (int)blen)
a1526 5
    if (DO_UTF8(bufsv)) {
	/* convert offset-as-chars to offset-as-bytes */
	offset = utf8_hop((U8 *)buffer,offset) - (U8 *) buffer;
    }
 more_bytes:
d1528 1
a1528 1
    buffer  = SvGROW(bufsv, (STRLEN)(length+offset+1));
a1531 2
    buffer = buffer + offset;

d1535 2
a1536 2
	    count = PerlSock_recv(PerlIO_fileno(IoIFP(io)),
				   buffer, length, 0);
d1541 2
a1542 2
	    count = PerlLIO_read(PerlIO_fileno(IoIFP(io)),
				  buffer, length);
d1554 1
a1554 1
	count = PerlSock_recvfrom(PerlIO_fileno(IoIFP(io)), buffer, length, 0,
d1560 8
a1567 7
	count = PerlIO_read(IoIFP(io), buffer, length);
	/* PerlIO_read() - like fread() returns 0 on both error and EOF */
	if (count == 0 && PerlIO_error(IoIFP(io)))
	    count = -1;
    }
    if (count < 0) {
	if ((IoTYPE(io) == IoTYPE_WRONLY) && ckWARN(WARN_IO))
d1577 1
a1577 1
		Perl_warner(aTHX_ packWARN(WARN_IO),
d1580 1
a1580 1
		Perl_warner(aTHX_ packWARN(WARN_IO),
d1585 1
a1585 1
    SvCUR_set(bufsv, count+(buffer - SvPVX(bufsv)));
a1587 35
    if (fp_utf8 && !IN_BYTES) {
	/* Look at utf8 we got back and count the characters */
	char *bend = buffer + count;
	while (buffer < bend) {
	    if (charstart) {
	        skip = UTF8SKIP(buffer);
		charskip = 0;
	    }
	    if (buffer - charskip + skip > bend) {
		/* partial character - try for rest of it */
		length = skip - (bend-buffer);
		offset = bend - SvPVX(bufsv);
		charstart = FALSE;
		charskip += count;
		goto more_bytes;
	    }
	    else {
		got++;
		buffer += skip;
		charstart = TRUE;
		charskip  = 0;
	    }
        }
	/* If we have not 'got' the number of _characters_ we 'wanted' get some more
	   provided amount read (count) was what was requested (length)
	 */
	if (got < wanted && count == length) {
	    length = wanted - got;
	    offset = bend - SvPVX(bufsv);
	    goto more_bytes;
	}
	/* return value is character count */
	count = got;
	SvUTF8_on(bufsv);
    }
d1593 1
a1593 1
    PUSHi(count);
d1624 1
d1629 1
a1629 4
    if (PL_op->op_type == OP_SYSWRITE
	&& gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
d1633 1
a1633 1
	*MARK = SvTIED_obj((SV*)io, mg);
d1646 1
a1659 1
	goto say_undef;
d1661 1
a1661 16

    if (PerlIO_isutf8(IoIFP(io))) {
	buffer = SvPVutf8(bufsv, blen);
    }
    else {
	if (DO_UTF8(bufsv))
	    sv_utf8_downgrade(bufsv, FALSE);
	buffer = SvPV(bufsv, blen);
    }

    if (PL_op->op_type == OP_SYSWRITE) {
	IV offset;
	if (DO_UTF8(bufsv)) {
	    /* length and offset are in chars */
	    blen   = sv_len_utf8(bufsv);
	}
d1665 1
a1665 1
		if (-offset > (IV)blen)
d1668 1
a1668 1
	    } else if (offset >= (IV)blen && blen > 0)
a1673 7
	if (DO_UTF8(bufsv)) {
	    buffer = (char*)utf8_hop((U8 *)buffer, offset);
	    length = utf8_hop((U8 *)buffer, length) - (U8 *)buffer;
	}
	else {
	    buffer = buffer+offset;
	}
d1677 1
a1677 1
				   buffer, length, 0);
d1684 1
a1684 1
				   buffer, length);
a1691 1
	/* length is really flags */
a1695 1
	/* length is really flags */
d1697 1
a1704 2
    if (DO_UTF8(bufsv))
        retval = utf8_length((U8*)buffer, (U8*)buffer + retval);
a1725 1
    IO *io;
d1731 1
a1731 1
	    gv = PL_last_in_gv = GvEGV(PL_argvgv);
d1751 1
a1751 3
    if (gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
d1753 1
a1753 1
	XPUSHs(SvTIED_obj((SV*)io, mg));
a1769 1
    IO *io;
d1777 1
a1777 3
    if (gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
d1779 1
a1779 1
	XPUSHs(SvTIED_obj((SV*)io, mg));
a1804 1
    IO *io;
d1815 1
a1815 3
    if (gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
d1817 1
a1817 1
	XPUSHs(SvTIED_obj((SV*)io, mg));
d1861 3
d1865 1
a1865 1
#if Off_t_size > IVSIZE
d1875 8
a1882 14
    {
        STRLEN n_a;
	int result = 1;
	GV *tmpgv;
	
	if (PL_op->op_flags & OPf_SPECIAL) {
	    tmpgv = gv_fetchpv(POPpx, FALSE, SVt_PVIO);

	do_ftruncate:
	    TAINT_PROPER("truncate");
	    if (!GvIO(tmpgv) || !IoIFP(GvIOp(tmpgv)))
	        result = 0;
	    else {
	        PerlIO_flush(IoIFP(GvIOp(tmpgv)));
d1884 1
a1884 1
		if (ftruncate(PerlIO_fileno(IoIFP(GvIOn(tmpgv))), len) < 0)
d1886 1
a1886 1
		if (my_chsize(PerlIO_fileno(IoIFP(GvIOn(tmpgv))), len) < 0)
d1888 15
a1902 2
		    result = 0;
	    }
a1903 12
	else {
	    SV *sv = POPs;
	    char *name;
	
	    if (SvTYPE(sv) == SVt_PVGV) {
	        tmpgv = (GV*)sv;		/* *main::FRED for example */
		goto do_ftruncate;
	    }
	    else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVGV) {
	        tmpgv = (GV*) SvRV(sv);	/* \*main::FRED for example */
		goto do_ftruncate;
	    }
d1905 2
a1906 2
	    name = SvPV(sv, n_a);
	    TAINT_PROPER("truncate");
d1908 2
a1909 2
	    if (truncate(name, len) < 0)
	        result = 0;
d1911 6
a1916 4
	    {
	        int tmpfd;

		if ((tmpfd = PerlLIO_open(name, O_RDWR)) < 0)
d1918 1
a1918 5
		else {
		    if (my_chsize(tmpfd, len) < 0)
		        result = 0;
		    PerlLIO_close(tmpfd);
		}
d1920 1
d1922 1
a1922 1
	}
d1924 5
a1928 6
	if (result)
	    RETPUSHYES;
	if (!errno)
	    SETERRNO(EBADF,RMS$_IFI);
	RETPUSHUNDEF;
    }
d1943 1
a1943 1
    unsigned int func = POPu;
d1948 1
a1948 1
    IO *io = gv ? GvIOn(gv) : 0;
a1950 2
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
d1981 1
a1981 3
#ifndef HAS_FCNTL
      DIE(aTHX_ "fcntl is not implemented");
#else
d1987 3
d1994 1
a1994 1
		OP_NAME(PL_op));
a2006 1
#endif
a2011 1
#ifdef FLOCK
d2019 1
d2052 1
a2053 1
    dSP;
a2061 1
    io = gv ? GvIOn(gv) : NULL;
d2063 1
a2063 5
    if (!gv || !io) {
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
	if (IoIFP(io))
	    do_close(gv, FALSE);
d2068 1
a2100 1
#if defined (HAS_SOCKETPAIR) || (defined (HAS_SOCKET) && defined(SOCK_DGRAM) && defined(AF_INET) && defined(PF_INET))
d2102 1
d2114 1
a2114 13
    io1 = gv1 ? GvIOn(gv1) : NULL;
    io2 = gv2 ? GvIOn(gv2) : NULL;
    if (!gv1 || !gv2 || !io1 || !io2) {
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED)) {
	    if (!gv1 || !io1)
		report_evil_fh(gv1, io1, PL_op->op_type);
	    if (!gv2 || !io2)
		report_evil_fh(gv1, io2, PL_op->op_type);
	}
	if (IoIFP(io1))
	    do_close(gv1, FALSE);
	if (IoIFP(io2))
	    do_close(gv2, FALSE);
a2115 1
    }
d2117 2
d2155 1
a2156 1
    dSP;
d2158 2
a2159 2
    extern void GETPRIVMODE();
    extern void GETUSERMODE();
d2214 1
a2215 1
    dSP;
d2244 1
a2245 1
    dSP;
d2248 1
a2248 1
    register IO *io = gv ? GvIOn(gv) : NULL;
d2250 1
a2250 1
    if (!gv || !io || !IoIFP(io))
d2270 1
a2271 1
    dSP; dTARGET;
a2278 1
    int fd2;
d2293 3
a2298 2
    if (IoIFP(nstio))
	do_close(ngv, FALSE);
d2300 1
a2300 5
    /* FIXME: we dup(fd) here so that refcounting of fd's does not inhibit
       fclose of IoOFP's FILE * - and hence leak memory.
       Special treatment of _this_ case of IoIFP != IoOFP seems wrong.
     */
    IoOFP(nstio) = PerlIO_fdopen(fd2 = PerlLIO_dup(fd), "w");
a2309 1
    fcntl(fd2, F_SETFD, fd2 > PL_maxsysfd);	/* ensure close-on-exec */
d2335 1
a2336 1
    dSP; dTARGET;
d2368 1
a2369 1
    dSP;
d2449 1
a2450 1
    dSP;
a2527 9
	if (PL_op->op_type == OP_LSTAT) {
	    if (gv != PL_defgv) {
		if (ckWARN(WARN_IO))
		    Perl_warner(aTHX_ packWARN(WARN_IO),
			"lstat() on filehandle %s", GvENAME(gv));
	    } else if (PL_laststype != OP_LSTAT)
		Perl_croak(aTHX_ "The stat preceding lstat() wasn't an lstat");
	}

a2549 3
	    if (PL_op->op_type == OP_LSTAT && ckWARN(WARN_IO))
		Perl_warner(aTHX_ packWARN(WARN_IO),
			"lstat() on filehandle %s", GvENAME(gv));
d2563 1
a2563 1
		Perl_warner(aTHX_ packWARN(WARN_NEWLINE), PL_warn_nl, "stat");
d3072 1
a3072 1
	    if (S_ISDIR(PL_statcache.st_mode)) { /* handle NFS glitch */
a3076 1
            }
a3103 1
	PL_laststype = OP_STAT;
d3107 1
a3107 1
		Perl_warner(aTHX_ packWARN(WARN_NEWLINE), PL_warn_nl, "open");
d3115 1
a3115 1
	PerlIO_binmode(aTHX_ fp, '<', O_BINARY, Nullch);
d3146 1
a3146 1
	    if (IN_LOCALE_RUNTIME && isALPHA_LC(*s))
d3194 2
a3195 2
    if( MAXARG == 1 )
        tmps = POPpx;
d3197 11
a3207 5
        tmps = 0;

    if( !tmps || !*tmps ) {
        if (    (svp = hv_fetch(GvHVn(PL_envgv), "HOME", 4, FALSE))
             || (svp = hv_fetch(GvHVn(PL_envgv), "LOGDIR", 6, FALSE))
d3209 5
a3213 1
             || (svp = hv_fetch(GvHVn(PL_envgv), "SYS$LOGIN", 9, FALSE))
a3214 13
           )
        {
            if( MAXARG == 1 )
                deprecate("chdir('') or chdir(undef) as chdir()");
            tmps = SvPV(*svp, n_a);
        }
        else {
            PUSHi(0);
            TAINT_PROPER("chdir");
            RETURN;
        }
    }

d3227 2
d3230 1
a3230 3
    dSP; dMARK; dTARGET;
    I32 value = (I32)apply(PL_op->op_type, MARK, SP);

d3235 1
a3235 1
    DIE(aTHX_ PL_no_func, "chown");
d3241 2
a3243 1
    dSP; dTARGET;
d3245 1
a3245 1
    char *tmps = POPpx;
d3313 1
a3314 1
    dSP; dTARGET;
a3319 1
    RETURN;
d3321 1
a3321 1
    DIE(aTHX_ PL_no_func, "link");
d3323 1
d3328 1
a3329 1
    dSP; dTARGET;
d3343 1
a3343 1
    dSP;
a3344 1
    dTARGET;
d3354 1
a3354 1
    len = readlink(tmps, buf, sizeof(buf) - 1);
d3460 1
a3460 1
    STRLEN len;
a3461 1
    bool copy = FALSE;
d3468 1
a3468 16
    tmps = SvPV(TOPs, len);
    /* Different operating and file systems take differently to
     * trailing slashes.  According to POSIX 1003.1 1996 Edition
     * any number of trailing slashes should be allowed.
     * Thusly we snip them away so that even non-conforming
     * systems are happy. */
    /* We should probably do this "filtering" for all
     * the functions that expect (potentially) directory names:
     * -d, chdir(), chmod(), chown(), chroot(), fcntl()?,
     * (mkdir()), opendir(), rename(), rmdir(), stat(). --jhi */
    if (len > 1 && tmps[len-1] == '/') {
	while (tmps[len] == '/' && len > 1)
	    len--;
	tmps = savepvn(tmps, len);
	copy = TRUE;
    }
a3478 2
    if (copy)
	Safefree(tmps);
d3502 1
a3503 1
    dSP;
d3529 1
d3531 1
a3531 2
    dSP;
#if !defined(I_DIRENT) && !defined(VMS)
d3587 1
a3588 1
    dSP; dTARGET;
d3615 1
a3616 1
    dSP;
d3638 1
a3639 1
    dSP;
d3659 1
a3660 1
    dSP;
d3698 1
a3698 1
    childpid = PerlProc_fork();
d3703 1
a3703 2
	if ((tmpgv = gv_fetchpv("$", TRUE, SVt_PV))) {
            SvREADONLY_off(GvSV(tmpgv));
a3704 2
            SvREADONLY_on(GvSV(tmpgv));
        }
d3722 1
a3722 1
    DIE(aTHX_ PL_no_func, "fork");
a3733 1
#ifdef PERL_OLD_SIGNALS
a3734 5
#else
    while ((childpid = wait4pid(-1, &argflags, 0)) == -1 && errno == EINTR) {
	PERL_ASYNC_CHECK();
    }
#endif
d3744 1
a3744 1
    DIE(aTHX_ PL_no_func, "wait");
a3757 1
#ifdef PERL_OLD_SIGNALS
a3758 5
#else
    while ((childpid = wait4pid(childpid, &argflags, optype)) == -1 && errno == EINTR) {
	PERL_ASYNC_CHECK();
    }
#endif
d3768 1
a3768 1
    DIE(aTHX_ PL_no_func, "waitpid");
d3776 4
a3780 1
    int result;
d3782 1
d3784 4
a3787 13
    if (PL_tainting) {
	int some_arg_tainted = 0;
	TAINT_ENV();
	while (++MARK <= SP) {
	    (void)SvPV_nolen(*MARK);      /* stringify for taint check */
	    if (PL_tainted) {
		some_arg_tainted = 1;
		break;
	    }
	}
	MARK = ORIGMARK;
	/* XXX Remove warning at end of deprecation cycle --RD 2002-02  */
	if (SP - MARK == 1) {
a3789 4
	else if (some_arg_tainted && ckWARN2(WARN_TAINT, WARN_DEPRECATED)) {
	    Perl_warner(aTHX_ packWARN2(WARN_TAINT, WARN_DEPRECATED),
		"Use of tainted arguments in %s is deprecated", "system");
	}
d3792 6
a3797 39
#if (defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(OS2) || defined(PERL_MICRO)
    {
	Pid_t childpid;
	int pp[2];

	if (PerlProc_pipe(pp) >= 0)
	    did_pipes = 1;
	while ((childpid = PerlProc_fork()) == -1) {
	    if (errno != EAGAIN) {
		value = -1;
		SP = ORIGMARK;
		PUSHi(value);
		if (did_pipes) {
		    PerlLIO_close(pp[0]);
		    PerlLIO_close(pp[1]);
		}
		RETURN;
	    }
	    sleep(5);
	}
	if (childpid > 0) {
	    Sigsave_t ihand,qhand; /* place to save signals during system() */
	    int status;

	    if (did_pipes)
		PerlLIO_close(pp[1]);
#ifndef PERL_MICRO
	    rsignal_save(SIGINT, SIG_IGN, &ihand);
	    rsignal_save(SIGQUIT, SIG_IGN, &qhand);
#endif
	    do {
		result = wait4pid(childpid, &status, 0);
	    } while (result == -1 && errno == EINTR);
#ifndef PERL_MICRO
	    (void)rsignal_restore(SIGINT, &ihand);
	    (void)rsignal_restore(SIGQUIT, &qhand);
#endif
	    STATUS_NATIVE_SET(result == -1 ? -1 : status);
	    do_execfree();	/* free any memory child malloced on fork */
d3799 1
a3800 11
		int errkid;
		int n = 0, n1;

		while (n < sizeof(int)) {
		    n1 = PerlLIO_read(pp[0],
				      (void*)(((char*)&errkid)+n),
				      (sizeof(int)) - n);
		    if (n1 <= 0)
			break;
		    n += n1;
		}
d3802 1
a3802 6
		if (n) {			/* Error */
		    if (n != sizeof(int))
			DIE(aTHX_ "panic: kid popen errno read");
		    errno = errkid;		/* Propagate errno from kid */
		    STATUS_CURRENT = -1;
		}
a3803 1
	    PUSHi(STATUS_CURRENT);
d3806 15
d3822 11
d3834 12
d3847 1
a3847 1
	    fcntl(pp[1], F_SETFD, FD_CLOEXEC);
a3848 11
	}
	if (PL_op->op_flags & OPf_STACKED) {
	    SV *really = *++MARK;
	    value = (I32)do_aexec5(really, MARK, SP, pp[1], did_pipes);
	}
	else if (SP - MARK != 1)
	    value = (I32)do_aexec5(Nullsv, MARK, SP, pp[1], did_pipes);
	else {
	    value = (I32)do_exec3(SvPVx(sv_mortalcopy(*SP), n_a), pp[1], did_pipes);
	}
	PerlProc__exit(-1);
d3850 10
a3864 3
#  ifdef WIN32
	value = (I32)do_aspawn(really, MARK, SP);
#  else
a3865 1
#  endif
d3867 1
a3867 4
    else if (SP - MARK != 1) {
#  ifdef WIN32
	value = (I32)do_aspawn(Nullsv, MARK, SP);
#  else
a3868 2
#  endif
    }
a3887 20
    if (PL_tainting) {
	int some_arg_tainted = 0;
	TAINT_ENV();
	while (++MARK <= SP) {
	    (void)SvPV_nolen(*MARK);      /* stringify for taint check */
	    if (PL_tainted) {
		some_arg_tainted = 1;
		break;
	    }
	}
	MARK = ORIGMARK;
	/* XXX Remove warning at end of deprecation cycle --RD 2002-02  */
	if (SP - MARK == 1) {
	    TAINT_PROPER("exec");
	}
	else if (some_arg_tainted && ckWARN2(WARN_TAINT, WARN_DEPRECATED)) {
	    Perl_warner(aTHX_ packWARN2(WARN_TAINT, WARN_DEPRECATED),
		"Use of tainted arguments in %s is deprecated", "exec");
	}
    }
d3907 5
d3924 5
a3935 1
#ifdef HAS_KILL
d3938 1
d3944 1
a3944 1
    DIE(aTHX_ PL_no_func, "kill");
d4018 3
d4022 2
a4023 3
    dSP; dTARGET;
    int who = POPi;
    int which = TOPi;
d4033 4
d4038 3
a4040 4
    dSP; dTARGET;
    int niceval = POPi;
    int who = POPi;
    int which = TOPi;
a4069 4
#ifdef __BEOS__
#  define HZ 1000000
#endif

a4079 1
#ifdef HAS_TIMES
d4081 4
d4086 1
a4101 2
#else
    DIE(aTHX_ "times not implemented");
d4133 2
a4136 2
        EXTEND(SP, 1);
        EXTEND_MORTAL(1);
d4150 1
a4150 3
        EXTEND(SP, 9);
        EXTEND_MORTAL(9);
        PUSHs(sv_2mortal(newSViv(tmbuf->tm_sec)));
a4164 1
#ifdef HAS_ALARM
d4167 1
d4176 1
a4176 1
    DIE(aTHX_ PL_no_func, "alarm");
d4339 1
a4340 1
    dSP;
d4345 3
a4347 3
    struct hostent *gethostbyaddr(Netdb_host_t, Netdb_hlen_t, int);
    struct hostent *gethostbyname(Netdb_name_t);
    struct hostent *gethostent(void);
d4354 1
a4354 1
    if (which == OP_GHBYNAME) {
d4356 1
a4356 2
        char* name = POPpbytex;
	hent = PerlSock_gethostbyname(name);
a4359 1
    }
d4365 1
a4365 1
	Netdb_host_t addr = (Netdb_host_t) SvPVbyte(addrsv, addrlen);
d4380 2
a4381 8
	if (!hent) {
#ifdef USE_REENTRANT_API
#   ifdef USE_GETHOSTENT_ERRNO
	    h_errno = PL_reentrant_buffer->_gethostent_errno;
#   endif
#endif
	    STATUS_NATIVE_SET(h_errno);
	}
d4448 1
a4449 1
    dSP;
d4454 3
a4456 3
    struct netent *getnetbyaddr(Netdb_net_t, int);
    struct netent *getnetbyname(Netdb_name_t);
    struct netent *getnetent(void);
d4461 1
a4461 1
    if (which == OP_GNBYNAME){
d4463 1
a4463 2
        char *name = POPpbytex;
	nent = PerlSock_getnetbyname(name);
a4466 1
    }
d4470 1
a4470 1
	Netdb_net_t addr = (Netdb_net_t) (U32)POPu;
a4482 11
#ifdef HOST_NOT_FOUND
	if (!nent) {
#ifdef USE_REENTRANT_API
#   ifdef USE_GETNETENT_ERRNO
	     h_errno = PL_reentrant_buffer->_getnetent_errno;
#   endif
#endif
	    STATUS_NATIVE_SET(h_errno);
	}
#endif

d4536 1
a4537 1
    dSP;
d4542 3
a4544 3
    struct protoent *getprotobyname(Netdb_name_t);
    struct protoent *getprotobynumber(int);
    struct protoent *getprotoent(void);
d4549 1
a4549 1
    if (which == OP_GPBYNAME) {
d4551 1
a4551 2
        char* name = POPpbytex;
	pent = PerlSock_getprotobyname(name);
d4555 1
a4555 2
    }
    else if (which == OP_GPBYNUMBER) {
d4557 1
a4557 2
        int number = POPi;
	pent = PerlSock_getprotobynumber(number);
d4559 1
a4559 1
	DIE(aTHX_ PL_no_sock_func, "getprotobynumber");
a4560 1
    }
d4619 1
a4620 1
    dSP;
d4625 3
a4627 3
    struct servent *getservbyname(Netdb_name_t, Netdb_name_t);
    struct servent *getservbyport(int, Netdb_name_t);
    struct servent *getservent(void);
d4634 2
a4635 2
	char *proto = POPpbytex;
	char *name = POPpbytex;
d4647 2
a4648 2
	char *proto = POPpbytex;
	unsigned short port = (unsigned short)POPu;
d4709 1
a4710 1
    dSP;
d4720 1
a4721 1
    dSP;
d4731 1
a4732 1
    dSP;
d4742 1
a4743 1
    dSP;
d4753 1
a4754 1
    dSP;
d4765 1
a4766 1
    dSP;
d4777 1
a4778 1
    dSP;
d4789 1
a4790 1
    dSP;
d4819 1
a4820 1
    dSP;
d4881 2
a4882 5
      {
	char* name = POPpbytex;
	pwent  = getpwnam(name);
      }
      break;
d4884 1
a4884 4
      {
	Uid_t uid = POPi;
	pwent = getpwuid(uid);
      }
d4887 1
a4887 1
#   ifdef HAS_GETPWENT
d4889 1
a4889 4
#ifdef POSIX_BC   /* In some cases pw_passwd has invalid addresses */
	if (pwent) pwent = getpwnam(pwent->pw_name);
#endif
#   else
d4891 1
a4891 1
#   endif
d4900 1
a4900 1
#   if Uid_t_sign <= 0
d4902 1
a4902 1
#   else
d4904 1
a4904 1
#   endif
d4933 1
a4933 1
#   ifdef HAS_GETSPNAM
d4947 1
a4947 1
#   endif
d4953 1
a4953 1
#   ifndef INCOMPLETE_TAINTS
d4957 1
a4957 1
#   endif
d4960 1
a4960 1
#   if Uid_t_sign <= 0
d4962 1
a4962 1
#   else
d4964 1
a4964 1
#   endif
d4967 1
a4967 1
#   if Uid_t_sign <= 0
d4969 1
a4969 1
#   else
d4971 1
a4971 1
#   endif
d4978 1
a4978 1
#   ifdef PWCHANGE
d4980 2
a4981 2
#   else
#       ifdef PWQUOTA
d4983 2
a4984 2
#       else
#           ifdef PWAGE
d4986 3
a4988 3
#           endif
#       endif
#   endif
d4993 1
a4993 1
#   ifdef PWCLASS
d4995 2
a4996 2
#   else
#       ifdef PWCOMMENT
d4998 2
a4999 2
#       endif
#   endif
d5002 1
a5002 1
#   ifdef PWGECOS
d5004 2
a5005 2
#   endif
#   ifndef INCOMPLETE_TAINTS
d5008 1
a5008 1
#   endif
d5015 1
a5015 1
#   ifndef INCOMPLETE_TAINTS
d5018 1
a5018 1
#   endif
d5020 1
a5020 1
#   ifdef PWEXPIRE
d5023 1
a5023 1
#   endif
d5033 1
a5034 1
    dSP;
d5044 1
a5045 1
    dSP;
d5073 1
a5074 1
    dSP;
d5081 4
a5084 8
    if (which == OP_GGRNAM) {
        char* name = POPpbytex;
	grent = (struct group *)getgrnam(name);
    }
    else if (which == OP_GGRGID) {
        Gid_t gid = POPi;
	grent = (struct group *)getgrgid(gid);
    }
a5115 1
#if !(defined(_CRAYMPP) && defined(USE_REENTRANT_API))
a5116 8
	/* In UNICOS/mk (_CRAYMPP) the multithreading
	 * versions (getgrnam_r, getgrgid_r)
	 * seem to return an illegal pointer
	 * as the group members list, gr_mem.
	 * getgrent() doesn't even have a _r version
	 * but the gr_mem is poisonous anyway.
	 * So yes, you cannot get the list of group
	 * members if building multithreaded in UNICOS/mk. */
a5121 1
#endif
d5132 1
a5133 1
    dSP;
d5143 1
a5144 1
    dSP;
d5154 1
a5155 1
    dSP; dTARGET;
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
a177 12
#ifdef __Lynx__
/* Missing protos on LynxOS */
void sethostent(int);
void endhostent(void);
void setnetent(int);
void endnetent(void);
void setprotoent(int);
void endprotoent(void);
void setservent(int);
void endservent(void);
#endif

d425 1
a425 1
    if ((!tmps || !len) && PL_errgv) {
d460 1
a460 1
        tmps = SvROK(tmpsv) ? Nullch : SvPV(tmpsv, len);
d611 2
a612 2
    IoIFP(rstio) = PerlIO_fdopen(fd[0], "r"PIPE_OPEN_MODE);
    IoOFP(wstio) = PerlIO_fdopen(fd[1], "w"PIPE_OPEN_MODE);
a736 1
	SETERRNO(EBADF,RMS_IFI);
a742 8
	if (IoOFP(io) && IoOFP(io) != IoIFP(io)) {
	     if (!PerlIO_binmode(aTHX_ IoOFP(io),IoTYPE(io),
			mode_from_discipline(discp),
                       (discp) ? SvPV_nolen(discp) : Nullch)) {
		SPAGAIN;
		RETPUSHUNDEF;
	     }
	}
d764 1
d811 2
a812 2
	    DIE(aTHX_ "Can't locate object method \"%s\" via package \"%"SVf"\"",
		 methname, *MARK);
d855 1
a855 1
	SV *obj = SvRV(SvTIED_obj(sv, mg));
d877 1
a878 1
    sv_unmagic(sv, how) ;
d1018 1
a1018 7
#  if SELECT_MIN_BITS == 1
    growsize = sizeof(fd_set);
#  else
#   if defined(__GLIBC__) && defined(__FD_SETSIZE)
#      undef SELECT_MIN_BITS
#      define SELECT_MIN_BITS __FD_SETSIZE
#   endif
d1025 2
a1070 10
#ifdef PERL_IRIX5_SELECT_TIMEVAL_VOID_CAST
    /* Can't make just the (void*) conditional because that would be
     * cpp #if within cpp macro, and not all compilers like that. */
    nfound = PerlSock_select(
	maxlen * 8,
	(Select_fd_set_t) fd_sets[1],
	(Select_fd_set_t) fd_sets[2],
	(Select_fd_set_t) fd_sets[3],
	(void*) tbuf); /* Workaround for compiler bug. */
#else
a1076 1
#endif
a1179 1
	SETERRNO(EBADF,RMS_IFI);
d1209 2
d1218 2
a1219 1
    PAD_SET_CUR(CvPADLIST(cv), 1);
d1368 15
a1382 2
	    if (IoIFP(io))
		report_evil_fh(gv, io, OP_phoney_INPUT_ONLY);
d1450 1
a1450 1
	SETERRNO(EBADF,RMS_IFI);
d1455 14
a1468 2
	    if (IoIFP(io))
		report_evil_fh(gv, io, OP_phoney_INPUT_ONLY);
d1472 1
a1472 1
	SETERRNO(EBADF,IoIFP(io)?RMS_FAC:RMS_IFI);
d1577 1
a1577 4
    if (!io || !IoIFP(io)) {
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
	SETERRNO(EBADF,RMS_IFI);
a1578 1
    }
d1581 1
a1581 1
	/* UTF-8 may not have been set if they are all low bytes */
d1691 15
a1705 1
		report_evil_fh(gv, io, OP_phoney_OUTPUT_ONLY);
a1818 1
	SETERRNO(EBADF,RMS_IFI);
d1826 3
a1828 6
	 if (DO_UTF8(bufsv)) {
	      /* Not modifying source SV, so making a temporary copy. */
	      bufsv = sv_2mortal(newSVsv(bufsv));
	      sv_utf8_downgrade(bufsv, FALSE);
	 }
	 buffer = SvPV(bufsv, blen);
d2070 1
a2070 2
	IO *io;

d2074 4
a2077 3
	do_ftruncate_gv:
	    if (!GvIO(tmpgv))
		result = 0;
d2079 1
a2079 9
		PerlIO *fp;
		io = GvIOp(tmpgv);
	    do_ftruncate_io:
		TAINT_PROPER("truncate");
		if (!(fp = IoIFP(io))) {
		    result = 0;
		}
		else {
		    PerlIO_flush(fp);
d2081 1
a2081 1
		    if (ftruncate(PerlIO_fileno(fp), len) < 0)
d2083 1
a2083 1
		    if (my_chsize(PerlIO_fileno(fp), len) < 0)
d2085 1
a2085 2
			result = 0;
		}
d2094 1
a2094 1
		goto do_ftruncate_gv;
d2098 1
a2098 5
		goto do_ftruncate_gv;
	    }
	    else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVIO) {
		io = (IO*) SvRV(sv); /* *main::FRED{IO} for example */
		goto do_ftruncate_io;
d2124 1
a2124 1
	    SETERRNO(EBADF,RMS_IFI);
d2151 1
a2151 1
	SETERRNO(EBADF,RMS_IFI);	/* well, sort of... */
a2188 1
#endif
a2189 1
#if defined(HAS_IOCTL) || defined(HAS_FCNTL)
d2239 1
a2239 1
	SETERRNO(EBADF,RMS_IFI);
d2269 1
a2269 1
	SETERRNO(EBADF,LIB_INVARG);
d2280 2
a2281 2
    IoIFP(io) = PerlIO_fdopen(fd, "r"SOCKET_OPEN_MODE);	/* stdio gets confused about sockets */
    IoOFP(io) = PerlIO_fdopen(fd, "w"SOCKET_OPEN_MODE);
d2342 2
a2343 2
    IoIFP(io1) = PerlIO_fdopen(fd[0], "r"SOCKET_OPEN_MODE);
    IoOFP(io1) = PerlIO_fdopen(fd[0], "w"SOCKET_OPEN_MODE);
d2345 2
a2346 2
    IoIFP(io2) = PerlIO_fdopen(fd[1], "r"SOCKET_OPEN_MODE);
    IoOFP(io2) = PerlIO_fdopen(fd[1], "w"SOCKET_OPEN_MODE);
d2420 1
a2420 1
    SETERRNO(EBADF,SS_IVCHAN);
d2450 1
a2450 1
    SETERRNO(EBADF,SS_IVCHAN);
d2476 1
a2476 1
    SETERRNO(EBADF,SS_IVCHAN);
d2491 2
a2492 6
    char namebuf[MAXPATHLEN];
#if (defined(VMS_DO_SOCKETS) && defined(DECCRTL_SOCKETS)) || defined(MPE) || defined(__QNXNTO__)
    Sock_size_t len = sizeof (struct sockaddr_in);
#else
    Sock_size_t len = sizeof namebuf;
#endif
d2494 1
d2509 1
a2509 1
    fd = PerlSock_accept(PerlIO_fileno(IoIFP(gstio)), (struct sockaddr *) namebuf, &len);
d2514 6
a2519 2
    IoIFP(nstio) = PerlIO_fdopen(fd, "r"SOCKET_OPEN_MODE);
    IoOFP(nstio) = PerlIO_fdopen(fd, "w"SOCKET_OPEN_MODE);
d2529 1
d2533 1
a2533 1
    len = sizeof (struct sockaddr_in); /* EPOC somehow truncates info */
a2535 3
#ifdef __SCO_VERSION__
    len = sizeof (struct sockaddr_in); /* OpenUNIX 8 somehow truncates info */
#endif
d2537 1
a2537 1
    PUSHp(namebuf, len);
d2543 1
a2543 1
    SETERRNO(EBADF,SS_IVCHAN);
d2570 1
a2570 1
    SETERRNO(EBADF,SS_IVCHAN);
d2649 1
a2649 1
    SETERRNO(EBADF,SS_IVCHAN);
d2722 1
a2722 1
    SETERRNO(EBADF,SS_IVCHAN);
d2837 1
a2837 1
	PUSHs(sv_2mortal(newSVnv((NV)PL_statcache.st_size)));
d2867 2
a2868 2
    if ((PL_op->op_private & OPpFT_ACCESS) && SvPOK(TOPs)) {
	result = access(POPpx, R_OK);
d2894 2
a2895 2
    if ((PL_op->op_private & OPpFT_ACCESS) && SvPOK(TOPs)) {
	result = access(POPpx, W_OK);
d2921 2
a2922 2
    if ((PL_op->op_private & OPpFT_ACCESS) && SvPOK(TOPs)) {
	result = access(POPpx, X_OK);
d2948 2
a2949 2
    if ((PL_op->op_private & OPpFT_ACCESS) && SvPOK(TOPs)) {
	result = PERL_EFF_ACCESS_R_OK(POPpx);
d2975 2
a2976 2
    if ((PL_op->op_private & OPpFT_ACCESS) && SvPOK(TOPs)) {
	result = PERL_EFF_ACCESS_W_OK(POPpx);
d3002 2
a3003 2
    if ((PL_op->op_private & OPpFT_ACCESS) && SvPOK(TOPs)) {
	result = PERL_EFF_ACCESS_X_OK(POPpx);
d3080 1
a3080 1
    PUSHn( (((NV)PL_basetime - PL_statcache.st_mtime)) / 86400.0 );
d3090 1
a3090 1
    PUSHn( (((NV)PL_basetime - PL_statcache.st_atime)) / 86400.0 );
d3100 1
a3100 1
    PUSHn( (((NV)PL_basetime - PL_statcache.st_ctime)) / 86400.0 );
d3328 1
a3328 1
	    SETERRNO(EBADF,RMS_IFI);
d3340 1
a3340 1
	    if (ckWARN(WARN_NEWLINE) && strchr(SvPV(PL_statname, n_a), '\n'))
d3657 1
a3657 1
		SETERRNO(EEXIST,RMS_FEX);
d3659 1
a3659 1
		SETERRNO(EEXIST,RMS_FEX);
d3661 1
a3661 1
		SETERRNO(EEXIST,RMS_FEX);
d3663 1
a3663 1
		SETERRNO(ENOENT,RMS_FNF);
d3665 1
a3665 1
		SETERRNO(ENOENT,RMS_FNF);
d3667 1
a3667 1
		SETERRNO(EBUSY,SS_DEVOFFLINE);
d3669 1
a3669 1
		SETERRNO(EACCES,RMS_PRV);
d3671 1
a3671 1
		SETERRNO(EPERM,RMS_PRV);
d3681 1
a3681 1
		SETERRNO(EACCES,RMS_PRV);	/* a guess */
a3689 20
/* This macro removes trailing slashes from a directory name.
 * Different operating and file systems take differently to
 * trailing slashes.  According to POSIX 1003.1 1996 Edition
 * any number of trailing slashes should be allowed.
 * Thusly we snip them away so that even non-conforming
 * systems are happy.
 * We should probably do this "filtering" for all
 * the functions that expect (potentially) directory names:
 * -d, chdir(), chmod(), chown(), chroot(), fcntl()?,
 * (mkdir()), opendir(), rename(), rmdir(), stat(). --jhi */

#define TRIMSLASHES(tmps,len,copy) (tmps) = SvPV(TOPs, (len)); \
    if ((len) > 1 && (tmps)[(len)-1] == '/') { \
	do { \
	    (len)--; \
	} while ((len) > 1 && (tmps)[(len)-1] == '/'); \
	(tmps) = savepvn((tmps), (len)); \
	(copy) = TRUE; \
    }

d3706 16
a3721 1
    TRIMSLASHES(tmps,len,copy);
a3739 1
    STRLEN len;
d3741 1
a3741 1
    bool copy = FALSE;
d3743 1
a3743 1
    TRIMSLASHES(tmps,len,copy);
d3746 1
a3746 1
    SETi( PerlDir_rmdir(tmps) >= 0 );
d3748 1
a3748 1
    SETi( dooneliner("rmdir", tmps) );
a3749 2
    if (copy)
	Safefree(tmps);
d3775 1
a3775 1
	SETERRNO(EBADF,RMS_DIR);
d3784 2
a3785 3
#if !defined(Direntry_t) || !defined(HAS_READDIR)
    DIE(aTHX_ PL_no_dir_func, "readdir");
#else
a3788 5
    dSP;

    SV *sv;
    I32 gimme = GIMME;
    GV *gv = (GV *)POPs;
d3790 1
d3792 1
d3797 18
a3814 4
    do {
        dp = (Direntry_t *)PerlDir_read(IoDIRP(io));
        if (!dp)
            break;
d3816 1
a3816 1
        sv = newSVpvn(dp->d_name, dp->d_namlen);
d3818 1
a3818 1
        sv = newSVpv(dp->d_name, 0);
d3821 2
a3822 2
        if (!(IoFLAGS(io) & IOf_UNTAINT))
            SvTAINTED_on(sv);
d3824 1
a3824 1
        XPUSHs(sv_2mortal(sv));
a3825 5
    while (gimme == G_ARRAY);

    if (!dp && gimme != G_ARRAY)
        goto nope;

d3830 1
a3830 1
	SETERRNO(EBADF,RMS_ISI);
d3835 2
d3861 1
a3861 1
	SETERRNO(EBADF,RMS_ISI);
d3884 1
a3884 1
	SETERRNO(EBADF,RMS_ISI);
d3905 1
a3905 1
	SETERRNO(EBADF,RMS_ISI);
d3935 1
a3935 1
	SETERRNO(EBADF,RMS_IFI);
a3962 3
#ifdef THREADS_HAVE_PIDS
	PL_ppid = (IV)getppid();
#endif
d3992 5
a3996 7
    if (PL_signals & PERL_SIGNALS_UNSAFE_FLAG)
        childpid = wait4pid(-1, &argflags, 0);
    else {
        while ((childpid = wait4pid(-1, &argflags, 0)) == -1 &&
	       errno == EINTR) {
	  PERL_ASYNC_CHECK();
	}
d3998 1
d4016 1
a4016 2
    Pid_t pid;
    Pid_t result;
d4021 6
a4026 8
    pid = TOPi;
    if (PL_signals & PERL_SIGNALS_UNSAFE_FLAG)
        result = wait4pid(pid, &argflags, optype);
    else {
        while ((result = wait4pid(pid, &argflags, optype)) == -1 &&
	       errno == EINTR) {
	  PERL_ASYNC_CHECK();
	}
d4028 1
d4031 1
a4031 1
    STATUS_NATIVE_SET((result && result != -1) ? argflags : -1);
d4033 1
a4033 1
    STATUS_NATIVE_SET((result > 0) ? argflags : -1);
d4035 1
a4035 1
    SETi(result);
d4051 1
d4055 2
a4056 1
	    if (PL_tainted)
d4058 1
d4061 8
a4068 1
	TAINT_PROPER("system");
d4156 1
a4156 1
#  if defined(WIN32) || defined(OS2)
d4163 1
a4163 1
#  if defined(WIN32) || defined(OS2)
d4189 1
d4193 2
a4194 1
	    if (PL_tainted)
d4196 1
d4199 8
a4206 1
	TAINT_PROPER("exec");
a4261 3
#   ifdef THREADS_HAVE_PIDS
    XPUSHi( PL_ppid );
#   else
a4262 1
#   endif
d4367 20
d4400 1
a4400 1
    PUSHs(sv_2mortal(newSVnv(((NV)PL_timesbuf.tms_utime)/(NV)PL_clocktick)));
d4402 3
a4404 3
	PUSHs(sv_2mortal(newSVnv(((NV)PL_timesbuf.tms_stime)/(NV)PL_clocktick)));
	PUSHs(sv_2mortal(newSVnv(((NV)PL_timesbuf.tms_cutime)/(NV)PL_clocktick)));
	PUSHs(sv_2mortal(newSVnv(((NV)PL_timesbuf.tms_cstime)/(NV)PL_clocktick)));
a4407 11
#   ifdef PERL_MICRO
    dSP;
    PUSHs(sv_2mortal(newSVnv((NV)0.0)));
    EXTEND(SP, 4);
    if (GIMME == G_ARRAY) {
	 PUSHs(sv_2mortal(newSVnv((NV)0.0)));
	 PUSHs(sv_2mortal(newSVnv((NV)0.0)));
	 PUSHs(sv_2mortal(newSVnv((NV)0.0)));
    }
    RETURN;
#   else
a4408 1
#   endif
a4983 3
	if (proto && !*proto)
	    proto = Nullch;

d5169 1
a5169 1
     * There are at least three other shadow password APIs.  Many platforms
a5190 6
     * <userpw.h> (AIX)
     * struct userpw *getuserpw();
     * The password is in
     * char *(getuserpw(...)).spw_upw_passwd
     * (but the de facto standard getpwnam() should work okay)
     *
a5212 6
#   if defined(__CYGWIN__) && defined(USE_REENTRANT_API)
    /* Cygwin 1.5.3-1 has buggy getpwnam_r() and getpwuid_r():
     * the pw_comment is left uninitialized. */
    PL_reentrant_buffer->_pwent_struct.pw_comment = NULL;
#   endif

d5276 1
a5276 3
	/* Some AIX setups falsely(?) detect some getspnam(), which
	 * has a different API than the Solaris/IRIX one. */
#   if defined(HAS_GETSPNAM) && !defined(_AIX)
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d1330 1
a1330 1
		topname = sv_2mortal(Perl_newSVpvf(aTHX_ "%s_TOP", GvNAME(gv)));
d1823 1
a1823 5
	if (!SvUTF8(bufsv)) {
	    bufsv = sv_2mortal(newSVsv(bufsv));
	    buffer = sv_2pvutf8(bufsv, &blen);
	} else
	    buffer = SvPV(bufsv, blen);
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@a17 9
/* This file contains system pp ("push/pop") functions that
 * execute the opcodes that make up a perl program. A typical pp function
 * expects to find its arguments on the stack, and usually pushes its
 * results onto the stack, hence the 'pp' terminology. Each OP structure
 * contains a pointer to the relevant pp_foo() function.
 *
 * By 'system', we mean ops which interact with the OS, such as pp_open().
 */

d1659 1
a1659 4
	if (offset >= (int)blen)
	    offset += SvCUR(bufsv) - blen;
	else
	    offset = utf8_hop((U8 *)buffer,offset) - (U8 *) buffer;
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d48 6
d96 1
a96 1
  struct passwd *Perl_my_getpwent (pTHX);
a127 6
#else
# ifdef HAS_TRUNCATE
#   define my_chsize PerlLIO_chsize
# else
I32 my_chsize(int fd, Off_t length);
# endif
d176 1
a176 1
static const char zero_but_true[ZBTLEN + 1] = "0 but true";
a203 9
/* AIX 5.2 and below use mktime for localtime, and defines the edge case
 * for time 0x7fffffff to be valid only in UTC. AIX 5.3 provides localtime64
 * available in the 32bit environment, which could warrant Configure
 * checks in the future.
 */
#ifdef  _AIX
#define LOCALTIME_EDGECASE_BROKEN
#endif

a311 2
    (void)path;
    (void)mode;
d322 4
a325 3
    const char * const tmps = POPpconstx;
    const I32 gimme = GIMME_V;
    const char *mode = "r";
d332 1
a332 1
    fp = PerlProc_popen((char*)tmps, (char *)mode);
d334 1
a334 1
        const char *type = NULL;
d336 1
a336 1
	    type = SvPV_nolen_const(PL_curcop->cop_io);
d344 1
d348 1
a348 2
	    ENTER;
	    SAVESPTR(PL_rs);
d350 1
a350 1
	    sv_setpvn(TARG, "", 0);	/* note that this preserves previous buffer */
d352 1
d354 1
a354 1
	    LEAVE;
d359 2
d362 1
a362 1
		SV * const sv = NEWSV(56, 79);
d369 2
a370 1
		    SvPV_shrink_to_cur(sv);
d435 1
a435 1
    const char *tmps;
d437 1
a437 1
    if (SP - MARK > 1) {
a442 4
    else if (SP == MARK) {
	tmpsv = &PL_sv_no;
	EXTEND(SP, 1);
    }
d446 1
a446 1
    tmps = SvPV_const(tmpsv, len);
d448 1
a448 1
  	SV * const error = ERRSV;
d453 1
a453 1
	tmps = SvPV_const(tmpsv, len);
d465 1
a465 1
    const char *tmps;
d476 1
a476 1
	tmps = SvPV_const(tmpsv, len);
d482 1
a482 1
        tmps = SvROK(tmpsv) ? Nullch : SvPV_const(tmpsv, len);
d507 1
a507 1
	    DIE(aTHX_ Nullch);
d513 1
a513 4
	    if (SvOK(tmpsv))
		tmps = SvPV_const(tmpsv, len);
	    else
		tmps = Nullch;
d532 1
a532 1
    const char *tmps;
d560 1
a560 1
	sv = GvSVn(gv);
d563 2
a564 2
    tmps = SvPV_const(sv, len);
    ok = do_openn(gv, (char *)tmps, len, FALSE, O_RDONLY, 0, Nullfp, MARK+1, (SP-MARK));
d700 1
a700 1
    dSP;
a701 1
    dTARGET;
d713 1
a713 1
    /* Only DIE if trying to restrict permissions on "user" (self).
d765 1
a765 1
                       (discp) ? SvPV_nolen_const(discp) : Nullch)) {
d769 1
a769 1
                       (discp) ? SvPV_nolen_const(discp) : Nullch)) {
d785 2
a786 1
    dSP; dMARK;
d791 2
a792 2
    const I32 markoff = MARK - PL_stack_base;
    const char *methname;
d800 1
a800 1
	    HvEITER_set((HV *)varsv, 0);
d878 1
a878 1
    const char how = (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV)
d885 1
a885 1
	SV * const obj = SvRV(SvTIED_obj(sv, mg));
d900 2
a901 1
	    else if (mg && SvREFCNT(obj) > 1 && ckWARN(WARN_UNTIE)) {
d915 1
a915 1
    const MAGIC *mg;
d917 1
a917 1
    const char how = (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV)
d936 1
d942 1
a942 1
    HV * const hv = (HV*)POPs;
d1010 1
d1026 1
a1026 2
	SV *sv = SP[i];
	if (!SvOK(sv))
d1028 1
a1028 12
	if (SvREADONLY(sv)) {
	    if (SvIsCOW(sv))
		sv_force_normal_flags(sv, 0);
	    if (SvREADONLY(sv) && !(SvPOK(sv) && SvCUR(sv) == 0))
		DIE(aTHX_ PL_no_modify);
	}
	if (!SvPOK(sv)) {
	    if (ckWARN(WARN_MISC))
                Perl_warner(aTHX_ packWARN(WARN_MISC), "Non-string passed as bitmask");
	    SvPV_force_nolen(sv);	/* force string conversion */
	}
	j = SvCUR(sv);
d1077 1
a1077 1
	if (!SvOK(sv) || SvCUR(sv) == 0) {
d1081 2
a1082 1
	assert(SvPOK(sv));
d1095 1
a1095 1
	Newx(fd_sets[i], growsize, char);
d1163 1
a1163 1
    GV *egv;
d1166 1
a1166 1
    GV * const newdefout = (PL_op->op_private > 0) ? ((GV *) POPs) : (GV *) NULL;
d1175 1
a1175 1
	GV ** const gvp = (GV**)hv_fetch(hv, GvNAME(egv), GvNAMELEN(egv), FALSE);
d1197 1
d1200 5
a1204 1
    GV * const gv = (MAXARG==0) ? PL_stdingv : (GV*)POPs;
d1209 1
a1209 1
	const I32 gimme = GIMME_V;
d1222 2
a1223 2
	if ((!io || (!IoIFP(io) && IoTYPE(io) != IoTYPE_WRONLY))
	  && ckWARN2(WARN_UNOPENED,WARN_CLOSED))
d1229 1
a1229 1
    sv_setpvn(TARG, " ", 1);
d1233 1
a1233 1
	Size_t len = UTF8SKIP(SvPVX_const(TARG));
d1254 1
a1254 1
    const I32 gimme = GIMME_V;
d1262 1
a1262 2
    SAVECOMPPAD();
    PAD_SET_CUR_NOSAVE(CvPADLIST(cv), 1);
d1295 1
d1297 1
a1297 2
	    SV * const tmpsv = sv_newmortal();
	    const char *name;
d1299 1
a1299 3
	    name = SvPV_nolen_const(tmpsv);
	    if (name && *name)
		DIE(aTHX_ "Undefined format \"%s\" called", name);
d1301 2
d1315 3
a1317 3
    GV * const gv = cxstack[cxstack_ix].blk_sub.gv;
    register IO * const io = GvIOp(gv);
    PerlIO * const ofp = IoOFP(io);
d1334 1
a1336 1
		SV *topname;
d1343 1
a1343 1
		    IoTOP_NAME(io) = savesvpv(topname);
d1349 1
a1349 1
		IoLINES_LEFT(io) = IoPAGE_LEN(io);
d1356 1
a1356 1
	    const char *s = SvPVX_const(PL_formtarget);
d1366 2
a1367 2
		const STRLEN save = SvCUR(PL_formtarget);
		SvCUR_set(PL_formtarget, s - SvPVX_const(PL_formtarget));
d1370 1
a1370 1
		sv_chop(PL_formtarget, (char *)s);
d1384 7
a1390 5
	if (!cv) {
	    SV * const sv = sv_newmortal();
	    const char *name;
	    gv_efullname4(sv, fgv, Nullch, FALSE);
	    name = SvPV_nolen_const(sv);
d1392 5
a1396 1
		DIE(aTHX_ "Undefined top format \"%s\" called",name);
a1397 4
	/* why no:
	else
	    DIE(aTHX_ "Undefined top format called");
	?*/
a1436 2
    PERL_UNUSED_VAR(newsp);
    PERL_UNUSED_VAR(gimme);
d1517 3
a1519 4
    const int perm = (MAXARG > 3) ? POPi : 0666;
    const int mode = POPi;
    SV * const sv = POPs;
    GV * const gv = (GV *)POPs;
d1521 9
d1532 3
a1534 3
    const char * const tmps = SvPV_const(sv, len);
    /* FIXME? do_open should do const  */
    if (do_open(gv, (char*)tmps, len, TRUE, mode, perm, Nullfp)) {
d1548 1
d1556 1
a1557 2
    int buffer_utf8;
    SV *read_target;
d1564 1
a1564 1
    GV * const gv = (GV*)*++MARK;
d1566 2
a1567 1
	&& gv && (io = GvIO(gv)) )
d1569 12
a1580 14
	const MAGIC * mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    SV *sv;
	    PUSHMARK(MARK-1);
	    *MARK = SvTIED_obj((SV*)io, mg);
	    ENTER;
	    call_method("READ", G_SCALAR);
	    LEAVE;
	    SPAGAIN;
	    sv = POPs;
	    SP = ORIGMARK;
	    PUSHs(sv);
	    RETURN;
	}
a1604 1
	buffer_utf8 = 0;
a1607 1
	buffer_utf8 = !IN_BYTES && SvUTF8(bufsv);
a1674 5
    /* Allocating length + offset + 1 isn't perfect in the case of reading
       bytes from a byte file handle into a UTF8 buffer, but it won't harm us
       unduly.
       (should be 2 * length + offset + 1, or possibly something longer if
       PL_encoding is true) */
d1676 1
a1676 1
    if (offset > 0 && (Sock_size_t)offset > bufsize) { /* Zero any newly allocated space */
a1679 14
    if (!buffer_utf8) {
	read_target = bufsv;
    } else {
	/* Best to read the bytes into a new SV, upgrade that to UTF8, then
	   concatenate it to the current buffer.  */

	/* Truncate the existing buffer to the start of where we will be
	   reading to:  */
	SvCUR_set(bufsv, offset);

	read_target = sv_newmortal();
	(void)SvUPGRADE(read_target, SVt_PV);
	buffer = SvGROW(read_target, (STRLEN)(length + 1));
    }
d1719 3
a1721 3
    SvCUR_set(read_target, count+(buffer - SvPVX_const(read_target)));
    *SvEND(read_target) = '\0';
    (void)SvPOK_only(read_target);
d1724 1
a1724 1
	const char *bend = buffer + count;
d1733 1
a1733 1
		offset = bend - SvPVX_const(bufsv);
d1750 1
a1750 1
	    offset = bend - SvPVX_const(bufsv);
a1756 5
    else if (buffer_utf8) {
	/* Let svcatsv upgrade the bytes we read in to utf8.
	   The buffer is a mortal so will be freed soon.  */
	sv_catsv_nomg(bufsv, read_target);
    }
d1773 1
a1773 1
    const int items = (SP - PL_stack_base) - TOPMARK;
d1790 1
a1790 1
    const char *buffer;
d1839 1
a1839 1
	    buffer = SvPV_const(bufsv, blen);
d1847 1
a1847 1
	 buffer = SvPV_const(bufsv, blen);
d1869 1
a1869 1
	    buffer = (const char*)utf8_hop((U8 *)buffer, offset);
d1890 1
d1892 1
a1892 1
	char * const sockbuf = SvPVx(*++MARK, mlen);
d1942 1
a1942 1
		    do_open(gv, (char *)"-", 1, FALSE, O_RDONLY, 0, Nullfp);
d2016 1
a2016 1
    const int whence = POPi;
d2084 1
d2086 1
d2118 1
a2118 1
	    const  char *name;
d2133 1
a2133 1
	    name = SvPV_nolen_const(sv);
d2159 3
d2173 2
a2174 2
    const unsigned int func = POPu;
    const int optype = PL_op->op_type;
d2406 4
d2411 1
a2411 2
    /* OK, so on what platform does bind modify addr?  */
    const char *addr;
d2416 3
d2423 1
a2423 1
    addr = SvPV_const(addrsv, len);
d2425 12
d2441 4
d2466 1
a2466 1
    const char *addr;
d2474 1
a2474 1
    addr = SvPV_const(addrsv, len);
d2661 1
a2661 1
	    const char *buf;
d2665 1
a2665 1
		buf = SvPV_const(sv, l);
d2670 1
a2670 1
		buf = (const char*)&aint;
d2734 2
a2735 2
	    if (((struct sockaddr *)SvPVX_const(sv))->sa_family == AF_INET &&
		!memcmp((char *)SvPVX_const(sv) + sizeof(u_short), nowhere,
d2779 1
d2796 1
a2796 1
	    sv_setpvn(PL_statname, "", 0);
d2819 1
a2819 1
	sv_setpv(PL_statname, SvPV_nolen_const(sv));
d2821 1
d2824 1
a2824 1
	    PL_laststatval = PerlLIO_lstat(SvPV_nolen_const(PL_statname), &PL_statcache);
d2826 2
a2827 1
	    PL_laststatval = PerlLIO_stat(SvPV_nolen_const(PL_statname), &PL_statcache);
d2829 1
a2829 1
	    if (ckWARN(WARN_NEWLINE) && strchr(SvPV_nolen_const(PL_statname), '\n'))
d2901 1
d2928 1
d2955 1
d2982 1
d3009 1
d3036 1
d3264 1
d3305 1
d3330 1
a3330 1
	    sv_setpvn(PL_statname, "", 0);
d3371 1
d3373 3
a3375 4
	sv_setpv(PL_statname, SvPV_nolen_const(sv));
	if (!(fp = PerlIO_open(SvPVX_const(PL_statname), "r"))) {
	    if (ckWARN(WARN_NEWLINE) && strchr(SvPV_nolen_const(PL_statname),
					       '\n'))
d3459 1
a3459 2
    const char *tmps = 0;
    GV *gv = 0;
d3461 1
d3463 4
a3466 12
    if( MAXARG == 1 ) {
	SV *sv = POPs;
        if (SvTYPE(sv) == SVt_PVGV) {
	    gv = (GV*)sv;
        }
	else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVGV) {
            gv = (GV*)SvRV(sv);
        }
        else {
	    tmps = SvPVx_nolen_const(sv);
	}
    }
d3468 1
a3468 1
    if( !gv && (!tmps || !*tmps) ) {
d3478 1
a3478 1
            tmps = SvPV_nolen_const(*svp);
d3488 1
a3488 27
    if (gv) {
#ifdef HAS_FCHDIR
	IO* io = GvIO(gv);
	if (io) {
	    if (IoIFP(io)) {
		PUSHi(fchdir(PerlIO_fileno(IoIFP(io))) >= 0);
	    }
	    else if (IoDIRP(io)) {
#ifdef HAS_DIRFD
		PUSHi(fchdir(dirfd(IoDIRP(io))) >= 0);
#else
		DIE(aTHX_ PL_no_func, "dirfd");
#endif
	    }
	    else {
		PUSHi(0);
	    }
        }
	else {
	    PUSHi(0);
	}
#else
	DIE(aTHX_ PL_no_func, "fchdir");
#endif
    }
    else 
	PUSHi( PerlDir_chdir((char *)tmps) >= 0 );
d3504 1
a3504 1
    XPUSHi(value);
d3515 1
d3559 4
a3562 2
    const char *tmps2 = POPpconstx;
    const char *tmps = SvPV_nolen_const(TOPs);
d3586 3
a3588 2
    const char *tmps2 = POPpconstx;
    const char *tmps = SvPV_nolen_const(TOPs);
d3601 3
a3603 2
    const char *tmps2 = POPpconstx;
    const char *tmps = SvPV_nolen_const(TOPs);
d3617 1
a3617 1
    const char *tmps;
d3620 1
d3625 1
a3625 1
    tmps = POPpconstx;
d3640 1
a3640 1
S_dooneliner(pTHX_ const char *cmd, const char *filename)
d3642 1
a3642 1
    char * const save_filename = filename;
d3648 1
a3648 1
    Newx(cmdline, strlen(cmd) + (strlen(filename) * 2) + 10, char);
d3736 1
a3736 1
#define TRIMSLASHES(tmps,len,copy) (tmps) = SvPV_const(TOPs, (len)); \
d3753 1
a3753 1
    const char *tmps;
d3765 1
a3765 1
    SETi( PerlDir_mkdir((char *)tmps, mode) >= 0 );
d3781 1
a3781 1
    const char *tmps;
d3787 1
a3787 1
    SETi( PerlDir_rmdir((char *)tmps) >= 0 );
d3802 2
a3803 1
    const char *dirname = POPpconstx;
d3812 1
a3812 1
    if (!(IoDIRP(io) = PerlDir_open((char *)dirname)))
d3836 1
a3836 1
    const I32 gimme = GIMME;
d3993 1
d4088 1
d4090 1
d4095 1
a4095 1
	    (void)SvPV_nolen_const(*MARK);      /* stringify for taint check */
a4106 1
	I32 did_pipes = 0;
d4114 1
a4114 1
		XPUSHi(value);
d4163 1
a4163 1
	    XPUSHi(STATUS_CURRENT);
d4179 1
a4179 1
	    value = (I32)do_exec3(SvPVx_nolen(sv_mortalcopy(*SP)), pp[1], did_pipes);
d4188 1
a4188 1
#  if defined(WIN32) || defined(OS2) || defined(SYMBIAN)
d4195 1
a4195 1
#  if defined(WIN32) || defined(OS2) || defined(SYMBIAN)
d4202 1
a4202 1
	value = (I32)do_spawn(SvPVx_nolen(sv_mortalcopy(*SP)));
d4209 1
a4209 1
    XPUSHi(result ? value : STATUS_CURRENT);
d4218 1
d4223 1
a4223 1
	    (void)SvPV_nolen_const(*MARK);      /* stringify for taint check */
d4250 1
a4250 1
	value = (I32)vms_do_exec(SvPVx_nolen(sv_mortalcopy(*SP)));
d4253 1
a4253 1
	(void) do_spawn(SvPVx_nolen(sv_mortalcopy(*SP)));
d4256 1
a4256 1
	value = (I32)do_exec(SvPVx_nolen(sv_mortalcopy(*SP)));
d4262 1
a4262 1
    XPUSHi(value);
a4284 3
    if (PL_ppid != 1 && getppid() == 1)
	/* maybe the parent process has died. Refresh ppid cache */
	PL_ppid = 1;
a4434 40
#ifdef LOCALTIME_EDGECASE_BROKEN
static struct tm *S_my_localtime (pTHX_ Time_t *tp)
{
    auto time_t     T;
    auto struct tm *P;

    /* No workarounds in the valid range */
    if (!tp || *tp < 0x7fff573f || *tp >= 0x80000000)
	return (localtime (tp));

    /* This edge case is to workaround the undefined behaviour, where the
     * TIMEZONE makes the time go beyond the defined range.
     * gmtime (0x7fffffff) => 2038-01-19 03:14:07
     * If there is a negative offset in TZ, like MET-1METDST, some broken
     * implementations of localtime () (like AIX 5.2) barf with bogus
     * return values:
     * 0x7fffffff gmtime               2038-01-19 03:14:07
     * 0x7fffffff localtime            1901-12-13 21:45:51
     * 0x7fffffff mylocaltime          2038-01-19 04:14:07
     * 0x3c19137f gmtime               2001-12-13 20:45:51
     * 0x3c19137f localtime            2001-12-13 21:45:51
     * 0x3c19137f mylocaltime          2001-12-13 21:45:51
     * Given that legal timezones are typically between GMT-12 and GMT+12
     * we turn back the clock 23 hours before calling the localtime
     * function, and add those to the return value. This will never cause
     * day wrapping problems, since the edge case is Tue Jan *19*
     */
    T = *tp - 82800; /* 23 hour. allows up to GMT-23 */
    P = localtime (&T);
    P->tm_hour += 23;
    if (P->tm_hour >= 24) {
	P->tm_hour -= 24;
	P->tm_mday++;	/* 18  -> 19  */
	P->tm_wday++;	/* Mon -> Tue */
	P->tm_yday++;	/* 18  -> 19  */
    }
    return (P);
} /* S_my_localtime */
#endif

d4439 4
a4442 6
    const struct tm *tmbuf;
    static const char * const dayname[] =
	{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    static const char * const monname[] =
	{"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
a4453 3
#ifdef LOCALTIME_EDGECASE_BROKEN
	tmbuf = S_my_localtime(aTHX_ &when);
#else
a4454 1
#endif
d4678 1
d4794 1
d4895 1
d4982 1
d5178 1
d5457 1
d5569 1
d5592 1
a5592 1
	    a[i++] = (unsigned long)SvPV_force_nolen(*MARK);
a5774 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d3 2
a4 2
 *    Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
 *    2004, 2005, 2006, 2007 by Larry Wall and others
d200 3
a202 1
#undef PERL_EFF_ACCESS	/* EFFective uid/gid ACCESS */
d215 1
a215 1
#if !defined(PERL_EFF_ACCESS) && defined(HAS_ACCESS) && defined(EFF_ONLY_OK) && !defined(NO_EFF_ONLY_OK)
d217 3
a219 1
#   define PERL_EFF_ACCESS(p,f) (access((p), (f) | EFF_ONLY_OK))
d222 1
a222 1
#if !defined(PERL_EFF_ACCESS) && defined(HAS_EACCESS)
d228 3
a230 1
#       define PERL_EFF_ACCESS(p,f) (eaccess((p), (f), ACC_SELF))
d233 3
a235 1
#       define PERL_EFF_ACCESS(p,f) (eaccess((p), (f)))
d239 1
a239 1
#if !defined(PERL_EFF_ACCESS) && defined(HAS_ACCESSX) && defined(ACC_SELF)
d241 3
a243 1
#   define PERL_EFF_ACCESS(p,f) (accessx((p), (f), ACC_SELF))
d246 1
a246 2

#if !defined(PERL_EFF_ACCESS) && defined(HAS_ACCESS)	\
d253 4
a256 4
    const Uid_t ruid = getuid();
    const Uid_t euid = geteuid();
    const Gid_t rgid = getgid();
    const Gid_t egid = getegid();
d309 18
a326 1
#   define PERL_EFF_ACCESS(p,f) (S_emulate_eaccess(aTHX_ (p), (f)))
d331 1
a331 1
    dVAR; dSP; dTARGET;
d342 1
a342 1
    fp = PerlProc_popen(tmps, mode);
d344 4
a347 1
        const char * const type = Perl_PerlIO_context_layers(aTHX_ NULL);
d354 1
a354 1
		NOOP;
d361 2
a362 2
	    while (sv_gets(TARG, fp, SvCUR(TARG)) != NULL)
		NOOP;
d369 2
a370 2
		SV * const sv = newSV(79);
		if (sv_gets(sv, fp, 0) == NULL) {
d381 1
a381 1
	STATUS_NATIVE_CHILD_SET(PerlProc_pclose(fp));
d385 1
a385 1
	STATUS_NATIVE_CHILD_SET(-1);
a394 1
    dVAR;
d419 1
a419 1
    PL_rs = sv_2mortal(newSVpvs("\000"));
a432 1
    dVAR;
d439 1
a439 1
    dVAR; dSP; dMARK;
a451 1
	SP = MARK + 1;
d459 1
a459 1
	SvUPGRADE(error, SVt_PV);
d461 1
a461 1
	    sv_catpvs(error, "\t...caught");
d466 1
a466 1
	tmpsv = sv_2mortal(newSVpvs("Warning: something's wrong"));
d468 1
a468 1
    Perl_warn(aTHX_ "%"SVf, SVfARG(tmpsv));
d474 1
a474 1
    dVAR; dSP; dMARK;
d492 1
a492 1
        tmps = SvROK(tmpsv) ? (const char *)NULL : SvPV_const(tmpsv, len);
d495 2
a496 2
	SV * const error = ERRSV;
	SvUPGRADE(error, SVt_PV);
d501 2
a502 2
		HV * const stash = SvSTASH(SvRV(error));
		GV * const gv = gv_fetchmethod(stash, "PROPAGATE");
d504 2
a505 2
		    SV * const file = sv_2mortal(newSVpv(CopFILE(PL_curcop),0));
		    SV * const line = sv_2mortal(newSVuv(CopLINE(PL_curcop)));
d517 1
a517 1
	    DIE(aTHX_ NULL);
d521 1
a521 1
		sv_catpvs(error, "\t...propagated");
d526 1
a526 1
		tmps = NULL;
d530 1
a530 1
	tmpsv = sv_2mortal(newSVpvs("Died"));
d532 1
a532 1
    DIE(aTHX_ "%"SVf, SVfARG(tmpsv));
d539 1
a539 1
    dVAR; dSP;
d542 1
d547 1
d550 1
a550 2
    GV * const gv = (GV *)*++MARK;

d553 1
a553 3

    if ((io = GvIOp(gv))) {
	MAGIC *mg;
d556 11
a566 17
	if (IoDIRP(io) && ckWARN2(WARN_IO, WARN_DEPRECATED))
	    Perl_warner(aTHX_ packWARN2(WARN_IO, WARN_DEPRECATED),
		    "Opening dirhandle %s also as a file", GvENAME(gv));

	mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    /* Method's args are same as ours ... */
	    /* ... except handle is replaced by the object */
	    *MARK-- = SvTIED_obj((SV*)io, mg);
	    PUSHMARK(MARK);
	    PUTBACK;
	    ENTER;
	    call_method("OPEN", G_SCALAR);
	    LEAVE;
	    SPAGAIN;
	    RETURN;
	}
d577 1
a577 1
    ok = do_openn(gv, tmps, len, FALSE, O_RDONLY, 0, NULL, MARK+1, (SP-MARK));
d590 9
a598 2
    dVAR; dSP;
    GV * const gv = (MAXARG == 0) ? PL_defoutgv : (GV*)POPs;
d600 11
a610 15
    if (gv) {
	IO * const io = GvIO(gv);
	if (io) {
	    MAGIC * const mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
	    if (mg) {
		PUSHMARK(SP);
		XPUSHs(SvTIED_obj((SV*)io, mg));
		PUTBACK;
		ENTER;
		call_method("CLOSE", G_SCALAR);
		LEAVE;
		SPAGAIN;
		RETURN;
	    }
	}
a619 1
    dVAR;
d621 2
d627 2
a628 2
    GV * const wgv = (GV*)POPs;
    GV * const rgv = (GV*)POPs;
d654 4
a657 8
	if (IoIFP(rstio))
	    PerlIO_close(IoIFP(rstio));
	else
	    PerlLIO_close(fd[0]);
	if (IoOFP(wstio))
	    PerlIO_close(IoOFP(wstio));
	else
	    PerlLIO_close(fd[1]);
d675 1
a675 1
    dVAR; dSP; dTARGET;
a712 1
    dVAR;
d719 2
a720 6
	anum = PerlLIO_umask(022);
	/* setting it to 022 between the two calls to umask avoids
	 * to have a window where the umask is set to 0 -- meaning
	 * that another thread could create world-writeable files. */
	if (anum != 022)
	    (void)PerlLIO_umask(anum);
d739 1
a739 1
    dVAR; dSP;
d743 2
a744 1
    SV *discp = NULL;
d754 13
a766 14
    if (gv && (io = GvIO(gv))) {
	MAGIC * const mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    PUSHMARK(SP);
	    XPUSHs(SvTIED_obj((SV*)io, mg));
	    if (discp)
		XPUSHs(discp);
	    PUTBACK;
	    ENTER;
	    call_method("BINMODE", G_SCALAR);
	    LEAVE;
	    SPAGAIN;
	    RETURN;
	}
d778 9
a786 16
    {
	const int mode = mode_from_discipline(discp);
	const char *const d = (discp ? SvPV_nolen_const(discp) : NULL);
	if (PerlIO_binmode(aTHX_ fp, IoTYPE(io), mode, d)) {
	    if (IoOFP(io) && IoOFP(io) != IoIFP(io)) {
		if (!PerlIO_binmode(aTHX_ IoOFP(io), IoTYPE(io), mode, d)) {
		    SPAGAIN;
		    RETPUSHUNDEF;
		}
	    }
	    SPAGAIN;
	    RETPUSHYES;
	}
	else {
	    SPAGAIN;
	    RETPUSHUNDEF;
d788 6
d799 2
a800 1
    dVAR; dSP; dMARK;
a807 1
    SV *varsv = *++MARK;
d809 1
d852 1
a852 1
	stash = gv_stashsv(*MARK, 0);
d855 1
a855 1
		 methname, SVfARG(*MARK));
d878 1
a878 1
	sv_magic(varsv, (SvRV(sv) == varsv ? NULL : sv), how, NULL, 0);
d888 1
a888 1
    dVAR; dSP;
d899 2
d902 2
a903 3
	    GV * const gv = gv_fetchmethod_autoload(SvSTASH(obj), "UNTIE", FALSE);
	    CV *cv;
	    if (gv && isGV(gv) && (cv = GvCV(gv))) {
d917 1
a917 1
	    }
a925 1
    dVAR;
d947 1
a947 1
    dVAR; dSP;
d951 1
d954 4
a957 2
    SV * const sv = sv_2mortal(newSVpvs("AnyDBM_File"));
    stash = gv_stashsv(sv, 0);
d995 1
a995 1
	sv_magic((SV*)hv, TOPs, PERL_MAGIC_tied, NULL, 0);
d1001 5
d1009 1
a1009 1
    dVAR; dSP; dTARGET;
d1036 1
a1036 1
	SV * const sv = SP[i];
d1095 1
a1095 1
	tbuf = NULL;
d1162 2
a1163 1
	PUSHs(sv_2mortal(newSVnv(value)));
d1174 2
a1175 2
    dVAR;
    SvREFCNT_inc_simple_void(gv);
d1183 2
a1184 1
    dVAR; dSP; dTARGET;
a1185 2
    GV * const newdefout = (PL_op->op_private > 0) ? ((GV *) POPs) : NULL;
    GV * egv = GvEGV(PL_defoutgv);
d1187 3
d1196 1
a1196 1
	GV * const * const gvp = (GV**)hv_fetch(hv, GvNAME(egv), GvNAMELEN(egv), FALSE);
d1198 1
a1198 1
	    gv_efullname4(TARG, PL_defoutgv, NULL, TRUE);
d1217 1
a1217 1
    dVAR; dSP; dTARGET;
d1219 1
d1222 14
a1235 15
    if (gv && (io = GvIO(gv))) {
	MAGIC * const mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    const I32 gimme = GIMME_V;
	    PUSHMARK(SP);
	    XPUSHs(SvTIED_obj((SV*)io, mg));
	    PUTBACK;
	    ENTER;
	    call_method("GETC", gimme);
	    LEAVE;
	    SPAGAIN;
	    if (gimme == G_SCALAR)
		SvSetMagicSV_nosteal(TARG, TOPs);
	    RETURN;
	}
d1261 5
a1268 1
    dVAR;
d1275 1
a1277 1
    cx->blk_sub.retop = retop;
a1286 1
    dVAR;
a1291 1
    SV * tmpsv = NULL;
a1309 3
    if (!fgv)
	goto not_a_format_reference;

d1312 8
a1319 8
	const char *name;
	tmpsv = sv_newmortal();
	gv_efullname4(tmpsv, fgv, NULL, FALSE);
	name = SvPV_nolen_const(tmpsv);
	if (name && *name)
	    DIE(aTHX_ "Undefined format \"%s\" called", name);

	not_a_format_reference:
d1331 1
a1331 1
    dVAR; dSP;
d1334 1
a1334 1
    PerlIO *ofp;
a1339 3
    if (!io || !(ofp = IoOFP(io)))
        goto forget_top;

d1342 2
a1343 1

d1357 1
a1357 1
		topgv = gv_fetchsv(topname, 0, SVt_PVFM);
d1359 1
a1359 1
		  !gv_fetchpvs("top", GV_NOTQUAL, SVt_PVFM))
d1362 1
a1362 1
		    IoTOP_NAME(io) = savepvs("top");
d1364 1
a1364 1
	    topgv = gv_fetchpv(IoTOP_NAME(io), 0, SVt_PVFM);
d1387 1
a1387 1
		sv_chop(PL_formtarget, s);
d1404 1
a1404 1
	    gv_efullname4(sv, fgv, NULL, FALSE);
d1407 1
a1407 3
		DIE(aTHX_ "Undefined top format \"%s\" called", name);
	    else
		DIE(aTHX_ "Undefined top format called");
d1409 5
a1413 1
	if (cv && CvCLONE(cv))
d1415 1
a1415 1
	return doform(cv, gv, PL_op);
d1454 1
a1454 1
    return cx->blk_sub.retop;
d1459 2
a1460 1
    dVAR; dSP; dMARK; dORIGMARK;
d1464 1
d1466 4
a1469 1
    GV * const gv = (PL_op->op_flags & OPf_STACKED) ? (GV*)*++MARK : PL_defoutgv;
d1471 8
a1478 20
    if (gv && (io = GvIO(gv))) {
	MAGIC * const mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    if (MARK == ORIGMARK) {
		MEXTEND(SP, 1);
		++MARK;
		Move(MARK, MARK + 1, (SP - MARK) + 1, SV*);
		++SP;
	    }
	    PUSHMARK(MARK - 1);
	    *MARK = SvTIED_obj((SV*)io, mg);
	    PUTBACK;
	    ENTER;
	    call_method("PRINTF", G_SCALAR);
	    LEAVE;
	    SPAGAIN;
	    MARK = ORIGMARK + 1;
	    *MARK = *SP;
	    SP = MARK;
	    RETURN;
d1480 11
d1493 1
a1493 1
    sv = newSV(0);
a1510 2
	if (SvTAINTED(MARK[1]))
	    TAINT_PROPER("printf");
a1532 1
    dVAR;
d1543 1
a1543 1
    if (do_open(gv, tmps, len, TRUE, mode, perm, NULL)) {
d1555 1
a1555 1
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
d1644 1
a1644 1
				  (struct sockaddr *)namebuf, &bufsize);
d1708 1
a1708 1
	SvUPGRADE(read_target, SVt_PV);
d1806 14
d1822 2
a1823 1
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
d1827 1
d1830 3
a1832 6
    STRLEN orig_blen_bytes;
    const int op_type = PL_op->op_type;
    bool doing_utf8;
    U8 *tmpbuf = NULL;
    
    GV *const gv = (GV*)*++MARK;
d1834 15
a1848 23
	&& gv && (io = GvIO(gv))) {
	MAGIC * const mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    SV *sv;

	    if (MARK == SP - 1) {
		EXTEND(SP, 1000);
		sv = sv_2mortal(newSViv(sv_len(*SP)));
		PUSHs(sv);
		PUTBACK;
	    }

	    PUSHMARK(ORIGMARK);
	    *(ORIGMARK+1) = SvTIED_obj((SV*)io, mg);
	    ENTER;
	    call_method("WRITE", G_SCALAR);
	    LEAVE;
	    SPAGAIN;
	    sv = POPs;
	    SP = ORIGMARK;
	    PUSHs(sv);
	    RETURN;
	}
a1851 1

d1853 7
a1859 1

d1862 1
a1862 1
    if (!io || !IoIFP(io) || IoTYPE(io) == IoTYPE_RDONLY) {
d1864 2
a1865 6
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED)) {
	    if (io && IoIFP(io))
		report_evil_fh(gv, io, OP_phoney_INPUT_ONLY);
	    else
		report_evil_fh(gv, io, PL_op->op_type);
	}
a1869 5
    /* Do this first to trigger any overloading.  */
    buffer = SvPV_const(bufsv, blen);
    orig_blen_bytes = blen;
    doing_utf8 = DO_UTF8(bufsv);

d1872 4
a1875 5
	    /* We don't modify the original scalar.  */
	    tmpbuf = bytes_to_utf8((const U8*) buffer, &blen);
	    buffer = (char *) tmpbuf;
	    doing_utf8 = TRUE;
	}
d1877 7
a1883 12
    else if (doing_utf8) {
	STRLEN tmplen = blen;
	U8 * const result = bytes_from_utf8((const U8*) buffer, &tmplen, &doing_utf8);
	if (!doing_utf8) {
	    tmpbuf = result;
	    buffer = (char *) tmpbuf;
	    blen = tmplen;
	}
	else {
	    assert((char *)result == buffer);
	    Perl_croak(aTHX_ "Wide character in %s", OP_DESC(PL_op));
	}
d1886 1
a1886 3
    if (op_type == OP_SYSWRITE) {
	Size_t length = 0; /* This length is in characters.  */
	STRLEN blen_chars;
d1888 3
a1890 33

	if (doing_utf8) {
	    if (tmpbuf) {
		/* The SV is bytes, and we've had to upgrade it.  */
		blen_chars = orig_blen_bytes;
	    } else {
		/* The SV really is UTF-8.  */
		if (SvGMAGICAL(bufsv) || SvAMAGIC(bufsv)) {
		    /* Don't call sv_len_utf8 again because it will call magic
		       or overloading a second time, and we might get back a
		       different result.  */
		    blen_chars = utf8_length((U8*)buffer, (U8*)buffer + blen);
		} else {
		    /* It's safe, and it may well be cached.  */
		    blen_chars = sv_len_utf8(bufsv);
		}
	    }
	} else {
	    blen_chars = blen;
	}

	if (MARK >= SP) {
	    length = blen_chars;
	} else {
#if Size_t_size > IVSIZE
	    length = (Size_t)SvNVx(*++MARK);
#else
	    length = (Size_t)SvIVx(*++MARK);
#endif
	    if ((SSize_t)length < 0) {
		Safefree(tmpbuf);
		DIE(aTHX_ "Negative length");
	    }
a1891 1

d1895 1
a1895 2
		if (-offset > (IV)blen_chars) {
		    Safefree(tmpbuf);
d1897 2
a1898 4
		}
		offset += blen_chars;
	    } else if (offset >= (IV)blen_chars && blen_chars > 0) {
		Safefree(tmpbuf);
a1899 1
	    }
d1902 5
a1906 25
	if (length > blen_chars - offset)
	    length = blen_chars - offset;
	if (doing_utf8) {
	    /* Here we convert length from characters to bytes.  */
	    if (tmpbuf || SvGMAGICAL(bufsv) || SvAMAGIC(bufsv)) {
		/* Either we had to convert the SV, or the SV is magical, or
		   the SV has overloading, in which case we can't or mustn't
		   or mustn't call it again.  */

		buffer = (const char*)utf8_hop((const U8 *)buffer, offset);
		length = utf8_hop((U8 *)buffer, length) - (U8 *)buffer;
	    } else {
		/* It's a real UTF-8 SV, and it's not going to change under
		   us.  Take advantage of any cache.  */
		I32 start = offset;
		I32 len_I32 = length;

		/* Convert the start and end character positions to bytes.
		   Remember that the second argument to sv_pos_u2b is relative
		   to the first.  */
		sv_pos_u2b(bufsv, &start, &len_I32);

		buffer += start;
		length = len_I32;
	    }
d1925 6
a1930 12
    else {
	const int flags = SvIVx(*++MARK);
	if (SP > MARK) {
	    STRLEN mlen;
	    char * const sockbuf = SvPVx(*++MARK, mlen);
	    retval = PerlSock_sendto(PerlIO_fileno(IoIFP(io)), buffer, blen,
				     flags, (struct sockaddr *)sockbuf, mlen);
	}
	else {
	    retval
		= PerlSock_send(PerlIO_fileno(IoIFP(io)), buffer, blen, flags);
	}
d1932 3
a1938 1

d1942 1
a1942 1
    if (doing_utf8)
a1943 2

    Safefree(tmpbuf);
a1951 1
    Safefree(tmpbuf);
d1956 5
d1963 1
a1963 1
    dVAR; dSP;
d1965 2
d1977 2
a1978 7
		    do_open(gv, "-", 1, FALSE, O_RDONLY, 0, NULL);
		    if ( GvSV(gv) ) {
			sv_setpvn(GvSV(gv), "-", 1);
		    }
		    else {
			GvSV(gv) = newSVpvn("-", 1);
		    }
d1991 11
a2001 13
    if (gv) {
	IO * const io = GvIO(gv);
	MAGIC * mg;
	if (io && (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar))) {
	    PUSHMARK(SP);
	    XPUSHs(SvTIED_obj((SV*)io, mg));
	    PUTBACK;
	    ENTER;
	    call_method("EOF", G_SCALAR);
	    LEAVE;
	    SPAGAIN;
	    RETURN;
	}
d2010 1
a2010 1
    dVAR; dSP; dTARGET;
d2013 1
d2015 4
a2018 3
    if (MAXARG != 0)
	PL_last_in_gv = (GV*)POPs;
    gv = PL_last_in_gv;
d2020 11
a2030 12
    if (gv && (io = GvIO(gv))) {
	MAGIC * const mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    PUSHMARK(SP);
	    XPUSHs(SvTIED_obj((SV*)io, mg));
	    PUTBACK;
	    ENTER;
	    call_method("TELL", G_SCALAR);
	    LEAVE;
	    SPAGAIN;
	    RETURN;
	}
d2041 5
d2048 3
a2050 1
    dVAR; dSP;
d2053 1
a2053 1
    const Off_t offset = (Off_t)SvNVx(POPs);
d2055 1
a2055 1
    const Off_t offset = (Off_t)SvIVx(POPs);
d2057 1
d2059 1
a2059 2
    GV * const gv = PL_last_in_gv = (GV*)POPs;
    IO *io;
d2061 5
a2065 5
    if (gv && (io = GvIO(gv))) {
	MAGIC * const mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    PUSHMARK(SP);
	    XPUSHs(SvTIED_obj((SV*)io, mg));
d2067 1
a2067 1
	    XPUSHs(sv_2mortal(newSVnv((NV) offset)));
d2069 1
a2069 1
	    XPUSHs(sv_2mortal(newSViv(offset)));
d2071 7
a2077 8
	    XPUSHs(sv_2mortal(newSViv(whence)));
	    PUTBACK;
	    ENTER;
	    call_method("SEEK", G_SCALAR);
	    LEAVE;
	    SPAGAIN;
	    RETURN;
	}
d2083 1
a2083 1
	const Off_t sought = do_sysseek(gv, offset, whence);
d2087 1
a2087 1
            SV* const sv = sought ?
a2101 1
    dVAR;
d2125 1
a2125 1
	    tmpgv = gv_fetchsv(POPs, 0, SVt_PVIO);
d2150 3
a2152 3
	    SV * const sv = POPs;
	    const char *name;

d2173 1
a2173 1
		const int tmpfd = PerlLIO_open(name, O_RDWR);
d2175 1
a2175 1
		if (tmpfd < 0)
d2194 5
d2201 2
a2202 2
    dVAR; dSP; dTARGET;
    SV * const argsv = POPs;
a2204 2
    GV * const gv = (GV*)POPs;
    IO * const io = gv ? GvIOn(gv) : NULL;
d2207 2
d2234 1
a2234 1
    TAINT_PROPER(PL_op_desc[optype]);
d2277 1
a2277 1
    dVAR; dSP; dTARGET;
d2279 2
a2282 2
    const int argtype = POPi;
    GV * const gv = (MAXARG == 0) ? PL_last_in_gv : (GV*)POPs;
d2284 5
d2292 1
a2292 1
	fp = NULL;
a2294 1
    /* XXX Looks to me like io is always NULL at this point */
d2317 6
a2322 6
    dVAR; dSP;
    const int protocol = POPi;
    const int type = POPi;
    const int domain = POPi;
    GV * const gv = (GV*)POPs;
    register IO * const io = gv ? GvIOn(gv) : NULL;
d2325 3
d2331 1
a2331 1
	if (io && IoIFP(io))
d2370 8
a2377 8
    dVAR; dSP;
    const int protocol = POPi;
    const int type = POPi;
    const int domain = POPi;
    GV * const gv2 = (GV*)POPs;
    GV * const gv1 = (GV*)POPs;
    register IO * const io1 = gv1 ? GvIOn(gv1) : NULL;
    register IO * const io2 = gv2 ? GvIOn(gv2) : NULL;
d2380 4
d2391 1
a2391 1
	if (io1 && IoIFP(io1))
d2393 1
a2393 1
	if (io2 && IoIFP(io2))
d2435 2
a2436 2
    dVAR; dSP;
    SV * const addrsv = POPs;
d2439 2
a2440 2
    GV * const gv = (GV*)POPs;
    register IO * const io = GvIOn(gv);
d2442 1
d2449 6
a2454 1
    if (PerlSock_bind(PerlIO_fileno(IoIFP(io)), (struct sockaddr *)addr, len) >= 0)
d2472 2
a2473 4
    dVAR; dSP;
    SV * const addrsv = POPs;
    GV * const gv = (GV*)POPs;
    register IO * const io = GvIOn(gv);
d2475 2
d2502 4
a2505 4
    dVAR; dSP;
    const int backlog = POPi;
    GV * const gv = (GV*)POPs;
    register IO * const io = gv ? GvIOn(gv) : NULL;
d2528 3
a2530 1
    dVAR; dSP; dTARGET;
a2538 2
    GV * const ggv = (GV*)POPs;
    GV * const ngv = (GV*)POPs;
d2541 3
a2554 11
#if defined(OEMVS)
    if (len == 0) {
	/* Some platforms indicate zero length when an AF_UNIX client is
	 * not bound. Simulate a non-zero-length sockaddr structure in
	 * this case. */
	namebuf[0] = 0;        /* sun_len */
	namebuf[1] = AF_UNIX;  /* sun_family */
	len = 2;
    }
#endif

d2599 4
a2602 4
    dVAR; dSP; dTARGET;
    const int how = POPi;
    GV * const gv = (GV*)POPs;
    register IO * const io = GvIOn(gv);
d2620 9
d2632 3
a2634 7
    dVAR; dSP;
    const int optype = PL_op->op_type;
    SV * const sv = (optype == OP_GSOCKOPT) ? sv_2mortal(newSV(257)) : POPs;
    const unsigned int optname = (unsigned int) POPi;
    const unsigned int lvl = (unsigned int) POPi;
    GV * const gv = (GV*)POPs;
    register IO * const io = GvIOn(gv);
d2636 4
d2642 9
d2669 1
a2669 15
#if defined(__SYMBIAN32__)
# define SETSOCKOPT_OPTION_VALUE_T void *
#else
# define SETSOCKOPT_OPTION_VALUE_T const char *
#endif
	/* XXX TODO: We need to have a proper type (a Configure probe,
	 * etc.) for what the C headers think of the third argument of
	 * setsockopt(), the option_value read-only buffer: is it
	 * a "char *", or a "void *", const or not.  Some compilers
	 * don't take kindly to e.g. assuming that "char *" implicitly
	 * promotes to a "void *", or to explicitly promoting/demoting
	 * consts to non/vice versa.  The "const void *" is the SUS
	 * definition, but that does not fly everywhere for the above
	 * reasons. */
	    SETSOCKOPT_OPTION_VALUE_T buf;
d2673 1
a2673 1
		buf = (SETSOCKOPT_OPTION_VALUE_T) SvPV_const(sv, l);
d2678 1
a2678 1
		buf = (SETSOCKOPT_OPTION_VALUE_T) &aint;
d2697 10
a2706 1
    DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
d2713 2
a2714 5
    dVAR; dSP;
    const int optype = PL_op->op_type;
    GV * const gv = (GV*)POPs;
    register IO * const io = GvIOn(gv);
    Sock_size_t len;
d2717 3
d2724 1
a2724 1
    sv = sv_2mortal(newSV(257));
d2743 1
a2743 1
		!memcmp(SvPVX_const(sv) + sizeof(u_short), nowhere,
d2770 1
a2770 1
    DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
d2776 5
a2782 1
    dVAR;
d2784 1
a2784 2
    GV *gv = NULL;
    IO *io;
a2791 1
	    do_fstat_warning_check:
d2794 1
a2794 1
			"lstat() on filehandle %s", gv ? GvENAME(gv) : "");
d2804 3
a2806 17
            if(gv) {
                io = GvIO(gv);
                do_fstat_have_io:
                if (io) {
                    if (IoIFP(io)) {
                        PL_laststatval = 
                            PerlLIO_fstat(PerlIO_fileno(IoIFP(io)), &PL_statcache);   
                    } else if (IoDIRP(io)) {
                        PL_laststatval =
                            PerlLIO_fstat(my_dirfd(IoDIRP(io)), &PL_statcache);
                    } else {
                        PL_laststatval = -1;
                    }
	        }
            }
        }

d2814 1
a2814 1
	SV* const sv = POPs;
d2818 8
a2825 12
	} else if(SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVGV) {
            gv = (GV*)SvRV(sv);
            if (PL_op->op_type == OP_LSTAT)
                goto do_fstat_warning_check;
            goto do_fstat;
        } else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVIO) { 
            io = (IO*)SvRV(sv);
            if (PL_op->op_type == OP_LSTAT)
                goto do_fstat_warning_check;
            goto do_fstat_have_io; 
        }
        
d2827 1
a2827 1
	PL_statgv = NULL;
d2874 1
a2874 1
	PUSHs(sv_2mortal(newSVpvs("")));
d2886 3
a2888 3
	PUSHs(sv_2mortal(newSViv((IV)PL_statcache.st_atime)));
	PUSHs(sv_2mortal(newSViv((IV)PL_statcache.st_mtime)));
	PUSHs(sv_2mortal(newSViv((IV)PL_statcache.st_ctime)));
d2894 2
a2895 2
	PUSHs(sv_2mortal(newSVpvs("")));
	PUSHs(sv_2mortal(newSVpvs("")));
a2900 9
/* This macro is used by the stacked filetest operators :
 * if the previous filetest failed, short-circuit and pass its value.
 * Else, discard it from the stack and continue. --rgs
 */
#define STACKED_FTEST_CHECK if (PL_op->op_private & OPpFT_STACKED) { \
	if (TOPs == &PL_sv_no || TOPs == &PL_sv_undef) { RETURN; } \
	else { (void)POPs; PUTBACK; } \
    }

a2902 1
    dVAR;
d2904 12
a2915 10
    /* Not const, because things tweak this below. Not bool, because there's
       no guarantee that OPp_FT_ACCESS is <= CHAR_MAX  */
#if defined(HAS_ACCESS) || defined (PERL_EFF_ACCESS)
    I32 use_access = PL_op->op_private & OPpFT_ACCESS;
    /* Giving some sort of initial value silences compilers.  */
#  ifdef R_OK
    int access_mode = R_OK;
#  else
    int access_mode = 0;
#  endif
d2917 1
a2917 3
    /* access_mode is never used, but leaving use_access in makes the
       conditional compiling below much clearer.  */
    I32 use_access = 0;
d2919 7
a2925 1
    int stat_mode = S_IRUSR;
d2927 3
a2929 1
    bool effective = FALSE;
a2930 11

    STACKED_FTEST_CHECK;

    switch (PL_op->op_type) {
    case OP_FTRREAD:
#if !(defined(HAS_ACCESS) && defined(R_OK))
	use_access = 0;
#endif
	break;

    case OP_FTRWRITE:
d2932 10
a2941 1
	access_mode = W_OK;
d2943 1
a2943 1
	use_access = 0;
d2945 7
a2951 2
	stat_mode = S_IWUSR;
	break;
d2953 4
a2956 1
    case OP_FTREXEC:
d2958 10
a2967 1
	access_mode = X_OK;
d2969 1
a2969 1
	use_access = 0;
d2971 7
a2977 2
	stat_mode = S_IXUSR;
	break;
d2979 17
a2995 10
    case OP_FTEWRITE:
#ifdef PERL_EFF_ACCESS
	access_mode = W_OK;
#endif
	stat_mode = S_IWUSR;
	/* Fall through  */

    case OP_FTEREAD:
#ifndef PERL_EFF_ACCESS
	use_access = 0;
d2997 7
a3003 2
	effective = TRUE;
	break;
d3005 15
a3019 4

    case OP_FTEEXEC:
#ifdef PERL_EFF_ACCESS
	access_mode = W_OK;
d3021 1
a3021 1
	use_access = 0;
d3023 7
a3029 4
	stat_mode = S_IXUSR;
	effective = TRUE;
	break;
    }
d3031 7
a3037 18
    if (use_access) {
#if defined(HAS_ACCESS) || defined (PERL_EFF_ACCESS)
	const char *name = POPpx;
	if (effective) {
#  ifdef PERL_EFF_ACCESS
	    result = PERL_EFF_ACCESS(name, access_mode);
#  else
	    DIE(aTHX_ "panic: attempt to call PERL_EFF_ACCESS in %s",
		OP_NAME(PL_op));
#  endif
	}
	else {
#  ifdef HAS_ACCESS
	    result = access(name, access_mode);
#  else
	    DIE(aTHX_ "panic: attempt to call access() in %s", OP_NAME(PL_op));
#  endif
	}
a3042 1
#endif
d3044 3
a3046 1

d3048 1
d3052 1
a3052 1
    if (cando(stat_mode, effective, &PL_statcache))
d3059 27
a3085 3
    dVAR;
    I32 result;
    const int op_type = PL_op->op_type;
a3086 3
    STACKED_FTEST_CHECK;
    result = my_stat();
    SPAGAIN;
d3089 1
a3089 1
    if (op_type == OP_FTIS)
d3091 9
a3099 6
    {
	/* You can't dTARGET inside OP_FTIS, because you'll get
	   "panic: pad_sv po" - the op is not flagged to have a target.  */
	dTARGET;
	switch (op_type) {
	case OP_FTSIZE:
d3101 1
a3101 1
	    PUSHn(PL_statcache.st_size);
d3103 1
a3103 1
	    PUSHi(PL_statcache.st_size);
a3104 12
	    break;
	case OP_FTMTIME:
	    PUSHn( (((NV)PL_basetime - PL_statcache.st_mtime)) / 86400.0 );
	    break;
	case OP_FTATIME:
	    PUSHn( (((NV)PL_basetime - PL_statcache.st_atime)) / 86400.0 );
	    break;
	case OP_FTCTIME:
	    PUSHn( (((NV)PL_basetime - PL_statcache.st_ctime)) / 86400.0 );
	    break;
	}
    }
d3108 75
a3182 1
PP(pp_ftrowned)
d3184 1
a3184 2
    dVAR;
    I32 result;
d3186 6
d3193 21
a3213 14
    /* I believe that all these three are likely to be defined on most every
       system these days.  */
#ifndef S_ISUID
    if(PL_op->op_type == OP_FTSUID)
	RETPUSHNO;
#endif
#ifndef S_ISGID
    if(PL_op->op_type == OP_FTSGID)
	RETPUSHNO;
#endif
#ifndef S_ISVTX
    if(PL_op->op_type == OP_FTSVTX)
	RETPUSHNO;
#endif
d3215 5
a3219 2
    STACKED_FTEST_CHECK;
    result = my_stat();
d3223 2
a3224 42
    switch (PL_op->op_type) {
    case OP_FTROWNED:
	if (PL_statcache.st_uid == PL_uid)
	    RETPUSHYES;
	break;
    case OP_FTEOWNED:
	if (PL_statcache.st_uid == PL_euid)
	    RETPUSHYES;
	break;
    case OP_FTZERO:
	if (PL_statcache.st_size == 0)
	    RETPUSHYES;
	break;
    case OP_FTSOCK:
	if (S_ISSOCK(PL_statcache.st_mode))
	    RETPUSHYES;
	break;
    case OP_FTCHR:
	if (S_ISCHR(PL_statcache.st_mode))
	    RETPUSHYES;
	break;
    case OP_FTBLK:
	if (S_ISBLK(PL_statcache.st_mode))
	    RETPUSHYES;
	break;
    case OP_FTFILE:
	if (S_ISREG(PL_statcache.st_mode))
	    RETPUSHYES;
	break;
    case OP_FTDIR:
	if (S_ISDIR(PL_statcache.st_mode))
	    RETPUSHYES;
	break;
    case OP_FTPIPE:
	if (S_ISFIFO(PL_statcache.st_mode))
	    RETPUSHYES;
	break;
#ifdef S_ISUID
    case OP_FTSUID:
	if (PL_statcache.st_mode & S_ISUID)
	    RETPUSHYES;
	break;
d3226 6
d3233 6
a3238 10
    case OP_FTSGID:
	if (PL_statcache.st_mode & S_ISGID)
	    RETPUSHYES;
	break;
#endif
#ifdef S_ISVTX
    case OP_FTSVTX:
	if (PL_statcache.st_mode & S_ISVTX)
	    RETPUSHYES;
	break;
a3239 1
    }
d3243 1
a3243 1
PP(pp_ftlink)
a3244 2
    dVAR;
    I32 result = my_lstat();
d3246 3
d3251 1
a3251 1
    if (S_ISLNK(PL_statcache.st_mode))
d3253 1
a3258 1
    dVAR;
d3262 1
a3262 3
    SV *tmpsv = NULL;

    STACKED_FTEST_CHECK;
d3271 1
a3271 1
	gv = gv_fetchsv(tmpsv = POPs, 0, SVt_PVIO);
d3275 2
a3276 7
    else if (tmpsv && SvOK(tmpsv)) {
	const char *tmps = SvPV_nolen_const(tmpsv);
	if (isDIGIT(*tmps))
	    fd = atoi(tmps);
	else 
	    RETPUSHUNDEF;
    }
a3293 1
    dVAR;
a3304 2
    STACKED_FTEST_CHECK;

d3312 1
a3312 1
	gv = NULL;
d3367 1
a3367 1
	PL_statgv = NULL;
d3381 1
a3381 1
	PerlIO_binmode(aTHX_ fp, '<', O_BINARY, NULL);
d3397 1
a3397 1
    if (len && len < (I32)sizeof(tbuf) && tbuf[len-1] == 26)
d3446 5
d3455 4
a3458 3
    dVAR; dSP; dTARGET;
    const char *tmps = NULL;
    GV *gv = NULL;
d3461 2
a3462 5
	SV * const sv = POPs;
	if (PL_op->op_flags & OPf_SPECIAL) {
	    gv = gv_fetchsv(sv, 0, SVt_PVIO);
	}
        else if (SvTYPE(sv) == SVt_PVGV) {
d3469 1
a3469 1
	    tmps = SvPV_nolen_const(sv);
d3474 2
a3475 5
	HV * const table = GvHVn(PL_envgv);
	SV **svp;

        if (    (svp = hv_fetchs(table, "HOME", FALSE))
             || (svp = hv_fetchs(table, "LOGDIR", FALSE))
d3477 1
a3477 1
             || (svp = hv_fetchs(table, "SYS$LOGIN", FALSE))
d3495 1
a3495 1
	IO* const io = GvIO(gv);
d3497 9
a3505 4
	    if (IoDIRP(io)) {
		PUSHi(fchdir(my_dirfd(IoDIRP(io))) >= 0);
	    } else if (IoIFP(io)) {
                PUSHi(fchdir(PerlIO_fileno(IoIFP(io))) >= 0);
a3507 3
		if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
		    report_evil_fh(gv, io, PL_op->op_type);
		SETERRNO(EBADF, RMS_IFI);
a3511 3
	    if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
		report_evil_fh(gv, io, PL_op->op_type);
	    SETERRNO(EBADF,RMS_IFI);
d3519 1
a3519 1
        PUSHi( PerlDir_chdir(tmps) >= 0 );
d3530 3
a3532 2
    dVAR; dSP; dMARK; dTARGET;
    const I32 value = (I32)apply(PL_op->op_type, MARK, SP);
d3537 3
d3545 2
a3546 2
    dVAR; dSP; dTARGET;
    char * const tmps = POPpx;
d3555 30
d3587 1
a3587 1
    dVAR; dSP; dTARGET;
d3589 2
a3590 2
    const char * const tmps2 = POPpconstx;
    const char * const tmps = SvPV_nolen_const(TOPs);
a3609 1
#if defined(HAS_LINK) || defined(HAS_SYMLINK)
d3612 11
a3622 3
    dVAR; dSP; dTARGET;
    const int op_type = PL_op->op_type;
    int result;
d3624 8
a3631 32
#  ifndef HAS_LINK
    if (op_type == OP_LINK)
	DIE(aTHX_ PL_no_func, "link");
#  endif
#  ifndef HAS_SYMLINK
    if (op_type == OP_SYMLINK)
	DIE(aTHX_ PL_no_func, "symlink");
#  endif

    {
	const char * const tmps2 = POPpconstx;
	const char * const tmps = SvPV_nolen_const(TOPs);
	TAINT_PROPER(PL_op_desc[op_type]);
	result =
#  if defined(HAS_LINK)
#    if defined(HAS_SYMLINK)
	    /* Both present - need to choose which.  */
	    (op_type == OP_LINK) ?
	    PerlLIO_link(tmps, tmps2) : symlink(tmps, tmps2);
#    else
    /* Only have link, so calls to pp_symlink will have DIE()d above.  */
	PerlLIO_link(tmps, tmps2);
#    endif
#  else
#    if defined(HAS_SYMLINK)
    /* Only have symlink, so calls to pp_link will have DIE()d above.  */
	symlink(tmps, tmps2);
#    endif
#  endif
    }

    SETi( result >= 0 );
a3632 1
}
d3634 2
a3635 4
PP(pp_link)
{
    /* Have neither.  */
    DIE(aTHX_ PL_no_func, PL_op_desc[PL_op->op_type]);
a3636 1
#endif
a3639 1
    dVAR;
a3671 1
    Size_t size = strlen(cmd) + (strlen(filename) * 2) + 10;
d3673 3
a3675 3
    Newx(cmdline, size, char);
    my_strlcpy(cmdline, cmd, size);
    my_strlcat(cmdline, " ", size);
d3680 1
a3680 2
    if (s - cmdline < size)
	my_strlcpy(s, " 2>&1", size - (s - cmdline));
d3685 1
a3685 1
	SV * const tmpsv = sv_newmortal();
d3689 1
a3689 1
	if (s != NULL) {
d3698 1
a3698 1
		const char * const errmsg =
d3772 5
a3776 1
    dVAR; dSP; dTARGET;
d3780 5
a3784 1
    const int mode = (MAXARG > 1) ? POPi : 0777;
d3790 1
a3790 1
    SETi( PerlDir_mkdir(tmps, mode) >= 0 );
a3791 2
    {
    int oldumask;
a3795 1
    }
d3804 1
a3804 1
    dVAR; dSP; dTARGET;
d3812 1
a3812 1
    SETi( PerlDir_rmdir(tmps) >= 0 );
d3826 4
a3829 4
    dVAR; dSP;
    const char * const dirname = POPpconstx;
    GV * const gv = (GV*)POPs;
    register IO * const io = GvIOn(gv);
a3833 3
    if ((IoIFP(io) || IoOFP(io)) && ckWARN2(WARN_IO, WARN_DEPRECATED))
	Perl_warner(aTHX_ packWARN2(WARN_IO, WARN_DEPRECATED),
		"Opening filehandle %s also as a directory", GvENAME(gv));
d3836 1
a3836 1
    if (!(IoDIRP(io) = PerlDir_open(dirname)))
a3856 1
    dVAR;
d3861 3
a3863 3
    GV * const gv = (GV *)POPs;
    register const Direntry_t *dp;
    register IO * const io = GvIOn(gv);
d3865 2
a3866 7
    if (!io || !IoDIRP(io)) {
        if(ckWARN(WARN_IO)) {
            Perl_warner(aTHX_ packWARN(WARN_IO),
                "readdir() attempted on invalid dirhandle %s", GvENAME(gv));
        }
        goto nope;
    }
d3882 2
a3883 1
    } while (gimme == G_ARRAY);
d3903 1
a3903 1
    dVAR; dSP; dTARGET;
d3911 2
a3912 2
    GV * const gv = (GV*)POPs;
    register IO * const io = GvIOn(gv);
d3914 2
a3915 7
    if (!io || !IoDIRP(io)) {
        if(ckWARN(WARN_IO)) {
            Perl_warner(aTHX_ packWARN(WARN_IO),
	        "telldir() attempted on invalid dirhandle %s", GvENAME(gv));
        }
        goto nope;
    }
d3931 8
a3938 12
    dVAR; dSP;
    const long along = POPl;
    GV * const gv = (GV*)POPs;
    register IO * const io = GvIOn(gv);

    if (!io || !IoDIRP(io)) {
	if(ckWARN(WARN_IO)) {
	    Perl_warner(aTHX_ packWARN(WARN_IO),
                "seekdir() attempted on invalid dirhandle %s", GvENAME(gv));
        }
        goto nope;
    }
d3954 5
a3958 9
    dVAR; dSP;
    GV * const gv = (GV*)POPs;
    register IO * const io = GvIOn(gv);

    if (!io || !IoDIRP(io)) {
	if(ckWARN(WARN_IO)) {
	    Perl_warner(aTHX_ packWARN(WARN_IO),
	        "rewinddir() attempted on invalid dirhandle %s", GvENAME(gv));
	}
d3960 1
a3960 1
    }
d3975 7
a3981 11
    dVAR; dSP;
    GV * const gv = (GV*)POPs;
    register IO * const io = GvIOn(gv);

    if (!io || !IoDIRP(io)) {
	if(ckWARN(WARN_IO)) {
	    Perl_warner(aTHX_ packWARN(WARN_IO),
                "closedir() attempted on invalid dirhandle %s", GvENAME(gv));
        }
        goto nope;
    }
d4007 1
a4007 1
    dVAR; dSP; dTARGET;
d4009 1
d4017 1
a4017 2
	GV * const tmpgv = gv_fetchpvs("$", GV_ADD|GV_NOTQUAL, SVt_PV);
	if (tmpgv) {
a4024 1
#ifdef PERL_USES_PL_PIDSTATUS
a4025 1
#endif
d4049 2
a4050 2
#if (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(MACOS_TRADITIONAL) && !defined(__LIBCATAMOUNT__)
    dVAR; dSP; dTARGET;
d4064 1
a4064 1
    STATUS_NATIVE_CHILD_SET((childpid && childpid != -1) ? argflags : -1);
d4066 1
a4066 1
    STATUS_NATIVE_CHILD_SET((childpid > 0) ? argflags : -1);
d4077 3
a4079 4
#if (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(MACOS_TRADITIONAL) && !defined(__LIBCATAMOUNT__)
    dVAR; dSP; dTARGET;
    const int optype = POPi;
    const Pid_t pid = TOPi;
d4081 1
d4084 2
d4096 1
a4096 1
    STATUS_NATIVE_CHILD_SET((result && result != -1) ? argflags : -1);
d4098 1
a4098 1
    STATUS_NATIVE_CHILD_SET((result > 0) ? argflags : -1);
d4109 1
a4109 6
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
#if defined(__LIBCATAMOUNT__)
    PL_statusvalue = -1;
    SP = ORIGMARK;
    XPUSHi(-1);
#else
d4152 2
a4153 2
	    rsignal_save(SIGINT,  (Sighandler_t) SIG_IGN, &ihand);
	    rsignal_save(SIGQUIT, (Sighandler_t) SIG_IGN, &qhand);
d4162 1
a4162 1
	    STATUS_NATIVE_CHILD_SET(result == -1 ? -1 : status);
d4167 1
a4167 2
		unsigned n = 0;
		SSize_t n1;
d4182 1
a4182 1
		    STATUS_NATIVE_CHILD_SET(-1);
d4195 1
a4195 1
	    SV * const really = *++MARK;
d4199 1
a4199 1
	    value = (I32)do_aexec5(NULL, MARK, SP, pp[1], did_pipes);
d4209 2
a4210 2
	SV * const really = *++MARK;
#  if defined(WIN32) || defined(OS2) || defined(__SYMBIAN32__)
d4217 2
a4218 2
#  if defined(WIN32) || defined(OS2) || defined(__SYMBIAN32__)
	value = (I32)do_aspawn(NULL, MARK, SP);
d4220 1
a4220 1
	value = (I32)do_aspawn(NULL, (void **)MARK, (void **)SP);
d4228 1
a4228 1
    STATUS_NATIVE_CHILD_SET(value);
d4232 1
a4232 2
#endif /* !FORK or VMS or OS/2 */
#endif
d4238 1
a4238 1
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
d4253 1
a4253 1
	SV * const really = *++MARK;
d4258 1
a4258 1
	value = (I32)vms_do_aexec(NULL, MARK, SP);
d4262 1
a4262 1
	   (void ) do_aspawn(NULL, MARK, SP);
d4266 1
a4266 1
	value = (I32)do_aexec(NULL, MARK, SP);
d4287 14
d4304 1
a4304 1
    dVAR; dSP; dTARGET;
d4322 2
a4323 1
    dVAR; dSP; dTARGET;
a4324 1
    const Pid_t pid = (MAXARG < 1) ? 0 : SvIVx(POPs);
d4326 4
d4347 1
a4347 1
    dVAR; dSP; dTARGET;
d4379 3
a4381 3
    dVAR; dSP; dTARGET;
    const int who = POPi;
    const int which = TOPi;
d4392 4
a4395 4
    dVAR; dSP; dTARGET;
    const int niceval = POPi;
    const int who = POPi;
    const int which = TOPi;
d4408 1
a4408 1
    dVAR; dSP; dTARGET;
d4410 1
a4410 1
    XPUSHn( time(NULL) );
d4412 1
a4412 1
    XPUSHi( time(NULL) );
a4419 1
    dVAR;
d4454 5
a4500 1
    dVAR;
d4563 1
a4563 1
    dVAR; dSP; dTARGET;
d4579 1
a4579 1
    dVAR; dSP; dTARGET;
d4597 15
a4611 1
/* Merged with some message passing. */
d4616 21
a4636 3
    dVAR; dSP; dMARK; dTARGET;
    const int op_type = PL_op->op_type;
    I32 value;
d4638 12
a4649 14
    switch (op_type) {
    case OP_MSGSND:
	value = (I32)(do_msgsnd(MARK, SP) >= 0);
	break;
    case OP_MSGRCV:
	value = (I32)(do_msgrcv(MARK, SP) >= 0);
	break;
    case OP_SEMOP:
	value = (I32)(do_semop(MARK, SP) >= 0);
	break;
    default:
	value = (I32)(do_shmio(op_type, MARK, SP) >= 0);
	break;
    }
d4651 5
d4669 2
a4670 2
    dVAR; dSP; dMARK; dTARGET;
    const int anum = do_ipcget(PL_op->op_type, MARK, SP);
d4684 2
a4685 2
    dVAR; dSP; dMARK; dTARGET;
    const int anum = do_ipcctl(PL_op->op_type, MARK, SP);
d4701 11
a4711 19
/* I can't const this further without getting warnings about the types of
   various arrays passed in from structures.  */
static SV *
S_space_join_names_mortal(pTHX_ char *const *array)
{
    SV *target;

    if (array && *array) {
	target = sv_2mortal(newSVpvs(""));
	while (1) {
	    sv_catpv(target, *array);
	    if (!*++array)
		break;
	    sv_catpvs(target, " ");
	}
    } else {
	target = sv_mortalcopy(&PL_sv_no);
    }
    return target;
d4716 18
d4737 1
a4737 1
    dVAR; dSP;
d4752 1
a4752 1
	const char* const name = POPpbytex;
d4760 2
a4761 2
	const int addrtype = POPi;
	SV * const addrsv = POPs;
d4763 1
a4763 1
	const char *addr = (char *)SvPVbyte(addrsv, addrlen);
d4784 1
a4784 1
	    STATUS_UNIX_SET(h_errno);
d4802 11
a4812 3
	PUSHs(sv_2mortal(newSVpv((char*)hent->h_name, 0)));
	PUSHs(space_join_names_mortal(hent->h_aliases));
	PUSHs(sv_2mortal(newSViv((IV)hent->h_addrtype)));
d4814 1
a4814 1
	PUSHs(sv_2mortal(newSViv((IV)len)));
d4817 2
a4818 1
	    XPUSHs(sv_2mortal(newSVpvn(*elem, len)));
d4821 1
d4823 1
a4823 3
	    PUSHs(newSVpvn(hent->h_addr, len));
	else
	    PUSHs(sv_mortalcopy(&PL_sv_no));
d4832 18
d4853 1
a4853 1
    dVAR; dSP;
d4855 1
d4866 1
a4866 1
	const char * const name = POPpbytex;
d4874 2
a4875 2
	const int addrtype = POPi;
	const Netdb_net_t addr = (Netdb_net_t) (U32)POPu;
d4895 1
a4895 1
	    STATUS_UNIX_SET(h_errno);
d4912 12
a4923 4
	PUSHs(sv_2mortal(newSVpv(nent->n_name, 0)));
	PUSHs(space_join_names_mortal(nent->n_aliases));
	PUSHs(sv_2mortal(newSViv((IV)nent->n_addrtype)));
	PUSHs(sv_2mortal(newSViv((IV)nent->n_net)));
d4932 18
d4953 1
a4953 1
    dVAR; dSP;
d4955 1
d4966 1
a4966 1
	const char* const name = POPpbytex;
d4974 1
a4974 1
	const int number = POPi;
d5000 10
a5009 3
	PUSHs(sv_2mortal(newSVpv(pent->p_name, 0)));
	PUSHs(space_join_names_mortal(pent->p_aliases));
	PUSHs(sv_2mortal(newSViv((IV)pent->p_proto)));
d5018 18
d5039 1
a5039 1
    dVAR; dSP;
d5041 1
d5052 7
a5058 3
	const char * const proto = POPpbytex;
	const char * const name = POPpbytex;
	sent = PerlSock_getservbyname(name, (proto && !*proto) ? NULL : proto);
d5065 1
a5065 1
	const char * const proto = POPpbytex;
d5067 4
d5074 1
a5074 1
	sent = PerlSock_getservbyport(port, (proto && !*proto) ? NULL : proto);
d5104 9
a5112 2
	PUSHs(sv_2mortal(newSVpv(sent->s_name, 0)));
	PUSHs(space_join_names_mortal(sent->s_aliases));
d5114 1
a5114 1
	PUSHs(sv_2mortal(newSViv((IV)PerlSock_ntohs(sent->s_port))));
d5116 1
a5116 1
	PUSHs(sv_2mortal(newSViv((IV)(sent->s_port))));
d5118 2
a5119 1
	PUSHs(sv_2mortal(newSVpv(sent->s_proto, 0)));
d5131 1
a5131 1
    dVAR; dSP;
d5142 1
a5142 1
    dVAR; dSP;
d5153 1
a5153 1
    dVAR; dSP;
d5164 1
a5164 1
    dVAR; dSP;
d5175 1
a5175 1
    dVAR; dSP;
d5187 1
a5187 1
    dVAR; dSP;
d5199 1
a5199 1
    dVAR; dSP;
d5211 1
a5211 1
    dVAR; dSP;
d5220 18
d5241 1
a5241 1
    dVAR; dSP;
d5314 1
a5314 1
	const char* const name = POPpbytex;
d5353 2
a5354 1
	PUSHs(sv_2mortal(newSVpv(pwent->pw_name, 0)));
d5356 2
a5357 1
	PUSHs(sv = sv_2mortal(newSViv(0)));
d5378 2
a5379 3
	    const int saverrno = errno;
	    const struct spwd * const spwent = getspnam(pwent->pw_name);
			  /* Save and restore errno so that
d5383 3
d5402 1
d5404 1
a5404 1
	PUSHs(sv_2mortal(newSViv((IV)pwent->pw_uid)));
d5406 1
a5406 1
	PUSHs(sv_2mortal(newSVuv((UV)pwent->pw_uid)));
d5409 1
d5411 1
a5411 1
	PUSHs(sv_2mortal(newSViv((IV)pwent->pw_gid)));
d5413 1
a5413 1
	PUSHs(sv_2mortal(newSVuv((UV)pwent->pw_gid)));
d5420 1
d5422 1
a5422 1
	PUSHs(sv_2mortal(newSViv((IV)pwent->pw_change)));
d5425 1
a5425 1
	PUSHs(sv_2mortal(newSViv((IV)pwent->pw_quota)));
d5428 1
a5428 4
	PUSHs(sv_2mortal(newSVpv(pwent->pw_age, 0)));
#	    else
	/* I think that you can never get this compiled, but just in case.  */
	PUSHs(sv_mortalcopy(&PL_sv_no));
d5435 1
d5437 1
a5437 1
	PUSHs(sv_2mortal(newSVpv(pwent->pw_class, 0)));
d5440 1
a5440 4
	PUSHs(sv_2mortal(newSVpv(pwent->pw_comment, 0)));
#	else
	/* I think that you can never get this compiled, but just in case.  */
	PUSHs(sv_mortalcopy(&PL_sv_no));
d5444 1
d5446 1
a5446 3
	PUSHs(sv = sv_2mortal(newSVpv(pwent->pw_gecos, 0)));
#   else
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
d5453 2
a5454 1
	PUSHs(sv_2mortal(newSVpv(pwent->pw_dir, 0)));
d5456 2
a5457 1
	PUSHs(sv = sv_2mortal(newSVpv(pwent->pw_shell, 0)));
d5464 2
a5465 1
	PUSHs(sv_2mortal(newSViv((IV)pwent->pw_expire)));
d5470 1
a5470 1
    DIE(aTHX_ PL_no_func, PL_op_desc[PL_op->op_type]);
d5477 1
a5477 1
    dVAR; dSP;
d5488 1
a5488 1
    dVAR; dSP;
d5496 18
d5517 5
a5521 3
    dVAR; dSP;
    const I32 which = PL_op->op_type;
    const struct group *grent;
d5524 2
a5525 2
	const char* const name = POPpbytex;
	grent = (const struct group *)getgrnam(name);
d5528 2
a5529 2
	const Gid_t gid = POPi;
	grent = (const struct group *)getgrgid(gid);
d5540 1
a5540 3
	SV * const sv = sv_newmortal();

	PUSHs(sv);
d5551 2
a5552 1
	PUSHs(sv_2mortal(newSVpv(grent->gr_name, 0)));
d5554 1
d5556 1
a5556 3
	PUSHs(sv_2mortal(newSVpv(grent->gr_passwd, 0)));
#else
	PUSHs(sv_mortalcopy(&PL_sv_no));
d5559 2
a5560 1
	PUSHs(sv_2mortal(newSViv((IV)grent->gr_gid)));
d5563 1
d5572 5
a5576 1
	PUSHs(space_join_names_mortal(grent->gr_mem));
d5582 1
a5582 1
    DIE(aTHX_ PL_no_func, PL_op_desc[PL_op->op_type]);
d5589 1
a5589 1
    dVAR; dSP;
d5600 1
a5600 1
    dVAR; dSP;
d5611 1
a5611 1
    dVAR; dSP; dTARGET;
d5628 1
a5628 1
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
d5788 1
a5788 1
    const int save_errno = errno;
d5792 1
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d4 1
a4 1
 *    2004, 2005, 2006, 2007, 2008 by Larry Wall and others
a15 2
 *
 *     [p.945 of _The Lord of the Rings_, VI/iii: "Mount Doom"]
d331 1
a331 1
	    sv_setpvs(TARG, "");	/* note that this preserves previous buffer */
d345 1
a345 1
		mXPUSHs(sv);
d388 1
a388 1
    PL_last_in_gv = MUTABLE_GV(*PL_stack_sp--);
d391 1
a391 1
    PL_rs = newSVpvs_flags("\000", SVs_TEMP);
d440 1
a440 1
	tmpsv = newSVpvs_flags("Warning: something's wrong", SVs_TEMP);
d486 1
a486 1
		    call_sv(MUTABLE_SV(GvCV(gv)),
d504 1
a504 1
	tmpsv = newSVpvs_flags("Died", SVs_TEMP);
d522 1
a522 1
    GV * const gv = MUTABLE_GV(*++MARK);
d535 1
a535 1
	mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d539 1
a539 1
	    *MARK-- = SvTIED_obj(MUTABLE_SV(io), mg);
d572 1
a572 1
    GV * const gv = (MAXARG == 0) ? PL_defoutgv : MUTABLE_GV(POPs);
d577 1
a577 1
	    MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d580 1
a580 1
		XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
d604 2
a605 2
    GV * const wgv = MUTABLE_GV(POPs);
    GV * const rgv = MUTABLE_GV(POPs);
d610 1
a610 1
    if (!isGV_with_GP(rgv) || !isGV_with_GP(wgv))
d664 1
a664 1
    gv = MUTABLE_GV(POPs);
d667 1
a667 1
	&& (mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar)))
d670 1
a670 1
	XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
d737 1
a737 1
    gv = MUTABLE_GV(POPs);
d740 1
a740 1
	MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d743 1
a743 1
	    XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
d799 1
a799 1
	    HvEITER_set(MUTABLE_HV(varsv), 0);
a804 1
	    if (isGV_with_GP(varsv)) {
d806 3
a808 3
		if (GvUNIQUE((const GV *)varsv)) {
		    Perl_croak(aTHX_ "Attempt to tie unique GV");
		}
d810 8
a817 10
		methname = "TIEHANDLE";
		how = PERL_MAGIC_tiedscalar;
		/* For tied filehandles, we apply tiedscalar magic to the IO
		   slot of the GP rather than the GV itself. AMS 20010812 */
		if (!GvIOp(varsv))
		    GvIOp(varsv) = newIO();
		varsv = MUTABLE_SV(GvIOp(varsv));
		break;
	    }
	    /* FALL THROUGH */
d824 1
a824 1
    if (sv_isobject(*MARK)) { /* Calls GET magic. */
d838 1
a838 3
	STRLEN len;
	const char *name = SvPV_nomg_const(*MARK, len);
	stash = gv_stashpvn(name, len, 0);
d841 1
a841 1
		 methname, SVfARG(SvOK(*MARK) ? *MARK : &PL_sv_no));
d850 1
a850 1
	call_sv(MUTABLE_SV(GvCV(gv)), G_SCALAR);
d880 1
a880 1
    if (isGV_with_GP(sv) && !(sv = MUTABLE_SV(GvIOp(sv))))
d890 2
a891 2
	       XPUSHs(SvTIED_obj(MUTABLE_SV(gv), mg));
	       mXPUSHi(SvREFCNT(obj) - 1);
d894 1
a894 1
	       call_sv(MUTABLE_SV(cv), G_VOID);
d918 1
a918 1
    if (isGV_with_GP(sv) && !(sv = MUTABLE_SV(GvIOp(sv))))
d938 2
a939 2
    HV * const hv = MUTABLE_HV(POPs);
    SV * const sv = newSVpvs_flags("AnyDBM_File", SVs_TEMP);
d956 1
a956 1
	mPUSHu(O_RDWR|O_CREAT);
d958 1
a958 1
	mPUSHu(O_RDWR);
d961 1
a961 1
    call_sv(MUTABLE_SV(GvCV(gv)), G_SCALAR);
d969 1
a969 1
	mPUSHu(O_RDONLY);
d972 1
a972 1
	call_sv(MUTABLE_SV(GvCV(gv)), G_SCALAR);
d977 2
a978 2
	sv_unmagic(MUTABLE_SV(hv), PERL_MAGIC_tied);
	sv_magic(MUTABLE_SV(hv), TOPs, PERL_MAGIC_tied, NULL, 0);
d1021 1
a1021 1
		DIE(aTHX_ "%s", PL_no_modify);
d1140 1
a1140 1
	mPUSHn(value);
d1162 1
a1162 1
    GV * const newdefout = (PL_op->op_private > 0) ? (MUTABLE_GV(POPs)) : NULL;
d1177 1
a1177 1
	    mXPUSHs(newRV(MUTABLE_SV(egv)));
d1194 1
a1194 1
    GV * const gv = (MAXARG==0) ? PL_stdingv : MUTABLE_GV(POPs);
d1197 1
a1197 1
	MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d1201 1
a1201 1
	    XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
d1220 1
a1220 1
    sv_setpvs(TARG, " ");
a1242 2
    PERL_ARGS_ASSERT_DOFORM;

d1269 1
a1269 1
	gv = MUTABLE_GV(POPs);
d1299 1
a1299 1
	cv = MUTABLE_CV(sv_2mortal(MUTABLE_SV(cv_clone(cv))));
d1390 1
a1390 1
	    cv = MUTABLE_CV(sv_2mortal(MUTABLE_SV(cv_clone(cv))));
d1440 1
a1440 2
    GV * const gv
	= (PL_op->op_flags & OPf_STACKED) ? MUTABLE_GV(*++MARK) : PL_defoutgv;
d1443 1
a1443 1
	MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d1452 1
a1452 1
	    *MARK = SvTIED_obj(MUTABLE_SV(io), mg);
d1512 1
a1512 1
    GV * const gv = MUTABLE_GV(POPs);
d1548 1
a1548 1
    GV * const gv = MUTABLE_GV(*++MARK);
d1552 1
a1552 1
	const MAGIC * mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d1556 1
a1556 1
	    *MARK = SvTIED_obj(MUTABLE_SV(io), mg);
d1572 1
a1572 1
	sv_setpvs(bufsv, "");
d1794 1
a1794 1
    GV *const gv = MUTABLE_GV(*++MARK);
d1797 1
a1797 1
	MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d1802 3
a1804 2
		sv = *SP;
		mXPUSHi(sv_len(sv));
d1809 1
a1809 1
	    *(ORIGMARK+1) = SvTIED_obj(MUTABLE_SV(io), mg);
d2016 1
a2016 1
			sv_setpvs(GvSV(gv), "-");
d2019 1
a2019 1
			GvSV(gv) = newSVpvs("-");
d2031 1
a2031 1
	gv = PL_last_in_gv = MUTABLE_GV(POPs);	/* eof(FH) */
d2036 1
a2036 1
	if (io && (mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar))) {
d2038 1
a2038 1
	    XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
d2059 1
a2059 1
	PL_last_in_gv = MUTABLE_GV(POPs);
d2063 1
a2063 1
	MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d2066 1
a2066 1
	    XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
d2094 1
a2094 1
    GV * const gv = PL_last_in_gv = MUTABLE_GV(POPs);
d2098 1
a2098 1
	MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d2101 1
a2101 1
	    XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
d2103 1
a2103 1
	    mXPUSHn((NV) offset);
d2105 1
a2105 1
	    mXPUSHi(offset);
d2107 1
a2107 1
	    mXPUSHi(whence);
d2131 1
a2131 1
            mPUSHs(sv);
d2191 2
a2192 2
	    if (isGV_with_GP(sv)) {
	        tmpgv = MUTABLE_GV(sv);		/* *main::FRED for example */
d2195 2
a2196 2
	    else if (SvROK(sv) && isGV_with_GP(SvRV(sv))) {
	        tmpgv = MUTABLE_GV(SvRV(sv));	/* \*main::FRED for example */
d2200 1
a2200 1
		io = MUTABLE_IO(SvRV(sv)); /* *main::FRED{IO} for example */
d2238 1
a2238 1
    GV * const gv = MUTABLE_GV(POPs);
d2315 1
a2315 1
    GV * const gv = (MAXARG == 0) ? PL_last_in_gv : MUTABLE_GV(POPs);
d2350 1
a2350 1
    GV * const gv = MUTABLE_GV(POPs);
d2400 2
a2401 2
    GV * const gv2 = MUTABLE_GV(POPs);
    GV * const gv1 = MUTABLE_GV(POPs);
d2461 1
a2461 1
    GV * const gv = MUTABLE_GV(POPs);
d2490 1
a2490 1
    GV * const gv = MUTABLE_GV(POPs);
d2520 1
a2520 1
    GV * const gv = MUTABLE_GV(POPs);
d2553 2
a2554 2
    GV * const ggv = MUTABLE_GV(POPs);
    GV * const ngv = MUTABLE_GV(POPs);
d2625 1
a2625 1
    GV * const gv = MUTABLE_GV(POPs);
d2652 1
a2652 1
    GV * const gv = MUTABLE_GV(POPs);
d2726 1
a2726 1
    GV * const gv = MUTABLE_GV(POPs);
d2812 1
a2812 1
	    sv_setpvs(PL_statname, "");
d2838 2
a2839 2
	if (isGV_with_GP(sv)) {
	    gv = MUTABLE_GV(sv);
d2841 2
a2842 2
	} else if(SvROK(sv) && isGV_with_GP(SvRV(sv))) {
            gv = MUTABLE_GV(SvRV(sv));
d2847 1
a2847 1
            io = MUTABLE_IO(SvRV(sv));
d2876 4
a2879 4
	mPUSHi(PL_statcache.st_dev);
	mPUSHi(PL_statcache.st_ino);
	mPUSHu(PL_statcache.st_mode);
	mPUSHu(PL_statcache.st_nlink);
d2881 1
a2881 1
	mPUSHn(PL_statcache.st_uid);
d2884 1
a2884 1
	mPUSHi(PL_statcache.st_uid);
d2886 1
a2886 1
	mPUSHu(PL_statcache.st_uid);
d2890 1
a2890 1
	mPUSHn(PL_statcache.st_gid);
d2893 1
a2893 1
	mPUSHi(PL_statcache.st_gid);
d2895 1
a2895 1
	mPUSHu(PL_statcache.st_gid);
d2899 1
a2899 1
	mPUSHi(PL_statcache.st_rdev);
d2901 1
a2901 1
	PUSHs(newSVpvs_flags("", SVs_TEMP));
d2904 1
a2904 1
	mPUSHn(PL_statcache.st_size);
d2906 1
a2906 1
	mPUSHi(PL_statcache.st_size);
d2909 7
a2915 7
	mPUSHn(PL_statcache.st_atime);
	mPUSHn(PL_statcache.st_mtime);
	mPUSHn(PL_statcache.st_ctime);
#else
	mPUSHi(PL_statcache.st_atime);
	mPUSHi(PL_statcache.st_mtime);
	mPUSHi(PL_statcache.st_ctime);
d2918 2
a2919 2
	mPUSHu(PL_statcache.st_blksize);
	mPUSHu(PL_statcache.st_blocks);
d2921 2
a2922 2
	PUSHs(newSVpvs_flags("", SVs_TEMP));
	PUSHs(newSVpvs_flags("", SVs_TEMP));
d2933 1
a2933 1
	if (!SvTRUE(TOPs)) { RETURN; } \
d3002 1
d3005 1
a3005 1
	access_mode = X_OK;
d3198 1
a3198 1
	gv = MUTABLE_GV(POPs);
d3200 1
a3200 1
	gv = MUTABLE_GV(SvRV(POPs));
d3247 1
a3247 1
	gv = MUTABLE_GV(POPs);
d3249 1
a3249 1
	gv = MUTABLE_GV(SvRV(POPs));
d3266 1
a3266 1
	    sv_setpvs(PL_statname, "");
d3398 2
a3399 2
        else if (isGV_with_GP(sv)) {
	    gv = MUTABLE_GV(sv);
d3401 2
a3402 2
	else if (SvROK(sv) && isGV_with_GP(SvRV(sv))) {
            gv = MUTABLE_GV(SvRV(sv));
a3601 2
    PERL_ARGS_ASSERT_DOONELINER;

d3753 1
a3753 1
    GV * const gv = MUTABLE_GV(POPs);
d3790 1
a3790 1
    GV * const gv = MUTABLE_GV(POPs);
d3815 1
a3815 1
        mXPUSHs(sv);
d3844 1
a3844 1
    GV * const gv = MUTABLE_GV(POPs);
d3871 1
a3871 1
    GV * const gv = MUTABLE_GV(POPs);
d3897 1
a3897 1
    GV * const gv = MUTABLE_GV(POPs);
d3922 1
a3922 1
    GV * const gv = MUTABLE_GV(POPs);
d4166 1
a4166 1
#  if defined(WIN32) || defined(OS2) || defined(__SYMBIAN32__) || defined(__VMS)
d4173 1
a4173 1
#  if defined(WIN32) || defined(OS2) || defined(__SYMBIAN32__) || defined(__VMS)
a4291 1
	XPUSHi(-1);
d4370 1
a4370 1
    mPUSHn(((NV)PL_timesbuf.tms_utime)/(NV)PL_clocktick);
d4372 3
a4374 3
	mPUSHn(((NV)PL_timesbuf.tms_stime)/(NV)PL_clocktick);
	mPUSHn(((NV)PL_timesbuf.tms_cutime)/(NV)PL_clocktick);
	mPUSHn(((NV)PL_timesbuf.tms_cstime)/(NV)PL_clocktick);
d4380 1
a4380 1
    mPUSHn(0.0);
d4383 3
a4385 3
	 mPUSHn(0.0);
	 mPUSHn(0.0);
	 mPUSHn(0.0);
d4478 1
a4478 1
	mPUSHs(tsv);
d4483 9
a4491 9
        mPUSHi(tmbuf->tm_sec);
	mPUSHi(tmbuf->tm_min);
	mPUSHi(tmbuf->tm_hour);
	mPUSHi(tmbuf->tm_mday);
	mPUSHi(tmbuf->tm_mon);
	mPUSHi(tmbuf->tm_year);
	mPUSHi(tmbuf->tm_wday);
	mPUSHi(tmbuf->tm_yday);
	mPUSHi(tmbuf->tm_isdst);
a4608 2
    PERL_ARGS_ASSERT_SPACE_JOIN_NAMES_MORTAL;

d4610 1
a4610 1
	target = newSVpvs_flags("", SVs_TEMP);
d4693 1
a4693 1
	mPUSHs(newSVpv((char*)hent->h_name, 0));
d4695 1
a4695 1
	mPUSHi(hent->h_addrtype);
d4697 1
a4697 1
	mPUSHi(len);
d4700 1
a4700 1
	    mXPUSHp(*elem, len);
d4704 1
a4704 1
	    mPUSHp(hent->h_addr, len);
d4776 1
a4776 1
	mPUSHs(newSVpv(nent->n_name, 0));
d4778 2
a4779 2
	mPUSHi(nent->n_addrtype);
	mPUSHi(nent->n_net);
d4837 1
a4837 1
	mPUSHs(newSVpv(pent->p_name, 0));
d4839 1
a4839 1
	mPUSHi(pent->p_proto);
d4907 1
a4907 1
	mPUSHs(newSVpv(sent->s_name, 0));
d4910 1
a4910 1
	mPUSHi(PerlSock_ntohs(sent->s_port));
d4912 1
a4912 1
	mPUSHi(sent->s_port);
d4914 1
a4914 1
	mPUSHs(newSVpv(sent->s_proto, 0));
d4938 1
a4938 1
    (void)PerlSock_setnetent(TOPi);
d4949 1
a4949 1
    (void)PerlSock_setprotoent(TOPi);
d4960 1
a4960 1
    (void)PerlSock_setservent(TOPi);
d5130 1
a5130 1
	mPUSHs(newSVpv(pwent->pw_name, 0));
d5132 1
a5132 2
	sv = newSViv(0);
	mPUSHs(sv);
d5153 1
a5153 1
	    dSAVE_ERRNO;
d5159 1
a5159 1
	    RESTORE_ERRNO;
d5176 1
a5176 1
	mPUSHi(pwent->pw_uid);
d5178 1
a5178 1
	mPUSHu(pwent->pw_uid);
d5182 1
a5182 1
	mPUSHi(pwent->pw_gid);
d5184 1
a5184 1
	mPUSHu(pwent->pw_gid);
d5192 1
a5192 1
	mPUSHi(pwent->pw_change);
d5195 1
a5195 1
	mPUSHi(pwent->pw_quota);
d5198 1
a5198 1
	mPUSHs(newSVpv(pwent->pw_age, 0));
d5209 1
a5209 1
	mPUSHs(newSVpv(pwent->pw_class, 0));
d5212 1
a5212 1
	mPUSHs(newSVpv(pwent->pw_comment, 0));
d5229 1
a5229 1
	mPUSHs(newSVpv(pwent->pw_dir, 0));
d5238 1
a5238 1
	mPUSHi(pwent->pw_expire);
a5297 1
#if Gid_t_sign <= 0
a5298 3
#else
		sv_setuv(sv, (UV)grent->gr_gid);
#endif
d5306 1
a5306 1
	mPUSHs(newSVpv(grent->gr_name, 0));
d5309 1
a5309 1
	mPUSHs(newSVpv(grent->gr_passwd, 0));
d5314 1
a5314 5
#if Gid_t_sign <= 0
	mPUSHi(grent->gr_gid);
#else
	mPUSHu(grent->gr_gid);
#endif
d5537 1
a5538 1
    dSAVE_ERRNO;
d5545 1
a5545 1
    RESTORE_ERRNO;
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@a31 2
#include "time64.h"
#include "time64.c"
d204 9
d252 1
d298 1
d330 1
a330 1
	    ENTER_with_name("backtick");
d336 1
a336 1
	    LEAVE_with_name("backtick");
d376 1
a376 1
    ENTER_with_name("glob");
d401 1
a401 1
    LEAVE_with_name("glob");
a508 1
    RETURN;
d533 3
a535 4
	if (IoDIRP(io))
	    Perl_ck_warner_d(aTHX_ packWARN2(WARN_IO, WARN_DEPRECATED),
			     "Opening dirhandle %s also as a file",
			     GvENAME(gv));
d544 1
a544 1
	    ENTER_with_name("call_OPEN");
d546 1
a546 1
	    LEAVE_with_name("call_OPEN");
d584 1
a584 1
		ENTER_with_name("call_CLOSE");
d586 1
a586 1
		LEAVE_with_name("call_CLOSE");
a652 1
    return NORMAL;
d674 1
a674 1
	ENTER_with_name("call_FILENO");
d676 1
a676 1
	LEAVE_with_name("call_FILENO");
d749 1
a749 1
	    ENTER_with_name("call_BINMODE");
d751 1
a751 1
	    LEAVE_with_name("call_BINMODE");
d767 2
a768 6
	STRLEN len = 0;
	const char *d = NULL;
	int mode;
	if (discp)
	    d = SvPV_const(discp, len);
	mode = mode_from_discipline(d, len);
d790 1
a790 1
    GV *gv = NULL;
d808 5
d830 1
a830 1
	ENTER_with_name("call_TIE");
d850 1
a850 1
	ENTER_with_name("call_TIE");
d873 1
a873 1
    LEAVE_with_name("call_TIE");
d900 1
a900 1
	       ENTER_with_name("call_UNTIE");
d902 1
a902 1
	       LEAVE_with_name("call_UNTIE");
d905 4
a908 4
	    else if (mg && SvREFCNT(obj) > 1) {
		Perl_ck_warner(aTHX_ packWARN(WARN_UNTIE),
			       "untie attempted while %"UVuf" inner references still exist",
			       (UV)SvREFCNT(obj) - 1 ) ;
d943 1
a943 1
    GV *gv = NULL;
d952 1
a952 1
	if (!stash || !(gv = gv_fetchmethod(stash, "TIEHASH")))
d1031 2
a1032 1
	    Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "Non-string passed as bitmask");
a1151 1
    return NORMAL;
a1154 11
/*
=for apidoc setdefout

Sets PL_defoutgv, the default file handle for output, to the passed in
typeglob. As PL_defoutgv "owns" a reference on its typeglob, the reference
count of the passed in typeglob is increased by one, and the reference count
of the typeglob that PL_defoutgv points to is decreased by one.

=cut
*/

d1160 2
a1161 1
    SvREFCNT_dec(PL_defoutgv);
a1202 3
    if (MAXARG == 0)
	EXTEND(SP, 1);

d1256 2
a1257 1
    PUSHFORMAT(cx, retop);
d1272 2
a1273 2
    CV *cv = NULL;
    SV *tmpsv = NULL;
d1317 1
a1317 1
    GV * const gv = cxstack[cxstack_ix].blk_format.gv;
d1420 2
a1421 1
	    Perl_ck_warner(aTHX_ packWARN(WARN_IO), "page overflow");
d1922 1
a1922 1
	    } else if (offset > (IV)blen_chars) {
a2012 2
    IO *io;
    MAGIC *mg;
d2014 22
a2035 7
    if (MAXARG)
	gv = PL_last_in_gv = MUTABLE_GV(POPs);	/* eof(FH) */
    else {
	EXTEND(SP, 1);

	if (PL_op->op_flags & OPf_SPECIAL)
	    gv = PL_last_in_gv = GvEGV(PL_argvgv);	/* eof() - ARGV magic */
d2039 2
d2042 12
a2053 41
    if (!gv)
	RETPUSHNO;

    if ((io = GvIO(gv)) && (mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar))) {
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
	/*
	 * in Perl 5.12 and later, the additional paramter is a bitmask:
	 * 0 = eof
	 * 1 = eof(FH)
	 * 2 = eof()  <- ARGV magic
	 */
	EXTEND(SP, 1);
	if (MAXARG)
	    mPUSHi(1);		/* 1 = eof(FH) - simple, explicit FH */
	else if (PL_op->op_flags & OPf_SPECIAL)
	    mPUSHi(2);		/* 2 = eof()   - ARGV magic */
	else
	    mPUSHi(0);		/* 0 = eof     - simple, implicit FH */
	PUTBACK;
	ENTER;
	call_method("EOF", G_SCALAR);
	LEAVE;
	SPAGAIN;
	RETURN;
    }

    if (!MAXARG && (PL_op->op_flags & OPf_SPECIAL)) {	/* eof() */
	if (io && !IoIFP(io)) {
	    if ((IoFLAGS(io) & IOf_START) && av_len(GvAVn(gv)) < 0) {
		IoLINES(io) = 0;
		IoFLAGS(io) &= ~IOf_START;
		do_open(gv, "-", 1, FALSE, O_RDONLY, 0, NULL);
		if (GvSV(gv))
		    sv_setpvs(GvSV(gv), "-");
		else
		    GvSV(gv) = newSVpvs("-");
		SvSETMAGIC(GvSV(gv));
	    }
	    else if (!nextargv(gv))
		RETPUSHYES;
d2057 1
a2057 1
    PUSHs(boolSV(do_eof(gv)));
a2068 2
    else
	EXTEND(SP, 1);
a2083 6
    else if (!gv) {
	if (!errno)
	    SETERRNO(EBADF,RMS_IFI);
	PUSHi(-1);
	RETURN;
    }
a2346 1
    return NORMAL;
a2398 1
    return NORMAL;
a2459 1
    return NORMAL;
a2490 1
    return NORMAL;
a2520 1
    return NORMAL;
a2546 1
    return NORMAL;
a2625 1
    return NORMAL;
a2649 1
    return NORMAL;
a2726 1
    return NORMAL;
a2790 1
    return NORMAL;
d2810 3
a2812 2
		Perl_ck_warner(aTHX_ packWARN(WARN_IO),
			       "lstat() on filehandle %s", gv ? GvENAME(gv) : "");
a2967 1
    char opchar = '?';
a2969 10
    switch (PL_op->op_type) {
    case OP_FTRREAD:	opchar = 'R'; break;
    case OP_FTRWRITE:	opchar = 'W'; break;
    case OP_FTREXEC:	opchar = 'X'; break;
    case OP_FTEREAD:	opchar = 'r'; break;
    case OP_FTEWRITE:	opchar = 'w'; break;
    case OP_FTEEXEC:	opchar = 'x'; break;
    }
    tryAMAGICftest(opchar);

d3002 1
a3002 1
	/* fall through */
a3061 1
    char opchar = '?';
a3062 10

    switch (op_type) {
    case OP_FTIS:	opchar = 'e'; break;
    case OP_FTSIZE:	opchar = 's'; break;
    case OP_FTMTIME:	opchar = 'M'; break;
    case OP_FTCTIME:	opchar = 'C'; break;
    case OP_FTATIME:	opchar = 'A'; break;
    }
    tryAMAGICftest(opchar);

a3063 1

a3099 1
    char opchar = '?';
a3101 16
    switch (PL_op->op_type) {
    case OP_FTROWNED:	opchar = 'O'; break;
    case OP_FTEOWNED:	opchar = 'o'; break;
    case OP_FTZERO:	opchar = 'z'; break;
    case OP_FTSOCK:	opchar = 'S'; break;
    case OP_FTCHR:	opchar = 'c'; break;
    case OP_FTBLK:	opchar = 'b'; break;
    case OP_FTFILE:	opchar = 'f'; break;
    case OP_FTDIR:	opchar = 'd'; break;
    case OP_FTPIPE:	opchar = 'p'; break;
    case OP_FTSUID:	opchar = 'u'; break;
    case OP_FTSGID:	opchar = 'g'; break;
    case OP_FTSVTX:	opchar = 'k'; break;
    }
    tryAMAGICftest(opchar);

a3117 1

d3184 1
a3185 6
    I32 result;

    tryAMAGICftest('l');
    result = my_lstat();
    SPAGAIN;

a3200 2
    tryAMAGICftest('t');

a3249 2
    tryAMAGICftest(PL_op->op_type == OP_FTTEXT ? 'T' : 'B');

a3495 1
    return NORMAL;
a3569 1
    return NORMAL;
d3769 3
a3771 4
    if ((IoIFP(io) || IoOFP(io)))
	Perl_ck_warner_d(aTHX_ packWARN2(WARN_IO, WARN_DEPRECATED),
			 "Opening filehandle %s also as a directory",
			 GvENAME(gv));
a3783 1
    return NORMAL;
a3790 1
    return NORMAL;
d3805 4
a3808 2
	Perl_ck_warner(aTHX_ packWARN(WARN_IO),
		       "readdir() attempted on invalid dirhandle %s", GvENAME(gv));
d3858 4
a3861 2
	Perl_ck_warner(aTHX_ packWARN(WARN_IO),
		       "telldir() attempted on invalid dirhandle %s", GvENAME(gv));
a3872 1
    return NORMAL;
d3885 4
a3888 2
	Perl_ck_warner(aTHX_ packWARN(WARN_IO),
		       "seekdir() attempted on invalid dirhandle %s", GvENAME(gv));
a3899 1
    return NORMAL;
d3911 4
a3914 2
	Perl_ck_warner(aTHX_ packWARN(WARN_IO),
		       "rewinddir() attempted on invalid dirhandle %s", GvENAME(gv));
a3924 1
    return NORMAL;
d3936 4
a3939 2
	Perl_ck_warner(aTHX_ packWARN(WARN_IO),
		       "closedir() attempted on invalid dirhandle %s", GvENAME(gv));
a3958 1
    return NORMAL;
a4004 1
    return NORMAL;
d4011 1
a4011 1
#if (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(__LIBCATAMOUNT__)
a4033 1
    return NORMAL;
d4039 1
a4039 1
#if (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(__LIBCATAMOUNT__)
a4063 1
    return NORMAL;
a4268 1
    return NORMAL;
a4289 1
    return NORMAL;
a4322 1
    return NORMAL;
a4335 1
    return NORMAL;
a4350 1
    return NORMAL;
a4400 1
    return NORMAL;
d4405 39
a4443 8
/* The 32 bit int year limits the times we can represent to these
   boundaries with a few days wiggle room to account for time zone
   offsets
*/
/* Sat Jan  3 00:00:00 -2147481748 */
#define TIME_LOWER_BOUND -67768100567755200.0
/* Sun Dec 29 12:00:00  2147483647 */
#define TIME_UPPER_BOUND  67767976233316800.0
d4449 2
a4450 4
    Time64_T when;
    struct TM tmbuf;
    struct TM *err;
    const char *opname = PL_op->op_type == OP_LOCALTIME ? "localtime" : "gmtime";
d4457 8
a4464 13
    if (MAXARG < 1) {
	time_t now;
	(void)time(&now);
	when = (Time64_T)now;
    }
    else {
	double input = Perl_floor(POPn);
	when = (Time64_T)input;
	if (when != input) {
	    Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW),
			   "%s(%.0f) too large", opname, input);
	}
    }
d4466 8
a4473 16
    if ( TIME_LOWER_BOUND > when ) {
	Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW),
		       "%s(%.0f) too small", opname, when);
	err = NULL;
    }
    else if( when > TIME_UPPER_BOUND ) {
	Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW),
		       "%s(%.0f) too large", opname, when);
	err = NULL;
    }
    else {
	if (PL_op->op_type == OP_LOCALTIME)
	    err = S_localtime64_r(&when, &tmbuf);
	else
	    err = S_gmtime64_r(&when, &tmbuf);
    }
d4475 1
a4475 7
    if (err == NULL) {
	/* XXX %lld broken for quads */
	Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW),
		       "%s(%.0f) failed", opname, (double)when);
    }

    if (GIMME != G_ARRAY) {	/* scalar context */
a4476 3
	/* XXX newSVpvf()'s %lld type is broken, so cheat with a double */
	double year = (double)tmbuf.tm_year + 1900;

d4479 1
a4479 1
	if (err == NULL)
d4481 8
a4488 9

	tsv = Perl_newSVpvf(aTHX_ "%s %s %2d %02d:%02d:%02d %.0f",
			    dayname[tmbuf.tm_wday],
			    monname[tmbuf.tm_mon],
			    tmbuf.tm_mday,
			    tmbuf.tm_hour,
			    tmbuf.tm_min,
			    tmbuf.tm_sec,
			    year);
d4491 1
a4491 4
    else {			/* list context */
	if ( err == NULL )
	    RETURN;

d4494 9
a4502 9
        mPUSHi(tmbuf.tm_sec);
	mPUSHi(tmbuf.tm_min);
	mPUSHi(tmbuf.tm_hour);
	mPUSHi(tmbuf.tm_mday);
	mPUSHi(tmbuf.tm_mon);
	mPUSHn(tmbuf.tm_year);
	mPUSHi(tmbuf.tm_wday);
	mPUSHi(tmbuf.tm_yday);
	mPUSHi(tmbuf.tm_isdst);
a4520 1
    return NORMAL;
a4589 1
    return NORMAL;
d4650 1
a4650 1
    struct hostent *hent = NULL;
a4724 1
    return NORMAL;
a4797 1
    return NORMAL;
a4857 1
    return NORMAL;
a4932 1
    return NORMAL;
a4943 1
    return NORMAL;
a4954 1
    return NORMAL;
a4965 1
    return NORMAL;
a4976 1
    return NORMAL;
a4988 1
    return NORMAL;
a5000 1
    return NORMAL;
a5012 1
    return NORMAL;
a5024 1
    return NORMAL;
a5257 1
    return NORMAL;
a5268 1
    return NORMAL;
a5279 1
    return NORMAL;
a5353 1
    return NORMAL;
a5364 1
    return NORMAL;
a5375 1
    return NORMAL;
a5390 1
    return NORMAL;
a5488 1
    return NORMAL;
a5500 1
    int res;
d5520 1
a5520 4
    res = fcntl(fd, (operation & LOCK_NB) ? F_SETLK : F_SETLKW, &flock);
    if (res == -1 && ((errno == EAGAIN) || (errno == EACCES)))
	errno = EWOULDBLOCK;
    return res;
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d52 4
a254 1
	/* diag_listed_as: entering effective %s failed */
a267 1
	/* diag_listed_as: entering effective %s failed */
a279 1
	/* diag_listed_as: leaving effective %s failed */
a288 1
	/* diag_listed_as: leaving effective %s failed */
d361 1
a361 21
    dSP;
    /* make a copy of the pattern if it is gmagical, to ensure that magic
     * is called once and only once */
    if (SvGMAGICAL(TOPm1s)) TOPm1s = sv_2mortal(newSVsv(TOPm1s));

    tryAMAGICunTARGET(iter_amg, -1, (PL_op->op_flags & OPf_SPECIAL));

    if (PL_op->op_flags & OPf_SPECIAL) {
	/* call Perl-level glob function instead. Stack args are:
	 * MARK, wildcard, csh_glob context index
	 * and following OPs should be: gv(CORE::GLOBAL::glob), entersub
	 * */
	return NORMAL;
    }
    /* stack args are: wildcard, gv(_GEN_n) */

    if (PL_globhook) {
	SETs(GvSV(TOPs));
	PL_globhook(aTHX);
	return NORMAL;
    }
d406 2
a407 1
    SV *exsv;
d412 1
a412 1
	exsv = TARG;
d416 1
a416 1
	exsv = &PL_sv_no;
d421 10
a430 1
	exsv = TOPs;
d432 2
d435 1
a435 16
    if (SvROK(exsv) || (SvPV_const(exsv, len), len)) {
	/* well-formed exception supplied */
    }
    else if (SvROK(ERRSV)) {
	exsv = ERRSV;
    }
    else if (SvPOK(ERRSV) && SvCUR(ERRSV)) {
	exsv = sv_mortalcopy(ERRSV);
	sv_catpvs(exsv, "\t...caught");
    }
    else {
	exsv = newSVpvs_flags("Warning: something's wrong", SVs_TEMP);
    }
    if (SvROK(exsv) && !PL_warnhook)
	 Perl_warn(aTHX_ "%"SVf, SVfARG(exsv));
    else warn_sv(exsv);
d442 2
a443 1
    SV *exsv;
d445 1
d452 3
a454 1
	exsv = TARG;
d458 2
a459 1
	exsv = TOPs;
d461 22
a482 21

    if (SvROK(exsv) || (SvPV_const(exsv, len), len)) {
	/* well-formed exception supplied */
    }
    else if (SvROK(ERRSV)) {
	exsv = ERRSV;
	if (sv_isobject(exsv)) {
	    HV * const stash = SvSTASH(SvRV(exsv));
	    GV * const gv = gv_fetchmethod(stash, "PROPAGATE");
	    if (gv) {
		SV * const file = sv_2mortal(newSVpv(CopFILE(PL_curcop),0));
		SV * const line = sv_2mortal(newSVuv(CopLINE(PL_curcop)));
		EXTEND(SP, 3);
		PUSHMARK(SP);
		PUSHs(exsv);
		PUSHs(file);
		PUSHs(line);
		PUTBACK;
		call_sv(MUTABLE_SV(GvCV(gv)),
			G_SCALAR|G_EVAL|G_KEEPERR);
		exsv = sv_mortalcopy(*PL_stack_sp--);
d484 1
d486 6
a491 45
    }
    else if (SvPV_const(ERRSV, len), len) {
	exsv = sv_mortalcopy(ERRSV);
	sv_catpvs(exsv, "\t...propagated");
    }
    else {
	exsv = newSVpvs_flags("Died", SVs_TEMP);
    }
    return die_sv(exsv);
}

/* I/O. */

OP *
Perl_tied_method(pTHX_ const char *const methname, SV **sp, SV *const sv,
		 const MAGIC *const mg, const U32 flags, U32 argc, ...)
{
    SV **orig_sp = sp;
    I32 ret_args;

    PERL_ARGS_ASSERT_TIED_METHOD;

    /* Ensure that our flag bits do not overlap.  */
    assert((TIED_METHOD_MORTALIZE_NOT_NEEDED & G_WANT) == 0);
    assert((TIED_METHOD_ARGUMENTS_ON_STACK & G_WANT) == 0);
    assert((TIED_METHOD_SAY & G_WANT) == 0);

    PUTBACK; /* sp is at *foot* of args, so this pops args from old stack */
    PUSHSTACKi(PERLSI_MAGIC);
    EXTEND(SP, argc+1); /* object + args */
    PUSHMARK(sp);
    PUSHs(SvTIED_obj(sv, mg));
    if (flags & TIED_METHOD_ARGUMENTS_ON_STACK) {
	Copy(orig_sp + 2, sp + 1, argc, SV*); /* copy args to new stack */
	sp += argc;
    }
    else if (argc) {
	const U32 mortalize_not_needed
	    = flags & TIED_METHOD_MORTALIZE_NOT_NEEDED;
	va_list args;
	va_start(args, argc);
	do {
	    SV *const arg = va_arg(args, SV *);
	    if(mortalize_not_needed)
		PUSHs(arg);
d493 2
a494 3
		mPUSHs(arg);
	} while (--argc);
	va_end(args);
d496 2
d499 2
a500 20
    PUTBACK;
    ENTER_with_name("call_tied_method");
    if (flags & TIED_METHOD_SAY) {
	/* local $\ = "\n" */
	SAVEGENERICSV(PL_ors_sv);
	PL_ors_sv = newSVpvs("\n");
    }
    ret_args = call_method(methname, flags & G_WANT);
    SPAGAIN;
    orig_sp = sp;
    POPSTACK;
    SPAGAIN;
    if (ret_args) { /* copy results back to original stack */
	EXTEND(sp, ret_args);
	Copy(orig_sp - ret_args + 1, sp + 1, ret_args, SV*);
	sp += ret_args;
	PUTBACK;
    }
    LEAVE_with_name("call_tied_method");
    return NORMAL;
d503 1
a503 6
#define tied_method0(a,b,c,d)		\
    Perl_tied_method(aTHX_ a,b,c,d,G_SCALAR,0)
#define tied_method1(a,b,c,d,e)		\
    Perl_tied_method(aTHX_ a,b,c,d,G_SCALAR,1,e)
#define tied_method2(a,b,c,d,e,f)	\
    Perl_tied_method(aTHX_ a,b,c,d,G_SCALAR,2,e,f)
d518 1
a518 1
    if (!isGV(gv) && !(SvTYPE(gv) == SVt_PVLV && isGV_with_GP(gv)))
d522 1
a522 1
	const MAGIC *mg;
d527 2
a528 2
			     "Opening dirhandle %"HEKf" also as a file",
			     HEKfARG(GvENAME_HEK(gv)));
d534 8
a541 3
	    return Perl_tied_method(aTHX_ "OPEN", mark - 1, MUTABLE_SV(io), mg,
				    G_SCALAR | TIED_METHOD_ARGUMENTS_ON_STACK,
				    sp - mark);
d567 1
a567 5
    GV * const gv =
	MAXARG == 0 || (!TOPs && !POPs) ? PL_defoutgv : MUTABLE_GV(POPs);

    if (MAXARG == 0)
	EXTEND(SP, 1);
d572 1
a572 1
	    const MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d574 8
a581 1
		return tied_method0("CLOSE", SP, MUTABLE_SV(io), mg);
d585 1
d646 1
d656 1
a656 1
    const MAGIC *mg;
a660 1
    io = GvIO(gv);
d662 1
a662 1
    if (io
d665 8
a672 1
	return tied_method0("FILENO", SP, MUTABLE_SV(io), mg);
d675 1
a675 1
    if (!io || !(fp = IoIFP(io))) {
d678 2
a679 2

	   report_evil_fh(gv);
d696 1
a696 1
    if (MAXARG < 1 || (!TOPs && !POPs)) {
d712 1
a712 1
    if (MAXARG >= 1 && (TOPs||POPs) && (POPi & 0700))
a733 1
    io = GvIO(gv);
d735 2
a736 2
    if (io) {
	const MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d738 10
a747 7
	    /* This takes advantage of the implementation of the varargs
	       function, which I don't think that the optimiser will be able to
	       figure out. Although, as it's a static function, in theory it
	       could.  */
	    return Perl_tied_method(aTHX_ "BINMODE", SP, MUTABLE_SV(io), mg,
				    G_SCALAR|TIED_METHOD_MORTALIZE_NOT_NEEDED,
				    discp ? 1 : 0, discp);
d751 4
a754 2
    if (!io || !(fp = IoIFP(io))) {
	report_evil_fh(gv);
a802 7
	    if (!AvREAL(varsv)) {
		if (!AvREIFY(varsv))
		    Perl_croak(aTHX_ "Cannot tie unreifiable array");
		av_clear((AV *)varsv);
		AvREIFY_off(varsv);
		AvREAL_on(varsv);
	    }
d805 1
a805 2
	case SVt_PVLV:
	    if (isGV_with_GP(varsv) && !SvFAKE(varsv)) {
d833 2
a834 4
	/* Can't use call_method here, else this: fileno FOO; tie @@a, "FOO"
	 * will attempt to invoke IO::File::TIEARRAY, with (best case) the
	 * wrong error message, and worse case, supreme action at a distance.
	 * (Sorry obfuscation writers. You're not going to be given this one.)
d836 4
a839 2
       stash = gv_stashsv(*MARK, 0);
       if (!stash || !(gv = gv_fetchmethod(stash, methname))) {
d880 1
a880 1
    if (isGV_with_GP(sv) && !SvFAKE(sv) && !(sv = MUTABLE_SV(GvIOp(sv))))
d890 1
a890 1
	       PUSHs(SvTIED_obj(MUTABLE_SV(gv), mg));
d918 1
a918 1
    if (isGV_with_GP(sv) && !SvFAKE(sv) && !(sv = MUTABLE_SV(GvIOp(sv))))
d922 4
a925 1
	PUSHs(SvTIED_obj(sv, mg));
a957 1
    {
a958 2
	if (!SvOK(right)) right = &PL_sv_no;
    }
a1014 1
	SvGETMAGIC(sv);
d1021 1
a1021 1
		Perl_croak_no_modify(aTHX);
d1024 2
a1025 4
	    if (!SvPOKp(sv))
		Perl_ck_warner(aTHX_ packWARN(WARN_MISC),
				    "Non-string passed as bitmask");
	    SvPV_force_nomg_nolen(sv);	/* force string conversion */
d1144 1
d1173 1
a1173 2
    GV * egv = GvEGVx(PL_defoutgv);
    GV * const *gvp;
d1177 6
a1182 5
    hv = isGV_with_GP(egv) ? GvSTASH(egv) : NULL;
    gvp = hv && HvENAME(hv)
		? (GV**)hv_fetch(hv, GvNAME(egv), HEK_UTF8(GvNAME_HEK(egv)) ? -GvNAMELEN(egv) : GvNAMELEN(egv), FALSE)
		: NULL;
    if (gvp && *gvp == egv) {
d1185 2
a1186 2
    }
    else {
d1188 1
d1203 2
a1204 3
    GV * const gv =
	MAXARG==0 || (!TOPs && !POPs) ? PL_stdingv : MUTABLE_GV(POPs);
    IO *const io = GvIO(gv);
d1209 2
a1210 2
    if (io) {
	const MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d1212 9
a1220 4
	    const U32 gimme = GIMME_V;
	    Perl_tied_method(aTHX_ "GETC", SP, MUTABLE_SV(io), mg, gimme, 0);
	    if (gimme == G_SCALAR) {
		SPAGAIN;
d1222 1
a1222 2
	    }
	    return NORMAL;
d1226 3
a1228 2
	if (!io || (!IoIFP(io) && IoTYPE(io) != IoTYPE_WRONLY))
	    report_evil_fh(gv);
a1257 3
    if (cv && CvCLONE(cv))
	cv = MUTABLE_CV(sv_2mortal(MUTABLE_SV(cv_clone(cv))));

d1280 1
a1280 1
    if (MAXARG == 0) {
a1281 2
	EXTEND(SP, 1);
    }
d1287 1
d1302 1
d1305 3
a1307 2
	if (SvPOK(tmpsv) && *SvPV_nolen_const(tmpsv))
	    DIE(aTHX_ "Undefined format \"%"SVf"\" called", SVfARG(tmpsv));
d1312 3
a1328 1
    OP *retop;
d1348 1
a1348 2
		topname = sv_2mortal(Perl_newSVpvf(aTHX_ "%"HEKf"_TOP",
                                        HEKfARG(GvNAME_HEK(gv))));
d1395 1
d1397 3
a1399 2
	    if (SvPOK(sv) && *SvPV_nolen_const(sv))
		DIE(aTHX_ "Undefined top format \"%"SVf"\" called", SVfARG(sv));
d1403 2
a1410 1
    retop = cx->blk_sub.retop;
d1415 6
a1420 4
	if (IoIFP(io))
	    report_wrongway_fh(gv, '<');
	else
	    report_evil_fh(gv);
d1443 1
a1443 1
    return retop;
d1449 1
a1454 1
    IO *const io = GvIO(gv);
d1456 2
a1457 2
    if (io) {
	const MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d1465 11
a1475 4
	    return Perl_tied_method(aTHX_ "PRINTF", mark - 1, MUTABLE_SV(io),
				    mg,
				    G_SCALAR | TIED_METHOD_ARGUMENTS_ON_STACK,
				    sp - mark);
d1480 3
a1482 2
    if (!io) {
	report_evil_fh(gv);
d1487 6
a1492 4
	if (IoIFP(io))
	    report_wrongway_fh(gv, '<');
	else if (ckWARN(WARN_CLOSED))
	    report_evil_fh(gv);
d1497 2
d1523 1
a1523 1
    const int perm = (MAXARG > 3 && (TOPs || POPs)) ? POPi : 0666;
d1545 1
a1545 1
    SSize_t offset;
a1547 1
    STRLEN orig_size;
d1550 1
d1566 1
a1566 1
	const MAGIC *const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d1568 11
a1578 3
	    return Perl_tied_method(aTHX_ "READ", mark - 1, MUTABLE_SV(io), mg,
				    G_SCALAR | TIED_METHOD_ARGUMENTS_ON_STACK,
				    sp - mark);
d1595 2
a1596 1
	report_evil_fh(gv);
a1619 1
	Sock_size_t bufsize;
a1635 3
	/* MSG_TRUNC can give oversized count; quietly lose it */
	if (count > length)
	    count = length;
d1654 3
d1663 1
a1663 1
	if (-offset > (SSize_t)blen)
d1675 1
a1675 1
    orig_size = SvCUR(bufsv);
d1682 2
a1683 2
    if (offset > 0 && offset > (SSize_t)orig_size) { /* Zero any newly allocated space */
    	Zero(buffer+orig_size, offset-orig_size, char);
a1716 1
	Sock_size_t bufsize;
d1735 2
a1736 2
	if (IoTYPE(io) == IoTYPE_WRONLY)
	    report_wrongway_fh(gv, '>');
d1795 1
a1795 1
PP(pp_syswrite)
d1798 1
d1807 1
d1809 5
a1813 1
    IO *const io = GvIO(gv);
a1814 3
    if (op_type == OP_SYSWRITE && io) {
	const MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
	if (mg) {
d1816 1
a1816 1
		SV *sv = *SP;
d1821 10
a1830 3
	    return Perl_tied_method(aTHX_ "WRITE", mark - 1, MUTABLE_SV(io), mg,
				    G_SCALAR | TIED_METHOD_ARGUMENTS_ON_STACK,
				    sp - mark);
d1839 1
d1842 6
a1847 4
	if (io && IoIFP(io))
	    report_wrongway_fh(gv, '<');
	else
	    report_evil_fh(gv);
d1879 1
a1879 17
#ifdef HAS_SOCKET
    if (op_type == OP_SEND) {
	const int flags = SvIVx(*++MARK);
	if (SP > MARK) {
	    STRLEN mlen;
	    char * const sockbuf = SvPVx(*++MARK, mlen);
	    retval = PerlSock_sendto(PerlIO_fileno(IoIFP(io)), buffer, blen,
				     flags, (struct sockaddr *)sockbuf, mlen);
	}
	else {
	    retval
		= PerlSock_send(PerlIO_fileno(IoIFP(io)), buffer, blen, flags);
	}
    }
    else
#endif
    {
d1974 18
d2018 1
a2018 12
    const MAGIC *mg;
    /*
     * in Perl 5.12 and later, the additional parameter is a bitmask:
     * 0 = eof
     * 1 = eof(FH)
     * 2 = eof()  <- ARGV magic
     *
     * I'll rely on the compiler's trace flow analysis to decide whether to
     * actually assign this out here, or punt it into the only block where it is
     * used. Doing it out here is DRY on the condition logic.
     */
    unsigned int which;
d2020 1
a2020 1
    if (MAXARG) {
a2021 2
	which = 1;
    }
d2025 3
a2027 5
	if (PL_op->op_flags & OPf_SPECIAL) {
	    gv = PL_last_in_gv = GvEGVx(PL_argvgv);	/* eof() - ARGV magic */
	    which = 2;
	}
	else {
a2028 2
	    which = 0;
	}
d2035 21
a2055 1
	return tied_method1("EOF", SP, MUTABLE_SV(io), mg, newSVuv(which));
d2085 1
a2085 1
    if (MAXARG != 0 && (TOPs || POPs))
d2091 2
a2092 3
    io = GvIO(gv);
    if (io) {
	const MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d2094 8
a2101 1
	    return tied_method0("TELL", SP, MUTABLE_SV(io), mg);
d2130 1
a2130 1
    IO *const io = GvIO(gv);
d2132 2
a2133 2
    if (io) {
	const MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d2135 2
d2138 1
a2138 1
	    SV *const offset_sv = newSVnv((NV) offset);
d2140 1
a2140 1
	    SV *const offset_sv = newSViv(offset);
d2142 7
a2148 3

	    return tied_method2("SEEK", SP, MUTABLE_SV(io), mg, offset_sv,
				newSViv(whence));
a2192 1
	SV * const sv = POPs;
d2197 5
a2201 5
	if ((tmpgv = PL_op->op_flags & OPf_SPECIAL
	               ? gv_fetchsv(sv, 0, SVt_PVIO)
	               : MAYBE_DEREF_GV(sv) )) {
	    io = GvIO(tmpgv);
	    if (!io)
d2205 1
d2222 13
a2234 1
	else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVIO) {
d2237 3
a2239 3
	}
	else {
	    const char * const name = SvPV_nomg_const_nolen(sv);
d2279 2
a2280 1
	report_evil_fh(gv);
d2347 2
d2350 1
a2350 3
    GV * const gv = MUTABLE_GV(POPs);
    IO *const io = GvIO(gv);
    PerlIO *const fp = io ? IoIFP(io) : NULL;
d2352 6
d2364 2
a2365 1
	report_evil_fh(gv);
d2373 1
a2378 2
#ifdef HAS_SOCKET

d2381 1
d2390 3
a2392 2
    if (!io) {
	report_evil_fh(gv);
d2424 4
a2428 1
#endif
d2443 13
a2455 4
    if (!io1)
	report_evil_fh(gv1);
    if (!io2)
	report_evil_fh(gv2);
d2457 1
a2457 1
    if (io1 && IoIFP(io1))
d2459 1
a2459 1
    if (io2 && IoIFP(io2))
a2461 3
    if (!io1 || !io2)
	RETPUSHUNDEF;

d2488 1
a2491 2
#ifdef HAS_SOCKET

d2494 1
a2501 1
    const int op_type = PL_op->op_type;
d2507 2
a2508 5
    TAINT_PROPER(PL_op_desc[op_type]);
    if ((op_type == OP_BIND
	 ? PerlSock_bind(PerlIO_fileno(IoIFP(io)), (struct sockaddr *)addr, len)
	 : PerlSock_connect(PerlIO_fileno(IoIFP(io)), (struct sockaddr *)addr, len))
	>= 0)
d2514 2
a2515 1
    report_evil_fh(gv);
d2518 35
d2557 1
d2563 1
a2563 1
    if (!io || !IoIFP(io))
d2572 2
a2573 1
    report_evil_fh(gv);
d2576 4
d2584 1
d2649 2
a2650 1
    report_evil_fh(ggv);
d2656 4
d2664 1
d2677 2
a2678 1
    report_evil_fh(gv);
d2681 4
d2689 1
d2753 2
a2754 1
    report_evil_fh(gv);
d2759 4
d2767 1
d2818 2
a2819 1
    report_evil_fh(gv);
a2822 1
}
d2824 3
d2828 1
d2837 1
a2837 1
    IO *io = NULL;
a2839 1
    SV* sv;
d2841 2
a2842 2
    if (PL_op->op_flags & OPf_REF ? (gv = cGVOP_gv, 1)
                                  : !!(sv=POPs, gv = MAYBE_DEREF_GV(sv))) {
d2847 1
a2847 5
			       "lstat() on filehandle%s%"SVf,
				gv ? " " : "",
				SVfARG(gv
                                        ? sv_2mortal(newSVhek(GvENAME_HEK(gv)))
                                        : &PL_sv_no));
a2848 1
		/* diag_listed_as: The stat preceding %s wasn't an lstat */
d2852 1
a2853 3
	    bool havefp;
          do_fstat_have_io:
	    havefp = FALSE;
d2855 1
a2855 1
	    PL_statgv = gv ? gv : (GV *)io;
d2859 2
a2860 2
	    }
            if (io) {
a2863 1
                        havefp = TRUE;
a2866 1
                        havefp = TRUE;
d2870 1
a2871 2
	    else PL_laststatval = -1;
	    if (PL_laststatval < 0 && !havefp) report_evil_fh(gv);
d2875 2
d2881 10
a2890 1
	if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVIO) { 
d2897 1
a2897 1
	sv_setpv(PL_statname, SvPV_nomg_const_nolen(sv));
a2920 4
#if ST_INO_SIZE > IVSIZE
	mPUSHn(PL_statcache.st_ino);
#else
#   if ST_INO_SIGN <= 0
a2921 4
#   else
	mPUSHu(PL_statcache.st_ino);
#   endif
#endif
d2972 7
a2978 74
/* If the next filetest is stacked up with this one
   (PL_op->op_private & OPpFT_STACKING), we leave
   the original argument on the stack for success,
   and skip the stacked operators on failure.
   The next few macros/functions take care of this.
*/

static OP *
S_ft_stacking_return_false(pTHX_ SV *ret) {
    dSP;
    OP *next = NORMAL;
    while (OP_IS_FILETEST(next->op_type)
	&& next->op_private & OPpFT_STACKED)
	next = next->op_next;
    if (PL_op->op_flags & OPf_REF) PUSHs(ret);
    else			   SETs(ret);
    PUTBACK;
    return next;
}

#define FT_RETURN_FALSE(X)			     \
    STMT_START {				      \
	if (PL_op->op_private & OPpFT_STACKING)	       \
	    return S_ft_stacking_return_false(aTHX_ X);	\
	RETURNX(PUSHs(X));				 \
    } STMT_END
#define FT_RETURN_TRUE(X)		 \
    RETURNX((void)(			  \
	PL_op->op_private & OPpFT_STACKING \
	    ? PL_op->op_flags & OPf_REF	    \
		? PUSHs((SV *)cGVOP_gv)	     \
		: 0			      \
	    : PUSHs(X)			       \
    ))

#define FT_RETURNNO	FT_RETURN_FALSE(&PL_sv_no)
#define FT_RETURNUNDEF	FT_RETURN_FALSE(&PL_sv_undef)
#define FT_RETURNYES	FT_RETURN_TRUE(&PL_sv_yes)

#define tryAMAGICftest_MG(chr) STMT_START { \
	if ( (SvFLAGS(TOPs) & (SVf_ROK|SVs_GMG)) \
		&& PL_op->op_flags & OPf_KIDS) {     \
	    OP *next = S_try_amagic_ftest(aTHX_ chr);	\
	    if (next) return next;			  \
	}						   \
    } STMT_END

STATIC OP *
S_try_amagic_ftest(pTHX_ char chr) {
    dVAR;
    dSP;
    SV* const arg = TOPs;

    assert(chr != '?');
    if (!(PL_op->op_private & OPpFT_STACKING)) SvGETMAGIC(arg);

    if (SvAMAGIC(TOPs))
    {
	const char tmpchr = chr;
	SV * const tmpsv = amagic_call(arg,
				newSVpvn_flags(&tmpchr, 1, SVs_TEMP),
				ftest_amg, AMGf_unary);

	if (!tmpsv)
	    return NULL;

	if (PL_op->op_private & OPpFT_STACKING) {
	    if (SvTRUE(tmpsv)) return NORMAL;
	    return S_ft_stacking_return_false(aTHX_ tmpsv);
	}

	SPAGAIN;

	RETURNX(SETs(tmpsv));
a2979 3
    return NULL;
}

d3000 1
a3000 1
    Mode_t stat_mode = S_IRUSR;
d3014 3
a3016 1
    tryAMAGICftest_MG(opchar);
d3094 1
a3094 1
    result = my_stat_flags(0);
d3097 1
a3097 1
	FT_RETURNUNDEF;
d3099 2
a3100 2
	FT_RETURNYES;
    FT_RETURNNO;
d3118 1
a3118 1
    tryAMAGICftest_MG(opchar);
d3120 3
a3122 1
    result = my_stat_flags(0);
d3125 1
a3125 1
	FT_RETURNUNDEF;
d3127 1
a3127 1
	FT_RETURNYES;
d3135 1
a3135 1
	    sv_setnv(TARG, (NV)PL_statcache.st_size);
d3137 1
a3137 1
	    sv_setiv(TARG, (IV)PL_statcache.st_size);
d3141 1
a3141 2
	    sv_setnv(TARG,
		    ((NV)PL_basetime - PL_statcache.st_mtime) / 86400.0 );
d3144 1
a3144 2
	    sv_setnv(TARG,
		    ((NV)PL_basetime - PL_statcache.st_atime) / 86400.0 );
d3147 1
a3147 2
	    sv_setnv(TARG,
		    ((NV)PL_basetime - PL_statcache.st_ctime) / 86400.0 );
a3149 3
	SvSETMAGIC(TARG);
	if (SvTRUE_nomg(TARG)) FT_RETURN_TRUE(TARG);
	else		       FT_RETURN_FALSE(TARG);
d3151 1
d3175 1
a3175 1
    tryAMAGICftest_MG(opchar);
d3180 2
a3181 5
    if(PL_op->op_type == OP_FTSUID) {
	if ((PL_op->op_flags & OPf_REF) == 0 && !(PL_op->op_private & OPpFT_STACKING))
	    (void) POPs;
	FT_RETURNNO;
    }
d3184 2
a3185 5
    if(PL_op->op_type == OP_FTSGID) {
	if ((PL_op->op_flags & OPf_REF) == 0 && !(PL_op->op_private & OPpFT_STACKING))
	    (void) POPs;
	FT_RETURNNO;
    }
d3188 2
a3189 5
    if(PL_op->op_type == OP_FTSVTX) {
	if ((PL_op->op_flags & OPf_REF) == 0 && !(PL_op->op_private & OPpFT_STACKING))
	    (void) POPs;
	FT_RETURNNO;
    }
d3192 3
a3194 1
    result = my_stat_flags(0);
d3197 1
a3197 1
	FT_RETURNUNDEF;
d3200 2
a3201 2
	if (PL_statcache.st_uid == PerlProc_getuid())
	    FT_RETURNYES;
d3204 2
a3205 2
	if (PL_statcache.st_uid == PerlProc_geteuid())
	    FT_RETURNYES;
d3209 1
a3209 1
	    FT_RETURNYES;
d3213 1
a3213 1
	    FT_RETURNYES;
d3217 1
a3217 1
	    FT_RETURNYES;
d3221 1
a3221 1
	    FT_RETURNYES;
d3225 1
a3225 1
	    FT_RETURNYES;
d3229 1
a3229 1
	    FT_RETURNYES;
d3233 1
a3233 1
	    FT_RETURNYES;
d3238 1
a3238 1
	    FT_RETURNYES;
d3244 1
a3244 1
	    FT_RETURNYES;
d3250 1
a3250 1
	    FT_RETURNYES;
d3254 1
a3254 1
    FT_RETURNNO;
d3263 2
a3264 2
    tryAMAGICftest_MG('l');
    result = my_lstat_flags(0);
d3268 1
a3268 1
	FT_RETURNUNDEF;
d3270 2
a3271 2
	FT_RETURNYES;
    FT_RETURNNO;
d3280 3
a3282 2
    char *name = NULL;
    STRLEN namelen;
d3284 1
a3284 1
    tryAMAGICftest_MG('t');
d3288 6
a3293 7
    else {
      SV *tmpsv = PL_op->op_private & OPpFT_STACKING ? TOPs : POPs;
      if (!(gv = MAYBE_DEREF_GV_nomg(tmpsv))) {
	name = SvPV_nomg(tmpsv, namelen);
	gv = gv_fetchpvn_flags(name, namelen, SvUTF8(tmpsv), SVt_PVIO);
      }
    }
d3297 7
a3303 2
    else if (name && isDIGIT(*name))
	    fd = atoi(name);
d3305 1
a3305 1
	FT_RETURNUNDEF;
d3307 2
a3308 2
	FT_RETURNYES;
    FT_RETURNNO;
d3329 1
a3329 1
    register SV *sv = NULL;
d3333 3
a3335 1
    tryAMAGICftest_MG(PL_op->op_type == OP_FTTEXT ? 'T' : 'B');
a3337 1
    {
d3339 6
a3344 9
	EXTEND(SP, 1);
    }
    else {
      sv = PL_op->op_private & OPpFT_STACKING ? TOPs : POPs;
      if ((PL_op->op_private & (OPpFT_STACKED|OPpFT_AFTER_t))
	     == OPpFT_STACKED)
	gv = PL_defgv;
      else gv = MAYBE_DEREF_GV_nomg(sv);
    }
d3347 1
d3350 1
a3350 3
		io = SvTYPE(PL_statgv) == SVt_PVIO
		    ? (IO *)PL_statgv
		    : GvIO(PL_statgv);
d3352 1
d3358 1
a3361 2
	PL_laststatval = -1;
	PL_laststype = OP_STAT;
d3367 1
a3367 1
		FT_RETURNUNDEF;
d3370 1
a3370 1
		    FT_RETURNNO;
d3372 1
a3372 1
		    FT_RETURNYES;
d3380 1
a3380 1
		FT_RETURNYES;
d3388 4
d3393 1
a3393 3
	    report_evil_fh(gv);
	    SETERRNO(EBADF,RMS_IFI);
	    FT_RETURNUNDEF;
d3397 1
a3397 1
	sv_setpv(PL_statname, SvPV_nomg_const_nolen(sv));
d3400 2
a3402 4
	    if (!gv) {
		PL_laststatval = -1;
		PL_laststype = OP_STAT;
	    }
d3406 1
a3406 1
	    FT_RETURNUNDEF;
a3407 1
	PL_laststype = OP_STAT;
d3411 1
a3411 1
	    FT_RETURNUNDEF;
d3418 2
a3419 2
		FT_RETURNNO;		/* special case NFS directories */
	    FT_RETURNYES;		/* null file is anything */
d3473 1
a3473 1
	FT_RETURNNO;
d3475 1
a3475 1
	FT_RETURNYES;
d3491 9
a3499 2
        else if (!(gv = MAYBE_DEREF_GV(sv)))
		tmps = SvPV_nomg_const_nolen(sv);
d3535 2
a3536 1
		report_evil_fh(gv);
d3542 2
a3543 1
	    report_evil_fh(gv);
d3581 1
d3599 1
a3599 1
	    if (PerlProc_geteuid() || PerlLIO_stat(tmps2, &PL_statbuf) < 0 || !S_ISDIR(PL_statbuf.st_mode))
d3656 1
d3675 1
d3803 1
a3803 1
    const int mode = (MAXARG > 1 && (TOPs||((void)POPs,0))) ? POPi : 0777;
d3858 2
a3859 2
			 "Opening filehandle %"HEKf" also as a directory",
			     HEKfARG(GvENAME_HEK(gv)) );
d3872 1
d3880 1
d3896 1
a3896 2
		       "readdir() attempted on invalid dirhandle %"HEKf,
                            HEKfARG(GvENAME_HEK(gv)));
d3947 1
a3947 2
		       "telldir() attempted on invalid dirhandle %"HEKf,
                            HEKfARG(GvENAME_HEK(gv)));
d3959 1
d3973 1
a3973 2
		       "seekdir() attempted on invalid dirhandle %"HEKf,
                                HEKfARG(GvENAME_HEK(gv)));
d3985 1
d3998 1
a3998 2
		       "rewinddir() attempted on invalid dirhandle %"HEKf,
                                HEKfARG(GvENAME_HEK(gv)));
d4009 1
d4022 1
a4022 2
		       "closedir() attempted on invalid dirhandle %"HEKf,
                                HEKfARG(GvENAME_HEK(gv)));
d4042 1
d4060 9
d4089 1
d4119 1
d4150 1
a4180 3
#if (defined(HAS_SIGPROCMASK) && !defined(PERL_MICRO))
	sigset_t newset, oldset;
#endif
a4183 5
#if (defined(HAS_SIGPROCMASK) && !defined(PERL_MICRO))
	sigemptyset(&newset);
	sigaddset(&newset, SIGCHLD);
	sigprocmask(SIG_BLOCK, &newset, &oldset);
#endif
a4192 3
#if (defined(HAS_SIGPROCMASK) && !defined(PERL_MICRO))
		sigprocmask(SIG_SETMASK, &oldset, NULL);
#endif
a4210 3
#ifdef HAS_SIGPROCMASK
	    sigprocmask(SIG_SETMASK, &oldset, NULL);
#endif
d4233 1
a4233 1
			DIE(aTHX_ "panic: kid popen errno read, n=%u", n);
a4240 3
#if (defined(HAS_SIGPROCMASK) && !defined(PERL_MICRO))
	sigprocmask(SIG_SETMASK, &oldset, NULL);
#endif
d4345 6
d4352 1
d4356 1
d4365 1
a4365 2
    const Pid_t pid =
	(MAXARG < 1) ? 0 : TOPs ? SvIVx(POPs) : ((void)POPs, 0);
d4378 1
d4388 2
a4389 3
    pgrp = MAXARG == 2 && (TOPs||POPs) ? POPi : 0;
    if (MAXARG > 0) pid = TOPs && TOPi;
    else {
d4393 4
d4412 1
a4415 6
#if defined(__GLIBC__) && ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3) || (__GLIBC__ > 2))
#  define PRIORITY_WHICH_T(which) (__priority_which_t)which
#else
#  define PRIORITY_WHICH_T(which) which
#endif

d4422 1
a4422 1
    SETi( getpriority(PRIORITY_WHICH_T(which), who) );
d4426 1
d4438 1
a4438 1
    SETi( setpriority(PRIORITY_WHICH_T(which), who, niceval) >= 0 );
d4442 1
a4445 2
#undef PRIORITY_WHICH_T

d4493 1
d4521 1
a4521 1
    if (MAXARG < 1 || (!TOPs && ((void)POPs, 1))) {
d4527 1
a4527 1
	NV input = Perl_floor(POPn);
a4529 1
	    /* diag_listed_as: gmtime(%f) too large */
d4531 1
a4531 1
			   "%s(%.0" NVff ") too large", opname, input);
a4535 1
	/* diag_listed_as: gmtime(%f) too small */
d4537 1
a4537 1
		       "%s(%.0" NVff ") too small", opname, when);
a4540 1
	/* diag_listed_as: gmtime(%f) too small */
d4542 1
a4542 1
		       "%s(%.0" NVff ") too large", opname, when);
d4555 1
a4555 1
		       "%s(%.0" NVff ") failed", opname, when);
d4604 1
d4611 1
d4623 1
a4623 1
    if (MAXARG < 1 || (!TOPs && !POPs))
d4663 1
a4663 1
    return Perl_pp_semget(aTHX);
d4681 1
d4701 1
a4701 1
    return Perl_pp_semget(aTHX);
d4816 2
a4817 1
    DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
d4890 2
a4891 1
    DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
d4951 2
a4952 1
    DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
d5027 2
a5028 1
    DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
d5034 1
d5036 2
a5037 5
    const int stayopen = TOPi;
    switch(PL_op->op_type) {
    case OP_SHOSTENT:
#ifdef HAS_SETHOSTENT
	PerlSock_sethostent(stayopen);
d5039 2
a5040 1
	DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
d5042 4
a5045 1
	break;
d5047 3
a5049 2
    case OP_SNETENT:
	PerlSock_setnetent(stayopen);
d5051 2
a5052 1
	DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
d5054 4
a5057 2
	break;
    case OP_SPROTOENT:
d5059 3
a5061 1
	PerlSock_setprotoent(stayopen);
d5063 2
a5064 1
	DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
d5066 4
a5069 2
	break;
    case OP_SSERVENT:
d5071 3
a5073 1
	PerlSock_setservent(stayopen);
d5075 2
a5076 1
	DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
a5077 3
	break;
    }
    RETSETYES;
d5082 1
d5084 3
a5086 4
    switch(PL_op->op_type) {
    case OP_EHOSTENT:
#ifdef HAS_ENDHOSTENT
	PerlSock_endhostent();
d5088 2
a5089 1
	DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
d5091 4
a5094 2
	break;
    case OP_ENETENT:
d5096 4
a5099 1
	PerlSock_endnetent();
d5101 2
a5102 1
	DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
d5104 4
a5107 2
	break;
    case OP_EPROTOENT:
d5109 4
a5112 1
	PerlSock_endprotoent();
d5114 2
a5115 1
	DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
d5117 4
a5120 2
	break;
    case OP_ESERVENT:
d5122 4
a5125 1
	PerlSock_endservent();
d5127 2
a5128 29
	DIE(aTHX_ PL_no_sock_func, PL_op_desc[PL_op->op_type]);
#endif
	break;
    case OP_SGRENT:
#if defined(HAS_GROUP) && defined(HAS_SETGRENT)
	setgrent();
#else
	DIE(aTHX_ PL_no_func, PL_op_desc[PL_op->op_type]);
#endif
	break;
    case OP_EGRENT:
#if defined(HAS_GROUP) && defined(HAS_ENDGRENT)
	endgrent();
#else
	DIE(aTHX_ PL_no_func, PL_op_desc[PL_op->op_type]);
#endif
	break;
    case OP_SPWENT:
#if defined(HAS_PASSWD) && defined(HAS_SETPWENT)
	setpwent();
#else
	DIE(aTHX_ PL_no_func, PL_op_desc[PL_op->op_type]);
#endif
	break;
    case OP_EPWENT:
#if defined(HAS_PASSWD) && defined(HAS_ENDPWENT)
	endpwent();
#else
	DIE(aTHX_ PL_no_func, PL_op_desc[PL_op->op_type]);
a5129 4
	break;
    }
    EXTEND(SP,1);
    RETPUSHYES;
d5275 1
a5275 1
			   * to have never made the unsuccessful
d5362 25
d5461 25
d5497 1
a5497 2
    sv_setpv_mg(TARG, tmps);
    PUSHs(TARG);
d5501 1
d5600 1
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a361 4
    GV * const gv = (PL_op->op_flags & OPf_SPECIAL) ? NULL : (GV *)POPs;

    PUTBACK;

d364 1
a364 1
    if (SvGMAGICAL(TOPs)) TOPs = sv_2mortal(newSVsv(TOPs));
d366 1
a366 1
    tryAMAGICunTARGETlist(iter_amg, (PL_op->op_flags & OPf_SPECIAL));
d370 1
a370 1
	 * MARK, wildcard
d375 2
d378 1
d390 1
a390 1
    if (TAINTING_get) {
d401 1
a401 1
    PL_last_in_gv = gv;
a440 1
	if (SvGMAGICAL(exsv)) exsv = sv_mortalcopy(exsv);
d446 7
a453 15
      SV * const errsv = ERRSV;
      SvGETMAGIC(errsv);
      if (SvROK(errsv)) {
	if (SvGMAGICAL(errsv)) {
	    exsv = sv_newmortal();
	    sv_setsv_nomg(exsv, errsv);
	}
	else exsv = errsv;
      }
      else if (SvPOKp(errsv) ? SvCUR(errsv) : SvNIOKp(errsv)) {
	exsv = sv_newmortal();
	sv_setsv_nomg(exsv, errsv);
	sv_catpvs(exsv, "\t...caught");
      }
      else {
a454 1
      }
d483 17
a499 21
    else {
	SV * const errsv = ERRSV;
	SvGETMAGIC(errsv);
	if (SvROK(errsv)) {
	    exsv = errsv;
	    if (sv_isobject(exsv)) {
		HV * const stash = SvSTASH(SvRV(exsv));
		GV * const gv = gv_fetchmethod(stash, "PROPAGATE");
		if (gv) {
		    SV * const file = sv_2mortal(newSVpv(CopFILE(PL_curcop),0));
		    SV * const line = sv_2mortal(newSVuv(CopLINE(PL_curcop)));
		    EXTEND(SP, 3);
		    PUSHMARK(SP);
		    PUSHs(exsv);
		    PUSHs(file);
		    PUSHs(line);
		    PUTBACK;
		    call_sv(MUTABLE_SV(GvCV(gv)),
			    G_SCALAR|G_EVAL|G_KEEPERR);
		    exsv = sv_mortalcopy(*PL_stack_sp--);
		}
d502 7
a508 7
	else if (SvPOK(errsv) && SvCUR(errsv)) {
	    exsv = sv_mortalcopy(errsv);
	    sv_catpvs(exsv, "\t...propagated");
	}
	else {
	    exsv = newSVpvs_flags("Died", SVs_TEMP);
	}
d663 2
a664 2
    IO *rstio;
    IO *wstio;
a854 2
	{
	    HE *entry;
a855 4
	    if (HvLAZYDEL(varsv) && (entry = HvEITER((HV *)varsv))) {
		HvLAZYDEL_off(varsv);
		hv_free_ent((HV *)varsv, entry);
	    }
a857 1
	}
d1053 4
a1056 4
    I32 i;
    I32 j;
    char *s;
    SV *sv;
d1083 2
a1084 1
	if (SvIsCOW(sv))
d1086 3
a1088 2
	if (SvREADONLY(sv) && !(SvPOK(sv) && SvCUR(sv) == 0))
		Perl_croak_no_modify();
d1230 1
a1230 2
    PERL_ARGS_ASSERT_SETDEFOUT;
    SvREFCNT_inc_simple_void_NN(gv);
d1315 1
a1315 1
    PERL_CONTEXT *cx;
a1327 4
    if (CvDEPTH(cv) >= 2) {
	PERL_STACK_OVERFLOW_CHECK();
	pad_push(CvPADLIST(cv), CvDEPTH(cv));
    }
d1329 1
a1329 1
    PAD_SET_CUR_NOSAVE(CvPADLIST(cv), CvDEPTH(cv));
d1339 2
a1340 2
    GV *gv;
    IO *io;
d1363 2
a1364 1
    assert(fgv);
d1370 5
a1374 1
	DIE(aTHX_ "Undefined format \"%"SVf"\" called", SVfARG(tmpsv));
d1377 1
a1377 1
    RETURNOP(doform(cv,gv,PL_op->op_next));
d1384 1
a1384 1
    IO * const io = GvIOp(gv);
d1389 1
a1389 1
    PERL_CONTEXT *cx;
d1447 1
a1447 1
	    do_print(GvSV(gv_fetchpvs("\f", GV_ADD, SVt_PV)), ofp);
d1459 4
a1462 1
	    DIE(aTHX_ "Undefined top format \"%"SVf"\" called", SVfARG(sv));
a1470 1
    SP = newsp; /* ignore retval of formline */
d1473 3
a1475 2
    if (!io || !(fp = IoOFP(io))) {
	if (io && IoIFP(io))
d1496 1
d1498 2
d1501 1
a1501 1
    RETURNOP(retop);
d1508 1
a1513 3
    /* Treat empty list as "" */
    if (MARK == SP) XPUSHs(&PL_sv_no);

d1530 1
a1544 1
	SV *sv = sv_newmortal();
d1553 1
d1559 1
a1625 2
    if (length < 0)
	DIE(aTHX_ "Negative length");
d1647 3
a1649 3
    if (DO_UTF8(bufsv)) {
	blen = sv_len_utf8_nomg(bufsv);
    }
a1653 1
    wanted = length;
d1659 1
a1659 1
#if (defined(VMS_DO_SOCKETS) && defined(DECCRTL_SOCKETS)) || defined(__QNXNTO__)
d1677 4
d1696 4
d1707 1
a1707 1
	if (offset >= (SSize_t)blen)
d1932 9
a1940 3
		/* Don't call sv_len_utf8 on a magical or overloaded
		   scalar, as we might get back a different result.  */
		blen_chars = sv_or_pv_len_utf8(bufsv, buffer, blen);
d2207 3
a2209 3
	if (PL_op->op_flags & OPf_SPECIAL
	               ? (tmpgv = gv_fetchsv(sv, 0, SVt_PVIO), 1)
	               : !!(tmpgv = MAYBE_DEREF_GV(sv)) ) {
d2376 1
a2376 1
    IO * const io = gv ? GvIOn(gv) : NULL;
d2407 4
d2424 2
a2425 2
    IO * const io1 = gv1 ? GvIOn(gv1) : NULL;
    IO * const io2 = gv2 ? GvIOn(gv2) : NULL;
d2479 1
a2479 1
    IO * const io = GvIOn(gv);
d2507 1
a2507 1
    IO * const io = gv ? GvIOn(gv) : NULL;
d2526 2
a2527 2
    IO *nstio;
    IO *gstio;
d2529 1
a2529 1
#if (defined(VMS_DO_SOCKETS) && defined(DECCRTL_SOCKETS)) || defined(__QNXNTO__)
d2577 4
d2602 1
a2602 1
    IO * const io = GvIOn(gv);
d2624 1
a2624 1
    IO * const io = GvIOn(gv);
d2693 1
a2693 1
    IO * const io = GvIOn(gv);
a2814 1
	SvTAINTED_off(PL_statname); /* previous tainting irrelevant */
a2897 7
/* All filetest ops avoid manipulating the perl stack pointer in their main
   bodies (since commit d2c4d2d1e22d3125), and return using either
   S_ft_return_false() or S_ft_return_true().  These two helper functions are
   the only two which manipulate the perl stack.  To ensure that no stack
   manipulation macros are used, the filetest ops avoid defining a local copy
   of the stack pointer with dSP.  */

d2906 2
a2907 1
S_ft_return_false(pTHX_ SV *ret) {
d2909 4
a2912 3
    dSP;

    if (PL_op->op_flags & OPf_REF) XPUSHs(ret);
a2914 6

    if (PL_op->op_private & OPpFT_STACKING) {
        while (OP_IS_FILETEST(next->op_type)
               && next->op_private & OPpFT_STACKED)
            next = next->op_next;
    }
d2918 18
a2935 14
PERL_STATIC_INLINE OP *
S_ft_return_true(pTHX_ SV *ret) {
    dSP;
    if (PL_op->op_flags & OPf_REF)
        XPUSHs(PL_op->op_private & OPpFT_STACKING ? (SV *)cGVOP_gv : (ret));
    else if (!(PL_op->op_private & OPpFT_STACKING))
        SETs(ret);
    PUTBACK;
    return NORMAL;
}

#define FT_RETURNNO	return S_ft_return_false(aTHX_ &PL_sv_no)
#define FT_RETURNUNDEF	return S_ft_return_false(aTHX_ &PL_sv_undef)
#define FT_RETURNYES	return S_ft_return_true(aTHX_ &PL_sv_yes)
d2938 1
a2938 1
	if ( (SvFLAGS(*PL_stack_sp) & (SVf_ROK|SVs_GMG)) \
d2948 2
a2949 1
    SV *const arg = *PL_stack_sp;
d2954 1
a2954 1
    if (SvAMAGIC(arg))
d2964 8
a2971 2
	return SvTRUE(tmpsv)
            ? S_ft_return_true(aTHX_ tmpsv) : S_ft_return_false(aTHX_ tmpsv);
d3000 1
d3064 1
a3064 1
	const char *name = SvPV_nolen(*PL_stack_sp);
d3081 1
a3081 1
	    FT_RETURNYES;
d3083 2
a3084 2
	    FT_RETURNUNDEF;
	FT_RETURNNO;
d3089 1
d3103 1
d3115 1
d3146 2
a3147 2
	return SvTRUE_nomg(TARG)
            ? S_ft_return_true(aTHX_ TARG) : S_ft_return_false(aTHX_ TARG);
d3156 1
d3178 2
d3185 2
d3192 2
d3199 1
d3264 1
d3269 1
d3281 1
d3292 1
a3292 1
      SV *tmpsv = *PL_stack_sp;
d3310 8
d3321 1
d3326 3
a3328 3
    STDCHAR *s;
    IO *io;
    SV *sv = NULL;
d3335 1
d3337 5
a3341 1
    else if ((PL_op->op_private & (OPpFT_STACKED|OPpFT_AFTER_t))
d3344 1
a3344 3
    else {
	sv = *PL_stack_sp;
	gv = MAYBE_DEREF_GV_nomg(sv);
d3842 1
a3842 1
    IO * const io = GvIOn(gv);
d3880 2
a3881 2
    const Direntry_t *dp;
    IO * const io = GvIOn(gv);
d3933 1
a3933 1
    IO * const io = GvIOn(gv);
d3959 1
a3959 1
    IO * const io = GvIOn(gv);
d3984 1
a3984 1
    IO * const io = GvIOn(gv);
d4008 1
a4008 1
    IO * const io = GvIOn(gv);
a4042 3
#if defined(HAS_SIGPROCMASK) && !defined(PERL_MICRO)
    sigset_t oldmask, newmask;
#endif
a4045 4
#if defined(HAS_SIGPROCMASK) && !defined(PERL_MICRO)
    sigfillset(&newmask);
    sigprocmask(SIG_SETMASK, &newmask, &oldmask);
#endif
a4046 14
    if (childpid == 0) {
	int sig;
	PL_sig_pending = 0;
	if (PL_psig_pend)
	    for (sig = 1; sig < SIG_SIZE; sig++)
		PL_psig_pend[sig] = 0;
    }
#if defined(HAS_SIGPROCMASK) && !defined(PERL_MICRO)
    {
	dSAVE_ERRNO;
	sigprocmask(SIG_SETMASK, &oldmask, NULL);
	RESTORE_ERRNO;
    }
#endif
d4048 1
a4048 1
	RETPUSHUNDEF;
d4065 1
a4065 1
	RETPUSHUNDEF;
d4143 1
a4143 1
    if (TAINTING_get) {
d4147 1
a4147 1
	    if (TAINT_get)
d4290 1
a4290 1
    if (TAINTING_get) {
d4294 1
a4294 1
	    if (TAINT_get)
d4309 6
d4316 1
d4322 4
d4327 1
d4723 2
a4724 2
    char **elem;
    SV *sv;
d4813 1
a4813 1
    SV *sv;
d4886 1
a4886 1
    SV *sv;
d4946 1
a4946 1
    SV *sv;
d5123 1
a5123 1
    SV *sv;
d5447 1
a5447 1
    I32 items = SP - MARK;
d5449 2
a5450 2
    I32 i = 0;
    IV retval = -1;
d5452 1
a5452 1
    if (TAINTING_get) {
d5506 24
d5664 1
a5664 1
 * indent-tabs-mode: nil
d5667 1
a5667 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d479 1
a479 2
    VMSISH_HUSHED  =
	VMSISH_HUSHED || (PL_curcop->op_private & OPpHUSH_VMSISH);
d531 1
a531 1
Perl_tied_method(pTHX_ SV *methname, SV **sp, SV *const sv,
d575 1
a575 1
    ret_args = call_sv(methname, (flags & G_WANT)|G_METHOD_NAMED);
d626 1
a626 1
	    return Perl_tied_method(aTHX_ SV_CONST(OPEN), mark - 1, MUTABLE_SV(io), mg,
d640 1
a640 1
    ok = do_open6(gv, tmps, len, NULL, MARK+1, (SP-MARK));
d665 1
a665 1
		return tied_method0(SV_CONST(CLOSE), SP, MUTABLE_SV(io), mg);
d685 5
a689 2
    assert (isGV_with_GP(rgv));
    assert (isGV_with_GP(wgv));
d691 2
a694 2

    wstio = GvIOn(wgv);
d748 1
a748 1
	return tied_method0(SV_CONST(FILENO), SP, MUTABLE_SV(io), mg);
d819 1
a819 1
	    return Perl_tied_method(aTHX_ SV_CONST(BINMODE), SP, MUTABLE_SV(io), mg,
a901 4
	    if (SvTYPE(varsv) == SVt_PVLV && LvTYPE(varsv) == 'y') {
		vivify_defelem(varsv);
		varsv = LvTARG(varsv);
	    }
a969 3
    if (SvTYPE(sv) == SVt_PVLV && LvTYPE(sv) == 'y' &&
	!(sv = defelem_target(sv, NULL))) RETPUSHUNDEF;

a1007 3
    if (SvTYPE(sv) == SVt_PVLV && LvTYPE(sv) == 'y' &&
	!(sv = defelem_target(sv, NULL))) RETPUSHUNDEF;

d1105 3
a1107 2
	if (SvREADONLY(sv)) {
	    if (!(SvPOK(sv) && SvCUR(sv) == 0))
a1108 2
	}
	else if (SvIsCOW(sv)) sv_force_normal_flags(sv, 0);
a1150 1
    SvGETMAGIC(sv);
d1152 1
a1152 1
	value = SvNV_nomg(sv);
d1239 1
a1239 1
typeglob.  As PL_defoutgv "owns" a reference on its typeglob, the reference
d1301 1
a1301 1
	    Perl_tied_method(aTHX_ SV_CONST(GETC), SP, MUTABLE_SV(io), mg, gimme, 0);
a1327 1
    else SvUTF8_off(TARG);
d1341 1
a1341 1
    if (CvCLONE(cv))
d1371 1
a1372 1
	gv = PL_defoutgv;
d1473 2
a1474 1
	assert(fgv); /* IoTOP_GV(io) should have been set above */
d1486 1
a1487 1
    POPFORMAT(cx);
d1539 1
a1539 1
	    return Perl_tied_method(aTHX_ SV_CONST(PRINTF), mark - 1, MUTABLE_SV(io),
d1591 2
a1592 1
    if (do_open_raw(gv, tmps, len, mode, perm)) {
d1628 1
a1628 1
	    return Perl_tied_method(aTHX_ SV_CONST(READ), mark - 1, MUTABLE_SV(io), mg,
a1703 8
#if defined(__CYGWIN__)
        /* recvfrom() on cygwin doesn't set bufsize at all for
           connected sockets, leaving us with trash in the returned
           name, so use the same test as the Win32 code to check if it
           wasn't set, and set it [perl #118843] */
        if (bufsize == sizeof namebuf)
            bufsize = 0;
#endif
d1762 14
d1866 1
a1866 1
	    return Perl_tied_method(aTHX_ SV_CONST(WRITE), mark - 1, MUTABLE_SV(io), mg,
d2079 1
a2079 1
	return tied_method1(SV_CONST(EOF), SP, MUTABLE_SV(io), mg, newSVuv(which));
d2084 1
a2084 1
	    if ((IoFLAGS(io) & IOf_START) && av_tindex(GvAVn(gv)) < 0) {
d2087 1
a2087 1
		do_open6(gv, "-", 1, NULL, NULL, 0);
d2119 1
a2119 1
	    return tied_method0(SV_CONST(TELL), SP, MUTABLE_SV(io), mg);
d2159 1
a2159 1
	    return tied_method2(SV_CONST(SEEK), SP, MUTABLE_SV(io), mg, offset_sv,
d2272 1
a2272 1
    int optype;
d2274 1
a2274 1
    IO * const io = GvIOn(gv);
d2278 1
a2278 1
    if (!IoIFP(io)) {
a2300 1
    optype = PL_op->op_type;
d2379 1
a2379 1
    IO * const io = GvIOn(gv);
d2382 8
a2417 1
    int fd[2];
a2420 1

a2421 1
    IO * const io2 = GvIOn(gv2);
d2423 8
a2430 1
    IO * const io1 = GvIOn(gv1);
d2432 1
a2432 1
    if (IoIFP(io1))
d2434 1
a2434 1
    if (IoIFP(io2))
d2437 3
d2480 1
a2480 1
    int op_type;
d2482 1
a2482 1
    if (!IoIFP(io))
a2485 1
    op_type = PL_op->op_type;
d2506 1
a2506 1
    IO * const io = GvIOn(gv);
d2508 1
a2508 1
    if (!IoIFP(io))
d2526 1
d2537 6
a2542 1
    IO * const gstio = GvIO(ggv);
d2599 1
a2599 1
    if (!IoIFP(io))
d2623 1
a2623 1
    if (!IoIFP(io))
d2693 1
a2693 1
    if (!IoIFP(io))
d2819 1
a2819 5
	    if (ckWARN(WARN_NEWLINE) &&
                    strchr(SvPV_nolen_const(PL_statname), '\n'))
            {
                /* PL_warn_nl is constant */
                GCC_DIAG_IGNORE(-Wformat-nonliteral);
a2820 2
                GCC_DIAG_RESTORE;
            }
d2846 18
a2863 4
	
        sv_setuid(PUSHmortal, PL_statcache.st_uid);
        sv_setgid(PUSHmortal, PL_statcache.st_gid);

d3295 1
a3295 1
    SSize_t len;
a3375 3
            {
                /* PL_warn_nl is constant */
                GCC_DIAG_IGNORE(-Wformat-nonliteral);
a3376 2
                GCC_DIAG_RESTORE;
            }
d3631 1
d3633 1
d3685 7
a3691 1
		const char * const errmsg = Strerror(e) ;
d3813 3
d3852 1
a3852 1
    if (!IoDIRP(io)) {
d3868 1
d3871 1
d3876 1
a3876 1
        RETPUSHUNDEF;
d3904 1
a3904 1
    if (!IoDIRP(io)) {
d3930 1
a3930 1
    if (!IoDIRP(io)) {
d3955 1
a3955 1
    if (!IoDIRP(io)) {
d3979 1
a3979 1
    if (!IoDIRP(io)) {
d4012 1
a4012 1
#ifdef HAS_SIGPROCMASK
d4018 1
a4018 1
#ifdef HAS_SIGPROCMASK
d4030 1
a4030 1
#ifdef HAS_SIGPROCMASK
d4149 1
a4149 1
#ifdef HAS_SIGPROCMASK
d4155 1
a4155 1
#ifdef HAS_SIGPROCMASK
d4169 1
a4169 1
#ifdef HAS_SIGPROCMASK
d4223 1
a4223 1
#ifdef HAS_SIGPROCMASK
a4430 2
    struct tms timesbuf;

d4432 7
a4438 1
    (void)PerlProc_times(&timesbuf);
d4440 1
a4440 1
    mPUSHn(((NV)timesbuf.tms_utime)/(NV)PL_clocktick);
d4442 3
a4444 3
	mPUSHn(((NV)timesbuf.tms_stime)/(NV)PL_clocktick);
	mPUSHn(((NV)timesbuf.tms_cutime)/(NV)PL_clocktick);
	mPUSHn(((NV)timesbuf.tms_cstime)/(NV)PL_clocktick);
a4521 1
	/* diag_listed_as: gmtime(%f) failed */
d4528 4
d4536 10
a4545 12
       else {
           mPUSHs(Perl_newSVpvf(aTHX_ "%s %s %2d %02d:%02d:%02d %.0f",
                                dayname[tmbuf.tm_wday],
                                monname[tmbuf.tm_mon],
                                tmbuf.tm_mday,
                                tmbuf.tm_hour,
                                tmbuf.tm_min,
                                tmbuf.tm_sec,
                                /* XXX newSVpvf()'s %lld type is broken,
                                 * so cheat with a double */
                                (double)tmbuf.tm_year + 1900));
        }
d4945 1
d4947 1
d4965 1
d4967 3
d4980 1
d4982 3
d5199 5
a5203 1
	        sv_setuid(sv, pwent->pw_uid);
d5251 1
d5255 1
d5257 5
a5261 2
        sv_setuid(PUSHmortal, pwent->pw_uid);
        sv_setgid(PUSHmortal, pwent->pw_gid);
d5263 5
d5306 1
d5309 1
d5314 1
d5317 1
d5358 5
a5362 1
		sv_setgid(sv, grent->gr_gid);
d5378 5
a5382 1
        sv_setgid(PUSHmortal, grent->gr_gid);
@


1.1.1.16
log
@Import perl-5.20.2
@
text
@a2619 5
#if defined(_AIX)
        /* XXX Configure test: does getsockopt set the length properly? */
        if (len == 256)
            len = sizeof(int);
#endif
a4457 1
	const bool pl_isnan = Perl_isnan(input);
d4459 1
a4459 1
	if (UNLIKELY(pl_isnan || when != input)) {
a4462 4
	    if (pl_isnan) {
		err = NULL;
		goto failed;
	    }
a4487 1
      failed:
@


1.1.1.17
log
@Import perl-5.24.2
@
text
@d33 1
d182 4
a199 4
#ifdef __amigaos4__
#  include "amigaos4/amigaio.h"
#endif

d298 1
a298 1
    dSP; dTARGET;
d301 1
a301 1
    const U8 gimme = GIMME_V;
d359 1
d419 1
d426 1
a426 1
    dSP; dMARK;
d475 1
a475 1
    dSP; dMARK;
d526 1
a526 3
    die_sv(exsv);
    NOT_REACHED; /* NOTREACHED */
    return NULL; /* avoid missing return from non-void function warning */
a536 1
    SSize_t extend_size;
d541 3
a543 3
    STATIC_ASSERT_STMT((TIED_METHOD_MORTALIZE_NOT_NEEDED & G_WANT) == 0);
    STATIC_ASSERT_STMT((TIED_METHOD_ARGUMENTS_ON_STACK & G_WANT) == 0);
    STATIC_ASSERT_STMT((TIED_METHOD_SAY & G_WANT) == 0);
d547 1
a547 14
    /* extend for object + args. If argc might wrap/truncate when cast
     * to SSize_t and incremented, set to -1, which will trigger a panic in
     * EXTEND().
     * The weird way this is written is because g++ is dumb enough to
     * warn "comparison is always false" on something like:
     *
     * sizeof(a) >= sizeof(b) && a >= B_t_MAX -1
     *
     * (where the LH condition is false)
     */
    extend_size =
        (argc > (sizeof(argc) >= sizeof(SSize_t) ? SSize_t_MAX - 1 : argc))
            ? -1 : (SSize_t)argc + 1;
    EXTEND(SP, extend_size);
d600 1
a600 1
    dSP;
d654 1
a654 1
    dSP;
d677 1
d686 2
d717 3
a719 5
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
    /* ensure close-on-exec */
    if ((fd[0] > PL_maxsysfd && fcntl(fd[0], F_SETFD, FD_CLOEXEC) < 0) ||
        (fd[1] > PL_maxsysfd && fcntl(fd[1], F_SETFD, FD_CLOEXEC) < 0))
        goto badexit;
d723 1
a723 1
  badexit:
d732 1
a732 1
    dSP; dTARGET;
a748 16
    if (io && IoDIRP(io)) {
#if defined(HAS_DIRFD) || defined(HAS_DIR_DD_FD)
        PUSHi(my_dirfd(IoDIRP(io)));
        RETURN;
#elif defined(ENOTSUP)
        errno = ENOTSUP;        /* Operation not supported */
        RETPUSHUNDEF;
#elif defined(EOPNOTSUPP)
        errno = EOPNOTSUPP;     /* Operation not supported on socket */
        RETPUSHUNDEF;
#else
        errno = EINVAL;         /* Invalid argument */
        RETPUSHUNDEF;
#endif
    }

d764 1
d795 1
a795 1
    dSP;
d856 1
a856 1
    dSP; dMARK;
d904 1
a904 1
	    /* FALLTHROUGH */
a960 3

/* also used for: pp_dbmclose() */

d963 1
a963 1
    dSP;
d1003 1
d1006 1
a1006 1
    dTOPss;
d1011 1
a1011 1
	goto ret_undef;
d1014 1
a1014 1
	!(sv = defelem_target(sv, NULL))) goto ret_undef;
d1017 2
a1018 2
	SETs(SvTIED_obj(sv, mg));
	return NORMAL; /* PUTBACK not needed, pp_tied never moves SP */
d1020 1
a1020 3
    ret_undef:
    SETs(&PL_sv_undef);
    return NORMAL;
d1025 1
a1025 1
    dSP;
a1068 2
        if (sv_isobject(TOPs))
            goto retie;
d1070 2
a1071 2
    else {
        retie:
d1082 1
a1082 1
    dSP; dTARGET;
d1154 1
a1154 1
     * UNIX, Solaris, Darwin) the smallest quantum select() operates
d1234 1
a1234 1
    if (GIMME_V == G_ARRAY && tbuf) {
a1245 3

=head1 GV Functions

d1248 2
a1249 2
Sets C<PL_defoutgv>, the default file handle for output, to the passed in
typeglob.  As C<PL_defoutgv> "owns" a reference on its typeglob, the reference
d1251 1
a1251 1
of the typeglob that C<PL_defoutgv> points to is decreased by one.
d1259 1
a1259 2
    GV *oldgv = PL_defoutgv;

a1260 1

d1262 1
a1263 1
    SvREFCNT_dec(oldgv);
d1268 1
a1268 1
    dSP; dTARGET;
d1299 1
a1299 1
    dSP; dTARGET;
d1310 1
a1310 1
	    const U8 gimme = GIMME_V;
d1346 1
d1348 1
a1348 1
    const U8 gimme = GIMME_V;
d1355 7
a1361 3
    cx = cx_pushblock(CXt_FORMAT, gimme, PL_stack_sp, PL_savestack_ix);
    cx_pushformat(cx, cv, retop, gv);
    if (CvDEPTH(cv) >= 2)
d1363 2
d1373 1
d1413 2
a1414 2
    dSP;
    GV * const gv = CX_CUR()->blk_format.gv;
d1418 2
a1421 1
    bool is_return = cBOOL(PL_op->op_type == OP_RETURN);
d1423 1
a1423 1
    if (is_return || !io || !(ofp = IoOFP(io)))
d1495 1
a1495 6
    cx = CX_CUR();
    assert(CxTYPE(cx) == CXt_FORMAT);
    SP = PL_stack_base + cx->blk_oldsp; /* ignore retval of formline */
    CX_LEAVE_SCOPE(cx);
    cx_popformat(cx);
    cx_popblock(cx);
d1497 3
a1499 1
    CX_POP(cx);
d1501 1
a1501 7
    if (is_return)
        /* XXX the semantics of doing 'return' in a format aren't documented.
         * Currently we ignore any args to 'return' and just return
         * a single undef in both scalar and list contexts
         */
	PUSHs(&PL_sv_undef);
    else if (!io || !(fp = IoOFP(io))) {
d1524 1
d1530 1
a1530 1
    dSP; dMARK; dORIGMARK;
d1591 1
a1610 3

/* also used for: pp_read() and pp_recv() (where supported) */

d1613 1
a1613 1
    dSP; dMARK; dORIGMARK; dTARGET;
d1630 1
a1631 2
    int fd;

a1661 4

    /* Note that fd can here validly be -1, don't check it yet. */
    fd = PerlIO_fileno(IoIFP(io));

a1662 5
        if (PL_op->op_type == OP_SYSREAD || PL_op->op_type == OP_RECV) {
            Perl_ck_warner(aTHX_ packWARN(WARN_DEPRECATED),
                           "%s() is deprecated on :utf8 handles",
                           OP_DESC(PL_op));
        }
a1684 4
        if (fd < 0) {
            SETERRNO(EBADF,SS_IVCHAN);
            RETPUSHUNDEF;
        }
d1696 1
a1696 1
	count = PerlSock_recvfrom(fd, buffer, length, offset,
a1737 1

a1738 3
    /* Reestablish the fd in case it shifted from underneath us. */
    fd = PerlIO_fileno(IoIFP(io));

d1744 1
a1744 1
       IN_ENCODING Is true) */
d1768 2
a1769 6
            if (fd < 0) {
                SETERRNO(EBADF,SS_IVCHAN);
                count = -1;
            }
            else
                count = PerlSock_recv(fd, buffer, length, 0);
d1774 2
a1775 6
            if (fd < 0) {
                SETERRNO(EBADF,RMS_IFI);
                count = -1;
            }
            else
                count = PerlLIO_read(fd, buffer, length);
a1845 3

/* also used for: pp_send() where defined */

d1848 1
a1848 1
    dSP; dMARK; dORIGMARK; dTARGET;
a1858 1
    int fd;
a1888 6
    fd = PerlIO_fileno(IoIFP(io));
    if (fd < 0) {
        SETERRNO(EBADF,SS_IVCHAN);
        retval = -1;
        goto say_undef;
    }
a1895 3
        Perl_ck_warner(aTHX_ packWARN(WARN_DEPRECATED),
                       "%s() is deprecated on :utf8 handles",
                       OP_DESC(PL_op));
d1923 1
a1923 1
	    retval = PerlSock_sendto(fd, buffer, blen,
d1927 2
a1928 1
	    retval = PerlSock_send(fd, buffer, blen, flags);
d2011 2
a2012 1
	    retval = PerlSock_send(fd, buffer, length, 0);
d2018 2
a2019 1
            retval = PerlLIO_write(fd, buffer, length);
d2045 1
a2045 1
    dSP;
a2087 1
		SV ** svp;
d2091 2
a2092 6
		svp = &GvSV(gv);
		if (*svp) {
		    SV * sv = *svp;
		    sv_setpvs(sv, "-");
		    SvSETMAGIC(sv);
		}
d2094 2
a2095 1
		    *svp = newSVpvs("-");
d2097 1
a2097 1
	    else if (!nextargv(gv, FALSE))
d2108 1
a2108 1
    dSP; dTARGET;
a2139 3

/* also used for: pp_seek() */

d2142 1
a2142 1
    dSP;
d2189 1
d2227 1
a2227 10
                    int fd = PerlIO_fileno(fp);
                    if (fd < 0) {
                        SETERRNO(EBADF,RMS_IFI);
                        result = 0;
                    } else {
                        if (len < 0) {
                            SETERRNO(EINVAL, LIB_INVARG);
                            result = 0;
                        } else {
                           PerlIO_flush(fp);
d2229 1
a2229 1
                           if (ftruncate(fd, len) < 0)
d2231 1
a2231 1
                           if (my_chsize(fd, len) < 0)
d2233 1
a2233 3
                               result = 0;
                        }
                    }
d2249 1
a2249 2
                int mode = O_RDWR;
                int tmpfd;
d2251 1
a2251 13
#if defined(USE_64_BIT_RAWIO) && defined(O_LARGEFILE)
                mode |= O_LARGEFILE;	/* Transparently largefiley. */
#endif
#ifdef O_BINARY
                /* On open(), the Win32 CRT tries to seek around text
                 * files using 32-bit offsets, which causes the open()
                 * to fail on large files, so open in binary mode.
                 */
                mode |= O_BINARY;
#endif
                tmpfd = PerlLIO_open(name, mode);

		if (tmpfd < 0) {
d2253 1
a2253 1
		} else {
a2269 3

/* also used for: pp_fcntl() */

d2272 1
a2272 1
    dSP; dTARGET;
d2348 1
a2348 1
    dSP; dTARGET;
d2368 1
a2368 1
    DIE(aTHX_ PL_no_func, "flock");
d2378 1
a2378 1
    dSP;
d2391 1
a2391 2
    if (fd < 0) {
        SETERRNO(EBADF,RMS_IFI);
a2392 1
    }
d2402 2
a2403 4
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
    /* ensure close-on-exec */
    if (fd > PL_maxsysfd && fcntl(fd, F_SETFD, FD_CLOEXEC) < 0)
	RETPUSHUNDEF;
d2413 1
a2413 1
    dSP;
d2447 3
a2449 5
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
    /* ensure close-on-exec */
    if ((fd[0] > PL_maxsysfd && fcntl(fd[0], F_SETFD, FD_CLOEXEC) < 0) ||
        (fd[1] > PL_maxsysfd && fcntl(fd[1], F_SETFD, FD_CLOEXEC) < 0))
	RETPUSHUNDEF;
a2459 2
/* also used for: pp_connect() */

d2462 1
a2462 1
    dSP;
a2469 1
    int fd;
a2472 3
    fd = PerlIO_fileno(IoIFP(io));
    if (fd < 0)
        goto nuts;
d2478 2
a2479 2
	 ? PerlSock_bind(fd, (struct sockaddr *)addr, len)
	 : PerlSock_connect(fd, (struct sockaddr *)addr, len))
d2485 1
a2485 1
  nuts:
d2493 1
a2493 1
    dSP;
d2506 1
a2506 1
  nuts:
d2514 1
a2514 1
    dSP; dTARGET;
d2556 2
a2557 4
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
    /* ensure close-on-exec */
    if (fd > PL_maxsysfd && fcntl(fd, F_SETFD, FD_CLOEXEC) < 0)
        goto badexit;
d2567 1
a2567 1
  nuts:
d2571 1
a2571 1
  badexit:
d2578 1
a2578 1
    dSP; dTARGET;
d2589 1
a2589 1
  nuts:
a2594 3

/* also used for: pp_gsockopt() */

d2597 1
a2597 1
    dSP;
a2610 2
    if (fd < 0)
        goto nuts;
d2664 1
a2664 1
  nuts:
d2667 1
a2667 1
  nuts2:
a2671 3

/* also used for: pp_getsockname() */

d2674 1
a2674 1
    dSP;
a2690 2
    if (fd < 0)
        goto nuts;
d2723 1
a2723 1
  nuts:
d2726 1
a2726 1
  nuts2:
a2733 2
/* also used for: pp_lstat() */

d2736 1
d2740 1
a2740 1
    U8 gimme;
d2772 3
a2774 8
                        int fd = PerlIO_fileno(IoIFP(io));
                        if (fd < 0) {
                            PL_laststatval = -1;
                            SETERRNO(EBADF,RMS_IFI);
                        } else {
                            PL_laststatval = PerlLIO_fstat(fd, &PL_statcache);
                            havefp = TRUE;
                        }
a2791 1
        const char *file;
a2802 1
        file = SvPV_nolen_const(PL_statname);
d2804 1
a2804 1
	    PL_laststatval = PerlLIO_lstat(file, &PL_statcache);
d2806 1
a2806 1
	    PL_laststatval = PerlLIO_stat(file, &PL_statcache);
d2808 3
a2810 1
	    if (ckWARN(WARN_NEWLINE) && should_warn_nl(file)) {
d2931 1
a2953 3
/* also used for: pp_fteexec() pp_fteread() pp_ftewrite() pp_ftrexec()
 *                pp_ftrwrite() */

d2956 1
d2959 1
a2959 1
       no guarantee that OPpFT_ACCESS is <= CHAR_MAX  */
d3018 1
a3018 1
	/* FALLTHROUGH */
a3071 3

/* also used for: pp_ftatime() pp_ftctime() pp_ftmtime() pp_ftsize() */

d3074 1
a3123 5

/* also used for: pp_ftblk() pp_ftchr() pp_ftdir() pp_fteowned()
 *                pp_ftfile() pp_ftpipe() pp_ftsgid() pp_ftsock()
 *                pp_ftsuid() pp_ftsvtx() pp_ftzero() */

d3126 1
d3228 1
d3243 1
a3247 1
    UV uv;
d3263 2
a3264 2
    else if (name && isDIGIT(*name) && grok_atoUV(name, &uv, NULL) && uv <= PERL_INT_MAX)
        fd = (int)uv;
a3266 4
    if (fd < 0) {
        SETERRNO(EBADF,RMS_IFI);
	FT_RETURNUNDEF;
    }
a3271 3

/* also used for: pp_ftbinary() */

d3274 1
a3314 1
	    int fd;
d3317 1
a3317 6
	    fd = PerlIO_fileno(IoIFP(io));
	    if (fd < 0) {
                SETERRNO(EBADF,RMS_IFI);
		FT_RETURNUNDEF;
            }
	    PL_laststatval = PerlLIO_fstat(fd, &PL_statcache);
a3329 3
                else
                    /* null file is anything */
                    FT_RETURNYES;
d3331 2
a3346 4
        const char *file;
        int fd; 

        assert(sv);
a3348 1
        file = SvPVX_const(PL_statname);
d3350 1
a3350 1
	if (!(fp = PerlIO_open(file, "r"))) {
d3355 3
a3357 1
	    if (ckWARN(WARN_NEWLINE) && should_warn_nl(file)) {
d3366 1
a3366 7
        fd = PerlIO_fileno(fp);
        if (fd < 0) {
	    (void)PerlIO_close(fp);
            SETERRNO(EBADF,RMS_IFI);
	    FT_RETURNUNDEF;
        }
	PL_laststatval = PerlLIO_fstat(fd, &PL_statcache);
a3368 1
            SETERRNO(EBADF,RMS_IFI);
d3383 1
a3390 22
    assert(len);
    if (! is_invariant_string((U8 *) s, len)) {
        const U8 *ep;

        /* Here contains a variant under UTF-8 .  See if the entire string is
         * UTF-8.  But the buffer may end in a partial character, so consider
         * it UTF-8 if the first non-UTF8 char is an ending partial */
        if (is_utf8_string_loc((U8 *) s, len, &ep)
            || ep + UTF8SKIP(ep)  > (U8 *) (s + len))
        {
            if (PL_op->op_type == OP_FTTEXT) {
                FT_RETURNYES;
            }
            else {
                FT_RETURNNO;
            }
        }
    }

    /* Here, is not UTF-8 or is entirely ASCII.  Look through the buffer for
     * things that wouldn't be in ASCII text or rich ASCII text.  Count these
     * in 'odd' */
d3396 7
a3402 3
#ifdef USE_LOCALE_CTYPE
        if (IN_LC_RUNTIME(LC_CTYPE)) {
            if ( isPRINT_LC(*s) || isSPACE_LC(*s)) {
a3403 3
            }
        }
        else
d3405 23
a3427 12
        if (isPRINT_A(*s)
                   /* VT occurs so rarely in text, that we consider it odd */
                || (isSPACE_A(*s) && *s != VT_NATIVE)

                    /* But there is a fair amount of backspaces and escapes in
                     * some text */
                || *s == '\b'
                || *s == ESC_NATIVE)
        {
            continue;
        }
        odd++;
d3440 1
a3440 1
    dSP; dTARGET;
a3447 10
            if (!gv) {
                if (ckWARN(WARN_UNOPENED)) {
                    Perl_warner(aTHX_ packWARN(WARN_UNOPENED),
                                "chdir() on unopened filehandle %" SVf, sv);
                }
                SETERRNO(EBADF,RMS_IFI);
                PUSHi(0);
                TAINT_PROPER("chdir");
                RETURN;
            }
d3452 2
a3453 1
    else {
d3464 2
a3469 1
            SETERRNO(EINVAL, LIB_INVARG);
d3483 1
a3483 5
                int fd = PerlIO_fileno(IoIFP(io));
                if (fd < 0) {
                    goto nuts;
                }
                PUSHi(fchdir(fd) >= 0);
d3486 3
a3488 1
                goto nuts;
a3489 2
        } else {
            goto nuts;
d3491 5
a3495 1

a3507 8

#ifdef HAS_FCHDIR
 nuts:
    report_evil_fh(gv);
    SETERRNO(EBADF,RMS_IFI);
    PUSHi(0);
    RETURN;
#endif
a3509 3

/* also used for: pp_chmod() pp_kill() pp_unlink() pp_utime() */

d3512 1
a3512 1
    dSP; dMARK; dTARGET;
d3523 1
a3523 1
    dSP; dTARGET;
d3535 1
a3535 1
    dSP; dTARGET;
a3536 3
#ifndef HAS_RENAME
    Stat_t statbuf;
#endif
d3543 1
a3543 1
    if (!(anum = PerlLIO_stat(tmps, &statbuf))) {
d3547 1
a3547 1
	    if (PerlProc_geteuid() || PerlLIO_stat(tmps2, &statbuf) < 0 || !S_ISDIR(statbuf.st_mode))
a3557 3

/* also used for: pp_symlink() */

d3561 1
a3561 1
    dSP; dTARGET;
a3599 3

/* also used for: pp_symlink() */

d3609 1
d3615 1
a3615 1
    SSize_t len;
a3618 2
    /* NOTE: if the length returned by readlink() is sizeof(buf) - 1,
     * it is impossible to know whether the result was truncated. */
a3621 2
    if (len != -1)
        buf[len] = '\0';
d3700 1
a3700 2
	    Stat_t statbuf;
	    anum = (PerlLIO_stat(save_filename, &statbuf) >= 0);
d3737 1
a3737 1
    dSP; dTARGET;
d3741 1
a3741 1
    const unsigned int mode = (MAXARG > 1 && (TOPs||((void)POPs,0))) ? POPu : 0777;
d3764 1
a3764 1
    dSP; dTARGET;
d3786 1
a3786 1
    dSP;
d3801 1
a3801 1
  nope:
d3818 1
d3822 1
a3822 1
    const U8 gimme = GIMME_V;
d3853 1
a3853 1
  nope:
d3856 1
a3856 1
    if (gimme == G_ARRAY)
d3866 1
a3866 1
    dSP; dTARGET;
d3886 1
a3886 1
  nope:
d3898 1
a3898 1
    dSP;
d3912 1
a3912 1
  nope:
d3924 1
a3924 1
    dSP;
d3936 1
a3936 1
  nope:
d3948 1
a3948 1
    dSP;
d3969 1
a3969 1
  nope:
d3983 1
a3983 1
    dSP; dTARGET;
d4020 1
a4020 1
#  if (defined(USE_ITHREADS) && defined(PERL_IMPLICIT_SYS)) || defined(__amigaos4__)
d4040 1
a4040 1
    dSP; dTARGET;
d4068 1
a4068 1
    dSP; dTARGET;
a4071 6
#ifdef __amigaos4__
    int argflags = 0;
    result = amigaos_waitpid(aTHX_ optype, pid, &argflags);
    STATUS_NATIVE_CHILD_SET((result >= 0) ? argflags : -1);
    result = result == 0 ? pid : -1;
#else
a4087 1
# endif /* __amigaos4__ */
d4097 1
a4097 1
    dSP; dMARK; dORIGMARK; dTARGET;
a4103 3
# ifdef __amigaos4__
    void * result;
# else
a4104 1
# endif
d4117 1
a4117 1
#if (defined(HAS_FORK) || defined(__amigaos4__)) && !defined(VMS) && !defined(OS2) || defined(PERL_MICRO)
a4118 4
#ifdef __amigaos4__
        struct UserData userdata;
        pthread_t proc;
#else
a4119 1
#endif
a4121 1
        bool child_success = FALSE;
a4127 10
#ifdef __amigaos4__
        amigaos_fork_set_userdata(aTHX_
                                  &userdata,
                                  did_pipes,
                                  pp[1],
                                  SP,
                                  mark);
        pthread_create(&proc,NULL,amigaos_system_child,(void *)&userdata);
        child_success = proc > 0;
#else
d4149 1
a4149 3
        child_success = childpid > 0;
#endif
	if (child_success) {
a4152 1
#ifndef __amigaos4__
a4154 1
#endif
a4158 3
#ifdef __amigaos4__
            result = pthread_join(proc, (void **)&status);
#else
a4161 1
#endif
d4190 1
a4190 8
#ifdef __amigaos4__
                    /* The pipe always has something in it
                     * so n alone is not enough. */
                    if (errno > 0)
#endif
                    {
                        STATUS_NATIVE_CHILD_SET(-1);
                    }
a4195 1
#ifndef __amigaos4__
d4201 2
a4202 3
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
	    if (fcntl(pp[1], F_SETFD, FD_CLOEXEC) < 0)
                RETPUSHUNDEF;
a4213 1
#endif /* __amigaos4__ */
d4250 1
a4250 1
    dSP; dMARK; dORIGMARK; dTARGET;
a4262 1

d4281 1
d4290 1
a4290 1
    dSP; dTARGET;
d4301 1
a4301 1
    dSP; dTARGET;
d4316 1
a4316 1
    DIE(aTHX_ PL_no_func, "getpgrp");
d4323 1
a4323 1
    dSP; dTARGET;
d4327 1
a4327 1
    if (MAXARG > 0) pid = TOPs ? TOPi : 0;
d4330 1
a4330 2
	EXTEND(SP,1);
	SP++;
d4346 1
a4346 1
    DIE(aTHX_ PL_no_func, "setpgrp");
d4359 1
a4359 1
    dSP; dTARGET;
d4365 1
a4365 1
    DIE(aTHX_ PL_no_func, "getpriority");
d4372 1
a4372 1
    dSP; dTARGET;
d4380 1
a4380 1
    DIE(aTHX_ PL_no_func, "setpriority");
d4390 1
a4390 1
    dSP; dTARGET;
d4402 1
d4410 1
a4410 1
    if (GIMME_V == G_ARRAY) {
d4421 1
a4421 1
    if (GIMME_V == G_ARRAY) {
a4441 3

/* also used for: pp_localtime() */

d4444 1
d4490 1
a4490 1
	    err = Perl_localtime64_r(&when, &tmbuf);
d4492 1
a4492 1
	    err = Perl_gmtime64_r(&when, &tmbuf);
d4503 1
a4503 1
    if (GIMME_V != G_ARRAY) {	/* scalar context */
d4505 1
d4509 1
a4509 3
           dTARGET;
           PUSHs(TARG);
           Perl_sv_setpvf_mg(aTHX_ TARG, "%s %s %2d %02d:%02d:%02d %"IVdf,
d4516 3
a4518 1
                                (IV)tmbuf.tm_year + 1900);
d4543 8
a4550 25
    dSP; dTARGET;
    /* alarm() takes an unsigned int number of seconds, and return the
     * unsigned int number of seconds remaining in the previous alarm
     * (alarms don't stack).  Therefore negative return values are not
     * possible. */
    int anum = POPi;
    if (anum < 0) {
        /* Note that while the C library function alarm() as such has
         * no errors defined (or in other words, properly behaving client
         * code shouldn't expect any), alarm() being obsoleted by
         * setitimer() and often being implemented in terms of
         * setitimer(), can fail. */
        /* diag_listed_as: %s() with negative argument */
        Perl_ck_warner_d(aTHX_ packWARN(WARN_MISC),
                         "alarm() with negative argument");
        SETERRNO(EINVAL, LIB_INVARG);
        RETPUSHUNDEF;
    }
    else {
        unsigned int retval = alarm(anum);
        if ((int)retval < 0) /* Strictly speaking "cannot happen". */
            RETPUSHUNDEF;
        PUSHu(retval);
        RETURN;
    }
d4558 1
a4558 1
    dSP; dTARGET;
d4568 1
a4568 10
        if (duration < 0) {
          /* diag_listed_as: %s() with negative argument */
          Perl_ck_warner_d(aTHX_ packWARN(WARN_MISC),
                           "sleep() with negative argument");
          SETERRNO(EINVAL, LIB_INVARG);
          XPUSHi(0);
          RETURN;
        } else {
          PerlProc_sleep((unsigned int)duration);
        }
a4577 2
/* also used for: pp_msgrcv() pp_msgsnd() pp_semop() pp_shmread() */

d4581 1
a4581 1
    dSP; dMARK; dTARGET;
a4609 2
/* also used for: pp_msgget() pp_shmget() */

d4613 1
a4613 1
    dSP; dMARK; dTARGET;
a4624 2
/* also used for: pp_msgctl() pp_shmctl() */

d4628 1
a4628 1
    dSP; dMARK; dTARGET;
d4632 1
a4632 1
	RETPUSHUNDEF;
d4654 1
a4654 1
    if (*array) {
a4669 2
/* also used for: pp_ghbyaddr() pp_ghbyname() */

d4673 1
a4673 1
    dSP;
d4724 1
a4724 1
    if (GIMME_V != G_ARRAY) {
a4759 2
/* also used for: pp_gnbyaddr() pp_gnbyname() */

d4763 1
a4763 1
    dSP;
d4809 1
a4809 1
    if (GIMME_V != G_ARRAY) {
a4832 3

/* also used for: pp_gpbyname() pp_gpbynumber() */

d4836 1
a4836 1
    dSP;
d4870 1
a4870 1
    if (GIMME_V != G_ARRAY) {
a4892 3

/* also used for: pp_gsbyname() pp_gsbyport() */

d4896 1
a4896 1
    dSP;
d4933 1
a4933 1
    if (GIMME_V != G_ARRAY) {
a4957 3

/* also used for: pp_snetent() pp_sprotoent() pp_sservent() */

d4960 1
a4960 1
    dSP;
a4994 4

/* also used for: pp_egrent() pp_enetent() pp_eprotoent() pp_epwent()
 *                pp_eservent() pp_sgrent() pp_spwent() */

d4997 1
a4997 1
    dSP;
a5059 3

/* also used for: pp_gpwnam() pp_gpwuid() */

d5063 1
a5063 1
    dSP;
d5159 1
a5159 1
    if (GIMME_V != G_ARRAY) {
a5274 3

/* also used for: pp_ggrgid() pp_ggrnam() */

d5278 1
a5278 1
    dSP;
a5286 3
#if Gid_t_sign == 1
	const Gid_t gid = POPu;
#elif Gid_t_sign == -1
a5287 3
#else
#  error "Unexpected Gid_t_sign"
#endif
d5298 1
a5298 1
    if (GIMME_V != G_ARRAY) {
d5344 1
a5344 1
    dSP; dTARGET;
d5362 1
a5362 1
    dSP; dMARK; dORIGMARK; dTARGET;
d5553 6
@


