head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.6
	OPENBSD_6_2_BASE:1.15
	PERL_5_24_2:1.1.1.9
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.10
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.12
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.13.0.4
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.13.0.8
	OPENBSD_5_6_BASE:1.13
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.9.0.16
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.14
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.15
date	2017.02.05.00.32.21;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	cxJ08BvJA9Pt2PTM;

1.14
date	2016.07.25.10.53.04;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	FHUgABTHZQuYQh2B;

1.13
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches
	1.13.10.1
	1.13.12.1;
next	1.12;

1.12
date	2010.09.24.15.07.10;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.20;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.41;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.10.32;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.50;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.38;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.41;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.42;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.06.01;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.24;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.24;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.56;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.33;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.08.09.17.48.38;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.18.22;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.19.03;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.09.39;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2017.08.14.13.46.25;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;

1.13.10.1
date	2016.08.05.01.01.40;	author afresh1;	state Exp;
branches;
next	;
commitid	HjAJx2yjL4A8HWon;

1.13.12.1
date	2016.08.05.01.00.56;	author afresh1;	state Exp;
branches;
next	;
commitid	wK3bUiy9jNch0Key;


desc
@@


1.15
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!/usr/local/bin/perl

use Config;
use File::Basename qw(&basename &dirname);
use Cwd;
use subs qw(link);

sub link { # This is a cut-down version of installperl:link().
    my($from,$to) = @@_;
    my($success) = 0;

    eval {
	CORE::link($from, $to)
	    ? $success++
	    : ($from =~ m#^/afs/# || $to =~ m#^/afs/#)
	      ? die "AFS"  # okay inside eval {}
	      : die "Couldn't link $from to $to: $!\n";
    };
    if ($@@) {
	warn $@@;
	require File::Copy;
	File::Copy::copy($from, $to)
	    ? $success++
	    : warn "Couldn't copy $from to $to: $!\n";
    }
    $success;
}

# List explicitly here the variables you want Configure to
# generate.  Metaconfig only looks for shell variables, so you
# have to mention them as if they were shell variables, not
# %Config entries.  Thus you write
#  $startperl
# to ensure Configure will look for $Config{startperl}.

# This forces PL files to create target in same directory as PL file.
# This is so that make depend always knows where to find PL derivatives.
$origdir = cwd;
chdir dirname($0);
$file = basename($0, '.PL');
$file .= '.com' if $^O eq 'VMS';

open OUT,">$file" or die "Can't create $file: $!";

print "Extracting $file (with variable substitutions)\n";

# In this section, perl variables will be expanded during extraction.
# You can use $Config{...} to use Configure variables.

print OUT <<"!GROK!THIS!";
$Config{startperl}
    eval 'exec $Config{perlpath} -S \$0 \${1+"\$@@"}'
	if \$running_under_some_shell;
!GROK!THIS!

# In the following, perl variables are not expanded during extraction.

print OUT <<'!NO!SUBS!';
#
#
#   c2ph (aka pstruct)
#   Tom Christiansen, <tchrist@@convex.com>
#
#   As pstruct, dump C structures as generated from 'cc -g -S' stabs.
#   As c2ph, do this PLUS generate perl code for getting at the structures.
#
#   See the usage message for more.  If this isn't enough, read the code.
#

=head1 NAME

c2ph, pstruct - Dump C structures as generated from C<cc -g -S> stabs

=head1 SYNOPSIS

    c2ph [-dpnP] [var=val] [files ...]

=head2 OPTIONS

    Options:

    -w	wide; short for: type_width=45 member_width=35 offset_width=8
    -x	hex; short for:  offset_fmt=x offset_width=08 size_fmt=x       \
                                                           size_width=04

    -n	do not generate perl code  (default when invoked as pstruct)
    -p	generate perl code         (default when invoked as c2ph)
    -v	generate perl code, with C decls as comments

    -i	do NOT recompute sizes for intrinsic datatypes
    -a	dump information on intrinsics also

    -t	trace execution
    -d	spew reams of debugging output

    -slist  give comma-separated list a structures to dump

=head1 DESCRIPTION

The following is the old c2ph.doc documentation by Tom Christiansen
<tchrist@@perl.com>
Date: 25 Jul 91 08:10:21 GMT

Once upon a time, I wrote a program called pstruct.  It was a perl
program that tried to parse out C structures and display their member
offsets for you.  This was especially useful for people looking at
binary dumps or poking around the kernel.

Pstruct was not a pretty program.  Neither was it particularly robust.
The problem, you see, was that the C compiler was much better at parsing
C than I could ever hope to be.

So I got smart:  I decided to be lazy and let the C compiler parse the C,
which would spit out debugger stabs for me to read.  These were much
easier to parse.  It's still not a pretty program, but at least it's more
robust.

Pstruct takes any .c or .h files, or preferably .s ones, since that's
the format it is going to massage them into anyway, and spits out
listings like this:

 struct tty {
   int                          tty.t_locker                  000      4
   int                          tty.t_mutex_index             004      4
   struct tty *                 tty.t_tp_virt                 008      4
   struct clist                 tty.t_rawq                    00c     20
     int                        tty.t_rawq.c_cc               00c      4
     int                        tty.t_rawq.c_cmax             010      4
     int                        tty.t_rawq.c_cfx              014      4
     int                        tty.t_rawq.c_clx              018      4
     struct tty *               tty.t_rawq.c_tp_cpu           01c      4
     struct tty *               tty.t_rawq.c_tp_iop           020      4
     unsigned char *            tty.t_rawq.c_buf_cpu          024      4
     unsigned char *            tty.t_rawq.c_buf_iop          028      4
   struct clist                 tty.t_canq                    02c     20
     int                        tty.t_canq.c_cc               02c      4
     int                        tty.t_canq.c_cmax             030      4
     int                        tty.t_canq.c_cfx              034      4
     int                        tty.t_canq.c_clx              038      4
     struct tty *               tty.t_canq.c_tp_cpu           03c      4
     struct tty *               tty.t_canq.c_tp_iop           040      4
     unsigned char *            tty.t_canq.c_buf_cpu          044      4
     unsigned char *            tty.t_canq.c_buf_iop          048      4
   struct clist                 tty.t_outq                    04c     20
     int                        tty.t_outq.c_cc               04c      4
     int                        tty.t_outq.c_cmax             050      4
     int                        tty.t_outq.c_cfx              054      4
     int                        tty.t_outq.c_clx              058      4
     struct tty *               tty.t_outq.c_tp_cpu           05c      4
     struct tty *               tty.t_outq.c_tp_iop           060      4
     unsigned char *            tty.t_outq.c_buf_cpu          064      4
     unsigned char *            tty.t_outq.c_buf_iop          068      4
   (*int)()                     tty.t_oproc_cpu               06c      4
   (*int)()                     tty.t_oproc_iop               070      4
   (*int)()                     tty.t_stopproc_cpu            074      4
   (*int)()                     tty.t_stopproc_iop            078      4
   struct thread *              tty.t_rsel                    07c      4

etc.


Actually, this was generated by a particular set of options.  You can control
the formatting of each column, whether you prefer wide or fat, hex or decimal,
leading zeroes or whatever.

All you need to be able to use this is a C compiler than generates
BSD/GCC-style stabs.  The B<-g> option on native BSD compilers and GCC
should get this for you.

To learn more, just type a bogus option, like B<-\?>, and a long usage message
will be provided.  There are a fair number of possibilities.

If you're only a C programmer, than this is the end of the message for you.
You can quit right now, and if you care to, save off the source and run it
when you feel like it.  Or not.



But if you're a perl programmer, then for you I have something much more
wondrous than just a structure offset printer.

You see, if you call pstruct by its other incybernation, c2ph, you have a code
generator that translates C code into perl code!  Well, structure and union
declarations at least, but that's quite a bit.

Prior to this point, anyone programming in perl who wanted to interact
with C programs, like the kernel, was forced to guess the layouts of
the C structures, and then hardwire these into his program.  Of course,
when you took your wonderfully crafted program to a system where the
sgtty structure was laid out differently, your program broke.  Which is
a shame.

We've had Larry's h2ph translator, which helped, but that only works on
cpp symbols, not real C, which was also very much needed.  What I offer
you is a symbolic way of getting at all the C structures.  I've couched
them in terms of packages and functions.  Consider the following program:

    #!/usr/local/bin/perl

    require 'syscall.ph';
    require 'sys/time.ph';
    require 'sys/resource.ph';

    $ru = "\0" x &rusage'sizeof();

    syscall(&SYS_getrusage, &RUSAGE_SELF, $ru)   && die "getrusage: $!";

    @@ru = unpack($t = &rusage'typedef(), $ru);

    $utime =  $ru[ &rusage'ru_utime + &timeval'tv_sec  ]
	   + ($ru[ &rusage'ru_utime + &timeval'tv_usec ]) / 1e6;

    $stime =  $ru[ &rusage'ru_stime + &timeval'tv_sec  ]
	   + ($ru[ &rusage'ru_stime + &timeval'tv_usec ]) / 1e6;

    printf "you have used %8.3fs+%8.3fu seconds.\n", $utime, $stime;


As you see, the name of the package is the name of the structure.  Regular
fields are just their own names.  Plus the following accessor functions are
provided for your convenience:

 struct      This takes no arguments, and is merely the number of first-
             level elements in the structure.  You would use this for
             indexing into arrays of structures, perhaps like this

                 $usec = $u[ &user'u_utimer
                             + (&ITIMER_VIRTUAL * &itimerval'struct)
                             + &itimerval'it_value
                             + &timeval'tv_usec
                           ];

 sizeof      Returns the bytes in the structure, or the member if
             you pass it an argument, such as

                 &rusage'sizeof(&rusage'ru_utime)

 typedef     This is the perl format definition for passing to pack and
             unpack.  If you ask for the typedef of a nothing, you get
             the whole structure, otherwise you get that of the member
             you ask for.  Padding is taken care of, as is the magic to
             guarantee that a union is unpacked into all its aliases.
             Bitfields are not quite yet supported however.

 offsetof    This function is the byte offset into the array of that
             member.  You may wish to use this for indexing directly
             into the packed structure with vec() if you're too lazy
             to unpack it.

 typeof      Not to be confused with the typedef accessor function, this
             one returns the C type of that field.  This would allow
             you to print out a nice structured pretty print of some
             structure without knoning anything about it beforehand.
             No args to this one is a noop.  Someday I'll post such
             a thing to dump out your u structure for you.


The way I see this being used is like basically this:

        % h2ph <some_include_file.h  >  /usr/lib/perl/tmp.ph
        % c2ph  some_include_file.h  >> /usr/lib/perl/tmp.ph
        % install

It's a little tricker with c2ph because you have to get the includes right.
I can't know this for your system, but it's not usually too terribly difficult.

The code isn't pretty as I mentioned  -- I never thought it would be a 1000-
line program when I started, or I might not have begun. :-)  But I would have
been less cavalier in how the parts of the program communicated with each
other, etc.  It might also have helped if I didn't have to divine the makeup
of the stabs on the fly, and then account for micro differences between my
compiler and gcc.

Anyway, here it is.  Should run on perl v4 or greater.  Maybe less.


 --tom

=cut

$RCSID = '$Id: c2ph,v 1.7 95/10/28 10:41:47 tchrist Exp Locker: tchrist $';

BEGIN { pop @@INC if $INC[-1] eq '.' }
use File::Temp;

######################################################################

# some handy data definitions.   many of these can be reset later.

$bitorder = 'b';  # ascending; set to B for descending bit fields

%intrinsics =
%template = (
    'char', 			'c',
    'unsigned char', 		'C',
    'short',			's',
    'short int',		's',
    'unsigned short',		'S',
    'unsigned short int',	'S',
    'short unsigned int',	'S',
    'int',			'i',
    'unsigned int',		'I',
    'long',			'l',
    'long int',			'l',
    'unsigned long',		'L',
    'unsigned long',		'L',
    'long unsigned int',	'L',
    'unsigned long int',	'L',
    'long long',		'q',
    'long long int',		'q',
    'unsigned long long',	'Q',
    'unsigned long long int',	'Q',
    'float',			'f',
    'double',			'd',
    'pointer',			'p',
    'null',			'x',
    'neganull',			'X',
    'bit',			$bitorder,
);

&buildscrunchlist;
delete $intrinsics{'neganull'};
delete $intrinsics{'bit'};
delete $intrinsics{'null'};

# use -s to recompute sizes
%sizeof = (
    'char', 			'1',
    'unsigned char', 		'1',
    'short',			'2',
    'short int',		'2',
    'unsigned short',		'2',
    'unsigned short int',	'2',
    'short unsigned int',	'2',
    'int',			'4',
    'unsigned int',		'4',
    'long',			'4',
    'long int',			'4',
    'unsigned long',		'4',
    'unsigned long int',	'4',
    'long unsigned int',	'4',
    'long long',		'8',
    'long long int',		'8',
    'unsigned long long',	'8',
    'unsigned long long int',	'8',
    'float',			'4',
    'double',			'8',
    'pointer',			'4',
);

($type_width, $member_width, $offset_width, $size_width) = (20, 20, 6, 5);

($offset_fmt, $size_fmt) = ('d', 'd');

$indent = 2;

$CC = 'cc';
!NO!SUBS!

if (($Config{gccversion} || '') =~ /^(\d+)\.(\d+)/
  and ($1 > 3 or ($1 == 3 and $2 >= 2))) {
    print OUT q/$CFLAGS = '-gstabs -S';/;
} else {
    print OUT q/$CFLAGS = '-g -S';/;
}

print OUT <<'!NO!SUBS!';

$DEFINES = '';

$perl++ if $0 =~ m#/?c2ph$#;

use Getopt::Std qw(getopts);

use File::Temp 'tempdir';

eval '$'.$1.'$2;' while $ARGV[0] =~ /^([A-Za-z_]+=)(.*)/ && shift;

getopts('aixdpvtnws:') || &usage(0);

$opt_d && $debug++;
$opt_t && $trace++;
$opt_p && $perl++;
$opt_v && $verbose++;
$opt_n && ($perl = 0);

if ($opt_w) {
    ($type_width, $member_width, $offset_width) = (45, 35, 8);
}
if ($opt_x) {
    ($offset_fmt, $offset_width, $size_fmt, $size_width) = ( 'x', '08', 'x', 04 );
}

eval '$'.$1.'$2;' while $ARGV[0] =~ /^([A-Za-z_]+=)(.*)/ && shift;

sub PLUMBER {
    select(STDERR);
    print "oops, apparent pager foulup\n";
    $isatty++;
    &usage(1);
}

sub usage {
    local($oops) = @@_;
    unless (-t STDOUT) {
	select(STDERR);
    } elsif (!$oops) {
	$isatty++;
	$| = 1;
	print "hit <RETURN> for further explanation: ";
	<STDIN>;
	open (PIPE, "|". ($ENV{PAGER} || 'more'));
	$SIG{PIPE} = PLUMBER;
	select(PIPE);
    }

    print "usage: $0 [-dpnP] [var=val] [files ...]\n";

    exit unless $isatty;

    print <<EOF;

Options:

-w	wide; short for: type_width=45 member_width=35 offset_width=8
-x	hex; short for:  offset_fmt=x offset_width=08 size_fmt=x size_width=04

-n  	do not generate perl code  (default when invoked as pstruct)
-p  	generate perl code         (default when invoked as c2ph)
-v	generate perl code, with C decls as comments

-i	do NOT recompute sizes for intrinsic datatypes
-a	dump information on intrinsics also

-t 	trace execution
-d	spew reams of debugging output

-slist  give comma-separated list a structures to dump


Var Name        Default Value    Meaning

EOF

    &defvar('CC', 'which_compiler to call');
    &defvar('CFLAGS', 'how to generate *.s files with stabs');
    &defvar('DEFINES','any extra cflags or cpp defines, like -I, -D, -U');

    print "\n";

    &defvar('type_width', 'width of type field   (column 1)');
    &defvar('member_width', 'width of member field (column 2)');
    &defvar('offset_width', 'width of offset field (column 3)');
    &defvar('size_width', 'width of size field   (column 4)');

    print "\n";

    &defvar('offset_fmt', 'sprintf format type for offset');
    &defvar('size_fmt', 'sprintf format type for size');

    print "\n";

    &defvar('indent', 'how far to indent each nesting level');

   print <<'EOF';

    If any *.[ch] files are given, these will be catted together into
    a temporary *.c file and sent through:
	    $CC $CFLAGS $DEFINES
    and the resulting *.s groped for stab information.  If no files are
    supplied, then stdin is read directly with the assumption that it
    contains stab information.  All other lines will be ignored.  At
    most one *.s file should be supplied.

EOF
    close PIPE;
    exit 1;
}

sub defvar {
    local($var, $msg) = @@_;
    printf "%-16s%-15s  %s\n", $var, eval "\$$var", $msg;
}

sub safedir {
    $SAFEDIR = File::Temp::tempdir("c2ph.XXXXXX", TMPDIR => 1, CLEANUP => 1)
      unless (defined($SAFEDIR));
}

undef $SAFEDIR;

$recurse = 1;

if (@@ARGV) {
    if (grep(!/\.[csh]$/,@@ARGV)) {
	warn "Only *.[csh] files expected!\n";
	&usage;
    }
    elsif (grep(/\.s$/,@@ARGV)) {
	if (@@ARGV > 1) {
	    warn "Only one *.s file allowed!\n";
	    &usage;
	}
    }
    elsif (@@ARGV == 1 && $ARGV[0] =~ /\.c$/) {
	local($dir, $file) = $ARGV[0] =~ m#(.*/)?(.*)$#;
	$chdir = "cd $dir && " if $dir;
	&system("$chdir$CC $CFLAGS $DEFINES $file") && exit 1;
	$ARGV[0] =~ s/\.c$/.s/;
    }
    else {
	&safedir;
	$TMP = "$SAFEDIR/c2ph.$$.c";
	&system("cat @@ARGV > $TMP") && exit 1;
	&system("cd $SAFEDIR && $CC $CFLAGS $DEFINES $TMP") && exit 1;
	unlink $TMP;
	$TMP =~ s/\.c$/.s/;
	@@ARGV = ($TMP);
    }
}

if ($opt_s) {
    for (split(/[\s,]+/, $opt_s)) {
	$interested{$_}++;
    }
}


$| = 1 if $debug;

main: {

    if ($trace) {
	if (-t && !@@ARGV) {
	    print STDERR "reading from your keyboard: ";
	} else {
	    print STDERR "reading from " . (@@ARGV ? "@@ARGV" : "<STDIN>").": ";
	}
    }

STAB: while (<>) {
	if ($trace && !($. % 10)) {
	    $lineno = $..'';
	    print STDERR $lineno, "\b" x length($lineno);
	}
	next unless /^\s*\.stabs\s+/;
	$line = $_;
	s/^\s*\.stabs\s+//;
	if (s/\\\\"[d,]+$//) {
	    $saveline .= $line;
	    $savebar  = $_;
	    next STAB;
	}
	if ($saveline) {
	    s/^"//;
	    $_ = $savebar . $_;
	    $line = $saveline;
	}
	&stab;
	$savebar = $saveline = undef;
    }
    print STDERR "$.\n" if $trace;
    unlink $TMP if $TMP;

    &compute_intrinsics if $perl && !$opt_i;

    print STDERR "resolving types\n" if $trace;

    &resolve_types;
    &adjust_start_addrs;

    $sum = 2 + $type_width + $member_width;
    $pmask1 = "%-${type_width}s %-${member_width}s";
    $pmask2 = "%-${sum}s %${offset_width}${offset_fmt}%s %${size_width}${size_fmt}%s";



    if ($perl) {
	# resolve template -- should be in stab define order, but even this isn't enough.
	print STDERR "\nbuilding type templates: " if $trace;
	for $i (reverse 0..$#type) {
	    next unless defined($name = $type[$i]);
	    next unless defined $struct{$name};
	    ($iname = $name) =~ s/\..*//;
	    $build_recursed = 0;
	    &build_template($name) unless defined $template{&psou($name)} ||
					$opt_s && !$interested{$iname};
	}
	print STDERR "\n\n" if $trace;
    }

    print STDERR "dumping structs: " if $trace;

    local($iam);



    foreach $name (sort keys %struct) {
	($iname = $name) =~ s/\..*//;
	next if $opt_s && !$interested{$iname};
	print STDERR "$name " if $trace;

	undef @@sizeof;
	undef @@typedef;
	undef @@offsetof;
	undef @@indices;
	undef @@typeof;
	undef @@fieldnames;

	$mname = &munge($name);

	$fname = &psou($name);

	print "# " if $perl && $verbose;
	$pcode = '';
	print "$fname {\n" if !$perl || $verbose;
	$template{$fname} = &scrunch($template{$fname}) if $perl;
	&pstruct($name,$name,0);
	print "# " if $perl && $verbose;
	print "}\n" if !$perl || $verbose;
	print "\n" if $perl && $verbose;

	if ($perl) {
	    print "$pcode";

	    printf("\nsub %-32s { %4d; }\n\n", "${mname}'struct", $countof{$name});

	    print <<EOF;
sub ${mname}'typedef {
    local(\$${mname}'index) = shift;
    defined \$${mname}'index
	? \$${mname}'typedef[\$${mname}'index]
	: \$${mname}'typedef;
}
EOF

	    print <<EOF;
sub ${mname}'sizeof {
    local(\$${mname}'index) = shift;
    defined \$${mname}'index
	? \$${mname}'sizeof[\$${mname}'index]
	: \$${mname}'sizeof;
}
EOF

	    print <<EOF;
sub ${mname}'offsetof {
    local(\$${mname}'index) = shift;
    defined \$${mname}index
	? \$${mname}'offsetof[\$${mname}'index]
	: \$${mname}'sizeof;
}
EOF

	    print <<EOF;
sub ${mname}'typeof {
    local(\$${mname}'index) = shift;
    defined \$${mname}index
	? \$${mname}'typeof[\$${mname}'index]
	: '$name';
}
EOF

	    print <<EOF;
sub ${mname}'fieldnames {
    \@@${mname}'fieldnames;
}
EOF

	$iam = ($isastruct{$name} && 's') || ($isaunion{$name} && 'u');

	    print <<EOF;
sub ${mname}'isastruct {
    '$iam';
}
EOF

	    print "\$${mname}'typedef = '" . &scrunch($template{$fname})
		. "';\n";

	    print "\$${mname}'sizeof = $sizeof{$name};\n\n";


	    print "\@@${mname}'indices = (", &squishseq(@@indices), ");\n";

	    print "\n";

	    print "\@@${mname}'typedef[\@@${mname}'indices] = (",
			join("\n\t", '', @@typedef), "\n    );\n\n";
	    print "\@@${mname}'sizeof[\@@${mname}'indices] = (",
			join("\n\t", '', @@sizeof), "\n    );\n\n";
	    print "\@@${mname}'offsetof[\@@${mname}'indices] = (",
			join("\n\t", '', @@offsetof), "\n    );\n\n";
	    print "\@@${mname}'typeof[\@@${mname}'indices] = (",
			join("\n\t", '', @@typeof), "\n    );\n\n";
	    print "\@@${mname}'fieldnames[\@@${mname}'indices] = (",
			join("\n\t", '', @@fieldnames), "\n    );\n\n";

	    $template_printed{$fname}++;
	    $size_printed{$fname}++;
	}
	print "\n";
    }

    print STDERR "\n" if $trace;

    unless ($perl && $opt_a) {
	print "\n1;\n" if $perl;
	exit;
    }



    foreach $name (sort bysizevalue keys %intrinsics) {
	next if $size_printed{$name};
	print '$',&munge($name),"'sizeof = ", $sizeof{$name}, ";\n";
    }

    print "\n";

    sub bysizevalue { $sizeof{$a} <=> $sizeof{$b}; }


    foreach $name (sort keys %intrinsics) {
	print '$',&munge($name),"'typedef = '", $template{$name}, "';\n";
    }

    print "\n1;\n" if $perl;

    exit;
}

########################################################################################


sub stab {
    next unless $continued || /:[\$\w]+(\(\d+,\d+\))?=[\*\$\w]+/;  # (\d+,\d+) is for sun
    s/"// 						|| next;
    s/",([x\d]+),([x\d]+),([x\d]+),.*// 		|| next;

    next if /^\s*$/;

    $size = $3 if $3;
    $_ = $continued . $_ if length($continued);
    if (s/\\\\$//) {
      # if last 2 chars of string are '\\' then stab is continued
      # in next stab entry
      chop;
      $continued = $_;
      next;
    }
    $continued = '';


    $line = $_;

    if (($name, $pdecl) = /^([\$ \w]+):[tT]((\d+)(=[rufs*](\d+))+)$/) {
	print "$name is a typedef for some funky pointers: $pdecl\n" if $debug;
	&pdecl($pdecl);
	next;
    }



    if (/(([ \w]+):t(\d+|\(\d+,\d+\)))=r?(\d+|\(\d+,\d+\))(;\d+;\d+;)?/) {
	local($ident) = $2;
	push(@@intrinsics, $ident);
	$typeno = &typeno($3);
	$type[$typeno] = $ident;
	print STDERR "intrinsic $ident in new type $typeno\n" if $debug;
	next;
    }

    if (($name, $typeordef, $typeno, $extra, $struct, $_)
	= /^([\$ \w]+):([ustT])(\d+|\(\d+,\d+\))(=[rufs*](\d+))?(.*)$/)
    {
	$typeno = &typeno($typeno);  # sun foolery
    }
    elsif (/^[\$\w]+:/) {
	next; # variable
    }
    else {
	warn "can't grok stab: <$_> in: $line " if $_;
	next;
    }

    #warn "got size $size for $name\n";
    $sizeof{$name} = $size if $size;

    s/;[-\d]*;[-\d]*;$//;  # we don't care about ranges

    $typenos{$name} = $typeno;

    unless (defined $type[$typeno]) {
	&panic("type 0??") unless $typeno;
	$type[$typeno] = $name unless defined $type[$typeno];
	printf "new type $typeno is $name" if $debug;
	if ($extra =~ /\*/ && defined $type[$struct]) {
	    print ", a typedef for a pointer to " , $type[$struct] if $debug;
	}
    } else {
	printf "%s is type %d", $name, $typeno if $debug;
	print ", a typedef for " , $type[$typeno] if $debug;
    }
    print "\n" if $debug;
    #next unless $extra =~ /[su*]/;

    #$type[$struct] = $name;

    if ($extra =~ /[us*]/) {
	&sou($name, $extra);
	$_ = &sdecl($name, $_, 0);
    }
    elsif (/^=ar/) {
	print "it's a bare array typedef -- that's pretty sick\n" if $debug;
	$_ = "$typeno$_";
	$scripts = '';
	$_ = &adecl($_,1);

    }
    elsif (s/((\w+):t(\d+|\(\d+,\d+\)))?=r?(;\d+;\d+;)?//) {  # the ?'s are for gcc
	push(@@intrinsics, $2);
	$typeno = &typeno($3);
	$type[$typeno] = $2;
	print STDERR "intrinsic $2 in new type $typeno\n" if $debug;
    }
    elsif (s/^=e//) { # blessed be thy compiler; mine won't do this
	&edecl;
    }
    else {
	warn "Funny remainder for $name on line $_ left in $line " if $_;
    }
}

sub typeno {  # sun thinks types are (0,27) instead of just 27
    local($_) = @@_;
    s/\(\d+,(\d+)\)/$1/;
    $_;
}

sub pstruct {
    local($what,$prefix,$base) = @@_;
    local($field, $fieldname, $typeno, $count, $offset, $entry);
    local($fieldtype);
    local($type, $tname);
    local($mytype, $mycount, $entry2);
    local($struct_count) = 0;
    local($pad, $revpad, $length, $prepad, $lastoffset, $lastlength, $fmt);
    local($bits,$bytes);
    local($template);


    local($mname) = &munge($name);

    sub munge {
	local($_) = @@_;
	s/[\s\$\.]/_/g;
	$_;
    }

    local($sname) = &psou($what);

    $nesting++;

    for $field (split(/;/, $struct{$what})) {
	$pad = $prepad = 0;
	$entry = '';
	($fieldname, $typeno, $count, $offset, $length) = split(/,/, $field);

	$type = $type[$typeno];

	$type =~ /([^[]*)(\[.*\])?/;
	$mytype = $1;
	$count .= $2;
	$fieldtype = &psou($mytype);

	local($fname) = &psou($name);

	if ($build_templates) {

	    $pad = ($offset - ($lastoffset + $lastlength))/8
		if defined $lastoffset;

	    if (! $finished_template{$sname}) {
		if ($isaunion{$what}) {
		    $template{$sname} .= 'X' x $revpad . ' '    if $revpad;
		} else {
		    $template{$sname} .= 'x' x $pad    . ' '    if $pad;
		}
	    }

	    $template = &fetch_template($type);
	    &repeat_template($template,$count);

	    if (! $finished_template{$sname}) {
		$template{$sname} .= $template;
	    }

	    $revpad = $length/8 if $isaunion{$what};

	    ($lastoffset, $lastlength) = ($offset, $length);

	} else {
	    print '# ' if $perl && $verbose;
	    $entry = sprintf($pmask1,
			' ' x ($nesting * $indent) . $fieldtype,
			"$prefix.$fieldname" . $count);

	    $entry =~ s/(\*+)( )/$2$1/;

	    printf $pmask2,
		    $entry,
		    ($base+$offset)/8,
		    ($bits = ($base+$offset)%8) ? ".$bits" : "  ",
		    $length/8,
		    ($bits = $length % 8) ? ".$bits": ""
			if !$perl || $verbose;

	    if ($perl) {
		$template = &fetch_template($type);
		&repeat_template($template,$count);
	    }

	    if ($perl && $nesting == 1) {

		push(@@sizeof, int($length/8) .",\t# $fieldname");
		push(@@offsetof, int($offset/8) .",\t# $fieldname");
		local($little) = &scrunch($template);
		push(@@typedef, "'$little', \t# $fieldname");
		$type =~ s/(struct|union) //;
		push(@@typeof, "'$mytype" . ($count ? $count : '') .
		    "',\t# $fieldname");
		push(@@fieldnames, "'$fieldname',");
	    }

	    print '  ', ' ' x $indent x $nesting, $template
				if $perl && $verbose;

	    print "\n" if !$perl || $verbose;

	}
	if ($perl) {
	    local($mycount) = defined $struct{$mytype} ? $countof{$mytype} : 1;
	    $mycount *= &scripts2count($count) if $count;
	    if ($nesting==1 && !$build_templates) {
		$pcode .= sprintf("sub %-32s { %4d; }\n",
			"${mname}'${fieldname}", $struct_count);
		push(@@indices, $struct_count);
	    }
	    $struct_count += $mycount;
	}


	&pstruct($type, "$prefix.$fieldname", $base+$offset)
		if $recurse && defined $struct{$type};
    }

    $countof{$what} = $struct_count unless defined $countof{$whati};

    $template{$sname} .= '$' if $build_templates;
    $finished_template{$sname}++;

    if ($build_templates && !defined $sizeof{$name}) {
	local($fmt) = &scrunch($template{$sname});
	print STDERR "no size for $name, punting with $fmt..." if $debug;
	eval '$sizeof{$name} = length(pack($fmt, ()))';
	if ($@@) {
	    chop $@@;
	    warn "couldn't get size for \$name: $@@";
	} else {
	    print STDERR $sizeof{$name}, "\n" if $debUg;
	}
    }

    --$nesting;
}


sub psize {
    local($me) = @@_;
    local($amstruct) = $struct{$me} ?  'struct ' : '';

    print '$sizeof{\'', $amstruct, $me, '\'} = ';
    printf "%d;\n", $sizeof{$me};
}

sub pdecl {
    local($pdecl) = @@_;
    local(@@pdecls);
    local($tname);

    warn "pdecl: $pdecl\n" if $debug;

    $pdecl =~ s/\(\d+,(\d+)\)/$1/g;
    $pdecl =~ s/\*//g;
    @@pdecls = split(/=/, $pdecl);
    $typeno = $pdecls[0];
    $tname = pop @@pdecls;

    if ($tname =~ s/^f//) { $tname = "$tname&"; }
    #else { $tname = "$tname*"; }

    for (reverse @@pdecls) {
	$tname  .= s/^f// ? "&" : "*";
	#$tname =~ s/^f(.*)/$1&/;
	print "type[$_] is $tname\n" if $debug;
	$type[$_] = $tname unless defined $type[$_];
    }
}



sub adecl {
    ($arraytype, $unknown, $lower, $upper) = ();
    #local($typeno);
    # global $typeno, @@type
    local($_, $typedef) = @@_;

    while (s/^((\d+|\(\d+,\d+\))=)?ar(\d+|\(\d+,\d+\));//) {
	($arraytype, $unknown) = ($2, $3);
	$arraytype = &typeno($arraytype);
	$unknown = &typeno($unknown);
	if (s/^(\d+);(\d+);//) {
	    ($lower, $upper) = ($1, $2);
	    $scripts .= '[' .  ($upper+1) . ']';
	} else {
	    warn "can't find array bounds: $_";
	}
    }
    if (s/^([(,)\d*f=]*),(\d+),(\d+);//) {
	($start, $length) = ($2, $3);
	$whatis = $1;
	if ($whatis =~ /^(\d+|\(\d+,\d+\))=/) {
	    $typeno = &typeno($1);
	    &pdecl($whatis);
	} else {
	    $typeno = &typeno($whatis);
	}
    } elsif (s/^(\d+)(=[*suf]\d*)//) {
	local($whatis) = $2;

	if ($whatis =~ /[f*]/) {
	    &pdecl($whatis);
	} elsif ($whatis =~ /[su]/) {  #
	    print "$prefix.$fieldname is an array$scripts anon structs; disgusting\n"
		if $debug;
	    #$type[$typeno] = $name unless defined $type[$typeno];
	    ##printf "new type $typeno is $name" if $debug;
	    $typeno = $1;
	    $type[$typeno] = "$prefix.$fieldname";
	    local($name) = $type[$typeno];
	    &sou($name, $whatis);
	    $_ = &sdecl($name, $_, $start+$offset);
	    1;
	    $start = $start{$name};
	    $offset = $sizeof{$name};
	    $length = $offset;
	} else {
	    warn "what's this? $whatis in $line ";
	}
    } elsif (/^\d+$/) {
	$typeno = $_;
    } else {
	warn "bad array stab: $_ in $line ";
	next STAB;
    }
    #local($wasdef) = defined($type[$typeno]) && $debug;
    #if ($typedef) {
	#print "redefining $type[$typeno] to " if $wasdef;
	#$type[$typeno] = "$whatis$scripts"; # unless defined $type[$typeno];
	#print "$type[$typeno]\n" if $wasdef;
    #} else {
	#$type[$arraytype] = $type[$typeno] unless defined $type[$arraytype];
    #}
    $type[$arraytype] = "$type[$typeno]$scripts" if defined $type[$typeno];
    print "type[$arraytype] is $type[$arraytype]\n" if $debug;
    print "$prefix.$fieldname is an array of $type[$arraytype]\n" if $debug;
    $_;
}



sub sdecl {
    local($prefix, $_, $offset) = @@_;

    local($fieldname, $scripts, $type, $arraytype, $unknown,
    $whatis, $pdecl, $upper,$lower, $start,$length) = ();
    local($typeno,$sou);


SFIELD:
    while (/^([^;]+);/) {
	$scripts = '';
	warn "sdecl $_\n" if $debug;
	if (s/^([\$\w]+)://) {
	    $fieldname = $1;
	} elsif (s/(\d+)=([us])(\d+|\(\d+,\d+\))//) { #
	    $typeno = &typeno($1);
	    $type[$typeno] = "$prefix.$fieldname";
	    local($name) = "$prefix.$fieldname";
	    &sou($name,$2);
	    $_ = &sdecl("$prefix.$fieldname", $_, $start+$offset);
	    $start = $start{$name};
	    $offset += $sizeof{$name};
	    #print "done with anon, start is $start, offset is $offset\n";
	    #next SFIELD;
	} else  {
	    warn "weird field $_ of $line" if $debug;
	    next STAB;
	    #$fieldname = &gensym;
	    #$_ = &sdecl("$prefix.$fieldname", $_, $start+$offset);
	}

	if (/^(\d+|\(\d+,\d+\))=ar/) {
	    $_ = &adecl($_);
	}
	elsif (s/^(\d+|\(\d+,\d+\))?,(\d+),(\d+);//) {
          ($start, $length) =  ($2, $3);
          &panic("no length?") unless $length;
          $typeno = &typeno($1) if $1;
        }
        elsif (s/^(\d+)=xs\w+:,(\d+),(\d+);//) {
	    ($start, $length) =  ($2, $3);
	    &panic("no length?") unless $length;
	    $typeno = &typeno($1) if $1;
	}
	elsif (s/^((\d+|\(\d+,\d+\))(=[*f](\d+|\(\d+,\d+\)))+),(\d+),(\d+);//) {
	    ($pdecl, $start, $length) =  ($1,$5,$6);
	    &pdecl($pdecl);
	}
	elsif (s/(\d+)=([us])(\d+|\(\d+,\d+\))//) { # the dratted anon struct
	    ($typeno, $sou) = ($1, $2);
	    $typeno = &typeno($typeno);
	    if (defined($type[$typeno])) {
		warn "now how did we get type $1 in $fieldname of $line?";
	    } else {
		print "anon type $typeno is $prefix.$fieldname\n" if $debug;
		$type[$typeno] = "$prefix.$fieldname" unless defined $type[$typeno];
	    };
	    local($name) = "$prefix.$fieldname";
	    &sou($name,$sou);
	    print "anon ".($isastruct{$name}) ? "struct":"union"." for $prefix.$fieldname\n" if $debug;
	    $type[$typeno] = "$prefix.$fieldname";
	    $_ = &sdecl("$prefix.$fieldname", $_, $start+$offset);
	    $start = $start{$name};
	    $length = $sizeof{$name};
	}
	else {
	    warn "can't grok stab for $name ($_) in line $line ";
	    next STAB;
	}

	&panic("no length for $prefix.$fieldname") unless $length;
	$struct{$name} .= join(',', $fieldname, $typeno, $scripts, $start, $length) . ';';
    }
    if (s/;\d*,(\d+),(\d+);//) {
	local($start, $size) = ($1, $2);
	$sizeof{$prefix} = $size;
	print "start of $prefix is $start, size of $sizeof{$prefix}\n" if $debug;
	$start{$prefix} = $start;
    }
    $_;
}

sub edecl {
    s/;$//;
    $enum{$name} = $_;
    $_ = '';
}

sub resolve_types {
    local($sou);
    for $i (0 .. $#type) {
	next unless defined $type[$i];
	$_ = $type[$i];
	unless (/\d/) {
	    print "type[$i] $type[$i]\n" if $debug;
	    next;
	}
	print "type[$i] $_ ==> " if $debug;
	s/^(\d+)(\**)\&\*(\**)/"$2($3".&type($1) . ')()'/e;
	s/^(\d+)\&/&type($1)/e;
	s/^(\d+)/&type($1)/e;
	s/(\*+)([^*]+)(\*+)/$1$3$2/;
	s/\((\*+)(\w+)(\*+)\)/$3($1$2)/;
	s/^(\d+)([\*\[].*)/&type($1).$2/e;
	#s/(\d+)(\*|(\[[\[\]\d\*]+]\])+)/&type($1).$2/ge;
	$type[$i] = $_;
	print "$_\n" if $debug;
    }
}
sub type { &psou($type[$_[0]] || "<UNDEFINED>"); }

sub adjust_start_addrs {
    for (sort keys %start) {
	($basename = $_) =~ s/\.[^.]+$//;
	$start{$_} += $start{$basename};
	print "start: $_ @@ $start{$_}\n" if $debug;
    }
}

sub sou {
    local($what, $_) = @@_;
    /u/ && $isaunion{$what}++;
    /s/ && $isastruct{$what}++;
}

sub psou {
    local($what) = @@_;
    local($prefix) = '';
    if ($isaunion{$what})  {
	$prefix = 'union ';
    } elsif ($isastruct{$what})  {
	$prefix = 'struct ';
    }
    $prefix . $what;
}

sub scrunch {
    local($_) = @@_;

    return '' if $_ eq '';

    study;

    s/\$//g;
    s/  / /g;
    1 while s/(\w) \1/$1$1/g;

    # i wanna say this, but perl resists my efforts:
    #	   s/(\w)(\1+)/$2 . length($1)/ge;

    &quick_scrunch;

    s/ $//;

    $_;
}

sub buildscrunchlist {
    $scrunch_code = "sub quick_scrunch {\n";
    for (values %intrinsics) {
        $scrunch_code .= "\ts/(${_}{2,})/'$_' . length(\$1)/ge;\n";
    }
    $scrunch_code .= "}\n";
    print "$scrunch_code" if $debug;
    eval $scrunch_code;
    &panic("can't eval scrunch_code $@@ \nscrunch_code") if $@@;
}

sub fetch_template {
    local($mytype) = @@_;
    local($fmt);
    local($count) = 1;

    &panic("why do you care?") unless $perl;

    if ($mytype =~ s/(\[\d+\])+$//) {
	$count .= $1;
    }

    if ($mytype =~ /\*/) {
	$fmt = $template{'pointer'};
    }
    elsif (defined $template{$mytype}) {
	$fmt = $template{$mytype};
    }
    elsif (defined $struct{$mytype}) {
	if (!defined $template{&psou($mytype)}) {
	    &build_template($mytype) unless $mytype eq $name;
	}
	elsif ($template{&psou($mytype)} !~ /\$$/) {
	    #warn "incomplete template for $mytype\n";
	}
	$fmt = $template{&psou($mytype)} || '?';
    }
    else {
	warn "unknown fmt for $mytype\n";
	$fmt = '?';
    }

    $fmt x $count . ' ';
}

sub compute_intrinsics {
    &safedir;
    local($TMP) = "$SAFEDIR/c2ph-i.$$.c";
    open (TMP, ">$TMP") || die "can't open $TMP: $!";
    select(TMP);

    print STDERR "computing intrinsic sizes: " if $trace;

    undef %intrinsics;

    print <<'EOF';
main() {
    char *mask = "%d %s\n";
EOF

    for $type (@@intrinsics) {
	next if !$type || $type eq 'void' || $type =~ /complex/; # sun stuff
	print <<"EOF";
    printf(mask,sizeof($type), "$type");
EOF
    }

    print <<'EOF';
    printf(mask,sizeof(char *), "pointer");
    exit(0);
}
EOF
    close TMP;

    select(STDOUT);
    open(PIPE, "cd $SAFEDIR && $CC $TMP && $SAFEDIR/a.out|");
    while (<PIPE>) {
	chop;
	split(' ',$_,2);;
	print "intrinsic $_[1] is size $_[0]\n" if $debug;
	$sizeof{$_[1]} = $_[0];
	$intrinsics{$_[1]} = $template{$_[0]};
    }
    close(PIPE) || die "couldn't read intrinsics!";
    unlink($TMP, "$SAFEDIR/a.out");
    print STDERR "done\n" if $trace;
}

sub scripts2count {
    local($_) = @@_;

    s/^\[//;
    s/\]$//;
    s/\]\[/*/g;
    $_ = eval;
    &panic("$_: $@@") if $@@;
    $_;
}

sub system {
    print STDERR "@@_\n" if $trace;
    system @@_;
}

sub build_template {
    local($name) = @@_;

    &panic("already got a template for $name") if defined $template{$name};

    local($build_templates) = 1;

    local($lparen) = '(' x $build_recursed;
    local($rparen) = ')' x $build_recursed;

    print STDERR "$lparen$name$rparen " if $trace;
    $build_recursed++;
    &pstruct($name,$name,0);
    print STDERR "TEMPLATE for $name is ", $template{&psou($name)}, "\n" if $debug;
    --$build_recursed;
}


sub panic {

    select(STDERR);

    print "\npanic: @@_\n";

    exit 1 if $] <= 4.003;  # caller broken

    local($i,$_);
    local($p,$f,$l,$s,$h,$a,@@a,@@sub);
    for ($i = 0; ($p,$f,$l,$s,$h,$w) = caller($i); $i++) {
	@@a = @@DB'args;
	for (@@a) {
	    if (/^StB\000/ && length($_) == length($_main{'_main'})) {
		$_ = sprintf("%s",$_);
	    }
	    else {
		s/'/\\'/g;
		s/([^\0]*)/'$1'/ unless /^-?[\d.]+$/;
		s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;
		s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
	    }
	}
	$w = $w ? '@@ = ' : '$ = ';
	$a = $h ? '(' . join(', ', @@a) . ')' : '';
	push(@@sub, "$w&$s$a from file $f line $l\n");
	last if $signal;
    }
    for ($i=0; $i <= $#sub; $i++) {
	last if $signal;
	print $sub[$i];
    }
    exit 1;
}

sub squishseq {
    local($num);
    local($last) = -1e8;
    local($string);
    local($seq) = '..';

    while (defined($num = shift)) {
        if ($num == ($last + 1)) {
            $string .= $seq unless $inseq++;
            $last = $num;
            next;
        } elsif ($inseq) {
            $string .= $last unless $last == -1e8;
        }

        $string .= ',' if defined $string;
        $string .= $num;
        $last = $num;
        $inseq = 0;
    }
    $string .= $last if $inseq && $last != -e18;
    $string;
}

sub repeat_template {
    #  local($template, $scripts) = @@_;  have to change caller's values

    if ( $_[1] ) {
	local($ncount) = &scripts2count($_[1]);
	if ($_[0] =~ /^\s*c\s*$/i) {
	    $_[0] = "A$ncount ";
	    $_[1] = '';
	} else {
	    $_[0] = $template x $ncount;
	}
    }
}
!NO!SUBS!

close OUT or die "Can't close $file: $!";
chmod 0755, $file or die "Can't reset permissions for $file: $!\n";
unlink 'pstruct';
print "Linking $file to pstruct.\n";
if (defined $Config{d_link}) {
    link $file, 'pstruct';
} else {
  unshift @@INC, '../lib';
  require File::Copy;
  File::Copy::syscopy('c2ph', 'pstruct');
}
exec("$Config{'eunicefix'} $file") if $Config{'eunicefix'} ne ':';
chdir $origdir;
@


1.14
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.


ok deraadt@@
@
text
@d83 2
a84 1
    -x	hex; short for:  offset_fmt=x offset_width=08 size_fmt=x size_width=04
d123 35
a157 35
   int                          tty.t_locker                         000      4
   int                          tty.t_mutex_index                    004      4
   struct tty *                 tty.t_tp_virt                        008      4
   struct clist                 tty.t_rawq                           00c     20
     int                        tty.t_rawq.c_cc                      00c      4
     int                        tty.t_rawq.c_cmax                    010      4
     int                        tty.t_rawq.c_cfx                     014      4
     int                        tty.t_rawq.c_clx                     018      4
     struct tty *               tty.t_rawq.c_tp_cpu                  01c      4
     struct tty *               tty.t_rawq.c_tp_iop                  020      4
     unsigned char *            tty.t_rawq.c_buf_cpu                 024      4
     unsigned char *            tty.t_rawq.c_buf_iop                 028      4
   struct clist                 tty.t_canq                           02c     20
     int                        tty.t_canq.c_cc                      02c      4
     int                        tty.t_canq.c_cmax                    030      4
     int                        tty.t_canq.c_cfx                     034      4
     int                        tty.t_canq.c_clx                     038      4
     struct tty *               tty.t_canq.c_tp_cpu                  03c      4
     struct tty *               tty.t_canq.c_tp_iop                  040      4
     unsigned char *            tty.t_canq.c_buf_cpu                 044      4
     unsigned char *            tty.t_canq.c_buf_iop                 048      4
   struct clist                 tty.t_outq                           04c     20
     int                        tty.t_outq.c_cc                      04c      4
     int                        tty.t_outq.c_cmax                    050      4
     int                        tty.t_outq.c_cfx                     054      4
     int                        tty.t_outq.c_clx                     058      4
     struct tty *               tty.t_outq.c_tp_cpu                  05c      4
     struct tty *               tty.t_outq.c_tp_iop                  060      4
     unsigned char *            tty.t_outq.c_buf_cpu                 064      4
     unsigned char *            tty.t_outq.c_buf_iop                 068      4
   (*int)()                     tty.t_oproc_cpu                      06c      4
   (*int)()                     tty.t_oproc_iop                      070      4
   (*int)()                     tty.t_stopproc_cpu                   074      4
   (*int)()                     tty.t_stopproc_iop                   078      4
   struct thread *              tty.t_rsel                           07c      4
d206 1
a206 1
    syscall(&SYS_getrusage, &RUSAGE_SELF, $ru)      && die "getrusage: $!";
d223 33
a255 34
    struct	This takes no arguments, and is merely the number of first-level
		elements in the structure.  You would use this for indexing
		into arrays of structures, perhaps like this


		    $usec = $u[ &user'u_utimer
				+ (&ITIMER_VIRTUAL * &itimerval'struct)
				+ &itimerval'it_value
				+ &timeval'tv_usec
			      ];

    sizeof   	Returns the bytes in the structure, or the member if
	     	you pass it an argument, such as

			&rusage'sizeof(&rusage'ru_utime)

    typedef  	This is the perl format definition for passing to pack and
	     	unpack.  If you ask for the typedef of a nothing, you get
	     	the whole structure, otherwise you get that of the member
	     	you ask for.  Padding is taken care of, as is the magic to
	     	guarantee that a union is unpacked into all its aliases.
	     	Bitfields are not quite yet supported however.

    offsetof	This function is the byte offset into the array of that
		member.  You may wish to use this for indexing directly
		into the packed structure with vec() if you're too lazy
		to unpack it.

    typeof	Not to be confused with the typedef accessor function, this
		one returns the C type of that field.  This would allow
		you to print out a nice structured pretty print of some
		structure without knoning anything about it beforehand.
		No args to this one is a noop.  Someday I'll post such
		a thing to dump out your u structure for you.
d260 3
a262 3
	% h2ph <some_include_file.h  >  /usr/lib/perl/tmp.ph
	% c2ph  some_include_file.h  >> /usr/lib/perl/tmp.ph
	% install
@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d283 1
@


1.13.10.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@a282 1
BEGIN { pop @@INC if $INC[-1] eq '.' }
@


1.13.12.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@a282 1
BEGIN { pop @@INC if $INC[-1] eq '.' }
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@d372 1
a372 1
require 'getopts.pl';
d378 1
a378 1
&Getopts('aixdpvtnws:') || &usage(0);
d397 1
a397 1
    print "oops, apperent pager foulup\n";
@


1.11
log
@Merge in perl 5.10.1; part two
@
text
@@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d281 1
a281 1
$RCSID = '$Id: c2ph.PL,v 1.8 2004/08/09 18:10:32 millert Exp $';
d1323 1
a1323 1
    unlink($TMP, '$SAFEDIR/a.out');
d1438 1
a1438 1
print "Linking c2ph to pstruct.\n";
d1440 1
a1440 1
  link 'c2ph', 'pstruct';
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d281 1
a281 1
$RCSID = '$Id: c2ph.PL,v 1.7 2003/12/03 03:02:50 millert Exp $';
d471 1
a471 1
    contains stab information.  All other liens will be ignored.  At
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d281 1
a281 1
$RCSID = '$Id: c2ph,v 1.7 95/10/28 10:41:47 tchrist Exp Locker: tchrist $';
d283 1
d484 7
d506 1
a506 1
	$chdir = "cd $dir; " if $dir;
d511 2
a512 2
	$TMPDIR = tempdir(CLEANUP => 1);
	$TMP = "$TMPDIR/c2ph.$$.c";
d514 1
a514 1
	&system("cd $TMPDIR; $CC $CFLAGS $DEFINES $TMP") && exit 1;
d1285 2
a1286 2
    $TMPDIR ||= tempdir(CLEANUP => 1);
    local($TMP) = "$TMPDIR/c2ph-i.$$.c";
d1314 1
a1314 1
    open(PIPE, "cd $TMPDIR && $CC $TMP && $TMPDIR/a.out|");
d1323 1
a1323 1
    unlink($TMP, '$TMPDIR/a.out');
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d187 1
a187 1
the C strutures, and then hardwire these into his program.  Of course,
d189 1
a189 1
sgtty structure was laid out differently, you program broke.  Which is
d356 11
a366 1
$CFLAGS = '-g -S';
d373 2
d503 2
a504 1
	$TMP = "/tmp/c2ph.$$.c";
d506 1
a506 1
	&system("cd /tmp; $CC $CFLAGS $DEFINES $TMP") && exit 1;
d1277 2
a1278 1
    local($TMP) = "/tmp/c2ph-i.$$.c";
d1306 1
a1306 1
    open(PIPE, "cd /tmp && $CC $TMP && /tmp/a.out|");
d1315 1
a1315 1
    unlink($TMP, '/tmp/a.out');
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d6 22
@


1.4
log
@perl-5.6.0 + local changes
@
text
@@


1.3
log
@perl5.005_03 (stock)
@
text
@@


1.2
log
@perl 5.004_04
@
text
@d5 1
d16 1
d1403 1
@


1.1
log
@Initial revision
@
text
@d15 3
a17 4
chdir(dirname($0));
($file = basename($0)) =~ s/\.PL$//;
$file =~ s/\.pl$//
	if ($^O eq 'VMS' or $^O eq 'os2');  # "case-forgiving"
d27 3
a29 3
$Config{'startperl'}
    eval 'exec perl -S \$0 "\$@@"'
	if 0;
d48 1
a48 1
c2ph,pstruct - Dump C structures as generated from 'cc -g -S' stabs
d97 36
a132 36
struct tty {
  int                          tty.t_locker                         000      4
  int                          tty.t_mutex_index                    004      4
  struct tty *                 tty.t_tp_virt                        008      4
  struct clist                 tty.t_rawq                           00c     20
    int                        tty.t_rawq.c_cc                      00c      4
    int                        tty.t_rawq.c_cmax                    010      4
    int                        tty.t_rawq.c_cfx                     014      4
    int                        tty.t_rawq.c_clx                     018      4
    struct tty *               tty.t_rawq.c_tp_cpu                  01c      4
    struct tty *               tty.t_rawq.c_tp_iop                  020      4
    unsigned char *            tty.t_rawq.c_buf_cpu                 024      4
    unsigned char *            tty.t_rawq.c_buf_iop                 028      4
  struct clist                 tty.t_canq                           02c     20
    int                        tty.t_canq.c_cc                      02c      4
    int                        tty.t_canq.c_cmax                    030      4
    int                        tty.t_canq.c_cfx                     034      4
    int                        tty.t_canq.c_clx                     038      4
    struct tty *               tty.t_canq.c_tp_cpu                  03c      4
    struct tty *               tty.t_canq.c_tp_iop                  040      4
    unsigned char *            tty.t_canq.c_buf_cpu                 044      4
    unsigned char *            tty.t_canq.c_buf_iop                 048      4
  struct clist                 tty.t_outq                           04c     20
    int                        tty.t_outq.c_cc                      04c      4
    int                        tty.t_outq.c_cmax                    050      4
    int                        tty.t_outq.c_cfx                     054      4
    int                        tty.t_outq.c_clx                     058      4
    struct tty *               tty.t_outq.c_tp_cpu                  05c      4
    struct tty *               tty.t_outq.c_tp_iop                  060      4
    unsigned char *            tty.t_outq.c_buf_cpu                 064      4
    unsigned char *            tty.t_outq.c_buf_iop                 068      4
  (*int)()                     tty.t_oproc_cpu                      06c      4
  (*int)()                     tty.t_oproc_iop                      070      4
  (*int)()                     tty.t_stopproc_cpu                   074      4
  (*int)()                     tty.t_stopproc_iop                   078      4
  struct thread *              tty.t_rsel                           07c      4
d134 1
a134 1
  etc.
d142 1
a142 1
BSD/GCC-style stabs.  The -g option on native BSD compilers and GCC
d145 1
a145 1
To learn more, just type a bogus option, like -\?, and a long usage message
d195 1
a195 1
fields are just their own names.  Plus the follwoing  accessor functions are
d253 1
a253 1
--tom
d1254 1
a1254 1
	next if !type || $type eq 'void' || $type =~ /complex/; # sun stuff
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a4 1
use Cwd;
d15 4
a18 4
$origdir = cwd;
chdir dirname($0);
$file = basename($0, '.PL');
$file .= '.com' if $^O eq 'VMS';
d28 3
a30 3
$Config{startperl}
    eval 'exec $Config{perlpath} -S \$0 \${1+"\$@@"}'
	if \$running_under_some_shell;
d49 1
a49 1
c2ph, pstruct - Dump C structures as generated from C<cc -g -S> stabs
d98 36
a133 36
 struct tty {
   int                          tty.t_locker                         000      4
   int                          tty.t_mutex_index                    004      4
   struct tty *                 tty.t_tp_virt                        008      4
   struct clist                 tty.t_rawq                           00c     20
     int                        tty.t_rawq.c_cc                      00c      4
     int                        tty.t_rawq.c_cmax                    010      4
     int                        tty.t_rawq.c_cfx                     014      4
     int                        tty.t_rawq.c_clx                     018      4
     struct tty *               tty.t_rawq.c_tp_cpu                  01c      4
     struct tty *               tty.t_rawq.c_tp_iop                  020      4
     unsigned char *            tty.t_rawq.c_buf_cpu                 024      4
     unsigned char *            tty.t_rawq.c_buf_iop                 028      4
   struct clist                 tty.t_canq                           02c     20
     int                        tty.t_canq.c_cc                      02c      4
     int                        tty.t_canq.c_cmax                    030      4
     int                        tty.t_canq.c_cfx                     034      4
     int                        tty.t_canq.c_clx                     038      4
     struct tty *               tty.t_canq.c_tp_cpu                  03c      4
     struct tty *               tty.t_canq.c_tp_iop                  040      4
     unsigned char *            tty.t_canq.c_buf_cpu                 044      4
     unsigned char *            tty.t_canq.c_buf_iop                 048      4
   struct clist                 tty.t_outq                           04c     20
     int                        tty.t_outq.c_cc                      04c      4
     int                        tty.t_outq.c_cmax                    050      4
     int                        tty.t_outq.c_cfx                     054      4
     int                        tty.t_outq.c_clx                     058      4
     struct tty *               tty.t_outq.c_tp_cpu                  05c      4
     struct tty *               tty.t_outq.c_tp_iop                  060      4
     unsigned char *            tty.t_outq.c_buf_cpu                 064      4
     unsigned char *            tty.t_outq.c_buf_iop                 068      4
   (*int)()                     tty.t_oproc_cpu                      06c      4
   (*int)()                     tty.t_oproc_iop                      070      4
   (*int)()                     tty.t_stopproc_cpu                   074      4
   (*int)()                     tty.t_stopproc_iop                   078      4
   struct thread *              tty.t_rsel                           07c      4
d135 1
a135 1
etc.
d143 1
a143 1
BSD/GCC-style stabs.  The B<-g> option on native BSD compilers and GCC
d146 1
a146 1
To learn more, just type a bogus option, like B<-\?>, and a long usage message
d196 1
a196 1
fields are just their own names.  Plus the following accessor functions are
d254 1
a254 1
 --tom
d1255 1
a1255 1
	next if !$type || $type eq 'void' || $type =~ /complex/; # sun stuff
a1401 1
chdir $origdir;
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@a5 22
use subs qw(link);

sub link { # This is a cut-down version of installperl:link().
    my($from,$to) = @@_;
    my($success) = 0;

    eval {
	CORE::link($from, $to)
	    ? $success++
	    : ($from =~ m#^/afs/# || $to =~ m#^/afs/#)
	      ? die "AFS"  # okay inside eval {}
	      : die "Couldn't link $from to $to: $!\n";
    };
    if ($@@) {
	warn $@@;
	require File::Copy;
	File::Copy::copy($from, $to)
	    ? $success++
	    : warn "Couldn't copy $from to $to: $!\n";
    }
    $success;
}
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d187 1
a187 1
the C structures, and then hardwire these into his program.  Of course,
d189 1
a189 1
sgtty structure was laid out differently, your program broke.  Which is
d356 1
a356 11
!NO!SUBS!

if (($Config{gccversion} || '') =~ /^(\d+)\.(\d+)/
  and ($1 > 3 or ($1 == 3 and $2 >= 2))) {
    print OUT q/$CFLAGS = '-gstabs -S';/;
} else {
    print OUT q/$CFLAGS = '-g -S';/;
}

print OUT <<'!NO!SUBS!';

a362 2
use File::Temp 'tempdir';

d491 1
a491 2
	$TMPDIR = tempdir(CLEANUP => 1);
	$TMP = "$TMPDIR/c2ph.$$.c";
d493 1
a493 1
	&system("cd $TMPDIR; $CC $CFLAGS $DEFINES $TMP") && exit 1;
d1264 1
a1264 2
    $TMPDIR ||= tempdir(CLEANUP => 1);
    local($TMP) = "$TMPDIR/c2ph-i.$$.c";
d1292 1
a1292 1
    open(PIPE, "cd $TMPDIR && $CC $TMP && $TMPDIR/a.out|");
d1301 1
a1301 1
    unlink($TMP, '$TMPDIR/a.out');
@


1.1.1.5
log
@Import of stock perl 5.8.5
@
text
@d281 1
a281 1
$RCSID = '$Id: c2ph.PL,v 1.7 2003/12/03 03:02:50 millert Exp $';
a282 1
use File::Temp;
a482 7
sub safedir {
    $SAFEDIR = File::Temp::tempdir("c2ph.XXXXXX", TMPDIR => 1, CLEANUP => 1)
      unless (defined($SAFEDIR));
}

undef $SAFEDIR;

d498 1
a498 1
	$chdir = "cd $dir && " if $dir;
d503 2
a504 2
	&safedir;
	$TMP = "$SAFEDIR/c2ph.$$.c";
d506 1
a506 1
	&system("cd $SAFEDIR && $CC $CFLAGS $DEFINES $TMP") && exit 1;
d1277 2
a1278 2
    &safedir;
    local($TMP) = "$SAFEDIR/c2ph-i.$$.c";
d1306 1
a1306 1
    open(PIPE, "cd $SAFEDIR && $CC $TMP && $SAFEDIR/a.out|");
d1315 1
a1315 1
    unlink($TMP, '$SAFEDIR/a.out');
@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@d281 1
a281 1
$RCSID = '$Id: c2ph,v 1.7 95/10/28 10:41:47 tchrist Exp Locker: tchrist $';
d471 1
a471 1
    contains stab information.  All other lines will be ignored.  At
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d1323 1
a1323 1
    unlink($TMP, "$SAFEDIR/a.out");
d1438 1
a1438 1
print "Linking $file to pstruct.\n";
d1440 1
a1440 1
    link $file, 'pstruct';
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d372 1
a372 1
use Getopt::Std qw(getopts);
d378 1
a378 1
getopts('aixdpvtnws:') || &usage(0);
d397 1
a397 1
    print "oops, apparent pager foulup\n";
@


1.1.1.9
log
@Import perl-5.24.2
@
text
@d83 1
a83 2
    -x	hex; short for:  offset_fmt=x offset_width=08 size_fmt=x       \
                                                           size_width=04
d122 35
a156 35
   int                          tty.t_locker                  000      4
   int                          tty.t_mutex_index             004      4
   struct tty *                 tty.t_tp_virt                 008      4
   struct clist                 tty.t_rawq                    00c     20
     int                        tty.t_rawq.c_cc               00c      4
     int                        tty.t_rawq.c_cmax             010      4
     int                        tty.t_rawq.c_cfx              014      4
     int                        tty.t_rawq.c_clx              018      4
     struct tty *               tty.t_rawq.c_tp_cpu           01c      4
     struct tty *               tty.t_rawq.c_tp_iop           020      4
     unsigned char *            tty.t_rawq.c_buf_cpu          024      4
     unsigned char *            tty.t_rawq.c_buf_iop          028      4
   struct clist                 tty.t_canq                    02c     20
     int                        tty.t_canq.c_cc               02c      4
     int                        tty.t_canq.c_cmax             030      4
     int                        tty.t_canq.c_cfx              034      4
     int                        tty.t_canq.c_clx              038      4
     struct tty *               tty.t_canq.c_tp_cpu           03c      4
     struct tty *               tty.t_canq.c_tp_iop           040      4
     unsigned char *            tty.t_canq.c_buf_cpu          044      4
     unsigned char *            tty.t_canq.c_buf_iop          048      4
   struct clist                 tty.t_outq                    04c     20
     int                        tty.t_outq.c_cc               04c      4
     int                        tty.t_outq.c_cmax             050      4
     int                        tty.t_outq.c_cfx              054      4
     int                        tty.t_outq.c_clx              058      4
     struct tty *               tty.t_outq.c_tp_cpu           05c      4
     struct tty *               tty.t_outq.c_tp_iop           060      4
     unsigned char *            tty.t_outq.c_buf_cpu          064      4
     unsigned char *            tty.t_outq.c_buf_iop          068      4
   (*int)()                     tty.t_oproc_cpu               06c      4
   (*int)()                     tty.t_oproc_iop               070      4
   (*int)()                     tty.t_stopproc_cpu            074      4
   (*int)()                     tty.t_stopproc_iop            078      4
   struct thread *              tty.t_rsel                    07c      4
d205 1
a205 1
    syscall(&SYS_getrusage, &RUSAGE_SELF, $ru)   && die "getrusage: $!";
d222 34
a255 33
 struct      This takes no arguments, and is merely the number of first-
             level elements in the structure.  You would use this for
             indexing into arrays of structures, perhaps like this

                 $usec = $u[ &user'u_utimer
                             + (&ITIMER_VIRTUAL * &itimerval'struct)
                             + &itimerval'it_value
                             + &timeval'tv_usec
                           ];

 sizeof      Returns the bytes in the structure, or the member if
             you pass it an argument, such as

                 &rusage'sizeof(&rusage'ru_utime)

 typedef     This is the perl format definition for passing to pack and
             unpack.  If you ask for the typedef of a nothing, you get
             the whole structure, otherwise you get that of the member
             you ask for.  Padding is taken care of, as is the magic to
             guarantee that a union is unpacked into all its aliases.
             Bitfields are not quite yet supported however.

 offsetof    This function is the byte offset into the array of that
             member.  You may wish to use this for indexing directly
             into the packed structure with vec() if you're too lazy
             to unpack it.

 typeof      Not to be confused with the typedef accessor function, this
             one returns the C type of that field.  This would allow
             you to print out a nice structured pretty print of some
             structure without knoning anything about it beforehand.
             No args to this one is a noop.  Someday I'll post such
             a thing to dump out your u structure for you.
d260 3
a262 3
        % h2ph <some_include_file.h  >  /usr/lib/perl/tmp.ph
        % c2ph  some_include_file.h  >> /usr/lib/perl/tmp.ph
        % install
a282 1
BEGIN { pop @@INC if $INC[-1] eq '.' }
@


