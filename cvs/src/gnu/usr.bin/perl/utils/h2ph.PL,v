head	1.31;
access;
symbols
	OPENBSD_6_2_BASE:1.31
	PERL_5_24_2:1.1.1.15
	OPENBSD_6_1:1.29.0.4
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.21.0.8
	OPENBSD_5_6_BASE:1.21
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.21.0.6
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.2
	OPENBSD_5_4_BASE:1.21
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.20.0.10
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.8
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.6
	OPENBSD_5_0:1.20.0.4
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.14.0.8
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.10.0.6
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.4
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.31
date	2017.08.14.13.49.45;	author afresh1;	state Exp;
branches;
next	1.30;
commitid	AOpGtCFzbfdujI88;

1.30
date	2017.08.14.13.48.48;	author afresh1;	state Exp;
branches;
next	1.29;
commitid	CrMEpTqBUsxCMTjx;

1.29
date	2017.02.05.00.33.41;	author afresh1;	state Exp;
branches;
next	1.28;
commitid	7JLVNm1wwPgqSqTa;

1.28
date	2017.02.05.00.32.21;	author afresh1;	state Exp;
branches;
next	1.27;
commitid	cxJ08BvJA9Pt2PTM;

1.27
date	2016.07.25.10.53.04;	author afresh1;	state Exp;
branches;
next	1.26;
commitid	FHUgABTHZQuYQh2B;

1.26
date	2016.07.03.01.08.05;	author afresh1;	state Exp;
branches;
next	1.25;
commitid	GzHqjSTnBjdF7Wcw;

1.25
date	2015.04.25.19.26.23;	author afresh1;	state Exp;
branches
	1.25.2.1
	1.25.4.1;
next	1.24;
commitid	3qGYFVvfrExB70FB;

1.24
date	2015.04.25.19.14.49;	author afresh1;	state Exp;
branches;
next	1.23;
commitid	XRK22kO4se3v2i2I;

1.23
date	2014.11.17.21.01.01;	author afresh1;	state Exp;
branches;
next	1.22;
commitid	LnErp1MFKSuew5Fr;

1.22
date	2014.11.17.20.57.08;	author afresh1;	state Exp;
branches;
next	1.21;
commitid	QP75iYx42Uo7mMxO;

1.21
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.28.16.19.23;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.24.15.07.10;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.13.01.25.48;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2008.09.29.17.36.20;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.28.19.23.13;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.08.09.18.10.32;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.03.03.02.50;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.02.18.10.40;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.27.22.25.38;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.20.20.38.28;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.24.18.36.26;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.06.17.08.42;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.04.29.22.52.42;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.02.04.18.31.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.02.04.18.14.33;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.04.27.16.00.24;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.11.30.08.06.02;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.08.26.05.31.52;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.25;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.25;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.56;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.57;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.26.12;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.34;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.48.37;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.18.22;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.49.49;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.19.03;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.47;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.49.14;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.09.39;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.53.19;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	B31cAbBIXiCqnL97;

1.1.1.15
date	2017.08.14.13.46.26;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;

1.25.2.1
date	2016.08.05.01.01.40;	author afresh1;	state Exp;
branches;
next	;
commitid	HjAJx2yjL4A8HWon;

1.25.4.1
date	2016.08.05.01.00.56;	author afresh1;	state Exp;
branches;
next	;
commitid	wK3bUiy9jNch0Key;


desc
@@


1.31
log
@Apply local patches - perl-5.24.2

OK bluhm@@, Reads ok sthen@@
@
text
@#!/usr/local/bin/perl

use Config;
use File::Basename qw(basename dirname);
use Cwd;

# List explicitly here the variables you want Configure to
# generate.  Metaconfig only looks for shell variables, so you
# have to mention them as if they were shell variables, not
# %Config entries.  Thus you write
#  $startperl
# to ensure Configure will look for $Config{startperl}.
# Wanted:  $archlibexp

# This forces PL files to create target in same directory as PL file.
# This is so that make depend always knows where to find PL derivatives.
$origdir = cwd;
chdir dirname($0);
$file = basename($0, '.PL');
$file .= '.com' if $^O eq 'VMS';

open OUT,">$file" or die "Can't create $file: $!";

print "Extracting $file (with variable substitutions)\n";

# In this section, perl variables will be expanded during extraction.
# You can use $Config{...} to use Configure variables.

print OUT <<"!GROK!THIS!";
$Config{startperl}
    eval 'exec $Config{perlpath} -S \$0 \${1+"\$@@"}'
	if \$running_under_some_shell;
!GROK!THIS!

# In the following, perl variables are not expanded during extraction.

print OUT <<'!NO!SUBS!';

BEGIN { pop @@INC if $INC[-1] eq '.' }

use strict;

use Config;
use File::Path qw(mkpath);
use Getopt::Std;

# Make sure read permissions for all are set:
if (defined umask && (umask() & 0444)) {
    umask (umask() & ~0444);
}

getopts('Dd:rlhaQe');
use vars qw($opt_D $opt_d $opt_r $opt_l $opt_h $opt_a $opt_Q $opt_e);
die "-r and -a options are mutually exclusive\n" if ($opt_r and $opt_a);
my @@inc_dirs = inc_dirs() if $opt_a;

my $Exit = 0;

my $Dest_dir = $opt_d || $Config{installsitearch};
die "Destination directory $Dest_dir doesn't exist or isn't a directory\n"
    unless -d $Dest_dir;

my @@isatype = qw(
	char	uchar	u_char
	short	ushort	u_short
	int	uint	u_int
	long	ulong	u_long
	FILE	key_t	caddr_t
	float	double	size_t
);

my %isatype;
@@isatype{@@isatype} = (1) x @@isatype;
my $inif = 0;
my %Is_converted;
my %bad_file = ();

@@ARGV = ('-') unless @@ARGV;

build_preamble_if_necessary();

sub reindent($) {
    my($text) = shift;
    $text =~ s/\n/\n    /g;
    $text =~ s/        /\t/g;
    $text;
}

my ($t, $tab, %curargs, $new, $eval_index, $dir, $name, $args, $outfile);
my ($incl, $incl_type, $incl_quote, $next);
while (defined (my $file = next_file())) {
    if (-l $file and -d $file) {
        link_if_possible($file) if ($opt_l);
        next;
    }

    # Recover from header files with unbalanced cpp directives
    $t = '';
    $tab = 0;

    # $eval_index goes into '#line' directives, to help locate syntax errors:
    $eval_index = 1;

    if ($file eq '-') {
	open(IN, "-");
	open(OUT, ">-");
    } else {
	($outfile = $file) =~ s/\.h$/.ph/ || next;
	print "$file -> $outfile\n" unless $opt_Q;
	if ($file =~ m|^(.*)/|) {
	    $dir = $1;
	    mkpath "$Dest_dir/$dir";
	}

	if ($opt_a) { # automagic mode:  locate header file in @@inc_dirs
	    foreach (@@inc_dirs) {
		chdir $_;
		last if -f $file;
	    }
	}

	open(IN,"$file") || (($Exit = 1),(warn "Can't open $file: $!\n"),next);
	open(OUT,">$Dest_dir/$outfile") || die "Can't create $outfile: $!\n";
    }

    print OUT
        "require '_h2ph_pre.ph';\n\n",
        "no warnings qw(redefine misc);\n\n";

    while (defined (local $_ = next_line($file))) {
	if (s/^\s*\#\s*//) {
	    if (s/^define\s+(\w+)//) {
		$name = $1;
		$new = '';
		s/\s+$//;
		s/\(\w+\s*\(\*\)\s*\(\w*\)\)\s*(-?\d+)/$1/; # (int (*)(foo_t))0
		if (s/^\(([\w,\s]*)\)//) {
		    $args = $1;
		    my $proto = '() ';
		    if ($args ne '') {
			$proto = '';
			foreach my $arg (split(/,\s*/,$args)) {
			    $arg =~ s/^\s*([^\s].*[^\s])\s*$/$1/;
			    $curargs{$arg} = 1;
			}
			$args =~ s/\b(\w)/\$$1/g;
			$args = "my($args) = \@@_;\n$t    ";
		    }
		    s/^\s+//;
		    expr();
		    $new =~ s/(["\\])/\\$1/g;       #"]);
		    EMIT($proto);
		} else {
		    s/^\s+//;
		    expr();

		    $new = 1 if $new eq '';

		    # Shunt around such directives as '#define FOO FOO':
		    next if $new =~ /^\s*&\Q$name\E\s*\z/;

		    $new = reindent($new);
		    $args = reindent($args);
		    $new =~ s/(['\\])/\\$1/g;        #']);

	    	    print OUT $t, 'eval ';
		    if ($opt_h) {
			print OUT "\"\\n#line $eval_index $outfile\\n\" . ";
			$eval_index++;
		    }
		    print OUT "'sub $name () {$new;}' unless defined(&$name);\n";
		}
	    } elsif (/^(include|import|include_next)\s*([<\"])(.*)[>\"]/) {
                $incl_type = $1;
                $incl_quote = $2;
                $incl = $3;
                if (($incl_type eq 'include_next') ||
                    ($opt_e && exists($bad_file{$incl}))) {
                    $incl =~ s/\.h$/.ph/;
		print OUT ($t,
			   "eval {\n");
                $tab += 4;
                $t = "\t" x ($tab / 8) . ' ' x ($tab % 8);
                    print OUT ($t, "my(\@@REM);\n");
                    if ($incl_type eq 'include_next') {
		print OUT ($t,
			   "my(\%INCD) = map { \$INC{\$_} => 1 } ",
			           "(grep { \$_ eq \"$incl\" } ",
                                   "keys(\%INC));\n");
		print OUT ($t,
			           "\@@REM = map { \"\$_/$incl\" } ",
			   "(grep { not exists(\$INCD{\"\$_/$incl\"})",
			           " and -f \"\$_/$incl\" } \@@INC);\n");
                    } else {
                        print OUT ($t,
                                   "\@@REM = map { \"\$_/$incl\" } ",
                                   "(grep {-r \"\$_/$incl\" } \@@INC);\n");
                    }
		print OUT ($t,
			   "require \"\$REM[0]\" if \@@REM;\n");
                $tab -= 4;
                $t = "\t" x ($tab / 8) . ' ' x ($tab % 8);
                print OUT ($t,
			   "};\n");
		print OUT ($t,
			   "warn(\$\@@) if \$\@@;\n");
                } else {
                    $incl =~ s/\.h$/.ph/;
                    # copy the prefix in the quote syntax (#include "x.h") case
                    if ($incl !~ m|/| && $incl_quote eq q{"} && $file =~ m|^(.*)/|) {
                        $incl = "$1/$incl";
                    }
		    print OUT $t,"require '$incl';\n";
                }
	    } elsif (/^ifdef\s+(\w+)/) {
		print OUT $t,"if(defined(&$1)) {\n";
		$tab += 4;
		$t = "\t" x ($tab / 8) . ' ' x ($tab % 8);
	    } elsif (/^ifndef\s+(\w+)/) {
		print OUT $t,"unless(defined(&$1)) {\n";
		$tab += 4;
		$t = "\t" x ($tab / 8) . ' ' x ($tab % 8);
	    } elsif (s/^if\s+//) {
		$new = '';
		$inif = 1;
		expr();
		$inif = 0;
		print OUT $t,"if($new) {\n";
		$tab += 4;
		$t = "\t" x ($tab / 8) . ' ' x ($tab % 8);
	    } elsif (s/^elif\s+//) {
		$new = '';
		$inif = 1;
		expr();
		$inif = 0;
		$tab -= 4;
		$t = "\t" x ($tab / 8) . ' ' x ($tab % 8);
		print OUT $t,"}\n elsif($new) {\n";
		$tab += 4;
		$t = "\t" x ($tab / 8) . ' ' x ($tab % 8);
	    } elsif (/^else/) {
		$tab -= 4;
		$t = "\t" x ($tab / 8) . ' ' x ($tab % 8);
		print OUT $t,"} else {\n";
		$tab += 4;
		$t = "\t" x ($tab / 8) . ' ' x ($tab % 8);
	    } elsif (/^endif/) {
		$tab -= 4;
		$t = "\t" x ($tab / 8) . ' ' x ($tab % 8);
		print OUT $t,"}\n";
	    } elsif(/^undef\s+(\w+)/) {
		print OUT $t, "undef(&$1) if defined(&$1);\n";
	    } elsif(/^error\s+(".*")/) {
		print OUT $t, "die($1);\n";
	    } elsif(/^error\s+(.*)/) {
		print OUT $t, "die(\"", quotemeta($1), "\");\n";
	    } elsif(/^warning\s+(.*)/) {
		print OUT $t, "warn(\"", quotemeta($1), "\");\n";
	    } elsif(/^ident\s+(.*)/) {
		print OUT $t, "# $1\n";
	    }
	} elsif (/^\s*(typedef\s*)?enum\s*(\s+[a-zA-Z_]\w*\s*)?/) { # { for vi
	    until(/\{[^}]*\}.*;/ || /;/) {
		last unless defined ($next = next_line($file));
		chomp $next;
		# drop "#define FOO FOO" in enums
		$next =~ s/^\s*#\s*define\s+(\w+)\s+\1\s*$//;
		# #defines in enums (aliases)
		$next =~ s/^\s*#\s*define\s+(\w+)\s+(\w+)\s*$/$1 = $2,/;
		$_ .= $next;
		print OUT "# $next\n" if $opt_D;
	    }
	    s/#\s*if.*?#\s*endif//g; # drop #ifdefs
	    s@@/\*.*?\*/@@@@g;
	    s/\s+/ /g;
	    next unless /^\s?(typedef\s?)?enum\s?([a-zA-Z_]\w*)?\s?\{(.*)\}\s?([a-zA-Z_]\w*)?\s?;/;
	    (my $enum_subs = $3) =~ s/\s//g;
	    my @@enum_subs = split(/,/, $enum_subs);
	    my $enum_val = -1;
	    foreach my $enum (@@enum_subs) {
		my ($enum_name, $enum_value) = $enum =~ /^([a-zA-Z_]\w*)(=.+)?$/;
		$enum_name or next;
		$enum_value =~ s/^=//;
		$enum_val = (length($enum_value) ? $enum_value : $enum_val + 1);
		if ($opt_h) {
		    print OUT ($t,
			       "eval(\"\\n#line $eval_index $outfile\\n",
			       "sub $enum_name () \{ $enum_val; \}\") ",
			       "unless defined(\&$enum_name);\n");
		    ++ $eval_index;
		} else {
		    print OUT ($t,
			       "eval(\"sub $enum_name () \{ $enum_val; \}\") ",
			       "unless defined(\&$enum_name);\n");
		}
	    }
	} elsif (/^(?:__extension__\s+)?(?:extern|static)\s+(?:__)?inline(?:__)?\s+/
	    and !/;\s*$/ and !/{\s*}\s*$/)
	{ # { for vi
	    # This is a hack to parse the inline functions in the glibc headers.
	    # Warning: massive kludge ahead. We suppose inline functions
	    # are mainly constructed like macros.
	    while (1) {
		last unless defined ($next = next_line($file));
		chomp $next;
		undef $_, last if $next =~ /__THROW\s*;/
			       or $next =~ /^(__extension__|extern|static)\b/;
		$_ .= " $next";
		print OUT "# $next\n" if $opt_D;
		last if $next =~ /^}|^{.*}\s*$/;
	    }
	    next if not defined; # because it's only a prototype
	    s/\b(__extension__|extern|static|(?:__)?inline(?:__)?)\b//g;
	    # violently drop #ifdefs
	    s/#\s*if.*?#\s*endif//g
		and print OUT "# some #ifdef were dropped here -- fill in the blanks\n";
	    if (s/^(?:\w|\s|\*)*\s(\w+)\s*//) {
		$name = $1;
	    } else {
		warn "name not found"; next; # shouldn't occur...
	    }
	    my @@args;
	    if (s/^\(([^()]*)\)\s*(\w+\s*)*//) {
		for my $arg (split /,/, $1) {
		    if ($arg =~ /(\w+)\s*$/) {
			$curargs{$1} = 1;
			push @@args, $1;
		    }
		}
	    }
	    $args = (
		@@args
		? "my(" . (join ',', map "\$$_", @@args) . ") = \@@_;\n$t    "
		: ""
	    );
	    my $proto = @@args ? '' : '() ';
	    $new = '';
	    s/\breturn\b//g; # "return" doesn't occur in macros usually...
	    expr();
	    # try to find and perlify local C variables
	    our @@local_variables = (); # needs to be a our(): (?{...}) bug workaround
	    {
		use re "eval";
		my $typelist = join '|', keys %isatype;
		$new =~ s['
		  (?:(?:__)?const(?:__)?\s+)?
		  (?:(?:un)?signed\s+)?
		  (?:long\s+)?
		  (?:$typelist)\s+
		  (\w+)
		  (?{ push @@local_variables, $1 })
		  ']
		 [my \$$1]gx;
		$new =~ s['
		  (?:(?:__)?const(?:__)?\s+)?
		  (?:(?:un)?signed\s+)?
		  (?:long\s+)?
		  (?:$typelist)\s+
		  ' \s+ &(\w+) \s* ;
		  (?{ push @@local_variables, $1 })
		  ]
		 [my \$$1;]gx;
	     }
	    $new =~ s/&$_\b/\$$_/g for @@local_variables;
	    $new =~ s/(["\\])/\\$1/g;       #"]);
	    # now that's almost like a macro (we hope)
	    EMIT($proto);
	}
    }
    $Is_converted{$file} = 1;
    if ($opt_e && exists($bad_file{$file})) {
        unlink($Dest_dir . '/' . $outfile);
        $next = '';
    } else {
        print OUT "1;\n";
	queue_includes_from($file) if $opt_a;
    }
}

if ($opt_e && (scalar(keys %bad_file) > 0)) {
    warn "Was unable to convert the following files:\n";
    warn "\t" . join("\n\t",sort(keys %bad_file)) . "\n";
}

exit $Exit;

sub EMIT {
    my $proto = shift;

    $new = reindent($new);
    $args = reindent($args);
    if ($t ne '') {
    $new =~ s/(['\\])/\\$1/g;   #']);
    if ($opt_h) {
        print OUT $t,
                    "eval \"\\n#line $eval_index $outfile\\n\" . 'sub $name $proto\{\n$t    ${args}eval q($new);\n$t}' unless defined(\&$name);\n";
                    $eval_index++;
    } else {
        print OUT $t,
                    "eval 'sub $name $proto\{\n$t    ${args}eval q($new);\n$t}' unless defined(\&$name);\n";
    }
    } else {
              print OUT "unless(defined(\&$name)) {\n    sub $name $proto\{\n\t${args}eval q($new);\n    }\n}\n";
    }
    %curargs = ();
    return;
}

sub expr {
    if (/\b__asm__\b/) {	# freak out
	$new = '"(assembly code)"';
	return
    }
    my $joined_args;
    if(keys(%curargs)) {
	$joined_args = join('|', keys(%curargs));
    }
    while ($_ ne '') {
	s/^\&\&// && do { $new .= " &&"; next;}; # handle && operator
	s/^\&([\(a-z\)]+)/$1/i;	# hack for things that take the address of
	s/^(\s+)//		&& do {$new .= ' '; next;};
	s/^0X([0-9A-F]+)[UL]*//i
	    && do {my $hex = $1;
		   $hex =~ s/^0+//;
		   if (length $hex > 8 && !$Config{use64bitint}) {
		       # Croak if nv_preserves_uv_bits < 64 ?
		       $new .=         hex(substr($hex, -8)) +
			       2**32 * hex(substr($hex,  0, -8));
		       # The above will produce "erroneous" code
		       # if the hex constant was e.g. inside UINT64_C
		       # macro, but then again, h2ph is an approximation.
		   } else {
		       $new .= lc("0x$hex");
		   }
		   next;};
	s/^(-?\d+\.\d+E[-+]?\d+)[FL]?//i	&& do {$new .= $1; next;};
	s/^(\d+)\s*[LU]*//i	&& do {$new .= $1; next;};
	s/^("(\\"|[^"])*")//	&& do {$new .= $1; next;};
	s/^'((\\"|[^"])*)'//	&& do {
	    if ($curargs{$1}) {
		$new .= "ord('\$$1')";
	    } else {
		$new .= "ord('$1')";
	    }
	    next;
	};
        # replace "sizeof(foo)" with "{foo}"
        # also, remove * (C dereference operator) to avoid perl syntax
        # problems.  Where the %sizeof array comes from is anyone's
        # guess (c2ph?), but this at least avoids fatal syntax errors.
        # Behavior is undefined if sizeof() delimiters are unbalanced.
        # This code was modified to able to handle constructs like this:
        #   sizeof(*(p)), which appear in the HP-UX 10.01 header files.
        s/^sizeof\s*\(// && do {
            $new .= '$sizeof';
            my $lvl = 1;  # already saw one open paren
            # tack { on the front, and skip it in the loop
            $_ = "{" . "$_";
            my $index = 1;
            # find balanced closing paren
            while ($index <= length($_) && $lvl > 0) {
                $lvl++ if substr($_, $index, 1) eq "(";
                $lvl-- if substr($_, $index, 1) eq ")";
                $index++;
            }
            # tack } on the end, replacing )
            substr($_, $index - 1, 1) = "}";
            # remove pesky * operators within the sizeof argument
            substr($_, 0, $index - 1) =~ s/\*//g;
            next;
        };
	# Eliminate typedefs
	/\(([\w\s]+)[\*\s]*\)\s*[\w\(]/ && do {
	    my $doit = 1;
	    foreach (split /\s+/, $1) {  # Make sure all the words are types,
	        unless($isatype{$_} or $_ eq 'struct' or $_ eq 'union'){
		    $doit = 0;
		    last;
		}
	    }
	    if( $doit ){
		s/\([\w\s]+[\*\s]*\)// && next;      # then eliminate them.
	    }
	};
	# struct/union member, including arrays:
	s/^([_A-Z]\w*(\[[^\]]+\])?((\.|->)[_A-Z]\w*(\[[^\]]+\])?)+)//i && do {
	    my $id = $1;
	    $id =~ s/(\.|(->))([^\.\-]*)/->\{$3\}/g;
	    $id =~ s/\b([^\$])($joined_args)/$1\$$2/g if length($joined_args);
	    while($id =~ /\[\s*([^\$\&\d\]]+)\]/) {
		my($index) = $1;
		$index =~ s/\s//g;
		if(exists($curargs{$index})) {
		    $index = "\$$index";
		} else {
		    $index = "&$index";
		}
		$id =~ s/\[\s*([^\$\&\d\]]+)\]/[$index]/;
	    }
	    $new .= " (\$$id)";
	};
	s/^([_a-zA-Z]\w*)//	&& do {
	    my $id = $1;
	    if ($id eq 'struct' || $id eq 'union') {
		s/^\s+(\w+)//;
		$id .= ' ' . $1;
		$isatype{$id} = 1;
	    } elsif ($id =~ /^((un)?signed)|(long)|(short)$/) {
		while (s/^\s+(\w+)//) { $id .= ' ' . $1; }
		$isatype{$id} = 1;
	    }
	    if ($curargs{$id}) {
		$new .= "\$$id";
		$new .= '->' if /^[\[\{]/;
	    } elsif ($id eq 'defined') {
		$new .= 'defined';
	    } elsif (/^\s*\(/) {
		s/^\s*\((\w),/("$1",/ if $id =~ /^_IO[WR]*$/i;	# cheat
		$new .= " &$id";
	    } elsif ($isatype{$id}) {
		if ($new =~ /\{\s*$/) {
		    $new .= "'$id'";
		} elsif ($new =~ /\(\s*$/ && /^[\s*]*\)/) {
		    $new =~ s/\(\s*$//;
		    s/^[\s*]*\)//;
		} else {
		    $new .= q(').$id.q(');
		}
	    } else {
		if ($inif) {
		    if ($new =~ /defined\s*$/) {
			$new .= '(&' . $id . ')';
		    } elsif ($new =~ /defined\s*\($/) {
			$new .= '&' . $id;
		    } else {
			$new .= '(defined(&' . $id . ') ? &' . $id . ' : undef)';
		    }
		} elsif (/^\[/) {
		    $new .= " \$$id";
		} else {
		    $new .= ' &' . $id;
		}
	    }
	    next;
	};
	s/^(.)// && do { if ($1 ne '#') { $new .= $1; } next;};
    }
}


sub next_line
{
    my $file = shift;
    my ($in, $out);
    my $pre_sub_tri_graphs = 1;

    READ: while (not eof IN) {
        $in  .= <IN>;
        chomp $in;
        next unless length $in;

        while (length $in) {
            if ($pre_sub_tri_graphs) {
                # Preprocess all tri-graphs
                # including things stuck in quoted string constants.
                $in =~ s/\?\?=/#/g;                         # | ??=|  #|
                $in =~ s/\?\?\!/|/g;                        # | ??!|  ||
                $in =~ s/\?\?'/^/g;                         # | ??'|  ^|
                $in =~ s/\?\?\(/[/g;                        # | ??(|  [|
                $in =~ s/\?\?\)/]/g;                        # | ??)|  ]|
                $in =~ s/\?\?\-/~/g;                        # | ??-|  ~|
                $in =~ s/\?\?\//\\/g;                       # | ??/|  \|
                $in =~ s/\?\?</{/g;                         # | ??<|  {|
                $in =~ s/\?\?>/}/g;                         # | ??>|  }|
            }
	    if ($in =~ s/^\#ifdef __LANGUAGE_PASCAL__//) {
		# Tru64 disassembler.h evilness: mixed C and Pascal.
		while (<IN>) {
		    last if /^\#endif/;
		}
		$in = "";
		next READ;
	    }
	    # Skip inlined functions in headers
	    if ($in =~ s/^(extern|static) (__inline__|inline) .*[^;]\s*$//) {
		while (<IN>) {
		    last if /^}/;
		}
		$in = "";
		next READ;
	    }
            if ($in =~ s/\\$//) {                           # \-newline
                $out    .= ' ';
                next READ;
            } elsif ($in =~ s/^([^"'\\\/]+)//) {            # Passthrough
                $out    .= $1;
            } elsif ($in =~ s/^(\\.)//) {                   # \...
                $out    .= $1;
            } elsif ($in =~ /^'/) {                         # '...
                if ($in =~ s/^('(\\.|[^'\\])*')//) {
                    $out    .= $1;
                } else {
                    next READ;
                }
            } elsif ($in =~ /^"/) {                         # "...
                if ($in =~ s/^("(\\.|[^"\\])*")//) {
                    $out    .= $1;
                } else {
                    next READ;
                }
            } elsif ($in =~ s/^\/\/.*//) {                  # //...
                # fall through
            } elsif ($in =~ m/^\/\*/) {                     # /*...
                # C comment removal adapted from perlfaq6:
                if ($in =~ s/^\/\*[^*]*\*+([^\/*][^*]*\*+)*\///) {
                    $out    .= ' ';
                } else {                                    # Incomplete /* */
                    next READ;
                }
            } elsif ($in =~ s/^(\/)//) {                    # /...
                $out    .= $1;
            } elsif ($in =~ s/^([^\'\"\\\/]+)//) {
                $out    .= $1;
            } elsif ($^O eq 'linux' &&
                     $file =~ m!(?:^|/)linux/byteorder/pdp_endian\.h$! &&
                     $in   =~ s!\'T KNOW!!) {
                $out    =~ s!I DON$!I_DO_NOT_KNOW!;
            } else {
                if ($opt_e) {
                    warn "Cannot parse $file:\n$in\n";
                    $bad_file{$file} = 1;
                    $in = '';
                    $out = undef;
                    last READ;
                } else {
		die "Cannot parse:\n$in\n";
                }
            }
        }

        last READ if $out =~ /\S/;
    }

    return $out;
}


# Handle recursive subdirectories without getting a grotesquely big stack.
# Could this be implemented using File::Find?
sub next_file
{
    my $file;

    while (@@ARGV) {
        $file = shift @@ARGV;

        if ($file eq '-' or -f $file or -l $file) {
            return $file;
        } elsif (-d $file) {
            if ($opt_r) {
                expand_glob($file);
            } else {
                print STDERR "Skipping directory '$file'\n";
            }
        } elsif ($opt_a) {
            return $file;
        } else {
            print STDERR "Skipping '$file':  not a file or directory\n";
        }
    }

    return undef;
}


# Put all the files in $directory into @@ARGV for processing.
sub expand_glob
{
    my ($directory)  = @@_;

    $directory =~ s:/$::;

    opendir DIR, $directory;
        foreach (readdir DIR) {
            next if ($_ eq '.' or $_ eq '..');

            # expand_glob() is going to be called until $ARGV[0] isn't a
            # directory; so push directories, and unshift everything else.
            if (-d "$directory/$_") { push    @@ARGV, "$directory/$_" }
            else                    { unshift @@ARGV, "$directory/$_" }
        }
    closedir DIR;
}


# Given $file, a symbolic link to a directory in the C include directory,
# make an equivalent symbolic link in $Dest_dir, if we can figure out how.
# Otherwise, just duplicate the file or directory.
sub link_if_possible
{
    my ($dirlink)  = @@_;
    my $target  = eval 'readlink($dirlink)';

    if ($target =~ m:^\.\./: or $target =~ m:^/:) {
        # The target of a parent or absolute link could leave the $Dest_dir
        # hierarchy, so let's put all of the contents of $dirlink (actually,
        # the contents of $target) into @@ARGV; as a side effect down the
        # line, $dirlink will get created as an _actual_ directory.
        expand_glob($dirlink);
    } else {
        if (-l "$Dest_dir/$dirlink") {
            unlink "$Dest_dir/$dirlink" or
                print STDERR "Could not remove link $Dest_dir/$dirlink:  $!\n";
        }

        if (eval 'symlink($target, "$Dest_dir/$dirlink")') {
            print "Linking $target -> $Dest_dir/$dirlink\n";

            # Make sure that the link _links_ to something:
            if (! -e "$Dest_dir/$target") {
                mkpath("$Dest_dir/$target", 0755) or
                    print STDERR "Could not create $Dest_dir/$target/\n";
            }
        } else {
            print STDERR "Could not symlink $target -> $Dest_dir/$dirlink:  $!\n";
        }
    }
}


# Push all #included files in $file onto our stack, except for STDIN
# and files we've already processed.
sub queue_includes_from
{
    my ($file)    = @@_;
    my $line;

    return if ($file eq "-");

    open HEADER, $file or return;
        while (defined($line = <HEADER>)) {
            while (/\\$/) { # Handle continuation lines
                chop $line;
                $line .= <HEADER>;
            }

            if ($line =~ /^#\s*include\s+([<"])(.*?)[>"]/) {
                my ($delimiter, $new_file) = ($1, $2);
                # copy the prefix in the quote syntax (#include "x.h") case
                if ($delimiter eq q{"} && $file =~ m|^(.*)/|) {
                    $new_file = "$1/$new_file";
                }
                push(@@ARGV, $new_file) unless $Is_converted{$new_file};
            }
        }
    close HEADER;
}


# Determine include directories; $Config{usrinc} should be enough for (all
# non-GCC?) C compilers, but gcc uses additional include directories.
sub inc_dirs
{
    my $from_gcc   = `LC_ALL=C $Config{cc} -v -E - < /dev/null 2>&1 | awk '/^#include/, /^End of search list/' | grep '^ '`;
    length($from_gcc) ? (split(' ', $from_gcc), $Config{usrinc}) : ($Config{usrinc});
}


# Create "_h2ph_pre.ph", if it doesn't exist or was built by a different
# version of h2ph.
sub build_preamble_if_necessary
{
    # Increment $VERSION every time this function is modified:
    my $VERSION     = 4;
    my $preamble    = "$Dest_dir/_h2ph_pre.ph";

    # Can we skip building the preamble file?
    if (-r $preamble) {
        # Extract version number from first line of preamble:
        open  PREAMBLE, $preamble or die "Cannot open $preamble:  $!";
            my $line = <PREAMBLE>;
            $line =~ /(\b\d+\b)/;
        close PREAMBLE            or die "Cannot close $preamble:  $!";

        # Don't build preamble if a compatible preamble exists:
        return if $1 == $VERSION;
    }

    my (%define) = _extract_cc_defines();

    open  PREAMBLE, ">$preamble" or die "Cannot open $preamble:  $!";
	print PREAMBLE "# This file was created by h2ph version $VERSION\n";
        # Prevent non-portable hex constants from warning.
        #
        # We still produce an overflow warning if we can't represent
        # a hex constant as an integer.
        print PREAMBLE "no warnings qw(portable);\n";

	foreach (sort keys %define) {
	    if ($opt_D) {
		print PREAMBLE "# $_=$define{$_}\n";
	    }
	    if ($define{$_} =~ /^\((.*)\)$/) {
		# parenthesized value:  d=(v)
		$define{$_} = $1;
	    }
	    if (/^(\w+)\((\w)\)$/) {
		my($macro, $arg) = ($1, $2);
		my $def = $define{$_};
		$def =~ s/$arg/\$\{$arg\}/g;
		print PREAMBLE <<DEFINE;
unless (defined &$macro) { sub $macro(\$) { my (\$$arg) = \@@_; \"$def\" } }

DEFINE
	    } elsif
		($define{$_} =~ /^([+-]?(\d+)?\.\d+([eE][+-]?\d+)?)[FL]?$/) {
		# float:
		print PREAMBLE
		    "unless (defined &$_) { sub $_() { $1 } }\n\n";
	    } elsif ($define{$_} =~ /^([+-]?\d+)U?L{0,2}$/i) {
		# integer:
		print PREAMBLE
		    "unless (defined &$_) { sub $_() { $1 } }\n\n";
            } elsif ($define{$_} =~ /^([+-]?0x[\da-f]+)U?L{0,2}$/i) {
                # hex integer
                # Special cased, since perl warns on hex integers
                # that can't be represented in a UV.
                #
                # This way we get the warning at time of use, so the user
                # only gets the warning if they happen to use this
                # platform-specific definition.
                my $code = $1;
                $code = "hex('$code')" if length $code > 10;
                print PREAMBLE
                    "unless (defined &$_) { sub $_() { $code } }\n\n";
	    } elsif ($define{$_} =~ /^\w+$/) {
		my $def = $define{$_};
		if ($isatype{$def}) {
		  print PREAMBLE
		    "unless (defined &$_) { sub $_() { \"$def\" } }\n\n";
		} else {
		  print PREAMBLE
		    "unless (defined &$_) { sub $_() { &$def } }\n\n";
	        }
	    } else {
		print PREAMBLE
		    "unless (defined &$_) { sub $_() { \"",
		    quotemeta($define{$_}), "\" } }\n\n";
	    }
	}
	print PREAMBLE "\n1;\n";  # avoid 'did not return a true value' when empty
    close PREAMBLE               or die "Cannot close $preamble:  $!";
}


# %Config contains information on macros that are pre-defined by the
# system's compiler.  We need this information to make the .ph files
# function with perl as the .h files do with cc.
sub _extract_cc_defines
{
    my %define;
    my $allsymbols  = join " ",
	@@Config{'ccsymbols', 'cppsymbols', 'cppccsymbols'};

    # Split compiler pre-definitions into 'key=value' pairs:
    while ($allsymbols =~ /([^\s]+)=((\\\s|[^\s])+)/g) {
	$define{$1} = $2;
	if ($opt_D) {
	    print STDERR "$_:  $1 -> $2\n";
	}
    }

    return %define;
}


1;

##############################################################################
__END__

=head1 NAME

h2ph - convert .h C header files to .ph Perl header files

=head1 SYNOPSIS

B<h2ph [-d destination directory] [-r | -a] [-l] [-h] [-e] [-D] [-Q]
[headerfiles]>

=head1 DESCRIPTION

I<h2ph>
converts any C header files specified to the corresponding Perl header file
format.
It is most easily run while in /usr/include:

	cd /usr/include; h2ph * sys/*

or

	cd /usr/include; h2ph * sys/* arpa/* netinet/*

or

	cd /usr/include; h2ph -r -l .

The output files are placed in the hierarchy rooted at Perl's
architecture dependent library directory.  You can specify a different
hierarchy with a B<-d> switch.

If run with no arguments, filters standard input to standard output.

=head1 OPTIONS

=over 4

=item -d destination_dir

Put the resulting B<.ph> files beneath B<destination_dir>, instead of
beneath the default Perl library location (C<$Config{'installsitearch'}>).

=item -r

Run recursively; if any of B<headerfiles> are directories, then run I<h2ph>
on all files in those directories (and their subdirectories, etc.).  B<-r>
and B<-a> are mutually exclusive.

=item -a

Run automagically; convert B<headerfiles>, as well as any B<.h> files
which they include.  This option will search for B<.h> files in all
directories which your C compiler ordinarily uses.  B<-a> and B<-r> are
mutually exclusive.

=item -l

Symbolic links will be replicated in the destination directory.  If B<-l>
is not specified, then links are skipped over.

=item -h

Put 'hints' in the .ph files which will help in locating problems with
I<h2ph>.  In those cases when you B<require> a B<.ph> file containing syntax
errors, instead of the cryptic

	[ some error condition ] at (eval mmm) line nnn

you will see the slightly more helpful

	[ some error condition ] at filename.ph line nnn

However, the B<.ph> files almost double in size when built using B<-h>.

=item -e

If an error is encountered during conversion, output file will be removed and
a warning emitted instead of terminating the conversion immediately.

=item -D

Include the code from the B<.h> file as a comment in the B<.ph> file.
This is primarily used for debugging I<h2ph>.

=item -Q

'Quiet' mode; don't print out the names of the files being converted.

=back

=head1 ENVIRONMENT

No environment variables are used.

=head1 FILES

 /usr/include/*.h
 /usr/include/sys/*.h

etc.

=head1 AUTHOR

Larry Wall

=head1 SEE ALSO

perl(1)

=head1 DIAGNOSTICS

The usual warnings if it can't read or write the files involved.

=head1 BUGS

Doesn't construct the %sizeof array for you.

It doesn't handle all C constructs, but it does attempt to isolate
definitions inside evals so that you can get at the definitions
that it can translate.

It's only intended as a rough tool.
You may need to dicker with the files produced.

You have to run this program by hand; it's not run as part of the Perl
installation.

Doesn't handle complicated expressions built piecemeal, a la:

    enum {
	FIRST_VALUE,
	SECOND_VALUE,
    #ifdef ABC
	THIRD_VALUE
    #endif
    };

Doesn't necessarily locate all of your C compiler's internally-defined
symbols.

=cut

!NO!SUBS!

close OUT or die "Can't close $file: $!";
chmod 0755, $file or die "Can't reset permissions for $file: $!\n";
exec("$Config{'eunicefix'} $file") if $Config{'eunicefix'} ne ':';
chdir $origdir;
@


1.30
log
@Fix merge issues, remove excess files - match perl-5.24.2 dist

OK bluhm@@, Reads ok sthen@@
@
text
@d576 1
a576 1
	    if ($in =~ /^\#ifdef __LANGUAGE_PASCAL__/) {
d584 2
a585 2
	    if ($in =~ /^extern inline / && # Inlined assembler.
		$^O eq 'linux' && $file =~ m!(?:^|/)asm/[^/]+\.h$!) {
@


1.29
log
@Apply local patches - perl-5.24.1
@
text
@d576 1
a576 1
	    if ($in =~ s/^\#ifdef __LANGUAGE_PASCAL__//) {
d584 2
a585 2
	    # Skip inlined functions in headers
	    if ($in =~ s/^(extern|static) (__inline__|inline) .*[^;]\s*$//) {
@


1.28
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@d576 1
a576 1
	    if ($in =~ /^\#ifdef __LANGUAGE_PASCAL__/) {
d584 2
a585 2
	    if ($in =~ /^extern inline / && # Inlined assembler.
		$^O eq 'linux' && $file =~ m!(?:^|/)asm/[^/]+\.h$!) {
@


1.27
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.


ok deraadt@@
@
text
@d576 1
a576 1
	    if ($in =~ s/^\#ifdef __LANGUAGE_PASCAL__//) {
d584 2
a585 2
	    # Skip inlined functions in headers
	    if ($in =~ s/^(extern|static) (__inline__|inline) .*[^;]\s*$//) {
@


1.26
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d39 2
@


1.25
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@d772 1
a772 1
    my $VERSION     = 3;
d791 5
d822 12
@


1.25.2.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@a38 2
BEGIN { pop @@INC if $INC[-1] eq '.' }

@


1.25.4.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@a38 2
BEGIN { pop @@INC if $INC[-1] eq '.' }

@


1.24
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d574 1
a574 1
	    if ($in =~ /^\#ifdef __LANGUAGE_PASCAL__/) {
d582 2
a583 2
	    if ($in =~ /^extern inline / && # Inlined assembler.
		$^O eq 'linux' && $file =~ m!(?:^|/)asm/[^/]+\.h$!) {
@


1.23
log
@Apply local patches to perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d574 1
a574 1
	    if ($in =~ s/^\#ifdef __LANGUAGE_PASCAL__//) {
d582 2
a583 2
	    # Skip inlined functions in headers
	    if ($in =~ s/^(extern|static) (__inline__|inline) .*[^;]\s*$//) {
@


1.22
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d574 1
a574 1
	    if ($in =~ /^\#ifdef __LANGUAGE_PASCAL__/) {
d582 2
a583 2
	    if ($in =~ /^extern inline / && # Inlined assembler.
		$^O eq 'linux' && $file =~ m!(?:^|/)asm/[^/]+\.h$!) {
@


1.21
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d574 1
a574 1
	    if ($in =~ s/^\#ifdef __LANGUAGE_PASCAL__//) {
d582 2
a583 2
	    # Skip inlined functions in headers
	    if ($in =~ s/^(extern|static) (__inline__|inline) .*[^;]\s*$//) {
d869 2
a870 1
B<h2ph [-d destination directory] [-r | -a] [-l] [headerfiles]>
d935 5
@


1.20
log
@Fix [perl #74404] h2ph using deprecated goto
Patch from perl git repo
@
text
@d99 1
a99 1
    # $eval_index goes into ``#line'' directives, to help locate syntax errors:
d154 1
d156 4
d162 1
a162 2
		    if ($t ne '') {
			$new =~ s/(['\\])/\\$1/g;        #']);
d164 4
a167 11
			if ($opt_h) {
			    print OUT $t,"eval \"\\n#line $eval_index $outfile\\n\" . 'sub $name () {",$new,";}' unless defined(\&$name);\n";
			    $eval_index++;
			} else {
			    print OUT $t,"eval 'sub $name () {",$new,";}' unless defined(\&$name);\n";
			}
		    } else {
		    	# Shunt around such directives as `#define FOO FOO':
		    	next if " \&$name" eq $new;

                      print OUT $t,"unless(defined(\&$name)) {\n    sub $name () {\t",$new,";}\n}\n";
d169 1
d408 4
a411 1
    $new = '"(assembly code)"' and return if /\b__asm__\b/; # freak out.
d427 1
a427 1
		       # The above will produce "errorneus" code
d661 1
a661 1
                print STDERR "Skipping directory `$file'\n";
d666 1
a666 1
            print STDERR "Skipping `$file':  not a file or directory\n";
d762 2
a763 10
    my $from_gcc    = `LC_ALL=C $Config{cc} -v 2>&1`;
    if( !( $from_gcc =~ s:^Reading specs from (.*?)/specs\b.*:$1/include:s ) )
    { # gcc-4+ :
       $from_gcc   = `LC_ALL=C $Config{cc} -print-search-dirs 2>&1`;
       if ( !($from_gcc =~ s/^install:\s*([^\s]+[^\s\/])([\s\/]*).*$/$1\/include/s) )
       {
           $from_gcc = '';
       };
    };
    length($from_gcc) ? ($from_gcc, $from_gcc . "-fixed", $Config{usrinc}) : ($Config{usrinc});
d772 1
a772 1
    my $VERSION     = 2;
d800 10
a809 1
	    if ($define{$_} =~ /^([+-]?(\d+)?\.\d+([eE][+-]?\d+)?)[FL]?$/) {
d818 8
a825 2
		print PREAMBLE
		    "unless (defined &$_) { sub $_() { &$define{$_} } }\n\n";
d846 1
a846 1
    # Split compiler pre-definitions into `key=value' pairs:
d923 1
a923 1
Put ``hints'' in the .ph files which will help in locating problems with
d942 1
a942 1
``Quiet'' mode; don't print out the names of the files being converted.
@


1.19
log
@merge in perl 5.12.2 plus local changes
@
text
@d150 1
a150 17
		  EMIT:
		    $new = reindent($new);
		    $args = reindent($args);
		    if ($t ne '') {
			$new =~ s/(['\\])/\\$1/g;   #']);
			if ($opt_h) {
			    print OUT $t,
                            "eval \"\\n#line $eval_index $outfile\\n\" . 'sub $name $proto\{\n$t    ${args}eval q($new);\n$t}' unless defined(\&$name);\n";
                            $eval_index++;
			} else {
			    print OUT $t,
                            "eval 'sub $name $proto\{\n$t    ${args}eval q($new);\n$t}' unless defined(\&$name);\n";
			}
		    } else {
                      print OUT "unless(defined(\&$name)) {\n    sub $name $proto\{\n\t${args}eval q($new);\n    }\n}\n";
		    }
		    %curargs = ();
d367 1
a367 1
	    goto EMIT;
d386 22
@


1.18
log
@Merge in some local changes that got lost.
@
text
@d512 1
a512 1
		if ($new =~ /{\s*$/) {
d521 8
a528 2
		if ($inif && $new !~ /defined\s*\($/) {
		    $new .= '(defined(&' . $id . ') ? &' . $id . ' : undef)';
@


1.17
log
@Merge in perl 5.10.1; part two
@
text
@d561 1
a561 1
	    if ($in =~ /^\#ifdef __LANGUAGE_PASCAL__/) {
d569 2
a570 2
	    if ($in =~ /^extern inline / && # Inlined assembler.
		$^O eq 'linux' && $file =~ m!(?:^|/)asm/[^/]+\.h$!) {
@


1.16
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d88 1
a88 1
my ($incl, $incl_type, $next);
d126 1
a126 1
        "no warnings 'redefine';\n\n";
d189 1
a189 1
	    } elsif (/^(include|import|include_next)\s*[<\"](.*)[>\"]/) {
d191 2
a192 1
                $incl = $2;
d225 4
d561 1
a561 1
	    if ($in =~ s/^\#ifdef __LANGUAGE_PASCAL__//) {
d569 2
a570 2
	    # Skip inlined functions in headers
	    if ($in =~ s/^(extern|static) (__inline__|inline) .*[^;]\s*$//) {
d732 7
a738 2
            if ($line =~ /^#\s*include\s+<(.*?)>/) {
                push(@@ARGV, $1) unless $Is_converted{$1};
d746 1
a746 1
# non-GCC?) C compilers, but gcc uses an additional include directory.
d758 1
a758 1
    length($from_gcc) ? ($from_gcc, $Config{usrinc}) : ($Config{usrinc});
d812 1
@


1.15
log
@merge in perl 5.8.8
@
text
@d517 1
a517 1
		    $new .= '(defined(&' . $id . ') ? &' . $id . ' : 0)';
d775 1
a775 1
        print PREAMBLE "# This file was created by h2ph version $VERSION\n";
d777 25
a801 17
        foreach (sort keys %define) {
            if ($opt_D) {
                print PREAMBLE "# $_=$define{$_}\n";
            }

            if ($define{$_} =~ /^(\d+)U?L{0,2}$/i) {
                print PREAMBLE
                    "unless (defined &$_) { sub $_() { $1 } }\n\n";
            } elsif ($define{$_} =~ /^\w+$/) {
                print PREAMBLE
                    "unless (defined &$_) { sub $_() { &$define{$_} } }\n\n";
            } else {
                print PREAMBLE
                    "unless (defined &$_) { sub $_() { \"",
                    quotemeta($define{$_}), "\" } }\n\n";
            }
        }
d813 1
a813 1
        @@Config{'ccsymbols', 'cppsymbols', 'cppccsymbols'};
d816 5
a820 6
    foreach (split /\s+/, $allsymbols) {
        /(.+?)=(.+)/ and $define{$1} = $2;

        if ($opt_D) {
            print STDERR "$_:  $1 -> $2\n";
        }
d870 1
a870 1
beneath the default Perl library location (C<$Config{'installsitsearch'}>).
d955 2
a956 2
        FIRST_VALUE,
        SECOND_VALUE,
d958 1
a958 1
        THIRD_VALUE
@


1.14
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d145 1
a145 1
			$args = "local($args) = \@@_;\n$t    ";
d279 2
d293 1
d344 1
a344 1
		? "local(" . (join ',', map "\$$_", @@args) . ") = \@@_;\n$t    "
d357 1
d366 1
d399 1
d408 1
a408 1
	s/^0X([0-9A-F]+)[UL]*//i 
d544 1
a544 1
                # Preprocess all tri-graphs 
d557 1
a557 1
                # Tru64 disassembler.h evilness: mixed C and Pascal.
d559 1
a559 1
		    last if /^\#endif/; 
d561 1
d566 2
a567 2
 		while (<IN>) {
		    last if /^}/; 
d569 1
d739 9
a747 3
    my $from_gcc    = `$Config{cc} -v 2>&1`;
    $from_gcc       =~ s:^Reading specs from (.*?)/specs\b.*:$1/include:s;

@


1.13
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d61 1
a61 1
my @@isatype = split(' ',<<END);
d67 2
a68 1
END
d137 1
a137 1
    	    	    my $proto = '() ';
d139 1
a139 1
    	    	    	$proto = '';
d150 1
d273 1
a273 1
	} elsif(/^\s*(typedef\s*)?enum\s*(\s+[a-zA-Z_]\w*\s*)?/) {
d305 69
d382 1
a382 1
    queue_includes_from($file) if ($opt_a);
d454 1
d456 7
a462 1
		last unless ($isatype{$_} or $_ eq 'struct' or $_ eq 'union');
a463 1
	    s/\([\w\s]+[\*\s]*\)// && next;      # then eliminate them.
@


1.12
log
@Don't try to process inline functions; fixes a problem parsing
macros.h on vax (noticed by hugh).
@
text
@d45 7
a51 2
getopts('Dd:rlhaQ');
use vars qw($opt_D $opt_d $opt_r $opt_l $opt_h $opt_a $opt_Q);
d73 1
d79 7
d87 1
a87 1
my ($incl, $next);
d123 3
a125 1
    print OUT "require '_h2ph_pre.ph';\n\n";
d187 6
a192 5
	    } elsif (/^(include|import)\s*[<"](.*)[>"]/) {
		($incl = $2) =~ s/\.h$/.ph/;
		print OUT $t,"require '$incl';\n";
	    } elsif(/^include_next\s*[<"](.*)[>"]/) {
		($incl = $1) =~ s/\.h$/.ph/;
d197 2
d201 2
a202 1
			   "(grep { \$_ eq \"$incl\" } keys(\%INC));\n");
d204 1
a204 1
			   "my(\@@REM) = map { \"\$_/$incl\" } ",
d206 6
a211 1
			   "and -f \"\$_/$incl\" } \@@INC);\n");
d220 4
a304 2
    print OUT "1;\n";

d306 5
d312 1
d315 3
a317 8
exit $Exit;


sub reindent($) {
    my($text) = shift;
    $text =~ s/\n/\n    /g;
    $text =~ s/        /\t/g;
    $text;
d320 1
d494 12
a505 4
            } elsif ($in =~ s/^('(\\.|[^'\\])*')//) {       # '...
                $out    .= $1;
            } elsif ($in =~ s/^("(\\.|[^"\\])*")//) {       # "...
                $out    .= $1;
d524 7
d532 1
@


1.11
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d445 1
a445 1
	    if ($in =~ /^\#ifdef __LANGUAGE_PASCAL__/) {
d452 2
a453 2
	    if ($in =~ /^extern inline / && # Inlined assembler.
		$^O eq 'linux' && $file =~ m!(?:^|/)asm/[^/]+\.h$!) {
@


1.10
log
@treat unions as structs; fixes pr 1918, perl dudes never replied though
@
text
@a110 8
    while (<IN>) {
	chop;
	while (/\\$/) {
	    chop;
	    $_ .= <IN>;
	    chop;
	}
	print OUT "# $_\n" if $opt_D;
d112 1
a112 9
	if (s:/\*:\200:g) {
	    s:\*/:\201:g;
	    s/\200[^\201]*\201//g;	# delete single line comments
	    if (s/\200.*//) {		# begin multi-line comment?
		$_ .= '/*';
		$_ .= <IN>;
		redo;
	    }
	}
d118 1
d243 6
a248 3
 	} elsif(/^\s*(typedef\s*)?enum\s*(\s+[a-zA-Z_]\w*\s*)?\{/) {
	    until(/\}.*?;/) {
		chomp($next = <IN>);
d252 1
d255 1
a255 1
	    /^\s?(typedef\s?)?enum\s?([a-zA-Z_]\w*)?\s?\{(.*)\}\s?([a-zA-Z_]\w*)?\s?;/;
d303 15
a317 2
	s/^(0X[0-9A-F]+)[UL]*//i	&& do {$new .= lc($1); next;};
	s/^(-?\d+\.\d+E[-+]\d+)F?//i	&& do {$new .= $1; next;};
d392 2
a393 2
	    } elsif (/^\(/) {
		s/^\((\w),/("$1",/ if $id =~ /^_IO[WR]*$/i;	# cheat
d420 79
d647 1
a647 1
            if ($define{$_} =~ /^\d+$/) {
d649 1
a649 1
                    "unless (defined &$_) { sub $_() { $define{$_} } }\n\n";
d706 4
@


1.9
log
@merge in perl 5.6.1 with our local changes
@
text
@d354 1
a354 1
		last unless ($isatype{$_} or $_ eq 'struct');
d377 1
a377 1
	    if ($id eq 'struct') {
@


1.8
log
@perl-5.6.0 + local changes
@
text
@d39 2
d46 1
d48 1
a48 1
@@inc_dirs = inc_dirs() if $opt_a;
d56 1
a56 1
@@isatype = split(' ',<<END);
d64 1
d66 2
a67 1
$inif = 0;
d73 3
a75 1
while (defined ($file = next_file())) {
d139 1
a139 1
			foreach $arg (split(/,\s*/,$args)) {
d267 5
a271 5
	    ($enum_subs = $3) =~ s/\s//g;
	    @@enum_subs = split(/,/, $enum_subs);
	    $enum_val = -1;
	    for $enum (@@enum_subs) {
		($enum_name, $enum_value) = $enum =~ /^([a-zA-Z_]\w*)(=.+)?$/;
d290 1
a290 1
    $is_converted{$file} = 1;
d296 1
d304 1
d306 1
d308 1
a308 1
	my($joined_args) = join('|', keys(%curargs));
d360 1
a360 1
	    $id = $1;
d376 1
a376 1
	    $id = $1;
d518 1
a518 1
                push(@@ARGV, $1) unless $is_converted{$1};
d588 2
a589 1
    my $allsymbols = join " ", @@Config{ccsymbols, cppsymbols, cppccsymbols};
a720 2

Doesn't run with C<use strict>
@


1.7
log
@perl5.005_03 (stock)
@
text
@d531 1
a531 1
    my $VERSION     = 1;
d559 3
d582 1
a582 2
        /(.*?)=(.*)/;
        $define{$1} = $2;
@


1.6
log
@Grok things like 1.7976931348623157E+308 and the [fF] suffix (float).
limits.ph is now almost usable...
@
text
@d4 2
a5 1
use File::Basename qw(&basename &dirname);
d17 1
d41 5
d49 1
a49 3
my $Dest_dir = (@@ARGV && $ARGV[0] =~ s/^-d//)
		    ? shift || shift
		    : $Config{installsitearch};
d66 8
a73 1
foreach $file (@@ARGV) {
d78 3
d84 1
a84 2
    }
    else {
d86 1
a86 1
	print "$file -> $outfile\n";
d91 8
d102 2
d111 2
d122 1
a122 1
	if (s/^#\s*//) {
d141 3
a143 1
		    $new =~ s/(["\\])/\\$1/g;
d145 11
a155 6
			$new =~ s/(['\\])/\\$1/g;
			print OUT $t,
                        "eval 'sub $name $proto\{\n$t    ${args}eval \"$new\";\n$t}' unless defined(\&$name);\n";
		    }
		    else {
                      print OUT "unless(defined(\&$name)) {\nsub $name $proto\{\n    ${args}eval \"$new\";\n}\n}\n";
d158 1
a158 2
		}
		else {
d162 2
d165 13
a177 5
			$new =~ s/(['\\])/\\$1/g;
                      print OUT $t,"eval 'sub $name () {",$new,";}' unless defined(\&$name);\n";
		    }
		    else {
                      print OUT $t,"unless(defined(\&$name)) {\nsub $name () {",$new,";}\n}\n";
d180 4
a183 2
	    }
	    elsif (/^include\s*<(.*)>/) {
d185 21
a205 4
		print OUT $t,"require '$incl';\n";
	    }
	    elsif (/^ifdef\s+(\w+)/) {
		print OUT $t,"if (defined &$1) {\n";
d208 2
a209 3
	    }
	    elsif (/^ifndef\s+(\w+)/) {
		print OUT $t,"if (!defined &$1) {\n";
d212 1
a212 2
	    }
	    elsif (s/^if\s+//) {
d217 1
a217 1
		print OUT $t,"if ($new) {\n";
d220 1
a220 2
	    }
	    elsif (s/^elif\s+//) {
d227 1
a227 1
		print OUT $t,"}\n${t}elsif ($new) {\n";
d230 1
a230 2
	    }
	    elsif (/^else/) {
d233 1
a233 1
		print OUT $t,"}\n${t}else {\n";
d236 1
a236 2
	    }
	    elsif (/^endif/) {
d240 38
d282 3
d289 7
d297 3
d301 8
a308 6
	s/^\&//;		# hack for things that take the address of
	s/^(\s+)//				&& do {$new .= ' '; next;};
	s/^(0x[0-9a-fA-F]+)\s*[LlUu]*//		&& do {$new .= $1; next;};
	s/^(\d+([Ee][\+-]\d+)?)\s*[fFLlUu]*//	&& do {$new .= $1; next;};
	s/^("(\\"|[^"])*")//			&& do {$new .= $1; next;};
	s/^'((\\"|[^"])*)'//			&& do {
d311 1
a311 2
	    }
	    else {
d341 24
d371 2
a372 4
	    }
	    elsif ($id eq 'unsigned' || $id eq 'long') {
		s/^\s+(\w+)//;
		$id .= ' ' . $1;
d376 3
a378 3
		$new .= '$' . $id;
	    }
	    elsif ($id eq 'defined') {
d380 1
a380 2
	    }
	    elsif (/^\(/) {
d383 1
a383 2
	    }
	    elsif ($isatype{$id}) {
d386 1
a386 2
		}
		elsif ($new =~ /\(\s*$/ && /^[\s*]*\)/) {
d389 1
a389 2
		}
		else {
d392 1
a392 2
	    }
	    else {
d395 3
a397 5
		}
		elsif (/^\[/) {
		    $new .= ' $' . $id;
		}
		else {
d406 187
d602 1
a602 1
B<h2ph [headerfiles]>
d613 4
d623 52
d709 18
d734 1
@


1.5
log
@Hex constants can end in [lLuU]* as well.  Fixes limits.ph and others.
@
text
@d195 5
a199 5
	s/^(\s+)//			&& do {$new .= ' '; next;};
	s/^(0x[0-9a-fA-F]+)\s*[LlUu]*//	&& do {$new .= $1; next;};
	s/^(\d+)\s*[LlUu]*//		&& do {$new .= $1; next;};
	s/^("(\\"|[^"])*")//		&& do {$new .= $1; next;};
	s/^'((\\"|[^"])*)'//		&& do {
@


1.4
log
@Add missing parens.  Peter Galbavy <peter@@wonderland.org>
@
text
@d195 5
a199 5
	s/^(\s+)//		&& do {$new .= ' '; next;};
	s/^(0x[0-9a-fA-F]+)//	&& do {$new .= $1; next;};
	s/^(\d+)\s*[LlUu]*//	&& do {$new .= $1; next;};
	s/^("(\\"|[^"])*")//	&& do {$new .= $1; next;};
	s/^'((\\"|[^"])*)'//	&& do {
@


1.3
log
@perl 5.004_04
@
text
@d122 1
a122 1
                      print OUT "unless defined(\&$name) {\nsub $name $proto\{\n    ${args}eval \"$new\";\n}\n}\n";
@


1.2
log
@First cut at teaching perl about $DESTDIR. Also add a run of h2ph, creating
the .ph include files.
@
text
@a1 4
#	$OpenBSD$
#
# This is slightly hacked up in order to support DESTDIR.
#
d16 3
a18 4
chdir(dirname($0));
($file = basename($0)) =~ s/\.PL$//;
$file =~ s/\.pl$//
	if ($^O eq 'VMS' or $^O eq 'os2');  # "case-forgiving"
d28 3
a30 10
$Config{'startperl'}
    eval 'exec perl -S \$0 "\$@@"'
	if 0;

'di ';
'ds 00 \"';
'ig 00 ';

\$perlincl = "$Config{archlibexp}";

d37 10
a46 8
$destdir = $ENV{"DESTDIR"};
if ($destdir ne '')  {
    chdir "$destdir/usr/include" || die "Can't cd $destdir/usr/include";
    # whack $perlincl
    $perlincl = "$destdir/$perlincl";
} else {
    chdir '/usr/include' || die "Can't cd /usr/include";
}
d53 1
a53 1
	FILE
d62 4
d75 1
a75 3
	    if (!-d "$perlincl/$dir") {
		mkdir("$perlincl/$dir",0777);
	    }
d77 2
a78 2
	open(IN,"$file") || ((warn "Can't open $file: $!\n"),next);
	open(OUT,">$perlincl/$outfile") || die "Can't create $outfile: $!\n";
d103 1
d105 1
d114 1
a114 1
		    do expr();
d119 1
a119 1
			  "eval 'sub $name {\n$t    ${args}eval \"$new\";\n$t}';\n";
d122 1
a122 1
			print OUT "sub $name {\n    ${args}eval \"$new\";\n}\n";
d128 1
a128 1
		    do expr();
d132 1
a132 1
			print OUT $t,"eval 'sub $name {",$new,";}';\n";
d135 1
a135 1
			print OUT $t,"sub $name {",$new,";}\n";
d156 1
a156 1
		do expr();
d165 1
a165 1
		do expr();
d190 2
d194 1
d197 1
a197 1
	s/^(\d+)[LlUu]*//	&& do {$new .= $1; next;};
d208 25
a232 4
	s/^sizeof\s*\(([^)]+)\)/{$1}/ && do {
	    $new .= '$sizeof';
	    next;
	};
d240 1
a240 1
	    elsif ($id eq 'unsigned') {
d270 2
a271 2
		} 
		elsif (/^\[/) { 
d284 3
d288 1
a288 1
	# These next few lines are legal in both Perl and nroff.
d290 1
a290 1
.00 ;			# finish .ig
d292 5
a296 12
'di			\" finish diversion--previous line must be blank
.nr nl 0-1		\" fake up transition to first page again
.nr % 0			\" start at page 1
'; __END__ ############# From here on it's a standard manual page ############
.TH H2PH 1 "August 8, 1990"
.AT 3
.SH NAME
h2ph \- convert .h C header files to .ph Perl header files
.SH SYNOPSIS
.B h2ph [headerfiles]
.SH DESCRIPTION
.I h2ph
a299 1
.nf
d303 4
a306 1
.fi
d308 3
a310 1
.SH ENVIRONMENT
d312 6
a317 5
.SH FILES
/usr/include/*.h
.br
/usr/include/sys/*.h
.br
d319 3
a321 1
.SH AUTHOR
d323 3
a325 1
.SH "SEE ALSO"
d327 3
a329 1
.SH DIAGNOSTICS
d331 3
a333 1
.SH BUGS
d335 1
a335 1
.PP
d339 1
a339 1
.PP
d342 3
a344 1
.ex
@


1.1
log
@Initial revision
@
text
@d2 4
d49 8
a56 1
chdir '/usr/include' || die "Can't cd /usr/include";
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d4 1
a4 2
use File::Basename qw(basename dirname);
use Cwd;
d16 4
a19 4
$origdir = cwd;
chdir dirname($0);
$file = basename($0, '.PL');
$file .= '.com' if $^O eq 'VMS';
d29 10
a38 3
$Config{startperl}
    eval 'exec $Config{perlpath} -S \$0 \${1+"\$@@"}'
	if \$running_under_some_shell;
d45 1
a45 13
use Config;
use File::Path qw(mkpath);
use Getopt::Std;

getopts('Dd:rlhaQ');
die "-r and -a options are mutually exclusive\n" if ($opt_r and $opt_a);
@@inc_dirs = inc_dirs() if $opt_a;

my $Exit = 0;

my $Dest_dir = $opt_d || $Config{installsitearch};
die "Destination directory $Dest_dir doesn't exist or isn't a directory\n"
    unless -d $Dest_dir;
d52 1
a52 1
	FILE	key_t	caddr_t
d60 1
a60 15
build_preamble_if_necessary();

while (defined ($file = next_file())) {
    if (-l $file and -d $file) {
        link_if_possible($file) if ($opt_l);
        next;
    }

    # Recover from header files with unbalanced cpp directives
    $t = '';
    $tab = 0;

    # $eval_index goes into ``#line'' directives, to help locate syntax errors:
    $eval_index = 1;

d64 2
a65 1
    } else {
d67 1
a67 1
	print "$file -> $outfile\n" unless $opt_Q;
d70 2
a71 7
	    mkpath "$Dest_dir/$dir";
	}

	if ($opt_a) { # automagic mode:  locate header file in @@inc_dirs
	    foreach (@@inc_dirs) {
		chdir $_;
		last if -f $file;
d74 2
a75 3

	open(IN,"$file") || (($Exit = 1),(warn "Can't open $file: $!\n"),next);
	open(OUT,">$Dest_dir/$outfile") || die "Can't create $outfile: $!\n";
a76 2

    print OUT "require '_h2ph_pre.ph';\n\n";
a83 2
	print OUT "# $_\n" if $opt_D;

d93 1
a93 1
	if (s/^\s*\#\s*//) {
a99 1
    	    	    my $proto = '() ';
a100 1
    	    	    	$proto = '';
d109 2
a110 4
		    expr();
		    $new =~ s/(["\\])/\\$1/g;       #"]);
		    $new = reindent($new);
		    $args = reindent($args);
d112 6
a117 11
			$new =~ s/(['\\])/\\$1/g;   #']);
			if ($opt_h) {
			    print OUT $t,
                            "eval \"\\n#line $eval_index $outfile\\n\" . 'sub $name $proto\{\n$t    ${args}eval q($new);\n$t}' unless defined(\&$name);\n";
                            $eval_index++;
			} else {
			    print OUT $t,
                            "eval 'sub $name $proto\{\n$t    ${args}eval q($new);\n$t}' unless defined(\&$name);\n";
			}
		    } else {
                      print OUT "unless(defined(\&$name)) {\n    sub $name $proto\{\n\t${args}eval q($new);\n    }\n}\n";
d120 2
a121 1
		} else {
d123 1
a123 1
		    expr();
a124 2
		    $new = reindent($new);
		    $args = reindent($args);
d126 5
a130 13
			$new =~ s/(['\\])/\\$1/g;        #']);

			if ($opt_h) {
			    print OUT $t,"eval \"\\n#line $eval_index $outfile\\n\" . 'sub $name () {",$new,";}' unless defined(\&$name);\n";
			    $eval_index++;
			} else {
			    print OUT $t,"eval 'sub $name () {",$new,";}' unless defined(\&$name);\n";
			}
		    } else {
		    	# Shunt around such directives as `#define FOO FOO':
		    	next if " \&$name" eq $new;

                      print OUT $t,"unless(defined(\&$name)) {\n    sub $name () {\t",$new,";}\n}\n";
d133 3
a135 2
	    } elsif (/^(include|import)\s*[<"](.*)[>"]/) {
		($incl = $2) =~ s/\.h$/.ph/;
d137 3
a139 23
	    } elsif(/^include_next\s*[<"](.*)[>"]/) {
		($incl = $1) =~ s/\.h$/.ph/;
		print OUT ($t,
			   "eval {\n");
                $tab += 4;
                $t = "\t" x ($tab / 8) . ' ' x ($tab % 8);
		print OUT ($t,
			   "my(\%INCD) = map { \$INC{\$_} => 1 } ",
			   "(grep { \$_ eq \"$incl\" } keys(\%INC));\n");
		print OUT ($t,
			   "my(\@@REM) = map { \"\$_/$incl\" } ",
			   "(grep { not exists(\$INCD{\"\$_/$incl\"})",
			   "and -f \"\$_/$incl\" } \@@INC);\n");
		print OUT ($t,
			   "require \"\$REM[0]\" if \@@REM;\n");
                $tab -= 4;
                $t = "\t" x ($tab / 8) . ' ' x ($tab % 8);
                print OUT ($t,
			   "};\n");
		print OUT ($t,
			   "warn(\$\@@) if \$\@@;\n");
	    } elsif (/^ifdef\s+(\w+)/) {
		print OUT $t,"if(defined(&$1)) {\n";
d142 3
a144 2
	    } elsif (/^ifndef\s+(\w+)/) {
		print OUT $t,"unless(defined(&$1)) {\n";
d147 2
a148 1
	    } elsif (s/^if\s+//) {
d151 1
a151 1
		expr();
d153 1
a153 1
		print OUT $t,"if($new) {\n";
d156 2
a157 1
	    } elsif (s/^elif\s+//) {
d160 1
a160 1
		expr();
d164 1
a164 1
		print OUT $t,"}\n elsif($new) {\n";
d167 2
a168 1
	    } elsif (/^else/) {
d171 1
a171 1
		print OUT $t,"} else {\n";
d174 2
a175 1
	    } elsif (/^endif/) {
a178 38
	    } elsif(/^undef\s+(\w+)/) {
		print OUT $t, "undef(&$1) if defined(&$1);\n";
	    } elsif(/^error\s+(".*")/) {
		print OUT $t, "die($1);\n";
	    } elsif(/^error\s+(.*)/) {
		print OUT $t, "die(\"", quotemeta($1), "\");\n";
	    } elsif(/^warning\s+(.*)/) {
		print OUT $t, "warn(\"", quotemeta($1), "\");\n";
	    } elsif(/^ident\s+(.*)/) {
		print OUT $t, "# $1\n";
	    }
 	} elsif(/^\s*(typedef\s*)?enum\s*(\s+[a-zA-Z_]\w*\s*)?\{/) {
	    until(/\}.*?;/) {
		chomp($next = <IN>);
		$_ .= $next;
		print OUT "# $next\n" if $opt_D;
	    }
	    s@@/\*.*?\*/@@@@g;
	    s/\s+/ /g;
	    /^\s?(typedef\s?)?enum\s?([a-zA-Z_]\w*)?\s?\{(.*)\}\s?([a-zA-Z_]\w*)?\s?;/;
	    ($enum_subs = $3) =~ s/\s//g;
	    @@enum_subs = split(/,/, $enum_subs);
	    $enum_val = -1;
	    for $enum (@@enum_subs) {
		($enum_name, $enum_value) = $enum =~ /^([a-zA-Z_]\w*)(=.+)?$/;
		$enum_value =~ s/^=//;
		$enum_val = (length($enum_value) ? $enum_value : $enum_val + 1);
		if ($opt_h) {
		    print OUT ($t,
			       "eval(\"\\n#line $eval_index $outfile\\n",
			       "sub $enum_name () \{ $enum_val; \}\") ",
			       "unless defined(\&$enum_name);\n");
		    ++ $eval_index;
		} else {
		    print OUT ($t,
			       "eval(\"sub $enum_name () \{ $enum_val; \}\") ",
			       "unless defined(\&$enum_name);\n");
		}
a182 12

    $is_converted{$file} = 1;
    queue_includes_from($file) if ($opt_a);
}

exit $Exit;

sub reindent($) {
    my($text) = shift;
    $text =~ s/\n/\n    /g;
    $text =~ s/        /\t/g;
    $text;
a185 3
    if(keys(%curargs)) {
	my($joined_args) = join('|', keys(%curargs));
    }
a186 2
	s/^\&\&// && do { $new .= " &&"; next;}; # handle && operator
	s/^\&([\(a-z\)]+)/$1/i;	# hack for things that take the address of
d188 2
a189 3
	s/^(0X[0-9A-F]+)[UL]*//i	&& do {$new .= lc($1); next;};
	s/^(-?\d+\.\d+E[-+]\d+)F?//i	&& do {$new .= $1; next;};
	s/^(\d+)\s*[LU]*//i	&& do {$new .= $1; next;};
d194 2
a195 1
	    } else {
d200 3
a202 48
        # replace "sizeof(foo)" with "{foo}"
        # also, remove * (C dereference operator) to avoid perl syntax
        # problems.  Where the %sizeof array comes from is anyone's
        # guess (c2ph?), but this at least avoids fatal syntax errors.
        # Behavior is undefined if sizeof() delimiters are unbalanced.
        # This code was modified to able to handle constructs like this:
        #   sizeof(*(p)), which appear in the HP-UX 10.01 header files.
        s/^sizeof\s*\(// && do {
            $new .= '$sizeof';
            my $lvl = 1;  # already saw one open paren
            # tack { on the front, and skip it in the loop
            $_ = "{" . "$_";
            my $index = 1;
            # find balanced closing paren
            while ($index <= length($_) && $lvl > 0) {
                $lvl++ if substr($_, $index, 1) eq "(";
                $lvl-- if substr($_, $index, 1) eq ")";
                $index++;
            }
            # tack } on the end, replacing )
            substr($_, $index - 1, 1) = "}";
            # remove pesky * operators within the sizeof argument
            substr($_, 0, $index - 1) =~ s/\*//g;
            next;
        };
	# Eliminate typedefs
	/\(([\w\s]+)[\*\s]*\)\s*[\w\(]/ && do {
	    foreach (split /\s+/, $1) {  # Make sure all the words are types,
		last unless ($isatype{$_} or $_ eq 'struct');
	    }
	    s/\([\w\s]+[\*\s]*\)// && next;      # then eliminate them.
	};
	# struct/union member, including arrays:
	s/^([_A-Z]\w*(\[[^\]]+\])?((\.|->)[_A-Z]\w*(\[[^\]]+\])?)+)//i && do {
	    $id = $1;
	    $id =~ s/(\.|(->))([^\.\-]*)/->\{$3\}/g;
	    $id =~ s/\b([^\$])($joined_args)/$1\$$2/g if length($joined_args);
	    while($id =~ /\[\s*([^\$\&\d\]]+)\]/) {
		my($index) = $1;
		$index =~ s/\s//g;
		if(exists($curargs{$index})) {
		    $index = "\$$index";
		} else {
		    $index = "&$index";
		}
		$id =~ s/\[\s*([^\$\&\d\]]+)\]/[$index]/;
	    }
	    $new .= " (\$$id)";
d210 4
a213 2
	    } elsif ($id =~ /^((un)?signed)|(long)|(short)$/) {
		while (s/^\s+(\w+)//) { $id .= ' ' . $1; }
d217 3
a219 3
		$new .= "\$$id";
		$new .= '->' if /^[\[\{]/;
	    } elsif ($id eq 'defined') {
d221 2
a222 1
	    } elsif (/^\(/) {
d225 2
a226 1
	    } elsif ($isatype{$id}) {
d229 2
a230 1
		} elsif ($new =~ /\(\s*$/ && /^[\s*]*\)/) {
d233 2
a234 1
		} else {
d237 2
a238 1
	    } else {
d241 5
a245 3
		} elsif (/^\[/) {
		    $new .= " \$$id";
		} else {
a253 187


# Handle recursive subdirectories without getting a grotesquely big stack.
# Could this be implemented using File::Find?
sub next_file
{
    my $file;

    while (@@ARGV) {
        $file = shift @@ARGV;

        if ($file eq '-' or -f $file or -l $file) {
            return $file;
        } elsif (-d $file) {
            if ($opt_r) {
                expand_glob($file);
            } else {
                print STDERR "Skipping directory `$file'\n";
            }
        } elsif ($opt_a) {
            return $file;
        } else {
            print STDERR "Skipping `$file':  not a file or directory\n";
        }
    }

    return undef;
}


# Put all the files in $directory into @@ARGV for processing.
sub expand_glob
{
    my ($directory)  = @@_;

    $directory =~ s:/$::;

    opendir DIR, $directory;
        foreach (readdir DIR) {
            next if ($_ eq '.' or $_ eq '..');

            # expand_glob() is going to be called until $ARGV[0] isn't a
            # directory; so push directories, and unshift everything else.
            if (-d "$directory/$_") { push    @@ARGV, "$directory/$_" }
            else                    { unshift @@ARGV, "$directory/$_" }
        }
    closedir DIR;
}


# Given $file, a symbolic link to a directory in the C include directory,
# make an equivalent symbolic link in $Dest_dir, if we can figure out how.
# Otherwise, just duplicate the file or directory.
sub link_if_possible
{
    my ($dirlink)  = @@_;
    my $target  = eval 'readlink($dirlink)';

    if ($target =~ m:^\.\./: or $target =~ m:^/:) {
        # The target of a parent or absolute link could leave the $Dest_dir
        # hierarchy, so let's put all of the contents of $dirlink (actually,
        # the contents of $target) into @@ARGV; as a side effect down the
        # line, $dirlink will get created as an _actual_ directory.
        expand_glob($dirlink);
    } else {
        if (-l "$Dest_dir/$dirlink") {
            unlink "$Dest_dir/$dirlink" or
                print STDERR "Could not remove link $Dest_dir/$dirlink:  $!\n";
        }

        if (eval 'symlink($target, "$Dest_dir/$dirlink")') {
            print "Linking $target -> $Dest_dir/$dirlink\n";

            # Make sure that the link _links_ to something:
            if (! -e "$Dest_dir/$target") {
                mkpath("$Dest_dir/$target", 0755) or
                    print STDERR "Could not create $Dest_dir/$target/\n";
            }
        } else {
            print STDERR "Could not symlink $target -> $Dest_dir/$dirlink:  $!\n";
        }
    }
}


# Push all #included files in $file onto our stack, except for STDIN
# and files we've already processed.
sub queue_includes_from
{
    my ($file)    = @@_;
    my $line;

    return if ($file eq "-");

    open HEADER, $file or return;
        while (defined($line = <HEADER>)) {
            while (/\\$/) { # Handle continuation lines
                chop $line;
                $line .= <HEADER>;
            }

            if ($line =~ /^#\s*include\s+<(.*?)>/) {
                push(@@ARGV, $1) unless $is_converted{$1};
            }
        }
    close HEADER;
}


# Determine include directories; $Config{usrinc} should be enough for (all
# non-GCC?) C compilers, but gcc uses an additional include directory.
sub inc_dirs
{
    my $from_gcc    = `$Config{cc} -v 2>&1`;
    $from_gcc       =~ s:^Reading specs from (.*?)/specs\b.*:$1/include:s;

    length($from_gcc) ? ($from_gcc, $Config{usrinc}) : ($Config{usrinc});
}


# Create "_h2ph_pre.ph", if it doesn't exist or was built by a different
# version of h2ph.
sub build_preamble_if_necessary
{
    # Increment $VERSION every time this function is modified:
    my $VERSION     = 1;
    my $preamble    = "$Dest_dir/_h2ph_pre.ph";

    # Can we skip building the preamble file?
    if (-r $preamble) {
        # Extract version number from first line of preamble:
        open  PREAMBLE, $preamble or die "Cannot open $preamble:  $!";
            my $line = <PREAMBLE>;
            $line =~ /(\b\d+\b)/;
        close PREAMBLE            or die "Cannot close $preamble:  $!";

        # Don't build preamble if a compatible preamble exists:
        return if $1 == $VERSION;
    }

    my (%define) = _extract_cc_defines();

    open  PREAMBLE, ">$preamble" or die "Cannot open $preamble:  $!";
        print PREAMBLE "# This file was created by h2ph version $VERSION\n";

        foreach (sort keys %define) {
            if ($opt_D) {
                print PREAMBLE "# $_=$define{$_}\n";
            }

            if ($define{$_} =~ /^\d+$/) {
                print PREAMBLE
                    "unless (defined &$_) { sub $_() { $define{$_} } }\n\n";
            } else {
                print PREAMBLE
                    "unless (defined &$_) { sub $_() { \"",
                    quotemeta($define{$_}), "\" } }\n\n";
            }
        }
    close PREAMBLE               or die "Cannot close $preamble:  $!";
}


# %Config contains information on macros that are pre-defined by the
# system's compiler.  We need this information to make the .ph files
# function with perl as the .h files do with cc.
sub _extract_cc_defines
{
    my %define;
    my $allsymbols = join " ", @@Config{ccsymbols, cppsymbols, cppccsymbols};

    # Split compiler pre-definitions into `key=value' pairs:
    foreach (split /\s+/, $allsymbols) {
        /(.*?)=(.*)/;
        $define{$1} = $2;

        if ($opt_D) {
            print STDERR "$_:  $1 -> $2\n";
        }
    }

    return %define;
}


1;

a254 7
__END__

=head1 NAME

h2ph - convert .h C header files to .ph Perl header files

=head1 SYNOPSIS
d256 1
a256 1
B<h2ph [-d destination directory] [-r | -a] [-l] [headerfiles]>
d258 1
a258 1
=head1 DESCRIPTION
d260 12
a271 1
I<h2ph>
d275 1
d279 1
a279 8
or

	cd /usr/include; h2ph -r -l .

The output files are placed in the hierarchy rooted at Perl's
architecture dependent library directory.  You can specify a different
hierarchy with a B<-d> switch.

d281 1
a281 55

=head1 OPTIONS

=over 4

=item -d destination_dir

Put the resulting B<.ph> files beneath B<destination_dir>, instead of
beneath the default Perl library location (C<$Config{'installsitsearch'}>).

=item -r

Run recursively; if any of B<headerfiles> are directories, then run I<h2ph>
on all files in those directories (and their subdirectories, etc.).  B<-r>
and B<-a> are mutually exclusive.

=item -a

Run automagically; convert B<headerfiles>, as well as any B<.h> files
which they include.  This option will search for B<.h> files in all
directories which your C compiler ordinarily uses.  B<-a> and B<-r> are
mutually exclusive.

=item -l

Symbolic links will be replicated in the destination directory.  If B<-l>
is not specified, then links are skipped over.

=item -h

Put ``hints'' in the .ph files which will help in locating problems with
I<h2ph>.  In those cases when you B<require> a B<.ph> file containing syntax
errors, instead of the cryptic

	[ some error condition ] at (eval mmm) line nnn

you will see the slightly more helpful

	[ some error condition ] at filename.ph line nnn

However, the B<.ph> files almost double in size when built using B<-h>.

=item -D

Include the code from the B<.h> file as a comment in the B<.ph> file.
This is primarily used for debugging I<h2ph>.

=item -Q

``Quiet'' mode; don't print out the names of the files being converted.

=back

=head1 ENVIRONMENT

d283 5
a287 6

=head1 FILES

 /usr/include/*.h
 /usr/include/sys/*.h

d289 1
a289 3

=head1 AUTHOR

d291 1
a291 3

=head1 SEE ALSO

d293 1
a293 3

=head1 DIAGNOSTICS

d295 1
a295 3

=head1 BUGS

d297 1
a297 1

d301 1
a301 1

d304 1
a304 21

Doesn't run with C<use strict>

You have to run this program by hand; it's not run as part of the Perl
installation.

Doesn't handle complicated expressions built piecemeal, a la:

    enum {
        FIRST_VALUE,
        SECOND_VALUE,
    #ifdef ABC
        THIRD_VALUE
    #endif
    };

Doesn't necessarily locate all of your C compiler's internally-defined
symbols.

=cut

a309 1
chdir $origdir;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d531 1
a531 1
    my $VERSION     = 2;
a558 3
            } elsif ($define{$_} =~ /^\w+$/) {
                print PREAMBLE
                    "unless (defined &$_) { sub $_() { &$define{$_} } }\n\n";
d579 2
a580 1
        /(.+?)=(.+)/ and $define{$1} = $2;
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a38 2
use strict;

a43 1
use vars qw($opt_D $opt_d $opt_r $opt_l $opt_h $opt_a $opt_Q);
d45 1
a45 1
my @@inc_dirs = inc_dirs() if $opt_a;
d53 1
a53 1
my @@isatype = split(' ',<<END);
a60 1
my %isatype;
d62 1
a62 2
my $inif = 0;
my %Is_converted;
d68 1
a68 3
my ($t, $tab, %curargs, $new, $eval_index, $dir, $name, $args, $outfile);
my ($incl, $next);
while (defined (my $file = next_file())) {
d132 1
a132 1
			foreach my $arg (split(/,\s*/,$args)) {
d260 5
a264 5
	    (my $enum_subs = $3) =~ s/\s//g;
	    my @@enum_subs = split(/,/, $enum_subs);
	    my $enum_val = -1;
	    foreach my $enum (@@enum_subs) {
		my ($enum_name, $enum_value) = $enum =~ /^([a-zA-Z_]\w*)(=.+)?$/;
d283 1
a283 1
    $Is_converted{$file} = 1;
a288 1

a295 1

a296 1
    my $joined_args;
d298 1
a298 1
	$joined_args = join('|', keys(%curargs));
d350 1
a350 1
	    my $id = $1;
d366 1
a366 1
	    my $id = $1;
d508 1
a508 1
                push(@@ARGV, $1) unless $Is_converted{$1};
d578 1
a578 2
    my $allsymbols  = join " ",
        @@Config{'ccsymbols', 'cppsymbols', 'cppccsymbols'};
d710 2
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d111 8
d120 9
a128 1
    while (defined (local $_ = next_line($file))) {
a133 1
		s/\(\w+\s*\(\*\)\s*\(\w*\)\)\s*(-?\d+)/$1/; # (int (*)(foo_t))0
d258 3
a260 6
	} elsif(/^\s*(typedef\s*)?enum\s*(\s+[a-zA-Z_]\w*\s*)?/) {
	    until(/\{[^}]*\}.*;/ || /;/) {
		last unless defined ($next = next_line($file));
		chomp $next;
		# drop "#define FOO FOO" in enums
		$next =~ s/^\s*#\s*define\s+(\w+)\s+\1\s*$//;
a263 1
	    s/#\s*if.*?#\s*endif//g; # drop #ifdefs
d266 1
a266 1
	    next unless /^\s?(typedef\s?)?enum\s?([a-zA-Z_]\w*)?\s?\{(.*)\}\s?([a-zA-Z_]\w*)?\s?;/;
d314 2
a315 15
	s/^0X([0-9A-F]+)[UL]*//i 
	    && do {my $hex = $1;
		   $hex =~ s/^0+//;
		   if (length $hex > 8 && !$Config{use64bitint}) {
		       # Croak if nv_preserves_uv_bits < 64 ?
		       $new .=         hex(substr($hex, -8)) +
			       2**32 * hex(substr($hex,  0, -8));
		       # The above will produce "errorneus" code
		       # if the hex constant was e.g. inside UINT64_C
		       # macro, but then again, h2ph is an approximation.
		   } else {
		       $new .= lc("0x$hex");
		   }
		   next;};
	s/^(-?\d+\.\d+E[-+]?\d+)[FL]?//i	&& do {$new .= $1; next;};
d354 1
a354 1
		last unless ($isatype{$_} or $_ eq 'struct' or $_ eq 'union');
d377 1
a377 1
	    if ($id eq 'struct' || $id eq 'union') {
d390 2
a391 2
	    } elsif (/^\s*\(/) {
		s/^\s*\((\w),/("$1",/ if $id =~ /^_IO[WR]*$/i;	# cheat
a417 79
sub next_line
{
    my $file = shift;
    my ($in, $out);
    my $pre_sub_tri_graphs = 1;

    READ: while (not eof IN) {
        $in  .= <IN>;
        chomp $in;
        next unless length $in;

        while (length $in) {
            if ($pre_sub_tri_graphs) {
                # Preprocess all tri-graphs 
                # including things stuck in quoted string constants.
                $in =~ s/\?\?=/#/g;                         # | ??=|  #|
                $in =~ s/\?\?\!/|/g;                        # | ??!|  ||
                $in =~ s/\?\?'/^/g;                         # | ??'|  ^|
                $in =~ s/\?\?\(/[/g;                        # | ??(|  [|
                $in =~ s/\?\?\)/]/g;                        # | ??)|  ]|
                $in =~ s/\?\?\-/~/g;                        # | ??-|  ~|
                $in =~ s/\?\?\//\\/g;                       # | ??/|  \|
                $in =~ s/\?\?</{/g;                         # | ??<|  {|
                $in =~ s/\?\?>/}/g;                         # | ??>|  }|
            }
	    if ($in =~ /^\#ifdef __LANGUAGE_PASCAL__/) {
                # Tru64 disassembler.h evilness: mixed C and Pascal.
		while (<IN>) {
		    last if /^\#endif/; 
		}
		next READ;
	    }
	    if ($in =~ /^extern inline / && # Inlined assembler.
		$^O eq 'linux' && $file =~ m!(?:^|/)asm/[^/]+\.h$!) {
 		while (<IN>) {
		    last if /^}/; 
		}
		next READ;
	    }
            if ($in =~ s/\\$//) {                           # \-newline
                $out    .= ' ';
                next READ;
            } elsif ($in =~ s/^([^"'\\\/]+)//) {            # Passthrough
                $out    .= $1;
            } elsif ($in =~ s/^(\\.)//) {                   # \...
                $out    .= $1;
            } elsif ($in =~ s/^('(\\.|[^'\\])*')//) {       # '...
                $out    .= $1;
            } elsif ($in =~ s/^("(\\.|[^"\\])*")//) {       # "...
                $out    .= $1;
            } elsif ($in =~ s/^\/\/.*//) {                  # //...
                # fall through
            } elsif ($in =~ m/^\/\*/) {                     # /*...
                # C comment removal adapted from perlfaq6:
                if ($in =~ s/^\/\*[^*]*\*+([^\/*][^*]*\*+)*\///) {
                    $out    .= ' ';
                } else {                                    # Incomplete /* */
                    next READ;
                }
            } elsif ($in =~ s/^(\/)//) {                    # /...
                $out    .= $1;
            } elsif ($in =~ s/^([^\'\"\\\/]+)//) {
                $out    .= $1;
            } elsif ($^O eq 'linux' &&
                     $file =~ m!(?:^|/)linux/byteorder/pdp_endian\.h$! &&
                     $in   =~ s!\'T KNOW!!) {
                $out    =~ s!I DON$!I_DO_NOT_KNOW!;
            } else {
		die "Cannot parse:\n$in\n";
            }
        }

        last READ if $out =~ /\S/;
    }

    return $out;
}


d566 1
a566 1
            if ($define{$_} =~ /^(\d+)U?L{0,2}$/i) {
d568 1
a568 1
                    "unless (defined &$_) { sub $_() { $1 } }\n\n";
a624 4

or

	cd /usr/include; h2ph * sys/* arpa/* netinet/*
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d45 2
a46 7
# Make sure read permissions for all are set:
if (defined umask && (umask() & 0444)) {
    umask (umask() & ~0444);
}

getopts('Dd:rlhaQe');
use vars qw($opt_D $opt_d $opt_r $opt_l $opt_h $opt_a $opt_Q $opt_e);
a67 1
my %bad_file = ();
a72 7
sub reindent($) {
    my($text) = shift;
    $text =~ s/\n/\n    /g;
    $text =~ s/        /\t/g;
    $text;
}

d74 1
a74 1
my ($incl, $incl_type, $next);
d110 1
a110 3
    print OUT
        "require '_h2ph_pre.ph';\n\n",
        "no warnings 'redefine';\n\n";
d172 5
a176 6
	    } elsif (/^(include|import|include_next)\s*[<\"](.*)[>\"]/) {
                $incl_type = $1;
                $incl = $2;
                if (($incl_type eq 'include_next') ||
                    ($opt_e && exists($bad_file{$incl}))) {
                    $incl =~ s/\.h$/.ph/;
a180 2
                    print OUT ($t, "my(\@@REM);\n");
                    if ($incl_type eq 'include_next') {
d183 1
a183 2
			           "(grep { \$_ eq \"$incl\" } ",
                                   "keys(\%INC));\n");
d185 1
a185 1
			           "\@@REM = map { \"\$_/$incl\" } ",
d187 1
a187 6
			           " and -f \"\$_/$incl\" } \@@INC);\n");
                    } else {
                        print OUT ($t,
                                   "\@@REM = map { \"\$_/$incl\" } ",
                                   "(grep {-r \"\$_/$incl\" } \@@INC);\n");
                    }
a195 4
                } else {
                    $incl =~ s/\.h$/.ph/;
		    print OUT $t,"require '$incl';\n";
                }
d277 2
a279 5
    if ($opt_e && exists($bad_file{$file})) {
        unlink($Dest_dir . '/' . $outfile);
        $next = '';
    } else {
        print OUT "1;\n";
a280 1
    }
d283 8
a290 3
if ($opt_e && (scalar(keys %bad_file) > 0)) {
    warn "Was unable to convert the following files:\n";
    warn "\t" . join("\n\t",sort(keys %bad_file)) . "\n";
a292 1
exit $Exit;
d466 4
a469 12
            } elsif ($in =~ /^'/) {                         # '...
                if ($in =~ s/^('(\\.|[^'\\])*')//) {
                    $out    .= $1;
                } else {
                    next READ;
                }
            } elsif ($in =~ /^"/) {                         # "...
                if ($in =~ s/^("(\\.|[^"\\])*")//) {
                    $out    .= $1;
                } else {
                    next READ;
                }
a487 7
                if ($opt_e) {
                    warn "Cannot parse $file:\n$in\n";
                    $bad_file{$file} = 1;
                    $in = '';
                    $out = undef;
                    last READ;
                } else {
a488 1
                }
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d61 1
a61 1
my @@isatype = qw(
d67 1
a67 2
	float	double	size_t
);
d136 1
a136 1
		    my $proto = '() ';
d138 1
a138 1
			$proto = '';
a148 1
		  EMIT:
d271 1
a271 1
	} elsif (/^\s*(typedef\s*)?enum\s*(\s+[a-zA-Z_]\w*\s*)?/) { # { for vi
a302 69
	} elsif (/^(?:__extension__\s+)?(?:extern|static)\s+(?:__)?inline(?:__)?\s+/
	    and !/;\s*$/ and !/{\s*}\s*$/)
	{ # { for vi
	    # This is a hack to parse the inline functions in the glibc headers.
	    # Warning: massive kludge ahead. We suppose inline functions
	    # are mainly constructed like macros.
	    while (1) {
		last unless defined ($next = next_line($file));
		chomp $next;
		undef $_, last if $next =~ /__THROW\s*;/
			       or $next =~ /^(__extension__|extern|static)\b/;
		$_ .= " $next";
		print OUT "# $next\n" if $opt_D;
		last if $next =~ /^}|^{.*}\s*$/;
	    }
	    next if not defined; # because it's only a prototype
	    s/\b(__extension__|extern|static|(?:__)?inline(?:__)?)\b//g;
	    # violently drop #ifdefs
	    s/#\s*if.*?#\s*endif//g
		and print OUT "# some #ifdef were dropped here -- fill in the blanks\n";
	    if (s/^(?:\w|\s|\*)*\s(\w+)\s*//) {
		$name = $1;
	    } else {
		warn "name not found"; next; # shouldn't occur...
	    }
	    my @@args;
	    if (s/^\(([^()]*)\)\s*(\w+\s*)*//) {
		for my $arg (split /,/, $1) {
		    if ($arg =~ /(\w+)\s*$/) {
			$curargs{$1} = 1;
			push @@args, $1;
		    }
		}
	    }
	    $args = (
		@@args
		? "local(" . (join ',', map "\$$_", @@args) . ") = \@@_;\n$t    "
		: ""
	    );
	    my $proto = @@args ? '' : '() ';
	    $new = '';
	    s/\breturn\b//g; # "return" doesn't occur in macros usually...
	    expr();
	    # try to find and perlify local C variables
	    our @@local_variables = (); # needs to be a our(): (?{...}) bug workaround
	    {
		use re "eval";
		my $typelist = join '|', keys %isatype;
		$new =~ s['
		  (?:(?:un)?signed\s+)?
		  (?:long\s+)?
		  (?:$typelist)\s+
		  (\w+)
		  (?{ push @@local_variables, $1 })
		  ']
		 [my \$$1]gx;
		$new =~ s['
		  (?:(?:un)?signed\s+)?
		  (?:long\s+)?
		  (?:$typelist)\s+
		  ' \s+ &(\w+) \s* ;
		  (?{ push @@local_variables, $1 })
		  ]
		 [my \$$1;]gx;
	     }
	    $new =~ s/&$_\b/\$$_/g for @@local_variables;
	    $new =~ s/(["\\])/\\$1/g;       #"]);
	    # now that's almost like a macro (we hope)
	    goto EMIT;
d311 1
a311 1
	queue_includes_from($file) if $opt_a;
a382 1
	    my $doit = 1;
d384 1
a384 7
	        unless($isatype{$_} or $_ eq 'struct' or $_ eq 'union'){
		    $doit = 0;
		    last;
		}
	    }
	    if( $doit ){
		s/\([\w\s]+[\*\s]*\)// && next;      # then eliminate them.
d386 1
d473 1
a473 1
	    if ($in =~ s/^\#ifdef __LANGUAGE_PASCAL__//) {
d480 2
a481 2
	    # Skip inlined functions in headers
	    if ($in =~ s/^(extern|static) (__inline__|inline) .*[^;]\s*$//) {
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d550 1
a550 1
	    if ($in =~ /^\#ifdef __LANGUAGE_PASCAL__/) {
d557 2
a558 2
	    if ($in =~ /^extern inline / && # Inlined assembler.
		$^O eq 'linux' && $file =~ m!(?:^|/)asm/[^/]+\.h$!) {
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d145 1
a145 1
			$args = "my($args) = \@@_;\n$t    ";
a278 2
		# #defines in enums (aliases)
		$next =~ s/^\s*#\s*define\s+(\w+)\s+(\w+)\s*$/$1 = $2,/;
a290 1
		$enum_name or next;
d341 1
a341 1
		? "my(" . (join ',', map "\$$_", @@args) . ") = \@@_;\n$t    "
a353 1
		  (?:(?:__)?const(?:__)?\s+)?
a361 1
		  (?:(?:__)?const(?:__)?\s+)?
a393 1
    $new = '"(assembly code)"' and return if /\b__asm__\b/; # freak out.
d402 1
a402 1
	s/^0X([0-9A-F]+)[UL]*//i
d538 1
a538 1
                # Preprocess all tri-graphs
d551 1
a551 1
		# Tru64 disassembler.h evilness: mixed C and Pascal.
d553 1
a553 1
		    last if /^\#endif/;
a554 1
		$in = "";
d559 2
a560 2
		while (<IN>) {
		    last if /^}/;
a561 1
		$in = "";
d731 3
a733 9
    my $from_gcc    = `LC_ALL=C $Config{cc} -v 2>&1`;
    if( !( $from_gcc =~ s:^Reading specs from (.*?)/specs\b.*:$1/include:s ) )
    { # gcc-4+ :
       $from_gcc   = `LC_ALL=C $Config{cc} -print-search-dirs 2>&1`;
       if ( !($from_gcc =~ s/^install:\s*([^\s]+[^\s\/])([\s\/]*).*$/$1\/include/s) )
       {
           $from_gcc = '';
       };
    };
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d517 1
a517 1
		    $new .= '(defined(&' . $id . ') ? &' . $id . ' : undef)';
d775 1
a775 1
	print PREAMBLE "# This file was created by h2ph version $VERSION\n";
d777 17
a793 25
	foreach (sort keys %define) {
	    if ($opt_D) {
		print PREAMBLE "# $_=$define{$_}\n";
	    }
	    if ($define{$_} =~ /^\((.*)\)$/) {
		# parenthesized value:  d=(v)
		$define{$_} = $1;
	    }
	    if ($define{$_} =~ /^([+-]?(\d+)?\.\d+([eE][+-]?\d+)?)[FL]?$/) {
		# float:
		print PREAMBLE
		    "unless (defined &$_) { sub $_() { $1 } }\n\n";
	    } elsif ($define{$_} =~ /^([+-]?\d+)U?L{0,2}$/i) {
		# integer:
		print PREAMBLE
		    "unless (defined &$_) { sub $_() { $1 } }\n\n";
	    } elsif ($define{$_} =~ /^\w+$/) {
		print PREAMBLE
		    "unless (defined &$_) { sub $_() { &$define{$_} } }\n\n";
	    } else {
		print PREAMBLE
		    "unless (defined &$_) { sub $_() { \"",
		    quotemeta($define{$_}), "\" } }\n\n";
	    }
	}
d805 1
a805 1
	@@Config{'ccsymbols', 'cppsymbols', 'cppccsymbols'};
d808 6
a813 5
    while ($allsymbols =~ /([^\s]+)=((\\\s|[^\s])+)/g) {
	$define{$1} = $2;
	if ($opt_D) {
	    print STDERR "$_:  $1 -> $2\n";
	}
d863 1
a863 1
beneath the default Perl library location (C<$Config{'installsitearch'}>).
d948 2
a949 2
	FIRST_VALUE,
	SECOND_VALUE,
d951 1
a951 1
	THIRD_VALUE
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d88 1
a88 1
my ($incl, $incl_type, $incl_quote, $next);
d126 1
a126 1
        "no warnings qw(redefine misc);\n\n";
d189 1
a189 1
	    } elsif (/^(include|import|include_next)\s*([<\"])(.*)[>\"]/) {
d191 1
a191 2
                $incl_quote = $2;
                $incl = $3;
a223 4
                    # copy the prefix in the quote syntax (#include "x.h") case
                    if ($incl !~ m|/| && $incl_quote eq q{"} && $file =~ m|^(.*)/|) {
                        $incl = "$1/$incl";
                    }
d727 2
a728 7
            if ($line =~ /^#\s*include\s+([<"])(.*?)[>"]/) {
                my ($delimiter, $new_file) = ($1, $2);
                # copy the prefix in the quote syntax (#include "x.h") case
                if ($delimiter eq q{"} && $file =~ m|^(.*)/|) {
                    $new_file = "$1/$new_file";
                }
                push(@@ARGV, $new_file) unless $Is_converted{$new_file};
d736 1
a736 1
# non-GCC?) C compilers, but gcc uses additional include directories.
d748 1
a748 1
    length($from_gcc) ? ($from_gcc, $from_gcc . "-fixed", $Config{usrinc}) : ($Config{usrinc});
a801 1
	print PREAMBLE "\n1;\n";  # avoid 'did not return a true value' when empty
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d512 1
a512 1
		if ($new =~ /\{\s*$/) {
d521 2
a522 8
		if ($inif) {
		    if ($new =~ /defined\s*$/) {
			$new .= '(&' . $id . ')';
		    } elsif ($new =~ /defined\s*\($/) {
			$new .= '&' . $id;
		    } else {
			$new .= '(defined(&' . $id . ') ? &' . $id . ' : undef)';
		    }
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d99 1
a99 1
    # $eval_index goes into '#line' directives, to help locate syntax errors:
d150 17
a166 1
		    EMIT($proto);
a169 1

a170 4

		    # Shunt around such directives as '#define FOO FOO':
		    next if $new =~ /^\s*&\Q$name\E\s*\z/;

d173 12
a184 1
		    $new =~ s/(['\\])/\\$1/g;        #']);
d186 1
a186 4
	    	    print OUT $t, 'eval ';
		    if ($opt_h) {
			print OUT "\"\\n#line $eval_index $outfile\\n\" . ";
			$eval_index++;
a187 1
		    print OUT "'sub $name () {$new;}' unless defined(&$name);\n";
d383 1
a383 1
	    EMIT($proto);
a402 22
sub EMIT {
    my $proto = shift;

    $new = reindent($new);
    $args = reindent($args);
    if ($t ne '') {
    $new =~ s/(['\\])/\\$1/g;   #']);
    if ($opt_h) {
        print OUT $t,
                    "eval \"\\n#line $eval_index $outfile\\n\" . 'sub $name $proto\{\n$t    ${args}eval q($new);\n$t}' unless defined(\&$name);\n";
                    $eval_index++;
    } else {
        print OUT $t,
                    "eval 'sub $name $proto\{\n$t    ${args}eval q($new);\n$t}' unless defined(\&$name);\n";
    }
    } else {
              print OUT "unless(defined(\&$name)) {\n    sub $name $proto\{\n\t${args}eval q($new);\n    }\n}\n";
    }
    %curargs = ();
    return;
}

d404 1
a404 4
    if (/\b__asm__\b/) {	# freak out
	$new = '"(assembly code)"';
	return
    }
d420 1
a420 1
		       # The above will produce "erroneous" code
d654 1
a654 1
                print STDERR "Skipping directory '$file'\n";
d659 1
a659 1
            print STDERR "Skipping '$file':  not a file or directory\n";
d755 10
a764 2
    my $from_gcc   = `LC_ALL=C $Config{cc} -v -E - < /dev/null 2>&1 | awk '/^#include/, /^End of search list/' | grep '^ '`;
    length($from_gcc) ? (split(' ', $from_gcc), $Config{usrinc}) : ($Config{usrinc});
d773 1
a773 1
    my $VERSION     = 3;
d801 1
a801 10
	    if (/^(\w+)\((\w)\)$/) {
		my($macro, $arg) = ($1, $2);
		my $def = $define{$_};
		$def =~ s/$arg/\$\{$arg\}/g;
		print PREAMBLE <<DEFINE;
unless (defined &$macro) { sub $macro(\$) { my (\$$arg) = \@@_; \"$def\" } }

DEFINE
	    } elsif
		($define{$_} =~ /^([+-]?(\d+)?\.\d+([eE][+-]?\d+)?)[FL]?$/) {
d810 2
a811 8
		my $def = $define{$_};
		if ($isatype{$def}) {
		  print PREAMBLE
		    "unless (defined &$_) { sub $_() { \"$def\" } }\n\n";
		} else {
		  print PREAMBLE
		    "unless (defined &$_) { sub $_() { &$def } }\n\n";
	        }
d832 1
a832 1
    # Split compiler pre-definitions into 'key=value' pairs:
d909 1
a909 1
Put 'hints' in the .ph files which will help in locating problems with
d928 1
a928 1
'Quiet' mode; don't print out the names of the files being converted.
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d869 1
a869 2
B<h2ph [-d destination directory] [-r | -a] [-l] [-h] [-e] [-D] [-Q]
[headerfiles]>
a933 5

=item -e

If an error is encountered during conversion, output file will be removed and
a warning emitted instead of terminating the conversion immediately.
@


1.1.1.15
log
@Import perl-5.24.2
@
text
@a38 2
BEGIN { pop @@INC if $INC[-1] eq '.' }

d772 1
a772 1
    my $VERSION     = 4;
a790 5
        # Prevent non-portable hex constants from warning.
        #
        # We still produce an overflow warning if we can't represent
        # a hex constant as an integer.
        print PREAMBLE "no warnings qw(portable);\n";
a816 12
            } elsif ($define{$_} =~ /^([+-]?0x[\da-f]+)U?L{0,2}$/i) {
                # hex integer
                # Special cased, since perl warns on hex integers
                # that can't be represented in a UV.
                #
                # This way we get the warning at time of use, so the user
                # only gets the warning if they happen to use this
                # platform-specific definition.
                my $code = $1;
                $code = "hex('$code')" if length $code > 10;
                print PREAMBLE
                    "unless (defined &$_) { sub $_() { $code } }\n\n";
@


