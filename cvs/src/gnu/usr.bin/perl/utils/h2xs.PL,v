head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.8
	OPENBSD_6_2_BASE:1.17
	PERL_5_24_2:1.1.1.17
	OPENBSD_6_1:1.17.0.6
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.17
date	2016.07.25.10.53.04;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	FHUgABTHZQuYQh2B;

1.16
date	2014.11.17.20.57.08;	author afresh1;	state Exp;
branches
	1.16.4.1
	1.16.6.1;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.07.10;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.36.20;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.23.13;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.10.32;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.10;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.50;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.38;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.42;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.42;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.06.03;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.25;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.25;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.57;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.57;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.26.12;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.34;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.45;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.48.38;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.18.22;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.49.49;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.19.03;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.47;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.49.14;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.09.39;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.53.19;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	B31cAbBIXiCqnL97;

1.1.1.17
date	2017.08.14.13.46.26;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;

1.16.4.1
date	2016.08.05.01.01.40;	author afresh1;	state Exp;
branches;
next	;
commitid	HjAJx2yjL4A8HWon;

1.16.6.1
date	2016.08.05.01.00.56;	author afresh1;	state Exp;
branches;
next	;
commitid	wK3bUiy9jNch0Key;


desc
@@


1.17
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.


ok deraadt@@
@
text
@#!/usr/local/bin/perl

use Config;
use File::Basename qw(&basename &dirname);
use Cwd;

# List explicitly here the variables you want Configure to
# generate.  Metaconfig only looks for shell variables, so you
# have to mention them as if they were shell variables, not
# %Config entries.  Thus you write
#  $startperl
# to ensure Configure will look for $Config{startperl}.

# This forces PL files to create target in same directory as PL file.
# This is so that make depend always knows where to find PL derivatives.
my $origdir = cwd;
chdir dirname($0);
my $file = basename($0, '.PL');
$file .= '.com' if $^O eq 'VMS';

open OUT,">$file" or die "Can't create $file: $!";

print "Extracting $file (with variable substitutions)\n";

# In this section, perl variables will be expanded during extraction.
# You can use $Config{...} to use Configure variables.

print OUT <<"!GROK!THIS!";
$Config{startperl}
    eval 'exec $Config{perlpath} -S \$0 \${1+"\$@@"}'
	if \$running_under_some_shell;
!GROK!THIS!

# In the following, perl variables are not expanded during extraction.

print OUT <<'!NO!SUBS!';

BEGIN { pop @@INC if $INC[-1] eq '.' }

use warnings;

=head1 NAME

h2xs - convert .h C header files to Perl extensions

=head1 SYNOPSIS

B<h2xs> [B<OPTIONS> ...] [headerfile ... [extra_libraries]]

B<h2xs> B<-h>|B<-?>|B<--help>

=head1 DESCRIPTION

I<h2xs> builds a Perl extension from C header files.  The extension
will include functions which can be used to retrieve the value of any
#define statement which was in the C header files.

The I<module_name> will be used for the name of the extension.  If
module_name is not supplied then the name of the first header file
will be used, with the first character capitalized.

If the extension might need extra libraries, they should be included
here.  The extension Makefile.PL will take care of checking whether
the libraries actually exist and how they should be loaded.  The extra
libraries should be specified in the form -lm -lposix, etc, just as on
the cc command line.  By default, the Makefile.PL will search through
the library path determined by Configure.  That path can be augmented
by including arguments of the form B<-L/another/library/path> in the
extra-libraries argument.

In spite of its name, I<h2xs> may also be used to create a skeleton pure
Perl module. See the B<-X> option.

=head1 OPTIONS

=over 5

=item B<-A>, B<--omit-autoload>

Omit all autoload facilities.  This is the same as B<-c> but also
removes the S<C<use AutoLoader>> statement from the .pm file.

=item B<-B>, B<--beta-version>

Use an alpha/beta style version number.  Causes version number to
be "0.00_01" unless B<-v> is specified.

=item B<-C>, B<--omit-changes>

Omits creation of the F<Changes> file, and adds a HISTORY section to
the POD template.

=item B<-F>, B<--cpp-flags>=I<addflags>

Additional flags to specify to C preprocessor when scanning header for
function declarations.  Writes these options in the generated F<Makefile.PL>
too.

=item B<-M>, B<--func-mask>=I<regular expression>

selects functions/macros to process.

=item B<-O>, B<--overwrite-ok>

Allows a pre-existing extension directory to be overwritten.

=item B<-P>, B<--omit-pod>

Omit the autogenerated stub POD section.

=item B<-X>, B<--omit-XS>

Omit the XS portion. Used to generate a skeleton pure Perl module.
C<-c> and C<-f> are implicitly enabled.

=item B<-a>, B<--gen-accessors>

Generate an accessor method for each element of structs and unions. The
generated methods are named after the element name; will return the current
value of the element if called without additional arguments; and will set
the element to the supplied value (and return the new value) if called with
an additional argument. Embedded structures and unions are returned as a
pointer rather than the complete structure, to facilitate chained calls.

These methods all apply to the Ptr type for the structure; additionally
two methods are constructed for the structure type itself, C<_to_ptr>
which returns a Ptr type pointing to the same structure, and a C<new>
method to construct and return a new structure, initialised to zeroes.

=item B<-b>, B<--compat-version>=I<version>

Generates a .pm file which is backwards compatible with the specified
perl version.

For versions < 5.6.0, the changes are.
    - no use of 'our' (uses 'use vars' instead)
    - no 'use warnings'

Specifying a compatibility version higher than the version of perl you
are using to run h2xs will have no effect.  If unspecified h2xs will default
to compatibility with the version of perl you are using to run h2xs.

=item B<-c>, B<--omit-constant>

Omit C<constant()> from the .xs file and corresponding specialised
C<AUTOLOAD> from the .pm file.

=item B<-d>, B<--debugging>

Turn on debugging messages.

=item B<-e>, B<--omit-enums>=[I<regular expression>]

If I<regular expression> is not given, skip all constants that are defined in
a C enumeration. Otherwise skip only those constants that are defined in an
enum whose name matches I<regular expression>.

Since I<regular expression> is optional, make sure that this switch is followed
by at least one other switch if you omit I<regular expression> and have some
pending arguments such as header-file names. This is ok:

    h2xs -e -n Module::Foo foo.h

This is not ok:

    h2xs -n Module::Foo -e foo.h

In the latter, foo.h is taken as I<regular expression>.

=item B<-f>, B<--force>

Allows an extension to be created for a header even if that header is
not found in standard include directories.

=item B<-g>, B<--global>

Include code for safely storing static data in the .xs file.
Extensions that do no make use of static data can ignore this option.

=item B<-h>, B<-?>, B<--help>

Print the usage, help and version for this h2xs and exit.

=item B<-k>, B<--omit-const-func>

For function arguments declared as C<const>, omit the const attribute in the
generated XS code.

=item B<-m>, B<--gen-tied-var>

B<Experimental>: for each variable declared in the header file(s), declare
a perl variable of the same name magically tied to the C variable.

=item B<-n>, B<--name>=I<module_name>

Specifies a name to be used for the extension, e.g., S<-n RPC::DCE>

=item B<-o>, B<--opaque-re>=I<regular expression>

Use "opaque" data type for the C types matched by the regular
expression, even if these types are C<typedef>-equivalent to types
from typemaps.  Should not be used without B<-x>.

This may be useful since, say, types which are C<typedef>-equivalent
to integers may represent OS-related handles, and one may want to work
with these handles in OO-way, as in C<$handle-E<gt>do_something()>.
Use C<-o .> if you want to handle all the C<typedef>ed types as opaque
types.

The type-to-match is whitewashed (except for commas, which have no
whitespace before them, and multiple C<*> which have no whitespace
between them).

=item B<-p>, B<--remove-prefix>=I<prefix>

Specify a prefix which should be removed from the Perl function names,
e.g., S<-p sec_rgy_> This sets up the XS B<PREFIX> keyword and removes
the prefix from functions that are autoloaded via the C<constant()>
mechanism.

=item B<-s>, B<--const-subs>=I<sub1,sub2>

Create a perl subroutine for the specified macros rather than autoload
with the constant() subroutine.  These macros are assumed to have a
return type of B<char *>, e.g.,
S<-s sec_rgy_wildcard_name,sec_rgy_wildcard_sid>.

=item B<-t>, B<--default-type>=I<type>

Specify the internal type that the constant() mechanism uses for macros.
The default is IV (signed integer).  Currently all macros found during the
header scanning process will be assumed to have this type.  Future versions
of C<h2xs> may gain the ability to make educated guesses.

=item B<--use-new-tests>

When B<--compat-version> (B<-b>) is present the generated tests will use
C<Test::More> rather than C<Test> which is the default for versions before
5.6.2.  C<Test::More> will be added to PREREQ_PM in the generated
C<Makefile.PL>.

=item B<--use-old-tests>

Will force the generation of test code that uses the older C<Test> module.

=item B<--skip-exporter>

Do not use C<Exporter> and/or export any symbol.

=item B<--skip-ppport>

Do not use C<Devel::PPPort>: no portability to older version.

=item B<--skip-autoloader>

Do not use the module C<AutoLoader>; but keep the constant() function
and C<sub AUTOLOAD> for constants.

=item B<--skip-strict>

Do not use the pragma C<strict>.

=item B<--skip-warnings>

Do not use the pragma C<warnings>.

=item B<-v>, B<--version>=I<version>

Specify a version number for this extension.  This version number is added
to the templates.  The default is 0.01, or 0.00_01 if C<-B> is specified.
The version specified should be numeric.

=item B<-x>, B<--autogen-xsubs>

Automatically generate XSUBs basing on function declarations in the
header file.  The package C<C::Scan> should be installed. If this
option is specified, the name of the header file may look like
C<NAME1,NAME2>. In this case NAME1 is used instead of the specified
string, but XSUBs are emitted only for the declarations included from
file NAME2.

Note that some types of arguments/return-values for functions may
result in XSUB-declarations/typemap-entries which need
hand-editing. Such may be objects which cannot be converted from/to a
pointer (like C<long long>), pointers to functions, or arrays.  See
also the section on L<LIMITATIONS of B<-x>>.

=back

=head1 EXAMPLES


    # Default behavior, extension is Rusers
    h2xs rpcsvc/rusers

    # Same, but extension is RUSERS
    h2xs -n RUSERS rpcsvc/rusers

    # Extension is rpcsvc::rusers. Still finds <rpcsvc/rusers.h>
    h2xs rpcsvc::rusers

    # Extension is ONC::RPC.  Still finds <rpcsvc/rusers.h>
    h2xs -n ONC::RPC rpcsvc/rusers

    # Without constant() or AUTOLOAD
    h2xs -c rpcsvc/rusers

    # Creates templates for an extension named RPC
    h2xs -cfn RPC

    # Extension is ONC::RPC.
    h2xs -cfn ONC::RPC

    # Extension is a pure Perl module with no XS code.
    h2xs -X My::Module

    # Extension is Lib::Foo which works at least with Perl5.005_03.
    # Constants are created for all #defines and enums h2xs can find
    # in foo.h.
    h2xs -b 5.5.3 -n Lib::Foo foo.h

    # Extension is Lib::Foo which works at least with Perl5.005_03.
    # Constants are created for all #defines but only for enums
    # whose names do not start with 'bar_'.
    h2xs -b 5.5.3 -e '^bar_' -n Lib::Foo foo.h

    # Makefile.PL will look for library -lrpc in
    # additional directory /opt/net/lib
    h2xs rpcsvc/rusers -L/opt/net/lib -lrpc

    # Extension is DCE::rgynbase
    # prefix "sec_rgy_" is dropped from perl function names
    h2xs -n DCE::rgynbase -p sec_rgy_ dce/rgynbase

    # Extension is DCE::rgynbase
    # prefix "sec_rgy_" is dropped from perl function names
    # subroutines are created for sec_rgy_wildcard_name and
    # sec_rgy_wildcard_sid
    h2xs -n DCE::rgynbase -p sec_rgy_ \
    -s sec_rgy_wildcard_name,sec_rgy_wildcard_sid dce/rgynbase

    # Make XS without defines in perl.h, but with function declarations
    # visible from perl.h. Name of the extension is perl1.
    # When scanning perl.h, define -DEXT=extern -DdEXT= -DINIT(x)=
    # Extra backslashes below because the string is passed to shell.
    # Note that a directory with perl header files would
    #  be added automatically to include path.
    h2xs -xAn perl1 -F "-DEXT=extern -DdEXT= -DINIT\(x\)=" perl.h

    # Same with function declaration in proto.h as visible from perl.h.
    h2xs -xAn perl2 perl.h,proto.h

    # Same but select only functions which match /^av_/
    h2xs -M '^av_' -xAn perl2 perl.h,proto.h

    # Same but treat SV* etc as "opaque" types
    h2xs -o '^[S]V \*$' -M '^av_' -xAn perl2 perl.h,proto.h

=head2 Extension based on F<.h> and F<.c> files

Suppose that you have some C files implementing some functionality,
and the corresponding header files.  How to create an extension which
makes this functionality accessible in Perl?  The example below
assumes that the header files are F<interface_simple.h> and
I<interface_hairy.h>, and you want the perl module be named as
C<Ext::Ension>.  If you need some preprocessor directives and/or
linking with external libraries, see the flags C<-F>, C<-L> and C<-l>
in L<"OPTIONS">.

=over

=item Find the directory name

Start with a dummy run of h2xs:

  h2xs -Afn Ext::Ension

The only purpose of this step is to create the needed directories, and
let you know the names of these directories.  From the output you can
see that the directory for the extension is F<Ext/Ension>.

=item Copy C files

Copy your header files and C files to this directory F<Ext/Ension>.

=item Create the extension

Run h2xs, overwriting older autogenerated files:

  h2xs -Oxan Ext::Ension interface_simple.h interface_hairy.h

h2xs looks for header files I<after> changing to the extension
directory, so it will find your header files OK.

=item Archive and test

As usual, run

  cd Ext/Ension
  perl Makefile.PL
  make dist
  make
  make test

=item Hints

It is important to do C<make dist> as early as possible.  This way you
can easily merge(1) your changes to autogenerated files if you decide
to edit your C<.h> files and rerun h2xs.

Do not forget to edit the documentation in the generated F<.pm> file.

Consider the autogenerated files as skeletons only, you may invent
better interfaces than what h2xs could guess.

Consider this section as a guideline only, some other options of h2xs
may better suit your needs.

=back

=head1 ENVIRONMENT

No environment variables are used.

=head1 AUTHOR

Larry Wall and others

=head1 SEE ALSO

L<perl>, L<perlxstut>, L<ExtUtils::MakeMaker>, and L<AutoLoader>.

=head1 DIAGNOSTICS

The usual warnings if it cannot read or write the files involved.

=head1 LIMITATIONS of B<-x>

F<h2xs> would not distinguish whether an argument to a C function
which is of the form, say, C<int *>, is an input, output, or
input/output parameter.  In particular, argument declarations of the
form

    int
    foo(n)
	int *n

should be better rewritten as

    int
    foo(n)
	int &n

if C<n> is an input parameter.

Additionally, F<h2xs> has no facilities to intuit that a function

   int
   foo(addr,l)
	char *addr
	int   l

takes a pair of address and length of data at this address, so it is better
to rewrite this function as

    int
    foo(sv)
	    SV *addr
	PREINIT:
	    STRLEN len;
	    char *s;
	CODE:
	    s = SvPV(sv,len);
	    RETVAL = foo(s, len);
	OUTPUT:
	    RETVAL

or alternately

    static int
    my_foo(SV *sv)
    {
	STRLEN len;
	char *s = SvPV(sv,len);

	return foo(s, len);
    }

    MODULE = foo	PACKAGE = foo	PREFIX = my_

    int
    foo(sv)
	SV *sv

See L<perlxs> and L<perlxstut> for additional details.

=cut

# ' # Grr
use strict;


my( $H2XS_VERSION ) = ' $Revision: 1.23 $ ' =~ /\$Revision:\s+([^\s]+)/;
my $TEMPLATE_VERSION = '0.01';
my @@ARGS = @@ARGV;
my $compat_version = $];

use Getopt::Long;
use Config;
use Text::Wrap;
$Text::Wrap::huge = 'overflow';
$Text::Wrap::columns = 80;
use ExtUtils::Constant qw (WriteConstants WriteMakefileSnippet autoload);
use File::Compare;
use File::Path;

sub usage {
    warn "@@_\n" if @@_;
    die <<EOFUSAGE;
h2xs [OPTIONS ... ] [headerfile [extra_libraries]]
version: $H2XS_VERSION
OPTIONS:
    -A, --omit-autoload   Omit all autoloading facilities (implies -c).
    -B, --beta-version    Use beta \$VERSION of 0.00_01 (ignored if -v).
    -C, --omit-changes    Omit creating the Changes file, add HISTORY heading
                          to stub POD.
    -F, --cpp-flags       Additional flags for C preprocessor/compile.
    -M, --func-mask       Mask to select C functions/macros
                          (default is select all).
    -O, --overwrite-ok    Allow overwriting of a pre-existing extension directory.
    -P, --omit-pod        Omit the stub POD section.
    -X, --omit-XS         Omit the XS portion (implies both -c and -f).
    -a, --gen-accessors   Generate get/set accessors for struct and union members
                          (used with -x).
    -b, --compat-version  Specify a perl version to be backwards compatible with.
    -c, --omit-constant   Omit the constant() function and specialised AUTOLOAD
                          from the XS file.
    -d, --debugging       Turn on debugging messages.
    -e, --omit-enums      Omit constants from enums in the constant() function.
                          If a pattern is given, only the matching enums are
                          ignored.
    -f, --force           Force creation of the extension even if the C header
                          does not exist.
    -g, --global          Include code for safely storing static data in the .xs file.
    -h, -?, --help        Display this help message.
    -k, --omit-const-func Omit 'const' attribute on function arguments
                          (used with -x).
    -m, --gen-tied-var    Generate tied variables for access to declared
                          variables.
    -n, --name            Specify a name to use for the extension (recommended).
    -o, --opaque-re       Regular expression for \"opaque\" types.
    -p, --remove-prefix   Specify a prefix which should be removed from the
                          Perl function names.
    -s, --const-subs      Create subroutines for specified macros.
    -t, --default-type    Default type for autoloaded constants (default is IV).
        --use-new-tests   Use Test::More in backward compatible modules.
        --use-old-tests   Use the module Test rather than Test::More.
        --skip-exporter   Do not export symbols.
        --skip-ppport     Do not use portability layer.
        --skip-autoloader Do not use the module C<AutoLoader>.
        --skip-strict     Do not use the pragma C<strict>.
        --skip-warnings   Do not use the pragma C<warnings>.
    -v, --version         Specify a version number for this extension.
    -x, --autogen-xsubs   Autogenerate XSUBs using C::Scan.
        --use-xsloader    Use XSLoader in backward compatible modules (ignored
                          when used with -X).

extra_libraries
         are any libraries that might be needed for loading the
         extension, e.g. -lm would try to link in the math library.
EOFUSAGE
}

my ($opt_A,
    $opt_B,
    $opt_C,
    $opt_F,
    $opt_M,
    $opt_O,
    $opt_P,
    $opt_X,
    $opt_a,
    $opt_c,
    $opt_d,
    $opt_e,
    $opt_f,
    $opt_g,
    $opt_h,
    $opt_k,
    $opt_m,
    $opt_n,
    $opt_o,
    $opt_p,
    $opt_s,
    $opt_v,
    $opt_x,
    $opt_b,
    $opt_t,
    $new_test,
    $old_test,
    $skip_exporter,
    $skip_ppport,
    $skip_autoloader,
    $skip_strict,
    $skip_warnings,
    $use_xsloader
   );

Getopt::Long::Configure('bundling');
Getopt::Long::Configure('pass_through');

my %options = (
                'omit-autoload|A'    => \$opt_A,
                'beta-version|B'     => \$opt_B,
                'omit-changes|C'     => \$opt_C,
                'cpp-flags|F=s'      => \$opt_F,
                'func-mask|M=s'      => \$opt_M,
                'overwrite_ok|O'     => \$opt_O,
                'omit-pod|P'         => \$opt_P,
                'omit-XS|X'          => \$opt_X,
                'gen-accessors|a'    => \$opt_a,
                'compat-version|b=s' => \$opt_b,
                'omit-constant|c'    => \$opt_c,
                'debugging|d'        => \$opt_d,
                'omit-enums|e:s'     => \$opt_e,
                'force|f'            => \$opt_f,
                'global|g'           => \$opt_g,
                'help|h|?'           => \$opt_h,
                'omit-const-func|k'  => \$opt_k,
                'gen-tied-var|m'     => \$opt_m,
                'name|n=s'           => \$opt_n,
                'opaque-re|o=s'      => \$opt_o,
                'remove-prefix|p=s'  => \$opt_p,
                'const-subs|s=s'     => \$opt_s,
                'default-type|t=s'   => \$opt_t,
                'version|v=s'        => \$opt_v,
                'autogen-xsubs|x'    => \$opt_x,
                'use-new-tests'      => \$new_test,
                'use-old-tests'      => \$old_test,
                'skip-exporter'      => \$skip_exporter,
                'skip-ppport'        => \$skip_ppport,
                'skip-autoloader'    => \$skip_autoloader,
                'skip-warnings'      => \$skip_warnings,
                'skip-strict'        => \$skip_strict,
                'use-xsloader'       => \$use_xsloader,
              );

GetOptions(%options) || usage;

usage if $opt_h;

if( $opt_b ){
    usage "You cannot use -b and -m at the same time.\n" if ($opt_b && $opt_m);
    $opt_b =~ /^v?(\d+)\.(\d+)\.(\d+)/ ||
    usage "You must provide the backwards compatibility version in X.Y.Z form. "
          .  "(i.e. 5.5.0)\n";
    my ($maj,$min,$sub) = ($1,$2,$3);
    if ($maj < 5 || ($maj == 5 && $min < 6)) {
        $compat_version =
	    $sub ? sprintf("%d.%03d%02d",$maj,$min,$sub) :
	           sprintf("%d.%03d",    $maj,$min);
    } else {
        $compat_version = sprintf("%d.%03d%03d",$maj,$min,$sub);
    }
} else {
    my ($maj,$min,$sub) = $compat_version =~ /(\d+)\.(\d\d\d)(\d*)/;
    $sub ||= 0;
    warn sprintf <<'EOF', $maj,$min,$sub;
Defaulting to backwards compatibility with perl %d.%d.%d
If you intend this module to be compatible with earlier perl versions, please
specify a minimum perl version with the -b option.

EOF
}

if( $opt_B ){
    $TEMPLATE_VERSION = '0.00_01';
}

if( $opt_v ){
	$TEMPLATE_VERSION = $opt_v;

    # check if it is numeric
    my $temp_version = $TEMPLATE_VERSION;
    my $beta_version = $temp_version =~ s/(\d)_(\d\d)/$1$2/;
    my $notnum;
    {
        local $SIG{__WARN__} = sub { $notnum = 1 };
        use warnings 'numeric';
        $temp_version = 0+$temp_version;
    }

    if ($notnum) {
        my $module = $opt_n || 'Your::Module';
        warn <<"EOF";
You have specified a non-numeric version.  Unless you supply an
appropriate VERSION class method, users may not be able to specify a
minimum required version with C<use $module versionnum>.

EOF
    }
    else {
        $opt_B = $beta_version;
    }
}

# -A implies -c.
$skip_autoloader = $opt_c = 1 if $opt_A;

# -X implies -c and -f
$opt_c = $opt_f = 1 if $opt_X;

$opt_t ||= 'IV';

my %const_xsub;
%const_xsub = map { $_,1 } split(/,+/, $opt_s) if $opt_s;

my $extralibs = '';

my @@path_h;

while (my $arg = shift) {
    if ($arg =~ /^-l/i) {
        $extralibs .= "$arg ";
        next;
    }
    last if $extralibs;
    push(@@path_h, $arg);
}

usage "Must supply header file or module name\n"
        unless (@@path_h or $opt_n);

my $fmask;
my $tmask;

$fmask = qr{$opt_M} if defined $opt_M;
$tmask = qr{$opt_o} if defined $opt_o;
my $tmask_all = $tmask && $opt_o eq '.';

if ($opt_x) {
  eval {require C::Scan; 1}
    or die <<EOD;
C::Scan required if you use -x option.
To install C::Scan, execute
   perl -MCPAN -e "install C::Scan"
EOD
  unless ($tmask_all) {
    $C::Scan::VERSION >= 0.70
      or die <<EOD;
C::Scan v. 0.70 or later required unless you use -o . option.
You have version $C::Scan::VERSION installed as $INC{'C/Scan.pm'}.
To install C::Scan, execute
   perl -MCPAN -e "install C::Scan"
EOD
  }
  if (($opt_m || $opt_a) && $C::Scan::VERSION < 0.73) {
    die <<EOD;
C::Scan v. 0.73 or later required to use -m or -a options.
You have version $C::Scan::VERSION installed as $INC{'C/Scan.pm'}.
To install C::Scan, execute
   perl -MCPAN -e "install C::Scan"
EOD
  }
}
elsif ($opt_o or $opt_F) {
  warn <<EOD if $opt_o;
Option -o does not make sense without -x.
EOD
  warn <<EOD if $opt_F and $opt_X ;
Option -F does not make sense with -X.
EOD
}

my @@path_h_ini = @@path_h;
my ($name, %fullpath, %prefix, %seen_define, %prefixless, %const_names);

my $module = $opt_n;

if( @@path_h ){
    use File::Spec;
    my @@paths;
    my $pre_sub_tri_graphs = 1;
    if ($^O eq 'VMS') {  # Consider overrides of default location
      # XXXX This is not equivalent to what the older version did:
      #		it was looking at $hadsys header-file per header-file...
      my($hadsys) = grep s!^sys/!!i , @@path_h;
      @@paths = qw( Sys$Library VAXC$Include );
      push @@paths, ($hadsys ? 'GNU_CC_Include[vms]' : 'GNU_CC_Include[000000]');
      push @@paths, qw( DECC$Library_Include DECC$System_Include );
    }
    else {
      @@paths = (File::Spec->curdir(), $Config{usrinc},
		(split / +/, $Config{locincpth} // ""), '/usr/include');
    }
    foreach my $path_h (@@path_h) {
        $name ||= $path_h;
    $module ||= do {
      $name =~ s/\.h$//;
      if ( $name !~ /::/ ) {
	$name =~ s#^.*/##;
	$name = "\u$name";
      }
      $name;
    };

    if( $path_h =~ s#::#/#g && $opt_n ){
	warn "Nesting of headerfile ignored with -n\n";
    }
    $path_h .= ".h" unless $path_h =~ /\.h$/;
    my $fullpath = $path_h;
    $path_h =~ s/,.*$// if $opt_x;
    $fullpath{$path_h} = $fullpath;

    # Minor trickery: we can't chdir() before we processed the headers
    # (so know the name of the extension), but the header may be in the
    # extension directory...
    my $tmp_path_h = $path_h;
    my $rel_path_h = $path_h;
    my @@dirs = @@paths;
    if (not -f $path_h) {
      my $found;
      for my $dir (@@paths) {
	$found++, last
	  if -f ($path_h = File::Spec->catfile($dir, $tmp_path_h));
      }
      if ($found) {
	$rel_path_h = $path_h;
	$fullpath{$path_h} = $fullpath;
      } else {
	(my $epath = $module) =~ s,::,/,g;
	$epath = File::Spec->catdir('ext', $epath) if -d 'ext';
	$rel_path_h = File::Spec->catfile($epath, $tmp_path_h);
	$path_h = $tmp_path_h;	# Used during -x
	push @@dirs, $epath;
      }
    }

    if (!$opt_c) {
      die "Can't find $tmp_path_h in @@dirs\n"
	if ( ! $opt_f && ! -f "$rel_path_h" );
      # Scan the header file (we should deal with nested header files)
      # Record the names of simple #define constants into const_names
            # Function prototypes are processed below.
      open(CH, "<$rel_path_h") || die "Can't open $rel_path_h: $!\n";
    defines:
      while (<CH>) {
	if ($pre_sub_tri_graphs) {
	    # Preprocess all tri-graphs
	    # including things stuck in quoted string constants.
	    s/\?\?=/#/g;                         # | ??=|  #|
	    s/\?\?\!/|/g;                        # | ??!|  ||
	    s/\?\?'/^/g;                         # | ??'|  ^|
	    s/\?\?\(/[/g;                        # | ??(|  [|
	    s/\?\?\)/]/g;                        # | ??)|  ]|
	    s/\?\?\-/~/g;                        # | ??-|  ~|
	    s/\?\?\//\\/g;                       # | ??/|  \|
	    s/\?\?</{/g;                         # | ??<|  {|
	    s/\?\?>/}/g;                         # | ??>|  }|
	}
	if (/^[ \t]*#[ \t]*define\s+([\$\w]+)\b(?!\()\s*(?=[^"\s])(.*)/) {
	    my $def = $1;
	    my $rest = $2;
	    $rest =~ s!/\*.*?(\*/|\n)|//.*!!g; # Remove comments
	    $rest =~ s/^\s+//;
	    $rest =~ s/\s+$//;
	    if ($rest eq '') {
	      print("Skip empty $def\n") if $opt_d;
	      next defines;
	    }
	    # Cannot do: (-1) and ((LHANDLE)3) are OK:
	    #print("Skip non-wordy $def => $rest\n"),
	    #  next defines if $rest =~ /[^\w\$]/;
	    if ($rest =~ /"/) {
	      print("Skip stringy $def => $rest\n") if $opt_d;
	      next defines;
	    }
	    print "Matched $_ ($def)\n" if $opt_d;
	    $seen_define{$def} = $rest;
	    $_ = $def;
	    next if /^_.*_h_*$/i; # special case, but for what?
	    if (defined $opt_p) {
	      if (!/^$opt_p(\d)/) {
		++$prefix{$_} if s/^$opt_p//;
	      }
	      else {
		warn "can't remove $opt_p prefix from '$_'!\n";
	      }
	    }
	    $prefixless{$def} = $_;
	    if (!$fmask or /$fmask/) {
		print "... Passes mask of -M.\n" if $opt_d and $fmask;
		$const_names{$_}++;
	    }
	  }
      }
      if (defined $opt_e and !$opt_e) {
        close(CH);
      }
      else {
	# Work from miniperl too - on "normal" systems
        my $SEEK_SET = eval 'use Fcntl qw/SEEK_SET/; SEEK_SET' || 0;
        seek CH, 0, $SEEK_SET;
        my $src = do { local $/; <CH> };
        close CH;
        no warnings 'uninitialized';

        # Remove C and C++ comments
        $src =~ s#/\*[^*]*\*+([^/*][^*]*\*+)*/|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#$2#gs;
        $src =~ s#//.*$##gm;

	while ($src =~ /\benum\s*([\w_]*)\s*\{\s([^}]+)\}/gsc) {
	    my ($enum_name, $enum_body) = ($1, $2);
            # skip enums matching $opt_e
            next if $opt_e && $enum_name =~ /$opt_e/;
            my $val = 0;
            for my $item (split /,/, $enum_body) {
                next if $item =~ /\A\s*\Z/;
                my ($key, $declared_val) = $item =~ /(\w+)\s*(?:=\s*(.*))?/;
                $val = defined($declared_val) && length($declared_val) ? $declared_val : 1 + $val;
                $seen_define{$key} = $val;
                $const_names{$key} = { name => $key, macro => 1 };
            }
        } # while (...)
      } # if (!defined $opt_e or $opt_e)
    }
    }
}

# Save current directory so that C::Scan can use it
my $cwd = File::Spec->rel2abs( File::Spec->curdir );

# As Ilya suggested, use a name that contains - and then it can't clash with
# the names of any packages. A directory 'fallback' will clash with any
# new pragmata down the fallback:: tree, but that seems unlikely.
my $constscfname = 'const-c.inc';
my $constsxsfname = 'const-xs.inc';
my $fallbackdirname = 'fallback';

my $ext = chdir 'ext' ? 'ext/' : '';

my @@modparts  = split(/::/,$module);
my $modpname  = join('-', @@modparts);
my $modfname  = pop @@modparts;
my $modpmdir  = join '/', 'lib', @@modparts;
my $modpmname = join '/', $modpmdir, $modfname.'.pm';

if ($opt_O) {
	warn "Overwriting existing $ext$modpname!!!\n" if -e $modpname;
}
else {
	die "Won't overwrite existing $ext$modpname\n" if -e $modpname;
}
-d "$modpname"   || mkpath([$modpname], 0, 0775);
chdir($modpname) || die "Can't chdir $ext$modpname: $!\n";

my %types_seen;
my %std_types;
my $fdecls = [];
my $fdecls_parsed = [];
my $typedef_rex;
my %typedefs_pre;
my %known_fnames;
my %structs;

my @@fnames;
my @@fnames_no_prefix;
my %vdecl_hash;
my @@vdecls;

if( ! $opt_X ){  # use XS, unless it was disabled
  unless ($skip_ppport) {
    require Devel::PPPort;
    warn "Writing $ext$modpname/ppport.h\n";
    Devel::PPPort::WriteFile('ppport.h')
        || die "Can't create $ext$modpname/ppport.h: $!\n";
  }
  open(XS, ">$modfname.xs") || die "Can't create $ext$modpname/$modfname.xs: $!\n";
  if ($opt_x) {
    warn "Scanning typemaps...\n";
    get_typemap();
    my @@td;
    my @@good_td;
    my $addflags = $opt_F || '';

    foreach my $filename (@@path_h) {
      my $c;
      my $filter;

      if ($fullpath{$filename} =~ /,/) {
	$filename = $`;
	$filter = $';
      }
      warn "Scanning $filename for functions...\n";
      my @@styles = $Config{gccversion} ? qw(C++ C9X GNU) : qw(C++ C9X);
      $c = C::Scan->new('filename' => $filename, 'filename_filter' => $filter,
        'add_cppflags' => $addflags, 'c_styles' => \@@styles);
      $c->set('includeDirs' => ["$Config::Config{archlib}/CORE", $cwd]);

      $c->get('keywords')->{'__restrict'} = 1;

      push @@$fdecls_parsed, @@{ $c->get('parsed_fdecls') };
      push(@@$fdecls, @@{$c->get('fdecls')});

      push @@td, @@{$c->get('typedefs_maybe')};
      if ($opt_a) {
	my $structs = $c->get('typedef_structs');
	@@structs{keys %$structs} = values %$structs;
      }

      if ($opt_m) {
	%vdecl_hash = %{ $c->get('vdecl_hash') };
	@@vdecls = sort keys %vdecl_hash;
	for (local $_ = 0; $_ < @@vdecls; ++$_) {
	  my $var = $vdecls[$_];
	  my($type, $post) = @@{ $vdecl_hash{$var} };
	  if (defined $post) {
	    warn "Can't handle variable '$type $var $post', skipping.\n";
	    splice @@vdecls, $_, 1;
	    redo;
	  }
	  $type = normalize_type($type);
	  $vdecl_hash{$var} = $type;
	}
      }

      unless ($tmask_all) {
	warn "Scanning $filename for typedefs...\n";
	my $td = $c->get('typedef_hash');
	# eval {require 'dumpvar.pl'; ::dumpValue($td)} or warn $@@ if $opt_d;
	my @@f_good_td = grep $td->{$_}[1] eq '', keys %$td;
	push @@good_td, @@f_good_td;
	@@typedefs_pre{@@f_good_td}  = map $_->[0], @@$td{@@f_good_td};
      }
    }
    { local $" = '|';
      $typedef_rex = qr(\b(?<!struct )(?:@@good_td)\b) if @@good_td;
    }
    %known_fnames = map @@$_[1,3], @@$fdecls_parsed; # [1,3] is NAME, FULLTEXT
    if ($fmask) {
      my @@good;
      for my $i (0..$#$fdecls_parsed) {
	next unless $fdecls_parsed->[$i][1] =~ /$fmask/; # [1] is NAME
	push @@good, $i;
	print "... Function $fdecls_parsed->[$i][1] passes -M mask.\n"
	  if $opt_d;
      }
      $fdecls = [@@$fdecls[@@good]];
      $fdecls_parsed = [@@$fdecls_parsed[@@good]];
    }
    @@fnames = sort map $_->[1], @@$fdecls_parsed; # 1 is NAME
    # Sort declarations:
    {
      my %h = map( ($_->[1], $_), @@$fdecls_parsed);
      $fdecls_parsed = [ @@h{@@fnames} ];
    }
    @@fnames_no_prefix = @@fnames;
    @@fnames_no_prefix
      = sort map { ++$prefix{$_} if s/^$opt_p(?!\d)//; $_ } @@fnames_no_prefix
         if defined $opt_p;
    # Remove macros which expand to typedefs
    print "Typedefs are @@td.\n" if $opt_d;
    my %td = map {($_, $_)} @@td;
    # Add some other possible but meaningless values for macros
    for my $k (qw(char double float int long short unsigned signed void)) {
      $td{"$_$k"} = "$_$k" for ('', 'signed ', 'unsigned ');
    }
    # eval {require 'dumpvar.pl'; ::dumpValue( [\@@td, \%td] ); 1} or warn $@@;
    my $n = 0;
    my %bad_macs;
    while (keys %td > $n) {
      $n = keys %td;
      my ($k, $v);
      while (($k, $v) = each %seen_define) {
	# print("found '$k'=>'$v'\n"),
	$bad_macs{$k} = $td{$k} = $td{$v} if exists $td{$v};
      }
    }
    # Now %bad_macs contains names of bad macros
    for my $k (keys %bad_macs) {
      delete $const_names{$prefixless{$k}};
      print "Ignoring macro $k which expands to a typedef name '$bad_macs{$k}'\n" if $opt_d;
    }
  }
}
my (@@const_specs, @@const_names);

for (sort(keys(%const_names))) {
    my $v = $const_names{$_};
    
    push(@@const_specs, ref($v) ? $v : $_);
    push(@@const_names, $_);
}

-d $modpmdir || mkpath([$modpmdir], 0, 0775);
open(PM, ">$modpmname") || die "Can't create $ext$modpname/$modpmname: $!\n";

$" = "\n\t";
warn "Writing $ext$modpname/$modpmname\n";

print PM <<"END";
package $module;

use $compat_version;
END

print PM <<"END" unless $skip_strict;
use strict;
END

print PM "use warnings;\n" unless $skip_warnings or $compat_version < 5.006;

unless( $opt_X || $opt_c || $opt_A ){
	# we'll have an AUTOLOAD(), and it will have $AUTOLOAD and
	# will want Carp.
	print PM <<'END';
use Carp;
END
}

print PM <<'END' unless $skip_exporter;

require Exporter;
END

my $use_Dyna = (not $opt_X and $compat_version < 5.006 and not $use_xsloader);
print PM <<"END" if $use_Dyna;  # use DynaLoader, unless XS was disabled
require DynaLoader;
END


# Are we using AutoLoader or not?
unless ($skip_autoloader) { # no autoloader whatsoever.
	unless ($opt_c) { # we're doing the AUTOLOAD
		print PM "use AutoLoader;\n";
	}
	else {
		print PM "use AutoLoader qw(AUTOLOAD);\n"
	}
}

if ( $compat_version < 5.006 ) {
    my $vars = '$VERSION @@ISA';
    $vars .= ' @@EXPORT @@EXPORT_OK %EXPORT_TAGS' unless $skip_exporter;
    $vars .= ' $AUTOLOAD' unless $opt_X || $opt_c || $opt_A;
    $vars .= ' $XS_VERSION' if $opt_B && !$opt_X;
    print PM "use vars qw($vars);";
}

# Determine @@ISA.
my @@modISA;
push @@modISA, 'Exporter'	unless $skip_exporter;
push @@modISA, 'DynaLoader' 	if $use_Dyna;  # no XS
my $myISA = "our \@@ISA = qw(@@modISA);";
$myISA =~ s/^our // if $compat_version < 5.006;

print PM "\n$myISA\n\n";

my @@exported_names = (@@const_names, @@fnames_no_prefix, map '$'.$_, @@vdecls);

my $tmp='';
$tmp .= <<"END" unless $skip_exporter;
# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.

# This allows declaration	use $module ':all';
# If you do not need this, moving things directly into \@@EXPORT or \@@EXPORT_OK
# will save memory.
our %EXPORT_TAGS = ( 'all' => [ qw(
	@@exported_names
) ] );

our \@@EXPORT_OK = ( \@@{ \$EXPORT_TAGS{'all'} } );

our \@@EXPORT = qw(
	@@const_names
);

END

$tmp .= "our \$VERSION = '$TEMPLATE_VERSION';\n";
if ($opt_B) {
    $tmp .= "our \$XS_VERSION = \$VERSION;\n" unless $opt_X;
    $tmp .= "\$VERSION = eval \$VERSION;  # see L<perlmodstyle>\n";
}
$tmp .= "\n";

$tmp =~ s/^our //mg if $compat_version < 5.006;
print PM $tmp;

if (@@vdecls) {
    printf PM "our(@@{[ join ', ', map '$'.$_, @@vdecls ]});\n\n";
}


print PM autoload ($module, $compat_version) unless $opt_c or $opt_X;

if( ! $opt_X ){ # print bootstrap, unless XS is disabled
  if ($use_Dyna) {
	$tmp = <<"END";
bootstrap $module \$VERSION;
END
  } else {
	$tmp = <<"END";
require XSLoader;
XSLoader::load('$module', \$VERSION);
END
  }
  $tmp =~ s:\$VERSION:\$XS_VERSION:g if $opt_B;
  print PM $tmp;
}

# tying the variables can happen only after bootstrap
if (@@vdecls) {
    printf PM <<END;
{
@@{[ join "\n", map "    _tievar_$_(\$$_);", @@vdecls ]}
}

END
}

my $after;
if( $opt_P ){ # if POD is disabled
	$after = '__END__';
}
else {
	$after = '=cut';
}

print PM <<"END";

# Preloaded methods go here.
END

print PM <<"END" unless $opt_A;

# Autoload methods go after $after, and are processed by the autosplit program.
END

print PM <<"END";

1;
__END__
END

my ($email,$author,$licence);

eval {
       my $username;
       ($username,$author) = (getpwuid($>))[0,6];
       if (defined $username && defined $author) {
	   $author =~ s/,.*$//; # in case of sub fields
	   my $domain = $Config{'mydomain'};
	   $domain =~ s/^\.//;
	   $email = "$username\@@$domain";
       }
     };

$author =~ s/'/\\'/g if defined $author;
$author ||= "A. U. Thor";
$email  ||= 'a.u.thor@@a.galaxy.far.far.away';

$licence = sprintf << "DEFAULT", $^V;
Copyright (C) ${\(1900 + (localtime) [5])} by $author

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version %vd or,
at your option, any later version of Perl 5 you may have available.
DEFAULT

my $revhist = '';
$revhist = <<EOT if $opt_C;
#
#=head1 HISTORY
#
#=over 8
#
#=item $TEMPLATE_VERSION
#
#Original version; created by h2xs $H2XS_VERSION with options
#
#  @@ARGS
#
#=back
#
EOT

my $exp_doc = $skip_exporter ? '' : <<EOD;
#
#=head2 EXPORT
#
#None by default.
#
EOD

if (@@const_names and not $opt_P) {
  $exp_doc .= <<EOD unless $skip_exporter;
#=head2 Exportable constants
#
#  @@{[join "\n  ", @@const_names]}
#
EOD
}

if (defined $fdecls and @@$fdecls and not $opt_P) {
  $exp_doc .= <<EOD unless $skip_exporter;
#=head2 Exportable functions
#
EOD

#  $exp_doc .= <<EOD if $opt_p;
#When accessing these functions from Perl, prefix C<$opt_p> should be removed.
#
#EOD
  $exp_doc .= <<EOD unless $skip_exporter;
#  @@{[join "\n  ", @@known_fnames{@@fnames}]}
#
EOD
}

my $meth_doc = '';

if ($opt_x && $opt_a) {
  my($name, $struct);
  $meth_doc .= accessor_docs($name, $struct)
    while ($name, $struct) = each %structs;
}

# Prefix the default licence with hash symbols.
# Is this just cargo cult - it seems that the first thing that happens to this
# block is that all the hashes are then s///g out.
my $licence_hash = $licence;
$licence_hash =~ s/^/#/gm;

my $pod;
$pod = <<"END" unless $opt_P;
## Below is stub documentation for your module. You'd better edit it!
#
#=head1 NAME
#
#$module - Perl extension for blah blah blah
#
#=head1 SYNOPSIS
#
#  use $module;
#  blah blah blah
#
#=head1 DESCRIPTION
#
#Stub documentation for $module, created by h2xs. It looks like the
#author of the extension was negligent enough to leave the stub
#unedited.
#
#Blah blah blah.
$exp_doc$meth_doc$revhist
#
#=head1 SEE ALSO
#
#Mention other useful documentation such as the documentation of
#related modules or operating system documentation (such as man pages
#in UNIX), or any relevant external documentation such as RFCs or
#standards.
#
#If you have a mailing list set up for your module, mention it here.
#
#If you have a web site set up for your module, mention it here.
#
#=head1 AUTHOR
#
#$author, E<lt>${email}E<gt>
#
#=head1 COPYRIGHT AND LICENSE
#
$licence_hash
#
#=cut
END

$pod =~ s/^\#//gm unless $opt_P;
print PM $pod unless $opt_P;

close PM;


if( ! $opt_X ){ # print XS, unless it is disabled
warn "Writing $ext$modpname/$modfname.xs\n";

print XS <<"END";
#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

END

print XS <<"END" unless $skip_ppport;
#include "ppport.h"

END

if( @@path_h ){
    foreach my $path_h (@@path_h_ini) {
	my($h) = $path_h;
	$h =~ s#^/usr/include/##;
	if ($^O eq 'VMS') { $h =~ s#.*vms\]#sys/# or $h =~ s#.*[:>\]]##; }
        print XS qq{#include <$h>\n};
    }
    print XS "\n";
}

print XS <<"END" if $opt_g;

/* Global Data */

#define MY_CXT_KEY "${module}::_guts" XS_VERSION

typedef struct {
    /* Put Global Data in here */
    int dummy;		/* you can access this elsewhere as MY_CXT.dummy */
} my_cxt_t;

START_MY_CXT

END

my %pointer_typedefs;
my %struct_typedefs;

sub td_is_pointer {
  my $type = shift;
  my $out = $pointer_typedefs{$type};
  return $out if defined $out;
  my $otype = $type;
  $out = ($type =~ /\*$/);
  # This converts only the guys which do not have trailing part in the typedef
  if (not $out
      and $typedef_rex and $type =~ s/($typedef_rex)/$typedefs_pre{$1}/go) {
    $type = normalize_type($type);
    print "Is-Pointer: Type mutation via typedefs: $otype ==> $type\n"
      if $opt_d;
    $out = td_is_pointer($type);
  }
  return ($pointer_typedefs{$otype} = $out);
}

sub td_is_struct {
  my $type = shift;
  my $out = $struct_typedefs{$type};
  return $out if defined $out;
  my $otype = $type;
  $out = ($type =~ /^(struct|union)\b/) && !td_is_pointer($type);
  # This converts only the guys which do not have trailing part in the typedef
  if (not $out
      and $typedef_rex and $type =~ s/($typedef_rex)/$typedefs_pre{$1}/go) {
    $type = normalize_type($type);
    print "Is-Struct: Type mutation via typedefs: $otype ==> $type\n"
      if $opt_d;
    $out = td_is_struct($type);
  }
  return ($struct_typedefs{$otype} = $out);
}

print_tievar_subs(\*XS, $_, $vdecl_hash{$_}) for @@vdecls;

if( ! $opt_c ) {
  # We write the "sample" files used when this module is built by perl without
  # ExtUtils::Constant.
  # h2xs will later check that these are the same as those generated by the
  # code embedded into Makefile.PL
  unless (-d $fallbackdirname) {
    mkdir "$fallbackdirname" or die "Cannot mkdir $fallbackdirname: $!\n";
  }
  warn "Writing $ext$modpname/$fallbackdirname/$constscfname\n";
  warn "Writing $ext$modpname/$fallbackdirname/$constsxsfname\n";
  my $cfallback = File::Spec->catfile($fallbackdirname, $constscfname);
  my $xsfallback = File::Spec->catfile($fallbackdirname, $constsxsfname);
  WriteConstants ( C_FILE =>       $cfallback,
                   XS_FILE =>      $xsfallback,
                   DEFAULT_TYPE => $opt_t,
                   NAME =>         $module,
                   NAMES =>        \@@const_specs,
                 );
  print XS "#include \"$constscfname\"\n";
}


my $prefix = defined $opt_p ? "PREFIX = $opt_p" : '';

# Now switch from C to XS by issuing the first MODULE declaration:
print XS <<"END";

MODULE = $module		PACKAGE = $module		$prefix

END

# If a constant() function was #included then output a corresponding
# XS declaration:
print XS "INCLUDE: $constsxsfname\n" unless $opt_c;

print XS <<"END" if $opt_g;

BOOT:
{
    MY_CXT_INIT;
    /* If any of the fields in the my_cxt_t struct need
       to be initialised, do it here.
     */
}

END

foreach (sort keys %const_xsub) {
    print XS <<"END";
char *
$_()

    CODE:
#ifdef $_
	RETVAL = $_;
#else
	croak("Your vendor has not defined the $module macro $_");
#endif

    OUTPUT:
	RETVAL

END
}

my %seen_decl;
my %typemap;

sub print_decl {
  my $fh = shift;
  my $decl = shift;
  my ($type, $name, $args) = @@$decl;
  return if $seen_decl{$name}++; # Need to do the same for docs as well?

  my @@argnames = map {$_->[1]} @@$args;
  my @@argtypes = map { normalize_type( $_->[0], 1 ) } @@$args;
  if ($opt_k) {
    s/^\s*const\b\s*// for @@argtypes;
  }
  my @@argarrays = map { $_->[4] || '' } @@$args;
  my $numargs = @@$args;
  if ($numargs and $argtypes[-1] eq '...') {
    $numargs--;
    $argnames[-1] = '...';
  }
  local $" = ', ';
  $type = normalize_type($type, 1);

  print $fh <<"EOP";

$type
$name(@@argnames)
EOP

  for my $arg (0 .. $numargs - 1) {
    print $fh <<"EOP";
	$argtypes[$arg]	$argnames[$arg]$argarrays[$arg]
EOP
  }
}

sub print_tievar_subs {
  my($fh, $name, $type) = @@_;
  print $fh <<END;
I32
_get_$name(IV index, SV *sv) {
    dSP;
    PUSHMARK(SP);
    XPUSHs(sv);
    PUTBACK;
    (void)call_pv("$module\::_get_$name", G_DISCARD);
    return (I32)0;
}

I32
_set_$name(IV index, SV *sv) {
    dSP;
    PUSHMARK(SP);
    XPUSHs(sv);
    PUTBACK;
    (void)call_pv("$module\::_set_$name", G_DISCARD);
    return (I32)0;
}

END
}

sub print_tievar_xsubs {
  my($fh, $name, $type) = @@_;
  print $fh <<END;
void
_tievar_$name(sv)
	SV* sv
    PREINIT:
	struct ufuncs uf;
    CODE:
	uf.uf_val = &_get_$name;
	uf.uf_set = &_set_$name;
	uf.uf_index = (IV)&_get_$name;
	sv_magic(sv, 0, 'U', (char*)&uf, sizeof(uf));

void
_get_$name(THIS)
	$type THIS = NO_INIT
    CODE:
	THIS = $name;
    OUTPUT:
	SETMAGIC: DISABLE
	THIS

void
_set_$name(THIS)
	$type THIS
    CODE:
	$name = THIS;

END
}

sub print_accessors {
  my($fh, $name, $struct) = @@_;
  return unless defined $struct && $name !~ /\s|_ANON/;
  $name = normalize_type($name);
  my $ptrname = normalize_type("$name *");
  print $fh <<"EOF";

MODULE = $module		PACKAGE = ${name}		$prefix

$name *
_to_ptr(THIS)
	$name THIS = NO_INIT
    PROTOTYPE: \$
    CODE:
	if (sv_derived_from(ST(0), "$name")) {
	    STRLEN len;
	    char *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(THIS))
		croak("Size \%d of packed data != expected \%d",
			len, sizeof(THIS));
	    RETVAL = ($name *)s;
	}
	else
	    croak("THIS is not of type $name");
    OUTPUT:
	RETVAL

$name
new(CLASS)
	char *CLASS = NO_INIT
    PROTOTYPE: \$
    CODE:
	Zero((void*)&RETVAL, sizeof(RETVAL), char);
    OUTPUT:
	RETVAL

MODULE = $module		PACKAGE = ${name}Ptr		$prefix

EOF
  my @@items = @@$struct;
  while (@@items) {
    my $item = shift @@items;
    if ($item->[0] =~ /_ANON/) {
      if (defined $item->[2]) {
	push @@items, map [
	  @@$_[0, 1], "$item->[2]_$_->[2]", "$item->[2].$_->[2]",
	], @@{ $structs{$item->[0]} };
      } else {
	push @@items, @@{ $structs{$item->[0]} };
      }
    } else {
      my $type = normalize_type($item->[0]);
      my $ttype = $structs{$type} ? normalize_type("$type *") : $type;
      print $fh <<"EOF";
$ttype
$item->[2](THIS, __value = NO_INIT)
	$ptrname THIS
	$type __value
    PROTOTYPE: \$;\$
    CODE:
	if (items > 1)
	    THIS->$item->[-1] = __value;
	RETVAL = @@{[
	    $type eq $ttype ? "THIS->$item->[-1]" : "&(THIS->$item->[-1])"
	]};
    OUTPUT:
	RETVAL

EOF
    }
  }
}

sub accessor_docs {
  my($name, $struct) = @@_;
  return unless defined $struct && $name !~ /\s|_ANON/;
  $name = normalize_type($name);
  my $ptrname = $name . 'Ptr';
  my @@items = @@$struct;
  my @@list;
  while (@@items) {
    my $item = shift @@items;
    if ($item->[0] =~ /_ANON/) {
      if (defined $item->[2]) {
	push @@items, map [
	  @@$_[0, 1], "$item->[2]_$_->[2]", "$item->[2].$_->[2]",
	], @@{ $structs{$item->[0]} };
      } else {
	push @@items, @@{ $structs{$item->[0]} };
      }
    } else {
      push @@list, $item->[2];
    }
  }
  my $methods = (join '(...)>, C<', @@list) . '(...)';

  my $pod = <<"EOF";
#
#=head2 Object and class methods for C<$name>/C<$ptrname>
#
#The principal Perl representation of a C object of type C<$name> is an
#object of class C<$ptrname> which is a reference to an integer
#representation of a C pointer.  To create such an object, one may use
#a combination
#
#  my \$buffer = $name->new();
#  my \$obj = \$buffer->_to_ptr();
#
#This exercises the following two methods, and an additional class
#C<$name>, the internal representation of which is a reference to a
#packed string with the C structure.  Keep in mind that \$buffer should
#better survive longer than \$obj.
#
#=over
#
#=item C<\$object_of_type_$name-E<gt>_to_ptr()>
#
#Converts an object of type C<$name> to an object of type C<$ptrname>.
#
#=item C<$name-E<gt>new()>
#
#Creates an empty object of type C<$name>.  The corresponding packed
#string is zeroed out.
#
#=item C<$methods>
#
#return the current value of the corresponding element if called
#without additional arguments.  Set the element to the supplied value
#(and return the new value) if called with an additional argument.
#
#Applicable to objects of type C<$ptrname>.
#
#=back
#
EOF
  $pod =~ s/^\#//gm;
  return $pod;
}

# Should be called before any actual call to normalize_type().
sub get_typemap {
  # We do not want to read ./typemap by obvios reasons.
  my @@tm =  qw(../../../typemap ../../typemap ../typemap);
  my $stdtypemap =  "$Config::Config{privlib}/ExtUtils/typemap";
  unshift @@tm, $stdtypemap;
  my $proto_re = "[" . quotemeta('\$%&*@@;') . "]" ;

  # Start with useful default values
  $typemap{float} = 'T_NV';

  foreach my $typemap (@@tm) {
    next unless -e $typemap ;
    # skip directories, binary files etc.
    warn " Scanning $typemap\n";
    warn("Warning: ignoring non-text typemap file '$typemap'\n"), next
      unless -T $typemap ;
    open(TYPEMAP, $typemap)
      or warn ("Warning: could not open typemap file '$typemap': $!\n"), next;
    my $mode = 'Typemap';
    while (<TYPEMAP>) {
      next if /^\s*\#/;
      if (/^INPUT\s*$/)   { $mode = 'Input'; next; }
      elsif (/^OUTPUT\s*$/)  { $mode = 'Output'; next; }
      elsif (/^TYPEMAP\s*$/) { $mode = 'Typemap'; next; }
      elsif ($mode eq 'Typemap') {
	next if /^\s*($|\#)/ ;
	my ($type, $image);
	if ( ($type, $image) =
	     /^\s*(.*?\S)\s+(\S+)\s*($proto_re*)\s*$/o
	     # This may reference undefined functions:
	     and not ($image eq 'T_PACKED' and $typemap eq $stdtypemap)) {
	  $typemap{normalize_type($type)} = $image;
	}
      }
    }
    close(TYPEMAP) or die "Cannot close $typemap: $!";
  }
  %std_types = %types_seen;
  %types_seen = ();
}


sub normalize_type {		# Second arg: do not strip const's before \*
  my $type = shift;
  my $do_keep_deep_const = shift;
  # If $do_keep_deep_const this is heuristic only
  my $keep_deep_const = ($do_keep_deep_const ? '\b(?![^(,)]*\*)' : '');
  my $ignore_mods
    = "(?:\\b(?:(?:__const__|const)$keep_deep_const|static|inline|__inline__)\\b\\s*)*";
  if ($do_keep_deep_const) {	# Keep different compiled /RExen/o separately!
    $type =~ s/$ignore_mods//go;
  }
  else {
    $type =~ s/$ignore_mods//go;
  }
  $type =~ s/([^\s\w])/ $1 /g;
  $type =~ s/\s+$//;
  $type =~ s/^\s+//;
  $type =~ s/\s+/ /g;
  $type =~ s/\* (?=\*)/*/g;
  $type =~ s/\. \. \./.../g;
  $type =~ s/ ,/,/g;
  $types_seen{$type}++
    unless $type eq '...' or $type eq 'void' or $std_types{$type};
  $type;
}

my $need_opaque;

sub assign_typemap_entry {
  my $type = shift;
  my $otype = $type;
  my $entry;
  if ($tmask and $type =~ /$tmask/) {
    print "Type $type matches -o mask\n" if $opt_d;
    $entry = (td_is_struct($type) ? "T_OPAQUE_STRUCT" : "T_PTROBJ");
  }
  elsif ($typedef_rex and $type =~ s/($typedef_rex)/$typedefs_pre{$1}/go) {
    $type = normalize_type $type;
    print "Type mutation via typedefs: $otype ==> $type\n" if $opt_d;
    $entry = assign_typemap_entry($type);
  }
  # XXX good do better if our UV happens to be long long
  return "T_NV" if $type =~ /^(unsigned\s+)?long\s+(long|double)\z/;
  $entry ||= $typemap{$otype}
    || (td_is_struct($type) ? "T_OPAQUE_STRUCT" : "T_PTROBJ");
  $typemap{$otype} = $entry;
  $need_opaque = 1 if $entry eq "T_OPAQUE_STRUCT";
  return $entry;
}

for (@@vdecls) {
  print_tievar_xsubs(\*XS, $_, $vdecl_hash{$_});
}

if ($opt_x) {
  for my $decl (@@$fdecls_parsed) { print_decl(\*XS, $decl) }
  if ($opt_a) {
    while (my($name, $struct) = each %structs) {
      print_accessors(\*XS, $name, $struct);
    }
  }
}

close XS;

if (%types_seen) {
  my $type;
  warn "Writing $ext$modpname/typemap\n";
  open TM, ">typemap" or die "Cannot open typemap file for write: $!";

  for $type (sort keys %types_seen) {
    my $entry = assign_typemap_entry $type;
    print TM $type, "\t" x (5 - int((length $type)/8)), "\t$entry\n"
  }

  print TM <<'EOP' if $need_opaque; # Older Perls do not have correct entry
#############################################################################
INPUT
T_OPAQUE_STRUCT
	if (sv_derived_from($arg, \"${ntype}\")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV($arg), len);

	    if (len != sizeof($var))
		croak(\"Size %d of packed data != expected %d\",
			len, sizeof($var));
	    $var = *($type *)s;
	}
	else
	    croak(\"$var is not of type ${ntype}\")
#############################################################################
OUTPUT
T_OPAQUE_STRUCT
	sv_setref_pvn($arg, \"${ntype}\", (char *)&$var, sizeof($var));
EOP

  close TM or die "Cannot close typemap file for write: $!";
}

} # if( ! $opt_X )

warn "Writing $ext$modpname/Makefile.PL\n";
open(PL, ">Makefile.PL") || die "Can't create $ext$modpname/Makefile.PL: $!\n";

my $prereq_pm = '';

if ( $compat_version < 5.006002 and $new_test )
{
  $prereq_pm .= q%'Test::More'  =>  0, %;
}
elsif ( $compat_version < 5.006002 )
{
  $prereq_pm .= q%'Test'        =>  0, %;
}

if (!$opt_X and $use_xsloader)
{
  $prereq_pm .= q%'XSLoader'    =>  0, %;
}

print PL <<"END";
use $compat_version;
use ExtUtils::MakeMaker;
# See lib/ExtUtils/MakeMaker.pm for details of how to influence
# the contents of the Makefile that is written.
WriteMakefile(
    NAME              => '$module',
    VERSION_FROM      => '$modpmname', # finds \$VERSION, requires EU::MM from perl >= 5.5
    PREREQ_PM         => {$prereq_pm}, # e.g., Module::Name => 1.1
    ABSTRACT_FROM     => '$modpmname', # retrieve abstract from module
    AUTHOR            => '$author <$email>',
    #LICENSE           => 'perl',
    #Value must be from legacy list of licenses here
    #http://search.cpan.org/perldoc?Module%3A%3ABuild%3A%3AAPI
END
if (!$opt_X) { # print C stuff, unless XS is disabled
  $opt_F = '' unless defined $opt_F;
  my $I = (((glob '*.h') || (glob '*.hh')) ? '-I.' : '');
  my $Ihelp = ($I ? '-I. ' : '');
  my $Icomment = ($I ? '' : <<EOC);
	# Insert -I. if you add *.h files later:
EOC

  print PL <<END;
    LIBS              => ['$extralibs'], # e.g., '-lm'
    DEFINE            => '$opt_F', # e.g., '-DHAVE_SOMETHING'
$Icomment    INC               => '$I', # e.g., '${Ihelp}-I/usr/include/other'
END

  my $C = grep {$_ ne "$modfname.c"}
    (glob '*.c'), (glob '*.cc'), (glob '*.C');
  my $Cpre = ($C ? '' : '# ');
  my $Ccomment = ($C ? '' : <<EOC);
	# Un-comment this if you add C files to link with later:
EOC

  print PL <<END;
$Ccomment    ${Cpre}OBJECT            => '\$(O_FILES)', # link all the C files too
END
} # ' # Grr
print PL ");\n";
if (!$opt_c) {
  my $generate_code =
    WriteMakefileSnippet ( C_FILE =>       $constscfname,
                           XS_FILE =>      $constsxsfname,
                           DEFAULT_TYPE => $opt_t,
                           NAME =>         $module,
                           NAMES =>        \@@const_specs,
                 );
  print PL <<"END";
if  (eval {require ExtUtils::Constant; 1}) {
  # If you edit these definitions to change the constants used by this module,
  # you will need to use the generated $constscfname and $constsxsfname
  # files to replace their "fallback" counterparts before distributing your
  # changes.
$generate_code
}
else {
  use File::Copy;
  use File::Spec;
  foreach my \$file ('$constscfname', '$constsxsfname') {
    my \$fallback = File::Spec->catfile('$fallbackdirname', \$file);
    copy (\$fallback, \$file) or die "Can't copy \$fallback to \$file: \$!";
  }
}
END

  eval $generate_code;
  if ($@@) {
    warn <<"EOM";
Attempting to test constant code in $ext$modpname/Makefile.PL:
$generate_code
__END__
gave unexpected error $@@
Please report the circumstances of this bug in h2xs version $H2XS_VERSION
using the perlbug script.
EOM
  } else {
    my $fail;

    foreach my $file ($constscfname, $constsxsfname) {
      my $fallback = File::Spec->catfile($fallbackdirname, $file);
      if (compare($file, $fallback)) {
        warn << "EOM";
Files "$ext$modpname/$fallbackdirname/$file" and "$ext$modpname/$file" differ.
EOM
        $fail++;
      }
    }
    if ($fail) {
      warn fill ('','', <<"EOM") . "\n";
It appears that the code in $ext$modpname/Makefile.PL does not autogenerate
the files $ext$modpname/$constscfname and $ext$modpname/$constsxsfname
correctly.

Please report the circumstances of this bug in h2xs version $H2XS_VERSION
using the perlbug script.
EOM
    } else {
      unlink $constscfname, $constsxsfname;
    }
  }
}
close(PL) || die "Can't close $ext$modpname/Makefile.PL: $!\n";

# Create a simple README since this is a CPAN requirement
# and it doesn't hurt to have one
warn "Writing $ext$modpname/README\n";
open(RM, ">README") || die "Can't create $ext$modpname/README:$!\n";
my $thisyear = (gmtime)[5] + 1900;
my $rmhead = "$modpname version $TEMPLATE_VERSION";
my $rmheadeq = "=" x length($rmhead);

my $rm_prereq;

if ( $compat_version < 5.006002 and $new_test )
{
  $rm_prereq = 'Test::More';
}
elsif ( $compat_version < 5.006002 )
{
  $rm_prereq = 'Test';
}
else
{
  $rm_prereq = 'blah blah blah';
}

print RM <<_RMEND_;
$rmhead
$rmheadeq

The README is used to introduce the module and provide instructions on
how to install the module, any machine dependencies it may have (for
example C compilers and installed libraries) and any other information
that should be provided before the module is installed.

A README file is required for CPAN modules since CPAN extracts the
README file from a module distribution so that people browsing the
archive can use it get an idea of the modules uses. It is usually a
good idea to provide version information here so that people can
decide whether fixes for the module are worth downloading.

INSTALLATION

To install this module type the following:

   perl Makefile.PL
   make
   make test
   make install

DEPENDENCIES

This module requires these other modules and libraries:

  $rm_prereq

COPYRIGHT AND LICENCE

Put the correct copyright and licence information here.

$licence

_RMEND_
close(RM) || die "Can't close $ext$modpname/README: $!\n";

my $testdir  = "t";
my $testfile = "$testdir/$modpname.t";
unless (-d "$testdir") {
  mkdir "$testdir" or die "Cannot mkdir $testdir: $!\n";
}
warn "Writing $ext$modpname/$testfile\n";
my $tests = @@const_names ? 2 : 1;

open EX, ">$testfile" or die "Can't create $ext$modpname/$testfile: $!\n";

print EX <<_END_;
# Before 'make install' is performed this script should be runnable with
# 'make test'. After 'make install' it should work as 'perl $modpname.t'

#########################

# change 'tests => $tests' to 'tests => last_test_to_print';

use strict;
use warnings;

_END_

my $test_mod = 'Test::More';

if ( $old_test or ($compat_version < 5.006002 and not $new_test ))
{
  my $test_mod = 'Test';

  print EX <<_END_;
use Test;
BEGIN { plan tests => $tests };
use $module;
ok(1); # If we made it this far, we're ok.

_END_

   if (@@const_names) {
     my $const_names = join " ", @@const_names;
     print EX <<'_END_';

my $fail;
foreach my $constname (qw(
_END_

     print EX wrap ("\t", "\t", $const_names);
     print EX (")) {\n");

     print EX <<_END_;
  next if (eval "my \\\$a = \$constname; 1");
  if (\$\@@ =~ /^Your vendor has not defined $module macro \$constname/) {
    print "# pass: \$\@@";
  } else {
    print "# fail: \$\@@";
    \$fail = 1;
  }
}
if (\$fail) {
  print "not ok 2\\n";
} else {
  print "ok 2\\n";
}

_END_
  }
}
else
{
  print EX <<_END_;
use Test::More tests => $tests;
BEGIN { use_ok('$module') };

_END_

   if (@@const_names) {
     my $const_names = join " ", @@const_names;
     print EX <<'_END_';

my $fail = 0;
foreach my $constname (qw(
_END_

     print EX wrap ("\t", "\t", $const_names);
     print EX (")) {\n");

     print EX <<_END_;
  next if (eval "my \\\$a = \$constname; 1");
  if (\$\@@ =~ /^Your vendor has not defined $module macro \$constname/) {
    print "# pass: \$\@@";
  } else {
    print "# fail: \$\@@";
    \$fail = 1;
  }

}

ok( \$fail == 0 , 'Constants' );
_END_
  }
}

print EX <<_END_;
#########################

# Insert your test code below, the $test_mod module is use()ed here so read
# its man page ( perldoc $test_mod ) for help writing this test script.

_END_

close(EX) || die "Can't close $ext$modpname/$testfile: $!\n";

unless ($opt_C) {
  warn "Writing $ext$modpname/Changes\n";
  $" = ' ';
  open(EX, ">Changes") || die "Can't create $ext$modpname/Changes: $!\n";
  @@ARGS = map {/[\s\"\'\`\$*?^|&<>\[\]\{\}\(\)]/ ? "'$_'" : $_} @@ARGS;
  print EX <<EOP;
Revision history for Perl extension $module.

$TEMPLATE_VERSION  @@{[scalar localtime]}
\t- original version; created by h2xs $H2XS_VERSION with options
\t\t@@ARGS

EOP
  close(EX) || die "Can't close $ext$modpname/Changes: $!\n";
}

warn "Writing $ext$modpname/MANIFEST\n";
open(MANI,'>MANIFEST') or die "Can't create MANIFEST: $!";
my @@files = grep { -f } (<*>, <t/*>, <$fallbackdirname/*>, <$modpmdir/*>);
if (!@@files) {
  eval {opendir(D,'.');};
  unless ($@@) { @@files = readdir(D); closedir(D); }
}
if (!@@files) { @@files = map {chomp && $_} `ls`; }
if ($^O eq 'VMS') {
  foreach (@@files) {
    # Clip trailing '.' for portability -- non-VMS OSs don't expect it
    s%\.$%%;
    # Fix up for case-sensitive file systems
    s/$modfname/$modfname/i && next;
    $_ = "\U$_" if $_ eq 'manifest' or $_ eq 'changes';
    $_ = 'Makefile.PL' if $_ eq 'makefile.pl';
  }
}
print MANI join("\n",@@files), "\n";
close MANI;
!NO!SUBS!

close OUT or die "Can't close $file: $!";
chmod 0755, $file or die "Can't reset permissions for $file: $!\n";
exec("$Config{'eunicefix'} $file") if $Config{'eunicefix'} ne ':';
chdir $origdir;
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d38 2
@


1.16.4.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@a37 2
BEGIN { pop @@INC if $INC[-1] eq '.' }

@


1.16.6.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@a37 2
BEGIN { pop @@INC if $INC[-1] eq '.' }

@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d994 2
a995 2
      $c = new C::Scan 'filename' => $filename, 'filename_filter' => $filter,
	'add_cppflags' => $addflags, 'c_styles' => \@@styles;
d1920 1
a1920 1
if ( $compat_version < 5.006 and !$opt_X and $use_xsloader)
d1932 1
a1932 1
    VERSION_FROM      => '$modpmname', # finds \$VERSION
d1934 5
a1938 3
    (\$] >= 5.005 ?     ## Add these new keywords supported since 5.005
      (ABSTRACT_FROM  => '$modpmname', # retrieve abstract from module
       AUTHOR         => '$author <$email>') : ()),
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d865 4
d1389 1
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d533 1
a533 1
    -b, --compat-version  Specify a perl version to be backwards compatibile with.
d792 1
a792 1
		(split ' ', $Config{locincpth}), '/usr/include');
d896 1
a896 1
        my $SEEK_SET = eval 'use Fcntl qw/SEEK_SET/; SEEK_SET' or 0;
d1727 1
a1727 1
#This exersizes the following two methods, and an additional class
d1804 1
a1804 1
  # If $do_keep_deep_const this is heuristical only
d2024 1
a2024 1
# and it doesnt hurt to have one
d2096 2
a2097 2
# Before `make install' is performed this script should be runnable with
# `make test'. After `make install' it should work as `perl $modpname.t'
@


1.12
log
@Merge in perl 5.10.1; part two
@
text
@d237 1
a237 1
5.7.2 .   C<Test::More> will be added to PREREQ_PM in the generated
d1906 1
a1906 1
if ( $compat_version < 5.00702 and $new_test )
d1910 4
d1915 1
a1915 1
if ( $compat_version < 5.00600 and !$opt_X and $use_xsloader)
d1917 1
a1917 1
  $prereq_pm .= q%'XSLoader'  =>  0, %;
d2033 5
a2037 1
if ( $compat_version < 5.00702 and $new_test )
d2039 1
a2039 1
   $rm_prereq = 'Test::More';
d2043 1
a2043 1
   $rm_prereq = 'blah blah blah';
d2103 3
d2110 1
a2110 1
if ( $old_test or ($compat_version < 5.007 and not $new_test ))
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d904 1
d916 1
a916 1
                $const_names{$key}++;
d1080 8
a1087 1
my @@const_names = sort keys %const_names;
d1476 1
a1476 1
                   NAMES =>        \@@const_names,
d1961 1
a1961 1
                           NAMES =>        \@@const_names,
@


1.10
log
@merge in perl 5.8.8
@
text
@d69 3
d111 2
a112 2
Omit the XS portion.  Used to generate templates for a module which is not
XS-based.  C<-c> and C<-f> are implicitly enabled.
d312 3
d501 1
a501 1
my( $H2XS_VERSION ) = ' $Revision: 1.9 $ ' =~ /\$Revision:\s+([^\s]+)/;
d652 1
a652 1
    $opt_b =~ /^\d+\.\d+\.\d+/ ||
d655 1
a655 1
    my ($maj,$min,$sub) = split(/\./,$opt_b,3);
d661 1
a661 3
        $compat_version =
	    $sub ? sprintf("%d.%03d%03d",$maj,$min,$sub) :
		   sprintf("%d.%03d",    $maj,$min);
d911 1
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d355 1
a355 1
makes this functionality accessable in Perl?  The example below
d495 1
a495 1
my( $H2XS_VERSION ) = ' $Revision: 1.8 $ ' =~ /\$Revision:\s+([^\s]+)/;
d525 3
a527 2
    -a, --gen-accessors   Generate get/set accessors for struct and union members                           (used with -x).
    -b, --compat-version  Specify a perl version to be backwards compatibile with
d537 1
a537 1
    -h, -?, --help        Display this help message
d547 8
a554 8
    -t, --default-type    Default type for autoloaded constants (default is IV)
        --use-new-tests   Use Test::More in backward compatible modules
        --use-old-tests   Use the module Test rather than Test::More
        --skip-exporter   Do not export symbols
        --skip-ppport     Do not use portability layer
        --skip-autoloader Do not use the module C<AutoLoader>
        --skip-strict     Do not use the pragma C<strict>
        --skip-warnings   Do not use the pragma C<warnings>
d557 2
d598 1
d637 1
d901 2
a902 3
        while ($src =~ /(\benum\s*([\w_]*)\s*\{\s([\s\w=,]+)\})/gsc) {
            my ($enum_name, $enum_body) =
                $1 =~ /enum\s*([\w_]*)\s*\{\s([\s\w=,]+)\}/gs;
d907 3
a909 3
                my ($key, $declared_val) = $item =~ /(\w+)\s*=\s*(.*)/;
                $val = length($declared_val) ? $declared_val : 1 + $val;
                $seen_define{$key} = $declared_val;
d1107 1
a1107 1
my $use_Dyna = (not $opt_X and $compat_version < 5.006);
d1242 1
d1891 1
a1891 1
my $prereq_pm;
d1895 1
a1895 1
  $prereq_pm = q%'Test::More'  =>  0%;
d1897 2
a1898 1
else
d1900 1
a1900 1
  $prereq_pm = '';
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d495 1
a495 1
my( $H2XS_VERSION ) = ' $Revision: 1.7 $ ' =~ /\$Revision:\s+([^\s]+)/;
d704 2
a705 1
my %const_xsub = map { $_,1 } split(/,+/, $opt_s) if $opt_s;
d903 1
a903 1
                my ($key, $declared_val) = $item =~ /(\w*)\s*=\s*(.*)/;
d984 2
d1313 2
a1314 1
my $pod = <<"END" unless $opt_P;
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d104 1
a104 1
Omit the autogenerated stub POD section. 
d172 1
a172 1
Include code for safely storing static data in the .xs file. 
d308 1
a308 1
    
d319 1
a319 1
    # Makefile.PL will look for library -lrpc in 
d329 1
a329 1
    # subroutines are created for sec_rgy_wildcard_name and 
d338 1
a338 1
    # Note that a directory with perl header files would 
d495 1
a495 1
my( $H2XS_VERSION ) = ' $Revision: 1.23 $ ' =~ /\$Revision:\s+([^\s]+)/;
d531 1
a531 1
                          If a pattern is given, only the matching enums are 
d535 1
a535 1
    -g, --global          Include code for safely storing static data in the .xs file. 
d828 1
a828 1
      die "Can't find $tmp_path_h in @@dirs\n" 
d837 1
a837 1
	    # Preprocess all tri-graphs 
d891 2
a892 2
        
        # Remove C and C++ comments 
d894 1
a894 1
        
d896 1
a896 1
            my ($enum_name, $enum_body) = 
d924 1
a924 1
  
d930 1
a930 1
  
d1056 1
a1056 1
	# print("found '$k'=>'$v'\n"), 
d1126 1
a1126 1
push @@modISA, 'Exporter'	unless $skip_exporter; 
d1618 1
a1618 1
	}   
d1751 1
a1751 1
    warn("Warning: ignoring non-text typemap file '$typemap'\n"), next 
d1753 1
a1753 1
    open(TYPEMAP, $typemap) 
d1784 1
a1784 1
  my $ignore_mods 
d1799 1
a1799 1
  $types_seen{$type}++ 
d2105 1
a2105 1
    \$fail = 1;    
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d147 18
d288 2
a289 5
	# Default behavior, extension is Rusers
	h2xs rpcsvc/rusers

	# Same, but extension is RUSERS
	h2xs -n RUSERS rpcsvc/rusers
d291 2
a292 2
	# Extension is rpcsvc::rusers. Still finds <rpcsvc/rusers.h>
	h2xs rpcsvc::rusers
d294 2
a295 2
	# Extension is ONC::RPC.  Still finds <rpcsvc/rusers.h>
	h2xs -n ONC::RPC rpcsvc/rusers
d297 44
a340 2
	# Without constant() or AUTOLOAD
	h2xs -c rpcsvc/rusers
d342 2
a343 2
	# Creates templates for an extension named RPC
	h2xs -cfn RPC
d345 2
a346 2
	# Extension is ONC::RPC.
	h2xs -cfn ONC::RPC
d348 2
a349 30
	# Makefile.PL will look for library -lrpc in 
	# additional directory /opt/net/lib
	h2xs rpcsvc/rusers -L/opt/net/lib -lrpc

        # Extension is DCE::rgynbase
        # prefix "sec_rgy_" is dropped from perl function names
        h2xs -n DCE::rgynbase -p sec_rgy_ dce/rgynbase

        # Extension is DCE::rgynbase
        # prefix "sec_rgy_" is dropped from perl function names
        # subroutines are created for sec_rgy_wildcard_name and sec_rgy_wildcard_sid
        h2xs -n DCE::rgynbase -p sec_rgy_ \
        -s sec_rgy_wildcard_name,sec_rgy_wildcard_sid dce/rgynbase

	# Make XS without defines in perl.h, but with function declarations
	# visible from perl.h. Name of the extension is perl1.
	# When scanning perl.h, define -DEXT=extern -DdEXT= -DINIT(x)=
	# Extra backslashes below because the string is passed to shell.
	# Note that a directory with perl header files would 
	#  be added automatically to include path.
	h2xs -xAn perl1 -F "-DEXT=extern -DdEXT= -DINIT\(x\)=" perl.h

	# Same with function declaration in proto.h as visible from perl.h.
	h2xs -xAn perl2 perl.h,proto.h

	# Same but select only functions which match /^av_/
	h2xs -M '^av_' -xAn perl2 perl.h,proto.h

	# Same but treat SV* etc as "opaque" types
	h2xs -o '^[S]V \*$' -M '^av_' -xAn perl2 perl.h,proto.h
d495 1
a495 1
my( $H2XS_VERSION ) = ' $Revision: 1.22 $ ' =~ /\$Revision:\s+([^\s]+)/;
d507 1
d530 3
d574 1
d598 1
d613 1
d712 2
a713 2
        $extralibs = "$arg @@ARGV";
        last;
d715 1
d881 28
a908 1
      close(CH);
a915 1
my ($ext, $nested, @@modparts, $modfname, $modpname);
d923 8
a930 15
$ext = chdir 'ext' ? 'ext/' : '';

if( $module =~ /::/ ){
	$nested = 1;
	@@modparts = split(/::/,$module);
	$modfname = $modparts[-1];
	$modpname = join('/',@@modparts);
}
else {
	$nested = 0;
	@@modparts = ();
	$modfname = $modpname = $module;
}


d937 1
a937 8
if( $nested ){
	my $modpath = "";
	foreach (@@modparts){
		-d "$modpath$_" || mkdir("$modpath$_", 0777);
		$modpath .= "$_/";
	}
}
-d "$modpname"   || mkdir($modpname, 0777);
d1069 2
a1070 1
open(PM, ">$modfname.pm") || die "Can't create $ext$modpname/$modfname.pm: $!\n";
d1073 1
a1073 1
warn "Writing $ext$modpname/$modfname.pm\n";
d1222 1
a1222 1
my ($email,$author);
d1238 8
d1304 6
a1321 7
#=head1 ABSTRACT
#
#  This should be the abstract for $module.
#  The abstract is used when making PPD (Perl Package Description) files.
#  If you don't want an ABSTRACT you should also edit Makefile.PL to
#  remove the ABSTRACT_FROM option.
#
d1348 1
a1348 4
#Copyright ${\(1900 + (localtime) [5])} by $author
#
#This library is free software; you can redistribute it and/or modify
#it under the same terms as Perl itself. 
d1899 6
a1904 6
    'NAME'		=> '$module',
    'VERSION_FROM'	=> '$modfname.pm', # finds \$VERSION
    'PREREQ_PM'		=> {$prereq_pm}, # e.g., Module::Name => 1.1
    (\$] >= 5.005 ?    ## Add these new keywords supported since 5.005
      (ABSTRACT_FROM => '$modfname.pm', # retrieve abstract from module
       AUTHOR     => '$author <$email>') : ()),
d1915 3
a1917 3
    'LIBS'		=> ['$extralibs'], # e.g., '-lm'
    'DEFINE'		=> '$opt_F', # e.g., '-DHAVE_SOMETHING'
$Icomment    'INC'		=> '$I', # e.g., '${Ihelp}-I/usr/include/other'
d1928 1
a1928 1
$Ccomment    $Cpre\'OBJECT'		=> '\$(O_FILES)', # link all the C files too
d2049 1
a2049 4
Copyright (C) $thisyear $author

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 
d2055 1
a2055 1
my $testfile = "$testdir/1.t";
d2066 1
a2066 1
# `make test'. After `make install' it should work as `perl 1.t'
d2180 1
a2180 1
my @@files = grep { -f } (<*>, <t/*>, <$fallbackdirname/*>);
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d38 2
d46 1
a46 1
B<h2xs> [B<-ACOPXacdfkmx>] [B<-F> addflags] [B<-M> fmask] [B<-n> module_name] [B<-o> tmask] [B<-p> prefix] [B<-s> subs] [B<-v> version] [headerfile ... [extra_libraries]]
d48 1
a48 1
B<h2xs> B<-h>
d62 6
a67 6
the libraries actually exist and how they should be loaded.
The extra libraries should be specified in the form -lm -lposix, etc,
just as on the cc command line.  By default, the Makefile.PL will
search through the library path determined by Configure.  That path
can be augmented by including arguments of the form B<-L/another/library/path>
in the extra-libraries argument.
d73 6
a78 1
=item B<-A>
d80 2
a81 2
Omit all autoload facilities.  This is the same as B<-c> but also removes the
S<C<use AutoLoader>> statement from the .pm file.
d83 1
a83 1
=item B<-C>
d88 1
a88 1
=item B<-F> I<addflags>
d91 2
a92 1
function declarations.  Should not be used without B<-x>.
d94 1
a94 1
=item B<-M> I<regular expression>
d98 1
a98 1
=item B<-O>
d102 1
a102 1
=item B<-P>
d106 1
a106 1
=item B<-X>
d111 1
a111 1
=item B<-a>
d125 14
a138 1
=item B<-c>
d143 1
a143 1
=item B<-d>
d147 1
a147 1
=item B<-f>
d152 6
a157 1
=item B<-h>
d161 1
a161 1
=item B<-k>
d166 1
a166 1
=item B<-m>
d171 1
a171 1
=item B<-n> I<module_name>
d175 1
a175 1
=item B<-o> I<regular expression>
d184 2
a185 1
Use C<-o .> if you want to handle all the C<typedef>ed types as opaque types.
d191 46
a236 1
=item B<-p> I<prefix>
d238 1
a238 3
Specify a prefix which should be removed from the Perl function names, e.g., S<-p sec_rgy_> 
This sets up the XS B<PREFIX> keyword and removes the prefix from functions that are
autoloaded via the C<constant()> mechanism.
d240 1
a240 1
=item B<-s> I<sub1,sub2>
d242 1
a242 2
Create a perl subroutine for the specified macros rather than autoload with the constant() subroutine.
These macros are assumed to have a return type of B<char *>, e.g., S<-s sec_rgy_wildcard_name,sec_rgy_wildcard_sid>.
d244 1
a244 1
=item B<-v> I<version>
d247 2
a248 1
to the templates.  The default is 0.01.
d250 1
a250 1
=item B<-x>
d255 3
a257 2
C<NAME1,NAME2>. In this case NAME1 is used instead of the specified string,
but XSUBs are emitted only for the declarations included from file NAME2.
a264 12
=item B<-b> I<version>

Generates a .pm file which is backwards compatible with the specified
perl version.

For versions < 5.6.0, the changes are.
    - no use of 'our' (uses 'use vars' instead)
    - no 'use warnings'

Specifying a compatibility version higher than the version of perl you
are using to run h2xs will have no effect.

d462 1
d466 1
a466 1
my( $H2XS_VERSION ) = ' $Revision: 1.21 $ ' =~ /\$Revision:\s+([^\s]+)/;
d471 52
a522 1
use Getopt::Std;
a523 25
sub usage{
	warn "@@_\n" if @@_;
    die "h2xs [-ACOPXacdfhkmx] [-F addflags] [-M fmask] [-n module_name] [-o tmask] [-p prefix] [-s subs] [-v version] [headerfile [extra_libraries]]
version: $H2XS_VERSION
    -A   Omit all autoloading facilities (implies -c).
    -C   Omit creating the Changes file, add HISTORY heading to stub POD.
    -F   Additional flags for C preprocessor (used with -x).
    -M   Mask to select C functions/macros (default is select all).
    -O   Allow overwriting of a pre-existing extension directory.
    -P   Omit the stub POD section.
    -X   Omit the XS portion (implies both -c and -f).
    -a   Generate get/set accessors for struct and union members (used with -x).
    -c   Omit the constant() function and specialised AUTOLOAD from the XS file.
    -d   Turn on debugging messages.
    -f   Force creation of the extension even if the C header does not exist.
    -h   Display this help message
    -k   Omit 'const' attribute on function arguments (used with -x).
    -m   Generate tied variables for access to declared variables.
    -n   Specify a name to use for the extension (recommended).
    -o   Regular expression for \"opaque\" types.
    -p   Specify a prefix which should be removed from the Perl function names.
    -s   Create subroutines for specified macros.
    -v   Specify a version number for this extension.
    -x   Autogenerate XSUBs using C::Scan.
    -b   Specify a perl version to be backwards compatibile with
d527 1
a527 1
";
d530 68
d599 1
a599 4
getopts("ACF:M:OPXacdfhkmn:o:p:s:v:xb:") || usage;
use vars qw($opt_A $opt_C $opt_F $opt_M $opt_O $opt_P $opt_X $opt_a $opt_c $opt_d
	    $opt_f $opt_h $opt_k $opt_m $opt_n $opt_o $opt_p $opt_s $opt_v $opt_x 
	    $opt_b);
d606 2
a607 2
	usage "You must provide the backwards compatibility version in X.Y.Z form. " .
	    "(i.e. 5.5.0)\n";
d609 23
a631 2
    $compat_version = sprintf("%d.%03d%02d",$maj,$min,$sub);
} 
d635 23
d661 1
a661 1
$opt_c = 1 if $opt_A;
d666 2
d669 3
a671 1
my $extralibs;
d718 5
a722 2
  warn <<EOD;
Options -o and -F do not make sense without -x.
a731 1
    use Config;
d734 1
d780 1
d799 14
a812 1
	if (/^[ \t]*#[ \t]*define\s+([\$\w]+)\b(?!\()\s*(?=[^" \t])(.*)/) {
d849 2
d852 7
d860 1
a860 2
my ($ext, $nested, @@modparts, $modfname, $modpname);
(chdir 'ext', $ext = 'ext/') if -d 'ext';
d884 1
a884 1
		mkdir("$modpath$_", 0777);
d888 1
a888 1
mkdir($modpname, 0777);
d906 6
a913 1
    require Config;		# Run-time directive
d929 1
d931 2
a932 2
	'add_cppflags' => $addflags, 'c_styles' => [qw(C++ C9X)];
      $c->set('includeDirs' => ["$Config::Config{archlib}/CORE"]);
d991 2
a992 1
      = sort map { ++$prefix{$_} if s/^$opt_p(?!\d)//; $_ } @@fnames_no_prefix;
a1024 1
if ( $compat_version < 5.006 ) {
a1028 1
use strict;
a1029 4
} 
else {
print PM <<"END";
package $module;
d1031 1
a1031 1
use 5.006;
a1032 1
use warnings;
d1034 2
a1035 1
}
d1045 1
a1045 1
print PM <<'END';
d1050 2
a1051 1
print PM <<"END" if ! $opt_X;  # use DynaLoader, unless XS was disabled
d1057 1
a1057 1
unless ($opt_A) { # no autoloader whatsoever.
d1067 5
a1071 5
    if ( $opt_X || $opt_c || $opt_A ) {
	print PM 'use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS);';
    } else {
	print PM 'use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS $AUTOLOAD);';
    }
d1075 4
a1078 3
my $myISA = 'our @@ISA = qw(Exporter';	# We seem to always want this.
$myISA .= ' DynaLoader' 	unless $opt_X;  # no XS
$myISA .= ');';
d1085 2
a1086 1
my $tmp=<<"END";
a1102 1
our \$VERSION = '$TEMPLATE_VERSION';
d1106 7
d1121 1
a1121 35
$tmp = ( $compat_version < 5.006 ?  "" : "our \$AUTOLOAD;" );
print PM <<"END" unless $opt_c or $opt_X;
sub AUTOLOAD {
    # This AUTOLOAD is used to 'autoload' constants from the constant()
    # XS function.  If a constant is not found then control is passed
    # to the AUTOLOAD in AutoLoader.

    my \$constname;
    $tmp
    (\$constname = \$AUTOLOAD) =~ s/.*:://;
    croak "&$module::constant not defined" if \$constname eq 'constant';
    my \$val = constant(\$constname, \@@_ ? \$_[0] : 0);
    if (\$! != 0) {
	if (\$! =~ /Invalid/ || \$!{EINVAL}) {
	    \$AutoLoader::AUTOLOAD = \$AUTOLOAD;
	    goto &AutoLoader::AUTOLOAD;
	}
	else {
	    croak "Your vendor has not defined $module macro \$constname";
	}
    }
    {
	no strict 'refs';
	# Fixed between 5.005_53 and 5.005_61
	if (\$] >= 5.00561) {
	    *\$AUTOLOAD = sub () { \$val };
	}
	else {
	    *\$AUTOLOAD = sub { \$val };
	}
    }
    goto &\$AUTOLOAD;
}

END
d1124 2
a1125 1
	print PM <<"END";
d1128 8
d1172 15
a1186 2
my $author = "A. U. Thor";
my $email = 'a.u.thor@@a.galaxy.far.far.away';
d1205 1
a1205 1
my $exp_doc = <<EOD;
d1214 1
a1214 1
  $exp_doc .= <<EOD;
d1223 1
a1223 1
  $exp_doc .= <<EOD;
d1232 1
a1232 1
  $exp_doc .= <<EOD;
d1247 1
a1247 1
## Below is stub documentation for your module. You better edit it!
d1258 7
d1273 12
d1289 3
a1291 1
#=head1 SEE ALSO
d1293 2
a1294 1
#L<perl>.
d1314 6
d1330 15
d1382 1
a1382 42
# Some macros will bomb if you try to return them from a double-returning func.
# Say, ((char *)0), or strlen (if somebody #define STRLEN strlen).
# Fortunately, we can detect both these cases...
sub protect_convert_to_double {
  my $in = shift;
  my $val;
  return '' unless defined ($val = $seen_define{$in});
  return '(IV)' if $known_fnames{$val};
  # OUT_t of ((OUT_t)-1):
  return '' unless $val =~ /^\s*(\(\s*)?\(\s*([^()]*?)\s*\)/;
  td_is_pointer($2) ? '(IV)' : '';
}

# For each of the generated functions, length($pref) leading
# letters are already checked.  Moreover, it is recommended that
# the generated functions uses switch on letter at offset at least
# $off + length($pref).
#
# The given list has length($pref) chars removed at front, it is
# guarantied that $off leading chars in the rest are the same for all
# elts of the list.
#
# Returns: how at which offset it was decided to make a switch, or -1 if none.

sub write_const;

sub write_const {
  my ($fh, $pref, $off, $list) = (shift,shift,shift,shift);
  my %leading;
  my $offarg = length $pref;

  if (@@$list == 0) {		# Can happen on the initial iteration only
    print $fh <<"END";
static double
constant(char *name, int len, int arg)
{
    errno = EINVAL;
    return 0;
}
END
    return -1;
  }
d1384 19
a1402 18
  if (@@$list == 1) {		# Can happen on the initial iteration only
    my $protect = protect_convert_to_double("$pref$list->[0]");

    print $fh <<"END";
static double
constant(char *name, int len, int arg)
{
    errno = 0;
    if (strEQ(name + $offarg, "$list->[0]")) {	/* $pref removed */
#ifdef $pref$list->[0]
	return $protect$pref$list->[0];
#else
	errno = ENOENT;
	return 0;
#endif
    }
    errno = EINVAL;
    return 0;
a1403 3
END
    return -1;
  }
a1404 5
  for my $n (@@$list) {
    my $c = substr $n, $off, 1;
    $leading{$c} = [] unless exists $leading{$c};
    push @@{$leading{$c}}, substr $n, $off + 1;
  }
d1406 1
a1406 3
  if (keys(%leading) == 1) {
    return 1 + write_const $fh, $pref, $off + 1, $list;
  }
d1408 2
a1409 5
  my $leader = substr $list->[0], 0, $off;
  foreach my $letter (keys %leading) {
    write_const $fh, "$pref$leader$letter", 0, $leading{$letter}
      if @@{$leading{$letter}} > 1;
  }
d1411 1
a1411 8
  my $npref = "_$pref";
  $npref = '' if $pref eq '';

  print $fh <<"END";
static double
constant$npref(char *name, int len, int arg)
{
END
a1412 2
  print $fh <<"END" if $npref eq '';
    errno = 0;
d1415 3
a1417 55
  print $fh <<"END" if $off;
    if ($offarg + $off >= len ) {
	errno = EINVAL;
	return 0;
    }
END

  print $fh <<"END";
    switch (name[$offarg + $off]) {
END

  foreach my $letter (sort keys %leading) {
    my $let = $letter;
    $let = '\0' if $letter eq '';

    print $fh <<EOP;
    case '$let':
EOP
    if (@@{$leading{$letter}} > 1) {
      # It makes sense to call a function
      if ($off) {
	print $fh <<EOP;
	if (!strnEQ(name + $offarg,"$leader", $off))
	    break;
EOP
      }
      print $fh <<EOP;
	return constant_$pref$leader$letter(name, len, arg);
EOP
    }
    else {
      # Do it ourselves
      my $protect
	= protect_convert_to_double("$pref$leader$letter$leading{$letter}[0]");

      print $fh <<EOP;
	if (strEQ(name + $offarg, "$leader$letter$leading{$letter}[0]")) {	/* $pref removed */
#ifdef $pref$leader$letter$leading{$letter}[0]
	    return $protect$pref$leader$letter$leading{$letter}[0];
#else
	    goto not_there;
#endif
	}
EOP
    }
  }
  print $fh <<"END";
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}
d1419 1
a1419 3
END

}
d1421 1
a1421 4
if( ! $opt_c ) {
  print XS <<"END";
static int
not_here(char *s)
d1423 4
a1426 7
    croak("$module::%s not implemented on this architecture", s);
    return -1;
}

END

  write_const(\*XS, '', 0, \@@const_names);
a1428 10
print_tievar_subs(\*XS, $_, $vdecl_hash{$_}) for @@vdecls;

my $prefix;
$prefix = "PREFIX = $opt_p" if defined $opt_p;

# Now switch from C to XS by issuing the first MODULE declaration:
print XS <<"END";

MODULE = $module		PACKAGE = $module		$prefix

a1448 19
# If a constant() function was written then output a corresponding
# XS declaration:
print XS <<"END" unless $opt_c;

double
constant(sv,arg)
    PREINIT:
	STRLEN		len;
    INPUT:
	SV *		sv
	char *		s = SvPV(sv, len);
	int		arg
    CODE:
	RETVAL = constant(s,len,arg);
    OUTPUT:
	RETVAL

END

d1691 1
a1691 1
  $typemap{float} = 'T_DOUBLE';
d1738 1
a1738 1
  $type =~ s/([^\s\w])/ \1 /g;
d1765 2
d1828 13
a1840 1
print PL <<END;
d1847 1
a1847 1
    'PREREQ_PM'		=> {}, # e.g., Module::Name => 1.1
d1863 1
a1863 1
$Icomment    'INC'		=> '$I', # e.g., '$Ihelp-I/usr/include/other'
d1866 2
a1867 1
  my $C = grep $_ ne "$modfname.c", (glob '*.c'), (glob '*.cc'), (glob '*.C');
d1876 63
a1939 1
print PL ");\n";
d1949 12
d1989 1
a1989 1
  blah blah blah
d1995 4
a1998 1
Copyright (C) $thisyear $author blah blah blah
d2003 11
a2013 3
warn "Writing $ext$modpname/test.pl\n";
open(EX, ">test.pl") || die "Can't create $ext$modpname/test.pl: $!\n";
print EX <<'_END_';
d2015 1
a2015 1
# `make test'. After `make install' it should work as `perl test.pl'
d2019 9
a2027 1
# change 'tests => 1' to 'tests => last_test_to_print';
d2029 1
d2031 41
a2071 1
BEGIN { plan tests => 1 };
d2073 24
a2096 2
print EX <<_END_;
use $module;
d2098 2
a2099 2
print EX <<'_END_';
ok(1); # If we made it this far, we're ok.
d2101 1
d2104 2
a2105 2
# Insert your test code below, the Test module is use()ed here so read
# its man page ( perldoc Test ) for help writing this test script.
d2108 2
a2109 1
close(EX) || die "Can't close $ext$modpname/test.pl: $!\n";
d2129 1
a2129 1
my @@files = <*>;
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d16 1
a16 1
$origdir = cwd;
d18 1
a18 1
$file = basename($0, '.PL');
d44 1
a44 1
B<h2xs> [B<-ACOPXcdf>] [B<-v> version] [B<-n> module_name] [B<-p> prefix] [B<-s> sub] [headerfile ... [extra_libraries]]
d81 1
a81 1
=item B<-F>
d194 12
d263 62
d406 1
a406 1
my( $H2XS_VERSION ) = ' $Revision: 1.20 $ ' =~ /\$Revision:\s+([^\s]+)/;
d409 1
d415 1
a415 1
    die "h2xs [-ACOPXcdfh] [-v version] [-n module_name] [-p prefix] [-s subs] [headerfile [extra_libraries]]
d437 1
d445 1
a445 1
getopts("ACF:M:OPXacdfhkmn:o:p:s:v:x") || usage;
d447 2
a448 1
	    $opt_f $opt_h $opt_k $opt_m $opt_n $opt_o $opt_p $opt_s $opt_v $opt_x);
d452 9
d527 2
d547 9
d564 6
d571 1
a571 1
      my $tmp_path_h = $path_h;
d573 11
a583 1
	last if -f ($path_h = File::Spec->catfile($dir, $tmp_path_h));
d588 2
a589 1
      die "Can't find $path_h\n" if ( ! $opt_f && ! -f $path_h );
d593 1
a593 1
      open(CH, "<$path_h") || die "Can't open $path_h: $!\n";
a633 8
my $module = $opt_n || do {
	$name =~ s/\.h$//;
	if( $name !~ /::/ ){
		$name =~ s#^.*/##;
		$name = "\u$name";
	}
	$name;
};
d794 1
d798 9
a806 1
require 5.005_62;
d810 1
d840 8
d852 2
d858 1
a858 1
print PM<<"END";
d879 3
d886 2
d895 1
a895 1
    our \$AUTOLOAD;
d968 13
a980 13

=head1 HISTORY

=over 8

=item $TEMPLATE_VERSION

Original version; created by h2xs $H2XS_VERSION with options

  @@ARGS

=back

d984 6
a990 5
=head2 EXPORT

None by default.

EOD
d993 4
a996 4
=head2 Exportable constants

  @@{[join "\n  ", @@const_names]}

d999 1
d1002 3
a1004 1
=head2 Exportable functions
d1006 7
d1014 1
a1014 2
  $exp_doc .= <<EOD if $opt_p;
When accessing these functions from Perl, prefix C<$opt_p> should be removed.
d1016 1
a1016 3
EOD
  $exp_doc .= <<EOD;
  @@{[join "\n  ", @@known_fnames{@@fnames}]}
d1018 4
a1021 1
EOD
d1043 1
a1043 1
#$exp_doc$revhist
d1046 1
a1046 1
#$author, $email
d1050 1
a1050 1
#perl(1).
d1502 66
d1720 3
d1726 6
d1735 11
a1745 1
    'INC'		=> '', # e.g., '-I/usr/include/other'
d1751 46
d1803 1
a1803 1
######################### We start with some black magic to print on failure.
d1805 1
a1805 2
# Change 1..1 below to 1..last_test_to_print .
# (It may become useful if the test is moved to ./t subdirectory.)
d1807 2
a1808 2
BEGIN { $| = 1; print "1..1\n"; }
END {print "not ok 1\n" unless $loaded;}
d1814 1
a1814 2
$loaded = 1;
print "ok 1\n";
d1816 1
a1816 1
######################### End of black magic.
d1818 2
a1819 3
# Insert your test code below (better if it prints "ok 13"
# (correspondingly "not ok 13") depending on the success of chunk 13
# of the test code):
@


1.3
log
@perl5.005_03 (stock)
@
text
@d44 1
a44 1
B<h2xs> [B<-AOPXcdf>] [B<-v> version] [B<-n> module_name] [B<-p> prefix] [B<-s> sub] [headerfile ... [extra_libraries]]
d74 6
a79 1
S<C<require AutoLoader>> statement from the .pm file.
d84 5
a88 1
function declarations. Should not be used without B<-x>.
d101 15
a115 1
XS-based.
d129 1
a129 1
not found in /usr/include.
d135 10
d149 15
d168 1
a168 1
autoloaded via the C<constant()> mechansim.
d191 2
a192 1
pointer (like C<long long>), pointers to functions, or arrays.
d245 6
d267 60
d329 4
a332 1
my( $H2XS_VERSION ) = ' $Revision: 1.19 $ ' =~ /\$Revision:\s+([^\s]+)/;
d334 1
d340 1
a340 1
    die "h2xs [-AOPXcdfh] [-v version] [-n module_name] [-p prefix] [-s subs] [headerfile [extra_libraries]]
d343 1
d345 1
d348 2
a349 1
    -X   Omit the XS portion.
d354 2
d357 1
d369 3
a371 1
getopts("AF:OPXcdfhn:p:s:v:x") || usage;
d378 2
d381 7
a387 1
%const_xsub = map { $_,1 } split(/,+/, $opt_s) if $opt_s;
d400 40
d442 15
d463 1
a463 1
    $fullpath = $path_h;
d465 7
a471 18
    if ($^O eq 'VMS') {  # Consider overrides of default location
	if ($path_h !~ m![:>\[]!) {
	    my($hadsys) = ($path_h =~ s!^sys/!!i);
	    if ($ENV{'DECC$System_Include'})     { $path_h = "DECC\$System_Include:$path_h";    }
	    elsif ($ENV{'DECC$Library_Include'}) { $path_h = "DECC\$Library_Include:$path_h";   }
	    elsif ($ENV{'GNU_CC_Include'})       { $path_h = 'GNU_CC_Include:' .
	                                            ($hadsys ? '[vms]' : '[000000]') . $path_h; }
	    elsif ($ENV{'VAXC$Include'})         { $path_h = "VAXC\$_Include:$path_h";          }
	    else                                 { $path_h = "Sys\$Library:$path_h";            }
	}
    }
    elsif ($^O eq 'os2') {
	$path_h = "/usr/include/$path_h" 
	  if $path_h !~ m#^([a-z]:)?[./]#i and -r "/usr/include/$path_h"; 
    }
    else { 
      $path_h = "/usr/include/$path_h" 
	if $path_h !~ m#^[./]# and -r "/usr/include/$path_h"; 
d480 1
d482 16
a497 3
	if (/^#[ \t]*define\s+([\$\w]+)\b\s*[^("]/) {
	    print "Matched $_ ($1)\n" if $opt_d;
	    $_ = $1;
d507 5
a511 1
	    $const_names{$_}++;
a516 1
    @@const_names = sort keys %const_names;
d520 1
a520 1
$module = $opt_n || do {
d529 1
d547 2
a548 1
} else {
d552 1
a552 1
	$modpath = "";
d563 11
a573 2
my $fdecls;
my $fdecls_parsed;
a577 1
    require C::Scan;		# Run-time directive
d581 2
a582 4
    my $c;
    my $filter;
        my @@fdecls;
        foreach my $filename (@@path_h) {
d584 95
a678 13
    if ($fullpath =~ /,/) {
      $filename = $`;
      $filter = $';
    }
    warn "Scanning $filename for functions...\n";
    $c = new C::Scan 'filename' => $filename, 'filename_filter' => $filter,
    'add_cppflags' => $addflags;
    $c->set('includeDirs' => ["$Config::Config{archlib}/CORE"]);
    
    $fdecls_parsed = $c->get('parsed_fdecls');
            push(@@fdecls, @@{$c->get('fdecls')});
        }
        $fdecls = [ @@fdecls ];
d681 1
d691 1
d693 1
d696 1
a696 7
if( $opt_X || $opt_c || $opt_A ){
	# we won't have our own AUTOLOAD(), so won't have $AUTOLOAD
	print PM <<'END';
use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK);
END
}
else{
a700 1
use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK $AUTOLOAD);
a712 12
# require autoloader if XS is disabled.
# if XS is enabled, require autoloader unless autoloading is disabled.
if( ($opt_X && (! $opt_A)) || (!$opt_X) ) {
	print PM <<"END";
require AutoLoader;
END
}

if( $opt_X || ($opt_c && ! $opt_A) ){
	# we won't have our own AUTOLOAD(), so we'll inherit it.
	if( ! $opt_X ) { # use DynaLoader, unless XS was disabled
		print PM <<"END";
d714 4
a717 2
\@@ISA = qw(Exporter AutoLoader DynaLoader);
END
d719 2
a720 5
	else{
		print PM <<"END";

\@@ISA = qw(Exporter AutoLoader);
END
a722 6
else{
	# 1) we have our own AUTOLOAD(), so don't need to inherit it.
	# or
	# 2) we don't want autoloading mentioned.
	if( ! $opt_X ){ # use DynaLoader, unless XS was disabled
		print PM <<"END";
d724 5
a728 5
\@@ISA = qw(Exporter DynaLoader);
END
	}
	else{
		print PM <<"END";
d730 1
a730 4
\@@ISA = qw(Exporter);
END
	}
}
d736 11
a746 1
\@@EXPORT = qw(
d749 1
a749 1
\$VERSION = '$TEMPLATE_VERSION';
d753 4
d764 1
d769 1
a769 1
	if (\$! =~ /Invalid/) {
d774 11
a784 1
		croak "Your vendor has not defined $module macro \$constname";
a786 2
    no strict 'refs';
    *\$AUTOLOAD = sub () { \$val };
d798 11
d819 3
d824 3
d832 19
a850 2
$author = "A. U. Thor";
$email = 'a.u.thor@@a.galaxy.far.far.away';
d852 7
a858 2
my $const_doc = '';
my $fdecl_doc = '';
d860 2
a861 2
  $const_doc = <<EOD;
\n=head1 Exported constants
d868 2
a869 2
  $fdecl_doc = <<EOD;
\n=head1 Exported functions
d871 7
a877 1
  @@{[join "\n  ", @@$fdecls]}
d882 2
a883 2
$pod = <<"END" unless $opt_P;
## Below is the stub of documentation for your module. You better edit it!
d896 1
a896 1
#Stub documentation for $module was created by h2xs. It looks like the
d901 1
a901 1
#$const_doc$fdecl_doc
d929 1
a929 1
    foreach my $path_h (@@path_h) {
d938 72
a1009 4
if( ! $opt_c ){
print XS <<"END";
static int
not_here(char *s)
d1011 4
a1014 1
    croak("$module::%s not implemented on this architecture", s);
d1016 20
d1037 22
d1060 1
d1062 1
a1062 1
constant(char *name, int arg)
d1064 3
a1067 1
    switch (*name) {
d1070 6
a1075 1
my(@@AZ, @@az, @@under);
d1077 3
a1079 5
foreach(@@const_names){
    @@AZ = 'A' .. 'Z' if !@@AZ && /^[A-Z]/;
    @@az = 'a' .. 'z' if !@@az && /^[a-z]/;
    @@under = '_'  if !@@under && /^_/;
}
d1081 3
a1083 1
foreach $letter (@@AZ, @@az, @@under) {
d1085 24
a1108 12
    last if $letter eq 'a' && !@@const_names;

    print XS "    case '$letter':\n";
    my($name);
    while (substr($const_names[0],0,1) eq $letter) {
	$name = shift(@@const_names);
	$macro = $prefix{$name} ? "$opt_p$name" : $name;
	next if $const_xsub{$macro};
	print XS <<"END";
	if (strEQ(name, "$name"))
#ifdef $macro
	    return $macro;
d1112 2
a1113 1
END
d1115 2
a1116 5
    print XS <<"END";
	break;
END
}
print XS <<"END";
d1127 15
d1144 3
d1148 1
d1163 1
a1163 1
    RETVAL = $_;
d1165 1
a1165 1
    croak("Your vendor has not defined the $module macro $_");
d1169 1
a1169 1
    RETVAL
d1179 6
a1184 2
constant(name,arg)
	char *		name
d1186 4
d1194 1
a1194 1

d1203 4
a1206 1
  my @@argtypes = map { normalize_type( $_->[0] ) } @@$args;
d1214 2
a1215 2
  $type = normalize_type($type);
  
d1222 1
a1222 1
  for $arg (0 .. $numargs - 1) {
d1229 131
d1367 5
a1371 3
  my $image;
  
  foreach $typemap (@@tm) {
d1387 2
a1388 1
	if ( ($type, $image) = 
d1392 1
a1392 1
	  normalize_type($type);
d1403 1
a1403 2
sub normalize_type {
  my $ignore_mods = '(?:\b(?:__const__|static|inline|__inline__)\b\s*)*';
d1405 12
a1416 3
  $type =~ s/$ignore_mods//go;
  $type =~ s/([\]\[()])/ \1 /g;
  $type =~ s/\s+/ /g;
d1419 4
a1422 3
  $type =~ s/\b\*/ */g;
  $type =~ s/\*\b/* /g;
  $type =~ s/\*\s+(?=\*)/*/g;
d1428 26
d1455 6
a1460 1
    for $decl (@@$fdecls_parsed) { print_decl(\*XS, $decl) }
d1470 3
a1472 2
  for $type (keys %types_seen) {
    print TM $type, "\t" x (6 - int((length $type)/8)), "T_PTROBJ\n"
d1475 21
d1504 1
a1504 1
print PL <<'END';
d1508 11
a1519 7
print PL "WriteMakefile(\n";
print PL "    'NAME'	=> '$module',\n";
print PL "    'VERSION_FROM' => '$modfname.pm', # finds \$VERSION\n"; 
if( ! $opt_X ){ # print C stuff, unless XS is disabled
  print PL "    'LIBS'	=> ['$extralibs'],   # e.g., '-lm' \n";
  print PL "    'DEFINE'	=> '',     # e.g., '-DHAVE_SOMETHING' \n";
  print PL "    'INC'	=> '',     # e.g., '-I/usr/include/other' \n";
d1554 15
a1568 6
warn "Writing $ext$modpname/Changes\n";
open(EX, ">Changes") || die "Can't create $ext$modpname/Changes: $!\n";
print EX "Revision history for Perl extension $module.\n\n";
print EX "$TEMPLATE_VERSION  ",scalar localtime,"\n";
print EX "\t- original version; created by h2xs $H2XS_VERSION\n\n";
close(EX) || die "Can't close $ext$modpname/Changes: $!\n";
d1572 1
a1572 1
@@files = <*>;
@


1.2
log
@perl 5.004_04
@
text
@d5 1
d16 1
d44 1
a44 1
B<h2xs> [B<-AOPXcdf>] [B<-v> version] [B<-n> module_name] [B<-p> prefix] [B<-s> sub] [headerfile [extra_libraries]]
d50 3
a52 3
I<h2xs> builds a Perl extension from any C header file.  The extension will
include functions which can be used to retrieve the value of any #define
statement which was in the C header.
d55 2
a56 2
module_name is not supplied then the name of the header file will be used,
with the first character capitalized.
d214 1
a214 1
my( $H2XS_VERSION ) = ' $Revision: 1.18 $ ' =~ /\$Revision:\s+([^\s]+)/;
d254 7
a260 2
$path_h    = shift;
$extralibs = "@@ARGV";
d263 1
a263 1
	unless ($path_h or $opt_n);
d266 3
a268 2
if( $path_h ){
    $name = $path_h;
d299 1
a299 1
      # Function prototypes are not (currently) processed.
a317 1
      @@const_names = sort keys %const_names;
d319 2
d377 2
a378 1
    my $filename = $path_h;
d390 3
a392 1
    $fdecls = $c->get('fdecls');
d491 1
d502 2
a503 1
    eval "sub \$AUTOLOAD { \$val }";
a594 3
#ifdef __cplusplus
extern "C" {
#endif
a597 3
#ifdef __cplusplus
}
#endif
d600 2
a601 1
if( $path_h ){
d605 3
a607 4
print XS <<"END";
#include <$h>

END
d613 1
a613 2
not_here(s)
char *s;
d620 1
a620 3
constant(name, arg)
char *name;
int arg;
d897 1
@


1.1
log
@Initial revision
@
text
@d15 3
a17 4
chdir(dirname($0));
($file = basename($0)) =~ s/\.PL$//;
$file =~ s/\.pl$//
	if ($^O eq 'VMS' or $^O eq 'os2');  # "case-forgiving"
d27 3
a29 3
$Config{'startperl'}
    eval 'exec perl -S \$0 "\$@@"'
	if 0;
d42 1
a42 1
B<h2xs> [B<-AOPXcf>] [B<-v> version] [B<-n> module_name] [headerfile [extra_libraries]]
d74 5
d87 5
d97 4
d114 11
d130 1
a130 1
=item B<-X>
d132 10
a141 2
Omit the XS portion.  Used to generate templates for a module which is not
XS-based.
d173 20
d208 1
a208 1
The usual warnings if it can't read or write the files involved.
d212 1
a212 1
my( $H2XS_VERSION ) = '$Revision: 1.16 $' =~ /\$Revision:\s+([^\s]+)/;
d219 1
a219 1
    die "h2xs [-AOPXcfh] [-v version] [-n module_name] [headerfile [extra_libraries]]
a220 3
    -f   Force creation of the extension even if the C header does not exist.
    -n   Specify a name to use for the extension (recommended).
    -c   Omit the constant() function and specialised AUTOLOAD from the XS file.
d222 1
d226 7
d234 1
a234 1
    -h   Display this help message
d242 1
a242 1
getopts("AOPXcfhv:n:") || usage;
d250 1
d265 21
a285 2
    $path_h = "/usr/include/$path_h" unless $path_h =~ m#^[./]#;
    die "Can't find $path_h\n" if ( ! $opt_f && ! -f $path_h );
d287 9
a295 6
    # Scan the header file (we should deal with nested header files)
    # Record the names of simple #define constants into const_names
    # Function prototypes are not (currently) processed.
    open(CH, "<$path_h") || die "Can't open $path_h: $!\n";
    while (<CH>) {
	if (/^#[ \t]*define\s+(\w+)\b\s*[^("]/) {
d298 8
d307 4
a310 1
	}
a311 2
    close(CH);
    @@const_names = sort keys %const_names;
d354 5
d361 21
d383 1
d398 1
a398 1
use vars qw($VERSION @@ISA @@EXPORT);
d406 1
a406 1
use vars qw($VERSION @@ISA @@EXPORT $AUTOLOAD);
d421 1
a421 1
if( $opt_X || (! $opt_A) ){
d521 19
d559 1
a559 1
#
d595 1
d637 2
d641 2
a642 2
#ifdef $name
	    return $name;
d665 1
d669 1
a669 1
MODULE = $module		PACKAGE = $module
d673 18
d702 93
d796 13
d875 11
a885 1
print MANI join("\n",@@files);
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a4 1
use Cwd;
d15 4
a18 4
$origdir = cwd;
chdir dirname($0);
$file = basename($0, '.PL');
$file .= '.com' if $^O eq 'VMS';
d28 3
a30 3
$Config{startperl}
    eval 'exec $Config{perlpath} -S \$0 \${1+"\$@@"}'
	if \$running_under_some_shell;
d43 1
a43 1
B<h2xs> [B<-AOPXcdf>] [B<-v> version] [B<-n> module_name] [B<-p> prefix] [B<-s> sub] [headerfile ... [extra_libraries]]
d49 3
a51 3
I<h2xs> builds a Perl extension from C header files.  The extension
will include functions which can be used to retrieve the value of any
#define statement which was in the C header files.
d54 2
a55 2
module_name is not supplied then the name of the first header file
will be used, with the first character capitalized.
a74 5
=item B<-F>

Additional flags to specify to C preprocessor when scanning header for
function declarations. Should not be used without B<-x>.

a82 5
=item B<-X>

Omit the XS portion.  Used to generate templates for a module which is not
XS-based.

a87 4
=item B<-d>

Turn on debugging messages.

a100 11
=item B<-p> I<prefix>

Specify a prefix which should be removed from the Perl function names, e.g., S<-p sec_rgy_> 
This sets up the XS B<PREFIX> keyword and removes the prefix from functions that are
autoloaded via the C<constant()> mechansim.

=item B<-s> I<sub1,sub2>

Create a perl subroutine for the specified macros rather than autoload with the constant() subroutine.
These macros are assumed to have a return type of B<char *>, e.g., S<-s sec_rgy_wildcard_name,sec_rgy_wildcard_sid>.

d106 1
a106 1
=item B<-x>
d108 2
a109 10
Automatically generate XSUBs basing on function declarations in the
header file.  The package C<C::Scan> should be installed. If this
option is specified, the name of the header file may look like
C<NAME1,NAME2>. In this case NAME1 is used instead of the specified string,
but XSUBs are emitted only for the declarations included from file NAME2.

Note that some types of arguments/return-values for functions may
result in XSUB-declarations/typemap-entries which need
hand-editing. Such may be objects which cannot be converted from/to a
pointer (like C<long long>), pointers to functions, or arrays.
a140 20
        # Extension is DCE::rgynbase
        # prefix "sec_rgy_" is dropped from perl function names
        h2xs -n DCE::rgynbase -p sec_rgy_ dce/rgynbase

        # Extension is DCE::rgynbase
        # prefix "sec_rgy_" is dropped from perl function names
        # subroutines are created for sec_rgy_wildcard_name and sec_rgy_wildcard_sid
        h2xs -n DCE::rgynbase -p sec_rgy_ \
        -s sec_rgy_wildcard_name,sec_rgy_wildcard_sid dce/rgynbase

	# Make XS without defines in perl.h, but with function declarations
	# visible from perl.h. Name of the extension is perl1.
	# When scanning perl.h, define -DEXT=extern -DdEXT= -DINIT(x)=
	# Extra backslashes below because the string is passed to shell.
	# Note that a directory with perl header files would 
	#  be added automatically to include path.
	h2xs -xAn perl1 -F "-DEXT=extern -DdEXT= -DINIT\(x\)=" perl.h

	# Same with function declaration in proto.h as visible from perl.h.
	h2xs -xAn perl2 perl.h,proto.h
d156 1
a156 1
The usual warnings if it cannot read or write the files involved.
d160 1
a160 1
my( $H2XS_VERSION ) = ' $Revision: 1.19 $ ' =~ /\$Revision:\s+([^\s]+)/;
d167 1
a167 1
    die "h2xs [-AOPXcdfh] [-v version] [-n module_name] [-p prefix] [-s subs] [headerfile [extra_libraries]]
d169 3
a172 1
    -F   Additional flags for C preprocessor (used with -x).
d176 1
a176 3
    -c   Omit the constant() function and specialised AUTOLOAD from the XS file.
    -d   Turn on debugging messages.
    -f   Force creation of the extension even if the C header does not exist.
a177 5
    -n   Specify a name to use for the extension (recommended).
    -p   Specify a prefix which should be removed from the Perl function names.
    -s   Create subroutines for specified macros.
    -v   Specify a version number for this extension.
    -x   Autogenerate XSUBs using C::Scan.
d185 1
a185 1
getopts("AF:OPXcdfhn:p:s:v:x") || usage;
a192 1
%const_xsub = map { $_,1 } split(/,+/, $opt_s) if $opt_s;
d194 2
a195 7
while (my $arg = shift) {
    if ($arg =~ /^-l/i) {
        $extralibs = "$arg @@ARGV";
        last;
    }
    push(@@path_h, $arg);
}
d198 1
a198 1
        unless (@@path_h or $opt_n);
d201 2
a202 3
if( @@path_h ){
    foreach my $path_h (@@path_h) {
        $name ||= $path_h;
d207 2
a208 21
    $fullpath = $path_h;
    $path_h =~ s/,.*$// if $opt_x;
    if ($^O eq 'VMS') {  # Consider overrides of default location
	if ($path_h !~ m![:>\[]!) {
	    my($hadsys) = ($path_h =~ s!^sys/!!i);
	    if ($ENV{'DECC$System_Include'})     { $path_h = "DECC\$System_Include:$path_h";    }
	    elsif ($ENV{'DECC$Library_Include'}) { $path_h = "DECC\$Library_Include:$path_h";   }
	    elsif ($ENV{'GNU_CC_Include'})       { $path_h = 'GNU_CC_Include:' .
	                                            ($hadsys ? '[vms]' : '[000000]') . $path_h; }
	    elsif ($ENV{'VAXC$Include'})         { $path_h = "VAXC\$_Include:$path_h";          }
	    else                                 { $path_h = "Sys\$Library:$path_h";            }
	}
    }
    elsif ($^O eq 'os2') {
	$path_h = "/usr/include/$path_h" 
	  if $path_h !~ m#^([a-z]:)?[./]#i and -r "/usr/include/$path_h"; 
    }
    else { 
      $path_h = "/usr/include/$path_h" 
	if $path_h !~ m#^[./]# and -r "/usr/include/$path_h"; 
    }
d210 6
a215 9
    if (!$opt_c) {
      die "Can't find $path_h\n" if ( ! $opt_f && ! -f $path_h );
      # Scan the header file (we should deal with nested header files)
      # Record the names of simple #define constants into const_names
            # Function prototypes are processed below.
      open(CH, "<$path_h") || die "Can't open $path_h: $!\n";
      while (<CH>) {
	if (/^#[ \t]*define\s+([\$\w]+)\b\s*[^("]/) {
	    print "Matched $_ ($1)\n" if $opt_d;
a217 8
	    if (defined $opt_p) {
	      if (!/^$opt_p(\d)/) {
		++$prefix{$_} if s/^$opt_p//;
	      }
	      else {
		warn "can't remove $opt_p prefix from '$_'!\n";
	      }
	    }
d219 1
a219 4
	  }
      }
      close(CH);
    }
d221 1
a264 5
my %types_seen;
my %std_types;
my $fdecls;
my $fdecls_parsed;

a266 24
  if ($opt_x) {
    require C::Scan;		# Run-time directive
    require Config;		# Run-time directive
    warn "Scanning typemaps...\n";
    get_typemap();
    my $c;
    my $filter;
        my @@fdecls;
        foreach my $filename (@@path_h) {
    my $addflags = $opt_F || '';
    if ($fullpath =~ /,/) {
      $filename = $`;
      $filter = $';
    }
    warn "Scanning $filename for functions...\n";
    $c = new C::Scan 'filename' => $filename, 'filename_filter' => $filter,
    'add_cppflags' => $addflags;
    $c->set('includeDirs' => ["$Config::Config{archlib}/CORE"]);
    
    $fdecls_parsed = $c->get('parsed_fdecls');
            push(@@fdecls, @@{$c->get('fdecls')});
        }
        $fdecls = [ @@fdecls ];
  }
a267 1

d282 1
a282 1
use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK);
d290 1
a290 1
use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK $AUTOLOAD);
d305 1
a305 1
if( ($opt_X && (! $opt_A)) || (!$opt_X) ) {
a362 1
    croak "&$module::constant not defined" if \$constname eq 'constant';
d373 1
a373 2
    no strict 'refs';
    *\$AUTOLOAD = sub () { \$val };
a404 19
my $const_doc = '';
my $fdecl_doc = '';
if (@@const_names and not $opt_P) {
  $const_doc = <<EOD;
\n=head1 Exported constants

  @@{[join "\n  ", @@const_names]}

EOD
}
if (defined $fdecls and @@$fdecls and not $opt_P) {
  $fdecl_doc = <<EOD;
\n=head1 Exported functions

  @@{[join "\n  ", @@$fdecls]}

EOD
}

d424 1
a424 1
#$const_doc$fdecl_doc
d446 3
d452 3
d457 1
a457 2
if( @@path_h ){
    foreach my $path_h (@@path_h) {
d460 4
a463 4
	if ($^O eq 'VMS') { $h =~ s#.*vms\]#sys/# or $h =~ s#.*[:>\]]##; }
        print XS qq{#include <$h>\n};
    }
    print XS "\n";
d469 2
a470 1
not_here(char *s)
d477 3
a479 1
constant(char *name, int arg)
a500 2
	$macro = $prefix{$name} ? "$opt_p$name" : $name;
	next if $const_xsub{$macro};
d503 2
a504 2
#ifdef $macro
	    return $macro;
a526 1
$prefix = "PREFIX = $opt_p" if defined $opt_p;
d530 1
a530 18
MODULE = $module		PACKAGE = $module		$prefix

END

foreach (sort keys %const_xsub) {
    print XS <<"END";
char *
$_()

    CODE:
#ifdef $_
    RETVAL = $_;
#else
    croak("Your vendor has not defined the $module macro $_");
#endif

    OUTPUT:
    RETVAL
a532 1
}
a544 93
my %seen_decl;


sub print_decl {
  my $fh = shift;
  my $decl = shift;
  my ($type, $name, $args) = @@$decl;
  return if $seen_decl{$name}++; # Need to do the same for docs as well?

  my @@argnames = map {$_->[1]} @@$args;
  my @@argtypes = map { normalize_type( $_->[0] ) } @@$args;
  my @@argarrays = map { $_->[4] || '' } @@$args;
  my $numargs = @@$args;
  if ($numargs and $argtypes[-1] eq '...') {
    $numargs--;
    $argnames[-1] = '...';
  }
  local $" = ', ';
  $type = normalize_type($type);
  
  print $fh <<"EOP";

$type
$name(@@argnames)
EOP

  for $arg (0 .. $numargs - 1) {
    print $fh <<"EOP";
	$argtypes[$arg]	$argnames[$arg]$argarrays[$arg]
EOP
  }
}

# Should be called before any actual call to normalize_type().
sub get_typemap {
  # We do not want to read ./typemap by obvios reasons.
  my @@tm =  qw(../../../typemap ../../typemap ../typemap);
  my $stdtypemap =  "$Config::Config{privlib}/ExtUtils/typemap";
  unshift @@tm, $stdtypemap;
  my $proto_re = "[" . quotemeta('\$%&*@@;') . "]" ;
  my $image;
  
  foreach $typemap (@@tm) {
    next unless -e $typemap ;
    # skip directories, binary files etc.
    warn " Scanning $typemap\n";
    warn("Warning: ignoring non-text typemap file '$typemap'\n"), next 
      unless -T $typemap ;
    open(TYPEMAP, $typemap) 
      or warn ("Warning: could not open typemap file '$typemap': $!\n"), next;
    my $mode = 'Typemap';
    while (<TYPEMAP>) {
      next if /^\s*\#/;
      if (/^INPUT\s*$/)   { $mode = 'Input'; next; }
      elsif (/^OUTPUT\s*$/)  { $mode = 'Output'; next; }
      elsif (/^TYPEMAP\s*$/) { $mode = 'Typemap'; next; }
      elsif ($mode eq 'Typemap') {
	next if /^\s*($|\#)/ ;
	if ( ($type, $image) = 
	     /^\s*(.*?\S)\s+(\S+)\s*($proto_re*)\s*$/o
	     # This may reference undefined functions:
	     and not ($image eq 'T_PACKED' and $typemap eq $stdtypemap)) {
	  normalize_type($type);
	}
      }
    }
    close(TYPEMAP) or die "Cannot close $typemap: $!";
  }
  %std_types = %types_seen;
  %types_seen = ();
}


sub normalize_type {
  my $ignore_mods = '(?:\b(?:__const__|static|inline|__inline__)\b\s*)*';
  my $type = shift;
  $type =~ s/$ignore_mods//go;
  $type =~ s/([\]\[()])/ \1 /g;
  $type =~ s/\s+/ /g;
  $type =~ s/\s+$//;
  $type =~ s/^\s+//;
  $type =~ s/\b\*/ */g;
  $type =~ s/\*\b/* /g;
  $type =~ s/\*\s+(?=\*)/*/g;
  $types_seen{$type}++ 
    unless $type eq '...' or $type eq 'void' or $std_types{$type};
  $type;
}

if ($opt_x) {
    for $decl (@@$fdecls_parsed) { print_decl(\*XS, $decl) }
}

a545 13

if (%types_seen) {
  my $type;
  warn "Writing $ext$modpname/typemap\n";
  open TM, ">typemap" or die "Cannot open typemap file for write: $!";

  for $type (keys %types_seen) {
    print TM $type, "\t" x (6 - int((length $type)/8)), "T_PTROBJ\n"
  }

  close TM or die "Cannot close typemap file for write: $!";
}

d612 1
a612 11
if ($^O eq 'VMS') {
  foreach (@@files) {
    # Clip trailing '.' for portability -- non-VMS OSs don't expect it
    s%\.$%%;
    # Fix up for case-sensitive file systems
    s/$modfname/$modfname/i && next;
    $_ = "\U$_" if $_ eq 'manifest' or $_ eq 'changes';
    $_ = 'Makefile.PL' if $_ eq 'makefile.pl';
  }
}
print MANI join("\n",@@files), "\n";
a618 1
chdir $origdir;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d44 1
a44 1
B<h2xs> [B<-ACOPXcdf>] [B<-v> version] [B<-n> module_name] [B<-p> prefix] [B<-s> sub] [headerfile ... [extra_libraries]]
d74 1
a74 6
S<C<use AutoLoader>> statement from the .pm file.

=item B<-C>

Omits creation of the F<Changes> file, and adds a HISTORY section to
the POD template.
d79 1
a79 5
function declarations.  Should not be used without B<-x>.

=item B<-M> I<regular expression>

selects functions/macros to process.
d92 1
a92 15
XS-based.  C<-c> and C<-f> are implicitly enabled.

=item B<-a>

Generate an accessor method for each element of structs and unions. The
generated methods are named after the element name; will return the current
value of the element if called without additional arguments; and will set
the element to the supplied value (and return the new value) if called with
an additional argument. Embedded structures and unions are returned as a
pointer rather than the complete structure, to facilitate chained calls.

These methods all apply to the Ptr type for the structure; additionally
two methods are constructed for the structure type itself, C<_to_ptr>
which returns a Ptr type pointing to the same structure, and a C<new>
method to construct and return a new structure, initialised to zeroes.
d106 1
a106 1
not found in standard include directories.
a111 10
=item B<-k>

For function arguments declared as C<const>, omit the const attribute in the
generated XS code.

=item B<-m>

B<Experimental>: for each variable declared in the header file(s), declare
a perl variable of the same name magically tied to the C variable.

a115 15
=item B<-o> I<regular expression>

Use "opaque" data type for the C types matched by the regular
expression, even if these types are C<typedef>-equivalent to types
from typemaps.  Should not be used without B<-x>.

This may be useful since, say, types which are C<typedef>-equivalent
to integers may represent OS-related handles, and one may want to work
with these handles in OO-way, as in C<$handle-E<gt>do_something()>.
Use C<-o .> if you want to handle all the C<typedef>ed types as opaque types.

The type-to-match is whitewashed (except for commas, which have no
whitespace before them, and multiple C<*> which have no whitespace
between them).

d120 1
a120 1
autoloaded via the C<constant()> mechanism.
d143 1
a143 2
pointer (like C<long long>), pointers to functions, or arrays.  See
also the section on L<LIMITATIONS of B<-x>>.
a195 6
	# Same but select only functions which match /^av_/
	h2xs -M '^av_' -xAn perl2 perl.h,proto.h

	# Same but treat SV* etc as "opaque" types
	h2xs -o '^[S]V \*$' -M '^av_' -xAn perl2 perl.h,proto.h

a211 60
=head1 LIMITATIONS of B<-x>

F<h2xs> would not distinguish whether an argument to a C function
which is of the form, say, C<int *>, is an input, output, or
input/output parameter.  In particular, argument declarations of the
form

    int
    foo(n)
	int *n

should be better rewritten as

    int
    foo(n)
	int &n

if C<n> is an input parameter.

Additionally, F<h2xs> has no facilities to intuit that a function

   int
   foo(addr,l)
	char *addr
	int   l

takes a pair of address and length of data at this address, so it is better
to rewrite this function as

    int
    foo(sv)
	    SV *addr
	PREINIT:
	    STRLEN len;
	    char *s;
	CODE:
	    s = SvPV(sv,len);
	    RETVAL = foo(s, len);
	OUTPUT:
	    RETVAL

or alternately

    static int
    my_foo(SV *sv)
    {
	STRLEN len;
	char *s = SvPV(sv,len);

	return foo(s, len);
    }

    MODULE = foo	PACKAGE = foo	PREFIX = my_

    int
    foo(sv)
	SV *sv

See L<perlxs> and L<perlxstut> for additional details.

d214 1
a214 4
use strict;


my( $H2XS_VERSION ) = ' $Revision: 1.20 $ ' =~ /\$Revision:\s+([^\s]+)/;
a215 1
my @@ARGS = @@ARGV;
d221 1
a221 1
    die "h2xs [-ACOPXcdfh] [-v version] [-n module_name] [-p prefix] [-s subs] [headerfile [extra_libraries]]
a223 1
    -C   Omit creating the Changes file, add HISTORY heading to stub POD.
a224 1
    -M   Mask to select C functions/macros (default is select all).
d227 1
a227 2
    -X   Omit the XS portion (implies both -c and -f).
    -a   Generate get/set accessors for struct and union members (used with -x).
a231 2
    -k   Omit 'const' attribute on function arguments (used with -x).
    -m   Generate tied variables for access to declared variables.
a232 1
    -o   Regular expression for \"opaque\" types.
d244 1
a244 3
getopts("ACF:M:OPXacdfhkmn:o:p:s:v:x") || usage;
use vars qw($opt_A $opt_C $opt_F $opt_M $opt_O $opt_P $opt_X $opt_a $opt_c $opt_d
	    $opt_f $opt_h $opt_k $opt_m $opt_n $opt_o $opt_p $opt_s $opt_v $opt_x);
a250 2

# -A implies -c.
d252 1
a252 7

# -X implies -c and -f
$opt_c = $opt_f = 1 if $opt_X;

my %const_xsub = map { $_,1 } split(/,+/, $opt_s) if $opt_s;
my $extralibs;
my @@path_h;
a264 40
my $fmask;
my $tmask;

$fmask = qr{$opt_M} if defined $opt_M;
$tmask = qr{$opt_o} if defined $opt_o;
my $tmask_all = $tmask && $opt_o eq '.';

if ($opt_x) {
  eval {require C::Scan; 1}
    or die <<EOD;
C::Scan required if you use -x option.
To install C::Scan, execute
   perl -MCPAN -e "install C::Scan"
EOD
  unless ($tmask_all) {
    $C::Scan::VERSION >= 0.70
      or die <<EOD;
C::Scan v. 0.70 or later required unless you use -o . option.
You have version $C::Scan::VERSION installed as $INC{'C/Scan.pm'}.
To install C::Scan, execute
   perl -MCPAN -e "install C::Scan"
EOD
  }
  if (($opt_m || $opt_a) && $C::Scan::VERSION < 0.73) {
    die <<EOD;
C::Scan v. 0.73 or later required to use -m or -a options.
You have version $C::Scan::VERSION installed as $INC{'C/Scan.pm'}.
To install C::Scan, execute
   perl -MCPAN -e "install C::Scan"
EOD
  }
}
elsif ($opt_o or $opt_F) {
  warn <<EOD;
Options -o and -F do not make sense without -x.
EOD
}

my @@path_h_ini = @@path_h;
my ($name, %fullpath, %prefix, %seen_define, %prefixless, %const_names);
a266 15
    use Config;
    use File::Spec;
    my @@paths;
    if ($^O eq 'VMS') {  # Consider overrides of default location
      # XXXX This is not equivalent to what the older version did:
      #		it was looking at $hadsys header-file per header-file...
      my($hadsys) = grep s!^sys/!!i , @@path_h;
      @@paths = qw( Sys$Library VAXC$Include );
      push @@paths, ($hadsys ? 'GNU_CC_Include[vms]' : 'GNU_CC_Include[000000]');
      push @@paths, qw( DECC$Library_Include DECC$System_Include );
    }
    else {
      @@paths = (File::Spec->curdir(), $Config{usrinc},
		(split ' ', $Config{locincpth}), '/usr/include');
    }
d273 1
a273 1
    my $fullpath = $path_h;
d275 18
a292 7
    $fullpath{$path_h} = $fullpath;

    if (not -f $path_h) {
      my $tmp_path_h = $path_h;
      for my $dir (@@paths) {
	last if -f ($path_h = File::Spec->catfile($dir, $tmp_path_h));
      }
a300 1
    defines:
d302 3
a304 16
	if (/^[ \t]*#[ \t]*define\s+([\$\w]+)\b(?!\()\s*(?=[^" \t])(.*)/) {
	    my $def = $1;
	    my $rest = $2;
	    $rest =~ s!/\*.*?(\*/|\n)|//.*!!g; # Remove comments
	    $rest =~ s/^\s+//;
	    $rest =~ s/\s+$//;
	    # Cannot do: (-1) and ((LHANDLE)3) are OK:
	    #print("Skip non-wordy $def => $rest\n"),
	    #  next defines if $rest =~ /[^\w\$]/;
	    if ($rest =~ /"/) {
	      print("Skip stringy $def => $rest\n") if $opt_d;
	      next defines;
	    }
	    print "Matched $_ ($def)\n" if $opt_d;
	    $seen_define{$def} = $rest;
	    $_ = $def;
d314 1
a314 5
	    $prefixless{$def} = $_;
	    if (!$fmask or /$fmask/) {
		print "... Passes mask of -M.\n" if $opt_d and $fmask;
		$const_names{$_}++;
	    }
d320 1
d324 1
a324 1
my $module = $opt_n || do {
a332 1
my ($ext, $nested, @@modparts, $modfname, $modpname);
d350 1
a350 2
}
else {
d354 1
a354 1
	my $modpath = "";
d365 2
a366 11
my $fdecls = [];
my $fdecls_parsed = [];
my $typedef_rex;
my %typedefs_pre;
my %known_fnames;
my %structs;

my @@fnames;
my @@fnames_no_prefix;
my %vdecl_hash;
my @@vdecls;
d371 1
d375 4
a378 2
    my @@td;
    my @@good_td;
d380 13
a392 95

    foreach my $filename (@@path_h) {
      my $c;
      my $filter;

      if ($fullpath{$filename} =~ /,/) {
	$filename = $`;
	$filter = $';
      }
      warn "Scanning $filename for functions...\n";
      $c = new C::Scan 'filename' => $filename, 'filename_filter' => $filter,
	'add_cppflags' => $addflags, 'c_styles' => [qw(C++ C9X)];
      $c->set('includeDirs' => ["$Config::Config{archlib}/CORE"]);

      push @@$fdecls_parsed, @@{ $c->get('parsed_fdecls') };
      push(@@$fdecls, @@{$c->get('fdecls')});

      push @@td, @@{$c->get('typedefs_maybe')};
      if ($opt_a) {
	my $structs = $c->get('typedef_structs');
	@@structs{keys %$structs} = values %$structs;
      }

      if ($opt_m) {
	%vdecl_hash = %{ $c->get('vdecl_hash') };
	@@vdecls = sort keys %vdecl_hash;
	for (local $_ = 0; $_ < @@vdecls; ++$_) {
	  my $var = $vdecls[$_];
	  my($type, $post) = @@{ $vdecl_hash{$var} };
	  if (defined $post) {
	    warn "Can't handle variable '$type $var $post', skipping.\n";
	    splice @@vdecls, $_, 1;
	    redo;
	  }
	  $type = normalize_type($type);
	  $vdecl_hash{$var} = $type;
	}
      }

      unless ($tmask_all) {
	warn "Scanning $filename for typedefs...\n";
	my $td = $c->get('typedef_hash');
	# eval {require 'dumpvar.pl'; ::dumpValue($td)} or warn $@@ if $opt_d;
	my @@f_good_td = grep $td->{$_}[1] eq '', keys %$td;
	push @@good_td, @@f_good_td;
	@@typedefs_pre{@@f_good_td}  = map $_->[0], @@$td{@@f_good_td};
      }
    }
    { local $" = '|';
      $typedef_rex = qr(\b(?<!struct )(?:@@good_td)\b) if @@good_td;
    }
    %known_fnames = map @@$_[1,3], @@$fdecls_parsed; # [1,3] is NAME, FULLTEXT
    if ($fmask) {
      my @@good;
      for my $i (0..$#$fdecls_parsed) {
	next unless $fdecls_parsed->[$i][1] =~ /$fmask/; # [1] is NAME
	push @@good, $i;
	print "... Function $fdecls_parsed->[$i][1] passes -M mask.\n"
	  if $opt_d;
      }
      $fdecls = [@@$fdecls[@@good]];
      $fdecls_parsed = [@@$fdecls_parsed[@@good]];
    }
    @@fnames = sort map $_->[1], @@$fdecls_parsed; # 1 is NAME
    # Sort declarations:
    {
      my %h = map( ($_->[1], $_), @@$fdecls_parsed);
      $fdecls_parsed = [ @@h{@@fnames} ];
    }
    @@fnames_no_prefix = @@fnames;
    @@fnames_no_prefix
      = sort map { ++$prefix{$_} if s/^$opt_p(?!\d)//; $_ } @@fnames_no_prefix;
    # Remove macros which expand to typedefs
    print "Typedefs are @@td.\n" if $opt_d;
    my %td = map {($_, $_)} @@td;
    # Add some other possible but meaningless values for macros
    for my $k (qw(char double float int long short unsigned signed void)) {
      $td{"$_$k"} = "$_$k" for ('', 'signed ', 'unsigned ');
    }
    # eval {require 'dumpvar.pl'; ::dumpValue( [\@@td, \%td] ); 1} or warn $@@;
    my $n = 0;
    my %bad_macs;
    while (keys %td > $n) {
      $n = keys %td;
      my ($k, $v);
      while (($k, $v) = each %seen_define) {
	# print("found '$k'=>'$v'\n"), 
	$bad_macs{$k} = $td{$k} = $td{$v} if exists $td{$v};
      }
    }
    # Now %bad_macs contains names of bad macros
    for my $k (keys %bad_macs) {
      delete $const_names{$prefixless{$k}};
      print "Ignoring macro $k which expands to a typedef name '$bad_macs{$k}'\n" if $opt_d;
    }
a394 1
my @@const_names = sort keys %const_names;
a403 1
require 5.005_62;
a404 1
use warnings;
d407 7
a413 1
unless( $opt_X || $opt_c || $opt_A ){
d418 1
d431 12
d444 2
a445 4
# Are we using AutoLoader or not?
unless ($opt_A) { # no autoloader whatsoever.
	unless ($opt_c) { # we're doing the AUTOLOAD
		print PM "use AutoLoader;\n";
d447 5
a451 2
	else {
		print PM "use AutoLoader qw(AUTOLOAD);\n"
d454 6
d461 5
a465 5
# Determine @@ISA.
my $myISA = 'our @@ISA = qw(Exporter';	# We seem to always want this.
$myISA .= ' DynaLoader' 	unless $opt_X;  # no XS
$myISA .= ');';
print PM "\n$myISA\n\n";
d467 4
a470 1
my @@exported_names = (@@const_names, @@fnames_no_prefix, map '$'.$_, @@vdecls);
d476 1
a476 11

# This allows declaration	use $module ':all';
# If you do not need this, moving things directly into \@@EXPORT or \@@EXPORT_OK
# will save memory.
our %EXPORT_TAGS = ( 'all' => [ qw(
	@@exported_names
) ] );

our \@@EXPORT_OK = ( \@@{ \$EXPORT_TAGS{'all'} } );

our \@@EXPORT = qw(
d479 1
a479 1
our \$VERSION = '$TEMPLATE_VERSION';
a482 4
if (@@vdecls) {
    printf PM "our(@@{[ join ', ', map '$'.$_, @@vdecls ]});\n\n";
}

a489 1
    our \$AUTOLOAD;
d494 1
a494 1
	if (\$! =~ /Invalid/ || \$!{EINVAL}) {
d499 1
a499 11
	    croak "Your vendor has not defined $module macro \$constname";
	}
    }
    {
	no strict 'refs';
	# Fixed between 5.005_53 and 5.005_61
	if (\$] >= 5.00561) {
	    *\$AUTOLOAD = sub () { \$val };
	}
	else {
	    *\$AUTOLOAD = sub { \$val };
d502 2
a514 11
# tying the variables can happen only after bootstrap
if (@@vdecls) {
    printf PM <<END;
{
@@{[ join "\n", map "    _tievar_$_(\$$_);", @@vdecls ]}
}

END
}

my $after;
a524 3
END

print PM <<"END" unless $opt_A;
a526 3
END

print PM <<"END";
d532 2
a533 19
my $author = "A. U. Thor";
my $email = 'a.u.thor@@a.galaxy.far.far.away';

my $revhist = '';
$revhist = <<EOT if $opt_C;

=head1 HISTORY

=over 8

=item $TEMPLATE_VERSION

Original version; created by h2xs $H2XS_VERSION with options

  @@ARGS

=back

EOT
d535 2
a536 7
my $exp_doc = <<EOD;

=head2 EXPORT

None by default.

EOD
d538 2
a539 2
  $exp_doc .= <<EOD;
=head2 Exportable constants
d546 2
a547 2
  $exp_doc .= <<EOD;
=head2 Exportable functions
d549 1
a549 7
EOD
  $exp_doc .= <<EOD if $opt_p;
When accessing these functions from Perl, prefix C<$opt_p> should be removed.

EOD
  $exp_doc .= <<EOD;
  @@{[join "\n  ", @@known_fnames{@@fnames}]}
d554 2
a555 2
my $pod = <<"END" unless $opt_P;
## Below is stub documentation for your module. You better edit it!
d568 1
a568 1
#Stub documentation for $module, created by h2xs. It looks like the
d573 1
a573 1
#$exp_doc$revhist
d601 1
a601 1
    foreach my $path_h (@@path_h_ini) {
d610 4
a613 72
my %pointer_typedefs;
my %struct_typedefs;

sub td_is_pointer {
  my $type = shift;
  my $out = $pointer_typedefs{$type};
  return $out if defined $out;
  my $otype = $type;
  $out = ($type =~ /\*$/);
  # This converts only the guys which do not have trailing part in the typedef
  if (not $out
      and $typedef_rex and $type =~ s/($typedef_rex)/$typedefs_pre{$1}/go) {
    $type = normalize_type($type);
    print "Is-Pointer: Type mutation via typedefs: $otype ==> $type\n"
      if $opt_d;
    $out = td_is_pointer($type);
  }
  return ($pointer_typedefs{$otype} = $out);
}

sub td_is_struct {
  my $type = shift;
  my $out = $struct_typedefs{$type};
  return $out if defined $out;
  my $otype = $type;
  $out = ($type =~ /^(struct|union)\b/) && !td_is_pointer($type);
  # This converts only the guys which do not have trailing part in the typedef
  if (not $out
      and $typedef_rex and $type =~ s/($typedef_rex)/$typedefs_pre{$1}/go) {
    $type = normalize_type($type);
    print "Is-Struct: Type mutation via typedefs: $otype ==> $type\n"
      if $opt_d;
    $out = td_is_struct($type);
  }
  return ($struct_typedefs{$otype} = $out);
}

# Some macros will bomb if you try to return them from a double-returning func.
# Say, ((char *)0), or strlen (if somebody #define STRLEN strlen).
# Fortunately, we can detect both these cases...
sub protect_convert_to_double {
  my $in = shift;
  my $val;
  return '' unless defined ($val = $seen_define{$in});
  return '(IV)' if $known_fnames{$val};
  # OUT_t of ((OUT_t)-1):
  return '' unless $val =~ /^\s*(\(\s*)?\(\s*([^()]*?)\s*\)/;
  td_is_pointer($2) ? '(IV)' : '';
}

# For each of the generated functions, length($pref) leading
# letters are already checked.  Moreover, it is recommended that
# the generated functions uses switch on letter at offset at least
# $off + length($pref).
#
# The given list has length($pref) chars removed at front, it is
# guarantied that $off leading chars in the rest are the same for all
# elts of the list.
#
# Returns: how at which offset it was decided to make a switch, or -1 if none.

sub write_const;

sub write_const {
  my ($fh, $pref, $off, $list) = (shift,shift,shift,shift);
  my %leading;
  my $offarg = length $pref;

  if (@@$list == 0) {		# Can happen on the initial iteration only
    print $fh <<"END";
static double
constant(char *name, int len, int arg)
d615 2
a616 2
    errno = EINVAL;
    return 0;
a617 6
END
    return -1;
  }

  if (@@$list == 1) {		# Can happen on the initial iteration only
    my $protect = protect_convert_to_double("$pref$list->[0]");
a618 1
    print $fh <<"END";
d620 1
a620 1
constant(char *name, int len, int arg)
d623 1
a623 11
    if (strEQ(name + $offarg, "$list->[0]")) {	/* $pref removed */
#ifdef $pref$list->[0]
	return $protect$pref$list->[0];
#else
	errno = ENOENT;
	return 0;
#endif
    }
    errno = EINVAL;
    return 0;
}
a624 2
    return -1;
  }
d626 1
a626 5
  for my $n (@@$list) {
    my $c = substr $n, $off, 1;
    $leading{$c} = [] unless exists $leading{$c};
    push @@{$leading{$c}}, substr $n, $off + 1;
  }
d628 5
a632 12
  if (keys(%leading) == 1) {
    return 1 + write_const $fh, $pref, $off + 1, $list;
  }

  my $leader = substr $list->[0], 0, $off;
  foreach my $letter (keys %leading) {
    write_const $fh, "$pref$leader$letter", 0, $leading{$letter}
      if @@{$leading{$letter}} > 1;
  }

  my $npref = "_$pref";
  $npref = '' if $pref eq '';
d634 1
a634 20
  print $fh <<"END";
static double
constant$npref(char *name, int len, int arg)
{
END

  print $fh <<"END" if $npref eq '';
    errno = 0;
END

  print $fh <<"END" if $off;
    if ($offarg + $off >= len ) {
	errno = EINVAL;
	return 0;
    }
END

  print $fh <<"END";
    switch (name[$offarg + $off]) {
END
d636 1
a636 3
  foreach my $letter (sort keys %leading) {
    my $let = $letter;
    $let = '\0' if $letter eq '';
d638 10
a647 24
    print $fh <<EOP;
    case '$let':
EOP
    if (@@{$leading{$letter}} > 1) {
      # It makes sense to call a function
      if ($off) {
	print $fh <<EOP;
	if (!strnEQ(name + $offarg,"$leader", $off))
	    break;
EOP
      }
      print $fh <<EOP;
	return constant_$pref$leader$letter(name, len, arg);
EOP
    }
    else {
      # Do it ourselves
      my $protect
	= protect_convert_to_double("$pref$leader$letter$leading{$letter}[0]");

      print $fh <<EOP;
	if (strEQ(name + $offarg, "$leader$letter$leading{$letter}[0]")) {	/* $pref removed */
#ifdef $pref$leader$letter$leading{$letter}[0]
	    return $protect$pref$leader$letter$leading{$letter}[0];
d651 1
a651 2
	}
EOP
d653 5
a657 2
  }
  print $fh <<"END";
a667 15

}

if( ! $opt_c ) {
  print XS <<"END";
static int
not_here(char *s)
{
    croak("$module::%s not implemented on this architecture", s);
    return -1;
}

END

  write_const(\*XS, '', 0, \@@const_names);
a669 3
print_tievar_subs(\*XS, $_, $vdecl_hash{$_}) for @@vdecls;

my $prefix;
a670 1

d685 1
a685 1
	RETVAL = $_;
d687 1
a687 1
	croak("Your vendor has not defined the $module macro $_");
d691 1
a691 1
	RETVAL
d701 2
a702 6
constant(sv,arg)
    PREINIT:
	STRLEN		len;
    INPUT:
	SV *		sv
	char *		s = SvPV(sv, len);
a703 4
    CODE:
	RETVAL = constant(s,len,arg);
    OUTPUT:
	RETVAL
d708 1
a708 1
my %typemap;
d717 1
a717 4
  my @@argtypes = map { normalize_type( $_->[0], 1 ) } @@$args;
  if ($opt_k) {
    s/^\s*const\b\s*// for @@argtypes;
  }
d725 2
a726 2
  $type = normalize_type($type, 1);

d733 1
a733 1
  for my $arg (0 .. $numargs - 1) {
a739 131
sub print_tievar_subs {
  my($fh, $name, $type) = @@_;
  print $fh <<END;
I32
_get_$name(IV index, SV *sv) {
    dSP;
    PUSHMARK(SP);
    XPUSHs(sv);
    PUTBACK;
    (void)call_pv("$module\::_get_$name", G_DISCARD);
    return (I32)0;
}

I32
_set_$name(IV index, SV *sv) {
    dSP;
    PUSHMARK(SP);
    XPUSHs(sv);
    PUTBACK;
    (void)call_pv("$module\::_set_$name", G_DISCARD);
    return (I32)0;
}

END
}

sub print_tievar_xsubs {
  my($fh, $name, $type) = @@_;
  print $fh <<END;
void
_tievar_$name(sv)
	SV* sv
    PREINIT:
	struct ufuncs uf;
    CODE:
	uf.uf_val = &_get_$name;
	uf.uf_set = &_set_$name;
	uf.uf_index = (IV)&_get_$name;
	sv_magic(sv, 0, 'U', (char*)&uf, sizeof(uf));

void
_get_$name(THIS)
	$type THIS = NO_INIT
    CODE:
	THIS = $name;
    OUTPUT:
	SETMAGIC: DISABLE
	THIS

void
_set_$name(THIS)
	$type THIS
    CODE:
	$name = THIS;

END
}

sub print_accessors {
  my($fh, $name, $struct) = @@_;
  return unless defined $struct && $name !~ /\s|_ANON/;
  $name = normalize_type($name);
  my $ptrname = normalize_type("$name *");
  print $fh <<"EOF";

MODULE = $module		PACKAGE = ${name}		$prefix

$name *
_to_ptr(THIS)
	$name THIS = NO_INIT
    PROTOTYPE: \$
    CODE:
	if (sv_derived_from(ST(0), "$name")) {
	    STRLEN len;
	    char *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(THIS))
		croak("Size \%d of packed data != expected \%d",
			len, sizeof(THIS));
	    RETVAL = ($name *)s;
	}   
	else
	    croak("THIS is not of type $name");
    OUTPUT:
	RETVAL

$name
new(CLASS)
	char *CLASS = NO_INIT
    PROTOTYPE: \$
    CODE:
	Zero((void*)&RETVAL, sizeof(RETVAL), char);
    OUTPUT:
	RETVAL

MODULE = $module		PACKAGE = ${name}Ptr		$prefix

EOF
  my @@items = @@$struct;
  while (@@items) {
    my $item = shift @@items;
    if ($item->[0] =~ /_ANON/) {
      if (defined $item->[2]) {
	push @@items, map [
	  @@$_[0, 1], "$item->[2]_$_->[2]", "$item->[2].$_->[2]",
	], @@{ $structs{$item->[0]} };
      } else {
	push @@items, @@{ $structs{$item->[0]} };
      }
    } else {
      my $type = normalize_type($item->[0]);
      my $ttype = $structs{$type} ? normalize_type("$type *") : $type;
      print $fh <<"EOF";
$ttype
$item->[2](THIS, __value = NO_INIT)
	$ptrname THIS
	$type __value
    PROTOTYPE: \$;\$
    CODE:
	if (items > 1)
	    THIS->$item->[-1] = __value;
	RETVAL = @@{[
	    $type eq $ttype ? "THIS->$item->[-1]" : "&(THIS->$item->[-1])"
	]};
    OUTPUT:
	RETVAL

EOF
    }
  }
}

d747 3
a749 5

  # Start with useful default values
  $typemap{float} = 'T_DOUBLE';

  foreach my $typemap (@@tm) {
d765 1
a765 2
	my ($type, $image);
	if ( ($type, $image) =
d769 1
a769 1
	  $typemap{normalize_type($type)} = $image;
d780 2
a781 1
sub normalize_type {		# Second arg: do not strip const's before \*
d783 3
a785 12
  my $do_keep_deep_const = shift;
  # If $do_keep_deep_const this is heuristical only
  my $keep_deep_const = ($do_keep_deep_const ? '\b(?![^(,)]*\*)' : '');
  my $ignore_mods 
    = "(?:\\b(?:(?:__const__|const)$keep_deep_const|static|inline|__inline__)\\b\\s*)*";
  if ($do_keep_deep_const) {	# Keep different compiled /RExen/o separately!
    $type =~ s/$ignore_mods//go;
  }
  else {
    $type =~ s/$ignore_mods//go;
  }
  $type =~ s/([^\s\w])/ \1 /g;
d788 3
a790 4
  $type =~ s/\s+/ /g;
  $type =~ s/\* (?=\*)/*/g;
  $type =~ s/\. \. \./.../g;
  $type =~ s/ ,/,/g;
a795 26
my $need_opaque;

sub assign_typemap_entry {
  my $type = shift;
  my $otype = $type;
  my $entry;
  if ($tmask and $type =~ /$tmask/) {
    print "Type $type matches -o mask\n" if $opt_d;
    $entry = (td_is_struct($type) ? "T_OPAQUE_STRUCT" : "T_PTROBJ");
  }
  elsif ($typedef_rex and $type =~ s/($typedef_rex)/$typedefs_pre{$1}/go) {
    $type = normalize_type $type;
    print "Type mutation via typedefs: $otype ==> $type\n" if $opt_d;
    $entry = assign_typemap_entry($type);
  }
  $entry ||= $typemap{$otype}
    || (td_is_struct($type) ? "T_OPAQUE_STRUCT" : "T_PTROBJ");
  $typemap{$otype} = $entry;
  $need_opaque = 1 if $entry eq "T_OPAQUE_STRUCT";
  return $entry;
}

for (@@vdecls) {
  print_tievar_xsubs(\*XS, $_, $vdecl_hash{$_});
}

d797 1
a797 6
  for my $decl (@@$fdecls_parsed) { print_decl(\*XS, $decl) }
  if ($opt_a) {
    while (my($name, $struct) = each %structs) {
      print_accessors(\*XS, $name, $struct);
    }
  }
d807 2
a808 3
  for $type (sort keys %types_seen) {
    my $entry = assign_typemap_entry $type;
    print TM $type, "\t" x (5 - int((length $type)/8)), "\t$entry\n"
a810 21
  print TM <<'EOP' if $need_opaque; # Older Perls do not have correct entry
#############################################################################
INPUT
T_OPAQUE_STRUCT
	if (sv_derived_from($arg, \"${ntype}\")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV($arg), len);

	    if (len != sizeof($var))
		croak(\"Size %d of packed data != expected %d\",
			len, sizeof($var));
	    $var = *($type *)s;
	}
	else
	    croak(\"$var is not of type ${ntype}\")
#############################################################################
OUTPUT
T_OPAQUE_STRUCT
	sv_setref_pvn($arg, \"${ntype}\", (char *)&$var, sizeof($var));
EOP

d819 1
a819 1
print PL <<END;
a822 11
WriteMakefile(
    'NAME'		=> '$module',
    'VERSION_FROM'	=> '$modfname.pm', # finds \$VERSION
    'PREREQ_PM'		=> {}, # e.g., Module::Name => 1.1
END
if (!$opt_X) { # print C stuff, unless XS is disabled
  $opt_F = '' unless defined $opt_F;
  print PL <<END;
    'LIBS'		=> ['$extralibs'], # e.g., '-lm'
    'DEFINE'		=> '$opt_F', # e.g., '-DHAVE_SOMETHING'
    'INC'		=> '', # e.g., '-I/usr/include/other'
d824 7
d865 6
a870 15
unless ($opt_C) {
  warn "Writing $ext$modpname/Changes\n";
  $" = ' ';
  open(EX, ">Changes") || die "Can't create $ext$modpname/Changes: $!\n";
  @@ARGS = map {/[\s\"\'\`\$*?^|&<>\[\]\{\}\(\)]/ ? "'$_'" : $_} @@ARGS;
  print EX <<EOP;
Revision history for Perl extension $module.

$TEMPLATE_VERSION  @@{[scalar localtime]}
\t- original version; created by h2xs $H2XS_VERSION with options
\t\t@@ARGS

EOP
  close(EX) || die "Can't close $ext$modpname/Changes: $!\n";
}
d874 1
a874 1
my @@files = <*>;
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d16 1
a16 1
my $origdir = cwd;
d18 1
a18 1
my $file = basename($0, '.PL');
d44 1
a44 1
B<h2xs> [B<-ACOPXacdfkmx>] [B<-F> addflags] [B<-M> fmask] [B<-n> module_name] [B<-o> tmask] [B<-p> prefix] [B<-s> subs] [B<-v> version] [headerfile ... [extra_libraries]]
d81 1
a81 1
=item B<-F> I<addflags>
a193 12
=item B<-b> I<version>

Generates a .pm file which is backwards compatible with the specified
perl version.

For versions < 5.6.0, the changes are.
    - no use of 'our' (uses 'use vars' instead)
    - no 'use warnings'

Specifying a compatibility version higher than the version of perl you
are using to run h2xs will have no effect.

a250 62
=head2 Extension based on F<.h> and F<.c> files

Suppose that you have some C files implementing some functionality,
and the corresponding header files.  How to create an extension which
makes this functionality accessable in Perl?  The example below
assumes that the header files are F<interface_simple.h> and
I<interface_hairy.h>, and you want the perl module be named as
C<Ext::Ension>.  If you need some preprocessor directives and/or
linking with external libraries, see the flags C<-F>, C<-L> and C<-l>
in L<"OPTIONS">.

=over

=item Find the directory name

Start with a dummy run of h2xs:

  h2xs -Afn Ext::Ension

The only purpose of this step is to create the needed directories, and
let you know the names of these directories.  From the output you can
see that the directory for the extension is F<Ext/Ension>.

=item Copy C files

Copy your header files and C files to this directory F<Ext/Ension>.

=item Create the extension

Run h2xs, overwriting older autogenerated files:

  h2xs -Oxan Ext::Ension interface_simple.h interface_hairy.h

h2xs looks for header files I<after> changing to the extension
directory, so it will find your header files OK.

=item Archive and test

As usual, run

  cd Ext/Ension
  perl Makefile.PL
  make dist
  make
  make test

=item Hints

It is important to do C<make dist> as early as possible.  This way you
can easily merge(1) your changes to autogenerated files if you decide
to edit your C<.h> files and rerun h2xs.

Do not forget to edit the documentation in the generated F<.pm> file.

Consider the autogenerated files as skeletons only, you may invent
better interfaces than what h2xs could guess.

Consider this section as a guideline only, some other options of h2xs
may better suit your needs.

=back

d332 1
a332 1
my( $H2XS_VERSION ) = ' $Revision: 1.21 $ ' =~ /\$Revision:\s+([^\s]+)/;
a334 1
my $compat_version = $];
d340 1
a340 1
    die "h2xs [-ACOPXacdfhkmx] [-F addflags] [-M fmask] [-n module_name] [-o tmask] [-p prefix] [-s subs] [-v version] [headerfile [extra_libraries]]
a361 1
    -b   Specify a perl version to be backwards compatibile with
d369 1
a369 1
getopts("ACF:M:OPXacdfhkmn:o:p:s:v:xb:") || usage;
d371 1
a371 2
	    $opt_f $opt_h $opt_k $opt_m $opt_n $opt_o $opt_p $opt_s $opt_v $opt_x 
	    $opt_b);
a374 9
if( $opt_b ){
    usage "You cannot use -b and -m at the same time.\n" if ($opt_b && $opt_m);
    $opt_b =~ /^\d+\.\d+\.\d+/ ||
	usage "You must provide the backwards compatibility version in X.Y.Z form. " .
	    "(i.e. 5.5.0)\n";
    my ($maj,$min,$sub) = split(/\./,$opt_b,3);
    $compat_version = sprintf("%d.%03d%02d",$maj,$min,$sub);
} 

a440 2
my $module = $opt_n;

a458 9
    $module ||= do {
      $name =~ s/\.h$//;
      if ( $name !~ /::/ ) {
	$name =~ s#^.*/##;
	$name = "\u$name";
      }
      $name;
    };

a466 6
    # Minor trickery: we can't chdir() before we processed the headers
    # (so know the name of the extension), but the header may be in the
    # extension directory...
    my $tmp_path_h = $path_h;
    my $rel_path_h = $path_h;
    my @@dirs = @@paths;
d468 1
a468 1
      my $found;
d470 1
a470 11
	$found++, last
	  if -f ($path_h = File::Spec->catfile($dir, $tmp_path_h));
      }
      if ($found) {
	$rel_path_h = $path_h;
      } else {
	(my $epath = $module) =~ s,::,/,g;
	$epath = File::Spec->catdir('ext', $epath) if -d 'ext';
	$rel_path_h = File::Spec->catfile($epath, $tmp_path_h);
	$path_h = $tmp_path_h;	# Used during -x
	push @@dirs, $epath;
d475 1
a475 2
      die "Can't find $tmp_path_h in @@dirs\n" 
	if ( ! $opt_f && ! -f "$rel_path_h" );
d479 1
a479 1
      open(CH, "<$rel_path_h") || die "Can't open $rel_path_h: $!\n";
d520 8
a687 1
if ( $compat_version < 5.006 ) {
d691 1
a691 9
use $compat_version;
use strict;
END
} 
else {
print PM <<"END";
package $module;

use 5.006;
a694 1
}
a723 8
if ( $compat_version < 5.006 ) {
    if ( $opt_X || $opt_c || $opt_A ) {
	print PM 'use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS);';
    } else {
	print PM 'use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS $AUTOLOAD);';
    }
}

a727 2
$myISA =~ s/^our // if $compat_version < 5.006;

d732 1
a732 1
my $tmp=<<"END";
a752 3
$tmp =~ s/^our //mg if $compat_version < 5.006;
print PM $tmp;

a756 2

$tmp = ( $compat_version < 5.006 ?  "" : "our \$AUTOLOAD;" );
d764 1
a764 1
    $tmp
d837 13
a849 13
#
#=head1 HISTORY
#
#=over 8
#
#=item $TEMPLATE_VERSION
#
#Original version; created by h2xs $H2XS_VERSION with options
#
#  @@ARGS
#
#=back
#
d853 5
a857 5
#
#=head2 EXPORT
#
#None by default.
#
a858 1

d861 4
a864 4
#=head2 Exportable constants
#
#  @@{[join "\n  ", @@const_names]}
#
a866 1

d869 2
a870 2
#=head2 Exportable functions
#
d872 2
d875 1
a875 4
#  $exp_doc .= <<EOD if $opt_p;
#When accessing these functions from Perl, prefix C<$opt_p> should be removed.
#
#EOD
d877 2
a878 2
#  @@{[join "\n  ", @@known_fnames{@@fnames}]}
#
a881 8
my $meth_doc = '';

if ($opt_x && $opt_a) {
  my($name, $struct);
  $meth_doc .= accessor_docs($name, $struct)
    while ($name, $struct) = each %structs;
}

d901 1
a901 1
$exp_doc$meth_doc$revhist
d904 1
a904 1
#$author, E<lt>${email}E<gt>
d908 1
a908 1
#L<perl>.
a1359 66
sub accessor_docs {
  my($name, $struct) = @@_;
  return unless defined $struct && $name !~ /\s|_ANON/;
  $name = normalize_type($name);
  my $ptrname = $name . 'Ptr';
  my @@items = @@$struct;
  my @@list;
  while (@@items) {
    my $item = shift @@items;
    if ($item->[0] =~ /_ANON/) {
      if (defined $item->[2]) {
	push @@items, map [
	  @@$_[0, 1], "$item->[2]_$_->[2]", "$item->[2].$_->[2]",
	], @@{ $structs{$item->[0]} };
      } else {
	push @@items, @@{ $structs{$item->[0]} };
      }
    } else {
      push @@list, $item->[2];
    }
  }
  my $methods = (join '(...)>, C<', @@list) . '(...)';

  my $pod = <<"EOF";
#
#=head2 Object and class methods for C<$name>/C<$ptrname>
#
#The principal Perl representation of a C object of type C<$name> is an
#object of class C<$ptrname> which is a reference to an integer
#representation of a C pointer.  To create such an object, one may use
#a combination
#
#  my \$buffer = $name->new();
#  my \$obj = \$buffer->_to_ptr();
#
#This exersizes the following two methods, and an additional class
#C<$name>, the internal representation of which is a reference to a
#packed string with the C structure.  Keep in mind that \$buffer should
#better survive longer than \$obj.
#
#=over
#
#=item C<\$object_of_type_$name-E<gt>_to_ptr()>
#
#Converts an object of type C<$name> to an object of type C<$ptrname>.
#
#=item C<$name-E<gt>new()>
#
#Creates an empty object of type C<$name>.  The corresponding packed
#string is zeroed out.
#
#=item C<$methods>
#
#return the current value of the corresponding element if called
#without additional arguments.  Set the element to the supplied value
#(and return the new value) if called with an additional argument.
#
#Applicable to objects of type C<$ptrname>.
#
#=back
#
EOF
  $pod =~ s/^\#//gm;
  return $pod;
}

a1511 3
    (\$] >= 5.005 ?    ## Add these new keywords supported since 5.005
      (ABSTRACT_FROM => '$modfname.pm', # retrieve abstract from module
       AUTHOR     => '$author <$email>') : ()),
a1514 6
  my $I = (((glob '*.h') || (glob '*.hh')) ? '-I.' : '');
  my $Ihelp = ($I ? '-I. ' : '');
  my $Icomment = ($I ? '' : <<EOC);
	# Insert -I. if you add *.h files later:
EOC

d1518 1
a1518 11
$Icomment    'INC'		=> '$I', # e.g., '$Ihelp-I/usr/include/other'
END

  my $C = grep $_ ne "$modfname.c", (glob '*.c'), (glob '*.cc'), (glob '*.C');
  my $Cpre = ($C ? '' : '# ');
  my $Ccomment = ($C ? '' : <<EOC);
	# Un-comment this if you add C files to link with later:
EOC

  print PL <<END;
$Ccomment    $Cpre\'OBJECT'		=> '\$(O_FILES)', # link all the C files too
a1523 46
# Create a simple README since this is a CPAN requirement
# and it doesnt hurt to have one
warn "Writing $ext$modpname/README\n";
open(RM, ">README") || die "Can't create $ext$modpname/README:$!\n";
my $thisyear = (gmtime)[5] + 1900;
my $rmhead = "$modpname version $TEMPLATE_VERSION";
my $rmheadeq = "=" x length($rmhead);
print RM <<_RMEND_;
$rmhead
$rmheadeq

The README is used to introduce the module and provide instructions on
how to install the module, any machine dependencies it may have (for
example C compilers and installed libraries) and any other information
that should be provided before the module is installed.

A README file is required for CPAN modules since CPAN extracts the
README file from a module distribution so that people browsing the
archive can use it get an idea of the modules uses. It is usually a
good idea to provide version information here so that people can
decide whether fixes for the module are worth downloading.

INSTALLATION

To install this module type the following:

   perl Makefile.PL
   make
   make test
   make install

DEPENDENCIES

This module requires these other modules and libraries:

  blah blah blah

COPYRIGHT AND LICENCE

Put the correct copyright and licence information here.

Copyright (C) $thisyear $author blah blah blah

_RMEND_
close(RM) || die "Can't close $ext$modpname/README: $!\n";

d1530 1
a1530 1
#########################
d1532 2
a1533 1
# change 'tests => 1' to 'tests => last_test_to_print';
d1535 2
a1536 2
use Test;
BEGIN { plan tests => 1 };
d1542 2
a1543 1
ok(1); # If we made it this far, we're ok.
d1545 1
a1545 1
#########################
d1547 3
a1549 2
# Insert your test code below, the Test module is use()ed here so read
# its man page ( perldoc Test ) for help writing this test script.
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a37 2
use warnings;

d44 1
a44 1
B<h2xs> [B<OPTIONS> ...] [headerfile ... [extra_libraries]]
d46 1
a46 1
B<h2xs> B<-h>|B<-?>|B<--help>
d60 6
a65 6
the libraries actually exist and how they should be loaded.  The extra
libraries should be specified in the form -lm -lposix, etc, just as on
the cc command line.  By default, the Makefile.PL will search through
the library path determined by Configure.  That path can be augmented
by including arguments of the form B<-L/another/library/path> in the
extra-libraries argument.
d71 1
a71 6
=item B<-A>, B<--omit-autoload>

Omit all autoload facilities.  This is the same as B<-c> but also
removes the S<C<use AutoLoader>> statement from the .pm file.

=item B<-B>, B<--beta-version>
d73 2
a74 2
Use an alpha/beta style version number.  Causes version number to
be "0.00_01" unless B<-v> is specified.
d76 1
a76 1
=item B<-C>, B<--omit-changes>
d81 1
a81 1
=item B<-F>, B<--cpp-flags>=I<addflags>
d84 1
a84 2
function declarations.  Writes these options in the generated F<Makefile.PL>
too.
d86 1
a86 1
=item B<-M>, B<--func-mask>=I<regular expression>
d90 1
a90 1
=item B<-O>, B<--overwrite-ok>
d94 1
a94 1
=item B<-P>, B<--omit-pod>
d98 1
a98 1
=item B<-X>, B<--omit-XS>
d103 1
a103 1
=item B<-a>, B<--gen-accessors>
d117 1
a117 14
=item B<-b>, B<--compat-version>=I<version>

Generates a .pm file which is backwards compatible with the specified
perl version.

For versions < 5.6.0, the changes are.
    - no use of 'our' (uses 'use vars' instead)
    - no 'use warnings'

Specifying a compatibility version higher than the version of perl you
are using to run h2xs will have no effect.  If unspecified h2xs will default
to compatibility with the version of perl you are using to run h2xs.

=item B<-c>, B<--omit-constant>
d122 1
a122 1
=item B<-d>, B<--debugging>
d126 1
a126 1
=item B<-f>, B<--force>
d131 1
a131 6
=item B<-g>, B<--global>

Include code for safely storing static data in the .xs file. 
Extensions that do no make use of static data can ignore this option.

=item B<-h>, B<-?>, B<--help>
d135 1
a135 1
=item B<-k>, B<--omit-const-func>
d140 1
a140 1
=item B<-m>, B<--gen-tied-var>
d145 1
a145 1
=item B<-n>, B<--name>=I<module_name>
d149 1
a149 1
=item B<-o>, B<--opaque-re>=I<regular expression>
d158 1
a158 2
Use C<-o .> if you want to handle all the C<typedef>ed types as opaque
types.
d164 1
a164 46
=item B<-p>, B<--remove-prefix>=I<prefix>

Specify a prefix which should be removed from the Perl function names,
e.g., S<-p sec_rgy_> This sets up the XS B<PREFIX> keyword and removes
the prefix from functions that are autoloaded via the C<constant()>
mechanism.

=item B<-s>, B<--const-subs>=I<sub1,sub2>

Create a perl subroutine for the specified macros rather than autoload
with the constant() subroutine.  These macros are assumed to have a
return type of B<char *>, e.g.,
S<-s sec_rgy_wildcard_name,sec_rgy_wildcard_sid>.

=item B<-t>, B<--default-type>=I<type>

Specify the internal type that the constant() mechanism uses for macros.
The default is IV (signed integer).  Currently all macros found during the
header scanning process will be assumed to have this type.  Future versions
of C<h2xs> may gain the ability to make educated guesses.

=item B<--use-new-tests>

When B<--compat-version> (B<-b>) is present the generated tests will use
C<Test::More> rather than C<Test> which is the default for versions before
5.7.2 .   C<Test::More> will be added to PREREQ_PM in the generated
C<Makefile.PL>.

=item B<--use-old-tests>

Will force the generation of test code that uses the older C<Test> module.

=item B<--skip-exporter>

Do not use C<Exporter> and/or export any symbol.

=item B<--skip-ppport>

Do not use C<Devel::PPPort>: no portability to older version.

=item B<--skip-autoloader>

Do not use the module C<AutoLoader>; but keep the constant() function
and C<sub AUTOLOAD> for constants.

=item B<--skip-strict>
d166 3
a168 1
Do not use the pragma C<strict>.
d170 1
a170 1
=item B<--skip-warnings>
d172 2
a173 1
Do not use the pragma C<warnings>.
d175 1
a175 1
=item B<-v>, B<--version>=I<version>
d178 1
a178 2
to the templates.  The default is 0.01, or 0.00_01 if C<-B> is specified.
The version specified should be numeric.
d180 1
a180 1
=item B<-x>, B<--autogen-xsubs>
d185 2
a186 3
C<NAME1,NAME2>. In this case NAME1 is used instead of the specified
string, but XSUBs are emitted only for the declarations included from
file NAME2.
d194 12
a402 1
# ' # Grr
d406 1
a406 1
my( $H2XS_VERSION ) = ' $Revision: 1.22 $ ' =~ /\$Revision:\s+([^\s]+)/;
d411 5
a415 12
use Getopt::Long;
use Config;
use Text::Wrap;
$Text::Wrap::huge = 'overflow';
$Text::Wrap::columns = 80;
use ExtUtils::Constant qw (WriteConstants WriteMakefileSnippet autoload);
use File::Compare;

sub usage {
    warn "@@_\n" if @@_;
    die <<EOFUSAGE;
h2xs [OPTIONS ... ] [headerfile [extra_libraries]]
d417 21
a437 40
OPTIONS:
    -A, --omit-autoload   Omit all autoloading facilities (implies -c).
    -B, --beta-version    Use beta \$VERSION of 0.00_01 (ignored if -v).
    -C, --omit-changes    Omit creating the Changes file, add HISTORY heading
                          to stub POD.
    -F, --cpp-flags       Additional flags for C preprocessor/compile.
    -M, --func-mask       Mask to select C functions/macros
                          (default is select all).
    -O, --overwrite-ok    Allow overwriting of a pre-existing extension directory.
    -P, --omit-pod        Omit the stub POD section.
    -X, --omit-XS         Omit the XS portion (implies both -c and -f).
    -a, --gen-accessors   Generate get/set accessors for struct and union members                           (used with -x).
    -b, --compat-version  Specify a perl version to be backwards compatibile with
    -c, --omit-constant   Omit the constant() function and specialised AUTOLOAD
                          from the XS file.
    -d, --debugging       Turn on debugging messages.
    -f, --force           Force creation of the extension even if the C header
                          does not exist.
    -g, --global          Include code for safely storing static data in the .xs file. 
    -h, -?, --help        Display this help message
    -k, --omit-const-func Omit 'const' attribute on function arguments
                          (used with -x).
    -m, --gen-tied-var    Generate tied variables for access to declared
                          variables.
    -n, --name            Specify a name to use for the extension (recommended).
    -o, --opaque-re       Regular expression for \"opaque\" types.
    -p, --remove-prefix   Specify a prefix which should be removed from the
                          Perl function names.
    -s, --const-subs      Create subroutines for specified macros.
    -t, --default-type    Default type for autoloaded constants (default is IV)
        --use-new-tests   Use Test::More in backward compatible modules
        --use-old-tests   Use the module Test rather than Test::More
        --skip-exporter   Do not export symbols
        --skip-ppport     Do not use portability layer
        --skip-autoloader Do not use the module C<AutoLoader>
        --skip-strict     Do not use the pragma C<strict>
        --skip-warnings   Do not use the pragma C<warnings>
    -v, --version         Specify a version number for this extension.
    -x, --autogen-xsubs   Autogenerate XSUBs using C::Scan.

d441 1
a441 1
EOFUSAGE
a443 68
my ($opt_A,
    $opt_B,
    $opt_C,
    $opt_F,
    $opt_M,
    $opt_O,
    $opt_P,
    $opt_X,
    $opt_a,
    $opt_c,
    $opt_d,
    $opt_f,
    $opt_g,
    $opt_h,
    $opt_k,
    $opt_m,
    $opt_n,
    $opt_o,
    $opt_p,
    $opt_s,
    $opt_v,
    $opt_x,
    $opt_b,
    $opt_t,
    $new_test,
    $old_test,
    $skip_exporter,
    $skip_ppport,
    $skip_autoloader,
    $skip_strict,
    $skip_warnings,
   );

Getopt::Long::Configure('bundling');

my %options = (
                'omit-autoload|A'    => \$opt_A,
                'beta-version|B'     => \$opt_B,
                'omit-changes|C'     => \$opt_C,
                'cpp-flags|F=s'      => \$opt_F,
                'func-mask|M=s'      => \$opt_M,
                'overwrite_ok|O'     => \$opt_O,
                'omit-pod|P'         => \$opt_P,
                'omit-XS|X'          => \$opt_X,
                'gen-accessors|a'    => \$opt_a,
                'compat-version|b=s' => \$opt_b,
                'omit-constant|c'    => \$opt_c,
                'debugging|d'        => \$opt_d,
                'force|f'            => \$opt_f,
                'global|g'           => \$opt_g,
                'help|h|?'           => \$opt_h,
                'omit-const-func|k'  => \$opt_k,
                'gen-tied-var|m'     => \$opt_m,
                'name|n=s'           => \$opt_n,
                'opaque-re|o=s'      => \$opt_o,
                'remove-prefix|p=s'  => \$opt_p,
                'const-subs|s=s'     => \$opt_s,
                'default-type|t=s'   => \$opt_t,
                'version|v=s'        => \$opt_v,
                'autogen-xsubs|x'    => \$opt_x,
                'use-new-tests'      => \$new_test,
                'use-old-tests'      => \$old_test,
                'skip-exporter'      => \$skip_exporter,
                'skip-ppport'        => \$skip_ppport,
                'skip-autoloader'    => \$skip_autoloader,
                'skip-warnings'      => \$skip_warnings,
                'skip-strict'        => \$skip_strict,
              );
d445 4
a448 1
GetOptions(%options) || usage;
d455 2
a456 2
    usage "You must provide the backwards compatibility version in X.Y.Z form. "
          .  "(i.e. 5.5.0)\n";
d458 2
a459 23
    if ($maj < 5 || ($maj == 5 && $min < 6)) {
        $compat_version =
	    $sub ? sprintf("%d.%03d%02d",$maj,$min,$sub) :
	           sprintf("%d.%03d",    $maj,$min);
    } else {
        $compat_version =
	    $sub ? sprintf("%d.%03d%03d",$maj,$min,$sub) :
		   sprintf("%d.%03d",    $maj,$min);
    }
} else {
    my ($maj,$min,$sub) = $compat_version =~ /(\d+)\.(\d\d\d)(\d*)/;
    $sub ||= 0;
    warn sprintf <<'EOF', $maj,$min,$sub;
Defaulting to backwards compatibility with perl %d.%d.%d
If you intend this module to be compatible with earlier perl versions, please
specify a minimum perl version with the -b option.

EOF
}

if( $opt_B ){
    $TEMPLATE_VERSION = '0.00_01';
}
a462 23

    # check if it is numeric
    my $temp_version = $TEMPLATE_VERSION;
    my $beta_version = $temp_version =~ s/(\d)_(\d\d)/$1$2/;
    my $notnum;
    {
        local $SIG{__WARN__} = sub { $notnum = 1 };
        use warnings 'numeric';
        $temp_version = 0+$temp_version;
    }

    if ($notnum) {
        my $module = $opt_n || 'Your::Module';
        warn <<"EOF";
You have specified a non-numeric version.  Unless you supply an
appropriate VERSION class method, users may not be able to specify a
minimum required version with C<use $module versionnum>.

EOF
    }
    else {
        $opt_B = $beta_version;
    }
d466 1
a466 1
$skip_autoloader = $opt_c = 1 if $opt_A;
a470 2
$opt_t ||= 'IV';

d472 1
a472 3

my $extralibs = '';

d519 2
a520 5
  warn <<EOD if $opt_o;
Option -o does not make sense without -x.
EOD
  warn <<EOD if $opt_F and $opt_X ;
Option -F does not make sense with -X.
d530 1
a532 1
    my $pre_sub_tri_graphs = 1;
a577 1
	$fullpath{$path_h} = $fullpath;
d596 1
a596 14
	if ($pre_sub_tri_graphs) {
	    # Preprocess all tri-graphs 
	    # including things stuck in quoted string constants.
	    s/\?\?=/#/g;                         # | ??=|  #|
	    s/\?\?\!/|/g;                        # | ??!|  ||
	    s/\?\?'/^/g;                         # | ??'|  ^|
	    s/\?\?\(/[/g;                        # | ??(|  [|
	    s/\?\?\)/]/g;                        # | ??)|  ]|
	    s/\?\?\-/~/g;                        # | ??-|  ~|
	    s/\?\?\//\\/g;                       # | ??/|  \|
	    s/\?\?</{/g;                         # | ??<|  {|
	    s/\?\?>/}/g;                         # | ??>|  }|
	}
	if (/^[ \t]*#[ \t]*define\s+([\$\w]+)\b(?!\()\s*(?=[^"\s])(.*)/) {
d633 1
a633 2
# Save current directory so that C::Scan can use it
my $cwd = File::Spec->rel2abs( File::Spec->curdir );
d636 1
a636 8
# As Ilya suggested, use a name that contains - and then it can't clash with
# the names of any packages. A directory 'fallback' will clash with any
# new pragmata down the fallback:: tree, but that seems unlikely.
my $constscfname = 'const-c.inc';
my $constsxsfname = 'const-xs.inc';
my $fallbackdirname = 'fallback';

$ext = chdir 'ext' ? 'ext/' : '';
d660 1
a660 1
		-d "$modpath$_" || mkdir("$modpath$_", 0777);
d664 1
a664 1
-d "$modpname"   || mkdir($modpname, 0777);
a681 6
  unless ($skip_ppport) {
    require Devel::PPPort;
    warn "Writing $ext$modpname/ppport.h\n";
    Devel::PPPort::WriteFile('ppport.h')
        || die "Can't create $ext$modpname/ppport.h: $!\n";
  }
d684 1
a699 1
      my @@styles = $Config{gccversion} ? qw(C++ C9X GNU) : qw(C++ C9X);
d701 2
a702 2
	'add_cppflags' => $addflags, 'c_styles' => \@@styles;
      $c->set('includeDirs' => ["$Config::Config{archlib}/CORE", $cwd]);
d761 1
a761 2
      = sort map { ++$prefix{$_} if s/^$opt_p(?!\d)//; $_ } @@fnames_no_prefix
         if defined $opt_p;
d794 1
d799 1
d801 4
d806 1
a806 1
print PM <<"END" unless $skip_strict;
d808 1
d810 1
a810 2

print PM "use warnings;\n" unless $skip_warnings or $compat_version < 5.006;
d820 1
a820 1
print PM <<'END' unless $skip_exporter;
d825 1
a825 2
my $use_Dyna = (not $opt_X and $compat_version < 5.006);
print PM <<"END" if $use_Dyna;  # use DynaLoader, unless XS was disabled
d831 1
a831 1
unless ($skip_autoloader) { # no autoloader whatsoever.
d841 5
a845 5
    my $vars = '$VERSION @@ISA';
    $vars .= ' @@EXPORT @@EXPORT_OK %EXPORT_TAGS' unless $skip_exporter;
    $vars .= ' $AUTOLOAD' unless $opt_X || $opt_c || $opt_A;
    $vars .= ' $XS_VERSION' if $opt_B && !$opt_X;
    print PM "use vars qw($vars);";
d849 3
a851 4
my @@modISA;
push @@modISA, 'Exporter'	unless $skip_exporter; 
push @@modISA, 'DynaLoader' 	if $use_Dyna;  # no XS
my $myISA = "our \@@ISA = qw(@@modISA);";
d858 1
a858 2
my $tmp='';
$tmp .= <<"END" unless $skip_exporter;
d875 1
a878 7
$tmp .= "our \$VERSION = '$TEMPLATE_VERSION';\n";
if ($opt_B) {
    $tmp .= "our \$XS_VERSION = \$VERSION;\n" unless $opt_X;
    $tmp .= "\$VERSION = eval \$VERSION;  # see L<perlmodstyle>\n";
}
$tmp .= "\n";

d887 35
a921 1
print PM autoload ($module, $compat_version) unless $opt_c or $opt_X;
d924 1
a924 2
  if ($use_Dyna) {
	$tmp = <<"END";
a926 8
  } else {
	$tmp = <<"END";
require XSLoader;
XSLoader::load('$module', \$VERSION);
END
  }
  $tmp =~ s:\$VERSION:\$XS_VERSION:g if $opt_B;
  print PM $tmp;
d963 2
a964 15
my ($email,$author);

eval {
       my $username;
       ($username,$author) = (getpwuid($>))[0,6];
       if (defined $username && defined $author) {
	   $author =~ s/,.*$//; # in case of sub fields
	   my $domain = $Config{'mydomain'};
	   $domain =~ s/^\.//;
	   $email = "$username\@@$domain";
       }
     };

$author ||= "A. U. Thor";
$email  ||= 'a.u.thor@@a.galaxy.far.far.away';
d983 1
a983 1
my $exp_doc = $skip_exporter ? '' : <<EOD;
d992 1
a992 1
  $exp_doc .= <<EOD unless $skip_exporter;
d1001 1
a1001 1
  $exp_doc .= <<EOD unless $skip_exporter;
d1010 1
a1010 1
  $exp_doc .= <<EOD unless $skip_exporter;
d1025 1
a1025 1
## Below is stub documentation for your module. You'd better edit it!
a1035 7
#=head1 ABSTRACT
#
#  This should be the abstract for $module.
#  The abstract is used when making PPD (Perl Package Description) files.
#  If you don't want an ABSTRACT you should also edit Makefile.PL to
#  remove the ABSTRACT_FROM option.
#
a1043 12
#
#=head1 SEE ALSO
#
#Mention other useful documentation such as the documentation of
#related modules or operating system documentation (such as man pages
#in UNIX), or any relevant external documentation such as RFCs or
#standards.
#
#If you have a mailing list set up for your module, mention it here.
#
#If you have a web site set up for your module, mention it here.
#
d1048 1
a1048 1
#=head1 COPYRIGHT AND LICENSE
d1050 1
a1050 4
#Copyright ${\(1900 + (localtime) [5])} by $author
#
#This library is free software; you can redistribute it and/or modify
#it under the same terms as Perl itself. 
a1069 6

print XS <<"END" unless $skip_ppport;
#include "ppport.h"

END

a1079 15
print XS <<"END" if $opt_g;

/* Global Data */

#define MY_CXT_KEY "${module}::_guts" XS_VERSION

typedef struct {
    /* Put Global Data in here */
    int dummy;		/* you can access this elsewhere as MY_CXT.dummy */
} my_cxt_t;

START_MY_CXT

END

d1117 45
a1161 1
print_tievar_subs(\*XS, $_, $vdecl_hash{$_}) for @@vdecls;
d1163 15
a1177 19
if( ! $opt_c ) {
  # We write the "sample" files used when this module is built by perl without
  # ExtUtils::Constant.
  # h2xs will later check that these are the same as those generated by the
  # code embedded into Makefile.PL
  unless (-d $fallbackdirname) {
    mkdir "$fallbackdirname" or die "Cannot mkdir $fallbackdirname: $!\n";
  }
  warn "Writing $ext$modpname/$fallbackdirname/$constscfname\n";
  warn "Writing $ext$modpname/$fallbackdirname/$constsxsfname\n";
  my $cfallback = File::Spec->catfile($fallbackdirname, $constscfname);
  my $xsfallback = File::Spec->catfile($fallbackdirname, $constsxsfname);
  WriteConstants ( C_FILE =>       $cfallback,
                   XS_FILE =>      $xsfallback,
                   DEFAULT_TYPE => $opt_t,
                   NAME =>         $module,
                   NAMES =>        \@@const_names,
                 );
  print XS "#include \"$constscfname\"\n";
d1179 19
d1199 2
d1202 5
a1206 1
my $prefix = defined $opt_p ? "PREFIX = $opt_p" : '';
d1208 3
a1210 2
# Now switch from C to XS by issuing the first MODULE declaration:
print XS <<"END";
d1212 6
a1217 1
MODULE = $module		PACKAGE = $module		$prefix
d1219 2
d1223 46
a1268 3
# If a constant() function was #included then output a corresponding
# XS declaration:
print XS "INCLUDE: $constsxsfname\n" unless $opt_c;
d1270 1
a1270 1
print XS <<"END" if $opt_g;
d1272 4
a1275 1
BOOT:
d1277 7
a1283 4
    MY_CXT_INIT;
    /* If any of the fields in the my_cxt_t struct need
       to be initialised, do it here.
     */
d1286 10
d1316 19
d1577 1
a1577 1
  $typemap{float} = 'T_NV';
d1624 1
a1624 1
  $type =~ s/([^\s\w])/ $1 /g;
a1650 2
  # XXX good do better if our UV happens to be long long
  return "T_NV" if $type =~ /^(unsigned\s+)?long\s+(long|double)\z/;
d1712 1
a1712 13
my $prereq_pm;

if ( $compat_version < 5.00702 and $new_test )
{
  $prereq_pm = q%'Test::More'  =>  0%;
}
else
{
  $prereq_pm = '';
}

print PL <<"END";
use $compat_version;
d1719 1
a1719 1
    'PREREQ_PM'		=> {$prereq_pm}, # e.g., Module::Name => 1.1
d1735 1
a1735 1
$Icomment    'INC'		=> '$I', # e.g., '${Ihelp}-I/usr/include/other'
d1738 1
a1738 2
  my $C = grep {$_ ne "$modfname.c"}
    (glob '*.c'), (glob '*.cc'), (glob '*.C');
d1747 1
a1747 1
} # ' # Grr
a1748 62
if (!$opt_c) {
  my $generate_code =
    WriteMakefileSnippet ( C_FILE =>       $constscfname,
                           XS_FILE =>      $constsxsfname,
                           DEFAULT_TYPE => $opt_t,
                           NAME =>         $module,
                           NAMES =>        \@@const_names,
                 );
  print PL <<"END";
if  (eval {require ExtUtils::Constant; 1}) {
  # If you edit these definitions to change the constants used by this module,
  # you will need to use the generated $constscfname and $constsxsfname
  # files to replace their "fallback" counterparts before distributing your
  # changes.
$generate_code
}
else {
  use File::Copy;
  use File::Spec;
  foreach my \$file ('$constscfname', '$constsxsfname') {
    my \$fallback = File::Spec->catfile('$fallbackdirname', \$file);
    copy (\$fallback, \$file) or die "Can't copy \$fallback to \$file: \$!";
  }
}
END

  eval $generate_code;
  if ($@@) {
    warn <<"EOM";
Attempting to test constant code in $ext$modpname/Makefile.PL:
$generate_code
__END__
gave unexpected error $@@
Please report the circumstances of this bug in h2xs version $H2XS_VERSION
using the perlbug script.
EOM
  } else {
    my $fail;

    foreach my $file ($constscfname, $constsxsfname) {
      my $fallback = File::Spec->catfile($fallbackdirname, $file);
      if (compare($file, $fallback)) {
        warn << "EOM";
Files "$ext$modpname/$fallbackdirname/$file" and "$ext$modpname/$file" differ.
EOM
        $fail++;
      }
    }
    if ($fail) {
      warn fill ('','', <<"EOM") . "\n";
It appears that the code in $ext$modpname/Makefile.PL does not autogenerate
the files $ext$modpname/$constscfname and $ext$modpname/$constsxsfname
correctly.

Please report the circumstances of this bug in h2xs version $H2XS_VERSION
using the perlbug script.
EOM
    } else {
      unlink $constscfname, $constsxsfname;
    }
  }
}
a1757 12

my $rm_prereq;

if ( $compat_version < 5.00702 and $new_test )
{
   $rm_prereq = 'Test::More';
}
else
{
   $rm_prereq = 'blah blah blah';
}

d1786 1
a1786 1
  $rm_prereq
d1792 1
a1792 4
Copyright (C) $thisyear $author

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 
d1797 3
a1799 11
my $testdir  = "t";
my $testfile = "$testdir/1.t";
unless (-d "$testdir") {
  mkdir "$testdir" or die "Cannot mkdir $testdir: $!\n";
}
warn "Writing $ext$modpname/$testfile\n";
my $tests = @@const_names ? 2 : 1;

open EX, ">$testfile" or die "Can't create $ext$modpname/$testfile: $!\n";

print EX <<_END_;
d1801 1
a1801 1
# `make test'. After `make install' it should work as `perl 1.t'
d1805 1
a1805 1
# change 'tests => $tests' to 'tests => last_test_to_print';
d1807 2
d1810 1
a1810 10

my $test_mod = 'Test::More';

if ( $old_test or ($compat_version < 5.007 and not $new_test ))
{
  my $test_mod = 'Test';

  print EX <<_END_;
use Test;
BEGIN { plan tests => $tests };
d1812 2
a1815 67
_END_

   if (@@const_names) {
     my $const_names = join " ", @@const_names;
     print EX <<'_END_';

my $fail;
foreach my $constname (qw(
_END_

     print EX wrap ("\t", "\t", $const_names);
     print EX (")) {\n");

     print EX <<_END_;
  next if (eval "my \\\$a = \$constname; 1");
  if (\$\@@ =~ /^Your vendor has not defined $module macro \$constname/) {
    print "# pass: \$\@@";
  } else {
    print "# fail: \$\@@";
    \$fail = 1;    
  }
}
if (\$fail) {
  print "not ok 2\\n";
} else {
  print "ok 2\\n";
}

_END_
  }
}
else
{
  print EX <<_END_;
use Test::More tests => $tests;
BEGIN { use_ok('$module') };

_END_

   if (@@const_names) {
     my $const_names = join " ", @@const_names;
     print EX <<'_END_';

my $fail = 0;
foreach my $constname (qw(
_END_

     print EX wrap ("\t", "\t", $const_names);
     print EX (")) {\n");

     print EX <<_END_;
  next if (eval "my \\\$a = \$constname; 1");
  if (\$\@@ =~ /^Your vendor has not defined $module macro \$constname/) {
    print "# pass: \$\@@";
  } else {
    print "# fail: \$\@@";
    \$fail = 1;
  }

}

ok( \$fail == 0 , 'Constants' );
_END_
  }
}

print EX <<_END_;
d1818 2
a1819 2
# Insert your test code below, the $test_mod module is use()ed here so read
# its man page ( perldoc $test_mod ) for help writing this test script.
d1822 1
a1822 2

close(EX) || die "Can't close $ext$modpname/$testfile: $!\n";
d1842 1
a1842 1
my @@files = grep { -f } (<*>, <t/*>, <$fallbackdirname/*>);
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@a146 18
=item B<-e>, B<--omit-enums>=[I<regular expression>]

If I<regular expression> is not given, skip all constants that are defined in
a C enumeration. Otherwise skip only those constants that are defined in an
enum whose name matches I<regular expression>.

Since I<regular expression> is optional, make sure that this switch is followed
by at least one other switch if you omit I<regular expression> and have some
pending arguments such as header-file names. This is ok:

    h2xs -e -n Module::Foo foo.h

This is not ok:

    h2xs -n Module::Foo -e foo.h

In the latter, foo.h is taken as I<regular expression>.

d270 5
a274 2
    # Default behavior, extension is Rusers
    h2xs rpcsvc/rusers
d276 2
a277 2
    # Same, but extension is RUSERS
    h2xs -n RUSERS rpcsvc/rusers
d279 2
a280 2
    # Extension is rpcsvc::rusers. Still finds <rpcsvc/rusers.h>
    h2xs rpcsvc::rusers
d282 2
a283 44
    # Extension is ONC::RPC.  Still finds <rpcsvc/rusers.h>
    h2xs -n ONC::RPC rpcsvc/rusers

    # Without constant() or AUTOLOAD
    h2xs -c rpcsvc/rusers

    # Creates templates for an extension named RPC
    h2xs -cfn RPC

    # Extension is ONC::RPC.
    h2xs -cfn ONC::RPC
    
    # Extension is Lib::Foo which works at least with Perl5.005_03.
    # Constants are created for all #defines and enums h2xs can find
    # in foo.h.
    h2xs -b 5.5.3 -n Lib::Foo foo.h

    # Extension is Lib::Foo which works at least with Perl5.005_03.
    # Constants are created for all #defines but only for enums
    # whose names do not start with 'bar_'.
    h2xs -b 5.5.3 -e '^bar_' -n Lib::Foo foo.h

    # Makefile.PL will look for library -lrpc in 
    # additional directory /opt/net/lib
    h2xs rpcsvc/rusers -L/opt/net/lib -lrpc

    # Extension is DCE::rgynbase
    # prefix "sec_rgy_" is dropped from perl function names
    h2xs -n DCE::rgynbase -p sec_rgy_ dce/rgynbase

    # Extension is DCE::rgynbase
    # prefix "sec_rgy_" is dropped from perl function names
    # subroutines are created for sec_rgy_wildcard_name and 
    # sec_rgy_wildcard_sid
    h2xs -n DCE::rgynbase -p sec_rgy_ \
    -s sec_rgy_wildcard_name,sec_rgy_wildcard_sid dce/rgynbase

    # Make XS without defines in perl.h, but with function declarations
    # visible from perl.h. Name of the extension is perl1.
    # When scanning perl.h, define -DEXT=extern -DdEXT= -DINIT(x)=
    # Extra backslashes below because the string is passed to shell.
    # Note that a directory with perl header files would 
    #  be added automatically to include path.
    h2xs -xAn perl1 -F "-DEXT=extern -DdEXT= -DINIT\(x\)=" perl.h
d285 2
a286 2
    # Same with function declaration in proto.h as visible from perl.h.
    h2xs -xAn perl2 perl.h,proto.h
d288 2
a289 2
    # Same but select only functions which match /^av_/
    h2xs -M '^av_' -xAn perl2 perl.h,proto.h
d291 30
a320 2
    # Same but treat SV* etc as "opaque" types
    h2xs -o '^[S]V \*$' -M '^av_' -xAn perl2 perl.h,proto.h
d466 1
a466 1
my( $H2XS_VERSION ) = ' $Revision: 1.23 $ ' =~ /\$Revision:\s+([^\s]+)/;
a477 1
use File::Path;
a499 3
    -e, --omit-enums      Omit constants from enums in the constant() function.
                          If a pattern is given, only the matching enums are 
                          ignored.
a540 1
    $opt_e,
a563 1
Getopt::Long::Configure('pass_through');
a577 1
                'omit-enums|e:s'     => \$opt_e,
d676 2
a677 2
        $extralibs .= "$arg ";
        next;
a678 1
    last if $extralibs;
d844 1
a844 28
      if (defined $opt_e and !$opt_e) {
        close(CH);
      }
      else {
	# Work from miniperl too - on "normal" systems
        my $SEEK_SET = eval 'use Fcntl qw/SEEK_SET/; SEEK_SET' or 0;
        seek CH, 0, $SEEK_SET;
        my $src = do { local $/; <CH> };
        close CH;
        no warnings 'uninitialized';
        
        # Remove C and C++ comments 
        $src =~ s#/\*[^*]*\*+([^/*][^*]*\*+)*/|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#$2#gs;
        
        while ($src =~ /(\benum\s*([\w_]*)\s*\{\s([\s\w=,]+)\})/gsc) {
            my ($enum_name, $enum_body) = 
                $1 =~ /enum\s*([\w_]*)\s*\{\s([\s\w=,]+)\}/gs;
            # skip enums matching $opt_e
            next if $opt_e && $enum_name =~ /$opt_e/;
            my $val = 0;
            for my $item (split /,/, $enum_body) {
                my ($key, $declared_val) = $item =~ /(\w*)\s*=\s*(.*)/;
                $val = length($declared_val) ? $declared_val : 1 + $val;
                $seen_define{$key} = $declared_val;
                $const_names{$key}++;
            }
        } # while (...)
      } # if (!defined $opt_e or $opt_e)
d852 1
d860 15
a874 8
my $ext = chdir 'ext' ? 'ext/' : '';
  
my @@modparts  = split(/::/,$module);
my $modpname  = join('-', @@modparts);
my $modfname  = pop @@modparts;
my $modpmdir  = join '/', 'lib', @@modparts;
my $modpmname = join '/', $modpmdir, $modfname.'.pm';
  
d881 8
a888 1
-d "$modpname"   || mkpath([$modpname], 0, 0775);
d1020 1
a1020 2
-d $modpmdir || mkpath([$modpmdir], 0, 0775);
open(PM, ">$modpmname") || die "Can't create $ext$modpname/$modpmname: $!\n";
d1023 1
a1023 1
warn "Writing $ext$modpname/$modpmname\n";
d1172 1
a1172 1
my ($email,$author,$licence);
a1187 8
$licence = sprintf << "DEFAULT", $^V;
Copyright (C) ${\(1900 + (localtime) [5])} by $author

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version %vd or,
at your option, any later version of Perl 5 you may have available.
DEFAULT

a1245 6
# Prefix the default licence with hash symbols.
# Is this just cargo cult - it seems that the first thing that happens to this
# block is that all the hashes are then s///g out.
my $licence_hash = $licence;
$licence_hash =~ s/^/#/gm;

d1258 7
d1291 4
a1294 1
$licence_hash
d1845 6
a1850 6
    NAME              => '$module',
    VERSION_FROM      => '$modpmname', # finds \$VERSION
    PREREQ_PM         => {$prereq_pm}, # e.g., Module::Name => 1.1
    (\$] >= 5.005 ?     ## Add these new keywords supported since 5.005
      (ABSTRACT_FROM  => '$modpmname', # retrieve abstract from module
       AUTHOR         => '$author <$email>') : ()),
d1861 3
a1863 3
    LIBS              => ['$extralibs'], # e.g., '-lm'
    DEFINE            => '$opt_F', # e.g., '-DHAVE_SOMETHING'
$Icomment    INC               => '$I', # e.g., '${Ihelp}-I/usr/include/other'
d1874 1
a1874 1
$Ccomment    ${Cpre}OBJECT            => '\$(O_FILES)', # link all the C files too
d1995 4
a1998 1
$licence
d2004 1
a2004 1
my $testfile = "$testdir/$modpname.t";
d2015 1
a2015 1
# `make test'. After `make install' it should work as `perl $modpname.t'
d2129 1
a2129 1
my @@files = grep { -f } (<*>, <t/*>, <$fallbackdirname/*>, <$modpmdir/*>);
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d104 1
a104 1
Omit the autogenerated stub POD section.
d172 1
a172 1
Include code for safely storing static data in the .xs file.
d308 1
a308 1

d319 1
a319 1
    # Makefile.PL will look for library -lrpc in
d329 1
a329 1
    # subroutines are created for sec_rgy_wildcard_name and
d338 1
a338 1
    # Note that a directory with perl header files would
d531 1
a531 1
                          If a pattern is given, only the matching enums are
d535 1
a535 1
    -g, --global          Include code for safely storing static data in the .xs file.
d828 1
a828 1
      die "Can't find $tmp_path_h in @@dirs\n"
d837 1
a837 1
	    # Preprocess all tri-graphs
d891 2
a892 2

        # Remove C and C++ comments
d894 1
a894 1

d896 1
a896 1
            my ($enum_name, $enum_body) =
d924 1
a924 1

d930 1
a930 1

d1056 1
a1056 1
	# print("found '$k'=>'$v'\n"),
d1126 1
a1126 1
push @@modISA, 'Exporter'	unless $skip_exporter;
d1618 1
a1618 1
	}
d1751 1
a1751 1
    warn("Warning: ignoring non-text typemap file '$typemap'\n"), next
d1753 1
a1753 1
    open(TYPEMAP, $typemap)
d1784 1
a1784 1
  my $ignore_mods
d1799 1
a1799 1
  $types_seen{$type}++
d2105 1
a2105 1
    \$fail = 1;
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d495 1
a495 1
my( $H2XS_VERSION ) = ' $Revision: 1.8 $ ' =~ /\$Revision:\s+([^\s]+)/;
d704 1
a704 2
my %const_xsub;
%const_xsub = map { $_,1 } split(/,+/, $opt_s) if $opt_s;
d902 1
a902 1
                my ($key, $declared_val) = $item =~ /(\w+)\s*=\s*(.*)/;
a982 2
      $c->get('keywords')->{'__restrict'} = 1;

d1310 1
a1310 2
my $pod;
$pod = <<"END" unless $opt_P;
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@d495 1
a495 1
my( $H2XS_VERSION ) = ' $Revision: 1.23 $ ' =~ /\$Revision:\s+([^\s]+)/;
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d355 1
a355 1
makes this functionality accessible in Perl?  The example below
d525 2
a526 3
    -a, --gen-accessors   Generate get/set accessors for struct and union members
                          (used with -x).
    -b, --compat-version  Specify a perl version to be backwards compatibile with.
d536 1
a536 1
    -h, -?, --help        Display this help message.
d546 8
a553 8
    -t, --default-type    Default type for autoloaded constants (default is IV).
        --use-new-tests   Use Test::More in backward compatible modules.
        --use-old-tests   Use the module Test rather than Test::More.
        --skip-exporter   Do not export symbols.
        --skip-ppport     Do not use portability layer.
        --skip-autoloader Do not use the module C<AutoLoader>.
        --skip-strict     Do not use the pragma C<strict>.
        --skip-warnings   Do not use the pragma C<warnings>.
a555 2
        --use-xsloader    Use XSLoader in backward compatible modules (ignored
                          when used with -X).
a594 1
    $use_xsloader
a632 1
                'use-xsloader'       => \$use_xsloader,
d896 3
a898 2
	while ($src =~ /\benum\s*([\w_]*)\s*\{\s([^}]+)\}/gsc) {
	    my ($enum_name, $enum_body) = ($1, $2);
d903 3
a905 3
                my ($key, $declared_val) = $item =~ /(\w+)\s*(?:=\s*(.*))?/;
                $val = defined($declared_val) && length($declared_val) ? $declared_val : 1 + $val;
                $seen_define{$key} = $val;
d1103 1
a1103 1
my $use_Dyna = (not $opt_X and $compat_version < 5.006 and not $use_xsloader);
a1237 1
$author =~ s/'/\\'/g if defined $author;
d1886 1
a1886 1
my $prereq_pm = '';
d1890 1
a1890 1
  $prereq_pm .= q%'Test::More'  =>  0, %;
d1892 1
a1892 2

if ( $compat_version < 5.00600 and !$opt_X and $use_xsloader)
d1894 1
a1894 1
  $prereq_pm .= q%'XSLoader'  =>  0, %;
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@a68 3
In spite of its name, I<h2xs> may also be used to create a skeleton pure
Perl module. See the B<-X> option.

d108 2
a109 2
Omit the XS portion. Used to generate a skeleton pure Perl module.
C<-c> and C<-f> are implicitly enabled.
a308 3
    # Extension is a pure Perl module with no XS code.
    h2xs -X My::Module

d646 1
a646 1
    $opt_b =~ /^v?(\d+)\.(\d+)\.(\d+)/ ||
d649 1
a649 1
    my ($maj,$min,$sub) = ($1,$2,$3);
d655 3
a657 1
        $compat_version = sprintf("%d.%03d%03d",$maj,$min,$sub);
a906 1
                next if $item =~ /\A\s*\Z/;
@


1.1.1.12
log
@import perl 5.10.1
@
text
@a903 1
        $src =~ s#//.*$##gm;
d915 1
a915 1
                $const_names{$key} = { name => $key, macro => 1 };
d1079 1
a1079 8
my (@@const_specs, @@const_names);

for (sort(keys(%const_names))) {
    my $v = $const_names{$_};
    
    push(@@const_specs, ref($v) ? $v : $_);
    push(@@const_names, $_);
}
d1468 1
a1468 1
                   NAMES =>        \@@const_specs,
d1953 1
a1953 1
                           NAMES =>        \@@const_specs,
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@d237 1
a237 1
5.6.2.  C<Test::More> will be added to PREREQ_PM in the generated
d1906 1
a1906 1
if ( $compat_version < 5.006002 and $new_test )
a1909 4
elsif ( $compat_version < 5.006002 )
{
  $prereq_pm .= q%'Test'        =>  0, %;
}
d1911 1
a1911 1
if ( $compat_version < 5.006 and !$opt_X and $use_xsloader)
d1913 1
a1913 1
  $prereq_pm .= q%'XSLoader'    =>  0, %;
d2029 1
a2029 5
if ( $compat_version < 5.006002 and $new_test )
{
  $rm_prereq = 'Test::More';
}
elsif ( $compat_version < 5.006002 )
d2031 1
a2031 1
  $rm_prereq = 'Test';
d2035 1
a2035 1
  $rm_prereq = 'blah blah blah';
a2094 3
use strict;
use warnings;

d2099 1
a2099 1
if ( $old_test or ($compat_version < 5.006002 and not $new_test ))
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d533 1
a533 1
    -b, --compat-version  Specify a perl version to be backwards compatible with.
d792 1
a792 1
		(split / +/, $Config{locincpth} // ""), '/usr/include');
d896 1
a896 1
        my $SEEK_SET = eval 'use Fcntl qw/SEEK_SET/; SEEK_SET' || 0;
d1727 1
a1727 1
#This exercises the following two methods, and an additional class
d1804 1
a1804 1
  # If $do_keep_deep_const this is heuristic only
d2024 1
a2024 1
# and it doesn't hurt to have one
d2096 2
a2097 2
# Before 'make install' is performed this script should be runnable with
# 'make test'. After 'make install' it should work as 'perl $modpname.t'
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a864 4
	    if ($rest eq '') {
	      print("Skip empty $def\n") if $opt_d;
	      next defines;
	    }
a1384 1
#define PERL_NO_GET_CONTEXT
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@d994 2
a995 2
      $c = C::Scan->new('filename' => $filename, 'filename_filter' => $filter,
        'add_cppflags' => $addflags, 'c_styles' => \@@styles);
d1920 1
a1920 1
if (!$opt_X and $use_xsloader)
d1932 1
a1932 1
    VERSION_FROM      => '$modpmname', # finds \$VERSION, requires EU::MM from perl >= 5.5
d1934 3
a1936 5
    ABSTRACT_FROM     => '$modpmname', # retrieve abstract from module
    AUTHOR            => '$author <$email>',
    #LICENSE           => 'perl',
    #Value must be from legacy list of licenses here
    #http://search.cpan.org/perldoc?Module%3A%3ABuild%3A%3AAPI
@


1.1.1.17
log
@Import perl-5.24.2
@
text
@a37 2
BEGIN { pop @@INC if $INC[-1] eq '.' }

@


