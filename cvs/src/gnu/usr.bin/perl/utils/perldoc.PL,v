head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.6
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.7.0.48
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.50
	OPENBSD_5_8_BASE:1.7
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.7.0.42
	OPENBSD_5_7_BASE:1.7
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.7.0.46
	OPENBSD_5_6_BASE:1.7
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.7.0.44
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.40
	OPENBSD_5_4_BASE:1.7
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.7.0.38
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.36
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.34
	OPENBSD_5_0:1.7.0.32
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.30
	OPENBSD_4_9_BASE:1.7
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.7.0.28
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.24
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.7.0.26
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.22
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.7.0.20
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.18
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.16
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.14
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.12
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.8
date	2016.07.25.10.53.04;	author afresh1;	state Exp;
branches;
next	1.7;
commitid	FHUgABTHZQuYQh2B;

1.7
date	2003.12.03.03.02.50;	author millert;	state Exp;
branches
	1.7.48.1
	1.7.50.1;
next	1.6;

1.6
date	2002.10.27.22.25.38;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.27;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.43;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.43;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.06.04;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.25;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.25;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.58;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.57;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.26.12;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.34;	author millert;	state Exp;
branches;
next	;

1.7.48.1
date	2016.08.05.01.01.40;	author afresh1;	state Exp;
branches;
next	;
commitid	HjAJx2yjL4A8HWon;

1.7.50.1
date	2016.08.05.01.00.56;	author afresh1;	state Exp;
branches;
next	;
commitid	wK3bUiy9jNch0Key;


desc
@@


1.8
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.


ok deraadt@@
@
text
@#!/usr/local/bin/perl

# This is for generating the perldoc executable.
# It may eventually be expanded to generate many executables, as
# explained in the preface of /Programming Perl/ 3e.

require 5;
use strict;
use Config;
use File::Basename qw(&basename &dirname);
use Cwd;

# List explicitly here the variables you want Configure to
# generate.  Metaconfig only looks for shell variables, so you
# have to mention them as if they were shell variables, not
# %Config entries.  Thus you write
#  $startperl
# to ensure Configure will look for $Config{startperl}.

# This forces PL files to create target in same directory as PL file.
# This is so that make depend always knows where to find PL derivatives.

my $origdir = cwd;
chdir dirname($0);
my $file = basename($0, '.PL');
my $file_shortname = $file;  # should be like "perldoc", maybe "perlsyn", etc.
warn "How odd, I'm going to generate $file_shortname?!"
 unless $file_shortname =~ m/^\w+$/;

$file .= '.com' if $^O eq 'VMS';

open OUT,">$file" or die "Can't create $file: $!";

print "Extracting \"$file\" (with variable substitutions)\n";

# In this section, perl variables will be expanded during extraction.
# You can use $Config{...} to use Configure variables.

print OUT <<"!GROK!THIS!";
$Config{startperl}
    eval 'exec $Config{perlpath} -S \$0 \${1+"\$@@"}'
	if 0;

# This "$file" file was generated by "$0"

require 5;
BEGIN {
    \$^W = 1 if \$ENV{'PERLDOCDEBUG'};
    pop \@@INC if \$INC[-1] eq '.';
}
use Pod::Perldoc;
exit( Pod::Perldoc->run() );

!GROK!THIS!


close OUT or die "Can't close $file: $!";
chmod 0755, $file or die "Can't reset permissions for $file: $!\n";
exec("$Config{'eunicefix'} $file") if $Config{'eunicefix'} ne ':';
chdir $origdir;

@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d47 4
a50 1
BEGIN { \$^W = 1 if \$ENV{'PERLDOCDEBUG'} }
@


1.7.48.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d47 1
a47 4
BEGIN {
    \$^W = 1 if \$ENV{'PERLDOCDEBUG'};
    pop \@@INC if \$INC[-1] eq '.';
}
@


1.7.50.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d47 1
a47 4
BEGIN {
    \$^W = 1 if \$ENV{'PERLDOCDEBUG'};
    pop \@@INC if \$INC[-1] eq '.';
}
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 6
d22 2
a23 1
$origdir = cwd;
d25 5
a29 1
$file = basename($0, '.PL');
d34 1
a34 1
print "Extracting $file (with variable substitutions)\n";
a38 2
my $versiononly = $Config{versiononly} ? $Config{version} : '';

d44 1
a44 5
use warnings;
use strict;

# make sure creat()s are neither too much nor too little
INIT { eval { umask(0077) } }   # doubtless someone has no mask
d46 4
a49 13
(my \$pager = <<'/../') =~ s/\\s*\\z//;
$Config{pager}
/../
my \@@pagers = ();
push \@@pagers, \$pager if -x \$pager;

(my \$bindir = <<'/../') =~ s/\\s*\\z//;
$Config{scriptdirexp}
/../

(my \$pod2man = <<'/../') =~ s/\\s*\\z//;
pod2man$versiononly
/../
a52 787
# In the following, perl variables are not expanded during extraction.

print OUT <<'!NO!SUBS!';

use Fcntl;    # for sysopen
use Getopt::Std;
use Config '%Config';
use File::Spec::Functions qw(catfile splitdir);

#
# Perldoc revision #1 -- look up a piece of documentation in .pod format that
# is embedded in the perl installation tree.
#
# This is not to be confused with Tom Christiansen's perlman, which is a
# man replacement, written in perl. This perldoc is strictly for reading
# the perl manuals, though it too is written in perl.
# 
# Massive security and correctness patches applied to this
# noisome program by Tom Christiansen Sat Mar 11 15:22:33 MST 2000 

if (@@ARGV<1) {
	my $me = $0;		# Editing $0 is unportable
	$me =~ s,.*/,,;
	die <<EOF;
Usage: $me [-h] [-r] [-i] [-v] [-t] [-u] [-m] [-n program] [-l] [-F] [-X] PageName|ModuleName|ProgramName
       $me -f PerlFunc
       $me -q FAQKeywords

The -h option prints more help.  Also try "perldoc perldoc" to get
acquainted with the system.
EOF
}

my @@global_found = ();
my $global_target = "";

my $Is_VMS = $^O eq 'VMS';
my $Is_MSWin32 = $^O eq 'MSWin32';
my $Is_Dos = $^O eq 'dos';
my $Is_OS2 = $^O eq 'os2';

sub usage{
    warn "@@_\n" if @@_;
    # Erase evidence of previous errors (if any), so exit status is simple.
    $! = 0;
    die <<EOF;
perldoc [options] PageName|ModuleName|ProgramName...
perldoc [options] -f BuiltinFunction
perldoc [options] -q FAQRegex

Options:
    -h   Display this help message
    -r   Recursive search (slow)
    -i   Ignore case
    -t   Display pod using pod2text instead of pod2man and nroff
             (-t is the default on win32)
    -u	 Display unformatted pod text
    -m   Display module's file in its entirety
    -n   Specify replacement for nroff
    -l   Display the module's file name
    -F   Arguments are file names, not modules
    -v	 Verbosely describe what's going on
    -X	 use index if present (looks for pod.idx at $Config{archlib})
    -q   Search the text of questions (not answers) in perlfaq[1-9]
    -U	 Run in insecure mode (superuser only)

PageName|ModuleName...
         is the name of a piece of documentation that you want to look at. You
         may either give a descriptive name of the page (as in the case of
         `perlfunc') the name of a module, either like `Term::Info' or like
         `Term/Info', or the name of a program, like `perldoc'.

BuiltinFunction
         is the name of a perl function.  Will extract documentation from
         `perlfunc'.

FAQRegex
         is a regex. Will search perlfaq[1-9] for and extract any
         questions that match.

Any switches in the PERLDOC environment variable will be used before the
command line arguments.  The optional pod index file contains a list of
filenames, one per line.

EOF
}

if (defined $ENV{"PERLDOC"}) {
    require Text::ParseWords;
    unshift(@@ARGV, Text::ParseWords::shellwords($ENV{"PERLDOC"}));
}
!NO!SUBS!

my $getopts = "mhtluvriFf:Xq:n:U";
print OUT <<"!GET!OPTS!";

use vars qw( @@{[map "\$opt_$_", ($getopts =~ /\w/g)]} );

getopts("$getopts") || usage;
!GET!OPTS!

print OUT <<'!NO!SUBS!';

usage if $opt_h;

# refuse to run if we should be tainting and aren't
# (but regular users deserve protection too, though!)
if (!($Is_VMS || $Is_MSWin32 || $Is_Dos || $Is_OS2) && ($> == 0 || $< == 0)
     && !am_taint_checking()) 
{{
    if ($opt_U) {
        my $id = eval { getpwnam("nobody") };
           $id = eval { getpwnam("nouser") } unless defined $id;
           $id = -2 unless defined $id;
	#
	# According to Stevens' APUE and various
	# (BSD, Solaris, HP-UX) man pages setting
	# the real uid first and effective uid second
	# is the way to go if one wants to drop privileges,
	# because if one changes into an effective uid of
	# non-zero, one cannot change the real uid any more.
	#
	# Actually, it gets even messier.  There is
	# a third uid, called the saved uid, and as
	# long as that is zero, one can get back to
	# uid of zero.  Setting the real-effective *twice*
	# helps in *most* systems (FreeBSD and Solaris)
	# but apparently in HP-UX even this doesn't help:
	# the saved uid stays zero (apparently the only way
	# in HP-UX to change saved uid is to call setuid()
	# when the effective uid is zero).
	#
        eval {
            $< = $id; # real uid
            $> = $id; # effective uid
            $< = $id; # real uid
            $> = $id; # effective uid
        };
        last if !$@@ && $< && $>;
    }
    die "Superuser must not run $0 without security audit and taint checks.\n";
}}

$opt_n = "nroff" if !$opt_n;

my $podidx;
if ($opt_X) {
    $podidx = "$Config{'archlib'}/pod.idx";
    $podidx = "" unless -f $podidx && -r _ && -M _ <= 7;
}

if ((my $opts = do{ no warnings; $opt_t + $opt_u + $opt_m + $opt_l }) > 1) {
    usage("only one of -t, -u, -m or -l")
}
elsif ($Is_MSWin32
       || $Is_Dos
       || !($ENV{TERM} && $ENV{TERM} !~ /dumb|emacs|none|unknown/i))
{
    $opt_t = 1 unless $opts;
}

if ($opt_t) { require Pod::Text; import Pod::Text; }

my @@pages;
if ($opt_f) {
    @@pages = ("perlfunc");
}
elsif ($opt_q) {
    @@pages = ("perlfaq1" .. "perlfaq9");
}
else {
    @@pages = @@ARGV;
}

# Does this look like a module or extension directory?
if (-f "Makefile.PL") {

    # Add ., lib to @@INC (if they exist)
    eval q{ use lib qw(. lib); 1; } or die;

    # don't add if superuser
    if ($< && $> && -f "blib") {   # don't be looking too hard now!
	eval q{ use blib; 1 };
	warn $@@ if $@@ && $opt_v;
    }
}

sub containspod {
    my($file, $readit) = @@_;
    return 1 if !$readit && $file =~ /\.pod\z/i;
    local($_);
    open(TEST,"<", $file) 	or die "Can't open $file: $!";
    while (<TEST>) {
	if (/^=head/) {
	    close(TEST) 	or die "Can't close $file: $!";
	    return 1;
	}
    }
    close(TEST) 		or die "Can't close $file: $!";
    return 0;
}

sub minus_f_nocase {
     my($dir,$file) = @@_;
     my $path = catfile($dir,$file);
     return $path if -f $path and -r _;
     if (!$opt_i or $Is_VMS or $Is_MSWin32 or $Is_Dos or $^O eq 'os2') {
        # on a case-forgiving file system or if case is important
	# that is it all we can do
	warn "Ignored $path: unreadable\n" if -f _;
	return '';
     }
     local *DIR;
     # this is completely wicked.  don't mess with $", and if 
     # you do, don't assume / is the dirsep!
     local($")="/";
     my @@p = ($dir);
     my($p,$cip);
     foreach $p (splitdir $file){
	my $try = catfile @@p, $p;
	stat $try;
 	if (-d _) {
 	    push @@p, $p;
	    if ( $p eq $global_target) {
		my $tmp_path = catfile @@p;
		my $path_f = 0;
		for (@@global_found) {
		    $path_f = 1 if $_ eq $tmp_path;
		}
		push (@@global_found, $tmp_path) unless $path_f;
		print STDERR "Found as @@p but directory\n" if $opt_v;
	    }
 	}
	elsif (-f _ && -r _) {
 	    return $try;
 	}
	elsif (-f _) {
	    warn "Ignored $try: unreadable\n";
 	}
	elsif (-d "@@p") {
 	    my $found=0;
 	    my $lcp = lc $p;
 	    opendir DIR, "@@p" 	    or die "opendir @@p: $!";
 	    while ($cip=readdir(DIR)) {
 		if (lc $cip eq $lcp){
 		    $found++;
 		    last;
 		}
 	    }
 	    closedir DIR	    or die "closedir @@p: $!";
 	    return "" unless $found;
 	    push @@p, $cip;
 	    return "@@p" if -f "@@p" and -r _;
	    warn "Ignored @@p: unreadable\n" if -f _;
 	}
     }
     return "";
}


sub check_file {
    my($dir,$file) = @@_;
    return "" if length $dir and not -d $dir;
    if ($opt_m) {
	return minus_f_nocase($dir,$file);
    }
    else {
	my $path = minus_f_nocase($dir,$file);
        return $path if length $path and containspod($path);
    }
    return "";
}


sub searchfor {
    my($recurse,$s,@@dirs) = @@_;
    $s =~ s!::!/!g;
    $s = VMS::Filespec::unixify($s) if $Is_VMS;
    return $s if -f $s && containspod($s);
    printf STDERR "Looking for $s in @@dirs\n" if $opt_v;
    my $ret;
    my $i;
    my $dir;
    $global_target = (splitdir $s)[-1];   # XXX: why not use File::Basename?
    for ($i=0; $i<@@dirs; $i++) {
	$dir = $dirs[$i];
	($dir = VMS::Filespec::unixpath($dir)) =~ s!/\z!! if $Is_VMS;
	if (       (! $opt_m && ( $ret = check_file $dir,"$s.pod"))
		or ( $ret = check_file $dir,"$s.pm")
		or ( $ret = check_file $dir,$s)
		or ( $Is_VMS and
		     $ret = check_file $dir,"$s.com")
		or ( $^O eq 'os2' and
		     $ret = check_file $dir,"$s.cmd")
		or ( ($Is_MSWin32 or $Is_Dos or $^O eq 'os2') and
		     $ret = check_file $dir,"$s.bat")
		or ( $ret = check_file "$dir/pod","$s.pod")
		or ( $ret = check_file "$dir/pod",$s)
		or ( $ret = check_file "$dir/pods","$s.pod")
		or ( $ret = check_file "$dir/pods",$s)
	) {
	    return $ret;
	}

	if ($recurse) {
	    opendir(D,$dir)	or die "Can't opendir $dir: $!";
	    my @@newdirs = map catfile($dir, $_), grep {
		not /^\.\.?\z/s and
		not /^auto\z/s  and   # save time! don't search auto dirs
		-d  catfile($dir, $_)
	    } readdir D;
	    closedir(D)		or die "Can't closedir $dir: $!";
	    next unless @@newdirs;
	    # what a wicked map!
	    @@newdirs = map((s/\.dir\z//,$_)[1],@@newdirs) if $Is_VMS;
	    print STDERR "Also looking in @@newdirs\n" if $opt_v;
	    push(@@dirs,@@newdirs);
	}
    }
    return ();
}

sub filter_nroff {
  my @@data = split /\n{2,}/, shift;
  shift @@data while @@data and $data[0] !~ /\S/; # Go to header
  shift @@data if @@data and $data[0] =~ /Contributed\s+Perl/; # Skip header
  pop @@data if @@data and $data[-1] =~ /^\w/; # Skip footer, like
				# 28/Jan/99 perl 5.005, patch 53 1
  join "\n\n", @@data;
}

sub page {
    my ($tmp, $no_tty, @@pagers) = @@_;
    if ($no_tty) {
	open(TMP,"<", $tmp) 	or die "Can't open $tmp: $!";
	local $_;
	while (<TMP>) {
	    print or die "Can't print to stdout: $!";
	} 
	close TMP		or die "Can't close while $tmp: $!";
    }
    else {
        # On VMS, quoting prevents logical expansion, and temp files with no
        # extension get the wrong default extension (such as .LIS for TYPE)

        $tmp = VMS::Filespec::rmsexpand($tmp, '.') if ($Is_VMS);
        foreach my $pager (@@pagers) {
          if ($Is_VMS) {
            last if system("$pager $tmp") == 0;
          } else {
	    last if system("$pager \"$tmp\"") == 0;
          }
	}
    }
}

my @@found;
foreach (@@pages) {
    if ($podidx && open(PODIDX, $podidx)) {
	my $searchfor = catfile split '::';
	print STDERR "Searching for '$searchfor' in $podidx\n" if $opt_v;
	local $_;
	while (<PODIDX>) {
	    chomp;
	    push(@@found, $_) if m,/$searchfor(?:\.(?:pod|pm))?\z,i;
	}
	close(PODIDX)	    or die "Can't close $podidx: $!";
	next;
    }
    print STDERR "Searching for $_\n" if $opt_v;
    if ($opt_F) {
	next unless -r;
	push @@found, $_ if $opt_m or containspod($_);
	next;
    }
    # We must look both in @@INC for library modules and in $bindir
    # for executables, like h2xs or perldoc itself.
    my @@searchdirs = ($bindir, @@INC);
    unless ($opt_m) {
	if ($Is_VMS) {
	    my($i,$trn);
	    for ($i = 0; $trn = $ENV{'DCL$PATH;'.$i}; $i++) {
		push(@@searchdirs,$trn);
	    }
	    push(@@searchdirs,'perl_root:[lib.pod]')  # installed pods
	}
	else {
	    push(@@searchdirs, grep(-d, split($Config{path_sep},
					     $ENV{'PATH'})));
	}
    }
    my @@files = searchfor(0,$_,@@searchdirs);
    if (@@files) {
	print STDERR "Found as @@files\n" if $opt_v;
    }
    else {
	# no match, try recursive search
	@@searchdirs = grep(!/^\.\z/s,@@INC);
	@@files= searchfor(1,$_,@@searchdirs) if $opt_r;
	if (@@files) {
	    print STDERR "Loosely found as @@files\n" if $opt_v;
	}
	else {
	    print STDERR "No " .
		($opt_m ? "module" : "documentation") . " found for \"$_\".\n";
	    if (@@global_found) {
		print STDERR "However, try\n";
		for my $dir (@@global_found) {
		    opendir(DIR, $dir) or die "opendir $dir: $!";
		    while (my $file = readdir(DIR)) {
			next if ($file =~ /^\./s);
			$file =~ s/\.(pm|pod)\z//;  # XXX: badfs
			print STDERR "\tperldoc $_\::$file\n";
		    }
		    closedir DIR    or die "closedir $dir: $!";
		}
	    }
	}
    }
    push(@@found,@@files);
}

if (!@@found) {
    exit ($Is_VMS ? 98962 : 1);
}

if ($opt_l) {
    print join("\n", @@found), "\n";
    exit;
}

my $lines = $ENV{LINES} || 24;

my $no_tty;
if (! -t STDOUT) { $no_tty = 1 }
END { close(STDOUT) || die "Can't close STDOUT: $!" }

if ($Is_MSWin32) {
    push @@pagers, qw( more< less notepad );
    unshift @@pagers, $ENV{PAGER}  if $ENV{PAGER};
    for (@@found) { s,/,\\,g }
}
elsif ($Is_VMS) {
    push @@pagers, qw( most more less type/page );
}
elsif ($Is_Dos) {
    push @@pagers, qw( less.exe more.com< );
    unshift @@pagers, $ENV{PAGER}  if $ENV{PAGER};
}
else {
    if ($^O eq 'os2') {
      unshift @@pagers, 'less', 'cmd /c more <';
    }
    push @@pagers, qw( more less pg view cat );
    unshift @@pagers, $ENV{PAGER}  if $ENV{PAGER};
}
unshift @@pagers, $ENV{PERLDOC_PAGER} if $ENV{PERLDOC_PAGER};

if ($opt_m) {
    foreach my $pager (@@pagers) {
	if (system($pager, @@found) == 0) {
	    exit;
    }
    }
    if ($Is_VMS) { 
	eval q{
	    use vmsish qw(status exit); 
	    exit $?;
	    1;
	} or die;
    }
    exit(1);
}

my @@pod;
if ($opt_f) {
    my $perlfunc = shift @@found;
    open(PFUNC, "<", $perlfunc)
	or die("Can't open $perlfunc: $!");

    # Functions like -r, -e, etc. are listed under `-X'.
    my $search_string = ($opt_f =~ /^-[rwxoRWXOeszfdlpSbctugkTBMAC]$/)
			? 'I<-X' : $opt_f ;

    # Skip introduction
    local $_;
    while (<PFUNC>) {
	last if /^=head2 Alphabetical Listing of Perl Functions/;
    }

    # Look for our function
    my $found = 0;
    my $inlist = 0;
    while (<PFUNC>) {
	if (/^=item\s+\Q$search_string\E\b/o)  {
	    $found = 1;
	}
	elsif (/^=item/) {
	    last if $found > 1 and not $inlist;
	}
	next unless $found;
	if (/^=over/) {
	    ++$inlist;
	}
	elsif (/^=back/) {
	    --$inlist;
	}
	push @@pod, $_;
	++$found if /^\w/;	# found descriptive text
    }
    if (!@@pod) {
	die "No documentation for perl function `$opt_f' found\n";
    }
    close PFUNC		or die "Can't open $perlfunc: $!";
}

if ($opt_q) {
    local @@ARGV = @@found;	# I'm lazy, sue me.
    my $found = 0;
    my %found_in;
    my $rx = eval { qr/$opt_q/ } or die <<EOD;
Invalid regular expression '$opt_q' given as -q pattern:
  $@@
Did you mean \\Q$opt_q ?

EOD

    for (@@found) { die "invalid file spec: $!" if /[<>|]/ } 
    local $_;
    while (<>) {
	if (/^=head2\s+.*(?:$opt_q)/oi) {
	    $found = 1;
	    push @@pod, "=head1 Found in $ARGV\n\n" unless $found_in{$ARGV}++;
	}
	elsif (/^=head[12]/) {
	    $found = 0;
	}
	next unless $found;
	push @@pod, $_;
    }
    if (!@@pod) {
	die("No documentation for perl FAQ keyword `$opt_q' found\n");
    }
}

require File::Temp;

my ($tmpfd, $tmp) = File::Temp::tempfile(UNLINK => 1);

my $filter;

if (@@pod) {
    my ($buffd, $buffer) = File::Temp::tempfile(UNLINK => 1);
    print $buffd "=over 8\n\n";
    print $buffd @@pod	or die "Can't print $buffer: $!";
    print $buffd "=back\n";
    close $buffd	or die "Can't close $buffer: $!";
    @@found = $buffer;
    $filter = 1;
}

foreach (@@found) {
    my $file = $_;
    my $err;

    if ($opt_t) {
	Pod::Text->new()->parse_from_file($file, $tmpfd);
    }
    elsif (not $opt_u) {
	my $cmd = catfile($bindir, $pod2man) . " --lax $file | $opt_n -man";
	$cmd .= " | col -x" if $^O =~ /hpux/;
	my $rslt = `$cmd`;
	$rslt = filter_nroff($rslt) if $filter;
	unless (($err = $?)) {
	    print $tmpfd $rslt
		or die "Can't print $tmp: $!";
	}
    }
    if ($opt_u or $err) {
	open(IN,"<", $file)   or die("Can't open $file: $!");
	my $cut = 1;
	local $_;
	while (<IN>) {
	    $cut = $1 eq 'cut' if /^=(\w+)/;
	    next if $cut;
	    print $tmpfd $_
		or die "Can't print $tmp: $!";
	}
	close IN    or die "Can't close $file: $!";
    }
}
close $tmpfd
    or die "Can't close $tmp: $!";
page($tmp, $no_tty, @@pagers);

exit;

sub is_tainted {
    my $arg = shift;
    my $nada = substr($arg, 0, 0);  # zero-length
    local $@@;  # preserve caller's version
    eval { eval "# $nada" };
    return length($@@) != 0;
}

sub am_taint_checking {
    my($k,$v) = each %ENV;
    return is_tainted($v);  
}


__END__

=head1 NAME

perldoc - Look up Perl documentation in pod format.

=head1 SYNOPSIS

B<perldoc> [B<-h>] [B<-v>] [B<-t>] [B<-u>] [B<-m>] [B<-l>] [B<-F>]  [B<-X>] PageName|ModuleName|ProgramName

B<perldoc> B<-f> BuiltinFunction

B<perldoc> B<-q> FAQ Keyword

=head1 DESCRIPTION

I<perldoc> looks up a piece of documentation in .pod format that is embedded
in the perl installation tree or in a perl script, and displays it via
C<pod2man | nroff -man | $PAGER>. (In addition, if running under HP-UX,
C<col -x> will be used.) This is primarily used for the documentation for
the perl library modules.

Your system may also have man pages installed for those modules, in
which case you can probably just use the man(1) command.

If you are looking for a table of contents to the Perl library modules
documentation, see the L<perltoc> page.

=head1 OPTIONS

=over 5

=item B<-h> help

Prints out a brief help message.

=item B<-v> verbose

Describes search for the item in detail.

=item B<-t> text output

Display docs using plain text converter, instead of nroff. This may be faster,
but it won't look as nice.

=item B<-u> unformatted

Find docs only; skip reformatting by pod2*

=item B<-m> module

Display the entire module: both code and unformatted pod documentation.
This may be useful if the docs don't explain a function in the detail
you need, and you'd like to inspect the code directly; perldoc will find
the file for you and simply hand it off for display.

=item B<-l> file name only

Display the file name of the module found.

=item B<-F> file names

Consider arguments as file names, no search in directories will be performed.

=item B<-f> perlfunc

The B<-f> option followed by the name of a perl built in function will
extract the documentation of this function from L<perlfunc>.

=item B<-q> perlfaq

The B<-q> option takes a regular expression as an argument.  It will search
the question headings in perlfaq[1-9] and print the entries matching
the regular expression.

=item B<-X> use an index if present

The B<-X> option looks for an entry whose basename matches the name given on the
command line in the file C<$Config{archlib}/pod.idx>.  The pod.idx file should
contain fully qualified filenames, one per line.

=item B<-U> run insecurely

Because B<perldoc> does not run properly tainted, and is known to
have security issues, it will not normally execute as the superuser.
If you use the B<-U> flag, it will do so, but only after setting
the effective and real IDs to nobody's or nouser's account, or -2
if unavailable.  If it cannot relinquish its privileges, it will not
run.  

=item B<PageName|ModuleName|ProgramName>

The item you want to look up.  Nested modules (such as C<File::Basename>)
are specified either as C<File::Basename> or C<File/Basename>.  You may also
give a descriptive name of a page, such as C<perlfunc>.

=back

=head1 ENVIRONMENT

Any switches in the C<PERLDOC> environment variable will be used before the
command line arguments.  C<perldoc> also searches directories
specified by the C<PERL5LIB> (or C<PERLLIB> if C<PERL5LIB> is not
defined) and C<PATH> environment variables.
(The latter is so that embedded pods for executables, such as
C<perldoc> itself, are available.)  C<perldoc> will use, in order of
preference, the pager defined in C<PERLDOC_PAGER>, C<MANPAGER>, or
C<PAGER> before trying to find a pager on its own.  (C<MANPAGER> is not
used if C<perldoc> was told to display plain text or unformatted pod.)

One useful value for C<PERLDOC_PAGER> is C<less -+C -E>.

=head1 VERSION

This is perldoc v2.03.

=head1 AUTHOR

Kenneth Albanowski <kjahds@@kjahds.com>

Minor updates by Andy Dougherty <doughera@@lafcol.lafayette.edu>,
and others.

=cut

#
# Version 2.03: Sun Apr 23 16:56:34 BST 2000
#	Hugo van der Sanden <hv@@crypt0.demon.co.uk>
#	don't die when 'use blib' fails
# Version 2.02: Mon Mar 13 18:03:04 MST 2000
#       Tom Christiansen <tchrist@@perl.com>
#	Added -U insecurity option
# Version 2.01: Sat Mar 11 15:22:33 MST 2000 
#       Tom Christiansen <tchrist@@perl.com>, querulously.
#       Security and correctness patches.
#       What a twisted bit of distasteful spaghetti code.
# Version 2.0: ????
# Version 1.15: Tue Aug 24 01:50:20 EST 1999
#       Charles Wilson <cwilson@@ece.gatech.edu>
#	changed /pod/ directory to /pods/ for cygwin
#         to support cygwin/win32
# Version 1.14: Wed Jul 15 01:50:20 EST 1998
#       Robin Barker <rmb1@@cise.npl.co.uk>
#	-strict, -w cleanups
# Version 1.13: Fri Feb 27 16:20:50 EST 1997
#       Gurusamy Sarathy <gsar@@activestate.com>
#	-doc tweaks for -F and -X options
# Version 1.12: Sat Apr 12 22:41:09 EST 1997
#       Gurusamy Sarathy <gsar@@activestate.com>
#	-various fixes for win32
# Version 1.11: Tue Dec 26 09:54:33 EST 1995
#       Kenneth Albanowski <kjahds@@kjahds.com>
#   -added Charles Bailey's further VMS patches, and -u switch
#   -added -t switch, with pod2text support
#
# Version 1.10: Thu Nov  9 07:23:47 EST 1995
#		Kenneth Albanowski <kjahds@@kjahds.com>
#	-added VMS support
#	-added better error recognition (on no found pages, just exit. On
#	 missing nroff/pod2man, just display raw pod.)
#	-added recursive/case-insensitive matching (thanks, Andreas). This
#	 slows things down a bit, unfortunately. Give a precise name, and
#	 it'll run faster.
#
# Version 1.01:	Tue May 30 14:47:34 EDT 1995
#		Andy Dougherty  <doughera@@lafcol.lafayette.edu>
#   -added pod documentation.
#   -added PATH searching.
#   -added searching pod/ subdirectory (mainly to pick up perlfunc.pod
#    and friends.
#
#
# TODO:
#
#	Cache directories read during sloppy match
!NO!SUBS!
d58 1
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d28 2
d48 5
a52 1
$Config{scriptdir}
d126 2
a127 3
         `perlfunc') the name of a module, either like `Term::Info',
         `Term/Info', the partial name of a module, like `info', or
         `makemaker', or the name of a program, like `perldoc'.
d171 18
d190 4
a193 2
            $> = $id;  # must do this one first!
            $< = $id;
d344 1
a344 1
	if (       ( $ret = check_file $dir,"$s.pod")
a387 44
sub printout {
    my ($file, $tmp, $filter) = @@_;
    my $err;

    if ($opt_t) {
	# why was this append?
	sysopen(OUT, $tmp, O_WRONLY | O_EXCL | O_CREAT, 0600)
	    or die ("Can't open $tmp: $!");
	Pod::Text->new()->parse_from_file($file,\*OUT);
	close OUT   or die "can't close $tmp: $!";
    }
    elsif (not $opt_u) {
	my $cmd = catfile($bindir, 'pod2man') . " --lax $file | $opt_n -man";
	$cmd .= " | col -x" if $^O =~ /hpux/;
	my $rslt = `$cmd`;
	$rslt = filter_nroff($rslt) if $filter;
	unless (($err = $?)) {
	    # why was this append?
	    sysopen(TMP, $tmp, O_WRONLY | O_EXCL | O_CREAT, 0600)
		or die "Can't open $tmp: $!";
	    print TMP $rslt
		or die "Can't print $tmp: $!";
	    close TMP
		or die "Can't close $tmp: $!";
	}
    }
    if ($opt_u or $err or -z $tmp) {  # XXX: race with -z
	# why was this append?
	sysopen(OUT, $tmp, O_WRONLY | O_EXCL | O_CREAT, 0600)
	    or die "Can't open $tmp: $!";
	open(IN,"<", $file)   or die("Can't open $file: $!");
	my $cut = 1;
	local $_;
	while (<IN>) {
	    $cut = $1 eq 'cut' if /^=(\w+)/;
	    next if $cut;
	    print OUT
		or die "Can't print $tmp: $!";
	}
	close IN    or die "Can't close $file: $!";
	close OUT   or die "Can't close $tmp: $!";
    }
}

d399 5
a403 1
	foreach my $pager (@@pagers) {
d405 1
a405 1
           last if system("$pager $tmp") == 0; # quoting prevents logical expansion
a412 11
sub cleanup {
    my @@files = @@_;
    for (@@files) {
	if ($Is_VMS) { 
	    1 while unlink($_);    # XXX: expect failure
	} else {
	    unlink($_);		   # or die "Can't unlink $_: $!";
	} 
    }
}

a426 3
    # We must look both in @@INC for library modules and in $bindir
    # for executables, like h2xs or perldoc itself.
    my @@searchdirs = ($bindir, @@INC);
d432 3
d460 2
a461 1
	    print STDERR "No documentation found for \"$_\".\n";
a493 7
# until here we could simply exit or die
# now we create temporary files that we have to clean up
# namely $tmp, $buffer
# that's because you did it wrong, should be descriptor based --tchrist

my $tmp;
my $buffer;
a494 2
    $tmp = "$ENV{TEMP}\\perldoc1.$$";
    $buffer = "$ENV{TEMP}\\perldoc1.b$$";
a499 2
    $tmp = 'Sys$Scratch:perldoc.tmp1_'.$$;
    $buffer = 'Sys$Scratch:perldoc.tmp1_b'.$$;
a502 4
    $tmp = "$ENV{TEMP}/perldoc1.$$";
    $buffer = "$ENV{TEMP}/perldoc1.b$$";
    $tmp =~ tr!\\/!//!s;
    $buffer =~ tr!\\/!//!s;
a507 3
      require POSIX;
      $tmp = POSIX::tmpnam();
      $buffer = POSIX::tmpnam();
a509 6
    else {
      # XXX: this is not secure, because it doesn't open it
      ($tmp, $buffer) = eval { require POSIX } 
	    ? (POSIX::tmpnam(),    POSIX::tmpnam()     )
	    : ("/tmp/perldoc1.$$", "/tmp/perldoc1.b$$" );
    }
a514 10
# make sure cleanup called
eval q{
    sub END { cleanup($tmp, $buffer) } 
    1;
} || die;

# exit/die in a windows sighandler is dangerous, so let it do the
# default thing, which is to exit
eval q{ use sigtrap qw(die INT TERM HUP QUIT) } unless $^O eq 'MSWin32';

d591 1
a591 1
	elsif (/^=head2/) {
d602 4
d609 5
a613 6
    sysopen(TMP, $buffer, O_WRONLY | O_EXCL | O_CREAT)
	or die("Can't open $buffer: $!");
    print TMP "=over 8\n\n";
    print TMP @@pod	or die "Can't print $buffer: $!";
    print TMP "=back\n";
    close TMP		or die "Can't close $buffer: $!";
d619 28
a646 1
    printout($_, $tmp, $filter);
d648 2
d693 3
d745 1
a745 1
The B<-X> option looks for a entry whose basename matches the name given on the
d755 1
a755 1
if unavailable.  If it cannot relinguish its privileges, it will not
d762 1
a762 4
give a descriptive name of a page, such as C<perlfunc>. You may also give a
partial or wrong-case name, such as "basename" for "File::Basename", but
this will be slower, if there is more then one page with the same partial
name, you will only get the first one.
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d39 3
d43 5
a47 1
push \@@pagers, "$Config{'pager'}" if -x "$Config{'pager'}";
d58 1
d90 1
d159 1
a159 1
if (!($Is_VMS || $Is_MSWin32 || $Is_Dos) && ($> == 0 || $< == 0)
d213 3
a215 2
    if ($< && $>) {   # don't be looking too hard now!
	eval q{ use blib; 1 } or die;
d236 1
a236 1
     my $path = join('/',$dir,$file);	# XXX: dirseps
d250 2
a251 2
     foreach $p (split(m!/!, $file)){	# XXX: dirseps
	my $try = "@@p/$p";
d256 1
a256 1
		my $tmp_path = join ('/', @@p);  # XXX: dirseps
d315 1
a315 1
    $global_target = (split(m!/!, $s))[-1];   # XXX: dirseps
d338 1
a338 1
	    my @@newdirs = map "$dir/$_", grep {  # XXX: dirseps
d341 1
a341 1
		-d  "$dir/$_"  # XXX: dirseps
d375 1
a375 1
	my $cmd = "pod2man --lax $file | $opt_n -man";
d419 5
a423 1
	    last if system("$pager $tmp") == 0;
d442 1
a442 2
	my $searchfor = $_;
	$searchfor =~ s,::,/,g;	    # XXX: dirseps
d453 1
a453 1
    # We must look both in @@INC for library modules and in PATH
d455 1
a455 1
    my @@searchdirs = @@INC;
d569 4
a572 1
eval q{ use sigtrap qw(die INT TERM HUP QUIT) };
d809 1
a809 1
This is perldoc v2.01.
d821 3
@


1.3
log
@perl5.005_03 (stock)
@
text
@d33 1
d35 4
d41 1
d48 4
d56 1
a56 1
# This is not to be confused with Tom Christianson's perlman, which is a
d59 3
d63 1
a63 1
if(@@ARGV<1) {
d67 1
a67 1
Usage: $me [-h] [-r] [-i] [-v] [-t] [-u] [-m] [-l] [-F] [-X] PageName|ModuleName|ProgramName
d72 1
a72 1
aquainted with the system.
a75 3
use Getopt::Std;
use Config '%Config';

d95 1
a95 1
    -i   Ignore case 
d100 1
d106 1
d109 1
a109 1
         is the name of a piece of documentation that you want to look at. You 
d111 2
a112 2
         `perlfunc') the name of a module, either like `Term::Info', 
         `Term/Info', the partial name of a module, like `info', or 
d123 1
a123 1
Any switches in the PERLDOC environment variable will be used before the 
d130 1
a130 1
if( defined $ENV{"PERLDOC"} ) {
d136 1
a136 1
my $getopts = "mhtluvriFf:Xq:";
d148 20
d169 1
a169 1
if( $opt_X ) {
d174 1
a174 1
if( (my $opts = do{ local $^W; $opt_t + $opt_u + $opt_m + $opt_l }) > 1) {
d176 6
a181 2
} elsif ($Is_MSWin32 || $Is_Dos) {
    $opt_t = 1 unless $opts
d188 7
a194 5
   @@pages = ("perlfunc");
} elsif ($opt_q) {
   @@pages = ("perlfaq1" .. "perlfaq9");
} else {
   @@pages = @@ARGV;
a198 5
	# Add ., lib and blib/* libs to @@INC (if they exist)
	unshift(@@INC, '.');
	unshift(@@INC, 'lib') if -d 'lib';
	require ExtUtils::testlib;
}
d200 2
d203 5
d211 1
a211 1
    return 1 if !$readit && $file =~ /\.pod$/i;
d213 4
a216 4
    open(TEST,"<$file");
    while(<TEST>) {
	if(/^=head/) {
	    close(TEST);
d220 1
a220 1
    close(TEST);
d226 1
a226 1
     my $path = join('/',$dir,$file);
d229 1
a229 1
        # on a case-forgiving file system or if case is important 
d235 2
d240 1
a240 1
     foreach $p (split(/\//, $file)){
d243 1
a243 1
 	if (-d _){
d246 1
a246 1
		my $tmp_path = join ('/', @@p);
d254 2
a255 1
 	} elsif (-f _ && -r _) {
d257 2
a258 1
 	} elsif (-f _) {
d260 2
a261 1
 	} else {
d264 1
a264 1
 	    opendir DIR, "@@p";
d271 1
a271 1
 	    closedir DIR;
d280 1
a280 1
 
d284 1
d287 2
a288 1
    } else {
d305 1
a305 1
    $global_target = (split('/', $s))[-1];
d308 1
a308 1
	($dir = VMS::Filespec::unixpath($dir)) =~ s!/$!! if $Is_VMS;
d314 1
a314 1
		or ( $^O eq 'os2' and 
d320 2
d325 1
a325 1
	
d327 5
a331 5
	    opendir(D,$dir);
	    my @@newdirs = map "$dir/$_", grep {
		not /^\.\.?$/ and
		not /^auto$/  and   # save time! don't search auto dirs
		-d  "$dir/$_"
d333 1
a333 1
	    closedir(D);
d335 2
a336 1
	    @@newdirs = map((s/.dir$//,$_)[1],@@newdirs) if $Is_VMS;
d344 81
d427 26
a452 8
        if ($podidx && open(PODIDX, $podidx)) {
	    my $searchfor = $_;
	    local($_);
	    $searchfor =~ s,::,/,g;
	    print STDERR "Searching for '$searchfor' in $podidx\n" if $opt_v;
	    while (<PODIDX>) {
		chomp;
		push(@@found, $_) if m,/$searchfor(?:\.(?:pod|pm))?$,i;
d454 30
a483 17
	    close(PODIDX);
	    next;
        }
	print STDERR "Searching for $_\n" if $opt_v;
	# We must look both in @@INC for library modules and in PATH
	# for executables, like h2xs or perldoc itself.
	my @@searchdirs = @@INC;
	if ($opt_F) {
	  next unless -r;
	  push @@found, $_ if $opt_m or containspod($_);
	  next;
	}
	unless ($opt_m) { 
	    if ($Is_VMS) {
		my($i,$trn);
		for ($i = 0; $trn = $ENV{'DCL$PATH'.$i}; $i++) {
		    push(@@searchdirs,$trn);
a484 4
		push(@@searchdirs,'perl_root:[lib.pod]')  # installed pods
	    } else {
	        push(@@searchdirs, grep(-d, split($Config{path_sep}, 
						 $ENV{'PATH'})));
d487 2
a488 28
	my @@files = searchfor(0,$_,@@searchdirs);
	if( @@files ) {
		print STDERR "Found as @@files\n" if $opt_v;
	} else {
		# no match, try recursive search
		
		@@searchdirs = grep(!/^\.$/,@@INC);
		
		@@files= searchfor(1,$_,@@searchdirs) if $opt_r;
		if( @@files ) {
			print STDERR "Loosely found as @@files\n" if $opt_v;
		} else {
			print STDERR "No documentation found for \"$_\".\n";
			if (@@global_found) {
			    print STDERR "However, try\n";
			    for my $dir (@@global_found) {
				opendir(DIR, $dir) or die "$!";
				while (my $file = readdir(DIR)) {
				    next if ($file =~ /^\./);
				    $file =~ s/\.(pm|pod)$//;
				    print STDERR "\tperldoc $_\::$file\n";
				}
				closedir DIR;
			    }
			}
		}
	}
	push(@@found,@@files);
d491 2
a492 2
if(!@@found) {
	exit ($Is_VMS ? 98962 : 1);
d503 7
a509 1
if( ! -t STDOUT ) { $no_tty = 1 }
d512 1
d514 34
a547 21
	$tmp = "$ENV{TEMP}\\perldoc1.$$";
	push @@pagers, qw( more< less notepad );
	unshift @@pagers, $ENV{PAGER}  if $ENV{PAGER};
} elsif ($Is_VMS) {
	$tmp = 'Sys$Scratch:perldoc.tmp1_'.$$;
	push @@pagers, qw( most more less type/page );
} elsif ($Is_Dos) {
	$tmp = "$ENV{TEMP}/perldoc1.$$";
	$tmp =~ tr!\\/!//!s;
	push @@pagers, qw( less.exe more.com< );
	unshift @@pagers, $ENV{PAGER}  if $ENV{PAGER};
} else {
	if ($^O eq 'os2') {
	  require POSIX;
	  $tmp = POSIX::tmpnam();
	  unshift @@pagers, 'less', 'cmd /c more <';
	} else {
	  $tmp = "/tmp/perldoc1.$$";	  
	}
	push @@pagers, qw( more less pg view cat );
	unshift @@pagers, $ENV{PAGER}  if $ENV{PAGER};
d551 7
d559 14
a572 6
	foreach my $pager (@@pagers) {
		system("$pager @@found") or exit;
	}
	if ($Is_VMS) { eval 'use vmsish qw(status exit); exit $?' }
	exit 1;
} 
d574 1
d576 13
a588 2
   my $perlfunc = shift @@found;
   open(PFUNC, $perlfunc) or die "Can't open $perlfunc: $!";
d590 25
a614 2
   # Functions like -r, -e, etc. are listed under `-X'.
   my $search_string = ($opt_f =~ /^-[rwxoRWXOeszfdlpSbctugkTBMAC]$/) ? 'I<-X' : $opt_f ;
d616 27
a642 39
   # Skip introduction
   while (<PFUNC>) {
       last if /^=head2 Alphabetical Listing of Perl Functions/;
   }

   # Look for our function
   my $found = 0;
   my @@pod;
   while (<PFUNC>) {
       if (/^=item\s+\Q$search_string\E\b/o)  {
	   $found = 1;
       } elsif (/^=item/) {
	   last if $found > 1;
       }
       next unless $found;
       push @@pod, $_;
       ++$found if /^\w/;	# found descriptive text
   }
   if (@@pod) {
       if ($opt_t) {
	   open(FORMATTER, "| pod2text") || die "Can't start filter";
	   print FORMATTER "=over 8\n\n";
	   print FORMATTER @@pod;
	   print FORMATTER "=back\n";
	   close(FORMATTER);
       } elsif (@@pod < $lines-2) {
	   print @@pod;
       } else {
	   foreach my $pager (@@pagers) {
		open (PAGER, "| $pager") or next;
		print PAGER @@pod ;
		close(PAGER) or next;
		last;
	   }
       }
   } else {
       die "No documentation for perl function `$opt_f' found\n";
   }
   exit;
d645 11
a655 38
if ($opt_q) {
   local @@ARGV = @@found;	# I'm lazy, sue me.
   my $found = 0;
   my %found_in;
   my @@pod;

   while (<>) {
      if (/^=head2\s+.*(?:$opt_q)/oi) {
	 $found = 1;
	 push @@pod, "=head1 Found in $ARGV\n\n" unless $found_in{$ARGV}++;
      } elsif (/^=head2/) {
	 $found = 0;
      }
      next unless $found;
      push @@pod, $_;
   }
   
   if (@@pod) {
      if ($opt_t) {
	 open(FORMATTER, "| pod2text") || die "Can't start filter";
	 print FORMATTER "=over 8\n\n";
	 print FORMATTER @@pod;
	 print FORMATTER "=back\n";
	 close(FORMATTER);
      } elsif (@@pod < $lines-2) {
	 print @@pod;
      } else {
	 foreach my $pager (@@pagers) {
	    open (PAGER, "| $pager") or next;
	    print PAGER @@pod ;
	    close(PAGER) or next;
	    last;
	 }
      }
   } else {
      die "No documentation for perl FAQ keyword `$opt_q' found\n";
   }
   exit;
d659 5
d665 6
a670 28
	my $err;
	if($opt_t) {
		open(TMP,">>$tmp");
		Pod::Text::pod2text($_,*TMP);
		close(TMP);
	} elsif(not $opt_u) {
		my $cmd = "pod2man --lax $_ | nroff -man";
		$cmd .= " | col -x" if $^O =~ /hpux/;
		my $rslt = `$cmd`;
		unless(($err = $?)) {
			open(TMP,">>$tmp");
			print TMP $rslt;
			close TMP;
		}
	}
	                                                
	if( $opt_u or $err or -z $tmp) {
		open(OUT,">>$tmp");
		open(IN,"<$_");
		my $cut = 1;
		while (<IN>) {
			$cut = $1 eq 'cut' if /^=(\w+)/;
			next if $cut;
			print OUT;
		}
		close(IN);
		close(OUT);
	}
d673 3
a675 8
if( $no_tty ) {
	open(TMP,"<$tmp");
	print while <TMP>;
	close(TMP);
} else {
	foreach my $pager (@@pagers) {
		system("$pager $tmp") or last;
	}
a677 3
1 while unlink($tmp); #Possibly pointless VMSism

exit 0;
d757 9
d770 1
a770 1
give a descriptive name of a page, such as C<perlfunc>. You make also give a
d779 1
a779 1
Any switches in the C<PERLDOC> environment variable will be used before the 
d789 6
d799 2
a800 1
Minor updates by Andy Dougherty <doughera@@lafcol.lafayette.edu>
d805 12
d821 1
a821 1
#       Gurusamy Sarathy <gsar@@umich.edu>
d824 1
a824 1
#       Gurusamy Sarathy <gsar@@umich.edu>
d830 1
a830 1
# 
@


1.2
log
@perl 5.004_04
@
text
@d5 1
d16 1
d31 1
a31 1
	if \$running_under_some_shell;
d33 2
a34 1
\@@pagers = ();
d51 1
a51 1
	$me = $0;		# Editing $0 is unportable
d54 1
a54 1
Usage: $me [-h] [-v] [-t] [-u] [-m] [-l] PageName|ModuleName|ProgramName
d56 1
d58 2
a59 2
We suggest you use "perldoc perldoc" to get aquainted 
with the system.
d66 2
a67 2
@@global_found = ();
$global_target = "";
d69 3
a71 2
$Is_VMS = $^O eq 'VMS';
$Is_MSWin32 = $^O eq 'MSWin32';
d80 1
d84 2
d89 3
a91 2
    -m   Display modules file in its entirety
    -l   Display the modules file name
d93 2
d106 5
a110 1
         
d112 2
a113 1
command line arguments.
d118 5
a122 1
use Text::ParseWords;
d124 2
d127 1
a127 1
unshift(@@ARGV,shellwords($ENV{"PERLDOC"}));
d129 2
a130 1
getopts("mhtluvf:") || usage;
d132 1
a132 1
usage if $opt_h || $opt_h; # avoid -w warning
d134 9
a142 1
if ($opt_t + $opt_u + $opt_m + $opt_l > 1) {
d144 2
a145 2
} elsif ($Is_MSWin32) {
    $opt_t = 1 unless $opt_t + $opt_u + $opt_m + $opt_l;
d150 1
d153 2
d185 7
a191 5
     my($file) = @@_;
     # on a case-forgiving file system we can simply use -f $file
     if ($Is_VMS or $Is_MSWin32 or $^O eq 'os2') {
        return $file if -f $file and -r _;
	warn "Ignored $file: unreadable\n" unless -r _;
d196 2
a197 1
     my(@@p,$p,$cip);
d204 1
a204 1
		$tmp_path = join ('/', @@p);
d230 1
a230 1
	    warn "Ignored $file: unreadable\n" if -f _;
d233 1
a233 1
     return; # is not a file
d238 8
a245 2
    my($file) = @@_;
    return minus_f_nocase($file) && containspod($file) ? $file : "";
d262 3
a264 3
	if (       ( $ret = check_file "$dir/$s.pod")
		or ( $ret = check_file "$dir/$s.pm")
		or ( $ret = check_file "$dir/$s")
d266 1
a266 1
		     $ret = check_file "$dir/$s.com")
d268 5
a272 5
		     $ret = check_file "$dir/$s.cmd")
		or ( ($Is_MSWin32 or $^O eq 'os2') and 
		     $ret = check_file "$dir/$s.bat")
		or ( $ret = check_file "$dir/pod/$s.pod")
		or ( $ret = check_file "$dir/pod/$s")
d294 1
a294 1

d296 12
d311 6
a316 1
	@@searchdirs = @@INC;
d323 1
a327 1
	    @@files= searchfor(0,$_,@@searchdirs);
d329 1
d337 1
a337 1
		@@files= searchfor(1,$_,@@searchdirs);
d344 1
a344 2
			    my $dir = $file = "";
			    for $dir (@@global_found) {
d346 1
a346 1
				while ($file = readdir(DIR)) {
d368 3
d373 1
d381 5
d390 1
d400 1
a400 1
	foreach $pager (@@pagers) {
d411 3
d423 1
a423 1
       if (/^=item\s+\Q$opt_f\E\b/o)  {
d439 2
d442 6
a447 1
	   print @@pod;
d455 40
d497 1
d505 1
a505 1
		$rslt = `$cmd`;
d516 1
a516 1
		$cut = 1;
d532 1
a532 1
	foreach $pager (@@pagers) {
d549 1
a549 1
B<perldoc> [B<-h>] [B<-v>] [B<-t>] [B<-u>] [B<-m>] [B<-l>] PageName|ModuleName|ProgramName
d553 2
d598 4
d607 12
d637 4
a640 1
C<perldoc> itself, are available.)
d651 6
d690 1
@


1.1
log
@Initial revision
@
text
@d15 3
a17 4
chdir(dirname($0));
($file = basename($0)) =~ s/\.PL$//;
$file =~ s/\.pl$//
	if ($^O eq 'VMS' or $^O eq 'os2');  # "case-forgiving"
d27 6
a32 3
$Config{'startperl'}
    eval 'exec perl -S \$0 "\$@@"'
	if 0;
a37 2
    eval 'exec perl -S $0 "$@@"'
	if 0;
d48 2
d51 2
a52 1
Usage: $0 [-h] [-v] [-t] [-u] [-m] PageName|ModuleName|ProgramName
d60 5
d66 1
d69 3
a71 1
        warn "@@_\n" if @@_;
d73 7
a79 3
perldoc [-h] [-v] [-u] PageName|ModuleName|ProgramName...
    -h   Display this help message.
    -t   Display pod using pod2text instead of pod2man and nroff.
d82 3
a84 1
    -v	 Verbosely describe what's going on.
d91 4
d107 1
a107 1
getopts("mhtuv") || usage;
d111 5
a115 1
usage("only one of -t, -u, or -m") if $opt_t + $opt_u + $opt_m > 1;
d119 15
a133 1
@@pages = @@ARGV;
d136 8
a143 8
	my($file) = @@_;
	local($_);
	open(TEST,"<$file");
	while(<TEST>) {
		if(/^=head/) {
			close(TEST);
			return 1;
		}
d145 3
a147 2
	close(TEST);
	return 0;
d150 1
a150 1
 sub minus_f_nocase {
d152 6
d162 3
a164 6
	if ($Is_VMS and not scalar @@p) {
	    # VMS filesystems don't begin at '/'
	    push(@@p,$p);
	    next;
	}
 	if (-d ("@@p/$p")){
d166 13
a178 2
 	} elsif (-f ("@@p/$p")) {
 	    return "@@p/$p";
a183 1
		$cip =~ s/\.dir$// if $Is_VMS;
d192 2
a193 1
 	    return "@@p" if -f "@@p";
d197 1
a197 1
 }
d199 51
a249 32
  sub searchfor {
  	my($recurse,$s,@@dirs) = @@_;
  	$s =~ s!::!/!g;
  	$s = VMS::Filespec::unixify($s) if $Is_VMS;
  	printf STDERR "looking for $s in @@dirs\n" if $opt_v;
 	my $ret;
 	my $i;
 	my $dir;
  	for ($i=0;$i<@@dirs;$i++) {
  		$dir = $dirs[$i];
  		($dir = VMS::Filespec::unixpath($dir)) =~ s!/$!! if $Is_VMS;
 	    if ((    $ret = minus_f_nocase "$dir/$s.pod")
 		or ( $ret = minus_f_nocase "$dir/$s.pm"  and containspod($ret))
 		or ( $ret = minus_f_nocase "$dir/$s"     and containspod($ret))
 		or ( $Is_VMS and 
 		     $ret = minus_f_nocase "$dir/$s.com" and containspod($ret))
 		or ( $ret = minus_f_nocase "$dir/pod/$s.pod")
 		or ( $ret = minus_f_nocase "$dir/pod/$s" and containspod($ret)))
 		{ return $ret; }
 		
 		if($recurse) {
			opendir(D,$dir);
			my(@@newdirs) = grep(-d,map("$dir/$_",grep(!/^\.\.?$/,readdir(D))));
			closedir(D);
			@@newdirs = map((s/.dir$//,$_)[1],@@newdirs) if $Is_VMS;
			next unless @@newdirs;
			print STDERR "Also looking in @@newdirs\n" if $opt_v;
			push(@@dirs,@@newdirs);
 		}
 	}
  	return ();
  }
d264 2
a265 1
		    push(@@searchdirs, grep(-d, split(':', $ENV{'PATH'})));
a275 1
		
d280 14
a293 1
			print STDERR "No documentation found for '$_'\n";
d303 6
a308 1
if( ! -t STDOUT ) { $opt_f = 1 }
d310 7
a316 5
unless($Is_VMS) {
	$tmp = "/tmp/perldoc1.$$";
	$goodresult = 0;
	@@pagers = qw( more less pg view cat );
	unshift(@@pagers,$ENV{PAGER}) if $ENV{PAGER};
d318 8
a325 4
	$tmp = 'Sys$Scratch:perldoc.tmp1_'.$$;
	@@pagers = qw( most more less type/page );
	unshift(@@pagers,$ENV{PERLDOC_PAGER}) if $ENV{PERLDOC_PAGER};
	$goodresult = 1;
d327 1
d330 5
a334 5
    foreach $pager (@@pagers) {
	my($sts) = system("$pager @@found");
	exit 0 if ($Is_VMS ? ($sts & 1) : !$sts);
    }
    exit $Is_VMS ? $sts : 1;
d337 38
d382 8
a389 6
		open(TMP,">>$tmp");
		$rslt = `pod2man $_ | nroff -man`;
		if ($Is_VMS) { $err = !($? % 2) || $rslt =~ /IVVERB/; }
		else      { $err = $?; }
		print TMP $rslt unless $err;
		close TMP;
d406 1
a406 1
if( $opt_f ) {
d412 1
a412 3
		$sts = system("$pager $tmp");
		last if $Is_VMS && ($sts & 1);
		last unless $sts;
d428 3
a430 1
B<perldoc> [B<-h>] [B<-v>] [B<-t>] [B<-u>] PageName|ModuleName|ProgramName
d434 5
a438 4
I<perldoc> looks up a piece of documentation in .pod format that is
embedded in the perl installation tree or in a perl script, and displays
it via pod2man | nroff -man | $PAGER.  This is primarily used for the
documentation for the perl library modules. 
d471 9
a505 4
=head1 SEE ALSO

=head1 DIAGNOSTICS

d509 3
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a4 1
use Cwd;
d15 4
a18 4
$origdir = cwd;
chdir dirname($0);
$file = basename($0, '.PL');
$file .= '.com' if $^O eq 'VMS';
d28 2
a29 2
$Config{startperl}
    eval 'exec $Config{perlpath} -S \$0 \${1+"\$@@"}'
a30 4

use strict;
my \@@pagers = ();
push \@@pagers, "$Config{'pager'}" if -x "$Config{'pager'}";
d36 2
a47 2
	my $me = $0;		# Editing $0 is unportable
	$me =~ s,.*/,,;
d49 1
a49 3
Usage: $me [-h] [-r] [-i] [-v] [-t] [-u] [-m] [-l] [-F] [-X] PageName|ModuleName|ProgramName
       $me -f PerlFunc
       $me -q FAQKeywords
d51 2
a52 2
The -h option prints more help.  Also try "perldoc perldoc" to get
aquainted with the system.
d57 1
a57 8
use Config '%Config';

my @@global_found = ();
my $global_target = "";

my $Is_VMS = $^O eq 'VMS';
my $Is_MSWin32 = $^O eq 'MSWin32';
my $Is_Dos = $^O eq 'dos';
d60 1
a60 3
    warn "@@_\n" if @@_;
    # Erase evidence of previous errors (if any), so exit status is simple.
    $! = 0;
d62 3
a64 10
perldoc [options] PageName|ModuleName|ProgramName...
perldoc [options] -f BuiltinFunction
perldoc [options] -q FAQRegex

Options:
    -h   Display this help message
    -r   Recursive search (slow)
    -i   Ignore case 
    -t   Display pod using pod2text instead of pod2man and nroff
             (-t is the default on win32)
d66 2
a67 7
    -m   Display module's file in its entirety
    -l   Display the module's file name
    -F   Arguments are file names, not modules
    -v	 Verbosely describe what's going on
    -X	 use index if present (looks for pod.idx at $Config{archlib})
    -q   Search the text of questions (not answers) in perlfaq[1-9]

d74 1
a74 9

BuiltinFunction
         is the name of a perl function.  Will extract documentation from
         `perlfunc'.

FAQRegex
         is a regex. Will search perlfaq[1-9] for and extract any
         questions that match.

d76 1
a76 2
command line arguments.  The optional pod index file contains a list of
filenames, one per line.
d81 1
a81 8
if( defined $ENV{"PERLDOC"} ) {
    require Text::ParseWords;
    unshift(@@ARGV, Text::ParseWords::shellwords($ENV{"PERLDOC"}));
}
!NO!SUBS!

my $getopts = "mhtluvriFf:Xq:";
print OUT <<"!GET!OPTS!";
a82 1
use vars qw( @@{[map "\$opt_$_", ($getopts =~ /\w/g)]} );
d84 1
a84 2
getopts("$getopts") || usage;
!GET!OPTS!
d86 1
a86 1
print OUT <<'!NO!SUBS!';
d88 1
a88 1
usage if $opt_h;
d90 1
a90 11
my $podidx;
if( $opt_X ) {
    $podidx = "$Config{'archlib'}/pod.idx";
    $podidx = "" unless -f $podidx && -r _ && -M _ <= 7;
}

if( (my $opts = do{ local $^W; $opt_t + $opt_u + $opt_m + $opt_l }) > 1) {
    usage("only one of -t, -u, -m or -l")
} elsif ($Is_MSWin32 || $Is_Dos) {
    $opt_t = 1 unless $opts
}
d94 1
a94 18
my @@pages;
if ($opt_f) {
   @@pages = ("perlfunc");
} elsif ($opt_q) {
   @@pages = ("perlfaq1" .. "perlfaq9");
} else {
   @@pages = @@ARGV;
}

# Does this look like a module or extension directory?
if (-f "Makefile.PL") {
	# Add ., lib and blib/* libs to @@INC (if they exist)
	unshift(@@INC, '.');
	unshift(@@INC, 'lib') if -d 'lib';
	require ExtUtils::testlib;
}


d97 8
a104 8
    my($file, $readit) = @@_;
    return 1 if !$readit && $file =~ /\.pod$/i;
    local($_);
    open(TEST,"<$file");
    while(<TEST>) {
	if(/^=head/) {
	    close(TEST);
	    return 1;
d106 2
a107 3
    }
    close(TEST);
    return 0;
d110 2
a111 10
sub minus_f_nocase {
     my($dir,$file) = @@_;
     my $path = join('/',$dir,$file);
     return $path if -f $path and -r _;
     if (!$opt_i or $Is_VMS or $Is_MSWin32 or $Is_Dos or $^O eq 'os2') {
        # on a case-forgiving file system or if case is important 
	# that is it all we can do
	warn "Ignored $path: unreadable\n" if -f _;
	return '';
     }
d114 1
a114 2
     my @@p = ($dir);
     my($p,$cip);
d116 6
a121 3
	my $try = "@@p/$p";
	stat $try;
 	if (-d _){
d123 2
a124 13
	    if ( $p eq $global_target) {
		my $tmp_path = join ('/', @@p);
		my $path_f = 0;
		for (@@global_found) {
		    $path_f = 1 if $_ eq $tmp_path;
		}
		push (@@global_found, $tmp_path) unless $path_f;
		print STDERR "Found as @@p but directory\n" if $opt_v;
	    }
 	} elsif (-f _ && -r _) {
 	    return $try;
 	} elsif (-f _) {
	    warn "Ignored $try: unreadable\n";
d130 1
d139 1
a139 2
 	    return "@@p" if -f "@@p" and -r _;
	    warn "Ignored @@p: unreadable\n" if -f _;
d142 2
a143 2
     return "";
}
d145 32
a177 10
sub check_file {
    my($dir,$file) = @@_;
    if ($opt_m) {
	return minus_f_nocase($dir,$file);
    } else {
	my $path = minus_f_nocase($dir,$file);
        return $path if length $path and containspod($path);
    }
    return "";
}
a178 47

sub searchfor {
    my($recurse,$s,@@dirs) = @@_;
    $s =~ s!::!/!g;
    $s = VMS::Filespec::unixify($s) if $Is_VMS;
    return $s if -f $s && containspod($s);
    printf STDERR "Looking for $s in @@dirs\n" if $opt_v;
    my $ret;
    my $i;
    my $dir;
    $global_target = (split('/', $s))[-1];
    for ($i=0; $i<@@dirs; $i++) {
	$dir = $dirs[$i];
	($dir = VMS::Filespec::unixpath($dir)) =~ s!/$!! if $Is_VMS;
	if (       ( $ret = check_file $dir,"$s.pod")
		or ( $ret = check_file $dir,"$s.pm")
		or ( $ret = check_file $dir,$s)
		or ( $Is_VMS and
		     $ret = check_file $dir,"$s.com")
		or ( $^O eq 'os2' and 
		     $ret = check_file $dir,"$s.cmd")
		or ( ($Is_MSWin32 or $Is_Dos or $^O eq 'os2') and
		     $ret = check_file $dir,"$s.bat")
		or ( $ret = check_file "$dir/pod","$s.pod")
		or ( $ret = check_file "$dir/pod",$s)
	) {
	    return $ret;
	}
	
	if ($recurse) {
	    opendir(D,$dir);
	    my @@newdirs = map "$dir/$_", grep {
		not /^\.\.?$/ and
		not /^auto$/  and   # save time! don't search auto dirs
		-d  "$dir/$_"
	    } readdir D;
	    closedir(D);
	    next unless @@newdirs;
	    @@newdirs = map((s/.dir$//,$_)[1],@@newdirs) if $Is_VMS;
	    print STDERR "Also looking in @@newdirs\n" if $opt_v;
	    push(@@dirs,@@newdirs);
	}
    }
    return ();
}

my @@found;
a179 12
        if ($podidx && open(PODIDX, $podidx)) {
	    my $searchfor = $_;
	    local($_);
	    $searchfor =~ s,::,/,g;
	    print STDERR "Searching for '$searchfor' in $podidx\n" if $opt_v;
	    while (<PODIDX>) {
		chomp;
		push(@@found, $_) if m,/$searchfor(?:\.(?:pod|pm))?$,i;
	    }
	    close(PODIDX);
	    next;
        }
d183 1
a183 6
	my @@searchdirs = @@INC;
	if ($opt_F) {
	  next unless -r;
	  push @@found, $_ if $opt_m or containspod($_);
	  next;
	}
a189 1
		push(@@searchdirs,'perl_root:[lib.pod]')  # installed pods
d191 1
a191 2
	        push(@@searchdirs, grep(-d, split($Config{path_sep}, 
						 $ENV{'PATH'})));
d193 1
a194 1
	my @@files = searchfor(0,$_,@@searchdirs);
d202 2
a203 1
		@@files= searchfor(1,$_,@@searchdirs) if $opt_r;
d207 1
a207 13
			print STDERR "No documentation found for \"$_\".\n";
			if (@@global_found) {
			    print STDERR "However, try\n";
			    for my $dir (@@global_found) {
				opendir(DIR, $dir) or die "$!";
				while (my $file = readdir(DIR)) {
				    next if ($file =~ /^\./);
				    $file =~ s/\.(pm|pod)$//;
				    print STDERR "\tperldoc $_\::$file\n";
				}
				closedir DIR;
			    }
			}
d217 1
a217 6
if ($opt_l) {
    print join("\n", @@found), "\n";
    exit;
}

my $lines = $ENV{LINES} || 24;
d219 6
a224 9
my $no_tty;
if( ! -t STDOUT ) { $no_tty = 1 }

my $tmp;
if ($Is_MSWin32) {
	$tmp = "$ENV{TEMP}\\perldoc1.$$";
	push @@pagers, qw( more< less notepad );
	unshift @@pagers, $ENV{PAGER}  if $ENV{PAGER};
} elsif ($Is_VMS) {
d226 3
a228 16
	push @@pagers, qw( most more less type/page );
} elsif ($Is_Dos) {
	$tmp = "$ENV{TEMP}/perldoc1.$$";
	$tmp =~ tr!\\/!//!s;
	push @@pagers, qw( less.exe more.com< );
	unshift @@pagers, $ENV{PAGER}  if $ENV{PAGER};
} else {
	if ($^O eq 'os2') {
	  require POSIX;
	  $tmp = POSIX::tmpnam();
	  unshift @@pagers, 'less', 'cmd /c more <';
	} else {
	  $tmp = "/tmp/perldoc1.$$";	  
	}
	push @@pagers, qw( more less pg view cat );
	unshift @@pagers, $ENV{PAGER}  if $ENV{PAGER};
a229 1
unshift @@pagers, $ENV{PERLDOC_PAGER} if $ENV{PERLDOC_PAGER};
d232 5
a236 5
	foreach my $pager (@@pagers) {
		system("$pager @@found") or exit;
	}
	if ($Is_VMS) { eval 'use vmsish qw(status exit); exit $?' }
	exit 1;
a238 88
if ($opt_f) {
   my $perlfunc = shift @@found;
   open(PFUNC, $perlfunc) or die "Can't open $perlfunc: $!";

   # Functions like -r, -e, etc. are listed under `-X'.
   my $search_string = ($opt_f =~ /^-[rwxoRWXOeszfdlpSbctugkTBMAC]$/) ? 'I<-X' : $opt_f ;

   # Skip introduction
   while (<PFUNC>) {
       last if /^=head2 Alphabetical Listing of Perl Functions/;
   }

   # Look for our function
   my $found = 0;
   my @@pod;
   while (<PFUNC>) {
       if (/^=item\s+\Q$search_string\E\b/o)  {
	   $found = 1;
       } elsif (/^=item/) {
	   last if $found > 1;
       }
       next unless $found;
       push @@pod, $_;
       ++$found if /^\w/;	# found descriptive text
   }
   if (@@pod) {
       if ($opt_t) {
	   open(FORMATTER, "| pod2text") || die "Can't start filter";
	   print FORMATTER "=over 8\n\n";
	   print FORMATTER @@pod;
	   print FORMATTER "=back\n";
	   close(FORMATTER);
       } elsif (@@pod < $lines-2) {
	   print @@pod;
       } else {
	   foreach my $pager (@@pagers) {
		open (PAGER, "| $pager") or next;
		print PAGER @@pod ;
		close(PAGER) or next;
		last;
	   }
       }
   } else {
       die "No documentation for perl function `$opt_f' found\n";
   }
   exit;
}

if ($opt_q) {
   local @@ARGV = @@found;	# I'm lazy, sue me.
   my $found = 0;
   my %found_in;
   my @@pod;

   while (<>) {
      if (/^=head2\s+.*(?:$opt_q)/oi) {
	 $found = 1;
	 push @@pod, "=head1 Found in $ARGV\n\n" unless $found_in{$ARGV}++;
      } elsif (/^=head2/) {
	 $found = 0;
      }
      next unless $found;
      push @@pod, $_;
   }
   
   if (@@pod) {
      if ($opt_t) {
	 open(FORMATTER, "| pod2text") || die "Can't start filter";
	 print FORMATTER "=over 8\n\n";
	 print FORMATTER @@pod;
	 print FORMATTER "=back\n";
	 close(FORMATTER);
      } elsif (@@pod < $lines-2) {
	 print @@pod;
      } else {
	 foreach my $pager (@@pagers) {
	    open (PAGER, "| $pager") or next;
	    print PAGER @@pod ;
	    close(PAGER) or next;
	    last;
	 }
      }
   } else {
      die "No documentation for perl FAQ keyword `$opt_q' found\n";
   }
   exit;
}

a240 1
	my $err;
d246 6
a251 8
		my $cmd = "pod2man --lax $_ | nroff -man";
		$cmd .= " | col -x" if $^O =~ /hpux/;
		my $rslt = `$cmd`;
		unless(($err = $?)) {
			open(TMP,">>$tmp");
			print TMP $rslt;
			close TMP;
		}
d257 1
a257 1
		my $cut = 1;
d268 1
a268 1
if( $no_tty ) {
d273 4
a276 2
	foreach my $pager (@@pagers) {
		system("$pager $tmp") or last;
d292 1
a292 5
B<perldoc> [B<-h>] [B<-v>] [B<-t>] [B<-u>] [B<-m>] [B<-l>] [B<-F>]  [B<-X>] PageName|ModuleName|ProgramName

B<perldoc> B<-f> BuiltinFunction

B<perldoc> B<-q> FAQ Keyword
d296 4
a299 5
I<perldoc> looks up a piece of documentation in .pod format that is embedded
in the perl installation tree or in a perl script, and displays it via
C<pod2man | nroff -man | $PAGER>. (In addition, if running under HP-UX,
C<col -x> will be used.) This is primarily used for the documentation for
the perl library modules.
a331 25
=item B<-l> file name only

Display the file name of the module found.

=item B<-F> file names

Consider arguments as file names, no search in directories will be performed.

=item B<-f> perlfunc

The B<-f> option followed by the name of a perl built in function will
extract the documentation of this function from L<perlfunc>.

=item B<-q> perlfaq

The B<-q> option takes a regular expression as an argument.  It will search
the question headings in perlfaq[1-9] and print the entries matching
the regular expression.

=item B<-X> use an index if present

The B<-X> option looks for a entry whose basename matches the name given on the
command line in the file C<$Config{archlib}/pod.idx>.  The pod.idx file should
contain fully qualified filenames, one per line.

d350 1
a350 4
C<perldoc> itself, are available.)  C<perldoc> will use, in order of
preference, the pager defined in C<PERLDOC_PAGER>, C<MANPAGER>, or
C<PAGER> before trying to find a pager on its own.  (C<MANPAGER> is not
used if C<perldoc> was told to display plain text or unformatted pod.)
d358 4
a364 9
# Version 1.14: Wed Jul 15 01:50:20 EST 1998
#       Robin Barker <rmb1@@cise.npl.co.uk>
#	-strict, -w cleanups
# Version 1.13: Fri Feb 27 16:20:50 EST 1997
#       Gurusamy Sarathy <gsar@@umich.edu>
#	-doc tweaks for -F and -X options
# Version 1.12: Sat Apr 12 22:41:09 EST 1997
#       Gurusamy Sarathy <gsar@@umich.edu>
#	-various fixes for win32
a394 1
chdir $origdir;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a32 1
use warnings;
a33 4

# make sure creat()s are neither too much nor too little
INIT { eval { umask(0077) } }   # doubtless someone has no mask

a35 1

a41 4
use Fcntl;    # for sysopen
use Getopt::Std;
use Config '%Config';

d46 1
a46 1
# This is not to be confused with Tom Christiansen's perlman, which is a
a48 3
# 
# Massive security and correctness patches applied to this
# noisome program by Tom Christiansen Sat Mar 11 15:22:33 MST 2000 
d50 1
a50 1
if (@@ARGV<1) {
d54 1
a54 1
Usage: $me [-h] [-r] [-i] [-v] [-t] [-u] [-m] [-n program] [-l] [-F] [-X] PageName|ModuleName|ProgramName
d59 1
a59 1
acquainted with the system.
d63 3
d85 1
a85 1
    -i   Ignore case
a89 1
    -n   Specify replacement for nroff
a94 1
    -U	 Run in insecure mode (superuser only)
d97 1
a97 1
         is the name of a piece of documentation that you want to look at. You
d99 2
a100 2
         `perlfunc') the name of a module, either like `Term::Info',
         `Term/Info', the partial name of a module, like `info', or
d111 1
a111 1
Any switches in the PERLDOC environment variable will be used before the
d118 1
a118 1
if (defined $ENV{"PERLDOC"}) {
d124 1
a124 1
my $getopts = "mhtluvriFf:Xq:n:U";
a135 20
# refuse to run if we should be tainting and aren't
# (but regular users deserve protection too, though!)
if (!($Is_VMS || $Is_MSWin32 || $Is_Dos) && ($> == 0 || $< == 0)
     && !am_taint_checking()) 
{{
    if ($opt_U) {
        my $id = eval { getpwnam("nobody") };
           $id = eval { getpwnam("nouser") } unless defined $id;
           $id = -2 unless defined $id;
        eval {
            $> = $id;  # must do this one first!
            $< = $id;
        };
        last if !$@@ && $< && $>;
    }
    die "Superuser must not run $0 without security audit and taint checks.\n";
}}

$opt_n = "nroff" if !$opt_n;

d137 1
a137 1
if ($opt_X) {
d142 1
a142 1
if ((my $opts = do{ no warnings; $opt_t + $opt_u + $opt_m + $opt_l }) > 1) {
d144 2
a145 6
}
elsif ($Is_MSWin32
       || $Is_Dos
       || !($ENV{TERM} && $ENV{TERM} !~ /dumb|emacs|none|unknown/i))
{
    $opt_t = 1 unless $opts;
d152 5
a156 7
    @@pages = ("perlfunc");
}
elsif ($opt_q) {
    @@pages = ("perlfaq1" .. "perlfaq9");
}
else {
    @@pages = @@ARGV;
d161 5
a166 2
    # Add ., lib to @@INC (if they exist)
    eval q{ use lib qw(. lib); 1; } or die;
a167 5
    # don't add if superuser
    if ($< && $>) {   # don't be looking too hard now!
	eval q{ use blib; 1 } or die;
    }
}
d171 1
a171 1
    return 1 if !$readit && $file =~ /\.pod\z/i;
d173 4
a176 4
    open(TEST,"<", $file) 	or die "Can't open $file: $!";
    while (<TEST>) {
	if (/^=head/) {
	    close(TEST) 	or die "Can't close $file: $!";
d180 1
a180 1
    close(TEST) 		or die "Can't close $file: $!";
d186 1
a186 1
     my $path = join('/',$dir,$file);	# XXX: dirseps
d189 1
a189 1
        # on a case-forgiving file system or if case is important
a194 2
     # this is completely wicked.  don't mess with $", and if 
     # you do, don't assume / is the dirsep!
d198 1
a198 1
     foreach $p (split(m!/!, $file)){	# XXX: dirseps
d201 1
a201 1
 	if (-d _) {
d204 1
a204 1
		my $tmp_path = join ('/', @@p);  # XXX: dirseps
d212 1
a212 2
 	}
	elsif (-f _ && -r _) {
d214 1
a214 2
 	}
	elsif (-f _) {
d216 1
a216 2
 	}
	elsif (-d "@@p") {
d219 1
a219 1
 	    opendir DIR, "@@p" 	    or die "opendir @@p: $!";
d226 1
a226 1
 	    closedir DIR	    or die "closedir @@p: $!";
d235 1
a235 1

a238 1
    return "" if length $dir and not -d $dir;
d241 1
a241 2
    }
    else {
d258 1
a258 1
    $global_target = (split(m!/!, $s))[-1];   # XXX: dirseps
d261 1
a261 1
	($dir = VMS::Filespec::unixpath($dir)) =~ s!/\z!! if $Is_VMS;
d267 1
a267 1
		or ( $^O eq 'os2' and
a272 2
		or ( $ret = check_file "$dir/pods","$s.pod")
		or ( $ret = check_file "$dir/pods",$s)
d276 1
a276 1

d278 5
a282 5
	    opendir(D,$dir)	or die "Can't opendir $dir: $!";
	    my @@newdirs = map "$dir/$_", grep {  # XXX: dirseps
		not /^\.\.?\z/s and
		not /^auto\z/s  and   # save time! don't search auto dirs
		-d  "$dir/$_"  # XXX: dirseps
d284 1
a284 1
	    closedir(D)		or die "Can't closedir $dir: $!";
d286 1
a286 2
	    # what a wicked map!
	    @@newdirs = map((s/\.dir\z//,$_)[1],@@newdirs) if $Is_VMS;
a293 81
sub filter_nroff {
  my @@data = split /\n{2,}/, shift;
  shift @@data while @@data and $data[0] !~ /\S/; # Go to header
  shift @@data if @@data and $data[0] =~ /Contributed\s+Perl/; # Skip header
  pop @@data if @@data and $data[-1] =~ /^\w/; # Skip footer, like
				# 28/Jan/99 perl 5.005, patch 53 1
  join "\n\n", @@data;
}

sub printout {
    my ($file, $tmp, $filter) = @@_;
    my $err;

    if ($opt_t) {
	# why was this append?
	sysopen(OUT, $tmp, O_WRONLY | O_EXCL | O_CREAT, 0600)
	    or die ("Can't open $tmp: $!");
	Pod::Text->new()->parse_from_file($file,\*OUT);
	close OUT   or die "can't close $tmp: $!";
    }
    elsif (not $opt_u) {
	my $cmd = "pod2man --lax $file | $opt_n -man";
	$cmd .= " | col -x" if $^O =~ /hpux/;
	my $rslt = `$cmd`;
	$rslt = filter_nroff($rslt) if $filter;
	unless (($err = $?)) {
	    # why was this append?
	    sysopen(TMP, $tmp, O_WRONLY | O_EXCL | O_CREAT, 0600)
		or die "Can't open $tmp: $!";
	    print TMP $rslt
		or die "Can't print $tmp: $!";
	    close TMP
		or die "Can't close $tmp: $!";
	}
    }
    if ($opt_u or $err or -z $tmp) {  # XXX: race with -z
	# why was this append?
	sysopen(OUT, $tmp, O_WRONLY | O_EXCL | O_CREAT, 0600)
	    or die "Can't open $tmp: $!";
	open(IN,"<", $file)   or die("Can't open $file: $!");
	my $cut = 1;
	local $_;
	while (<IN>) {
	    $cut = $1 eq 'cut' if /^=(\w+)/;
	    next if $cut;
	    print OUT
		or die "Can't print $tmp: $!";
	}
	close IN    or die "Can't close $file: $!";
	close OUT   or die "Can't close $tmp: $!";
    }
}

sub page {
    my ($tmp, $no_tty, @@pagers) = @@_;
    if ($no_tty) {
	open(TMP,"<", $tmp) 	or die "Can't open $tmp: $!";
	local $_;
	while (<TMP>) {
	    print or die "Can't print to stdout: $!";
	} 
	close TMP		or die "Can't close while $tmp: $!";
    }
    else {
	foreach my $pager (@@pagers) {
	    last if system("$pager $tmp") == 0;
	}
    }
}

sub cleanup {
    my @@files = @@_;
    for (@@files) {
	if ($Is_VMS) { 
	    1 while unlink($_);    # XXX: expect failure
	} else {
	    unlink($_);		   # or die "Can't unlink $_: $!";
	} 
    }
}

d296 31
a326 26
    if ($podidx && open(PODIDX, $podidx)) {
	my $searchfor = $_;
	$searchfor =~ s,::,/,g;	    # XXX: dirseps
	print STDERR "Searching for '$searchfor' in $podidx\n" if $opt_v;
	local $_;
	while (<PODIDX>) {
	    chomp;
	    push(@@found, $_) if m,/$searchfor(?:\.(?:pod|pm))?\z,i;
	}
	close(PODIDX)	    or die "Can't close $podidx: $!";
	next;
    }
    print STDERR "Searching for $_\n" if $opt_v;
    # We must look both in @@INC for library modules and in PATH
    # for executables, like h2xs or perldoc itself.
    my @@searchdirs = @@INC;
    if ($opt_F) {
	next unless -r;
	push @@found, $_ if $opt_m or containspod($_);
	next;
    }
    unless ($opt_m) {
	if ($Is_VMS) {
	    my($i,$trn);
	    for ($i = 0; $trn = $ENV{'DCL$PATH;'.$i}; $i++) {
		push(@@searchdirs,$trn);
a327 1
	    push(@@searchdirs,'perl_root:[lib.pod]')  # installed pods
d329 25
a353 28
	else {
	    push(@@searchdirs, grep(-d, split($Config{path_sep},
					     $ENV{'PATH'})));
	}
    }
    my @@files = searchfor(0,$_,@@searchdirs);
    if (@@files) {
	print STDERR "Found as @@files\n" if $opt_v;
    }
    else {
	# no match, try recursive search
	@@searchdirs = grep(!/^\.\z/s,@@INC);
	@@files= searchfor(1,$_,@@searchdirs) if $opt_r;
	if (@@files) {
	    print STDERR "Loosely found as @@files\n" if $opt_v;
	}
	else {
	    print STDERR "No documentation found for \"$_\".\n";
	    if (@@global_found) {
		print STDERR "However, try\n";
		for my $dir (@@global_found) {
		    opendir(DIR, $dir) or die "opendir $dir: $!";
		    while (my $file = readdir(DIR)) {
			next if ($file =~ /^\./s);
			$file =~ s/\.(pm|pod)\z//;  # XXX: badfs
			print STDERR "\tperldoc $_\::$file\n";
		    }
		    closedir DIR    or die "closedir $dir: $!";
a354 1
	    }
d356 1
a356 2
    }
    push(@@found,@@files);
d359 2
a360 2
if (!@@found) {
    exit ($Is_VMS ? 98962 : 1);
d371 1
a371 7
if (! -t STDOUT) { $no_tty = 1 }
END { close(STDOUT) || die "Can't close STDOUT: $!" }

# until here we could simply exit or die
# now we create temporary files that we have to clean up
# namely $tmp, $buffer
# that's because you did it wrong, should be descriptor based --tchrist
a373 1
my $buffer;
d375 21
a395 34
    $tmp = "$ENV{TEMP}\\perldoc1.$$";
    $buffer = "$ENV{TEMP}\\perldoc1.b$$";
    push @@pagers, qw( more< less notepad );
    unshift @@pagers, $ENV{PAGER}  if $ENV{PAGER};
    for (@@found) { s,/,\\,g }
}
elsif ($Is_VMS) {
    $tmp = 'Sys$Scratch:perldoc.tmp1_'.$$;
    $buffer = 'Sys$Scratch:perldoc.tmp1_b'.$$;
    push @@pagers, qw( most more less type/page );
}
elsif ($Is_Dos) {
    $tmp = "$ENV{TEMP}/perldoc1.$$";
    $buffer = "$ENV{TEMP}/perldoc1.b$$";
    $tmp =~ tr!\\/!//!s;
    $buffer =~ tr!\\/!//!s;
    push @@pagers, qw( less.exe more.com< );
    unshift @@pagers, $ENV{PAGER}  if $ENV{PAGER};
}
else {
    if ($^O eq 'os2') {
      require POSIX;
      $tmp = POSIX::tmpnam();
      $buffer = POSIX::tmpnam();
      unshift @@pagers, 'less', 'cmd /c more <';
    }
    else {
      # XXX: this is not secure, because it doesn't open it
      ($tmp, $buffer) = eval { require POSIX } 
	    ? (POSIX::tmpnam(),    POSIX::tmpnam()     )
	    : ("/tmp/perldoc1.$$", "/tmp/perldoc1.b$$" );
    }
    push @@pagers, qw( more less pg view cat );
    unshift @@pagers, $ENV{PAGER}  if $ENV{PAGER};
a398 7
# make sure cleanup called
eval q{
    sub END { cleanup($tmp, $buffer) } 
    1;
} || die;
eval q{ use sigtrap qw(die INT TERM HUP QUIT) };

d400 6
a405 14
    foreach my $pager (@@pagers) {
	if (system($pager, @@found) == 0) {
	    exit;
    }
    }
    if ($Is_VMS) { 
	eval q{
	    use vmsish qw(status exit); 
	    exit $?;
	    1;
	} or die;
    }
    exit(1);
}
a406 1
my @@pod;
d408 5
a412 13
    my $perlfunc = shift @@found;
    open(PFUNC, "<", $perlfunc)
	or die("Can't open $perlfunc: $!");

    # Functions like -r, -e, etc. are listed under `-X'.
    my $search_string = ($opt_f =~ /^-[rwxoRWXOeszfdlpSbctugkTBMAC]$/)
			? 'I<-X' : $opt_f ;

    # Skip introduction
    local $_;
    while (<PFUNC>) {
	last if /^=head2 Alphabetical Listing of Perl Functions/;
    }
d414 39
a452 24
    # Look for our function
    my $found = 0;
    my $inlist = 0;
    while (<PFUNC>) {
	if (/^=item\s+\Q$search_string\E\b/o)  {
	    $found = 1;
	}
	elsif (/^=item/) {
	    last if $found > 1 and not $inlist;
	}
	next unless $found;
	if (/^=over/) {
	    ++$inlist;
	}
	elsif (/^=back/) {
	    --$inlist;
	}
	push @@pod, $_;
	++$found if /^\w/;	# found descriptive text
    }
    if (!@@pod) {
	die "No documentation for perl function `$opt_f' found\n";
    }
    close PFUNC		or die "Can't open $perlfunc: $!";
d456 37
a492 26
    local @@ARGV = @@found;	# I'm lazy, sue me.
    my $found = 0;
    my %found_in;
    my $rx = eval { qr/$opt_q/ } or die <<EOD;
Invalid regular expression '$opt_q' given as -q pattern:
  $@@
Did you mean \\Q$opt_q ?

EOD

    for (@@found) { die "invalid file spec: $!" if /[<>|]/ } 
    local $_;
    while (<>) {
	if (/^=head2\s+.*(?:$opt_q)/oi) {
	    $found = 1;
	    push @@pod, "=head1 Found in $ARGV\n\n" unless $found_in{$ARGV}++;
	}
	elsif (/^=head2/) {
	    $found = 0;
	}
	next unless $found;
	push @@pod, $_;
    }
    if (!@@pod) {
	die("No documentation for perl FAQ keyword `$opt_q' found\n");
    }
d495 1
a495 1
my $filter;
d497 28
a524 9
if (@@pod) {
    sysopen(TMP, $buffer, O_WRONLY | O_EXCL | O_CREAT)
	or die("Can't open $buffer: $!");
    print TMP "=over 8\n\n";
    print TMP @@pod	or die "Can't print $buffer: $!";
    print TMP "=back\n";
    close TMP		or die "Can't close $buffer: $!";
    @@found = $buffer;
    $filter = 1;
d527 8
a534 2
foreach (@@found) {
    printout($_, $tmp, $filter);
a535 1
page($tmp, $no_tty, @@pagers);
d537 1
a537 14
exit;

sub is_tainted {
    my $arg = shift;
    my $nada = substr($arg, 0, 0);  # zero-length
    local $@@;  # preserve caller's version
    eval { eval "# $nada" };
    return length($@@) != 0;
}

sub am_taint_checking {
    my($k,$v) = each %ENV;
    return is_tainted($v);  
}
d539 1
a618 9
=item B<-U> run insecurely

Because B<perldoc> does not run properly tainted, and is known to
have security issues, it will not normally execute as the superuser.
If you use the B<-U> flag, it will do so, but only after setting
the effective and real IDs to nobody's or nouser's account, or -2
if unavailable.  If it cannot relinguish its privileges, it will not
run.  

d623 1
a623 1
give a descriptive name of a page, such as C<perlfunc>. You may also give a
d632 1
a632 1
Any switches in the C<PERLDOC> environment variable will be used before the
a641 6
One useful value for C<PERLDOC_PAGER> is C<less -+C -E>.

=head1 VERSION

This is perldoc v2.01.

d646 1
a646 2
Minor updates by Andy Dougherty <doughera@@lafcol.lafayette.edu>,
and others.
a650 12
# Version 2.02: Mon Mar 13 18:03:04 MST 2000
#       Tom Christiansen <tchrist@@perl.com>
#	Added -U insecurity option
# Version 2.01: Sat Mar 11 15:22:33 MST 2000 
#       Tom Christiansen <tchrist@@perl.com>, querulously.
#       Security and correctness patches.
#       What a twisted bit of distasteful spaghetti code.
# Version 2.0: ????
# Version 1.15: Tue Aug 24 01:50:20 EST 1999
#       Charles Wilson <cwilson@@ece.gatech.edu>
#	changed /pod/ directory to /pods/ for cygwin
#         to support cygwin/win32
d655 1
a655 1
#       Gurusamy Sarathy <gsar@@activestate.com>
d658 1
a658 1
#       Gurusamy Sarathy <gsar@@activestate.com>
d664 1
a664 1
#
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a38 3
(my \$pager = <<'/../') =~ s/\\s*\\z//;
$Config{pager}
/../
d40 1
a40 5
push \@@pagers, \$pager if -x \$pager;

(my \$bindir = <<'/../') =~ s/\\s*\\z//;
$Config{scriptdir}
/../
a50 1
use File::Spec::Functions qw(catfile splitdir);
a81 1
my $Is_OS2 = $^O eq 'os2';
d150 1
a150 1
if (!($Is_VMS || $Is_MSWin32 || $Is_Dos || $Is_OS2) && ($> == 0 || $< == 0)
d204 2
a205 3
    if ($< && $> && -f "blib") {   # don't be looking too hard now!
	eval q{ use blib; 1 };
	warn $@@ if $@@ && $opt_v;
d226 1
a226 1
     my $path = catfile($dir,$file);
d240 2
a241 2
     foreach $p (splitdir $file){
	my $try = catfile @@p, $p;
d246 1
a246 1
		my $tmp_path = catfile @@p;
d305 1
a305 1
    $global_target = (splitdir $s)[-1];   # XXX: why not use File::Basename?
d328 1
a328 1
	    my @@newdirs = map catfile($dir, $_), grep {
d331 1
a331 1
		-d  catfile($dir, $_)
d365 1
a365 1
	my $cmd = catfile($bindir, 'pod2man') . " --lax $file | $opt_n -man";
d409 1
a409 5
          if ($Is_VMS) {
           last if system("$pager $tmp") == 0; # quoting prevents logical expansion
          } else {
	    last if system("$pager \"$tmp\"") == 0;
          }
d428 2
a429 1
	my $searchfor = catfile split '::';
d440 1
a440 1
    # We must look both in @@INC for library modules and in $bindir
d442 1
a442 1
    my @@searchdirs = ($bindir, @@INC);
d556 1
a556 4

# exit/die in a windows sighandler is dangerous, so let it do the
# default thing, which is to exit
eval q{ use sigtrap qw(die INT TERM HUP QUIT) } unless $^O eq 'MSWin32';
d793 1
a793 1
This is perldoc v2.03.
a804 3
# Version 2.03: Sun Apr 23 16:56:34 BST 2000
#	Hugo van der Sanden <hv@@crypt0.demon.co.uk>
#	don't die when 'use blib' fails
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a27 2
my $versiononly = $Config{versiononly} ? $Config{version} : '';

d46 1
a46 5
$Config{scriptdirexp}
/../

(my \$pod2man = <<'/../') =~ s/\\s*\\z//;
pod2man$versiononly
d120 3
a122 2
         `perlfunc') the name of a module, either like `Term::Info' or like
         `Term/Info', or the name of a program, like `perldoc'.
a165 18
	#
	# According to Stevens' APUE and various
	# (BSD, Solaris, HP-UX) man pages setting
	# the real uid first and effective uid second
	# is the way to go if one wants to drop privileges,
	# because if one changes into an effective uid of
	# non-zero, one cannot change the real uid any more.
	#
	# Actually, it gets even messier.  There is
	# a third uid, called the saved uid, and as
	# long as that is zero, one can get back to
	# uid of zero.  Setting the real-effective *twice*
	# helps in *most* systems (FreeBSD and Solaris)
	# but apparently in HP-UX even this doesn't help:
	# the saved uid stays zero (apparently the only way
	# in HP-UX to change saved uid is to call setuid()
	# when the effective uid is zero).
	#
d167 2
a168 4
            $< = $id; # real uid
            $> = $id; # effective uid
            $< = $id; # real uid
            $> = $id; # effective uid
d319 1
a319 1
	if (       (! $opt_m && ( $ret = check_file $dir,"$s.pod"))
d363 44
d418 1
a418 5
        # On VMS, quoting prevents logical expansion, and temp files with no
        # extension get the wrong default extension (such as .LIS for TYPE)

        $tmp = VMS::Filespec::rmsexpand($tmp, '.') if ($Is_VMS);
        foreach my $pager (@@pagers) {
d420 1
a420 1
            last if system("$pager $tmp") == 0;
d428 11
d453 3
a460 3
    # We must look both in @@INC for library modules and in $bindir
    # for executables, like h2xs or perldoc itself.
    my @@searchdirs = ($bindir, @@INC);
d486 1
a486 2
	    print STDERR "No " .
		($opt_m ? "module" : "documentation") . " found for \"$_\".\n";
d519 7
d527 2
d534 2
d539 4
d548 3
d553 6
d564 10
d650 1
a650 1
	elsif (/^=head[12]/) {
a660 4
require File::Temp;

my ($tmpfd, $tmp) = File::Temp::tempfile(UNLINK => 1);

d664 6
a669 5
    my ($buffd, $buffer) = File::Temp::tempfile(UNLINK => 1);
    print $buffd "=over 8\n\n";
    print $buffd @@pod	or die "Can't print $buffer: $!";
    print $buffd "=back\n";
    close $buffd	or die "Can't close $buffer: $!";
d675 1
a675 28
    my $file = $_;
    my $err;

    if ($opt_t) {
	Pod::Text->new()->parse_from_file($file, $tmpfd);
    }
    elsif (not $opt_u) {
	my $cmd = catfile($bindir, $pod2man) . " --lax $file | $opt_n -man";
	$cmd .= " | col -x" if $^O =~ /hpux/;
	my $rslt = `$cmd`;
	$rslt = filter_nroff($rslt) if $filter;
	unless (($err = $?)) {
	    print $tmpfd $rslt
		or die "Can't print $tmp: $!";
	}
    }
    if ($opt_u or $err) {
	open(IN,"<", $file)   or die("Can't open $file: $!");
	my $cut = 1;
	local $_;
	while (<IN>) {
	    $cut = $1 eq 'cut' if /^=(\w+)/;
	    next if $cut;
	    print $tmpfd $_
		or die "Can't print $tmp: $!";
	}
	close IN    or die "Can't close $file: $!";
    }
a676 2
close $tmpfd
    or die "Can't close $tmp: $!";
a719 3
If you are looking for a table of contents to the Perl library modules
documentation, see the L<perltoc> page.

d769 1
a769 1
The B<-X> option looks for an entry whose basename matches the name given on the
d779 1
a779 1
if unavailable.  If it cannot relinquish its privileges, it will not
d786 4
a789 1
give a descriptive name of a page, such as C<perlfunc>.
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@a2 6
# This is for generating the perldoc executable.
# It may eventually be expanded to generate many executables, as
# explained in the preface of /Programming Perl/ 3e.

require 5;
use strict;
d16 1
a16 2

my $origdir = cwd;
d18 1
a18 5
my $file = basename($0, '.PL');
my $file_shortname = $file;  # should be like "perldoc", maybe "perlsyn", etc.
warn "How odd, I'm going to generate $file_shortname?!"
 unless $file_shortname =~ m/^\w+$/;

d23 1
a23 1
print "Extracting \"$file\" (with variable substitutions)\n";
d28 2
d35 5
a39 1
# This "$file" file was generated by "$0"
d41 13
a53 4
require 5;
BEGIN { \$^W = 1 if \$ENV{'PERLDOCDEBUG'} }
use Pod::Perldoc;
exit( Pod::Perldoc->run() );
d57 787
a848 1

@


