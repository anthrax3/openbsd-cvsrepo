head	1.40;
access;
symbols
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.34.0.8
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	PERL_5_20_2:1.1.1.17
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.27.0.6
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.26.0.10
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.8
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.6
	OPENBSD_5_0:1.26.0.4
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.18.0.10
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.8
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.17.0.8
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.14.0.4
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.13.0.6
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.4
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.12.0.6
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.4
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.40
date	2017.03.04.22.02.16;	author afresh1;	state Exp;
branches;
next	1.39;
commitid	B2S59S4502vuferi;

1.39
date	2017.02.05.00.33.38;	author afresh1;	state Exp;
branches;
next	1.38;
commitid	7JLVNm1wwPgqSqTa;

1.38
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.37;
commitid	cxJ08BvJA9Pt2PTM;

1.37
date	2016.09.24.19.47.37;	author afresh1;	state Exp;
branches;
next	1.36;
commitid	J22IA6GBHOLqXqlb;

1.36
date	2016.09.20.18.29.12;	author natano;	state Exp;
branches;
next	1.35;
commitid	hHrIAZKVIofYrkTK;

1.35
date	2016.09.16.08.33.13;	author natano;	state Exp;
branches;
next	1.34;
commitid	HkjBgNvwG65kvS3v;

1.34
date	2015.04.25.19.26.15;	author afresh1;	state Exp;
branches;
next	1.33;
commitid	3qGYFVvfrExB70FB;

1.33
date	2015.04.25.19.14.37;	author afresh1;	state Exp;
branches;
next	1.32;
commitid	XRK22kO4se3v2i2I;

1.32
date	2014.12.24.04.45.44;	author afresh1;	state Exp;
branches;
next	1.31;
commitid	HFUuY33a51tqqPx4;

1.31
date	2014.12.24.03.53.05;	author afresh1;	state Exp;
branches;
next	1.30;
commitid	lYW6uwvn5TzSF3cE;

1.30
date	2014.11.17.21.00.55;	author afresh1;	state Exp;
branches;
next	1.29;
commitid	LnErp1MFKSuew5Fr;

1.29
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.28;
commitid	QP75iYx42Uo7mMxO;

1.28
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.27;

1.27
date	2013.03.25.20.40.44;	author sthen;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.24.15.06.40;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.14.19.08.07;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.13.16.33.47;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.13.10.24.51;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.13.01.25.48;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2008.10.12.19.15.31;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2008.09.29.17.35.57;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.28.19.22.57;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.09.18.08.55;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.07.21.32.59;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.03.03.02.20;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.24.18.34.50;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.06.17.03.58;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.17.07.06.41;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	99.11.23.05.17.20;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.04.29.22.56.02;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.04.29.22.51.00;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.11.30.07.48.39;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.24.21.18.44;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.07.24.21.12.15;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.09.06.17.35.29;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.08.26.14.06.20;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.26.05.31.51;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.40;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.40;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.22;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.37;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.04;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.47;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.30;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.12.49;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.45.41;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.25;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.47.28;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.05;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.35;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.33;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.06.25;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.58.44;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.52.36;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	B31cAbBIXiCqnL97;

1.1.1.17
date	2015.04.25.19.10.09;	author afresh1;	state Exp;
branches;
next	;
commitid	Wpcs5S8qILgEZC7F;


desc
@@


1.40
log
@Better avoid installing versioned perl, makes perlivp happy
@
text
@#!./perl -w

BEGIN {
    chdir '..' if !-d 'lib' and -d '../lib';
    @@INC = 'lib';
    $ENV{PERL5LIB} = 'lib';

    # This needs to be at BEGIN time, before any use of Config
    # install_lib itself loads and imports Config into main::
    require './install_lib.pl';
}

use strict;
use vars qw($Is_VMS $Is_W32 $Is_OS2 $Is_Cygwin $Is_Darwin $Is_NetWare $Is_AmigaOS
	    %opts $packlist);
my $versiononly;

BEGIN {
    if ($Is_VMS) { eval 'use VMS::Filespec;' }
}

# HP-UX (at least) needs to maintain execute permissions
# on dynamically-loadable libraries. So we do it for all.
#
# In AmigaOS, the 0777 means 'rwed' (e = execute, d = delete),
# (not 'rwx') and having the 'd' makes updates more convenient.
my $SO_MODE     = $Is_AmigaOS ? 0777 : 0555;
my $NON_SO_MODE = $Is_AmigaOS ? 0666 : 0444;

my $scr_ext = ($Is_VMS ? '.Com' : $Is_W32 ? '.bat' : '');

use File::Find;
use File::Compare;
use File::Copy ();
use ExtUtils::Packlist;
use Cwd;
# nogetopt_compat to disable treating +v as meaning -v
use Getopt::Long qw(:config nogetopt_compat no_auto_abbrev noignorecase);

require './Porting/pod_lib.pl';

if ($Is_NetWare) {
    $Is_W32 = 0;
    $scr_ext = '.pl';
}

my $mainperldir = "/usr/bin";
my $exe_ext = $Config{exe_ext};

# Allow "make install PERLNAME=something_besides_perl":
my $perl = defined($ENV{PERLNAME}) ? $ENV{PERLNAME} : 'perl';

# This is the base used for versioned names, like "perl5.6.0".
# It's separate because a common use of $PERLNAME is to install
# perl as "perl5", if that's used as base for versioned files you
# get "perl55.6.0".
my $perl_verbase = defined($ENV{PERLNAME_VERBASE})
		    ? $ENV{PERLNAME_VERBASE}
		    : $perl;
my $dbg = '';
my $ndbg = '';
if ( $Is_VMS ) {
    if ( defined $Config{usevmsdebug} ) {
        if ( $Config{usevmsdebug} eq 'define' ) {
            $dbg = 'dbg';
            $ndbg = 'ndbg';
        }
    }
}

# This little hack simplifies making the code after the comment "Fetch some
# frequently-used items from %Config" warning free. With $opts{destdir} always
# defined, it's also possible to make the s/\Q$opts{destdir}\E unconditional.

$opts{destdir} = '';
{
    my $usage = 0;
    if (!GetOptions(\%opts, 'notify|n', 'strip|s', 'silent|S',
                    'skip-otherperls|o', 'force|f', 'verbose|V', 'archname|A',
                    'netware', 'nopods|p', 'destdir:s', 'help|h|?', 'user|u:s',
		    'group|g:s', 'versiononly|v' => \$versiononly, '<>' => sub {
                        if ($_[0] eq '+v') {
                            $versiononly = 0;
                        } else {
                            # Any other unknown argument is going to be an error
                            $usage = 1;
                        }
                    },
                   )) {
        $usage = 1;
    }
    $opts{verbose} ||= $opts{notify};

    if ($usage || $opts{help}) {
        print <<"EOT";
Usage $0: [switches]
  -n	    Don't actually run any commands; just print them.
  -s        Run strip on installed binaries.
  -v        Only install perl as a binary with the version number in the name.
            (Override whatever config.sh says)
  +v        Install perl as "perl" and as a binary with the version number in
            the name.  (Override whatever config.sh says)
  -S        Silent mode.
  -f        Force installation (don't check if same version is there)
  -o        Skip checking for other copies of perl in your PATH.
  -V        Verbose mode.
  -A        Also install perl with the architecture's name in the perl binary's
            name.
  -p        Don't install the pod files. [This will break use diagnostics;]
  -g group  install files with the specified group
  -u user   install files with the specified user 
  -netware  Install correctly on a Netware server.
  -destdir  Prefix installation directories by this string.
  -h        Display this help message.
EOT
        exit $usage;
    }
}
$opts{'uid'} = getpwnam($opts{'user'}) if exists($opts{'user'});
$opts{'gid'} = getgrnam($opts{'group'}) if exists($opts{'group'});

$versiononly = 1 if $Config{versiononly} && !defined $versiononly;
my (@@scripts, @@tolink);
open SCRIPTS, "utils.lst" or die "Can't open utils.lst: $!";
while (<SCRIPTS>) {
    next if /^#/;
    chomp;
    if (/(\S*)\s*#\s*link\s*=\s*(\S*)/) {
	push @@scripts, $1;
	push @@tolink, [$1, $2];
    } else {
	push @@scripts, $_;
    }
}
close SCRIPTS;

if ($scr_ext) { @@scripts = map { "$_$scr_ext" } @@scripts; }

# Specify here any .pm files that are actually architecture-dependent.
# (Those included with XS extensions under ext/ are automatically
# added later.)
# Now that the default privlib has the full perl version number included,
# we no longer have to play the trick of sticking version-specific .pm
# files under the archlib directory.
my %archpms = (
    Config => 1,
    lib => 1,
);

if ($^O eq 'dos') {
    push(@@scripts,'djgpp/fixpmain');
    $archpms{config} = $archpms{filehand} = 1;
}

if ((-e "testcompile") && (defined($ENV{'COMPILE'}))) {
    push(@@scripts, map("$_.exe", @@scripts));
}

# Exclude nonxs extensions that are not architecture dependent
my @@nonxs = grep(!/^(Errno|IO\/Compress)$/, split(' ', $Config{'nonxs_ext'}));

my @@ext_dirs = qw(cpan dist ext);
foreach my $ext_dir (@@ext_dirs) {
    find(sub {
	if (($File::Find::name =~ m{^$ext_dir\b(.*)/([^/]+)\.pm$}) &&
	    ! grep { (my $dir = $_) =~ s/\//-/g;
		     $File::Find::name =~ /^$ext_dir\/$dir\// } @@nonxs)
	{
	    my($path, $modname) = ($1,$2);

	    # Change hyphenated name like Filter-Util-Call to nested
	    # directory name Filter/Util/Call
	    $path =~ s{-}{/}g;

	    # strip to optional "/lib", or remove trailing component
	    $path =~ s{.*/lib\b}{} or $path =~ s{/[^/]*$}{};

	    # strip any leading /
	    $path =~ s{^/}{};

	    # reconstitute canonical module name
	    $modname = "$path/$modname" if length $path;

	    # remember it
	    $archpms{$modname} = 1;
	}
    }, $ext_dir);
}

# print "[$_]\n" for sort keys %archpms;

my $ver = $Config{version};
my $release = substr($],0,3);   # Not used currently.
my $patchlevel = substr($],3,2);
die "Patchlevel of perl ($patchlevel)",
    "and patchlevel of config.sh ($Config{'PERL_VERSION'}) don't match\n"
	if $patchlevel != $Config{'PERL_VERSION'};

# Fetch some frequently-used items from %Config
my $installbin = "$opts{destdir}$Config{installbin}";
my $installscript = "$opts{destdir}$Config{installscript}";
my $installprivlib = "$opts{destdir}$Config{installprivlib}";
my $installarchlib = "$opts{destdir}$Config{installarchlib}";
my $installsitelib = "$opts{destdir}$Config{installsitelib}";
my $installsitearch = "$opts{destdir}$Config{installsitearch}";
my $installman1dir = "none";
my $man1ext = $Config{man1ext};
my $libperl = $Config{libperl};
# Shared library and dynamic loading suffixes.
my $so = $Config{so};
my $dlext = $Config{dlext};
my $dlsrc = $Config{dlsrc};
if ($^O eq 'os390') {
    my $pwd;
    chomp($pwd=`pwd`);
    my $archlibexp = $Config{archlibexp};
    my $usedl = $Config{usedl};
    if ($usedl eq 'define') {
	`./$^X -pibak -e 's{$pwd\/libperl.x}{$archlibexp/CORE/libperl.x}' lib/Config.pm`;
    }
}

if ($opts{netware}) {
    # This is required only if we are installing on a NetWare server
    $installscript = $Config{installnwscripts};
    $installprivlib = $Config{installnwlib};
    $installarchlib = $Config{installnwlib};
    $installsitelib = $Config{installnwlib};
}

my $binexp = $Config{binexp};

if ($Is_VMS) {  # Hang in there until File::Spec hits the big time
    foreach ( \$installbin,     \$installscript,  \$installprivlib,
	      \$installarchlib, \$installsitelib, \$installsitearch,
	      \$installman1dir ) {
	$$_ = unixify($$_);  $$_ =~ s:/$::;
    }
}

# Do some quick sanity checks.

   $installbin		|| die "No installbin directory in config.sh\n";
-d $installbin	        || mkpath($installbin);
-d $installbin		|| $opts{notify} || die "$installbin is not a directory\n";

if (!$Is_NetWare) {
if (!$Is_VMS) {
-x 'perl' . $exe_ext	|| die "perl isn't executable!\n";
}
else {
-x $ndbg . 'perl' . $exe_ext	|| die "${ndbg}perl$exe_ext isn't executable!\n";
    if ($dbg) {
        -x $dbg . 'perl' . $exe_ext	|| die "${dbg}perl$exe_ext isn't executable!\n";
    }
}

#-f 't/rantests'		|| $Is_W32
#			|| warn "WARNING: You've never run 'make test' or",
#				" some tests failed! (Installing anyway.)\n";
} #if (!$Is_NetWare)

# This will be used to store the packlist
$packlist = ExtUtils::Packlist->new("$installarchlib/.packlist");

if (($Is_W32 and ! $Is_NetWare) or $Is_Cygwin) {
    my $perldll;

    if ($Is_Cygwin) {
	$perldll = $libperl;
    } else {
	$perldll = 'perl5'.$Config{patchlevel}.'.'.$so;
    }

    if ($dlsrc ne "dl_none.xs") {
	-f $perldll || die "No perl DLL built\n";
    }

    # Install the DLL
    safe_unlink("$installbin/$perldll");
    copy("$perldll", "$installbin/$perldll");
    chmod(0755, "$installbin/$perldll");
    $packlist->{"$Config{installbin}/$perldll"} = { type => 'file' };
} # if (($Is_W32 and ! $Is_NetWare) or $Is_Cygwin)

# Get the install command and flags from the environment
my @@installcmd = $ENV{"INSTALL"} || "install";
push(@@installcmd, $ENV{"INSTALL_COPY"} || "-c");

# First we install the version-numbered executables.

if ($Is_VMS) {
    safe_unlink("$installbin/perl_setup.com");
    copy("perl_setup.com", "$installbin/perl_setup.com");
    chmod(0755, "$installbin/perl_setup.com");
    safe_unlink("$installbin/$dbg$perl$exe_ext");
    copy("$dbg$perl$exe_ext", "$installbin/$dbg$perl$exe_ext");
    chmod(0755, "$installbin/$dbg$perl$exe_ext");
    safe_unlink("$installbin/$dbg${perl}shr$exe_ext");
    copy("$dbg${perl}shr$exe_ext", "$installbin/$dbg${perl}shr$exe_ext");
    chmod(0755, "$installbin/$dbg${perl}shr$exe_ext");
    if ($ndbg) {
        safe_unlink("$installbin/$ndbg$perl$exe_ext");
        copy("$ndbg$perl$exe_ext", "$installbin/$ndbg$perl$exe_ext");
        chmod(0755, "$installbin/$ndbg$perl$exe_ext");
    }
}
elsif ($^O ne 'dos') {
    if (!$Is_NetWare) {
	my $ver = ''; # don't install a versioned perl binary
	install("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext", "0755");
    }
    else {
	# If installing onto a NetWare server
        if ($opts{netware}) {
	    # Copy perl.nlm, echo.nlm, type.nlm & cgi2perl.nlm
            mkpath($Config{installnwsystem});
	    copy("netware\\".$ENV{'MAKE_TYPE'}."\\perl.nlm", $Config{installnwsystem});
	    copy("netware\\testnlm\\echo\\echo.nlm", $Config{installnwsystem});
	    copy("netware\\testnlm\\type\\type.nlm", $Config{installnwsystem});
	    chmod(0755, "$Config{installnwsystem}\\perl.nlm");
            mkpath($Config{installnwlcgi});
	    copy("lib\\auto\\cgi2perl\\cgi2perl.nlm", $Config{installnwlcgi});
	}
    } #if (!$Is_NetWare)
}
else {
    safe_unlink("$installbin/$perl.exe");
    copy("perl.exe", "$installbin/$perl.exe");
}

# Install library files.

my $do_installarchlib = !samepath($installarchlib, 'lib');
my $do_installprivlib = !samepath($installprivlib, 'lib');
my $vershort = ($Is_Cygwin and !$Config{usedevel}) ? substr($ver,0,-2) : $ver;
$do_installprivlib = 0 if $versiononly && !($installprivlib =~ m/\Q$vershort/);

mkpath($installprivlib);
mkpath($installarchlib);
mkpath($installsitelib, $opts{verbose}, 0777) if ($installsitelib);
mkpath($installsitearch, $opts{verbose}, 0777) if ($installsitearch);

if (-d 'lib') {
    find({no_chdir => 1, wanted => \&installlib}, 'lib')
        if $do_installarchlib || $do_installprivlib;
}
else {
    warn "Can't install lib files - 'lib/' does not exist";
}

# Install header files and libraries.
mkpath("$installarchlib/CORE");
my @@corefiles;
if ($Is_VMS) {  # We did core file selection during build
    my $coredir = "lib/$Config{archname}/$ver/CORE";
    $coredir =~ tr/./_/;
    map { s|^$coredir/||i; } @@corefiles = <$coredir/*.*>;
}
elsif ($Is_Cygwin) { # On Cygwin symlink it to CORE to make Makefile happy
    @@corefiles = <*.h libperl*.* perl*$Config{lib_ext}>;
    my $coredll = "$installarchlib/CORE/$libperl";
    my $instcoredll = "$Config{installarchlib}/CORE/$libperl";
    safe_unlink($coredll);
    ( $Config{'d_link'} eq 'define' &&
      eval {
          CORE::link("$installbin/$libperl", $coredll);
          $packlist->{$instcoredll} = { from => "$Config{installbin}/$libperl",
                                    type => 'link' };
      }
    ) ||
    eval {
        symlink("$installbin/$libperl", $coredll);
        $packlist->{$instcoredll} = { from => "$Config{installbin}/$libperl",
                                  type => 'link' };
    } ||
    ( copy("$installbin/$libperl", $coredll) &&
      push(@@corefiles, $instcoredll)
    )
} elsif ($Is_W32) {
    @@corefiles = <*.h>;
} else {
    # [als] hard-coded 'libperl' name... not good!
    #@@corefiles = <*.h libperl*.* perl*$Config{lib_ext}>;
    @@corefiles = <*.h *.inc perl*$Config{lib_ext}>;
    push(@@corefiles,<libperl*.*>) unless defined($ENV{"NOLIBINSTALL"});

    # AIX needs perl.exp installed as well.
    push(@@corefiles,'perl.exp') if $^O eq 'aix';
}


foreach my $file (@@corefiles) {
    if (copy_if_diff($file,"$installarchlib/CORE/$file")) {
	if ($file =~ /\.(\Q$so\E|\Q$dlext\E)$/) {
	    strip("-S", "$installarchlib/CORE/$file") if $^O eq 'darwin';
	    chmod($SO_MODE, "$installarchlib/CORE/$file");
	} else {
	    chmod($NON_SO_MODE, "$installarchlib/CORE/$file");
	}
    }
}

if ($Is_W32) { #linking lib isn't made in root but in CORE on Win32
    @@corefiles = <lib/CORE/libperl*.* lib/CORE/perl*$Config{lib_ext}>;
    my $dest;
    copy_if_diff($_,($dest = $installarchlib.substr($_,3))) &&
	chmod($NON_SO_MODE, $dest) foreach @@corefiles;
}

# Install main perl executables
# Make links to ordinary names if installbin directory isn't current directory.

if (0) { # don't install a versioned perl binary
#if (! $versiononly && ! samepath($installbin, '.') && ($^O ne 'dos') && ! $Is_VMS && ! $Is_NetWare) {
    safe_unlink("$installbin/$perl$exe_ext", "$installbin/suid$perl$exe_ext");
    if ($^O eq 'vos') {
	# VOS doesn't support hard links, so use a symlink.
	symlink("$installbin/$perl_verbase$ver$exe_ext",
		"$installbin/$perl$exe_ext");
    } else {
	link("$installbin/$perl_verbase$ver$exe_ext",
		"$installbin/$perl$exe_ext");
    }
}

# For development purposes it can be very useful to have multiple perls
# build for different "architectures" (eg threading or not) simultaneously.
if ($opts{archname} && ! samepath($installbin, '.') && ($^O ne 'dos') && ! $Is_VMS) {
    my $archperl = "$perl_verbase$ver-$Config{archname}$exe_ext";
    safe_unlink("$installbin/$archperl");
    if ($^O eq 'vos') {
	# VOS doesn't support hard links, so use a symlink.
	symlink("$installbin/$perl_verbase$ver$exe_ext",
		"$installbin/$archperl");
    } else {
	link("$installbin/$perl_verbase$ver$exe_ext", "$installbin/$archperl");
    }
}

# Offer to install perl in a "standard" location

my $mainperl_is_instperl = 0;

if ($Config{installusrbinperl} && $Config{installusrbinperl} eq 'define' &&
    !$versiononly && !$opts{notify} && !$Is_W32 && !$Is_NetWare && !$Is_VMS && -t STDIN && -t STDERR
	&& -w $mainperldir && ! samepath($mainperldir, $installbin)) {
    my($usrbinperl)	= "$mainperldir/$perl$exe_ext";
    my($instperl)	= "$installbin/$perl$exe_ext";
    my($expinstperl)	= "$binexp/$perl$exe_ext";

    # First make sure $usrbinperl is not already the same as the perl we
    # just installed.
    if (-x $usrbinperl) {
	# Try to be clever about mainperl being a symbolic link
	# to binexp/perl if binexp and installbin are different.
	$mainperl_is_instperl =
	    samepath($usrbinperl, $instperl) ||
	    samepath($usrbinperl, $expinstperl) ||
	     (($binexp ne $installbin) &&
	      (-l $usrbinperl) &&
	      ((readlink $usrbinperl) eq $expinstperl));
    }
    if (! $mainperl_is_instperl) {
	unlink($usrbinperl);
	( $Config{'d_link'} eq 'define' &&
	  eval { CORE::link $instperl, $usrbinperl } )	||
	eval { symlink $expinstperl, $usrbinperl }	||
	copy($instperl, $usrbinperl);

	$mainperl_is_instperl = 1;
    }
}

# cppstdin is just a script, but it is architecture-dependent, so
# it can't safely be shared.  Place it in $installbin.
# Note that Configure doesn't build cppstin if it isn't needed, so
# we skip this if cppstdin doesn't exist.
if (! $versiononly && (-f 'cppstdin') && (! samepath($installbin, '.'))) {
    safe_unlink("$installbin/cppstdin");
    copy("cppstdin", "$installbin/cppstdin");
    chmod(0755, "$installbin/cppstdin");
}

sub script_alias {
    my ($installscript, $orig, $alias, $scr_ext) = @@_;

    safe_unlink("$installscript/$alias$scr_ext");
    if ($^O eq 'dos' or $Is_VMS or $^O eq 'transit') {
	copy("$installscript/$orig$scr_ext",
	     "$installscript/$alias$scr_ext");
    } elsif ($^O eq 'vos') {
	symlink("$installscript/$orig$scr_ext",
		"$installscript/$alias$scr_ext");
    } else {
	link("$installscript/$orig$scr_ext",
	     "$installscript/$alias$scr_ext");
    }
}

# Install scripts.
mkpath($installscript);
if ($versiononly) {
    for (@@scripts) {
	(my $base = $_) =~ s#.*/##;
	$base .= $ver;
	copy($_,    "$installscript/$base");
	chmod(0755, "$installscript/$base");
    }

    for (@@tolink) {
	my ($from, $to) = map { "$_$ver" } @@$_;
	(my $frbase = $from) =~ s#.*/##;
	(my $tobase = $to) =~ s#.*/##;
	script_alias($installscript, $frbase, $tobase, $scr_ext);
    }
} else {
    for (@@scripts) {
	(my $base = $_) =~ s#.*/##;
	copy($_, "$installscript/$base");
	chmod(0755, "$installscript/$base");
	if ($Is_AmigaOS) {
            my $amigapath = unixtoamiga("$installscript/$base");
            amigaprotect($amigapath,"+s");
        }
    }

    for (@@tolink) {
	my ($from, $to) = @@$_;
	(my $frbase = $from) =~ s#.*/##;
	(my $tobase = $to) =~ s#.*/##;
	script_alias($installscript, $frbase, $tobase, $scr_ext);
    }
}

# Install pod pages.  Where? I guess in $installprivlib/pod
# ($installprivlib/pods for cygwin).
if (!$opts{nopods} && (!$versiononly || ($installprivlib =~ m/\Q$vershort/))) {
    my $pod = ($Is_Cygwin || $Is_Darwin || $Is_VMS || $Is_W32) ? 'pods' : 'pod';
    mkpath("${installprivlib}/$pod");

    for (map {$_->[1]} @@{get_pod_metadata()->{master}}) {
	# $_ is a name like  pod/perl.pod
	(my $base = $_) =~ s#.*/##;
	copy_if_diff($_, "${installprivlib}/$pod/${base}");
	chmod(0644, "${installprivlib}/$pod/${base}");
    }

}

# Check to make sure there aren't other perls around in installer's
# path.  This is probably UNIX-specific.  Check all absolute directories
# in the path except for where public executables are supposed to live.
# Also skip $mainperl if the user opted to have it be a link to the
# installed perl.

if (!$versiononly && !$opts{'skip-otherperls'}) {
    my ($path, @@path);
    my $dirsep = ($Is_OS2 || $Is_W32 || $Is_NetWare) ? ';' : ':' ;
    ($path = $ENV{"PATH"}) =~ s:\\:/:g ;
    @@path = split(/$dirsep/, $path);
    if ($Is_VMS) {
	my $i = 0;
	while (exists $ENV{'DCL$PATH' . $i}) {
	    my $dir = unixpath($ENV{'DCL$PATH' . $i});  $dir =~ s-/$--;
	    push(@@path,$dir);
	}
    }
    my @@otherperls;
    my %otherperls;
    for (@@path) {
	next unless m,^/,;
	# Use &samepath here because some systems have other dirs linked
	# to $mainperldir (like SunOS)
	next unless -d;
	next if samepath($_, $binexp);
	next if samepath($_, cwd());
	next if ($mainperl_is_instperl && samepath($_, $mainperldir));
	my $otherperl = "$_/$perl$exe_ext";
	next if $otherperls{$otherperl}++;
	push(@@otherperls, $otherperl)
	    if (-x $otherperl && ! -d $otherperl);
    }
    if (@@otherperls) {
	warn "\nWarning: $perl appears in your path in the following " .
	    "locations beyond where\nwe just installed it:\n";
	for (@@otherperls) {
	    warn "    ", $_, "\n";
	}
	warn "\n";
    }

}

$packlist->write() unless $opts{notify};
if (defined($opts{uid}) || defined($opts{gid})) {
    chown($opts{uid}, $opts{gid}, $packlist->packlist_file());
}
print "  Installation complete\n" if $opts{verbose};

exit 0;

###############################################################################

# If these are needed elsewhere, move them into install_lib.pl rather than
# copying them.

sub yn {
    my($prompt) = @@_;
    my($answer);
    my($default) = $prompt =~ m/\[([yn])\]\s*$/i;
    print STDERR $prompt;
    chop($answer = <STDIN>);
    $answer = $default if $answer =~ m/^\s*$/;
    ($answer =~ m/^[yY]/);
}

sub safe_unlink {
    return if $opts{notify} or $Is_VMS;
    my @@names = @@_;
    foreach my $name (@@names) {
	next unless -e $name;
	chmod 0777, $name if ($Is_OS2 || $Is_W32 || $Is_NetWare);
	print "  unlink $name\n" if $opts{verbose};
	next if CORE::unlink($name);
	warn "Couldn't unlink $name: $!\n";
	if ($! =~ /busy/i) {
	    print "  mv $name $name.old\n" if $opts{verbose};
	    safe_rename($name, "$name.old")
		or warn "Couldn't rename $name: $!\n";
	}
    }
}

sub copy {
    my($from,$to) = @@_;
    my($success) = 0;

    my $xto = $to;
    $xto =~ s/^\Q$opts{destdir}\E//;
    print $opts{verbose} ? "  cp $from $xto\n" : "  $xto\n"
	unless $opts{silent};
    print "  creating new version of $xto\n"
	if $Is_VMS and -e $to and !$opts{silent};
    unless ($opts{notify} or File::Copy::copy($from, $to) and ++$success) {
	# Might have been that F::C::c can't overwrite the target
	warn "Couldn't copy $from to $to: $!\n"
	    unless -f $to and (chmod(0666, $to), unlink $to)
		   and File::Copy::copy($from, $to) and ++$success;
    }
    if (defined($opts{uid}) || defined($opts{gid})) {
	chown($opts{uid}, $opts{gid}, $to) if $success;
    }
    $packlist->{$xto} = { type => 'file' };
}

sub install {
    my($from,$to,$mode) = @@_;

    my $xto = $to;
    my $cmd = join(' ', @@installcmd);
    $cmd .= " -m $mode" if $mode;
    $cmd .= " -o $opts{uid}" if defined($opts{uid});
    $cmd .= " -g $opts{gid}" if defined($opts{gid});
    $cmd .= " -s" if $opts{strip};
    $cmd .= " $from $to";
    $xto =~ s/^\Q$opts{destdir}\E// if $opts{destdir};
    print $opts{verbose} ? "  install $from $xto\n" : "  $xto\n" unless $opts{silent};
    system($cmd);
    warn "Couldn't $cmd\n" if $?;
    $packlist->{$xto} = { type => 'file' };
}

sub installlib {
    my $dir = $File::Find::dir;
    $dir =~ s!\Alib/?!!;

    m!([^/]+)\z!;
    my $name = $1;

    # This remains ugly, and in need of refactoring.

    # $name always starts as the leafname
    # $dir is the directory *within* lib
    # $name later has $dir pre-pended, to give the relative path in lib/
    # which is used to create the path in the target directory.

    # $_ was always the filename to use on disk. Adding no_chdir doesn't change
    # this, as $_ becomes a pathname, and so still works. However, it's not
    # obvious that $_ is needed later, and hence $_ must not be modified.

    # Also, many of the regex exclusion tests below are now superfluous, as the
    # files in question are either no longer in blead, or now in ext/, dist/ or
    # cpan/ and not copied into lib/

    # Ignore version control directories.
    if ($name =~ /^(?:CVS|RCS|SCCS|\.svn)\z/ and -d $name) {
	$File::Find::prune = 1;
	return;
    }

    # If we have different install version, install that instead
    return if -e "$_.install";
    $name =~ s/\.install$//;

    # ignore patch backups, RCS files, emacs backup & temp files and the
    # .exists files, .PL files, and test files.
    return if $name =~ m{\.orig$|\.rej$|~$|^#.+#$|,v$|^\.exists|\.PL$|\.plc$|\.t$|^test\.pl$|^dbm_filter_util\.pl$|^filter-util\.pl$|^uupacktool\.pl$|^\.gitignore$} ||
	      $dir  =~ m{/t(?:/|$)};
    # ignore the cpan script in lib/CPAN/bin, the instmodsh and xsubpp
    # scripts in lib/ExtUtils, the prove script in lib/Test/Harness,
    # the corelist script from lib/Module/CoreList/bin and ptar* in
    # lib/Archive/Tar/bin and zipdetails in cpan/IO-Compress/bin
    # (they're installed later with other utils)
    return if $name =~ /^(?:cpan|instmodsh|prove|corelist|ptar|ptardiff|ptargrep|zipdetails)\z/;
    # ignore the Makefiles
    return if $name =~ /^makefile$/i;
    # ignore the test extensions, dont install PPPort.so/.dll
    return if $dir =~ m{\b(?:XS/(?:APItest|Typemap)|Devel/PPPort)\b};
    return if $name =~ m{\b(?:APItest|Typemap)\.pm$};
    # ignore the build support code
    return if $name =~ /\bbuildcustomize\.pl$/;
    # ignore the demo files
    return if $dir =~ /\b(?:demos?|eg)\b/;
    # ignore unneeded unicore files
    if ( $dir =~ /^unicore/ ) {
      if ( $name =~ /\.txt\z/ ) {
        # We can ignore most, but not all .txt files
        return unless $name =~ /\A(?:Blocks|SpecialCasing|NamedSequences)\.txt\z/;
      }
      else {
        # TestProp only needed during testing
        return if $name =~ /\ATestProp.pl\z/;
        # we need version and *.pl files and can skip the rest
        return unless $name =~ /\A(?:version|\w+\.p[lm])\z/;
      }
    }

    # ignore READMEs, MANIFESTs, INSTALL docs, META.ymls and change logs.
    # Changes.e2x and README.e2x are needed by enc2xs.
    return if $name =~ m{^(?:README(?:\.\w+)?)$} && $name ne 'README.e2x';
    return if $name =~ m{^(?:MANIFEST|META\.yml)$};
    return if $name =~ m{^(?:INSTALL|TODO|BUGS|CREDITS)$}i;
    return if $name =~ m{^change(?:s|log)(?:\.libnet)?$}i;
    return if $name =~ m{^(?:SIGNATURE|PAUSE200\d\.pub)$}; # CPAN files
    return if $name =~ m{^(?:NOTES|PATCHING)$}; # ExtUtils files

    # if using a shared perl library then ignore:
    # - static library files [of statically linked extensions];
    # - import library files and export library files (only present on Win32
    #   anyway?) and empty bootstrap files [of dynamically linked extensions].
    return if $Config{useshrplib} eq 'true' and
             ($name =~ /$Config{_a}$/ or $name =~ /\.exp$/ or ($name =~ /\.bs$/ and -z $name));

    $name = "$dir/$name" if $dir ne '';

    # ignore pods that are stand alone documentation from dual life modules.
    return if /\.pod\z/ && is_duplicate_pod($_);

    return if $name eq 'ExtUtils/XSSymSet.pm' and !$Is_VMS;

    #blead comes with version, blead isn't 5.8/5.6
    return if $name eq 'ExtUtils/MakeMaker/version/regex.pm';

    my $installlib = $installprivlib;
    if ($dir =~ /^auto\// ||
	  ($name =~ /^(.*)\.(?:pm|pod)$/ && $archpms{$1}) ||
	  ($name =~ /^(.*)\.(?:h|lib)$/i && ($Is_W32 || $Is_NetWare)) ||
	  $name=~/^Config_(heavy|git)\.pl\z/
       ) {
	$installlib = $installarchlib;
	return unless $do_installarchlib;
    } else {
	return unless $do_installprivlib;
    }

    if ($Is_NetWare && !$opts{netware} && /\.(?:nlp|nlm|bs)$/) {
        # Don't copy .nlp,.nlm files, doesn't make sense on Windows and also
        # if copied will give problems when building new extensions.
        # Has to be copied if we are installing on a NetWare server and
        # hence the check !$opts{netware}
        return;
    }

    if (-f $_) {
	my $xname = "$installlib/$name";
	$xname =~ s/^\Q$opts{destdir}\E//;
	$packlist->{$xname} = { type => 'file' };
        if ($opts{force} || compare($_, "$installlib/$name") || $opts{notify}) {
	    unlink("$installlib/$name");
	    mkpath("$installlib/$dir");
	    # HP-UX (at least) needs to maintain execute permissions
	    # on dynamically-loaded libraries.
            if (copy_if_diff($_, "$installlib/$name")) {
                strip("-S", "$installlib/$name")
                    if $^O eq 'darwin' and /\.(?:so|$dlext|a)$/;
                chmod(/\.(so|$dlext)$/ ? $SO_MODE : $NON_SO_MODE,
                      "$installlib/$name");
            }
	}
    }
}

# Copy $from to $to, only if $from is different than $to.
# Also preserve modification times for .a libraries.
# On some systems, if you do
#   ranlib libperl.a
#   cp libperl.a /usr/local/lib/perl5/archlib/CORE/libperl.a
# and then try to link against the installed libperl.a, you might
# get an error message to the effect that the symbol table is older
# than the library.
# Return true if copying occurred.

sub copy_if_diff {
    my($from,$to)=@@_;
    return 1 if (($^O eq 'VMS') && (-d $from));
    my $xto = $to;
    $xto =~ s/^\Q$opts{destdir}\E//;
    my $perlpodbadsymlink;
    if ($from =~ m!^pod/perl[\w-]+\.pod$! &&
	-l $from &&
	! -e $from) {
	# Some Linux implementations have problems traversing over
	# multiple symlinks (when going over NFS?) and fail to read
	# the symlink target.  Combine this with the fact that some
	# of the pod files (the perl$OS.pod) are symlinks (to ../README.$OS),
	# and you end up with those pods not getting installed.
	$perlpodbadsymlink = 1;
    }
    -f $from || $perlpodbadsymlink || warn "$0: $from not found";
    $packlist->{$xto} = { type => 'file' };
    if ($opts{force} || compare($from, $to) || $opts{notify}) {
	safe_unlink($to);   # In case we don't have write permissions.
	if ($perlpodbadsymlink && $from =~ m!^pod/perl(.+)\.pod$!) {
	    $from = "README.$1";
	}
	copy($from, $to);
	# Restore timestamps if it's a .a library or for OS/2.
	if (!$opts{notify} && ($Is_OS2 || $to =~ /\.a$/)) {
	    my ($atime, $mtime) = (stat $from)[8,9];
	    utime $atime, $mtime, $to;
	}
	1;
    }
}

sub strip
{
    my(@@args) = @@_;

    return unless $opts{strip};

    my @@opts;
    while (@@args && $args[0] =~ /^(-\w+)$/) {
	push @@opts, shift @@args;
    }

    foreach my $file (@@args) {
	if (-f $file) {
	    if ($opts{verbose}) {
		print "  strip " . join(' ', @@opts);
		print " " if (@@opts);
		print "$file\n";
	    }
	    system("strip", @@opts, $file);
	} else {
	    print "# file '$file' skipped\n" if $opts{verbose};
	}
    }
}

# ex: set ts=8 sts=4 sw=4 et:
@


1.39
log
@Apply local patches - perl-5.24.1
@
text
@d310 1
d414 2
a415 1
if (! $versiononly && ! samepath($installbin, '.') && ($^O ne 'dos') && ! $Is_VMS && ! $Is_NetWare) {
d422 1
a422 1
	safe_rename("$installbin/$perl_verbase$ver$exe_ext",
@


1.38
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@d80 2
a81 2
                    'netware', 'nopods|p', 'destdir:s', 'help|h|?',
                    'versiononly|v' => \$versiononly, '<>' => sub {
d110 2
d119 2
d160 1
a160 1
my @@nonxs = grep(!/^Errno$/, split(' ', $Config{'nonxs_ext'}));
d206 1
a206 1
my $installman1dir = "$opts{destdir}$Config{installman1dir}";
a245 2
-w $installbin		|| $opts{notify} || die "$installbin is not writable by you\n"
	unless $installbin =~ m#^/afs/# || $opts{notify};
d258 3
a260 3
-f 't/rantests'		|| $Is_W32
			|| warn "WARNING: You've never run 'make test' or",
				" some tests failed! (Installing anyway.)\n";
d286 4
d310 1
a310 4
	safe_unlink("$installbin/$perl_verbase$ver$exe_ext");
	copy("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext");
	strip("$installbin/$perl_verbase$ver$exe_ext");
	chmod(0755, "$installbin/$perl_verbase$ver$exe_ext");
d383 3
a385 1
    @@corefiles = <*.h libperl*.* perl*$Config{lib_ext}>;
d420 1
a420 1
	link("$installbin/$perl_verbase$ver$exe_ext",
d594 3
d635 1
d643 1
a643 1
    unless ($opts{notify} or File::Copy::copy($from, $to)) {
d647 1
a647 1
		   and File::Copy::copy($from, $to);
d649 20
d699 4
@


1.37
log
@Build install Config_heavy.pl during build not install

Needed for noperm builds

OK natano@@
@
text
@d14 1
a14 1
use vars qw($Is_VMS $Is_W32 $Is_OS2 $Is_Cygwin $Is_Darwin $Is_NetWare
d22 8
d80 2
a81 2
                    'netware', 'nopods|p', 'destdir:s', 'help|h|?', 'user|u:s',
		    'group|g:s', 'versiononly|v' => \$versiononly, '<>' => sub {
a109 2
  -g group  install files with the specified group
  -u user   install files with the specified user 
a116 2
$opts{'uid'} = getpwnam($opts{'user'}) if exists($opts{'user'});
$opts{'gid'} = getgrnam($opts{'group'}) if exists($opts{'group'});
a122 1
    next if /a2p/; # a2p is binary, to be installed separately
d156 1
a156 1
my @@nonxs = grep(!/^(Errno|IO\/Compress)$/, split(' ', $Config{'nonxs_ext'}));
d202 1
a202 1
my $installman1dir = "none";
d242 2
d256 3
a258 3
#-f 't/rantests'		|| $Is_W32
#			|| warn "WARNING: You've never run 'make test' or",
#				" some tests failed! (Installing anyway.)\n";
a283 4
# Get the install command and flags from the environment
my @@installcmd = $ENV{"INSTALL"} || "install";
push(@@installcmd, $ENV{"INSTALL_COPY"} || "-c");

a299 3
	safe_unlink("$installbin/${dbg}a2p$exe_ext");
	copy("x2p/${dbg}a2p$exe_ext", "$installbin/${dbg}a2p$exe_ext");
	chmod(0755, "$installbin/${dbg}a2p$exe_ext");
d304 4
a307 1
	install("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext", "0755");
d312 1
a312 1
	    # Copy perl.nlm, echo.nlm, type.nlm, a2p.nlm & cgi2perl.nlm
a316 1
	    copy("x2p\\a2p.nlm", $Config{installnwsystem});
d376 2
d380 1
a380 3
    #@@corefiles = <*.h libperl*.* perl*$Config{lib_ext}>;
    @@corefiles = <*.h *.inc perl*$Config{lib_ext}>;
    push(@@corefiles,<libperl*.*>) unless defined($ENV{"NOLIBINSTALL"});
d385 2
a387 2
    # HP-UX (at least) needs to maintain execute permissions
    # on dynamically-loadable libraries. So we do it for all.
d391 1
a391 1
	    chmod(0555, "$installarchlib/CORE/$file");
d393 1
a393 1
	    chmod(0444, "$installarchlib/CORE/$file");
d398 7
a467 15
# Make links to ordinary names if installbin directory isn't current directory.
if (!$Is_NetWare && $dbg eq '') {
    if (! samepath($installbin, 'x2p')) {
	my $base = 'a2p';
	$base .= $ver if $versiononly;
	safe_unlink("$installbin/$base$exe_ext");
	copy("x2p/a2p$exe_ext", "$installbin/$base$exe_ext");
	strip("$installbin/$base$exe_ext");
	if (defined($opts{uid}) || defined($opts{gid})) {
	    chown($opts{uid}, $opts{gid}, "$installbin/$base$exe_ext");
	}
	chmod(0755, "$installbin/$base$exe_ext");
    }
}

d515 4
a588 3
if (defined($opts{uid}) || defined($opts{gid})) {
    chown($opts{uid}, $opts{gid}, $packlist->packlist_file());
}
a626 1
    my($success) = 0;
d634 1
a634 1
    unless ($opts{notify} or File::Copy::copy($from, $to) and ++$success) {
d638 1
a638 1
		   and File::Copy::copy($from, $to) and ++$success;
a639 20
    if (defined($opts{uid}) || defined($opts{gid})) {
	chown($opts{uid}, $opts{gid}, $to) if $success;
    }
    $packlist->{$xto} = { type => 'file' };
}

sub install {
    my($from,$to,$mode) = @@_;

    my $xto = $to;
    my $cmd = join(' ', @@installcmd);
    $cmd .= " -m $mode" if $mode;
    $cmd .= " -o $opts{uid}" if defined($opts{uid});
    $cmd .= " -g $opts{gid}" if defined($opts{gid});
    $cmd .= " -s" if $opts{strip};
    $cmd .= " $from $to";
    $xto =~ s/^\Q$opts{destdir}\E// if $opts{destdir};
    print $opts{verbose} ? "  install $from $xto\n" : "  $xto\n" unless $opts{silent};
    system($cmd);
    warn "Couldn't $cmd\n" if $?;
a670 4
    # If we have different install version, install that instead
    return if -e "$_.install";
    $name =~ s/\.install$//;

d678 1
a678 2
    # lib/Archive/Tar/bin, the config_data script in lib/Module/Build/scripts
    # and zipdetails in cpan/IO-Compress/bin
d680 1
a680 1
    return if $name =~ /^(?:cpan|instmodsh|prove|corelist|ptar|ptardiff|ptargrep|config_data|zipdetails)\z/;
d683 2
a684 2
    # ignore the test extensions
    return if $dir =~ m{\bXS/(?:APItest|Typemap)\b};
d727 3
d762 2
a763 1
                chmod(/\.(so|$dlext)$/ ? 0555 : 0444, "$installlib/$name");
a836 5
# Local variables:
# cperl-indent-level: 4
# indent-tabs-mode: nil
# End:
#
@


1.36
log
@Set correct owner for installed files. One step closer to noperm
builds.

initial diff and ok millert
@
text
@d699 4
a769 13
    }

    if ($name eq 'Config_heavy.pl') {
        open my $ifh, '<', $_ or die $!;
        $_ = "$_.orig";
        open my $ofh, '>', $_ or die $!;
        while (my $l = <$ifh>) {
            $l =~ s,^(ccflags|cppflags)[^=]*='[^']+,$& -I/usr/local/include,;
            $l =~ s,^(ldflags|lddlflags)[^=]*='[^']+,$& -L/usr/local/lib,;
            print $ofh $l;
        }
        close $ifh;
        close $ofh;
@


1.35
log
@Don't check if target directory is writeable. This gets in the way of
noperm builds.

ok deraadt some time ago
@
text
@d72 2
a73 2
                    'netware', 'nopods|p', 'destdir:s', 'help|h|?',
                    'versiononly|v' => \$versiononly, '<>' => sub {
d102 2
d111 2
d469 3
d593 3
d634 1
d642 1
a642 1
    unless ($opts{notify} or File::Copy::copy($from, $to)) {
d646 4
a649 1
		   and File::Copy::copy($from, $to);
d660 2
@


1.34
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@a234 2
-w $installbin		|| $opts{notify} || die "$installbin is not writable by you\n"
	unless $installbin =~ m#^/afs/# || $opts{notify};
@


1.33
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d149 1
a149 1
my @@nonxs = grep(!/^Errno$/, split(' ', $Config{'nonxs_ext'}));
d195 1
a195 1
my $installman1dir = "$opts{destdir}$Config{installman1dir}";
d249 3
a251 3
-f 't/rantests'		|| $Is_W32
			|| warn "WARNING: You've never run 'make test' or",
				" some tests failed! (Installing anyway.)\n";
d277 4
d304 1
a304 4
	safe_unlink("$installbin/$perl_verbase$ver$exe_ext");
	copy("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext");
	strip("$installbin/$perl_verbase$ver$exe_ext");
	chmod(0755, "$installbin/$perl_verbase$ver$exe_ext");
d376 3
a378 1
    @@corefiles = <*.h libperl*.* perl*$Config{lib_ext}>;
d642 15
d752 13
@


1.32
log
@Use an extension that installperl skips for the Config_heavy modifications
@
text
@d149 1
a149 1
my @@nonxs = grep(!/^(Errno|IO\/Compress)$/, split(' ', $Config{'nonxs_ext'}));
d195 1
a195 1
my $installman1dir = "none";
d249 3
a251 3
#-f 't/rantests'		|| $Is_W32
#			|| warn "WARNING: You've never run 'make test' or",
#				" some tests failed! (Installing anyway.)\n";
d263 1
a263 1
	$perldll = 'perl5'.$Config{patchlevel}.'.'.$dlext;
a276 4
# Get the install command and flags from the environment
my @@installcmd = $ENV{"INSTALL"} || "install";
push(@@installcmd, $ENV{"INSTALL_COPY"} || "-c");

d300 4
a303 1
	install("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext", "0755");
d375 1
a375 3
    #@@corefiles = <*.h libperl*.* perl*$Config{lib_ext}>;
    @@corefiles = <*.h *.inc perl*$Config{lib_ext}>;
    push(@@corefiles,<libperl*.*>) unless defined($ENV{"NOLIBINSTALL"});
a638 15
sub install {
    my($from,$to,$mode) = @@_;

    my $xto = $to;
    my $cmd = join(' ', @@installcmd);
    $cmd .= " -m $mode" if $mode;
    $cmd .= " -s" if $opts{strip};
    $cmd .= " $from $to";
    $xto =~ s/^\Q$opts{destdir}\E// if $opts{destdir};
    print $opts{verbose} ? "  install $from $xto\n" : "  $xto\n" unless $opts{silent};
    system($cmd);
    warn "Couldn't $cmd\n" if $?;
    $packlist->{$xto} = { type => 'file' };
}

a733 13
    }

    if ($name eq 'Config_heavy.pl') {
        open my $ifh, '<', $_ or die $!;
        $_ = "$_.orig";
        open my $ofh, '>', $_ or die $!;
        while (my $l = <$ifh>) {
            $l =~ s,^(ccflags|cppflags)[^=]*='[^']+,$& -I/usr/local/include,;
            $l =~ s,^(ldflags|lddlflags)[^=]*='[^']+,$& -L/usr/local/lib,;
            print $ofh $l;
        }
        close $ifh;
        close $ofh;
@


1.31
log
@Avoid /usr/local while building perl, but allow it for ports

commit it deraadt@@
@
text
@d756 1
a756 1
        $_ = "$_.local";
@


1.30
log
@Apply local patches to perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d754 13
@


1.29
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d149 1
a149 1
my @@nonxs = grep(!/^Errno$/, split(' ', $Config{'nonxs_ext'}));
d195 1
a195 1
my $installman1dir = "$opts{destdir}$Config{installman1dir}";
d249 3
a251 3
-f 't/rantests'		|| $Is_W32
			|| warn "WARNING: You've never run 'make test' or",
				" some tests failed! (Installing anyway.)\n";
d277 4
d304 1
a304 4
	safe_unlink("$installbin/$perl_verbase$ver$exe_ext");
	copy("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext");
	strip("$installbin/$perl_verbase$ver$exe_ext");
	chmod(0755, "$installbin/$perl_verbase$ver$exe_ext");
d376 3
a378 1
    @@corefiles = <*.h libperl*.* perl*$Config{lib_ext}>;
d639 15
@


1.28
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a3 1
    require 5.004;
d9 1
d16 1
a16 2
my ($dostrip, $versiononly, $force,
    $otherperls, $archname, $nwinstall, $nopods);
a26 1
use File::Path ();
d29 2
a38 5
# override the ones in the rest of the script
sub mkpath {
    File::Path::mkpath(@@_) unless $opts{notify};
}

a62 1
$otherperls = 1;
d68 20
a87 17
# Consider refactoring this to use Getopt::Long once Getopt::Long's planned
# feature is implemented, to distinguish + and - options.
while (@@ARGV) {
    $opts{notify} = 1 if $ARGV[0] eq '-n';
    $dostrip = 1 if $ARGV[0] eq '-s';
    $versiononly = 1 if $ARGV[0] eq '-v';
    $versiononly = 0 if $ARGV[0] eq '+v';
    $opts{silent} = 1 if $ARGV[0] eq '-S';
    $otherperls = 0 if $ARGV[0] eq '-o';
    $force = 1 if $ARGV[0] eq '-f';
    $opts{verbose} = 1 if $ARGV[0] eq '-V' || $ARGV [0] eq '-n';
    $archname = 1 if $ARGV[0] eq '-A';
    $nwinstall = 1 if $ARGV[0] eq '-netware';
    $nopods = 1 if $ARGV[0] eq '-p';
    $opts{destdir} = $1 if $ARGV[0] =~ /^-?-destdir=(.*)$/;
    if ($ARGV[0] eq '-?' or $ARGV[0] =~ /^-?-h/) {
	print <<"EOT";
d104 1
d106 1
a106 1
	exit;
a107 1
    shift;
a136 1
    Cwd => 1,
d149 1
a149 1
my @@nonxs = grep(!/^(Errno|IO\/Compress)$/, split(' ', $Config{'nonxs_ext'}));
d195 1
a195 1
my $installman1dir = "none";
d212 1
a212 1
if ($nwinstall) {
d233 1
a233 1
-d $installbin		|| mkpath($installbin, $opts{verbose}, 0777);
d249 3
a251 3
#-f 't/rantests'		|| $Is_W32
#			|| warn "WARNING: You've never run 'make test' or",
#				" some tests failed! (Installing anyway.)\n";
d274 1
a274 1
    $packlist->{"$installbin/$perldll"} = { type => 'file' };
a276 4
# Get the install command and flags from the environment
my @@installcmd = $ENV{"INSTALL"} || "install";
push(@@installcmd, $ENV{"INSTALL_COPY"} || "-c");

d300 4
a303 2
	install("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext",
	    "0755", $dostrip);
d307 1
a307 1
	if ($nwinstall) {
d309 1
a309 1
            mkpath($Config{installnwsystem}, $opts{verbose}, 0777);
d315 1
a315 1
            mkpath($Config{installnwlcgi}, $opts{verbose}, 0777);
d332 2
a333 2
mkpath($installprivlib, $opts{verbose}, 0777);
mkpath($installarchlib, $opts{verbose}, 0777);
d346 1
a346 1
mkpath("$installarchlib/CORE", $opts{verbose}, 0777);
d356 1
d361 1
a361 1
          $packlist->{$coredll} = { from => "$installbin/$libperl",
d367 1
a367 1
        $packlist->{$coredll} = { from => "$installbin/$libperl",
d371 1
a371 1
      push(@@corefiles, $coredll)
d375 1
a375 3
    #@@corefiles = <*.h libperl*.* perl*$Config{lib_ext}>;
    @@corefiles = <*.h *.inc perl*$Config{lib_ext}>;
    push(@@corefiles,<libperl*.*>) unless defined($ENV{"NOLIBINSTALL"});
d410 1
a410 1
if ($archname && ! samepath($installbin, '.') && ($^O ne 'dos') && ! $Is_VMS) {
d495 1
a495 1
mkpath($installscript, $opts{verbose}, 0777);
d527 1
a527 1
if (!$nopods && (!$versiononly || ($installprivlib =~ m/\Q$vershort/))) {
d529 1
a529 1
    mkpath("${installprivlib}/$pod", $opts{verbose}, 0777);
d546 1
a546 1
if (!$versiononly && $otherperls) {
a620 14
sub safe_rename {
    my($from,$to) = @@_;
    if (-f $to and not unlink($to)) {
	my($i);
	for ($i = 1; $i < 50; $i++) {
	    last if rename($to, "$to.$i");
	}
	warn("Cannot rename to '$to.$i': $!"), return 0
	   if $i >= 50;	# Give up!
    }
    link($from,$to) || return 0;
    unlink($from);
}

a638 15
sub install {
    my($from,$to,$mode,$strip) = @@_;

    my $xto = $to;
    my $cmd = join(' ', @@installcmd);
    $cmd .= " -m $mode" if $mode;
    $cmd .= " -s" if $strip;
    $cmd .= " $from $to";
    $xto =~ s/^\Q$opts{destdir}\E// if $opts{destdir};
    print $opts{verbose} ? "  install $from $xto\n" : "  $xto\n" unless $opts{silent};
    system($cmd);
    warn "Couldn't $cmd\n" if $?;
    $packlist->{$xto} = { type => 'file' };
}

d657 1
a657 1
    # Also, many of the regex exlusion tests below are now superfluous, as the
d677 1
a677 1
    return if $name =~ /^(?:cpan|instmodsh|prove|corelist|ptar|cpan2dist|cpanp|cpanp-run-perl|ptardiff|ptargrep|config_data|zipdetails)\z/;
d736 1
a736 1
    if ($Is_NetWare && !$nwinstall && /\.(?:nlp|nlm|bs)$/) {
d740 1
a740 1
        # hence the check !$nwinstall
a744 8
	if (/\.(?:al|ix)$/ && !($dir =~ m[^auto/(.*)$])) {
	    $installlib = $installprivlib;
	    #We're installing *.al and *.ix files into $installprivlib,
	    #but we have to delete old *.al and *.ix files from the 5.000
	    #distribution:
	    #This might not work because $archname might have changed.
	    unlink("$installarchlib/$name");
	}
d748 1
a748 1
	if ($force || compare($_, "$installlib/$name") || $opts{notify}) {
d750 1
a750 1
	    mkpath("$installlib/$dir", $opts{verbose}, 0777);
d790 1
a790 1
    if ($force || compare($from, $to) || $opts{notify}) {
d809 1
a809 1
    return unless $dostrip;
@


1.27
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@a305 10
elsif ($^O eq 'mpeix') {
    # MPE lacks hard links and requires that executables with special
    # capabilities reside in the MPE namespace.
    safe_unlink("$installbin/perl$ver$exe_ext", $Config{perlpath});
    # Install the primary executable into the MPE namespace as perlpath.
    copy("perl$exe_ext", $Config{perlpath});
    chmod(0755, $Config{perlpath});
    # Create a backup copy with the version number.
    link($Config{perlpath}, "$installbin/perl$ver$exe_ext");
}
a385 5
    if ($^O eq 'mpeix') {
	# MPE needs mpeixish.h installed as well.
	mkpath("$installarchlib/CORE/mpeix", $opts{verbose}, 0777);
	push(@@corefiles,'mpeix/mpeixish.h');
    }
d392 1
a392 1
	    strip("-S", "$installarchlib/CORE/$file") if $^O =~ /^(rhapsody|darwin)$/;
d405 1
a405 5
    if ($^O eq 'mpeix') {
	# MPE doesn't support hard links, so use a symlink.
	# We don't want another cloned copy.
	symlink($Config{perlpath}, "$installbin/perl$exe_ext");
    } elsif ($^O eq 'vos') {
d420 1
a420 5
    if ($^O eq 'mpeix') {
	# MPE doesn't support hard links, so use a symlink.
	# We don't want another cloned copy.
	symlink($Config{perlpath}, "$installbin/$archperl");
    } elsif ($^O eq 'vos') {
d727 1
a727 1
        return unless $name =~ /\A(?:Blocks|CaseFolding|SpecialCasing|NamedSequences)\.txt\z/;
d799 1
a799 1
                    if $^O =~ /^(rhapsody|darwin)$/ and /\.(?:so|$dlext|a)$/;
@


1.26
log
@merge in perl 5.12.2 plus local changes
@
text
@a17 3
# Not sure how easy it would be to refactor to remove the need for local $depth
# below
use vars qw /$depth/;
d32 2
a117 1
    s/\s*#\s*pod\s*=.*//; # install script regardless of pod location
a130 2
my @@pods = $nopods ? () : (<pod/*.pod>, 'x2p/a2p.pod');

d164 1
a164 1
	    # Change hypenated name like Filter-Util-Call to nested
d325 1
a325 1
	    mkpath($Config{installnwsystem}, 1, 0777);
d331 1
a331 1
	    mkpath($Config{installnwlcgi}, 1, 0777);
d343 2
a344 1
my ($do_installarchlib, $do_installprivlib) = (0, 0);
d346 1
d353 3
a355 9
if (chdir "lib") {
    $do_installarchlib = ! samepath($installarchlib, '.');
    $do_installprivlib = ! samepath($installprivlib, '.');
    $do_installprivlib = 0 if $versiononly && !($installprivlib =~ m/\Q$vershort/);

    if ($do_installarchlib || $do_installprivlib) {
	find(\&installlib, '.');
    }
    chdir ".." || die "Can't cd back to source directory: $!\n";
d358 1
a358 1
    warn "Can't cd to lib to install lib files: $!\n";
a400 2
    # If they have built sperl.o...
    push(@@corefiles,'sperl.o') if -f 'sperl.o';
d557 2
a558 3

my $pod = ($Is_Cygwin || $Is_Darwin || $Is_VMS || $Is_W32) ? 'pods' : 'pod';
if ( !$versiononly || ($installprivlib =~ m/\Q$vershort/)) {
d561 1
a561 1
    for (@@pods) {
d565 1
d658 1
a658 1
	warn("Cannot rename to `$to.$i': $!"), return 0
d700 15
a714 2
    $dir =~ s#^\.(?![^/])/?##;
    local($depth) = $dir ? "lib/$dir" : "lib";
d716 3
a718 1
    my $name = $_;
d734 1
d736 1
a736 1
    return if $name =~ /^(?:cpan|instmodsh|prove|corelist|ptar|cpan2dist|cpanp|cpanp-run-perl|ptardiff|config_data)\z/;
d742 2
d746 13
d778 3
d795 8
d820 5
a824 22
	    if ($Is_NetWare && !$nwinstall) {
		# Don't copy .nlp,.nlm files, doesn't make sense on Windows and also
		# if copied will give problems when building new extensions.
		# Has to be copied if we are installing on a NetWare server and hence
		# the check !$nwinstall
		if (!(/\.(?:nlp|nlm|bs)$/)) {
		    copy_if_diff($_, "$installlib/$name")
			and chmod($name =~ /\.(so|$dlext)$/o ? 0555 : 0444,
				  "$installlib/$name");
		}
	   } else {
		if (copy_if_diff($_, "$installlib/$name")) {
		    if ($name =~ /\.(so|$dlext)$/o) {
			strip("-S", "$installlib/$name") if $^O =~ /^(rhapsody|darwin)$/;
			chmod(0555, "$installlib/$name");
		    } else {
			strip("-S", "$installlib/$name")
			    if ($name =~ /\.a$/o and $^O =~ /^(rhapsody|darwin)$/);
			chmod(0444, "$installlib/$name");
		    }
		}
	    } #if ($Is_NetWare)
a858 3
	if ($opts{notify}) {
	    $from = $depth . "/" . $from if $depth;
	}
d896 7
@


1.25
log
@Better fix for treating IO-Compress as an extension that the one in 5.10.1,
http://perl5.git.perl.org/perl.git/commit/4cc80fc4cbbd82e20f7b14b6
Should fix static architectures like vax.
@
text
@d159 15
a173 16
find(sub {
    if (($File::Find::name =~ m{^ext\b(.*)/([^/]+)\.pm$}) &&
        ! grep { (my $dir = $_) =~ s/\//-/g;
                 $File::Find::name =~ /^ext\/$dir/ } @@nonxs)
    {
	my($path, $modname) = ($1,$2);

	# Change hypenated name like Filter-Util-Call to nested
	# directory name Filter/Util/Call
	$path =~ s{-}{/}g;

	# strip to optional "/lib", or remove trailing component
	$path =~ s{.*/lib\b}{} or $path =~ s{/[^/]*$}{};

	# strip any leading /
	$path =~ s{^/}{};
d175 2
a176 2
	# reconstitute canonical module name
	$modname = "$path/$modname" if length $path;
d178 8
a185 4
	# remember it
	$archpms{$modname} = 1;
    }
}, 'ext');
a227 1
my $d_dosuid = $Config{d_dosuid};
a239 2
if (!$opts{notify} && $d_dosuid && $>) { die "You must run as root to install suidperl\n"; }

a255 1
-x 'suidperl' . $exe_ext|| die "suidperl isn't executable!\n" if $d_dosuid;
a344 6
safe_unlink("$installbin/s$perl_verbase$ver$exe_ext");
if ($d_dosuid) {
    install("perl$exe_ext", "$installbin/s$perl_verbase$ver$exe_ext",
	"04711", $dostrip);
}

a441 3
    link("$installbin/$perl_verbase$ver$exe_ext",
	    "$installbin/suid$perl$exe_ext")
      if $d_dosuid;
a571 15
    # If Perl 5.003's perldiag.pod is there, rename it.
    if (open POD, "${installprivlib}/$pod/perldiag.pod") {
	read POD, $_, 4000;
	close POD;
	# Some of Perl 5.003's diagnostic messages ended with periods.
	if (/^=.*\.$/m) {
	    my ($from, $to) = ("${installprivlib}/$pod/perldiag.pod",
			       "${installprivlib}/$pod/perldiag-5.003.pod");
	    print "  rename $from $to";
	    rename($from, $to)
		or warn "Couldn't rename $from to $to: $!\n"
		unless $opts{notify};
	}
    }

d723 1
a723 1
    return if $name =~ m{\.orig$|\.rej$|~$|^#.+#$|,v$|^\.exists|\.PL$|\.plc$|\.t$|^test\.pl$|^dbm_filter_util.pl$} ||
@


1.24
log
@Add back bits mistakenly removed in rev 1.23
@
text
@d157 1
a157 1
my @@nonxs = grep(!/^Errno$/, split(' ', $Config{'nonxs_ext'}));
@


1.23
log
@Fix mismerge
@
text
@d728 2
@


1.22
log
@Merge in some local changes that got lost.
@
text
@d726 2
a727 6
    $xto =~ s/^\Q$destdir\E// if $destdir;
    print $verbose ? "  install $from $xto\n" : "  $xto\n" unless $silent;
    unless ($nonono) {
       system($cmd);
       warn "Couldn't $cmd\n" if $?;
    }
@


1.21
log
@Merge in perl 5.10.1
@
text
@d200 1
a200 1
my $installman1dir = "$opts{destdir}$Config{installman1dir}";
d258 3
a260 3
-f 't/rantests'		|| $Is_W32
			|| warn "WARNING: You've never run 'make test' or",
				" some tests failed! (Installing anyway.)\n";
d286 4
d323 2
a324 4
	safe_unlink("$installbin/$perl_verbase$ver$exe_ext");
	copy("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext");
	strip("$installbin/$perl_verbase$ver$exe_ext");
	chmod(0755, "$installbin/$perl_verbase$ver$exe_ext");
d348 2
a349 2
    copy("suidperl$exe_ext", "$installbin/s$perl_verbase$ver$exe_ext");
    chmod(04711, "$installbin/s$perl_verbase$ver$exe_ext");
d405 3
a407 1
    @@corefiles = <*.h libperl*.* perl*$Config{lib_ext}>;
d714 17
@


1.20
log
@Remove hack from MM_Unix.pm and simply set man1dir to 'none' in
installperl to prevent man page installation of the perl man pages.
@
text
@d1 1
a1 1
#!./perl
a7 1
}
d9 2
a10 23
BEGIN {
    use Config;
    if ($Config{userelocatableinc}) {
	# This might be a considered a hack. Need to get information about the
	# configuration from Config.pm *before* Config.pm expands any .../
	# prefixes.
	#
	# So we set $^X to pretend that we're the already installed perl, so
	# Config.pm doesits ... expansion off that location.

	my $location = $Config{initialinstalllocation};
	die <<'OS' unless defined $location;
$Config{initialinstalllocation} is not defined - can't install a relocatable
perl without this.
OS
	$^X = "$location/perl";
	# And then remove all trace of ever having loaded Config.pm, so that
	# it will reload with the revised $^X
	undef %Config::;
	delete $INC{"Config.pm"};
	delete $INC{"Config_heavy.pl"};
	# You never saw us. We weren't here.
    }
d14 6
a19 3
my ($Is_VMS, $Is_W32, $Is_OS2, $Is_Cygwin, $Is_Darwin,
    $nonono, $dostrip, $versiononly, $silent, $verbose, $force,
    $otherperls, $archname, $Is_NetWare, $nwinstall, $nopods);
a22 5
    $Is_VMS = $^O eq 'VMS';
    $Is_W32 = $^O eq 'MSWin32';
    $Is_OS2 = $^O eq 'os2';
    $Is_Cygwin = $^O eq 'cygwin';
    $Is_Darwin = $^O eq 'darwin';
d33 1
a33 6
use Config;
use subs qw(unlink link chmod);

if ($Config{d_umask}) {
    umask(022); # umasks like 077 aren't that useful for installations
}
a34 1
$Is_NetWare = $Config{osname} eq 'NetWare';
d42 1
a42 1
    File::Path::mkpath(@@_) unless $nonono;
d48 1
a48 1
# Allow ``make install PERLNAME=something_besides_perl'':
d70 7
a76 1
my $destdir = '';
d78 1
a78 1
    $nonono = 1 if $ARGV[0] eq '-n';
d82 1
a82 1
    $silent = 1 if $ARGV[0] eq '-S';
d85 1
a85 1
    $verbose = 1 if $ARGV[0] eq '-V' || $ARGV [0] eq '-n';
d89 1
a89 1
    $destdir = $1 if $ARGV[0] =~ /^-?-destdir=(.*)$/;
d156 3
d160 4
a163 1
    if ("$File::Find::dir/$_" =~ m{^ext\b(.*)/([^/]+)\.pm$}) {
d166 4
d194 7
a200 7
my $installbin = "$destdir$Config{installbin}";
my $installscript = "$destdir$Config{installscript}";
my $installprivlib = "$destdir$Config{installprivlib}";
my $installarchlib = "$destdir$Config{installarchlib}";
my $installsitelib = "$destdir$Config{installsitelib}";
my $installsitearch = "$destdir$Config{installsitearch}";
my $installman1dir = "none";
d238 1
a238 1
if (!$nonono && $d_dosuid && $>) { die "You must run as root to install suidperl\n"; }
d241 4
a244 4
-d $installbin		|| mkpath($installbin, $verbose, 0777);
-d $installbin		|| $nonono || die "$installbin is not a directory\n";
-w $installbin		|| $nonono || die "$installbin is not writable by you\n"
	unless $installbin =~ m#^/afs/# || $nonono;
d258 3
a260 3
#-f 't/rantests'		|| $Is_W32
#			|| warn "WARNING: You've never run 'make test' or",
#				" some tests failed! (Installing anyway.)\n";
d264 1
a264 1
my $packlist = ExtUtils::Packlist->new("$installarchlib/.packlist");
a270 3
	my $v_e_r_s = $ver; $v_e_r_s =~ tr/./_/;
	$perldll =~ s/(\..*)?$/$v_e_r_s.$dlext/;
	$perldll =~ s/^lib/cyg/;
d272 1
a272 1
	$perldll = 'perl510.' . $dlext;
a285 4
# Get the install command and flags from the environment
my @@installcmd = $ENV{"INSTALL"} || "install";
push(@@installcmd, $ENV{"INSTALL_COPY"} || "-c");

d319 4
a322 2
	install("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext",
	    "0755", $dostrip);
d346 2
a347 2
    install("perl$exe_ext", "$installbin/s$perl_verbase$ver$exe_ext",
	"04711", $dostrip);
d353 1
d355 4
a358 4
mkpath($installprivlib, $verbose, 0777);
mkpath($installarchlib, $verbose, 0777);
mkpath($installsitelib, $verbose, 0777) if ($installsitelib);
mkpath($installsitearch, $verbose, 0777) if ($installsitearch);
d363 1
a363 1
    $do_installprivlib = 0 if $versiononly && !($installprivlib =~ m/\Q$ver/);
d375 1
a375 1
mkpath("$installarchlib/CORE", $verbose, 0777);
d382 20
a401 1
else {
d403 1
a403 3
    #@@corefiles = <*.h libperl*.* perl*$Config{lib_ext}>;
    @@corefiles = <*.h *.inc perl*$Config{lib_ext}>;
    push(@@corefiles,<libperl*.*>) unless defined($ENV{"NOLIBINSTALL"});
d409 1
a409 1
	mkpath("$installarchlib/CORE/mpeix", $verbose, 0777);
d473 1
a473 1
    !$versiononly && !$nonono && !$Is_W32 && !$Is_NetWare && !$Is_VMS && -t STDIN && -t STDERR
d541 1
a541 1
mkpath($installscript, $verbose, 0777);
d575 2
a576 2
if ( !$versiononly || ($installprivlib =~ m/\Q$ver/)) {
    mkpath("${installprivlib}/$pod", $verbose, 0777);
d589 1
a589 1
		unless $nonono;
d625 1
d627 1
d645 2
a646 2
$packlist->write() unless $nonono;
print "  Installation complete\n" if $verbose;
d652 3
a664 16
sub unlink {
    my(@@names) = @@_;
    my($cnt) = 0;

    return scalar(@@names) if $Is_VMS;

    foreach my $name (@@names) {
	next unless -e $name;
	chmod 0777, $name if ($Is_OS2 || $Is_W32 || $Is_Cygwin || $Is_NetWare);
	print "  unlink $name\n" if $verbose;
	( CORE::unlink($name) and ++$cnt
	  or warn "Couldn't unlink $name: $!\n" ) unless $nonono;
    }
    return $cnt;
}

d666 1
a666 1
    return if $nonono or $Is_VMS;
d671 1
a671 1
	print "  unlink $name\n" if $verbose;
d675 1
a675 1
	    print "  mv $name $name.old\n" if $verbose;
a695 44
sub link {
    my($from,$to) = @@_;
    my($success) = 0;

    my $xfrom = $from;
    $xfrom =~ s/^\Q$destdir\E// if $destdir;
    my $xto = $to;
    $xto =~ s/^\Q$destdir\E// if $destdir;
    print $verbose ? "  ln $xfrom $xto\n" : "  $xto\n" unless $silent;
    eval {
	CORE::link($from, $to)
	    ? $success++
	    : ($from =~ m#^/afs/# || $to =~ m#^/afs/#)
	      ? die "AFS"  # okay inside eval {}
	      : die "Couldn't link $from to $to: $!\n"
	  unless $nonono;
	$packlist->{$xto} = { from => $xfrom, type => 'link' };
    };
    if ($@@) {
	warn "Replacing link() with File::Copy::copy(): $@@";
	print $verbose ? "  cp $from $xto\n" : "  $xto\n" unless $silent;
	print "  creating new version of $xto\n"
		 if $Is_VMS and -e $to and !$silent;
	unless ($nonono or File::Copy::copy($from, $to) and ++$success) {
	    # Might have been that F::C::c can't overwrite the target
	    warn "Couldn't copy $from to $to: $!\n"
		unless -f $to and (chmod(0666, $to), unlink $to)
			and File::Copy::copy($from, $to) and ++$success;
	}
	$packlist->{$xto} = { type => 'file' };
    }
    $success;
}

sub chmod {
    my($mode,$name) = @@_;

    return if ($^O eq 'dos');
    printf "  chmod %o %s\n", $mode, $name if $verbose;
    CORE::chmod($mode,$name)
	|| warn sprintf("Couldn't chmod %o %s: $!\n", $mode, $name)
      unless $nonono;
}

d700 6
a705 4
    $xto =~ s/^\Q$destdir\E// if $destdir;
    print $verbose ? "  cp $from $xto\n" : "  $xto\n" unless $silent;
    print "  creating new version of $xto\n" if $Is_VMS and -e $to and !$silent;
    unless ($nonono or File::Copy::copy($from, $to)) {
a713 33
sub install {
    my($from,$to,$mode,$strip) = @@_;

    my $xto = $to;
    my $cmd = join(' ', @@installcmd);
    $cmd .= " -m $mode" if $mode;
    $cmd .= " -s" if $strip;
    $cmd .= " $from $to";
    $xto =~ s/^\Q$destdir\E// if $destdir;
    print $verbose ? "  install $from $xto\n" : "  $xto\n" unless $silent;
    unless ($nonono) {
       system($cmd);
       warn "Couldn't $cmd\n" if $?;
    }
    $packlist->{$xto} = { type => 'file' };
}

sub samepath {
    my($p1, $p2) = @@_;

    return (lc($p1) eq lc($p2)) if ($Is_W32 || $Is_NetWare);

    if ($p1 ne $p2) {
	my($dev1, $ino1, $dev2, $ino2);
	($dev1, $ino1) = stat($p1);
	($dev2, $ino2) = stat($p2);
	($dev1 == $dev2 && $ino1 == $ino2);
    }
    else {
	1;
    }
}

d763 2
d766 1
a766 1
    if ($dir =~ /^auto/ ||
d769 1
a769 1
	  $name eq 'Config_heavy.pl'
d787 1
a787 1
	$xname =~ s/^\Q$destdir\E// if $destdir;
d789 1
a789 1
	if ($force || compare($_, "$installlib/$name") || $nonono) {
d791 1
a791 1
	    mkpath("$installlib/$dir", $verbose, 0777);
d834 1
a834 1
    $xto =~ s/^\Q$destdir\E// if $destdir;
d848 1
a848 1
    if ($force || compare($from, $to) || $nonono) {
d850 1
a850 1
	if ($nonono) {
d858 1
a858 1
	if (!$nonono && ($Is_OS2 || $to =~ /\.a$/)) {
d879 1
a879 1
	    if ($verbose) {
d886 1
a886 1
	    print "# file '$file' skipped\n" if $verbose;
@


1.19
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d214 1
a214 1
my $installman1dir = "$destdir$Config{installman1dir}";
@


1.18
log
@merge in perl 5.8.8
@
text
@d10 25
d184 2
a185 5
	# strip trailing component first
	$path =~ s{/[^/]*$}{};

	# strip optional "/lib";
	$path =~ s{/lib\b}{};
a287 31
	if ($Config{useshrplib} eq 'true') {
	    # install ld2 and perlld as well
	    foreach ('ld2', 'perlld') {
		safe_unlink("$installbin/$_");
		copy("$_", "$installbin/$_");
		chmod(0755, "$installbin/$_");
		$packlist->{"$installbin/$_"} = { type => 'file' };
	    };
	    open (LD2, ">$installbin/ld2");
	    print LD2 <<SHELL;
#!/bin/sh
#
# ld wrapper, passes all args to perlld;
#
for trythis in $installbin/perl
do
  if [ -x \$trythis ]
  then
    \$trythis $installbin/perlld "\$\@@"
    exit \$?
  fi
done
# hard luck!
echo I see no perl executable around there
echo perl is required to build dynamic libraries
echo look if the path to perl in /bin/ld2 is correct
exit 1
SHELL
	    close LD2;
	    chmod(0755, "$installbin/ld2");
	};
d289 1
a289 1
	$perldll = 'perl58.' . $dlext;
d402 1
a402 1
    #@@corefiles = <*.h *.inc libperl*.* perl*$Config{lib_ext}>;
a428 8
# Switch in the 5.005-threads versions of he threadsafe queue and semaphore
# modules if so needed.
if ($Config{use5005threads}) {
    for my $m (qw(Queue Semaphore)) {
	install("ext/Thread/$m.pmx", "$installprivlib/Thread/$m.pm", "0444");
    }
}

d575 1
a575 1
my $pod = ($Is_Cygwin || $Is_Darwin || $Is_VMS) ? 'pods' : 'pod';
d779 2
a780 2
	system($cmd);
	warn "Couldn't $cmd\n" if $?;
d816 1
a816 1
    return if $name =~ m{\.orig$|\.rej$|~$|^#.+#$|,v$|^\.exists|\.PL$|\.plc$|\.t$|^test\.pl$} ||
a817 4

    # XXX xsubpp back out of the list. prove now integrated. Out of order, so
    # p4 will conflict on the next update to the following lines:

d819 3
a821 1
    # scripts in lib/ExtUtils, and the prove script in lib/Test/Harness
d823 1
a823 2
    return if $name =~ /^(?:cpan|instmodsh|prove)\z/;

d827 2
a828 1
    return if $dir =~ m{ext/XS/(?:APItest|Typemap)/};
d830 1
a830 1
    return if $dir =~ /\bdemos?\b/;
d834 3
a836 2
    return if $name =~ m{^(?:README(?:\.\w+)?|MANIFEST|META\.yml|INSTALL)$} && $name ne 'README.e2x';
    return if $name =~ m{^(?:TODO|BUGS|CREDITS)$}i;
d838 9
d863 1
a863 1
	if (/\.(?:al|ix)$/ && !($dir =~ m[^auto/(.*)$] && $archpms{$1})) {
@


1.17
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d592 1
a592 1
my $pod = ($Is_Cygwin || $Is_Darwin) ? 'pods' : 'pod';
d848 8
d862 2
a863 1
	  ($name =~ /^(.*)\.(?:h|lib)$/i && ($Is_W32 || $Is_NetWare))
@


1.16
log
@merge local changes into perl-5.8.3
@
text
@d255 3
d272 1
d309 1
a311 3
# This will be used to store the packlist
my $packlist = ExtUtils::Packlist->new("$installarchlib/.packlist");

d463 1
a463 1
    link("$installbin/s$perl_verbase$ver$exe_ext",
@


1.15
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d106 1
d132 1
a132 1
my @@pods = $nopods ? () : (<pod/*.pod>);
d409 2
a410 2
    #@@corefiles = <*.h *.inc libperl*.*>;
    @@corefiles = <*.h *.inc>;
d742 1
a742 1
	warn $@@;
d746 6
a751 4
	File::Copy::copy($from, $to)
	    ? $success++
	    : warn "Couldn't copy $from to $to: $!\n"
	  unless $nonono;
d774 6
a779 3
    File::Copy::copy($from, $to)
	|| warn "Couldn't copy $from to $to: $!\n"
      unless $nonono;
d824 1
a824 1
    if (($name eq 'CVS' or $name eq 'RCS' or $name eq '.svn') and -d $name) {
d833 9
a841 2
    # ignore the cpan script in lib/CPAN/bin (installed later with other utils)
    return if $name eq 'cpan';
@


1.14
log
@Resolve conflicts, remove old files, merge local changes
@
text
@a1 4
#	$OpenBSD: installperl,v 1.13 2001/05/24 18:34:50 millert Exp $
#
# This is hacked up, in order to support DESTDIR and INSTALL_STRIP.
#
d5 1
a5 1
    chdir '..' if !-d 'lib' and -d '..\lib';
d12 2
a13 2
    $nonono, $dostrip, $versiononly, $silent, $verbose,
    $otherperls, $archname,$Is_NetWare, $nwinstall, $nopods);
d33 1
a33 1
use subs qw(unlink link chmod cmd);
d41 2
a42 2
	$Is_W32 = 0;
	$scr_ext = '.pl';
d63 10
d75 1
d83 1
d86 1
a86 1
	$nwinstall = 1 if $ARGV[0] eq '-netware';
d88 1
d90 1
a90 1
      print <<"EOT";
d99 1
d107 1
a107 1
      exit;
d117 2
a118 1
    next if /#\s*pod\s*=/; # Binary programs need separate treatment
d121 2
a122 2
        push @@scripts, $1;
        push @@tolink, [$1, $2];
d124 1
a124 1
        push @@scripts, $_;
d150 2
a151 3
if ((-e "testcompile") && (defined($ENV{'COMPILE'})))
{
	push(@@scripts, map("$_.exe", @@scripts));
d155 2
a156 2
	if ("$File::Find::dir/$_" =~ m{^ext\b(.*)/([^/]+)\.pm$}) {
	    my($path, $modname) = ($1,$2);
d158 2
a159 2
	    # strip trailing component first
	    $path =~ s{/[^/]*$}{};
d161 2
a162 2
	    # strip optional "/lib";
	    $path =~ s{/lib\b}{};
d164 2
a165 2
	    # strip any leading /
	    $path =~ s{^/}{};
d167 2
a168 2
	    # reconstitute canonical module name
	    $modname = "$path/$modname" if length $path;
d170 4
a173 4
	    # remember it
	    $archpms{$modname} = 1;
	}
    }, 'ext');
d184 8
a191 32
my $installbin;
my $installscript;
my $installprivlib;
my $installarchlib;
my $installsitelib;
my $installsitearch;
my $installman1dir;
my $installdest = $ENV{"DESTDIR"};

$installdest =~ s:/+$::;
if ($installdest ne '') {
    # Fetch some frequently-used items from %Config, prefixing with DESTDIR.
    $installbin = "$installdest/$Config{installbin}";
    $installscript = "$installdest/$Config{installscript}";
    $installprivlib = "$installdest/$Config{installprivlib}";
    $installarchlib = "$installdest/$Config{installarchlib}";
    $installsitelib = "$installdest/$Config{installsitelib}";
    $installsitearch = "$installdest/$Config{installsitearch}";
    $installman1dir = "$installdest/$Config{installman1dir}";
    # Also whack $mainperldir.
    $mainperldir = "$installdest/$mainperldir";
} else {
    # Fetch some frequently-used items from %Config
    $installbin = $Config{installbin};
    $installscript = $Config{installscript};
    $installprivlib = $Config{installprivlib};
    $installarchlib = $Config{installarchlib};
    $installsitelib = $Config{installsitelib};
    $installsitearch = $Config{installsitearch};
    $installman1dir = $Config{installman1dir};
}

d204 1
a204 1
        `./$^X -pibak -e 's{$pwd\/libperl.x}{$archlibexp/CORE/libperl.x}' lib/Config.pm`;
d209 5
a213 5
	# This is required only if we are installing on a NetWare server
	$installscript = $Config{installnwscripts};
	$installprivlib = $Config{installnwlib};
	$installarchlib = $Config{installnwlib};
	$installsitelib = $Config{installnwlib};
d221 3
a223 3
              \$installarchlib, \$installsitelib, \$installsitearch,
              \$installman1dir ) {
      $$_ = unixify($$_);  $$_ =~ s:/$::;
d229 1
a229 1
if ($d_dosuid && $>) { die "You must run as root to install suidperl\n"; }
d238 1
d240 7
d249 3
a251 3
-f 't/rantests'		|| $Is_W32
                        || warn "WARNING: You've never run 'make test' or",
                                " some tests failed! (Installing anyway.)\n";
d254 2
a255 2
if (($Is_W32 and ! $Is_NetWare)  or $Is_Cygwin) {
  my $perldll;
d257 42
a298 37
  if ($Is_Cygwin) {
    $perldll = $libperl;
    my $v_e_r_s = $ver; $v_e_r_s =~ tr/./_/;
    $perldll =~ s/(\..*)?$/$v_e_r_s.$dlext/;
    $perldll =~ s/^lib/cyg/;
    if ($Config{useshrplib} eq 'true') {
      # install ld2 and perlld as well
      foreach ('ld2', 'perlld') {
        safe_unlink("$installbin/$_");
        copy("$_", "$installbin/$_");
        chmod(0755, "$installbin/$_");
      };
      { 
		open (LD2, ">$installbin/ld2");
		print LD2 "#!/bin/sh\n#\n# ld wrapper, passes all args to perlld;\n#\n"
		          . "for trythis in $installbin/perl\ndo\n  if [ -x \$trythis ]\n"
		          . "  then\n    \$trythis $installbin/perlld \"\$\@@\"\n"
		          . "    exit \$?\n  fi\ndone\n# hard luck!\necho i see no perl"
		          . " executable around there\necho perl is required to build "
		          . "dynamic libraries\necho look if the path to perl in /bin/ld2"
		          . " is correct\nexit 1\n";
		close LD2;
      };
      chmod(0755, "$installbin/ld2");
    };
  } else {
    $perldll = 'perl58.' . $dlext;
  }

  if ($dlsrc ne "dl_none.xs") {
    -f $perldll || die "No perl DLL built\n";
  }
  # Install the DLL

  safe_unlink("$installbin/$perldll");
  copy("$perldll", "$installbin/$perldll");
  chmod(0755, "$installbin/$perldll");
d300 4
d309 3
a311 9
# Get the install command from the environment
my $installcmd;
if (defined($ENV{"INSTALL"})) {
    $installcmd = $ENV{"INSTALL"}
	. " " . $ENV{"INSTALL_COPY"}
	. " " . $ENV{"INSTALL_STRIP"};
} else {
    $installcmd = "cp";
}
d314 1
d316 17
a332 6
    safe_unlink("$installbin/$perl$exe_ext");
    copy("perl$exe_ext", "$installbin/$perl$exe_ext");
    chmod(0755, "$installbin/$perl$exe_ext");
    safe_unlink("$installbin/${perl}shr$exe_ext");
    copy("perlshr$exe_ext", "$installbin/${perl}shr$exe_ext");
    chmod(0755, "$installbin/${perl}shr$exe_ext");
d345 18
a362 21
	if (!$Is_NetWare) {
		safe_unlink("$installbin/$perl_verbase$ver$exe_ext");
		#copy("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext");
		cmd("$installcmd perl$exe_ext $installbin/$perl_verbase$ver$exe_ext");
		strip("$installbin/$perl_verbase$ver$exe_ext");
		chmod(0755, "$installbin/$perl_verbase$ver$exe_ext");
	}
	else {
		# If installing onto a NetWare server
		if ($nwinstall) {
			# Copy perl.nlm, echo.nlm, type.nlm, a2p.nlm & cgi2perl.nlm
			mkpath($Config{installnwsystem}, 1, 0777);
			copy("netware\\".$ENV{'MAKE_TYPE'}."\\perl.nlm", $Config{installnwsystem});
			copy("netware\\testnlm\\echo\\echo.nlm", $Config{installnwsystem});
			copy("netware\\testnlm\\type\\type.nlm", $Config{installnwsystem});
			copy("x2p\\a2p.nlm", $Config{installnwsystem});
			chmod(0755, "$Config{installnwsystem}\\perl.nlm");
			mkpath($Config{installnwlcgi}, 1, 0777);
			copy("lib\\auto\\cgi2perl\\cgi2perl.nlm", $Config{installnwlcgi});
		}
	} #if (!$Is_NetWare)
d371 2
a372 3
    #copy("suidperl$exe_ext", "$installbin/s$perl_verbase$ver$exe_ext");
    cmd("$installcmd suidperl$exe_ext $installbin/s$perl_verbase$ver$exe_ext");
    chmod(04711, "$installbin/s$perl_verbase$ver$exe_ext");
d408 2
a409 2
    #@@corefiles = <*.h libperl*.*>;
    @@corefiles = <*.h>;
d415 3
a417 3
        # MPE needs mpeixish.h installed as well.
        mkpath("$installarchlib/CORE/mpeix", $verbose, 0777);
        push(@@corefiles,'mpeix/mpeixish.h');
d428 1
a428 1
           chmod(0555, "$installarchlib/CORE/$file");
d439 1
a439 4
        my $t = "$installprivlib/Thread/$m.pm";
        unlink $t;
        copy("ext/Thread/$m.pmx", $t);
        chmod(0444, $t);
d451 1
a451 1
        symlink($Config{perlpath}, "$installbin/perl$exe_ext");
d454 2
a455 2
        symlink("$installbin/$perl_verbase$ver$exe_ext",
                "$installbin/$perl$exe_ext");
d473 1
a473 1
        symlink($Config{perlpath}, "$installbin/$archperl");
d479 1
a479 2
	link("$installbin/$perl_verbase$ver$exe_ext",
		"$installbin/$archperl");
d518 9
a526 8
if (!$Is_NetWare) {
	if (!$versiononly && ! samepath($installbin, 'x2p')) {
		safe_unlink("$installbin/a2p$exe_ext");
		#copy("x2p/a2p$exe_ext", "$installbin/a2p$exe_ext");
		cmd("$installcmd x2p/a2p$exe_ext $installbin/a2p$exe_ext");
		strip("$installbin/a2p$exe_ext");
		chmod(0755, "$installbin/a2p$exe_ext");
	}
d548 1
a548 1
	        "$installscript/$alias$scr_ext");
d566 4
a569 4
        my ($from, $to) = map { "$_$ver" } @@$_;
        (my $frbase = $from) =~ s#.*/##;
        (my $tobase = $to) =~ s#.*/##;
        script_alias($installscript, $frbase, $tobase, $scr_ext);
d579 4
a582 4
        my ($from, $to) = @@$_;
        (my $frbase = $from) =~ s#.*/##;
        (my $tobase = $to) =~ s#.*/##;
        script_alias($installscript, $frbase, $tobase, $scr_ext);
d610 1
a610 1
        (my $base = $_) =~ s#.*/##;
d628 5
a632 5
        my $i = 0;
        while (exists $ENV{'DCL$PATH' . $i}) {
            my $dir = unixpath($ENV{'DCL$PATH' . $i});  $dir =~ s-/$--;
            push(@@path,$dir);
        }
d642 1
a642 1
        my $otherperl = "$_/$perl$exe_ext";
d726 5
a730 1
    print $verbose ? "  ln $from $to\n" : "  $to\n" unless $silent;
d738 1
a738 1
        $packlist->{$to} = { from => $from, type => 'link' };
d742 3
a744 3
        print $verbose ? "  cp $from $to\n" : "  $to\n" unless $silent;
	print "  creating new version of $to\n"
                 if $Is_VMS and -e $to and !$silent;
d749 1
a749 1
        $packlist->{$to} = { type => 'file' };
a753 9
sub cmd {
    my($cmd) = @@_;
    print STDERR "  $cmd\n";
    unless ($nonono) {
	system $cmd;
	warn "Command failed!!!\n" if $?;
    }
}

d767 4
a770 2
    print $verbose ? "  cp $from $to\n" : "  $to\n" unless $silent;
    print "  creating new version of $to\n" if $Is_VMS and -e $to and !$silent;
d774 18
a791 1
    $packlist->{$to} = { type => 'file' };
d817 2
a818 2
    # Ignore RCS and CVS directories.
    if (($name eq 'CVS' or $name eq 'RCS') and -d $name) {
d824 7
a830 3
    # .exists files, .PL files, and .t files.
    return if $name =~ m{\.orig$|~$|^#.+#$|,v$|^\.exists|\.PL$|\.t$} ||
              $dir  =~ m{/t(?:/|$)};
d841 1
a841 1
        $installlib = $installarchlib;
d856 4
a859 2
        $packlist->{"$installlib/$name"} = { type => 'file' };
	if (compare($_, "$installlib/$name") || $nonono) {
d864 7
a870 7
           if ($Is_NetWare && !$nwinstall) {
               # Don't copy .nlp,.nlm files, doesn't make sense on Windows and also
               # if copied will give problems when building new extensions.
               # Has to be copied if we are installing on a NetWare server and hence
               # the check !$nwinstall
               if (!(/\.(?:nlp|nlm|bs)$/)) {
                   copy_if_diff($_, "$installlib/$name")
d872 14
a885 14
                                 "$installlib/$name");
               }
           } else {
               if (copy_if_diff($_, "$installlib/$name")) {
                   if ($name =~ /\.(so|$dlext)$/o) {
                       strip("-S", "$installlib/$name") if $^O =~ /^(rhapsody|darwin)$/;
                       chmod(0555, "$installlib/$name");
                   } else {
                       strip("-S", "$installlib/$name")
                           if ($name =~ /\.a$/o and $^O =~ /^(rhapsody|darwin)$/);
                       chmod(0444, "$installlib/$name");
                   }
               }
           } #if ($Is_NetWare)
d903 2
d917 2
a918 2
    $packlist->{$to} = { type => 'file' };
    if (compare($from, $to) || $nonono) {
d920 3
a922 3
        if ($nonono) {
            $from = $depth . "/" . $from if $depth;
        }
d944 1
a944 1
        push @@opts, shift @@args;
d948 10
a957 10
        if (-f $file) {
           if ($verbose) {
               print "  strip " . join(' ', @@opts);
               print " " if (@@opts);
               print "$file\n";
           }
            system("strip", @@opts, $file);
        } else {
            print "# file '$file' skipped\n" if $verbose;
        }
@


1.13
log
@merge in perl 5.6.1 with our local changes
@
text
@d2 1
a2 1
#	$OpenBSD: installperl,v 1.12 2000/04/06 17:03:58 millert Exp $
d15 3
a17 2
my ($Is_VMS, $Is_W32, $Is_OS2, $Is_Cygwin, $nonono, $dostrip,
    $versiononly, $silent, $verbose, $otherperls);
d25 1
d39 10
d73 1
d77 22
d102 15
a116 7
$versiononly = 1 if $Config{versiononly};

my @@scripts = qw(utils/c2ph utils/h2ph utils/h2xs utils/perlbug utils/perldoc
		utils/pl2pm utils/splain utils/perlcc utils/dprofpp
		x2p/s2p x2p/find2perl 
		pod/pod2man pod/pod2html pod/pod2latex pod/pod2text
		pod/pod2usage pod/podchecker pod/podselect);
d120 1
a120 1
my @@pods = (<pod/*.pod>);
d126 1
a126 1
# we no longer have to play the trick of sticking version-specific .pm 
d129 3
a131 1
    Config => 1, 
d213 3
d218 1
a218 4
        my $pwd;
        chomp($pwd=`pwd`);
        my $archlibexp = $Config{archlibexp};
        `./$^X -p -e 's{$pwd\/libperl.x}{$archlibexp/CORE/libperl.x}' lib/Config.pm`;
d222 8
d251 1
d256 3
a258 2
			|| warn "WARNING: You've never run 'make test'!!!",
				"  (Installing anyway.)\n";
d260 1
a260 1
if ($Is_W32 or $Is_Cygwin) {
d265 3
a267 1
    $perldll =~ s/(\..*)?$/.$dlext/;
d275 12
d289 1
a289 1
    $perldll = 'perl56.' . $dlext;
d300 2
a301 2
   
} # if ($Is_W32 or $Is_Cygwin)
d336 21
a356 5
    safe_unlink("$installbin/$perl_verbase$ver$exe_ext");
    #copy("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext");
    cmd("$installcmd perl$exe_ext $installbin/$perl_verbase$ver$exe_ext");
    strip("$installbin/$perl_verbase$ver$exe_ext");
    chmod(0755, "$installbin/$perl_verbase$ver$exe_ext");
d373 1
a373 1
    
a421 1
	    chmod(0555, "$installarchlib/CORE/$file");
d423 1
d430 11
d444 1
a444 1
if (! $versiononly && ! samepath($installbin, '.') && ($^O ne 'dos') && ! $Is_VMS) {
d450 4
d459 1
a459 1
	    "$installbin/suid$perl$exe_ext") 
d463 19
d487 1
a487 1
    !$versiononly && !$nonono && !$Is_W32 && !$Is_VMS && -t STDIN && -t STDERR
d505 1
a505 5
    if ((! $mainperl_is_instperl) &&
	(yn("Many scripts expect perl to be installed as $usrbinperl.\n" . 
	     "Do you wish to have $usrbinperl be the same as\n" .
	     "$expinstperl? [y] ")))
    {
d517 8
a524 6

if (!$versiononly && ! samepath($installbin, 'x2p')) {
    safe_unlink("$installbin/a2p$exe_ext");
    #copy("x2p/a2p$exe_ext", "$installbin/a2p$exe_ext");
    cmd("$installcmd x2p/a2p$exe_ext $installbin/a2p$exe_ext");
    chmod(0755, "$installbin/a2p$exe_ext");
d537 2
a538 2
if (! $versiononly) {
    # Install scripts.
d540 22
a561 1
    mkpath($installscript, $verbose, 0777);
d563 7
d576 5
a580 8
    # pstruct should be a link to c2ph
    safe_unlink("$installscript/pstruct$scr_ext");
    if ($^O eq 'dos' or $Is_VMS or $^O eq 'transit') {
	copy("$installscript/c2ph$scr_ext",
	     "$installscript/pstruct$scr_ext"); 
    } else {
	link("$installscript/c2ph$scr_ext",
	     "$installscript/pstruct$scr_ext");
d587 1
a587 1
my $pod = $Is_Cygwin ? 'pods' : 'pod';
d622 1
a622 1
    my $dirsep = ($Is_OS2 || $Is_W32) ? ';' : ':' ;
d667 1
a667 1
    warn $prompt;
d681 1
a681 1
	chmod 0777, $name if ($Is_OS2 || $Is_W32 || $Is_Cygwin);
d683 1
a683 1
	( CORE::unlink($name) and ++$cnt 
d694 1
a694 1
	chmod 0777, $name if ($Is_OS2 || $Is_W32);
d713 1
a713 1
	warn("Cannot rename to `$to.$i': $!"), return 0 
d781 1
a781 1
    return (lc($p1) eq lc($p2)) if $Is_W32;
d806 1
a806 1
    
d808 5
a812 2
    # .exists files.
    return if $name =~ m{\.orig$|~$|^#.+#$|,v$|^\.exists};
d819 1
a819 1
	  ($name =~ /^(.*)\.(?:h|lib)$/i && $Is_W32)
d842 22
a863 3
	    copy_if_diff($_, "$installlib/$name")
		and chmod($name =~ /\.(so|$dlext)$/o ? 0555 : 0444,
			   "$installlib/$name");
d881 12
a892 1
    -f $from || warn "$0: $from not found";
d899 3
d925 5
a929 1
            print "  strip $file\n" if $verbose;
a935 1

@


1.12
log
@perl-5.6.0 + local changes
@
text
@d2 1
a2 1
#	$OpenBSD: installperl,v 1.11 2000/01/17 07:06:41 fgsch Exp $
d15 3
a17 1
use vars qw($Is_VMS $Is_W32 $Is_OS2 $Is_Cygwin $nonono $dostrip $versiononly $depth);
a35 1
use vars qw($packlist);
d56 1
d61 3
d67 2
d123 1
a123 1
my $release = substr($],0,3);   # Not used presently.
d167 9
d193 1
a193 1
-d $installbin		|| mkpath($installbin, 1, 0777);
d201 1
a201 1
-x 't/TEST'		|| $Is_W32
d208 10
a217 9
if ($Is_Cygwin) {
  $perldll = $libperl;
  $perldll =~ s/(\..*)?$/.$dlext/;
  if ($Config{useshrplib} eq 'true') {
    # install ld2 and perlld as well
    foreach ('ld2', 'perlld') {
      safe_unlink("$installbin/$_");
      copy("$_", "$installbin/$_");
      chmod(0755, "$installbin/$_");
d219 12
a230 13
  };
} else {
  $perldll = 'perl56.' . $dlext;
}

   if ($dlsrc ne "dl_none.xs") {
      -f $perldll || die "No perl DLL built\n";
   }
# Install the DLL

   safe_unlink("$installbin/$perldll");
   copy("$perldll", "$installbin/$perldll");
   chmod(0755, "$installbin/$perldll");
d289 4
a292 4
mkpath($installprivlib, 1, 0777);
mkpath($installarchlib, 1, 0777);
mkpath($installsitelib, 1, 0777) if ($installsitelib);
mkpath($installsitearch, 1, 0777) if ($installsitearch);
d309 1
a309 1
mkpath("$installarchlib/CORE", 1, 0777);
d312 1
a312 1
    my $coredir = "lib/$Config{'arch'}/$ver";
d314 1
a314 1
    @@corefiles = map { s|^$coredir/||i; } <$coredir/*.*>;
d326 1
a326 1
        mkpath("$installarchlib/CORE/mpeix", 1, 0777);
d367 1
a367 1
if ($Config{installusrbinperl} eq 'define' &&
d420 2
a421 1
# Install scripts.
d423 1
a423 1
mkpath($installscript, 1, 0777);
a424 1
if (! $versiononly) {
a429 3
}

# pstruct should be a link to c2ph
d431 1
a431 1
if (! $versiononly) {
d434 2
a435 1
        copy("$installscript/c2ph$scr_ext", "$installscript/pstruct$scr_ext"); 
d437 2
a438 1
        link("$installscript/c2ph$scr_ext", "$installscript/pstruct$scr_ext");
d446 2
a447 2
unless ( $versiononly && !($installprivlib =~ m/\Q$ver/)) {
    mkpath("${installprivlib}/$pod", 1, 0777);
d478 1
a478 1
if (!$versiononly) {
d504 1
a504 1
	print STDERR "\nWarning: $perl appears in your path in the following " .
d507 1
a507 1
	    print STDERR "    ", $_, "\n";
d509 1
a509 1
	print STDERR "\n";
d515 1
a515 1
print "  Installation complete\n";
d525 1
a525 1
    print $prompt;
d540 1
a540 1
	print "  unlink $name\n";
d553 1
a553 1
	print "  unlink $name\n";
d557 1
a557 1
	    print "  mv $name $name.old\n";
d582 1
a582 1
    print "  ln $from $to\n";
d594 3
a596 2
	print "  cp $from $to\n";
	print "  creating new version of $to\n" if $Is_VMS and -e $to;
d619 1
a619 1
    printf "  chmod %o %s\n", $mode, $name;
d628 2
a629 2
    print "  cp $from $to\n";
    print "  creating new version of $to\n" if $Is_VMS and -e $to;
d694 1
a694 1
	    mkpath("$installlib/$dir", 1, 0777);
d747 1
a747 1
            print "  strip $file\n";
d750 1
a750 1
            print "# file '$file' skipped\n";
@


1.11
log
@Install stripped version of a2p; millert@@ ok.
@
text
@d2 1
a2 1
#	$OpenBSD: installperl,v 1.10 1999/11/23 05:17:20 millert Exp $
d15 1
a15 1
use vars qw($Is_VMS $Is_W32 $Is_OS2 $nonono $versiononly $depth);
d21 1
d47 8
d57 1
a61 2
umask 022 unless $Is_VMS;

d63 1
a63 1
		utils/pl2pm utils/splain utils/perlcc
d65 2
a66 1
		pod/pod2man pod/pod2html pod/pod2latex pod/pod2text);
d93 17
a109 3
	if ("$File::Find::dir/$_" =~ m{^ext/[^/]+/(.*)\.pm$}) {
	    (my $pm = $1) =~ s{^lib/}{};
	    $archpms{$pm} = 1;
d113 5
a117 3
my $ver = $];
my $release = substr($ver,0,3);   # Not used presently.
my $patchlevel = substr($ver,3,2);
d119 2
a120 2
    "and patchlevel of config.sh ($Config{'PATCHLEVEL'}) don't match\n"
	if $patchlevel != $Config{'PATCHLEVEL'};
d159 1
d189 2
a190 1
if ($Is_W32) {
d192 14
a205 4
my $perldll = 'perl.' . $dlext;
$perldll = 'perlcore.' . $dlext if $Config{'ccflags'} =~ /PERL_OBJECT/i;

-f $perldll || die "No perl DLL built\n";
d207 3
d212 5
a216 4
safe_unlink("$installbin/$perldll");
copy("$perldll", "$installbin/$perldll");
chmod(0755, "$installbin/$perldll");
}
d221 1
a221 1
# First we install the version-numbered executables.
d231 1
d251 5
a255 4
    safe_unlink("$installbin/$perl$ver$exe_ext");
    cmd("$installcmd perl$exe_ext $installbin/perl$ver$exe_ext");
    #copy("perl$exe_ext", "$installbin/$perl$ver$exe_ext");
    chmod(0755, "$installbin/$perl$ver$exe_ext");
d262 1
a262 1
safe_unlink("$installbin/s$perl$ver$exe_ext");
d264 3
a266 3
    cmd("$installcmd suidperl$exe_ext $installbin/sperl$ver$exe_ext");
    #copy("suidperl$exe_ext", "$installbin/s$perl$ver$exe_ext");
    chmod(04711, "$installbin/s$perl$ver$exe_ext");
d281 1
a281 1
    $do_installprivlib = 0 if $versiononly && !($installprivlib =~ m/\Q$]/);
d296 1
a296 1
    my $coredir = "lib/$Config{'arch'}/$]";
d298 1
a298 1
    @@corefiles = <$coredir/*.*>;
d301 2
d305 1
d319 8
a326 3
    copy_if_diff($file,"$installarchlib/CORE/$file")
	and chmod($file =~ /\.(so|\Q$dlext\E)$/ ? 0555 : 0444,
		   "$installarchlib/CORE/$file");
d339 2
a340 1
	link("$installbin/$perl$ver$exe_ext", "$installbin/$perl$exe_ext");
d342 2
a343 1
    link("$installbin/s$perl$ver$exe_ext", "$installbin/suid$perl$exe_ext") 
d420 1
a420 1
    if ($^O eq 'dos' or $Is_VMS) {
d427 2
a428 1
# Install pod pages.  Where? I guess in $installprivlib/pod.
d430 3
a432 2
unless ( $versiononly && !($installprivlib =~ m/\Q$]/)) {     # as line 200
    mkpath("${installprivlib}/pod", 1, 0777);
d435 1
a435 1
    if (open POD, "${installprivlib}/pod/perldiag.pod") {
d440 3
a442 3
	    my ($from, $to) = ("${installprivlib}/pod/perldiag.pod",
			       "${installprivlib}/pod/perldiag-5.003.pod");
	    print STDERR "  rename $from $to";
d449 4
a452 3
    foreach my $file (@@pods) {
	# $file is a name like  pod/perl.pod
	copy_if_diff($file, "${installprivlib}/${file}");
d464 1
a464 1
	my ($path, @@path);
d476 1
d483 4
a486 2
	push(@@otherperls, "$_/$perl$exe_ext")
	    if (-x "$_/$perl$exe_ext" && ! -d "$_/$perl$exe_ext");
d500 1
a500 1
print STDERR "  Installation complete\n";
d510 1
a510 1
    print STDERR $prompt;
d524 2
a525 2
	chmod 0777, $name if ($Is_OS2 || $Is_W32);
	print STDERR "  unlink $name\n";
d538 1
a538 1
	print STDERR "  unlink $name\n";
d542 1
a542 1
	    print STDERR "  mv $name $name.old\n";
d567 1
a567 1
    print STDERR "  ln $from $to\n";
d573 1
a573 1
	      : warn "Couldn't link $from to $to: $!\n"
d578 3
a580 1
	print STDERR "  creating new version of $to\n" if $Is_VMS and -e $to;
d603 1
a603 1
    printf STDERR "  chmod %o %s\n", $mode, $name;
d612 2
a613 2
    print STDERR "  cp $from $to\n";
    print STDERR "  creating new version of $to\n" if $Is_VMS and -e $to;
d643 2
a644 1
    if ($name eq 'CVS' && -d $name) {
d649 3
a651 2
    # ignore patch backups and the .exists files.
    return if $name =~ m{\.orig$|~$|^\.exists};
d701 1
a701 1
    -f $from || die "$0: $from not found";
d717 22
@


1.10
log
@missed in shared libperl mods due to cvs bug
@
text
@d2 1
a2 1
#	$OpenBSD: installperl,v 1.9 1999/04/29 22:56:02 millert Exp $
d336 2
a337 1
    copy("x2p/a2p$exe_ext", "$installbin/a2p$exe_ext");
@


1.9
log
@New configuration method, use a combination of hints and config.over.  Also add in OpenBSD-specific patches
@
text
@d2 1
a2 1
#	$OpenBSD: installperl,v 1.7 1997/11/30 07:48:39 millert Exp $
d258 2
a259 1
    @@corefiles = <*.h libperl*.*>;
@


1.8
log
@perl5.005_03 (stock)
@
text
@d2 4
d32 1
a32 1
use subs qw(unlink link chmod);
d97 32
a128 8
# Fetch some frequently-used items from %Config
my $installbin = $Config{installbin};
my $installscript = $Config{installscript};
my $installprivlib = $Config{installprivlib};
my $installarchlib = $Config{installarchlib};
my $installsitelib = $Config{installsitelib};
my $installsitearch = $Config{installsitearch};
my $installman1dir = $Config{installman1dir};
d181 8
d210 2
a211 1
    copy("perl$exe_ext", "$installbin/$perl$ver$exe_ext");
d221 2
a222 1
    copy("suidperl$exe_ext", "$installbin/s$perl$ver$exe_ext");
d525 9
@


1.7
log
@perl 5.004_04
@
text
@a1 4
#	$OpenBSD: installperl,v 1.6 1997/07/24 21:18:44 kstailey Exp $
#
# This is hacked up, in order to support DESTDIR and INSTALL_STRIP.
#
d5 1
d10 12
d26 1
d28 2
a29 1
use subs qw(unlink link chmod cmd);
d36 5
a40 2
$mainperldir = "/usr/bin";
$exe_ext = $Config{exe_ext};
d48 1
a48 1
umask 022;
d50 3
a52 3
@@scripts = qw(	utils/c2ph utils/h2ph utils/h2xs
		utils/perlbug utils/perldoc utils/pl2pm utils/splain
		x2p/s2p x2p/find2perl
d55 23
a77 1
@@pods = (<pod/*.pod>);
a78 1
%archpms = (Config => 1, FileHandle => 1, overload => 1);
d86 3
a88 3
$ver = $];
$release = substr($ver,0,3);   # Not used presently.
$patchlevel = substr($ver,3,2);
d93 13
a105 23
$installdest = $ENV{"DESTDIR"};
$installdest =~ s:/+$::;
if ($installdest ne '') {
    # Fetch some frequently-used items from %Config, prefixing with DESTDIR.
    $installbin = "$installdest/$Config{installbin}";
    $installscript = "$installdest/$Config{installscript}";
    $installprivlib = "$installdest/$Config{installprivlib}";
    $installarchlib = "$installdest/$Config{installarchlib}";
    $installsitelib = "$installdest/$Config{installsitelib}";
    $installsitearch = "$installdest/$Config{installsitearch}";
    $installman1dir = "$installdest/$Config{installman1dir}";
    # Also whack $mainperldir.
    $mainperldir = "$installdest/$mainperldir";
} else {
    # Fetch some frequently-used items from %Config
    $installbin = $Config{installbin};
    $installscript = $Config{installscript};
    $installprivlib = $Config{installprivlib};
    $installarchlib = $Config{installarchlib};
    $installsitelib = $Config{installsitelib};
    $installsitearch = $Config{installsitearch};
    $installman1dir = $Config{installman1dir};
}
d107 2
a108 5
$man1ext = $Config{man1ext};
$libperl = $Config{libperl};
# Shared library and dynamic loading suffixes.
$so = $Config{so};
$dlext = $Config{dlext};
d110 7
a116 2
$d_dosuid = $Config{d_dosuid};
$binexp = $Config{binexp};
d131 20
a150 2
-x 't/TEST'		|| warn "WARNING: You've never run 'make test'!!!",
	"  (Installing anyway.)\n";
d154 26
a179 6
if (defined($ENV{"INSTALL"})) {
    $installcmd = $ENV{"INSTALL"}
	. " " . $ENV{"INSTALL_COPY"}
	. " " . $ENV{"INSTALL_STRIP"};
} else {
    $installcmd = "cp";
d182 1
a182 6
safe_unlink("$installbin/perl$ver$exe_ext");
cmd("$installcmd perl$exe_ext $installbin/perl$ver$exe_ext");
#copy("perl$exe_ext", "$installbin/perl$ver$exe_ext");
chmod(0755, "$installbin/perl$ver$exe_ext");

safe_unlink("$installbin/sperl$ver$exe_ext");
d184 2
a185 3
    cmd("$installcmd suidperl$exe_ext $installbin/sperl$ver$exe_ext");
    #copy("suidperl$exe_ext", "$installbin/sperl$ver$exe_ext");
    chmod(04711, "$installbin/sperl$ver$exe_ext");
d190 1
a190 1
$do_installarchlib = $do_installprivlib = 0;
d213 19
a231 6
@@corefiles = <*.h libperl*.*>;
# AIX needs perl.exp installed as well.
push(@@corefiles,'perl.exp') if $^O eq 'aix';
# If they have built sperl.o...
push(@@corefiles,'sperl.o') if -f 'sperl.o';
foreach $file (@@corefiles) {
d239 16
d257 1
a257 1
$mainperl_is_instperl = 0;
d259 2
a260 1
if (!$versiononly && !$nonono && -t STDIN && -t STDERR
d262 3
a264 3
    local($usrbinperl)	= "$mainperldir/perl$exe_ext";
    local($instperl)	= "$installbin/perl$exe_ext";
    local($expinstperl)	= "$binexp/perl$exe_ext";
d282 1
a282 1
    {	
d284 5
a288 3
	eval { CORE::link $instperl, $usrbinperl } ||
	    eval { symlink $expinstperl, $usrbinperl } ||
		copy($instperl, $usrbinperl);
a294 7
if (! $versiononly && ! samepath($installbin, '.')) {
    safe_unlink("$installbin/perl$exe_ext", "$installbin/suidperl$exe_ext");
    link("$installbin/perl$ver$exe_ext", "$installbin/perl$exe_ext");
    link("$installbin/sperl$ver$exe_ext", "$installbin/suidperl$exe_ext") 
      if $d_dosuid;
}

d326 6
a331 2
    safe_unlink("$installscript/pstruct");
    link("$installscript/c2ph","$installscript/pstruct");
d336 1
a336 1
if (! $versiononly || !($installprivlib =~ m/\Q$]/)) {
d354 1
a354 1
    foreach $file (@@pods) {
a358 8
    # Link perldiag.pod into archlib
    my ($from, $to) = ("${installprivlib}/pod/perldiag.pod",
		       "${installarchlib}/pod/perldiag.pod");
    if (compare($from, $to) || $nonono) {
	mkpath("${installarchlib}/pod", 1, 0777);
	unlink($to);
	link($from, $to);
    }
d368 2
a369 2

    $dirsep = ($^O eq 'os2') ? ';' : ':' ;
d372 8
a379 1
    @@otherperls = ();
d386 2
a387 2
	push(@@otherperls, "$_/perl$exe_ext")
	    if (-x "$_/perl$exe_ext" && ! -d "$_/perl$exe_ext");
d390 1
a390 1
	print STDERR "\nWarning: perl appears in your path in the following " .
d400 1
d408 3
a410 3
    local($prompt) = @@_;
    local($answer);
    local($default) = $prompt =~ m/\[([yn])\]\s*$/i;
d418 1
a418 1
    local(@@names) = @@_;
d421 3
a423 1
    foreach $name (@@names) {
d425 1
a425 1
	chmod 0777, $name if $^O eq 'os2';
d434 3
a436 3
    return if $nonono;
    local @@names = @@_;
    foreach $name (@@names) {
d438 1
a438 1
	chmod 0777, $name if $^O eq 'os2';
d451 1
a451 1
    local($from,$to) = @@_;
d476 1
d479 1
d484 1
a488 9
sub cmd {
    my($cmd) = @@_;
    print STDERR "  $cmd\n";
    unless ($nonono) {
	system $cmd;
	warn "Command failed!!!\n" if $?;
    }
}

d490 1
a490 1
    local($mode,$name) = @@_;
d492 1
d503 1
d507 1
d511 3
a513 2
    local($p1, $p2) = @@_;
    local($dev1, $ino1, $dev2, $ino2);
d516 1
d545 3
a547 1
	  ($name =~ /^(.*)\.(?:pm|pod)$/ && $archpms{$1})) {
d563 1
a572 2
    } elsif (-d $_) {
	mkpath("$installlib/$name", 1, 0777);
d588 1
d590 1
d598 1
a598 1
	if (!$nonono && ($^O eq 'os2' || $to =~ /\.a$/)) {
@


1.6
log
@respect ``INSTALL_STRIP=-s'' completely pr 188
@
text
@d2 1
a2 1
#	$OpenBSD: installperl,v 1.5 1997/07/24 21:12:15 kstailey Exp $
d7 6
a12 1
BEGIN { @@INC=('./lib', '../lib') }
d14 3
a16 1
use File::Path qw(mkpath);
d18 6
a23 1
use subs qw(unlink rename link chmod);
d36 2
a37 3
@@scripts = qw(cppstdin
		utils/c2ph utils/h2ph utils/h2xs utils/pstruct
		utils/perlbug utils/perldoc
d41 1
a41 3
# pod documentation now handled by separate installman script.
# These two are archaic leftovers.
#@@manpages = qw(x2p/a2p.man x2p/s2p.man);
d43 7
a49 1
@@pods = (<pod/*.pod>);
d59 1
d61 1
a61 2
    # Fetch some frequently-used items from %Config, prefixing them with
    # DESTDIR.
d72 1
a72 1
    # Fetch some frequently-used items from %Config.
d79 1
d81 1
d83 1
a83 3
# Did we build libperl as a shared library?
$d_shrplib = $Config{d_shrplib};
$shrpdir = $Config{shrpdir};
d97 2
a98 2
-d $installbin		|| die "$installbin is not a directory\n";
-w $installbin		|| die "$installbin is not writable by you\n"
a106 11
if ($d_shrplib) {
    if (!<libperl*.$so*>) {
	warn "WARNING: Can't find libperl*.$so* to install into $shrpdir.",
	    "  (Installing other things anyway.)\n";
    } else {
	mkpath($shrpdir, 1, 0777);
	-w $shrpdir	|| $nonono || die "$shrpdir is not writable by you\n";
	&cmd("cp libperl*.$so* $shrpdir");
    }
}

d109 2
a110 1
$installcmd = $ENV{"INSTALL"}
d113 3
d117 4
a120 2
&safe_unlink("$installbin/perl$ver$exe_ext");
&cmd("$installcmd perl$exe_ext $installbin/perl$ver$exe_ext");
d122 1
a122 1
&safe_unlink("$installbin/sperl$ver$exe_ext");
d124 3
a126 19
    &cmd("cp suidperl$exe_ext $installbin/sperl$ver$exe_ext");
    &chmod(04711, "$installbin/sperl$ver$exe_ext");
}

exit 0 if $versiononly;

# Make links to ordinary names if installbin directory isn't current directory.

if (! &samepath($installbin, '.')) {
    &safe_unlink("$installbin/perl$exe_ext", "$installbin/suidperl$exe_ext");
    &link("$installbin/perl$ver$exe_ext", "$installbin/perl$exe_ext");
    &link("$installbin/sperl$ver$exe_ext", "$installbin/suidperl$exe_ext") 
      if $d_dosuid;
}

if (! &samepath($installbin, 'x2p')) {
    &safe_unlink("$installbin/a2p$exe_ext");
    &cmd("$installcmd x2p/a2p$exe_ext $installbin");
    &chmod(0755, "$installbin/a2p$exe_ext");
a128 42
# Install scripts.

mkpath($installscript, 1, 0777);

for (@@scripts) {
    if (-f $_) {   # cppstdin might not exist on this system.
	&cmd("cp $_ $installscript");
	s#.*/##; &chmod(0755, "$installscript/$_");
    }
}

# Install pod pages.  Where? I guess in $installprivlib/pod.
mkpath("${installprivlib}/pod", 1, 0777);
foreach $file (@@pods) {
    # $file is a name like  pod/perl.pod
    cp_if_diff($file, "${installprivlib}/${file}");
}

# Install old man pages.

#if ($installman1dir ne '') {
#    mkpath($installman1dir, 1, 0777);
#
#    if (! &samepath($installman1dir, '.')) {
#	for (@@manpages) {
#	    ($new = $_) =~ s/man$/$man1ext/;
#	    $new =~ s#.*/##;
#	    print STDERR "  Installing $installman1dir/$new\n";
#	    next if $nonono;
#	    open(MI,$_) || warn "Can't open $_: $!\n";
#	    open(MO,">$installman1dir/$new") || 
#		    warn "Can't install $installman1dir/$new: $!\n";
#	    print MO ".ds RP Release $release Patchlevel $patchlevel\n";
#	    while (<MI>) {
#		print MO;
#	    }
#	    close MI;
#	    close MO;
#	}
#    }
#}

d139 3
a141 2
    $do_installarchlib = ! &samepath($installarchlib, '.');
    $do_installprivlib = ! &samepath($installprivlib, '.');
d154 1
a154 4
foreach $file (<*.h libperl*.*>) {
    cp_if_diff($file,"$installarchlib/CORE/$file");
    &chmod(0444,"$installarchlib/CORE/$file");
}
d156 1
a156 2
cp_if_diff("perl.exp" ,"$installarchlib/CORE/perl.exp") if ($^O eq 'aix');

d158 8
a165 2
cp_if_diff("sperl.o" ,"$installarchlib/CORE/sperl.o") if (-f 'sperl.o');

d171 9
a179 4
if (-w $mainperldir && ! &samepath($mainperldir, $installbin) && !$nonono) {
    # First make sure $mainperldir/perl is not already the same as
    # the perl we just installed
    if (-x "$mainperldir/perl$exe_ext") {
d183 2
a184 1
	    &samepath("$mainperldir/perl$exe_ext", "$installbin/perl$exe_ext") ||
d186 2
a187 2
	      (-l "$mainperldir/perl$exe_ext") &&
	      ((readlink "$mainperldir/perl$exe_ext") eq "$binexp/perl$exe_ext"));
d190 3
a192 4
	(&yn("Many scripts expect perl to be installed as " .
	     "$mainperldir/perl.\n" . 
	     "Do you wish to have $mainperldir/perl be the same as\n" .
	     "$binexp/perl? [y] ")))
d194 4
a197 4
	unlink("$mainperldir/perl$exe_ext");
	eval 'link("$installbin/perl$exe_ext", "$mainperldir/perl$exe_ext")' ||
	eval 'symlink("$binexp/perl$exe_ext", "$mainperldir/perl$exe_ext")' ||
	&cmd("cp $installbin/perl$exe_ext $mainperldir$exe_ext");
d202 79
d287 22
a308 18
$dirsep = ($^O eq 'os2') ? ';' : ':' ;
($path = $ENV{"PATH"}) =~ s:\\:/:g ;
@@path = split(/$dirsep/, $path);
@@otherperls = ();
for (@@path) {
    next unless m,^/,;
    next if ($_ eq $binexp);
    # Use &samepath here because some systems have other dirs linked
    # to $mainperldir (like SunOS)
    next if ($mainperl_is_instperl && &samepath($_, $mainperldir));
    push(@@otherperls, "$_/perl$exe_ext")
      if (-x "$_/perl$exe_ext" && ! -d "$_/perl$exe_ext");
}
if (@@otherperls) {
    print STDERR "\nWarning: perl appears in your path in the following " .
	"locations beyond where\nwe just installed it:\n";
    for (@@otherperls) {
	print STDERR "    ", $_, "\n";
d310 1
a310 1
    print STDERR "\n";
d344 2
a345 2
    local(@@names) = @@_;

a347 1
	next if $nonono;
d354 2
a355 1
	    &rename($name, "$name.old") || warn "Couldn't rename $name: $!\n";
d360 1
a360 10
sub cmd {
    local($cmd) = @@_;
    print STDERR "  $cmd\n";
    unless ($nonono) {
	system $cmd;
	warn "Command failed!!!\n" if $?;
    }
}

sub rename {
d365 1
a365 1
	    last if CORE::rename($to, "$to.$i");
d375 2
a376 1
    local($from,$to) = @@_;
d380 6
a385 1
      CORE::link($from,$to) || warn "Couldn't link $from to $to: $!\n" unless $nonono;
d388 14
a401 2
      system( $cp, $from, $to )
	&& warn "Couldn't copy $from to $to: $!\n" unless $nonono;
d409 12
a420 2
    CORE::chmod($mode,$name) || warn sprintf("Couldn't chmod %o %s: $!\n",$mode,$name)
	unless $nonono;
d440 1
d443 5
d455 2
a456 1
    if ((substr($dir, 0, 4) eq 'auto') || ($name eq 'Config.pm')) {
d464 1
a464 1
	if (/\.al$/ || /\.ix$/) {
d470 1
a470 1
	    &unlink("$installarchlib/$name");
d472 2
a473 3
	system "cmp", "-s", $_, "$installlib/$name";
	if ($?) {
	    &unlink("$installlib/$name");
a474 1
	    cp_if_diff($_, "$installlib/$name");
d477 3
a479 6
	    if ($name =~ /\.(so|$dlext)$/o) {
		&chmod(0555, "$installlib/$name");
	    }
	    else {
		&chmod(0444, "$installlib/$name");
	    }
d494 3
a496 1
sub cp_if_diff {
d499 9
a507 8
    system "cmp", "-s", $from, $to;
    if ($?) {
	my ($atime, $mtime);
	unlink($to);   # In case we don't have write permissions.
	cmd("cp $from $to");
	# Restore timestamps if it's a .a library.
	if ($to =~ /\.a$/) {
	    ($atime, $mtime) = (stat $from)[8,9];
d510 1
@


1.5
log
@respect ``INSTALL_STRIP=-s'' pr 188
@
text
@d2 1
a2 1
#	$OpenBSD: installperl,v 1.4 1996/09/06 17:35:29 downsj Exp $
d105 4
d110 1
a110 1
&cmd("cp perl$exe_ext $installbin/perl$ver$exe_ext");
a129 3
    $installcmd = $ENV{"INSTALL"}
	. " " . $ENV{"INSTALL_COPY"}
	. " " . $ENV{"INSTALL_STRIP"};
@


1.4
log
@More bullshit.
@
text
@d2 1
a2 1
#	$OpenBSD: installperl,v 1.3 1996/08/26 14:06:20 downsj Exp $
d4 1
a4 1
# This is hacked up, in order to support DESTDIR.
d126 3
d130 1
a130 1
    &cmd("cp x2p/a2p$exe_ext $installbin/a2p$exe_ext");
@


1.3
log
@Fix one more variable..
@
text
@d2 1
a2 1
#	$OpenBSD: installperl,v 1.2 1996/08/26 05:31:51 downsj Exp $
d32 1
a32 1
@@manpages = qw(x2p/a2p.man x2p/s2p.man);
d151 21
a171 21
if ($installman1dir ne '') {
    mkpath($installman1dir, 1, 0777);

    if (! &samepath($installman1dir, '.')) {
	for (@@manpages) {
	    ($new = $_) =~ s/man$/$man1ext/;
	    $new =~ s#.*/##;
	    print STDERR "  Installing $installman1dir/$new\n";
	    next if $nonono;
	    open(MI,$_) || warn "Can't open $_: $!\n";
	    open(MO,">$installman1dir/$new") || 
		    warn "Can't install $installman1dir/$new: $!\n";
	    print MO ".ds RP Release $release Patchlevel $patchlevel\n";
	    while (<MI>) {
		print MO;
	    }
	    close MI;
	    close MO;
	}
    }
}
@


1.2
log
@First cut at teaching perl about $DESTDIR. Also add a run of h2ph, creating
the .ph include files.
@
text
@d2 1
a2 1
#	$OpenBSD$
d54 2
@


1.1
log
@Initial revision
@
text
@d2 5
d43 20
a62 8
# Fetch some frequently-used items from %Config
$installbin = $Config{installbin};
$installscript = $Config{installscript};
$installprivlib = $Config{installprivlib};
$installarchlib = $Config{installarchlib};
$installsitelib = $Config{installsitelib};
$installsitearch = $Config{installsitearch};
$installman1dir = $Config{installman1dir};
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d2 1
a2 20

BEGIN {
    require 5.004;
    chdir '..' if !-d 'lib' and -d '..\lib';
    @@INC = 'lib';
    $ENV{PERL5LIB} = 'lib';
}

use strict;
use vars qw($Is_VMS $Is_W32 $Is_OS2 $nonono $versiononly $depth);

BEGIN {
    $Is_VMS = $^O eq 'VMS';
    $Is_W32 = $^O eq 'MSWin32';
    $Is_OS2 = $^O eq 'os2';
    if ($Is_VMS) { eval 'use VMS::Filespec;' }
}

my $scr_ext = ($Is_VMS ? '.Com' : $Is_W32 ? '.bat' : '');

d4 1
a4 4
use File::Compare;
use File::Copy ();
use File::Path ();
use ExtUtils::Packlist;
d6 1
a6 7
use subs qw(unlink link chmod);
use vars qw($packlist);

# override the ones in the rest of the script
sub mkpath {
    File::Path::mkpath(@@_) unless $nonono;
}
d8 2
a9 5
my $mainperldir = "/usr/bin";
my $exe_ext = $Config{exe_ext};

# Allow ``make install PERLNAME=something_besides_perl'':
my $perl = defined($ENV{PERLNAME}) ? $ENV{PERLNAME} : 'perl';
d17 1
a17 1
umask 022 unless $Is_VMS;
d19 4
a22 3
my @@scripts = qw(utils/c2ph utils/h2ph utils/h2xs utils/perlbug utils/perldoc
		utils/pl2pm utils/splain utils/perlcc
		x2p/s2p x2p/find2perl 
d25 9
a33 34
if ($scr_ext) { @@scripts = map { "$_$scr_ext" } @@scripts; }

my @@pods = (<pod/*.pod>);

# Specify here any .pm files that are actually architecture-dependent.
# (Those included with XS extensions under ext/ are automatically
# added later.)
# Now that the default privlib has the full perl version number included,
# we no longer have to play the trick of sticking version-specific .pm 
# files under the archlib directory.
my %archpms = (
    Config => 1, 
);

if ($^O eq 'dos') {
    push(@@scripts,'djgpp/fixpmain');
    $archpms{config} = $archpms{filehand} = 1;
}

if ((-e "testcompile") && (defined($ENV{'COMPILE'})))
{
	push(@@scripts, map("$_.exe", @@scripts));
}

find(sub {
	if ("$File::Find::dir/$_" =~ m{^ext/[^/]+/(.*)\.pm$}) {
	    (my $pm = $1) =~ s{^lib/}{};
	    $archpms{$pm} = 1;
	}
    }, 'ext');

my $ver = $];
my $release = substr($ver,0,3);   # Not used presently.
my $patchlevel = substr($ver,3,2);
d39 11
a49 9
my $installbin = $Config{installbin};
my $installscript = $Config{installscript};
my $installprivlib = $Config{installprivlib};
my $installarchlib = $Config{installarchlib};
my $installsitelib = $Config{installsitelib};
my $installsitearch = $Config{installsitearch};
my $installman1dir = $Config{installman1dir};
my $man1ext = $Config{man1ext};
my $libperl = $Config{libperl};
d51 2
a52 5
my $so = $Config{so};
my $dlext = $Config{dlext};

my $d_dosuid = $Config{d_dosuid};
my $binexp = $Config{binexp};
d54 2
a55 7
if ($Is_VMS) {  # Hang in there until File::Spec hits the big time
    foreach ( \$installbin,     \$installscript,  \$installprivlib,
              \$installarchlib, \$installsitelib, \$installsitearch,
              \$installman1dir ) {
      $$_ = unixify($$_);  $$_ =~ s:/$::;
    }
}
d63 2
a64 2
-d $installbin		|| $nonono || die "$installbin is not a directory\n";
-w $installbin		|| $nonono || die "$installbin is not writable by you\n"
d70 2
a71 3
-x 't/TEST'		|| $Is_W32
			|| warn "WARNING: You've never run 'make test'!!!",
				"  (Installing anyway.)\n";
d73 10
a82 1
if ($Is_W32) {
d84 1
a84 2
my $perldll = 'perl.' . $dlext;
$perldll = 'perlcore.' . $dlext if $Config{'ccflags'} =~ /PERL_OBJECT/i;
d86 2
a87 1
-f $perldll || die "No perl DLL built\n";
d89 5
a93 1
# Install the DLL
d95 9
a103 3
safe_unlink("$installbin/$perldll");
copy("$perldll", "$installbin/$perldll");
chmod(0755, "$installbin/$perldll");
d106 5
a110 2
# This will be used to store the packlist
my $packlist = ExtUtils::Packlist->new("$installarchlib/.packlist");
d112 3
a114 1
# First we install the version-numbered executables.
d116 5
a120 26
if ($Is_VMS) {
    safe_unlink("$installbin/$perl$exe_ext");
    copy("perl$exe_ext", "$installbin/$perl$exe_ext");
    chmod(0755, "$installbin/$perl$exe_ext");
    safe_unlink("$installbin/${perl}shr$exe_ext");
    copy("perlshr$exe_ext", "$installbin/${perl}shr$exe_ext");
    chmod(0755, "$installbin/${perl}shr$exe_ext");
}
elsif ($^O eq 'mpeix') {
    # MPE lacks hard links and requires that executables with special
    # capabilities reside in the MPE namespace.
    safe_unlink("$installbin/perl$ver$exe_ext", $Config{perlpath});
    # Install the primary executable into the MPE namespace as perlpath.
    copy("perl$exe_ext", $Config{perlpath});
    chmod(0755, $Config{perlpath});
    # Create a backup copy with the version number.
    link($Config{perlpath}, "$installbin/perl$ver$exe_ext");
}
elsif ($^O ne 'dos') {
    safe_unlink("$installbin/$perl$ver$exe_ext");
    copy("perl$exe_ext", "$installbin/$perl$ver$exe_ext");
    chmod(0755, "$installbin/$perl$ver$exe_ext");
}
else {
    safe_unlink("$installbin/$perl.exe");
    copy("perl.exe", "$installbin/$perl.exe");
d123 29
a151 4
safe_unlink("$installbin/s$perl$ver$exe_ext");
if ($d_dosuid) {
    copy("suidperl$exe_ext", "$installbin/s$perl$ver$exe_ext");
    chmod(04711, "$installbin/s$perl$ver$exe_ext");
d156 1
a156 1
my ($do_installarchlib, $do_installprivlib) = (0, 0);
d164 2
a165 3
    $do_installarchlib = ! samepath($installarchlib, '.');
    $do_installprivlib = ! samepath($installprivlib, '.');
    $do_installprivlib = 0 if $versiononly && !($installprivlib =~ m/\Q$]/);
d178 3
a180 24
my @@corefiles;
if ($Is_VMS) {  # We did core file selection during build
    my $coredir = "lib/$Config{'arch'}/$]";
    $coredir =~ tr/./_/;
    @@corefiles = <$coredir/*.*>;
}
else {
    @@corefiles = <*.h libperl*.*>;
    # AIX needs perl.exp installed as well.
    push(@@corefiles,'perl.exp') if $^O eq 'aix';
    if ($^O eq 'mpeix') {
        # MPE needs mpeixish.h installed as well.
        mkpath("$installarchlib/CORE/mpeix", 1, 0777);
        push(@@corefiles,'mpeix/mpeixish.h');
    }
    # If they have built sperl.o...
    push(@@corefiles,'sperl.o') if -f 'sperl.o';
}
foreach my $file (@@corefiles) {
    # HP-UX (at least) needs to maintain execute permissions
    # on dynamically-loadable libraries. So we do it for all.
    copy_if_diff($file,"$installarchlib/CORE/$file")
	and chmod($file =~ /\.(so|\Q$dlext\E)$/ ? 0555 : 0444,
		   "$installarchlib/CORE/$file");
d182 2
d185 2
a186 2
# Install main perl executables
# Make links to ordinary names if installbin directory isn't current directory.
a187 12
if (! $versiononly && ! samepath($installbin, '.') && ($^O ne 'dos') && ! $Is_VMS) {
    safe_unlink("$installbin/$perl$exe_ext", "$installbin/suid$perl$exe_ext");
    if ($^O eq 'mpeix') {
	# MPE doesn't support hard links, so use a symlink.
	# We don't want another cloned copy.
        symlink($Config{perlpath}, "$installbin/perl$exe_ext");
    } else {
	link("$installbin/$perl$ver$exe_ext", "$installbin/$perl$exe_ext");
    }
    link("$installbin/s$perl$ver$exe_ext", "$installbin/suid$perl$exe_ext") 
      if $d_dosuid;
}
d191 1
a191 1
my $mainperl_is_instperl = 0;
d193 4
a196 10
if ($Config{installusrbinperl} eq 'define' &&
    !$versiononly && !$nonono && !$Is_W32 && !$Is_VMS && -t STDIN && -t STDERR
	&& -w $mainperldir && ! samepath($mainperldir, $installbin)) {
    my($usrbinperl)	= "$mainperldir/$perl$exe_ext";
    my($instperl)	= "$installbin/$perl$exe_ext";
    my($expinstperl)	= "$binexp/$perl$exe_ext";

    # First make sure $usrbinperl is not already the same as the perl we
    # just installed.
    if (-x $usrbinperl) {
d200 1
a200 2
	    samepath($usrbinperl, $instperl) ||
	    samepath($usrbinperl, $expinstperl) ||
d202 2
a203 2
	      (-l $usrbinperl) &&
	      ((readlink $usrbinperl) eq $expinstperl));
d206 9
a214 10
	(yn("Many scripts expect perl to be installed as $usrbinperl.\n" . 
	     "Do you wish to have $usrbinperl be the same as\n" .
	     "$expinstperl? [y] ")))
    {
	unlink($usrbinperl);
	( $Config{'d_link'} eq 'define' &&
	  eval { CORE::link $instperl, $usrbinperl } )	||
	eval { symlink $expinstperl, $usrbinperl }	||
	copy($instperl, $usrbinperl);

a218 68
# Make links to ordinary names if installbin directory isn't current directory.

if (!$versiononly && ! samepath($installbin, 'x2p')) {
    safe_unlink("$installbin/a2p$exe_ext");
    copy("x2p/a2p$exe_ext", "$installbin/a2p$exe_ext");
    chmod(0755, "$installbin/a2p$exe_ext");
}

# cppstdin is just a script, but it is architecture-dependent, so
# it can't safely be shared.  Place it in $installbin.
# Note that Configure doesn't build cppstin if it isn't needed, so
# we skip this if cppstdin doesn't exist.
if (! $versiononly && (-f 'cppstdin') && (! samepath($installbin, '.'))) {
    safe_unlink("$installbin/cppstdin");
    copy("cppstdin", "$installbin/cppstdin");
    chmod(0755, "$installbin/cppstdin");
}

# Install scripts.

mkpath($installscript, 1, 0777);

if (! $versiononly) {
    for (@@scripts) {
	(my $base = $_) =~ s#.*/##;
	copy($_, "$installscript/$base");
	chmod(0755, "$installscript/$base");
    }
}

# pstruct should be a link to c2ph

if (! $versiononly) {
    safe_unlink("$installscript/pstruct$scr_ext");
    if ($^O eq 'dos' or $Is_VMS) {
        copy("$installscript/c2ph$scr_ext", "$installscript/pstruct$scr_ext"); 
    } else {
        link("$installscript/c2ph$scr_ext", "$installscript/pstruct$scr_ext");
    }
}

# Install pod pages.  Where? I guess in $installprivlib/pod.

unless ( $versiononly && !($installprivlib =~ m/\Q$]/)) {     # as line 200
    mkpath("${installprivlib}/pod", 1, 0777);

    # If Perl 5.003's perldiag.pod is there, rename it.
    if (open POD, "${installprivlib}/pod/perldiag.pod") {
	read POD, $_, 4000;
	close POD;
	# Some of Perl 5.003's diagnostic messages ended with periods.
	if (/^=.*\.$/m) {
	    my ($from, $to) = ("${installprivlib}/pod/perldiag.pod",
			       "${installprivlib}/pod/perldiag-5.003.pod");
	    print STDERR "  rename $from $to";
	    rename($from, $to)
		or warn "Couldn't rename $from to $to: $!\n"
		unless $nonono;
	}
    }

    foreach my $file (@@pods) {
	# $file is a name like  pod/perl.pod
	copy_if_diff($file, "${installprivlib}/${file}");
    }

}

d225 18
a242 29
if (!$versiononly) {
	my ($path, @@path);
    my $dirsep = ($Is_OS2 || $Is_W32) ? ';' : ':' ;
    ($path = $ENV{"PATH"}) =~ s:\\:/:g ;
    @@path = split(/$dirsep/, $path);
    if ($Is_VMS) {
        my $i = 0;
        while (exists $ENV{'DCL$PATH' . $i}) {
            my $dir = unixpath($ENV{'DCL$PATH' . $i});  $dir =~ s-/$--;
            push(@@path,$dir);
        }
    }
    my @@otherperls;
    for (@@path) {
	next unless m,^/,;
	# Use &samepath here because some systems have other dirs linked
	# to $mainperldir (like SunOS)
	next if samepath($_, $binexp);
	next if ($mainperl_is_instperl && samepath($_, $mainperldir));
	push(@@otherperls, "$_/$perl$exe_ext")
	    if (-x "$_/$perl$exe_ext" && ! -d "$_/$perl$exe_ext");
    }
    if (@@otherperls) {
	print STDERR "\nWarning: $perl appears in your path in the following " .
	    "locations beyond where\nwe just installed it:\n";
	for (@@otherperls) {
	    print STDERR "    ", $_, "\n";
	}
	print STDERR "\n";
d244 1
a244 1

a246 1
$packlist->write() unless $nonono;
d254 3
a256 3
    my($prompt) = @@_;
    my($answer);
    my($default) = $prompt =~ m/\[([yn])\]\s*$/i;
d264 1
a264 1
    my(@@names) = @@_;
d267 1
a267 3
    return scalar(@@names) if $Is_VMS;

    foreach my $name (@@names) {
d269 1
a269 1
	chmod 0777, $name if ($Is_OS2 || $Is_W32);
d278 3
a280 3
    return if $nonono or $Is_VMS;
    my @@names = @@_;
    foreach my $name (@@names) {
d282 2
a283 1
	chmod 0777, $name if ($Is_OS2 || $Is_W32);
d289 1
a289 2
	    safe_rename($name, "$name.old")
		or warn "Couldn't rename $name: $!\n";
d294 11
a304 2
sub safe_rename {
    my($from,$to) = @@_;
d308 1
a308 1
	    last if rename($to, "$to.$i");
d318 1
a318 2
    my($from,$to) = @@_;
    my($success) = 0;
d322 1
a322 7
	CORE::link($from, $to)
	    ? $success++
	    : ($from =~ m#^/afs/# || $to =~ m#^/afs/#)
	      ? die "AFS"  # okay inside eval {}
	      : warn "Couldn't link $from to $to: $!\n"
	  unless $nonono;
        $packlist->{$to} = { from => $from, type => 'link' };
d325 2
a326 6
	print STDERR "  creating new version of $to\n" if $Is_VMS and -e $to;
	File::Copy::copy($from, $to)
	    ? $success++
	    : warn "Couldn't copy $from to $to: $!\n"
	  unless $nonono;
        $packlist->{$to} = { type => 'file' };
a327 1
    $success;
d331 1
a331 1
    my($mode,$name) = @@_;
a332 1
    return if ($^O eq 'dos');
d334 2
a335 14
    CORE::chmod($mode,$name)
	|| warn sprintf("Couldn't chmod %o %s: $!\n", $mode, $name)
      unless $nonono;
}

sub copy {
    my($from,$to) = @@_;

    print STDERR "  cp $from $to\n";
    print STDERR "  creating new version of $to\n" if $Is_VMS and -e $to;
    File::Copy::copy($from, $to)
	|| warn "Couldn't copy $from to $to: $!\n"
      unless $nonono;
    $packlist->{$to} = { type => 'file' };
d339 2
a340 3
    my($p1, $p2) = @@_;

    return (lc($p1) eq lc($p2)) if $Is_W32;
a342 1
	my($dev1, $ino1, $dev2, $ino2);
a354 1
    local($depth) = $dir ? "lib/$dir" : "lib";
a356 5

    if ($name eq 'CVS' && -d $name) {
	$File::Find::prune = 1;
	return;
    }
d364 1
a364 4
    if ($dir =~ /^auto/ ||
	  ($name =~ /^(.*)\.(?:pm|pod)$/ && $archpms{$1}) ||
	  ($name =~ /^(.*)\.(?:h|lib)$/i && $Is_W32)
       ) {
d372 1
a372 1
	if (/\.(?:al|ix)$/ && !($dir =~ m[^auto/(.*)$] && $archpms{$1})) {
d378 1
a378 1
	    unlink("$installarchlib/$name");
d380 3
a382 3
        $packlist->{"$installlib/$name"} = { type => 'file' };
	if (compare($_, "$installlib/$name") || $nonono) {
	    unlink("$installlib/$name");
d384 1
d387 6
a392 3
	    copy_if_diff($_, "$installlib/$name")
		and chmod($name =~ /\.(so|$dlext)$/o ? 0555 : 0444,
			   "$installlib/$name");
d394 2
d407 1
a407 3
# Return true if copying occurred.

sub copy_if_diff {
a408 1
    return 1 if (($^O eq 'VMS') && (-d $from));
d410 8
a417 10
    $packlist->{$to} = { type => 'file' };
    if (compare($from, $to) || $nonono) {
	safe_unlink($to);   # In case we don't have write permissions.
        if ($nonono) {
            $from = $depth . "/" . $from if $depth;
        }
	copy($from, $to);
	# Restore timestamps if it's a .a library or for OS/2.
	if (!$nonono && ($Is_OS2 || $to =~ /\.a$/)) {
	    my ($atime, $mtime) = (stat $from)[8,9];
a419 1
	1;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d11 1
a11 1
use vars qw($Is_VMS $Is_W32 $Is_OS2 $Is_Cygwin $nonono $dostrip $versiononly $depth);
a16 1
    $Is_Cygwin = $^O eq 'cygwin';
a41 8
# This is the base used for versioned names, like "perl5.6.0".
# It's separate because a common use of $PERLNAME is to install
# perl as "perl5", if that's used as base for versioned files you
# get "perl55.6.0".
my $perl_verbase = defined($ENV{PERLNAME_VERBASE})
		    ? $ENV{PERLNAME_VERBASE}
		    : $perl;

a43 1
    $dostrip = 1 if $ARGV[0] eq '-s';
d48 2
d51 1
a51 1
		utils/pl2pm utils/splain utils/perlcc utils/dprofpp
d53 1
a53 2
		pod/pod2man pod/pod2html pod/pod2latex pod/pod2text
		pod/pod2usage pod/podchecker pod/podselect);
d80 3
a82 17
	if ("$File::Find::dir/$_" =~ m{^ext\b(.*)/([^/]+)\.pm$}) {
	    my($path, $modname) = ($1,$2);

	    # strip trailing component first
	    $path =~ s{/[^/]*$}{};

	    # strip optional "/lib";
	    $path =~ s{/lib\b}{};

	    # strip any leading /
	    $path =~ s{^/}{};

	    # reconstitute canonical module name
	    $modname = "$path/$modname" if length $path;

	    # remember it
	    $archpms{$modname} = 1;
d86 3
a88 5
# print "[$_]\n" for sort keys %archpms;

my $ver = $Config{version};
my $release = substr($],0,3);   # Not used presently.
my $patchlevel = substr($],3,2);
d90 2
a91 2
    "and patchlevel of config.sh ($Config{'PERL_VERSION'}) don't match\n"
	if $patchlevel != $Config{'PERL_VERSION'};
a105 1
my $dlsrc = $Config{dlsrc};
d135 4
a138 2
if ($Is_W32 or $Is_Cygwin) {
  my $perldll;
d140 1
a140 14
if ($Is_Cygwin) {
  $perldll = $libperl;
  $perldll =~ s/(\..*)?$/.$dlext/;
  if ($Config{useshrplib} eq 'true') {
    # install ld2 and perlld as well
    foreach ('ld2', 'perlld') {
      safe_unlink("$installbin/$_");
      copy("$_", "$installbin/$_");
      chmod(0755, "$installbin/$_");
    };
  };
} else {
  $perldll = 'perl56.' . $dlext;
}
a141 3
   if ($dlsrc ne "dl_none.xs") {
      -f $perldll || die "No perl DLL built\n";
   }
d144 4
a147 5
   safe_unlink("$installbin/$perldll");
   copy("$perldll", "$installbin/$perldll");
   chmod(0755, "$installbin/$perldll");
   
} # if ($Is_W32 or $Is_Cygwin)
d173 3
a175 4
    safe_unlink("$installbin/$perl_verbase$ver$exe_ext");
    copy("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext");
    strip("$installbin/$perl_verbase$ver$exe_ext");
    chmod(0755, "$installbin/$perl_verbase$ver$exe_ext");
d182 1
a182 1
safe_unlink("$installbin/s$perl_verbase$ver$exe_ext");
d184 2
a185 2
    copy("suidperl$exe_ext", "$installbin/s$perl_verbase$ver$exe_ext");
    chmod(04711, "$installbin/s$perl_verbase$ver$exe_ext");
d200 1
a200 1
    $do_installprivlib = 0 if $versiononly && !($installprivlib =~ m/\Q$ver/);
d215 1
a215 1
    my $coredir = "lib/$Config{'arch'}/$ver";
d217 1
a217 1
    @@corefiles = map { s|^$coredir/||i; } <$coredir/*.*>;
a219 1
    # [als] hard-coded 'libperl' name... not good!
a220 1

d234 3
a236 8
    if (copy_if_diff($file,"$installarchlib/CORE/$file")) {
	if ($file =~ /\.(\Q$so\E|\Q$dlext\E)$/) {
	    chmod(0555, "$installarchlib/CORE/$file");
	    strip("-S", "$installarchlib/CORE/$file") if $^O =~ /^(rhapsody|darwin)$/;
	} else {
	    chmod(0444, "$installarchlib/CORE/$file");
	}
    }
d249 1
a249 2
	link("$installbin/$perl_verbase$ver$exe_ext",
		"$installbin/$perl$exe_ext");
d251 1
a251 2
    link("$installbin/s$perl_verbase$ver$exe_ext",
	    "$installbin/suid$perl$exe_ext") 
d327 1
a327 1
    if ($^O eq 'dos' or $Is_VMS or $^O eq 'transit') {
d334 1
a334 2
# Install pod pages.  Where? I guess in $installprivlib/pod
# ($installprivlib/pods for cygwin).
d336 2
a337 3
my $pod = $Is_Cygwin ? 'pods' : 'pod';
unless ( $versiononly && !($installprivlib =~ m/\Q$ver/)) {
    mkpath("${installprivlib}/$pod", 1, 0777);
d340 1
a340 1
    if (open POD, "${installprivlib}/$pod/perldiag.pod") {
d345 3
a347 3
	    my ($from, $to) = ("${installprivlib}/$pod/perldiag.pod",
			       "${installprivlib}/$pod/perldiag-5.003.pod");
	    print "  rename $from $to";
d354 3
a356 4
    for (@@pods) {
	# $_ is a name like  pod/perl.pod
        (my $base = $_) =~ s#.*/##;
	copy_if_diff($_, "${installprivlib}/$pod/${base}");
d368 1
a368 1
    my ($path, @@path);
a379 1
    my %otherperls;
d386 2
a387 4
        my $otherperl = "$_/$perl$exe_ext";
	next if $otherperls{$otherperl}++;
	push(@@otherperls, $otherperl)
	    if (-x $otherperl && ! -d $otherperl);
d401 1
a401 1
print "  Installation complete\n";
d411 1
a411 1
    print $prompt;
d425 2
a426 2
	chmod 0777, $name if ($Is_OS2 || $Is_W32 || $Is_Cygwin);
	print "  unlink $name\n";
d439 1
a439 1
	print "  unlink $name\n";
d443 1
a443 1
	    print "  mv $name $name.old\n";
d468 1
a468 1
    print "  ln $from $to\n";
d474 1
a474 1
	      : die "Couldn't link $from to $to: $!\n"
d479 1
a479 3
	warn $@@;
	print "  cp $from $to\n";
	print "  creating new version of $to\n" if $Is_VMS and -e $to;
d493 1
a493 1
    printf "  chmod %o %s\n", $mode, $name;
d502 2
a503 2
    print "  cp $from $to\n";
    print "  creating new version of $to\n" if $Is_VMS and -e $to;
d533 1
a533 2
    # Ignore RCS and CVS directories.
    if (($name eq 'CVS' or $name eq 'RCS') and -d $name) {
d538 2
a539 3
    # ignore patch backups, RCS files, emacs backup & temp files and the
    # .exists files.
    return if $name =~ m{\.orig$|~$|^#.+#$|,v$|^\.exists};
d589 1
a589 1
    -f $from || warn "$0: $from not found";
a604 22

sub strip
{
    my(@@args) = @@_;

    return unless $dostrip;

    my @@opts;
    while (@@args && $args[0] =~ /^(-\w+)$/) {
        push @@opts, shift @@args;
    }

    foreach my $file (@@args) {
        if (-f $file) {
            print "  strip $file\n";
            system("strip", @@opts, $file);
        } else {
            print "# file '$file' skipped\n";
        }
    }
}

@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d11 1
a11 3
my ($Is_VMS, $Is_W32, $Is_OS2, $Is_Cygwin, $nonono, $dostrip,
    $versiononly, $silent, $verbose, $otherperls);
use vars qw /$depth/;
d30 1
a50 1
$otherperls = 1;
a54 3
    $silent = 1 if $ARGV[0] eq '-S';
    $otherperls = 0 if $ARGV[0] eq '-o';
    $verbose = 1 if $ARGV[0] eq '-V' || $ARGV [0] eq '-n';
a57 2
$versiononly = 1 if $Config{versiononly};

d112 1
a112 1
my $release = substr($],0,3);   # Not used currently.
a131 9
if ($^O eq 'os390') {
    my $usedl = $Config{usedl};
    if ($usedl eq 'define') {
        my $pwd;
        chomp($pwd=`pwd`);
        my $archlibexp = $Config{archlibexp};
        `./$^X -p -e 's{$pwd\/libperl.x}{$archlibexp/CORE/libperl.x}' lib/Config.pm`;
    }
}
d149 1
a149 1
-d $installbin		|| mkpath($installbin, $verbose, 0777);
d157 1
a157 1
-f 't/rantests'		|| $Is_W32
d164 9
a172 10
  if ($Is_Cygwin) {
    $perldll = $libperl;
    $perldll =~ s/(\..*)?$/.$dlext/;
    if ($Config{useshrplib} eq 'true') {
      # install ld2 and perlld as well
      foreach ('ld2', 'perlld') {
        safe_unlink("$installbin/$_");
        copy("$_", "$installbin/$_");
        chmod(0755, "$installbin/$_");
      };
d174 13
a186 12
  } else {
    $perldll = 'perl56.' . $dlext;
  }

  if ($dlsrc ne "dl_none.xs") {
    -f $perldll || die "No perl DLL built\n";
  }
  # Install the DLL

  safe_unlink("$installbin/$perldll");
  copy("$perldll", "$installbin/$perldll");
  chmod(0755, "$installbin/$perldll");
d234 4
a237 4
mkpath($installprivlib, $verbose, 0777);
mkpath($installarchlib, $verbose, 0777);
mkpath($installsitelib, $verbose, 0777) if ($installsitelib);
mkpath($installsitearch, $verbose, 0777) if ($installsitearch);
d254 1
a254 1
mkpath("$installarchlib/CORE", $verbose, 0777);
d257 1
a257 1
    my $coredir = "lib/$Config{archname}/$ver/CORE";
d259 1
a259 1
    map { s|^$coredir/||i; } @@corefiles = <$coredir/*.*>;
d269 1
a269 1
        mkpath("$installarchlib/CORE/mpeix", $verbose, 0777);
d310 1
a310 1
if ($Config{installusrbinperl} && $Config{installusrbinperl} eq 'define' &&
d362 1
a362 2
if (! $versiononly) {
    # Install scripts.
d364 1
a364 1
    mkpath($installscript, $verbose, 0777);
d366 1
d372 1
d374 3
a376 1
    # pstruct should be a link to c2ph
d379 1
a379 2
	copy("$installscript/c2ph$scr_ext",
	     "$installscript/pstruct$scr_ext"); 
d381 1
a381 2
	link("$installscript/c2ph$scr_ext",
	     "$installscript/pstruct$scr_ext");
d389 2
a390 2
if ( !$versiononly || ($installprivlib =~ m/\Q$ver/)) {
    mkpath("${installprivlib}/$pod", $verbose, 0777);
d421 1
a421 1
if (!$versiononly && $otherperls) {
d447 1
a447 1
	warn "\nWarning: $perl appears in your path in the following " .
d450 1
a450 1
	    warn "    ", $_, "\n";
d452 1
a452 1
	warn "\n";
d458 1
a458 1
print "  Installation complete\n" if $verbose;
d468 1
a468 1
    warn $prompt;
d483 1
a483 1
	print "  unlink $name\n" if $verbose;
d496 1
a496 1
	print "  unlink $name\n" if $verbose;
d500 1
a500 1
	    print "  mv $name $name.old\n" if $verbose;
d525 1
a525 1
    print $verbose ? "  ln $from $to\n" : "  $to\n" unless $silent;
d537 2
a538 3
        print $verbose ? "  cp $from $to\n" : "  $to\n" unless $silent;
	print "  creating new version of $to\n"
                 if $Is_VMS and -e $to and !$silent;
d552 1
a552 1
    printf "  chmod %o %s\n", $mode, $name if $verbose;
d561 2
a562 2
    print $verbose ? "  cp $from $to\n" : "  $to\n" unless $silent;
    print "  creating new version of $to\n" if $Is_VMS and -e $to and !$silent;
d627 1
a627 1
	    mkpath("$installlib/$dir", $verbose, 0777);
d680 1
a680 1
            print "  strip $file\n" if $verbose;
d683 1
a683 1
            print "# file '$file' skipped\n" if $verbose;
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d11 2
a12 3
my ($Is_VMS, $Is_W32, $Is_OS2, $Is_Cygwin, $Is_Darwin,
    $nonono, $dostrip, $versiononly, $silent, $verbose,
    $otherperls, $archname,$Is_NetWare, $nwinstall, $nopods);
a19 1
    $Is_Darwin = $^O eq 'darwin';
a32 10
if ($Config{d_umask}) {
    umask(022); # umasks like 077 aren't that useful for installations
}

$Is_NetWare = $Config{osname} eq 'NetWare';
if ($Is_NetWare) {
	$Is_W32 = 0;
	$scr_ext = '.pl';
}

a56 1
    $versiononly = 0 if $ARGV[0] eq '+v';
a59 22
    $archname = 1 if $ARGV[0] eq '-A';
	$nwinstall = 1 if $ARGV[0] eq '-netware';
    $nopods = 1 if $ARGV[0] eq '-p';
    if ($ARGV[0] eq '-?' or $ARGV[0] =~ /^-?-h/) {
      print <<"EOT";
Usage $0: [switches]
  -n	    Don't actually run any commands; just print them.
  -s        Run strip on installed binaries.
  -v        Only install perl as a binary with the version number in the name.
            (Override whatever config.sh says)
  +v        Install perl as "perl" and as a binary with the version number in
            the name.  (Override whatever config.sh says)
  -S        Silent mode.
  -o        Skip checking for other copies of perl in your PATH.
  -V        Verbose mode.
  -A        Also install perl with the architecture's name in the perl binary's
            name.
  -p        Don't install the pod files. [This will break use diagnostics;]
  -netware  Install correctly on a Netware server.
EOT
      exit;
    }
d63 7
a69 15
$versiononly = 1 if $Config{versiononly} && !defined $versiononly;
my (@@scripts, @@tolink);
open SCRIPTS, "utils.lst" or die "Can't open utils.lst: $!";
while (<SCRIPTS>) {
    next if /^#/;
    next if /#\s*pod\s*=/; # Binary programs need separate treatment
    chomp;
    if (/(\S*)\s*#\s*link\s*=\s*(\S*)/) {
        push @@scripts, $1;
        push @@tolink, [$1, $2];
    } else {
        push @@scripts, $_;
    }
}
close SCRIPTS;
d73 1
a73 1
my @@pods = $nopods ? () : (<pod/*.pod>);
d79 1
a79 1
# we no longer have to play the trick of sticking version-specific .pm
d82 1
a82 3
    Config => 1,
    lib => 1,
    Cwd => 1,
a139 3
    my $pwd;
    chomp($pwd=`pwd`);
    my $archlibexp = $Config{archlibexp};
d142 4
a145 1
        `./$^X -pibak -e 's{$pwd\/libperl.x}{$archlibexp/CORE/libperl.x}' lib/Config.pm`;
a148 8
if ($nwinstall) {
	# This is required only if we are installing on a NetWare server
	$installscript = $Config{installnwscripts};
	$installprivlib = $Config{installnwlib};
	$installarchlib = $Config{installnwlib};
	$installsitelib = $Config{installnwlib};
}

a169 1
if (!$Is_NetWare) {
d174 2
a175 3
                        || warn "WARNING: You've never run 'make test' or",
                                " some tests failed! (Installing anyway.)\n";
} #if (!$Is_NetWare)
d177 1
a177 1
if (($Is_W32 and ! $Is_NetWare)  or $Is_Cygwin) {
d182 1
a182 3
    my $v_e_r_s = $ver; $v_e_r_s =~ tr/./_/;
    $perldll =~ s/(\..*)?$/$v_e_r_s.$dlext/;
    $perldll =~ s/^lib/cyg/;
a189 12
      { 
		open (LD2, ">$installbin/ld2");
		print LD2 "#!/bin/sh\n#\n# ld wrapper, passes all args to perlld;\n#\n"
		          . "for trythis in $installbin/perl\ndo\n  if [ -x \$trythis ]\n"
		          . "  then\n    \$trythis $installbin/perlld \"\$\@@\"\n"
		          . "    exit \$?\n  fi\ndone\n# hard luck!\necho i see no perl"
		          . " executable around there\necho perl is required to build "
		          . "dynamic libraries\necho look if the path to perl in /bin/ld2"
		          . " is correct\nexit 1\n";
		close LD2;
      };
      chmod(0755, "$installbin/ld2");
d192 1
a192 1
    $perldll = 'perl58.' . $dlext;
d203 2
a204 2

} # if (($Is_W32 and ! $Is_NetWare) or $Is_Cygwin)
d230 4
a233 20
	if (!$Is_NetWare) {
		safe_unlink("$installbin/$perl_verbase$ver$exe_ext");
		copy("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext");
		strip("$installbin/$perl_verbase$ver$exe_ext");
		chmod(0755, "$installbin/$perl_verbase$ver$exe_ext");
	}
	else {
		# If installing onto a NetWare server
		if ($nwinstall) {
			# Copy perl.nlm, echo.nlm, type.nlm, a2p.nlm & cgi2perl.nlm
			mkpath($Config{installnwsystem}, 1, 0777);
			copy("netware\\".$ENV{'MAKE_TYPE'}."\\perl.nlm", $Config{installnwsystem});
			copy("netware\\testnlm\\echo\\echo.nlm", $Config{installnwsystem});
			copy("netware\\testnlm\\type\\type.nlm", $Config{installnwsystem});
			copy("x2p\\a2p.nlm", $Config{installnwsystem});
			chmod(0755, "$Config{installnwsystem}\\perl.nlm");
			mkpath($Config{installnwlcgi}, 1, 0777);
			copy("lib\\auto\\cgi2perl\\cgi2perl.nlm", $Config{installnwlcgi});
		}
	} #if (!$Is_NetWare)
d249 1
a249 1

d296 1
a297 1
           chmod(0555, "$installarchlib/CORE/$file");
a303 11
# Switch in the 5.005-threads versions of he threadsafe queue and semaphore
# modules if so needed.
if ($Config{use5005threads}) {
    for my $m (qw(Queue Semaphore)) {
        my $t = "$installprivlib/Thread/$m.pm";
        unlink $t;
        copy("ext/Thread/$m.pmx", $t);
        chmod(0444, $t);
    }
}

d307 1
a307 1
if (! $versiononly && ! samepath($installbin, '.') && ($^O ne 'dos') && ! $Is_VMS && ! $Is_NetWare) {
a312 4
    } elsif ($^O eq 'vos') {
	# VOS doesn't support hard links, so use a symlink.
        symlink("$installbin/$perl_verbase$ver$exe_ext",
                "$installbin/$perl$exe_ext");
d318 1
a318 1
	    "$installbin/suid$perl$exe_ext")
a321 19
# For development purposes it can be very useful to have multiple perls
# build for different "architectures" (eg threading or not) simultaneously.
if ($archname && ! samepath($installbin, '.') && ($^O ne 'dos') && ! $Is_VMS) {
    my $archperl = "$perl_verbase$ver-$Config{archname}$exe_ext";
    safe_unlink("$installbin/$archperl");
    if ($^O eq 'mpeix') {
	# MPE doesn't support hard links, so use a symlink.
	# We don't want another cloned copy.
        symlink($Config{perlpath}, "$installbin/$archperl");
    } elsif ($^O eq 'vos') {
	# VOS doesn't support hard links, so use a symlink.
	symlink("$installbin/$perl_verbase$ver$exe_ext",
		"$installbin/$archperl");
    } else {
	link("$installbin/$perl_verbase$ver$exe_ext",
		"$installbin/$archperl");
    }
}

d327 1
a327 1
    !$versiononly && !$nonono && !$Is_W32 && !$Is_NetWare && !$Is_VMS && -t STDIN && -t STDERR
d345 5
a349 1
    if (! $mainperl_is_instperl) {
d361 5
a365 7
if (!$Is_NetWare) {
	if (!$versiononly && ! samepath($installbin, 'x2p')) {
		safe_unlink("$installbin/a2p$exe_ext");
		copy("x2p/a2p$exe_ext", "$installbin/a2p$exe_ext");
               strip("$installbin/a2p$exe_ext");
		chmod(0755, "$installbin/a2p$exe_ext");
	}
d378 2
a379 15
sub script_alias {
    my ($installscript, $orig, $alias, $scr_ext) = @@_;

    safe_unlink("$installscript/$alias$scr_ext");
    if ($^O eq 'dos' or $Is_VMS or $^O eq 'transit') {
	copy("$installscript/$orig$scr_ext",
	     "$installscript/$alias$scr_ext");
    } elsif ($^O eq 'vos') {
	symlink("$installscript/$orig$scr_ext",
	        "$installscript/$alias$scr_ext");
    } else {
	link("$installscript/$orig$scr_ext",
	     "$installscript/$alias$scr_ext");
    }
}
d381 1
a381 9
# Install scripts.
mkpath($installscript, $verbose, 0777);
if ($versiononly) {
    for (@@scripts) {
	(my $base = $_) =~ s#.*/##;
	$base .= $ver;
	copy($_,    "$installscript/$base");
	chmod(0755, "$installscript/$base");
    }
a382 7
    for (@@tolink) {
        my ($from, $to) = map { "$_$ver" } @@$_;
        (my $frbase = $from) =~ s#.*/##;
        (my $tobase = $to) =~ s#.*/##;
        script_alias($installscript, $frbase, $tobase, $scr_ext);
    }
} else {
d389 8
a396 5
    for (@@tolink) {
        my ($from, $to) = @@$_;
        (my $frbase = $from) =~ s#.*/##;
        (my $tobase = $to) =~ s#.*/##;
        script_alias($installscript, $frbase, $tobase, $scr_ext);
d403 1
a403 1
my $pod = ($Is_Cygwin || $Is_Darwin) ? 'pods' : 'pod';
d438 1
a438 1
    my $dirsep = ($Is_OS2 || $Is_W32 || $Is_NetWare) ? ';' : ':' ;
d483 1
a483 1
    print STDERR $prompt;
d497 1
a497 1
	chmod 0777, $name if ($Is_OS2 || $Is_W32 || $Is_Cygwin || $Is_NetWare);
d499 1
a499 1
	( CORE::unlink($name) and ++$cnt
d510 1
a510 1
	chmod 0777, $name if ($Is_OS2 || $Is_W32 || $Is_NetWare);
d529 1
a529 1
	warn("Cannot rename to `$to.$i': $!"), return 0
d588 1
a588 1
    return (lc($p1) eq lc($p2)) if ($Is_W32 || $Is_NetWare);
d613 1
a613 1

d615 2
a616 5
    # .exists files, .PL files, and .t files.
    return if $name =~ m{\.orig$|~$|^#.+#$|,v$|^\.exists|\.PL$|\.t$} ||
              $dir  =~ m{/t(?:/|$)};
    # ignore the test extensions
    return if $dir =~ m{ext/XS/(?:APItest|Typemap)/};
d623 1
a623 1
	  ($name =~ /^(.*)\.(?:h|lib)$/i && ($Is_W32 || $Is_NetWare))
d646 3
a648 22
           if ($Is_NetWare && !$nwinstall) {
               # Don't copy .nlp,.nlm files, doesn't make sense on Windows and also
               # if copied will give problems when building new extensions.
               # Has to be copied if we are installing on a NetWare server and hence
               # the check !$nwinstall
               if (!(/\.(?:nlp|nlm|bs)$/)) {
                   copy_if_diff($_, "$installlib/$name")
			and chmod($name =~ /\.(so|$dlext)$/o ? 0555 : 0444,
                                 "$installlib/$name");
               }
           } else {
               if (copy_if_diff($_, "$installlib/$name")) {
                   if ($name =~ /\.(so|$dlext)$/o) {
                       strip("-S", "$installlib/$name") if $^O =~ /^(rhapsody|darwin)$/;
                       chmod(0555, "$installlib/$name");
                   } else {
                       strip("-S", "$installlib/$name")
                           if ($name =~ /\.a$/o and $^O =~ /^(rhapsody|darwin)$/);
                       chmod(0444, "$installlib/$name");
                   }
               }
           } #if ($Is_NetWare)
d666 1
a666 12
    my $perlpodbadsymlink;
    if ($from =~ m!^pod/perl[\w-]+\.pod$! &&
	-l $from &&
	! -e $from) {
	# Some Linux implementations have problems traversing over
	# multiple symlinks (when going over NFS?) and fail to read
	# the symlink target.  Combine this with the fact that some
	# of the pod files (the perl$OS.pod) are symlinks (to ../README.$OS),
	# and you end up with those pods not getting installed.
	$perlpodbadsymlink = 1;
    }
    -f $from || $perlpodbadsymlink || warn "$0: $from not found";
a672 3
	if ($perlpodbadsymlink && $from =~ m!^pod/perl(.+)\.pod$!) {
	    $from = "README.$1";
	}
d696 1
a696 5
           if ($verbose) {
               print "  strip " . join(' ', @@opts);
               print " " if (@@opts);
               print "$file\n";
           }
d703 1
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d5 1
a5 1
    chdir '..' if !-d 'lib' and -d '../lib';
d12 2
a13 2
    $nonono, $dostrip, $versiononly, $silent, $verbose, $force,
    $otherperls, $archname, $Is_NetWare, $nwinstall, $nopods);
d41 2
a42 2
    $Is_W32 = 0;
    $scr_ext = '.pl';
a62 10
my $dbg = '';
my $ndbg = '';
if ( $Is_VMS ) {
    if ( defined $Config{usevmsdebug} ) {
        if ( $Config{usevmsdebug} eq 'define' ) {
            $dbg = 'dbg';
            $ndbg = 'ndbg';
        }
    }
}
a64 1
my $destdir = '';
a71 1
    $force = 1 if $ARGV[0] eq '-f';
d74 1
a74 1
    $nwinstall = 1 if $ARGV[0] eq '-netware';
a75 1
    $destdir = $1 if $ARGV[0] =~ /^-?-destdir=(.*)$/;
d77 1
a77 1
	print <<"EOT";
a85 1
  -f        Force installation (don't check if same version is there)
d93 1
a93 1
	exit;
d103 1
a103 2
    s/\s*#\s*pod\s*=.*//; # install script regardless of pod location
    next if /a2p/; # a2p is binary, to be installed separately
d106 2
a107 2
	push @@scripts, $1;
	push @@tolink, [$1, $2];
d109 1
a109 1
	push @@scripts, $_;
d135 3
a137 2
if ((-e "testcompile") && (defined($ENV{'COMPILE'}))) {
    push(@@scripts, map("$_.exe", @@scripts));
d141 2
a142 2
    if ("$File::Find::dir/$_" =~ m{^ext\b(.*)/([^/]+)\.pm$}) {
	my($path, $modname) = ($1,$2);
d144 2
a145 2
	# strip trailing component first
	$path =~ s{/[^/]*$}{};
d147 2
a148 2
	# strip optional "/lib";
	$path =~ s{/lib\b}{};
d150 2
a151 2
	# strip any leading /
	$path =~ s{^/}{};
d153 2
a154 2
	# reconstitute canonical module name
	$modname = "$path/$modname" if length $path;
d156 4
a159 4
	# remember it
	$archpms{$modname} = 1;
    }
}, 'ext');
d171 7
a177 7
my $installbin = "$destdir$Config{installbin}";
my $installscript = "$destdir$Config{installscript}";
my $installprivlib = "$destdir$Config{installprivlib}";
my $installarchlib = "$destdir$Config{installarchlib}";
my $installsitelib = "$destdir$Config{installsitelib}";
my $installsitearch = "$destdir$Config{installsitearch}";
my $installman1dir = "$destdir$Config{installman1dir}";
d190 1
a190 1
	`./$^X -pibak -e 's{$pwd\/libperl.x}{$archlibexp/CORE/libperl.x}' lib/Config.pm`;
d195 5
a199 5
    # This is required only if we are installing on a NetWare server
    $installscript = $Config{installnwscripts};
    $installprivlib = $Config{installnwlib};
    $installarchlib = $Config{installnwlib};
    $installsitelib = $Config{installnwlib};
d207 3
a209 3
	      \$installarchlib, \$installsitelib, \$installsitearch,
	      \$installman1dir ) {
	$$_ = unixify($$_);  $$_ =~ s:/$::;
d215 1
a215 1
if (!$nonono && $d_dosuid && $>) { die "You must run as root to install suidperl\n"; }
a223 1
if (!$Is_VMS) {
a224 7
}
else {
-x $ndbg . 'perl' . $exe_ext	|| die "${ndbg}perl$exe_ext isn't executable!\n";
    if ($dbg) {
        -x $dbg . 'perl' . $exe_ext	|| die "${dbg}perl$exe_ext isn't executable!\n";
    }
}
d228 2
a229 2
			|| warn "WARNING: You've never run 'make test' or",
				" some tests failed! (Installing anyway.)\n";
d232 2
a233 2
if (($Is_W32 and ! $Is_NetWare) or $Is_Cygwin) {
    my $perldll;
d235 37
a271 42
    if ($Is_Cygwin) {
	$perldll = $libperl;
	my $v_e_r_s = $ver; $v_e_r_s =~ tr/./_/;
	$perldll =~ s/(\..*)?$/$v_e_r_s.$dlext/;
	$perldll =~ s/^lib/cyg/;
	if ($Config{useshrplib} eq 'true') {
	    # install ld2 and perlld as well
	    foreach ('ld2', 'perlld') {
		safe_unlink("$installbin/$_");
		copy("$_", "$installbin/$_");
		chmod(0755, "$installbin/$_");
	    };
	    open (LD2, ">$installbin/ld2");
	    print LD2 <<SHELL;
#!/bin/sh
#
# ld wrapper, passes all args to perlld;
#
for trythis in $installbin/perl
do
  if [ -x \$trythis ]
  then
    \$trythis $installbin/perlld "\$\@@"
    exit \$?
  fi
done
# hard luck!
echo I see no perl executable around there
echo perl is required to build dynamic libraries
echo look if the path to perl in /bin/ld2 is correct
exit 1
SHELL
	    close LD2;
	    chmod(0755, "$installbin/ld2");
	};
    } else {
	$perldll = 'perl58.' . $dlext;
    }

    if ($dlsrc ne "dl_none.xs") {
	-f $perldll || die "No perl DLL built\n";
    }
a272 4
    # Install the DLL
    safe_unlink("$installbin/$perldll");
    copy("$perldll", "$installbin/$perldll");
    chmod(0755, "$installbin/$perldll");
d281 6
a286 17
    safe_unlink("$installbin/perl_setup.com");
    copy("perl_setup.com", "$installbin/perl_setup.com");
    chmod(0755, "$installbin/perl_setup.com");
    safe_unlink("$installbin/$dbg$perl$exe_ext");
    copy("$dbg$perl$exe_ext", "$installbin/$dbg$perl$exe_ext");
    chmod(0755, "$installbin/$dbg$perl$exe_ext");
    safe_unlink("$installbin/$dbg${perl}shr$exe_ext");
    copy("$dbg${perl}shr$exe_ext", "$installbin/$dbg${perl}shr$exe_ext");
    chmod(0755, "$installbin/$dbg${perl}shr$exe_ext");
    if ($ndbg) {
        safe_unlink("$installbin/$ndbg$perl$exe_ext");
        copy("$ndbg$perl$exe_ext", "$installbin/$ndbg$perl$exe_ext");
        chmod(0755, "$installbin/$ndbg$perl$exe_ext");
	safe_unlink("$installbin/${dbg}a2p$exe_ext");
	copy("x2p/${dbg}a2p$exe_ext", "$installbin/${dbg}a2p$exe_ext");
	chmod(0755, "$installbin/${dbg}a2p$exe_ext");
    }
d299 20
a318 20
    if (!$Is_NetWare) {
	safe_unlink("$installbin/$perl_verbase$ver$exe_ext");
	copy("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext");
	strip("$installbin/$perl_verbase$ver$exe_ext");
	chmod(0755, "$installbin/$perl_verbase$ver$exe_ext");
    }
    else {
	# If installing onto a NetWare server
	if ($nwinstall) {
	    # Copy perl.nlm, echo.nlm, type.nlm, a2p.nlm & cgi2perl.nlm
	    mkpath($Config{installnwsystem}, 1, 0777);
	    copy("netware\\".$ENV{'MAKE_TYPE'}."\\perl.nlm", $Config{installnwsystem});
	    copy("netware\\testnlm\\echo\\echo.nlm", $Config{installnwsystem});
	    copy("netware\\testnlm\\type\\type.nlm", $Config{installnwsystem});
	    copy("x2p\\a2p.nlm", $Config{installnwsystem});
	    chmod(0755, "$Config{installnwsystem}\\perl.nlm");
	    mkpath($Config{installnwlcgi}, 1, 0777);
	    copy("lib\\auto\\cgi2perl\\cgi2perl.nlm", $Config{installnwlcgi});
	}
    } #if (!$Is_NetWare)
d364 1
a364 1
    @@corefiles = <*.h *.inc libperl*.*>;
d369 3
a371 3
	# MPE needs mpeixish.h installed as well.
	mkpath("$installarchlib/CORE/mpeix", $verbose, 0777);
	push(@@corefiles,'mpeix/mpeixish.h');
d382 1
a382 1
	    chmod(0555, "$installarchlib/CORE/$file");
d393 4
a396 4
	my $t = "$installprivlib/Thread/$m.pm";
	unlink $t;
	copy("ext/Thread/$m.pmx", $t);
	chmod(0444, $t);
d408 1
a408 1
	symlink($Config{perlpath}, "$installbin/perl$exe_ext");
d411 2
a412 2
	symlink("$installbin/$perl_verbase$ver$exe_ext",
		"$installbin/$perl$exe_ext");
d430 1
a430 1
	symlink($Config{perlpath}, "$installbin/$archperl");
d436 2
a437 1
	link("$installbin/$perl_verbase$ver$exe_ext", "$installbin/$archperl");
d476 7
a482 9
if (!$Is_NetWare && $dbg eq '') {
    if (! samepath($installbin, 'x2p')) {
	my $base = 'a2p';
	$base .= $ver if $versiononly;
	safe_unlink("$installbin/$base$exe_ext");
	copy("x2p/a2p$exe_ext", "$installbin/$base$exe_ext");
	strip("$installbin/$base$exe_ext");
	chmod(0755, "$installbin/$base$exe_ext");
    }
d504 1
a504 1
		"$installscript/$alias$scr_ext");
d522 4
a525 4
	my ($from, $to) = map { "$_$ver" } @@$_;
	(my $frbase = $from) =~ s#.*/##;
	(my $tobase = $to) =~ s#.*/##;
	script_alias($installscript, $frbase, $tobase, $scr_ext);
d535 4
a538 4
	my ($from, $to) = @@$_;
	(my $frbase = $from) =~ s#.*/##;
	(my $tobase = $to) =~ s#.*/##;
	script_alias($installscript, $frbase, $tobase, $scr_ext);
d566 1
a566 1
	(my $base = $_) =~ s#.*/##;
d584 5
a588 5
	my $i = 0;
	while (exists $ENV{'DCL$PATH' . $i}) {
	    my $dir = unixpath($ENV{'DCL$PATH' . $i});  $dir =~ s-/$--;
	    push(@@path,$dir);
	}
d598 1
a598 1
	my $otherperl = "$_/$perl$exe_ext";
d682 1
a682 5
    my $xfrom = $from;
    $xfrom =~ s/^\Q$destdir\E// if $destdir;
    my $xto = $to;
    $xto =~ s/^\Q$destdir\E// if $destdir;
    print $verbose ? "  ln $xfrom $xto\n" : "  $xto\n" unless $silent;
d690 1
a690 1
	$packlist->{$xto} = { from => $xfrom, type => 'link' };
d694 3
a696 3
	print $verbose ? "  cp $from $xto\n" : "  $xto\n" unless $silent;
	print "  creating new version of $xto\n"
		 if $Is_VMS and -e $to and !$silent;
d701 1
a701 1
	$packlist->{$xto} = { type => 'file' };
d719 2
a720 4
    my $xto = $to;
    $xto =~ s/^\Q$destdir\E// if $destdir;
    print $verbose ? "  cp $from $xto\n" : "  $xto\n" unless $silent;
    print "  creating new version of $xto\n" if $Is_VMS and -e $to and !$silent;
d724 1
a724 1
    $packlist->{$xto} = { type => 'file' };
d750 2
a751 2
    # Ignore version control directories.
    if (($name eq 'CVS' or $name eq 'RCS' or $name eq '.svn') and -d $name) {
d757 3
a759 7
    # .exists files, .PL files, and test files.
    return if $name =~ m{\.orig$|\.rej$|~$|^#.+#$|,v$|^\.exists|\.PL$|\.plc$|\.t$|^test\.pl$} ||
	      $dir  =~ m{/t(?:/|$)};
    # ignore the cpan script in lib/CPAN/bin (installed later with other utils)
    return if $name eq 'cpan';
    # ignore the Makefiles
    return if $name =~ /^makefile$/i;
d770 1
a770 1
	$installlib = $installarchlib;
d785 2
a786 4
	my $xname = "$installlib/$name";
	$xname =~ s/^\Q$destdir\E// if $destdir;
	$packlist->{$xname} = { type => 'file' };
	if ($force || compare($_, "$installlib/$name") || $nonono) {
d791 7
a797 7
	    if ($Is_NetWare && !$nwinstall) {
		# Don't copy .nlp,.nlm files, doesn't make sense on Windows and also
		# if copied will give problems when building new extensions.
		# Has to be copied if we are installing on a NetWare server and hence
		# the check !$nwinstall
		if (!(/\.(?:nlp|nlm|bs)$/)) {
		    copy_if_diff($_, "$installlib/$name")
d799 14
a812 14
				  "$installlib/$name");
		}
	   } else {
		if (copy_if_diff($_, "$installlib/$name")) {
		    if ($name =~ /\.(so|$dlext)$/o) {
			strip("-S", "$installlib/$name") if $^O =~ /^(rhapsody|darwin)$/;
			chmod(0555, "$installlib/$name");
		    } else {
			strip("-S", "$installlib/$name")
			    if ($name =~ /\.a$/o and $^O =~ /^(rhapsody|darwin)$/);
			chmod(0444, "$installlib/$name");
		    }
		}
	    } #if ($Is_NetWare)
a829 2
    my $xto = $to;
    $xto =~ s/^\Q$destdir\E// if $destdir;
d842 2
a843 2
    $packlist->{$xto} = { type => 'file' };
    if ($force || compare($from, $to) || $nonono) {
d845 3
a847 3
	if ($nonono) {
	    $from = $depth . "/" . $from if $depth;
	}
d869 1
a869 1
	push @@opts, shift @@args;
d873 10
a882 10
	if (-f $file) {
	    if ($verbose) {
		print "  strip " . join(' ', @@opts);
		print " " if (@@opts);
		print "$file\n";
	    }
	    system("strip", @@opts, $file);
	} else {
	    print "# file '$file' skipped\n" if $verbose;
	}
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@a105 1
  -destdir  Prefix installation directories by this string.
d131 1
a131 1
my @@pods = $nopods ? () : (<pod/*.pod>, 'x2p/a2p.pod');
d406 1
a406 1
    @@corefiles = <*.h *.inc libperl*.* perl*$Config{lib_ext}>;
d740 1
a740 1
	warn "Replacing link() with File::Copy::copy(): $@@";
d744 4
a747 6
	unless ($nonono or File::Copy::copy($from, $to) and ++$success) {
	    # Might have been that F::C::c can't overwrite the target
	    warn "Couldn't copy $from to $to: $!\n"
		unless -f $to and (chmod(0666, $to), unlink $to)
			and File::Copy::copy($from, $to) and ++$success;
	}
d770 3
a772 6
    unless ($nonono or File::Copy::copy($from, $to)) {
	# Might have been that F::C::c can't overwrite the target
	warn "Couldn't copy $from to $to: $!\n"
	    unless -f $to and (chmod(0666, $to), unlink $to)
		   and File::Copy::copy($from, $to);
    }
d800 1
a800 1
    if ($name =~ /^(?:CVS|RCS|SCCS|\.svn)\z/ and -d $name) {
d809 2
a810 9

    # XXX xsubpp back out of the list. prove now integrated. Out of order, so
    # p4 will conflict on the next update to the following lines:

    # ignore the cpan script in lib/CPAN/bin, the instmodsh and xsubpp
    # scripts in lib/ExtUtils, and the prove script in lib/Test/Harness
    # (they're installed later with other utils)
    return if $name =~ /^(?:cpan|instmodsh|prove)\z/;

@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d250 3
a252 3
#-f 't/rantests'		|| $Is_W32
#			|| warn "WARNING: You've never run 'make test' or",
#				" some tests failed! (Installing anyway.)\n";
a254 3
# This will be used to store the packlist
my $packlist = ExtUtils::Packlist->new("$installarchlib/.packlist");

a268 1
		$packlist->{"$installbin/$_"} = { type => 'file' };
a304 1
    $packlist->{"$installbin/$perldll"} = { type => 'file' };
d307 2
a308 3
# Get the install command and flags from the environment
my @@installcmd = $ENV{"INSTALL"} || "install";
push(@@installcmd, $ENV{"INSTALL_COPY"} || "-c");
d343 4
a346 2
	install("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext",
	    "0755", $dostrip);
d370 2
a371 2
    install("perl$exe_ext", "$installbin/s$perl_verbase$ver$exe_ext",
	"04711", $dostrip);
d407 1
a407 3
    #@@corefiles = <*.h *.inc libperl*.* perl*$Config{lib_ext}>;
    @@corefiles = <*.h *.inc perl*$Config{lib_ext}>;
    push(@@corefiles,<libperl*.*>) unless defined($ENV{"NOLIBINSTALL"});
d436 4
a439 1
	install("ext/Thread/$m.pmx", "$installprivlib/Thread/$m.pm", "0444");
d460 1
a460 1
    link("$installbin/$perl_verbase$ver$exe_ext",
a777 17
    }
    $packlist->{$xto} = { type => 'file' };
}

sub install {
    my($from,$to,$mode,$strip) = @@_;

    my $xto = $to;
    my $cmd = join(' ', @@installcmd);
    $cmd .= " -m $mode" if $mode;
    $cmd .= " -s" if $strip;
    $cmd .= " $from $to";
    $xto =~ s/^\Q$destdir\E// if $destdir;
    print $verbose ? "  install $from $xto\n" : "  $xto\n" unless $silent;
    unless ($nonono) {
	system($cmd);
	warn "Couldn't $cmd\n" if $?;
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@d250 3
a252 3
-f 't/rantests'		|| $Is_W32
			|| warn "WARNING: You've never run 'make test' or",
				" some tests failed! (Installing anyway.)\n";
d312 4
d349 2
a350 4
	safe_unlink("$installbin/$perl_verbase$ver$exe_ext");
	copy("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext");
	strip("$installbin/$perl_verbase$ver$exe_ext");
	chmod(0755, "$installbin/$perl_verbase$ver$exe_ext");
d374 2
a375 2
    copy("suidperl$exe_ext", "$installbin/s$perl_verbase$ver$exe_ext");
    chmod(04711, "$installbin/s$perl_verbase$ver$exe_ext");
d411 3
a413 1
    @@corefiles = <*.h *.inc libperl*.* perl*$Config{lib_ext}>;
d442 1
a442 4
	my $t = "$installprivlib/Thread/$m.pm";
	unlink $t;
	copy("ext/Thread/$m.pmx", $t);
	chmod(0444, $t);
d781 17
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d591 1
a591 1
my $pod = ($Is_Cygwin || $Is_Darwin || $Is_VMS) ? 'pods' : 'pod';
a829 8
    # ignore the demo files
    return if $dir =~ /\bdemos?\b/;

    # ignore READMEs, MANIFESTs, INSTALL docs, META.ymls and change logs.
    # Changes.e2x and README.e2x are needed by enc2xs.
    return if $name =~ m{^(?:README(?:\.\w+)?|MANIFEST|META\.yml|INSTALL)$} && $name ne 'README.e2x';
    return if $name =~ m{^(?:TODO|BUGS|CREDITS)$}i;
    return if $name =~ m{^change(?:s|log)(?:\.libnet)?$}i;
d836 1
a836 2
	  ($name =~ /^(.*)\.(?:h|lib)$/i && ($Is_W32 || $Is_NetWare)) ||
	  $name eq 'Config_heavy.pl'
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@a9 25
BEGIN {
    use Config;
    if ($Config{userelocatableinc}) {
	# This might be a considered a hack. Need to get information about the
	# configuration from Config.pm *before* Config.pm expands any .../
	# prefixes.
	#
	# So we set $^X to pretend that we're the already installed perl, so
	# Config.pm doesits ... expansion off that location.

	my $location = $Config{initialinstalllocation};
	die <<'OS' unless defined $location;
$Config{initialinstalllocation} is not defined - can't install a relocatable
perl without this.
OS
	$^X = "$location/perl";
	# And then remove all trace of ever having loaded Config.pm, so that
	# it will reload with the revised $^X
	undef %Config::;
	delete $INC{"Config.pm"};
	delete $INC{"Config_heavy.pl"};
	# You never saw us. We weren't here.
    }
}

d159 5
a163 2
	# strip to optional "/lib", or remove trailing component
	$path =~ s{.*/lib\b}{} or $path =~ s{/[^/]*$}{};
d266 31
d298 1
a298 1
	$perldll = 'perl510.' . $dlext;
d409 1
a409 1
    @@corefiles = <*.h libperl*.* perl*$Config{lib_ext}>;
d434 11
d591 1
a591 1
my $pod = ($Is_Cygwin || $Is_Darwin || $Is_VMS || $Is_W32) ? 'pods' : 'pod';
d815 1
a815 1
    return if $name =~ m{\.orig$|\.rej$|~$|^#.+#$|,v$|^\.exists|\.PL$|\.plc$|\.t$|^test\.pl$|^dbm_filter_util.pl$} ||
d817 4
d822 1
a822 3
    # scripts in lib/ExtUtils, the prove script in lib/Test/Harness,
    # the corelist script from lib/Module/CoreList/bin and ptar* in
    # lib/Archive/Tar/bin, the config_data script in lib/Module/Build/scripts
d824 2
a825 1
    return if $name =~ /^(?:cpan|instmodsh|prove|corelist|ptar|cpan2dist|cpanp|cpanp-run-perl|ptardiff|config_data)\z/;
d829 1
a829 2
    return if $dir =~ m{\bXS/(?:APItest|Typemap)\b};
    return if $name =~ m{\b(?:APItest|Typemap)\.pm$};
d831 1
a831 1
    return if $dir =~ /\b(?:demos?|eg)\b/;
d835 2
a836 3
    return if $name =~ m{^(?:README(?:\.\w+)?)$} && $name ne 'README.e2x';
    return if $name =~ m{^(?:MANIFEST|META\.yml)$};
    return if $name =~ m{^(?:INSTALL|TODO|BUGS|CREDITS)$}i;
a837 9
    return if $name =~ m{^(?:SIGNATURE|PAUSE200\d\.pub)$}; # CPAN files
    return if $name =~ m{^(?:NOTES|PATCHING)$}; # ExtUtils files

    # if using a shared perl library then ignore:
    # - static library files [of statically linked extensions];
    # - import library files and export library files (only present on Win32
    #   anyway?) and empty bootstrap files [of dynamically linked extensions].
    return if $Config{useshrplib} eq 'true' and
             ($name =~ /$Config{_a}$/ or $name =~ /\.exp$/ or ($name =~ /\.bs$/ and -z $name));
d854 1
a854 1
	if (/\.(?:al|ix)$/ && !($dir =~ m[^auto/(.*)$])) {
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d1 1
a1 1
#!./perl -w
d8 1
d10 23
a32 2
    # This needs to be at BEGIN time, before any use of Config
    require './install_lib.pl';
d36 3
a38 6
use vars qw($Is_VMS $Is_W32 $Is_OS2 $Is_Cygwin $Is_Darwin $Is_NetWare
	    %opts $packlist);
my ($dostrip, $versiononly, $force,
    $otherperls, $archname, $nwinstall, $nopods);
# Not sure how easy it would be to refactor to remove the need for local $depth
# below
d42 5
d57 6
a62 1
use Cwd;
d64 1
d72 1
a72 1
    File::Path::mkpath(@@_) unless $opts{notify};
d78 1
a78 1
# Allow "make install PERLNAME=something_besides_perl":
d100 1
a100 7
# This little hack simplifies making the code after the comment "Fetch some
# frequently-used items from %Config" warning free. With $opts{destdir} always
# defined, it's also possible to make the s/\Q$opts{destdir}\E unconditional.

$opts{destdir} = '';
# Consider refactoring this to use Getopt::Long once Getopt::Long's planned
# feature is implemented, to distinguish + and - options.
d102 1
a102 1
    $opts{notify} = 1 if $ARGV[0] eq '-n';
d106 1
a106 1
    $opts{silent} = 1 if $ARGV[0] eq '-S';
d109 1
a109 1
    $opts{verbose} = 1 if $ARGV[0] eq '-V' || $ARGV [0] eq '-n';
d113 1
a113 1
    $opts{destdir} = $1 if $ARGV[0] =~ /^-?-destdir=(.*)$/;
a179 3
# Exclude nonxs extensions that are not architecture dependent
my @@nonxs = grep(!/^Errno$/, split(' ', $Config{'nonxs_ext'}));

d181 1
a181 4
    if (($File::Find::name =~ m{^ext\b(.*)/([^/]+)\.pm$}) &&
        ! grep { (my $dir = $_) =~ s/\//-/g;
                 $File::Find::name =~ /^ext\/$dir/ } @@nonxs)
    {
a183 4
	# Change hypenated name like Filter-Util-Call to nested
	# directory name Filter/Util/Call
	$path =~ s{-}{/}g;

d208 7
a214 7
my $installbin = "$opts{destdir}$Config{installbin}";
my $installscript = "$opts{destdir}$Config{installscript}";
my $installprivlib = "$opts{destdir}$Config{installprivlib}";
my $installarchlib = "$opts{destdir}$Config{installarchlib}";
my $installsitelib = "$opts{destdir}$Config{installsitelib}";
my $installsitearch = "$opts{destdir}$Config{installsitearch}";
my $installman1dir = "$opts{destdir}$Config{installman1dir}";
d252 1
a252 1
if (!$opts{notify} && $d_dosuid && $>) { die "You must run as root to install suidperl\n"; }
d255 4
a258 4
-d $installbin		|| mkpath($installbin, $opts{verbose}, 0777);
-d $installbin		|| $opts{notify} || die "$installbin is not a directory\n";
-w $installbin		|| $opts{notify} || die "$installbin is not writable by you\n"
	unless $installbin =~ m#^/afs/# || $opts{notify};
d278 1
a278 1
$packlist = ExtUtils::Packlist->new("$installarchlib/.packlist");
d285 3
d289 1
a289 1
	$perldll = 'perl5'.$Config{patchlevel}.'.'.$dlext;
a369 1
my $vershort = ($Is_Cygwin and !$Config{usedevel}) ? substr($ver,0,-2) : $ver;
d371 4
a374 4
mkpath($installprivlib, $opts{verbose}, 0777);
mkpath($installarchlib, $opts{verbose}, 0777);
mkpath($installsitelib, $opts{verbose}, 0777) if ($installsitelib);
mkpath($installsitearch, $opts{verbose}, 0777) if ($installsitearch);
d379 1
a379 1
    $do_installprivlib = 0 if $versiononly && !($installprivlib =~ m/\Q$vershort/);
d391 1
a391 1
mkpath("$installarchlib/CORE", $opts{verbose}, 0777);
d398 1
a398 20
elsif ($Is_Cygwin) { # On Cygwin symlink it to CORE to make Makefile happy
    @@corefiles = <*.h libperl*.* perl*$Config{lib_ext}>;
    my $coredll = "$installarchlib/CORE/$libperl";
    safe_unlink($coredll);
    ( $Config{'d_link'} eq 'define' &&
      eval {
          CORE::link("$installbin/$libperl", $coredll);
          $packlist->{$coredll} = { from => "$installbin/$libperl",
                                    type => 'link' };
      }
    ) ||
    eval {
        symlink("$installbin/$libperl", $coredll);
        $packlist->{$coredll} = { from => "$installbin/$libperl",
                                  type => 'link' };
    } ||
    ( copy("$installbin/$libperl", $coredll) &&
      push(@@corefiles, $coredll)
    )
} else {
d406 1
a406 1
	mkpath("$installarchlib/CORE/mpeix", $opts{verbose}, 0777);
d470 1
a470 1
    !$versiononly && !$opts{notify} && !$Is_W32 && !$Is_NetWare && !$Is_VMS && -t STDIN && -t STDERR
d538 1
a538 1
mkpath($installscript, $opts{verbose}, 0777);
d572 2
a573 2
if ( !$versiononly || ($installprivlib =~ m/\Q$vershort/)) {
    mkpath("${installprivlib}/$pod", $opts{verbose}, 0777);
d586 1
a586 1
		unless $opts{notify};
a621 1
	next unless -d;
a622 1
	next if samepath($_, cwd());
d640 2
a641 2
$packlist->write() unless $opts{notify};
print "  Installation complete\n" if $opts{verbose};
a646 3
# If these are needed elsewhere, move them into install_lib.pl rather than
# copying them.

d657 16
d674 1
a674 1
    return if $opts{notify} or $Is_VMS;
d679 1
a679 1
	print "  unlink $name\n" if $opts{verbose};
d683 1
a683 1
	    print "  mv $name $name.old\n" if $opts{verbose};
d704 44
d752 4
a755 6
    $xto =~ s/^\Q$opts{destdir}\E//;
    print $opts{verbose} ? "  cp $from $xto\n" : "  $xto\n"
	unless $opts{silent};
    print "  creating new version of $xto\n"
	if $Is_VMS and -e $to and !$opts{silent};
    unless ($opts{notify} or File::Copy::copy($from, $to)) {
d764 16
a828 2
    return if $name eq 'ExtUtils/XSSymSet.pm' and !$Is_VMS;

d830 1
a830 1
    if ($dir =~ /^auto\// ||
d833 1
a833 1
	  $name=~/^Config_(heavy|git)\.pl\z/
d851 1
a851 1
	$xname =~ s/^\Q$opts{destdir}\E//;
d853 1
a853 1
	if ($force || compare($_, "$installlib/$name") || $opts{notify}) {
d855 1
a855 1
	    mkpath("$installlib/$dir", $opts{verbose}, 0777);
d898 1
a898 1
    $xto =~ s/^\Q$opts{destdir}\E//;
d912 1
a912 1
    if ($force || compare($from, $to) || $opts{notify}) {
d914 1
a914 1
	if ($opts{notify}) {
d922 1
a922 1
	if (!$opts{notify} && ($Is_OS2 || $to =~ /\.a$/)) {
d943 1
a943 1
	    if ($opts{verbose}) {
d950 1
a950 1
	    print "# file '$file' skipped\n" if $opts{verbose};
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@d159 16
a174 15
my @@ext_dirs = qw(cpan dist ext);
foreach my $ext_dir (@@ext_dirs) {
    find(sub {
	if (($File::Find::name =~ m{^$ext_dir\b(.*)/([^/]+)\.pm$}) &&
	    ! grep { (my $dir = $_) =~ s/\//-/g;
		     $File::Find::name =~ /^$ext_dir\/$dir\// } @@nonxs)
	{
	    my($path, $modname) = ($1,$2);

	    # Change hypenated name like Filter-Util-Call to nested
	    # directory name Filter/Util/Call
	    $path =~ s{-}{/}g;

	    # strip to optional "/lib", or remove trailing component
	    $path =~ s{.*/lib\b}{} or $path =~ s{/[^/]*$}{};
d176 2
a177 2
	    # strip any leading /
	    $path =~ s{^/}{};
d179 4
a182 8
	    # reconstitute canonical module name
	    $modname = "$path/$modname" if length $path;

	    # remember it
	    $archpms{$modname} = 1;
	}
    }, $ext_dir);
}
d225 1
d238 2
d256 1
d344 6
d445 3
d578 15
d729 1
a729 1
    return if $name =~ m{\.orig$|\.rej$|~$|^#.+#$|,v$|^\.exists|\.PL$|\.plc$|\.t$|^test\.pl$|^dbm_filter_util\.pl$|^filter-util\.pl$|^uupacktool\.pl$|^\.gitignore$} ||
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d18 3
a34 2
require './Porting/pod_lib.pl';

d119 1
d133 2
d168 1
a168 1
	    # Change hyphenated name like Filter-Util-Call to nested
d327 1
a327 1
            mkpath($Config{installnwsystem}, $opts{verbose}, 0777);
d333 1
a333 1
            mkpath($Config{installnwlcgi}, $opts{verbose}, 0777);
d345 1
a345 2
my $do_installarchlib = !samepath($installarchlib, 'lib');
my $do_installprivlib = !samepath($installprivlib, 'lib');
a346 1
$do_installprivlib = 0 if $versiononly && !($installprivlib =~ m/\Q$vershort/);
d353 9
a361 3
if (-d 'lib') {
    find({no_chdir => 1, wanted => \&installlib}, 'lib')
        if $do_installarchlib || $do_installprivlib;
d364 1
a364 1
    warn "Can't install lib files - 'lib/' does not exist";
d405 2
d563 3
a565 2
if (!$nopods && (!$versiononly || ($installprivlib =~ m/\Q$vershort/))) {
    my $pod = ($Is_Cygwin || $Is_Darwin || $Is_VMS || $Is_W32) ? 'pods' : 'pod';
d568 1
a568 1
    for (map {$_->[1]} @@{get_pod_metadata()->{master}}) {
a571 1
	chmod(0644, "${installprivlib}/$pod/${base}");
d664 1
a664 1
	warn("Cannot rename to '$to.$i': $!"), return 0
d691 2
a692 15
    $dir =~ s!\Alib/?!!;

    m!([^/]+)\z!;
    my $name = $1;

    # This remains ugly, and in need of refactoring.

    # $name always starts as the leafname
    # $dir is the directory *within* lib
    # $name later has $dir pre-pended, to give the relative path in lib/
    # which is used to create the path in the target directory.

    # $_ was always the filename to use on disk. Adding no_chdir doesn't change
    # this, as $_ becomes a pathname, and so still works. However, it's not
    # obvious that $_ is needed later, and hence $_ must not be modified.
d694 1
a694 3
    # Also, many of the regex exlusion tests below are now superfluous, as the
    # files in question are either no longer in blead, or now in ext/, dist/ or
    # cpan/ and not copied into lib/
a709 1
    # and zipdetails in cpan/IO-Compress/bin
d711 1
a711 1
    return if $name =~ /^(?:cpan|instmodsh|prove|corelist|ptar|cpan2dist|cpanp|cpanp-run-perl|ptardiff|ptargrep|config_data|zipdetails)\z/;
a716 2
    # ignore the build support code
    return if $name =~ /\bbuildcustomize\.pl$/;
a718 13
    # ignore unneeded unicore files
    if ( $dir =~ /^unicore/ ) {
      if ( $name =~ /\.txt\z/ ) {
        # We can ignore most, but not all .txt files
        return unless $name =~ /\A(?:Blocks|CaseFolding|SpecialCasing|NamedSequences)\.txt\z/;
      }
      else {
        # TestProp only needed during testing
        return if $name =~ /\ATestProp.pl\z/;
        # we need version and *.pl files and can skip the rest
        return unless $name =~ /\A(?:version|\w+\.p[lm])\z/;
      }
    }
a737 3
    # ignore pods that are stand alone documentation from dual life modules.
    return if /\.pod\z/ && is_duplicate_pod($_);

a751 8
    if ($Is_NetWare && !$nwinstall && /\.(?:nlp|nlm|bs)$/) {
        # Don't copy .nlp,.nlm files, doesn't make sense on Windows and also
        # if copied will give problems when building new extensions.
        # Has to be copied if we are installing on a NetWare server and
        # hence the check !$nwinstall
        return;
    }

d769 22
a790 5
            if (copy_if_diff($_, "$installlib/$name")) {
                strip("-S", "$installlib/$name")
                    if $^O =~ /^(rhapsody|darwin)$/ and /\.(?:so|$dlext|a)$/;
                chmod(/\.(so|$dlext)$/ ? 0555 : 0444, "$installlib/$name");
            }
d825 3
a864 7

# Local variables:
# cperl-indent-level: 4
# indent-tabs-mode: nil
# End:
#
# ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d302 10
d392 5
d403 1
a403 1
	    strip("-S", "$installarchlib/CORE/$file") if $^O eq 'darwin';
d416 5
a420 1
    if ($^O eq 'vos') {
d435 5
a439 1
    if ($^O eq 'vos') {
d731 1
a731 1
        return unless $name =~ /\A(?:Blocks|SpecialCasing|NamedSequences)\.txt\z/;
d803 1
a803 1
                    if $^O eq 'darwin' and /\.(?:so|$dlext|a)$/;
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@d4 1
a9 1
    # install_lib itself loads and imports Config into main::
d16 2
a17 1
my $versiononly;
d28 1
a30 2
# nogetopt_compat to disable treating +v as meaning -v
use Getopt::Long qw(:config nogetopt_compat no_auto_abbrev noignorecase);
d39 5
d68 1
d74 17
a90 20
{
    my $usage = 0;
    if (!GetOptions(\%opts, 'notify|n', 'strip|s', 'silent|S',
                    'skip-otherperls|o', 'force|f', 'verbose|V', 'archname|A',
                    'netware', 'nopods|p', 'destdir:s', 'help|h|?',
                    'versiononly|v' => \$versiononly, '<>' => sub {
                        if ($_[0] eq '+v') {
                            $versiononly = 0;
                        } else {
                            # Any other unknown argument is going to be an error
                            $usage = 1;
                        }
                    },
                   )) {
        $usage = 1;
    }
    $opts{verbose} ||= $opts{notify};

    if ($usage || $opts{help}) {
        print <<"EOT";
a106 1
  -h        Display this help message.
d108 1
a108 1
        exit $usage;
d110 1
d140 1
d216 1
a216 1
if ($opts{netware}) {
d237 1
a237 1
-d $installbin	        || mkpath($installbin);
d278 1
a278 1
    $packlist->{"$Config{installbin}/$perldll"} = { type => 'file' };
d311 1
a311 1
        if ($opts{netware}) {
d313 1
a313 1
            mkpath($Config{installnwsystem});
d319 1
a319 1
            mkpath($Config{installnwlcgi});
d336 2
a337 2
mkpath($installprivlib);
mkpath($installarchlib);
d350 1
a350 1
mkpath("$installarchlib/CORE");
a359 1
    my $instcoredll = "$Config{installarchlib}/CORE/$libperl";
d364 1
a364 1
          $packlist->{$instcoredll} = { from => "$Config{installbin}/$libperl",
d370 1
a370 1
        $packlist->{$instcoredll} = { from => "$Config{installbin}/$libperl",
d374 1
a374 1
      push(@@corefiles, $instcoredll)
d413 1
a413 1
if ($opts{archname} && ! samepath($installbin, '.') && ($^O ne 'dos') && ! $Is_VMS) {
d498 1
a498 1
mkpath($installscript);
d530 1
a530 1
if (!$opts{nopods} && (!$versiononly || ($installprivlib =~ m/\Q$vershort/))) {
d532 1
a532 1
    mkpath("${installprivlib}/$pod");
d549 1
a549 1
if (!$versiononly && !$opts{'skip-otherperls'}) {
d624 14
d674 1
a674 1
    # Also, many of the regex exclusion tests below are now superfluous, as the
d694 1
a694 1
    return if $name =~ /^(?:cpan|instmodsh|prove|corelist|ptar|ptardiff|ptargrep|config_data|zipdetails)\z/;
d753 1
a753 1
    if ($Is_NetWare && !$opts{netware} && /\.(?:nlp|nlm|bs)$/) {
d757 1
a757 1
        # hence the check !$opts{netware}
d762 8
d773 1
a773 1
        if ($opts{force} || compare($_, "$installlib/$name") || $opts{notify}) {
d775 1
a775 1
	    mkpath("$installlib/$dir");
d815 1
a815 1
    if ($opts{force} || compare($from, $to) || $opts{notify}) {
d834 1
a834 1
    return unless $opts{strip};
@


1.1.1.17
log
@Import perl-5.20.2
@
text
@d263 1
a263 1
	$perldll = 'perl5'.$Config{patchlevel}.'.'.$so;
@


