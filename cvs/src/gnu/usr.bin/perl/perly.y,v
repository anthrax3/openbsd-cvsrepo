head	1.17;
access;
symbols
	PERL_5_24_2:1.1.1.15
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.10
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.6.0.6
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.17
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	cxJ08BvJA9Pt2PTM;

1.16
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.06.41;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.35.58;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.22.58;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.20;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.00;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.27.22.25.18;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.24.18.34.54;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.06.17.04.15;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.28.04.40.34;	author millert;	state dead;
branches;
next	1.3;

1.3
date	99.04.29.22.51.06;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.07;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.46;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.46;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.40;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.43;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.15;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.49;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.21.12.53;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.01.15.21.16.30;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.47.36;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.07;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.32;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.48.30;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.06.30;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.58.46;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.52.38;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	B31cAbBIXiCqnL97;

1.1.1.15
date	2017.08.14.13.45.27;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.17
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    perly.y
 *
 *    Copyright (c) 1991-2002, 2003, 2004, 2005, 2006 Larry Wall
 *    Copyright (c) 2007, 2008, 2009, 2010, 2011 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * 'I see,' laughed Strider.  'I look foul and feel fair.  Is that it?
 *  All that is gold does not glitter, not all those who wander are lost.'
 *
 *     [p.171 of _The Lord of the Rings_, I/x: "Strider"]
 */

/*
 * This file holds the grammar for the Perl language. If edited, you need
 * to run regen_perly.pl, which re-creates the files perly.h, perly.tab
 * and perly.act which are derived from this.
 *
 * The main job of of this grammar is to call the various newFOO()
 * functions in op.c to build a syntax tree of OP structs.
 * It relies on the lexer in toke.c to do the tokenizing.
 *
 * Note: due to the way that the cleanup code works WRT to freeing ops on
 * the parse stack, it is dangerous to assign to the $n variables within
 * an action.
 */

/*  Make the parser re-entrant. */

%pure-parser

%start grammar

%union {
    I32	ival; /* __DEFAULT__ (marker for regen_perly.pl;
				must always be 1st union member) */
    char *pval;
    OP *opval;
    GV *gvval;
}

%token <ival> GRAMPROG GRAMEXPR GRAMBLOCK GRAMBARESTMT GRAMFULLSTMT GRAMSTMTSEQ

%token <ival> '{' '}' '[' ']' '-' '+' '@@' '%' '&' '=' '.'

%token <opval> WORD METHOD FUNCMETH THING PMFUNC PRIVATEREF QWLIST
%token <opval> FUNC0OP FUNC0SUB UNIOPSUB LSTOPSUB
%token <opval> PLUGEXPR PLUGSTMT
%token <pval> LABEL
%token <ival> FORMAT SUB ANONSUB PACKAGE USE
%token <ival> WHILE UNTIL IF UNLESS ELSE ELSIF CONTINUE FOR
%token <ival> GIVEN WHEN DEFAULT
%token <ival> LOOPEX DOTDOT YADAYADA
%token <ival> FUNC0 FUNC1 FUNC UNIOP LSTOP
%token <ival> RELOP EQOP MULOP ADDOP
%token <ival> DOLSHARP DO HASHBRACK NOAMP
%token <ival> LOCAL MY REQUIRE
%token <ival> COLONATTR FORMLBRACK FORMRBRACK

%type <ival> grammar remember mremember
%type <ival>  startsub startanonsub startformsub

%type <ival> mintro

%type <opval> stmtseq fullstmt labfullstmt barestmt block mblock else
%type <opval> expr term subscripted scalar ary hsh arylen star amper sideff
%type <opval> sliceme kvslice gelem
%type <opval> listexpr nexpr texpr iexpr mexpr mnexpr
%type <opval> optlistexpr optexpr optrepl indirob listop method
%type <opval> formname subname proto optsubbody cont my_scalar my_var
%type <opval> refgen_topic formblock
%type <opval> subattrlist myattrlist myattrterm myterm
%type <opval> subsignature termbinop termunop anonymous termdo
%type <opval> formstmtseq formline formarg

%nonassoc <ival> PREC_LOW
%nonassoc LOOPEX

%left <ival> OROP DOROP
%left <ival> ANDOP
%right <ival> NOTOP
%nonassoc LSTOP LSTOPSUB
%left <ival> ','
%right <ival> ASSIGNOP
%right <ival> '?' ':'
%nonassoc DOTDOT YADAYADA
%left <ival> OROR DORDOR
%left <ival> ANDAND
%left <ival> BITOROP
%left <ival> BITANDOP
%nonassoc EQOP
%nonassoc RELOP
%nonassoc UNIOP UNIOPSUB
%nonassoc REQUIRE
%left <ival> SHIFTOP
%left ADDOP
%left MULOP
%left <ival> MATCHOP
%right <ival> '!' '~' UMINUS REFGEN
%right <ival> POWOP
%nonassoc <ival> PREINC PREDEC POSTINC POSTDEC POSTJOIN
%left <ival> ARROW
%nonassoc <ival> ')'
%left <ival> '('
%left '[' '{'

%% /* RULES */

/* Top-level choice of what kind of thing yyparse was called to parse */
grammar	:	GRAMPROG
			{
			  parser->expect = XSTATE;
			}
		remember stmtseq
			{
			  newPROG(block_end($3,$4));
			  PL_compiling.cop_seq = 0;
			  $$ = 0;
			}
	|	GRAMEXPR
			{
			  parser->expect = XTERM;
			}
		optexpr
			{
			  PL_eval_root = $3;
			  $$ = 0;
			}
	|	GRAMBLOCK
			{
			  parser->expect = XBLOCK;
			}
		block
			{
			  PL_pad_reset_pending = TRUE;
			  PL_eval_root = $3;
			  $$ = 0;
			  yyunlex();
			  parser->yychar = YYEOF;
			}
	|	GRAMBARESTMT
			{
			  parser->expect = XSTATE;
			}
		barestmt
			{
			  PL_pad_reset_pending = TRUE;
			  PL_eval_root = $3;
			  $$ = 0;
			  yyunlex();
			  parser->yychar = YYEOF;
			}
	|	GRAMFULLSTMT
			{
			  parser->expect = XSTATE;
			}
		fullstmt
			{
			  PL_pad_reset_pending = TRUE;
			  PL_eval_root = $3;
			  $$ = 0;
			  yyunlex();
			  parser->yychar = YYEOF;
			}
	|	GRAMSTMTSEQ
			{
			  parser->expect = XSTATE;
			}
		stmtseq
			{
			  PL_eval_root = $3;
			  $$ = 0;
			}
	;

/* An ordinary block */
block	:	'{' remember stmtseq '}'
			{ if (parser->copline > (line_t)$1)
			      parser->copline = (line_t)$1;
			  $$ = block_end($2, $3);
			}
	;

/* format body */
formblock:	'=' remember ';' FORMRBRACK formstmtseq ';' '.'
			{ if (parser->copline > (line_t)$1)
			      parser->copline = (line_t)$1;
			  $$ = block_end($2, $5);
			}
	;

remember:	/* NULL */	/* start a full lexical scope */
			{ $$ = block_start(TRUE);
			  parser->parsed_sub = 0; }
	;

mblock	:	'{' mremember stmtseq '}'
			{ if (parser->copline > (line_t)$1)
			      parser->copline = (line_t)$1;
			  $$ = block_end($2, $3);
			}
	;

mremember:	/* NULL */	/* start a partial lexical scope */
			{ $$ = block_start(FALSE);
			  parser->parsed_sub = 0; }
	;

/* A sequence of statements in the program */
stmtseq	:	/* NULL */
			{ $$ = (OP*)NULL; }
	|	stmtseq fullstmt
			{   $$ = op_append_list(OP_LINESEQ, $1, $2);
			    PL_pad_reset_pending = TRUE;
			    if ($1 && $2)
				PL_hints |= HINT_BLOCK_SCOPE;
			}
	;

/* A sequence of format lines */
formstmtseq:	/* NULL */
			{ $$ = (OP*)NULL; }
	|	formstmtseq formline
			{   $$ = op_append_list(OP_LINESEQ, $1, $2);
			    PL_pad_reset_pending = TRUE;
			    if ($1 && $2)
				PL_hints |= HINT_BLOCK_SCOPE;
			}
	;

/* A statement in the program, including optional labels */
fullstmt:	barestmt
			{
			  $$ = $1 ? newSTATEOP(0, NULL, $1) : NULL;
			}
	|	labfullstmt
			{ $$ = $1; }
	;

labfullstmt:	LABEL barestmt
			{
			  $$ = newSTATEOP(SVf_UTF8 * $1[strlen($1)+1], $1, $2);
			}
	|	LABEL labfullstmt
			{
			  $$ = newSTATEOP(SVf_UTF8 * $1[strlen($1)+1], $1, $2);
			}
	;

/* A bare statement, lacking label and other aspects of state op */
barestmt:	PLUGSTMT
			{ $$ = $1; }
	|	FORMAT startformsub formname formblock
			{
			  CV *fmtcv = PL_compcv;
			  newFORM($2, $3, $4);
			  $$ = (OP*)NULL;
			  if (CvOUTSIDE(fmtcv) && !CvEVAL(CvOUTSIDE(fmtcv))) {
			      pad_add_weakref(fmtcv);
			  }
			  parser->parsed_sub = 1;
			}
	|	SUB subname startsub
			{
			  if ($2->op_type == OP_CONST) {
			    const char *const name =
				SvPV_nolen_const(((SVOP*)$2)->op_sv);
			    if (strEQ(name, "BEGIN") || strEQ(name, "END")
			      || strEQ(name, "INIT") || strEQ(name, "CHECK")
			      || strEQ(name, "UNITCHECK"))
			      CvSPECIAL_on(PL_compcv);
			  }
			  else
			  /* State subs inside anonymous subs need to be
			     clonable themselves. */
			  if (CvANON(CvOUTSIDE(PL_compcv))
			   || CvCLONE(CvOUTSIDE(PL_compcv))
			   || !PadnameIsSTATE(PadlistNAMESARRAY(CvPADLIST(
						CvOUTSIDE(PL_compcv)
					     ))[$2->op_targ]))
			      CvCLONE_on(PL_compcv);
			  parser->in_my = 0;
			  parser->in_my_stash = NULL;
			}
		proto subattrlist optsubbody
			{
			  SvREFCNT_inc_simple_void(PL_compcv);
			  $2->op_type == OP_CONST
			      ? newATTRSUB($3, $2, $5, $6, $7)
			      : newMYSUB($3, $2, $5, $6, $7)
			  ;
			  $$ = (OP*)NULL;
			  intro_my();
			  parser->parsed_sub = 1;
			}
	|	SUB subname startsub
			{
			  if ($2->op_type == OP_CONST) {
			    const char *const name =
				SvPV_nolen_const(((SVOP*)$2)->op_sv);
			    if (strEQ(name, "BEGIN") || strEQ(name, "END")
			      || strEQ(name, "INIT") || strEQ(name, "CHECK")
			      || strEQ(name, "UNITCHECK"))
			      CvSPECIAL_on(PL_compcv);
			  }
			  else
			  /* State subs inside anonymous subs need to be
			     clonable themselves. */
			  if (CvANON(CvOUTSIDE(PL_compcv))
			   || CvCLONE(CvOUTSIDE(PL_compcv))
			   || !PadnameIsSTATE(PadlistNAMESARRAY(CvPADLIST(
						CvOUTSIDE(PL_compcv)
					     ))[$2->op_targ]))
			      CvCLONE_on(PL_compcv);
			  parser->in_my = 0;
			  parser->in_my_stash = NULL;
			}
		remember subsignature subattrlist '{' stmtseq '}'
			{
			  OP *body;
			  if (parser->copline > (line_t)$8)
			      parser->copline = (line_t)$8;
			  body = block_end($5,
				op_append_list(OP_LINESEQ, $6, $9));

			  SvREFCNT_inc_simple_void(PL_compcv);
			  $2->op_type == OP_CONST
			      ? newATTRSUB($3, $2, NULL, $7, body)
			      : newMYSUB($3, $2, NULL, $7, body)
			  ;
			  $$ = (OP*)NULL;
			  intro_my();
			  parser->parsed_sub = 1;
			}
	|	PACKAGE WORD WORD ';'
			{
			  package($3);
			  if ($2)
			      package_version($2);
			  $$ = (OP*)NULL;
			}
	|	USE startsub
			{ CvSPECIAL_on(PL_compcv); /* It's a BEGIN {} */ }
		WORD WORD optlistexpr ';'
			{
			  SvREFCNT_inc_simple_void(PL_compcv);
			  utilize($1, $2, $4, $5, $6);
			  parser->parsed_sub = 1;
			  $$ = (OP*)NULL;
			}
	|	IF '(' remember mexpr ')' mblock else
			{
			  $$ = block_end($3,
			      newCONDOP(0, $4, op_scope($6), $7));
			  parser->copline = (line_t)$1;
			}
	|	UNLESS '(' remember mexpr ')' mblock else
			{
			  $$ = block_end($3,
                              newCONDOP(0, $4, $7, op_scope($6)));
			  parser->copline = (line_t)$1;
			}
	|	GIVEN '(' remember mexpr ')' mblock
			{
			  $$ = block_end($3, newGIVENOP($4, op_scope($6), 0));
			  parser->copline = (line_t)$1;
			}
	|	WHEN '(' remember mexpr ')' mblock
			{ $$ = block_end($3, newWHENOP($4, op_scope($6))); }
	|	DEFAULT block
			{ $$ = newWHENOP(0, op_scope($2)); }
	|	WHILE '(' remember texpr ')' mintro mblock cont
			{
			  $$ = block_end($3,
				  newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
				      $4, $7, $8, $6));
			  parser->copline = (line_t)$1;
			}
	|	UNTIL '(' remember iexpr ')' mintro mblock cont
			{
			  $$ = block_end($3,
				  newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
				      $4, $7, $8, $6));
			  parser->copline = (line_t)$1;
			}
	|	FOR '(' remember mnexpr ';'
			{ parser->expect = XTERM; }
		texpr ';'
			{ parser->expect = XTERM; }
		mintro mnexpr ')'
		mblock
			{
			  OP *initop = $4;
			  OP *forop = newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
				      scalar($7), $13, $11, $10);
			  if (initop) {
			      forop = op_prepend_elem(OP_LINESEQ, initop,
				  op_append_elem(OP_LINESEQ,
				      newOP(OP_UNSTACK, OPf_SPECIAL),
				      forop));
			  }
			  PL_hints |= HINT_BLOCK_SCOPE;
			  $$ = block_end($3, forop);
			  parser->copline = (line_t)$1;
			}
	|	FOR MY remember my_scalar '(' mexpr ')' mblock cont
			{
			  $$ = block_end($3, newFOROP(0, $4, $6, $8, $9));
			  parser->copline = (line_t)$1;
			}
	|	FOR scalar '(' remember mexpr ')' mblock cont
			{
			  $$ = block_end($4, newFOROP(0,
				      op_lvalue($2, OP_ENTERLOOP), $5, $7, $8));
			  parser->copline = (line_t)$1;
			}
	|	FOR REFGEN MY remember my_var
			{ parser->in_my = 0; $<opval>$ = my($5); }
		'(' mexpr ')' mblock cont
			{
			  $$ = block_end(
				$4,
				newFOROP(0,
					 op_lvalue(
					    newUNOP(OP_REFGEN, 0,
						    $<opval>6),
					    OP_ENTERLOOP),
					 $8, $10, $11)
			  );
			  parser->copline = (line_t)$1;
			}
	|	FOR REFGEN refgen_topic '(' remember mexpr ')' mblock cont
			{
			  $$ = block_end($5, newFOROP(
				0, op_lvalue(newUNOP(OP_REFGEN, 0,
						     $3),
					     OP_ENTERLOOP), $6, $8, $9));
			  parser->copline = (line_t)$1;
			}
	|	FOR '(' remember mexpr ')' mblock cont
			{
			  $$ = block_end($3,
				  newFOROP(0, (OP*)NULL, $4, $6, $7));
			  parser->copline = (line_t)$1;
			}
	|	block cont
			{
			  /* a block is a loop that happens once */
			  $$ = newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
				  (OP*)NULL, $1, $2, 0);
			}
	|	PACKAGE WORD WORD '{' remember
			{
			  package($3);
			  if ($2) {
			      package_version($2);
			  }
			}
		stmtseq '}'
			{
			  /* a block is a loop that happens once */
			  $$ = newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
				  (OP*)NULL, block_end($5, $7), (OP*)NULL, 0);
			  if (parser->copline > (line_t)$4)
			      parser->copline = (line_t)$4;
			}
	|	sideff ';'
			{
			  $$ = $1;
			}
	|	';'
			{
			  $$ = (OP*)NULL;
			  parser->copline = NOLINE;
			}
	;

/* Format line */
formline:	THING formarg
			{ OP *list;
			  if ($2) {
			      OP *term = $2;
			      list = op_append_elem(OP_LIST, $1, term);
			  }
			  else {
			      list = $1;
			  }
			  if (parser->copline == NOLINE)
			       parser->copline = CopLINE(PL_curcop)-1;
			  else parser->copline--;
			  $$ = newSTATEOP(0, NULL,
					  op_convert_list(OP_FORMLINE, 0, list));
			}
	;

formarg	:	/* NULL */
			{ $$ = NULL; }
	|	FORMLBRACK stmtseq FORMRBRACK
			{ $$ = op_unscope($2); }
	;

/* An expression which may have a side-effect */
sideff	:	error
			{ $$ = (OP*)NULL; }
	|	expr
			{ $$ = $1; }
	|	expr IF expr
			{ $$ = newLOGOP(OP_AND, 0, $3, $1); }
	|	expr UNLESS expr
			{ $$ = newLOGOP(OP_OR, 0, $3, $1); }
	|	expr WHILE expr
			{ $$ = newLOOPOP(OPf_PARENS, 1, scalar($3), $1); }
	|	expr UNTIL iexpr
			{ $$ = newLOOPOP(OPf_PARENS, 1, $3, $1); }
	|	expr FOR expr
			{ $$ = newFOROP(0, (OP*)NULL, $3, $1, (OP*)NULL);
			  parser->copline = (line_t)$2; }
	|	expr WHEN expr
			{ $$ = newWHENOP($3, op_scope($1)); }
	;

/* else and elsif blocks */
else	:	/* NULL */
			{ $$ = (OP*)NULL; }
	|	ELSE mblock
			{
			  ($2)->op_flags |= OPf_PARENS;
			  $$ = op_scope($2);
			}
	|	ELSIF '(' mexpr ')' mblock else
			{ parser->copline = (line_t)$1;
			    $$ = newCONDOP(0,
				newSTATEOP(OPf_SPECIAL,NULL,$3),
				op_scope($5), $6);
			  PL_hints |= HINT_BLOCK_SCOPE;
			}
	;

/* Continue blocks */
cont	:	/* NULL */
			{ $$ = (OP*)NULL; }
	|	CONTINUE block
			{ $$ = op_scope($2); }
	;

/* determine whether there are any new my declarations */
mintro	:	/* NULL */
			{ $$ = (PL_min_intro_pending &&
			    PL_max_intro_pending >=  PL_min_intro_pending);
			  intro_my(); }

/* Normal expression */
nexpr	:	/* NULL */
			{ $$ = (OP*)NULL; }
	|	sideff
	;

/* Boolean expression */
texpr	:	/* NULL means true */
			{ YYSTYPE tmplval;
			  (void)scan_num("1", &tmplval);
			  $$ = tmplval.opval; }
	|	expr
	;

/* Inverted boolean expression */
iexpr	:	expr
			{ $$ = invert(scalar($1)); }
	;

/* Expression with its own lexical scope */
mexpr	:	expr
			{ $$ = $1; intro_my(); }
	;

mnexpr	:	nexpr
			{ $$ = $1; intro_my(); }
	;

formname:	WORD		{ $$ = $1; }
	|	/* NULL */	{ $$ = (OP*)NULL; }
	;

startsub:	/* NULL */	/* start a regular subroutine scope */
			{ $$ = start_subparse(FALSE, 0);
			    SAVEFREESV(PL_compcv); }

	;

startanonsub:	/* NULL */	/* start an anonymous subroutine scope */
			{ $$ = start_subparse(FALSE, CVf_ANON);
			    SAVEFREESV(PL_compcv); }
	;

startformsub:	/* NULL */	/* start a format subroutine scope */
			{ $$ = start_subparse(TRUE, 0);
			    SAVEFREESV(PL_compcv); }
	;

/* Name of a subroutine - must be a bareword, could be special */
subname	:	WORD
	|	PRIVATEREF
	;

/* Subroutine prototype */
proto	:	/* NULL */
			{ $$ = (OP*)NULL; }
	|	THING
	;

/* Optional list of subroutine attributes */
subattrlist:	/* NULL */
			{ $$ = (OP*)NULL; }
	|	COLONATTR THING
			{ $$ = $2; }
	|	COLONATTR
			{ $$ = (OP*)NULL; }
	;

/* List of attributes for a "my" variable declaration */
myattrlist:	COLONATTR THING
			{ $$ = $2; }
	|	COLONATTR
			{ $$ = (OP*)NULL; }
	;

/* Subroutine signature */
subsignature:	'('
			{
			  /* We shouldn't get here otherwise */
			  assert(FEATURE_SIGNATURES_IS_ENABLED);

			  Perl_ck_warner_d(aTHX_
				packWARN(WARN_EXPERIMENTAL__SIGNATURES),
				"The signatures feature is experimental");
			  $<opval>$ = parse_subsignature();
			}
		')'
			{
			  $$ = op_append_list(OP_LINESEQ, $<opval>2,
				newSTATEOP(0, NULL, sawparens(newNULLLIST())));
			  parser->expect = XATTRBLOCK;
			}
	;

/* Optional subroutine body, for named subroutine declaration */
optsubbody:	block
	|	';'	{ $$ = (OP*)NULL; }
	;

/* Ordinary expressions; logical combinations */
expr	:	expr ANDOP expr
			{ $$ = newLOGOP(OP_AND, 0, $1, $3); }
	|	expr OROP expr
			{ $$ = newLOGOP($2, 0, $1, $3); }
	|	expr DOROP expr
			{ $$ = newLOGOP(OP_DOR, 0, $1, $3); }
	|	listexpr %prec PREC_LOW
	;

/* Expressions are a list of terms joined by commas */
listexpr:	listexpr ','
			{ $$ = $1; }
	|	listexpr ',' term
			{
			  OP* term = $3;
			  $$ = op_append_elem(OP_LIST, $1, term);
			}
	|	term %prec PREC_LOW
	;

/* List operators */
listop	:	LSTOP indirob listexpr /* map {...} @@args or print $fh @@args */
			{ $$ = op_convert_list($1, OPf_STACKED,
				op_prepend_elem(OP_LIST, newGVREF($1,$2), $3) );
			}
	|	FUNC '(' indirob expr ')'      /* print ($fh @@args */
			{ $$ = op_convert_list($1, OPf_STACKED,
				op_prepend_elem(OP_LIST, newGVREF($1,$3), $4) );
			}
	|	term ARROW method '(' optexpr ')' /* $foo->bar(list) */
			{ $$ = op_convert_list(OP_ENTERSUB, OPf_STACKED,
				op_append_elem(OP_LIST,
				    op_prepend_elem(OP_LIST, scalar($1), $5),
				    newMETHOP(OP_METHOD, 0, $3)));
			}
	|	term ARROW method                     /* $foo->bar */
			{ $$ = op_convert_list(OP_ENTERSUB, OPf_STACKED,
				op_append_elem(OP_LIST, scalar($1),
				    newMETHOP(OP_METHOD, 0, $3)));
			}
	|	METHOD indirob optlistexpr           /* new Class @@args */
			{ $$ = op_convert_list(OP_ENTERSUB, OPf_STACKED,
				op_append_elem(OP_LIST,
				    op_prepend_elem(OP_LIST, $2, $3),
				    newMETHOP(OP_METHOD, 0, $1)));
			}
	|	FUNCMETH indirob '(' optexpr ')'    /* method $object (@@args) */
			{ $$ = op_convert_list(OP_ENTERSUB, OPf_STACKED,
				op_append_elem(OP_LIST,
				    op_prepend_elem(OP_LIST, $2, $4),
				    newMETHOP(OP_METHOD, 0, $1)));
			}
	|	LSTOP optlistexpr                    /* print @@args */
			{ $$ = op_convert_list($1, 0, $2); }
	|	FUNC '(' optexpr ')'                 /* print (@@args) */
			{ $$ = op_convert_list($1, 0, $3); }
	|	LSTOPSUB startanonsub block /* sub f(&@@);   f { foo } ... */
			{ SvREFCNT_inc_simple_void(PL_compcv);
			  $<opval>$ = newANONATTRSUB($2, 0, (OP*)NULL, $3); }
		    optlistexpr		%prec LSTOP  /* ... @@bar */
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
				 op_append_elem(OP_LIST,
				   op_prepend_elem(OP_LIST, $<opval>4, $5), $1));
			}
	;

/* Names of methods. May use $object->$methodname */
method	:	METHOD
	|	scalar
	;

/* Some kind of subscripted expression */
subscripted:    gelem '{' expr ';' '}'        /* *main::{something} */
                        /* In this and all the hash accessors, ';' is
                         * provided by the tokeniser */
			{ $$ = newBINOP(OP_GELEM, 0, $1, scalar($3)); }
	|	scalar '[' expr ']'          /* $array[$element] */
			{ $$ = newBINOP(OP_AELEM, 0, oopsAV($1), scalar($3));
			}
	|	term ARROW '[' expr ']'      /* somearef->[$element] */
			{ $$ = newBINOP(OP_AELEM, 0,
					ref(newAVREF($1),OP_RV2AV),
					scalar($4));
			}
	|	subscripted '[' expr ']'    /* $foo->[$bar]->[$baz] */
			{ $$ = newBINOP(OP_AELEM, 0,
					ref(newAVREF($1),OP_RV2AV),
					scalar($3));
			}
	|	scalar '{' expr ';' '}'    /* $foo{bar();} */
			{ $$ = newBINOP(OP_HELEM, 0, oopsHV($1), jmaybe($3));
			}
	|	term ARROW '{' expr ';' '}' /* somehref->{bar();} */
			{ $$ = newBINOP(OP_HELEM, 0,
					ref(newHVREF($1),OP_RV2HV),
					jmaybe($4)); }
	|	subscripted '{' expr ';' '}' /* $foo->[bar]->{baz;} */
			{ $$ = newBINOP(OP_HELEM, 0,
					ref(newHVREF($1),OP_RV2HV),
					jmaybe($3)); }
	|	term ARROW '(' ')'          /* $subref->() */
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
				   newCVREF(0, scalar($1))); }
	|	term ARROW '(' expr ')'     /* $subref->(@@args) */
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
				   op_append_elem(OP_LIST, $4,
				       newCVREF(0, scalar($1)))); }

	|	subscripted '(' expr ')'   /* $foo->{bar}->(@@args) */
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
				   op_append_elem(OP_LIST, $3,
					       newCVREF(0, scalar($1)))); }
	|	subscripted '(' ')'        /* $foo->{bar}->() */
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
				   newCVREF(0, scalar($1))); }
	|	'(' expr ')' '[' expr ']'            /* list slice */
			{ $$ = newSLICEOP(0, $5, $2); }
	|	QWLIST '[' expr ']'            /* list literal slice */
			{ $$ = newSLICEOP(0, $3, $1); }
	|	'(' ')' '[' expr ']'                 /* empty list slice! */
			{ $$ = newSLICEOP(0, $4, (OP*)NULL); }
    ;

/* Binary operators between terms */
termbinop:	term ASSIGNOP term                     /* $x = $y */
			{ $$ = newASSIGNOP(OPf_STACKED, $1, $2, $3); }
	|	term POWOP term                        /* $x ** $y */
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
	|	term MULOP term                        /* $x * $y, $x x $y */
			{   if ($2 != OP_REPEAT)
				scalar($1);
			    $$ = newBINOP($2, 0, $1, scalar($3));
			}
	|	term ADDOP term                        /* $x + $y */
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
	|	term SHIFTOP term                      /* $x >> $y, $x << $y */
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
	|	term RELOP term                        /* $x > $y, etc. */
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
	|	term EQOP term                         /* $x == $y, $x eq $y */
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
	|	term BITANDOP term                     /* $x & $y */
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
	|	term BITOROP term                      /* $x | $y */
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
	|	term DOTDOT term                       /* $x..$y, $x...$y */
			{ $$ = newRANGE($2, scalar($1), scalar($3)); }
	|	term ANDAND term                       /* $x && $y */
			{ $$ = newLOGOP(OP_AND, 0, $1, $3); }
	|	term OROR term                         /* $x || $y */
			{ $$ = newLOGOP(OP_OR, 0, $1, $3); }
	|	term DORDOR term                       /* $x // $y */
			{ $$ = newLOGOP(OP_DOR, 0, $1, $3); }
	|	term MATCHOP term                      /* $x =~ /$y/ */
			{ $$ = bind_match($2, $1, $3); }
    ;

/* Unary operators and terms */
termunop : '-' term %prec UMINUS                       /* -$x */
			{ $$ = newUNOP(OP_NEGATE, 0, scalar($2)); }
	|	'+' term %prec UMINUS                  /* +$x */
			{ $$ = $2; }

	|	'!' term                               /* !$x */
			{ $$ = newUNOP(OP_NOT, 0, scalar($2)); }
	|	'~' term                               /* ~$x */
			{ $$ = newUNOP($1, 0, scalar($2)); }
	|	term POSTINC                           /* $x++ */
			{ $$ = newUNOP(OP_POSTINC, 0,
					op_lvalue(scalar($1), OP_POSTINC)); }
	|	term POSTDEC                           /* $x-- */
			{ $$ = newUNOP(OP_POSTDEC, 0,
					op_lvalue(scalar($1), OP_POSTDEC));}
	|	term POSTJOIN    /* implicit join after interpolated ->@@ */
			{ $$ = op_convert_list(OP_JOIN, 0,
				       op_append_elem(
					OP_LIST,
					newSVREF(scalar(
					    newSVOP(OP_CONST,0,
						    newSVpvs("\""))
					)),
					$1
				       ));
			}
	|	PREINC term                            /* ++$x */
			{ $$ = newUNOP(OP_PREINC, 0,
					op_lvalue(scalar($2), OP_PREINC)); }
	|	PREDEC term                            /* --$x */
			{ $$ = newUNOP(OP_PREDEC, 0,
					op_lvalue(scalar($2), OP_PREDEC)); }

    ;

/* Constructors for anonymous data */
anonymous:	'[' expr ']'
			{ $$ = newANONLIST($2); }
	|	'[' ']'
			{ $$ = newANONLIST((OP*)NULL);}
	|	HASHBRACK expr ';' '}'	%prec '(' /* { foo => "Bar" } */
			{ $$ = newANONHASH($2); }
	|	HASHBRACK ';' '}'	%prec '(' /* { } (';' by tokener) */
			{ $$ = newANONHASH((OP*)NULL); }
	|	ANONSUB startanonsub proto subattrlist block		%prec '('
			{ SvREFCNT_inc_simple_void(PL_compcv);
			  $$ = newANONATTRSUB($2, $3, $4, $5); }
	|	ANONSUB startanonsub remember subsignature subattrlist '{' stmtseq '}'	%prec '('
			{
			  OP *body;
			  if (parser->copline > (line_t)$6)
			      parser->copline = (line_t)$6;
			  body = block_end($3,
				op_append_list(OP_LINESEQ, $4, $7));
			  SvREFCNT_inc_simple_void(PL_compcv);
			  $$ = newANONATTRSUB($2, NULL, $5, body);
			}

    ;

/* Things called with "do" */
termdo	:       DO term	%prec UNIOP                     /* do $filename */
			{ $$ = dofile($2, $1);}
	|	DO block	%prec '('               /* do { code */
			{ $$ = newUNOP(OP_NULL, OPf_SPECIAL, op_scope($2));}
        ;

term	:	termbinop
	|	termunop
	|	anonymous
	|	termdo
	|	term '?' term ':' term
			{ $$ = newCONDOP(0, $1, $3, $5); }
	|	REFGEN term                          /* \$x, \@@y, \%z */
			{ $$ = newUNOP(OP_REFGEN, 0, $2); }
	|	myattrterm	%prec UNIOP
			{ $$ = $1; }
	|	LOCAL term	%prec UNIOP
			{ $$ = localize($2,$1); }
	|	'(' expr ')'
			{ $$ = sawparens($2); }
	|	QWLIST
			{ $$ = $1; }
	|	'(' ')'
			{ $$ = sawparens(newNULLLIST()); }
	|	scalar	%prec '('
			{ $$ = $1; }
	|	star	%prec '('
			{ $$ = $1; }
	|	hsh 	%prec '('
			{ $$ = $1; }
	|	ary 	%prec '('
			{ $$ = $1; }
	|	arylen 	%prec '('                    /* $#x, $#{ something } */
			{ $$ = newUNOP(OP_AV2ARYLEN, 0, ref($1, OP_AV2ARYLEN));}
	|       subscripted
			{ $$ = $1; }
	|	sliceme '[' expr ']'                     /* array slice */
			{ $$ = op_prepend_elem(OP_ASLICE,
				newOP(OP_PUSHMARK, 0),
				    newLISTOP(OP_ASLICE, 0,
					list($3),
					ref($1, OP_ASLICE)));
			  if ($$ && $1)
			      $$->op_private |=
				  $1->op_private & OPpSLICEWARNING;
			}
	|	kvslice '[' expr ']'                 /* array key/value slice */
			{ $$ = op_prepend_elem(OP_KVASLICE,
				newOP(OP_PUSHMARK, 0),
				    newLISTOP(OP_KVASLICE, 0,
					list($3),
					ref(oopsAV($1), OP_KVASLICE)));
			  if ($$ && $1)
			      $$->op_private |=
				  $1->op_private & OPpSLICEWARNING;
			}
	|	sliceme '{' expr ';' '}'                 /* @@hash{@@keys} */
			{ $$ = op_prepend_elem(OP_HSLICE,
				newOP(OP_PUSHMARK, 0),
				    newLISTOP(OP_HSLICE, 0,
					list($3),
					ref(oopsHV($1), OP_HSLICE)));
			  if ($$ && $1)
			      $$->op_private |=
				  $1->op_private & OPpSLICEWARNING;
			}
	|	kvslice '{' expr ';' '}'                 /* %hash{@@keys} */
			{ $$ = op_prepend_elem(OP_KVHSLICE,
				newOP(OP_PUSHMARK, 0),
				    newLISTOP(OP_KVHSLICE, 0,
					list($3),
					ref($1, OP_KVHSLICE)));
			  if ($$ && $1)
			      $$->op_private |=
				  $1->op_private & OPpSLICEWARNING;
			}
	|	THING	%prec '('
			{ $$ = $1; }
	|	amper                                /* &foo; */
			{ $$ = newUNOP(OP_ENTERSUB, 0, scalar($1)); }
	|	amper '(' ')'                 /* &foo() or foo() */
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED, scalar($1));
			}
	|	amper '(' expr ')'          /* &foo(@@args) or foo(@@args) */
			{
			  $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
				op_append_elem(OP_LIST, $3, scalar($1)));
			}
	|	NOAMP subname optlistexpr       /* foo @@args (no parens) */
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
			    op_append_elem(OP_LIST, $3, scalar($2)));
			}
	|	term ARROW '$' '*'
			{ $$ = newSVREF($1); }
	|	term ARROW '@@' '*'
			{ $$ = newAVREF($1); }
	|	term ARROW '%' '*'
			{ $$ = newHVREF($1); }
	|	term ARROW '&' '*'
			{ $$ = newUNOP(OP_ENTERSUB, 0,
				       scalar(newCVREF($3,$1))); }
	|	term ARROW '*' '*'	%prec '('
			{ $$ = newGVREF(0,$1); }
	|	LOOPEX  /* loop exiting command (goto, last, dump, etc) */
			{ $$ = newOP($1, OPf_SPECIAL);
			    PL_hints |= HINT_BLOCK_SCOPE; }
	|	LOOPEX term
			{ $$ = newLOOPEX($1,$2); }
	|	NOTOP listexpr                       /* not $foo */
			{ $$ = newUNOP(OP_NOT, 0, scalar($2)); }
	|	UNIOP                                /* Unary op, $_ implied */
			{ $$ = newOP($1, 0); }
	|	UNIOP block                          /* eval { foo }* */
			{ $$ = newUNOP($1, 0, $2); }
	|	UNIOP term                           /* Unary op */
			{ $$ = newUNOP($1, 0, $2); }
	|	REQUIRE                              /* require, $_ implied */
			{ $$ = newOP(OP_REQUIRE, $1 ? OPf_SPECIAL : 0); }
	|	REQUIRE term                         /* require Foo */
			{ $$ = newUNOP(OP_REQUIRE, $1 ? OPf_SPECIAL : 0, $2); }
	|	UNIOPSUB
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED, scalar($1)); }
	|	UNIOPSUB term                        /* Sub treated as unop */
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
			    op_append_elem(OP_LIST, $2, scalar($1))); }
	|	FUNC0                                /* Nullary operator */
			{ $$ = newOP($1, 0); }
	|	FUNC0 '(' ')'
			{ $$ = newOP($1, 0);}
	|	FUNC0OP       /* Same as above, but op created in toke.c */
			{ $$ = $1; }
	|	FUNC0OP '(' ')'
			{ $$ = $1; }
	|	FUNC0SUB                             /* Sub treated as nullop */
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED, scalar($1)); }
	|	FUNC1 '(' ')'                        /* not () */
			{ $$ = ($1 == OP_NOT)
                          ? newUNOP($1, 0, newSVOP(OP_CONST, 0, newSViv(0)))
                          : newOP($1, OPf_SPECIAL); }
	|	FUNC1 '(' expr ')'                   /* not($foo) */
			{ $$ = newUNOP($1, 0, $3); }
	|	PMFUNC /* m//, s///, qr//, tr/// */
			{
			    if (   $1->op_type != OP_TRANS
			        && $1->op_type != OP_TRANSR
				&& (((PMOP*)$1)->op_pmflags & PMf_HAS_CV))
			    {
				$<ival>$ = start_subparse(FALSE, CVf_ANON);
				SAVEFREESV(PL_compcv);
			    } else
				$<ival>$ = 0;
			}
		    '(' listexpr optrepl ')'
			{ $$ = pmruntime($1, $4, $5, 1, $<ival>2); }
	|	WORD
	|	listop
	|	YADAYADA
			{
			  $$ = newLISTOP(OP_DIE, 0, newOP(OP_PUSHMARK, 0),
				newSVOP(OP_CONST, 0, newSVpvs("Unimplemented")));
			}
	|	PLUGEXPR
	;

/* "my" declarations, with optional attributes */
myattrterm:	MY myterm myattrlist
			{ $$ = my_attrs($2,$3); }
	|	MY myterm
			{ $$ = localize($2,$1); }
	;

/* Things that can be "my"'d */
myterm	:	'(' expr ')'
			{ $$ = sawparens($2); }
	|	'(' ')'
			{ $$ = sawparens(newNULLLIST()); }

	|	scalar	%prec '('
			{ $$ = $1; }
	|	hsh 	%prec '('
			{ $$ = $1; }
	|	ary 	%prec '('
			{ $$ = $1; }
	;

/* Basic list expressions */
optlistexpr:	/* NULL */ %prec PREC_LOW
			{ $$ = (OP*)NULL; }
	|	listexpr    %prec PREC_LOW
			{ $$ = $1; }
	;

optexpr:	/* NULL */
			{ $$ = (OP*)NULL; }
	|	expr
			{ $$ = $1; }
	;

optrepl:	/* NULL */
			{ $$ = (OP*)NULL; }
	|	'/' expr
			{ $$ = $2; }
	;

/* A little bit of trickery to make "for my $foo (@@bar)" actually be
   lexical */
my_scalar:	scalar
			{ parser->in_my = 0; $$ = my($1); }
	;

my_var	:	scalar
	|	ary
	|	hsh
	;

refgen_topic:	my_var
	|	amper
	;

amper	:	'&' indirob
			{ $$ = newCVREF($1,$2); }
	;

scalar	:	'$' indirob
			{ $$ = newSVREF($2); }
	;

ary	:	'@@' indirob
			{ $$ = newAVREF($2);
			  if ($$) $$->op_private |= $1;
			}
	;

hsh	:	'%' indirob
			{ $$ = newHVREF($2);
			  if ($$) $$->op_private |= $1;
			}
	;

arylen	:	DOLSHARP indirob
			{ $$ = newAVREF($2); }
	|	term ARROW DOLSHARP '*'
			{ $$ = newAVREF($1); }
	;

star	:	'*' indirob
			{ $$ = newGVREF(0,$2); }
	;

sliceme	:	ary
	|	term ARROW '@@'
			{ $$ = newAVREF($1); }
	;

kvslice	:	hsh
	|	term ARROW '%'
			{ $$ = newHVREF($1); }
	;

gelem	:	star
	|	term ARROW '*'
			{ $$ = newGVREF(0,$1); }
	;

/* Indirect objects */
indirob	:	WORD
			{ $$ = scalar($1); }
	|	scalar %prec PREC_LOW
			{ $$ = scalar($1); }
	|	block
			{ $$ = op_scope($1); }

	|	PRIVATEREF
			{ $$ = $1; }
	;
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a22 14
 * Note that these derived files are included and compiled twice; once
 * from perly.c, and once from madly.c. The second time, a number of MAD
 * macros are defined, which compile in extra code that allows the parse
 * tree to be accurately dumped. In particular:
 *
 * MAD            defined if compiling madly.c
 * DO_MAD(A)      expands to A  under madly.c, to null otherwise
 * IF_MAD(a,b)    expands to A under madly.c, to B otherwise
 * TOKEN_GETMAD() expands to token_getmad() under madly.c, to null otherwise
 * TOKEN_FREE()   similarly
 * OP_GETMAD()    similarly
 * IVAL(i)        expands to (i)->tk_lval.ival or (i)
 * PVAL(p)        expands to (p)->tk_lval.pval or (p)
 *
d34 1
a34 3
%pure_parser

/* FIXME for MAD - is the new mintro on while and until important?  */
a43 10
#ifdef PERL_IN_MADLY_C
    TOKEN* p_tkval;
    TOKEN* i_tkval;
#else
    char *p_tkval;
    I32	i_tkval;
#endif
#ifdef PERL_MAD
    TOKEN* tkval;
#endif
d48 1
a48 1
%token <i_tkval> '{' '}' '[' ']' '-' '+' '$' '@@' '%' '*' '&' ';' '=' '.'
d53 10
a62 10
%token <p_tkval> LABEL
%token <i_tkval> FORMAT SUB ANONSUB PACKAGE USE
%token <i_tkval> WHILE UNTIL IF UNLESS ELSE ELSIF CONTINUE FOR
%token <i_tkval> GIVEN WHEN DEFAULT
%token <i_tkval> LOOPEX DOTDOT YADAYADA
%token <i_tkval> FUNC0 FUNC1 FUNC UNIOP LSTOP
%token <i_tkval> RELOP EQOP MULOP ADDOP
%token <i_tkval> DOLSHARP DO HASHBRACK NOAMP
%token <i_tkval> LOCAL MY REQUIRE
%token <i_tkval> COLONATTR FORMLBRACK FORMRBRACK
d66 1
a66 1
/* FIXME for MAD - are these two ival? */
d72 4
a75 3
%type <opval> listexpr nexpr texpr iexpr mexpr mnexpr miexpr
%type <opval> optlistexpr optexpr indirob listop method
%type <opval> formname subname proto optsubbody cont my_scalar formblock
d77 1
a77 1
%type <opval> realsubbody subsignature termbinop termunop anonymous termdo
d80 1
a80 1
%nonassoc <i_tkval> PREC_LOW
d83 3
a85 3
%left <i_tkval> OROP DOROP
%left <i_tkval> ANDOP
%right <i_tkval> NOTOP
d87 3
a89 3
%left <i_tkval> ','
%right <i_tkval> ASSIGNOP
%right <i_tkval> '?' ':'
d91 4
a94 4
%left <i_tkval> OROR DORDOR
%left <i_tkval> ANDAND
%left <i_tkval> BITOROP
%left <i_tkval> BITANDOP
d99 1
a99 1
%left <i_tkval> SHIFTOP
d102 7
a108 7
%left <i_tkval> MATCHOP
%right <i_tkval> '!' '~' UMINUS REFGEN
%right <i_tkval> POWOP
%nonassoc <i_tkval> PREINC PREDEC POSTINC POSTDEC POSTJOIN
%left <i_tkval> ARROW
%nonassoc <i_tkval> ')'
%left <i_tkval> '('
a110 2
%token <i_tkval> PEG

d116 1
a116 1
			  PL_parser->expect = XSTATE;
d121 1
d182 2
a183 2
			{ if (PL_parser->copline > (line_t)IVAL($1))
			      PL_parser->copline = (line_t)IVAL($1);
a184 2
			  TOKEN_GETMAD($1,$$,'{');
			  TOKEN_GETMAD($4,$$,'}');
d190 2
a191 2
			{ if (PL_parser->copline > (line_t)IVAL($1))
			      PL_parser->copline = (line_t)IVAL($1);
a192 2
			  TOKEN_GETMAD($1,$$,'{');
			  TOKEN_GETMAD($7,$$,'}');
d197 2
a198 1
			{ $$ = block_start(TRUE); }
d202 2
a203 2
			{ if (PL_parser->copline > (line_t)IVAL($1))
			      PL_parser->copline = (line_t)IVAL($1);
a204 2
			  TOKEN_GETMAD($1,$$,'{');
			  TOKEN_GETMAD($4,$$,'}');
d209 2
a210 1
			{ $$ = block_start(FALSE); }
d238 1
a238 5
			  if($1) {
			      $$ = newSTATEOP(0, NULL, $1);
			  } else {
			      $$ = IF_MAD(newOP(OP_NULL, 0), NULL);
			  }
d246 1
a246 5
			  $$ = newSTATEOP(SVf_UTF8
					   * PVAL($1)[strlen(PVAL($1))+1],
					  PVAL($1), $2);
			  TOKEN_GETMAD($1,
			      $2 ? cLISTOPx($$)->op_first : $$, 'L');
d250 1
a250 4
			  $$ = newSTATEOP(SVf_UTF8
					   * PVAL($1)[strlen(PVAL($1))+1],
					  PVAL($1), $2);
			  TOKEN_GETMAD($1, cLISTOPx($$)->op_first, 'L');
a256 5
	|	PEG
			{
			  $$ = newOP(OP_NULL,0);
			  TOKEN_GETMAD($1,$$,'p');
			}
a259 6
#ifdef MAD
			  $$ = newFORM($2, $3, $4);
			  prepend_madprops($1->tk_mad, $$, 'F');
			  $1->tk_mad = 0;
			  token_free($1);
#else
a261 1
#endif
d263 1
a263 2
			      SvREFCNT_inc_simple_void(fmtcv);
			      pad_add_anon(fmtcv, OP_NULL);
d265 1
d286 2
a287 2
			  PL_parser->in_my = 0;
			  PL_parser->in_my_stash = NULL;
a291 5
#ifdef MAD
			  {
			      OP* o = newSVOP(OP_ANONCODE, 0,
				(SV*)(
#endif
d295 14
a308 10
#ifdef MAD
				));
			      $$ = newOP(OP_NULL,0);
			      op_getmad(o,$$,'&');
			      op_getmad($2,$$,'n');
			      op_getmad($5,$$,'s');
			      op_getmad($6,$$,'a');
			      token_getmad($1,$$,'d');
			      append_madprops($7->op_madprop, $$, 0);
			      $7->op_madprop = 0;
d310 24
a333 1
#else
a335 1
#endif
d337 1
a340 7
#ifdef MAD
			  $$ = package($3);
			  token_getmad($1,$$,'o');
			  if ($2)
			      package_version($2);
			  token_getmad($4,$$,';');
#else
a344 1
#endif
d351 2
a352 9
#ifdef MAD
			  $$ = utilize(IVAL($1), $2, $4, $5, $6);
			  token_getmad($1,$$,'o');
			  token_getmad($7,$$,';');
			  if (PL_parser->rsfp_filters &&
				      AvFILLp(PL_parser->rsfp_filters) >= 0)
			      append_madprops(newMADPROP('!', MAD_NULL, NULL, 0), $$, 0);
#else
			  utilize(IVAL($1), $2, $4, $5, $6);
a353 1
#endif
d359 1
a359 4
			  TOKEN_GETMAD($1,$$,'I');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			  PL_parser->copline = (line_t)IVAL($1);
d361 1
a361 1
	|	UNLESS '(' remember miexpr ')' mblock else
d364 2
a365 5
			      newCONDOP(0, $4, op_scope($6), $7));
			  TOKEN_GETMAD($1,$$,'I');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			  PL_parser->copline = (line_t)IVAL($1);
d369 2
a370 8
			  const PADOFFSET offset = pad_findmy_pvs("$_", 0);
			  $$ = block_end($3,
				  newGIVENOP($4, op_scope($6),
				    offset == NOT_IN_PAD
				    || PAD_COMPNAME_FLAGS_isOUR(offset)
				      ? 0
				      : offset));
			  PL_parser->copline = (line_t)IVAL($1);
d381 1
a381 4
			  TOKEN_GETMAD($1,$$,'W');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			  PL_parser->copline = (line_t)IVAL($1);
d388 1
a388 4
			  TOKEN_GETMAD($1,$$,'W');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			  PL_parser->copline = (line_t)IVAL($1);
d390 5
a394 1
	|	FOR '(' remember mnexpr ';' texpr ';' mintro mnexpr ')'
d397 1
a397 1
			  OP *initop = IF_MAD($4 ? $4 : newOP(OP_NULL, 0), $4);
d399 1
a399 1
				      scalar($6), $11, $9, $8);
d406 1
a406 1
			  DO_MAD({ forop = newUNOP(OP_NULL, 0, forop); })
d408 1
a408 6
			  TOKEN_GETMAD($1,$$,'3');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,'1');
			  TOKEN_GETMAD($7,$$,'2');
			  TOKEN_GETMAD($10,$$,')');
			  PL_parser->copline = (line_t)IVAL($1);
d413 1
a413 5
			  TOKEN_GETMAD($1,$$,'W');
			  TOKEN_GETMAD($2,$$,'d');
			  TOKEN_GETMAD($5,$$,'(');
			  TOKEN_GETMAD($7,$$,')');
			  PL_parser->copline = (line_t)IVAL($1);
d419 24
a442 4
			  TOKEN_GETMAD($1,$$,'W');
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($6,$$,')');
			  PL_parser->copline = (line_t)IVAL($1);
d448 1
a448 4
			  TOKEN_GETMAD($1,$$,'W');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			  PL_parser->copline = (line_t)IVAL($1);
d468 2
a469 4
			  TOKEN_GETMAD($4,$$,'{');
			  TOKEN_GETMAD($8,$$,'}');
			  if (PL_parser->copline > (line_t)IVAL($4))
			      PL_parser->copline = (line_t)IVAL($4);
a472 1
			  PL_parser->expect = XSTATE;
a473 1
			  TOKEN_GETMAD($2,$$,';');
d477 2
a478 4
			  PL_parser->expect = XSTATE;
			  $$ = IF_MAD(newOP(OP_NULL, 0), (OP*)NULL);
			  TOKEN_GETMAD($1,$$,';');
			  PL_parser->copline = NOLINE;
a486 1
			      DO_MAD(term = newUNOP(OP_NULL, 0, term));
a489 4
#ifdef MAD
			      OP *op = newNULLLIST();
			      list = op_append_elem(OP_LIST, $1, op);
#else
a490 1
#endif
d492 3
a494 3
			  if (PL_parser->copline == NOLINE)
			       PL_parser->copline = CopLINE(PL_curcop)-1;
			  else PL_parser->copline--;
d496 1
a496 1
					  convert(OP_FORMLINE, 0, list));
d512 1
a512 3
			{ $$ = newLOGOP(OP_AND, 0, $3, $1);
			  TOKEN_GETMAD($2,$$,'i');
			}
d514 1
a514 3
			{ $$ = newLOGOP(OP_OR, 0, $3, $1);
			  TOKEN_GETMAD($2,$$,'i');
			}
d516 1
a516 3
			{ $$ = newLOOPOP(OPf_PARENS, 1, scalar($3), $1);
			  TOKEN_GETMAD($2,$$,'w');
			}
d518 1
a518 3
			{ $$ = newLOOPOP(OPf_PARENS, 1, $3, $1);
			  TOKEN_GETMAD($2,$$,'w');
			}
d521 1
a521 3
			  TOKEN_GETMAD($2,$$,'w');
			  PL_parser->copline = (line_t)IVAL($2);
			}
a532 1
			  TOKEN_GETMAD($1,$$,'o');
d535 1
a535 1
			{ PL_parser->copline = (line_t)IVAL($1);
a539 3
			  TOKEN_GETMAD($1,$$,'I');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($4,$$,')');
d547 1
a547 4
			{
			  $$ = op_scope($2);
			  TOKEN_GETMAD($1,$$,'o');
			}
a583 4
miexpr	:	iexpr
			{ $$ = $1; intro_my(); }
	;

d619 1
a619 3
			{ $$ = $2;
			  TOKEN_GETMAD($1,$$,':');
			}
d621 1
a621 6
			{ $$ = IF_MAD(
				    newOP(OP_NULL, 0),
				    (OP*)NULL
				);
			  TOKEN_GETMAD($1,$$,':');
			}
d626 1
a626 3
			{ $$ = $2;
			  TOKEN_GETMAD($1,$$,':');
			}
d628 1
a628 6
			{ $$ = IF_MAD(
				    newOP(OP_NULL, 0),
				    (OP*)NULL
				);
			  TOKEN_GETMAD($1,$$,':');
			}
d631 2
a632 3
/* Optional subroutine signature */
subsignature:	/* NULL */ { $$ = (OP*)NULL; }
	|	'('
d634 3
a636 3
			  if (!FEATURE_SIGNATURES_IS_ENABLED)
			    Perl_croak(aTHX_ "Experimental "
				"subroutine signatures not enabled");
d646 1
a646 13
			  PL_parser->expect = XBLOCK;
			}
	;

/* Subroutine body - block with optional signature */
realsubbody:	remember subsignature '{' stmtseq '}'
			{
			  if (PL_parser->copline > (line_t)IVAL($3))
			      PL_parser->copline = (line_t)IVAL($3);
			  $$ = block_end($1,
				op_append_list(OP_LINESEQ, $2, $4));
			  TOKEN_GETMAD($3,$$,'{');
			  TOKEN_GETMAD($5,$$,'}');
d651 2
a652 8
optsubbody:	realsubbody { $$ = $1; }
	|	';'	{ $$ = IF_MAD(
				    newOP(OP_NULL,0),
				    (OP*)NULL
				);
			  PL_parser->expect = XSTATE;
			  TOKEN_GETMAD($1,$$,';');
			}
d657 1
a657 3
			{ $$ = newLOGOP(OP_AND, 0, $1, $3);
			  TOKEN_GETMAD($2,$$,'o');
			}
d659 1
a659 3
			{ $$ = newLOGOP(IVAL($2), 0, $1, $3);
			  TOKEN_GETMAD($2,$$,'o');
			}
d661 1
a661 3
			{ $$ = newLOGOP(OP_DOR, 0, $1, $3);
			  TOKEN_GETMAD($2,$$,'o');
			}
d667 2
a669 10
#ifdef MAD
			  OP* op = newNULLLIST();
			  token_getmad($2,op,',');
			  $$ = op_append_elem(OP_LIST, $1, op);
#else
			  $$ = $1;
#endif
			}
	|	listexpr ',' term
			{ 
a670 4
			  DO_MAD(
			      term = newUNOP(OP_NULL, 0, term);
			      token_getmad($2,term,',');
			  )
d678 2
a679 3
			{ $$ = convert(IVAL($1), OPf_STACKED,
				op_prepend_elem(OP_LIST, newGVREF(IVAL($1),$2), $3) );
			  TOKEN_GETMAD($1,$$,'o');
d682 2
a683 5
			{ $$ = convert(IVAL($1), OPf_STACKED,
				op_prepend_elem(OP_LIST, newGVREF(IVAL($1),$3), $4) );
			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
d686 1
a686 1
			{ $$ = convert(OP_ENTERSUB, OPf_STACKED,
d689 1
a689 4
				    newUNOP(OP_METHOD, 0, $3)));
			  TOKEN_GETMAD($2,$$,'A');
			  TOKEN_GETMAD($4,$$,'(');
			  TOKEN_GETMAD($6,$$,')');
d692 1
a692 1
			{ $$ = convert(OP_ENTERSUB, OPf_STACKED,
d694 1
a694 2
				    newUNOP(OP_METHOD, 0, $3)));
			  TOKEN_GETMAD($2,$$,'A');
d697 1
a697 1
			{ $$ = convert(OP_ENTERSUB, OPf_STACKED,
d700 1
a700 1
				    newUNOP(OP_METHOD, 0, $1)));
d703 1
a703 1
			{ $$ = convert(OP_ENTERSUB, OPf_STACKED,
d706 1
a706 3
				    newUNOP(OP_METHOD, 0, $1)));
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
d709 1
a709 3
			{ $$ = convert(IVAL($1), 0, $2);
			  TOKEN_GETMAD($1,$$,'o');
			}
d711 1
a711 5
			{ $$ = convert(IVAL($1), 0, $3);
			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($4,$$,')');
			}
d731 1
a731 6
			{ $$ = newBINOP(OP_GELEM, 0, $1, scalar($3));
			    PL_parser->expect = XOPERATOR;
			  TOKEN_GETMAD($2,$$,'{');
			  TOKEN_GETMAD($4,$$,';');
			  TOKEN_GETMAD($5,$$,'}');
			}
a733 2
			  TOKEN_GETMAD($2,$$,'[');
			  TOKEN_GETMAD($4,$$,']');
a738 3
			  TOKEN_GETMAD($2,$$,'a');
			  TOKEN_GETMAD($3,$$,'[');
			  TOKEN_GETMAD($5,$$,']');
a743 2
			  TOKEN_GETMAD($2,$$,'[');
			  TOKEN_GETMAD($4,$$,']');
a746 4
			    PL_parser->expect = XOPERATOR;
			  TOKEN_GETMAD($2,$$,'{');
			  TOKEN_GETMAD($4,$$,';');
			  TOKEN_GETMAD($5,$$,'}');
d751 1
a751 7
					jmaybe($4));
			    PL_parser->expect = XOPERATOR;
			  TOKEN_GETMAD($2,$$,'a');
			  TOKEN_GETMAD($3,$$,'{');
			  TOKEN_GETMAD($5,$$,';');
			  TOKEN_GETMAD($6,$$,'}');
			}
d755 1
a755 6
					jmaybe($3));
			    PL_parser->expect = XOPERATOR;
			  TOKEN_GETMAD($2,$$,'{');
			  TOKEN_GETMAD($4,$$,';');
			  TOKEN_GETMAD($5,$$,'}');
			}
d758 1
a758 5
				   newCVREF(0, scalar($1)));
			  TOKEN_GETMAD($2,$$,'a');
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($4,$$,')');
			}
d762 1
a762 5
				       newCVREF(0, scalar($1))));
			  TOKEN_GETMAD($2,$$,'a');
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			}
d767 1
a767 4
					       newCVREF(0, scalar($1))));
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($4,$$,')');
			}
d770 1
a770 4
				   newCVREF(0, scalar($1)));
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($3,$$,')');
			}
d772 1
a772 6
			{ $$ = newSLICEOP(0, $5, $2);
			  TOKEN_GETMAD($1,$$,'(');
			  TOKEN_GETMAD($3,$$,')');
			  TOKEN_GETMAD($4,$$,'[');
			  TOKEN_GETMAD($6,$$,']');
			}
d774 1
a774 4
			{ $$ = newSLICEOP(0, $3, $1);
			  TOKEN_GETMAD($2,$$,'[');
			  TOKEN_GETMAD($4,$$,']');
			}
d776 1
a776 6
			{ $$ = newSLICEOP(0, $4, (OP*)NULL);
			  TOKEN_GETMAD($1,$$,'(');
			  TOKEN_GETMAD($2,$$,')');
			  TOKEN_GETMAD($3,$$,'[');
			  TOKEN_GETMAD($5,$$,']');
			}
d781 1
a781 3
			{ $$ = newASSIGNOP(OPf_STACKED, $1, IVAL($2), $3);
			  TOKEN_GETMAD($2,$$,'o');
			}
d783 1
a783 3
			{ $$ = newBINOP(IVAL($2), 0, scalar($1), scalar($3));
			  TOKEN_GETMAD($2,$$,'o');
			}
d785 1
a785 1
			{   if (IVAL($2) != OP_REPEAT)
d787 1
a787 2
			    $$ = newBINOP(IVAL($2), 0, $1, scalar($3));
			  TOKEN_GETMAD($2,$$,'o');
d790 1
a790 3
			{ $$ = newBINOP(IVAL($2), 0, scalar($1), scalar($3));
			  TOKEN_GETMAD($2,$$,'o');
			}
d792 1
a792 3
			{ $$ = newBINOP(IVAL($2), 0, scalar($1), scalar($3));
			  TOKEN_GETMAD($2,$$,'o');
			}
d794 1
a794 3
			{ $$ = newBINOP(IVAL($2), 0, scalar($1), scalar($3));
			  TOKEN_GETMAD($2,$$,'o');
			}
d796 1
a796 3
			{ $$ = newBINOP(IVAL($2), 0, scalar($1), scalar($3));
			  TOKEN_GETMAD($2,$$,'o');
			}
d798 1
a798 3
			{ $$ = newBINOP(IVAL($2), 0, scalar($1), scalar($3));
			  TOKEN_GETMAD($2,$$,'o');
			}
d800 1
a800 3
			{ $$ = newBINOP(IVAL($2), 0, scalar($1), scalar($3));
			  TOKEN_GETMAD($2,$$,'o');
			}
d802 1
a802 11
			{
			  $$ = newRANGE(IVAL($2), scalar($1), scalar($3));
			  DO_MAD({
			      UNOP *op;
			      op = (UNOP*)$$;
			      op = (UNOP*)op->op_first;	/* get to flop */
			      op = (UNOP*)op->op_first;	/* get to flip */
			      op = (UNOP*)op->op_first;	/* get to range */
			      token_getmad($2,(OP*)op,'o');
			    });
			}
d804 1
a804 3
			{ $$ = newLOGOP(OP_AND, 0, $1, $3);
			  TOKEN_GETMAD($2,$$,'o');
			}
d806 1
a806 3
			{ $$ = newLOGOP(OP_OR, 0, $1, $3);
			  TOKEN_GETMAD($2,$$,'o');
			}
d808 1
a808 3
			{ $$ = newLOGOP(OP_DOR, 0, $1, $3);
			  TOKEN_GETMAD($2,$$,'o');
			}
d810 1
a810 6
			{ $$ = bind_match(IVAL($2), $1, $3);
			  TOKEN_GETMAD($2,
				($$->op_type == OP_NOT
				    ? ((UNOP*)$$)->op_first : $$),
				'~');
			}
d815 1
a815 3
			{ $$ = newUNOP(OP_NEGATE, 0, scalar($2));
			  TOKEN_GETMAD($1,$$,'o');
			}
d817 2
a818 6
			{ $$ = IF_MAD(
				    newUNOP(OP_NULL, 0, $2),
				    $2
				);
			  TOKEN_GETMAD($1,$$,'+');
			}
d820 1
a820 3
			{ $$ = newUNOP(OP_NOT, 0, scalar($2));
			  TOKEN_GETMAD($1,$$,'o');
			}
d822 1
a822 3
			{ $$ = newUNOP(OP_COMPLEMENT, 0, scalar($2));
			  TOKEN_GETMAD($1,$$,'o');
			}
d825 1
a825 3
					op_lvalue(scalar($1), OP_POSTINC));
			  TOKEN_GETMAD($2,$$,'o');
			}
d828 1
a828 3
					op_lvalue(scalar($1), OP_POSTDEC));
			  TOKEN_GETMAD($2,$$,'o');
			}
d830 1
a830 1
			{ $$ = convert(OP_JOIN, 0,
a838 1
			  TOKEN_GETMAD($2,$$,'o');
d842 1
a842 3
					op_lvalue(scalar($2), OP_PREINC));
			  TOKEN_GETMAD($1,$$,'o');
			}
d845 1
a845 3
					op_lvalue(scalar($2), OP_PREDEC));
			  TOKEN_GETMAD($1,$$,'o');
			}
d851 1
a851 4
			{ $$ = newANONLIST($2);
			  TOKEN_GETMAD($1,$$,'[');
			  TOKEN_GETMAD($3,$$,']');
			}
d853 1
a853 4
			{ $$ = newANONLIST((OP*)NULL);
			  TOKEN_GETMAD($1,$$,'[');
			  TOKEN_GETMAD($2,$$,']');
			}
d855 1
a855 5
			{ $$ = newANONHASH($2);
			  TOKEN_GETMAD($1,$$,'{');
			  TOKEN_GETMAD($3,$$,';');
			  TOKEN_GETMAD($4,$$,'}');
			}
d857 2
a858 6
			{ $$ = newANONHASH((OP*)NULL);
			  TOKEN_GETMAD($1,$$,'{');
			  TOKEN_GETMAD($2,$$,';');
			  TOKEN_GETMAD($3,$$,'}');
			}
	|	ANONSUB startanonsub proto subattrlist realsubbody	%prec '('
d860 10
a869 4
			  $$ = newANONATTRSUB($2, $3, $4, $5);
			  TOKEN_GETMAD($1,$$,'o');
			  OP_GETMAD($3,$$,'s');
			  OP_GETMAD($4,$$,'a');
d876 1
a876 3
			{ $$ = dofile($2, IVAL($1));
			  TOKEN_GETMAD($1,$$,'o');
			}
d878 1
a878 3
			{ $$ = newUNOP(OP_NULL, OPf_SPECIAL, op_scope($2));
			  TOKEN_GETMAD($1,$$,'D');
			}
d886 1
a886 4
			{ $$ = newCONDOP(0, $1, $3, $5);
			  TOKEN_GETMAD($2,$$,'?');
			  TOKEN_GETMAD($4,$$,':');
			}
d888 1
a888 3
			{ $$ = newUNOP(OP_REFGEN, 0, op_lvalue($2,OP_REFGEN));
			  TOKEN_GETMAD($1,$$,'o');
			}
d892 1
a892 3
			{ $$ = localize($2,IVAL($1));
			  TOKEN_GETMAD($1,$$,'k');
			}
d894 1
a894 4
			{ $$ = sawparens(IF_MAD(newUNOP(OP_NULL,0,$2), $2));
			  TOKEN_GETMAD($1,$$,'(');
			  TOKEN_GETMAD($3,$$,')');
			}
d896 1
a896 1
			{ $$ = IF_MAD(newUNOP(OP_NULL,0,$1), $1); }
d898 1
a898 4
			{ $$ = sawparens(newNULLLIST());
			  TOKEN_GETMAD($1,$$,'(');
			  TOKEN_GETMAD($2,$$,')');
			}
a919 2
			  TOKEN_GETMAD($2,$$,'[');
			  TOKEN_GETMAD($4,$$,']');
a929 2
			  TOKEN_GETMAD($2,$$,'[');
			  TOKEN_GETMAD($4,$$,']');
a939 4
			    PL_parser->expect = XOPERATOR;
			  TOKEN_GETMAD($2,$$,'{');
			  TOKEN_GETMAD($4,$$,';');
			  TOKEN_GETMAD($5,$$,'}');
a949 4
			    PL_parser->expect = XOPERATOR;
			  TOKEN_GETMAD($2,$$,'{');
			  TOKEN_GETMAD($4,$$,';');
			  TOKEN_GETMAD($5,$$,'}');
a956 2
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($3,$$,')');
a961 8
			  DO_MAD({
			      OP* op = $$;
			      if (op->op_type == OP_CONST) { /* defeat const fold */
				op = (OP*)op->op_madprop->mad_val;
			      }
			      token_getmad($2,op,'(');
			      token_getmad($4,op,')');
			  });
a965 1
			  TOKEN_GETMAD($1,$$,'o');
d968 1
a968 3
			{ $$ = newSVREF($1);
			  TOKEN_GETMAD($3,$$,'$');
			}
d970 1
a970 3
			{ $$ = newAVREF($1);
			  TOKEN_GETMAD($3,$$,'@@');
			}
d972 1
a972 3
			{ $$ = newHVREF($1);
			  TOKEN_GETMAD($3,$$,'%');
			}
d975 1
a975 3
				       scalar(newCVREF(IVAL($3),$1)));
			  TOKEN_GETMAD($3,$$,'&');
			}
d977 1
a977 3
			{ $$ = newGVREF(0,$1);
			  TOKEN_GETMAD($3,$$,'*');
			}
d979 2
a980 4
			{ $$ = newOP(IVAL($1), OPf_SPECIAL);
			    PL_hints |= HINT_BLOCK_SCOPE;
			  TOKEN_GETMAD($1,$$,'o');
			}
d982 1
a982 3
			{ $$ = newLOOPEX(IVAL($1),$2);
			  TOKEN_GETMAD($1,$$,'o');
			}
d984 1
a984 3
			{ $$ = newUNOP(OP_NOT, 0, scalar($2));
			  TOKEN_GETMAD($1,$$,'o');
			}
d986 1
a986 3
			{ $$ = newOP(IVAL($1), 0);
			  TOKEN_GETMAD($1,$$,'o');
			}
d988 1
a988 3
			{ $$ = newUNOP(IVAL($1), 0, $2);
			  TOKEN_GETMAD($1,$$,'o');
			}
d990 1
a990 3
			{ $$ = newUNOP(IVAL($1), 0, $2);
			  TOKEN_GETMAD($1,$$,'o');
			}
d992 1
a992 3
			{ $$ = newOP(OP_REQUIRE, $1 ? OPf_SPECIAL : 0);
			  TOKEN_GETMAD($1,$$,'o');
			}
d994 1
a994 3
			{ $$ = newUNOP(OP_REQUIRE, $1 ? OPf_SPECIAL : 0, $2);
			  TOKEN_GETMAD($1,$$,'o');
			}
d1001 1
a1001 3
			{ $$ = newOP(IVAL($1), 0);
			  TOKEN_GETMAD($1,$$,'o');
			}
d1003 1
a1003 5
			{ $$ = newOP(IVAL($1), 0);
			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($3,$$,')');
			}
d1007 1
a1007 4
			{ $$ = $1;
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($3,$$,')');
			}
d1009 1
a1009 2
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
				scalar($1)); }
d1011 3
a1013 8
			{ $$ = (IVAL($1) == OP_NOT)
			    ? newUNOP(IVAL($1), 0, newSVOP(OP_CONST, 0, newSViv(0)))
			    : newOP(IVAL($1), OPf_SPECIAL);

			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($3,$$,')');
			}
d1015 1
a1015 5
			{ $$ = newUNOP(IVAL($1), 0, $3);
			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($4,$$,')');
			}
d1027 2
a1028 5
		    '(' listexpr ')'
			{ $$ = pmruntime($1, $4, 1, $<ival>2);
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			}
a1034 1
			  TOKEN_GETMAD($1,$$,'X');
d1041 1
a1041 7
			{ $$ = my_attrs($2,$3);
			  DO_MAD(
			      token_getmad($1,$$,'d');
			      append_madprops($3->op_madprop, $$, 'a');
			      $3->op_madprop = 0;
			  );
			}
d1043 1
a1043 3
			{ $$ = localize($2,IVAL($1));
			  TOKEN_GETMAD($1,$$,'d');
			}
d1048 1
a1048 4
			{ $$ = sawparens($2);
			  TOKEN_GETMAD($1,$$,'(');
			  TOKEN_GETMAD($3,$$,')');
			}
d1050 2
a1051 4
			{ $$ = sawparens(newNULLLIST());
			  TOKEN_GETMAD($1,$$,'(');
			  TOKEN_GETMAD($2,$$,')');
			}
d1073 6
d1082 10
a1091 1
			{ PL_parser->in_my = 0; $$ = my($1); }
d1095 1
a1095 3
			{ $$ = newCVREF(IVAL($1),$2);
			  TOKEN_GETMAD($1,$$,'&');
			}
d1099 1
a1099 3
			{ $$ = newSVREF($2);
			  TOKEN_GETMAD($1,$$,'$');
			}
d1104 1
a1104 2
			  if ($$) $$->op_private |= IVAL($1);
			  TOKEN_GETMAD($1,$$,'@@');
d1110 1
a1110 2
			  if ($$) $$->op_private |= IVAL($1);
			  TOKEN_GETMAD($1,$$,'%');
d1115 1
a1115 3
			{ $$ = newAVREF($2);
			  TOKEN_GETMAD($1,$$,'l');
			}
d1117 1
a1117 3
			{ $$ = newAVREF($1);
			  TOKEN_GETMAD($3,$$,'l');
			}
d1121 1
a1121 3
			{ $$ = newGVREF(0,$2);
			  TOKEN_GETMAD($1,$$,'*');
			}
d1126 1
a1126 3
			{ $$ = newAVREF($1);
			  TOKEN_GETMAD($3,$$,'@@');
			}
d1131 1
a1131 3
			{ $$ = newHVREF($1);
			  TOKEN_GETMAD($3,$$,'@@');
			}
d1136 1
a1136 3
			{ $$ = newGVREF(0,$1);
			  TOKEN_GETMAD($3,$$,'*');
			}
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d97 1
d100 1
a100 1
%type <opval> formname subname proto subbody cont my_scalar formblock
d102 1
a102 1
%type <opval> termbinop termunop anonymous termdo
d130 1
a130 1
%nonassoc <i_tkval> PREINC PREDEC POSTINC POSTDEC
d342 1
a342 1
		proto subattrlist subbody
d731 34
a764 2
/* Subroutine body - either null or a block */
subbody	:	block	{ $$ = $1; }
d881 1
a881 1
subscripted:    star '{' expr ';' '}'        /* *main::{something} */
d1088 12
d1136 1
a1136 1
	|	ANONSUB startanonsub proto subattrlist block	%prec '('
a1154 43
	|	DO subname '(' ')'                  /* do somesub() */
			{ $$ = newUNOP(OP_ENTERSUB,
			    OPf_SPECIAL|OPf_STACKED,
			    op_prepend_elem(OP_LIST,
				scalar(newCVREF(
				    (OPpENTERSUB_AMPER<<8),
				    scalar($2)
				)),(OP*)NULL)); dep();
			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($4,$$,')');
			}
	|	DO subname '(' expr ')'             /* do somesub(@@args) */
			{ $$ = newUNOP(OP_ENTERSUB,
			    OPf_SPECIAL|OPf_STACKED,
			    op_append_elem(OP_LIST,
				$4,
				scalar(newCVREF(
				    (OPpENTERSUB_AMPER<<8),
				    scalar($2)
				)))); dep();
			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			}
	|	DO scalar '(' ')'                /* do $subref () */
			{ $$ = newUNOP(OP_ENTERSUB, OPf_SPECIAL|OPf_STACKED,
			    op_prepend_elem(OP_LIST,
				scalar(newCVREF(0,scalar($2))), (OP*)NULL)); dep();
			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($4,$$,')');
			}
	|	DO scalar '(' expr ')'           /* do $subref (@@args) */
			{ $$ = newUNOP(OP_ENTERSUB, OPf_SPECIAL|OPf_STACKED,
			    op_prepend_elem(OP_LIST,
				$4,
				scalar(newCVREF(0,scalar($2))))); dep();
			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			}

d1200 1
a1200 1
	|	ary '[' expr ']'                     /* array slice */
d1206 15
d1224 1
a1224 1
	|	ary '{' expr ';' '}'                 /* @@hash{@@keys} */
d1230 17
d1256 1
a1256 1
	|	amper '(' ')'                 /* &foo() */
d1261 1
a1261 1
	|	amper '(' expr ')'            /* &foo(@@args) */
d1274 1
a1274 1
	|	NOAMP subname optlistexpr               /* foo(@@args) */
d1279 21
d1467 1
d1474 1
d1483 4
d1492 21
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d74 1
a74 1
%token <i_tkval> '{' '}' '[' ']' '-' '+' '$' '@@' '%' '*' '&' ';'
d87 2
a88 4
%token <i_tkval> LOCAL MY MYSUB REQUIRE
%token <i_tkval> COLONATTR

%type <i_tkval> lpar_or_qw
d93 1
a93 1
%type <ival> mydefsv mintro
d99 1
a99 1
%type <opval> formname subname proto subbody cont my_scalar
d102 1
d215 10
a228 4
mydefsv:	/* NULL */	/* lexicalize $_ */
			{ $$ = (I32) Perl_allocmy(aTHX_ STR_WITH_LEN("$_"), 0); }
	;

d253 11
d279 3
a281 2
			  $$ = newSTATEOP(SvUTF8(((SVOP*)$1)->op_sv),
                                        savepv(SvPVX(((SVOP*)$1)->op_sv)), $2);
d287 3
a289 2
			  $$ = newSTATEOP(SvUTF8(((SVOP*)$1)->op_sv),
                                        savepv(SvPVX(((SVOP*)$1)->op_sv)), $2);
d302 1
a302 1
	|	FORMAT startformsub formname block
a304 1
			  SvREFCNT_inc_simple_void(PL_compcv);
d314 1
a314 1
			  if (CvOUTSIDE(fmtcv) && !CvUNIQUE(CvOUTSIDE(fmtcv))) {
d319 23
a341 1
	|	SUB startsub subname proto subattrlist subbody
d347 7
a353 1
				(SV*)newATTRSUB($2, $3, $4, $5, $6));
d356 3
a358 3
			      op_getmad($3,$$,'n');
			      op_getmad($4,$$,'s');
			      op_getmad($5,$$,'a');
d360 2
a361 2
			      append_madprops($6->op_madprop, $$, 0);
			      $6->op_madprop = 0;
d364 1
a364 13
			  newATTRSUB($2, $3, $4, $5, $6);
			  $$ = (OP*)NULL;
#endif
			}
	|	MYSUB startsub subname proto subattrlist subbody
			{
			  /* Unimplemented "my sub foo { }" */
			  SvREFCNT_inc_simple_void(PL_compcv);
#ifdef MAD
			  $$ = newMYSUB($2, $3, $4, $5, $6);
			  token_getmad($1,$$,'d');
#else
			  newMYSUB($2, $3, $4, $5, $6);
d367 1
d401 1
a401 1
	|	IF lpar_or_qw remember mexpr ')' mblock else
d410 1
a410 1
	|	UNLESS lpar_or_qw remember miexpr ')' mblock else
d419 1
a419 1
	|	GIVEN lpar_or_qw remember mydefsv mexpr ')' mblock
d421 1
d423 5
a427 1
				  newGIVENOP($5, op_scope($7), (PADOFFSET)$4));
d430 1
a430 1
	|	WHEN lpar_or_qw remember mexpr ')' mblock
d434 1
a434 1
	|	WHILE lpar_or_qw remember texpr ')' mintro mblock cont
d444 1
a444 1
	|	UNTIL lpar_or_qw remember iexpr ')' mintro mblock cont
d454 1
a454 1
	|	FOR lpar_or_qw remember mnexpr ';' texpr ';' mintro mnexpr ')'
d475 1
a475 1
	|	FOR MY remember my_scalar lpar_or_qw mexpr ')' mblock cont
d484 1
a484 1
	|	FOR scalar lpar_or_qw remember mexpr ')' mblock cont
d493 1
a493 1
	|	FOR lpar_or_qw remember mexpr ')' mblock cont
a509 2
			  int save_3_latefree = $3->op_latefree;
			  $3->op_latefree = 1;
a510 1
			  $3->op_latefree = save_3_latefree;
a511 2
			      int save_2_latefree = $2->op_latefree;
			      $2->op_latefree = 1;
a512 1
			      $2->op_latefree = save_2_latefree;
a519 3
			  op_free($3);
			  if ($2)
			      op_free($2);
d540 30
d609 1
a609 1
	|	ELSIF lpar_or_qw mexpr ')' mblock else
d690 2
a691 6
subname	:	WORD	{ const char *const name = SvPV_nolen_const(((SVOP*)$1)->op_sv);
			  if (strEQ(name, "BEGIN") || strEQ(name, "END")
			      || strEQ(name, "INIT") || strEQ(name, "CHECK")
			      || strEQ(name, "UNITCHECK"))
			      CvSPECIAL_on(PL_compcv);
			  $$ = $1; }
d793 1
a793 1
	|	term ARROW method lpar_or_qw optexpr ')' /* $foo->bar(list) */
d919 1
a919 1
	|	subscripted lpar_or_qw expr ')'   /* $foo->{bar}->(@@args) */
d926 1
a926 1
	|	subscripted lpar_or_qw ')'        /* $foo->{bar}->() */
d1002 1
a1002 1
			    })
d1110 1
a1110 1
	|	DO WORD lpar_or_qw ')'                  /* do somesub() */
d1122 1
a1122 1
	|	DO WORD lpar_or_qw expr ')'             /* do somesub(@@args) */
d1135 1
a1135 1
	|	DO scalar lpar_or_qw ')'                /* do $subref () */
d1143 1
a1143 1
	|	DO scalar lpar_or_qw expr ')'           /* do $subref (@@args) */
d1222 1
a1222 1
	|	amper lpar_or_qw ')'                 /* &foo() */
d1227 1
a1227 1
	|	amper lpar_or_qw expr ')'            /* &foo(@@args) */
d1238 1
a1238 1
			  })
d1240 1
a1240 1
	|	NOAMP WORD optlistexpr               /* foo(@@args) */
d1318 15
a1332 4
	|	PMFUNC '(' listexpr ')'		/* m//, s///, tr/// */
			{ $$ = pmruntime($1, $3, 1);
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($4,$$,')');
d1352 1
a1352 1
			  )
a1389 8
	;

lpar_or_qw:	'('
			{ $$ = $1; }
	|	QWLIST
			{ munge_qwlist_to_paren_list($1); }
		'('
			{ $$ = $3; }
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d4 1
a4 1
 *    Copyright (c) 2007, 2008 by Larry Wall and others
d52 1
a52 1
%start prog
d72 2
d76 2
a77 2
%token <opval> WORD METHOD FUNCMETH THING PMFUNC PRIVATEREF
%token <opval> FUNC0SUB UNIOPSUB LSTOPSUB
d90 3
a92 1
%type <ival> prog progstart remember mremember
d97 1
a97 3
%type <opval> decl format subrout mysubrout package use peg

%type <opval> block mblock lineseq line loop cond else
d99 2
a100 2
%type <opval> argexpr nexpr texpr iexpr mexpr mnexpr miexpr
%type <opval> listexpr listexprcom indirob listop method
a103 2
%type <opval> switch case
%type <p_tkval> label
d140 64
a203 4
/* The whole program */
prog	:	progstart
	/*CONTINUED*/	lineseq
			{ $$ = $1; newPROG(block_end($1,$2)); }
d207 1
a207 1
block	:	'{' remember lineseq '}'
d224 1
a224 8
progstart:
		{
		    PL_parser->expect = XSTATE; $$ = block_start(TRUE);
		}
	;


mblock	:	'{' mremember lineseq '}'
d237 2
a238 2
/* A collection of "lines" in the program */
lineseq	:	/* NULL */
d240 2
a241 10
	|	lineseq decl
			{
			$$ = IF_MAD(
				append_list(OP_LINESEQ,
			    	    (LISTOP*)$1, (LISTOP*)$2),
				$1);
			}
	|	lineseq line
			{   $$ = append_list(OP_LINESEQ,
				(LISTOP*)$1, (LISTOP*)$2);
d248 10
a257 6
/* A "line" in the program */
line	:	label cond
			{ $$ = newSTATEOP(0, PVAL($1), $2);
			  TOKEN_GETMAD($1,((LISTOP*)$$)->op_first,'L'); }
	|	loop	/* loops add their own labels */
	|	switch  /* ... and so do switches */
d259 167
a425 8
	|	label case
			{ $$ = newSTATEOP(0, PVAL($1), $2); }
	|	label ';'
			{
			  if (PVAL($1)) {
			      $$ = newSTATEOP(0, PVAL($1), newOP(OP_NULL, 0));
			      TOKEN_GETMAD($1,$$,'L');
			      TOKEN_GETMAD($2,((LISTOP*)$$)->op_first,';');
d427 53
a479 7
			  else {
			      $$ = IF_MAD(
					newOP(OP_NULL, 0),
					(OP*)NULL);
                              PL_parser->copline = NOLINE;
			      TOKEN_FREE($1);
			      TOKEN_GETMAD($2,$$,';');
d481 16
d498 2
d501 1
a501 1
	|	label sideff ';'
a502 1
			  $$ = newSTATEOP(0, PVAL($1), $2);
d504 3
a506 11
			  DO_MAD({
			      /* sideff might already have a nexstate */
			      OP* op = ((LISTOP*)$$)->op_first;
			      if (op) {
				  while (op->op_sibling &&
				     op->op_sibling->op_type == OP_NEXTSTATE)
					op = op->op_sibling;
				  token_getmad($1,op,'L');
				  token_getmad($3,op,';');
			      }
			  })
a507 2
	|	label PLUGSTMT
			{ $$ = newSTATEOP(0, PVAL($1), $2); }
d532 3
a534 3
			{ $$ = newFOROP(0, NULL, (line_t)IVAL($2),
					(OP*)NULL, $3, $1, (OP*)NULL);
			  TOKEN_GETMAD($2,((LISTOP*)$$)->op_first->op_sibling,'w');
d537 1
a537 1
			{ $$ = newWHENOP($3, scope($1)); }
d544 3
a546 1
			{ ($2)->op_flags |= OPf_PARENS; $$ = scope($2);
d549 1
a549 1
	|	ELSIF '(' mexpr ')' mblock else
d551 4
a554 2
			    $$ = newCONDOP(0, newSTATEOP(OPf_SPECIAL,NULL,$3), scope($5), $6);
			    PL_hints |= HINT_BLOCK_SCOPE;
a560 27
/* Real conditional expressions */
cond	:	IF '(' remember mexpr ')' mblock else
			{ PL_parser->copline = (line_t)IVAL($1);
			    $$ = block_end($3,
				   newCONDOP(0, $4, scope($6), $7));
			  TOKEN_GETMAD($1,$$,'I');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			}
	|	UNLESS '(' remember miexpr ')' mblock else
			{ PL_parser->copline = (line_t)IVAL($1);
			    $$ = block_end($3,
				   newCONDOP(0, $4, scope($6), $7));
			  TOKEN_GETMAD($1,$$,'I');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			}
	;

/* Cases for a switch statement */
case	:	WHEN '(' remember mexpr ')' mblock
	{ $$ = block_end($3,
		newWHENOP($4, scope($6))); }
	|	DEFAULT block
	{ $$ = newWHENOP(0, scope($2)); }
	;

d565 2
a566 1
			{ $$ = scope($2);
a570 105
/* Loops: while, until, for, and a bare block */
loop	:	label WHILE '(' remember texpr ')' mintro mblock cont
			{ OP *innerop;
			  PL_parser->copline = (line_t)IVAL($2);
			    $$ = block_end($4,
				   newSTATEOP(0, PVAL($1),
				     innerop = newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
						IVAL($2), $5, $8, $9, $7)));
			  TOKEN_GETMAD($1,innerop,'L');
			  TOKEN_GETMAD($2,innerop,'W');
			  TOKEN_GETMAD($3,innerop,'(');
			  TOKEN_GETMAD($6,innerop,')');
			}

	|	label UNTIL '(' remember iexpr ')' mintro mblock cont
			{ OP *innerop;
			  PL_parser->copline = (line_t)IVAL($2);
			    $$ = block_end($4,
				   newSTATEOP(0, PVAL($1),
				     innerop = newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
						IVAL($2), $5, $8, $9, $7)));
			  TOKEN_GETMAD($1,innerop,'L');
			  TOKEN_GETMAD($2,innerop,'W');
			  TOKEN_GETMAD($3,innerop,'(');
			  TOKEN_GETMAD($6,innerop,')');
			}
	|	label FOR MY remember my_scalar '(' mexpr ')' mblock cont
			{ OP *innerop;
			  $$ = block_end($4,
			     innerop = newFOROP(0, PVAL($1), (line_t)IVAL($2),
					    $5, $7, $9, $10));
			  TOKEN_GETMAD($1,((LISTOP*)innerop)->op_first,'L');
			  TOKEN_GETMAD($2,((LISTOP*)innerop)->op_first->op_sibling,'W');
			  TOKEN_GETMAD($3,((LISTOP*)innerop)->op_first->op_sibling,'d');
			  TOKEN_GETMAD($6,((LISTOP*)innerop)->op_first->op_sibling,'(');
			  TOKEN_GETMAD($8,((LISTOP*)innerop)->op_first->op_sibling,')');
			}
	|	label FOR scalar '(' remember mexpr ')' mblock cont
			{ OP *innerop;
			  $$ = block_end($5,
			     innerop = newFOROP(0, PVAL($1), (line_t)IVAL($2),
				    mod($3, OP_ENTERLOOP), $6, $8, $9));
			  TOKEN_GETMAD($1,((LISTOP*)innerop)->op_first,'L');
			  TOKEN_GETMAD($2,((LISTOP*)innerop)->op_first->op_sibling,'W');
			  TOKEN_GETMAD($4,((LISTOP*)innerop)->op_first->op_sibling,'(');
			  TOKEN_GETMAD($7,((LISTOP*)innerop)->op_first->op_sibling,')');
			}
	|	label FOR '(' remember mexpr ')' mblock cont
			{ OP *innerop;
			  $$ = block_end($4,
			     innerop = newFOROP(0, PVAL($1), (line_t)IVAL($2),
						    (OP*)NULL, $5, $7, $8));
			  TOKEN_GETMAD($1,((LISTOP*)innerop)->op_first,'L');
			  TOKEN_GETMAD($2,((LISTOP*)innerop)->op_first->op_sibling,'W');
			  TOKEN_GETMAD($3,((LISTOP*)innerop)->op_first->op_sibling,'(');
			  TOKEN_GETMAD($6,((LISTOP*)innerop)->op_first->op_sibling,')');
			}
	|	label FOR '(' remember mnexpr ';' texpr ';' mintro mnexpr ')'
	    	    mblock
			/* basically fake up an initialize-while lineseq */
			{ OP *forop;
			  PL_parser->copline = (line_t)IVAL($2);
			  forop = newSTATEOP(0, PVAL($1),
					    newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
						IVAL($2), scalar($7),
						$12, $10, $9));
#ifdef MAD
			  forop = newUNOP(OP_NULL, 0, append_elem(OP_LINESEQ,
				newSTATEOP(0,
					   CopLABEL_alloc(($1)->tk_lval.pval),
					   ($5 ? $5 : newOP(OP_NULL, 0)) ),
				forop));

			  token_getmad($2,forop,'3');
			  token_getmad($3,forop,'(');
			  token_getmad($6,forop,'1');
			  token_getmad($8,forop,'2');
			  token_getmad($11,forop,')');
			  token_getmad($1,forop,'L');
#else
			  if ($5) {
				forop = append_elem(OP_LINESEQ,
                                        newSTATEOP(0, CopLABEL_alloc($1), $5),
					forop);
			  }


#endif
			  $$ = block_end($4, forop); }
	|	label block cont  /* a block is a loop that happens once */
			{ $$ = newSTATEOP(0, PVAL($1),
				 newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
					    NOLINE, (OP*)NULL, $2, $3, 0));
			  TOKEN_GETMAD($1,((LISTOP*)$$)->op_first,'L'); }
	;

/* Switch blocks */
switch	:	label GIVEN '(' remember mydefsv mexpr ')' mblock
			{ PL_parser->copline = (line_t) IVAL($2);
			    $$ = block_end($4,
				newSTATEOP(0, PVAL($1),
				    newGIVENOP($6, scope($8),
					(PADOFFSET) $5) )); }
	;

a608 58
/* Optional "MAIN:"-style loop labels */
label	:	/* empty */
			{
#ifdef MAD
			  YYSTYPE tmplval;
			  tmplval.pval = NULL;
			  $$ = newTOKEN(OP_NULL, tmplval, 0);
#else
			  $$ = NULL;
#endif
			}
	|	LABEL
	;

/* Some kind of declaration - just hang on peg in the parse tree */
decl	:	format
			{ $$ = $1; }
	|	subrout
			{ $$ = $1; }
	|	mysubrout
			{ $$ = $1; }
	|	package
			{ $$ = $1; }
	|	use
			{ $$ = $1; }

    /* these two are only used by MAD */

	|	peg
			{ $$ = $1; }
	;

peg	:	PEG
			{ $$ = newOP(OP_NULL,0);
			  TOKEN_GETMAD($1,$$,'p');
			}
	;

format	:	FORMAT startformsub formname block
			{
			  CV *fmtcv = PL_compcv;
			  SvREFCNT_inc_simple_void(PL_compcv);
#ifdef MAD
			  $$ = newFORM($2, $3, $4);
			  prepend_madprops($1->tk_mad, $$, 'F');
			  $1->tk_mad = 0;
			  token_free($1);
#else
			  newFORM($2, $3, $4);
			  $$ = (OP*)NULL;
#endif
			  if (CvOUTSIDE(fmtcv) && !CvUNIQUE(CvOUTSIDE(fmtcv))) {
			    SvREFCNT_inc_simple_void(fmtcv);
			    pad_add_anon((SV*)fmtcv, OP_NULL);
			  }
			}
	;

a612 36
/* Unimplemented "my sub foo { }" */
mysubrout:	MYSUB startsub subname proto subattrlist subbody
			{ SvREFCNT_inc_simple_void(PL_compcv);
#ifdef MAD
			  $$ = newMYSUB($2, $3, $4, $5, $6);
			  token_getmad($1,$$,'d');
#else
			  newMYSUB($2, $3, $4, $5, $6);
			  $$ = (OP*)NULL;
#endif
			}
	;

/* Subroutine definition */
subrout	:	SUB startsub subname proto subattrlist subbody
			{ SvREFCNT_inc_simple_void(PL_compcv);
#ifdef MAD
			  {
			      OP* o = newSVOP(OP_ANONCODE, 0,
				(SV*)newATTRSUB($2, $3, $4, $5, $6));
			      $$ = newOP(OP_NULL,0);
			      op_getmad(o,$$,'&');
			      op_getmad($3,$$,'n');
			      op_getmad($4,$$,'s');
			      op_getmad($5,$$,'a');
			      token_getmad($1,$$,'d');
			      append_madprops($6->op_madprop, $$, 0);
			      $6->op_madprop = 0;
			    }
#else
			  newATTRSUB($2, $3, $4, $5, $6);
			  $$ = (OP*)NULL;
#endif
			}
	;

a684 35
package :	PACKAGE WORD WORD ';'
			{
#ifdef MAD
			  $$ = package($3);
			  token_getmad($1,$$,'o');
			  if ($2)
			      package_version($2);
			  token_getmad($4,$$,';');
#else
			  package($3);
			  if ($2)
			      package_version($2);
			  $$ = (OP*)NULL;
#endif
			}
	;

use	:	USE startsub
			{ CvSPECIAL_on(PL_compcv); /* It's a BEGIN {} */ }
		    WORD WORD listexpr ';'
			{ SvREFCNT_inc_simple_void(PL_compcv);
#ifdef MAD
			  $$ = utilize(IVAL($1), $2, $4, $5, $6);
			  token_getmad($1,$$,'o');
			  token_getmad($7,$$,';');
			  if (PL_parser->rsfp_filters &&
				      AvFILLp(PL_parser->rsfp_filters) >= 0)
			      append_madprops(newMADPROP('!', MAD_NULL, NULL, 0), $$, 0);
#else
			  utilize(IVAL($1), $2, $4, $5, $6);
			  $$ = (OP*)NULL;
#endif
			}
	;

d698 1
a698 1
	|	argexpr %prec PREC_LOW
d702 1
a702 1
argexpr	:	argexpr ','
d707 1
a707 1
			  $$ = append_elem(OP_LIST, $1, op);
d712 1
a712 1
	|	argexpr ',' term
d719 1
a719 1
			  $$ = append_elem(OP_LIST, $1, term);
d725 1
a725 1
listop	:	LSTOP indirob argexpr /* map {...} @@args or print $fh @@args */
d727 1
a727 1
				prepend_elem(OP_LIST, newGVREF(IVAL($1),$2), $3) );
d732 1
a732 1
				prepend_elem(OP_LIST, newGVREF(IVAL($1),$3), $4) );
d737 1
a737 1
	|	term ARROW method '(' listexprcom ')' /* $foo->bar(list) */
d739 2
a740 2
				append_elem(OP_LIST,
				    prepend_elem(OP_LIST, scalar($1), $5),
d748 1
a748 1
				append_elem(OP_LIST, scalar($1),
d752 1
a752 1
	|	METHOD indirob listexpr              /* new Class @@args */
d754 2
a755 2
				append_elem(OP_LIST,
				    prepend_elem(OP_LIST, $2, $3),
d758 1
a758 1
	|	FUNCMETH indirob '(' listexprcom ')' /* method $object (@@args) */
d760 2
a761 2
				append_elem(OP_LIST,
				    prepend_elem(OP_LIST, $2, $4),
d766 1
a766 1
	|	LSTOP listexpr                       /* print @@args */
d770 1
a770 1
	|	FUNC '(' listexprcom ')'             /* print (@@args) */
d779 1
a779 1
		    listexpr		%prec LSTOP  /* ... @@bar */
d781 2
a782 2
				 append_elem(OP_LIST,
				   prepend_elem(OP_LIST, $<opval>4, $5), $1));
d821 1
a821 1
	|	scalar '{' expr ';' '}'    /* $foo->{bar();} */
d856 1
a856 1
				   append_elem(OP_LIST, $4,
d863 1
a863 1
	|	subscripted '(' expr ')'   /* $foo->{bar}->(@@args) */
d865 1
a865 1
				   append_elem(OP_LIST, $3,
d870 1
a870 1
	|	subscripted '(' ')'        /* $foo->{bar}->() */
d883 5
d991 1
a991 1
					mod(scalar($1), OP_POSTINC));
d996 1
a996 1
					mod(scalar($1), OP_POSTDEC));
d1001 1
a1001 1
					mod(scalar($2), OP_PREINC));
d1006 1
a1006 1
					mod(scalar($2), OP_PREDEC));
d1051 1
a1051 1
			{ $$ = newUNOP(OP_NULL, OPf_SPECIAL, scope($2));
d1054 1
a1054 1
	|	DO WORD '(' ')'                         /* do somesub() */
d1057 1
a1057 1
			    prepend_elem(OP_LIST,
d1066 1
a1066 1
	|	DO WORD '(' expr ')'                    /* do somesub(@@args) */
d1069 1
a1069 1
			    append_elem(OP_LIST,
d1079 1
a1079 1
	|	DO scalar '(' ')'                      /* do $subref () */
d1081 1
a1081 1
			    prepend_elem(OP_LIST,
d1087 1
a1087 1
	|	DO scalar '(' expr ')'                 /* do $subref (@@args) */
d1089 1
a1089 1
			    prepend_elem(OP_LIST,
d1109 1
a1109 1
			{ $$ = newUNOP(OP_REFGEN, 0, mod($2,OP_REFGEN));
d1123 2
d1143 1
a1143 1
			{ $$ = prepend_elem(OP_ASLICE,
d1152 1
a1152 1
			{ $$ = prepend_elem(OP_HSLICE,
d1166 1
a1166 1
	|	amper '(' ')'                        /* &foo() */
d1171 1
a1171 1
	|	amper '(' expr ')'                   /* &foo(@@args) */
d1174 1
a1174 1
				append_elem(OP_LIST, $3, scalar($1)));
d1184 1
a1184 1
	|	NOAMP WORD listexpr                  /* foo(@@args) */
d1186 1
a1186 1
			    append_elem(OP_LIST, $3, scalar($2)));
d1198 1
a1198 1
	|	NOTOP argexpr                        /* not $foo */
d1226 1
a1226 1
			    append_elem(OP_LIST, $2, scalar($1))); }
d1237 7
d1262 1
a1262 1
	|	PMFUNC '(' argexpr ')'		/* m//, s///, tr/// */
d1313 1
a1313 1
listexpr:	/* NULL */ %prec PREC_LOW
d1315 1
a1315 1
	|	argexpr    %prec PREC_LOW
d1319 1
a1319 1
listexprcom:	/* NULL */
d1323 1
a1323 9
	|	expr ','
			{
#ifdef MAD
			  OP* op = newNULLLIST();
			  token_getmad($2,op,',');
			  $$ = append_elem(OP_LIST, $1, op);
#else
			  $$ = $1;
#endif
d1325 6
a1330 1
			}
d1381 1
a1381 1
			{ $$ = scope($1); }
@


1.12
log
@Merge in perl 5.10.1
@
text
@d76 1
d81 1
a81 1
%token <i_tkval> LOOPEX DOTDOT
d115 1
a115 1
%nonassoc DOTDOT
d161 1
a161 1
			{ $$ = (I32) allocmy("$_"); }
d245 2
d275 2
d335 1
a335 1
			  PL_parser->copline = (line_t)$2;
d348 1
a348 1
			  PL_parser->copline = (line_t)$2;
d430 1
a430 1
			{ PL_parser->copline = (line_t) $2;
d514 3
a516 1
			{ SvREFCNT_inc_simple_void(PL_compcv);
d526 4
d645 1
a645 1
package :	PACKAGE WORD ';'
d648 1
a648 1
			  $$ = package($2);
d650 3
a652 1
			  token_getmad($3,$$,';');
d654 3
a656 1
			  package($2);
d672 1
a672 1
			      append_madprops(newMADPROP('!', MAD_PV, "", 0), $$, 0);
d1250 7
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d4 1
d13 1
a13 1
 * All that is gold does not glitter, not all those who wander are lost.'
d15 4
d185 1
a185 1
			{ $$ = Nullop; }
d221 1
a221 1
					Nullop);
d248 1
a248 1
			{ $$ = Nullop; }
d269 1
a269 1
					Nullop, $3, $1, Nullop);
d276 1
a276 1
			{ $$ = Nullop; }
d283 1
a283 1
			    $$ = newCONDOP(0, $3, scope($5), $6);
d320 1
a320 1
			{ $$ = Nullop; }
d333 1
a333 1
				     innerop = newWHILEOP(0, 1, (LOOP*)Nullop,
d346 1
a346 1
				     innerop = newWHILEOP(0, 1, (LOOP*)Nullop,
d378 1
a378 1
						    Nullop, $5, $7, $8));
d390 1
a390 1
					    newWHILEOP(0, 1, (LOOP*)Nullop,
d418 2
a419 2
				 newWHILEOP(0, 1, (LOOP*)Nullop,
					    NOLINE, Nullop, $2, $3, 0));
d440 1
a440 1
			{ $$ = Nullop; }
d517 1
a517 1
			  $$ = Nullop;
d523 1
a523 1
	|	/* NULL */	{ $$ = Nullop; }
d534 1
a534 1
			  $$ = Nullop;
d557 1
a557 1
			  $$ = Nullop;
d589 1
a589 1
			{ $$ = Nullop; }
d595 1
a595 1
			{ $$ = Nullop; }
d603 1
a603 1
				    Nullop
d617 1
a617 1
				    Nullop
d627 1
a627 1
				    Nullop
d642 1
a642 1
			  $$ = Nullop;
d660 1
a660 1
			  $$ = Nullop;
d758 1
a758 1
			  $<opval>$ = newANONATTRSUB($2, 0, Nullop, $3); }
d864 1
a864 1
			{ $$ = newSLICEOP(0, $4, Nullop);
d994 1
a994 1
			{ $$ = newANONLIST(Nullop);
d1005 1
a1005 1
			{ $$ = newANONHASH(Nullop);
d1036 1
a1036 1
				)),Nullop)); dep();
d1057 1
a1057 1
				scalar(newCVREF(0,scalar($2))), Nullop)); dep();
d1273 1
a1273 1
			{ $$ = Nullop; }
d1279 1
a1279 1
			{ $$ = Nullop; }
@


1.10
log
@merge in perl 5.8.8
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
d13 2
a14 3
 */

/* This file holds the grammar for the Perl language. If edited, you need
d18 14
d35 4
d41 1
a41 28
%{
#include "EXTERN.h"
#define PERL_IN_PERLY_C
#include "perl.h"
#ifdef EBCDIC
#undef YYDEBUG
#endif
#define dep() deprecate("\"do\" to call subroutines")

/* stuff included here to make perly_c.diff apply better */

#define yydebug	    PL_yydebug
#define yynerrs	    PL_yynerrs
#define yyerrflag   PL_yyerrflag
#define yychar	    PL_yychar
#define yyval	    PL_yyval
#define yylval	    PL_yylval

struct ysv {
    short* yyss;
    YYSTYPE* yyvs;
    int oldyydebug;
    int oldyynerrs;
    int oldyyerrflag;
    int oldyychar;
    YYSTYPE oldyyval;
    YYSTYPE oldyylval;
};
d43 1
a43 1
static void yydestruct(pTHX_ void *ptr);
d45 1
a45 1
%}
a48 4
%{
#if 0 /* get this from perly.h instead */
%}

d50 2
a51 1
    I32	ival;
d55 10
d67 1
a67 11
%{
#endif /* 0 */

#ifdef USE_PURE_BISON
#define YYLEX_PARAM (&yychar)
#define yylex yylex_r
#endif

%}

%token <ival> '{'
d71 17
a87 9
%token <pval> LABEL
%token <ival> FORMAT SUB ANONSUB PACKAGE USE
%token <ival> WHILE UNTIL IF UNLESS ELSE ELSIF CONTINUE FOR
%token <ival> LOOPEX DOTDOT
%token <ival> FUNC0 FUNC1 FUNC UNIOP LSTOP
%token <ival> RELOP EQOP MULOP ADDOP
%token <ival> DOLSHARP DO HASHBRACK NOAMP
%token <ival> LOCAL MY MYSUB
%token COLONATTR
a88 2
%type <ival> prog decl format startsub startanonsub startformsub
%type <ival> progstart remember mremember '&'
d91 1
a91 1
%type <opval> argexpr nexpr texpr iexpr mexpr mnexpr mtexpr miexpr
d94 1
a94 1
%type <opval> subattrlist myattrlist mysubrout myattrterm myterm
d96 2
a97 1
%type <pval> label
d99 1
a99 1
%nonassoc PREC_LOW
d102 3
a104 3
%left <ival> OROP
%left ANDOP
%right NOTOP
d106 3
a108 3
%left ','
%right <ival> ASSIGNOP
%right '?' ':'
d110 4
a113 4
%left OROR
%left ANDAND
%left <ival> BITOROP
%left <ival> BITANDOP
d117 2
a118 1
%left <ival> SHIFTOP
d121 7
a127 7
%left <ival> MATCHOP
%right '!' '~' UMINUS REFGEN
%right <ival> POWOP
%nonassoc PREINC PREDEC POSTINC POSTDEC
%left ARROW
%nonassoc <ival> ')'
%left '('
d130 2
d142 6
a147 3
			{ if (PL_copline > (line_t)$1)
			      PL_copline = (line_t)$1;
			  $$ = block_end($2, $3); }
d154 4
d160 1
a160 4
#if defined(YYDEBUG) && defined(DEBUGGING)
		    yydebug = (DEBUG_p_TEST);
#endif
		    PL_expect = XSTATE; $$ = block_start(TRUE);
d166 6
a171 3
			{ if (PL_copline > (line_t)$1)
			      PL_copline = (line_t)$1;
			  $$ = block_end($2, $3); }
d182 6
a187 1
			{ $$ = $1; }
d192 3
a194 1
			    if ($1 && $2) PL_hints |= HINT_BLOCK_SCOPE; }
d199 2
a200 1
			{ $$ = newSTATEOP(0, $1, $2); }
d202 4
d207 16
a222 8
			{ if ($1 != Nullch) {
			      $$ = newSTATEOP(0, $1, newOP(OP_NULL, 0));
			    }
			    else {
			      $$ = Nullop;
			      PL_copline = NOLINE;
			    }
			    PL_expect = XSTATE; }
d224 15
a238 2
			{ $$ = newSTATEOP(0, $1, $2);
			  PL_expect = XSTATE; }
d247 3
a249 1
			{ $$ = newLOGOP(OP_AND, 0, $3, $1); }
d251 3
a253 1
			{ $$ = newLOGOP(OP_OR, 0, $3, $1); }
d255 3
a257 1
			{ $$ = newLOOPOP(OPf_PARENS, 1, scalar($3), $1); }
d259 3
a261 1
			{ $$ = newLOOPOP(OPf_PARENS, 1, $3, $1);}
d263 4
a266 2
			{ $$ = newFOROP(0, Nullch, (line_t)$2,
					Nullop, $3, $1, Nullop); }
d273 3
a275 1
			{ ($2)->op_flags |= OPf_PARENS; $$ = scope($2); }
d277 1
a277 1
			{ PL_copline = (line_t)$1;
d279 5
a283 1
			    PL_hints |= HINT_BLOCK_SCOPE; }
d288 1
a288 1
			{ PL_copline = (line_t)$1;
d290 5
a294 1
				   newCONDOP(0, $4, scope($6), $7)); }
d296 1
a296 1
			{ PL_copline = (line_t)$1;
d298 13
a310 1
				   newCONDOP(0, $4, scope($6), $7)); }
d317 3
a319 1
			{ $$ = scope($2); }
d323 3
a325 2
loop	:	label WHILE '(' remember mtexpr ')' mblock cont
			{ PL_copline = (line_t)$2;
d327 12
a338 5
				   newSTATEOP(0, $1,
				     newWHILEOP(0, 1, (LOOP*)Nullop,
						$2, $5, $7, $8))); }
	|	label UNTIL '(' remember miexpr ')' mblock cont
			{ PL_copline = (line_t)$2;
d340 8
a347 3
				   newSTATEOP(0, $1,
				     newWHILEOP(0, 1, (LOOP*)Nullop,
						$2, $5, $7, $8))); }
d349 10
a358 2
			{ $$ = block_end($4,
				 newFOROP(0, $1, (line_t)$2, $5, $7, $9, $10)); }
d360 9
a368 3
			{ $$ = block_end($5,
				 newFOROP(0, $1, (line_t)$2, mod($3, OP_ENTERLOOP),
					  $6, $8, $9)); }
d370 11
a380 3
			{ $$ = block_end($4,
				 newFOROP(0, $1, (line_t)$2, Nullop, $5, $7, $8)); }
	|	label FOR '(' remember mnexpr ';' mtexpr ';' mnexpr ')' mblock
d383 2
a384 2
			  PL_copline = (line_t)$2;
			  forop = newSTATEOP(0, $1,
d386 16
a401 2
						$2, scalar($7),
						$11, $9));
d404 1
a404 2
                                        newSTATEOP(0, ($1?savepv($1):Nullch),
						   $5),
d408 2
d412 1
a412 1
			{ $$ = newSTATEOP(0, $1,
d414 2
a415 1
					    NOLINE, Nullop, $2, $3)); }
d418 15
d441 3
a443 1
			{ (void)scan_num("1", &yylval); $$ = yylval.opval; }
a460 4
mtexpr	:	texpr
			{ $$ = $1; intro_my(); }
	;

d467 9
a475 1
			{ $$ = Nullch; }
d479 1
a479 1
/* Some kind of declaration - does not take part in the parse tree */
d481 1
a481 1
			{ $$ = 0; }
d483 1
a483 1
			{ $$ = 0; }
d485 1
a485 1
			{ $$ = 0; }
d487 1
a487 1
			{ $$ = 0; }
d489 12
a500 1
			{ $$ = 0; }
d504 11
a514 1
			{ newFORM($2, $3, $4); }
d523 9
a531 1
			{ newMYSUB($2, $3, $4, $5, $6); }
d536 19
a554 1
			{ newATTRSUB($2, $3, $4, $5, $6); }
d558 3
a560 1
			{ $$ = start_subparse(FALSE, 0); }
d564 2
a565 1
			{ $$ = start_subparse(FALSE, CVf_ANON); }
d569 2
a570 1
			{ $$ = start_subparse(TRUE, 0); }
d574 1
a574 1
subname	:	WORD	{ STRLEN n_a; char *name = SvPV(((SVOP*)$1)->op_sv,n_a);
d576 2
a577 1
			      || strEQ(name, "INIT") || strEQ(name, "CHECK"))
d592 3
a594 1
			{ $$ = $2; }
d596 6
a601 1
			{ $$ = Nullop; }
d606 3
a608 1
			{ $$ = $2; }
d610 6
a615 1
			{ $$ = Nullop; }
d620 7
a626 1
	|	';'	{ $$ = Nullop; PL_expect = XSTATE; }
d630 10
a639 3
			{ package($2); }
	|	PACKAGE ';'
			{ package(Nullop); }
d645 13
a657 1
			{ utilize($1, $2, $4, $5, $6); }
d662 3
a664 1
			{ $$ = newLOGOP(OP_AND, 0, $1, $3); }
d666 7
a672 1
			{ $$ = newLOGOP($2, 0, $1, $3); }
d678 9
a686 1
			{ $$ = $1; }
d688 8
a695 1
			{ $$ = append_elem(OP_LIST, $1, $3); }
d701 4
a704 2
			{ $$ = convert($1, OPf_STACKED,
				prepend_elem(OP_LIST, newGVREF($1,$2), $3) ); }
d706 6
a711 2
			{ $$ = convert($1, OPf_STACKED,
				prepend_elem(OP_LIST, newGVREF($1,$3), $4) ); }
d716 5
a720 1
				    newUNOP(OP_METHOD, 0, $3))); }
d724 3
a726 1
				    newUNOP(OP_METHOD, 0, $3))); }
d731 2
a732 1
				    newUNOP(OP_METHOD, 0, $1))); }
d737 4
a740 1
				    newUNOP(OP_METHOD, 0, $1))); }
d742 3
a744 1
			{ $$ = convert($1, 0, $2); }
d746 5
a750 1
			{ $$ = convert($1, 0, $3); }
d752 2
a753 1
			{ $3 = newANONATTRSUB($2, 0, Nullop, $3); }
d757 2
a758 1
				   prepend_elem(OP_LIST, $3, $5), $1)); }
d771 5
a775 1
			    PL_expect = XOPERATOR; }
d777 4
a780 1
			{ $$ = newBINOP(OP_AELEM, 0, oopsAV($1), scalar($3)); }
d784 5
a788 1
					scalar($4));}
d792 4
a795 1
					scalar($3));}
d798 5
a802 1
			    PL_expect = XOPERATOR; }
d807 6
a812 1
			    PL_expect = XOPERATOR; }
d817 5
a821 1
			    PL_expect = XOPERATOR; }
d824 5
a828 1
				   newCVREF(0, scalar($1))); }
d832 5
a836 1
				       newCVREF(0, scalar($1)))); }
d841 4
a844 1
					       newCVREF(0, scalar($1)))); }
d847 18
a864 1
				   newCVREF(0, scalar($1))); }
d868 4
a871 2
termbinop	:	term ASSIGNOP term             /* $x = $y */
			{ $$ = newASSIGNOP(OPf_STACKED, $1, $2, $3); }
d873 3
a875 1
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
d877 1
a877 1
			{   if ($2 != OP_REPEAT)
d879 3
a881 1
			    $$ = newBINOP($2, 0, $1, scalar($3)); }
d883 3
a885 1
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
d887 3
a889 1
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
d891 3
a893 1
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
d895 3
a897 1
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
d899 3
a901 1
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
d903 3
a905 1
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
d907 11
a917 1
			{ $$ = newRANGE($2, scalar($1), scalar($3));}
d919 3
a921 1
			{ $$ = newLOGOP(OP_AND, 0, $1, $3); }
d923 7
a929 1
			{ $$ = newLOGOP(OP_OR, 0, $1, $3); }
d931 6
a936 1
			{ $$ = bind_match($2, $1, $3); }
d941 3
a943 1
			{ $$ = newUNOP(OP_NEGATE, 0, scalar($2)); }
d945 6
a950 1
			{ $$ = $2; }
d952 3
a954 1
			{ $$ = newUNOP(OP_NOT, 0, scalar($2)); }
d956 3
a958 1
			{ $$ = newUNOP(OP_COMPLEMENT, 0, scalar($2));}
d961 3
a963 1
					mod(scalar($1), OP_POSTINC)); }
d966 3
a968 1
					mod(scalar($1), OP_POSTDEC)); }
d971 3
a973 1
					mod(scalar($2), OP_PREINC)); }
d976 3
a978 1
					mod(scalar($2), OP_PREDEC)); }
d984 4
a987 1
			{ $$ = newANONLIST($2); }
d989 4
a992 1
			{ $$ = newANONLIST(Nullop); }
d994 5
a998 1
			{ $$ = newANONHASH($2); }
d1000 5
a1004 1
			{ $$ = newANONHASH(Nullop); }
d1006 6
a1011 1
			{ $$ = newANONATTRSUB($2, $3, $4, $5); }
d1017 3
a1019 1
			{ $$ = dofile($2); }
d1021 3
a1023 1
			{ $$ = newUNOP(OP_NULL, OPf_SPECIAL, scope($2)); }
d1031 5
a1035 1
				)),Nullop)); dep();}
d1044 5
a1048 1
				)))); dep();}
d1052 5
a1056 1
				scalar(newCVREF(0,scalar($2))), Nullop)); dep();}
d1061 5
a1065 1
				scalar(newCVREF(0,scalar($2))))); dep();}
d1074 4
a1077 1
			{ $$ = newCONDOP(0, $1, $3, $5); }
d1079 3
a1081 1
			{ $$ = newUNOP(OP_REFGEN, 0, mod($2,OP_REFGEN)); }
d1085 3
a1087 1
			{ $$ = localize($2,$1); }
d1089 4
a1092 1
			{ $$ = sawparens($2); }
d1094 4
a1097 1
			{ $$ = sawparens(newNULLLIST()); }
a1109 4
	|	'(' expr ')' '[' expr ']'            /* list slice */
			{ $$ = newSLICEOP(0, $5, $2); }
	|	'(' ')' '[' expr ']'                 /* empty list slice! */
			{ $$ = newSLICEOP(0, $4, Nullop); }
d1115 4
a1118 1
					ref($1, OP_ASLICE))); }
d1125 5
a1129 1
			    PL_expect = XOPERATOR; }
d1135 4
a1138 1
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED, scalar($1)); }
d1140 12
a1151 2
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
			    append_elem(OP_LIST, $3, scalar($1))); }
d1154 3
a1156 1
			    append_elem(OP_LIST, $3, scalar($2))); }
d1158 4
a1161 2
			{ $$ = newOP($1, OPf_SPECIAL);
			    PL_hints |= HINT_BLOCK_SCOPE; }
d1163 3
a1165 1
			{ $$ = newLOOPEX($1,$2); }
d1167 3
a1169 1
			{ $$ = newUNOP(OP_NOT, 0, scalar($2)); }
d1171 7
a1177 3
			{ $$ = newOP($1, 0); }
	|	UNIOP block                          /* eval { foo }, I *think* */
			{ $$ = newUNOP($1, 0, $2); }
d1179 13
a1191 1
			{ $$ = newUNOP($1, 0, $2); }
d1196 3
a1198 1
			{ $$ = newOP($1, 0); }
d1200 5
a1204 1
			{ $$ = newOP($1, 0); }
d1209 8
a1216 2
			{ $$ = $1 == OP_NOT ? newUNOP($1, 0, newSVOP(OP_CONST, 0, newSViv(0)))
					    : newOP($1, OPf_SPECIAL); }
d1218 10
a1227 5
			{ $$ = newUNOP($1, 0, $3); }
	|	PMFUNC '(' term ')'                  /* split (/foo/) */
			{ $$ = pmruntime($1, $3, Nullop); }
	|	PMFUNC '(' term ',' term ')'         /* split (/foo/,$bar) */
			{ $$ = pmruntime($1, $3, $5); }
d1234 7
a1240 1
			{ $$ = my_attrs($2,$3); }
d1242 3
a1244 1
			{ $$ = localize($2,$1); }
d1249 4
a1252 1
			{ $$ = sawparens($2); }
d1254 4
a1257 1
			{ $$ = sawparens(newNULLLIST()); }
d1278 10
a1287 1
			{ $$ = $1; }
d1293 1
a1293 1
			{ PL_in_my = 0; $$ = my($1); }
d1297 3
a1299 1
			{ $$ = newCVREF($1,$2); }
d1303 3
a1305 1
			{ $$ = newSVREF($2); }
d1309 3
a1311 1
			{ $$ = newAVREF($2); }
d1315 3
a1317 1
			{ $$ = newHVREF($2); }
d1321 3
a1323 1
			{ $$ = newAVREF($2); }
d1327 3
a1329 1
			{ $$ = newGVREF(0,$2); }
d1336 1
a1336 1
			{ $$ = scalar($1);  }
a1342 10

%% /* PROGRAM */

/* more stuff added to make perly_c.diff easier to apply */

#ifdef yyparse
#undef yyparse
#endif
#define yyparse() Perl_yyparse(pTHX)

@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d443 1
a443 1
listop	:	LSTOP indirob argexpr          /* print $fh @@args */
d472 1
a472 1
	|	LSTOPSUB startanonsub block          /* map { foo } ... */
d715 2
a716 1
			{ $$ = newOP($1, OPf_SPECIAL); }
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d15 9
@


1.7
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d480 2
a481 1
			{ $$ = newBINOP(OP_GELEM, 0, $1, scalar($3)); }
@


1.6
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d19 3
a21 1

d44 1
a44 1
static void yydestruct(pTHXo_ void *ptr);
d86 1
a86 1
%type <ival> remember mremember '&'
d93 1
d128 2
a129 7
prog	:	/* NULL */
		{
#if defined(YYDEBUG) && defined(DEBUGGING)
		    yydebug = (PL_debug & 1);
#endif
		    PL_expect = XSTATE;
		}
d131 1
a131 1
			{ newPROG($2); }
d134 1
d137 1
a137 1
			      PL_copline = $1;
d145 10
d157 1
a157 1
			      PL_copline = $1;
d165 1
d177 1
d195 1
d209 1
a209 1
			{ $$ = newFOROP(0, Nullch, $2,
d213 1
d219 1
a219 1
			{ PL_copline = $1;
d224 1
d226 1
a226 1
			{ PL_copline = $1;
d230 1
a230 1
			{ PL_copline = $1;
d235 1
d242 1
d244 1
a244 1
			{ PL_copline = $2;
d250 1
a250 1
			{ PL_copline = $2;
d257 1
a257 1
				 newFOROP(0, $1, $2, $5, $7, $9, $10)); }
d260 1
a260 1
				 newFOROP(0, $1, $2, mod($3, OP_ENTERLOOP),
d264 1
a264 1
				 newFOROP(0, $1, $2, Nullop, $5, $7, $8)); }
d267 14
a280 7
			{ OP *forop = append_elem(OP_LINESEQ,
					scalar($5),
					newWHILEOP(0, 1, (LOOP*)Nullop,
						   $2, scalar($7),
						   $11, scalar($9)));
			  PL_copline = $2;
			  $$ = block_end($4, newSTATEOP(0, $1, forop)); }
d287 1
d293 1
d299 1
d304 1
d321 1
d327 1
d348 1
d353 1
d370 1
d378 1
d384 1
d393 1
d400 1
d417 1
d425 1
d433 2
a434 1
listop	:	LSTOP indirob argexpr
d437 1
a437 1
	|	FUNC '(' indirob expr ')'
d440 1
a440 1
	|	term ARROW method '(' listexprcom ')'
d445 1
a445 1
	|	term ARROW method
d449 1
a449 1
	|	METHOD indirob listexpr
d454 1
a454 1
	|	FUNCMETH indirob '(' listexprcom ')'
d459 1
a459 1
	|	LSTOP listexpr
d461 1
a461 1
	|	FUNC '(' listexprcom ')'
d463 1
a463 1
	|	LSTOPSUB startanonsub block
d465 1
a465 1
		    listexpr		%prec LSTOP
d471 1
d476 4
a479 1
subscripted:    star '{' expr ';' '}'
d481 1
a481 1
	|	scalar '[' expr ']'
d483 1
a483 1
	|	term ARROW '[' expr ']'
d487 1
a487 1
	|	subscripted '[' expr ']'
d491 1
a491 1
	|	scalar '{' expr ';' '}'
d494 1
a494 1
	|	term ARROW '{' expr ';' '}'
d499 1
a499 1
	|	subscripted '{' expr ';' '}'
d504 1
a504 1
	|	term ARROW '(' ')'
d507 1
a507 1
	|	term ARROW '(' expr ')'
d512 1
a512 1
	|	subscripted '(' expr ')'
d516 1
a516 1
	|	subscripted '(' ')'
d519 1
d521 2
a522 3


term	:	term ASSIGNOP term
d524 1
a524 1
	|	term POWOP term
d526 1
a526 1
	|	term MULOP term
d530 1
a530 1
	|	term ADDOP term
d532 1
a532 1
	|	term SHIFTOP term
d534 1
a534 1
	|	term RELOP term
d536 1
a536 1
	|	term EQOP term
d538 1
a538 1
	|	term BITANDOP term
d540 1
a540 1
	|	term BITOROP term
d542 1
a542 1
	|	term DOTDOT term
d544 1
a544 1
	|	term ANDAND term
d546 1
a546 1
	|	term OROR term
d548 1
a548 3
	|	term '?' term ':' term
			{ $$ = newCONDOP(0, $1, $3, $5); }
	|	term MATCHOP term
d550 1
d552 2
a553 1
	|	'-' term %prec UMINUS
d555 1
a555 1
	|	'+' term %prec UMINUS
d557 1
a557 1
	|	'!' term
d559 1
a559 1
	|	'~' term
d561 1
a561 3
	|	REFGEN term
			{ $$ = newUNOP(OP_REFGEN, 0, mod($2,OP_REFGEN)); }
	|	term POSTINC
d564 1
a564 1
	|	term POSTDEC
d567 1
a567 1
	|	PREINC term
d570 1
a570 1
	|	PREDEC term
d573 59
a639 10
	|	'[' expr ']'
			{ $$ = newANONLIST($2); }
	|	'[' ']'
			{ $$ = newANONLIST(Nullop); }
	|	HASHBRACK expr ';' '}'			%prec '('
			{ $$ = newANONHASH($2); }
	|	HASHBRACK ';' '}'				%prec '('
			{ $$ = newANONHASH(Nullop); }
	|	ANONSUB startanonsub proto subattrlist block	%prec '('
			{ $$ = newANONATTRSUB($2, $3, $4, $5); }
d648 1
a648 1
	|	arylen 	%prec '('
d652 1
a652 1
	|	'(' expr ')' '[' expr ']'
d654 1
a654 1
	|	'(' ')' '[' expr ']'
d656 1
a656 1
	|	ary '[' expr ']'
d662 1
a662 1
	|	ary '{' expr ';' '}'
d671 1
a671 1
	|	amper
d673 1
a673 1
	|	amper '(' ')'
d675 1
a675 1
	|	amper '(' expr ')'
d678 1
a678 1
	|	NOAMP WORD listexpr
d681 1
a681 31
	|	DO term	%prec UNIOP
			{ $$ = dofile($2); }
	|	DO block	%prec '('
			{ $$ = newUNOP(OP_NULL, OPf_SPECIAL, scope($2)); }
	|	DO WORD '(' ')'
			{ $$ = newUNOP(OP_ENTERSUB,
			    OPf_SPECIAL|OPf_STACKED,
			    prepend_elem(OP_LIST,
				scalar(newCVREF(
				    (OPpENTERSUB_AMPER<<8),
				    scalar($2)
				)),Nullop)); dep();}
	|	DO WORD '(' expr ')'
			{ $$ = newUNOP(OP_ENTERSUB,
			    OPf_SPECIAL|OPf_STACKED,
			    append_elem(OP_LIST,
				$4,
				scalar(newCVREF(
				    (OPpENTERSUB_AMPER<<8),
				    scalar($2)
				)))); dep();}
	|	DO scalar '(' ')'
			{ $$ = newUNOP(OP_ENTERSUB, OPf_SPECIAL|OPf_STACKED,
			    prepend_elem(OP_LIST,
				scalar(newCVREF(0,scalar($2))), Nullop)); dep();}
	|	DO scalar '(' expr ')'
			{ $$ = newUNOP(OP_ENTERSUB, OPf_SPECIAL|OPf_STACKED,
			    prepend_elem(OP_LIST,
				$4,
				scalar(newCVREF(0,scalar($2))))); dep();}
	|	LOOPEX
d686 1
a686 1
	|	NOTOP argexpr
d688 1
a688 1
	|	UNIOP
d690 1
a690 1
	|	UNIOP block
d692 1
a692 1
	|	UNIOP term
d694 1
a694 1
	|	UNIOPSUB term
d697 1
a697 1
	|	FUNC0
d701 1
a701 1
	|	FUNC0SUB
d704 1
a704 1
	|	FUNC1 '(' ')'
d706 1
a706 1
	|	FUNC1 '(' expr ')'
d708 1
a708 1
	|	PMFUNC '(' term ')'
d710 1
a710 1
	|	PMFUNC '(' term ',' term ')'
d716 1
d723 1
d736 1
d751 2
d781 1
@


1.5
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d64 1
d270 1
a270 1
			{ (void)scan_num("1"); $$ = yylval.opval; }
@


1.4
log
@Prevent make from trying to build perly.y for good.
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d17 1
d20 23
a42 5
static void
dep(void)
{
    deprecate("\"do\" to call subroutines");
}
d49 1
a49 1
#ifndef OEMVS
d60 6
a65 1
#endif /* OEMVS */
d68 1
a68 1
%token <ival> '{' ')'
d79 2
a80 1
%token LOCAL MY
d82 1
a82 1
%type <ival> prog decl local format startsub startanonsub startformsub
d85 1
a85 1
%type <opval> expr term scalar ary hsh arylen star amper sideff
d89 1
d92 3
d118 1
d120 1
d203 1
a203 1
			{ $$ = scope($2); }
d206 1
a206 2
			    $$ = newSTATEOP(0, Nullch,
				   newCONDOP(0, $3, scope($5), $6));
d302 2
d318 6
a323 2
subrout	:	SUB startsub subname proto subbody
			{ newSUB($2, $3, $4, $5); }
d338 1
a338 1
subname	:	WORD	{ STRLEN n_a; char *name = SvPV(((SVOP*)$1)->op_sv, n_a);
d340 1
a340 1
			      || strEQ(name, "INIT"))
d350 14
d384 1
a384 1
	|	argexpr
d391 1
a391 1
	|	term
d405 4
d424 1
a424 1
			{ $3 = newANONSUB($2, 0, $3); }
d435 43
d531 3
a533 1
	|	local term	%prec UNIOP
d539 1
a539 1
	|	'[' expr ']'				%prec '('
d541 1
a541 1
	|	'[' ']'					%prec '('
d547 2
a548 2
	|	ANONSUB startanonsub proto block		%prec '('
			{ $$ = newANONSUB($2, $3, $4); }
a550 2
	|	star '{' expr ';' '}'
			{ $$ = newBINOP(OP_GELEM, 0, $1, scalar($3)); }
a552 10
	|	scalar '[' expr ']'	%prec '('
			{ $$ = newBINOP(OP_AELEM, 0, oopsAV($1), scalar($3)); }
	|	term ARROW '[' expr ']'	%prec '('
			{ $$ = newBINOP(OP_AELEM, 0,
					ref(newAVREF($1),OP_RV2AV),
					scalar($4));}
	|	term '[' expr ']'	%prec '('
			{ assertref($1); $$ = newBINOP(OP_AELEM, 0,
					ref(newAVREF($1),OP_RV2AV),
					scalar($3));}
d559 3
a561 14
	|	scalar '{' expr ';' '}'	%prec '('
			{ $$ = newBINOP(OP_HELEM, 0, oopsHV($1), jmaybe($3));
			    PL_expect = XOPERATOR; }
	|	term ARROW '{' expr ';' '}'	%prec '('
			{ $$ = newBINOP(OP_HELEM, 0,
					ref(newHVREF($1),OP_RV2HV),
					jmaybe($4));
			    PL_expect = XOPERATOR; }
	|	term '{' expr ';' '}'	%prec '('
			{ assertref($1); $$ = newBINOP(OP_HELEM, 0,
					ref(newHVREF($1),OP_RV2HV),
					jmaybe($3));
			    PL_expect = XOPERATOR; }
	|	'(' expr ')' '[' expr ']'	%prec '('
d563 1
a563 1
	|	'(' ')' '[' expr ']'	%prec '('
d565 1
a565 1
	|	ary '[' expr ']'	%prec '('
d571 1
a571 1
	|	ary '{' expr ';' '}'	%prec '('
a619 7
	|	term ARROW '(' ')'	%prec '('
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
				   newCVREF(0, scalar($1))); }
	|	term ARROW '(' expr ')'	%prec '('
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
				   append_elem(OP_LIST, $4,
				       newCVREF(0, scalar($1)))); }
d655 19
a673 1
listexpr:	/* NULL */
d675 1
a675 1
	|	argexpr
a686 4
local	:	LOCAL	{ $$ = 0; }
	|	MY	{ $$ = 1; }
	;

d717 1
a717 1
	|	scalar
d727 8
@


1.3
log
@perl5.005_03 (stock)
@
text
@@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d20 1
a20 1
dep()
d29 4
d40 4
d96 1
a96 1
		    yydebug = (debug & 1);
d98 1
a98 1
		    expect = XSTATE;
d105 2
a106 2
			{ if (copline > (line_t)$1)
			      copline = $1;
d115 2
a116 2
			{ if (copline > (line_t)$1)
			      copline = $1;
d131 2
a132 2
			    pad_reset_pending = TRUE;
			    if ($1 && $2) hints |= HINT_BLOCK_SCOPE; }
d144 1
a144 1
			      copline = NOLINE;
d146 1
a146 1
			    expect = XSTATE; }
d149 1
a149 1
			  expect = XSTATE; }
d164 3
d174 1
a174 1
			{ copline = $1;
d177 1
a177 1
			    hints |= HINT_BLOCK_SCOPE; }
d181 1
a181 1
			{ copline = $1;
d185 1
a185 1
			{ copline = $1;
d197 1
a197 1
			{ copline = $2;
d203 1
a203 1
			{ copline = $2;
d225 1
a225 1
			  copline = $2;
d302 4
a305 3
subname	:	WORD	{ char *name = SvPVx(((SVOP*)$1)->op_sv, na);
			  if (strEQ(name, "BEGIN") || strEQ(name, "END"))
			      CvUNIQUE_on(compcv);
d315 1
a315 1
	|	';'	{ $$ = Nullop; expect = XSTATE; }
d325 1
a325 1
			{ CvUNIQUE_on(compcv); /* It's a BEGIN {} */ }
d453 1
a453 1
			{ $$ = newBINOP(OP_GELEM, 0, newGVREF(0,$1), $3); }
d474 1
a474 1
			    expect = XOPERATOR; }
d479 1
a479 1
			    expect = XOPERATOR; }
d484 1
a484 1
			    expect = XOPERATOR; }
d501 1
a501 1
			    expect = XOPERATOR; }
d515 1
a515 1
			{ $$ = newUNOP(OP_DOFILE, 0, scalar($2)); }
d553 1
a553 1
			    hints |= HINT_BLOCK_SCOPE; }
d605 1
a605 1
			{ in_my = 0; $$ = my($1); }
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d12 1
a12 1
 * All that is gold does not glitter, not all those that wander are lost.'
d44 1
a44 1
%token <ival> FUNC0 FUNC1 FUNC
d46 2
a47 1
%token <ival> DOLSHARP DO LOCAL HASHBRACK NOAMP
d49 3
a51 2
%type <ival> prog decl format remember startsub '&'
%type <opval> block lineseq line loop cond nexpr else argexpr
d53 3
a55 2
%type <opval> listexpr listexprcom indirob
%type <opval> texpr listop method proto
a56 1
%type <opval> cont
d61 1
a61 1
%nonassoc <ival> LSTOP
d72 1
a72 1
%nonassoc <ival> UNIOP
d97 3
a99 1
			{ $$ = block_end($1,$2,$3); }
d102 12
a113 2
remember:	/* NULL */	/* start a lexical scope */
			{ $$ = block_start(); }
d154 2
a155 2
	|	expr UNTIL expr
			{ $$ = newLOOPOP(OPf_PARENS, 1, invert(scalar($3)), $1);}
d160 1
a160 1
	|	ELSE block
d162 1
a162 1
	|	ELSIF '(' expr ')' block else
d164 2
a165 2
			    $$ = newSTATEOP(0, 0,
				newCONDOP(0, $3, scope($5), $6));
d169 1
a169 4
cond	:	IF '(' expr ')' block else
			{ copline = $1;
			    $$ = newCONDOP(0, $3, scope($5), $6); }
	|	UNLESS '(' expr ')' block else
d171 3
a173 3
			    $$ = newCONDOP(0,
				invert(scalar($3)), scope($5), $6); }
	|	IF block block else
d175 2
a176 7
			    deprecate("if BLOCK BLOCK");
			    $$ = newCONDOP(0, scope($2), scope($3), $4); }
	|	UNLESS block block else
			{ copline = $1;
			    deprecate("unless BLOCK BLOCK");
			    $$ = newCONDOP(0, invert(scalar(scope($2))),
						scope($3), $4); }
d185 1
a185 11
loop	:	label WHILE '(' texpr ')' block cont
			{ copline = $2;
			    $$ = newSTATEOP(0, $1,
				    newWHILEOP(0, 1, (LOOP*)Nullop,
					$4, $6, $7) ); }
	|	label UNTIL '(' expr ')' block cont
			{ copline = $2;
			    $$ = newSTATEOP(0, $1,
				    newWHILEOP(0, 1, (LOOP*)Nullop,
					invert(scalar($4)), $6, $7) ); }
	|	label WHILE block block cont
d187 5
a191 4
			    $$ = newSTATEOP(0, $1,
				    newWHILEOP(0, 1, (LOOP*)Nullop,
					scope($3), $4, $5) ); }
	|	label UNTIL block block cont
d193 15
a207 9
			    $$ = newSTATEOP(0, $1,
				    newWHILEOP(0, 1, (LOOP*)Nullop,
					invert(scalar(scope($3))), $4, $5)); }
	|	label FOR scalar '(' expr ')' block cont
			{ $$ = newFOROP(0, $1, $2, mod($3, OP_ENTERLOOP),
				$5, $7, $8); }
	|	label FOR '(' expr ')' block cont
			{ $$ = newFOROP(0, $1, $2, Nullop, $4, $6, $7); }
	|	label FOR '(' nexpr ';' texpr ';' nexpr ')' block
d209 2
a210 4
			{  copline = $2;
			    $$ = append_elem(OP_LINESEQ,
				    newSTATEOP(0, $1, scalar($4)),
				    newSTATEOP(0, $1,
d212 4
a215 1
					    scalar($6), $10, scalar($8)) )); }
d217 3
a219 3
			{ $$ = newSTATEOP(0,
				$1, newWHILEOP(0, 1, (LOOP*)Nullop,
					Nullop, $2, $3)); }
d232 20
d267 1
a267 1
format	:	FORMAT startsub WORD block
a268 2
	|	FORMAT startsub block
			{ newFORM($2, Nullop, $3); }
d271 5
a275 1
subrout	:	SUB startsub WORD proto block
d277 18
a294 2
	|	SUB startsub WORD proto ';'
			{ newSUB($2, $3, $4, Nullop); expect = XSTATE; }
d301 3
a303 3
		
startsub:	/* NULL */	/* start a subroutine scope */
			{ $$ = start_subparse(); }
d312 4
a315 2
use	:	USE startsub WORD listexpr ';'
			{ utilize($1, $2, $3, $4); }
d341 1
a341 1
				    prepend_elem(OP_LIST, $1, $5),
d357 3
a359 1
	|	LSTOPSUB startsub block listexpr	%prec LSTOP
d361 2
a362 3
			    append_elem(OP_LIST,
			      prepend_elem(OP_LIST, newANONSUB($2, 0, $3), $4),
			      $1)); }
d422 1
a422 1
	|	LOCAL term	%prec UNIOP
d436 1
a436 1
	|	ANONSUB startsub proto block			%prec '('
d532 7
d560 1
a560 1
			{ $$ = newUNOP(OP_ENTERSUB, 0,
d586 8
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d12 1
a12 1
 * All that is gold does not glitter, not all those who wander are lost.'
d20 1
a20 1
dep(void)
a28 4
%{
#ifndef OEMVS
%}

a35 4
%{
#endif /* OEMVS */
%}

d44 1
a44 1
%token <ival> FUNC0 FUNC1 FUNC UNIOP LSTOP
d46 1
a46 2
%token <ival> DOLSHARP DO HASHBRACK NOAMP
%token LOCAL MY
d48 2
a49 3
%type <ival> prog decl local format startsub startanonsub startformsub
%type <ival> remember mremember '&'
%type <opval> block mblock lineseq line loop cond else
d51 2
a52 3
%type <opval> argexpr nexpr texpr iexpr mexpr mnexpr mtexpr miexpr
%type <opval> listexpr listexprcom indirob listop method
%type <opval> formname subname proto subbody cont my_scalar
d54 1
d59 1
a59 1
%nonassoc LSTOP LSTOPSUB
d70 1
a70 1
%nonassoc UNIOP UNIOPSUB
d86 1
a86 1
		    yydebug = (PL_debug & 1);
d88 1
a88 1
		    PL_expect = XSTATE;
d95 1
a95 3
			{ if (PL_copline > (line_t)$1)
			      PL_copline = $1;
			  $$ = block_end($2, $3); }
d98 2
a99 12
remember:	/* NULL */	/* start a full lexical scope */
			{ $$ = block_start(TRUE); }
	;

mblock	:	'{' mremember lineseq '}'
			{ if (PL_copline > (line_t)$1)
			      PL_copline = $1;
			  $$ = block_end($2, $3); }
	;

mremember:	/* NULL */	/* start a partial lexical scope */
			{ $$ = block_start(FALSE); }
d109 2
a110 2
			    PL_pad_reset_pending = TRUE;
			    if ($1 && $2) PL_hints |= HINT_BLOCK_SCOPE; }
d122 1
a122 1
			      PL_copline = NOLINE;
d124 1
a124 1
			    PL_expect = XSTATE; }
d127 1
a127 1
			  PL_expect = XSTATE; }
d140 2
a141 5
	|	expr UNTIL iexpr
			{ $$ = newLOOPOP(OPf_PARENS, 1, $3, $1);}
	|	expr FOR expr
			{ $$ = newFOROP(0, Nullch, $2,
					Nullop, $3, $1, Nullop); }
d146 1
a146 1
	|	ELSE mblock
d148 23
a170 15
	|	ELSIF '(' mexpr ')' mblock else
			{ PL_copline = $1;
			    $$ = newSTATEOP(0, Nullch,
				   newCONDOP(0, $3, scope($5), $6));
			    PL_hints |= HINT_BLOCK_SCOPE; }
	;

cond	:	IF '(' remember mexpr ')' mblock else
			{ PL_copline = $1;
			    $$ = block_end($3,
				   newCONDOP(0, $4, scope($6), $7)); }
	|	UNLESS '(' remember miexpr ')' mblock else
			{ PL_copline = $1;
			    $$ = block_end($3,
				   newCONDOP(0, $4, scope($6), $7)); }
d179 26
a204 23
loop	:	label WHILE '(' remember mtexpr ')' mblock cont
			{ PL_copline = $2;
			    $$ = block_end($4,
				   newSTATEOP(0, $1,
				     newWHILEOP(0, 1, (LOOP*)Nullop,
						$2, $5, $7, $8))); }
	|	label UNTIL '(' remember miexpr ')' mblock cont
			{ PL_copline = $2;
			    $$ = block_end($4,
				   newSTATEOP(0, $1,
				     newWHILEOP(0, 1, (LOOP*)Nullop,
						$2, $5, $7, $8))); }
	|	label FOR MY remember my_scalar '(' mexpr ')' mblock cont
			{ $$ = block_end($4,
				 newFOROP(0, $1, $2, $5, $7, $9, $10)); }
	|	label FOR scalar '(' remember mexpr ')' mblock cont
			{ $$ = block_end($5,
				 newFOROP(0, $1, $2, mod($3, OP_ENTERLOOP),
					  $6, $8, $9)); }
	|	label FOR '(' remember mexpr ')' mblock cont
			{ $$ = block_end($4,
				 newFOROP(0, $1, $2, Nullop, $5, $7, $8)); }
	|	label FOR '(' remember mnexpr ';' mtexpr ';' mnexpr ')' mblock
d206 4
a209 2
			{ OP *forop = append_elem(OP_LINESEQ,
					scalar($5),
d211 1
a211 4
						   $2, scalar($7),
						   $11, scalar($9)));
			  PL_copline = $2;
			  $$ = block_end($4, newSTATEOP(0, $1, forop)); }
d213 3
a215 3
			{ $$ = newSTATEOP(0, $1,
				 newWHILEOP(0, 1, (LOOP*)Nullop,
					    NOLINE, Nullop, $2, $3)); }
a227 20
iexpr	:	expr
			{ $$ = invert(scalar($1)); }
	;

mexpr	:	expr
			{ $$ = $1; intro_my(); }
	;

mnexpr	:	nexpr
			{ $$ = $1; intro_my(); }
	;

mtexpr	:	texpr
			{ $$ = $1; intro_my(); }
	;

miexpr	:	iexpr
			{ $$ = $1; intro_my(); }
	;

d243 1
a243 1
format	:	FORMAT startformsub formname block
d245 2
d249 1
a249 5
formname:	WORD		{ $$ = $1; }
	|	/* NULL */	{ $$ = Nullop; }
	;

subrout	:	SUB startsub subname proto subbody
d251 2
a252 19
	;

startsub:	/* NULL */	/* start a regular subroutine scope */
			{ $$ = start_subparse(FALSE, 0); }
	;

startanonsub:	/* NULL */	/* start an anonymous subroutine scope */
			{ $$ = start_subparse(FALSE, CVf_ANON); }
	;

startformsub:	/* NULL */	/* start a format subroutine scope */
			{ $$ = start_subparse(TRUE, 0); }
	;

subname	:	WORD	{ STRLEN n_a; char *name = SvPV(((SVOP*)$1)->op_sv, n_a);
			  if (strEQ(name, "BEGIN") || strEQ(name, "END")
			      || strEQ(name, "INIT"))
			      CvSPECIAL_on(PL_compcv);
			  $$ = $1; }
d259 3
a261 3

subbody	:	block	{ $$ = $1; }
	|	';'	{ $$ = Nullop; PL_expect = XSTATE; }
d270 2
a271 4
use	:	USE startsub
			{ CvSPECIAL_on(PL_compcv); /* It's a BEGIN {} */ }
		    WORD WORD listexpr ';'
			{ utilize($1, $2, $4, $5, $6); }
d297 1
a297 1
				    prepend_elem(OP_LIST, scalar($1), $5),
d313 1
a313 3
	|	LSTOPSUB startanonsub block
			{ $3 = newANONSUB($2, 0, $3); }
		    listexpr		%prec LSTOP
d315 3
a317 2
				 append_elem(OP_LIST,
				   prepend_elem(OP_LIST, $3, $5), $1)); }
d377 1
a377 1
	|	local term	%prec UNIOP
d391 1
a391 1
	|	ANONSUB startanonsub proto block		%prec '('
d396 1
a396 1
			{ $$ = newBINOP(OP_GELEM, 0, $1, scalar($3)); }
d417 1
a417 1
			    PL_expect = XOPERATOR; }
d422 1
a422 1
			    PL_expect = XOPERATOR; }
d427 1
a427 1
			    PL_expect = XOPERATOR; }
d444 1
a444 1
			    PL_expect = XOPERATOR; }
d458 1
a458 1
			{ $$ = dofile($2); }
a486 7
	|	term ARROW '(' ')'	%prec '('
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
				   newCVREF(0, scalar($1))); }
	|	term ARROW '(' expr ')'	%prec '('
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
				   append_elem(OP_LIST, $4,
				       newCVREF(0, scalar($1)))); }
d489 1
a489 1
			    PL_hints |= HINT_BLOCK_SCOPE; }
d508 1
a508 1
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
a533 8
	;

local	:	LOCAL	{ $$ = 0; }
	|	MY	{ $$ = 1; }
	;

my_scalar:	scalar
			{ PL_in_my = 0; $$ = my($1); }
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a16 1
#define PERL_IN_PERLY_C
d19 5
a23 23
#define dep() deprecate("\"do\" to call subroutines")

/* stuff included here to make perly_c.diff apply better */

#define yydebug	    PL_yydebug
#define yynerrs	    PL_yynerrs
#define yyerrflag   PL_yyerrflag
#define yychar	    PL_yychar
#define yyval	    PL_yyval
#define yylval	    PL_yylval

struct ysv {
    short* yyss;
    YYSTYPE* yyvs;
    int oldyydebug;
    int oldyynerrs;
    int oldyyerrflag;
    int oldyychar;
    YYSTYPE oldyyval;
    YYSTYPE oldyylval;
};

static void yydestruct(pTHXo_ void *ptr);
d30 1
a30 1
#if 0 /* get this from perly.h instead */
d41 1
a41 6
#endif /* 0 */

#ifdef USE_PURE_BISON
#define YYLEX_PARAM (&yychar)
#endif

d44 1
a44 1
%token <ival> '{'
d55 1
a55 2
%token <ival> LOCAL MY MYSUB
%token COLONATTR
d57 1
a57 1
%type <ival> prog decl format startsub startanonsub startformsub
d60 1
a60 1
%type <opval> expr term subscripted scalar ary hsh arylen star amper sideff
a63 1
%type <opval> subattrlist myattrlist mysubrout myattrterm myterm
a65 3
%nonassoc PREC_LOW
%nonassoc LOOPEX

a88 1
%nonassoc <ival> ')'
a89 1
%left '[' '{'
d172 1
a172 1
			{ ($2)->op_flags |= OPf_PARENS; $$ = scope($2); }
d175 2
a176 1
			    $$ = newCONDOP(0, $3, scope($5), $6);
a271 2
	|	mysubrout
			{ $$ = 0; }
d286 2
a287 6
mysubrout:	MYSUB startsub subname proto subattrlist subbody
			{ newMYSUB($2, $3, $4, $5, $6); }
	;

subrout	:	SUB startsub subname proto subattrlist subbody
			{ newATTRSUB($2, $3, $4, $5, $6); }
d302 1
a302 1
subname	:	WORD	{ STRLEN n_a; char *name = SvPV(((SVOP*)$1)->op_sv,n_a);
d304 1
a304 1
			      || strEQ(name, "INIT") || strEQ(name, "CHECK"))
a313 14
subattrlist:	/* NULL */
			{ $$ = Nullop; }
	|	COLONATTR THING
			{ $$ = $2; }
	|	COLONATTR
			{ $$ = Nullop; }
	;

myattrlist:	COLONATTR THING
			{ $$ = $2; }
	|	COLONATTR
			{ $$ = Nullop; }
	;

d334 1
a334 1
	|	argexpr %prec PREC_LOW
d341 1
a341 1
	|	term %prec PREC_LOW
a354 4
	|	term ARROW method
			{ $$ = convert(OP_ENTERSUB, OPf_STACKED,
				append_elem(OP_LIST, scalar($1),
				    newUNOP(OP_METHOD, 0, $3))); }
d370 1
a370 1
			{ $3 = newANONATTRSUB($2, 0, Nullop, $3); }
a380 43
subscripted:    star '{' expr ';' '}'
			{ $$ = newBINOP(OP_GELEM, 0, $1, scalar($3)); }
	|	scalar '[' expr ']'
			{ $$ = newBINOP(OP_AELEM, 0, oopsAV($1), scalar($3)); }
	|	term ARROW '[' expr ']'
			{ $$ = newBINOP(OP_AELEM, 0,
					ref(newAVREF($1),OP_RV2AV),
					scalar($4));}
	|	subscripted '[' expr ']'
			{ $$ = newBINOP(OP_AELEM, 0,
					ref(newAVREF($1),OP_RV2AV),
					scalar($3));}
	|	scalar '{' expr ';' '}'
			{ $$ = newBINOP(OP_HELEM, 0, oopsHV($1), jmaybe($3));
			    PL_expect = XOPERATOR; }
	|	term ARROW '{' expr ';' '}'
			{ $$ = newBINOP(OP_HELEM, 0,
					ref(newHVREF($1),OP_RV2HV),
					jmaybe($4));
			    PL_expect = XOPERATOR; }
	|	subscripted '{' expr ';' '}'
			{ $$ = newBINOP(OP_HELEM, 0,
					ref(newHVREF($1),OP_RV2HV),
					jmaybe($3));
			    PL_expect = XOPERATOR; }
	|	term ARROW '(' ')'
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
				   newCVREF(0, scalar($1))); }
	|	term ARROW '(' expr ')'
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
				   append_elem(OP_LIST, $4,
				       newCVREF(0, scalar($1)))); }

	|	subscripted '(' expr ')'
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
				   append_elem(OP_LIST, $3,
					       newCVREF(0, scalar($1)))); }
	|	subscripted '(' ')'
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
				   newCVREF(0, scalar($1))); }



d434 1
a434 3
	|	myattrterm	%prec UNIOP
			{ $$ = $1; }
	|	LOCAL term	%prec UNIOP
d440 1
a440 1
	|	'[' expr ']'
d442 1
a442 1
	|	'[' ']'
d448 2
a449 2
	|	ANONSUB startanonsub proto subattrlist block	%prec '('
			{ $$ = newANONATTRSUB($2, $3, $4, $5); }
d452 2
d456 10
d472 14
a485 3
	|       subscripted
			{ $$ = $1; }
	|	'(' expr ')' '[' expr ']'
d487 1
a487 1
	|	'(' ')' '[' expr ']'
d489 1
a489 1
	|	ary '[' expr ']'
d495 1
a495 1
	|	ary '{' expr ';' '}'
d544 7
d586 1
a586 19
myattrterm:	MY myterm myattrlist
			{ $$ = my_attrs($2,$3); }
	|	MY myterm
			{ $$ = localize($2,$1); }
	;

myterm	:	'(' expr ')'
			{ $$ = sawparens($2); }
	|	'(' ')'
			{ $$ = sawparens(newNULLLIST()); }
	|	scalar	%prec '('
			{ $$ = $1; }
	|	hsh 	%prec '('
			{ $$ = $1; }
	|	ary 	%prec '('
			{ $$ = $1; }
	;

listexpr:	/* NULL */ %prec PREC_LOW
d588 1
a588 1
	|	argexpr    %prec PREC_LOW
d600 4
d634 1
a634 1
	|	scalar %prec PREC_LOW
a643 8

/* more stuff added to make perly_c.diff easier to apply */

#ifdef yyparse
#undef yyparse
#endif
#define yyparse() Perl_yyparse(pTHX)

@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
a63 1
#define yylex yylex_r
d269 1
a269 1
			{ (void)scan_num("1", &yylval); $$ = yylval.opval; }
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
d19 1
a19 3
#ifdef EBCDIC
#undef YYDEBUG
#endif
d42 1
a42 1
static void yydestruct(pTHX_ void *ptr);
d84 1
a84 1
%type <ival> progstart remember mremember '&'
a90 1
%type <opval> termbinop termunop anonymous termdo
d125 7
a131 2
/* The whole program */
prog	:	progstart
d133 1
a133 1
			{ $$ = $1; newPROG(block_end($1,$2)); }
a135 1
/* An ordinary block */
d138 1
a138 1
			      PL_copline = (line_t)$1;
a145 10
progstart:
		{
#if defined(YYDEBUG) && defined(DEBUGGING)
		    yydebug = (DEBUG_p_TEST);
#endif
		    PL_expect = XSTATE; $$ = block_start(TRUE);
		}
	;


d148 1
a148 1
			      PL_copline = (line_t)$1;
a155 1
/* A collection of "lines" in the program */
a166 1
/* A "line" in the program */
a183 1
/* An expression which may have a side-effect */
d197 1
a197 1
			{ $$ = newFOROP(0, Nullch, (line_t)$2,
a200 1
/* else and elsif blocks */
d206 1
a206 1
			{ PL_copline = (line_t)$1;
a210 1
/* Real conditional expressions */
d212 1
a212 1
			{ PL_copline = (line_t)$1;
d216 1
a216 1
			{ PL_copline = (line_t)$1;
a220 1
/* Continue blocks */
a226 1
/* Loops: while, until, for, and a bare block */
d228 1
a228 1
			{ PL_copline = (line_t)$2;
d234 1
a234 1
			{ PL_copline = (line_t)$2;
d241 1
a241 1
				 newFOROP(0, $1, (line_t)$2, $5, $7, $9, $10)); }
d244 1
a244 1
				 newFOROP(0, $1, (line_t)$2, mod($3, OP_ENTERLOOP),
d248 1
a248 1
				 newFOROP(0, $1, (line_t)$2, Nullop, $5, $7, $8)); }
d251 7
a257 14
			{ OP *forop;
			  PL_copline = (line_t)$2;
			  forop = newSTATEOP(0, $1,
					    newWHILEOP(0, 1, (LOOP*)Nullop,
						$2, scalar($7),
						$11, $9));
			  if ($5) {
				forop = append_elem(OP_LINESEQ,
                                        newSTATEOP(0, ($1?savepv($1):Nullch),
						   $5),
					forop);
			  }

			  $$ = block_end($4, forop); }
a263 1
/* Normal expression */
a268 1
/* Boolean expression */
a273 1
/* Inverted boolean expression */
a277 1
/* Expression with its own lexical scope */
a293 1
/* Optional "MAIN:"-style loop labels */
a298 1
/* Some kind of declaration - does not take part in the parse tree */
a318 1
/* Unimplemented "my sub foo { }" */
a322 1
/* Subroutine definition */
a338 1
/* Name of a subroutine - must be a bareword, could be special */
a345 1
/* Subroutine prototype */
a350 1
/* Optional list of subroutine attributes */
a358 1
/* List of attributes for a "my" variable declaration */
a364 1
/* Subroutine body - either null or a block */
a380 1
/* Ordinary expressions; logical combinations */
a387 1
/* Expressions are a list of terms joined by commas */
d395 1
a395 2
/* List operators */
listop	:	LSTOP indirob argexpr          /* print $fh @@args */
d398 1
a398 1
	|	FUNC '(' indirob expr ')'      /* print ($fh @@args */
d401 1
a401 1
	|	term ARROW method '(' listexprcom ')' /* $foo->bar(list) */
d406 1
a406 1
	|	term ARROW method                     /* $foo->bar */
d410 1
a410 1
	|	METHOD indirob listexpr              /* new Class @@args */
d415 1
a415 1
	|	FUNCMETH indirob '(' listexprcom ')' /* method $object (@@args) */
d420 1
a420 1
	|	LSTOP listexpr                       /* print @@args */
d422 1
a422 1
	|	FUNC '(' listexprcom ')'             /* print (@@args) */
d424 1
a424 1
	|	LSTOPSUB startanonsub block          /* map { foo } ... */
d426 1
a426 1
		    listexpr		%prec LSTOP  /* ... @@bar */
a431 1
/* Names of methods. May use $object->$methodname */
d436 1
a436 4
/* Some kind of subscripted expression */
subscripted:    star '{' expr ';' '}'        /* *main::{something} */
                        /* In this and all the hash accessors, ';' is
                         * provided by the tokeniser */
d438 1
a438 1
	|	scalar '[' expr ']'          /* $array[$element] */
d440 1
a440 1
	|	term ARROW '[' expr ']'      /* somearef->[$element] */
d444 1
a444 1
	|	subscripted '[' expr ']'    /* $foo->[$bar]->[$baz] */
d448 1
a448 1
	|	scalar '{' expr ';' '}'    /* $foo->{bar();} */
d451 1
a451 1
	|	term ARROW '{' expr ';' '}' /* somehref->{bar();} */
d456 1
a456 1
	|	subscripted '{' expr ';' '}' /* $foo->[bar]->{baz;} */
d461 1
a461 1
	|	term ARROW '(' ')'          /* $subref->() */
d464 1
a464 1
	|	term ARROW '(' expr ')'     /* $subref->(@@args) */
d469 1
a469 1
	|	subscripted '(' expr ')'   /* $foo->{bar}->(@@args) */
d473 1
a473 1
	|	subscripted '(' ')'        /* $foo->{bar}->() */
a475 1
    ;
d477 3
a479 2
/* Binary operators between terms */
termbinop	:	term ASSIGNOP term             /* $x = $y */
d481 1
a481 1
	|	term POWOP term                        /* $x ** $y */
d483 1
a483 1
	|	term MULOP term                        /* $x * $y, $x x $y */
d487 1
a487 1
	|	term ADDOP term                        /* $x + $y */
d489 1
a489 1
	|	term SHIFTOP term                      /* $x >> $y, $x << $y */
d491 1
a491 1
	|	term RELOP term                        /* $x > $y, etc. */
d493 1
a493 1
	|	term EQOP term                         /* $x == $y, $x eq $y */
d495 1
a495 1
	|	term BITANDOP term                     /* $x & $y */
d497 1
a497 1
	|	term BITOROP term                      /* $x | $y */
d499 1
a499 1
	|	term DOTDOT term                       /* $x..$y, $x...$y */
d501 1
a501 1
	|	term ANDAND term                       /* $x && $y */
d503 1
a503 1
	|	term OROR term                         /* $x || $y */
d505 3
a507 1
	|	term MATCHOP term                      /* $x =~ /$y/ */
a508 1
    ;
d510 1
a510 2
/* Unary operators and terms */
termunop : '-' term %prec UMINUS                       /* -$x */
d512 1
a512 1
	|	'+' term %prec UMINUS                  /* +$x */
d514 1
a514 1
	|	'!' term                               /* !$x */
d516 1
a516 1
	|	'~' term                               /* ~$x */
d518 3
a520 1
	|	term POSTINC                           /* $x++ */
d523 1
a523 1
	|	term POSTDEC                           /* $x-- */
d526 1
a526 1
	|	PREINC term                            /* ++$x */
d529 1
a529 1
	|	PREDEC term                            /* --$x */
a531 59

    ;

/* Constructors for anonymous data */
anonymous:	'[' expr ']'
			{ $$ = newANONLIST($2); }
	|	'[' ']'
			{ $$ = newANONLIST(Nullop); }
	|	HASHBRACK expr ';' '}'	%prec '(' /* { foo => "Bar" } */
			{ $$ = newANONHASH($2); }
	|	HASHBRACK ';' '}'	%prec '(' /* { } (';' by tokener) */
			{ $$ = newANONHASH(Nullop); }
	|	ANONSUB startanonsub proto subattrlist block	%prec '('
			{ $$ = newANONATTRSUB($2, $3, $4, $5); }

    ;

/* Things called with "do" */
termdo	:       DO term	%prec UNIOP                     /* do $filename */
			{ $$ = dofile($2); }
	|	DO block	%prec '('               /* do { code */
			{ $$ = newUNOP(OP_NULL, OPf_SPECIAL, scope($2)); }
	|	DO WORD '(' ')'                         /* do somesub() */
			{ $$ = newUNOP(OP_ENTERSUB,
			    OPf_SPECIAL|OPf_STACKED,
			    prepend_elem(OP_LIST,
				scalar(newCVREF(
				    (OPpENTERSUB_AMPER<<8),
				    scalar($2)
				)),Nullop)); dep();}
	|	DO WORD '(' expr ')'                    /* do somesub(@@args) */
			{ $$ = newUNOP(OP_ENTERSUB,
			    OPf_SPECIAL|OPf_STACKED,
			    append_elem(OP_LIST,
				$4,
				scalar(newCVREF(
				    (OPpENTERSUB_AMPER<<8),
				    scalar($2)
				)))); dep();}
	|	DO scalar '(' ')'                      /* do $subref () */
			{ $$ = newUNOP(OP_ENTERSUB, OPf_SPECIAL|OPf_STACKED,
			    prepend_elem(OP_LIST,
				scalar(newCVREF(0,scalar($2))), Nullop)); dep();}
	|	DO scalar '(' expr ')'                 /* do $subref (@@args) */
			{ $$ = newUNOP(OP_ENTERSUB, OPf_SPECIAL|OPf_STACKED,
			    prepend_elem(OP_LIST,
				$4,
				scalar(newCVREF(0,scalar($2))))); dep();}

        ;

term	:	termbinop
	|	termunop
	|	anonymous
	|	termdo
	|	term '?' term ':' term
			{ $$ = newCONDOP(0, $1, $3, $5); }
	|	REFGEN term                          /* \$x, \@@y, \%z */
			{ $$ = newUNOP(OP_REFGEN, 0, mod($2,OP_REFGEN)); }
d540 10
d558 1
a558 1
	|	arylen 	%prec '('                    /* $#x, $#{ something } */
d562 1
a562 1
	|	'(' expr ')' '[' expr ']'            /* list slice */
d564 1
a564 1
	|	'(' ')' '[' expr ']'                 /* empty list slice! */
d566 1
a566 1
	|	ary '[' expr ']'                     /* array slice */
d572 1
a572 1
	|	ary '{' expr ';' '}'                 /* @@hash{@@keys} */
d581 1
a581 1
	|	amper                                /* &foo; */
d583 1
a583 1
	|	amper '(' ')'                        /* &foo() */
d585 1
a585 1
	|	amper '(' expr ')'                   /* &foo(@@args) */
d588 1
a588 1
	|	NOAMP WORD listexpr                  /* foo(@@args) */
d591 31
a621 1
	|	LOOPEX  /* loop exiting command (goto, last, dump, etc) */
d626 1
a626 1
	|	NOTOP argexpr                        /* not $foo */
d628 1
a628 1
	|	UNIOP                                /* Unary op, $_ implied */
d630 1
a630 1
	|	UNIOP block                          /* eval { foo }, I *think* */
d632 1
a632 1
	|	UNIOP term                           /* Unary op */
d634 1
a634 1
	|	UNIOPSUB term                        /* Sub treated as unop */
d637 1
a637 1
	|	FUNC0                                /* Nullary operator */
d641 1
a641 1
	|	FUNC0SUB                             /* Sub treated as nullop */
d644 1
a644 1
	|	FUNC1 '(' ')'                        /* not () */
d646 1
a646 1
	|	FUNC1 '(' expr ')'                   /* not($foo) */
d648 1
a648 1
	|	PMFUNC '(' term ')'                  /* split (/foo/) */
d650 1
a650 1
	|	PMFUNC '(' term ',' term ')'         /* split (/foo/,$bar) */
a655 1
/* "my" declarations, with optional attributes */
a661 1
/* Things that can be "my"'d */
a673 1
/* Basic list expressions */
a687 2
/* A little bit of trickery to make "for my $foo (@@bar)" actually be
   lexical */
a715 1
/* Indirect objects */
@


1.1.1.6
log
@perl 5.8.3 from CPAN
@
text
@d480 1
a480 2
			{ $$ = newBINOP(OP_GELEM, 0, $1, scalar($3));
			    PL_expect = XOPERATOR; }
@


1.1.1.7
log
@perl 5.8.6 from CPAN
@
text
@a14 9
/* This file holds the grammar for the Perl language. If edited, you need
 * to run regen_perly.pl, which re-creates the files perly.h, perly.tab
 * and perly.act which are derived from this.
 *
 * The main job of of this grammar is to call the various newFOO()
 * functions in op.c to build a syntax tree of OP structs.
 * It relies on the lexer in toke.c to do the tokenizing.
 */

@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d443 1
a443 1
listop	:	LSTOP indirob argexpr /* map {...} @@args or print $fh @@args */
d472 1
a472 1
	|	LSTOPSUB startanonsub block /* sub f(&@@);   f { foo } ... */
d715 1
a715 2
			{ $$ = $1 == OP_NOT ? newUNOP($1, 0, newSVOP(OP_CONST, 0, newSViv(0)))
					    : newOP($1, OPf_SPECIAL); }
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, 2003, 2004, 2005, 2006 Larry Wall
d13 3
a15 2
 *
 * This file holds the grammar for the Perl language. If edited, you need
a18 14
 * Note that these derived files are included and compiled twice; once
 * from perly.c, and once from madly.c. The second time, a number of MAD
 * macros are defined, which compile in extra code that allows the parse
 * tree to be accurately dumped. In particular:
 *
 * MAD            defined if compiling madly.c
 * DO_MAD(A)      expands to A  under madly.c, to null otherwise
 * IF_MAD(a,b)    expands to A under madly.c, to B otherwise
 * TOKEN_GETMAD() expands to token_getmad() under madly.c, to null otherwise
 * TOKEN_FREE()   similarly
 * OP_GETMAD()    similarly
 * IVAL(i)        expands to (i)->tk_lval.ival or (i)
 * PVAL(p)        expands to (p)->tk_lval.pval or (p)
 *
a21 4
 *
 * Note: due to the way that the cleanup code works WRT to freeing ops on
 * the parse stack, it is dangerous to assign to the $n variables within
 * an action.
d24 28
a51 1
/*  Make the parser re-entrant. */
d53 1
a53 1
%pure_parser
d55 1
a55 1
/* FIXME for MAD - is the new mintro on while and until important?  */
d59 4
d64 1
a64 2
    I32	ival; /* __DEFAULT__ (marker for regen_perly.pl;
				must always be 1st union member) */
d68 8
a75 6
#ifdef PERL_IN_MADLY_C
    TOKEN* p_tkval;
    TOKEN* i_tkval;
#else
    char *p_tkval;
    I32	i_tkval;
a76 4
#ifdef PERL_MAD
    TOKEN* tkval;
#endif
}
d78 3
a80 1
%token <i_tkval> '{' '}' '[' ']' '-' '+' '$' '@@' '%' '*' '&' ';'
d84 9
a92 17
%token <p_tkval> LABEL
%token <i_tkval> FORMAT SUB ANONSUB PACKAGE USE
%token <i_tkval> WHILE UNTIL IF UNLESS ELSE ELSIF CONTINUE FOR
%token <i_tkval> GIVEN WHEN DEFAULT
%token <i_tkval> LOOPEX DOTDOT
%token <i_tkval> FUNC0 FUNC1 FUNC UNIOP LSTOP
%token <i_tkval> RELOP EQOP MULOP ADDOP
%token <i_tkval> DOLSHARP DO HASHBRACK NOAMP
%token <i_tkval> LOCAL MY MYSUB REQUIRE
%token <i_tkval> COLONATTR

%type <ival> prog progstart remember mremember
%type <ival>  startsub startanonsub startformsub
/* FIXME for MAD - are these two ival? */
%type <ival> mydefsv mintro

%type <opval> decl format subrout mysubrout package use peg
d94 2
d98 1
a98 1
%type <opval> argexpr nexpr texpr iexpr mexpr mnexpr miexpr
d101 1
a101 1
%type <opval> subattrlist myattrlist myattrterm myterm
d103 1
a103 2
%type <opval> switch case
%type <p_tkval> label
d105 1
a105 1
%nonassoc <i_tkval> PREC_LOW
d108 3
a110 3
%left <i_tkval> OROP DOROP
%left <i_tkval> ANDOP
%right <i_tkval> NOTOP
d112 3
a114 3
%left <i_tkval> ','
%right <i_tkval> ASSIGNOP
%right <i_tkval> '?' ':'
d116 4
a119 4
%left <i_tkval> OROR DORDOR
%left <i_tkval> ANDAND
%left <i_tkval> BITOROP
%left <i_tkval> BITANDOP
d123 1
a123 2
%nonassoc REQUIRE
%left <i_tkval> SHIFTOP
d126 7
a132 7
%left <i_tkval> MATCHOP
%right <i_tkval> '!' '~' UMINUS REFGEN
%right <i_tkval> POWOP
%nonassoc <i_tkval> PREINC PREDEC POSTINC POSTDEC
%left <i_tkval> ARROW
%nonassoc <i_tkval> ')'
%left <i_tkval> '('
a134 2
%token <i_tkval> PEG

d145 3
a147 6
			{ if (PL_parser->copline > (line_t)IVAL($1))
			      PL_parser->copline = (line_t)IVAL($1);
			  $$ = block_end($2, $3);
			  TOKEN_GETMAD($1,$$,'{');
			  TOKEN_GETMAD($4,$$,'}');
			}
a153 4
mydefsv:	/* NULL */	/* lexicalize $_ */
			{ $$ = (I32) allocmy("$_"); }
	;

d156 4
a159 1
		    PL_parser->expect = XSTATE; $$ = block_start(TRUE);
d165 3
a167 6
			{ if (PL_parser->copline > (line_t)IVAL($1))
			      PL_parser->copline = (line_t)IVAL($1);
			  $$ = block_end($2, $3);
			  TOKEN_GETMAD($1,$$,'{');
			  TOKEN_GETMAD($4,$$,'}');
			}
d178 1
a178 6
			{
			$$ = IF_MAD(
				append_list(OP_LINESEQ,
			    	    (LISTOP*)$1, (LISTOP*)$2),
				$1);
			}
d183 1
a183 3
			    if ($1 && $2)
				PL_hints |= HINT_BLOCK_SCOPE;
			}
d188 1
a188 2
			{ $$ = newSTATEOP(0, PVAL($1), $2);
			  TOKEN_GETMAD($1,((LISTOP*)$$)->op_first,'L'); }
a189 4
	|	switch  /* ... and so do switches */
			{ $$ = $1; }
	|	label case
			{ $$ = newSTATEOP(0, PVAL($1), $2); }
d191 8
a198 16
			{
			  if (PVAL($1)) {
			      $$ = newSTATEOP(0, PVAL($1), newOP(OP_NULL, 0));
			      TOKEN_GETMAD($1,$$,'L');
			      TOKEN_GETMAD($2,((LISTOP*)$$)->op_first,';');
			  }
			  else {
			      $$ = IF_MAD(
					newOP(OP_NULL, 0),
					Nullop);
                              PL_parser->copline = NOLINE;
			      TOKEN_FREE($1);
			      TOKEN_GETMAD($2,$$,';');
			  }
			  PL_parser->expect = XSTATE;
			}
d200 2
a201 15
			{
			  $$ = newSTATEOP(0, PVAL($1), $2);
			  PL_parser->expect = XSTATE;
			  DO_MAD({
			      /* sideff might already have a nexstate */
			      OP* op = ((LISTOP*)$$)->op_first;
			      if (op) {
				  while (op->op_sibling &&
				     op->op_sibling->op_type == OP_NEXTSTATE)
					op = op->op_sibling;
				  token_getmad($1,op,'L');
				  token_getmad($3,op,';');
			      }
			  })
			}
d210 1
a210 3
			{ $$ = newLOGOP(OP_AND, 0, $3, $1);
			  TOKEN_GETMAD($2,$$,'i');
			}
d212 1
a212 3
			{ $$ = newLOGOP(OP_OR, 0, $3, $1);
			  TOKEN_GETMAD($2,$$,'i');
			}
d214 1
a214 3
			{ $$ = newLOOPOP(OPf_PARENS, 1, scalar($3), $1);
			  TOKEN_GETMAD($2,$$,'w');
			}
d216 1
a216 3
			{ $$ = newLOOPOP(OPf_PARENS, 1, $3, $1);
			  TOKEN_GETMAD($2,$$,'w');
			}
d218 2
a219 4
			{ $$ = newFOROP(0, NULL, (line_t)IVAL($2),
					Nullop, $3, $1, Nullop);
			  TOKEN_GETMAD($2,((LISTOP*)$$)->op_first->op_sibling,'w');
			}
d226 1
a226 3
			{ ($2)->op_flags |= OPf_PARENS; $$ = scope($2);
			  TOKEN_GETMAD($1,$$,'o');
			}
d228 1
a228 1
			{ PL_parser->copline = (line_t)IVAL($1);
d230 1
a230 5
			    PL_hints |= HINT_BLOCK_SCOPE;
			  TOKEN_GETMAD($1,$$,'I');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($4,$$,')');
			}
d235 1
a235 1
			{ PL_parser->copline = (line_t)IVAL($1);
d237 1
a237 5
				   newCONDOP(0, $4, scope($6), $7));
			  TOKEN_GETMAD($1,$$,'I');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			}
d239 1
a239 1
			{ PL_parser->copline = (line_t)IVAL($1);
d241 1
a241 13
				   newCONDOP(0, $4, scope($6), $7));
			  TOKEN_GETMAD($1,$$,'I');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			}
	;

/* Cases for a switch statement */
case	:	WHEN '(' remember mexpr ')' mblock
	{ $$ = block_end($3,
		newWHENOP($4, scope($6))); }
	|	DEFAULT block
	{ $$ = newWHENOP(0, scope($2)); }
d248 1
a248 3
			{ $$ = scope($2);
			  TOKEN_GETMAD($1,$$,'o');
			}
d252 2
a253 3
loop	:	label WHILE '(' remember texpr ')' mintro mblock cont
			{ OP *innerop;
			  PL_parser->copline = (line_t)$2;
d255 5
a259 12
				   newSTATEOP(0, PVAL($1),
				     innerop = newWHILEOP(0, 1, (LOOP*)Nullop,
						IVAL($2), $5, $8, $9, $7)));
			  TOKEN_GETMAD($1,innerop,'L');
			  TOKEN_GETMAD($2,innerop,'W');
			  TOKEN_GETMAD($3,innerop,'(');
			  TOKEN_GETMAD($6,innerop,')');
			}

	|	label UNTIL '(' remember iexpr ')' mintro mblock cont
			{ OP *innerop;
			  PL_parser->copline = (line_t)$2;
d261 3
a263 8
				   newSTATEOP(0, PVAL($1),
				     innerop = newWHILEOP(0, 1, (LOOP*)Nullop,
						IVAL($2), $5, $8, $9, $7)));
			  TOKEN_GETMAD($1,innerop,'L');
			  TOKEN_GETMAD($2,innerop,'W');
			  TOKEN_GETMAD($3,innerop,'(');
			  TOKEN_GETMAD($6,innerop,')');
			}
d265 2
a266 10
			{ OP *innerop;
			  $$ = block_end($4,
			     innerop = newFOROP(0, PVAL($1), (line_t)IVAL($2),
					    $5, $7, $9, $10));
			  TOKEN_GETMAD($1,((LISTOP*)innerop)->op_first,'L');
			  TOKEN_GETMAD($2,((LISTOP*)innerop)->op_first->op_sibling,'W');
			  TOKEN_GETMAD($3,((LISTOP*)innerop)->op_first->op_sibling,'d');
			  TOKEN_GETMAD($6,((LISTOP*)innerop)->op_first->op_sibling,'(');
			  TOKEN_GETMAD($8,((LISTOP*)innerop)->op_first->op_sibling,')');
			}
d268 3
a270 9
			{ OP *innerop;
			  $$ = block_end($5,
			     innerop = newFOROP(0, PVAL($1), (line_t)IVAL($2),
				    mod($3, OP_ENTERLOOP), $6, $8, $9));
			  TOKEN_GETMAD($1,((LISTOP*)innerop)->op_first,'L');
			  TOKEN_GETMAD($2,((LISTOP*)innerop)->op_first->op_sibling,'W');
			  TOKEN_GETMAD($4,((LISTOP*)innerop)->op_first->op_sibling,'(');
			  TOKEN_GETMAD($7,((LISTOP*)innerop)->op_first->op_sibling,')');
			}
d272 3
a274 11
			{ OP *innerop;
			  $$ = block_end($4,
			     innerop = newFOROP(0, PVAL($1), (line_t)IVAL($2),
						    Nullop, $5, $7, $8));
			  TOKEN_GETMAD($1,((LISTOP*)innerop)->op_first,'L');
			  TOKEN_GETMAD($2,((LISTOP*)innerop)->op_first->op_sibling,'W');
			  TOKEN_GETMAD($3,((LISTOP*)innerop)->op_first->op_sibling,'(');
			  TOKEN_GETMAD($6,((LISTOP*)innerop)->op_first->op_sibling,')');
			}
	|	label FOR '(' remember mnexpr ';' texpr ';' mintro mnexpr ')'
	    	    mblock
d277 2
a278 2
			  PL_parser->copline = (line_t)IVAL($2);
			  forop = newSTATEOP(0, PVAL($1),
d280 2
a281 16
						IVAL($2), scalar($7),
						$12, $10, $9));
#ifdef MAD
			  forop = newUNOP(OP_NULL, 0, append_elem(OP_LINESEQ,
				newSTATEOP(0,
					   CopLABEL_alloc(($1)->tk_lval.pval),
					   ($5 ? $5 : newOP(OP_NULL, 0)) ),
				forop));

			  token_getmad($2,forop,'3');
			  token_getmad($3,forop,'(');
			  token_getmad($6,forop,'1');
			  token_getmad($8,forop,'2');
			  token_getmad($11,forop,')');
			  token_getmad($1,forop,'L');
#else
d284 2
a285 1
                                        newSTATEOP(0, CopLABEL_alloc($1), $5),
a288 2

#endif
d291 1
a291 1
			{ $$ = newSTATEOP(0, PVAL($1),
d293 1
a293 2
					    NOLINE, Nullop, $2, $3, 0));
			  TOKEN_GETMAD($1,((LISTOP*)$$)->op_first,'L'); }
a295 15
/* Switch blocks */
switch	:	label GIVEN '(' remember mydefsv mexpr ')' mblock
			{ PL_parser->copline = (line_t) $2;
			    $$ = block_end($4,
				newSTATEOP(0, PVAL($1),
				    newGIVENOP($6, scope($8),
					(PADOFFSET) $5) )); }
	;

/* determine whether there are any new my declarations */
mintro	:	/* NULL */
			{ $$ = (PL_min_intro_pending &&
			    PL_max_intro_pending >=  PL_min_intro_pending);
			  intro_my(); }

d304 1
a304 3
			{ YYSTYPE tmplval;
			  (void)scan_num("1", &tmplval);
			  $$ = tmplval.opval; }
d322 4
d332 1
a332 9
			{
#ifdef MAD
			  YYSTYPE tmplval;
			  tmplval.pval = NULL;
			  $$ = newTOKEN(OP_NULL, tmplval, 0);
#else
			  $$ = NULL;
#endif
			}
d336 1
a336 1
/* Some kind of declaration - just hang on peg in the parse tree */
d338 1
a338 1
			{ $$ = $1; }
d340 1
a340 1
			{ $$ = $1; }
d342 1
a342 1
			{ $$ = $1; }
d344 1
a344 1
			{ $$ = $1; }
d346 1
a346 12
			{ $$ = $1; }

    /* these two are only used by MAD */

	|	peg
			{ $$ = $1; }
	;

peg	:	PEG
			{ $$ = newOP(OP_NULL,0);
			  TOKEN_GETMAD($1,$$,'p');
			}
d350 1
a350 11
			{ SvREFCNT_inc_simple_void(PL_compcv);
#ifdef MAD
			  $$ = newFORM($2, $3, $4);
			  prepend_madprops($1->tk_mad, $$, 'F');
			  $1->tk_mad = 0;
			  token_free($1);
#else
			  newFORM($2, $3, $4);
			  $$ = Nullop;
#endif
			}
d359 1
a359 9
			{ SvREFCNT_inc_simple_void(PL_compcv);
#ifdef MAD
			  $$ = newMYSUB($2, $3, $4, $5, $6);
			  token_getmad($1,$$,'d');
#else
			  newMYSUB($2, $3, $4, $5, $6);
			  $$ = Nullop;
#endif
			}
d364 1
a364 19
			{ SvREFCNT_inc_simple_void(PL_compcv);
#ifdef MAD
			  {
			      OP* o = newSVOP(OP_ANONCODE, 0,
				(SV*)newATTRSUB($2, $3, $4, $5, $6));
			      $$ = newOP(OP_NULL,0);
			      op_getmad(o,$$,'&');
			      op_getmad($3,$$,'n');
			      op_getmad($4,$$,'s');
			      op_getmad($5,$$,'a');
			      token_getmad($1,$$,'d');
			      append_madprops($6->op_madprop, $$, 0);
			      $6->op_madprop = 0;
			    }
#else
			  newATTRSUB($2, $3, $4, $5, $6);
			  $$ = Nullop;
#endif
			}
d368 1
a368 3
			{ $$ = start_subparse(FALSE, 0);
			    SAVEFREESV(PL_compcv); }

d372 1
a372 2
			{ $$ = start_subparse(FALSE, CVf_ANON);
			    SAVEFREESV(PL_compcv); }
d376 1
a376 2
			{ $$ = start_subparse(TRUE, 0);
			    SAVEFREESV(PL_compcv); }
d380 1
a380 1
subname	:	WORD	{ const char *const name = SvPV_nolen_const(((SVOP*)$1)->op_sv);
d382 1
a382 2
			      || strEQ(name, "INIT") || strEQ(name, "CHECK")
			      || strEQ(name, "UNITCHECK"))
d397 1
a397 3
			{ $$ = $2;
			  TOKEN_GETMAD($1,$$,':');
			}
d399 1
a399 6
			{ $$ = IF_MAD(
				    newOP(OP_NULL, 0),
				    Nullop
				);
			  TOKEN_GETMAD($1,$$,':');
			}
d404 1
a404 3
			{ $$ = $2;
			  TOKEN_GETMAD($1,$$,':');
			}
d406 1
a406 6
			{ $$ = IF_MAD(
				    newOP(OP_NULL, 0),
				    Nullop
				);
			  TOKEN_GETMAD($1,$$,':');
			}
d411 1
a411 7
	|	';'	{ $$ = IF_MAD(
				    newOP(OP_NULL,0),
				    Nullop
				);
			  PL_parser->expect = XSTATE;
			  TOKEN_GETMAD($1,$$,';');
			}
d415 3
a417 10
			{
#ifdef MAD
			  $$ = package($2);
			  token_getmad($1,$$,'o');
			  token_getmad($3,$$,';');
#else
			  package($2);
			  $$ = Nullop;
#endif
			}
d423 1
a423 13
			{ SvREFCNT_inc_simple_void(PL_compcv);
#ifdef MAD
			  $$ = utilize(IVAL($1), $2, $4, $5, $6);
			  token_getmad($1,$$,'o');
			  token_getmad($7,$$,';');
			  if (PL_parser->rsfp_filters &&
				      AvFILLp(PL_parser->rsfp_filters) >= 0)
			      append_madprops(newMADPROP('!', MAD_PV, "", 0), $$, 0);
#else
			  utilize(IVAL($1), $2, $4, $5, $6);
			  $$ = Nullop;
#endif
			}
d428 1
a428 3
			{ $$ = newLOGOP(OP_AND, 0, $1, $3);
			  TOKEN_GETMAD($2,$$,'o');
			}
d430 1
a430 7
			{ $$ = newLOGOP(IVAL($2), 0, $1, $3);
			  TOKEN_GETMAD($2,$$,'o');
			}
	|	expr DOROP expr
			{ $$ = newLOGOP(OP_DOR, 0, $1, $3);
			  TOKEN_GETMAD($2,$$,'o');
			}
d436 1
a436 9
			{
#ifdef MAD
			  OP* op = newNULLLIST();
			  token_getmad($2,op,',');
			  $$ = append_elem(OP_LIST, $1, op);
#else
			  $$ = $1;
#endif
			}
d438 1
a438 8
			{ 
			  OP* term = $3;
			  DO_MAD(
			      term = newUNOP(OP_NULL, 0, term);
			      token_getmad($2,term,',');
			  )
			  $$ = append_elem(OP_LIST, $1, term);
			}
d444 2
a445 4
			{ $$ = convert(IVAL($1), OPf_STACKED,
				prepend_elem(OP_LIST, newGVREF(IVAL($1),$2), $3) );
			  TOKEN_GETMAD($1,$$,'o');
			}
d447 2
a448 6
			{ $$ = convert(IVAL($1), OPf_STACKED,
				prepend_elem(OP_LIST, newGVREF(IVAL($1),$3), $4) );
			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			}
d453 1
a453 5
				    newUNOP(OP_METHOD, 0, $3)));
			  TOKEN_GETMAD($2,$$,'A');
			  TOKEN_GETMAD($4,$$,'(');
			  TOKEN_GETMAD($6,$$,')');
			}
d457 1
a457 3
				    newUNOP(OP_METHOD, 0, $3)));
			  TOKEN_GETMAD($2,$$,'A');
			}
d462 1
a462 2
				    newUNOP(OP_METHOD, 0, $1)));
			}
d467 1
a467 4
				    newUNOP(OP_METHOD, 0, $1)));
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			}
d469 1
a469 3
			{ $$ = convert(IVAL($1), 0, $2);
			  TOKEN_GETMAD($1,$$,'o');
			}
d471 1
a471 5
			{ $$ = convert(IVAL($1), 0, $3);
			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($4,$$,')');
			}
d473 1
a473 2
			{ SvREFCNT_inc_simple_void(PL_compcv);
			  $<opval>$ = newANONATTRSUB($2, 0, Nullop, $3); }
d477 1
a477 2
				   prepend_elem(OP_LIST, $<opval>4, $5), $1));
			}
d490 1
a490 5
			    PL_parser->expect = XOPERATOR;
			  TOKEN_GETMAD($2,$$,'{');
			  TOKEN_GETMAD($4,$$,';');
			  TOKEN_GETMAD($5,$$,'}');
			}
d492 1
a492 4
			{ $$ = newBINOP(OP_AELEM, 0, oopsAV($1), scalar($3));
			  TOKEN_GETMAD($2,$$,'[');
			  TOKEN_GETMAD($4,$$,']');
			}
d496 1
a496 5
					scalar($4));
			  TOKEN_GETMAD($2,$$,'a');
			  TOKEN_GETMAD($3,$$,'[');
			  TOKEN_GETMAD($5,$$,']');
			}
d500 1
a500 4
					scalar($3));
			  TOKEN_GETMAD($2,$$,'[');
			  TOKEN_GETMAD($4,$$,']');
			}
d503 1
a503 5
			    PL_parser->expect = XOPERATOR;
			  TOKEN_GETMAD($2,$$,'{');
			  TOKEN_GETMAD($4,$$,';');
			  TOKEN_GETMAD($5,$$,'}');
			}
d508 1
a508 6
			    PL_parser->expect = XOPERATOR;
			  TOKEN_GETMAD($2,$$,'a');
			  TOKEN_GETMAD($3,$$,'{');
			  TOKEN_GETMAD($5,$$,';');
			  TOKEN_GETMAD($6,$$,'}');
			}
d513 1
a513 5
			    PL_parser->expect = XOPERATOR;
			  TOKEN_GETMAD($2,$$,'{');
			  TOKEN_GETMAD($4,$$,';');
			  TOKEN_GETMAD($5,$$,'}');
			}
d516 1
a516 5
				   newCVREF(0, scalar($1)));
			  TOKEN_GETMAD($2,$$,'a');
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($4,$$,')');
			}
d520 1
a520 5
				       newCVREF(0, scalar($1))));
			  TOKEN_GETMAD($2,$$,'a');
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			}
d525 1
a525 4
					       newCVREF(0, scalar($1))));
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($4,$$,')');
			}
d528 1
a528 18
				   newCVREF(0, scalar($1)));
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($3,$$,')');
			}
	|	'(' expr ')' '[' expr ']'            /* list slice */
			{ $$ = newSLICEOP(0, $5, $2);
			  TOKEN_GETMAD($1,$$,'(');
			  TOKEN_GETMAD($3,$$,')');
			  TOKEN_GETMAD($4,$$,'[');
			  TOKEN_GETMAD($6,$$,']');
			}
	|	'(' ')' '[' expr ']'                 /* empty list slice! */
			{ $$ = newSLICEOP(0, $4, Nullop);
			  TOKEN_GETMAD($1,$$,'(');
			  TOKEN_GETMAD($2,$$,')');
			  TOKEN_GETMAD($3,$$,'[');
			  TOKEN_GETMAD($5,$$,']');
			}
d532 2
a533 4
termbinop:	term ASSIGNOP term                     /* $x = $y */
			{ $$ = newASSIGNOP(OPf_STACKED, $1, IVAL($2), $3);
			  TOKEN_GETMAD($2,$$,'o');
			}
d535 1
a535 3
			{ $$ = newBINOP(IVAL($2), 0, scalar($1), scalar($3));
			  TOKEN_GETMAD($2,$$,'o');
			}
d537 1
a537 1
			{   if (IVAL($2) != OP_REPEAT)
d539 1
a539 3
			    $$ = newBINOP(IVAL($2), 0, $1, scalar($3));
			  TOKEN_GETMAD($2,$$,'o');
			}
d541 1
a541 3
			{ $$ = newBINOP(IVAL($2), 0, scalar($1), scalar($3));
			  TOKEN_GETMAD($2,$$,'o');
			}
d543 1
a543 3
			{ $$ = newBINOP(IVAL($2), 0, scalar($1), scalar($3));
			  TOKEN_GETMAD($2,$$,'o');
			}
d545 1
a545 3
			{ $$ = newBINOP(IVAL($2), 0, scalar($1), scalar($3));
			  TOKEN_GETMAD($2,$$,'o');
			}
d547 1
a547 3
			{ $$ = newBINOP(IVAL($2), 0, scalar($1), scalar($3));
			  TOKEN_GETMAD($2,$$,'o');
			}
d549 1
a549 3
			{ $$ = newBINOP(IVAL($2), 0, scalar($1), scalar($3));
			  TOKEN_GETMAD($2,$$,'o');
			}
d551 1
a551 3
			{ $$ = newBINOP(IVAL($2), 0, scalar($1), scalar($3));
			  TOKEN_GETMAD($2,$$,'o');
			}
d553 1
a553 11
			{
			  $$ = newRANGE(IVAL($2), scalar($1), scalar($3));
			  DO_MAD({
			      UNOP *op;
			      op = (UNOP*)$$;
			      op = (UNOP*)op->op_first;	/* get to flop */
			      op = (UNOP*)op->op_first;	/* get to flip */
			      op = (UNOP*)op->op_first;	/* get to range */
			      token_getmad($2,(OP*)op,'o');
			    })
			}
d555 1
a555 3
			{ $$ = newLOGOP(OP_AND, 0, $1, $3);
			  TOKEN_GETMAD($2,$$,'o');
			}
d557 1
a557 7
			{ $$ = newLOGOP(OP_OR, 0, $1, $3);
			  TOKEN_GETMAD($2,$$,'o');
			}
	|	term DORDOR term                       /* $x // $y */
			{ $$ = newLOGOP(OP_DOR, 0, $1, $3);
			  TOKEN_GETMAD($2,$$,'o');
			}
d559 1
a559 6
			{ $$ = bind_match(IVAL($2), $1, $3);
			  TOKEN_GETMAD($2,
				($$->op_type == OP_NOT
				    ? ((UNOP*)$$)->op_first : $$),
				'~');
			}
d564 1
a564 3
			{ $$ = newUNOP(OP_NEGATE, 0, scalar($2));
			  TOKEN_GETMAD($1,$$,'o');
			}
d566 1
a566 6
			{ $$ = IF_MAD(
				    newUNOP(OP_NULL, 0, $2),
				    $2
				);
			  TOKEN_GETMAD($1,$$,'+');
			}
d568 1
a568 3
			{ $$ = newUNOP(OP_NOT, 0, scalar($2));
			  TOKEN_GETMAD($1,$$,'o');
			}
d570 1
a570 3
			{ $$ = newUNOP(OP_COMPLEMENT, 0, scalar($2));
			  TOKEN_GETMAD($1,$$,'o');
			}
d573 1
a573 3
					mod(scalar($1), OP_POSTINC));
			  TOKEN_GETMAD($2,$$,'o');
			}
d576 1
a576 3
					mod(scalar($1), OP_POSTDEC));
			  TOKEN_GETMAD($2,$$,'o');
			}
d579 1
a579 3
					mod(scalar($2), OP_PREINC));
			  TOKEN_GETMAD($1,$$,'o');
			}
d582 1
a582 3
					mod(scalar($2), OP_PREDEC));
			  TOKEN_GETMAD($1,$$,'o');
			}
d588 1
a588 4
			{ $$ = newANONLIST($2);
			  TOKEN_GETMAD($1,$$,'[');
			  TOKEN_GETMAD($3,$$,']');
			}
d590 1
a590 4
			{ $$ = newANONLIST(Nullop);
			  TOKEN_GETMAD($1,$$,'[');
			  TOKEN_GETMAD($2,$$,']');
			}
d592 1
a592 5
			{ $$ = newANONHASH($2);
			  TOKEN_GETMAD($1,$$,'{');
			  TOKEN_GETMAD($3,$$,';');
			  TOKEN_GETMAD($4,$$,'}');
			}
d594 1
a594 5
			{ $$ = newANONHASH(Nullop);
			  TOKEN_GETMAD($1,$$,'{');
			  TOKEN_GETMAD($2,$$,';');
			  TOKEN_GETMAD($3,$$,'}');
			}
d596 1
a596 6
			{ SvREFCNT_inc_simple_void(PL_compcv);
			  $$ = newANONATTRSUB($2, $3, $4, $5);
			  TOKEN_GETMAD($1,$$,'o');
			  OP_GETMAD($3,$$,'s');
			  OP_GETMAD($4,$$,'a');
			}
d602 1
a602 3
			{ $$ = dofile($2, IVAL($1));
			  TOKEN_GETMAD($1,$$,'o');
			}
d604 1
a604 3
			{ $$ = newUNOP(OP_NULL, OPf_SPECIAL, scope($2));
			  TOKEN_GETMAD($1,$$,'D');
			}
d612 1
a612 5
				)),Nullop)); dep();
			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($4,$$,')');
			}
d621 1
a621 5
				)))); dep();
			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			}
d625 1
a625 5
				scalar(newCVREF(0,scalar($2))), Nullop)); dep();
			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($4,$$,')');
			}
d630 1
a630 5
				scalar(newCVREF(0,scalar($2))))); dep();
			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			}
d639 1
a639 4
			{ $$ = newCONDOP(0, $1, $3, $5);
			  TOKEN_GETMAD($2,$$,'?');
			  TOKEN_GETMAD($4,$$,':');
			}
d641 1
a641 3
			{ $$ = newUNOP(OP_REFGEN, 0, mod($2,OP_REFGEN));
			  TOKEN_GETMAD($1,$$,'o');
			}
d645 1
a645 3
			{ $$ = localize($2,IVAL($1));
			  TOKEN_GETMAD($1,$$,'k');
			}
d647 1
a647 4
			{ $$ = sawparens(IF_MAD(newUNOP(OP_NULL,0,$2), $2));
			  TOKEN_GETMAD($1,$$,'(');
			  TOKEN_GETMAD($3,$$,')');
			}
d649 1
a649 4
			{ $$ = sawparens(newNULLLIST());
			  TOKEN_GETMAD($1,$$,'(');
			  TOKEN_GETMAD($2,$$,')');
			}
d662 4
d671 1
a671 4
					ref($1, OP_ASLICE)));
			  TOKEN_GETMAD($2,$$,'[');
			  TOKEN_GETMAD($4,$$,']');
			}
d678 1
a678 5
			    PL_parser->expect = XOPERATOR;
			  TOKEN_GETMAD($2,$$,'{');
			  TOKEN_GETMAD($4,$$,';');
			  TOKEN_GETMAD($5,$$,'}');
			}
d684 1
a684 4
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED, scalar($1));
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($3,$$,')');
			}
d686 2
a687 12
			{
			  $$ = newUNOP(OP_ENTERSUB, OPf_STACKED,
				append_elem(OP_LIST, $3, scalar($1)));
			  DO_MAD({
			      OP* op = $$;
			      if (op->op_type == OP_CONST) { /* defeat const fold */
				op = (OP*)op->op_madprop->mad_val;
			      }
			      token_getmad($2,op,'(');
			      token_getmad($4,op,')');
			  })
			}
d690 1
a690 3
			    append_elem(OP_LIST, $3, scalar($2)));
			  TOKEN_GETMAD($1,$$,'o');
			}
d692 2
a693 4
			{ $$ = newOP(IVAL($1), OPf_SPECIAL);
			    PL_hints |= HINT_BLOCK_SCOPE;
			  TOKEN_GETMAD($1,$$,'o');
			}
d695 1
a695 3
			{ $$ = newLOOPEX(IVAL($1),$2);
			  TOKEN_GETMAD($1,$$,'o');
			}
d697 1
a697 3
			{ $$ = newUNOP(OP_NOT, 0, scalar($2));
			  TOKEN_GETMAD($1,$$,'o');
			}
d699 3
a701 7
			{ $$ = newOP(IVAL($1), 0);
			  TOKEN_GETMAD($1,$$,'o');
			}
	|	UNIOP block                          /* eval { foo }* */
			{ $$ = newUNOP(IVAL($1), 0, $2);
			  TOKEN_GETMAD($1,$$,'o');
			}
d703 1
a703 13
			{ $$ = newUNOP(IVAL($1), 0, $2);
			  TOKEN_GETMAD($1,$$,'o');
			}
	|	REQUIRE                              /* require, $_ implied */
			{ $$ = newOP(OP_REQUIRE, $1 ? OPf_SPECIAL : 0);
			  TOKEN_GETMAD($1,$$,'o');
			}
	|	REQUIRE term                         /* require Foo */
			{ $$ = newUNOP(OP_REQUIRE, $1 ? OPf_SPECIAL : 0, $2);
			  TOKEN_GETMAD($1,$$,'o');
			}
	|	UNIOPSUB
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED, scalar($1)); }
d708 1
a708 3
			{ $$ = newOP(IVAL($1), 0);
			  TOKEN_GETMAD($1,$$,'o');
			}
d710 1
a710 5
			{ $$ = newOP(IVAL($1), 0);
			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($3,$$,')');
			}
d715 2
a716 8
			{ $$ = (IVAL($1) == OP_NOT)
			    ? newUNOP(IVAL($1), 0, newSVOP(OP_CONST, 0, newSViv(0)))
			    : newOP(IVAL($1), OPf_SPECIAL);

			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($3,$$,')');
			}
d718 5
a722 10
			{ $$ = newUNOP(IVAL($1), 0, $3);
			  TOKEN_GETMAD($1,$$,'o');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($4,$$,')');
			}
	|	PMFUNC '(' argexpr ')'		/* m//, s///, tr/// */
			{ $$ = pmruntime($1, $3, 1);
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($4,$$,')');
			}
d729 1
a729 7
			{ $$ = my_attrs($2,$3);
			  DO_MAD(
			      token_getmad($1,$$,'d');
			      append_madprops($3->op_madprop, $$, 'a');
			      $3->op_madprop = 0;
			  )
			}
d731 1
a731 3
			{ $$ = localize($2,IVAL($1));
			  TOKEN_GETMAD($1,$$,'d');
			}
d736 1
a736 4
			{ $$ = sawparens($2);
			  TOKEN_GETMAD($1,$$,'(');
			  TOKEN_GETMAD($3,$$,')');
			}
d738 1
a738 4
			{ $$ = sawparens(newNULLLIST());
			  TOKEN_GETMAD($1,$$,'(');
			  TOKEN_GETMAD($2,$$,')');
			}
d759 1
a759 10
			{
#ifdef MAD
			  OP* op = newNULLLIST();
			  token_getmad($2,op,',');
			  $$ = append_elem(OP_LIST, $1, op);
#else
			  $$ = $1;
#endif

			}
d765 1
a765 1
			{ PL_parser->in_my = 0; $$ = my($1); }
d769 1
a769 3
			{ $$ = newCVREF(IVAL($1),$2);
			  TOKEN_GETMAD($1,$$,'&');
			}
d773 1
a773 3
			{ $$ = newSVREF($2);
			  TOKEN_GETMAD($1,$$,'$');
			}
d777 1
a777 3
			{ $$ = newAVREF($2);
			  TOKEN_GETMAD($1,$$,'@@');
			}
d781 1
a781 3
			{ $$ = newHVREF($2);
			  TOKEN_GETMAD($1,$$,'%');
			}
d785 1
a785 3
			{ $$ = newAVREF($2);
			  TOKEN_GETMAD($1,$$,'l');
			}
d789 1
a789 3
			{ $$ = newGVREF(0,$2);
			  TOKEN_GETMAD($1,$$,'*');
			}
d796 1
a796 1
			{ $$ = scalar($1); }
d803 10
@


1.1.1.10
log
@import perl 5.10.1
@
text
@a3 1
 *    Copyright (c) 2007, 2008 by Larry Wall and others
d12 1
a12 1
 *  All that is gold does not glitter, not all those who wander are lost.'
a13 4
 *     [p.171 of _The Lord of the Rings_, I/x: "Strider"]
 */

/*
d180 1
a180 1
			{ $$ = (OP*)NULL; }
d216 1
a216 1
					(OP*)NULL);
d243 1
a243 1
			{ $$ = (OP*)NULL; }
d264 1
a264 1
					(OP*)NULL, $3, $1, (OP*)NULL);
d271 1
a271 1
			{ $$ = (OP*)NULL; }
d278 1
a278 1
			    $$ = newCONDOP(0, newSTATEOP(OPf_SPECIAL,NULL,$3), scope($5), $6);
d315 1
a315 1
			{ $$ = (OP*)NULL; }
d328 1
a328 1
				     innerop = newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
d341 1
a341 1
				     innerop = newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
d373 1
a373 1
						    (OP*)NULL, $5, $7, $8));
d385 1
a385 1
					    newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
d413 2
a414 2
				 newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
					    NOLINE, (OP*)NULL, $2, $3, 0));
d435 1
a435 1
			{ $$ = (OP*)NULL; }
d512 1
a512 1
			  $$ = (OP*)NULL;
d518 1
a518 1
	|	/* NULL */	{ $$ = (OP*)NULL; }
d529 1
a529 1
			  $$ = (OP*)NULL;
d552 1
a552 1
			  $$ = (OP*)NULL;
d584 1
a584 1
			{ $$ = (OP*)NULL; }
d590 1
a590 1
			{ $$ = (OP*)NULL; }
d598 1
a598 1
				    (OP*)NULL
d612 1
a612 1
				    (OP*)NULL
d622 1
a622 1
				    (OP*)NULL
d637 1
a637 1
			  $$ = (OP*)NULL;
d655 1
a655 1
			  $$ = (OP*)NULL;
d753 1
a753 1
			  $<opval>$ = newANONATTRSUB($2, 0, (OP*)NULL, $3); }
d859 1
a859 1
			{ $$ = newSLICEOP(0, $4, (OP*)NULL);
d989 1
a989 1
			{ $$ = newANONLIST((OP*)NULL);
d1000 1
a1000 1
			{ $$ = newANONHASH((OP*)NULL);
d1031 1
a1031 1
				)),(OP*)NULL)); dep();
d1052 1
a1052 1
				scalar(newCVREF(0,scalar($2))), (OP*)NULL)); dep();
d1268 1
a1268 1
			{ $$ = (OP*)NULL; }
d1274 1
a1274 1
			{ $$ = (OP*)NULL; }
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@a75 1
%token <opval> PLUGEXPR PLUGSTMT
d80 1
a80 1
%token <i_tkval> LOOPEX DOTDOT YADAYADA
d114 1
a114 1
%nonassoc DOTDOT YADAYADA
d160 1
a160 1
			{ $$ = (I32) Perl_allocmy(aTHX_ STR_WITH_LEN("$_"), 0); }
a243 2
	|	label PLUGSTMT
			{ $$ = newSTATEOP(0, PVAL($1), $2); }
a271 2
	|	expr WHEN expr
			{ $$ = newWHENOP($3, scope($1)); }
d330 1
a330 1
			  PL_parser->copline = (line_t)IVAL($2);
d343 1
a343 1
			  PL_parser->copline = (line_t)IVAL($2);
d425 1
a425 1
			{ PL_parser->copline = (line_t) IVAL($2);
d509 1
a509 3
			{
			  CV *fmtcv = PL_compcv;
			  SvREFCNT_inc_simple_void(PL_compcv);
a518 4
			  if (CvOUTSIDE(fmtcv) && !CvUNIQUE(CvOUTSIDE(fmtcv))) {
			    SvREFCNT_inc_simple_void(fmtcv);
			    pad_add_anon((SV*)fmtcv, OP_NULL);
			  }
d634 1
a634 1
package :	PACKAGE WORD WORD ';'
d637 1
a637 1
			  $$ = package($3);
d639 1
a639 3
			  if ($2)
			      package_version($2);
			  token_getmad($4,$$,';');
d641 1
a641 3
			  package($3);
			  if ($2)
			      package_version($2);
d657 1
a657 1
			      append_madprops(newMADPROP('!', MAD_NULL, NULL, 0), $$, 0);
a1234 7
	|	YADAYADA
			{
			  $$ = newLISTOP(OP_DIE, 0, newOP(OP_PUSHMARK, 0),
				newSVOP(OP_CONST, 0, newSVpvs("Unimplemented")));
			  TOKEN_GETMAD($1,$$,'X');
			}
	|	PLUGEXPR
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d4 1
a4 1
 *    Copyright (c) 2007, 2008, 2009, 2010, 2011 by Larry Wall and others
d52 1
a52 1
%start grammar
a71 2
%token <ival> GRAMPROG GRAMEXPR GRAMBLOCK GRAMBARESTMT GRAMFULLSTMT GRAMSTMTSEQ

d74 2
a75 2
%token <opval> WORD METHOD FUNCMETH THING PMFUNC PRIVATEREF QWLIST
%token <opval> FUNC0OP FUNC0SUB UNIOPSUB LSTOPSUB
d88 1
a88 3
%type <i_tkval> lpar_or_qw

%type <ival> grammar remember mremember
d93 3
a95 1
%type <opval> stmtseq fullstmt labfullstmt barestmt block mblock else
d97 2
a98 2
%type <opval> listexpr nexpr texpr iexpr mexpr mnexpr miexpr
%type <opval> optlistexpr optexpr indirob listop method
d102 2
d140 4
a143 64
/* Top-level choice of what kind of thing yyparse was called to parse */
grammar	:	GRAMPROG
			{
			  PL_parser->expect = XSTATE;
			}
		remember stmtseq
			{
			  newPROG(block_end($3,$4));
			  $$ = 0;
			}
	|	GRAMEXPR
			{
			  parser->expect = XTERM;
			}
		optexpr
			{
			  PL_eval_root = $3;
			  $$ = 0;
			}
	|	GRAMBLOCK
			{
			  parser->expect = XBLOCK;
			}
		block
			{
			  PL_pad_reset_pending = TRUE;
			  PL_eval_root = $3;
			  $$ = 0;
			  yyunlex();
			  parser->yychar = YYEOF;
			}
	|	GRAMBARESTMT
			{
			  parser->expect = XSTATE;
			}
		barestmt
			{
			  PL_pad_reset_pending = TRUE;
			  PL_eval_root = $3;
			  $$ = 0;
			  yyunlex();
			  parser->yychar = YYEOF;
			}
	|	GRAMFULLSTMT
			{
			  parser->expect = XSTATE;
			}
		fullstmt
			{
			  PL_pad_reset_pending = TRUE;
			  PL_eval_root = $3;
			  $$ = 0;
			  yyunlex();
			  parser->yychar = YYEOF;
			}
	|	GRAMSTMTSEQ
			{
			  parser->expect = XSTATE;
			}
		stmtseq
			{
			  PL_eval_root = $3;
			  $$ = 0;
			}
d147 1
a147 1
block	:	'{' remember stmtseq '}'
d164 8
a171 1
mblock	:	'{' mremember stmtseq '}'
d184 2
a185 2
/* A sequence of statements in the program */
stmtseq	:	/* NULL */
d187 10
a196 2
	|	stmtseq fullstmt
			{   $$ = op_append_list(OP_LINESEQ, $1, $2);
d203 6
a208 10
/* A statement in the program, including optional labels */
fullstmt:	barestmt
			{
			  if($1) {
			      $$ = newSTATEOP(0, NULL, $1);
			  } else {
			      $$ = IF_MAD(newOP(OP_NULL, 0), NULL);
			  }
			}
	|	labfullstmt
d210 8
a217 167
	;

labfullstmt:	LABEL barestmt
			{
			  $$ = newSTATEOP(SvUTF8(((SVOP*)$1)->op_sv),
                                        savepv(SvPVX(((SVOP*)$1)->op_sv)), $2);
			  TOKEN_GETMAD($1,
			      $2 ? cLISTOPx($$)->op_first : $$, 'L');
			}
	|	LABEL labfullstmt
			{
			  $$ = newSTATEOP(SvUTF8(((SVOP*)$1)->op_sv),
                                        savepv(SvPVX(((SVOP*)$1)->op_sv)), $2);
			  TOKEN_GETMAD($1, cLISTOPx($$)->op_first, 'L');
			}
	;

/* A bare statement, lacking label and other aspects of state op */
barestmt:	PLUGSTMT
			{ $$ = $1; }
	|	PEG
			{
			  $$ = newOP(OP_NULL,0);
			  TOKEN_GETMAD($1,$$,'p');
			}
	|	FORMAT startformsub formname block
			{
			  CV *fmtcv = PL_compcv;
			  SvREFCNT_inc_simple_void(PL_compcv);
#ifdef MAD
			  $$ = newFORM($2, $3, $4);
			  prepend_madprops($1->tk_mad, $$, 'F');
			  $1->tk_mad = 0;
			  token_free($1);
#else
			  newFORM($2, $3, $4);
			  $$ = (OP*)NULL;
#endif
			  if (CvOUTSIDE(fmtcv) && !CvUNIQUE(CvOUTSIDE(fmtcv))) {
			      SvREFCNT_inc_simple_void(fmtcv);
			      pad_add_anon(fmtcv, OP_NULL);
			  }
			}
	|	SUB startsub subname proto subattrlist subbody
			{
			  SvREFCNT_inc_simple_void(PL_compcv);
#ifdef MAD
			  {
			      OP* o = newSVOP(OP_ANONCODE, 0,
				(SV*)newATTRSUB($2, $3, $4, $5, $6));
			      $$ = newOP(OP_NULL,0);
			      op_getmad(o,$$,'&');
			      op_getmad($3,$$,'n');
			      op_getmad($4,$$,'s');
			      op_getmad($5,$$,'a');
			      token_getmad($1,$$,'d');
			      append_madprops($6->op_madprop, $$, 0);
			      $6->op_madprop = 0;
			  }
#else
			  newATTRSUB($2, $3, $4, $5, $6);
			  $$ = (OP*)NULL;
#endif
			}
	|	MYSUB startsub subname proto subattrlist subbody
			{
			  /* Unimplemented "my sub foo { }" */
			  SvREFCNT_inc_simple_void(PL_compcv);
#ifdef MAD
			  $$ = newMYSUB($2, $3, $4, $5, $6);
			  token_getmad($1,$$,'d');
#else
			  newMYSUB($2, $3, $4, $5, $6);
			  $$ = (OP*)NULL;
#endif
			}
	|	PACKAGE WORD WORD ';'
			{
#ifdef MAD
			  $$ = package($3);
			  token_getmad($1,$$,'o');
			  if ($2)
			      package_version($2);
			  token_getmad($4,$$,';');
#else
			  package($3);
			  if ($2)
			      package_version($2);
			  $$ = (OP*)NULL;
#endif
			}
	|	USE startsub
			{ CvSPECIAL_on(PL_compcv); /* It's a BEGIN {} */ }
		WORD WORD optlistexpr ';'
			{
			  SvREFCNT_inc_simple_void(PL_compcv);
#ifdef MAD
			  $$ = utilize(IVAL($1), $2, $4, $5, $6);
			  token_getmad($1,$$,'o');
			  token_getmad($7,$$,';');
			  if (PL_parser->rsfp_filters &&
				      AvFILLp(PL_parser->rsfp_filters) >= 0)
			      append_madprops(newMADPROP('!', MAD_NULL, NULL, 0), $$, 0);
#else
			  utilize(IVAL($1), $2, $4, $5, $6);
			  $$ = (OP*)NULL;
#endif
			}
	|	IF lpar_or_qw remember mexpr ')' mblock else
			{
			  $$ = block_end($3,
			      newCONDOP(0, $4, op_scope($6), $7));
			  TOKEN_GETMAD($1,$$,'I');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			  PL_parser->copline = (line_t)IVAL($1);
			}
	|	UNLESS lpar_or_qw remember miexpr ')' mblock else
			{
			  $$ = block_end($3,
			      newCONDOP(0, $4, op_scope($6), $7));
			  TOKEN_GETMAD($1,$$,'I');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			  PL_parser->copline = (line_t)IVAL($1);
			}
	|	GIVEN lpar_or_qw remember mydefsv mexpr ')' mblock
			{
			  $$ = block_end($3,
				  newGIVENOP($5, op_scope($7), (PADOFFSET)$4));
			  PL_parser->copline = (line_t)IVAL($1);
			}
	|	WHEN lpar_or_qw remember mexpr ')' mblock
			{ $$ = block_end($3, newWHENOP($4, op_scope($6))); }
	|	DEFAULT block
			{ $$ = newWHENOP(0, op_scope($2)); }
	|	WHILE lpar_or_qw remember texpr ')' mintro mblock cont
			{
			  $$ = block_end($3,
				  newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
				      $4, $7, $8, $6));
			  TOKEN_GETMAD($1,$$,'W');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			  PL_parser->copline = (line_t)IVAL($1);
			}
	|	UNTIL lpar_or_qw remember iexpr ')' mintro mblock cont
			{
			  $$ = block_end($3,
				  newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
				      $4, $7, $8, $6));
			  TOKEN_GETMAD($1,$$,'W');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			  PL_parser->copline = (line_t)IVAL($1);
			}
	|	FOR lpar_or_qw remember mnexpr ';' texpr ';' mintro mnexpr ')'
		mblock
			{
			  OP *initop = IF_MAD($4 ? $4 : newOP(OP_NULL, 0), $4);
			  OP *forop = newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
				      scalar($6), $11, $9, $8);
			  if (initop) {
			      forop = op_prepend_elem(OP_LINESEQ, initop,
				  op_append_elem(OP_LINESEQ,
				      newOP(OP_UNSTACK, OPf_SPECIAL),
				      forop));
d219 7
a225 53
			  DO_MAD({ forop = newUNOP(OP_NULL, 0, forop); })
			  $$ = block_end($3, forop);
			  TOKEN_GETMAD($1,$$,'3');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,'1');
			  TOKEN_GETMAD($7,$$,'2');
			  TOKEN_GETMAD($10,$$,')');
			  PL_parser->copline = (line_t)IVAL($1);
			}
	|	FOR MY remember my_scalar lpar_or_qw mexpr ')' mblock cont
			{
			  $$ = block_end($3, newFOROP(0, $4, $6, $8, $9));
			  TOKEN_GETMAD($1,$$,'W');
			  TOKEN_GETMAD($2,$$,'d');
			  TOKEN_GETMAD($5,$$,'(');
			  TOKEN_GETMAD($7,$$,')');
			  PL_parser->copline = (line_t)IVAL($1);
			}
	|	FOR scalar lpar_or_qw remember mexpr ')' mblock cont
			{
			  $$ = block_end($4, newFOROP(0,
				      op_lvalue($2, OP_ENTERLOOP), $5, $7, $8));
			  TOKEN_GETMAD($1,$$,'W');
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($6,$$,')');
			  PL_parser->copline = (line_t)IVAL($1);
			}
	|	FOR lpar_or_qw remember mexpr ')' mblock cont
			{
			  $$ = block_end($3,
				  newFOROP(0, (OP*)NULL, $4, $6, $7));
			  TOKEN_GETMAD($1,$$,'W');
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
			  PL_parser->copline = (line_t)IVAL($1);
			}
	|	block cont
			{
			  /* a block is a loop that happens once */
			  $$ = newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
				  (OP*)NULL, $1, $2, 0);
			}
	|	PACKAGE WORD WORD '{' remember
			{
			  int save_3_latefree = $3->op_latefree;
			  $3->op_latefree = 1;
			  package($3);
			  $3->op_latefree = save_3_latefree;
			  if ($2) {
			      int save_2_latefree = $2->op_latefree;
			      $2->op_latefree = 1;
			      package_version($2);
			      $2->op_latefree = save_2_latefree;
a226 16
			}
		stmtseq '}'
			{
			  /* a block is a loop that happens once */
			  $$ = newWHILEOP(0, 1, (LOOP*)(OP*)NULL,
				  (OP*)NULL, block_end($5, $7), (OP*)NULL, 0);
			  op_free($3);
			  if ($2)
			      op_free($2);
			  TOKEN_GETMAD($4,$$,'{');
			  TOKEN_GETMAD($8,$$,'}');
			  if (PL_parser->copline > (line_t)IVAL($4))
			      PL_parser->copline = (line_t)IVAL($4);
			}
	|	sideff ';'
			{
a227 2
			  $$ = $1;
			  TOKEN_GETMAD($2,$$,';');
d229 1
a229 1
	|	';'
d231 1
d233 11
a243 3
			  $$ = IF_MAD(newOP(OP_NULL, 0), (OP*)NULL);
			  TOKEN_GETMAD($1,$$,';');
			  PL_parser->copline = NOLINE;
d245 2
d271 3
a273 3
			{ $$ = newFOROP(0, (OP*)NULL, $3, $1, (OP*)NULL);
			  TOKEN_GETMAD($2,$$,'w');
			  PL_parser->copline = (line_t)IVAL($2);
d276 1
a276 1
			{ $$ = newWHENOP($3, op_scope($1)); }
d283 1
a283 3
			{
			  ($2)->op_flags |= OPf_PARENS;
			  $$ = op_scope($2);
d286 1
a286 1
	|	ELSIF lpar_or_qw mexpr ')' mblock else
d288 2
a289 4
			    $$ = newCONDOP(0,
				newSTATEOP(OPf_SPECIAL,NULL,$3),
				op_scope($5), $6);
			  PL_hints |= HINT_BLOCK_SCOPE;
d296 27
d327 1
a327 2
			{
			  $$ = op_scope($2);
d332 105
d475 58
d537 36
d645 35
d693 1
a693 1
	|	listexpr %prec PREC_LOW
d697 1
a697 1
listexpr:	listexpr ','
d702 1
a702 1
			  $$ = op_append_elem(OP_LIST, $1, op);
d707 1
a707 1
	|	listexpr ',' term
d714 1
a714 1
			  $$ = op_append_elem(OP_LIST, $1, term);
d720 1
a720 1
listop	:	LSTOP indirob listexpr /* map {...} @@args or print $fh @@args */
d722 1
a722 1
				op_prepend_elem(OP_LIST, newGVREF(IVAL($1),$2), $3) );
d727 1
a727 1
				op_prepend_elem(OP_LIST, newGVREF(IVAL($1),$3), $4) );
d732 1
a732 1
	|	term ARROW method lpar_or_qw optexpr ')' /* $foo->bar(list) */
d734 2
a735 2
				op_append_elem(OP_LIST,
				    op_prepend_elem(OP_LIST, scalar($1), $5),
d743 1
a743 1
				op_append_elem(OP_LIST, scalar($1),
d747 1
a747 1
	|	METHOD indirob optlistexpr           /* new Class @@args */
d749 2
a750 2
				op_append_elem(OP_LIST,
				    op_prepend_elem(OP_LIST, $2, $3),
d753 1
a753 1
	|	FUNCMETH indirob '(' optexpr ')'    /* method $object (@@args) */
d755 2
a756 2
				op_append_elem(OP_LIST,
				    op_prepend_elem(OP_LIST, $2, $4),
d761 1
a761 1
	|	LSTOP optlistexpr                    /* print @@args */
d765 1
a765 1
	|	FUNC '(' optexpr ')'                 /* print (@@args) */
d774 1
a774 1
		    optlistexpr		%prec LSTOP  /* ... @@bar */
d776 2
a777 2
				 op_append_elem(OP_LIST,
				   op_prepend_elem(OP_LIST, $<opval>4, $5), $1));
d816 1
a816 1
	|	scalar '{' expr ';' '}'    /* $foo{bar();} */
d851 1
a851 1
				   op_append_elem(OP_LIST, $4,
d858 1
a858 1
	|	subscripted lpar_or_qw expr ')'   /* $foo->{bar}->(@@args) */
d860 1
a860 1
				   op_append_elem(OP_LIST, $3,
d865 1
a865 1
	|	subscripted lpar_or_qw ')'        /* $foo->{bar}->() */
a877 5
	|	QWLIST '[' expr ']'            /* list literal slice */
			{ $$ = newSLICEOP(0, $3, $1);
			  TOKEN_GETMAD($2,$$,'[');
			  TOKEN_GETMAD($4,$$,']');
			}
d981 1
a981 1
					op_lvalue(scalar($1), OP_POSTINC));
d986 1
a986 1
					op_lvalue(scalar($1), OP_POSTDEC));
d991 1
a991 1
					op_lvalue(scalar($2), OP_PREINC));
d996 1
a996 1
					op_lvalue(scalar($2), OP_PREDEC));
d1041 1
a1041 1
			{ $$ = newUNOP(OP_NULL, OPf_SPECIAL, op_scope($2));
d1044 1
a1044 1
	|	DO WORD lpar_or_qw ')'                  /* do somesub() */
d1047 1
a1047 1
			    op_prepend_elem(OP_LIST,
d1056 1
a1056 1
	|	DO WORD lpar_or_qw expr ')'             /* do somesub(@@args) */
d1059 1
a1059 1
			    op_append_elem(OP_LIST,
d1069 1
a1069 1
	|	DO scalar lpar_or_qw ')'                /* do $subref () */
d1071 1
a1071 1
			    op_prepend_elem(OP_LIST,
d1077 1
a1077 1
	|	DO scalar lpar_or_qw expr ')'           /* do $subref (@@args) */
d1079 1
a1079 1
			    op_prepend_elem(OP_LIST,
d1099 1
a1099 1
			{ $$ = newUNOP(OP_REFGEN, 0, op_lvalue($2,OP_REFGEN));
a1112 2
	|	QWLIST
			{ $$ = IF_MAD(newUNOP(OP_NULL,0,$1), $1); }
d1131 1
a1131 1
			{ $$ = op_prepend_elem(OP_ASLICE,
d1140 1
a1140 1
			{ $$ = op_prepend_elem(OP_HSLICE,
d1154 1
a1154 1
	|	amper lpar_or_qw ')'                 /* &foo() */
d1159 1
a1159 1
	|	amper lpar_or_qw expr ')'            /* &foo(@@args) */
d1162 1
a1162 1
				op_append_elem(OP_LIST, $3, scalar($1)));
d1172 1
a1172 1
	|	NOAMP WORD optlistexpr               /* foo(@@args) */
d1174 1
a1174 1
			    op_append_elem(OP_LIST, $3, scalar($2)));
d1186 1
a1186 1
	|	NOTOP listexpr                       /* not $foo */
d1214 1
a1214 1
			    op_append_elem(OP_LIST, $2, scalar($1))); }
a1224 7
	|	FUNC0OP       /* Same as above, but op created in toke.c */
			{ $$ = $1; }
	|	FUNC0OP '(' ')'
			{ $$ = $1;
			  TOKEN_GETMAD($2,$$,'(');
			  TOKEN_GETMAD($3,$$,')');
			}
d1243 1
a1243 1
	|	PMFUNC '(' listexpr ')'		/* m//, s///, tr/// */
d1294 1
a1294 1
optlistexpr:	/* NULL */ %prec PREC_LOW
d1296 1
a1296 1
	|	listexpr    %prec PREC_LOW
d1300 1
a1300 1
optexpr:	/* NULL */
d1304 9
a1312 1
	;
d1314 1
a1314 6
lpar_or_qw:	'('
			{ $$ = $1; }
	|	QWLIST
			{ munge_qwlist_to_paren_list($1); }
		'('
			{ $$ = $3; }
d1365 1
a1365 1
			{ $$ = op_scope($1); }
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d74 1
a74 1
%token <i_tkval> '{' '}' '[' ']' '-' '+' '$' '@@' '%' '*' '&' ';' '=' '.'
d87 4
a90 2
%token <i_tkval> LOCAL MY REQUIRE
%token <i_tkval> COLONATTR FORMLBRACK FORMRBRACK
d95 1
a95 1
%type <ival> mintro
d101 1
a101 1
%type <opval> formname subname proto subbody cont my_scalar formblock
a103 1
%type <opval> formstmtseq formline formarg
d216 2
a217 8
/* format body */
formblock:	'=' remember ';' FORMRBRACK formstmtseq ';' '.'
			{ if (PL_parser->copline > (line_t)IVAL($1))
			      PL_parser->copline = (line_t)IVAL($1);
			  $$ = block_end($2, $5);
			  TOKEN_GETMAD($1,$$,'{');
			  TOKEN_GETMAD($7,$$,'}');
			}
d220 2
a221 2
remember:	/* NULL */	/* start a full lexical scope */
			{ $$ = block_start(TRUE); }
a247 11
/* A sequence of format lines */
formstmtseq:	/* NULL */
			{ $$ = (OP*)NULL; }
	|	formstmtseq formline
			{   $$ = op_append_list(OP_LINESEQ, $1, $2);
			    PL_pad_reset_pending = TRUE;
			    if ($1 && $2)
				PL_hints |= HINT_BLOCK_SCOPE;
			}
	;

d263 2
a264 3
			  $$ = newSTATEOP(SVf_UTF8
					   * PVAL($1)[strlen(PVAL($1))+1],
					  PVAL($1), $2);
d270 2
a271 3
			  $$ = newSTATEOP(SVf_UTF8
					   * PVAL($1)[strlen(PVAL($1))+1],
					  PVAL($1), $2);
d284 1
a284 1
	|	FORMAT startformsub formname formblock
d287 1
d297 1
a297 1
			  if (CvOUTSIDE(fmtcv) && !CvEVAL(CvOUTSIDE(fmtcv))) {
d302 1
a302 23
	|	SUB subname startsub
			{
			  if ($2->op_type == OP_CONST) {
			    const char *const name =
				SvPV_nolen_const(((SVOP*)$2)->op_sv);
			    if (strEQ(name, "BEGIN") || strEQ(name, "END")
			      || strEQ(name, "INIT") || strEQ(name, "CHECK")
			      || strEQ(name, "UNITCHECK"))
			      CvSPECIAL_on(PL_compcv);
			  }
			  else
			  /* State subs inside anonymous subs need to be
			     clonable themselves. */
			  if (CvANON(CvOUTSIDE(PL_compcv))
			   || CvCLONE(CvOUTSIDE(PL_compcv))
			   || !PadnameIsSTATE(PadlistNAMESARRAY(CvPADLIST(
						CvOUTSIDE(PL_compcv)
					     ))[$2->op_targ]))
			      CvCLONE_on(PL_compcv);
			  PL_parser->in_my = 0;
			  PL_parser->in_my_stash = NULL;
			}
		proto subattrlist subbody
d308 1
a308 7
				(SV*)(
#endif
			  $2->op_type == OP_CONST
			      ? newATTRSUB($3, $2, $5, $6, $7)
			      : newMYSUB($3, $2, $5, $6, $7)
#ifdef MAD
				));
d311 3
a313 3
			      op_getmad($2,$$,'n');
			      op_getmad($5,$$,'s');
			      op_getmad($6,$$,'a');
d315 2
a316 2
			      append_madprops($7->op_madprop, $$, 0);
			      $7->op_madprop = 0;
d319 13
a331 1
			  ;
a333 1
			  intro_my();
d367 1
a367 1
	|	IF '(' remember mexpr ')' mblock else
d376 1
a376 1
	|	UNLESS '(' remember miexpr ')' mblock else
d385 1
a385 1
	|	GIVEN '(' remember mexpr ')' mblock
a386 1
			  const PADOFFSET offset = pad_findmy_pvs("$_", 0);
d388 1
a388 5
				  newGIVENOP($4, op_scope($6),
				    offset == NOT_IN_PAD
				    || PAD_COMPNAME_FLAGS_isOUR(offset)
				      ? 0
				      : offset));
d391 1
a391 1
	|	WHEN '(' remember mexpr ')' mblock
d395 1
a395 1
	|	WHILE '(' remember texpr ')' mintro mblock cont
d405 1
a405 1
	|	UNTIL '(' remember iexpr ')' mintro mblock cont
d415 1
a415 1
	|	FOR '(' remember mnexpr ';' texpr ';' mintro mnexpr ')'
d436 1
a436 1
	|	FOR MY remember my_scalar '(' mexpr ')' mblock cont
d445 1
a445 1
	|	FOR scalar '(' remember mexpr ')' mblock cont
d454 1
a454 1
	|	FOR '(' remember mexpr ')' mblock cont
d471 2
d474 1
d476 2
d479 1
d487 3
a509 30
/* Format line */
formline:	THING formarg
			{ OP *list;
			  if ($2) {
			      OP *term = $2;
			      DO_MAD(term = newUNOP(OP_NULL, 0, term));
			      list = op_append_elem(OP_LIST, $1, term);
			  }
			  else {
#ifdef MAD
			      OP *op = newNULLLIST();
			      list = op_append_elem(OP_LIST, $1, op);
#else
			      list = $1;
#endif
			  }
			  if (PL_parser->copline == NOLINE)
			       PL_parser->copline = CopLINE(PL_curcop)-1;
			  else PL_parser->copline--;
			  $$ = newSTATEOP(0, NULL,
					  convert(OP_FORMLINE, 0, list));
			}
	;

formarg	:	/* NULL */
			{ $$ = NULL; }
	|	FORMLBRACK stmtseq FORMRBRACK
			{ $$ = op_unscope($2); }
	;

d549 1
a549 1
	|	ELSIF '(' mexpr ')' mblock else
d630 6
a635 2
subname	:	WORD
	|	PRIVATEREF
d737 1
a737 1
	|	term ARROW method '(' optexpr ')' /* $foo->bar(list) */
d863 1
a863 1
	|	subscripted '(' expr ')'   /* $foo->{bar}->(@@args) */
d870 1
a870 1
	|	subscripted '(' ')'        /* $foo->{bar}->() */
d946 1
a946 1
			    });
d1054 1
a1054 1
	|	DO subname '(' ')'                  /* do somesub() */
d1066 1
a1066 1
	|	DO subname '(' expr ')'             /* do somesub(@@args) */
d1079 1
a1079 1
	|	DO scalar '(' ')'                /* do $subref () */
d1087 1
a1087 1
	|	DO scalar '(' expr ')'           /* do $subref (@@args) */
d1166 1
a1166 1
	|	amper '(' ')'                 /* &foo() */
d1171 1
a1171 1
	|	amper '(' expr ')'            /* &foo(@@args) */
d1182 1
a1182 1
			  });
d1184 1
a1184 1
	|	NOAMP subname optlistexpr               /* foo(@@args) */
d1262 4
a1265 15
	|	PMFUNC /* m//, s///, qr//, tr/// */
			{
			    if (   $1->op_type != OP_TRANS
			        && $1->op_type != OP_TRANSR
				&& (((PMOP*)$1)->op_pmflags & PMf_HAS_CV))
			    {
				$<ival>$ = start_subparse(FALSE, CVf_ANON);
				SAVEFREESV(PL_compcv);
			    } else
				$<ival>$ = 0;
			}
		    '(' listexpr ')'
			{ $$ = pmruntime($1, $4, 1, $<ival>2);
			  TOKEN_GETMAD($3,$$,'(');
			  TOKEN_GETMAD($5,$$,')');
d1285 1
a1285 1
			  );
d1323 8
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@a96 1
%type <opval> sliceme kvslice gelem
d99 1
a99 1
%type <opval> formname subname proto optsubbody cont my_scalar formblock
d101 1
a101 1
%type <opval> realsubbody subsignature termbinop termunop anonymous termdo
d129 1
a129 1
%nonassoc <i_tkval> PREINC PREDEC POSTINC POSTDEC POSTJOIN
d341 1
a341 1
		proto subattrlist optsubbody
d730 2
a731 34
/* Optional subroutine signature */
subsignature:	/* NULL */ { $$ = (OP*)NULL; }
	|	'('
			{
			  if (!FEATURE_SIGNATURES_IS_ENABLED)
			    Perl_croak(aTHX_ "Experimental "
				"subroutine signatures not enabled");
			  Perl_ck_warner_d(aTHX_
				packWARN(WARN_EXPERIMENTAL__SIGNATURES),
				"The signatures feature is experimental");
			  $<opval>$ = parse_subsignature();
			}
		')'
			{
			  $$ = op_append_list(OP_LINESEQ, $<opval>2,
				newSTATEOP(0, NULL, sawparens(newNULLLIST())));
			  PL_parser->expect = XBLOCK;
			}
	;

/* Subroutine body - block with optional signature */
realsubbody:	remember subsignature '{' stmtseq '}'
			{
			  if (PL_parser->copline > (line_t)IVAL($3))
			      PL_parser->copline = (line_t)IVAL($3);
			  $$ = block_end($1,
				op_append_list(OP_LINESEQ, $2, $4));
			  TOKEN_GETMAD($3,$$,'{');
			  TOKEN_GETMAD($5,$$,'}');
			}
	;

/* Optional subroutine body, for named subroutine declaration */
optsubbody:	realsubbody { $$ = $1; }
d848 1
a848 1
subscripted:    gelem '{' expr ';' '}'        /* *main::{something} */
a1054 12
	|	term POSTJOIN    /* implicit join after interpolated ->@@ */
			{ $$ = convert(OP_JOIN, 0,
				       op_append_elem(
					OP_LIST,
					newSVREF(scalar(
					    newSVOP(OP_CONST,0,
						    newSVpvs("\""))
					)),
					$1
				       ));
			  TOKEN_GETMAD($2,$$,'o');
			}
d1091 1
a1091 1
	|	ANONSUB startanonsub proto subattrlist realsubbody	%prec '('
d1110 43
d1198 1
a1198 1
	|	sliceme '[' expr ']'                     /* array slice */
a1203 15
			  if ($$ && $1)
			      $$->op_private |=
				  $1->op_private & OPpSLICEWARNING;
			  TOKEN_GETMAD($2,$$,'[');
			  TOKEN_GETMAD($4,$$,']');
			}
	|	kvslice '[' expr ']'                 /* array key/value slice */
			{ $$ = op_prepend_elem(OP_KVASLICE,
				newOP(OP_PUSHMARK, 0),
				    newLISTOP(OP_KVASLICE, 0,
					list($3),
					ref(oopsAV($1), OP_KVASLICE)));
			  if ($$ && $1)
			      $$->op_private |=
				  $1->op_private & OPpSLICEWARNING;
d1207 1
a1207 1
	|	sliceme '{' expr ';' '}'                 /* @@hash{@@keys} */
a1212 17
			  if ($$ && $1)
			      $$->op_private |=
				  $1->op_private & OPpSLICEWARNING;
			    PL_parser->expect = XOPERATOR;
			  TOKEN_GETMAD($2,$$,'{');
			  TOKEN_GETMAD($4,$$,';');
			  TOKEN_GETMAD($5,$$,'}');
			}
	|	kvslice '{' expr ';' '}'                 /* %hash{@@keys} */
			{ $$ = op_prepend_elem(OP_KVHSLICE,
				newOP(OP_PUSHMARK, 0),
				    newLISTOP(OP_KVHSLICE, 0,
					list($3),
					ref($1, OP_KVHSLICE)));
			  if ($$ && $1)
			      $$->op_private |=
				  $1->op_private & OPpSLICEWARNING;
d1222 1
a1222 1
	|	amper '(' ')'                 /* &foo() or foo() */
d1227 1
a1227 1
	|	amper '(' expr ')'          /* &foo(@@args) or foo(@@args) */
d1240 1
a1240 1
	|	NOAMP subname optlistexpr       /* foo @@args (no parens) */
a1244 21
	|	term ARROW '$' '*'
			{ $$ = newSVREF($1);
			  TOKEN_GETMAD($3,$$,'$');
			}
	|	term ARROW '@@' '*'
			{ $$ = newAVREF($1);
			  TOKEN_GETMAD($3,$$,'@@');
			}
	|	term ARROW '%' '*'
			{ $$ = newHVREF($1);
			  TOKEN_GETMAD($3,$$,'%');
			}
	|	term ARROW '&' '*'
			{ $$ = newUNOP(OP_ENTERSUB, 0,
				       scalar(newCVREF(IVAL($3),$1)));
			  TOKEN_GETMAD($3,$$,'&');
			}
	|	term ARROW '*' '*'	%prec '('
			{ $$ = newGVREF(0,$1);
			  TOKEN_GETMAD($3,$$,'*');
			}
a1411 1
			  if ($$) $$->op_private |= IVAL($1);
a1417 1
			  if ($$) $$->op_private |= IVAL($1);
a1425 4
	|	term ARROW DOLSHARP '*'
			{ $$ = newAVREF($1);
			  TOKEN_GETMAD($3,$$,'l');
			}
a1430 21
			}
	;

sliceme	:	ary
	|	term ARROW '@@'
			{ $$ = newAVREF($1);
			  TOKEN_GETMAD($3,$$,'@@');
			}
	;

kvslice	:	hsh
	|	term ARROW '%'
			{ $$ = newHVREF($1);
			  TOKEN_GETMAD($3,$$,'@@');
			}
	;

gelem	:	star
	|	term ARROW '*'
			{ $$ = newGVREF(0,$1);
			  TOKEN_GETMAD($3,$$,'*');
@


1.1.1.15
log
@Import perl-5.24.2
@
text
@d23 14
d48 3
a50 1
%pure-parser
d60 10
d74 1
a74 1
%token <ival> '{' '}' '[' ']' '-' '+' '@@' '%' '&' '=' '.'
d79 10
a88 10
%token <pval> LABEL
%token <ival> FORMAT SUB ANONSUB PACKAGE USE
%token <ival> WHILE UNTIL IF UNLESS ELSE ELSIF CONTINUE FOR
%token <ival> GIVEN WHEN DEFAULT
%token <ival> LOOPEX DOTDOT YADAYADA
%token <ival> FUNC0 FUNC1 FUNC UNIOP LSTOP
%token <ival> RELOP EQOP MULOP ADDOP
%token <ival> DOLSHARP DO HASHBRACK NOAMP
%token <ival> LOCAL MY REQUIRE
%token <ival> COLONATTR FORMLBRACK FORMRBRACK
d92 1
a92 1

d98 3
a100 4
%type <opval> listexpr nexpr texpr iexpr mexpr mnexpr
%type <opval> optlistexpr optexpr optrepl indirob listop method
%type <opval> formname subname proto optsubbody cont my_scalar my_var
%type <opval> refgen_topic formblock
d102 1
a102 1
%type <opval> subsignature termbinop termunop anonymous termdo
d105 1
a105 1
%nonassoc <ival> PREC_LOW
d108 3
a110 3
%left <ival> OROP DOROP
%left <ival> ANDOP
%right <ival> NOTOP
d112 3
a114 3
%left <ival> ','
%right <ival> ASSIGNOP
%right <ival> '?' ':'
d116 4
a119 4
%left <ival> OROR DORDOR
%left <ival> ANDAND
%left <ival> BITOROP
%left <ival> BITANDOP
d124 1
a124 1
%left <ival> SHIFTOP
d127 7
a133 7
%left <ival> MATCHOP
%right <ival> '!' '~' UMINUS REFGEN
%right <ival> POWOP
%nonassoc <ival> PREINC PREDEC POSTINC POSTDEC POSTJOIN
%left <ival> ARROW
%nonassoc <ival> ')'
%left <ival> '('
d136 2
d143 1
a143 1
			  parser->expect = XSTATE;
a147 1
			  PL_compiling.cop_seq = 0;
d208 2
a209 2
			{ if (parser->copline > (line_t)$1)
			      parser->copline = (line_t)$1;
d211 2
d218 2
a219 2
			{ if (parser->copline > (line_t)$1)
			      parser->copline = (line_t)$1;
d221 2
d227 1
a227 2
			{ $$ = block_start(TRUE);
			  parser->parsed_sub = 0; }
d231 2
a232 2
			{ if (parser->copline > (line_t)$1)
			      parser->copline = (line_t)$1;
d234 2
d240 1
a240 2
			{ $$ = block_start(FALSE);
			  parser->parsed_sub = 0; }
d268 5
a272 1
			  $$ = $1 ? newSTATEOP(0, NULL, $1) : NULL;
d280 5
a284 1
			  $$ = newSTATEOP(SVf_UTF8 * $1[strlen($1)+1], $1, $2);
d288 4
a291 1
			  $$ = newSTATEOP(SVf_UTF8 * $1[strlen($1)+1], $1, $2);
d298 5
d306 6
d314 1
d316 2
a317 1
			      pad_add_weakref(fmtcv);
a318 1
			  parser->parsed_sub = 1;
d339 2
a340 2
			  parser->in_my = 0;
			  parser->in_my_stash = NULL;
d345 5
d353 10
a362 14
			  ;
			  $$ = (OP*)NULL;
			  intro_my();
			  parser->parsed_sub = 1;
			}
	|	SUB subname startsub
			{
			  if ($2->op_type == OP_CONST) {
			    const char *const name =
				SvPV_nolen_const(((SVOP*)$2)->op_sv);
			    if (strEQ(name, "BEGIN") || strEQ(name, "END")
			      || strEQ(name, "INIT") || strEQ(name, "CHECK")
			      || strEQ(name, "UNITCHECK"))
			      CvSPECIAL_on(PL_compcv);
d364 1
a364 24
			  else
			  /* State subs inside anonymous subs need to be
			     clonable themselves. */
			  if (CvANON(CvOUTSIDE(PL_compcv))
			   || CvCLONE(CvOUTSIDE(PL_compcv))
			   || !PadnameIsSTATE(PadlistNAMESARRAY(CvPADLIST(
						CvOUTSIDE(PL_compcv)
					     ))[$2->op_targ]))
			      CvCLONE_on(PL_compcv);
			  parser->in_my = 0;
			  parser->in_my_stash = NULL;
			}
		remember subsignature subattrlist '{' stmtseq '}'
			{
			  OP *body;
			  if (parser->copline > (line_t)$8)
			      parser->copline = (line_t)$8;
			  body = block_end($5,
				op_append_list(OP_LINESEQ, $6, $9));

			  SvREFCNT_inc_simple_void(PL_compcv);
			  $2->op_type == OP_CONST
			      ? newATTRSUB($3, $2, NULL, $7, body)
			      : newMYSUB($3, $2, NULL, $7, body)
d367 1
a368 1
			  parser->parsed_sub = 1;
d372 7
d383 1
d390 9
a398 2
			  utilize($1, $2, $4, $5, $6);
			  parser->parsed_sub = 1;
d400 1
d406 4
a409 1
			  parser->copline = (line_t)$1;
d411 1
a411 1
	|	UNLESS '(' remember mexpr ')' mblock else
d414 5
a418 2
                              newCONDOP(0, $4, $7, op_scope($6)));
			  parser->copline = (line_t)$1;
d422 8
a429 2
			  $$ = block_end($3, newGIVENOP($4, op_scope($6), 0));
			  parser->copline = (line_t)$1;
d440 4
a443 1
			  parser->copline = (line_t)$1;
d450 4
a453 1
			  parser->copline = (line_t)$1;
d455 1
a455 5
	|	FOR '(' remember mnexpr ';'
			{ parser->expect = XTERM; }
		texpr ';'
			{ parser->expect = XTERM; }
		mintro mnexpr ')'
d458 1
a458 1
			  OP *initop = $4;
d460 1
a460 1
				      scalar($7), $13, $11, $10);
d467 1
a467 1
			  PL_hints |= HINT_BLOCK_SCOPE;
d469 6
a474 1
			  parser->copline = (line_t)$1;
d479 5
a483 1
			  parser->copline = (line_t)$1;
d489 4
a492 24
			  parser->copline = (line_t)$1;
			}
	|	FOR REFGEN MY remember my_var
			{ parser->in_my = 0; $<opval>$ = my($5); }
		'(' mexpr ')' mblock cont
			{
			  $$ = block_end(
				$4,
				newFOROP(0,
					 op_lvalue(
					    newUNOP(OP_REFGEN, 0,
						    $<opval>6),
					    OP_ENTERLOOP),
					 $8, $10, $11)
			  );
			  parser->copline = (line_t)$1;
			}
	|	FOR REFGEN refgen_topic '(' remember mexpr ')' mblock cont
			{
			  $$ = block_end($5, newFOROP(
				0, op_lvalue(newUNOP(OP_REFGEN, 0,
						     $3),
					     OP_ENTERLOOP), $6, $8, $9));
			  parser->copline = (line_t)$1;
d498 4
a501 1
			  parser->copline = (line_t)$1;
d521 4
a524 2
			  if (parser->copline > (line_t)$4)
			      parser->copline = (line_t)$4;
d528 1
d530 1
d534 4
a537 2
			  $$ = (OP*)NULL;
			  parser->copline = NOLINE;
d546 1
d550 4
d555 1
d557 3
a559 3
			  if (parser->copline == NOLINE)
			       parser->copline = CopLINE(PL_curcop)-1;
			  else parser->copline--;
d561 1
a561 1
					  op_convert_list(OP_FORMLINE, 0, list));
d577 3
a579 1
			{ $$ = newLOGOP(OP_AND, 0, $3, $1); }
d581 3
a583 1
			{ $$ = newLOGOP(OP_OR, 0, $3, $1); }
d585 3
a587 1
			{ $$ = newLOOPOP(OPf_PARENS, 1, scalar($3), $1); }
d589 3
a591 1
			{ $$ = newLOOPOP(OPf_PARENS, 1, $3, $1); }
d594 3
a596 1
			  parser->copline = (line_t)$2; }
d608 1
d611 1
a611 1
			{ parser->copline = (line_t)$1;
d616 3
d626 4
a629 1
			{ $$ = op_scope($2); }
d666 4
d705 3
a707 1
			{ $$ = $2; }
d709 6
a714 1
			{ $$ = (OP*)NULL; }
d719 3
a721 1
			{ $$ = $2; }
d723 6
a728 1
			{ $$ = (OP*)NULL; }
d731 3
a733 2
/* Subroutine signature */
subsignature:	'('
d735 3
a737 3
			  /* We shouldn't get here otherwise */
			  assert(FEATURE_SIGNATURES_IS_ENABLED);

d747 13
a759 1
			  parser->expect = XATTRBLOCK;
d764 8
a771 2
optsubbody:	block
	|	';'	{ $$ = (OP*)NULL; }
d776 3
a778 1
			{ $$ = newLOGOP(OP_AND, 0, $1, $3); }
d780 3
a782 1
			{ $$ = newLOGOP($2, 0, $1, $3); }
d784 3
a786 1
			{ $$ = newLOGOP(OP_DOR, 0, $1, $3); }
d792 9
a800 1
			{ $$ = $1; }
d802 1
a802 1
			{
d804 4
d815 3
a817 2
			{ $$ = op_convert_list($1, OPf_STACKED,
				op_prepend_elem(OP_LIST, newGVREF($1,$2), $3) );
d820 5
a824 2
			{ $$ = op_convert_list($1, OPf_STACKED,
				op_prepend_elem(OP_LIST, newGVREF($1,$3), $4) );
d827 1
a827 1
			{ $$ = op_convert_list(OP_ENTERSUB, OPf_STACKED,
d830 4
a833 1
				    newMETHOP(OP_METHOD, 0, $3)));
d836 1
a836 1
			{ $$ = op_convert_list(OP_ENTERSUB, OPf_STACKED,
d838 2
a839 1
				    newMETHOP(OP_METHOD, 0, $3)));
d842 1
a842 1
			{ $$ = op_convert_list(OP_ENTERSUB, OPf_STACKED,
d845 1
a845 1
				    newMETHOP(OP_METHOD, 0, $1)));
d848 1
a848 1
			{ $$ = op_convert_list(OP_ENTERSUB, OPf_STACKED,
d851 3
a853 1
				    newMETHOP(OP_METHOD, 0, $1)));
d856 3
a858 1
			{ $$ = op_convert_list($1, 0, $2); }
d860 5
a864 1
			{ $$ = op_convert_list($1, 0, $3); }
d884 6
a889 1
			{ $$ = newBINOP(OP_GELEM, 0, $1, scalar($3)); }
d892 2
d899 3
d907 2
d912 4
d920 7
a926 1
					jmaybe($4)); }
d930 6
a935 1
					jmaybe($3)); }
d938 5
a942 1
				   newCVREF(0, scalar($1))); }
d946 5
a950 1
				       newCVREF(0, scalar($1)))); }
d955 4
a958 1
					       newCVREF(0, scalar($1)))); }
d961 4
a964 1
				   newCVREF(0, scalar($1))); }
d966 6
a971 1
			{ $$ = newSLICEOP(0, $5, $2); }
d973 4
a976 1
			{ $$ = newSLICEOP(0, $3, $1); }
d978 6
a983 1
			{ $$ = newSLICEOP(0, $4, (OP*)NULL); }
d988 3
a990 1
			{ $$ = newASSIGNOP(OPf_STACKED, $1, $2, $3); }
d992 3
a994 1
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
d996 1
a996 1
			{   if ($2 != OP_REPEAT)
d998 2
a999 1
			    $$ = newBINOP($2, 0, $1, scalar($3));
d1002 3
a1004 1
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
d1006 3
a1008 1
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
d1010 3
a1012 1
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
d1014 3
a1016 1
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
d1018 3
a1020 1
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
d1022 3
a1024 1
			{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
d1026 11
a1036 1
			{ $$ = newRANGE($2, scalar($1), scalar($3)); }
d1038 3
a1040 1
			{ $$ = newLOGOP(OP_AND, 0, $1, $3); }
d1042 3
a1044 1
			{ $$ = newLOGOP(OP_OR, 0, $1, $3); }
d1046 3
a1048 1
			{ $$ = newLOGOP(OP_DOR, 0, $1, $3); }
d1050 6
a1055 1
			{ $$ = bind_match($2, $1, $3); }
d1060 3
a1062 1
			{ $$ = newUNOP(OP_NEGATE, 0, scalar($2)); }
d1064 6
a1069 2
			{ $$ = $2; }

d1071 3
a1073 1
			{ $$ = newUNOP(OP_NOT, 0, scalar($2)); }
d1075 3
a1077 1
			{ $$ = newUNOP($1, 0, scalar($2)); }
d1080 3
a1082 1
					op_lvalue(scalar($1), OP_POSTINC)); }
d1085 3
a1087 1
					op_lvalue(scalar($1), OP_POSTDEC));}
d1089 1
a1089 1
			{ $$ = op_convert_list(OP_JOIN, 0,
d1098 1
d1102 3
a1104 1
					op_lvalue(scalar($2), OP_PREINC)); }
d1107 3
a1109 1
					op_lvalue(scalar($2), OP_PREDEC)); }
d1115 4
a1118 1
			{ $$ = newANONLIST($2); }
d1120 4
a1123 1
			{ $$ = newANONLIST((OP*)NULL);}
d1125 5
a1129 1
			{ $$ = newANONHASH($2); }
d1131 6
a1136 2
			{ $$ = newANONHASH((OP*)NULL); }
	|	ANONSUB startanonsub proto subattrlist block		%prec '('
d1138 4
a1141 10
			  $$ = newANONATTRSUB($2, $3, $4, $5); }
	|	ANONSUB startanonsub remember subsignature subattrlist '{' stmtseq '}'	%prec '('
			{
			  OP *body;
			  if (parser->copline > (line_t)$6)
			      parser->copline = (line_t)$6;
			  body = block_end($3,
				op_append_list(OP_LINESEQ, $4, $7));
			  SvREFCNT_inc_simple_void(PL_compcv);
			  $$ = newANONATTRSUB($2, NULL, $5, body);
d1148 3
a1150 1
			{ $$ = dofile($2, $1);}
d1152 3
a1154 1
			{ $$ = newUNOP(OP_NULL, OPf_SPECIAL, op_scope($2));}
d1162 4
a1165 1
			{ $$ = newCONDOP(0, $1, $3, $5); }
d1167 3
a1169 1
			{ $$ = newUNOP(OP_REFGEN, 0, $2); }
d1173 3
a1175 1
			{ $$ = localize($2,$1); }
d1177 4
a1180 1
			{ $$ = sawparens($2); }
d1182 1
a1182 1
			{ $$ = $1; }
d1184 4
a1187 1
			{ $$ = sawparens(newNULLLIST()); }
d1209 2
d1221 2
d1233 4
d1247 4
d1258 2
d1265 8
d1277 1
d1280 3
a1282 1
			{ $$ = newSVREF($1); }
d1284 3
a1286 1
			{ $$ = newAVREF($1); }
d1288 3
a1290 1
			{ $$ = newHVREF($1); }
d1293 3
a1295 1
				       scalar(newCVREF($3,$1))); }
d1297 3
a1299 1
			{ $$ = newGVREF(0,$1); }
d1301 4
a1304 2
			{ $$ = newOP($1, OPf_SPECIAL);
			    PL_hints |= HINT_BLOCK_SCOPE; }
d1306 3
a1308 1
			{ $$ = newLOOPEX($1,$2); }
d1310 3
a1312 1
			{ $$ = newUNOP(OP_NOT, 0, scalar($2)); }
d1314 3
a1316 1
			{ $$ = newOP($1, 0); }
d1318 3
a1320 1
			{ $$ = newUNOP($1, 0, $2); }
d1322 3
a1324 1
			{ $$ = newUNOP($1, 0, $2); }
d1326 3
a1328 1
			{ $$ = newOP(OP_REQUIRE, $1 ? OPf_SPECIAL : 0); }
d1330 3
a1332 1
			{ $$ = newUNOP(OP_REQUIRE, $1 ? OPf_SPECIAL : 0, $2); }
d1339 3
a1341 1
			{ $$ = newOP($1, 0); }
d1343 5
a1347 1
			{ $$ = newOP($1, 0);}
d1351 4
a1354 1
			{ $$ = $1; }
d1356 2
a1357 1
			{ $$ = newUNOP(OP_ENTERSUB, OPf_STACKED, scalar($1)); }
d1359 8
a1366 3
			{ $$ = ($1 == OP_NOT)
                          ? newUNOP($1, 0, newSVOP(OP_CONST, 0, newSViv(0)))
                          : newOP($1, OPf_SPECIAL); }
d1368 5
a1372 1
			{ $$ = newUNOP($1, 0, $3); }
d1384 5
a1388 2
		    '(' listexpr optrepl ')'
			{ $$ = pmruntime($1, $4, $5, 1, $<ival>2); }
d1395 1
d1402 7
a1408 1
			{ $$ = my_attrs($2,$3); }
d1410 3
a1412 1
			{ $$ = localize($2,$1); }
d1417 4
a1420 1
			{ $$ = sawparens($2); }
d1422 4
a1425 2
			{ $$ = sawparens(newNULLLIST()); }

a1446 6
optrepl:	/* NULL */
			{ $$ = (OP*)NULL; }
	|	'/' expr
			{ $$ = $2; }
	;

d1450 1
a1450 10
			{ parser->in_my = 0; $$ = my($1); }
	;

my_var	:	scalar
	|	ary
	|	hsh
	;

refgen_topic:	my_var
	|	amper
d1454 3
a1456 1
			{ $$ = newCVREF($1,$2); }
d1460 3
a1462 1
			{ $$ = newSVREF($2); }
d1467 2
a1468 1
			  if ($$) $$->op_private |= $1;
d1474 2
a1475 1
			  if ($$) $$->op_private |= $1;
d1480 3
a1482 1
			{ $$ = newAVREF($2); }
d1484 3
a1486 1
			{ $$ = newAVREF($1); }
d1490 3
a1492 1
			{ $$ = newGVREF(0,$2); }
d1497 3
a1499 1
			{ $$ = newAVREF($1); }
d1504 3
a1506 1
			{ $$ = newHVREF($1); }
d1511 3
a1513 1
			{ $$ = newGVREF(0,$1); }
@


