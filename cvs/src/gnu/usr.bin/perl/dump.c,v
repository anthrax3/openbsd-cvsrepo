head	1.17;
access;
symbols
	PERL_5_24_2:1.1.1.16
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.10
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.15
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.17
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	cxJ08BvJA9Pt2PTM;

1.16
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.44;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.06.40;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.20;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.35.56;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.22.57;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.18;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.54;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.20;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.47;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.03.51;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.50.58;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.30;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.38;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.38;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.13;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.34;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.21.59;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.46;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.28;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.39;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.16.23;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.47.25;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.04;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.34;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.34;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.06.22;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.58.44;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.52.36;	author afresh1;	state Exp;
branches;
next	1.1.1.16;
commitid	B31cAbBIXiCqnL97;

1.1.1.16
date	2017.08.14.13.45.25;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.17
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    dump.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 *  'You have talked long in your sleep, Frodo,' said Gandalf gently, 'and
 *   it has not been hard for me to read your mind and memory.'
 *
 *     [p.220 of _The Lord of the Rings_, II/i: "Many Meetings"]
 */

/* This file contains utility routines to dump the contents of SV and OP
 * structures, as used by command-line options like -Dt and -Dx, and
 * by Devel::Peek.
 *
 * It also holds the debugging version of the  runops function.

=head1 Display and Dump functions
 */

#include "EXTERN.h"
#define PERL_IN_DUMP_C
#include "perl.h"
#include "regcomp.h"

static const char* const svtypenames[SVt_LAST] = {
    "NULL",
    "IV",
    "NV",
    "PV",
    "INVLIST",
    "PVIV",
    "PVNV",
    "PVMG",
    "REGEXP",
    "PVGV",
    "PVLV",
    "PVAV",
    "PVHV",
    "PVCV",
    "PVFM",
    "PVIO"
};


static const char* const svshorttypenames[SVt_LAST] = {
    "UNDEF",
    "IV",
    "NV",
    "PV",
    "INVLST",
    "PVIV",
    "PVNV",
    "PVMG",
    "REGEXP",
    "GV",
    "PVLV",
    "AV",
    "HV",
    "CV",
    "FM",
    "IO"
};

struct flag_to_name {
    U32 flag;
    const char *name;
};

static void
S_append_flags(pTHX_ SV *sv, U32 flags, const struct flag_to_name *start,
	       const struct flag_to_name *const end)
{
    do {
	if (flags & start->flag)
	    sv_catpv(sv, start->name);
    } while (++start < end);
}

#define append_flags(sv, f, flags) \
    S_append_flags(aTHX_ (sv), (f), (flags), C_ARRAY_END(flags))

#define generic_pv_escape(sv,s,len,utf8) pv_escape( (sv), (s), (len), \
                              (len) * (4+UTF8_MAXBYTES) + 1, NULL, \
                              PERL_PV_ESCAPE_NONASCII | PERL_PV_ESCAPE_DWIM \
                              | ((utf8) ? PERL_PV_ESCAPE_UNI : 0) )

/*
=for apidoc pv_escape

Escapes at most the first C<count> chars of C<pv> and puts the results into
C<dsv> such that the size of the escaped string will not exceed C<max> chars
and will not contain any incomplete escape sequences.  The number of bytes
escaped will be returned in the C<STRLEN *escaped> parameter if it is not null.
When the C<dsv> parameter is null no escaping actually occurs, but the number
of bytes that would be escaped were it not null will be calculated.

If flags contains C<PERL_PV_ESCAPE_QUOTE> then any double quotes in the string
will also be escaped.

Normally the SV will be cleared before the escaped string is prepared,
but when C<PERL_PV_ESCAPE_NOCLEAR> is set this will not occur.

If C<PERL_PV_ESCAPE_UNI> is set then the input string is treated as UTF-8
if C<PERL_PV_ESCAPE_UNI_DETECT> is set then the input string is scanned
using C<is_utf8_string()> to determine if it is UTF-8.

If C<PERL_PV_ESCAPE_ALL> is set then all input chars will be output
using C<\x01F1> style escapes, otherwise if C<PERL_PV_ESCAPE_NONASCII> is set, only
non-ASCII chars will be escaped using this style; otherwise, only chars above
255 will be so escaped; other non printable chars will use octal or
common escaped patterns like C<\n>.
Otherwise, if C<PERL_PV_ESCAPE_NOBACKSLASH>
then all chars below 255 will be treated as printable and
will be output as literals.

If C<PERL_PV_ESCAPE_FIRSTCHAR> is set then only the first char of the
string will be escaped, regardless of max.  If the output is to be in hex,
then it will be returned as a plain hex
sequence.  Thus the output will either be a single char,
an octal escape sequence, a special escape like C<\n> or a hex value.

If C<PERL_PV_ESCAPE_RE> is set then the escape char used will be a C<"%"> and
not a C<"\\">.  This is because regexes very often contain backslashed
sequences, whereas C<"%"> is not a particularly common character in patterns.

Returns a pointer to the escaped text as held by C<dsv>.

=cut
*/
#define PV_ESCAPE_OCTBUFSIZE 32

char *
Perl_pv_escape( pTHX_ SV *dsv, char const * const str, 
                const STRLEN count, const STRLEN max, 
                STRLEN * const escaped, const U32 flags ) 
{
    const char esc = (flags & PERL_PV_ESCAPE_RE) ? '%' : '\\';
    const char dq = (flags & PERL_PV_ESCAPE_QUOTE) ? '"' : esc;
    char octbuf[PV_ESCAPE_OCTBUFSIZE] = "%123456789ABCDF";
    STRLEN wrote = 0;    /* chars written so far */
    STRLEN chsize = 0;   /* size of data to be written */
    STRLEN readsize = 1; /* size of data just read */
    bool isuni= flags & PERL_PV_ESCAPE_UNI ? 1 : 0; /* is this UTF-8 */
    const char *pv  = str;
    const char * const end = pv + count; /* end of string */
    octbuf[0] = esc;

    PERL_ARGS_ASSERT_PV_ESCAPE;

    if (dsv && !(flags & PERL_PV_ESCAPE_NOCLEAR)) {
	    /* This won't alter the UTF-8 flag */
	    sv_setpvs(dsv, "");
    }
    
    if ((flags & PERL_PV_ESCAPE_UNI_DETECT) && is_utf8_string((U8*)pv, count))
        isuni = 1;
    
    for ( ; (pv < end && (!max || (wrote < max))) ; pv += readsize ) {
        const UV u= (isuni) ? utf8_to_uvchr_buf((U8*)pv, (U8*) end, &readsize) : (U8)*pv;
        const U8 c = (U8)u & 0xFF;
        
        if ( ( u > 255 )
	  || (flags & PERL_PV_ESCAPE_ALL)
	  || (( ! isASCII(u) ) && (flags & (PERL_PV_ESCAPE_NONASCII|PERL_PV_ESCAPE_DWIM))))
	{
            if (flags & PERL_PV_ESCAPE_FIRSTCHAR) 
                chsize = my_snprintf( octbuf, PV_ESCAPE_OCTBUFSIZE, 
                                      "%"UVxf, u);
            else
                chsize = my_snprintf( octbuf, PV_ESCAPE_OCTBUFSIZE, 
                                      ((flags & PERL_PV_ESCAPE_DWIM) && !isuni)
                                      ? "%cx%02"UVxf
                                      : "%cx{%02"UVxf"}", esc, u);

        } else if (flags & PERL_PV_ESCAPE_NOBACKSLASH) {
            chsize = 1;            
        } else {         
            if ( (c == dq) || (c == esc) || !isPRINT(c) ) {
	        chsize = 2;
                switch (c) {
                
		case '\\' : /* FALLTHROUGH */
		case '%'  : if ( c == esc )  {
		                octbuf[1] = esc;  
		            } else {
		                chsize = 1;
		            }
		            break;
		case '\v' : octbuf[1] = 'v';  break;
		case '\t' : octbuf[1] = 't';  break;
		case '\r' : octbuf[1] = 'r';  break;
		case '\n' : octbuf[1] = 'n';  break;
		case '\f' : octbuf[1] = 'f';  break;
                case '"'  : 
                        if ( dq == '"' ) 
				octbuf[1] = '"';
                        else 
                            chsize = 1;
                        break;
		default:
                     if ( (flags & PERL_PV_ESCAPE_DWIM) && c != '\0' ) {
                        chsize = my_snprintf( octbuf, PV_ESCAPE_OCTBUFSIZE,
                                      isuni ? "%cx{%02"UVxf"}" : "%cx%02"UVxf,
                                      esc, u);
                     }
                     else if ( (pv+readsize < end) && isDIGIT((U8)*(pv+readsize)) )
                            chsize = my_snprintf( octbuf, PV_ESCAPE_OCTBUFSIZE, 
                                                  "%c%03o", esc, c);
			else
                            chsize = my_snprintf( octbuf, PV_ESCAPE_OCTBUFSIZE, 
                                                  "%c%o", esc, c);
                }
            } else {
                chsize = 1;
            }
	}
	if ( max && (wrote + chsize > max) ) {
	    break;
        } else if (chsize > 1) {
            if (dsv)
                sv_catpvn(dsv, octbuf, chsize);
            wrote += chsize;
	} else {
	    /* If PERL_PV_ESCAPE_NOBACKSLASH is set then non-ASCII bytes
	       can be appended raw to the dsv. If dsv happens to be
	       UTF-8 then we need catpvf to upgrade them for us.
	       Or add a new API call sv_catpvc(). Think about that name, and
	       how to keep it clear that it's unlike the s of catpvs, which is
	       really an array of octets, not a string.  */
            if (dsv)
                Perl_sv_catpvf( aTHX_ dsv, "%c", c);
	    wrote++;
	}
        if ( flags & PERL_PV_ESCAPE_FIRSTCHAR ) 
            break;
    }
    if (escaped != NULL)
        *escaped= pv - str;
    return dsv ? SvPVX(dsv) : NULL;
}
/*
=for apidoc pv_pretty

Converts a string into something presentable, handling escaping via
C<pv_escape()> and supporting quoting and ellipses.

If the C<PERL_PV_PRETTY_QUOTE> flag is set then the result will be
double quoted with any double quotes in the string escaped.  Otherwise
if the C<PERL_PV_PRETTY_LTGT> flag is set then the result be wrapped in
angle brackets. 

If the C<PERL_PV_PRETTY_ELLIPSES> flag is set and not all characters in
string were output then an ellipsis C<...> will be appended to the
string.  Note that this happens AFTER it has been quoted.

If C<start_color> is non-null then it will be inserted after the opening
quote (if there is one) but before the escaped text.  If C<end_color>
is non-null then it will be inserted after the escaped text but before
any quotes or ellipses.

Returns a pointer to the prettified text as held by C<dsv>.

=cut           
*/

char *
Perl_pv_pretty( pTHX_ SV *dsv, char const * const str, const STRLEN count, 
  const STRLEN max, char const * const start_color, char const * const end_color, 
  const U32 flags ) 
{
    const U8 *quotes = (U8*)((flags & PERL_PV_PRETTY_QUOTE) ? "\"\"" :
                             (flags & PERL_PV_PRETTY_LTGT)  ? "<>" : NULL);
    STRLEN escaped;
    STRLEN max_adjust= 0;
    STRLEN orig_cur;
 
    PERL_ARGS_ASSERT_PV_PRETTY;
   
    if (!(flags & PERL_PV_PRETTY_NOCLEAR)) {
        /* This won't alter the UTF-8 flag */
        sv_setpvs(dsv, "");
    }
    orig_cur= SvCUR(dsv);

    if ( quotes )
        Perl_sv_catpvf(aTHX_ dsv, "%c", quotes[0]);
        
    if ( start_color != NULL ) 
        sv_catpv(dsv, start_color);

    if ((flags & PERL_PV_PRETTY_EXACTSIZE)) {
        if (quotes)
            max_adjust += 2;
        assert(max > max_adjust);
        pv_escape( NULL, str, count, max - max_adjust, &escaped, flags );
        if ( (flags & PERL_PV_PRETTY_ELLIPSES) && ( escaped < count ) )
            max_adjust += 3;
        assert(max > max_adjust);
    }

    pv_escape( dsv, str, count, max - max_adjust, &escaped, flags | PERL_PV_ESCAPE_NOCLEAR );

    if ( end_color != NULL ) 
        sv_catpv(dsv, end_color);

    if ( quotes )
        Perl_sv_catpvf(aTHX_ dsv, "%c", quotes[1]);
    
    if ( (flags & PERL_PV_PRETTY_ELLIPSES) && ( escaped < count ) )
	    sv_catpvs(dsv, "...");

    if ((flags & PERL_PV_PRETTY_EXACTSIZE)) {
        while( SvCUR(dsv) - orig_cur < max )
            sv_catpvs(dsv," ");
    }
 
    return SvPVX(dsv);
}

/*
=for apidoc pv_display

Similar to

  pv_escape(dsv,pv,cur,pvlim,PERL_PV_ESCAPE_QUOTE);

except that an additional "\0" will be appended to the string when
len > cur and pv[cur] is "\0".

Note that the final string may be up to 7 chars longer than pvlim.

=cut
*/

char *
Perl_pv_display(pTHX_ SV *dsv, const char *pv, STRLEN cur, STRLEN len, STRLEN pvlim)
{
    PERL_ARGS_ASSERT_PV_DISPLAY;

    pv_pretty( dsv, pv, cur, pvlim, NULL, NULL, PERL_PV_PRETTY_DUMP);
    if (len > cur && pv[cur] == '\0')
            sv_catpvs( dsv, "\\0");
    return SvPVX(dsv);
}

char *
Perl_sv_peek(pTHX_ SV *sv)
{
    dVAR;
    SV * const t = sv_newmortal();
    int unref = 0;
    U32 type;

    sv_setpvs(t, "");
  retry:
    if (!sv) {
	sv_catpv(t, "VOID");
	goto finish;
    }
    else if (sv == (const SV *)0x55555555 || ((char)SvTYPE(sv)) == 'U') {
        /* detect data corruption under memory poisoning */
	sv_catpv(t, "WILD");
	goto finish;
    }
    else if (sv == &PL_sv_undef || sv == &PL_sv_no || sv == &PL_sv_yes || sv == &PL_sv_placeholder) {
	if (sv == &PL_sv_undef) {
	    sv_catpv(t, "SV_UNDEF");
	    if (!(SvFLAGS(sv) & (SVf_OK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		SvREADONLY(sv))
		goto finish;
	}
	else if (sv == &PL_sv_no) {
	    sv_catpv(t, "SV_NO");
	    if (!(SvFLAGS(sv) & (SVf_ROK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		!(~SvFLAGS(sv) & (SVf_POK|SVf_NOK|SVf_READONLY|
				  SVp_POK|SVp_NOK)) &&
		SvCUR(sv) == 0 &&
		SvNVX(sv) == 0.0)
		goto finish;
	}
	else if (sv == &PL_sv_yes) {
	    sv_catpv(t, "SV_YES");
	    if (!(SvFLAGS(sv) & (SVf_ROK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		!(~SvFLAGS(sv) & (SVf_POK|SVf_NOK|SVf_READONLY|
				  SVp_POK|SVp_NOK)) &&
		SvCUR(sv) == 1 &&
		SvPVX_const(sv) && *SvPVX_const(sv) == '1' &&
		SvNVX(sv) == 1.0)
		goto finish;
	}
	else {
	    sv_catpv(t, "SV_PLACEHOLDER");
	    if (!(SvFLAGS(sv) & (SVf_OK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		SvREADONLY(sv))
		goto finish;
	}
	sv_catpv(t, ":");
    }
    else if (SvREFCNT(sv) == 0) {
	sv_catpv(t, "(");
	unref++;
    }
    else if (DEBUG_R_TEST_) {
	int is_tmp = 0;
	SSize_t ix;
	/* is this SV on the tmps stack? */
	for (ix=PL_tmps_ix; ix>=0; ix--) {
	    if (PL_tmps_stack[ix] == sv) {
		is_tmp = 1;
		break;
	    }
	}
	if (SvREFCNT(sv) > 1)
	    Perl_sv_catpvf(aTHX_ t, "<%"UVuf"%s>", (UV)SvREFCNT(sv),
		    is_tmp ? "T" : "");
	else if (is_tmp)
	    sv_catpv(t, "<T>");
    }

    if (SvROK(sv)) {
	sv_catpv(t, "\\");
	if (SvCUR(t) + unref > 10) {
	    SvCUR_set(t, unref + 3);
	    *SvEND(t) = '\0';
	    sv_catpv(t, "...");
	    goto finish;
	}
	sv = SvRV(sv);
	goto retry;
    }
    type = SvTYPE(sv);
    if (type == SVt_PVCV) {
        SV * const tmp = newSVpvs_flags("", SVs_TEMP);
        GV* gvcv = CvGV(sv);
        Perl_sv_catpvf(aTHX_ t, "CV(%s)", gvcv
                       ? generic_pv_escape( tmp, GvNAME(gvcv), GvNAMELEN(gvcv), GvNAMEUTF8(gvcv))
                       : "");
	goto finish;
    } else if (type < SVt_LAST) {
	sv_catpv(t, svshorttypenames[type]);

	if (type == SVt_NULL)
	    goto finish;
    } else {
	sv_catpv(t, "FREED");
	goto finish;
    }

    if (SvPOKp(sv)) {
	if (!SvPVX_const(sv))
	    sv_catpv(t, "(null)");
	else {
	    SV * const tmp = newSVpvs("");
	    sv_catpv(t, "(");
	    if (SvOOK(sv)) {
		STRLEN delta;
		SvOOK_offset(sv, delta);
		Perl_sv_catpvf(aTHX_ t, "[%s]", pv_display(tmp, SvPVX_const(sv)-delta, delta, 0, 127));
	    }
	    Perl_sv_catpvf(aTHX_ t, "%s)", pv_display(tmp, SvPVX_const(sv), SvCUR(sv), SvLEN(sv), 127));
	    if (SvUTF8(sv))
		Perl_sv_catpvf(aTHX_ t, " [UTF8 \"%s\"]",
			       sv_uni_display(tmp, sv, 6 * SvCUR(sv),
					      UNI_DISPLAY_QQ));
	    SvREFCNT_dec_NN(tmp);
	}
    }
    else if (SvNOKp(sv)) {
	STORE_LC_NUMERIC_UNDERLYING_SET_STANDARD();
	Perl_sv_catpvf(aTHX_ t, "(%"NVgf")",SvNVX(sv));
	RESTORE_LC_NUMERIC_UNDERLYING();
    }
    else if (SvIOKp(sv)) {
	if (SvIsUV(sv))
	    Perl_sv_catpvf(aTHX_ t, "(%"UVuf")", (UV)SvUVX(sv));
	else
            Perl_sv_catpvf(aTHX_ t, "(%"IVdf")", (IV)SvIVX(sv));
    }
    else
	sv_catpv(t, "()");

  finish:
    while (unref--)
	sv_catpv(t, ")");
    if (TAINTING_get && sv && SvTAINTED(sv))
	sv_catpv(t, " [tainted]");
    return SvPV_nolen(t);
}

/*
=head1 Debugging Utilities
*/

void
Perl_dump_indent(pTHX_ I32 level, PerlIO *file, const char* pat, ...)
{
    va_list args;
    PERL_ARGS_ASSERT_DUMP_INDENT;
    va_start(args, pat);
    dump_vindent(level, file, pat, &args);
    va_end(args);
}

void
Perl_dump_vindent(pTHX_ I32 level, PerlIO *file, const char* pat, va_list *args)
{
    PERL_ARGS_ASSERT_DUMP_VINDENT;
    PerlIO_printf(file, "%*s", (int)(level*PL_dumpindent), "");
    PerlIO_vprintf(file, pat, *args);
}

/*
=for apidoc dump_all

Dumps the entire optree of the current program starting at C<PL_main_root> to 
C<STDERR>.  Also dumps the optrees for all visible subroutines in
C<PL_defstash>.

=cut
*/

void
Perl_dump_all(pTHX)
{
    dump_all_perl(FALSE);
}

void
Perl_dump_all_perl(pTHX_ bool justperl)
{
    PerlIO_setlinebuf(Perl_debug_log);
    if (PL_main_root)
	op_dump(PL_main_root);
    dump_packsubs_perl(PL_defstash, justperl);
}

/*
=for apidoc dump_packsubs

Dumps the optrees for all visible subroutines in C<stash>.

=cut
*/

void
Perl_dump_packsubs(pTHX_ const HV *stash)
{
    PERL_ARGS_ASSERT_DUMP_PACKSUBS;
    dump_packsubs_perl(stash, FALSE);
}

void
Perl_dump_packsubs_perl(pTHX_ const HV *stash, bool justperl)
{
    I32	i;

    PERL_ARGS_ASSERT_DUMP_PACKSUBS_PERL;

    if (!HvARRAY(stash))
	return;
    for (i = 0; i <= (I32) HvMAX(stash); i++) {
        const HE *entry;
	for (entry = HvARRAY(stash)[i]; entry; entry = HeNEXT(entry)) {
	    GV * gv = (GV *)HeVAL(entry);
            if (SvROK(gv) && SvTYPE(SvRV(gv)) == SVt_PVCV)
                /* unfake a fake GV */
                (void)CvGV(SvRV(gv));
	    if (SvTYPE(gv) != SVt_PVGV || !GvGP(gv))
		continue;
	    if (GvCVu(gv))
		dump_sub_perl(gv, justperl);
	    if (GvFORM(gv))
		dump_form(gv);
	    if (HeKEY(entry)[HeKLEN(entry)-1] == ':') {
		const HV * const hv = GvHV(gv);
		if (hv && (hv != PL_defstash))
		    dump_packsubs_perl(hv, justperl); /* nested package */
	    }
	}
    }
}

void
Perl_dump_sub(pTHX_ const GV *gv)
{
    PERL_ARGS_ASSERT_DUMP_SUB;
    dump_sub_perl(gv, FALSE);
}

void
Perl_dump_sub_perl(pTHX_ const GV *gv, bool justperl)
{
    STRLEN len;
    SV * const sv = newSVpvs_flags("", SVs_TEMP);
    SV *tmpsv;
    const char * name;

    PERL_ARGS_ASSERT_DUMP_SUB_PERL;

    if (justperl && (CvISXSUB(GvCV(gv)) || !CvROOT(GvCV(gv))))
	return;

    tmpsv = newSVpvs_flags("", SVs_TEMP);
    gv_fullname3(sv, gv, NULL);
    name = SvPV_const(sv, len);
    Perl_dump_indent(aTHX_ 0, Perl_debug_log, "\nSUB %s = ",
                     generic_pv_escape(tmpsv, name, len, SvUTF8(sv)));
    if (CvISXSUB(GvCV(gv)))
	Perl_dump_indent(aTHX_ 0, Perl_debug_log, "(xsub 0x%"UVxf" %d)\n",
	    PTR2UV(CvXSUB(GvCV(gv))),
	    (int)CvXSUBANY(GvCV(gv)).any_i32);
    else if (CvROOT(GvCV(gv)))
	op_dump(CvROOT(GvCV(gv)));
    else
	Perl_dump_indent(aTHX_ 0, Perl_debug_log, "<undef>\n");
}

void
Perl_dump_form(pTHX_ const GV *gv)
{
    SV * const sv = sv_newmortal();

    PERL_ARGS_ASSERT_DUMP_FORM;

    gv_fullname3(sv, gv, NULL);
    Perl_dump_indent(aTHX_ 0, Perl_debug_log, "\nFORMAT %s = ", SvPVX_const(sv));
    if (CvROOT(GvFORM(gv)))
	op_dump(CvROOT(GvFORM(gv)));
    else
	Perl_dump_indent(aTHX_ 0, Perl_debug_log, "<undef>\n");
}

void
Perl_dump_eval(pTHX)
{
    op_dump(PL_eval_root);
}

void
Perl_do_pmop_dump(pTHX_ I32 level, PerlIO *file, const PMOP *pm)
{
    char ch;

    PERL_ARGS_ASSERT_DO_PMOP_DUMP;

    if (!pm) {
	Perl_dump_indent(aTHX_ level, file, "{}\n");
	return;
    }
    Perl_dump_indent(aTHX_ level, file, "{\n");
    level++;
    if (pm->op_pmflags & PMf_ONCE)
	ch = '?';
    else
	ch = '/';
    if (PM_GETRE(pm))
	Perl_dump_indent(aTHX_ level, file, "PMf_PRE %c%.*s%c%s\n",
	     ch,(int)RX_PRELEN(PM_GETRE(pm)), RX_PRECOMP(PM_GETRE(pm)), ch,
	     (pm->op_private & OPpRUNTIME) ? " (RUNTIME)" : "");
    else
	Perl_dump_indent(aTHX_ level, file, "PMf_PRE (RUNTIME)\n");
    if (pm->op_type != OP_PUSHRE && pm->op_pmreplrootu.op_pmreplroot) {
	Perl_dump_indent(aTHX_ level, file, "PMf_REPL = ");
	op_dump(pm->op_pmreplrootu.op_pmreplroot);
    }
    if (pm->op_code_list) {
	if (pm->op_pmflags & PMf_CODELIST_PRIVATE) {
	    Perl_dump_indent(aTHX_ level, file, "CODE_LIST =\n");
	    do_op_dump(level, file, pm->op_code_list);
	}
	else
	    Perl_dump_indent(aTHX_ level, file, "CODE_LIST = 0x%"UVxf"\n",
				    PTR2UV(pm->op_code_list));
    }
    if (pm->op_pmflags || (PM_GETRE(pm) && RX_CHECK_SUBSTR(PM_GETRE(pm)))) {
	SV * const tmpsv = pm_description(pm);
	Perl_dump_indent(aTHX_ level, file, "PMFLAGS = (%s)\n", SvCUR(tmpsv) ? SvPVX_const(tmpsv) + 1 : "");
	SvREFCNT_dec_NN(tmpsv);
    }

    Perl_dump_indent(aTHX_ level-1, file, "}\n");
}

const struct flag_to_name pmflags_flags_names[] = {
    {PMf_CONST, ",CONST"},
    {PMf_KEEP, ",KEEP"},
    {PMf_GLOBAL, ",GLOBAL"},
    {PMf_CONTINUE, ",CONTINUE"},
    {PMf_RETAINT, ",RETAINT"},
    {PMf_EVAL, ",EVAL"},
    {PMf_NONDESTRUCT, ",NONDESTRUCT"},
    {PMf_HAS_CV, ",HAS_CV"},
    {PMf_CODELIST_PRIVATE, ",CODELIST_PRIVATE"},
    {PMf_IS_QR, ",IS_QR"}
};

static SV *
S_pm_description(pTHX_ const PMOP *pm)
{
    SV * const desc = newSVpvs("");
    const REGEXP * const regex = PM_GETRE(pm);
    const U32 pmflags = pm->op_pmflags;

    PERL_ARGS_ASSERT_PM_DESCRIPTION;

    if (pmflags & PMf_ONCE)
	sv_catpv(desc, ",ONCE");
#ifdef USE_ITHREADS
    if (SvREADONLY(PL_regex_pad[pm->op_pmoffset]))
        sv_catpv(desc, ":USED");
#else
    if (pmflags & PMf_USED)
        sv_catpv(desc, ":USED");
#endif

    if (regex) {
        if (RX_ISTAINTED(regex))
            sv_catpv(desc, ",TAINTED");
        if (RX_CHECK_SUBSTR(regex)) {
            if (!(RX_INTFLAGS(regex) & PREGf_NOSCAN))
                sv_catpv(desc, ",SCANFIRST");
            if (RX_EXTFLAGS(regex) & RXf_CHECK_ALL)
                sv_catpv(desc, ",ALL");
        }
        if (RX_EXTFLAGS(regex) & RXf_SKIPWHITE)
            sv_catpv(desc, ",SKIPWHITE");
    }

    append_flags(desc, pmflags, pmflags_flags_names);
    return desc;
}

void
Perl_pmop_dump(pTHX_ PMOP *pm)
{
    do_pmop_dump(0, Perl_debug_log, pm);
}

/* Return a unique integer to represent the address of op o.
 * If it already exists in PL_op_sequence, just return it;
 * otherwise add it.
 *  *** Note that this isn't thread-safe */

STATIC UV
S_sequence_num(pTHX_ const OP *o)
{
    dVAR;
    SV     *op,
          **seq;
    const char *key;
    STRLEN  len;
    if (!o)
	return 0;
    op = newSVuv(PTR2UV(o));
    sv_2mortal(op);
    key = SvPV_const(op, len);
    if (!PL_op_sequence)
	PL_op_sequence = newHV();
    seq = hv_fetch(PL_op_sequence, key, len, 0);
    if (seq)
	return SvUV(*seq);
    (void)hv_store(PL_op_sequence, key, len, newSVuv(++PL_op_seq), 0);
    return PL_op_seq;
}





const struct flag_to_name op_flags_names[] = {
    {OPf_KIDS, ",KIDS"},
    {OPf_PARENS, ",PARENS"},
    {OPf_REF, ",REF"},
    {OPf_MOD, ",MOD"},
    {OPf_STACKED, ",STACKED"},
    {OPf_SPECIAL, ",SPECIAL"}
};


void
Perl_do_op_dump(pTHX_ I32 level, PerlIO *file, const OP *o)
{
    UV      seq;
    const OPCODE optype = o->op_type;

    PERL_ARGS_ASSERT_DO_OP_DUMP;

    Perl_dump_indent(aTHX_ level, file, "{\n");
    level++;
    seq = sequence_num(o);
    if (seq)
	PerlIO_printf(file, "%-4"UVuf, seq);
    else
	PerlIO_printf(file, "????");
    PerlIO_printf(file,
		  "%*sTYPE = %s  ===> ",
		  (int)(PL_dumpindent*level-4), "", OP_NAME(o));
    if (o->op_next)
	PerlIO_printf(file,
			o->op_type == OP_NULL ? "(%"UVuf")\n" : "%"UVuf"\n",
				sequence_num(o->op_next));
    else
	PerlIO_printf(file, "NULL\n");
    if (o->op_targ) {
	if (optype == OP_NULL) {
	    Perl_dump_indent(aTHX_ level, file, "  (was %s)\n", PL_op_name[o->op_targ]);
	}
	else
	    Perl_dump_indent(aTHX_ level, file, "TARG = %ld\n", (long)o->op_targ);
    }
#ifdef DUMPADDR
    Perl_dump_indent(aTHX_ level, file, "ADDR = 0x%"UVxf" => 0x%"UVxf"\n", (UV)o, (UV)o->op_next);
#endif

    if (o->op_flags || o->op_slabbed || o->op_savefree || o->op_static) {
        SV * const tmpsv = newSVpvs("");
        switch (o->op_flags & OPf_WANT) {
        case OPf_WANT_VOID:
            sv_catpv(tmpsv, ",VOID");
            break;
        case OPf_WANT_SCALAR:
            sv_catpv(tmpsv, ",SCALAR");
            break;
        case OPf_WANT_LIST:
            sv_catpv(tmpsv, ",LIST");
            break;
        default:
            sv_catpv(tmpsv, ",UNKNOWN");
            break;
        }
        append_flags(tmpsv, o->op_flags, op_flags_names);
        if (o->op_slabbed)  sv_catpvs(tmpsv, ",SLABBED");
        if (o->op_savefree) sv_catpvs(tmpsv, ",SAVEFREE");
        if (o->op_static)   sv_catpvs(tmpsv, ",STATIC");
        if (o->op_folded)   sv_catpvs(tmpsv, ",FOLDED");
        if (o->op_moresib)  sv_catpvs(tmpsv, ",MORESIB");
        Perl_dump_indent(aTHX_ level, file, "FLAGS = (%s)\n",
                         SvCUR(tmpsv) ? SvPVX_const(tmpsv) + 1 : "");
    }

    if (o->op_private) {
        U16 oppriv = o->op_private;
        I16 op_ix = PL_op_private_bitdef_ix[o->op_type];
        SV * tmpsv = NULL;

        if (op_ix != -1) {
            U16 stop = 0;
            tmpsv = newSVpvs("");
            for (; !stop; op_ix++) {
                U16 entry = PL_op_private_bitdefs[op_ix];
                U16 bit = (entry >> 2) & 7;
                U16 ix = entry >> 5;

                stop = (entry & 1);

                if (entry & 2) {
                    /* bitfield */
                    I16 const *p = &PL_op_private_bitfields[ix];
                    U16 bitmin = (U16) *p++;
                    I16 label = *p++;
                    I16 enum_label;
                    U16 mask = 0;
                    U16 i;
                    U16 val;

                    for (i = bitmin; i<= bit; i++)
                        mask |= (1<<i);
                    bit = bitmin;
                    val = (oppriv & mask);

                    if (   label != -1
                        && PL_op_private_labels[label] == '-'
                        && PL_op_private_labels[label+1] == '\0'
                    )
                        /* display as raw number */
                        continue;

                    oppriv -= val;
                    val >>= bit;
                    enum_label = -1;
                    while (*p != -1) {
                        if (val == *p++) {
                            enum_label = *p;
                            break;
                        }
                        p++;
                    }
                    if (val == 0 && enum_label == -1)
                        /* don't display anonymous zero values */
                        continue;

                    sv_catpv(tmpsv, ",");
                    if (label != -1) {
                        sv_catpv(tmpsv, &PL_op_private_labels[label]);
                        sv_catpv(tmpsv, "=");
                    }
                    if (enum_label == -1)
                        Perl_sv_catpvf(aTHX_ tmpsv, "0x%"UVxf, (UV)val);
                    else
                        sv_catpv(tmpsv, &PL_op_private_labels[enum_label]);

                }
                else {
                    /* bit flag */
                    if (   oppriv & (1<<bit)
                        && !(PL_op_private_labels[ix] == '-'
                             && PL_op_private_labels[ix+1] == '\0'))
                    {
                        oppriv -= (1<<bit);
                        sv_catpv(tmpsv, ",");
                        sv_catpv(tmpsv, &PL_op_private_labels[ix]);
                    }
                }
            }
            if (oppriv) {
                sv_catpv(tmpsv, ",");
                Perl_sv_catpvf(aTHX_ tmpsv, "0x%"UVxf, (UV)oppriv);
            }
        }
	if (tmpsv && SvCUR(tmpsv)) {
            Perl_dump_indent(aTHX_ level, file, "PRIVATE = (%s)\n", SvPVX_const(tmpsv) + 1);
	} else
            Perl_dump_indent(aTHX_ level, file, "PRIVATE = (0x%"UVxf")\n",
                             (UV)oppriv);
    }

    switch (optype) {
    case OP_AELEMFAST:
    case OP_GVSV:
    case OP_GV:
#ifdef USE_ITHREADS
	Perl_dump_indent(aTHX_ level, file, "PADIX = %" IVdf "\n", (IV)cPADOPo->op_padix);
#else
	if ( ! (o->op_flags & OPf_SPECIAL)) { /* not lexical */
	    if (cSVOPo->op_sv) {
      STRLEN len;
      const char * name;
      SV * const tmpsv  = newSVpvs_flags("", SVs_TEMP);
      SV * const tmpsv2 = newSVpvs_flags("", SVs_TEMP);
		gv_fullname3(tmpsv, MUTABLE_GV(cSVOPo->op_sv), NULL);
      name = SvPV_const(tmpsv, len);
		Perl_dump_indent(aTHX_ level, file, "GV = %s\n",
                       generic_pv_escape( tmpsv2, name, len, SvUTF8(tmpsv)));
	    }
	    else
		Perl_dump_indent(aTHX_ level, file, "GV = NULL\n");
	}
#endif
	break;

    case OP_MULTIDEREF:
    {
        UNOP_AUX_item *items = cUNOP_AUXo->op_aux;
        UV i, count = items[-1].uv;

	Perl_dump_indent(aTHX_ level, file, "ARGS = \n");
        for (i=0; i < count;  i++)
            Perl_dump_indent(aTHX_ level+1, file, "%"UVuf" => 0x%"UVxf"\n",
                                    i, items[i].uv);
	break;
    }

    case OP_CONST:
    case OP_HINTSEVAL:
    case OP_METHOD_NAMED:
    case OP_METHOD_SUPER:
    case OP_METHOD_REDIR:
    case OP_METHOD_REDIR_SUPER:
#ifndef USE_ITHREADS
	/* with ITHREADS, consts are stored in the pad, and the right pad
	 * may not be active here, so skip */
	Perl_dump_indent(aTHX_ level, file, "SV = %s\n", SvPEEK(cMETHOPx_meth(o)));
#endif
	break;
    case OP_NULL:
	if (o->op_targ != OP_NEXTSTATE && o->op_targ != OP_DBSTATE)
	    break;
	/* FALLTHROUGH */
    case OP_NEXTSTATE:
    case OP_DBSTATE:
	if (CopLINE(cCOPo))
	    Perl_dump_indent(aTHX_ level, file, "LINE = %"UVuf"\n",
			     (UV)CopLINE(cCOPo));
    if (CopSTASHPV(cCOPo)) {
        SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
        HV *stash = CopSTASH(cCOPo);
        const char * const hvname = HvNAME_get(stash);
        
	    Perl_dump_indent(aTHX_ level, file, "PACKAGE = \"%s\"\n",
                           generic_pv_escape(tmpsv, hvname,
                              HvNAMELEN(stash), HvNAMEUTF8(stash)));
    }
  if (CopLABEL(cCOPo)) {
       SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
       STRLEN label_len;
       U32 label_flags;
       const char *label = CopLABEL_len_flags(cCOPo,
                                                &label_len, &label_flags);
       Perl_dump_indent(aTHX_ level, file, "LABEL = \"%s\"\n",
                           generic_pv_escape( tmpsv, label, label_len,
                                      (label_flags & SVf_UTF8)));
   }
        Perl_dump_indent(aTHX_ level, file, "SEQ = %u\n",
                         (unsigned int)cCOPo->cop_seq);
	break;
    case OP_ENTERLOOP:
	Perl_dump_indent(aTHX_ level, file, "REDO ===> ");
	if (cLOOPo->op_redoop)
	    PerlIO_printf(file, "%"UVuf"\n", sequence_num(cLOOPo->op_redoop));
	else
	    PerlIO_printf(file, "DONE\n");
	Perl_dump_indent(aTHX_ level, file, "NEXT ===> ");
	if (cLOOPo->op_nextop)
	    PerlIO_printf(file, "%"UVuf"\n", sequence_num(cLOOPo->op_nextop));
	else
	    PerlIO_printf(file, "DONE\n");
	Perl_dump_indent(aTHX_ level, file, "LAST ===> ");
	if (cLOOPo->op_lastop)
	    PerlIO_printf(file, "%"UVuf"\n", sequence_num(cLOOPo->op_lastop));
	else
	    PerlIO_printf(file, "DONE\n");
	break;
    case OP_COND_EXPR:
    case OP_RANGE:
    case OP_MAPWHILE:
    case OP_GREPWHILE:
    case OP_OR:
    case OP_AND:
	Perl_dump_indent(aTHX_ level, file, "OTHER ===> ");
	if (cLOGOPo->op_other)
	    PerlIO_printf(file, "%"UVuf"\n", sequence_num(cLOGOPo->op_other));
	else
	    PerlIO_printf(file, "DONE\n");
	break;
    case OP_PUSHRE:
    case OP_MATCH:
    case OP_QR:
    case OP_SUBST:
	do_pmop_dump(level, file, cPMOPo);
	break;
    case OP_LEAVE:
    case OP_LEAVEEVAL:
    case OP_LEAVESUB:
    case OP_LEAVESUBLV:
    case OP_LEAVEWRITE:
    case OP_SCOPE:
	if (o->op_private & OPpREFCOUNTED)
	    Perl_dump_indent(aTHX_ level, file, "REFCNT = %"UVuf"\n", (UV)o->op_targ);
	break;
    default:
	break;
    }
    if (o->op_flags & OPf_KIDS) {
	OP *kid;
	for (kid = cUNOPo->op_first; kid; kid = OpSIBLING(kid))
	    do_op_dump(level, file, kid);
    }
    Perl_dump_indent(aTHX_ level-1, file, "}\n");
}

/*
=for apidoc op_dump

Dumps the optree starting at OP C<o> to C<STDERR>.

=cut
*/

void
Perl_op_dump(pTHX_ const OP *o)
{
    PERL_ARGS_ASSERT_OP_DUMP;
    do_op_dump(0, Perl_debug_log, o);
}

void
Perl_gv_dump(pTHX_ GV *gv)
{
    STRLEN len;
    const char* name;
    SV *sv, *tmp = newSVpvs_flags("", SVs_TEMP);

    if (!gv) {
	PerlIO_printf(Perl_debug_log, "{}\n");
	return;
    }
    sv = sv_newmortal();
    PerlIO_printf(Perl_debug_log, "{\n");
    gv_fullname3(sv, gv, NULL);
    name = SvPV_const(sv, len);
    Perl_dump_indent(aTHX_ 1, Perl_debug_log, "GV_NAME = %s",
                     generic_pv_escape( tmp, name, len, SvUTF8(sv) ));
    if (gv != GvEGV(gv)) {
	gv_efullname3(sv, GvEGV(gv), NULL);
        name = SvPV_const(sv, len);
        Perl_dump_indent(aTHX_ 1, Perl_debug_log, "-> %s",
                     generic_pv_escape( tmp, name, len, SvUTF8(sv) ));
    }
    (void)PerlIO_putc(Perl_debug_log, '\n');
    Perl_dump_indent(aTHX_ 0, Perl_debug_log, "}\n");
}


/* map magic types to the symbolic names
 * (with the PERL_MAGIC_ prefixed stripped)
 */

static const struct { const char type; const char *name; } magic_names[] = {
#include "mg_names.inc"
	/* this null string terminates the list */
	{ 0,                         NULL },
};

void
Perl_do_magic_dump(pTHX_ I32 level, PerlIO *file, const MAGIC *mg, I32 nest, I32 maxnest, bool dumpops, STRLEN pvlim)
{
    PERL_ARGS_ASSERT_DO_MAGIC_DUMP;

    for (; mg; mg = mg->mg_moremagic) {
 	Perl_dump_indent(aTHX_ level, file,
			 "  MAGIC = 0x%"UVxf"\n", PTR2UV(mg));
 	if (mg->mg_virtual) {
            const MGVTBL * const v = mg->mg_virtual;
	    if (v >= PL_magic_vtables
		&& v < PL_magic_vtables + magic_vtable_max) {
		const U32 i = v - PL_magic_vtables;
	        Perl_dump_indent(aTHX_ level, file, "    MG_VIRTUAL = &PL_vtbl_%s\n", PL_magic_vtable_names[i]);
	    }
	    else
	        Perl_dump_indent(aTHX_ level, file, "    MG_VIRTUAL = 0x%"UVxf"\n", PTR2UV(v));
        }
	else
	    Perl_dump_indent(aTHX_ level, file, "    MG_VIRTUAL = 0\n");

	if (mg->mg_private)
	    Perl_dump_indent(aTHX_ level, file, "    MG_PRIVATE = %d\n", mg->mg_private);

	{
	    int n;
	    const char *name = NULL;
	    for (n = 0; magic_names[n].name; n++) {
		if (mg->mg_type == magic_names[n].type) {
		    name = magic_names[n].name;
		    break;
		}
	    }
	    if (name)
		Perl_dump_indent(aTHX_ level, file,
				"    MG_TYPE = PERL_MAGIC_%s\n", name);
	    else
		Perl_dump_indent(aTHX_ level, file,
				"    MG_TYPE = UNKNOWN(\\%o)\n", mg->mg_type);
	}

        if (mg->mg_flags) {
            Perl_dump_indent(aTHX_ level, file, "    MG_FLAGS = 0x%02X\n", mg->mg_flags);
	    if (mg->mg_type == PERL_MAGIC_envelem &&
		mg->mg_flags & MGf_TAINTEDDIR)
	        Perl_dump_indent(aTHX_ level, file, "      TAINTEDDIR\n");
	    if (mg->mg_type == PERL_MAGIC_regex_global &&
		mg->mg_flags & MGf_MINMATCH)
	        Perl_dump_indent(aTHX_ level, file, "      MINMATCH\n");
	    if (mg->mg_flags & MGf_REFCOUNTED)
	        Perl_dump_indent(aTHX_ level, file, "      REFCOUNTED\n");
            if (mg->mg_flags & MGf_GSKIP)
	        Perl_dump_indent(aTHX_ level, file, "      GSKIP\n");
	    if (mg->mg_flags & MGf_COPY)
	        Perl_dump_indent(aTHX_ level, file, "      COPY\n");
	    if (mg->mg_flags & MGf_DUP)
	        Perl_dump_indent(aTHX_ level, file, "      DUP\n");
	    if (mg->mg_flags & MGf_LOCAL)
	        Perl_dump_indent(aTHX_ level, file, "      LOCAL\n");
	    if (mg->mg_type == PERL_MAGIC_regex_global &&
		mg->mg_flags & MGf_BYTES)
	        Perl_dump_indent(aTHX_ level, file, "      BYTES\n");
        }
	if (mg->mg_obj) {
	    Perl_dump_indent(aTHX_ level, file, "    MG_OBJ = 0x%"UVxf"\n",
	        PTR2UV(mg->mg_obj));
            if (mg->mg_type == PERL_MAGIC_qr) {
		REGEXP* const re = (REGEXP *)mg->mg_obj;
		SV * const dsv = sv_newmortal();
                const char * const s
		    = pv_pretty(dsv, RX_WRAPPED(re), RX_WRAPLEN(re),
                    60, NULL, NULL,
                    ( PERL_PV_PRETTY_QUOTE | PERL_PV_ESCAPE_RE | PERL_PV_PRETTY_ELLIPSES |
                    (RX_UTF8(re) ? PERL_PV_ESCAPE_UNI : 0))
                );
		Perl_dump_indent(aTHX_ level+1, file, "    PAT = %s\n", s);
		Perl_dump_indent(aTHX_ level+1, file, "    REFCNT = %"IVdf"\n",
			(IV)RX_REFCNT(re));
            }
            if (mg->mg_flags & MGf_REFCOUNTED)
		do_sv_dump(level+2, file, mg->mg_obj, nest+1, maxnest, dumpops, pvlim); /* MG is already +1 */
	}
        if (mg->mg_len)
	    Perl_dump_indent(aTHX_ level, file, "    MG_LEN = %ld\n", (long)mg->mg_len);
        if (mg->mg_ptr) {
	    Perl_dump_indent(aTHX_ level, file, "    MG_PTR = 0x%"UVxf, PTR2UV(mg->mg_ptr));
	    if (mg->mg_len >= 0) {
		if (mg->mg_type != PERL_MAGIC_utf8) {
		    SV * const sv = newSVpvs("");
		    PerlIO_printf(file, " %s", pv_display(sv, mg->mg_ptr, mg->mg_len, 0, pvlim));
		    SvREFCNT_dec_NN(sv);
		}
            }
	    else if (mg->mg_len == HEf_SVKEY) {
		PerlIO_puts(file, " => HEf_SVKEY\n");
		do_sv_dump(level+2, file, MUTABLE_SV(((mg)->mg_ptr)), nest+1,
			   maxnest, dumpops, pvlim); /* MG is already +1 */
		continue;
	    }
	    else if (mg->mg_len == -1 && mg->mg_type == PERL_MAGIC_utf8);
	    else
		PerlIO_puts(
		  file,
		 " ???? - " __FILE__
		 " does not know how to handle this MG_LEN"
		);
            (void)PerlIO_putc(file, '\n');
        }
	if (mg->mg_type == PERL_MAGIC_utf8) {
	    const STRLEN * const cache = (STRLEN *) mg->mg_ptr;
	    if (cache) {
		IV i;
		for (i = 0; i < PERL_MAGIC_UTF8_CACHESIZE; i++)
		    Perl_dump_indent(aTHX_ level, file,
				     "      %2"IVdf": %"UVuf" -> %"UVuf"\n",
				     i,
				     (UV)cache[i * 2],
				     (UV)cache[i * 2 + 1]);
	    }
	}
    }
}

void
Perl_magic_dump(pTHX_ const MAGIC *mg)
{
    do_magic_dump(0, Perl_debug_log, mg, 0, 0, FALSE, 0);
}

void
Perl_do_hv_dump(pTHX_ I32 level, PerlIO *file, const char *name, HV *sv)
{
    const char *hvname;

    PERL_ARGS_ASSERT_DO_HV_DUMP;

    Perl_dump_indent(aTHX_ level, file, "%s = 0x%"UVxf, name, PTR2UV(sv));
    if (sv && (hvname = HvNAME_get(sv)))
    {
	/* we have to use pv_display and HvNAMELEN_get() so that we display the real package
           name which quite legally could contain insane things like tabs, newlines, nulls or
           other scary crap - this should produce sane results - except maybe for unicode package
           names - but we will wait for someone to file a bug on that - demerphq */
        SV * const tmpsv = newSVpvs_flags("", SVs_TEMP);
        PerlIO_printf(file, "\t\"%s\"\n",
                              generic_pv_escape( tmpsv, hvname,
                                   HvNAMELEN(sv), HvNAMEUTF8(sv)));
    }
    else
        (void)PerlIO_putc(file, '\n');
}

void
Perl_do_gv_dump(pTHX_ I32 level, PerlIO *file, const char *name, GV *sv)
{
    PERL_ARGS_ASSERT_DO_GV_DUMP;

    Perl_dump_indent(aTHX_ level, file, "%s = 0x%"UVxf, name, PTR2UV(sv));
    if (sv && GvNAME(sv)) {
        SV * const tmpsv = newSVpvs("");
        PerlIO_printf(file, "\t\"%s\"\n",
                              generic_pv_escape( tmpsv, GvNAME(sv), GvNAMELEN(sv), GvNAMEUTF8(sv) ));
    }
    else
        (void)PerlIO_putc(file, '\n');
}

void
Perl_do_gvgv_dump(pTHX_ I32 level, PerlIO *file, const char *name, GV *sv)
{
    PERL_ARGS_ASSERT_DO_GVGV_DUMP;

    Perl_dump_indent(aTHX_ level, file, "%s = 0x%"UVxf, name, PTR2UV(sv));
    if (sv && GvNAME(sv)) {
       SV *tmp = newSVpvs_flags("", SVs_TEMP);
	const char *hvname;
        HV * const stash = GvSTASH(sv);
	PerlIO_printf(file, "\t");
   /* TODO might have an extra \" here */
	if (stash && (hvname = HvNAME_get(stash))) {
            PerlIO_printf(file, "\"%s\" :: \"",
                                  generic_pv_escape(tmp, hvname,
                                      HvNAMELEN(stash), HvNAMEUTF8(stash)));
        }
        PerlIO_printf(file, "%s\"\n",
                              generic_pv_escape( tmp, GvNAME(sv), GvNAMELEN(sv), GvNAMEUTF8(sv)));
    }
    else
        (void)PerlIO_putc(file, '\n');
}

const struct flag_to_name first_sv_flags_names[] = {
    {SVs_TEMP, "TEMP,"},
    {SVs_OBJECT, "OBJECT,"},
    {SVs_GMG, "GMG,"},
    {SVs_SMG, "SMG,"},
    {SVs_RMG, "RMG,"},
    {SVf_IOK, "IOK,"},
    {SVf_NOK, "NOK,"},
    {SVf_POK, "POK,"}
};

const struct flag_to_name second_sv_flags_names[] = {
    {SVf_OOK, "OOK,"},
    {SVf_FAKE, "FAKE,"},
    {SVf_READONLY, "READONLY,"},
    {SVf_PROTECT, "PROTECT,"},
    {SVf_BREAK, "BREAK,"},
    {SVp_IOK, "pIOK,"},
    {SVp_NOK, "pNOK,"},
    {SVp_POK, "pPOK,"}
};

const struct flag_to_name cv_flags_names[] = {
    {CVf_ANON, "ANON,"},
    {CVf_UNIQUE, "UNIQUE,"},
    {CVf_CLONE, "CLONE,"},
    {CVf_CLONED, "CLONED,"},
    {CVf_CONST, "CONST,"},
    {CVf_NODEBUG, "NODEBUG,"},
    {CVf_LVALUE, "LVALUE,"},
    {CVf_METHOD, "METHOD,"},
    {CVf_WEAKOUTSIDE, "WEAKOUTSIDE,"},
    {CVf_CVGV_RC, "CVGV_RC,"},
    {CVf_DYNFILE, "DYNFILE,"},
    {CVf_AUTOLOAD, "AUTOLOAD,"},
    {CVf_HASEVAL, "HASEVAL,"},
    {CVf_SLABBED, "SLABBED,"},
    {CVf_NAMED, "NAMED,"},
    {CVf_LEXICAL, "LEXICAL,"},
    {CVf_ISXSUB, "ISXSUB,"}
};

const struct flag_to_name hv_flags_names[] = {
    {SVphv_SHAREKEYS, "SHAREKEYS,"},
    {SVphv_LAZYDEL, "LAZYDEL,"},
    {SVphv_HASKFLAGS, "HASKFLAGS,"},
    {SVf_AMAGIC, "OVERLOAD,"},
    {SVphv_CLONEABLE, "CLONEABLE,"}
};

const struct flag_to_name gp_flags_names[] = {
    {GVf_INTRO, "INTRO,"},
    {GVf_MULTI, "MULTI,"},
    {GVf_ASSUMECV, "ASSUMECV,"},
};

const struct flag_to_name gp_flags_imported_names[] = {
    {GVf_IMPORTED_SV, " SV"},
    {GVf_IMPORTED_AV, " AV"},
    {GVf_IMPORTED_HV, " HV"},
    {GVf_IMPORTED_CV, " CV"},
};

/* NOTE: this structure is mostly duplicative of one generated by
 * 'make regen' in regnodes.h - perhaps we should somehow integrate
 * the two. - Yves */
const struct flag_to_name regexp_extflags_names[] = {
    {RXf_PMf_MULTILINE,   "PMf_MULTILINE,"},
    {RXf_PMf_SINGLELINE,  "PMf_SINGLELINE,"},
    {RXf_PMf_FOLD,        "PMf_FOLD,"},
    {RXf_PMf_EXTENDED,    "PMf_EXTENDED,"},
    {RXf_PMf_EXTENDED_MORE, "PMf_EXTENDED_MORE,"},
    {RXf_PMf_KEEPCOPY,    "PMf_KEEPCOPY,"},
    {RXf_PMf_NOCAPTURE,   "PMf_NOCAPURE,"},
    {RXf_IS_ANCHORED,     "IS_ANCHORED,"},
    {RXf_NO_INPLACE_SUBST, "NO_INPLACE_SUBST,"},
    {RXf_EVAL_SEEN,       "EVAL_SEEN,"},
    {RXf_CHECK_ALL,       "CHECK_ALL,"},
    {RXf_MATCH_UTF8,      "MATCH_UTF8,"},
    {RXf_USE_INTUIT_NOML, "USE_INTUIT_NOML,"},
    {RXf_USE_INTUIT_ML,   "USE_INTUIT_ML,"},
    {RXf_INTUIT_TAIL,     "INTUIT_TAIL,"},
    {RXf_SPLIT,           "SPLIT,"},
    {RXf_COPY_DONE,       "COPY_DONE,"},
    {RXf_TAINTED_SEEN,    "TAINTED_SEEN,"},
    {RXf_TAINTED,         "TAINTED,"},
    {RXf_START_ONLY,      "START_ONLY,"},
    {RXf_SKIPWHITE,       "SKIPWHITE,"},
    {RXf_WHITE,           "WHITE,"},
    {RXf_NULL,            "NULL,"},
};

/* NOTE: this structure is mostly duplicative of one generated by
 * 'make regen' in regnodes.h - perhaps we should somehow integrate
 * the two. - Yves */
const struct flag_to_name regexp_core_intflags_names[] = {
    {PREGf_SKIP,            "SKIP,"},
    {PREGf_IMPLICIT,        "IMPLICIT,"},
    {PREGf_NAUGHTY,         "NAUGHTY,"},
    {PREGf_VERBARG_SEEN,    "VERBARG_SEEN,"},
    {PREGf_CUTGROUP_SEEN,   "CUTGROUP_SEEN,"},
    {PREGf_USE_RE_EVAL,     "USE_RE_EVAL,"},
    {PREGf_NOSCAN,          "NOSCAN,"},
    {PREGf_GPOS_SEEN,       "GPOS_SEEN,"},
    {PREGf_GPOS_FLOAT,      "GPOS_FLOAT,"},
    {PREGf_ANCH_MBOL,       "ANCH_MBOL,"},
    {PREGf_ANCH_SBOL,       "ANCH_SBOL,"},
    {PREGf_ANCH_GPOS,       "ANCH_GPOS,"},
};

/* Perl_do_sv_dump():
 *
 * level:   amount to indent the output
 * sv:      the object to dump
 * nest:    the current level of recursion
 * maxnest: the maximum allowed level of recursion
 * dumpops: if true, also dump the ops associated with a CV
 * pvlim:   limit on the length of any strings that are output
 * */

void
Perl_do_sv_dump(pTHX_ I32 level, PerlIO *file, SV *sv, I32 nest, I32 maxnest, bool dumpops, STRLEN pvlim)
{
    SV *d;
    const char *s;
    U32 flags;
    U32 type;

    PERL_ARGS_ASSERT_DO_SV_DUMP;

    if (!sv) {
	Perl_dump_indent(aTHX_ level, file, "SV = 0\n");
	return;
    }

    flags = SvFLAGS(sv);
    type = SvTYPE(sv);

    /* process general SV flags */

    d = Perl_newSVpvf(aTHX_
		   "(0x%"UVxf") at 0x%"UVxf"\n%*s  REFCNT = %"IVdf"\n%*s  FLAGS = (",
		   PTR2UV(SvANY(sv)), PTR2UV(sv),
		   (int)(PL_dumpindent*level), "", (IV)SvREFCNT(sv),
		   (int)(PL_dumpindent*level), "");

    if ((flags & SVs_PADSTALE))
	    sv_catpv(d, "PADSTALE,");
    if ((flags & SVs_PADTMP))
	    sv_catpv(d, "PADTMP,");
    append_flags(d, flags, first_sv_flags_names);
    if (flags & SVf_ROK)  {	
    				sv_catpv(d, "ROK,");
	if (SvWEAKREF(sv))	sv_catpv(d, "WEAKREF,");
    }
    if (flags & SVf_IsCOW && type != SVt_PVHV) sv_catpvs(d, "IsCOW,");
    append_flags(d, flags, second_sv_flags_names);
    if (flags & SVp_SCREAM && type != SVt_PVHV && !isGV_with_GP(sv)
			   && type != SVt_PVAV) {
	if (SvPCS_IMPORTED(sv))
				sv_catpv(d, "PCS_IMPORTED,");
	else
				sv_catpv(d, "SCREAM,");
    }

    /* process type-specific SV flags */

    switch (type) {
    case SVt_PVCV:
    case SVt_PVFM:
	append_flags(d, CvFLAGS(sv), cv_flags_names);
	break;
    case SVt_PVHV:
	append_flags(d, flags, hv_flags_names);
	break;
    case SVt_PVGV:
    case SVt_PVLV:
	if (isGV_with_GP(sv)) {
	    append_flags(d, GvFLAGS(sv), gp_flags_names);
	}
	if (isGV_with_GP(sv) && GvIMPORTED(sv)) {
	    sv_catpv(d, "IMPORT");
	    if (GvIMPORTED(sv) == GVf_IMPORTED)
		sv_catpv(d, "ALL,");
	    else {
		sv_catpv(d, "(");
		append_flags(d, GvFLAGS(sv), gp_flags_imported_names);
		sv_catpv(d, " ),");
	    }
	}
	/* FALLTHROUGH */
    default:
    evaled_or_uv:
	if (SvEVALED(sv))	sv_catpv(d, "EVALED,");
	if (SvIsUV(sv) && !(flags & SVf_ROK))	sv_catpv(d, "IsUV,");
	break;
    case SVt_PVMG:
	if (SvTAIL(sv))		sv_catpv(d, "TAIL,");
	if (SvVALID(sv))	sv_catpv(d, "VALID,");
	/* FALLTHROUGH */
	goto evaled_or_uv;
    case SVt_PVAV:
	break;
    }
    /* SVphv_SHAREKEYS is also 0x20000000 */
    if ((type != SVt_PVHV) && SvUTF8(sv))
        sv_catpv(d, "UTF8");

    if (*(SvEND(d) - 1) == ',') {
        SvCUR_set(d, SvCUR(d) - 1);
	SvPVX(d)[SvCUR(d)] = '\0';
    }
    sv_catpv(d, ")");
    s = SvPVX_const(d);

    /* dump initial SV details */

#ifdef DEBUG_LEAKING_SCALARS
    Perl_dump_indent(aTHX_ level, file,
	"ALLOCATED at %s:%d %s %s (parent 0x%"UVxf"); serial %"UVuf"\n",
	sv->sv_debug_file ? sv->sv_debug_file : "(unknown)",
	sv->sv_debug_line,
	sv->sv_debug_inpad ? "for" : "by",
	sv->sv_debug_optype ? PL_op_name[sv->sv_debug_optype]: "(none)",
	PTR2UV(sv->sv_debug_parent),
	sv->sv_debug_serial
    );
#endif
    Perl_dump_indent(aTHX_ level, file, "SV = ");

    /* Dump SV type */

    if (type < SVt_LAST) {
	PerlIO_printf(file, "%s%s\n", svtypenames[type], s);

	if (type ==  SVt_NULL) {
	    SvREFCNT_dec_NN(d);
	    return;
	}
    } else {
	PerlIO_printf(file, "UNKNOWN(0x%"UVxf") %s\n", (UV)type, s);
	SvREFCNT_dec_NN(d);
	return;
    }

    /* Dump general SV fields */

    if ((type >= SVt_PVIV && type != SVt_PVAV && type != SVt_PVHV
	 && type != SVt_PVCV && type != SVt_PVFM && type != SVt_PVIO
	 && type != SVt_REGEXP && !isGV_with_GP(sv) && !SvVALID(sv))
	|| (type == SVt_IV && !SvROK(sv))) {
	if (SvIsUV(sv)
	                             )
	    Perl_dump_indent(aTHX_ level, file, "  UV = %"UVuf, (UV)SvUVX(sv));
	else
	    Perl_dump_indent(aTHX_ level, file, "  IV = %"IVdf, (IV)SvIVX(sv));
	(void)PerlIO_putc(file, '\n');
    }

    if ((type >= SVt_PVNV && type != SVt_PVAV && type != SVt_PVHV
		&& type != SVt_PVCV && type != SVt_PVFM  && type != SVt_REGEXP
		&& type != SVt_PVIO && !isGV_with_GP(sv) && !SvVALID(sv))
	       || type == SVt_NV) {
	STORE_LC_NUMERIC_UNDERLYING_SET_STANDARD();
	Perl_dump_indent(aTHX_ level, file, "  NV = %.*" NVgf "\n", NV_DIG, SvNVX(sv));
	RESTORE_LC_NUMERIC_UNDERLYING();
    }

    if (SvROK(sv)) {
	Perl_dump_indent(aTHX_ level, file, "  RV = 0x%"UVxf"\n", PTR2UV(SvRV(sv)));
	if (nest < maxnest)
	    do_sv_dump(level+1, file, SvRV(sv), nest+1, maxnest, dumpops, pvlim);
    }

    if (type < SVt_PV) {
	SvREFCNT_dec_NN(d);
	return;
    }

    if ((type <= SVt_PVLV && !isGV_with_GP(sv))
     || (type == SVt_PVIO && IoFLAGS(sv) & IOf_FAKE_DIRP)) {
	const bool re = isREGEXP(sv);
	const char * const ptr =
	    re ? RX_WRAPPED((REGEXP*)sv) : SvPVX_const(sv);
	if (ptr) {
	    STRLEN delta;
	    if (SvOOK(sv)) {
		SvOOK_offset(sv, delta);
		Perl_dump_indent(aTHX_ level, file,"  OFFSET = %"UVuf"\n",
				 (UV) delta);
	    } else {
		delta = 0;
	    }
	    Perl_dump_indent(aTHX_ level, file,"  PV = 0x%"UVxf" ", PTR2UV(ptr));
	    if (SvOOK(sv)) {
		PerlIO_printf(file, "( %s . ) ",
			      pv_display(d, ptr - delta, delta, 0,
					 pvlim));
	    }
            if (type == SVt_INVLIST) {
		PerlIO_printf(file, "\n");
                /* 4 blanks indents 2 beyond the PV, etc */
                _invlist_dump(file, level, "    ", sv);
            }
            else {
                PerlIO_printf(file, "%s", pv_display(d, ptr, SvCUR(sv),
                                                     re ? 0 : SvLEN(sv),
                                                     pvlim));
                if (SvUTF8(sv)) /* the 6?  \x{....} */
                    PerlIO_printf(file, " [UTF8 \"%s\"]",
                                         sv_uni_display(d, sv, 6 * SvCUR(sv),
                                                        UNI_DISPLAY_QQ));
                PerlIO_printf(file, "\n");
            }
	    Perl_dump_indent(aTHX_ level, file, "  CUR = %"IVdf"\n", (IV)SvCUR(sv));
	    if (!re)
		Perl_dump_indent(aTHX_ level, file, "  LEN = %"IVdf"\n",
				       (IV)SvLEN(sv));
#ifdef PERL_COPY_ON_WRITE
	    if (SvIsCOW(sv) && SvLEN(sv))
		Perl_dump_indent(aTHX_ level, file, "  COW_REFCNT = %d\n",
				       CowREFCNT(sv));
#endif
	}
	else
	    Perl_dump_indent(aTHX_ level, file, "  PV = 0\n");
    }

    if (type >= SVt_PVMG) {
	if (SvMAGIC(sv))
		do_magic_dump(level, file, SvMAGIC(sv), nest+1, maxnest, dumpops, pvlim);
	if (SvSTASH(sv))
	    do_hv_dump(level, file, "  STASH", SvSTASH(sv));

	if ((type == SVt_PVMG || type == SVt_PVLV) && SvVALID(sv)) {
	    Perl_dump_indent(aTHX_ level, file, "  USEFUL = %"IVdf"\n", (IV)BmUSEFUL(sv));
	}
    }

    /* Dump type-specific SV fields */

    switch (type) {
    case SVt_PVAV:
	Perl_dump_indent(aTHX_ level, file, "  ARRAY = 0x%"UVxf, PTR2UV(AvARRAY(sv)));
	if (AvARRAY(sv) != AvALLOC(sv)) {
	    PerlIO_printf(file, " (offset=%"IVdf")\n", (IV)(AvARRAY(sv) - AvALLOC(sv)));
	    Perl_dump_indent(aTHX_ level, file, "  ALLOC = 0x%"UVxf"\n", PTR2UV(AvALLOC(sv)));
	}
	else
            (void)PerlIO_putc(file, '\n');
	Perl_dump_indent(aTHX_ level, file, "  FILL = %"IVdf"\n", (IV)AvFILLp(sv));
	Perl_dump_indent(aTHX_ level, file, "  MAX = %"IVdf"\n", (IV)AvMAX(sv));
	Perl_dump_indent(aTHX_ level, file, "  ARYLEN = 0x%"UVxf"\n",
				   SvMAGIC(sv) ? PTR2UV(AvARYLEN(sv)) : 0);
	sv_setpvs(d, "");
	if (AvREAL(sv))	sv_catpv(d, ",REAL");
	if (AvREIFY(sv))	sv_catpv(d, ",REIFY");
	Perl_dump_indent(aTHX_ level, file, "  FLAGS = (%s)\n",
			 SvCUR(d) ? SvPVX_const(d) + 1 : "");
	if (nest < maxnest && av_tindex(MUTABLE_AV(sv)) >= 0) {
	    SSize_t count;
	    for (count = 0; count <=  av_tindex(MUTABLE_AV(sv)) && count < maxnest; count++) {
		SV** const elt = av_fetch(MUTABLE_AV(sv),count,0);

		Perl_dump_indent(aTHX_ level + 1, file, "Elt No. %"IVdf"\n", (IV)count);
		if (elt)
		    do_sv_dump(level+1, file, *elt, nest+1, maxnest, dumpops, pvlim);
	    }
	}
	break;
    case SVt_PVHV: {
	U32 usedkeys;
        if (SvOOK(sv)) {
            struct xpvhv_aux *const aux = HvAUX(sv);
            Perl_dump_indent(aTHX_ level, file, "  AUX_FLAGS = %"UVuf"\n",
                             (UV)aux->xhv_aux_flags);
        }
	Perl_dump_indent(aTHX_ level, file, "  ARRAY = 0x%"UVxf, PTR2UV(HvARRAY(sv)));
	usedkeys = HvUSEDKEYS(sv);
	if (HvARRAY(sv) && usedkeys) {
	    /* Show distribution of HEs in the ARRAY */
	    int freq[200];
#define FREQ_MAX ((int)(C_ARRAY_LENGTH(freq) - 1))
	    int i;
	    int max = 0;
	    U32 pow2 = 2, keys = usedkeys;
	    NV theoret, sum = 0;

	    PerlIO_printf(file, "  (");
	    Zero(freq, FREQ_MAX + 1, int);
	    for (i = 0; (STRLEN)i <= HvMAX(sv); i++) {
		HE* h;
		int count = 0;
                for (h = HvARRAY(sv)[i]; h; h = HeNEXT(h))
		    count++;
		if (count > FREQ_MAX)
		    count = FREQ_MAX;
	        freq[count]++;
	        if (max < count)
		    max = count;
	    }
	    for (i = 0; i <= max; i++) {
		if (freq[i]) {
		    PerlIO_printf(file, "%d%s:%d", i,
				  (i == FREQ_MAX) ? "+" : "",
				  freq[i]);
		    if (i != max)
			PerlIO_printf(file, ", ");
		}
            }
	    (void)PerlIO_putc(file, ')');
	    /* The "quality" of a hash is defined as the total number of
	       comparisons needed to access every element once, relative
	       to the expected number needed for a random hash.

	       The total number of comparisons is equal to the sum of
	       the squares of the number of entries in each bucket.
	       For a random hash of n keys into k buckets, the expected
	       value is
				n + n(n-1)/2k
	    */

	    for (i = max; i > 0; i--) { /* Precision: count down. */
		sum += freq[i] * i * i;
            }
	    while ((keys = keys >> 1))
		pow2 = pow2 << 1;
	    theoret = usedkeys;
	    theoret += theoret * (theoret-1)/pow2;
	    (void)PerlIO_putc(file, '\n');
	    Perl_dump_indent(aTHX_ level, file, "  hash quality = %.1"NVff"%%", theoret/sum*100);
	}
	(void)PerlIO_putc(file, '\n');
	Perl_dump_indent(aTHX_ level, file, "  KEYS = %"IVdf"\n", (IV)usedkeys);
        {
            STRLEN count = 0;
            HE **ents = HvARRAY(sv);

            if (ents) {
                HE *const *const last = ents + HvMAX(sv);
                count = last + 1 - ents;
                
                do {
                    if (!*ents)
                        --count;
                } while (++ents <= last);
            }

            if (SvOOK(sv)) {
                struct xpvhv_aux *const aux = HvAUX(sv);
                Perl_dump_indent(aTHX_ level, file, "  FILL = %"UVuf
                                 " (cached = %"UVuf")\n",
                                 (UV)count, (UV)aux->xhv_fill_lazy);
            } else {
                Perl_dump_indent(aTHX_ level, file, "  FILL = %"UVuf"\n",
                                 (UV)count);
            }
        }
	Perl_dump_indent(aTHX_ level, file, "  MAX = %"IVdf"\n", (IV)HvMAX(sv));
        if (SvOOK(sv)) {
	    Perl_dump_indent(aTHX_ level, file, "  RITER = %"IVdf"\n", (IV)HvRITER_get(sv));
	    Perl_dump_indent(aTHX_ level, file, "  EITER = 0x%"UVxf"\n", PTR2UV(HvEITER_get(sv)));
#ifdef PERL_HASH_RANDOMIZE_KEYS
	    Perl_dump_indent(aTHX_ level, file, "  RAND = 0x%"UVxf, (UV)HvRAND_get(sv));
            if (HvRAND_get(sv) != HvLASTRAND_get(sv) && HvRITER_get(sv) != -1 ) {
                PerlIO_printf(file, " (LAST = 0x%"UVxf")", (UV)HvLASTRAND_get(sv));
            }
#endif
            (void)PerlIO_putc(file, '\n');
        }
	{
	    MAGIC * const mg = mg_find(sv, PERL_MAGIC_symtab);
	    if (mg && mg->mg_obj) {
		Perl_dump_indent(aTHX_ level, file, "  PMROOT = 0x%"UVxf"\n", PTR2UV(mg->mg_obj));
	    }
	}
	{
	    const char * const hvname = HvNAME_get(sv);
	    if (hvname) {
          SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
     Perl_dump_indent(aTHX_ level, file, "  NAME = \"%s\"\n",
                                       generic_pv_escape( tmpsv, hvname,
                                           HvNAMELEN(sv), HvNAMEUTF8(sv)));
        }
	}
	if (SvOOK(sv)) {
	    AV * const backrefs
		= *Perl_hv_backreferences_p(aTHX_ MUTABLE_HV(sv));
	    struct mro_meta * const meta = HvAUX(sv)->xhv_mro_meta;
	    if (HvAUX(sv)->xhv_name_count)
		Perl_dump_indent(aTHX_
		 level, file, "  NAMECOUNT = %"IVdf"\n",
		 (IV)HvAUX(sv)->xhv_name_count
		);
	    if (HvAUX(sv)->xhv_name_u.xhvnameu_name && HvENAME_HEK_NN(sv)) {
		const I32 count = HvAUX(sv)->xhv_name_count;
		if (count) {
		    SV * const names = newSVpvs_flags("", SVs_TEMP);
		    /* The starting point is the first element if count is
		       positive and the second element if count is negative. */
		    HEK *const *hekp = HvAUX(sv)->xhv_name_u.xhvnameu_names
			+ (count < 0 ? 1 : 0);
		    HEK *const *const endp = HvAUX(sv)->xhv_name_u.xhvnameu_names
			+ (count < 0 ? -count : count);
		    while (hekp < endp) {
			if (HEK_LEN(*hekp)) {
             SV *tmp = newSVpvs_flags("", SVs_TEMP);
			    Perl_sv_catpvf(aTHX_ names, ", \"%s\"",
                              generic_pv_escape(tmp, HEK_KEY(*hekp), HEK_LEN(*hekp), HEK_UTF8(*hekp)));
			} else {
			    /* This should never happen. */
			    sv_catpvs(names, ", (null)");
			}
			++hekp;
		    }
		    Perl_dump_indent(aTHX_
		     level, file, "  ENAME = %s\n", SvPV_nolen(names)+2
		    );
		}
		else {
                    SV * const tmp = newSVpvs_flags("", SVs_TEMP);
                    const char *const hvename = HvENAME_get(sv);
		    Perl_dump_indent(aTHX_
		     level, file, "  ENAME = \"%s\"\n",
                     generic_pv_escape(tmp, hvename,
                                       HvENAMELEN_get(sv), HvENAMEUTF8(sv)));
                }
	    }
	    if (backrefs) {
		Perl_dump_indent(aTHX_ level, file, "  BACKREFS = 0x%"UVxf"\n",
				 PTR2UV(backrefs));
		do_sv_dump(level+1, file, MUTABLE_SV(backrefs), nest+1, maxnest,
			   dumpops, pvlim);
	    }
	    if (meta) {
		SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
		Perl_dump_indent(aTHX_ level, file, "  MRO_WHICH = \"%s\" (0x%"UVxf")\n",
				 generic_pv_escape( tmpsv, meta->mro_which->name,
                                meta->mro_which->length,
                                (meta->mro_which->kflags & HVhek_UTF8)),
				 PTR2UV(meta->mro_which));
		Perl_dump_indent(aTHX_ level, file, "  CACHE_GEN = 0x%"UVxf"\n",
				 (UV)meta->cache_gen);
		Perl_dump_indent(aTHX_ level, file, "  PKG_GEN = 0x%"UVxf"\n",
				 (UV)meta->pkg_gen);
		if (meta->mro_linear_all) {
		    Perl_dump_indent(aTHX_ level, file, "  MRO_LINEAR_ALL = 0x%"UVxf"\n",
				 PTR2UV(meta->mro_linear_all));
		do_sv_dump(level+1, file, MUTABLE_SV(meta->mro_linear_all), nest+1, maxnest,
			   dumpops, pvlim);
		}
		if (meta->mro_linear_current) {
		    Perl_dump_indent(aTHX_ level, file, "  MRO_LINEAR_CURRENT = 0x%"UVxf"\n",
				 PTR2UV(meta->mro_linear_current));
		do_sv_dump(level+1, file, MUTABLE_SV(meta->mro_linear_current), nest+1, maxnest,
			   dumpops, pvlim);
		}
		if (meta->mro_nextmethod) {
		    Perl_dump_indent(aTHX_ level, file, "  MRO_NEXTMETHOD = 0x%"UVxf"\n",
				 PTR2UV(meta->mro_nextmethod));
		do_sv_dump(level+1, file, MUTABLE_SV(meta->mro_nextmethod), nest+1, maxnest,
			   dumpops, pvlim);
		}
		if (meta->isa) {
		    Perl_dump_indent(aTHX_ level, file, "  ISA = 0x%"UVxf"\n",
				 PTR2UV(meta->isa));
		do_sv_dump(level+1, file, MUTABLE_SV(meta->isa), nest+1, maxnest,
			   dumpops, pvlim);
		}
	    }
	}
	if (nest < maxnest) {
	    HV * const hv = MUTABLE_HV(sv);
	    STRLEN i;
	    HE *he;

	    if (HvARRAY(hv)) {
		int count = maxnest - nest;
		for (i=0; i <= HvMAX(hv); i++) {
		    for (he = HvARRAY(hv)[i]; he; he = HeNEXT(he)) {
			U32 hash;
			SV * keysv;
			const char * keypv;
			SV * elt;
                        STRLEN len;

			if (count-- <= 0) goto DONEHV;

			hash = HeHASH(he);
			keysv = hv_iterkeysv(he);
			keypv = SvPV_const(keysv, len);
			elt = HeVAL(he);

                        Perl_dump_indent(aTHX_ level+1, file, "Elt %s ", pv_display(d, keypv, len, 0, pvlim));
                        if (SvUTF8(keysv))
                            PerlIO_printf(file, "[UTF8 \"%s\"] ", sv_uni_display(d, keysv, 6 * SvCUR(keysv), UNI_DISPLAY_QQ));
			if (HvEITER_get(hv) == he)
			    PerlIO_printf(file, "[CURRENT] ");
                        PerlIO_printf(file, "HASH = 0x%"UVxf"\n", (UV) hash);
                        do_sv_dump(level+1, file, elt, nest+1, maxnest, dumpops, pvlim);
                    }
		}
	      DONEHV:;
	    }
	}
	break;
    } /* case SVt_PVHV */

    case SVt_PVCV:
	if (CvAUTOLOAD(sv)) {
	    SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
       STRLEN len;
	    const char *const name =  SvPV_const(sv, len);
	    Perl_dump_indent(aTHX_ level, file, "  AUTOLOAD = \"%s\"\n",
			     generic_pv_escape(tmpsv, name, len, SvUTF8(sv)));
	}
	if (SvPOK(sv)) {
       SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
       const char *const proto = CvPROTO(sv);
	    Perl_dump_indent(aTHX_ level, file, "  PROTOTYPE = \"%s\"\n",
			     generic_pv_escape(tmpsv, proto, CvPROTOLEN(sv),
                                SvUTF8(sv)));
	}
	/* FALLTHROUGH */
    case SVt_PVFM:
	do_hv_dump(level, file, "  COMP_STASH", CvSTASH(sv));
	if (!CvISXSUB(sv)) {
	    if (CvSTART(sv)) {
		Perl_dump_indent(aTHX_ level, file,
				 "  START = 0x%"UVxf" ===> %"IVdf"\n",
				 PTR2UV(CvSTART(sv)),
				 (IV)sequence_num(CvSTART(sv)));
	    }
	    Perl_dump_indent(aTHX_ level, file, "  ROOT = 0x%"UVxf"\n",
			     PTR2UV(CvROOT(sv)));
	    if (CvROOT(sv) && dumpops) {
		do_op_dump(level+1, file, CvROOT(sv));
	    }
	} else {
	    SV * const constant = cv_const_sv((const CV *)sv);

	    Perl_dump_indent(aTHX_ level, file, "  XSUB = 0x%"UVxf"\n", PTR2UV(CvXSUB(sv)));

	    if (constant) {
		Perl_dump_indent(aTHX_ level, file, "  XSUBANY = 0x%"UVxf
				 " (CONST SV)\n",
				 PTR2UV(CvXSUBANY(sv).any_ptr));
		do_sv_dump(level+1, file, constant, nest+1, maxnest, dumpops,
			   pvlim);
	    } else {
		Perl_dump_indent(aTHX_ level, file, "  XSUBANY = %"IVdf"\n",
				 (IV)CvXSUBANY(sv).any_i32);
	    }
	}
	if (CvNAMED(sv))
	    Perl_dump_indent(aTHX_ level, file, "  NAME = \"%s\"\n",
				   HEK_KEY(CvNAME_HEK((CV *)sv)));
	else do_gvgv_dump(level, file, "  GVGV::GV", CvGV(sv));
	Perl_dump_indent(aTHX_ level, file, "  FILE = \"%s\"\n", CvFILE(sv));
	Perl_dump_indent(aTHX_ level, file, "  DEPTH = %"IVdf"\n", (IV)CvDEPTH(sv));
	Perl_dump_indent(aTHX_ level, file, "  FLAGS = 0x%"UVxf"\n", (UV)CvFLAGS(sv));
	Perl_dump_indent(aTHX_ level, file, "  OUTSIDE_SEQ = %"UVuf"\n", (UV)CvOUTSIDE_SEQ(sv));
	if (!CvISXSUB(sv)) {
	    Perl_dump_indent(aTHX_ level, file, "  PADLIST = 0x%"UVxf"\n", PTR2UV(CvPADLIST(sv)));
	    if (nest < maxnest) {
		do_dump_pad(level+1, file, CvPADLIST(sv), 0);
	    }
	}
	else
	    Perl_dump_indent(aTHX_ level, file, "  HSCXT = 0x%p\n", CvHSCXT(sv));
	{
	    const CV * const outside = CvOUTSIDE(sv);
	    Perl_dump_indent(aTHX_ level, file, "  OUTSIDE = 0x%"UVxf" (%s)\n",
			PTR2UV(outside),
			(!outside ? "null"
			 : CvANON(outside) ? "ANON"
			 : (outside == PL_main_cv) ? "MAIN"
			 : CvUNIQUE(outside) ? "UNIQUE"
			 : CvGV(outside) ?
			     generic_pv_escape(
			         newSVpvs_flags("", SVs_TEMP),
			         GvNAME(CvGV(outside)),
			         GvNAMELEN(CvGV(outside)),
			         GvNAMEUTF8(CvGV(outside)))
			 : "UNDEFINED"));
	}
	if (CvOUTSIDE(sv)
	 && (nest < maxnest && (CvCLONE(sv) || CvCLONED(sv))))
	    do_sv_dump(level+1, file, MUTABLE_SV(CvOUTSIDE(sv)), nest+1, maxnest, dumpops, pvlim);
	break;

    case SVt_PVGV:
    case SVt_PVLV:
	if (type == SVt_PVLV) {
	    Perl_dump_indent(aTHX_ level, file, "  TYPE = %c\n", LvTYPE(sv));
	    Perl_dump_indent(aTHX_ level, file, "  TARGOFF = %"IVdf"\n", (IV)LvTARGOFF(sv));
	    Perl_dump_indent(aTHX_ level, file, "  TARGLEN = %"IVdf"\n", (IV)LvTARGLEN(sv));
	    Perl_dump_indent(aTHX_ level, file, "  TARG = 0x%"UVxf"\n", PTR2UV(LvTARG(sv)));
	    Perl_dump_indent(aTHX_ level, file, "  FLAGS = %"IVdf"\n", (IV)LvFLAGS(sv));
	    if (isALPHA_FOLD_NE(LvTYPE(sv), 't'))
		do_sv_dump(level+1, file, LvTARG(sv), nest+1, maxnest,
		    dumpops, pvlim);
	}
	if (isREGEXP(sv)) goto dumpregexp;
	if (!isGV_with_GP(sv))
	    break;
       {
          SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
          Perl_dump_indent(aTHX_ level, file, "  NAME = \"%s\"\n",
                    generic_pv_escape(tmpsv, GvNAME(sv),
                                      GvNAMELEN(sv),
                                      GvNAMEUTF8(sv)));
       }
	Perl_dump_indent(aTHX_ level, file, "  NAMELEN = %"IVdf"\n", (IV)GvNAMELEN(sv));
	do_hv_dump (level, file, "  GvSTASH", GvSTASH(sv));
	Perl_dump_indent(aTHX_ level, file, "  FLAGS = 0x%"UVxf"\n", (UV)GvFLAGS(sv));
	Perl_dump_indent(aTHX_ level, file, "  GP = 0x%"UVxf"\n", PTR2UV(GvGP(sv)));
	if (!GvGP(sv))
	    break;
	Perl_dump_indent(aTHX_ level, file, "    SV = 0x%"UVxf"\n", PTR2UV(GvSV(sv)));
	Perl_dump_indent(aTHX_ level, file, "    REFCNT = %"IVdf"\n", (IV)GvREFCNT(sv));
	Perl_dump_indent(aTHX_ level, file, "    IO = 0x%"UVxf"\n", PTR2UV(GvIOp(sv)));
	Perl_dump_indent(aTHX_ level, file, "    FORM = 0x%"UVxf"  \n", PTR2UV(GvFORM(sv)));
	Perl_dump_indent(aTHX_ level, file, "    AV = 0x%"UVxf"\n", PTR2UV(GvAV(sv)));
	Perl_dump_indent(aTHX_ level, file, "    HV = 0x%"UVxf"\n", PTR2UV(GvHV(sv)));
	Perl_dump_indent(aTHX_ level, file, "    CV = 0x%"UVxf"\n", PTR2UV(GvCV(sv)));
	Perl_dump_indent(aTHX_ level, file, "    CVGEN = 0x%"UVxf"\n", (UV)GvCVGEN(sv));
	Perl_dump_indent(aTHX_ level, file, "    GPFLAGS = 0x%"UVxf
					    " (%s)\n",
			       (UV)GvGPFLAGS(sv),
			       "");
	Perl_dump_indent(aTHX_ level, file, "    LINE = %"IVdf"\n", (IV)GvLINE(sv));
	Perl_dump_indent(aTHX_ level, file, "    FILE = \"%s\"\n", GvFILE(sv));
	do_gv_dump (level, file, "    EGV", GvEGV(sv));
	break;
    case SVt_PVIO:
	Perl_dump_indent(aTHX_ level, file, "  IFP = 0x%"UVxf"\n", PTR2UV(IoIFP(sv)));
	Perl_dump_indent(aTHX_ level, file, "  OFP = 0x%"UVxf"\n", PTR2UV(IoOFP(sv)));
	Perl_dump_indent(aTHX_ level, file, "  DIRP = 0x%"UVxf"\n", PTR2UV(IoDIRP(sv)));
	Perl_dump_indent(aTHX_ level, file, "  LINES = %"IVdf"\n", (IV)IoLINES(sv));
	Perl_dump_indent(aTHX_ level, file, "  PAGE = %"IVdf"\n", (IV)IoPAGE(sv));
	Perl_dump_indent(aTHX_ level, file, "  PAGE_LEN = %"IVdf"\n", (IV)IoPAGE_LEN(sv));
	Perl_dump_indent(aTHX_ level, file, "  LINES_LEFT = %"IVdf"\n", (IV)IoLINES_LEFT(sv));
        if (IoTOP_NAME(sv))
            Perl_dump_indent(aTHX_ level, file, "  TOP_NAME = \"%s\"\n", IoTOP_NAME(sv));
	if (!IoTOP_GV(sv) || SvTYPE(IoTOP_GV(sv)) == SVt_PVGV)
	    do_gv_dump (level, file, "  TOP_GV", IoTOP_GV(sv));
	else {
	    Perl_dump_indent(aTHX_ level, file, "  TOP_GV = 0x%"UVxf"\n",
			     PTR2UV(IoTOP_GV(sv)));
	    do_sv_dump (level+1, file, MUTABLE_SV(IoTOP_GV(sv)), nest+1,
			maxnest, dumpops, pvlim);
	}
	/* Source filters hide things that are not GVs in these three, so let's
	   be careful out there.  */
        if (IoFMT_NAME(sv))
            Perl_dump_indent(aTHX_ level, file, "  FMT_NAME = \"%s\"\n", IoFMT_NAME(sv));
	if (!IoFMT_GV(sv) || SvTYPE(IoFMT_GV(sv)) == SVt_PVGV)
	    do_gv_dump (level, file, "  FMT_GV", IoFMT_GV(sv));
	else {
	    Perl_dump_indent(aTHX_ level, file, "  FMT_GV = 0x%"UVxf"\n",
			     PTR2UV(IoFMT_GV(sv)));
	    do_sv_dump (level+1, file, MUTABLE_SV(IoFMT_GV(sv)), nest+1,
			maxnest, dumpops, pvlim);
	}
        if (IoBOTTOM_NAME(sv))
            Perl_dump_indent(aTHX_ level, file, "  BOTTOM_NAME = \"%s\"\n", IoBOTTOM_NAME(sv));
	if (!IoBOTTOM_GV(sv) || SvTYPE(IoBOTTOM_GV(sv)) == SVt_PVGV)
	    do_gv_dump (level, file, "  BOTTOM_GV", IoBOTTOM_GV(sv));
	else {
	    Perl_dump_indent(aTHX_ level, file, "  BOTTOM_GV = 0x%"UVxf"\n",
			     PTR2UV(IoBOTTOM_GV(sv)));
	    do_sv_dump (level+1, file, MUTABLE_SV(IoBOTTOM_GV(sv)), nest+1,
			maxnest, dumpops, pvlim);
	}
	if (isPRINT(IoTYPE(sv)))
            Perl_dump_indent(aTHX_ level, file, "  TYPE = '%c'\n", IoTYPE(sv));
	else
            Perl_dump_indent(aTHX_ level, file, "  TYPE = '\\%o'\n", IoTYPE(sv));
	Perl_dump_indent(aTHX_ level, file, "  FLAGS = 0x%"UVxf"\n", (UV)IoFLAGS(sv));
	break;
    case SVt_REGEXP:
      dumpregexp:
	{
	    struct regexp * const r = ReANY((REGEXP*)sv);

#define SV_SET_STRINGIFY_REGEXP_FLAGS(d,flags,names) STMT_START { \
            sv_setpv(d,"");                                 \
            append_flags(d, flags, names);     \
            if (SvCUR(d) > 0 && *(SvEND(d) - 1) == ',') {       \
                SvCUR_set(d, SvCUR(d) - 1);                 \
                SvPVX(d)[SvCUR(d)] = '\0';                  \
            }                                               \
} STMT_END
            SV_SET_STRINGIFY_REGEXP_FLAGS(d,r->compflags,regexp_extflags_names);
            Perl_dump_indent(aTHX_ level, file, "  COMPFLAGS = 0x%"UVxf" (%s)\n",
                                (UV)(r->compflags), SvPVX_const(d));

            SV_SET_STRINGIFY_REGEXP_FLAGS(d,r->extflags,regexp_extflags_names);
	    Perl_dump_indent(aTHX_ level, file, "  EXTFLAGS = 0x%"UVxf" (%s)\n",
                                (UV)(r->extflags), SvPVX_const(d));

            Perl_dump_indent(aTHX_ level, file, "  ENGINE = 0x%"UVxf" (%s)\n",
                                PTR2UV(r->engine), (r->engine == &PL_core_reg_engine) ? "STANDARD" : "PLUG-IN" );
            if (r->engine == &PL_core_reg_engine) {
                SV_SET_STRINGIFY_REGEXP_FLAGS(d,r->intflags,regexp_core_intflags_names);
                Perl_dump_indent(aTHX_ level, file, "  INTFLAGS = 0x%"UVxf" (%s)\n",
                                (UV)(r->intflags), SvPVX_const(d));
            } else {
                Perl_dump_indent(aTHX_ level, file, "  INTFLAGS = 0x%"UVxf"\n",
				(UV)(r->intflags));
            }
#undef SV_SET_STRINGIFY_REGEXP_FLAGS
	    Perl_dump_indent(aTHX_ level, file, "  NPARENS = %"UVuf"\n",
				(UV)(r->nparens));
	    Perl_dump_indent(aTHX_ level, file, "  LASTPAREN = %"UVuf"\n",
				(UV)(r->lastparen));
	    Perl_dump_indent(aTHX_ level, file, "  LASTCLOSEPAREN = %"UVuf"\n",
				(UV)(r->lastcloseparen));
	    Perl_dump_indent(aTHX_ level, file, "  MINLEN = %"IVdf"\n",
				(IV)(r->minlen));
	    Perl_dump_indent(aTHX_ level, file, "  MINLENRET = %"IVdf"\n",
				(IV)(r->minlenret));
	    Perl_dump_indent(aTHX_ level, file, "  GOFS = %"UVuf"\n",
				(UV)(r->gofs));
	    Perl_dump_indent(aTHX_ level, file, "  PRE_PREFIX = %"UVuf"\n",
				(UV)(r->pre_prefix));
	    Perl_dump_indent(aTHX_ level, file, "  SUBLEN = %"IVdf"\n",
				(IV)(r->sublen));
	    Perl_dump_indent(aTHX_ level, file, "  SUBOFFSET = %"IVdf"\n",
				(IV)(r->suboffset));
	    Perl_dump_indent(aTHX_ level, file, "  SUBCOFFSET = %"IVdf"\n",
				(IV)(r->subcoffset));
	    if (r->subbeg)
		Perl_dump_indent(aTHX_ level, file, "  SUBBEG = 0x%"UVxf" %s\n",
			    PTR2UV(r->subbeg),
			    pv_display(d, r->subbeg, r->sublen, 50, pvlim));
	    else
		Perl_dump_indent(aTHX_ level, file, "  SUBBEG = 0x0\n");
	    Perl_dump_indent(aTHX_ level, file, "  MOTHER_RE = 0x%"UVxf"\n",
				PTR2UV(r->mother_re));
	    if (nest < maxnest && r->mother_re)
		do_sv_dump(level+1, file, (SV *)r->mother_re, nest+1,
			   maxnest, dumpops, pvlim);
	    Perl_dump_indent(aTHX_ level, file, "  PAREN_NAMES = 0x%"UVxf"\n",
				PTR2UV(r->paren_names));
	    Perl_dump_indent(aTHX_ level, file, "  SUBSTRS = 0x%"UVxf"\n",
				PTR2UV(r->substrs));
	    Perl_dump_indent(aTHX_ level, file, "  PPRIVATE = 0x%"UVxf"\n",
				PTR2UV(r->pprivate));
	    Perl_dump_indent(aTHX_ level, file, "  OFFS = 0x%"UVxf"\n",
				PTR2UV(r->offs));
	    Perl_dump_indent(aTHX_ level, file, "  QR_ANONCV = 0x%"UVxf"\n",
				PTR2UV(r->qr_anoncv));
#ifdef PERL_ANY_COW
	    Perl_dump_indent(aTHX_ level, file, "  SAVED_COPY = 0x%"UVxf"\n",
				PTR2UV(r->saved_copy));
#endif
	}
	break;
    }
    SvREFCNT_dec_NN(d);
}

/*
=for apidoc sv_dump

Dumps the contents of an SV to the C<STDERR> filehandle.

For an example of its output, see L<Devel::Peek>.

=cut
*/

void
Perl_sv_dump(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_DUMP;

    if (SvROK(sv))
	do_sv_dump(0, Perl_debug_log, sv, 0, 4, 0, 0);
    else
	do_sv_dump(0, Perl_debug_log, sv, 0, 0, 0, 0);
}

int
Perl_runops_debug(pTHX)
{
    if (!PL_op) {
	Perl_ck_warner_d(aTHX_ packWARN(WARN_DEBUGGING), "NULL OP IN RUN");
	return 0;
    }

    DEBUG_l(Perl_deb(aTHX_ "Entering new RUNOPS level\n"));
    do {
#ifdef PERL_TRACE_OPS
        ++PL_op_exec_cnt[PL_op->op_type];
#endif
	if (PL_debug) {
            ENTER;
            SAVETMPS;
	    if (PL_watchaddr && (*PL_watchaddr != PL_watchok))
		PerlIO_printf(Perl_debug_log,
			      "WARNING: %"UVxf" changed from %"UVxf" to %"UVxf"\n",
			      PTR2UV(PL_watchaddr), PTR2UV(PL_watchok),
			      PTR2UV(*PL_watchaddr));
	    if (DEBUG_s_TEST_) {
		if (DEBUG_v_TEST_) {
		    PerlIO_printf(Perl_debug_log, "\n");
		    deb_stack_all();
		}
		else
		    debstack();
	    }


	    if (DEBUG_t_TEST_) debop(PL_op);
	    if (DEBUG_P_TEST_) debprof(PL_op);
            FREETMPS;
            LEAVE;
	}

        PERL_DTRACE_PROBE_OP(PL_op);
    } while ((PL_op = PL_op->op_ppaddr(aTHX)));
    DEBUG_l(Perl_deb(aTHX_ "leaving RUNOPS level\n"));
    PERL_ASYNC_CHECK();

    TAINT_NOT;
    return 0;
}


/* print the names of the n lexical vars starting at pad offset off */

STATIC void
S_deb_padvar(pTHX_ PADOFFSET off, int n, bool paren)
{
    PADNAME *sv;
    CV * const cv = deb_curcv(cxstack_ix);
    PADNAMELIST *comppad = NULL;
    int i;

    if (cv) {
        PADLIST * const padlist = CvPADLIST(cv);
        comppad = PadlistNAMES(padlist);
    }
    if (paren)
        PerlIO_printf(Perl_debug_log, "(");
    for (i = 0; i < n; i++) {
        if (comppad && (sv = padnamelist_fetch(comppad, off + i)))
            PerlIO_printf(Perl_debug_log, "%"PNf, PNfARG(sv));
        else
            PerlIO_printf(Perl_debug_log, "[%"UVuf"]",
                    (UV)(off+i));
        if (i < n - 1)
            PerlIO_printf(Perl_debug_log, ",");
    }
    if (paren)
        PerlIO_printf(Perl_debug_log, ")");
}


/* append to the out SV, the name of the lexical at offset off in the CV
 * cv */

static void
S_append_padvar(pTHX_ PADOFFSET off, CV *cv, SV *out, int n,
        bool paren, bool is_scalar)
{
    PADNAME *sv;
    PADNAMELIST *namepad = NULL;
    int i;

    if (cv) {
        PADLIST * const padlist = CvPADLIST(cv);
        namepad = PadlistNAMES(padlist);
    }

    if (paren)
        sv_catpvs_nomg(out, "(");
    for (i = 0; i < n; i++) {
        if (namepad && (sv = padnamelist_fetch(namepad, off + i)))
        {
            STRLEN cur = SvCUR(out);
            Perl_sv_catpvf(aTHX_ out, "[%"UTF8f,
                                 UTF8fARG(1, PadnameLEN(sv) - 1,
                                          PadnamePV(sv) + 1));
            if (is_scalar)
                SvPVX(out)[cur] = '$';
        }
        else
            Perl_sv_catpvf(aTHX_ out, "[%"UVuf"]", (UV)(off+i));
        if (i < n - 1)
            sv_catpvs_nomg(out, ",");
    }
    if (paren)
        sv_catpvs_nomg(out, "(");
}


static void
S_append_gv_name(pTHX_ GV *gv, SV *out)
{
    SV *sv;
    if (!gv) {
        sv_catpvs_nomg(out, "<NULLGV>");
        return;
    }
    sv = newSV(0);
    gv_fullname4(sv, gv, NULL, FALSE);
    Perl_sv_catpvf(aTHX_ out, "$%"SVf, SVfARG(sv));
    SvREFCNT_dec_NN(sv);
}

#ifdef USE_ITHREADS
#  define ITEM_SV(item) (comppad ? \
    *av_fetch(comppad, (item)->pad_offset, FALSE) : NULL);
#else
#  define ITEM_SV(item) UNOP_AUX_item_sv(item)
#endif


/* return a temporary SV containing a stringified representation of
 * the op_aux field of a MULTIDEREF op, associated with CV cv
 */

SV*
Perl_multideref_stringify(pTHX_ const OP *o, CV *cv)
{
    UNOP_AUX_item *items = cUNOP_AUXo->op_aux;
    UV actions = items->uv;
    SV *sv;
    bool last = 0;
    bool is_hash = FALSE;
    int derefs = 0;
    SV *out = newSVpvn_flags("",0,SVs_TEMP);
#ifdef USE_ITHREADS
    PAD *comppad;

    if (cv) {
        PADLIST *padlist = CvPADLIST(cv);
        comppad = PadlistARRAY(padlist)[1];
    }
    else
        comppad = NULL;
#endif

    PERL_ARGS_ASSERT_MULTIDEREF_STRINGIFY;

    while (!last) {
        switch (actions & MDEREF_ACTION_MASK) {

        case MDEREF_reload:
            actions = (++items)->uv;
            continue;
            NOT_REACHED; /* NOTREACHED */

        case MDEREF_HV_padhv_helem:
            is_hash = TRUE;
            /* FALLTHROUGH */
        case MDEREF_AV_padav_aelem:
            derefs = 1;
            S_append_padvar(aTHX_ (++items)->pad_offset, cv, out, 1, 0, 1);
            goto do_elem;
            NOT_REACHED; /* NOTREACHED */

        case MDEREF_HV_gvhv_helem:
            is_hash = TRUE;
            /* FALLTHROUGH */
        case MDEREF_AV_gvav_aelem:
            derefs = 1;
            items++;
            sv = ITEM_SV(items);
            S_append_gv_name(aTHX_ (GV*)sv, out);
            goto do_elem;
            NOT_REACHED; /* NOTREACHED */

        case MDEREF_HV_gvsv_vivify_rv2hv_helem:
            is_hash = TRUE;
            /* FALLTHROUGH */
        case MDEREF_AV_gvsv_vivify_rv2av_aelem:
            items++;
            sv = ITEM_SV(items);
            S_append_gv_name(aTHX_ (GV*)sv, out);
            goto do_vivify_rv2xv_elem;
            NOT_REACHED; /* NOTREACHED */

        case MDEREF_HV_padsv_vivify_rv2hv_helem:
            is_hash = TRUE;
            /* FALLTHROUGH */
        case MDEREF_AV_padsv_vivify_rv2av_aelem:
            S_append_padvar(aTHX_ (++items)->pad_offset, cv, out, 1, 0, 1);
            goto do_vivify_rv2xv_elem;
            NOT_REACHED; /* NOTREACHED */

        case MDEREF_HV_pop_rv2hv_helem:
        case MDEREF_HV_vivify_rv2hv_helem:
            is_hash = TRUE;
            /* FALLTHROUGH */
        do_vivify_rv2xv_elem:
        case MDEREF_AV_pop_rv2av_aelem:
        case MDEREF_AV_vivify_rv2av_aelem:
            if (!derefs++)
                sv_catpvs_nomg(out, "->");
        do_elem:
            if ((actions & MDEREF_INDEX_MASK)== MDEREF_INDEX_none) {
                sv_catpvs_nomg(out, "->");
                last = 1;
                break;
            }

            sv_catpvn_nomg(out, (is_hash ? "{" : "["), 1);
            switch (actions & MDEREF_INDEX_MASK) {
            case MDEREF_INDEX_const:
                if (is_hash) {
                    items++;
                    sv = ITEM_SV(items);
                    if (!sv)
                        sv_catpvs_nomg(out, "???");
                    else {
                        STRLEN cur;
                        char *s;
                        s = SvPV(sv, cur);
                        pv_pretty(out, s, cur, 30,
                                    NULL, NULL,
                                    (PERL_PV_PRETTY_NOCLEAR
                                    |PERL_PV_PRETTY_QUOTE
                                    |PERL_PV_PRETTY_ELLIPSES));
                    }
                }
                else
                    Perl_sv_catpvf(aTHX_ out, "%"IVdf, (++items)->iv);
                break;
            case MDEREF_INDEX_padsv:
                S_append_padvar(aTHX_ (++items)->pad_offset, cv, out, 1, 0, 1);
                break;
            case MDEREF_INDEX_gvsv:
                items++;
                sv = ITEM_SV(items);
                S_append_gv_name(aTHX_ (GV*)sv, out);
                break;
            }
            sv_catpvn_nomg(out, (is_hash ? "}" : "]"), 1);

            if (actions & MDEREF_FLAG_last)
                last = 1;
            is_hash = FALSE;

            break;

        default:
            PerlIO_printf(Perl_debug_log, "UNKNOWN(%d)",
                (int)(actions & MDEREF_ACTION_MASK));
            last = 1;
            break;

        } /* switch */

        actions >>= MDEREF_SHIFT;
    } /* while */
    return out;
}


I32
Perl_debop(pTHX_ const OP *o)
{
    PERL_ARGS_ASSERT_DEBOP;

    if (CopSTASH_eq(PL_curcop, PL_debstash) && !DEBUG_J_TEST_)
	return 0;

    Perl_deb(aTHX_ "%s", OP_NAME(o));
    switch (o->op_type) {
    case OP_CONST:
    case OP_HINTSEVAL:
	/* With ITHREADS, consts are stored in the pad, and the right pad
	 * may not be active here, so check.
	 * Looks like only during compiling the pads are illegal.
	 */
#ifdef USE_ITHREADS
	if ((((SVOP*)o)->op_sv) || !IN_PERL_COMPILETIME)
#endif
	    PerlIO_printf(Perl_debug_log, "(%s)", SvPEEK(cSVOPo_sv));
	break;
    case OP_GVSV:
    case OP_GV:
	if (cGVOPo_gv && isGV(cGVOPo_gv)) {
	    SV * const sv = newSV(0);
	    gv_fullname3(sv, cGVOPo_gv, NULL);
	    PerlIO_printf(Perl_debug_log, "(%s)", SvPV_nolen_const(sv));
	    SvREFCNT_dec_NN(sv);
	}
	else if (cGVOPo_gv) {
	    SV * const sv = newSV(0);
	    assert(SvROK(cGVOPo_gv));
	    assert(SvTYPE(SvRV(cGVOPo_gv)) == SVt_PVCV);
	    PerlIO_printf(Perl_debug_log, "(cv ref: %s)",
		    SvPV_nolen_const(cv_name((CV *)SvRV(cGVOPo_gv),sv,0)));
	    SvREFCNT_dec_NN(sv);
	}
	else
	    PerlIO_printf(Perl_debug_log, "(NULL)");
	break;

    case OP_PADSV:
    case OP_PADAV:
    case OP_PADHV:
        S_deb_padvar(aTHX_ o->op_targ, 1, 1);
        break;

    case OP_PADRANGE:
        S_deb_padvar(aTHX_ o->op_targ,
                        o->op_private & OPpPADRANGE_COUNTMASK, 1);
        break;

    case OP_MULTIDEREF:
        PerlIO_printf(Perl_debug_log, "(%"SVf")",
            SVfARG(multideref_stringify(o, deb_curcv(cxstack_ix))));
        break;

    default:
	break;
    }
    PerlIO_printf(Perl_debug_log, "\n");
    return 0;
}

STATIC CV*
S_deb_curcv(pTHX_ I32 ix)
{
    PERL_SI *si = PL_curstackinfo;
    for (; ix >=0; ix--) {
        const PERL_CONTEXT * const cx = &(si->si_cxstack)[ix];

        if (CxTYPE(cx) == CXt_SUB || CxTYPE(cx) == CXt_FORMAT)
            return cx->blk_sub.cv;
        else if (CxTYPE(cx) == CXt_EVAL && !CxTRYBLOCK(cx))
            return cx->blk_eval.cv;
        else if (ix == 0 && si->si_type == PERLSI_MAIN)
            return PL_main_cv;
        else if (ix == 0 && CxTYPE(cx) == CXt_NULL
               && si->si_type == PERLSI_SORT)
        {
            /* fake sort sub; use CV of caller */
            si = si->si_prev;
            ix = si->si_cxix + 1;
        }
    }
    return NULL;
}

void
Perl_watch(pTHX_ char **addr)
{
    PERL_ARGS_ASSERT_WATCH;

    PL_watchaddr = addr;
    PL_watchok = *addr;
    PerlIO_printf(Perl_debug_log, "WATCHING, %"UVxf" is currently %"UVxf"\n",
	PTR2UV(PL_watchaddr), PTR2UV(PL_watchok));
}

STATIC void
S_debprof(pTHX_ const OP *o)
{
    PERL_ARGS_ASSERT_DEBPROF;

    if (!DEBUG_J_TEST_ && CopSTASH_eq(PL_curcop, PL_debstash))
	return;
    if (!PL_profiledata)
	Newxz(PL_profiledata, MAXO, U32);
    ++PL_profiledata[o->op_type];
}

void
Perl_debprofdump(pTHX)
{
    unsigned i;
    if (!PL_profiledata)
	return;
    for (i = 0; i < MAXO; i++) {
	if (PL_profiledata[i])
	    PerlIO_printf(Perl_debug_log,
			  "%5lu %s\n", (unsigned long)PL_profiledata[i],
                                       PL_op_name[i]);
    }
}


/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d23 2
d97 6
a102 3
Escapes at most the first "count" chars of pv and puts the results into
dsv such that the size of the escaped string will not exceed "max" chars
and will not contain any incomplete escape sequences.
d104 1
a104 1
If flags contains PERL_PV_ESCAPE_QUOTE then any double quotes in the string
d108 1
a108 1
but when PERL_PV_ESCAPE_NOCLEAR is set this will not occur.
d110 3
a112 3
If PERL_PV_ESCAPE_UNI is set then the input string is treated as Unicode,
if PERL_PV_ESCAPE_UNI_DETECT is set then the input string is scanned
using C<is_utf8_string()> to determine if it is Unicode.
d114 2
a115 2
If PERL_PV_ESCAPE_ALL is set then all input chars will be output
using C<\x01F1> style escapes, otherwise if PERL_PV_ESCAPE_NONASCII is set, only
d119 1
a119 1
Otherwise, if PERL_PV_ESCAPE_NOBACKSLASH
d123 1
a123 1
If PERL_PV_ESCAPE_FIRSTCHAR is set then only the first char of the
d129 3
a131 3
If PERL_PV_ESCAPE_RE is set then the escape char used will be a '%' and
not a '\\'.  This is because regexes very often contain backslashed
sequences, whereas '%' is not a particularly common character in patterns.
d133 1
a133 1
Returns a pointer to the escaped text as held by dsv.
d150 1
a150 1
    bool isuni= flags & PERL_PV_ESCAPE_UNI ? 1 : 0; /* is this Unicode */
d157 1
a157 1
    if (!(flags & PERL_PV_ESCAPE_NOCLEAR)) {
d189 1
a189 1
		case '\\' : /* fallthrough */
d227 2
a228 1
            sv_catpvn(dsv, octbuf, chsize);
d237 2
a238 1
            Perl_sv_catpvf( aTHX_ dsv, "%c", c);
d246 1
a246 1
    return SvPVX(dsv);
d252 1
a252 1
pv_escape() and supporting quoting and ellipses.
d254 1
a254 1
If the PERL_PV_PRETTY_QUOTE flag is set then the result will be 
d256 1
a256 1
if the PERL_PV_PRETTY_LTGT flag is set then the result be wrapped in
d259 1
a259 1
If the PERL_PV_PRETTY_ELLIPSES flag is set and not all characters in
d263 2
a264 2
If start_color is non-null then it will be inserted after the opening
quote (if there is one) but before the escaped text.  If end_color
d268 1
a268 1
Returns a pointer to the prettified text as held by dsv.
d278 2
a279 1
    const U8 dq = (flags & PERL_PV_PRETTY_QUOTE) ? '"' : '%';
d281 2
d287 2
a288 2
	    /* This won't alter the UTF-8 flag */
	    sv_setpvs(dsv, "");
d290 1
d292 2
a293 4
    if ( dq == '"' )
        sv_catpvs(dsv, "\"");
    else if ( flags & PERL_PV_PRETTY_LTGT )
        sv_catpvs(dsv, "<");
d297 13
a309 3
    
    pv_escape( dsv, str, count, max, &escaped, flags | PERL_PV_ESCAPE_NOCLEAR );    
    
d313 2
a314 4
    if ( dq == '"' ) 
	sv_catpvs( dsv, "\"");
    else if ( flags & PERL_PV_PRETTY_LTGT )
        sv_catpvs(dsv, ">");         
d318 5
d480 1
a480 1
	STORE_NUMERIC_LOCAL_SET_STANDARD();
d482 1
a482 1
	RESTORE_NUMERIC_LOCAL();
d496 1
a496 1
    if (TAINTING_get && SvTAINTED(sv))
a517 1
    dVAR;
a541 2

    dVAR;
a565 1
    dVAR;
d575 4
a578 1
	    const GV * const gv = (const GV *)HeVAL(entry);
a646 1
    dVAR;
d668 2
a669 2
	Perl_dump_indent(aTHX_ level, file, "PMf_PRE %c%s%c%s\n",
	     ch, RX_PRECOMP(PM_GETRE(pm)), ch,
d777 4
a789 247
const struct flag_to_name op_trans_names[] = {
    {OPpTRANS_FROM_UTF, ",FROM_UTF"},
    {OPpTRANS_TO_UTF, ",TO_UTF"},
    {OPpTRANS_IDENTICAL, ",IDENTICAL"},
    {OPpTRANS_SQUASH, ",SQUASH"},
    {OPpTRANS_COMPLEMENT, ",COMPLEMENT"},
    {OPpTRANS_GROWS, ",GROWS"},
    {OPpTRANS_DELETE, ",DELETE"}
};

const struct flag_to_name op_entersub_names[] = {
    {OPpENTERSUB_DB, ",DB"},
    {OPpENTERSUB_HASTARG, ",HASTARG"},
    {OPpENTERSUB_AMPER, ",AMPER"},
    {OPpENTERSUB_NOPAREN, ",NOPAREN"},
    {OPpENTERSUB_INARGS, ",INARGS"}
};

const struct flag_to_name op_const_names[] = {
    {OPpCONST_NOVER, ",NOVER"},
    {OPpCONST_SHORTCIRCUIT, ",SHORTCIRCUIT"},
    {OPpCONST_STRICT, ",STRICT"},
    {OPpCONST_ENTERED, ",ENTERED"},
    {OPpCONST_BARE, ",BARE"}
};

const struct flag_to_name op_sort_names[] = {
    {OPpSORT_NUMERIC, ",NUMERIC"},
    {OPpSORT_INTEGER, ",INTEGER"},
    {OPpSORT_REVERSE, ",REVERSE"},
    {OPpSORT_INPLACE, ",INPLACE"},
    {OPpSORT_DESCEND, ",DESCEND"},
    {OPpSORT_QSORT, ",QSORT"},
    {OPpSORT_STABLE, ",STABLE"}
};

const struct flag_to_name op_open_names[] = {
    {OPpOPEN_IN_RAW, ",IN_RAW"},
    {OPpOPEN_IN_CRLF, ",IN_CRLF"},
    {OPpOPEN_OUT_RAW, ",OUT_RAW"},
    {OPpOPEN_OUT_CRLF, ",OUT_CRLF"}
};

const struct flag_to_name op_sassign_names[] = {
    {OPpASSIGN_BACKWARDS, ",BACKWARDS"},
    {OPpASSIGN_CV_TO_GV,  ",CV2GV"}
};

const struct flag_to_name op_leave_names[] = {
    {OPpREFCOUNTED, ",REFCOUNTED"},
    {OPpLVALUE,	    ",LVALUE"}
};

#define OP_PRIVATE_ONCE(op, flag, name) \
    const struct flag_to_name CAT2(op, _names)[] = {	\
	{(flag), (name)} \
    }

OP_PRIVATE_ONCE(op_leavesub, OPpREFCOUNTED, ",REFCOUNTED");
OP_PRIVATE_ONCE(op_repeat, OPpREPEAT_DOLIST, ",DOLIST");
OP_PRIVATE_ONCE(op_reverse, OPpREVERSE_INPLACE, ",INPLACE");
OP_PRIVATE_ONCE(op_rv2cv, OPpLVAL_INTRO, ",INTRO");
OP_PRIVATE_ONCE(op_flip, OPpFLIP_LINENUM, ",LINENUM");
OP_PRIVATE_ONCE(op_gv, OPpEARLY_CV, ",EARLY_CV");
OP_PRIVATE_ONCE(op_list, OPpLIST_GUESSED, ",GUESSED");
OP_PRIVATE_ONCE(op_delete, OPpSLICE, ",SLICE");
OP_PRIVATE_ONCE(op_exists, OPpEXISTS_SUB, ",EXISTS_SUB");
OP_PRIVATE_ONCE(op_die, OPpHUSH_VMSISH, ",HUSH_VMSISH");
OP_PRIVATE_ONCE(op_split, OPpSPLIT_IMPLIM, ",IMPLIM");
OP_PRIVATE_ONCE(op_dbstate, OPpHUSH_VMSISH, ",HUSH_VMSISH");

struct op_private_by_op {
    U16 op_type;
    U16 len;
    const struct flag_to_name *start;
};

const struct op_private_by_op op_private_names[] = {
    {OP_LEAVESUB, C_ARRAY_LENGTH(op_leavesub_names), op_leavesub_names },
    {OP_LEAVE, C_ARRAY_LENGTH(op_leave_names), op_leave_names },
    {OP_LEAVESUBLV, C_ARRAY_LENGTH(op_leavesub_names), op_leavesub_names },
    {OP_LEAVEWRITE, C_ARRAY_LENGTH(op_leavesub_names), op_leavesub_names },
    {OP_DIE, C_ARRAY_LENGTH(op_die_names), op_die_names },
    {OP_DELETE, C_ARRAY_LENGTH(op_delete_names), op_delete_names },
    {OP_EXISTS, C_ARRAY_LENGTH(op_exists_names), op_exists_names },
    {OP_FLIP, C_ARRAY_LENGTH(op_flip_names), op_flip_names },
    {OP_FLOP, C_ARRAY_LENGTH(op_flip_names), op_flip_names },
    {OP_GV, C_ARRAY_LENGTH(op_gv_names), op_gv_names },
    {OP_LIST, C_ARRAY_LENGTH(op_list_names), op_list_names },
    {OP_SASSIGN, C_ARRAY_LENGTH(op_sassign_names), op_sassign_names },
    {OP_REPEAT, C_ARRAY_LENGTH(op_repeat_names), op_repeat_names },
    {OP_RV2CV, C_ARRAY_LENGTH(op_rv2cv_names), op_rv2cv_names },
    {OP_TRANS, C_ARRAY_LENGTH(op_trans_names), op_trans_names },
    {OP_CONST, C_ARRAY_LENGTH(op_const_names), op_const_names },
    {OP_SORT, C_ARRAY_LENGTH(op_sort_names), op_sort_names },
    {OP_OPEN, C_ARRAY_LENGTH(op_open_names), op_open_names },
    {OP_SPLIT, C_ARRAY_LENGTH(op_split_names), op_split_names },
    {OP_DBSTATE, C_ARRAY_LENGTH(op_dbstate_names), op_dbstate_names },
    {OP_NEXTSTATE, C_ARRAY_LENGTH(op_dbstate_names), op_dbstate_names },
    {OP_BACKTICK, C_ARRAY_LENGTH(op_open_names), op_open_names }
};

static bool
S_op_private_to_names(pTHX_ SV *tmpsv, U32 optype, U32 op_private) {
    const struct op_private_by_op *start = op_private_names;
    const struct op_private_by_op *const end = C_ARRAY_END(op_private_names);

    /* This is a linear search, but no worse than the code that it replaced.
       It's debugging code - size is more important than speed.  */
    do {
	if (optype == start->op_type) {
	    S_append_flags(aTHX_ tmpsv, op_private, start->start,
			   start->start + start->len);
	    return TRUE;
	}
    } while (++start < end);
    return FALSE;
}

#define DUMP_OP_FLAGS(o,xml,level,file)                                 \
    if (o->op_flags || o->op_slabbed || o->op_savefree || o->op_static) { \
        SV * const tmpsv = newSVpvs("");                                \
        switch (o->op_flags & OPf_WANT) {                               \
        case OPf_WANT_VOID:                                             \
            sv_catpv(tmpsv, ",VOID");                                   \
            break;                                                      \
        case OPf_WANT_SCALAR:                                           \
            sv_catpv(tmpsv, ",SCALAR");                                 \
            break;                                                      \
        case OPf_WANT_LIST:                                             \
            sv_catpv(tmpsv, ",LIST");                                   \
            break;                                                      \
        default:                                                        \
            sv_catpv(tmpsv, ",UNKNOWN");                                \
            break;                                                      \
        }                                                               \
        append_flags(tmpsv, o->op_flags, op_flags_names);               \
        if (o->op_slabbed)  sv_catpvs(tmpsv, ",SLABBED");               \
        if (o->op_savefree) sv_catpvs(tmpsv, ",SAVEFREE");              \
        if (o->op_static)   sv_catpvs(tmpsv, ",STATIC");                \
        if (o->op_folded)   sv_catpvs(tmpsv, ",FOLDED");                \
        if (!xml)                                                        \
            Perl_dump_indent(aTHX_ level, file, "FLAGS = (%s)\n",       \
                            SvCUR(tmpsv) ? SvPVX_const(tmpsv) + 1 : "");\
        else                                                            \
            PerlIO_printf(file, " flags=\"%s\"",                        \
                          SvCUR(tmpsv) ? SvPVX(tmpsv) + 1 : "");        \
    }

#if !defined(PERL_MAD)
# define xmldump_attr1(level, file, pat, arg)
#else
# define xmldump_attr1(level, file, pat, arg) \
	S_xmldump_attr(aTHX_ level, file, pat, arg)
#endif

#define DUMP_OP_PRIVATE(o,xml,level,file)                               \
    if (o->op_private) {                                                \
        U32 optype = o->op_type;                                        \
        U32 oppriv = o->op_private;                                     \
        SV * const tmpsv = newSVpvs("");                                \
	if (PL_opargs[optype] & OA_TARGLEX) {                           \
	    if (oppriv & OPpTARGET_MY)                                  \
		sv_catpv(tmpsv, ",TARGET_MY");                          \
	}                                                               \
	else if (optype == OP_ENTERSUB ||                               \
                 optype == OP_RV2SV ||                                  \
                 optype == OP_GVSV ||                                   \
                 optype == OP_RV2AV ||                                  \
                 optype == OP_RV2HV ||                                  \
                 optype == OP_RV2GV ||                                  \
                 optype == OP_AELEM ||                                  \
                 optype == OP_HELEM )                                   \
        {                                                               \
            if (optype == OP_ENTERSUB) {                                \
                append_flags(tmpsv, oppriv, op_entersub_names);         \
            }                                                           \
            else {                                                      \
                switch (oppriv & OPpDEREF) {                            \
                case OPpDEREF_SV:                                       \
                    sv_catpv(tmpsv, ",SV");                             \
                    break;                                              \
                case OPpDEREF_AV:                                       \
                    sv_catpv(tmpsv, ",AV");                             \
                    break;                                              \
                case OPpDEREF_HV:                                       \
                    sv_catpv(tmpsv, ",HV");                             \
                    break;                                              \
                }                                                       \
                if (oppriv & OPpMAYBE_LVSUB)                            \
                    sv_catpv(tmpsv, ",MAYBE_LVSUB");                    \
            }                                                           \
            if (optype == OP_AELEM || optype == OP_HELEM) {             \
                if (oppriv & OPpLVAL_DEFER)                             \
                    sv_catpv(tmpsv, ",LVAL_DEFER");                     \
            }                                                           \
            else if (optype == OP_RV2HV || optype == OP_PADHV) {        \
                if (oppriv & OPpMAYBE_TRUEBOOL)                         \
                    sv_catpvs(tmpsv, ",OPpMAYBE_TRUEBOOL");             \
                if (oppriv & OPpTRUEBOOL)                               \
                    sv_catpvs(tmpsv, ",OPpTRUEBOOL");                   \
            }                                                           \
            else {                                                      \
                if (oppriv & HINT_STRICT_REFS)                          \
                    sv_catpv(tmpsv, ",STRICT_REFS");                    \
                if (oppriv & OPpOUR_INTRO)                              \
                    sv_catpv(tmpsv, ",OUR_INTRO");                      \
            }                                                           \
        }                                                               \
	else if (S_op_private_to_names(aTHX_ tmpsv, optype, oppriv)) {  \
	}                                                               \
	else if (OP_IS_FILETEST(o->op_type)) {                          \
            if (oppriv & OPpFT_ACCESS)                                  \
                sv_catpv(tmpsv, ",FT_ACCESS");                          \
            if (oppriv & OPpFT_STACKED)                                 \
                sv_catpv(tmpsv, ",FT_STACKED");                         \
            if (oppriv & OPpFT_STACKING)                                \
                sv_catpv(tmpsv, ",FT_STACKING");                        \
            if (oppriv & OPpFT_AFTER_t)                                 \
                sv_catpv(tmpsv, ",AFTER_t");                            \
	}                                                               \
	else if (o->op_type == OP_AASSIGN) {                            \
	    if (oppriv & OPpASSIGN_COMMON)                              \
		sv_catpvs(tmpsv, ",COMMON");                            \
	    if (oppriv & OPpMAYBE_LVSUB)                                \
		sv_catpvs(tmpsv, ",MAYBE_LVSUB");                       \
	}                                                               \
	if (o->op_flags & OPf_MOD && oppriv & OPpLVAL_INTRO)            \
	    sv_catpv(tmpsv, ",INTRO");                                  \
	if (o->op_type == OP_PADRANGE)                                  \
	    Perl_sv_catpvf(aTHX_ tmpsv, ",COUNT=%"UVuf,                 \
                           (UV)(oppriv & OPpPADRANGE_COUNTMASK));       \
        if (  (o->op_type == OP_RV2HV || o->op_type == OP_RV2AV ||      \
               o->op_type == OP_PADAV || o->op_type == OP_PADHV ||      \
               o->op_type == OP_ASLICE || o->op_type == OP_HSLICE)      \
           && oppriv & OPpSLICEWARNING  )                               \
            sv_catpvs(tmpsv, ",SLICEWARNING");                          \
	if (SvCUR(tmpsv)) {                                             \
            if (xml)                                                    \
                xmldump_attr1(level+1, file, "private=\"%s\"", SvPVX(tmpsv)+1); \
            else                                                        \
                Perl_dump_indent(aTHX_ level, file, "PRIVATE = (%s)\n", SvPVX_const(tmpsv) + 1); \
	} else if (!xml)                                                \
            Perl_dump_indent(aTHX_ level, file, "PRIVATE = (0x%"UVxf")\n", \
                             (UV)oppriv);                               \
    }

a793 1
    dVAR;
a817 24
	    if (o->op_targ == OP_NEXTSTATE) {
		if (CopLINE(cCOPo))
		    Perl_dump_indent(aTHX_ level, file, "LINE = %"UVuf"\n",
				     (UV)CopLINE(cCOPo));
        if (CopSTASHPV(cCOPo)) {
            SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
            HV *stash = CopSTASH(cCOPo);
            const char * const hvname = HvNAME_get(stash);

		    Perl_dump_indent(aTHX_ level, file, "PACKAGE = \"%s\"\n",
                           generic_pv_escape( tmpsv, hvname, HvNAMELEN(stash), HvNAMEUTF8(stash)));
       }
     if (CopLABEL(cCOPo)) {
          SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
          STRLEN label_len;
          U32 label_flags;
          const char *label = CopLABEL_len_flags(cCOPo,
                                                 &label_len,
                                                 &label_flags);
		    Perl_dump_indent(aTHX_ level, file, "LABEL = \"%s\"\n",
                           generic_pv_escape( tmpsv, label, label_len,(label_flags & SVf_UTF8)));
      }

	    }
d826 86
a911 2
    DUMP_OP_FLAGS(o,0,level,file);
    DUMP_OP_PRIVATE(o,0,level,file);
d913 23
a935 38
#ifdef PERL_MAD
    if (PL_madskills && o->op_madprop) {
	SV * const tmpsv = newSVpvs("");
	MADPROP* mp = o->op_madprop;
	Perl_dump_indent(aTHX_ level, file, "MADPROPS = {\n");
	level++;
	while (mp) {
	    const char tmp = mp->mad_key;
	    sv_setpvs(tmpsv,"'");
	    if (tmp)
		sv_catpvn(tmpsv, &tmp, 1);
	    sv_catpv(tmpsv, "'=");
	    switch (mp->mad_type) {
	    case MAD_NULL:
		sv_catpv(tmpsv, "NULL");
		Perl_dump_indent(aTHX_ level, file, "%s\n", SvPVX(tmpsv));
		break;
	    case MAD_PV:
		sv_catpv(tmpsv, "<");
		sv_catpvn(tmpsv, (char*)mp->mad_val, mp->mad_vlen);
		sv_catpv(tmpsv, ">");
		Perl_dump_indent(aTHX_ level, file, "%s\n", SvPVX(tmpsv));
		break;
	    case MAD_OP:
		if ((OP*)mp->mad_val) {
		    Perl_dump_indent(aTHX_ level, file, "%s\n", SvPVX(tmpsv));
		    do_op_dump(level, file, (OP*)mp->mad_val);
		}
		break;
	    default:
		sv_catpv(tmpsv, "(UNK)");
		Perl_dump_indent(aTHX_ level, file, "%s\n", SvPVX(tmpsv));
		break;
	    }
	    mp = mp->mad_next;
	}
	level--;
	Perl_dump_indent(aTHX_ level, file, "}\n");
a936 1
#endif
a950 5
#ifdef PERL_MAD
		/* FIXME - is this making unwarranted assumptions about the
		   UTF-8 cleanliness of the dump file handle?  */
		SvUTF8_on(tmpsv);
#endif
d961 13
d977 3
d983 1
a983 1
	Perl_dump_indent(aTHX_ level, file, "SV = %s\n", SvPEEK(cSVOPo_sv));
d986 4
d1014 2
d1066 1
a1066 1
	for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling)
a1093 3

    PERL_ARGS_ASSERT_GV_DUMP;

d1110 1
a1110 1
    PerlIO_putc(Perl_debug_log, '\n');
d1120 1
a1120 1
#include "mg_names.c"
d1231 1
a1231 1
            PerlIO_putc(file, '\n');
d1274 1
a1274 1
	PerlIO_putc(file, '\n');
d1289 1
a1289 1
	PerlIO_putc(file, '\n');
d1313 1
a1313 1
	PerlIO_putc(file, '\n');
d1331 1
a1331 1
    {SVf_IsCOW, "IsCOW,"},
a1332 1
    {SVf_AMAGIC, "OVERLOAD,"},
d1351 1
a1351 1
    {CVf_HASEVAL, "HASEVAL"},
d1353 2
d1362 1
a1369 1
    {GVf_IN_PAD, "IN_PAD,"}
d1387 1
d1389 1
a1418 1
    {PREGf_CANY_SEEN,       "CANY_SEEN,"},
a1420 1
    {PREGf_ANCH_BOL,        "ANCH_BOL,"},
d1426 10
a1438 1
    dVAR;
d1462 1
a1462 3
    if (!((flags & SVpad_NAME) == SVpad_NAME
	  && (type == SVt_PVMG || type == SVt_PVNV))) {
	if ((flags & SVs_PADMY) && (flags & SVs_PADSTALE))
d1464 1
a1464 3
    }
    if (!((flags & SVpad_NAME) == SVpad_NAME && type == SVt_PVMG)) {
	if (!(flags & SVs_PADMY) && (flags & SVs_PADTMP))
a1465 2
	if (flags & SVs_PADMY)	sv_catpv(d, "PADMY,");
    }
d1471 1
d1506 1
a1506 1
	/* FALL THROUGH */
d1515 1
a1515 5
	if (SvPAD_TYPED(sv))	sv_catpv(d, "TYPED,");
	if (SvPAD_OUR(sv))	sv_catpv(d, "OUR,");
	/* FALL THROUGH */
    case SVt_PVNV:
	if (SvPAD_STATE(sv))	sv_catpv(d, "STATE,");
a1517 1
	if (AvPAD_NAMELIST(sv))	sv_catpvs(d, "NAMELIST,");
a1567 3
#ifdef PERL_OLD_COPY_ON_WRITE
	               || SvIsCOW(sv)
#endif
d1572 1
a1572 7
#ifdef PERL_OLD_COPY_ON_WRITE
	if (SvIsCOW_shared_hash(sv))
	    PerlIO_printf(file, "  (HASH)");
	else if (SvIsCOW_normal(sv))
	    PerlIO_printf(file, "  (COW from 0x%"UVxf")", (UV)SvUVX(sv));
#endif
	PerlIO_putc(file, '\n');
d1575 1
a1575 7
    if ((type == SVt_PVNV || type == SVt_PVMG)
	&& (SvFLAGS(sv) & SVpad_NAME) == SVpad_NAME) {
	Perl_dump_indent(aTHX_ level, file, "  COP_LOW = %"UVuf"\n",
			 (UV) COP_SEQ_RANGE_LOW(sv));
	Perl_dump_indent(aTHX_ level, file, "  COP_HIGH = %"UVuf"\n",
			 (UV) COP_SEQ_RANGE_HIGH(sv));
    } else if ((type >= SVt_PVNV && type != SVt_PVAV && type != SVt_PVHV
d1579 3
a1581 8
	STORE_NUMERIC_LOCAL_SET_STANDARD();
	/* %Vg doesn't work? --jhi */
#ifdef USE_LONG_DOUBLE
	Perl_dump_indent(aTHX_ level, file, "  NV = %.*" PERL_PRIgldbl "\n", LDBL_DIG, SvNVX(sv));
#else
	Perl_dump_indent(aTHX_ level, file, "  NV = %.*g\n", DBL_DIG, SvNVX(sv));
#endif
	RESTORE_NUMERIC_LOCAL();
d1634 1
a1634 1
#ifdef PERL_NEW_COPY_ON_WRITE
d1645 1
a1645 9
	if (type == SVt_PVMG && SvPAD_OUR(sv)) {
	    HV * const ost = SvOURSTASH(sv);
	    if (ost)
		do_hv_dump(level, file, "  OURSTASH", ost);
	} else if (SvTYPE(sv) == SVt_PVAV && AvPAD_NAMELIST(sv)) {
	    Perl_dump_indent(aTHX_ level, file, "  MAXNAMED = %"UVuf"\n",
				   (UV)PadnamelistMAXNAMED(sv));
	} else {
	    if (SvMAGIC(sv))
a1646 1
	}
d1665 1
a1665 1
	    PerlIO_putc(file, '\n');
d1668 1
a1668 4
	/* arylen is stored in magic, and padnamelists use SvMAGIC for
	   something else. */
	if (!AvPAD_NAMELIST(sv))
	    Perl_dump_indent(aTHX_ level, file, "  ARYLEN = 0x%"UVxf"\n",
d1726 1
a1726 1
	    PerlIO_putc(file, ')');
d1745 1
a1745 1
	    PerlIO_putc(file, '\n');
d1748 1
a1748 1
	PerlIO_putc(file, '\n');
d1784 1
a1784 1
            PerlIO_putc(file, '\n');
d1939 1
a1939 1
	/* FALL THROUGH */
d1978 5
a1982 3
	Perl_dump_indent(aTHX_ level, file, "  PADLIST = 0x%"UVxf"\n", PTR2UV(CvPADLIST(sv)));
	if (nest < maxnest) {
	    do_dump_pad(level+1, file, CvPADLIST(sv), 0);
d1984 2
d2002 2
a2003 1
	if (nest < maxnest && (CvCLONE(sv) || CvCLONED(sv)))
d2015 1
a2015 1
	    if (LvTYPE(sv) != 't' && LvTYPE(sv) != 'T')
d2031 1
d2043 4
a2048 1
	Perl_dump_indent(aTHX_ level, file, "    FLAGS = 0x%"UVxf"\n", (UV)GvFLAGS(sv));
a2192 2
    dVAR;

a2203 1
    dVAR;
d2215 2
d2234 2
d2238 1
a2238 1
        OP_ENTRY_PROBE(OP_NAME(PL_op));
d2247 233
a2482 2
    dVAR;

d2503 1
a2503 1
	if (cGVOPo_gv) {
a2504 5
#ifdef PERL_MAD
	    /* FIXME - is this making unwarranted assumptions about the
	       UTF-8 cleanliness of the dump file handle?  */
	    SvUTF8_on(sv);
#endif
d2509 8
a2520 3
    {
        int count;

d2524 3
a2526 2
        count = 1;
        goto dump_padop;
d2528 7
a2534 26
        count = o->op_private & OPpPADRANGE_COUNTMASK;
    dump_padop:
	/* print the lexical's name */
        {
            CV * const cv = deb_curcv(cxstack_ix);
            SV *sv;
            PAD * comppad = NULL;
            int i;

            if (cv) {
                PADLIST * const padlist = CvPADLIST(cv);
                comppad = *PadlistARRAY(padlist);
            }
            PerlIO_printf(Perl_debug_log, "(");
            for (i = 0; i < count; i++) {
                if (comppad &&
                        (sv = *av_fetch(comppad, o->op_targ + i, FALSE)))
                    PerlIO_printf(Perl_debug_log, "%s", SvPV_nolen_const(sv));
                else
                    PerlIO_printf(Perl_debug_log, "[%"UVuf"]",
                            (UV)o->op_targ+i);
                if (i < count-1)
                    PerlIO_printf(Perl_debug_log, ",");
            }
            PerlIO_printf(Perl_debug_log, ")");
        }
a2535 1
    }
d2545 1
a2545 1
S_deb_curcv(pTHX_ const I32 ix)
d2547 19
a2565 12
    dVAR;
    const PERL_CONTEXT * const cx = &cxstack[ix];
    if (CxTYPE(cx) == CXt_SUB || CxTYPE(cx) == CXt_FORMAT)
        return cx->blk_sub.cv;
    else if (CxTYPE(cx) == CXt_EVAL && !CxTRYBLOCK(cx))
        return cx->blk_eval.cv;
    else if (ix == 0 && PL_curstackinfo->si_type == PERLSI_MAIN)
        return PL_main_cv;
    else if (ix <= 0)
        return NULL;
    else
        return deb_curcv(ix - 1);
a2570 2
    dVAR;

a2581 2
    dVAR;

a2593 1
    dVAR;
d2605 1
a2605 1
#ifdef PERL_MAD
a2606 697
 *    XML variants of most of the above routines
 */

STATIC void
S_xmldump_attr(pTHX_ I32 level, PerlIO *file, const char* pat, ...)
{
    va_list args;

    PERL_ARGS_ASSERT_XMLDUMP_ATTR;

    PerlIO_printf(file, "\n    ");
    va_start(args, pat);
    xmldump_vindent(level, file, pat, &args);
    va_end(args);
}


void
Perl_xmldump_indent(pTHX_ I32 level, PerlIO *file, const char* pat, ...)
{
    va_list args;
    PERL_ARGS_ASSERT_XMLDUMP_INDENT;
    va_start(args, pat);
    xmldump_vindent(level, file, pat, &args);
    va_end(args);
}

void
Perl_xmldump_vindent(pTHX_ I32 level, PerlIO *file, const char* pat, va_list *args)
{
    PERL_ARGS_ASSERT_XMLDUMP_VINDENT;

    PerlIO_printf(file, "%*s", (int)(level*PL_dumpindent), "");
    PerlIO_vprintf(file, pat, *args);
}

void
Perl_xmldump_all(pTHX)
{
    xmldump_all_perl(FALSE);
}

void
Perl_xmldump_all_perl(pTHX_ bool justperl PERL_UNUSED_DECL)
{
    PerlIO_setlinebuf(PL_xmlfp);
    if (PL_main_root)
	op_xmldump(PL_main_root);
    /* someday we might call this, when it outputs XML: */
    /* xmldump_packsubs_perl(PL_defstash, justperl); */
    if (PL_xmlfp != (PerlIO*)PerlIO_stdout())
	PerlIO_close(PL_xmlfp);
    PL_xmlfp = 0;
}

void
Perl_xmldump_packsubs(pTHX_ const HV *stash)
{
    PERL_ARGS_ASSERT_XMLDUMP_PACKSUBS;
    xmldump_packsubs_perl(stash, FALSE);
}

void
Perl_xmldump_packsubs_perl(pTHX_ const HV *stash, bool justperl)
{
    I32	i;
    HE	*entry;

    PERL_ARGS_ASSERT_XMLDUMP_PACKSUBS_PERL;

    if (!HvARRAY(stash))
	return;
    for (i = 0; i <= (I32) HvMAX(stash); i++) {
	for (entry = HvARRAY(stash)[i]; entry; entry = HeNEXT(entry)) {
	    GV *gv = MUTABLE_GV(HeVAL(entry));
	    HV *hv;
	    if (SvTYPE(gv) != SVt_PVGV || !GvGP(gv))
		continue;
	    if (GvCVu(gv))
		xmldump_sub_perl(gv, justperl);
	    if (GvFORM(gv))
		xmldump_form(gv);
	    if (HeKEY(entry)[HeKLEN(entry)-1] == ':'
		&& (hv = GvHV(gv)) && hv != PL_defstash)
		xmldump_packsubs_perl(hv, justperl);	/* nested package */
	}
    }
}

void
Perl_xmldump_sub(pTHX_ const GV *gv)
{
    PERL_ARGS_ASSERT_XMLDUMP_SUB;
    xmldump_sub_perl(gv, FALSE);
}

void
Perl_xmldump_sub_perl(pTHX_ const GV *gv, bool justperl)
{
    SV * sv;

    PERL_ARGS_ASSERT_XMLDUMP_SUB_PERL;

    if (justperl && (CvISXSUB(GvCV(gv)) || !CvROOT(GvCV(gv))))
	return;

    sv = sv_newmortal();
    gv_fullname3(sv, gv, NULL);
    Perl_xmldump_indent(aTHX_ 0, PL_xmlfp, "\nSUB %s = ", SvPVX(sv));
    if (CvXSUB(GvCV(gv)))
	Perl_xmldump_indent(aTHX_ 0, PL_xmlfp, "(xsub 0x%"UVxf" %d)\n",
	    PTR2UV(CvXSUB(GvCV(gv))),
	    (int)CvXSUBANY(GvCV(gv)).any_i32);
    else if (CvROOT(GvCV(gv)))
	op_xmldump(CvROOT(GvCV(gv)));
    else
	Perl_xmldump_indent(aTHX_ 0, PL_xmlfp, "<undef>\n");
}

void
Perl_xmldump_form(pTHX_ const GV *gv)
{
    SV * const sv = sv_newmortal();

    PERL_ARGS_ASSERT_XMLDUMP_FORM;

    gv_fullname3(sv, gv, NULL);
    Perl_xmldump_indent(aTHX_ 0, PL_xmlfp, "\nFORMAT %s = ", SvPVX(sv));
    if (CvROOT(GvFORM(gv)))
	op_xmldump(CvROOT(GvFORM(gv)));
    else
	Perl_xmldump_indent(aTHX_ 0, PL_xmlfp, "<undef>\n");
}

void
Perl_xmldump_eval(pTHX)
{
    op_xmldump(PL_eval_root);
}

char *
Perl_sv_catxmlsv(pTHX_ SV *dsv, SV *ssv)
{
    PERL_ARGS_ASSERT_SV_CATXMLSV;
    return sv_catxmlpvn(dsv, SvPVX(ssv), SvCUR(ssv), SvUTF8(ssv));
}

char *
Perl_sv_catxmlpv(pTHX_ SV *dsv, const char *pv, int utf8)
{
    PERL_ARGS_ASSERT_SV_CATXMLPV;
    return sv_catxmlpvn(dsv, pv, strlen(pv), utf8);
}

char *
Perl_sv_catxmlpvn(pTHX_ SV *dsv, const char *pv, STRLEN len, int utf8)
{
    unsigned int c;
    const char * const e = pv + len;
    const char * const start = pv;
    STRLEN dsvcur;
    STRLEN cl;

    PERL_ARGS_ASSERT_SV_CATXMLPVN;

    sv_catpvs(dsv,"");
    dsvcur = SvCUR(dsv);	/* in case we have to restart */

  retry:
    while (pv < e) {
	if (utf8) {
	    c = utf8_to_uvchr_buf((U8*)pv, (U8*)e, &cl);
	    if (cl == 0) {
		SvCUR(dsv) = dsvcur;
		pv = start;
		utf8 = 0;
		goto retry;
	    }
	}
	else
	    c = (*pv & 255);

        if (isCNTRL_L1(c)
            && c != '\t'
            && c != '\n'
            && c != '\r'
            && c != LATIN1_TO_NATIVE(0x85))
        {
	    Perl_sv_catpvf(aTHX_ dsv, "STUPIDXML(#x%X)", c);
        }
        else switch (c) {
	case '<':
	    sv_catpvs(dsv, "&lt;");
	    break;
	case '>':
	    sv_catpvs(dsv, "&gt;");
	    break;
	case '&':
	    sv_catpvs(dsv, "&amp;");
	    break;
	case '"':
	    sv_catpvs(dsv, "&#34;");
	    break;
	default:
	    if (c < 0xD800) {
		if (! isPRINT(c)) {
		    Perl_sv_catpvf(aTHX_ dsv, "&#x%X;", c);
		}
		else {
		    const char string = (char) c;
		    sv_catpvn(dsv, &string, 1);
		}
		break;
	    }
	    if ((c >= 0xD800 && c <= 0xDB7F) ||
		(c >= 0xDC00 && c <= 0xDFFF) ||
		(c >= 0xFFF0 && c <= 0xFFFF) ||
		 c > 0x10ffff)
		Perl_sv_catpvf(aTHX_ dsv, "STUPIDXML(#x%X)", c);
	    else
		Perl_sv_catpvf(aTHX_ dsv, "&#x%X;", c);
	}

	if (utf8)
	    pv += UTF8SKIP(pv);
	else
	    pv++;
    }

    return SvPVX(dsv);
}

char *
Perl_sv_xmlpeek(pTHX_ SV *sv)
{
    SV * const t = sv_newmortal();
    STRLEN n_a;
    int unref = 0;

    PERL_ARGS_ASSERT_SV_XMLPEEK;

    sv_utf8_upgrade(t);
    sv_setpvs(t, "");
    /* retry: */
    if (!sv) {
	sv_catpv(t, "VOID=\"\"");
	goto finish;
    }
    else if (sv == (const SV *)0x55555555 || ((char)SvTYPE(sv)) == 'U') {
	sv_catpv(t, "WILD=\"\"");
	goto finish;
    }
    else if (sv == &PL_sv_undef || sv == &PL_sv_no || sv == &PL_sv_yes || sv == &PL_sv_placeholder) {
	if (sv == &PL_sv_undef) {
	    sv_catpv(t, "SV_UNDEF=\"1\"");
	    if (!(SvFLAGS(sv) & (SVf_OK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		SvREADONLY(sv))
		goto finish;
	}
	else if (sv == &PL_sv_no) {
	    sv_catpv(t, "SV_NO=\"1\"");
	    if (!(SvFLAGS(sv) & (SVf_ROK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		!(~SvFLAGS(sv) & (SVf_POK|SVf_NOK|SVf_READONLY|
				  SVp_POK|SVp_NOK)) &&
		SvCUR(sv) == 0 &&
		SvNVX(sv) == 0.0)
		goto finish;
	}
	else if (sv == &PL_sv_yes) {
	    sv_catpv(t, "SV_YES=\"1\"");
	    if (!(SvFLAGS(sv) & (SVf_ROK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		!(~SvFLAGS(sv) & (SVf_POK|SVf_NOK|SVf_READONLY|
				  SVp_POK|SVp_NOK)) &&
		SvCUR(sv) == 1 &&
		SvPVX(sv) && *SvPVX(sv) == '1' &&
		SvNVX(sv) == 1.0)
		goto finish;
	}
	else {
	    sv_catpv(t, "SV_PLACEHOLDER=\"1\"");
	    if (!(SvFLAGS(sv) & (SVf_OK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		SvREADONLY(sv))
		goto finish;
	}
	sv_catpv(t, " XXX=\"\" ");
    }
    else if (SvREFCNT(sv) == 0) {
	sv_catpv(t, " refcnt=\"0\"");
	unref++;
    }
    else if (DEBUG_R_TEST_) {
	int is_tmp = 0;
	SSize_t ix;
	/* is this SV on the tmps stack? */
	for (ix=PL_tmps_ix; ix>=0; ix--) {
	    if (PL_tmps_stack[ix] == sv) {
		is_tmp = 1;
		break;
	    }
	}
	if (SvREFCNT(sv) > 1)
	    Perl_sv_catpvf(aTHX_ t, " DRT=\"<%"UVuf"%s>\"", (UV)SvREFCNT(sv),
		    is_tmp ? "T" : "");
	else if (is_tmp)
	    sv_catpv(t, " DRT=\"<T>\"");
    }

    if (SvROK(sv)) {
	sv_catpv(t, " ROK=\"\"");
    }
    switch (SvTYPE(sv)) {
    default:
	sv_catpv(t, " FREED=\"1\"");
	goto finish;

    case SVt_NULL:
	sv_catpv(t, " UNDEF=\"1\"");
	goto finish;
    case SVt_IV:
	sv_catpv(t, " IV=\"");
	break;
    case SVt_NV:
	sv_catpv(t, " NV=\"");
	break;
    case SVt_PV:
	sv_catpv(t, " PV=\"");
	break;
    case SVt_PVIV:
	sv_catpv(t, " PVIV=\"");
	break;
    case SVt_PVNV:
	sv_catpv(t, " PVNV=\"");
	break;
    case SVt_PVMG:
	sv_catpv(t, " PVMG=\"");
	break;
    case SVt_PVLV:
	sv_catpv(t, " PVLV=\"");
	break;
    case SVt_PVAV:
	sv_catpv(t, " AV=\"");
	break;
    case SVt_PVHV:
	sv_catpv(t, " HV=\"");
	break;
    case SVt_PVCV:
	if (CvGV(sv))
	    Perl_sv_catpvf(aTHX_ t, " CV=\"(%s)\"", GvNAME(CvGV(sv)));
	else
	    sv_catpv(t, " CV=\"()\"");
	goto finish;
    case SVt_PVGV:
	sv_catpv(t, " GV=\"");
	break;
    case SVt_INVLIST:
	sv_catpv(t, " DUMMY=\"");
	break;
    case SVt_REGEXP:
	sv_catpv(t, " REGEXP=\"");
	break;
    case SVt_PVFM:
	sv_catpv(t, " FM=\"");
	break;
    case SVt_PVIO:
	sv_catpv(t, " IO=\"");
	break;
    }

    if (SvPOKp(sv)) {
	if (SvPVX(sv)) {
	    sv_catxmlsv(t, sv);
	}
    }
    else if (SvNOKp(sv)) {
	STORE_NUMERIC_LOCAL_SET_STANDARD();
	Perl_sv_catpvf(aTHX_ t, "%"NVgf"",SvNVX(sv));
	RESTORE_NUMERIC_LOCAL();
    }
    else if (SvIOKp(sv)) {
	if (SvIsUV(sv))
	    Perl_sv_catpvf(aTHX_ t, "%"UVuf"", (UV)SvUVX(sv));
	else
            Perl_sv_catpvf(aTHX_ t, "%"IVdf"", (IV)SvIVX(sv));
    }
    else
	sv_catpv(t, "");
    sv_catpv(t, "\"");

  finish:
    while (unref--)
	sv_catpv(t, ")");
    return SvPV(t, n_a);
}

void
Perl_do_pmop_xmldump(pTHX_ I32 level, PerlIO *file, const PMOP *pm)
{
    PERL_ARGS_ASSERT_DO_PMOP_XMLDUMP;

    if (!pm) {
	Perl_xmldump_indent(aTHX_ level, file, "<pmop/>\n");
	return;
    }
    Perl_xmldump_indent(aTHX_ level, file, "<pmop \n");
    level++;
    if (PM_GETRE(pm)) {
	REGEXP *const r = PM_GETRE(pm);
	SV * const tmpsv = newSVpvn_utf8("", 0, TRUE);
	sv_catxmlsv(tmpsv, MUTABLE_SV(r));
	Perl_xmldump_indent(aTHX_ level, file, "pre=\"%s\"\n",
	     SvPVX(tmpsv));
	SvREFCNT_dec_NN(tmpsv);
	Perl_xmldump_indent(aTHX_ level, file, "when=\"%s\"\n",
	     (pm->op_private & OPpRUNTIME) ? "RUN" : "COMP");
    }
    else
	Perl_xmldump_indent(aTHX_ level, file, "pre=\"\" when=\"RUN\"\n");
    if (pm->op_pmflags || (PM_GETRE(pm) && RX_CHECK_SUBSTR(PM_GETRE(pm)))) {
	SV * const tmpsv = pm_description(pm);
	Perl_xmldump_indent(aTHX_ level, file, "pmflags=\"%s\"\n", SvCUR(tmpsv) ? SvPVX(tmpsv) + 1 : "");
	SvREFCNT_dec_NN(tmpsv);
    }

    level--;
    if (pm->op_type != OP_PUSHRE && pm->op_pmreplrootu.op_pmreplroot) {
	Perl_xmldump_indent(aTHX_ level, file, ">\n");
	Perl_xmldump_indent(aTHX_ level+1, file, "<pm_repl>\n");
	do_op_xmldump(level+2, file, pm->op_pmreplrootu.op_pmreplroot);
	Perl_xmldump_indent(aTHX_ level+1, file, "</pm_repl>\n");
	Perl_xmldump_indent(aTHX_ level, file, "</pmop>\n");
    }
    else
	Perl_xmldump_indent(aTHX_ level, file, "/>\n");
}

void
Perl_pmop_xmldump(pTHX_ const PMOP *pm)
{
    do_pmop_xmldump(0, PL_xmlfp, pm);
}

void
Perl_do_op_xmldump(pTHX_ I32 level, PerlIO *file, const OP *o)
{
    UV      seq;
    int     contents = 0;
    const OPCODE optype = o->op_type;

    PERL_ARGS_ASSERT_DO_OP_XMLDUMP;

    if (!o)
	return;
    seq = sequence_num(o);
    Perl_xmldump_indent(aTHX_ level, file,
	"<op_%s seq=\"%"UVuf" -> ",
	     OP_NAME(o),
	              seq);
    level++;
    if (o->op_next)
	PerlIO_printf(file, seq ? "%"UVuf"\"" : "(%"UVuf")\"",
		      sequence_num(o->op_next));
    else
	PerlIO_printf(file, "DONE\"");

    if (o->op_targ) {
	if (optype == OP_NULL)
	{
	    PerlIO_printf(file, " was=\"%s\"", PL_op_name[o->op_targ]);
	    if (o->op_targ == OP_NEXTSTATE)
	    {
		if (CopLINE(cCOPo))
		    PerlIO_printf(file, " line=\"%"UVuf"\"",
				     (UV)CopLINE(cCOPo));
		if (CopSTASHPV(cCOPo))
		    PerlIO_printf(file, " package=\"%s\"",
				     CopSTASHPV(cCOPo));
		if (CopLABEL(cCOPo))
		    PerlIO_printf(file, " label=\"%s\"",
				     CopLABEL(cCOPo));
	    }
	}
	else
	    PerlIO_printf(file, " targ=\"%ld\"", (long)o->op_targ);
    }
#ifdef DUMPADDR
    PerlIO_printf(file, " addr=\"0x%"UVxf" => 0x%"UVxf"\"", (UV)o, (UV)o->op_next);
#endif

    DUMP_OP_FLAGS(o,1,0,file);
    DUMP_OP_PRIVATE(o,1,0,file);

    switch (optype) {
    case OP_AELEMFAST:
	if (o->op_flags & OPf_SPECIAL) {
	    break;
	}
    case OP_GVSV:
    case OP_GV:
#ifdef USE_ITHREADS
	S_xmldump_attr(aTHX_ level, file, "padix=\"%" IVdf "\"", (IV)cPADOPo->op_padix);
#else
	if (cSVOPo->op_sv) {
	    SV * const tmpsv1 = newSVpvn_utf8(NULL, 0, TRUE);
	    SV * const tmpsv2 = newSVpvn_utf8("", 0, TRUE);
	    char *s;
	    STRLEN len;
	    ENTER;
	    SAVEFREESV(tmpsv1);
	    SAVEFREESV(tmpsv2);
	    gv_fullname3(tmpsv1, MUTABLE_GV(cSVOPo->op_sv), NULL);
	    s = SvPV(tmpsv1,len);
	    sv_catxmlpvn(tmpsv2, s, len, 1);
	    S_xmldump_attr(aTHX_ level, file, "gv=\"%s\"", SvPV(tmpsv2, len));
	    LEAVE;
	}
	else
	    S_xmldump_attr(aTHX_ level, file, "gv=\"NULL\"");
#endif
	break;
    case OP_CONST:
    case OP_HINTSEVAL:
    case OP_METHOD_NAMED:
#ifndef USE_ITHREADS
	/* with ITHREADS, consts are stored in the pad, and the right pad
	 * may not be active here, so skip */
	S_xmldump_attr(aTHX_ level, file, "%s", sv_xmlpeek(cSVOPo_sv));
#endif
	break;
    case OP_ANONCODE:
	if (!contents) {
	    contents = 1;
	    PerlIO_printf(file, ">\n");
	}
	do_op_xmldump(level+1, file, CvROOT(cSVOPo_sv));
	break;
    case OP_NEXTSTATE:
    case OP_DBSTATE:
	if (CopLINE(cCOPo))
	    S_xmldump_attr(aTHX_ level, file, "line=\"%"UVuf"\"",
			     (UV)CopLINE(cCOPo));
	if (CopSTASHPV(cCOPo))
	    S_xmldump_attr(aTHX_ level, file, "package=\"%s\"",
			     CopSTASHPV(cCOPo));
	if (CopLABEL(cCOPo))
	    S_xmldump_attr(aTHX_ level, file, "label=\"%s\"",
			     CopLABEL(cCOPo));
	break;
    case OP_ENTERLOOP:
	S_xmldump_attr(aTHX_ level, file, "redo=\"");
	if (cLOOPo->op_redoop)
	    PerlIO_printf(file, "%"UVuf"\"", sequence_num(cLOOPo->op_redoop));
	else
	    PerlIO_printf(file, "DONE\"");
	S_xmldump_attr(aTHX_ level, file, "next=\"");
	if (cLOOPo->op_nextop)
	    PerlIO_printf(file, "%"UVuf"\"", sequence_num(cLOOPo->op_nextop));
	else
	    PerlIO_printf(file, "DONE\"");
	S_xmldump_attr(aTHX_ level, file, "last=\"");
	if (cLOOPo->op_lastop)
	    PerlIO_printf(file, "%"UVuf"\"", sequence_num(cLOOPo->op_lastop));
	else
	    PerlIO_printf(file, "DONE\"");
	break;
    case OP_COND_EXPR:
    case OP_RANGE:
    case OP_MAPWHILE:
    case OP_GREPWHILE:
    case OP_OR:
    case OP_AND:
	S_xmldump_attr(aTHX_ level, file, "other=\"");
	if (cLOGOPo->op_other)
	    PerlIO_printf(file, "%"UVuf"\"", sequence_num(cLOGOPo->op_other));
	else
	    PerlIO_printf(file, "DONE\"");
	break;
    case OP_LEAVE:
    case OP_LEAVEEVAL:
    case OP_LEAVESUB:
    case OP_LEAVESUBLV:
    case OP_LEAVEWRITE:
    case OP_SCOPE:
	if (o->op_private & OPpREFCOUNTED)
	    S_xmldump_attr(aTHX_ level, file, "refcnt=\"%"UVuf"\"", (UV)o->op_targ);
	break;
    default:
	break;
    }

    if (PL_madskills && o->op_madprop) {
	char prevkey = '\0';
	SV * const tmpsv = newSVpvn_utf8("", 0, TRUE);
	const MADPROP* mp = o->op_madprop;

	if (!contents) {
	    contents = 1;
	    PerlIO_printf(file, ">\n");
	}
	Perl_xmldump_indent(aTHX_ level, file, "<madprops>\n");
	level++;
	while (mp) {
	    char tmp = mp->mad_key;
	    sv_setpvs(tmpsv,"\"");
	    if (tmp)
		sv_catxmlpvn(tmpsv, &tmp, 1, 0);
	    if ((tmp == '_') || (tmp == '#')) /* '_' '#' whitespace belong to the previous token. */
		sv_catxmlpvn(tmpsv, &prevkey, 1, 0);
	    else
		prevkey = tmp;
	    sv_catpv(tmpsv, "\"");
	    switch (mp->mad_type) {
	    case MAD_NULL:
		sv_catpv(tmpsv, "NULL");
		Perl_xmldump_indent(aTHX_ level, file, "<mad_null key=%s/>\n", SvPVX(tmpsv));
		break;
	    case MAD_PV:
		sv_catpv(tmpsv, " val=\"");
		sv_catxmlpvn(tmpsv, (char*)mp->mad_val, mp->mad_vlen,1);
		sv_catpv(tmpsv, "\"");
		Perl_xmldump_indent(aTHX_ level, file, "<mad_pv key=%s/>\n", SvPVX(tmpsv));
		break;
	    case MAD_SV:
		sv_catpv(tmpsv, " val=\"");
		sv_catxmlsv(tmpsv, MUTABLE_SV(mp->mad_val));
		sv_catpv(tmpsv, "\"");
		Perl_xmldump_indent(aTHX_ level, file, "<mad_sv key=%s/>\n", SvPVX(tmpsv));
		break;
	    case MAD_OP:
		if ((OP*)mp->mad_val) {
		    Perl_xmldump_indent(aTHX_ level, file, "<mad_op key=%s>\n", SvPVX(tmpsv));
		    do_op_xmldump(level+1, file, (OP*)mp->mad_val);
		    Perl_xmldump_indent(aTHX_ level, file, "</mad_op>\n");
		}
		break;
	    default:
		Perl_xmldump_indent(aTHX_ level, file, "<mad_unk key=%s/>\n", SvPVX(tmpsv));
		break;
	    }
	    mp = mp->mad_next;
	}
	level--;
	Perl_xmldump_indent(aTHX_ level, file, "</madprops>\n");

	SvREFCNT_dec_NN(tmpsv);
    }

    switch (optype) {
    case OP_PUSHRE:
    case OP_MATCH:
    case OP_QR:
    case OP_SUBST:
	if (!contents) {
	    contents = 1;
	    PerlIO_printf(file, ">\n");
	}
	do_pmop_xmldump(level, file, cPMOPo);
	break;
    default:
	break;
    }

    if (o->op_flags & OPf_KIDS) {
	OP *kid;
	if (!contents) {
	    contents = 1;
	    PerlIO_printf(file, ">\n");
	}
	for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling)
	    do_op_xmldump(level, file, kid);
    }

    if (contents)
	Perl_xmldump_indent(aTHX_ level-1, file, "</op_%s>\n", OP_NAME(o));
    else
	PerlIO_printf(file, " />\n");
}

void
Perl_op_xmldump(pTHX_ const OP *o)
{
    PERL_ARGS_ASSERT_OP_XMLDUMP;

    do_op_xmldump(0, PL_xmlfp, o);
}
#endif

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a29 1

a31 1
    "BIND",
d35 1
a51 1
    "BIND",
d55 1
d87 4
a90 126


void
Perl_dump_indent(pTHX_ I32 level, PerlIO *file, const char* pat, ...)
{
    va_list args;
    PERL_ARGS_ASSERT_DUMP_INDENT;
    va_start(args, pat);
    dump_vindent(level, file, pat, &args);
    va_end(args);
}

void
Perl_dump_vindent(pTHX_ I32 level, PerlIO *file, const char* pat, va_list *args)
{
    dVAR;
    PERL_ARGS_ASSERT_DUMP_VINDENT;
    PerlIO_printf(file, "%*s", (int)(level*PL_dumpindent), "");
    PerlIO_vprintf(file, pat, *args);
}

void
Perl_dump_all(pTHX)
{
    dump_all_perl(FALSE);
}

void
Perl_dump_all_perl(pTHX_ bool justperl)
{

    dVAR;
    PerlIO_setlinebuf(Perl_debug_log);
    if (PL_main_root)
	op_dump(PL_main_root);
    dump_packsubs_perl(PL_defstash, justperl);
}

void
Perl_dump_packsubs(pTHX_ const HV *stash)
{
    PERL_ARGS_ASSERT_DUMP_PACKSUBS;
    dump_packsubs_perl(stash, FALSE);
}

void
Perl_dump_packsubs_perl(pTHX_ const HV *stash, bool justperl)
{
    dVAR;
    I32	i;

    PERL_ARGS_ASSERT_DUMP_PACKSUBS_PERL;

    if (!HvARRAY(stash))
	return;
    for (i = 0; i <= (I32) HvMAX(stash); i++) {
        const HE *entry;
	for (entry = HvARRAY(stash)[i]; entry; entry = HeNEXT(entry)) {
	    const GV * const gv = (const GV *)HeVAL(entry);
	    if (SvTYPE(gv) != SVt_PVGV || !GvGP(gv))
		continue;
	    if (GvCVu(gv))
		dump_sub_perl(gv, justperl);
	    if (GvFORM(gv))
		dump_form(gv);
	    if (HeKEY(entry)[HeKLEN(entry)-1] == ':') {
		const HV * const hv = GvHV(gv);
		if (hv && (hv != PL_defstash))
		    dump_packsubs_perl(hv, justperl); /* nested package */
	    }
	}
    }
}

void
Perl_dump_sub(pTHX_ const GV *gv)
{
    PERL_ARGS_ASSERT_DUMP_SUB;
    dump_sub_perl(gv, FALSE);
}

void
Perl_dump_sub_perl(pTHX_ const GV *gv, bool justperl)
{
    SV * sv;

    PERL_ARGS_ASSERT_DUMP_SUB_PERL;

    if (justperl && (CvISXSUB(GvCV(gv)) || !CvROOT(GvCV(gv))))
	return;

    sv = sv_newmortal();
    gv_fullname3(sv, gv, NULL);
    Perl_dump_indent(aTHX_ 0, Perl_debug_log, "\nSUB %s = ", SvPVX_const(sv));
    if (CvISXSUB(GvCV(gv)))
	Perl_dump_indent(aTHX_ 0, Perl_debug_log, "(xsub 0x%"UVxf" %d)\n",
	    PTR2UV(CvXSUB(GvCV(gv))),
	    (int)CvXSUBANY(GvCV(gv)).any_i32);
    else if (CvROOT(GvCV(gv)))
	op_dump(CvROOT(GvCV(gv)));
    else
	Perl_dump_indent(aTHX_ 0, Perl_debug_log, "<undef>\n");
}

void
Perl_dump_form(pTHX_ const GV *gv)
{
    SV * const sv = sv_newmortal();

    PERL_ARGS_ASSERT_DUMP_FORM;

    gv_fullname3(sv, gv, NULL);
    Perl_dump_indent(aTHX_ 0, Perl_debug_log, "\nFORMAT %s = ", SvPVX_const(sv));
    if (CvROOT(GvFORM(gv)))
	op_dump(CvROOT(GvFORM(gv)));
    else
	Perl_dump_indent(aTHX_ 0, Perl_debug_log, "<undef>\n");
}

void
Perl_dump_eval(pTHX)
{
    dVAR;
    op_dump(PL_eval_root);
}

d111 1
a111 1
chars above 127 will be escaped using this style; otherwise, only chars above
d113 2
a114 1
common escaped patterns like C<\n>. Otherwise, if PERL_PV_ESCAPE_NOBACKSLASH
d119 1
a119 1
string will be escaped, regardless of max. If the output is to be in hex,
d121 1
a121 1
sequence. Thus the output will either be a single char,
d125 1
a125 1
not a '\\'. This is because regexes very often contain backslashed
d166 1
a166 1
	  || (( u > 127 ) && (flags & PERL_PV_ESCAPE_NONASCII)))
d173 4
a176 1
                                      "%cx{%"UVxf"}", esc, u);
d203 6
a208 1
                        if ( (pv+readsize < end) && isDIGIT((U8)*(pv+readsize)) )
d225 2
a226 2
	    /* If PERL_PV_ESCAPE_NOBACKSLASH is set then bytes in the range
	       128-255 can be appended raw to the dsv. If dsv happens to be
d230 1
a230 1
	       really an array octets, not a string.  */
d248 1
a248 1
double quoted with any double quotes in the string escaped. Otherwise
d254 1
a254 1
string. Note that this happens AFTER it has been quoted.
d257 1
a257 1
quote (if there is one) but before the escaped text. If end_color
d394 1
a394 1
	I32 ix;
d422 5
a426 1
	Perl_sv_catpvf(aTHX_ t, "CV(%s)", CvGV(sv) ? GvNAME(CvGV(sv)) : "");
d479 151
d711 1
a711 1
            if (!(RX_EXTFLAGS(regex) & RXf_NOSCAN))
a788 1
    {OPpCONST_FOLDED, ",FOLDED"},
a808 5
const struct flag_to_name op_exit_names[] = {
    {OPpEXIT_VMSISH, ",EXIT_VMSISH"},
    {OPpHUSH_VMSISH, ",HUSH_VMSISH"}
};

d814 5
d834 2
d845 1
a845 1
    {OP_LEAVE, C_ARRAY_LENGTH(op_leavesub_names), op_leavesub_names },
a850 1
    {OP_EXIT, C_ARRAY_LENGTH(op_exit_names), op_exit_names },
d862 3
d871 1
a871 2
    const struct op_private_by_op *const end
	= op_private_names + C_ARRAY_LENGTH(op_private_names);
d906 1
a912 1
        SvREFCNT_dec_NN(tmpsv);                                            \
d998 5
a1010 1
	SvREFCNT_dec_NN(tmpsv);                                         \
d1046 5
a1050 1
		if (CopSTASHPV(cCOPo))
d1052 9
a1060 2
				     CopSTASHPV(cCOPo));
		if (CopLABEL(cCOPo))
d1062 3
a1064 1
				     CopLABEL(cCOPo));
a1114 2

	SvREFCNT_dec_NN(tmpsv);
d1127 4
a1130 3
		SV * const tmpsv = newSV(0);
		ENTER;
		SAVEFREESV(tmpsv);
d1137 1
d1139 1
a1139 2
				 SvPV_nolen_const(tmpsv));
		LEAVE;
d1160 5
a1164 1
	if (CopSTASHPV(cCOPo))
d1166 13
a1178 4
			     CopSTASHPV(cCOPo));
	if (CopLABEL(cCOPo))
	    Perl_dump_indent(aTHX_ level, file, "LABEL = \"%s\"\n",
			     CopLABEL(cCOPo));
d1235 8
d1253 4
a1256 1
    SV *sv;
d1267 3
a1269 1
    Perl_dump_indent(aTHX_ 1, Perl_debug_log, "GV_NAME = %s", SvPVX_const(sv));
d1272 3
a1274 1
	Perl_dump_indent(aTHX_ 1, Perl_debug_log, "-> %s", SvPVX_const(sv));
d1350 3
d1434 4
a1437 2
        SV * const tmpsv = newSVpvs("");
        PerlIO_printf(file, "\t%s\n", pv_display(tmpsv, hvname, HvNAMELEN_get(sv), 0, 1024));
d1449 5
a1453 2
    if (sv && GvNAME(sv))
	PerlIO_printf(file, "\t\"%s\"\n", GvNAME(sv));
d1465 1
d1467 10
a1476 4
	PerlIO_printf(file, "\t\"");
	if (GvSTASH(sv) && (hvname = HvNAME_get(GvSTASH(sv))))
	    PerlIO_printf(file, "%s\" :: \"", hvname);
	PerlIO_printf(file, "%s\"\n", GvNAME(sv));
d1544 4
a1547 1
const struct flag_to_name regexp_flags_names[] = {
d1553 1
a1553 6
    {RXf_ANCH_BOL,        "ANCH_BOL,"},
    {RXf_ANCH_MBOL,       "ANCH_MBOL,"},
    {RXf_ANCH_SBOL,       "ANCH_SBOL,"},
    {RXf_ANCH_GPOS,       "ANCH_GPOS,"},
    {RXf_GPOS_SEEN,       "GPOS_SEEN,"},
    {RXf_GPOS_FLOAT,      "GPOS_FLOAT,"},
a1555 2
    {RXf_CANY_SEEN,       "CANY_SEEN,"},
    {RXf_NOSCAN,          "NOSCAN,"},
d1571 20
d1634 2
a1635 1
    if (flags & SVp_SCREAM && type != SVt_PVHV && !isGV_with_GP(sv)) {
d1683 1
d1781 2
a1782 1
    if (type <= SVt_PVLV && !isGV_with_GP(sv)) {
d1801 15
a1815 6
	    PerlIO_printf(file, "%s", pv_display(d, ptr, SvCUR(sv),
						 re ? 0 : SvLEN(sv),
						 pvlim));
	    if (SvUTF8(sv)) /* the 6?  \x{....} */
	        PerlIO_printf(file, " [UTF8 \"%s\"]", sv_uni_display(d, sv, 6 * SvCUR(sv), UNI_DISPLAY_QQ));
	    PerlIO_printf(file, "\n");
d1835 3
a1845 2
	    Perl_dump_indent(aTHX_ level, file, "  RARE = %u\n", (U8)BmRARE(sv));
	    Perl_dump_indent(aTHX_ level, file, "  PREVIOUS = %"UVuf"\n", (UV)BmPREVIOUS(sv));
d1863 5
a1867 1
	Perl_dump_indent(aTHX_ level, file, "  ARYLEN = 0x%"UVxf"\n", SvMAGIC(sv) ? PTR2UV(AvARYLEN(sv)) : 0);
d1873 3
a1875 3
	if (nest < maxnest && av_len(MUTABLE_AV(sv)) >= 0) {
	    int count;
	    for (count = 0; count <=  av_len(MUTABLE_AV(sv)) && count < maxnest; count++) {
d1884 7
a1890 1
    case SVt_PVHV:
d1892 2
a1893 1
	if (HvARRAY(sv) && HvUSEDKEYS(sv)) {
d1896 1
a1896 1
#define FREQ_MAX ((int)(sizeof freq / sizeof freq[0] - 1))
d1899 1
a1899 1
	    U32 pow2 = 2, keys = HvUSEDKEYS(sv);
d1941 1
a1941 1
	    theoret = HvUSEDKEYS(sv);
d1947 25
a1971 2
	Perl_dump_indent(aTHX_ level, file, "  KEYS = %"IVdf"\n", (IV)HvUSEDKEYS(sv));
	Perl_dump_indent(aTHX_ level, file, "  FILL = %"IVdf"\n", (IV)HvFILL(sv));
d1992 6
a1997 2
	    if (hvname)
		Perl_dump_indent(aTHX_ level, file, "  NAME = \"%s\"\n", hvname);
d2019 4
a2022 4
			if (*hekp) {
			    sv_catpvs(names, ", \"");
			    sv_catpvn(names, HEK_KEY(*hekp), HEK_LEN(*hekp));
			    sv_catpvs(names, "\"");
d2033 3
a2035 1
		else
d2037 4
a2040 2
		     level, file, "  ENAME = \"%s\"\n", HvENAME_get(sv)
		    );
d2049 5
a2053 4
		/* FIXME - mro_algs kflags can signal a UTF-8 name.  */
		Perl_dump_indent(aTHX_ level, file, "  MRO_WHICH = \"%.*s\" (0x%"UVxf")\n",
				 (int)meta->mro_which->length,
				 meta->mro_which->name,
d2120 1
d2124 2
a2125 1
	    STRLEN len;
d2127 2
a2128 2
	    Perl_dump_indent(aTHX_ level, file, "  AUTOLOAD = \"%.*s\"\n",
			     (int) len, name);
d2131 5
a2135 2
	    Perl_dump_indent(aTHX_ level, file, "  PROTOTYPE = \"%.*s\"\n",
			     (int) CvPROTOLEN(sv), CvPROTO(sv));
d2188 7
a2194 1
			 : CvGV(outside) ? GvNAME(CvGV(outside)) : "UNDEFINED"));
d2215 7
a2221 1
	Perl_dump_indent(aTHX_ level, file, "  NAME = \"%s\"\n", GvNAME(sv));
d2290 2
a2291 1
#define SV_SET_STRINGIFY_REGEXP_FLAGS(d,flags) STMT_START { \
d2293 1
a2293 1
            append_flags(d, flags, regexp_flags_names);     \
d2299 1
a2299 1
            SV_SET_STRINGIFY_REGEXP_FLAGS(d,r->compflags);
d2303 1
a2303 1
            SV_SET_STRINGIFY_REGEXP_FLAGS(d,r->extflags);
a2305 1
#undef SV_SET_STRINGIFY_REGEXP_FLAGS
d2307 8
a2314 1
	    Perl_dump_indent(aTHX_ level, file, "  INTFLAGS = 0x%"UVxf"\n",
d2316 2
a2343 2
	    Perl_dump_indent(aTHX_ level, file, "  ENGINE = 0x%"UVxf"\n",
				PTR2UV(r->engine));
d2346 3
d2369 10
d2403 3
d2763 6
a2768 56
	switch (c) {
	case 0x00:
	case 0x01:
	case 0x02:
	case 0x03:
	case 0x04:
	case 0x05:
	case 0x06:
	case 0x07:
	case 0x08:
	case 0x0b:
	case 0x0c:
	case 0x0e:
	case 0x0f:
	case 0x10:
	case 0x11:
	case 0x12:
	case 0x13:
	case 0x14:
	case 0x15:
	case 0x16:
	case 0x17:
	case 0x18:
	case 0x19:
	case 0x1a:
	case 0x1b:
	case 0x1c:
	case 0x1d:
	case 0x1e:
	case 0x1f:
	case 0x7f:
	case 0x80:
	case 0x81:
	case 0x82:
	case 0x83:
	case 0x84:
	case 0x86:
	case 0x87:
	case 0x88:
	case 0x89:
	case 0x90:
	case 0x91:
	case 0x92:
	case 0x93:
	case 0x94:
	case 0x95:
	case 0x96:
	case 0x97:
	case 0x98:
	case 0x99:
	case 0x9a:
	case 0x9b:
	case 0x9c:
	case 0x9d:
	case 0x9e:
	case 0x9f:
d2770 2
a2771 1
	    break;
d2786 1
a2786 1
		if (c < 32 || c > 127) {
d2877 1
a2877 1
	I32 ix;
d2939 2
a2940 2
    case SVt_BIND:
	sv_catpv(t, " BIND=\"");
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@a28 1
#include "proto.h"
d459 2
a460 1
    else if (sv == (const SV *)0x55555555 || SvTYPE(sv) == 'U') {
d564 1
a564 1
	    SvREFCNT_dec(tmp);
d584 1
a584 1
    if (PL_tainting && SvTAINTED(sv))
d616 9
d628 1
a628 1
	SvREFCNT_dec(tmpsv);
d642 3
d667 1
a667 1
        if (RX_EXTFLAGS(regex) & RXf_TAINTED)
d748 2
a749 2
    {OPpCONST_BARE, ",BARE"},
    {OPpCONST_WARNING, ",WARNING"}
d774 5
a783 1
OP_PRIVATE_ONCE(op_aassign, OPpASSIGN_COMMON, ",COMMON");
a784 1
OP_PRIVATE_ONCE(op_sassign, OPpASSIGN_BACKWARDS, ",BACKWARDS");
a805 1
    {OP_AASSIGN, C_ARRAY_LENGTH(op_aassign_names), op_aassign_names },
d842 125
a1012 59
    if (o->op_flags || o->op_latefree || o->op_latefreed || o->op_attached) {
	SV * const tmpsv = newSVpvs("");
	switch (o->op_flags & OPf_WANT) {
	case OPf_WANT_VOID:
	    sv_catpv(tmpsv, ",VOID");
	    break;
	case OPf_WANT_SCALAR:
	    sv_catpv(tmpsv, ",SCALAR");
	    break;
	case OPf_WANT_LIST:
	    sv_catpv(tmpsv, ",LIST");
	    break;
	default:
	    sv_catpv(tmpsv, ",UNKNOWN");
	    break;
	}
	append_flags(tmpsv, o->op_flags, op_flags_names);
	if (o->op_latefree)
	    sv_catpv(tmpsv, ",LATEFREE");
	if (o->op_latefreed)
	    sv_catpv(tmpsv, ",LATEFREED");
	if (o->op_attached)
	    sv_catpv(tmpsv, ",ATTACHED");
	Perl_dump_indent(aTHX_ level, file, "FLAGS = (%s)\n", SvCUR(tmpsv) ? SvPVX_const(tmpsv) + 1 : "");
	SvREFCNT_dec(tmpsv);
    }
    if (o->op_private) {
	SV * const tmpsv = newSVpvs("");
	if (PL_opargs[optype] & OA_TARGLEX) {
	    if (o->op_private & OPpTARGET_MY)
		sv_catpv(tmpsv, ",TARGET_MY");
	}
	else if (optype == OP_ENTERSUB ||
	    optype == OP_RV2SV ||
	    optype == OP_GVSV ||
	    optype == OP_RV2AV ||
	    optype == OP_RV2HV ||
	    optype == OP_RV2GV ||
	    optype == OP_AELEM ||
	    optype == OP_HELEM )
	{
	    if (optype == OP_ENTERSUB) {
		append_flags(tmpsv, o->op_private, op_entersub_names);
	    }
	    else {
		switch (o->op_private & OPpDEREF) {
		case OPpDEREF_SV:
		    sv_catpv(tmpsv, ",SV");
		    break;
		case OPpDEREF_AV:
		    sv_catpv(tmpsv, ",AV");
		    break;
		case OPpDEREF_HV:
		    sv_catpv(tmpsv, ",HV");
		    break;
		}
		if (o->op_private & OPpMAYBE_LVSUB)
		    sv_catpv(tmpsv, ",MAYBE_LVSUB");
	    }
d1014 2
a1015 25
	    if (optype == OP_AELEM || optype == OP_HELEM) {
		if (o->op_private & OPpLVAL_DEFER)
		    sv_catpv(tmpsv, ",LVAL_DEFER");
	    }
	    else {
		if (o->op_private & HINT_STRICT_REFS)
		    sv_catpv(tmpsv, ",STRICT_REFS");
		if (o->op_private & OPpOUR_INTRO)
		    sv_catpv(tmpsv, ",OUR_INTRO");
	    }
	}
	else if (S_op_private_to_names(aTHX_ tmpsv, optype, o->op_private)) {
	}
	else if (PL_check[optype] != Perl_ck_ftst) {
	    if (OP_IS_FILETEST_ACCESS(o->op_type) && o->op_private & OPpFT_ACCESS)
		sv_catpv(tmpsv, ",FT_ACCESS");
	    if (o->op_private & OPpFT_STACKED)
		sv_catpv(tmpsv, ",FT_STACKED");
	}
	if (o->op_flags & OPf_MOD && o->op_private & OPpLVAL_INTRO)
	    sv_catpv(tmpsv, ",INTRO");
	if (SvCUR(tmpsv))
	    Perl_dump_indent(aTHX_ level, file, "PRIVATE = (%s)\n", SvPVX_const(tmpsv) + 1);
	SvREFCNT_dec(tmpsv);
    }
d1056 1
a1056 1
	SvREFCNT_dec(tmpsv);
d1291 1
a1291 1
		    SvREFCNT_dec(sv);
d1395 1
d1416 2
a1424 1
    {SVphv_REHASH, "REHASH,"},
d1454 1
a1454 1
    {RXf_LOOKBEHIND_SEEN, "LOOKBEHIND_SEEN,"},
d1598 1
a1598 1
	    SvREFCNT_dec(d);
d1603 1
a1603 1
	SvREFCNT_dec(d);
d1657 1
a1657 1
	SvREFCNT_dec(d);
d1661 5
a1665 2
    if ((type <= SVt_PVLV && !isGV_with_GP(sv)) || type == SVt_PVFM) {
	if (SvPVX_const(sv)) {
d1674 1
a1674 1
	    Perl_dump_indent(aTHX_ level, file,"  PV = 0x%"UVxf" ", PTR2UV(SvPVX_const(sv)));
d1677 1
a1677 1
			      pv_display(d, SvPVX_const(sv) - delta, delta, 0,
d1680 3
a1682 1
	    PerlIO_printf(file, "%s", pv_display(d, SvPVX_const(sv), SvCUR(sv), SvLEN(sv), pvlim));
d1687 8
a1694 1
	    Perl_dump_indent(aTHX_ level, file, "  LEN = %"IVdf"\n", (IV)SvLEN(sv));
d1808 11
a1818 2
	Perl_dump_indent(aTHX_ level, file, "  RITER = %"IVdf"\n", (IV)HvRITER_get(sv));
	Perl_dump_indent(aTHX_ level, file, "  EITER = 0x%"UVxf"\n", PTR2UV(HvEITER_get(sv)));
d1924 1
a1924 1
		STRLEN len;
d1933 3
a1935 3
		Perl_dump_indent(aTHX_ level+1, file, "Elt %s ", pv_display(d, keypv, len, 0, pvlim));
		if (SvUTF8(keysv))
		    PerlIO_printf(file, "[UTF8 \"%s\"] ", sv_uni_display(d, keysv, 6 * SvCUR(keysv), UNI_DISPLAY_QQ));
d1938 3
a1940 5
		if (HeKREHASH(he))
		    PerlIO_printf(file, "[REHASH] ");
			PerlIO_printf(file, "HASH = 0x%"UVxf"\n", (UV) hash);
		do_sv_dump(level+1, file, elt, nest+1, maxnest, dumpops, pvlim);
	    }
d1989 4
a1992 1
 	do_gvgv_dump(level, file, "  GVGV::GV", CvGV(sv));
d1994 1
a1994 2
	if (type == SVt_PVCV)
	    Perl_dump_indent(aTHX_ level, file, "  DEPTH = %"IVdf"\n", (IV)CvDEPTH(sv));
a1996 2
	if (type == SVt_PVFM)
	    Perl_dump_indent(aTHX_ level, file, "  LINES = %"IVdf"\n", (IV)FmLINES(sv));
d2027 1
d2096 1
d2098 14
a2111 8
	    struct regexp * const r = (struct regexp *)SvANY(sv);
	    flags = RX_EXTFLAGS((REGEXP*)sv);
	    sv_setpv(d,"");
	    append_flags(d, flags, regexp_flags_names);
	    if (*(SvEND(d) - 1) == ',') {
		SvCUR_set(d, SvCUR(d) - 1);
		SvPVX(d)[SvCUR(d)] = '\0';
	    }
d2113 3
a2115 1
				(UV)flags, SvPVX_const(d));
a2131 2
	    Perl_dump_indent(aTHX_ level, file, "  SEEN_EVALS = %"UVuf"\n",
				(UV)(r->seen_evals));
d2134 4
d2156 3
a2158 1
#ifdef PERL_OLD_COPY_ON_WRITE
d2165 1
a2165 1
    SvREFCNT_dec(d);
d2211 2
d2215 1
d2255 1
a2255 1
	    SvREFCNT_dec(sv);
d2260 4
d2267 5
a2271 1
	{
d2273 23
a2295 13
	CV * const cv = deb_curcv(cxstack_ix);
	SV *sv;
        if (cv) {
	    AV * const padlist = CvPADLIST(cv);
            AV * const comppad = MUTABLE_AV(*av_fetch(padlist, 0, FALSE));
            sv = *av_fetch(comppad, o->op_targ, FALSE);
        } else
            sv = NULL;
        if (sv)
	    PerlIO_printf(Perl_debug_log, "(%s)", SvPV_nolen_const(sv));
        else
	    PerlIO_printf(Perl_debug_log, "[%"UVuf"]", (UV)o->op_targ);
	}
d2297 2
d2664 1
a2664 1
    else if (sv == (const SV *)0x55555555 || SvTYPE(sv) == 'U') {
d2831 1
a2831 1
	SvREFCNT_dec(tmpsv);
d2840 1
a2840 1
	SvREFCNT_dec(tmpsv);
d2866 1
d2885 1
a2885 1
	if (o->op_type == OP_NULL)
a2906 193
    if (o->op_flags) {
	SV * const tmpsv = newSVpvs("");
	switch (o->op_flags & OPf_WANT) {
	case OPf_WANT_VOID:
	    sv_catpv(tmpsv, ",VOID");
	    break;
	case OPf_WANT_SCALAR:
	    sv_catpv(tmpsv, ",SCALAR");
	    break;
	case OPf_WANT_LIST:
	    sv_catpv(tmpsv, ",LIST");
	    break;
	default:
	    sv_catpv(tmpsv, ",UNKNOWN");
	    break;
	}
	if (o->op_flags & OPf_KIDS)
	    sv_catpv(tmpsv, ",KIDS");
	if (o->op_flags & OPf_PARENS)
	    sv_catpv(tmpsv, ",PARENS");
	if (o->op_flags & OPf_STACKED)
	    sv_catpv(tmpsv, ",STACKED");
	if (o->op_flags & OPf_REF)
	    sv_catpv(tmpsv, ",REF");
	if (o->op_flags & OPf_MOD)
	    sv_catpv(tmpsv, ",MOD");
	if (o->op_flags & OPf_SPECIAL)
	    sv_catpv(tmpsv, ",SPECIAL");
	PerlIO_printf(file, " flags=\"%s\"", SvCUR(tmpsv) ? SvPVX(tmpsv) + 1 : "");
	SvREFCNT_dec(tmpsv);
    }
    if (o->op_private) {
	SV * const tmpsv = newSVpvs("");
	if (PL_opargs[o->op_type] & OA_TARGLEX) {
	    if (o->op_private & OPpTARGET_MY)
		sv_catpv(tmpsv, ",TARGET_MY");
	}
	else if (o->op_type == OP_LEAVESUB ||
		 o->op_type == OP_LEAVE ||
		 o->op_type == OP_LEAVESUBLV ||
		 o->op_type == OP_LEAVEWRITE) {
	    if (o->op_private & OPpREFCOUNTED)
		sv_catpv(tmpsv, ",REFCOUNTED");
	}
        else if (o->op_type == OP_AASSIGN) {
	    if (o->op_private & OPpASSIGN_COMMON)
		sv_catpv(tmpsv, ",COMMON");
	}
	else if (o->op_type == OP_SASSIGN) {
	    if (o->op_private & OPpASSIGN_BACKWARDS)
		sv_catpv(tmpsv, ",BACKWARDS");
	}
	else if (o->op_type == OP_TRANS) {
	    if (o->op_private & OPpTRANS_SQUASH)
		sv_catpv(tmpsv, ",SQUASH");
	    if (o->op_private & OPpTRANS_DELETE)
		sv_catpv(tmpsv, ",DELETE");
	    if (o->op_private & OPpTRANS_COMPLEMENT)
		sv_catpv(tmpsv, ",COMPLEMENT");
	    if (o->op_private & OPpTRANS_IDENTICAL)
		sv_catpv(tmpsv, ",IDENTICAL");
	    if (o->op_private & OPpTRANS_GROWS)
		sv_catpv(tmpsv, ",GROWS");
	}
	else if (o->op_type == OP_REPEAT) {
	    if (o->op_private & OPpREPEAT_DOLIST)
		sv_catpv(tmpsv, ",DOLIST");
	}
	else if (o->op_type == OP_ENTERSUB ||
		 o->op_type == OP_RV2SV ||
		 o->op_type == OP_GVSV ||
		 o->op_type == OP_RV2AV ||
		 o->op_type == OP_RV2HV ||
		 o->op_type == OP_RV2GV ||
		 o->op_type == OP_AELEM ||
		 o->op_type == OP_HELEM )
	{
	    if (o->op_type == OP_ENTERSUB) {
		if (o->op_private & OPpENTERSUB_AMPER)
		    sv_catpv(tmpsv, ",AMPER");
		if (o->op_private & OPpENTERSUB_DB)
		    sv_catpv(tmpsv, ",DB");
		if (o->op_private & OPpENTERSUB_HASTARG)
		    sv_catpv(tmpsv, ",HASTARG");
		if (o->op_private & OPpENTERSUB_NOPAREN)
		    sv_catpv(tmpsv, ",NOPAREN");
		if (o->op_private & OPpENTERSUB_INARGS)
		    sv_catpv(tmpsv, ",INARGS");
	    }
	    else {
		switch (o->op_private & OPpDEREF) {
	    case OPpDEREF_SV:
		sv_catpv(tmpsv, ",SV");
		break;
	    case OPpDEREF_AV:
		sv_catpv(tmpsv, ",AV");
		break;
	    case OPpDEREF_HV:
		sv_catpv(tmpsv, ",HV");
		break;
	    }
		if (o->op_private & OPpMAYBE_LVSUB)
		    sv_catpv(tmpsv, ",MAYBE_LVSUB");
	    }
	    if (o->op_type == OP_AELEM || o->op_type == OP_HELEM) {
		if (o->op_private & OPpLVAL_DEFER)
		    sv_catpv(tmpsv, ",LVAL_DEFER");
	    }
	    else {
		if (o->op_private & HINT_STRICT_REFS)
		    sv_catpv(tmpsv, ",STRICT_REFS");
		if (o->op_private & OPpOUR_INTRO)
		    sv_catpv(tmpsv, ",OUR_INTRO");
	    }
	}
	else if (o->op_type == OP_CONST) {
	    if (o->op_private & OPpCONST_BARE)
		sv_catpv(tmpsv, ",BARE");
	    if (o->op_private & OPpCONST_STRICT)
		sv_catpv(tmpsv, ",STRICT");
	    if (o->op_private & OPpCONST_WARNING)
		sv_catpv(tmpsv, ",WARNING");
	    if (o->op_private & OPpCONST_ENTERED)
		sv_catpv(tmpsv, ",ENTERED");
	}
	else if (o->op_type == OP_FLIP) {
	    if (o->op_private & OPpFLIP_LINENUM)
		sv_catpv(tmpsv, ",LINENUM");
	}
	else if (o->op_type == OP_FLOP) {
	    if (o->op_private & OPpFLIP_LINENUM)
		sv_catpv(tmpsv, ",LINENUM");
	}
	else if (o->op_type == OP_RV2CV) {
	    if (o->op_private & OPpLVAL_INTRO)
		sv_catpv(tmpsv, ",INTRO");
	}
	else if (o->op_type == OP_GV) {
	    if (o->op_private & OPpEARLY_CV)
		sv_catpv(tmpsv, ",EARLY_CV");
	}
	else if (o->op_type == OP_LIST) {
	    if (o->op_private & OPpLIST_GUESSED)
		sv_catpv(tmpsv, ",GUESSED");
	}
	else if (o->op_type == OP_DELETE) {
	    if (o->op_private & OPpSLICE)
		sv_catpv(tmpsv, ",SLICE");
	}
	else if (o->op_type == OP_EXISTS) {
	    if (o->op_private & OPpEXISTS_SUB)
		sv_catpv(tmpsv, ",EXISTS_SUB");
	}
	else if (o->op_type == OP_SORT) {
	    if (o->op_private & OPpSORT_NUMERIC)
		sv_catpv(tmpsv, ",NUMERIC");
	    if (o->op_private & OPpSORT_INTEGER)
		sv_catpv(tmpsv, ",INTEGER");
	    if (o->op_private & OPpSORT_REVERSE)
		sv_catpv(tmpsv, ",REVERSE");
	}
	else if (o->op_type == OP_OPEN || o->op_type == OP_BACKTICK) {
	    if (o->op_private & OPpOPEN_IN_RAW)
		sv_catpv(tmpsv, ",IN_RAW");
	    if (o->op_private & OPpOPEN_IN_CRLF)
		sv_catpv(tmpsv, ",IN_CRLF");
	    if (o->op_private & OPpOPEN_OUT_RAW)
		sv_catpv(tmpsv, ",OUT_RAW");
	    if (o->op_private & OPpOPEN_OUT_CRLF)
		sv_catpv(tmpsv, ",OUT_CRLF");
	}
	else if (o->op_type == OP_EXIT) {
	    if (o->op_private & OPpEXIT_VMSISH)
		sv_catpv(tmpsv, ",EXIT_VMSISH");
	    if (o->op_private & OPpHUSH_VMSISH)
		sv_catpv(tmpsv, ",HUSH_VMSISH");
	}
	else if (o->op_type == OP_DIE) {
	    if (o->op_private & OPpHUSH_VMSISH)
		sv_catpv(tmpsv, ",HUSH_VMSISH");
	}
	else if (PL_check[o->op_type] != Perl_ck_ftst) {
	    if (OP_IS_FILETEST_ACCESS(o->op_type) && o->op_private & OPpFT_ACCESS)
		sv_catpv(tmpsv, ",FT_ACCESS");
	    if (o->op_private & OPpFT_STACKED)
		sv_catpv(tmpsv, ",FT_STACKED");
	}
	if (o->op_flags & OPf_MOD && o->op_private & OPpLVAL_INTRO)
	    sv_catpv(tmpsv, ",INTRO");
	if (SvCUR(tmpsv))
	    S_xmldump_attr(aTHX_ level, file, "private=\"%s\"", SvPVX(tmpsv) + 1);
	SvREFCNT_dec(tmpsv);
    }
d2908 4
a2911 1
    switch (o->op_type) {
d3063 1
a3063 1
	SvREFCNT_dec(tmpsv);
d3066 1
a3066 1
    switch (o->op_type) {
d3110 1
a3110 1
 * indent-tabs-mode: t
d3113 1
a3113 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d71 19
a89 1
#define Sequence PL_op_sequence
d234 5
a238 4
using C<\x01F1> style escapes, otherwise only chars above 255 will be
escaped using this style, other non printable chars will use octal or
common escaped patterns like C<\n>. If PERL_PV_ESCAPE_NOBACKSLASH
then all chars below 255 will be treated as printable and 
d242 4
a245 5
string will be escaped, regardles of max. If the string is utf8 and 
the chars value is >255 then it will be returned as a plain hex 
sequence. Thus the output will either be a single char, 
an octal escape sequence, a special escape like C<\n> or a 3 or 
more digit hex value. 
d284 1
a284 1
        const UV u= (isuni) ? utf8_to_uvchr((U8*)pv, &readsize) : (U8)*pv;            
d287 4
a290 1
        if ( ( u > 255 ) || (flags & PERL_PV_ESCAPE_ALL)) {
d323 1
a323 1
                        if ( (pv < end) && isDIGIT((U8)*(pv+readsize)) )
d366 1
a366 1
           
d370 1
a370 1
           
d377 1
a377 1
           
d625 10
d667 1
a667 12
    if (pmflags & PMf_CONST)
	sv_catpv(desc, ",CONST");
    if (pmflags & PMf_KEEP)
	sv_catpv(desc, ",KEEP");
    if (pmflags & PMf_GLOBAL)
	sv_catpv(desc, ",GLOBAL");
    if (pmflags & PMf_CONTINUE)
	sv_catpv(desc, ",CONTINUE");
    if (pmflags & PMf_RETAINT)
	sv_catpv(desc, ",RETAINT");
    if (pmflags & PMf_EVAL)
	sv_catpv(desc, ",EVAL");
d677 4
a680 1
/* An op sequencer.  We visit the ops in the order they're to execute. */
d682 2
a683 2
STATIC void
S_sequence(pTHX_ register const OP *o)
d686 17
a702 1
    const OP *oldop = NULL;
d704 8
a711 2
    if (!o)
	return;
d713 9
a721 4
#ifdef PERL_MAD
    if (o->op_next == 0)
 	return;
#endif
d723 7
a729 2
    if (!Sequence)
	Sequence = newHV();
d731 8
a738 4
    for (; o; o = o->op_next) {
	STRLEN len;
	SV * const op = newSVuv(PTR2UV(o));
	const char * const key = SvPV_const(op, len);
d740 9
a748 2
	if (hv_exists(Sequence, key, len))
	    break;
d750 6
a755 23
	switch (o->op_type) {
	case OP_STUB:
	    if ((o->op_flags & OPf_WANT) != OPf_WANT_LIST) {
		(void)hv_store(Sequence, key, len, newSVuv(++PL_op_seq), 0);
		break;
	    }
	    goto nothin;
	case OP_NULL:
#ifdef PERL_MAD
	    if (o == o->op_next)
		return;
#endif
	    if (oldop && o->op_next)
		continue;
	    break;
	case OP_SCALAR:
	case OP_LINESEQ:
	case OP_SCOPE:
	  nothin:
	    if (oldop && o->op_next)
		continue;
	    (void)hv_store(Sequence, key, len, newSVuv(++PL_op_seq), 0);
	    break;
d757 4
a760 13
	case OP_MAPWHILE:
	case OP_GREPWHILE:
	case OP_AND:
	case OP_OR:
	case OP_DOR:
	case OP_ANDASSIGN:
	case OP_ORASSIGN:
	case OP_DORASSIGN:
	case OP_COND_EXPR:
	case OP_RANGE:
	    (void)hv_store(Sequence, key, len, newSVuv(++PL_op_seq), 0);
	    sequence_tail(cLOGOPo->op_other);
	    break;
d762 23
a784 7
	case OP_ENTERLOOP:
	case OP_ENTERITER:
	    (void)hv_store(Sequence, key, len, newSVuv(++PL_op_seq), 0);
	    sequence_tail(cLOOPo->op_redoop);
	    sequence_tail(cLOOPo->op_nextop);
	    sequence_tail(cLOOPo->op_lastop);
	    break;
d786 23
a808 4
	case OP_SUBST:
	    (void)hv_store(Sequence, key, len, newSVuv(++PL_op_seq), 0);
	    sequence_tail(cPMOPo->op_pmstashstartu.op_pmreplstart);
	    break;
d810 5
a814 4
	case OP_QR:
	case OP_MATCH:
	case OP_HELEM:
	    break;
d816 7
a822 3
	default:
	    (void)hv_store(Sequence, key, len, newSVuv(++PL_op_seq), 0);
	    break;
d824 2
a825 25
	oldop = o;
    }
}

static void
S_sequence_tail(pTHX_ const OP *o)
{
    while (o && (o->op_type == OP_NULL))
	o = o->op_next;
    sequence(o);
}

STATIC UV
S_sequence_num(pTHX_ const OP *o)
{
    dVAR;
    SV     *op,
          **seq;
    const char *key;
    STRLEN  len;
    if (!o) return 0;
    op = newSVuv(PTR2UV(o));
    key = SvPV_const(op, len);
    seq = hv_fetch(Sequence, key, len, 0);
    return seq ? SvUV(*seq): 0;
a836 1
    sequence(o);
d843 1
a843 1
	PerlIO_printf(file, "    ");
d848 2
a849 1
	PerlIO_printf(file, seq ? "%"UVuf"\n" : "(%"UVuf")\n",
d852 1
a852 1
	PerlIO_printf(file, "DONE\n");
d890 1
a890 12
	if (o->op_flags & OPf_KIDS)
	    sv_catpv(tmpsv, ",KIDS");
	if (o->op_flags & OPf_PARENS)
	    sv_catpv(tmpsv, ",PARENS");
	if (o->op_flags & OPf_STACKED)
	    sv_catpv(tmpsv, ",STACKED");
	if (o->op_flags & OPf_REF)
	    sv_catpv(tmpsv, ",REF");
	if (o->op_flags & OPf_MOD)
	    sv_catpv(tmpsv, ",MOD");
	if (o->op_flags & OPf_SPECIAL)
	    sv_catpv(tmpsv, ",SPECIAL");
a905 31
	else if (optype == OP_LEAVESUB ||
		 optype == OP_LEAVE ||
		 optype == OP_LEAVESUBLV ||
		 optype == OP_LEAVEWRITE) {
	    if (o->op_private & OPpREFCOUNTED)
		sv_catpv(tmpsv, ",REFCOUNTED");
	}
        else if (optype == OP_AASSIGN) {
	    if (o->op_private & OPpASSIGN_COMMON)
		sv_catpv(tmpsv, ",COMMON");
	}
	else if (optype == OP_SASSIGN) {
	    if (o->op_private & OPpASSIGN_BACKWARDS)
		sv_catpv(tmpsv, ",BACKWARDS");
	}
	else if (optype == OP_TRANS) {
	    if (o->op_private & OPpTRANS_SQUASH)
		sv_catpv(tmpsv, ",SQUASH");
	    if (o->op_private & OPpTRANS_DELETE)
		sv_catpv(tmpsv, ",DELETE");
	    if (o->op_private & OPpTRANS_COMPLEMENT)
		sv_catpv(tmpsv, ",COMPLEMENT");
	    if (o->op_private & OPpTRANS_IDENTICAL)
		sv_catpv(tmpsv, ",IDENTICAL");
	    if (o->op_private & OPpTRANS_GROWS)
		sv_catpv(tmpsv, ",GROWS");
	}
	else if (optype == OP_REPEAT) {
	    if (o->op_private & OPpREPEAT_DOLIST)
		sv_catpv(tmpsv, ",DOLIST");
	}
d907 7
a913 7
		 optype == OP_RV2SV ||
		 optype == OP_GVSV ||
		 optype == OP_RV2AV ||
		 optype == OP_RV2HV ||
		 optype == OP_RV2GV ||
		 optype == OP_AELEM ||
		 optype == OP_HELEM )
d916 1
a916 12
		if (o->op_private & OPpENTERSUB_AMPER)
		    sv_catpv(tmpsv, ",AMPER");
		if (o->op_private & OPpENTERSUB_DB)
		    sv_catpv(tmpsv, ",DB");
		if (o->op_private & OPpENTERSUB_HASTARG)
		    sv_catpv(tmpsv, ",HASTARG");
		if (o->op_private & OPpENTERSUB_NOPAREN)
		    sv_catpv(tmpsv, ",NOPAREN");
		if (o->op_private & OPpENTERSUB_INARGS)
		    sv_catpv(tmpsv, ",INARGS");
		if (o->op_private & OPpENTERSUB_NOMOD)
		    sv_catpv(tmpsv, ",NOMOD");
d933 1
d945 1
a945 47
	else if (optype == OP_CONST) {
	    if (o->op_private & OPpCONST_BARE)
		sv_catpv(tmpsv, ",BARE");
	    if (o->op_private & OPpCONST_STRICT)
		sv_catpv(tmpsv, ",STRICT");
	    if (o->op_private & OPpCONST_ARYBASE)
		sv_catpv(tmpsv, ",ARYBASE");
	    if (o->op_private & OPpCONST_WARNING)
		sv_catpv(tmpsv, ",WARNING");
	    if (o->op_private & OPpCONST_ENTERED)
		sv_catpv(tmpsv, ",ENTERED");
	}
	else if (optype == OP_FLIP) {
	    if (o->op_private & OPpFLIP_LINENUM)
		sv_catpv(tmpsv, ",LINENUM");
	}
	else if (optype == OP_FLOP) {
	    if (o->op_private & OPpFLIP_LINENUM)
		sv_catpv(tmpsv, ",LINENUM");
	}
	else if (optype == OP_RV2CV) {
	    if (o->op_private & OPpLVAL_INTRO)
		sv_catpv(tmpsv, ",INTRO");
	}
	else if (optype == OP_GV) {
	    if (o->op_private & OPpEARLY_CV)
		sv_catpv(tmpsv, ",EARLY_CV");
	}
	else if (optype == OP_LIST) {
	    if (o->op_private & OPpLIST_GUESSED)
		sv_catpv(tmpsv, ",GUESSED");
	}
	else if (optype == OP_DELETE) {
	    if (o->op_private & OPpSLICE)
		sv_catpv(tmpsv, ",SLICE");
	}
	else if (optype == OP_EXISTS) {
	    if (o->op_private & OPpEXISTS_SUB)
		sv_catpv(tmpsv, ",EXISTS_SUB");
	}
	else if (optype == OP_SORT) {
	    if (o->op_private & OPpSORT_NUMERIC)
		sv_catpv(tmpsv, ",NUMERIC");
	    if (o->op_private & OPpSORT_INTEGER)
		sv_catpv(tmpsv, ",INTEGER");
	    if (o->op_private & OPpSORT_REVERSE)
		sv_catpv(tmpsv, ",REVERSE");
d947 1
a947 21
	else if (optype == OP_OPEN || optype == OP_BACKTICK) {
	    if (o->op_private & OPpOPEN_IN_RAW)
		sv_catpv(tmpsv, ",IN_RAW");
	    if (o->op_private & OPpOPEN_IN_CRLF)
		sv_catpv(tmpsv, ",IN_CRLF");
	    if (o->op_private & OPpOPEN_OUT_RAW)
		sv_catpv(tmpsv, ",OUT_RAW");
	    if (o->op_private & OPpOPEN_OUT_CRLF)
		sv_catpv(tmpsv, ",OUT_CRLF");
	}
	else if (optype == OP_EXIT) {
	    if (o->op_private & OPpEXIT_VMSISH)
		sv_catpv(tmpsv, ",EXIT_VMSISH");
	    if (o->op_private & OPpHUSH_VMSISH)
		sv_catpv(tmpsv, ",HUSH_VMSISH");
	}
	else if (optype == OP_DIE) {
	    if (o->op_private & OPpHUSH_VMSISH)
		sv_catpv(tmpsv, ",HUSH_VMSISH");
	}
	else if (PL_check[optype] != MEMBER_TO_FPTR(Perl_ck_ftst)) {
d1142 1
a1142 42
	{ PERL_MAGIC_sv,             "sv(\\0)" },
	{ PERL_MAGIC_arylen,         "arylen(#)" },
	{ PERL_MAGIC_rhash,          "rhash(%)" },
	{ PERL_MAGIC_pos,            "pos(.)" },
	{ PERL_MAGIC_symtab,         "symtab(:)" },
	{ PERL_MAGIC_backref,        "backref(<)" },
	{ PERL_MAGIC_arylen_p,       "arylen_p(@@)" },
	{ PERL_MAGIC_overload,       "overload(A)" },
	{ PERL_MAGIC_bm,             "bm(B)" },
	{ PERL_MAGIC_regdata,        "regdata(D)" },
	{ PERL_MAGIC_env,            "env(E)" },
	{ PERL_MAGIC_hints,          "hints(H)" },
	{ PERL_MAGIC_isa,            "isa(I)" },
	{ PERL_MAGIC_dbfile,         "dbfile(L)" },
	{ PERL_MAGIC_shared,         "shared(N)" },
	{ PERL_MAGIC_tied,           "tied(P)" },
	{ PERL_MAGIC_sig,            "sig(S)" },
	{ PERL_MAGIC_uvar,           "uvar(U)" },
	{ PERL_MAGIC_overload_elem,  "overload_elem(a)" },
	{ PERL_MAGIC_overload_table, "overload_table(c)" },
	{ PERL_MAGIC_regdatum,       "regdatum(d)" },
	{ PERL_MAGIC_envelem,        "envelem(e)" },
	{ PERL_MAGIC_fm,             "fm(f)" },
	{ PERL_MAGIC_regex_global,   "regex_global(g)" },
	{ PERL_MAGIC_hintselem,      "hintselem(h)" },
	{ PERL_MAGIC_isaelem,        "isaelem(i)" },
	{ PERL_MAGIC_nkeys,          "nkeys(k)" },
	{ PERL_MAGIC_dbline,         "dbline(l)" },
	{ PERL_MAGIC_shared_scalar,  "shared_scalar(n)" },
	{ PERL_MAGIC_collxfrm,       "collxfrm(o)" },
	{ PERL_MAGIC_tiedelem,       "tiedelem(p)" },
	{ PERL_MAGIC_tiedscalar,     "tiedscalar(q)" },
	{ PERL_MAGIC_qr,             "qr(r)" },
	{ PERL_MAGIC_sigelem,        "sigelem(s)" },
	{ PERL_MAGIC_taint,          "taint(t)" },
	{ PERL_MAGIC_uvar_elem,      "uvar_elem(u)" },
	{ PERL_MAGIC_vec,            "vec(v)" },
	{ PERL_MAGIC_vstring,        "vstring(V)" },
	{ PERL_MAGIC_utf8,           "utf8(w)" },
	{ PERL_MAGIC_substr,         "substr(x)" },
	{ PERL_MAGIC_defelem,        "defelem(y)" },
	{ PERL_MAGIC_ext,            "ext(~)" },
d1157 5
a1161 34
 	    const char *s;
 	    if      (v == &PL_vtbl_sv)         s = "sv";
            else if (v == &PL_vtbl_env)        s = "env";
            else if (v == &PL_vtbl_envelem)    s = "envelem";
            else if (v == &PL_vtbl_sig)        s = "sig";
            else if (v == &PL_vtbl_sigelem)    s = "sigelem";
            else if (v == &PL_vtbl_pack)       s = "pack";
            else if (v == &PL_vtbl_packelem)   s = "packelem";
            else if (v == &PL_vtbl_dbline)     s = "dbline";
            else if (v == &PL_vtbl_isa)        s = "isa";
            else if (v == &PL_vtbl_arylen)     s = "arylen";
            else if (v == &PL_vtbl_mglob)      s = "mglob";
            else if (v == &PL_vtbl_nkeys)      s = "nkeys";
            else if (v == &PL_vtbl_taint)      s = "taint";
            else if (v == &PL_vtbl_substr)     s = "substr";
            else if (v == &PL_vtbl_vec)        s = "vec";
            else if (v == &PL_vtbl_pos)        s = "pos";
            else if (v == &PL_vtbl_bm)         s = "bm";
            else if (v == &PL_vtbl_fm)         s = "fm";
            else if (v == &PL_vtbl_uvar)       s = "uvar";
            else if (v == &PL_vtbl_defelem)    s = "defelem";
#ifdef USE_LOCALE_COLLATE
	    else if (v == &PL_vtbl_collxfrm)   s = "collxfrm";
#endif
	    else if (v == &PL_vtbl_amagic)     s = "amagic";
	    else if (v == &PL_vtbl_amagicelem) s = "amagicelem";
	    else if (v == &PL_vtbl_backref)    s = "backref";
	    else if (v == &PL_vtbl_utf8)       s = "utf8";
            else if (v == &PL_vtbl_arylen_p)   s = "arylen_p";
            else if (v == &PL_vtbl_hintselem)  s = "hintselem";
            else if (v == &PL_vtbl_hints)      s = "hints";
	    else			       s = NULL;
	    if (s)
	        Perl_dump_indent(aTHX_ level, file, "    MG_VIRTUAL = &PL_vtbl_%s\n", s);
d1193 3
d1200 6
a1205 3
	    if (mg->mg_type == PERL_MAGIC_regex_global &&
		mg->mg_flags & MGf_MINMATCH)
	        Perl_dump_indent(aTHX_ level, file, "      MINMATCH\n");
d1208 1
a1208 1
	    Perl_dump_indent(aTHX_ level, file, "    MG_OBJ = 0x%"UVxf"\n", 
d1214 1
a1214 1
		    = pv_pretty(dsv, RX_WRAPPED(re), RX_WRAPLEN(re), 
d1243 1
d1245 5
a1249 1
		PerlIO_puts(file, " ???? - please notify IZ");
d1282 8
a1289 1
	PerlIO_printf(file, "\t\"%s\"\n", hvname);
d1323 91
d1433 2
d1441 8
a1448 5
    if (!(flags & SVpad_NAME && (type == SVt_PVMG || type == SVt_PVNV))) {
	if (flags & SVs_PADSTALE)	sv_catpv(d, "PADSTALE,");
    }
    if (!(flags & SVpad_NAME && type == SVt_PVMG)) {
	if (flags & SVs_PADTMP)	sv_catpv(d, "PADTMP,");
d1451 1
a1451 9
    if (flags & SVs_TEMP)	sv_catpv(d, "TEMP,");
    if (flags & SVs_OBJECT)	sv_catpv(d, "OBJECT,");
    if (flags & SVs_GMG)	sv_catpv(d, "GMG,");
    if (flags & SVs_SMG)	sv_catpv(d, "SMG,");
    if (flags & SVs_RMG)	sv_catpv(d, "RMG,");

    if (flags & SVf_IOK)	sv_catpv(d, "IOK,");
    if (flags & SVf_NOK)	sv_catpv(d, "NOK,");
    if (flags & SVf_POK)	sv_catpv(d, "POK,");
d1456 1
a1456 9
    if (flags & SVf_OOK)	sv_catpv(d, "OOK,");
    if (flags & SVf_FAKE)	sv_catpv(d, "FAKE,");
    if (flags & SVf_READONLY)	sv_catpv(d, "READONLY,");
    if (flags & SVf_BREAK)	sv_catpv(d, "BREAK,");

    if (flags & SVf_AMAGIC)	sv_catpv(d, "OVERLOAD,");
    if (flags & SVp_IOK)	sv_catpv(d, "pIOK,");
    if (flags & SVp_NOK)	sv_catpv(d, "pNOK,");
    if (flags & SVp_POK)	sv_catpv(d, "pPOK,");
d1464 2
d1469 1
a1469 10
	if (CvANON(sv))		sv_catpv(d, "ANON,");
	if (CvUNIQUE(sv))	sv_catpv(d, "UNIQUE,");
	if (CvCLONE(sv))	sv_catpv(d, "CLONE,");
	if (CvCLONED(sv))	sv_catpv(d, "CLONED,");
	if (CvCONST(sv))	sv_catpv(d, "CONST,");
	if (CvNODEBUG(sv))	sv_catpv(d, "NODEBUG,");
	if (SvCOMPILED(sv))	sv_catpv(d, "COMPILED,");
	if (CvLVALUE(sv))	sv_catpv(d, "LVALUE,");
	if (CvMETHOD(sv))	sv_catpv(d, "METHOD,");
	if (CvWEAKOUTSIDE(sv))	sv_catpv(d, "WEAKOUTSIDE,");
d1472 1
a1472 5
	if (HvSHAREKEYS(sv))	sv_catpv(d, "SHAREKEYS,");
	if (HvLAZYDEL(sv))	sv_catpv(d, "LAZYDEL,");
	if (HvHASKFLAGS(sv))	sv_catpv(d, "HASKFLAGS,");
	if (HvREHASH(sv))	sv_catpv(d, "REHASH,");
	if (flags & SVphv_CLONEABLE) sv_catpv(d, "CLONEABLE,");
d1477 1
a1477 4
	    if (GvINTRO(sv))	sv_catpv(d, "INTRO,");
	    if (GvMULTI(sv))	sv_catpv(d, "MULTI,");
	    if (GvASSUMECV(sv))	sv_catpv(d, "ASSUMECV,");
	    if (GvIN_PAD(sv))   sv_catpv(d, "IN_PAD,");
d1485 1
a1485 4
		if (GvIMPORTED_SV(sv))	sv_catpv(d, " SV");
		if (GvIMPORTED_AV(sv))	sv_catpv(d, " AV");
		if (GvIMPORTED_HV(sv))	sv_catpv(d, " HV");
		if (GvIMPORTED_CV(sv))	sv_catpv(d, " CV");
a1488 2
	if (SvTAIL(sv))		sv_catpv(d, "TAIL,");
	if (SvVALID(sv))	sv_catpv(d, "VALID,");
d1496 2
d1518 2
d1522 1
a1522 1
	"ALLOCATED at %s:%d %s %s%s; serial %"UVuf"\n",
d1527 1
a1527 1
	sv->sv_debug_cloned ? " (cloned)" : "",
d1532 3
d1547 3
d1551 2
a1552 2
	 && type != SVt_PVCV && !isGV_with_GP(sv) && type != SVt_PVFM
	 && type != SVt_PVIO)
d1570 3
a1572 1
    if ((type == SVt_PVNV || type == SVt_PVMG) && SvFLAGS(sv) & SVpad_NAME) {
d1590 1
d1596 1
d1601 1
d1628 1
a1628 6
    if (type == SVt_REGEXP) {
	/* FIXME dumping
	    Perl_dump_indent(aTHX_ level, file, "  REGEXP = 0x%"UVxf"\n",
			     PTR2UV(((struct regexp *)SvANY(sv))->xrx_regexp));
	*/
    }
d1636 1
a1636 1
		do_magic_dump(level, file, SvMAGIC(sv), nest, maxnest, dumpops, pvlim);
d1640 6
d1647 3
d1680 1
a1680 1
	if (HvARRAY(sv) && HvKEYS(sv)) {
d1686 1
a1686 1
	    U32 pow2 = 2, keys = HvKEYS(sv);
d1728 1
a1728 1
	    theoret = HvKEYS(sv);
d1734 1
a1734 1
	Perl_dump_indent(aTHX_ level, file, "  KEYS = %"IVdf"\n", (IV)HvKEYS(sv));
d1754 35
d1831 3
a1833 1
	if (nest < maxnest && !HvEITER_get(sv)) { /* Try to preserve iterator */
a1834 2
	    HV * const hv = MUTABLE_HV(sv);
	    int count = maxnest - nest;
d1836 8
a1843 3
	    hv_iterinit(hv);
	    while ((he = hv_iternext_flags(hv, HV_ITERNEXT_WANTPLACEHOLDERS))
                   && count--) {
d1845 7
a1851 4
		const U32 hash = HeHASH(he);
		SV * const keysv = hv_iterkeysv(he);
		const char * const keypv = SvPV_const(keysv, len);
		SV * const elt = hv_iterval(hv, he);
d1856 2
d1860 1
a1860 1
		PerlIO_printf(file, "HASH = 0x%"UVxf"\n", (UV)hash);
d1863 3
a1865 1
	    hv_iterinit(hv);		/* Return to status quo */
d1868 1
d1870 6
a1876 2
	    STRLEN len;
	    const char *const proto =  SvPV_const(sv, len);
d1878 1
a1878 1
			     (int) len, proto);
d1936 1
d1944 1
a1948 6
	if (SvVALID(sv)) {
	    Perl_dump_indent(aTHX_ level, file, "  FLAGS = %u\n", (U8)BmFLAGS(sv));
	    Perl_dump_indent(aTHX_ level, file, "  RARE = %u\n", (U8)BmRARE(sv));
	    Perl_dump_indent(aTHX_ level, file, "  PREVIOUS = %"UVuf"\n", (UV)BmPREVIOUS(sv));
	    Perl_dump_indent(aTHX_ level, file, "  USEFUL = %"IVdf"\n", (IV)BmUSEFUL(sv));
	}
d2016 56
a2099 1
	PERL_ASYNC_CHECK();
d2119 1
a2119 1
    } while ((PL_op = CALL_FPTR(PL_op->op_ppaddr)(aTHX)));
d2199 1
a2199 1
        return PL_compcv;
d2295 1
a2295 1
Perl_xmldump_all_perl(pTHX_ bool justperl)
d2300 2
a2301 1
    xmldump_packsubs_perl(PL_defstash, justperl);
d2400 7
d2423 1
a2423 1
	    c = utf8_to_uvchr((U8*)pv, &cl);
d2663 1
a2663 1
	sv_catpv(t, " ORANGE=\"");
a2755 1
    sequence(o);
a2878 2
		if (o->op_private & OPpENTERSUB_NOMOD)
		    sv_catpv(tmpsv, ",NOMOD");
a2910 2
	    if (o->op_private & OPpCONST_ARYBASE)
		sv_catpv(tmpsv, ",ARYBASE");
d2972 1
a2972 1
	else if (PL_check[o->op_type] != MEMBER_TO_FPTR(Perl_ck_ftst)) {
@


1.12
log
@Merge in perl 5.10.1
@
text
@a36 1
    "RV",
d41 1
a56 1
    "RV",
d61 1
d95 7
d106 1
a106 1
    dump_packsubs(PL_defstash);
d112 7
d122 1
a122 1
    PERL_ARGS_ASSERT_DUMP_PACKSUBS;
d133 1
a133 1
		dump_sub(gv);
d139 1
a139 1
		    dump_packsubs(hv);		/* nested package */
d148 10
a157 1
    SV * const sv = sv_newmortal();
d159 2
a160 1
    PERL_ARGS_ASSERT_DUMP_SUB;
d162 1
d533 5
a537 2
	    if (SvOOK(sv))
		Perl_sv_catpvf(aTHX_ t, "[%s]", pv_display(tmp, SvPVX_const(sv)-SvIVX(sv), SvIVX(sv), 0, 127));
d1009 1
a1009 1
	    if (OP_IS_FILETEST_ACCESS(o) && o->op_private & OPpFT_ACCESS)
d1092 1
a1099 1
    case OP_SETSTATE:
d1289 1
a1508 1
	if (CvLOCKED(sv))	sv_catpv(d, "LOCKED,");
a1522 1
	    if (GvUNIQUE(sv))   sv_catpv(d, "UNIQUE,");
d1569 2
a1570 1
    Perl_dump_indent(aTHX_ level, file, "ALLOCATED at %s:%d %s %s%s\n",
d1575 3
a1577 1
	sv->sv_debug_cloned ? " (cloned)" : "");
d1593 3
a1595 2
	 && type != SVt_PVCV && !isGV_with_GP(sv))
	|| type == SVt_IV) {
a1603 2
	if (SvOOK(sv))
	    PerlIO_printf(file, "  (OFFSET)");
d1618 2
a1619 2
		&& type != SVt_PVCV && type != SVt_PVFM && !isGV_with_GP(sv)
		&& !SvVALID(sv))
d1641 8
d1650 5
a1654 2
	    if (SvOOK(sv))
		PerlIO_printf(file, "( %s . ) ", pv_display(d, SvPVX_const(sv)-SvIVX(sv), SvIVX(sv), 0, pvlim));
d1665 6
d1786 1
d1793 35
d1877 1
a1877 1
	    SV * const constant = cv_const_sv((CV *)sv);
d2023 1
a2023 2
	if (ckWARN_d(WARN_DEBUGGING))
	    Perl_warner(aTHX_ packWARN(WARN_DEBUGGING), "NULL OP IN RUN");
d2069 1
d2221 6
d2230 1
d2239 7
d2249 1
a2249 1
    PERL_ARGS_ASSERT_XMLDUMP_PACKSUBS;
d2260 1
a2260 1
		xmldump_sub(gv);
d2265 1
a2265 1
		xmldump_packsubs(hv);		/* nested package */
d2273 10
a2282 1
    SV * const sv = sv_newmortal();
d2284 2
a2285 1
    PERL_ARGS_ASSERT_XMLDUMP_SUB;
d2287 1
a2550 3
    case SVt_RV:
	sv_catpv(t, " RV=\"");
	break;
d2584 3
d2634 2
a2635 3
	SV * const tmpsv
	    = newSVpvn_utf8(RX_PRECOMP(r), RX_PRELEN(r), RX_UTF8(r));
	sv_utf8_upgrade(tmpsv);
d2900 1
a2900 1
	    if (OP_IS_FILETEST_ACCESS(o) && o->op_private & OPpFT_ACCESS)
d2941 1
a2955 1
    case OP_SETSTATE:
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d12 4
a15 2
 * "'You have talked long in your sleep, Frodo,' said Gandalf gently, 'and
 * it has not been hard for me to read your mind and memory.'"
d77 1
d87 1
d108 2
d115 1
a115 1
	    const GV * const gv = (GV*)HeVAL(entry);
d136 2
d155 2
d174 1
a174 3
=for apidoc Apd|char*|pv_escape|NN SV *dsv|NN const char const *str\
               |const STRLEN count|const STRLEN max
               |STRLEN const *escaped, const U32 flags
d230 2
d234 1
a234 1
	    sv_setpvn(dsv, "", 0);
d311 1
a311 4
=for apidoc Apd|char *|pv_pretty|NN SV *dsv|NN const char const *str\
           |const STRLEN count|const STRLEN max\
           |const char const *start_color| const char const *end_color\
           |const U32 flags
d342 3
a344 1
    
d347 1
a347 1
	    sv_setpvn(dsv, "", 0);
d351 1
a351 1
        sv_catpvn(dsv, "\"", 1);
d353 1
a353 1
        sv_catpvn(dsv, "<", 1);
d356 1
a356 1
        Perl_sv_catpv( aTHX_ dsv, start_color);
d361 1
a361 1
        Perl_sv_catpv( aTHX_ dsv, end_color);
d364 1
a364 1
	sv_catpvn( dsv, "\"", 1 );
d366 1
a366 1
        sv_catpvn( dsv, ">", 1);         
d369 1
a369 1
	    sv_catpvn( dsv, "...", 3 );
a376 3
  char *pv_display(SV *dsv, const char *pv, STRLEN cur, STRLEN len,
                   STRLEN pvlim, U32 flags)

d392 2
d396 1
a396 1
            sv_catpvn( dsv, "\\0", 2 );
d408 1
a408 1
    sv_setpvn(t, "", 0);
d414 1
a414 1
    else if (sv == (SV*)0x55555555 || SvTYPE(sv) == 'U') {
d485 1
a485 1
	sv = (SV*)SvRV(sv);
d535 2
d545 2
d559 1
a559 1
	     ch, PM_GETRE(pm)->precomp, ch,
d567 1
a567 1
    if (pm->op_pmflags || (PM_GETRE(pm) && PM_GETRE(pm)->check_substr)) {
d583 2
d596 1
a596 1
        if (regex->extflags & RXf_TAINTED)
d598 2
a599 2
        if (regex->check_substr) {
            if (!(regex->extflags & RXf_NOSCAN))
d601 1
a601 1
            if (regex->extflags & RXf_CHECK_ALL)
d604 1
a604 1
        if (regex->extflags & RXf_SKIPWHITE)
d750 2
d778 1
a778 1
		if (cCOPo->cop_label)
d780 1
a780 1
				     cCOPo->cop_label);
d995 1
a995 1
	SV * const tmpsv = newSVpvn("", 0);
d1001 1
a1001 1
	    sv_setpvn(tmpsv,"'",1);
d1043 1
a1043 1
	if ( ! PL_op->op_flags & OPf_SPECIAL) { /* not lexical */
d1053 1
a1053 1
		gv_fullname3(tmpsv, (GV*)cSVOPo->op_sv, NULL);
d1080 1
a1080 1
	if (cCOPo->cop_label)
d1082 1
a1082 1
			     cCOPo->cop_label);
d1142 1
d1151 2
d1210 1
a1210 1
	{ PERL_MAGIC_uvar_elem,      "uvar_elem(v)" },
d1224 2
d1307 1
a1307 1
		const regexp * const re = (regexp *)mg->mg_obj;
d1309 2
a1310 1
                const char * const s =  pv_pretty(dsv, re->wrapped, re->wraplen, 
d1313 1
a1313 1
                    ((re->extflags & RXf_UTF8) ? PERL_PV_ESCAPE_UNI : 0))
d1317 1
a1317 1
			(IV)re->refcnt);
d1335 2
a1336 1
		do_sv_dump(level+2, file, (SV*)((mg)->mg_ptr), nest+1, maxnest, dumpops, pvlim); /* MG is already +1 */
d1368 3
d1381 2
d1393 2
d1416 2
d1610 1
a1610 1
    if (type <= SVt_PVLV && !isGV_with_GP(sv)) {
d1649 1
a1649 1
	sv_setpvn(d, "", 0);
d1654 1
a1654 1
	if (nest < maxnest && av_len((AV*)sv) >= 0) {
d1656 2
a1657 2
	    for (count = 0; count <=  av_len((AV*)sv) && count < maxnest; count++) {
		SV** const elt = av_fetch((AV*)sv,count,0);
d1738 2
a1739 1
	    const AV * const backrefs = *Perl_hv_backreferences_p(aTHX_ (HV*)sv);
d1743 1
a1743 1
		do_sv_dump(level+1, file, (SV*)backrefs, nest+1, maxnest,
d1749 1
a1749 1
	    HV * const hv = (HV*)sv;
d1812 2
a1813 1
	Perl_dump_indent(aTHX_ level, file, "  DEPTH = %"IVdf"\n", (IV)CvDEPTH(sv));
d1833 1
a1833 1
	    do_sv_dump(level+1, file, (SV*)CvOUTSIDE(sv), nest+1, maxnest, dumpops, pvlim);
d1888 2
a1889 2
	    do_sv_dump (level+1, file, (SV *) IoTOP_GV(sv), nest+1, maxnest,
			dumpops, pvlim);
d1900 2
a1901 2
	    do_sv_dump (level+1, file, (SV *) IoFMT_GV(sv), nest+1, maxnest,
			dumpops, pvlim);
d1910 2
a1911 2
	    do_sv_dump (level+1, file, (SV *) IoBOTTOM_GV(sv), nest+1, maxnest,
			dumpops, pvlim);
d1927 3
d1979 3
d1988 8
a1995 1
	PerlIO_printf(Perl_debug_log, "(%s)", SvPEEK(cSVOPo_sv));
d2022 1
a2022 1
            AV * const comppad = (AV*)(*av_fetch(padlist, 0, FALSE));
d2060 3
d2073 3
d2107 3
d2121 1
d2130 2
d2153 2
d2159 1
a2159 1
	    GV *gv = (GV*)HeVAL(entry);
d2179 2
d2198 2
d2217 1
d2230 3
a2232 1
    sv_catpvn(dsv,"",0);
d2355 2
d2358 1
a2358 1
    sv_setpvn(t, "", 0);
d2364 1
a2364 1
    else if (sv == (SV*)0x55555555 || SvTYPE(sv) == 'U') {
d2517 2
d2526 4
a2529 3
	const regexp *const r = PM_GETRE(pm);
	SV * const tmpsv = newSVpvn(r->precomp,r->prelen);
	SvUTF8_on(tmpsv);
d2538 1
a2538 1
    if (pm->op_pmflags || (PM_GETRE(pm) && PM_GETRE(pm)->check_substr)) {
d2567 3
d2597 1
a2597 1
		if (cCOPo->cop_label)
d2599 1
a2599 1
				     cCOPo->cop_label);
d2609 1
a2609 1
	SV * const tmpsv = newSVpvn("", 0);
d2640 1
a2640 1
	SV * const tmpsv = newSVpvn("", 0);
d2817 2
a2818 2
	    SV * const tmpsv1 = newSV(0);
	    SV * const tmpsv2 = newSVpvn("",0);
a2820 2
	    SvUTF8_on(tmpsv1);
	    SvUTF8_on(tmpsv2);
d2824 1
a2824 1
	    gv_fullname3(tmpsv1, (GV*)cSVOPo->op_sv, NULL);
d2858 1
a2858 1
	if (cCOPo->cop_label)
d2860 1
a2860 1
			     cCOPo->cop_label);
d2906 1
a2906 1
	SV * const tmpsv = newSVpvn("", 0);
a2908 1
	sv_utf8_upgrade(tmpsv);
d2917 1
a2917 1
	    sv_setpvn(tmpsv,"\"",1);
d2938 1
a2938 1
		sv_catxmlsv(tmpsv, (SV*)mp->mad_val);
d2995 2
@


1.10
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, by Larry Wall and others
d27 43
d83 1
d91 1
d99 1
a99 1
Perl_dump_packsubs(pTHX_ HV *stash)
d101 1
d109 1
a109 2
            const GV *gv = (GV*)HeVAL(entry);
            const HV *hv;
d113 1
a113 1
		dump_sub((GV *)gv);
d115 6
a120 4
		dump_form((GV *)gv);
	    if (HeKEY(entry)[HeKLEN(entry)-1] == ':'
		&& (hv = GvHV(gv)) && hv != PL_defstash)
		dump_packsubs((HV *) hv);		/* nested package */
d126 1
a126 1
Perl_dump_sub(pTHX_ GV *gv)
d130 1
a130 1
    gv_fullname3(sv, gv, Nullch);
d132 1
a132 1
    if (CvXSUB(GvCV(gv)))
d143 1
a143 1
Perl_dump_form(pTHX_ GV *gv)
d147 1
a147 1
    gv_fullname3(sv, gv, Nullch);
d158 1
d162 44
d207 72
a278 9
Perl_pv_display(pTHX_ SV *dsv, char *pv, STRLEN cur, STRLEN len, STRLEN pvlim)
{
    const bool nul_terminated = len > cur && pv[cur] == '\0';
    bool truncated = 0;

    sv_setpvn(dsv, "\"", 1);
    for (; cur--; pv++) {
	if (pvlim && SvCUR(dsv) >= pvlim) {
            truncated = 1;
d280 15
a294 16
        }
	switch (*pv) {
	case '\t': sv_catpvn(dsv, "\\t", 2);  break;
	case '\n': sv_catpvn(dsv, "\\n", 2);  break;
	case '\r': sv_catpvn(dsv, "\\r", 2);  break;
	case '\f': sv_catpvn(dsv, "\\f", 2);  break;
	case '"':  sv_catpvn(dsv, "\\\"", 2); break;
	case '\\': sv_catpvn(dsv, "\\\\", 2); break;
	default:
	    if (isPRINT(*pv))
		sv_catpvn(dsv, pv, 1);
	    else if (cur && isDIGIT(*(pv+1)))
		Perl_sv_catpvf(aTHX_ dsv, "\\%03o", (U8)*pv);
	    else
		Perl_sv_catpvf(aTHX_ dsv, "\\%o", (U8)*pv);
        }
d296 71
a366 5
    sv_catpvn(dsv, "\"", 1);
    if (truncated)
	sv_catpvn(dsv, "...", 3);
    if (nul_terminated)
	sv_catpvn(dsv, "\\0", 2);
d368 21
d395 1
d398 1
d480 3
a482 3
    switch (SvTYPE(sv)) {
    default:
	sv_catpv(t, "FREED");
d484 2
d487 4
a490 38
    case SVt_NULL:
	sv_catpv(t, "UNDEF");
	goto finish;
    case SVt_IV:
	sv_catpv(t, "IV");
	break;
    case SVt_NV:
	sv_catpv(t, "NV");
	break;
    case SVt_RV:
	sv_catpv(t, "RV");
	break;
    case SVt_PV:
	sv_catpv(t, "PV");
	break;
    case SVt_PVIV:
	sv_catpv(t, "PVIV");
	break;
    case SVt_PVNV:
	sv_catpv(t, "PVNV");
	break;
    case SVt_PVMG:
	sv_catpv(t, "PVMG");
	break;
    case SVt_PVLV:
	sv_catpv(t, "PVLV");
	break;
    case SVt_PVAV:
	sv_catpv(t, "AV");
	break;
    case SVt_PVHV:
	sv_catpv(t, "HV");
	break;
    case SVt_PVCV:
	if (CvGV(sv))
	    Perl_sv_catpvf(aTHX_ t, "CV(%s)", GvNAME(CvGV(sv)));
	else
	    sv_catpv(t, "CV()");
a491 12
    case SVt_PVGV:
	sv_catpv(t, "GV");
	break;
    case SVt_PVBM:
	sv_catpv(t, "BM");
	break;
    case SVt_PVFM:
	sv_catpv(t, "FM");
	break;
    case SVt_PVIO:
	sv_catpv(t, "IO");
	break;
d498 1
a498 1
	    SV *tmp = newSVpvn("", 0);
d501 2
a502 2
		Perl_sv_catpvf(aTHX_ t, "[%s]", pv_display(tmp, (char *)SvPVX_const(sv)-SvIVX(sv), SvIVX(sv), 0, 127));
	    Perl_sv_catpvf(aTHX_ t, "%s)", pv_display(tmp, (char *)SvPVX_const(sv), SvCUR(sv), SvLEN(sv), 127));
d505 1
a505 1
			       sv_uni_display(tmp, sv, 8 * sv_len_utf8(sv),
d525 2
a526 4
    if (unref) {
	while (unref--)
	    sv_catpv(t, ")");
    }
d531 1
a531 1
Perl_do_pmop_dump(pTHX_ I32 level, PerlIO *file, PMOP *pm)
d551 1
a551 1
    if (pm->op_type != OP_PUSHRE && pm->op_pmreplroot) {
d553 1
a553 1
	op_dump(pm->op_pmreplroot);
d556 1
a556 27
	SV *tmpsv = newSVpvn("", 0);
	if (pm->op_pmdynflags & PMdf_USED)
	    sv_catpv(tmpsv, ",USED");
	if (pm->op_pmdynflags & PMdf_TAINTED)
	    sv_catpv(tmpsv, ",TAINTED");
	if (pm->op_pmflags & PMf_ONCE)
	    sv_catpv(tmpsv, ",ONCE");
	if (PM_GETRE(pm) && PM_GETRE(pm)->check_substr
	    && !(PM_GETRE(pm)->reganch & ROPT_NOSCAN))
	    sv_catpv(tmpsv, ",SCANFIRST");
	if (PM_GETRE(pm) && PM_GETRE(pm)->check_substr
	    && PM_GETRE(pm)->reganch & ROPT_CHECK_ALL)
	    sv_catpv(tmpsv, ",ALL");
	if (pm->op_pmflags & PMf_SKIPWHITE)
	    sv_catpv(tmpsv, ",SKIPWHITE");
	if (pm->op_pmflags & PMf_CONST)
	    sv_catpv(tmpsv, ",CONST");
	if (pm->op_pmflags & PMf_KEEP)
	    sv_catpv(tmpsv, ",KEEP");
	if (pm->op_pmflags & PMf_GLOBAL)
	    sv_catpv(tmpsv, ",GLOBAL");
	if (pm->op_pmflags & PMf_CONTINUE)
	    sv_catpv(tmpsv, ",CONTINUE");
	if (pm->op_pmflags & PMf_RETAINT)
	    sv_catpv(tmpsv, ",RETAINT");
	if (pm->op_pmflags & PMf_EVAL)
	    sv_catpv(tmpsv, ",EVAL");
d564 45
d615 114
d730 1
a730 1
Perl_do_op_dump(pTHX_ I32 level, PerlIO *file, OP *o)
d732 5
d739 3
a741 2
    if (o->op_seq)
	PerlIO_printf(file, "%-4d", o->op_seq);
d747 3
a749 6
    if (o->op_next) {
	if (o->op_seq)
	    PerlIO_printf(file, "%d\n", o->op_next->op_seq);
	else
	    PerlIO_printf(file, "(%d)\n", o->op_next->op_seq);
    }
d753 1
a753 2
	if (o->op_type == OP_NULL)
	{
d755 1
a755 2
	    if (o->op_targ == OP_NEXTSTATE)
	    {
d757 1
a757 1
		    Perl_dump_indent(aTHX_ level, file, "LINE = %"UVf"\n",
d773 2
a774 2
    if (o->op_flags) {
	SV *tmpsv = newSVpvn("", 0);
d801 6
d811 2
a812 2
	SV *tmpsv = newSVpvn("", 0);
	if (PL_opargs[o->op_type] & OA_TARGLEX) {
d816 4
a819 4
	else if (o->op_type == OP_LEAVESUB ||
		 o->op_type == OP_LEAVE ||
		 o->op_type == OP_LEAVESUBLV ||
		 o->op_type == OP_LEAVEWRITE) {
d823 1
a823 1
        else if (o->op_type == OP_AASSIGN) {
a825 2
	    if (o->op_private & OPpASSIGN_HASH)
		sv_catpv(tmpsv, ",HASH");
d827 1
a827 1
	else if (o->op_type == OP_SASSIGN) {
d831 1
a831 1
	else if (o->op_type == OP_TRANS) {
d843 1
a843 1
	else if (o->op_type == OP_REPEAT) {
d847 8
a854 8
	else if (o->op_type == OP_ENTERSUB ||
		 o->op_type == OP_RV2SV ||
		 o->op_type == OP_GVSV ||
		 o->op_type == OP_RV2AV ||
		 o->op_type == OP_RV2HV ||
		 o->op_type == OP_RV2GV ||
		 o->op_type == OP_AELEM ||
		 o->op_type == OP_HELEM )
d856 1
a856 1
	    if (o->op_type == OP_ENTERSUB) {
d872 10
a881 10
	    case OPpDEREF_SV:
		sv_catpv(tmpsv, ",SV");
		break;
	    case OPpDEREF_AV:
		sv_catpv(tmpsv, ",AV");
		break;
	    case OPpDEREF_HV:
		sv_catpv(tmpsv, ",HV");
		break;
	    }
d885 1
a885 1
	    if (o->op_type == OP_AELEM || o->op_type == OP_HELEM) {
d896 1
a896 1
	else if (o->op_type == OP_CONST) {
d908 1
a908 1
	else if (o->op_type == OP_FLIP) {
d912 1
a912 1
	else if (o->op_type == OP_FLOP) {
d916 1
a916 1
	else if (o->op_type == OP_RV2CV) {
d920 1
a920 1
	else if (o->op_type == OP_GV) {
d924 1
a924 1
	else if (o->op_type == OP_LIST) {
d928 1
a928 1
	else if (o->op_type == OP_DELETE) {
d932 1
a932 1
	else if (o->op_type == OP_EXISTS) {
d936 1
a936 1
	else if (o->op_type == OP_SORT) {
d944 1
a944 5
	else if (o->op_type == OP_THREADSV) {
	    if (o->op_private & OPpDONE_SVREF)
		sv_catpv(tmpsv, ",SVREF");
	}
	else if (o->op_type == OP_OPEN || o->op_type == OP_BACKTICK) {
d954 1
a954 1
	else if (o->op_type == OP_EXIT) {
d960 1
a960 1
	else if (o->op_type == OP_DIE) {
d964 5
a968 3
	else if (OP_IS_FILETEST_ACCESS(o)) {
	     if (o->op_private & OPpFT_ACCESS)
		  sv_catpv(tmpsv, ",FT_ACCESS");
d977 44
a1020 1
    switch (o->op_type) {
d1029 1
a1029 1
		SV *tmpsv = NEWSV(0,0);
d1032 6
a1037 1
		gv_fullname3(tmpsv, (GV*)cSVOPo->op_sv, Nullch);
d1059 1
a1059 1
	    Perl_dump_indent(aTHX_ level, file, "LINE = %"UVf"\n",
d1071 1
a1071 1
	    PerlIO_printf(file, "%d\n", cLOOPo->op_redoop->op_seq);
d1076 1
a1076 1
	    PerlIO_printf(file, "%d\n", cLOOPo->op_nextop->op_seq);
d1081 1
a1081 1
	    PerlIO_printf(file, "%d\n", cLOOPo->op_lastop->op_seq);
d1093 1
a1093 1
	    PerlIO_printf(file, "%d\n", cLOGOPo->op_other->op_seq);
d1124 1
a1124 1
Perl_op_dump(pTHX_ OP *o)
d1140 1
a1140 1
    gv_fullname3(sv, gv, Nullch);
d1143 1
a1143 1
	gv_efullname3(sv, GvEGV(gv), Nullch);
d1158 1
a1158 1
	{ PERL_MAGIC_glob,           "glob(*)" },
d1160 1
d1162 1
d1167 1
d1180 1
a1183 1
	{ PERL_MAGIC_mutex,          "mutex(m)" },
d1193 1
a1193 1
	{ PERL_MAGIC_vstring,        "v-string(V)" },
d1199 1
a1199 1
	{ 0,                         0 },
d1203 1
a1203 1
Perl_do_magic_dump(pTHX_ I32 level, PerlIO *file, MAGIC *mg, I32 nest, I32 maxnest, bool dumpops, STRLEN pvlim)
d1210 1
a1210 1
 	    const char *s = 0;
a1220 1
            else if (v == &PL_vtbl_glob)       s = "glob";
d1238 3
d1254 1
a1254 1
	    const char *name = 0;
d1283 15
a1297 2
	    Perl_dump_indent(aTHX_ level, file, "    MG_OBJ = 0x%"UVxf"\n", PTR2UV(mg->mg_obj));
	    if (mg->mg_flags & MGf_REFCOUNTED)
d1305 5
a1309 5
		 if (mg->mg_type != PERL_MAGIC_utf8) {
		      SV *sv = newSVpvn("", 0);
		      PerlIO_printf(file, " %s", pv_display(sv, mg->mg_ptr, mg->mg_len, 0, pvlim));
		      SvREFCNT_dec(sv);
		 }
d1321 10
a1330 10
	     STRLEN *cache = (STRLEN *) mg->mg_ptr;
	     if (cache) {
		  IV i;
		  for (i = 0; i < PERL_MAGIC_UTF8_CACHESIZE; i++)
		       Perl_dump_indent(aTHX_ level, file,
					"      %2"IVdf": %"UVuf" -> %"UVuf"\n",
					i,
					(UV)cache[i * 2],
					(UV)cache[i * 2 + 1]);
	     }
d1336 1
a1336 1
Perl_magic_dump(pTHX_ MAGIC *mg)
d1338 1
a1338 1
    do_magic_dump(0, Perl_debug_log, mg, 0, 0, 0, 0);
d1342 1
a1342 1
Perl_do_hv_dump(pTHX_ I32 level, PerlIO *file, char *name, HV *sv)
d1353 1
a1353 1
Perl_do_gv_dump(pTHX_ I32 level, PerlIO *file, char *name, GV *sv)
d1363 1
a1363 1
Perl_do_gvgv_dump(pTHX_ I32 level, PerlIO *file, char *name, GV *sv)
d1380 1
d1400 7
a1406 3
    if (flags & SVs_PADBUSY)	sv_catpv(d, "PADBUSY,");
    if (flags & SVs_PADTMP)	sv_catpv(d, "PADTMP,");
    if (flags & SVs_PADMY)	sv_catpv(d, "PADMY,");
d1423 1
d1425 1
a1425 2
    if (flags & SVf_AMAGIC && type != SVt_PVHV)
				sv_catpv(d, "OVERLOAD,");
d1429 4
a1432 1
    if (flags & SVp_SCREAM && type != SVt_PVHV)
d1434 1
d1459 9
a1467 7
	if (GvINTRO(sv))	sv_catpv(d, "INTRO,");
	if (GvMULTI(sv))	sv_catpv(d, "MULTI,");
	if (GvUNIQUE(sv))       sv_catpv(d, "UNIQUE,");
	if (GvASSUMECV(sv))	sv_catpv(d, "ASSUMECV,");
	if (GvIN_PAD(sv))       sv_catpv(d, "IN_PAD,");
	if (flags & SVpad_OUR)	sv_catpv(d, "OUR,");
	if (GvIMPORTED(sv)) {
d1480 2
d1484 1
a1487 4
    case SVt_PVBM:
	if (SvTAIL(sv))		sv_catpv(d, "TAIL,");
	if (SvVALID(sv))	sv_catpv(d, "VALID,");
	break;
d1489 7
a1495 2
	if (flags & SVpad_TYPED)
				sv_catpv(d, "TYPED,");
d1509 8
d1518 8
a1525 51
    switch (type) {
    case SVt_NULL:
	PerlIO_printf(file, "NULL%s\n", s);
	SvREFCNT_dec(d);
	return;
    case SVt_IV:
	PerlIO_printf(file, "IV%s\n", s);
	break;
    case SVt_NV:
	PerlIO_printf(file, "NV%s\n", s);
	break;
    case SVt_RV:
	PerlIO_printf(file, "RV%s\n", s);
	break;
    case SVt_PV:
	PerlIO_printf(file, "PV%s\n", s);
	break;
    case SVt_PVIV:
	PerlIO_printf(file, "PVIV%s\n", s);
	break;
    case SVt_PVNV:
	PerlIO_printf(file, "PVNV%s\n", s);
	break;
    case SVt_PVBM:
	PerlIO_printf(file, "PVBM%s\n", s);
	break;
    case SVt_PVMG:
	PerlIO_printf(file, "PVMG%s\n", s);
	break;
    case SVt_PVLV:
	PerlIO_printf(file, "PVLV%s\n", s);
	break;
    case SVt_PVAV:
	PerlIO_printf(file, "PVAV%s\n", s);
	break;
    case SVt_PVHV:
	PerlIO_printf(file, "PVHV%s\n", s);
	break;
    case SVt_PVCV:
	PerlIO_printf(file, "PVCV%s\n", s);
	break;
    case SVt_PVGV:
	PerlIO_printf(file, "PVGV%s\n", s);
	break;
    case SVt_PVFM:
	PerlIO_printf(file, "PVFM%s\n", s);
	break;
    case SVt_PVIO:
	PerlIO_printf(file, "PVIO%s\n", s);
	break;
    default:
d1530 8
a1537 2
    if (type >= SVt_PVIV || type == SVt_IV) {
	if (SvIsUV(sv))
d1543 6
d1551 9
a1559 1
    if (type >= SVt_PVNV || type == SVt_NV) {
d1578 1
a1578 1
    if (type <= SVt_PVLV) {
d1582 4
a1585 4
		PerlIO_printf(file, "( %s . ) ", pv_display(d, (char *)SvPVX_const(sv)-SvIVX(sv), SvIVX(sv), 0, pvlim));
	    PerlIO_printf(file, "%s", pv_display(d, (char *)SvPVX_const(sv), SvCUR(sv), SvLEN(sv), pvlim));
	    if (SvUTF8(sv)) /* the 8?  \x{....} */
	        PerlIO_printf(file, " [UTF8 \"%s\"]", sv_uni_display(d, sv, 8 * sv_len_utf8(sv), UNI_DISPLAY_QQ));
d1594 8
a1601 2
	if (SvMAGIC(sv))
            do_magic_dump(level, file, SvMAGIC(sv), nest, maxnest, dumpops, pvlim);
a1605 9
    case SVt_PVLV:
	Perl_dump_indent(aTHX_ level, file, "  TYPE = %c\n", LvTYPE(sv));
	Perl_dump_indent(aTHX_ level, file, "  TARGOFF = %"IVdf"\n", (IV)LvTARGOFF(sv));
	Perl_dump_indent(aTHX_ level, file, "  TARGLEN = %"IVdf"\n", (IV)LvTARGLEN(sv));
	Perl_dump_indent(aTHX_ level, file, "  TARG = 0x%"UVxf"\n", PTR2UV(LvTARG(sv)));
	if (LvTYPE(sv) != 't' && LvTYPE(sv) != 'T')
	    do_sv_dump(level+1, file, LvTARG(sv), nest+1, maxnest,
		    dumpops, pvlim);
	break;
d1616 1
a1616 2
	Perl_dump_indent(aTHX_ level, file, "  ARYLEN = 0x%"UVxf"\n", PTR2UV(AvARYLEN(sv)));
	flags = AvFLAGS(sv);
d1618 2
a1619 3
	if (flags & AVf_REAL)	sv_catpv(d, ",REAL");
	if (flags & AVf_REIFY)	sv_catpv(d, ",REIFY");
	if (flags & AVf_REUSED)	sv_catpv(d, ",REUSED");
d1625 1
a1625 1
		SV** elt = av_fetch((AV*)sv,count,0);
d1638 1
a1638 1
#define FREQ_MAX (sizeof freq / sizeof freq[0] - 1)
d1647 2
a1648 1
		HE* h; int count = 0;
a1693 2
	if (HvPMROOT(sv))
	    Perl_dump_indent(aTHX_ level, file, "  PMROOT = 0x%"UVxf"\n", PTR2UV(HvPMROOT(sv)));
d1695 7
a1701 1
	    const char *hvname = HvNAME_get(sv);
d1705 9
d1716 1
a1716 1
	    HV *hv = (HV*)sv;
a1721 2
		SV *elt, *keysv;
                const char *keypv;
d1723 4
a1726 1
		U32 hash = HeHASH(he);
d1728 1
a1728 4
		keysv = hv_iterkeysv(he);
		keypv = SvPV_const(keysv, len);
		elt = hv_iterval(hv, he);
		Perl_dump_indent(aTHX_ level+1, file, "Elt %s ", pv_display(d, (char *)keypv, len, 0, pvlim));
d1730 1
a1730 1
		    PerlIO_printf(file, "[UTF8 \"%s\"] ", sv_uni_display(d, keysv, 8 * sv_len_utf8(keysv), UNI_DISPLAY_QQ));
d1740 6
a1745 2
	if (SvPOK(sv))
	    Perl_dump_indent(aTHX_ level, file, "  PROTOTYPE = \"%s\"\n", SvPV_nolen_const(sv));
d1749 28
a1776 7
	if (CvSTART(sv))
	    Perl_dump_indent(aTHX_ level, file, "  START = 0x%"UVxf" ===> %"IVdf"\n", PTR2UV(CvSTART(sv)), (IV)CvSTART(sv)->op_seq);
	Perl_dump_indent(aTHX_ level, file, "  ROOT = 0x%"UVxf"\n", PTR2UV(CvROOT(sv)));
        if (CvROOT(sv) && dumpops)
	    do_op_dump(level+1, file, CvROOT(sv));
	Perl_dump_indent(aTHX_ level, file, "  XSUB = 0x%"UVxf"\n", PTR2UV(CvXSUB(sv)));
	Perl_dump_indent(aTHX_ level, file, "  XSUBANY = %"IVdf"\n", (IV)CvXSUBANY(sv).any_i32);
a1779 4
#ifdef USE_5005THREADS
	Perl_dump_indent(aTHX_ level, file, "  MUTEXP = 0x%"UVxf"\n", PTR2UV(CvMUTEXP(sv)));
	Perl_dump_indent(aTHX_ level, file, "  OWNER = 0x%"UVxf"\n",  PTR2UV(CvOWNER(sv)));
#endif /* USE_5005THREADS */
d1789 1
a1789 1
            const CV *outside = CvOUTSIDE(sv);
d1802 18
a1833 1
	Perl_dump_indent(aTHX_ level, file, "    GPFLAGS = 0x%"UVxf"\n", (UV)GvGPFLAGS(sv));
d1849 10
a1858 1
	do_gv_dump (level, file, "  TOP_GV", IoTOP_GV(sv));
d1861 8
a1868 1
	do_gv_dump (level, file, "  FMT_GV", IoFMT_GV(sv));
d1871 8
a1878 2
	do_gv_dump (level, file, "  BOTTOM_GV", IoBOTTOM_GV(sv));
	Perl_dump_indent(aTHX_ level, file, "  SUBPROCESS = %"IVdf"\n", (IV)IoSUBPROCESS(sv));
d1892 5
a1896 1
    do_sv_dump(0, Perl_debug_log, sv, 0, 0, 0, 0);
d1902 1
d1909 1
d1913 1
a1913 1
	    if (PL_watchaddr != 0 && *PL_watchaddr != PL_watchok)
d1932 1
d1939 1
a1939 1
Perl_debop(pTHX_ OP *o)
d1941 1
d1953 7
a1959 2
	    SV *sv = NEWSV(0,0);
	    gv_fullname3(sv, cGVOPo_gv, Nullch);
d1971 1
a1971 1
	CV *cv = deb_curcv(cxstack_ix);
d1974 1
a1974 1
            AV * const padlist = CvPADLIST(cv);
d1978 1
a1978 1
            sv = Nullsv;
d1980 1
a1980 1
           PerlIO_printf(Perl_debug_log, "(%s)", SvPV_nolen_const(sv));
d1982 1
a1982 1
           PerlIO_printf(Perl_debug_log, "[%"UVuf"]", (UV)o->op_targ);
d1993 1
a1993 1
S_deb_curcv(pTHX_ I32 ix)
d1995 2
a1996 1
    const PERL_CONTEXT *cx = &cxstack[ix];
d2004 1
a2004 1
        return Nullcv;
d2012 1
d2022 2
a2023 1
    if (CopSTASH_eq(PL_curcop, PL_debstash) && !DEBUG_J_TEST_)
d2033 1
d2044 881
@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
a56 1
    HE	*entry;
d61 1
d63 2
a64 2
	    GV *gv = (GV*)HeVAL(entry);
	    HV *hv;
d68 1
a68 1
		dump_sub(gv);
d70 1
a70 1
		dump_form(gv);
d73 1
a73 1
		dump_packsubs(hv);		/* nested package */
d81 1
a81 1
    SV *sv = sv_newmortal();
d84 1
a84 1
    Perl_dump_indent(aTHX_ 0, Perl_debug_log, "\nSUB %s = ", SvPVX(sv));
d98 1
a98 1
    SV *sv = sv_newmortal();
d101 1
a101 1
    Perl_dump_indent(aTHX_ 0, Perl_debug_log, "\nFORMAT %s = ", SvPVX(sv));
d117 2
a118 2
    int truncated = 0;
    int nul_terminated = len > cur && pv[cur] == '\0';
d123 1
a123 1
            truncated++;
d154 1
a154 2
    SV *t = sv_newmortal();
    STRLEN n_a;
d192 1
a192 1
		SvPVX(sv) && *SvPVX(sv) == '1' &&
d229 1
a229 1
	    SvCUR(t) = unref + 3;
d296 1
a296 1
	if (!SvPVX(sv))
d302 2
a303 2
		Perl_sv_catpvf(aTHX_ t, "[%s]", pv_display(tmp, SvPVX(sv)-SvIVX(sv), SvIVX(sv), 0, 127));
	    Perl_sv_catpvf(aTHX_ t, "%s)", pv_display(tmp, SvPVX(sv), SvCUR(sv), SvLEN(sv), 127));
d330 1
a330 1
    return SvPV(t, n_a);
d386 1
a386 1
	Perl_dump_indent(aTHX_ level, file, "PMFLAGS = (%s)\n", SvCUR(tmpsv) ? SvPVX(tmpsv) + 1 : "");
d470 1
a470 1
	Perl_dump_indent(aTHX_ level, file, "FLAGS = (%s)\n", SvCUR(tmpsv) ? SvPVX(tmpsv) + 1 : "");
d640 1
a640 1
	    Perl_dump_indent(aTHX_ level, file, "PRIVATE = (%s)\n", SvPVX(tmpsv) + 1);
a653 1
		STRLEN n_a;
d657 2
a658 1
		Perl_dump_indent(aTHX_ level, file, "GV = %s\n", SvPV(tmpsv, n_a));
d760 1
a760 1
    Perl_dump_indent(aTHX_ 1, Perl_debug_log, "GV_NAME = %s", SvPVX(sv));
d763 1
a763 1
	Perl_dump_indent(aTHX_ 1, Perl_debug_log, "-> %s", SvPVX(sv));
d774 1
a774 1
static struct { char type; char *name; } magic_names[] = {
d825 2
a826 2
            MGVTBL *v = mg->mg_virtual;
 	    char *s = 0;
d868 2
a869 2
	    char *name = 0;
	    for (n=0; magic_names[n].name; n++) {
d945 1
d947 2
a948 2
    if (sv && HvNAME(sv))
	PerlIO_printf(file, "\t\"%s\"\n", HvNAME(sv));
d968 1
d970 2
a971 2
	if (GvSTASH(sv))
	    PerlIO_printf(file, "%s\" :: \"", HvNAME(GvSTASH(sv)));
d982 1
a982 1
    char *s;
d1025 2
a1026 1
    if (flags & SVp_SCREAM)	sv_catpv(d, "SCREAM,");
d1048 1
d1073 1
a1073 1
	if (SvIsUV(sv))		sv_catpv(d, "IsUV,");
d1084 2
a1085 1
    if ((SvPOK(sv) || SvPOKp(sv)) && SvUTF8(sv))
d1088 4
a1091 2
    if (*(SvEND(d) - 1) == ',')
	SvPVX(d)[--SvCUR(d)] = '\0';
d1093 1
a1093 1
    s = SvPVX(d);
d1180 2
a1181 2
	if (SvPVX(sv)) {
	    Perl_dump_indent(aTHX_ level, file,"  PV = 0x%"UVxf" ", PTR2UV(SvPVX(sv)));
d1183 2
a1184 2
		PerlIO_printf(file, "( %s . ) ", pv_display(d, SvPVX(sv)-SvIVX(sv), SvIVX(sv), 0, pvlim));
	    PerlIO_printf(file, "%s", pv_display(d, SvPVX(sv), SvCUR(sv), SvLEN(sv), pvlim));
d1222 1
a1222 1
	sv_setpv(d, "");
d1226 2
a1227 1
	Perl_dump_indent(aTHX_ level, file, "  FLAGS = (%s)\n", SvCUR(d) ? SvPVX(d) + 1 : "");
d1297 2
a1298 2
	Perl_dump_indent(aTHX_ level, file, "  RITER = %"IVdf"\n", (IV)HvRITER(sv));
	Perl_dump_indent(aTHX_ level, file, "  EITER = 0x%"UVxf"\n", PTR2UV(HvEITER(sv)));
d1301 6
a1306 3
	if (HvNAME(sv))
	    Perl_dump_indent(aTHX_ level, file, "  NAME = \"%s\"\n", HvNAME(sv));
	if (nest < maxnest && !HvEITER(sv)) { /* Try to preserve iterator */
d1315 1
a1315 1
		char *keypv;
d1320 1
a1320 1
		keypv = SvPV(keysv, len);
d1322 1
a1322 1
		Perl_dump_indent(aTHX_ level+1, file, "Elt %s ", pv_display(d, keypv, len, 0, pvlim));
d1335 1
a1335 1
	    Perl_dump_indent(aTHX_ level, file, "  PROTOTYPE = \"%s\"\n", SvPV_nolen(sv));
d1362 1
a1362 1
	    CV *outside = CvOUTSIDE(sv);
a1467 4
    AV *padlist, *comppad;
    CV *cv;
    SV *sv;

d1479 1
a1479 1
	    sv = NEWSV(0,0);
d1481 1
a1481 1
	    PerlIO_printf(Perl_debug_log, "(%s)", SvPV_nolen(sv));
d1490 1
d1492 2
a1493 1
        cv = deb_curcv(cxstack_ix);
d1495 2
a1496 2
            padlist = CvPADLIST(cv);
            comppad = (AV*)(*av_fetch(padlist, 0, FALSE));
d1501 1
a1501 1
           PerlIO_printf(Perl_debug_log, "(%s)", SvPV_nolen(sv));
d1504 1
d1516 1
a1516 1
    PERL_CONTEXT *cx = &cxstack[ix];
d1539 1
a1539 1
S_debprof(pTHX_ OP *o)
d1544 1
a1544 1
	Newz(000, PL_profiledata, MAXO, U32);
d1561 10
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d16 7
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d119 11
a129 13
        if (isPRINT(*pv)) {
            switch (*pv) {
	    case '\t': sv_catpvn(dsv, "\\t", 2);  break;
	    case '\n': sv_catpvn(dsv, "\\n", 2);  break;
	    case '\r': sv_catpvn(dsv, "\\r", 2);  break;
	    case '\f': sv_catpvn(dsv, "\\f", 2);  break;
	    case '"':  sv_catpvn(dsv, "\\\"", 2); break;
	    case '\\': sv_catpvn(dsv, "\\\\", 2); break;
	    default:   sv_catpvn(dsv, pv, 1);     break;
            }
        }
	else {
	    if (cur && isDIGIT(*(pv+1)))
d645 12
a656 8
	if (cSVOPo->op_sv) {
	    SV *tmpsv = NEWSV(0,0);
	    STRLEN n_a;
	    ENTER;
	    SAVEFREESV(tmpsv);
	    gv_fullname3(tmpsv, (GV*)cSVOPo->op_sv, Nullch);
	    Perl_dump_indent(aTHX_ level, file, "GV = %s\n", SvPV(tmpsv, n_a));
	    LEAVE;
a657 2
	else
	    Perl_dump_indent(aTHX_ level, file, "GV = NULL\n");
d662 3
d666 1
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d163 1
a163 1
    else if (sv == &PL_sv_undef || sv == &PL_sv_no || sv == &PL_sv_yes) {
d181 1
a181 1
	else {
d192 7
d205 15
a219 2
    else if (DEBUG_R_TEST_ && SvREFCNT(sv) > 1) {
	Perl_sv_catpvf(aTHX_ t, "<%"UVuf">", (UV)SvREFCNT(sv));
a221 1

d422 2
a423 1
		    Perl_dump_indent(aTHX_ level, file, "LINE = %d\n",CopLINE(cCOPo));
d629 4
d662 1
a662 1
	Perl_dump_indent(aTHX_ level, file, "SV = %s\n", SvPEEK(cSVOPo->op_sv));
d668 2
a669 1
	    Perl_dump_indent(aTHX_ level, file, "LINE = %d\n",CopLINE(cCOPo));
d799 2
d844 1
d875 2
a876 1
	    if (mg->mg_flags & MGf_TAINTEDDIR)
d882 2
a883 1
	    if (mg->mg_flags & MGf_MINMATCH)
d896 5
a900 3
		SV *sv = newSVpvn("", 0);
                PerlIO_printf(file, " %s", pv_display(sv, mg->mg_ptr, mg->mg_len, 0, pvlim));
		SvREFCNT_dec(sv);
d911 12
a972 1
    STRLEN n_a;
d1008 2
a1009 1
    if (flags & SVf_AMAGIC)	sv_catpv(d, "OVERLOAD,");
d1028 1
d1034 1
d1070 1
a1070 1
    if (SvPOK(sv) && SvUTF8(sv))
a1156 2
	SvREFCNT_dec(d);
	return;
d1189 3
a1191 2
	/* XXX level+1 ??? */
	do_sv_dump(level, file, LvTARG(sv), nest+1, maxnest, dumpops, pvlim);
d1304 2
d1314 1
a1314 1
	    Perl_dump_indent(aTHX_ level, file, "  PROTOTYPE = \"%s\"\n", SvPV(sv,n_a));
d1333 1
d1337 2
a1338 20
	if (nest < maxnest && CvPADLIST(sv)) {
	    AV* padlist = CvPADLIST(sv);
	    AV* pad_name = (AV*)*av_fetch(padlist, 0, FALSE);
	    AV* pad = (AV*)*av_fetch(padlist, 1, FALSE);
	    SV** pname = AvARRAY(pad_name);
	    SV** ppad = AvARRAY(pad);
	    I32 ix;

	    for (ix = 1; ix <= AvFILL(pad_name); ix++) {
		if (SvPOK(pname[ix]))
		    Perl_dump_indent(aTHX_ level,
				/* %5d below is enough whitespace. */
				file,
				"%5d. 0x%"UVxf" (%s\"%s\" %"IVdf"-%"IVdf")\n",
				(int)ix, PTR2UV(ppad[ix]),
				SvFAKE(pname[ix]) ? "FAKE " : "",
				SvPVX(pname[ix]),
				(IV)SvNVX(pname[ix]),
				(IV)SvIVX(pname[ix]));
	    }
d1425 10
a1434 1
	    if (DEBUG_s_TEST_) debstack();
a1449 1
    STRLEN n_a;
d1464 1
a1464 1
	    PerlIO_printf(Perl_debug_log, "(%s)", SvPV(sv, n_a));
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d63 2
a64 2
	    if (HeKEY(entry)[HeKLEN(entry)-1] == ':' &&
	      (hv = GvHV(gv)) && HvNAME(hv) && hv != PL_defstash)
d78 2
a79 2
	Perl_dump_indent(aTHX_ 0, Perl_debug_log, "(xsub 0x%lx %d)\n",
	    (long)CvXSUB(GvCV(gv)),
d107 1
a107 1
Perl_pv_display(pTHX_ SV *sv, char *pv, STRLEN cur, STRLEN len, STRLEN pvlim)
d112 1
a112 1
    sv_setpvn(sv, "\"", 1);
d114 1
a114 1
	if (pvlim && SvCUR(sv) >= pvlim) {
d120 7
a126 7
	    case '\t': sv_catpvn(sv, "\\t", 2);  break;
	    case '\n': sv_catpvn(sv, "\\n", 2);  break;
	    case '\r': sv_catpvn(sv, "\\r", 2);  break;
	    case '\f': sv_catpvn(sv, "\\f", 2);  break;
	    case '"':  sv_catpvn(sv, "\\\"", 2); break;
	    case '\\': sv_catpvn(sv, "\\\\", 2); break;
	    default:   sv_catpvn(sv, pv, 1);     break;
d131 1
a131 1
		Perl_sv_catpvf(aTHX_ sv, "\\%03o", (U8)*pv);
d133 1
a133 1
		Perl_sv_catpvf(aTHX_ sv, "\\%o", (U8)*pv);
d136 1
a136 1
    sv_catpvn(sv, "\"", 1);
d138 1
a138 1
	sv_catpvn(sv, "...", 3);
d140 1
a140 1
	sv_catpvn(sv, "\\0", 2);
d142 1
a142 1
    return SvPVX(sv);
d197 5
d280 4
d289 1
a289 1
	Perl_sv_catpvf(aTHX_ t, "(%g)",SvNVX(sv));
d300 1
a300 1
    
d324 1
a324 1
    if (pm->op_pmregexp)
d326 1
a326 1
	     ch, pm->op_pmregexp->precomp, ch,
d334 1
a334 1
    if (pm->op_pmflags || (pm->op_pmregexp && pm->op_pmregexp->check_substr)) {
d342 2
a343 2
	if (pm->op_pmregexp && pm->op_pmregexp->check_substr
	    && !(pm->op_pmregexp->reganch & ROPT_NOSCAN))
d345 2
a346 2
	if (pm->op_pmregexp && pm->op_pmregexp->check_substr
	    && pm->op_pmregexp->reganch & ROPT_CHECK_ALL)
d386 1
a386 1
		  (int)(PL_dumpindent*level-4), "", PL_op_name[o->op_type]);
d397 1
d399 12
d454 8
a461 1
	if (o->op_type == OP_AASSIGN) {
d478 4
d503 6
d510 1
a510 1
	    else 
d522 3
d541 6
d555 2
a556 1
	} else if (o->op_type == OP_RV2CV) {
d560 48
d620 1
a620 1
	Perl_dump_indent(aTHX_ level, file, "PADIX = %d\n", cPADOPo->op_padix);
d733 47
d827 16
a842 4
	if (isPRINT(mg->mg_type))
	    Perl_dump_indent(aTHX_ level, file, "    MG_TYPE = '%c'\n", mg->mg_type);
	else
	    Perl_dump_indent(aTHX_ level, file, "    MG_TYPE = '\\%o'\n", mg->mg_type);
d913 1
a913 1
	if (GvSTASH(sv) && HvNAME(GvSTASH(sv)))
d934 1
a934 1
    
d977 1
d982 1
d987 1
d992 1
d995 1
d1009 1
a1009 1
	/* FALL THROGH */
a1012 1
	if (SvUTF8(sv))         sv_catpv(d, "UTF8");
d1018 4
d1023 2
d1122 4
a1125 1
	    PerlIO_printf(file, "%s\n", pv_display(d, SvPVX(sv), SvCUR(sv), SvLEN(sv), pvlim));
d1170 1
a1170 1
		if (elt) 
d1188 1
a1188 1
	    for (i = 0; i <= HvMAX(sv); i++) {
d1208 11
a1218 1
	    /* Now calculate quality wrt theoretical value */
a1223 1
	    /* Approximate by Poisson distribution */
d1225 1
a1225 1
	    theoret += theoret * theoret/pow2;
d1245 5
a1249 4
	    while ((he = hv_iternext(hv)) && count--) {
		SV *elt;
		char *key;
		I32 len;
d1252 2
a1253 1
		key = hv_iterkey(he, &len);
d1255 4
a1258 1
		Perl_dump_indent(aTHX_ level+1, file, "Elt %s HASH = 0x%"UVxf"\n", pv_display(d, key, len, 0, pvlim), (UV)hash);
d1280 1
a1280 1
#ifdef USE_THREADS
d1283 1
a1283 1
#endif /* USE_THREADS */
d1300 1
a1300 1
				file, 
d1311 1
a1311 1
	    Perl_dump_indent(aTHX_ level, file, "  OUTSIDE = 0x%"UVxf" (%s)\n", 
d1375 126
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a31 1
    dTHR;
a38 1
    dTHR;
a47 1
    dTHR;
d279 1
a279 1
 	RESTORE_NUMERIC_STANDARD();
d281 1
a281 1
 	RESTORE_NUMERIC_LOCAL();
a368 1
    dTHR;
d456 1
d768 1
a768 2
    dTHR;
    SV *d = sv_newmortal();
d782 1
a782 1
    Perl_sv_setpvf(aTHX_ d,
d823 2
d834 1
d869 1
d918 1
d931 1
a931 1
	RESTORE_NUMERIC_STANDARD();
d944 1
d947 2
a948 1
    if (type < SVt_PV)
d950 1
d1049 1
a1049 1
	    Perl_dump_indent(aTHX_ level, file, "  hash quality = %.1f%%", theoret/sum*100);
d1185 1
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d16 1
d18 1
d20 8
a27 3
#ifndef PERL_OBJECT
static void dump(char *pat, ...);
#endif /* PERL_OBJECT */
d30 9
a38 1
dump_all(void)
a39 1
#ifdef DEBUGGING
d43 1
a43 1
	dump_op(PL_main_root);
a44 1
#endif	/* DEBUGGING */
d48 1
a48 1
dump_packsubs(HV *stash)
a49 1
#ifdef DEBUGGING
a70 1
#endif	/* DEBUGGING */
d74 1
a74 1
dump_sub(GV *gv)
a75 1
#ifdef DEBUGGING
d79 1
a79 1
    dump("\nSUB %s = ", SvPVX(sv));
d81 1
a81 1
	dump("(xsub 0x%x %d)\n",
d83 1
a83 1
	    CvXSUBANY(GvCV(gv)).any_i32);
d85 1
a85 1
	dump_op(CvROOT(GvCV(gv)));
d87 1
a87 2
	dump("<undef>\n");
#endif	/* DEBUGGING */
d91 1
a91 1
dump_form(GV *gv)
a92 1
#ifdef DEBUGGING
d96 1
a96 1
    dump("\nFORMAT %s = ", SvPVX(sv));
d98 1
a98 1
	dump_op(CvROOT(GvFORM(gv)));
d100 1
a100 2
	dump("<undef>\n");
#endif	/* DEBUGGING */
d104 1
a104 1
dump_eval(void)
d106 195
a300 3
#ifdef DEBUGGING
    dump_op(PL_eval_root);
#endif	/* DEBUGGING */
d304 1
a304 1
dump_op(OP *o)
d306 69
a374 2
#ifdef DEBUGGING
    dump("{\n");
d376 1
a376 1
	PerlIO_printf(Perl_debug_log, "%-4d", o->op_seq);
d378 4
a381 2
	PerlIO_printf(Perl_debug_log, "    ");
    dump("TYPE = %s  ===> ", op_name[o->op_type]);
d384 1
a384 1
	    PerlIO_printf(Perl_debug_log, "%d\n", o->op_next->op_seq);
d386 1
a386 1
	    PerlIO_printf(Perl_debug_log, "(%d)\n", o->op_next->op_seq);
d389 1
a389 2
	PerlIO_printf(Perl_debug_log, "DONE\n");
    PL_dumplvl++;
d392 1
a392 1
	    dump("  (was %s)\n", op_name[o->op_targ]);
d394 1
a394 1
	    dump("TARG = %d\n", o->op_targ);
d397 1
a397 1
    dump("ADDR = 0x%lx => 0x%lx\n",o, o->op_next);
d400 1
a400 1
	SV *tmpsv = newSVpv("", 0);
d427 1
a427 1
	dump("FLAGS = (%s)\n", SvCUR(tmpsv) ? SvPVX(tmpsv) + 1 : "");
d431 5
a435 1
	SV *tmpsv = newSVpv("", 0);
d439 2
d471 2
d474 2
a475 1
	    switch (o->op_private & OPpDEREF) {
d493 2
d500 2
d510 3
d517 1
a517 1
	    dump("PRIVATE = (%s)\n", SvPVX(tmpsv) + 1);
d522 1
d525 5
a529 1
	if (cGVOPo->op_gv) {
a530 1
	    SV *tmpsv = NEWSV(0,0);
d533 2
a534 2
	    gv_fullname3(tmpsv, cGVOPo->op_gv, Nullch);
	    dump("GV = %s\n", SvPV(tmpsv, n_a));
d538 2
a539 1
	    dump("GV = NULL\n");
d542 2
a543 1
	dump("SV = %s\n", SvPEEK(cSVOPo->op_sv));
d545 1
d548 5
a552 2
	if (cCOPo->cop_line)
	    dump("LINE = %d\n",cCOPo->cop_line);
d554 2
a555 1
	    dump("LABEL = \"%s\"\n",cCOPo->cop_label);
d558 1
a558 1
	dump("REDO ===> ");
d560 1
a560 1
	    PerlIO_printf(Perl_debug_log, "%d\n", cLOOPo->op_redoop->op_seq);
d562 2
a563 2
	    PerlIO_printf(Perl_debug_log, "DONE\n");
	dump("NEXT ===> ");
d565 1
a565 1
	    PerlIO_printf(Perl_debug_log, "%d\n", cLOOPo->op_nextop->op_seq);
d567 2
a568 2
	    PerlIO_printf(Perl_debug_log, "DONE\n");
	dump("LAST ===> ");
d570 1
a570 1
	    PerlIO_printf(Perl_debug_log, "%d\n", cLOOPo->op_lastop->op_seq);
d572 1
a572 1
	    PerlIO_printf(Perl_debug_log, "DONE\n");
d575 1
a575 11
	dump("TRUE ===> ");
	if (cCONDOPo->op_true)
	    PerlIO_printf(Perl_debug_log, "%d\n", cCONDOPo->op_true->op_seq);
	else
	    PerlIO_printf(Perl_debug_log, "DONE\n");
	dump("FALSE ===> ");
	if (cCONDOPo->op_false)
	    PerlIO_printf(Perl_debug_log, "%d\n", cCONDOPo->op_false->op_seq);
	else
	    PerlIO_printf(Perl_debug_log, "DONE\n");
	break;
d580 1
a580 1
	dump("OTHER ===> ");
d582 1
a582 1
	    PerlIO_printf(Perl_debug_log, "%d\n", cLOGOPo->op_other->op_seq);
d584 1
a584 1
	    PerlIO_printf(Perl_debug_log, "DONE\n");
d590 10
a599 1
	dump_pm(cPMOPo);
d607 1
a607 1
	    dump_op(kid);
d609 7
a615 3
    PL_dumplvl--;
    dump("}\n");
#endif	/* DEBUGGING */
d619 1
a619 1
dump_gv(GV *gv)
a620 1
#ifdef DEBUGGING
a627 1
    PL_dumplvl++;
d630 1
a630 1
    dump("GV_NAME = %s", SvPVX(sv));
d633 1
a633 1
	dump("-> %s", SvPVX(sv));
d635 2
a636 4
    dump("\n");
    PL_dumplvl--;
    dump("}\n");
#endif	/* DEBUGGING */
d640 1
a640 1
dump_pm(PMOP *pm)
d642 48
a689 2
#ifdef DEBUGGING
    char ch;
d691 34
a724 3
    if (!pm) {
	dump("{}\n");
	return;
d726 24
a749 4
    dump("{\n");
    PL_dumplvl++;
    if (pm->op_pmflags & PMf_ONCE)
	ch = '?';
d751 13
a763 5
	ch = '/';
    if (pm->op_pmregexp)
	dump("PMf_PRE %c%s%c%s\n",
	     ch, pm->op_pmregexp->precomp, ch,
	     (pm->op_private & OPpRUNTIME) ? " (RUNTIME)" : "");
d765 42
a806 4
	dump("PMf_PRE (RUNTIME)\n");
    if (pm->op_type != OP_PUSHRE && pm->op_pmreplroot) {
	dump("PMf_REPL = ");
	dump_op(pm->op_pmreplroot);
d808 51
a858 30
    if (pm->op_pmflags || (pm->op_pmregexp && pm->op_pmregexp->check_substr)) {
	SV *tmpsv = newSVpv("", 0);
	if (pm->op_pmdynflags & PMdf_USED)
	    sv_catpv(tmpsv, ",USED");
	if (pm->op_pmdynflags & PMdf_TAINTED)
	    sv_catpv(tmpsv, ",TAINTED");
	if (pm->op_pmflags & PMf_ONCE)
	    sv_catpv(tmpsv, ",ONCE");
	if (pm->op_pmregexp && pm->op_pmregexp->check_substr
	    && !(pm->op_pmregexp->reganch & ROPT_NOSCAN))
	    sv_catpv(tmpsv, ",SCANFIRST");
	if (pm->op_pmregexp && pm->op_pmregexp->check_substr
	    && pm->op_pmregexp->reganch & ROPT_CHECK_ALL)
	    sv_catpv(tmpsv, ",ALL");
	if (pm->op_pmflags & PMf_SKIPWHITE)
	    sv_catpv(tmpsv, ",SKIPWHITE");
	if (pm->op_pmflags & PMf_CONST)
	    sv_catpv(tmpsv, ",CONST");
	if (pm->op_pmflags & PMf_KEEP)
	    sv_catpv(tmpsv, ",KEEP");
	if (pm->op_pmflags & PMf_GLOBAL)
	    sv_catpv(tmpsv, ",GLOBAL");
	if (pm->op_pmflags & PMf_CONTINUE)
	    sv_catpv(tmpsv, ",CONTINUE");
	if (pm->op_pmflags & PMf_RETAINT)
	    sv_catpv(tmpsv, ",RETAINT");
	if (pm->op_pmflags & PMf_EVAL)
	    sv_catpv(tmpsv, ",EVAL");
	dump("PMFLAGS = (%s)\n", SvCUR(tmpsv) ? SvPVX(tmpsv) + 1 : "");
	SvREFCNT_dec(tmpsv);
d861 320
a1180 3
    PL_dumplvl--;
    dump("}\n");
#endif	/* DEBUGGING */
d1183 2
a1184 3

STATIC void
dump(char *pat,...)
d1186 1
a1186 10
#ifdef DEBUGGING
    I32 i;
    va_list args;

    va_start(args, pat);
    for (i = PL_dumplvl*4; i; i--)
	(void)PerlIO_putc(Perl_debug_log,' ');
    PerlIO_vprintf(Perl_debug_log,pat,args);
    va_end(args);
#endif	/* DEBUGGING */
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d18 1
a18 8
#ifndef DEBUGGING
void
dump_all()
{
}
#else  /* Rest of file is for DEBUGGING */

#ifdef I_STDARG
d20 1
a20 3
#else
static void dump();
#endif
d23 1
a23 1
dump_all()
d25 2
d28 4
a31 3
    if (main_root)
	dump_op(main_root);
    dump_packsubs(defstash);
d35 1
a35 2
dump_packsubs(stash)
HV* stash;
d37 2
d48 2
d55 1
a55 1
	      (hv = GvHV(gv)) && HvNAME(hv) && hv != defstash)
d59 1
d63 1
a63 2
dump_sub(gv)
GV* gv;
d65 1
d78 1
d82 1
a82 2
dump_form(gv)
GV* gv;
d84 1
d93 1
d97 1
a97 1
dump_eval()
d99 3
a101 1
    dump_op(eval_root);
d105 1
a105 2
dump_op(op)
register OP *op;
d107 1
d109 2
a110 2
    if (op->op_seq)
	PerlIO_printf(Perl_debug_log, "%-4d", op->op_seq);
d113 4
a116 4
    dump("TYPE = %s  ===> ", op_name[op->op_type]);
    if (op->op_next) {
	if (op->op_seq)
	    PerlIO_printf(Perl_debug_log, "%d\n", op->op_next->op_seq);
d118 1
a118 1
	    PerlIO_printf(Perl_debug_log, "(%d)\n", op->op_next->op_seq);
d122 4
a125 4
    dumplvl++;
    if (op->op_targ) {
	if (op->op_type == OP_NULL)
	    dump("  (was %s)\n", op_name[op->op_targ]);
d127 1
a127 1
	    dump("TARG = %d\n", op->op_targ);
d130 1
a130 1
    dump("ADDR = 0x%lx => 0x%lx\n",op, op->op_next);
d132 1
a132 1
    if (op->op_flags) {
d134 1
a134 1
	switch (op->op_flags & OPf_WANT) {
d148 1
a148 1
	if (op->op_flags & OPf_KIDS)
d150 1
a150 1
	if (op->op_flags & OPf_PARENS)
d152 1
a152 1
	if (op->op_flags & OPf_STACKED)
d154 1
a154 1
	if (op->op_flags & OPf_REF)
d156 1
a156 1
	if (op->op_flags & OPf_MOD)
d158 1
a158 1
	if (op->op_flags & OPf_SPECIAL)
d163 1
a163 1
    if (op->op_private) {
d165 2
a166 2
	if (op->op_type == OP_AASSIGN) {
	    if (op->op_private & OPpASSIGN_COMMON)
d169 2
a170 2
	else if (op->op_type == OP_SASSIGN) {
	    if (op->op_private & OPpASSIGN_BACKWARDS)
d173 2
a174 2
	else if (op->op_type == OP_TRANS) {
	    if (op->op_private & OPpTRANS_SQUASH)
d176 1
a176 1
	    if (op->op_private & OPpTRANS_DELETE)
d178 1
a178 1
	    if (op->op_private & OPpTRANS_COMPLEMENT)
d181 2
a182 2
	else if (op->op_type == OP_REPEAT) {
	    if (op->op_private & OPpREPEAT_DOLIST)
d185 7
a191 7
	else if (op->op_type == OP_ENTERSUB ||
		 op->op_type == OP_RV2SV ||
		 op->op_type == OP_RV2AV ||
		 op->op_type == OP_RV2HV ||
		 op->op_type == OP_RV2GV ||
		 op->op_type == OP_AELEM ||
		 op->op_type == OP_HELEM )
d193 2
a194 2
	    if (op->op_type == OP_ENTERSUB) {
		if (op->op_private & OPpENTERSUB_AMPER)
d196 1
a196 1
		if (op->op_private & OPpENTERSUB_DB)
d199 1
a199 1
	    switch (op->op_private & OPpDEREF) {
d210 2
a211 2
	    if (op->op_type == OP_AELEM || op->op_type == OP_HELEM) {
		if (op->op_private & OPpLVAL_DEFER)
d215 1
a215 1
		if (op->op_private & HINT_STRICT_REFS)
d219 2
a220 2
	else if (op->op_type == OP_CONST) {
	    if (op->op_private & OPpCONST_BARE)
d223 2
a224 2
	else if (op->op_type == OP_FLIP) {
	    if (op->op_private & OPpFLIP_LINENUM)
d227 2
a228 2
	else if (op->op_type == OP_FLOP) {
	    if (op->op_private & OPpFLIP_LINENUM)
d231 1
a231 1
	if (op->op_flags & OPf_MOD && op->op_private & OPpLVAL_INTRO)
d238 1
a238 1
    switch (op->op_type) {
d241 2
a242 1
	if (cGVOP->op_gv) {
d246 2
a247 2
	    gv_fullname3(tmpsv, cGVOP->op_gv, Nullch);
	    dump("GV = %s\n", SvPV(tmpsv, na));
d254 1
a254 1
	dump("SV = %s\n", SvPEEK(cSVOP->op_sv));
d258 4
a261 4
	if (cCOP->cop_line)
	    dump("LINE = %d\n",cCOP->cop_line);
	if (cCOP->cop_label)
	    dump("LABEL = \"%s\"\n",cCOP->cop_label);
d265 2
a266 2
	if (cLOOP->op_redoop)
	    PerlIO_printf(Perl_debug_log, "%d\n", cLOOP->op_redoop->op_seq);
d270 2
a271 2
	if (cLOOP->op_nextop)
	    PerlIO_printf(Perl_debug_log, "%d\n", cLOOP->op_nextop->op_seq);
d275 2
a276 2
	if (cLOOP->op_lastop)
	    PerlIO_printf(Perl_debug_log, "%d\n", cLOOP->op_lastop->op_seq);
d282 2
a283 2
	if (cCONDOP->op_true)
	    PerlIO_printf(Perl_debug_log, "%d\n", cCONDOP->op_true->op_seq);
d287 2
a288 2
	if (cCONDOP->op_false)
	    PerlIO_printf(Perl_debug_log, "%d\n", cCONDOP->op_false->op_seq);
d297 2
a298 2
	if (cLOGOP->op_other)
	    PerlIO_printf(Perl_debug_log, "%d\n", cLOGOP->op_other->op_seq);
d304 1
d306 1
a306 1
	dump_pm((PMOP*)op);
d311 1
a311 1
    if (op->op_flags & OPf_KIDS) {
d313 1
a313 1
	for (kid = cUNOP->op_first; kid; kid = kid->op_sibling)
d316 1
a316 1
    dumplvl--;
d318 1
d322 1
a322 2
dump_gv(gv)
register GV *gv;
d324 1
d332 1
a332 1
    dumplvl++;
d341 1
a341 1
    dumplvl--;
d343 1
d347 1
a347 2
dump_pm(pm)
register PMOP *pm;
d349 1
d357 1
a357 1
    dumplvl++;
d372 1
a372 4
    if (pm->op_pmshort) {
	dump("PMf_SHORT = %s\n",SvPEEK(pm->op_pmshort));
    }
    if (pm->op_pmflags) {
d374 1
a374 1
	if (pm->op_pmflags & PMf_USED)
d376 2
d380 2
a381 1
	if (pm->op_pmflags & PMf_SCANFIRST)
d383 2
a384 1
	if (pm->op_pmflags & PMf_ALL)
d396 2
d404 1
a404 1
    dumplvl--;
d406 1
d410 1
a410 17
#if !defined(I_STDARG) && !defined(I_VARARGS)
/* VARARGS1 */
static void dump(arg1,arg2,arg3,arg4,arg5)
char *arg1;
long arg2, arg3, arg4, arg5;
{
    I32 i;

    for (i = dumplvl*4; i; i--)
	(void)PerlIO_putc(Perl_debug_log,' ');
    PerlIO_printf(Perl_debug_log, arg1, arg2, arg3, arg4, arg5);
}

#else

#ifdef I_STDARG
static void
a411 7
#else
/*VARARGS0*/
static void
dump(pat,va_alist)
    char *pat;
    va_dcl
#endif
d413 1
a416 1
#ifdef I_STDARG
d418 1
a418 4
#else
    va_start(args);
#endif
    for (i = dumplvl*4; i; i--)
d422 1
a423 3
#endif

#endif
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d25 3
d29 1
d34 1
a34 5
#ifdef HAS_SETLINEBUF
    setlinebuf(stderr);
#else
    setvbuf(stderr, Nullch, _IOLBF, 0);
#endif
d50 2
a51 2
	for (entry = HvARRAY(stash)[i]; entry; entry = entry->hent_next) {
	    GV *gv = (GV*)entry->hent_val;
d53 1
a53 1
	    if (GvCV(gv))
d57 1
a57 1
	    if (entry->hent_key[entry->hent_klen-1] == ':' &&
d70 1
a70 1
    gv_fullname(sv,gv);
d88 1
a88 1
    gv_fullname(sv,gv);
a105 2
    SV *tmpsv;

d108 1
a108 1
	fprintf(stderr, "%-4d", op->op_seq);
d110 1
a110 1
	fprintf(stderr, "    ");
d114 1
a114 1
	    fprintf(stderr, "%d\n", op->op_next->op_seq);
d116 1
a116 1
	    fprintf(stderr, "(%d)\n", op->op_next->op_seq);
d119 1
a119 1
	fprintf(stderr, "DONE\n");
d131 14
a144 6
	*buf = '\0';
	if (op->op_flags & OPf_KNOW) {
	    if (op->op_flags & OPf_LIST)
		(void)strcat(buf,"LIST,");
	    else
		(void)strcat(buf,"SCALAR,");
a145 2
	else
	    (void)strcat(buf,"UNKNOWN,");
d147 1
a147 1
	    (void)strcat(buf,"KIDS,");
d149 1
a149 1
	    (void)strcat(buf,"PARENS,");
d151 1
a151 1
	    (void)strcat(buf,"STACKED,");
d153 1
a153 1
	    (void)strcat(buf,"REF,");
d155 1
a155 1
	    (void)strcat(buf,"MOD,");
d157 3
a159 4
	    (void)strcat(buf,"SPECIAL,");
	if (*buf)
	    buf[strlen(buf)-1] = '\0';
	dump("FLAGS = (%s)\n",buf);
d162 1
a162 1
	*buf = '\0';
d165 1
a165 1
		(void)strcat(buf,"COMMON,");
d169 1
a169 1
		(void)strcat(buf,"BACKWARDS,");
d173 1
a173 1
		(void)strcat(buf,"SQUASH,");
d175 1
a175 1
		(void)strcat(buf,"DELETE,");
d177 1
a177 1
		(void)strcat(buf,"COMPLEMENT,");
d181 1
a181 1
		(void)strcat(buf,"DOLIST,");
d191 25
a215 10
	    if (op->op_private & OPpENTERSUB_AMPER)
		(void)strcat(buf,"AMPER,");
	    if (op->op_private & OPpENTERSUB_DB)
		(void)strcat(buf,"DB,");
	    if (op->op_private & OPpDEREF_AV)
		(void)strcat(buf,"AV,");
	    if (op->op_private & OPpDEREF_HV)
		(void)strcat(buf,"HV,");
	    if (op->op_private & HINT_STRICT_REFS)
		(void)strcat(buf,"STRICT_REFS,");
d219 1
a219 1
		(void)strcat(buf,"BARE,");
d223 1
a223 1
		(void)strcat(buf,"LINENUM,");
d227 1
a227 1
		(void)strcat(buf,"LINENUM,");
d230 4
a233 5
	    (void)strcat(buf,"INTRO,");
	if (*buf) {
	    buf[strlen(buf)-1] = '\0';
	    dump("PRIVATE = (%s)\n",buf);
	}
d240 1
a241 1
	    tmpsv = NEWSV(0,0);
d243 1
a243 1
	    gv_fullname(tmpsv,cGVOP->op_gv);
d263 1
a263 1
	    fprintf(stderr, "%d\n", cLOOP->op_redoop->op_seq);
d265 1
a265 1
	    fprintf(stderr, "DONE\n");
d268 1
a268 1
	    fprintf(stderr, "%d\n", cLOOP->op_nextop->op_seq);
d270 1
a270 1
	    fprintf(stderr, "DONE\n");
d273 1
a273 1
	    fprintf(stderr, "%d\n", cLOOP->op_lastop->op_seq);
d275 1
a275 1
	    fprintf(stderr, "DONE\n");
d280 1
a280 1
	    fprintf(stderr, "%d\n", cCONDOP->op_true->op_seq);
d282 1
a282 1
	    fprintf(stderr, "DONE\n");
d285 1
a285 1
	    fprintf(stderr, "%d\n", cCONDOP->op_false->op_seq);
d287 1
a287 1
	    fprintf(stderr, "DONE\n");
d295 1
a295 1
	    fprintf(stderr, "%d\n", cLOGOP->op_other->op_seq);
d297 1
a297 1
	    fprintf(stderr, "DONE\n");
d323 1
a323 1
	fprintf(stderr,"{}\n");
d328 2
a329 2
    fprintf(stderr,"{\n");
    gv_fullname(sv,gv);
d332 1
a332 1
	gv_efullname(sv,GvEGV(gv));
d357 5
a361 1
	dump("PMf_PRE %c%s%c\n",ch,pm->op_pmregexp->precomp,ch);
d370 1
a370 1
	*buf = '\0';
d372 1
a372 1
	    (void)strcat(buf,"USED,");
d374 1
a374 1
	    (void)strcat(buf,"ONCE,");
d376 1
a376 1
	    (void)strcat(buf,"SCANFIRST,");
d378 1
a378 1
	    (void)strcat(buf,"ALL,");
d380 1
a380 3
	    (void)strcat(buf,"SKIPWHITE,");
	if (pm->op_pmflags & PMf_FOLD)
	    (void)strcat(buf,"FOLD,");
d382 1
a382 1
	    (void)strcat(buf,"CONST,");
d384 1
a384 1
	    (void)strcat(buf,"KEEP,");
d386 3
a388 3
	    (void)strcat(buf,"GLOBAL,");
	if (pm->op_pmflags & PMf_RUNTIME)
	    (void)strcat(buf,"RUNTIME,");
d390 3
a392 4
	    (void)strcat(buf,"EVAL,");
	if (*buf)
	    buf[strlen(buf)-1] = '\0';
	dump("PMFLAGS = (%s)\n",buf);
d399 2
d409 2
a410 2
	(void)putc(' ',stderr);
    fprintf(stderr,arg1, arg2, arg3, arg4, arg5);
d412 29
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d18 8
a25 3
#ifndef PERL_OBJECT
static void dump(char *pat, ...);
#endif /* PERL_OBJECT */
d28 1
a28 1
dump_all(void)
d30 8
a37 7
#ifdef DEBUGGING
    dTHR;
    PerlIO_setlinebuf(Perl_debug_log);
    if (PL_main_root)
	dump_op(PL_main_root);
    dump_packsubs(PL_defstash);
#endif	/* DEBUGGING */
d41 2
a42 1
dump_packsubs(HV *stash)
a43 2
#ifdef DEBUGGING
    dTHR;
d50 2
a51 2
	for (entry = HvARRAY(stash)[i]; entry; entry = HeNEXT(entry)) {
	    GV *gv = (GV*)HeVAL(entry);
d53 1
a53 3
	    if (SvTYPE(gv) != SVt_PVGV || !GvGP(gv))
		continue;
	    if (GvCVu(gv))
d57 2
a58 2
	    if (HeKEY(entry)[HeKLEN(entry)-1] == ':' &&
	      (hv = GvHV(gv)) && HvNAME(hv) && hv != PL_defstash)
a61 1
#endif	/* DEBUGGING */
d65 2
a66 1
dump_sub(GV *gv)
a67 1
#ifdef DEBUGGING
d70 1
a70 1
    gv_fullname3(sv, gv, Nullch);
a79 1
#endif	/* DEBUGGING */
d83 2
a84 1
dump_form(GV *gv)
a85 1
#ifdef DEBUGGING
d88 1
a88 1
    gv_fullname3(sv, gv, Nullch);
a93 1
#endif	/* DEBUGGING */
d97 1
a97 1
dump_eval(void)
d99 1
a99 3
#ifdef DEBUGGING
    dump_op(PL_eval_root);
#endif	/* DEBUGGING */
d103 2
a104 1
dump_op(OP *o)
d106 2
a107 1
#ifdef DEBUGGING
d109 2
a110 2
    if (o->op_seq)
	PerlIO_printf(Perl_debug_log, "%-4d", o->op_seq);
d112 5
a116 5
	PerlIO_printf(Perl_debug_log, "    ");
    dump("TYPE = %s  ===> ", op_name[o->op_type]);
    if (o->op_next) {
	if (o->op_seq)
	    PerlIO_printf(Perl_debug_log, "%d\n", o->op_next->op_seq);
d118 1
a118 1
	    PerlIO_printf(Perl_debug_log, "(%d)\n", o->op_next->op_seq);
d121 5
a125 5
	PerlIO_printf(Perl_debug_log, "DONE\n");
    PL_dumplvl++;
    if (o->op_targ) {
	if (o->op_type == OP_NULL)
	    dump("  (was %s)\n", op_name[o->op_targ]);
d127 1
a127 1
	    dump("TARG = %d\n", o->op_targ);
d130 1
a130 1
    dump("ADDR = 0x%lx => 0x%lx\n",o, o->op_next);
d132 55
a186 60
    if (o->op_flags) {
	SV *tmpsv = newSVpv("", 0);
	switch (o->op_flags & OPf_WANT) {
	case OPf_WANT_VOID:
	    sv_catpv(tmpsv, ",VOID");
	    break;
	case OPf_WANT_SCALAR:
	    sv_catpv(tmpsv, ",SCALAR");
	    break;
	case OPf_WANT_LIST:
	    sv_catpv(tmpsv, ",LIST");
	    break;
	default:
	    sv_catpv(tmpsv, ",UNKNOWN");
	    break;
	}
	if (o->op_flags & OPf_KIDS)
	    sv_catpv(tmpsv, ",KIDS");
	if (o->op_flags & OPf_PARENS)
	    sv_catpv(tmpsv, ",PARENS");
	if (o->op_flags & OPf_STACKED)
	    sv_catpv(tmpsv, ",STACKED");
	if (o->op_flags & OPf_REF)
	    sv_catpv(tmpsv, ",REF");
	if (o->op_flags & OPf_MOD)
	    sv_catpv(tmpsv, ",MOD");
	if (o->op_flags & OPf_SPECIAL)
	    sv_catpv(tmpsv, ",SPECIAL");
	dump("FLAGS = (%s)\n", SvCUR(tmpsv) ? SvPVX(tmpsv) + 1 : "");
	SvREFCNT_dec(tmpsv);
    }
    if (o->op_private) {
	SV *tmpsv = newSVpv("", 0);
	if (o->op_type == OP_AASSIGN) {
	    if (o->op_private & OPpASSIGN_COMMON)
		sv_catpv(tmpsv, ",COMMON");
	}
	else if (o->op_type == OP_SASSIGN) {
	    if (o->op_private & OPpASSIGN_BACKWARDS)
		sv_catpv(tmpsv, ",BACKWARDS");
	}
	else if (o->op_type == OP_TRANS) {
	    if (o->op_private & OPpTRANS_SQUASH)
		sv_catpv(tmpsv, ",SQUASH");
	    if (o->op_private & OPpTRANS_DELETE)
		sv_catpv(tmpsv, ",DELETE");
	    if (o->op_private & OPpTRANS_COMPLEMENT)
		sv_catpv(tmpsv, ",COMPLEMENT");
	}
	else if (o->op_type == OP_REPEAT) {
	    if (o->op_private & OPpREPEAT_DOLIST)
		sv_catpv(tmpsv, ",DOLIST");
	}
	else if (o->op_type == OP_ENTERSUB ||
		 o->op_type == OP_RV2SV ||
		 o->op_type == OP_RV2AV ||
		 o->op_type == OP_RV2HV ||
		 o->op_type == OP_RV2GV ||
		 o->op_type == OP_AELEM ||
		 o->op_type == OP_HELEM )
d188 29
a216 43
	    if (o->op_type == OP_ENTERSUB) {
		if (o->op_private & OPpENTERSUB_AMPER)
		    sv_catpv(tmpsv, ",AMPER");
		if (o->op_private & OPpENTERSUB_DB)
		    sv_catpv(tmpsv, ",DB");
	    }
	    switch (o->op_private & OPpDEREF) {
	    case OPpDEREF_SV:
		sv_catpv(tmpsv, ",SV");
		break;
	    case OPpDEREF_AV:
		sv_catpv(tmpsv, ",AV");
		break;
	    case OPpDEREF_HV:
		sv_catpv(tmpsv, ",HV");
		break;
	    }
	    if (o->op_type == OP_AELEM || o->op_type == OP_HELEM) {
		if (o->op_private & OPpLVAL_DEFER)
		    sv_catpv(tmpsv, ",LVAL_DEFER");
	    }
	    else {
		if (o->op_private & HINT_STRICT_REFS)
		    sv_catpv(tmpsv, ",STRICT_REFS");
	    }
	}
	else if (o->op_type == OP_CONST) {
	    if (o->op_private & OPpCONST_BARE)
		sv_catpv(tmpsv, ",BARE");
	}
	else if (o->op_type == OP_FLIP) {
	    if (o->op_private & OPpFLIP_LINENUM)
		sv_catpv(tmpsv, ",LINENUM");
	}
	else if (o->op_type == OP_FLOP) {
	    if (o->op_private & OPpFLIP_LINENUM)
		sv_catpv(tmpsv, ",LINENUM");
	}
	if (o->op_flags & OPf_MOD && o->op_private & OPpLVAL_INTRO)
	    sv_catpv(tmpsv, ",INTRO");
	if (SvCUR(tmpsv))
	    dump("PRIVATE = (%s)\n", SvPVX(tmpsv) + 1);
	SvREFCNT_dec(tmpsv);
d219 1
a219 1
    switch (o->op_type) {
d222 1
a222 3
	if (cGVOPo->op_gv) {
	    STRLEN n_a;
	    SV *tmpsv = NEWSV(0,0);
d224 1
d226 2
a227 2
	    gv_fullname3(tmpsv, cGVOPo->op_gv, Nullch);
	    dump("GV = %s\n", SvPV(tmpsv, n_a));
d234 1
a234 1
	dump("SV = %s\n", SvPEEK(cSVOPo->op_sv));
d238 4
a241 4
	if (cCOPo->cop_line)
	    dump("LINE = %d\n",cCOPo->cop_line);
	if (cCOPo->cop_label)
	    dump("LABEL = \"%s\"\n",cCOPo->cop_label);
d245 2
a246 2
	if (cLOOPo->op_redoop)
	    PerlIO_printf(Perl_debug_log, "%d\n", cLOOPo->op_redoop->op_seq);
d248 1
a248 1
	    PerlIO_printf(Perl_debug_log, "DONE\n");
d250 2
a251 2
	if (cLOOPo->op_nextop)
	    PerlIO_printf(Perl_debug_log, "%d\n", cLOOPo->op_nextop->op_seq);
d253 1
a253 1
	    PerlIO_printf(Perl_debug_log, "DONE\n");
d255 2
a256 2
	if (cLOOPo->op_lastop)
	    PerlIO_printf(Perl_debug_log, "%d\n", cLOOPo->op_lastop->op_seq);
d258 1
a258 1
	    PerlIO_printf(Perl_debug_log, "DONE\n");
d262 2
a263 2
	if (cCONDOPo->op_true)
	    PerlIO_printf(Perl_debug_log, "%d\n", cCONDOPo->op_true->op_seq);
d265 1
a265 1
	    PerlIO_printf(Perl_debug_log, "DONE\n");
d267 2
a268 2
	if (cCONDOPo->op_false)
	    PerlIO_printf(Perl_debug_log, "%d\n", cCONDOPo->op_false->op_seq);
d270 1
a270 1
	    PerlIO_printf(Perl_debug_log, "DONE\n");
d277 2
a278 2
	if (cLOGOPo->op_other)
	    PerlIO_printf(Perl_debug_log, "%d\n", cLOGOPo->op_other->op_seq);
d280 1
a280 1
	    PerlIO_printf(Perl_debug_log, "DONE\n");
a283 1
    case OP_QR:
d285 1
a285 1
	dump_pm(cPMOPo);
d290 1
a290 1
    if (o->op_flags & OPf_KIDS) {
d292 1
a292 1
	for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling)
d295 1
a295 1
    PL_dumplvl--;
a296 1
#endif	/* DEBUGGING */
d300 2
a301 1
dump_gv(GV *gv)
a302 1
#ifdef DEBUGGING
d306 1
a306 1
	PerlIO_printf(Perl_debug_log, "{}\n");
d310 3
a312 3
    PL_dumplvl++;
    PerlIO_printf(Perl_debug_log, "{\n");
    gv_fullname3(sv, gv, Nullch);
d315 1
a315 1
	gv_efullname3(sv, GvEGV(gv), Nullch);
d319 1
a319 1
    PL_dumplvl--;
a320 1
#endif	/* DEBUGGING */
d324 2
a325 1
dump_pm(PMOP *pm)
a326 1
#ifdef DEBUGGING
d334 1
a334 1
    PL_dumplvl++;
d340 1
a340 5
	dump("PMf_PRE %c%s%c%s\n",
	     ch, pm->op_pmregexp->precomp, ch,
	     (pm->op_private & OPpRUNTIME) ? " (RUNTIME)" : "");
    else
	dump("PMf_PRE (RUNTIME)\n");
d345 7
a351 6
    if (pm->op_pmflags || (pm->op_pmregexp && pm->op_pmregexp->check_substr)) {
	SV *tmpsv = newSVpv("", 0);
	if (pm->op_pmdynflags & PMdf_USED)
	    sv_catpv(tmpsv, ",USED");
	if (pm->op_pmdynflags & PMdf_TAINTED)
	    sv_catpv(tmpsv, ",TAINTED");
d353 5
a357 7
	    sv_catpv(tmpsv, ",ONCE");
	if (pm->op_pmregexp && pm->op_pmregexp->check_substr
	    && !(pm->op_pmregexp->reganch & ROPT_NOSCAN))
	    sv_catpv(tmpsv, ",SCANFIRST");
	if (pm->op_pmregexp && pm->op_pmregexp->check_substr
	    && pm->op_pmregexp->reganch & ROPT_CHECK_ALL)
	    sv_catpv(tmpsv, ",ALL");
d359 3
a361 1
	    sv_catpv(tmpsv, ",SKIPWHITE");
d363 1
a363 1
	    sv_catpv(tmpsv, ",CONST");
d365 1
a365 1
	    sv_catpv(tmpsv, ",KEEP");
d367 3
a369 5
	    sv_catpv(tmpsv, ",GLOBAL");
	if (pm->op_pmflags & PMf_CONTINUE)
	    sv_catpv(tmpsv, ",CONTINUE");
	if (pm->op_pmflags & PMf_RETAINT)
	    sv_catpv(tmpsv, ",RETAINT");
d371 4
a374 3
	    sv_catpv(tmpsv, ",EVAL");
	dump("PMFLAGS = (%s)\n", SvCUR(tmpsv) ? SvPVX(tmpsv) + 1 : "");
	SvREFCNT_dec(tmpsv);
d377 1
a377 1
    PL_dumplvl--;
a378 1
#endif	/* DEBUGGING */
d381 4
a384 3

STATIC void
dump(char *pat,...)
a385 1
#ifdef DEBUGGING
a386 1
    va_list args;
d388 3
a390 6
    va_start(args, pat);
    for (i = PL_dumplvl*4; i; i--)
	(void)PerlIO_putc(Perl_debug_log,' ');
    PerlIO_vprintf(Perl_debug_log,pat,args);
    va_end(args);
#endif	/* DEBUGGING */
d392 1
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a15 1
#define PERL_IN_DUMP_C
a16 1
#include "regcomp.h"
d18 3
a20 8
void
Perl_dump_indent(pTHX_ I32 level, PerlIO *file, const char* pat, ...)
{
    va_list args;
    va_start(args, pat);
    dump_vindent(level, file, pat, &args);
    va_end(args);
}
d23 1
a23 9
Perl_dump_vindent(pTHX_ I32 level, PerlIO *file, const char* pat, va_list *args)
{
    dTHR;
    PerlIO_printf(file, "%*s", (int)(level*PL_dumpindent), "");
    PerlIO_vprintf(file, pat, *args);
}

void
Perl_dump_all(pTHX)
d25 1
d29 1
a29 1
	op_dump(PL_main_root);
d31 1
d35 1
a35 1
Perl_dump_packsubs(pTHX_ HV *stash)
d37 1
d59 1
d63 1
a63 1
Perl_dump_sub(pTHX_ GV *gv)
d65 1
d69 1
a69 1
    Perl_dump_indent(aTHX_ 0, Perl_debug_log, "\nSUB %s = ", SvPVX(sv));
d71 1
a71 1
	Perl_dump_indent(aTHX_ 0, Perl_debug_log, "(xsub 0x%lx %d)\n",
d73 1
a73 1
	    (int)CvXSUBANY(GvCV(gv)).any_i32);
d75 1
a75 1
	op_dump(CvROOT(GvCV(gv)));
d77 2
a78 1
	Perl_dump_indent(aTHX_ 0, Perl_debug_log, "<undef>\n");
d82 1
a82 1
Perl_dump_form(pTHX_ GV *gv)
d84 1
d88 1
a88 1
    Perl_dump_indent(aTHX_ 0, Perl_debug_log, "\nFORMAT %s = ", SvPVX(sv));
d90 1
a90 1
	op_dump(CvROOT(GvFORM(gv)));
d92 2
a93 1
	Perl_dump_indent(aTHX_ 0, Perl_debug_log, "<undef>\n");
d97 1
a97 1
Perl_dump_eval(pTHX)
d99 3
a101 195
    op_dump(PL_eval_root);
}

char *
Perl_pv_display(pTHX_ SV *sv, char *pv, STRLEN cur, STRLEN len, STRLEN pvlim)
{
    int truncated = 0;
    int nul_terminated = len > cur && pv[cur] == '\0';

    sv_setpvn(sv, "\"", 1);
    for (; cur--; pv++) {
	if (pvlim && SvCUR(sv) >= pvlim) {
            truncated++;
	    break;
        }
        if (isPRINT(*pv)) {
            switch (*pv) {
	    case '\t': sv_catpvn(sv, "\\t", 2);  break;
	    case '\n': sv_catpvn(sv, "\\n", 2);  break;
	    case '\r': sv_catpvn(sv, "\\r", 2);  break;
	    case '\f': sv_catpvn(sv, "\\f", 2);  break;
	    case '"':  sv_catpvn(sv, "\\\"", 2); break;
	    case '\\': sv_catpvn(sv, "\\\\", 2); break;
	    default:   sv_catpvn(sv, pv, 1);     break;
            }
        }
	else {
	    if (cur && isDIGIT(*(pv+1)))
		Perl_sv_catpvf(aTHX_ sv, "\\%03o", (U8)*pv);
	    else
		Perl_sv_catpvf(aTHX_ sv, "\\%o", (U8)*pv);
        }
    }
    sv_catpvn(sv, "\"", 1);
    if (truncated)
	sv_catpvn(sv, "...", 3);
    if (nul_terminated)
	sv_catpvn(sv, "\\0", 2);

    return SvPVX(sv);
}

char *
Perl_sv_peek(pTHX_ SV *sv)
{
    SV *t = sv_newmortal();
    STRLEN n_a;
    int unref = 0;

    sv_setpvn(t, "", 0);
  retry:
    if (!sv) {
	sv_catpv(t, "VOID");
	goto finish;
    }
    else if (sv == (SV*)0x55555555 || SvTYPE(sv) == 'U') {
	sv_catpv(t, "WILD");
	goto finish;
    }
    else if (sv == &PL_sv_undef || sv == &PL_sv_no || sv == &PL_sv_yes) {
	if (sv == &PL_sv_undef) {
	    sv_catpv(t, "SV_UNDEF");
	    if (!(SvFLAGS(sv) & (SVf_OK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		SvREADONLY(sv))
		goto finish;
	}
	else if (sv == &PL_sv_no) {
	    sv_catpv(t, "SV_NO");
	    if (!(SvFLAGS(sv) & (SVf_ROK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		!(~SvFLAGS(sv) & (SVf_POK|SVf_NOK|SVf_READONLY|
				  SVp_POK|SVp_NOK)) &&
		SvCUR(sv) == 0 &&
		SvNVX(sv) == 0.0)
		goto finish;
	}
	else {
	    sv_catpv(t, "SV_YES");
	    if (!(SvFLAGS(sv) & (SVf_ROK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		!(~SvFLAGS(sv) & (SVf_POK|SVf_NOK|SVf_READONLY|
				  SVp_POK|SVp_NOK)) &&
		SvCUR(sv) == 1 &&
		SvPVX(sv) && *SvPVX(sv) == '1' &&
		SvNVX(sv) == 1.0)
		goto finish;
	}
	sv_catpv(t, ":");
    }
    else if (SvREFCNT(sv) == 0) {
	sv_catpv(t, "(");
	unref++;
    }
    if (SvROK(sv)) {
	sv_catpv(t, "\\");
	if (SvCUR(t) + unref > 10) {
	    SvCUR(t) = unref + 3;
	    *SvEND(t) = '\0';
	    sv_catpv(t, "...");
	    goto finish;
	}
	sv = (SV*)SvRV(sv);
	goto retry;
    }
    switch (SvTYPE(sv)) {
    default:
	sv_catpv(t, "FREED");
	goto finish;

    case SVt_NULL:
	sv_catpv(t, "UNDEF");
	goto finish;
    case SVt_IV:
	sv_catpv(t, "IV");
	break;
    case SVt_NV:
	sv_catpv(t, "NV");
	break;
    case SVt_RV:
	sv_catpv(t, "RV");
	break;
    case SVt_PV:
	sv_catpv(t, "PV");
	break;
    case SVt_PVIV:
	sv_catpv(t, "PVIV");
	break;
    case SVt_PVNV:
	sv_catpv(t, "PVNV");
	break;
    case SVt_PVMG:
	sv_catpv(t, "PVMG");
	break;
    case SVt_PVLV:
	sv_catpv(t, "PVLV");
	break;
    case SVt_PVAV:
	sv_catpv(t, "AV");
	break;
    case SVt_PVHV:
	sv_catpv(t, "HV");
	break;
    case SVt_PVCV:
	if (CvGV(sv))
	    Perl_sv_catpvf(aTHX_ t, "CV(%s)", GvNAME(CvGV(sv)));
	else
	    sv_catpv(t, "CV()");
	goto finish;
    case SVt_PVGV:
	sv_catpv(t, "GV");
	break;
    case SVt_PVBM:
	sv_catpv(t, "BM");
	break;
    case SVt_PVFM:
	sv_catpv(t, "FM");
	break;
    case SVt_PVIO:
	sv_catpv(t, "IO");
	break;
    }

    if (SvPOKp(sv)) {
	if (!SvPVX(sv))
	    sv_catpv(t, "(null)");
	else {
	    SV *tmp = newSVpvn("", 0);
	    sv_catpv(t, "(");
	    if (SvOOK(sv))
		Perl_sv_catpvf(aTHX_ t, "[%s]", pv_display(tmp, SvPVX(sv)-SvIVX(sv), SvIVX(sv), 0, 127));
	    Perl_sv_catpvf(aTHX_ t, "%s)", pv_display(tmp, SvPVX(sv), SvCUR(sv), SvLEN(sv), 127));
	    SvREFCNT_dec(tmp);
	}
    }
    else if (SvNOKp(sv)) {
 	RESTORE_NUMERIC_STANDARD();
	Perl_sv_catpvf(aTHX_ t, "(%g)",SvNVX(sv));
 	RESTORE_NUMERIC_LOCAL();
    }
    else if (SvIOKp(sv)) {
	if (SvIsUV(sv))
	    Perl_sv_catpvf(aTHX_ t, "(%"UVuf")", (UV)SvUVX(sv));
	else
            Perl_sv_catpvf(aTHX_ t, "(%"IVdf")", (IV)SvIVX(sv));
    }
    else
	sv_catpv(t, "()");
    
  finish:
    if (unref) {
	while (unref--)
	    sv_catpv(t, ")");
    }
    return SvPV(t, n_a);
d105 1
a105 1
Perl_do_pmop_dump(pTHX_ I32 level, PerlIO *file, PMOP *pm)
d107 2
a108 69
    char ch;

    if (!pm) {
	Perl_dump_indent(aTHX_ level, file, "{}\n");
	return;
    }
    Perl_dump_indent(aTHX_ level, file, "{\n");
    level++;
    if (pm->op_pmflags & PMf_ONCE)
	ch = '?';
    else
	ch = '/';
    if (pm->op_pmregexp)
	Perl_dump_indent(aTHX_ level, file, "PMf_PRE %c%s%c%s\n",
	     ch, pm->op_pmregexp->precomp, ch,
	     (pm->op_private & OPpRUNTIME) ? " (RUNTIME)" : "");
    else
	Perl_dump_indent(aTHX_ level, file, "PMf_PRE (RUNTIME)\n");
    if (pm->op_type != OP_PUSHRE && pm->op_pmreplroot) {
	Perl_dump_indent(aTHX_ level, file, "PMf_REPL = ");
	op_dump(pm->op_pmreplroot);
    }
    if (pm->op_pmflags || (pm->op_pmregexp && pm->op_pmregexp->check_substr)) {
	SV *tmpsv = newSVpvn("", 0);
	if (pm->op_pmdynflags & PMdf_USED)
	    sv_catpv(tmpsv, ",USED");
	if (pm->op_pmdynflags & PMdf_TAINTED)
	    sv_catpv(tmpsv, ",TAINTED");
	if (pm->op_pmflags & PMf_ONCE)
	    sv_catpv(tmpsv, ",ONCE");
	if (pm->op_pmregexp && pm->op_pmregexp->check_substr
	    && !(pm->op_pmregexp->reganch & ROPT_NOSCAN))
	    sv_catpv(tmpsv, ",SCANFIRST");
	if (pm->op_pmregexp && pm->op_pmregexp->check_substr
	    && pm->op_pmregexp->reganch & ROPT_CHECK_ALL)
	    sv_catpv(tmpsv, ",ALL");
	if (pm->op_pmflags & PMf_SKIPWHITE)
	    sv_catpv(tmpsv, ",SKIPWHITE");
	if (pm->op_pmflags & PMf_CONST)
	    sv_catpv(tmpsv, ",CONST");
	if (pm->op_pmflags & PMf_KEEP)
	    sv_catpv(tmpsv, ",KEEP");
	if (pm->op_pmflags & PMf_GLOBAL)
	    sv_catpv(tmpsv, ",GLOBAL");
	if (pm->op_pmflags & PMf_CONTINUE)
	    sv_catpv(tmpsv, ",CONTINUE");
	if (pm->op_pmflags & PMf_RETAINT)
	    sv_catpv(tmpsv, ",RETAINT");
	if (pm->op_pmflags & PMf_EVAL)
	    sv_catpv(tmpsv, ",EVAL");
	Perl_dump_indent(aTHX_ level, file, "PMFLAGS = (%s)\n", SvCUR(tmpsv) ? SvPVX(tmpsv) + 1 : "");
	SvREFCNT_dec(tmpsv);
    }

    Perl_dump_indent(aTHX_ level-1, file, "}\n");
}

void
Perl_pmop_dump(pTHX_ PMOP *pm)
{
    do_pmop_dump(0, Perl_debug_log, pm);
}

void
Perl_do_op_dump(pTHX_ I32 level, PerlIO *file, OP *o)
{
    dTHR;
    Perl_dump_indent(aTHX_ level, file, "{\n");
    level++;
d110 1
a110 1
	PerlIO_printf(file, "%-4d", o->op_seq);
d112 2
a113 4
	PerlIO_printf(file, "    ");
    PerlIO_printf(file,
		  "%*sTYPE = %s  ===> ",
		  (int)(PL_dumpindent*level-4), "", PL_op_name[o->op_type]);
d116 1
a116 1
	    PerlIO_printf(file, "%d\n", o->op_next->op_seq);
d118 1
a118 1
	    PerlIO_printf(file, "(%d)\n", o->op_next->op_seq);
d121 2
a122 1
	PerlIO_printf(file, "DONE\n");
d125 1
a125 1
	    Perl_dump_indent(aTHX_ level, file, "  (was %s)\n", PL_op_name[o->op_targ]);
d127 1
a127 1
	    Perl_dump_indent(aTHX_ level, file, "TARG = %ld\n", (long)o->op_targ);
d130 1
a130 1
    Perl_dump_indent(aTHX_ level, file, "ADDR = 0x%"UVxf" => 0x%"UVxf"\n", (UV)o, (UV)o->op_next);
d133 1
a133 1
	SV *tmpsv = newSVpvn("", 0);
d160 1
a160 1
	Perl_dump_indent(aTHX_ level, file, "FLAGS = (%s)\n", SvCUR(tmpsv) ? SvPVX(tmpsv) + 1 : "");
d164 1
a164 5
	SV *tmpsv = newSVpvn("", 0);
	if (PL_opargs[o->op_type] & OA_TARGLEX) {
	    if (o->op_private & OPpTARGET_MY)
		sv_catpv(tmpsv, ",TARGET_MY");
	}
a167 2
	    if (o->op_private & OPpASSIGN_HASH)
		sv_catpv(tmpsv, ",HASH");
a197 2
		if (o->op_private & OPpENTERSUB_HASTARG)
		    sv_catpv(tmpsv, ",HASTARG");
d199 1
a199 2
	    else 
		switch (o->op_private & OPpDEREF) {
a216 2
		if (o->op_private & OPpOUR_INTRO)
		    sv_catpv(tmpsv, ",OUR_INTRO");
a221 2
	    if (o->op_private & OPpCONST_STRICT)
		sv_catpv(tmpsv, ",STRICT");
a229 3
	} else if (o->op_type == OP_RV2CV) {
	    if (o->op_private & OPpLVAL_INTRO)
		sv_catpv(tmpsv, ",INTRO");
d234 1
a234 1
	    Perl_dump_indent(aTHX_ level, file, "PRIVATE = (%s)\n", SvPVX(tmpsv) + 1);
a238 1
    case OP_AELEMFAST:
d241 2
a242 4
#ifdef USE_ITHREADS
	Perl_dump_indent(aTHX_ level, file, "PADIX = %d\n", cPADOPo->op_padix);
#else
	if (cSVOPo->op_sv) {
a243 1
	    STRLEN n_a;
d246 2
a247 2
	    gv_fullname3(tmpsv, (GV*)cSVOPo->op_sv, Nullch);
	    Perl_dump_indent(aTHX_ level, file, "GV = %s\n", SvPV(tmpsv, n_a));
d251 1
a251 2
	    Perl_dump_indent(aTHX_ level, file, "GV = NULL\n");
#endif
d254 1
a254 2
    case OP_METHOD_NAMED:
	Perl_dump_indent(aTHX_ level, file, "SV = %s\n", SvPEEK(cSVOPo->op_sv));
a255 1
    case OP_SETSTATE:
d258 2
a259 5
	if (CopLINE(cCOPo))
	    Perl_dump_indent(aTHX_ level, file, "LINE = %d\n",CopLINE(cCOPo));
	if (CopSTASHPV(cCOPo))
	    Perl_dump_indent(aTHX_ level, file, "PACKAGE = \"%s\"\n",
			     CopSTASHPV(cCOPo));
d261 1
a261 2
	    Perl_dump_indent(aTHX_ level, file, "LABEL = \"%s\"\n",
			     cCOPo->cop_label);
d264 1
a264 1
	Perl_dump_indent(aTHX_ level, file, "REDO ===> ");
d266 1
a266 1
	    PerlIO_printf(file, "%d\n", cLOOPo->op_redoop->op_seq);
d268 2
a269 2
	    PerlIO_printf(file, "DONE\n");
	Perl_dump_indent(aTHX_ level, file, "NEXT ===> ");
d271 1
a271 1
	    PerlIO_printf(file, "%d\n", cLOOPo->op_nextop->op_seq);
d273 2
a274 2
	    PerlIO_printf(file, "DONE\n");
	Perl_dump_indent(aTHX_ level, file, "LAST ===> ");
d276 1
a276 1
	    PerlIO_printf(file, "%d\n", cLOOPo->op_lastop->op_seq);
d278 1
a278 1
	    PerlIO_printf(file, "DONE\n");
d281 11
a291 1
    case OP_RANGE:
d296 1
a296 1
	Perl_dump_indent(aTHX_ level, file, "OTHER ===> ");
d298 1
a298 1
	    PerlIO_printf(file, "%d\n", cLOGOPo->op_other->op_seq);
d300 1
a300 1
	    PerlIO_printf(file, "DONE\n");
d306 1
a306 10
	do_pmop_dump(level, file, cPMOPo);
	break;
    case OP_LEAVE:
    case OP_LEAVEEVAL:
    case OP_LEAVESUB:
    case OP_LEAVESUBLV:
    case OP_LEAVEWRITE:
    case OP_SCOPE:
	if (o->op_private & OPpREFCOUNTED)
	    Perl_dump_indent(aTHX_ level, file, "REFCNT = %"UVuf"\n", (UV)o->op_targ);
d314 1
a314 1
	    do_op_dump(level, file, kid);
d316 3
a318 7
    Perl_dump_indent(aTHX_ level-1, file, "}\n");
}

void
Perl_op_dump(pTHX_ OP *o)
{
    do_op_dump(0, Perl_debug_log, o);
d322 1
a322 1
Perl_gv_dump(pTHX_ GV *gv)
d324 1
d332 1
d335 1
a335 1
    Perl_dump_indent(aTHX_ 1, Perl_debug_log, "GV_NAME = %s", SvPVX(sv));
d338 1
a338 1
	Perl_dump_indent(aTHX_ 1, Perl_debug_log, "-> %s", SvPVX(sv));
d340 4
a343 2
    PerlIO_putc(Perl_debug_log, '\n');
    Perl_dump_indent(aTHX_ 0, Perl_debug_log, "}\n");
d347 1
a347 1
Perl_do_magic_dump(pTHX_ I32 level, PerlIO *file, MAGIC *mg, I32 nest, I32 maxnest, bool dumpops, STRLEN pvlim)
d349 2
a350 40
    for (; mg; mg = mg->mg_moremagic) {
 	Perl_dump_indent(aTHX_ level, file,
			 "  MAGIC = 0x%"UVxf"\n", PTR2UV(mg));
 	if (mg->mg_virtual) {
            MGVTBL *v = mg->mg_virtual;
 	    char *s = 0;
 	    if      (v == &PL_vtbl_sv)         s = "sv";
            else if (v == &PL_vtbl_env)        s = "env";
            else if (v == &PL_vtbl_envelem)    s = "envelem";
            else if (v == &PL_vtbl_sig)        s = "sig";
            else if (v == &PL_vtbl_sigelem)    s = "sigelem";
            else if (v == &PL_vtbl_pack)       s = "pack";
            else if (v == &PL_vtbl_packelem)   s = "packelem";
            else if (v == &PL_vtbl_dbline)     s = "dbline";
            else if (v == &PL_vtbl_isa)        s = "isa";
            else if (v == &PL_vtbl_arylen)     s = "arylen";
            else if (v == &PL_vtbl_glob)       s = "glob";
            else if (v == &PL_vtbl_mglob)      s = "mglob";
            else if (v == &PL_vtbl_nkeys)      s = "nkeys";
            else if (v == &PL_vtbl_taint)      s = "taint";
            else if (v == &PL_vtbl_substr)     s = "substr";
            else if (v == &PL_vtbl_vec)        s = "vec";
            else if (v == &PL_vtbl_pos)        s = "pos";
            else if (v == &PL_vtbl_bm)         s = "bm";
            else if (v == &PL_vtbl_fm)         s = "fm";
            else if (v == &PL_vtbl_uvar)       s = "uvar";
            else if (v == &PL_vtbl_defelem)    s = "defelem";
#ifdef USE_LOCALE_COLLATE
	    else if (v == &PL_vtbl_collxfrm)   s = "collxfrm";
#endif
	    else if (v == &PL_vtbl_amagic)     s = "amagic";
	    else if (v == &PL_vtbl_amagicelem) s = "amagicelem";
	    else if (v == &PL_vtbl_backref)    s = "backref";
	    if (s)
	        Perl_dump_indent(aTHX_ level, file, "    MG_VIRTUAL = &PL_vtbl_%s\n", s);
	    else
	        Perl_dump_indent(aTHX_ level, file, "    MG_VIRTUAL = 0x%"UVxf"\n", PTR2UV(v));
        }
	else
	    Perl_dump_indent(aTHX_ level, file, "    MG_VIRTUAL = 0\n");
d352 3
a354 42
	if (mg->mg_private)
	    Perl_dump_indent(aTHX_ level, file, "    MG_PRIVATE = %d\n", mg->mg_private);

	if (isPRINT(mg->mg_type))
	    Perl_dump_indent(aTHX_ level, file, "    MG_TYPE = '%c'\n", mg->mg_type);
	else
	    Perl_dump_indent(aTHX_ level, file, "    MG_TYPE = '\\%o'\n", mg->mg_type);

        if (mg->mg_flags) {
            Perl_dump_indent(aTHX_ level, file, "    MG_FLAGS = 0x%02X\n", mg->mg_flags);
	    if (mg->mg_flags & MGf_TAINTEDDIR)
	        Perl_dump_indent(aTHX_ level, file, "      TAINTEDDIR\n");
	    if (mg->mg_flags & MGf_REFCOUNTED)
	        Perl_dump_indent(aTHX_ level, file, "      REFCOUNTED\n");
            if (mg->mg_flags & MGf_GSKIP)
	        Perl_dump_indent(aTHX_ level, file, "      GSKIP\n");
	    if (mg->mg_flags & MGf_MINMATCH)
	        Perl_dump_indent(aTHX_ level, file, "      MINMATCH\n");
        }
	if (mg->mg_obj) {
	    Perl_dump_indent(aTHX_ level, file, "    MG_OBJ = 0x%"UVxf"\n", PTR2UV(mg->mg_obj));
	    if (mg->mg_flags & MGf_REFCOUNTED)
		do_sv_dump(level+2, file, mg->mg_obj, nest+1, maxnest, dumpops, pvlim); /* MG is already +1 */
	}
        if (mg->mg_len)
	    Perl_dump_indent(aTHX_ level, file, "    MG_LEN = %ld\n", (long)mg->mg_len);
        if (mg->mg_ptr) {
	    Perl_dump_indent(aTHX_ level, file, "    MG_PTR = 0x%"UVxf, PTR2UV(mg->mg_ptr));
	    if (mg->mg_len >= 0) {
		SV *sv = newSVpvn("", 0);
                PerlIO_printf(file, " %s", pv_display(sv, mg->mg_ptr, mg->mg_len, 0, pvlim));
		SvREFCNT_dec(sv);
            }
	    else if (mg->mg_len == HEf_SVKEY) {
		PerlIO_puts(file, " => HEf_SVKEY\n");
		do_sv_dump(level+2, file, (SV*)((mg)->mg_ptr), nest+1, maxnest, dumpops, pvlim); /* MG is already +1 */
		continue;
	    }
	    else
		PerlIO_puts(file, " ???? - please notify IZ");
            PerlIO_putc(file, '\n');
        }
d356 4
a359 14
}

void
Perl_magic_dump(pTHX_ MAGIC *mg)
{
    do_magic_dump(0, Perl_debug_log, mg, 0, 0, 0, 0);
}

void
Perl_do_hv_dump(pTHX_ I32 level, PerlIO *file, char *name, HV *sv)
{
    Perl_dump_indent(aTHX_ level, file, "%s = 0x%"UVxf, name, PTR2UV(sv));
    if (sv && HvNAME(sv))
	PerlIO_printf(file, "\t\"%s\"\n", HvNAME(sv));
d361 5
a365 9
	PerlIO_putc(file, '\n');
}

void
Perl_do_gv_dump(pTHX_ I32 level, PerlIO *file, char *name, GV *sv)
{
    Perl_dump_indent(aTHX_ level, file, "%s = 0x%"UVxf, name, PTR2UV(sv));
    if (sv && GvNAME(sv))
	PerlIO_printf(file, "\t\"%s\"\n", GvNAME(sv));
d367 4
a370 12
	PerlIO_putc(file, '\n');
}

void
Perl_do_gvgv_dump(pTHX_ I32 level, PerlIO *file, char *name, GV *sv)
{
    Perl_dump_indent(aTHX_ level, file, "%s = 0x%"UVxf, name, PTR2UV(sv));
    if (sv && GvNAME(sv)) {
	PerlIO_printf(file, "\t\"");
	if (GvSTASH(sv) && HvNAME(GvSTASH(sv)))
	    PerlIO_printf(file, "%s\" :: \"", HvNAME(GvSTASH(sv)));
	PerlIO_printf(file, "%s\"\n", GvNAME(sv));
d372 30
a401 95
    else
	PerlIO_putc(file, '\n');
}

void
Perl_do_sv_dump(pTHX_ I32 level, PerlIO *file, SV *sv, I32 nest, I32 maxnest, bool dumpops, STRLEN pvlim)
{
    dTHR;
    SV *d = sv_newmortal();
    char *s;
    U32 flags;
    U32 type;
    STRLEN n_a;

    if (!sv) {
	Perl_dump_indent(aTHX_ level, file, "SV = 0\n");
	return;
    }
    
    flags = SvFLAGS(sv);
    type = SvTYPE(sv);

    Perl_sv_setpvf(aTHX_ d,
		   "(0x%"UVxf") at 0x%"UVxf"\n%*s  REFCNT = %"IVdf"\n%*s  FLAGS = (",
		   PTR2UV(SvANY(sv)), PTR2UV(sv),
		   (int)(PL_dumpindent*level), "", (IV)SvREFCNT(sv),
		   (int)(PL_dumpindent*level), "");

    if (flags & SVs_PADBUSY)	sv_catpv(d, "PADBUSY,");
    if (flags & SVs_PADTMP)	sv_catpv(d, "PADTMP,");
    if (flags & SVs_PADMY)	sv_catpv(d, "PADMY,");
    if (flags & SVs_TEMP)	sv_catpv(d, "TEMP,");
    if (flags & SVs_OBJECT)	sv_catpv(d, "OBJECT,");
    if (flags & SVs_GMG)	sv_catpv(d, "GMG,");
    if (flags & SVs_SMG)	sv_catpv(d, "SMG,");
    if (flags & SVs_RMG)	sv_catpv(d, "RMG,");

    if (flags & SVf_IOK)	sv_catpv(d, "IOK,");
    if (flags & SVf_NOK)	sv_catpv(d, "NOK,");
    if (flags & SVf_POK)	sv_catpv(d, "POK,");
    if (flags & SVf_ROK)  {	
    				sv_catpv(d, "ROK,");
	if (SvWEAKREF(sv))	sv_catpv(d, "WEAKREF,");
    }
    if (flags & SVf_OOK)	sv_catpv(d, "OOK,");
    if (flags & SVf_FAKE)	sv_catpv(d, "FAKE,");
    if (flags & SVf_READONLY)	sv_catpv(d, "READONLY,");

    if (flags & SVf_AMAGIC)	sv_catpv(d, "OVERLOAD,");
    if (flags & SVp_IOK)	sv_catpv(d, "pIOK,");
    if (flags & SVp_NOK)	sv_catpv(d, "pNOK,");
    if (flags & SVp_POK)	sv_catpv(d, "pPOK,");
    if (flags & SVp_SCREAM)	sv_catpv(d, "SCREAM,");

    switch (type) {
    case SVt_PVCV:
    case SVt_PVFM:
	if (CvANON(sv))		sv_catpv(d, "ANON,");
	if (CvUNIQUE(sv))	sv_catpv(d, "UNIQUE,");
	if (CvCLONE(sv))	sv_catpv(d, "CLONE,");
	if (CvCLONED(sv))	sv_catpv(d, "CLONED,");
	if (CvNODEBUG(sv))	sv_catpv(d, "NODEBUG,");
	if (SvCOMPILED(sv))	sv_catpv(d, "COMPILED,");
	break;
    case SVt_PVHV:
	if (HvSHAREKEYS(sv))	sv_catpv(d, "SHAREKEYS,");
	if (HvLAZYDEL(sv))	sv_catpv(d, "LAZYDEL,");
	break;
    case SVt_PVGV:
	if (GvINTRO(sv))	sv_catpv(d, "INTRO,");
	if (GvMULTI(sv))	sv_catpv(d, "MULTI,");
	if (GvASSUMECV(sv))	sv_catpv(d, "ASSUMECV,");
	if (GvIMPORTED(sv)) {
	    sv_catpv(d, "IMPORT");
	    if (GvIMPORTED(sv) == GVf_IMPORTED)
		sv_catpv(d, "ALL,");
	    else {
		sv_catpv(d, "(");
		if (GvIMPORTED_SV(sv))	sv_catpv(d, " SV");
		if (GvIMPORTED_AV(sv))	sv_catpv(d, " AV");
		if (GvIMPORTED_HV(sv))	sv_catpv(d, " HV");
		if (GvIMPORTED_CV(sv))	sv_catpv(d, " CV");
		sv_catpv(d, " ),");
	    }
	}
	/* FALL THROGH */
    default:
	if (SvEVALED(sv))	sv_catpv(d, "EVALED,");
	if (SvIsUV(sv))		sv_catpv(d, "IsUV,");
	if (SvUTF8(sv))         sv_catpv(d, "UTF8");
	break;
    case SVt_PVBM:
	if (SvTAIL(sv))		sv_catpv(d, "TAIL,");
	if (SvVALID(sv))	sv_catpv(d, "VALID,");
	break;
d404 3
a406 320
    if (*(SvEND(d) - 1) == ',')
	SvPVX(d)[--SvCUR(d)] = '\0';
    sv_catpv(d, ")");
    s = SvPVX(d);

    Perl_dump_indent(aTHX_ level, file, "SV = ");
    switch (type) {
    case SVt_NULL:
	PerlIO_printf(file, "NULL%s\n", s);
	return;
    case SVt_IV:
	PerlIO_printf(file, "IV%s\n", s);
	break;
    case SVt_NV:
	PerlIO_printf(file, "NV%s\n", s);
	break;
    case SVt_RV:
	PerlIO_printf(file, "RV%s\n", s);
	break;
    case SVt_PV:
	PerlIO_printf(file, "PV%s\n", s);
	break;
    case SVt_PVIV:
	PerlIO_printf(file, "PVIV%s\n", s);
	break;
    case SVt_PVNV:
	PerlIO_printf(file, "PVNV%s\n", s);
	break;
    case SVt_PVBM:
	PerlIO_printf(file, "PVBM%s\n", s);
	break;
    case SVt_PVMG:
	PerlIO_printf(file, "PVMG%s\n", s);
	break;
    case SVt_PVLV:
	PerlIO_printf(file, "PVLV%s\n", s);
	break;
    case SVt_PVAV:
	PerlIO_printf(file, "PVAV%s\n", s);
	break;
    case SVt_PVHV:
	PerlIO_printf(file, "PVHV%s\n", s);
	break;
    case SVt_PVCV:
	PerlIO_printf(file, "PVCV%s\n", s);
	break;
    case SVt_PVGV:
	PerlIO_printf(file, "PVGV%s\n", s);
	break;
    case SVt_PVFM:
	PerlIO_printf(file, "PVFM%s\n", s);
	break;
    case SVt_PVIO:
	PerlIO_printf(file, "PVIO%s\n", s);
	break;
    default:
	PerlIO_printf(file, "UNKNOWN(0x%"UVxf") %s\n", (UV)type, s);
	return;
    }
    if (type >= SVt_PVIV || type == SVt_IV) {
	if (SvIsUV(sv))
	    Perl_dump_indent(aTHX_ level, file, "  UV = %"UVuf, (UV)SvUVX(sv));
	else
	    Perl_dump_indent(aTHX_ level, file, "  IV = %"IVdf, (IV)SvIVX(sv));
	if (SvOOK(sv))
	    PerlIO_printf(file, "  (OFFSET)");
	PerlIO_putc(file, '\n');
    }
    if (type >= SVt_PVNV || type == SVt_NV) {
	RESTORE_NUMERIC_STANDARD();
	/* %Vg doesn't work? --jhi */
#ifdef USE_LONG_DOUBLE
	Perl_dump_indent(aTHX_ level, file, "  NV = %.*" PERL_PRIgldbl "\n", LDBL_DIG, SvNVX(sv));
#else
	Perl_dump_indent(aTHX_ level, file, "  NV = %.*g\n", DBL_DIG, SvNVX(sv));
#endif
	RESTORE_NUMERIC_LOCAL();
    }
    if (SvROK(sv)) {
	Perl_dump_indent(aTHX_ level, file, "  RV = 0x%"UVxf"\n", PTR2UV(SvRV(sv)));
	if (nest < maxnest)
	    do_sv_dump(level+1, file, SvRV(sv), nest+1, maxnest, dumpops, pvlim);
	return;
    }
    if (type < SVt_PV)
	return;
    if (type <= SVt_PVLV) {
	if (SvPVX(sv)) {
	    Perl_dump_indent(aTHX_ level, file,"  PV = 0x%"UVxf" ", PTR2UV(SvPVX(sv)));
	    if (SvOOK(sv))
		PerlIO_printf(file, "( %s . ) ", pv_display(d, SvPVX(sv)-SvIVX(sv), SvIVX(sv), 0, pvlim));
	    PerlIO_printf(file, "%s\n", pv_display(d, SvPVX(sv), SvCUR(sv), SvLEN(sv), pvlim));
	    Perl_dump_indent(aTHX_ level, file, "  CUR = %"IVdf"\n", (IV)SvCUR(sv));
	    Perl_dump_indent(aTHX_ level, file, "  LEN = %"IVdf"\n", (IV)SvLEN(sv));
	}
	else
	    Perl_dump_indent(aTHX_ level, file, "  PV = 0\n");
    }
    if (type >= SVt_PVMG) {
	if (SvMAGIC(sv))
            do_magic_dump(level, file, SvMAGIC(sv), nest, maxnest, dumpops, pvlim);
	if (SvSTASH(sv))
	    do_hv_dump(level, file, "  STASH", SvSTASH(sv));
    }
    switch (type) {
    case SVt_PVLV:
	Perl_dump_indent(aTHX_ level, file, "  TYPE = %c\n", LvTYPE(sv));
	Perl_dump_indent(aTHX_ level, file, "  TARGOFF = %"IVdf"\n", (IV)LvTARGOFF(sv));
	Perl_dump_indent(aTHX_ level, file, "  TARGLEN = %"IVdf"\n", (IV)LvTARGLEN(sv));
	Perl_dump_indent(aTHX_ level, file, "  TARG = 0x%"UVxf"\n", PTR2UV(LvTARG(sv)));
	/* XXX level+1 ??? */
	do_sv_dump(level, file, LvTARG(sv), nest+1, maxnest, dumpops, pvlim);
	break;
    case SVt_PVAV:
	Perl_dump_indent(aTHX_ level, file, "  ARRAY = 0x%"UVxf, PTR2UV(AvARRAY(sv)));
	if (AvARRAY(sv) != AvALLOC(sv)) {
	    PerlIO_printf(file, " (offset=%"IVdf")\n", (IV)(AvARRAY(sv) - AvALLOC(sv)));
	    Perl_dump_indent(aTHX_ level, file, "  ALLOC = 0x%"UVxf"\n", PTR2UV(AvALLOC(sv)));
	}
	else
	    PerlIO_putc(file, '\n');
	Perl_dump_indent(aTHX_ level, file, "  FILL = %"IVdf"\n", (IV)AvFILLp(sv));
	Perl_dump_indent(aTHX_ level, file, "  MAX = %"IVdf"\n", (IV)AvMAX(sv));
	Perl_dump_indent(aTHX_ level, file, "  ARYLEN = 0x%"UVxf"\n", PTR2UV(AvARYLEN(sv)));
	flags = AvFLAGS(sv);
	sv_setpv(d, "");
	if (flags & AVf_REAL)	sv_catpv(d, ",REAL");
	if (flags & AVf_REIFY)	sv_catpv(d, ",REIFY");
	if (flags & AVf_REUSED)	sv_catpv(d, ",REUSED");
	Perl_dump_indent(aTHX_ level, file, "  FLAGS = (%s)\n", SvCUR(d) ? SvPVX(d) + 1 : "");
	if (nest < maxnest && av_len((AV*)sv) >= 0) {
	    int count;
	    for (count = 0; count <=  av_len((AV*)sv) && count < maxnest; count++) {
		SV** elt = av_fetch((AV*)sv,count,0);

		Perl_dump_indent(aTHX_ level + 1, file, "Elt No. %"IVdf"\n", (IV)count);
		if (elt) 
		    do_sv_dump(level+1, file, *elt, nest+1, maxnest, dumpops, pvlim);
	    }
	}
	break;
    case SVt_PVHV:
	Perl_dump_indent(aTHX_ level, file, "  ARRAY = 0x%"UVxf, PTR2UV(HvARRAY(sv)));
	if (HvARRAY(sv) && HvKEYS(sv)) {
	    /* Show distribution of HEs in the ARRAY */
	    int freq[200];
#define FREQ_MAX (sizeof freq / sizeof freq[0] - 1)
	    int i;
	    int max = 0;
	    U32 pow2 = 2, keys = HvKEYS(sv);
	    NV theoret, sum = 0;

	    PerlIO_printf(file, "  (");
	    Zero(freq, FREQ_MAX + 1, int);
	    for (i = 0; i <= HvMAX(sv); i++) {
		HE* h; int count = 0;
                for (h = HvARRAY(sv)[i]; h; h = HeNEXT(h))
		    count++;
		if (count > FREQ_MAX)
		    count = FREQ_MAX;
	        freq[count]++;
	        if (max < count)
		    max = count;
	    }
	    for (i = 0; i <= max; i++) {
		if (freq[i]) {
		    PerlIO_printf(file, "%d%s:%d", i,
				  (i == FREQ_MAX) ? "+" : "",
				  freq[i]);
		    if (i != max)
			PerlIO_printf(file, ", ");
		}
            }
	    PerlIO_putc(file, ')');
	    /* Now calculate quality wrt theoretical value */
	    for (i = max; i > 0; i--) { /* Precision: count down. */
		sum += freq[i] * i * i;
            }
	    while ((keys = keys >> 1))
		pow2 = pow2 << 1;
	    /* Approximate by Poisson distribution */
	    theoret = HvKEYS(sv);
	    theoret += theoret * theoret/pow2;
	    PerlIO_putc(file, '\n');
	    Perl_dump_indent(aTHX_ level, file, "  hash quality = %.1f%%", theoret/sum*100);
	}
	PerlIO_putc(file, '\n');
	Perl_dump_indent(aTHX_ level, file, "  KEYS = %"IVdf"\n", (IV)HvKEYS(sv));
	Perl_dump_indent(aTHX_ level, file, "  FILL = %"IVdf"\n", (IV)HvFILL(sv));
	Perl_dump_indent(aTHX_ level, file, "  MAX = %"IVdf"\n", (IV)HvMAX(sv));
	Perl_dump_indent(aTHX_ level, file, "  RITER = %"IVdf"\n", (IV)HvRITER(sv));
	Perl_dump_indent(aTHX_ level, file, "  EITER = 0x%"UVxf"\n", PTR2UV(HvEITER(sv)));
	if (HvPMROOT(sv))
	    Perl_dump_indent(aTHX_ level, file, "  PMROOT = 0x%"UVxf"\n", PTR2UV(HvPMROOT(sv)));
	if (HvNAME(sv))
	    Perl_dump_indent(aTHX_ level, file, "  NAME = \"%s\"\n", HvNAME(sv));
	if (nest < maxnest && !HvEITER(sv)) { /* Try to preserve iterator */
	    HE *he;
	    HV *hv = (HV*)sv;
	    int count = maxnest - nest;

	    hv_iterinit(hv);
	    while ((he = hv_iternext(hv)) && count--) {
		SV *elt;
		char *key;
		I32 len;
		U32 hash = HeHASH(he);

		key = hv_iterkey(he, &len);
		elt = hv_iterval(hv, he);
		Perl_dump_indent(aTHX_ level+1, file, "Elt %s HASH = 0x%"UVxf"\n", pv_display(d, key, len, 0, pvlim), (UV)hash);
		do_sv_dump(level+1, file, elt, nest+1, maxnest, dumpops, pvlim);
	    }
	    hv_iterinit(hv);		/* Return to status quo */
	}
	break;
    case SVt_PVCV:
	if (SvPOK(sv))
	    Perl_dump_indent(aTHX_ level, file, "  PROTOTYPE = \"%s\"\n", SvPV(sv,n_a));
	/* FALL THROUGH */
    case SVt_PVFM:
	do_hv_dump(level, file, "  COMP_STASH", CvSTASH(sv));
	if (CvSTART(sv))
	    Perl_dump_indent(aTHX_ level, file, "  START = 0x%"UVxf" ===> %"IVdf"\n", PTR2UV(CvSTART(sv)), (IV)CvSTART(sv)->op_seq);
	Perl_dump_indent(aTHX_ level, file, "  ROOT = 0x%"UVxf"\n", PTR2UV(CvROOT(sv)));
        if (CvROOT(sv) && dumpops)
	    do_op_dump(level+1, file, CvROOT(sv));
	Perl_dump_indent(aTHX_ level, file, "  XSUB = 0x%"UVxf"\n", PTR2UV(CvXSUB(sv)));
	Perl_dump_indent(aTHX_ level, file, "  XSUBANY = %"IVdf"\n", (IV)CvXSUBANY(sv).any_i32);
 	do_gvgv_dump(level, file, "  GVGV::GV", CvGV(sv));
	Perl_dump_indent(aTHX_ level, file, "  FILE = \"%s\"\n", CvFILE(sv));
	Perl_dump_indent(aTHX_ level, file, "  DEPTH = %"IVdf"\n", (IV)CvDEPTH(sv));
#ifdef USE_THREADS
	Perl_dump_indent(aTHX_ level, file, "  MUTEXP = 0x%"UVxf"\n", PTR2UV(CvMUTEXP(sv)));
	Perl_dump_indent(aTHX_ level, file, "  OWNER = 0x%"UVxf"\n",  PTR2UV(CvOWNER(sv)));
#endif /* USE_THREADS */
	Perl_dump_indent(aTHX_ level, file, "  FLAGS = 0x%"UVxf"\n", (UV)CvFLAGS(sv));
	if (type == SVt_PVFM)
	    Perl_dump_indent(aTHX_ level, file, "  LINES = %"IVdf"\n", (IV)FmLINES(sv));
	Perl_dump_indent(aTHX_ level, file, "  PADLIST = 0x%"UVxf"\n", PTR2UV(CvPADLIST(sv)));
	if (nest < maxnest && CvPADLIST(sv)) {
	    AV* padlist = CvPADLIST(sv);
	    AV* pad_name = (AV*)*av_fetch(padlist, 0, FALSE);
	    AV* pad = (AV*)*av_fetch(padlist, 1, FALSE);
	    SV** pname = AvARRAY(pad_name);
	    SV** ppad = AvARRAY(pad);
	    I32 ix;

	    for (ix = 1; ix <= AvFILL(pad_name); ix++) {
		if (SvPOK(pname[ix]))
		    Perl_dump_indent(aTHX_ level,
				/* %5d below is enough whitespace. */
				file, 
				"%5d. 0x%"UVxf" (%s\"%s\" %"IVdf"-%"IVdf")\n",
				(int)ix, PTR2UV(ppad[ix]),
				SvFAKE(pname[ix]) ? "FAKE " : "",
				SvPVX(pname[ix]),
				(IV)SvNVX(pname[ix]),
				(IV)SvIVX(pname[ix]));
	    }
	}
	{
	    CV *outside = CvOUTSIDE(sv);
	    Perl_dump_indent(aTHX_ level, file, "  OUTSIDE = 0x%"UVxf" (%s)\n", 
			PTR2UV(outside),
			(!outside ? "null"
			 : CvANON(outside) ? "ANON"
			 : (outside == PL_main_cv) ? "MAIN"
			 : CvUNIQUE(outside) ? "UNIQUE"
			 : CvGV(outside) ? GvNAME(CvGV(outside)) : "UNDEFINED"));
	}
	if (nest < maxnest && (CvCLONE(sv) || CvCLONED(sv)))
	    do_sv_dump(level+1, file, (SV*)CvOUTSIDE(sv), nest+1, maxnest, dumpops, pvlim);
	break;
    case SVt_PVGV:
	Perl_dump_indent(aTHX_ level, file, "  NAME = \"%s\"\n", GvNAME(sv));
	Perl_dump_indent(aTHX_ level, file, "  NAMELEN = %"IVdf"\n", (IV)GvNAMELEN(sv));
	do_hv_dump (level, file, "  GvSTASH", GvSTASH(sv));
	Perl_dump_indent(aTHX_ level, file, "  GP = 0x%"UVxf"\n", PTR2UV(GvGP(sv)));
	if (!GvGP(sv))
	    break;
	Perl_dump_indent(aTHX_ level, file, "    SV = 0x%"UVxf"\n", PTR2UV(GvSV(sv)));
	Perl_dump_indent(aTHX_ level, file, "    REFCNT = %"IVdf"\n", (IV)GvREFCNT(sv));
	Perl_dump_indent(aTHX_ level, file, "    IO = 0x%"UVxf"\n", PTR2UV(GvIOp(sv)));
	Perl_dump_indent(aTHX_ level, file, "    FORM = 0x%"UVxf"  \n", PTR2UV(GvFORM(sv)));
	Perl_dump_indent(aTHX_ level, file, "    AV = 0x%"UVxf"\n", PTR2UV(GvAV(sv)));
	Perl_dump_indent(aTHX_ level, file, "    HV = 0x%"UVxf"\n", PTR2UV(GvHV(sv)));
	Perl_dump_indent(aTHX_ level, file, "    CV = 0x%"UVxf"\n", PTR2UV(GvCV(sv)));
	Perl_dump_indent(aTHX_ level, file, "    CVGEN = 0x%"UVxf"\n", (UV)GvCVGEN(sv));
	Perl_dump_indent(aTHX_ level, file, "    GPFLAGS = 0x%"UVxf"\n", (UV)GvGPFLAGS(sv));
	Perl_dump_indent(aTHX_ level, file, "    LINE = %"IVdf"\n", (IV)GvLINE(sv));
	Perl_dump_indent(aTHX_ level, file, "    FILE = \"%s\"\n", GvFILE(sv));
	Perl_dump_indent(aTHX_ level, file, "    FLAGS = 0x%"UVxf"\n", (UV)GvFLAGS(sv));
	do_gv_dump (level, file, "    EGV", GvEGV(sv));
	break;
    case SVt_PVIO:
	Perl_dump_indent(aTHX_ level, file, "  IFP = 0x%"UVxf"\n", PTR2UV(IoIFP(sv)));
	Perl_dump_indent(aTHX_ level, file, "  OFP = 0x%"UVxf"\n", PTR2UV(IoOFP(sv)));
	Perl_dump_indent(aTHX_ level, file, "  DIRP = 0x%"UVxf"\n", PTR2UV(IoDIRP(sv)));
	Perl_dump_indent(aTHX_ level, file, "  LINES = %"IVdf"\n", (IV)IoLINES(sv));
	Perl_dump_indent(aTHX_ level, file, "  PAGE = %"IVdf"\n", (IV)IoPAGE(sv));
	Perl_dump_indent(aTHX_ level, file, "  PAGE_LEN = %"IVdf"\n", (IV)IoPAGE_LEN(sv));
	Perl_dump_indent(aTHX_ level, file, "  LINES_LEFT = %"IVdf"\n", (IV)IoLINES_LEFT(sv));
        if (IoTOP_NAME(sv))
            Perl_dump_indent(aTHX_ level, file, "  TOP_NAME = \"%s\"\n", IoTOP_NAME(sv));
	do_gv_dump (level, file, "  TOP_GV", IoTOP_GV(sv));
        if (IoFMT_NAME(sv))
            Perl_dump_indent(aTHX_ level, file, "  FMT_NAME = \"%s\"\n", IoFMT_NAME(sv));
	do_gv_dump (level, file, "  FMT_GV", IoFMT_GV(sv));
        if (IoBOTTOM_NAME(sv))
            Perl_dump_indent(aTHX_ level, file, "  BOTTOM_NAME = \"%s\"\n", IoBOTTOM_NAME(sv));
	do_gv_dump (level, file, "  BOTTOM_GV", IoBOTTOM_GV(sv));
	Perl_dump_indent(aTHX_ level, file, "  SUBPROCESS = %"IVdf"\n", (IV)IoSUBPROCESS(sv));
	if (isPRINT(IoTYPE(sv)))
            Perl_dump_indent(aTHX_ level, file, "  TYPE = '%c'\n", IoTYPE(sv));
	else
            Perl_dump_indent(aTHX_ level, file, "  TYPE = '\\%o'\n", IoTYPE(sv));
	Perl_dump_indent(aTHX_ level, file, "  FLAGS = 0x%"UVxf"\n", (UV)IoFLAGS(sv));
	break;
    }
d409 3
a411 2
void
Perl_sv_dump(pTHX_ SV *sv)
d413 10
a422 1
    do_sv_dump(0, Perl_debug_log, sv, 0, 0, 0, 0);
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d32 1
d40 1
d50 1
d282 1
a282 1
	STORE_NUMERIC_LOCAL_SET_STANDARD();
d284 1
a284 1
	RESTORE_NUMERIC_LOCAL();
d372 1
a459 1
		 o->op_type == OP_GVSV ||
d771 2
a772 1
    SV *d;
d786 1
a786 1
    d = Perl_newSVpvf(aTHX_
a826 2
	if (CvLVALUE(sv))	sv_catpv(d, "LVALUE,");
	if (CvMETHOD(sv))	sv_catpv(d, "METHOD,");
a835 1
	if (GvIN_PAD(sv))       sv_catpv(d, "IN_PAD,");
a869 1
	SvREFCNT_dec(d);
a917 1
	SvREFCNT_dec(d);
d930 1
a930 1
	STORE_NUMERIC_LOCAL_SET_STANDARD();
a942 1
	SvREFCNT_dec(d);
d945 1
a945 2
    if (type < SVt_PV) {
	SvREFCNT_dec(d);
a946 1
    }
d1045 1
a1045 1
	    Perl_dump_indent(aTHX_ level, file, "  hash quality = %.1"NVff"%%", theoret/sum*100);
a1180 1
    SvREFCNT_dec(d);
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
d63 2
a64 2
	    if (HeKEY(entry)[HeKLEN(entry)-1] == ':'
		&& (hv = GvHV(gv)) && hv != PL_defstash)
d78 2
a79 2
	Perl_dump_indent(aTHX_ 0, Perl_debug_log, "(xsub 0x%"UVxf" %d)\n",
	    PTR2UV(CvXSUB(GvCV(gv))),
d107 1
a107 1
Perl_pv_display(pTHX_ SV *dsv, char *pv, STRLEN cur, STRLEN len, STRLEN pvlim)
d112 1
a112 1
    sv_setpvn(dsv, "\"", 1);
d114 1
a114 1
	if (pvlim && SvCUR(dsv) >= pvlim) {
d120 7
a126 7
	    case '\t': sv_catpvn(dsv, "\\t", 2);  break;
	    case '\n': sv_catpvn(dsv, "\\n", 2);  break;
	    case '\r': sv_catpvn(dsv, "\\r", 2);  break;
	    case '\f': sv_catpvn(dsv, "\\f", 2);  break;
	    case '"':  sv_catpvn(dsv, "\\\"", 2); break;
	    case '\\': sv_catpvn(dsv, "\\\\", 2); break;
	    default:   sv_catpvn(dsv, pv, 1);     break;
d131 1
a131 1
		Perl_sv_catpvf(aTHX_ dsv, "\\%03o", (U8)*pv);
d133 1
a133 1
		Perl_sv_catpvf(aTHX_ dsv, "\\%o", (U8)*pv);
d136 1
a136 1
    sv_catpvn(dsv, "\"", 1);
d138 1
a138 1
	sv_catpvn(dsv, "...", 3);
d140 1
a140 1
	sv_catpvn(dsv, "\\0", 2);
d142 1
a142 1
    return SvPVX(dsv);
a196 5
    else if (DEBUG_R_TEST_ && SvREFCNT(sv) > 1) {
	Perl_sv_catpvf(aTHX_ t, "<%"UVuf">", (UV)SvREFCNT(sv));
    }


a274 4
	    if (SvUTF8(sv))
		Perl_sv_catpvf(aTHX_ t, " [UTF8 \"%s\"]",
			       sv_uni_display(tmp, sv, 8 * sv_len_utf8(sv),
					      UNI_DISPLAY_QQ));
d280 1
a280 1
	Perl_sv_catpvf(aTHX_ t, "(%"NVgf")",SvNVX(sv));
d291 1
a291 1

d315 1
a315 1
    if (PM_GETRE(pm))
d317 1
a317 1
	     ch, PM_GETRE(pm)->precomp, ch,
d325 1
a325 1
    if (pm->op_pmflags || (PM_GETRE(pm) && PM_GETRE(pm)->check_substr)) {
d333 2
a334 2
	if (PM_GETRE(pm) && PM_GETRE(pm)->check_substr
	    && !(PM_GETRE(pm)->reganch & ROPT_NOSCAN))
d336 2
a337 2
	if (PM_GETRE(pm) && PM_GETRE(pm)->check_substr
	    && PM_GETRE(pm)->reganch & ROPT_CHECK_ALL)
d377 1
a377 1
		  (int)(PL_dumpindent*level-4), "", OP_NAME(o));
a387 1
	{
a388 12
	    if (o->op_targ == OP_NEXTSTATE)
	    {
		if (CopLINE(cCOPo))
		    Perl_dump_indent(aTHX_ level, file, "LINE = %d\n",CopLINE(cCOPo));
		if (CopSTASHPV(cCOPo))
		    Perl_dump_indent(aTHX_ level, file, "PACKAGE = \"%s\"\n",
				     CopSTASHPV(cCOPo));
		if (cCOPo->cop_label)
		    Perl_dump_indent(aTHX_ level, file, "LABEL = \"%s\"\n",
				     cCOPo->cop_label);
	    }
	}
d432 1
a432 8
	else if (o->op_type == OP_LEAVESUB ||
		 o->op_type == OP_LEAVE ||
		 o->op_type == OP_LEAVESUBLV ||
		 o->op_type == OP_LEAVEWRITE) {
	    if (o->op_private & OPpREFCOUNTED)
		sv_catpv(tmpsv, ",REFCOUNTED");
	}
        else if (o->op_type == OP_AASSIGN) {
a448 4
	    if (o->op_private & OPpTRANS_IDENTICAL)
		sv_catpv(tmpsv, ",IDENTICAL");
	    if (o->op_private & OPpTRANS_GROWS)
		sv_catpv(tmpsv, ",GROWS");
a469 6
		if (o->op_private & OPpENTERSUB_NOPAREN)
		    sv_catpv(tmpsv, ",NOPAREN");
		if (o->op_private & OPpENTERSUB_INARGS)
		    sv_catpv(tmpsv, ",INARGS");
		if (o->op_private & OPpENTERSUB_NOMOD)
		    sv_catpv(tmpsv, ",NOMOD");
d471 1
a471 1
	    else {
a482 3
		if (o->op_private & OPpMAYBE_LVSUB)
		    sv_catpv(tmpsv, ",MAYBE_LVSUB");
	    }
a498 6
	    if (o->op_private & OPpCONST_ARYBASE)
		sv_catpv(tmpsv, ",ARYBASE");
	    if (o->op_private & OPpCONST_WARNING)
		sv_catpv(tmpsv, ",WARNING");
	    if (o->op_private & OPpCONST_ENTERED)
		sv_catpv(tmpsv, ",ENTERED");
d507 1
a507 2
	}
	else if (o->op_type == OP_RV2CV) {
a510 48
	else if (o->op_type == OP_GV) {
	    if (o->op_private & OPpEARLY_CV)
		sv_catpv(tmpsv, ",EARLY_CV");
	}
	else if (o->op_type == OP_LIST) {
	    if (o->op_private & OPpLIST_GUESSED)
		sv_catpv(tmpsv, ",GUESSED");
	}
	else if (o->op_type == OP_DELETE) {
	    if (o->op_private & OPpSLICE)
		sv_catpv(tmpsv, ",SLICE");
	}
	else if (o->op_type == OP_EXISTS) {
	    if (o->op_private & OPpEXISTS_SUB)
		sv_catpv(tmpsv, ",EXISTS_SUB");
	}
	else if (o->op_type == OP_SORT) {
	    if (o->op_private & OPpSORT_NUMERIC)
		sv_catpv(tmpsv, ",NUMERIC");
	    if (o->op_private & OPpSORT_INTEGER)
		sv_catpv(tmpsv, ",INTEGER");
	    if (o->op_private & OPpSORT_REVERSE)
		sv_catpv(tmpsv, ",REVERSE");
	}
	else if (o->op_type == OP_THREADSV) {
	    if (o->op_private & OPpDONE_SVREF)
		sv_catpv(tmpsv, ",SVREF");
	}
	else if (o->op_type == OP_OPEN || o->op_type == OP_BACKTICK) {
	    if (o->op_private & OPpOPEN_IN_RAW)
		sv_catpv(tmpsv, ",IN_RAW");
	    if (o->op_private & OPpOPEN_IN_CRLF)
		sv_catpv(tmpsv, ",IN_CRLF");
	    if (o->op_private & OPpOPEN_OUT_RAW)
		sv_catpv(tmpsv, ",OUT_RAW");
	    if (o->op_private & OPpOPEN_OUT_CRLF)
		sv_catpv(tmpsv, ",OUT_CRLF");
	}
	else if (o->op_type == OP_EXIT) {
	    if (o->op_private & OPpEXIT_VMSISH)
		sv_catpv(tmpsv, ",EXIT_VMSISH");
	    if (o->op_private & OPpHUSH_VMSISH)
		sv_catpv(tmpsv, ",HUSH_VMSISH");
	}
	else if (o->op_type == OP_DIE) {
	    if (o->op_private & OPpHUSH_VMSISH)
		sv_catpv(tmpsv, ",HUSH_VMSISH");
	}
d523 1
a523 1
	Perl_dump_indent(aTHX_ level, file, "PADIX = %" IVdf "\n", (IV)cPADOPo->op_padix);
a635 47

/* map magic types to the symbolic names
 * (with the PERL_MAGIC_ prefixed stripped)
 */

static struct { char type; char *name; } magic_names[] = {
	{ PERL_MAGIC_sv,             "sv(\\0)" },
	{ PERL_MAGIC_arylen,         "arylen(#)" },
	{ PERL_MAGIC_glob,           "glob(*)" },
	{ PERL_MAGIC_pos,            "pos(.)" },
	{ PERL_MAGIC_backref,        "backref(<)" },
	{ PERL_MAGIC_overload,       "overload(A)" },
	{ PERL_MAGIC_bm,             "bm(B)" },
	{ PERL_MAGIC_regdata,        "regdata(D)" },
	{ PERL_MAGIC_env,            "env(E)" },
	{ PERL_MAGIC_isa,            "isa(I)" },
	{ PERL_MAGIC_dbfile,         "dbfile(L)" },
	{ PERL_MAGIC_shared,         "shared(N)" },
	{ PERL_MAGIC_tied,           "tied(P)" },
	{ PERL_MAGIC_sig,            "sig(S)" },
	{ PERL_MAGIC_uvar,           "uvar(U)" },
	{ PERL_MAGIC_overload_elem,  "overload_elem(a)" },
	{ PERL_MAGIC_overload_table, "overload_table(c)" },
	{ PERL_MAGIC_regdatum,       "regdatum(d)" },
	{ PERL_MAGIC_envelem,        "envelem(e)" },
	{ PERL_MAGIC_fm,             "fm(f)" },
	{ PERL_MAGIC_regex_global,   "regex_global(g)" },
	{ PERL_MAGIC_isaelem,        "isaelem(i)" },
	{ PERL_MAGIC_nkeys,          "nkeys(k)" },
	{ PERL_MAGIC_dbline,         "dbline(l)" },
	{ PERL_MAGIC_mutex,          "mutex(m)" },
	{ PERL_MAGIC_shared_scalar,  "shared_scalar(n)" },
	{ PERL_MAGIC_collxfrm,       "collxfrm(o)" },
	{ PERL_MAGIC_tiedelem,       "tiedelem(p)" },
	{ PERL_MAGIC_tiedscalar,     "tiedscalar(q)" },
	{ PERL_MAGIC_qr,             "qr(r)" },
	{ PERL_MAGIC_sigelem,        "sigelem(s)" },
	{ PERL_MAGIC_taint,          "taint(t)" },
	{ PERL_MAGIC_uvar_elem,      "uvar_elem(v)" },
	{ PERL_MAGIC_vec,            "vec(v)" },
	{ PERL_MAGIC_substr,         "substr(x)" },
	{ PERL_MAGIC_defelem,        "defelem(y)" },
	{ PERL_MAGIC_ext,            "ext(~)" },
	/* this null string terminates the list */
	{ 0,                         0 },
};

d683 4
a686 16
	{
	    int n;
	    char *name = 0;
	    for (n=0; magic_names[n].name; n++) {
		if (mg->mg_type == magic_names[n].type) {
		    name = magic_names[n].name;
		    break;
		}
	    }
	    if (name)
		Perl_dump_indent(aTHX_ level, file,
				"    MG_TYPE = PERL_MAGIC_%s\n", name);
	    else
		Perl_dump_indent(aTHX_ level, file,
				"    MG_TYPE = UNKNOWN(\\%o)\n", mg->mg_type);
	}
d757 1
a757 1
	if (GvSTASH(sv))
d778 1
a778 1

a820 1
	if (CvCONST(sv))	sv_catpv(d, "CONST,");
a824 1
	if (CvLOCKED(sv))	sv_catpv(d, "LOCKED,");
a828 1
	if (HvHASKFLAGS(sv))	sv_catpv(d, "HASKFLAGS,");
a832 1
	if (GvUNIQUE(sv))       sv_catpv(d, "UNIQUE,");
a834 1
	if (flags & SVpad_OUR)	sv_catpv(d, "OUR,");
d848 1
a848 1
	/* FALL THROUGH */
d852 1
a857 4
    case SVt_PVMG:
	if (flags & SVpad_TYPED)
				sv_catpv(d, "TYPED,");
	break;
a858 2
    if (SvPOK(sv) && SvUTF8(sv))
        sv_catpv(d, "UTF8");
d956 1
a956 4
	    PerlIO_printf(file, "%s", pv_display(d, SvPVX(sv), SvCUR(sv), SvLEN(sv), pvlim));
	    if (SvUTF8(sv)) /* the 8?  \x{....} */
	        PerlIO_printf(file, " [UTF8 \"%s\"]", sv_uni_display(d, sv, 8 * sv_len_utf8(sv), UNI_DISPLAY_QQ));
	    PerlIO_printf(file, "\n");
d1001 1
a1001 1
		if (elt)
d1019 1
a1019 1
	    for (i = 0; (STRLEN)i <= HvMAX(sv); i++) {
d1039 1
a1039 11
	    /* The "quality" of a hash is defined as the total number of
	       comparisons needed to access every element once, relative
	       to the expected number needed for a random hash.

	       The total number of comparisons is equal to the sum of
	       the squares of the number of entries in each bucket.
	       For a random hash of n keys into k buckets, the expected
	       value is
				n + n(n-1)/2k
	    */

d1045 1
d1047 1
a1047 1
	    theoret += theoret * (theoret-1)/pow2;
d1067 4
a1070 5
	    while ((he = hv_iternext_flags(hv, HV_ITERNEXT_WANTPLACEHOLDERS))
                   && count--) {
		SV *elt, *keysv;
		char *keypv;
		STRLEN len;
d1073 1
a1073 2
		keysv = hv_iterkeysv(he);
		keypv = SvPV(keysv, len);
d1075 1
a1075 4
		Perl_dump_indent(aTHX_ level+1, file, "Elt %s ", pv_display(d, keypv, len, 0, pvlim));
		if (SvUTF8(keysv))
		    PerlIO_printf(file, "[UTF8 \"%s\"] ", sv_uni_display(d, keysv, 8 * sv_len_utf8(keysv), UNI_DISPLAY_QQ));
		PerlIO_printf(file, "HASH = 0x%"UVxf"\n", (UV)hash);
d1097 1
a1097 1
#ifdef USE_5005THREADS
d1100 1
a1100 1
#endif /* USE_5005THREADS */
d1117 1
a1117 1
				file,
d1128 1
a1128 1
	    Perl_dump_indent(aTHX_ level, file, "  OUTSIDE = 0x%"UVxf" (%s)\n",
a1191 126
}

int
Perl_runops_debug(pTHX)
{
    if (!PL_op) {
	if (ckWARN_d(WARN_DEBUGGING))
	    Perl_warner(aTHX_ packWARN(WARN_DEBUGGING), "NULL OP IN RUN");
	return 0;
    }

    do {
	PERL_ASYNC_CHECK();
	if (PL_debug) {
	    if (PL_watchaddr != 0 && *PL_watchaddr != PL_watchok)
		PerlIO_printf(Perl_debug_log,
			      "WARNING: %"UVxf" changed from %"UVxf" to %"UVxf"\n",
			      PTR2UV(PL_watchaddr), PTR2UV(PL_watchok),
			      PTR2UV(*PL_watchaddr));
	    if (DEBUG_s_TEST_) debstack();
	    if (DEBUG_t_TEST_) debop(PL_op);
	    if (DEBUG_P_TEST_) debprof(PL_op);
	}
    } while ((PL_op = CALL_FPTR(PL_op->op_ppaddr)(aTHX)));

    TAINT_NOT;
    return 0;
}

I32
Perl_debop(pTHX_ OP *o)
{
    AV *padlist, *comppad;
    CV *cv;
    SV *sv;
    STRLEN n_a;

    if (CopSTASH_eq(PL_curcop, PL_debstash) && !DEBUG_J_TEST_)
	return 0;

    Perl_deb(aTHX_ "%s", OP_NAME(o));
    switch (o->op_type) {
    case OP_CONST:
	PerlIO_printf(Perl_debug_log, "(%s)", SvPEEK(cSVOPo_sv));
	break;
    case OP_GVSV:
    case OP_GV:
	if (cGVOPo_gv) {
	    sv = NEWSV(0,0);
	    gv_fullname3(sv, cGVOPo_gv, Nullch);
	    PerlIO_printf(Perl_debug_log, "(%s)", SvPV(sv, n_a));
	    SvREFCNT_dec(sv);
	}
	else
	    PerlIO_printf(Perl_debug_log, "(NULL)");
	break;
    case OP_PADSV:
    case OP_PADAV:
    case OP_PADHV:
	/* print the lexical's name */
        cv = deb_curcv(cxstack_ix);
        if (cv) {
            padlist = CvPADLIST(cv);
            comppad = (AV*)(*av_fetch(padlist, 0, FALSE));
            sv = *av_fetch(comppad, o->op_targ, FALSE);
        } else
            sv = Nullsv;
        if (sv)
           PerlIO_printf(Perl_debug_log, "(%s)", SvPV_nolen(sv));
        else
           PerlIO_printf(Perl_debug_log, "[%"UVuf"]", (UV)o->op_targ);
        break;
    default:
	break;
    }
    PerlIO_printf(Perl_debug_log, "\n");
    return 0;
}

STATIC CV*
S_deb_curcv(pTHX_ I32 ix)
{
    PERL_CONTEXT *cx = &cxstack[ix];
    if (CxTYPE(cx) == CXt_SUB || CxTYPE(cx) == CXt_FORMAT)
        return cx->blk_sub.cv;
    else if (CxTYPE(cx) == CXt_EVAL && !CxTRYBLOCK(cx))
        return PL_compcv;
    else if (ix == 0 && PL_curstackinfo->si_type == PERLSI_MAIN)
        return PL_main_cv;
    else if (ix <= 0)
        return Nullcv;
    else
        return deb_curcv(ix - 1);
}

void
Perl_watch(pTHX_ char **addr)
{
    PL_watchaddr = addr;
    PL_watchok = *addr;
    PerlIO_printf(Perl_debug_log, "WATCHING, %"UVxf" is currently %"UVxf"\n",
	PTR2UV(PL_watchaddr), PTR2UV(PL_watchok));
}

STATIC void
S_debprof(pTHX_ OP *o)
{
    if (CopSTASH_eq(PL_curcop, PL_debstash) && !DEBUG_J_TEST_)
	return;
    if (!PL_profiledata)
	Newz(000, PL_profiledata, MAXO, U32);
    ++PL_profiledata[o->op_type];
}

void
Perl_debprofdump(pTHX)
{
    unsigned i;
    if (!PL_profiledata)
	return;
    for (i = 0; i < MAXO; i++) {
	if (PL_profiledata[i])
	    PerlIO_printf(Perl_debug_log,
			  "%5lu %s\n", (unsigned long)PL_profiledata[i],
                                       PL_op_name[i]);
    }
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d162 1
a162 1
    else if (sv == &PL_sv_undef || sv == &PL_sv_no || sv == &PL_sv_yes || sv == &PL_sv_placeholder) {
d180 1
a180 1
	else if (sv == &PL_sv_yes) {
a190 7
	else {
	    sv_catpv(t, "SV_PLACEHOLDER");
	    if (!(SvFLAGS(sv) & (SVf_OK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		SvREADONLY(sv))
		goto finish;
	}
d197 2
a198 15
    else if (DEBUG_R_TEST_) {
	int is_tmp = 0;
	I32 ix;
	/* is this SV on the tmps stack? */
	for (ix=PL_tmps_ix; ix>=0; ix--) {
	    if (PL_tmps_stack[ix] == sv) {
		is_tmp = 1;
		break;
	    }
	}
	if (SvREFCNT(sv) > 1)
	    Perl_sv_catpvf(aTHX_ t, "<%"UVuf"%s>", (UV)SvREFCNT(sv),
		    is_tmp ? "T" : "");
	else if (is_tmp)
	    sv_catpv(t, "<T>");
d201 1
d402 1
a402 2
		    Perl_dump_indent(aTHX_ level, file, "LINE = %"UVf"\n",
				     (UV)CopLINE(cCOPo));
a607 4
	else if (OP_IS_FILETEST_ACCESS(o)) {
	     if (o->op_private & OPpFT_ACCESS)
		  sv_catpv(tmpsv, ",FT_ACCESS");
	}
d637 1
a637 1
	Perl_dump_indent(aTHX_ level, file, "SV = %s\n", SvPEEK(cSVOPo_sv));
d643 1
a643 2
	    Perl_dump_indent(aTHX_ level, file, "LINE = %"UVf"\n",
			     (UV)CopLINE(cCOPo));
a772 2
	{ PERL_MAGIC_vstring,        "v-string(V)" },
	{ PERL_MAGIC_utf8,           "utf8(w)" },
a815 1
	    else if (v == &PL_vtbl_utf8)       s = "utf8";
d846 1
a846 2
	    if (mg->mg_type == PERL_MAGIC_envelem &&
		mg->mg_flags & MGf_TAINTEDDIR)
d852 1
a852 2
	    if (mg->mg_type == PERL_MAGIC_regex_global &&
		mg->mg_flags & MGf_MINMATCH)
d865 3
a867 5
		 if (mg->mg_type != PERL_MAGIC_utf8) {
		      SV *sv = newSVpvn("", 0);
		      PerlIO_printf(file, " %s", pv_display(sv, mg->mg_ptr, mg->mg_len, 0, pvlim));
		      SvREFCNT_dec(sv);
		 }
a877 12
	if (mg->mg_type == PERL_MAGIC_utf8) {
	     STRLEN *cache = (STRLEN *) mg->mg_ptr;
	     if (cache) {
		  IV i;
		  for (i = 0; i < PERL_MAGIC_UTF8_CACHESIZE; i++)
		       Perl_dump_indent(aTHX_ level, file,
					"      %2"IVdf": %"UVuf" -> %"UVuf"\n",
					i,
					(UV)cache[i * 2],
					(UV)cache[i * 2 + 1]);
	     }
	}
d928 1
d964 1
a964 2
    if (flags & SVf_AMAGIC && type != SVt_PVHV)
				sv_catpv(d, "OVERLOAD,");
a982 1
	if (CvWEAKOUTSIDE(sv))	sv_catpv(d, "WEAKOUTSIDE,");
a987 1
	if (HvREHASH(sv))	sv_catpv(d, "REHASH,");
d1023 1
a1023 1
    if ((SvPOK(sv) || SvPOKp(sv)) && SvUTF8(sv))
d1110 2
d1144 2
a1145 3
	if (LvTYPE(sv) != 't' && LvTYPE(sv) != 'T')
	    do_sv_dump(level+1, file, LvTARG(sv), nest+1, maxnest,
		    dumpops, pvlim);
a1257 2
		if (HeKREHASH(he))
		    PerlIO_printf(file, "[REHASH] ");
d1266 1
a1266 1
	    Perl_dump_indent(aTHX_ level, file, "  PROTOTYPE = \"%s\"\n", SvPV_nolen(sv));
a1284 1
	Perl_dump_indent(aTHX_ level, file, "  OUTSIDE_SEQ = %"UVuf"\n", (UV)CvOUTSIDE_SEQ(sv));
d1288 20
a1307 2
	if (nest < maxnest) {
	    do_dump_pad(level+1, file, CvPADLIST(sv), 0);
d1394 1
a1394 10
	    if (DEBUG_s_TEST_) {
		if (DEBUG_v_TEST_) {
		    PerlIO_printf(Perl_debug_log, "\n");
		    deb_stack_all();
		}
		else
		    debstack();
	    }


d1410 1
d1425 1
a1425 1
	    PerlIO_printf(Perl_debug_log, "(%s)", SvPV_nolen(sv));
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d119 13
a131 11
	switch (*pv) {
	case '\t': sv_catpvn(dsv, "\\t", 2);  break;
	case '\n': sv_catpvn(dsv, "\\n", 2);  break;
	case '\r': sv_catpvn(dsv, "\\r", 2);  break;
	case '\f': sv_catpvn(dsv, "\\f", 2);  break;
	case '"':  sv_catpvn(dsv, "\\\"", 2); break;
	case '\\': sv_catpvn(dsv, "\\\\", 2); break;
	default:
	    if (isPRINT(*pv))
		sv_catpvn(dsv, pv, 1);
	    else if (cur && isDIGIT(*(pv+1)))
d647 8
a654 12
	if ( ! PL_op->op_flags & OPf_SPECIAL) { /* not lexical */
	    if (cSVOPo->op_sv) {
		SV *tmpsv = NEWSV(0,0);
		STRLEN n_a;
		ENTER;
		SAVEFREESV(tmpsv);
		gv_fullname3(tmpsv, (GV*)cSVOPo->op_sv, Nullch);
		Perl_dump_indent(aTHX_ level, file, "GV = %s\n", SvPV(tmpsv, n_a));
		LEAVE;
	    }
	    else
		Perl_dump_indent(aTHX_ level, file, "GV = NULL\n");
d656 2
a661 3
#ifndef USE_ITHREADS
	/* with ITHREADS, consts are stored in the pad, and the right pad
	 * may not be active here, so skip */
a662 1
#endif
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@a15 7
/* This file contains utility routines to dump the contents of SV and OP
 * structures, as used by command-line options like -Dt and -Dx, and
 * by Devel::Peek.
 *
 * It also holds the debugging version of the  runops function.
 */

@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, by Larry Wall and others
d57 1
a61 1
        const HE *entry;
d63 2
a64 2
            const GV *gv = (GV*)HeVAL(entry);
            const HV *hv;
d68 1
a68 1
		dump_sub((GV *)gv);
d70 1
a70 1
		dump_form((GV *)gv);
d73 1
a73 1
		dump_packsubs((HV *) hv);		/* nested package */
d81 1
a81 1
    SV * const sv = sv_newmortal();
d84 1
a84 1
    Perl_dump_indent(aTHX_ 0, Perl_debug_log, "\nSUB %s = ", SvPVX_const(sv));
d98 1
a98 1
    SV * const sv = sv_newmortal();
d101 1
a101 1
    Perl_dump_indent(aTHX_ 0, Perl_debug_log, "\nFORMAT %s = ", SvPVX_const(sv));
d117 2
a118 2
    const bool nul_terminated = len > cur && pv[cur] == '\0';
    bool truncated = 0;
d123 1
a123 1
            truncated = 1;
d154 2
a155 1
    SV * const t = sv_newmortal();
d193 1
a193 1
		SvPVX_const(sv) && *SvPVX_const(sv) == '1' &&
d230 1
a230 1
	    SvCUR_set(t, unref + 3);
d297 1
a297 1
	if (!SvPVX_const(sv))
d303 2
a304 2
		Perl_sv_catpvf(aTHX_ t, "[%s]", pv_display(tmp, (char *)SvPVX_const(sv)-SvIVX(sv), SvIVX(sv), 0, 127));
	    Perl_sv_catpvf(aTHX_ t, "%s)", pv_display(tmp, (char *)SvPVX_const(sv), SvCUR(sv), SvLEN(sv), 127));
d331 1
a331 1
    return SvPV_nolen(t);
d387 1
a387 1
	Perl_dump_indent(aTHX_ level, file, "PMFLAGS = (%s)\n", SvCUR(tmpsv) ? SvPVX_const(tmpsv) + 1 : "");
d471 1
a471 1
	Perl_dump_indent(aTHX_ level, file, "FLAGS = (%s)\n", SvCUR(tmpsv) ? SvPVX_const(tmpsv) + 1 : "");
d641 1
a641 1
	    Perl_dump_indent(aTHX_ level, file, "PRIVATE = (%s)\n", SvPVX_const(tmpsv) + 1);
d655 1
d659 1
a659 2
		Perl_dump_indent(aTHX_ level, file, "GV = %s\n",
				 SvPV_nolen_const(tmpsv));
d761 1
a761 1
    Perl_dump_indent(aTHX_ 1, Perl_debug_log, "GV_NAME = %s", SvPVX_const(sv));
d764 1
a764 1
	Perl_dump_indent(aTHX_ 1, Perl_debug_log, "-> %s", SvPVX_const(sv));
d775 1
a775 1
static const struct { const char type; const char *name; } magic_names[] = {
d826 2
a827 2
            const MGVTBL * const v = mg->mg_virtual;
 	    const char *s = 0;
d869 2
a870 2
	    const char *name = 0;
	    for (n = 0; magic_names[n].name; n++) {
a945 1
    const char *hvname;
d947 2
a948 2
    if (sv && (hvname = HvNAME_get(sv)))
	PerlIO_printf(file, "\t\"%s\"\n", hvname);
a967 1
	const char *hvname;
d969 2
a970 2
	if (GvSTASH(sv) && (hvname = HvNAME_get(GvSTASH(sv))))
	    PerlIO_printf(file, "%s\" :: \"", hvname);
d981 1
a981 1
    const char *s;
d1024 1
a1024 2
    if (flags & SVp_SCREAM && type != SVt_PVHV)
				sv_catpv(d, "SCREAM,");
a1045 1
	if (flags & SVphv_CLONEABLE) sv_catpv(d, "CLONEABLE,");
d1070 1
a1070 1
	if (SvIsUV(sv) && !(flags & SVf_ROK))	sv_catpv(d, "IsUV,");
d1081 1
a1081 2
    /* SVphv_SHAREKEYS is also 0x20000000 */
    if ((type != SVt_PVHV) && SvUTF8(sv))
d1084 2
a1085 4
    if (*(SvEND(d) - 1) == ',') {
        SvCUR_set(d, SvCUR(d) - 1);
	SvPVX(d)[SvCUR(d)] = '\0';
    }
d1087 1
a1087 1
    s = SvPVX_const(d);
d1174 2
a1175 2
	if (SvPVX_const(sv)) {
	    Perl_dump_indent(aTHX_ level, file,"  PV = 0x%"UVxf" ", PTR2UV(SvPVX_const(sv)));
d1177 2
a1178 2
		PerlIO_printf(file, "( %s . ) ", pv_display(d, (char *)SvPVX_const(sv)-SvIVX(sv), SvIVX(sv), 0, pvlim));
	    PerlIO_printf(file, "%s", pv_display(d, (char *)SvPVX_const(sv), SvCUR(sv), SvLEN(sv), pvlim));
d1216 1
a1216 1
	sv_setpvn(d, "", 0);
d1220 1
a1220 2
	Perl_dump_indent(aTHX_ level, file, "  FLAGS = (%s)\n",
			 SvCUR(d) ? SvPVX_const(d) + 1 : "");
d1290 2
a1291 2
	Perl_dump_indent(aTHX_ level, file, "  RITER = %"IVdf"\n", (IV)HvRITER_get(sv));
	Perl_dump_indent(aTHX_ level, file, "  EITER = 0x%"UVxf"\n", PTR2UV(HvEITER_get(sv)));
d1294 3
a1296 6
	{
	    const char *hvname = HvNAME_get(sv);
	    if (hvname)
		Perl_dump_indent(aTHX_ level, file, "  NAME = \"%s\"\n", hvname);
	}
	if (nest < maxnest && !HvEITER_get(sv)) { /* Try to preserve iterator */
d1305 1
a1305 1
                const char *keypv;
d1310 1
a1310 1
		keypv = SvPV_const(keysv, len);
d1312 1
a1312 1
		Perl_dump_indent(aTHX_ level+1, file, "Elt %s ", pv_display(d, (char *)keypv, len, 0, pvlim));
d1325 1
a1325 1
	    Perl_dump_indent(aTHX_ level, file, "  PROTOTYPE = \"%s\"\n", SvPV_nolen_const(sv));
d1352 1
a1352 1
            const CV *outside = CvOUTSIDE(sv);
d1458 4
d1473 1
a1473 1
	    SV *sv = NEWSV(0,0);
d1475 1
a1475 1
	    PerlIO_printf(Perl_debug_log, "(%s)", SvPV_nolen_const(sv));
a1483 1
	{
d1485 1
a1485 2
	CV *cv = deb_curcv(cxstack_ix);
	SV *sv;
d1487 2
a1488 2
            AV * const padlist = CvPADLIST(cv);
            AV * const comppad = (AV*)(*av_fetch(padlist, 0, FALSE));
d1493 1
a1493 1
           PerlIO_printf(Perl_debug_log, "(%s)", SvPV_nolen_const(sv));
a1495 1
	}
d1507 1
a1507 1
    const PERL_CONTEXT *cx = &cxstack[ix];
d1530 1
a1530 1
S_debprof(pTHX_ const OP *o)
d1535 1
a1535 1
	Newxz(PL_profiledata, MAXO, U32);
a1551 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
a26 43
#include "proto.h"


static const char* const svtypenames[SVt_LAST] = {
    "NULL",
    "BIND",
    "IV",
    "NV",
    "RV",
    "PV",
    "PVIV",
    "PVNV",
    "PVMG",
    "PVGV",
    "PVLV",
    "PVAV",
    "PVHV",
    "PVCV",
    "PVFM",
    "PVIO"
};


static const char* const svshorttypenames[SVt_LAST] = {
    "UNDEF",
    "BIND",
    "IV",
    "NV",
    "RV",
    "PV",
    "PVIV",
    "PVNV",
    "PVMG",
    "GV",
    "PVLV",
    "AV",
    "HV",
    "CV",
    "FM",
    "IO"
};

#define Sequence PL_op_sequence
a39 1
    dVAR;
a46 1
    dVAR;
d54 1
a54 1
Perl_dump_packsubs(pTHX_ const HV *stash)
a55 1
    dVAR;
d63 2
a64 1
	    const GV * const gv = (GV*)HeVAL(entry);
d68 1
a68 1
		dump_sub(gv);
d70 4
a73 6
		dump_form(gv);
	    if (HeKEY(entry)[HeKLEN(entry)-1] == ':') {
		const HV * const hv = GvHV(gv);
		if (hv && (hv != PL_defstash))
		    dump_packsubs(hv);		/* nested package */
	    }
d79 1
a79 1
Perl_dump_sub(pTHX_ const GV *gv)
d83 1
a83 1
    gv_fullname3(sv, gv, NULL);
d85 1
a85 1
    if (CvISXSUB(GvCV(gv)))
d96 1
a96 1
Perl_dump_form(pTHX_ const GV *gv)
d100 1
a100 1
    gv_fullname3(sv, gv, NULL);
a110 1
    dVAR;
d114 5
d120 4
a123 116
/*
=for apidoc Apd|char*|pv_escape|NN SV *dsv|NN const char const *str\
               |const STRLEN count|const STRLEN max
               |STRLEN const *escaped, const U32 flags

Escapes at most the first "count" chars of pv and puts the results into
dsv such that the size of the escaped string will not exceed "max" chars
and will not contain any incomplete escape sequences.

If flags contains PERL_PV_ESCAPE_QUOTE then any double quotes in the string
will also be escaped.

Normally the SV will be cleared before the escaped string is prepared,
but when PERL_PV_ESCAPE_NOCLEAR is set this will not occur.

If PERL_PV_ESCAPE_UNI is set then the input string is treated as Unicode,
if PERL_PV_ESCAPE_UNI_DETECT is set then the input string is scanned
using C<is_utf8_string()> to determine if it is Unicode.

If PERL_PV_ESCAPE_ALL is set then all input chars will be output
using C<\x01F1> style escapes, otherwise only chars above 255 will be
escaped using this style, other non printable chars will use octal or
common escaped patterns like C<\n>. If PERL_PV_ESCAPE_NOBACKSLASH
then all chars below 255 will be treated as printable and 
will be output as literals.

If PERL_PV_ESCAPE_FIRSTCHAR is set then only the first char of the
string will be escaped, regardles of max. If the string is utf8 and 
the chars value is >255 then it will be returned as a plain hex 
sequence. Thus the output will either be a single char, 
an octal escape sequence, a special escape like C<\n> or a 3 or 
more digit hex value. 

If PERL_PV_ESCAPE_RE is set then the escape char used will be a '%' and
not a '\\'. This is because regexes very often contain backslashed
sequences, whereas '%' is not a particularly common character in patterns.

Returns a pointer to the escaped text as held by dsv.

=cut
*/
#define PV_ESCAPE_OCTBUFSIZE 32

char *
Perl_pv_escape( pTHX_ SV *dsv, char const * const str, 
                const STRLEN count, const STRLEN max, 
                STRLEN * const escaped, const U32 flags ) 
{
    const char esc = (flags & PERL_PV_ESCAPE_RE) ? '%' : '\\';
    const char dq = (flags & PERL_PV_ESCAPE_QUOTE) ? '"' : esc;
    char octbuf[PV_ESCAPE_OCTBUFSIZE] = "%123456789ABCDF";
    STRLEN wrote = 0;    /* chars written so far */
    STRLEN chsize = 0;   /* size of data to be written */
    STRLEN readsize = 1; /* size of data just read */
    bool isuni= flags & PERL_PV_ESCAPE_UNI ? 1 : 0; /* is this Unicode */
    const char *pv  = str;
    const char * const end = pv + count; /* end of string */
    octbuf[0] = esc;

    if (!(flags & PERL_PV_ESCAPE_NOCLEAR)) {
	    /* This won't alter the UTF-8 flag */
	    sv_setpvn(dsv, "", 0);
    }
    
    if ((flags & PERL_PV_ESCAPE_UNI_DETECT) && is_utf8_string((U8*)pv, count))
        isuni = 1;
    
    for ( ; (pv < end && (!max || (wrote < max))) ; pv += readsize ) {
        const UV u= (isuni) ? utf8_to_uvchr((U8*)pv, &readsize) : (U8)*pv;            
        const U8 c = (U8)u & 0xFF;
        
        if ( ( u > 255 ) || (flags & PERL_PV_ESCAPE_ALL)) {
            if (flags & PERL_PV_ESCAPE_FIRSTCHAR) 
                chsize = my_snprintf( octbuf, PV_ESCAPE_OCTBUFSIZE, 
                                      "%"UVxf, u);
            else
                chsize = my_snprintf( octbuf, PV_ESCAPE_OCTBUFSIZE, 
                                      "%cx{%"UVxf"}", esc, u);
        } else if (flags & PERL_PV_ESCAPE_NOBACKSLASH) {
            chsize = 1;            
        } else {         
            if ( (c == dq) || (c == esc) || !isPRINT(c) ) {
	        chsize = 2;
                switch (c) {
                
		case '\\' : /* fallthrough */
		case '%'  : if ( c == esc )  {
		                octbuf[1] = esc;  
		            } else {
		                chsize = 1;
		            }
		            break;
		case '\v' : octbuf[1] = 'v';  break;
		case '\t' : octbuf[1] = 't';  break;
		case '\r' : octbuf[1] = 'r';  break;
		case '\n' : octbuf[1] = 'n';  break;
		case '\f' : octbuf[1] = 'f';  break;
                case '"'  : 
                        if ( dq == '"' ) 
				octbuf[1] = '"';
                        else 
                            chsize = 1;
                        break;
		default:
                        if ( (pv < end) && isDIGIT((U8)*(pv+readsize)) )
                            chsize = my_snprintf( octbuf, PV_ESCAPE_OCTBUFSIZE, 
                                                  "%c%03o", esc, c);
			else
                            chsize = my_snprintf( octbuf, PV_ESCAPE_OCTBUFSIZE, 
                                                  "%c%o", esc, c);
                }
            } else {
                chsize = 1;
            }
	}
	if ( max && (wrote + chsize > max) ) {
d125 16
a140 15
        } else if (chsize > 1) {
            sv_catpvn(dsv, octbuf, chsize);
            wrote += chsize;
	} else {
	    /* If PERL_PV_ESCAPE_NOBACKSLASH is set then bytes in the range
	       128-255 can be appended raw to the dsv. If dsv happens to be
	       UTF-8 then we need catpvf to upgrade them for us.
	       Or add a new API call sv_catpvc(). Think about that name, and
	       how to keep it clear that it's unlike the s of catpvs, which is
	       really an array octets, not a string.  */
            Perl_sv_catpvf( aTHX_ dsv, "%c", c);
	    wrote++;
	}
        if ( flags & PERL_PV_ESCAPE_FIRSTCHAR ) 
            break;
d142 5
a146 71
    if (escaped != NULL)
        *escaped= pv - str;
    return SvPVX(dsv);
}
/*
=for apidoc Apd|char *|pv_pretty|NN SV *dsv|NN const char const *str\
           |const STRLEN count|const STRLEN max\
           |const char const *start_color| const char const *end_color\
           |const U32 flags

Converts a string into something presentable, handling escaping via
pv_escape() and supporting quoting and ellipses.

If the PERL_PV_PRETTY_QUOTE flag is set then the result will be 
double quoted with any double quotes in the string escaped. Otherwise
if the PERL_PV_PRETTY_LTGT flag is set then the result be wrapped in
angle brackets. 
           
If the PERL_PV_PRETTY_ELLIPSES flag is set and not all characters in
string were output then an ellipsis C<...> will be appended to the
string. Note that this happens AFTER it has been quoted.
           
If start_color is non-null then it will be inserted after the opening
quote (if there is one) but before the escaped text. If end_color
is non-null then it will be inserted after the escaped text but before
any quotes or ellipses.

Returns a pointer to the prettified text as held by dsv.
           
=cut           
*/

char *
Perl_pv_pretty( pTHX_ SV *dsv, char const * const str, const STRLEN count, 
  const STRLEN max, char const * const start_color, char const * const end_color, 
  const U32 flags ) 
{
    const U8 dq = (flags & PERL_PV_PRETTY_QUOTE) ? '"' : '%';
    STRLEN escaped;
    
    if (!(flags & PERL_PV_PRETTY_NOCLEAR)) {
	    /* This won't alter the UTF-8 flag */
	    sv_setpvn(dsv, "", 0);
    }

    if ( dq == '"' )
        sv_catpvn(dsv, "\"", 1);
    else if ( flags & PERL_PV_PRETTY_LTGT )
        sv_catpvn(dsv, "<", 1);
        
    if ( start_color != NULL ) 
        Perl_sv_catpv( aTHX_ dsv, start_color);
    
    pv_escape( dsv, str, count, max, &escaped, flags | PERL_PV_ESCAPE_NOCLEAR );    
    
    if ( end_color != NULL ) 
        Perl_sv_catpv( aTHX_ dsv, end_color);

    if ( dq == '"' ) 
	sv_catpvn( dsv, "\"", 1 );
    else if ( flags & PERL_PV_PRETTY_LTGT )
        sv_catpvn( dsv, ">", 1);         
    
    if ( (flags & PERL_PV_PRETTY_ELLIPSES) && ( escaped < count ) )
	    sv_catpvn( dsv, "...", 3 );
 
    return SvPVX(dsv);
}

/*
=for apidoc pv_display
a147 21
  char *pv_display(SV *dsv, const char *pv, STRLEN cur, STRLEN len,
                   STRLEN pvlim, U32 flags)

Similar to

  pv_escape(dsv,pv,cur,pvlim,PERL_PV_ESCAPE_QUOTE);

except that an additional "\0" will be appended to the string when
len > cur and pv[cur] is "\0".

Note that the final string may be up to 7 chars longer than pvlim.

=cut
*/

char *
Perl_pv_display(pTHX_ SV *dsv, const char *pv, STRLEN cur, STRLEN len, STRLEN pvlim)
{
    pv_pretty( dsv, pv, cur, pvlim, NULL, NULL, PERL_PV_PRETTY_DUMP);
    if (len > cur && pv[cur] == '\0')
            sv_catpvn( dsv, "\\0", 2 );
a153 1
    dVAR;
a155 1
    U32 type;
d237 3
a239 3
    type = SvTYPE(sv);
    if (type == SVt_PVCV) {
	Perl_sv_catpvf(aTHX_ t, "CV(%s)", CvGV(sv) ? GvNAME(CvGV(sv)) : "");
a240 2
    } else if (type < SVt_LAST) {
	sv_catpv(t, svshorttypenames[type]);
d242 38
a279 4
	if (type == SVt_NULL)
	    goto finish;
    } else {
	sv_catpv(t, "FREED");
d281 12
d299 1
a299 1
	    SV * const tmp = newSVpvs("");
d302 2
a303 2
		Perl_sv_catpvf(aTHX_ t, "[%s]", pv_display(tmp, SvPVX_const(sv)-SvIVX(sv), SvIVX(sv), 0, 127));
	    Perl_sv_catpvf(aTHX_ t, "%s)", pv_display(tmp, SvPVX_const(sv), SvCUR(sv), SvLEN(sv), 127));
d306 1
a306 1
			       sv_uni_display(tmp, sv, 6 * SvCUR(sv),
d326 4
a329 2
    while (unref--)
	sv_catpv(t, ")");
d334 1
a334 1
Perl_do_pmop_dump(pTHX_ I32 level, PerlIO *file, const PMOP *pm)
d354 1
a354 1
    if (pm->op_type != OP_PUSHRE && pm->op_pmreplrootu.op_pmreplroot) {
d356 1
a356 1
	op_dump(pm->op_pmreplrootu.op_pmreplroot);
d359 27
a385 1
	SV * const tmpsv = pm_description(pm);
a392 45
static SV *
S_pm_description(pTHX_ const PMOP *pm)
{
    SV * const desc = newSVpvs("");
    const REGEXP * const regex = PM_GETRE(pm);
    const U32 pmflags = pm->op_pmflags;

    if (pmflags & PMf_ONCE)
	sv_catpv(desc, ",ONCE");
#ifdef USE_ITHREADS
    if (SvREADONLY(PL_regex_pad[pm->op_pmoffset]))
        sv_catpv(desc, ":USED");
#else
    if (pmflags & PMf_USED)
        sv_catpv(desc, ":USED");
#endif

    if (regex) {
        if (regex->extflags & RXf_TAINTED)
            sv_catpv(desc, ",TAINTED");
        if (regex->check_substr) {
            if (!(regex->extflags & RXf_NOSCAN))
                sv_catpv(desc, ",SCANFIRST");
            if (regex->extflags & RXf_CHECK_ALL)
                sv_catpv(desc, ",ALL");
        }
        if (regex->extflags & RXf_SKIPWHITE)
            sv_catpv(desc, ",SKIPWHITE");
    }

    if (pmflags & PMf_CONST)
	sv_catpv(desc, ",CONST");
    if (pmflags & PMf_KEEP)
	sv_catpv(desc, ",KEEP");
    if (pmflags & PMf_GLOBAL)
	sv_catpv(desc, ",GLOBAL");
    if (pmflags & PMf_CONTINUE)
	sv_catpv(desc, ",CONTINUE");
    if (pmflags & PMf_RETAINT)
	sv_catpv(desc, ",RETAINT");
    if (pmflags & PMf_EVAL)
	sv_catpv(desc, ",EVAL");
    return desc;
}

a398 114
/* An op sequencer.  We visit the ops in the order they're to execute. */

STATIC void
S_sequence(pTHX_ register const OP *o)
{
    dVAR;
    const OP *oldop = NULL;

    if (!o)
	return;

#ifdef PERL_MAD
    if (o->op_next == 0)
 	return;
#endif

    if (!Sequence)
	Sequence = newHV();

    for (; o; o = o->op_next) {
	STRLEN len;
	SV * const op = newSVuv(PTR2UV(o));
	const char * const key = SvPV_const(op, len);

	if (hv_exists(Sequence, key, len))
	    break;

	switch (o->op_type) {
	case OP_STUB:
	    if ((o->op_flags & OPf_WANT) != OPf_WANT_LIST) {
		(void)hv_store(Sequence, key, len, newSVuv(++PL_op_seq), 0);
		break;
	    }
	    goto nothin;
	case OP_NULL:
#ifdef PERL_MAD
	    if (o == o->op_next)
		return;
#endif
	    if (oldop && o->op_next)
		continue;
	    break;
	case OP_SCALAR:
	case OP_LINESEQ:
	case OP_SCOPE:
	  nothin:
	    if (oldop && o->op_next)
		continue;
	    (void)hv_store(Sequence, key, len, newSVuv(++PL_op_seq), 0);
	    break;

	case OP_MAPWHILE:
	case OP_GREPWHILE:
	case OP_AND:
	case OP_OR:
	case OP_DOR:
	case OP_ANDASSIGN:
	case OP_ORASSIGN:
	case OP_DORASSIGN:
	case OP_COND_EXPR:
	case OP_RANGE:
	    (void)hv_store(Sequence, key, len, newSVuv(++PL_op_seq), 0);
	    sequence_tail(cLOGOPo->op_other);
	    break;

	case OP_ENTERLOOP:
	case OP_ENTERITER:
	    (void)hv_store(Sequence, key, len, newSVuv(++PL_op_seq), 0);
	    sequence_tail(cLOOPo->op_redoop);
	    sequence_tail(cLOOPo->op_nextop);
	    sequence_tail(cLOOPo->op_lastop);
	    break;

	case OP_SUBST:
	    (void)hv_store(Sequence, key, len, newSVuv(++PL_op_seq), 0);
	    sequence_tail(cPMOPo->op_pmstashstartu.op_pmreplstart);
	    break;

	case OP_QR:
	case OP_MATCH:
	case OP_HELEM:
	    break;

	default:
	    (void)hv_store(Sequence, key, len, newSVuv(++PL_op_seq), 0);
	    break;
	}
	oldop = o;
    }
}

static void
S_sequence_tail(pTHX_ const OP *o)
{
    while (o && (o->op_type == OP_NULL))
	o = o->op_next;
    sequence(o);
}

STATIC UV
S_sequence_num(pTHX_ const OP *o)
{
    dVAR;
    SV     *op,
          **seq;
    const char *key;
    STRLEN  len;
    if (!o) return 0;
    op = newSVuv(PTR2UV(o));
    key = SvPV_const(op, len);
    seq = hv_fetch(Sequence, key, len, 0);
    return seq ? SvUV(*seq): 0;
}

d400 1
a400 1
Perl_do_op_dump(pTHX_ I32 level, PerlIO *file, const OP *o)
a401 5
    dVAR;
    UV      seq;
    const OPCODE optype = o->op_type;

    sequence(o);
d404 2
a405 3
    seq = sequence_num(o);
    if (seq)
	PerlIO_printf(file, "%-4"UVuf, seq);
d411 6
a416 3
    if (o->op_next)
	PerlIO_printf(file, seq ? "%"UVuf"\n" : "(%"UVuf")\n",
				sequence_num(o->op_next));
d420 2
a421 1
	if (optype == OP_NULL) {
d423 2
a424 1
	    if (o->op_targ == OP_NEXTSTATE) {
d426 1
a426 1
		    Perl_dump_indent(aTHX_ level, file, "LINE = %"UVuf"\n",
d442 2
a443 2
    if (o->op_flags || o->op_latefree || o->op_latefreed || o->op_attached) {
	SV * const tmpsv = newSVpvs("");
a469 6
	if (o->op_latefree)
	    sv_catpv(tmpsv, ",LATEFREE");
	if (o->op_latefreed)
	    sv_catpv(tmpsv, ",LATEFREED");
	if (o->op_attached)
	    sv_catpv(tmpsv, ",ATTACHED");
d474 2
a475 2
	SV * const tmpsv = newSVpvs("");
	if (PL_opargs[optype] & OA_TARGLEX) {
d479 4
a482 4
	else if (optype == OP_LEAVESUB ||
		 optype == OP_LEAVE ||
		 optype == OP_LEAVESUBLV ||
		 optype == OP_LEAVEWRITE) {
d486 1
a486 1
        else if (optype == OP_AASSIGN) {
d489 2
d492 1
a492 1
	else if (optype == OP_SASSIGN) {
d496 1
a496 1
	else if (optype == OP_TRANS) {
d508 1
a508 1
	else if (optype == OP_REPEAT) {
d512 8
a519 8
	else if (optype == OP_ENTERSUB ||
		 optype == OP_RV2SV ||
		 optype == OP_GVSV ||
		 optype == OP_RV2AV ||
		 optype == OP_RV2HV ||
		 optype == OP_RV2GV ||
		 optype == OP_AELEM ||
		 optype == OP_HELEM )
d521 1
a521 1
	    if (optype == OP_ENTERSUB) {
d537 10
a546 10
		case OPpDEREF_SV:
		    sv_catpv(tmpsv, ",SV");
		    break;
		case OPpDEREF_AV:
		    sv_catpv(tmpsv, ",AV");
		    break;
		case OPpDEREF_HV:
		    sv_catpv(tmpsv, ",HV");
		    break;
		}
d550 1
a550 1
	    if (optype == OP_AELEM || optype == OP_HELEM) {
d561 1
a561 1
	else if (optype == OP_CONST) {
d573 1
a573 1
	else if (optype == OP_FLIP) {
d577 1
a577 1
	else if (optype == OP_FLOP) {
d581 1
a581 1
	else if (optype == OP_RV2CV) {
d585 1
a585 1
	else if (optype == OP_GV) {
d589 1
a589 1
	else if (optype == OP_LIST) {
d593 1
a593 1
	else if (optype == OP_DELETE) {
d597 1
a597 1
	else if (optype == OP_EXISTS) {
d601 1
a601 1
	else if (optype == OP_SORT) {
d609 5
a613 1
	else if (optype == OP_OPEN || optype == OP_BACKTICK) {
d623 1
a623 1
	else if (optype == OP_EXIT) {
d629 1
a629 1
	else if (optype == OP_DIE) {
d633 3
a635 5
	else if (PL_check[optype] != MEMBER_TO_FPTR(Perl_ck_ftst)) {
	    if (OP_IS_FILETEST_ACCESS(o) && o->op_private & OPpFT_ACCESS)
		sv_catpv(tmpsv, ",FT_ACCESS");
	    if (o->op_private & OPpFT_STACKED)
		sv_catpv(tmpsv, ",FT_STACKED");
d644 1
a644 44
#ifdef PERL_MAD
    if (PL_madskills && o->op_madprop) {
	SV * const tmpsv = newSVpvn("", 0);
	MADPROP* mp = o->op_madprop;
	Perl_dump_indent(aTHX_ level, file, "MADPROPS = {\n");
	level++;
	while (mp) {
	    const char tmp = mp->mad_key;
	    sv_setpvn(tmpsv,"'",1);
	    if (tmp)
		sv_catpvn(tmpsv, &tmp, 1);
	    sv_catpv(tmpsv, "'=");
	    switch (mp->mad_type) {
	    case MAD_NULL:
		sv_catpv(tmpsv, "NULL");
		Perl_dump_indent(aTHX_ level, file, "%s\n", SvPVX(tmpsv));
		break;
	    case MAD_PV:
		sv_catpv(tmpsv, "<");
		sv_catpvn(tmpsv, (char*)mp->mad_val, mp->mad_vlen);
		sv_catpv(tmpsv, ">");
		Perl_dump_indent(aTHX_ level, file, "%s\n", SvPVX(tmpsv));
		break;
	    case MAD_OP:
		if ((OP*)mp->mad_val) {
		    Perl_dump_indent(aTHX_ level, file, "%s\n", SvPVX(tmpsv));
		    do_op_dump(level, file, (OP*)mp->mad_val);
		}
		break;
	    default:
		sv_catpv(tmpsv, "(UNK)");
		Perl_dump_indent(aTHX_ level, file, "%s\n", SvPVX(tmpsv));
		break;
	    }
	    mp = mp->mad_next;
	}
	level--;
	Perl_dump_indent(aTHX_ level, file, "}\n");

	SvREFCNT_dec(tmpsv);
    }
#endif

    switch (optype) {
d653 1
a653 1
		SV * const tmpsv = newSV(0);
d656 1
a656 6
#ifdef PERL_MAD
		/* FIXME - is this making unwarranted assumptions about the
		   UTF-8 cleanliness of the dump file handle?  */
		SvUTF8_on(tmpsv);
#endif
		gv_fullname3(tmpsv, (GV*)cSVOPo->op_sv, NULL);
d678 1
a678 1
	    Perl_dump_indent(aTHX_ level, file, "LINE = %"UVuf"\n",
d690 1
a690 1
	    PerlIO_printf(file, "%"UVuf"\n", sequence_num(cLOOPo->op_redoop));
d695 1
a695 1
	    PerlIO_printf(file, "%"UVuf"\n", sequence_num(cLOOPo->op_nextop));
d700 1
a700 1
	    PerlIO_printf(file, "%"UVuf"\n", sequence_num(cLOOPo->op_lastop));
d712 1
a712 1
	    PerlIO_printf(file, "%"UVuf"\n", sequence_num(cLOGOPo->op_other));
d743 1
a743 1
Perl_op_dump(pTHX_ const OP *o)
d759 1
a759 1
    gv_fullname3(sv, gv, NULL);
d762 1
a762 1
	gv_efullname3(sv, GvEGV(gv), NULL);
d777 1
a777 1
	{ PERL_MAGIC_rhash,          "rhash(%)" },
a778 1
	{ PERL_MAGIC_symtab,         "symtab(:)" },
a779 1
	{ PERL_MAGIC_arylen_p,       "arylen_p(@@)" },
a783 1
	{ PERL_MAGIC_hints,          "hints(H)" },
a795 1
	{ PERL_MAGIC_hintselem,      "hintselem(h)" },
d799 1
d809 1
a809 1
	{ PERL_MAGIC_vstring,        "vstring(V)" },
d815 1
a815 1
	{ 0,                         NULL },
d819 1
a819 1
Perl_do_magic_dump(pTHX_ I32 level, PerlIO *file, const MAGIC *mg, I32 nest, I32 maxnest, bool dumpops, STRLEN pvlim)
d826 1
a826 1
 	    const char *s;
d837 1
a854 3
            else if (v == &PL_vtbl_arylen_p)   s = "arylen_p";
            else if (v == &PL_vtbl_hintselem)  s = "hintselem";
	    else			       s = NULL;
d868 1
a868 1
	    const char *name = NULL;
d897 2
a898 15
	    Perl_dump_indent(aTHX_ level, file, "    MG_OBJ = 0x%"UVxf"\n", 
	        PTR2UV(mg->mg_obj));
            if (mg->mg_type == PERL_MAGIC_qr) {
		const regexp * const re = (regexp *)mg->mg_obj;
		SV * const dsv = sv_newmortal();
                const char * const s =  pv_pretty(dsv, re->wrapped, re->wraplen, 
                    60, NULL, NULL,
                    ( PERL_PV_PRETTY_QUOTE | PERL_PV_ESCAPE_RE | PERL_PV_PRETTY_ELLIPSES |
                    ((re->extflags & RXf_UTF8) ? PERL_PV_ESCAPE_UNI : 0))
                );
		Perl_dump_indent(aTHX_ level+1, file, "    PAT = %s\n", s);
		Perl_dump_indent(aTHX_ level+1, file, "    REFCNT = %"IVdf"\n",
			(IV)re->refcnt);
            }
            if (mg->mg_flags & MGf_REFCOUNTED)
d906 5
a910 5
		if (mg->mg_type != PERL_MAGIC_utf8) {
		    SV * const sv = newSVpvs("");
		    PerlIO_printf(file, " %s", pv_display(sv, mg->mg_ptr, mg->mg_len, 0, pvlim));
		    SvREFCNT_dec(sv);
		}
d922 10
a931 10
	    const STRLEN * const cache = (STRLEN *) mg->mg_ptr;
	    if (cache) {
		IV i;
		for (i = 0; i < PERL_MAGIC_UTF8_CACHESIZE; i++)
		    Perl_dump_indent(aTHX_ level, file,
				     "      %2"IVdf": %"UVuf" -> %"UVuf"\n",
				     i,
				     (UV)cache[i * 2],
				     (UV)cache[i * 2 + 1]);
	    }
d937 1
a937 1
Perl_magic_dump(pTHX_ const MAGIC *mg)
d939 1
a939 1
    do_magic_dump(0, Perl_debug_log, mg, 0, 0, FALSE, 0);
d943 1
a943 1
Perl_do_hv_dump(pTHX_ I32 level, PerlIO *file, const char *name, HV *sv)
d954 1
a954 1
Perl_do_gv_dump(pTHX_ I32 level, PerlIO *file, const char *name, GV *sv)
d964 1
a964 1
Perl_do_gvgv_dump(pTHX_ I32 level, PerlIO *file, const char *name, GV *sv)
a980 1
    dVAR;
d1000 3
a1002 7
    if (!(flags & SVpad_NAME && (type == SVt_PVMG || type == SVt_PVNV))) {
	if (flags & SVs_PADSTALE)	sv_catpv(d, "PADSTALE,");
    }
    if (!(flags & SVpad_NAME && type == SVt_PVMG)) {
	if (flags & SVs_PADTMP)	sv_catpv(d, "PADTMP,");
	if (flags & SVs_PADMY)	sv_catpv(d, "PADMY,");
    }
a1018 1
    if (flags & SVf_BREAK)	sv_catpv(d, "BREAK,");
d1020 2
a1021 1
    if (flags & SVf_AMAGIC)	sv_catpv(d, "OVERLOAD,");
d1025 1
a1025 4
    if (flags & SVp_SCREAM && type != SVt_PVHV && !isGV_with_GP(sv)) {
	if (SvPCS_IMPORTED(sv))
				sv_catpv(d, "PCS_IMPORTED,");
	else
a1026 1
    }
d1051 7
a1057 9
    case SVt_PVLV:
	if (isGV_with_GP(sv)) {
	    if (GvINTRO(sv))	sv_catpv(d, "INTRO,");
	    if (GvMULTI(sv))	sv_catpv(d, "MULTI,");
	    if (GvUNIQUE(sv))   sv_catpv(d, "UNIQUE,");
	    if (GvASSUMECV(sv))	sv_catpv(d, "ASSUMECV,");
	    if (GvIN_PAD(sv))   sv_catpv(d, "IN_PAD,");
	}
	if (isGV_with_GP(sv) && GvIMPORTED(sv)) {
a1069 2
	if (SvTAIL(sv))		sv_catpv(d, "TAIL,");
	if (SvVALID(sv))	sv_catpv(d, "VALID,");
a1071 1
    evaled_or_uv:
d1075 4
d1080 2
a1081 7
	if (SvPAD_TYPED(sv))	sv_catpv(d, "TYPED,");
	if (SvPAD_OUR(sv))	sv_catpv(d, "OUR,");
	/* FALL THROUGH */
    case SVt_PVNV:
	if (SvPAD_STATE(sv))	sv_catpv(d, "STATE,");
	goto evaled_or_uv;
    case SVt_PVAV:
a1094 8
#ifdef DEBUG_LEAKING_SCALARS
    Perl_dump_indent(aTHX_ level, file, "ALLOCATED at %s:%d %s %s%s\n",
	sv->sv_debug_file ? sv->sv_debug_file : "(unknown)",
	sv->sv_debug_line,
	sv->sv_debug_inpad ? "for" : "by",
	sv->sv_debug_optype ? PL_op_name[sv->sv_debug_optype]: "(none)",
	sv->sv_debug_cloned ? " (cloned)" : "");
#endif
d1096 51
a1146 8
    if (type < SVt_LAST) {
	PerlIO_printf(file, "%s%s\n", svtypenames[type], s);

	if (type ==  SVt_NULL) {
	    SvREFCNT_dec(d);
	    return;
	}
    } else {
d1151 2
a1152 8
    if ((type >= SVt_PVIV && type != SVt_PVAV && type != SVt_PVHV
	 && type != SVt_PVCV && !isGV_with_GP(sv))
	|| type == SVt_IV) {
	if (SvIsUV(sv)
#ifdef PERL_OLD_COPY_ON_WRITE
	               || SvIsCOW(sv)
#endif
	                             )
a1157 6
#ifdef PERL_OLD_COPY_ON_WRITE
	if (SvIsCOW_shared_hash(sv))
	    PerlIO_printf(file, "  (HASH)");
	else if (SvIsCOW_normal(sv))
	    PerlIO_printf(file, "  (COW from 0x%"UVxf")", (UV)SvUVX(sv));
#endif
d1160 1
a1160 9
    if ((type == SVt_PVNV || type == SVt_PVMG) && SvFLAGS(sv) & SVpad_NAME) {
	Perl_dump_indent(aTHX_ level, file, "  COP_LOW = %"UVuf"\n",
			 (UV) COP_SEQ_RANGE_LOW(sv));
	Perl_dump_indent(aTHX_ level, file, "  COP_HIGH = %"UVuf"\n",
			 (UV) COP_SEQ_RANGE_HIGH(sv));
    } else if ((type >= SVt_PVNV && type != SVt_PVAV && type != SVt_PVHV
		&& type != SVt_PVCV && type != SVt_PVFM && !isGV_with_GP(sv)
		&& !SvVALID(sv))
	       || type == SVt_NV) {
d1179 1
a1179 1
    if (type <= SVt_PVLV && !isGV_with_GP(sv)) {
d1183 4
a1186 4
		PerlIO_printf(file, "( %s . ) ", pv_display(d, SvPVX_const(sv)-SvIVX(sv), SvIVX(sv), 0, pvlim));
	    PerlIO_printf(file, "%s", pv_display(d, SvPVX_const(sv), SvCUR(sv), SvLEN(sv), pvlim));
	    if (SvUTF8(sv)) /* the 6?  \x{....} */
	        PerlIO_printf(file, " [UTF8 \"%s\"]", sv_uni_display(d, sv, 6 * SvCUR(sv), UNI_DISPLAY_QQ));
d1195 2
a1196 8
	if (type == SVt_PVMG && SvPAD_OUR(sv)) {
	    HV * const ost = SvOURSTASH(sv);
	    if (ost)
		do_hv_dump(level, file, "  OURSTASH", ost);
	} else {
	    if (SvMAGIC(sv))
		do_magic_dump(level, file, SvMAGIC(sv), nest, maxnest, dumpops, pvlim);
	}
d1201 9
d1220 2
a1221 1
	Perl_dump_indent(aTHX_ level, file, "  ARYLEN = 0x%"UVxf"\n", SvMAGIC(sv) ? PTR2UV(AvARYLEN(sv)) : 0);
d1223 3
a1225 2
	if (AvREAL(sv))	sv_catpv(d, ",REAL");
	if (AvREIFY(sv))	sv_catpv(d, ",REIFY");
d1231 1
a1231 1
		SV** const elt = av_fetch((AV*)sv,count,0);
d1244 1
a1244 1
#define FREQ_MAX ((int)(sizeof freq / sizeof freq[0] - 1))
d1253 1
a1253 2
		HE* h;
		int count = 0;
d1299 2
d1302 1
a1302 7
	    MAGIC * const mg = mg_find(sv, PERL_MAGIC_symtab);
	    if (mg && mg->mg_obj) {
		Perl_dump_indent(aTHX_ level, file, "  PMROOT = 0x%"UVxf"\n", PTR2UV(mg->mg_obj));
	    }
	}
	{
	    const char * const hvname = HvNAME_get(sv);
a1305 9
	if (SvOOK(sv)) {
	    const AV * const backrefs = *Perl_hv_backreferences_p(aTHX_ (HV*)sv);
	    if (backrefs) {
		Perl_dump_indent(aTHX_ level, file, "  BACKREFS = 0x%"UVxf"\n",
				 PTR2UV(backrefs));
		do_sv_dump(level+1, file, (SV*)backrefs, nest+1, maxnest,
			   dumpops, pvlim);
	    }
	}
d1308 1
a1308 1
	    HV * const hv = (HV*)sv;
d1314 2
d1317 1
a1317 4
		const U32 hash = HeHASH(he);
		SV * const keysv = hv_iterkeysv(he);
		const char * const keypv = SvPV_const(keysv, len);
		SV * const elt = hv_iterval(hv, he);
d1319 4
a1322 1
		Perl_dump_indent(aTHX_ level+1, file, "Elt %s ", pv_display(d, keypv, len, 0, pvlim));
d1324 1
a1324 1
		    PerlIO_printf(file, "[UTF8 \"%s\"] ", sv_uni_display(d, keysv, 6 * SvCUR(keysv), UNI_DISPLAY_QQ));
d1334 2
a1335 6
	if (SvPOK(sv)) {
	    STRLEN len;
	    const char *const proto =  SvPV_const(sv, len);
	    Perl_dump_indent(aTHX_ level, file, "  PROTOTYPE = \"%.*s\"\n",
			     (int) len, proto);
	}
d1339 7
a1345 28
	if (!CvISXSUB(sv)) {
	    if (CvSTART(sv)) {
		Perl_dump_indent(aTHX_ level, file,
				 "  START = 0x%"UVxf" ===> %"IVdf"\n",
				 PTR2UV(CvSTART(sv)),
				 (IV)sequence_num(CvSTART(sv)));
	    }
	    Perl_dump_indent(aTHX_ level, file, "  ROOT = 0x%"UVxf"\n",
			     PTR2UV(CvROOT(sv)));
	    if (CvROOT(sv) && dumpops) {
		do_op_dump(level+1, file, CvROOT(sv));
	    }
	} else {
	    SV * const constant = cv_const_sv((CV *)sv);

	    Perl_dump_indent(aTHX_ level, file, "  XSUB = 0x%"UVxf"\n", PTR2UV(CvXSUB(sv)));

	    if (constant) {
		Perl_dump_indent(aTHX_ level, file, "  XSUBANY = 0x%"UVxf
				 " (CONST SV)\n",
				 PTR2UV(CvXSUBANY(sv).any_ptr));
		do_sv_dump(level+1, file, constant, nest+1, maxnest, dumpops,
			   pvlim);
	    } else {
		Perl_dump_indent(aTHX_ level, file, "  XSUBANY = %"IVdf"\n",
				 (IV)CvXSUBANY(sv).any_i32);
	    }
	}
d1349 4
d1362 1
a1362 1
	    const CV * const outside = CvOUTSIDE(sv);
a1374 18
    case SVt_PVLV:
	if (type == SVt_PVLV) {
	    Perl_dump_indent(aTHX_ level, file, "  TYPE = %c\n", LvTYPE(sv));
	    Perl_dump_indent(aTHX_ level, file, "  TARGOFF = %"IVdf"\n", (IV)LvTARGOFF(sv));
	    Perl_dump_indent(aTHX_ level, file, "  TARGLEN = %"IVdf"\n", (IV)LvTARGLEN(sv));
	    Perl_dump_indent(aTHX_ level, file, "  TARG = 0x%"UVxf"\n", PTR2UV(LvTARG(sv)));
	    if (LvTYPE(sv) != 't' && LvTYPE(sv) != 'T')
		do_sv_dump(level+1, file, LvTARG(sv), nest+1, maxnest,
		    dumpops, pvlim);
	}
	if (SvVALID(sv)) {
	    Perl_dump_indent(aTHX_ level, file, "  FLAGS = %u\n", (U8)BmFLAGS(sv));
	    Perl_dump_indent(aTHX_ level, file, "  RARE = %u\n", (U8)BmRARE(sv));
	    Perl_dump_indent(aTHX_ level, file, "  PREVIOUS = %"UVuf"\n", (UV)BmPREVIOUS(sv));
	    Perl_dump_indent(aTHX_ level, file, "  USEFUL = %"IVdf"\n", (IV)BmUSEFUL(sv));
	}
	if (!isGV_with_GP(sv))
	    break;
d1389 1
d1405 1
a1405 10
	if (!IoTOP_GV(sv) || SvTYPE(IoTOP_GV(sv)) == SVt_PVGV)
	    do_gv_dump (level, file, "  TOP_GV", IoTOP_GV(sv));
	else {
	    Perl_dump_indent(aTHX_ level, file, "  TOP_GV = 0x%"UVxf"\n",
			     PTR2UV(IoTOP_GV(sv)));
	    do_sv_dump (level+1, file, (SV *) IoTOP_GV(sv), nest+1, maxnest,
			dumpops, pvlim);
	}
	/* Source filters hide things that are not GVs in these three, so let's
	   be careful out there.  */
d1408 1
a1408 8
	if (!IoFMT_GV(sv) || SvTYPE(IoFMT_GV(sv)) == SVt_PVGV)
	    do_gv_dump (level, file, "  FMT_GV", IoFMT_GV(sv));
	else {
	    Perl_dump_indent(aTHX_ level, file, "  FMT_GV = 0x%"UVxf"\n",
			     PTR2UV(IoFMT_GV(sv)));
	    do_sv_dump (level+1, file, (SV *) IoFMT_GV(sv), nest+1, maxnest,
			dumpops, pvlim);
	}
d1411 2
a1412 8
	if (!IoBOTTOM_GV(sv) || SvTYPE(IoBOTTOM_GV(sv)) == SVt_PVGV)
	    do_gv_dump (level, file, "  BOTTOM_GV", IoBOTTOM_GV(sv));
	else {
	    Perl_dump_indent(aTHX_ level, file, "  BOTTOM_GV = 0x%"UVxf"\n",
			     PTR2UV(IoBOTTOM_GV(sv)));
	    do_sv_dump (level+1, file, (SV *) IoBOTTOM_GV(sv), nest+1, maxnest,
			dumpops, pvlim);
	}
d1426 1
a1426 5
    dVAR;
    if (SvROK(sv))
	do_sv_dump(0, Perl_debug_log, sv, 0, 4, 0, 0);
    else
	do_sv_dump(0, Perl_debug_log, sv, 0, 0, 0, 0);
a1431 1
    dVAR;
a1437 1
    DEBUG_l(Perl_deb(aTHX_ "Entering new RUNOPS level\n"));
d1441 1
a1441 1
	    if (PL_watchaddr && (*PL_watchaddr != PL_watchok))
a1459 1
    DEBUG_l(Perl_deb(aTHX_ "leaving RUNOPS level\n"));
d1466 1
a1466 1
Perl_debop(pTHX_ const OP *o)
a1467 1
    dVAR;
d1479 2
a1480 7
	    SV * const sv = newSV(0);
#ifdef PERL_MAD
	    /* FIXME - is this making unwarranted assumptions about the
	       UTF-8 cleanliness of the dump file handle?  */
	    SvUTF8_on(sv);
#endif
	    gv_fullname3(sv, cGVOPo_gv, NULL);
d1492 1
a1492 1
	CV * const cv = deb_curcv(cxstack_ix);
d1495 1
a1495 1
	    AV * const padlist = CvPADLIST(cv);
d1499 1
a1499 1
            sv = NULL;
d1501 1
a1501 1
	    PerlIO_printf(Perl_debug_log, "(%s)", SvPV_nolen_const(sv));
d1503 1
a1503 1
	    PerlIO_printf(Perl_debug_log, "[%"UVuf"]", (UV)o->op_targ);
d1514 1
a1514 1
S_deb_curcv(pTHX_ const I32 ix)
d1516 1
a1516 2
    dVAR;
    const PERL_CONTEXT * const cx = &cxstack[ix];
d1524 1
a1524 1
        return NULL;
a1531 1
    dVAR;
d1541 1
a1541 2
    dVAR;
    if (!DEBUG_J_TEST_ && CopSTASH_eq(PL_curcop, PL_debstash))
a1550 1
    dVAR;
a1560 881

#ifdef PERL_MAD
/*
 *    XML variants of most of the above routines
 */

STATIC void
S_xmldump_attr(pTHX_ I32 level, PerlIO *file, const char* pat, ...)
{
    va_list args;
    PerlIO_printf(file, "\n    ");
    va_start(args, pat);
    xmldump_vindent(level, file, pat, &args);
    va_end(args);
}


void
Perl_xmldump_indent(pTHX_ I32 level, PerlIO *file, const char* pat, ...)
{
    va_list args;
    va_start(args, pat);
    xmldump_vindent(level, file, pat, &args);
    va_end(args);
}

void
Perl_xmldump_vindent(pTHX_ I32 level, PerlIO *file, const char* pat, va_list *args)
{
    PerlIO_printf(file, "%*s", (int)(level*PL_dumpindent), "");
    PerlIO_vprintf(file, pat, *args);
}

void
Perl_xmldump_all(pTHX)
{
    PerlIO_setlinebuf(PL_xmlfp);
    if (PL_main_root)
	op_xmldump(PL_main_root);
    if (PL_xmlfp != (PerlIO*)PerlIO_stdout())
	PerlIO_close(PL_xmlfp);
    PL_xmlfp = 0;
}

void
Perl_xmldump_packsubs(pTHX_ const HV *stash)
{
    I32	i;
    HE	*entry;

    if (!HvARRAY(stash))
	return;
    for (i = 0; i <= (I32) HvMAX(stash); i++) {
	for (entry = HvARRAY(stash)[i]; entry; entry = HeNEXT(entry)) {
	    GV *gv = (GV*)HeVAL(entry);
	    HV *hv;
	    if (SvTYPE(gv) != SVt_PVGV || !GvGP(gv))
		continue;
	    if (GvCVu(gv))
		xmldump_sub(gv);
	    if (GvFORM(gv))
		xmldump_form(gv);
	    if (HeKEY(entry)[HeKLEN(entry)-1] == ':'
		&& (hv = GvHV(gv)) && hv != PL_defstash)
		xmldump_packsubs(hv);		/* nested package */
	}
    }
}

void
Perl_xmldump_sub(pTHX_ const GV *gv)
{
    SV * const sv = sv_newmortal();

    gv_fullname3(sv, gv, NULL);
    Perl_xmldump_indent(aTHX_ 0, PL_xmlfp, "\nSUB %s = ", SvPVX(sv));
    if (CvXSUB(GvCV(gv)))
	Perl_xmldump_indent(aTHX_ 0, PL_xmlfp, "(xsub 0x%"UVxf" %d)\n",
	    PTR2UV(CvXSUB(GvCV(gv))),
	    (int)CvXSUBANY(GvCV(gv)).any_i32);
    else if (CvROOT(GvCV(gv)))
	op_xmldump(CvROOT(GvCV(gv)));
    else
	Perl_xmldump_indent(aTHX_ 0, PL_xmlfp, "<undef>\n");
}

void
Perl_xmldump_form(pTHX_ const GV *gv)
{
    SV * const sv = sv_newmortal();

    gv_fullname3(sv, gv, NULL);
    Perl_xmldump_indent(aTHX_ 0, PL_xmlfp, "\nFORMAT %s = ", SvPVX(sv));
    if (CvROOT(GvFORM(gv)))
	op_xmldump(CvROOT(GvFORM(gv)));
    else
	Perl_xmldump_indent(aTHX_ 0, PL_xmlfp, "<undef>\n");
}

void
Perl_xmldump_eval(pTHX)
{
    op_xmldump(PL_eval_root);
}

char *
Perl_sv_catxmlsv(pTHX_ SV *dsv, SV *ssv)
{
    return sv_catxmlpvn(dsv, SvPVX(ssv), SvCUR(ssv), SvUTF8(ssv));
}

char *
Perl_sv_catxmlpvn(pTHX_ SV *dsv, const char *pv, STRLEN len, int utf8)
{
    unsigned int c;
    const char * const e = pv + len;
    const char * const start = pv;
    STRLEN dsvcur;
    STRLEN cl;

    sv_catpvn(dsv,"",0);
    dsvcur = SvCUR(dsv);	/* in case we have to restart */

  retry:
    while (pv < e) {
	if (utf8) {
	    c = utf8_to_uvchr((U8*)pv, &cl);
	    if (cl == 0) {
		SvCUR(dsv) = dsvcur;
		pv = start;
		utf8 = 0;
		goto retry;
	    }
	}
	else
	    c = (*pv & 255);

	switch (c) {
	case 0x00:
	case 0x01:
	case 0x02:
	case 0x03:
	case 0x04:
	case 0x05:
	case 0x06:
	case 0x07:
	case 0x08:
	case 0x0b:
	case 0x0c:
	case 0x0e:
	case 0x0f:
	case 0x10:
	case 0x11:
	case 0x12:
	case 0x13:
	case 0x14:
	case 0x15:
	case 0x16:
	case 0x17:
	case 0x18:
	case 0x19:
	case 0x1a:
	case 0x1b:
	case 0x1c:
	case 0x1d:
	case 0x1e:
	case 0x1f:
	case 0x7f:
	case 0x80:
	case 0x81:
	case 0x82:
	case 0x83:
	case 0x84:
	case 0x86:
	case 0x87:
	case 0x88:
	case 0x89:
	case 0x90:
	case 0x91:
	case 0x92:
	case 0x93:
	case 0x94:
	case 0x95:
	case 0x96:
	case 0x97:
	case 0x98:
	case 0x99:
	case 0x9a:
	case 0x9b:
	case 0x9c:
	case 0x9d:
	case 0x9e:
	case 0x9f:
	    Perl_sv_catpvf(aTHX_ dsv, "STUPIDXML(#x%X)", c);
	    break;
	case '<':
	    sv_catpvs(dsv, "&lt;");
	    break;
	case '>':
	    sv_catpvs(dsv, "&gt;");
	    break;
	case '&':
	    sv_catpvs(dsv, "&amp;");
	    break;
	case '"':
	    sv_catpvs(dsv, "&#34;");
	    break;
	default:
	    if (c < 0xD800) {
		if (c < 32 || c > 127) {
		    Perl_sv_catpvf(aTHX_ dsv, "&#x%X;", c);
		}
		else {
		    const char string = (char) c;
		    sv_catpvn(dsv, &string, 1);
		}
		break;
	    }
	    if ((c >= 0xD800 && c <= 0xDB7F) ||
		(c >= 0xDC00 && c <= 0xDFFF) ||
		(c >= 0xFFF0 && c <= 0xFFFF) ||
		 c > 0x10ffff)
		Perl_sv_catpvf(aTHX_ dsv, "STUPIDXML(#x%X)", c);
	    else
		Perl_sv_catpvf(aTHX_ dsv, "&#x%X;", c);
	}

	if (utf8)
	    pv += UTF8SKIP(pv);
	else
	    pv++;
    }

    return SvPVX(dsv);
}

char *
Perl_sv_xmlpeek(pTHX_ SV *sv)
{
    SV * const t = sv_newmortal();
    STRLEN n_a;
    int unref = 0;

    sv_utf8_upgrade(t);
    sv_setpvn(t, "", 0);
    /* retry: */
    if (!sv) {
	sv_catpv(t, "VOID=\"\"");
	goto finish;
    }
    else if (sv == (SV*)0x55555555 || SvTYPE(sv) == 'U') {
	sv_catpv(t, "WILD=\"\"");
	goto finish;
    }
    else if (sv == &PL_sv_undef || sv == &PL_sv_no || sv == &PL_sv_yes || sv == &PL_sv_placeholder) {
	if (sv == &PL_sv_undef) {
	    sv_catpv(t, "SV_UNDEF=\"1\"");
	    if (!(SvFLAGS(sv) & (SVf_OK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		SvREADONLY(sv))
		goto finish;
	}
	else if (sv == &PL_sv_no) {
	    sv_catpv(t, "SV_NO=\"1\"");
	    if (!(SvFLAGS(sv) & (SVf_ROK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		!(~SvFLAGS(sv) & (SVf_POK|SVf_NOK|SVf_READONLY|
				  SVp_POK|SVp_NOK)) &&
		SvCUR(sv) == 0 &&
		SvNVX(sv) == 0.0)
		goto finish;
	}
	else if (sv == &PL_sv_yes) {
	    sv_catpv(t, "SV_YES=\"1\"");
	    if (!(SvFLAGS(sv) & (SVf_ROK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		!(~SvFLAGS(sv) & (SVf_POK|SVf_NOK|SVf_READONLY|
				  SVp_POK|SVp_NOK)) &&
		SvCUR(sv) == 1 &&
		SvPVX(sv) && *SvPVX(sv) == '1' &&
		SvNVX(sv) == 1.0)
		goto finish;
	}
	else {
	    sv_catpv(t, "SV_PLACEHOLDER=\"1\"");
	    if (!(SvFLAGS(sv) & (SVf_OK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		SvREADONLY(sv))
		goto finish;
	}
	sv_catpv(t, " XXX=\"\" ");
    }
    else if (SvREFCNT(sv) == 0) {
	sv_catpv(t, " refcnt=\"0\"");
	unref++;
    }
    else if (DEBUG_R_TEST_) {
	int is_tmp = 0;
	I32 ix;
	/* is this SV on the tmps stack? */
	for (ix=PL_tmps_ix; ix>=0; ix--) {
	    if (PL_tmps_stack[ix] == sv) {
		is_tmp = 1;
		break;
	    }
	}
	if (SvREFCNT(sv) > 1)
	    Perl_sv_catpvf(aTHX_ t, " DRT=\"<%"UVuf"%s>\"", (UV)SvREFCNT(sv),
		    is_tmp ? "T" : "");
	else if (is_tmp)
	    sv_catpv(t, " DRT=\"<T>\"");
    }

    if (SvROK(sv)) {
	sv_catpv(t, " ROK=\"\"");
    }
    switch (SvTYPE(sv)) {
    default:
	sv_catpv(t, " FREED=\"1\"");
	goto finish;

    case SVt_NULL:
	sv_catpv(t, " UNDEF=\"1\"");
	goto finish;
    case SVt_IV:
	sv_catpv(t, " IV=\"");
	break;
    case SVt_NV:
	sv_catpv(t, " NV=\"");
	break;
    case SVt_RV:
	sv_catpv(t, " RV=\"");
	break;
    case SVt_PV:
	sv_catpv(t, " PV=\"");
	break;
    case SVt_PVIV:
	sv_catpv(t, " PVIV=\"");
	break;
    case SVt_PVNV:
	sv_catpv(t, " PVNV=\"");
	break;
    case SVt_PVMG:
	sv_catpv(t, " PVMG=\"");
	break;
    case SVt_PVLV:
	sv_catpv(t, " PVLV=\"");
	break;
    case SVt_PVAV:
	sv_catpv(t, " AV=\"");
	break;
    case SVt_PVHV:
	sv_catpv(t, " HV=\"");
	break;
    case SVt_PVCV:
	if (CvGV(sv))
	    Perl_sv_catpvf(aTHX_ t, " CV=\"(%s)\"", GvNAME(CvGV(sv)));
	else
	    sv_catpv(t, " CV=\"()\"");
	goto finish;
    case SVt_PVGV:
	sv_catpv(t, " GV=\"");
	break;
    case SVt_BIND:
	sv_catpv(t, " BIND=\"");
	break;
    case SVt_PVFM:
	sv_catpv(t, " FM=\"");
	break;
    case SVt_PVIO:
	sv_catpv(t, " IO=\"");
	break;
    }

    if (SvPOKp(sv)) {
	if (SvPVX(sv)) {
	    sv_catxmlsv(t, sv);
	}
    }
    else if (SvNOKp(sv)) {
	STORE_NUMERIC_LOCAL_SET_STANDARD();
	Perl_sv_catpvf(aTHX_ t, "%"NVgf"",SvNVX(sv));
	RESTORE_NUMERIC_LOCAL();
    }
    else if (SvIOKp(sv)) {
	if (SvIsUV(sv))
	    Perl_sv_catpvf(aTHX_ t, "%"UVuf"", (UV)SvUVX(sv));
	else
            Perl_sv_catpvf(aTHX_ t, "%"IVdf"", (IV)SvIVX(sv));
    }
    else
	sv_catpv(t, "");
    sv_catpv(t, "\"");

  finish:
    while (unref--)
	sv_catpv(t, ")");
    return SvPV(t, n_a);
}

void
Perl_do_pmop_xmldump(pTHX_ I32 level, PerlIO *file, const PMOP *pm)
{
    if (!pm) {
	Perl_xmldump_indent(aTHX_ level, file, "<pmop/>\n");
	return;
    }
    Perl_xmldump_indent(aTHX_ level, file, "<pmop \n");
    level++;
    if (PM_GETRE(pm)) {
	const regexp *const r = PM_GETRE(pm);
	SV * const tmpsv = newSVpvn(r->precomp,r->prelen);
	SvUTF8_on(tmpsv);
	Perl_xmldump_indent(aTHX_ level, file, "pre=\"%s\"\n",
	     SvPVX(tmpsv));
	SvREFCNT_dec(tmpsv);
	Perl_xmldump_indent(aTHX_ level, file, "when=\"%s\"\n",
	     (pm->op_private & OPpRUNTIME) ? "RUN" : "COMP");
    }
    else
	Perl_xmldump_indent(aTHX_ level, file, "pre=\"\" when=\"RUN\"\n");
    if (pm->op_pmflags || (PM_GETRE(pm) && PM_GETRE(pm)->check_substr)) {
	SV * const tmpsv = pm_description(pm);
	Perl_xmldump_indent(aTHX_ level, file, "pmflags=\"%s\"\n", SvCUR(tmpsv) ? SvPVX(tmpsv) + 1 : "");
	SvREFCNT_dec(tmpsv);
    }

    level--;
    if (pm->op_type != OP_PUSHRE && pm->op_pmreplrootu.op_pmreplroot) {
	Perl_xmldump_indent(aTHX_ level, file, ">\n");
	Perl_xmldump_indent(aTHX_ level+1, file, "<pm_repl>\n");
	do_op_xmldump(level+2, file, pm->op_pmreplrootu.op_pmreplroot);
	Perl_xmldump_indent(aTHX_ level+1, file, "</pm_repl>\n");
	Perl_xmldump_indent(aTHX_ level, file, "</pmop>\n");
    }
    else
	Perl_xmldump_indent(aTHX_ level, file, "/>\n");
}

void
Perl_pmop_xmldump(pTHX_ const PMOP *pm)
{
    do_pmop_xmldump(0, PL_xmlfp, pm);
}

void
Perl_do_op_xmldump(pTHX_ I32 level, PerlIO *file, const OP *o)
{
    UV      seq;
    int     contents = 0;
    if (!o)
	return;
    sequence(o);
    seq = sequence_num(o);
    Perl_xmldump_indent(aTHX_ level, file,
	"<op_%s seq=\"%"UVuf" -> ",
	     OP_NAME(o),
	              seq);
    level++;
    if (o->op_next)
	PerlIO_printf(file, seq ? "%"UVuf"\"" : "(%"UVuf")\"",
		      sequence_num(o->op_next));
    else
	PerlIO_printf(file, "DONE\"");

    if (o->op_targ) {
	if (o->op_type == OP_NULL)
	{
	    PerlIO_printf(file, " was=\"%s\"", PL_op_name[o->op_targ]);
	    if (o->op_targ == OP_NEXTSTATE)
	    {
		if (CopLINE(cCOPo))
		    PerlIO_printf(file, " line=\"%"UVuf"\"",
				     (UV)CopLINE(cCOPo));
		if (CopSTASHPV(cCOPo))
		    PerlIO_printf(file, " package=\"%s\"",
				     CopSTASHPV(cCOPo));
		if (cCOPo->cop_label)
		    PerlIO_printf(file, " label=\"%s\"",
				     cCOPo->cop_label);
	    }
	}
	else
	    PerlIO_printf(file, " targ=\"%ld\"", (long)o->op_targ);
    }
#ifdef DUMPADDR
    PerlIO_printf(file, " addr=\"0x%"UVxf" => 0x%"UVxf"\"", (UV)o, (UV)o->op_next);
#endif
    if (o->op_flags) {
	SV * const tmpsv = newSVpvn("", 0);
	switch (o->op_flags & OPf_WANT) {
	case OPf_WANT_VOID:
	    sv_catpv(tmpsv, ",VOID");
	    break;
	case OPf_WANT_SCALAR:
	    sv_catpv(tmpsv, ",SCALAR");
	    break;
	case OPf_WANT_LIST:
	    sv_catpv(tmpsv, ",LIST");
	    break;
	default:
	    sv_catpv(tmpsv, ",UNKNOWN");
	    break;
	}
	if (o->op_flags & OPf_KIDS)
	    sv_catpv(tmpsv, ",KIDS");
	if (o->op_flags & OPf_PARENS)
	    sv_catpv(tmpsv, ",PARENS");
	if (o->op_flags & OPf_STACKED)
	    sv_catpv(tmpsv, ",STACKED");
	if (o->op_flags & OPf_REF)
	    sv_catpv(tmpsv, ",REF");
	if (o->op_flags & OPf_MOD)
	    sv_catpv(tmpsv, ",MOD");
	if (o->op_flags & OPf_SPECIAL)
	    sv_catpv(tmpsv, ",SPECIAL");
	PerlIO_printf(file, " flags=\"%s\"", SvCUR(tmpsv) ? SvPVX(tmpsv) + 1 : "");
	SvREFCNT_dec(tmpsv);
    }
    if (o->op_private) {
	SV * const tmpsv = newSVpvn("", 0);
	if (PL_opargs[o->op_type] & OA_TARGLEX) {
	    if (o->op_private & OPpTARGET_MY)
		sv_catpv(tmpsv, ",TARGET_MY");
	}
	else if (o->op_type == OP_LEAVESUB ||
		 o->op_type == OP_LEAVE ||
		 o->op_type == OP_LEAVESUBLV ||
		 o->op_type == OP_LEAVEWRITE) {
	    if (o->op_private & OPpREFCOUNTED)
		sv_catpv(tmpsv, ",REFCOUNTED");
	}
        else if (o->op_type == OP_AASSIGN) {
	    if (o->op_private & OPpASSIGN_COMMON)
		sv_catpv(tmpsv, ",COMMON");
	}
	else if (o->op_type == OP_SASSIGN) {
	    if (o->op_private & OPpASSIGN_BACKWARDS)
		sv_catpv(tmpsv, ",BACKWARDS");
	}
	else if (o->op_type == OP_TRANS) {
	    if (o->op_private & OPpTRANS_SQUASH)
		sv_catpv(tmpsv, ",SQUASH");
	    if (o->op_private & OPpTRANS_DELETE)
		sv_catpv(tmpsv, ",DELETE");
	    if (o->op_private & OPpTRANS_COMPLEMENT)
		sv_catpv(tmpsv, ",COMPLEMENT");
	    if (o->op_private & OPpTRANS_IDENTICAL)
		sv_catpv(tmpsv, ",IDENTICAL");
	    if (o->op_private & OPpTRANS_GROWS)
		sv_catpv(tmpsv, ",GROWS");
	}
	else if (o->op_type == OP_REPEAT) {
	    if (o->op_private & OPpREPEAT_DOLIST)
		sv_catpv(tmpsv, ",DOLIST");
	}
	else if (o->op_type == OP_ENTERSUB ||
		 o->op_type == OP_RV2SV ||
		 o->op_type == OP_GVSV ||
		 o->op_type == OP_RV2AV ||
		 o->op_type == OP_RV2HV ||
		 o->op_type == OP_RV2GV ||
		 o->op_type == OP_AELEM ||
		 o->op_type == OP_HELEM )
	{
	    if (o->op_type == OP_ENTERSUB) {
		if (o->op_private & OPpENTERSUB_AMPER)
		    sv_catpv(tmpsv, ",AMPER");
		if (o->op_private & OPpENTERSUB_DB)
		    sv_catpv(tmpsv, ",DB");
		if (o->op_private & OPpENTERSUB_HASTARG)
		    sv_catpv(tmpsv, ",HASTARG");
		if (o->op_private & OPpENTERSUB_NOPAREN)
		    sv_catpv(tmpsv, ",NOPAREN");
		if (o->op_private & OPpENTERSUB_INARGS)
		    sv_catpv(tmpsv, ",INARGS");
		if (o->op_private & OPpENTERSUB_NOMOD)
		    sv_catpv(tmpsv, ",NOMOD");
	    }
	    else {
		switch (o->op_private & OPpDEREF) {
	    case OPpDEREF_SV:
		sv_catpv(tmpsv, ",SV");
		break;
	    case OPpDEREF_AV:
		sv_catpv(tmpsv, ",AV");
		break;
	    case OPpDEREF_HV:
		sv_catpv(tmpsv, ",HV");
		break;
	    }
		if (o->op_private & OPpMAYBE_LVSUB)
		    sv_catpv(tmpsv, ",MAYBE_LVSUB");
	    }
	    if (o->op_type == OP_AELEM || o->op_type == OP_HELEM) {
		if (o->op_private & OPpLVAL_DEFER)
		    sv_catpv(tmpsv, ",LVAL_DEFER");
	    }
	    else {
		if (o->op_private & HINT_STRICT_REFS)
		    sv_catpv(tmpsv, ",STRICT_REFS");
		if (o->op_private & OPpOUR_INTRO)
		    sv_catpv(tmpsv, ",OUR_INTRO");
	    }
	}
	else if (o->op_type == OP_CONST) {
	    if (o->op_private & OPpCONST_BARE)
		sv_catpv(tmpsv, ",BARE");
	    if (o->op_private & OPpCONST_STRICT)
		sv_catpv(tmpsv, ",STRICT");
	    if (o->op_private & OPpCONST_ARYBASE)
		sv_catpv(tmpsv, ",ARYBASE");
	    if (o->op_private & OPpCONST_WARNING)
		sv_catpv(tmpsv, ",WARNING");
	    if (o->op_private & OPpCONST_ENTERED)
		sv_catpv(tmpsv, ",ENTERED");
	}
	else if (o->op_type == OP_FLIP) {
	    if (o->op_private & OPpFLIP_LINENUM)
		sv_catpv(tmpsv, ",LINENUM");
	}
	else if (o->op_type == OP_FLOP) {
	    if (o->op_private & OPpFLIP_LINENUM)
		sv_catpv(tmpsv, ",LINENUM");
	}
	else if (o->op_type == OP_RV2CV) {
	    if (o->op_private & OPpLVAL_INTRO)
		sv_catpv(tmpsv, ",INTRO");
	}
	else if (o->op_type == OP_GV) {
	    if (o->op_private & OPpEARLY_CV)
		sv_catpv(tmpsv, ",EARLY_CV");
	}
	else if (o->op_type == OP_LIST) {
	    if (o->op_private & OPpLIST_GUESSED)
		sv_catpv(tmpsv, ",GUESSED");
	}
	else if (o->op_type == OP_DELETE) {
	    if (o->op_private & OPpSLICE)
		sv_catpv(tmpsv, ",SLICE");
	}
	else if (o->op_type == OP_EXISTS) {
	    if (o->op_private & OPpEXISTS_SUB)
		sv_catpv(tmpsv, ",EXISTS_SUB");
	}
	else if (o->op_type == OP_SORT) {
	    if (o->op_private & OPpSORT_NUMERIC)
		sv_catpv(tmpsv, ",NUMERIC");
	    if (o->op_private & OPpSORT_INTEGER)
		sv_catpv(tmpsv, ",INTEGER");
	    if (o->op_private & OPpSORT_REVERSE)
		sv_catpv(tmpsv, ",REVERSE");
	}
	else if (o->op_type == OP_OPEN || o->op_type == OP_BACKTICK) {
	    if (o->op_private & OPpOPEN_IN_RAW)
		sv_catpv(tmpsv, ",IN_RAW");
	    if (o->op_private & OPpOPEN_IN_CRLF)
		sv_catpv(tmpsv, ",IN_CRLF");
	    if (o->op_private & OPpOPEN_OUT_RAW)
		sv_catpv(tmpsv, ",OUT_RAW");
	    if (o->op_private & OPpOPEN_OUT_CRLF)
		sv_catpv(tmpsv, ",OUT_CRLF");
	}
	else if (o->op_type == OP_EXIT) {
	    if (o->op_private & OPpEXIT_VMSISH)
		sv_catpv(tmpsv, ",EXIT_VMSISH");
	    if (o->op_private & OPpHUSH_VMSISH)
		sv_catpv(tmpsv, ",HUSH_VMSISH");
	}
	else if (o->op_type == OP_DIE) {
	    if (o->op_private & OPpHUSH_VMSISH)
		sv_catpv(tmpsv, ",HUSH_VMSISH");
	}
	else if (PL_check[o->op_type] != MEMBER_TO_FPTR(Perl_ck_ftst)) {
	    if (OP_IS_FILETEST_ACCESS(o) && o->op_private & OPpFT_ACCESS)
		sv_catpv(tmpsv, ",FT_ACCESS");
	    if (o->op_private & OPpFT_STACKED)
		sv_catpv(tmpsv, ",FT_STACKED");
	}
	if (o->op_flags & OPf_MOD && o->op_private & OPpLVAL_INTRO)
	    sv_catpv(tmpsv, ",INTRO");
	if (SvCUR(tmpsv))
	    S_xmldump_attr(aTHX_ level, file, "private=\"%s\"", SvPVX(tmpsv) + 1);
	SvREFCNT_dec(tmpsv);
    }

    switch (o->op_type) {
    case OP_AELEMFAST:
	if (o->op_flags & OPf_SPECIAL) {
	    break;
	}
    case OP_GVSV:
    case OP_GV:
#ifdef USE_ITHREADS
	S_xmldump_attr(aTHX_ level, file, "padix=\"%" IVdf "\"", (IV)cPADOPo->op_padix);
#else
	if (cSVOPo->op_sv) {
	    SV * const tmpsv1 = newSV(0);
	    SV * const tmpsv2 = newSVpvn("",0);
	    char *s;
	    STRLEN len;
	    SvUTF8_on(tmpsv1);
	    SvUTF8_on(tmpsv2);
	    ENTER;
	    SAVEFREESV(tmpsv1);
	    SAVEFREESV(tmpsv2);
	    gv_fullname3(tmpsv1, (GV*)cSVOPo->op_sv, NULL);
	    s = SvPV(tmpsv1,len);
	    sv_catxmlpvn(tmpsv2, s, len, 1);
	    S_xmldump_attr(aTHX_ level, file, "gv=\"%s\"", SvPV(tmpsv2, len));
	    LEAVE;
	}
	else
	    S_xmldump_attr(aTHX_ level, file, "gv=\"NULL\"");
#endif
	break;
    case OP_CONST:
    case OP_METHOD_NAMED:
#ifndef USE_ITHREADS
	/* with ITHREADS, consts are stored in the pad, and the right pad
	 * may not be active here, so skip */
	S_xmldump_attr(aTHX_ level, file, "%s", sv_xmlpeek(cSVOPo_sv));
#endif
	break;
    case OP_ANONCODE:
	if (!contents) {
	    contents = 1;
	    PerlIO_printf(file, ">\n");
	}
	do_op_xmldump(level+1, file, CvROOT(cSVOPo_sv));
	break;
    case OP_SETSTATE:
    case OP_NEXTSTATE:
    case OP_DBSTATE:
	if (CopLINE(cCOPo))
	    S_xmldump_attr(aTHX_ level, file, "line=\"%"UVuf"\"",
			     (UV)CopLINE(cCOPo));
	if (CopSTASHPV(cCOPo))
	    S_xmldump_attr(aTHX_ level, file, "package=\"%s\"",
			     CopSTASHPV(cCOPo));
	if (cCOPo->cop_label)
	    S_xmldump_attr(aTHX_ level, file, "label=\"%s\"",
			     cCOPo->cop_label);
	break;
    case OP_ENTERLOOP:
	S_xmldump_attr(aTHX_ level, file, "redo=\"");
	if (cLOOPo->op_redoop)
	    PerlIO_printf(file, "%"UVuf"\"", sequence_num(cLOOPo->op_redoop));
	else
	    PerlIO_printf(file, "DONE\"");
	S_xmldump_attr(aTHX_ level, file, "next=\"");
	if (cLOOPo->op_nextop)
	    PerlIO_printf(file, "%"UVuf"\"", sequence_num(cLOOPo->op_nextop));
	else
	    PerlIO_printf(file, "DONE\"");
	S_xmldump_attr(aTHX_ level, file, "last=\"");
	if (cLOOPo->op_lastop)
	    PerlIO_printf(file, "%"UVuf"\"", sequence_num(cLOOPo->op_lastop));
	else
	    PerlIO_printf(file, "DONE\"");
	break;
    case OP_COND_EXPR:
    case OP_RANGE:
    case OP_MAPWHILE:
    case OP_GREPWHILE:
    case OP_OR:
    case OP_AND:
	S_xmldump_attr(aTHX_ level, file, "other=\"");
	if (cLOGOPo->op_other)
	    PerlIO_printf(file, "%"UVuf"\"", sequence_num(cLOGOPo->op_other));
	else
	    PerlIO_printf(file, "DONE\"");
	break;
    case OP_LEAVE:
    case OP_LEAVEEVAL:
    case OP_LEAVESUB:
    case OP_LEAVESUBLV:
    case OP_LEAVEWRITE:
    case OP_SCOPE:
	if (o->op_private & OPpREFCOUNTED)
	    S_xmldump_attr(aTHX_ level, file, "refcnt=\"%"UVuf"\"", (UV)o->op_targ);
	break;
    default:
	break;
    }

    if (PL_madskills && o->op_madprop) {
	char prevkey = '\0';
	SV * const tmpsv = newSVpvn("", 0);
	const MADPROP* mp = o->op_madprop;

	sv_utf8_upgrade(tmpsv);
	if (!contents) {
	    contents = 1;
	    PerlIO_printf(file, ">\n");
	}
	Perl_xmldump_indent(aTHX_ level, file, "<madprops>\n");
	level++;
	while (mp) {
	    char tmp = mp->mad_key;
	    sv_setpvn(tmpsv,"\"",1);
	    if (tmp)
		sv_catxmlpvn(tmpsv, &tmp, 1, 0);
	    if ((tmp == '_') || (tmp == '#')) /* '_' '#' whitespace belong to the previous token. */
		sv_catxmlpvn(tmpsv, &prevkey, 1, 0);
	    else
		prevkey = tmp;
	    sv_catpv(tmpsv, "\"");
	    switch (mp->mad_type) {
	    case MAD_NULL:
		sv_catpv(tmpsv, "NULL");
		Perl_xmldump_indent(aTHX_ level, file, "<mad_null key=%s/>\n", SvPVX(tmpsv));
		break;
	    case MAD_PV:
		sv_catpv(tmpsv, " val=\"");
		sv_catxmlpvn(tmpsv, (char*)mp->mad_val, mp->mad_vlen,1);
		sv_catpv(tmpsv, "\"");
		Perl_xmldump_indent(aTHX_ level, file, "<mad_pv key=%s/>\n", SvPVX(tmpsv));
		break;
	    case MAD_SV:
		sv_catpv(tmpsv, " val=\"");
		sv_catxmlsv(tmpsv, (SV*)mp->mad_val);
		sv_catpv(tmpsv, "\"");
		Perl_xmldump_indent(aTHX_ level, file, "<mad_sv key=%s/>\n", SvPVX(tmpsv));
		break;
	    case MAD_OP:
		if ((OP*)mp->mad_val) {
		    Perl_xmldump_indent(aTHX_ level, file, "<mad_op key=%s>\n", SvPVX(tmpsv));
		    do_op_xmldump(level+1, file, (OP*)mp->mad_val);
		    Perl_xmldump_indent(aTHX_ level, file, "</mad_op>\n");
		}
		break;
	    default:
		Perl_xmldump_indent(aTHX_ level, file, "<mad_unk key=%s/>\n", SvPVX(tmpsv));
		break;
	    }
	    mp = mp->mad_next;
	}
	level--;
	Perl_xmldump_indent(aTHX_ level, file, "</madprops>\n");

	SvREFCNT_dec(tmpsv);
    }

    switch (o->op_type) {
    case OP_PUSHRE:
    case OP_MATCH:
    case OP_QR:
    case OP_SUBST:
	if (!contents) {
	    contents = 1;
	    PerlIO_printf(file, ">\n");
	}
	do_pmop_xmldump(level, file, cPMOPo);
	break;
    default:
	break;
    }

    if (o->op_flags & OPf_KIDS) {
	OP *kid;
	if (!contents) {
	    contents = 1;
	    PerlIO_printf(file, ">\n");
	}
	for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling)
	    do_op_xmldump(level, file, kid);
    }

    if (contents)
	Perl_xmldump_indent(aTHX_ level-1, file, "</op_%s>\n", OP_NAME(o));
    else
	PerlIO_printf(file, " />\n");
}

void
Perl_op_xmldump(pTHX_ const OP *o)
{
    do_op_xmldump(0, PL_xmlfp, o);
}
#endif
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d12 2
a13 4
 *  'You have talked long in your sleep, Frodo,' said Gandalf gently, 'and
 *   it has not been hard for me to read your mind and memory.'
 *
 *     [p.220 of _The Lord of the Rings_, II/i: "Many Meetings"]
a74 1
    PERL_ARGS_ASSERT_DUMP_INDENT;
a83 1
    PERL_ARGS_ASSERT_DUMP_VINDENT;
a103 2
    PERL_ARGS_ASSERT_DUMP_PACKSUBS;

d109 1
a109 1
	    const GV * const gv = (const GV *)HeVAL(entry);
a129 2
    PERL_ARGS_ASSERT_DUMP_SUB;

a146 2
    PERL_ARGS_ASSERT_DUMP_FORM;

d164 3
a166 1
=for apidoc pv_escape
a221 2
    PERL_ARGS_ASSERT_PV_ESCAPE;

d224 1
a224 1
	    sv_setpvs(dsv, "");
d301 4
a304 1
=for apidoc pv_pretty
d335 1
a335 3
 
    PERL_ARGS_ASSERT_PV_PRETTY;
   
d338 1
a338 1
	    sv_setpvs(dsv, "");
d342 1
a342 1
        sv_catpvs(dsv, "\"");
d344 1
a344 1
        sv_catpvs(dsv, "<");
d347 1
a347 1
        sv_catpv(dsv, start_color);
d352 1
a352 1
        sv_catpv(dsv, end_color);
d355 1
a355 1
	sv_catpvs( dsv, "\"");
d357 1
a357 1
        sv_catpvs(dsv, ">");         
d360 1
a360 1
	    sv_catpvs(dsv, "...");
d368 3
a385 2
    PERL_ARGS_ASSERT_PV_DISPLAY;

d388 1
a388 1
            sv_catpvs( dsv, "\\0");
d400 1
a400 1
    sv_setpvs(t, "");
d406 1
a406 1
    else if (sv == (const SV *)0x55555555 || SvTYPE(sv) == 'U') {
d477 1
a477 1
	sv = SvRV(sv);
a526 2
    if (PL_tainting && SvTAINTED(sv))
	sv_catpv(t, " [tainted]");
a534 2
    PERL_ARGS_ASSERT_DO_PMOP_DUMP;

d547 1
a547 1
	     ch, RX_PRECOMP(PM_GETRE(pm)), ch,
d555 1
a555 1
    if (pm->op_pmflags || (PM_GETRE(pm) && RX_CHECK_SUBSTR(PM_GETRE(pm)))) {
a570 2
    PERL_ARGS_ASSERT_PM_DESCRIPTION;

d582 1
a582 1
        if (RX_EXTFLAGS(regex) & RXf_TAINTED)
d584 2
a585 2
        if (RX_CHECK_SUBSTR(regex)) {
            if (!(RX_EXTFLAGS(regex) & RXf_NOSCAN))
d587 1
a587 1
            if (RX_EXTFLAGS(regex) & RXf_CHECK_ALL)
d590 1
a590 1
        if (RX_EXTFLAGS(regex) & RXf_SKIPWHITE)
a735 2
    PERL_ARGS_ASSERT_DO_OP_DUMP;

d762 1
a762 1
		if (CopLABEL(cCOPo))
d764 1
a764 1
				     CopLABEL(cCOPo));
d979 1
a979 1
	SV * const tmpsv = newSVpvs("");
d985 1
a985 1
	    sv_setpvs(tmpsv,"'");
d1027 1
a1027 1
	if ( ! (o->op_flags & OPf_SPECIAL)) { /* not lexical */
d1037 1
a1037 1
		gv_fullname3(tmpsv, MUTABLE_GV(cSVOPo->op_sv), NULL);
d1064 1
a1064 1
	if (CopLABEL(cCOPo))
d1066 1
a1066 1
			     CopLABEL(cCOPo));
a1125 1
    PERL_ARGS_ASSERT_OP_DUMP;
a1133 2
    PERL_ARGS_ASSERT_GV_DUMP;

d1191 1
a1191 1
	{ PERL_MAGIC_uvar_elem,      "uvar_elem(u)" },
a1204 2
    PERL_ARGS_ASSERT_DO_MAGIC_DUMP;

d1286 1
a1286 1
		REGEXP* const re = (REGEXP *)mg->mg_obj;
d1288 1
a1288 2
                const char * const s
		    = pv_pretty(dsv, RX_WRAPPED(re), RX_WRAPLEN(re), 
d1291 1
a1291 1
                    (RX_UTF8(re) ? PERL_PV_ESCAPE_UNI : 0))
d1295 1
a1295 1
			(IV)RX_REFCNT(re));
d1313 1
a1313 2
		do_sv_dump(level+2, file, MUTABLE_SV(((mg)->mg_ptr)), nest+1,
			   maxnest, dumpops, pvlim); /* MG is already +1 */
a1344 3

    PERL_ARGS_ASSERT_DO_HV_DUMP;

a1354 2
    PERL_ARGS_ASSERT_DO_GV_DUMP;

a1364 2
    PERL_ARGS_ASSERT_DO_GVGV_DUMP;

a1385 2
    PERL_ARGS_ASSERT_DO_SV_DUMP;

d1578 1
a1578 1
    if ((type <= SVt_PVLV && !isGV_with_GP(sv)) || type == SVt_PVFM) {
d1617 1
a1617 1
	sv_setpvs(d, "");
d1622 1
a1622 1
	if (nest < maxnest && av_len(MUTABLE_AV(sv)) >= 0) {
d1624 2
a1625 2
	    for (count = 0; count <=  av_len(MUTABLE_AV(sv)) && count < maxnest; count++) {
		SV** const elt = av_fetch(MUTABLE_AV(sv),count,0);
d1706 1
a1706 2
	    AV * const backrefs
		= *Perl_hv_backreferences_p(aTHX_ MUTABLE_HV(sv));
d1710 1
a1710 1
		do_sv_dump(level+1, file, MUTABLE_SV(backrefs), nest+1, maxnest,
d1716 1
a1716 1
	    HV * const hv = MUTABLE_HV(sv);
d1779 1
a1779 2
	if (type == SVt_PVCV)
	    Perl_dump_indent(aTHX_ level, file, "  DEPTH = %"IVdf"\n", (IV)CvDEPTH(sv));
d1799 1
a1799 1
	    do_sv_dump(level+1, file, MUTABLE_SV(CvOUTSIDE(sv)), nest+1, maxnest, dumpops, pvlim);
d1854 2
a1855 2
	    do_sv_dump (level+1, file, MUTABLE_SV(IoTOP_GV(sv)), nest+1,
			maxnest, dumpops, pvlim);
d1866 2
a1867 2
	    do_sv_dump (level+1, file, MUTABLE_SV(IoFMT_GV(sv)), nest+1,
			maxnest, dumpops, pvlim);
d1876 2
a1877 2
	    do_sv_dump (level+1, file, MUTABLE_SV(IoBOTTOM_GV(sv)), nest+1,
			maxnest, dumpops, pvlim);
a1892 3

    PERL_ARGS_ASSERT_SV_DUMP;

a1941 3

    PERL_ARGS_ASSERT_DEBOP;

d1948 1
a1948 8
	/* With ITHREADS, consts are stored in the pad, and the right pad
	 * may not be active here, so check.
	 * Looks like only during compiling the pads are illegal.
	 */
#ifdef USE_ITHREADS
	if ((((SVOP*)o)->op_sv) || !IN_PERL_COMPILETIME)
#endif
	    PerlIO_printf(Perl_debug_log, "(%s)", SvPEEK(cSVOPo_sv));
d1975 1
a1975 1
            AV * const comppad = MUTABLE_AV(*av_fetch(padlist, 0, FALSE));
a2012 3

    PERL_ARGS_ASSERT_WATCH;

a2022 3

    PERL_ARGS_ASSERT_DEBPROF;

a2053 3

    PERL_ARGS_ASSERT_XMLDUMP_ATTR;

a2064 1
    PERL_ARGS_ASSERT_XMLDUMP_INDENT;
a2072 2
    PERL_ARGS_ASSERT_XMLDUMP_VINDENT;

a2093 2
    PERL_ARGS_ASSERT_XMLDUMP_PACKSUBS;

d2098 1
a2098 1
	    GV *gv = MUTABLE_GV(HeVAL(entry));
a2117 2
    PERL_ARGS_ASSERT_XMLDUMP_SUB;

a2134 2
    PERL_ARGS_ASSERT_XMLDUMP_FORM;

a2151 1
    PERL_ARGS_ASSERT_SV_CATXMLSV;
d2164 1
a2164 3
    PERL_ARGS_ASSERT_SV_CATXMLPVN;

    sv_catpvs(dsv,"");
a2286 2
    PERL_ARGS_ASSERT_SV_XMLPEEK;

d2288 1
a2288 1
    sv_setpvs(t, "");
d2294 1
a2294 1
    else if (sv == (const SV *)0x55555555 || SvTYPE(sv) == 'U') {
a2446 2
    PERL_ARGS_ASSERT_DO_PMOP_XMLDUMP;

d2454 3
a2456 4
	REGEXP *const r = PM_GETRE(pm);
	SV * const tmpsv
	    = newSVpvn_utf8(RX_PRECOMP(r), RX_PRELEN(r), RX_UTF8(r));
	sv_utf8_upgrade(tmpsv);
d2465 1
a2465 1
    if (pm->op_pmflags || (PM_GETRE(pm) && RX_CHECK_SUBSTR(PM_GETRE(pm)))) {
a2493 3

    PERL_ARGS_ASSERT_DO_OP_XMLDUMP;

d2521 1
a2521 1
		if (CopLABEL(cCOPo))
d2523 1
a2523 1
				     CopLABEL(cCOPo));
d2533 1
a2533 1
	SV * const tmpsv = newSVpvs("");
d2564 1
a2564 1
	SV * const tmpsv = newSVpvs("");
d2741 2
a2742 2
	    SV * const tmpsv1 = newSVpvn_utf8(NULL, 0, TRUE);
	    SV * const tmpsv2 = newSVpvn_utf8("", 0, TRUE);
d2745 2
d2750 1
a2750 1
	    gv_fullname3(tmpsv1, MUTABLE_GV(cSVOPo->op_sv), NULL);
d2784 1
a2784 1
	if (CopLABEL(cCOPo))
d2786 1
a2786 1
			     CopLABEL(cCOPo));
d2832 1
a2832 1
	SV * const tmpsv = newSVpvn_utf8("", 0, TRUE);
d2835 1
d2844 1
a2844 1
	    sv_setpvs(tmpsv,"\"");
d2865 1
a2865 1
		sv_catxmlsv(tmpsv, MUTABLE_SV(mp->mad_val));
a2921 2
    PERL_ARGS_ASSERT_OP_XMLDUMP;

@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d37 1
a41 1
    "REGEXP",
d57 1
a61 1
    "REGEXP",
a94 7
    dump_all_perl(FALSE);
}

void
Perl_dump_all_perl(pTHX_ bool justperl)
{

d99 1
a99 1
    dump_packsubs_perl(PL_defstash, justperl);
a104 7
    PERL_ARGS_ASSERT_DUMP_PACKSUBS;
    dump_packsubs_perl(stash, FALSE);
}

void
Perl_dump_packsubs_perl(pTHX_ const HV *stash, bool justperl)
{
d108 1
a108 1
    PERL_ARGS_ASSERT_DUMP_PACKSUBS_PERL;
d119 1
a119 1
		dump_sub_perl(gv, justperl);
d125 1
a125 1
		    dump_packsubs_perl(hv, justperl); /* nested package */
d134 2
a136 2
    dump_sub_perl(gv, FALSE);
}
a137 11
void
Perl_dump_sub_perl(pTHX_ const GV *gv, bool justperl)
{
    SV * sv;

    PERL_ARGS_ASSERT_DUMP_SUB_PERL;

    if (justperl && (CvISXSUB(GvCV(gv)) || !CvROOT(GvCV(gv))))
	return;

    sv = sv_newmortal();
d508 2
a509 5
	    if (SvOOK(sv)) {
		STRLEN delta;
		SvOOK_offset(sv, delta);
		Perl_sv_catpvf(aTHX_ t, "[%s]", pv_display(tmp, SvPVX_const(sv)-delta, delta, 0, 127));
	    }
d981 1
a981 1
	    if (OP_IS_FILETEST_ACCESS(o->op_type) && o->op_private & OPpFT_ACCESS)
a1063 1
    case OP_HINTSEVAL:
d1071 1
a1260 1
            else if (v == &PL_vtbl_hints)      s = "hints";
d1480 1
d1495 1
d1542 1
a1542 2
    Perl_dump_indent(aTHX_ level, file,
	"ALLOCATED at %s:%d %s %s%s; serial %"UVuf"\n",
d1547 1
a1547 3
	sv->sv_debug_cloned ? " (cloned)" : "",
	sv->sv_debug_serial
    );
d1563 2
a1564 3
	 && type != SVt_PVCV && !isGV_with_GP(sv) && type != SVt_PVFM
	 && type != SVt_PVIO)
	|| (type == SVt_IV && !SvROK(sv))) {
d1573 2
d1589 2
a1590 2
		&& type != SVt_PVCV && type != SVt_PVFM  && type != SVt_REGEXP
		&& type != SVt_PVIO && !isGV_with_GP(sv) && !SvVALID(sv))
a1611 8
	    STRLEN delta;
	    if (SvOOK(sv)) {
		SvOOK_offset(sv, delta);
		Perl_dump_indent(aTHX_ level, file,"  OFFSET = %"UVuf"\n",
				 (UV) delta);
	    } else {
		delta = 0;
	    }
d1613 2
a1614 5
	    if (SvOOK(sv)) {
		PerlIO_printf(file, "( %s . ) ",
			      pv_display(d, SvPVX_const(sv) - delta, delta, 0,
					 pvlim));
	    }
a1624 6
    if (type == SVt_REGEXP) {
	/* FIXME dumping
	    Perl_dump_indent(aTHX_ level, file, "  REGEXP = 0x%"UVxf"\n",
			     PTR2UV(((struct regexp *)SvANY(sv))->xrx_regexp));
	*/
    }
a1739 1
	    struct mro_meta * const meta = HvAUX(sv)->xhv_mro_meta;
a1745 35
	    if (meta) {
		/* FIXME - mro_algs kflags can signal a UTF-8 name.  */
		Perl_dump_indent(aTHX_ level, file, "  MRO_WHICH = \"%.*s\" (0x%"UVxf")\n",
				 (int)meta->mro_which->length,
				 meta->mro_which->name,
				 PTR2UV(meta->mro_which));
		Perl_dump_indent(aTHX_ level, file, "  CACHE_GEN = 0x%"UVxf"\n",
				 (UV)meta->cache_gen);
		Perl_dump_indent(aTHX_ level, file, "  PKG_GEN = 0x%"UVxf"\n",
				 (UV)meta->pkg_gen);
		if (meta->mro_linear_all) {
		    Perl_dump_indent(aTHX_ level, file, "  MRO_LINEAR_ALL = 0x%"UVxf"\n",
				 PTR2UV(meta->mro_linear_all));
		do_sv_dump(level+1, file, MUTABLE_SV(meta->mro_linear_all), nest+1, maxnest,
			   dumpops, pvlim);
		}
		if (meta->mro_linear_current) {
		    Perl_dump_indent(aTHX_ level, file, "  MRO_LINEAR_CURRENT = 0x%"UVxf"\n",
				 PTR2UV(meta->mro_linear_current));
		do_sv_dump(level+1, file, MUTABLE_SV(meta->mro_linear_current), nest+1, maxnest,
			   dumpops, pvlim);
		}
		if (meta->mro_nextmethod) {
		    Perl_dump_indent(aTHX_ level, file, "  MRO_NEXTMETHOD = 0x%"UVxf"\n",
				 PTR2UV(meta->mro_nextmethod));
		do_sv_dump(level+1, file, MUTABLE_SV(meta->mro_nextmethod), nest+1, maxnest,
			   dumpops, pvlim);
		}
		if (meta->isa) {
		    Perl_dump_indent(aTHX_ level, file, "  ISA = 0x%"UVxf"\n",
				 PTR2UV(meta->isa));
		do_sv_dump(level+1, file, MUTABLE_SV(meta->isa), nest+1, maxnest,
			   dumpops, pvlim);
		}
	    }
d1795 1
a1795 1
	    SV * const constant = cv_const_sv((const CV *)sv);
d1941 2
a1942 1
	Perl_ck_warner_d(aTHX_ packWARN(WARN_DEBUGGING), "NULL OP IN RUN");
a1987 1
    case OP_HINTSEVAL:
a2138 6
    xmldump_all_perl(FALSE);
}

void
Perl_xmldump_all_perl(pTHX_ bool justperl)
{
a2141 1
    xmldump_packsubs_perl(PL_defstash, justperl);
a2149 7
    PERL_ARGS_ASSERT_XMLDUMP_PACKSUBS;
    xmldump_packsubs_perl(stash, FALSE);
}

void
Perl_xmldump_packsubs_perl(pTHX_ const HV *stash, bool justperl)
{
d2153 1
a2153 1
    PERL_ARGS_ASSERT_XMLDUMP_PACKSUBS_PERL;
d2164 1
a2164 1
		xmldump_sub_perl(gv, justperl);
d2169 1
a2169 1
		xmldump_packsubs_perl(hv, justperl);	/* nested package */
d2177 2
a2179 12
    xmldump_sub_perl(gv, FALSE);
}

void
Perl_xmldump_sub_perl(pTHX_ const GV *gv, bool justperl)
{
    SV * sv;

    PERL_ARGS_ASSERT_XMLDUMP_SUB_PERL;

    if (justperl && (CvISXSUB(GvCV(gv)) || !CvROOT(GvCV(gv))))
	return;
a2180 1
    sv = sv_newmortal();
d2444 3
a2479 3
    case SVt_REGEXP:
	sv_catpv(t, " ORANGE=\"");
	break;
d2527 3
a2529 2
	SV * const tmpsv = newSVpvn_utf8("", 0, TRUE);
	sv_catxmlsv(tmpsv, MUTABLE_SV(r));
d2794 1
a2794 1
	    if (OP_IS_FILETEST_ACCESS(o->op_type) && o->op_private & OPpFT_ACCESS)
a2834 1
    case OP_HINTSEVAL:
d2849 1
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d71 1
a71 19
struct flag_to_name {
    U32 flag;
    const char *name;
};

static void
S_append_flags(pTHX_ SV *sv, U32 flags, const struct flag_to_name *start,
	       const struct flag_to_name *const end)
{
    do {
	if (flags & start->flag)
	    sv_catpv(sv, start->name);
    } while (++start < end);
}

#define append_flags(sv, f, flags) \
    S_append_flags(aTHX_ (sv), (f), (flags), C_ARRAY_END(flags))


d216 4
a219 5
using C<\x01F1> style escapes, otherwise if PERL_PV_ESCAPE_NONASCII is set, only
chars above 127 will be escaped using this style; otherwise, only chars above
255 will be so escaped; other non printable chars will use octal or
common escaped patterns like C<\n>. Otherwise, if PERL_PV_ESCAPE_NOBACKSLASH
then all chars below 255 will be treated as printable and
d223 5
a227 4
string will be escaped, regardless of max. If the output is to be in hex,
then it will be returned as a plain hex
sequence. Thus the output will either be a single char,
an octal escape sequence, a special escape like C<\n> or a hex value.
d266 1
a266 1
        const UV u= (isuni) ? utf8_to_uvchr_buf((U8*)pv, (U8*) end, &readsize) : (U8)*pv;
d269 1
a269 4
        if ( ( u > 255 )
	  || (flags & PERL_PV_ESCAPE_ALL)
	  || (( u > 127 ) && (flags & PERL_PV_ESCAPE_NONASCII)))
	{
d302 1
a302 1
                        if ( (pv+readsize < end) && isDIGIT((U8)*(pv+readsize)) )
d345 1
a345 1

d349 1
a349 1

d356 1
a356 1

a603 10
const struct flag_to_name pmflags_flags_names[] = {
    {PMf_CONST, ",CONST"},
    {PMf_KEEP, ",KEEP"},
    {PMf_GLOBAL, ",GLOBAL"},
    {PMf_CONTINUE, ",CONTINUE"},
    {PMf_RETAINT, ",RETAINT"},
    {PMf_EVAL, ",EVAL"},
    {PMf_NONDESTRUCT, ",NONDESTRUCT"},
};

d636 12
a647 1
    append_flags(desc, pmflags, pmflags_flags_names);
d657 1
a657 4
/* Return a unique integer to represent the address of op o.
 * If it already exists in PL_op_sequence, just return it;
 * otherwise add it.
 *  *** Note that this isn't thread-safe */
d659 2
a660 2
STATIC UV
S_sequence_num(pTHX_ const OP *o)
d663 2
a664 4
    SV     *op,
          **seq;
    const char *key;
    STRLEN  len;
d666 6
a671 12
	return 0;
    op = newSVuv(PTR2UV(o));
    sv_2mortal(op);
    key = SvPV_const(op, len);
    if (!PL_op_sequence)
	PL_op_sequence = newHV();
    seq = hv_fetch(PL_op_sequence, key, len, 0);
    if (seq)
	return SvUV(*seq);
    (void)hv_store(PL_op_sequence, key, len, newSVuv(++PL_op_seq), 0);
    return PL_op_seq;
}
d673 2
a674 8
const struct flag_to_name op_flags_names[] = {
    {OPf_KIDS, ",KIDS"},
    {OPf_PARENS, ",PARENS"},
    {OPf_REF, ",REF"},
    {OPf_MOD, ",MOD"},
    {OPf_STACKED, ",STACKED"},
    {OPf_SPECIAL, ",SPECIAL"}
};
d676 4
a679 9
const struct flag_to_name op_trans_names[] = {
    {OPpTRANS_FROM_UTF, ",FROM_UTF"},
    {OPpTRANS_TO_UTF, ",TO_UTF"},
    {OPpTRANS_IDENTICAL, ",IDENTICAL"},
    {OPpTRANS_SQUASH, ",SQUASH"},
    {OPpTRANS_COMPLEMENT, ",COMPLEMENT"},
    {OPpTRANS_GROWS, ",GROWS"},
    {OPpTRANS_DELETE, ",DELETE"}
};
d681 2
a682 7
const struct flag_to_name op_entersub_names[] = {
    {OPpENTERSUB_DB, ",DB"},
    {OPpENTERSUB_HASTARG, ",HASTARG"},
    {OPpENTERSUB_AMPER, ",AMPER"},
    {OPpENTERSUB_NOPAREN, ",NOPAREN"},
    {OPpENTERSUB_INARGS, ",INARGS"}
};
d684 23
a706 8
const struct flag_to_name op_const_names[] = {
    {OPpCONST_NOVER, ",NOVER"},
    {OPpCONST_SHORTCIRCUIT, ",SHORTCIRCUIT"},
    {OPpCONST_STRICT, ",STRICT"},
    {OPpCONST_ENTERED, ",ENTERED"},
    {OPpCONST_BARE, ",BARE"},
    {OPpCONST_WARNING, ",WARNING"}
};
d708 13
a720 9
const struct flag_to_name op_sort_names[] = {
    {OPpSORT_NUMERIC, ",NUMERIC"},
    {OPpSORT_INTEGER, ",INTEGER"},
    {OPpSORT_REVERSE, ",REVERSE"},
    {OPpSORT_INPLACE, ",INPLACE"},
    {OPpSORT_DESCEND, ",DESCEND"},
    {OPpSORT_QSORT, ",QSORT"},
    {OPpSORT_STABLE, ",STABLE"}
};
d722 7
a728 6
const struct flag_to_name op_open_names[] = {
    {OPpOPEN_IN_RAW, ",IN_RAW"},
    {OPpOPEN_IN_CRLF, ",IN_CRLF"},
    {OPpOPEN_OUT_RAW, ",OUT_RAW"},
    {OPpOPEN_OUT_CRLF, ",OUT_CRLF"}
};
d730 4
a733 4
const struct flag_to_name op_exit_names[] = {
    {OPpEXIT_VMSISH, ",EXIT_VMSISH"},
    {OPpHUSH_VMSISH, ",HUSH_VMSISH"}
};
d735 4
a738 23
#define OP_PRIVATE_ONCE(op, flag, name) \
    const struct flag_to_name CAT2(op, _names)[] = {	\
	{(flag), (name)} \
    }

OP_PRIVATE_ONCE(op_aassign, OPpASSIGN_COMMON, ",COMMON");
OP_PRIVATE_ONCE(op_leavesub, OPpREFCOUNTED, ",REFCOUNTED");
OP_PRIVATE_ONCE(op_sassign, OPpASSIGN_BACKWARDS, ",BACKWARDS");
OP_PRIVATE_ONCE(op_repeat, OPpREPEAT_DOLIST, ",DOLIST");
OP_PRIVATE_ONCE(op_reverse, OPpREVERSE_INPLACE, ",INPLACE");
OP_PRIVATE_ONCE(op_rv2cv, OPpLVAL_INTRO, ",INTRO");
OP_PRIVATE_ONCE(op_flip, OPpFLIP_LINENUM, ",LINENUM");
OP_PRIVATE_ONCE(op_gv, OPpEARLY_CV, ",EARLY_CV");
OP_PRIVATE_ONCE(op_list, OPpLIST_GUESSED, ",GUESSED");
OP_PRIVATE_ONCE(op_delete, OPpSLICE, ",SLICE");
OP_PRIVATE_ONCE(op_exists, OPpEXISTS_SUB, ",EXISTS_SUB");
OP_PRIVATE_ONCE(op_die, OPpHUSH_VMSISH, ",HUSH_VMSISH");

struct op_private_by_op {
    U16 op_type;
    U16 len;
    const struct flag_to_name *start;
};
d740 7
a746 23
const struct op_private_by_op op_private_names[] = {
    {OP_LEAVESUB, C_ARRAY_LENGTH(op_leavesub_names), op_leavesub_names },
    {OP_LEAVE, C_ARRAY_LENGTH(op_leavesub_names), op_leavesub_names },
    {OP_LEAVESUBLV, C_ARRAY_LENGTH(op_leavesub_names), op_leavesub_names },
    {OP_LEAVEWRITE, C_ARRAY_LENGTH(op_leavesub_names), op_leavesub_names },
    {OP_AASSIGN, C_ARRAY_LENGTH(op_aassign_names), op_aassign_names },
    {OP_DIE, C_ARRAY_LENGTH(op_die_names), op_die_names },
    {OP_DELETE, C_ARRAY_LENGTH(op_delete_names), op_delete_names },
    {OP_EXISTS, C_ARRAY_LENGTH(op_exists_names), op_exists_names },
    {OP_EXIT, C_ARRAY_LENGTH(op_exit_names), op_exit_names },
    {OP_FLIP, C_ARRAY_LENGTH(op_flip_names), op_flip_names },
    {OP_FLOP, C_ARRAY_LENGTH(op_flip_names), op_flip_names },
    {OP_GV, C_ARRAY_LENGTH(op_gv_names), op_gv_names },
    {OP_LIST, C_ARRAY_LENGTH(op_list_names), op_list_names },
    {OP_SASSIGN, C_ARRAY_LENGTH(op_sassign_names), op_sassign_names },
    {OP_REPEAT, C_ARRAY_LENGTH(op_repeat_names), op_repeat_names },
    {OP_RV2CV, C_ARRAY_LENGTH(op_rv2cv_names), op_rv2cv_names },
    {OP_TRANS, C_ARRAY_LENGTH(op_trans_names), op_trans_names },
    {OP_CONST, C_ARRAY_LENGTH(op_const_names), op_const_names },
    {OP_SORT, C_ARRAY_LENGTH(op_sort_names), op_sort_names },
    {OP_OPEN, C_ARRAY_LENGTH(op_open_names), op_open_names },
    {OP_BACKTICK, C_ARRAY_LENGTH(op_open_names), op_open_names }
};
d748 7
a754 5
static bool
S_op_private_to_names(pTHX_ SV *tmpsv, U32 optype, U32 op_private) {
    const struct op_private_by_op *start = op_private_names;
    const struct op_private_by_op *const end
	= op_private_names + C_ARRAY_LENGTH(op_private_names);
d756 13
a768 10
    /* This is a linear search, but no worse than the code that it replaced.
       It's debugging code - size is more important than speed.  */
    do {
	if (optype == start->op_type) {
	    S_append_flags(aTHX_ tmpsv, op_private, start->start,
			   start->start + start->len);
	    return TRUE;
	}
    } while (++start < end);
    return FALSE;
d780 1
d787 1
a787 1
	PerlIO_printf(file, "????");
d792 1
a792 2
	PerlIO_printf(file,
			o->op_type == OP_NULL ? "(%"UVuf")\n" : "%"UVuf"\n",
d795 1
a795 1
	PerlIO_printf(file, "NULL\n");
d833 12
a844 1
	append_flags(tmpsv, o->op_flags, op_flags_names);
d860 31
d892 7
a898 7
	    optype == OP_RV2SV ||
	    optype == OP_GVSV ||
	    optype == OP_RV2AV ||
	    optype == OP_RV2HV ||
	    optype == OP_RV2GV ||
	    optype == OP_AELEM ||
	    optype == OP_HELEM )
d901 12
a912 1
		append_flags(tmpsv, o->op_private, op_entersub_names);
a928 1

d940 47
a986 1
	else if (S_op_private_to_names(aTHX_ tmpsv, optype, o->op_private)) {
d988 21
a1008 1
	else if (PL_check[optype] != Perl_ck_ftst) {
d1203 42
a1244 1
#include "mg_names.c"
d1259 34
a1292 5
	    if (v >= PL_magic_vtables
		&& v < PL_magic_vtables + magic_vtable_max) {
		const U32 i = v - PL_magic_vtables;
	        Perl_dump_indent(aTHX_ level, file, "    MG_VIRTUAL = &PL_vtbl_%s\n", PL_magic_vtable_names[i]);
	    }
a1323 3
	    if (mg->mg_type == PERL_MAGIC_regex_global &&
		mg->mg_flags & MGf_MINMATCH)
	        Perl_dump_indent(aTHX_ level, file, "      MINMATCH\n");
d1328 3
a1330 6
	    if (mg->mg_flags & MGf_COPY)
	        Perl_dump_indent(aTHX_ level, file, "      COPY\n");
	    if (mg->mg_flags & MGf_DUP)
	        Perl_dump_indent(aTHX_ level, file, "      DUP\n");
	    if (mg->mg_flags & MGf_LOCAL)
	        Perl_dump_indent(aTHX_ level, file, "      LOCAL\n");
d1333 1
a1333 1
	    Perl_dump_indent(aTHX_ level, file, "    MG_OBJ = 0x%"UVxf"\n",
d1339 1
a1339 1
		    = pv_pretty(dsv, RX_WRAPPED(re), RX_WRAPLEN(re),
a1367 1
	    else if (mg->mg_len == -1 && mg->mg_type == PERL_MAGIC_utf8);
d1369 1
a1369 5
		PerlIO_puts(
		  file,
		 " ???? - " __FILE__
		 " does not know how to handle this MG_LEN"
		);
d1402 1
a1402 8
    {
	/* we have to use pv_display and HvNAMELEN_get() so that we display the real package
           name which quite legally could contain insane things like tabs, newlines, nulls or
           other scary crap - this should produce sane results - except maybe for unicode package
           names - but we will wait for someone to file a bug on that - demerphq */
        SV * const tmpsv = newSVpvs("");
        PerlIO_printf(file, "\t%s\n", pv_display(tmpsv, hvname, HvNAMELEN_get(sv), 0, 1024));
    }
a1435 91
const struct flag_to_name first_sv_flags_names[] = {
    {SVs_TEMP, "TEMP,"},
    {SVs_OBJECT, "OBJECT,"},
    {SVs_GMG, "GMG,"},
    {SVs_SMG, "SMG,"},
    {SVs_RMG, "RMG,"},
    {SVf_IOK, "IOK,"},
    {SVf_NOK, "NOK,"},
    {SVf_POK, "POK,"}
};

const struct flag_to_name second_sv_flags_names[] = {
    {SVf_OOK, "OOK,"},
    {SVf_FAKE, "FAKE,"},
    {SVf_READONLY, "READONLY,"},
    {SVf_BREAK, "BREAK,"},
    {SVf_AMAGIC, "OVERLOAD,"},
    {SVp_IOK, "pIOK,"},
    {SVp_NOK, "pNOK,"},
    {SVp_POK, "pPOK,"}
};

const struct flag_to_name cv_flags_names[] = {
    {CVf_ANON, "ANON,"},
    {CVf_UNIQUE, "UNIQUE,"},
    {CVf_CLONE, "CLONE,"},
    {CVf_CLONED, "CLONED,"},
    {CVf_CONST, "CONST,"},
    {CVf_NODEBUG, "NODEBUG,"},
    {CVf_LVALUE, "LVALUE,"},
    {CVf_METHOD, "METHOD,"},
    {CVf_WEAKOUTSIDE, "WEAKOUTSIDE,"},
    {CVf_CVGV_RC, "CVGV_RC,"},
    {CVf_DYNFILE, "DYNFILE,"},
    {CVf_AUTOLOAD, "AUTOLOAD,"},
    {CVf_ISXSUB, "ISXSUB,"}
};

const struct flag_to_name hv_flags_names[] = {
    {SVphv_SHAREKEYS, "SHAREKEYS,"},
    {SVphv_LAZYDEL, "LAZYDEL,"},
    {SVphv_HASKFLAGS, "HASKFLAGS,"},
    {SVphv_REHASH, "REHASH,"},
    {SVphv_CLONEABLE, "CLONEABLE,"}
};

const struct flag_to_name gp_flags_names[] = {
    {GVf_INTRO, "INTRO,"},
    {GVf_MULTI, "MULTI,"},
    {GVf_ASSUMECV, "ASSUMECV,"},
    {GVf_IN_PAD, "IN_PAD,"}
};

const struct flag_to_name gp_flags_imported_names[] = {
    {GVf_IMPORTED_SV, " SV"},
    {GVf_IMPORTED_AV, " AV"},
    {GVf_IMPORTED_HV, " HV"},
    {GVf_IMPORTED_CV, " CV"},
};

const struct flag_to_name regexp_flags_names[] = {
    {RXf_PMf_MULTILINE,   "PMf_MULTILINE,"},
    {RXf_PMf_SINGLELINE,  "PMf_SINGLELINE,"},
    {RXf_PMf_FOLD,        "PMf_FOLD,"},
    {RXf_PMf_EXTENDED,    "PMf_EXTENDED,"},
    {RXf_PMf_KEEPCOPY,    "PMf_KEEPCOPY,"},
    {RXf_ANCH_BOL,        "ANCH_BOL,"},
    {RXf_ANCH_MBOL,       "ANCH_MBOL,"},
    {RXf_ANCH_SBOL,       "ANCH_SBOL,"},
    {RXf_ANCH_GPOS,       "ANCH_GPOS,"},
    {RXf_GPOS_SEEN,       "GPOS_SEEN,"},
    {RXf_GPOS_FLOAT,      "GPOS_FLOAT,"},
    {RXf_LOOKBEHIND_SEEN, "LOOKBEHIND_SEEN,"},
    {RXf_EVAL_SEEN,       "EVAL_SEEN,"},
    {RXf_CANY_SEEN,       "CANY_SEEN,"},
    {RXf_NOSCAN,          "NOSCAN,"},
    {RXf_CHECK_ALL,       "CHECK_ALL,"},
    {RXf_MATCH_UTF8,      "MATCH_UTF8,"},
    {RXf_USE_INTUIT_NOML, "USE_INTUIT_NOML,"},
    {RXf_USE_INTUIT_ML,   "USE_INTUIT_ML,"},
    {RXf_INTUIT_TAIL,     "INTUIT_TAIL,"},
    {RXf_SPLIT,           "SPLIT,"},
    {RXf_COPY_DONE,       "COPY_DONE,"},
    {RXf_TAINTED_SEEN,    "TAINTED_SEEN,"},
    {RXf_TAINTED,         "TAINTED,"},
    {RXf_START_ONLY,      "START_ONLY,"},
    {RXf_SKIPWHITE,       "SKIPWHITE,"},
    {RXf_WHITE,           "WHITE,"},
    {RXf_NULL,            "NULL,"},
};

a1454 2
    /* process general SV flags */

d1461 5
a1465 8
    if (!((flags & SVpad_NAME) == SVpad_NAME
	  && (type == SVt_PVMG || type == SVt_PVNV))) {
	if ((flags & SVs_PADMY) && (flags & SVs_PADSTALE))
	    sv_catpv(d, "PADSTALE,");
    }
    if (!((flags & SVpad_NAME) == SVpad_NAME && type == SVt_PVMG)) {
	if (!(flags & SVs_PADMY) && (flags & SVs_PADTMP))
	    sv_catpv(d, "PADTMP,");
d1468 9
a1476 1
    append_flags(d, flags, first_sv_flags_names);
d1481 9
a1489 1
    append_flags(d, flags, second_sv_flags_names);
a1496 2
    /* process type-specific SV flags */

d1500 10
a1509 1
	append_flags(d, CvFLAGS(sv), cv_flags_names);
d1512 5
a1516 1
	append_flags(d, flags, hv_flags_names);
d1521 4
a1524 1
	    append_flags(d, GvFLAGS(sv), gp_flags_names);
d1532 4
a1535 1
		append_flags(d, GvFLAGS(sv), gp_flags_imported_names);
d1539 2
a1547 2
	if (SvTAIL(sv))		sv_catpv(d, "TAIL,");
	if (SvVALID(sv))	sv_catpv(d, "VALID,");
a1567 2
    /* dump initial SV details */

d1570 1
a1570 1
	"ALLOCATED at %s:%d %s %s (parent 0x%"UVxf"); serial %"UVuf"\n",
d1575 1
a1575 1
	PTR2UV(sv->sv_debug_parent),
a1579 3

    /* Dump SV type */

a1591 3

    /* Dump general SV fields */

d1593 2
a1594 2
	 && type != SVt_PVCV && type != SVt_PVFM && type != SVt_PVIO
	 && type != SVt_REGEXP && !isGV_with_GP(sv) && !SvVALID(sv))
d1612 1
a1612 3

    if ((type == SVt_PVNV || type == SVt_PVMG)
	&& (SvFLAGS(sv) & SVpad_NAME) == SVpad_NAME) {
a1629 1

a1634 1

a1638 1

d1665 6
a1670 1

d1678 1
a1678 1
		do_magic_dump(level, file, SvMAGIC(sv), nest+1, maxnest, dumpops, pvlim);
a1681 6

	if ((type == SVt_PVMG || type == SVt_PVLV) && SvVALID(sv)) {
	    Perl_dump_indent(aTHX_ level, file, "  RARE = %u\n", (U8)BmRARE(sv));
	    Perl_dump_indent(aTHX_ level, file, "  PREVIOUS = %"UVuf"\n", (UV)BmPREVIOUS(sv));
	    Perl_dump_indent(aTHX_ level, file, "  USEFUL = %"IVdf"\n", (IV)BmUSEFUL(sv));
	}
a1682 3

    /* Dump type-specific SV fields */

d1713 1
a1713 1
	if (HvARRAY(sv) && HvUSEDKEYS(sv)) {
d1719 1
a1719 1
	    U32 pow2 = 2, keys = HvUSEDKEYS(sv);
d1761 1
a1761 1
	    theoret = HvUSEDKEYS(sv);
d1767 1
a1767 1
	Perl_dump_indent(aTHX_ level, file, "  KEYS = %"IVdf"\n", (IV)HvUSEDKEYS(sv));
a1786 35
	    if (HvAUX(sv)->xhv_name_count)
		Perl_dump_indent(aTHX_
		 level, file, "  NAMECOUNT = %"IVdf"\n",
		 (IV)HvAUX(sv)->xhv_name_count
		);
	    if (HvAUX(sv)->xhv_name_u.xhvnameu_name && HvENAME_HEK_NN(sv)) {
		const I32 count = HvAUX(sv)->xhv_name_count;
		if (count) {
		    SV * const names = newSVpvs_flags("", SVs_TEMP);
		    /* The starting point is the first element if count is
		       positive and the second element if count is negative. */
		    HEK *const *hekp = HvAUX(sv)->xhv_name_u.xhvnameu_names
			+ (count < 0 ? 1 : 0);
		    HEK *const *const endp = HvAUX(sv)->xhv_name_u.xhvnameu_names
			+ (count < 0 ? -count : count);
		    while (hekp < endp) {
			if (*hekp) {
			    sv_catpvs(names, ", \"");
			    sv_catpvn(names, HEK_KEY(*hekp), HEK_LEN(*hekp));
			    sv_catpvs(names, "\"");
			} else {
			    /* This should never happen. */
			    sv_catpvs(names, ", (null)");
			}
			++hekp;
		    }
		    Perl_dump_indent(aTHX_
		     level, file, "  ENAME = %s\n", SvPV_nolen(names)+2
		    );
		}
		else
		    Perl_dump_indent(aTHX_
		     level, file, "  ENAME = \"%s\"\n", HvENAME_get(sv)
		    );
	    }
d1829 2
a1830 1
	if (nest < maxnest) {
d1832 1
a1832 2
	    STRLEN i;
	    HE *he;
d1834 3
a1836 8
	    if (HvARRAY(hv)) {
		int count = maxnest - nest;
		for (i=0; i <= HvMAX(hv); i++) {
		    for (he = HvARRAY(hv)[i]; he; he = HeNEXT(he)) {
			U32 hash;
			SV * keysv;
			const char * keypv;
			SV * elt;
d1838 4
a1841 7

			if (count-- <= 0) goto DONEHV;

			hash = HeHASH(he);
			keysv = hv_iterkeysv(he);
			keypv = SvPV_const(keysv, len);
			elt = HeVAL(he);
a1845 2
			if (HvEITER_get(hv) == he)
			    PerlIO_printf(file, "[CURRENT] ");
d1848 1
a1848 1
			PerlIO_printf(file, "HASH = 0x%"UVxf"\n", (UV) hash);
d1851 1
a1851 3
		}
	      DONEHV:;
	    }
a1853 1

d1855 1
a1855 1
	if (CvAUTOLOAD(sv)) {
d1857 1
a1857 5
	    const char *const name =  SvPV_const(sv, len);
	    Perl_dump_indent(aTHX_ level, file, "  AUTOLOAD = \"%.*s\"\n",
			     (int) len, name);
	}
	if (SvPOK(sv)) {
d1859 1
a1859 1
			     (int) CvPROTOLEN(sv), CvPROTO(sv));
a1916 1

a1923 1
	    Perl_dump_indent(aTHX_ level, file, "  FLAGS = %"IVdf"\n", (IV)LvFLAGS(sv));
d1928 6
a2000 56
    case SVt_REGEXP:
	{
	    struct regexp * const r = (struct regexp *)SvANY(sv);
	    flags = RX_EXTFLAGS((REGEXP*)sv);
	    sv_setpv(d,"");
	    append_flags(d, flags, regexp_flags_names);
	    if (*(SvEND(d) - 1) == ',') {
		SvCUR_set(d, SvCUR(d) - 1);
		SvPVX(d)[SvCUR(d)] = '\0';
	    }
	    Perl_dump_indent(aTHX_ level, file, "  EXTFLAGS = 0x%"UVxf" (%s)\n",
				(UV)flags, SvPVX_const(d));
	    Perl_dump_indent(aTHX_ level, file, "  INTFLAGS = 0x%"UVxf"\n",
				(UV)(r->intflags));
	    Perl_dump_indent(aTHX_ level, file, "  NPARENS = %"UVuf"\n",
				(UV)(r->nparens));
	    Perl_dump_indent(aTHX_ level, file, "  LASTPAREN = %"UVuf"\n",
				(UV)(r->lastparen));
	    Perl_dump_indent(aTHX_ level, file, "  LASTCLOSEPAREN = %"UVuf"\n",
				(UV)(r->lastcloseparen));
	    Perl_dump_indent(aTHX_ level, file, "  MINLEN = %"IVdf"\n",
				(IV)(r->minlen));
	    Perl_dump_indent(aTHX_ level, file, "  MINLENRET = %"IVdf"\n",
				(IV)(r->minlenret));
	    Perl_dump_indent(aTHX_ level, file, "  GOFS = %"UVuf"\n",
				(UV)(r->gofs));
	    Perl_dump_indent(aTHX_ level, file, "  PRE_PREFIX = %"UVuf"\n",
				(UV)(r->pre_prefix));
	    Perl_dump_indent(aTHX_ level, file, "  SEEN_EVALS = %"UVuf"\n",
				(UV)(r->seen_evals));
	    Perl_dump_indent(aTHX_ level, file, "  SUBLEN = %"IVdf"\n",
				(IV)(r->sublen));
	    if (r->subbeg)
		Perl_dump_indent(aTHX_ level, file, "  SUBBEG = 0x%"UVxf" %s\n",
			    PTR2UV(r->subbeg),
			    pv_display(d, r->subbeg, r->sublen, 50, pvlim));
	    else
		Perl_dump_indent(aTHX_ level, file, "  SUBBEG = 0x0\n");
	    Perl_dump_indent(aTHX_ level, file, "  ENGINE = 0x%"UVxf"\n",
				PTR2UV(r->engine));
	    Perl_dump_indent(aTHX_ level, file, "  MOTHER_RE = 0x%"UVxf"\n",
				PTR2UV(r->mother_re));
	    Perl_dump_indent(aTHX_ level, file, "  PAREN_NAMES = 0x%"UVxf"\n",
				PTR2UV(r->paren_names));
	    Perl_dump_indent(aTHX_ level, file, "  SUBSTRS = 0x%"UVxf"\n",
				PTR2UV(r->substrs));
	    Perl_dump_indent(aTHX_ level, file, "  PPRIVATE = 0x%"UVxf"\n",
				PTR2UV(r->pprivate));
	    Perl_dump_indent(aTHX_ level, file, "  OFFS = 0x%"UVxf"\n",
				PTR2UV(r->offs));
#ifdef PERL_OLD_COPY_ON_WRITE
	    Perl_dump_indent(aTHX_ level, file, "  SAVED_COPY = 0x%"UVxf"\n",
				PTR2UV(r->saved_copy));
#endif
	}
	break;
d2029 1
d2049 1
a2049 1
    } while ((PL_op = PL_op->op_ppaddr(aTHX)));
d2129 1
a2129 1
        return cx->blk_eval.cv;
d2225 1
a2225 1
Perl_xmldump_all_perl(pTHX_ bool justperl PERL_UNUSED_DECL)
d2230 1
a2230 2
    /* someday we might call this, when it outputs XML: */
    /* xmldump_packsubs_perl(PL_defstash, justperl); */
a2328 7
Perl_sv_catxmlpv(pTHX_ SV *dsv, const char *pv, int utf8)
{
    PERL_ARGS_ASSERT_SV_CATXMLPV;
    return sv_catxmlpvn(dsv, pv, strlen(pv), utf8);
}

char *
d2345 1
a2345 1
	    c = utf8_to_uvchr_buf((U8*)pv, (U8*)e, &cl);
d2585 1
a2585 1
	sv_catpv(t, " REGEXP=\"");
d2678 1
d2802 2
d2836 2
d2899 1
a2899 1
	else if (PL_check[o->op_type] != Perl_ck_ftst) {
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d29 1
d460 1
a460 2
    else if (sv == (const SV *)0x55555555 || ((char)SvTYPE(sv)) == 'U') {
        /* detect data corruption under memory poisoning */
d564 1
a564 1
	    SvREFCNT_dec_NN(tmp);
d584 1
a584 1
    if (TAINTING_get && SvTAINTED(sv))
a615 9
    if (pm->op_code_list) {
	if (pm->op_pmflags & PMf_CODELIST_PRIVATE) {
	    Perl_dump_indent(aTHX_ level, file, "CODE_LIST =\n");
	    do_op_dump(level, file, pm->op_code_list);
	}
	else
	    Perl_dump_indent(aTHX_ level, file, "CODE_LIST = 0x%"UVxf"\n",
				    PTR2UV(pm->op_code_list));
    }
d619 1
a619 1
	SvREFCNT_dec_NN(tmpsv);
a632 3
    {PMf_HAS_CV, ",HAS_CV"},
    {PMf_CODELIST_PRIVATE, ",CODELIST_PRIVATE"},
    {PMf_IS_QR, ",IS_QR"}
d655 1
a655 1
        if (RX_ISTAINTED(regex))
d736 2
a737 2
    {OPpCONST_FOLDED, ",FOLDED"},
    {OPpCONST_BARE, ",BARE"}
a761 5
const struct flag_to_name op_sassign_names[] = {
    {OPpASSIGN_BACKWARDS, ",BACKWARDS"},
    {OPpASSIGN_CV_TO_GV,  ",CV2GV"}
};

d767 1
d769 1
d791 1
a827 125
#define DUMP_OP_FLAGS(o,xml,level,file)                                 \
    if (o->op_flags || o->op_slabbed || o->op_savefree || o->op_static) { \
        SV * const tmpsv = newSVpvs("");                                \
        switch (o->op_flags & OPf_WANT) {                               \
        case OPf_WANT_VOID:                                             \
            sv_catpv(tmpsv, ",VOID");                                   \
            break;                                                      \
        case OPf_WANT_SCALAR:                                           \
            sv_catpv(tmpsv, ",SCALAR");                                 \
            break;                                                      \
        case OPf_WANT_LIST:                                             \
            sv_catpv(tmpsv, ",LIST");                                   \
            break;                                                      \
        default:                                                        \
            sv_catpv(tmpsv, ",UNKNOWN");                                \
            break;                                                      \
        }                                                               \
        append_flags(tmpsv, o->op_flags, op_flags_names);               \
        if (o->op_slabbed)  sv_catpvs(tmpsv, ",SLABBED");               \
        if (o->op_savefree) sv_catpvs(tmpsv, ",SAVEFREE");              \
        if (o->op_static)   sv_catpvs(tmpsv, ",STATIC");                \
        if (!xml)                                                        \
            Perl_dump_indent(aTHX_ level, file, "FLAGS = (%s)\n",       \
                            SvCUR(tmpsv) ? SvPVX_const(tmpsv) + 1 : "");\
        else                                                            \
            PerlIO_printf(file, " flags=\"%s\"",                        \
                          SvCUR(tmpsv) ? SvPVX(tmpsv) + 1 : "");        \
        SvREFCNT_dec_NN(tmpsv);                                            \
    }

#if !defined(PERL_MAD)
# define xmldump_attr1(level, file, pat, arg)
#else
# define xmldump_attr1(level, file, pat, arg) \
	S_xmldump_attr(aTHX_ level, file, pat, arg)
#endif

#define DUMP_OP_PRIVATE(o,xml,level,file)                               \
    if (o->op_private) {                                                \
        U32 optype = o->op_type;                                        \
        U32 oppriv = o->op_private;                                     \
        SV * const tmpsv = newSVpvs("");                                \
	if (PL_opargs[optype] & OA_TARGLEX) {                           \
	    if (oppriv & OPpTARGET_MY)                                  \
		sv_catpv(tmpsv, ",TARGET_MY");                          \
	}                                                               \
	else if (optype == OP_ENTERSUB ||                               \
                 optype == OP_RV2SV ||                                  \
                 optype == OP_GVSV ||                                   \
                 optype == OP_RV2AV ||                                  \
                 optype == OP_RV2HV ||                                  \
                 optype == OP_RV2GV ||                                  \
                 optype == OP_AELEM ||                                  \
                 optype == OP_HELEM )                                   \
        {                                                               \
            if (optype == OP_ENTERSUB) {                                \
                append_flags(tmpsv, oppriv, op_entersub_names);         \
            }                                                           \
            else {                                                      \
                switch (oppriv & OPpDEREF) {                            \
                case OPpDEREF_SV:                                       \
                    sv_catpv(tmpsv, ",SV");                             \
                    break;                                              \
                case OPpDEREF_AV:                                       \
                    sv_catpv(tmpsv, ",AV");                             \
                    break;                                              \
                case OPpDEREF_HV:                                       \
                    sv_catpv(tmpsv, ",HV");                             \
                    break;                                              \
                }                                                       \
                if (oppriv & OPpMAYBE_LVSUB)                            \
                    sv_catpv(tmpsv, ",MAYBE_LVSUB");                    \
            }                                                           \
            if (optype == OP_AELEM || optype == OP_HELEM) {             \
                if (oppriv & OPpLVAL_DEFER)                             \
                    sv_catpv(tmpsv, ",LVAL_DEFER");                     \
            }                                                           \
            else if (optype == OP_RV2HV || optype == OP_PADHV) {        \
                if (oppriv & OPpMAYBE_TRUEBOOL)                         \
                    sv_catpvs(tmpsv, ",OPpMAYBE_TRUEBOOL");             \
                if (oppriv & OPpTRUEBOOL)                               \
                    sv_catpvs(tmpsv, ",OPpTRUEBOOL");                   \
            }                                                           \
            else {                                                      \
                if (oppriv & HINT_STRICT_REFS)                          \
                    sv_catpv(tmpsv, ",STRICT_REFS");                    \
                if (oppriv & OPpOUR_INTRO)                              \
                    sv_catpv(tmpsv, ",OUR_INTRO");                      \
            }                                                           \
        }                                                               \
	else if (S_op_private_to_names(aTHX_ tmpsv, optype, oppriv)) {  \
	}                                                               \
	else if (OP_IS_FILETEST(o->op_type)) {                          \
            if (oppriv & OPpFT_ACCESS)                                  \
                sv_catpv(tmpsv, ",FT_ACCESS");                          \
            if (oppriv & OPpFT_STACKED)                                 \
                sv_catpv(tmpsv, ",FT_STACKED");                         \
            if (oppriv & OPpFT_STACKING)                                \
                sv_catpv(tmpsv, ",FT_STACKING");                        \
            if (oppriv & OPpFT_AFTER_t)                                 \
                sv_catpv(tmpsv, ",AFTER_t");                            \
	}                                                               \
	else if (o->op_type == OP_AASSIGN) {                            \
	    if (oppriv & OPpASSIGN_COMMON)                              \
		sv_catpvs(tmpsv, ",COMMON");                            \
	    if (oppriv & OPpMAYBE_LVSUB)                                \
		sv_catpvs(tmpsv, ",MAYBE_LVSUB");                       \
	}                                                               \
	if (o->op_flags & OPf_MOD && oppriv & OPpLVAL_INTRO)            \
	    sv_catpv(tmpsv, ",INTRO");                                  \
	if (o->op_type == OP_PADRANGE)                                  \
	    Perl_sv_catpvf(aTHX_ tmpsv, ",COUNT=%"UVuf,                 \
                           (UV)(oppriv & OPpPADRANGE_COUNTMASK));       \
	if (SvCUR(tmpsv)) {                                             \
            if (xml)                                                    \
                xmldump_attr1(level+1, file, "private=\"%s\"", SvPVX(tmpsv)+1); \
            else                                                        \
                Perl_dump_indent(aTHX_ level, file, "PRIVATE = (%s)\n", SvPVX_const(tmpsv) + 1); \
	} else if (!xml)                                                \
            Perl_dump_indent(aTHX_ level, file, "PRIVATE = (0x%"UVxf")\n", \
                             (UV)oppriv);                               \
	SvREFCNT_dec_NN(tmpsv);                                         \
    }


d874 59
d934 25
a958 2
    DUMP_OP_FLAGS(o,0,level,file);
    DUMP_OP_PRIVATE(o,0,level,file);
d999 1
a999 1
	SvREFCNT_dec_NN(tmpsv);
d1234 1
a1234 1
		    SvREFCNT_dec_NN(sv);
a1337 1
    {SVf_IsCOW, "IsCOW,"},
a1357 2
    {CVf_HASEVAL, "HASEVAL"},
    {CVf_SLABBED, "SLABBED,"},
d1365 1
d1395 1
a1395 1
    {RXf_NO_INPLACE_SUBST, "NO_INPLACE_SUBST,"},
d1539 1
a1539 1
	    SvREFCNT_dec_NN(d);
d1544 1
a1544 1
	SvREFCNT_dec_NN(d);
d1598 1
a1598 1
	SvREFCNT_dec_NN(d);
d1602 2
a1603 5
    if (type <= SVt_PVLV && !isGV_with_GP(sv)) {
	const bool re = isREGEXP(sv);
	const char * const ptr =
	    re ? RX_WRAPPED((REGEXP*)sv) : SvPVX_const(sv);
	if (ptr) {
d1612 1
a1612 1
	    Perl_dump_indent(aTHX_ level, file,"  PV = 0x%"UVxf" ", PTR2UV(ptr));
d1615 1
a1615 1
			      pv_display(d, ptr - delta, delta, 0,
d1618 1
a1618 3
	    PerlIO_printf(file, "%s", pv_display(d, ptr, SvCUR(sv),
						 re ? 0 : SvLEN(sv),
						 pvlim));
d1623 1
a1623 8
	    if (!re)
		Perl_dump_indent(aTHX_ level, file, "  LEN = %"IVdf"\n",
				       (IV)SvLEN(sv));
#ifdef PERL_NEW_COPY_ON_WRITE
	    if (SvIsCOW(sv) && SvLEN(sv))
		Perl_dump_indent(aTHX_ level, file, "  COW_REFCNT = %d\n",
				       CowREFCNT(sv));
#endif
d1737 2
a1738 11
        if (SvOOK(sv)) {
	    Perl_dump_indent(aTHX_ level, file, "  RITER = %"IVdf"\n", (IV)HvRITER_get(sv));
	    Perl_dump_indent(aTHX_ level, file, "  EITER = 0x%"UVxf"\n", PTR2UV(HvEITER_get(sv)));
#ifdef PERL_HASH_RANDOMIZE_KEYS
	    Perl_dump_indent(aTHX_ level, file, "  RAND = 0x%"UVxf, (UV)HvRAND_get(sv));
            if (HvRAND_get(sv) != HvLASTRAND_get(sv) && HvRITER_get(sv) != -1 ) {
                PerlIO_printf(file, " (LAST = 0x%"UVxf")", (UV)HvLASTRAND_get(sv));
            }
#endif
            PerlIO_putc(file, '\n');
        }
d1844 1
a1844 1
                        STRLEN len;
d1853 3
a1855 3
                        Perl_dump_indent(aTHX_ level+1, file, "Elt %s ", pv_display(d, keypv, len, 0, pvlim));
                        if (SvUTF8(keysv))
                            PerlIO_printf(file, "[UTF8 \"%s\"] ", sv_uni_display(d, keysv, 6 * SvCUR(keysv), UNI_DISPLAY_QQ));
d1858 5
a1862 3
                        PerlIO_printf(file, "HASH = 0x%"UVxf"\n", (UV) hash);
                        do_sv_dump(level+1, file, elt, nest+1, maxnest, dumpops, pvlim);
                    }
d1911 1
a1911 4
	if (CvNAMED(sv))
	    Perl_dump_indent(aTHX_ level, file, "  NAME = \"%s\"\n",
				   HEK_KEY(CvNAME_HEK((CV *)sv)));
	else do_gvgv_dump(level, file, "  GVGV::GV", CvGV(sv));
d1913 2
a1914 1
	Perl_dump_indent(aTHX_ level, file, "  DEPTH = %"IVdf"\n", (IV)CvDEPTH(sv));
d1917 2
a1948 1
	if (isREGEXP(sv)) goto dumpregexp;
a2016 1
      dumpregexp:
d2018 8
a2025 14
	    struct regexp * const r = ReANY((REGEXP*)sv);
#define SV_SET_STRINGIFY_REGEXP_FLAGS(d,flags) STMT_START { \
            sv_setpv(d,"");                                 \
            append_flags(d, flags, regexp_flags_names);     \
            if (SvCUR(d) > 0 && *(SvEND(d) - 1) == ',') {       \
                SvCUR_set(d, SvCUR(d) - 1);                 \
                SvPVX(d)[SvCUR(d)] = '\0';                  \
            }                                               \
} STMT_END
            SV_SET_STRINGIFY_REGEXP_FLAGS(d,r->compflags);
            Perl_dump_indent(aTHX_ level, file, "  COMPFLAGS = 0x%"UVxf" (%s)\n",
                                (UV)(r->compflags), SvPVX_const(d));

            SV_SET_STRINGIFY_REGEXP_FLAGS(d,r->extflags);
d2027 1
a2027 3
                                (UV)(r->extflags), SvPVX_const(d));
#undef SV_SET_STRINGIFY_REGEXP_FLAGS

d2044 2
a2047 4
	    Perl_dump_indent(aTHX_ level, file, "  SUBOFFSET = %"IVdf"\n",
				(IV)(r->suboffset));
	    Perl_dump_indent(aTHX_ level, file, "  SUBCOFFSET = %"IVdf"\n",
				(IV)(r->subcoffset));
d2066 1
a2066 3
	    Perl_dump_indent(aTHX_ level, file, "  QR_ANONCV = 0x%"UVxf"\n",
				PTR2UV(r->qr_anoncv));
#ifdef PERL_ANY_COW
d2073 1
a2073 1
    SvREFCNT_dec_NN(d);
a2118 2

        OP_ENTRY_PROBE(OP_NAME(PL_op));
a2120 1
    PERL_ASYNC_CHECK();
d2160 1
a2160 1
	    SvREFCNT_dec_NN(sv);
a2164 4

    {
        int count;

d2168 1
a2168 5
        count = 1;
        goto dump_padop;
    case OP_PADRANGE:
        count = o->op_private & OPpPADRANGE_COUNTMASK;
    dump_padop:
d2170 13
a2182 23
        {
            CV * const cv = deb_curcv(cxstack_ix);
            SV *sv;
            PAD * comppad = NULL;
            int i;

            if (cv) {
                PADLIST * const padlist = CvPADLIST(cv);
                comppad = *PadlistARRAY(padlist);
            }
            PerlIO_printf(Perl_debug_log, "(");
            for (i = 0; i < count; i++) {
                if (comppad &&
                        (sv = *av_fetch(comppad, o->op_targ + i, FALSE)))
                    PerlIO_printf(Perl_debug_log, "%s", SvPV_nolen_const(sv));
                else
                    PerlIO_printf(Perl_debug_log, "[%"UVuf"]",
                            (UV)o->op_targ+i);
                if (i < count-1)
                    PerlIO_printf(Perl_debug_log, ",");
            }
            PerlIO_printf(Perl_debug_log, ")");
        }
a2183 2
    }

d2549 1
a2549 1
    else if (sv == (const SV *)0x55555555 || ((char)SvTYPE(sv)) == 'U') {
d2716 1
a2716 1
	SvREFCNT_dec_NN(tmpsv);
d2725 1
a2725 1
	SvREFCNT_dec_NN(tmpsv);
a2750 1
    const OPCODE optype = o->op_type;
d2769 1
a2769 1
	if (optype == OP_NULL)
d2791 193
d2985 1
a2985 4
    DUMP_OP_FLAGS(o,1,0,file);
    DUMP_OP_PRIVATE(o,1,0,file);

    switch (optype) {
d3137 1
a3137 1
	SvREFCNT_dec_NN(tmpsv);
d3140 1
a3140 1
    switch (optype) {
d3184 1
a3184 1
 * indent-tabs-mode: nil
d3187 1
a3187 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d30 1
d33 1
a36 1
    "INVLIST",
d53 1
a56 1
    "INVLST",
d88 126
a213 4
#define generic_pv_escape(sv,s,len,utf8) pv_escape( (sv), (s), (len), \
                              (len) * (4+UTF8_MAXBYTES) + 1, NULL, \
                              PERL_PV_ESCAPE_NONASCII | PERL_PV_ESCAPE_DWIM \
                              | ((utf8) ? PERL_PV_ESCAPE_UNI : 0) )
d234 1
a234 1
non-ASCII chars will be escaped using this style; otherwise, only chars above
d236 1
a236 2
common escaped patterns like C<\n>.
Otherwise, if PERL_PV_ESCAPE_NOBACKSLASH
d241 1
a241 1
string will be escaped, regardless of max.  If the output is to be in hex,
d243 1
a243 1
sequence.  Thus the output will either be a single char,
d247 1
a247 1
not a '\\'.  This is because regexes very often contain backslashed
d288 1
a288 1
	  || (( ! isASCII(u) ) && (flags & (PERL_PV_ESCAPE_NONASCII|PERL_PV_ESCAPE_DWIM))))
d295 1
a295 4
                                      ((flags & PERL_PV_ESCAPE_DWIM) && !isuni)
                                      ? "%cx%02"UVxf
                                      : "%cx{%02"UVxf"}", esc, u);

d322 1
a322 6
                     if ( (flags & PERL_PV_ESCAPE_DWIM) && c != '\0' ) {
                        chsize = my_snprintf( octbuf, PV_ESCAPE_OCTBUFSIZE,
                                      isuni ? "%cx{%02"UVxf"}" : "%cx%02"UVxf,
                                      esc, u);
                     }
                     else if ( (pv+readsize < end) && isDIGIT((U8)*(pv+readsize)) )
d339 2
a340 2
	    /* If PERL_PV_ESCAPE_NOBACKSLASH is set then non-ASCII bytes
	       can be appended raw to the dsv. If dsv happens to be
d344 1
a344 1
	       really an array of octets, not a string.  */
d362 1
a362 1
double quoted with any double quotes in the string escaped.  Otherwise
d368 1
a368 1
string.  Note that this happens AFTER it has been quoted.
d371 1
a371 1
quote (if there is one) but before the escaped text.  If end_color
d508 1
a508 1
	SSize_t ix;
d536 1
a536 5
        SV * const tmp = newSVpvs_flags("", SVs_TEMP);
        GV* gvcv = CvGV(sv);
        Perl_sv_catpvf(aTHX_ t, "CV(%s)", gvcv
                       ? generic_pv_escape( tmp, GvNAME(gvcv), GvNAMELEN(gvcv), GvNAMEUTF8(gvcv))
                       : "");
a588 151
/*
=head1 Debugging Utilities
*/

void
Perl_dump_indent(pTHX_ I32 level, PerlIO *file, const char* pat, ...)
{
    va_list args;
    PERL_ARGS_ASSERT_DUMP_INDENT;
    va_start(args, pat);
    dump_vindent(level, file, pat, &args);
    va_end(args);
}

void
Perl_dump_vindent(pTHX_ I32 level, PerlIO *file, const char* pat, va_list *args)
{
    dVAR;
    PERL_ARGS_ASSERT_DUMP_VINDENT;
    PerlIO_printf(file, "%*s", (int)(level*PL_dumpindent), "");
    PerlIO_vprintf(file, pat, *args);
}

/*
=for apidoc dump_all

Dumps the entire optree of the current program starting at C<PL_main_root> to 
C<STDERR>.  Also dumps the optrees for all visible subroutines in
C<PL_defstash>.

=cut
*/

void
Perl_dump_all(pTHX)
{
    dump_all_perl(FALSE);
}

void
Perl_dump_all_perl(pTHX_ bool justperl)
{

    dVAR;
    PerlIO_setlinebuf(Perl_debug_log);
    if (PL_main_root)
	op_dump(PL_main_root);
    dump_packsubs_perl(PL_defstash, justperl);
}

/*
=for apidoc dump_packsubs

Dumps the optrees for all visible subroutines in C<stash>.

=cut
*/

void
Perl_dump_packsubs(pTHX_ const HV *stash)
{
    PERL_ARGS_ASSERT_DUMP_PACKSUBS;
    dump_packsubs_perl(stash, FALSE);
}

void
Perl_dump_packsubs_perl(pTHX_ const HV *stash, bool justperl)
{
    dVAR;
    I32	i;

    PERL_ARGS_ASSERT_DUMP_PACKSUBS_PERL;

    if (!HvARRAY(stash))
	return;
    for (i = 0; i <= (I32) HvMAX(stash); i++) {
        const HE *entry;
	for (entry = HvARRAY(stash)[i]; entry; entry = HeNEXT(entry)) {
	    const GV * const gv = (const GV *)HeVAL(entry);
	    if (SvTYPE(gv) != SVt_PVGV || !GvGP(gv))
		continue;
	    if (GvCVu(gv))
		dump_sub_perl(gv, justperl);
	    if (GvFORM(gv))
		dump_form(gv);
	    if (HeKEY(entry)[HeKLEN(entry)-1] == ':') {
		const HV * const hv = GvHV(gv);
		if (hv && (hv != PL_defstash))
		    dump_packsubs_perl(hv, justperl); /* nested package */
	    }
	}
    }
}

void
Perl_dump_sub(pTHX_ const GV *gv)
{
    PERL_ARGS_ASSERT_DUMP_SUB;
    dump_sub_perl(gv, FALSE);
}

void
Perl_dump_sub_perl(pTHX_ const GV *gv, bool justperl)
{
    STRLEN len;
    SV * const sv = newSVpvs_flags("", SVs_TEMP);
    SV *tmpsv;
    const char * name;

    PERL_ARGS_ASSERT_DUMP_SUB_PERL;

    if (justperl && (CvISXSUB(GvCV(gv)) || !CvROOT(GvCV(gv))))
	return;

    tmpsv = newSVpvs_flags("", SVs_TEMP);
    gv_fullname3(sv, gv, NULL);
    name = SvPV_const(sv, len);
    Perl_dump_indent(aTHX_ 0, Perl_debug_log, "\nSUB %s = ",
                     generic_pv_escape(tmpsv, name, len, SvUTF8(sv)));
    if (CvISXSUB(GvCV(gv)))
	Perl_dump_indent(aTHX_ 0, Perl_debug_log, "(xsub 0x%"UVxf" %d)\n",
	    PTR2UV(CvXSUB(GvCV(gv))),
	    (int)CvXSUBANY(GvCV(gv)).any_i32);
    else if (CvROOT(GvCV(gv)))
	op_dump(CvROOT(GvCV(gv)));
    else
	Perl_dump_indent(aTHX_ 0, Perl_debug_log, "<undef>\n");
}

void
Perl_dump_form(pTHX_ const GV *gv)
{
    SV * const sv = sv_newmortal();

    PERL_ARGS_ASSERT_DUMP_FORM;

    gv_fullname3(sv, gv, NULL);
    Perl_dump_indent(aTHX_ 0, Perl_debug_log, "\nFORMAT %s = ", SvPVX_const(sv));
    if (CvROOT(GvFORM(gv)))
	op_dump(CvROOT(GvFORM(gv)));
    else
	Perl_dump_indent(aTHX_ 0, Perl_debug_log, "<undef>\n");
}

void
Perl_dump_eval(pTHX)
{
    dVAR;
    op_dump(PL_eval_root);
}

d670 1
a670 1
            if (!(RX_INTFLAGS(regex) & PREGf_NOSCAN))
d748 1
d769 5
a778 5
const struct flag_to_name op_leave_names[] = {
    {OPpREFCOUNTED, ",REFCOUNTED"},
    {OPpLVALUE,	    ",LVALUE"}
};

a793 2
OP_PRIVATE_ONCE(op_split, OPpSPLIT_IMPLIM, ",IMPLIM");
OP_PRIVATE_ONCE(op_dbstate, OPpHUSH_VMSISH, ",HUSH_VMSISH");
d803 1
a803 1
    {OP_LEAVE, C_ARRAY_LENGTH(op_leave_names), op_leave_names },
d809 1
a820 3
    {OP_SPLIT, C_ARRAY_LENGTH(op_split_names), op_split_names },
    {OP_DBSTATE, C_ARRAY_LENGTH(op_dbstate_names), op_dbstate_names },
    {OP_NEXTSTATE, C_ARRAY_LENGTH(op_dbstate_names), op_dbstate_names },
d827 2
a828 1
    const struct op_private_by_op *const end = C_ARRAY_END(op_private_names);
a862 1
        if (o->op_folded)   sv_catpvs(tmpsv, ",FOLDED");                \
d869 1
a954 5
        if (  (o->op_type == OP_RV2HV || o->op_type == OP_RV2AV ||      \
               o->op_type == OP_PADAV || o->op_type == OP_PADHV ||      \
               o->op_type == OP_ASLICE || o->op_type == OP_HSLICE)      \
           && oppriv & OPpSLICEWARNING  )                               \
            sv_catpvs(tmpsv, ",SLICEWARNING");                          \
d963 1
d999 1
a999 5
        if (CopSTASHPV(cCOPo)) {
            SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
            HV *stash = CopSTASH(cCOPo);
            const char * const hvname = HvNAME_get(stash);

d1001 2
a1002 9
                           generic_pv_escape( tmpsv, hvname, HvNAMELEN(stash), HvNAMEUTF8(stash)));
       }
     if (CopLABEL(cCOPo)) {
          SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
          STRLEN label_len;
          U32 label_flags;
          const char *label = CopLABEL_len_flags(cCOPo,
                                                 &label_len,
                                                 &label_flags);
d1004 1
a1004 3
                           generic_pv_escape( tmpsv, label, label_len,(label_flags & SVf_UTF8)));
      }

d1055 2
d1069 3
a1071 4
      STRLEN len;
      const char * name;
      SV * const tmpsv  = newSVpvs_flags("", SVs_TEMP);
      SV * const tmpsv2 = newSVpvs_flags("", SVs_TEMP);
a1077 1
      name = SvPV_const(tmpsv, len);
d1079 2
a1080 1
                       generic_pv_escape( tmpsv2, name, len, SvUTF8(tmpsv)));
d1101 1
a1101 5
    if (CopSTASHPV(cCOPo)) {
        SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
        HV *stash = CopSTASH(cCOPo);
        const char * const hvname = HvNAME_get(stash);
        
d1103 4
a1106 13
                           generic_pv_escape(tmpsv, hvname,
                              HvNAMELEN(stash), HvNAMEUTF8(stash)));
    }
  if (CopLABEL(cCOPo)) {
       SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
       STRLEN label_len;
       U32 label_flags;
       const char *label = CopLABEL_len_flags(cCOPo,
                                                &label_len, &label_flags);
       Perl_dump_indent(aTHX_ level, file, "LABEL = \"%s\"\n",
                           generic_pv_escape( tmpsv, label, label_len,
                                      (label_flags & SVf_UTF8)));
   }
a1162 8
/*
=for apidoc op_dump

Dumps the optree starting at OP C<o> to C<STDERR>.

=cut
*/

d1173 1
a1173 4
    STRLEN len;
    const char* name;
    SV *sv, *tmp = newSVpvs_flags("", SVs_TEMP);

d1184 1
a1184 3
    name = SvPV_const(sv, len);
    Perl_dump_indent(aTHX_ 1, Perl_debug_log, "GV_NAME = %s",
                     generic_pv_escape( tmp, name, len, SvUTF8(sv) ));
d1187 1
a1187 3
        name = SvPV_const(sv, len);
        Perl_dump_indent(aTHX_ 1, Perl_debug_log, "-> %s",
                     generic_pv_escape( tmp, name, len, SvUTF8(sv) ));
a1262 3
	    if (mg->mg_type == PERL_MAGIC_regex_global &&
		mg->mg_flags & MGf_BYTES)
	        Perl_dump_indent(aTHX_ level, file, "      BYTES\n");
d1344 2
a1345 4
        SV * const tmpsv = newSVpvs_flags("", SVs_TEMP);
        PerlIO_printf(file, "\t\"%s\"\n",
                              generic_pv_escape( tmpsv, hvname,
                                   HvNAMELEN(sv), HvNAMEUTF8(sv)));
d1357 2
a1358 5
    if (sv && GvNAME(sv)) {
        SV * const tmpsv = newSVpvs("");
        PerlIO_printf(file, "\t\"%s\"\n",
                              generic_pv_escape( tmpsv, GvNAME(sv), GvNAMELEN(sv), GvNAMEUTF8(sv) ));
    }
a1369 1
       SV *tmp = newSVpvs_flags("", SVs_TEMP);
d1371 4
a1374 10
        HV * const stash = GvSTASH(sv);
	PerlIO_printf(file, "\t");
   /* TODO might have an extra \" here */
	if (stash && (hvname = HvNAME_get(stash))) {
            PerlIO_printf(file, "\"%s\" :: \"",
                                  generic_pv_escape(tmp, hvname,
                                      HvNAMELEN(stash), HvNAMEUTF8(stash)));
        }
        PerlIO_printf(file, "%s\"\n",
                              generic_pv_escape( tmp, GvNAME(sv), GvNAMELEN(sv), GvNAMEUTF8(sv)));
d1442 1
a1442 4
/* NOTE: this structure is mostly duplicative of one generated by
 * 'make regen' in regnodes.h - perhaps we should somehow integrate
 * the two. - Yves */
const struct flag_to_name regexp_extflags_names[] = {
d1448 6
a1453 1
    {RXf_IS_ANCHORED,     "IS_ANCHORED,"},
d1456 2
a1472 20
/* NOTE: this structure is mostly duplicative of one generated by
 * 'make regen' in regnodes.h - perhaps we should somehow integrate
 * the two. - Yves */
const struct flag_to_name regexp_core_intflags_names[] = {
    {PREGf_SKIP,            "SKIP,"},
    {PREGf_IMPLICIT,        "IMPLICIT,"},
    {PREGf_NAUGHTY,         "NAUGHTY,"},
    {PREGf_VERBARG_SEEN,    "VERBARG_SEEN,"},
    {PREGf_CUTGROUP_SEEN,   "CUTGROUP_SEEN,"},
    {PREGf_USE_RE_EVAL,     "USE_RE_EVAL,"},
    {PREGf_NOSCAN,          "NOSCAN,"},
    {PREGf_CANY_SEEN,       "CANY_SEEN,"},
    {PREGf_GPOS_SEEN,       "GPOS_SEEN,"},
    {PREGf_GPOS_FLOAT,      "GPOS_FLOAT,"},
    {PREGf_ANCH_BOL,        "ANCH_BOL,"},
    {PREGf_ANCH_MBOL,       "ANCH_MBOL,"},
    {PREGf_ANCH_SBOL,       "ANCH_SBOL,"},
    {PREGf_ANCH_GPOS,       "ANCH_GPOS,"},
};

d1516 1
a1516 2
    if (flags & SVp_SCREAM && type != SVt_PVHV && !isGV_with_GP(sv)
			   && type != SVt_PVAV) {
a1563 1
	if (AvPAD_NAMELIST(sv))	sv_catpvs(d, "NAMELIST,");
d1661 1
a1661 2
    if ((type <= SVt_PVLV && !isGV_with_GP(sv))
     || (type == SVt_PVIO && IoFLAGS(sv) & IOf_FAKE_DIRP)) {
d1680 6
a1685 15
            if (type == SVt_INVLIST) {
		PerlIO_printf(file, "\n");
                /* 4 blanks indents 2 beyond the PV, etc */
                _invlist_dump(file, level, "    ", sv);
            }
            else {
                PerlIO_printf(file, "%s", pv_display(d, ptr, SvCUR(sv),
                                                     re ? 0 : SvLEN(sv),
                                                     pvlim));
                if (SvUTF8(sv)) /* the 6?  \x{....} */
                    PerlIO_printf(file, " [UTF8 \"%s\"]",
                                         sv_uni_display(d, sv, 6 * SvCUR(sv),
                                                        UNI_DISPLAY_QQ));
                PerlIO_printf(file, "\n");
            }
a1704 3
	} else if (SvTYPE(sv) == SVt_PVAV && AvPAD_NAMELIST(sv)) {
	    Perl_dump_indent(aTHX_ level, file, "  MAXNAMED = %"UVuf"\n",
				   (UV)PadnamelistMAXNAMED(sv));
d1713 2
d1732 1
a1732 5
	/* arylen is stored in magic, and padnamelists use SvMAGIC for
	   something else. */
	if (!AvPAD_NAMELIST(sv))
	    Perl_dump_indent(aTHX_ level, file, "  ARYLEN = 0x%"UVxf"\n",
				   SvMAGIC(sv) ? PTR2UV(AvARYLEN(sv)) : 0);
d1738 3
a1740 3
	if (nest < maxnest && av_tindex(MUTABLE_AV(sv)) >= 0) {
	    SSize_t count;
	    for (count = 0; count <=  av_tindex(MUTABLE_AV(sv)) && count < maxnest; count++) {
d1749 1
a1749 7
    case SVt_PVHV: {
	U32 usedkeys;
        if (SvOOK(sv)) {
            struct xpvhv_aux *const aux = HvAUX(sv);
            Perl_dump_indent(aTHX_ level, file, "  AUX_FLAGS = %"UVuf"\n",
                             (UV)aux->xhv_aux_flags);
        }
d1751 1
a1751 2
	usedkeys = HvUSEDKEYS(sv);
	if (HvARRAY(sv) && usedkeys) {
d1754 1
a1754 1
#define FREQ_MAX ((int)(C_ARRAY_LENGTH(freq) - 1))
d1757 1
a1757 1
	    U32 pow2 = 2, keys = usedkeys;
d1799 1
a1799 1
	    theoret = usedkeys;
d1805 2
a1806 25
	Perl_dump_indent(aTHX_ level, file, "  KEYS = %"IVdf"\n", (IV)usedkeys);
        {
            STRLEN count = 0;
            HE **ents = HvARRAY(sv);

            if (ents) {
                HE *const *const last = ents + HvMAX(sv);
                count = last + 1 - ents;
                
                do {
                    if (!*ents)
                        --count;
                } while (++ents <= last);
            }

            if (SvOOK(sv)) {
                struct xpvhv_aux *const aux = HvAUX(sv);
                Perl_dump_indent(aTHX_ level, file, "  FILL = %"UVuf
                                 " (cached = %"UVuf")\n",
                                 (UV)count, (UV)aux->xhv_fill_lazy);
            } else {
                Perl_dump_indent(aTHX_ level, file, "  FILL = %"UVuf"\n",
                                 (UV)count);
            }
        }
d1827 2
a1828 6
	    if (hvname) {
          SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
     Perl_dump_indent(aTHX_ level, file, "  NAME = \"%s\"\n",
                                       generic_pv_escape( tmpsv, hvname,
                                           HvNAMELEN(sv), HvNAMEUTF8(sv)));
        }
d1850 4
a1853 4
			if (HEK_LEN(*hekp)) {
             SV *tmp = newSVpvs_flags("", SVs_TEMP);
			    Perl_sv_catpvf(aTHX_ names, ", \"%s\"",
                              generic_pv_escape(tmp, HEK_KEY(*hekp), HEK_LEN(*hekp), HEK_UTF8(*hekp)));
d1864 1
a1864 3
		else {
                    SV * const tmp = newSVpvs_flags("", SVs_TEMP);
                    const char *const hvename = HvENAME_get(sv);
d1866 2
a1867 4
		     level, file, "  ENAME = \"%s\"\n",
                     generic_pv_escape(tmp, hvename,
                                       HvENAMELEN_get(sv), HvENAMEUTF8(sv)));
                }
d1876 4
a1879 5
		SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
		Perl_dump_indent(aTHX_ level, file, "  MRO_WHICH = \"%s\" (0x%"UVxf")\n",
				 generic_pv_escape( tmpsv, meta->mro_which->name,
                                meta->mro_which->length,
                                (meta->mro_which->kflags & HVhek_UTF8)),
a1945 1
    } /* case SVt_PVHV */
d1949 1
a1949 2
	    SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
       STRLEN len;
d1951 2
a1952 2
	    Perl_dump_indent(aTHX_ level, file, "  AUTOLOAD = \"%s\"\n",
			     generic_pv_escape(tmpsv, name, len, SvUTF8(sv)));
d1955 2
a1956 5
       SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
       const char *const proto = CvPROTO(sv);
	    Perl_dump_indent(aTHX_ level, file, "  PROTOTYPE = \"%s\"\n",
			     generic_pv_escape(tmpsv, proto, CvPROTOLEN(sv),
                                SvUTF8(sv)));
d2009 1
a2009 7
			 : CvGV(outside) ?
			     generic_pv_escape(
			         newSVpvs_flags("", SVs_TEMP),
			         GvNAME(CvGV(outside)),
			         GvNAMELEN(CvGV(outside)),
			         GvNAMEUTF8(CvGV(outside)))
			 : "UNDEFINED"));
d2030 1
a2030 7
       {
          SV* tmpsv = newSVpvs_flags("", SVs_TEMP);
          Perl_dump_indent(aTHX_ level, file, "  NAME = \"%s\"\n",
                    generic_pv_escape(tmpsv, GvNAME(sv),
                                      GvNAMELEN(sv),
                                      GvNAMEUTF8(sv)));
       }
d2099 1
a2099 2

#define SV_SET_STRINGIFY_REGEXP_FLAGS(d,flags,names) STMT_START { \
d2101 1
a2101 1
            append_flags(d, flags, names);     \
d2107 1
a2107 1
            SV_SET_STRINGIFY_REGEXP_FLAGS(d,r->compflags,regexp_extflags_names);
d2111 1
a2111 1
            SV_SET_STRINGIFY_REGEXP_FLAGS(d,r->extflags,regexp_extflags_names);
d2114 1
d2116 1
a2116 8
            Perl_dump_indent(aTHX_ level, file, "  ENGINE = 0x%"UVxf" (%s)\n",
                                PTR2UV(r->engine), (r->engine == &PL_core_reg_engine) ? "STANDARD" : "PLUG-IN" );
            if (r->engine == &PL_core_reg_engine) {
                SV_SET_STRINGIFY_REGEXP_FLAGS(d,r->intflags,regexp_core_intflags_names);
                Perl_dump_indent(aTHX_ level, file, "  INTFLAGS = 0x%"UVxf" (%s)\n",
                                (UV)(r->intflags), SvPVX_const(d));
            } else {
                Perl_dump_indent(aTHX_ level, file, "  INTFLAGS = 0x%"UVxf"\n",
a2117 2
            }
#undef SV_SET_STRINGIFY_REGEXP_FLAGS
d2144 2
a2147 3
	    if (nest < maxnest && r->mother_re)
		do_sv_dump(level+1, file, (SV *)r->mother_re, nest+1,
			   maxnest, dumpops, pvlim);
a2167 10
/*
=for apidoc sv_dump

Dumps the contents of an SV to the C<STDERR> filehandle.

For an example of its output, see L<Devel::Peek>.

=cut
*/

a2191 3
#ifdef PERL_TRACE_OPS
        ++PL_op_exec_cnt[PL_op->op_type];
#endif
d2549 56
a2604 6
        if (isCNTRL_L1(c)
            && c != '\t'
            && c != '\n'
            && c != '\r'
            && c != LATIN1_TO_NATIVE(0x85))
        {
d2606 1
a2606 2
        }
        else switch (c) {
d2621 1
a2621 1
		if (! isPRINT(c)) {
d2712 1
a2712 1
	SSize_t ix;
d2774 2
a2775 2
    case SVt_INVLIST:
	sv_catpv(t, " DUMMY=\"");
@


1.1.1.16
log
@Import perl-5.24.2
@
text
@a22 2

=head1 Display and Dump functions
d95 3
a97 6
Escapes at most the first C<count> chars of C<pv> and puts the results into
C<dsv> such that the size of the escaped string will not exceed C<max> chars
and will not contain any incomplete escape sequences.  The number of bytes
escaped will be returned in the C<STRLEN *escaped> parameter if it is not null.
When the C<dsv> parameter is null no escaping actually occurs, but the number
of bytes that would be escaped were it not null will be calculated.
d99 1
a99 1
If flags contains C<PERL_PV_ESCAPE_QUOTE> then any double quotes in the string
d103 1
a103 1
but when C<PERL_PV_ESCAPE_NOCLEAR> is set this will not occur.
d105 3
a107 3
If C<PERL_PV_ESCAPE_UNI> is set then the input string is treated as UTF-8
if C<PERL_PV_ESCAPE_UNI_DETECT> is set then the input string is scanned
using C<is_utf8_string()> to determine if it is UTF-8.
d109 2
a110 2
If C<PERL_PV_ESCAPE_ALL> is set then all input chars will be output
using C<\x01F1> style escapes, otherwise if C<PERL_PV_ESCAPE_NONASCII> is set, only
d114 1
a114 1
Otherwise, if C<PERL_PV_ESCAPE_NOBACKSLASH>
d118 1
a118 1
If C<PERL_PV_ESCAPE_FIRSTCHAR> is set then only the first char of the
d124 3
a126 3
If C<PERL_PV_ESCAPE_RE> is set then the escape char used will be a C<"%"> and
not a C<"\\">.  This is because regexes very often contain backslashed
sequences, whereas C<"%"> is not a particularly common character in patterns.
d128 1
a128 1
Returns a pointer to the escaped text as held by C<dsv>.
d145 1
a145 1
    bool isuni= flags & PERL_PV_ESCAPE_UNI ? 1 : 0; /* is this UTF-8 */
d152 1
a152 1
    if (dsv && !(flags & PERL_PV_ESCAPE_NOCLEAR)) {
d184 1
a184 1
		case '\\' : /* FALLTHROUGH */
d222 1
a222 2
            if (dsv)
                sv_catpvn(dsv, octbuf, chsize);
d231 1
a231 2
            if (dsv)
                Perl_sv_catpvf( aTHX_ dsv, "%c", c);
d239 1
a239 1
    return dsv ? SvPVX(dsv) : NULL;
d245 1
a245 1
C<pv_escape()> and supporting quoting and ellipses.
d247 1
a247 1
If the C<PERL_PV_PRETTY_QUOTE> flag is set then the result will be
d249 1
a249 1
if the C<PERL_PV_PRETTY_LTGT> flag is set then the result be wrapped in
d252 1
a252 1
If the C<PERL_PV_PRETTY_ELLIPSES> flag is set and not all characters in
d256 2
a257 2
If C<start_color> is non-null then it will be inserted after the opening
quote (if there is one) but before the escaped text.  If C<end_color>
d261 1
a261 1
Returns a pointer to the prettified text as held by C<dsv>.
d271 1
a271 2
    const U8 *quotes = (U8*)((flags & PERL_PV_PRETTY_QUOTE) ? "\"\"" :
                             (flags & PERL_PV_PRETTY_LTGT)  ? "<>" : NULL);
a272 2
    STRLEN max_adjust= 0;
    STRLEN orig_cur;
d277 2
a278 2
        /* This won't alter the UTF-8 flag */
        sv_setpvs(dsv, "");
a279 1
    orig_cur= SvCUR(dsv);
d281 4
a284 2
    if ( quotes )
        Perl_sv_catpvf(aTHX_ dsv, "%c", quotes[0]);
d288 3
a290 13

    if ((flags & PERL_PV_PRETTY_EXACTSIZE)) {
        if (quotes)
            max_adjust += 2;
        assert(max > max_adjust);
        pv_escape( NULL, str, count, max - max_adjust, &escaped, flags );
        if ( (flags & PERL_PV_PRETTY_ELLIPSES) && ( escaped < count ) )
            max_adjust += 3;
        assert(max > max_adjust);
    }

    pv_escape( dsv, str, count, max - max_adjust, &escaped, flags | PERL_PV_ESCAPE_NOCLEAR );

d294 4
a297 2
    if ( quotes )
        Perl_sv_catpvf(aTHX_ dsv, "%c", quotes[1]);
a300 5

    if ((flags & PERL_PV_PRETTY_EXACTSIZE)) {
        while( SvCUR(dsv) - orig_cur < max )
            sv_catpvs(dsv," ");
    }
d458 1
a458 1
	STORE_LC_NUMERIC_UNDERLYING_SET_STANDARD();
d460 1
a460 1
	RESTORE_LC_NUMERIC_UNDERLYING();
d474 1
a474 1
    if (TAINTING_get && sv && SvTAINTED(sv))
d496 1
d521 2
d547 1
d557 1
a557 4
	    GV * gv = (GV *)HeVAL(entry);
            if (SvROK(gv) && SvTYPE(SvRV(gv)) == SVt_PVCV)
                /* unfake a fake GV */
                (void)CvGV(SvRV(gv));
d626 1
d648 2
a649 2
	Perl_dump_indent(aTHX_ level, file, "PMf_PRE %c%.*s%c%s\n",
	     ch,(int)RX_PRELEN(PM_GETRE(pm)), RX_PRECOMP(PM_GETRE(pm)), ch,
a756 4




d766 247
d1017 1
d1042 24
d1074 2
a1075 86
    if (o->op_flags || o->op_slabbed || o->op_savefree || o->op_static) {
        SV * const tmpsv = newSVpvs("");
        switch (o->op_flags & OPf_WANT) {
        case OPf_WANT_VOID:
            sv_catpv(tmpsv, ",VOID");
            break;
        case OPf_WANT_SCALAR:
            sv_catpv(tmpsv, ",SCALAR");
            break;
        case OPf_WANT_LIST:
            sv_catpv(tmpsv, ",LIST");
            break;
        default:
            sv_catpv(tmpsv, ",UNKNOWN");
            break;
        }
        append_flags(tmpsv, o->op_flags, op_flags_names);
        if (o->op_slabbed)  sv_catpvs(tmpsv, ",SLABBED");
        if (o->op_savefree) sv_catpvs(tmpsv, ",SAVEFREE");
        if (o->op_static)   sv_catpvs(tmpsv, ",STATIC");
        if (o->op_folded)   sv_catpvs(tmpsv, ",FOLDED");
        if (o->op_moresib)  sv_catpvs(tmpsv, ",MORESIB");
        Perl_dump_indent(aTHX_ level, file, "FLAGS = (%s)\n",
                         SvCUR(tmpsv) ? SvPVX_const(tmpsv) + 1 : "");
    }

    if (o->op_private) {
        U16 oppriv = o->op_private;
        I16 op_ix = PL_op_private_bitdef_ix[o->op_type];
        SV * tmpsv = NULL;

        if (op_ix != -1) {
            U16 stop = 0;
            tmpsv = newSVpvs("");
            for (; !stop; op_ix++) {
                U16 entry = PL_op_private_bitdefs[op_ix];
                U16 bit = (entry >> 2) & 7;
                U16 ix = entry >> 5;

                stop = (entry & 1);

                if (entry & 2) {
                    /* bitfield */
                    I16 const *p = &PL_op_private_bitfields[ix];
                    U16 bitmin = (U16) *p++;
                    I16 label = *p++;
                    I16 enum_label;
                    U16 mask = 0;
                    U16 i;
                    U16 val;

                    for (i = bitmin; i<= bit; i++)
                        mask |= (1<<i);
                    bit = bitmin;
                    val = (oppriv & mask);

                    if (   label != -1
                        && PL_op_private_labels[label] == '-'
                        && PL_op_private_labels[label+1] == '\0'
                    )
                        /* display as raw number */
                        continue;

                    oppriv -= val;
                    val >>= bit;
                    enum_label = -1;
                    while (*p != -1) {
                        if (val == *p++) {
                            enum_label = *p;
                            break;
                        }
                        p++;
                    }
                    if (val == 0 && enum_label == -1)
                        /* don't display anonymous zero values */
                        continue;

                    sv_catpv(tmpsv, ",");
                    if (label != -1) {
                        sv_catpv(tmpsv, &PL_op_private_labels[label]);
                        sv_catpv(tmpsv, "=");
                    }
                    if (enum_label == -1)
                        Perl_sv_catpvf(aTHX_ tmpsv, "0x%"UVxf, (UV)val);
                    else
                        sv_catpv(tmpsv, &PL_op_private_labels[enum_label]);
d1077 38
a1114 23
                }
                else {
                    /* bit flag */
                    if (   oppriv & (1<<bit)
                        && !(PL_op_private_labels[ix] == '-'
                             && PL_op_private_labels[ix+1] == '\0'))
                    {
                        oppriv -= (1<<bit);
                        sv_catpv(tmpsv, ",");
                        sv_catpv(tmpsv, &PL_op_private_labels[ix]);
                    }
                }
            }
            if (oppriv) {
                sv_catpv(tmpsv, ",");
                Perl_sv_catpvf(aTHX_ tmpsv, "0x%"UVxf, (UV)oppriv);
            }
        }
	if (tmpsv && SvCUR(tmpsv)) {
            Perl_dump_indent(aTHX_ level, file, "PRIVATE = (%s)\n", SvPVX_const(tmpsv) + 1);
	} else
            Perl_dump_indent(aTHX_ level, file, "PRIVATE = (0x%"UVxf")\n",
                             (UV)oppriv);
d1116 1
d1131 5
a1145 13

    case OP_MULTIDEREF:
    {
        UNOP_AUX_item *items = cUNOP_AUXo->op_aux;
        UV i, count = items[-1].uv;

	Perl_dump_indent(aTHX_ level, file, "ARGS = \n");
        for (i=0; i < count;  i++)
            Perl_dump_indent(aTHX_ level+1, file, "%"UVuf" => 0x%"UVxf"\n",
                                    i, items[i].uv);
	break;
    }

a1148 3
    case OP_METHOD_SUPER:
    case OP_METHOD_REDIR:
    case OP_METHOD_REDIR_SUPER:
d1152 1
a1152 1
	Perl_dump_indent(aTHX_ level, file, "SV = %s\n", SvPEEK(cMETHOPx_meth(o)));
a1154 4
    case OP_NULL:
	if (o->op_targ != OP_NEXTSTATE && o->op_targ != OP_DBSTATE)
	    break;
	/* FALLTHROUGH */
a1178 2
        Perl_dump_indent(aTHX_ level, file, "SEQ = %u\n",
                         (unsigned int)cCOPo->cop_seq);
d1229 1
a1229 1
	for (kid = cUNOPo->op_first; kid; kid = OpSIBLING(kid))
d1257 3
d1276 1
a1276 1
    (void)PerlIO_putc(Perl_debug_log, '\n');
d1286 1
a1286 1
#include "mg_names.inc"
d1397 1
a1397 1
            (void)PerlIO_putc(file, '\n');
d1440 1
a1440 1
        (void)PerlIO_putc(file, '\n');
d1455 1
a1455 1
        (void)PerlIO_putc(file, '\n');
d1479 1
a1479 1
        (void)PerlIO_putc(file, '\n');
d1497 1
a1497 1
    {SVf_PROTECT, "PROTECT,"},
d1499 1
d1518 1
a1518 1
    {CVf_HASEVAL, "HASEVAL,"},
a1519 2
    {CVf_NAMED, "NAMED,"},
    {CVf_LEXICAL, "LEXICAL,"},
a1526 1
    {SVf_AMAGIC, "OVERLOAD,"},
d1534 1
a1551 1
    {RXf_PMf_EXTENDED_MORE, "PMf_EXTENDED_MORE,"},
a1552 1
    {RXf_PMf_NOCAPTURE,   "PMf_NOCAPURE,"},
d1582 1
d1585 1
a1590 10
/* Perl_do_sv_dump():
 *
 * level:   amount to indent the output
 * sv:      the object to dump
 * nest:    the current level of recursion
 * maxnest: the maximum allowed level of recursion
 * dumpops: if true, also dump the ops associated with a CV
 * pvlim:   limit on the length of any strings that are output
 * */

d1594 1
d1618 3
a1620 1
    if ((flags & SVs_PADSTALE))
d1622 3
a1624 1
    if ((flags & SVs_PADTMP))
d1626 2
a1632 1
    if (flags & SVf_IsCOW && type != SVt_PVHV) sv_catpvs(d, "IsCOW,");
d1667 1
a1667 1
	/* FALLTHROUGH */
d1676 5
a1680 1
	/* FALLTHROUGH */
d1683 1
d1734 3
d1741 7
a1747 1
	(void)PerlIO_putc(file, '\n');
d1750 7
a1756 1
    if ((type >= SVt_PVNV && type != SVt_PVAV && type != SVt_PVHV
d1760 8
a1767 3
	STORE_LC_NUMERIC_UNDERLYING_SET_STANDARD();
	Perl_dump_indent(aTHX_ level, file, "  NV = %.*" NVgf "\n", NV_DIG, SvNVX(sv));
	RESTORE_LC_NUMERIC_UNDERLYING();
d1820 1
a1820 1
#ifdef PERL_COPY_ON_WRITE
d1831 9
a1839 1
	if (SvMAGIC(sv))
d1841 1
d1860 1
a1860 1
            (void)PerlIO_putc(file, '\n');
d1863 4
a1866 1
	Perl_dump_indent(aTHX_ level, file, "  ARYLEN = 0x%"UVxf"\n",
d1924 1
a1924 1
	    (void)PerlIO_putc(file, ')');
d1943 1
a1943 1
	    (void)PerlIO_putc(file, '\n');
d1946 1
a1946 1
	(void)PerlIO_putc(file, '\n');
d1982 1
a1982 1
            (void)PerlIO_putc(file, '\n');
d2137 1
a2137 1
	/* FALLTHROUGH */
d2176 3
a2178 5
	if (!CvISXSUB(sv)) {
	    Perl_dump_indent(aTHX_ level, file, "  PADLIST = 0x%"UVxf"\n", PTR2UV(CvPADLIST(sv)));
	    if (nest < maxnest) {
		do_dump_pad(level+1, file, CvPADLIST(sv), 0);
	    }
a2179 2
	else
	    Perl_dump_indent(aTHX_ level, file, "  HSCXT = 0x%p\n", CvHSCXT(sv));
d2196 1
a2196 2
	if (CvOUTSIDE(sv)
	 && (nest < maxnest && (CvCLONE(sv) || CvCLONED(sv))))
d2208 1
a2208 1
	    if (isALPHA_FOLD_NE(LvTYPE(sv), 't'))
a2223 1
	Perl_dump_indent(aTHX_ level, file, "  FLAGS = 0x%"UVxf"\n", (UV)GvFLAGS(sv));
a2234 4
	Perl_dump_indent(aTHX_ level, file, "    GPFLAGS = 0x%"UVxf
					    " (%s)\n",
			       (UV)GvGPFLAGS(sv),
			       "");
d2237 1
d2382 2
d2395 1
a2406 2
            ENTER;
            SAVETMPS;
a2423 2
            FREETMPS;
            LEAVE;
d2426 1
a2426 1
        PERL_DTRACE_PROBE_OP(PL_op);
a2434 233

/* print the names of the n lexical vars starting at pad offset off */

STATIC void
S_deb_padvar(pTHX_ PADOFFSET off, int n, bool paren)
{
    PADNAME *sv;
    CV * const cv = deb_curcv(cxstack_ix);
    PADNAMELIST *comppad = NULL;
    int i;

    if (cv) {
        PADLIST * const padlist = CvPADLIST(cv);
        comppad = PadlistNAMES(padlist);
    }
    if (paren)
        PerlIO_printf(Perl_debug_log, "(");
    for (i = 0; i < n; i++) {
        if (comppad && (sv = padnamelist_fetch(comppad, off + i)))
            PerlIO_printf(Perl_debug_log, "%"PNf, PNfARG(sv));
        else
            PerlIO_printf(Perl_debug_log, "[%"UVuf"]",
                    (UV)(off+i));
        if (i < n - 1)
            PerlIO_printf(Perl_debug_log, ",");
    }
    if (paren)
        PerlIO_printf(Perl_debug_log, ")");
}


/* append to the out SV, the name of the lexical at offset off in the CV
 * cv */

static void
S_append_padvar(pTHX_ PADOFFSET off, CV *cv, SV *out, int n,
        bool paren, bool is_scalar)
{
    PADNAME *sv;
    PADNAMELIST *namepad = NULL;
    int i;

    if (cv) {
        PADLIST * const padlist = CvPADLIST(cv);
        namepad = PadlistNAMES(padlist);
    }

    if (paren)
        sv_catpvs_nomg(out, "(");
    for (i = 0; i < n; i++) {
        if (namepad && (sv = padnamelist_fetch(namepad, off + i)))
        {
            STRLEN cur = SvCUR(out);
            Perl_sv_catpvf(aTHX_ out, "[%"UTF8f,
                                 UTF8fARG(1, PadnameLEN(sv) - 1,
                                          PadnamePV(sv) + 1));
            if (is_scalar)
                SvPVX(out)[cur] = '$';
        }
        else
            Perl_sv_catpvf(aTHX_ out, "[%"UVuf"]", (UV)(off+i));
        if (i < n - 1)
            sv_catpvs_nomg(out, ",");
    }
    if (paren)
        sv_catpvs_nomg(out, "(");
}


static void
S_append_gv_name(pTHX_ GV *gv, SV *out)
{
    SV *sv;
    if (!gv) {
        sv_catpvs_nomg(out, "<NULLGV>");
        return;
    }
    sv = newSV(0);
    gv_fullname4(sv, gv, NULL, FALSE);
    Perl_sv_catpvf(aTHX_ out, "$%"SVf, SVfARG(sv));
    SvREFCNT_dec_NN(sv);
}

#ifdef USE_ITHREADS
#  define ITEM_SV(item) (comppad ? \
    *av_fetch(comppad, (item)->pad_offset, FALSE) : NULL);
#else
#  define ITEM_SV(item) UNOP_AUX_item_sv(item)
#endif


/* return a temporary SV containing a stringified representation of
 * the op_aux field of a MULTIDEREF op, associated with CV cv
 */

SV*
Perl_multideref_stringify(pTHX_ const OP *o, CV *cv)
{
    UNOP_AUX_item *items = cUNOP_AUXo->op_aux;
    UV actions = items->uv;
    SV *sv;
    bool last = 0;
    bool is_hash = FALSE;
    int derefs = 0;
    SV *out = newSVpvn_flags("",0,SVs_TEMP);
#ifdef USE_ITHREADS
    PAD *comppad;

    if (cv) {
        PADLIST *padlist = CvPADLIST(cv);
        comppad = PadlistARRAY(padlist)[1];
    }
    else
        comppad = NULL;
#endif

    PERL_ARGS_ASSERT_MULTIDEREF_STRINGIFY;

    while (!last) {
        switch (actions & MDEREF_ACTION_MASK) {

        case MDEREF_reload:
            actions = (++items)->uv;
            continue;
            NOT_REACHED; /* NOTREACHED */

        case MDEREF_HV_padhv_helem:
            is_hash = TRUE;
            /* FALLTHROUGH */
        case MDEREF_AV_padav_aelem:
            derefs = 1;
            S_append_padvar(aTHX_ (++items)->pad_offset, cv, out, 1, 0, 1);
            goto do_elem;
            NOT_REACHED; /* NOTREACHED */

        case MDEREF_HV_gvhv_helem:
            is_hash = TRUE;
            /* FALLTHROUGH */
        case MDEREF_AV_gvav_aelem:
            derefs = 1;
            items++;
            sv = ITEM_SV(items);
            S_append_gv_name(aTHX_ (GV*)sv, out);
            goto do_elem;
            NOT_REACHED; /* NOTREACHED */

        case MDEREF_HV_gvsv_vivify_rv2hv_helem:
            is_hash = TRUE;
            /* FALLTHROUGH */
        case MDEREF_AV_gvsv_vivify_rv2av_aelem:
            items++;
            sv = ITEM_SV(items);
            S_append_gv_name(aTHX_ (GV*)sv, out);
            goto do_vivify_rv2xv_elem;
            NOT_REACHED; /* NOTREACHED */

        case MDEREF_HV_padsv_vivify_rv2hv_helem:
            is_hash = TRUE;
            /* FALLTHROUGH */
        case MDEREF_AV_padsv_vivify_rv2av_aelem:
            S_append_padvar(aTHX_ (++items)->pad_offset, cv, out, 1, 0, 1);
            goto do_vivify_rv2xv_elem;
            NOT_REACHED; /* NOTREACHED */

        case MDEREF_HV_pop_rv2hv_helem:
        case MDEREF_HV_vivify_rv2hv_helem:
            is_hash = TRUE;
            /* FALLTHROUGH */
        do_vivify_rv2xv_elem:
        case MDEREF_AV_pop_rv2av_aelem:
        case MDEREF_AV_vivify_rv2av_aelem:
            if (!derefs++)
                sv_catpvs_nomg(out, "->");
        do_elem:
            if ((actions & MDEREF_INDEX_MASK)== MDEREF_INDEX_none) {
                sv_catpvs_nomg(out, "->");
                last = 1;
                break;
            }

            sv_catpvn_nomg(out, (is_hash ? "{" : "["), 1);
            switch (actions & MDEREF_INDEX_MASK) {
            case MDEREF_INDEX_const:
                if (is_hash) {
                    items++;
                    sv = ITEM_SV(items);
                    if (!sv)
                        sv_catpvs_nomg(out, "???");
                    else {
                        STRLEN cur;
                        char *s;
                        s = SvPV(sv, cur);
                        pv_pretty(out, s, cur, 30,
                                    NULL, NULL,
                                    (PERL_PV_PRETTY_NOCLEAR
                                    |PERL_PV_PRETTY_QUOTE
                                    |PERL_PV_PRETTY_ELLIPSES));
                    }
                }
                else
                    Perl_sv_catpvf(aTHX_ out, "%"IVdf, (++items)->iv);
                break;
            case MDEREF_INDEX_padsv:
                S_append_padvar(aTHX_ (++items)->pad_offset, cv, out, 1, 0, 1);
                break;
            case MDEREF_INDEX_gvsv:
                items++;
                sv = ITEM_SV(items);
                S_append_gv_name(aTHX_ (GV*)sv, out);
                break;
            }
            sv_catpvn_nomg(out, (is_hash ? "}" : "]"), 1);

            if (actions & MDEREF_FLAG_last)
                last = 1;
            is_hash = FALSE;

            break;

        default:
            PerlIO_printf(Perl_debug_log, "UNKNOWN(%d)",
                (int)(actions & MDEREF_ACTION_MASK));
            last = 1;
            break;

        } /* switch */

        actions >>= MDEREF_SHIFT;
    } /* while */
    return out;
}


d2438 2
d2460 1
a2460 1
	if (cGVOPo_gv && isGV(cGVOPo_gv)) {
d2462 5
a2470 8
	else if (cGVOPo_gv) {
	    SV * const sv = newSV(0);
	    assert(SvROK(cGVOPo_gv));
	    assert(SvTYPE(SvRV(cGVOPo_gv)) == SVt_PVCV);
	    PerlIO_printf(Perl_debug_log, "(cv ref: %s)",
		    SvPV_nolen_const(cv_name((CV *)SvRV(cGVOPo_gv),sv,0)));
	    SvREFCNT_dec_NN(sv);
	}
d2475 3
d2481 2
a2482 3
        S_deb_padvar(aTHX_ o->op_targ, 1, 1);
        break;

d2484 26
a2509 7
        S_deb_padvar(aTHX_ o->op_targ,
                        o->op_private & OPpPADRANGE_COUNTMASK, 1);
        break;

    case OP_MULTIDEREF:
        PerlIO_printf(Perl_debug_log, "(%"SVf")",
            SVfARG(multideref_stringify(o, deb_curcv(cxstack_ix))));
d2511 1
d2521 1
a2521 1
S_deb_curcv(pTHX_ I32 ix)
d2523 12
a2534 19
    PERL_SI *si = PL_curstackinfo;
    for (; ix >=0; ix--) {
        const PERL_CONTEXT * const cx = &(si->si_cxstack)[ix];

        if (CxTYPE(cx) == CXt_SUB || CxTYPE(cx) == CXt_FORMAT)
            return cx->blk_sub.cv;
        else if (CxTYPE(cx) == CXt_EVAL && !CxTRYBLOCK(cx))
            return cx->blk_eval.cv;
        else if (ix == 0 && si->si_type == PERLSI_MAIN)
            return PL_main_cv;
        else if (ix == 0 && CxTYPE(cx) == CXt_NULL
               && si->si_type == PERLSI_SORT)
        {
            /* fake sort sub; use CV of caller */
            si = si->si_prev;
            ix = si->si_cxix + 1;
        }
    }
    return NULL;
d2540 2
d2553 2
d2567 1
d2579 691
d3272 6
@


