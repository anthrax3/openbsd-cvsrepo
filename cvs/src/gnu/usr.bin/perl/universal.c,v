head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.6
	OPENBSD_6_2_BASE:1.18
	PERL_5_24_2:1.1.1.16
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.10
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.4
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	PERL_5_20_2:1.1.1.15
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.18
date	2017.02.05.00.31.54;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	cxJ08BvJA9Pt2PTM;

1.17
date	2014.11.17.20.56.48;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	QP75iYx42Uo7mMxO;

1.16
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.24.15.06.43;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.12.18.24.22;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.29.17.36.00;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.19.22.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.15.21.30.23;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.08.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.01;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.23;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.00;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.18.15.56.04;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.04.30;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.13;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.49.24;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.38.06;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.08.49;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.26;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.52;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.39;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.21.12.57;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.51;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.16.39;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.47.48;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.11;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.35;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.18;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.06.42;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.58.48;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.52.40;	author afresh1;	state Exp;
branches;
next	1.1.1.16;
commitid	B31cAbBIXiCqnL97;

1.1.1.16
date	2017.08.14.13.45.31;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@perl 5.004_04
@


1.18
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    universal.c
 *
 *    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
 *    2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * '"The roots of those mountains must be roots indeed; there must be
 *   great secrets buried there which have not been discovered since the
 *   beginning."'                   --Gandalf, relating Gollum's history
 *
 *     [p.54 of _The Lord of the Rings_, I/ii: "The Shadow of the Past"]
 */

/* This file contains the code that implements the functions in Perl's
 * UNIVERSAL package, such as UNIVERSAL->can().
 *
 * It is also used to store XS functions that need to be present in
 * miniperl for a lack of a better place to put them. It might be
 * clever to move them to separate XS files which would then be pulled
 * in by some to-be-written build process.
 */

#include "EXTERN.h"
#define PERL_IN_UNIVERSAL_C
#include "perl.h"

#if defined(USE_PERLIO)
#include "perliol.h" /* For the PERLIO_F_XXX */
#endif

/*
 * Contributed by Graham Barr  <Graham.Barr@@tiuk.ti.com>
 * The main guts of traverse_isa was actually copied from gv_fetchmeth
 */

STATIC bool
S_isa_lookup(pTHX_ HV *stash, const char * const name, STRLEN len, U32 flags)
{
    const struct mro_meta *const meta = HvMROMETA(stash);
    HV *isa = meta->isa;
    const HV *our_stash;

    PERL_ARGS_ASSERT_ISA_LOOKUP;

    if (!isa) {
	(void)mro_get_linear_isa(stash);
	isa = meta->isa;
    }

    if (hv_common(isa, NULL, name, len, ( flags & SVf_UTF8 ? HVhek_UTF8 : 0),
		  HV_FETCH_ISEXISTS, NULL, 0)) {
	/* Direct name lookup worked.  */
	return TRUE;
    }

    /* A stash/class can go by many names (ie. User == main::User), so 
       we use the HvENAME in the stash itself, which is canonical, falling
       back to HvNAME if necessary.  */
    our_stash = gv_stashpvn(name, len, flags);

    if (our_stash) {
	HEK *canon_name = HvENAME_HEK(our_stash);
	if (!canon_name) canon_name = HvNAME_HEK(our_stash);
	assert(canon_name);
	if (hv_common(isa, NULL, HEK_KEY(canon_name), HEK_LEN(canon_name),
		      HEK_FLAGS(canon_name),
		      HV_FETCH_ISEXISTS, NULL, HEK_HASH(canon_name))) {
	    return TRUE;
	}
    }

    return FALSE;
}

/*
=head1 SV Manipulation Functions

=for apidoc sv_derived_from_pvn

Returns a boolean indicating whether the SV is derived from the specified class
I<at the C level>.  To check derivation at the Perl level, call C<isa()> as a
normal Perl method.

Currently, the only significant value for C<flags> is SVf_UTF8.

=cut

=for apidoc sv_derived_from_sv

Exactly like L</sv_derived_from_pvn>, but takes the name string in the form
of an SV instead of a string/length pair.

=cut

*/

bool
Perl_sv_derived_from_sv(pTHX_ SV *sv, SV *namesv, U32 flags)
{
    char *namepv;
    STRLEN namelen;
    PERL_ARGS_ASSERT_SV_DERIVED_FROM_SV;
    namepv = SvPV(namesv, namelen);
    if (SvUTF8(namesv))
       flags |= SVf_UTF8;
    return sv_derived_from_pvn(sv, namepv, namelen, flags);
}

/*
=for apidoc sv_derived_from

Exactly like L</sv_derived_from_pv>, but doesn't take a C<flags> parameter.

=cut
*/

bool
Perl_sv_derived_from(pTHX_ SV *sv, const char *const name)
{
    PERL_ARGS_ASSERT_SV_DERIVED_FROM;
    return sv_derived_from_pvn(sv, name, strlen(name), 0);
}

/*
=for apidoc sv_derived_from_pv

Exactly like L</sv_derived_from_pvn>, but takes a nul-terminated string 
instead of a string/length pair.

=cut
*/


bool
Perl_sv_derived_from_pv(pTHX_ SV *sv, const char *const name, U32 flags)
{
    PERL_ARGS_ASSERT_SV_DERIVED_FROM_PV;
    return sv_derived_from_pvn(sv, name, strlen(name), flags);
}

bool
Perl_sv_derived_from_pvn(pTHX_ SV *sv, const char *const name, const STRLEN len, U32 flags)
{
    HV *stash;

    PERL_ARGS_ASSERT_SV_DERIVED_FROM_PVN;

    SvGETMAGIC(sv);

    if (SvROK(sv)) {
	const char *type;
        sv = SvRV(sv);
        type = sv_reftype(sv,0);
	if (type && strEQ(type,name))
	    return TRUE;
        if (!SvOBJECT(sv))
            return FALSE;
	stash = SvSTASH(sv);
    }
    else {
        stash = gv_stashsv(sv, 0);
    }

    if (stash && isa_lookup(stash, name, len, flags))
        return TRUE;

    stash = gv_stashpvs("UNIVERSAL", 0);
    return stash && isa_lookup(stash, name, len, flags);
}

/*
=for apidoc sv_does_sv

Returns a boolean indicating whether the SV performs a specific, named role.
The SV can be a Perl object or the name of a Perl class.

=cut
*/

#include "XSUB.h"

bool
Perl_sv_does_sv(pTHX_ SV *sv, SV *namesv, U32 flags)
{
    SV *classname;
    bool does_it;
    SV *methodname;
    dSP;

    PERL_ARGS_ASSERT_SV_DOES_SV;
    PERL_UNUSED_ARG(flags);

    ENTER;
    SAVETMPS;

    SvGETMAGIC(sv);

    if (!SvOK(sv) || !(SvROK(sv) || (SvPOK(sv) && SvCUR(sv)))) {
	LEAVE;
	return FALSE;
    }

    if (SvROK(sv) && SvOBJECT(SvRV(sv))) {
	classname = sv_ref(NULL,SvRV(sv),TRUE);
    } else {
	classname = sv;
    }

    if (sv_eq(classname, namesv)) {
	LEAVE;
	return TRUE;
    }

    PUSHMARK(SP);
    EXTEND(SP, 2);
    PUSHs(sv);
    PUSHs(namesv);
    PUTBACK;

    methodname = newSVpvs_flags("isa", SVs_TEMP);
    /* ugly hack: use the SvSCREAM flag so S_method_common
     * can figure out we're calling DOES() and not isa(),
     * and report eventual errors correctly. --rgs */
    SvSCREAM_on(methodname);
    call_sv(methodname, G_SCALAR | G_METHOD);
    SPAGAIN;

    does_it = SvTRUE( TOPs );
    FREETMPS;
    LEAVE;

    return does_it;
}

/*
=for apidoc sv_does

Like L</sv_does_pv>, but doesn't take a C<flags> parameter.

=cut
*/

bool
Perl_sv_does(pTHX_ SV *sv, const char *const name)
{
    PERL_ARGS_ASSERT_SV_DOES;
    return sv_does_sv(sv, newSVpvn_flags(name, strlen(name), SVs_TEMP), 0);
}

/*
=for apidoc sv_does_pv

Like L</sv_does_sv>, but takes a nul-terminated string instead of an SV.

=cut
*/


bool
Perl_sv_does_pv(pTHX_ SV *sv, const char *const name, U32 flags)
{
    PERL_ARGS_ASSERT_SV_DOES_PV;
    return sv_does_sv(sv, newSVpvn_flags(name, strlen(name), SVs_TEMP | flags), flags);
}

/*
=for apidoc sv_does_pvn

Like L</sv_does_sv>, but takes a string/length pair instead of an SV.

=cut
*/

bool
Perl_sv_does_pvn(pTHX_ SV *sv, const char *const name, const STRLEN len, U32 flags)
{
    PERL_ARGS_ASSERT_SV_DOES_PVN;

    return sv_does_sv(sv, newSVpvn_flags(name, len, flags | SVs_TEMP), flags);
}

/*
=for apidoc croak_xs_usage

A specialised variant of C<croak()> for emitting the usage message for xsubs

    croak_xs_usage(cv, "eee_yow");

works out the package name and subroutine name from C<cv>, and then calls
C<croak()>.  Hence if C<cv> is C<&ouch::awk>, it would call C<croak> as:

 Perl_croak(aTHX_ "Usage: %"SVf"::%"SVf"(%s)", "ouch" "awk",
                                                     "eee_yow");

=cut
*/

void
Perl_croak_xs_usage(const CV *const cv, const char *const params)
{
    /* Avoid CvGV as it requires aTHX.  */
    const GV *gv = CvNAMED(cv) ? NULL : cv->sv_any->xcv_gv_u.xcv_gv;

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) got_gv: {
	const HV *const stash = GvSTASH(gv);

	if (HvNAME_get(stash))
	    /* diag_listed_as: SKIPME */
	    Perl_croak_nocontext("Usage: %"HEKf"::%"HEKf"(%s)",
                                HEKfARG(HvNAME_HEK(stash)),
                                HEKfARG(GvNAME_HEK(gv)),
                                params);
	else
	    /* diag_listed_as: SKIPME */
	    Perl_croak_nocontext("Usage: %"HEKf"(%s)",
                                HEKfARG(GvNAME_HEK(gv)), params);
    } else {
        dTHX;
        if ((gv = CvGV(cv))) goto got_gv;

	/* Pants. I don't think that it should be possible to get here. */
	/* diag_listed_as: SKIPME */
	Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}

XS(XS_UNIVERSAL_isa); /* prototype to pass -Wmissing-prototypes */
XS(XS_UNIVERSAL_isa)
{
    dXSARGS;

    if (items != 2)
	croak_xs_usage(cv, "reference, kind");
    else {
	SV * const sv = ST(0);

	SvGETMAGIC(sv);

	if (!SvOK(sv) || !(SvROK(sv) || (SvPOK(sv) && SvCUR(sv))))
	    XSRETURN_UNDEF;

	ST(0) = boolSV(sv_derived_from_sv(sv, ST(1), 0));
	XSRETURN(1);
    }
}

XS(XS_UNIVERSAL_can); /* prototype to pass -Wmissing-prototypes */
XS(XS_UNIVERSAL_can)
{
    dXSARGS;
    SV   *sv;
    SV   *rv;
    HV   *pkg = NULL;
    GV   *iogv;

    if (items != 2)
	croak_xs_usage(cv, "object-ref, method");

    sv = ST(0);

    SvGETMAGIC(sv);

    /* Reject undef and empty string.  Note that the string form takes
       precedence here over the numeric form, as (!1)->foo treats the
       invocant as the empty string, though it is a dualvar. */
    if (!SvOK(sv) || (SvPOK(sv) && !SvCUR(sv)))
	XSRETURN_UNDEF;

    rv = &PL_sv_undef;

    if (SvROK(sv)) {
        sv = MUTABLE_SV(SvRV(sv));
        if (SvOBJECT(sv))
            pkg = SvSTASH(sv);
        else if (isGV_with_GP(sv) && GvIO(sv))
	    pkg = SvSTASH(GvIO(sv));
    }
    else if (isGV_with_GP(sv) && GvIO(sv))
        pkg = SvSTASH(GvIO(sv));
    else if ((iogv = gv_fetchsv_nomg(sv, 0, SVt_PVIO)) && GvIO(iogv))
        pkg = SvSTASH(GvIO(iogv));
    else {
        pkg = gv_stashsv(sv, 0);
        if (!pkg)
            pkg = gv_stashpvs("UNIVERSAL", 0);
    }

    if (pkg) {
	GV * const gv = gv_fetchmethod_sv_flags(pkg, ST(1), 0);
        if (gv && isGV(gv))
	    rv = sv_2mortal(newRV(MUTABLE_SV(GvCV(gv))));
    }

    ST(0) = rv;
    XSRETURN(1);
}

XS(XS_UNIVERSAL_DOES); /* prototype to pass -Wmissing-prototypes */
XS(XS_UNIVERSAL_DOES)
{
    dXSARGS;
    PERL_UNUSED_ARG(cv);

    if (items != 2)
	Perl_croak(aTHX_ "Usage: invocant->DOES(kind)");
    else {
	SV * const sv = ST(0);
	if (sv_does_sv( sv, ST(1), 0 ))
	    XSRETURN_YES;

	XSRETURN_NO;
    }
}

XS(XS_utf8_is_utf8); /* prototype to pass -Wmissing-prototypes */
XS(XS_utf8_is_utf8)
{
     dXSARGS;
     if (items != 1)
	 croak_xs_usage(cv, "sv");
     else {
	SV * const sv = ST(0);
	SvGETMAGIC(sv);
	    if (SvUTF8(sv))
		XSRETURN_YES;
	    else
		XSRETURN_NO;
     }
     XSRETURN_EMPTY;
}

XS(XS_utf8_valid); /* prototype to pass -Wmissing-prototypes */
XS(XS_utf8_valid)
{
     dXSARGS;
     if (items != 1)
	 croak_xs_usage(cv, "sv");
    else {
	SV * const sv = ST(0);
	STRLEN len;
	const char * const s = SvPV_const(sv,len);
	if (!SvUTF8(sv) || is_utf8_string((const U8*)s,len))
	    XSRETURN_YES;
	else
	    XSRETURN_NO;
    }
     XSRETURN_EMPTY;
}

XS(XS_utf8_encode); /* prototype to pass -Wmissing-prototypes */
XS(XS_utf8_encode)
{
    dXSARGS;
    if (items != 1)
	croak_xs_usage(cv, "sv");
    sv_utf8_encode(ST(0));
    SvSETMAGIC(ST(0));
    XSRETURN_EMPTY;
}

XS(XS_utf8_decode); /* prototype to pass -Wmissing-prototypes */
XS(XS_utf8_decode)
{
    dXSARGS;
    if (items != 1)
	croak_xs_usage(cv, "sv");
    else {
	SV * const sv = ST(0);
	bool RETVAL;
	SvPV_force_nolen(sv);
	RETVAL = sv_utf8_decode(sv);
	SvSETMAGIC(sv);
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}

XS(XS_utf8_upgrade); /* prototype to pass -Wmissing-prototypes */
XS(XS_utf8_upgrade)
{
    dXSARGS;
    if (items != 1)
	croak_xs_usage(cv, "sv");
    else {
	SV * const sv = ST(0);
	STRLEN	RETVAL;
	dXSTARG;

	RETVAL = sv_utf8_upgrade(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_utf8_downgrade); /* prototype to pass -Wmissing-prototypes */
XS(XS_utf8_downgrade)
{
    dXSARGS;
    if (items < 1 || items > 2)
	croak_xs_usage(cv, "sv, failok=0");
    else {
	SV * const sv = ST(0);
        const bool failok = (items < 2) ? 0 : SvTRUE(ST(1)) ? 1 : 0;
        const bool RETVAL = sv_utf8_downgrade(sv, failok);

	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}

XS(XS_utf8_native_to_unicode); /* prototype to pass -Wmissing-prototypes */
XS(XS_utf8_native_to_unicode)
{
 dXSARGS;
 const UV uv = SvUV(ST(0));

 if (items > 1)
     croak_xs_usage(cv, "sv");

 ST(0) = sv_2mortal(newSVuv(NATIVE_TO_UNI(uv)));
 XSRETURN(1);
}

XS(XS_utf8_unicode_to_native); /* prototype to pass -Wmissing-prototypes */
XS(XS_utf8_unicode_to_native)
{
 dXSARGS;
 const UV uv = SvUV(ST(0));

 if (items > 1)
     croak_xs_usage(cv, "sv");

 ST(0) = sv_2mortal(newSVuv(UNI_TO_NATIVE(uv)));
 XSRETURN(1);
}

XS(XS_Internals_SvREADONLY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Internals_SvREADONLY)	/* This is dangerous stuff. */
{
    dXSARGS;
    SV * const svz = ST(0);
    SV * sv;
    PERL_UNUSED_ARG(cv);

    /* [perl #77776] - called as &foo() not foo() */
    if (!SvROK(svz))
        croak_xs_usage(cv, "SCALAR[, ON]");

    sv = SvRV(svz);

    if (items == 1) {
	 if (SvREADONLY(sv))
	     XSRETURN_YES;
	 else
	     XSRETURN_NO;
    }
    else if (items == 2) {
	if (SvTRUE(ST(1))) {
	    SvFLAGS(sv) |= SVf_READONLY;
	    XSRETURN_YES;
	}
	else {
	    /* I hope you really know what you are doing. */
	    SvFLAGS(sv) &=~ SVf_READONLY;
	    XSRETURN_NO;
	}
    }
    XSRETURN_UNDEF; /* Can't happen. */
}

XS(XS_constant__make_const); /* prototype to pass -Wmissing-prototypes */
XS(XS_constant__make_const)	/* This is dangerous stuff. */
{
    dXSARGS;
    SV * const svz = ST(0);
    SV * sv;
    PERL_UNUSED_ARG(cv);

    /* [perl #77776] - called as &foo() not foo() */
    if (!SvROK(svz) || items != 1)
        croak_xs_usage(cv, "SCALAR");

    sv = SvRV(svz);

    SvREADONLY_on(sv);
    if (SvTYPE(sv) == SVt_PVAV && AvFILLp(sv) != -1) {
	/* for constant.pm; nobody else should be calling this
	   on arrays anyway. */
	SV **svp;
	for (svp = AvARRAY(sv) + AvFILLp(sv)
	   ; svp >= AvARRAY(sv)
	   ; --svp)
	    if (*svp) SvPADTMP_on(*svp);
    }
    XSRETURN(0);
}

XS(XS_Internals_SvREFCNT); /* prototype to pass -Wmissing-prototypes */
XS(XS_Internals_SvREFCNT)	/* This is dangerous stuff. */
{
    dXSARGS;
    SV * const svz = ST(0);
    SV * sv;
    U32 refcnt;
    PERL_UNUSED_ARG(cv);

    /* [perl #77776] - called as &foo() not foo() */
    if ((items != 1 && items != 2) || !SvROK(svz))
        croak_xs_usage(cv, "SCALAR[, REFCOUNT]");

    sv = SvRV(svz);

         /* I hope you really know what you are doing. */
    /* idea is for SvREFCNT(sv) to be accessed only once */
    refcnt = items == 2 ?
                /* we free one ref on exit */
                (SvREFCNT(sv) = SvUV(ST(1)) + 1)
                : SvREFCNT(sv);
    XSRETURN_UV(refcnt - 1); /* Minus the ref created for us. */        

}

XS(XS_Internals_hv_clear_placehold); /* prototype to pass -Wmissing-prototypes */
XS(XS_Internals_hv_clear_placehold)
{
    dXSARGS;

    if (items != 1 || !SvROK(ST(0)))
	croak_xs_usage(cv, "hv");
    else {
	HV * const hv = MUTABLE_HV(SvRV(ST(0)));
	hv_clear_placeholders(hv);
	XSRETURN(0);
    }
}

XS(XS_PerlIO_get_layers); /* prototype to pass -Wmissing-prototypes */
XS(XS_PerlIO_get_layers)
{
    dXSARGS;
    if (items < 1 || items % 2 == 0)
	croak_xs_usage(cv, "filehandle[,args]");
#if defined(USE_PERLIO)
    {
	SV *	sv;
	GV *	gv;
	IO *	io;
	bool	input = TRUE;
	bool	details = FALSE;

	if (items > 1) {
	     SV * const *svp;
	     for (svp = MARK + 2; svp <= SP; svp += 2) {
		  SV * const * const varp = svp;
		  SV * const * const valp = svp + 1;
		  STRLEN klen;
		  const char * const key = SvPV_const(*varp, klen);

		  switch (*key) {
		  case 'i':
		       if (klen == 5 && memEQ(key, "input", 5)) {
			    input = SvTRUE(*valp);
			    break;
		       }
		       goto fail;
		  case 'o': 
		       if (klen == 6 && memEQ(key, "output", 6)) {
			    input = !SvTRUE(*valp);
			    break;
		       }
		       goto fail;
		  case 'd':
		       if (klen == 7 && memEQ(key, "details", 7)) {
			    details = SvTRUE(*valp);
			    break;
		       }
		       goto fail;
		  default:
		  fail:
		       Perl_croak(aTHX_
				  "get_layers: unknown argument '%s'",
				  key);
		  }
	     }

	     SP -= (items - 1);
	}

	sv = POPs;
	gv = MAYBE_DEREF_GV(sv);

	if (!gv && !SvROK(sv))
	    gv = gv_fetchsv_nomg(sv, 0, SVt_PVIO);

	if (gv && (io = GvIO(gv))) {
	     AV* const av = PerlIO_get_layers(aTHX_ input ?
					IoIFP(io) : IoOFP(io));
	     SSize_t i;
	     const SSize_t last = av_tindex(av);
	     SSize_t nitem = 0;
	     
	     for (i = last; i >= 0; i -= 3) {
		  SV * const * const namsvp = av_fetch(av, i - 2, FALSE);
		  SV * const * const argsvp = av_fetch(av, i - 1, FALSE);
		  SV * const * const flgsvp = av_fetch(av, i,     FALSE);

		  const bool namok = namsvp && *namsvp && SvPOK(*namsvp);
		  const bool argok = argsvp && *argsvp && SvPOK(*argsvp);
		  const bool flgok = flgsvp && *flgsvp && SvIOK(*flgsvp);

		  EXTEND(SP, 3); /* Three is the max in all branches: better check just once */
		  if (details) {
		      /* Indents of 5? Yuck.  */
		      /* We know that PerlIO_get_layers creates a new SV for
			 the name and flags, so we can just take a reference
			 and "steal" it when we free the AV below.  */
		       PUSHs(namok
			      ? sv_2mortal(SvREFCNT_inc_simple_NN(*namsvp))
			      : &PL_sv_undef);
		       PUSHs(argok
			      ? newSVpvn_flags(SvPVX_const(*argsvp),
					       SvCUR(*argsvp),
					       (SvUTF8(*argsvp) ? SVf_UTF8 : 0)
					       | SVs_TEMP)
			      : &PL_sv_undef);
		       PUSHs(flgok
			      ? sv_2mortal(SvREFCNT_inc_simple_NN(*flgsvp))
			      : &PL_sv_undef);
		       nitem += 3;
		  }
		  else {
		       if (namok && argok)
			    PUSHs(sv_2mortal(Perl_newSVpvf(aTHX_ "%"SVf"(%"SVf")",
						 SVfARG(*namsvp),
						 SVfARG(*argsvp))));
		       else if (namok)
			    PUSHs(sv_2mortal(SvREFCNT_inc_simple_NN(*namsvp)));
		       else
			    PUSHs(&PL_sv_undef);
		       nitem++;
		       if (flgok) {
			    const IV flags = SvIVX(*flgsvp);

			    if (flags & PERLIO_F_UTF8) {
				 PUSHs(newSVpvs_flags("utf8", SVs_TEMP));
				 nitem++;
			    }
		       }
		  }
	     }

	     SvREFCNT_dec(av);

	     XSRETURN(nitem);
	}
    }
#endif

    XSRETURN(0);
}


XS(XS_re_is_regexp); /* prototype to pass -Wmissing-prototypes */
XS(XS_re_is_regexp)
{
    dXSARGS;
    PERL_UNUSED_VAR(cv);

    if (items != 1)
	croak_xs_usage(cv, "sv");

    if (SvRXOK(ST(0))) {
        XSRETURN_YES;
    } else {
        XSRETURN_NO;
    }
}

XS(XS_re_regnames_count); /* prototype to pass -Wmissing-prototypes */
XS(XS_re_regnames_count)
{
    REGEXP *rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;
    SV * ret;
    dXSARGS;

    if (items != 0)
	croak_xs_usage(cv, "");

    SP -= items;
    PUTBACK;

    if (!rx)
        XSRETURN_UNDEF;

    ret = CALLREG_NAMED_BUFF_COUNT(rx);

    SPAGAIN;
    PUSHs(ret ? sv_2mortal(ret) : &PL_sv_undef);
    XSRETURN(1);
}

XS(XS_re_regname); /* prototype to pass -Wmissing-prototypes */
XS(XS_re_regname)
{
    dXSARGS;
    REGEXP * rx;
    U32 flags;
    SV * ret;

    if (items < 1 || items > 2)
	croak_xs_usage(cv, "name[, all ]");

    SP -= items;
    PUTBACK;

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx)
        XSRETURN_UNDEF;

    if (items == 2 && SvTRUE(ST(1))) {
        flags = RXapif_ALL;
    } else {
        flags = RXapif_ONE;
    }
    ret = CALLREG_NAMED_BUFF_FETCH(rx, ST(0), (flags | RXapif_REGNAME));

    SPAGAIN;
    PUSHs(ret ? sv_2mortal(ret) : &PL_sv_undef);
    XSRETURN(1);
}


XS(XS_re_regnames); /* prototype to pass -Wmissing-prototypes */
XS(XS_re_regnames)
{
    dXSARGS;
    REGEXP * rx;
    U32 flags;
    SV *ret;
    AV *av;
    SSize_t length;
    SSize_t i;
    SV **entry;

    if (items > 1)
	croak_xs_usage(cv, "[all]");

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx)
        XSRETURN_UNDEF;

    if (items == 1 && SvTRUE(ST(0))) {
        flags = RXapif_ALL;
    } else {
        flags = RXapif_ONE;
    }

    SP -= items;
    PUTBACK;

    ret = CALLREG_NAMED_BUFF_ALL(rx, (flags | RXapif_REGNAMES));

    SPAGAIN;

    if (!ret)
        XSRETURN_UNDEF;

    av = MUTABLE_AV(SvRV(ret));
    length = av_tindex(av);

    EXTEND(SP, length+1); /* better extend stack just once */
    for (i = 0; i <= length; i++) {
        entry = av_fetch(av, i, FALSE);
        
        if (!entry)
            Perl_croak(aTHX_ "NULL array element in re::regnames()");

        mPUSHs(SvREFCNT_inc_simple_NN(*entry));
    }

    SvREFCNT_dec(ret);

    PUTBACK;
    return;
}

XS(XS_re_regexp_pattern); /* prototype to pass -Wmissing-prototypes */
XS(XS_re_regexp_pattern)
{
    dXSARGS;
    REGEXP *re;
    U8 const gimme = GIMME_V;

    EXTEND(SP, 2);
    SP -= items;
    if (items != 1)
	croak_xs_usage(cv, "sv");

    /*
       Checks if a reference is a regex or not. If the parameter is
       not a ref, or is not the result of a qr// then returns false
       in scalar context and an empty list in list context.
       Otherwise in list context it returns the pattern and the
       modifiers, in scalar context it returns the pattern just as it
       would if the qr// was stringified normally, regardless as
       to the class of the variable and any stringification overloads
       on the object.
    */

    if ((re = SvRX(ST(0)))) /* assign deliberate */
    {
        /* Houston, we have a regex! */
        SV *pattern;

        if ( gimme == G_ARRAY ) {
	    STRLEN left = 0;
	    char reflags[sizeof(INT_PAT_MODS) + MAX_CHARSET_NAME_LENGTH];
            const char *fptr;
            char ch;
            U16 match_flags;

            /*
               we are in list context so stringify
               the modifiers that apply. We ignore "negative
               modifiers" in this scenario, and the default character set
            */

	    if (get_regex_charset(RX_EXTFLAGS(re)) != REGEX_DEPENDS_CHARSET) {
		STRLEN len;
		const char* const name = get_regex_charset_name(RX_EXTFLAGS(re),
								&len);
		Copy(name, reflags + left, len, char);
		left += len;
	    }
            fptr = INT_PAT_MODS;
            match_flags = (U16)((RX_EXTFLAGS(re) & RXf_PMf_COMPILETIME)
                                    >> RXf_PMf_STD_PMMOD_SHIFT);

            while((ch = *fptr++)) {
                if(match_flags & 1) {
                    reflags[left++] = ch;
                }
                match_flags >>= 1;
            }

            pattern = newSVpvn_flags(RX_PRECOMP(re),RX_PRELEN(re),
				     (RX_UTF8(re) ? SVf_UTF8 : 0) | SVs_TEMP);

            /* return the pattern and the modifiers */
            PUSHs(pattern);
            PUSHs(newSVpvn_flags(reflags, left, SVs_TEMP));
            XSRETURN(2);
        } else {
            /* Scalar, so use the string that Perl would return */
            /* return the pattern in (?msixn:..) format */
#if PERL_VERSION >= 11
            pattern = sv_2mortal(newSVsv(MUTABLE_SV(re)));
#else
            pattern = newSVpvn_flags(RX_WRAPPED(re), RX_WRAPLEN(re),
				     (RX_UTF8(re) ? SVf_UTF8 : 0) | SVs_TEMP);
#endif
            PUSHs(pattern);
            XSRETURN(1);
        }
    } else {
        /* It ain't a regexp folks */
        if ( gimme == G_ARRAY ) {
            /* return the empty list */
            XSRETURN_EMPTY;
        } else {
            /* Because of the (?:..) wrapping involved in a
               stringified pattern it is impossible to get a
               result for a real regexp that would evaluate to
               false. Therefore we can return PL_sv_no to signify
               that the object is not a regex, this means that one
               can say

                 if (regex($might_be_a_regex) eq '(?:foo)') { }

               and not worry about undefined values.
            */
            XSRETURN_NO;
        }
    }
    NOT_REACHED; /* NOTREACHED */
}

#include "vutil.h"
#include "vxs.inc"

struct xsub_details {
    const char *name;
    XSUBADDR_t xsub;
    const char *proto;
};

static const struct xsub_details details[] = {
    {"UNIVERSAL::isa", XS_UNIVERSAL_isa, NULL},
    {"UNIVERSAL::can", XS_UNIVERSAL_can, NULL},
    {"UNIVERSAL::DOES", XS_UNIVERSAL_DOES, NULL},
#define VXS_XSUB_DETAILS
#include "vxs.inc"
#undef VXS_XSUB_DETAILS
    {"utf8::is_utf8", XS_utf8_is_utf8, NULL},
    {"utf8::valid", XS_utf8_valid, NULL},
    {"utf8::encode", XS_utf8_encode, NULL},
    {"utf8::decode", XS_utf8_decode, NULL},
    {"utf8::upgrade", XS_utf8_upgrade, NULL},
    {"utf8::downgrade", XS_utf8_downgrade, NULL},
    {"utf8::native_to_unicode", XS_utf8_native_to_unicode, NULL},
    {"utf8::unicode_to_native", XS_utf8_unicode_to_native, NULL},
    {"Internals::SvREADONLY", XS_Internals_SvREADONLY, "\\[$%@@];$"},
    {"constant::_make_const", XS_constant__make_const, "\\[$@@]"},
    {"Internals::SvREFCNT", XS_Internals_SvREFCNT, "\\[$%@@];$"},
    {"Internals::hv_clear_placeholders", XS_Internals_hv_clear_placehold, "\\%"},
    {"PerlIO::get_layers", XS_PerlIO_get_layers, "*;@@"},
    {"re::is_regexp", XS_re_is_regexp, "$"},
    {"re::regname", XS_re_regname, ";$$"},
    {"re::regnames", XS_re_regnames, ";$"},
    {"re::regnames_count", XS_re_regnames_count, ""},
    {"re::regexp_pattern", XS_re_regexp_pattern, "$"},
};

STATIC OP*
optimize_out_native_convert_function(pTHX_ OP* entersubop,
                                           GV* namegv,
                                           SV* protosv)
{
    /* Optimizes out an identity function, i.e., one that just returns its
     * argument.  The passed in function is assumed to be an identity function,
     * with no checking.  This is designed to be called for utf8_to_native()
     * and native_to_utf8() on ASCII platforms, as they just return their
     * arguments, but it could work on any such function.
     *
     * The code is mostly just cargo-culted from Memoize::Lift */

    OP *pushop, *argop;
    OP *parent;
    SV* prototype = newSVpvs("$");

    PERL_UNUSED_ARG(protosv);

    assert(entersubop->op_type == OP_ENTERSUB);

    entersubop = ck_entersub_args_proto(entersubop, namegv, prototype);
    parent = entersubop;

    SvREFCNT_dec(prototype);

    pushop = cUNOPx(entersubop)->op_first;
    if (! OpHAS_SIBLING(pushop)) {
        parent = pushop;
        pushop = cUNOPx(pushop)->op_first;
    }
    argop = OpSIBLING(pushop);

    /* Carry on without doing the optimization if it is not something we're
     * expecting, so continues to work */
    if (   ! argop
        || ! OpHAS_SIBLING(argop)
        ||   OpHAS_SIBLING(OpSIBLING(argop))
    ) {
        return entersubop;
    }

    /* cut argop from the subtree */
    (void)op_sibling_splice(parent, pushop, 1, NULL);

    op_free(entersubop);
    return argop;
}

void
Perl_boot_core_UNIVERSAL(pTHX)
{
    static const char file[] = __FILE__;
    const struct xsub_details *xsub = details;
    const struct xsub_details *end = C_ARRAY_END(details);

    do {
	newXS_flags(xsub->name, xsub->xsub, file, xsub->proto, 0);
    } while (++xsub < end);

#ifndef EBCDIC
    { /* On ASCII platforms these functions just return their argument, so can
         be optimized away */

        CV* to_native_cv = get_cv("utf8::unicode_to_native", 0);
        CV* to_unicode_cv = get_cv("utf8::native_to_unicode", 0);

        cv_set_call_checker(to_native_cv,
                            optimize_out_native_convert_function,
                            (SV*) to_native_cv);
        cv_set_call_checker(to_unicode_cv,
                            optimize_out_native_convert_function,
                            (SV*) to_unicode_cv);
    }
#endif

    /* Providing a Regexp::DESTROY fixes #21347. See test in t/op/ref.t  */
    {
	CV * const cv =
	    newCONSTSUB(get_hv("Regexp::", GV_ADD), "DESTROY", NULL);
	char ** cvfile = &CvFILE(cv);
	char * oldfile = *cvfile;
	CvDYNFILE_off(cv);
	*cvfile = (char *)file;
	Safefree(oldfile);
    }
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.17
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a43 1
    dVAR;
d69 1
a69 1

a148 1
    dVAR;
d208 1
a208 1
    if (sv_isobject(sv)) {
d297 2
a298 1
    Perl_croak(aTHX_ "Usage: %"SVf"::%"SVf"(%s)", "ouch" "awk", "eee_yow");
d306 2
a307 1
    const GV *const gv = CvGV(cv);
d311 1
a311 1
    if (gv) {
d325 3
d330 1
a330 1
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
a336 1
    dVAR;
a356 1
    dVAR;
d392 1
a392 1
            pkg = gv_stashpv("UNIVERSAL", 0);
a407 1
    dVAR;
a424 1
     dVAR;
a441 1
     dVAR;
a459 1
    dVAR;
a470 1
    dVAR;
a487 1
    dVAR;
a504 1
    dVAR;
d510 1
a510 1
        const bool failok = (items < 2) ? 0 : (int)SvIV(ST(1));
a520 1
 dVAR;
d527 1
a527 1
 ST(0) = sv_2mortal(newSViv(NATIVE_TO_UNI(uv)));
a533 1
 dVAR;
d540 1
a540 1
 ST(0) = sv_2mortal(newSViv(UNI_TO_NATIVE(uv)));
a546 1
    dVAR;
d566 1
a566 4
#ifdef PERL_OLD_COPY_ON_WRITE
	    if (SvIsCOW(sv)) sv_force_normal(sv);
#endif
	    SvREADONLY_on(sv);
d571 1
a571 1
	    SvREADONLY_off(sv);
a580 1
    dVAR;
a591 3
#ifdef PERL_OLD_COPY_ON_WRITE
    if (SvIsCOW(sv)) sv_force_normal(sv);
#endif
a607 1
    dVAR;
a632 1
    dVAR;
a646 1
    dVAR;
a772 1
    dVAR; 
a790 1
    dVAR; 
a811 1
    dVAR;
a843 1
    dVAR;
a898 1
    dVAR;
d901 1
d924 1
a924 1
        if ( GIMME_V == G_ARRAY ) {
d964 1
a964 1
            /* return the pattern in (?msix:..) format */
d976 1
a976 1
        if ( GIMME_V == G_ARRAY ) {
d978 1
a978 1
            XSRETURN_UNDEF;
d994 1
a994 1
    /* NOT-REACHED */
d1033 49
a1084 1
    dVAR;
d1093 16
d1113 2
a1114 2
	Safefree(CvFILE(cv));
	CvFILE(cv) = (char *)file;
d1116 2
a1121 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.16
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d32 1
a32 1
#ifdef USE_PERLIO
d163 3
a165 1
	stash = SvOBJECT(sv) ? SvSTASH(sv) : NULL;
a168 2
        if (!stash)
            stash = gv_stashpvs("UNIVERSAL", 0);
d171 5
a175 1
    return stash ? isa_lookup(stash, name, len, flags) : FALSE;
d297 1
a297 1
C<croak()>. Hence if C<cv> is C<&ouch::awk>, it would call C<croak> as:
d315 1
d321 1
d326 1
d331 1
d352 1
d360 1
d369 4
a372 2
    if (!SvOK(sv) || !(SvROK(sv) || SvNIOK(sv) || (SvPOK(sv) && SvCUR(sv))
       ))
d381 2
d384 4
d404 1
d422 1
a422 366
XS(XS_UNIVERSAL_VERSION)
{
    dVAR;
    dXSARGS;
    HV *pkg;
    GV **gvp;
    GV *gv;
    SV *sv;
    const char *undef;
    PERL_UNUSED_ARG(cv);

    if (SvROK(ST(0))) {
        sv = MUTABLE_SV(SvRV(ST(0)));
        if (!SvOBJECT(sv))
            Perl_croak(aTHX_ "Cannot find version of an unblessed reference");
        pkg = SvSTASH(sv);
    }
    else {
        pkg = gv_stashsv(ST(0), 0);
    }

    gvp = pkg ? (GV**)hv_fetchs(pkg, "VERSION", FALSE) : NULL;

    if (gvp && isGV(gv = *gvp) && (sv = GvSV(gv)) && SvOK(sv)) {
        SV * const nsv = sv_newmortal();
        sv_setsv(nsv, sv);
        sv = nsv;
	if ( !sv_isobject(sv) || !sv_derived_from(sv, "version"))
	    upg_version(sv, FALSE);

        undef = NULL;
    }
    else {
        sv = &PL_sv_undef;
        undef = "(undef)";
    }

    if (items > 1) {
	SV *req = ST(1);

	if (undef) {
	    if (pkg) {
		const HEK * const name = HvNAME_HEK(pkg);
		Perl_croak(aTHX_
			   "%"HEKf" does not define $%"HEKf
			   "::VERSION--version check failed",
			   HEKfARG(name), HEKfARG(name));
	    } else {
		Perl_croak(aTHX_
			     "%"SVf" defines neither package nor VERSION--version check failed",
			     SVfARG(ST(0)) );
	     }
	}

	if ( !sv_isobject(req) || !sv_derived_from(req, "version")) {
	    /* req may very well be R/O, so create a new object */
	    req = sv_2mortal( new_version(req) );
	}

	if ( vcmp( req, sv ) > 0 ) {
	    if ( hv_exists(MUTABLE_HV(SvRV(req)), "qv", 2 ) ) {
		Perl_croak(aTHX_ "%"HEKf" version %"SVf" required--"
		       "this is only version %"SVf"",
                       HEKfARG(HvNAME_HEK(pkg)),
		       SVfARG(sv_2mortal(vnormal(req))),
		       SVfARG(sv_2mortal(vnormal(sv))));
	    } else {
		Perl_croak(aTHX_ "%"HEKf" version %"SVf" required--"
		       "this is only version %"SVf,
                       HEKfARG(HvNAME_HEK(pkg)),
		       SVfARG(sv_2mortal(vstringify(req))),
		       SVfARG(sv_2mortal(vstringify(sv))));
	    }
	}

    }

    if ( SvOK(sv) && sv_derived_from(sv, "version") ) {
	ST(0) = sv_2mortal(vstringify(sv));
    } else {
	ST(0) = sv;
    }

    XSRETURN(1);
}

XS(XS_version_new)
{
    dVAR;
    dXSARGS;
    if (items > 3 || items < 1)
	croak_xs_usage(cv, "class, version");
    SP -= items;
    {
        SV *vs = ST(1);
	SV *rv;
        STRLEN len;
        const char *classname;
        U32 flags;
        if ( sv_isobject(ST(0)) ) { /* get the class if called as an object method */
            const HV * stash = SvSTASH(SvRV(ST(0)));
            classname = HvNAME(stash);
            len       = HvNAMELEN(stash);
            flags     = HvNAMEUTF8(stash) ? SVf_UTF8 : 0;
        }
        else {
	    classname = SvPV(ST(0), len);
            flags     = SvUTF8(ST(0));
        }

	if ( items == 1 || ! SvOK(vs) ) { /* no param or explicit undef */
	    /* create empty object */
	    vs = sv_newmortal();
	    sv_setpvs(vs, "0");
	}
	else if ( items == 3 ) {
	    vs = sv_newmortal();
	    Perl_sv_setpvf(aTHX_ vs,"v%s",SvPV_nolen_const(ST(2)));
	}

	rv = new_version(vs);
	if ( strnNE(classname,"version", len) ) /* inherited new() */
	    sv_bless(rv, gv_stashpvn(classname, len, GV_ADD | flags));

	mPUSHs(rv);
	PUTBACK;
	return;
    }
}

XS(XS_version_stringify)
{
     dVAR;
     dXSARGS;
     if (items < 1)
	 croak_xs_usage(cv, "lobj, ...");
     SP -= items;
     {
	  SV *	lobj = ST(0);

	  if (sv_isobject(lobj) && sv_derived_from(lobj, "version")) {
	       lobj = SvRV(lobj);
	  }
	  else
	       Perl_croak(aTHX_ "lobj is not of type version");

	  mPUSHs(vstringify(lobj));

	  PUTBACK;
	  return;
     }
}

XS(XS_version_numify)
{
     dVAR;
     dXSARGS;
     if (items < 1)
	 croak_xs_usage(cv, "lobj, ...");
     SP -= items;
     {
	  SV *	lobj = ST(0);

	  if (sv_isobject(lobj) && sv_derived_from(lobj, "version")) {
	       lobj = SvRV(lobj);
	  }
	  else
	       Perl_croak(aTHX_ "lobj is not of type version");

	  mPUSHs(vnumify(lobj));

	  PUTBACK;
	  return;
     }
}

XS(XS_version_normal)
{
     dVAR;
     dXSARGS;
     if (items < 1)
	 croak_xs_usage(cv, "lobj, ...");
     SP -= items;
     {
	  SV *	lobj = ST(0);

	  if (sv_isobject(lobj) && sv_derived_from(lobj, "version")) {
	       lobj = SvRV(lobj);
	  }
	  else
	       Perl_croak(aTHX_ "lobj is not of type version");

	  mPUSHs(vnormal(lobj));

	  PUTBACK;
	  return;
     }
}

XS(XS_version_vcmp)
{
     dVAR;
     dXSARGS;
     if (items < 1)
	 croak_xs_usage(cv, "lobj, ...");
     SP -= items;
     {
	  SV *	lobj = ST(0);

	  if (sv_isobject(lobj) && sv_derived_from(lobj, "version")) {
	       lobj = SvRV(lobj);
	  }
	  else
	       Perl_croak(aTHX_ "lobj is not of type version");

	  {
	       SV	*rs;
	       SV	*rvs;
	       SV * robj = ST(1);
	       const IV	 swap = (IV)SvIV(ST(2));

	       if ( !sv_isobject(robj) || !sv_derived_from(robj, "version") )
	       {
		    robj = new_version(SvOK(robj) ? robj : newSVpvs_flags("0", SVs_TEMP));
		    sv_2mortal(robj);
	       }
	       rvs = SvRV(robj);

	       if ( swap )
	       {
		    rs = newSViv(vcmp(rvs,lobj));
	       }
	       else
	       {
		    rs = newSViv(vcmp(lobj,rvs));
	       }

	       mPUSHs(rs);
	  }

	  PUTBACK;
	  return;
     }
}

XS(XS_version_boolean)
{
    dVAR;
    dXSARGS;
    if (items < 1)
	croak_xs_usage(cv, "lobj, ...");
    SP -= items;
    if (sv_isobject(ST(0)) && sv_derived_from(ST(0), "version")) {
	SV * const lobj = SvRV(ST(0));
	SV * const rs =
	    newSViv( vcmp(lobj,
			  sv_2mortal(new_version(
					sv_2mortal(newSVpvs("0"))
				    ))
			 )
		   );
	mPUSHs(rs);
	PUTBACK;
	return;
    }
    else
	Perl_croak(aTHX_ "lobj is not of type version");
}

XS(XS_version_noop)
{
    dVAR;
    dXSARGS;
    if (items < 1)
	croak_xs_usage(cv, "lobj, ...");
    if (sv_isobject(ST(0)) && sv_derived_from(ST(0), "version"))
	Perl_croak(aTHX_ "operation not supported with version object");
    else
	Perl_croak(aTHX_ "lobj is not of type version");
#ifndef HASATTRIBUTE_NORETURN
    XSRETURN_EMPTY;
#endif
}

XS(XS_version_is_alpha)
{
    dVAR;
    dXSARGS;
    if (items != 1)
	croak_xs_usage(cv, "lobj");
    SP -= items;
    if (sv_isobject(ST(0)) && sv_derived_from(ST(0), "version")) {
	SV * const lobj = ST(0);
	if ( hv_exists(MUTABLE_HV(SvRV(lobj)), "alpha", 5 ) )
	    XSRETURN_YES;
	else
	    XSRETURN_NO;
	PUTBACK;
	return;
    }
    else
	Perl_croak(aTHX_ "lobj is not of type version");
}

XS(XS_version_qv)
{
    dVAR;
    dXSARGS;
    PERL_UNUSED_ARG(cv);
    SP -= items;
    {
	SV * ver = ST(0);
	SV * rv;
        STRLEN len = 0;
        const char * classname = "";
        U32 flags = 0;
        if ( items == 2 && SvOK(ST(1)) ) {
            ver = ST(1);
            if ( sv_isobject(ST(0)) ) { /* class called as an object method */
                const HV * stash = SvSTASH(SvRV(ST(0)));
                classname = HvNAME(stash);
                len       = HvNAMELEN(stash);
                flags     = HvNAMEUTF8(stash) ? SVf_UTF8 : 0;
            }
            else {
	       classname = SvPV(ST(0), len);
                flags     = SvUTF8(ST(0));
            }
        }
	if ( !SvVOK(ver) ) { /* not already a v-string */
	    rv = sv_newmortal();
	    sv_setsv(rv,ver); /* make a duplicate */
	    upg_version(rv, TRUE);
	} else {
	    rv = sv_2mortal(new_version(ver));
	}
	if ( items == 2
                && strnNE(classname,"version", len) ) { /* inherited new() */
	    sv_bless(rv, gv_stashpvn(classname, len, GV_ADD | flags));
        }
	PUSHs(rv);
    }
    PUTBACK;
    return;
}

XS(XS_version_is_qv)
{
    dVAR;
    dXSARGS;
    if (items != 1)
	croak_xs_usage(cv, "lobj");
    SP -= items;
    if (sv_isobject(ST(0)) && sv_derived_from(ST(0), "version")) {
	SV * const lobj = ST(0);
	if ( hv_exists(MUTABLE_HV(SvRV(lobj)), "qv", 2 ) )
	    XSRETURN_YES;
	else
	    XSRETURN_NO;
	PUTBACK;
	return;
    }
    else
	Perl_croak(aTHX_ "lobj is not of type version");
}

d440 1
d459 1
d471 1
d489 1
d507 1
d524 1
d538 1
d552 1
d568 1
a568 1
	 if (SvREADONLY(sv) && !SvIsCOW(sv))
d575 1
d577 1
d583 1
a583 1
	    if (!SvIsCOW(sv)) SvREADONLY_off(sv);
d589 33
d647 1
d662 1
d669 1
a669 1
#ifdef USE_PERLIO
d724 3
a726 3
	     I32 i;
	     const I32 last = av_len(av);
	     I32 nitem = 0;
d789 1
d806 1
d830 1
d863 1
d872 2
a873 2
    I32 length;
    I32 i;
d901 1
a901 1
    length = av_len(av);
d919 1
d1020 3
d1029 1
a1029 1
const struct xsub_details details[] = {
d1033 3
a1035 29
    {"UNIVERSAL::VERSION", XS_UNIVERSAL_VERSION, NULL},
    {"version::()", XS_version_noop, NULL},
    {"version::new", XS_version_new, NULL},
    {"version::parse", XS_version_new, NULL},
    {"version::(\"\"", XS_version_stringify, NULL},
    {"version::stringify", XS_version_stringify, NULL},
    {"version::(0+", XS_version_numify, NULL},
    {"version::numify", XS_version_numify, NULL},
    {"version::normal", XS_version_normal, NULL},
    {"version::(cmp", XS_version_vcmp, NULL},
    {"version::(<=>", XS_version_vcmp, NULL},
    {"version::vcmp", XS_version_vcmp, NULL},
    {"version::(bool", XS_version_boolean, NULL},
    {"version::boolean", XS_version_boolean, NULL},
    {"version::(+", XS_version_noop, NULL},
    {"version::(-", XS_version_noop, NULL},
    {"version::(*", XS_version_noop, NULL},
    {"version::(/", XS_version_noop, NULL},
    {"version::(+=", XS_version_noop, NULL},
    {"version::(-=", XS_version_noop, NULL},
    {"version::(*=", XS_version_noop, NULL},
    {"version::(/=", XS_version_noop, NULL},
    {"version::(abs", XS_version_noop, NULL},
    {"version::(nomethod", XS_version_noop, NULL},
    {"version::noop", XS_version_noop, NULL},
    {"version::is_alpha", XS_version_is_alpha, NULL},
    {"version::qv", XS_version_qv, NULL},
    {"version::declare", XS_version_qv, NULL},
    {"version::is_qv", XS_version_is_qv, NULL},
d1045 1
d1062 1
a1062 2
    const struct xsub_details *end
	= details + sizeof(details) / sizeof(details[0]);
@


1.15
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d167 2
d201 1
a201 2
    if (!SvOK(sv) || !(SvROK(sv) || (SvPOK(sv) && SvCUR(sv))
	    || (SvGMAGICAL(sv) && SvPOKp(sv) && SvCUR(sv)))) {
d301 1
a301 1
Perl_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
d311 1
a311 1
	    Perl_croak(aTHX_ "Usage: %"HEKf"::%"HEKf"(%s)",
d316 1
a316 1
	    Perl_croak(aTHX_ "Usage: %"HEKf"(%s)",
d320 1
a320 1
	Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
d336 1
a336 2
	if (!SvOK(sv) || !(SvROK(sv) || (SvPOK(sv) && SvCUR(sv))
		    || (SvGMAGICAL(sv) && SvPOKp(sv) && SvCUR(sv))))
d359 2
a360 2
    if (!SvOK(sv) || !(SvROK(sv) || (SvPOK(sv) && SvCUR(sv))
		|| (SvGMAGICAL(sv) && SvPOKp(sv) && SvCUR(sv))))
d372 2
d493 1
a493 1
    if (items > 3)
d811 1
d826 1
a924 1

d931 1
d935 1
a935 1
    if (!SvROK(svz))
a939 3
    if (items == 1)
	 XSRETURN_UV(SvREFCNT(sv) - 1); /* Minus the ref created for us. */
    else if (items == 2) {
d941 7
a947 4
	 SvREFCNT(sv) = SvUV(ST(1)) + 1; /* we free one ref on exit */
	 XSRETURN_UV(SvREFCNT(sv) - 1);
    }
    XSRETURN_UNDEF; /* Can't happen. */
d1038 1
d1044 1
a1044 1
		       XPUSHs(namok
d1047 1
a1047 1
		       XPUSHs(argok
d1053 1
a1053 1
		       XPUSHs(flgok
d1060 1
a1060 1
			    XPUSHs(sv_2mortal(Perl_newSVpvf(aTHX_ "%"SVf"(%"SVf")",
d1064 1
a1064 1
			   XPUSHs(sv_2mortal(SvREFCNT_inc_simple_NN(*namsvp)));
d1066 1
a1066 1
			    XPUSHs(&PL_sv_undef);
d1072 1
a1072 1
				 XPUSHs(newSVpvs_flags("utf8", SVs_TEMP));
a1088 38
XS(XS_Internals_hash_seed)
{
    dVAR;
    /* Using dXSARGS would also have dITEM and dSP,
     * which define 2 unused local variables.  */
    dAXMARK;
    PERL_UNUSED_ARG(cv);
    PERL_UNUSED_VAR(mark);
    XSRETURN_UV(PERL_HASH_SEED);
}

XS(XS_Internals_rehash_seed)
{
    dVAR;
    /* Using dXSARGS would also have dITEM and dSP,
     * which define 2 unused local variables.  */
    dAXMARK;
    PERL_UNUSED_ARG(cv);
    PERL_UNUSED_VAR(mark);
    XSRETURN_UV(PL_rehash_seed);
}

XS(XS_Internals_HvREHASH)	/* Subject to change  */
{
    dVAR;
    dXSARGS;
    PERL_UNUSED_ARG(cv);
    if (SvROK(ST(0))) {
	const HV * const hv = (const HV *) SvRV(ST(0));
	if (items == 1 && SvTYPE(hv) == SVt_PVHV) {
	    if (HvREHASH(hv))
		XSRETURN_YES;
	    else
		XSRETURN_NO;
	}
    }
    Perl_croak(aTHX_ "Internals::HvREHASH $hashref");
}
d1200 1
d1207 1
a1207 1
        mXPUSHs(SvREFCNT_inc_simple_NN(*entry));
d1222 2
a1226 2
    SP -= items;

d1278 2
a1279 2
            XPUSHs(pattern);
            XPUSHs(newSVpvn_flags(reflags, left, SVs_TEMP));
d1290 1
a1290 1
            XPUSHs(pattern);
d1322 1
a1322 1
struct xsub_details details[] = {
a1366 3
    {"Internals::hash_seed", XS_Internals_hash_seed, ""},
    {"Internals::rehash_seed", XS_Internals_rehash_seed, ""},
    {"Internals::HvREHASH", XS_Internals_HvREHASH, "\\%"},
d1379 1
a1379 1
    struct xsub_details *xsub = details;
a1386 3
    /* register the overloading (type 'A') magic */
    PL_amagic_generation++;

d1401 1
a1401 1
 * indent-tabs-mode: t
d1404 1
a1404 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.14
log
@merge in perl 5.12.2 plus local changes
@
text
@d24 1
a24 1
 * clever to move them to seperate XS files which would then be pulled
a35 35
static HV *
S_get_isa_hash(pTHX_ HV *const stash)
{
    dVAR;
    struct mro_meta *const meta = HvMROMETA(stash);

    PERL_ARGS_ASSERT_GET_ISA_HASH;

    if (!meta->isa) {
	AV *const isa = mro_get_linear_isa(stash);
	if (!meta->isa) {
	    HV *const isa_hash = newHV();
	    /* Linearisation didn't build it for us, so do it here.  */
	    SV *const *svp = AvARRAY(isa);
	    SV *const *const svp_end = svp + AvFILLp(isa) + 1;
	    const HEK *const canon_name = HvNAME_HEK(stash);

	    while (svp < svp_end) {
		(void) hv_store_ent(isa_hash, *svp++, &PL_sv_undef, 0);
	    }

	    (void) hv_common(isa_hash, NULL, HEK_KEY(canon_name),
			     HEK_LEN(canon_name), HEK_FLAGS(canon_name),
			     HV_FETCH_ISSTORE, &PL_sv_undef,
			     HEK_HASH(canon_name));
	    (void) hv_store(isa_hash, "UNIVERSAL", 9, &PL_sv_undef, 0);

	    SvREADONLY_on(isa_hash);

	    meta->isa = isa_hash;
	}
    }
    return meta->isa;
}

d42 1
a42 1
S_isa_lookup(pTHX_ HV *stash, const char * const name)
d46 1
a46 2
    HV *const isa = meta->isa ? meta->isa : S_get_isa_hash(aTHX_ stash);
    STRLEN len = strlen(name);
d51 6
a56 2
    if (hv_common(isa, NULL, name, len, 0 /* No "UTF-8" flag possible with only
					     a char * argument*/,
d63 3
a65 2
       we use the name in the stash itself, which is canonical.  */
    our_stash = gv_stashpvn(name, len, 0);
d68 2
a69 1
	HEK *const canon_name = HvNAME_HEK(our_stash);
d84 1
a84 1
=for apidoc sv_derived_from
d90 30
d126 24
d153 1
a153 1
    PERL_ARGS_ASSERT_SV_DERIVED_FROM;
d169 1
a169 1
    return stash ? isa_lookup(stash, name) : FALSE;
d173 1
a173 1
=for apidoc sv_does
d184 1
a184 1
Perl_sv_does(pTHX_ SV *sv, const char *const name)
d186 1
a186 1
    const char *classname;
d191 2
a192 1
    PERL_ARGS_ASSERT_SV_DOES;
d206 1
a206 1
	classname = sv_reftype(SvRV(sv),TRUE);
d208 1
a208 1
	classname = SvPV_nolen(sv);
d211 1
a211 1
    if (strEQ(name,classname)) {
d217 3
a219 2
    XPUSHs(sv);
    mXPUSHs(newSVpv(name, 0));
d237 38
a274 47
PERL_XS_EXPORT_C void XS_UNIVERSAL_isa(pTHX_ CV *cv);
PERL_XS_EXPORT_C void XS_UNIVERSAL_can(pTHX_ CV *cv);
PERL_XS_EXPORT_C void XS_UNIVERSAL_DOES(pTHX_ CV *cv);
PERL_XS_EXPORT_C void XS_UNIVERSAL_VERSION(pTHX_ CV *cv);
XS(XS_version_new);
XS(XS_version_stringify);
XS(XS_version_numify);
XS(XS_version_normal);
XS(XS_version_vcmp);
XS(XS_version_boolean);
#ifdef HASATTRIBUTE_NORETURN
XS(XS_version_noop) __attribute__noreturn__;
#else
XS(XS_version_noop);
#endif
XS(XS_version_is_alpha);
XS(XS_version_qv);
XS(XS_version_is_qv);
XS(XS_utf8_is_utf8);
XS(XS_utf8_valid);
XS(XS_utf8_encode);
XS(XS_utf8_decode);
XS(XS_utf8_upgrade);
XS(XS_utf8_downgrade);
XS(XS_utf8_unicode_to_native);
XS(XS_utf8_native_to_unicode);
XS(XS_Internals_SvREADONLY);
XS(XS_Internals_SvREFCNT);
XS(XS_Internals_hv_clear_placehold);
XS(XS_PerlIO_get_layers);
XS(XS_Internals_hash_seed);
XS(XS_Internals_rehash_seed);
XS(XS_Internals_HvREHASH);
XS(XS_re_is_regexp); 
XS(XS_re_regname);
XS(XS_re_regnames);
XS(XS_re_regnames_count);
XS(XS_re_regexp_pattern);
XS(XS_Tie_Hash_NamedCapture_FETCH);
XS(XS_Tie_Hash_NamedCapture_STORE);
XS(XS_Tie_Hash_NamedCapture_DELETE);
XS(XS_Tie_Hash_NamedCapture_CLEAR);
XS(XS_Tie_Hash_NamedCapture_EXISTS);
XS(XS_Tie_Hash_NamedCapture_FIRSTK);
XS(XS_Tie_Hash_NamedCapture_NEXTK);
XS(XS_Tie_Hash_NamedCapture_SCALAR);
XS(XS_Tie_Hash_NamedCapture_flags);
d276 2
a277 2
void
Perl_boot_core_UNIVERSAL(pTHX)
d279 1
a279 2
    dVAR;
    static const char file[] = __FILE__;
d281 1
a281 62
    newXS("UNIVERSAL::isa",             XS_UNIVERSAL_isa,         file);
    newXS("UNIVERSAL::can",             XS_UNIVERSAL_can,         file);
    newXS("UNIVERSAL::DOES",            XS_UNIVERSAL_DOES,        file);
    newXS("UNIVERSAL::VERSION", 	XS_UNIVERSAL_VERSION, 	  file);
    {
	/* register the overloading (type 'A') magic */
	PL_amagic_generation++;
	/* Make it findable via fetchmethod */
	newXS("version::()", XS_version_noop, file);
	newXS("version::new", XS_version_new, file);
	newXS("version::parse", XS_version_new, file);
	newXS("version::(\"\"", XS_version_stringify, file);
	newXS("version::stringify", XS_version_stringify, file);
	newXS("version::(0+", XS_version_numify, file);
	newXS("version::numify", XS_version_numify, file);
	newXS("version::normal", XS_version_normal, file);
	newXS("version::(cmp", XS_version_vcmp, file);
	newXS("version::(<=>", XS_version_vcmp, file);
	newXS("version::vcmp", XS_version_vcmp, file);
	newXS("version::(bool", XS_version_boolean, file);
	newXS("version::boolean", XS_version_boolean, file);
	newXS("version::(nomethod", XS_version_noop, file);
	newXS("version::noop", XS_version_noop, file);
	newXS("version::is_alpha", XS_version_is_alpha, file);
	newXS("version::qv", XS_version_qv, file);
	newXS("version::declare", XS_version_qv, file);
	newXS("version::is_qv", XS_version_is_qv, file);
    }
    newXS("utf8::is_utf8", XS_utf8_is_utf8, file);
    newXS("utf8::valid", XS_utf8_valid, file);
    newXS("utf8::encode", XS_utf8_encode, file);
    newXS("utf8::decode", XS_utf8_decode, file);
    newXS("utf8::upgrade", XS_utf8_upgrade, file);
    newXS("utf8::downgrade", XS_utf8_downgrade, file);
    newXS("utf8::native_to_unicode", XS_utf8_native_to_unicode, file);
    newXS("utf8::unicode_to_native", XS_utf8_unicode_to_native, file);
    newXSproto("Internals::SvREADONLY",XS_Internals_SvREADONLY, file, "\\[$%@@];$");
    newXSproto("Internals::SvREFCNT",XS_Internals_SvREFCNT, file, "\\[$%@@];$");
    newXSproto("Internals::hv_clear_placeholders",
               XS_Internals_hv_clear_placehold, file, "\\%");
    newXSproto("PerlIO::get_layers",
               XS_PerlIO_get_layers, file, "*;@@");
    /* Providing a Regexp::DESTROY fixes #21347. See test in t/op/ref.t  */
    CvFILE(newCONSTSUB(get_hv("Regexp::", GV_ADD), "DESTROY", NULL))
	= (char *)file;
    newXSproto("Internals::hash_seed",XS_Internals_hash_seed, file, "");
    newXSproto("Internals::rehash_seed",XS_Internals_rehash_seed, file, "");
    newXSproto("Internals::HvREHASH", XS_Internals_HvREHASH, file, "\\%");
    newXSproto("re::is_regexp", XS_re_is_regexp, file, "$");
    newXSproto("re::regname", XS_re_regname, file, ";$$");
    newXSproto("re::regnames", XS_re_regnames, file, ";$");
    newXSproto("re::regnames_count", XS_re_regnames_count, file, "");
    newXSproto("re::regexp_pattern", XS_re_regexp_pattern, file, "$");
    newXS("Tie::Hash::NamedCapture::FETCH", XS_Tie_Hash_NamedCapture_FETCH, file);
    newXS("Tie::Hash::NamedCapture::STORE", XS_Tie_Hash_NamedCapture_STORE, file);
    newXS("Tie::Hash::NamedCapture::DELETE", XS_Tie_Hash_NamedCapture_DELETE, file);
    newXS("Tie::Hash::NamedCapture::CLEAR", XS_Tie_Hash_NamedCapture_CLEAR, file);
    newXS("Tie::Hash::NamedCapture::EXISTS", XS_Tie_Hash_NamedCapture_EXISTS, file);
    newXS("Tie::Hash::NamedCapture::FIRSTKEY", XS_Tie_Hash_NamedCapture_FIRSTK, file);
    newXS("Tie::Hash::NamedCapture::NEXTKEY", XS_Tie_Hash_NamedCapture_NEXTK, file);
    newXS("Tie::Hash::NamedCapture::SCALAR", XS_Tie_Hash_NamedCapture_SCALAR, file);
    newXS("Tie::Hash::NamedCapture::flags", XS_Tie_Hash_NamedCapture_flags, file);
d294 1
a294 1
    Perl_croak(aTHX_ "Usage %s::%s(%s)", "ouch" "awk", "eee_yow");
a306 1
	const char *const gvname = GvNAME(gv);
a307 1
	const char *const hvname = stash ? HvNAME_get(stash) : NULL;
d309 5
a313 2
	if (hvname)
	    Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
d315 2
a316 1
	    Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
a331 1
	const char *name;
d339 1
a339 3
	name = SvPV_nolen_const(ST(1));

	ST(0) = boolSV(sv_derived_from(sv, name));
a348 1
    const char *name;
a362 1
    name = SvPV_nolen_const(ST(1));
d375 1
a375 1
	GV * const gv = gv_fetchmethod_autoload(pkg, name, FALSE);
d394 1
a394 4
	const char *name;

	name = SvPV_nolen_const(ST(1));
	if (sv_does( sv, name ))
d428 1
a428 1
	if ( !sv_derived_from(sv, "version"))
d430 1
d443 1
a443 1
		const char * const name = HvNAME_get(pkg);
d445 3
a447 2
			   "%s does not define $%s::VERSION--version check failed",
			   name, name);
d450 2
a451 2
			     "%s defines neither package nor VERSION--version check failed",
			     SvPVx_nolen_const(ST(0)) );
d455 1
a455 1
	if ( !sv_derived_from(req, "version")) {
d462 5
a466 4
		Perl_croak(aTHX_ "%s version %"SVf" required--"
		       "this is only version %"SVf"", HvNAME_get(pkg),
		       SVfARG(vnormal(req)),
		       SVfARG(vnormal(sv)));
d468 5
a472 4
		Perl_croak(aTHX_ "%s version %"SVf" required--"
		       "this is only version %"SVf"", HvNAME_get(pkg),
		       SVfARG(vstringify(req)),
		       SVfARG(vstringify(sv)));
d479 1
a479 1
	ST(0) = vstringify(sv);
d497 13
a509 4
	const char * const classname =
	    sv_isobject(ST(0)) /* get the class if called as an object method */
		? HvNAME(SvSTASH(SvRV(ST(0))))
		: (char *)SvPV_nolen(ST(0));
d522 2
a523 2
	if ( strcmp(classname,"version") != 0 ) /* inherited new() */
	    sv_bless(rv, gv_stashpv(classname, GV_ADD));
d539 1
a539 1
	  SV *	lobj;
d541 2
a542 2
	  if (sv_derived_from(ST(0), "version")) {
	       lobj = SvRV(ST(0));
d562 1
a562 1
	  SV *	lobj;
d564 2
a565 2
	  if (sv_derived_from(ST(0), "version")) {
	       lobj = SvRV(ST(0));
d585 1
a585 1
	  SV *	lobj;
d587 2
a588 2
	  if (sv_derived_from(ST(0), "version")) {
	       lobj = SvRV(ST(0));
d608 1
a608 1
	  SV *	lobj;
d610 2
a611 2
	  if (sv_derived_from(ST(0), "version")) {
	       lobj = SvRV(ST(0));
d622 1
a622 1
	       if ( ! sv_derived_from(robj, "version") )
d624 2
a625 1
		    robj = new_version(SvOK(robj) ? robj : newSVpvs("0"));
d653 1
a653 1
    if (sv_derived_from(ST(0), "version")) {
d655 7
a661 1
	SV * const rs = newSViv( vcmp(lobj,new_version(newSVpvs("0"))) );
d676 1
a676 1
    if (sv_derived_from(ST(0), "version"))
d692 1
a692 1
    if (sv_derived_from(ST(0), "version")) {
d714 16
a729 9
	const char * classname = "";
	if ( items == 2 && SvOK(ST(1)) ) {
	    /* getting called as object or class method */
	    ver = ST(1);
	    classname = 
		sv_isobject(ST(0)) /* class called as an object method */
		    ? HvNAME_get(SvSTASH(SvRV(ST(0))))
		    : (char *)SvPV_nolen(ST(0));
	}
d737 4
a740 3
	if ( items == 2 && strcmp(classname,"version") ) { /* inherited new() */
	    sv_bless(rv, gv_stashpv(classname, GV_ADD));
	}
d754 1
a754 1
    if (sv_derived_from(ST(0), "version")) {
d820 3
a822 1
	const bool RETVAL = sv_utf8_decode(sv);
a823 1
	sv_2mortal(ST(0));
a856 1
	sv_2mortal(ST(0));
d891 2
a892 1
    SV * const sv = SvRV(ST(0));
d895 6
d902 1
a902 1
	 if (SvREADONLY(sv))
d909 1
d915 1
a915 1
	    SvREADONLY_off(sv);
d926 2
a927 1
    SV * const sv = SvRV(ST(0));
d930 6
d937 1
a937 1
	 XSRETURN_IV(SvREFCNT(sv) - 1); /* Minus the ref created for us. */
d940 2
a941 2
	 SvREFCNT(sv) = SvIV(ST(1));
	 XSRETURN_IV(SvREFCNT(sv));
d951 1
a951 1
    if (items != 1)
d1013 1
a1013 1
	gv = MUTABLE_GV(sv);
d1015 2
a1016 6
	if (!isGV(sv)) {
	     if (SvROK(sv) && isGV(SvRV(sv)))
		  gv = MUTABLE_GV(SvRV(sv));
	     else if (SvPOKp(sv))
		  gv = gv_fetchsv(sv, 0, SVt_PVIO);
	}
a1131 2
    SP -= items;

d1150 1
d1158 2
a1159 8

    if (ret) {
        mXPUSHs(ret);
        PUTBACK;
        return;
    } else {
        XSRETURN_UNDEF;
    }
d1174 1
d1188 3
a1190 5
    if (ret) {
        mXPUSHs(ret);
        XSRETURN(1);
    }
    XSRETURN_UNDEF;    
d1221 1
a1226 2
    SP -= items;

d1266 1
a1266 1
       to the class of the variable and any strigification overloads
d1272 1
a1272 1
        /* Housten, we have a regex! */
a1273 2
        STRLEN left = 0;
        char reflags[6];
d1276 6
d1285 1
a1285 1
               modifiers" in this scenario.
d1288 9
a1296 3
            const char *fptr = INT_PAT_MODS;
            char ch;
            U16 match_flags = (U16)((RX_EXTFLAGS(re) & PMf_COMPILETIME)
d1348 60
a1407 7
XS(XS_Tie_Hash_NamedCapture_FETCH)
{
    dVAR;
    dXSARGS;
    REGEXP * rx;
    U32 flags;
    SV * ret;
d1409 2
a1410 24
    if (items != 2)
	croak_xs_usage(cv, "$key, $flags");

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx || !SvROK(ST(0)))
        XSRETURN_UNDEF;

    SP -= items;

    flags = (U32)INT2PTR(IV,SvIV(SvRV(MUTABLE_SV(ST(0)))));
    ret = CALLREG_NAMED_BUFF_FETCH(rx, ST(1), flags);

    SPAGAIN;

    if (ret) {
        mXPUSHs(ret);
        PUTBACK;
        return;
    }
    XSRETURN_UNDEF;
}

XS(XS_Tie_Hash_NamedCapture_STORE)
d1413 8
a1420 3
    dXSARGS;
    REGEXP * rx;
    U32 flags;
d1422 2
a1423 2
    if (items != 3)
	croak_xs_usage(cv, "$key, $value, $flags");
d1425 7
a1431 175
    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx || !SvROK(ST(0))) {
        if (!PL_localizing)
            Perl_croak(aTHX_ "%s", PL_no_modify);
        else
            XSRETURN_UNDEF;
    }

    SP -= items;

    flags = (U32)INT2PTR(IV,SvIV(SvRV(MUTABLE_SV(ST(0)))));
    CALLREG_NAMED_BUFF_STORE(rx,ST(1), ST(2), flags);
}

XS(XS_Tie_Hash_NamedCapture_DELETE)
{
    dVAR;
    dXSARGS;
    REGEXP * rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;
    U32 flags;

    if (items != 2)
	croak_xs_usage(cv, "$key, $flags");

    if (!rx || !SvROK(ST(0)))
        Perl_croak(aTHX_ "%s", PL_no_modify);

    SP -= items;

    flags = (U32)INT2PTR(IV,SvIV(SvRV(MUTABLE_SV(ST(0)))));
    CALLREG_NAMED_BUFF_DELETE(rx, ST(1), flags);
}

XS(XS_Tie_Hash_NamedCapture_CLEAR)
{
    dVAR;
    dXSARGS;
    REGEXP * rx;
    U32 flags;

    if (items != 1)
	croak_xs_usage(cv, "$flags");

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx || !SvROK(ST(0)))
        Perl_croak(aTHX_ "%s", PL_no_modify);

    SP -= items;

    flags = (U32)INT2PTR(IV,SvIV(SvRV(MUTABLE_SV(ST(0)))));
    CALLREG_NAMED_BUFF_CLEAR(rx, flags);
}

XS(XS_Tie_Hash_NamedCapture_EXISTS)
{
    dVAR;
    dXSARGS;
    REGEXP * rx;
    U32 flags;
    SV * ret;

    if (items != 2)
	croak_xs_usage(cv, "$key, $flags");

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx || !SvROK(ST(0)))
        XSRETURN_UNDEF;

    SP -= items;

    flags = (U32)INT2PTR(IV,SvIV(SvRV(MUTABLE_SV(ST(0)))));
    ret = CALLREG_NAMED_BUFF_EXISTS(rx, ST(1), flags);

    SPAGAIN;

	XPUSHs(ret);
	PUTBACK;
	return;
}

XS(XS_Tie_Hash_NamedCapture_FIRSTK)
{
    dVAR;
    dXSARGS;
    REGEXP * rx;
    U32 flags;
    SV * ret;

    if (items != 1)
	croak_xs_usage(cv, "");

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx || !SvROK(ST(0)))
        XSRETURN_UNDEF;

    SP -= items;

    flags = (U32)INT2PTR(IV,SvIV(SvRV(MUTABLE_SV(ST(0)))));
    ret = CALLREG_NAMED_BUFF_FIRSTKEY(rx, flags);

    SPAGAIN;

    if (ret) {
        mXPUSHs(ret);
        PUTBACK;
    } else {
        XSRETURN_UNDEF;
    }

}

XS(XS_Tie_Hash_NamedCapture_NEXTK)
{
    dVAR;
    dXSARGS;
    REGEXP * rx;
    U32 flags;
    SV * ret;

    if (items != 2)
	croak_xs_usage(cv, "$lastkey");

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx || !SvROK(ST(0)))
        XSRETURN_UNDEF;

    SP -= items;

    flags = (U32)INT2PTR(IV,SvIV(SvRV(MUTABLE_SV(ST(0)))));
    ret = CALLREG_NAMED_BUFF_NEXTKEY(rx, ST(1), flags);

    SPAGAIN;

    if (ret) {
        mXPUSHs(ret);
    } else {
        XSRETURN_UNDEF;
    }  
    PUTBACK;
}

XS(XS_Tie_Hash_NamedCapture_SCALAR)
{
    dVAR;
    dXSARGS;
    REGEXP * rx;
    U32 flags;
    SV * ret;

    if (items != 1)
	croak_xs_usage(cv, "");

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx || !SvROK(ST(0)))
        XSRETURN_UNDEF;

    SP -= items;

    flags = (U32)INT2PTR(IV,SvIV(SvRV(MUTABLE_SV(ST(0)))));
    ret = CALLREG_NAMED_BUFF_SCALAR(rx, flags);

    SPAGAIN;

    if (ret) {
        mXPUSHs(ret);
        PUTBACK;
        return;
    } else {
        XSRETURN_UNDEF;
a1433 15

XS(XS_Tie_Hash_NamedCapture_flags)
{
    dVAR;
    dXSARGS;

    if (items != 0)
	croak_xs_usage(cv, "");

	mXPUSHu(RXapif_ONE);
	mXPUSHu(RXapif_ALL);
	PUTBACK;
	return;
}

@


1.13
log
@Merge in perl 5.10.1
@
text
@d124 1
a124 1
Perl_sv_derived_from(pTHX_ SV *sv, const char *name)
d160 1
a160 1
Perl_sv_does(pTHX_ SV *sv, const char *name)
d175 2
a176 1
		|| (SvGMAGICAL(sv) && SvPOKp(sv) && SvCUR(sv))))
d178 1
d186 2
a187 1
    if (strEQ(name,classname))
d189 1
a240 1
XS(XS_Regexp_DESTROY);
d307 3
a309 1
    newXS("Regexp::DESTROY", XS_Regexp_DESTROY, file);
d549 1
a549 1
	if ( items == 1 || vs == &PL_sv_undef ) { /* no param or explicit undef */
d552 1
a552 1
	    sv_setpvs(vs,"");
d662 1
a662 1
		    robj = new_version(robj);
d746 1
a746 1
	if ( items == 2 && (ST(1)) != &PL_sv_undef ) {
d797 2
a798 1
	const SV * const sv = ST(0);
a967 6
XS(XS_Regexp_DESTROY)
{
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(cv);
}

d1047 4
d1052 1
a1052 1
			      ? sv_2mortal(newSVpvn(SvPVX_const(*namsvp), SvCUR(*namsvp)))
d1055 7
a1061 1
			      ? sv_2mortal(newSVpvn(SvPVX_const(*argsvp), SvCUR(*argsvp)))
a1062 4
		       if (flgok)
			    mXPUSHi(SvIVX(*flgsvp));
		       else
			    XPUSHs(&PL_sv_undef);
d1071 1
a1071 2
			    XPUSHs(sv_2mortal(Perl_newSVpvf(aTHX_ "%"SVf,
						 SVfARG(*namsvp))));
d1372 1
a1372 1
    if (!rx)
d1402 1
a1402 1
    if (!rx) {
d1425 1
a1425 1
    if (!rx)
d1446 1
a1446 1
    if (!rx)
d1468 1
a1468 1
    if (!rx)
d1496 1
a1496 1
    if (!rx)
d1528 1
a1528 1
    if (!rx)
d1559 1
a1559 1
    if (!rx)
@


1.12
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d4 1
a4 1
 *    2005, 2006, 2007 by Larry Wall and others
d12 5
a16 3
 * "The roots of those mountains must be roots indeed; there must be
 * great secrets buried there which have not been discovered since the
 * beginning." --Gandalf, relating Gollum's story
d36 35
d77 1
a77 1
S_isa_lookup(pTHX_ HV *stash, const char * const name, const HV* const name_stash)
d80 4
a83 4
    AV* stash_linear_isa;
    SV** svp;
    const char *hvname;
    I32 items;
d85 1
a85 4
    /* A stash/class can go by many names (ie. User == main::User), so 
       we compare the stash itself just in case */
    if (name_stash && ((const HV *)stash == name_stash))
        return TRUE;
d87 6
a92 1
    hvname = HvNAME_get(stash);
d94 3
a96 2
    if (strEQ(hvname, name))
	return TRUE;
d98 2
a99 2
    if (strEQ(name, "UNIVERSAL"))
	return TRUE;
d101 4
a104 12
    stash_linear_isa = mro_get_linear_isa(stash);
    svp = AvARRAY(stash_linear_isa) + 1;
    items = AvFILLp(stash_linear_isa);
    while (items--) {
	SV* const basename_sv = *svp++;
        HV* const basestash = gv_stashsv(basename_sv, 0);
	if (!basestash) {
	    if (ckWARN(WARN_SYNTAX))
		Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
			    "Can't locate package %"SVf" for the parents of %s",
			    SVfARG(basename_sv), hvname);
	    continue;
a105 2
        if(name_stash == basestash || strEQ(name, SvPVX(basename_sv)))
	    return TRUE;
d129 2
d145 1
a145 7
    if (stash) {
	HV * const name_stash = gv_stashpv(name, 0);
	return isa_lookup(stash, name, name_stash);
    }
    else
	return FALSE;

d165 3
a168 1
    dSP;
d189 1
a189 1
    XPUSHs(sv_2mortal(newSVpv(name, 0)));
d192 1
a192 1
    methodname = sv_2mortal(newSVpvs("isa"));
d224 1
a240 1
XS(XS_Internals_inc_sub_generation);
d245 1
d272 1
d287 2
d312 1
d324 36
a364 1
    PERL_UNUSED_ARG(cv);
d367 1
a367 1
	Perl_croak(aTHX_ "Usage: UNIVERSAL::isa(reference, kind)");
a392 1
    PERL_UNUSED_ARG(cv);
d395 1
a395 1
	Perl_croak(aTHX_ "Usage: UNIVERSAL::can(object-ref, method)");
d409 1
a409 1
        sv = (SV*)SvRV(sv);
d420 1
a420 1
	    rv = sv_2mortal(newRV((SV*)GvCV(gv)));
d459 1
a459 1
        sv = (SV*)SvRV(ST(0));
d479 1
a479 1
        sv = (SV*)&PL_sv_undef;
d505 1
a505 1
	    if ( hv_exists((HV*)SvRV(req), "qv", 2 ) ) {
a532 1
    PERL_UNUSED_ARG(cv);
d534 1
a534 1
	Perl_croak(aTHX_ "Usage: version::new(class, version)");
d547 1
a547 1
	    sv_setpvn(vs,"",0);
d558 1
a558 1
	PUSHs(sv_2mortal(rv));
a567 1
     PERL_UNUSED_ARG(cv);
d569 1
a569 1
	  Perl_croak(aTHX_ "Usage: version::stringify(lobj, ...)");
d580 1
a580 1
	  PUSHs(sv_2mortal(vstringify(lobj)));
a590 1
     PERL_UNUSED_ARG(cv);
d592 1
a592 1
	  Perl_croak(aTHX_ "Usage: version::numify(lobj, ...)");
d603 1
a603 1
	  PUSHs(sv_2mortal(vnumify(lobj)));
a613 1
     PERL_UNUSED_ARG(cv);
d615 1
a615 1
	  Perl_croak(aTHX_ "Usage: version::normal(lobj, ...)");
d626 1
a626 1
	  PUSHs(sv_2mortal(vnormal(lobj)));
a636 1
     PERL_UNUSED_ARG(cv);
d638 1
a638 1
	  Perl_croak(aTHX_ "Usage: version::vcmp(lobj, ...)");
d670 1
a670 1
	       PUSHs(sv_2mortal(rs));
a681 1
    PERL_UNUSED_ARG(cv);
d683 1
a683 1
	Perl_croak(aTHX_ "Usage: version::boolean(lobj, ...)");
d688 1
a688 1
	PUSHs(sv_2mortal(rs));
a699 1
    PERL_UNUSED_ARG(cv);
d701 1
a701 1
	Perl_croak(aTHX_ "Usage: version::noop(lobj, ...)");
a714 1
    PERL_UNUSED_ARG(cv);
d716 1
a716 1
	Perl_croak(aTHX_ "Usage: version::is_alpha(lobj)");
d720 1
a720 1
	if ( hv_exists((HV*)SvRV(lobj), "alpha", 5 ) )
a735 2
    if (items != 1)
	Perl_croak(aTHX_ "Usage: version::qv(ver)");
d738 13
a750 3
	SV *	ver = ST(0);
	if ( !SvVOK(ver) ) { /* only need to do with if not already v-string */
	    SV * const rv = sv_newmortal();
d753 2
a754 1
	    PUSHs(rv);
d756 2
a757 3
	else
	{
	    PUSHs(sv_2mortal(new_version(ver)));
d759 5
d765 13
d781 2
a788 1
     PERL_UNUSED_ARG(cv);
d790 1
a790 1
	  Perl_croak(aTHX_ "Usage: utf8::is_utf8(sv)");
a804 1
     PERL_UNUSED_ARG(cv);
d806 1
a806 1
	  Perl_croak(aTHX_ "Usage: utf8::valid(sv)");
a822 1
    PERL_UNUSED_ARG(cv);
d824 1
a824 1
	Perl_croak(aTHX_ "Usage: utf8::encode(sv)");
a832 1
    PERL_UNUSED_ARG(cv);
d834 1
a834 1
	Perl_croak(aTHX_ "Usage: utf8::decode(sv)");
a847 1
    PERL_UNUSED_ARG(cv);
d849 1
a849 1
	Perl_croak(aTHX_ "Usage: utf8::upgrade(sv)");
a864 1
    PERL_UNUSED_ARG(cv);
d866 1
a866 1
	Perl_croak(aTHX_ "Usage: utf8::downgrade(sv, failok=0)");
a882 1
 PERL_UNUSED_ARG(cv);
d885 1
a885 1
     Perl_croak(aTHX_ "Usage: utf8::native_to_unicode(sv)");
a895 1
 PERL_UNUSED_ARG(cv);
d898 1
a898 1
     Perl_croak(aTHX_ "Usage: utf8::unicode_to_native(sv)");
a951 1
    PERL_UNUSED_ARG(cv);
d954 1
a954 1
	Perl_croak(aTHX_ "Usage: UNIVERSAL::hv_clear_placeholders(hv)");
d956 1
a956 1
	HV * const hv = (HV *) SvRV(ST(0));
a971 1
    PERL_UNUSED_ARG(cv);
d973 1
a973 1
	Perl_croak(aTHX_ "Usage: PerlIO_get_layers(filehandle[,args])");
d1021 1
a1021 1
	gv = (GV*)sv;
d1025 1
a1025 1
		  gv = (GV*)SvRV(sv);
a1030 1
	     dTARGET;
d1048 1
a1048 1
			      ? newSVpvn(SvPVX_const(*namsvp), SvCUR(*namsvp))
d1051 1
a1051 1
			      ? newSVpvn(SvPVX_const(*argsvp), SvCUR(*argsvp))
d1054 1
a1054 1
			    XPUSHi(SvIVX(*flgsvp));
d1061 1
a1061 1
			    XPUSHs(Perl_newSVpvf(aTHX_ "%"SVf"(%"SVf")",
d1063 1
a1063 1
						 SVfARG(*argsvp)));
d1065 2
a1066 2
			    XPUSHs(Perl_newSVpvf(aTHX_ "%"SVf,
						 SVfARG(*namsvp)));
d1074 1
a1074 1
				 XPUSHs(newSVpvs("utf8"));
d1119 1
a1119 1
	const HV * const hv = (HV *) SvRV(ST(0));
d1137 1
a1137 1
       Perl_croak(aTHX_ "Usage: %s(%s)", "re::is_regexp", "sv");
a1153 1
    PERL_UNUSED_ARG(cv);
d1156 1
a1156 1
       Perl_croak(aTHX_ "Usage: %s(%s)", "re::regnames_count", "");
d1168 1
a1168 1
        XPUSHs(ret);
a1182 1
    PERL_UNUSED_ARG(cv);
d1185 1
a1185 1
        Perl_croak(aTHX_ "Usage: %s(%s)", "re::regname", "name[, all ]");
d1202 1
a1202 4
        if (SvROK(ret))
            XPUSHs(ret);
        else
            XPUSHs(SvREFCNT_inc(ret));
a1219 1
    PERL_UNUSED_ARG(cv);
d1222 1
a1222 1
        Perl_croak(aTHX_ "Usage: %s(%s)", "re::regnames", "[all]");
d1246 1
a1246 1
    av = (AV*)SvRV(ret);
d1255 1
a1255 1
        XPUSHs(*entry);
d1257 3
d1264 90
a1360 1
    PERL_UNUSED_ARG(cv);
d1363 1
a1363 1
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::STORE($key, $flags)");
d1372 1
a1372 1
    flags = (U32)INT2PTR(IV,SvIV(SvRV((SV*)ST(0))));
d1378 1
a1378 4
        if (SvROK(ret))
            XPUSHs(ret);
        else
            XPUSHs(SvREFCNT_inc(ret));
a1390 1
    PERL_UNUSED_ARG(cv);
d1393 1
a1393 1
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::STORE($key, $value, $flags)");
d1399 1
a1399 1
            Perl_croak(aTHX_ PL_no_modify);
d1406 1
a1406 1
    flags = (U32)INT2PTR(IV,SvIV(SvRV((SV*)ST(0))));
a1415 1
    PERL_UNUSED_ARG(cv);
d1418 1
a1418 1
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::DELETE($key, $flags)");
d1421 1
a1421 1
        Perl_croak(aTHX_ PL_no_modify);
d1425 1
a1425 1
    flags = (U32)INT2PTR(IV,SvIV(SvRV((SV*)ST(0))));
a1434 1
    PERL_UNUSED_ARG(cv);
d1437 1
a1437 1
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::CLEAR($flags)");
d1442 1
a1442 1
        Perl_croak(aTHX_ PL_no_modify);
d1446 1
a1446 1
    flags = (U32)INT2PTR(IV,SvIV(SvRV((SV*)ST(0))));
a1456 1
    PERL_UNUSED_ARG(cv);
d1459 1
a1459 1
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::EXISTS($key, $flags)");
d1468 1
a1468 1
    flags = (U32)INT2PTR(IV,SvIV(SvRV((SV*)ST(0))));
a1484 1
    PERL_UNUSED_ARG(cv);
d1487 1
a1487 1
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::FIRSTKEY()");
d1496 1
a1496 1
    flags = (U32)INT2PTR(IV,SvIV(SvRV((SV*)ST(0))));
d1502 1
a1502 1
        XPUSHs(SvREFCNT_inc(ret));
a1516 1
    PERL_UNUSED_ARG(cv);
d1519 1
a1519 1
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::NEXTKEY($lastkey)");
d1528 1
a1528 1
    flags = (U32)INT2PTR(IV,SvIV(SvRV((SV*)ST(0))));
d1534 1
a1534 1
        XPUSHs(ret);
a1547 1
    PERL_UNUSED_ARG(cv);
d1550 1
a1550 1
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::SCALAR()");
d1559 1
a1559 1
    flags = (U32)INT2PTR(IV,SvIV(SvRV((SV*)ST(0))));
d1565 1
a1565 1
        XPUSHs(ret);
a1576 1
    PERL_UNUSED_ARG(cv);
d1579 1
a1579 1
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::flags()");
d1581 2
a1582 2
	XPUSHs(sv_2mortal(newSVuv(RXapif_ONE)));
	XPUSHs(sv_2mortal(newSVuv(RXapif_ALL)));
@


1.11
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2005, 2006, by Larry Wall and others
d19 5
d39 6
a44 9
STATIC SV *
S_isa_lookup(pTHX_ HV *stash, const char *name, HV* name_stash,
             int len, int level)
{
    AV* av;
    GV* gv;
    GV** gvp;
    HV* hv = Nullhv;
    SV* subgen = Nullsv;
d46 1
d50 2
a51 2
    if (name_stash && (stash == name_stash))
        return &PL_sv_yes;
d56 1
a56 1
	return &PL_sv_yes;
d59 1
a59 5
	return &PL_sv_yes;

    if (level > 100)
	Perl_croak(aTHX_ "Recursive inheritance detected in package '%s'",
		   hvname);
d61 12
a72 19
    gvp = (GV**)hv_fetch(stash, "::ISA::CACHE::", 14, FALSE);

    if (gvp && (gv = *gvp) != (GV*)&PL_sv_undef && (subgen = GvSV(gv))
	&& (hv = GvHV(gv)))
    {
	if (SvIV(subgen) == (IV)PL_sub_generation) {
	    SV* sv;
	    SV** svp = (SV**)hv_fetch(hv, name, len, FALSE);
	    if (svp && (sv = *svp) != (SV*)&PL_sv_undef) {
	        DEBUG_o( Perl_deb(aTHX_ "Using cached ISA %s for package %s\n",
				  name, hvname) );
		return sv;
	    }
	}
	else {
	    DEBUG_o( Perl_deb(aTHX_ "ISA Cache in package %s is stale\n",
			      hvname) );
	    hv_clear(hv);
	    sv_setiv(subgen, PL_sub_generation);
d74 2
d78 1
a78 42
    gvp = (GV**)hv_fetch(stash,"ISA",3,FALSE);

    if (gvp && (gv = *gvp) != (GV*)&PL_sv_undef && (av = GvAV(gv))) {
	if (!hv || !subgen) {
	    gvp = (GV**)hv_fetch(stash, "::ISA::CACHE::", 14, TRUE);

	    gv = *gvp;

	    if (SvTYPE(gv) != SVt_PVGV)
		gv_init(gv, stash, "::ISA::CACHE::", 14, TRUE);

	    if (!hv)
		hv = GvHVn(gv);
	    if (!subgen) {
		subgen = newSViv(PL_sub_generation);
		GvSV(gv) = subgen;
	    }
	}
	if (hv) {
	    SV** svp = AvARRAY(av);
	    /* NOTE: No support for tied ISA */
	    I32 items = AvFILLp(av) + 1;
	    while (items--) {
		SV* sv = *svp++;
		HV* basestash = gv_stashsv(sv, FALSE);
		if (!basestash) {
		    if (ckWARN(WARN_MISC))
			Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				    "Can't locate package %"SVf" for @@%s::ISA",
				    sv, hvname);
		    continue;
		}
		if (&PL_sv_yes == isa_lookup(basestash, name, name_stash, 
                                             len, level + 1)) {
		    (void)hv_store(hv,name,len,&PL_sv_yes,0);
		    return &PL_sv_yes;
		}
	    }
	    (void)hv_store(hv,name,len,&PL_sv_no,0);
	}
    }
    return &PL_sv_no;
d86 3
a88 3
Returns a boolean indicating whether the SV is derived from the specified
class.  This is the function that implements C<UNIVERSAL::isa>.  It works
for class names as well as for objects.
d96 2
a97 3
    const char *type = Nullch;
    HV *stash = Nullhv;
    HV *name_stash;
d99 1
a99 2
    if (SvGMAGICAL(sv))
        mg_get(sv) ;
d102 1
d105 3
a107 2
        if (SvOBJECT(sv))
            stash = SvSTASH(sv);
d110 1
a110 1
        stash = gv_stashsv(sv, FALSE);
d113 6
a118 1
    name_stash = gv_stashpv(name, FALSE);
a119 5
    return (type && strEQ(type,name)) ||
            (stash && isa_lookup(stash, name, name_stash, strlen(name), 0) 
             == &PL_sv_yes)
        ? TRUE
        : FALSE ;
d122 9
d133 46
d181 1
d183 13
d212 14
d230 2
a231 1
    const char file[] = __FILE__;
d233 35
a267 13
    newXS("UNIVERSAL::isa",             XS_UNIVERSAL_isa,         (char *)file);
    newXS("UNIVERSAL::can",             XS_UNIVERSAL_can,         (char *)file);
    newXS("UNIVERSAL::VERSION", 	XS_UNIVERSAL_VERSION, 	  (char *)file);
    newXS("utf8::is_utf8", XS_utf8_is_utf8, (char *)file);
    newXS("utf8::valid", XS_utf8_valid, (char *)file);
    newXS("utf8::encode", XS_utf8_encode, (char *)file);
    newXS("utf8::decode", XS_utf8_decode, (char *)file);
    newXS("utf8::upgrade", XS_utf8_upgrade, (char *)file);
    newXS("utf8::downgrade", XS_utf8_downgrade, (char *)file);
    newXS("utf8::native_to_unicode", XS_utf8_native_to_unicode, (char *)file);
    newXS("utf8::unicode_to_native", XS_utf8_unicode_to_native, (char *)file);
    newXSproto("Internals::SvREADONLY",XS_Internals_SvREADONLY, (char *)file, "\\[$%@@];$");
    newXSproto("Internals::SvREFCNT",XS_Internals_SvREFCNT, (char *)file, "\\[$%@@];$");
d269 1
a269 1
               XS_Internals_hv_clear_placehold, (char *)file, "\\%");
d271 18
a288 5
               XS_PerlIO_get_layers, (char *)file, "*;@@");
    newXS("Regexp::DESTROY", XS_Regexp_DESTROY, (char *)file);
    newXSproto("Internals::hash_seed",XS_Internals_hash_seed, (char *)file, "");
    newXSproto("Internals::rehash_seed",XS_Internals_rehash_seed, (char *)file, "");
    newXSproto("Internals::HvREHASH", XS_Internals_HvREHASH, (char *)file, "\\%");
d294 1
d296 1
a296 2
    SV *sv;
    const char *name;
d300 3
d304 1
a304 1
    sv = ST(0);
d306 3
a308 6
    if (SvGMAGICAL(sv))
	mg_get(sv);

    if (!SvOK(sv) || !(SvROK(sv) || (SvPOK(sv) && SvCUR(sv))
		|| (SvGMAGICAL(sv) && SvPOKp(sv) && SvCUR(sv))))
	XSRETURN_UNDEF;
d310 1
a310 1
    name = SvPV_nolen_const(ST(1));
d312 3
a314 2
    ST(0) = boolSV(sv_derived_from(sv, name));
    XSRETURN(1);
d319 1
d325 1
d332 1
a332 2
    if (SvGMAGICAL(sv))
	mg_get(sv);
d347 1
a347 1
        pkg = gv_stashsv(sv, FALSE);
d351 1
a351 1
        GV *gv = gv_fetchmethod_autoload(pkg, name, FALSE);
d360 20
d382 1
d389 1
d398 1
a398 1
        pkg = gv_stashsv(ST(0), FALSE);
d401 1
a401 1
    gvp = pkg ? (GV**)hv_fetch(pkg,"VERSION",7,FALSE) : Null(GV**);
d404 1
a404 1
        SV *nsv = sv_newmortal();
d407 3
a409 1
        undef = Nullch;
d421 1
a421 1
		const char *name = HvNAME_get(pkg);
d423 2
a424 2
			     "%s does not define $%s::VERSION--version check failed",
			     name, name);
d431 17
a447 26
	if (!SvNIOK(sv) && SvPOK(sv)) {
	    STRLEN len;
	    char *str = SvPVx(sv,len);
	    while (len) {
		--len;
		/* XXX could DWIM "1.2.3" here */
		if (!isDIGIT(str[len]) && str[len] != '.' && str[len] != '_')
		    break;
	    }
	    if (len) {
		if (SvNOK(req) && SvPOK(req)) {
		    /* they said C<use Foo v1.2.3> and $Foo::VERSION
		     * doesn't look like a float: do string compare */
		    if (sv_cmp(req,sv) == 1) {
			Perl_croak(aTHX_ "%s v%"VDf" required--"
				   "this is only v%"VDf,
				   HvNAME(pkg), req, sv);
		    }
		    goto finish;
		}
		/* they said C<use Foo 1.002_003> and $Foo::VERSION
		 * doesn't look like a float: force numeric compare */
		(void)SvUPGRADE(sv, SVt_PVNV);
		SvNVX(sv) = str_to_version(sv);
		SvPOK_off(sv);
		SvNOK_on(sv);
d450 1
a450 12
	/* if we get here, we're looking for a numeric comparison,
	 * so force the required version into a float, even if they
	 * said C<use Foo v1.2.3> */
	if (SvNOK(req) && SvPOK(req)) {
	    NV n = SvNV(req);
	    req = sv_newmortal();
	    sv_setnv(req, n);
	}

	if (SvNV(req) > SvNV(sv))
	    Perl_croak(aTHX_ "%s version %s required--this is only version %s",
		       HvNAME_get(pkg), SvPV_nolen(req), SvPV_nolen(sv));
d453 5
a457 2
finish:
    ST(0) = sv;
d462 109
a570 1
XS(XS_utf8_is_utf8)
d572 1
d574 4
a577 2
     if (items != 1)
	  Perl_croak(aTHX_ "Usage: utf8::is_utf8(sv)");
d579 8
a586 1
          const SV *sv = ST(0);
d588 15
a602 2
	       if (SvUTF8(sv))
		    XSRETURN_YES;
d604 5
a608 1
		    XSRETURN_NO;
d610 101
d717 1
d719 1
d722 9
a730 11
     {
	  SV *	sv = ST(0);
	  {
	       STRLEN len;
	       const char *s = SvPV_const(sv,len);
	       if (!SvUTF8(sv) || is_utf8_string((U8*)s,len))
		    XSRETURN_YES;
	       else
		    XSRETURN_NO;
	  }
     }
d736 1
d738 1
d741 1
a741 5
    {
	SV *	sv = ST(0);

	sv_utf8_encode(sv);
    }
d747 1
d749 1
d752 2
a753 2
    {
	SV *	sv = ST(0);
d763 1
d765 1
d768 2
a769 2
    {
	SV *	sv = ST(0);
d781 1
d783 1
d786 2
a787 2
    {
	SV *	sv = ST(0);
d799 1
d802 1
d813 1
d816 1
d827 1
d829 2
a830 1
    SV *sv = SvRV(ST(0));
d854 1
d856 2
a857 1
    SV *sv = SvRV(ST(0));
d871 1
d873 1
a873 1
    HV *hv = (HV *) SvRV(ST(0));
d877 5
a881 2
    hv_clear_placeholders(hv);
    XSRETURN(0);
d886 1
d892 1
d894 1
d906 1
a906 2
	     SV **svp;
	     
d908 2
a909 2
		  SV **varp = svp;
		  SV **valp = svp + 1;
d911 1
a911 1
                  const char *key = SvPV_const(*varp, klen);
d950 1
a950 1
		  gv = gv_fetchpv(SvPVX(sv), FALSE, SVt_PVIO);
d955 1
a955 1
	     AV* av = PerlIO_get_layers(aTHX_ input ?
d958 1
a958 1
	     I32 last = av_len(av);
d962 7
a968 12
		  SV **namsvp;
		  SV **argsvp;
		  SV **flgsvp;
		  bool namok, argok, flgok;

		  namsvp = av_fetch(av, i - 2, FALSE);
		  argsvp = av_fetch(av, i - 1, FALSE);
		  flgsvp = av_fetch(av, i,     FALSE);

		  namok = namsvp && *namsvp && SvPOK(*namsvp);
		  argok = argsvp && *argsvp && SvPOK(*argsvp);
		  flgok = flgsvp && *flgsvp && SvIOK(*flgsvp);
d986 2
a987 1
					       *namsvp, *argsvp));
d989 2
a990 1
			    XPUSHs(Perl_newSVpvf(aTHX_ "%"SVf, *namsvp));
d995 1
a995 1
			    IV flags = SvIVX(*flgsvp);
d998 1
a998 1
				 XPUSHs(newSVpvn("utf8", 4));
d1017 1
d1028 1
d1039 1
d1041 1
d1043 1
a1043 1
	const HV *hv = (HV *) SvRV(ST(0));
d1053 383
@


1.10
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    by Larry Wall and others
d43 1
d50 3
a52 1
    if (strEQ(HvNAME(stash), name))
d60 1
a60 1
		   HvNAME(stash));
d72 1
a72 1
				  name, HvNAME(stash)) );
d78 1
a78 1
			      HvNAME(stash)) );
d112 2
a113 2
		             "Can't locate package %"SVf" for @@%s::ISA",
			    sv, HvNAME(stash));
d143 2
a144 2
    char *type;
    HV *stash;
a146 3
    stash = Nullhv;
    type = Nullch;

d171 3
a173 3
void XS_UNIVERSAL_isa(pTHX_ CV *cv);
void XS_UNIVERSAL_can(pTHX_ CV *cv);
void XS_UNIVERSAL_VERSION(pTHX_ CV *cv);
d194 1
a194 1
    char *file = __FILE__;
d196 13
a208 13
    newXS("UNIVERSAL::isa",             XS_UNIVERSAL_isa,         file);
    newXS("UNIVERSAL::can",             XS_UNIVERSAL_can,         file);
    newXS("UNIVERSAL::VERSION", 	XS_UNIVERSAL_VERSION, 	  file);
    newXS("utf8::is_utf8", XS_utf8_is_utf8, file);
    newXS("utf8::valid", XS_utf8_valid, file);
    newXS("utf8::encode", XS_utf8_encode, file);
    newXS("utf8::decode", XS_utf8_decode, file);
    newXS("utf8::upgrade", XS_utf8_upgrade, file);
    newXS("utf8::downgrade", XS_utf8_downgrade, file);
    newXS("utf8::native_to_unicode", XS_utf8_native_to_unicode, file);
    newXS("utf8::unicode_to_native", XS_utf8_unicode_to_native, file);
    newXSproto("Internals::SvREADONLY",XS_Internals_SvREADONLY, file, "\\[$%@@];$");
    newXSproto("Internals::SvREFCNT",XS_Internals_SvREFCNT, file, "\\[$%@@];$");
d210 1
a210 1
               XS_Internals_hv_clear_placehold, file, "\\%");
d212 5
a216 5
               XS_PerlIO_get_layers, file, "*;@@");
    newXS("Regexp::DESTROY", XS_Regexp_DESTROY, file);
    newXSproto("Internals::hash_seed",XS_Internals_hash_seed, file, "");
    newXSproto("Internals::rehash_seed",XS_Internals_rehash_seed, file, "");
    newXSproto("Internals::HvREHASH", XS_Internals_HvREHASH, file, "\\%");
d224 1
a224 2
    char *name;
    STRLEN n_a;
d238 1
a238 1
    name = (char *)SvPV(ST(1),n_a);
d248 1
a248 1
    char *name;
a250 1
    STRLEN n_a;
d264 1
a264 1
    name = (char *)SvPV(ST(1),n_a);
d293 1
a293 1
    char *undef;
d307 1
a307 1
    if (gvp && isGV(gv = *gvp) && SvOK(sv = GvSV(gv))) {
a318 1
	STRLEN len;
d322 3
a324 2
	     if (pkg)
		  Perl_croak(aTHX_
d326 5
a330 6
			     HvNAME(pkg), HvNAME(pkg));
	     else {
		  char *str = SvPVx(ST(0), len);

		  Perl_croak(aTHX_
			     "%s defines neither package nor VERSION--version check failed", str);
d334 1
d372 1
a372 1
		       HvNAME(pkg), SvPV_nolen(req), SvPV_nolen(sv));
d387 1
a387 1
	  SV *	sv = ST(0);
d407 1
a407 1
	       char *s = SvPV(sv,len);
d437 1
a437 3
	bool	RETVAL;

	RETVAL = sv_utf8_decode(sv);
d467 2
a468 8
	bool	failok;
	bool	RETVAL;

	if (items < 2)
	    failok = 0;
	else {
	    failok = (int)SvIV(ST(1));
	}
a469 1
	RETVAL = sv_utf8_downgrade(sv, failok);
d479 1
a479 1
 UV uv = SvUV(ST(0));
d491 1
a491 1
 UV uv = SvUV(ST(0));
d504 1
d529 1
d544 1
d553 1
a553 1

d576 1
a576 1
		  char *key = SvPV(*varp, klen);
d614 1
a614 1
	     else
d641 6
a646 4
		       XPUSHs(namok ?
			     newSVpv(SvPVX(*namsvp), 0) : &PL_sv_undef);
		       XPUSHs(argok ?
			     newSVpv(SvPVX(*argsvp), 0) : &PL_sv_undef);
d687 3
a689 1
    dMARK; dAX;
d697 3
a699 1
    dMARK; dAX;
d707 1
a707 1
	HV *hv = (HV *) SvRV(ST(0));
d717 10
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d17 4
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d3 1
a3 1
 *    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@a544 2
/* Maybe this should return the number of placeholders found in scalar context,
   and a list of them in list context.  */
d549 3
a551 41

    /* I don't care how many parameters were passed in, but I want to avoid
       the unused variable warning. */

    items = (I32)HvPLACEHOLDERS(hv);

    if (items) {
        HE *entry;
        I32 riter = HvRITER(hv);
        HE *eiter = HvEITER(hv);
        hv_iterinit(hv);
        /* This may look suboptimal with the items *after* the iternext, but
           it's quite deliberate. We only get here with items==0 if we've
           just deleted the last placeholder in the hash. If we've just done
           that then it means that the hash is in lazy delete mode, and the
           HE is now only referenced in our iterator. If we just quit the loop
           and discarded our iterator then the HE leaks. So we do the && the
           other way to ensure iternext is called just one more time, which
           has the side effect of triggering the lazy delete.  */
        while ((entry = hv_iternext_flags(hv, HV_ITERNEXT_WANTPLACEHOLDERS))
            && items) {
            SV *val = hv_iterval(hv, entry);

            if (val == &PL_sv_placeholder) {

                /* It seems that I have to go back in the front of the hash
                   API to delete a hash, even though I have a HE structure
                   pointing to the very entry I want to delete, and could hold
                   onto the previous HE that points to it. And it's easier to
                   go in with SVs as I can then specify the precomputed hash,
                   and don't have fun and games with utf8 keys.  */
                SV *key = hv_iterkeysv(entry);

                hv_delete_ent (hv, key, G_DISCARD, HeHASH(entry));
                items--;
            }
        }
        HvRITER(hv) = riter;
        HvEITER(hv) = eiter;
    }

@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1997-2002, Larry Wall
d21 4
d48 3
d105 2
a106 2
		             "Can't locate package %s for @@%s::ISA",
			    SvPVX(sv), HvNAME(stash));
d118 1
a118 2

    return boolSV(strEQ(name, "UNIVERSAL"));
d170 1
d181 5
d195 1
d207 6
d231 2
a232 1
    if (!SvOK(sv) || !(SvROK(sv) || (SvPOK(sv) && SvCUR(sv))))
d258 2
a259 1
    if (!SvOK(sv) || !(SvROK(sv) || (SvPOK(sv) && SvCUR(sv))))
d379 17
d398 15
a412 15
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: utf8::valid(sv)");
    {
	SV *	sv = ST(0);
 {
  STRLEN len;
  char *s = SvPV(sv,len);
  if (!SvUTF8(sv) || is_utf8_string((U8*)s,len))
   XSRETURN_YES;
  else
   XSRETURN_NO;
 }
    }
    XSRETURN_EMPTY;
d574 1
a574 1
            if (val == &PL_sv_undef) {
d593 161
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d1 15
d26 2
a27 1
S_isa_lookup(pTHX_ HV *stash, const char *name, int len, int level)
d35 4
a38 2
    if (!stash)
	return &PL_sv_undef;
d52 1
a52 1
	if (SvIV(subgen) == PL_sub_generation) {
d96 1
a96 1
			Perl_warner(aTHX_ WARN_SYNTAX,
d101 2
a102 1
		if (&PL_sv_yes == isa_lookup(basestash, name, len, level + 1)) {
d115 2
d131 1
d149 2
d152 2
a153 1
            (stash && isa_lookup(stash, name, strlen(name), 0) == &PL_sv_yes)
d158 15
a172 3
void XS_UNIVERSAL_isa(pTHXo_ CV *cv);
void XS_UNIVERSAL_can(pTHXo_ CV *cv);
void XS_UNIVERSAL_VERSION(pTHXo_ CV *cv);
d182 11
a194 1
#include "XSUB.h"
d298 12
a309 4
	if (undef)
	    Perl_croak(aTHX_ "%s does not define $%s::VERSION--version check failed",
		       HvNAME(pkg), HvNAME(pkg));

d348 1
a348 1
		  HvNAME(pkg), SvPV(req,len), SvPV(sv,len));
d357 198
@


1.4
log
@Update from perl-current--fixes the op/universal test.
@
text
@a76 1
		    dTHR;
d268 2
a269 2
			Perl_croak(aTHX_ "%s v%vd required--"
				   "this is only v%vd",
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d17 1
d22 1
a22 1
    if(strEQ(HvNAME(stash), name))
d26 2
a27 1
	Perl_croak(aTHX_ "Recursive inheritance detected in package '%s'", HvNAME(stash));
d31 18
a48 5
    if (gvp && (gv = *gvp) != (GV*)&PL_sv_undef && (hv = GvHV(gv))) {
	SV* sv;
	SV** svp = (SV**)hv_fetch(hv, name, len, FALSE);
	if (svp && (sv = *svp) != (SV*)&PL_sv_undef)
	    return sv;
d52 1
a52 1
    
d54 1
a54 1
	if(!hv) {
d62 6
a67 1
	    hv = GvHVn(gv);
d69 1
a69 1
	if(hv) {
d84 1
a84 1
		if(&PL_sv_yes == isa_lookup(basestash, name, len, level + 1)) {
d111 1
a111 1
  
d114 1
a114 1
 
d121 1
a121 1
        if(SvOBJECT(sv))
d127 1
a127 1
 
d197 1
a197 1
    if(SvROK(sv)) {
d199 1
a199 1
        if(SvOBJECT(sv))
d265 1
a265 1
		if (SvNIOKp(req) && SvPOK(req)) {
d286 1
a286 1
	if (SvNIOKp(req) && SvPOK(req)) {
@


1.2
log
@perl5.005_03 (stock)
@
text
@d2 1
d11 1
a11 1
isa_lookup(HV *stash, char *name, int len, int level)
d25 1
a25 1
	croak("Recursive inheritance detected in package '%s'", HvNAME(stash));
d57 4
a60 2
		    if (PL_dowarn)
			warn("Can't locate package %s for @@%s::ISA",
d76 10
d87 1
a87 1
sv_derived_from(SV *sv, char *name)
a88 1
    SV *rv;
a111 1
 
d114 13
a126 3
#ifdef PERL_OBJECT
#define NO_XSLOCKS
#endif  /* PERL_OBJECT */
d138 1
a138 1
	croak("Usage: UNIVERSAL::isa(reference, kind)");
d141 7
d164 1
a164 1
	croak("Usage: UNIVERSAL::can(object-ref, method)");
d167 7
a203 1
    double req;
d205 1
a205 1
    if(SvROK(ST(0))) {
d207 2
a208 2
        if(!SvOBJECT(sv))
            croak("Cannot find version of an unblessed reference");
d217 1
a217 1
    if (gvp && (gv = *gvp) != (GV*)&PL_sv_undef && (sv = GvSV(gv))) {
d228 47
a274 4
    if (items > 1 && (undef || (req = SvNV(ST(1)), req > SvNV(sv)))) {
	STRLEN n_a;
	croak("%s version %s required--this is only version %s",
	      HvNAME(pkg), SvPV(ST(1),n_a), undef ? undef : SvPV(sv,n_a));
d277 1
a282 15
#ifdef PERL_OBJECT
#undef  boot_core_UNIVERSAL
#define boot_core_UNIVERSAL CPerlObj::Perl_boot_core_UNIVERSAL
#define pPerl this
#endif

void
boot_core_UNIVERSAL(void)
{
    char *file = __FILE__;

    newXS("UNIVERSAL::isa",             XS_UNIVERSAL_isa,         file);
    newXS("UNIVERSAL::can",             XS_UNIVERSAL_can,         file);
    newXS("UNIVERSAL::VERSION", 	XS_UNIVERSAL_VERSION, 	  file);
}
@


1.1
log
@perl 5.004_04
@
text
@a2 1
#include "XSUB.h"
d9 2
a10 6
static SV *
isa_lookup(stash, name, len, level)
HV *stash;
char *name;
int len;
int level;
d18 1
a18 1
	return &sv_undef;
d21 1
a21 1
	return &sv_yes;
d24 1
a24 1
	croak("Recursive inheritance detected");
d28 1
a28 1
    if (gvp && (gv = *gvp) != (GV*)&sv_undef && (hv = GvHV(gv))) {
d31 1
a31 1
	if (svp && (sv = *svp) != (SV*)&sv_undef)
d37 1
a37 1
    if (gvp && (gv = *gvp) != (GV*)&sv_undef && (av = GvAV(gv))) {
d50 2
a51 1
	    I32 items = AvFILL(av) + 1;
d56 1
a56 1
		    if (dowarn)
d61 3
a63 3
		if(&sv_yes == isa_lookup(basestash, name, len, level + 1)) {
		    (void)hv_store(hv,name,len,&sv_yes,0);
		    return &sv_yes;
d66 1
a66 1
	    (void)hv_store(hv,name,len,&sv_no,0);
d74 1
a74 3
sv_derived_from(sv, name)
SV * sv ;
char * name ;
d97 1
a97 1
            (stash && isa_lookup(stash, name, strlen(name), 0) == &sv_yes)
d103 5
a108 1
static
d114 1
d120 1
a120 1
    name = (char *)SvPV(ST(1),na);
a125 1
static
d133 1
d139 2
a140 2
    name = (char *)SvPV(ST(1),na);
    rv = &sv_undef;
a160 1
static
d183 1
a183 1
    if (gvp && (gv = *gvp) != (GV*)&sv_undef && (sv = GvSV(gv))) {
d190 1
a190 1
        sv = (SV*)&sv_undef;
d194 2
a195 1
    if (items > 1 && (undef || (req = SvNV(ST(1)), req > SvNV(sv))))
d197 2
a198 1
	      HvNAME(pkg), SvPV(ST(1),na), undef ? undef : SvPV(sv,na));
d205 6
d212 1
a212 1
boot_core_UNIVERSAL()
@


1.1.1.1
log
@perl5.005_03
@
text
@d3 1
d10 6
a15 2
STATIC SV *
isa_lookup(HV *stash, char *name, int len, int level)
d23 1
a23 1
	return &PL_sv_undef;
d26 1
a26 1
	return &PL_sv_yes;
d29 1
a29 1
	croak("Recursive inheritance detected in package '%s'", HvNAME(stash));
d33 1
a33 1
    if (gvp && (gv = *gvp) != (GV*)&PL_sv_undef && (hv = GvHV(gv))) {
d36 1
a36 1
	if (svp && (sv = *svp) != (SV*)&PL_sv_undef)
d42 1
a42 1
    if (gvp && (gv = *gvp) != (GV*)&PL_sv_undef && (av = GvAV(gv))) {
d55 1
a55 2
	    /* NOTE: No support for tied ISA */
	    I32 items = AvFILLp(av) + 1;
d60 1
a60 1
		    if (PL_dowarn)
d65 3
a67 3
		if(&PL_sv_yes == isa_lookup(basestash, name, len, level + 1)) {
		    (void)hv_store(hv,name,len,&PL_sv_yes,0);
		    return &PL_sv_yes;
d70 1
a70 1
	    (void)hv_store(hv,name,len,&PL_sv_no,0);
d78 3
a80 1
sv_derived_from(SV *sv, char *name)
d103 1
a103 1
            (stash && isa_lookup(stash, name, strlen(name), 0) == &PL_sv_yes)
a108 5
#ifdef PERL_OBJECT
#define NO_XSLOCKS
#endif  /* PERL_OBJECT */

#include "XSUB.h"
d110 1
a115 1
    STRLEN n_a;
d121 1
a121 1
    name = (char *)SvPV(ST(1),n_a);
d127 1
a134 1
    STRLEN n_a;
d140 2
a141 2
    name = (char *)SvPV(ST(1),n_a);
    rv = &PL_sv_undef;
d162 1
d185 1
a185 1
    if (gvp && (gv = *gvp) != (GV*)&PL_sv_undef && (sv = GvSV(gv))) {
d192 1
a192 1
        sv = (SV*)&PL_sv_undef;
d196 1
a196 2
    if (items > 1 && (undef || (req = SvNV(ST(1)), req > SvNV(sv)))) {
	STRLEN n_a;
d198 1
a198 2
	      HvNAME(pkg), SvPV(ST(1),n_a), undef ? undef : SvPV(sv,n_a));
    }
a204 6
#ifdef PERL_OBJECT
#undef  boot_core_UNIVERSAL
#define boot_core_UNIVERSAL CPerlObj::Perl_boot_core_UNIVERSAL
#define pPerl this
#endif

d206 1
a206 1
boot_core_UNIVERSAL(void)
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@a1 1
#define PERL_IN_UNIVERSAL_C
d10 1
a10 1
S_isa_lookup(pTHX_ HV *stash, const char *name, int len, int level)
d24 1
a24 1
	Perl_croak(aTHX_ "Recursive inheritance detected in package '%s'", HvNAME(stash));
d56 2
a57 4
		    dTHR;
		    if (ckWARN(WARN_MISC))
			Perl_warner(aTHX_ WARN_SYNTAX,
		             "Can't locate package %s for @@%s::ISA",
a72 10
/*
=for apidoc sv_derived_from

Returns a boolean indicating whether the SV is derived from the specified
class.  This is the function that implements C<UNIVERSAL::isa>.  It works
for class names as well as for objects.

=cut
*/

d74 1
a74 1
Perl_sv_derived_from(pTHX_ SV *sv, const char *name)
d76 1
d100 1
d103 3
a105 13
void XS_UNIVERSAL_isa(pTHXo_ CV *cv);
void XS_UNIVERSAL_can(pTHXo_ CV *cv);
void XS_UNIVERSAL_VERSION(pTHXo_ CV *cv);

void
Perl_boot_core_UNIVERSAL(pTHX)
{
    char *file = __FILE__;

    newXS("UNIVERSAL::isa",             XS_UNIVERSAL_isa,         file);
    newXS("UNIVERSAL::can",             XS_UNIVERSAL_can,         file);
    newXS("UNIVERSAL::VERSION", 	XS_UNIVERSAL_VERSION, 	  file);
}
d117 1
a117 1
	Perl_croak(aTHX_ "Usage: UNIVERSAL::isa(reference, kind)");
a119 7

    if (SvGMAGICAL(sv))
	mg_get(sv);

    if (!SvOK(sv) || !(SvROK(sv) || (SvPOK(sv) && SvCUR(sv))))
	XSRETURN_UNDEF;

d136 1
a136 1
	Perl_croak(aTHX_ "Usage: UNIVERSAL::can(object-ref, method)");
a138 7

    if (SvGMAGICAL(sv))
	mg_get(sv);

    if (!SvOK(sv) || !(SvROK(sv) || (SvPOK(sv) && SvCUR(sv))))
	XSRETURN_UNDEF;

d169 1
d171 1
a171 1
    if (SvROK(ST(0))) {
d173 2
a174 2
        if (!SvOBJECT(sv))
            Perl_croak(aTHX_ "Cannot find version of an unblessed reference");
d183 1
a183 1
    if (gvp && isGV(gv = *gvp) && SvOK(sv = GvSV(gv))) {
d194 4
a197 47
    if (items > 1) {
	STRLEN len;
	SV *req = ST(1);

	if (undef)
	    Perl_croak(aTHX_ "%s does not define $%s::VERSION--version check failed",
		       HvNAME(pkg), HvNAME(pkg));

	if (!SvNIOK(sv) && SvPOK(sv)) {
	    char *str = SvPVx(sv,len);
	    while (len) {
		--len;
		/* XXX could DWIM "1.2.3" here */
		if (!isDIGIT(str[len]) && str[len] != '.' && str[len] != '_')
		    break;
	    }
	    if (len) {
		if (SvNIOKp(req) && SvPOK(req)) {
		    /* they said C<use Foo v1.2.3> and $Foo::VERSION
		     * doesn't look like a float: do string compare */
		    if (sv_cmp(req,sv) == 1) {
			Perl_croak(aTHX_ "%s v%vd required--"
				   "this is only v%vd",
				   HvNAME(pkg), req, sv);
		    }
		    goto finish;
		}
		/* they said C<use Foo 1.002_003> and $Foo::VERSION
		 * doesn't look like a float: force numeric compare */
		(void)SvUPGRADE(sv, SVt_PVNV);
		SvNVX(sv) = str_to_version(sv);
		SvPOK_off(sv);
		SvNOK_on(sv);
	    }
	}
	/* if we get here, we're looking for a numeric comparison,
	 * so force the required version into a float, even if they
	 * said C<use Foo v1.2.3> */
	if (SvNIOKp(req) && SvPOK(req)) {
	    NV n = SvNV(req);
	    req = sv_newmortal();
	    sv_setnv(req, n);
	}

	if (SvNV(req) > SvNV(sv))
	    Perl_croak(aTHX_ "%s version %s required--this is only version %s",
		  HvNAME(pkg), SvPV(req,len), SvPV(sv,len));
a199 1
finish:
d205 15
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@a16 1
    SV* subgen = Nullsv;
d21 1
a21 1
    if (strEQ(HvNAME(stash), name))
d25 1
a25 2
	Perl_croak(aTHX_ "Recursive inheritance detected in package '%s'",
		   HvNAME(stash));
d29 5
a33 18
    if (gvp && (gv = *gvp) != (GV*)&PL_sv_undef && (subgen = GvSV(gv))
	&& (hv = GvHV(gv)))
    {
	if (SvIV(subgen) == PL_sub_generation) {
	    SV* sv;
	    SV** svp = (SV**)hv_fetch(hv, name, len, FALSE);
	    if (svp && (sv = *svp) != (SV*)&PL_sv_undef) {
	        DEBUG_o( Perl_deb(aTHX_ "Using cached ISA %s for package %s\n",
				  name, HvNAME(stash)) );
		return sv;
	    }
	}
	else {
	    DEBUG_o( Perl_deb(aTHX_ "ISA Cache in package %s is stale\n",
			      HvNAME(stash)) );
	    hv_clear(hv);
	    sv_setiv(subgen, PL_sub_generation);
	}
d37 1
a37 1

d39 1
a39 1
	if (!hv || !subgen) {
d47 1
a47 6
	    if (!hv)
		hv = GvHVn(gv);
	    if (!subgen) {
		subgen = newSViv(PL_sub_generation);
		GvSV(gv) = subgen;
	    }
d49 1
a49 1
	if (hv) {
d57 1
d64 1
a64 1
		if (&PL_sv_yes == isa_lookup(basestash, name, len, level + 1)) {
d91 1
a91 1

d94 1
a94 1

d101 1
a101 1
        if (SvOBJECT(sv))
d107 1
a107 1

d177 1
a177 1
    if (SvROK(sv)) {
d179 1
a179 1
        if (SvOBJECT(sv))
d245 1
a245 1
		if (SvNOK(req) && SvPOK(req)) {
d249 2
a250 2
			Perl_croak(aTHX_ "%s v%"VDf" required--"
				   "this is only v%"VDf,
d266 1
a266 1
	if (SvNOK(req) && SvPOK(req)) {
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a0 15
/*    universal.c
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * "The roots of those mountains must be roots indeed; there must be
 * great secrets buried there which have not been discovered since the
 * beginning." --Gandalf, relating Gollum's story
 */

d11 1
a11 2
S_isa_lookup(pTHX_ HV *stash, const char *name, HV* name_stash,
             int len, int level)
d19 2
a20 4
    /* A stash/class can go by many names (ie. User == main::User), so 
       we compare the stash itself just in case */
    if (name_stash && (stash == name_stash))
        return &PL_sv_yes;
d34 1
a34 1
	if (SvIV(subgen) == (IV)PL_sub_generation) {
d78 1
a78 1
			Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
d83 1
a83 2
		if (&PL_sv_yes == isa_lookup(basestash, name, name_stash, 
                                             len, level + 1)) {
a95 2
=head1 SV Manipulation Functions

a109 1
    HV *name_stash;
a126 2
    name_stash = gv_stashpv(name, FALSE);

d128 1
a128 2
            (stash && isa_lookup(stash, name, name_stash, strlen(name), 0) 
             == &PL_sv_yes)
d133 3
a135 15
#include "XSUB.h"

void XS_UNIVERSAL_isa(pTHX_ CV *cv);
void XS_UNIVERSAL_can(pTHX_ CV *cv);
void XS_UNIVERSAL_VERSION(pTHX_ CV *cv);
XS(XS_utf8_valid);
XS(XS_utf8_encode);
XS(XS_utf8_decode);
XS(XS_utf8_upgrade);
XS(XS_utf8_downgrade);
XS(XS_utf8_unicode_to_native);
XS(XS_utf8_native_to_unicode);
XS(XS_Internals_SvREADONLY);
XS(XS_Internals_SvREFCNT);
XS(XS_Internals_hv_clear_placehold);
a144 11
    newXS("utf8::valid", XS_utf8_valid, file);
    newXS("utf8::encode", XS_utf8_encode, file);
    newXS("utf8::decode", XS_utf8_decode, file);
    newXS("utf8::upgrade", XS_utf8_upgrade, file);
    newXS("utf8::downgrade", XS_utf8_downgrade, file);
    newXS("utf8::native_to_unicode", XS_utf8_native_to_unicode, file);
    newXS("utf8::unicode_to_native", XS_utf8_unicode_to_native, file);
    newXSproto("Internals::SvREADONLY",XS_Internals_SvREADONLY, file, "\\[$%@@];$");
    newXSproto("Internals::SvREFCNT",XS_Internals_SvREFCNT, file, "\\[$%@@];$");
    newXSproto("Internals::hv_clear_placeholders",
               XS_Internals_hv_clear_placehold, file, "\\%");
d147 1
d251 4
a254 12
	if (undef) {
	     if (pkg)
		  Perl_croak(aTHX_
			     "%s does not define $%s::VERSION--version check failed",
			     HvNAME(pkg), HvNAME(pkg));
	     else {
		  char *str = SvPVx(ST(0), len);

		  Perl_croak(aTHX_
			     "%s defines neither package nor VERSION--version check failed", str);
	     }
	}
d293 1
a293 1
		       HvNAME(pkg), SvPV_nolen(req), SvPV_nolen(sv));
a301 198
XS(XS_utf8_valid)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: utf8::valid(sv)");
    {
	SV *	sv = ST(0);
 {
  STRLEN len;
  char *s = SvPV(sv,len);
  if (!SvUTF8(sv) || is_utf8_string((U8*)s,len))
   XSRETURN_YES;
  else
   XSRETURN_NO;
 }
    }
    XSRETURN_EMPTY;
}

XS(XS_utf8_encode)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: utf8::encode(sv)");
    {
	SV *	sv = ST(0);

	sv_utf8_encode(sv);
    }
    XSRETURN_EMPTY;
}

XS(XS_utf8_decode)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: utf8::decode(sv)");
    {
	SV *	sv = ST(0);
	bool	RETVAL;

	RETVAL = sv_utf8_decode(sv);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_utf8_upgrade)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: utf8::upgrade(sv)");
    {
	SV *	sv = ST(0);
	STRLEN	RETVAL;
	dXSTARG;

	RETVAL = sv_utf8_upgrade(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_utf8_downgrade)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: utf8::downgrade(sv, failok=0)");
    {
	SV *	sv = ST(0);
	bool	failok;
	bool	RETVAL;

	if (items < 2)
	    failok = 0;
	else {
	    failok = (int)SvIV(ST(1));
	}

	RETVAL = sv_utf8_downgrade(sv, failok);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_utf8_native_to_unicode)
{
 dXSARGS;
 UV uv = SvUV(ST(0));

 if (items > 1)
     Perl_croak(aTHX_ "Usage: utf8::native_to_unicode(sv)");

 ST(0) = sv_2mortal(newSViv(NATIVE_TO_UNI(uv)));
 XSRETURN(1);
}

XS(XS_utf8_unicode_to_native)
{
 dXSARGS;
 UV uv = SvUV(ST(0));

 if (items > 1)
     Perl_croak(aTHX_ "Usage: utf8::unicode_to_native(sv)");

 ST(0) = sv_2mortal(newSViv(UNI_TO_NATIVE(uv)));
 XSRETURN(1);
}

XS(XS_Internals_SvREADONLY)	/* This is dangerous stuff. */
{
    dXSARGS;
    SV *sv = SvRV(ST(0));
    if (items == 1) {
	 if (SvREADONLY(sv))
	     XSRETURN_YES;
	 else
	     XSRETURN_NO;
    }
    else if (items == 2) {
	if (SvTRUE(ST(1))) {
	    SvREADONLY_on(sv);
	    XSRETURN_YES;
	}
	else {
	    /* I hope you really know what you are doing. */
	    SvREADONLY_off(sv);
	    XSRETURN_NO;
	}
    }
    XSRETURN_UNDEF; /* Can't happen. */
}

XS(XS_Internals_SvREFCNT)	/* This is dangerous stuff. */
{
    dXSARGS;
    SV *sv = SvRV(ST(0));
    if (items == 1)
	 XSRETURN_IV(SvREFCNT(sv) - 1); /* Minus the ref created for us. */
    else if (items == 2) {
         /* I hope you really know what you are doing. */
	 SvREFCNT(sv) = SvIV(ST(1));
	 XSRETURN_IV(SvREFCNT(sv));
    }
    XSRETURN_UNDEF; /* Can't happen. */
}

/* Maybe this should return the number of placeholders found in scalar context,
   and a list of them in list context.  */
XS(XS_Internals_hv_clear_placehold)
{
    dXSARGS;
    HV *hv = (HV *) SvRV(ST(0));

    /* I don't care how many parameters were passed in, but I want to avoid
       the unused variable warning. */

    items = (I32)HvPLACEHOLDERS(hv);

    if (items) {
        HE *entry;
        I32 riter = HvRITER(hv);
        HE *eiter = HvEITER(hv);
        hv_iterinit(hv);
        /* This may look suboptimal with the items *after* the iternext, but
           it's quite deliberate. We only get here with items==0 if we've
           just deleted the last placeholder in the hash. If we've just done
           that then it means that the hash is in lazy delete mode, and the
           HE is now only referenced in our iterator. If we just quit the loop
           and discarded our iterator then the HE leaks. So we do the && the
           other way to ensure iternext is called just one more time, which
           has the side effect of triggering the lazy delete.  */
        while ((entry = hv_iternext_flags(hv, HV_ITERNEXT_WANTPLACEHOLDERS))
            && items) {
            SV *val = hv_iterval(hv, entry);

            if (val == &PL_sv_undef) {

                /* It seems that I have to go back in the front of the hash
                   API to delete a hash, even though I have a HE structure
                   pointing to the very entry I want to delete, and could hold
                   onto the previous HE that points to it. And it's easier to
                   go in with SVs as I can then specify the precomputed hash,
                   and don't have fun and games with utf8 keys.  */
                SV *key = hv_iterkeysv(entry);

                hv_delete_ent (hv, key, G_DISCARD, HeHASH(entry));
                items--;
            }
        }
        HvRITER(hv) = riter;
        HvEITER(hv) = eiter;
    }

    XSRETURN(0);
}
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
 *    by Larry Wall and others
a19 4
#ifdef USE_PERLIO
#include "perliol.h" /* For the PERLIO_F_XXX */
#endif

a42 3
    if (strEQ(name, "UNIVERSAL"))
	return &PL_sv_yes;

d97 2
a98 2
		             "Can't locate package %"SVf" for @@%s::ISA",
			    sv, HvNAME(stash));
d110 2
a111 1
    return &PL_sv_no;
a162 1
XS(XS_utf8_is_utf8);
a172 5
XS(XS_PerlIO_get_layers);
XS(XS_Regexp_DESTROY);
XS(XS_Internals_hash_seed);
XS(XS_Internals_rehash_seed);
XS(XS_Internals_HvREHASH);
a181 1
    newXS("utf8::is_utf8", XS_utf8_is_utf8, file);
a192 6
    newXSproto("PerlIO::get_layers",
               XS_PerlIO_get_layers, file, "*;@@");
    newXS("Regexp::DESTROY", XS_Regexp_DESTROY, file);
    newXSproto("Internals::hash_seed",XS_Internals_hash_seed, file, "");
    newXSproto("Internals::rehash_seed",XS_Internals_rehash_seed, file, "");
    newXSproto("Internals::HvREHASH", XS_Internals_HvREHASH, file, "\\%");
d211 1
a211 2
    if (!SvOK(sv) || !(SvROK(sv) || (SvPOK(sv) && SvCUR(sv))
		|| (SvGMAGICAL(sv) && SvPOKp(sv) && SvCUR(sv))))
d237 1
a237 2
    if (!SvOK(sv) || !(SvROK(sv) || (SvPOK(sv) && SvCUR(sv))
		|| (SvGMAGICAL(sv) && SvPOKp(sv) && SvCUR(sv))))
a356 17
XS(XS_utf8_is_utf8)
{
     dXSARGS;
     if (items != 1)
	  Perl_croak(aTHX_ "Usage: utf8::is_utf8(sv)");
     {
	  SV *	sv = ST(0);
	  {
	       if (SvUTF8(sv))
		    XSRETURN_YES;
	       else
		    XSRETURN_NO;
	  }
     }
     XSRETURN_EMPTY;
}

d359 15
a373 15
     dXSARGS;
     if (items != 1)
	  Perl_croak(aTHX_ "Usage: utf8::valid(sv)");
     {
	  SV *	sv = ST(0);
	  {
	       STRLEN len;
	       char *s = SvPV(sv,len);
	       if (!SvUTF8(sv) || is_utf8_string((U8*)s,len))
		    XSRETURN_YES;
	       else
		    XSRETURN_NO;
	  }
     }
     XSRETURN_EMPTY;
d535 1
a535 1
            if (val == &PL_sv_placeholder) {
a553 161
}

XS(XS_Regexp_DESTROY)
{

}

XS(XS_PerlIO_get_layers)
{
    dXSARGS;
    if (items < 1 || items % 2 == 0)
	Perl_croak(aTHX_ "Usage: PerlIO_get_layers(filehandle[,args])");
#ifdef USE_PERLIO
    {
	SV *	sv;
	GV *	gv;
	IO *	io;
	bool	input = TRUE;
	bool	details = FALSE;

	if (items > 1) {
	     SV **svp;
	     
	     for (svp = MARK + 2; svp <= SP; svp += 2) {
		  SV **varp = svp;
		  SV **valp = svp + 1;
		  STRLEN klen;
		  char *key = SvPV(*varp, klen);

		  switch (*key) {
		  case 'i':
		       if (klen == 5 && memEQ(key, "input", 5)) {
			    input = SvTRUE(*valp);
			    break;
		       }
		       goto fail;
		  case 'o': 
		       if (klen == 6 && memEQ(key, "output", 6)) {
			    input = !SvTRUE(*valp);
			    break;
		       }
		       goto fail;
		  case 'd':
		       if (klen == 7 && memEQ(key, "details", 7)) {
			    details = SvTRUE(*valp);
			    break;
		       }
		       goto fail;
		  default:
		  fail:
		       Perl_croak(aTHX_
				  "get_layers: unknown argument '%s'",
				  key);
		  }
	     }

	     SP -= (items - 1);
	}

	sv = POPs;
	gv = (GV*)sv;

	if (!isGV(sv)) {
	     if (SvROK(sv) && isGV(SvRV(sv)))
		  gv = (GV*)SvRV(sv);
	     else
		  gv = gv_fetchpv(SvPVX(sv), FALSE, SVt_PVIO);
	}

	if (gv && (io = GvIO(gv))) {
	     dTARGET;
	     AV* av = PerlIO_get_layers(aTHX_ input ?
					IoIFP(io) : IoOFP(io));
	     I32 i;
	     I32 last = av_len(av);
	     I32 nitem = 0;
	     
	     for (i = last; i >= 0; i -= 3) {
		  SV **namsvp;
		  SV **argsvp;
		  SV **flgsvp;
		  bool namok, argok, flgok;

		  namsvp = av_fetch(av, i - 2, FALSE);
		  argsvp = av_fetch(av, i - 1, FALSE);
		  flgsvp = av_fetch(av, i,     FALSE);

		  namok = namsvp && *namsvp && SvPOK(*namsvp);
		  argok = argsvp && *argsvp && SvPOK(*argsvp);
		  flgok = flgsvp && *flgsvp && SvIOK(*flgsvp);

		  if (details) {
		       XPUSHs(namok ?
			     newSVpv(SvPVX(*namsvp), 0) : &PL_sv_undef);
		       XPUSHs(argok ?
			     newSVpv(SvPVX(*argsvp), 0) : &PL_sv_undef);
		       if (flgok)
			    XPUSHi(SvIVX(*flgsvp));
		       else
			    XPUSHs(&PL_sv_undef);
		       nitem += 3;
		  }
		  else {
		       if (namok && argok)
			    XPUSHs(Perl_newSVpvf(aTHX_ "%"SVf"(%"SVf")",
					       *namsvp, *argsvp));
		       else if (namok)
			    XPUSHs(Perl_newSVpvf(aTHX_ "%"SVf, *namsvp));
		       else
			    XPUSHs(&PL_sv_undef);
		       nitem++;
		       if (flgok) {
			    IV flags = SvIVX(*flgsvp);

			    if (flags & PERLIO_F_UTF8) {
				 XPUSHs(newSVpvn("utf8", 4));
				 nitem++;
			    }
		       }
		  }
	     }

	     SvREFCNT_dec(av);

	     XSRETURN(nitem);
	}
    }
#endif

    XSRETURN(0);
}

XS(XS_Internals_hash_seed)
{
    /* Using dXSARGS would also have dITEM and dSP,
     * which define 2 unused local variables.  */
    dMARK; dAX;
    XSRETURN_UV(PERL_HASH_SEED);
}

XS(XS_Internals_rehash_seed)
{
    /* Using dXSARGS would also have dITEM and dSP,
     * which define 2 unused local variables.  */
    dMARK; dAX;
    XSRETURN_UV(PL_rehash_seed);
}

XS(XS_Internals_HvREHASH)	/* Subject to change  */
{
    dXSARGS;
    if (SvROK(ST(0))) {
	HV *hv = (HV *) SvRV(ST(0));
	if (items == 1 && SvTYPE(hv) == SVt_PVHV) {
	    if (HvREHASH(hv))
		XSRETURN_YES;
	    else
		XSRETURN_NO;
	}
    }
    Perl_croak(aTHX_ "Internals::HvREHASH $hashref");
@


1.1.1.6
log
@perl 5.8.3 from CPAN
@
text
@d545 2
d551 41
a591 3
    if (items != 1)
	Perl_croak(aTHX_ "Usage: UNIVERSAL::hv_clear_placeholders(hv)");
    hv_clear_placeholders(hv);
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d3 1
a3 1
 *    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@a16 4
/* This file contains the code that implements the functions in Perl's
 * UNIVERSAL package, such as UNIVERSAL->can().
 */

@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2005, 2006, by Larry Wall and others
a42 1
    const char *hvname;
d49 1
a49 3
    hvname = HvNAME_get(stash);

    if (strEQ(hvname, name))
d57 1
a57 1
		   hvname);
d69 1
a69 1
				  name, hvname) );
d75 1
a75 1
			      hvname) );
d109 2
a110 2
				    "Can't locate package %"SVf" for @@%s::ISA",
				    sv, hvname);
d140 2
a141 2
    const char *type = Nullch;
    HV *stash = Nullhv;
d144 3
d171 3
a173 3
PERL_XS_EXPORT_C void XS_UNIVERSAL_isa(pTHX_ CV *cv);
PERL_XS_EXPORT_C void XS_UNIVERSAL_can(pTHX_ CV *cv);
PERL_XS_EXPORT_C void XS_UNIVERSAL_VERSION(pTHX_ CV *cv);
d194 1
a194 1
    const char file[] = __FILE__;
d196 13
a208 13
    newXS("UNIVERSAL::isa",             XS_UNIVERSAL_isa,         (char *)file);
    newXS("UNIVERSAL::can",             XS_UNIVERSAL_can,         (char *)file);
    newXS("UNIVERSAL::VERSION", 	XS_UNIVERSAL_VERSION, 	  (char *)file);
    newXS("utf8::is_utf8", XS_utf8_is_utf8, (char *)file);
    newXS("utf8::valid", XS_utf8_valid, (char *)file);
    newXS("utf8::encode", XS_utf8_encode, (char *)file);
    newXS("utf8::decode", XS_utf8_decode, (char *)file);
    newXS("utf8::upgrade", XS_utf8_upgrade, (char *)file);
    newXS("utf8::downgrade", XS_utf8_downgrade, (char *)file);
    newXS("utf8::native_to_unicode", XS_utf8_native_to_unicode, (char *)file);
    newXS("utf8::unicode_to_native", XS_utf8_unicode_to_native, (char *)file);
    newXSproto("Internals::SvREADONLY",XS_Internals_SvREADONLY, (char *)file, "\\[$%@@];$");
    newXSproto("Internals::SvREFCNT",XS_Internals_SvREFCNT, (char *)file, "\\[$%@@];$");
d210 1
a210 1
               XS_Internals_hv_clear_placehold, (char *)file, "\\%");
d212 5
a216 5
               XS_PerlIO_get_layers, (char *)file, "*;@@");
    newXS("Regexp::DESTROY", XS_Regexp_DESTROY, (char *)file);
    newXSproto("Internals::hash_seed",XS_Internals_hash_seed, (char *)file, "");
    newXSproto("Internals::rehash_seed",XS_Internals_rehash_seed, (char *)file, "");
    newXSproto("Internals::HvREHASH", XS_Internals_HvREHASH, (char *)file, "\\%");
d224 2
a225 1
    const char *name;
d239 1
a239 1
    name = SvPV_nolen_const(ST(1));
d249 1
a249 1
    const char *name;
d252 1
d266 1
a266 1
    name = SvPV_nolen_const(ST(1));
d295 1
a295 1
    const char *undef;
d309 1
a309 1
    if (gvp && isGV(gv = *gvp) && (sv = GvSV(gv)) && SvOK(sv)) {
d321 1
d325 2
a326 3
	    if (pkg) {
		const char *name = HvNAME_get(pkg);
		Perl_croak(aTHX_
d328 6
a333 5
			     name, name);
	    } else {
		Perl_croak(aTHX_
			     "%s defines neither package nor VERSION--version check failed",
			     SvPVx_nolen_const(ST(0)) );
a336 1
	    STRLEN len;
d374 1
a374 1
		       HvNAME_get(pkg), SvPV_nolen(req), SvPV_nolen(sv));
d389 1
a389 1
          const SV *sv = ST(0);
d409 1
a409 1
	       const char *s = SvPV_const(sv,len);
d439 3
a441 1
	const bool RETVAL = sv_utf8_decode(sv);
d471 8
a478 2
        const bool failok = (items < 2) ? 0 : (int)SvIV(ST(1));
        const bool RETVAL = sv_utf8_downgrade(sv, failok);
d480 1
d490 1
a490 1
 const UV uv = SvUV(ST(0));
d502 1
a502 1
 const UV uv = SvUV(ST(0));
a514 1

a538 1

a552 1

d561 1
a561 1
    PERL_UNUSED_ARG(cv);
d584 1
a584 1
                  const char *key = SvPV_const(*varp, klen);
d622 1
a622 1
	     else if (SvPOKp(sv))
d649 4
a652 6
		       XPUSHs(namok
			      ? newSVpvn(SvPVX_const(*namsvp), SvCUR(*namsvp))
			      : &PL_sv_undef);
		       XPUSHs(argok
			      ? newSVpvn(SvPVX_const(*argsvp), SvCUR(*argsvp))
			      : &PL_sv_undef);
d693 1
a693 3
    dAXMARK;
    PERL_UNUSED_ARG(cv);
    PERL_UNUSED_VAR(mark);
d701 1
a701 3
    dAXMARK;
    PERL_UNUSED_ARG(cv);
    PERL_UNUSED_VAR(mark);
d709 1
a709 1
	const HV *hv = (HV *) SvRV(ST(0));
a718 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2005, 2006, 2007 by Larry Wall and others
a18 5
 *
 * It is also used to store XS functions that need to be present in
 * miniperl for a lack of a better place to put them. It might be
 * clever to move them to seperate XS files which would then be pulled
 * in by some to-be-written build process.
d34 9
a42 6
STATIC bool
S_isa_lookup(pTHX_ HV *stash, const char * const name, const HV* const name_stash)
{
    dVAR;
    AV* stash_linear_isa;
    SV** svp;
a43 1
    I32 items;
d47 2
a48 2
    if (name_stash && ((const HV *)stash == name_stash))
        return TRUE;
d53 1
a53 1
	return TRUE;
d56 5
a60 1
	return TRUE;
d62 19
a80 12
    stash_linear_isa = mro_get_linear_isa(stash);
    svp = AvARRAY(stash_linear_isa) + 1;
    items = AvFILLp(stash_linear_isa);
    while (items--) {
	SV* const basename_sv = *svp++;
        HV* const basestash = gv_stashsv(basename_sv, 0);
	if (!basestash) {
	    if (ckWARN(WARN_SYNTAX))
		Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
			    "Can't locate package %"SVf" for the parents of %s",
			    SVfARG(basename_sv), hvname);
	    continue;
a81 2
        if(name_stash == basestash || strEQ(name, SvPVX(basename_sv)))
	    return TRUE;
d84 42
a125 1
    return FALSE;
d133 3
a135 3
Returns a boolean indicating whether the SV is derived from the specified class
I<at the C level>.  To check derivation at the Perl level, call C<isa()> as a
normal Perl method.
d143 3
a145 2
    dVAR;
    HV *stash;
d147 2
a148 1
    SvGETMAGIC(sv);
a150 1
	const char *type;
d153 2
a154 3
	if (type && strEQ(type,name))
	    return TRUE;
	stash = SvOBJECT(sv) ? SvSTASH(sv) : NULL;
d157 1
a157 1
        stash = gv_stashsv(sv, 0);
d160 1
a160 6
    if (stash) {
	HV * const name_stash = gv_stashpv(name, 0);
	return isa_lookup(stash, name, name_stash);
    }
    else
	return FALSE;
d162 5
a168 9
/*
=for apidoc sv_does

Returns a boolean indicating whether the SV performs a specific, named role.
The SV can be a Perl object or the name of a Perl class.

=cut
*/

a170 46
bool
Perl_sv_does(pTHX_ SV *sv, const char *name)
{
    const char *classname;
    bool does_it;
    SV *methodname;

    dSP;
    ENTER;
    SAVETMPS;

    SvGETMAGIC(sv);

    if (!SvOK(sv) || !(SvROK(sv) || (SvPOK(sv) && SvCUR(sv))
		|| (SvGMAGICAL(sv) && SvPOKp(sv) && SvCUR(sv))))
	return FALSE;

    if (sv_isobject(sv)) {
	classname = sv_reftype(SvRV(sv),TRUE);
    } else {
	classname = SvPV_nolen(sv);
    }

    if (strEQ(name,classname))
	return TRUE;

    PUSHMARK(SP);
    XPUSHs(sv);
    XPUSHs(sv_2mortal(newSVpv(name, 0)));
    PUTBACK;

    methodname = sv_2mortal(newSVpvs("isa"));
    /* ugly hack: use the SvSCREAM flag so S_method_common
     * can figure out we're calling DOES() and not isa(),
     * and report eventual errors correctly. --rgs */
    SvSCREAM_on(methodname);
    call_sv(methodname, G_SCALAR | G_METHOD);
    SPAGAIN;

    does_it = SvTRUE( TOPs );
    FREETMPS;
    LEAVE;

    return does_it;
}

a172 1
PERL_XS_EXPORT_C void XS_UNIVERSAL_DOES(pTHX_ CV *cv);
a173 13
XS(XS_version_new);
XS(XS_version_stringify);
XS(XS_version_numify);
XS(XS_version_normal);
XS(XS_version_vcmp);
XS(XS_version_boolean);
#ifdef HASATTRIBUTE_NORETURN
XS(XS_version_noop) __attribute__noreturn__;
#else
XS(XS_version_noop);
#endif
XS(XS_version_is_alpha);
XS(XS_version_qv);
a189 14
XS(XS_Internals_inc_sub_generation);
XS(XS_re_is_regexp); 
XS(XS_re_regname);
XS(XS_re_regnames);
XS(XS_re_regnames_count);
XS(XS_Tie_Hash_NamedCapture_FETCH);
XS(XS_Tie_Hash_NamedCapture_STORE);
XS(XS_Tie_Hash_NamedCapture_DELETE);
XS(XS_Tie_Hash_NamedCapture_CLEAR);
XS(XS_Tie_Hash_NamedCapture_EXISTS);
XS(XS_Tie_Hash_NamedCapture_FIRSTK);
XS(XS_Tie_Hash_NamedCapture_NEXTK);
XS(XS_Tie_Hash_NamedCapture_SCALAR);
XS(XS_Tie_Hash_NamedCapture_flags);
d194 1
a194 2
    dVAR;
    static const char file[] = __FILE__;
d196 13
a208 35
    newXS("UNIVERSAL::isa",             XS_UNIVERSAL_isa,         file);
    newXS("UNIVERSAL::can",             XS_UNIVERSAL_can,         file);
    newXS("UNIVERSAL::DOES",            XS_UNIVERSAL_DOES,        file);
    newXS("UNIVERSAL::VERSION", 	XS_UNIVERSAL_VERSION, 	  file);
    {
	/* register the overloading (type 'A') magic */
	PL_amagic_generation++;
	/* Make it findable via fetchmethod */
	newXS("version::()", XS_version_noop, file);
	newXS("version::new", XS_version_new, file);
	newXS("version::(\"\"", XS_version_stringify, file);
	newXS("version::stringify", XS_version_stringify, file);
	newXS("version::(0+", XS_version_numify, file);
	newXS("version::numify", XS_version_numify, file);
	newXS("version::normal", XS_version_normal, file);
	newXS("version::(cmp", XS_version_vcmp, file);
	newXS("version::(<=>", XS_version_vcmp, file);
	newXS("version::vcmp", XS_version_vcmp, file);
	newXS("version::(bool", XS_version_boolean, file);
	newXS("version::boolean", XS_version_boolean, file);
	newXS("version::(nomethod", XS_version_noop, file);
	newXS("version::noop", XS_version_noop, file);
	newXS("version::is_alpha", XS_version_is_alpha, file);
	newXS("version::qv", XS_version_qv, file);
    }
    newXS("utf8::is_utf8", XS_utf8_is_utf8, file);
    newXS("utf8::valid", XS_utf8_valid, file);
    newXS("utf8::encode", XS_utf8_encode, file);
    newXS("utf8::decode", XS_utf8_decode, file);
    newXS("utf8::upgrade", XS_utf8_upgrade, file);
    newXS("utf8::downgrade", XS_utf8_downgrade, file);
    newXS("utf8::native_to_unicode", XS_utf8_native_to_unicode, file);
    newXS("utf8::unicode_to_native", XS_utf8_unicode_to_native, file);
    newXSproto("Internals::SvREADONLY",XS_Internals_SvREADONLY, file, "\\[$%@@];$");
    newXSproto("Internals::SvREFCNT",XS_Internals_SvREFCNT, file, "\\[$%@@];$");
d210 1
a210 1
               XS_Internals_hv_clear_placehold, file, "\\%");
d212 5
a216 18
               XS_PerlIO_get_layers, file, "*;@@");
    newXS("Regexp::DESTROY", XS_Regexp_DESTROY, file);
    newXSproto("Internals::hash_seed",XS_Internals_hash_seed, file, "");
    newXSproto("Internals::rehash_seed",XS_Internals_rehash_seed, file, "");
    newXSproto("Internals::HvREHASH", XS_Internals_HvREHASH, file, "\\%");
    newXSproto("re::is_regexp", XS_re_is_regexp, file, "$");
    newXSproto("re::regname", XS_re_regname, file, ";$$");
    newXSproto("re::regnames", XS_re_regnames, file, ";$");
    newXSproto("re::regnames_count", XS_re_regnames_count, file, "");
    newXS("Tie::Hash::NamedCapture::FETCH", XS_Tie_Hash_NamedCapture_FETCH, file);
    newXS("Tie::Hash::NamedCapture::STORE", XS_Tie_Hash_NamedCapture_STORE, file);
    newXS("Tie::Hash::NamedCapture::DELETE", XS_Tie_Hash_NamedCapture_DELETE, file);
    newXS("Tie::Hash::NamedCapture::CLEAR", XS_Tie_Hash_NamedCapture_CLEAR, file);
    newXS("Tie::Hash::NamedCapture::EXISTS", XS_Tie_Hash_NamedCapture_EXISTS, file);
    newXS("Tie::Hash::NamedCapture::FIRSTKEY", XS_Tie_Hash_NamedCapture_FIRSTK, file);
    newXS("Tie::Hash::NamedCapture::NEXTKEY", XS_Tie_Hash_NamedCapture_NEXTK, file);
    newXS("Tie::Hash::NamedCapture::SCALAR", XS_Tie_Hash_NamedCapture_SCALAR, file);
    newXS("Tie::Hash::NamedCapture::flags", XS_Tie_Hash_NamedCapture_flags, file);
a221 1
    dVAR;
d223 2
a224 1
    PERL_UNUSED_ARG(cv);
a227 3
    else {
	SV * const sv = ST(0);
	const char *name;
d229 4
a232 1
	SvGETMAGIC(sv);
d234 3
a236 3
	if (!SvOK(sv) || !(SvROK(sv) || (SvPOK(sv) && SvCUR(sv))
		    || (SvGMAGICAL(sv) && SvPOKp(sv) && SvCUR(sv))))
	    XSRETURN_UNDEF;
d238 1
a238 1
	name = SvPV_nolen_const(ST(1));
d240 2
a241 3
	ST(0) = boolSV(sv_derived_from(sv, name));
	XSRETURN(1);
    }
a245 1
    dVAR;
a250 1
    PERL_UNUSED_ARG(cv);
d257 2
a258 1
    SvGETMAGIC(sv);
d273 1
a273 1
        pkg = gv_stashsv(sv, 0);
d277 1
a277 1
	GV * const gv = gv_fetchmethod_autoload(pkg, name, FALSE);
a285 20
XS(XS_UNIVERSAL_DOES)
{
    dVAR;
    dXSARGS;
    PERL_UNUSED_ARG(cv);

    if (items != 2)
	Perl_croak(aTHX_ "Usage: invocant->DOES(kind)");
    else {
	SV * const sv = ST(0);
	const char *name;

	name = SvPV_nolen_const(ST(1));
	if (sv_does( sv, name ))
	    XSRETURN_YES;

	XSRETURN_NO;
    }
}

a287 1
    dVAR;
a293 1
    PERL_UNUSED_ARG(cv);
d302 1
a302 1
        pkg = gv_stashsv(ST(0), 0);
d305 1
a305 1
    gvp = pkg ? (GV**)hv_fetchs(pkg, "VERSION", FALSE) : NULL;
d308 1
a308 1
        SV * const nsv = sv_newmortal();
d311 1
a311 3
	if ( !sv_derived_from(sv, "version"))
	    upg_version(sv, FALSE);
        undef = NULL;
d323 1
a323 1
		const char * const name = HvNAME_get(pkg);
d325 2
a326 2
			   "%s does not define $%s::VERSION--version check failed",
			   name, name);
d333 26
a358 17

	if ( !sv_derived_from(req, "version")) {
	    /* req may very well be R/O, so create a new object */
	    req = sv_2mortal( new_version(req) );
	}

	if ( vcmp( req, sv ) > 0 ) {
	    if ( hv_exists((HV*)SvRV(req), "qv", 2 ) ) {
		Perl_croak(aTHX_ "%s version %"SVf" required--"
		       "this is only version %"SVf"", HvNAME_get(pkg),
		       SVfARG(vnormal(req)),
		       SVfARG(vnormal(sv)));
	    } else {
		Perl_croak(aTHX_ "%s version %"SVf" required--"
		       "this is only version %"SVf"", HvNAME_get(pkg),
		       SVfARG(vstringify(req)),
		       SVfARG(vstringify(sv)));
d361 12
a372 1

d375 2
a376 5
    if ( SvOK(sv) && sv_derived_from(sv, "version") ) {
	ST(0) = vstringify(sv);
    } else {
	ST(0) = sv;
    }
d381 1
a381 37
XS(XS_version_new)
{
    dVAR;
    dXSARGS;
    PERL_UNUSED_ARG(cv);
    if (items > 3)
	Perl_croak(aTHX_ "Usage: version::new(class, version)");
    SP -= items;
    {
        SV *vs = ST(1);
	SV *rv;
	const char * const classname =
	    sv_isobject(ST(0)) /* get the class if called as an object method */
		? HvNAME(SvSTASH(SvRV(ST(0))))
		: (char *)SvPV_nolen(ST(0));

	if ( items == 1 || vs == &PL_sv_undef ) { /* no param or explicit undef */
	    /* create empty object */
	    vs = sv_newmortal();
	    sv_setpvn(vs,"",0);
	}
	else if ( items == 3 ) {
	    vs = sv_newmortal();
	    Perl_sv_setpvf(aTHX_ vs,"v%s",SvPV_nolen_const(ST(2)));
	}

	rv = new_version(vs);
	if ( strcmp(classname,"version") != 0 ) /* inherited new() */
	    sv_bless(rv, gv_stashpv(classname, GV_ADD));

	PUSHs(sv_2mortal(rv));
	PUTBACK;
	return;
    }
}

XS(XS_version_stringify)
a382 1
     dVAR;
d384 2
a385 28
     PERL_UNUSED_ARG(cv);
     if (items < 1)
	  Perl_croak(aTHX_ "Usage: version::stringify(lobj, ...)");
     SP -= items;
     {
	  SV *	lobj;

	  if (sv_derived_from(ST(0), "version")) {
	       lobj = SvRV(ST(0));
	  }
	  else
	       Perl_croak(aTHX_ "lobj is not of type version");

	  PUSHs(sv_2mortal(vstringify(lobj)));

	  PUTBACK;
	  return;
     }
}

XS(XS_version_numify)
{
     dVAR;
     dXSARGS;
     PERL_UNUSED_ARG(cv);
     if (items < 1)
	  Perl_croak(aTHX_ "Usage: version::numify(lobj, ...)");
     SP -= items;
d387 1
a387 56
	  SV *	lobj;

	  if (sv_derived_from(ST(0), "version")) {
	       lobj = SvRV(ST(0));
	  }
	  else
	       Perl_croak(aTHX_ "lobj is not of type version");

	  PUSHs(sv_2mortal(vnumify(lobj)));

	  PUTBACK;
	  return;
     }
}

XS(XS_version_normal)
{
     dVAR;
     dXSARGS;
     PERL_UNUSED_ARG(cv);
     if (items < 1)
	  Perl_croak(aTHX_ "Usage: version::normal(lobj, ...)");
     SP -= items;
     {
	  SV *	lobj;

	  if (sv_derived_from(ST(0), "version")) {
	       lobj = SvRV(ST(0));
	  }
	  else
	       Perl_croak(aTHX_ "lobj is not of type version");

	  PUSHs(sv_2mortal(vnormal(lobj)));

	  PUTBACK;
	  return;
     }
}

XS(XS_version_vcmp)
{
     dVAR;
     dXSARGS;
     PERL_UNUSED_ARG(cv);
     if (items < 1)
	  Perl_croak(aTHX_ "Usage: version::vcmp(lobj, ...)");
     SP -= items;
     {
	  SV *	lobj;

	  if (sv_derived_from(ST(0), "version")) {
	       lobj = SvRV(ST(0));
	  }
	  else
	       Perl_croak(aTHX_ "lobj is not of type version");

d389 2
a390 15
	       SV	*rs;
	       SV	*rvs;
	       SV * robj = ST(1);
	       const IV	 swap = (IV)SvIV(ST(2));

	       if ( ! sv_derived_from(robj, "version") )
	       {
		    robj = new_version(robj);
	       }
	       rvs = SvRV(robj);

	       if ( swap )
	       {
		    rs = newSViv(vcmp(rvs,lobj));
	       }
d392 1
a392 5
	       {
		    rs = newSViv(vcmp(lobj,rvs));
	       }

	       PUSHs(sv_2mortal(rs));
a393 101

	  PUTBACK;
	  return;
     }
}

XS(XS_version_boolean)
{
    dVAR;
    dXSARGS;
    PERL_UNUSED_ARG(cv);
    if (items < 1)
	Perl_croak(aTHX_ "Usage: version::boolean(lobj, ...)");
    SP -= items;
    if (sv_derived_from(ST(0), "version")) {
	SV * const lobj = SvRV(ST(0));
	SV * const rs = newSViv( vcmp(lobj,new_version(newSVpvs("0"))) );
	PUSHs(sv_2mortal(rs));
	PUTBACK;
	return;
    }
    else
	Perl_croak(aTHX_ "lobj is not of type version");
}

XS(XS_version_noop)
{
    dVAR;
    dXSARGS;
    PERL_UNUSED_ARG(cv);
    if (items < 1)
	Perl_croak(aTHX_ "Usage: version::noop(lobj, ...)");
    if (sv_derived_from(ST(0), "version"))
	Perl_croak(aTHX_ "operation not supported with version object");
    else
	Perl_croak(aTHX_ "lobj is not of type version");
#ifndef HASATTRIBUTE_NORETURN
    XSRETURN_EMPTY;
#endif
}

XS(XS_version_is_alpha)
{
    dVAR;
    dXSARGS;
    PERL_UNUSED_ARG(cv);
    if (items != 1)
	Perl_croak(aTHX_ "Usage: version::is_alpha(lobj)");
    SP -= items;
    if (sv_derived_from(ST(0), "version")) {
	SV * const lobj = ST(0);
	if ( hv_exists((HV*)SvRV(lobj), "alpha", 5 ) )
	    XSRETURN_YES;
	else
	    XSRETURN_NO;
	PUTBACK;
	return;
    }
    else
	Perl_croak(aTHX_ "lobj is not of type version");
}

XS(XS_version_qv)
{
    dVAR;
    dXSARGS;
    PERL_UNUSED_ARG(cv);
    if (items != 1)
	Perl_croak(aTHX_ "Usage: version::qv(ver)");
    SP -= items;
    {
	SV *	ver = ST(0);
	if ( !SvVOK(ver) ) { /* only need to do with if not already v-string */
	    SV * const rv = sv_newmortal();
	    sv_setsv(rv,ver); /* make a duplicate */
	    upg_version(rv, TRUE);
	    PUSHs(rv);
	}
	else
	{
	    PUSHs(sv_2mortal(new_version(ver)));
	}

	PUTBACK;
	return;
    }
}

XS(XS_utf8_is_utf8)
{
     dVAR;
     dXSARGS;
     PERL_UNUSED_ARG(cv);
     if (items != 1)
	  Perl_croak(aTHX_ "Usage: utf8::is_utf8(sv)");
     else {
	const SV * const sv = ST(0);
	    if (SvUTF8(sv))
		XSRETURN_YES;
	    else
		XSRETURN_NO;
a399 1
     dVAR;
a400 1
     PERL_UNUSED_ARG(cv);
d403 11
a413 9
    else {
	SV * const sv = ST(0);
	STRLEN len;
	const char * const s = SvPV_const(sv,len);
	if (!SvUTF8(sv) || is_utf8_string((const U8*)s,len))
	    XSRETURN_YES;
	else
	    XSRETURN_NO;
    }
a418 1
    dVAR;
a419 1
    PERL_UNUSED_ARG(cv);
d422 5
a426 1
    sv_utf8_encode(ST(0));
a431 1
    dVAR;
a432 1
    PERL_UNUSED_ARG(cv);
d435 2
a436 2
    else {
	SV * const sv = ST(0);
a445 1
    dVAR;
a446 1
    PERL_UNUSED_ARG(cv);
d449 2
a450 2
    else {
	SV * const sv = ST(0);
a461 1
    dVAR;
a462 1
    PERL_UNUSED_ARG(cv);
d465 2
a466 2
    else {
	SV * const sv = ST(0);
a477 1
 dVAR;
a479 1
 PERL_UNUSED_ARG(cv);
a489 1
 dVAR;
a491 1
 PERL_UNUSED_ARG(cv);
a501 1
    dVAR;
d503 1
a503 2
    SV * const sv = SvRV(ST(0));
    PERL_UNUSED_ARG(cv);
a526 1
    dVAR;
d528 1
a528 2
    SV * const sv = SvRV(ST(0));
    PERL_UNUSED_ARG(cv);
a541 1
    dVAR;
d543 1
a543 1
    PERL_UNUSED_ARG(cv);
d547 2
a548 5
    else {
	HV * const hv = (HV *) SvRV(ST(0));
	hv_clear_placeholders(hv);
	XSRETURN(0);
    }
a552 1
    PERL_UNUSED_CONTEXT;
a557 1
    dVAR;
a558 1
    PERL_UNUSED_ARG(cv);
d570 2
a571 1
	     SV * const *svp;
d573 2
a574 2
		  SV * const * const varp = svp;
		  SV * const * const valp = svp + 1;
d576 1
a576 1
		  const char * const key = SvPV_const(*varp, klen);
d615 1
a615 1
		  gv = gv_fetchsv(sv, 0, SVt_PVIO);
d620 1
a620 1
	     AV* const av = PerlIO_get_layers(aTHX_ input ?
d623 1
a623 1
	     const I32 last = av_len(av);
d627 12
a638 7
		  SV * const * const namsvp = av_fetch(av, i - 2, FALSE);
		  SV * const * const argsvp = av_fetch(av, i - 1, FALSE);
		  SV * const * const flgsvp = av_fetch(av, i,     FALSE);

		  const bool namok = namsvp && *namsvp && SvPOK(*namsvp);
		  const bool argok = argsvp && *argsvp && SvPOK(*argsvp);
		  const bool flgok = flgsvp && *flgsvp && SvIOK(*flgsvp);
d656 1
a656 2
						 SVfARG(*namsvp),
						 SVfARG(*argsvp)));
d658 1
a658 2
			    XPUSHs(Perl_newSVpvf(aTHX_ "%"SVf,
						 SVfARG(*namsvp)));
d663 1
a663 1
			    const IV flags = SvIVX(*flgsvp);
d666 1
a666 1
				 XPUSHs(newSVpvs("utf8"));
a684 1
    dVAR;
a694 1
    dVAR;
a704 1
    dVAR;
a705 1
    PERL_UNUSED_ARG(cv);
d707 1
a707 1
	const HV * const hv = (HV *) SvRV(ST(0));
a716 383

XS(XS_re_is_regexp)
{
    dVAR; 
    dXSARGS;
    PERL_UNUSED_VAR(cv);

    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "re::is_regexp", "sv");

    SP -= items;

    if (SvRXOK(ST(0))) {
        XSRETURN_YES;
    } else {
        XSRETURN_NO;
    }
}

XS(XS_re_regnames_count)
{
    REGEXP *rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;
    SV * ret;
    dVAR; 
    dXSARGS;
    PERL_UNUSED_ARG(cv);

    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "re::regnames_count", "");

    SP -= items;

    if (!rx)
        XSRETURN_UNDEF;

    ret = CALLREG_NAMED_BUFF_COUNT(rx);

    SPAGAIN;

    if (ret) {
        XPUSHs(ret);
        PUTBACK;
        return;
    } else {
        XSRETURN_UNDEF;
    }
}

XS(XS_re_regname)
{
    dVAR;
    dXSARGS;
    REGEXP * rx;
    U32 flags;
    SV * ret;
    PERL_UNUSED_ARG(cv);

    if (items < 1 || items > 2)
        Perl_croak(aTHX_ "Usage: %s(%s)", "re::regname", "name[, all ]");

    SP -= items;

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx)
        XSRETURN_UNDEF;

    if (items == 2 && SvTRUE(ST(1))) {
        flags = RXapif_ALL;
    } else {
        flags = RXapif_ONE;
    }
    ret = CALLREG_NAMED_BUFF_FETCH(rx, ST(0), (flags | RXapif_REGNAME));

    if (ret) {
        if (SvROK(ret))
            XPUSHs(ret);
        else
            XPUSHs(SvREFCNT_inc(ret));
        XSRETURN(1);
    }
    XSRETURN_UNDEF;    
}


XS(XS_re_regnames)
{
    dVAR;
    dXSARGS;
    REGEXP * rx;
    U32 flags;
    SV *ret;
    AV *av;
    I32 length;
    I32 i;
    SV **entry;
    PERL_UNUSED_ARG(cv);

    if (items > 1)
        Perl_croak(aTHX_ "Usage: %s(%s)", "re::regnames", "[all]");

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx)
        XSRETURN_UNDEF;

    if (items == 1 && SvTRUE(ST(0))) {
        flags = RXapif_ALL;
    } else {
        flags = RXapif_ONE;
    }

    SP -= items;

    ret = CALLREG_NAMED_BUFF_ALL(rx, (flags | RXapif_REGNAMES));

    SPAGAIN;

    SP -= items;

    if (!ret)
        XSRETURN_UNDEF;

    av = (AV*)SvRV(ret);
    length = av_len(av);

    for (i = 0; i <= length; i++) {
        entry = av_fetch(av, i, FALSE);
        
        if (!entry)
            Perl_croak(aTHX_ "NULL array element in re::regnames()");

        XPUSHs(*entry);
    }
    PUTBACK;
    return;
}

XS(XS_Tie_Hash_NamedCapture_FETCH)
{
    dVAR;
    dXSARGS;
    REGEXP * rx;
    U32 flags;
    SV * ret;
    PERL_UNUSED_ARG(cv);

    if (items != 2)
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::STORE($key, $flags)");

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx)
        XSRETURN_UNDEF;

    SP -= items;

    flags = (U32)INT2PTR(IV,SvIV(SvRV((SV*)ST(0))));
    ret = CALLREG_NAMED_BUFF_FETCH(rx, ST(1), flags);

    SPAGAIN;

    if (ret) {
        if (SvROK(ret))
            XPUSHs(ret);
        else
            XPUSHs(SvREFCNT_inc(ret));
        PUTBACK;
        return;
    }
    XSRETURN_UNDEF;
}

XS(XS_Tie_Hash_NamedCapture_STORE)
{
    dVAR;
    dXSARGS;
    REGEXP * rx;
    U32 flags;
    PERL_UNUSED_ARG(cv);

    if (items != 3)
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::STORE($key, $value, $flags)");

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx) {
        if (!PL_localizing)
            Perl_croak(aTHX_ PL_no_modify);
        else
            XSRETURN_UNDEF;
    }

    SP -= items;

    flags = (U32)INT2PTR(IV,SvIV(SvRV((SV*)ST(0))));
    CALLREG_NAMED_BUFF_STORE(rx,ST(1), ST(2), flags);
}

XS(XS_Tie_Hash_NamedCapture_DELETE)
{
    dVAR;
    dXSARGS;
    REGEXP * rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;
    U32 flags;
    PERL_UNUSED_ARG(cv);

    if (items != 2)
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::DELETE($key, $flags)");

    if (!rx)
        Perl_croak(aTHX_ PL_no_modify);

    SP -= items;

    flags = (U32)INT2PTR(IV,SvIV(SvRV((SV*)ST(0))));
    CALLREG_NAMED_BUFF_DELETE(rx, ST(1), flags);
}

XS(XS_Tie_Hash_NamedCapture_CLEAR)
{
    dVAR;
    dXSARGS;
    REGEXP * rx;
    U32 flags;
    PERL_UNUSED_ARG(cv);

    if (items != 1)
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::CLEAR($flags)");

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx)
        Perl_croak(aTHX_ PL_no_modify);

    SP -= items;

    flags = (U32)INT2PTR(IV,SvIV(SvRV((SV*)ST(0))));
    CALLREG_NAMED_BUFF_CLEAR(rx, flags);
}

XS(XS_Tie_Hash_NamedCapture_EXISTS)
{
    dVAR;
    dXSARGS;
    REGEXP * rx;
    U32 flags;
    SV * ret;
    PERL_UNUSED_ARG(cv);

    if (items != 2)
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::EXISTS($key, $flags)");

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx)
        XSRETURN_UNDEF;

    SP -= items;

    flags = (U32)INT2PTR(IV,SvIV(SvRV((SV*)ST(0))));
    ret = CALLREG_NAMED_BUFF_EXISTS(rx, ST(1), flags);

    SPAGAIN;

	XPUSHs(ret);
	PUTBACK;
	return;
}

XS(XS_Tie_Hash_NamedCapture_FIRSTK)
{
    dVAR;
    dXSARGS;
    REGEXP * rx;
    U32 flags;
    SV * ret;
    PERL_UNUSED_ARG(cv);

    if (items != 1)
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::FIRSTKEY()");

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx)
        XSRETURN_UNDEF;

    SP -= items;

    flags = (U32)INT2PTR(IV,SvIV(SvRV((SV*)ST(0))));
    ret = CALLREG_NAMED_BUFF_FIRSTKEY(rx, flags);

    SPAGAIN;

    if (ret) {
        XPUSHs(SvREFCNT_inc(ret));
        PUTBACK;
    } else {
        XSRETURN_UNDEF;
    }

}

XS(XS_Tie_Hash_NamedCapture_NEXTK)
{
    dVAR;
    dXSARGS;
    REGEXP * rx;
    U32 flags;
    SV * ret;
    PERL_UNUSED_ARG(cv);

    if (items != 2)
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::NEXTKEY($lastkey)");

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx)
        XSRETURN_UNDEF;

    SP -= items;

    flags = (U32)INT2PTR(IV,SvIV(SvRV((SV*)ST(0))));
    ret = CALLREG_NAMED_BUFF_NEXTKEY(rx, ST(1), flags);

    SPAGAIN;

    if (ret) {
        XPUSHs(ret);
    } else {
        XSRETURN_UNDEF;
    }  
    PUTBACK;
}

XS(XS_Tie_Hash_NamedCapture_SCALAR)
{
    dVAR;
    dXSARGS;
    REGEXP * rx;
    U32 flags;
    SV * ret;
    PERL_UNUSED_ARG(cv);

    if (items != 1)
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::SCALAR()");

    rx = PL_curpm ? PM_GETRE(PL_curpm) : NULL;

    if (!rx)
        XSRETURN_UNDEF;

    SP -= items;

    flags = (U32)INT2PTR(IV,SvIV(SvRV((SV*)ST(0))));
    ret = CALLREG_NAMED_BUFF_SCALAR(rx, flags);

    SPAGAIN;

    if (ret) {
        XPUSHs(ret);
        PUTBACK;
        return;
    } else {
        XSRETURN_UNDEF;
    }
}

XS(XS_Tie_Hash_NamedCapture_flags)
{
    dVAR;
    dXSARGS;
    PERL_UNUSED_ARG(cv);

    if (items != 0)
        Perl_croak(aTHX_ "Usage: Tie::Hash::NamedCapture::flags()");

	XPUSHs(sv_2mortal(newSVuv(RXapif_ONE)));
	XPUSHs(sv_2mortal(newSVuv(RXapif_ALL)));
	PUTBACK;
	return;
}

@


1.1.1.11
log
@import perl 5.10.1
@
text
@d4 1
a4 1
 *    2005, 2006, 2007, 2008 by Larry Wall and others
d12 3
a14 5
 * '"The roots of those mountains must be roots indeed; there must be
 *   great secrets buried there which have not been discovered since the
 *   beginning."'                   --Gandalf, relating Gollum's history
 *
 *     [p.54 of _The Lord of the Rings_, I/ii: "The Shadow of the Past"]
a33 35
static HV *
S_get_isa_hash(pTHX_ HV *const stash)
{
    dVAR;
    struct mro_meta *const meta = HvMROMETA(stash);

    PERL_ARGS_ASSERT_GET_ISA_HASH;

    if (!meta->isa) {
	AV *const isa = mro_get_linear_isa(stash);
	if (!meta->isa) {
	    HV *const isa_hash = newHV();
	    /* Linearisation didn't build it for us, so do it here.  */
	    SV *const *svp = AvARRAY(isa);
	    SV *const *const svp_end = svp + AvFILLp(isa) + 1;
	    const HEK *const canon_name = HvNAME_HEK(stash);

	    while (svp < svp_end) {
		(void) hv_store_ent(isa_hash, *svp++, &PL_sv_undef, 0);
	    }

	    (void) hv_common(isa_hash, NULL, HEK_KEY(canon_name),
			     HEK_LEN(canon_name), HEK_FLAGS(canon_name),
			     HV_FETCH_ISSTORE, &PL_sv_undef,
			     HEK_HASH(canon_name));
	    (void) hv_store(isa_hash, "UNIVERSAL", 9, &PL_sv_undef, 0);

	    SvREADONLY_on(isa_hash);

	    meta->isa = isa_hash;
	}
    }
    return meta->isa;
}

d40 1
a40 1
S_isa_lookup(pTHX_ HV *stash, const char * const name)
d43 4
a46 4
    const struct mro_meta *const meta = HvMROMETA(stash);
    HV *const isa = meta->isa ? meta->isa : S_get_isa_hash(aTHX_ stash);
    STRLEN len = strlen(name);
    const HV *our_stash;
d48 4
a51 1
    PERL_ARGS_ASSERT_ISA_LOOKUP;
d53 3
a55 4
    if (hv_common(isa, NULL, name, len, 0 /* No "UTF-8" flag possible with only
					     a char * argument*/,
		  HV_FETCH_ISEXISTS, NULL, 0)) {
	/* Direct name lookup worked.  */
a56 1
    }
d58 2
a59 3
    /* A stash/class can go by many names (ie. User == main::User), so 
       we use the name in the stash itself, which is canonical.  */
    our_stash = gv_stashpvn(name, len, 0);
d61 14
a74 6
    if (our_stash) {
	HEK *const canon_name = HvNAME_HEK(our_stash);

	if (hv_common(isa, NULL, HEK_KEY(canon_name), HEK_LEN(canon_name),
		      HEK_FLAGS(canon_name),
		      HV_FETCH_ISEXISTS, NULL, HEK_HASH(canon_name))) {
a75 1
	}
a98 2
    PERL_ARGS_ASSERT_SV_DERIVED_FROM;

d113 7
a119 1
    return stash ? isa_lookup(stash, name) : FALSE;
d139 1
a140 3

    PERL_ARGS_ASSERT_SV_DOES;

d161 1
a161 1
    mXPUSHs(newSVpv(name, 0));
d164 1
a164 1
    methodname = newSVpvs_flags("isa", SVs_TEMP);
a195 1
XS(XS_version_is_qv);
d212 1
a216 1
XS(XS_re_regexp_pattern);
a242 1
	newXS("version::parse", XS_version_new, file);
a256 2
	newXS("version::declare", XS_version_qv, file);
	newXS("version::is_qv", XS_version_is_qv, file);
a279 1
    newXSproto("re::regexp_pattern", XS_re_regexp_pattern, file, "$");
a290 36
/*
=for apidoc croak_xs_usage

A specialised variant of C<croak()> for emitting the usage message for xsubs

    croak_xs_usage(cv, "eee_yow");

works out the package name and subroutine name from C<cv>, and then calls
C<croak()>. Hence if C<cv> is C<&ouch::awk>, it would call C<croak> as:

    Perl_croak(aTHX_ "Usage %s::%s(%s)", "ouch" "awk", "eee_yow");

=cut
*/

void
Perl_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
	const char *const gvname = GvNAME(gv);
	const HV *const stash = GvSTASH(gv);
	const char *const hvname = stash ? HvNAME_get(stash) : NULL;

	if (hvname)
	    Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
	else
	    Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
	/* Pants. I don't think that it should be possible to get here. */
	Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
d296 1
d299 1
a299 1
	croak_xs_usage(cv, "reference, kind");
d325 1
d328 1
a328 1
	croak_xs_usage(cv, "object-ref, method");
d342 1
a342 1
        sv = MUTABLE_SV(SvRV(sv));
d353 1
a353 1
	    rv = sv_2mortal(newRV(MUTABLE_SV(GvCV(gv))));
d392 1
a392 1
        sv = MUTABLE_SV(SvRV(ST(0)));
d412 1
a412 1
        sv = &PL_sv_undef;
d438 1
a438 1
	    if ( hv_exists(MUTABLE_HV(SvRV(req)), "qv", 2 ) ) {
d466 1
d468 1
a468 1
	croak_xs_usage(cv, "class, version");
d481 1
a481 1
	    sv_setpvs(vs,"");
d492 1
a492 1
	mPUSHs(rv);
d502 1
d504 1
a504 1
	 croak_xs_usage(cv, "lobj, ...");
d515 1
a515 1
	  mPUSHs(vstringify(lobj));
d526 1
d528 1
a528 1
	 croak_xs_usage(cv, "lobj, ...");
d539 1
a539 1
	  mPUSHs(vnumify(lobj));
d550 1
d552 1
a552 1
	 croak_xs_usage(cv, "lobj, ...");
d563 1
a563 1
	  mPUSHs(vnormal(lobj));
d574 1
d576 1
a576 1
	 croak_xs_usage(cv, "lobj, ...");
d608 1
a608 1
	       mPUSHs(rs);
d620 1
d622 1
a622 1
	croak_xs_usage(cv, "lobj, ...");
d627 1
a627 1
	mPUSHs(rs);
d639 1
d641 1
a641 1
	croak_xs_usage(cv, "lobj, ...");
d655 1
d657 1
a657 1
	croak_xs_usage(cv, "lobj");
d661 1
a661 1
	if ( hv_exists(MUTABLE_HV(SvRV(lobj)), "alpha", 5 ) )
d677 2
d681 3
a683 13
	SV * ver = ST(0);
	SV * rv;
	const char * classname = "";
	if ( items == 2 && (ST(1)) != &PL_sv_undef ) {
	    /* getting called as object or class method */
	    ver = ST(1);
	    classname = 
		sv_isobject(ST(0)) /* class called as an object method */
		    ? HvNAME_get(SvSTASH(SvRV(ST(0))))
		    : (char *)SvPV_nolen(ST(0));
	}
	if ( !SvVOK(ver) ) { /* not already a v-string */
	    rv = sv_newmortal();
d686 1
a686 2
	} else {
	    rv = sv_2mortal(new_version(ver));
d688 3
a690 2
	if ( items == 2 && strcmp(classname,"version") ) { /* inherited new() */
	    sv_bless(rv, gv_stashpv(classname, GV_ADD));
a691 5
	PUSHs(rv);
    }
    PUTBACK;
    return;
}
a692 13
XS(XS_version_is_qv)
{
    dVAR;
    dXSARGS;
    if (items != 1)
	croak_xs_usage(cv, "lobj");
    SP -= items;
    if (sv_derived_from(ST(0), "version")) {
	SV * const lobj = ST(0);
	if ( hv_exists(MUTABLE_HV(SvRV(lobj)), "qv", 2 ) )
	    XSRETURN_YES;
	else
	    XSRETURN_NO;
a695 2
    else
	Perl_croak(aTHX_ "lobj is not of type version");
d702 1
d704 1
a704 1
	 croak_xs_usage(cv, "sv");
d719 1
d721 1
a721 1
	 croak_xs_usage(cv, "sv");
d738 1
d740 1
a740 1
	croak_xs_usage(cv, "sv");
d749 1
d751 1
a751 1
	croak_xs_usage(cv, "sv");
d765 1
d767 1
a767 1
	croak_xs_usage(cv, "sv");
d783 1
d785 1
a785 1
	croak_xs_usage(cv, "sv, failok=0");
d802 1
d805 1
a805 1
     croak_xs_usage(cv, "sv");
d816 1
d819 1
a819 1
     croak_xs_usage(cv, "sv");
d873 1
d876 1
a876 1
	croak_xs_usage(cv, "hv");
d878 1
a878 1
	HV * const hv = MUTABLE_HV(SvRV(ST(0)));
d894 1
d896 1
a896 1
	croak_xs_usage(cv, "filehandle[,args]");
d944 1
a944 1
	gv = MUTABLE_GV(sv);
d948 1
a948 1
		  gv = MUTABLE_GV(SvRV(sv));
d954 1
d972 1
a972 1
			      ? sv_2mortal(newSVpvn(SvPVX_const(*namsvp), SvCUR(*namsvp)))
d975 1
a975 1
			      ? sv_2mortal(newSVpvn(SvPVX_const(*argsvp), SvCUR(*argsvp)))
d978 1
a978 1
			    mXPUSHi(SvIVX(*flgsvp));
d985 1
a985 1
			    XPUSHs(sv_2mortal(Perl_newSVpvf(aTHX_ "%"SVf"(%"SVf")",
d987 1
a987 1
						 SVfARG(*argsvp))));
d989 2
a990 2
			    XPUSHs(sv_2mortal(Perl_newSVpvf(aTHX_ "%"SVf,
						 SVfARG(*namsvp))));
d998 1
a998 1
				 XPUSHs(newSVpvs_flags("utf8", SVs_TEMP));
d1043 1
a1043 1
	const HV * const hv = (const HV *) SvRV(ST(0));
d1061 1
a1061 1
	croak_xs_usage(cv, "sv");
d1078 1
d1081 1
a1081 1
	croak_xs_usage(cv, "");
d1093 1
a1093 1
        mXPUSHs(ret);
d1108 1
d1111 1
a1111 1
	croak_xs_usage(cv, "name[, all ]");
d1128 4
a1131 1
        mXPUSHs(ret);
d1149 1
d1152 1
a1152 1
	croak_xs_usage(cv, "[all]");
d1176 1
a1176 1
    av = MUTABLE_AV(SvRV(ret));
d1185 1
a1185 1
        mXPUSHs(SvREFCNT_inc_simple_NN(*entry));
a1186 3

    SvREFCNT_dec(ret);

a1190 90
XS(XS_re_regexp_pattern)
{
    dVAR;
    dXSARGS;
    REGEXP *re;

    if (items != 1)
	croak_xs_usage(cv, "sv");

    SP -= items;

    /*
       Checks if a reference is a regex or not. If the parameter is
       not a ref, or is not the result of a qr// then returns false
       in scalar context and an empty list in list context.
       Otherwise in list context it returns the pattern and the
       modifiers, in scalar context it returns the pattern just as it
       would if the qr// was stringified normally, regardless as
       to the class of the variable and any strigification overloads
       on the object.
    */

    if ((re = SvRX(ST(0)))) /* assign deliberate */
    {
        /* Housten, we have a regex! */
        SV *pattern;
        STRLEN left = 0;
        char reflags[6];

        if ( GIMME_V == G_ARRAY ) {
            /*
               we are in list context so stringify
               the modifiers that apply. We ignore "negative
               modifiers" in this scenario.
            */

            const char *fptr = INT_PAT_MODS;
            char ch;
            U16 match_flags = (U16)((RX_EXTFLAGS(re) & PMf_COMPILETIME)
                                    >> RXf_PMf_STD_PMMOD_SHIFT);

            while((ch = *fptr++)) {
                if(match_flags & 1) {
                    reflags[left++] = ch;
                }
                match_flags >>= 1;
            }

            pattern = newSVpvn_flags(RX_PRECOMP(re),RX_PRELEN(re),
				     (RX_UTF8(re) ? SVf_UTF8 : 0) | SVs_TEMP);

            /* return the pattern and the modifiers */
            XPUSHs(pattern);
            XPUSHs(newSVpvn_flags(reflags, left, SVs_TEMP));
            XSRETURN(2);
        } else {
            /* Scalar, so use the string that Perl would return */
            /* return the pattern in (?msix:..) format */
#if PERL_VERSION >= 11
            pattern = sv_2mortal(newSVsv(MUTABLE_SV(re)));
#else
            pattern = newSVpvn_flags(RX_WRAPPED(re), RX_WRAPLEN(re),
				     (RX_UTF8(re) ? SVf_UTF8 : 0) | SVs_TEMP);
#endif
            XPUSHs(pattern);
            XSRETURN(1);
        }
    } else {
        /* It ain't a regexp folks */
        if ( GIMME_V == G_ARRAY ) {
            /* return the empty list */
            XSRETURN_UNDEF;
        } else {
            /* Because of the (?:..) wrapping involved in a
               stringified pattern it is impossible to get a
               result for a real regexp that would evaluate to
               false. Therefore we can return PL_sv_no to signify
               that the object is not a regex, this means that one
               can say

                 if (regex($might_be_a_regex) eq '(?:foo)') { }

               and not worry about undefined values.
            */
            XSRETURN_NO;
        }
    }
    /* NOT-REACHED */
}

d1198 1
d1201 1
a1201 1
	croak_xs_usage(cv, "$key, $flags");
d1210 1
a1210 1
    flags = (U32)INT2PTR(IV,SvIV(SvRV(MUTABLE_SV(ST(0)))));
d1216 4
a1219 1
        mXPUSHs(ret);
d1232 1
d1235 1
a1235 1
	croak_xs_usage(cv, "$key, $value, $flags");
d1241 1
a1241 1
            Perl_croak(aTHX_ "%s", PL_no_modify);
d1248 1
a1248 1
    flags = (U32)INT2PTR(IV,SvIV(SvRV(MUTABLE_SV(ST(0)))));
d1258 1
d1261 1
a1261 1
	croak_xs_usage(cv, "$key, $flags");
d1264 1
a1264 1
        Perl_croak(aTHX_ "%s", PL_no_modify);
d1268 1
a1268 1
    flags = (U32)INT2PTR(IV,SvIV(SvRV(MUTABLE_SV(ST(0)))));
d1278 1
d1281 1
a1281 1
	croak_xs_usage(cv, "$flags");
d1286 1
a1286 1
        Perl_croak(aTHX_ "%s", PL_no_modify);
d1290 1
a1290 1
    flags = (U32)INT2PTR(IV,SvIV(SvRV(MUTABLE_SV(ST(0)))));
d1301 1
d1304 1
a1304 1
	croak_xs_usage(cv, "$key, $flags");
d1313 1
a1313 1
    flags = (U32)INT2PTR(IV,SvIV(SvRV(MUTABLE_SV(ST(0)))));
d1330 1
d1333 1
a1333 1
	croak_xs_usage(cv, "");
d1342 1
a1342 1
    flags = (U32)INT2PTR(IV,SvIV(SvRV(MUTABLE_SV(ST(0)))));
d1348 1
a1348 1
        mXPUSHs(ret);
d1363 1
d1366 1
a1366 1
	croak_xs_usage(cv, "$lastkey");
d1375 1
a1375 1
    flags = (U32)INT2PTR(IV,SvIV(SvRV(MUTABLE_SV(ST(0)))));
d1381 1
a1381 1
        mXPUSHs(ret);
d1395 1
d1398 1
a1398 1
	croak_xs_usage(cv, "");
d1407 1
a1407 1
    flags = (U32)INT2PTR(IV,SvIV(SvRV(MUTABLE_SV(ST(0)))));
d1413 1
a1413 1
        mXPUSHs(ret);
d1425 1
d1428 1
a1428 1
	croak_xs_usage(cv, "");
d1430 2
a1431 2
	mXPUSHu(RXapif_ONE);
	mXPUSHu(RXapif_ALL);
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d124 1
a124 1
Perl_sv_derived_from(pTHX_ SV *sv, const char *const name)
d160 1
a160 1
Perl_sv_does(pTHX_ SV *sv, const char *const name)
d175 1
a175 2
	    || (SvGMAGICAL(sv) && SvPOKp(sv) && SvCUR(sv)))) {
	LEAVE;
a176 1
    }
d184 1
a184 2
    if (strEQ(name,classname)) {
	LEAVE;
a185 1
    }
d237 1
d304 1
a304 3
    /* Providing a Regexp::DESTROY fixes #21347. See test in t/op/ref.t  */
    CvFILE(newCONSTSUB(get_hv("Regexp::", GV_ADD), "DESTROY", NULL))
	= (char *)file;
d544 1
a544 1
	if ( items == 1 || ! SvOK(vs) ) { /* no param or explicit undef */
d547 1
a547 1
	    sv_setpvs(vs, "0");
d657 1
a657 1
		    robj = new_version(SvOK(robj) ? robj : newSVpvs("0"));
d741 1
a741 1
	if ( items == 2 && SvOK(ST(1)) ) {
d792 1
a792 2
	SV * const sv = ST(0);
	SvGETMAGIC(sv);
d962 6
a1046 4
		      /* Indents of 5? Yuck.  */
		      /* We know that PerlIO_get_layers creates a new SV for
			 the name and flags, so we can just take a reference
			 and "steal" it when we free the AV below.  */
d1048 1
a1048 1
			      ? sv_2mortal(SvREFCNT_inc_simple_NN(*namsvp))
d1051 1
a1051 7
			      ? newSVpvn_flags(SvPVX_const(*argsvp),
					       SvCUR(*argsvp),
					       (SvUTF8(*argsvp) ? SVf_UTF8 : 0)
					       | SVs_TEMP)
			      : &PL_sv_undef);
		       XPUSHs(flgok
			      ? sv_2mortal(SvREFCNT_inc_simple_NN(*flgsvp))
d1053 4
d1065 2
a1066 1
			   XPUSHs(sv_2mortal(SvREFCNT_inc_simple_NN(*namsvp)));
d1367 1
a1367 1
    if (!rx || !SvROK(ST(0)))
d1397 1
a1397 1
    if (!rx || !SvROK(ST(0))) {
d1420 1
a1420 1
    if (!rx || !SvROK(ST(0)))
d1441 1
a1441 1
    if (!rx || !SvROK(ST(0)))
d1463 1
a1463 1
    if (!rx || !SvROK(ST(0)))
d1491 1
a1491 1
    if (!rx || !SvROK(ST(0)))
d1523 1
a1523 1
    if (!rx || !SvROK(ST(0)))
d1554 1
a1554 1
    if (!rx || !SvROK(ST(0)))
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d24 1
a24 1
 * clever to move them to separate XS files which would then be pulled
d36 35
d77 1
a77 1
S_isa_lookup(pTHX_ HV *stash, const char * const name, STRLEN len, U32 flags)
d81 2
a82 1
    HV *isa = meta->isa;
d87 2
a88 6
    if (!isa) {
	(void)mro_get_linear_isa(stash);
	isa = meta->isa;
    }

    if (hv_common(isa, NULL, name, len, ( flags & SVf_UTF8 ? HVhek_UTF8 : 0),
d95 2
a96 3
       we use the HvENAME in the stash itself, which is canonical, falling
       back to HvNAME if necessary.  */
    our_stash = gv_stashpvn(name, len, flags);
d99 1
a99 2
	HEK *canon_name = HvENAME_HEK(our_stash);
	if (!canon_name) canon_name = HvNAME_HEK(our_stash);
d114 1
a114 1
=for apidoc sv_derived_from_pvn
a119 30
Currently, the only significant value for C<flags> is SVf_UTF8.

=cut

=for apidoc sv_derived_from_sv

Exactly like L</sv_derived_from_pvn>, but takes the name string in the form
of an SV instead of a string/length pair.

=cut

*/

bool
Perl_sv_derived_from_sv(pTHX_ SV *sv, SV *namesv, U32 flags)
{
    char *namepv;
    STRLEN namelen;
    PERL_ARGS_ASSERT_SV_DERIVED_FROM_SV;
    namepv = SvPV(namesv, namelen);
    if (SvUTF8(namesv))
       flags |= SVf_UTF8;
    return sv_derived_from_pvn(sv, namepv, namelen, flags);
}

/*
=for apidoc sv_derived_from

Exactly like L</sv_derived_from_pv>, but doesn't take a C<flags> parameter.

a125 24
    PERL_ARGS_ASSERT_SV_DERIVED_FROM;
    return sv_derived_from_pvn(sv, name, strlen(name), 0);
}

/*
=for apidoc sv_derived_from_pv

Exactly like L</sv_derived_from_pvn>, but takes a nul-terminated string 
instead of a string/length pair.

=cut
*/


bool
Perl_sv_derived_from_pv(pTHX_ SV *sv, const char *const name, U32 flags)
{
    PERL_ARGS_ASSERT_SV_DERIVED_FROM_PV;
    return sv_derived_from_pvn(sv, name, strlen(name), flags);
}

bool
Perl_sv_derived_from_pvn(pTHX_ SV *sv, const char *const name, const STRLEN len, U32 flags)
{
d129 1
a129 1
    PERL_ARGS_ASSERT_SV_DERIVED_FROM_PVN;
d145 1
a145 1
    return stash ? isa_lookup(stash, name, len, flags) : FALSE;
d149 1
a149 1
=for apidoc sv_does_sv
d160 1
a160 1
Perl_sv_does_sv(pTHX_ SV *sv, SV *namesv, U32 flags)
d162 1
a162 1
    SV *classname;
d167 1
a167 2
    PERL_ARGS_ASSERT_SV_DOES_SV;
    PERL_UNUSED_ARG(flags);
d181 1
a181 1
	classname = sv_ref(NULL,SvRV(sv),TRUE);
d183 1
a183 1
	classname = sv;
d186 1
a186 1
    if (sv_eq(classname, namesv)) {
d192 2
a193 3
    EXTEND(SP, 2);
    PUSHs(sv);
    PUSHs(namesv);
d211 47
a257 2
/*
=for apidoc sv_does
d259 2
a260 7
Like L</sv_does_pv>, but doesn't take a C<flags> parameter.

=cut
*/

bool
Perl_sv_does(pTHX_ SV *sv, const char *const name)
d262 2
a263 3
    PERL_ARGS_ASSERT_SV_DOES;
    return sv_does_sv(sv, newSVpvn_flags(name, strlen(name), SVs_TEMP), 0);
}
d265 62
a326 30
/*
=for apidoc sv_does_pv

Like L</sv_does_sv>, but takes a nul-terminated string instead of an SV.

=cut
*/


bool
Perl_sv_does_pv(pTHX_ SV *sv, const char *const name, U32 flags)
{
    PERL_ARGS_ASSERT_SV_DOES_PV;
    return sv_does_sv(sv, newSVpvn_flags(name, strlen(name), SVs_TEMP | flags), flags);
}

/*
=for apidoc sv_does_pvn

Like L</sv_does_sv>, but takes a string/length pair instead of an SV.

=cut
*/

bool
Perl_sv_does_pvn(pTHX_ SV *sv, const char *const name, const STRLEN len, U32 flags)
{
    PERL_ARGS_ASSERT_SV_DOES_PVN;

    return sv_does_sv(sv, newSVpvn_flags(name, len, flags | SVs_TEMP), flags);
d339 1
a339 1
    Perl_croak(aTHX_ "Usage: %"SVf"::%"SVf"(%s)", "ouch" "awk", "eee_yow");
d352 1
d354 1
d356 2
a357 5
	if (HvNAME_get(stash))
	    Perl_croak(aTHX_ "Usage: %"HEKf"::%"HEKf"(%s)",
                                HEKfARG(HvNAME_HEK(stash)),
                                HEKfARG(GvNAME_HEK(gv)),
                                params);
d359 1
a359 2
	    Perl_croak(aTHX_ "Usage: %"HEKf"(%s)",
                                HEKfARG(GvNAME_HEK(gv)), params);
d375 1
d383 3
a385 1
	ST(0) = boolSV(sv_derived_from_sv(sv, ST(1), 0));
d395 1
d410 1
d423 1
a423 1
	GV * const gv = gv_fetchmethod_sv_flags(pkg, ST(1), 0);
d442 4
a445 1
	if (sv_does_sv( sv, ST(1), 0 ))
d479 1
a479 1
	if ( !sv_isobject(sv) || !sv_derived_from(sv, "version"))
a480 1

d493 1
a493 1
		const HEK * const name = HvNAME_HEK(pkg);
d495 2
a496 3
			   "%"HEKf" does not define $%"HEKf
			   "::VERSION--version check failed",
			   HEKfARG(name), HEKfARG(name));
d499 2
a500 2
			     "%"SVf" defines neither package nor VERSION--version check failed",
			     SVfARG(ST(0)) );
d504 1
a504 1
	if ( !sv_isobject(req) || !sv_derived_from(req, "version")) {
d511 4
a514 5
		Perl_croak(aTHX_ "%"HEKf" version %"SVf" required--"
		       "this is only version %"SVf"",
                       HEKfARG(HvNAME_HEK(pkg)),
		       SVfARG(sv_2mortal(vnormal(req))),
		       SVfARG(sv_2mortal(vnormal(sv))));
d516 4
a519 5
		Perl_croak(aTHX_ "%"HEKf" version %"SVf" required--"
		       "this is only version %"SVf,
                       HEKfARG(HvNAME_HEK(pkg)),
		       SVfARG(sv_2mortal(vstringify(req))),
		       SVfARG(sv_2mortal(vstringify(sv))));
d526 1
a526 1
	ST(0) = sv_2mortal(vstringify(sv));
d544 4
a547 13
        STRLEN len;
        const char *classname;
        U32 flags;
        if ( sv_isobject(ST(0)) ) { /* get the class if called as an object method */
            const HV * stash = SvSTASH(SvRV(ST(0)));
            classname = HvNAME(stash);
            len       = HvNAMELEN(stash);
            flags     = HvNAMEUTF8(stash) ? SVf_UTF8 : 0;
        }
        else {
	    classname = SvPV(ST(0), len);
            flags     = SvUTF8(ST(0));
        }
d560 2
a561 2
	if ( strnNE(classname,"version", len) ) /* inherited new() */
	    sv_bless(rv, gv_stashpvn(classname, len, GV_ADD | flags));
d577 1
a577 1
	  SV *	lobj = ST(0);
d579 2
a580 2
	  if (sv_isobject(lobj) && sv_derived_from(lobj, "version")) {
	       lobj = SvRV(lobj);
d600 1
a600 1
	  SV *	lobj = ST(0);
d602 2
a603 2
	  if (sv_isobject(lobj) && sv_derived_from(lobj, "version")) {
	       lobj = SvRV(lobj);
d623 1
a623 1
	  SV *	lobj = ST(0);
d625 2
a626 2
	  if (sv_isobject(lobj) && sv_derived_from(lobj, "version")) {
	       lobj = SvRV(lobj);
d646 1
a646 1
	  SV *	lobj = ST(0);
d648 2
a649 2
	  if (sv_isobject(lobj) && sv_derived_from(lobj, "version")) {
	       lobj = SvRV(lobj);
d660 1
a660 1
	       if ( !sv_isobject(robj) || !sv_derived_from(robj, "version") )
d662 1
a662 2
		    robj = new_version(SvOK(robj) ? robj : newSVpvs_flags("0", SVs_TEMP));
		    sv_2mortal(robj);
d690 1
a690 1
    if (sv_isobject(ST(0)) && sv_derived_from(ST(0), "version")) {
d692 1
a692 7
	SV * const rs =
	    newSViv( vcmp(lobj,
			  sv_2mortal(new_version(
					sv_2mortal(newSVpvs("0"))
				    ))
			 )
		   );
d707 1
a707 1
    if (sv_isobject(ST(0)) && sv_derived_from(ST(0), "version"))
d723 1
a723 1
    if (sv_isobject(ST(0)) && sv_derived_from(ST(0), "version")) {
d745 9
a753 16
        STRLEN len = 0;
        const char * classname = "";
        U32 flags = 0;
        if ( items == 2 && SvOK(ST(1)) ) {
            ver = ST(1);
            if ( sv_isobject(ST(0)) ) { /* class called as an object method */
                const HV * stash = SvSTASH(SvRV(ST(0)));
                classname = HvNAME(stash);
                len       = HvNAMELEN(stash);
                flags     = HvNAMEUTF8(stash) ? SVf_UTF8 : 0;
            }
            else {
	       classname = SvPV(ST(0), len);
                flags     = SvUTF8(ST(0));
            }
        }
d761 3
a763 4
	if ( items == 2
                && strnNE(classname,"version", len) ) { /* inherited new() */
	    sv_bless(rv, gv_stashpvn(classname, len, GV_ADD | flags));
        }
d777 1
a777 1
    if (sv_isobject(ST(0)) && sv_derived_from(ST(0), "version")) {
d843 1
a843 3
	bool RETVAL;
	SvPV_force_nolen(sv);
	RETVAL = sv_utf8_decode(sv);
d845 1
d879 1
d914 1
a914 2
    SV * const svz = ST(0);
    SV * sv;
a916 6
    /* [perl #77776] - called as &foo() not foo() */
    if (!SvROK(svz))
        croak_xs_usage(cv, "SCALAR[, ON]");

    sv = SvRV(svz);

d918 1
a918 1
	 if (SvREADONLY(sv) && !SvIsCOW(sv))
a924 1
	    if (SvIsCOW(sv)) sv_force_normal(sv);
d930 1
a930 1
	    if (!SvIsCOW(sv)) SvREADONLY_off(sv);
d941 1
a941 2
    SV * const svz = ST(0);
    SV * sv;
a943 6
    /* [perl #77776] - called as &foo() not foo() */
    if (!SvROK(svz))
        croak_xs_usage(cv, "SCALAR[, REFCOUNT]");

    sv = SvRV(svz);

d945 1
a945 1
	 XSRETURN_UV(SvREFCNT(sv) - 1); /* Minus the ref created for us. */
d948 2
a949 2
	 SvREFCNT(sv) = SvUV(ST(1)) + 1; /* we free one ref on exit */
	 XSRETURN_UV(SvREFCNT(sv) - 1);
d959 1
a959 1
    if (items != 1 || !SvROK(ST(0)))
d1021 1
a1021 1
	gv = MAYBE_DEREF_GV(sv);
d1023 6
a1028 2
	if (!gv && !SvROK(sv))
	    gv = gv_fetchsv_nomg(sv, 0, SVt_PVIO);
d1144 2
a1163 1
    PUTBACK;
d1171 8
a1178 2
    PUSHs(ret ? sv_2mortal(ret) : &PL_sv_undef);
    XSRETURN(1);
a1192 1
    PUTBACK;
d1206 5
a1210 3
    SPAGAIN;
    PUSHs(ret ? sv_2mortal(ret) : &PL_sv_undef);
    XSRETURN(1);
a1240 1
    PUTBACK;
d1246 2
d1287 1
a1287 1
       to the class of the variable and any stringification overloads
d1293 1
a1293 1
        /* Houston, we have a regex! */
d1295 2
a1298 6
	    STRLEN left = 0;
	    char reflags[sizeof(INT_PAT_MODS) + MAX_CHARSET_NAME_LENGTH];
            const char *fptr;
            char ch;
            U16 match_flags;

d1302 1
a1302 1
               modifiers" in this scenario, and the default character set
d1305 3
a1307 9
	    if (get_regex_charset(RX_EXTFLAGS(re)) != REGEX_DEPENDS_CHARSET) {
		STRLEN len;
		const char* const name = get_regex_charset_name(RX_EXTFLAGS(re),
								&len);
		Copy(name, reflags + left, len, char);
		left += len;
	    }
            fptr = INT_PAT_MODS;
            match_flags = (U16)((RX_EXTFLAGS(re) & RXf_PMf_COMPILETIME)
d1359 186
a1544 60
struct xsub_details {
    const char *name;
    XSUBADDR_t xsub;
    const char *proto;
};

struct xsub_details details[] = {
    {"UNIVERSAL::isa", XS_UNIVERSAL_isa, NULL},
    {"UNIVERSAL::can", XS_UNIVERSAL_can, NULL},
    {"UNIVERSAL::DOES", XS_UNIVERSAL_DOES, NULL},
    {"UNIVERSAL::VERSION", XS_UNIVERSAL_VERSION, NULL},
    {"version::()", XS_version_noop, NULL},
    {"version::new", XS_version_new, NULL},
    {"version::parse", XS_version_new, NULL},
    {"version::(\"\"", XS_version_stringify, NULL},
    {"version::stringify", XS_version_stringify, NULL},
    {"version::(0+", XS_version_numify, NULL},
    {"version::numify", XS_version_numify, NULL},
    {"version::normal", XS_version_normal, NULL},
    {"version::(cmp", XS_version_vcmp, NULL},
    {"version::(<=>", XS_version_vcmp, NULL},
    {"version::vcmp", XS_version_vcmp, NULL},
    {"version::(bool", XS_version_boolean, NULL},
    {"version::boolean", XS_version_boolean, NULL},
    {"version::(+", XS_version_noop, NULL},
    {"version::(-", XS_version_noop, NULL},
    {"version::(*", XS_version_noop, NULL},
    {"version::(/", XS_version_noop, NULL},
    {"version::(+=", XS_version_noop, NULL},
    {"version::(-=", XS_version_noop, NULL},
    {"version::(*=", XS_version_noop, NULL},
    {"version::(/=", XS_version_noop, NULL},
    {"version::(abs", XS_version_noop, NULL},
    {"version::(nomethod", XS_version_noop, NULL},
    {"version::noop", XS_version_noop, NULL},
    {"version::is_alpha", XS_version_is_alpha, NULL},
    {"version::qv", XS_version_qv, NULL},
    {"version::declare", XS_version_qv, NULL},
    {"version::is_qv", XS_version_is_qv, NULL},
    {"utf8::is_utf8", XS_utf8_is_utf8, NULL},
    {"utf8::valid", XS_utf8_valid, NULL},
    {"utf8::encode", XS_utf8_encode, NULL},
    {"utf8::decode", XS_utf8_decode, NULL},
    {"utf8::upgrade", XS_utf8_upgrade, NULL},
    {"utf8::downgrade", XS_utf8_downgrade, NULL},
    {"utf8::native_to_unicode", XS_utf8_native_to_unicode, NULL},
    {"utf8::unicode_to_native", XS_utf8_unicode_to_native, NULL},
    {"Internals::SvREADONLY", XS_Internals_SvREADONLY, "\\[$%@@];$"},
    {"Internals::SvREFCNT", XS_Internals_SvREFCNT, "\\[$%@@];$"},
    {"Internals::hv_clear_placeholders", XS_Internals_hv_clear_placehold, "\\%"},
    {"PerlIO::get_layers", XS_PerlIO_get_layers, "*;@@"},
    {"Internals::hash_seed", XS_Internals_hash_seed, ""},
    {"Internals::rehash_seed", XS_Internals_rehash_seed, ""},
    {"Internals::HvREHASH", XS_Internals_HvREHASH, "\\%"},
    {"re::is_regexp", XS_re_is_regexp, "$"},
    {"re::regname", XS_re_regname, ";$$"},
    {"re::regnames", XS_re_regnames, ";$"},
    {"re::regnames_count", XS_re_regnames_count, ""},
    {"re::regexp_pattern", XS_re_regexp_pattern, "$"},
};
d1546 1
a1546 2
void
Perl_boot_core_UNIVERSAL(pTHX)
d1549 17
a1565 8
    static const char file[] = __FILE__;
    struct xsub_details *xsub = details;
    const struct xsub_details *end
	= details + sizeof(details) / sizeof(details[0]);

    do {
	newXS_flags(xsub->name, xsub->xsub, file, xsub->proto, 0);
    } while (++xsub < end);
d1567 1
a1567 2
    /* register the overloading (type 'A') magic */
    PL_amagic_generation++;
d1569 6
a1574 7
    /* Providing a Regexp::DESTROY fixes #21347. See test in t/op/ref.t  */
    {
	CV * const cv =
	    newCONSTSUB(get_hv("Regexp::", GV_ADD), "DESTROY", NULL);
	Safefree(CvFILE(cv));
	CvFILE(cv) = (char *)file;
	CvDYNFILE_off(cv);
d1577 15
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a166 2
        if (!stash)
            stash = gv_stashpvs("UNIVERSAL", 0);
d199 2
a200 1
    if (!SvOK(sv) || !(SvROK(sv) || (SvPOK(sv) && SvCUR(sv)))) {
d300 1
a300 1
Perl_croak_xs_usage(const CV *const cv, const char *const params)
d310 1
a310 1
	    Perl_croak_nocontext("Usage: %"HEKf"::%"HEKf"(%s)",
d315 1
a315 1
	    Perl_croak_nocontext("Usage: %"HEKf"(%s)",
d319 1
a319 1
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
d335 2
a336 1
	if (!SvOK(sv) || !(SvROK(sv) || (SvPOK(sv) && SvCUR(sv))))
d359 2
a360 2
    if (!SvOK(sv) || !(SvROK(sv) || SvNIOK(sv) || (SvPOK(sv) && SvCUR(sv))
       ))
a371 2
        if (!pkg)
            pkg = gv_stashpv("UNIVERSAL", 0);
d491 1
a491 1
    if (items > 3 || items < 1)
a808 1
    SvSETMAGIC(ST(0));
a822 1
	SvSETMAGIC(sv);
d921 1
a927 1
    U32 refcnt;
d931 1
a931 1
    if ((items != 1 && items != 2) || !SvROK(svz))
d936 3
d940 4
a943 7
    /* idea is for SvREFCNT(sv) to be accessed only once */
    refcnt = items == 2 ?
                /* we free one ref on exit */
                (SvREFCNT(sv) = SvUV(ST(1)) + 1)
                : SvREFCNT(sv);
    XSRETURN_UV(refcnt - 1); /* Minus the ref created for us. */        

a1033 1
		  EXTEND(SP, 3); /* Three is the max in all branches: better check just once */
d1039 1
a1039 1
		       PUSHs(namok
d1042 1
a1042 1
		       PUSHs(argok
d1048 1
a1048 1
		       PUSHs(flgok
d1055 1
a1055 1
			    PUSHs(sv_2mortal(Perl_newSVpvf(aTHX_ "%"SVf"(%"SVf")",
d1059 1
a1059 1
			    PUSHs(sv_2mortal(SvREFCNT_inc_simple_NN(*namsvp)));
d1061 1
a1061 1
			    PUSHs(&PL_sv_undef);
d1067 1
a1067 1
				 PUSHs(newSVpvs_flags("utf8", SVs_TEMP));
d1084 38
a1232 1
    EXTEND(SP, length+1); /* better extend stack just once */
d1239 1
a1239 1
        mPUSHs(SvREFCNT_inc_simple_NN(*entry));
a1253 2
    EXTEND(SP, 2);
    SP -= items;
d1257 2
d1310 2
a1311 2
            PUSHs(pattern);
            PUSHs(newSVpvn_flags(reflags, left, SVs_TEMP));
d1322 1
a1322 1
            PUSHs(pattern);
d1354 1
a1354 1
const struct xsub_details details[] = {
d1399 3
d1414 1
a1414 1
    const struct xsub_details *xsub = details;
d1422 3
d1439 1
a1439 1
 * indent-tabs-mode: nil
d1442 1
a1442 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d32 1
a32 1
#if defined(USE_PERLIO)
d163 1
a163 3
        if (!SvOBJECT(sv))
            return FALSE;
	stash = SvSTASH(sv);
d167 2
d171 1
a171 5
    if (stash && isa_lookup(stash, name, len, flags))
        return TRUE;

    stash = gv_stashpvs("UNIVERSAL", 0);
    return stash && isa_lookup(stash, name, len, flags);
d293 1
a293 1
C<croak()>.  Hence if C<cv> is C<&ouch::awk>, it would call C<croak> as:
a310 1
	    /* diag_listed_as: SKIPME */
a315 1
	    /* diag_listed_as: SKIPME */
a319 1
	/* diag_listed_as: SKIPME */
a323 1
XS(XS_UNIVERSAL_isa); /* prototype to pass -Wmissing-prototypes */
a343 1
XS(XS_UNIVERSAL_can); /* prototype to pass -Wmissing-prototypes */
a350 1
    GV   *iogv;
d359 2
a360 4
    /* Reject undef and empty string.  Note that the string form takes
       precedence here over the numeric form, as (!1)->foo treats the
       invocant as the empty string, though it is a dualvar. */
    if (!SvOK(sv) || (SvPOK(sv) && !SvCUR(sv)))
a368 2
        else if (isGV_with_GP(sv) && GvIO(sv))
	    pkg = SvSTASH(GvIO(sv));
a369 4
    else if (isGV_with_GP(sv) && GvIO(sv))
        pkg = SvSTASH(GvIO(sv));
    else if ((iogv = gv_fetchsv_nomg(sv, 0, SVt_PVIO)) && GvIO(iogv))
        pkg = SvSTASH(GvIO(iogv));
a385 1
XS(XS_UNIVERSAL_DOES); /* prototype to pass -Wmissing-prototypes */
d403 366
a768 1
XS(XS_utf8_is_utf8); /* prototype to pass -Wmissing-prototypes */
a785 1
XS(XS_utf8_valid); /* prototype to pass -Wmissing-prototypes */
a803 1
XS(XS_utf8_encode); /* prototype to pass -Wmissing-prototypes */
a814 1
XS(XS_utf8_decode); /* prototype to pass -Wmissing-prototypes */
a831 1
XS(XS_utf8_upgrade); /* prototype to pass -Wmissing-prototypes */
a848 1
XS(XS_utf8_downgrade); /* prototype to pass -Wmissing-prototypes */
a864 1
XS(XS_utf8_native_to_unicode); /* prototype to pass -Wmissing-prototypes */
a877 1
XS(XS_utf8_unicode_to_native); /* prototype to pass -Wmissing-prototypes */
a890 1
XS(XS_Internals_SvREADONLY); /* prototype to pass -Wmissing-prototypes */
d906 1
a906 1
	 if (SvREADONLY(sv))
a912 1
#ifdef PERL_OLD_COPY_ON_WRITE
a913 1
#endif
d919 1
a919 1
	    SvREADONLY_off(sv);
a924 33

XS(XS_constant__make_const); /* prototype to pass -Wmissing-prototypes */
XS(XS_constant__make_const)	/* This is dangerous stuff. */
{
    dVAR;
    dXSARGS;
    SV * const svz = ST(0);
    SV * sv;
    PERL_UNUSED_ARG(cv);

    /* [perl #77776] - called as &foo() not foo() */
    if (!SvROK(svz) || items != 1)
        croak_xs_usage(cv, "SCALAR");

    sv = SvRV(svz);

#ifdef PERL_OLD_COPY_ON_WRITE
    if (SvIsCOW(sv)) sv_force_normal(sv);
#endif
    SvREADONLY_on(sv);
    if (SvTYPE(sv) == SVt_PVAV && AvFILLp(sv) != -1) {
	/* for constant.pm; nobody else should be calling this
	   on arrays anyway. */
	SV **svp;
	for (svp = AvARRAY(sv) + AvFILLp(sv)
	   ; svp >= AvARRAY(sv)
	   ; --svp)
	    if (*svp) SvPADTMP_on(*svp);
    }
    XSRETURN(0);
}

XS(XS_Internals_SvREFCNT); /* prototype to pass -Wmissing-prototypes */
a949 1
XS(XS_Internals_hv_clear_placehold); /* prototype to pass -Wmissing-prototypes */
a963 1
XS(XS_PerlIO_get_layers); /* prototype to pass -Wmissing-prototypes */
d970 1
a970 1
#if defined(USE_PERLIO)
d1025 3
a1027 3
	     SSize_t i;
	     const SSize_t last = av_tindex(av);
	     SSize_t nitem = 0;
a1089 1
XS(XS_re_is_regexp); /* prototype to pass -Wmissing-prototypes */
a1105 1
XS(XS_re_regnames_count); /* prototype to pass -Wmissing-prototypes */
a1128 1
XS(XS_re_regname); /* prototype to pass -Wmissing-prototypes */
a1160 1
XS(XS_re_regnames); /* prototype to pass -Wmissing-prototypes */
d1169 2
a1170 2
    SSize_t length;
    SSize_t i;
d1198 1
a1198 1
    length = av_tindex(av);
a1215 1
XS(XS_re_regexp_pattern); /* prototype to pass -Wmissing-prototypes */
a1315 3
#include "vutil.h"
#include "vxs.inc"

d1322 1
a1322 1
static const struct xsub_details details[] = {
d1326 29
a1354 3
#define VXS_XSUB_DETAILS
#include "vxs.inc"
#undef VXS_XSUB_DETAILS
a1363 1
    {"constant::_make_const", XS_constant__make_const, "\\[$@@]"},
d1380 2
a1381 1
    const struct xsub_details *end = C_ARRAY_END(details);
@


1.1.1.16
log
@Import perl-5.24.2
@
text
@d44 1
d70 1
a70 1
	assert(canon_name);
d150 1
d210 1
a210 1
    if (SvROK(sv) && SvOBJECT(SvRV(sv))) {
d299 1
a299 2
 Perl_croak(aTHX_ "Usage: %"SVf"::%"SVf"(%s)", "ouch" "awk",
                                                     "eee_yow");
d307 1
a307 2
    /* Avoid CvGV as it requires aTHX.  */
    const GV *gv = CvNAMED(cv) ? NULL : cv->sv_any->xcv_gv_u.xcv_gv;
d311 1
a311 1
    if (gv) got_gv: {
a324 3
        dTHX;
        if ((gv = CvGV(cv))) goto got_gv;

d327 1
a327 1
	Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
d334 1
d355 1
d391 1
a391 1
            pkg = gv_stashpvs("UNIVERSAL", 0);
d407 1
d425 1
d443 1
d462 1
d474 1
d492 1
d510 1
d516 1
a516 1
        const bool failok = (items < 2) ? 0 : SvTRUE(ST(1)) ? 1 : 0;
d527 1
d534 1
a534 1
 ST(0) = sv_2mortal(newSVuv(NATIVE_TO_UNI(uv)));
d541 1
d548 1
a548 1
 ST(0) = sv_2mortal(newSVuv(UNI_TO_NATIVE(uv)));
d555 1
d575 4
a578 1
	    SvFLAGS(sv) |= SVf_READONLY;
d583 1
a583 1
	    SvFLAGS(sv) &=~ SVf_READONLY;
d593 1
d605 3
d624 1
d650 1
d665 1
d792 1
d811 1
d833 1
d866 1
d922 1
a924 1
    U8 const gimme = GIMME_V;
d947 1
a947 1
        if ( gimme == G_ARRAY ) {
d987 1
a987 1
            /* return the pattern in (?msixn:..) format */
d999 1
a999 1
        if ( gimme == G_ARRAY ) {
d1001 1
a1001 1
            XSRETURN_EMPTY;
d1017 1
a1017 1
    NOT_REACHED; /* NOTREACHED */
a1055 49
STATIC OP*
optimize_out_native_convert_function(pTHX_ OP* entersubop,
                                           GV* namegv,
                                           SV* protosv)
{
    /* Optimizes out an identity function, i.e., one that just returns its
     * argument.  The passed in function is assumed to be an identity function,
     * with no checking.  This is designed to be called for utf8_to_native()
     * and native_to_utf8() on ASCII platforms, as they just return their
     * arguments, but it could work on any such function.
     *
     * The code is mostly just cargo-culted from Memoize::Lift */

    OP *pushop, *argop;
    OP *parent;
    SV* prototype = newSVpvs("$");

    PERL_UNUSED_ARG(protosv);

    assert(entersubop->op_type == OP_ENTERSUB);

    entersubop = ck_entersub_args_proto(entersubop, namegv, prototype);
    parent = entersubop;

    SvREFCNT_dec(prototype);

    pushop = cUNOPx(entersubop)->op_first;
    if (! OpHAS_SIBLING(pushop)) {
        parent = pushop;
        pushop = cUNOPx(pushop)->op_first;
    }
    argop = OpSIBLING(pushop);

    /* Carry on without doing the optimization if it is not something we're
     * expecting, so continues to work */
    if (   ! argop
        || ! OpHAS_SIBLING(argop)
        ||   OpHAS_SIBLING(OpSIBLING(argop))
    ) {
        return entersubop;
    }

    /* cut argop from the subtree */
    (void)op_sibling_splice(parent, pushop, 1, NULL);

    op_free(entersubop);
    return argop;
}

d1059 1
a1067 16
#ifndef EBCDIC
    { /* On ASCII platforms these functions just return their argument, so can
         be optimized away */

        CV* to_native_cv = get_cv("utf8::unicode_to_native", 0);
        CV* to_unicode_cv = get_cv("utf8::native_to_unicode", 0);

        cv_set_call_checker(to_native_cv,
                            optimize_out_native_convert_function,
                            (SV*) to_native_cv);
        cv_set_call_checker(to_unicode_cv,
                            optimize_out_native_convert_function,
                            (SV*) to_unicode_cv);
    }
#endif

d1072 2
a1073 2
	char ** cvfile = &CvFILE(cv);
	char * oldfile = *cvfile;
a1074 2
	*cvfile = (char *)file;
	Safefree(oldfile);
d1079 6
@


