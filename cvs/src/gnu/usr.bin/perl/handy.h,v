head	1.17;
access;
symbols
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.10
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.15
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.17
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	cxJ08BvJA9Pt2PTM;

1.16
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.44;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.06.40;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.35.57;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.22.57;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.19;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.54;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.20;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.03.56;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.00;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.35;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.40;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.40;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.20;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.36;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.03;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.47;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.29;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.41;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.16.24;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.47.27;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.05;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.32;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.26;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.06.24;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.58.44;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.52.36;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.17
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    handy.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000,
 *    2001, 2002, 2004, 2005, 2006, 2007, 2008, 2012 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* IMPORTANT NOTE: Everything whose name begins with an underscore is for
 * internal core Perl use only. */

#ifndef HANDY_H /* Guard against nested #inclusion */
#define HANDY_H

#if !defined(__STDC__)
#ifdef NULL
#undef NULL
#endif
#  define NULL 0
#endif

#ifndef PERL_CORE
#  define Null(type) ((type)NULL)

/*
=head1 Handy Values

=for apidoc AmU||Nullch
Null character pointer.  (No longer available when C<PERL_CORE> is
defined.)

=for apidoc AmU||Nullsv
Null SV pointer.  (No longer available when C<PERL_CORE> is defined.)

=cut
*/

#  define Nullch Null(char*)
#  define Nullfp Null(PerlIO*)
#  define Nullsv Null(SV*)
#endif

#ifdef TRUE
#undef TRUE
#endif
#ifdef FALSE
#undef FALSE
#endif
#define TRUE (1)
#define FALSE (0)

/* The MUTABLE_*() macros cast pointers to the types shown, in such a way
 * (compiler permitting) that casting away const-ness will give a warning;
 * e.g.:
 *
 * const SV *sv = ...;
 * AV *av1 = (AV*)sv;        <== BAD:  the const has been silently cast away
 * AV *av2 = MUTABLE_AV(sv); <== GOOD: it may warn
 */

#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define MUTABLE_PTR(p) ({ void *_p = (p); _p; })
#else
#  define MUTABLE_PTR(p) ((void *) (p))
#endif

#define MUTABLE_AV(p)	((AV *)MUTABLE_PTR(p))
#define MUTABLE_CV(p)	((CV *)MUTABLE_PTR(p))
#define MUTABLE_GV(p)	((GV *)MUTABLE_PTR(p))
#define MUTABLE_HV(p)	((HV *)MUTABLE_PTR(p))
#define MUTABLE_IO(p)	((IO *)MUTABLE_PTR(p))
#define MUTABLE_SV(p)	((SV *)MUTABLE_PTR(p))

#if defined(I_STDBOOL) && !defined(PERL_BOOL_AS_CHAR)
#  include <stdbool.h>
#  ifndef HAS_BOOL
#    define HAS_BOOL 1
#  endif
#endif

/* bool is built-in for g++-2.6.3 and later, which might be used
   for extensions.  <_G_config.h> defines _G_HAVE_BOOL, but we can't
   be sure _G_config.h will be included before this file.  _G_config.h
   also defines _G_HAVE_BOOL for both gcc and g++, but only g++
   actually has bool.  Hence, _G_HAVE_BOOL is pretty useless for us.
   g++ can be identified by __GNUG__.
   Andy Dougherty	February 2000
*/
#ifdef __GNUG__		/* GNU g++ has bool built-in */
# ifndef PERL_BOOL_AS_CHAR
#  ifndef HAS_BOOL
#    define HAS_BOOL 1
#  endif
# endif
#endif

#ifndef HAS_BOOL
# ifdef bool
#  undef bool
# endif
# define bool char
# define HAS_BOOL 1
#endif

/* cast-to-bool.  A simple (bool) cast may not do the right thing: if bool is
 * defined as char for example, then the cast from int is
 * implementation-defined (bool)!!(cbool) in a ternary triggers a bug in xlc on
 * AIX */
#define cBOOL(cbool) ((cbool) ? (bool)1 : (bool)0)

/* Try to figure out __func__ or __FUNCTION__ equivalent, if any.
 * XXX Should really be a Configure probe, with HAS__FUNCTION__
 *     and FUNCTION__ as results.
 * XXX Similarly, a Configure probe for __FILE__ and __LINE__ is needed. */
#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || (defined(__SUNPRO_C)) /* C99 or close enough. */
#  define FUNCTION__ __func__
#else
#  if (defined(USING_MSVC6)) || /* MSVC6 has neither __func__ nor __FUNCTION and no good workarounds, either. */ \
      (defined(__DECC_VER)) /* Tru64 or VMS, and strict C89 being used, but not modern enough cc (in Tur64, -c99 not known, only -std1). */
#    define FUNCTION__ ""
#  else
#    define FUNCTION__ __FUNCTION__ /* Common extension. */
#  endif
#endif

/* XXX A note on the perl source internal type system.  The
   original intent was that I32 be *exactly* 32 bits.

   Currently, we only guarantee that I32 is *at least* 32 bits.
   Specifically, if int is 64 bits, then so is I32.  (This is the case
   for the Cray.)  This has the advantage of meshing nicely with
   standard library calls (where we pass an I32 and the library is
   expecting an int), but the disadvantage that an I32 is not 32 bits.
   Andy Dougherty	August 1996

   There is no guarantee that there is *any* integral type with
   exactly 32 bits.  It is perfectly legal for a system to have
   sizeof(short) == sizeof(int) == sizeof(long) == 8.

   Similarly, there is no guarantee that I16 and U16 have exactly 16
   bits.

   For dealing with issues that may arise from various 32/64-bit
   systems, we will ask Configure to check out

	SHORTSIZE == sizeof(short)
	INTSIZE == sizeof(int)
	LONGSIZE == sizeof(long)
	LONGLONGSIZE == sizeof(long long) (if HAS_LONG_LONG)
	PTRSIZE == sizeof(void *)
	DOUBLESIZE == sizeof(double)
	LONG_DOUBLESIZE == sizeof(long double) (if HAS_LONG_DOUBLE).

*/

#ifdef I_INTTYPES /* e.g. Linux has int64_t without <inttypes.h> */
#   include <inttypes.h>
#   ifdef INT32_MIN_BROKEN
#       undef  INT32_MIN
#       define INT32_MIN (-2147483647-1)
#   endif
#   ifdef INT64_MIN_BROKEN
#       undef  INT64_MIN
#       define INT64_MIN (-9223372036854775807LL-1)
#   endif
#endif

typedef I8TYPE I8;
typedef U8TYPE U8;
typedef I16TYPE I16;
typedef U16TYPE U16;
typedef I32TYPE I32;
typedef U32TYPE U32;

#ifdef HAS_QUAD
typedef I64TYPE I64;
typedef U64TYPE U64;
#endif

/* INT64_C/UINT64_C are C99 from <stdint.h> (so they will not be
 * available in strict C89 mode), but they are nice, so let's define
 * them if necessary. */
#if defined(HAS_QUAD)
#  undef PeRl_INT64_C
#  undef PeRl_UINT64_C
/* Prefer the native integer types (int and long) over long long
 * (which is not C89) and Win32-specific __int64. */
#  if QUADKIND == QUAD_IS_INT && INTSIZE == 8
#    define PeRl_INT64_C(c)	(c)
#    define PeRl_UINT64_C(c)	CAT2(c,U)
#  endif
#  if QUADKIND == QUAD_IS_LONG && LONGSIZE == 8
#    define PeRl_INT64_C(c)	CAT2(c,L)
#    define PeRl_UINT64_C(c)	CAT2(c,UL)
#  endif
#  if QUADKIND == QUAD_IS_LONG_LONG && defined(HAS_LONG_LONG)
#    define PeRl_INT64_C(c)	CAT2(c,LL)
#    define PeRl_UINT64_C(c)	CAT2(c,ULL)
#  endif
#  if QUADKIND == QUAD_IS___INT64
#    define PeRl_INT64_C(c)	CAT2(c,I64)
#    define PeRl_UINT64_C(c)	CAT2(c,UI64)
#  endif
#  ifndef PeRl_INT64_C
#    define PeRl_INT64_C(c)	((I64)(c)) /* last resort */
#    define PeRl_UINT64_C(c)	((U64)(c))
#  endif
/* In OS X the INT64_C/UINT64_C are defined with LL/ULL, which will
 * not fly with C89-pedantic gcc, so let's undefine them first so that
 * we can redefine them with our native integer preferring versions. */
#  if defined(PERL_DARWIN) && defined(PERL_GCC_PEDANTIC)
#    undef INT64_C
#    undef UINT64_C
#  endif
#  ifndef INT64_C
#    define INT64_C(c) PeRl_INT64_C(c)
#  endif
#  ifndef UINT64_C
#    define UINT64_C(c) PeRl_UINT64_C(c)
#  endif
#endif

#if defined(UINT8_MAX) && defined(INT16_MAX) && defined(INT32_MAX)

/* I8_MAX and I8_MIN constants are not defined, as I8 is an ambiguous type.
   Please search CHAR_MAX in perl.h for further details. */
#define U8_MAX UINT8_MAX
#define U8_MIN UINT8_MIN

#define I16_MAX INT16_MAX
#define I16_MIN INT16_MIN
#define U16_MAX UINT16_MAX
#define U16_MIN UINT16_MIN

#define I32_MAX INT32_MAX
#define I32_MIN INT32_MIN
#ifndef UINT32_MAX_BROKEN /* e.g. HP-UX with gcc messes this up */
#  define U32_MAX UINT32_MAX
#else
#  define U32_MAX 4294967295U
#endif
#define U32_MIN UINT32_MIN

#else

/* I8_MAX and I8_MIN constants are not defined, as I8 is an ambiguous type.
   Please search CHAR_MAX in perl.h for further details. */
#define U8_MAX PERL_UCHAR_MAX
#define U8_MIN PERL_UCHAR_MIN

#define I16_MAX PERL_SHORT_MAX
#define I16_MIN PERL_SHORT_MIN
#define U16_MAX PERL_USHORT_MAX
#define U16_MIN PERL_USHORT_MIN

#if LONGSIZE > 4
# define I32_MAX PERL_INT_MAX
# define I32_MIN PERL_INT_MIN
# define U32_MAX PERL_UINT_MAX
# define U32_MIN PERL_UINT_MIN
#else
# define I32_MAX PERL_LONG_MAX
# define I32_MIN PERL_LONG_MIN
# define U32_MAX PERL_ULONG_MAX
# define U32_MIN PERL_ULONG_MIN
#endif

#endif

/* log(2) is pretty close to  0.30103, just in case anyone is grepping for it */
#define BIT_DIGITS(N)   (((N)*146)/485 + 1)  /* log2(10) =~ 146/485 */
#define TYPE_DIGITS(T)  BIT_DIGITS(sizeof(T) * 8)
#define TYPE_CHARS(T)   (TYPE_DIGITS(T) + 2) /* sign, NUL */

/* Unused by core; should be deprecated */
#define Ctl(ch) ((ch) & 037)

/* This is a helper macro to avoid preprocessor issues, replaced by nothing
 * unless under DEBUGGING, where it expands to an assert of its argument,
 * followed by a comma (hence the comma operator).  If we just used a straight
 * assert(), we would get a comma with nothing before it when not DEBUGGING.
 *
 * We also use empty definition under Coverity since the __ASSERT__
 * checks often check for things that Really Cannot Happen, and Coverity
 * detects that and gets all excited. */

#if defined(DEBUGGING) && !defined(__COVERITY__)
#   define __ASSERT_(statement)  assert(statement),
#else
#   define __ASSERT_(statement)
#endif

/*
=head1 SV-Body Allocation

=for apidoc Ama|SV*|newSVpvs|const char* s
Like C<newSVpvn>, but takes a C<NUL>-terminated literal string instead of a
string/length pair.

=for apidoc Ama|SV*|newSVpvs_flags|const char* s|U32 flags
Like C<newSVpvn_flags>, but takes a C<NUL>-terminated literal string instead of
a string/length pair.

=for apidoc Ama|SV*|newSVpvs_share|const char* s
Like C<newSVpvn_share>, but takes a C<NUL>-terminated literal string instead of
a string/length pair and omits the hash parameter.

=for apidoc Am|void|sv_catpvs_flags|SV* sv|const char* s|I32 flags
Like C<sv_catpvn_flags>, but takes a C<NUL>-terminated literal string instead
of a string/length pair.

=for apidoc Am|void|sv_catpvs_nomg|SV* sv|const char* s
Like C<sv_catpvn_nomg>, but takes a C<NUL>-terminated literal string instead of
a string/length pair.

=for apidoc Am|void|sv_catpvs|SV* sv|const char* s
Like C<sv_catpvn>, but takes a C<NUL>-terminated literal string instead of a
string/length pair.

=for apidoc Am|void|sv_catpvs_mg|SV* sv|const char* s
Like C<sv_catpvn_mg>, but takes a C<NUL>-terminated literal string instead of a
string/length pair.

=for apidoc Am|void|sv_setpvs|SV* sv|const char* s
Like C<sv_setpvn>, but takes a C<NUL>-terminated literal string instead of a
string/length pair.

=for apidoc Am|void|sv_setpvs_mg|SV* sv|const char* s
Like C<sv_setpvn_mg>, but takes a C<NUL>-terminated literal string instead of a
string/length pair.

=for apidoc Am|SV *|sv_setref_pvs|const char* s
Like C<sv_setref_pvn>, but takes a C<NUL>-terminated literal string instead of
a string/length pair.

=head1 Memory Management

=for apidoc Ama|char*|savepvs|const char* s
Like C<savepvn>, but takes a C<NUL>-terminated literal string instead of a
string/length pair.

=for apidoc Ama|char*|savesharedpvs|const char* s
A version of C<savepvs()> which allocates the duplicate string in memory
which is shared between threads.

=head1 GV Functions

=for apidoc Am|HV*|gv_stashpvs|const char* name|I32 create
Like C<gv_stashpvn>, but takes a C<NUL>-terminated literal string instead of a
string/length pair.

=head1 Hash Manipulation Functions

=for apidoc Am|SV**|hv_fetchs|HV* tb|const char* key|I32 lval
Like C<hv_fetch>, but takes a C<NUL>-terminated literal string instead of a
string/length pair.

=for apidoc Am|SV**|hv_stores|HV* tb|const char* key|NULLOK SV* val
Like C<hv_store>, but takes a C<NUL>-terminated literal string instead of a
string/length pair
and omits the hash parameter.

=head1 Lexer interface

=for apidoc Amx|void|lex_stuff_pvs|const char *pv|U32 flags

Like L</lex_stuff_pvn>, but takes a C<NUL>-terminated literal string instead of
a string/length pair.

=cut
*/

/* concatenating with "" ensures that only literal strings are accepted as
 * argument */
#define STR_WITH_LEN(s)  ("" s ""), (sizeof(s)-1)

/* note that STR_WITH_LEN() can't be used as argument to macros or functions
 * that under some configurations might be macros, which means that it requires
 * the full Perl_xxx(aTHX_ ...) form for any API calls where it's used.
 */

/* STR_WITH_LEN() shortcuts */
#define newSVpvs(str) Perl_newSVpvn(aTHX_ STR_WITH_LEN(str))
#define newSVpvs_flags(str,flags)	\
    Perl_newSVpvn_flags(aTHX_ STR_WITH_LEN(str), flags)
#define newSVpvs_share(str) Perl_newSVpvn_share(aTHX_ STR_WITH_LEN(str), 0)
#define sv_catpvs_flags(sv, str, flags) \
    Perl_sv_catpvn_flags(aTHX_ sv, STR_WITH_LEN(str), flags)
#define sv_catpvs_nomg(sv, str) \
    Perl_sv_catpvn_flags(aTHX_ sv, STR_WITH_LEN(str), 0)
#define sv_catpvs(sv, str) \
    Perl_sv_catpvn_flags(aTHX_ sv, STR_WITH_LEN(str), SV_GMAGIC)
#define sv_catpvs_mg(sv, str) \
    Perl_sv_catpvn_flags(aTHX_ sv, STR_WITH_LEN(str), SV_GMAGIC|SV_SMAGIC)
#define sv_setpvs(sv, str) Perl_sv_setpvn(aTHX_ sv, STR_WITH_LEN(str))
#define sv_setpvs_mg(sv, str) Perl_sv_setpvn_mg(aTHX_ sv, STR_WITH_LEN(str))
#define sv_setref_pvs(rv, classname, str) \
    Perl_sv_setref_pvn(aTHX_ rv, classname, STR_WITH_LEN(str))
#define savepvs(str) Perl_savepvn(aTHX_ STR_WITH_LEN(str))
#define savesharedpvs(str) Perl_savesharedpvn(aTHX_ STR_WITH_LEN(str))
#define gv_stashpvs(str, create) \
    Perl_gv_stashpvn(aTHX_ STR_WITH_LEN(str), create)
#define gv_fetchpvs(namebeg, add, sv_type) \
    Perl_gv_fetchpvn_flags(aTHX_ STR_WITH_LEN(namebeg), add, sv_type)
#define gv_fetchpvn(namebeg, len, add, sv_type) \
    Perl_gv_fetchpvn_flags(aTHX_ namebeg, len, add, sv_type)
#define sv_catxmlpvs(dsv, str, utf8) \
    Perl_sv_catxmlpvn(aTHX_ dsv, STR_WITH_LEN(str), utf8)
#define hv_fetchs(hv,key,lval)						\
  ((SV **)Perl_hv_common(aTHX_ (hv), NULL, STR_WITH_LEN(key), 0,	\
			 (lval) ? (HV_FETCH_JUST_SV | HV_FETCH_LVALUE)	\
			 : HV_FETCH_JUST_SV, NULL, 0))

#define hv_stores(hv,key,val)						\
  ((SV **)Perl_hv_common(aTHX_ (hv), NULL, STR_WITH_LEN(key), 0,	\
			 (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), (val), 0))

#define lex_stuff_pvs(pv,flags) Perl_lex_stuff_pvn(aTHX_ STR_WITH_LEN(pv), flags)

#define get_cvs(str, flags)					\
	Perl_get_cvn_flags(aTHX_ STR_WITH_LEN(str), (flags))

/*
=head1 Miscellaneous Functions

=for apidoc Am|bool|strNE|char* s1|char* s2
Test two C<NUL>-terminated strings to see if they are different.  Returns true
or false.

=for apidoc Am|bool|strEQ|char* s1|char* s2
Test two C<NUL>-terminated strings to see if they are equal.  Returns true or
false.

=for apidoc Am|bool|strLT|char* s1|char* s2
Test two C<NUL>-terminated strings to see if the first, C<s1>, is less than the
second, C<s2>.  Returns true or false.

=for apidoc Am|bool|strLE|char* s1|char* s2
Test two C<NUL>-terminated strings to see if the first, C<s1>, is less than or
equal to the second, C<s2>.  Returns true or false.

=for apidoc Am|bool|strGT|char* s1|char* s2
Test two C<NUL>-terminated strings to see if the first, C<s1>, is greater than
the second, C<s2>.  Returns true or false.

=for apidoc Am|bool|strGE|char* s1|char* s2
Test two C<NUL>-terminated strings to see if the first, C<s1>, is greater than
or equal to the second, C<s2>.  Returns true or false.

=for apidoc Am|bool|strnNE|char* s1|char* s2|STRLEN len
Test two C<NUL>-terminated strings to see if they are different.  The C<len>
parameter indicates the number of bytes to compare.  Returns true or false.  (A
wrapper for C<strncmp>).

=for apidoc Am|bool|strnEQ|char* s1|char* s2|STRLEN len
Test two C<NUL>-terminated strings to see if they are equal.  The C<len>
parameter indicates the number of bytes to compare.  Returns true or false.  (A
wrapper for C<strncmp>).

=for apidoc Am|bool|memEQ|char* s1|char* s2|STRLEN len
Test two buffers (which may contain embedded C<NUL> characters, to see if they
are equal.  The C<len> parameter indicates the number of bytes to compare.
Returns zero if equal, or non-zero if non-equal.

=for apidoc Am|bool|memNE|char* s1|char* s2|STRLEN len
Test two buffers (which may contain embedded C<NUL> characters, to see if they
are not equal.  The C<len> parameter indicates the number of bytes to compare.
Returns zero if non-equal, or non-zero if equal.

=cut
*/

#define strNE(s1,s2) (strcmp(s1,s2))
#define strEQ(s1,s2) (!strcmp(s1,s2))
#define strLT(s1,s2) (strcmp(s1,s2) < 0)
#define strLE(s1,s2) (strcmp(s1,s2) <= 0)
#define strGT(s1,s2) (strcmp(s1,s2) > 0)
#define strGE(s1,s2) (strcmp(s1,s2) >= 0)
#define strnNE(s1,s2,l) (strncmp(s1,s2,l))
#define strnEQ(s1,s2,l) (!strncmp(s1,s2,l))

#ifdef HAS_MEMCMP
#  define memNE(s1,s2,l) (memcmp(s1,s2,l))
#  define memEQ(s1,s2,l) (!memcmp(s1,s2,l))
#else
#  define memNE(s1,s2,l) (bcmp(s1,s2,l))
#  define memEQ(s1,s2,l) (!bcmp(s1,s2,l))
#endif

#define memEQs(s1, l, s2) \
	(sizeof(s2)-1 == l && memEQ(s1, ("" s2 ""), (sizeof(s2)-1)))
#define memNEs(s1, l, s2) !memEQs(s1, l, s2)

/*
 * Character classes.
 *
 * Unfortunately, the introduction of locales means that we
 * can't trust isupper(), etc. to tell the truth.  And when
 * it comes to /\w+/ with tainting enabled, we *must* be able
 * to trust our character classes.
 *
 * Therefore, the default tests in the text of Perl will be
 * independent of locale.  Any code that wants to depend on
 * the current locale will use the tests that begin with "lc".
 */

#ifdef HAS_SETLOCALE  /* XXX Is there a better test for this? */
#  ifndef CTYPE256
#    define CTYPE256
#  endif
#endif

/*

=head1 Character classification
This section is about functions (really macros) that classify characters
into types, such as punctuation versus alphabetic, etc.  Most of these are
analogous to regular expression character classes.  (See
L<perlrecharclass/POSIX Character Classes>.)  There are several variants for
each class.  (Not all macros have all variants; each item below lists the
ones valid for it.)  None are affected by C<use bytes>, and only the ones
with C<LC> in the name are affected by the current locale.

The base function, e.g., C<isALPHA()>, takes an octet (either a C<char> or a
C<U8>) as input and returns a boolean as to whether or not the character
represented by that octet is (or on non-ASCII platforms, corresponds to) an
ASCII character in the named class based on platform, Unicode, and Perl rules.
If the input is a number that doesn't fit in an octet, FALSE is returned.

Variant C<isFOO_A> (e.g., C<isALPHA_A()>) is identical to the base function
with no suffix C<"_A">.

Variant C<isFOO_L1> imposes the Latin-1 (or EBCDIC equivlalent) character set
onto the platform.  That is, the code points that are ASCII are unaffected,
since ASCII is a subset of Latin-1.  But the non-ASCII code points are treated
as if they are Latin-1 characters.  For example, C<isWORDCHAR_L1()> will return
true when called with the code point 0xDF, which is a word character in both
ASCII and EBCDIC (though it represents different characters in each).

Variant C<isFOO_uvchr> is like the C<isFOO_L1> variant, but accepts any UV code
point as input.  If the code point is larger than 255, Unicode rules are used
to determine if it is in the character class.  For example,
C<isWORDCHAR_uvchr(0x100)> returns TRUE, since 0x100 is LATIN CAPITAL LETTER A
WITH MACRON in Unicode, and is a word character.

Variant C<isFOO_utf8> is like C<isFOO_uvchr>, but the input is a pointer to a
(known to be well-formed) UTF-8 encoded string (C<U8*> or C<char*>, and
possibly containing embedded C<NUL> characters).  The classification of just
the first (possibly multi-byte) character in the string is tested.

Variant C<isFOO_LC> is like the C<isFOO_A> and C<isFOO_L1> variants, but the
result is based on the current locale, which is what C<LC> in the name stands
for.  If Perl can determine that the current locale is a UTF-8 locale, it uses
the published Unicode rules; otherwise, it uses the C library function that
gives the named classification.  For example, C<isDIGIT_LC()> when not in a
UTF-8 locale returns the result of calling C<isdigit()>.  FALSE is always
returned if the input won't fit into an octet.  On some platforms where the C
library function is known to be defective, Perl changes its result to follow
the POSIX standard's rules.

Variant C<isFOO_LC_uvchr> is like C<isFOO_LC>, but is defined on any UV.  It
returns the same as C<isFOO_LC> for input code points less than 256, and
returns the hard-coded, not-affected-by-locale, Unicode results for larger ones.

Variant C<isFOO_LC_utf8> is like C<isFOO_LC_uvchr>, but the input is a pointer
to a (known to be well-formed) UTF-8 encoded string (C<U8*> or C<char*>, and
possibly containing embedded C<NUL> characters).  The classification of just
the first (possibly multi-byte) character in the string is tested.

=for apidoc Am|bool|isALPHA|char ch
Returns a boolean indicating whether the specified character is an
alphabetic character, analogous to C<m/[[:alpha:]]/>.
See the L<top of this section|/Character classification> for an explanation of
variants
C<isALPHA_A>, C<isALPHA_L1>, C<isALPHA_uvchr>, C<isALPHA_utf8>, C<isALPHA_LC>,
C<isALPHA_LC_uvchr>, and C<isALPHA_LC_utf8>.

=for apidoc Am|bool|isALPHANUMERIC|char ch
Returns a boolean indicating whether the specified character is a either an
alphabetic character or decimal digit, analogous to C<m/[[:alnum:]]/>.
See the L<top of this section|/Character classification> for an explanation of
variants
C<isALPHANUMERIC_A>, C<isALPHANUMERIC_L1>, C<isALPHANUMERIC_uvchr>,
C<isALPHANUMERIC_utf8>, C<isALPHANUMERIC_LC>, C<isALPHANUMERIC_LC_uvchr>, and
C<isALPHANUMERIC_LC_utf8>.

=for apidoc Am|bool|isASCII|char ch
Returns a boolean indicating whether the specified character is one of the 128
characters in the ASCII character set, analogous to C<m/[[:ascii:]]/>.
On non-ASCII platforms, it returns TRUE iff this
character corresponds to an ASCII character.  Variants C<isASCII_A()> and
C<isASCII_L1()> are identical to C<isASCII()>.
See the L<top of this section|/Character classification> for an explanation of
variants
C<isASCII_uvchr>, C<isASCII_utf8>, C<isASCII_LC>, C<isASCII_LC_uvchr>, and
C<isASCII_LC_utf8>.  Note, however, that some platforms do not have the C
library routine C<isascii()>.  In these cases, the variants whose names contain
C<LC> are the same as the corresponding ones without.

Also note, that because all ASCII characters are UTF-8 invariant (meaning they
have the exact same representation (always a single byte) whether encoded in
UTF-8 or not), C<isASCII> will give the correct results when called with any
byte in any string encoded or not in UTF-8.  And similarly C<isASCII_utf8> will
work properly on any string encoded or not in UTF-8.

=for apidoc Am|bool|isBLANK|char ch
Returns a boolean indicating whether the specified character is a
character considered to be a blank, analogous to C<m/[[:blank:]]/>.
See the L<top of this section|/Character classification> for an explanation of
variants
C<isBLANK_A>, C<isBLANK_L1>, C<isBLANK_uvchr>, C<isBLANK_utf8>, C<isBLANK_LC>,
C<isBLANK_LC_uvchr>, and C<isBLANK_LC_utf8>.  Note, however, that some
platforms do not have the C library routine C<isblank()>.  In these cases, the
variants whose names contain C<LC> are the same as the corresponding ones
without.

=for apidoc Am|bool|isCNTRL|char ch
Returns a boolean indicating whether the specified character is a
control character, analogous to C<m/[[:cntrl:]]/>.
See the L<top of this section|/Character classification> for an explanation of
variants
C<isCNTRL_A>, C<isCNTRL_L1>, C<isCNTRL_uvchr>, C<isCNTRL_utf8>, C<isCNTRL_LC>,
C<isCNTRL_LC_uvchr>, and C<isCNTRL_LC_utf8>
On EBCDIC platforms, you almost always want to use the C<isCNTRL_L1> variant.

=for apidoc Am|bool|isDIGIT|char ch
Returns a boolean indicating whether the specified character is a
digit, analogous to C<m/[[:digit:]]/>.
Variants C<isDIGIT_A> and C<isDIGIT_L1> are identical to C<isDIGIT>.
See the L<top of this section|/Character classification> for an explanation of
variants
C<isDIGIT_uvchr>, C<isDIGIT_utf8>, C<isDIGIT_LC>, C<isDIGIT_LC_uvchr>, and
C<isDIGIT_LC_utf8>.

=for apidoc Am|bool|isGRAPH|char ch
Returns a boolean indicating whether the specified character is a
graphic character, analogous to C<m/[[:graph:]]/>.
See the L<top of this section|/Character classification> for an explanation of
variants
C<isGRAPH_A>, C<isGRAPH_L1>, C<isGRAPH_uvchr>, C<isGRAPH_utf8>, C<isGRAPH_LC>,
C<isGRAPH_LC_uvchr>, and C<isGRAPH_LC_utf8>.

=for apidoc Am|bool|isLOWER|char ch
Returns a boolean indicating whether the specified character is a
lowercase character, analogous to C<m/[[:lower:]]/>.
See the L<top of this section|/Character classification> for an explanation of
variants
C<isLOWER_A>, C<isLOWER_L1>, C<isLOWER_uvchr>, C<isLOWER_utf8>, C<isLOWER_LC>,
C<isLOWER_LC_uvchr>, and C<isLOWER_LC_utf8>.

=for apidoc Am|bool|isOCTAL|char ch
Returns a boolean indicating whether the specified character is an
octal digit, [0-7].
The only two variants are C<isOCTAL_A> and C<isOCTAL_L1>; each is identical to
C<isOCTAL>.

=for apidoc Am|bool|isPUNCT|char ch
Returns a boolean indicating whether the specified character is a
punctuation character, analogous to C<m/[[:punct:]]/>.
Note that the definition of what is punctuation isn't as
straightforward as one might desire.  See L<perlrecharclass/POSIX Character
Classes> for details.
See the L<top of this section|/Character classification> for an explanation of
variants
C<isPUNCT_A>, C<isPUNCT_L1>, C<isPUNCT_uvchr>, C<isPUNCT_utf8>, C<isPUNCT_LC>,
C<isPUNCT_LC_uvchr>, and C<isPUNCT_LC_utf8>.

=for apidoc Am|bool|isSPACE|char ch
Returns a boolean indicating whether the specified character is a
whitespace character.  This is analogous
to what C<m/\s/> matches in a regular expression.  Starting in Perl 5.18
this also matches what C<m/[[:space:]]/> does.  Prior to 5.18, only the
locale forms of this macro (the ones with C<LC> in their names) matched
precisely what C<m/[[:space:]]/> does.  In those releases, the only difference,
in the non-locale variants, was that C<isSPACE()> did not match a vertical tab.
(See L</isPSXSPC> for a macro that matches a vertical tab in all releases.)
See the L<top of this section|/Character classification> for an explanation of
variants
C<isSPACE_A>, C<isSPACE_L1>, C<isSPACE_uvchr>, C<isSPACE_utf8>, C<isSPACE_LC>,
C<isSPACE_LC_uvchr>, and C<isSPACE_LC_utf8>.

=for apidoc Am|bool|isPSXSPC|char ch
(short for Posix Space)
Starting in 5.18, this is identical in all its forms to the
corresponding C<isSPACE()> macros.
The locale forms of this macro are identical to their corresponding
C<isSPACE()> forms in all Perl releases.  In releases prior to 5.18, the
non-locale forms differ from their C<isSPACE()> forms only in that the
C<isSPACE()> forms don't match a Vertical Tab, and the C<isPSXSPC()> forms do.
Otherwise they are identical.  Thus this macro is analogous to what
C<m/[[:space:]]/> matches in a regular expression.
See the L<top of this section|/Character classification> for an explanation of
variants C<isPSXSPC_A>, C<isPSXSPC_L1>, C<isPSXSPC_uvchr>, C<isPSXSPC_utf8>,
C<isPSXSPC_LC>, C<isPSXSPC_LC_uvchr>, and C<isPSXSPC_LC_utf8>.

=for apidoc Am|bool|isUPPER|char ch
Returns a boolean indicating whether the specified character is an
uppercase character, analogous to C<m/[[:upper:]]/>.
See the L<top of this section|/Character classification> for an explanation of
variants
C<isUPPER_A>, C<isUPPER_L1>, C<isUPPER_uvchr>, C<isUPPER_utf8>, C<isUPPER_LC>,
C<isUPPER_LC_uvchr>, and C<isUPPER_LC_utf8>.

=for apidoc Am|bool|isPRINT|char ch
Returns a boolean indicating whether the specified character is a
printable character, analogous to C<m/[[:print:]]/>.
See the L<top of this section|/Character classification> for an explanation of
variants
C<isPRINT_A>, C<isPRINT_L1>, C<isPRINT_uvchr>, C<isPRINT_utf8>, C<isPRINT_LC>,
C<isPRINT_LC_uvchr>, and C<isPRINT_LC_utf8>.

=for apidoc Am|bool|isWORDCHAR|char ch
Returns a boolean indicating whether the specified character is a character
that is a word character, analogous to what C<m/\w/> and C<m/[[:word:]]/> match
in a regular expression.  A word character is an alphabetic character, a
decimal digit, a connecting punctuation character (such as an underscore), or
a "mark" character that attaches to one of those (like some sort of accent).
C<isALNUM()> is a synonym provided for backward compatibility, even though a
word character includes more than the standard C language meaning of
alphanumeric.
See the L<top of this section|/Character classification> for an explanation of
variants
C<isWORDCHAR_A>, C<isWORDCHAR_L1>, C<isWORDCHAR_uvchr>, and C<isWORDCHAR_utf8>.
C<isWORDCHAR_LC>, C<isWORDCHAR_LC_uvchr>, and C<isWORDCHAR_LC_utf8> are also as
described there, but additionally include the platform's native underscore.

=for apidoc Am|bool|isXDIGIT|char ch
Returns a boolean indicating whether the specified character is a hexadecimal
digit.  In the ASCII range these are C<[0-9A-Fa-f]>.  Variants C<isXDIGIT_A()>
and C<isXDIGIT_L1()> are identical to C<isXDIGIT()>.
See the L<top of this section|/Character classification> for an explanation of
variants
C<isXDIGIT_uvchr>, C<isXDIGIT_utf8>, C<isXDIGIT_LC>, C<isXDIGIT_LC_uvchr>, and
C<isXDIGIT_LC_utf8>.

=for apidoc Am|bool|isIDFIRST|char ch
Returns a boolean indicating whether the specified character can be the first
character of an identifier.  This is very close to, but not quite the same as
the official Unicode property C<XID_Start>.  The difference is that this
returns true only if the input character also matches L</isWORDCHAR>.
See the L<top of this section|/Character classification> for an explanation of
variants
C<isIDFIRST_A>, C<isIDFIRST_L1>, C<isIDFIRST_uvchr>, C<isIDFIRST_utf8>,
C<isIDFIRST_LC>, C<isIDFIRST_LC_uvchr>, and C<isIDFIRST_LC_utf8>.

=for apidoc Am|bool|isIDCONT|char ch
Returns a boolean indicating whether the specified character can be the
second or succeeding character of an identifier.  This is very close to, but
not quite the same as the official Unicode property C<XID_Continue>.  The
difference is that this returns true only if the input character also matches
L</isWORDCHAR>.  See the L<top of this section|/Character classification> for
an
explanation of variants C<isIDCONT_A>, C<isIDCONT_L1>, C<isIDCONT_uvchr>,
C<isIDCONT_utf8>, C<isIDCONT_LC>, C<isIDCONT_LC_uvchr>, and
C<isIDCONT_LC_utf8>.

=head1 Miscellaneous Functions

=for apidoc Am|U8|READ_XDIGIT|char str*
Returns the value of an ASCII-range hex digit and advances the string pointer.
Behaviour is only well defined when isXDIGIT(*str) is true.

=head1 Character case changing

=for apidoc Am|U8|toUPPER|U8 ch
Converts the specified character to uppercase.  If the input is anything but an
ASCII lowercase character, that input character itself is returned.  Variant
C<toUPPER_A> is equivalent.

=for apidoc Am|UV|toUPPER_uvchr|UV cp|U8* s|STRLEN* lenp
Converts the code point C<cp> to its uppercase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  The code
point is interpreted as native if less than 256; otherwise as Unicode.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the uppercase version may be longer than the original character.

The first code point of the uppercased version is returned
(but note, as explained just above, that there may be more.)

=for apidoc Am|UV|toUPPER_utf8|U8* p|U8* s|STRLEN* lenp
Converts the UTF-8 encoded character at C<p> to its uppercase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the uppercase version may be longer than the original character.

The first code point of the uppercased version is returned
(but note, as explained just above, that there may be more.)

The input character at C<p> is assumed to be well-formed.

=for apidoc Am|U8|toFOLD|U8 ch
Converts the specified character to foldcase.  If the input is anything but an
ASCII uppercase character, that input character itself is returned.  Variant
C<toFOLD_A> is equivalent.  (There is no equivalent C<to_FOLD_L1> for the full
Latin1 range, as the full generality of L</toFOLD_uvchr> is needed there.)

=for apidoc Am|UV|toFOLD_uvchr|UV cp|U8* s|STRLEN* lenp
Converts the code point C<cp> to its foldcase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  The code
point is interpreted as native if less than 256; otherwise as Unicode.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the foldcase version may be longer than the original character.

The first code point of the foldcased version is returned
(but note, as explained just above, that there may be more.)

=for apidoc Am|UV|toFOLD_utf8|U8* p|U8* s|STRLEN* lenp
Converts the UTF-8 encoded character at C<p> to its foldcase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the foldcase version may be longer than the original character.

The first code point of the foldcased version is returned
(but note, as explained just above, that there may be more.)

The input character at C<p> is assumed to be well-formed.

=for apidoc Am|U8|toLOWER|U8 ch
Converts the specified character to lowercase.  If the input is anything but an
ASCII uppercase character, that input character itself is returned.  Variant
C<toLOWER_A> is equivalent.

=for apidoc Am|U8|toLOWER_L1|U8 ch
Converts the specified Latin1 character to lowercase.  The results are
undefined if the input doesn't fit in a byte.

=for apidoc Am|U8|toLOWER_LC|U8 ch
Converts the specified character to lowercase using the current locale's rules,
if possible; otherwise returns the input character itself.

=for apidoc Am|UV|toLOWER_uvchr|UV cp|U8* s|STRLEN* lenp
Converts the code point C<cp> to its lowercase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  The code
point is interpreted as native if less than 256; otherwise as Unicode.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the lowercase version may be longer than the original character.

The first code point of the lowercased version is returned
(but note, as explained just above, that there may be more.)

=for apidoc Am|UV|toLOWER_utf8|U8* p|U8* s|STRLEN* lenp
Converts the UTF-8 encoded character at C<p> to its lowercase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the lowercase version may be longer than the original character.

The first code point of the lowercased version is returned
(but note, as explained just above, that there may be more.)

The input character at C<p> is assumed to be well-formed.

=for apidoc Am|U8|toTITLE|U8 ch
Converts the specified character to titlecase.  If the input is anything but an
ASCII lowercase character, that input character itself is returned.  Variant
C<toTITLE_A> is equivalent.  (There is no C<toTITLE_L1> for the full Latin1
range, as the full generality of L</toTITLE_uvchr> is needed there.  Titlecase is
not a concept used in locale handling, so there is no functionality for that.)

=for apidoc Am|UV|toTITLE_uvchr|UV cp|U8* s|STRLEN* lenp
Converts the code point C<cp> to its titlecase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  The code
point is interpreted as native if less than 256; otherwise as Unicode.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the titlecase version may be longer than the original character.

The first code point of the titlecased version is returned
(but note, as explained just above, that there may be more.)

=for apidoc Am|UV|toTITLE_utf8|U8* p|U8* s|STRLEN* lenp
Converts the UTF-8 encoded character at C<p> to its titlecase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the titlecase version may be longer than the original character.

The first code point of the titlecased version is returned
(but note, as explained just above, that there may be more.)

The input character at C<p> is assumed to be well-formed.

=cut

XXX Still undocumented isVERTWS_uvchr and _utf8; it's unclear what their names
really should be.  Also toUPPER_LC and toFOLD_LC, which are subject to change.

Note that these macros are repeated in Devel::PPPort, so should also be
patched there.  The file as of this writing is cpan/Devel-PPPort/parts/inc/misc

*/

/* Specify the widest unsigned type on the platform.  Use U64TYPE because U64
 * is known only in the perl core, and this macro can be called from outside
 * that */
#ifdef HAS_QUAD
#   define WIDEST_UTYPE U64TYPE
#else
#   define WIDEST_UTYPE U32
#endif

/* FITS_IN_8_BITS(c) returns true if c doesn't have  a bit set other than in
 * the lower 8.  It is designed to be hopefully bomb-proof, making sure that no
 * bits of information are lost even on a 64-bit machine, but to get the
 * compiler to optimize it out if possible.  This is because Configure makes
 * sure that the machine has an 8-bit byte, so if c is stored in a byte, the
 * sizeof() guarantees that this evaluates to a constant true at compile time.
 *
 * For Coverity, be always true, because otherwise Coverity thinks
 * it finds several expressions that are always true, independent
 * of operands.  Well, they are, but that is kind of the point.
 */
#ifndef __COVERITY__
#define FITS_IN_8_BITS(c) ((sizeof(c) == 1) || !(((WIDEST_UTYPE)(c)) & ~0xFF))
#else
#define FITS_IN_8_BITS(c) (1)
#endif

#ifdef EBCDIC
#   ifndef _ALL_SOURCE
        /* The native libc isascii() et.al. functions return the wrong results
         * on at least z/OS unless this is defined. */
#       error   _ALL_SOURCE should probably be defined
#   endif
#else
    /* There is a simple definition of ASCII for ASCII platforms.  But the
     * EBCDIC one isn't so simple, so is defined using table look-up like the
     * other macros below.
     * The '| 0' part ensures that c is an integer (and not e.g. a pointer) */
#   define isASCII(c)    ((WIDEST_UTYPE)((c) | 0) < 128)
#endif

/* The lower 3 bits in both the ASCII and EBCDIC representations of '0' are 0,
 * and the 8 possible permutations of those bits exactly comprise the 8 octal
 * digits */
#define isOCTAL_A(c)  cBOOL(FITS_IN_8_BITS(c) && (0xF8 & (c)) == '0')

#ifdef H_PERL       /* If have access to perl.h, lookup in its table */

/* Character class numbers.  For internal core Perl use only.  The ones less
 * than 32 are used in PL_charclass[] and the ones up through the one that
 * corresponds to <_HIGHEST_REGCOMP_DOT_H_SYNC> are used by regcomp.h and
 * related files.  PL_charclass ones use names used in l1_char_class_tab.h but
 * their actual definitions are here.  If that file has a name not used here,
 * it won't compile.
 *
 * The first group of these is ordered in what I (khw) estimate to be the
 * frequency of their use.  This gives a slight edge to exiting a loop earlier
 * (in reginclass() in regexec.c) */
#  define _CC_WORDCHAR           0      /* \w and [:word:] */
#  define _CC_DIGIT              1      /* \d and [:digit:] */
#  define _CC_ALPHA              2      /* [:alpha:] */
#  define _CC_LOWER              3      /* [:lower:] */
#  define _CC_UPPER              4      /* [:upper:] */
#  define _CC_PUNCT              5      /* [:punct:] */
#  define _CC_PRINT              6      /* [:print:] */
#  define _CC_ALPHANUMERIC       7      /* [:alnum:] */
#  define _CC_GRAPH              8      /* [:graph:] */
#  define _CC_CASED              9      /* [:lower:] and [:upper:] under /i */

#define _FIRST_NON_SWASH_CC     10
/* The character classes above are implemented with swashes.  The second group
 * (just below) contains the ones implemented without.  These are also sorted
 * in rough order of the frequency of their use, except that \v should be last,
 * as it isn't a real Posix character class, and some (small) inefficiencies in
 * regular expression handling would be introduced by putting it in the middle
 * of those that are.  Also, cntrl and ascii come after the others as it may be
 * useful to group these which have no members that match above Latin1, (or
 * above ASCII in the latter case) */

#  define _CC_SPACE             10      /* \s, [:space:] */
#  define _CC_BLANK             11      /* [:blank:] */
#  define _CC_XDIGIT            12      /* [:xdigit:] */
#  define _CC_CNTRL             13      /* [:cntrl:] */
#  define _CC_ASCII             14      /* [:ascii:] */
#  define _CC_VERTSPACE         15      /* \v */

#  define _HIGHEST_REGCOMP_DOT_H_SYNC _CC_VERTSPACE

/* The members of the third group below do not need to be coordinated with data
 * structures in regcomp.[ch] and regexec.c. */
#  define _CC_IDFIRST                  16
#  define _CC_CHARNAME_CONT            17
#  define _CC_NONLATIN1_FOLD           18
#  define _CC_NONLATIN1_SIMPLE_FOLD    19
#  define _CC_QUOTEMETA                20
#  define _CC_NON_FINAL_FOLD           21
#  define _CC_IS_IN_SOME_FOLD          22
#  define _CC_MNEMONIC_CNTRL           23

/* This next group is only used on EBCDIC platforms, so theoretically could be
 * shared with something entirely different that's only on ASCII platforms */
#  define _CC_UTF8_START_BYTE_IS_FOR_AT_LEAST_SURROGATE 28
#  define _CC_UTF8_IS_START                             29
#  define _CC_UTF8_IS_DOWNGRADEABLE_START               30
#  define _CC_UTF8_IS_CONTINUATION                      31
/* Unused: 24-27
 * If more bits are needed, one could add a second word for non-64bit
 * QUAD_IS_INT systems, using some #ifdefs to distinguish between having a 2nd
 * word or not.  The IS_IN_SOME_FOLD bit is the most easily expendable, as it
 * is used only for optimization (as of this writing), and differs in the
 * Latin1 range from the ALPHA bit only in two relatively unimportant
 * characters: the masculine and feminine ordinal indicators, so removing it
 * would just cause /i regexes which match them to run less efficiently.
 * Similarly the EBCDIC-only bits are used just for speed, and could be
 * replaced by other means */

#if defined(PERL_CORE) || defined(PERL_EXT)
/* An enum version of the character class numbers, to help compilers
 * optimize */
typedef enum {
    _CC_ENUM_ALPHA          = _CC_ALPHA,
    _CC_ENUM_ALPHANUMERIC   = _CC_ALPHANUMERIC,
    _CC_ENUM_ASCII          = _CC_ASCII,
    _CC_ENUM_BLANK          = _CC_BLANK,
    _CC_ENUM_CASED          = _CC_CASED,
    _CC_ENUM_CNTRL          = _CC_CNTRL,
    _CC_ENUM_DIGIT          = _CC_DIGIT,
    _CC_ENUM_GRAPH          = _CC_GRAPH,
    _CC_ENUM_LOWER          = _CC_LOWER,
    _CC_ENUM_PRINT          = _CC_PRINT,
    _CC_ENUM_PUNCT          = _CC_PUNCT,
    _CC_ENUM_SPACE          = _CC_SPACE,
    _CC_ENUM_UPPER          = _CC_UPPER,
    _CC_ENUM_VERTSPACE      = _CC_VERTSPACE,
    _CC_ENUM_WORDCHAR       = _CC_WORDCHAR,
    _CC_ENUM_XDIGIT         = _CC_XDIGIT
} _char_class_number;
#endif

#define POSIX_SWASH_COUNT _FIRST_NON_SWASH_CC
#define POSIX_CC_COUNT    (_HIGHEST_REGCOMP_DOT_H_SYNC + 1)

#if defined(PERL_IN_UTF8_C)                         \
 || defined(PERL_IN_REGCOMP_C)                      \
 || defined(PERL_IN_REGEXEC_C)
#   if _CC_WORDCHAR != 0 || _CC_DIGIT != 1 || _CC_ALPHA != 2 || _CC_LOWER != 3 \
       || _CC_UPPER != 4 || _CC_PUNCT != 5 || _CC_PRINT != 6                   \
       || _CC_ALPHANUMERIC != 7 || _CC_GRAPH != 8 || _CC_CASED != 9
      #error Need to adjust order of swash_property_names[]
#   endif

/* This is declared static in each of the few files that this is #defined for
 * to keep them from being publicly accessible.  Hence there is a small amount
 * of wasted space */

static const char* const swash_property_names[] = {
    "XPosixWord",
    "XPosixDigit",
    "XPosixAlpha",
    "XPosixLower",
    "XPosixUpper",
    "XPosixPunct",
    "XPosixPrint",
    "XPosixAlnum",
    "XPosixGraph",
    "Cased"
};
#endif

START_EXTERN_C
#  ifdef DOINIT
EXTCONST  U32 PL_charclass[] = {
#    include "l1_char_class_tab.h"
};

#  else /* ! DOINIT */
EXTCONST U32 PL_charclass[];
#  endif
END_EXTERN_C

    /* The 1U keeps Solaris from griping when shifting sets the uppermost bit */
#   define _CC_mask(classnum) (1U << (classnum))

    /* For internal core Perl use only: the base macro for defining macros like
     * isALPHA */
#   define _generic_isCC(c, classnum) cBOOL(FITS_IN_8_BITS(c)    \
                && (PL_charclass[(U8) (c)] & _CC_mask(classnum)))

    /* The mask for the _A versions of the macros; it just adds in the bit for
     * ASCII. */
#   define _CC_mask_A(classnum) (_CC_mask(classnum) | _CC_mask(_CC_ASCII))

    /* For internal core Perl use only: the base macro for defining macros like
     * isALPHA_A.  The foo_A version makes sure that both the desired bit and
     * the ASCII bit are present */
#   define _generic_isCC_A(c, classnum) (FITS_IN_8_BITS(c)      \
        && ((PL_charclass[(U8) (c)] & _CC_mask_A(classnum))     \
                                   == _CC_mask_A(classnum)))

#   define isALPHA_A(c)  _generic_isCC_A(c, _CC_ALPHA)
#   define isALPHANUMERIC_A(c) _generic_isCC_A(c, _CC_ALPHANUMERIC)
#   define isBLANK_A(c)  _generic_isCC_A(c, _CC_BLANK)
#   define isCNTRL_A(c)  _generic_isCC_A(c, _CC_CNTRL)
#   define isDIGIT_A(c)  _generic_isCC(c, _CC_DIGIT) /* No non-ASCII digits */
#   define isGRAPH_A(c)  _generic_isCC_A(c, _CC_GRAPH)
#   define isLOWER_A(c)  _generic_isCC_A(c, _CC_LOWER)
#   define isPRINT_A(c)  _generic_isCC_A(c, _CC_PRINT)
#   define isPUNCT_A(c)  _generic_isCC_A(c, _CC_PUNCT)
#   define isSPACE_A(c)  _generic_isCC_A(c, _CC_SPACE)
#   define isUPPER_A(c)  _generic_isCC_A(c, _CC_UPPER)
#   define isWORDCHAR_A(c) _generic_isCC_A(c, _CC_WORDCHAR)
#   define isXDIGIT_A(c)  _generic_isCC(c, _CC_XDIGIT) /* No non-ASCII xdigits
                                                        */
#   define isIDFIRST_A(c) _generic_isCC_A(c, _CC_IDFIRST)
#   define isALPHA_L1(c)  _generic_isCC(c, _CC_ALPHA)
#   define isALPHANUMERIC_L1(c) _generic_isCC(c, _CC_ALPHANUMERIC)
#   define isBLANK_L1(c)  _generic_isCC(c, _CC_BLANK)

    /* continuation character for legal NAME in \N{NAME} */
#   define isCHARNAME_CONT(c) _generic_isCC(c, _CC_CHARNAME_CONT)

#   define isCNTRL_L1(c)  _generic_isCC(c, _CC_CNTRL)
#   define isGRAPH_L1(c)  _generic_isCC(c, _CC_GRAPH)
#   define isLOWER_L1(c)  _generic_isCC(c, _CC_LOWER)
#   define isPRINT_L1(c)  _generic_isCC(c, _CC_PRINT)
#   define isPSXSPC_L1(c)  isSPACE_L1(c)
#   define isPUNCT_L1(c)  _generic_isCC(c, _CC_PUNCT)
#   define isSPACE_L1(c)  _generic_isCC(c, _CC_SPACE)
#   define isUPPER_L1(c)  _generic_isCC(c, _CC_UPPER)
#   define isWORDCHAR_L1(c) _generic_isCC(c, _CC_WORDCHAR)
#   define isIDFIRST_L1(c) _generic_isCC(c, _CC_IDFIRST)

#   ifdef EBCDIC
#       define isASCII(c) _generic_isCC(c, _CC_ASCII)
#   endif

    /* Participates in a single-character fold with a character above 255 */
#   define _HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(c) ((! cBOOL(FITS_IN_8_BITS(c))) || (PL_charclass[(U8) (c)] & _CC_mask(_CC_NONLATIN1_SIMPLE_FOLD)))

    /* Like the above, but also can be part of a multi-char fold */
#   define _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(c) ((! cBOOL(FITS_IN_8_BITS(c))) || (PL_charclass[(U8) (c)] & _CC_mask(_CC_NONLATIN1_FOLD)))

#   define _isQUOTEMETA(c) _generic_isCC(c, _CC_QUOTEMETA)
#   define _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c) \
                                           _generic_isCC(c, _CC_NON_FINAL_FOLD)
#   define _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c) \
                                           _generic_isCC(c, _CC_IS_IN_SOME_FOLD)
#   define _IS_MNEMONIC_CNTRL_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c) \
                                            _generic_isCC(c, _CC_MNEMONIC_CNTRL)
#else   /* else we don't have perl.h H_PERL */

    /* If we don't have perl.h, we are compiling a utility program.  Below we
     * hard-code various macro definitions that wouldn't otherwise be available
     * to it. Most are coded based on first principals.  First some ones common
     * to both ASCII and EBCDIC */
#   define isDIGIT_A(c)  ((c) <= '9' && (c) >= '0')
#   define isBLANK_A(c)  ((c) == ' ' || (c) == '\t')
#   define isSPACE_A(c)  (isBLANK_A(c)                                       \
                          || (c) == '\n'                                     \
                          || (c) == '\r'                                     \
                          || (c) == '\v'                                     \
                          || (c) == '\f')
#   ifdef EBCDIC    /* There are gaps between 'i' and 'j'; 'r' and 's'.  Same
                       for uppercase.  This is ordered to exclude most things
                       early */
#       define isLOWER_A(c)  ((c) >= 'a' && (c) <= 'z'                       \
                               && ((c) <= 'i'                                \
                                   || ((c) >= 'j' && (c) <= 'r')             \
                                   || (c) >= 's'))
#       define isUPPER_A(c)  ((c) >= 'A' && (c) <= 'Z'                       \
                               && ((c) <= 'I'                                \
                                   || ((c) >= 'J' && (c) <= 'R')             \
                                   || (c) >= 'S'))
#   else   /* ASCII platform. */
#       define isLOWER_A(c)  ((c) >= 'a' && (c) <= 'z')
#       define isUPPER_A(c)  ((c) <= 'Z' && (c) >= 'A')
#   endif

    /* Some more ASCII, non-ASCII common definitions */
#   define isALPHA_A(c)  (isUPPER_A(c) || isLOWER_A(c))
#   define isALPHANUMERIC_A(c) (isALPHA_A(c) || isDIGIT_A(c))
#   define isWORDCHAR_A(c)   (isALPHANUMERIC_A(c) || (c) == '_')
#   define isIDFIRST_A(c)    (isALPHA_A(c) || (c) == '_')
#   define isXDIGIT_A(c) (isDIGIT_A(c)                                      \
                          || ((c) >= 'a' && (c) <= 'f')                     \
                          || ((c) <= 'F' && (c) >= 'A'))

#   ifdef EBCDIC
#       define isPUNCT_A(c)  ((c) == '-' || (c) == '!' || (c) == '"'        \
                           || (c) == '#' || (c) == '$' || (c) == '%'        \
                           || (c) == '&' || (c) == '\'' || (c) == '('       \
                           || (c) == ')' || (c) == '*' || (c) == '+'        \
                           || (c) == ',' || (c) == '.' || (c) == '/'        \
                           || (c) == ':' || (c) == ';' || (c) == '<'        \
                           || (c) == '=' || (c) == '>' || (c) == '?'        \
                           || (c) == '@@' || (c) == '[' || (c) == '\\'       \
                           || (c) == ']' || (c) == '^' || (c) == '_'        \
                           || (c) == '`' || (c) == '{' || (c) == '|'        \
                           || (c) == '}' || (c) == '~')
#       define isGRAPH_A(c)  (isALPHANUMERIC_A(c) || isPUNCT_A(c))
#       define isPRINT_A(c)  (isGRAPH_A(c) || (c) == ' ')

#       ifdef QUESTION_MARK_CTRL
#           define _isQMC(c) ((c) == QUESTION_MARK_CTRL)
#       else
#           define _isQMC(c) 0
#       endif

        /* I (khw) can't think of a way to define all the ASCII controls
         * without resorting to a libc (locale-sensitive) call.  But we know
         * that all controls but the question-mark one are in the range 0-0x3f.
         * This makes sure that all the controls that have names are included,
         * and all controls that are also considered ASCII in the locale.  This
         * may include more or fewer than what it actually should, but the
         * wrong ones are less-important controls, so likely won't impact
         * things (keep in mind that this is compiled only if perl.h isn't
         * available).  The question mark control is included if available */
#       define isCNTRL_A(c)  (((c) < 0x40 && isascii(c))                    \
                            || (c) == '\0' || (c) == '\a' || (c) == '\b'    \
                            || (c) == '\f' || (c) == '\n' || (c) == '\r'    \
                            || (c) == '\t' || (c) == '\v' || _isQMC(c))

#       define isASCII(c)    (isCNTRL_A(c) || isPRINT_A(c))
#   else    /* ASCII platform; things are simpler, and  isASCII has already
               been defined */
#       define isGRAPH_A(c)  (((c) > ' ' && (c) < 127))
#       define isPRINT_A(c)  (isGRAPH_A(c) || (c) == ' ')
#       define isPUNCT_A(c)  (isGRAPH_A(c) && (! isALPHANUMERIC_A(c)))
#       define isCNTRL_A(c)  (isASCII(c) && (! isPRINT_A(c)))
#   endif

    /* The _L1 macros may be unnecessary for the utilities; I (khw) added them
     * during debugging, and it seems best to keep them.  We may be called
     * without NATIVE_TO_LATIN1 being defined.  On ASCII platforms, it doesn't
     * do anything anyway, so make it not a problem */
#   if ! defined(EBCDIC) && ! defined(NATIVE_TO_LATIN1)
#       define NATIVE_TO_LATIN1(ch) (ch)
#   endif
#   define isALPHA_L1(c)     (isUPPER_L1(c) || isLOWER_L1(c))
#   define isALPHANUMERIC_L1(c) (isALPHA_L1(c) || isDIGIT_A(c))
#   define isBLANK_L1(c)     (isBLANK_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && NATIVE_TO_LATIN1((U8) c) == 0xA0))
#   define isCNTRL_L1(c)     (FITS_IN_8_BITS(c) && (! isPRINT_L1(c)))
#   define isGRAPH_L1(c)     (isPRINT_L1(c) && (! isBLANK_L1(c)))
#   define isLOWER_L1(c)     (isLOWER_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && ((NATIVE_TO_LATIN1((U8) c) >= 0xDF      \
                                       && NATIVE_TO_LATIN1((U8) c) != 0xF7)  \
                                       || NATIVE_TO_LATIN1((U8) c) == 0xAA   \
                                       || NATIVE_TO_LATIN1((U8) c) == 0xBA   \
                                       || NATIVE_TO_LATIN1((U8) c) == 0xB5)))
#   define isPRINT_L1(c)     (isPRINT_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && NATIVE_TO_LATIN1((U8) c) >= 0xA0))
#   define isPUNCT_L1(c)     (isPUNCT_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && (NATIVE_TO_LATIN1((U8) c) == 0xA1       \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xA7    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xAB    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xB6    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xB7    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xBB    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xBF)))
#   define isSPACE_L1(c)     (isSPACE_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && (NATIVE_TO_LATIN1((U8) c) == 0x85       \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xA0)))
#   define isUPPER_L1(c)     (isUPPER_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && (NATIVE_TO_LATIN1((U8) c) >= 0xC0       \
                                      && NATIVE_TO_LATIN1((U8) c) <= 0xDE    \
                                      && NATIVE_TO_LATIN1((U8) c) != 0xD7)))
#   define isWORDCHAR_L1(c)  (isIDFIRST_L1(c) || isDIGIT_A(c))
#   define isIDFIRST_L1(c)   (isALPHA_L1(c) || NATIVE_TO_LATIN1(c) == '_')
#   define isCHARNAME_CONT(c) (isWORDCHAR_L1(c)                              \
                               || isBLANK_L1(c)                              \
                               || (c) == '-'                                 \
                               || (c) == '('                                 \
                               || (c) == ')')
    /* The following are not fully accurate in the above-ASCII range.  I (khw)
     * don't think it's necessary to be so for the purposes where this gets
     * compiled */
#   define _isQUOTEMETA(c)      (FITS_IN_8_BITS(c) && ! isWORDCHAR_L1(c))
#   define _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c) isALPHA_L1(c)

    /*  And these aren't accurate at all.  They are useful only for above
     *  Latin1, which utilities and bootstrapping don't deal with */
#   define _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c) 0
#   define _HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(c) 0
#   define _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(c) 0

    /* Many of the macros later in this file are defined in terms of these.  By
     * implementing them with a function, which converts the class number into
     * a call to the desired macro, all of the later ones work.  However, that
     * function won't be actually defined when building a utility program (no
     * perl.h), and so a compiler error will be generated if one is attempted
     * to be used.  And the above-Latin1 code points require Unicode tables to
     * be present, something unlikely to be the case when bootstrapping */
#   define _generic_isCC(c, classnum)                                        \
         (FITS_IN_8_BITS(c) && S_bootstrap_ctype((U8) (c), (classnum), TRUE))
#   define _generic_isCC_A(c, classnum)                                      \
         (FITS_IN_8_BITS(c) && S_bootstrap_ctype((U8) (c), (classnum), FALSE))
#endif  /* End of no perl.h H_PERL */

#define isALPHANUMERIC(c)  isALPHANUMERIC_A(c)
#define isALPHA(c)   isALPHA_A(c)
#define isASCII_A(c)  isASCII(c)
#define isASCII_L1(c)  isASCII(c)
#define isBLANK(c)   isBLANK_A(c)
#define isCNTRL(c)   isCNTRL_A(c)
#define isDIGIT(c)   isDIGIT_A(c)
#define isGRAPH(c)   isGRAPH_A(c)
#define isIDFIRST(c) isIDFIRST_A(c)
#define isLOWER(c)   isLOWER_A(c)
#define isPRINT(c)   isPRINT_A(c)
#define isPSXSPC_A(c) isSPACE_A(c)
#define isPSXSPC(c)  isPSXSPC_A(c)
#define isPSXSPC_L1(c) isSPACE_L1(c)
#define isPUNCT(c)   isPUNCT_A(c)
#define isSPACE(c)   isSPACE_A(c)
#define isUPPER(c)   isUPPER_A(c)
#define isWORDCHAR(c) isWORDCHAR_A(c)
#define isXDIGIT(c)  isXDIGIT_A(c)

/* ASCII casing.  These could also be written as
    #define toLOWER(c) (isASCII(c) ? toLOWER_LATIN1(c) : (c))
    #define toUPPER(c) (isASCII(c) ? toUPPER_LATIN1_MOD(c) : (c))
   which uses table lookup and mask instead of subtraction.  (This would
   work because the _MOD does not apply in the ASCII range) */
#define toLOWER(c)  (isUPPER(c) ? (U8)((c) + ('a' - 'A')) : (c))
#define toUPPER(c)  (isLOWER(c) ? (U8)((c) - ('a' - 'A')) : (c))

/* In the ASCII range, these are equivalent to what they're here defined to be.
 * But by creating these definitions, other code doesn't have to be aware of
 * this detail */
#define toFOLD(c)    toLOWER(c)
#define toTITLE(c)   toUPPER(c)

#define toLOWER_A(c) toLOWER(c)
#define toUPPER_A(c) toUPPER(c)
#define toFOLD_A(c)  toFOLD(c)
#define toTITLE_A(c) toTITLE(c)

/* Use table lookup for speed; returns the input itself if is out-of-range */
#define toLOWER_LATIN1(c)    ((! FITS_IN_8_BITS(c))                        \
                             ? (c)                                         \
                             : PL_latin1_lc[ (U8) (c) ])
#define toLOWER_L1(c)    toLOWER_LATIN1(c)  /* Synonym for consistency */

/* Modified uc.  Is correct uc except for three non-ascii chars which are
 * all mapped to one of them, and these need special handling; returns the
 * input itself if is out-of-range */
#define toUPPER_LATIN1_MOD(c) ((! FITS_IN_8_BITS(c))                       \
                               ? (c)                                       \
                               : PL_mod_latin1_uc[ (U8) (c) ])
#define IN_UTF8_CTYPE_LOCALE PL_in_utf8_CTYPE_locale

/* Use foo_LC_uvchr() instead  of these for beyond the Latin1 range */

/* For internal core Perl use only: the base macro for defining macros like
 * isALPHA_LC, which uses the current LC_CTYPE locale.  'c' is the code point
 * (0-255) to check.  In a UTF-8 locale, the result is the same as calling
 * isFOO_L1(); the 'utf8_locale_classnum' parameter is something like
 * _CC_UPPER, which gives the class number for doing this.  For non-UTF-8
 * locales, the code to actually do the test this is passed in 'non_utf8'.  If
 * 'c' is above 255, 0 is returned.  For accessing the full range of possible
 * code points under locale rules, use the macros based on _generic_LC_uvchr
 * instead of this. */
#define _generic_LC_base(c, utf8_locale_classnum, non_utf8)                    \
           (! FITS_IN_8_BITS(c)                                                \
           ? 0                                                                 \
           : IN_UTF8_CTYPE_LOCALE                                              \
             ? cBOOL(PL_charclass[(U8) (c)] & _CC_mask(utf8_locale_classnum))  \
             : cBOOL(non_utf8))

/* For internal core Perl use only: a helper macro for defining macros like
 * isALPHA_LC.  'c' is the code point (0-255) to check.  The function name to
 * actually do this test is passed in 'non_utf8_func', which is called on 'c',
 * casting 'c' to the macro _LC_CAST, which should not be parenthesized.  See
 * _generic_LC_base for more info */
#define _generic_LC(c, utf8_locale_classnum, non_utf8_func)                    \
                        _generic_LC_base(c,utf8_locale_classnum,               \
                                         non_utf8_func( (_LC_CAST) (c)))

/* For internal core Perl use only: like _generic_LC, but also returns TRUE if
 * 'c' is the platform's native underscore character */
#define _generic_LC_underscore(c,utf8_locale_classnum,non_utf8_func)           \
                        _generic_LC_base(c, utf8_locale_classnum,              \
                                         (non_utf8_func( (_LC_CAST) (c))       \
                                          || (char)(c) == '_'))

/* These next three are also for internal core Perl use only: case-change
 * helper macros */
#define _generic_toLOWER_LC(c, function, cast)  (! FITS_IN_8_BITS(c)           \
                                                ? (c)                          \
                                                : (IN_UTF8_CTYPE_LOCALE)       \
                                                  ? PL_latin1_lc[ (U8) (c) ]   \
                                                : (cast)function((cast)(c)))

/* Note that the result can be larger than a byte in a UTF-8 locale.  It
 * returns a single value, so can't adequately return the upper case of LATIN
 * SMALL LETTER SHARP S in a UTF-8 locale (which should be a string of two
 * values "SS");  instead it asserts against that under DEBUGGING, and
 * otherwise returns its input */
#define _generic_toUPPER_LC(c, function, cast)                                 \
                    (! FITS_IN_8_BITS(c)                                       \
                    ? (c)                                                      \
                    : ((! IN_UTF8_CTYPE_LOCALE)                                \
                      ? (cast)function((cast)(c))                              \
                      : ((((U8)(c)) == MICRO_SIGN)                             \
                        ? GREEK_CAPITAL_LETTER_MU                              \
                        : ((((U8)(c)) == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS)  \
                          ? LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS              \
                          : ((((U8)(c)) == LATIN_SMALL_LETTER_SHARP_S)         \
                            ? (__ASSERT_(0) (c))                               \
                            : PL_mod_latin1_uc[ (U8) (c) ])))))

/* Note that the result can be larger than a byte in a UTF-8 locale.  It
 * returns a single value, so can't adequately return the fold case of LATIN
 * SMALL LETTER SHARP S in a UTF-8 locale (which should be a string of two
 * values "ss"); instead it asserts against that under DEBUGGING, and
 * otherwise returns its input */
#define _generic_toFOLD_LC(c, function, cast)                                  \
                    ((UNLIKELY((c) == MICRO_SIGN) && IN_UTF8_CTYPE_LOCALE)     \
                      ? GREEK_SMALL_LETTER_MU                                  \
                      : (__ASSERT_(! IN_UTF8_CTYPE_LOCALE                      \
                                   || (c) != LATIN_SMALL_LETTER_SHARP_S)       \
                         _generic_toLOWER_LC(c, function, cast)))

/* Use the libc versions for these if available. */
#if defined(HAS_ISASCII)
#   define isASCII_LC(c) (FITS_IN_8_BITS(c) && isascii( (U8) (c)))
#else
#   define isASCII_LC(c) isASCII(c)
#endif

#if defined(HAS_ISBLANK)
#   define isBLANK_LC(c) _generic_LC(c, _CC_BLANK, isblank)
#else /* Unlike isASCII, varies if in a UTF-8 locale */
#   define isBLANK_LC(c) ((IN_UTF8_CTYPE_LOCALE) ? isBLANK_L1(c) : isBLANK(c))
#endif

#define _LC_CAST U8

#ifdef WIN32
    /* The Windows functions don't bother to follow the POSIX standard, which
     * for example says that something can't both be a printable and a control.
     * But Windows treats the \t control as a printable, and does such things
     * as making superscripts into both digits and punctuation.  This tames
     * these flaws by assuming that the definitions of both controls and space
     * are correct, and then making sure that other definitions don't have
     * weirdnesses, by making sure that isalnum() isn't also ispunct(), etc.
     * Not all possible weirdnesses are checked for, just the ones that were
     * detected on actual Microsoft code pages */

#  define isCNTRL_LC(c)  _generic_LC(c, _CC_CNTRL, iscntrl)
#  define isSPACE_LC(c)  _generic_LC(c, _CC_SPACE, isspace)

#  define isALPHA_LC(c)  (_generic_LC(c, _CC_ALPHA, isalpha)                  \
                                                    && isALPHANUMERIC_LC(c))
#  define isALPHANUMERIC_LC(c)  (_generic_LC(c, _CC_ALPHANUMERIC, isalnum) && \
                                                              ! isPUNCT_LC(c))
#  define isDIGIT_LC(c)  (_generic_LC(c, _CC_DIGIT, isdigit) &&               \
                                                         isALPHANUMERIC_LC(c))
#  define isGRAPH_LC(c)  (_generic_LC(c, _CC_GRAPH, isgraph) && isPRINT_LC(c))
#  define isIDFIRST_LC(c) (((c) == '_')                                       \
                 || (_generic_LC(c, _CC_IDFIRST, isalpha) && ! isPUNCT_LC(c)))
#  define isLOWER_LC(c)  (_generic_LC(c, _CC_LOWER, islower) && isALPHA_LC(c))
#  define isPRINT_LC(c)  (_generic_LC(c, _CC_PRINT, isprint) && ! isCNTRL_LC(c))
#  define isPUNCT_LC(c)  (_generic_LC(c, _CC_PUNCT, ispunct) && ! isCNTRL_LC(c))
#  define isUPPER_LC(c)  (_generic_LC(c, _CC_UPPER, isupper) && isALPHA_LC(c))
#  define isWORDCHAR_LC(c) (((c) == '_') || isALPHANUMERIC_LC(c))
#  define isXDIGIT_LC(c) (_generic_LC(c, _CC_XDIGIT, isxdigit)                \
                                                    && isALPHANUMERIC_LC(c))

#  define toLOWER_LC(c) _generic_toLOWER_LC((c), tolower, U8)
#  define toUPPER_LC(c) _generic_toUPPER_LC((c), toupper, U8)
#  define toFOLD_LC(c)  _generic_toFOLD_LC((c), tolower, U8)

#elif defined(CTYPE256) || (!defined(isascii) && !defined(HAS_ISASCII))
    /* For most other platforms */

#  define isALPHA_LC(c)   _generic_LC(c, _CC_ALPHA, isalpha)
#  define isALPHANUMERIC_LC(c)  _generic_LC(c, _CC_ALPHANUMERIC, isalnum)
#  define isCNTRL_LC(c)    _generic_LC(c, _CC_CNTRL, iscntrl)
#  define isDIGIT_LC(c)    _generic_LC(c, _CC_DIGIT, isdigit)
#  define isGRAPH_LC(c)    _generic_LC(c, _CC_GRAPH, isgraph)
#  define isIDFIRST_LC(c)  _generic_LC_underscore(c, _CC_IDFIRST, isalpha)
#  define isLOWER_LC(c)    _generic_LC(c, _CC_LOWER, islower)
#  define isPRINT_LC(c)    _generic_LC(c, _CC_PRINT, isprint)
#  define isPUNCT_LC(c)    _generic_LC(c, _CC_PUNCT, ispunct)
#  define isSPACE_LC(c)    _generic_LC(c, _CC_SPACE, isspace)
#  define isUPPER_LC(c)    _generic_LC(c, _CC_UPPER, isupper)
#  define isWORDCHAR_LC(c) _generic_LC_underscore(c, _CC_WORDCHAR, isalnum)
#  define isXDIGIT_LC(c)   _generic_LC(c, _CC_XDIGIT, isxdigit)


#  define toLOWER_LC(c) _generic_toLOWER_LC((c), tolower, U8)
#  define toUPPER_LC(c) _generic_toUPPER_LC((c), toupper, U8)
#  define toFOLD_LC(c)  _generic_toFOLD_LC((c), tolower, U8)

#else  /* The final fallback position */

#  define isALPHA_LC(c)	        (isascii(c) && isalpha(c))
#  define isALPHANUMERIC_LC(c)  (isascii(c) && isalnum(c))
#  define isCNTRL_LC(c)	        (isascii(c) && iscntrl(c))
#  define isDIGIT_LC(c)	        (isascii(c) && isdigit(c))
#  define isGRAPH_LC(c)	        (isascii(c) && isgraph(c))
#  define isIDFIRST_LC(c)	(isascii(c) && (isalpha(c) || (c) == '_'))
#  define isLOWER_LC(c)	        (isascii(c) && islower(c))
#  define isPRINT_LC(c)	        (isascii(c) && isprint(c))
#  define isPUNCT_LC(c)	        (isascii(c) && ispunct(c))
#  define isSPACE_LC(c)	        (isascii(c) && isspace(c))
#  define isUPPER_LC(c)	        (isascii(c) && isupper(c))
#  define isWORDCHAR_LC(c)	(isascii(c) && (isalnum(c) || (c) == '_'))
#  define isXDIGIT_LC(c)        (isascii(c) && isxdigit(c))

#  define toLOWER_LC(c)	(isascii(c) ? tolower(c) : (c))
#  define toUPPER_LC(c)	(isascii(c) ? toupper(c) : (c))
#  define toFOLD_LC(c)	(isascii(c) ? tolower(c) : (c))

#endif

#define isIDCONT(c)             isWORDCHAR(c)
#define isIDCONT_A(c)           isWORDCHAR_A(c)
#define isIDCONT_L1(c)	        isWORDCHAR_L1(c)
#define isIDCONT_LC(c)	        isWORDCHAR_LC(c)
#define isPSXSPC_LC(c)		isSPACE_LC(c)

/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_uvchr.  'c' is the code point to check.  'classnum' is the POSIX class
 * number defined earlier in this file.  _generic_uvchr() is used for POSIX
 * classes where there is a macro or function 'above_latin1' that takes the
 * single argument 'c' and returns the desired value.  These exist for those
 * classes which have simple definitions, avoiding the overhead of a hash
 * lookup or inversion list binary search.  _generic_swash_uvchr() can be used
 * for classes where that overhead is faster than a direct lookup.
 * _generic_uvchr() won't compile if 'c' isn't unsigned, as it won't match the
 * 'above_latin1' prototype. _generic_isCC() macro does bounds checking, so
 * have duplicate checks here, so could create versions of the macros that
 * don't, but experiments show that gcc optimizes them out anyway. */

/* Note that all ignore 'use bytes' */
#define _generic_uvchr(classnum, above_latin1, c) ((c) < 256                    \
                                             ? _generic_isCC(c, classnum)     \
                                             : above_latin1(c))
#define _generic_swash_uvchr(classnum, c) ((c) < 256                            \
                                             ? _generic_isCC(c, classnum)     \
                                             : _is_uni_FOO(classnum, c))
#define isALPHA_uvchr(c)      _generic_swash_uvchr(_CC_ALPHA, c)
#define isALPHANUMERIC_uvchr(c) _generic_swash_uvchr(_CC_ALPHANUMERIC, c)
#define isASCII_uvchr(c)      isASCII(c)
#define isBLANK_uvchr(c)      _generic_uvchr(_CC_BLANK, is_HORIZWS_cp_high, c)
#define isCNTRL_uvchr(c)      isCNTRL_L1(c) /* All controls are in Latin1 */
#define isDIGIT_uvchr(c)      _generic_swash_uvchr(_CC_DIGIT, c)
#define isGRAPH_uvchr(c)      _generic_swash_uvchr(_CC_GRAPH, c)
#define isIDCONT_uvchr(c)     _generic_uvchr(_CC_WORDCHAR, _is_uni_perl_idcont, c)
#define isIDFIRST_uvchr(c)    _generic_uvchr(_CC_IDFIRST, _is_uni_perl_idstart, c)
#define isLOWER_uvchr(c)      _generic_swash_uvchr(_CC_LOWER, c)
#define isPRINT_uvchr(c)      _generic_swash_uvchr(_CC_PRINT, c)

#define isPUNCT_uvchr(c)      _generic_swash_uvchr(_CC_PUNCT, c)
#define isSPACE_uvchr(c)      _generic_uvchr(_CC_SPACE, is_XPERLSPACE_cp_high, c)
#define isPSXSPC_uvchr(c)     isSPACE_uvchr(c)

#define isUPPER_uvchr(c)      _generic_swash_uvchr(_CC_UPPER, c)
#define isVERTWS_uvchr(c)     _generic_uvchr(_CC_VERTSPACE, is_VERTWS_cp_high, c)
#define isWORDCHAR_uvchr(c)   _generic_swash_uvchr(_CC_WORDCHAR, c)
#define isXDIGIT_uvchr(c)     _generic_uvchr(_CC_XDIGIT, is_XDIGIT_cp_high, c)

#define toFOLD_uvchr(c,s,l)	to_uni_fold(c,s,l)
#define toLOWER_uvchr(c,s,l)	to_uni_lower(c,s,l)
#define toTITLE_uvchr(c,s,l)	to_uni_title(c,s,l)
#define toUPPER_uvchr(c,s,l)	to_uni_upper(c,s,l)

/* For backwards compatibility, even though '_uni' should mean official Unicode
 * code points, in Perl it means native for those below 256 */
#define isALPHA_uni(c)          isALPHA_uvchr(c)
#define isALPHANUMERIC_uni(c)   isALPHANUMERIC_uvchr(c)
#define isASCII_uni(c)          isASCII_uvchr(c)
#define isBLANK_uni(c)          isBLANK_uvchr(c)
#define isCNTRL_uni(c)          isCNTRL_uvchr(c)
#define isDIGIT_uni(c)          isDIGIT_uvchr(c)
#define isGRAPH_uni(c)          isGRAPH_uvchr(c)
#define isIDCONT_uni(c)         isIDCONT_uvchr(c)
#define isIDFIRST_uni(c)        isIDFIRST_uvchr(c)
#define isLOWER_uni(c)          isLOWER_uvchr(c)
#define isPRINT_uni(c)          isPRINT_uvchr(c)
#define isPUNCT_uni(c)          isPUNCT_uvchr(c)
#define isSPACE_uni(c)          isSPACE_uvchr(c)
#define isPSXSPC_uni(c)         isPSXSPC_uvchr(c)
#define isUPPER_uni(c)          isUPPER_uvchr(c)
#define isVERTWS_uni(c)         isVERTWS_uvchr(c)
#define isWORDCHAR_uni(c)       isWORDCHAR_uvchr(c)
#define isXDIGIT_uni(c)         isXDIGIT_uvchr(c)
#define toFOLD_uni(c,s,l)       toFOLD_uvchr(c,s,l)
#define toLOWER_uni(c,s,l)      toLOWER_uvchr(c,s,l)
#define toTITLE_uni(c,s,l)      toTITLE_uvchr(c,s,l)
#define toUPPER_uni(c,s,l)      toUPPER_uvchr(c,s,l)

/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_LC_uvchr.  These are like isALPHA_LC, but the input can be any code
 * point, not just 0-255.  Like _generic_uvchr, there are two versions, one for
 * simple class definitions; the other for more complex.  These are like
 * _generic_uvchr, so see it for more info. */
#define _generic_LC_uvchr(latin1, above_latin1, c)                            \
                                    (c < 256 ? latin1(c) : above_latin1(c))
#define _generic_LC_swash_uvchr(latin1, classnum, c)                          \
                            (c < 256 ? latin1(c) : _is_uni_FOO(classnum, c))

#define isALPHA_LC_uvchr(c)  _generic_LC_swash_uvchr(isALPHA_LC, _CC_ALPHA, c)
#define isALPHANUMERIC_LC_uvchr(c)  _generic_LC_swash_uvchr(isALPHANUMERIC_LC, \
                                                         _CC_ALPHANUMERIC, c)
#define isASCII_LC_uvchr(c)   isASCII_LC(c)
#define isBLANK_LC_uvchr(c)  _generic_LC_uvchr(isBLANK_LC,                    \
                                                        is_HORIZWS_cp_high, c)
#define isCNTRL_LC_uvchr(c)  (c < 256 ? isCNTRL_LC(c) : 0)
#define isDIGIT_LC_uvchr(c)  _generic_LC_swash_uvchr(isDIGIT_LC, _CC_DIGIT, c)
#define isGRAPH_LC_uvchr(c)  _generic_LC_swash_uvchr(isGRAPH_LC, _CC_GRAPH, c)
#define isIDCONT_LC_uvchr(c) _generic_LC_uvchr(isIDCONT_LC,                   \
                                                  _is_uni_perl_idcont, c)
#define isIDFIRST_LC_uvchr(c) _generic_LC_uvchr(isIDFIRST_LC,                 \
                                                  _is_uni_perl_idstart, c)
#define isLOWER_LC_uvchr(c)  _generic_LC_swash_uvchr(isLOWER_LC, _CC_LOWER, c)
#define isPRINT_LC_uvchr(c)  _generic_LC_swash_uvchr(isPRINT_LC, _CC_PRINT, c)
#define isPSXSPC_LC_uvchr(c)  isSPACE_LC_uvchr(c)
#define isPUNCT_LC_uvchr(c)  _generic_LC_swash_uvchr(isPUNCT_LC, _CC_PUNCT, c)
#define isSPACE_LC_uvchr(c)  _generic_LC_uvchr(isSPACE_LC,                    \
                                                    is_XPERLSPACE_cp_high, c)
#define isUPPER_LC_uvchr(c)  _generic_LC_swash_uvchr(isUPPER_LC, _CC_UPPER, c)
#define isWORDCHAR_LC_uvchr(c) _generic_LC_swash_uvchr(isWORDCHAR_LC,         \
                                                           _CC_WORDCHAR, c)
#define isXDIGIT_LC_uvchr(c) _generic_LC_uvchr(isXDIGIT_LC,                  \
                                                       is_XDIGIT_cp_high, c)

#define isBLANK_LC_uni(c)    isBLANK_LC_uvchr(UNI_TO_NATIVE(c))

/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_utf8.  These are like the earlier defined macros, but take an input
 * UTF-8 encoded string 'p'. If the input is in the Latin1 range, use
 * the Latin1 macro 'classnum' on 'p'.  Otherwise use the value given by the
 * 'utf8' parameter.  This relies on the fact that ASCII characters have the
 * same representation whether utf8 or not.  Note that it assumes that the utf8
 * has been validated, and ignores 'use bytes' */
#define _generic_utf8(classnum, p, utf8) (UTF8_IS_INVARIANT(*(p))              \
                                         ? _generic_isCC(*(p), classnum)       \
                                         : (UTF8_IS_DOWNGRADEABLE_START(*(p))) \
                                           ? _generic_isCC(                    \
                                                EIGHT_BIT_UTF8_TO_NATIVE(*(p), \
                                                                   *((p)+1 )), \
                                                classnum)                      \
                                           : utf8)
/* Like the above, but calls 'above_latin1(p)' to get the utf8 value.
 * 'above_latin1' can be a macro */
#define _generic_func_utf8(classnum, above_latin1, p)  \
                                    _generic_utf8(classnum, p, above_latin1(p))
/* Like the above, but passes classnum to _isFOO_utf8(), instead of having an
 * 'above_latin1' parameter */
#define _generic_swash_utf8(classnum, p)  \
                      _generic_utf8(classnum, p, _is_utf8_FOO(classnum, p))

/* Like the above, but should be used only when it is known that there are no
 * characters in the upper-Latin1 range (128-255 on ASCII platforms) which the
 * class is TRUE for.  Hence it can skip the tests for this range.
 * 'above_latin1' should include its arguments */
#define _generic_utf8_no_upper_latin1(classnum, p, above_latin1)               \
                                         (UTF8_IS_INVARIANT(*(p))              \
                                         ? _generic_isCC(*(p), classnum)       \
                                         : (UTF8_IS_ABOVE_LATIN1(*(p)))        \
                                           ? above_latin1                      \
                                           : 0)

/* NOTE that some of these macros have very similar ones in regcharclass.h.
 * For example, there is (at the time of this writing) an 'is_SPACE_utf8()'
 * there, differing in name only by an underscore from the one here
 * 'isSPACE_utf8().  The difference is that the ones here are probably more
 * efficient and smaller, using an O(1) array lookup for Latin1-range code
 * points; the regcharclass.h ones are implemented as a series of
 * "if-else-if-else ..." */

#define isALPHA_utf8(p)        _generic_swash_utf8(_CC_ALPHA, p)
#define isALPHANUMERIC_utf8(p) _generic_swash_utf8(_CC_ALPHANUMERIC, p)
#define isASCII_utf8(p)        isASCII(*p) /* Because ASCII is invariant under
                                               utf8, the non-utf8 macro works
                                             */
#define isBLANK_utf8(p)        _generic_func_utf8(_CC_BLANK, is_HORIZWS_high, p)

#ifdef EBCDIC
    /* Because all controls are UTF-8 invariants in EBCDIC, we can use this
     * more efficient macro instead of the more general one */
#   define isCNTRL_utf8(p)      isCNTRL_L1(*(p))
#else
#   define isCNTRL_utf8(p)      _generic_utf8(_CC_CNTRL, p, 0)
#endif

#define isDIGIT_utf8(p)         _generic_utf8_no_upper_latin1(_CC_DIGIT, p,   \
                                                  _is_utf8_FOO(_CC_DIGIT, p))
#define isGRAPH_utf8(p)         _generic_swash_utf8(_CC_GRAPH, p)
#define isIDCONT_utf8(p)        _generic_func_utf8(_CC_WORDCHAR,              \
                                                  _is_utf8_perl_idcont, p)

/* To prevent S_scan_word in toke.c from hanging, we have to make sure that
 * IDFIRST is an alnum.  See
 * http://rt.perl.org/rt3/Ticket/Display.html?id=74022 for more detail than you
 * ever wanted to know about.  (In the ASCII range, there isn't a difference.)
 * This used to be not the XID version, but we decided to go with the more
 * modern Unicode definition */
#define isIDFIRST_utf8(p)   _generic_func_utf8(_CC_IDFIRST,                  \
                                                _is_utf8_perl_idstart, p)

#define isLOWER_utf8(p)     _generic_swash_utf8(_CC_LOWER, p)
#define isPRINT_utf8(p)     _generic_swash_utf8(_CC_PRINT, p)
#define isPSXSPC_utf8(p)    isSPACE_utf8(p)
#define isPUNCT_utf8(p)     _generic_swash_utf8(_CC_PUNCT, p)
#define isSPACE_utf8(p)     _generic_func_utf8(_CC_SPACE, is_XPERLSPACE_high, p)
#define isUPPER_utf8(p)     _generic_swash_utf8(_CC_UPPER, p)
#define isVERTWS_utf8(p)    _generic_func_utf8(_CC_VERTSPACE, is_VERTWS_high, p)
#define isWORDCHAR_utf8(p)  _generic_swash_utf8(_CC_WORDCHAR, p)
#define isXDIGIT_utf8(p)    _generic_utf8_no_upper_latin1(_CC_XDIGIT, p,     \
                                                          is_XDIGIT_high(p))

#define toFOLD_utf8(p,s,l)	to_utf8_fold(p,s,l)
#define toLOWER_utf8(p,s,l)	to_utf8_lower(p,s,l)
#define toTITLE_utf8(p,s,l)	to_utf8_title(p,s,l)
#define toUPPER_utf8(p,s,l)	to_utf8_upper(p,s,l)

/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_LC_utf8.  These are like _generic_utf8, but if the first code point
 * in 'p' is within the 0-255 range, it uses locale rules from the passed-in
 * 'macro' parameter */
#define _generic_LC_utf8(macro, p, utf8)                                    \
                         (UTF8_IS_INVARIANT(*(p))                           \
                         ? macro(*(p))                                      \
                         : (UTF8_IS_DOWNGRADEABLE_START(*(p)))              \
                           ? macro(EIGHT_BIT_UTF8_TO_NATIVE(*(p), *((p)+1)))\
                           : utf8)

#define _generic_LC_swash_utf8(macro, classnum, p)                         \
                    _generic_LC_utf8(macro, p, _is_utf8_FOO(classnum, p))
#define _generic_LC_func_utf8(macro, above_latin1, p)                         \
                              _generic_LC_utf8(macro, p, above_latin1(p))

#define isALPHANUMERIC_LC_utf8(p) _generic_LC_swash_utf8(isALPHANUMERIC_LC,   \
                                                      _CC_ALPHANUMERIC, p)
#define isALPHA_LC_utf8(p)    _generic_LC_swash_utf8(isALPHA_LC, _CC_ALPHA, p)
#define isASCII_LC_utf8(p)     isASCII_LC(*p)
#define isBLANK_LC_utf8(p)    _generic_LC_func_utf8(isBLANK_LC,               \
                                                         is_HORIZWS_high, p)
#define isCNTRL_LC_utf8(p)    _generic_LC_utf8(isCNTRL_LC, p, 0)
#define isDIGIT_LC_utf8(p)    _generic_LC_swash_utf8(isDIGIT_LC, _CC_DIGIT, p)
#define isGRAPH_LC_utf8(p)    _generic_LC_swash_utf8(isGRAPH_LC, _CC_GRAPH, p)
#define isIDCONT_LC_utf8(p)   _generic_LC_func_utf8(isIDCONT_LC,              \
                                                    _is_utf8_perl_idcont, p)
#define isIDFIRST_LC_utf8(p)  _generic_LC_func_utf8(isIDFIRST_LC,             \
                                                    _is_utf8_perl_idstart, p)
#define isLOWER_LC_utf8(p)    _generic_LC_swash_utf8(isLOWER_LC, _CC_LOWER, p)
#define isPRINT_LC_utf8(p)    _generic_LC_swash_utf8(isPRINT_LC, _CC_PRINT, p)
#define isPSXSPC_LC_utf8(p)    isSPACE_LC_utf8(p)
#define isPUNCT_LC_utf8(p)    _generic_LC_swash_utf8(isPUNCT_LC, _CC_PUNCT, p)
#define isSPACE_LC_utf8(p)    _generic_LC_func_utf8(isSPACE_LC,               \
                                                        is_XPERLSPACE_high, p)
#define isUPPER_LC_utf8(p)    _generic_LC_swash_utf8(isUPPER_LC, _CC_UPPER, p)
#define isWORDCHAR_LC_utf8(p) _generic_LC_swash_utf8(isWORDCHAR_LC,           \
                                                            _CC_WORDCHAR, p)
#define isXDIGIT_LC_utf8(p)   _generic_LC_func_utf8(isXDIGIT_LC,              \
                                                            is_XDIGIT_high, p)

/* Macros for backwards compatibility and for completeness when the ASCII and
 * Latin1 values are identical */
#define isALPHAU(c)         isALPHA_L1(c)
#define isDIGIT_L1(c)       isDIGIT_A(c)
#define isOCTAL(c)          isOCTAL_A(c)
#define isOCTAL_L1(c)       isOCTAL_A(c)
#define isXDIGIT_L1(c)      isXDIGIT_A(c)
#define isALNUM(c)          isWORDCHAR(c)
#define isALNUMU(c)         isWORDCHAR_L1(c)
#define isALNUM_LC(c)       isWORDCHAR_LC(c)
#define isALNUM_uni(c)      isWORDCHAR_uni(c)
#define isALNUM_LC_uvchr(c) isWORDCHAR_LC_uvchr(c)
#define isALNUM_utf8(p)     isWORDCHAR_utf8(p)
#define isALNUM_LC_utf8(p)  isWORDCHAR_LC_utf8(p)
#define isALNUMC_A(c)       isALPHANUMERIC_A(c)      /* Mnemonic: "C's alnum" */
#define isALNUMC_L1(c)      isALPHANUMERIC_L1(c)
#define isALNUMC(c)	    isALPHANUMERIC(c)
#define isALNUMC_LC(c)	    isALPHANUMERIC_LC(c)
#define isALNUMC_uni(c)     isALPHANUMERIC_uni(c)
#define isALNUMC_LC_uvchr(c) isALPHANUMERIC_LC_uvchr(c)
#define isALNUMC_utf8(p)    isALPHANUMERIC_utf8(p)
#define isALNUMC_LC_utf8(p) isALPHANUMERIC_LC_utf8(p)

/* On EBCDIC platforms, CTRL-@@ is 0, CTRL-A is 1, etc, just like on ASCII,
 * except that they don't necessarily mean the same characters, e.g. CTRL-D is
 * 4 on both systems, but that is EOT on ASCII;  ST on EBCDIC.
 * '?' is special-cased on EBCDIC to APC, which is the control there that is
 * the outlier from the block that contains the other controls, just like
 * toCTRL('?') on ASCII yields DEL, the control that is the outlier from the C0
 * block.  If it weren't special cased, it would yield a non-control.
 * The conversion works both ways, so toCTRL('D') is 4, and toCTRL(4) is D,
 * etc. */
#ifndef EBCDIC
#  define toCTRL(c)    (__ASSERT_(FITS_IN_8_BITS(c)) toUPPER(((U8)(c))) ^ 64)
#else
#  define toCTRL(c)   (__ASSERT_(FITS_IN_8_BITS(c))                     \
                      ((isPRINT_A(c))                                   \
                       ? (UNLIKELY((c) == '?')                          \
                         ? QUESTION_MARK_CTRL                           \
                         : (NATIVE_TO_LATIN1(toUPPER((U8) (c))) ^ 64))  \
                       : (UNLIKELY((c) == QUESTION_MARK_CTRL)           \
                         ? '?'                                          \
                         : (LATIN1_TO_NATIVE(((U8) (c)) ^ 64)))))
#endif

/* Line numbers are unsigned, 32 bits. */
typedef U32 line_t;
#define NOLINE ((line_t) 4294967295UL)  /* = FFFFFFFF */

/* Helpful alias for version prescan */
#define is_LAX_VERSION(a,b) \
	(a != Perl_prescan_version(aTHX_ a, FALSE, b, NULL, NULL, NULL, NULL))

#define is_STRICT_VERSION(a,b) \
	(a != Perl_prescan_version(aTHX_ a, TRUE, b, NULL, NULL, NULL, NULL))

#define BADVERSION(a,b,c) \
	if (b) { \
	    *b = c; \
	} \
	return a;

/* Converts a character known to represent a hexadecimal digit (0-9, A-F, or
 * a-f) to its numeric value.  READ_XDIGIT's argument is a string pointer,
 * which is advanced.  The input is validated only by an assert() in DEBUGGING
 * builds.  In both ASCII and EBCDIC the last 4 bits of the digits are 0-9; and
 * the last 4 bits of A-F and a-f are 1-6, so adding 9 yields 10-15 */
#define XDIGIT_VALUE(c) (__ASSERT_(isXDIGIT(c)) (0xf & (isDIGIT(c)        \
                                                        ? (c)             \
                                                        : ((c) + 9))))
#define READ_XDIGIT(s)  (__ASSERT_(isXDIGIT(*s)) (0xf & (isDIGIT(*(s))     \
                                                        ? (*(s)++)         \
                                                        : (*(s)++ + 9))))

/* Converts a character known to represent an octal digit (0-7) to its numeric
 * value.  The input is validated only by an assert() in DEBUGGING builds.  In
 * both ASCII and EBCDIC the last 3 bits of the octal digits range from 0-7. */
#define OCTAL_VALUE(c) (__ASSERT_(isOCTAL(c)) (7 & (c)))

/* Efficiently returns a boolean as to if two native characters are equivalent
 * case-insenstively.  At least one of the characters must be one of [A-Za-z];
 * the ALPHA in the name is to remind you of that.  This is asserted() in
 * DEBUGGING builds.  Because [A-Za-z] are invariant under UTF-8, this macro
 * works (on valid input) for both non- and UTF-8-encoded bytes.
 *
 * When one of the inputs is a compile-time constant and gets folded by the
 * compiler, this reduces to an AND and a TEST.  On both EBCDIC and ASCII
 * machines, 'A' and 'a' differ by a single bit; the same with the upper and
 * lower case of all other ASCII-range alphabetics.  On ASCII platforms, they
 * are 32 apart; on EBCDIC, they are 64.  At compile time, this uses an
 * exclusive 'or' to find that bit and then inverts it to form a mask, with
 * just a single 0, in the bit position where the upper- and lowercase differ.
 * */
#define isALPHA_FOLD_EQ(c1, c2)                                         \
                      (__ASSERT_(isALPHA_A(c1) || isALPHA_A(c2))        \
                      ((c1) & ~('A' ^ 'a')) ==  ((c2) & ~('A' ^ 'a')))
#define isALPHA_FOLD_NE(c1, c2) (! isALPHA_FOLD_EQ((c1), (c2)))

/*
=head1 Memory Management

=for apidoc Am|void|Newx|void* ptr|int nitems|type
The XSUB-writer's interface to the C C<malloc> function.

Memory obtained by this should B<ONLY> be freed with L<"Safefree">.

In 5.9.3, Newx() and friends replace the older New() API, and drops
the first parameter, I<x>, a debug aid which allowed callers to identify
themselves.  This aid has been superseded by a new build option,
PERL_MEM_LOG (see L<perlhacktips/PERL_MEM_LOG>).  The older API is still
there for use in XS modules supporting older perls.

=for apidoc Am|void|Newxc|void* ptr|int nitems|type|cast
The XSUB-writer's interface to the C C<malloc> function, with
cast.  See also C<L</Newx>>.

Memory obtained by this should B<ONLY> be freed with L<"Safefree">.

=for apidoc Am|void|Newxz|void* ptr|int nitems|type
The XSUB-writer's interface to the C C<malloc> function.  The allocated
memory is zeroed with C<memzero>.  See also C<L</Newx>>.

Memory obtained by this should B<ONLY> be freed with L<"Safefree">.

=for apidoc Am|void|Renew|void* ptr|int nitems|type
The XSUB-writer's interface to the C C<realloc> function.

Memory obtained by this should B<ONLY> be freed with L<"Safefree">.

=for apidoc Am|void|Renewc|void* ptr|int nitems|type|cast
The XSUB-writer's interface to the C C<realloc> function, with
cast.

Memory obtained by this should B<ONLY> be freed with L<"Safefree">.

=for apidoc Am|void|Safefree|void* ptr
The XSUB-writer's interface to the C C<free> function.

This should B<ONLY> be used on memory obtained using L<"Newx"> and friends.

=for apidoc Am|void|Move|void* src|void* dest|int nitems|type
The XSUB-writer's interface to the C C<memmove> function.  The C<src> is the
source, C<dest> is the destination, C<nitems> is the number of items, and
C<type> is the type.  Can do overlapping moves.  See also C<L</Copy>>.

=for apidoc Am|void *|MoveD|void* src|void* dest|int nitems|type
Like C<Move> but returns C<dest>.  Useful
for encouraging compilers to tail-call
optimise.

=for apidoc Am|void|Copy|void* src|void* dest|int nitems|type
The XSUB-writer's interface to the C C<memcpy> function.  The C<src> is the
source, C<dest> is the destination, C<nitems> is the number of items, and
C<type> is the type.  May fail on overlapping copies.  See also C<L</Move>>.

=for apidoc Am|void *|CopyD|void* src|void* dest|int nitems|type

Like C<Copy> but returns C<dest>.  Useful
for encouraging compilers to tail-call
optimise.

=for apidoc Am|void|Zero|void* dest|int nitems|type

The XSUB-writer's interface to the C C<memzero> function.  The C<dest> is the
destination, C<nitems> is the number of items, and C<type> is the type.

=for apidoc Am|void *|ZeroD|void* dest|int nitems|type

Like C<Zero> but returns dest.  Useful
for encouraging compilers to tail-call
optimise.

=for apidoc Am|void|StructCopy|type *src|type *dest|type
This is an architecture-independent macro to copy one structure to another.

=for apidoc Am|void|PoisonWith|void* dest|int nitems|type|U8 byte

Fill up memory with a byte pattern (a byte repeated over and over
again) that hopefully catches attempts to access uninitialized memory.

=for apidoc Am|void|PoisonNew|void* dest|int nitems|type

PoisonWith(0xAB) for catching access to allocated but uninitialized memory.

=for apidoc Am|void|PoisonFree|void* dest|int nitems|type

PoisonWith(0xEF) for catching access to freed memory.

=for apidoc Am|void|Poison|void* dest|int nitems|type

PoisonWith(0xEF) for catching access to freed memory.

=cut */

/* Maintained for backwards-compatibility only. Use newSV() instead. */
#ifndef PERL_CORE
#define NEWSV(x,len)	newSV(len)
#endif

#define MEM_SIZE_MAX ((MEM_SIZE)~0)


#ifdef PERL_MALLOC_WRAP

/* This expression will be constant-folded at compile time.  It checks
 * whether or not the type of the count n is so small (e.g. U8 or U16, or
 * U32 on 64-bit systems) that there's no way a wrap-around could occur.
 * As well as avoiding the need for a run-time check in some cases, it's
 * designed to avoid compiler warnings like:
 *     comparison is always false due to limited range of data type
 * It's mathematically equivalent to
 *    max(n) * sizeof(t) > MEM_SIZE_MAX
 */

#  define _MEM_WRAP_NEEDS_RUNTIME_CHECK(n,t) \
    (8 * sizeof(n) + sizeof(t) > sizeof(MEM_SIZE))

/* This is written in a slightly odd way to avoid various spurious
 * compiler warnings. We *want* to write the expression as
 *    _MEM_WRAP_NEEDS_RUNTIME_CHECK(n,t) && (n > C)
 * (for some compile-time constant C), but even when the LHS
 * constant-folds to false at compile-time, g++ insists on emitting
 * warnings about the RHS (e.g. "comparison is always false"), so instead
 * we write it as
 *
 *    (cond ? n : X) > C
 *
 * where X is a constant with X > C always false. Choosing a value for X
 * is tricky. If 0, some compilers will complain about 0 > C always being
 * false; if 1, Coverity complains when n happens to be the constant value
 * '1', that cond ? 1 : 1 has the same value on both branches; so use C
 * for X and hope that nothing else whines.
 */

#  define _MEM_WRAP_WILL_WRAP(n,t) \
      ((_MEM_WRAP_NEEDS_RUNTIME_CHECK(n,t) ? (MEM_SIZE)(n) : \
            MEM_SIZE_MAX/sizeof(t)) > MEM_SIZE_MAX/sizeof(t))

#  define MEM_WRAP_CHECK(n,t) \
	(void)(UNLIKELY(_MEM_WRAP_WILL_WRAP(n,t)) \
        && (croak_memory_wrap(),0))

#  define MEM_WRAP_CHECK_1(n,t,a) \
	(void)(UNLIKELY(_MEM_WRAP_WILL_WRAP(n,t)) \
	&& (Perl_croak_nocontext("%s",(a)),0))

#define MEM_WRAP_CHECK_(n,t) MEM_WRAP_CHECK(n,t),

#define PERL_STRLEN_ROUNDUP(n) ((void)(((n) > MEM_SIZE_MAX - 2 * PERL_STRLEN_ROUNDUP_QUANTUM) ? (croak_memory_wrap(),0):0),((n-1+PERL_STRLEN_ROUNDUP_QUANTUM)&~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM-1)))
#else

#define MEM_WRAP_CHECK(n,t)
#define MEM_WRAP_CHECK_1(n,t,a)
#define MEM_WRAP_CHECK_2(n,t,a,b)
#define MEM_WRAP_CHECK_(n,t)

#define PERL_STRLEN_ROUNDUP(n) (((n-1+PERL_STRLEN_ROUNDUP_QUANTUM)&~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM-1)))

#endif

#ifdef PERL_MEM_LOG
/*
 * If PERL_MEM_LOG is defined, all Newx()s, Renew()s, and Safefree()s
 * go through functions, which are handy for debugging breakpoints, but
 * which more importantly get the immediate calling environment (file and
 * line number, and C function name if available) passed in.  This info can
 * then be used for logging the calls, for which one gets a sample
 * implementation unless -DPERL_MEM_LOG_NOIMPL is also defined.
 *
 * Known problems:
 * - not all memory allocs get logged, only those
 *   that go through Newx() and derivatives (while all
 *   Safefrees do get logged)
 * - __FILE__ and __LINE__ do not work everywhere
 * - __func__ or __FUNCTION__ even less so
 * - I think more goes on after the perlio frees but
 *   the thing is that STDERR gets closed (as do all
 *   the file descriptors)
 * - no deeper calling stack than the caller of the Newx()
 *   or the kind, but do I look like a C reflection/introspection
 *   utility to you?
 * - the function prototypes for the logging functions
 *   probably should maybe be somewhere else than handy.h
 * - one could consider inlining (macrofying) the logging
 *   for speed, but I am too lazy
 * - one could imagine recording the allocations in a hash,
 *   (keyed by the allocation address?), and maintain that
 *   through reallocs and frees, but how to do that without
 *   any News() happening...?
 * - lots of -Ddefines to get useful/controllable output
 * - lots of ENV reads
 */

# ifdef PERL_CORE
#  ifndef PERL_MEM_LOG_NOIMPL
enum mem_log_type {
  MLT_ALLOC,
  MLT_REALLOC,
  MLT_FREE,
  MLT_NEW_SV,
  MLT_DEL_SV
};
#  endif
#  if defined(PERL_IN_SV_C)  /* those are only used in sv.c */
void Perl_mem_log_new_sv(const SV *sv, const char *filename, const int linenumber, const char *funcname);
void Perl_mem_log_del_sv(const SV *sv, const char *filename, const int linenumber, const char *funcname);
#  endif
# endif

#endif

#ifdef PERL_MEM_LOG
#define MEM_LOG_ALLOC(n,t,a)     Perl_mem_log_alloc(n,sizeof(t),STRINGIFY(t),a,__FILE__,__LINE__,FUNCTION__)
#define MEM_LOG_REALLOC(n,t,v,a) Perl_mem_log_realloc(n,sizeof(t),STRINGIFY(t),v,a,__FILE__,__LINE__,FUNCTION__)
#define MEM_LOG_FREE(a)          Perl_mem_log_free(a,__FILE__,__LINE__,FUNCTION__)
#endif

#ifndef MEM_LOG_ALLOC
#define MEM_LOG_ALLOC(n,t,a)     (a)
#endif
#ifndef MEM_LOG_REALLOC
#define MEM_LOG_REALLOC(n,t,v,a) (a)
#endif
#ifndef MEM_LOG_FREE
#define MEM_LOG_FREE(a)          (a)
#endif

#define Newx(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) (t*)MEM_LOG_ALLOC(n,t,safemalloc((MEM_SIZE)((n)*sizeof(t))))))
#define Newxc(v,n,t,c)	(v = (MEM_WRAP_CHECK_(n,t) (c*)MEM_LOG_ALLOC(n,t,safemalloc((MEM_SIZE)((n)*sizeof(t))))))
#define Newxz(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) (t*)MEM_LOG_ALLOC(n,t,safecalloc((n),sizeof(t)))))

#ifndef PERL_CORE
/* pre 5.9.x compatibility */
#define New(x,v,n,t)	Newx(v,n,t)
#define Newc(x,v,n,t,c)	Newxc(v,n,t,c)
#define Newz(x,v,n,t)	Newxz(v,n,t)
#endif

#define Renew(v,n,t) \
	  (v = (MEM_WRAP_CHECK_(n,t) (t*)MEM_LOG_REALLOC(n,t,v,saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))))
#define Renewc(v,n,t,c) \
	  (v = (MEM_WRAP_CHECK_(n,t) (c*)MEM_LOG_REALLOC(n,t,v,saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))))

#ifdef PERL_POISON
#define Safefree(d) \
  ((d) ? (void)(safefree(MEM_LOG_FREE((Malloc_t)(d))), Poison(&(d), 1, Malloc_t)) : (void) 0)
#else
#define Safefree(d)	safefree(MEM_LOG_FREE((Malloc_t)(d)))
#endif

#define Move(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) (void)memmove((char*)(d),(const char*)(s), (n) * sizeof(t)))
#define Copy(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) (void)memcpy((char*)(d),(const char*)(s), (n) * sizeof(t)))
#define Zero(d,n,t)	(MEM_WRAP_CHECK_(n,t) (void)memzero((char*)(d), (n) * sizeof(t)))

#define MoveD(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) memmove((char*)(d),(const char*)(s), (n) * sizeof(t)))
#define CopyD(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) memcpy((char*)(d),(const char*)(s), (n) * sizeof(t)))
#ifdef HAS_MEMSET
#define ZeroD(d,n,t)	(MEM_WRAP_CHECK_(n,t) memzero((char*)(d), (n) * sizeof(t)))
#else
/* Using bzero(), which returns void.  */
#define ZeroD(d,n,t)	(MEM_WRAP_CHECK_(n,t) memzero((char*)(d), (n) * sizeof(t)),d)
#endif

#define PoisonWith(d,n,t,b)	(MEM_WRAP_CHECK_(n,t) (void)memset((char*)(d), (U8)(b), (n) * sizeof(t)))
#define PoisonNew(d,n,t)	PoisonWith(d,n,t,0xAB)
#define PoisonFree(d,n,t)	PoisonWith(d,n,t,0xEF)
#define Poison(d,n,t)		PoisonFree(d,n,t)

#ifdef PERL_POISON
#  define PERL_POISON_EXPR(x) x
#else
#  define PERL_POISON_EXPR(x)
#endif

#ifdef USE_STRUCT_COPY
#define StructCopy(s,d,t) (*((t*)(d)) = *((t*)(s)))
#else
#define StructCopy(s,d,t) Copy(s,d,1,t)
#endif

/* C_ARRAY_LENGTH is the number of elements in the C array (so you
 * want your zero-based indices to be less than but not equal to).
 *
 * C_ARRAY_END is one past the last: half-open/half-closed range,
 * not last-inclusive range. */
#define C_ARRAY_LENGTH(a)	(sizeof(a)/sizeof((a)[0]))
#define C_ARRAY_END(a)		((a) + C_ARRAY_LENGTH(a))

#ifdef NEED_VA_COPY
# ifdef va_copy
#  define Perl_va_copy(s, d) va_copy(d, s)
# else
#  if defined(__va_copy)
#   define Perl_va_copy(s, d) __va_copy(d, s)
#  else
#   define Perl_va_copy(s, d) Copy(s, d, 1, va_list)
#  endif
# endif
#endif

/* convenience debug macros */
#ifdef USE_ITHREADS
#define pTHX_FORMAT  "Perl interpreter: 0x%p"
#define pTHX__FORMAT ", Perl interpreter: 0x%p"
#define pTHX_VALUE_   (void *)my_perl,
#define pTHX_VALUE    (void *)my_perl
#define pTHX__VALUE_ ,(void *)my_perl,
#define pTHX__VALUE  ,(void *)my_perl
#else
#define pTHX_FORMAT
#define pTHX__FORMAT
#define pTHX_VALUE_
#define pTHX_VALUE
#define pTHX__VALUE_
#define pTHX__VALUE
#endif /* USE_ITHREADS */

/* Perl_deprecate was not part of the public API, and did not have a deprecate()
   shortcut macro defined without -DPERL_CORE. Neither codesearch.google.com nor
   CPAN::Unpack show any users outside the core.  */
#ifdef PERL_CORE
#  define deprecate(s) Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),    \
                                            "Use of " s " is deprecated")
#endif

/* Internal macros to deal with gids and uids */
#ifdef PERL_CORE

#  if Uid_t_size > IVSIZE
#    define sv_setuid(sv, uid)       sv_setnv((sv), (NV)(uid))
#    define SvUID(sv)                SvNV(sv)
#  else
#    if Uid_t_sign <= 0
#      define sv_setuid(sv, uid)       sv_setiv((sv), (IV)(uid))
#      define SvUID(sv)                SvIV(sv)
#    else
#      define sv_setuid(sv, uid)       sv_setuv((sv), (UV)(uid))
#      define SvUID(sv)                SvUV(sv)
#    endif
#  endif /* Uid_t_size */

#  if Gid_t_size > IVSIZE
#    define sv_setgid(sv, gid)       sv_setnv((sv), (NV)(gid))
#    define SvGID(sv)                SvNV(sv)
#  else
#    if Gid_t_sign <= 0
#      define sv_setgid(sv, gid)       sv_setiv((sv), (IV)(gid))
#      define SvGID(sv)                SvIV(sv)
#    else
#      define sv_setgid(sv, gid)       sv_setuv((sv), (UV)(gid))
#      define SvGID(sv)                SvUV(sv)
#    endif
#  endif /* Gid_t_size */

#endif

#endif  /* HANDY_H */

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a98 13
/* The NeXT dynamic loader headers will not build with the bool macro
   So declare them now to clear confusion.
*/
#if defined(NeXT) || defined(__NeXT__)
# undef FALSE
# undef TRUE
  typedef enum bool { FALSE = 0, TRUE = 1 } bool;
# define ENUM_BOOL 1
# ifndef HAS_BOOL
#  define HAS_BOOL 1
# endif /* !HAS_BOOL */
#endif /* NeXT || __NeXT__ */

d176 2
a177 2
#ifdef PERL_CORE
#   ifdef HAS_QUAD
d180 1
a180 2
#   endif
#endif /* PERL_CORE */
d182 41
a222 24
#if defined(HAS_QUAD) && defined(USE_64_BIT_INT)
#   if defined(HAS_LONG_LONG) && QUADKIND == QUAD_IS_LONG_LONG
#       define PeRl_INT64_C(c)	CAT2(c,LL)
#       define PeRl_UINT64_C(c)	CAT2(c,ULL)
#   else
#       if QUADKIND == QUAD_IS___INT64
#           define PeRl_INT64_C(c)	CAT2(c,I64)
#           define PeRl_UINT64_C(c)	CAT2(c,UI64)
#       else
#           if LONGSIZE == 8 && QUADKIND == QUAD_IS_LONG
#               define PeRl_INT64_C(c)	CAT2(c,L)
#               define PeRl_UINT64_C(c)	CAT2(c,UL)
#           else
#               define PeRl_INT64_C(c)	((I64TYPE)(c))
#               define PeRl_UINT64_C(c)	((U64TYPE)(c))
#           endif
#       endif
#   endif
#   ifndef UINT64_C
#   define UINT64_C(c) PeRl_UINT64_C(c)
#   endif
#   ifndef INT64_C
#   define INT64_C(c) PeRl_INT64_C(c)
#   endif
d277 1
d283 7
a289 2
 * assert(), we would get a comma with nothing before it when not DEBUGGING */
#ifdef DEBUGGING
d299 1
a299 1
Like C<newSVpvn>, but takes a literal C<NUL>-terminated string instead of a
d303 1
a303 1
Like C<newSVpvn_flags>, but takes a literal C<NUL>-terminated string instead of
d307 1
a307 1
Like C<newSVpvn_share>, but takes a literal C<NUL>-terminated string instead of
d311 1
a311 1
Like C<sv_catpvn_flags>, but takes a literal C<NUL>-terminated string instead
d315 2
a316 2
Like C<sv_catpvn_nomg>, but takes a literal string instead of a
string/length pair.
d319 2
a320 1
Like C<sv_catpvn>, but takes a literal string instead of a string/length pair.
d323 1
a323 1
Like C<sv_catpvn_mg>, but takes a literal string instead of a
d327 2
a328 1
Like C<sv_setpvn>, but takes a literal string instead of a string/length pair.
d331 1
a331 1
Like C<sv_setpvn_mg>, but takes a literal string instead of a
d335 2
a336 2
Like C<sv_setref_pvn>, but takes a literal string instead of a
string/length pair.
d341 1
a341 1
Like C<savepvn>, but takes a literal C<NUL>-terminated string instead of a
d351 2
a352 1
Like C<gv_stashpvn>, but takes a literal string instead of a string/length pair.
d357 2
a358 1
Like C<hv_fetch>, but takes a literal string instead of a string/length pair.
d361 2
a362 1
Like C<hv_store>, but takes a literal string instead of a string/length pair
d369 2
a370 2
Like L</lex_stuff_pvn>, but takes a literal string instead of a
string/length pair.
d429 2
a430 2
Test two strings to see if they are different.  Returns true or
false.
d433 2
a434 1
Test two strings to see if they are equal.  Returns true or false.
d437 2
a438 2
Test two strings to see if the first, C<s1>, is less than the second,
C<s2>.  Returns true or false.
d441 2
a442 2
Test two strings to see if the first, C<s1>, is less than or equal to the
second, C<s2>.  Returns true or false.
d445 2
a446 2
Test two strings to see if the first, C<s1>, is greater than the second,
C<s2>.  Returns true or false.
d449 2
a450 2
Test two strings to see if the first, C<s1>, is greater than or equal to
the second, C<s2>.  Returns true or false.
d453 2
a454 2
Test two strings to see if they are different.  The C<len> parameter
indicates the number of bytes to compare.  Returns true or false.  (A
d458 13
a470 3
Test two strings to see if they are equal.  The C<len> parameter indicates
the number of bytes to compare.  Returns true or false.  (A wrapper for
C<strncmp>).
d517 1
a517 1
=head1 Character classes
d542 1
a542 1
Variant C<isFOO_uni> is like the C<isFOO_L1> variant, but accepts any UV code
d545 1
a545 1
C<isWORDCHAR_uni(0x100)> returns TRUE, since 0x100 is LATIN CAPITAL LETTER A
d548 4
a551 4
Variant C<isFOO_utf8> is like C<isFOO_uni>, but the input is a pointer to a
(known to be well-formed) UTF-8 encoded string (C<U8*> or C<char*>).  The
classification of just the first (possibly multi-byte) character in the string
is tested.
d559 3
a561 1
returned if the input won't fit into an octet.
d567 4
a570 4
Variant C<isFOO_LC_utf8> is like C<isFOO_LC_uvchr>, but the input is a pointer to a
(known to be well-formed) UTF-8 encoded string (C<U8*> or C<char*>).  The
classification of just the first (possibly multi-byte) character in the string
is tested.
d575 3
a577 2
See the L<top of this section|/Character classes> for an explanation of variants
C<isALPHA_A>, C<isALPHA_L1>, C<isALPHA_uni>, C<isALPHA_utf8>, C<isALPHA_LC>,
d583 3
a585 2
See the L<top of this section|/Character classes> for an explanation of variants
C<isALPHANUMERIC_A>, C<isALPHANUMERIC_L1>, C<isALPHANUMERIC_uni>,
d595 3
a597 2
See the L<top of this section|/Character classes> for an explanation of variants
C<isASCII_uni>, C<isASCII_utf8>, C<isASCII_LC>, C<isASCII_LC_uvchr>, and
d611 3
a613 2
See the L<top of this section|/Character classes> for an explanation of variants
C<isBLANK_A>, C<isBLANK_L1>, C<isBLANK_uni>, C<isBLANK_utf8>, C<isBLANK_LC>,
d622 3
a624 2
See the L<top of this section|/Character classes> for an explanation of variants
C<isCNTRL_A>, C<isCNTRL_L1>, C<isCNTRL_uni>, C<isCNTRL_utf8>, C<isCNTRL_LC>,
d632 3
a634 2
See the L<top of this section|/Character classes> for an explanation of variants
C<isDIGIT_uni>, C<isDIGIT_utf8>, C<isDIGIT_LC>, C<isDIGIT_LC_uvchr>, and
d640 3
a642 2
See the L<top of this section|/Character classes> for an explanation of variants
C<isGRAPH_A>, C<isGRAPH_L1>, C<isGRAPH_uni>, C<isGRAPH_utf8>, C<isGRAPH_LC>,
d648 3
a650 2
See the L<top of this section|/Character classes> for an explanation of variants
C<isLOWER_A>, C<isLOWER_L1>, C<isLOWER_uni>, C<isLOWER_utf8>, C<isLOWER_LC>,
d665 3
a667 2
See the L<top of this section|/Character classes> for an explanation of variants
C<isPUNCT_A>, C<isPUNCT_L1>, C<isPUNCT_uni>, C<isPUNCT_utf8>, C<isPUNCT_LC>,
d674 1
a674 3
(experimentally), this also matches what C<m/[[:space:]]/> does.
("Experimentally" means that this change may be backed out in 5.22 if
field experience indicates that it was unwise.)  Prior to 5.18, only the
d679 3
a681 2
See the L<top of this section|/Character classes> for an explanation of variants
C<isSPACE_A>, C<isSPACE_L1>, C<isSPACE_uni>, C<isSPACE_utf8>, C<isSPACE_LC>,
d686 2
a687 4
Starting in 5.18, this is identical (experimentally) in all its forms to the
corresponding C<isSPACE()> macros.  ("Experimentally" means that this change
may be backed out in 5.22 if field experience indicates that it
was unwise.)
d694 3
a696 3
See the L<top of this section|/Character classes> for an explanation of variants
C<isPSXSPC_A>, C<isPSXSPC_L1>, C<isPSXSPC_uni>, C<isPSXSPC_utf8>, C<isPSXSPC_LC>,
C<isPSXSPC_LC_uvchr>, and C<isPSXSPC_LC_utf8>.
d701 3
a703 2
See the L<top of this section|/Character classes> for an explanation of variants
C<isUPPER_A>, C<isUPPER_L1>, C<isUPPER_uni>, C<isUPPER_utf8>, C<isUPPER_LC>,
d709 3
a711 2
See the L<top of this section|/Character classes> for an explanation of variants
C<isPRINT_A>, C<isPRINT_L1>, C<isPRINT_uni>, C<isPRINT_utf8>, C<isPRINT_LC>,
d723 5
a727 3
See the L<top of this section|/Character classes> for an explanation of variants
C<isWORDCHAR_A>, C<isWORDCHAR_L1>, C<isWORDCHAR_uni>, C<isWORDCHAR_utf8>,
C<isWORDCHAR_LC>, C<isWORDCHAR_LC_uvchr>, and C<isWORDCHAR_LC_utf8>.
d733 3
a735 2
See the L<top of this section|/Character classes> for an explanation of variants
C<isXDIGIT_uni>, C<isXDIGIT_utf8>, C<isXDIGIT_LC>, C<isXDIGIT_LC_uvchr>, and
d743 3
a745 2
See the L<top of this section|/Character classes> for an explanation of variants
C<isIDFIRST_A>, C<isIDFIRST_L1>, C<isIDFIRST_uni>, C<isIDFIRST_utf8>,
d753 3
a755 2
L</isWORDCHAR>.  See the L<top of this section|/Character classes> for an
explanation of variants C<isIDCONT_A>, C<isIDCONT_L1>, C<isIDCONT_uni>,
d772 4
a775 3
=for apidoc Am|UV|toUPPER_uni|UV cp|U8* s|STRLEN* lenp
Converts the Unicode code point C<cp> to its uppercase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
d797 1
a797 1
Latin1 range, as the full generality of L</toFOLD_uni> is needed there.)
d799 4
a802 3
=for apidoc Am|UV|toFOLD_uni|UV cp|U8* s|STRLEN* lenp
Converts the Unicode code point C<cp> to its foldcase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
d826 2
a827 2
Converts the specified Latin1 character to lowercase.  The results are undefined if
the input doesn't fit in a byte.
d833 4
a836 3
=for apidoc Am|UV|toLOWER_uni|UV cp|U8* s|STRLEN* lenp
Converts the Unicode code point C<cp> to its lowercase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
a853 4
=for apidoc Am|U8|toLOWER_LC|U8 ch
Converts the specified character to lowercase using the current locale's rules,
if possible; otherwise returns the input character itself.

d857 8
a864 7
C<toTITLE_A> is equivalent.  (There is no C<toTITLE_L1> for the full Latin1 range,
as the full generality of L</toTITLE_uni> is needed there.  Titlecase is not a
concept used in locale handling, so there is no functionality for that.)

=for apidoc Am|UV|toTITLE_uni|UV cp|U8* s|STRLEN* lenp
Converts the Unicode code point C<cp> to its titlecase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
d884 1
a884 1
XXX Still undocumented isVERTWS_uni and _utf8; it's unclear what their names
d907 4
d912 1
d914 3
d920 2
a921 2
        /* This returns the wrong results on at least z/OS unless this is
         * defined. */
a923 4

    /* We could be called without perl.h, in which case NATIVE_TO_ASCII() is
     * likely not defined, and so we use the native function */
#   define isASCII(c)    cBOOL(isascii(c))
d925 5
a929 1
#   define isASCII(c)    ((WIDEST_UTYPE)(c) < 128)
a931 3
#define isASCII_A(c)  isASCII(c)
#define isASCII_L1(c)  isASCII(c)

a936 1
/* ASCII range only */
d970 1
a970 1
#  define _CC_SPACE             10      /* \s */
d973 3
a975 4
#  define _CC_PSXSPC            13      /* [:space:] */
#  define _CC_CNTRL             14      /* [:cntrl:] */
#  define _CC_ASCII             15      /* [:ascii:] */
#  define _CC_VERTSPACE         16      /* \v */
d980 17
a996 10
 * structures in regcomp.[ch] and regexec.c.  But they should be added to
 * bootstrap_ctype() */
#  define _CC_IDFIRST           17
#  define _CC_CHARNAME_CONT     18
#  define _CC_NONLATIN1_FOLD    19
#  define _CC_QUOTEMETA         20
#  define _CC_NON_FINAL_FOLD    21
#  define _CC_IS_IN_SOME_FOLD   22
#  define _CC_BACKSLASH_FOO_LBRACE_IS_META 31 /* temp, see mk_PL_charclass.pl */
/* Unused: 23-30
d1003 3
a1005 1
 * would just cause /i regexes which match them to run less efficiently */
a1020 1
    _CC_ENUM_PSXSPC         = _CC_PSXSPC,
d1033 3
a1035 1
#if defined(PERL_IN_UTF8_C) || defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)
d1060 1
d1069 1
a1069 3
#endif  /* Has perl.h */

#if defined(H_PERL) && ! defined(BOOTSTRAP_CHARSET)
d1076 1
a1076 1
#   define _generic_isCC(c, classnum) cBOOL(FITS_IN_8_BITS(c) \
d1086 3
a1088 3
#   define _generic_isCC_A(c, classnum) (FITS_IN_8_BITS(c)  \
        && ((PL_charclass[(U8) (c)] & _CC_mask_A(classnum)) \
                                == _CC_mask_A(classnum)))
d1094 1
a1094 1
#   define isDIGIT_A(c)  _generic_isCC(c, _CC_DIGIT)
a1097 1
#   define isPSXSPC_A(c) _generic_isCC_A(c, _CC_PSXSPC)
d1102 2
a1103 1
#   define isXDIGIT_A(c)  _generic_isCC(c, _CC_XDIGIT)
d1116 1
a1116 1
#   define isPSXSPC_L1(c) _generic_isCC(c, _CC_PSXSPC)
d1123 8
a1130 2
    /* Either participates in a fold with a character above 255, or is a
     * multi-char fold */
d1135 1
a1135 1
                                            _generic_isCC(c, _CC_NON_FINAL_FOLD)
d1137 4
a1140 2
                                            _generic_isCC(c, _CC_IS_IN_SOME_FOLD)
#else   /* Either don't have perl.h or don't want to use char_class_tab.h */
d1144 21
a1164 27
     * to it.  We can also get here if we are configured to bootstrap up Perl
     * on a non-ASCII platform that doesn't have a working Perl (currently only
     * EBCDIC).  For these we currently use the native definitions to get
     * things going.  (It should also be possible to use the translation
     * function NATIVE_TO_LATIN1(), but that is an extra layer of dependence on
     * Perl, so it is currently avoided for the macros where it's possible to
     * do so.) */
#   ifdef EBCDIC
        /* Use the native functions.  They likely will return false for all
         * non-ASCII values, but this makes sure */
#       define isALPHA_A(c)    (isASCII(c) && isalpha(c))
#       define isALPHANUMERIC_A(c) (isASCII(c) && isalnum(c))
#       define isCNTRL_A(c)    (isASCII(c) && iscntrl(c))
#       define isDIGIT_A(c)    (isASCII(c) && isdigit(c))
#       define isGRAPH_A(c)    (isASCII(c) && isgraph(c))
#       define isLOWER_A(c)    (isASCII(c) && islower(c))
#       define isPRINT_A(c)    (isASCII(c) && isprint(c))
#       define isPUNCT_A(c)    (isASCII(c) && ispunct(c))
#       define isSPACE_A(c)    (isASCII(c) && isspace(c))
#       define isUPPER_A(c)    (isASCII(c) && isupper(c))
#       define isXDIGIT_A(c)   (isASCII(c) && isxdigit(c))
#   else   /* ASCII platform.  These are coded based on first principals */
#       define isALPHA_A(c)  (isUPPER_A(c) || isLOWER_A(c))
#       define isALPHANUMERIC_A(c) (isALPHA_A(c) || isDIGIT_A(c))
#       define isCNTRL_A(c)  (isASCII(c) && (! isPRINT_A(c)))
#       define isDIGIT_A(c)  ((c) <= '9' && (c) >= '0')
#       define isGRAPH_A(c)  (isPRINT_A(c) && (c) != ' ')
a1165 8
#       define isPRINT_A(c)  (((c) >= 32 && (c) < 127))
#       define isPUNCT_A(c)  (isGRAPH_A(c) && (! isALPHANUMERIC_A(c)))
#       define isSPACE_A(c)  ((c) == ' '                                     \
                              || (c) == '\t'                                 \
                              || (c) == '\n'                                 \
                              || (c) == '\r'                                 \
                              || (c) =='\v'                                  \
                              || (c) == '\f')
d1167 6
a1172 5
#       define isXDIGIT_A(c) (isDIGIT_A(c)                                   \
                              || ((c) >= 'a' && (c) <= 'f')                  \
                              || ((c) <= 'F' && (c) >= 'A'))
#   endif   /* Below are common definitions for ASCII and non-ASCII */
#   define isBLANK_A(c)      ((c) == ' ' || (c) == '\t')
d1174 47
a1220 1
#   define isWORDCHAR_A(c)   (isALPHANUMERIC_A(c) || (c) == '_')
d1222 7
a1228 4
    /* The _L1 macros may be unnecessary for both the utilities and for
     * bootstrapping; I (khw) added them during debugging of bootstrapping, and
     * it seems best to keep them. */
#   define isPSXSPC_A(c)     isSPACE_A(c) /* XXX Assumes SPACE matches '\v' */
a1245 1
#   define isPSXSPC_L1(c)    isSPACE_L1(c)
d1280 1
d1294 1
a1294 1
#endif  /* End of no perl.h or have BOOTSTRAP_CHARSET */
d1298 2
d1307 1
d1309 1
d1389 1
a1389 1
                                                : function((cast)(c)))
d1400 1
a1400 1
                      ? function((cast)(c))                                    \
d1422 1
a1422 1
#if defined(HAS_ISASCII) && ! defined(USE_NEXT_CTYPE)
d1428 1
a1428 1
#if defined(HAS_ISBLANK) && ! defined(USE_NEXT_CTYPE)
d1431 1
a1431 1
#   define isBLANK_LC(c) (IN_UTF8_CTYPE_LOCALE) ? isBLANK_L1(c) : isBLANK(c)
d1434 1
a1434 18
#ifdef USE_NEXT_CTYPE   /* NeXT computers */

#    define _LC_CAST unsigned int   /* Needed by _generic_LC.  NeXT functions
                                       use this as their input type */

#    define isALPHA_LC(c)   _generic_LC(c, _CC_ALPHA, NXIsAlpha)
#    define isALPHANUMERIC_LC(c)  _generic_LC(c, _CC_ALPHANUMERIC, NXIsAlNum)
#    define isCNTRL_LC(c)    _generic_LC(c, _CC_CNTRL, NXIsCntrl)
#    define isDIGIT_LC(c)    _generic_LC(c, _CC_DIGIT, NXIsDigit)
#    define isGRAPH_LC(c)    _generic_LC(c, _CC_GRAPH, NXIsGraph)
#    define isIDFIRST_LC(c)  _generic_LC_underscore(c, _CC_IDFIRST, NXIsAlpha)
#    define isLOWER_LC(c)    _generic_LC(c, _CC_LOWER, NXIsLower)
#    define isPRINT_LC(c)    _generic_LC(c, _CC_PRINT, NXIsPrint)
#    define isPUNCT_LC(c)    _generic_LC(c, _CC_PUNCT, NXIsPunct)
#    define isSPACE_LC(c)    _generic_LC(c, _CC_SPACE, NXIsSpace)
#    define isUPPER_LC(c)    _generic_LC(c, _CC_UPPER, NXIsUpper)
#    define isWORDCHAR_LC(c) _generic_LC_underscore(c, _CC_WORDCHAR, NXIsAlNum)
#    define isXDIGIT_LC(c)   _generic_LC(c, _CC_XDIGIT, NXIsXdigit)
d1436 34
a1469 3
#    define toLOWER_LC(c) _generic_toLOWER_LC((c), NXToLower, unsigned int)
#    define toUPPER_LC(c) _generic_toUPPER_LC((c), NXToUpper, unsigned int)
#    define toFOLD_LC(c)  _generic_toFOLD_LC((c), NXToLower, unsigned int)
d1471 1
a1471 5
#else /* !USE_NEXT_CTYPE */

#  define _LC_CAST U8

#  if defined(CTYPE256) || (!defined(isascii) && !defined(HAS_ISASCII))
d1474 38
a1511 38
#    define isALPHA_LC(c)   _generic_LC(c, _CC_ALPHA, isalpha)
#    define isALPHANUMERIC_LC(c)  _generic_LC(c, _CC_ALPHANUMERIC, isalnum)
#    define isCNTRL_LC(c)    _generic_LC(c, _CC_CNTRL, iscntrl)
#    define isDIGIT_LC(c)    _generic_LC(c, _CC_DIGIT, isdigit)
#    define isGRAPH_LC(c)    _generic_LC(c, _CC_GRAPH, isgraph)
#    define isIDFIRST_LC(c)  _generic_LC_underscore(c, _CC_IDFIRST, isalpha)
#    define isLOWER_LC(c)    _generic_LC(c, _CC_LOWER, islower)
#    define isPRINT_LC(c)    _generic_LC(c, _CC_PRINT, isprint)
#    define isPUNCT_LC(c)    _generic_LC(c, _CC_PUNCT, ispunct)
#    define isSPACE_LC(c)    _generic_LC(c, _CC_SPACE, isspace)
#    define isUPPER_LC(c)    _generic_LC(c, _CC_UPPER, isupper)
#    define isWORDCHAR_LC(c) _generic_LC_underscore(c, _CC_WORDCHAR, isalnum)
#    define isXDIGIT_LC(c)   _generic_LC(c, _CC_XDIGIT, isxdigit)


#    define toLOWER_LC(c) _generic_toLOWER_LC((c), tolower, U8)
#    define toUPPER_LC(c) _generic_toUPPER_LC((c), toupper, U8)
#    define toFOLD_LC(c)  _generic_toFOLD_LC((c), tolower, U8)

#  else  /* The final fallback position */

#    define isALPHA_LC(c)	(isascii(c) && isalpha(c))
#    define isALPHANUMERIC_LC(c) (isascii(c) && isalnum(c))
#    define isCNTRL_LC(c)	(isascii(c) && iscntrl(c))
#    define isDIGIT_LC(c)	(isascii(c) && isdigit(c))
#    define isGRAPH_LC(c)	(isascii(c) && isgraph(c))
#    define isIDFIRST_LC(c)	(isascii(c) && (isalpha(c) || (c) == '_'))
#    define isLOWER_LC(c)	(isascii(c) && islower(c))
#    define isPRINT_LC(c)	(isascii(c) && isprint(c))
#    define isPUNCT_LC(c)	(isascii(c) && ispunct(c))
#    define isSPACE_LC(c)	(isascii(c) && isspace(c))
#    define isUPPER_LC(c)	(isascii(c) && isupper(c))
#    define isWORDCHAR_LC(c)	(isascii(c) && (isalnum(c) || (c) == '_'))
#    define isXDIGIT_LC(c)      (isascii(c) && isxdigit(c))

#    define toLOWER_LC(c)	(isascii(c) ? tolower(c) : (c))
#    define toUPPER_LC(c)	(isascii(c) ? toupper(c) : (c))
#    define toFOLD_LC(c)	(isascii(c) ? tolower(c) : (c))
d1513 1
a1513 2
#  endif
#endif /* USE_NEXT_CTYPE */
d1522 2
a1523 2
 * isALPHA_uni.  'c' is the code point to check.  'classnum' is the POSIX class
 * number defined earlier in this file.  _generic_uni() is used for POSIX
d1527 1
a1527 1
 * lookup or inversion list binary search.  _generic_swash_uni() can be used
d1529 1
a1529 1
 * _generic_uni() won't compile if 'c' isn't unsigned, as it won't match the
d1535 1
a1535 1
#define _generic_uni(classnum, above_latin1, c) ((c) < 256                    \
d1538 1
a1538 1
#define _generic_swash_uni(classnum, c) ((c) < 256                            \
d1541 50
a1590 26
#define isALPHA_uni(c)      _generic_swash_uni(_CC_ALPHA, c)
#define isALPHANUMERIC_uni(c) _generic_swash_uni(_CC_ALPHANUMERIC, c)
#define isASCII_uni(c)      isASCII(c)
#define isBLANK_uni(c)      _generic_uni(_CC_BLANK, is_HORIZWS_cp_high, c)
#define isCNTRL_uni(c)      isCNTRL_L1(c) /* All controls are in Latin1 */
#define isDIGIT_uni(c)      _generic_swash_uni(_CC_DIGIT, c)
#define isGRAPH_uni(c)      _generic_swash_uni(_CC_GRAPH, c)
#define isIDCONT_uni(c)     _generic_uni(_CC_WORDCHAR, _is_uni_perl_idcont, c)
#define isIDFIRST_uni(c)    _generic_uni(_CC_IDFIRST, _is_uni_perl_idstart, c)
#define isLOWER_uni(c)      _generic_swash_uni(_CC_LOWER, c)
#define isPRINT_uni(c)      _generic_swash_uni(_CC_PRINT, c)

/* Posix and regular space are identical above Latin1 */
#define isPSXSPC_uni(c)     _generic_uni(_CC_PSXSPC, is_XPERLSPACE_cp_high, c)

#define isPUNCT_uni(c)      _generic_swash_uni(_CC_PUNCT, c)
#define isSPACE_uni(c)      _generic_uni(_CC_SPACE, is_XPERLSPACE_cp_high, c)
#define isUPPER_uni(c)      _generic_swash_uni(_CC_UPPER, c)
#define isVERTWS_uni(c)     _generic_uni(_CC_VERTSPACE, is_VERTWS_cp_high, c)
#define isWORDCHAR_uni(c)   _generic_swash_uni(_CC_WORDCHAR, c)
#define isXDIGIT_uni(c)     _generic_uni(_CC_XDIGIT, is_XDIGIT_cp_high, c)

#define toFOLD_uni(c,s,l)	to_uni_fold(c,s,l)
#define toLOWER_uni(c,s,l)	to_uni_lower(c,s,l)
#define toTITLE_uni(c,s,l)	to_uni_title(c,s,l)
#define toUPPER_uni(c,s,l)	to_uni_upper(c,s,l)
d1594 1
a1594 1
 * point, not just 0-255.  Like _generic_uni, there are two versions, one for
d1596 1
a1596 1
 * _generic_uni, so see it for more info. */
d1605 3
a1607 2
#define isASCII_LC_uvchr(c)  isASCII_LC(c)
#define isBLANK_LC_uvchr(c)  _generic_LC_uvchr(isBLANK_LC, is_HORIZWS_cp_high, c)
d1611 1
a1611 1
#define isIDCONT_LC_uvchr(c)  _generic_LC_uvchr(isIDCONT_LC,                  \
d1613 1
a1613 1
#define isIDFIRST_LC_uvchr(c)  _generic_LC_uvchr(isIDFIRST_LC,                 \
d1617 1
a1617 2
#define isPSXSPC_LC_uvchr(c) isSPACE_LC_uvchr(c) /* space is identical to posix
                                                    space under locale */
d1619 1
a1619 1
#define isSPACE_LC_uvchr(c)  _generic_LC_uvchr(isSPACE_LC,                     \
d1622 1
a1622 1
#define isWORDCHAR_LC_uvchr(c)  _generic_LC_swash_uvchr(isWORDCHAR_LC,              \
d1624 2
a1625 1
#define isXDIGIT_LC_uvchr(c) _generic_LC_uvchr(isXDIGIT_LC, is_XDIGIT_cp_high, c)
d1627 1
a1627 1
#define isBLANK_LC_uni(c)	isBLANK_LC_uvchr(UNI_TO_NATIVE(c))
d1640 1
a1640 1
                                                TWO_BYTE_UTF8_TO_NATIVE(*(p),  \
d1644 2
a1645 2
/* Like the above, but calls 'above_latin1(p)' to get the utf8 value.  'above_latin1'
 * can be a macro */
d1654 3
a1656 2
 * characters in the range 128-255 which the class is TRUE for.  Hence it can
 * skip the tests for this range.  'above_latin1' should include its arguments */
d1672 3
a1674 3
#define isALPHA_utf8(p)         _generic_swash_utf8(_CC_ALPHA, p)
#define isALPHANUMERIC_utf8(p)  _generic_swash_utf8(_CC_ALPHANUMERIC, p)
#define isASCII_utf8(p)         isASCII(*p) /* Because ASCII is invariant under
d1677 10
a1686 2
#define isBLANK_utf8(p)         _generic_func_utf8(_CC_BLANK, is_HORIZWS_high, p)
#define isCNTRL_utf8(p)         _generic_utf8(_CC_CNTRL, p, 0)
d1699 1
a1699 1
#define isIDFIRST_utf8(p)       _generic_func_utf8(_CC_IDFIRST,               \
d1702 9
a1710 12
#define isLOWER_utf8(p)         _generic_swash_utf8(_CC_LOWER, p)
#define isPRINT_utf8(p)         _generic_swash_utf8(_CC_PRINT, p)

/* Posix and regular space are identical above Latin1 */
#define isPSXSPC_utf8(p)        _generic_func_utf8(_CC_PSXSPC, is_XPERLSPACE_high, p)

#define isPUNCT_utf8(p)         _generic_swash_utf8(_CC_PUNCT, p)
#define isSPACE_utf8(p)         _generic_func_utf8(_CC_SPACE, is_XPERLSPACE_high, p)
#define isUPPER_utf8(p)         _generic_swash_utf8(_CC_UPPER, p)
#define isVERTWS_utf8(p)        _generic_func_utf8(_CC_VERTSPACE, is_VERTWS_high, p)
#define isWORDCHAR_utf8(p)      _generic_swash_utf8(_CC_WORDCHAR, p)
#define isXDIGIT_utf8(p)        _generic_utf8_no_upper_latin1(_CC_XDIGIT, p,   \
d1726 1
a1726 1
                           ? macro(TWO_BYTE_UTF8_TO_NATIVE(*(p), *((p)+1))) \
d1734 1
a1734 1
#define isALPHANUMERIC_LC_utf8(p)  _generic_LC_swash_utf8(isALPHANUMERIC_LC,  \
d1736 18
a1753 15
#define isALPHA_LC_utf8(p)   _generic_LC_swash_utf8(isALPHA_LC, _CC_ALPHA, p)
#define isASCII_LC_utf8(p)   isASCII_LC(*p)
#define isBLANK_LC_utf8(p)   _generic_LC_func_utf8(isBLANK_LC, is_HORIZWS_high, p)
#define isCNTRL_LC_utf8(p)   _generic_LC_utf8(isCNTRL_LC, p, 0)
#define isDIGIT_LC_utf8(p)   _generic_LC_swash_utf8(isDIGIT_LC, _CC_DIGIT, p)
#define isGRAPH_LC_utf8(p)   _generic_LC_swash_utf8(isGRAPH_LC, _CC_GRAPH, p)
#define isIDCONT_LC_utf8(p) _generic_LC_func_utf8(isIDCONT_LC, _is_utf8_perl_idcont, p)
#define isIDFIRST_LC_utf8(p) _generic_LC_func_utf8(isIDFIRST_LC, _is_utf8_perl_idstart, p)
#define isLOWER_LC_utf8(p)   _generic_LC_swash_utf8(isLOWER_LC, _CC_LOWER, p)
#define isPRINT_LC_utf8(p)   _generic_LC_swash_utf8(isPRINT_LC, _CC_PRINT, p)
#define isPSXSPC_LC_utf8(p)  isSPACE_LC_utf8(p) /* space is identical to posix
                                                   space under locale */
#define isPUNCT_LC_utf8(p)   _generic_LC_swash_utf8(isPUNCT_LC, _CC_PUNCT, p)
#define isSPACE_LC_utf8(p)   _generic_LC_func_utf8(isSPACE_LC, is_XPERLSPACE_high, p)
#define isUPPER_LC_utf8(p)   _generic_LC_swash_utf8(isUPPER_LC, _CC_UPPER, p)
d1756 2
a1757 1
#define isXDIGIT_LC_utf8(p)  _generic_LC_func_utf8(isXDIGIT_LC, is_XDIGIT_high, p)
d1761 9
a1769 9
#define isALPHAU(c)     isALPHA_L1(c)
#define isDIGIT_L1(c)   isDIGIT_A(c)
#define isOCTAL(c)      isOCTAL_A(c)
#define isOCTAL_L1(c)   isOCTAL_A(c)
#define isXDIGIT_L1(c)  isXDIGIT_A(c)
#define isALNUM(c)      isWORDCHAR(c)
#define isALNUMU(c)     isWORDCHAR_L1(c)
#define isALNUM_LC(c)   isWORDCHAR_LC(c)
#define isALNUM_uni(c)  isWORDCHAR_uni(c)
d1771 7
a1777 7
#define isALNUM_utf8(p) isWORDCHAR_utf8(p)
#define isALNUM_LC_utf8(p) isWORDCHAR_LC_utf8(p)
#define isALNUMC_A(c)   isALPHANUMERIC_A(c)      /* Mnemonic: "C's alnum" */
#define isALNUMC_L1(c)  isALPHANUMERIC_L1(c)
#define isALNUMC(c)	isALPHANUMERIC(c)
#define isALNUMC_LC(c)	isALPHANUMERIC_LC(c)
#define isALNUMC_uni(c) isALPHANUMERIC_uni(c)
d1779 1
a1779 1
#define isALNUMC_utf8(p) isALPHANUMERIC_utf8(p)
d1789 2
a1790 1
 * The conversion works both ways, so CTRL('D') is 4, and CTRL(4) is D, etc. */
d1792 1
a1792 1
#  define toCTRL(c)    (toUPPER(c) ^ 64)
d1794 8
a1801 5
#  define toCTRL(c)    ((c) == '?'                               \
                        ? LATIN1_TO_NATIVE(0x9F)                 \
                        : (c) == LATIN1_TO_NATIVE(0x9F)          \
                          ? '?'                                  \
                          : (NATIVE_TO_LATIN1(toUPPER(c)) ^ 64))
d1838 19
d1873 1
a1873 1
cast.  See also C<Newx>.
d1879 1
a1879 1
memory is zeroed with C<memzero>.  See also C<Newx>.
d1902 1
a1902 1
C<type> is the type.  Can do overlapping moves.  See also C<Copy>.
d1905 1
a1905 1
Like C<Move> but returns dest.  Useful
d1912 1
a1912 1
C<type> is the type.  May fail on overlapping copies.  See also C<Move>.
d1916 1
a1916 1
Like C<Copy> but returns dest.  Useful
d1960 1
a1960 3
/* The +0.0 in MEM_WRAP_CHECK_ is an attempt to foil
 * overly eager compilers that will bleat about e.g.
 * (U16)n > (size_t)~0/sizeof(U16) always being false. */
d1962 43
a2004 4
#define MEM_WRAP_CHECK(n,t) \
	(void)(UNLIKELY(sizeof(t) > 1 && ((MEM_SIZE)(n)+0.0) > MEM_SIZE_MAX/sizeof(t)) && (croak_memory_wrap(),0))
#define MEM_WRAP_CHECK_1(n,t,a) \
	(void)(UNLIKELY(sizeof(t) > 1 && ((MEM_SIZE)(n)+0.0) > MEM_SIZE_MAX/sizeof(t)) && (Perl_croak_nocontext("%s",(a)),0))
a2051 6
PERL_EXPORT_C Malloc_t Perl_mem_log_alloc(const UV n, const UV typesize, const char *type_name, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);

PERL_EXPORT_C Malloc_t Perl_mem_log_realloc(const UV n, const UV typesize, const char *type_name, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);

PERL_EXPORT_C Malloc_t Perl_mem_log_free(Malloc_t oldalloc, const char *filename, const int linenumber, const char *funcname);

d2180 2
a2181 1
#  define deprecate(s) Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED), "Use of " s " is deprecated")
a2217 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d11 3
d31 2
a32 1
Null character pointer. (No longer available when C<PERL_CORE> is defined.)
d35 1
a35 1
Null SV pointer. (No longer available when C<PERL_CORE> is defined.)
d76 1
a76 1
#ifdef I_STDBOOL
d92 1
d96 1
d113 2
a114 4
# if defined(VMS)
#  define bool int
# else
#  define bool char
d116 1
d120 4
a123 5
/* a simple (bool) cast may not do the right thing: if bool is defined
 * as char for example, then the cast from int is implementation-defined
 * (bool)!!(cbool) in a ternary triggers a bug in xlc on AIX
 */

d133 1
a133 1
#  if (defined(_MSC_VER) && _MSC_VER < 1300) || /* MSVC6 has neither __func__ nor __FUNCTION and no good workarounds, either. */ \
d276 10
d290 2
a291 1
Like C<newSVpvn>, but takes a literal string instead of a string/length pair.
d294 2
a295 2
Like C<newSVpvn_flags>, but takes a literal string instead of a string/length
pair.
d298 2
a299 2
Like C<newSVpvn_share>, but takes a literal string instead of a string/length
pair and omits the hash parameter.
d302 2
a303 2
Like C<sv_catpvn_flags>, but takes a literal string instead of a
string/length pair.
d330 2
a331 1
Like C<savepvn>, but takes a literal string instead of a string/length pair.
d439 1
a439 1
indicates the number of bytes to compare.  Returns true or false. (A
d444 1
a444 1
the number of bytes to compare.  Returns true or false. (A wrapper for
d515 1
a515 1
ASCII and EBCDIC (though it represent different characters in each).
d528 7
a534 6
Variant C<isFOO_LC> is like the C<isFOO_A> and C<isFOO_L1> variants, but uses
the C library function that gives the named classification instead of
hard-coded rules.  For example, C<isDIGIT_LC()> returns the result of calling
C<isdigit()>.  This means that the result is based on the current locale, which
is what C<LC> in the name stands for.  FALSE is always returned if the input
won't fit into an octet.
d572 6
d639 1
a639 1
("Experimentally" means that this change may be backed out in 5.20 or 5.22 if
d653 1
a653 1
may be backed out in 5.20 or 5.22 if field experience indicates that it
d727 114
a840 7
=for apidoc Am|char|toUPPER|char ch
Converts the specified character to uppercase, if possible; otherwise returns
the input character itself.

=for apidoc Am|char|toLOWER|char ch
Converts the specified character to lowercase, if possible; otherwise returns
the input character itself.
d844 2
a845 1
XXX Still undocumented isVERTWS_uni and _utf8, and the other toUPPER etc functions
d871 9
a879 1
#   define isASCII(c)    (FITS_IN_8_BITS(c) && (NATIVE_TO_UNI((U8) (c)) < 128))
d937 2
a938 1
 * structures in regcomp.[ch] and regexec.c */
d1015 3
d1021 3
d1025 1
a1025 1
                && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_mask(classnum)))
d1031 5
a1035 4
    /* The _A version makes sure that both the desired bit and the ASCII bit
     * are present */
#   define _generic_isCC_A(c, classnum) (FITS_IN_8_BITS(c) \
        && ((PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_mask_A(classnum)) \
d1052 18
a1069 1
#   define isIDFIRST_A(c) _generic_isCC_A(c, ( _CC_IDFIRST))
d1073 1
a1073 1
#   define _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(c) ((! cBOOL(FITS_IN_8_BITS(c))) || (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_mask(_CC_NONLATIN1_FOLD)))
d1080 11
a1090 1
#else   /* No perl.h. */
d1092 14
a1105 16
#       define isALPHA_A(c)    (isASCII(c) && isALPHA(c))
#       define isALPHANUMERIC_A(c) (isASCII(c) && isALPHANUMERIC(c))
#       define isBLANK_A(c)    (isASCII(c) && isBLANK(c))
#       define isCNTRL_A(c)    (isASCII(c) && isCNTRL(c))
#       define isDIGIT_A(c)    (isASCII(c) && isDIGIT(c))
#       define isGRAPH_A(c)    (isASCII(c) && isGRAPH(c))
#       define isIDFIRST_A(c)  (isASCII(c) && isIDFIRST(c))
#       define isLOWER_A(c)    (isASCII(c) && isLOWER(c))
#       define isPRINT_A(c)    (isASCII(c) && isPRINT(c))
#       define isPSXSPC_A(c)   (isASCII(c) && isPSXSPC(c))
#       define isPUNCT_A(c)    (isASCII(c) && isPUNCT(c))
#       define isSPACE_A(c)    (isASCII(c) && isSPACE(c))
#       define isUPPER_A(c)    (isASCII(c) && isUPPER(c))
#       define isWORDCHAR_A(c) (isASCII(c) && isWORDCHAR(c))
#       define isXDIGIT_A(c)   (isASCII(c) && isXDIGIT(c))
#   else   /* ASCII platform, no perl.h */
d1108 1
a1108 2
#       define isBLANK_A(c)  ((c) == ' ' || (c) == '\t')
#       define isCNTRL_A(c) (FITS_IN_8_BITS(c) && ((U8) (c) < ' ' || (c) == 127))
d1110 1
a1110 2
#       define isGRAPH_A(c)  (isWORDCHAR_A(c) || isPUNCT_A(c))
#       define isIDFIRST_A(c) (isALPHA_A(c) || (c) == '_')
d1113 6
a1118 9
#       define isPSXSPC_A(c) (isSPACE_A(c) || (c) == '\v')
#       define isPUNCT_A(c)  (((c) >= 33 && (c) <= 47)              \
                              || ((c) >= 58 && (c) <= 64)           \
                              || ((c) >= 91 && (c) <= 96)           \
                              || ((c) >= 123 && (c) <= 126))
#       define isSPACE_A(c)  ((c) == ' '                            \
                              || (c) == '\t'                        \
                              || (c) == '\n'                        \
                              || (c) =='\r'                         \
d1121 119
a1239 6
#       define isWORDCHAR_A(c) (isALPHA_A(c) || isDIGIT_A(c) || (c) == '_')
#       define isXDIGIT_A(c)   (isDIGIT_A(c)                        \
                                || ((c) >= 'a' && (c) <= 'f')       \
                                || ((c) <= 'F' && (c) >= 'A'))
#   endif
#endif  /* ASCII range definitions */
d1241 7
a1247 5
/* Latin1 definitions */
#ifdef H_PERL
#   define isALPHA_L1(c)  _generic_isCC(c, _CC_ALPHA)
#   define isALPHANUMERIC_L1(c) _generic_isCC(c, _CC_ALPHANUMERIC)
#   define isBLANK_L1(c)  _generic_isCC(c, _CC_BLANK)
d1249 1
a1249 2
/*  continuation character for legal NAME in \N{NAME} */
#   define isCHARNAME_CONT(c) _generic_isCC(c, _CC_CHARNAME_CONT)
d1251 75
a1325 78
#   define isCNTRL_L1(c)  _generic_isCC(c, _CC_CNTRL)
#   define isGRAPH_L1(c)  _generic_isCC(c, _CC_GRAPH)
#   define isLOWER_L1(c)  _generic_isCC(c, _CC_LOWER)
#   define isPRINT_L1(c)  _generic_isCC(c, _CC_PRINT)
#   define isPSXSPC_L1(c) _generic_isCC(c, _CC_PSXSPC)
#   define isPUNCT_L1(c)  _generic_isCC(c, _CC_PUNCT)
#   define isSPACE_L1(c)  _generic_isCC(c, _CC_SPACE)
#   define isUPPER_L1(c)  _generic_isCC(c, _CC_UPPER)
#   define isWORDCHAR_L1(c) _generic_isCC(c, _CC_WORDCHAR)
#   define isIDFIRST_L1(c) _generic_isCC(c, _CC_IDFIRST)
#else /* No access to perl.h.  Only a few provided here, just in case needed
       * for backwards compatibility */
    /* ALPHAU includes Unicode semantics for latin1 characters.  It has an extra
     * >= AA test to speed up ASCII-only tests at the expense of the others */
#   define isALPHA_L1(c) (isALPHA(c) || (NATIVE_TO_UNI((U8) c) >= 0xAA \
	&& ((NATIVE_TO_UNI((U8) c) >= 0xC0 \
             && NATIVE_TO_UNI((U8) c) != 0xD7 && NATIVE_TO_UNI((U8) c) != 0xF7) \
	    || NATIVE_TO_UNI((U8) c) == 0xAA \
	    || NATIVE_TO_UNI((U8) c) == 0xB5 \
	    || NATIVE_TO_UNI((U8) c) == 0xBA)))
#   define isCHARNAME_CONT(c) (isWORDCHAR_L1(c)                         \
                               || (c) == ' '                            \
                               || (c) == '-'                            \
                               || (c) == '('                            \
                               || (c) == ')'                            \
                               || (c) == ':'                            \
                               || NATIVE_TO_UNI((U8) c) == 0xA0)
#endif

/* Macros that differ between EBCDIC and ASCII.  Where C89 defines a function,
 * that is used in the EBCDIC form, because in EBCDIC we do not do locales:
 * therefore can use native functions.  For those where C89 doesn't define a
 * function, use our function, assuming that the EBCDIC code page is isomorphic
 * with Latin1, which the three currently recognized by Perl are.  Some libc's
 * have an isblank(), but it's not guaranteed. */
#ifdef EBCDIC
#   define isALPHA(c)	isalpha(c)
#   define isALPHANUMERIC(c)	isalnum(c)
#   define isBLANK(c)	((c) == ' ' || (c) == '\t' || NATIVE_TO_UNI(c) == 0xA0)
#   define isCNTRL(c)	iscntrl(c)
#   define isDIGIT(c)	isdigit(c)
#   define isGRAPH(c)	isgraph(c)
#   define isIDFIRST(c) (isALPHA(c) || (c) == '_')
#   define isLOWER(c)	islower(c)
#   define isPRINT(c)	isprint(c)
#   define isPSXSPC(c)	isspace(c)
#   define isPUNCT(c)	ispunct(c)
#   define isSPACE(c)   (isPSXSPC(c) /* && (c) != '\v' (Experimentally making
                                        these macros identical) */)
#   define isUPPER(c)	isupper(c)
#   define isXDIGIT(c)	isxdigit(c)
#   define isWORDCHAR(c) (isalnum(c) || (c) == '_')
#   define toLOWER(c)	tolower(c)
#   define toUPPER(c)	toupper(c)
#else /* Not EBCDIC: ASCII-only matching */
#   define isALPHANUMERIC(c)  isALPHANUMERIC_A(c)
#   define isALPHA(c)   isALPHA_A(c)
#   define isBLANK(c)   isBLANK_A(c)
#   define isCNTRL(c)   isCNTRL_A(c)
#   define isDIGIT(c)   isDIGIT_A(c)
#   define isGRAPH(c)   isGRAPH_A(c)
#   define isIDFIRST(c) isIDFIRST_A(c)
#   define isLOWER(c)   isLOWER_A(c)
#   define isPRINT(c)   isPRINT_A(c)
#   define isPSXSPC(c)	isPSXSPC_A(c)
#   define isPUNCT(c)   isPUNCT_A(c)
#   define isSPACE(c)   isSPACE_A(c)
#   define isUPPER(c)   isUPPER_A(c)
#   define isWORDCHAR(c) isWORDCHAR_A(c)
#   define isXDIGIT(c)  isXDIGIT_A(c)

    /* ASCII casing.  These could also be written as
	#define toLOWER(c) (isASCII(c) ? toLOWER_LATIN1(c) : (c))
	#define toUPPER(c) (isASCII(c) ? toUPPER_LATIN1_MOD(c) : (c))
       which uses table lookup and mask instead of subtraction.  (This would
       work because the _MOD does not apply in the ASCII range) */
#   define toLOWER(c)	(isUPPER(c) ? (c) + ('a' - 'A') : (c))
#   define toUPPER(c)	(isLOWER(c) ? (c) - ('a' - 'A') : (c))
d1328 28
d1357 1
a1357 33
/* Use table lookup for speed; return error character for input
 * out-of-range */
#define toLOWER_LATIN1(c)    (FITS_IN_8_BITS(c)                            \
                             ? UNI_TO_NATIVE(PL_latin1_lc[                 \
                                               NATIVE_TO_UNI( (U8) (c)) ]) \
                             : UNICODE_REPLACEMENT)
/* Modified uc.  Is correct uc except for three non-ascii chars which are
 * all mapped to one of them, and these need special handling; error
 * character for input out-of-range */
#define toUPPER_LATIN1_MOD(c) (FITS_IN_8_BITS(c)                           \
                              ? UNI_TO_NATIVE(PL_mod_latin1_uc[            \
                                               NATIVE_TO_UNI( (U8) (c)) ]) \
                              : UNICODE_REPLACEMENT)

#ifdef USE_NEXT_CTYPE

#  define isALPHANUMERIC_LC(c)	NXIsAlNum((unsigned int)(c))
#  define isALPHA_LC(c)		NXIsAlpha((unsigned int)(c))
#  define isASCII_LC(c)		isASCII((unsigned int)(c))
#  define isBLANK_LC(c)		isBLANK((unsigned int)(c))
#  define isCNTRL_LC(c)		NXIsCntrl((unsigned int)(c))
#  define isDIGIT_LC(c)		NXIsDigit((unsigned int)(c))
#  define isGRAPH_LC(c)		NXIsGraph((unsigned int)(c))
#  define isIDFIRST_LC(c) (NXIsAlpha((unsigned int)(c)) || (char)(c) == '_')
#  define isLOWER_LC(c)		NXIsLower((unsigned int)(c))
#  define isPRINT_LC(c)		NXIsPrint((unsigned int)(c))
#  define isPUNCT_LC(c)		NXIsPunct((unsigned int)(c))
#  define isSPACE_LC(c)		NXIsSpace((unsigned int)(c))
#  define isUPPER_LC(c)		NXIsUpper((unsigned int)(c))
#  define isWORDCHAR_LC(c) (NXIsAlNum((unsigned int)(c)) || (char)(c) == '_')
#  define isXDIGIT_LC(c)        NXIsXDigit((unsigned int)(c))
#  define toLOWER_LC(c)		NXToLower((unsigned int)(c))
#  define toUPPER_LC(c)		NXToUpper((unsigned int)(c))
d1359 1
a1359 1
#else /* !USE_NEXT_CTYPE */
d1362 1
d1364 18
a1381 30
/* Use foo_LC_uvchr() instead  of these for beyond the Latin1 range */

#    define isALPHA_LC(c)   (FITS_IN_8_BITS(c) && isalpha((unsigned char)(c)))
#    define isALPHANUMERIC_LC(c)   (FITS_IN_8_BITS(c)                          \
                                               && isalnum((unsigned char)(c)))
#    ifdef HAS_ISASCII
#	define isASCII_LC(c) (FITS_IN_8_BITS(c) && isascii((unsigned char)(c)))
#    else
#	define isASCII_LC(c) (FITS_IN_8_BITS(c) && isASCII((unsigned char)(c)))
#    endif
#    ifdef HAS_ISBLANK
#	define isBLANK_LC(c) (FITS_IN_8_BITS(c) && isblank((unsigned char)(c)))
#    else
#	define isBLANK_LC(c) (FITS_IN_8_BITS(c) && isBLANK((unsigned char)(c)))
#    endif
#    define isCNTRL_LC(c)    (FITS_IN_8_BITS(c) && iscntrl((unsigned char)(c)))
#    define isDIGIT_LC(c)    (FITS_IN_8_BITS(c) && isdigit((unsigned char)(c)))
#    define isGRAPH_LC(c)    (FITS_IN_8_BITS(c) && isgraph((unsigned char)(c)))
#    define isIDFIRST_LC(c) (FITS_IN_8_BITS(c)                                 \
                            && (isalpha((unsigned char)(c)) || (char)(c) == '_'))
#    define isLOWER_LC(c)    (FITS_IN_8_BITS(c) && islower((unsigned char)(c)))
#    define isPRINT_LC(c)    (FITS_IN_8_BITS(c) && isprint((unsigned char)(c)))
#    define isPUNCT_LC(c)    (FITS_IN_8_BITS(c) && ispunct((unsigned char)(c)))
#    define isSPACE_LC(c)    (FITS_IN_8_BITS(c) && isspace((unsigned char)(c)))
#    define isUPPER_LC(c)    (FITS_IN_8_BITS(c) && isupper((unsigned char)(c)))
#    define isWORDCHAR_LC(c) (FITS_IN_8_BITS(c)                                \
                            && (isalnum((unsigned char)(c)) || (char)(c) == '_'))
#    define isXDIGIT_LC(c)   (FITS_IN_8_BITS(c) && isxdigit((unsigned char)(c)))
#    define toLOWER_LC(c) (FITS_IN_8_BITS(c) ? tolower((unsigned char)(c)) : (c))
#    define toUPPER_LC(c) (FITS_IN_8_BITS(c) ? toupper((unsigned char)(c)) : (c))
d1383 1
a1383 1
#  else
a1386 6
#    define isASCII_LC(c)	isascii(c)
#    ifdef HAS_ISBLANK
#	define isBLANK_LC(c)	(isascii(c) && isblank(c))
#    else
#	define isBLANK_LC(c)	isBLANK_A(c)
#    endif
d1398 1
d1401 1
d1412 12
a1423 5
/* For internal core Perl use only.  If the input is Latin1, use the Latin1
 * macro; otherwise use the function 'above_latin1'.  Won't compile if 'c' isn't unsigned, as
 * won't match above_latin1 prototype. The macros do bounds checking, so have
 * duplicate checks here, so could create versions of the macros that don't,
 * but experiments show that gcc optimizes them out anyway. */
d1459 5
a1492 1

d1495 7
a1501 9
/* Everything whose name begins with an underscore is for internal core Perl
 * use only. */

/* If the input is in the Latin1 range, use
 * the Latin1 macro 'classnum' on 'p' which is a pointer to a UTF-8 string.
 * Otherwise use the value given by the 'utf8' parameter.  This relies on the
 * fact that ASCII characters have the same representation whether utf8 or not.
 * Note that it assumes that the utf8 has been validated, and ignores 'use
 * bytes' */
d1506 1
a1506 1
                                                   TWO_BYTE_UTF8_TO_UNI(*(p),  \
d1508 1
a1508 1
                                                   classnum)                   \
d1514 1
a1514 1
/* Like the above, but passes classnum to _isFOO_utf8(), instead of having a
d1522 1
a1522 1
#define _generic_utf8_no_upper_latin1(classnum, p, above_latin1)                   \
d1526 1
a1526 1
                                           ? above_latin1                          \
d1573 1
d1578 9
a1586 10
/* For internal core Perl use only.  If the input is in the Latin1 range, use
 * the macro 'macro' on 'p' which is a pointer to a UTF-8 string.  Otherwise
 * use the value given by the 'utf8' parameter.  This relies on the fact that
 * ASCII characters have the same representation whether utf8 or not.  Note
 * that it assumes that the utf8 has been validated, and ignores 'use bytes' */
#define _generic_LC_utf8(macro, p, utf8)                                   \
                         (UTF8_IS_INVARIANT(*(p))                          \
                         ? macro(*(p))                                     \
                         : (UTF8_IS_DOWNGRADEABLE_START(*(p)))             \
                           ? macro(TWO_BYTE_UTF8_TO_UNI(*(p), *((p)+1)))   \
d1592 1
a1592 1
                    _generic_LC_utf8(macro, p, above_latin1(p))
d1638 17
a1654 5
/* This conversion works both ways, strangely enough. On EBCDIC platforms,
 * CTRL-@@ is 0, CTRL-A is 1, etc, just like on ASCII, except that they don't
 * necessarily mean the same characters, e.g. CTRL-D is 4 on both systems, but
 * that is EOT on ASCII;  ST on EBCDIC */
#  define toCTRL(c)    (toUPPER(NATIVE_TO_UNI(c)) ^ 64)
d1673 16
a1688 1
#define READ_XDIGIT(s) (isALPHA(*(s)) ? ((*(s)++ + 9) & 0xf) : (*(s)++ & 0xf))
d1696 2
d1708 2
d1714 2
d1719 2
d1725 2
d1730 2
d1738 2
a1739 1
Like C<Move> but returns dest. Useful for encouraging compilers to tail-call
d1749 2
a1750 1
Like C<Copy> but returns dest. Useful for encouraging compilers to tail-call
d1760 2
a1761 1
Like C<Zero> but returns dest. Useful for encouraging compilers to tail-call
d1798 1
a1798 1
	(void)(sizeof(t) > 1 && ((MEM_SIZE)(n)+0.0) > MEM_SIZE_MAX/sizeof(t) && (Perl_croak_memory_wrap(),0))
d1800 1
a1800 1
	(void)(sizeof(t) > 1 && ((MEM_SIZE)(n)+0.0) > MEM_SIZE_MAX/sizeof(t) && (Perl_croak_nocontext("%s",(a)),0))
d1803 1
a1803 1
#define PERL_STRLEN_ROUNDUP(n) ((void)(((n) > MEM_SIZE_MAX - 2 * PERL_STRLEN_ROUNDUP_QUANTUM) ?  (Perl_croak_memory_wrap(),0):0),((n-1+PERL_STRLEN_ROUNDUP_QUANTUM)&~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM-1)))
d1929 6
d1941 5
d1947 1
a1947 1
#define C_ARRAY_END(a)		(a) + (sizeof(a)/sizeof((a)[0]))
d1983 31
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d4 1
a4 1
 *    2001, 2002, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d11 3
a17 1
#ifndef I286
a18 3
#else
#  define NULL 0L
#endif
d107 1
a107 1
# if defined(UTS) || defined(VMS)
d129 1
a129 1
#  if (defined(_MSC_VER) && _MSC_VER < 1300) || /* Pre-MSVC 7.0 has neither __func__ nor __FUNCTION and no good workarounds, either. */ \
d193 7
a199 4
#   ifndef UINT64_C /* usually from <inttypes.h> */
#       if defined(HAS_LONG_LONG) && QUADKIND == QUAD_IS_LONG_LONG
#           define INT64_C(c)	CAT2(c,LL)
#           define UINT64_C(c)	CAT2(c,ULL)
d202 2
a203 2
#               define INT64_C(c)	CAT2(c,L)
#               define UINT64_C(c)	CAT2(c,UL)
d205 2
a206 7
#               if defined(_WIN64) && defined(_MSC_VER)
#                   define INT64_C(c)	CAT2(c,I64)
#                   define UINT64_C(c)	CAT2(c,UI64)
#               else
#                   define INT64_C(c)	((I64TYPE)(c))
#                   define UINT64_C(c)	((U64TYPE)(c))
#               endif
d210 6
d345 2
a346 1
/* concatenating with "" ensures that only literal strings are accepted as argument */
d349 3
a351 3
/* note that STR_WITH_LEN() can't be used as argument to macros or functions that
 * under some configurations might be macros, which means that it requires the full
 * Perl_xxx(aTHX_ ...) form for any API calls where it's used.
d477 50
a526 19
There are three variants for all the functions in this section.  The base ones
operate using the character set of the platform Perl is running on.  The ones
with an C<_A> suffix operate on the ASCII character set, and the ones with an
C<_L1> suffix operate on the full Latin1 character set.  All are unaffected by
locale and by C<use bytes>.

For ASCII platforms, the base function with no suffix and the one with the
C<_A> suffix are identical.  The function with the C<_L1> suffix imposes the
Latin-1 character set onto the platform.  That is, the code points that are
ASCII are unaffected, since ASCII is a subset of Latin-1.  But the non-ASCII
code points are treated as if they are Latin-1 characters.  For example,
C<isSPACE_L1()> will return true when called with the code point 0xA0, which is
the Latin-1 NO-BREAK SPACE.

For EBCDIC platforms, the base function with no suffix and the one with the
C<_L1> suffix should be identical, since, as of this writing, the EBCDIC code
pages that Perl knows about all are equivalent to Latin-1.  The function that
ends in an C<_A> suffix will not return true unless the specified character also
has an ASCII equivalent.
d530 8
a537 1
alphabetic character in the platform's native character set.
d539 3
a541 1
C<isALPHA_A> and C<isALPHA_L1>.
d545 2
a546 1
characters in the ASCII character set.  On non-ASCII platforms, it is if this
d549 23
d575 1
a575 1
digit in the platform's native character set.
d577 10
d590 1
a590 1
lowercase character in the platform's native character set.
d592 2
a593 1
C<isLOWER_A> and C<isLOWER_L1>.
d597 13
a609 2
octal digit, [0-7] in the platform's native character set.
Variants C<isOCTAL_A> and C<isOCTAL_L1> are identical to C<isOCTAL>.
d613 9
a621 2
whitespace character in the platform's native character set.  This is the same
as what C<\s> matches in a regular expression.
d623 18
a640 1
C<isSPACE_A> and C<isSPACE_L1>.
d644 8
a651 1
uppercase character in the platform's native character set.
d653 2
a654 1
C<isUPPER_A> and C<isUPPER_L1>.
d657 8
a664 6
Returns a boolean indicating whether the specified character is a
character that is any of: alphabetic, numeric, or an underscore.  This is the
same as what C<\w> matches in a regular expression.
C<isALNUM()> is a synonym provided for backward compatibility.  Note that it
does not have the standard C language meaning of alphanumeric, since it matches
an underscore and the standard meaning does not.
d666 2
a667 1
C<isWORDCHAR_A> and C<isWORDCHAR_L1>.
d671 30
a700 2
digit, [0-9A-Fa-f].  Variants C<isXDIGIT_A()> and C<isXDIGIT_L1()> are
identical to C<isXDIGIT()>.
d705 2
a706 2
Converts the specified character to uppercase in the platform's native
character set, if possible; otherwise returns the input character itself.
d709 2
a710 2
Converts the specified character to lowercase in the platform's native
character set, if possible; otherwise returns the input character itself.
d714 2
d748 5
d755 111
a865 41
/* Bits for PL_charclass[].  These use names used in l1_char_class_tab.h but
 * their actual definitions are here.  If that has a name not used here, it
 * won't compile. */
#  define _CC_ALNUMC_A         (1<<0)
#  define _CC_ALNUMC_L1        (1<<1)
#  define _CC_ALPHA_A          (1<<2)
#  define _CC_ALPHA_L1         (1<<3)
#  define _CC_BLANK_A          (1<<4)
#  define _CC_BLANK_L1         (1<<5)
#  define _CC_CHARNAME_CONT    (1<<6)
#  define _CC_CNTRL_A          (1<<7)
#  define _CC_CNTRL_L1         (1<<8)
#  define _CC_DIGIT_A          (1<<9)
#  define _CC_GRAPH_A          (1<<10)
#  define _CC_GRAPH_L1         (1<<11)
#  define _CC_IDFIRST_A        (1<<12)
#  define _CC_IDFIRST_L1       (1<<13)
#  define _CC_LOWER_A          (1<<14)
#  define _CC_LOWER_L1         (1<<15)
#  define _CC_OCTAL_A          (1<<16)
#  define _CC_PRINT_A          (1<<17)
#  define _CC_PRINT_L1         (1<<18)
#  define _CC_PSXSPC_A         (1<<19)
#  define _CC_PSXSPC_L1        (1<<20)
#  define _CC_PUNCT_A          (1<<21)
#  define _CC_PUNCT_L1         (1<<22)
#  define _CC_SPACE_A          (1<<23)
#  define _CC_SPACE_L1         (1<<24)
#  define _CC_UPPER_A          (1<<25)
#  define _CC_UPPER_L1         (1<<26)
#  define _CC_WORDCHAR_A       (1<<27)
#  define _CC_WORDCHAR_L1      (1<<28)
#  define _CC_XDIGIT_A         (1<<29)
#  define _CC_NONLATIN1_FOLD   (1<<30)
#  define _CC_QUOTEMETA        (1U<<31)	/* 1U keeps Solaris from griping */
/* Unused: None
 * If more are needed, can give up some of the above.  The first ones to go
 * would be those that require just two tests to verify, either there are two
 * code points, like BLANK_A, or occupy a single range like OCTAL_A, DIGIT_A,
 * UPPER_A, and LOWER_A.
 */
d876 31
a906 16
#   define isALNUMC_A(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_ALNUMC_A))
#   define isALPHA_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_ALPHA_A))
#   define isBLANK_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_BLANK_A))
#   define isCNTRL_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_CNTRL_A))
#   define isDIGIT_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_DIGIT_A))
#   define isGRAPH_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_GRAPH_A))
#   define isIDFIRST_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_IDFIRST_A))
#   define isLOWER_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_LOWER_A))
#   define isOCTAL_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_OCTAL_A))
#   define isPRINT_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_PRINT_A))
#   define isPSXSPC_A(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_PSXSPC_A))
#   define isPUNCT_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_PUNCT_A))
#   define isSPACE_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_SPACE_A))
#   define isUPPER_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_UPPER_A))
#   define isWORDCHAR_A(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_WORDCHAR_A))
#   define isXDIGIT_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_XDIGIT_A))
d909 7
a915 2
#   define _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(c) ((! cBOOL(FITS_IN_8_BITS(c))) || (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_NONLATIN1_FOLD))
#   define _isQUOTEMETA(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_QUOTEMETA))
a916 1
#   define isOCTAL_A(c)  ((c) <= '7' && (c) >= '0')
a917 1
#       define isALNUMC_A(c)   (isASCII(c) && isALNUMC(c))
d919 1
a933 1
#       define isALNUMC_A(c) (isALPHA_A(c) || isDIGIT_A(c))
d935 1
d937 1
a937 1
#       define isCNTRL_A(c)  (FITS_IN_8_BITS(c) && ((U8) (c) < ' ' || (c) == 127))
d944 9
a952 2
#       define isPUNCT_A(c)  (((c) >= 33 && (c) <= 47) || ((c) >= 58 && (c) <= 64)  || ((c) >= 91 && (c) <= 96) || ((c) >= 123 && (c) <= 126))
#       define isSPACE_A(c)  ((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) =='\r' || (c) == '\f')
d955 3
a957 1
#       define isXDIGIT_A(c)   (isDIGIT_A(c) || ((c) >= 'a' && (c) <= 'f') || ((c) <= 'F' && (c) >= 'A'))
d963 4
a966 3
#   define isALNUMC_L1(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_ALNUMC_L1))
#   define isALPHA_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_ALPHA_L1))
#   define isBLANK_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_BLANK_L1))
d968 12
a979 11
#   define isCHARNAME_CONT(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_CHARNAME_CONT))
#   define isCNTRL_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_CNTRL_L1))
#   define isGRAPH_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_GRAPH_L1))
#   define isIDFIRST_L1(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_IDFIRST_L1))
#   define isLOWER_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_LOWER_L1))
#   define isPRINT_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_PRINT_L1))
#   define isPSXSPC_L1(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_PSXSPC_L1))
#   define isPUNCT_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_PUNCT_L1))
#   define isSPACE_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_SPACE_L1))
#   define isUPPER_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_UPPER_L1))
#   define isWORDCHAR_L1(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_WORDCHAR_L1))
d986 1
a986 1
		&& NATIVE_TO_UNI((U8) c) != 0xD7 && NATIVE_TO_UNI((U8) c) != 0xF7) \
d990 7
a996 1
#   define isCHARNAME_CONT(c) (isALNUM_L1(c) || (c) == ' ' || (c) == '-' || (c) == '(' || (c) == ')' || (c) == ':' || NATIVE_TO_UNI((U8) c) == 0xA0)
a998 10
/* Macros for backwards compatibility and for completeness when the ASCII and
 * Latin1 values are identical */
#define isALNUM(c)      isWORDCHAR(c)
#define isALNUMU(c)     isWORDCHAR_L1(c)
#define isALPHAU(c)     isALPHA_L1(c)
#define isDIGIT_L1(c)   isDIGIT_A(c)
#define isOCTAL(c)      isOCTAL_A(c)
#define isOCTAL_L1(c)   isOCTAL_A(c)
#define isXDIGIT_L1(c)  isXDIGIT_A(c)

a1005 1
#   define isALNUMC(c)	isalnum(c)
d1007 1
d1017 2
a1018 1
#   define isSPACE(c)   (isPSXSPC(c) && (c) != '\v')
d1025 1
a1025 1
#   define isALNUMC(c)  isALNUMC_A(c)
d1067 1
a1067 4
#  define isALNUM_LC(c) \
	(NXIsAlNum((unsigned int)(c)) || (char)(c) == '_')
#  define isIDFIRST_LC(c) \
	(NXIsAlpha((unsigned int)(c)) || (char)(c) == '_')
d1071 1
a1071 1
#  define isSPACE_LC(c)		NXIsSpace((unsigned int)(c))
d1073 2
a1074 1
#  define isUPPER_LC(c)		NXIsUpper((unsigned int)(c))
a1075 3
#  define isALNUMC_LC(c)	NXIsAlNum((unsigned int)(c))
#  define isCNTRL_LC(c)		NXIsCntrl((unsigned int)(c))
#  define isGRAPH_LC(c)		NXIsGraph((unsigned int)(c))
d1078 5
a1083 1
#  define toLOWER_LC(c)		NXToLower((unsigned int)(c))
d1089 5
a1093 7
/* Note that the foo_LC() macros in this case generally are defined only on
 * code points 0-256, and give undefined, unwarned results if called with
 * values outside that range */

#    define isALNUM_LC(c)   (isalnum((unsigned char)(c)) || (char)(c) == '_')
#    define isIDFIRST_LC(c) (isalpha((unsigned char)(c)) || (char)(c) == '_')
#    define isALPHA_LC(c)	isalpha((unsigned char)(c))
d1095 1
a1095 1
#	define isASCII_LC(c)	isascii((unsigned char)(c))
d1097 1
a1097 1
#	define isASCII_LC(c)	isASCII((unsigned char)(c))
d1100 1
a1100 1
#	define isBLANK_LC(c)	isblank((unsigned char)(c))
d1102 1
a1102 1
#	define isBLANK_LC(c)	isBLANK((unsigned char)(c))
d1104 15
a1118 11
#    define isSPACE_LC(c)	isspace((unsigned char)(c))
#    define isDIGIT_LC(c)	isdigit((unsigned char)(c))
#    define isUPPER_LC(c)	isupper((unsigned char)(c))
#    define isLOWER_LC(c)	islower((unsigned char)(c))
#    define isALNUMC_LC(c)	isalnum((unsigned char)(c))
#    define isCNTRL_LC(c)	iscntrl((unsigned char)(c))
#    define isGRAPH_LC(c)	isgraph((unsigned char)(c))
#    define isPRINT_LC(c)	isprint((unsigned char)(c))
#    define isPUNCT_LC(c)	ispunct((unsigned char)(c))
#    define toUPPER_LC(c)	toupper((unsigned char)(c))
#    define toLOWER_LC(c)	tolower((unsigned char)(c))
a1121 2
#    define isALNUM_LC(c)	(isascii(c) && (isalnum(c) || (c) == '_'))
#    define isIDFIRST_LC(c)	(isascii(c) && (isalpha(c) || (c) == '_'))
d1123 1
d1128 1
a1128 1
#	define isBLANK_LC(c)	isBLANK(c)
d1130 1
a1130 1
#    define isSPACE_LC(c)	(isascii(c) && isspace(c))
d1132 2
a1133 1
#    define isUPPER_LC(c)	(isascii(c) && isupper(c))
a1134 3
#    define isALNUMC_LC(c)	(isascii(c) && isalnum(c))
#    define isCNTRL_LC(c)	(isascii(c) && iscntrl(c))
#    define isGRAPH_LC(c)	(isascii(c) && isgraph(c))
d1137 6
a1142 2
#    define toUPPER_LC(c)	toupper(c)
#    define toLOWER_LC(c)	tolower(c)
d1147 11
a1157 1
#define isPSXSPC_LC(c)		(isSPACE_LC(c) || (c) == '\v')
a1158 9
/* For use in the macros just below.  If the input is Latin1, use the Latin1
 * (_L1) version of the macro; otherwise use the function.  Won't compile if
 * 'c' isn't unsigned, as won't match function prototype. The macros do bounds
 * checking, so have duplicate checks here, so could create versions of the
 * macros that don't, but experiments show that gcc optimizes them out anyway.
 */
#define generic_uni(macro, function, c) ((c) < 256               \
                                         ? CAT2(macro, _L1)(c)   \
                                         : function(c))
d1160 27
d1188 3
a1190 14
#define isALNUM_uni(c)		generic_uni(isWORDCHAR, is_uni_alnum, c)
#define isIDFIRST_uni(c)        generic_uni(isIDFIRST, is_uni_idfirst, c)
#define isALPHA_uni(c)		generic_uni(isALPHA, is_uni_alpha, c)
#define isSPACE_uni(c)		generic_uni(isSPACE, is_uni_space, c)
#define isDIGIT_uni(c)		generic_uni(isDIGIT, is_uni_digit, c)
#define isUPPER_uni(c)		generic_uni(isUPPER, is_uni_upper, c)
#define isLOWER_uni(c)		generic_uni(isLOWER, is_uni_lower, c)
#define isASCII_uni(c)		isASCII(c)
/* All controls are in Latin1 */
#define isCNTRL_uni(c)		((c) < 256 && isCNTRL_L1(c))
#define isGRAPH_uni(c)		generic_uni(isGRAPH, is_uni_graph, c)
#define isPRINT_uni(c)		generic_uni(isPRINT, is_uni_print, c)
#define isPUNCT_uni(c)		generic_uni(isPUNCT, is_uni_punct, c)
#define isXDIGIT_uni(c)		generic_uni(isXDIGIT, is_uni_xdigit, c)
a1191 3
#define toTITLE_uni(c,s,l)	to_uni_title(c,s,l)
#define toLOWER_uni(c,s,l)	to_uni_lower(c,s,l)
#define toFOLD_uni(c,s,l)	to_uni_fold(c,s,l)
d1193 43
a1235 26
/* Posix and regular space differ only in U+000B, which is in Latin1 */
#define isPSXSPC_uni(c)		((c) < 256 ? isPSXSPC_L1(c) : isSPACE_uni(c))
#define isBLANK_uni(c)		isBLANK(c) /* could be wrong */

#define isALNUM_LC_uvchr(c)	(c < 256 ? isALNUM_LC(c) : is_uni_alnum_lc(c))
#define isIDFIRST_LC_uvchr(c)	(c < 256 ? isIDFIRST_LC(c) : is_uni_idfirst_lc(c))
#define isALPHA_LC_uvchr(c)	(c < 256 ? isALPHA_LC(c) : is_uni_alpha_lc(c))
#define isSPACE_LC_uvchr(c)	(c < 256 ? isSPACE_LC(c) : is_uni_space_lc(c))
#define isDIGIT_LC_uvchr(c)	(c < 256 ? isDIGIT_LC(c) : is_uni_digit_lc(c))
#define isUPPER_LC_uvchr(c)	(c < 256 ? isUPPER_LC(c) : is_uni_upper_lc(c))
#define isLOWER_LC_uvchr(c)	(c < 256 ? isLOWER_LC(c) : is_uni_lower_lc(c))
#define isCNTRL_LC_uvchr(c)	(c < 256 ? isCNTRL_LC(c) : is_uni_cntrl_lc(c))
#define isGRAPH_LC_uvchr(c)	(c < 256 ? isGRAPH_LC(c) : is_uni_graph_lc(c))
#define isPRINT_LC_uvchr(c)	(c < 256 ? isPRINT_LC(c) : is_uni_print_lc(c))
#define isPUNCT_LC_uvchr(c)	(c < 256 ? isPUNCT_LC(c) : is_uni_punct_lc(c))

#define isPSXSPC_LC_uni(c)	(isSPACE_LC_uni(c) ||(c) == '\f')
#define isBLANK_LC_uni(c)	isBLANK(c) /* could be wrong */

/* For use in the macros just below.  If the input is ASCII, use the ASCII (_A)
 * version of the macro; if the input is in the upper Latin1 range, use the
 * Latin1 (_L1) version of the macro, after converting from utf8; otherwise use
 * the function.  This relies on the fact that ASCII characters have the same
 * representation whether utf8 or not */
#define generic_utf8(macro, function, p) (isASCII(*(p))                        \
                                         ? CAT2(CAT2(macro,_),A)(*(p))               \
d1237 44
a1280 4
                                           ? CAT2(macro, _L1)                  \
                                             (TWO_BYTE_UTF8_TO_UNI(*(p),       \
                                                                   *((p)+1)))  \
                                           : function(p))
a1281 4
/* Note that all assume that the utf8 has been validated, and ignore 'use
 * bytes' */

#define isALNUM_utf8(p)		generic_utf8(isWORDCHAR, is_utf8_alnum, p)
d1285 22
a1306 23
 * ever wanted to know about.  XXX It is unclear if this should extend to
 * isIDFIRST_uni() which it hasn't so far.  (In the ASCII range, there isn't a
 * difference.) This used to be not the XID version, but we decided to go with
 * the more modern Unicode definition */
#define isIDFIRST_utf8(p)       (isASCII(*(p))                                  \
                                ? isIDFIRST_A(*(p))                             \
                                : (UTF8_IS_DOWNGRADEABLE_START(*(p)))           \
                                  ? isIDFIRST_L1(TWO_BYTE_UTF8_TO_UNI(*(p),     \
                                                                      *((p)+1)))\
                                  : Perl__is_utf8__perl_idstart(aTHX_ p))
#define isIDCONT_utf8(p)	generic_utf8(isWORDCHAR, is_utf8_xidcont, p)
#define isALPHA_utf8(p)		generic_utf8(isALPHA, is_utf8_alpha, p)
#define isSPACE_utf8(p)		generic_utf8(isSPACE, is_utf8_space, p)
#define isDIGIT_utf8(p)		generic_utf8(isDIGIT, is_utf8_digit, p)
#define isUPPER_utf8(p)		generic_utf8(isUPPER, is_utf8_upper, p)
#define isLOWER_utf8(p)		generic_utf8(isLOWER, is_utf8_lower, p)
/* Because ASCII is invariant under utf8, the non-utf8 macro works */
#define isASCII_utf8(p)		isASCII(p)
#define isCNTRL_utf8(p)		generic_utf8(isCNTRL, is_utf8_cntrl, p)
#define isGRAPH_utf8(p)		generic_utf8(isGRAPH, is_utf8_graph, p)
#define isPRINT_utf8(p)		generic_utf8(isPRINT, is_utf8_print, p)
#define isPUNCT_utf8(p)		generic_utf8(isPUNCT, is_utf8_punct, p)
#define isXDIGIT_utf8(p)	generic_utf8(isXDIGIT, is_utf8_xdigit, p)
a1307 2
#define toTITLE_utf8(p,s,l)	to_utf8_title(p,s,l)
#define toLOWER_utf8(p,s,l)	to_utf8_lower(p,s,l)
d1309 37
a1345 22
/* Posix and regular space differ only in U+000B, which is in ASCII (and hence
 * Latin1 */
#define isPSXSPC_utf8(p)	((isASCII(*(p)))                               \
                                ? isPSXSPC_A(*(p))                             \
                                : (UTF8_IS_DOWNGRADEABLE_START(*(p))           \
				  ? isPSXSPC_L1(TWO_BYTE_UTF8_TO_UNI(*(p),     \
                                                                     *((p)+1)))\
                                  : isSPACE_utf8(p)))
#define isBLANK_utf8(c)		isBLANK(c) /* could be wrong */

#define isALNUM_LC_utf8(p)	isALNUM_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isIDFIRST_LC_utf8(p)	isIDFIRST_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isALPHA_LC_utf8(p)	isALPHA_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isSPACE_LC_utf8(p)	isSPACE_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isDIGIT_LC_utf8(p)	isDIGIT_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isUPPER_LC_utf8(p)	isUPPER_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isLOWER_LC_utf8(p)	isLOWER_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isALNUMC_LC_utf8(p)	isALNUMC_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isCNTRL_LC_utf8(p)	isCNTRL_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isGRAPH_LC_utf8(p)	isGRAPH_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isPRINT_LC_utf8(p)	isPRINT_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isPUNCT_LC_utf8(p)	isPUNCT_LC_uvchr(valid_utf8_to_uvchr(p,  0))
d1347 22
a1368 2
#define isPSXSPC_LC_utf8(c)	(isSPACE_LC_utf8(c) ||(c) == '\f')
#define isBLANK_LC_utf8(c)	isBLANK(c) /* could be wrong */
d1371 3
a1373 1
 * CTRL-@@ is 0, CTRL-A is 1, etc, just like on ASCII */
d1378 1
a1378 1
#define NOLINE ((line_t) 4294967295UL)
d1393 2
d1427 2
a1428 2
source, C<dest> is the destination, C<nitems> is the number of items, and C<type> is
the type.  Can do overlapping moves.  See also C<Copy>.
d1436 2
a1437 2
source, C<dest> is the destination, C<nitems> is the number of items, and C<type> is
the type.  May fail on overlapping copies.  See also C<Move>.
d1454 1
a1454 1
=for apidoc Am|void|StructCopy|type src|type dest|type
d1487 2
a1488 1
#define MEM_WRAP_CHECK(n,t) MEM_WRAP_CHECK_1(n,t,PL_memory_wrap)
d1493 1
a1493 2
#define PERL_STRLEN_ROUNDUP(n) ((void)(((n) > MEM_SIZE_MAX - 2 * PERL_STRLEN_ROUNDUP_QUANTUM) ? (Perl_croak_nocontext("%s",PL_memory_wrap),0):0),((n-1+PERL_STRLEN_ROUNDUP_QUANTUM)&~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM-1)))

d1664 2
d1670 1
a1670 1
 * indent-tabs-mode: t
d1673 1
a1673 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d73 7
a79 4
/* XXX Configure ought to have a test for a boolean type, if I can
   just figure out all the headers such a test needs.
   Andy Dougherty	August 1996
*/
d116 7
a214 13
/* HMB H.Merijn Brand - a placeholder for preparing Configure patches:
 * 
 * USE_DTRACE	HAS_PSEUDOFORK	HAS_TIMEGM	LOCALTIME_R_NEEDS_TZSET	
 * GMTIME_MAX	GMTIME_MIN	LOCALTIME_MAX	LOCALTIME_MIN
 * HAS_CTIME64	HAS_LOCALTIME64	HAS_GMTIME64	HAS_DIFFTIME64
 * HAS_MKTIME64	HAS_ASCTIME64	HAS_GETADDRINFO	HAS_GETNAMEINFO
 * HAS_INETNTOP	HAS_INETPTON	CHARBITS
 * Not (yet) used at top level, but mention them for metaconfig
 */

/* Mention I8SIZE, U8SIZE, I16SIZE, U16SIZE, I32SIZE, U32SIZE,
   I64SIZE, and U64SIZE here so that metaconfig pulls them in. */

d283 8
d294 4
d301 8
d314 4
d332 7
d355 8
a362 1
#define sv_catpvs(sv, str) Perl_sv_catpvn_flags(aTHX_ sv, STR_WITH_LEN(str), SV_GMAGIC)
d364 3
d368 9
a376 2
#define gv_stashpvs(str, create) Perl_gv_stashpvn(aTHX_ STR_WITH_LEN(str), create)
#define gv_fetchpvs(namebeg, add, sv_type) Perl_gv_fetchpvn_flags(aTHX_ STR_WITH_LEN(namebeg), add, sv_type)
d386 2
d448 1
a448 1
	(sizeof(s2)-1 == l && memEQ(s1, (s2 ""), (sizeof(s2)-1)))
d473 19
d493 11
a503 3
=for apidoc Am|bool|isALNUM|char ch
Returns a boolean indicating whether the C C<char> is a US-ASCII (Basic Latin)
alphanumeric character (including underscore) or digit.
d505 15
a519 3
=for apidoc Am|bool|isALPHA|char ch
Returns a boolean indicating whether the C C<char> is a US-ASCII (Basic Latin)
alphabetic character.
d522 5
a526 6
Returns a boolean indicating whether the C C<char> is a US-ASCII (Basic Latin)
whitespace.

=for apidoc Am|bool|isDIGIT|char ch
Returns a boolean indicating whether the C C<char> is a US-ASCII (Basic Latin)
digit.
d529 19
a547 2
Returns a boolean indicating whether the C C<char> is a US-ASCII (Basic Latin)
uppercase character.
d549 1
a549 3
=for apidoc Am|bool|isLOWER|char ch
Returns a boolean indicating whether the C C<char> is a US-ASCII (Basic Latin)
lowercase character.
d552 2
a553 2
Converts the specified character to uppercase.  Characters outside the
US-ASCII (Basic Latin) range are viewed as not having any case.
d556 2
a557 2
Converts the specified character to lowercase.  Characters outside the
US-ASCII (Basic Latin) range are viewed as not having any case.
d560 4
d566 183
a748 20
#define isALNUM(c)	(isALPHA(c) || isDIGIT(c) || (c) == '_')
#define isIDFIRST(c)	(isALPHA(c) || (c) == '_')
#define isALPHA(c)	(isUPPER(c) || isLOWER(c))
/* ALPHAU includes Unicode semantics for latin1 characters.  It has an extra
 * >= AA test to speed up ASCII-only tests at the expense of the others */
#define isALPHAU(c)	(isALPHA(c) || (NATIVE_TO_UNI((U8) c) >= 0xAA \
    && ((NATIVE_TO_UNI((U8) c) >= 0xC0 \
	    && NATIVE_TO_UNI((U8) c) != 0xD7 && NATIVE_TO_UNI((U8) c) != 0xF7) \
	|| NATIVE_TO_UNI((U8) c) == 0xAA \
	|| NATIVE_TO_UNI((U8) c) == 0xB5 \
	|| NATIVE_TO_UNI((U8) c) == 0xBA)))
#define isALNUMU(c)	(isDIGIT(c) || isALPHAU(c) || (c) == '_')

/* continuation character for legal NAME in \N{NAME} */
#define isCHARNAME_CONT(c) (isALNUMU(c) || (c) == ' ' || (c) == '-' || (c) == '(' || (c) == ')' || (c) == ':' || NATIVE_TO_UNI((U8) c) == 0xA0)
#define isSPACE(c) \
	((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) =='\r' || (c) == '\f')
#define isPSXSPC(c)	(isSPACE(c) || (c) == '\v')
#define isBLANK(c)	((c) == ' ' || (c) == '\t')
#define isDIGIT(c)	((c) >= '0' && (c) <= '9')
a749 3
    /* In EBCDIC we do not do locales: therefore() isupper() is fine. */
#   define isUPPER(c)	isupper(c)
#   define isLOWER(c)	islower(c)
d751 2
a752 1
#   define isASCII(c)	isascii(c)
d754 1
d756 2
d759 1
d761 2
d764 2
d767 25
a791 13
#   define toUPPER_LATIN1_MOD(c)    UNI_TO_NATIVE(PL_mod_latin1_uc[(U8) NATIVE_TO_UNI(c)])
#   define toLOWER(c)	tolower(c)
#   define toLOWER_LATIN1(c)	UNI_TO_NATIVE(PL_latin1_lc[(U8) NATIVE_TO_UNI(c)])
#else
#   define isUPPER(c)	((c) >= 'A' && (c) <= 'Z')
#   define isLOWER(c)	((c) >= 'a' && (c) <= 'z')
#   define isALNUMC(c)	(isALPHA(c) || isDIGIT(c))
#   define isASCII(c)	((c) <= 127)
#   define isCNTRL(c)	((c) < ' ' || (c) == 127)
#   define isGRAPH(c)	(isALNUM(c) || isPUNCT(c))
#   define isPRINT(c)	(((c) >= 32 && (c) < 127))
#   define isPUNCT(c)	(((c) >= 33 && (c) <= 47) || ((c) >= 58 && (c) <= 64)  || ((c) >= 91 && (c) <= 96) || ((c) >= 123 && (c) <= 126))
#   define isXDIGIT(c)  (isDIGIT(c) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
a792 2
/* Use table lookup for speed */
#   define toLOWER_LATIN1(c)	(PL_latin1_lc[(U8) c])
d794 6
d801 6
a806 7
 * all mapped to one of them, and these need special handling */
#   define toUPPER_LATIN1_MOD(c)    (PL_mod_latin1_uc[(U8) c])

/* ASCII casing. */
#   define toUPPER(c)	(isLOWER(c) ? (c) - ('a' - 'A') : (c))
#   define toLOWER(c)	(isUPPER(c) ? (c) + ('a' - 'A') : (c))
#endif
d815 2
d833 4
d840 10
d867 6
a888 1
#define isBLANK_LC(c)		isBLANK(c) /* could be wrong */
d890 25
a914 13
#define isALNUM_uni(c)		is_uni_alnum(c)
#define isIDFIRST_uni(c)	is_uni_idfirst(c)
#define isALPHA_uni(c)		is_uni_alpha(c)
#define isSPACE_uni(c)		is_uni_space(c)
#define isDIGIT_uni(c)		is_uni_digit(c)
#define isUPPER_uni(c)		is_uni_upper(c)
#define isLOWER_uni(c)		is_uni_lower(c)
#define isASCII_uni(c)		is_uni_ascii(c)
#define isCNTRL_uni(c)		is_uni_cntrl(c)
#define isGRAPH_uni(c)		is_uni_graph(c)
#define isPRINT_uni(c)		is_uni_print(c)
#define isPUNCT_uni(c)		is_uni_punct(c)
#define isXDIGIT_uni(c)		is_uni_xdigit(c)
d920 2
a921 1
#define isPSXSPC_uni(c)		(isSPACE_uni(c) ||(c) == '\f')
d939 43
a981 16
#define isALNUM_utf8(p)		is_utf8_alnum(p)
/* The ID_Start of Unicode is quite limiting: it assumes a L-class
 * character (meaning that you cannot have, say, a CJK character).
 * Instead, let's allow ID_Continue but not digits. */
#define isIDFIRST_utf8(p)	(is_utf8_idcont(p) && !is_utf8_digit(p))
#define isALPHA_utf8(p)		is_utf8_alpha(p)
#define isSPACE_utf8(p)		is_utf8_space(p)
#define isDIGIT_utf8(p)		is_utf8_digit(p)
#define isUPPER_utf8(p)		is_utf8_upper(p)
#define isLOWER_utf8(p)		is_utf8_lower(p)
#define isASCII_utf8(p)		is_utf8_ascii(p)
#define isCNTRL_utf8(p)		is_utf8_cntrl(p)
#define isGRAPH_utf8(p)		is_utf8_graph(p)
#define isPRINT_utf8(p)		is_utf8_print(p)
#define isPUNCT_utf8(p)		is_utf8_punct(p)
#define isXDIGIT_utf8(p)	is_utf8_xdigit(p)
d986 8
a993 1
#define isPSXSPC_utf8(c)	(isSPACE_utf8(c) ||(c) == '\f')
d996 12
a1007 12
#define isALNUM_LC_utf8(p)	isALNUM_LC_uvchr(utf8_to_uvchr(p,  0))
#define isIDFIRST_LC_utf8(p)	isIDFIRST_LC_uvchr(utf8_to_uvchr(p,  0))
#define isALPHA_LC_utf8(p)	isALPHA_LC_uvchr(utf8_to_uvchr(p,  0))
#define isSPACE_LC_utf8(p)	isSPACE_LC_uvchr(utf8_to_uvchr(p,  0))
#define isDIGIT_LC_utf8(p)	isDIGIT_LC_uvchr(utf8_to_uvchr(p,  0))
#define isUPPER_LC_utf8(p)	isUPPER_LC_uvchr(utf8_to_uvchr(p,  0))
#define isLOWER_LC_utf8(p)	isLOWER_LC_uvchr(utf8_to_uvchr(p,  0))
#define isALNUMC_LC_utf8(p)	isALNUMC_LC_uvchr(utf8_to_uvchr(p,  0))
#define isCNTRL_LC_utf8(p)	isCNTRL_LC_uvchr(utf8_to_uvchr(p,  0))
#define isGRAPH_LC_utf8(p)	isGRAPH_LC_uvchr(utf8_to_uvchr(p,  0))
#define isPRINT_LC_utf8(p)	isPRINT_LC_uvchr(utf8_to_uvchr(p,  0))
#define isPUNCT_LC_utf8(p)	isPUNCT_LC_uvchr(utf8_to_uvchr(p,  0))
d1012 3
a1014 10
#ifdef EBCDIC
#  ifdef PERL_IMPLICIT_CONTEXT
#    define toCTRL(c)     Perl_ebcdic_control(aTHX_ c)
#  else
#    define toCTRL        Perl_ebcdic_control
#  endif
#else
  /* This conversion works both ways, strangely enough. */
#  define toCTRL(c)    (toUPPER(c) ^ 64)
#endif
d1042 1
a1042 1
PERL_MEM_LOG (see L<perlhack/PERL_MEM_LOG>).  The older API is still
d1264 1
@


1.12
log
@Merge in perl 5.10.1
@
text
@d22 2
a23 1
#define Null(type) ((type)NULL)
d29 1
a29 1
Null character pointer.
d32 1
a32 1
Null SV pointer.
d37 4
a40 3
#define Nullch Null(char*)
#define Nullfp Null(PerlIO*)
#define Nullsv Null(SV*)
d60 1
a60 3
/* For 5.10.x, disable the const cast checking that MUTABLE_PTR does in
 * blead */
#if 0 && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
d193 7
a199 2
#               define INT64_C(c)	((I64TYPE)(c))
#               define UINT64_C(c)	((U64TYPE)(c))
d211 1
a211 1
 * HAS_INETNTOP	HAS_INETPTON
d341 2
d432 1
a432 1
Returns a boolean indicating whether the C C<char> is a US-ASCII (Basic Latin) 
d465 12
d494 1
d496 1
d507 9
a587 1
#define isALNUMC_uni(c)		is_uni_alnumc(c)
a608 1
#define isALNUMC_LC_uvchr(c)	(c < 256 ? isALNUMC_LC(c) : is_uni_alnumc_lc(c))
a626 1
#define isALNUMC_utf8(p)	is_utf8_alnumc(p)
d671 12
d801 1
a801 1
 * implementation if PERL_MEM_LOG_STDERR is defined.
d804 1
a804 1
 * - all memory allocs do not get logged, only those
d806 1
a806 1
 *  Safefrees do get logged)
d823 2
d834 1
a834 1
#  ifdef PERL_MEM_LOG_STDERR
d944 7
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,
 *    2000, 2001, 2002, 2004, 2005, 2006, 2007, by Larry Wall and others
d49 23
d200 9
a208 4
/* HMB H.Merijn Brand - a placeholder for preparing Configure patches */
#if defined(HAS_MALLOC_SIZE) && defined(LOCALTIME_R_NEEDS_TZSET) && defined(HAS_PSEUDOFORK)
/* Not (yet) used at top level, but mention them for metaconfig */
#endif
d273 4
d310 1
a310 1
#define STR_WITH_LEN(s)  (s ""), (sizeof(s)-1)
d319 2
d421 2
a422 2
Returns a boolean indicating whether the C C<char> is an ASCII alphanumeric
character (including underscore) or digit.
d425 2
a426 2
Returns a boolean indicating whether the C C<char> is an ASCII alphabetic
character.
d429 2
a430 1
Returns a boolean indicating whether the C C<char> is whitespace.
d433 1
a433 1
Returns a boolean indicating whether the C C<char> is an ASCII
d437 2
a438 2
Returns a boolean indicating whether the C C<char> is an uppercase
character.
d441 2
a442 2
Returns a boolean indicating whether the C C<char> is a lowercase
character.
d445 2
a446 1
Converts the specified character to uppercase.
d449 2
a450 1
Converts the specified character to lowercase.
d739 1
a739 1
	(void)(sizeof(t) > 1 && ((MEM_SIZE)(n)+0.0) > MEM_SIZE_MAX/sizeof(t) && (Perl_croak_nocontext(a),0))
d742 1
a742 1
#define PERL_STRLEN_ROUNDUP(n) ((void)(((n) > MEM_SIZE_MAX - 2 * PERL_STRLEN_ROUNDUP_QUANTUM) ? (Perl_croak_nocontext(PL_memory_wrap),0):0),((n-1+PERL_STRLEN_ROUNDUP_QUANTUM)&~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM-1)))
d786 1
a786 1
Malloc_t Perl_mem_log_alloc(const UV n, const UV typesize, const char *typename, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);
d788 1
a788 1
Malloc_t Perl_mem_log_realloc(const UV n, const UV typesize, const char *typename, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);
d790 17
a806 1
Malloc_t Perl_mem_log_free(Malloc_t oldalloc, const char *filename, const int linenumber, const char *funcname);
d826 3
a828 3
#define Newx(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) MEM_LOG_ALLOC(n,t,(t*)safemalloc((MEM_SIZE)((n)*sizeof(t))))))
#define Newxc(v,n,t,c)	(v = (MEM_WRAP_CHECK_(n,t) MEM_LOG_ALLOC(n,t,(c*)safemalloc((MEM_SIZE)((n)*sizeof(t))))))
#define Newxz(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) MEM_LOG_ALLOC(n,t,(t*)safecalloc((n),sizeof(t)))))
d838 1
a838 1
	  (v = (MEM_WRAP_CHECK_(n,t) MEM_LOG_REALLOC(n,t,v,(t*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))))
d840 1
a840 1
	  (v = (MEM_WRAP_CHECK_(n,t) MEM_LOG_REALLOC(n,t,v,(c*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))))
d904 9
@


1.10
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2004, 2005, 2006, by Larry Wall and others
d27 1
a27 1
=for apidoc AmU||Nullch 
d62 1
a62 1
#ifdef __GNUG__ 	/* GNU g++ has bool built-in */
d125 3
a127 3
   	SHORTSIZE == sizeof(short)
   	INTSIZE == sizeof(int)
   	LONGSIZE == sizeof(long)
d129 1
a129 1
   	PTRSIZE == sizeof(void *)
d178 1
a178 1
#if defined(HAS_MALLOC_SIZE) && defined(HAS_MALLOC_GOOD_SIZE)
d240 64
d359 4
d446 1
a446 1
#   define isPRINT(c)	(((c) > 32 && (c) < 127) || (c) == ' ')
d493 1
a493 1
#    define isALNUM_LC(c) 	(isascii(c) && (isalnum(c) || (c) == '_'))
a608 9
=head1 SV Manipulation Functions

=for apidoc Am|SV*|NEWSV|int id|STRLEN len
Creates a new SV.  A non-zero C<len> parameter indicates the number of
bytes of preallocated string space the SV should have.  An extra byte for a
tailing NUL is also reserved.  (SvPOK is not set for the SV even if string
space is allocated.)  The reference count for the new SV is set to 1.
C<id> is an integer id between 0 and 1299 (used to identify leaks).

d614 6
d622 1
a622 1
cast.
d626 1
a626 6
memory is zeroed with C<memzero>.

In 5.9.3, we removed the 1st parameter, a debug aid, from the api.  It
was used to uniquely identify each usage of these allocation
functions, but was deemed unnecessary with the availability of better
memory tracking tools, valgrind for example.
d670 13
d685 1
a685 2
Fill up memory with a pattern (byte 0xAB over and over again) that
hopefully catches attempts to access uninitialized memory.
d689 2
d692 3
d696 3
d702 1
a702 1
	(void)(sizeof(t) > 1 && (n) > ((MEM_SIZE)~0)/sizeof(t) && (Perl_croak_nocontext(a),0))
d705 1
a705 1
#define PERL_STRLEN_ROUNDUP(n) ((void)(((n) > (MEM_SIZE)~0 - 2 * PERL_STRLEN_ROUNDUP_QUANTUM) ? (Perl_croak_nocontext(PL_memory_wrap),0):0),((n-1+PERL_STRLEN_ROUNDUP_QUANTUM)&~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM-1)))
d718 60
a777 4
#define Newx(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) (t*)safemalloc((MEM_SIZE)((n)*sizeof(t)))))
#define Newxc(v,n,t,c)	(v = (MEM_WRAP_CHECK_(n,t) (c*)safemalloc((MEM_SIZE)((n)*sizeof(t)))))
#define Newxz(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) (t*)safemalloc((MEM_SIZE)((n)*sizeof(t))))), \
			memzero((char*)(v), (n)*sizeof(t))
d782 1
d785 1
a785 1
	  (v = (MEM_WRAP_CHECK_(n,t) (t*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t)))))
d787 1
a787 1
	  (v = (MEM_WRAP_CHECK_(n,t) (c*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t)))))
d791 1
a791 1
  (d ? (void)(safefree((Malloc_t)(d)), Poison(&(d), 1, Malloc_t)) : (void) 0)
d793 1
a793 1
#define Safefree(d)	safefree((Malloc_t)(d))
d809 4
a812 1
#define Poison(d,n,t)	(MEM_WRAP_CHECK_(n,t) (void)memset((char*)(d), 0xAB, (n) * sizeof(t)))
d843 1
a843 1
#define pTHX_FORMAT 
d845 1
a845 1
#define pTHX_VALUE_ 
d847 1
a847 1
#define pTHX__VALUE_ 
d850 1
@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2004, by Larry Wall and others
d90 15
d177 5
a536 3
#ifdef lint
#define NOLINE ((line_t)0)
#else
a537 1
#endif
d552 1
a552 1
=for apidoc Am|void|New|int id|void* ptr|int nitems|type
d555 1
a555 1
=for apidoc Am|void|Newc|int id|void* ptr|int nitems|type|cast
d559 1
a559 1
=for apidoc Am|void|Newz|int id|void* ptr|int nitems|type
d563 5
a616 2
#ifndef lint

d620 1
a620 2
#define MEM_WRAP_CHECK(n,t) \
	(void)((n)>((MEM_SIZE)~0)/sizeof(t)?(Perl_croak_nocontext(PL_memory_wrap),0):0)
d622 2
a623 13
	(void)((n)>((MEM_SIZE)~0)/sizeof(t)?(Perl_croak_nocontext(a),0):0)
#define MEM_WRAP_CHECK_2(n,t,a,b) \
	(void)((n)>((MEM_SIZE)~0)/sizeof(t)?(Perl_croak_nocontext(a,b),0):0)

#define New(x,v,n,t)	(v = (MEM_WRAP_CHECK(n,t), (t*)safemalloc((MEM_SIZE)((n)*sizeof(t)))))
#define Newc(x,v,n,t,c)	(v = (MEM_WRAP_CHECK(n,t), (c*)safemalloc((MEM_SIZE)((n)*sizeof(t)))))
#define Newz(x,v,n,t)	(v = (MEM_WRAP_CHECK(n,t), (t*)safemalloc((MEM_SIZE)((n)*sizeof(t))))), \
			memzero((char*)(v), (n)*sizeof(t))
#define Renew(v,n,t) \
	  (v = (MEM_WRAP_CHECK(n,t), (t*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t)))))
#define Renewc(v,n,t,c) \
	  (v = (MEM_WRAP_CHECK(n,t), (c*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t)))))
#define Safefree(d)	safefree((Malloc_t)(d))
d625 1
a625 14
#define Move(s,d,n,t)	(MEM_WRAP_CHECK(n,t), (void)memmove((char*)(d),(char*)(s), (n) * sizeof(t)))
#define Copy(s,d,n,t)	(MEM_WRAP_CHECK(n,t), (void)memcpy((char*)(d),(char*)(s), (n) * sizeof(t)))
#define Zero(d,n,t)	(MEM_WRAP_CHECK(n,t), (void)memzero((char*)(d), (n) * sizeof(t)))

#define MoveD(s,d,n,t)	(MEM_WRAP_CHECK(n,t), memmove((char*)(d),(char*)(s), (n) * sizeof(t)))
#define CopyD(s,d,n,t)	(MEM_WRAP_CHECK(n,t), memcpy((char*)(d),(char*)(s), (n) * sizeof(t)))
#ifdef HAS_MEMSET
#define ZeroD(d,n,t)	(MEM_WRAP_CHECK(n,t), memzero((char*)(d), (n) * sizeof(t)))
#else
/* Using bzero(), which returns void.  */
#define ZeroD(d,n,t)	(MEM_WRAP_CHECK(n,t), memzero((char*)(d), (n) * sizeof(t)),d)
#endif

#define Poison(d,n,t)	(MEM_WRAP_CHECK(n,t), (void)memset((char*)(d), 0xAB, (n) * sizeof(t)))
d632 3
d636 5
a640 3
#define New(x,v,n,t)	(v = (t*)safemalloc((MEM_SIZE)((n)*sizeof(t))))
#define Newc(x,v,n,t,c)	(v = (c*)safemalloc((MEM_SIZE)((n)*sizeof(t))))
#define Newz(x,v,n,t)	(v = (t*)safemalloc((MEM_SIZE)((n)*sizeof(t)))), \
d642 5
d648 1
a648 1
	  (v = (t*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))
d650 6
a655 1
	  (v = (c*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))
d657 1
d659 3
a661 3
#define Move(s,d,n,t)	(void)memmove((char*)(d),(char*)(s), (n) * sizeof(t))
#define Copy(s,d,n,t)	(void)memcpy((char*)(d),(char*)(s), (n) * sizeof(t))
#define Zero(d,n,t)	(void)memzero((char*)(d), (n) * sizeof(t))
d663 2
a664 2
#define MoveD(s,d,n,t)	memmove((char*)(d),(char*)(s), (n) * sizeof(t))
#define CopyD(s,d,n,t)	memcpy((char*)(d),(char*)(s), (n) * sizeof(t))
d666 1
a666 1
#define ZeroD(d,n,t)	memzero((char*)(d), (n) * sizeof(t))
d668 2
a669 5
#define ZeroD(d,n,t)	((void)memzero((char*)(d), (n) * sizeof(t)),d)
#endif

#define Poison(d,n,t)	(void)memset((char*)(d), 0xAB, (n) * sizeof(t))

d672 1
a672 16
#else /* lint */

#define New(x,v,n,s)	(v = Null(s *))
#define Newc(x,v,n,s,c)	(v = Null(s *))
#define Newz(x,v,n,s)	(v = Null(s *))
#define Renew(v,n,s)	(v = Null(s *))
#define Move(s,d,n,t)
#define Copy(s,d,n,t)
#define Zero(d,n,t)
#define MoveD(s,d,n,t)	d
#define CopyD(s,d,n,t)	d
#define ZeroD(d,n,t)	d
#define Poison(d,n,t)
#define Safefree(d)	(d) = (d)

#endif /* lint */
d698 4
a701 4
#define pTHX_VALUE_   (unsigned long)my_perl,
#define pTHX_VALUE    (unsigned long)my_perl
#define pTHX__VALUE_ ,(unsigned long)my_perl,
#define pTHX__VALUE  ,(unsigned long)my_perl
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d562 4
d571 5
d581 5
d622 9
d653 8
d674 3
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, by Larry Wall and others
d360 1
a360 1
#   define isXDIGIT(c)  (isdigit(c) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
d586 30
d632 2
d668 16
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d29 1
d505 5
a509 1
#  define toCTRL(c)	Perl_ebcdic_control(c)
d515 2
a516 2
/* Line numbers are unsigned, 16 bits. */
typedef U16 line_t;
d520 1
a520 1
#define NOLINE ((line_t) 65535)
a524 12
   XXX LEAKTEST doesn't really work in perl5.  There are direct calls to
   safemalloc() in the source, so LEAKTEST won't pick them up.
   (The main "offenders" are extensions.)
   Further, if you try LEAKTEST, you'll also end up calling
   Safefree, which might call safexfree() on some things that weren't
   malloced with safexmalloc.  The correct "fix" to this, if anyone
   is interested, is to ensure that all calls go through the New and
   Renew macros.
	--Andy Dougherty		August 1996
*/

/*
a585 2
#ifndef LEAKTEST

a595 22
#else /* LEAKTEST */

#define New(x,v,n,t)	(v = (t*)safexmalloc((x),(MEM_SIZE)((n)*sizeof(t))))
#define Newc(x,v,n,t,c)	(v = (c*)safexmalloc((x),(MEM_SIZE)((n)*sizeof(t))))
#define Newz(x,v,n,t)	(v = (t*)safexmalloc((x),(MEM_SIZE)((n)*sizeof(t)))), \
			 memzero((char*)(v), (n)*sizeof(t))
#define Renew(v,n,t) \
	  (v = (t*)safexrealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))
#define Renewc(v,n,t,c) \
	  (v = (c*)safexrealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))
#define Safefree(d)	safexfree((Malloc_t)(d))

#define MAXXCOUNT 1400
#define MAXY_SIZE 80
#define MAXYCOUNT 16			/* (MAXY_SIZE/4 + 1) */
extern long xcount[MAXXCOUNT];
extern long lastxcount[MAXXCOUNT];
extern long xycount[MAXXCOUNT][MAXYCOUNT];
extern long lastxycount[MAXXCOUNT][MAXYCOUNT];

#endif /* LEAKTEST */

d621 2
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d24 3
a26 1
=for apidoc AmU||Nullch
a27 1

d120 8
d177 5
a181 1
#define U32_MAX UINT32_MAX
d210 1
d218 2
d293 3
d354 1
a354 1
#   define isCNTRL(c)	((c) < ' ')
d356 1
a356 1
#   define isPRINT(c)	(((c) > 32 && (c) < 127) || isSPACE(c))
d438 4
a441 3
#define toUPPER_uni(c)		to_uni_upper(c)
#define toTITLE_uni(c)		to_uni_title(c)
#define toLOWER_uni(c)		to_uni_lower(c)
d446 12
a457 15
#define isALNUM_LC_uni(c)	(c < 256 ? isALNUM_LC(c) : is_uni_alnum_lc(c))
#define isIDFIRST_LC_uni(c)	(c < 256 ? isIDFIRST_LC(c) : is_uni_idfirst_lc(c))
#define isALPHA_LC_uni(c)	(c < 256 ? isALPHA_LC(c) : is_uni_alpha_lc(c))
#define isSPACE_LC_uni(c)	(c < 256 ? isSPACE_LC(c) : is_uni_space_lc(c))
#define isDIGIT_LC_uni(c)	(c < 256 ? isDIGIT_LC(c) : is_uni_digit_lc(c))
#define isUPPER_LC_uni(c)	(c < 256 ? isUPPER_LC(c) : is_uni_upper_lc(c))
#define isLOWER_LC_uni(c)	(c < 256 ? isLOWER_LC(c) : is_uni_lower_lc(c))
#define isALNUMC_LC_uni(c)	(c < 256 ? isALNUMC_LC(c) : is_uni_alnumc_lc(c))
#define isCNTRL_LC_uni(c)	(c < 256 ? isCNTRL_LC(c) : is_uni_cntrl_lc(c))
#define isGRAPH_LC_uni(c)	(c < 256 ? isGRAPH_LC(c) : is_uni_graph_lc(c))
#define isPRINT_LC_uni(c)	(c < 256 ? isPRINT_LC(c) : is_uni_print_lc(c))
#define isPUNCT_LC_uni(c)	(c < 256 ? isPUNCT_LC(c) : is_uni_punct_lc(c))
#define toUPPER_LC_uni(c)	(c < 256 ? toUPPER_LC(c) : to_uni_upper_lc(c))
#define toTITLE_LC_uni(c)	(c < 256 ? toUPPER_LC(c) : to_uni_title_lc(c))
#define toLOWER_LC_uni(c)	(c < 256 ? toLOWER_LC(c) : to_uni_lower_lc(c))
d463 4
a466 1
#define isIDFIRST_utf8(p)	is_utf8_idfirst(p)
d479 3
a481 3
#define toUPPER_utf8(p)		to_utf8_upper(p)
#define toTITLE_utf8(p)		to_utf8_title(p)
#define toLOWER_utf8(p)		to_utf8_lower(p)
d486 12
a497 15
#define isALNUM_LC_utf8(p)	isALNUM_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isIDFIRST_LC_utf8(p)	isIDFIRST_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isALPHA_LC_utf8(p)	isALPHA_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isSPACE_LC_utf8(p)	isSPACE_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isDIGIT_LC_utf8(p)	isDIGIT_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isUPPER_LC_utf8(p)	isUPPER_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isLOWER_LC_utf8(p)	isLOWER_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isALNUMC_LC_utf8(p)	isALNUMC_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isCNTRL_LC_utf8(p)	isCNTRL_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isGRAPH_LC_utf8(p)	isGRAPH_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isPRINT_LC_utf8(p)	isPRINT_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isPUNCT_LC_utf8(p)	isPUNCT_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define toUPPER_LC_utf8(p)	toUPPER_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define toTITLE_LC_utf8(p)	toTITLE_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define toLOWER_LC_utf8(p)	toLOWER_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
d531 2
d540 2
d581 6
a586 2
=cut
*/
d630 2
d641 1
d651 13
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d51 1
a51 1
/* bool is built-in for g++-2.6.3 and later, which might be used 
d54 1
a54 1
   also defines _G_HAVE_BOOL for both gcc and g++, but only g++ 
d104 2
a105 2
   For dealing with issues that may arise from various 32/64-bit 
   systems, we will ask Configure to check out 
d117 4
a128 6
#       if QUADKIND == QUAD_IS_INT64_T
#           include <sys/types.h>
#           ifdef I_INTTYPES /* e.g. Linux has int64_t without <inttypes.h> */
#               include <inttypes.h>
#           endif
#       endif
d134 17
d278 2
a279 2
Returns a boolean indicating whether the C C<char> is an ascii alphanumeric
character or digit.
d282 1
a282 1
Returns a boolean indicating whether the C C<char> is an ascii alphabetic
d289 1
a289 1
Returns a boolean indicating whether the C C<char> is an ascii
d314 2
d402 3
d423 3
d442 3
d463 21
a483 15
#define isALNUM_LC_utf8(p)	isALNUM_LC_uni(utf8_to_uv(p, 0))
#define isIDFIRST_LC_utf8(p)	isIDFIRST_LC_uni(utf8_to_uv(p, 0))
#define isALPHA_LC_utf8(p)	isALPHA_LC_uni(utf8_to_uv(p, 0))
#define isSPACE_LC_utf8(p)	isSPACE_LC_uni(utf8_to_uv(p, 0))
#define isDIGIT_LC_utf8(p)	isDIGIT_LC_uni(utf8_to_uv(p, 0))
#define isUPPER_LC_utf8(p)	isUPPER_LC_uni(utf8_to_uv(p, 0))
#define isLOWER_LC_utf8(p)	isLOWER_LC_uni(utf8_to_uv(p, 0))
#define isALNUMC_LC_utf8(p)	isALNUMC_LC_uni(utf8_to_uv(p, 0))
#define isCNTRL_LC_utf8(p)	isCNTRL_LC_uni(utf8_to_uv(p, 0))
#define isGRAPH_LC_utf8(p)	isGRAPH_LC_uni(utf8_to_uv(p, 0))
#define isPRINT_LC_utf8(p)	isPRINT_LC_uni(utf8_to_uv(p, 0))
#define isPUNCT_LC_utf8(p)	isPUNCT_LC_uni(utf8_to_uv(p, 0))
#define toUPPER_LC_utf8(p)	toUPPER_LC_uni(utf8_to_uv(p, 0))
#define toTITLE_LC_utf8(p)	toTITLE_LC_uni(utf8_to_uv(p, 0))
#define toLOWER_LC_utf8(p)	toLOWER_LC_uni(utf8_to_uv(p, 0))
d486 1
a486 2
EXT int ebcdic_control (int);
#  define toCTRL(c)	ebcdic_control(c)
d501 1
a501 1
/* 
d518 1
a518 1
space is allocated.)  The reference count for the new SV is set to 1. 
d539 1
a539 1
=for apidoc Am|void|Safefree|void* src|void* dest|int nitems|type
d558 1
a558 1
This is an architecture-independant macro to copy one structure to another.
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d22 11
d51 7
a57 5
/* bool is built-in for g++-2.6.3, which might be used for an extension.
   If the extension includes <_G_config.h> before this file then
   _G_HAVE_BOOL will be properly set.  If, however, the extension includes
   this file first, then you will have to manually set -DHAS_BOOL in 
   your command line to avoid a conflict.
d59 1
a59 2
#ifdef _G_HAVE_BOOL
# if _G_HAVE_BOOL
d61 1
a61 1
#   define HAS_BOOL 1
a62 1
# endif
d68 1
a68 1
#ifdef NeXT
d76 1
a76 1
#endif /* NeXT */
d84 1
d106 1
d114 1
a114 5
    Most of these are currently unused, but they are mentioned here so
    metaconfig will include the appropriate tests in Configure and
    we can then start to consider how best to deal with long long
    variables.
   Andy Dougherty	April 1998
d117 41
a157 2
typedef char		I8;
typedef unsigned char	U8;
a162 2
typedef short		I16;
typedef unsigned short	U16;
a168 2
  typedef int		I32;
  typedef unsigned int	U32;
a173 2
  typedef long		I32;
  typedef unsigned long	U32;
d180 2
d188 37
d261 33
d304 4
d309 2
d316 4
d321 2
d330 1
a330 2
	(NXIsAlpha((unsigned int)(c)) || NXIsDigit((unsigned int)(c)) || \
	 (char)(c) == '_')
d338 3
d342 1
d347 1
d350 1
a350 3
#    define isALNUM_LC(c) \
	(isalpha((unsigned char)(c)) || \
	 isdigit((unsigned char)(c)) || (char)(c) == '_')
d357 3
d361 1
d367 1
a367 2
#    define isALNUM_LC(c) \
	(isascii(c) && (isalpha(c) || isdigit(c) || (c) == '_'))
d374 3
d378 1
d385 68
d454 1
a454 1
EXT int ebcdic_control _((int));
d470 1
a470 2
/* This looks obsolete (IZ):

d473 1
d480 50
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d68 1
a68 1
# ifdef UTS
d85 21
a105 16
   In the future, we may perhaps want to think about something like
    #if INTSIZE == 4
	typedef I32 int;
    #else
    #  if LONGSIZE == 4
	    typedef I32 long;
    #  else
    #    if SHORTSIZE == 4
	    typedef I32 short;
    #    else
	    typedef I32 int;
    #    endif
    #  endif
    #endif
   For the moment, these are mentioned here so metaconfig will
   construct Configure to figure out the various sizes.
d122 1
a122 1
#if BYTEORDER > 0x4321
d186 14
a199 5
#define isUPPER(c)	((c) >= 'A' && (c) <= 'Z')
#define isLOWER(c)	((c) >= 'a' && (c) <= 'z')
#define isPRINT(c)	(((c) > 32 && (c) < 127) || isSPACE(c))
#define toUPPER(c)	(isLOWER(c) ? (c) - ('a' - 'A') : (c))
#define toLOWER(c)	(isUPPER(c) ? (c) + ('a' - 'A') : (c))
d250 7
a256 2
/* This conversion works both ways, strangely enough. */
#define toCTRL(c)    (toUPPER(c) ^ 64)
d266 4
a269 1
/* XXX LEAKTEST doesn't really work in perl5.  There are direct calls to
d280 3
a293 1
#define NEWSV(x,len)	newSV(len)
d305 1
a305 2
#define Safefree(d)	safexfree((Malloc_t)d)
#define NEWSV(x,len)	newSV(x,len)
d308 6
a313 2
long xcount[MAXXCOUNT];
long lastxcount[MAXXCOUNT];
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d23 1
a23 1
#define Nullfp Null(FILE*)
d26 14
d54 13
d75 27
a101 8
#ifdef TRUE
#undef TRUE
#endif
#ifdef FALSE
#undef FALSE
#endif
#define TRUE (1)
#define FALSE (0)
d105 4
d112 4
d120 4
d127 4
d133 5
a137 1
#define Ctl(ch) (ch & 037)
d148 21
d175 59
a233 32
#ifdef USE_NEXT_CTYPE 
#define isALNUM(c)   (NXIsAlpha((unsigned int)c) || NXIsDigit((unsigned int)c) || c == '_')
#define isIDFIRST(c) (NXIsAlpha((unsigned int)c) || c == '_')
#define isALPHA(c)   NXIsAlpha((unsigned int)c)
#define isSPACE(c)   NXIsSpace((unsigned int)c)
#define isDIGIT(c)   NXIsDigit((unsigned int)c)
#define isUPPER(c)   NXIsUpper((unsigned int)c)
#define isLOWER(c)   NXIsLower((unsigned int)c)
#define toUPPER(c)   NXToUpper((unsigned int)c)
#define toLOWER(c)   NXToLower((unsigned int)c)
#else /* USE_NEXT_CTYPE */
#if defined(CTYPE256) || (!defined(isascii) && !defined(HAS_ISASCII))
#define isALNUM(c)   (isalpha((unsigned char)(c)) || isdigit((unsigned char)(c)) || c == '_')
#define isIDFIRST(c) (isalpha((unsigned char)(c)) || (c) == '_')
#define isALPHA(c)   isalpha((unsigned char)(c))
#define isSPACE(c)   isspace((unsigned char)(c))
#define isDIGIT(c)   isdigit((unsigned char)(c))
#define isUPPER(c)   isupper((unsigned char)(c))
#define isLOWER(c)   islower((unsigned char)(c))
#define toUPPER(c)   toupper((unsigned char)(c))
#define toLOWER(c)   tolower((unsigned char)(c))
#else
#define isALNUM(c)   (isascii(c) && (isalpha(c) || isdigit(c) || c == '_'))
#define isIDFIRST(c) (isascii(c) && (isalpha(c) || (c) == '_'))
#define isALPHA(c)   (isascii(c) && isalpha(c))
#define isSPACE(c)   (isascii(c) && isspace(c))
#define isDIGIT(c)   (isascii(c) && isdigit(c))
#define isUPPER(c)   (isascii(c) && isupper(c))
#define isLOWER(c)   (isascii(c) && islower(c))
#define toUPPER(c)   toupper(c)
#define toLOWER(c)   tolower(c)
#endif
d236 3
d247 10
d259 12
a270 22
#ifndef safemalloc
char *safemalloc _((MEM_SIZE));
char *saferealloc _((char *, MEM_SIZE));
void safefree _((char *));
#endif
#ifndef MSDOS
#define New(x,v,n,t)  (v = (t*)safemalloc((MEM_SIZE)((n) * sizeof(t))))
#define Newc(x,v,n,t,c)  (v = (c*)safemalloc((MEM_SIZE)((n) * sizeof(t))))
#define Newz(x,v,n,t) (v = (t*)safemalloc((MEM_SIZE)((n) * sizeof(t)))), \
    memzero((char*)(v), (n) * sizeof(t))
#define Renew(v,n,t) (v = (t*)saferealloc((char*)(v),(MEM_SIZE)((n)*sizeof(t))))
#define Renewc(v,n,t,c) (v = (c*)saferealloc((char*)(v),(MEM_SIZE)((n)*sizeof(t))))
#else
#define New(x,v,n,t)  (v = (t*)safemalloc(((unsigned long)(n) * sizeof(t))))
#define Newc(x,v,n,t,c)  (v = (c*)safemalloc(((unsigned long)(n) * sizeof(t))))
#define Newz(x,v,n,t) (v = (t*)safemalloc(((unsigned long)(n) * sizeof(t)))), \
    memzero((char*)(v), (n) * sizeof(t))
#define Renew(v,n,t) (v = (t*)saferealloc((char*)(v),((unsigned long)(n)*sizeof(t))))
#define Renewc(v,n,t,c) (v = (c*)saferealloc((char*)(v),((unsigned long)(n)*sizeof(t))))
#endif /* MSDOS */
#define Safefree(d) safefree((char*)d)
#define NEWSV(x,len) newSV(len)
d272 13
a284 12
char *safexmalloc();
char *safexrealloc();
void safexfree();
#define New(x,v,n,t)  (v = (t*)safexmalloc(x,(MEM_SIZE)((n) * sizeof(t))))
#define Newc(x,v,n,t,c)  (v = (c*)safexmalloc(x,(MEM_SIZE)((n) * sizeof(t))))
#define Newz(x,v,n,t) (v = (t*)safexmalloc(x,(MEM_SIZE)((n) * sizeof(t)))), \
    memzero((char*)(v), (n) * sizeof(t))
#define Renew(v,n,t) (v = (t*)safexrealloc((char*)(v),(MEM_SIZE)((n)*sizeof(t))))
#define Renewc(v,n,t,c) (v = (c*)safexrealloc((char*)(v),(MEM_SIZE)((n)*sizeof(t))))
#define Safefree(d) safexfree((char*)d)
#define NEWSV(x,len) newSV(x,len)
#define MAXXCOUNT 1200
d287 1
d289 5
a293 3
#define Move(s,d,n,t) (void)memmove((char*)(d),(char*)(s), (n) * sizeof(t))
#define Copy(s,d,n,t) (void)memcpy((char*)(d),(char*)(s), (n) * sizeof(t))
#define Zero(d,n,t) (void)memzero((char*)(d), (n) * sizeof(t))
d295 5
a299 4
#define New(x,v,n,s) (v = Null(s *))
#define Newc(x,v,n,s,c) (v = Null(s *))
#define Newz(x,v,n,s) (v = Null(s *))
#define Renew(v,n,s) (v = Null(s *))
d303 2
a304 1
#define Safefree(d) d = d
d308 1
a308 1
#define StructCopy(s,d,t) *((t*)(d)) = *((t*)(s))
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d23 1
a23 1
#define Nullfp Null(PerlIO*)
a25 14
#ifdef TRUE
#undef TRUE
#endif
#ifdef FALSE
#undef FALSE
#endif
#define TRUE (1)
#define FALSE (0)


/* XXX Configure ought to have a test for a boolean type, if I can
   just figure out all the headers such a test needs.
   Andy Dougherty	August 1996
*/
a39 13
/* The NeXT dynamic loader headers will not build with the bool macro
   So declare them now to clear confusion.
*/
#ifdef NeXT
# undef FALSE
# undef TRUE
  typedef enum bool { FALSE = 0, TRUE = 1 } bool;
# define ENUM_BOOL 1
# ifndef HAS_BOOL
#  define HAS_BOOL 1
# endif /* !HAS_BOOL */
#endif /* NeXT */

d41 1
a41 1
# if defined(UTS) || defined(VMS)
d48 8
a55 32
/* XXX A note on the perl source internal type system.  The
   original intent was that I32 be *exactly* 32 bits.

   Currently, we only guarantee that I32 is *at least* 32 bits.
   Specifically, if int is 64 bits, then so is I32.  (This is the case
   for the Cray.)  This has the advantage of meshing nicely with
   standard library calls (where we pass an I32 and the library is
   expecting an int), but the disadvantage that an I32 is not 32 bits.
   Andy Dougherty	August 1996

   There is no guarantee that there is *any* integral type with
   exactly 32 bits.  It is perfectly legal for a system to have
   sizeof(short) == sizeof(int) == sizeof(long) == 8.

   Similarly, there is no guarantee that I16 and U16 have exactly 16
   bits.

   For dealing with issues that may arise from various 32/64-bit 
   systems, we will ask Configure to check out 
   	SHORTSIZE == sizeof(short)
   	INTSIZE == sizeof(int)
   	LONGSIZE == sizeof(long)
	LONGLONGSIZE == sizeof(long long) (if HAS_LONG_LONG)
   	PTRSIZE == sizeof(void *)
	DOUBLESIZE == sizeof(double)
	LONG_DOUBLESIZE == sizeof(long double) (if HAS_LONG_DOUBLE).
    Most of these are currently unused, but they are mentioned here so
    metaconfig will include the appropriate tests in Configure and
    we can then start to consider how best to deal with long long
    variables.
   Andy Dougherty	April 1998
*/
a58 4
/* I8_MAX and I8_MIN constants are not defined, as I8 is an ambiguous type.
   Please search CHAR_MAX in perl.h for further details. */
#define U8_MAX PERL_UCHAR_MAX
#define U8_MIN PERL_UCHAR_MIN
a61 4
#define I16_MAX PERL_SHORT_MAX
#define I16_MIN PERL_SHORT_MIN
#define U16_MAX PERL_USHORT_MAX
#define U16_MIN PERL_USHORT_MIN
d63 1
a63 1
#if LONGSIZE > 4
a65 4
# define I32_MAX PERL_INT_MAX
# define I32_MIN PERL_INT_MIN
# define U32_MAX PERL_UINT_MAX
# define U32_MIN PERL_UINT_MIN
a68 4
# define I32_MAX PERL_LONG_MAX
# define I32_MIN PERL_LONG_MIN
# define U32_MAX PERL_ULONG_MAX
# define U32_MIN PERL_ULONG_MIN
d71 1
a71 5
#define BIT_DIGITS(N)   (((N)*146)/485 + 1)  /* log2(10) =~ 146/485 */
#define TYPE_DIGITS(T)  BIT_DIGITS(sizeof(T) * 8)
#define TYPE_CHARS(T)   (TYPE_DIGITS(T) + 2) /* sign, NUL */

#define Ctl(ch) ((ch) & 037)
a81 21
#ifdef HAS_MEMCMP
#  define memNE(s1,s2,l) (memcmp(s1,s2,l))
#  define memEQ(s1,s2,l) (!memcmp(s1,s2,l))
#else
#  define memNE(s1,s2,l) (bcmp(s1,s2,l))
#  define memEQ(s1,s2,l) (!bcmp(s1,s2,l))
#endif

/*
 * Character classes.
 *
 * Unfortunately, the introduction of locales means that we
 * can't trust isupper(), etc. to tell the truth.  And when
 * it comes to /\w+/ with tainting enabled, we *must* be able
 * to trust our character classes.
 *
 * Therefore, the default tests in the text of Perl will be
 * independent of locale.  Any code that wants to depend on
 * the current locale will use the tests that begin with "lc".
 */

d88 32
a119 68
#define isALNUM(c)	(isALPHA(c) || isDIGIT(c) || (c) == '_')
#define isIDFIRST(c)	(isALPHA(c) || (c) == '_')
#define isALPHA(c)	(isUPPER(c) || isLOWER(c))
#define isSPACE(c) \
	((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) =='\r' || (c) == '\f')
#define isDIGIT(c)	((c) >= '0' && (c) <= '9')
#ifdef EBCDIC
    /* In EBCDIC we do not do locales: therefore() isupper() is fine. */
#   define isUPPER(c)	isupper(c)
#   define isLOWER(c)	islower(c)
#   define isPRINT(c)	isprint(c)
#   define toUPPER(c)	toupper(c)
#   define toLOWER(c)	tolower(c)
#else
#   define isUPPER(c)	((c) >= 'A' && (c) <= 'Z')
#   define isLOWER(c)	((c) >= 'a' && (c) <= 'z')
#   define isPRINT(c)	(((c) > 32 && (c) < 127) || isSPACE(c))
#   define toUPPER(c)	(isLOWER(c) ? (c) - ('a' - 'A') : (c))
#   define toLOWER(c)	(isUPPER(c) ? (c) + ('a' - 'A') : (c))
#endif

#ifdef USE_NEXT_CTYPE

#  define isALNUM_LC(c) \
	(NXIsAlpha((unsigned int)(c)) || NXIsDigit((unsigned int)(c)) || \
	 (char)(c) == '_')
#  define isIDFIRST_LC(c) \
	(NXIsAlpha((unsigned int)(c)) || (char)(c) == '_')
#  define isALPHA_LC(c)		NXIsAlpha((unsigned int)(c))
#  define isSPACE_LC(c)		NXIsSpace((unsigned int)(c))
#  define isDIGIT_LC(c)		NXIsDigit((unsigned int)(c))
#  define isUPPER_LC(c)		NXIsUpper((unsigned int)(c))
#  define isLOWER_LC(c)		NXIsLower((unsigned int)(c))
#  define isPRINT_LC(c)		NXIsPrint((unsigned int)(c))
#  define toUPPER_LC(c)		NXToUpper((unsigned int)(c))
#  define toLOWER_LC(c)		NXToLower((unsigned int)(c))

#else /* !USE_NEXT_CTYPE */
#  if defined(CTYPE256) || (!defined(isascii) && !defined(HAS_ISASCII))

#    define isALNUM_LC(c) \
	(isalpha((unsigned char)(c)) || \
	 isdigit((unsigned char)(c)) || (char)(c) == '_')
#    define isIDFIRST_LC(c) (isalpha((unsigned char)(c)) || (char)(c) == '_')
#    define isALPHA_LC(c)	isalpha((unsigned char)(c))
#    define isSPACE_LC(c)	isspace((unsigned char)(c))
#    define isDIGIT_LC(c)	isdigit((unsigned char)(c))
#    define isUPPER_LC(c)	isupper((unsigned char)(c))
#    define isLOWER_LC(c)	islower((unsigned char)(c))
#    define isPRINT_LC(c)	isprint((unsigned char)(c))
#    define toUPPER_LC(c)	toupper((unsigned char)(c))
#    define toLOWER_LC(c)	tolower((unsigned char)(c))

#  else

#    define isALNUM_LC(c) \
	(isascii(c) && (isalpha(c) || isdigit(c) || (c) == '_'))
#    define isIDFIRST_LC(c)	(isascii(c) && (isalpha(c) || (c) == '_'))
#    define isALPHA_LC(c)	(isascii(c) && isalpha(c))
#    define isSPACE_LC(c)	(isascii(c) && isspace(c))
#    define isDIGIT_LC(c)	(isascii(c) && isdigit(c))
#    define isUPPER_LC(c)	(isascii(c) && isupper(c))
#    define isLOWER_LC(c)	(isascii(c) && islower(c))
#    define isPRINT_LC(c)	(isascii(c) && isprint(c))
#    define toUPPER_LC(c)	toupper(c)
#    define toLOWER_LC(c)	tolower(c)

#  endif
a121 8
#ifdef EBCDIC
EXT int ebcdic_control _((int));
#  define toCTRL(c)	ebcdic_control(c)
#else
  /* This conversion works both ways, strangely enough. */
#  define toCTRL(c)    (toUPPER(c) ^ 64)
#endif

a129 13

/* This looks obsolete (IZ):

   XXX LEAKTEST doesn't really work in perl5.  There are direct calls to
   safemalloc() in the source, so LEAKTEST won't pick them up.
   Further, if you try LEAKTEST, you'll also end up calling
   Safefree, which might call safexfree() on some things that weren't
   malloced with safexmalloc.  The correct "fix" to this, if anyone
   is interested, is to ensure that all calls go through the New and
   Renew macros.
	--Andy Dougherty		August 1996
*/

a130 3

#define NEWSV(x,len)	newSV(len)

d132 22
a153 11

#define New(x,v,n,t)	(v = (t*)safemalloc((MEM_SIZE)((n)*sizeof(t))))
#define Newc(x,v,n,t,c)	(v = (c*)safemalloc((MEM_SIZE)((n)*sizeof(t))))
#define Newz(x,v,n,t)	(v = (t*)safemalloc((MEM_SIZE)((n)*sizeof(t)))), \
			memzero((char*)(v), (n)*sizeof(t))
#define Renew(v,n,t) \
	  (v = (t*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))
#define Renewc(v,n,t,c) \
	  (v = (c*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))
#define Safefree(d)	safefree((Malloc_t)(d))

d155 14
a168 19

#define New(x,v,n,t)	(v = (t*)safexmalloc((x),(MEM_SIZE)((n)*sizeof(t))))
#define Newc(x,v,n,t,c)	(v = (c*)safexmalloc((x),(MEM_SIZE)((n)*sizeof(t))))
#define Newz(x,v,n,t)	(v = (t*)safexmalloc((x),(MEM_SIZE)((n)*sizeof(t)))), \
			 memzero((char*)(v), (n)*sizeof(t))
#define Renew(v,n,t) \
	  (v = (t*)safexrealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))
#define Renewc(v,n,t,c) \
	  (v = (c*)safexrealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))
#define Safefree(d)	safexfree((Malloc_t)(d))

#define MAXXCOUNT 1400
#define MAXY_SIZE 80
#define MAXYCOUNT 16			/* (MAXY_SIZE/4 + 1) */
extern long xcount[MAXXCOUNT];
extern long lastxcount[MAXXCOUNT];
extern long xycount[MAXXCOUNT][MAXYCOUNT];
extern long lastxycount[MAXXCOUNT][MAXYCOUNT];

d170 3
a172 5

#define Move(s,d,n,t)	(void)memmove((char*)(d),(char*)(s), (n) * sizeof(t))
#define Copy(s,d,n,t)	(void)memcpy((char*)(d),(char*)(s), (n) * sizeof(t))
#define Zero(d,n,t)	(void)memzero((char*)(d), (n) * sizeof(t))

d174 4
a177 5

#define New(x,v,n,s)	(v = Null(s *))
#define Newc(x,v,n,s,c)	(v = Null(s *))
#define Newz(x,v,n,s)	(v = Null(s *))
#define Renew(v,n,s)	(v = Null(s *))
d181 1
a181 2
#define Safefree(d)	(d) = (d)

d185 1
a185 1
#define StructCopy(s,d,t) (*((t*)(d)) = *((t*)(s)))
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a21 11

/*
=for apidoc AmU||Nullch
Null character pointer.

=for apidoc AmU||Nullsv
Null SV pointer.

=cut
*/

d40 5
a44 7
/* bool is built-in for g++-2.6.3 and later, which might be used 
   for extensions.  <_G_config.h> defines _G_HAVE_BOOL, but we can't
   be sure _G_config.h will be included before this file.  _G_config.h
   also defines _G_HAVE_BOOL for both gcc and g++, but only g++ 
   actually has bool.  Hence, _G_HAVE_BOOL is pretty useless for us.
   g++ can be identified by __GNUG__.
   Andy Dougherty	February 2000
d46 2
a47 1
#ifdef __GNUG__ 	/* GNU g++ has bool built-in */
d49 1
a49 1
#    define HAS_BOOL 1
d51 1
d57 1
a57 1
#if defined(NeXT) || defined(__NeXT__)
d65 1
a65 1
#endif /* NeXT || __NeXT__ */
a72 1
# define HAS_BOOL 1
a93 1

d101 5
a105 1

d108 2
a109 41
typedef I8TYPE I8;
typedef U8TYPE U8;
typedef I16TYPE I16;
typedef U16TYPE U16;
typedef I32TYPE I32;
typedef U32TYPE U32;
#ifdef PERL_CORE
#   ifdef HAS_QUAD
#       if QUADKIND == QUAD_IS_INT64_T
#           include <sys/types.h>
#           ifdef I_INTTYPES /* e.g. Linux has int64_t without <inttypes.h> */
#               include <inttypes.h>
#           endif
#       endif
typedef I64TYPE I64;
typedef U64TYPE U64;
#   endif
#endif /* PERL_CORE */

/* Mention I8SIZE, U8SIZE, I16SIZE, U16SIZE, I32SIZE, U32SIZE,
   I64SIZE, and U64SIZE here so that metaconfig pulls them in. */

#if defined(UINT8_MAX) && defined(INT16_MAX) && defined(INT32_MAX)

/* I8_MAX and I8_MIN constants are not defined, as I8 is an ambiguous type.
   Please search CHAR_MAX in perl.h for further details. */
#define U8_MAX UINT8_MAX
#define U8_MIN UINT8_MIN

#define I16_MAX INT16_MAX
#define I16_MIN INT16_MIN
#define U16_MAX UINT16_MAX
#define U16_MIN UINT16_MIN

#define I32_MAX INT32_MAX
#define I32_MIN INT32_MIN
#define U32_MAX UINT32_MAX
#define U32_MIN UINT32_MIN

#else

d115 2
d123 2
d130 2
a137 2
#endif

a143 37
/*
=for apidoc Am|bool|strNE|char* s1|char* s2
Test two strings to see if they are different.  Returns true or
false.

=for apidoc Am|bool|strEQ|char* s1|char* s2
Test two strings to see if they are equal.  Returns true or false.

=for apidoc Am|bool|strLT|char* s1|char* s2
Test two strings to see if the first, C<s1>, is less than the second,
C<s2>.  Returns true or false.

=for apidoc Am|bool|strLE|char* s1|char* s2
Test two strings to see if the first, C<s1>, is less than or equal to the
second, C<s2>.  Returns true or false.

=for apidoc Am|bool|strGT|char* s1|char* s2
Test two strings to see if the first, C<s1>, is greater than the second,
C<s2>.  Returns true or false.

=for apidoc Am|bool|strGE|char* s1|char* s2
Test two strings to see if the first, C<s1>, is greater than or equal to
the second, C<s2>.  Returns true or false.

=for apidoc Am|bool|strnNE|char* s1|char* s2|STRLEN len
Test two strings to see if they are different.  The C<len> parameter
indicates the number of bytes to compare.  Returns true or false. (A
wrapper for C<strncmp>).

=for apidoc Am|bool|strnEQ|char* s1|char* s2|STRLEN len
Test two strings to see if they are equal.  The C<len> parameter indicates
the number of bytes to compare.  Returns true or false. (A wrapper for
C<strncmp>).

=cut
*/

a179 33
/*
=for apidoc Am|bool|isALNUM|char ch
Returns a boolean indicating whether the C C<char> is an ascii alphanumeric
character or digit.

=for apidoc Am|bool|isALPHA|char ch
Returns a boolean indicating whether the C C<char> is an ascii alphabetic
character.

=for apidoc Am|bool|isSPACE|char ch
Returns a boolean indicating whether the C C<char> is whitespace.

=for apidoc Am|bool|isDIGIT|char ch
Returns a boolean indicating whether the C C<char> is an ascii
digit.

=for apidoc Am|bool|isUPPER|char ch
Returns a boolean indicating whether the C C<char> is an uppercase
character.

=for apidoc Am|bool|isLOWER|char ch
Returns a boolean indicating whether the C C<char> is a lowercase
character.

=for apidoc Am|char|toUPPER|char ch
Converts the specified character to uppercase.

=for apidoc Am|char|toLOWER|char ch
Converts the specified character to lowercase.

=cut
*/

a189 4
#   define isALNUMC(c)	isalnum(c)
#   define isASCII(c)	isascii(c)
#   define isCNTRL(c)	iscntrl(c)
#   define isGRAPH(c)	isgraph(c)
a190 2
#   define isPUNCT(c)	ispunct(c)
#   define isXDIGIT(c)	isxdigit(c)
a195 4
#   define isALNUMC(c)	(isALPHA(c) || isDIGIT(c))
#   define isASCII(c)	((c) <= 127)
#   define isCNTRL(c)	((c) < ' ')
#   define isGRAPH(c)	(isALNUM(c) || isPUNCT(c))
a196 2
#   define isPUNCT(c)	(((c) >= 33 && (c) <= 47) || ((c) >= 58 && (c) <= 64)  || ((c) >= 91 && (c) <= 96) || ((c) >= 123 && (c) <= 126))
#   define isXDIGIT(c)  (isdigit(c) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
d204 2
a205 1
	(NXIsAlNum((unsigned int)(c)) || (char)(c) == '_')
a212 3
#  define isALNUMC_LC(c)	NXIsAlNum((unsigned int)(c))
#  define isCNTRL_LC(c)		NXIsCntrl((unsigned int)(c))
#  define isGRAPH_LC(c)		NXIsGraph((unsigned int)(c))
a213 1
#  define isPUNCT_LC(c)		NXIsPunct((unsigned int)(c))
a217 1

d220 3
a222 1
#    define isALNUM_LC(c)   (isalnum((unsigned char)(c)) || (char)(c) == '_')
a228 3
#    define isALNUMC_LC(c)	isalnum((unsigned char)(c))
#    define isCNTRL_LC(c)	iscntrl((unsigned char)(c))
#    define isGRAPH_LC(c)	isgraph((unsigned char)(c))
a229 1
#    define isPUNCT_LC(c)	ispunct((unsigned char)(c))
d235 2
a236 1
#    define isALNUM_LC(c) 	(isascii(c) && (isalnum(c) || (c) == '_'))
a242 3
#    define isALNUMC_LC(c)	(isascii(c) && isalnum(c))
#    define isCNTRL_LC(c)	(isascii(c) && iscntrl(c))
#    define isGRAPH_LC(c)	(isascii(c) && isgraph(c))
a243 1
#    define isPUNCT_LC(c)	(isascii(c) && ispunct(c))
a249 68
#define isALNUM_uni(c)		is_uni_alnum(c)
#define isIDFIRST_uni(c)	is_uni_idfirst(c)
#define isALPHA_uni(c)		is_uni_alpha(c)
#define isSPACE_uni(c)		is_uni_space(c)
#define isDIGIT_uni(c)		is_uni_digit(c)
#define isUPPER_uni(c)		is_uni_upper(c)
#define isLOWER_uni(c)		is_uni_lower(c)
#define isALNUMC_uni(c)		is_uni_alnumc(c)
#define isASCII_uni(c)		is_uni_ascii(c)
#define isCNTRL_uni(c)		is_uni_cntrl(c)
#define isGRAPH_uni(c)		is_uni_graph(c)
#define isPRINT_uni(c)		is_uni_print(c)
#define isPUNCT_uni(c)		is_uni_punct(c)
#define isXDIGIT_uni(c)		is_uni_xdigit(c)
#define toUPPER_uni(c)		to_uni_upper(c)
#define toTITLE_uni(c)		to_uni_title(c)
#define toLOWER_uni(c)		to_uni_lower(c)

#define isALNUM_LC_uni(c)	(c < 256 ? isALNUM_LC(c) : is_uni_alnum_lc(c))
#define isIDFIRST_LC_uni(c)	(c < 256 ? isIDFIRST_LC(c) : is_uni_idfirst_lc(c))
#define isALPHA_LC_uni(c)	(c < 256 ? isALPHA_LC(c) : is_uni_alpha_lc(c))
#define isSPACE_LC_uni(c)	(c < 256 ? isSPACE_LC(c) : is_uni_space_lc(c))
#define isDIGIT_LC_uni(c)	(c < 256 ? isDIGIT_LC(c) : is_uni_digit_lc(c))
#define isUPPER_LC_uni(c)	(c < 256 ? isUPPER_LC(c) : is_uni_upper_lc(c))
#define isLOWER_LC_uni(c)	(c < 256 ? isLOWER_LC(c) : is_uni_lower_lc(c))
#define isALNUMC_LC_uni(c)	(c < 256 ? isALNUMC_LC(c) : is_uni_alnumc_lc(c))
#define isCNTRL_LC_uni(c)	(c < 256 ? isCNTRL_LC(c) : is_uni_cntrl_lc(c))
#define isGRAPH_LC_uni(c)	(c < 256 ? isGRAPH_LC(c) : is_uni_graph_lc(c))
#define isPRINT_LC_uni(c)	(c < 256 ? isPRINT_LC(c) : is_uni_print_lc(c))
#define isPUNCT_LC_uni(c)	(c < 256 ? isPUNCT_LC(c) : is_uni_punct_lc(c))
#define toUPPER_LC_uni(c)	(c < 256 ? toUPPER_LC(c) : to_uni_upper_lc(c))
#define toTITLE_LC_uni(c)	(c < 256 ? toUPPER_LC(c) : to_uni_title_lc(c))
#define toLOWER_LC_uni(c)	(c < 256 ? toLOWER_LC(c) : to_uni_lower_lc(c))

#define isALNUM_utf8(p)		is_utf8_alnum(p)
#define isIDFIRST_utf8(p)	is_utf8_idfirst(p)
#define isALPHA_utf8(p)		is_utf8_alpha(p)
#define isSPACE_utf8(p)		is_utf8_space(p)
#define isDIGIT_utf8(p)		is_utf8_digit(p)
#define isUPPER_utf8(p)		is_utf8_upper(p)
#define isLOWER_utf8(p)		is_utf8_lower(p)
#define isALNUMC_utf8(p)	is_utf8_alnumc(p)
#define isASCII_utf8(p)		is_utf8_ascii(p)
#define isCNTRL_utf8(p)		is_utf8_cntrl(p)
#define isGRAPH_utf8(p)		is_utf8_graph(p)
#define isPRINT_utf8(p)		is_utf8_print(p)
#define isPUNCT_utf8(p)		is_utf8_punct(p)
#define isXDIGIT_utf8(p)	is_utf8_xdigit(p)
#define toUPPER_utf8(p)		to_utf8_upper(p)
#define toTITLE_utf8(p)		to_utf8_title(p)
#define toLOWER_utf8(p)		to_utf8_lower(p)

#define isALNUM_LC_utf8(p)	isALNUM_LC_uni(utf8_to_uv(p, 0))
#define isIDFIRST_LC_utf8(p)	isIDFIRST_LC_uni(utf8_to_uv(p, 0))
#define isALPHA_LC_utf8(p)	isALPHA_LC_uni(utf8_to_uv(p, 0))
#define isSPACE_LC_utf8(p)	isSPACE_LC_uni(utf8_to_uv(p, 0))
#define isDIGIT_LC_utf8(p)	isDIGIT_LC_uni(utf8_to_uv(p, 0))
#define isUPPER_LC_utf8(p)	isUPPER_LC_uni(utf8_to_uv(p, 0))
#define isLOWER_LC_utf8(p)	isLOWER_LC_uni(utf8_to_uv(p, 0))
#define isALNUMC_LC_utf8(p)	isALNUMC_LC_uni(utf8_to_uv(p, 0))
#define isCNTRL_LC_utf8(p)	isCNTRL_LC_uni(utf8_to_uv(p, 0))
#define isGRAPH_LC_utf8(p)	isGRAPH_LC_uni(utf8_to_uv(p, 0))
#define isPRINT_LC_utf8(p)	isPRINT_LC_uni(utf8_to_uv(p, 0))
#define isPUNCT_LC_utf8(p)	isPUNCT_LC_uni(utf8_to_uv(p, 0))
#define toUPPER_LC_utf8(p)	toUPPER_LC_uni(utf8_to_uv(p, 0))
#define toTITLE_LC_utf8(p)	toTITLE_LC_uni(utf8_to_uv(p, 0))
#define toLOWER_LC_utf8(p)	toLOWER_LC_uni(utf8_to_uv(p, 0))

d251 1
a251 1
EXT int ebcdic_control (int);
d267 2
a268 1
/* 
a270 1
   (The main "offenders" are extensions.)
a276 50
*/

/*
=for apidoc Am|SV*|NEWSV|int id|STRLEN len
Creates a new SV.  A non-zero C<len> parameter indicates the number of
bytes of preallocated string space the SV should have.  An extra byte for a
tailing NUL is also reserved.  (SvPOK is not set for the SV even if string
space is allocated.)  The reference count for the new SV is set to 1. 
C<id> is an integer id between 0 and 1299 (used to identify leaks).

=for apidoc Am|void|New|int id|void* ptr|int nitems|type
The XSUB-writer's interface to the C C<malloc> function.

=for apidoc Am|void|Newc|int id|void* ptr|int nitems|type|cast
The XSUB-writer's interface to the C C<malloc> function, with
cast.

=for apidoc Am|void|Newz|int id|void* ptr|int nitems|type
The XSUB-writer's interface to the C C<malloc> function.  The allocated
memory is zeroed with C<memzero>.

=for apidoc Am|void|Renew|void* ptr|int nitems|type
The XSUB-writer's interface to the C C<realloc> function.

=for apidoc Am|void|Renewc|void* ptr|int nitems|type|cast
The XSUB-writer's interface to the C C<realloc> function, with
cast.

=for apidoc Am|void|Safefree|void* src|void* dest|int nitems|type
The XSUB-writer's interface to the C C<free> function.

=for apidoc Am|void|Move|void* src|void* dest|int nitems|type
The XSUB-writer's interface to the C C<memmove> function.  The C<src> is the
source, C<dest> is the destination, C<nitems> is the number of items, and C<type> is
the type.  Can do overlapping moves.  See also C<Copy>.

=for apidoc Am|void|Copy|void* src|void* dest|int nitems|type
The XSUB-writer's interface to the C C<memcpy> function.  The C<src> is the
source, C<dest> is the destination, C<nitems> is the number of items, and C<type> is
the type.  May fail on overlapping copies.  See also C<Move>.

=for apidoc Am|void|Zero|void* dest|int nitems|type

The XSUB-writer's interface to the C C<memzero> function.  The C<dest> is the
destination, C<nitems> is the number of items, and C<type> is the type.

=for apidoc Am|void|StructCopy|type src|type dest|type
This is an architecture-independant macro to copy one structure to another.

=cut
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d51 1
a51 1
/* bool is built-in for g++-2.6.3 and later, which might be used
d54 1
a54 1
   also defines _G_HAVE_BOOL for both gcc and g++, but only g++
d104 2
a105 2
   For dealing with issues that may arise from various 32/64-bit
   systems, we will ask Configure to check out
a116 4
#ifdef I_INTTYPES /* e.g. Linux has int64_t without <inttypes.h> */
#   include <inttypes.h>
#endif

d125 6
a135 17
#if defined(HAS_QUAD) && defined(USE_64_BIT_INT)
#   ifndef UINT64_C /* usually from <inttypes.h> */
#       if defined(HAS_LONG_LONG) && QUADKIND == QUAD_IS_LONG_LONG
#           define INT64_C(c)	CAT2(c,LL)
#           define UINT64_C(c)	CAT2(c,ULL)
#       else
#           if LONGSIZE == 8 && QUADKIND == QUAD_IS_LONG
#               define INT64_C(c)	CAT2(c,L)
#               define UINT64_C(c)	CAT2(c,UL)
#           else
#               define INT64_C(c)	((I64TYPE)(c))
#               define UINT64_C(c)	((U64TYPE)(c))
#           endif
#       endif
#   endif
#endif

d263 2
a264 2
Returns a boolean indicating whether the C C<char> is an ASCII alphanumeric
character (including underscore) or digit.
d267 1
a267 1
Returns a boolean indicating whether the C C<char> is an ASCII alphabetic
d274 1
a274 1
Returns a boolean indicating whether the C C<char> is an ASCII
a298 2
#define isPSXSPC(c)	(isSPACE(c) || (c) == '\v')
#define isBLANK(c)	((c) == ' ' || (c) == '\t')
a384 3
#define isPSXSPC_LC(c)		(isSPACE_LC(c) || (c) == '\v')
#define isBLANK_LC(c)		isBLANK(c) /* could be wrong */

a402 3
#define isPSXSPC_uni(c)		(isSPACE_uni(c) ||(c) == '\f')
#define isBLANK_uni(c)		isBLANK(c) /* could be wrong */

a418 3
#define isPSXSPC_LC_uni(c)	(isSPACE_LC_uni(c) ||(c) == '\f')
#define isBLANK_LC_uni(c)	isBLANK(c) /* could be wrong */

d437 15
a451 21
#define isPSXSPC_utf8(c)	(isSPACE_utf8(c) ||(c) == '\f')
#define isBLANK_utf8(c)		isBLANK(c) /* could be wrong */

#define isALNUM_LC_utf8(p)	isALNUM_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isIDFIRST_LC_utf8(p)	isIDFIRST_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isALPHA_LC_utf8(p)	isALPHA_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isSPACE_LC_utf8(p)	isSPACE_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isDIGIT_LC_utf8(p)	isDIGIT_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isUPPER_LC_utf8(p)	isUPPER_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isLOWER_LC_utf8(p)	isLOWER_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isALNUMC_LC_utf8(p)	isALNUMC_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isCNTRL_LC_utf8(p)	isCNTRL_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isGRAPH_LC_utf8(p)	isGRAPH_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isPRINT_LC_utf8(p)	isPRINT_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define isPUNCT_LC_utf8(p)	isPUNCT_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define toUPPER_LC_utf8(p)	toUPPER_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define toTITLE_LC_utf8(p)	toTITLE_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))
#define toLOWER_LC_utf8(p)	toLOWER_LC_uni(utf8_to_uv(p, UTF8_MAXLEN, 0, 0))

#define isPSXSPC_LC_utf8(c)	(isSPACE_LC_utf8(c) ||(c) == '\f')
#define isBLANK_LC_utf8(c)	isBLANK(c) /* could be wrong */
d454 2
a455 1
#  define toCTRL(c)	Perl_ebcdic_control(c)
d470 1
a470 1
/*
d487 1
a487 1
space is allocated.)  The reference count for the new SV is set to 1.
d508 1
a508 1
=for apidoc Am|void|Safefree|void* ptr
d527 1
a527 1
This is an architecture-independent macro to copy one structure to another.
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
d24 2
a25 1
=head1 Handy Values
a26 2
=for apidoc AmU||Nullch 
Null character pointer.
a118 8
#   ifdef INT32_MIN_BROKEN
#       undef  INT32_MIN
#       define INT32_MIN (-2147483647-1)
#   endif
#   ifdef INT64_MIN_BROKEN
#       undef  INT64_MIN
#       define INT64_MIN (-9223372036854775807LL-1)
#   endif
d168 1
a168 5
#ifndef UINT32_MAX_BROKEN /* e.g. HP-UX with gcc messes this up */
#  define U32_MAX UINT32_MAX
#else
#  define U32_MAX 4294967295U
#endif
a196 1
/* log(2) is pretty close to  0.30103, just in case anyone is grepping for it */
a203 2
=head1 Miscellaneous Functions

a276 3

=head1 Character classes

d335 1
a335 1
#   define isCNTRL(c)	((c) < ' ' || (c) == 127)
d337 1
a337 1
#   define isPRINT(c)	(((c) > 32 && (c) < 127) || (c) == ' ')
d419 3
a421 4
#define toUPPER_uni(c,s,l)	to_uni_upper(c,s,l)
#define toTITLE_uni(c,s,l)	to_uni_title(c,s,l)
#define toLOWER_uni(c,s,l)	to_uni_lower(c,s,l)
#define toFOLD_uni(c,s,l)	to_uni_fold(c,s,l)
d426 15
a440 12
#define isALNUM_LC_uvchr(c)	(c < 256 ? isALNUM_LC(c) : is_uni_alnum_lc(c))
#define isIDFIRST_LC_uvchr(c)	(c < 256 ? isIDFIRST_LC(c) : is_uni_idfirst_lc(c))
#define isALPHA_LC_uvchr(c)	(c < 256 ? isALPHA_LC(c) : is_uni_alpha_lc(c))
#define isSPACE_LC_uvchr(c)	(c < 256 ? isSPACE_LC(c) : is_uni_space_lc(c))
#define isDIGIT_LC_uvchr(c)	(c < 256 ? isDIGIT_LC(c) : is_uni_digit_lc(c))
#define isUPPER_LC_uvchr(c)	(c < 256 ? isUPPER_LC(c) : is_uni_upper_lc(c))
#define isLOWER_LC_uvchr(c)	(c < 256 ? isLOWER_LC(c) : is_uni_lower_lc(c))
#define isALNUMC_LC_uvchr(c)	(c < 256 ? isALNUMC_LC(c) : is_uni_alnumc_lc(c))
#define isCNTRL_LC_uvchr(c)	(c < 256 ? isCNTRL_LC(c) : is_uni_cntrl_lc(c))
#define isGRAPH_LC_uvchr(c)	(c < 256 ? isGRAPH_LC(c) : is_uni_graph_lc(c))
#define isPRINT_LC_uvchr(c)	(c < 256 ? isPRINT_LC(c) : is_uni_print_lc(c))
#define isPUNCT_LC_uvchr(c)	(c < 256 ? isPUNCT_LC(c) : is_uni_punct_lc(c))
d446 1
a446 4
/* The ID_Start of Unicode is quite limiting: it assumes a L-class
 * character (meaning that you cannot have, say, a CJK character).
 * Instead, let's allow ID_Continue but not digits. */
#define isIDFIRST_utf8(p)	(is_utf8_idcont(p) && !is_utf8_digit(p))
d459 3
a461 3
#define toUPPER_utf8(p,s,l)	to_utf8_upper(p,s,l)
#define toTITLE_utf8(p,s,l)	to_utf8_title(p,s,l)
#define toLOWER_utf8(p,s,l)	to_utf8_lower(p,s,l)
d466 15
a480 12
#define isALNUM_LC_utf8(p)	isALNUM_LC_uvchr(utf8_to_uvchr(p,  0))
#define isIDFIRST_LC_utf8(p)	isIDFIRST_LC_uvchr(utf8_to_uvchr(p,  0))
#define isALPHA_LC_utf8(p)	isALPHA_LC_uvchr(utf8_to_uvchr(p,  0))
#define isSPACE_LC_utf8(p)	isSPACE_LC_uvchr(utf8_to_uvchr(p,  0))
#define isDIGIT_LC_utf8(p)	isDIGIT_LC_uvchr(utf8_to_uvchr(p,  0))
#define isUPPER_LC_utf8(p)	isUPPER_LC_uvchr(utf8_to_uvchr(p,  0))
#define isLOWER_LC_utf8(p)	isLOWER_LC_uvchr(utf8_to_uvchr(p,  0))
#define isALNUMC_LC_utf8(p)	isALNUMC_LC_uvchr(utf8_to_uvchr(p,  0))
#define isCNTRL_LC_utf8(p)	isCNTRL_LC_uvchr(utf8_to_uvchr(p,  0))
#define isGRAPH_LC_utf8(p)	isGRAPH_LC_uvchr(utf8_to_uvchr(p,  0))
#define isPRINT_LC_utf8(p)	isPRINT_LC_uvchr(utf8_to_uvchr(p,  0))
#define isPUNCT_LC_utf8(p)	isPUNCT_LC_uvchr(utf8_to_uvchr(p,  0))
a513 2
=head1 SV Manipulation Functions

a520 2
=head1 Memory Management

d560 2
a561 6
=for apidoc Am|void|Poison|void* dest|int nitems|type

Fill up memory with a pattern (byte 0xAB over and over again) that
hopefully catches attempts to access uninitialized memory.

=cut */
a604 2
#define Poison(d,n,t)	(void)memset((char*)(d), 0xAB, (n) * sizeof(t))

a613 1
#define Poison(d,n,t)
a622 13

#ifdef NEED_VA_COPY
# ifdef va_copy
#  define Perl_va_copy(s, d) va_copy(d, s)
# else
#  if defined(__va_copy)
#   define Perl_va_copy(s, d) __va_copy(d, s)
#  else
#   define Perl_va_copy(s, d) Copy(s, d, 1, va_list)
#  endif
# endif
#endif

@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,
 *    2000, 2001, 2002, by Larry Wall and others
a27 1

d503 1
a503 5
#  ifdef PERL_IMPLICIT_CONTEXT
#    define toCTRL(c)     Perl_ebcdic_control(aTHX_ c)
#  else
#    define toCTRL        Perl_ebcdic_control
#  endif
d509 2
a510 2
/* Line numbers are unsigned, 32 bits. */
typedef U32 line_t;
d514 1
a514 1
#define NOLINE ((line_t) 4294967295UL)
d519 12
d592 2
d604 22
a650 2

#define C_ARRAY_LENGTH(a)	(sizeof(a)/sizeof((a)[0]))
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2004, by Larry Wall and others
d360 1
a360 1
#   define isXDIGIT(c)  (isDIGIT(c) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
a585 30
#ifdef PERL_MALLOC_WRAP
#define MEM_WRAP_CHECK(n,t) \
	(void)((n)>((MEM_SIZE)~0)/sizeof(t)?(Perl_croak_nocontext(PL_memory_wrap),0):0)
#define MEM_WRAP_CHECK_1(n,t,a) \
	(void)((n)>((MEM_SIZE)~0)/sizeof(t)?(Perl_croak_nocontext(a),0):0)
#define MEM_WRAP_CHECK_2(n,t,a,b) \
	(void)((n)>((MEM_SIZE)~0)/sizeof(t)?(Perl_croak_nocontext(a,b),0):0)

#define New(x,v,n,t)	(v = (MEM_WRAP_CHECK(n,t), (t*)safemalloc((MEM_SIZE)((n)*sizeof(t)))))
#define Newc(x,v,n,t,c)	(v = (MEM_WRAP_CHECK(n,t), (c*)safemalloc((MEM_SIZE)((n)*sizeof(t)))))
#define Newz(x,v,n,t)	(v = (MEM_WRAP_CHECK(n,t), (t*)safemalloc((MEM_SIZE)((n)*sizeof(t))))), \
			memzero((char*)(v), (n)*sizeof(t))
#define Renew(v,n,t) \
	  (v = (MEM_WRAP_CHECK(n,t), (t*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t)))))
#define Renewc(v,n,t,c) \
	  (v = (MEM_WRAP_CHECK(n,t), (c*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t)))))
#define Safefree(d)	safefree((Malloc_t)(d))

#define Move(s,d,n,t)	(MEM_WRAP_CHECK(n,t), (void)memmove((char*)(d),(char*)(s), (n) * sizeof(t)))
#define Copy(s,d,n,t)	(MEM_WRAP_CHECK(n,t), (void)memcpy((char*)(d),(char*)(s), (n) * sizeof(t)))
#define Zero(d,n,t)	(MEM_WRAP_CHECK(n,t), (void)memzero((char*)(d), (n) * sizeof(t)))

#define Poison(d,n,t)	(MEM_WRAP_CHECK(n,t), (void)memset((char*)(d), 0xAB, (n) * sizeof(t)))

#else

#define MEM_WRAP_CHECK(n,t)
#define MEM_WRAP_CHECK_1(n,t,a)
#define MEM_WRAP_CHECK_2(n,t,a,b)

a601 2
#endif

a635 16
/* convenience debug macros */
#ifdef USE_ITHREADS
#define pTHX_FORMAT  "Perl interpreter: 0x%p"
#define pTHX__FORMAT ", Perl interpreter: 0x%p"
#define pTHX_VALUE_   (unsigned long)my_perl,
#define pTHX_VALUE    (unsigned long)my_perl
#define pTHX__VALUE_ ,(unsigned long)my_perl,
#define pTHX__VALUE  ,(unsigned long)my_perl
#else
#define pTHX_FORMAT 
#define pTHX__FORMAT
#define pTHX_VALUE_ 
#define pTHX_VALUE
#define pTHX__VALUE_ 
#define pTHX__VALUE
#endif /* USE_ITHREADS */
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@a561 4
=for apidoc Am|void *|MoveD|void* src|void* dest|int nitems|type
Like C<Move> but returns dest. Useful for encouraging compilers to tail-call
optimise.

a566 5
=for apidoc Am|void *|CopyD|void* src|void* dest|int nitems|type

Like C<Copy> but returns dest. Useful for encouraging compilers to tail-call
optimise.

a571 5
=for apidoc Am|void *|ZeroD|void* dest|int nitems|type

Like C<Zero> but returns dest. Useful for encouraging compilers to tail-call
optimise.

a607 9
#define MoveD(s,d,n,t)	(MEM_WRAP_CHECK(n,t), memmove((char*)(d),(char*)(s), (n) * sizeof(t)))
#define CopyD(s,d,n,t)	(MEM_WRAP_CHECK(n,t), memcpy((char*)(d),(char*)(s), (n) * sizeof(t)))
#ifdef HAS_MEMSET
#define ZeroD(d,n,t)	(MEM_WRAP_CHECK(n,t), memzero((char*)(d), (n) * sizeof(t)))
#else
/* Using bzero(), which returns void.  */
#define ZeroD(d,n,t)	(MEM_WRAP_CHECK(n,t), memzero((char*)(d), (n) * sizeof(t)),d)
#endif

a629 8
#define MoveD(s,d,n,t)	memmove((char*)(d),(char*)(s), (n) * sizeof(t))
#define CopyD(s,d,n,t)	memcpy((char*)(d),(char*)(s), (n) * sizeof(t))
#ifdef HAS_MEMSET
#define ZeroD(d,n,t)	memzero((char*)(d), (n) * sizeof(t))
#else
#define ZeroD(d,n,t)	((void)memzero((char*)(d), (n) * sizeof(t)),d)
#endif

a642 3
#define MoveD(s,d,n,t)	d
#define CopyD(s,d,n,t)	d
#define ZeroD(d,n,t)	d
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2004, 2005, 2006, by Larry Wall and others
a89 15
/* Try to figure out __func__ or __FUNCTION__ equivalent, if any.
 * XXX Should really be a Configure probe, with HAS__FUNCTION__
 *     and FUNCTION__ as results.
 * XXX Similarly, a Configure probe for __FILE__ and __LINE__ is needed. */
#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || (defined(__SUNPRO_C)) /* C99 or close enough. */
#  define FUNCTION__ __func__
#else
#  if (defined(_MSC_VER) && _MSC_VER < 1300) || /* Pre-MSVC 7.0 has neither __func__ nor __FUNCTION and no good workarounds, either. */ \
      (defined(__DECC_VER)) /* Tru64 or VMS, and strict C89 being used, but not modern enough cc (in Tur64, -c99 not known, only -std1). */
#    define FUNCTION__ ""
#  else
#    define FUNCTION__ __FUNCTION__ /* Common extension. */
#  endif
#endif

a161 5
/* HMB H.Merijn Brand - a placeholder for preparing Configure patches */
#if defined(HAS_MALLOC_SIZE) && defined(HAS_MALLOC_GOOD_SIZE)
/* Not (yet) used at top level, but mention them for metaconfig */
#endif

d517 3
d521 1
d536 1
a536 1
=for apidoc Am|void|Newx|void* ptr|int nitems|type
d539 1
a539 1
=for apidoc Am|void|Newxc|void* ptr|int nitems|type|cast
d543 1
a543 1
=for apidoc Am|void|Newxz|void* ptr|int nitems|type
a546 5
In 5.9.3, we removed the 1st parameter, a debug aid, from the api.  It
was used to uniquely identify each usage of these allocation
functions, but was deemed unnecessary with the availability of better
memory tracking tools, valgrind for example.

d596 2
d601 2
a602 1
#define MEM_WRAP_CHECK(n,t) MEM_WRAP_CHECK_1(n,t,PL_memory_wrap)
d604 13
a616 2
	(void)(sizeof(t) > 1 && (n) > ((MEM_SIZE)~0)/sizeof(t) && (Perl_croak_nocontext(a),0))
#define MEM_WRAP_CHECK_(n,t) MEM_WRAP_CHECK(n,t),
d618 14
a631 1
#define PERL_STRLEN_ROUNDUP(n) ((void)(((n) > (MEM_SIZE)~0 - 2 * PERL_STRLEN_ROUNDUP_QUANTUM) ? (Perl_croak_nocontext(PL_memory_wrap),0):0),((n-1+PERL_STRLEN_ROUNDUP_QUANTUM)&~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM-1)))
a637 3
#define MEM_WRAP_CHECK_(n,t)

#define PERL_STRLEN_ROUNDUP(n) (((n-1+PERL_STRLEN_ROUNDUP_QUANTUM)&~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM-1)))
d639 3
a641 5
#endif

#define Newx(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) (t*)safemalloc((MEM_SIZE)((n)*sizeof(t)))))
#define Newxc(v,n,t,c)	(v = (MEM_WRAP_CHECK_(n,t) (c*)safemalloc((MEM_SIZE)((n)*sizeof(t)))))
#define Newxz(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) (t*)safemalloc((MEM_SIZE)((n)*sizeof(t))))), \
a642 5
/* pre 5.9.x compatibility */
#define New(x,v,n,t)	Newx(v,n,t)
#define Newc(x,v,n,t,c)	Newxc(v,n,t,c)
#define Newz(x,v,n,t)	Newxz(v,n,t)

d644 1
a644 1
	  (v = (MEM_WRAP_CHECK_(n,t) (t*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t)))))
d646 2
a647 1
	  (v = (MEM_WRAP_CHECK_(n,t) (c*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t)))))
d649 8
a656 3
#ifdef PERL_POISON
#define Safefree(d) \
  (d ? (void)(safefree((Malloc_t)(d)), Poison(&(d), 1, Malloc_t)) : (void) 0)
d658 1
a658 1
#define Safefree(d)	safefree((Malloc_t)(d))
d661 1
a661 3
#define Move(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) (void)memmove((char*)(d),(const char*)(s), (n) * sizeof(t)))
#define Copy(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) (void)memcpy((char*)(d),(const char*)(s), (n) * sizeof(t)))
#define Zero(d,n,t)	(MEM_WRAP_CHECK_(n,t) (void)memzero((char*)(d), (n) * sizeof(t)))
a662 7
#define MoveD(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) memmove((char*)(d),(const char*)(s), (n) * sizeof(t)))
#define CopyD(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) memcpy((char*)(d),(const char*)(s), (n) * sizeof(t)))
#ifdef HAS_MEMSET
#define ZeroD(d,n,t)	(MEM_WRAP_CHECK_(n,t) memzero((char*)(d), (n) * sizeof(t)))
#else
/* Using bzero(), which returns void.  */
#define ZeroD(d,n,t)	(MEM_WRAP_CHECK_(n,t) memzero((char*)(d), (n) * sizeof(t)),d)
d665 16
a680 1
#define Poison(d,n,t)	(MEM_WRAP_CHECK_(n,t) (void)memset((char*)(d), 0xAB, (n) * sizeof(t)))
d706 4
a709 4
#define pTHX_VALUE_   (void *)my_perl,
#define pTHX_VALUE    (void *)my_perl
#define pTHX__VALUE_ ,(void *)my_perl,
#define pTHX__VALUE  ,(void *)my_perl
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2004, 2005, 2006, 2007, by Larry Wall and others
d27 1
a27 1
=for apidoc AmU||Nullch
d62 1
a62 1
#ifdef __GNUG__		/* GNU g++ has bool built-in */
d125 3
a127 3
	SHORTSIZE == sizeof(short)
	INTSIZE == sizeof(int)
	LONGSIZE == sizeof(long)
d129 1
a129 1
	PTRSIZE == sizeof(void *)
d178 1
a178 1
#if defined(HAS_MALLOC_SIZE) && defined(LOCALTIME_R_NEEDS_TZSET) && defined(HAS_PSEUDOFORK)
a239 64
=head1 SV-Body Allocation

=for apidoc Ama|SV*|newSVpvs|const char* s
Like C<newSVpvn>, but takes a literal string instead of a string/length pair.

=for apidoc Ama|SV*|newSVpvs_share|const char* s
Like C<newSVpvn_share>, but takes a literal string instead of a string/length
pair and omits the hash parameter.

=for apidoc Am|void|sv_catpvs|SV* sv|const char* s
Like C<sv_catpvn>, but takes a literal string instead of a string/length pair.

=for apidoc Am|void|sv_setpvs|SV* sv|const char* s
Like C<sv_setpvn>, but takes a literal string instead of a string/length pair.

=head1 Memory Management

=for apidoc Ama|char*|savepvs|const char* s
Like C<savepvn>, but takes a literal string instead of a string/length pair.

=head1 GV Functions

=for apidoc Am|HV*|gv_stashpvs|const char* name|I32 create
Like C<gv_stashpvn>, but takes a literal string instead of a string/length pair.

=head1 Hash Manipulation Functions

=for apidoc Am|SV**|hv_fetchs|HV* tb|const char* key|I32 lval
Like C<hv_fetch>, but takes a literal string instead of a string/length pair.

=for apidoc Am|SV**|hv_stores|HV* tb|const char* key|NULLOK SV* val
Like C<hv_store>, but takes a literal string instead of a string/length pair
and omits the hash parameter.

=cut
*/

/* concatenating with "" ensures that only literal strings are accepted as argument */
#define STR_WITH_LEN(s)  (s ""), (sizeof(s)-1)

/* note that STR_WITH_LEN() can't be used as argument to macros or functions that
 * under some configurations might be macros, which means that it requires the full
 * Perl_xxx(aTHX_ ...) form for any API calls where it's used.
 */

/* STR_WITH_LEN() shortcuts */
#define newSVpvs(str) Perl_newSVpvn(aTHX_ STR_WITH_LEN(str))
#define newSVpvs_share(str) Perl_newSVpvn_share(aTHX_ STR_WITH_LEN(str), 0)
#define sv_catpvs(sv, str) Perl_sv_catpvn_flags(aTHX_ sv, STR_WITH_LEN(str), SV_GMAGIC)
#define sv_setpvs(sv, str) Perl_sv_setpvn(aTHX_ sv, STR_WITH_LEN(str))
#define savepvs(str) Perl_savepvn(aTHX_ STR_WITH_LEN(str))
#define gv_stashpvs(str, create) Perl_gv_stashpvn(aTHX_ STR_WITH_LEN(str), create)
#define gv_fetchpvs(namebeg, add, sv_type) Perl_gv_fetchpvn_flags(aTHX_ STR_WITH_LEN(namebeg), add, sv_type)
#define hv_fetchs(hv,key,lval)						\
  ((SV **)Perl_hv_common(aTHX_ (hv), NULL, STR_WITH_LEN(key), 0,	\
			 (lval) ? (HV_FETCH_JUST_SV | HV_FETCH_LVALUE)	\
			 : HV_FETCH_JUST_SV, NULL, 0))

#define hv_stores(hv,key,val)						\
  ((SV **)Perl_hv_common(aTHX_ (hv), NULL, STR_WITH_LEN(key), 0,	\
			 (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), (val), 0))


/*
a294 4
#define memEQs(s1, l, s2) \
	(sizeof(s2)-1 == l && memEQ(s1, (s2 ""), (sizeof(s2)-1)))
#define memNEs(s1, l, s2) !memEQs(s1, l, s2)

d378 1
a378 1
#   define isPRINT(c)	(((c) >= 32 && (c) < 127))
d425 1
a425 1
#    define isALNUM_LC(c)	(isascii(c) && (isalnum(c) || (c) == '_'))
d541 9
a554 6
In 5.9.3, Newx() and friends replace the older New() API, and drops
the first parameter, I<x>, a debug aid which allowed callers to identify
themselves.  This aid has been superseded by a new build option,
PERL_MEM_LOG (see L<perlhack/PERL_MEM_LOG>).  The older API is still
there for use in XS modules supporting older perls.

d557 1
a557 1
cast.  See also C<Newx>.
d561 6
a566 1
memory is zeroed with C<memzero>.  See also C<Newx>.
a609 13
=for apidoc Am|void|PoisonWith|void* dest|int nitems|type|U8 byte

Fill up memory with a byte pattern (a byte repeated over and over
again) that hopefully catches attempts to access uninitialized memory.

=for apidoc Am|void|PoisonNew|void* dest|int nitems|type

PoisonWith(0xAB) for catching access to allocated but uninitialized memory.

=for apidoc Am|void|PoisonFree|void* dest|int nitems|type

PoisonWith(0xEF) for catching access to freed memory.

d612 2
a613 1
PoisonWith(0xEF) for catching access to freed memory.
a616 2
/* Maintained for backwards-compatibility only. Use newSV() instead. */
#ifndef PERL_CORE
a617 3
#endif

#define MEM_SIZE_MAX ((MEM_SIZE)~0)
a618 3
/* The +0.0 in MEM_WRAP_CHECK_ is an attempt to foil
 * overly eager compilers that will bleat about e.g.
 * (U16)n > (size_t)~0/sizeof(U16) always being false. */
d622 1
a622 1
	(void)(sizeof(t) > 1 && ((MEM_SIZE)(n)+0.0) > MEM_SIZE_MAX/sizeof(t) && (Perl_croak_nocontext(a),0))
d625 1
a625 1
#define PERL_STRLEN_ROUNDUP(n) ((void)(((n) > MEM_SIZE_MAX - 2 * PERL_STRLEN_ROUNDUP_QUANTUM) ? (Perl_croak_nocontext(PL_memory_wrap),0):0),((n-1+PERL_STRLEN_ROUNDUP_QUANTUM)&~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM-1)))
d638 4
a641 60
#ifdef PERL_MEM_LOG
/*
 * If PERL_MEM_LOG is defined, all Newx()s, Renew()s, and Safefree()s
 * go through functions, which are handy for debugging breakpoints, but
 * which more importantly get the immediate calling environment (file and
 * line number, and C function name if available) passed in.  This info can
 * then be used for logging the calls, for which one gets a sample
 * implementation if PERL_MEM_LOG_STDERR is defined.
 *
 * Known problems:
 * - all memory allocs do not get logged, only those
 *   that go through Newx() and derivatives (while all
 *  Safefrees do get logged)
 * - __FILE__ and __LINE__ do not work everywhere
 * - __func__ or __FUNCTION__ even less so
 * - I think more goes on after the perlio frees but
 *   the thing is that STDERR gets closed (as do all
 *   the file descriptors)
 * - no deeper calling stack than the caller of the Newx()
 *   or the kind, but do I look like a C reflection/introspection
 *   utility to you?
 * - the function prototypes for the logging functions
 *   probably should maybe be somewhere else than handy.h
 * - one could consider inlining (macrofying) the logging
 *   for speed, but I am too lazy
 * - one could imagine recording the allocations in a hash,
 *   (keyed by the allocation address?), and maintain that
 *   through reallocs and frees, but how to do that without
 *   any News() happening...?
 */

Malloc_t Perl_mem_log_alloc(const UV n, const UV typesize, const char *typename, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);

Malloc_t Perl_mem_log_realloc(const UV n, const UV typesize, const char *typename, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);

Malloc_t Perl_mem_log_free(Malloc_t oldalloc, const char *filename, const int linenumber, const char *funcname);

#endif

#ifdef PERL_MEM_LOG
#define MEM_LOG_ALLOC(n,t,a)     Perl_mem_log_alloc(n,sizeof(t),STRINGIFY(t),a,__FILE__,__LINE__,FUNCTION__)
#define MEM_LOG_REALLOC(n,t,v,a) Perl_mem_log_realloc(n,sizeof(t),STRINGIFY(t),v,a,__FILE__,__LINE__,FUNCTION__)
#define MEM_LOG_FREE(a)          Perl_mem_log_free(a,__FILE__,__LINE__,FUNCTION__)
#endif

#ifndef MEM_LOG_ALLOC
#define MEM_LOG_ALLOC(n,t,a)     (a)
#endif
#ifndef MEM_LOG_REALLOC
#define MEM_LOG_REALLOC(n,t,v,a) (a)
#endif
#ifndef MEM_LOG_FREE
#define MEM_LOG_FREE(a)          (a)
#endif

#define Newx(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) MEM_LOG_ALLOC(n,t,(t*)safemalloc((MEM_SIZE)((n)*sizeof(t))))))
#define Newxc(v,n,t,c)	(v = (MEM_WRAP_CHECK_(n,t) MEM_LOG_ALLOC(n,t,(c*)safemalloc((MEM_SIZE)((n)*sizeof(t))))))
#define Newxz(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) MEM_LOG_ALLOC(n,t,(t*)safecalloc((n),sizeof(t)))))

#ifndef PERL_CORE
a645 1
#endif
d648 1
a648 1
	  (v = (MEM_WRAP_CHECK_(n,t) MEM_LOG_REALLOC(n,t,v,(t*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))))
d650 1
a650 1
	  (v = (MEM_WRAP_CHECK_(n,t) MEM_LOG_REALLOC(n,t,v,(c*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))))
d654 1
a654 1
  ((d) ? (void)(safefree(MEM_LOG_FREE((Malloc_t)(d))), Poison(&(d), 1, Malloc_t)) : (void) 0)
d656 1
a656 1
#define Safefree(d)	safefree(MEM_LOG_FREE((Malloc_t)(d)))
d672 1
a672 4
#define PoisonWith(d,n,t,b)	(MEM_WRAP_CHECK_(n,t) (void)memset((char*)(d), (U8)(b), (n) * sizeof(t)))
#define PoisonNew(d,n,t)	PoisonWith(d,n,t,0xAB)
#define PoisonFree(d,n,t)	PoisonWith(d,n,t,0xEF)
#define Poison(d,n,t)		PoisonFree(d,n,t)
d703 1
a703 1
#define pTHX_FORMAT
d705 1
a705 1
#define pTHX_VALUE_
d707 1
a707 1
#define pTHX__VALUE_
a709 1

@


1.1.1.11
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000,
 *    2001, 2002, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
a48 23
/* The MUTABLE_*() macros cast pointers to the types shown, in such a way
 * (compiler permitting) that casting away const-ness will give a warning;
 * e.g.:
 *
 * const SV *sv = ...;
 * AV *av1 = (AV*)sv;        <== BAD:  the const has been silently cast away
 * AV *av2 = MUTABLE_AV(sv); <== GOOD: it may warn
 */

/* For 5.10.x, disable the const cast checking that MUTABLE_PTR does in
 * blead */
#if 0 && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define MUTABLE_PTR(p) ({ void *_p = (p); _p; })
#else
#  define MUTABLE_PTR(p) ((void *) (p))
#endif

#define MUTABLE_AV(p)	((AV *)MUTABLE_PTR(p))
#define MUTABLE_CV(p)	((CV *)MUTABLE_PTR(p))
#define MUTABLE_GV(p)	((GV *)MUTABLE_PTR(p))
#define MUTABLE_HV(p)	((HV *)MUTABLE_PTR(p))
#define MUTABLE_IO(p)	((IO *)MUTABLE_PTR(p))
#define MUTABLE_SV(p)	((SV *)MUTABLE_PTR(p))
d177 4
a180 9
/* HMB H.Merijn Brand - a placeholder for preparing Configure patches:
 * 
 * USE_DTRACE	HAS_PSEUDOFORK	HAS_TIMEGM	LOCALTIME_R_NEEDS_TZSET	
 * GMTIME_MAX	GMTIME_MIN	LOCALTIME_MAX	LOCALTIME_MIN
 * HAS_CTIME64	HAS_LOCALTIME64	HAS_GMTIME64	HAS_DIFFTIME64
 * HAS_MKTIME64	HAS_ASCTIME64	HAS_GETADDRINFO	HAS_GETNAMEINFO
 * HAS_INETNTOP	HAS_INETPTON
 * Not (yet) used at top level, but mention them for metaconfig
 */
a244 4
=for apidoc Ama|SV*|newSVpvs_flags|const char* s|U32 flags
Like C<newSVpvn_flags>, but takes a literal string instead of a string/length
pair.

d278 1
a278 1
#define STR_WITH_LEN(s)  ("" s ""), (sizeof(s)-1)
a286 2
#define newSVpvs_flags(str,flags)	\
    Perl_newSVpvn_flags(aTHX_ STR_WITH_LEN(str), flags)
d387 2
a388 2
Returns a boolean indicating whether the C C<char> is a US-ASCII (Basic Latin)
alphanumeric character (including underscore) or digit.
d391 2
a392 2
Returns a boolean indicating whether the C C<char> is a US-ASCII (Basic Latin) 
alphabetic character.
d395 1
a395 2
Returns a boolean indicating whether the C C<char> is a US-ASCII (Basic Latin)
whitespace.
d398 1
a398 1
Returns a boolean indicating whether the C C<char> is a US-ASCII (Basic Latin)
d402 2
a403 2
Returns a boolean indicating whether the C C<char> is a US-ASCII (Basic Latin)
uppercase character.
d406 2
a407 2
Returns a boolean indicating whether the C C<char> is a US-ASCII (Basic Latin)
lowercase character.
d410 1
a410 2
Converts the specified character to uppercase.  Characters outside the
US-ASCII (Basic Latin) range are viewed as not having any case.
d413 1
a413 2
Converts the specified character to lowercase.  Characters outside the
US-ASCII (Basic Latin) range are viewed as not having any case.
d702 1
a702 1
	(void)(sizeof(t) > 1 && ((MEM_SIZE)(n)+0.0) > MEM_SIZE_MAX/sizeof(t) && (Perl_croak_nocontext("%s",(a)),0))
d705 1
a705 1
#define PERL_STRLEN_ROUNDUP(n) ((void)(((n) > MEM_SIZE_MAX - 2 * PERL_STRLEN_ROUNDUP_QUANTUM) ? (Perl_croak_nocontext("%s",PL_memory_wrap),0):0),((n-1+PERL_STRLEN_ROUNDUP_QUANTUM)&~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM-1)))
d749 1
a749 1
PERL_EXPORT_C Malloc_t Perl_mem_log_alloc(const UV n, const UV typesize, const char *type_name, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);
d751 1
a751 1
PERL_EXPORT_C Malloc_t Perl_mem_log_realloc(const UV n, const UV typesize, const char *type_name, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);
d753 1
a753 17
PERL_EXPORT_C Malloc_t Perl_mem_log_free(Malloc_t oldalloc, const char *filename, const int linenumber, const char *funcname);

# ifdef PERL_CORE
#  ifdef PERL_MEM_LOG_STDERR
enum mem_log_type {
  MLT_ALLOC,
  MLT_REALLOC,
  MLT_FREE,
  MLT_NEW_SV,
  MLT_DEL_SV
};
#  endif
#  if defined(PERL_IN_SV_C)  /* those are only used in sv.c */
void Perl_mem_log_new_sv(const SV *sv, const char *filename, const int linenumber, const char *funcname);
void Perl_mem_log_del_sv(const SV *sv, const char *filename, const int linenumber, const char *funcname);
#  endif
# endif
d773 3
a775 3
#define Newx(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) (t*)MEM_LOG_ALLOC(n,t,safemalloc((MEM_SIZE)((n)*sizeof(t))))))
#define Newxc(v,n,t,c)	(v = (MEM_WRAP_CHECK_(n,t) (c*)MEM_LOG_ALLOC(n,t,safemalloc((MEM_SIZE)((n)*sizeof(t))))))
#define Newxz(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) (t*)MEM_LOG_ALLOC(n,t,safecalloc((n),sizeof(t)))))
d785 1
a785 1
	  (v = (MEM_WRAP_CHECK_(n,t) (t*)MEM_LOG_REALLOC(n,t,v,saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))))
d787 1
a787 1
	  (v = (MEM_WRAP_CHECK_(n,t) (c*)MEM_LOG_REALLOC(n,t,v,saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))))
a850 9
/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d22 1
a22 2
#ifndef PERL_CORE
#  define Null(type) ((type)NULL)
d28 1
a28 1
Null character pointer. (No longer available when C<PERL_CORE> is defined.)
d31 1
a31 1
Null SV pointer. (No longer available when C<PERL_CORE> is defined.)
d36 3
a38 4
#  define Nullch Null(char*)
#  define Nullfp Null(PerlIO*)
#  define Nullsv Null(SV*)
#endif
d58 3
a60 1
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
d193 2
a194 7
#               if defined(_WIN64) && defined(_MSC_VER)
#                   define INT64_C(c)	CAT2(c,I64)
#                   define UINT64_C(c)	CAT2(c,UI64)
#               else
#                   define INT64_C(c)	((I64TYPE)(c))
#                   define UINT64_C(c)	((U64TYPE)(c))
#               endif
d206 1
a206 1
 * HAS_INETNTOP	HAS_INETPTON	CHARBITS
a335 2
#define get_cvs(str, flags)					\
	Perl_get_cvn_flags(aTHX_ STR_WITH_LEN(str), (flags))
d425 1
a425 1
Returns a boolean indicating whether the C C<char> is a US-ASCII (Basic Latin)
a457 12
/* ALPHAU includes Unicode semantics for latin1 characters.  It has an extra
 * >= AA test to speed up ASCII-only tests at the expense of the others */
#define isALPHAU(c)	(isALPHA(c) || (NATIVE_TO_UNI((U8) c) >= 0xAA \
    && ((NATIVE_TO_UNI((U8) c) >= 0xC0 \
	    && NATIVE_TO_UNI((U8) c) != 0xD7 && NATIVE_TO_UNI((U8) c) != 0xF7) \
	|| NATIVE_TO_UNI((U8) c) == 0xAA \
	|| NATIVE_TO_UNI((U8) c) == 0xB5 \
	|| NATIVE_TO_UNI((U8) c) == 0xBA)))
#define isALNUMU(c)	(isDIGIT(c) || isALPHAU(c) || (c) == '_')

/* continuation character for legal NAME in \N{NAME} */
#define isCHARNAME_CONT(c) (isALNUMU(c) || (c) == ' ' || (c) == '-' || (c) == '(' || (c) == ')' || (c) == ':' || NATIVE_TO_UNI((U8) c) == 0xA0)
a474 1
#   define toUPPER_LATIN1_MOD(c)    UNI_TO_NATIVE(PL_mod_latin1_uc[(U8) NATIVE_TO_UNI(c)])
a475 1
#   define toLOWER_LATIN1(c)	UNI_TO_NATIVE(PL_latin1_lc[(U8) NATIVE_TO_UNI(c)])
a485 9

/* Use table lookup for speed */
#   define toLOWER_LATIN1(c)	(PL_latin1_lc[(U8) c])

/* Modified uc.  Is correct uc except for three non-ascii chars which are
 * all mapped to one of them, and these need special handling */
#   define toUPPER_LATIN1_MOD(c)    (PL_mod_latin1_uc[(U8) c])

/* ASCII casing. */
d558 1
d580 1
d599 1
a643 12
/* Helpful alias for version prescan */
#define is_LAX_VERSION(a,b) \
	(a != Perl_prescan_version(aTHX_ a, FALSE, b, NULL, NULL, NULL, NULL))

#define is_STRICT_VERSION(a,b) \
	(a != Perl_prescan_version(aTHX_ a, TRUE, b, NULL, NULL, NULL, NULL))

#define BADVERSION(a,b,c) \
	if (b) { \
	    *b = c; \
	} \
	return a;
d762 1
a762 1
 * implementation unless -DPERL_MEM_LOG_NOIMPL is also defined.
d765 1
a765 1
 * - not all memory allocs get logged, only those
d767 1
a767 1
 *   Safefrees do get logged)
a783 2
 * - lots of -Ddefines to get useful/controllable output
 * - lots of ENV reads
d793 1
a793 1
#  ifndef PERL_MEM_LOG_NOIMPL
a902 7

/* Perl_deprecate was not part of the public API, and did not have a deprecate()
   shortcut macro defined without -DPERL_CORE. Neither codesearch.google.com nor
   CPAN::Unpack show any users outside the core.  */
#ifdef PERL_CORE
#  define deprecate(s) Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED), "Use of " s " is deprecated")
#endif
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d73 4
a76 7
#ifdef I_STDBOOL
#  include <stdbool.h>
#  ifndef HAS_BOOL
#    define HAS_BOOL 1
#  endif
#endif

a112 7
/* a simple (bool) cast may not do the right thing: if bool is defined
 * as char for example, then the cast from int is implementation-defined
 * (bool)!!(cbool) in a ternary triggers a bug in xlc on AIX
 */

#define cBOOL(cbool) ((cbool) ? (bool)1 : (bool)0)

d205 13
a285 8
=for apidoc Am|void|sv_catpvs_flags|SV* sv|const char* s|I32 flags
Like C<sv_catpvn_flags>, but takes a literal string instead of a
string/length pair.

=for apidoc Am|void|sv_catpvs_nomg|SV* sv|const char* s
Like C<sv_catpvn_nomg>, but takes a literal string instead of a
string/length pair.

a288 4
=for apidoc Am|void|sv_catpvs_mg|SV* sv|const char* s
Like C<sv_catpvn_mg>, but takes a literal string instead of a
string/length pair.

a291 8
=for apidoc Am|void|sv_setpvs_mg|SV* sv|const char* s
Like C<sv_setpvn_mg>, but takes a literal string instead of a
string/length pair.

=for apidoc Am|SV *|sv_setref_pvs|const char* s
Like C<sv_setref_pvn>, but takes a literal string instead of a
string/length pair.

a296 4
=for apidoc Ama|char*|savesharedpvs|const char* s
A version of C<savepvs()> which allocates the duplicate string in memory
which is shared between threads.

a310 7
=head1 Lexer interface

=for apidoc Amx|void|lex_stuff_pvs|const char *pv|U32 flags

Like L</lex_stuff_pvn>, but takes a literal string instead of a
string/length pair.

d327 1
a327 8
#define sv_catpvs_flags(sv, str, flags) \
    Perl_sv_catpvn_flags(aTHX_ sv, STR_WITH_LEN(str), flags)
#define sv_catpvs_nomg(sv, str) \
    Perl_sv_catpvn_flags(aTHX_ sv, STR_WITH_LEN(str), 0)
#define sv_catpvs(sv, str) \
    Perl_sv_catpvn_flags(aTHX_ sv, STR_WITH_LEN(str), SV_GMAGIC)
#define sv_catpvs_mg(sv, str) \
    Perl_sv_catpvn_flags(aTHX_ sv, STR_WITH_LEN(str), SV_GMAGIC|SV_SMAGIC)
a328 3
#define sv_setpvs_mg(sv, str) Perl_sv_setpvn_mg(aTHX_ sv, STR_WITH_LEN(str))
#define sv_setref_pvs(rv, classname, str) \
    Perl_sv_setref_pvn(aTHX_ rv, classname, STR_WITH_LEN(str))
d330 2
a331 9
#define savesharedpvs(str) Perl_savesharedpvn(aTHX_ STR_WITH_LEN(str))
#define gv_stashpvs(str, create) \
    Perl_gv_stashpvn(aTHX_ STR_WITH_LEN(str), create)
#define gv_fetchpvs(namebeg, add, sv_type) \
    Perl_gv_fetchpvn_flags(aTHX_ STR_WITH_LEN(namebeg), add, sv_type)
#define gv_fetchpvn(namebeg, len, add, sv_type) \
    Perl_gv_fetchpvn_flags(aTHX_ namebeg, len, add, sv_type)
#define sv_catxmlpvs(dsv, str, utf8) \
    Perl_sv_catxmlpvn(aTHX_ dsv, STR_WITH_LEN(str), utf8)
a340 2
#define lex_stuff_pvs(pv,flags) Perl_lex_stuff_pvn(aTHX_ STR_WITH_LEN(pv), flags)

d401 1
a401 1
	(sizeof(s2)-1 == l && memEQ(s1, ("" s2 ""), (sizeof(s2)-1)))
d426 4
a429 19
There are three variants for all the functions in this section.  The base ones
operate using the character set of the platform Perl is running on.  The ones
with an C<_A> suffix operate on the ASCII character set, and the ones with an
C<_L1> suffix operate on the full Latin1 character set.  All are unaffected by
locale and by C<use bytes>.

For ASCII platforms, the base function with no suffix and the one with the
C<_A> suffix are identical.  The function with the C<_L1> suffix imposes the
Latin-1 character set onto the platform.  That is, the code points that are
ASCII are unaffected, since ASCII is a subset of Latin-1.  But the non-ASCII
code points are treated as if they are Latin-1 characters.  For example,
C<isSPACE_L1()> will return true when called with the code point 0xA0, which is
the Latin-1 NO-BREAK SPACE.

For EBCDIC platforms, the base function with no suffix and the one with the
C<_L1> suffix should be identical, since, as of this writing, the EBCDIC code
pages that Perl knows about all are equivalent to Latin-1.  The function that
ends in an C<_A> suffix will not return true unless the specified character also
has an ASCII equivalent.
d432 6
a437 10
Returns a boolean indicating whether the specified character is an
alphabetic character in the platform's native character set.
See the L<top of this section|/Character classes> for an explanation of variants
C<isALPHA_A> and C<isALPHA_L1>.

=for apidoc Am|bool|isASCII|char ch
Returns a boolean indicating whether the specified character is one of the 128
characters in the ASCII character set.  On non-ASCII platforms, it is if this
character corresponds to an ASCII character.  Variants C<isASCII_A()> and
C<isASCII_L1()> are identical to C<isASCII()>.
d440 2
a441 21
Returns a boolean indicating whether the specified character is a
digit in the platform's native character set.
Variants C<isDIGIT_A> and C<isDIGIT_L1> are identical to C<isDIGIT>.

=for apidoc Am|bool|isLOWER|char ch
Returns a boolean indicating whether the specified character is a
lowercase character in the platform's native character set.
See the L<top of this section|/Character classes> for an explanation of variants
C<isLOWER_A> and C<isLOWER_L1>.

=for apidoc Am|bool|isOCTAL|char ch
Returns a boolean indicating whether the specified character is an
octal digit, [0-7] in the platform's native character set.
Variants C<isOCTAL_A> and C<isOCTAL_L1> are identical to C<isOCTAL>.

=for apidoc Am|bool|isSPACE|char ch
Returns a boolean indicating whether the specified character is a
whitespace character in the platform's native character set.  This is the same
as what C<\s> matches in a regular expression.
See the L<top of this section|/Character classes> for an explanation of variants
C<isSPACE_A> and C<isSPACE_L1>.
d444 2
a445 19
Returns a boolean indicating whether the specified character is an
uppercase character in the platform's native character set.
See the L<top of this section|/Character classes> for an explanation of variants
C<isUPPER_A> and C<isUPPER_L1>.

=for apidoc Am|bool|isWORDCHAR|char ch
Returns a boolean indicating whether the specified character is a
character that is any of: alphabetic, numeric, or an underscore.  This is the
same as what C<\w> matches in a regular expression.
C<isALNUM()> is a synonym provided for backward compatibility.  Note that it
does not have the standard C language meaning of alphanumeric, since it matches
an underscore and the standard meaning does not.
See the L<top of this section|/Character classes> for an explanation of variants
C<isWORDCHAR_A> and C<isWORDCHAR_L1>.

=for apidoc Am|bool|isXDIGIT|char ch
Returns a boolean indicating whether the specified character is a hexadecimal
digit, [0-9A-Fa-f].  Variants C<isXDIGIT_A()> and C<isXDIGIT_L1()> are
identical to C<isXDIGIT()>.
d447 3
a449 1
=head1 Character case changing
d452 2
a453 2
Converts the specified character to uppercase in the platform's native
character set, if possible; otherwise returns the input character itself.
d456 2
a457 2
Converts the specified character to lowercase in the platform's native
character set, if possible; otherwise returns the input character itself.
a459 4

Note that these macros are repeated in Devel::PPPort, so should also be
patched there.  The file as of this writing is cpan/Devel-PPPort/parts/inc/misc

d462 20
a481 183
/* Specify the widest unsigned type on the platform.  Use U64TYPE because U64
 * is known only in the perl core, and this macro can be called from outside
 * that */
#ifdef HAS_QUAD
#   define WIDEST_UTYPE U64TYPE
#else
#   define WIDEST_UTYPE U32
#endif

/* FITS_IN_8_BITS(c) returns true if c doesn't have  a bit set other than in
 * the lower 8.  It is designed to be hopefully bomb-proof, making sure that no
 * bits of information are lost even on a 64-bit machine, but to get the
 * compiler to optimize it out if possible.  This is because Configure makes
 * sure that the machine has an 8-bit byte, so if c is stored in a byte, the
 * sizeof() guarantees that this evaluates to a constant true at compile time.
 */
#define FITS_IN_8_BITS(c) ((sizeof(c) == 1) || !(((WIDEST_UTYPE)(c)) & ~0xFF))

#ifdef EBCDIC
#   define isASCII(c)    (FITS_IN_8_BITS(c) && (NATIVE_TO_UNI((U8) (c)) < 128))
#else
#   define isASCII(c)    ((WIDEST_UTYPE)(c) < 128)
#endif

#define isASCII_A(c)  isASCII(c)
#define isASCII_L1(c)  isASCII(c)

/* ASCII range only */
#ifdef H_PERL       /* If have access to perl.h, lookup in its table */
/* Bits for PL_charclass[].  These use names used in l1_char_class_tab.h but
 * their actual definitions are here.  If that has a name not used here, it
 * won't compile. */
#  define _CC_ALNUMC_A         (1<<0)
#  define _CC_ALNUMC_L1        (1<<1)
#  define _CC_ALPHA_A          (1<<2)
#  define _CC_ALPHA_L1         (1<<3)
#  define _CC_BLANK_A          (1<<4)
#  define _CC_BLANK_L1         (1<<5)
#  define _CC_CHARNAME_CONT    (1<<6)
#  define _CC_CNTRL_A          (1<<7)
#  define _CC_CNTRL_L1         (1<<8)
#  define _CC_DIGIT_A          (1<<9)
#  define _CC_GRAPH_A          (1<<10)
#  define _CC_GRAPH_L1         (1<<11)
#  define _CC_IDFIRST_A        (1<<12)
#  define _CC_IDFIRST_L1       (1<<13)
#  define _CC_LOWER_A          (1<<14)
#  define _CC_LOWER_L1         (1<<15)
#  define _CC_OCTAL_A          (1<<16)
#  define _CC_PRINT_A          (1<<17)
#  define _CC_PRINT_L1         (1<<18)
#  define _CC_PSXSPC_A         (1<<19)
#  define _CC_PSXSPC_L1        (1<<20)
#  define _CC_PUNCT_A          (1<<21)
#  define _CC_PUNCT_L1         (1<<22)
#  define _CC_SPACE_A          (1<<23)
#  define _CC_SPACE_L1         (1<<24)
#  define _CC_UPPER_A          (1<<25)
#  define _CC_UPPER_L1         (1<<26)
#  define _CC_WORDCHAR_A       (1<<27)
#  define _CC_WORDCHAR_L1      (1<<28)
#  define _CC_XDIGIT_A         (1<<29)
#  define _CC_NONLATIN1_FOLD   (1<<30)
#  define _CC_QUOTEMETA        (1U<<31)	/* 1U keeps Solaris from griping */
/* Unused: None
 * If more are needed, can give up some of the above.  The first ones to go
 * would be those that require just two tests to verify, either there are two
 * code points, like BLANK_A, or occupy a single range like OCTAL_A, DIGIT_A,
 * UPPER_A, and LOWER_A.
 */

#  ifdef DOINIT
EXTCONST  U32 PL_charclass[] = {
#    include "l1_char_class_tab.h"
};

#  else /* ! DOINIT */
EXTCONST U32 PL_charclass[];
#  endif

#   define isALNUMC_A(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_ALNUMC_A))
#   define isALPHA_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_ALPHA_A))
#   define isBLANK_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_BLANK_A))
#   define isCNTRL_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_CNTRL_A))
#   define isDIGIT_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_DIGIT_A))
#   define isGRAPH_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_GRAPH_A))
#   define isIDFIRST_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_IDFIRST_A))
#   define isLOWER_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_LOWER_A))
#   define isOCTAL_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_OCTAL_A))
#   define isPRINT_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_PRINT_A))
#   define isPSXSPC_A(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_PSXSPC_A))
#   define isPUNCT_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_PUNCT_A))
#   define isSPACE_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_SPACE_A))
#   define isUPPER_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_UPPER_A))
#   define isWORDCHAR_A(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_WORDCHAR_A))
#   define isXDIGIT_A(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_XDIGIT_A))
    /* Either participates in a fold with a character above 255, or is a
     * multi-char fold */
#   define _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(c) ((! cBOOL(FITS_IN_8_BITS(c))) || (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_NONLATIN1_FOLD))
#   define _isQUOTEMETA(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_QUOTEMETA))
#else   /* No perl.h. */
#   define isOCTAL_A(c)  ((c) <= '7' && (c) >= '0')
#   ifdef EBCDIC
#       define isALNUMC_A(c)   (isASCII(c) && isALNUMC(c))
#       define isALPHA_A(c)    (isASCII(c) && isALPHA(c))
#       define isBLANK_A(c)    (isASCII(c) && isBLANK(c))
#       define isCNTRL_A(c)    (isASCII(c) && isCNTRL(c))
#       define isDIGIT_A(c)    (isASCII(c) && isDIGIT(c))
#       define isGRAPH_A(c)    (isASCII(c) && isGRAPH(c))
#       define isIDFIRST_A(c)  (isASCII(c) && isIDFIRST(c))
#       define isLOWER_A(c)    (isASCII(c) && isLOWER(c))
#       define isPRINT_A(c)    (isASCII(c) && isPRINT(c))
#       define isPSXSPC_A(c)   (isASCII(c) && isPSXSPC(c))
#       define isPUNCT_A(c)    (isASCII(c) && isPUNCT(c))
#       define isSPACE_A(c)    (isASCII(c) && isSPACE(c))
#       define isUPPER_A(c)    (isASCII(c) && isUPPER(c))
#       define isWORDCHAR_A(c) (isASCII(c) && isWORDCHAR(c))
#       define isXDIGIT_A(c)   (isASCII(c) && isXDIGIT(c))
#   else   /* ASCII platform, no perl.h */
#       define isALNUMC_A(c) (isALPHA_A(c) || isDIGIT_A(c))
#       define isALPHA_A(c)  (isUPPER_A(c) || isLOWER_A(c))
#       define isBLANK_A(c)  ((c) == ' ' || (c) == '\t')
#       define isCNTRL_A(c)  (FITS_IN_8_BITS(c) && ((U8) (c) < ' ' || (c) == 127))
#       define isDIGIT_A(c)  ((c) <= '9' && (c) >= '0')
#       define isGRAPH_A(c)  (isWORDCHAR_A(c) || isPUNCT_A(c))
#       define isIDFIRST_A(c) (isALPHA_A(c) || (c) == '_')
#       define isLOWER_A(c)  ((c) >= 'a' && (c) <= 'z')
#       define isPRINT_A(c)  (((c) >= 32 && (c) < 127))
#       define isPSXSPC_A(c) (isSPACE_A(c) || (c) == '\v')
#       define isPUNCT_A(c)  (((c) >= 33 && (c) <= 47) || ((c) >= 58 && (c) <= 64)  || ((c) >= 91 && (c) <= 96) || ((c) >= 123 && (c) <= 126))
#       define isSPACE_A(c)  ((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) =='\r' || (c) == '\f')
#       define isUPPER_A(c)  ((c) <= 'Z' && (c) >= 'A')
#       define isWORDCHAR_A(c) (isALPHA_A(c) || isDIGIT_A(c) || (c) == '_')
#       define isXDIGIT_A(c)   (isDIGIT_A(c) || ((c) >= 'a' && (c) <= 'f') || ((c) <= 'F' && (c) >= 'A'))
#   endif
#endif  /* ASCII range definitions */

/* Latin1 definitions */
#ifdef H_PERL
#   define isALNUMC_L1(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_ALNUMC_L1))
#   define isALPHA_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_ALPHA_L1))
#   define isBLANK_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_BLANK_L1))
/*  continuation character for legal NAME in \N{NAME} */
#   define isCHARNAME_CONT(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_CHARNAME_CONT))
#   define isCNTRL_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_CNTRL_L1))
#   define isGRAPH_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_GRAPH_L1))
#   define isIDFIRST_L1(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_IDFIRST_L1))
#   define isLOWER_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_LOWER_L1))
#   define isPRINT_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_PRINT_L1))
#   define isPSXSPC_L1(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_PSXSPC_L1))
#   define isPUNCT_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_PUNCT_L1))
#   define isSPACE_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_SPACE_L1))
#   define isUPPER_L1(c)  cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_UPPER_L1))
#   define isWORDCHAR_L1(c) cBOOL(FITS_IN_8_BITS(c) && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_WORDCHAR_L1))
#else /* No access to perl.h.  Only a few provided here, just in case needed
       * for backwards compatibility */
    /* ALPHAU includes Unicode semantics for latin1 characters.  It has an extra
     * >= AA test to speed up ASCII-only tests at the expense of the others */
#   define isALPHA_L1(c) (isALPHA(c) || (NATIVE_TO_UNI((U8) c) >= 0xAA \
	&& ((NATIVE_TO_UNI((U8) c) >= 0xC0 \
		&& NATIVE_TO_UNI((U8) c) != 0xD7 && NATIVE_TO_UNI((U8) c) != 0xF7) \
	    || NATIVE_TO_UNI((U8) c) == 0xAA \
	    || NATIVE_TO_UNI((U8) c) == 0xB5 \
	    || NATIVE_TO_UNI((U8) c) == 0xBA)))
#   define isCHARNAME_CONT(c) (isALNUM_L1(c) || (c) == ' ' || (c) == '-' || (c) == '(' || (c) == ')' || (c) == ':' || NATIVE_TO_UNI((U8) c) == 0xA0)
#endif

/* Macros for backwards compatibility and for completeness when the ASCII and
 * Latin1 values are identical */
#define isALNUM(c)      isWORDCHAR(c)
#define isALNUMU(c)     isWORDCHAR_L1(c)
#define isALPHAU(c)     isALPHA_L1(c)
#define isDIGIT_L1(c)   isDIGIT_A(c)
#define isOCTAL(c)      isOCTAL_A(c)
#define isOCTAL_L1(c)   isOCTAL_A(c)
#define isXDIGIT_L1(c)  isXDIGIT_A(c)

/* Macros that differ between EBCDIC and ASCII.  Where C89 defines a function,
 * that is used in the EBCDIC form, because in EBCDIC we do not do locales:
 * therefore can use native functions.  For those where C89 doesn't define a
 * function, use our function, assuming that the EBCDIC code page is isomorphic
 * with Latin1, which the three currently recognized by Perl are.  Some libc's
 * have an isblank(), but it's not guaranteed. */
d483 3
d487 1
a487 2
#   define isALPHA(c)	isalpha(c)
#   define isBLANK(c)	((c) == ' ' || (c) == '\t' || NATIVE_TO_UNI(c) == 0xA0)
a488 1
#   define isDIGIT(c)	isdigit(c)
a489 2
#   define isIDFIRST(c) (isALPHA(c) || (c) == '_')
#   define isLOWER(c)	islower(c)
a490 1
#   define isPSXSPC(c)	isspace(c)
a491 2
#   define isSPACE(c)   (isPSXSPC(c) && (c) != '\v')
#   define isUPPER(c)	isupper(c)
d493 2
a494 1
#   define isWORDCHAR(c) (isalnum(c) || (c) == '_')
d496 11
a506 26
#   define toUPPER(c)	toupper(c)
#else /* Not EBCDIC: ASCII-only matching */
#   define isALNUMC(c)  isALNUMC_A(c)
#   define isALPHA(c)   isALPHA_A(c)
#   define isBLANK(c)   isBLANK_A(c)
#   define isCNTRL(c)   isCNTRL_A(c)
#   define isDIGIT(c)   isDIGIT_A(c)
#   define isGRAPH(c)   isGRAPH_A(c)
#   define isIDFIRST(c) isIDFIRST_A(c)
#   define isLOWER(c)   isLOWER_A(c)
#   define isPRINT(c)   isPRINT_A(c)
#   define isPSXSPC(c)	isPSXSPC_A(c)
#   define isPUNCT(c)   isPUNCT_A(c)
#   define isSPACE(c)   isSPACE_A(c)
#   define isUPPER(c)   isUPPER_A(c)
#   define isWORDCHAR(c) isWORDCHAR_A(c)
#   define isXDIGIT(c)  isXDIGIT_A(c)

    /* ASCII casing.  These could also be written as
	#define toLOWER(c) (isASCII(c) ? toLOWER_LATIN1(c) : (c))
	#define toUPPER(c) (isASCII(c) ? toUPPER_LATIN1_MOD(c) : (c))
       which uses table lookup and mask instead of subtraction.  (This would
       work because the _MOD does not apply in the ASCII range) */
#   define toLOWER(c)	(isUPPER(c) ? (c) + ('a' - 'A') : (c))
#   define toUPPER(c)	(isLOWER(c) ? (c) - ('a' - 'A') : (c))
#endif
d508 2
a510 6
/* Use table lookup for speed; return error character for input
 * out-of-range */
#define toLOWER_LATIN1(c)    (FITS_IN_8_BITS(c)                            \
                             ? UNI_TO_NATIVE(PL_latin1_lc[                 \
                                               NATIVE_TO_UNI( (U8) (c)) ]) \
                             : UNICODE_REPLACEMENT)
d512 7
a518 6
 * all mapped to one of them, and these need special handling; error
 * character for input out-of-range */
#define toUPPER_LATIN1_MOD(c) (FITS_IN_8_BITS(c)                           \
                              ? UNI_TO_NATIVE(PL_mod_latin1_uc[            \
                                               NATIVE_TO_UNI( (U8) (c)) ]) \
                              : UNICODE_REPLACEMENT)
a526 2
#  define isASCII_LC(c)		isASCII((unsigned int)(c))
#  define isBLANK_LC(c)		isBLANK((unsigned int)(c))
a542 4
/* Note that the foo_LC() macros in this case generally are defined only on
 * code points 0-256, and give undefined, unwarned results if called with
 * values outside that range */

a545 10
#    ifdef HAS_ISASCII
#	define isASCII_LC(c)	isascii((unsigned char)(c))
#    else
#	define isASCII_LC(c)	isASCII((unsigned char)(c))
#    endif
#    ifdef HAS_ISBLANK
#	define isBLANK_LC(c)	isblank((unsigned char)(c))
#    else
#	define isBLANK_LC(c)	isBLANK((unsigned char)(c))
#    endif
a562 6
#    define isASCII_LC(c)	isascii(c)
#    ifdef HAS_ISBLANK
#	define isBLANK_LC(c)	(isascii(c) && isblank(c))
#    else
#	define isBLANK_LC(c)	isBLANK(c)
#    endif
d579 1
d581 13
a593 25
/* For use in the macros just below.  If the input is Latin1, use the Latin1
 * (_L1) version of the macro; otherwise use the function.  Won't compile if
 * 'c' isn't unsigned, as won't match function prototype. The macros do bounds
 * checking, so have duplicate checks here, so could create versions of the
 * macros that don't, but experiments show that gcc optimizes them out anyway.
 */
#define generic_uni(macro, function, c) ((c) < 256               \
                                         ? CAT2(macro, _L1)(c)   \
                                         : function(c))
/* Note that all ignore 'use bytes' */

#define isALNUM_uni(c)		generic_uni(isWORDCHAR, is_uni_alnum, c)
#define isIDFIRST_uni(c)        generic_uni(isIDFIRST, is_uni_idfirst, c)
#define isALPHA_uni(c)		generic_uni(isALPHA, is_uni_alpha, c)
#define isSPACE_uni(c)		generic_uni(isSPACE, is_uni_space, c)
#define isDIGIT_uni(c)		generic_uni(isDIGIT, is_uni_digit, c)
#define isUPPER_uni(c)		generic_uni(isUPPER, is_uni_upper, c)
#define isLOWER_uni(c)		generic_uni(isLOWER, is_uni_lower, c)
#define isASCII_uni(c)		isASCII(c)
/* All controls are in Latin1 */
#define isCNTRL_uni(c)		((c) < 256 && isCNTRL_L1(c))
#define isGRAPH_uni(c)		generic_uni(isGRAPH, is_uni_graph, c)
#define isPRINT_uni(c)		generic_uni(isPRINT, is_uni_print, c)
#define isPUNCT_uni(c)		generic_uni(isPUNCT, is_uni_punct, c)
#define isXDIGIT_uni(c)		generic_uni(isXDIGIT, is_uni_xdigit, c)
d599 1
a599 2
/* Posix and regular space differ only in U+000B, which is in Latin1 */
#define isPSXSPC_uni(c)		((c) < 256 ? isPSXSPC_L1(c) : isSPACE_uni(c))
d617 16
a632 43
/* For use in the macros just below.  If the input is ASCII, use the ASCII (_A)
 * version of the macro; if the input is in the upper Latin1 range, use the
 * Latin1 (_L1) version of the macro, after converting from utf8; otherwise use
 * the function.  This relies on the fact that ASCII characters have the same
 * representation whether utf8 or not */
#define generic_utf8(macro, function, p) (isASCII(*(p))                        \
                                         ? CAT2(CAT2(macro,_),A)(*(p))               \
                                         : (UTF8_IS_DOWNGRADEABLE_START(*(p))) \
                                           ? CAT2(macro, _L1)                  \
                                             (TWO_BYTE_UTF8_TO_UNI(*(p),       \
                                                                   *((p)+1)))  \
                                           : function(p))

/* Note that all assume that the utf8 has been validated, and ignore 'use
 * bytes' */

#define isALNUM_utf8(p)		generic_utf8(isWORDCHAR, is_utf8_alnum, p)
/* To prevent S_scan_word in toke.c from hanging, we have to make sure that
 * IDFIRST is an alnum.  See
 * http://rt.perl.org/rt3/Ticket/Display.html?id=74022 for more detail than you
 * ever wanted to know about.  XXX It is unclear if this should extend to
 * isIDFIRST_uni() which it hasn't so far.  (In the ASCII range, there isn't a
 * difference.) This used to be not the XID version, but we decided to go with
 * the more modern Unicode definition */
#define isIDFIRST_utf8(p)       (isASCII(*(p))                                  \
                                ? isIDFIRST_A(*(p))                             \
                                : (UTF8_IS_DOWNGRADEABLE_START(*(p)))           \
                                  ? isIDFIRST_L1(TWO_BYTE_UTF8_TO_UNI(*(p),     \
                                                                      *((p)+1)))\
                                  : Perl__is_utf8__perl_idstart(aTHX_ p))
#define isIDCONT_utf8(p)	generic_utf8(isWORDCHAR, is_utf8_xidcont, p)
#define isALPHA_utf8(p)		generic_utf8(isALPHA, is_utf8_alpha, p)
#define isSPACE_utf8(p)		generic_utf8(isSPACE, is_utf8_space, p)
#define isDIGIT_utf8(p)		generic_utf8(isDIGIT, is_utf8_digit, p)
#define isUPPER_utf8(p)		generic_utf8(isUPPER, is_utf8_upper, p)
#define isLOWER_utf8(p)		generic_utf8(isLOWER, is_utf8_lower, p)
/* Because ASCII is invariant under utf8, the non-utf8 macro works */
#define isASCII_utf8(p)		isASCII(p)
#define isCNTRL_utf8(p)		generic_utf8(isCNTRL, is_utf8_cntrl, p)
#define isGRAPH_utf8(p)		generic_utf8(isGRAPH, is_utf8_graph, p)
#define isPRINT_utf8(p)		generic_utf8(isPRINT, is_utf8_print, p)
#define isPUNCT_utf8(p)		generic_utf8(isPUNCT, is_utf8_punct, p)
#define isXDIGIT_utf8(p)	generic_utf8(isXDIGIT, is_utf8_xdigit, p)
d637 1
a637 8
/* Posix and regular space differ only in U+000B, which is in ASCII (and hence
 * Latin1 */
#define isPSXSPC_utf8(p)	((isASCII(*(p)))                               \
                                ? isPSXSPC_A(*(p))                             \
                                : (UTF8_IS_DOWNGRADEABLE_START(*(p))           \
				  ? isPSXSPC_L1(TWO_BYTE_UTF8_TO_UNI(*(p),     \
                                                                     *((p)+1)))\
                                  : isSPACE_utf8(p)))
d640 12
a651 12
#define isALNUM_LC_utf8(p)	isALNUM_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isIDFIRST_LC_utf8(p)	isIDFIRST_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isALPHA_LC_utf8(p)	isALPHA_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isSPACE_LC_utf8(p)	isSPACE_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isDIGIT_LC_utf8(p)	isDIGIT_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isUPPER_LC_utf8(p)	isUPPER_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isLOWER_LC_utf8(p)	isLOWER_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isALNUMC_LC_utf8(p)	isALNUMC_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isCNTRL_LC_utf8(p)	isCNTRL_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isGRAPH_LC_utf8(p)	isGRAPH_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isPRINT_LC_utf8(p)	isPRINT_LC_uvchr(valid_utf8_to_uvchr(p,  0))
#define isPUNCT_LC_utf8(p)	isPUNCT_LC_uvchr(valid_utf8_to_uvchr(p,  0))
d656 10
a665 3
/* This conversion works both ways, strangely enough. On EBCDIC platforms,
 * CTRL-@@ is 0, CTRL-A is 1, etc, just like on ASCII */
#  define toCTRL(c)    (toUPPER(NATIVE_TO_UNI(c)) ^ 64)
d693 1
a693 1
PERL_MEM_LOG (see L<perlhacktips/PERL_MEM_LOG>).  The older API is still
a914 1
#define C_ARRAY_END(a)		(a) + (sizeof(a)/sizeof((a)[0]))
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d4 1
a4 1
 *    2001, 2002, 2004, 2005, 2006, 2007, 2008, 2012 by Larry Wall and others
a10 3
#ifndef HANDY_H /* Guard against nested #inclusion */
#define HANDY_H

d15 1
d17 3
d108 1
a108 1
# if defined(VMS)
d130 1
a130 1
#  if (defined(_MSC_VER) && _MSC_VER < 1300) || /* MSVC6 has neither __func__ nor __FUNCTION and no good workarounds, either. */ \
d194 4
a197 7
#   if defined(HAS_LONG_LONG) && QUADKIND == QUAD_IS_LONG_LONG
#       define PeRl_INT64_C(c)	CAT2(c,LL)
#       define PeRl_UINT64_C(c)	CAT2(c,ULL)
#   else
#       if QUADKIND == QUAD_IS___INT64
#           define PeRl_INT64_C(c)	CAT2(c,I64)
#           define PeRl_UINT64_C(c)	CAT2(c,UI64)
d200 2
a201 2
#               define PeRl_INT64_C(c)	CAT2(c,L)
#               define PeRl_UINT64_C(c)	CAT2(c,UL)
d203 7
a209 2
#               define PeRl_INT64_C(c)	((I64TYPE)(c))
#               define PeRl_UINT64_C(c)	((U64TYPE)(c))
a212 6
#   ifndef UINT64_C
#   define UINT64_C(c) PeRl_UINT64_C(c)
#   endif
#   ifndef INT64_C
#   define INT64_C(c) PeRl_INT64_C(c)
#   endif
d342 1
a342 2
/* concatenating with "" ensures that only literal strings are accepted as
 * argument */
d345 3
a347 3
/* note that STR_WITH_LEN() can't be used as argument to macros or functions
 * that under some configurations might be macros, which means that it requires
 * the full Perl_xxx(aTHX_ ...) form for any API calls where it's used.
d473 19
a491 50
This section is about functions (really macros) that classify characters
into types, such as punctuation versus alphabetic, etc.  Most of these are
analogous to regular expression character classes.  (See
L<perlrecharclass/POSIX Character Classes>.)  There are several variants for
each class.  (Not all macros have all variants; each item below lists the
ones valid for it.)  None are affected by C<use bytes>, and only the ones
with C<LC> in the name are affected by the current locale.

The base function, e.g., C<isALPHA()>, takes an octet (either a C<char> or a
C<U8>) as input and returns a boolean as to whether or not the character
represented by that octet is (or on non-ASCII platforms, corresponds to) an
ASCII character in the named class based on platform, Unicode, and Perl rules.
If the input is a number that doesn't fit in an octet, FALSE is returned.

Variant C<isFOO_A> (e.g., C<isALPHA_A()>) is identical to the base function
with no suffix C<"_A">.

Variant C<isFOO_L1> imposes the Latin-1 (or EBCDIC equivlalent) character set
onto the platform.  That is, the code points that are ASCII are unaffected,
since ASCII is a subset of Latin-1.  But the non-ASCII code points are treated
as if they are Latin-1 characters.  For example, C<isWORDCHAR_L1()> will return
true when called with the code point 0xDF, which is a word character in both
ASCII and EBCDIC (though it represent different characters in each).

Variant C<isFOO_uni> is like the C<isFOO_L1> variant, but accepts any UV code
point as input.  If the code point is larger than 255, Unicode rules are used
to determine if it is in the character class.  For example,
C<isWORDCHAR_uni(0x100)> returns TRUE, since 0x100 is LATIN CAPITAL LETTER A
WITH MACRON in Unicode, and is a word character.

Variant C<isFOO_utf8> is like C<isFOO_uni>, but the input is a pointer to a
(known to be well-formed) UTF-8 encoded string (C<U8*> or C<char*>).  The
classification of just the first (possibly multi-byte) character in the string
is tested.

Variant C<isFOO_LC> is like the C<isFOO_A> and C<isFOO_L1> variants, but uses
the C library function that gives the named classification instead of
hard-coded rules.  For example, C<isDIGIT_LC()> returns the result of calling
C<isdigit()>.  This means that the result is based on the current locale, which
is what C<LC> in the name stands for.  FALSE is always returned if the input
won't fit into an octet.

Variant C<isFOO_LC_uvchr> is like C<isFOO_LC>, but is defined on any UV.  It
returns the same as C<isFOO_LC> for input code points less than 256, and
returns the hard-coded, not-affected-by-locale, Unicode results for larger ones.

Variant C<isFOO_LC_utf8> is like C<isFOO_LC_uvchr>, but the input is a pointer to a
(known to be well-formed) UTF-8 encoded string (C<U8*> or C<char*>).  The
classification of just the first (possibly multi-byte) character in the string
is tested.
d495 1
a495 8
alphabetic character, analogous to C<m/[[:alpha:]]/>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isALPHA_A>, C<isALPHA_L1>, C<isALPHA_uni>, C<isALPHA_utf8>, C<isALPHA_LC>,
C<isALPHA_LC_uvchr>, and C<isALPHA_LC_utf8>.

=for apidoc Am|bool|isALPHANUMERIC|char ch
Returns a boolean indicating whether the specified character is a either an
alphabetic character or decimal digit, analogous to C<m/[[:alnum:]]/>.
d497 1
a497 3
C<isALPHANUMERIC_A>, C<isALPHANUMERIC_L1>, C<isALPHANUMERIC_uni>,
C<isALPHANUMERIC_utf8>, C<isALPHANUMERIC_LC>, C<isALPHANUMERIC_LC_uvchr>, and
C<isALPHANUMERIC_LC_utf8>.
d501 1
a501 2
characters in the ASCII character set, analogous to C<m/[[:ascii:]]/>.
On non-ASCII platforms, it returns TRUE iff this
a503 23
See the L<top of this section|/Character classes> for an explanation of variants
C<isASCII_uni>, C<isASCII_utf8>, C<isASCII_LC>, C<isASCII_LC_uvchr>, and
C<isASCII_LC_utf8>.  Note, however, that some platforms do not have the C
library routine C<isascii()>.  In these cases, the variants whose names contain
C<LC> are the same as the corresponding ones without.

=for apidoc Am|bool|isBLANK|char ch
Returns a boolean indicating whether the specified character is a
character considered to be a blank, analogous to C<m/[[:blank:]]/>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isBLANK_A>, C<isBLANK_L1>, C<isBLANK_uni>, C<isBLANK_utf8>, C<isBLANK_LC>,
C<isBLANK_LC_uvchr>, and C<isBLANK_LC_utf8>.  Note, however, that some
platforms do not have the C library routine C<isblank()>.  In these cases, the
variants whose names contain C<LC> are the same as the corresponding ones
without.

=for apidoc Am|bool|isCNTRL|char ch
Returns a boolean indicating whether the specified character is a
control character, analogous to C<m/[[:cntrl:]]/>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isCNTRL_A>, C<isCNTRL_L1>, C<isCNTRL_uni>, C<isCNTRL_utf8>, C<isCNTRL_LC>,
C<isCNTRL_LC_uvchr>, and C<isCNTRL_LC_utf8>
On EBCDIC platforms, you almost always want to use the C<isCNTRL_L1> variant.
d507 1
a507 1
digit, analogous to C<m/[[:digit:]]/>.
a508 10
See the L<top of this section|/Character classes> for an explanation of variants
C<isDIGIT_uni>, C<isDIGIT_utf8>, C<isDIGIT_LC>, C<isDIGIT_LC_uvchr>, and
C<isDIGIT_LC_utf8>.

=for apidoc Am|bool|isGRAPH|char ch
Returns a boolean indicating whether the specified character is a
graphic character, analogous to C<m/[[:graph:]]/>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isGRAPH_A>, C<isGRAPH_L1>, C<isGRAPH_uni>, C<isGRAPH_utf8>, C<isGRAPH_LC>,
C<isGRAPH_LC_uvchr>, and C<isGRAPH_LC_utf8>.
d512 1
a512 1
lowercase character, analogous to C<m/[[:lower:]]/>.
d514 1
a514 2
C<isLOWER_A>, C<isLOWER_L1>, C<isLOWER_uni>, C<isLOWER_utf8>, C<isLOWER_LC>,
C<isLOWER_LC_uvchr>, and C<isLOWER_LC_utf8>.
d518 2
a519 13
octal digit, [0-7].
The only two variants are C<isOCTAL_A> and C<isOCTAL_L1>; each is identical to
C<isOCTAL>.

=for apidoc Am|bool|isPUNCT|char ch
Returns a boolean indicating whether the specified character is a
punctuation character, analogous to C<m/[[:punct:]]/>.
Note that the definition of what is punctuation isn't as
straightforward as one might desire.  See L<perlrecharclass/POSIX Character
Classes> for details.
See the L<top of this section|/Character classes> for an explanation of variants
C<isPUNCT_A>, C<isPUNCT_L1>, C<isPUNCT_uni>, C<isPUNCT_utf8>, C<isPUNCT_LC>,
C<isPUNCT_LC_uvchr>, and C<isPUNCT_LC_utf8>.
d523 2
a524 9
whitespace character.  This is analogous
to what C<m/\s/> matches in a regular expression.  Starting in Perl 5.18
(experimentally), this also matches what C<m/[[:space:]]/> does.
("Experimentally" means that this change may be backed out in 5.20 or 5.22 if
field experience indicates that it was unwise.)  Prior to 5.18, only the
locale forms of this macro (the ones with C<LC> in their names) matched
precisely what C<m/[[:space:]]/> does.  In those releases, the only difference,
in the non-locale variants, was that C<isSPACE()> did not match a vertical tab.
(See L</isPSXSPC> for a macro that matches a vertical tab in all releases.)
d526 1
a526 18
C<isSPACE_A>, C<isSPACE_L1>, C<isSPACE_uni>, C<isSPACE_utf8>, C<isSPACE_LC>,
C<isSPACE_LC_uvchr>, and C<isSPACE_LC_utf8>.

=for apidoc Am|bool|isPSXSPC|char ch
(short for Posix Space)
Starting in 5.18, this is identical (experimentally) in all its forms to the
corresponding C<isSPACE()> macros.  ("Experimentally" means that this change
may be backed out in 5.20 or 5.22 if field experience indicates that it
was unwise.)
The locale forms of this macro are identical to their corresponding
C<isSPACE()> forms in all Perl releases.  In releases prior to 5.18, the
non-locale forms differ from their C<isSPACE()> forms only in that the
C<isSPACE()> forms don't match a Vertical Tab, and the C<isPSXSPC()> forms do.
Otherwise they are identical.  Thus this macro is analogous to what
C<m/[[:space:]]/> matches in a regular expression.
See the L<top of this section|/Character classes> for an explanation of variants
C<isPSXSPC_A>, C<isPSXSPC_L1>, C<isPSXSPC_uni>, C<isPSXSPC_utf8>, C<isPSXSPC_LC>,
C<isPSXSPC_LC_uvchr>, and C<isPSXSPC_LC_utf8>.
d530 1
a530 1
uppercase character, analogous to C<m/[[:upper:]]/>.
d532 1
a532 2
C<isUPPER_A>, C<isUPPER_L1>, C<isUPPER_uni>, C<isUPPER_utf8>, C<isUPPER_LC>,
C<isUPPER_LC_uvchr>, and C<isUPPER_LC_utf8>.
d534 1
a534 1
=for apidoc Am|bool|isPRINT|char ch
d536 5
a540 14
printable character, analogous to C<m/[[:print:]]/>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isPRINT_A>, C<isPRINT_L1>, C<isPRINT_uni>, C<isPRINT_utf8>, C<isPRINT_LC>,
C<isPRINT_LC_uvchr>, and C<isPRINT_LC_utf8>.

=for apidoc Am|bool|isWORDCHAR|char ch
Returns a boolean indicating whether the specified character is a character
that is a word character, analogous to what C<m/\w/> and C<m/[[:word:]]/> match
in a regular expression.  A word character is an alphabetic character, a
decimal digit, a connecting punctuation character (such as an underscore), or
a "mark" character that attaches to one of those (like some sort of accent).
C<isALNUM()> is a synonym provided for backward compatibility, even though a
word character includes more than the standard C language meaning of
alphanumeric.
d542 1
a542 2
C<isWORDCHAR_A>, C<isWORDCHAR_L1>, C<isWORDCHAR_uni>, C<isWORDCHAR_utf8>,
C<isWORDCHAR_LC>, C<isWORDCHAR_LC_uvchr>, and C<isWORDCHAR_LC_utf8>.
d546 2
a547 30
digit.  In the ASCII range these are C<[0-9A-Fa-f]>.  Variants C<isXDIGIT_A()>
and C<isXDIGIT_L1()> are identical to C<isXDIGIT()>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isXDIGIT_uni>, C<isXDIGIT_utf8>, C<isXDIGIT_LC>, C<isXDIGIT_LC_uvchr>, and
C<isXDIGIT_LC_utf8>.

=for apidoc Am|bool|isIDFIRST|char ch
Returns a boolean indicating whether the specified character can be the first
character of an identifier.  This is very close to, but not quite the same as
the official Unicode property C<XID_Start>.  The difference is that this
returns true only if the input character also matches L</isWORDCHAR>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isIDFIRST_A>, C<isIDFIRST_L1>, C<isIDFIRST_uni>, C<isIDFIRST_utf8>,
C<isIDFIRST_LC>, C<isIDFIRST_LC_uvchr>, and C<isIDFIRST_LC_utf8>.

=for apidoc Am|bool|isIDCONT|char ch
Returns a boolean indicating whether the specified character can be the
second or succeeding character of an identifier.  This is very close to, but
not quite the same as the official Unicode property C<XID_Continue>.  The
difference is that this returns true only if the input character also matches
L</isWORDCHAR>.  See the L<top of this section|/Character classes> for an
explanation of variants C<isIDCONT_A>, C<isIDCONT_L1>, C<isIDCONT_uni>,
C<isIDCONT_utf8>, C<isIDCONT_LC>, C<isIDCONT_LC_uvchr>, and
C<isIDCONT_LC_utf8>.

=head1 Miscellaneous Functions

=for apidoc Am|U8|READ_XDIGIT|char str*
Returns the value of an ASCII-range hex digit and advances the string pointer.
Behaviour is only well defined when isXDIGIT(*str) is true.
d552 2
a553 2
Converts the specified character to uppercase, if possible; otherwise returns
the input character itself.
d556 2
a557 2
Converts the specified character to lowercase, if possible; otherwise returns
the input character itself.
a560 2
XXX Still undocumented isVERTWS_uni and _utf8, and the other toUPPER etc functions

a592 5
/* The lower 3 bits in both the ASCII and EBCDIC representations of '0' are 0,
 * and the 8 possible permutations of those bits exactly comprise the 8 octal
 * digits */
#define isOCTAL_A(c)  cBOOL(FITS_IN_8_BITS(c) && (0xF8 & (c)) == '0')

d595 41
a635 111

/* Character class numbers.  For internal core Perl use only.  The ones less
 * than 32 are used in PL_charclass[] and the ones up through the one that
 * corresponds to <_HIGHEST_REGCOMP_DOT_H_SYNC> are used by regcomp.h and
 * related files.  PL_charclass ones use names used in l1_char_class_tab.h but
 * their actual definitions are here.  If that file has a name not used here,
 * it won't compile.
 *
 * The first group of these is ordered in what I (khw) estimate to be the
 * frequency of their use.  This gives a slight edge to exiting a loop earlier
 * (in reginclass() in regexec.c) */
#  define _CC_WORDCHAR           0      /* \w and [:word:] */
#  define _CC_DIGIT              1      /* \d and [:digit:] */
#  define _CC_ALPHA              2      /* [:alpha:] */
#  define _CC_LOWER              3      /* [:lower:] */
#  define _CC_UPPER              4      /* [:upper:] */
#  define _CC_PUNCT              5      /* [:punct:] */
#  define _CC_PRINT              6      /* [:print:] */
#  define _CC_ALPHANUMERIC       7      /* [:alnum:] */
#  define _CC_GRAPH              8      /* [:graph:] */
#  define _CC_CASED              9      /* [:lower:] and [:upper:] under /i */

#define _FIRST_NON_SWASH_CC     10
/* The character classes above are implemented with swashes.  The second group
 * (just below) contains the ones implemented without.  These are also sorted
 * in rough order of the frequency of their use, except that \v should be last,
 * as it isn't a real Posix character class, and some (small) inefficiencies in
 * regular expression handling would be introduced by putting it in the middle
 * of those that are.  Also, cntrl and ascii come after the others as it may be
 * useful to group these which have no members that match above Latin1, (or
 * above ASCII in the latter case) */

#  define _CC_SPACE             10      /* \s */
#  define _CC_BLANK             11      /* [:blank:] */
#  define _CC_XDIGIT            12      /* [:xdigit:] */
#  define _CC_PSXSPC            13      /* [:space:] */
#  define _CC_CNTRL             14      /* [:cntrl:] */
#  define _CC_ASCII             15      /* [:ascii:] */
#  define _CC_VERTSPACE         16      /* \v */

#  define _HIGHEST_REGCOMP_DOT_H_SYNC _CC_VERTSPACE

/* The members of the third group below do not need to be coordinated with data
 * structures in regcomp.[ch] and regexec.c */
#  define _CC_IDFIRST           17
#  define _CC_CHARNAME_CONT     18
#  define _CC_NONLATIN1_FOLD    19
#  define _CC_QUOTEMETA         20
#  define _CC_NON_FINAL_FOLD    21
#  define _CC_IS_IN_SOME_FOLD   22
#  define _CC_BACKSLASH_FOO_LBRACE_IS_META 31 /* temp, see mk_PL_charclass.pl */
/* Unused: 23-30
 * If more bits are needed, one could add a second word for non-64bit
 * QUAD_IS_INT systems, using some #ifdefs to distinguish between having a 2nd
 * word or not.  The IS_IN_SOME_FOLD bit is the most easily expendable, as it
 * is used only for optimization (as of this writing), and differs in the
 * Latin1 range from the ALPHA bit only in two relatively unimportant
 * characters: the masculine and feminine ordinal indicators, so removing it
 * would just cause /i regexes which match them to run less efficiently */

#if defined(PERL_CORE) || defined(PERL_EXT)
/* An enum version of the character class numbers, to help compilers
 * optimize */
typedef enum {
    _CC_ENUM_ALPHA          = _CC_ALPHA,
    _CC_ENUM_ALPHANUMERIC   = _CC_ALPHANUMERIC,
    _CC_ENUM_ASCII          = _CC_ASCII,
    _CC_ENUM_BLANK          = _CC_BLANK,
    _CC_ENUM_CASED          = _CC_CASED,
    _CC_ENUM_CNTRL          = _CC_CNTRL,
    _CC_ENUM_DIGIT          = _CC_DIGIT,
    _CC_ENUM_GRAPH          = _CC_GRAPH,
    _CC_ENUM_LOWER          = _CC_LOWER,
    _CC_ENUM_PRINT          = _CC_PRINT,
    _CC_ENUM_PSXSPC         = _CC_PSXSPC,
    _CC_ENUM_PUNCT          = _CC_PUNCT,
    _CC_ENUM_SPACE          = _CC_SPACE,
    _CC_ENUM_UPPER          = _CC_UPPER,
    _CC_ENUM_VERTSPACE      = _CC_VERTSPACE,
    _CC_ENUM_WORDCHAR       = _CC_WORDCHAR,
    _CC_ENUM_XDIGIT         = _CC_XDIGIT
} _char_class_number;
#endif

#define POSIX_SWASH_COUNT _FIRST_NON_SWASH_CC
#define POSIX_CC_COUNT    (_HIGHEST_REGCOMP_DOT_H_SYNC + 1)

#if defined(PERL_IN_UTF8_C) || defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)
#   if _CC_WORDCHAR != 0 || _CC_DIGIT != 1 || _CC_ALPHA != 2 || _CC_LOWER != 3 \
       || _CC_UPPER != 4 || _CC_PUNCT != 5 || _CC_PRINT != 6                   \
       || _CC_ALPHANUMERIC != 7 || _CC_GRAPH != 8 || _CC_CASED != 9
      #error Need to adjust order of swash_property_names[]
#   endif

/* This is declared static in each of the few files that this is #defined for
 * to keep them from being publicly accessible.  Hence there is a small amount
 * of wasted space */

static const char* const swash_property_names[] = {
    "XPosixWord",
    "XPosixDigit",
    "XPosixAlpha",
    "XPosixLower",
    "XPosixUpper",
    "XPosixPunct",
    "XPosixPrint",
    "XPosixAlnum",
    "XPosixGraph",
    "Cased"
};
#endif
d646 16
a661 31
    /* The 1U keeps Solaris from griping when shifting sets the uppermost bit */
#   define _CC_mask(classnum) (1U << (classnum))
#   define _generic_isCC(c, classnum) cBOOL(FITS_IN_8_BITS(c) \
                && (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_mask(classnum)))

    /* The mask for the _A versions of the macros; it just adds in the bit for
     * ASCII. */
#   define _CC_mask_A(classnum) (_CC_mask(classnum) | _CC_mask(_CC_ASCII))

    /* The _A version makes sure that both the desired bit and the ASCII bit
     * are present */
#   define _generic_isCC_A(c, classnum) (FITS_IN_8_BITS(c) \
        && ((PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_mask_A(classnum)) \
                                == _CC_mask_A(classnum)))

#   define isALPHA_A(c)  _generic_isCC_A(c, _CC_ALPHA)
#   define isALPHANUMERIC_A(c) _generic_isCC_A(c, _CC_ALPHANUMERIC)
#   define isBLANK_A(c)  _generic_isCC_A(c, _CC_BLANK)
#   define isCNTRL_A(c)  _generic_isCC_A(c, _CC_CNTRL)
#   define isDIGIT_A(c)  _generic_isCC(c, _CC_DIGIT)
#   define isGRAPH_A(c)  _generic_isCC_A(c, _CC_GRAPH)
#   define isLOWER_A(c)  _generic_isCC_A(c, _CC_LOWER)
#   define isPRINT_A(c)  _generic_isCC_A(c, _CC_PRINT)
#   define isPSXSPC_A(c) _generic_isCC_A(c, _CC_PSXSPC)
#   define isPUNCT_A(c)  _generic_isCC_A(c, _CC_PUNCT)
#   define isSPACE_A(c)  _generic_isCC_A(c, _CC_SPACE)
#   define isUPPER_A(c)  _generic_isCC_A(c, _CC_UPPER)
#   define isWORDCHAR_A(c) _generic_isCC_A(c, _CC_WORDCHAR)
#   define isXDIGIT_A(c)  _generic_isCC(c, _CC_XDIGIT)
#   define isIDFIRST_A(c) _generic_isCC_A(c, ( _CC_IDFIRST))

d664 2
a665 7
#   define _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(c) ((! cBOOL(FITS_IN_8_BITS(c))) || (PL_charclass[(U8) NATIVE_TO_UNI(c)] & _CC_mask(_CC_NONLATIN1_FOLD)))

#   define _isQUOTEMETA(c) _generic_isCC(c, _CC_QUOTEMETA)
#   define _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c) \
                                            _generic_isCC(c, _CC_NON_FINAL_FOLD)
#   define _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c) \
                                            _generic_isCC(c, _CC_IS_IN_SOME_FOLD)
d667 1
d669 1
a670 1
#       define isALPHANUMERIC_A(c) (isASCII(c) && isALPHANUMERIC(c))
d685 1
a686 1
#       define isALPHANUMERIC_A(c) (isALPHA_A(c) || isDIGIT_A(c))
d688 1
a688 1
#       define isCNTRL_A(c) (FITS_IN_8_BITS(c) && ((U8) (c) < ' ' || (c) == 127))
d695 2
a696 9
#       define isPUNCT_A(c)  (((c) >= 33 && (c) <= 47)              \
                              || ((c) >= 58 && (c) <= 64)           \
                              || ((c) >= 91 && (c) <= 96)           \
                              || ((c) >= 123 && (c) <= 126))
#       define isSPACE_A(c)  ((c) == ' '                            \
                              || (c) == '\t'                        \
                              || (c) == '\n'                        \
                              || (c) =='\r'                         \
                              || (c) == '\f')
d699 1
a699 3
#       define isXDIGIT_A(c)   (isDIGIT_A(c)                        \
                                || ((c) >= 'a' && (c) <= 'f')       \
                                || ((c) <= 'F' && (c) >= 'A'))
d705 3
a707 4
#   define isALPHA_L1(c)  _generic_isCC(c, _CC_ALPHA)
#   define isALPHANUMERIC_L1(c) _generic_isCC(c, _CC_ALPHANUMERIC)
#   define isBLANK_L1(c)  _generic_isCC(c, _CC_BLANK)

d709 11
a719 12
#   define isCHARNAME_CONT(c) _generic_isCC(c, _CC_CHARNAME_CONT)

#   define isCNTRL_L1(c)  _generic_isCC(c, _CC_CNTRL)
#   define isGRAPH_L1(c)  _generic_isCC(c, _CC_GRAPH)
#   define isLOWER_L1(c)  _generic_isCC(c, _CC_LOWER)
#   define isPRINT_L1(c)  _generic_isCC(c, _CC_PRINT)
#   define isPSXSPC_L1(c) _generic_isCC(c, _CC_PSXSPC)
#   define isPUNCT_L1(c)  _generic_isCC(c, _CC_PUNCT)
#   define isSPACE_L1(c)  _generic_isCC(c, _CC_SPACE)
#   define isUPPER_L1(c)  _generic_isCC(c, _CC_UPPER)
#   define isWORDCHAR_L1(c) _generic_isCC(c, _CC_WORDCHAR)
#   define isIDFIRST_L1(c) _generic_isCC(c, _CC_IDFIRST)
d726 1
a726 1
             && NATIVE_TO_UNI((U8) c) != 0xD7 && NATIVE_TO_UNI((U8) c) != 0xF7) \
d730 1
a730 7
#   define isCHARNAME_CONT(c) (isWORDCHAR_L1(c)                         \
                               || (c) == ' '                            \
                               || (c) == '-'                            \
                               || (c) == '('                            \
                               || (c) == ')'                            \
                               || (c) == ':'                            \
                               || NATIVE_TO_UNI((U8) c) == 0xA0)
d733 10
d750 1
a751 1
#   define isALPHANUMERIC(c)	isalnum(c)
d761 1
a761 2
#   define isSPACE(c)   (isPSXSPC(c) /* && (c) != '\v' (Experimentally making
                                        these macros identical) */)
d768 1
a768 1
#   define isALPHANUMERIC(c)  isALPHANUMERIC_A(c)
d810 4
a813 1
#  define isALPHANUMERIC_LC(c)	NXIsAlNum((unsigned int)(c))
d817 5
a822 1
#  define isDIGIT_LC(c)		NXIsDigit((unsigned int)(c))
a823 2
#  define isIDFIRST_LC(c) (NXIsAlpha((unsigned int)(c)) || (char)(c) == '_')
#  define isLOWER_LC(c)		NXIsLower((unsigned int)(c))
d826 1
a826 4
#  define isSPACE_LC(c)		NXIsSpace((unsigned int)(c))
#  define isUPPER_LC(c)		NXIsUpper((unsigned int)(c))
#  define isWORDCHAR_LC(c) (NXIsAlNum((unsigned int)(c)) || (char)(c) == '_')
#  define isXDIGIT_LC(c)        NXIsXDigit((unsigned int)(c))
a827 1
#  define toUPPER_LC(c)		NXToUpper((unsigned int)(c))
d833 7
a839 5
/* Use foo_LC_uvchr() instead  of these for beyond the Latin1 range */

#    define isALPHA_LC(c)   (FITS_IN_8_BITS(c) && isalpha((unsigned char)(c)))
#    define isALPHANUMERIC_LC(c)   (FITS_IN_8_BITS(c)                          \
                                               && isalnum((unsigned char)(c)))
d841 1
a841 1
#	define isASCII_LC(c) (FITS_IN_8_BITS(c) && isascii((unsigned char)(c)))
d843 1
a843 1
#	define isASCII_LC(c) (FITS_IN_8_BITS(c) && isASCII((unsigned char)(c)))
d846 1
a846 1
#	define isBLANK_LC(c) (FITS_IN_8_BITS(c) && isblank((unsigned char)(c)))
d848 1
a848 1
#	define isBLANK_LC(c) (FITS_IN_8_BITS(c) && isBLANK((unsigned char)(c)))
d850 11
a860 15
#    define isCNTRL_LC(c)    (FITS_IN_8_BITS(c) && iscntrl((unsigned char)(c)))
#    define isDIGIT_LC(c)    (FITS_IN_8_BITS(c) && isdigit((unsigned char)(c)))
#    define isGRAPH_LC(c)    (FITS_IN_8_BITS(c) && isgraph((unsigned char)(c)))
#    define isIDFIRST_LC(c) (FITS_IN_8_BITS(c)                                 \
                            && (isalpha((unsigned char)(c)) || (char)(c) == '_'))
#    define isLOWER_LC(c)    (FITS_IN_8_BITS(c) && islower((unsigned char)(c)))
#    define isPRINT_LC(c)    (FITS_IN_8_BITS(c) && isprint((unsigned char)(c)))
#    define isPUNCT_LC(c)    (FITS_IN_8_BITS(c) && ispunct((unsigned char)(c)))
#    define isSPACE_LC(c)    (FITS_IN_8_BITS(c) && isspace((unsigned char)(c)))
#    define isUPPER_LC(c)    (FITS_IN_8_BITS(c) && isupper((unsigned char)(c)))
#    define isWORDCHAR_LC(c) (FITS_IN_8_BITS(c)                                \
                            && (isalnum((unsigned char)(c)) || (char)(c) == '_'))
#    define isXDIGIT_LC(c)   (FITS_IN_8_BITS(c) && isxdigit((unsigned char)(c)))
#    define toLOWER_LC(c) (FITS_IN_8_BITS(c) ? tolower((unsigned char)(c)) : (c))
#    define toUPPER_LC(c) (FITS_IN_8_BITS(c) ? toupper((unsigned char)(c)) : (c))
d864 2
a866 1
#    define isALPHANUMERIC_LC(c) (isascii(c) && isalnum(c))
d871 1
a871 1
#	define isBLANK_LC(c)	isBLANK_A(c)
d873 5
a878 1
#    define isDIGIT_LC(c)	(isascii(c) && isdigit(c))
a879 2
#    define isIDFIRST_LC(c)	(isascii(c) && (isalpha(c) || (c) == '_'))
#    define isLOWER_LC(c)	(isascii(c) && islower(c))
d882 2
a883 6
#    define isSPACE_LC(c)	(isascii(c) && isspace(c))
#    define isUPPER_LC(c)	(isascii(c) && isupper(c))
#    define isWORDCHAR_LC(c)	(isascii(c) && (isalnum(c) || (c) == '_'))
#    define isXDIGIT_LC(c)      (isascii(c) && isxdigit(c))
#    define toLOWER_LC(c)	(isascii(c) ? tolower(c) : (c))
#    define toUPPER_LC(c)	(isascii(c) ? toupper(c) : (c))
d888 1
a888 11
#define isIDCONT(c)             isWORDCHAR(c)
#define isIDCONT_A(c)           isWORDCHAR_A(c)
#define isIDCONT_L1(c)	        isWORDCHAR_L1(c)
#define isIDCONT_LC(c)	        isWORDCHAR_LC(c)
#define isPSXSPC_LC(c)		isSPACE_LC(c)

/* For internal core Perl use only.  If the input is Latin1, use the Latin1
 * macro; otherwise use the function 'above_latin1'.  Won't compile if 'c' isn't unsigned, as
 * won't match above_latin1 prototype. The macros do bounds checking, so have
 * duplicate checks here, so could create versions of the macros that don't,
 * but experiments show that gcc optimizes them out anyway. */
d890 9
a899 27
#define _generic_uni(classnum, above_latin1, c) ((c) < 256                    \
                                             ? _generic_isCC(c, classnum)     \
                                             : above_latin1(c))
#define _generic_swash_uni(classnum, c) ((c) < 256                            \
                                             ? _generic_isCC(c, classnum)     \
                                             : _is_uni_FOO(classnum, c))
#define isALPHA_uni(c)      _generic_swash_uni(_CC_ALPHA, c)
#define isALPHANUMERIC_uni(c) _generic_swash_uni(_CC_ALPHANUMERIC, c)
#define isASCII_uni(c)      isASCII(c)
#define isBLANK_uni(c)      _generic_uni(_CC_BLANK, is_HORIZWS_cp_high, c)
#define isCNTRL_uni(c)      isCNTRL_L1(c) /* All controls are in Latin1 */
#define isDIGIT_uni(c)      _generic_swash_uni(_CC_DIGIT, c)
#define isGRAPH_uni(c)      _generic_swash_uni(_CC_GRAPH, c)
#define isIDCONT_uni(c)     _generic_uni(_CC_WORDCHAR, _is_uni_perl_idcont, c)
#define isIDFIRST_uni(c)    _generic_uni(_CC_IDFIRST, _is_uni_perl_idstart, c)
#define isLOWER_uni(c)      _generic_swash_uni(_CC_LOWER, c)
#define isPRINT_uni(c)      _generic_swash_uni(_CC_PRINT, c)

/* Posix and regular space are identical above Latin1 */
#define isPSXSPC_uni(c)     _generic_uni(_CC_PSXSPC, is_XPERLSPACE_cp_high, c)

#define isPUNCT_uni(c)      _generic_swash_uni(_CC_PUNCT, c)
#define isSPACE_uni(c)      _generic_uni(_CC_SPACE, is_XPERLSPACE_cp_high, c)
#define isUPPER_uni(c)      _generic_swash_uni(_CC_UPPER, c)
#define isVERTWS_uni(c)     _generic_uni(_CC_VERTSPACE, is_VERTWS_cp_high, c)
#define isWORDCHAR_uni(c)   _generic_swash_uni(_CC_WORDCHAR, c)
#define isXDIGIT_uni(c)     _generic_uni(_CC_XDIGIT, is_XDIGIT_cp_high, c)
d901 17
a918 3
#define toLOWER_uni(c,s,l)	to_uni_lower(c,s,l)
#define toTITLE_uni(c,s,l)	to_uni_title(c,s,l)
#define toUPPER_uni(c,s,l)	to_uni_upper(c,s,l)
d920 33
a952 40
#define _generic_LC_uvchr(latin1, above_latin1, c)                            \
                                    (c < 256 ? latin1(c) : above_latin1(c))
#define _generic_LC_swash_uvchr(latin1, classnum, c)                          \
                            (c < 256 ? latin1(c) : _is_uni_FOO(classnum, c))

#define isALPHA_LC_uvchr(c)  _generic_LC_swash_uvchr(isALPHA_LC, _CC_ALPHA, c)
#define isALPHANUMERIC_LC_uvchr(c)  _generic_LC_swash_uvchr(isALPHANUMERIC_LC, \
                                                         _CC_ALPHANUMERIC, c)
#define isASCII_LC_uvchr(c)  isASCII_LC(c)
#define isBLANK_LC_uvchr(c)  _generic_LC_uvchr(isBLANK_LC, is_HORIZWS_cp_high, c)
#define isCNTRL_LC_uvchr(c)  (c < 256 ? isCNTRL_LC(c) : 0)
#define isDIGIT_LC_uvchr(c)  _generic_LC_swash_uvchr(isDIGIT_LC, _CC_DIGIT, c)
#define isGRAPH_LC_uvchr(c)  _generic_LC_swash_uvchr(isGRAPH_LC, _CC_GRAPH, c)
#define isIDCONT_LC_uvchr(c)  _generic_LC_uvchr(isIDCONT_LC,                  \
                                                  _is_uni_perl_idcont, c)
#define isIDFIRST_LC_uvchr(c)  _generic_LC_uvchr(isIDFIRST_LC,                 \
                                                  _is_uni_perl_idstart, c)
#define isLOWER_LC_uvchr(c)  _generic_LC_swash_uvchr(isLOWER_LC, _CC_LOWER, c)
#define isPRINT_LC_uvchr(c)  _generic_LC_swash_uvchr(isPRINT_LC, _CC_PRINT, c)
#define isPSXSPC_LC_uvchr(c) isSPACE_LC_uvchr(c) /* space is identical to posix
                                                    space under locale */
#define isPUNCT_LC_uvchr(c)  _generic_LC_swash_uvchr(isPUNCT_LC, _CC_PUNCT, c)
#define isSPACE_LC_uvchr(c)  _generic_LC_uvchr(isSPACE_LC,                     \
                                                    is_XPERLSPACE_cp_high, c)
#define isUPPER_LC_uvchr(c)  _generic_LC_swash_uvchr(isUPPER_LC, _CC_UPPER, c)
#define isWORDCHAR_LC_uvchr(c)  _generic_LC_swash_uvchr(isWORDCHAR_LC,              \
                                                           _CC_WORDCHAR, c)
#define isXDIGIT_LC_uvchr(c) _generic_LC_uvchr(isXDIGIT_LC, is_XDIGIT_cp_high, c)


#define isBLANK_LC_uni(c)	isBLANK_LC_uvchr(UNI_TO_NATIVE(c))

/* Everything whose name begins with an underscore is for internal core Perl
 * use only. */

/* If the input is in the Latin1 range, use
 * the Latin1 macro 'classnum' on 'p' which is a pointer to a UTF-8 string.
 * Otherwise use the value given by the 'utf8' parameter.  This relies on the
 * fact that ASCII characters have the same representation whether utf8 or not.
 * Note that it assumes that the utf8 has been validated, and ignores 'use
a953 47
#define _generic_utf8(classnum, p, utf8) (UTF8_IS_INVARIANT(*(p))              \
                                         ? _generic_isCC(*(p), classnum)       \
                                         : (UTF8_IS_DOWNGRADEABLE_START(*(p))) \
                                           ? _generic_isCC(                    \
                                                   TWO_BYTE_UTF8_TO_UNI(*(p),  \
                                                                   *((p)+1 )), \
                                                   classnum)                   \
                                           : utf8)
/* Like the above, but calls 'above_latin1(p)' to get the utf8 value.  'above_latin1'
 * can be a macro */
#define _generic_func_utf8(classnum, above_latin1, p)  \
                                    _generic_utf8(classnum, p, above_latin1(p))
/* Like the above, but passes classnum to _isFOO_utf8(), instead of having a
 * 'above_latin1' parameter */
#define _generic_swash_utf8(classnum, p)  \
                      _generic_utf8(classnum, p, _is_utf8_FOO(classnum, p))

/* Like the above, but should be used only when it is known that there are no
 * characters in the range 128-255 which the class is TRUE for.  Hence it can
 * skip the tests for this range.  'above_latin1' should include its arguments */
#define _generic_utf8_no_upper_latin1(classnum, p, above_latin1)                   \
                                         (UTF8_IS_INVARIANT(*(p))              \
                                         ? _generic_isCC(*(p), classnum)       \
                                         : (UTF8_IS_ABOVE_LATIN1(*(p)))        \
                                           ? above_latin1                          \
                                           : 0)

/* NOTE that some of these macros have very similar ones in regcharclass.h.
 * For example, there is (at the time of this writing) an 'is_SPACE_utf8()'
 * there, differing in name only by an underscore from the one here
 * 'isSPACE_utf8().  The difference is that the ones here are probably more
 * efficient and smaller, using an O(1) array lookup for Latin1-range code
 * points; the regcharclass.h ones are implemented as a series of
 * "if-else-if-else ..." */

#define isALPHA_utf8(p)         _generic_swash_utf8(_CC_ALPHA, p)
#define isALPHANUMERIC_utf8(p)  _generic_swash_utf8(_CC_ALPHANUMERIC, p)
#define isASCII_utf8(p)         isASCII(*p) /* Because ASCII is invariant under
                                               utf8, the non-utf8 macro works
                                             */
#define isBLANK_utf8(p)         _generic_func_utf8(_CC_BLANK, is_HORIZWS_high, p)
#define isCNTRL_utf8(p)         _generic_utf8(_CC_CNTRL, p, 0)
#define isDIGIT_utf8(p)         _generic_utf8_no_upper_latin1(_CC_DIGIT, p,   \
                                                  _is_utf8_FOO(_CC_DIGIT, p))
#define isGRAPH_utf8(p)         _generic_swash_utf8(_CC_GRAPH, p)
#define isIDCONT_utf8(p)        _generic_func_utf8(_CC_WORDCHAR,              \
                                                  _is_utf8_perl_idcont, p)
d955 1
d959 25
a983 20
 * ever wanted to know about.  (In the ASCII range, there isn't a difference.)
 * This used to be not the XID version, but we decided to go with the more
 * modern Unicode definition */
#define isIDFIRST_utf8(p)       _generic_func_utf8(_CC_IDFIRST,               \
                                                _is_utf8_perl_idstart, p)

#define isLOWER_utf8(p)         _generic_swash_utf8(_CC_LOWER, p)
#define isPRINT_utf8(p)         _generic_swash_utf8(_CC_PRINT, p)

/* Posix and regular space are identical above Latin1 */
#define isPSXSPC_utf8(p)        _generic_func_utf8(_CC_PSXSPC, is_XPERLSPACE_high, p)

#define isPUNCT_utf8(p)         _generic_swash_utf8(_CC_PUNCT, p)
#define isSPACE_utf8(p)         _generic_func_utf8(_CC_SPACE, is_XPERLSPACE_high, p)
#define isUPPER_utf8(p)         _generic_swash_utf8(_CC_UPPER, p)
#define isVERTWS_utf8(p)        _generic_func_utf8(_CC_VERTSPACE, is_VERTWS_high, p)
#define isWORDCHAR_utf8(p)      _generic_swash_utf8(_CC_WORDCHAR, p)
#define isXDIGIT_utf8(p)        _generic_utf8_no_upper_latin1(_CC_XDIGIT, p,   \
                                                          is_XDIGIT_high(p))

a984 2
#define toTITLE_utf8(p,s,l)	to_utf8_title(p,s,l)
#define toUPPER_utf8(p,s,l)	to_utf8_upper(p,s,l)
d986 22
a1007 37
/* For internal core Perl use only.  If the input is in the Latin1 range, use
 * the macro 'macro' on 'p' which is a pointer to a UTF-8 string.  Otherwise
 * use the value given by the 'utf8' parameter.  This relies on the fact that
 * ASCII characters have the same representation whether utf8 or not.  Note
 * that it assumes that the utf8 has been validated, and ignores 'use bytes' */
#define _generic_LC_utf8(macro, p, utf8)                                   \
                         (UTF8_IS_INVARIANT(*(p))                          \
                         ? macro(*(p))                                     \
                         : (UTF8_IS_DOWNGRADEABLE_START(*(p)))             \
                           ? macro(TWO_BYTE_UTF8_TO_UNI(*(p), *((p)+1)))   \
                           : utf8)

#define _generic_LC_swash_utf8(macro, classnum, p)                         \
                    _generic_LC_utf8(macro, p, _is_utf8_FOO(classnum, p))
#define _generic_LC_func_utf8(macro, above_latin1, p)                         \
                    _generic_LC_utf8(macro, p, above_latin1(p))

#define isALPHANUMERIC_LC_utf8(p)  _generic_LC_swash_utf8(isALPHANUMERIC_LC,  \
                                                      _CC_ALPHANUMERIC, p)
#define isALPHA_LC_utf8(p)   _generic_LC_swash_utf8(isALPHA_LC, _CC_ALPHA, p)
#define isASCII_LC_utf8(p)   isASCII_LC(*p)
#define isBLANK_LC_utf8(p)   _generic_LC_func_utf8(isBLANK_LC, is_HORIZWS_high, p)
#define isCNTRL_LC_utf8(p)   _generic_LC_utf8(isCNTRL_LC, p, 0)
#define isDIGIT_LC_utf8(p)   _generic_LC_swash_utf8(isDIGIT_LC, _CC_DIGIT, p)
#define isGRAPH_LC_utf8(p)   _generic_LC_swash_utf8(isGRAPH_LC, _CC_GRAPH, p)
#define isIDCONT_LC_utf8(p) _generic_LC_func_utf8(isIDCONT_LC, _is_utf8_perl_idcont, p)
#define isIDFIRST_LC_utf8(p) _generic_LC_func_utf8(isIDFIRST_LC, _is_utf8_perl_idstart, p)
#define isLOWER_LC_utf8(p)   _generic_LC_swash_utf8(isLOWER_LC, _CC_LOWER, p)
#define isPRINT_LC_utf8(p)   _generic_LC_swash_utf8(isPRINT_LC, _CC_PRINT, p)
#define isPSXSPC_LC_utf8(p)  isSPACE_LC_utf8(p) /* space is identical to posix
                                                   space under locale */
#define isPUNCT_LC_utf8(p)   _generic_LC_swash_utf8(isPUNCT_LC, _CC_PUNCT, p)
#define isSPACE_LC_utf8(p)   _generic_LC_func_utf8(isSPACE_LC, is_XPERLSPACE_high, p)
#define isUPPER_LC_utf8(p)   _generic_LC_swash_utf8(isUPPER_LC, _CC_UPPER, p)
#define isWORDCHAR_LC_utf8(p) _generic_LC_swash_utf8(isWORDCHAR_LC,           \
                                                            _CC_WORDCHAR, p)
#define isXDIGIT_LC_utf8(p)  _generic_LC_func_utf8(isXDIGIT_LC, is_XDIGIT_high, p)
d1009 2
a1010 22
/* Macros for backwards compatibility and for completeness when the ASCII and
 * Latin1 values are identical */
#define isALPHAU(c)     isALPHA_L1(c)
#define isDIGIT_L1(c)   isDIGIT_A(c)
#define isOCTAL(c)      isOCTAL_A(c)
#define isOCTAL_L1(c)   isOCTAL_A(c)
#define isXDIGIT_L1(c)  isXDIGIT_A(c)
#define isALNUM(c)      isWORDCHAR(c)
#define isALNUMU(c)     isWORDCHAR_L1(c)
#define isALNUM_LC(c)   isWORDCHAR_LC(c)
#define isALNUM_uni(c)  isWORDCHAR_uni(c)
#define isALNUM_LC_uvchr(c) isWORDCHAR_LC_uvchr(c)
#define isALNUM_utf8(p) isWORDCHAR_utf8(p)
#define isALNUM_LC_utf8(p) isWORDCHAR_LC_utf8(p)
#define isALNUMC_A(c)   isALPHANUMERIC_A(c)      /* Mnemonic: "C's alnum" */
#define isALNUMC_L1(c)  isALPHANUMERIC_L1(c)
#define isALNUMC(c)	isALPHANUMERIC(c)
#define isALNUMC_LC(c)	isALPHANUMERIC_LC(c)
#define isALNUMC_uni(c) isALPHANUMERIC_uni(c)
#define isALNUMC_LC_uvchr(c) isALPHANUMERIC_LC_uvchr(c)
#define isALNUMC_utf8(p) isALPHANUMERIC_utf8(p)
#define isALNUMC_LC_utf8(p) isALPHANUMERIC_LC_utf8(p)
d1013 1
a1013 3
 * CTRL-@@ is 0, CTRL-A is 1, etc, just like on ASCII, except that they don't
 * necessarily mean the same characters, e.g. CTRL-D is 4 on both systems, but
 * that is EOT on ASCII;  ST on EBCDIC */
d1018 1
a1018 1
#define NOLINE ((line_t) 4294967295UL)  /* = FFFFFFFF */
a1032 2
#define READ_XDIGIT(s) (isALPHA(*(s)) ? ((*(s)++ + 9) & 0xf) : (*(s)++ & 0xf))

d1065 2
a1066 2
source, C<dest> is the destination, C<nitems> is the number of items, and
C<type> is the type.  Can do overlapping moves.  See also C<Copy>.
d1074 2
a1075 2
source, C<dest> is the destination, C<nitems> is the number of items, and
C<type> is the type.  May fail on overlapping copies.  See also C<Move>.
d1092 1
a1092 1
=for apidoc Am|void|StructCopy|type *src|type *dest|type
d1125 1
a1125 2
#define MEM_WRAP_CHECK(n,t) \
	(void)(sizeof(t) > 1 && ((MEM_SIZE)(n)+0.0) > MEM_SIZE_MAX/sizeof(t) && (Perl_croak_memory_wrap(),0))
d1130 2
a1131 1
#define PERL_STRLEN_ROUNDUP(n) ((void)(((n) > MEM_SIZE_MAX - 2 * PERL_STRLEN_ROUNDUP_QUANTUM) ?  (Perl_croak_memory_wrap(),0):0),((n-1+PERL_STRLEN_ROUNDUP_QUANTUM)&~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM-1)))
a1301 2
#endif  /* HANDY_H */

d1306 1
a1306 1
 * indent-tabs-mode: nil
d1309 1
a1309 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@a10 3
/* IMPORTANT NOTE: Everything whose name begins with an underscore is for
 * internal core Perl use only. */

d28 1
a28 2
Null character pointer.  (No longer available when C<PERL_CORE> is
defined.)
d31 1
a31 1
Null SV pointer.  (No longer available when C<PERL_CORE> is defined.)
d72 1
a72 1
#if defined(I_STDBOOL) && !defined(PERL_BOOL_AS_CHAR)
a87 1
# ifndef PERL_BOOL_AS_CHAR
a90 1
# endif
d107 4
a110 2
# ifdef bool
#  undef bool
a111 1
# define bool char
d115 5
a119 4
/* cast-to-bool.  A simple (bool) cast may not do the right thing: if bool is
 * defined as char for example, then the cast from int is
 * implementation-defined (bool)!!(cbool) in a ternary triggers a bug in xlc on
 * AIX */
d129 1
a129 1
#  if (defined(USING_MSVC6)) || /* MSVC6 has neither __func__ nor __FUNCTION and no good workarounds, either. */ \
a271 10
/* This is a helper macro to avoid preprocessor issues, replaced by nothing
 * unless under DEBUGGING, where it expands to an assert of its argument,
 * followed by a comma (hence the comma operator).  If we just used a straight
 * assert(), we would get a comma with nothing before it when not DEBUGGING */
#ifdef DEBUGGING
#   define __ASSERT_(statement)  assert(statement),
#else
#   define __ASSERT_(statement)
#endif

d276 1
a276 2
Like C<newSVpvn>, but takes a literal C<NUL>-terminated string instead of a
string/length pair.
d279 2
a280 2
Like C<newSVpvn_flags>, but takes a literal C<NUL>-terminated string instead of
a string/length pair.
d283 2
a284 2
Like C<newSVpvn_share>, but takes a literal C<NUL>-terminated string instead of
a string/length pair and omits the hash parameter.
d287 2
a288 2
Like C<sv_catpvn_flags>, but takes a literal C<NUL>-terminated string instead
of a string/length pair.
d315 1
a315 2
Like C<savepvn>, but takes a literal C<NUL>-terminated string instead of a
string/length pair.
d423 1
a423 1
indicates the number of bytes to compare.  Returns true or false.  (A
d428 1
a428 1
the number of bytes to compare.  Returns true or false.  (A wrapper for
d499 1
a499 1
ASCII and EBCDIC (though it represents different characters in each).
d512 6
a517 7
Variant C<isFOO_LC> is like the C<isFOO_A> and C<isFOO_L1> variants, but the
result is based on the current locale, which is what C<LC> in the name stands
for.  If Perl can determine that the current locale is a UTF-8 locale, it uses
the published Unicode rules; otherwise, it uses the C library function that
gives the named classification.  For example, C<isDIGIT_LC()> when not in a
UTF-8 locale returns the result of calling C<isdigit()>.  FALSE is always
returned if the input won't fit into an octet.
a554 6
Also note, that because all ASCII characters are UTF-8 invariant (meaning they
have the exact same representation (always a single byte) whether encoded in
UTF-8 or not), C<isASCII> will give the correct results when called with any
byte in any string encoded or not in UTF-8.  And similarly C<isASCII_utf8> will
work properly on any string encoded or not in UTF-8.

d616 1
a616 1
("Experimentally" means that this change may be backed out in 5.22 if
d630 1
a630 1
may be backed out in 5.22 if field experience indicates that it
d704 7
a710 114
=for apidoc Am|U8|toUPPER|U8 ch
Converts the specified character to uppercase.  If the input is anything but an
ASCII lowercase character, that input character itself is returned.  Variant
C<toUPPER_A> is equivalent.

=for apidoc Am|UV|toUPPER_uni|UV cp|U8* s|STRLEN* lenp
Converts the Unicode code point C<cp> to its uppercase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the uppercase version may be longer than the original character.

The first code point of the uppercased version is returned
(but note, as explained just above, that there may be more.)

=for apidoc Am|UV|toUPPER_utf8|U8* p|U8* s|STRLEN* lenp
Converts the UTF-8 encoded character at C<p> to its uppercase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the uppercase version may be longer than the original character.

The first code point of the uppercased version is returned
(but note, as explained just above, that there may be more.)

The input character at C<p> is assumed to be well-formed.

=for apidoc Am|U8|toFOLD|U8 ch
Converts the specified character to foldcase.  If the input is anything but an
ASCII uppercase character, that input character itself is returned.  Variant
C<toFOLD_A> is equivalent.  (There is no equivalent C<to_FOLD_L1> for the full
Latin1 range, as the full generality of L</toFOLD_uni> is needed there.)

=for apidoc Am|UV|toFOLD_uni|UV cp|U8* s|STRLEN* lenp
Converts the Unicode code point C<cp> to its foldcase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the foldcase version may be longer than the original character.

The first code point of the foldcased version is returned
(but note, as explained just above, that there may be more.)

=for apidoc Am|UV|toFOLD_utf8|U8* p|U8* s|STRLEN* lenp
Converts the UTF-8 encoded character at C<p> to its foldcase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the foldcase version may be longer than the original character.

The first code point of the foldcased version is returned
(but note, as explained just above, that there may be more.)

The input character at C<p> is assumed to be well-formed.

=for apidoc Am|U8|toLOWER|U8 ch
Converts the specified character to lowercase.  If the input is anything but an
ASCII uppercase character, that input character itself is returned.  Variant
C<toLOWER_A> is equivalent.

=for apidoc Am|U8|toLOWER_L1|U8 ch
Converts the specified Latin1 character to lowercase.  The results are undefined if
the input doesn't fit in a byte.

=for apidoc Am|U8|toLOWER_LC|U8 ch
Converts the specified character to lowercase using the current locale's rules,
if possible; otherwise returns the input character itself.

=for apidoc Am|UV|toLOWER_uni|UV cp|U8* s|STRLEN* lenp
Converts the Unicode code point C<cp> to its lowercase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the lowercase version may be longer than the original character.

The first code point of the lowercased version is returned
(but note, as explained just above, that there may be more.)

=for apidoc Am|UV|toLOWER_utf8|U8* p|U8* s|STRLEN* lenp
Converts the UTF-8 encoded character at C<p> to its lowercase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the lowercase version may be longer than the original character.

The first code point of the lowercased version is returned
(but note, as explained just above, that there may be more.)

The input character at C<p> is assumed to be well-formed.

=for apidoc Am|U8|toLOWER_LC|U8 ch
Converts the specified character to lowercase using the current locale's rules,
if possible; otherwise returns the input character itself.

=for apidoc Am|U8|toTITLE|U8 ch
Converts the specified character to titlecase.  If the input is anything but an
ASCII lowercase character, that input character itself is returned.  Variant
C<toTITLE_A> is equivalent.  (There is no C<toTITLE_L1> for the full Latin1 range,
as the full generality of L</toTITLE_uni> is needed there.  Titlecase is not a
concept used in locale handling, so there is no functionality for that.)

=for apidoc Am|UV|toTITLE_uni|UV cp|U8* s|STRLEN* lenp
Converts the Unicode code point C<cp> to its titlecase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the titlecase version may be longer than the original character.

The first code point of the titlecased version is returned
(but note, as explained just above, that there may be more.)

=for apidoc Am|UV|toTITLE_utf8|U8* p|U8* s|STRLEN* lenp
Converts the UTF-8 encoded character at C<p> to its titlecase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the titlecase version may be longer than the original character.

The first code point of the titlecased version is returned
(but note, as explained just above, that there may be more.)

The input character at C<p> is assumed to be well-formed.
d714 1
a714 2
XXX Still undocumented isVERTWS_uni and _utf8; it's unclear what their names
really should be.  Also toUPPER_LC and toFOLD_LC, which are subject to change.
d740 1
a740 9
#   ifndef _ALL_SOURCE
        /* This returns the wrong results on at least z/OS unless this is
         * defined. */
#       error   _ALL_SOURCE should probably be defined
#   endif

    /* We could be called without perl.h, in which case NATIVE_TO_ASCII() is
     * likely not defined, and so we use the native function */
#   define isASCII(c)    cBOOL(isascii(c))
d798 1
a798 2
 * structures in regcomp.[ch] and regexec.c.  But they should be added to
 * bootstrap_ctype() */
a874 3
#endif  /* Has perl.h */

#if defined(H_PERL) && ! defined(BOOTSTRAP_CHARSET)
a877 3

    /* For internal core Perl use only: the base macro for defining macros like
     * isALPHA */
d879 1
a879 1
                && (PL_charclass[(U8) (c)] & _CC_mask(classnum)))
d885 4
a888 5
    /* For internal core Perl use only: the base macro for defining macros like
     * isALPHA_A.  The foo_A version makes sure that both the desired bit and
     * the ASCII bit are present */
#   define _generic_isCC_A(c, classnum) (FITS_IN_8_BITS(c)  \
        && ((PL_charclass[(U8) (c)] & _CC_mask_A(classnum)) \
d905 1
a905 18
#   define isIDFIRST_A(c) _generic_isCC_A(c, _CC_IDFIRST)
#   define isALPHA_L1(c)  _generic_isCC(c, _CC_ALPHA)
#   define isALPHANUMERIC_L1(c) _generic_isCC(c, _CC_ALPHANUMERIC)
#   define isBLANK_L1(c)  _generic_isCC(c, _CC_BLANK)

    /* continuation character for legal NAME in \N{NAME} */
#   define isCHARNAME_CONT(c) _generic_isCC(c, _CC_CHARNAME_CONT)

#   define isCNTRL_L1(c)  _generic_isCC(c, _CC_CNTRL)
#   define isGRAPH_L1(c)  _generic_isCC(c, _CC_GRAPH)
#   define isLOWER_L1(c)  _generic_isCC(c, _CC_LOWER)
#   define isPRINT_L1(c)  _generic_isCC(c, _CC_PRINT)
#   define isPSXSPC_L1(c) _generic_isCC(c, _CC_PSXSPC)
#   define isPUNCT_L1(c)  _generic_isCC(c, _CC_PUNCT)
#   define isSPACE_L1(c)  _generic_isCC(c, _CC_SPACE)
#   define isUPPER_L1(c)  _generic_isCC(c, _CC_UPPER)
#   define isWORDCHAR_L1(c) _generic_isCC(c, _CC_WORDCHAR)
#   define isIDFIRST_L1(c) _generic_isCC(c, _CC_IDFIRST)
d909 1
a909 1
#   define _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(c) ((! cBOOL(FITS_IN_8_BITS(c))) || (PL_charclass[(U8) (c)] & _CC_mask(_CC_NONLATIN1_FOLD)))
d916 1
a916 11
#else   /* Either don't have perl.h or don't want to use char_class_tab.h */

    /* If we don't have perl.h, we are compiling a utility program.  Below we
     * hard-code various macro definitions that wouldn't otherwise be available
     * to it.  We can also get here if we are configured to bootstrap up Perl
     * on a non-ASCII platform that doesn't have a working Perl (currently only
     * EBCDIC).  For these we currently use the native definitions to get
     * things going.  (It should also be possible to use the translation
     * function NATIVE_TO_LATIN1(), but that is an extra layer of dependence on
     * Perl, so it is currently avoided for the macros where it's possible to
     * do so.) */
d918 16
a933 14
        /* Use the native functions.  They likely will return false for all
         * non-ASCII values, but this makes sure */
#       define isALPHA_A(c)    (isASCII(c) && isalpha(c))
#       define isALPHANUMERIC_A(c) (isASCII(c) && isalnum(c))
#       define isCNTRL_A(c)    (isASCII(c) && iscntrl(c))
#       define isDIGIT_A(c)    (isASCII(c) && isdigit(c))
#       define isGRAPH_A(c)    (isASCII(c) && isgraph(c))
#       define isLOWER_A(c)    (isASCII(c) && islower(c))
#       define isPRINT_A(c)    (isASCII(c) && isprint(c))
#       define isPUNCT_A(c)    (isASCII(c) && ispunct(c))
#       define isSPACE_A(c)    (isASCII(c) && isspace(c))
#       define isUPPER_A(c)    (isASCII(c) && isupper(c))
#       define isXDIGIT_A(c)   (isASCII(c) && isxdigit(c))
#   else   /* ASCII platform.  These are coded based on first principals */
d936 2
a937 1
#       define isCNTRL_A(c)  (isASCII(c) && (! isPRINT_A(c)))
d939 2
a940 1
#       define isGRAPH_A(c)  (isPRINT_A(c) && (c) != ' ')
d943 9
a951 6
#       define isPUNCT_A(c)  (isGRAPH_A(c) && (! isALPHANUMERIC_A(c)))
#       define isSPACE_A(c)  ((c) == ' '                                     \
                              || (c) == '\t'                                 \
                              || (c) == '\n'                                 \
                              || (c) == '\r'                                 \
                              || (c) =='\v'                                  \
d954 6
a959 119
#       define isXDIGIT_A(c) (isDIGIT_A(c)                                   \
                              || ((c) >= 'a' && (c) <= 'f')                  \
                              || ((c) <= 'F' && (c) >= 'A'))
#   endif   /* Below are common definitions for ASCII and non-ASCII */
#   define isBLANK_A(c)      ((c) == ' ' || (c) == '\t')
#   define isIDFIRST_A(c)    (isALPHA_A(c) || (c) == '_')
#   define isWORDCHAR_A(c)   (isALPHANUMERIC_A(c) || (c) == '_')

    /* The _L1 macros may be unnecessary for both the utilities and for
     * bootstrapping; I (khw) added them during debugging of bootstrapping, and
     * it seems best to keep them. */
#   define isPSXSPC_A(c)     isSPACE_A(c) /* XXX Assumes SPACE matches '\v' */
#   define isALPHA_L1(c)     (isUPPER_L1(c) || isLOWER_L1(c))
#   define isALPHANUMERIC_L1(c) (isALPHA_L1(c) || isDIGIT_A(c))
#   define isBLANK_L1(c)     (isBLANK_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && NATIVE_TO_LATIN1((U8) c) == 0xA0))
#   define isCNTRL_L1(c)     (FITS_IN_8_BITS(c) && (! isPRINT_L1(c)))
#   define isGRAPH_L1(c)     (isPRINT_L1(c) && (! isBLANK_L1(c)))
#   define isLOWER_L1(c)     (isLOWER_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && ((NATIVE_TO_LATIN1((U8) c) >= 0xDF      \
                                       && NATIVE_TO_LATIN1((U8) c) != 0xF7)  \
                                       || NATIVE_TO_LATIN1((U8) c) == 0xAA   \
                                       || NATIVE_TO_LATIN1((U8) c) == 0xBA   \
                                       || NATIVE_TO_LATIN1((U8) c) == 0xB5)))
#   define isPRINT_L1(c)     (isPRINT_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && NATIVE_TO_LATIN1((U8) c) >= 0xA0))
#   define isPSXSPC_L1(c)    isSPACE_L1(c)
#   define isPUNCT_L1(c)     (isPUNCT_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && (NATIVE_TO_LATIN1((U8) c) == 0xA1       \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xA7    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xAB    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xB6    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xB7    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xBB    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xBF)))
#   define isSPACE_L1(c)     (isSPACE_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && (NATIVE_TO_LATIN1((U8) c) == 0x85       \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xA0)))
#   define isUPPER_L1(c)     (isUPPER_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && (NATIVE_TO_LATIN1((U8) c) >= 0xC0       \
                                      && NATIVE_TO_LATIN1((U8) c) <= 0xDE    \
                                      && NATIVE_TO_LATIN1((U8) c) != 0xD7)))
#   define isWORDCHAR_L1(c)  (isIDFIRST_L1(c) || isDIGIT_A(c))
#   define isIDFIRST_L1(c)   (isALPHA_L1(c) || NATIVE_TO_LATIN1(c) == '_')
#   define isCHARNAME_CONT(c) (isWORDCHAR_L1(c)                              \
                               || isBLANK_L1(c)                              \
                               || (c) == '-'                                 \
                               || (c) == '('                                 \
                               || (c) == ')')
    /* The following are not fully accurate in the above-ASCII range.  I (khw)
     * don't think it's necessary to be so for the purposes where this gets
     * compiled */
#   define _isQUOTEMETA(c)      (FITS_IN_8_BITS(c) && ! isWORDCHAR_L1(c))
#   define _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c) isALPHA_L1(c)

    /*  And these aren't accurate at all.  They are useful only for above
     *  Latin1, which utilities and bootstrapping don't deal with */
#   define _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c) 0
#   define _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(c) 0

    /* Many of the macros later in this file are defined in terms of these.  By
     * implementing them with a function, which converts the class number into
     * a call to the desired macro, all of the later ones work.  However, that
     * function won't be actually defined when building a utility program (no
     * perl.h), and so a compiler error will be generated if one is attempted
     * to be used.  And the above-Latin1 code points require Unicode tables to
     * be present, something unlikely to be the case when bootstrapping */
#   define _generic_isCC(c, classnum)                                        \
         (FITS_IN_8_BITS(c) && S_bootstrap_ctype((U8) (c), (classnum), TRUE))
#   define _generic_isCC_A(c, classnum)                                      \
         (FITS_IN_8_BITS(c) && S_bootstrap_ctype((U8) (c), (classnum), FALSE))
#endif  /* End of no perl.h or have BOOTSTRAP_CHARSET */

#define isALPHANUMERIC(c)  isALPHANUMERIC_A(c)
#define isALPHA(c)   isALPHA_A(c)
#define isBLANK(c)   isBLANK_A(c)
#define isCNTRL(c)   isCNTRL_A(c)
#define isDIGIT(c)   isDIGIT_A(c)
#define isGRAPH(c)   isGRAPH_A(c)
#define isIDFIRST(c) isIDFIRST_A(c)
#define isLOWER(c)   isLOWER_A(c)
#define isPRINT(c)   isPRINT_A(c)
#define isPSXSPC(c)  isPSXSPC_A(c)
#define isPUNCT(c)   isPUNCT_A(c)
#define isSPACE(c)   isSPACE_A(c)
#define isUPPER(c)   isUPPER_A(c)
#define isWORDCHAR(c) isWORDCHAR_A(c)
#define isXDIGIT(c)  isXDIGIT_A(c)

/* ASCII casing.  These could also be written as
    #define toLOWER(c) (isASCII(c) ? toLOWER_LATIN1(c) : (c))
    #define toUPPER(c) (isASCII(c) ? toUPPER_LATIN1_MOD(c) : (c))
   which uses table lookup and mask instead of subtraction.  (This would
   work because the _MOD does not apply in the ASCII range) */
#define toLOWER(c)  (isUPPER(c) ? (U8)((c) + ('a' - 'A')) : (c))
#define toUPPER(c)  (isLOWER(c) ? (U8)((c) - ('a' - 'A')) : (c))

/* In the ASCII range, these are equivalent to what they're here defined to be.
 * But by creating these definitions, other code doesn't have to be aware of
 * this detail */
#define toFOLD(c)    toLOWER(c)
#define toTITLE(c)   toUPPER(c)

#define toLOWER_A(c) toLOWER(c)
#define toUPPER_A(c) toUPPER(c)
#define toFOLD_A(c)  toFOLD(c)
#define toTITLE_A(c) toTITLE(c)

/* Use table lookup for speed; returns the input itself if is out-of-range */
#define toLOWER_LATIN1(c)    ((! FITS_IN_8_BITS(c))                        \
                             ? (c)                                         \
                             : PL_latin1_lc[ (U8) (c) ])
#define toLOWER_L1(c)    toLOWER_LATIN1(c)  /* Synonym for consistency */
d961 5
a965 7
/* Modified uc.  Is correct uc except for three non-ascii chars which are
 * all mapped to one of them, and these need special handling; returns the
 * input itself if is out-of-range */
#define toUPPER_LATIN1_MOD(c) ((! FITS_IN_8_BITS(c))                       \
                               ? (c)                                       \
                               : PL_mod_latin1_uc[ (U8) (c) ])
#define IN_UTF8_CTYPE_LOCALE PL_in_utf8_CTYPE_locale
d967 2
a968 1
/* Use foo_LC_uvchr() instead  of these for beyond the Latin1 range */
d970 78
a1047 75
/* For internal core Perl use only: the base macro for defining macros like
 * isALPHA_LC, which uses the current LC_CTYPE locale.  'c' is the code point
 * (0-255) to check.  In a UTF-8 locale, the result is the same as calling
 * isFOO_L1(); the 'utf8_locale_classnum' parameter is something like
 * _CC_UPPER, which gives the class number for doing this.  For non-UTF-8
 * locales, the code to actually do the test this is passed in 'non_utf8'.  If
 * 'c' is above 255, 0 is returned.  For accessing the full range of possible
 * code points under locale rules, use the macros based on _generic_LC_uvchr
 * instead of this. */
#define _generic_LC_base(c, utf8_locale_classnum, non_utf8)                    \
           (! FITS_IN_8_BITS(c)                                                \
           ? 0                                                                 \
           : IN_UTF8_CTYPE_LOCALE                                              \
             ? cBOOL(PL_charclass[(U8) (c)] & _CC_mask(utf8_locale_classnum))  \
             : cBOOL(non_utf8))

/* For internal core Perl use only: a helper macro for defining macros like
 * isALPHA_LC.  'c' is the code point (0-255) to check.  The function name to
 * actually do this test is passed in 'non_utf8_func', which is called on 'c',
 * casting 'c' to the macro _LC_CAST, which should not be parenthesized.  See
 * _generic_LC_base for more info */
#define _generic_LC(c, utf8_locale_classnum, non_utf8_func)                    \
                        _generic_LC_base(c,utf8_locale_classnum,               \
                                         non_utf8_func( (_LC_CAST) (c)))

/* For internal core Perl use only: like _generic_LC, but also returns TRUE if
 * 'c' is the platform's native underscore character */
#define _generic_LC_underscore(c,utf8_locale_classnum,non_utf8_func)           \
                        _generic_LC_base(c, utf8_locale_classnum,              \
                                         (non_utf8_func( (_LC_CAST) (c))       \
                                          || (char)(c) == '_'))

/* These next three are also for internal core Perl use only: case-change
 * helper macros */
#define _generic_toLOWER_LC(c, function, cast)  (! FITS_IN_8_BITS(c)           \
                                                ? (c)                          \
                                                : (IN_UTF8_CTYPE_LOCALE)       \
                                                  ? PL_latin1_lc[ (U8) (c) ]   \
                                                : function((cast)(c)))

/* Note that the result can be larger than a byte in a UTF-8 locale.  It
 * returns a single value, so can't adequately return the upper case of LATIN
 * SMALL LETTER SHARP S in a UTF-8 locale (which should be a string of two
 * values "SS");  instead it asserts against that under DEBUGGING, and
 * otherwise returns its input */
#define _generic_toUPPER_LC(c, function, cast)                                 \
                    (! FITS_IN_8_BITS(c)                                       \
                    ? (c)                                                      \
                    : ((! IN_UTF8_CTYPE_LOCALE)                                \
                      ? function((cast)(c))                                    \
                      : ((((U8)(c)) == MICRO_SIGN)                             \
                        ? GREEK_CAPITAL_LETTER_MU                              \
                        : ((((U8)(c)) == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS)  \
                          ? LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS              \
                          : ((((U8)(c)) == LATIN_SMALL_LETTER_SHARP_S)         \
                            ? (__ASSERT_(0) (c))                               \
                            : PL_mod_latin1_uc[ (U8) (c) ])))))

/* Note that the result can be larger than a byte in a UTF-8 locale.  It
 * returns a single value, so can't adequately return the fold case of LATIN
 * SMALL LETTER SHARP S in a UTF-8 locale (which should be a string of two
 * values "ss"); instead it asserts against that under DEBUGGING, and
 * otherwise returns its input */
#define _generic_toFOLD_LC(c, function, cast)                                  \
                    ((UNLIKELY((c) == MICRO_SIGN) && IN_UTF8_CTYPE_LOCALE)     \
                      ? GREEK_SMALL_LETTER_MU                                  \
                      : (__ASSERT_(! IN_UTF8_CTYPE_LOCALE                      \
                                   || (c) != LATIN_SMALL_LETTER_SHARP_S)       \
                         _generic_toLOWER_LC(c, function, cast)))

/* Use the libc versions for these if available. */
#if defined(HAS_ISASCII) && ! defined(USE_NEXT_CTYPE)
#   define isASCII_LC(c) (FITS_IN_8_BITS(c) && isascii( (U8) (c)))
#else
#   define isASCII_LC(c) isASCII(c)
d1050 34
a1083 28
#if defined(HAS_ISBLANK) && ! defined(USE_NEXT_CTYPE)
#   define isBLANK_LC(c) _generic_LC(c, _CC_BLANK, isblank)
#else /* Unlike isASCII, varies if in a UTF-8 locale */
#   define isBLANK_LC(c) (IN_UTF8_CTYPE_LOCALE) ? isBLANK_L1(c) : isBLANK(c)
#endif

#ifdef USE_NEXT_CTYPE   /* NeXT computers */

#    define _LC_CAST unsigned int   /* Needed by _generic_LC.  NeXT functions
                                       use this as their input type */

#    define isALPHA_LC(c)   _generic_LC(c, _CC_ALPHA, NXIsAlpha)
#    define isALPHANUMERIC_LC(c)  _generic_LC(c, _CC_ALPHANUMERIC, NXIsAlNum)
#    define isCNTRL_LC(c)    _generic_LC(c, _CC_CNTRL, NXIsCntrl)
#    define isDIGIT_LC(c)    _generic_LC(c, _CC_DIGIT, NXIsDigit)
#    define isGRAPH_LC(c)    _generic_LC(c, _CC_GRAPH, NXIsGraph)
#    define isIDFIRST_LC(c)  _generic_LC_underscore(c, _CC_IDFIRST, NXIsAlpha)
#    define isLOWER_LC(c)    _generic_LC(c, _CC_LOWER, NXIsLower)
#    define isPRINT_LC(c)    _generic_LC(c, _CC_PRINT, NXIsPrint)
#    define isPUNCT_LC(c)    _generic_LC(c, _CC_PUNCT, NXIsPunct)
#    define isSPACE_LC(c)    _generic_LC(c, _CC_SPACE, NXIsSpace)
#    define isUPPER_LC(c)    _generic_LC(c, _CC_UPPER, NXIsUpper)
#    define isWORDCHAR_LC(c) _generic_LC_underscore(c, _CC_WORDCHAR, NXIsAlNum)
#    define isXDIGIT_LC(c)   _generic_LC(c, _CC_XDIGIT, NXIsXdigit)

#    define toLOWER_LC(c) _generic_toLOWER_LC((c), NXToLower, unsigned int)
#    define toUPPER_LC(c) _generic_toUPPER_LC((c), NXToUpper, unsigned int)
#    define toFOLD_LC(c)  _generic_toFOLD_LC((c), NXToLower, unsigned int)
d1087 1
a1087 1
#  define _LC_CAST U8
d1089 1
a1089 2
#  if defined(CTYPE256) || (!defined(isascii) && !defined(HAS_ISASCII))
    /* For most other platforms */
d1091 28
a1118 18
#    define isALPHA_LC(c)   _generic_LC(c, _CC_ALPHA, isalpha)
#    define isALPHANUMERIC_LC(c)  _generic_LC(c, _CC_ALPHANUMERIC, isalnum)
#    define isCNTRL_LC(c)    _generic_LC(c, _CC_CNTRL, iscntrl)
#    define isDIGIT_LC(c)    _generic_LC(c, _CC_DIGIT, isdigit)
#    define isGRAPH_LC(c)    _generic_LC(c, _CC_GRAPH, isgraph)
#    define isIDFIRST_LC(c)  _generic_LC_underscore(c, _CC_IDFIRST, isalpha)
#    define isLOWER_LC(c)    _generic_LC(c, _CC_LOWER, islower)
#    define isPRINT_LC(c)    _generic_LC(c, _CC_PRINT, isprint)
#    define isPUNCT_LC(c)    _generic_LC(c, _CC_PUNCT, ispunct)
#    define isSPACE_LC(c)    _generic_LC(c, _CC_SPACE, isspace)
#    define isUPPER_LC(c)    _generic_LC(c, _CC_UPPER, isupper)
#    define isWORDCHAR_LC(c) _generic_LC_underscore(c, _CC_WORDCHAR, isalnum)
#    define isXDIGIT_LC(c)   _generic_LC(c, _CC_XDIGIT, isxdigit)


#    define toLOWER_LC(c) _generic_toLOWER_LC((c), tolower, U8)
#    define toUPPER_LC(c) _generic_toUPPER_LC((c), toupper, U8)
#    define toFOLD_LC(c)  _generic_toFOLD_LC((c), tolower, U8)
d1120 1
a1120 1
#  else  /* The final fallback position */
d1124 6
a1140 1

a1142 1
#    define toFOLD_LC(c)	(isascii(c) ? tolower(c) : (c))
d1153 5
a1157 12
/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_uni.  'c' is the code point to check.  'classnum' is the POSIX class
 * number defined earlier in this file.  _generic_uni() is used for POSIX
 * classes where there is a macro or function 'above_latin1' that takes the
 * single argument 'c' and returns the desired value.  These exist for those
 * classes which have simple definitions, avoiding the overhead of a hash
 * lookup or inversion list binary search.  _generic_swash_uni() can be used
 * for classes where that overhead is faster than a direct lookup.
 * _generic_uni() won't compile if 'c' isn't unsigned, as it won't match the
 * 'above_latin1' prototype. _generic_isCC() macro does bounds checking, so
 * have duplicate checks here, so could create versions of the macros that
 * don't, but experiments show that gcc optimizes them out anyway. */
a1192 5
/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_LC_uvchr.  These are like isALPHA_LC, but the input can be any code
 * point, not just 0-255.  Like _generic_uni, there are two versions, one for
 * simple class definitions; the other for more complex.  These are like
 * _generic_uni, so see it for more info. */
d1222 1
d1225 9
a1233 7
/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_utf8.  These are like the earlier defined macros, but take an input
 * UTF-8 encoded string 'p'. If the input is in the Latin1 range, use
 * the Latin1 macro 'classnum' on 'p'.  Otherwise use the value given by the
 * 'utf8' parameter.  This relies on the fact that ASCII characters have the
 * same representation whether utf8 or not.  Note that it assumes that the utf8
 * has been validated, and ignores 'use bytes' */
d1238 1
a1238 1
                                                TWO_BYTE_UTF8_TO_NATIVE(*(p),  \
d1240 1
a1240 1
                                                classnum)                      \
d1246 1
a1246 1
/* Like the above, but passes classnum to _isFOO_utf8(), instead of having an
d1254 1
a1254 1
#define _generic_utf8_no_upper_latin1(classnum, p, above_latin1)               \
d1258 1
a1258 1
                                           ? above_latin1                      \
a1304 1
#define toFOLD_utf8(p,s,l)	to_utf8_fold(p,s,l)
d1309 10
a1318 9
/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_LC_utf8.  These are like _generic_utf8, but if the first code point
 * in 'p' is within the 0-255 range, it uses locale rules from the passed-in
 * 'macro' parameter */
#define _generic_LC_utf8(macro, p, utf8)                                    \
                         (UTF8_IS_INVARIANT(*(p))                           \
                         ? macro(*(p))                                      \
                         : (UTF8_IS_DOWNGRADEABLE_START(*(p)))              \
                           ? macro(TWO_BYTE_UTF8_TO_NATIVE(*(p), *((p)+1))) \
d1324 1
a1324 1
                              _generic_LC_utf8(macro, p, above_latin1(p))
d1370 5
a1374 17
/* On EBCDIC platforms, CTRL-@@ is 0, CTRL-A is 1, etc, just like on ASCII,
 * except that they don't necessarily mean the same characters, e.g. CTRL-D is
 * 4 on both systems, but that is EOT on ASCII;  ST on EBCDIC.
 * '?' is special-cased on EBCDIC to APC, which is the control there that is
 * the outlier from the block that contains the other controls, just like
 * toCTRL('?') on ASCII yields DEL, the control that is the outlier from the C0
 * block.  If it weren't special cased, it would yield a non-control.
 * The conversion works both ways, so CTRL('D') is 4, and CTRL(4) is D, etc. */
#ifndef EBCDIC
#  define toCTRL(c)    (toUPPER(c) ^ 64)
#else
#  define toCTRL(c)    ((c) == '?'                               \
                        ? LATIN1_TO_NATIVE(0x9F)                 \
                        : (c) == LATIN1_TO_NATIVE(0x9F)          \
                          ? '?'                                  \
                          : (NATIVE_TO_LATIN1(toUPPER(c)) ^ 64))
#endif
d1393 1
a1393 16
/* Converts a character known to represent a hexadecimal digit (0-9, A-F, or
 * a-f) to its numeric value.  READ_XDIGIT's argument is a string pointer,
 * which is advanced.  The input is validated only by an assert() in DEBUGGING
 * builds.  In both ASCII and EBCDIC the last 4 bits of the digits are 0-9; and
 * the last 4 bits of A-F and a-f are 1-6, so adding 9 yields 10-15 */
#define XDIGIT_VALUE(c) (__ASSERT_(isXDIGIT(c)) (0xf & (isDIGIT(c)        \
                                                        ? (c)             \
                                                        : ((c) + 9))))
#define READ_XDIGIT(s)  (__ASSERT_(isXDIGIT(*s)) (0xf & (isDIGIT(*(s))     \
                                                        ? (*(s)++)         \
                                                        : (*(s)++ + 9))))

/* Converts a character known to represent an octal digit (0-7) to its numeric
 * value.  The input is validated only by an assert() in DEBUGGING builds.  In
 * both ASCII and EBCDIC the last 3 bits of the octal digits range from 0-7. */
#define OCTAL_VALUE(c) (__ASSERT_(isOCTAL(c)) (7 & (c)))
a1400 2
Memory obtained by this should B<ONLY> be freed with L<"Safefree">.

a1410 2
Memory obtained by this should B<ONLY> be freed with L<"Safefree">.

a1414 2
Memory obtained by this should B<ONLY> be freed with L<"Safefree">.

a1417 2
Memory obtained by this should B<ONLY> be freed with L<"Safefree">.

a1421 2
Memory obtained by this should B<ONLY> be freed with L<"Safefree">.

a1424 2
This should B<ONLY> be used on memory obtained using L<"Newx"> and friends.

d1431 1
a1431 2
Like C<Move> but returns dest.  Useful
for encouraging compilers to tail-call
d1441 1
a1441 2
Like C<Copy> but returns dest.  Useful
for encouraging compilers to tail-call
d1451 1
a1451 2
Like C<Zero> but returns dest.  Useful
for encouraging compilers to tail-call
d1488 1
a1488 1
	(void)(UNLIKELY(sizeof(t) > 1 && ((MEM_SIZE)(n)+0.0) > MEM_SIZE_MAX/sizeof(t)) && (croak_memory_wrap(),0))
d1490 1
a1490 1
	(void)(UNLIKELY(sizeof(t) > 1 && ((MEM_SIZE)(n)+0.0) > MEM_SIZE_MAX/sizeof(t)) && (Perl_croak_nocontext("%s",(a)),0))
d1493 1
a1493 1
#define PERL_STRLEN_ROUNDUP(n) ((void)(((n) > MEM_SIZE_MAX - 2 * PERL_STRLEN_ROUNDUP_QUANTUM) ? (croak_memory_wrap(),0):0),((n-1+PERL_STRLEN_ROUNDUP_QUANTUM)&~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM-1)))
a1618 6
#ifdef PERL_POISON
#  define PERL_POISON_EXPR(x) x
#else
#  define PERL_POISON_EXPR(x)
#endif

a1624 5
/* C_ARRAY_LENGTH is the number of elements in the C array (so you
 * want your zero-based indices to be less than but not equal to).
 *
 * C_ARRAY_END is one past the last: half-open/half-closed range,
 * not last-inclusive range. */
d1626 1
a1626 1
#define C_ARRAY_END(a)		((a) + C_ARRAY_LENGTH(a))
a1661 31
#endif

/* Internal macros to deal with gids and uids */
#ifdef PERL_CORE

#  if Uid_t_size > IVSIZE
#    define sv_setuid(sv, uid)       sv_setnv((sv), (NV)(uid))
#    define SvUID(sv)                SvNV(sv)
#  else
#    if Uid_t_sign <= 0
#      define sv_setuid(sv, uid)       sv_setiv((sv), (IV)(uid))
#      define SvUID(sv)                SvIV(sv)
#    else
#      define sv_setuid(sv, uid)       sv_setuv((sv), (UV)(uid))
#      define SvUID(sv)                SvUV(sv)
#    endif
#  endif /* Uid_t_size */

#  if Gid_t_size > IVSIZE
#    define sv_setgid(sv, gid)       sv_setnv((sv), (NV)(gid))
#    define SvGID(sv)                SvNV(sv)
#  else
#    if Gid_t_sign <= 0
#      define sv_setgid(sv, gid)       sv_setiv((sv), (IV)(gid))
#      define SvGID(sv)                SvIV(sv)
#    else
#      define sv_setgid(sv, gid)       sv_setuv((sv), (UV)(gid))
#      define SvGID(sv)                SvUV(sv)
#    endif
#  endif /* Gid_t_size */

@


