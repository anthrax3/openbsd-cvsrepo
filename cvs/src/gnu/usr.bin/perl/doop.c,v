head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.2
	OPENBSD_6_2_BASE:1.18
	PERL_5_24_2:1.1.1.17
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.10
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.4
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.18
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	cxJ08BvJA9Pt2PTM;

1.17
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	QP75iYx42Uo7mMxO;

1.16
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.25.20.40.44;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.24.15.06.40;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.12.18.24.20;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.29.17.35.56;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.19.22.57;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.15.21.30.18;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.08.54;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.32.59;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.20;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.47;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.03.49;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.50.58;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.29;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.38;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.38;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.11;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.34;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.21.59;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.46;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.28;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.12.48;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.45.39;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.23;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.47.24;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.04;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.34;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.29;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.06.21;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.58.44;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.52.35;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	B31cAbBIXiCqnL97;

1.1.1.17
date	2017.08.14.13.45.25;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.18
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    doop.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 *  'So that was the job I felt I had to do when I started,' thought Sam.
 *
 *     [p.934 of _The Lord of the Rings_, VI/iii: "Mount Doom"]
 */

/* This file contains some common functions needed to carry out certain
 * ops. For example, both pp_sprintf() and pp_prtf() call the function
 * do_sprintf() found in this file.
 */

#include "EXTERN.h"
#define PERL_IN_DOOP_C
#include "perl.h"

#ifndef PERL_MICRO
#include <signal.h>
#endif

STATIC I32
S_do_trans_simple(pTHX_ SV * const sv)
{
    I32 matches = 0;
    STRLEN len;
    U8 *s = (U8*)SvPV_nomg(sv,len);
    U8 * const send = s+len;
    const short * const tbl = (short*)cPVOP->op_pv;

    PERL_ARGS_ASSERT_DO_TRANS_SIMPLE;

    if (!tbl)
	Perl_croak(aTHX_ "panic: do_trans_simple line %d",__LINE__);

    /* First, take care of non-UTF-8 input strings, because they're easy */
    if (!SvUTF8(sv)) {
	while (s < send) {
	    const I32 ch = tbl[*s];
	    if (ch >= 0) {
		matches++;
		*s = (U8)ch;
	    }
	    s++;
	}
	SvSETMAGIC(sv);
    }
    else {
	const I32 grows = PL_op->op_private & OPpTRANS_GROWS;
	U8 *d;
	U8 *dstart;

	/* Allow for expansion: $_="a".chr(400); tr/a/\xFE/, FE needs encoding */
	if (grows)
	    Newx(d, len*2+1, U8);
	else
	    d = s;
	dstart = d;
	while (s < send) {
	    STRLEN ulen;
	    I32 ch;

	    /* Need to check this, otherwise 128..255 won't match */
	    const UV c = utf8n_to_uvchr(s, send - s, &ulen, UTF8_ALLOW_DEFAULT);
	    if (c < 0x100 && (ch = tbl[c]) >= 0) {
		matches++;
		d = uvchr_to_utf8(d, ch);
		s += ulen;
	    }
	    else { /* No match -> copy */
		Move(s, d, ulen, U8);
		d += ulen;
		s += ulen;
	    }
	}
	if (grows) {
	    sv_setpvn(sv, (char*)dstart, d - dstart);
	    Safefree(dstart);
	}
	else {
	    *d = '\0';
	    SvCUR_set(sv, d - dstart);
	}
	SvUTF8_on(sv);
	SvSETMAGIC(sv);
    }
    return matches;
}

STATIC I32
S_do_trans_count(pTHX_ SV * const sv)
{
    STRLEN len;
    const U8 *s = (const U8*)SvPV_nomg_const(sv, len);
    const U8 * const send = s + len;
    I32 matches = 0;
    const short * const tbl = (short*)cPVOP->op_pv;

    PERL_ARGS_ASSERT_DO_TRANS_COUNT;

    if (!tbl)
	Perl_croak(aTHX_ "panic: do_trans_count line %d",__LINE__);

    if (!SvUTF8(sv)) {
	while (s < send) {
            if (tbl[*s++] >= 0)
                matches++;
	}
    }
    else {
	const I32 complement = PL_op->op_private & OPpTRANS_COMPLEMENT;
	while (s < send) {
	    STRLEN ulen;
	    const UV c = utf8n_to_uvchr(s, send - s, &ulen, UTF8_ALLOW_DEFAULT);
	    if (c < 0x100) {
		if (tbl[c] >= 0)
		    matches++;
	    } else if (complement)
		matches++;
	    s += ulen;
	}
    }

    return matches;
}

STATIC I32
S_do_trans_complex(pTHX_ SV * const sv)
{
    STRLEN len;
    U8 *s = (U8*)SvPV_nomg(sv, len);
    U8 * const send = s+len;
    I32 matches = 0;
    const short * const tbl = (short*)cPVOP->op_pv;

    PERL_ARGS_ASSERT_DO_TRANS_COMPLEX;

    if (!tbl)
	Perl_croak(aTHX_ "panic: do_trans_complex line %d",__LINE__);

    if (!SvUTF8(sv)) {
	U8 *d = s;
	U8 * const dstart = d;

	if (PL_op->op_private & OPpTRANS_SQUASH) {
	    const U8* p = send;
	    while (s < send) {
		const I32 ch = tbl[*s];
		if (ch >= 0) {
		    *d = (U8)ch;
		    matches++;
		    if (p != d - 1 || *p != *d)
			p = d++;
		}
		else if (ch == -1)	/* -1 is unmapped character */
		    *d++ = *s;	
		else if (ch == -2)	/* -2 is delete character */
		    matches++;
		s++;
	    }
	}
	else {
	    while (s < send) {
		const I32 ch = tbl[*s];
		if (ch >= 0) {
		    matches++;
		    *d++ = (U8)ch;
		}
		else if (ch == -1)	/* -1 is unmapped character */
		    *d++ = *s;
		else if (ch == -2)      /* -2 is delete character */
		    matches++;
		s++;
	    }
	}
	*d = '\0';
	SvCUR_set(sv, d - dstart);
    }
    else { /* is utf8 */
	const I32 complement = PL_op->op_private & OPpTRANS_COMPLEMENT;
	const I32 grows = PL_op->op_private & OPpTRANS_GROWS;
	const I32 del = PL_op->op_private & OPpTRANS_DELETE;
	U8 *d;
	U8 *dstart;
	STRLEN rlen = 0;

	if (grows)
	    Newx(d, len*2+1, U8);
	else
	    d = s;
	dstart = d;
	if (complement && !del)
	    rlen = tbl[0x100];

	if (PL_op->op_private & OPpTRANS_SQUASH) {
	    UV pch = 0xfeedface;
	    while (s < send) {
		STRLEN len;
		const UV comp = utf8n_to_uvchr(s, send - s, &len,
					       UTF8_ALLOW_DEFAULT);
		I32 ch;

		if (comp > 0xff) {
		    if (!complement) {
			Move(s, d, len, U8);
			d += len;
		    }
		    else {
			matches++;
			if (!del) {
			    ch = (rlen == 0) ? (I32)comp :
				(comp - 0x100 < rlen) ?
				tbl[comp+1] : tbl[0x100+rlen];
			    if ((UV)ch != pch) {
				d = uvchr_to_utf8(d, ch);
				pch = (UV)ch;
			    }
			    s += len;
			    continue;
			}
		    }
		}
		else if ((ch = tbl[comp]) >= 0) {
		    matches++;
		    if ((UV)ch != pch) {
		        d = uvchr_to_utf8(d, ch);
		        pch = (UV)ch;
		    }
		    s += len;
		    continue;
		}
		else if (ch == -1) {	/* -1 is unmapped character */
		    Move(s, d, len, U8);
		    d += len;
		}
		else if (ch == -2)      /* -2 is delete character */
		    matches++;
		s += len;
		pch = 0xfeedface;
	    }
	}
	else {
	    while (s < send) {
		STRLEN len;
		const UV comp = utf8n_to_uvchr(s, send - s, &len,
					       UTF8_ALLOW_DEFAULT);
		I32 ch;
		if (comp > 0xff) {
		    if (!complement) {
			Move(s, d, len, U8);
			d += len;
		    }
		    else {
			matches++;
			if (!del) {
			    if (comp - 0x100 < rlen)
				d = uvchr_to_utf8(d, tbl[comp+1]);
			    else
				d = uvchr_to_utf8(d, tbl[0x100+rlen]);
			}
		    }
		}
		else if ((ch = tbl[comp]) >= 0) {
		    d = uvchr_to_utf8(d, ch);
		    matches++;
		}
		else if (ch == -1) {	/* -1 is unmapped character */
		    Move(s, d, len, U8);
		    d += len;
		}
		else if (ch == -2)      /* -2 is delete character */
		    matches++;
		s += len;
	    }
	}
	if (grows) {
	    sv_setpvn(sv, (char*)dstart, d - dstart);
	    Safefree(dstart);
	}
	else {
	    *d = '\0';
	    SvCUR_set(sv, d - dstart);
	}
	SvUTF8_on(sv);
    }
    SvSETMAGIC(sv);
    return matches;
}

STATIC I32
S_do_trans_simple_utf8(pTHX_ SV * const sv)
{
    U8 *s;
    U8 *send;
    U8 *d;
    U8 *start;
    U8 *dstart, *dend;
    I32 matches = 0;
    const I32 grows = PL_op->op_private & OPpTRANS_GROWS;
    STRLEN len;
    SV* const  rv =
#ifdef USE_ITHREADS
		    PAD_SVl(cPADOP->op_padix);
#else
		    MUTABLE_SV(cSVOP->op_sv);
#endif
    HV* const  hv = MUTABLE_HV(SvRV(rv));
    SV* const * svp = hv_fetchs(hv, "NONE", FALSE);
    const UV none = svp ? SvUV(*svp) : 0x7fffffff;
    const UV extra = none + 1;
    UV final = 0;
    U8 hibit = 0;

    PERL_ARGS_ASSERT_DO_TRANS_SIMPLE_UTF8;

    s = (U8*)SvPV_nomg(sv, len);
    if (!SvUTF8(sv)) {
	const U8 *t = s;
	const U8 * const e = s + len;
	while (t < e) {
	    const U8 ch = *t++;
	    hibit = !NATIVE_BYTE_IS_INVARIANT(ch);
	    if (hibit) {
		s = bytes_to_utf8(s, &len);
		break;
	    }
	}
    }
    send = s + len;
    start = s;

    svp = hv_fetchs(hv, "FINAL", FALSE);
    if (svp)
	final = SvUV(*svp);

    if (grows) {
	/* d needs to be bigger than s, in case e.g. upgrading is required */
	Newx(d, len * 3 + UTF8_MAXBYTES, U8);
	dend = d + len * 3;
	dstart = d;
    }
    else {
	dstart = d = s;
	dend = d + len;
    }

    while (s < send) {
	const UV uv = swash_fetch(rv, s, TRUE);
	if (uv < none) {
	    s += UTF8SKIP(s);
	    matches++;
	    d = uvchr_to_utf8(d, uv);
	}
	else if (uv == none) {
	    const int i = UTF8SKIP(s);
	    Move(s, d, i, U8);
	    d += i;
	    s += i;
	}
	else if (uv == extra) {
	    s += UTF8SKIP(s);
	    matches++;
	    d = uvchr_to_utf8(d, final);
	}
	else
	    s += UTF8SKIP(s);

	if (d > dend) {
	    const STRLEN clen = d - dstart;
	    const STRLEN nlen = dend - dstart + len + UTF8_MAXBYTES;
	    if (!grows)
		Perl_croak(aTHX_ "panic: do_trans_simple_utf8 line %d",__LINE__);
	    Renew(dstart, nlen + UTF8_MAXBYTES, U8);
	    d = dstart + clen;
	    dend = dstart + nlen;
	}
    }
    if (grows || hibit) {
	sv_setpvn(sv, (char*)dstart, d - dstart);
	Safefree(dstart);
	if (grows && hibit)
	    Safefree(start);
    }
    else {
	*d = '\0';
	SvCUR_set(sv, d - dstart);
    }
    SvSETMAGIC(sv);
    SvUTF8_on(sv);

    return matches;
}

STATIC I32
S_do_trans_count_utf8(pTHX_ SV * const sv)
{
    const U8 *s;
    const U8 *start = NULL;
    const U8 *send;
    I32 matches = 0;
    STRLEN len;
    SV* const  rv =
#ifdef USE_ITHREADS
		    PAD_SVl(cPADOP->op_padix);
#else
		    MUTABLE_SV(cSVOP->op_sv);
#endif
    HV* const hv = MUTABLE_HV(SvRV(rv));
    SV* const * const svp = hv_fetchs(hv, "NONE", FALSE);
    const UV none = svp ? SvUV(*svp) : 0x7fffffff;
    const UV extra = none + 1;
    U8 hibit = 0;

    PERL_ARGS_ASSERT_DO_TRANS_COUNT_UTF8;

    s = (const U8*)SvPV_nomg_const(sv, len);
    if (!SvUTF8(sv)) {
	const U8 *t = s;
	const U8 * const e = s + len;
	while (t < e) {
	    const U8 ch = *t++;
	    hibit = !NATIVE_BYTE_IS_INVARIANT(ch);
	    if (hibit) {
		start = s = bytes_to_utf8(s, &len);
		break;
	    }
	}
    }
    send = s + len;

    while (s < send) {
	const UV uv = swash_fetch(rv, s, TRUE);
	if (uv < none || uv == extra)
	    matches++;
	s += UTF8SKIP(s);
    }
    if (hibit)
        Safefree(start);

    return matches;
}

STATIC I32
S_do_trans_complex_utf8(pTHX_ SV * const sv)
{
    U8 *start, *send;
    U8 *d;
    I32 matches = 0;
    const I32 squash   = PL_op->op_private & OPpTRANS_SQUASH;
    const I32 del      = PL_op->op_private & OPpTRANS_DELETE;
    const I32 grows    = PL_op->op_private & OPpTRANS_GROWS;
    SV* const  rv =
#ifdef USE_ITHREADS
		    PAD_SVl(cPADOP->op_padix);
#else
		    MUTABLE_SV(cSVOP->op_sv);
#endif
    HV * const hv = MUTABLE_HV(SvRV(rv));
    SV * const *svp = hv_fetchs(hv, "NONE", FALSE);
    const UV none = svp ? SvUV(*svp) : 0x7fffffff;
    const UV extra = none + 1;
    UV final = 0;
    bool havefinal = FALSE;
    STRLEN len;
    U8 *dstart, *dend;
    U8 hibit = 0;
    U8 *s = (U8*)SvPV_nomg(sv, len);

    PERL_ARGS_ASSERT_DO_TRANS_COMPLEX_UTF8;

    if (!SvUTF8(sv)) {
	const U8 *t = s;
	const U8 * const e = s + len;
	while (t < e) {
	    const U8 ch = *t++;
	    hibit = !NATIVE_BYTE_IS_INVARIANT(ch);
	    if (hibit) {
		s = bytes_to_utf8(s, &len);
		break;
	    }
	}
    }
    send = s + len;
    start = s;

    svp = hv_fetchs(hv, "FINAL", FALSE);
    if (svp) {
	final = SvUV(*svp);
	havefinal = TRUE;
    }

    if (grows) {
	/* d needs to be bigger than s, in case e.g. upgrading is required */
	Newx(d, len * 3 + UTF8_MAXBYTES, U8);
	dend = d + len * 3;
	dstart = d;
    }
    else {
	dstart = d = s;
	dend = d + len;
    }

    if (squash) {
	UV puv = 0xfeedface;
	while (s < send) {
	    UV uv = swash_fetch(rv, s, TRUE);
	
	    if (d > dend) {
		const STRLEN clen = d - dstart;
		const STRLEN nlen = dend - dstart + len + UTF8_MAXBYTES;
		if (!grows)
		    Perl_croak(aTHX_ "panic: do_trans_complex_utf8 line %d",__LINE__);
		Renew(dstart, nlen + UTF8_MAXBYTES, U8);
		d = dstart + clen;
		dend = dstart + nlen;
	    }
	    if (uv < none) {
		matches++;
		s += UTF8SKIP(s);
		if (uv != puv) {
		    d = uvchr_to_utf8(d, uv);
		    puv = uv;
		}
		continue;
	    }
	    else if (uv == none) {	/* "none" is unmapped character */
		const int i = UTF8SKIP(s);
		Move(s, d, i, U8);
		d += i;
		s += i;
		puv = 0xfeedface;
		continue;
	    }
	    else if (uv == extra && !del) {
		matches++;
		if (havefinal) {
		    s += UTF8SKIP(s);
		    if (puv != final) {
			d = uvchr_to_utf8(d, final);
			puv = final;
		    }
		}
		else {
		    STRLEN len;
		    uv = utf8n_to_uvchr(s, send - s, &len, UTF8_ALLOW_DEFAULT);
		    if (uv != puv) {
			Move(s, d, len, U8);
			d += len;
			puv = uv;
		    }
		    s += len;
		}
		continue;
	    }
	    matches++;			/* "none+1" is delete character */
	    s += UTF8SKIP(s);
	}
    }
    else {
	while (s < send) {
	    const UV uv = swash_fetch(rv, s, TRUE);
	    if (d > dend) {
	        const STRLEN clen = d - dstart;
		const STRLEN nlen = dend - dstart + len + UTF8_MAXBYTES;
		if (!grows)
		    Perl_croak(aTHX_ "panic: do_trans_complex_utf8 line %d",__LINE__);
		Renew(dstart, nlen + UTF8_MAXBYTES, U8);
		d = dstart + clen;
		dend = dstart + nlen;
	    }
	    if (uv < none) {
		matches++;
		s += UTF8SKIP(s);
		d = uvchr_to_utf8(d, uv);
		continue;
	    }
	    else if (uv == none) {	/* "none" is unmapped character */
		const int i = UTF8SKIP(s);
		Move(s, d, i, U8);
		d += i;
		s += i;
		continue;
	    }
	    else if (uv == extra && !del) {
		matches++;
		s += UTF8SKIP(s);
		d = uvchr_to_utf8(d, final);
		continue;
	    }
	    matches++;			/* "none+1" is delete character */
	    s += UTF8SKIP(s);
	}
    }
    if (grows || hibit) {
	sv_setpvn(sv, (char*)dstart, d - dstart);
	Safefree(dstart);
	if (grows && hibit)
	    Safefree(start);
    }
    else {
	*d = '\0';
	SvCUR_set(sv, d - dstart);
    }
    SvUTF8_on(sv);
    SvSETMAGIC(sv);

    return matches;
}

I32
Perl_do_trans(pTHX_ SV *sv)
{
    STRLEN len;
    const I32 flags = PL_op->op_private;
    const I32 hasutf = flags & (OPpTRANS_FROM_UTF | OPpTRANS_TO_UTF);

    PERL_ARGS_ASSERT_DO_TRANS;

    if (SvREADONLY(sv) && !(flags & OPpTRANS_IDENTICAL)) {
        Perl_croak_no_modify();
    }
    (void)SvPV_const(sv, len);
    if (!len)
	return 0;
    if (!(flags & OPpTRANS_IDENTICAL)) {
	if (!SvPOKp(sv) || SvTHINKFIRST(sv))
	    (void)SvPV_force_nomg(sv, len);
	(void)SvPOK_only_UTF8(sv);
    }

    DEBUG_t( Perl_deb(aTHX_ "2.TBL\n"));

    /* If we use only OPpTRANS_IDENTICAL to bypass the READONLY check,
     * we must also rely on it to choose the readonly strategy.
     */
    if (flags & OPpTRANS_IDENTICAL) {
        return hasutf ? do_trans_count_utf8(sv) : do_trans_count(sv);
    } else if (flags & (OPpTRANS_SQUASH|OPpTRANS_DELETE|OPpTRANS_COMPLEMENT)) {
        return hasutf ? do_trans_complex_utf8(sv) : do_trans_complex(sv);
    } else {
        return hasutf ? do_trans_simple_utf8(sv) : do_trans_simple(sv);
    }
}

void
Perl_do_join(pTHX_ SV *sv, SV *delim, SV **mark, SV **sp)
{
    SV ** const oldmark = mark;
    I32 items = sp - mark;
    STRLEN len;
    STRLEN delimlen;
    const char * const delims = SvPV_const(delim, delimlen);

    PERL_ARGS_ASSERT_DO_JOIN;

    mark++;
    len = (items > 0 ? (delimlen * (items - 1) ) : 0);
    SvUPGRADE(sv, SVt_PV);
    if (SvLEN(sv) < len + items) {	/* current length is way too short */
	while (items-- > 0) {
	    if (*mark && !SvGAMAGIC(*mark) && SvOK(*mark)) {
		STRLEN tmplen;
		SvPV_const(*mark, tmplen);
		len += tmplen;
	    }
	    mark++;
	}
	SvGROW(sv, len + 1);		/* so try to pre-extend */

	mark = oldmark;
	items = sp - mark;
	++mark;
    }

    sv_setpvs(sv, "");
    /* sv_setpv retains old UTF8ness [perl #24846] */
    SvUTF8_off(sv);

    if (TAINTING_get && SvMAGICAL(sv))
	SvTAINTED_off(sv);

    if (items-- > 0) {
	if (*mark)
	    sv_catsv(sv, *mark);
	mark++;
    }

    if (delimlen) {
	const U32 delimflag = DO_UTF8(delim) ? SV_CATUTF8 : SV_CATBYTES;
	for (; items > 0; items--,mark++) {
	    STRLEN len;
	    const char *s;
	    sv_catpvn_flags(sv,delims,delimlen,delimflag);
	    s = SvPV_const(*mark,len);
	    sv_catpvn_flags(sv,s,len,
			    DO_UTF8(*mark) ? SV_CATUTF8 : SV_CATBYTES);
	}
    }
    else {
	for (; items > 0; items--,mark++)
	{
	    STRLEN len;
	    const char *s = SvPV_const(*mark,len);
	    sv_catpvn_flags(sv,s,len,
			    DO_UTF8(*mark) ? SV_CATUTF8 : SV_CATBYTES);
	}
    }
    SvSETMAGIC(sv);
}

void
Perl_do_sprintf(pTHX_ SV *sv, I32 len, SV **sarg)
{
    STRLEN patlen;
    const char * const pat = SvPV_const(*sarg, patlen);
    bool do_taint = FALSE;

    PERL_ARGS_ASSERT_DO_SPRINTF;

    if (SvTAINTED(*sarg))
	TAINT_PROPER(
		(PL_op && PL_op->op_type < OP_max)
		    ? (PL_op->op_type == OP_PRTF)
			? "printf"
			: PL_op_name[PL_op->op_type]
		    : "(unknown)"
	);
    SvUTF8_off(sv);
    if (DO_UTF8(*sarg))
        SvUTF8_on(sv);
    sv_vsetpvfn(sv, pat, patlen, NULL, sarg + 1, len - 1, &do_taint);
    SvSETMAGIC(sv);
    if (do_taint)
	SvTAINTED_on(sv);
}

/* currently converts input to bytes if possible, but doesn't sweat failure */
UV
Perl_do_vecget(pTHX_ SV *sv, SSize_t offset, int size)
{
    STRLEN srclen, len, uoffset, bitoffs = 0;
    const I32 svpv_flags = ((PL_op->op_flags & OPf_MOD || LVRET)
                                          ? SV_UNDEF_RETURNS_NULL : 0);
    unsigned char *s = (unsigned char *)
                            SvPV_flags(sv, srclen, (svpv_flags|SV_GMAGIC));
    UV retnum = 0;

    if (!s) {
      s = (unsigned char *)"";
    }
    
    PERL_ARGS_ASSERT_DO_VECGET;

    if (offset < 0)
	return 0;
    if (size < 1 || (size & (size-1))) /* size < 1 or not a power of two */
	Perl_croak(aTHX_ "Illegal number of bits in vec");

    if (SvUTF8(sv)) {
	(void) Perl_sv_utf8_downgrade(aTHX_ sv, TRUE);
        /* PVX may have changed */
        s = (unsigned char *) SvPV_flags(sv, srclen, svpv_flags);
    }

    if (size < 8) {
	bitoffs = ((offset%8)*size)%8;
	uoffset = offset/(8/size);
    }
    else if (size > 8)
	uoffset = offset*(size/8);
    else
	uoffset = offset;

    len = uoffset + (bitoffs + size + 7)/8;	/* required number of bytes */
    if (len > srclen) {
	if (size <= 8)
	    retnum = 0;
	else {
	    if (size == 16) {
		if (uoffset >= srclen)
		    retnum = 0;
		else
		    retnum = (UV) s[uoffset] <<  8;
	    }
	    else if (size == 32) {
		if (uoffset >= srclen)
		    retnum = 0;
		else if (uoffset + 1 >= srclen)
		    retnum =
			((UV) s[uoffset    ] << 24);
		else if (uoffset + 2 >= srclen)
		    retnum =
			((UV) s[uoffset    ] << 24) +
			((UV) s[uoffset + 1] << 16);
		else
		    retnum =
			((UV) s[uoffset    ] << 24) +
			((UV) s[uoffset + 1] << 16) +
			(     s[uoffset + 2] <<  8);
	    }
#ifdef UV_IS_QUAD
	    else if (size == 64) {
		Perl_ck_warner(aTHX_ packWARN(WARN_PORTABLE),
			       "Bit vector size > 32 non-portable");
		if (uoffset >= srclen)
		    retnum = 0;
		else if (uoffset + 1 >= srclen)
		    retnum =
			(UV) s[uoffset     ] << 56;
		else if (uoffset + 2 >= srclen)
		    retnum =
			((UV) s[uoffset    ] << 56) +
			((UV) s[uoffset + 1] << 48);
		else if (uoffset + 3 >= srclen)
		    retnum =
			((UV) s[uoffset    ] << 56) +
			((UV) s[uoffset + 1] << 48) +
			((UV) s[uoffset + 2] << 40);
		else if (uoffset + 4 >= srclen)
		    retnum =
			((UV) s[uoffset    ] << 56) +
			((UV) s[uoffset + 1] << 48) +
			((UV) s[uoffset + 2] << 40) +
			((UV) s[uoffset + 3] << 32);
		else if (uoffset + 5 >= srclen)
		    retnum =
			((UV) s[uoffset    ] << 56) +
			((UV) s[uoffset + 1] << 48) +
			((UV) s[uoffset + 2] << 40) +
			((UV) s[uoffset + 3] << 32) +
			((UV) s[uoffset + 4] << 24);
		else if (uoffset + 6 >= srclen)
		    retnum =
			((UV) s[uoffset    ] << 56) +
			((UV) s[uoffset + 1] << 48) +
			((UV) s[uoffset + 2] << 40) +
			((UV) s[uoffset + 3] << 32) +
			((UV) s[uoffset + 4] << 24) +
			((UV) s[uoffset + 5] << 16);
		else
		    retnum =
			((UV) s[uoffset    ] << 56) +
			((UV) s[uoffset + 1] << 48) +
			((UV) s[uoffset + 2] << 40) +
			((UV) s[uoffset + 3] << 32) +
			((UV) s[uoffset + 4] << 24) +
			((UV) s[uoffset + 5] << 16) +
			((UV) s[uoffset + 6] <<  8);
	    }
#endif
	}
    }
    else if (size < 8)
	retnum = (s[uoffset] >> bitoffs) & ((1 << size) - 1);
    else {
	if (size == 8)
	    retnum = s[uoffset];
	else if (size == 16)
	    retnum =
		((UV) s[uoffset] <<      8) +
		      s[uoffset + 1];
	else if (size == 32)
	    retnum =
		((UV) s[uoffset    ] << 24) +
		((UV) s[uoffset + 1] << 16) +
		(     s[uoffset + 2] <<  8) +
		      s[uoffset + 3];
#ifdef UV_IS_QUAD
	else if (size == 64) {
	    Perl_ck_warner(aTHX_ packWARN(WARN_PORTABLE),
			   "Bit vector size > 32 non-portable");
	    retnum =
		((UV) s[uoffset    ] << 56) +
		((UV) s[uoffset + 1] << 48) +
		((UV) s[uoffset + 2] << 40) +
		((UV) s[uoffset + 3] << 32) +
		((UV) s[uoffset + 4] << 24) +
		((UV) s[uoffset + 5] << 16) +
		(     s[uoffset + 6] <<  8) +
		      s[uoffset + 7];
	}
#endif
    }

    return retnum;
}

/* currently converts input to bytes if possible but doesn't sweat failures,
 * although it does ensure that the string it clobbers is not marked as
 * utf8-valid any more
 */
void
Perl_do_vecset(pTHX_ SV *sv)
{
    SSize_t offset, bitoffs = 0;
    int size;
    unsigned char *s;
    UV lval;
    I32 mask;
    STRLEN targlen;
    STRLEN len;
    SV * const targ = LvTARG(sv);

    PERL_ARGS_ASSERT_DO_VECSET;

    if (!targ)
	return;
    s = (unsigned char*)SvPV_force_flags(targ, targlen,
                                         SV_GMAGIC | SV_UNDEF_RETURNS_NULL);
    if (SvUTF8(targ)) {
	/* This is handled by the SvPOK_only below...
	if (!Perl_sv_utf8_downgrade(aTHX_ targ, TRUE))
	    SvUTF8_off(targ);
	 */
	(void) Perl_sv_utf8_downgrade(aTHX_ targ, TRUE);
    }

    (void)SvPOK_only(targ);
    lval = SvUV(sv);
    offset = LvTARGOFF(sv);
    if (offset < 0)
	Perl_croak(aTHX_ "Negative offset to vec in lvalue context");
    size = LvTARGLEN(sv);
    if (size < 1 || (size & (size-1))) /* size < 1 or not a power of two */
	Perl_croak(aTHX_ "Illegal number of bits in vec");

    if (size < 8) {
	bitoffs = ((offset%8)*size)%8;
	offset /= 8/size;
    }
    else if (size > 8)
	offset *= size/8;

    len = offset + (bitoffs + size + 7)/8;	/* required number of bytes */
    if (len > targlen) {
	s = (unsigned char*)SvGROW(targ, len + 1);
	(void)memzero((char *)(s + targlen), len - targlen + 1);
	SvCUR_set(targ, len);
    }

    if (size < 8) {
	mask = (1 << size) - 1;
	lval &= mask;
	s[offset] &= ~(mask << bitoffs);
	s[offset] |= lval << bitoffs;
    }
    else {
	if (size == 8)
	    s[offset  ] = (U8)( lval        & 0xff);
	else if (size == 16) {
	    s[offset  ] = (U8)((lval >>  8) & 0xff);
	    s[offset+1] = (U8)( lval        & 0xff);
	}
	else if (size == 32) {
	    s[offset  ] = (U8)((lval >> 24) & 0xff);
	    s[offset+1] = (U8)((lval >> 16) & 0xff);
	    s[offset+2] = (U8)((lval >>  8) & 0xff);
	    s[offset+3] = (U8)( lval        & 0xff);
	}
#ifdef UV_IS_QUAD
	else if (size == 64) {
	    Perl_ck_warner(aTHX_ packWARN(WARN_PORTABLE),
			   "Bit vector size > 32 non-portable");
	    s[offset  ] = (U8)((lval >> 56) & 0xff);
	    s[offset+1] = (U8)((lval >> 48) & 0xff);
	    s[offset+2] = (U8)((lval >> 40) & 0xff);
	    s[offset+3] = (U8)((lval >> 32) & 0xff);
	    s[offset+4] = (U8)((lval >> 24) & 0xff);
	    s[offset+5] = (U8)((lval >> 16) & 0xff);
	    s[offset+6] = (U8)((lval >>  8) & 0xff);
	    s[offset+7] = (U8)( lval        & 0xff);
	}
#endif
    }
    SvSETMAGIC(targ);
}

void
Perl_do_vop(pTHX_ I32 optype, SV *sv, SV *left, SV *right)
{
#ifdef LIBERAL
    long *dl;
    long *ll;
    long *rl;
#endif
    char *dc;
    STRLEN leftlen;
    STRLEN rightlen;
    const char *lc;
    const char *rc;
    STRLEN len;
    STRLEN lensave;
    const char *lsave;
    const char *rsave;
    bool left_utf;
    bool right_utf;
    bool do_warn_above_ff = ckWARN_d(WARN_DEPRECATED);
    STRLEN needlen = 0;

    PERL_ARGS_ASSERT_DO_VOP;

    if (sv != left || (optype != OP_BIT_AND && !SvOK(sv)))
	sv_setpvs(sv, "");	/* avoid undef warning on |= and ^= */
    if (sv == left) {
	lsave = lc = SvPV_force_nomg(left, leftlen);
    }
    else {
	lsave = lc = SvPV_nomg_const(left, leftlen);
	SvPV_force_nomg_nolen(sv);
    }
    rsave = rc = SvPV_nomg_const(right, rightlen);

    /* This needs to come after SvPV to ensure that string overloading has
       fired off.  */

    left_utf = DO_UTF8(left);
    right_utf = DO_UTF8(right);

    if (left_utf && !right_utf) {
	/* Avoid triggering overloading again by using temporaries.
	   Maybe there should be a variant of sv_utf8_upgrade that takes pvn
	*/
	right = newSVpvn_flags(rsave, rightlen, SVs_TEMP);
	sv_utf8_upgrade(right);
	rsave = rc = SvPV_nomg_const(right, rightlen);
	right_utf = TRUE;
    }
    else if (!left_utf && right_utf) {
	left = newSVpvn_flags(lsave, leftlen, SVs_TEMP);
	sv_utf8_upgrade(left);
	lsave = lc = SvPV_nomg_const(left, leftlen);
	left_utf = TRUE;
    }

    len = leftlen < rightlen ? leftlen : rightlen;
    lensave = len;
    SvCUR_set(sv, len);
    (void)SvPOK_only(sv);
    if ((left_utf || right_utf) && (sv == left || sv == right)) {
	needlen = optype == OP_BIT_AND ? len : leftlen + rightlen;
	Newxz(dc, needlen + 1, char);
    }
    else if (SvOK(sv) || SvTYPE(sv) > SVt_PVMG) {
	dc = SvPV_force_nomg_nolen(sv);
	if (SvLEN(sv) < len + 1) {
	    dc = SvGROW(sv, len + 1);
	    (void)memzero(dc + SvCUR(sv), len - SvCUR(sv) + 1);
	}
	if (optype != OP_BIT_AND && (left_utf || right_utf))
	    dc = SvGROW(sv, leftlen + rightlen + 1);
    }
    else {
	needlen = optype == OP_BIT_AND
		    ? len : (leftlen > rightlen ? leftlen : rightlen);
	Newxz(dc, needlen + 1, char);
	sv_usepvn_flags(sv, dc, needlen, SV_HAS_TRAILING_NUL);
	dc = SvPVX(sv);		/* sv_usepvn() calls Renew() */
    }
    if (left_utf || right_utf) {
	UV duc, luc, ruc;
	char *dcorig = dc;
	char *dcsave = NULL;
	STRLEN lulen = leftlen;
	STRLEN rulen = rightlen;
	STRLEN ulen;

	switch (optype) {
	case OP_BIT_AND:
	    while (lulen && rulen) {
		luc = utf8n_to_uvchr((U8*)lc, lulen, &ulen, UTF8_ALLOW_ANYUV);
		lc += ulen;
		lulen -= ulen;
		ruc = utf8n_to_uvchr((U8*)rc, rulen, &ulen, UTF8_ALLOW_ANYUV);
		rc += ulen;
		rulen -= ulen;
		duc = luc & ruc;
		dc = (char*)uvchr_to_utf8((U8*)dc, duc);
                if (do_warn_above_ff && (luc > 0xff || ruc > 0xff)) {
                    Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                                deprecated_above_ff_msg, PL_op_desc[optype]);
                    /* Warn only once per operation */
                    do_warn_above_ff = FALSE;
                }
	    }
	    if (sv == left || sv == right)
		(void)sv_usepvn(sv, dcorig, needlen);
	    SvCUR_set(sv, dc - dcorig);
	    break;
	case OP_BIT_XOR:
	    while (lulen && rulen) {
		luc = utf8n_to_uvchr((U8*)lc, lulen, &ulen, UTF8_ALLOW_ANYUV);
		lc += ulen;
		lulen -= ulen;
		ruc = utf8n_to_uvchr((U8*)rc, rulen, &ulen, UTF8_ALLOW_ANYUV);
		rc += ulen;
		rulen -= ulen;
		duc = luc ^ ruc;
		dc = (char*)uvchr_to_utf8((U8*)dc, duc);
                if (do_warn_above_ff && (luc > 0xff || ruc > 0xff)) {
                    Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                                deprecated_above_ff_msg, PL_op_desc[optype]);
                    do_warn_above_ff = FALSE;
                }
	    }
	    goto mop_up_utf;
	case OP_BIT_OR:
	    while (lulen && rulen) {
		luc = utf8n_to_uvchr((U8*)lc, lulen, &ulen, UTF8_ALLOW_ANYUV);
		lc += ulen;
		lulen -= ulen;
		ruc = utf8n_to_uvchr((U8*)rc, rulen, &ulen, UTF8_ALLOW_ANYUV);
		rc += ulen;
		rulen -= ulen;
		duc = luc | ruc;
		dc = (char*)uvchr_to_utf8((U8*)dc, duc);
                if (do_warn_above_ff && (luc > 0xff || ruc > 0xff)) {
                    Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                                deprecated_above_ff_msg, PL_op_desc[optype]);
                    do_warn_above_ff = FALSE;
                }
	    }
	  mop_up_utf:
	    if (rulen)
		dcsave = savepvn(rc, rulen);
	    else if (lulen)
		dcsave = savepvn(lc, lulen);
	    if (sv == left || sv == right)
		(void)sv_usepvn(sv, dcorig, needlen); /* uses Renew(); defaults to nomg */
	    SvCUR_set(sv, dc - dcorig);
	    if (rulen)
		sv_catpvn_nomg(sv, dcsave, rulen);
	    else if (lulen)
		sv_catpvn_nomg(sv, dcsave, lulen);
	    else
		*SvEND(sv) = '\0';
	    Safefree(dcsave);
	    break;
	default:
	    if (sv == left || sv == right)
		Safefree(dcorig);
	    Perl_croak(aTHX_ "panic: do_vop called for op %u (%s)",
			(unsigned)optype, PL_op_name[optype]);
	}
	SvUTF8_on(sv);
	goto finish;
    }
    else
#ifdef LIBERAL
    if (len >= sizeof(long)*4 &&
	!((unsigned long)dc % sizeof(long)) &&
	!((unsigned long)lc % sizeof(long)) &&
	!((unsigned long)rc % sizeof(long)))	/* It's almost always aligned... */
    {
	const STRLEN remainder = len % (sizeof(long)*4);
	len /= (sizeof(long)*4);

	dl = (long*)dc;
	ll = (long*)lc;
	rl = (long*)rc;

	switch (optype) {
	case OP_BIT_AND:
	    while (len--) {
		*dl++ = *ll++ & *rl++;
		*dl++ = *ll++ & *rl++;
		*dl++ = *ll++ & *rl++;
		*dl++ = *ll++ & *rl++;
	    }
	    break;
	case OP_BIT_XOR:
	    while (len--) {
		*dl++ = *ll++ ^ *rl++;
		*dl++ = *ll++ ^ *rl++;
		*dl++ = *ll++ ^ *rl++;
		*dl++ = *ll++ ^ *rl++;
	    }
	    break;
	case OP_BIT_OR:
	    while (len--) {
		*dl++ = *ll++ | *rl++;
		*dl++ = *ll++ | *rl++;
		*dl++ = *ll++ | *rl++;
		*dl++ = *ll++ | *rl++;
	    }
	}

	dc = (char*)dl;
	lc = (char*)ll;
	rc = (char*)rl;

	len = remainder;
    }
#endif
    {
	switch (optype) {
	case OP_BIT_AND:
	    while (len--)
		*dc++ = *lc++ & *rc++;
	    *dc = '\0';
	    break;
	case OP_BIT_XOR:
	    while (len--)
		*dc++ = *lc++ ^ *rc++;
	    goto mop_up;
	case OP_BIT_OR:
	    while (len--)
		*dc++ = *lc++ | *rc++;
	  mop_up:
	    len = lensave;
	    if (rightlen > len)
		sv_catpvn_nomg(sv, rsave + len, rightlen - len);
	    else if (leftlen > (STRLEN)len)
		sv_catpvn_nomg(sv, lsave + len, leftlen - len);
	    else
		*SvEND(sv) = '\0';
	    break;
	}
    }
  finish:
    SvTAINT(sv);
}


/* used for: pp_keys(), pp_values() */

OP *
Perl_do_kv(pTHX)
{
    dSP;
    HV * const keys = MUTABLE_HV(POPs);
    HE *entry;
    SSize_t extend_size;
    const U8 gimme = GIMME_V;
    const I32 dokv =     (PL_op->op_type == OP_RV2HV || PL_op->op_type == OP_PADHV);
    /* op_type is OP_RKEYS/OP_RVALUES if pp_rkeys delegated to here */
    const I32 dokeys =   dokv || (PL_op->op_type == OP_KEYS);
    const I32 dovalues = dokv || (PL_op->op_type == OP_VALUES);

    (void)hv_iterinit(keys);	/* always reset iterator regardless */

    if (gimme == G_VOID)
	RETURN;

    if (gimme == G_SCALAR) {
	if (PL_op->op_flags & OPf_MOD || LVRET) {	/* lvalue */
	    SV * const ret = sv_2mortal(newSV_type(SVt_PVLV));  /* Not TARG RT#67838 */
	    sv_magic(ret, NULL, PERL_MAGIC_nkeys, NULL, 0);
	    LvTYPE(ret) = 'k';
	    LvTARG(ret) = SvREFCNT_inc_simple(keys);
	    PUSHs(ret);
	}
	else {
	    IV i;
	    dTARGET;

	    if (! SvTIED_mg((const SV *)keys, PERL_MAGIC_tied) ) {
		i = HvUSEDKEYS(keys);
	    }
	    else {
		i = 0;
		while (hv_iternext(keys)) i++;
	    }
	    PUSHi( i );
	}
	RETURN;
    }

    /* 2*HvUSEDKEYS() should never be big enough to truncate or wrap */
    assert(HvUSEDKEYS(keys) <= (SSize_t_MAX >> 1));
    extend_size = (SSize_t)HvUSEDKEYS(keys) * (dokeys + dovalues);
    EXTEND(SP, extend_size);

    while ((entry = hv_iternext(keys))) {
	if (dokeys) {
	    SV* const sv = hv_iterkeysv(entry);
	    XPUSHs(sv);
	}
	if (dovalues) {
	    SV *tmpstr = hv_iterval(keys,entry);
	    DEBUG_H(Perl_sv_setpvf(aTHX_ tmpstr, "%lu%%%d=%lu",
			    (unsigned long)HeHASH(entry),
			    (int)HvMAX(keys)+1,
			    (unsigned long)(HeHASH(entry) & HvMAX(keys))));
	    XPUSHs(tmpstr);
	}
    }
    RETURN;
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.17
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d19 1
a19 1
 * do_printf() found in this file.
a32 1
    dVAR;
a100 1
    dVAR;
a137 1
    dVAR;
a300 1
    dVAR;
a404 1
    dVAR;
a453 1
    dVAR;
a620 1
    dVAR;
d622 2
a623 2
    const I32 hasutf = (PL_op->op_private &
                    (OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF));
d627 2
a628 2
    if (SvREADONLY(sv) && !(PL_op->op_private & OPpTRANS_IDENTICAL)) {
            Perl_croak_no_modify();
d633 1
a633 1
    if (!(PL_op->op_private & OPpTRANS_IDENTICAL)) {
d641 9
a649 21
    switch (PL_op->op_private & ~hasutf & (
		OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF|OPpTRANS_IDENTICAL|
		OPpTRANS_SQUASH|OPpTRANS_DELETE|OPpTRANS_COMPLEMENT)) {
    case 0:
	if (hasutf)
	    return do_trans_simple_utf8(sv);
	else
	    return do_trans_simple(sv);

    case OPpTRANS_IDENTICAL:
    case OPpTRANS_IDENTICAL|OPpTRANS_COMPLEMENT:
	if (hasutf)
	    return do_trans_count_utf8(sv);
	else
	    return do_trans_count(sv);

    default:
	if (hasutf)
	    return do_trans_complex_utf8(sv);
	else
	    return do_trans_complex(sv);
a655 1
    dVAR;
d660 1
a663 3
    (void) SvPV_const(delim, delimlen); /* stringify and get the delimlen */
    /* SvCUR assumes it's SvPOK() and woe betide you if it's not. */

d697 1
d699 6
a704 2
	    sv_catsv_nomg(sv,delim);
	    sv_catsv(sv,*mark);
d709 6
a714 1
	    sv_catsv(sv,*mark);
a721 1
    dVAR;
a748 1
    dVAR;
d839 1
a839 1
			(     s[uoffset + 4] << 24);
d856 1
a856 1
			(     s[uoffset + 6] <<  8);
a902 1
    dVAR;
a988 1
    dVAR;
d1005 1
d1021 1
a1021 1
    /* This need to come after SvPV to ensure that string overloading has
d1086 6
d1107 5
d1124 5
d1227 1
a1227 1
finish:
d1231 3
a1236 1
    dVAR;
d1240 2
a1241 1
    const I32 gimme = GIMME_V;
d1244 2
a1245 2
    const I32 dokeys =   dokv || (PL_op->op_type == OP_KEYS || PL_op->op_type == OP_RKEYS);
    const I32 dovalues = dokv || (PL_op->op_type == OP_VALUES || PL_op->op_type == OP_RVALUES);
d1276 4
a1279 1
    EXTEND(SP, HvUSEDKEYS(keys) * (dokeys + dovalues));
a1280 1
    PUTBACK;	/* hv_iternext and hv_iterval might clobber stack_sp */
a1281 1
	SPAGAIN;
d1284 1
a1284 1
	    XPUSHs(sv);	/* won't clobber stack_sp */
d1287 1
a1287 3
	    SV *tmpstr;
	    PUTBACK;
	    tmpstr = hv_iterval(keys,entry);
a1291 1
	    SPAGAIN;
a1293 1
	PUTBACK;
d1295 1
a1295 1
    return NORMAL;
a1298 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.16
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d18 2
a19 2
 * ops. For example both pp_schomp() and pp_chomp() - scalar and array
 * chomp operations - call the function do_chomp() found in this file.
d334 1
a334 1
	    hibit = !NATIVE_IS_INVARIANT(ch);
d364 1
a364 1
	    d = uvuni_to_utf8(d, uv);
d375 1
a375 1
	    d = uvuni_to_utf8(d, final);
d435 1
a435 1
	    hibit = !NATIVE_IS_INVARIANT(ch);
d490 1
a490 1
	    hibit = !NATIVE_IS_INVARIANT(ch);
d535 1
a535 1
		    d = uvuni_to_utf8(d, uv);
d553 1
a553 1
			d = uvuni_to_utf8(d, final);
d559 1
a559 1
		    uv = utf8n_to_uvuni(s, send - s, &len, UTF8_ALLOW_DEFAULT);
d588 1
a588 1
		d = uvuni_to_utf8(d, uv);
d601 1
a601 1
		d = uvuni_to_utf8(d, final);
a634 1
        if (!SvIsCOW(sv))
d764 4
a767 3
    const unsigned char *s = (const unsigned char *) SvPV_flags_const(sv, srclen,
                             SV_GMAGIC | ((PL_op->op_flags & OPf_MOD || LVRET)
                                          ? SV_UNDEF_RETURNS_NULL : 0));
d771 1
a771 1
      s = (const unsigned char *)"";
d781 1
a781 1
    if (SvUTF8(sv))
d783 3
@


1.15
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d635 2
a636 4
        if (SvIsCOW(sv))
            sv_force_normal_flags(sv, 0);
        if (SvREADONLY(sv))
            Perl_croak_no_modify(aTHX);
d642 1
a642 1
	if (!SvPOKp(sv))
d674 1
a674 1
Perl_do_join(pTHX_ register SV *sv, SV *delim, register SV **mark, register SV **sp)
d678 2
a679 2
    register I32 items = sp - mark;
    register STRLEN len;
d710 1
a710 1
    if (PL_tainting && SvMAGICAL(sv))
d721 1
a721 1
	    sv_catsv(sv,delim);
d761 1
a761 1
Perl_do_vecget(pTHX_ SV *sv, I32 offset, I32 size)
d765 3
a767 1
    const unsigned char *s = (const unsigned char *) SvPV_const(sv, srclen);
d770 4
d915 4
a918 4
    register I32 offset, bitoffs = 0;
    register I32 size;
    register unsigned char *s;
    register UV lval;
d928 2
a929 1
    s = (unsigned char*)SvPV_force(targ, targlen);
d1003 3
a1005 3
    register long *dl;
    register long *ll;
    register long *rl;
d1007 1
a1007 1
    register char *dc;
d1010 3
a1012 3
    register const char *lc;
    register const char *rc;
    register STRLEN len;
d1132 1
a1132 1
		(void)sv_usepvn(sv, dcorig, needlen); /* Uses Renew(). */
d1135 1
a1135 1
		sv_catpvn(sv, dcsave, rulen);
d1137 1
a1137 1
		sv_catpvn(sv, dcsave, lulen);
d1215 1
a1215 1
		sv_catpvn(sv, rsave + len, rightlen - len);
d1217 1
a1217 1
		sv_catpvn(sv, lsave + len, leftlen - len);
d1233 1
a1233 1
    register HE *entry;
d1298 1
a1298 1
 * indent-tabs-mode: t
d1301 1
a1301 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.14
log
@merge in perl 5.12.2 plus local changes
@
text
@d36 1
a36 1
    U8 *s = (U8*)SvPV(sv,len);
d104 1
a104 1
    const U8 *s = (const U8*)SvPV_const(sv, len);
d142 1
a142 1
    U8 *s = (U8*)SvPV(sv, len);
d328 1
a328 1
    s = (U8*)SvPV(sv, len);
d429 1
a429 1
    s = (const U8*)SvPV_const(sv, len);
d481 1
a481 1
    U8 *s = (U8*)SvPV(sv, len);
d638 1
a638 1
            Perl_croak(aTHX_ "%s", PL_no_modify);
d645 1
a645 1
	    (void)SvPV_force(sv, len);
d744 8
a993 215
Perl_do_chop(pTHX_ register SV *astr, register SV *sv)
{
    dVAR;
    STRLEN len;
    char *s;

    PERL_ARGS_ASSERT_DO_CHOP;

    if (SvTYPE(sv) == SVt_PVAV) {
	register I32 i;
	AV *const av = MUTABLE_AV(sv);
	const I32 max = AvFILL(av);

	for (i = 0; i <= max; i++) {
	    sv = MUTABLE_SV(av_fetch(av, i, FALSE));
	    if (sv && ((sv = *(SV**)sv), sv != &PL_sv_undef))
		do_chop(astr, sv);
	}
        return;
    }
    else if (SvTYPE(sv) == SVt_PVHV) {
	HV* const hv = MUTABLE_HV(sv);
	HE* entry;
        (void)hv_iterinit(hv);
        while ((entry = hv_iternext(hv)))
            do_chop(astr,hv_iterval(hv,entry));
        return;
    }
    else if (SvREADONLY(sv)) {
        if (SvFAKE(sv)) {
            /* SV is copy-on-write */
	    sv_force_normal_flags(sv, 0);
        }
        if (SvREADONLY(sv))
            Perl_croak(aTHX_ "%s", PL_no_modify);
    }

    if (PL_encoding && !SvUTF8(sv)) {
	/* like in do_chomp(), utf8-ize the sv as a side-effect
	 * if we're using encoding. */
	sv_recode_to_utf8(sv, PL_encoding);
    }

    s = SvPV(sv, len);
    if (len && !SvPOK(sv))
	s = SvPV_force_nomg(sv, len);
    if (DO_UTF8(sv)) {
	if (s && len) {
	    char * const send = s + len;
	    char * const start = s;
	    s = send - 1;
	    while (s > start && UTF8_IS_CONTINUATION(*s))
		s--;
	    if (is_utf8_string((U8*)s, send - s)) {
		sv_setpvn(astr, s, send - s);
		*s = '\0';
		SvCUR_set(sv, s - start);
		SvNIOK_off(sv);
		SvUTF8_on(astr);
	    }
	}
	else
	    sv_setpvs(astr, "");
    }
    else if (s && len) {
	s += --len;
	sv_setpvn(astr, s, 1);
	*s = '\0';
	SvCUR_set(sv, len);
	SvUTF8_off(sv);
	SvNIOK_off(sv);
    }
    else
	sv_setpvs(astr, "");
    SvSETMAGIC(sv);
}

I32
Perl_do_chomp(pTHX_ register SV *sv)
{
    dVAR;
    register I32 count;
    STRLEN len;
    char *s;
    char *temp_buffer = NULL;
    SV* svrecode = NULL;

    PERL_ARGS_ASSERT_DO_CHOMP;

    if (RsSNARF(PL_rs))
	return 0;
    if (RsRECORD(PL_rs))
      return 0;
    count = 0;
    if (SvTYPE(sv) == SVt_PVAV) {
	register I32 i;
	AV *const av = MUTABLE_AV(sv);
	const I32 max = AvFILL(av);

	for (i = 0; i <= max; i++) {
	    sv = MUTABLE_SV(av_fetch(av, i, FALSE));
	    if (sv && ((sv = *(SV**)sv), sv != &PL_sv_undef))
		count += do_chomp(sv);
	}
        return count;
    }
    else if (SvTYPE(sv) == SVt_PVHV) {
	HV* const hv = MUTABLE_HV(sv);
	HE* entry;
        (void)hv_iterinit(hv);
        while ((entry = hv_iternext(hv)))
            count += do_chomp(hv_iterval(hv,entry));
        return count;
    }
    else if (SvREADONLY(sv)) {
        if (SvFAKE(sv)) {
            /* SV is copy-on-write */
	    sv_force_normal_flags(sv, 0);
        }
        if (SvREADONLY(sv))
            Perl_croak(aTHX_ "%s", PL_no_modify);
    }

    if (PL_encoding) {
	if (!SvUTF8(sv)) {
	/* XXX, here sv is utf8-ized as a side-effect!
	   If encoding.pm is used properly, almost string-generating
	   operations, including literal strings, chr(), input data, etc.
	   should have been utf8-ized already, right?
	*/
	    sv_recode_to_utf8(sv, PL_encoding);
	}
    }

    s = SvPV(sv, len);
    if (s && len) {
	s += --len;
	if (RsPARA(PL_rs)) {
	    if (*s != '\n')
		goto nope;
	    ++count;
	    while (len && s[-1] == '\n') {
		--len;
		--s;
		++count;
	    }
	}
	else {
	    STRLEN rslen, rs_charlen;
	    const char *rsptr = SvPV_const(PL_rs, rslen);

	    rs_charlen = SvUTF8(PL_rs)
		? sv_len_utf8(PL_rs)
		: rslen;

	    if (SvUTF8(PL_rs) != SvUTF8(sv)) {
		/* Assumption is that rs is shorter than the scalar.  */
		if (SvUTF8(PL_rs)) {
		    /* RS is utf8, scalar is 8 bit.  */
		    bool is_utf8 = TRUE;
		    temp_buffer = (char*)bytes_from_utf8((U8*)rsptr,
							 &rslen, &is_utf8);
		    if (is_utf8) {
			/* Cannot downgrade, therefore cannot possibly match
			 */
			assert (temp_buffer == rsptr);
			temp_buffer = NULL;
			goto nope;
		    }
		    rsptr = temp_buffer;
		}
		else if (PL_encoding) {
		    /* RS is 8 bit, encoding.pm is used.
		     * Do not recode PL_rs as a side-effect. */
		   svrecode = newSVpvn(rsptr, rslen);
		   sv_recode_to_utf8(svrecode, PL_encoding);
		   rsptr = SvPV_const(svrecode, rslen);
		   rs_charlen = sv_len_utf8(svrecode);
		}
		else {
		    /* RS is 8 bit, scalar is utf8.  */
		    temp_buffer = (char*)bytes_to_utf8((U8*)rsptr, &rslen);
		    rsptr = temp_buffer;
		}
	    }
	    if (rslen == 1) {
		if (*s != *rsptr)
		    goto nope;
		++count;
	    }
	    else {
		if (len < rslen - 1)
		    goto nope;
		len -= rslen - 1;
		s -= rslen - 1;
		if (memNE(s, rsptr, rslen))
		    goto nope;
		count += rs_charlen;
	    }
	}
	s = SvPV_force_nolen(sv);
	SvCUR_set(sv, len);
	*SvEND(sv) = '\0';
	SvNIOK_off(sv);
	SvSETMAGIC(sv);
    }
  nope:

    SvREFCNT_dec(svrecode);

    Safefree(temp_buffer);
    return count;
}

void
d1017 1
a1017 1
    if (sv != left || (optype != OP_BIT_AND && !SvOK(sv) && !SvGMAGICAL(sv)))
d1227 1
a1227 2
    HV * const hv = MUTABLE_HV(POPs);
    HV *keys;
d1231 3
a1233 2
    const I32 dokeys =   dokv || (PL_op->op_type == OP_KEYS);
    const I32 dovalues = dokv || (PL_op->op_type == OP_VALUES);
a1234 11
    if (!hv) {
	if (PL_op->op_flags & OPf_MOD || LVRET) {	/* lvalue */
	    dTARGET;		/* make sure to clear its target here */
	    if (SvTYPE(TARG) == SVt_PVLV)
		LvTARG(TARG) = NULL;
	    PUSHs(TARG);
	}
	RETURN;
    }

    keys = hv;
a1240 3
	IV i;
	dTARGET;

d1242 5
a1246 16
	    if (SvTYPE(TARG) < SVt_PVLV) {
		sv_upgrade(TARG, SVt_PVLV);
		sv_magic(TARG, NULL, PERL_MAGIC_nkeys, NULL, 0);
	    }
	    LvTYPE(TARG) = 'k';
	    if (LvTARG(TARG) != (const SV *)keys) {
		SvREFCNT_dec(LvTARG(TARG));
		LvTARG(TARG) = SvREFCNT_inc_simple(keys);
	    }
	    PUSHs(TARG);
	    RETURN;
	}

	if (! SvTIED_mg((const SV *)keys, PERL_MAGIC_tied) )
	{
	    i = HvKEYS(keys);
d1249 11
a1259 2
	    i = 0;
	    while (hv_iternext(keys)) i++;
a1260 1
	PUSHi( i );
d1264 1
a1264 1
    EXTEND(SP, HvKEYS(keys) * (dokeys + dovalues));
d1276 1
a1276 1
	    tmpstr = hv_iterval(hv,entry);
@


1.13
log
@Merge in perl 5.10.1
@
text
@a205 4
#ifdef MACOS_TRADITIONAL
#define comp CoMP   /* "comp" is a keyword in some compilers ... */
#endif

d810 2
a811 3
		if (ckWARN(WARN_PORTABLE))
		    Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
				"Bit vector size > 32 non-portable");
d877 2
a878 3
	    if (ckWARN(WARN_PORTABLE))
		Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
			    "Bit vector size > 32 non-portable");
d969 2
a970 3
	    if (ckWARN(WARN_PORTABLE))
		Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
			    "Bit vector size > 32 non-portable");
d1194 1
a1194 2
    if (svrecode)
	 SvREFCNT_dec(svrecode);
d1469 1
a1469 2
		if (LvTARG(TARG))
		    SvREFCNT_dec(LvTARG(TARG));
@


1.12
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2004, 2005, 2006, 2007, by Larry Wall and others
d12 3
a14 1
 * "'So that was the job I felt I had to do when I started,' thought Sam."
d38 3
a41 1
    const short * const tbl = (short*)cPVOP->op_pv;
d107 3
a110 1
    const short * const tbl = (short*)cPVOP->op_pv;
d145 3
a148 1
    const short * const tbl = (short*)cPVOP->op_pv;
a316 1

d321 1
a321 1
		    (SV*)cSVOP->op_sv;
d323 1
a323 1
    HV* const  hv = (HV*)SvRV(rv);
d330 2
a418 1

d423 1
a423 1
		    (SV*)cSVOP->op_sv;
d425 1
a425 1
    HV* const hv = (HV*)SvRV(rv);
d431 2
d474 1
a474 1
		    (SV*)cSVOP->op_sv;
d476 1
a476 1
    HV * const hv = (HV*)SvRV(rv);
d485 3
a488 1
    U8 *s = (U8*)SvPV(sv, len);
d636 3
a638 1
    if (SvREADONLY(sv)) {
d641 2
a642 2
        if (SvREADONLY(sv) && !(PL_op->op_private & OPpTRANS_IDENTICAL))
            Perl_croak(aTHX_ PL_no_modify);
d688 2
d712 1
a712 1
    sv_setpvn(sv, "", 0);
d746 2
d766 2
d918 2
d999 2
d1003 1
a1003 1
	AV* const av = (AV*)sv;
d1007 1
a1007 1
	    sv = (SV*)av_fetch(av, i, FALSE);
d1014 1
a1014 1
	HV* const hv = (HV*)sv;
d1027 1
a1027 1
            Perl_croak(aTHX_ PL_no_modify);
d1038 1
a1038 1
	s = SvPV_force(sv, len);
d1055 1
a1055 1
	    sv_setpvn(astr, "", 0);
d1066 1
a1066 1
	sv_setpvn(astr, "", 0);
d1080 2
d1089 1
a1089 1
	AV* const av = (AV*)sv;
d1093 1
a1093 1
	    sv = (SV*)av_fetch(av, i, FALSE);
d1100 1
a1100 1
	HV* const hv = (HV*)sv;
d1113 1
a1113 1
            Perl_croak(aTHX_ PL_no_modify);
d1230 1
d1233 8
a1240 2
	sv_setpvn(sv, "", 0);	/* avoid undef warning on |= and ^= */
    lsave = lc = SvPV_nomg_const(left, leftlen);
d1253 1
a1253 1
	right = sv_2mortal(newSVpvn(rsave, rightlen));
d1259 1
a1259 1
	left = sv_2mortal(newSVpvn(lsave, leftlen));
d1442 1
a1442 1
    HV * const hv = (HV*)POPs;
d1476 1
a1476 1
	    if (LvTARG(TARG) != (SV*)keys) {
d1485 1
a1485 1
	if (! SvTIED_mg((SV*)keys, PERL_MAGIC_tied) )
@


1.11
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2004, 2005, 2006, by Larry Wall and others
d29 1
a29 1
S_do_trans_simple(pTHX_ SV *sv)
d31 1
a31 4
    U8 *s;
    U8 *d;
    const U8 *send;
    U8 *dstart;
a32 1
    const I32 grows = PL_op->op_private & OPpTRANS_GROWS;
d34 2
d37 1
a37 1
    const short *tbl = (short*)cPVOP->op_pv;
a40 3
    s = (U8*)SvPV(sv, len);
    send = s + len;

d47 1
a47 1
		*s++ = (U8)ch;
d49 1
a49 2
	    else
		s++;
a51 1
        return matches;
d53 4
d58 9
a66 9
    /* Allow for expansion: $_="a".chr(400); tr/a/\xFE/, FE needs encoding */
    if (grows)
	Newx(d, len*2+1, U8);
    else
	d = s;
    dstart = d;
    while (s < send) {
        STRLEN ulen;
	I32 ch;
d68 23
a90 20
        /* Need to check this, otherwise 128..255 won't match */
	const UV c = utf8n_to_uvchr(s, send - s, &ulen, 0);
        if (c < 0x100 && (ch = tbl[c]) >= 0) {
            matches++;
	    d = uvchr_to_utf8(d, ch);
            s += ulen;
        }
	else { /* No match -> copy */
	    Move(s, d, ulen, U8);
	    d += ulen;
	    s += ulen;
        }
    }
    if (grows) {
	sv_setpvn(sv, (char*)dstart, d - dstart);
	Safefree(dstart);
    }
    else {
	*d = '\0';
	SvCUR_set(sv, d - dstart);
a91 2
    SvUTF8_on(sv);
    SvSETMAGIC(sv);
d96 1
a96 1
S_do_trans_count(pTHX_ SV *sv)
d98 4
a101 2
    const U8 *s;
    const U8 *send;
a102 2
    STRLEN len;
    const I32 complement = PL_op->op_private & OPpTRANS_COMPLEMENT;
d108 1
a108 4
    s = (const U8*)SvPV_const(sv, len);
    send = s + len;

    if (!SvUTF8(sv))
d113 3
a115 1
    else
d118 1
a118 1
	    const UV c = utf8n_to_uvchr((U8 *)s, send - s, &ulen, 0);
d126 1
d132 1
a132 1
S_do_trans_complex(pTHX_ SV *sv)
d134 4
a137 5
    U8 *s;
    U8 *send;
    U8 *d;
    U8 *dstart;
    I32 isutf8;
a138 4
    const I32 grows = PL_op->op_private & OPpTRANS_GROWS;
    const I32 complement = PL_op->op_private & OPpTRANS_COMPLEMENT;
    const I32 del = PL_op->op_private & OPpTRANS_DELETE;
    STRLEN len, rlen = 0;
d144 3
a146 3
    s = (U8*)SvPV(sv, len);
    isutf8 = SvUTF8(sv);
    send = s + len;
a147 2
    if (!isutf8) {
	dstart = d = s;
d182 8
a189 1
    else { /* isutf8 */
d206 2
a207 1
		const UV comp = utf8_to_uvchr(s, &len);
d212 1
a212 1
			Copy(s, d, len, U8);
d218 1
a218 1
			    ch = (rlen == 0) ? comp :
d240 1
a240 1
		    Copy(s, d, len, U8);
d252 2
a253 1
		const UV comp = utf8_to_uvchr(s, &len);
d275 1
a275 1
		    Copy(s, d, len, U8);
d298 1
a298 1
S_do_trans_simple_utf8(pTHX_ SV *sv)
d300 1
d310 6
a315 1
    SV* const  rv = (SV*)cSVOP->op_sv;
d317 1
a317 1
    SV** svp = hv_fetch(hv, "NONE", 4, FALSE);
a320 2
    UV uv;
    I32 isutf8;
d324 3
a326 3
    isutf8 = SvUTF8(sv);
    if (!isutf8) {
	const U8 *t = s, *e = s + len;
d329 3
a331 1
	    if ((hibit = !NATIVE_IS_INVARIANT(ch)))
d333 1
a334 2
	if (hibit)
	    s = bytes_to_utf8(s, &len);
d339 1
a339 1
    svp = hv_fetch(hv, "FINAL", 5, FALSE);
d355 2
a356 1
	if ((uv = swash_fetch(rv, s, TRUE)) < none) {
d402 1
a402 1
S_do_trans_count_utf8(pTHX_ SV *sv)
d404 1
d406 2
a407 1
    const U8 *start = 0, *send;
d411 6
a416 1
    SV* const rv = (SV*)cSVOP->op_sv;
d418 1
a418 1
    SV** const svp = hv_fetch(hv, "NONE", 4, FALSE);
d426 1
a426 1
	const U8 *e = s + len;
d429 3
a431 1
	    if ((hibit = !NATIVE_IS_INVARIANT(ch)))
d433 1
a434 2
	if (hibit)
	    start = s = bytes_to_utf8((U8 *)s, &len);
d439 2
a440 2
	UV uv;
	if ((uv = swash_fetch(rv, (U8 *)s, TRUE)) < none || uv == extra)
d451 1
a451 1
S_do_trans_complex_utf8(pTHX_ SV *sv)
d453 1
d460 6
a465 1
    SV * const rv = (SV*)cSVOP->op_sv;
d467 1
a467 1
    SV** svp = hv_fetch(hv, "NONE", 4, FALSE);
d477 1
a477 2
    const I32 isutf8 = SvUTF8(sv);
    if (!isutf8) {
d482 3
a484 1
	    if ((hibit = !NATIVE_IS_INVARIANT(ch)))
d486 1
a487 2
	if (hibit)
	    s = bytes_to_utf8(s, &len);
d492 1
a492 1
    svp = hv_fetch(hv, "FINAL", 5, FALSE);
d551 1
a551 1
		    uv = utf8_to_uvuni(s, &len);
d619 1
d625 2
a626 2
        if (SvFAKE(sv))
            sv_force_normal(sv);
d666 1
a666 1
Perl_do_join(pTHX_ register SV *sv, SV *del, register SV **mark, register SV **sp)
d668 1
d674 1
a674 1
    (void) SvPV_const(del, delimlen); /* stringify and get the delimlen */
d679 1
a679 1
    (void)SvUPGRADE(sv, SVt_PV);
d711 1
a711 1
	    sv_catsv(sv,del);
d725 1
d733 1
a733 1
    sv_vsetpvfn(sv, pat, patlen, Null(va_list*), sarg + 1, len - 1, &do_taint);
d743 2
a744 1
    STRLEN srclen, len;
d749 1
a749 1
	return retnum;
d756 10
a765 2
    offset *= size;	/* turn into bit offset */
    len = (offset + size + 7) / 8;	/* required number of bytes */
a769 1
	    offset >>= 3;	/* turn into byte offset */
d771 1
a771 1
		if ((STRLEN)offset >= srclen)
d774 1
a774 1
		    retnum = (UV) s[offset] <<  8;
d777 1
a777 1
		if ((STRLEN)offset >= srclen)
d779 1
a779 1
		else if ((STRLEN)(offset + 1) >= srclen)
d781 2
a782 2
			((UV) s[offset    ] << 24);
		else if ((STRLEN)(offset + 2) >= srclen)
d784 2
a785 2
			((UV) s[offset    ] << 24) +
			((UV) s[offset + 1] << 16);
d788 3
a790 3
			((UV) s[offset    ] << 24) +
			((UV) s[offset + 1] << 16) +
			(     s[offset + 2] <<  8);
d797 1
a797 1
		if (offset >= srclen)
d799 1
a799 1
		else if (offset + 1 >= srclen)
d801 2
a802 2
			(UV) s[offset     ] << 56;
		else if (offset + 2 >= srclen)
d804 3
a806 3
			((UV) s[offset    ] << 56) +
			((UV) s[offset + 1] << 48);
		else if (offset + 3 >= srclen)
d808 4
a811 4
			((UV) s[offset    ] << 56) +
			((UV) s[offset + 1] << 48) +
			((UV) s[offset + 2] << 40);
		else if (offset + 4 >= srclen)
d813 5
a817 5
			((UV) s[offset    ] << 56) +
			((UV) s[offset + 1] << 48) +
			((UV) s[offset + 2] << 40) +
			((UV) s[offset + 3] << 32);
		else if (offset + 5 >= srclen)
d819 6
a824 6
			((UV) s[offset    ] << 56) +
			((UV) s[offset + 1] << 48) +
			((UV) s[offset + 2] << 40) +
			((UV) s[offset + 3] << 32) +
			(     s[offset + 4] << 24);
		else if (offset + 6 >= srclen)
d826 6
a831 6
			((UV) s[offset    ] << 56) +
			((UV) s[offset + 1] << 48) +
			((UV) s[offset + 2] << 40) +
			((UV) s[offset + 3] << 32) +
			((UV) s[offset + 4] << 24) +
			((UV) s[offset + 5] << 16);
d834 7
a840 7
			((UV) s[offset    ] << 56) +
			((UV) s[offset + 1] << 48) +
			((UV) s[offset + 2] << 40) +
			((UV) s[offset + 3] << 32) +
			((UV) s[offset + 4] << 24) +
			((UV) s[offset + 5] << 16) +
			(     s[offset + 6] <<  8);
d846 1
a846 1
	retnum = (s[offset >> 3] >> (offset & 7)) & ((1 << size) - 1);
a847 1
	offset >>= 3;	/* turn into byte offset */
d849 1
a849 1
	    retnum = s[offset];
d852 2
a853 2
		((UV) s[offset] <<      8) +
		      s[offset + 1];
d856 4
a859 4
		((UV) s[offset    ] << 24) +
		((UV) s[offset + 1] << 16) +
		(     s[offset + 2] <<  8) +
		      s[offset + 3];
d866 8
a873 8
		((UV) s[offset    ] << 56) +
		((UV) s[offset + 1] << 48) +
		((UV) s[offset + 2] << 40) +
		((UV) s[offset + 3] << 32) +
		((UV) s[offset + 4] << 24) +
		((UV) s[offset + 5] << 16) +
		(     s[offset + 6] <<  8) +
		      s[offset + 7];
d888 2
a889 2
    SV *targ = LvTARG(sv);
    register I32 offset;
d896 1
d918 8
a925 2
    offset *= size;			/* turn into bit offset */
    len = (offset + size + 7) / 8;	/* required number of bytes */
a933 1
	size = offset & 7;
d935 2
a936 3
	offset >>= 3;			/* turn into byte offset */
	s[offset] &= ~(mask << size);
	s[offset] |= lval << size;
a938 1
	offset >>= 3;			/* turn into byte offset */
d973 1
d979 1
a979 1
	AV* av = (AV*)sv;
d990 1
a990 1
        HV* hv = (HV*)sv;
d1017 2
a1018 2
	    char *send = s + len;
	    char *start = s;
d1049 1
d1054 1
a1054 1
    SV* svrecode = Nullsv;
d1185 1
d1196 2
a1197 2
    register I32 len;
    I32 lensave;
d1200 12
a1211 3
    const bool left_utf = DO_UTF8(left);
    const bool right_utf = DO_UTF8(right);
    I32 needlen = 0;
d1213 8
a1220 1
    if (left_utf && !right_utf)
d1222 5
a1226 1
    else if (!left_utf && right_utf)
d1228 3
a1231 4
    if (sv != left || (optype != OP_BIT_AND && !SvOK(sv) && !SvGMAGICAL(sv)))
	sv_setpvn(sv, "", 0);	/* avoid undef warning on |= and ^= */
    lsave = lc = SvPV_const(left, leftlen);
    rsave = rc = SvPV_const(right, rightlen);
d1234 2
d1241 3
a1243 5
	/* Fix this to nong when change 22613 is integrated.
	   (Which in turn awaits merging sv_2iv and sv_2uv)  */
	dc = SvPV_force_nolen(sv);
	if (SvLEN(sv) < (STRLEN)(len + 1)) {
	    dc = SvGROW(sv, (STRLEN)(len + 1));
d1250 2
a1251 2
	needlen = ((optype == OP_BIT_AND)
		    ? len : (leftlen > rightlen ? leftlen : rightlen));
d1253 1
a1253 1
	(void)sv_usepvn(sv, dc, needlen);
a1255 2
    SvCUR_set(sv, len);
    (void)SvPOK_only(sv);
d1258 2
a1259 1
	char *dcsave = dc;
d1277 2
a1278 2
		(void)sv_usepvn(sv, dcsave, needlen);
	    SvCUR_set(sv, dc - dcsave);
d1304 4
d1309 2
a1310 2
		(void)sv_usepvn(sv, dcsave, needlen);
	    SvCUR_set(sv, dc - dcsave);
d1312 1
a1312 1
		sv_catpvn(sv, rc, rulen);
d1314 1
a1314 1
		sv_catpvn(sv, lc, lulen);
d1317 1
d1319 5
d1331 3
a1333 3
	!((long)dc % sizeof(long)) &&
	!((long)lc % sizeof(long)) &&
	!((long)rc % sizeof(long)))	/* It's almost always aligned... */
d1335 1
a1335 1
	const I32 remainder = len % (sizeof(long)*4);
d1391 1
a1391 1
	    if (rightlen > (STRLEN)len)
d1407 1
d1409 1
a1409 1
    HV *hv = (HV*)POPs;
a1415 1
    I32 realhv = (SvTYPE(hv) == SVt_PVHV);
d1421 1
a1421 1
		LvTARG(TARG) = Nullsv;
d1427 1
a1427 1
    keys = realhv ? hv : avhv_keys((AV*)hv);
d1440 1
a1440 1
		sv_magic(TARG, Nullsv, PERL_MAGIC_nkeys, Nullch, 0);
d1446 1
a1446 1
		LvTARG(TARG) = SvREFCNT_inc(keys);
d1452 2
a1453 1
	if (! SvTIED_mg((SV*)keys, PERL_MAGIC_tied))
d1455 1
d1476 1
a1476 2
	    tmpstr = realhv ?
		     hv_iterval(hv,entry) : avhv_iterval((AV*)hv,entry);
@


1.10
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2004, by Larry Wall and others
d33 1
a33 1
    U8 *send;
d36 1
a36 1
    I32 grows = PL_op->op_private & OPpTRANS_GROWS;
a37 2
    short *tbl;
    I32 ch;
d39 1
a39 1
    tbl = (short*)cPVOP->op_pv;
d49 2
a50 1
	    if ((ch = tbl[*s]) >= 0) {
d63 1
a63 1
	New(0, d, len*2+1, U8);
d69 1
a69 1
        UV c;
d72 1
a72 1
	c = utf8n_to_uvchr(s, send - s, &ulen, 0);
d100 2
a101 2
    U8 *s;
    U8 *send;
d104 1
a104 2
    short *tbl;
    I32 complement = PL_op->op_private & OPpTRANS_COMPLEMENT;
d106 1
a106 1
    tbl = (short*)cPVOP->op_pv;
d110 1
a110 1
    s = (U8*)SvPV(sv, len);
a119 1
	    UV c;
d121 1
a121 1
	    c = utf8n_to_uvchr(s, send - s, &ulen, 0);
d142 3
a144 3
    I32 grows = PL_op->op_private & OPpTRANS_GROWS;
    I32 complement = PL_op->op_private & OPpTRANS_COMPLEMENT;
    I32 del = PL_op->op_private & OPpTRANS_DELETE;
a145 2
    short *tbl;
    I32 ch;
d147 1
a147 1
    tbl = (short*)cPVOP->op_pv;
d158 1
a158 1
	    U8* p = send;
d160 2
a161 1
		if ((ch = tbl[*s]) >= 0) {
d176 2
a177 1
	        if ((ch = tbl[*s]) >= 0) {
d193 1
a193 1
	    New(0, d, len*2+1, U8);
d208 2
a209 1
	        UV comp = utf8_to_uvchr(s, &len);
d253 2
a254 1
	        UV comp = utf8_to_uvchr(s, &len);
d306 1
a306 1
    I32 grows = PL_op->op_private & OPpTRANS_GROWS;
d309 2
a310 2
    SV* rv = (SV*)cSVOP->op_sv;
    HV* hv = (HV*)SvRV(rv);
d312 2
a313 2
    UV none = svp ? SvUV(*svp) : 0x7fffffff;
    UV extra = none + 1;
d322 1
a322 1
	U8 *t = s, *e = s + len;
d324 1
a324 1
	    U8 ch = *t++;
d340 1
a340 1
	New(0, d, len*3+UTF8_MAXLEN, U8);
d356 1
a356 1
	    int i = UTF8SKIP(s);
d362 1
a362 2
	    int i = UTF8SKIP(s);
	    s += i;
d370 2
a371 2
	    STRLEN clen = d - dstart;
	    STRLEN nlen = dend - dstart + len + UTF8_MAXLEN;
d374 1
a374 1
	    Renew(dstart, nlen+UTF8_MAXLEN, U8);
d398 2
a399 2
    U8 *s;
    U8 *start = 0, *send;
d403 5
a407 6
    SV* rv = (SV*)cSVOP->op_sv;
    HV* hv = (HV*)SvRV(rv);
    SV** svp = hv_fetch(hv, "NONE", 4, FALSE);
    UV none = svp ? SvUV(*svp) : 0x7fffffff;
    UV extra = none + 1;
    UV uv;
d410 1
a410 1
    s = (U8*)SvPV(sv, len);
d412 2
a413 1
	U8 *t = s, *e = s + len;
d415 1
a415 1
	    U8 ch = *t++;
d420 1
a420 1
	    start = s = bytes_to_utf8(s, &len);
d425 2
a426 1
	if ((uv = swash_fetch(rv, s, TRUE)) < none || uv == extra)
a438 1
    U8 *s;
d442 5
a446 5
    I32 squash   = PL_op->op_private & OPpTRANS_SQUASH;
    I32 del      = PL_op->op_private & OPpTRANS_DELETE;
    I32 grows    = PL_op->op_private & OPpTRANS_GROWS;
    SV* rv = (SV*)cSVOP->op_sv;
    HV* hv = (HV*)SvRV(rv);
d448 2
a449 2
    UV none = svp ? SvUV(*svp) : 0x7fffffff;
    UV extra = none + 1;
a451 1
    UV uv;
a453 1
    I32 isutf8;
d456 2
a457 2
    s = (U8*)SvPV(sv, len);
    isutf8 = SvUTF8(sv);
d459 2
a460 1
	U8 *t = s, *e = s + len;
d462 1
a462 1
	    U8 ch = *t++;
d480 1
a480 1
	New(0, d, len*3+UTF8_MAXLEN, U8);
d492 1
a492 1
	    uv = swash_fetch(rv, s, TRUE);
d495 2
a496 2
	        STRLEN clen = d - dstart;
		STRLEN nlen = dend - dstart + len + UTF8_MAXLEN;
d499 1
a499 1
		Renew(dstart, nlen+UTF8_MAXLEN, U8);
d513 1
a513 1
		int i = UTF8SKIP(s);
d547 1
a547 1
	    uv = swash_fetch(rv, s, TRUE);
d549 2
a550 2
	        STRLEN clen = d - dstart;
		STRLEN nlen = dend - dstart + len + UTF8_MAXLEN;
d553 1
a553 1
		Renew(dstart, nlen+UTF8_MAXLEN, U8);
d564 1
a564 1
		int i = UTF8SKIP(s);
d600 1
a600 1
    I32 hasutf = (PL_op->op_private &
d609 1
a609 1
    (void)SvPV(sv, len);
d647 1
a647 1
    SV **oldmark = mark;
a650 1
    STRLEN tmplen;
d652 1
a652 1
    (void) SvPV(del, delimlen); /* stringify and get the delimlen */
d661 2
a662 1
		SvPV(*mark, tmplen);
d676 1
a676 2
    if (SvUTF8(sv))
	SvUTF8_off(sv);
d704 1
a704 1
    char *pat = SvPV(*sarg, patlen);
d721 1
a721 1
    unsigned char *s = (unsigned char *) SvPV(sv, srclen);
a943 1
        I32 max;
d945 3
a947 2
        max = AvFILL(av);
        for (i = 0; i <= max; i++) {
a957 1
        /*SUPPRESS 560*/
d970 7
d987 1
a987 1
	    if (utf8_to_uvchr((U8*)s, 0)) {
a1015 1
    STRLEN n_a;
d1027 4
a1030 4
        I32 max;
	AV* av = (AV*)sv;
        max = AvFILL(av);
        for (i = 0; i <= max; i++) {
d1038 1
a1038 1
        HV* hv = (HV*)sv;
a1040 1
        /*SUPPRESS 560*/
d1080 1
a1080 1
	    char *rsptr = SvPV(PL_rs, rslen);
d1107 1
a1107 1
		   rsptr = SvPV(svrecode, rslen);
d1131 1
a1131 1
	s = SvPV_force(sv, n_a);
d1157 2
a1158 2
    register char *lc;
    register char *rc;
d1161 4
a1164 4
    char *lsave;
    char *rsave;
    bool left_utf = DO_UTF8(left);
    bool right_utf = DO_UTF8(right);
d1174 2
a1175 2
    lsave = lc = SvPV(left, leftlen);
    rsave = rc = SvPV(right, rightlen);
d1180 1
a1180 1
	Newz(801, dc, needlen + 1, char);
d1183 4
a1186 3
	STRLEN n_a;
	dc = SvPV_force(sv, n_a);
	if (SvCUR(sv) < (STRLEN)len) {
d1196 1
a1196 1
	Newz(801, dc, needlen + 1, char);
d1270 1
a1270 1
	I32 remainder = len % (sizeof(long)*4);
d1315 1
d1346 4
a1349 4
    SV *tmpstr;
    I32 gimme = GIMME_V;
    I32 dokeys =   (PL_op->op_type == OP_KEYS);
    I32 dovalues = (PL_op->op_type == OP_VALUES);
a1351 3
    if (PL_op->op_type == OP_RV2HV || PL_op->op_type == OP_PADHV)
	dokeys = dovalues = TRUE;

a1390 1
	    /*SUPPRESS 560*/
d1403 1
a1403 1
	    SV* sv = hv_iterkeysv(entry);
d1407 1
d1413 1
a1413 1
			    HvMAX(keys)+1,
d1423 9
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d15 5
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, by Larry Wall and others
d618 3
a620 1
    switch (PL_op->op_private & ~hasutf & 63) {
d672 1
a672 1
    sv_setpv(sv, "");
d1011 2
d1048 12
d1074 1
a1074 1
	    STRLEN rslen;
d1076 35
d1123 1
a1123 1
		count += rslen;
d1133 5
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@a19 1
#if !defined(NSIG) || defined(M_UNIX) || defined(M_XENIX)
a21 1
#endif
d671 4
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d45 1
a45 1
    /* First, take care of non-UTF8 input strings, because they're easy */
d77 1
a77 1
	    Copy(s, d, ulen, U8);
d255 1
a255 1
			Copy(s, d, len, U8);
d355 1
a355 1
	    Copy(s, d, i, U8);
d514 1
a514 1
		Copy(s, d, i, U8);
d533 1
a533 1
			Copy(s, d, len, U8);
d565 1
a565 1
		Copy(s, d, i, U8);
d612 3
a614 3
    if (!SvPOKp(sv))
	(void)SvPV_force(sv, len);
    if (!(PL_op->op_private & OPpTRANS_IDENTICAL))
d616 1
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d18 1
d22 1
d39 1
a39 1
	Perl_croak(aTHX_ "panic: do_trans_simple");
d49 1
a49 1
		*s++ = ch;
d69 1
a69 1
	c = utf8_to_uv(s, send - s, &ulen, 0);
d72 1
a72 4
            if (UTF8_IS_ASCII(ch))
                *d++ = ch;
            else
                d = uv_to_utf8(d,ch);
d95 1
a95 1
S_do_trans_count(pTHX_ SV *sv)/* SPC - OK */
d102 1
d106 1
a106 1
	Perl_croak(aTHX_ "panic: do_trans_count");
d120 5
a124 2
	    c = utf8_to_uv(s, send - s, &ulen, 0);
	    if (c < 0x100 && tbl[c] >= 0)
d133 1
a133 1
S_do_trans_complex(pTHX_ SV *sv)/* SPC - NOT OK */
d142 3
a144 1
    STRLEN len;
d150 1
a150 1
	Perl_croak(aTHX_ "panic: do_trans_complex");
d162 1
a162 1
		    *d = ch;
d178 1
a178 1
		    *d++ = ch;
d196 2
a203 1
	    U8* p = send;
d207 1
a207 1
	        UV comp = utf8_to_uv_simple(s, &len);
d209 19
a227 3
		if (comp > 0xff) {	/* always unmapped */	
		    Copy(s, d, len, U8);
		    d += len;
d231 3
a233 3
		    if (ch != pch) {
		        d = uv_to_utf8(d, ch);
		        pch = ch;
d251 15
a265 4
	        UV comp = utf8_to_uv_simple(s, &len);
		if (comp > 0xff) {	/* always unmapped */
		    Copy(s, d, len, U8);
		    d += len;
d268 1
a268 1
		    d = uv_to_utf8(d, ch);
d295 1
a295 1
S_do_trans_simple_utf8(pTHX_ SV *sv)/* SPC - OK */
d311 1
a311 1
    UV final;
d320 3
a322 2
	while (t < e)
	    if ((hibit = UTF8_IS_CONTINUED(*t++)))
d324 1
d347 1
a347 1
	if ((uv = swash_fetch(rv, s)) < none) {
d350 1
a350 1
	    d = uv_to_utf8(d, uv);
d362 1
a362 1
	    d = uv_to_utf8(d, final);
d371 1
a371 1
		Perl_croak(aTHX_ "panic: do_trans_complex_utf8");
a388 2
    if (!isutf8 && !(PL_hints & HINT_UTF8))
	sv_utf8_downgrade(sv, TRUE);
d394 1
a394 1
S_do_trans_count_utf8(pTHX_ SV *sv)/* SPC - OK */
d397 1
a397 1
    U8 *start, *send;
d405 1
d412 3
a414 2
	while (t < e)
	    if ((hibit = !UTF8_IS_ASCII(*t++)))
d416 1
d423 1
a423 1
	if ((uv = swash_fetch(rv, s)) < none)
d434 1
a434 1
S_do_trans_complex_utf8(pTHX_ SV *sv) /* SPC - NOT OK */
d448 2
a449 1
    UV final;
d460 3
a462 2
	while (t < e)
	    if ((hibit = !UTF8_IS_ASCII(*t++)))
d464 1
d472 1
a472 1
    if (svp)
d474 2
d491 2
a492 2
	    uv = swash_fetch(rv, s);
	    
d497 1
a497 1
		    Perl_croak(aTHX_ "panic: do_trans_complex_utf8");
d504 1
d506 1
a506 1
		    d = uv_to_utf8(d, uv);
a508 1
		s += UTF8SKIP(s);
d521 16
a536 3
		if (uv != puv) {
		    d = uv_to_utf8(d, final);
		    puv = final;
a537 1
		s += UTF8SKIP(s);
d546 1
a546 1
	    uv = swash_fetch(rv, s);
d551 1
a551 1
		    Perl_croak(aTHX_ "panic: do_trans_complex_utf8");
a557 1
		d = uv_to_utf8(d, uv);
d559 1
a570 1
		d = uv_to_utf8(d, final);
d572 1
a589 2
    if (!isutf8 && !(PL_hints & HINT_UTF8))
	sv_utf8_downgrade(sv, TRUE);
d602 6
a607 3
    if (SvREADONLY(sv) && !(PL_op->op_private & OPpTRANS_IDENTICAL))
	Perl_croak(aTHX_ PL_no_modify);

d626 1
a646 1
    register char *delim = SvPV(del, delimlen);
d649 3
d670 4
a674 1
	sv_setpv(sv, "");
d679 1
a679 2
    else
	sv_setpv(sv,"");
d700 3
d733 1
a733 1
		if (offset >= srclen)
d739 1
a739 1
		if (offset >= srclen)
d741 1
a741 1
		else if (offset + 1 >= srclen)
d744 1
a744 1
		else if (offset + 2 >= srclen)
d757 1
a757 1
		    Perl_warner(aTHX_ WARN_PORTABLE,
d826 1
a826 1
		Perl_warner(aTHX_ WARN_PORTABLE,
d875 1
a875 1
	Perl_croak(aTHX_ "Assigning to negative offset in vec");
d884 1
a884 1
	(void)memzero(s + targlen, len - targlen + 1);
d899 1
a899 1
	    s[offset  ] = lval         & 0xff;
d901 2
a902 2
	    s[offset  ] = (lval >>  8) & 0xff;
	    s[offset+1] = lval         & 0xff;
d905 4
a908 4
	    s[offset  ] = (lval >> 24) & 0xff;
	    s[offset+1] = (lval >> 16) & 0xff;
	    s[offset+2] = (lval >>  8) & 0xff;
	    s[offset+3] =  lval        & 0xff;
d913 1
a913 1
		Perl_warner(aTHX_ WARN_PORTABLE,
d915 8
a922 8
	    s[offset  ] = (lval >> 56) & 0xff;
	    s[offset+1] = (lval >> 48) & 0xff;
	    s[offset+2] = (lval >> 40) & 0xff;
	    s[offset+3] = (lval >> 32) & 0xff;
	    s[offset+4] = (lval >> 24) & 0xff;
	    s[offset+5] = (lval >> 16) & 0xff;
	    s[offset+6] = (lval >>  8) & 0xff;
	    s[offset+7] =  lval        & 0xff;
d956 8
a963 2
    else if (SvREADONLY(sv))
	Perl_croak(aTHX_ PL_no_modify);
d974 1
a974 1
	    if (utf8_to_uv_simple((U8*)s, 0)) {
d1003 1
d1032 8
a1039 2
    else if (SvREADONLY(sv))
	Perl_croak(aTHX_ PL_no_modify);
a1040 2
    if (len && !SvPOKp(sv))
	s = SvPV_force(sv, len);
d1071 1
a1071 1
	*s = '\0';
d1073 1
d1075 1
a1077 1
    SvSETMAGIC(sv);
d1100 1
a1100 1
    I32 needlen;
d1120 2
a1121 2
	if (SvCUR(sv) < len) {
	    dc = SvGROW(sv, len + 1);
d1146 1
a1146 1
		luc = utf8_to_uv((U8*)lc, lulen, &ulen, UTF8_ALLOW_ANYUV);
d1149 1
a1149 1
		ruc = utf8_to_uv((U8*)rc, rulen, &ulen, UTF8_ALLOW_ANYUV);
d1153 1
a1153 1
		dc = (char*)uv_to_utf8((U8*)dc, duc);
d1161 1
a1161 1
		luc = utf8_to_uv((U8*)lc, lulen, &ulen, UTF8_ALLOW_ANYUV);
d1164 1
a1164 1
		ruc = utf8_to_uv((U8*)rc, rulen, &ulen, UTF8_ALLOW_ANYUV);
d1168 1
a1168 1
		dc = (char*)uv_to_utf8((U8*)dc, duc);
d1173 1
a1173 1
		luc = utf8_to_uv((U8*)lc, lulen, &ulen, UTF8_ALLOW_ANYUV);
d1176 1
a1176 1
		ruc = utf8_to_uv((U8*)rc, rulen, &ulen, UTF8_ALLOW_ANYUV);
d1180 1
a1180 1
		dc = (char*)uv_to_utf8((U8*)dc, duc);
d1259 1
a1259 1
	    if (rightlen > len)
d1261 1
a1261 1
	    else if (leftlen > len)
d1311 1
a1311 1
		sv_magic(TARG, Nullsv, 'k', Nullch, 0);
d1323 1
a1323 1
	if (! SvTIED_mg((SV*)keys, 'P'))
d1339 4
a1342 2
	if (dokeys)
	    XPUSHs(hv_iterkeysv(entry));	/* won't clobber stack_sp */
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d23 1
a23 1
S_do_trans_CC_simple(pTHX_ SV *sv)
a24 1
    dTHR;
d26 1
d28 1
d30 1
d37 1
a37 1
	Perl_croak(aTHX_ "panic: do_trans");
d42 20
d63 26
a88 5
	if ((ch = tbl[*s]) >= 0) {
	    matches++;
	    *s = ch;
	}
	s++;
d90 1
a91 1

d96 1
a96 1
S_do_trans_CC_count(pTHX_ SV *sv)
a97 1
    dTHR;
d106 1
a106 1
	Perl_croak(aTHX_ "panic: do_trans");
d111 14
a124 5
    while (s < send) {
	if (tbl[*s] >= 0)
	    matches++;
	s++;
    }
d130 1
a130 1
S_do_trans_CC_complex(pTHX_ SV *sv)
a131 1
    dTHR;
d135 2
d138 1
d145 1
a145 1
	Perl_croak(aTHX_ "panic: do_trans");
d148 1
d151 16
a166 12
    d = s;
    if (PL_op->op_private & OPpTRANS_SQUASH) {
	U8* p = send;

	while (s < send) {
	    if ((ch = tbl[*s]) >= 0) {
		*d = ch;
		matches++;
		if (p == d - 1 && *p == *d)
		    matches--;
		else
		    p = d++;
a167 3
	    else if (ch == -1)		/* -1 is unmapped character */
		*d++ = *s;		/* -2 is delete character */
	    s++;
d169 11
a179 7
    }
    else {
	while (s < send) {
	    if ((ch = tbl[*s]) >= 0) {
		*d = ch;
		matches++;
		d++;
a180 3
	    else if (ch == -1)		/* -1 is unmapped character */
		*d++ = *s;		/* -2 is delete character */
	    s++;
d182 2
d185 6
a190 4
    matches += send - d;	/* account for disappeared chars */
    *d = '\0';
    SvCUR_set(sv, d - (U8*)SvPVX(sv));
    SvSETMAGIC(sv);
d192 3
a194 2
    return matches;
}
d196 50
a245 31
STATIC I32
S_do_trans_UU_simple(pTHX_ SV *sv)
{
    dTHR;
    U8 *s;
    U8 *send;
    U8 *d;
    I32 matches = 0;
    STRLEN len;

    SV* rv = (SV*)cSVOP->op_sv;
    HV* hv = (HV*)SvRV(rv);
    SV** svp = hv_fetch(hv, "NONE", 4, FALSE);
    UV none = svp ? SvUV(*svp) : 0x7fffffff;
    UV extra = none + 1;
    UV final;
    UV uv;

    s = (U8*)SvPV(sv, len);
    send = s + len;

    svp = hv_fetch(hv, "FINAL", 5, FALSE);
    if (svp)
	final = SvUV(*svp);

    d = s;
    while (s < send) {
	if ((uv = swash_fetch(rv, s)) < none) {
	    s += UTF8SKIP(s);
	    matches++;
	    d = uv_to_utf8(d, uv);
d247 3
a249 4
	else if (uv == none) {
	    int i;
	    for (i = UTF8SKIP(s); i; i--)
		*d++ = *s++;
d251 3
a253 4
	else if (uv == extra) {
	    s += UTF8SKIP(s);
	    matches++;
	    d = uv_to_utf8(d, final);
d255 1
a255 2
	else
	    s += UTF8SKIP(s);
a256 2
    *d = '\0';
    SvCUR_set(sv, d - (U8*)SvPVX(sv));
a257 28

    return matches;
}

STATIC I32
S_do_trans_UU_count(pTHX_ SV *sv)
{
    dTHR;
    U8 *s;
    U8 *send;
    I32 matches = 0;
    STRLEN len;

    SV* rv = (SV*)cSVOP->op_sv;
    HV* hv = (HV*)SvRV(rv);
    SV** svp = hv_fetch(hv, "NONE", 4, FALSE);
    UV none = svp ? SvUV(*svp) : 0x7fffffff;
    UV uv;

    s = (U8*)SvPV(sv, len);
    send = s + len;

    while (s < send) {
	if ((uv = swash_fetch(rv, s)) < none)
	    matches++;
	s += UTF8SKIP(s);
    }

d262 1
a262 1
S_do_trans_UC_simple(pTHX_ SV *sv)
a263 1
    dTHR;
d267 2
d270 1
d280 2
d284 9
d294 1
d300 11
a310 1
    d = s;
d315 1
a315 1
	    *d++ = (U8)uv;
d318 4
a321 4
	    I32 ulen;
	    uv = utf8_to_uv(s, &ulen);
	    s += ulen;
	    *d++ = (U8)uv;
d324 2
a325 1
	    s += UTF8SKIP(s);
d327 1
a327 1
	    *d++ = (U8)final;
d331 20
a351 2
    *d = '\0';
    SvCUR_set(sv, d - (U8*)SvPVX(sv));
d353 3
d361 1
a361 1
S_do_trans_CU_simple(pTHX_ SV *sv)
a362 1
    dTHR;
d364 1
a364 3
    U8 *send;
    U8 *d;
    U8 *dst;
a371 2
    UV extra = none + 1;
    UV final;
d373 1
a373 2
    U8 tmpbuf[UTF8_MAXLEN];
    I32 bits = 16;
d376 8
a385 11
    svp = hv_fetch(hv, "BITS", 4, FALSE);
    if (svp)
	bits = (I32)SvIV(*svp);

    svp = hv_fetch(hv, "FINAL", 5, FALSE);
    if (svp)
	final = SvUV(*svp);

    Newz(801, d, len * (bits >> 3) + 1, U8);
    dst = d;

d387 1
a387 9
	uv = *s++;
	if (uv < 0x80)
	    tmpbuf[0] = uv;
	else {
	    tmpbuf[0] = (( uv >>  6)         | 0xc0);
	    tmpbuf[1] = (( uv        & 0x3f) | 0x80);
	}

	if ((uv = swash_fetch(rv, tmpbuf)) < none) {
d389 1
a389 76
	    d = uv_to_utf8(d, uv);
	}
	else if (uv == none)
	    d = uv_to_utf8(d, s[-1]);
	else if (uv == extra) {
	    matches++;
	    d = uv_to_utf8(d, final);
	}
    }
    *d = '\0';
    sv_usepvn_mg(sv, (char*)dst, d - dst);

    return matches;
}

/* utf-8 to latin-1 */

STATIC I32
S_do_trans_UC_trivial(pTHX_ SV *sv)
{
    dTHR;
    U8 *s;
    U8 *send;
    U8 *d;
    STRLEN len;

    s = (U8*)SvPV(sv, len);
    send = s + len;

    d = s;
    while (s < send) {
	if (*s < 0x80)
	    *d++ = *s++;
	else {
	    I32 ulen;
	    UV uv = utf8_to_uv(s, &ulen);
	    s += ulen;
	    *d++ = (U8)uv;
	}
    }
    *d = '\0';
    SvCUR_set(sv, d - (U8*)SvPVX(sv));
    SvSETMAGIC(sv);

    return SvCUR(sv);
}

/* latin-1 to utf-8 */

STATIC I32
S_do_trans_CU_trivial(pTHX_ SV *sv)
{
    dTHR;
    U8 *s;
    U8 *send;
    U8 *d;
    U8 *dst;
    I32 matches;
    STRLEN len;

    s = (U8*)SvPV(sv, len);
    send = s + len;

    Newz(801, d, len * 2 + 1, U8);
    dst = d;

    matches = send - s;

    while (s < send) {
	if (*s < 0x80)
	    *d++ = *s++;
	else {
	    UV uv = *s++;
	    *d++ = (( uv >>  6)         | 0xc0);
	    *d++ = (( uv        & 0x3f) | 0x80);
	}
d391 2
a392 2
    *d = '\0';
    sv_usepvn_mg(sv, (char*)dst, d - dst);
d398 1
a398 1
S_do_trans_UU_complex(pTHX_ SV *sv)
a399 1
    dTHR;
d401 1
a401 1
    U8 *send;
a404 2
    I32 from_utf = PL_op->op_private & OPpTRANS_FROM_UTF;
    I32 to_utf   = PL_op->op_private & OPpTRANS_TO_UTF;
d406 1
d415 3
a417 1
    U8 *dst;
d420 9
d430 1
d436 5
a440 9
    if (PL_op->op_private & OPpTRANS_GROWS) {
	I32 bits = 16;

	svp = hv_fetch(hv, "BITS", 4, FALSE);
	if (svp)
	    bits = (I32)SvIV(*svp);

	Newz(801, d, len * (bits >> 3) + 1, U8);
	dst = d;
d443 2
a444 2
	d = s;
	dst = 0;
d450 10
a459 13
	    if (from_utf) {
		uv = swash_fetch(rv, s);
	    }
	    else {
		U8 tmpbuf[2];
		uv = *s++;
		if (uv < 0x80)
		    tmpbuf[0] = uv;
		else {
		    tmpbuf[0] = (( uv >>  6)         | 0xc0);
		    tmpbuf[1] = (( uv        & 0x3f) | 0x80);
		}
		uv = swash_fetch(rv, tmpbuf);
d464 1
a464 4
		    if (uv >= 0x80 && to_utf)
			d = uv_to_utf8(d, uv);
		    else
			*d++ = (U8)uv;
d467 1
a467 2
		if (from_utf)
		    s += UTF8SKIP(s);
d471 4
a474 17
		if (from_utf) {
		    if (*s < 0x80)
			*d++ = *s++;
		    else if (to_utf) {
			int i;
			for (i = UTF8SKIP(s); i; --i)
			    *d++ = *s++;
		    }
		    else {
			I32 ulen;
			*d++ = (U8)utf8_to_uv(s, &ulen);
			s += ulen;
		    }
		}
		else {	/* must be to_utf only */
		    d = uv_to_utf8(d, s[-1]);
		}
d481 1
a481 4
		    if (final >= 0x80 && to_utf)
			d = uv_to_utf8(d, final);
		    else
			*d++ = (U8)final;
d484 1
a484 2
		if (from_utf)
		    s += UTF8SKIP(s);
d487 2
a488 3
	    matches++;		/* "none+1" is delete character */
	    if (from_utf)
		s += UTF8SKIP(s);
d493 9
a501 13
	    if (from_utf) {
		uv = swash_fetch(rv, s);
	    }
	    else {
		U8 tmpbuf[2];
		uv = *s++;
		if (uv < 0x80)
		    tmpbuf[0] = uv;
		else {
		    tmpbuf[0] = (( uv >>  6)         | 0xc0);
		    tmpbuf[1] = (( uv        & 0x3f) | 0x80);
		}
		uv = swash_fetch(rv, tmpbuf);
d505 2
a506 6
		if (uv >= 0x80 && to_utf)
		    d = uv_to_utf8(d, uv);
		else
		    *d++ = (U8)uv;
		if (from_utf)
		    s += UTF8SKIP(s);
d510 4
a513 17
		if (from_utf) {
		    if (*s < 0x80)
			*d++ = *s++;
		    else if (to_utf) {
			int i;
			for (i = UTF8SKIP(s); i; --i)
			    *d++ = *s++;
		    }
		    else {
			I32 ulen;
			*d++ = (U8)utf8_to_uv(s, &ulen);
			s += ulen;
		    }
		}
		else {	/* must be to_utf only */
		    d = uv_to_utf8(d, s[-1]);
		}
d518 2
a519 6
		if (final >= 0x80 && to_utf)
		    d = uv_to_utf8(d, final);
		else
		    *d++ = (U8)final;
		if (from_utf)
		    s += UTF8SKIP(s);
d522 2
a523 3
	    matches++;		/* "none+1" is delete character */
	    if (from_utf)
		s += UTF8SKIP(s);
d526 6
a531 2
    if (dst)
	sv_usepvn(sv, (char*)dst, d - dst);
d534 1
a534 1
	SvCUR_set(sv, d - (U8*)SvPVX(sv));
d536 3
a546 1
    dTHR;
d548 2
d559 2
a560 1
    (void)SvPOK_only(sv);
d564 1
a564 1
    switch (PL_op->op_private & 63) {
d566 4
a569 10
	return do_trans_CC_simple(sv);

    case OPpTRANS_FROM_UTF:
	return do_trans_UC_simple(sv);

    case OPpTRANS_TO_UTF:
	return do_trans_CU_simple(sv);

    case OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF:
	return do_trans_UU_simple(sv);
d572 4
a575 10
	return do_trans_CC_count(sv);

    case OPpTRANS_FROM_UTF|OPpTRANS_IDENTICAL:
	return do_trans_UC_trivial(sv);

    case OPpTRANS_TO_UTF|OPpTRANS_IDENTICAL:
	return do_trans_CU_trivial(sv);

    case OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF|OPpTRANS_IDENTICAL:
	return do_trans_UU_count(sv);
d578 2
a579 2
	if (PL_op->op_private & (OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF))
	    return do_trans_UU_complex(sv); /* could be UC or CU too */
d581 1
a581 1
	    return do_trans_CC_complex(sv);
d600 1
a600 1
	    if (*mark && !SvGMAGICAL(*mark) && SvOK(*mark)) {
d614 3
a616 8
	char *s;

	if (*mark) {
	    s = SvPV(*mark, tmplen);
	    sv_setpvn(sv, s, tmplen);
	}
	else
	    sv_setpv(sv, "");
d621 1
a621 2
    len = delimlen;
    if (len) {
d623 1
a623 1
	    sv_catpvn(sv,delim,len);
d647 1
d657 1
a657 1
    if (size < 1 || (size & (size-1))) /* size < 1 or not a power of two */ 
d659 4
a693 1
		dTHR;
d733 1
a733 1
		    retnum = 
a762 1
	    dTHR;
d782 4
d801 9
d812 2
d815 1
a815 1
    if (size < 1 || (size & (size-1))) /* size < 1 or not a power of two */ 
d817 1
a817 1
    
d825 1
a825 1
    
a849 1
	    dTHR;
d872 1
a872 2
    dTHR;
    
d904 9
a912 9
	    while ((*s & 0xc0) == 0x80)
		--s;
	    if (UTF8SKIP(s) != send - s && ckWARN_d(WARN_UTF8))
		Perl_warner(aTHX_ WARN_UTF8, "Malformed UTF-8 character");
	    sv_setpvn(astr, s, send - s);
	    *s = '\0';
	    SvCUR_set(sv, s - start);
	    SvNIOK_off(sv);
	    SvUTF8_on(astr);
a932 1
    dTHR;
d1005 1
a1005 1
} 
a1009 1
    dTHR;	/* just for taint */
d1026 1
d1030 1
a1030 1
    if (!left_utf && right_utf)
d1039 5
a1043 1
    if (SvOK(sv) || SvTYPE(sv) > SVt_PVMG) {
d1050 2
d1054 2
a1055 2
	I32 needlen = ((optype == OP_BIT_AND)
			? len : (leftlen > rightlen ? leftlen : rightlen));
d1064 1
d1067 1
a1067 5
	STRLEN dulen = 0;
	I32 ulen;

	if (optype != OP_BIT_AND)
	    dc = SvGROW(sv, leftlen+rightlen+1);
d1072 1
a1072 1
		luc = utf8_to_uv((U8*)lc, &ulen);
d1075 1
a1075 1
		ruc = utf8_to_uv((U8*)rc, &ulen);
d1081 3
a1083 2
	    dulen = dc - SvPVX(sv);
	    SvCUR_set(sv, dulen);
d1087 1
a1087 1
		luc = utf8_to_uv((U8*)lc, &ulen);
d1090 1
a1090 1
		ruc = utf8_to_uv((U8*)rc, &ulen);
d1099 1
a1099 1
		luc = utf8_to_uv((U8*)lc, &ulen);
d1102 1
a1102 1
		ruc = utf8_to_uv((U8*)rc, &ulen);
d1109 3
a1111 2
	    dulen = dc - SvPVX(sv);
	    SvCUR_set(sv, dulen);
d1201 1
a1201 1
    djSP;
d1210 2
a1211 2
    
    if (PL_op->op_type == OP_RV2HV || PL_op->op_type == OP_PADHV) 
d1215 1
a1215 1
	if (PL_op->op_flags & OPf_MOD) {	/* lvalue */
d1234 1
a1234 1
	if (PL_op->op_flags & OPf_MOD) {	/* lvalue */
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d15 1
d22 58
a79 2
I32
do_trans(SV *sv, OP *arg)
d82 4
a85 8
    register short *tbl;
    register U8 *s;
    register U8 *send;
    register U8 *d;
    register I32 ch;
    register I32 matches = 0;
    register I32 squash = PL_op->op_private & OPpTRANS_SQUASH;
    register U8 *p;
d87 2
a89 2
    if (SvREADONLY(sv) && !(PL_op->op_private & OPpTRANS_COUNTONLY))
	croak(no_modify);
d91 3
a94 5
    if (!len)
	return 0;
    if (!SvPOKp(sv))
	s = (U8*)SvPV_force(sv, len);
    (void)SvPOK_only(sv);
d96 5
a100 4
    if (!tbl || !s)
	croak("panic: do_trans");
    DEBUG_t( deb("2.TBL\n"));
    if (!PL_op->op_private) {
d103 1
d105 4
a108 1
		*s = ch;
d110 2
a113 1
	SvSETMAGIC(sv);
d115 1
a115 1
    else if (PL_op->op_private & OPpTRANS_COUNTONLY) {
d117 2
a118 1
	    if (tbl[*s] >= 0)
d120 4
d127 308
d437 5
a441 1
	p = send;
d443 49
a491 2
	    if ((ch = tbl[*s]) >= 0) {
		*d = ch;
d493 3
a495 3
		if (squash) {
		    if (p == d - 1 && *p == *d)
			matches--;
d497 2
a498 1
		        p = d++;
d500 29
d530 4
a533 1
		    d++;
d535 33
a567 3
	    else if (ch == -1)		/* -1 is unmapped character */
		*d++ = *s;		/* -2 is delete character */
	    s++;
d569 4
a572 1
	matches += send - d;	/* account for disappeared chars */
a574 1
	SvSETMAGIC(sv);
d576 2
d581 51
d633 1
a633 1
do_join(register SV *sv, SV *del, register SV **mark, register SV **sp)
d644 1
a644 2
    if (SvTYPE(sv) < SVt_PV)
	sv_upgrade(sv, SVt_PV);
d656 1
a656 1
	items = sp - mark;;
d688 1
a688 1
do_sprintf(SV *sv, I32 len, SV **sarg)
d700 132
d833 1
a833 1
do_vecset(SV *sv)
d839 1
a839 1
    register unsigned long lval;
d847 1
a847 1
    lval = U_L(SvNV(sv));
d850 2
d853 2
a854 1
    len = (offset + size + 7) / 8;
d865 1
a865 1
	offset >>= 3;
d870 1
a870 1
	offset >>= 3;
d872 1
a872 1
	    s[offset] = lval & 255;
d874 2
a875 2
	    s[offset] = (lval >> 8) & 255;
	    s[offset+1] = lval & 255;
d878 19
a896 4
	    s[offset] = (lval >> 24) & 255;
	    s[offset+1] = (lval >> 16) & 255;
	    s[offset+2] = (lval >> 8) & 255;
	    s[offset+3] = lval & 255;
d898 1
d900 1
d904 1
a904 1
do_chop(register SV *astr, register SV *sv)
d908 1
d922 1
a922 1
    if (SvTYPE(sv) == SVt_PVHV) {
d927 1
a927 1
        while (entry = hv_iternext(hv))
d931 2
d936 19
a954 1
    if (s && len) {
d959 1
d965 1
a965 1
} 
d968 1
a968 1
do_chomp(register SV *sv)
d977 2
d992 1
a992 1
    if (SvTYPE(sv) == SVt_PVHV) {
d997 1
a997 1
        while (entry = hv_iternext(hv))
d1001 2
d1046 1
a1046 1
do_vop(I32 optype, SV *sv, SV *left, SV *right)
d1063 7
d1094 63
d1227 1
d1232 1
a1232 1
do_kv(ARGSproto)
d1296 1
a1296 1
    while (entry = hv_iternext(keys)) {
a1300 1
	    tmpstr = sv_newmortal();
d1302 3
a1304 3
	    sv_setsv(tmpstr,realhv ?
		     hv_iterval(hv,entry) : avhv_iterval((AV*)hv,entry));
	    DEBUG_H(sv_setpvf(tmpstr, "%lu%%%d=%lu",
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d22 1
a22 3
do_trans(sv,arg)
SV *sv;
OP *arg;
d24 1
d31 2
a32 1
    register I32 squash = op->op_private & OPpTRANS_SQUASH;
d35 1
a35 1
    if (SvREADONLY(sv))
d48 1
a48 1
    if (!op->op_private) {
d56 8
d67 1
d71 3
a73 2
		if (matches++ && squash) {
		    if (d[-1] == *d)
d76 1
a76 1
			d++;
d88 1
a89 1
    SvSETMAGIC(sv);
d94 1
a94 5
do_join(sv,del,mark,sp)
register SV *sv;
SV *del;
register SV **mark;
register SV **sp;
d109 1
a109 1
	    if (*mark) {
d150 1
a150 4
do_sprintf(sv,len,sarg)
SV *sv;
I32 len;
SV **sarg;
d163 1
a163 2
do_vecset(sv)
SV *sv;
d214 1
a214 3
do_chop(astr,sv)
register SV *astr;
register SV *sv;
d226 1
a226 1
	    if (sv && ((sv = *(SV**)sv), sv != &sv_undef))
d256 1
a256 2
do_chomp(sv)
register SV *sv;
d258 1
d263 1
a263 1
    if (RsSNARF(rs))
d273 1
a273 1
	    if (sv && ((sv = *(SV**)sv), sv != &sv_undef))
d292 1
a292 1
	if (RsPARA(rs)) {
d304 1
a304 1
	    char *rsptr = SvPV(rs, rslen);
d330 1
a330 5
do_vop(optype,sv,left,right)
I32 optype;
SV *sv;
SV *left;
SV *right;
d332 1
d355 2
a356 1
	dc = SvPV_force(sv, na);
d445 1
a445 2
do_kv(ARGS)
dARGS
d447 1
a447 1
    dSP;
d449 1
d453 5
a457 4
    I32 dokeys =   (op->op_type == OP_KEYS);
    I32 dovalues = (op->op_type == OP_VALUES);

    if (op->op_type == OP_RV2HV || op->op_type == OP_PADHV) 
d461 1
a461 1
	if (op->op_flags & OPf_MOD) {	/* lvalue */
d470 2
a471 1
    (void)hv_iterinit(hv);	/* always reset iterator regardless */
d477 1
a477 1
	I32 i;
d480 1
a480 1
	if (op->op_flags & OPf_MOD) {	/* lvalue */
d486 5
a490 1
	    LvTARG(TARG) = (SV*)hv;
d495 2
a496 2
	if (!SvRMAGICAL(hv) || !mg_find((SV*)hv,'P'))
	    i = HvKEYS(hv);
d500 1
a500 3
	    while (entry = hv_iternext(hv)) {
		i++;
	    }
d506 1
a506 2
    /* Guess how much room we need.  hv_max may be a few too many.  Oh well. */
    EXTEND(sp, HvMAX(hv) * (dokeys + dovalues));
d509 1
a509 1
    while (entry = hv_iternext(hv)) {
d516 2
a517 1
	    sv_setsv(tmpstr,hv_iterval(hv,entry));
d520 2
a521 2
			    HvMAX(hv)+1,
			    (unsigned long)(HeHASH(entry) & HvMAX(hv))));
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
a20 8
#ifdef BUGGY_MSC
 #pragma function(memcmp)
#endif /* BUGGY_MSC */

#ifdef BUGGY_MSC
 #pragma intrinsic(memcmp)
#endif /* BUGGY_MSC */

d145 3
a147 3
register SV *sv;
register I32 len;
register SV **sarg;
d149 5
a153 185
    register char *s;
    register char *t;
    register char *f;
    bool dolong;
#ifdef HAS_QUAD
    bool doquad;
#endif /* HAS_QUAD */
    char ch;
    register char *send;
    register SV *arg;
    char *xs;
    I32 xlen;
    I32 pre;
    I32 post;
    double value;
    STRLEN arglen;

    sv_setpv(sv,"");
    len--;			/* don't count pattern string */
    t = s = SvPV(*sarg, arglen);	/* XXX Don't know t is writeable */
    send = s + arglen;
    sarg++;
    for ( ; ; len--) {

	/*SUPPRESS 560*/
	if (len <= 0 || !(arg = *sarg++))
	    arg = &sv_no;

	/*SUPPRESS 530*/
	for ( ; t < send && *t != '%'; t++) ;
	if (t >= send)
	    break;		/* end of run_format string, ignore extra args */
	f = t;
	*buf = '\0';
	xs = buf;
#ifdef HAS_QUAD
	doquad =
#endif /* HAS_QUAD */
	dolong = FALSE;
	pre = post = 0;
	for (t++; t < send; t++) {
	    switch (*t) {
	    default:
		ch = *(++t);
		*t = '\0';
		(void)sprintf(xs,f);
		len++, sarg--;
		xlen = strlen(xs);
		break;
	    case 'n': case '*':
		croak("Use of %c in printf format not supported", *t);

	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9': 
	    case '.': case '#': case '-': case '+': case ' ':
		continue;
	    case 'l':
#ifdef HAS_QUAD
		if (dolong) {
		    dolong = FALSE;
		    doquad = TRUE;
		} else
#endif
		dolong = TRUE;
		continue;
	    case 'c':
		ch = *(++t);
		*t = '\0';
		xlen = SvIV(arg);
		if (strEQ(f,"%c")) { /* some printfs fail on null chars */
		    *xs = xlen;
		    xs[1] = '\0';
		    xlen = 1;
		}
		else {
		    (void)sprintf(xs,f,xlen);
		    xlen = strlen(xs);
		}
		break;
	    case 'D':
		dolong = TRUE;
		/* FALL THROUGH */
	    case 'd':
		ch = *(++t);
		*t = '\0';
#ifdef HAS_QUAD
		if (doquad)
		    (void)sprintf(buf,s,(Quad_t)SvNV(arg));
		else
#endif
		if (dolong)
		    (void)sprintf(xs,f,(long)SvNV(arg));
		else
		    (void)sprintf(xs,f,SvIV(arg));
		xlen = strlen(xs);
		break;
	    case 'X': case 'O':
		dolong = TRUE;
		/* FALL THROUGH */
	    case 'x': case 'o': case 'u':
		ch = *(++t);
		*t = '\0';
		value = SvNV(arg);
#ifdef HAS_QUAD
		if (doquad)
		    (void)sprintf(buf,s,(unsigned Quad_t)value);
		else
#endif
		if (dolong)
		    (void)sprintf(xs,f,U_L(value));
		else
		    (void)sprintf(xs,f,U_I(value));
		xlen = strlen(xs);
		break;
	    case 'E': case 'e': case 'f': case 'G': case 'g':
		ch = *(++t);
		*t = '\0';
		(void)sprintf(xs,f,SvNV(arg));
		xlen = strlen(xs);
		break;
	    case 's':
		ch = *(++t);
		*t = '\0';
		xs = SvPV(arg, arglen);
		xlen = (I32)arglen;
		if (strEQ(f,"%s")) {	/* some printfs fail on >128 chars */
		    break;		/* so handle simple cases */
		}
		else if (f[1] == '-') {
		    char *mp = strchr(f, '.');
		    I32 min = atoi(f+2);

		    if (mp) {
			I32 max = atoi(mp+1);

			if (xlen > max)
			    xlen = max;
		    }
		    if (xlen < min)
			post = min - xlen;
		    break;
		}
		else if (isDIGIT(f[1])) {
		    char *mp = strchr(f, '.');
		    I32 min = atoi(f+1);

		    if (mp) {
			I32 max = atoi(mp+1);

			if (xlen > max)
			    xlen = max;
		    }
		    if (xlen < min)
			pre = min - xlen;
		    break;
		}
		strcpy(tokenbuf+64,f);	/* sprintf($s,...$s...) */
		*t = ch;
		(void)sprintf(buf,tokenbuf+64,xs);
		xs = buf;
		xlen = strlen(xs);
		break;
	    }
	    /* end of switch, copy results */
	    *t = ch;
	    if (xs == buf && xlen >= sizeof(buf)) {	/* Ooops! */
		fputs("panic: sprintf overflow - memory corrupted!\n",stderr);
		my_exit(1);
	    }
	    SvGROW(sv, SvCUR(sv) + (f - s) + xlen + 1 + pre + post);
	    sv_catpvn(sv, s, f - s);
	    if (pre) {
		repeatcpy(SvPVX(sv) + SvCUR(sv), " ", 1, pre);
		SvCUR(sv) += pre;
	    }
	    sv_catpvn(sv, xs, xlen);
	    if (post) {
		repeatcpy(SvPVX(sv) + SvCUR(sv), " ", 1, post);
		SvCUR(sv) += post;
	    }
	    s = t;
	    break;		/* break from for loop */
	}
    }
    sv_catpvn(sv, s, t - s);
d155 2
d311 1
a311 1
		if (len < rslen)
d315 1
a315 1
		if (bcmp(s, rsptr, rslen))
d344 2
a345 2
    register char *lc = SvPV(left, leftlen);
    register char *rc = SvPV(right, rightlen);
d348 2
d351 4
a354 1
    dc = SvPV_force(sv,na);
d357 13
a369 3
    if (SvCUR(sv) < len) {
	dc = SvGROW(sv,len + 1);
	(void)memzero(dc + SvCUR(sv), len - SvCUR(sv) + 1);
a419 3
	char *lsave = lc;
	char *rsave = rc;
	
d443 1
a451 1
    I32 i;
a452 1
    char *tmps;
d454 1
d461 7
a467 1
    if (!hv)
d469 1
d473 5
a477 1
    if (GIMME != G_ARRAY) {
d480 11
d510 2
a511 6
	if (dokeys) {
	    tmps = hv_iterkey(entry,&i);	/* won't clobber stack_sp */
	    if (!i)
		tmps = "";
	    XPUSHs(sv_2mortal(newSVpv(tmps,i)));
	}
d513 1
a513 1
	    tmpstr = NEWSV(45,0);
d516 4
d521 1
a521 6
	    DEBUG_H( {
		sprintf(buf,"%d%%%d=%d\n",entry->hent_hash,
		    HvMAX(hv)+1,entry->hent_hash & HvMAX(hv));
		sv_setpv(tmpstr,buf);
	    } )
	    XPUSHs(sv_2mortal(tmpstr));
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d21 8
d30 3
a32 1
do_trans(SV *sv, OP *arg)
a33 1
    dTHR;
d40 1
a40 2
    register I32 squash = PL_op->op_private & OPpTRANS_SQUASH;
    register U8 *p;
d43 1
a43 1
    if (SvREADONLY(sv) && !(PL_op->op_private & OPpTRANS_COUNTONLY))
d56 1
a56 1
    if (!PL_op->op_private) {
a63 8
	SvSETMAGIC(sv);
    }
    else if (PL_op->op_private & OPpTRANS_COUNTONLY) {
	while (s < send) {
	    if (tbl[*s] >= 0)
		matches++;
	    s++;
	}
a66 1
	p = send;
d70 2
a71 3
		matches++;
		if (squash) {
		    if (p == d - 1 && *p == *d)
d74 1
a74 1
		        p = d++;
a85 1
	SvSETMAGIC(sv);
d87 1
d92 5
a96 1
do_join(register SV *sv, SV *del, register SV **mark, register SV **sp)
d111 1
a111 1
	    if (*mark && !SvGMAGICAL(*mark) && SvOK(*mark)) {
d152 4
a155 1
do_sprintf(SV *sv, I32 len, SV **sarg)
d157 185
a341 5
    STRLEN patlen;
    char *pat = SvPV(*sarg, patlen);
    bool do_taint = FALSE;

    sv_vsetpvfn(sv, pat, patlen, Null(va_list*), sarg + 1, len - 1, &do_taint);
a342 2
    if (do_taint)
	SvTAINTED_on(sv);
d346 2
a347 1
do_vecset(SV *sv)
d398 3
a400 1
do_chop(register SV *astr, register SV *sv)
d412 1
a412 1
	    if (sv && ((sv = *(SV**)sv), sv != &PL_sv_undef))
d442 2
a443 1
do_chomp(register SV *sv)
a444 1
    dTHR;
d449 1
a449 1
    if (RsSNARF(PL_rs))
d459 1
a459 1
	    if (sv && ((sv = *(SV**)sv), sv != &PL_sv_undef))
d478 1
a478 1
	if (RsPARA(PL_rs)) {
d490 1
a490 1
	    char *rsptr = SvPV(PL_rs, rslen);
d497 1
a497 1
		if (len < rslen - 1)
d501 1
a501 1
		if (memNE(s, rsptr, rslen))
d516 5
a520 1
do_vop(I32 optype, SV *sv, SV *left, SV *right)
a521 1
    dTHR;	/* just for taint */
d530 2
a531 2
    register char *lc;
    register char *rc;
a533 2
    char *lsave;
    char *rsave;
d535 1
a535 4
    if (sv != left || (optype != OP_BIT_AND && !SvOK(sv) && !SvGMAGICAL(sv)))
	sv_setpvn(sv, "", 0);	/* avoid undef warning on |= and ^= */
    lsave = lc = SvPV(left, leftlen);
    rsave = rc = SvPV(right, rightlen);
d538 3
a540 14
    if (SvOK(sv) || SvTYPE(sv) > SVt_PVMG) {
	STRLEN n_a;
	dc = SvPV_force(sv, n_a);
	if (SvCUR(sv) < len) {
	    dc = SvGROW(sv, len + 1);
	    (void)memzero(dc + SvCUR(sv), len - SvCUR(sv) + 1);
	}
    }
    else {
	I32 needlen = ((optype == OP_BIT_AND)
			? len : (leftlen > rightlen ? leftlen : rightlen));
	Newz(801, dc, needlen + 1, char);
	(void)sv_usepvn(sv, dc, needlen);
	dc = SvPVX(sv);		/* sv_usepvn() calls Renew() */
d591 3
a616 1
    SvTAINT(sv);
d620 2
a621 1
do_kv(ARGSproto)
d623 1
a623 1
    djSP;
d625 1
a625 1
    HV *keys;
d627 1
d629 4
a632 6
    I32 gimme = GIMME_V;
    I32 dokeys =   (PL_op->op_type == OP_KEYS);
    I32 dovalues = (PL_op->op_type == OP_VALUES);
    I32 realhv = (SvTYPE(hv) == SVt_PVHV);
    
    if (PL_op->op_type == OP_RV2HV || PL_op->op_type == OP_PADHV) 
d635 1
a635 7
    if (!hv) {
	if (PL_op->op_flags & OPf_MOD) {	/* lvalue */
	    dTARGET;		/* make sure to clear its target here */
	    if (SvTYPE(TARG) == SVt_PVLV)
		LvTARG(TARG) = Nullsv;
	    PUSHs(TARG);
	}
a636 1
    }
d638 1
a638 2
    keys = realhv ? hv : avhv_keys((AV*)hv);
    (void)hv_iterinit(keys);	/* always reset iterator regardless */
d640 1
a640 5
    if (gimme == G_VOID)
	RETURN;

    if (gimme == G_SCALAR) {
	IV i;
d643 2
a644 17
	if (PL_op->op_flags & OPf_MOD) {	/* lvalue */
	    if (SvTYPE(TARG) < SVt_PVLV) {
		sv_upgrade(TARG, SVt_PVLV);
		sv_magic(TARG, Nullsv, 'k', Nullch, 0);
	    }
	    LvTYPE(TARG) = 'k';
	    if (LvTARG(TARG) != (SV*)keys) {
		if (LvTARG(TARG))
		    SvREFCNT_dec(LvTARG(TARG));
		LvTARG(TARG) = SvREFCNT_inc(keys);
	    }
	    PUSHs(TARG);
	    RETURN;
	}

	if (! SvTIED_mg((SV*)keys, 'P'))
	    i = HvKEYS(keys);
d648 3
a650 1
	    while (hv_iternext(keys)) i++;
d656 2
a657 1
    EXTEND(SP, HvKEYS(keys) * (dokeys + dovalues));
d660 1
a660 1
    while (entry = hv_iternext(keys)) {
d662 6
a667 2
	if (dokeys)
	    XPUSHs(hv_iterkeysv(entry));	/* won't clobber stack_sp */
d669 1
a669 1
	    tmpstr = sv_newmortal();
d671 1
a671 6
	    sv_setsv(tmpstr,realhv ?
		     hv_iterval(hv,entry) : avhv_iterval((AV*)hv,entry));
	    DEBUG_H(sv_setpvf(tmpstr, "%lu%%%d=%lu",
			    (unsigned long)HeHASH(entry),
			    HvMAX(keys)+1,
			    (unsigned long)(HeHASH(entry) & HvMAX(keys))));
d673 6
a678 1
	    XPUSHs(tmpstr);
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a14 1
#define PERL_IN_DOOP_C
d21 2
a22 2
STATIC I32
S_do_trans_CC_simple(pTHX_ SV *sv)
d25 8
a32 3
    U8 *s;
    U8 *send;
    I32 matches = 0;
a33 2
    short *tbl;
    I32 ch;
d35 2
a37 60
    if (!tbl)
	Perl_croak(aTHX_ "panic: do_trans");

    s = (U8*)SvPV(sv, len);
    send = s + len;

    while (s < send) {
	if ((ch = tbl[*s]) >= 0) {
	    matches++;
	    *s = ch;
	}
	s++;
    }
    SvSETMAGIC(sv);

    return matches;
}

STATIC I32
S_do_trans_CC_count(pTHX_ SV *sv)
{
    dTHR;
    U8 *s;
    U8 *send;
    I32 matches = 0;
    STRLEN len;
    short *tbl;

    tbl = (short*)cPVOP->op_pv;
    if (!tbl)
	Perl_croak(aTHX_ "panic: do_trans");

    s = (U8*)SvPV(sv, len);
    send = s + len;

    while (s < send) {
	if (tbl[*s] >= 0)
	    matches++;
	s++;
    }

    return matches;
}

STATIC I32
S_do_trans_CC_complex(pTHX_ SV *sv)
{
    dTHR;
    U8 *s;
    U8 *send;
    U8 *d;
    I32 matches = 0;
    STRLEN len;
    short *tbl;
    I32 ch;

    tbl = (short*)cPVOP->op_pv;
    if (!tbl)
	Perl_croak(aTHX_ "panic: do_trans");

d39 5
d45 4
a48 5

    d = s;
    if (PL_op->op_private & OPpTRANS_SQUASH) {
	U8* p = send;

a50 1
		*d = ch;
d52 1
a52 4
		if (p == d - 1 && *p == *d)
		    matches--;
		else
		    p = d++;
a53 2
	    else if (ch == -1)		/* -1 is unmapped character */
		*d++ = *s;		/* -2 is delete character */
d56 1
d58 1
a58 1
    else {
d60 1
a60 2
	    if ((ch = tbl[*s]) >= 0) {
		*d = ch;
a61 4
		d++;
	    }
	    else if (ch == -1)		/* -1 is unmapped character */
		*d++ = *s;		/* -2 is delete character */
a64 308
    matches += send - d;	/* account for disappeared chars */
    *d = '\0';
    SvCUR_set(sv, d - (U8*)SvPVX(sv));
    SvSETMAGIC(sv);

    return matches;
}

STATIC I32
S_do_trans_UU_simple(pTHX_ SV *sv)
{
    dTHR;
    U8 *s;
    U8 *send;
    U8 *d;
    I32 matches = 0;
    STRLEN len;

    SV* rv = (SV*)cSVOP->op_sv;
    HV* hv = (HV*)SvRV(rv);
    SV** svp = hv_fetch(hv, "NONE", 4, FALSE);
    UV none = svp ? SvUV(*svp) : 0x7fffffff;
    UV extra = none + 1;
    UV final;
    UV uv;

    s = (U8*)SvPV(sv, len);
    send = s + len;

    svp = hv_fetch(hv, "FINAL", 5, FALSE);
    if (svp)
	final = SvUV(*svp);

    d = s;
    while (s < send) {
	if ((uv = swash_fetch(rv, s)) < none) {
	    s += UTF8SKIP(s);
	    matches++;
	    d = uv_to_utf8(d, uv);
	}
	else if (uv == none) {
	    int i;
	    for (i = UTF8SKIP(s); i; i--)
		*d++ = *s++;
	}
	else if (uv == extra) {
	    s += UTF8SKIP(s);
	    matches++;
	    d = uv_to_utf8(d, final);
	}
	else
	    s += UTF8SKIP(s);
    }
    *d = '\0';
    SvCUR_set(sv, d - (U8*)SvPVX(sv));
    SvSETMAGIC(sv);

    return matches;
}

STATIC I32
S_do_trans_UU_count(pTHX_ SV *sv)
{
    dTHR;
    U8 *s;
    U8 *send;
    I32 matches = 0;
    STRLEN len;

    SV* rv = (SV*)cSVOP->op_sv;
    HV* hv = (HV*)SvRV(rv);
    SV** svp = hv_fetch(hv, "NONE", 4, FALSE);
    UV none = svp ? SvUV(*svp) : 0x7fffffff;
    UV uv;

    s = (U8*)SvPV(sv, len);
    send = s + len;

    while (s < send) {
	if ((uv = swash_fetch(rv, s)) < none)
	    matches++;
	s += UTF8SKIP(s);
    }

    return matches;
}

STATIC I32
S_do_trans_UC_simple(pTHX_ SV *sv)
{
    dTHR;
    U8 *s;
    U8 *send;
    U8 *d;
    I32 matches = 0;
    STRLEN len;

    SV* rv = (SV*)cSVOP->op_sv;
    HV* hv = (HV*)SvRV(rv);
    SV** svp = hv_fetch(hv, "NONE", 4, FALSE);
    UV none = svp ? SvUV(*svp) : 0x7fffffff;
    UV extra = none + 1;
    UV final;
    UV uv;

    s = (U8*)SvPV(sv, len);
    send = s + len;

    svp = hv_fetch(hv, "FINAL", 5, FALSE);
    if (svp)
	final = SvUV(*svp);

    d = s;
    while (s < send) {
	if ((uv = swash_fetch(rv, s)) < none) {
	    s += UTF8SKIP(s);
	    matches++;
	    *d++ = (U8)uv;
	}
	else if (uv == none) {
	    I32 ulen;
	    uv = utf8_to_uv(s, &ulen);
	    s += ulen;
	    *d++ = (U8)uv;
	}
	else if (uv == extra) {
	    s += UTF8SKIP(s);
	    matches++;
	    *d++ = (U8)final;
	}
	else
	    s += UTF8SKIP(s);
    }
    *d = '\0';
    SvCUR_set(sv, d - (U8*)SvPVX(sv));
    SvSETMAGIC(sv);

    return matches;
}

STATIC I32
S_do_trans_CU_simple(pTHX_ SV *sv)
{
    dTHR;
    U8 *s;
    U8 *send;
    U8 *d;
    U8 *dst;
    I32 matches = 0;
    STRLEN len;

    SV* rv = (SV*)cSVOP->op_sv;
    HV* hv = (HV*)SvRV(rv);
    SV** svp = hv_fetch(hv, "NONE", 4, FALSE);
    UV none = svp ? SvUV(*svp) : 0x7fffffff;
    UV extra = none + 1;
    UV final;
    UV uv;
    U8 tmpbuf[UTF8_MAXLEN];
    I32 bits = 16;

    s = (U8*)SvPV(sv, len);
    send = s + len;

    svp = hv_fetch(hv, "BITS", 4, FALSE);
    if (svp)
	bits = (I32)SvIV(*svp);

    svp = hv_fetch(hv, "FINAL", 5, FALSE);
    if (svp)
	final = SvUV(*svp);

    Newz(801, d, len * (bits >> 3) + 1, U8);
    dst = d;

    while (s < send) {
	uv = *s++;
	if (uv < 0x80)
	    tmpbuf[0] = uv;
	else {
	    tmpbuf[0] = (( uv >>  6)         | 0xc0);
	    tmpbuf[1] = (( uv        & 0x3f) | 0x80);
	}

	if ((uv = swash_fetch(rv, tmpbuf)) < none) {
	    matches++;
	    d = uv_to_utf8(d, uv);
	}
	else if (uv == none)
	    d = uv_to_utf8(d, s[-1]);
	else if (uv == extra) {
	    matches++;
	    d = uv_to_utf8(d, final);
	}
    }
    *d = '\0';
    sv_usepvn_mg(sv, (char*)dst, d - dst);

    return matches;
}

/* utf-8 to latin-1 */

STATIC I32
S_do_trans_UC_trivial(pTHX_ SV *sv)
{
    dTHR;
    U8 *s;
    U8 *send;
    U8 *d;
    STRLEN len;

    s = (U8*)SvPV(sv, len);
    send = s + len;

    d = s;
    while (s < send) {
	if (*s < 0x80)
	    *d++ = *s++;
	else {
	    I32 ulen;
	    UV uv = utf8_to_uv(s, &ulen);
	    s += ulen;
	    *d++ = (U8)uv;
	}
    }
    *d = '\0';
    SvCUR_set(sv, d - (U8*)SvPVX(sv));
    SvSETMAGIC(sv);

    return SvCUR(sv);
}

/* latin-1 to utf-8 */

STATIC I32
S_do_trans_CU_trivial(pTHX_ SV *sv)
{
    dTHR;
    U8 *s;
    U8 *send;
    U8 *d;
    U8 *dst;
    I32 matches;
    STRLEN len;

    s = (U8*)SvPV(sv, len);
    send = s + len;

    Newz(801, d, len * 2 + 1, U8);
    dst = d;

    matches = send - s;

    while (s < send) {
	if (*s < 0x80)
	    *d++ = *s++;
	else {
	    UV uv = *s++;
	    *d++ = (( uv >>  6)         | 0xc0);
	    *d++ = (( uv        & 0x3f) | 0x80);
	}
    }
    *d = '\0';
    sv_usepvn_mg(sv, (char*)dst, d - dst);

    return matches;
}

STATIC I32
S_do_trans_UU_complex(pTHX_ SV *sv)
{
    dTHR;
    U8 *s;
    U8 *send;
    U8 *d;
    I32 matches = 0;
    I32 squash   = PL_op->op_private & OPpTRANS_SQUASH;
    I32 from_utf = PL_op->op_private & OPpTRANS_FROM_UTF;
    I32 to_utf   = PL_op->op_private & OPpTRANS_TO_UTF;
    I32 del      = PL_op->op_private & OPpTRANS_DELETE;
    SV* rv = (SV*)cSVOP->op_sv;
    HV* hv = (HV*)SvRV(rv);
    SV** svp = hv_fetch(hv, "NONE", 4, FALSE);
    UV none = svp ? SvUV(*svp) : 0x7fffffff;
    UV extra = none + 1;
    UV final;
    UV uv;
    STRLEN len;
    U8 *dst;

    s = (U8*)SvPV(sv, len);
    send = s + len;

    svp = hv_fetch(hv, "FINAL", 5, FALSE);
    if (svp)
	final = SvUV(*svp);

    if (PL_op->op_private & OPpTRANS_GROWS) {
	I32 bits = 16;

	svp = hv_fetch(hv, "BITS", 4, FALSE);
	if (svp)
	    bits = (I32)SvIV(*svp);

	Newz(801, d, len * (bits >> 3) + 1, U8);
	dst = d;
    }
d67 1
a67 5
	dst = 0;
    }

    if (squash) {
	UV puv = 0xfeedface;
d69 2
a70 15
	    if (from_utf) {
		uv = swash_fetch(rv, s);
	    }
	    else {
		U8 tmpbuf[2];
		uv = *s++;
		if (uv < 0x80)
		    tmpbuf[0] = uv;
		else {
		    tmpbuf[0] = (( uv >>  6)         | 0xc0);
		    tmpbuf[1] = (( uv        & 0x3f) | 0x80);
		}
		uv = swash_fetch(rv, tmpbuf);
	    }
	    if (uv < none) {
d72 3
a74 3
		if (uv != puv) {
		    if (uv >= 0x80 && to_utf)
			d = uv_to_utf8(d, uv);
d76 1
a76 2
			*d++ = (U8)uv;
		    puv = uv;
a77 63
		if (from_utf)
		    s += UTF8SKIP(s);
		continue;
	    }
	    else if (uv == none) {	/* "none" is unmapped character */
		if (from_utf) {
		    if (*s < 0x80)
			*d++ = *s++;
		    else if (to_utf) {
			int i;
			for (i = UTF8SKIP(s); i; --i)
			    *d++ = *s++;
		    }
		    else {
			I32 ulen;
			*d++ = (U8)utf8_to_uv(s, &ulen);
			s += ulen;
		    }
		}
		else {	/* must be to_utf only */
		    d = uv_to_utf8(d, s[-1]);
		}
		puv = 0xfeedface;
		continue;
	    }
	    else if (uv == extra && !del) {
		matches++;
		if (uv != puv) {
		    if (final >= 0x80 && to_utf)
			d = uv_to_utf8(d, final);
		    else
			*d++ = (U8)final;
		    puv = final;
		}
		if (from_utf)
		    s += UTF8SKIP(s);
		continue;
	    }
	    matches++;		/* "none+1" is delete character */
	    if (from_utf)
		s += UTF8SKIP(s);
	}
    }
    else {
	while (s < send) {
	    if (from_utf) {
		uv = swash_fetch(rv, s);
	    }
	    else {
		U8 tmpbuf[2];
		uv = *s++;
		if (uv < 0x80)
		    tmpbuf[0] = uv;
		else {
		    tmpbuf[0] = (( uv >>  6)         | 0xc0);
		    tmpbuf[1] = (( uv        & 0x3f) | 0x80);
		}
		uv = swash_fetch(rv, tmpbuf);
	    }
	    if (uv < none) {
		matches++;
		if (uv >= 0x80 && to_utf)
		    d = uv_to_utf8(d, uv);
d79 1
a79 4
		    *d++ = (U8)uv;
		if (from_utf)
		    s += UTF8SKIP(s);
		continue;
d81 3
a83 33
	    else if (uv == none) {	/* "none" is unmapped character */
		if (from_utf) {
		    if (*s < 0x80)
			*d++ = *s++;
		    else if (to_utf) {
			int i;
			for (i = UTF8SKIP(s); i; --i)
			    *d++ = *s++;
		    }
		    else {
			I32 ulen;
			*d++ = (U8)utf8_to_uv(s, &ulen);
			s += ulen;
		    }
		}
		else {	/* must be to_utf only */
		    d = uv_to_utf8(d, s[-1]);
		}
		continue;
	    }
	    else if (uv == extra && !del) {
		matches++;
		if (final >= 0x80 && to_utf)
		    d = uv_to_utf8(d, final);
		else
		    *d++ = (U8)final;
		if (from_utf)
		    s += UTF8SKIP(s);
		continue;
	    }
	    matches++;		/* "none+1" is delete character */
	    if (from_utf)
		s += UTF8SKIP(s);
d85 1
a85 4
    }
    if (dst)
	sv_usepvn(sv, (char*)dst, d - dst);
    else {
d88 1
a89 2
    SvSETMAGIC(sv);

a92 51
I32
Perl_do_trans(pTHX_ SV *sv)
{
    dTHR;
    STRLEN len;

    if (SvREADONLY(sv) && !(PL_op->op_private & OPpTRANS_IDENTICAL))
	Perl_croak(aTHX_ PL_no_modify);

    (void)SvPV(sv, len);
    if (!len)
	return 0;
    if (!SvPOKp(sv))
	(void)SvPV_force(sv, len);
    (void)SvPOK_only(sv);

    DEBUG_t( Perl_deb(aTHX_ "2.TBL\n"));

    switch (PL_op->op_private & 63) {
    case 0:
	return do_trans_CC_simple(sv);

    case OPpTRANS_FROM_UTF:
	return do_trans_UC_simple(sv);

    case OPpTRANS_TO_UTF:
	return do_trans_CU_simple(sv);

    case OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF:
	return do_trans_UU_simple(sv);

    case OPpTRANS_IDENTICAL:
	return do_trans_CC_count(sv);

    case OPpTRANS_FROM_UTF|OPpTRANS_IDENTICAL:
	return do_trans_UC_trivial(sv);

    case OPpTRANS_TO_UTF|OPpTRANS_IDENTICAL:
	return do_trans_CU_trivial(sv);

    case OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF|OPpTRANS_IDENTICAL:
	return do_trans_UU_count(sv);

    default:
	if (PL_op->op_private & (OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF))
	    return do_trans_UU_complex(sv); /* could be UC or CU too */
	else
	    return do_trans_CC_complex(sv);
    }
}

d94 1
a94 1
Perl_do_join(pTHX_ register SV *sv, SV *del, register SV **mark, register SV **sp)
d105 2
a106 1
    (void)SvUPGRADE(sv, SVt_PV);
d118 1
a118 1
	items = sp - mark;
d150 1
a150 1
Perl_do_sprintf(pTHX_ SV *sv, I32 len, SV **sarg)
a161 132
UV
Perl_do_vecget(pTHX_ SV *sv, I32 offset, I32 size)
{
    STRLEN srclen, len;
    unsigned char *s = (unsigned char *) SvPV(sv, srclen);
    UV retnum = 0;

    if (offset < 0)
	return retnum;
    if (size < 1 || (size & (size-1))) /* size < 1 or not a power of two */ 
	Perl_croak(aTHX_ "Illegal number of bits in vec");
    offset *= size;	/* turn into bit offset */
    len = (offset + size + 7) / 8;	/* required number of bytes */
    if (len > srclen) {
	if (size <= 8)
	    retnum = 0;
	else {
	    offset >>= 3;	/* turn into byte offset */
	    if (size == 16) {
		if (offset >= srclen)
		    retnum = 0;
		else
		    retnum = (UV) s[offset] <<  8;
	    }
	    else if (size == 32) {
		if (offset >= srclen)
		    retnum = 0;
		else if (offset + 1 >= srclen)
		    retnum =
			((UV) s[offset    ] << 24);
		else if (offset + 2 >= srclen)
		    retnum =
			((UV) s[offset    ] << 24) +
			((UV) s[offset + 1] << 16);
		else
		    retnum =
			((UV) s[offset    ] << 24) +
			((UV) s[offset + 1] << 16) +
			(     s[offset + 2] <<  8);
	    }
#ifdef UV_IS_QUAD
	    else if (size == 64) {
		dTHR;
		if (ckWARN(WARN_PORTABLE))
		    Perl_warner(aTHX_ WARN_PORTABLE,
				"Bit vector size > 32 non-portable");
		if (offset >= srclen)
		    retnum = 0;
		else if (offset + 1 >= srclen)
		    retnum =
			(UV) s[offset     ] << 56;
		else if (offset + 2 >= srclen)
		    retnum =
			((UV) s[offset    ] << 56) +
			((UV) s[offset + 1] << 48);
		else if (offset + 3 >= srclen)
		    retnum =
			((UV) s[offset    ] << 56) +
			((UV) s[offset + 1] << 48) +
			((UV) s[offset + 2] << 40);
		else if (offset + 4 >= srclen)
		    retnum =
			((UV) s[offset    ] << 56) +
			((UV) s[offset + 1] << 48) +
			((UV) s[offset + 2] << 40) +
			((UV) s[offset + 3] << 32);
		else if (offset + 5 >= srclen)
		    retnum =
			((UV) s[offset    ] << 56) +
			((UV) s[offset + 1] << 48) +
			((UV) s[offset + 2] << 40) +
			((UV) s[offset + 3] << 32) +
			(     s[offset + 4] << 24);
		else if (offset + 6 >= srclen)
		    retnum =
			((UV) s[offset    ] << 56) +
			((UV) s[offset + 1] << 48) +
			((UV) s[offset + 2] << 40) +
			((UV) s[offset + 3] << 32) +
			((UV) s[offset + 4] << 24) +
			((UV) s[offset + 5] << 16);
		else
		    retnum = 
			((UV) s[offset    ] << 56) +
			((UV) s[offset + 1] << 48) +
			((UV) s[offset + 2] << 40) +
			((UV) s[offset + 3] << 32) +
			((UV) s[offset + 4] << 24) +
			((UV) s[offset + 5] << 16) +
			(     s[offset + 6] <<  8);
	    }
#endif
	}
    }
    else if (size < 8)
	retnum = (s[offset >> 3] >> (offset & 7)) & ((1 << size) - 1);
    else {
	offset >>= 3;	/* turn into byte offset */
	if (size == 8)
	    retnum = s[offset];
	else if (size == 16)
	    retnum =
		((UV) s[offset] <<      8) +
		      s[offset + 1];
	else if (size == 32)
	    retnum =
		((UV) s[offset    ] << 24) +
		((UV) s[offset + 1] << 16) +
		(     s[offset + 2] <<  8) +
		      s[offset + 3];
#ifdef UV_IS_QUAD
	else if (size == 64) {
	    dTHR;
	    if (ckWARN(WARN_PORTABLE))
		Perl_warner(aTHX_ WARN_PORTABLE,
			    "Bit vector size > 32 non-portable");
	    retnum =
		((UV) s[offset    ] << 56) +
		((UV) s[offset + 1] << 48) +
		((UV) s[offset + 2] << 40) +
		((UV) s[offset + 3] << 32) +
		((UV) s[offset + 4] << 24) +
		((UV) s[offset + 5] << 16) +
		(     s[offset + 6] <<  8) +
		      s[offset + 7];
	}
#endif
    }

    return retnum;
}

d163 1
a163 1
Perl_do_vecset(pTHX_ SV *sv)
d169 1
a169 1
    register UV lval;
d177 1
a177 1
    lval = SvUV(sv);
a179 2
    if (size < 1 || (size & (size-1))) /* size < 1 or not a power of two */ 
	Perl_croak(aTHX_ "Illegal number of bits in vec");
d181 1
a181 2
    offset *= size;			/* turn into bit offset */
    len = (offset + size + 7) / 8;	/* required number of bytes */
d192 1
a192 1
	offset >>= 3;			/* turn into byte offset */
d197 1
a197 1
	offset >>= 3;			/* turn into byte offset */
d199 1
a199 1
	    s[offset  ] = lval         & 0xff;
d201 2
a202 2
	    s[offset  ] = (lval >>  8) & 0xff;
	    s[offset+1] = lval         & 0xff;
d205 4
a208 19
	    s[offset  ] = (lval >> 24) & 0xff;
	    s[offset+1] = (lval >> 16) & 0xff;
	    s[offset+2] = (lval >>  8) & 0xff;
	    s[offset+3] =  lval        & 0xff;
	}
#ifdef UV_IS_QUAD
	else if (size == 64) {
	    dTHR;
	    if (ckWARN(WARN_PORTABLE))
		Perl_warner(aTHX_ WARN_PORTABLE,
			    "Bit vector size > 32 non-portable");
	    s[offset  ] = (lval >> 56) & 0xff;
	    s[offset+1] = (lval >> 48) & 0xff;
	    s[offset+2] = (lval >> 40) & 0xff;
	    s[offset+3] = (lval >> 32) & 0xff;
	    s[offset+4] = (lval >> 24) & 0xff;
	    s[offset+5] = (lval >> 16) & 0xff;
	    s[offset+6] = (lval >>  8) & 0xff;
	    s[offset+7] =  lval        & 0xff;
a209 1
#endif
a210 1
    SvSETMAGIC(targ);
d214 1
a214 1
Perl_do_chop(pTHX_ register SV *astr, register SV *sv)
a217 1
    dTHR;
d231 1
a231 1
    else if (SvTYPE(sv) == SVt_PVHV) {
d236 1
a236 1
        while ((entry = hv_iternext(hv)))
a239 2
    else if (SvREADONLY(sv))
	Perl_croak(aTHX_ PL_no_modify);
d243 1
a243 19
    if (DO_UTF8(sv)) {
	if (s && len) {
	    char *send = s + len;
	    char *start = s;
	    s = send - 1;
	    while ((*s & 0xc0) == 0x80)
		--s;
	    if (UTF8SKIP(s) != send - s && ckWARN_d(WARN_UTF8))
		Perl_warner(aTHX_ WARN_UTF8, "Malformed UTF-8 character");
	    sv_setpvn(astr, s, send - s);
	    *s = '\0';
	    SvCUR_set(sv, s - start);
	    SvNIOK_off(sv);
	    SvUTF8_on(astr);
	}
	else
	    sv_setpvn(astr, "", 0);
    }
    else if (s && len) {
a247 1
	SvUTF8_off(sv);
d253 1
a253 1
}
d256 1
a256 1
Perl_do_chomp(pTHX_ register SV *sv)
a264 2
    if (RsRECORD(PL_rs))
      return 0;
d278 1
a278 1
    else if (SvTYPE(sv) == SVt_PVHV) {
d283 1
a283 1
        while ((entry = hv_iternext(hv)))
a286 2
    else if (SvREADONLY(sv))
	Perl_croak(aTHX_ PL_no_modify);
d330 1
a330 1
Perl_do_vop(pTHX_ I32 optype, SV *sv, SV *left, SV *right)
a346 7
    bool left_utf = DO_UTF8(left);
    bool right_utf = DO_UTF8(right);

    if (left_utf && !right_utf)
	sv_utf8_upgrade(right);
    if (!left_utf && right_utf)
	sv_utf8_upgrade(left);
a370 63
    if (left_utf || right_utf) {
	UV duc, luc, ruc;
	STRLEN lulen = leftlen;
	STRLEN rulen = rightlen;
	STRLEN dulen = 0;
	I32 ulen;

	if (optype != OP_BIT_AND)
	    dc = SvGROW(sv, leftlen+rightlen+1);

	switch (optype) {
	case OP_BIT_AND:
	    while (lulen && rulen) {
		luc = utf8_to_uv((U8*)lc, &ulen);
		lc += ulen;
		lulen -= ulen;
		ruc = utf8_to_uv((U8*)rc, &ulen);
		rc += ulen;
		rulen -= ulen;
		duc = luc & ruc;
		dc = (char*)uv_to_utf8((U8*)dc, duc);
	    }
	    dulen = dc - SvPVX(sv);
	    SvCUR_set(sv, dulen);
	    break;
	case OP_BIT_XOR:
	    while (lulen && rulen) {
		luc = utf8_to_uv((U8*)lc, &ulen);
		lc += ulen;
		lulen -= ulen;
		ruc = utf8_to_uv((U8*)rc, &ulen);
		rc += ulen;
		rulen -= ulen;
		duc = luc ^ ruc;
		dc = (char*)uv_to_utf8((U8*)dc, duc);
	    }
	    goto mop_up_utf;
	case OP_BIT_OR:
	    while (lulen && rulen) {
		luc = utf8_to_uv((U8*)lc, &ulen);
		lc += ulen;
		lulen -= ulen;
		ruc = utf8_to_uv((U8*)rc, &ulen);
		rc += ulen;
		rulen -= ulen;
		duc = luc | ruc;
		dc = (char*)uv_to_utf8((U8*)dc, duc);
	    }
	  mop_up_utf:
	    dulen = dc - SvPVX(sv);
	    SvCUR_set(sv, dulen);
	    if (rulen)
		sv_catpvn(sv, rc, rulen);
	    else if (lulen)
		sv_catpvn(sv, lc, lulen);
	    else
		*SvEND(sv) = '\0';
	    break;
	}
	SvUTF8_on(sv);
	goto finish;
    }
    else
a440 1
finish:
d445 1
a445 1
Perl_do_kv(pTHX)
d509 1
a509 1
    while ((entry = hv_iternext(keys))) {
d514 1
d516 3
a518 3
	    tmpstr = realhv ?
		     hv_iterval(hv,entry) : avhv_iterval((AV*)hv,entry);
	    DEBUG_H(Perl_sv_setpvf(aTHX_ tmpstr, "%lu%%%d=%lu",
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d23 1
a23 1
S_do_trans_simple(pTHX_ SV *sv)
d25 1
a26 1
    U8 *d;
a27 1
    U8 *dstart;
a28 1
    I32 grows = PL_op->op_private & OPpTRANS_GROWS;
d35 1
a35 1
	Perl_croak(aTHX_ "panic: do_trans_simple");
d40 4
a43 9
    /* First, take care of non-UTF8 input strings, because they're easy */
    if (!SvUTF8(sv)) {
	while (s < send) {
	    if ((ch = tbl[*s]) >= 0) {
		matches++;
		*s++ = ch;
	    }
	    else
		s++;
d45 1
a45 2
	SvSETMAGIC(sv);
        return matches;
d47 1
a48 36
    /* Allow for expansion: $_="a".chr(400); tr/a/\xFE/, FE needs encoding */
    if (grows)
	New(0, d, len*2+1, U8);
    else
	d = s;
    dstart = d;
    while (s < send) {
        STRLEN ulen;
        UV c;

        /* Need to check this, otherwise 128..255 won't match */
	c = utf8_to_uv(s, send - s, &ulen, 0);
        if (c < 0x100 && (ch = tbl[c]) >= 0) {
            matches++;
            if (UTF8_IS_ASCII(ch))
                *d++ = ch;
            else
                d = uv_to_utf8(d,ch);
            s += ulen;
        }
	else { /* No match -> copy */
	    Copy(s, d, ulen, U8);
	    d += ulen;
	    s += ulen;
        }
    }
    if (grows) {
	sv_setpvn(sv, (char*)dstart, d - dstart);
	Safefree(dstart);
    }
    else {
	*d = '\0';
	SvCUR_set(sv, d - dstart);
    }
    SvUTF8_on(sv);
    SvSETMAGIC(sv);
d53 1
a53 1
S_do_trans_count(pTHX_ SV *sv)/* SPC - OK */
d55 1
d64 1
a64 1
	Perl_croak(aTHX_ "panic: do_trans_count");
d69 5
a73 14
    if (!SvUTF8(sv))
	while (s < send) {
            if (tbl[*s++] >= 0)
                matches++;
	}
    else
	while (s < send) {
	    UV c;
	    STRLEN ulen;
	    c = utf8_to_uv(s, send - s, &ulen, 0);
	    if (c < 0x100 && tbl[c] >= 0)
		matches++;
	    s += ulen;
	}
d79 1
a79 1
S_do_trans_complex(pTHX_ SV *sv)/* SPC - NOT OK */
d81 1
a84 2
    U8 *dstart;
    I32 isutf8;
a85 1
    I32 grows = PL_op->op_private & OPpTRANS_GROWS;
d92 1
a92 1
	Perl_croak(aTHX_ "panic: do_trans_complex");
a94 1
    isutf8 = SvUTF8(sv);
d97 12
a108 16
    if (!isutf8) {
	dstart = d = s;
	if (PL_op->op_private & OPpTRANS_SQUASH) {
	    U8* p = send;
	    while (s < send) {
		if ((ch = tbl[*s]) >= 0) {
		    *d = ch;
		    matches++;
		    if (p != d - 1 || *p != *d)
			p = d++;
		}
		else if (ch == -1)	/* -1 is unmapped character */
		    *d++ = *s;	
		else if (ch == -2)	/* -2 is delete character */
		    matches++;
		s++;
d110 3
d114 7
a120 11
	else {
	    while (s < send) {
	        if ((ch = tbl[*s]) >= 0) {
		    matches++;
		    *d++ = ch;
		}
		else if (ch == -1)	/* -1 is unmapped character */
		    *d++ = *s;
		else if (ch == -2)      /* -2 is delete character */
		    matches++;
		s++;
d122 3
a125 2
	*d = '\0';
	SvCUR_set(sv, d - dstart);
d127 28
a154 6
    else { /* isutf8 */
	if (grows)
	    New(0, d, len*2+1, U8);
	else
	    d = s;
	dstart = d;
d156 3
a158 3
#ifdef MACOS_TRADITIONAL
#define comp CoMP   /* "comp" is a keyword in some compilers ... */
#endif
d160 6
a165 29
	if (PL_op->op_private & OPpTRANS_SQUASH) {
	    U8* p = send;
	    UV pch = 0xfeedface;
	    while (s < send) {
		STRLEN len;
	        UV comp = utf8_to_uv_simple(s, &len);

		if (comp > 0xff) {	/* always unmapped */	
		    Copy(s, d, len, U8);
		    d += len;
		}
		else if ((ch = tbl[comp]) >= 0) {
		    matches++;
		    if (ch != pch) {
		        d = uv_to_utf8(d, ch);
		        pch = ch;
		    }
		    s += len;
		    continue;
		}
		else if (ch == -1) {	/* -1 is unmapped character */
		    Copy(s, d, len, U8);
		    d += len;
		}
		else if (ch == -2)      /* -2 is delete character */
		    matches++;
		s += len;
		pch = 0xfeedface;
	    }
d167 4
a170 20
	else {
	    while (s < send) {
		STRLEN len;
	        UV comp = utf8_to_uv_simple(s, &len);
		if (comp > 0xff) {	/* always unmapped */
		    Copy(s, d, len, U8);
		    d += len;
		}
		else if ((ch = tbl[comp]) >= 0) {
		    d = uv_to_utf8(d, ch);
		    matches++;
		}
		else if (ch == -1) {	/* -1 is unmapped character */
		    Copy(s, d, len, U8);
		    d += len;
		}
		else if (ch == -2)      /* -2 is delete character */
		    matches++;
		s += len;
	    }
d172 4
a175 3
	if (grows) {
	    sv_setpvn(sv, (char*)dstart, d - dstart);
	    Safefree(dstart);
d177 2
a178 5
	else {
	    *d = '\0';
	    SvCUR_set(sv, d - dstart);
	}
	SvUTF8_on(sv);
d180 2
d183 28
d215 1
a215 1
S_do_trans_simple_utf8(pTHX_ SV *sv)/* SPC - OK */
d217 1
a220 2
    U8 *start;
    U8 *dstart, *dend;
a221 1
    I32 grows = PL_op->op_private & OPpTRANS_GROWS;
a230 2
    I32 isutf8;
    U8 hibit = 0;
a232 9
    isutf8 = SvUTF8(sv);
    if (!isutf8) {
	U8 *t = s, *e = s + len;
	while (t < e)
	    if ((hibit = UTF8_IS_CONTINUED(*t++)))
		break;
	if (hibit)
	    s = bytes_to_utf8(s, &len);
    }
a233 1
    start = s;
d239 1
a239 11
    if (grows) {
	/* d needs to be bigger than s, in case e.g. upgrading is required */
	New(0, d, len*3+UTF8_MAXLEN, U8);
	dend = d + len * 3;
	dstart = d;
    }
    else {
	dstart = d = s;
	dend = d + len;
    }

d244 1
a244 1
	    d = uv_to_utf8(d, uv);
d247 4
a250 4
	    int i = UTF8SKIP(s);
	    Copy(s, d, i, U8);
	    d += i;
	    s += i;
d253 1
a253 2
	    int i = UTF8SKIP(s);
	    s += i;
d255 1
a255 1
	    d = uv_to_utf8(d, final);
a258 20

	if (d > dend) {
	    STRLEN clen = d - dstart;
	    STRLEN nlen = dend - dstart + len + UTF8_MAXLEN;
	    if (!grows)
		Perl_croak(aTHX_ "panic: do_trans_complex_utf8");
	    Renew(dstart, nlen+UTF8_MAXLEN, U8);
	    d = dstart + clen;
	    dend = dstart + nlen;
	}
    }
    if (grows || hibit) {
	sv_setpvn(sv, (char*)dstart, d - dstart);
	Safefree(dstart);
	if (grows && hibit)
	    Safefree(start);
    }
    else {
	*d = '\0';
	SvCUR_set(sv, d - dstart);
d260 2
a262 3
    SvUTF8_on(sv);
    if (!isutf8 && !(PL_hints & HINT_UTF8))
	sv_utf8_downgrade(sv, TRUE);
d268 1
a268 1
S_do_trans_count_utf8(pTHX_ SV *sv)/* SPC - OK */
d270 1
d272 3
a274 1
    U8 *start, *send;
d282 2
d285 53
a337 1
    U8 hibit = 0;
d340 12
a351 7
    if (!SvUTF8(sv)) {
	U8 *t = s, *e = s + len;
	while (t < e)
	    if ((hibit = !UTF8_IS_ASCII(*t++)))
		break;
	if (hibit)
	    start = s = bytes_to_utf8(s, &len);
d353 21
d376 5
d382 7
a388 3
	if ((uv = swash_fetch(rv, s)) < none)
	    matches++;
	s += UTF8SKIP(s);
d390 2
a391 2
    if (hibit)
        Safefree(start);
d397 1
a397 1
S_do_trans_complex_utf8(pTHX_ SV *sv) /* SPC - NOT OK */
d399 1
d401 1
a401 1
    U8 *start, *send;
d405 2
a407 1
    I32 grows    = PL_op->op_private & OPpTRANS_GROWS;
d416 1
a416 3
    U8 *dstart, *dend;
    I32 isutf8;
    U8 hibit = 0;
a418 9
    isutf8 = SvUTF8(sv);
    if (!isutf8) {
	U8 *t = s, *e = s + len;
	while (t < e)
	    if ((hibit = !UTF8_IS_ASCII(*t++)))
		break;
	if (hibit)
	    s = bytes_to_utf8(s, &len);
    }
a419 1
    start = s;
d425 9
a433 5
    if (grows) {
	/* d needs to be bigger than s, in case e.g. upgrading is required */
	New(0, d, len*3+UTF8_MAXLEN, U8);
	dend = d + len * 3;
	dstart = d;
d436 2
a437 2
	dstart = d = s;
	dend = d + len;
d443 13
a455 10
	    uv = swash_fetch(rv, s);
	    
	    if (d > dend) {
	        STRLEN clen = d - dstart;
		STRLEN nlen = dend - dstart + len + UTF8_MAXLEN;
		if (!grows)
		    Perl_croak(aTHX_ "panic: do_trans_complex_utf8");
		Renew(dstart, nlen+UTF8_MAXLEN, U8);
		d = dstart + clen;
		dend = dstart + nlen;
d460 4
a463 1
		    d = uv_to_utf8(d, uv);
d466 2
a467 1
		s += UTF8SKIP(s);
d471 17
a487 4
		int i = UTF8SKIP(s);
		Copy(s, d, i, U8);
		d += i;
		s += i;
d494 4
a497 1
		    d = uv_to_utf8(d, final);
d500 2
a501 1
		s += UTF8SKIP(s);
d504 3
a506 2
	    matches++;			/* "none+1" is delete character */
	    s += UTF8SKIP(s);
d511 13
a523 9
	    uv = swash_fetch(rv, s);
	    if (d > dend) {
	        STRLEN clen = d - dstart;
		STRLEN nlen = dend - dstart + len + UTF8_MAXLEN;
		if (!grows)
		    Perl_croak(aTHX_ "panic: do_trans_complex_utf8");
		Renew(dstart, nlen+UTF8_MAXLEN, U8);
		d = dstart + clen;
		dend = dstart + nlen;
d527 6
a532 2
		d = uv_to_utf8(d, uv);
		s += UTF8SKIP(s);
d536 17
a552 4
		int i = UTF8SKIP(s);
		Copy(s, d, i, U8);
		d += i;
		s += i;
d557 6
a562 2
		d = uv_to_utf8(d, final);
		s += UTF8SKIP(s);
d565 3
a567 2
	    matches++;			/* "none+1" is delete character */
	    s += UTF8SKIP(s);
d570 2
a571 6
    if (grows || hibit) {
	sv_setpvn(sv, (char*)dstart, d - dstart);
	Safefree(dstart);
	if (grows && hibit)
	    Safefree(start);
    }
d574 1
a574 1
	SvCUR_set(sv, d - dstart);
a575 3
    SvUTF8_on(sv);
    if (!isutf8 && !(PL_hints & HINT_UTF8))
	sv_utf8_downgrade(sv, TRUE);
d584 1
a585 2
    I32 hasutf = (PL_op->op_private &
                    (OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF));
d595 1
a595 2
    if (!(PL_op->op_private & OPpTRANS_IDENTICAL))
	(void)SvPOK_only_UTF8(sv);
d599 1
a599 1
    switch (PL_op->op_private & ~hasutf & 63) {
d601 10
a610 4
	if (hasutf)
	    return do_trans_simple_utf8(sv);
	else
	    return do_trans_simple(sv);
d613 10
a622 4
	if (hasutf)
	    return do_trans_count_utf8(sv);
	else
	    return do_trans_count(sv);
d625 2
a626 2
	if (hasutf)
	    return do_trans_complex_utf8(sv);
d628 1
a628 1
	    return do_trans_complex(sv);
d647 1
a647 1
	    if (*mark && !SvGAMAGIC(*mark) && SvOK(*mark)) {
d661 8
a668 3
	sv_setpv(sv, "");
	if (*mark)
	    sv_catsv(sv, *mark);
d673 2
a674 1
    if (delimlen) {
d676 1
a676 1
	    sv_catsv(sv,del);
a699 1
/* currently converts input to bytes if possible, but doesn't sweat failure */
d709 1
a709 1
    if (size < 1 || (size & (size-1))) /* size < 1 or not a power of two */
a710 4

    if (SvUTF8(sv))
	(void) Perl_sv_utf8_downgrade(aTHX_ sv, TRUE);

d742 1
d782 1
a782 1
		    retnum =
d812 1
a831 4
/* currently converts input to bytes if possible but doesn't sweat failures,
 * although it does ensure that the string it clobbers is not marked as
 * utf8-valid any more
 */
a846 9
    if (SvUTF8(targ)) {
	/* This is handled by the SvPOK_only below...
	if (!Perl_sv_utf8_downgrade(aTHX_ targ, TRUE))
	    SvUTF8_off(targ);
	 */
	(void) Perl_sv_utf8_downgrade(aTHX_ targ, TRUE);
    }

    (void)SvPOK_only(targ);
a848 2
    if (offset < 0)
	Perl_croak(aTHX_ "Assigning to negative offset in vec");
d850 1
a850 1
    if (size < 1 || (size & (size-1))) /* size < 1 or not a power of two */
d852 1
a852 1

d860 1
a860 1

d885 1
d908 2
a909 1

d941 9
a949 9
	    while (s > start && UTF8_IS_CONTINUATION(*s))
		s--;
	    if (utf8_to_uv_simple((U8*)s, 0)) {
		sv_setpvn(astr, s, send - s);
		*s = '\0';
		SvCUR_set(sv, s - start);
		SvNIOK_off(sv);
		SvUTF8_on(astr);
	    }
d970 1
d1043 1
a1043 1
}
d1048 1
a1064 1
    I32 needlen;
d1068 1
a1068 1
    else if (!left_utf && right_utf)
d1077 1
a1077 5
    if ((left_utf || right_utf) && (sv == left || sv == right)) {
	needlen = optype == OP_BIT_AND ? len : leftlen + rightlen;
	Newz(801, dc, needlen + 1, char);
    }
    else if (SvOK(sv) || SvTYPE(sv) > SVt_PVMG) {
a1083 2
	if (optype != OP_BIT_AND && (left_utf || right_utf))
	    dc = SvGROW(sv, leftlen + rightlen + 1);
d1086 2
a1087 2
	needlen = ((optype == OP_BIT_AND)
		    ? len : (leftlen > rightlen ? leftlen : rightlen));
a1095 1
	char *dcsave = dc;
d1098 5
a1102 1
	STRLEN ulen;
d1107 1
a1107 1
		luc = utf8_to_uv((U8*)lc, lulen, &ulen, UTF8_ALLOW_ANYUV);
d1110 1
a1110 1
		ruc = utf8_to_uv((U8*)rc, rulen, &ulen, UTF8_ALLOW_ANYUV);
d1116 2
a1117 3
	    if (sv == left || sv == right)
		(void)sv_usepvn(sv, dcsave, needlen);
	    SvCUR_set(sv, dc - dcsave);
d1121 1
a1121 1
		luc = utf8_to_uv((U8*)lc, lulen, &ulen, UTF8_ALLOW_ANYUV);
d1124 1
a1124 1
		ruc = utf8_to_uv((U8*)rc, rulen, &ulen, UTF8_ALLOW_ANYUV);
d1133 1
a1133 1
		luc = utf8_to_uv((U8*)lc, lulen, &ulen, UTF8_ALLOW_ANYUV);
d1136 1
a1136 1
		ruc = utf8_to_uv((U8*)rc, rulen, &ulen, UTF8_ALLOW_ANYUV);
d1143 2
a1144 3
	    if (sv == left || sv == right)
		(void)sv_usepvn(sv, dcsave, needlen);
	    SvCUR_set(sv, dc - dcsave);
d1234 1
a1234 1
    dSP;
d1243 2
a1244 2

    if (PL_op->op_type == OP_RV2HV || PL_op->op_type == OP_PADHV)
d1248 1
a1248 1
	if (PL_op->op_flags & OPf_MOD || LVRET) {	/* lvalue */
d1267 1
a1267 1
	if (PL_op->op_flags & OPf_MOD || LVRET) {	/* lvalue */
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
a17 1
#ifndef PERL_MICRO
a20 1
#endif
d37 1
a37 1
	Perl_croak(aTHX_ "panic: do_trans_simple line %d",__LINE__);
d47 1
a47 1
		*s++ = (U8)ch;
d67 1
a67 1
	c = utf8n_to_uvchr(s, send - s, &ulen, 0);
d70 4
a73 1
	    d = uvchr_to_utf8(d, ch);
d96 1
a96 1
S_do_trans_count(pTHX_ SV *sv)
a102 1
    I32 complement = PL_op->op_private & OPpTRANS_COMPLEMENT;
d106 1
a106 1
	Perl_croak(aTHX_ "panic: do_trans_count line %d",__LINE__);
d120 2
a121 5
	    c = utf8n_to_uvchr(s, send - s, &ulen, 0);
	    if (c < 0x100) {
		if (tbl[c] >= 0)
		    matches++;
	    } else if (complement)
d130 1
a130 1
S_do_trans_complex(pTHX_ SV *sv)
d139 1
a139 3
    I32 complement = PL_op->op_private & OPpTRANS_COMPLEMENT;
    I32 del = PL_op->op_private & OPpTRANS_DELETE;
    STRLEN len, rlen = 0;
d145 1
a145 1
	Perl_croak(aTHX_ "panic: do_trans_complex line %d",__LINE__);
d157 1
a157 1
		    *d = (U8)ch;
d173 1
a173 1
		    *d++ = (U8)ch;
a190 2
	if (complement && !del)
	    rlen = tbl[0x100];
d197 1
d201 1
a201 1
	        UV comp = utf8_to_uvchr(s, &len);
d203 3
a205 19
		if (comp > 0xff) {
		    if (!complement) {
			Copy(s, d, len, U8);
			d += len;
		    }
		    else {
			matches++;
			if (!del) {
			    ch = (rlen == 0) ? comp :
				(comp - 0x100 < rlen) ?
				tbl[comp+1] : tbl[0x100+rlen];
			    if ((UV)ch != pch) {
				d = uvchr_to_utf8(d, ch);
				pch = (UV)ch;
			    }
			    s += len;
			    continue;
			}
		    }
d209 3
a211 3
		    if ((UV)ch != pch) {
		        d = uvchr_to_utf8(d, ch);
		        pch = (UV)ch;
d229 4
a232 15
	        UV comp = utf8_to_uvchr(s, &len);
		if (comp > 0xff) {
		    if (!complement) {
			Copy(s, d, len, U8);
			d += len;
		    }
		    else {
			matches++;
			if (!del) {
			    if (comp - 0x100 < rlen)
				d = uvchr_to_utf8(d, tbl[comp+1]);
			    else
				d = uvchr_to_utf8(d, tbl[0x100+rlen]);
			}
		    }
d235 1
a235 1
		    d = uvchr_to_utf8(d, ch);
d262 1
a262 1
S_do_trans_simple_utf8(pTHX_ SV *sv)
d278 1
a278 1
    UV final = 0;
d287 2
a288 3
	while (t < e) {
	    U8 ch = *t++;
	    if ((hibit = !NATIVE_IS_INVARIANT(ch)))
a289 1
	}
d312 1
a312 1
	if ((uv = swash_fetch(rv, s, TRUE)) < none) {
d315 1
a315 1
	    d = uvuni_to_utf8(d, uv);
d327 1
a327 1
	    d = uvuni_to_utf8(d, final);
d336 1
a336 1
		Perl_croak(aTHX_ "panic: do_trans_simple_utf8 line %d",__LINE__);
d354 2
d361 1
a361 1
S_do_trans_count_utf8(pTHX_ SV *sv)
d364 1
a364 1
    U8 *start = 0, *send;
a371 1
    UV extra = none + 1;
d378 2
a379 3
	while (t < e) {
	    U8 ch = *t++;
	    if ((hibit = !NATIVE_IS_INVARIANT(ch)))
a380 1
	}
d387 1
a387 1
	if ((uv = swash_fetch(rv, s, TRUE)) < none || uv == extra)
d398 1
a398 1
S_do_trans_complex_utf8(pTHX_ SV *sv)
d412 1
a412 2
    UV final = 0;
    bool havefinal = FALSE;
d423 2
a424 3
	while (t < e) {
	    U8 ch = *t++;
	    if ((hibit = !NATIVE_IS_INVARIANT(ch)))
a425 1
	}
d433 1
a433 1
    if (svp) {
a434 2
	havefinal = TRUE;
    }
d450 2
a451 2
	    uv = swash_fetch(rv, s, TRUE);
	
d456 1
a456 1
		    Perl_croak(aTHX_ "panic: do_trans_complex_utf8 line %d",__LINE__);
a462 1
		s += UTF8SKIP(s);
d464 1
a464 1
		    d = uvuni_to_utf8(d, uv);
d467 1
d480 3
a482 16
		if (havefinal) {
		    s += UTF8SKIP(s);
		    if (puv != final) {
			d = uvuni_to_utf8(d, final);
			puv = final;
		    }
		}
		else {
		    STRLEN len;
		    uv = utf8_to_uvuni(s, &len);
		    if (uv != puv) {
			Copy(s, d, len, U8);
			d += len;
			puv = uv;
		    }
		    s += len;
d484 1
d493 1
a493 1
	    uv = swash_fetch(rv, s, TRUE);
d498 1
a498 1
		    Perl_croak(aTHX_ "panic: do_trans_complex_utf8 line %d",__LINE__);
d505 1
a506 1
		d = uvuni_to_utf8(d, uv);
d518 1
a519 1
		d = uvuni_to_utf8(d, final);
d537 2
d551 3
a553 6
    if (SvREADONLY(sv)) {
        if (SvFAKE(sv))
            sv_force_normal(sv);
        if (SvREADONLY(sv) && !(PL_op->op_private & OPpTRANS_IDENTICAL))
            Perl_croak(aTHX_ PL_no_modify);
    }
a571 1
    case OPpTRANS_IDENTICAL|OPpTRANS_COMPLEMENT:
d592 1
a594 3
    (void) SvPV(del, delimlen); /* stringify and get the delimlen */
    /* SvCUR assumes it's SvPOK() and woe betide you if it's not. */

a612 4
    sv_setpv(sv, "");
    if (PL_tainting && SvMAGICAL(sv))
	SvTAINTED_off(sv);

d614 1
d619 2
a620 1

a640 3
    SvUTF8_off(sv);
    if (DO_UTF8(*sarg))
        SvUTF8_on(sv);
d671 1
a671 1
		if ((STRLEN)offset >= srclen)
d677 1
a677 1
		if ((STRLEN)offset >= srclen)
d679 1
a679 1
		else if ((STRLEN)(offset + 1) >= srclen)
d682 1
a682 1
		else if ((STRLEN)(offset + 2) >= srclen)
d695 1
a695 1
		    Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
d764 1
a764 1
		Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
d813 1
a813 1
	Perl_croak(aTHX_ "Negative offset to vec in lvalue context");
d822 1
a822 1
	(void)memzero((char *)(s + targlen), len - targlen + 1);
d837 1
a837 1
	    s[offset  ] = (U8)( lval        & 0xff);
d839 2
a840 2
	    s[offset  ] = (U8)((lval >>  8) & 0xff);
	    s[offset+1] = (U8)( lval        & 0xff);
d843 4
a846 4
	    s[offset  ] = (U8)((lval >> 24) & 0xff);
	    s[offset+1] = (U8)((lval >> 16) & 0xff);
	    s[offset+2] = (U8)((lval >>  8) & 0xff);
	    s[offset+3] = (U8)( lval        & 0xff);
d851 1
a851 1
		Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
d853 8
a860 8
	    s[offset  ] = (U8)((lval >> 56) & 0xff);
	    s[offset+1] = (U8)((lval >> 48) & 0xff);
	    s[offset+2] = (U8)((lval >> 40) & 0xff);
	    s[offset+3] = (U8)((lval >> 32) & 0xff);
	    s[offset+4] = (U8)((lval >> 24) & 0xff);
	    s[offset+5] = (U8)((lval >> 16) & 0xff);
	    s[offset+6] = (U8)((lval >>  8) & 0xff);
	    s[offset+7] = (U8)( lval        & 0xff);
d894 2
a895 8
    else if (SvREADONLY(sv)) {
        if (SvFAKE(sv)) {
            /* SV is copy-on-write */
	    sv_force_normal_flags(sv, 0);
        }
        if (SvREADONLY(sv))
            Perl_croak(aTHX_ PL_no_modify);
    }
d906 1
a906 1
	    if (utf8_to_uvchr((U8*)s, 0)) {
a934 1
    STRLEN n_a;
d963 2
a964 8
    else if (SvREADONLY(sv)) {
        if (SvFAKE(sv)) {
            /* SV is copy-on-write */
	    sv_force_normal_flags(sv, 0);
        }
        if (SvREADONLY(sv))
            Perl_croak(aTHX_ PL_no_modify);
    }
d966 2
d998 1
a998 1
	s = SvPV_force(sv, n_a);
a999 1
	*SvEND(sv) = '\0';
a1000 1
	SvSETMAGIC(sv);
d1003 1
d1026 1
a1026 1
    I32 needlen = 0;
d1046 2
a1047 2
	if (SvCUR(sv) < (STRLEN)len) {
	    dc = SvGROW(sv, (STRLEN)(len + 1));
d1072 1
a1072 1
		luc = utf8n_to_uvchr((U8*)lc, lulen, &ulen, UTF8_ALLOW_ANYUV);
d1075 1
a1075 1
		ruc = utf8n_to_uvchr((U8*)rc, rulen, &ulen, UTF8_ALLOW_ANYUV);
d1079 1
a1079 1
		dc = (char*)uvchr_to_utf8((U8*)dc, duc);
d1087 1
a1087 1
		luc = utf8n_to_uvchr((U8*)lc, lulen, &ulen, UTF8_ALLOW_ANYUV);
d1090 1
a1090 1
		ruc = utf8n_to_uvchr((U8*)rc, rulen, &ulen, UTF8_ALLOW_ANYUV);
d1094 1
a1094 1
		dc = (char*)uvchr_to_utf8((U8*)dc, duc);
d1099 1
a1099 1
		luc = utf8n_to_uvchr((U8*)lc, lulen, &ulen, UTF8_ALLOW_ANYUV);
d1102 1
a1102 1
		ruc = utf8n_to_uvchr((U8*)rc, rulen, &ulen, UTF8_ALLOW_ANYUV);
d1106 1
a1106 1
		dc = (char*)uvchr_to_utf8((U8*)dc, duc);
d1185 1
a1185 1
	    if (rightlen > (STRLEN)len)
d1187 1
a1187 1
	    else if (leftlen > (STRLEN)len)
d1237 1
a1237 1
		sv_magic(TARG, Nullsv, PERL_MAGIC_nkeys, Nullch, 0);
d1249 1
a1249 1
	if (! SvTIED_mg((SV*)keys, PERL_MAGIC_tied))
d1265 2
a1266 4
	if (dokeys) {
	    SV* sv = hv_iterkeysv(entry);
	    XPUSHs(sv);	/* won't clobber stack_sp */
	}
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, by Larry Wall and others
d44 1
a44 1
    /* First, take care of non-UTF-8 input strings, because they're easy */
d76 1
a76 1
	    Move(s, d, ulen, U8);
d254 1
a254 1
			Move(s, d, len, U8);
d354 1
a354 1
	    Move(s, d, i, U8);
d513 1
a513 1
		Move(s, d, i, U8);
d532 1
a532 1
			Move(s, d, len, U8);
d564 1
a564 1
		Move(s, d, i, U8);
d611 3
a613 3
    if (!(PL_op->op_private & OPpTRANS_IDENTICAL)) {
	if (!SvPOKp(sv))
	    (void)SvPV_force(sv, len);
a614 1
    }
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d20 1
d23 1
a672 4
    /* sv_setpv retains old UTF8ness [perl #24846] */
    if (SvUTF8(sv))
	SvUTF8_off(sv);

@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2004, by Larry Wall and others
d618 1
a618 3
    switch (PL_op->op_private & ~hasutf & (
		OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF|OPpTRANS_IDENTICAL|
		OPpTRANS_SQUASH|OPpTRANS_DELETE|OPpTRANS_COMPLEMENT)) {
d670 1
a670 1
    sv_setpvn(sv, "", 0);
a1008 2
    char *temp_buffer = NULL;
    SV* svrecode = Nullsv;
a1043 12

    if (PL_encoding) {
	if (!SvUTF8(sv)) {
	/* XXX, here sv is utf8-ized as a side-effect!
	   If encoding.pm is used properly, almost string-generating
	   operations, including literal strings, chr(), input data, etc.
	   should have been utf8-ized already, right?
	*/
	    sv_recode_to_utf8(sv, PL_encoding);
	}
    }

d1058 1
a1058 1
	    STRLEN rslen, rs_charlen;
a1059 35

	    rs_charlen = SvUTF8(PL_rs)
		? sv_len_utf8(PL_rs)
		: rslen;

	    if (SvUTF8(PL_rs) != SvUTF8(sv)) {
		/* Assumption is that rs is shorter than the scalar.  */
		if (SvUTF8(PL_rs)) {
		    /* RS is utf8, scalar is 8 bit.  */
		    bool is_utf8 = TRUE;
		    temp_buffer = (char*)bytes_from_utf8((U8*)rsptr,
							 &rslen, &is_utf8);
		    if (is_utf8) {
			/* Cannot downgrade, therefore cannot possibly match
			 */
			assert (temp_buffer == rsptr);
			temp_buffer = NULL;
			goto nope;
		    }
		    rsptr = temp_buffer;
		}
		else if (PL_encoding) {
		    /* RS is 8 bit, encoding.pm is used.
		     * Do not recode PL_rs as a side-effect. */
		   svrecode = newSVpvn(rsptr, rslen);
		   sv_recode_to_utf8(svrecode, PL_encoding);
		   rsptr = SvPV(svrecode, rslen);
		   rs_charlen = sv_len_utf8(svrecode);
		}
		else {
		    /* RS is 8 bit, scalar is utf8.  */
		    temp_buffer = (char*)bytes_to_utf8((U8*)rsptr, &rslen);
		    rsptr = temp_buffer;
		}
	    }
d1072 1
a1072 1
		count += rs_charlen;
a1081 5

    if (svrecode)
	 SvREFCNT_dec(svrecode);

    Safefree(temp_buffer);
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@a14 5
/* This file contains some common functions needed to carry out certain
 * ops. For example both pp_schomp() and pp_chomp() - scalar and array
 * chomp operations - call the function do_chomp() found in this file.
 */

@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2004, 2005, 2006, by Larry Wall and others
d33 1
a33 1
    const U8 *send;
d36 1
a36 1
    const I32 grows = PL_op->op_private & OPpTRANS_GROWS;
d38 2
d41 1
a41 1
    const short *tbl = (short*)cPVOP->op_pv;
d51 1
a51 2
	    const I32 ch = tbl[*s];
	    if (ch >= 0) {
d64 1
a64 1
	Newx(d, len*2+1, U8);
d70 1
a70 1
	I32 ch;
d73 1
a73 1
	const UV c = utf8n_to_uvchr(s, send - s, &ulen, 0);
d101 2
a102 2
    const U8 *s;
    const U8 *send;
d105 2
a106 1
    const I32 complement = PL_op->op_private & OPpTRANS_COMPLEMENT;
d108 1
a108 1
    const short * const tbl = (short*)cPVOP->op_pv;
d112 1
a112 1
    s = (const U8*)SvPV_const(sv, len);
d122 1
d124 1
a124 1
	    const UV c = utf8n_to_uvchr((U8 *)s, send - s, &ulen, 0);
d145 3
a147 3
    const I32 grows = PL_op->op_private & OPpTRANS_GROWS;
    const I32 complement = PL_op->op_private & OPpTRANS_COMPLEMENT;
    const I32 del = PL_op->op_private & OPpTRANS_DELETE;
d149 2
d152 1
a152 1
    const short * const tbl = (short*)cPVOP->op_pv;
d163 1
a163 1
	    const U8* p = send;
d165 1
a165 2
		const I32 ch = tbl[*s];
		if (ch >= 0) {
d180 1
a180 2
		const I32 ch = tbl[*s];
		if (ch >= 0) {
d196 1
a196 1
	    Newx(d, len*2+1, U8);
d211 1
a211 2
		const UV comp = utf8_to_uvchr(s, &len);
		I32 ch;
d255 1
a255 2
		const UV comp = utf8_to_uvchr(s, &len);
		I32 ch;
d307 1
a307 1
    const I32 grows = PL_op->op_private & OPpTRANS_GROWS;
d310 2
a311 2
    SV* const  rv = (SV*)cSVOP->op_sv;
    HV* const  hv = (HV*)SvRV(rv);
d313 2
a314 2
    const UV none = svp ? SvUV(*svp) : 0x7fffffff;
    const UV extra = none + 1;
d323 1
a323 1
	const U8 *t = s, *e = s + len;
d325 1
a325 1
	    const U8 ch = *t++;
d341 1
a341 1
	Newx(d, len * 3 + UTF8_MAXBYTES, U8);
d357 1
a357 1
	    const int i = UTF8SKIP(s);
d363 2
a364 1
	    s += UTF8SKIP(s);
d372 2
a373 2
	    const STRLEN clen = d - dstart;
	    const STRLEN nlen = dend - dstart + len + UTF8_MAXBYTES;
d376 1
a376 1
	    Renew(dstart, nlen + UTF8_MAXBYTES, U8);
d400 2
a401 2
    const U8 *s;
    const U8 *start = 0, *send;
d405 6
a410 5
    SV* const rv = (SV*)cSVOP->op_sv;
    HV* const hv = (HV*)SvRV(rv);
    SV** const svp = hv_fetch(hv, "NONE", 4, FALSE);
    const UV none = svp ? SvUV(*svp) : 0x7fffffff;
    const UV extra = none + 1;
d413 1
a413 1
    s = (const U8*)SvPV_const(sv, len);
d415 1
a415 2
	const U8 *t = s;
	const U8 *e = s + len;
d417 1
a417 1
	    const U8 ch = *t++;
d422 1
a422 1
	    start = s = bytes_to_utf8((U8 *)s, &len);
d427 1
a427 2
	UV uv;
	if ((uv = swash_fetch(rv, (U8 *)s, TRUE)) < none || uv == extra)
d440 1
d444 5
a448 5
    const I32 squash   = PL_op->op_private & OPpTRANS_SQUASH;
    const I32 del      = PL_op->op_private & OPpTRANS_DELETE;
    const I32 grows    = PL_op->op_private & OPpTRANS_GROWS;
    SV * const rv = (SV*)cSVOP->op_sv;
    HV * const hv = (HV*)SvRV(rv);
d450 2
a451 2
    const UV none = svp ? SvUV(*svp) : 0x7fffffff;
    const UV extra = none + 1;
d454 1
d457 1
d460 2
a461 2
    U8 *s = (U8*)SvPV(sv, len);
    const I32 isutf8 = SvUTF8(sv);
d463 1
a463 2
	const U8 *t = s;
	const U8 * const e = s + len;
d465 1
a465 1
	    const U8 ch = *t++;
d483 1
a483 1
	Newx(d, len * 3 + UTF8_MAXBYTES, U8);
d495 1
a495 1
	    UV uv = swash_fetch(rv, s, TRUE);
d498 2
a499 2
		const STRLEN clen = d - dstart;
		const STRLEN nlen = dend - dstart + len + UTF8_MAXBYTES;
d502 1
a502 1
		Renew(dstart, nlen + UTF8_MAXBYTES, U8);
d516 1
a516 1
		const int i = UTF8SKIP(s);
d550 1
a550 1
	    const UV uv = swash_fetch(rv, s, TRUE);
d552 2
a553 2
	        const STRLEN clen = d - dstart;
		const STRLEN nlen = dend - dstart + len + UTF8_MAXBYTES;
d556 1
a556 1
		Renew(dstart, nlen + UTF8_MAXBYTES, U8);
d567 1
a567 1
		const int i = UTF8SKIP(s);
d603 1
a603 1
    const I32 hasutf = (PL_op->op_private &
d612 1
a612 1
    (void)SvPV_const(sv, len);
d650 1
a650 1
    SV ** const oldmark = mark;
d654 1
d656 1
a656 1
    (void) SvPV_const(del, delimlen); /* stringify and get the delimlen */
d665 1
a665 2
		STRLEN tmplen;
		SvPV_const(*mark, tmplen);
d679 2
a680 1
    SvUTF8_off(sv);
d708 1
a708 1
    const char * const pat = SvPV_const(*sarg, patlen);
d725 1
a725 1
    const unsigned char *s = (const unsigned char *) SvPV_const(sv, srclen);
d948 1
d950 2
a951 3
	const I32 max = AvFILL(av);

	for (i = 0; i <= max; i++) {
d962 1
a974 7

    if (PL_encoding && !SvUTF8(sv)) {
	/* like in do_chomp(), utf8-ize the sv as a side-effect
	 * if we're using encoding. */
	sv_recode_to_utf8(sv, PL_encoding);
    }

d985 1
a985 1
	    if (is_utf8_string((U8*)s, send - s)) {
d1014 1
d1026 4
a1029 4
	AV* const av = (AV*)sv;
	const I32 max = AvFILL(av);

	for (i = 0; i <= max; i++) {
d1037 1
a1037 1
	HV* const hv = (HV*)sv;
d1040 1
d1080 1
a1080 1
	    const char *rsptr = SvPV_const(PL_rs, rslen);
d1107 1
a1107 1
		   rsptr = SvPV_const(svrecode, rslen);
d1131 1
a1131 1
	s = SvPV_force_nolen(sv);
d1157 2
a1158 2
    register const char *lc;
    register const char *rc;
d1161 4
a1164 4
    const char *lsave;
    const char *rsave;
    const bool left_utf = DO_UTF8(left);
    const bool right_utf = DO_UTF8(right);
d1174 2
a1175 2
    lsave = lc = SvPV_const(left, leftlen);
    rsave = rc = SvPV_const(right, rightlen);
d1180 1
a1180 1
	Newxz(dc, needlen + 1, char);
d1183 3
a1185 4
	/* Fix this to nong when change 22613 is integrated.
	   (Which in turn awaits merging sv_2iv and sv_2uv)  */
	dc = SvPV_force_nolen(sv);
	if (SvLEN(sv) < (STRLEN)(len + 1)) {
d1195 1
a1195 1
	Newxz(dc, needlen + 1, char);
d1269 1
a1269 1
	const I32 remainder = len % (sizeof(long)*4);
a1313 1
	    *dc = '\0';
d1344 4
a1347 4
    const I32 gimme = GIMME_V;
    const I32 dokv =     (PL_op->op_type == OP_RV2HV || PL_op->op_type == OP_PADHV);
    const I32 dokeys =   dokv || (PL_op->op_type == OP_KEYS);
    const I32 dovalues = dokv || (PL_op->op_type == OP_VALUES);
d1350 3
d1392 1
d1405 1
a1405 1
	    SV* const sv = hv_iterkeysv(entry);
a1408 1
	    SV *tmpstr;
d1414 1
a1414 1
			    (int)HvMAX(keys)+1,
a1423 9
/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2004, 2005, 2006, 2007, by Larry Wall and others
d29 1
a29 1
S_do_trans_simple(pTHX_ SV * const sv)
d31 4
a34 1
    dVAR;
d36 1
a37 2
    U8 *s = (U8*)SvPV(sv,len);
    U8 * const send = s+len;
d39 1
a39 1
    const short * const tbl = (short*)cPVOP->op_pv;
d43 3
d52 1
a52 1
		*s = (U8)ch;
d54 2
a55 1
	    s++;
d58 1
a59 4
    else {
	const I32 grows = PL_op->op_private & OPpTRANS_GROWS;
	U8 *d;
	U8 *dstart;
d61 9
a69 9
	/* Allow for expansion: $_="a".chr(400); tr/a/\xFE/, FE needs encoding */
	if (grows)
	    Newx(d, len*2+1, U8);
	else
	    d = s;
	dstart = d;
	while (s < send) {
	    STRLEN ulen;
	    I32 ch;
d71 20
a90 23
	    /* Need to check this, otherwise 128..255 won't match */
	    const UV c = utf8n_to_uvchr(s, send - s, &ulen, UTF8_ALLOW_DEFAULT);
	    if (c < 0x100 && (ch = tbl[c]) >= 0) {
		matches++;
		d = uvchr_to_utf8(d, ch);
		s += ulen;
	    }
	    else { /* No match -> copy */
		Move(s, d, ulen, U8);
		d += ulen;
		s += ulen;
	    }
	}
	if (grows) {
	    sv_setpvn(sv, (char*)dstart, d - dstart);
	    Safefree(dstart);
	}
	else {
	    *d = '\0';
	    SvCUR_set(sv, d - dstart);
	}
	SvUTF8_on(sv);
	SvSETMAGIC(sv);
d92 2
d98 1
a98 1
S_do_trans_count(pTHX_ SV * const sv)
d100 3
a102 1
    dVAR;
d104 1
a104 3
    const U8 *s = (const U8*)SvPV_const(sv, len);
    const U8 * const send = s + len;
    I32 matches = 0;
d110 4
a113 1
    if (!SvUTF8(sv)) {
d118 1
a118 3
    }
    else {
	const I32 complement = PL_op->op_private & OPpTRANS_COMPLEMENT;
d121 1
a121 1
	    const UV c = utf8n_to_uvchr(s, send - s, &ulen, UTF8_ALLOW_DEFAULT);
a128 1
    }
d134 1
a134 1
S_do_trans_complex(pTHX_ SV * const sv)
d136 5
a140 4
    dVAR;
    STRLEN len;
    U8 *s = (U8*)SvPV(sv, len);
    U8 * const send = s+len;
d142 4
d151 3
a153 3
    if (!SvUTF8(sv)) {
	U8 *d = s;
	U8 * const dstart = d;
d155 2
d191 1
a191 8
    else { /* is utf8 */
	const I32 complement = PL_op->op_private & OPpTRANS_COMPLEMENT;
	const I32 grows = PL_op->op_private & OPpTRANS_GROWS;
	const I32 del = PL_op->op_private & OPpTRANS_DELETE;
	U8 *d;
	U8 *dstart;
	STRLEN rlen = 0;

d208 1
a208 2
		const UV comp = utf8n_to_uvchr(s, send - s, &len,
					       UTF8_ALLOW_DEFAULT);
d213 1
a213 1
			Move(s, d, len, U8);
d219 1
a219 1
			    ch = (rlen == 0) ? (I32)comp :
d241 1
a241 1
		    Move(s, d, len, U8);
d253 1
a253 2
		const UV comp = utf8n_to_uvchr(s, send - s, &len,
					       UTF8_ALLOW_DEFAULT);
d275 1
a275 1
		    Move(s, d, len, U8);
d298 1
a298 1
S_do_trans_simple_utf8(pTHX_ SV * const sv)
a299 1
    dVAR;
d309 1
a309 6
    SV* const  rv =
#ifdef USE_ITHREADS
		    PAD_SVl(cPADOP->op_padix);
#else
		    (SV*)cSVOP->op_sv;
#endif
d311 1
a311 1
    SV* const * svp = hv_fetchs(hv, "NONE", FALSE);
d315 2
d320 3
a322 3
    if (!SvUTF8(sv)) {
	const U8 *t = s;
	const U8 * const e = s + len;
d325 1
a325 3
	    hibit = !NATIVE_IS_INVARIANT(ch);
	    if (hibit) {
		s = bytes_to_utf8(s, &len);
a326 1
	    }
d328 2
d334 1
a334 1
    svp = hv_fetchs(hv, "FINAL", FALSE);
d350 1
a350 2
	const UV uv = swash_fetch(rv, s, TRUE);
	if (uv < none) {
d396 1
a396 1
S_do_trans_count_utf8(pTHX_ SV * const sv)
a397 1
    dVAR;
d399 1
a399 2
    const U8 *start = NULL;
    const U8 *send;
d403 1
a403 6
    SV* const  rv =
#ifdef USE_ITHREADS
		    PAD_SVl(cPADOP->op_padix);
#else
		    (SV*)cSVOP->op_sv;
#endif
d405 1
a405 1
    SV* const * const svp = hv_fetchs(hv, "NONE", FALSE);
d413 1
a413 1
	const U8 * const e = s + len;
d416 1
a416 3
	    hibit = !NATIVE_IS_INVARIANT(ch);
	    if (hibit) {
		start = s = bytes_to_utf8(s, &len);
a417 1
	    }
d419 2
d425 2
a426 2
	const UV uv = swash_fetch(rv, s, TRUE);
	if (uv < none || uv == extra)
d437 1
a437 1
S_do_trans_complex_utf8(pTHX_ SV * const sv)
a438 1
    dVAR;
d445 1
a445 6
    SV* const  rv =
#ifdef USE_ITHREADS
		    PAD_SVl(cPADOP->op_padix);
#else
		    (SV*)cSVOP->op_sv;
#endif
d447 1
a447 1
    SV * const *svp = hv_fetchs(hv, "NONE", FALSE);
d457 2
a458 1
    if (!SvUTF8(sv)) {
d463 1
a463 3
	    hibit = !NATIVE_IS_INVARIANT(ch);
	    if (hibit) {
		s = bytes_to_utf8(s, &len);
a464 1
	    }
d466 2
d472 1
a472 1
    svp = hv_fetchs(hv, "FINAL", FALSE);
d531 1
a531 1
		    uv = utf8n_to_uvuni(s, send - s, &len, UTF8_ALLOW_DEFAULT);
a598 1
    dVAR;
d604 2
a605 2
        if (SvIsCOW(sv))
            sv_force_normal_flags(sv, 0);
d645 1
a645 1
Perl_do_join(pTHX_ register SV *sv, SV *delim, register SV **mark, register SV **sp)
a646 1
    dVAR;
d652 1
a652 1
    (void) SvPV_const(delim, delimlen); /* stringify and get the delimlen */
d657 1
a657 1
    SvUPGRADE(sv, SVt_PV);
d689 1
a689 1
	    sv_catsv(sv,delim);
a702 1
    dVAR;
d710 1
a710 1
    sv_vsetpvfn(sv, pat, patlen, NULL, sarg + 1, len - 1, &do_taint);
d720 1
a720 2
    dVAR;
    STRLEN srclen, len, uoffset, bitoffs = 0;
d725 1
a725 1
	return 0;
d732 2
a733 10
    if (size < 8) {
	bitoffs = ((offset%8)*size)%8;
	uoffset = offset/(8/size);
    }
    else if (size > 8)
	uoffset = offset*(size/8);
    else
	uoffset = offset;

    len = uoffset + (bitoffs + size + 7)/8;	/* required number of bytes */
d738 1
d740 1
a740 1
		if (uoffset >= srclen)
d743 1
a743 1
		    retnum = (UV) s[uoffset] <<  8;
d746 1
a746 1
		if (uoffset >= srclen)
d748 1
a748 1
		else if (uoffset + 1 >= srclen)
d750 2
a751 2
			((UV) s[uoffset    ] << 24);
		else if (uoffset + 2 >= srclen)
d753 2
a754 2
			((UV) s[uoffset    ] << 24) +
			((UV) s[uoffset + 1] << 16);
d757 3
a759 3
			((UV) s[uoffset    ] << 24) +
			((UV) s[uoffset + 1] << 16) +
			(     s[uoffset + 2] <<  8);
d766 1
a766 1
		if (uoffset >= srclen)
d768 1
a768 1
		else if (uoffset + 1 >= srclen)
d770 2
a771 2
			(UV) s[uoffset     ] << 56;
		else if (uoffset + 2 >= srclen)
d773 3
a775 3
			((UV) s[uoffset    ] << 56) +
			((UV) s[uoffset + 1] << 48);
		else if (uoffset + 3 >= srclen)
d777 4
a780 4
			((UV) s[uoffset    ] << 56) +
			((UV) s[uoffset + 1] << 48) +
			((UV) s[uoffset + 2] << 40);
		else if (uoffset + 4 >= srclen)
d782 5
a786 5
			((UV) s[uoffset    ] << 56) +
			((UV) s[uoffset + 1] << 48) +
			((UV) s[uoffset + 2] << 40) +
			((UV) s[uoffset + 3] << 32);
		else if (uoffset + 5 >= srclen)
d788 6
a793 6
			((UV) s[uoffset    ] << 56) +
			((UV) s[uoffset + 1] << 48) +
			((UV) s[uoffset + 2] << 40) +
			((UV) s[uoffset + 3] << 32) +
			(     s[uoffset + 4] << 24);
		else if (uoffset + 6 >= srclen)
d795 6
a800 6
			((UV) s[uoffset    ] << 56) +
			((UV) s[uoffset + 1] << 48) +
			((UV) s[uoffset + 2] << 40) +
			((UV) s[uoffset + 3] << 32) +
			((UV) s[uoffset + 4] << 24) +
			((UV) s[uoffset + 5] << 16);
d803 7
a809 7
			((UV) s[uoffset    ] << 56) +
			((UV) s[uoffset + 1] << 48) +
			((UV) s[uoffset + 2] << 40) +
			((UV) s[uoffset + 3] << 32) +
			((UV) s[uoffset + 4] << 24) +
			((UV) s[uoffset + 5] << 16) +
			(     s[uoffset + 6] <<  8);
d815 1
a815 1
	retnum = (s[uoffset] >> bitoffs) & ((1 << size) - 1);
d817 1
d819 1
a819 1
	    retnum = s[uoffset];
d822 2
a823 2
		((UV) s[uoffset] <<      8) +
		      s[uoffset + 1];
d826 4
a829 4
		((UV) s[uoffset    ] << 24) +
		((UV) s[uoffset + 1] << 16) +
		(     s[uoffset + 2] <<  8) +
		      s[uoffset + 3];
d836 8
a843 8
		((UV) s[uoffset    ] << 56) +
		((UV) s[uoffset + 1] << 48) +
		((UV) s[uoffset + 2] << 40) +
		((UV) s[uoffset + 3] << 32) +
		((UV) s[uoffset + 4] << 24) +
		((UV) s[uoffset + 5] << 16) +
		(     s[uoffset + 6] <<  8) +
		      s[uoffset + 7];
d858 2
a859 2
    dVAR;
    register I32 offset, bitoffs = 0;
a865 1
    SV * const targ = LvTARG(sv);
d887 2
a888 8
    if (size < 8) {
	bitoffs = ((offset%8)*size)%8;
	offset /= 8/size;
    }
    else if (size > 8)
	offset *= size/8;

    len = offset + (bitoffs + size + 7)/8;	/* required number of bytes */
d897 1
d899 3
a901 2
	s[offset] &= ~(mask << bitoffs);
	s[offset] |= lval << bitoffs;
d904 1
a938 1
    dVAR;
d944 1
a944 1
	AV* const av = (AV*)sv;
d955 1
a955 1
	HV* const hv = (HV*)sv;
d982 2
a983 2
	    char * const send = s + len;
	    char * const start = s;
a1013 1
    dVAR;
d1018 1
a1018 1
    SV* svrecode = NULL;
a1148 1
    dVAR;
d1159 2
a1160 2
    register STRLEN len;
    STRLEN lensave;
d1163 3
a1165 3
    bool left_utf;
    bool right_utf;
    STRLEN needlen = 0;
d1167 4
d1174 2
a1175 25
    lsave = lc = SvPV_nomg_const(left, leftlen);
    rsave = rc = SvPV_nomg_const(right, rightlen);

    /* This need to come after SvPV to ensure that string overloading has
       fired off.  */

    left_utf = DO_UTF8(left);
    right_utf = DO_UTF8(right);

    if (left_utf && !right_utf) {
	/* Avoid triggering overloading again by using temporaries.
	   Maybe there should be a variant of sv_utf8_upgrade that takes pvn
	*/
	right = sv_2mortal(newSVpvn(rsave, rightlen));
	sv_utf8_upgrade(right);
	rsave = rc = SvPV_nomg_const(right, rightlen);
	right_utf = TRUE;
    }
    else if (!left_utf && right_utf) {
	left = sv_2mortal(newSVpvn(lsave, leftlen));
	sv_utf8_upgrade(left);
	lsave = lc = SvPV_nomg_const(left, leftlen);
	left_utf = TRUE;
    }

a1177 2
    SvCUR_set(sv, len);
    (void)SvPOK_only(sv);
d1183 5
a1187 3
	dc = SvPV_force_nomg_nolen(sv);
	if (SvLEN(sv) < len + 1) {
	    dc = SvGROW(sv, len + 1);
d1194 2
a1195 2
	needlen = optype == OP_BIT_AND
		    ? len : (leftlen > rightlen ? leftlen : rightlen);
d1197 1
a1197 1
	sv_usepvn_flags(sv, dc, needlen, SV_HAS_TRAILING_NUL);
d1200 2
d1204 1
a1204 2
	char *dcorig = dc;
	char *dcsave = NULL;
d1222 2
a1223 2
		(void)sv_usepvn(sv, dcorig, needlen);
	    SvCUR_set(sv, dc - dcorig);
a1248 4
	    if (rulen)
		dcsave = savepvn(rc, rulen);
	    else if (lulen)
		dcsave = savepvn(lc, lulen);
d1250 2
a1251 2
		(void)sv_usepvn(sv, dcorig, needlen); /* Uses Renew(). */
	    SvCUR_set(sv, dc - dcorig);
d1253 1
a1253 1
		sv_catpvn(sv, dcsave, rulen);
d1255 1
a1255 1
		sv_catpvn(sv, dcsave, lulen);
a1257 1
	    Safefree(dcsave);
a1258 5
	default:
	    if (sv == left || sv == right)
		Safefree(dcorig);
	    Perl_croak(aTHX_ "panic: do_vop called for op %u (%s)",
			(unsigned)optype, PL_op_name[optype]);
d1266 3
a1268 3
	!((unsigned long)dc % sizeof(long)) &&
	!((unsigned long)lc % sizeof(long)) &&
	!((unsigned long)rc % sizeof(long)))	/* It's almost always aligned... */
d1270 1
a1270 1
	const STRLEN remainder = len % (sizeof(long)*4);
d1326 1
a1326 1
	    if (rightlen > len)
a1341 1
    dVAR;
d1343 1
a1343 1
    HV * const hv = (HV*)POPs;
d1350 1
d1356 1
a1356 1
		LvTARG(TARG) = NULL;
d1362 1
a1362 1
    keys = hv;
d1375 1
a1375 1
		sv_magic(TARG, NULL, PERL_MAGIC_nkeys, NULL, 0);
d1381 1
a1381 1
		LvTARG(TARG) = SvREFCNT_inc_simple(keys);
d1387 1
a1387 2
	if (! SvTIED_mg((SV*)keys, PERL_MAGIC_tied) )
	{
a1388 1
	}
d1409 2
a1410 1
	    tmpstr = hv_iterval(hv,entry);
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
d12 1
a12 3
 *  'So that was the job I felt I had to do when I started,' thought Sam.
 *
 *     [p.934 of _The Lord of the Rings_, VI/iii: "Mount Doom"]
d36 1
a37 3

    PERL_ARGS_ASSERT_DO_TRANS_SIMPLE;

d103 1
a104 3

    PERL_ARGS_ASSERT_DO_TRANS_COUNT;

d139 1
a140 3

    PERL_ARGS_ASSERT_DO_TRANS_COMPLEX;

d309 1
d314 1
a314 1
		    MUTABLE_SV(cSVOP->op_sv);
d316 1
a316 1
    HV* const  hv = MUTABLE_HV(SvRV(rv));
a322 2
    PERL_ARGS_ASSERT_DO_TRANS_SIMPLE_UTF8;

d410 1
d415 1
a415 1
		    MUTABLE_SV(cSVOP->op_sv);
d417 1
a417 1
    HV* const hv = MUTABLE_HV(SvRV(rv));
a422 2
    PERL_ARGS_ASSERT_DO_TRANS_COUNT_UTF8;

d464 1
a464 1
		    MUTABLE_SV(cSVOP->op_sv);
d466 1
a466 1
    HV * const hv = MUTABLE_HV(SvRV(rv));
d475 1
a476 3

    PERL_ARGS_ASSERT_DO_TRANS_COMPLEX_UTF8;

d624 1
a624 3
    PERL_ARGS_ASSERT_DO_TRANS;

    if (SvREADONLY(sv) && !(PL_op->op_private & OPpTRANS_IDENTICAL)) {
d627 2
a628 2
        if (SvREADONLY(sv))
            Perl_croak(aTHX_ "%s", PL_no_modify);
a673 2
    PERL_ARGS_ASSERT_DO_JOIN;

d696 1
a696 1
    sv_setpvs(sv, "");
a729 2
    PERL_ARGS_ASSERT_DO_SPRINTF;

a747 2
    PERL_ARGS_ASSERT_DO_VECGET;

a897 2
    PERL_ARGS_ASSERT_DO_VECSET;

a976 2
    PERL_ARGS_ASSERT_DO_CHOP;

d979 1
a979 1
	AV *const av = MUTABLE_AV(sv);
d983 1
a983 1
	    sv = MUTABLE_SV(av_fetch(av, i, FALSE));
d990 1
a990 1
	HV* const hv = MUTABLE_HV(sv);
d1003 1
a1003 1
            Perl_croak(aTHX_ "%s", PL_no_modify);
d1014 1
a1014 1
	s = SvPV_force_nomg(sv, len);
d1031 1
a1031 1
	    sv_setpvs(astr, "");
d1042 1
a1042 1
	sv_setpvs(astr, "");
a1055 2
    PERL_ARGS_ASSERT_DO_CHOMP;

d1063 1
a1063 1
	AV *const av = MUTABLE_AV(sv);
d1067 1
a1067 1
	    sv = MUTABLE_SV(av_fetch(av, i, FALSE));
d1074 1
a1074 1
	HV* const hv = MUTABLE_HV(sv);
d1087 1
a1087 1
            Perl_croak(aTHX_ "%s", PL_no_modify);
a1203 1
    PERL_ARGS_ASSERT_DO_VOP;
d1206 2
a1207 8
	sv_setpvs(sv, "");	/* avoid undef warning on |= and ^= */
    if (sv == left) {
	lsave = lc = SvPV_force_nomg(left, leftlen);
    }
    else {
	lsave = lc = SvPV_nomg_const(left, leftlen);
	SvPV_force_nomg_nolen(sv);
    }
d1220 1
a1220 1
	right = newSVpvn_flags(rsave, rightlen, SVs_TEMP);
d1226 1
a1226 1
	left = newSVpvn_flags(lsave, leftlen, SVs_TEMP);
d1409 1
a1409 1
    HV * const hv = MUTABLE_HV(POPs);
d1443 1
a1443 1
	    if (LvTARG(TARG) != (const SV *)keys) {
d1452 1
a1452 1
	if (! SvTIED_mg((const SV *)keys, PERL_MAGIC_tied) )
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@d206 4
d814 3
a816 2
		Perl_ck_warner(aTHX_ packWARN(WARN_PORTABLE),
			       "Bit vector size > 32 non-portable");
d882 3
a884 2
	    Perl_ck_warner(aTHX_ packWARN(WARN_PORTABLE),
			   "Bit vector size > 32 non-portable");
d975 3
a977 2
	    Perl_ck_warner(aTHX_ packWARN(WARN_PORTABLE),
			   "Bit vector size > 32 non-portable");
d1201 2
a1202 1
    SvREFCNT_dec(svrecode);
d1477 2
a1478 1
		SvREFCNT_dec(LvTARG(TARG));
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d36 1
a36 1
    U8 *s = (U8*)SvPV_nomg(sv,len);
d104 1
a104 1
    const U8 *s = (const U8*)SvPV_nomg_const(sv, len);
d142 1
a142 1
    U8 *s = (U8*)SvPV_nomg(sv, len);
d328 1
a328 1
    s = (U8*)SvPV_nomg(sv, len);
d429 1
a429 1
    s = (const U8*)SvPV_nomg_const(sv, len);
d481 1
a481 1
    U8 *s = (U8*)SvPV_nomg(sv, len);
d638 1
a638 1
            Perl_croak_no_modify(aTHX);
d645 1
a645 1
	    (void)SvPV_force_nomg(sv, len);
a743 8
    if (SvTAINTED(*sarg))
	TAINT_PROPER(
		(PL_op && PL_op->op_type < OP_max)
		    ? (PL_op->op_type == OP_PRTF)
			? "printf"
			: PL_op_name[PL_op->op_type]
		    : "(unknown)"
	);
d986 215
d1224 1
a1224 1
    if (sv != left || (optype != OP_BIT_AND && !SvOK(sv)))
d1434 2
a1435 1
    HV * const keys = MUTABLE_HV(POPs);
d1439 2
a1440 3
    /* op_type is OP_RKEYS/OP_RVALUES if pp_rkeys delegated to here */
    const I32 dokeys =   dokv || (PL_op->op_type == OP_KEYS || PL_op->op_type == OP_RKEYS);
    const I32 dovalues = dokv || (PL_op->op_type == OP_VALUES || PL_op->op_type == OP_RVALUES);
d1442 11
d1459 3
d1463 16
a1478 5
	    SV * const ret = sv_2mortal(newSV_type(SVt_PVLV));  /* Not TARG RT#67838 */
	    sv_magic(ret, NULL, PERL_MAGIC_nkeys, NULL, 0);
	    LvTYPE(ret) = 'k';
	    LvTARG(ret) = SvREFCNT_inc_simple(keys);
	    PUSHs(ret);
d1481 2
a1482 11
	    IV i;
	    dTARGET;

	    if (! SvTIED_mg((const SV *)keys, PERL_MAGIC_tied) ) {
		i = HvUSEDKEYS(keys);
	    }
	    else {
		i = 0;
		while (hv_iternext(keys)) i++;
	    }
	    PUSHi( i );
d1484 1
d1488 1
a1488 1
    EXTEND(SP, HvUSEDKEYS(keys) * (dokeys + dovalues));
d1500 1
a1500 1
	    tmpstr = hv_iterval(keys,entry);
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d635 4
a638 2
        if (!SvIsCOW(sv))
            Perl_croak_no_modify();
d644 1
a644 1
	if (!SvPOKp(sv) || SvTHINKFIRST(sv))
d676 1
a676 1
Perl_do_join(pTHX_ SV *sv, SV *delim, SV **mark, SV **sp)
d680 2
a681 2
    I32 items = sp - mark;
    STRLEN len;
d712 1
a712 1
    if (TAINTING_get && SvMAGICAL(sv))
d723 1
a723 1
	    sv_catsv_nomg(sv,delim);
d763 1
a763 1
Perl_do_vecget(pTHX_ SV *sv, SSize_t offset, int size)
d767 1
a767 3
    const unsigned char *s = (const unsigned char *) SvPV_flags_const(sv, srclen,
                             SV_GMAGIC | ((PL_op->op_flags & OPf_MOD || LVRET)
                                          ? SV_UNDEF_RETURNS_NULL : 0));
a769 4
    if (!s) {
      s = (const unsigned char *)"";
    }
    
d911 4
a914 4
    SSize_t offset, bitoffs = 0;
    int size;
    unsigned char *s;
    UV lval;
d924 1
a924 2
    s = (unsigned char*)SvPV_force_flags(targ, targlen,
                                         SV_GMAGIC | SV_UNDEF_RETURNS_NULL);
d998 3
a1000 3
    long *dl;
    long *ll;
    long *rl;
d1002 1
a1002 1
    char *dc;
d1005 3
a1007 3
    const char *lc;
    const char *rc;
    STRLEN len;
d1127 1
a1127 1
		(void)sv_usepvn(sv, dcorig, needlen); /* uses Renew(); defaults to nomg */
d1130 1
a1130 1
		sv_catpvn_nomg(sv, dcsave, rulen);
d1132 1
a1132 1
		sv_catpvn_nomg(sv, dcsave, lulen);
d1210 1
a1210 1
		sv_catpvn_nomg(sv, rsave + len, rightlen - len);
d1212 1
a1212 1
		sv_catpvn_nomg(sv, lsave + len, leftlen - len);
d1228 1
a1228 1
    HE *entry;
d1293 1
a1293 1
 * indent-tabs-mode: nil
d1296 1
a1296 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@d18 2
a19 2
 * ops. For example, both pp_sprintf() and pp_prtf() call the function
 * do_printf() found in this file.
d334 1
a334 1
	    hibit = !NATIVE_BYTE_IS_INVARIANT(ch);
d364 1
a364 1
	    d = uvchr_to_utf8(d, uv);
d375 1
a375 1
	    d = uvchr_to_utf8(d, final);
d435 1
a435 1
	    hibit = !NATIVE_BYTE_IS_INVARIANT(ch);
d490 1
a490 1
	    hibit = !NATIVE_BYTE_IS_INVARIANT(ch);
d535 1
a535 1
		    d = uvchr_to_utf8(d, uv);
d553 1
a553 1
			d = uvchr_to_utf8(d, final);
d559 1
a559 1
		    uv = utf8n_to_uvchr(s, send - s, &len, UTF8_ALLOW_DEFAULT);
d588 1
a588 1
		d = uvchr_to_utf8(d, uv);
d601 1
a601 1
		d = uvchr_to_utf8(d, final);
d635 1
d765 3
a767 4
    const I32 svpv_flags = ((PL_op->op_flags & OPf_MOD || LVRET)
                                          ? SV_UNDEF_RETURNS_NULL : 0);
    unsigned char *s = (unsigned char *)
                            SvPV_flags(sv, srclen, (svpv_flags|SV_GMAGIC));
d771 1
a771 1
      s = (unsigned char *)"";
d781 1
a781 1
    if (SvUTF8(sv)) {
a782 3
        /* PVX may have changed */
        s = (unsigned char *) SvPV_flags(sv, srclen, svpv_flags);
    }
@


1.1.1.17
log
@Import perl-5.24.2
@
text
@d19 1
a19 1
 * do_sprintf() found in this file.
d33 1
d102 1
d140 1
d304 1
d409 1
d459 1
d627 1
d629 2
a630 2
    const I32 flags = PL_op->op_private;
    const I32 hasutf = flags & (OPpTRANS_FROM_UTF | OPpTRANS_TO_UTF);
d634 2
a635 2
    if (SvREADONLY(sv) && !(flags & OPpTRANS_IDENTICAL)) {
        Perl_croak_no_modify();
d640 1
a640 1
    if (!(flags & OPpTRANS_IDENTICAL)) {
d648 21
a668 9
    /* If we use only OPpTRANS_IDENTICAL to bypass the READONLY check,
     * we must also rely on it to choose the readonly strategy.
     */
    if (flags & OPpTRANS_IDENTICAL) {
        return hasutf ? do_trans_count_utf8(sv) : do_trans_count(sv);
    } else if (flags & (OPpTRANS_SQUASH|OPpTRANS_DELETE|OPpTRANS_COMPLEMENT)) {
        return hasutf ? do_trans_complex_utf8(sv) : do_trans_complex(sv);
    } else {
        return hasutf ? do_trans_simple_utf8(sv) : do_trans_simple(sv);
d675 1
a679 1
    const char * const delims = SvPV_const(delim, delimlen);
d683 3
a718 1
	const U32 delimflag = DO_UTF8(delim) ? SV_CATUTF8 : SV_CATBYTES;
d720 2
a721 6
	    STRLEN len;
	    const char *s;
	    sv_catpvn_flags(sv,delims,delimlen,delimflag);
	    s = SvPV_const(*mark,len);
	    sv_catpvn_flags(sv,s,len,
			    DO_UTF8(*mark) ? SV_CATUTF8 : SV_CATBYTES);
d726 1
a726 6
	{
	    STRLEN len;
	    const char *s = SvPV_const(*mark,len);
	    sv_catpvn_flags(sv,s,len,
			    DO_UTF8(*mark) ? SV_CATUTF8 : SV_CATBYTES);
	}
d734 1
d762 1
d853 1
a853 1
			((UV) s[uoffset + 4] << 24);
d870 1
a870 1
			((UV) s[uoffset + 6] <<  8);
d917 1
d1004 1
a1020 1
    bool do_warn_above_ff = ckWARN_d(WARN_DEPRECATED);
d1036 1
a1036 1
    /* This needs to come after SvPV to ensure that string overloading has
a1100 6
                if (do_warn_above_ff && (luc > 0xff || ruc > 0xff)) {
                    Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                                deprecated_above_ff_msg, PL_op_desc[optype]);
                    /* Warn only once per operation */
                    do_warn_above_ff = FALSE;
                }
a1115 5
                if (do_warn_above_ff && (luc > 0xff || ruc > 0xff)) {
                    Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                                deprecated_above_ff_msg, PL_op_desc[optype]);
                    do_warn_above_ff = FALSE;
                }
a1127 5
                if (do_warn_above_ff && (luc > 0xff || ruc > 0xff)) {
                    Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                                deprecated_above_ff_msg, PL_op_desc[optype]);
                    do_warn_above_ff = FALSE;
                }
d1226 1
a1226 1
  finish:
a1229 3

/* used for: pp_keys(), pp_values() */

d1233 1
d1237 1
a1237 2
    SSize_t extend_size;
    const U8 gimme = GIMME_V;
d1240 2
a1241 2
    const I32 dokeys =   dokv || (PL_op->op_type == OP_KEYS);
    const I32 dovalues = dokv || (PL_op->op_type == OP_VALUES);
d1272 1
a1272 4
    /* 2*HvUSEDKEYS() should never be big enough to truncate or wrap */
    assert(HvUSEDKEYS(keys) <= (SSize_t_MAX >> 1));
    extend_size = (SSize_t)HvUSEDKEYS(keys) * (dokeys + dovalues);
    EXTEND(SP, extend_size);
d1274 1
d1276 1
d1279 1
a1279 1
	    XPUSHs(sv);
d1282 3
a1284 1
	    SV *tmpstr = hv_iterval(keys,entry);
d1289 1
d1292 1
d1294 1
a1294 1
    RETURN;
d1298 6
@


