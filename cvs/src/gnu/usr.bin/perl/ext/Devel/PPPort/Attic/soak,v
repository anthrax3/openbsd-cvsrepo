head	1.2;
access;
symbols
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.6
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.4
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.2
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2009.10.12.18.24.25;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.01.15.21.16.45;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.47.57;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.15;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Merge in perl 5.10.1
@
text
@
# soak: Test Devel::PPPort with multiple versions of Perl.
#
# Author:	Paul Marquess
#

require 5.006001;

use strict ;
use warnings ;
use ExtUtils::MakeMaker;
use Getopt::Long;

my $VERSION = "1.000";

$| = 1 ;
my $verbose = 0 ;

# TODO -- determine what "make" program to run.
my $MAKE = 'make';

my $result = GetOptions(
	"verbose"	=> \$verbose,
	"make=s"	=> \$MAKE,
	) or Usage();

my @@GoodPerls = ();

if (@@ARGV)
  { @@GoodPerls = @@ARGV }
else 
  { @@GoodPerls = FindPerls() }

my $maxlen = 0;
foreach (@@GoodPerls) {
    $maxlen = length $_
        if length $_ > $maxlen ;
}
$maxlen += 3 ;

# run each through the test harness

my $bad = 0 ;
my $good = 0 ;
my $total = 0 ;

# prime the pump, so the first "make clean" will work.
runit("perl Makefile.PL") || die "Cannot run perl Makefile.PL\n" ;

foreach my $perl (@@GoodPerls)
{
   my $prefix = "$perl -- " if $verbose ;
   print "Testing $perl " . ('.' x ($maxlen - length $perl)) ;

   my $ok = runit("$MAKE clean") &&
            runit("$perl Makefile.PL") &&
            runit("$MAKE test")	;

    ++ $total;
    if ($ok) {
        ++ $good ;
        print "${prefix}ok\n";
    }
    else {
        ++ $bad ;
        print "${prefix}not ok\n" ;
    }

}

print "\n\nPassed with $good of $total versions of Perl.\n\n";
exit $bad ;


sub runit
{
    # TODO -- portability alert!!

    my $cmd = shift ;
    print "\n    Running [$cmd]\n" if $verbose ;
    my $output = `$cmd 2>&1` ;
    $output = "\n" unless defined $output;
    $output =~ s/^/      /gm;
    print "\n    Output\n$output\n" if $verbose || $? ;
    if ($?)
    {
        warn "    Running '$cmd' failed: $?\n" ;
        return 0 ;
    }
    return 1 ;
}                   

sub Usage
{
    die <<EOM;

usage: soak [OPT] [perl...]

  OPT
    -m make	- the name of the make program. Default "make"
    -v		- verbose

EOM

}

sub FindPerls
{
    # TODO -- need to decide how far back we go.
    # TODO -- get list of user releases prior to 5.004

    # find all version of Perl that are available
    my @@PerlBinaries = qw( 
	5.000        
	5.001        
	5.002        
	5.003        
	5.004        
	5.00401      
	5.00402      
	5.00403      
	5.00404      
	5.00405      
	5.005                         
	5.00501                       
	5.00502      
	5.00503                     
	5.6.0        
	5.6.1 
	5.7.0
	5.7.1
	5.7.2      
	);

    print "Searching for Perl binaries...\n" ;
    my @@GoodPerls = ();
    my $maxlen = 0;
    my $mm = MM->new( { NAME => 'dummy' });
    my @@path = $mm->path();

    # find_perl will send a warning to STDOUT if it can't find 
    # the requested perl, so need to temporarily silence STDOUT.
    tie(*STDOUT, 'NoSTDOUT');

    foreach my $perl (@@PerlBinaries) {
        if (my $abs = $mm->find_perl($perl, ["perl$perl"], [@@path], 0)) {
            push @@GoodPerls, $abs ;
        }
    }
    untie *STDOUT;
    
    print "\n\nFound\n";
    foreach (@@GoodPerls) { print "    $_\n" }
    print "\n\n";

    return @@GoodPerls;
}

package NoSTDOUT;

use Tie::Handle;
our @@ISA = qw(Tie::Handle);

sub TIEHANDLE 
{
    my ($class) = @@_;
    my $buf = "";
    bless \$buf, $class;
}
 
sub PRINT 
{
    my $self = shift;
}                
 
sub WRITE 
{
    my $self = shift;
}                
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.6 from CPAN
@
text
@d1 2
a2 12
#!/usr/bin/perl -w
################################################################################
#
#  soak -- Test Devel::PPPort with multiple versions of Perl.
#
#  Original Author: Paul Marquess
#
################################################################################
#
#  $Revision: 6 $
#  $Author: mhx $
#  $Date: 2004/08/13 12:49:41 +0200 $
d4 1
a4 1
################################################################################
a5 8
#  Version 3.x, Copyright (C) 2004, Marcus Holland-Moritz.
#  Version 2.x, Copyright (C) 2001, Paul Marquess.
#  Version 1.x, Copyright (C) 1999, Kenneth Albanowski.
#
#  This program is free software; you can redistribute it and/or
#  modify it under the same terms as Perl itself.
#
################################################################################
d9 2
a10 2
use strict;
use warnings;
d47 1
a47 1
# prime the pump, so the first "make realclean" will work.
d52 1
a52 1
   my $prefix = $verbose  ? "$perl -- " : '';
d55 1
a55 1
   my $ok = runit("$MAKE realclean") &&
d57 1
a57 2
            # runit("$perl Makefile.PL --with-apicheck") &&
            runit("$MAKE test");
a179 2


@


1.1.1.3
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
#  soak -- Test Perl modules with multiple Perl releases.
d10 1
a10 1
#  $Revision: 8 $
d12 1
a12 1
#  $Date: 2005/02/27 21:16:42 +0100 $
d16 1
a16 1
#  Version 3.x, Copyright (C) 2004-2005, Marcus Holland-Moritz.
d31 27
a57 22
use Pod::Usage;
use List::Util qw(max);
use Config;

my $VERSION = do { my @@r = '$Snapshot: /Devel-PPPort/3.06_01 $' =~ /(\d+\.\d+(?:_\d+)?)/; @@r ? $r[0] : '9.99' };

$| = 1;
my $verbose = 0;
my $MAKE = $Config{make} || 'make';
my %OPT = (
  verbose => 0,
  make    => $Config{make} || 'make',
);

GetOptions(\%OPT, qw(verbose make=s mmargs=s@@)) or pod2usage(2);

$OPT{mmargs} = [''] unless exists $OPT{mmargs};

my @@GoodPerls = @@ARGV ? @@ARGV : FindPerls();
my $maxlen = max(map length, @@GoodPerls) + 3;
my $mmalen = max(map length, @@{$OPT{mmargs}});
$maxlen += $mmalen+3 if $mmalen > 0;
d60 4
a63 1
my(@@good, @@bad, $total);
d66 6
a71 2
runit("$^X Makefile.PL") && runit("$MAKE realclean")
    or die "Cannot run $^X Makefile.PL && $MAKE realclean\n";
d73 4
a76 9
for my $perl (@@GoodPerls) {
  for my $mm (@@{$OPT{mmargs}}) {
    my $config = $mm =~ /\S+/ ? " ($mm)" : '';
    my $prefix = $verbose ? "$perl$config -- " : '';
    print "Testing $perl$config " . ('.' x ($maxlen - length($perl.$config)));

    my $ok = runit("$perl Makefile.PL $mm") &&
             # runit("$perl Makefile.PL --with-apicheck") &&
             runit("$MAKE test");
d78 1
a78 1
    $total++;
d80 2
a81 2
      push @@good, [$perl, $mm];
      print "${prefix}ok\n";
d84 2
a85 2
      push @@bad, [$perl, $mm];
      print "${prefix}not ok\n";
a87 2
    runit("$MAKE realclean");
  }
d90 3
a92 5
if ($verbose && @@bad) {
  print "\nFailed with:\n", map "    $_\n", @@bad;
}
print "\nPassed with ", scalar @@good, " of $total versions/configurations.\n\n";
exit scalar @@bad;
d96 27
a122 1
  # TODO -- portability alert!!
a123 11
  my $cmd = shift;
  print "\n    Running [$cmd]\n" if $verbose;
  my $output = `$cmd 2>&1`;
  $output = "\n" unless defined $output;
  $output =~ s/^/      /gm;
  print "\n    Output\n$output\n" if $verbose || $?;
  if ($?) {
    warn "    Running '$cmd' failed: $?\n";
    return 0;
  }
  return 1;
d128 40
a167 30
  # TODO -- need to decide how far back we go.
  # TODO -- get list of user releases prior to 5.004
  # TODO -- does not work on Windows (at least)

  # find versions of Perl that are available
  my @@PerlBinaries = qw(
    5.000
    5.001
    5.002
    5.003
    5.004 5.00401 5.00402 5.00403 5.00404 5.00405
    5.005 5.00501 5.00502 5.00503 5.00504
    5.6.0 5.6.1 5.6.2
    5.7.0 5.7.1 5.7.2 5.7.3
    5.8.0 5.8.1 5.8.2 5.8.3 5.8.4 5.8.5 5.8.6
    5.9.0 5.9.1
  );

  print "Searching for Perl binaries...\n";
  my $mm = MM->new( { NAME => 'dummy' });
  my @@path = $mm->path;
  my @@GoodPerls;

  # find_perl will send a warning to STDOUT if it can't find
  # the requested perl, so need to temporarily silence STDOUT.
  tie *STDOUT, 'NoSTDOUT';

  for my $perl (@@PerlBinaries) {
    if (my $abs = $mm->find_perl($perl, ["perl$perl"], \@@path, 0)) {
      push @@GoodPerls, $abs;
d169 5
a173 3
  }

  untie *STDOUT;
d175 1
a175 3
  print "\nFound:\n", (map "    $_\n", @@GoodPerls), "\n";

  return @@GoodPerls;
d183 16
a198 32
sub TIEHANDLE { bless \(my $s = ''), shift }
sub PRINT {}
sub WRITE {}

__END__

=head1 NAME

soak - Test Perl modules with multiple Perl releases

=head1 SYNOPSIS

  soak [options] [perl ...]

  --make=program     override name of make program ($Config{make})
  --mmargs=options   pass options to Makefile.PL (multiple --mmargs possible)
  --verbose          be verbose

=head1 COPYRIGHT

Version 3.x, Copyright (c) 2004-2005, Marcus Holland-Moritz.

Version 2.x, Copyright (C) 2001, Paul Marquess.

Version 1.x, Copyright (C) 1999, Kenneth Albanowski.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=head1 SEE ALSO

See L<Devel::PPPort>.
a199 1
=cut
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d10 1
a10 1
#  $Revision: 16 $
d12 1
a12 1
#  $Date: 2007/08/12 23:25:33 +0200 $
d16 1
a16 1
#  Version 3.x, Copyright (C) 2004-2007, Marcus Holland-Moritz.
a31 1
use File::Find;
d35 1
a35 1
my $VERSION = do { my @@r = '$Snapshot: /Devel-PPPort/3.13 $' =~ /(\d+\.\d+(?:_\d+)?)/; @@r ? $r[0] : '9.99' };
d38 2
a42 2
  min     => '5.000',
  color   => 1,
d45 1
a45 1
GetOptions(\%OPT, qw(verbose make=s min=s mmargs=s@@ color!)) or pod2usage(2);
a47 14
$OPT{min}    = parse_version($OPT{min}) - 1e-10;

sub cs($;$$) { my $x = shift; my($s, $p) = @@_ ? @@_ : ('', 's'); ($x, $x == 1 ? $s : $p) }

my @@GoodPerls = map  { $_->[0] }
                sort { $a->[1] <=> $b->[1] or $a->[0] cmp $b->[0] }
                grep { $_->[1] >= $OPT{min} }
                map  { [$_ => perl_version($_)] }
                @@ARGV ? SearchPerls(@@ARGV) : FindPerls();

unless (@@GoodPerls) {
  print "Sorry, got no Perl binaries for testing.\n\n";
  exit 0;
}
d49 1
d54 2
a55 7
my $rep = Soak::Reporter->new( verbose => $OPT{verbose}
                             , color   => $OPT{color}
                             , width   => $maxlen
                             );

$SIG{__WARN__} = sub { $rep->warn(@@_) };
$SIG{__DIE__}  = sub { $rep->die(@@_)  };
d58 2
a59 9
runit("$^X Makefile.PL") && runit("$OPT{make} realclean")
    or $rep->die("Cannot run $^X Makefile.PL && $OPT{make} realclean\n");

my $tot = @@GoodPerls*@@{$OPT{mmargs}};

$rep->set(tests => $tot);

$rep->status(sprintf("Testing %d version%s / %d configuration%s (%d combination%s)...\n",
                     cs(@@GoodPerls), cs(@@{$OPT{mmargs}}), cs($tot)));
d63 7
a69 15
    $rep->set(perl => $perl, config => $mm);

    $rep->test;

    my @@warn_mfpl;
    my @@warn_make;
    my @@warn_test;

    my $ok = runit("$perl Makefile.PL $mm", \@@warn_mfpl) &&
             runit("$OPT{make}", \@@warn_make) &&
             runit("$OPT{make} test", \@@warn_test);

    $rep->warnings(['Makefile.PL' => \@@warn_mfpl],
                   ['make'        => \@@warn_make],
                   ['make test'   => \@@warn_test]);
d71 1
d73 2
a74 1
      $rep->passed;
d77 2
a78 1
      $rep->failed;
d81 1
a81 1
    runit("$OPT{make} realclean");
d85 5
a89 1
exit $rep->finish;
d95 2
a96 2
  my($cmd, $warn) = @@_;
  $rep->vsay("\n    Running [$cmd]");
d99 2
a100 2
  $output =~ s/^/    > /gm;
  $rep->say("\n    Output:\n$output") if $OPT{verbose} || $?;
d102 1
a102 1
    $rep->warn("    Running '$cmd' failed: $?\n");
a104 1
  push @@$warn, $output =~ /(warning: .*)/ig;
d124 2
a125 2
    5.8.0 5.8.1 5.8.2 5.8.3 5.8.4 5.8.5 5.8.6 5.8.7 5.8.8
    5.9.0 5.9.1 5.9.2 5.9.3
d129 3
a136 4
  my $mm = MM->new( { NAME => 'dummy' });
  my @@path = $mm->path;
  my @@GoodPerls;

a149 49
sub SearchPerls
{
  my @@args = @@_;
  my @@perls;

  for my $arg (@@args) {
    if (-d $arg) {
      my @@found;
      print "Searching for Perl binaries in '$arg'...\n";
      find(sub {
             $File::Find::name =~ m!perl5[\w._]+$!
                 and -f $File::Find::name
                 and -x $File::Find::name
                 and perl_version($File::Find::name)
                 and push @@found, $File::Find::name;
           }, $arg);
      printf "Found %d Perl binar%s in '%s'.\n\n", cs(@@found, 'y', 'ies'), $arg;
      push @@perls, @@found;
    }
    else {
      push @@perls, $arg;
    }
  }

  return @@perls;
}

sub perl_version
{
  my $perl = shift;
  my $ver = `$perl -e 'print \$]' 2>&1`;
  return $? == 0 && $ver =~ /^\d+\.\d+/ && $ver >= 5 ? $ver : 0;
}

sub parse_version
{
  my $ver = shift;

  if ($ver =~ /^(\d+)\.(\d+)\.(\d+)$/) {
    return $1 + 1e-3*$2 + 1e-6*$3;
  }
  elsif ($ver =~ /^\d+\.[\d_]+$/) {
    $ver =~ s/_//g;
    return $ver;
  }

  die "cannot parse version '$ver'\n";
}

a158 267
package Soak::Reporter;

use strict;

sub cs($;$$) { my $x = shift; my($s, $p) = @@_ ? @@_ : ('', 's'); ($x, $x == 1 ? $s : $p) }

sub new
{
  my $class = shift;
  bless {
    tests   => undef,
    color   => 1,
    verbose => 0,
    @@_,
    _cur    => 0,
    _atbol  => 1,
    _total  => 0,
    _good   => [],
    _bad    => [],
  }, $class;
}

sub colored
{
  my $self = shift;

  if ($self->{color}) {
    my $c = eval {
      require Term::ANSIColor;
      Term::ANSIColor::colored(@@_);
    };

    if ($@@) {
      $self->{color} = 0;
    }
    else {
      return $c;
    }
  }

  return $_[0];
}

sub _config
{
  my $self = shift;
  return $self->{config} =~ /\S+/ ? " ($self->{config})" : '';
}

sub _progress
{
  my $self = shift;
  return '' unless defined $self->{tests};
  my $tlen = length $self->{tests};
  my $text = sprintf "[%${tlen}d/%${tlen}d] ", $self->{_cur}, $self->{tests};
  return $self->colored($text, 'bold');
}

sub _test
{
  my $self = shift;
  return $self->_progress . "Testing "
         . $self->colored($self->{perl}, 'blue')
         . $self->colored($self->_config, 'green');
}

sub _testlen
{
  my $self = shift;
  return length("Testing " . $self->{perl} . $self->_config);
}

sub _dots
{
  my $self = shift;
  return '.' x $self->_dotslen;
}

sub _dotslen
{
  my $self = shift;
  return $self->{width} - length($self->{perl} . $self->_config);
}

sub _sep
{
  my $self = shift;
  my $width = shift;
  $self->print($self->colored('-'x$width, 'bold'), "\n");
}

sub _vsep
{
  goto &_sep if $_[0]->{verbose};
}

sub set
{
  my $self = shift;
  while (@@_) {
    my($k, $v) = splice @@_, 0, 2;
    $self->{$k} = $v;
  }
}

sub test
{
  my $self = shift;
  $self->{_cur}++;
  $self->_vsep($self->_testlen);
  $self->print($self->_test, $self->{verbose} ? "\n" : ' ' . $self->_dots . ' ');
  $self->_vsep($self->_testlen);
}

sub _warnings
{
  my($self, $mode) = @@_;

  my $warnings = 0;
  my $differ   = 0;

  for my $w (@@{$self->{_warnings}}) {
    if (@@{$w->[1]}) {
      $warnings += @@{$w->[1]};
      $differ++;
    }
  }

  my $rv = '';

  if ($warnings) {
    if ($mode eq 'summary') {
      $rv .= sprintf " (%d warning%s", cs($warnings);
    }
    else {
      $rv .= "\n";
    }

    for my $w (@@{$self->{_warnings}}) {
      if (@@{$w->[1]}) {
        if ($mode eq 'detail') {
          $rv .= "  Warnings during '$w->[0]':\n";
          my $cnt = 1;
          for my $msg (@@{$w->[1]}) {
            $rv .= sprintf "    [%d] %s", $cnt++, $msg;
          }
          $rv .= "\n";
        }
        else {
          unless ($self->{verbose}) {
            $rv .= $differ == 1 ? " during " . $w->[0]
                                : sprintf(", %d during %s", scalar @@{$w->[1]}, $w->[0]);
          }
        }
      }
    }

    if ($mode eq 'summary') {
      $rv .= ')';
    }
  }

  return $rv;
}

sub _result
{
  my($self, $text, $color) = @@_;
  my $sum = $self->_warnings('summary');
  my $len = $self->_testlen + $self->_dotslen + length($text) + length($sum) + 2;

  $self->_vsep($len);
  $self->print($self->_test, ' ', $self->_dots, ' ') if $self->{verbose} || $self->{_atbol};
  $self->print($self->colored($text, $color));
  $self->print($self->colored($sum, 'red'));
  $self->print("\n");
  $self->_vsep($len);
  $self->print($self->_warnings('detail')) if $self->{verbose};
  $self->{_total}++;
}

sub passed
{
  my $self = shift;
  $self->_result(@@_, 'ok', 'bold green');
  push @@{$self->{_good}}, [$self->{perl}, $self->{config}];
}

sub failed
{
  my $self = shift;
  $self->_result(@@_, 'not ok', 'bold red');
  push @@{$self->{_bad}}, [$self->{perl}, $self->{config}];
}

sub warnings
{
  my $self = shift;
  $self->{_warnings} = \@@_;
}

sub _tobol
{
  my $self = shift;
  print "\n" unless $self->{_atbol};
  $self->{_atbol} = 1;
}

sub print
{
  my $self = shift;
  my $text = join '', @@_;
  print $text;
  $self->{_atbol} = $text =~ /[\r\n]$/;
}

sub say
{
  my $self = shift;
  $self->_tobol;
  $self->print(@@_, "\n");
}

sub vsay
{
  goto &say if $_[0]->{verbose};
}

sub warn
{
  my $self = shift;
  $self->say($self->colored(join('', @@_), 'red')); 
}

sub die
{
  my $self = shift;
  $self->say($self->colored(join('', 'FATAL: ', @@_), 'bold red')); 
  exit -1;
}

sub status
{
  my($self, $text) = @@_;
  $self->_tobol;
  $self->print($self->colored($text, 'bold'), "\n");
}

sub finish
{
  my $self = shift;

  if (@@{$self->{_bad}}) {
    $self->status("\nFailed with:");
    for my $fail (@@{$self->{_bad}}) {
      my($perl, $cfg) = @@$fail;
      $self->set(config => $cfg);
      $self->say("    ", $self->colored($perl, 'blue'), $self->colored($self->_config, 'green'));
    }
  }

  $self->status(sprintf("\nPassed with %d of %d combination%s.\n",
                        scalar @@{$self->{_good}}, cs($self->{_total})));

  return scalar @@{$self->{_bad}};
}

a169 1
  --min=version      use at least this version of perl
a171 71
  --nocolor          don't use colored output

=head1 DESCRIPTION

The F<soak> utility can be used to test Perl modules with
multiple Perl releases or build options. It automates the
task of running F<Makefile.PL> and the modules test suite.

It is not primarily intended for cross-platform checking,
so don't expect it to work on all platforms.

=head1 EXAMPLES

To test your favourite module, just change to its root
directory (where the F<Makefile.PL> is located) and run:

  soak

This will automatically look for Perl binaries installed
on your system.

Alternatively, you can explicitly pass F<soak> a list of
Perl binaries:

  soak perl5.8.6 perl5.9.2

Last but not least, you can pass it a list of directories
to recursively search for Perl binaries, for example:

  soak /tmp/perl/install /usr/bin

All of the above examples will run

  perl Makefile.PL
  make
  make test

for your module and report success or failure.

If your F<Makefile.PL> can take arguments, you may also
want to test different configurations for your module.
You can do so with the I<--mmargs> option:

  soak --mmargs=' ' --mmargs='CCFLAGS=-Wextra' --mmargs='enable-debug'

This will run

  perl Makefile.PL
  make
  make test
  perl Makefile.PL CCFLAGS=-Wextra
  make
  make test
  perl Makefile.PL enable-debug
  make
  make test

for each Perl binary.

If you have a directory full of different Perl binaries,
but your module isn't expected to work with ancient perls,
you can use the I<--min> option to specify the minimum
version a Perl binary must have to be chosen for testing:

  soak --min=5.8.1

Usually, the output of F<soak> is rather terse, to give
you a good overview. If you'd like to see more of what's
going on, use the I<--verbose> option:

  soak --verbose
d175 1
a175 1
Version 3.x, Copyright (c) 2004-2007, Marcus Holland-Moritz.
@


