head	1.4;
access;
symbols
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.2.0.10
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.8
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.6
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.4
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.1.0.6
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.4
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.2
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2009.10.12.18.24.25;	author millert;	state dead;
branches;
next	1.3;

1.3
date	2008.09.29.17.36.03;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.28.19.23.02;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.15.21.16.45;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.01.15.21.16.45;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.03.28.18.47.58;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.15;	author millert;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge in perl 5.10.1
@
text
@#!/usr/bin/perl -w
################################################################################
#
#  mktodo.pl -- generate baseline and todo files
#
################################################################################
#
#  $Revision: 1.3 $
#  $Author: millert $
#  $Date: 2008/09/29 17:36:03 $
#
################################################################################
#
#  Version 3.x, Copyright (C) 2004-2007, Marcus Holland-Moritz.
#  Version 2.x, Copyright (C) 2001, Paul Marquess.
#  Version 1.x, Copyright (C) 1999, Kenneth Albanowski.
#
#  This program is free software; you can redistribute it and/or
#  modify it under the same terms as Perl itself.
#
################################################################################

use strict;
use Getopt::Long;
use Data::Dumper;
use IO::File;
use IO::Select;
use Config;
use Time::HiRes qw( gettimeofday tv_interval );

require 'devel/devtools.pl';

our %opt = (
  debug   => 0,
  base    => 0,
  verbose => 0,
  check   => 1,
  shlib   => 'blib/arch/auto/Devel/PPPort/PPPort.so',
);

GetOptions(\%opt, qw(
            perl=s todo=s version=s shlib=s debug base verbose check!
          )) or die;

identify();

print "\n", ident_str(), "\n\n";

my $fullperl = `which $opt{perl}`;
chomp $fullperl;

$ENV{SKIP_SLOW_TESTS} = 1;

regen_all();

my %sym;
for (`$Config{nm} $fullperl`) {
  chomp;
  /\s+T\s+(\w+)\s*$/ and $sym{$1}++;
}
keys %sym >= 50 or die "less than 50 symbols found in $fullperl\n";

my %all = %{load_todo($opt{todo}, $opt{version})};
my @@recheck;

my $symmap = get_apicheck_symbol_map();

for (;;) {
  my $retry = 1;
  my $trynm = 1;
  regen_apicheck();

retry:
  my(@@new, @@tmp, %seen);

  my $r = run(qw(make));
  $r->{didnotrun} and die "couldn't run make: $!\n";

  for my $l (@@{$r->{stderr}}) {
    if ($l =~ /_DPPP_test_(\w+)/) {
      if (!$seen{$1}++) {
        my @@s = grep { exists $sym{$_} } $1, "Perl_$1", "perl_$1";
        if (@@s) {
          push @@tmp, [$1, "E (@@s)"];
        }
        else {
          push @@new, [$1, "E"];
        }
      }
    }
  }

  if ($r->{status} == 0) {
    my @@u;
    my @@usym;

    if ($trynm) {
      @@u = eval { find_undefined_symbols($fullperl, $opt{shlib}) };
      warn "warning: $@@" if $@@;
      $trynm = 0;
    }

    unless (@@u) {
      $r = run(qw(make test));
      $r->{didnotrun} and die "couldn't run make test: $!\n";
      $r->{status} == 0 and last;

      for my $l (@@{$r->{stderr}}) {
        if ($l =~ /undefined symbol: (\w+)/) {
          push @@u, $1;
        }
      }
    }

    for my $u (@@u) {
      for my $m (keys %{$symmap->{$u}}) {
        if (!$seen{$m}++) {
          my $pl = $m;
          $pl =~ s/^[Pp]erl_//;
          my @@s = grep { exists $sym{$_} } $pl, "Perl_$pl", "perl_$pl";
          push @@new, [$m, @@s ? "U (@@s)" : "U"];
        }
      }
    }
  }

  @@new = grep !$all{$_->[0]}, @@new;

  unless (@@new) {
    @@new = grep !$all{$_->[0]}, @@tmp;
  }

  unless (@@new) {
    if ($retry > 0) {
      $retry--;
      regen_all();
      goto retry;
    }
    print Dumper($r);
    die "no new TODO symbols found...";
  }

  # don't recheck undefined symbols reported by the dynamic linker
  push @@recheck, map { $_->[0] } grep { $_->[1] !~ /^U/ } @@new;

  for (@@new) {
    sym('new', @@$_);
    $all{$_->[0]} = $_->[1];
  }

  write_todo($opt{todo}, $opt{version}, \%all);
}

if ($opt{check}) {
  my $ifmt = '%' . length(scalar @@recheck) . 'd';
  my $t0 = [gettimeofday];
  
  RECHECK: for my $i (0 .. $#recheck) {
    my $sym = $recheck[$i];
    my $cur = delete $all{$sym};
  
    sym('chk', $sym, $cur, sprintf(" [$ifmt/$ifmt, ETA %s]",
               $i + 1, scalar @@recheck, eta($t0, $i, scalar @@recheck)));
  
    write_todo($opt{todo}, $opt{version}, \%all);
  
    if ($cur eq "E (Perl_$sym)") {
      # we can try a shortcut here
      regen_apicheck($sym);
  
      my $r = run(qw(make test));
  
      if (!$r->{didnotrun} && $r->{status} == 0) {
        sym('del', $sym, $cur);
        next RECHECK;
      }
    }
  
    # run the full test
    regen_all();
  
    my $r = run(qw(make test));
  
    $r->{didnotrun} and die "couldn't run make test: $!\n";
  
    if ($r->{status} == 0) {
      sym('del', $sym, $cur);
    }
    else {
      $all{$sym} = $cur;
    }
  }
}

write_todo($opt{todo}, $opt{version}, \%all);

run(qw(make realclean));

exit 0;

sub sym
{
  my($what, $sym, $reason, $extra) = @@_;
  $extra ||= '';
  my %col = (
    'new' => 'bold red',
    'chk' => 'bold magenta',
    'del' => 'bold green',
  );
  $what = colored("$what symbol", $col{$what});

  printf "[%s] %s %-30s # %s%s\n",
         $opt{version}, $what, $sym, $reason, $extra;
}

sub regen_all
{
  my @@mf_arg = ('--with-apicheck', 'OPTIMIZE=-O0 -w');
  push @@mf_arg, qw( DEFINE=-DDPPP_APICHECK_NO_PPPORT_H ) if $opt{base};

  # just to be sure
  run(qw(make realclean));
  run($fullperl, "Makefile.PL", @@mf_arg)->{status} == 0
      or die "cannot run Makefile.PL: $!\n";
}

sub regen_apicheck
{
  unlink qw(apicheck.c apicheck.o);
  runtool({ out => '/dev/null' }, $fullperl, 'apicheck_c.PL', map { "--api=$_" } @@_)
      or die "cannot regenerate apicheck.c\n";
}

sub load_todo
{
  my($file, $expver) = @@_;

  if (-e $file) {
    my $f = new IO::File $file or die "cannot open $file: $!\n";
    my $ver = <$f>;
    chomp $ver;
    if ($ver eq $expver) {
      my %sym;
      while (<$f>) {
        chomp;
        /^(\w+)\s+#\s+(.*)/ or goto nuke_file;
        exists $sym{$1} and goto nuke_file;
        $sym{$1} = $2;
      }
      return \%sym;
    }

nuke_file:
    undef $f;
    unlink $file or die "cannot remove $file: $!\n";
  }

  return {};
}

sub write_todo
{
  my($file, $ver, $sym) = @@_;
  my $f;

  $f = new IO::File ">$file" or die "cannot open $file: $!\n";
  $f->print("$ver\n");

  for (sort keys %$sym) {
    $f->print(sprintf "%-30s # %s\n", $_, $sym->{$_});
  }
}

sub find_undefined_symbols
{
  my($perl, $shlib) = @@_;

  my $ps = read_sym(file => $perl,  options => [qw( --defined-only   )]);
  my $ls = read_sym(file => $shlib, options => [qw( --undefined-only )]);

  my @@undefined;

  for my $sym (keys %$ls) {
    unless (exists $ps->{$sym}) {
      if ($sym !~ /\@@/ and $sym !~ /^_/) {
        push @@undefined, $sym;
      }
    }
  }

  return @@undefined;
}

sub read_sym
{
  my %opt = ( options => [], @@_ );

  my $r = run($Config{nm}, @@{$opt{options}}, $opt{file});

  if ($r->{didnotrun} or $r->{status}) {
    die "cannot run $Config{nm}";
  }

  my %sym;

  for (@@{$r->{stdout}}) {
    chomp;
    my($adr, $fmt, $sym) = /^\s*([[:xdigit:]]+)?\s+([ABCDGINRSTUVW?-])\s+(\S+)\s*$/i
                           or die "cannot parse $Config{nm} output:\n[$_]\n";
    $sym{$sym} = { format => $fmt };
    $sym{$sym}{address} = $adr if defined $adr;
  }

  return \%sym;
}

sub get_apicheck_symbol_map
{
  my $r = run(qw(make apicheck.i));
  
  if ($r->{didnotrun} or $r->{status}) {
    die "cannot run make apicheck.i";
  }

  my $fh = IO::File->new('apicheck.i')
           or die "cannot open apicheck.i: $!";

  local $_;
  my %symmap;
  my $cur;

  while (<$fh>) {
    next if /^#/;
    if (defined $cur) {
      for my $sym (/\b([A-Za-z_]\w+)\b/g) {
        $symmap{$sym}{$cur}++;
      }
      undef $cur if /^}$/;
    }
    else {
      /_DPPP_test_(\w+)/ and $cur = $1;
    }
  }

  return \%symmap;
}
@


1.3
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d8 3
a10 3
#  $Revision: 14 $
#  $Author: mhx $
#  $Date: 2007/08/12 08:45:39 +0200 $
@


1.2
log
@merge in perl 5.8.8
@
text
@d8 3
a10 3
#  $Revision: 1.1.1.1 $
#  $Author: millert $
#  $Date: 2005/01/15 21:16:45 $
d14 1
a14 1
#  Version 3.x, Copyright (C) 2004-2005, Marcus Holland-Moritz.
d28 2
d31 8
a38 3
my %opt = (
  debug => 0,
  base  => 0,
a40 2
print "\n$0 @@ARGV\n\n";

d42 1
a42 1
            perl=s todo=s version=s debug base
d45 4
d52 2
d57 1
a57 1
for (`nm $fullperl`) {
d66 2
d70 1
d72 1
a73 3
  my $r = run(qw(make test));
  $r->{didnotrun} and die "couldn't run make test: $!\n";
  $r->{status} == 0 and last;
d75 4
d91 32
a122 4
    if ($l =~ /undefined symbol: (?:[Pp]erl_)?(\w+)/) {
      if (!$seen{$1}++) {
        my @@s = grep { exists $sym{$_} } $1, "Perl_$1", "perl_$1";
        push @@new, [$1, @@s ? "U (@@s)" : "U"];
d126 1
d128 1
a130 3
    # TODO: @@recheck was here, find a better way to get recheck syms
    #       * we definitely don't have to check (U) symbols
    #       * try to grep out warnings before making symlist ?
d132 1
d142 4
a145 1
  push @@recheck, map { $_->[0] } @@new;
d147 1
a147 1
    printf "[$opt{version}] new symbol: %-30s # %s\n", @@$_;
d150 1
d154 38
a191 12
for my $sym (@@recheck) {
  my $cur = delete $all{$sym};
  printf "[$opt{version}] chk symbol: %-30s # %s\n", $sym, $cur;
  write_todo($opt{todo}, $opt{version}, \%all);
  regen_all();
  my $r = run(qw(make test));
  $r->{didnotrun} and die "couldn't run make test: $!\n";
  if ($r->{status} == 0) {
    printf "[$opt{version}] del symbol: %-30s # %s\n", $sym, $cur;
  }
  else {
    $all{$sym} = $cur;
d201 15
d218 1
a218 1
  my @@mf_arg = qw( --with-apicheck OPTIMIZE=-O0 );
d230 2
a231 1
  system "$fullperl apicheck_c.PL >/dev/null";
d274 1
a274 1
sub run
d276 14
a289 2
  my $prog = shift;
  my @@args = @@_;
d291 2
a292 1
  # print "[$prog @@args]\n";
d294 3
a296 1
  system "$prog @@args >tmp.out 2>tmp.err";
d298 1
a298 2
  my $out = new IO::File "tmp.out" || die "tmp.out: $!\n";
  my $err = new IO::File "tmp.err" || die "tmp.err: $!\n";
d300 3
a302 6
  my %rval = (
    status    => $? >> 8,
    stdout    => [<$out>],
    stderr    => [<$err>],
    didnotrun => 0,
  );
d304 1
a304 1
  unlink "tmp.out", "tmp.err";
d306 7
a312 2
  $? & 128 and $rval{core}   = 1;
  $? & 127 and $rval{signal} = $? & 127;
d314 1
a314 1
  \%rval;
d317 30
@


1.1
log
@Initial revision
@
text
@d8 3
a10 3
#  $Revision: 6 $
#  $Author: mhx $
#  $Date: 2004/08/13 12:50:23 +0200 $
d14 1
a14 1
#  Version 3.x, Copyright (C) 2004, Marcus Holland-Moritz.
@


1.1.1.1
log
@perl 5.8.6 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.8 import
@
text
@d8 1
a8 1
#  $Revision: 7 $
d10 1
a10 1
#  $Date: 2005/01/31 08:10:50 +0100 $
d14 1
a14 1
#  Version 3.x, Copyright (C) 2004-2005, Marcus Holland-Moritz.
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d8 1
a8 1
#  $Revision: 14 $
d10 1
a10 1
#  $Date: 2007/08/12 08:45:39 +0200 $
d14 1
a14 1
#  Version 3.x, Copyright (C) 2004-2007, Marcus Holland-Moritz.
a27 2
use Config;
use Time::HiRes qw( gettimeofday tv_interval );
d29 4
a32 1
require 'devel/devtools.pl';
d34 1
a34 7
our %opt = (
  debug   => 0,
  base    => 0,
  verbose => 0,
  check   => 1,
  shlib   => 'blib/arch/auto/Devel/PPPort/PPPort.so',
);
d37 1
a37 1
            perl=s todo=s version=s shlib=s debug base verbose check!
a39 4
identify();

print "\n", ident_str(), "\n\n";

a42 2
$ENV{SKIP_SLOW_TESTS} = 1;

d46 1
a46 1
for (`$Config{nm} $fullperl`) {
a54 2
my $symmap = get_apicheck_symbol_map();

a56 1
  my $trynm = 1;
a57 1

d59 3
a62 4

  my $r = run(qw(make));
  $r->{didnotrun} and die "couldn't run make: $!\n";

d75 4
a78 32
  }

  if ($r->{status} == 0) {
    my @@u;
    my @@usym;

    if ($trynm) {
      @@u = eval { find_undefined_symbols($fullperl, $opt{shlib}) };
      warn "warning: $@@" if $@@;
      $trynm = 0;
    }

    unless (@@u) {
      $r = run(qw(make test));
      $r->{didnotrun} and die "couldn't run make test: $!\n";
      $r->{status} == 0 and last;

      for my $l (@@{$r->{stderr}}) {
        if ($l =~ /undefined symbol: (\w+)/) {
          push @@u, $1;
        }
      }
    }

    for my $u (@@u) {
      for my $m (keys %{$symmap->{$u}}) {
        if (!$seen{$m}++) {
          my $pl = $m;
          $pl =~ s/^[Pp]erl_//;
          my @@s = grep { exists $sym{$_} } $pl, "Perl_$pl", "perl_$pl";
          push @@new, [$m, @@s ? "U (@@s)" : "U"];
        }
a81 1

a82 1

d85 3
a88 1

d98 1
a98 4

  # don't recheck undefined symbols reported by the dynamic linker
  push @@recheck, map { $_->[0] } grep { $_->[1] !~ /^U/ } @@new;

d100 1
a100 1
    sym('new', @@$_);
a102 1

d106 12
a117 38
if ($opt{check}) {
  my $ifmt = '%' . length(scalar @@recheck) . 'd';
  my $t0 = [gettimeofday];
  
  RECHECK: for my $i (0 .. $#recheck) {
    my $sym = $recheck[$i];
    my $cur = delete $all{$sym};
  
    sym('chk', $sym, $cur, sprintf(" [$ifmt/$ifmt, ETA %s]",
               $i + 1, scalar @@recheck, eta($t0, $i, scalar @@recheck)));
  
    write_todo($opt{todo}, $opt{version}, \%all);
  
    if ($cur eq "E (Perl_$sym)") {
      # we can try a shortcut here
      regen_apicheck($sym);
  
      my $r = run(qw(make test));
  
      if (!$r->{didnotrun} && $r->{status} == 0) {
        sym('del', $sym, $cur);
        next RECHECK;
      }
    }
  
    # run the full test
    regen_all();
  
    my $r = run(qw(make test));
  
    $r->{didnotrun} and die "couldn't run make test: $!\n";
  
    if ($r->{status} == 0) {
      sym('del', $sym, $cur);
    }
    else {
      $all{$sym} = $cur;
    }
a126 15
sub sym
{
  my($what, $sym, $reason, $extra) = @@_;
  $extra ||= '';
  my %col = (
    'new' => 'bold red',
    'chk' => 'bold magenta',
    'del' => 'bold green',
  );
  $what = colored("$what symbol", $col{$what});

  printf "[%s] %s %-30s # %s%s\n",
         $opt{version}, $what, $sym, $reason, $extra;
}

d129 1
a129 1
  my @@mf_arg = ('--with-apicheck', 'OPTIMIZE=-O0 -w');
d141 1
a141 2
  runtool({ out => '/dev/null' }, $fullperl, 'apicheck_c.PL', map { "--api=$_" } @@_)
      or die "cannot regenerate apicheck.c\n";
d184 1
a184 1
sub find_undefined_symbols
d186 2
a187 1
  my($perl, $shlib) = @@_;
d189 1
a189 2
  my $ps = read_sym(file => $perl,  options => [qw( --defined-only   )]);
  my $ls = read_sym(file => $shlib, options => [qw( --undefined-only )]);
d191 1
a191 1
  my @@undefined;
d193 2
a194 7
  for my $sym (keys %$ls) {
    unless (exists $ps->{$sym}) {
      if ($sym !~ /\@@/ and $sym !~ /^_/) {
        push @@undefined, $sym;
      }
    }
  }
d196 6
a201 12
  return @@undefined;
}

sub read_sym
{
  my %opt = ( options => [], @@_ );

  my $r = run($Config{nm}, @@{$opt{options}}, $opt{file});

  if ($r->{didnotrun} or $r->{status}) {
    die "cannot run $Config{nm}";
  }
d203 1
a203 1
  my %sym;
d205 2
a206 7
  for (@@{$r->{stdout}}) {
    chomp;
    my($adr, $fmt, $sym) = /^\s*([[:xdigit:]]+)?\s+([ABCDGINRSTUVW?-])\s+(\S+)\s*$/i
                           or die "cannot parse $Config{nm} output:\n[$_]\n";
    $sym{$sym} = { format => $fmt };
    $sym{$sym}{address} = $adr if defined $adr;
  }
d208 1
a208 1
  return \%sym;
a210 30
sub get_apicheck_symbol_map
{
  my $r = run(qw(make apicheck.i));
  
  if ($r->{didnotrun} or $r->{status}) {
    die "cannot run make apicheck.i";
  }

  my $fh = IO::File->new('apicheck.i')
           or die "cannot open apicheck.i: $!";

  local $_;
  my %symmap;
  my $cur;

  while (<$fh>) {
    next if /^#/;
    if (defined $cur) {
      for my $sym (/\b([A-Za-z_]\w+)\b/g) {
        $symmap{$sym}{$cur}++;
      }
      undef $cur if /^}$/;
    }
    else {
      /_DPPP_test_(\w+)/ and $cur = $1;
    }
  }

  return \%symmap;
}
@


