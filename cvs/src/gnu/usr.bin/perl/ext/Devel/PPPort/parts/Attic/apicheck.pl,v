head	1.4;
access;
symbols
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.2.0.10
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.8
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.6
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.4
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.1.0.6
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.4
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.2
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2009.10.12.18.24.25;	author millert;	state dead;
branches;
next	1.3;

1.3
date	2008.09.29.17.36.03;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.28.19.23.02;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.15.21.16.45;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.01.15.21.16.45;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.03.28.18.47.58;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.15;	author millert;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge in perl 5.10.1
@
text
@#!/usr/bin/perl -w
################################################################################
#
#  apicheck.pl -- generate C source for automated API check
#
################################################################################
#
#  $Revision: 1.3 $
#  $Author: millert $
#  $Date: 2008/09/29 17:36:03 $
#
################################################################################
#
#  Version 3.x, Copyright (C) 2004-2007, Marcus Holland-Moritz.
#  Version 2.x, Copyright (C) 2001, Paul Marquess.
#  Version 1.x, Copyright (C) 1999, Kenneth Albanowski.
#
#  This program is free software; you can redistribute it and/or
#  modify it under the same terms as Perl itself.
#
################################################################################

use strict;
require 'parts/ppptools.pl';

if (@@ARGV) {
  my $file = pop @@ARGV;
  open OUT, ">$file" or die "$file: $!\n";
}
else {
  *OUT = \*STDOUT;
}

my @@f = parse_embed(qw( parts/embed.fnc parts/apidoc.fnc parts/ppport.fnc ));

my %todo = %{&parse_todo};

my %tmap = (
  void => 'int',
);

my %amap = (
  SP   => 'SP',
  type => 'int',
  cast => 'int',
);

my %void = (
  void     => 1,
  Free_t   => 1,
  Signal_t => 1,
);

my %castvoid = (
  map { ($_ => 1) } qw(
    Nullav
    Nullcv
    Nullhv
    Nullch
    Nullsv
    HEf_SVKEY
    SP
    MARK
    SVt_PV
    SVt_IV
    SVt_NV
    SVt_PVMG
    SVt_PVAV
    SVt_PVHV
    SVt_PVCV
    SvUOK
    G_SCALAR
    G_ARRAY
    G_VOID
    G_DISCARD
    G_EVAL
    G_NOARGS
    XS_VERSION
  ),
);

my %ignorerv = (
  map { ($_ => 1) } qw(
    newCONSTSUB
  ),
);

my %stack = (
  ORIGMARK       => ['dORIGMARK;'],
  POPpx          => ['STRLEN n_a;'],
  POPpbytex      => ['STRLEN n_a;'],
  PUSHp          => ['dTARG;'],
  PUSHn          => ['dTARG;'],
  PUSHi          => ['dTARG;'],
  PUSHu          => ['dTARG;'],
  XPUSHp         => ['dTARG;'],
  XPUSHn         => ['dTARG;'],
  XPUSHi         => ['dTARG;'],
  XPUSHu         => ['dTARG;'],
  UNDERBAR       => ['dUNDERBAR;'],
  XCPT_TRY_START => ['dXCPT;'],
  XCPT_TRY_END   => ['dXCPT;'],
  XCPT_CATCH     => ['dXCPT;'],
  XCPT_RETHROW   => ['dXCPT;'],
);

my %ignore = (
  map { ($_ => 1) } qw(
    svtype
    items
    ix
    dXSI32
    XS
    CLASS
    THIS
    RETVAL
    StructCopy
  ),
);

print OUT <<HEAD;
/*
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by $0.
 * Any changes made here will be lost!
 */

#include "EXTERN.h"
#include "perl.h"

#define NO_XSLOCKS
#include "XSUB.h"

#ifdef DPPP_APICHECK_NO_PPPORT_H

/* This is just to avoid too many baseline failures with perls < 5.6.0 */

#ifndef dTHX
#  define dTHX extern int Perl___notused
#endif

#else

#define NEED_PL_signals
#define NEED_eval_pv
#define NEED_grok_bin
#define NEED_grok_hex
#define NEED_grok_number
#define NEED_grok_numeric_radix
#define NEED_grok_oct
#define NEED_load_module
#define NEED_my_snprintf
#define NEED_my_strlcat
#define NEED_my_strlcpy
#define NEED_newCONSTSUB
#define NEED_newRV_noinc
#define NEED_newSVpvn_share
#define NEED_sv_2pv_flags
#define NEED_sv_2pvbyte
#define NEED_sv_catpvf_mg
#define NEED_sv_catpvf_mg_nocontext
#define NEED_sv_pvn_force_flags
#define NEED_sv_setpvf_mg
#define NEED_sv_setpvf_mg_nocontext
#define NEED_vload_module
#define NEED_vnewSVpvf
#define NEED_warner

#include "ppport.h"

#endif

static int    VARarg1;
static char  *VARarg2;
static double VARarg3;

HEAD

if (@@ARGV) {
  my %want = map { ($_ => 0) } @@ARGV;
  @@f = grep { exists $want{$_->{name}} } @@f;
  for (@@f) { $want{$_->{name}}++ }
  for (keys %want) {
    die "nothing found for '$_'\n" unless $want{$_};
  }
}

my $f;
for $f (@@f) {
  $ignore{$f->{name}} and next;
  $f->{flags}{A} or next;  # only public API members

  $ignore{$f->{name}} = 1; # ignore duplicates

  my $Perl_ = $f->{flags}{p} ? 'Perl_' : '';

  my $stack = '';
  my @@arg;
  my $aTHX = '';

  my $i = 1;
  my $ca;
  my $varargs = 0;
  for $ca (@@{$f->{args}}) {
    my $a = $ca->[0];
    if ($a eq '...') {
      $varargs = 1;
      push @@arg, qw(VARarg1 VARarg2 VARarg3);
      last;
    }
    my($n, $p, $d) = $a =~ /^ (\w+(?:\s+\w+)*)\s*  # type name  => $n
                              (\**)                # pointer    => $p
                              (?:\s*const\s*)?     # const
                              ((?:\[[^\]]*\])*)    # dimension  => $d
                            $/x
                     or die "$0 - cannot parse argument: [$a]\n";
    if (exists $amap{$n}) {
      push @@arg, $amap{$n};
      next;
    }
    $n = $tmap{$n} || $n;
    if ($n eq 'const char' and $p eq '*' and !$f->{flags}{f}) {
      push @@arg, '"foo"';
    }
    else {
      my $v = 'arg' . $i++;
      push @@arg, $v;
      $stack .= "  static $n $p$v$d;\n";
    }
  }

  unless ($f->{flags}{n} || $f->{flags}{'m'}) {
    $stack = "  dTHX;\n$stack";
    $aTHX = @@arg ? 'aTHX_ ' : 'aTHX';
  }

  if ($stack{$f->{name}}) {
    my $s = '';
    for (@@{$stack{$f->{name}}}) {
      $s .= "  $_\n";
    }
    $stack = "$s$stack";
  }

  my $args = join ', ', @@arg;
  my $rvt = $f->{ret} || 'void';
  my $ret;
  if ($void{$rvt}) {
    $ret = $castvoid{$f->{name}} ? '(void) ' : '';
  }
  else {
    $stack .= "  $rvt rval;\n";
    $ret = $ignorerv{$f->{name}} ? '(void) ' : "rval = ";
  }
  my $aTHX_args = "$aTHX$args";

  unless ($f->{flags}{'m'} and @@arg == 0) {
    $args = "($args)";
    $aTHX_args = "($aTHX_args)";
  }

  print OUT <<HEAD;
/******************************************************************************
*
*  $f->{name}
*
******************************************************************************/

HEAD

  if ($todo{$f->{name}}) {
    my($ver,$sub) = $todo{$f->{name}} =~ /^5\.(\d{3})(\d{3})$/ or die;
    for ($ver, $sub) {
      s/^0+(\d)/$1/
    }
    if ($ver < 6 && $sub > 0) {
      $sub =~ s/0$// or die;
    }
    print OUT "#if PERL_VERSION > $ver || (PERL_VERSION == $ver && PERL_SUBVERSION >= $sub) /* TODO */\n";
  }

  my $final = $varargs
              ? "$Perl_$f->{name}$aTHX_args"
              : "$f->{name}$args";

  $f->{cond} and print OUT "#if $f->{cond}\n";

  print OUT <<END;
void _DPPP_test_$f->{name} (void)
{
  dXSARGS;
$stack
  {
#ifdef $f->{name}
    $ret$f->{name}$args;
#endif
  }

  {
#ifdef $f->{name}
    $ret$final;
#else
    $ret$Perl_$f->{name}$aTHX_args;
#endif
  }
}
END

  $f->{cond} and print OUT "#endif\n";
  $todo{$f->{name}} and print OUT "#endif\n";

  print OUT "\n";
}

@@ARGV and close OUT;

@


1.3
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d8 3
a10 3
#  $Revision: 27 $
#  $Author: mhx $
#  $Date: 2007/08/19 19:41:03 +0200 $
@


1.2
log
@merge in perl 5.8.8
@
text
@d8 3
a10 3
#  $Revision: 1.1.1.1 $
#  $Author: millert $
#  $Date: 2005/01/15 21:16:45 $
d14 1
a14 1
#  Version 3.x, Copyright (C) 2004-2005, Marcus Holland-Moritz.
d27 2
a28 1
  open OUT, ">$ARGV[0]" or die "$ARGV[0]: $!\n";
d34 1
a34 1
my @@f = parse_embed(qw( parts/embed.fnc parts/apidoc.fnc ));
a106 14
my %postcode = (
  dSP        => "some_global_var = !sp;",
  dMARK      => "some_global_var = !mark;",
  dORIGMARK  => "some_global_var = !origmark;",
  dAX        => "some_global_var = !ax;",
  dITEMS     => "some_global_var = !items;",
  dXSARGS    => "some_global_var = ax && items;",
  NEWSV      => "some_global_var = !arg1;",
  New        => "some_global_var = !arg1;",
  Newc       => "some_global_var = !arg1;",
  Newz       => "some_global_var = !arg1;",
  dUNDERBAR  => "(void) UNDERBAR;",
);

d134 3
a136 1
#ifndef DPPP_APICHECK_NO_PPPORT_H
d138 7
d151 4
d157 2
a158 1
#define NEED_sv_2pv_nolen
d162 1
d165 1
d167 1
a167 1

a172 2
static int some_global_var;

d179 9
d213 1
d222 8
a229 3
    my $v = 'arg' . $i++;
    push @@arg, $v;
    $stack .= "  static $n $p$v$d;\n";
d252 2
a253 1
    $ret = $ignorerv{$f->{name}} ? '(void) ' : "return ";
a256 7
  my $post = '';
  if ($postcode{$f->{name}}) {
    $post = $postcode{$f->{name}};
    $post =~ s/^/    /g;
    $post = "\n$post";
  }

d289 1
a289 1
$rvt _DPPP_test_$f->{name} (void)
d293 1
d295 2
a296 3
  if (some_global_var)
  {
    $ret$f->{name}$args;$post
a297 3
#endif

  some_global_var = items && ax;
d301 1
a301 1
    $ret$final;$post
d303 1
a303 1
    $ret$Perl_$f->{name}$aTHX_args;$post
@


1.1
log
@Initial revision
@
text
@d8 3
a10 3
#  $Revision: 10 $
#  $Author: mhx $
#  $Date: 2004/08/17 20:56:15 +0200 $
d14 1
a14 1
#  Version 3.x, Copyright (C) 2004, Marcus Holland-Moritz.
d88 16
a103 12
  ORIGMARK  => ['dORIGMARK;'],
  POPpx     => ['STRLEN n_a;'],
  POPpbytex => ['STRLEN n_a;'],
  PUSHp     => ['dTARG;'],
  PUSHn     => ['dTARG;'],
  PUSHi     => ['dTARG;'],
  PUSHu     => ['dTARG;'],
  XPUSHp    => ['dTARG;'],
  XPUSHn    => ['dTARG;'],
  XPUSHi    => ['dTARG;'],
  XPUSHu    => ['dTARG;'],
  UNDERBAR  => ['dUNDERBAR;'],
d143 2
d201 5
a205 1
    my($n, $p, $d) = $a =~ /^(\w+(?:\s+\w+)*)\s*(\**)((?:\[[^\]]*\])*)$/ or die;
@


1.1.1.1
log
@perl 5.8.6 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.8 import
@
text
@d8 1
a8 1
#  $Revision: 13 $
d10 1
a10 1
#  $Date: 2005/06/25 16:47:31 +0200 $
d14 1
a14 1
#  Version 3.x, Copyright (C) 2004-2005, Marcus Holland-Moritz.
d88 12
a99 16
  ORIGMARK       => ['dORIGMARK;'],
  POPpx          => ['STRLEN n_a;'],
  POPpbytex      => ['STRLEN n_a;'],
  PUSHp          => ['dTARG;'],
  PUSHn          => ['dTARG;'],
  PUSHi          => ['dTARG;'],
  PUSHu          => ['dTARG;'],
  XPUSHp         => ['dTARG;'],
  XPUSHn         => ['dTARG;'],
  XPUSHi         => ['dTARG;'],
  XPUSHu         => ['dTARG;'],
  UNDERBAR       => ['dUNDERBAR;'],
  XCPT_TRY_START => ['dXCPT;'],
  XCPT_TRY_END   => ['dXCPT;'],
  XCPT_CATCH     => ['dXCPT;'],
  XCPT_RETHROW   => ['dXCPT;'],
a138 2

#define NO_XSLOCKS
d195 1
a195 5
    my($n, $p, $d) = $a =~ /^ (\w+(?:\s+\w+)*)\s*  # type name  => $n
                              (\**)                # pointer    => $p
                              ((?:\[[^\]]*\])*)    # dimension  => $d
                            $/x
                     or die "$0 - cannot parse argument: [$a]\n";
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d8 1
a8 1
#  $Revision: 27 $
d10 1
a10 1
#  $Date: 2007/08/19 19:41:03 +0200 $
d14 1
a14 1
#  Version 3.x, Copyright (C) 2004-2007, Marcus Holland-Moritz.
d27 1
a27 2
  my $file = pop @@ARGV;
  open OUT, ">$file" or die "$file: $!\n";
d33 1
a33 1
my @@f = parse_embed(qw( parts/embed.fnc parts/apidoc.fnc parts/ppport.fnc ));
d106 14
d147 1
a147 3
#ifdef DPPP_APICHECK_NO_PPPORT_H

/* This is just to avoid too many baseline failures with perls < 5.6.0 */
a148 7
#ifndef dTHX
#  define dTHX extern int Perl___notused
#endif

#else

#define NEED_PL_signals
a154 4
#define NEED_load_module
#define NEED_my_snprintf
#define NEED_my_strlcat
#define NEED_my_strlcpy
d157 1
a157 2
#define NEED_newSVpvn_share
#define NEED_sv_2pv_flags
a160 1
#define NEED_sv_pvn_force_flags
a162 1
#define NEED_vload_module
d164 1
a164 1
#define NEED_warner
d170 2
a177 9
if (@@ARGV) {
  my %want = map { ($_ => 0) } @@ARGV;
  @@f = grep { exists $want{$_->{name}} } @@f;
  for (@@f) { $want{$_->{name}}++ }
  for (keys %want) {
    die "nothing found for '$_'\n" unless $want{$_};
  }
}

a202 1
                              (?:\s*const\s*)?     # const
d211 3
a213 8
    if ($n eq 'const char' and $p eq '*' and !$f->{flags}{f}) {
      push @@arg, '"foo"';
    }
    else {
      my $v = 'arg' . $i++;
      push @@arg, $v;
      $stack .= "  static $n $p$v$d;\n";
    }
d236 1
a236 2
    $stack .= "  $rvt rval;\n";
    $ret = $ignorerv{$f->{name}} ? '(void) ' : "rval = ";
d240 7
d279 1
a279 1
void _DPPP_test_$f->{name} (void)
d283 2
d286 2
a287 2
#ifdef $f->{name}
    $ret$f->{name}$args;
d289 2
a290 1
  }
d294 1
a294 1
    $ret$final;
d296 1
a296 1
    $ret$Perl_$f->{name}$aTHX_args;
@


