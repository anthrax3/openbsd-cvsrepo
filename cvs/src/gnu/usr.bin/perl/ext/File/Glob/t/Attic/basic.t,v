head	1.2;
access;
symbols
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2009.10.12.18.24.28;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.50;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.48.15;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.21;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Merge in perl 5.10.1
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    if ($^O eq 'MacOS') { 
	@@INC = qw(: ::lib ::macos:lib); 
    } else { 
	@@INC = '.'; 
	push @@INC, '../lib'; 
    }
    require Config; import Config;
    if ($Config{'extensions'} !~ /\bFile\/Glob\b/i) {
        print "1..0\n";
        exit 0;
    }
    print "1..11\n";
}
END {
    print "not ok 1\n" unless $loaded;
}
use File::Glob ':glob';
use Cwd ();
$loaded = 1;
print "ok 1\n";

sub array {
    return '(', join(", ", map {defined $_ ? "\"$_\"" : "undef"} @@a), ")\n";
}

# look for the contents of the current directory
$ENV{PATH} = "/bin";
delete @@ENV{BASH_ENV, CDPATH, ENV, IFS};
@@correct = ();
if (opendir(D, $^O eq "MacOS" ? ":" : ".")) {
   @@correct = grep { !/^\./ } sort readdir(D);
   closedir D;
}
@@a = File::Glob::glob("*", 0);
@@a = sort @@a;
if ("@@a" ne "@@correct" || GLOB_ERROR) {
    print "# |@@a| ne |@@correct|\nnot ";
}
print "ok 2\n";

# look up the user's home directory
# should return a list with one item, and not set ERROR
if ($^O ne 'MSWin32' && $^O ne 'NetWare' && $^O ne 'VMS' && $^O ne 'os2') {
  eval {
    ($name, $home) = (getpwuid($>))[0,7];
    1;
  } and do {
    if (defined $home && defined $name && -d $home) {
	@@a = bsd_glob("~$name", GLOB_TILDE);
	if ((scalar(@@a) != 1 || $a[0] ne $home || GLOB_ERROR)) {
	    print "not ";
	}
    }
  };
}
print "ok 3\n";

# check backslashing
# should return a list with one item, and not set ERROR
@@a = bsd_glob('TEST', GLOB_QUOTE);
if (scalar @@a != 1 || $a[0] ne 'TEST' || GLOB_ERROR) {
    local $/ = "][";
    print "# [@@a]\n";
    print "not ";
}
print "ok 4\n";

# check nonexistent checks
# should return an empty list
# XXX since errfunc is NULL on win32, this test is not valid there
@@a = bsd_glob("asdfasdf", 0);
if (($^O ne 'MSWin32' && $^O ne 'NetWare') and scalar @@a != 0) {
    print "# |@@a|\nnot ";
}
print "ok 5\n";

# check bad protections
# should return an empty list, and set ERROR
if ($^O eq 'mpeix' or $^O eq 'MSWin32' or $^O eq 'NetWare' or $^O eq 'os2' or $^O eq 'VMS'
    or $^O eq 'cygwin' or Cwd::cwd() =~ m#^$Config{'afsroot'}#s or not $>)
{
    print "ok 6 # skipped\n";
}
else {
    $dir = "pteerslo";
    mkdir $dir, 0;
    @@a = bsd_glob("$dir/*", GLOB_ERR);
    #print "\@@a = ", array(@@a);
    rmdir $dir;
    if (scalar(@@a) != 0 || GLOB_ERROR == 0) {
	if ($^O eq 'vos') {
	    print "not ok 6 # TODO hit VOS bug posix-956\n";
	} else {
	    print "not ok 6\n";
	}
    }
    else {
	print "ok 6\n";
    }
}

# check for csh style globbing
@@a = bsd_glob('{a,b}', GLOB_BRACE | GLOB_NOMAGIC);
unless (@@a == 2 and $a[0] eq 'a' and $a[1] eq 'b') {
    print "not ";
}
print "ok 7\n";

@@a = bsd_glob(
    '{TES*,doesntexist*,a,b}',
    GLOB_BRACE | GLOB_NOMAGIC | ($^O eq 'VMS' ? GLOB_NOCASE : 0)
);

# Working on t/TEST often causes this test to fail because it sees Emacs temp
# and RCS files.  Filter them out, and .pm files too, and patch temp files.
@@a = grep !/(,v$|~$|\.(pm|ori?g|rej)$)/, @@a;
@@a = (grep !/test.pl/, @@a) if $^O eq 'VMS';

print "# @@a\n";

unless (@@a == 3
        and $a[0] eq ($^O eq 'VMS'? 'test.' : 'TEST')
        and $a[1] eq 'a'
        and $a[2] eq 'b')
{
    print "not ok 8 # @@a\n";
} else {
    print "ok 8\n";
}

# "~" should expand to $ENV{HOME}
$ENV{HOME} = "sweet home";
@@a = bsd_glob('~', GLOB_TILDE | GLOB_NOMAGIC);
unless ($^O eq "MacOS" || (@@a == 1 and $a[0] eq $ENV{HOME})) {
    print "not ";
}
print "ok 9\n";

# GLOB_ALPHASORT (default) should sort alphabetically regardless of case
mkdir "pteerslo", 0777;
chdir "pteerslo";

@@f_names = qw(Ax.pl Bx.pl Cx.pl aY.pl bY.pl cY.pl);
@@f_alpha = qw(Ax.pl aY.pl Bx.pl bY.pl Cx.pl cY.pl);
if ('a' lt 'A') { # EBCDIC char sets sort lower case before UPPER
    @@f_names = sort(@@f_names);
}
if ($^O eq 'VMS') { # VMS is happily caseignorant
    @@f_alpha = qw(ax.pl ay.pl bx.pl by.pl cx.pl cy.pl);
    @@f_names = @@f_alpha;
}

for (@@f_names) {
    open T, "> $_";
    close T;
}

$pat = "*.pl";

$ok = 1;
@@g_names = bsd_glob($pat, 0);
print "# f_names = @@f_names\n";
print "# g_names = @@g_names\n";
for (@@f_names) {
    $ok = 0 unless $_ eq shift @@g_names;
}
print $ok ? "ok 10\n" : "not ok 10\n";

$ok = 1;
@@g_alpha = bsd_glob($pat);
print "# f_alpha = @@f_alpha\n";
print "# g_alpha = @@g_alpha\n";
for (@@f_alpha) {
    $ok = 0 unless $_ eq shift @@g_alpha;
}
print $ok ? "ok 11\n" : "not ok 11\n";

unlink @@f_names;
chdir "..";
rmdir "pteerslo";
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d16 1
a16 1
    print "1..12\n";
a184 4

# this can panic if PL_glob_index gets passed as flags to bsd_glob
<*>; <*>;
print "ok 12\n";
@


1.1.1.3
log
@perl 5.8.8 import
@
text
@d47 1
a47 2
if ($^O ne 'MSWin32' && $^O ne 'NetWare' && $^O ne 'VMS' && $^O ne 'os2'
    && $^O ne 'beos') {
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d16 1
a16 1
    print "1..13\n";
a189 24

{
    use File::Temp qw(tempdir);
    use File::Spec qw();

    my($dir) = tempdir(CLEANUP => 1)
	or die "Could not create temporary directory";
    for my $file (qw(a_dej a_ghj a_qej)) {
	open my $fh, ">", File::Spec->catfile($dir, $file)
	    or die "Could not create file $dir/$file: $!";
	close $fh;
    }
    my $cwd = Cwd::cwd();
    chdir $dir
	or die "Could not chdir to $dir: $!";
    my(@@glob_files) = glob("a*{d[e]}j");
    if (!(@@glob_files == 1 && "@@glob_files" eq "a_dej")) {
	print "not ";
    }
    my $todo = $^O ne 'VMS' ? '' : " # TODO home-made glob doesn't do regexes";
    print "ok 13$todo\n";
    chdir $cwd
	or die "Could not chdir back to $cwd: $!";
}
@


