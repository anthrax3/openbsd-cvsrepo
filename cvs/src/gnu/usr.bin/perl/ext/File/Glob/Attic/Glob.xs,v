head	1.2;
access;
symbols
	OPENBSD_4_6:1.1.1.5.0.16
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.12
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.8
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.6
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.4
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.6
	OPENBSD_3_5_BASE:1.1.1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2009.10.12.18.24.28;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2000.04.06.16.09.13;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.09.13;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.22.48;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.46.21;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.14;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Merge in perl 5.10.1
@
text
@#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "bsd_glob.h"

static int GLOB_ERROR = 0;

static int
not_here(char *s)
{
    croak("%s not implemented on this architecture", s);
    return -1;
}


static double
constant(char *name, int arg)
{
    errno = 0;
    if (strlen(name) <= 5)
        goto not_there;
    switch (*(name+5)) {
    case 'A':
	if (strEQ(name, "GLOB_ABEND"))
#ifdef GLOB_ABEND
	    return GLOB_ABEND;
#else
	    goto not_there;
#endif
	if (strEQ(name, "GLOB_ALTDIRFUNC"))
#ifdef GLOB_ALTDIRFUNC
	    return GLOB_ALTDIRFUNC;
#else
	    goto not_there;
#endif
	break;
    case 'B':
	if (strEQ(name, "GLOB_BRACE"))
#ifdef GLOB_BRACE
	    return GLOB_BRACE;
#else
	    goto not_there;
#endif
	break;
    case 'C':
	break;
    case 'D':
	break;
    case 'E':
	if (strEQ(name, "GLOB_ERR"))
#ifdef GLOB_ERR
	    return GLOB_ERR;
#else
	    goto not_there;
#endif
        if (strEQ(name, "GLOB_ERROR"))
            return GLOB_ERROR;
        break;
    case 'F':
	break;
    case 'G':
        break;
    case 'H':
	break;
    case 'I':
	break;
    case 'J':
	break;
    case 'K':
	break;
    case 'L':
	break;
    case 'M':
	if (strEQ(name, "GLOB_MARK"))
#ifdef GLOB_MARK
	    return GLOB_MARK;
#else
	    goto not_there;
#endif
	break;
    case 'N':
	if (strEQ(name, "GLOB_NOCASE"))
#ifdef GLOB_NOCASE
	    return GLOB_NOCASE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "GLOB_NOCHECK"))
#ifdef GLOB_NOCHECK
	    return GLOB_NOCHECK;
#else
	    goto not_there;
#endif
	if (strEQ(name, "GLOB_NOMAGIC"))
#ifdef GLOB_NOMAGIC
	    return GLOB_NOMAGIC;
#else
	    goto not_there;
#endif
	if (strEQ(name, "GLOB_NOSORT"))
#ifdef GLOB_NOSORT
	    return GLOB_NOSORT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "GLOB_NOSPACE"))
#ifdef GLOB_NOSPACE
	    return GLOB_NOSPACE;
#else
	    goto not_there;
#endif
	break;
    case 'O':
	break;
    case 'P':
	break;
    case 'Q':
	if (strEQ(name, "GLOB_QUOTE"))
#ifdef GLOB_QUOTE
	    return GLOB_QUOTE;
#else
	    goto not_there;
#endif
	break;
    case 'R':
	break;
    case 'S':
	break;
    case 'T':
	if (strEQ(name, "GLOB_TILDE"))
#ifdef GLOB_TILDE
	    return GLOB_TILDE;
#else
	    goto not_there;
#endif
	break;
    case 'U':
	break;
    case 'V':
	break;
    case 'W':
	break;
    case 'X':
	break;
    case 'Y':
	break;
    case 'Z':
	break;
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}

#ifdef WIN32
#define errfunc		NULL
#else
int
errfunc(const char *foo, int bar) {
  return !(bar == ENOENT || bar == ENOTDIR);
}
#endif

MODULE = File::Glob		PACKAGE = File::Glob

void
doglob(pattern,...)
    char *pattern
PROTOTYPE: $;$
PREINIT:
    glob_t pglob;
    int i;
    int retval;
    int flags = 0;
    SV *tmp;
PPCODE:
    {
	/* allow for optional flags argument */
	if (items > 1) {
	    flags = (int) SvIV(ST(1));
	}

	/* call glob */
	retval = bsd_glob(pattern, flags, errfunc, &pglob);
	GLOB_ERROR = retval;

	/* return any matches found */
	EXTEND(sp, pglob.gl_pathc);
	for (i = 0; i < pglob.gl_pathc; i++) {
	    /* printf("# bsd_glob: %s\n", pglob.gl_pathv[i]); */
	    tmp = sv_2mortal(newSVpvn(pglob.gl_pathv[i],
				      strlen(pglob.gl_pathv[i])));
	    TAINT;
	    SvTAINT(tmp);
	    PUSHs(tmp);
	}

	bsd_globfree(&pglob);
    }

double
constant(name,arg)
    char *name
    int   arg
PROTOTYPE: $$
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@a6 1
/* XXX: need some thread awareness */
d9 8
a27 6
#else
	    goto not_there;
#endif
	if (strEQ(name, "GLOB_ALPHASORT"))
#ifdef GLOB_ALPHASORT
	    return GLOB_ALPHASORT;
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d7 2
a8 1
#define MY_CXT_KEY "File::Glob::_guts" XS_VERSION
d10 142
a151 3
typedef struct {
    int		x_GLOB_ERROR;
} my_cxt_t;
d153 4
a156 5
START_MY_CXT

#define GLOB_ERROR	(MY_CXT.x_GLOB_ERROR)

#include "const-c.inc"
a168 5
BOOT:
{
    MY_CXT_INIT;
}

a180 2
	dMY_CXT;

d204 5
a208 1
INCLUDE: const-xs.inc
@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@d24 1
a24 1
  return !(bar == EACCES || bar == ENOENT || bar == ENOTDIR);
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d22 1
a22 1
static int
@


