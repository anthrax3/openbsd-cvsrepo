head	1.2;
access;
symbols
	OPENBSD_5_3:1.1.1.3.0.10
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.8
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.6
	OPENBSD_5_0:1.1.1.3.0.4
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.2
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.2.0.8
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.4
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.6
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.2
	OPENBSD_4_5_BASE:1.1.1.2
	PERL_5_10_0:1.1.1.2
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2013.03.25.20.40.55;	author sthen;	state dead;
branches;
next	1.1;

1.1
date	2003.12.03.02.43.53;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.03.02.43.53;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.09.29.17.18.24;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.09.24.14.48.50;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@#!./perl -w

my $child;
my $can_fork;
my $has_perlio;

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require Config; import Config;
    $can_fork = $Config{'d_fork'}
		|| ($^O eq 'MSWin32' && $Config{useithreads}
		    && $Config{ccflags} =~ /-DPERL_IMPLICIT_SYS\b/);


    if ($^O eq "hpux" or $Config{'extensions'} !~ /\bSocket\b/ &&
        !(($^O eq 'VMS') && $Config{d_socket})) {
	print "1..0\n";
	exit 0;
      }

    # Too many things in this test will hang forever if something is wrong,
    # so we need a self destruct timer. And IO can hang despite an alarm.

    # This is convoluted, but we must fork before Test::More, else child's
    # Test::More thinks that it ran no tests, and prints a message to that
    # effect
    if( $can_fork) {
      my $parent = $$;
      $child = fork;
      die "Fork failed" unless defined $child;
      if (!$child) {
        $SIG{INT} = sub {exit 0}; # You have 60 seconds. Your time starts now.
        my $must_finish_by = time + 60;
        my $remaining;
        while (($remaining = $must_finish_by - time) > 0) {
          sleep $remaining;
        }
        warn "Something unexpectedly hung during testing";
        kill "INT", $parent or die "Kill failed: $!";
        exit 1;
      }
    }
    unless ($has_perlio = find PerlIO::Layer 'perlio') {
	print <<EOF;
# Since you don't have perlio you might get failures with UTF-8 locales.
EOF
    }
}

use Socket;
use Test::More;
use strict;
use warnings;
use Errno;

my $skip_reason;

if( !$Config{d_alarm} ) {
  plan skip_all => "alarm() not implemented on this platform";
} elsif( !$can_fork ) {
  plan skip_all => "fork() not implemented on this platform";
} else {
  # This should fail but not die if there is real socketpair
  eval {socketpair LEFT, RIGHT, -1, -1, -1};
  if ($@@ =~ /^Unsupported socket function "socketpair" called/ ||
      $! =~ /^The operation requested is not supported./) { # Stratus VOS
    plan skip_all => 'No socketpair (real or emulated)';
  } else {
    eval {AF_UNIX};
    if ($@@ =~ /^Your vendor has not defined Socket macro AF_UNIX/) {
      plan skip_all => 'No AF_UNIX';
    } else {
      plan tests => 45;
    }
  }
}

# But we'll install an alarm handler in case any of the races below fail.
$SIG{ALRM} = sub {die "Unexpected alarm during testing"};

ok (socketpair (LEFT, RIGHT, AF_UNIX, SOCK_STREAM, PF_UNSPEC),
    "socketpair (LEFT, RIGHT, AF_UNIX, SOCK_STREAM, PF_UNSPEC)")
  or print "# \$\! = $!\n";

if ($has_perlio) {
    binmode(LEFT,  ":bytes");
    binmode(RIGHT, ":bytes");
}

my @@left = ("hello ", "world\n");
my @@right = ("perl ", "rules!"); # Not like I'm trying to bias any survey here.

foreach (@@left) {
  # is (syswrite (LEFT, $_), length $_, "write " . _qq ($_) . " to left");
  is (syswrite (LEFT, $_), length $_, "syswrite to left");
}
foreach (@@right) {
  # is (syswrite (RIGHT, $_), length $_, "write " . _qq ($_) . " to right");
  is (syswrite (RIGHT, $_), length $_, "syswrite to right");
}

# stream socket, so our writes will become joined:
my ($buffer, $expect);
$expect = join '', @@right;
undef $buffer;
is (read (LEFT, $buffer, length $expect), length $expect, "read on left");
is ($buffer, $expect, "content what we expected?");
$expect = join '', @@left;
undef $buffer;
is (read (RIGHT, $buffer, length $expect), length $expect, "read on right");
is ($buffer, $expect, "content what we expected?");

ok (shutdown(LEFT, SHUT_WR), "shutdown left for writing");
# This will hang forever if eof is buggy, and alarm doesn't interrupt system
# Calls. Hence the child process minder.
SKIP: {
  skip "SCO Unixware / OSR have a bug with shutdown",2 if $^O =~ /^(?:svr|sco)/;
  local $SIG{ALRM} = sub { warn "EOF on right took over 3 seconds" };
  local $TODO = "Known problems with unix sockets on $^O"
      if $^O eq 'hpux'   || $^O eq 'super-ux';
  alarm 3;
  $! = 0;
  ok (eof RIGHT, "right is at EOF");
  local $TODO = "Known problems with unix sockets on $^O"
      if $^O eq 'unicos' || $^O eq 'unicosmk';
  is ($!, '', 'and $! should report no error');
  alarm 60;
}

my $err = $!;
$SIG{PIPE} = 'IGNORE';
{
  local $SIG{ALRM}
    = sub { warn "syswrite to left didn't fail within 3 seconds" };
  alarm 3;
  # Split the system call from the is() - is() does IO so
  # (say) a flush may do a seek which on a pipe may disturb errno
  my $ans = syswrite (LEFT, "void");
  $err = $!;
  is ($ans, undef, "syswrite to shutdown left should fail");
  alarm 60;
}
{
  # This may need skipping on some OSes - restoring value saved above
  # should help
  $! = $err;
  ok (($!{EPIPE} or $!{ESHUTDOWN}), '$! should be EPIPE or ESHUTDOWN')
    or printf "\$\!=%d(%s)\n", $err, $err;
}

my @@gripping = (chr 255, chr 127);
foreach (@@gripping) {
  is (syswrite (RIGHT, $_), length $_, "syswrite to right");
}

ok (!eof LEFT, "left is not at EOF");

$expect = join '', @@gripping;
undef $buffer;
is (read (LEFT, $buffer, length $expect), length $expect, "read on left");
is ($buffer, $expect, "content what we expected?");

ok (close LEFT, "close left");
ok (close RIGHT, "close right");


# And now datagrams
# I suspect we also need a self destruct time-bomb for these, as I don't see any
# guarantee that the stack won't drop a UDP packet, even if it is for localhost.

SKIP: {
  skip "No usable SOCK_DGRAM for socketpair", 24 if ($^O =~ /^(MSWin32|os2)\z/);
  local $TODO = "socketpair not supported on $^O" if $^O eq 'nto';

ok (socketpair (LEFT, RIGHT, AF_UNIX, SOCK_DGRAM, PF_UNSPEC),
    "socketpair (LEFT, RIGHT, AF_UNIX, SOCK_DGRAM, PF_UNSPEC)")
  or print "# \$\! = $!\n";

if ($has_perlio) {
    binmode(LEFT,  ":bytes");
    binmode(RIGHT, ":bytes");
}

foreach (@@left) {
  # is (syswrite (LEFT, $_), length $_, "write " . _qq ($_) . " to left");
  is (syswrite (LEFT, $_), length $_, "syswrite to left");
}
foreach (@@right) {
  # is (syswrite (RIGHT, $_), length $_, "write " . _qq ($_) . " to right");
  is (syswrite (RIGHT, $_), length $_, "syswrite to right");
}

# stream socket, so our writes will become joined:
my ($total);
$total = join '', @@right;
foreach $expect (@@right) {
  undef $buffer;
  is (sysread (LEFT, $buffer, length $total), length $expect, "read on left");
  is ($buffer, $expect, "content what we expected?");
}
$total = join '', @@left;
foreach $expect (@@left) {
  undef $buffer;
  is (sysread (RIGHT, $buffer, length $total), length $expect, "read on right");
  is ($buffer, $expect, "content what we expected?");
}

ok (shutdown(LEFT, 1), "shutdown left for writing");

# eof uses buffering. eof is indicated by a sysread of zero.
# but for a datagram socket there's no way it can know nothing will ever be
# sent
SKIP: {
  skip "$^O does length 0 udp reads", 2 if ($^O eq 'os390');

  my $alarmed = 0;
  local $SIG{ALRM} = sub { $alarmed = 1; };
  print "# Approximate forever as 3 seconds. Wait 'forever'...\n";
  alarm 3;
  undef $buffer;
  is (sysread (RIGHT, $buffer, 1), undef,
      "read on right should be interrupted");
  is ($alarmed, 1, "alarm should have fired");
}

alarm 30;

#ok (eof RIGHT, "right is at EOF");

foreach (@@gripping) {
  is (syswrite (RIGHT, $_), length $_, "syswrite to right");
}

$total = join '', @@gripping;
foreach $expect (@@gripping) {
  undef $buffer;
  is (sysread (LEFT, $buffer, length $total), length $expect, "read on left");
  is ($buffer, $expect, "content what we expected?");
}

ok (close LEFT, "close left");
ok (close RIGHT, "close right");

} # end of DGRAM SKIP

kill "INT", $child or warn "Failed to kill child process $child: $!";
exit 0;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@perl 5.8.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.0 from CPAN
@
text
@d11 4
a14 1
    $can_fork = $Config{'d_fork'} || $Config{'d_pseudofork'};
d20 1
a20 6
    }
}

{
    # This was in the BEGIN block, but since Test::More 0.47 added support to
    # detect forking, we don't need to fork before Test::More initialises.
d25 3
@


1.1.1.3
log
@Perl 5.12.2 from CPAN
@
text
@d8 2
@


