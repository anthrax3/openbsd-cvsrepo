head	1.13;
access;
symbols
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.13
date	2013.03.25.20.40.55;	author sthen;	state dead;
branches;
next	1.12;

1.12
date	2010.09.24.15.06.57;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.24.34;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.06;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.04;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.09.22;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.33;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.23;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.17;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.05.37;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.55.56;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.16;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.16;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.39.10;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.23;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.59;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.53;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.46.27;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.48.20;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.24;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.11.15;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.48.49;	author millert;	state Exp;
branches;
next	;


desc
@@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include <stddef.h>

#ifndef VMS
# ifdef I_SYS_TYPES
#  include <sys/types.h>
# endif
# if !defined(ultrix) /* Avoid double definition. */
#   include <sys/socket.h>
# endif
# if defined(USE_SOCKS) && defined(I_SOCKS)
#   include <socks.h>
# endif
# ifdef MPE
#  define PF_INET AF_INET
#  define PF_UNIX AF_UNIX
#  define SOCK_RAW 3
# endif
# ifdef I_SYS_UN
#  include <sys/un.h>
# endif
/* XXX Configure test for <netinet/in_systm.h needed XXX */
# if defined(NeXT) || defined(__NeXT__)
#  include <netinet/in_systm.h>
# endif
# if defined(__sgi) && !defined(AF_LINK) && defined(PF_LINK) && PF_LINK == AF_LNK
#  undef PF_LINK
# endif
# if defined(I_NETINET_IN) || defined(__ultrix__)
#  include <netinet/in.h>
# endif
# ifdef I_NETDB
#  if !defined(ultrix)  /* Avoid double definition. */
#   include <netdb.h>
#  endif
# endif
# ifdef I_ARPA_INET
#  include <arpa/inet.h>
# endif
# ifdef I_NETINET_TCP
#  include <netinet/tcp.h>
# endif
#else
# include "sockadapt.h"
#endif

#ifdef NETWARE
NETDB_DEFINE_CONTEXT
NETINET_DEFINE_CONTEXT
#endif

#ifdef I_SYSUIO
# include <sys/uio.h>
#endif

#ifndef AF_NBS
# undef PF_NBS
#endif

#ifndef AF_X25
# undef PF_X25
#endif

#ifndef INADDR_NONE
# define INADDR_NONE	0xffffffff
#endif /* INADDR_NONE */
#ifndef INADDR_BROADCAST
# define INADDR_BROADCAST	0xffffffff
#endif /* INADDR_BROADCAST */
#ifndef INADDR_LOOPBACK
# define INADDR_LOOPBACK         0x7F000001
#endif /* INADDR_LOOPBACK */

#ifndef HAS_INET_ATON

/*
 * Check whether "cp" is a valid ascii representation
 * of an Internet address and convert to a binary address.
 * Returns 1 if the address is valid, 0 if not.
 * This replaces inet_addr, the return value from which
 * cannot distinguish between failure and a local broadcast address.
 */
static int
my_inet_aton(register const char *cp, struct in_addr *addr)
{
	dTHX;
	register U32 val;
	register int base;
	register char c;
	int nparts;
	const char *s;
	unsigned int parts[4];
	register unsigned int *pp = parts;

       if (!cp || !*cp)
		return 0;
	for (;;) {
		/*
		 * Collect number up to ``.''.
		 * Values are specified as for C:
		 * 0x=hex, 0=octal, other=decimal.
		 */
		val = 0; base = 10;
		if (*cp == '0') {
			if (*++cp == 'x' || *cp == 'X')
				base = 16, cp++;
			else
				base = 8;
		}
		while ((c = *cp) != '\0') {
			if (isDIGIT(c)) {
				val = (val * base) + (c - '0');
				cp++;
				continue;
			}
			if (base == 16 && (s=strchr(PL_hexdigit,c))) {
				val = (val << 4) +
					((s - PL_hexdigit) & 15);
				cp++;
				continue;
			}
			break;
		}
		if (*cp == '.') {
			/*
			 * Internet format:
			 *	a.b.c.d
			 *	a.b.c	(with c treated as 16-bits)
			 *	a.b	(with b treated as 24 bits)
			 */
			if (pp >= parts + 3 || val > 0xff)
				return 0;
			*pp++ = val, cp++;
		} else
			break;
	}
	/*
	 * Check for trailing characters.
	 */
	if (*cp && !isSPACE(*cp))
		return 0;
	/*
	 * Concoct the address according to
	 * the number of parts specified.
	 */
	nparts = pp - parts + 1;	/* force to an int for switch() */
	switch (nparts) {

	case 1:				/* a -- 32 bits */
		break;

	case 2:				/* a.b -- 8.24 bits */
		if (val > 0xffffff)
			return 0;
		val |= parts[0] << 24;
		break;

	case 3:				/* a.b.c -- 8.8.16 bits */
		if (val > 0xffff)
			return 0;
		val |= (parts[0] << 24) | (parts[1] << 16);
		break;

	case 4:				/* a.b.c.d -- 8.8.8.8 bits */
		if (val > 0xff)
			return 0;
		val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
		break;
	}
	addr->s_addr = htonl(val);
	return 1;
}

#undef inet_aton
#define inet_aton my_inet_aton

#endif /* ! HAS_INET_ATON */


static int
not_here(const char *s)
{
    croak("Socket::%s not implemented on this architecture", s);
    return -1;
}

#define PERL_IN_ADDR_S_ADDR_SIZE 4

/*
* Bad assumptions possible here.
*
* Bad Assumption 1: struct in_addr has no other fields
* than the s_addr (which is the field we care about
* in here, really). However, we can be fed either 4-byte
* addresses (from pack("N", ...), or va.b.c.d, or ...),
* or full struct in_addrs (from e.g. pack_sockaddr_in()),
* which may or may not be 4 bytes in size.
*
* Bad Assumption 2: the s_addr field is a simple type
* (such as an int, u_int32_t).  It can be a bit field,
* in which case using & (address-of) on it or taking sizeof()
* wouldn't go over too well.  (Those are not attempted
* now but in case someone thinks to change the below code
* to use addr.s_addr instead of addr, you have been warned.)
*
* Bad Assumption 3: the s_addr is the first field in
* an in_addr, or that its bytes are the first bytes in
* an in_addr.
*
* These bad assumptions are wrong in UNICOS which has
* struct in_addr { struct { u_long  st_addr:32; } s_da };
* #define s_addr s_da.st_addr
* and u_long is 64 bits.
*
* --jhi */

#include "const-c.inc"

MODULE = Socket		PACKAGE = Socket

INCLUDE: const-xs.inc

void
inet_aton(host)
	char *	host
	CODE:
	{
	struct in_addr ip_address;
	struct hostent * phe;
	int ok = (*host != '\0') && inet_aton(host, &ip_address);

	if (!ok && (phe = gethostbyname(host)) &&
			phe->h_addrtype == AF_INET && phe->h_length == 4) {
		Copy( phe->h_addr, &ip_address, phe->h_length, char );
		ok = 1;
	}

	ST(0) = sv_newmortal();
	if (ok)
		sv_setpvn( ST(0), (char *)&ip_address, sizeof ip_address );
	}

void
inet_ntoa(ip_address_sv)
	SV *	ip_address_sv
	CODE:
	{
	STRLEN addrlen;
	struct in_addr addr;
	char * addr_str;
	char * ip_address;
	if (DO_UTF8(ip_address_sv) && !sv_utf8_downgrade(ip_address_sv, 1))
	     croak("Wide character in Socket::inet_ntoa");
	ip_address = SvPVbyte(ip_address_sv, addrlen);
	if (addrlen == sizeof(addr) || addrlen == 4)
	        addr.s_addr =
		    (ip_address[0] & 0xFF) << 24 |
		    (ip_address[1] & 0xFF) << 16 |
		    (ip_address[2] & 0xFF) <<  8 |
		    (ip_address[3] & 0xFF);
	else
	        croak("Bad arg length for %s, length is %d, should be %d",
		      "Socket::inet_ntoa",
		      addrlen, sizeof(addr));
	/* We could use inet_ntoa() but that is broken
	 * in HP-UX + GCC + 64bitint (returns "0.0.0.0"),
	 * so let's use this sprintf() workaround everywhere.
	 * This is also more threadsafe than using inet_ntoa(). */
	Newx(addr_str, 4 * 3 + 3 + 1, char); /* IPv6? */
	sprintf(addr_str, "%d.%d.%d.%d",
		((addr.s_addr >> 24) & 0xFF),
		((addr.s_addr >> 16) & 0xFF),
		((addr.s_addr >>  8) & 0xFF),
		( addr.s_addr        & 0xFF));
	ST(0) = newSVpvn_flags(addr_str, strlen(addr_str), SVs_TEMP);
	Safefree(addr_str);
	}

void
sockaddr_family(sockaddr)
	SV *	sockaddr
	PREINIT:
	STRLEN sockaddr_len;
	char *sockaddr_pv = SvPVbyte(sockaddr, sockaddr_len);
	CODE:
	if (sockaddr_len < offsetof(struct sockaddr, sa_data)) {
	    croak("Bad arg length for %s, length is %d, should be at least %d",
	          "Socket::sockaddr_family", sockaddr_len,
		  offsetof(struct sockaddr, sa_data));
	}
	ST(0) = sv_2mortal(newSViv(((struct sockaddr*)sockaddr_pv)->sa_family));

void
pack_sockaddr_un(pathname)
	SV *	pathname
	CODE:
	{
#ifdef I_SYS_UN
	struct sockaddr_un sun_ad; /* fear using sun */
	STRLEN len;
	char * pathname_pv;
	int addr_len;

	Zero( &sun_ad, sizeof sun_ad, char );
	sun_ad.sun_family = AF_UNIX;
	pathname_pv = SvPV(pathname,len);
	if (len > sizeof(sun_ad.sun_path))
	    len = sizeof(sun_ad.sun_path);
#  ifdef OS2	/* Name should start with \socket\ and contain backslashes! */
	{
	    int off;
	    char *s, *e;

	    if (pathname_pv[0] != '/' && pathname_pv[0] != '\\')
		croak("Relative UNIX domain socket name '%s' unsupported",
			pathname_pv);
	    else if (len < 8
		     || pathname_pv[7] != '/' && pathname_pv[7] != '\\'
		     || !strnicmp(pathname_pv + 1, "socket", 6))
		off = 7;
	    else
		off = 0;		/* Preserve names starting with \socket\ */
	    Copy( "\\socket", sun_ad.sun_path, off, char);
	    Copy( pathname_pv, sun_ad.sun_path + off, len, char );

	    s = sun_ad.sun_path + off - 1;
	    e = s + len + 1;
	    while (++s < e)
		if (*s = '/')
		    *s = '\\';
	}
#  else	/* !( defined OS2 ) */
	Copy( pathname_pv, sun_ad.sun_path, len, char );
#  endif
	if (0) not_here("dummy");
	if (len > 1 && sun_ad.sun_path[0] == '\0') {
		/* Linux-style abstract-namespace socket.
		 * The name is not a file name, but an array of arbitrary
		 * character, starting with \0 and possibly including \0s,
		 * therefore the length of the structure must denote the
		 * end of that character array */
		addr_len = (char *)&(sun_ad.sun_path) - (char *)&sun_ad + len;
	} else {
		addr_len = sizeof sun_ad;
	}
	ST(0) = newSVpvn_flags((char *)&sun_ad, addr_len, SVs_TEMP);
#else
	ST(0) = (SV *) not_here("pack_sockaddr_un");
#endif
	
	}

void
unpack_sockaddr_un(sun_sv)
	SV *	sun_sv
	CODE:
	{
#ifdef I_SYS_UN
	struct sockaddr_un addr;
	STRLEN sockaddrlen;
	char * sun_ad = SvPVbyte(sun_sv,sockaddrlen);
	int addr_len;
#   ifndef __linux__
	/* On Linux sockaddrlen on sockets returned by accept, recvfrom,
	   getpeername and getsockname is not equal to sizeof(addr). */
	if (sockaddrlen != sizeof(addr)) {
	    croak("Bad arg length for %s, length is %d, should be %d",
			"Socket::unpack_sockaddr_un",
			sockaddrlen, sizeof(addr));
	}
#   endif

	Copy( sun_ad, &addr, sizeof addr, char );

	if ( addr.sun_family != AF_UNIX ) {
	    croak("Bad address family for %s, got %d, should be %d",
			"Socket::unpack_sockaddr_un",
			addr.sun_family,
			AF_UNIX);
	}

	if (addr.sun_path[0] == '\0') {
		/* Linux-style abstract socket address begins with a nul
		 * and can contain nuls. */
		addr_len = (char *)&addr - (char *)&(addr.sun_path) + sockaddrlen;
	} else {
		for (addr_len = 0; addr.sun_path[addr_len]
		     && addr_len < sizeof addr.sun_path; addr_len++);
	}

	ST(0) = newSVpvn_flags(addr.sun_path, addr_len, SVs_TEMP);
#else
	ST(0) = (SV *) not_here("unpack_sockaddr_un");
#endif
	}

void
pack_sockaddr_in(port, ip_address_sv)
	unsigned short	port
	SV *	ip_address_sv
	CODE:
	{
	struct sockaddr_in sin;
	struct in_addr addr;
	STRLEN addrlen;
	char * ip_address;
	if (DO_UTF8(ip_address_sv) && !sv_utf8_downgrade(ip_address_sv, 1))
	     croak("Wide character in Socket::pack_sockaddr_in");
	ip_address = SvPVbyte(ip_address_sv, addrlen);
	if (addrlen == sizeof(addr) || addrlen == 4)
	        addr.s_addr =
		    (ip_address[0] & 0xFF) << 24 |
		    (ip_address[1] & 0xFF) << 16 |
		    (ip_address[2] & 0xFF) <<  8 |
		    (ip_address[3] & 0xFF);
	else
	        croak("Bad arg length for %s, length is %d, should be %d",
		      "Socket::pack_sockaddr_in",
		      addrlen, sizeof(addr));
	Zero( &sin, sizeof sin, char );
	sin.sin_family = AF_INET;
	sin.sin_port = htons(port);
	sin.sin_addr.s_addr = htonl(addr.s_addr);
	ST(0) = newSVpvn_flags((char *)&sin, sizeof (sin), SVs_TEMP);
	}

void
unpack_sockaddr_in(sin_sv)
	SV *	sin_sv
	PPCODE:
	{
	STRLEN sockaddrlen;
	struct sockaddr_in addr;
	unsigned short	port;
	struct in_addr  ip_address;
	char *	sin = SvPVbyte(sin_sv,sockaddrlen);
	if (sockaddrlen != sizeof(addr)) {
	    croak("Bad arg length for %s, length is %d, should be %d",
			"Socket::unpack_sockaddr_in",
			sockaddrlen, sizeof(addr));
	}
	Copy( sin, &addr,sizeof addr, char );
	if ( addr.sin_family != AF_INET ) {
	    croak("Bad address family for %s, got %d, should be %d",
			"Socket::unpack_sockaddr_in",
			addr.sin_family,
			AF_INET);
	}
	port = ntohs(addr.sin_port);
	ip_address = addr.sin_addr;

	EXTEND(SP, 2);
	PUSHs(sv_2mortal(newSViv((IV) port)));
	PUSHs(newSVpvn_flags((char *)&ip_address, sizeof(ip_address), SVs_TEMP));
	}

void
inet_ntop(af, ip_address_sv)
        int     af
        SV *    ip_address_sv
        CODE:
#ifdef HAS_INETNTOP
	STRLEN addrlen, struct_size;
	struct in6_addr addr;
	char str[INET6_ADDRSTRLEN];
	char *ip_address = SvPV(ip_address_sv, addrlen);

        if(af == AF_INET) {
            struct_size = sizeof(struct in_addr);
        } else if(af == AF_INET6) {
            struct_size = sizeof(struct in6_addr);
        } else {
           croak("Bad address family for Socket::inet_ntop, got %d, should be either AF_INET or AF_INET6",
               af);
        }

	Copy( ip_address, &addr, sizeof addr, char );
	inet_ntop(af, &addr, str, INET6_ADDRSTRLEN);

	ST(0) = newSVpvn_flags(str, strlen(str), SVs_TEMP);
#else
        ST(0) = (SV *)not_here("inet_ntop");
#endif

void
inet_pton(af, host)
        int           af
        const char *  host
        CODE:
#ifdef HAS_INETPTON
        int ok;
        struct in6_addr ip_address;
        if(af != AF_INET && af != AF_INET6) {
           croak("Bad address family for %s, got %d, should be either AF_INET or AF_INET6",
                        "Socket::inet_pton",
                        af);
        }
        ok = (*host != '\0') && inet_pton(af, host, &ip_address);

        ST(0) = sv_newmortal();
        if (ok) {
                sv_setpvn( ST(0), (char *)&ip_address,
                           af == AF_INET6 ? sizeof(ip_address) : sizeof(struct in_addr) );
        }
#else
        ST(0) = (SV *)not_here("inet_pton");
#endif
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@@


1.11
log
@Merge in perl 5.10.1
@
text
@d279 1
a279 1
	ST(0) = sv_2mortal(newSVpvn(addr_str, strlen(addr_str)));
d306 1
d340 11
a350 1
	ST(0) = sv_2mortal(newSVpvn((char *)&sun_ad, sizeof sun_ad));
d366 1
a366 1
	char * e;
d385 11
a395 7
	e = (char*)addr.sun_path;
	/* On Linux, the name of abstract unix domain sockets begins
	 * with a '\0', so allow this. */
	while ((*e || (e == addr.sun_path && e[1] && sockaddrlen > 1))
		&& e < (char*)addr.sun_path + sizeof addr.sun_path)
	    ++e;
	ST(0) = sv_2mortal(newSVpvn(addr.sun_path, e - (char*)addr.sun_path));
d428 1
a428 1
	ST(0) = sv_2mortal(newSVpvn((char *)&sin, sizeof sin));
d458 1
a458 1
	PUSHs(sv_2mortal(newSVpvn((char *)&ip_address, sizeof ip_address)));
d460 52
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d185 1
a185 1
not_here(char *s)
@


1.9
log
@merge in perl 5.8.8
@
text
@d234 1
a234 4
	int ok =
		(host != NULL) &&
		(*host != '\0') &&
		inet_aton(host, &ip_address);
d236 2
a237 1
	if (!ok && (phe = gethostbyname(host))) {
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d275 1
a275 1
	New(1138, addr_str, 4 * 3 + 3 + 1, char); /* IPv6? */
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d301 1
a301 1
	char *	pathname
d307 1
d311 1
a311 1
	len = strlen(pathname);
d319 3
a321 2
	    if (pathname[0] != '/' && pathname[0] != '\\')
		croak("Relative UNIX domain socket name '%s' unsupported", pathname);
d323 2
a324 2
		     || pathname[7] != '/' && pathname[7] != '\\'
		     || !strnicmp(pathname + 1, "socket", 6))
d329 1
a329 1
	    Copy( pathname, sun_ad.sun_path + off, len, char );
d338 1
a338 1
	Copy( pathname, sun_ad.sun_path, len, char );
d377 4
a380 1
	while (*e && e < (char*)addr.sun_path + sizeof addr.sun_path)
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d12 3
a14 1
# include <sys/socket.h>
d30 4
a33 1
# ifdef I_NETINET_IN
d37 3
a39 1
#  include <netdb.h>
d374 2
a375 2
	e = addr.sun_path;
	while (*e && e < addr.sun_path + sizeof addr.sun_path)
d377 1
a377 1
	ST(0) = sv_2mortal(newSVpvn(addr.sun_path, e - addr.sun_path));
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d6 2
d15 1
a15 1
# endif 
d44 5
d73 1
a73 1
/* 
d92 1
a92 1
	if (!cp)
d114 1
a114 1
				val = (val << 4) + 
d184 29
a212 725
static double
constant(char *name, int arg)
{
    errno = 0;
    switch (*name) {
    case 'A':
	if (strEQ(name, "AF_802"))
#ifdef AF_802
	    return AF_802;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_APPLETALK"))
#ifdef AF_APPLETALK
	    return AF_APPLETALK;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_CCITT"))
#ifdef AF_CCITT
	    return AF_CCITT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_CHAOS"))
#ifdef AF_CHAOS
	    return AF_CHAOS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_DATAKIT"))
#ifdef AF_DATAKIT
	    return AF_DATAKIT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_DECnet"))
#ifdef AF_DECnet
	    return AF_DECnet;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_DLI"))
#ifdef AF_DLI
	    return AF_DLI;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_ECMA"))
#ifdef AF_ECMA
	    return AF_ECMA;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_GOSIP"))
#ifdef AF_GOSIP
	    return AF_GOSIP;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_HYLINK"))
#ifdef AF_HYLINK
	    return AF_HYLINK;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_IMPLINK"))
#ifdef AF_IMPLINK
	    return AF_IMPLINK;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_INET"))
#ifdef AF_INET
	    return AF_INET;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_LAT"))
#ifdef AF_LAT
	    return AF_LAT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_MAX"))
#ifdef AF_MAX
	    return AF_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_NBS"))
#ifdef AF_NBS
	    return AF_NBS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_NIT"))
#ifdef AF_NIT
	    return AF_NIT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_NS"))
#ifdef AF_NS
	    return AF_NS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_OSI"))
#ifdef AF_OSI
	    return AF_OSI;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_OSINET"))
#ifdef AF_OSINET
	    return AF_OSINET;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_PUP"))
#ifdef AF_PUP
	    return AF_PUP;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_SNA"))
#ifdef AF_SNA
	    return AF_SNA;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_UNIX"))
#ifdef AF_UNIX
	    return AF_UNIX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_UNSPEC"))
#ifdef AF_UNSPEC
	    return AF_UNSPEC;
#else
	    goto not_there;
#endif
	if (strEQ(name, "AF_X25"))
#ifdef AF_X25
	    return AF_X25;
#else
	    goto not_there;
#endif
	break;
    case 'B':
	break;
    case 'C':
	break;
    case 'D':
	break;
    case 'E':
	break;
    case 'F':
	break;
    case 'G':
	break;
    case 'H':
	break;
    case 'I':
	if (strEQ(name, "IOV_MAX"))
#ifdef IOV_MAX
	    return IOV_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "IPPROTO_TCP"))
#ifdef IPPROTO_TCP
	    return IPPROTO_TCP;
#else
	    goto not_there;
#endif
	break;
    case 'J':
	break;
    case 'K':
	break;
    case 'L':
	break;
    case 'M':
	if (strEQ(name, "MSG_BCAST"))
#ifdef MSG_BCAST
	    return MSG_BCAST;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_CTLFLAGS"))
#ifdef MSG_CTLFLAGS
	    return MSG_CTLFLAGS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_CTLIGNORE"))
#ifdef MSG_CTLIGNORE
	    return MSG_CTLIGNORE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_CTRUNC"))
#if defined(MSG_TRUNC) || defined(HAS_MSG_CTRUNC) /* might be an enum */
	    return MSG_CTRUNC;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_DONTROUTE"))
#if defined(MSG_DONTROUTE) || defined(HAS_MSG_DONTROUTE) /* might be an enum */
	    return MSG_DONTROUTE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_DONTWAIT"))
#ifdef MSG_DONTWAIT
	    return MSG_DONTWAIT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_EOF"))
#ifdef MSG_EOF
	    return MSG_EOF;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_EOR"))
#ifdef MSG_EOR
	    return MSG_EOR;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_ERRQUEUE"))
#ifdef MSG_ERRQUEUE
	    return MSG_ERRQUEUE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_FIN"))
#ifdef MSG_FIN
	    return MSG_FIN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_MAXIOVLEN"))
#ifdef MSG_MAXIOVLEN
	    return MSG_MAXIOVLEN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_MCAST"))
#ifdef MSG_MCAST
	    return MSG_MCAST;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_NOSIGNAL"))
#ifdef MSG_NOSIGNAL
	    return MSG_NOSIGNAL;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_OOB"))
#if defined(MSG_OOB) || defined(HAS_MSG_OOB) /* might be an enum */
	    return MSG_OOB;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_PEEK"))
#if defined(MSG_PEEK) || defined(HAS_MSG_PEEK) /* might be an enum */
	    return MSG_PEEK;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_PROXY"))
#if defined(MSG_PROXY) || defined(HAS_MSG_PROXY) /* might be an enum */
	    return MSG_PROXY;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_RST"))
#ifdef MSG_RST
	    return MSG_RST;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_SYN"))
#ifdef MSG_SYN
	    return MSG_SYN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_TRUNC"))
#ifdef MSG_TRUNC
	    return MSG_TRUNC;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_WAITALL"))
#ifdef MSG_WAITALL
	    return MSG_WAITALL;
#else
	    goto not_there;
#endif
	break;
    case 'N':
	break;
    case 'O':
	break;
    case 'P':
	if (strEQ(name, "PF_802"))
#ifdef PF_802
	    return PF_802;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_APPLETALK"))
#ifdef PF_APPLETALK
	    return PF_APPLETALK;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_CCITT"))
#ifdef PF_CCITT
	    return PF_CCITT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_CHAOS"))
#ifdef PF_CHAOS
	    return PF_CHAOS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_DATAKIT"))
#ifdef PF_DATAKIT
	    return PF_DATAKIT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_DECnet"))
#ifdef PF_DECnet
	    return PF_DECnet;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_DLI"))
#ifdef PF_DLI
	    return PF_DLI;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_ECMA"))
#ifdef PF_ECMA
	    return PF_ECMA;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_GOSIP"))
#ifdef PF_GOSIP
	    return PF_GOSIP;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_HYLINK"))
#ifdef PF_HYLINK
	    return PF_HYLINK;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_IMPLINK"))
#ifdef PF_IMPLINK
	    return PF_IMPLINK;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_INET"))
#ifdef PF_INET
	    return PF_INET;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_LAT"))
#ifdef PF_LAT
	    return PF_LAT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_MAX"))
#ifdef PF_MAX
	    return PF_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_NBS"))
#ifdef PF_NBS
	    return PF_NBS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_NIT"))
#ifdef PF_NIT
	    return PF_NIT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_NS"))
#ifdef PF_NS
	    return PF_NS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_OSI"))
#ifdef PF_OSI
	    return PF_OSI;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_OSINET"))
#ifdef PF_OSINET
	    return PF_OSINET;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_PUP"))
#ifdef PF_PUP
	    return PF_PUP;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_SNA"))
#ifdef PF_SNA
	    return PF_SNA;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_UNIX"))
#ifdef PF_UNIX
	    return PF_UNIX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_UNSPEC"))
#ifdef PF_UNSPEC
	    return PF_UNSPEC;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PF_X25"))
#ifdef PF_X25
	    return PF_X25;
#else
	    goto not_there;
#endif
	break;
    case 'Q':
	break;
    case 'R':
	break;
    case 'S':
	if (strEQ(name, "SCM_CONNECT"))
#ifdef SCM_CONNECT
	    return SCM_CONNECT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SCM_CREDENTIALS"))
#ifdef SCM_CREDENTIALS
	    return SCM_CREDENTIALS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SCM_CREDS"))
#ifdef SCM_CREDS
	    return SCM_CREDS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SCM_RIGHTS"))
#if defined(SCM_RIGHTS) || defined(HAS_SCM_RIGHTS) /* might be an enum */
	    return SCM_RIGHTS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SCM_TIMESTAMP"))
#ifdef SCM_TIMESTAMP
	    return SCM_TIMESTAMP;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SHUT_RD"))
#ifdef SHUT_RD
	    return SHUT_RD;
#else
	    return 0;
#endif
	if (strEQ(name, "SHUT_RDWR"))
#ifdef SHUT_RDWR
	    return SHUT_RDWR;
#else
	    return 2;
#endif
	if (strEQ(name, "SHUT_WR"))
#ifdef SHUT_WR
	    return SHUT_WR;
#else
	    return 1;
#endif
	if (strEQ(name, "SOCK_DGRAM"))
#ifdef SOCK_DGRAM
	    return SOCK_DGRAM;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SOCK_RAW"))
#ifdef SOCK_RAW
	    return SOCK_RAW;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SOCK_RDM"))
#ifdef SOCK_RDM
	    return SOCK_RDM;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SOCK_SEQPACKET"))
#ifdef SOCK_SEQPACKET
	    return SOCK_SEQPACKET;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SOCK_STREAM"))
#ifdef SOCK_STREAM
	    return SOCK_STREAM;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SOL_SOCKET"))
#ifdef SOL_SOCKET
	    return SOL_SOCKET;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SOMAXCONN"))
#ifdef SOMAXCONN
	    return SOMAXCONN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_ACCEPTCONN"))
#ifdef SO_ACCEPTCONN
	    return SO_ACCEPTCONN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_BROADCAST"))
#ifdef SO_BROADCAST
	    return SO_BROADCAST;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_DEBUG"))
#ifdef SO_DEBUG
	    return SO_DEBUG;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_DONTLINGER"))
#ifdef SO_DONTLINGER
	    return SO_DONTLINGER;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_DONTROUTE"))
#ifdef SO_DONTROUTE
	    return SO_DONTROUTE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_ERROR"))
#ifdef SO_ERROR
	    return SO_ERROR;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_KEEPALIVE"))
#ifdef SO_KEEPALIVE
	    return SO_KEEPALIVE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_LINGER"))
#ifdef SO_LINGER
	    return SO_LINGER;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_OOBINLINE"))
#ifdef SO_OOBINLINE
	    return SO_OOBINLINE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_RCVBUF"))
#ifdef SO_RCVBUF
	    return SO_RCVBUF;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_RCVLOWAT"))
#ifdef SO_RCVLOWAT
	    return SO_RCVLOWAT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_RCVTIMEO"))
#ifdef SO_RCVTIMEO
	    return SO_RCVTIMEO;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_REUSEADDR"))
#ifdef SO_REUSEADDR
	    return SO_REUSEADDR;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_REUSEPORT"))
#ifdef SO_REUSEPORT
	    return SO_REUSEPORT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_SNDBUF"))
#ifdef SO_SNDBUF
	    return SO_SNDBUF;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_SNDLOWAT"))
#ifdef SO_SNDLOWAT
	    return SO_SNDLOWAT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_SNDTIMEO"))
#ifdef SO_SNDTIMEO
	    return SO_SNDTIMEO;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_TYPE"))
#ifdef SO_TYPE
	    return SO_TYPE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SO_USELOOPBACK"))
#ifdef SO_USELOOPBACK
	    return SO_USELOOPBACK;
#else
	    goto not_there;
#endif
	break;
    case 'T':
	if (strEQ(name, "TCP_KEEPALIVE"))
#ifdef TCP_KEEPALIVE
	    return TCP_KEEPALIVE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCP_MAXRT"))
#ifdef TCP_MAXRT
	    return TCP_MAXRT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCP_MAXSEG"))
#ifdef TCP_MAXSEG
	    return TCP_MAXSEG;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCP_NODELAY"))
#ifdef TCP_NODELAY
	    return TCP_NODELAY;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCP_STDURG"))
#ifdef TCP_STDURG
	    return TCP_STDURG;
#else
	    goto not_there;
#endif
	break;
    case 'U':
	if (strEQ(name, "UIO_MAXIOV"))
#ifdef UIO_MAXIOV
	    return UIO_MAXIOV;
#else
	    goto not_there;
#endif
	break;
    case 'V':
	break;
    case 'W':
	break;
    case 'X':
	break;
    case 'Y':
	break;
    case 'Z':
	break;
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}
d214 1
d218 1
a218 5
double
constant(name,arg)
	char *		name
	int		arg

d227 4
a230 1
	int ok = inet_aton(host, &ip_address);
d238 1
a238 1
	if (ok) {
a240 1
	}
d250 26
a275 5
	char * ip_address = SvPV(ip_address_sv,addrlen);
	if (addrlen != sizeof(addr)) {
	    croak("Bad arg length for %s, length is %d, should be %d",
			"Socket::inet_ntoa",
			addrlen, sizeof(addr));
d278 11
a288 4
	Copy( ip_address, &addr, sizeof addr, char );
	addr_str = inet_ntoa(addr);

	ST(0) = sv_2mortal(newSVpvn(addr_str, strlen(addr_str)));
d290 1
d313 1
a313 1
	    else if (len < 8 
d328 1
a328 1
#  else	/* !( defined OS2 ) */ 
d331 1
d347 1
a347 1
	char * sun_ad = SvPV(sun_sv,sockaddrlen);
d377 1
a377 1
pack_sockaddr_in(port,ip_address)
d379 1
a379 1
	char *	ip_address
d383 16
a398 1

d402 1
a402 2
	Copy( ip_address, &sin.sin_addr, sizeof sin.sin_addr, char );

d414 2
a415 2
	struct in_addr	ip_address;
	char *	sin = SvPV(sin_sv,sockaddrlen);
d427 1
a427 1
	} 
d433 1
a433 37
	PUSHs(sv_2mortal(newSVpvn((char *)&ip_address,sizeof ip_address)));
	}

void
INADDR_ANY()
	CODE:
	{
	struct in_addr	ip_address;
	ip_address.s_addr = htonl(INADDR_ANY);
	ST(0) = sv_2mortal(newSVpvn((char *)&ip_address,sizeof ip_address ));
	}

void
INADDR_LOOPBACK()
	CODE:
	{
	struct in_addr	ip_address;
	ip_address.s_addr = htonl(INADDR_LOOPBACK);
	ST(0) = sv_2mortal(newSVpvn((char *)&ip_address,sizeof ip_address));
	}

void
INADDR_NONE()
	CODE:
	{
	struct in_addr	ip_address;
	ip_address.s_addr = htonl(INADDR_NONE);
	ST(0) = sv_2mortal(newSVpvn((char *)&ip_address,sizeof ip_address));
	}

void
INADDR_BROADCAST()
	CODE:
	{
	struct in_addr	ip_address;
	ip_address.s_addr = htonl(INADDR_BROADCAST);
	ST(0) = sv_2mortal(newSVpvn((char *)&ip_address,sizeof ip_address));
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d1009 3
a1011 1

d1017 1
@


1.3
log
@perl5.005_03 (stock)
@
text
@d1 1
d10 16
a25 9
#include <sys/socket.h>
#ifdef MPE
# define PF_INET AF_INET
# define PF_UNIX AF_UNIX
# define SOCK_RAW 3
#endif
#ifdef I_SYS_UN
#include <sys/un.h>
#endif
d29 11
a39 3
#include <netdb.h>
#ifdef I_ARPA_INET
# include <arpa/inet.h>
d41 3
a43 2
#else
#include "sockadapt.h"
d47 1
a47 1
#undef PF_NBS
d51 1
a51 1
#undef PF_X25
d55 1
a55 1
#define INADDR_NONE	0xffffffff
d58 1
a58 1
#define INADDR_BROADCAST	0xffffffff
d61 1
a61 1
#define INADDR_LOOPBACK         0x7F000001
d76 1
d343 12
d363 6
d429 6
d669 18
d845 30
d877 6
d950 1
a950 1
	ST(0) = sv_2mortal(newSVpv(addr_str, strlen(addr_str)));
d961 1
d967 23
d991 2
a992 1
	ST(0) = sv_2mortal(newSVpv((char *)&sun_ad, sizeof sun_ad));
d1027 1
a1027 1
	ST(0) = sv_2mortal(newSVpv(addr.sun_path, e - addr.sun_path));
d1046 1
a1046 1
	ST(0) = sv_2mortal(newSVpv((char *)&sin, sizeof sin));
d1076 1
a1076 1
	PUSHs(sv_2mortal(newSVpv((char *)&ip_address,sizeof ip_address)));
d1085 1
a1085 1
	ST(0) = sv_2mortal(newSVpv((char *)&ip_address,sizeof ip_address ));
d1094 1
a1094 1
	ST(0) = sv_2mortal(newSVpv((char *)&ip_address,sizeof ip_address));
d1103 1
a1103 1
	ST(0) = sv_2mortal(newSVpv((char *)&ip_address,sizeof ip_address));
d1112 1
a1112 1
	ST(0) = sv_2mortal(newSVpv((char *)&ip_address,sizeof ip_address));
@


1.2
log
@perl 5.004_04
@
text
@d10 5
d22 3
a24 1
#include <arpa/inet.h>
d57 1
a57 3
my_inet_aton(cp, addr)
register const char *cp;
struct in_addr *addr;
d88 1
a88 1
			if (base == 16 && (s=strchr(hexdigit,c))) {
d90 1
a90 1
					((s - hexdigit) & 15);
d153 1
a153 2
not_here(s)
char *s;
d160 1
a160 3
constant(name, arg)
char *name;
int arg;
d333 18
d352 1
a352 1
#ifdef MSG_DONTROUTE
d357 30
d393 6
d400 1
a400 1
#ifdef MSG_OOB
d406 1
a406 1
#ifdef MSG_PEEK
d411 30
d597 30
d823 1
a823 1
	int ok;
d825 1
a825 1
	if (phe = gethostbyname(host)) {
a827 2
	} else {
		ok = inet_aton(host, &ip_address);
d864 1
d867 4
a870 1
	Copy( pathname, sun_ad.sun_path, sizeof sun_ad.sun_path, char );
d884 1
d886 2
a887 2
	struct sockaddr_un addr;
	char *	sun_ad = SvPV(sun_sv,sockaddrlen);
d902 5
a906 2
	} 
	ST(0) = sv_2mortal(newSVpv(addr.sun_path, strlen(addr.sun_path)));
d953 1
a953 1
	EXTEND(sp, 2);
@


1.1
log
@Initial revision
@
text
@d33 3
d40 106
d707 1
d711 1
d713 1
a713 1
        	ip_address.s_addr = inet_addr(host);
d717 1
a717 1
	if(ip_address.s_addr != INADDR_NONE) {
d763 1
a763 1
	PPCODE:
d860 9
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a9 5
#ifdef MPE
# define PF_INET AF_INET
# define PF_UNIX AF_UNIX
# define SOCK_RAW 3
#endif
d17 1
a17 3
#ifdef I_ARPA_INET
# include <arpa/inet.h>
#endif
a32 3
#ifndef INADDR_BROADCAST
#define INADDR_BROADCAST	0xffffffff
#endif /* INADDR_BROADCAST */
a36 104
#ifndef HAS_INET_ATON

/* 
 * Check whether "cp" is a valid ascii representation
 * of an Internet address and convert to a binary address.
 * Returns 1 if the address is valid, 0 if not.
 * This replaces inet_addr, the return value from which
 * cannot distinguish between failure and a local broadcast address.
 */
static int
my_inet_aton(register const char *cp, struct in_addr *addr)
{
	register U32 val;
	register int base;
	register char c;
	int nparts;
	const char *s;
	unsigned int parts[4];
	register unsigned int *pp = parts;

	if (!cp)
		return 0;
	for (;;) {
		/*
		 * Collect number up to ``.''.
		 * Values are specified as for C:
		 * 0x=hex, 0=octal, other=decimal.
		 */
		val = 0; base = 10;
		if (*cp == '0') {
			if (*++cp == 'x' || *cp == 'X')
				base = 16, cp++;
			else
				base = 8;
		}
		while ((c = *cp) != '\0') {
			if (isDIGIT(c)) {
				val = (val * base) + (c - '0');
				cp++;
				continue;
			}
			if (base == 16 && (s=strchr(PL_hexdigit,c))) {
				val = (val << 4) + 
					((s - PL_hexdigit) & 15);
				cp++;
				continue;
			}
			break;
		}
		if (*cp == '.') {
			/*
			 * Internet format:
			 *	a.b.c.d
			 *	a.b.c	(with c treated as 16-bits)
			 *	a.b	(with b treated as 24 bits)
			 */
			if (pp >= parts + 3 || val > 0xff)
				return 0;
			*pp++ = val, cp++;
		} else
			break;
	}
	/*
	 * Check for trailing characters.
	 */
	if (*cp && !isSPACE(*cp))
		return 0;
	/*
	 * Concoct the address according to
	 * the number of parts specified.
	 */
	nparts = pp - parts + 1;	/* force to an int for switch() */
	switch (nparts) {

	case 1:				/* a -- 32 bits */
		break;

	case 2:				/* a.b -- 8.24 bits */
		if (val > 0xffffff)
			return 0;
		val |= parts[0] << 24;
		break;

	case 3:				/* a.b.c -- 8.8.16 bits */
		if (val > 0xffff)
			return 0;
		val |= (parts[0] << 24) | (parts[1] << 16);
		break;

	case 4:				/* a.b.c.d -- 8.8.8.8 bits */
		if (val > 0xff)
			return 0;
		val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
		break;
	}
	addr->s_addr = htonl(val);
	return 1;
}

#undef inet_aton
#define inet_aton my_inet_aton

#endif /* ! HAS_INET_ATON */

d39 2
a40 1
not_here(char *s)
d47 3
a49 1
constant(char *name, int arg)
a221 18
	if (strEQ(name, "MSG_CTLFLAGS"))
#ifdef MSG_CTLFLAGS
	    return MSG_CTLFLAGS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_CTLIGNORE"))
#ifdef MSG_CTLIGNORE
	    return MSG_CTLIGNORE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_CTRUNC"))
#if defined(MSG_TRUNC) || defined(HAS_MSG_CTRUNC) /* might be an enum */
	    return MSG_CTRUNC;
#else
	    goto not_there;
#endif
d223 1
a223 1
#if defined(MSG_DONTROUTE) || defined(HAS_MSG_DONTROUTE) /* might be an enum */
a227 30
	if (strEQ(name, "MSG_DONTWAIT"))
#ifdef MSG_DONTWAIT
	    return MSG_DONTWAIT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_EOF"))
#ifdef MSG_EOF
	    return MSG_EOF;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_EOR"))
#ifdef MSG_EOR
	    return MSG_EOR;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_ERRQUEUE"))
#ifdef MSG_ERRQUEUE
	    return MSG_ERRQUEUE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_FIN"))
#ifdef MSG_FIN
	    return MSG_FIN;
#else
	    goto not_there;
#endif
a233 6
	if (strEQ(name, "MSG_NOSIGNAL"))
#ifdef MSG_NOSIGNAL
	    return MSG_NOSIGNAL;
#else
	    goto not_there;
#endif
d235 1
a235 1
#if defined(MSG_OOB) || defined(HAS_MSG_OOB) /* might be an enum */
d241 1
a241 1
#if defined(MSG_PEEK) || defined(HAS_MSG_PEEK) /* might be an enum */
a245 30
	if (strEQ(name, "MSG_PROXY"))
#if defined(MSG_PROXY) || defined(HAS_MSG_PROXY) /* might be an enum */
	    return MSG_PROXY;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_RST"))
#ifdef MSG_RST
	    return MSG_RST;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_SYN"))
#ifdef MSG_SYN
	    return MSG_SYN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_TRUNC"))
#ifdef MSG_TRUNC
	    return MSG_TRUNC;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MSG_WAITALL"))
#ifdef MSG_WAITALL
	    return MSG_WAITALL;
#else
	    goto not_there;
#endif
a401 30
	if (strEQ(name, "SCM_CONNECT"))
#ifdef SCM_CONNECT
	    return SCM_CONNECT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SCM_CREDENTIALS"))
#ifdef SCM_CREDENTIALS
	    return SCM_CREDENTIALS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SCM_CREDS"))
#ifdef SCM_CREDS
	    return SCM_CREDS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SCM_RIGHTS"))
#if defined(SCM_RIGHTS) || defined(HAS_SCM_RIGHTS) /* might be an enum */
	    return SCM_RIGHTS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SCM_TIMESTAMP"))
#ifdef SCM_TIMESTAMP
	    return SCM_TIMESTAMP;
#else
	    goto not_there;
#endif
a597 1
	int ok = inet_aton(host, &ip_address);
d599 1
a599 1
	if (!ok && (phe = gethostbyname(host))) {
d601 2
a602 1
		ok = 1;
d606 1
a606 1
	if (ok) {
a638 1
	STRLEN len;
d641 1
a641 4
	len = strlen(pathname);
	if (len > sizeof(sun_ad.sun_path))
	    len = sizeof(sun_ad.sun_path);
	Copy( pathname, sun_ad.sun_path, len, char );
d652 1
a652 1
	CODE:
d655 1
d657 1
a657 3
	STRLEN sockaddrlen;
	char * sun_ad = SvPV(sun_sv,sockaddrlen);
	char * e;
d672 2
a673 5
	}
	e = addr.sun_path;
	while (*e && e < addr.sun_path + sizeof addr.sun_path)
	    ++e;
	ST(0) = sv_2mortal(newSVpv(addr.sun_path, e - addr.sun_path));
d720 1
a720 1
	EXTEND(SP, 2);
a748 9
	ST(0) = sv_2mortal(newSVpv((char *)&ip_address,sizeof ip_address));
	}

void
INADDR_BROADCAST()
	CODE:
	{
	struct in_addr	ip_address;
	ip_address.s_addr = htonl(INADDR_BROADCAST);
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a0 1
#define PERL_NO_GET_CONTEXT
d9 9
a17 16
# include <sys/socket.h>
# if defined(USE_SOCKS) && defined(I_SOCKS)
#   include <socks.h>
# endif 
# ifdef MPE
#  define PF_INET AF_INET
#  define PF_UNIX AF_UNIX
#  define SOCK_RAW 3
# endif
# ifdef I_SYS_UN
#  include <sys/un.h>
# endif
/* XXX Configure test for <netinet/in_systm.h needed XXX */
# if defined(NeXT) || defined(__NeXT__)
#  include <netinet/in_systm.h>
# endif
d21 4
a24 9
# ifdef I_NETDB
#  include <netdb.h>
# endif
# ifdef I_ARPA_INET
#  include <arpa/inet.h>
# endif
# ifdef I_NETINET_TCP
#  include <netinet/tcp.h>
# endif
d26 1
a26 5
# include "sockadapt.h"
#endif

#ifdef I_SYSUIO
# include <sys/uio.h>
d30 1
a30 1
# undef PF_NBS
d34 1
a34 1
# undef PF_X25
d38 1
a38 1
# define INADDR_NONE	0xffffffff
d41 1
a41 1
# define INADDR_BROADCAST	0xffffffff
d44 1
a44 1
# define INADDR_LOOPBACK         0x7F000001
a58 1
	dTHX;
a324 12
	if (strEQ(name, "IOV_MAX"))
#ifdef IOV_MAX
	    return IOV_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "IPPROTO_TCP"))
#ifdef IPPROTO_TCP
	    return IPPROTO_TCP;
#else
	    goto not_there;
#endif
a332 6
	if (strEQ(name, "MSG_BCAST"))
#ifdef MSG_BCAST
	    return MSG_BCAST;
#else
	    goto not_there;
#endif
a392 6
	if (strEQ(name, "MSG_MCAST"))
#ifdef MSG_MCAST
	    return MSG_MCAST;
#else
	    goto not_there;
#endif
a626 18
	if (strEQ(name, "SHUT_RD"))
#ifdef SHUT_RD
	    return SHUT_RD;
#else
	    return 0;
#endif
	if (strEQ(name, "SHUT_RDWR"))
#ifdef SHUT_RDWR
	    return SHUT_RDWR;
#else
	    return 2;
#endif
	if (strEQ(name, "SHUT_WR"))
#ifdef SHUT_WR
	    return SHUT_WR;
#else
	    return 1;
#endif
a784 30
	if (strEQ(name, "TCP_KEEPALIVE"))
#ifdef TCP_KEEPALIVE
	    return TCP_KEEPALIVE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCP_MAXRT"))
#ifdef TCP_MAXRT
	    return TCP_MAXRT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCP_MAXSEG"))
#ifdef TCP_MAXSEG
	    return TCP_MAXSEG;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCP_NODELAY"))
#ifdef TCP_NODELAY
	    return TCP_NODELAY;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCP_STDURG"))
#ifdef TCP_STDURG
	    return TCP_STDURG;
#else
	    goto not_there;
#endif
a786 6
	if (strEQ(name, "UIO_MAXIOV"))
#ifdef UIO_MAXIOV
	    return UIO_MAXIOV;
#else
	    goto not_there;
#endif
d854 1
a854 1
	ST(0) = sv_2mortal(newSVpvn(addr_str, strlen(addr_str)));
a864 1

a869 23
#  ifdef OS2	/* Name should start with \socket\ and contain backslashes! */
	{
	    int off;
	    char *s, *e;

	    if (pathname[0] != '/' && pathname[0] != '\\')
		croak("Relative UNIX domain socket name '%s' unsupported", pathname);
	    else if (len < 8 
		     || pathname[7] != '/' && pathname[7] != '\\'
		     || !strnicmp(pathname + 1, "socket", 6))
		off = 7;
	    else
		off = 0;		/* Preserve names starting with \socket\ */
	    Copy( "\\socket", sun_ad.sun_path, off, char);
	    Copy( pathname, sun_ad.sun_path + off, len, char );

	    s = sun_ad.sun_path + off - 1;
	    e = s + len + 1;
	    while (++s < e)
		if (*s = '/')
		    *s = '\\';
	}
#  else	/* !( defined OS2 ) */ 
d871 1
a871 2
#  endif
	ST(0) = sv_2mortal(newSVpvn((char *)&sun_ad, sizeof sun_ad));
d906 1
a906 1
	ST(0) = sv_2mortal(newSVpvn(addr.sun_path, e - addr.sun_path));
d925 1
a925 1
	ST(0) = sv_2mortal(newSVpvn((char *)&sin, sizeof sin));
d955 1
a955 1
	PUSHs(sv_2mortal(newSVpvn((char *)&ip_address,sizeof ip_address)));
d964 1
a964 1
	ST(0) = sv_2mortal(newSVpvn((char *)&ip_address,sizeof ip_address ));
d973 1
a973 1
	ST(0) = sv_2mortal(newSVpvn((char *)&ip_address,sizeof ip_address));
d982 1
a982 1
	ST(0) = sv_2mortal(newSVpvn((char *)&ip_address,sizeof ip_address));
d991 1
a991 1
	ST(0) = sv_2mortal(newSVpvn((char *)&ip_address,sizeof ip_address));
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d1009 1
a1009 3
#   ifndef __linux__
	/* On Linux sockaddrlen on sockets returned by accept, recvfrom,
	   getpeername and getsockname is not equal to sizeof(addr). */
a1014 1
#   endif
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a5 2
#include <stddef.h>

d13 1
a13 1
# endif
a41 5
#ifdef NETWARE
NETDB_DEFINE_CONTEXT
NETINET_DEFINE_CONTEXT
#endif

d66 1
a66 1
/*
d85 1
a85 1
       if (!cp || !*cp)
d107 1
a107 1
				val = (val << 4) +
d177 725
a901 1
#define PERL_IN_ADDR_S_ADDR_SIZE 4
a902 27
/*
* Bad assumptions possible here.
*
* Bad Assumption 1: struct in_addr has no other fields
* than the s_addr (which is the field we care about
* in here, really). However, we can be fed either 4-byte
* addresses (from pack("N", ...), or va.b.c.d, or ...),
* or full struct in_addrs (from e.g. pack_sockaddr_in()),
* which may or may not be 4 bytes in size.
*
* Bad Assumption 2: the s_addr field is a simple type
* (such as an int, u_int32_t).  It can be a bit field,
* in which case using & (address-of) on it or taking sizeof()
* wouldn't go over too well.  (Those are not attempted
* now but in case someone thinks to change the below code
* to use addr.s_addr instead of addr, you have been warned.)
*
* Bad Assumption 3: the s_addr is the first field in
* an in_addr, or that its bytes are the first bytes in
* an in_addr.
*
* These bad assumptions are wrong in UNICOS which has
* struct in_addr { struct { u_long  st_addr:32; } s_da };
* #define s_addr s_da.st_addr
* and u_long is 64 bits.
*
* --jhi */
d904 1
a904 1
#include "const-c.inc"
d906 4
a909 1
MODULE = Socket		PACKAGE = Socket
a910 1
INCLUDE: const-xs.inc
d919 1
a919 4
	int ok =
		(host != NULL) &&
		(*host != '\0') &&
		inet_aton(host, &ip_address);
d927 1
a927 1
	if (ok)
d930 1
d940 5
a944 26
	char * ip_address;
	if (DO_UTF8(ip_address_sv) && !sv_utf8_downgrade(ip_address_sv, 1))
	     croak("Wide character in Socket::inet_ntoa");
	ip_address = SvPVbyte(ip_address_sv, addrlen);
	if (addrlen == sizeof(addr) || addrlen == 4)
	        addr.s_addr =
		    (ip_address[0] & 0xFF) << 24 |
		    (ip_address[1] & 0xFF) << 16 |
		    (ip_address[2] & 0xFF) <<  8 |
		    (ip_address[3] & 0xFF);
	else
	        croak("Bad arg length for %s, length is %d, should be %d",
		      "Socket::inet_ntoa",
		      addrlen, sizeof(addr));
	/* We could use inet_ntoa() but that is broken
	 * in HP-UX + GCC + 64bitint (returns "0.0.0.0"),
	 * so let's use this sprintf() workaround everywhere.
	 * This is also more threadsafe than using inet_ntoa(). */
	New(1138, addr_str, 4 * 3 + 3 + 1, char); /* IPv6? */
	sprintf(addr_str, "%d.%d.%d.%d",
		((addr.s_addr >> 24) & 0xFF),
		((addr.s_addr >> 16) & 0xFF),
		((addr.s_addr >>  8) & 0xFF),
		( addr.s_addr        & 0xFF));
	ST(0) = sv_2mortal(newSVpvn(addr_str, strlen(addr_str)));
	Safefree(addr_str);
d947 4
a950 11
void
sockaddr_family(sockaddr)
	SV *	sockaddr
	PREINIT:
	STRLEN sockaddr_len;
	char *sockaddr_pv = SvPVbyte(sockaddr, sockaddr_len);
	CODE:
	if (sockaddr_len < offsetof(struct sockaddr, sa_data)) {
	    croak("Bad arg length for %s, length is %d, should be at least %d",
	          "Socket::sockaddr_family", sockaddr_len,
		  offsetof(struct sockaddr, sa_data));
a951 1
	ST(0) = sv_2mortal(newSViv(((struct sockaddr*)sockaddr_pv)->sa_family));
d974 1
a974 1
	    else if (len < 8
d989 1
a989 1
#  else	/* !( defined OS2 ) */
a991 1
	if (0) not_here("dummy");
d1007 1
a1007 1
	char * sun_ad = SvPVbyte(sun_sv,sockaddrlen);
d1037 1
a1037 1
pack_sockaddr_in(port, ip_address_sv)
d1039 1
a1039 1
	SV *	ip_address_sv
d1043 1
a1043 16
	struct in_addr addr;
	STRLEN addrlen;
	char * ip_address;
	if (DO_UTF8(ip_address_sv) && !sv_utf8_downgrade(ip_address_sv, 1))
	     croak("Wide character in Socket::pack_sockaddr_in");
	ip_address = SvPVbyte(ip_address_sv, addrlen);
	if (addrlen == sizeof(addr) || addrlen == 4)
	        addr.s_addr =
		    (ip_address[0] & 0xFF) << 24 |
		    (ip_address[1] & 0xFF) << 16 |
		    (ip_address[2] & 0xFF) <<  8 |
		    (ip_address[3] & 0xFF);
	else
	        croak("Bad arg length for %s, length is %d, should be %d",
		      "Socket::pack_sockaddr_in",
		      addrlen, sizeof(addr));
d1047 2
a1048 1
	sin.sin_addr.s_addr = htonl(addr.s_addr);
d1060 2
a1061 2
	struct in_addr  ip_address;
	char *	sin = SvPVbyte(sin_sv,sockaddrlen);
d1073 1
a1073 1
	}
d1079 37
a1115 1
	PUSHs(sv_2mortal(newSVpvn((char *)&ip_address, sizeof ip_address)));
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d12 1
a12 3
# if !defined(ultrix) /* Avoid double definition. */
#   include <sys/socket.h>
# endif
d28 1
a28 4
# if defined(__sgi) && !defined(AF_LINK) && defined(PF_LINK) && PF_LINK == AF_LNK
#  undef PF_LINK
# endif
# if defined(I_NETINET_IN) || defined(__ultrix__)
d32 1
a32 3
#  if !defined(ultrix)  /* Avoid double definition. */
#   include <netdb.h>
#  endif
d367 2
a368 2
	e = (char*)addr.sun_path;
	while (*e && e < (char*)addr.sun_path + sizeof addr.sun_path)
d370 1
a370 1
	ST(0) = sv_2mortal(newSVpvn(addr.sun_path, e - (char*)addr.sun_path));
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d301 1
a301 1
	SV *	pathname
a306 1
	char * pathname_pv;
d310 1
a310 1
	pathname_pv = SvPV(pathname,len);
d318 2
a319 3
	    if (pathname_pv[0] != '/' && pathname_pv[0] != '\\')
		croak("Relative UNIX domain socket name '%s' unsupported",
			pathname_pv);
d321 2
a322 2
		     || pathname_pv[7] != '/' && pathname_pv[7] != '\\'
		     || !strnicmp(pathname_pv + 1, "socket", 6))
d327 1
a327 1
	    Copy( pathname_pv, sun_ad.sun_path + off, len, char );
d336 1
a336 1
	Copy( pathname_pv, sun_ad.sun_path, len, char );
d375 1
a375 4
	/* On Linux, the name of abstract unix domain sockets begins
	 * with a '\0', so allow this. */
	while ((*e || (e == addr.sun_path && e[1] && sockaddrlen > 1))
		&& e < (char*)addr.sun_path + sizeof addr.sun_path)
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d275 1
a275 1
	Newx(addr_str, 4 * 3 + 3 + 1, char); /* IPv6? */
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d234 4
a237 1
	int ok = (*host != '\0') && inet_aton(host, &ip_address);
d239 1
a239 2
	if (!ok && (phe = gethostbyname(host)) &&
			phe->h_addrtype == AF_INET && phe->h_length == 4) {
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d185 1
a185 1
not_here(const char *s)
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d279 1
a279 1
	ST(0) = newSVpvn_flags(addr_str, strlen(addr_str), SVs_TEMP);
a305 1
	int addr_len;
d339 1
a339 11
	if (len > 1 && sun_ad.sun_path[0] == '\0') {
		/* Linux-style abstract-namespace socket.
		 * The name is not a file name, but an array of arbitrary
		 * character, starting with \0 and possibly including \0s,
		 * therefore the length of the structure must denote the
		 * end of that character array */
		addr_len = (char *)&(sun_ad.sun_path) - (char *)&sun_ad + len;
	} else {
		addr_len = sizeof sun_ad;
	}
	ST(0) = newSVpvn_flags((char *)&sun_ad, addr_len, SVs_TEMP);
d355 1
a355 1
	int addr_len;
d374 7
a380 11

	if (addr.sun_path[0] == '\0') {
		/* Linux-style abstract socket address begins with a nul
		 * and can contain nuls. */
		addr_len = (char *)&addr - (char *)&(addr.sun_path) + sockaddrlen;
	} else {
		for (addr_len = 0; addr.sun_path[addr_len]
		     && addr_len < sizeof addr.sun_path; addr_len++);
	}

	ST(0) = newSVpvn_flags(addr.sun_path, addr_len, SVs_TEMP);
d413 1
a413 1
	ST(0) = newSVpvn_flags((char *)&sin, sizeof (sin), SVs_TEMP);
d443 1
a443 1
	PUSHs(newSVpvn_flags((char *)&ip_address, sizeof(ip_address), SVs_TEMP));
a444 52

void
inet_ntop(af, ip_address_sv)
        int     af
        SV *    ip_address_sv
        CODE:
#ifdef HAS_INETNTOP
	STRLEN addrlen, struct_size;
	struct in6_addr addr;
	char str[INET6_ADDRSTRLEN];
	char *ip_address = SvPV(ip_address_sv, addrlen);

        if(af == AF_INET) {
            struct_size = sizeof(struct in_addr);
        } else if(af == AF_INET6) {
            struct_size = sizeof(struct in6_addr);
        } else {
           croak("Bad address family for Socket::inet_ntop, got %d, should be either AF_INET or AF_INET6",
               af);
        }

	Copy( ip_address, &addr, sizeof addr, char );
	inet_ntop(af, &addr, str, INET6_ADDRSTRLEN);

	ST(0) = newSVpvn_flags(str, strlen(str), SVs_TEMP);
#else
        ST(0) = (SV *)not_here("inet_ntop");
#endif

void
inet_pton(af, host)
        int           af
        const char *  host
        CODE:
#ifdef HAS_INETPTON
        int ok;
        struct in6_addr ip_address;
        if(af != AF_INET && af != AF_INET6) {
           croak("Bad address family for %s, got %d, should be either AF_INET or AF_INET6",
                        "Socket::inet_pton",
                        af);
        }
        ok = (*host != '\0') && inet_pton(af, host, &ip_address);

        ST(0) = sv_newmortal();
        if (ok) {
                sv_setpvn( ST(0), (char *)&ip_address,
                           af == AF_INET6 ? sizeof(ip_address) : sizeof(struct in_addr) );
        }
#else
        ST(0) = (SV *)not_here("inet_pton");
#endif
@


