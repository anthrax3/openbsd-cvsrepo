head	1.2;
access;
symbols
	OPENBSD_4_6:1.1.1.2.0.6
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.2
	OPENBSD_4_5_BASE:1.1.1.2
	PERL_5_10_0:1.1.1.2
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2009.10.12.18.24.31;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2003.12.03.02.43.51;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.03.02.43.51;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.09.29.17.18.22;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Merge in perl 5.10.1
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';

    @@INC = '../lib';

    require Config; import Config;

    my $reason;

    if ($Config{'extensions'} !~ /\bIPC\/SysV\b/) {
      $reason = 'IPC::SysV was not built';
    } elsif ($Config{'d_sem'} ne 'define') {
      $reason = '$Config{d_sem} undefined';
    } elsif ($Config{'d_msg'} ne 'define') {
      $reason = '$Config{d_msg} undefined';
    }
    if ($reason) {
	print "1..0 # Skip: $reason\n";
	exit 0;
    }
}

# These constants are common to all tests.
# Later the sem* tests will import more for themselves.

use IPC::SysV qw(IPC_PRIVATE IPC_NOWAIT IPC_STAT IPC_RMID S_IRWXU);
use strict;

print "1..16\n";

my $msg;
my $sem;

$SIG{__DIE__} = 'cleanup'; # will cleanup $msg and $sem if needed

# FreeBSD is known to throw this if there's no SysV IPC in the kernel.
$SIG{SYS} = sub {
    print STDERR <<EOM;
SIGSYS caught.
It may be that your kernel does not have SysV IPC configured.

EOM
    if ($^O eq 'freebsd') {
	print STDERR <<EOM;
You must have following options in your kernel:

options         SYSVSHM
options         SYSVSEM
options         SYSVMSG

See config(8).
EOM
    }
    exit(1);
};

my $perm = S_IRWXU;

if ($Config{'d_msgget'} eq 'define' &&
    $Config{'d_msgctl'} eq 'define' &&
    $Config{'d_msgsnd'} eq 'define' &&
    $Config{'d_msgrcv'} eq 'define') {

    $msg = msgget(IPC_PRIVATE, $perm);
    # Very first time called after machine is booted value may be 0 
    die "msgget failed: $!\n" unless defined($msg) && $msg >= 0;

    print "ok 1\n";

    #Putting a message on the queue
    my $msgtype = 1;
    my $msgtext = "hello";

    my $test2bad;
    my $test5bad;
    my $test6bad;

    unless (msgsnd($msg,pack("L! a*",$msgtype,$msgtext),IPC_NOWAIT)) {
	print "not ";
	$test2bad = 1;
    }
    print "ok 2\n";
    if ($test2bad) {
	print <<EOM;
#
# The failure of the subtest #2 may indicate that the message queue
# resource limits either of the system or of the testing account
# have been reached.  Error message "Operating would block" is
# usually indicative of this situation.  The error message was now:
# "$!"
#
# You can check the message queues with the 'ipcs' command and
# you can remove unneeded queues with the 'ipcrm -q id' command.
# You may also consider configuring your system or account
# to have more message queue resources.
#
# Because of the subtest #2 failing also the substests #5 and #6 will
# very probably also fail.
#
EOM
    }

    my $data;
    msgctl($msg,IPC_STAT,$data) or print "not ";
    print "ok 3\n";

    print "not " unless length($data);
    print "ok 4\n";

    my $msgbuf;
    unless (msgrcv($msg,$msgbuf,256,0,IPC_NOWAIT)) {
	print "not ";
	$test5bad = 1;
    }
    print "ok 5\n";
    if ($test5bad && $test2bad) {
	print <<EOM;
#
# This failure was to be expected because the subtest #2 failed.
#
EOM
    }

    my($rmsgtype,$rmsgtext);
    ($rmsgtype,$rmsgtext) = unpack("L! a*",$msgbuf);
    unless ($rmsgtype == $msgtype && $rmsgtext eq $msgtext) {
	print "not ";
	$test6bad = 1;
    }
    print "ok 6\n";
    if ($test6bad && $test2bad) {
	print <<EOM;
#
# This failure was to be expected because the subtest #2 failed.
#
EOM
     }
} else {
    for (1..6) {
	print "ok $_\n"; # fake it
    }
}

if($Config{'d_semget'} eq 'define' &&
   $Config{'d_semctl'} eq 'define') {

    if ($Config{'d_semctl_semid_ds'} eq 'define' ||
	$Config{'d_semctl_semun'}    eq 'define') {

	use IPC::SysV qw(IPC_CREAT GETALL SETALL);

	$sem = semget(IPC_PRIVATE, 10, $perm | IPC_CREAT);
	# Very first time called after machine is booted value may be 0 
	die "semget: $!\n" unless defined($sem) && $sem >= 0;

	print "ok 7\n";

	my $data;
	semctl($sem,0,IPC_STAT,$data) or print "not ";
	print "ok 8\n";
	
	print "not " unless length($data);
	print "ok 9\n";

	my $nsem = 10;

	semctl($sem,0,SETALL,pack("s!*",(0) x $nsem)) or print "not ";
	print "ok 10\n";

	$data = "";
	semctl($sem,0,GETALL,$data) or print "not ";
	print "ok 11\n";

	print "not " unless length($data) == length(pack("s!*",(0) x $nsem));
	print "ok 12\n";

	my @@data = unpack("s!*",$data);

	my $adata = "0" x $nsem;

	print "not " unless @@data == $nsem and join("",@@data) eq $adata;
	print "ok 13\n";

	my $poke = 2;

	$data[$poke] = 1;
	semctl($sem,0,SETALL,pack("s!*",@@data)) or print "not ";
	print "ok 14\n";
    
	$data = "";
	semctl($sem,0,GETALL,$data) or print "not ";
	print "ok 15\n";

	@@data = unpack("s!*",$data);

	my $bdata = "0" x $poke . "1" . "0" x ($nsem-$poke-1);

	print "not " unless join("",@@data) eq $bdata;
	print "ok 16\n";
    } else {
	for (7..16) {
	    print "ok $_ # skipped, no semctl possible\n";
	}
    }
} else {
    for (7..16) {
	print "ok $_\n"; # fake it
    }
}

sub cleanup {
    msgctl($msg,IPC_RMID,0)       if defined $msg;
    semctl($sem,0,IPC_RMID,undef) if defined $sem;
}

cleanup;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@perl 5.8.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.0 from CPAN
@
text
@d1 2
d6 1
a6 1
    @@INC = qw(. ../lib);
a8 2
    require 'test.pl';
}
d10 13
a22 11
if ($Config{'extensions'} !~ /\bIPC\/SysV\b/) {
    skip_all('IPC::SysV was not built');
}
elsif ($Config{'d_sem'} ne 'define') {
    skip_all('$Config{d_sem} undefined');
}
elsif ($Config{'d_msg'} ne 'define') {
    skip_all('$Config{d_msg} undefined');
}
else {
    plan( tests => 17 );
d31 2
d36 2
d40 1
a40 1
    diag(<<EOM);
d46 1
a46 1
        diag(<<EOM);
a53 1

a55 1
    diag('Bail out! SIGSYS caught');
d61 1
a61 4
SKIP: {

skip( 'lacking d_msgget d_msgctl d_msgsnd d_msgrcv', 6 ) unless
    $Config{'d_msgget'} eq 'define' &&
d64 1
a64 1
    $Config{'d_msgrcv'} eq 'define';
d68 3
a70 6
    if (!(defined($msg) && $msg >= 0)) {
        skip( "msgget failed: $!", 6);
    }
    else {
        pass('msgget IPC_PRIVATE S_IRWXU');
    }
d80 22
a101 21
    my $test_name = 'queue a message';
    if (msgsnd($msg,pack("L! a*",$msgtype,$msgtext),IPC_NOWAIT)) {
        pass($test_name);
    }
    else {
        fail($test_name);
        $test2bad = 1;
        diag(<<EOM);
The failure of the subtest #2 may indicate that the message queue
resource limits either of the system or of the testing account
have been reached.  Error message "Operating would block" is
usually indicative of this situation.  The error message was now:
"$!"

You can check the message queues with the 'ipcs' command and
you can remove unneeded queues with the 'ipcrm -q id' command.
You may also consider configuring your system or account
to have more message queue resources.

Because of the subtest #2 failing also the substests #5 and #6 will
very probably also fail.
d106 2
a107 1
    ok(msgctl($msg,IPC_STAT,$data),'msgctl IPC_STAT call');
d109 2
a110 1
    cmp_ok(length($data),'>',0,'msgctl IPC_STAT data');
a111 1
    my $test_name = 'message get call';
d113 3
a115 6
    if (msgrcv($msg,$msgbuf,256,0,IPC_NOWAIT)) {
        pass($test_name);
    }
    else {
        fail($test_name);
        $test5bad = 1;
d117 1
d119 4
a122 2
        diag(<<EOM);
This failure was to be expected because the subtest #2 failed.
a125 1
    my $test_name = 'message get data';
d128 3
a130 6
    if ($rmsgtype == $msgtype && $rmsgtext eq $msgtext) {
        pass($test_name);
    }
    else {
        fail($test_name);
        $test6bad = 1;
d132 1
d134 4
a137 2
    print <<EOM;
This failure was to be expected because the subtest #2 failed.
d140 5
a144 3
} # SKIP

SKIP: {
d146 2
a147 3
    skip('lacking d_semget d_semctl', 11) unless
        $Config{'d_semget'} eq 'define' &&
        $Config{'d_semctl'} eq 'define';
d149 2
a150 1
    use IPC::SysV qw(IPC_CREAT GETALL SETALL);
d152 1
a152 2
    # FreeBSD's default limit seems to be 9
    my $nsem = 5;
d154 3
a156 9
    my $test_name = 'sem acquire';
    $sem = semget(IPC_PRIVATE, $nsem, $perm | IPC_CREAT);
    if ($sem) {
        pass($test_name);
    }
    else {
        diag("cannot proceed: semget() error: $!");
        skip('semget() resource unavailable', 11)
            if $! eq 'No space left on device';
d158 1
a158 3
        # Very first time called after machine is booted value may be 0 
        die "semget: $!\n" unless defined($sem) && $sem >= 0;
    }
d160 6
a165 2
    my $data;
    ok(semctl($sem,0,IPC_STAT,$data),'sem data call');
d167 1
a167 1
    cmp_ok(length($data),'>',0,'sem data len');
d169 2
a170 1
    ok(semctl($sem,0,SETALL,pack("s!*",(0) x $nsem)), 'set all sems');
d172 3
a174 2
    $data = "";
    ok(semctl($sem,0,GETALL,$data), 'get all sems');
d176 2
a177 1
    is(length($data),length(pack("s!*",(0) x $nsem)), 'right length');
d179 1
a179 1
    my @@data = unpack("s!*",$data);
d181 1
a181 1
    my $adata = "0" x $nsem;
d183 2
a184 2
    is(scalar(@@data),$nsem,'right amount');
    cmp_ok(join("",@@data),'eq',$adata,'right data');
d186 1
a186 1
    my $poke = 2;
d188 3
a190 2
    $data[$poke] = 1;
    ok(semctl($sem,0,SETALL,pack("s!*",@@data)),'poke it');
d192 3
a194 2
    $data = "";
    ok(semctl($sem,0,GETALL,$data),'and get it back');
d196 1
a196 2
    @@data = unpack("s!*",$data);
    my $bdata = "0" x $poke . "1" . "0" x ($nsem-$poke-1);
d198 1
a198 2
    cmp_ok(join("",@@data),'eq',$bdata,'changed');
} # SKIP
d200 14
a213 1
END {
d217 2
@

