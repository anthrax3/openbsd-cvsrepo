head	1.8;
access;
symbols
	OPENBSD_6_0:1.7.0.12
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.6
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.6.0.6
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.5.0.14
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.12
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.10
	OPENBSD_5_0:1.5.0.8
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.6
	OPENBSD_4_9_BASE:1.5
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.4.0.42
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.38
	OPENBSD_4_5_BASE:1.4
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.4.0.36
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.34
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.32
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.30
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.28
	OPENBSD_4_0_BASE:1.4
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.4.0.26
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.24
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.22
	OPENBSD_3_7_BASE:1.4
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.4.0.20
	OPENBSD_3_6_BASE:1.4
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.4.0.18
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.4.0.16
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.14
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.8
date	2017.02.05.00.32.14;	author afresh1;	state dead;
branches;
next	1.7;
commitid	cxJ08BvJA9Pt2PTM;

1.7
date	2014.03.24.15.05.27;	author afresh1;	state Exp;
branches;
next	1.6;

1.6
date	2013.03.25.20.40.54;	author sthen;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.12.18.24.34;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.05.34;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.35;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.55.48;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.13;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.13;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.39.01;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.22;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.10.12.18.11.18;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.08.46;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.03.24.14.59.02;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*
 * sdbm - ndbm work-alike hashed database library
 * based on Per-Aake Larson's Dynamic Hashing algorithms. BIT 18 (1978).
 * author: oz@@nexus.yorku.ca
 * status: public domain.
 *
 * page-level routines
 */

#include "config.h"
#ifdef __CYGWIN__
# define EXTCONST extern const
#else
# include "EXTERN.h"
#endif
#include "sdbm.h"
#include "tune.h"
#include "pair.h"

#define exhash(item)	sdbm_hash((item).dptr, (item).dsize)

/* 
 * forward 
 */
static int seepair proto((char *, int, const char *, int));

/*
 * page format:
 *	+------------------------------+
 * ino	| n | keyoff | datoff | keyoff |
 * 	+------------+--------+--------+
 *	| datoff | - - - ---->	       |
 *	+--------+---------------------+
 *	|	 F R E E A R E A       |
 *	+--------------+---------------+
 *	|  <---- - - - | data          |
 *	+--------+-----+----+----------+
 *	|  key   | data     | key      |
 *	+--------+----------+----------+
 *
 * calculating the offsets for free area:  if the number
 * of entries (ino[0]) is zero, the offset to the END of
 * the free area is the block size. Otherwise, it is the
 * nth (ino[ino[0]]) entry's offset.
 */

int
fitpair(char *pag, int need)
{
	int n;
	int off;
	int free;
	short *ino = (short *) pag;

	off = ((n = ino[0]) > 0) ? ino[n] : PBLKSIZ;
	free = off - (n + 1) * sizeof(short);
	need += 2 * sizeof(short);

	debug(("free %d need %d\n", free, need));

	return need <= free;
}

void
putpair(char *pag, datum key, datum val)
{
	int n;
	int off;
	short *ino = (short *) pag;

	off = ((n = ino[0]) > 0) ? ino[n] : PBLKSIZ;
/*
 * enter the key first
 */
	off -= key.dsize;
	(void) memcpy(pag + off, key.dptr, key.dsize);
	ino[n + 1] = off;
/*
 * now the data
 */
	off -= val.dsize;
	(void) memcpy(pag + off, val.dptr, val.dsize);
	ino[n + 2] = off;
/*
 * adjust item count
 */
	ino[0] += 2;
}

datum
getpair(char *pag, datum key)
{
	int i;
	int n;
	datum val;
	short *ino = (short *) pag;

	if ((n = ino[0]) == 0)
		return nullitem;

	if ((i = seepair(pag, n, key.dptr, key.dsize)) == 0)
		return nullitem;

	val.dptr = pag + ino[i + 1];
	val.dsize = ino[i] - ino[i + 1];
	return val;
}

int
exipair(char *pag, datum key)
{
	short *ino = (short *) pag;

	if (ino[0] == 0)
		return 0;

	return (seepair(pag, ino[0], key.dptr, key.dsize) != 0);
}

#ifdef SEEDUPS
int
duppair(char *pag, datum key)
{
	short *ino = (short *) pag;
	return ino[0] > 0 && seepair(pag, ino[0], key.dptr, key.dsize) > 0;
}
#endif

datum
getnkey(char *pag, int num)
{
	datum key;
	int off;
	short *ino = (short *) pag;

	num = num * 2 - 1;
	if (ino[0] == 0 || num > ino[0])
		return nullitem;

	off = (num > 1) ? ino[num - 1] : PBLKSIZ;

	key.dptr = pag + ino[num];
	key.dsize = off - ino[num];

	return key;
}

int
delpair(char *pag, datum key)
{
	int n;
	int i;
	short *ino = (short *) pag;

	if ((n = ino[0]) == 0)
		return 0;

	if ((i = seepair(pag, n, key.dptr, key.dsize)) == 0)
		return 0;
/*
 * found the key. if it is the last entry
 * [i.e. i == n - 1] we just adjust the entry count.
 * hard case: move all data down onto the deleted pair,
 * shift offsets onto deleted offsets, and adjust them.
 * [note: 0 < i < n]
 */
	if (i < n - 1) {
		int m;
		char *dst = pag + (i == 1 ? PBLKSIZ : ino[i - 1]);
		char *src = pag + ino[i + 1];
		int   zoo = dst - src;

		debug(("free-up %d ", zoo));
/*
 * shift data/keys down
 */
		m = ino[i + 1] - ino[n];
#ifdef DUFF
#define MOVB 	*--dst = *--src

		if (m > 0) {
			int loop = (m + 8 - 1) >> 3;

			switch (m & (8 - 1)) {
			case 0:	do {
				MOVB;	case 7:	MOVB;
			case 6:	MOVB;	case 5:	MOVB;
			case 4:	MOVB;	case 3:	MOVB;
			case 2:	MOVB;	case 1:	MOVB;
				} while (--loop);
			}
		}
#else
#ifdef HAS_MEMMOVE
		dst -= m;
		src -= m;
		memmove(dst, src, m);
#else
		while (m--)
			*--dst = *--src;
#endif
#endif
/*
 * adjust offset index up
 */
		while (i < n - 1) {
			ino[i] = ino[i + 2] + zoo;
			i++;
		}
	}
	ino[0] -= 2;
	return 1;
}

/*
 * search for the key in the page.
 * return offset index in the range 0 < i < n.
 * return 0 if not found.
 */
static int
seepair(char *pag, int n, const char *key, int siz)
{
	int i;
	int off = PBLKSIZ;
	short *ino = (short *) pag;

	for (i = 1; i < n; i += 2) {
		if (siz == off - ino[i] &&
		    memEQ(key, pag + ino[i], siz))
			return i;
		off = ino[i + 1];
	}
	return 0;
}

void
splpage(char *pag, char *New, long int sbit)
{
	datum key;
	datum val;

	int n;
	int off = PBLKSIZ;
	char cur[PBLKSIZ];
	short *ino = (short *) cur;

	(void) memcpy(cur, pag, PBLKSIZ);
	(void) memset(pag, 0, PBLKSIZ);
	(void) memset(New, 0, PBLKSIZ);

	n = ino[0];
	for (ino++; n > 0; ino += 2) {
		key.dptr = cur + ino[0]; 
		key.dsize = off - ino[0];
		val.dptr = cur + ino[1];
		val.dsize = ino[0] - ino[1];
/*
 * select the page pointer (by looking at sbit) and insert
 */
		(void) putpair((exhash(key) & sbit) ? New : pag, key, val);

		off = ino[1];
		n -= 2;
	}

	debug(("%d split %d/%d\n", ((short *) cur)[0] / 2, 
	       ((short *) New)[0] / 2,
	       ((short *) pag)[0] / 2));
}

/*
 * check page sanity: 
 * number of entries should be something
 * reasonable, and all offsets in the index should be in order.
 * this could be made more rigorous.
 */
int
chkpage(char *pag)
{
	int n;
	int off;
	short *ino = (short *) pag;

	if ((n = ino[0]) < 0 || n > (int)(PBLKSIZ / sizeof(short)))
		return 0;

	if (n > 0) {
		off = PBLKSIZ;
		for (ino++; n > 0; ino += 2) {
			if (ino[0] > off || ino[1] > off ||
			    ino[1] > ino[0])
				return 0;
			off = ino[1];
			n -= 2;
		}
	}
	return 1;
}
@


1.7
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@@


1.6
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d50 4
a53 4
	register int n;
	register int off;
	register int free;
	register short *ino = (short *) pag;
d67 3
a69 3
	register int n;
	register int off;
	register short *ino = (short *) pag;
d93 2
a94 2
	register int i;
	register int n;
d96 1
a96 1
	register short *ino = (short *) pag;
d112 1
a112 1
	register short *ino = (short *) pag;
d124 1
a124 1
	register short *ino = (short *) pag;
d133 2
a134 2
	register int off;
	register short *ino = (short *) pag;
d151 3
a153 3
	register int n;
	register int i;
	register short *ino = (short *) pag;
d168 4
a171 4
		register int m;
		register char *dst = pag + (i == 1 ? PBLKSIZ : ino[i - 1]);
		register char *src = pag + ino[i + 1];
		register int   zoo = dst - src;
d182 1
a182 1
			register int loop = (m + 8 - 1) >> 3;
d221 1
a221 1
seepair(char *pag, register int n, register const char *key, register int siz)
d223 3
a225 3
	register int i;
	register int off = PBLKSIZ;
	register short *ino = (short *) pag;
d242 2
a243 2
	register int n;
	register int off = PBLKSIZ;
d245 1
a245 1
	register short *ino = (short *) cur;
d280 3
a282 3
	register int n;
	register int off;
	register short *ino = (short *) pag;
@


1.5
log
@Merge in perl 5.10.1
@
text
@d284 1
a284 1
	if ((n = ino[0]) < 0 || n > PBLKSIZ / sizeof(short))
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d25 1
a25 1
static int seepair proto((char *, int, char *, int));
d221 1
a221 1
seepair(char *pag, register int n, register char *key, register int siz)
@


1.3
log
@perl5.005_03 (stock)
@
text
@d11 5
a15 1
#include "EXTERN.h"
d107 11
@


1.2
log
@perl 5.004_04
@
text
@a9 4
#ifndef lint
static char rcsid[] = "$Id: pair.c,v 1.10 90/12/13 13:00:35 oz Exp $";
#endif

d11 1
d44 1
a44 3
fitpair(pag, need)
char *pag;
int need;
d61 1
a61 4
putpair(pag, key, val)
char *pag;
datum key;
datum val;
d87 1
a87 3
getpair(pag, key)
char *pag;
datum key;
d107 1
a107 3
duppair(pag, key)
char *pag;
datum key;
d115 1
a115 3
getnkey(pag, num)
char *pag;
int num;
d134 1
a134 3
delpair(pag, key)
char *pag;
datum key;
d206 1
a206 5
seepair(pag, n, key, siz)
char *pag;
register int n;
register char *key;
register int siz;
d222 1
a222 4
splpage(pag, new, sbit)
char *pag;
char *new;
long sbit;
d234 1
a234 1
	(void) memset(new, 0, PBLKSIZ);
d245 1
a245 1
		(void) putpair((exhash(key) & sbit) ? new : pag, key, val);
d252 1
a252 1
	       ((short *) new)[0] / 2,
d263 1
a263 2
chkpage(pag)
char *pag;
@


1.1
log
@Initial revision
@
text
@d234 1
a234 1
		    memcmp(key, pag + ino[i], siz) == 0)
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d10 4
a14 1
#include "EXTERN.h"
d47 3
a49 1
fitpair(char *pag, int need)
d66 4
a69 1
putpair(char *pag, datum key, datum val)
d95 3
a97 1
getpair(char *pag, datum key)
d117 3
a119 1
duppair(char *pag, datum key)
d127 3
a129 1
getnkey(char *pag, int num)
d148 3
a150 1
delpair(char *pag, datum key)
d222 5
a226 1
seepair(char *pag, register int n, register char *key, register int siz)
d234 1
a234 1
		    memEQ(key, pag + ino[i], siz))
d242 4
a245 1
splpage(char *pag, char *New, long int sbit)
d257 1
a257 1
	(void) memset(New, 0, PBLKSIZ);
d268 1
a268 1
		(void) putpair((exhash(key) & sbit) ? New : pag, key, val);
d275 1
a275 1
	       ((short *) New)[0] / 2,
d286 2
a287 1
chkpage(char *pag)
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d11 1
a11 5
#ifdef __CYGWIN__
# define EXTCONST extern const
#else
# include "EXTERN.h"
#endif
a102 11
}

int
exipair(char *pag, datum key)
{
	register short *ino = (short *) pag;

	if (ino[0] == 0)
		return 0;

	return (seepair(pag, ino[0], key.dptr, key.dsize) != 0);
@


1.1.1.4
log
@import perl 5.10.1
@
text
@d25 1
a25 1
static int seepair proto((char *, int, const char *, int));
d221 1
a221 1
seepair(char *pag, register int n, register const char *key, register int siz)
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d284 1
a284 1
	if ((n = ino[0]) < 0 || n > (int)(PBLKSIZ / sizeof(short)))
@


1.1.1.6
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d50 4
a53 4
	int n;
	int off;
	int free;
	short *ino = (short *) pag;
d67 3
a69 3
	int n;
	int off;
	short *ino = (short *) pag;
d93 2
a94 2
	int i;
	int n;
d96 1
a96 1
	short *ino = (short *) pag;
d112 1
a112 1
	short *ino = (short *) pag;
d124 1
a124 1
	short *ino = (short *) pag;
d133 2
a134 2
	int off;
	short *ino = (short *) pag;
d151 3
a153 3
	int n;
	int i;
	short *ino = (short *) pag;
d168 4
a171 4
		int m;
		char *dst = pag + (i == 1 ? PBLKSIZ : ino[i - 1]);
		char *src = pag + ino[i + 1];
		int   zoo = dst - src;
d182 1
a182 1
			int loop = (m + 8 - 1) >> 3;
d221 1
a221 1
seepair(char *pag, int n, const char *key, int siz)
d223 3
a225 3
	int i;
	int off = PBLKSIZ;
	short *ino = (short *) pag;
d242 2
a243 2
	int n;
	int off = PBLKSIZ;
d245 1
a245 1
	short *ino = (short *) cur;
d280 3
a282 3
	int n;
	int off;
	short *ino = (short *) pag;
@


