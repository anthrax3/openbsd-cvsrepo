head	1.15;
access;
symbols
	OPENBSD_6_0:1.14.0.10
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.4
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.15
date	2017.02.05.00.32.14;	author afresh1;	state dead;
branches;
next	1.14;
commitid	cxJ08BvJA9Pt2PTM;

1.14
date	2014.11.17.20.57.06;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	QP75iYx42Uo7mMxO;

1.13
date	2014.03.24.15.05.27;	author afresh1;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.25.20.40.54;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.24.34;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.06;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.04;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.31.18.49.17;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.33;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.23;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.05.36;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.35;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.55.51;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.14;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.14;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.39.04;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.22;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.59;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.53;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.46.27;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.17.00;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.48.20;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.24;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.11.18;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.08.47;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.59.02;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.53.06;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.15
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*
 * sdbm - ndbm work-alike hashed database library
 * based on Per-Aake Larson's Dynamic Hashing algorithms. BIT 18 (1978).
 * author: oz@@nexus.yorku.ca
 * status: public domain.
 *
 * core routines
 */

#include "INTERN.h"
#include "config.h"
#ifdef WIN32
#include "io.h"
#endif
#include "sdbm.h"
#include "tune.h"
#include "pair.h"

#ifdef I_FCNTL
# include <fcntl.h>
#endif
#ifdef I_SYS_FILE
# include <sys/file.h>
#endif

#ifdef I_STRING
# ifndef __ultrix__
#  include <string.h>
# endif
#else
# include <strings.h>
#endif

/*
 * externals
 */

#include <errno.h> /* See notes in perl.h about avoiding
			extern int errno; */
#ifdef __cplusplus
extern "C" {
#endif

extern Malloc_t malloc proto((MEM_SIZE));
extern Free_t free proto((Malloc_t));

#ifdef __cplusplus
}
#endif

/*
 * forward
 */
static int getdbit proto((DBM *, long));
static int setdbit proto((DBM *, long));
static int getpage proto((DBM *, long));
static datum getnext proto((DBM *));
static int makroom proto((DBM *, long, int));

/*
 * useful macros
 */
#define bad(x)		((x).dptr == NULL || (x).dsize < 0)
#define exhash(item)	sdbm_hash((item).dptr, (item).dsize)
#define ioerr(db)	((db)->flags |= DBM_IOERR)

#define OFF_PAG(off)	(long) (off) * PBLKSIZ
#define OFF_DIR(off)	(long) (off) * DBLKSIZ

static const long masks[] = {
	000000000000, 000000000001, 000000000003, 000000000007,
	000000000017, 000000000037, 000000000077, 000000000177,
	000000000377, 000000000777, 000000001777, 000000003777,
	000000007777, 000000017777, 000000037777, 000000077777,
	000000177777, 000000377777, 000000777777, 000001777777,
	000003777777, 000007777777, 000017777777, 000037777777,
	000077777777, 000177777777, 000377777777, 000777777777,
	001777777777, 003777777777, 007777777777, 017777777777
};

DBM *
sdbm_open(char *file, int flags, int mode)
{
	DBM *db;
	char *dirname;
	char *pagname;
	size_t filelen;
	const size_t dirfext_size = sizeof(DIRFEXT "");
	const size_t pagfext_size = sizeof(PAGFEXT "");

	if (file == NULL || !*file)
		return errno = EINVAL, (DBM *) NULL;
/*
 * need space for two separate filenames
 */
	filelen = strlen(file);

	if ((dirname = (char *) malloc(filelen + dirfext_size
				       + filelen + pagfext_size)) == NULL)
		return errno = ENOMEM, (DBM *) NULL;
/*
 * build the file names
 */
	memcpy(dirname, file, filelen);
	memcpy(dirname + filelen, DIRFEXT, dirfext_size);
	pagname = dirname + filelen + dirfext_size;
	memcpy(pagname, file, filelen);
	memcpy(pagname + filelen, PAGFEXT, pagfext_size);

	db = sdbm_prep(dirname, pagname, flags, mode);
	free((char *) dirname);
	return db;
}

DBM *
sdbm_prep(char *dirname, char *pagname, int flags, int mode)
{
	DBM *db;
	struct stat dstat;

	if ((db = (DBM *) malloc(sizeof(DBM))) == NULL)
		return errno = ENOMEM, (DBM *) NULL;

        db->flags = 0;
        db->hmask = 0;
        db->blkptr = 0;
        db->keyptr = 0;
/*
 * adjust user flags so that WRONLY becomes RDWR, 
 * as required by this package. Also set our internal
 * flag for RDONLY if needed.
 */
	if (flags & O_WRONLY)
		flags = (flags & ~O_WRONLY) | O_RDWR;

	else if ((flags & 03) == O_RDONLY)
		db->flags = DBM_RDONLY;
/*
 * open the files in sequence, and stat the dirfile.
 * If we fail anywhere, undo everything, return NULL.
 */
#if defined(OS2) || defined(MSDOS) || defined(WIN32) || defined(__CYGWIN__)
	flags |= O_BINARY;
#	endif
	if ((db->pagf = open(pagname, flags, mode)) > -1) {
		if ((db->dirf = open(dirname, flags, mode)) > -1) {
/*
 * need the dirfile size to establish max bit number.
 */
			if (fstat(db->dirf, &dstat) == 0) {
/*
 * zero size: either a fresh database, or one with a single,
 * unsplit data page: dirpage is all zeros.
 */
				db->dirbno = (!dstat.st_size) ? 0 : -1;
				db->pagbno = -1;
				db->maxbno = dstat.st_size * BYTESIZ;

				(void) memset(db->pagbuf, 0, PBLKSIZ);
				(void) memset(db->dirbuf, 0, DBLKSIZ);
			/*
			 * success
			 */
				return db;
			}
			(void) close(db->dirf);
		}
		(void) close(db->pagf);
	}
	free((char *) db);
	return (DBM *) NULL;
}

void
sdbm_close(DBM *db)
{
	if (db == NULL)
		errno = EINVAL;
	else {
		(void) close(db->dirf);
		(void) close(db->pagf);
		free((char *) db);
	}
}

datum
sdbm_fetch(DBM *db, datum key)
{
	if (db == NULL || bad(key))
		return errno = EINVAL, nullitem;

	if (getpage(db, exhash(key)))
		return getpair(db->pagbuf, key);

	return ioerr(db), nullitem;
}

int
sdbm_exists(DBM *db, datum key)
{
	if (db == NULL || bad(key))
		return errno = EINVAL, -1;

	if (getpage(db, exhash(key)))
		return exipair(db->pagbuf, key);

	return ioerr(db), -1;
}

int
sdbm_delete(DBM *db, datum key)
{
	if (db == NULL || bad(key))
		return errno = EINVAL, -1;
	if (sdbm_rdonly(db))
		return errno = EPERM, -1;

	if (getpage(db, exhash(key))) {
		if (!delpair(db->pagbuf, key))
			return -1;
/*
 * update the page file
 */
		if (lseek(db->pagf, OFF_PAG(db->pagbno), SEEK_SET) < 0
		    || write(db->pagf, db->pagbuf, PBLKSIZ) < 0)
			return ioerr(db), -1;

		return 0;
	}

	return ioerr(db), -1;
}

int
sdbm_store(DBM *db, datum key, datum val, int flags)
{
	int need;
	long hash;

	if (db == NULL || bad(key))
		return errno = EINVAL, -1;
	if (sdbm_rdonly(db))
		return errno = EPERM, -1;

	need = key.dsize + val.dsize;
/*
 * is the pair too big (or too small) for this database ??
 */
	if (need < 0 || need > PAIRMAX)
		return errno = EINVAL, -1;

	if (getpage(db, (hash = exhash(key)))) {
/*
 * if we need to replace, delete the key/data pair
 * first. If it is not there, ignore.
 */
		if (flags == DBM_REPLACE)
			(void) delpair(db->pagbuf, key);
#ifdef SEEDUPS
		else if (duppair(db->pagbuf, key))
			return 1;
#endif
/*
 * if we do not have enough room, we have to split.
 */
		if (!fitpair(db->pagbuf, need))
			if (!makroom(db, hash, need))
				return ioerr(db), -1;
/*
 * we have enough room or split is successful. insert the key,
 * and update the page file.
 */
		(void) putpair(db->pagbuf, key, val);

		if (lseek(db->pagf, OFF_PAG(db->pagbno), SEEK_SET) < 0
		    || write(db->pagf, db->pagbuf, PBLKSIZ) < 0)
			return ioerr(db), -1;
	/*
	 * success
	 */
		return 0;
	}

	return ioerr(db), -1;
}

/*
 * makroom - make room by splitting the overfull page
 * this routine will attempt to make room for SPLTMAX times before
 * giving up.
 */
static int
makroom(DBM *db, long int hash, int need)
{
	long newp;
	char twin[PBLKSIZ];
#if defined(DOSISH) || defined(WIN32)
	char zer[PBLKSIZ];
	long oldtail;
#endif
	char *pag = db->pagbuf;
	char *New = twin;
	int smax = SPLTMAX;
#ifdef BADMESS
	int rc;
#endif

	do {
/*
 * split the current page
 */
		(void) splpage(pag, New, db->hmask + 1);
/*
 * address of the new page
 */
		newp = (hash & db->hmask) | (db->hmask + 1);

/*
 * write delay, read avoidance/cache shuffle:
 * select the page for incoming pair: if key is to go to the new page,
 * write out the previous one, and copy the new one over, thus making
 * it the current page. If not, simply write the new page, and we are
 * still looking at the page of interest. current page is not updated
 * here, as sdbm_store will do so, after it inserts the incoming pair.
 */

#if defined(DOSISH) || defined(WIN32)
		/*
		 * Fill hole with 0 if made it.
		 * (hole is NOT read as 0)
		 */
		oldtail = lseek(db->pagf, 0L, SEEK_END);
		memset(zer, 0, PBLKSIZ);
		while (OFF_PAG(newp) > oldtail) {
			if (lseek(db->pagf, 0L, SEEK_END) < 0 ||
			    write(db->pagf, zer, PBLKSIZ) < 0) {

				return 0;
			}
			oldtail += PBLKSIZ;
		}
#endif
		if (hash & (db->hmask + 1)) {
			if (lseek(db->pagf, OFF_PAG(db->pagbno), SEEK_SET) < 0
			    || write(db->pagf, db->pagbuf, PBLKSIZ) < 0)
				return 0;
			db->pagbno = newp;
			(void) memcpy(pag, New, PBLKSIZ);
		}
		else if (lseek(db->pagf, OFF_PAG(newp), SEEK_SET) < 0
			 || write(db->pagf, New, PBLKSIZ) < 0)
			return 0;

		if (!setdbit(db, db->curbit))
			return 0;
/*
 * see if we have enough room now
 */
		if (fitpair(pag, need))
			return 1;
/*
 * try again... update curbit and hmask as getpage would have
 * done. because of our update of the current page, we do not
 * need to read in anything. BUT we have to write the current
 * [deferred] page out, as the window of failure is too great.
 */
		db->curbit = 2 * db->curbit +
			((hash & (db->hmask + 1)) ? 2 : 1);
		db->hmask |= db->hmask + 1;

		if (lseek(db->pagf, OFF_PAG(db->pagbno), SEEK_SET) < 0
		    || write(db->pagf, db->pagbuf, PBLKSIZ) < 0)
			return 0;

	} while (--smax);
/*
 * if we are here, this is real bad news. After SPLTMAX splits,
 * we still cannot fit the key. say goodnight.
 */
#ifdef BADMESS
	rc = write(2, "sdbm: cannot insert after SPLTMAX attempts.\n", 44);
	/* PERL_UNUSED_VAR() or PERL_UNUSED_RESULT() would be
	 * useful here but that would mean pulling in perl.h */
	(void)rc;
#endif
	return 0;

}

/*
 * the following two routines will break if
 * deletions aren't taken into account. (ndbm bug)
 */
datum
sdbm_firstkey(DBM *db)
{
	if (db == NULL)
		return errno = EINVAL, nullitem;
/*
 * start at page 0
 */
	if (lseek(db->pagf, OFF_PAG(0), SEEK_SET) < 0
	    || read(db->pagf, db->pagbuf, PBLKSIZ) < 0)
		return ioerr(db), nullitem;
	db->pagbno = 0;
	db->blkptr = 0;
	db->keyptr = 0;

	return getnext(db);
}

datum
sdbm_nextkey(DBM *db)
{
	if (db == NULL)
		return errno = EINVAL, nullitem;
	return getnext(db);
}

/*
 * all important binary trie traversal
 */
static int
getpage(DBM *db, long int hash)
{
	int hbit;
	long dbit;
	long pagb;

	dbit = 0;
	hbit = 0;
	while (dbit < db->maxbno && getdbit(db, dbit))
		dbit = 2 * dbit + ((hash & (1 << hbit++)) ? 2 : 1);

	debug(("dbit: %d...", dbit));

	db->curbit = dbit;
	db->hmask = masks[hbit];

	pagb = hash & db->hmask;
/*
 * see if the block we need is already in memory.
 * note: this lookaside cache has about 10% hit rate.
 */
	if (pagb != db->pagbno) { 
/*
 * note: here, we assume a "hole" is read as 0s.
 * if not, must zero pagbuf first.
 */
		if (lseek(db->pagf, OFF_PAG(pagb), SEEK_SET) < 0
		    || read(db->pagf, db->pagbuf, PBLKSIZ) < 0)
			return 0;
		if (!chkpage(db->pagbuf))
			return 0;
		db->pagbno = pagb;

		debug(("pag read: %d\n", pagb));
	}
	return 1;
}

static int
getdbit(DBM *db, long int dbit)
{
	long c;
	long dirb;

	c = dbit / BYTESIZ;
	dirb = c / DBLKSIZ;

	if (dirb != db->dirbno) {
		int got;
		if (lseek(db->dirf, OFF_DIR(dirb), SEEK_SET) < 0
		    || (got=read(db->dirf, db->dirbuf, DBLKSIZ)) < 0)
			return 0;
		if (got==0) 
			memset(db->dirbuf,0,DBLKSIZ);
		db->dirbno = dirb;

		debug(("dir read: %d\n", dirb));
	}

	return db->dirbuf[c % DBLKSIZ] & (1 << dbit % BYTESIZ);
}

static int
setdbit(DBM *db, long int dbit)
{
	long c;
	long dirb;

	c = dbit / BYTESIZ;
	dirb = c / DBLKSIZ;

	if (dirb != db->dirbno) {
		int got;
		if (lseek(db->dirf, OFF_DIR(dirb), SEEK_SET) < 0
		    || (got=read(db->dirf, db->dirbuf, DBLKSIZ)) < 0)
			return 0;
		if (got==0) 
			memset(db->dirbuf,0,DBLKSIZ);
		db->dirbno = dirb;

		debug(("dir read: %d\n", dirb));
	}

	db->dirbuf[c % DBLKSIZ] |= (1 << dbit % BYTESIZ);

#if 0
	if (dbit >= db->maxbno)
		db->maxbno += DBLKSIZ * BYTESIZ;
#else
	if (OFF_DIR((dirb+1))*BYTESIZ > db->maxbno) 
		db->maxbno=OFF_DIR((dirb+1))*BYTESIZ;
#endif

	if (lseek(db->dirf, OFF_DIR(dirb), SEEK_SET) < 0
	    || write(db->dirf, db->dirbuf, DBLKSIZ) < 0)
		return 0;

	return 1;
}

/*
 * getnext - get the next key in the page, and if done with
 * the page, try the next page in sequence
 */
static datum
getnext(DBM *db)
{
	datum key;

	for (;;) {
		db->keyptr++;
		key = getnkey(db->pagbuf, db->keyptr);
		if (key.dptr != NULL)
			return key;
/*
 * we either run out, or there is nothing on this page..
 * try the next one... If we lost our position on the
 * file, we will have to seek.
 */
		db->keyptr = 0;
		if (db->pagbno != db->blkptr++)
			if (lseek(db->pagf, OFF_PAG(db->blkptr), SEEK_SET) < 0)
				break;
		db->pagbno = db->blkptr;
		if (read(db->pagf, db->pagbuf, PBLKSIZ) <= 0)
			break;
		if (!chkpage(db->pagbuf))
			break;
	}

	return ioerr(db), nullitem;
}

@


1.14
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@@


1.13
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d304 3
d381 4
a384 1
	(void) write(2, "sdbm: cannot insert after SPLTMAX attempts.\n", 44);
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d40 3
d47 4
d82 1
a82 1
sdbm_open(register char *file, register int flags, register int mode)
d84 3
a86 3
	register DBM *db;
	register char *dirname;
	register char *pagname;
d118 1
a118 1
	register DBM *db;
d175 1
a175 1
sdbm_close(register DBM *db)
d187 1
a187 1
sdbm_fetch(register DBM *db, datum key)
d199 1
a199 1
sdbm_exists(register DBM *db, datum key)
d211 1
a211 1
sdbm_delete(register DBM *db, datum key)
d235 1
a235 1
sdbm_store(register DBM *db, datum key, datum val, int flags)
d238 1
a238 1
	register long hash;
d293 1
a293 1
makroom(register DBM *db, long int hash, int need)
d303 1
a303 1
	register int smax = SPLTMAX;
d389 1
a389 1
sdbm_firstkey(register DBM *db)
d407 1
a407 1
sdbm_nextkey(register DBM *db)
d418 1
a418 1
getpage(register DBM *db, register long int hash)
d420 3
a422 3
	register int hbit;
	register long dbit;
	register long pagb;
d457 1
a457 1
getdbit(register DBM *db, register long int dbit)
d459 2
a460 2
	register long c;
	register long dirb;
d481 1
a481 1
setdbit(register DBM *db, register long int dbit)
d483 2
a484 2
	register long c;
	register long dirb;
d523 1
a523 1
getnext(register DBM *db)
@


1.11
log
@Merge in perl 5.10.1
@
text
@d81 2
a82 2
	const size_t dirfext_len = sizeof(DIRFEXT "");
	const size_t pagfext_len = sizeof(PAGFEXT "");
d87 1
a87 1
 * need space for two seperate filenames
d91 2
a92 2
	if ((dirname = (char *) malloc(filelen + dirfext_len + 1
				       + filelen + pagfext_len + 1)) == NULL)
d98 2
a99 2
	memcpy(dirname + filelen, DIRFEXT, dirfext_len + 1);
	pagname = dirname + filelen + dirfext_len + 1;
d101 1
a101 1
	memcpy(pagname + filelen, PAGFEXT, pagfext_len + 1);
d309 1
a309 1
 * write delay, read avoidence/cache shuffle:
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d80 3
a82 1
	register int n;
d89 1
a89 1
	n = strlen(file) * 2 + strlen(DIRFEXT) + strlen(PAGFEXT) + 2;
d91 2
a92 1
	if ((dirname = (char *) malloc((unsigned) n)) == NULL)
d97 5
a101 3
	dirname = strcat(strcpy(dirname, file), DIRFEXT);
	pagname = strcpy(dirname + strlen(dirname) + 1, file);
	pagname = strcat(pagname, PAGFEXT);
@


1.9
log
@merge in perl 5.8.8
@
text
@d63 1
a63 1
static long masks[] = {
@


1.8
log
@#ifndef errno declaration. ok millert@@
@
text
@d37 3
a39 7
#ifndef WIN32
#ifndef sun
#ifndef errno
extern int errno;
#endif
#endif
#endif
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d39 1
d41 1
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d27 3
a29 1
# include <string.h>
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d39 1
a42 2

#endif
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d286 4
d312 17
@


1.3
log
@perl5.005_03 (stock)
@
text
@d12 3
d42 1
a42 1
extern Off_t lseek(int, Off_t, int);
d131 1
a131 1
#if defined(OS2) || defined(MSDOS) || defined(WIN32)
d188 12
d434 1
d436 1
a436 1
		    || read(db->dirf, db->dirbuf, DBLKSIZ) < 0)
d438 2
d458 1
a458 1
		(void) memset(db->dirbuf, 0, DBLKSIZ);
d460 1
a460 1
		    || read(db->dirf, db->dirbuf, DBLKSIZ) < 0)
d462 2
d471 1
d474 4
@


1.2
log
@perl 5.004_04
@
text
@d10 1
a10 4
#ifndef lint
static char rcsid[] = "$Id: sdbm.c,v 1.16 90/12/13 13:01:31 oz Exp $";
#endif

d39 1
a39 1
extern Off_t lseek();
a71 2
datum nullitem = {NULL, 0};

d73 1
a73 4
sdbm_open(file, flags, mode)
register char *file;
register int flags;
register int mode;
d87 1
a87 1
	if ((dirname = malloc((unsigned) n)) == NULL)
d102 1
a102 5
sdbm_prep(dirname, pagname, flags, mode)
char *dirname;
char *pagname;
int flags;
int mode;
d161 1
a161 2
sdbm_close(db)
register DBM *db;
d173 1
a173 3
sdbm_fetch(db, key)
register DBM *db;
datum key;
d185 1
a185 3
sdbm_delete(db, key)
register DBM *db;
datum key;
d209 1
a209 5
sdbm_store(db, key, val, flags)
register DBM *db;
datum key;
datum val;
int flags;
d267 1
a267 4
makroom(db, hash, need)
register DBM *db;
long hash;
int need;
d272 1
a272 1
	char *new = twin;
d279 1
a279 1
		(void) splpage(pag, new, db->hmask + 1);
d298 1
a298 1
			(void) memcpy(pag, new, PBLKSIZ);
d301 1
a301 1
			 || write(db->pagf, new, PBLKSIZ) < 0)
d342 1
a342 2
sdbm_firstkey(db)
register DBM *db;
d360 1
a360 2
sdbm_nextkey(db)
register DBM *db;
d371 1
a371 3
getpage(db, hash)
register DBM *db;
register long hash;
d410 1
a410 3
getdbit(db, dbit)
register DBM *db;
register long dbit;
d431 1
a431 3
setdbit(db, dbit)
register DBM *db;
register long dbit;
d440 1
d466 1
a466 2
getnext(db)
register DBM *db;
@


1.1
log
@Initial revision
@
text
@d35 1
d43 1
d140 1
a140 1
#	ifdef OS2
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d10 4
a13 1
#include "INTERN.h"
a34 1
#ifndef WIN32
d41 1
a41 2
extern Off_t lseek(int, Off_t, int);
#endif
d73 2
d76 4
a79 1
sdbm_open(register char *file, register int flags, register int mode)
d93 1
a93 1
	if ((dirname = (char *) malloc((unsigned) n)) == NULL)
d108 5
a112 1
sdbm_prep(char *dirname, char *pagname, int flags, int mode)
d138 1
a138 1
#if defined(OS2) || defined(MSDOS) || defined(WIN32)
d171 2
a172 1
sdbm_close(register DBM *db)
d184 3
a186 1
sdbm_fetch(register DBM *db, datum key)
d198 3
a200 1
sdbm_delete(register DBM *db, datum key)
d224 5
a228 1
sdbm_store(register DBM *db, datum key, datum val, int flags)
d286 4
a289 1
makroom(register DBM *db, long int hash, int need)
d294 1
a294 1
	char *New = twin;
d301 1
a301 1
		(void) splpage(pag, New, db->hmask + 1);
d320 1
a320 1
			(void) memcpy(pag, New, PBLKSIZ);
d323 1
a323 1
			 || write(db->pagf, New, PBLKSIZ) < 0)
d364 2
a365 1
sdbm_firstkey(register DBM *db)
d383 2
a384 1
sdbm_nextkey(register DBM *db)
d395 3
a397 1
getpage(register DBM *db, register long int hash)
d436 3
a438 1
getdbit(register DBM *db, register long int dbit)
d459 3
a461 1
setdbit(register DBM *db, register long int dbit)
a469 1
		(void) memset(db->dirbuf, 0, DBLKSIZ);
d495 2
a496 1
getnext(register DBM *db)
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a11 3
#ifdef WIN32
#include "io.h"
#endif
d39 1
a39 1

d128 1
a128 1
#if defined(OS2) || defined(MSDOS) || defined(WIN32) || defined(__CYGWIN__)
a184 12
sdbm_exists(register DBM *db, datum key)
{
	if (db == NULL || bad(key))
		return errno = EINVAL, -1;

	if (getpage(db, exhash(key)))
		return exipair(db->pagbuf, key);

	return ioerr(db), -1;
}

int
a418 1
		int got;
d420 1
a420 1
		    || (got=read(db->dirf, db->dirbuf, DBLKSIZ)) < 0)
a421 2
		if (got==0) 
			memset(db->dirbuf,0,DBLKSIZ);
d440 1
a440 1
		int got;
d442 1
a442 1
		    || (got=read(db->dirf, db->dirbuf, DBLKSIZ)) < 0)
a443 2
		if (got==0) 
			memset(db->dirbuf,0,DBLKSIZ);
a450 1
#if 0
a452 4
#else
	if (OFF_DIR((dirb+1))*BYTESIZ > db->maxbno) 
		db->maxbno=OFF_DIR((dirb+1))*BYTESIZ;
#endif
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a285 4
#if defined(DOSISH) || defined(WIN32)
	char zer[PBLKSIZ];
	long oldtail;
#endif
a307 17

#if defined(DOSISH) || defined(WIN32)
		/*
		 * Fill hole with 0 if made it.
		 * (hole is NOT read as 0)
		 */
		oldtail = lseek(db->pagf, 0L, SEEK_END);
		memset(zer, 0, PBLKSIZ);
		while (OFF_PAG(newp) > oldtail) {
			if (lseek(db->pagf, 0L, SEEK_END) < 0 ||
			    write(db->pagf, zer, PBLKSIZ) < 0) {

				return 0;
			}
			oldtail += PBLKSIZ;
		}
#endif
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a38 1
#endif
d42 2
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d27 1
a27 3
# ifndef __ultrix__
#  include <string.h>
# endif
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@a38 1
#ifndef errno
a39 1
#endif
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d39 1
d41 1
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d37 5
a41 3

#include <errno.h> /* See notes in perl.h about avoiding
			extern int errno; */
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d63 1
a63 1
static const long masks[] = {
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d80 1
a80 3
	size_t filelen;
	const size_t dirfext_len = sizeof(DIRFEXT "");
	const size_t pagfext_len = sizeof(PAGFEXT "");
d87 1
a87 1
	filelen = strlen(file);
d89 1
a89 2
	if ((dirname = (char *) malloc(filelen + dirfext_len + 1
				       + filelen + pagfext_len + 1)) == NULL)
d94 3
a96 5
	memcpy(dirname, file, filelen);
	memcpy(dirname + filelen, DIRFEXT, dirfext_len + 1);
	pagname = dirname + filelen + dirfext_len + 1;
	memcpy(pagname, file, filelen);
	memcpy(pagname + filelen, PAGFEXT, pagfext_len + 1);
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d81 2
a82 2
	const size_t dirfext_size = sizeof(DIRFEXT "");
	const size_t pagfext_size = sizeof(PAGFEXT "");
d87 1
a87 1
 * need space for two separate filenames
d91 2
a92 2
	if ((dirname = (char *) malloc(filelen + dirfext_size
				       + filelen + pagfext_size)) == NULL)
d98 2
a99 2
	memcpy(dirname + filelen, DIRFEXT, dirfext_size);
	pagname = dirname + filelen + dirfext_size;
d101 1
a101 1
	memcpy(pagname + filelen, PAGFEXT, pagfext_size);
d309 1
a309 1
 * write delay, read avoidance/cache shuffle:
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a39 3
#ifdef __cplusplus
extern "C" {
#endif
a43 4
#ifdef __cplusplus
}
#endif

d75 1
a75 1
sdbm_open(char *file, int flags, int mode)
d77 3
a79 3
	DBM *db;
	char *dirname;
	char *pagname;
d111 1
a111 1
	DBM *db;
d168 1
a168 1
sdbm_close(DBM *db)
d180 1
a180 1
sdbm_fetch(DBM *db, datum key)
d192 1
a192 1
sdbm_exists(DBM *db, datum key)
d204 1
a204 1
sdbm_delete(DBM *db, datum key)
d228 1
a228 1
sdbm_store(DBM *db, datum key, datum val, int flags)
d231 1
a231 1
	long hash;
d286 1
a286 1
makroom(DBM *db, long int hash, int need)
d296 1
a296 1
	int smax = SPLTMAX;
d382 1
a382 1
sdbm_firstkey(DBM *db)
d400 1
a400 1
sdbm_nextkey(DBM *db)
d411 1
a411 1
getpage(DBM *db, long int hash)
d413 3
a415 3
	int hbit;
	long dbit;
	long pagb;
d450 1
a450 1
getdbit(DBM *db, long int dbit)
d452 2
a453 2
	long c;
	long dirb;
d474 1
a474 1
setdbit(DBM *db, long int dbit)
d476 2
a477 2
	long c;
	long dirb;
d516 1
a516 1
getnext(DBM *db)
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@a303 3
#ifdef BADMESS
	int rc;
#endif
d378 1
a378 4
	rc = write(2, "sdbm: cannot insert after SPLTMAX attempts.\n", 44);
	/* PERL_UNUSED_VAR() or PERL_UNUSED_RESULT() would be
	 * useful here but that would mean pulling in perl.h */
	(void)rc;
@


