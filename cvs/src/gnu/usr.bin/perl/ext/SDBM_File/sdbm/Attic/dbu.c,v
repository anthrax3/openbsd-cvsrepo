head	1.2;
access;
symbols
	OPENBSD_6_0:1.1.1.4.0.12
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.6
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.8
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.4.0.4
	OPENBSD_5_6_BASE:1.1.1.4
	PERL_5_18_2:1.1.1.4
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.3.0.60
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.56
	OPENBSD_5_4_BASE:1.1.1.3
	PERL_5_16_3:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.54
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.52
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.50
	OPENBSD_5_0:1.1.1.3.0.48
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.46
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.44
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.40
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.42
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.38
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.36
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.34
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.32
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.30
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.28
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.26
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.24
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.22
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.20
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.18
	OPENBSD_3_5_BASE:1.1.1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.16
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.14
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.12
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.10
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.8
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.3.0.6
	OPENBSD_2_9_BASE:1.1.1.3
	OPENBSD_2_8:1.1.1.3.0.4
	OPENBSD_2_8_BASE:1.1.1.3
	OPENBSD_2_7:1.1.1.3.0.2
	OPENBSD_2_7_BASE:1.1.1.3
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.1.1.2.0.2
	OPENBSD_2_6_BASE:1.1.1.2
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2017.02.05.00.32.14;	author afresh1;	state dead;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	96.08.19.10.12.12;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.12;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.38.59;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.22;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.03.24.14.59.02;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#include <stdio.h>
#include <sys/file.h>
#ifdef SDBM
#include "sdbm.h"
#else
#include <ndbm.h>
#endif
#include <string.h>

#ifdef BSD42
#define strchr	index
#endif

extern int	getopt();
extern char	*strchr();
extern void	oops();

char *progname;

static int rflag;
static char *usage = "%s [-R] cat | look |... dbmname";

#define DERROR	0
#define DLOOK	1
#define DINSERT	2
#define DDELETE 3
#define	DCAT	4
#define DBUILD	5
#define DPRESS	6
#define DCREAT	7

#define LINEMAX	8192

typedef struct {
	char *sname;
	int scode;
	int flags;
} cmd;

static cmd cmds[] = {

	"fetch", DLOOK, 	O_RDONLY,
	"get", DLOOK,		O_RDONLY,
	"look", DLOOK,		O_RDONLY,
	"add", DINSERT,		O_RDWR,
	"insert", DINSERT,	O_RDWR,
	"store", DINSERT,	O_RDWR,
	"delete", DDELETE,	O_RDWR,
	"remove", DDELETE,	O_RDWR,
	"dump", DCAT,		O_RDONLY,
	"list", DCAT, 		O_RDONLY,
	"cat", DCAT,		O_RDONLY,
	"creat", DCREAT,	O_RDWR | O_CREAT | O_TRUNC,
	"new", DCREAT,		O_RDWR | O_CREAT | O_TRUNC,
	"build", DBUILD,	O_RDWR | O_CREAT,
	"squash", DPRESS,	O_RDWR,
	"compact", DPRESS,	O_RDWR,
	"compress", DPRESS,	O_RDWR
};

#define CTABSIZ (sizeof (cmds)/sizeof (cmd))

static cmd *parse();
static void badk(), doit(), prdatum();

int
main(argc, argv)
int	argc;
char *argv[];
{
	int c;
	register cmd *act;
	extern int optind;
	extern char *optarg;

	progname = argv[0];

	while ((c = getopt(argc, argv, "R")) != EOF)
		switch (c) {
		case 'R':	       /* raw processing  */
			rflag++;
			break;

		default:
			oops("usage: %s", usage);
			break;
		}

	if ((argc -= optind) < 2)
		oops("usage: %s", usage);

	if ((act = parse(argv[optind])) == NULL)
		badk(argv[optind]);
	optind++;
	doit(act, argv[optind]);
	return 0;
}

static void
doit(act, file)
register cmd *act;
char *file;
{
	datum key;
	datum val;
	register DBM *db;
	register char *op;
	register int n;
	char *line;
#ifdef TIME
	long start;
	extern long time();
#endif

	if ((db = dbm_open(file, act->flags, 0644)) == NULL)
		oops("cannot open: %s", file);

	if ((line = (char *) malloc(LINEMAX)) == NULL)
		oops("%s: cannot get memory", "line alloc");

	switch (act->scode) {

	case DLOOK:
		while (fgets(line, LINEMAX, stdin) != NULL) {
			n = strlen(line) - 1;
			line[n] = 0;
			key.dptr = line;
			key.dsize = n;
			val = dbm_fetch(db, key);
			if (val.dptr != NULL) {
				prdatum(stdout, val);
				putchar('\n');
				continue;
			}
			prdatum(stderr, key);
			fprintf(stderr, ": not found.\n");
		}
		break;
	case DINSERT:
		break;
	case DDELETE:
		while (fgets(line, LINEMAX, stdin) != NULL) {
			n = strlen(line) - 1;
			line[n] = 0;
			key.dptr = line;
			key.dsize = n;
			if (dbm_delete(db, key) == -1) {
				prdatum(stderr, key);
				fprintf(stderr, ": not found.\n");
			}
		}
		break;
	case DCAT:
		for (key = dbm_firstkey(db); key.dptr != 0; 
		     key = dbm_nextkey(db)) {
			prdatum(stdout, key);
			putchar('\t');
			prdatum(stdout, dbm_fetch(db, key));
			putchar('\n');
		}
		break;
	case DBUILD:
#ifdef TIME
		start = time(0);
#endif
		while (fgets(line, LINEMAX, stdin) != NULL) {
			n = strlen(line) - 1;
			line[n] = 0;
			key.dptr = line;
			if ((op = strchr(line, '\t')) != 0) {
				key.dsize = op - line;
				*op++ = 0;
				val.dptr = op;
				val.dsize = line + n - op;
			}
			else
				oops("bad input; %s", line);
	
			if (dbm_store(db, key, val, DBM_REPLACE) < 0) {
				prdatum(stderr, key);
				fprintf(stderr, ": ");
				oops("store: %s", "failed");
			}
		}
#ifdef TIME
		printf("done: %d seconds.\n", time(0) - start);
#endif
		break;
	case DPRESS:
		break;
	case DCREAT:
		break;
	}

	dbm_close(db);
}

static void
badk(word)
char *word;
{
	register int i;

	if (progname)
		fprintf(stderr, "%s: ", progname);
	fprintf(stderr, "bad keywd %s. use one of\n", word);
	for (i = 0; i < (int)CTABSIZ; i++)
		fprintf(stderr, "%-8s%c", cmds[i].sname,
			((i + 1) % 6 == 0) ? '\n' : ' ');
	fprintf(stderr, "\n");
	exit(1);
	/*NOTREACHED*/
}

static cmd *
parse(str)
register char *str;
{
	register int i = CTABSIZ;
	register cmd *p;
	
	for (p = cmds; i--; p++)
		if (strcmp(p->sname, str) == 0)
			return p;
	return NULL;
}

static void
prdatum(stream, d)
FILE *stream;
datum d;
{
	register int c;
	register char *p = d.dptr;
	register int n = d.dsize;

	while (n--) {
		c = *p++ & 0377;
		if (c & 0200) {
			fprintf(stream, "M-");
			c &= 0177;
		}
		if (c == 0177 || c < ' ') 
			fprintf(stream, "^%c", (c == 0177) ? '?' : c + '@@');
		else
			putc(c, stream);
	}
}


@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a3 1
#include "EXTERN.h"
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d68 3
a70 1
main(int argc, char **argv)
d101 3
a103 1
doit(register cmd *act, char *file)
d200 2
a201 1
badk(char *word)
d217 2
a218 1
parse(register char *str)
d230 3
a232 1
prdatum(FILE *stream, datum d)
@


1.1.1.4
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d71 1
a71 1
	cmd *act;
d99 1
a99 1
doit(cmd *act, char *file)
d103 3
a105 3
	DBM *db;
	char *op;
	int n;
d198 1
a198 1
	int i;
d212 1
a212 1
parse(char *str)
d214 2
a215 2
	int i = CTABSIZ;
	cmd *p;
d226 3
a228 3
	int c;
	char *p = d.dptr;
	int n = d.dsize;
@


