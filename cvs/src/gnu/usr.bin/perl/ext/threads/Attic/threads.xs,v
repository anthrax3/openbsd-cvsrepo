head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.7.0.4
	OPENBSD_4_8_BASE:1.1.1.7
	OPENBSD_4_7:1.1.1.7.0.2
	OPENBSD_4_7_BASE:1.1.1.7
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.1.1.6.0.6
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.2
	OPENBSD_4_5_BASE:1.1.1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.6
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.4
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.2
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.31;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.46.35;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.01.15.21.17.02;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.22;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.26;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.11.18;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#ifdef USE_ITHREADS

#ifdef WIN32
#include <windows.h>
#include <win32thread.h>
#define PERL_THREAD_SETSPECIFIC(k,v) TlsSetValue(k,v)
#define PERL_THREAD_GETSPECIFIC(k,v) v = TlsGetValue(k)
#define PERL_THREAD_ALLOC_SPECIFIC(k) \
STMT_START {\
  if((k = TlsAlloc()) == TLS_OUT_OF_INDEXES) {\
    PerlIO_printf(PerlIO_stderr(),"panic threads.h: TlsAlloc");\
    exit(1);\
  }\
} STMT_END
#else
#include <pthread.h>
#include <thread.h>

#define PERL_THREAD_SETSPECIFIC(k,v) pthread_setspecific(k,v)
#ifdef OLD_PTHREADS_API
#define PERL_THREAD_DETACH(t) pthread_detach(&(t))
#define PERL_THREAD_GETSPECIFIC(k,v) pthread_getspecific(k,&v)
#define PERL_THREAD_ALLOC_SPECIFIC(k) STMT_START {\
  if(pthread_keycreate(&(k),0)) {\
    PerlIO_printf(PerlIO_stderr(), "panic threads.h: pthread_key_create");\
    exit(1);\
  }\
} STMT_END
#else
#define PERL_THREAD_DETACH(t) pthread_detach((t))
#define PERL_THREAD_GETSPECIFIC(k,v) v = pthread_getspecific(k)
#define PERL_THREAD_ALLOC_SPECIFIC(k) STMT_START {\
  if(pthread_key_create(&(k),0)) {\
    PerlIO_printf(PerlIO_stderr(), "panic threads.h: pthread_key_create");\
    exit(1);\
  }\
} STMT_END
#endif
#endif

/* Values for 'state' member */
#define PERL_ITHR_JOINABLE		0
#define PERL_ITHR_DETACHED		1
#define PERL_ITHR_FINISHED		4
#define PERL_ITHR_JOINED		2

typedef struct ithread_s {
    struct ithread_s *next;	/* next thread in the list */
    struct ithread_s *prev;	/* prev thread in the list */
    PerlInterpreter *interp;	/* The threads interpreter */
    I32 tid;              	/* threads module's thread id */
    perl_mutex mutex; 		/* mutex for updating things in this struct */
    I32 count;			/* how many SVs have a reference to us */
    signed char state;		/* are we detached ? */
    int gimme;			/* Context of create */
    SV* init_function;          /* Code to run */
    SV* params;                 /* args to pass function */
#ifdef WIN32
	DWORD	thr;            /* OS's idea if thread id */
	HANDLE handle;          /* OS's waitable handle */
#else
  	pthread_t thr;          /* OS's handle for the thread */
#endif
} ithread;

ithread *threads;

/* Macros to supply the aTHX_ in an embed.h like manner */
#define ithread_join(thread)		Perl_ithread_join(aTHX_ thread)
#define ithread_DESTROY(thread)		Perl_ithread_DESTROY(aTHX_ thread)
#define ithread_CLONE(thread)		Perl_ithread_CLONE(aTHX_ thread)
#define ithread_detach(thread)		Perl_ithread_detach(aTHX_ thread)
#define ithread_tid(thread)		((thread)->tid)
#define ithread_yield(thread)		(YIELD);

static perl_mutex create_destruct_mutex;  /* protects the creation and destruction of threads*/

I32 tid_counter = 0;
I32 known_threads = 0;
I32 active_threads = 0;
perl_key self_key;

/*
 *  Clear up after thread is done with
 */
void
Perl_ithread_destruct (pTHX_ ithread* thread, const char *why)
{
        PerlInterpreter* destroyperl = NULL;        
	MUTEX_LOCK(&thread->mutex);
	if (!thread->next) {
	    Perl_croak(aTHX_ "panic: destruct destroyed thread %p (%s)",thread, why);
	}
	if (thread->count != 0) {
		MUTEX_UNLOCK(&thread->mutex);
		return;
	}
	MUTEX_LOCK(&create_destruct_mutex);
	/* Remove from circular list of threads */
	if (thread->next == thread) {
	    /* last one should never get here ? */
	    threads = NULL;
        }
	else {
	    thread->next->prev = thread->prev;
	    thread->prev->next = thread->next;
	    if (threads == thread) {
		threads = thread->next;
	    }
	    thread->next = NULL;
	    thread->prev = NULL;
	}
	known_threads--;
	assert( known_threads >= 0 );
#if 0
        Perl_warn(aTHX_ "destruct %d @@ %p by %p now %d",
	          thread->tid,thread->interp,aTHX, known_threads);
#endif
	MUTEX_UNLOCK(&create_destruct_mutex);
	/* Thread is now disowned */
	if (thread->interp) {
	    dTHXa(thread->interp);
	    PERL_SET_CONTEXT(thread->interp);
	    SvREFCNT_dec(thread->params);
	    thread->params = Nullsv;
	    destroyperl = thread->interp;
	    thread->interp = NULL;
	}
	MUTEX_UNLOCK(&thread->mutex);
	MUTEX_DESTROY(&thread->mutex);
        PerlMemShared_free(thread);
	if(destroyperl) {
	    perl_destruct(destroyperl);
            perl_free(destroyperl);
	}
	PERL_SET_CONTEXT(aTHX);
}

int
Perl_ithread_hook(pTHX)
{
    int veto_cleanup = 0;
    MUTEX_LOCK(&create_destruct_mutex);
    if (aTHX == PL_curinterp && active_threads != 1) {
	Perl_warn(aTHX_ "A thread exited while %" IVdf " other threads were still running",
						(IV)active_threads);
	veto_cleanup = 1;
    }
    MUTEX_UNLOCK(&create_destruct_mutex);
    return veto_cleanup;
}

void
Perl_ithread_detach(pTHX_ ithread *thread)
{
    MUTEX_LOCK(&thread->mutex);
    if (!(thread->state & (PERL_ITHR_DETACHED|PERL_ITHR_JOINED))) {
	thread->state |= PERL_ITHR_DETACHED;
#ifdef WIN32
	CloseHandle(thread->handle);
	thread->handle = 0;
#else
	PERL_THREAD_DETACH(thread->thr);
#endif
    }
    if ((thread->state & PERL_ITHR_FINISHED) &&
        (thread->state & PERL_ITHR_DETACHED)) {
	MUTEX_UNLOCK(&thread->mutex);
	Perl_ithread_destruct(aTHX_ thread, "detach");
    }
    else {
	MUTEX_UNLOCK(&thread->mutex);
    }
}

/* MAGIC (in mg.h sense) hooks */

int
ithread_mg_get(pTHX_ SV *sv, MAGIC *mg)
{
    ithread *thread = (ithread *) mg->mg_ptr;
    SvIVX(sv) = PTR2IV(thread);
    SvIOK_on(sv);
    return 0;
}

int
ithread_mg_free(pTHX_ SV *sv, MAGIC *mg)
{
    ithread *thread = (ithread *) mg->mg_ptr;
    MUTEX_LOCK(&thread->mutex);
    thread->count--;
    if (thread->count == 0) {
       if(thread->state & PERL_ITHR_FINISHED &&
          (thread->state & PERL_ITHR_DETACHED ||
           thread->state & PERL_ITHR_JOINED))
       {
            MUTEX_UNLOCK(&thread->mutex);
            Perl_ithread_destruct(aTHX_ thread, "no reference");
       }
       else {
	    MUTEX_UNLOCK(&thread->mutex);
       }    
    }
    else {
	MUTEX_UNLOCK(&thread->mutex);
    }
    return 0;
}

int
ithread_mg_dup(pTHX_ MAGIC *mg, CLONE_PARAMS *param)
{
    ithread *thread = (ithread *) mg->mg_ptr;
    MUTEX_LOCK(&thread->mutex);
    thread->count++;
    MUTEX_UNLOCK(&thread->mutex);
    return 0;
}

MGVTBL ithread_vtbl = {
 ithread_mg_get,	/* get */
 0,			/* set */
 0,			/* len */
 0,			/* clear */
 ithread_mg_free,	/* free */
 0,			/* copy */
 ithread_mg_dup		/* dup */
};


/*
 *	Starts executing the thread. Needs to clean up memory a tad better.
 *      Passed as the C level function to run in the new thread
 */

#ifdef WIN32
THREAD_RET_TYPE
Perl_ithread_run(LPVOID arg) {
#else
void*
Perl_ithread_run(void * arg) {
#endif
	ithread* thread = (ithread*) arg;
	dTHXa(thread->interp);
	PERL_SET_CONTEXT(thread->interp);
	PERL_THREAD_SETSPECIFIC(self_key,thread);

#if 0
	/* Far from clear messing with ->thr child-side is a good idea */
	MUTEX_LOCK(&thread->mutex);
#ifdef WIN32
	thread->thr = GetCurrentThreadId();
#else
	thread->thr = pthread_self();
#endif
 	MUTEX_UNLOCK(&thread->mutex);
#endif

	PL_perl_destruct_level = 2;

	{
		AV* params = (AV*) SvRV(thread->params);
		I32 len = av_len(params)+1;
		int i;
		dSP;
		ENTER;
		SAVETMPS;
		PUSHMARK(SP);
		for(i = 0; i < len; i++) {
		    XPUSHs(av_shift(params));
		}
		PUTBACK;
		len = call_sv(thread->init_function, thread->gimme|G_EVAL);
		SPAGAIN;
		for (i=len-1; i >= 0; i--) {
		  SV *sv = POPs;
		  av_store(params, i, SvREFCNT_inc(sv));
		}
		PUTBACK;
		if (SvTRUE(ERRSV)) {
		    Perl_warn(aTHX_ "thread failed to start: %" SVf, ERRSV);
		}
		FREETMPS;
		LEAVE;
		SvREFCNT_dec(thread->init_function);
	}

	PerlIO_flush((PerlIO*)NULL);
	MUTEX_LOCK(&thread->mutex);
	thread->state |= PERL_ITHR_FINISHED;

	if (thread->state & PERL_ITHR_DETACHED) {
		MUTEX_UNLOCK(&thread->mutex);
		Perl_ithread_destruct(aTHX_ thread, "detached finish");
	} else {
		MUTEX_UNLOCK(&thread->mutex);
	}
	MUTEX_LOCK(&create_destruct_mutex);
	active_threads--;
	assert( active_threads >= 0 );
	MUTEX_UNLOCK(&create_destruct_mutex);

#ifdef WIN32
	return (DWORD)0;
#else
	return 0;
#endif
}

SV *
ithread_to_SV(pTHX_ SV *obj, ithread *thread, char *classname, bool inc)
{
    SV *sv;
    MAGIC *mg;
    if (inc) {
	MUTEX_LOCK(&thread->mutex);
	thread->count++;
	MUTEX_UNLOCK(&thread->mutex);
    }
    if (!obj)
     obj = newSV(0);
    sv = newSVrv(obj,classname);
    sv_setiv(sv,PTR2IV(thread));
    mg = sv_magicext(sv,Nullsv,PERL_MAGIC_shared_scalar,&ithread_vtbl,(char *)thread,0);
    mg->mg_flags |= MGf_DUP;
    SvREADONLY_on(sv);
    return obj;
}

ithread *
SV_to_ithread(pTHX_ SV *sv)
{
    ithread *thread;
    if (SvROK(sv))
     {
      thread = INT2PTR(ithread*, SvIV(SvRV(sv)));
     }
    else
     {
      PERL_THREAD_GETSPECIFIC(self_key,thread);
     }
    return thread;
}

/*
 * iThread->create(); ( aka iThread->new() )
 * Called in context of parent thread
 */

SV *
Perl_ithread_create(pTHX_ SV *obj, char* classname, SV* init_function, SV* params)
{
	ithread*	thread;
	CLONE_PARAMS	clone_param;

	MUTEX_LOCK(&create_destruct_mutex);
	thread = PerlMemShared_malloc(sizeof(ithread));
	Zero(thread,1,ithread);
	thread->next = threads;
	thread->prev = threads->prev;
	threads->prev = thread;
	thread->prev->next = thread;
	/* Set count to 1 immediately in case thread exits before
	 * we return to caller !
	 */
	thread->count = 1;
	MUTEX_INIT(&thread->mutex);
	thread->tid = tid_counter++;
	thread->gimme = GIMME_V;

	/* "Clone" our interpreter into the thread's interpreter
	 * This gives thread access to "static data" and code.
	 */

	PerlIO_flush((PerlIO*)NULL);

#ifdef WIN32
	thread->interp = perl_clone(aTHX, CLONEf_KEEP_PTR_TABLE | CLONEf_CLONE_HOST);
#else
	thread->interp = perl_clone(aTHX, CLONEf_KEEP_PTR_TABLE);
#endif
	/* perl_clone leaves us in new interpreter's context.
	   As it is tricky to spot implcit aTHX create a new scope
	   with aTHX matching the context for the duration of
	   our work for new interpreter.
	 */
	{
	    dTHXa(thread->interp);
            /* Here we remove END blocks since they should only run
	       in the thread they are created
            */
            SvREFCNT_dec(PL_endav);
            PL_endav = newAV();
            clone_param.flags = 0;
	    thread->init_function = sv_dup(init_function, &clone_param);
	    if (SvREFCNT(thread->init_function) == 0) {
		SvREFCNT_inc(thread->init_function);
	    }

	    thread->params = sv_dup(params, &clone_param);
	    SvREFCNT_inc(thread->params);
	    SvTEMP_off(thread->init_function);
	    ptr_table_free(PL_ptr_table);
	    PL_ptr_table = NULL;
	    PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
	}

	PERL_SET_CONTEXT(aTHX);

	/* Start the thread */

#ifdef WIN32

	thread->handle = CreateThread(NULL, 0, Perl_ithread_run,
			(LPVOID)thread, 0, &thread->thr);

#else
	{
	  static pthread_attr_t attr;
	  static int attr_inited = 0;
	  static int attr_joinable = PTHREAD_CREATE_JOINABLE;
	  if (!attr_inited) {
	    attr_inited = 1;
	    pthread_attr_init(&attr);
	  }
#  ifdef PTHREAD_ATTR_SETDETACHSTATE
            PTHREAD_ATTR_SETDETACHSTATE(&attr, attr_joinable);
#  endif
#  ifdef THREAD_CREATE_NEEDS_STACK
	    if(pthread_attr_setstacksize(&attr, THREAD_CREATE_NEEDS_STACK))
	      croak("panic: pthread_attr_setstacksize failed");
#  endif

#ifdef OLD_PTHREADS_API
	  pthread_create( &thread->thr, attr, Perl_ithread_run, (void *)thread);
#else
	  pthread_create( &thread->thr, &attr, Perl_ithread_run, (void *)thread);
#endif
	}
#endif
	known_threads++;
	active_threads++;
	MUTEX_UNLOCK(&create_destruct_mutex);
	sv_2mortal(params);
	return ithread_to_SV(aTHX_ obj, thread, classname, FALSE);
}

SV*
Perl_ithread_self (pTHX_ SV *obj, char* Class)
{
    ithread *thread;
    PERL_THREAD_GETSPECIFIC(self_key,thread);
    return ithread_to_SV(aTHX_ obj, thread, Class, TRUE);
}

/*
 * Joins the thread this code needs to take the returnvalue from the
 * call_sv and send it back
 */

void
Perl_ithread_CLONE(pTHX_ SV *obj)
{
 if (SvROK(obj))
  {
   ithread *thread = SV_to_ithread(aTHX_ obj);
  }
 else
  {
   Perl_warn(aTHX_ "CLONE %" SVf,obj);
  }
}

AV*
Perl_ithread_join(pTHX_ SV *obj)
{
    ithread *thread = SV_to_ithread(aTHX_ obj);
    MUTEX_LOCK(&thread->mutex);
    if (thread->state & PERL_ITHR_DETACHED) {
	MUTEX_UNLOCK(&thread->mutex);
	Perl_croak(aTHX_ "Cannot join a detached thread");
    }
    else if (thread->state & PERL_ITHR_JOINED) {
	MUTEX_UNLOCK(&thread->mutex);
	Perl_croak(aTHX_ "Thread already joined");
    }
    else {
        AV* retparam;
#ifdef WIN32
	DWORD waitcode;
#else
	void *retval;
#endif
	MUTEX_UNLOCK(&thread->mutex);
#ifdef WIN32
	waitcode = WaitForSingleObject(thread->handle, INFINITE);
#else
	pthread_join(thread->thr,&retval);
#endif
	MUTEX_LOCK(&thread->mutex);
	
	/* sv_dup over the args */
	{
	  AV* params = (AV*) SvRV(thread->params);	
	  CLONE_PARAMS clone_params;
	  clone_params.stashes = newAV();
	  PL_ptr_table = ptr_table_new();
	  retparam = (AV*) sv_dup((SV*)params, &clone_params);
	  SvREFCNT_dec(clone_params.stashes);
	  SvREFCNT_inc(retparam);
	  ptr_table_free(PL_ptr_table);
	  PL_ptr_table = NULL;

	}
	/* We have finished with it */
	thread->state |= PERL_ITHR_JOINED;
	MUTEX_UNLOCK(&thread->mutex);
    	sv_unmagic(SvRV(obj),PERL_MAGIC_shared_scalar);
	return retparam;
    }
    return (AV*)NULL;
}

void
Perl_ithread_DESTROY(pTHX_ SV *sv)
{
    ithread *thread = SV_to_ithread(aTHX_ sv);
    sv_unmagic(SvRV(sv),PERL_MAGIC_shared_scalar);
}

#endif /* USE_ITHREADS */

MODULE = threads		PACKAGE = threads	PREFIX = ithread_
PROTOTYPES: DISABLE

#ifdef USE_ITHREADS

void
ithread_new (classname, function_to_call, ...)
char *	classname
SV *	function_to_call
CODE:
{
    AV* params = newAV();
    if (items > 2) {
	int i;
	for(i = 2; i < items ; i++) {
	    av_push(params, SvREFCNT_inc(ST(i)));
	}
    }
    ST(0) = sv_2mortal(Perl_ithread_create(aTHX_ Nullsv, classname, function_to_call, newRV_noinc((SV*) params)));
    XSRETURN(1);
}

void
ithread_list(char *classname)
PPCODE:
{
  ithread *curr_thread;
  MUTEX_LOCK(&create_destruct_mutex);
  curr_thread = threads;
  if(curr_thread->tid != 0)	
    PUSHs( sv_2mortal(ithread_to_SV(aTHX_ NULL, curr_thread, classname, TRUE)));
  while(curr_thread) {
    curr_thread = curr_thread->next;
    if(curr_thread == threads)
      break;
    if(curr_thread->state & PERL_ITHR_DETACHED ||
       curr_thread->state & PERL_ITHR_JOINED)
         continue;
     PUSHs( sv_2mortal(ithread_to_SV(aTHX_ NULL, curr_thread, classname, TRUE)));
  }	
  MUTEX_UNLOCK(&create_destruct_mutex);
}


void
ithread_self(char *classname)
CODE:
{
	ST(0) = sv_2mortal(Perl_ithread_self(aTHX_ Nullsv,classname));
	XSRETURN(1);
}

int
ithread_tid(ithread *thread)

void
ithread_join(SV *obj)
PPCODE:
{
  AV* params = Perl_ithread_join(aTHX_ obj);
  int i;
  I32 len = AvFILL(params);
  for (i = 0; i <= len; i++) {
    SV* tmp = av_shift(params);
    XPUSHs(tmp);
    sv_2mortal(tmp);
  }
  SvREFCNT_dec(params);
}

void
yield(...)
CODE:
{
    YIELD;
}
	

void
ithread_detach(ithread *thread)

void
ithread_DESTROY(SV *thread)

#endif /* USE_ITHREADS */

BOOT:
{
#ifdef USE_ITHREADS
	ithread* thread;
	PL_perl_destruct_level = 2;
	PERL_THREAD_ALLOC_SPECIFIC(self_key);
	MUTEX_INIT(&create_destruct_mutex);
	MUTEX_LOCK(&create_destruct_mutex);
	PL_threadhook = &Perl_ithread_hook;
	thread  = PerlMemShared_malloc(sizeof(ithread));
	Zero(thread,1,ithread);
	PL_perl_destruct_level = 2;
	MUTEX_INIT(&thread->mutex);
	threads = thread;
	thread->next = thread;
        thread->prev = thread;
	thread->interp = aTHX;
	thread->count  = 1;  /* imortal */
	thread->tid = tid_counter++;
	known_threads++;
	active_threads++;
	thread->state = 1;
#ifdef WIN32
	thread->thr = GetCurrentThreadId();
#else
	thread->thr = pthread_self();
#endif

	PERL_THREAD_SETSPECIFIC(self_key,thread);
	MUTEX_UNLOCK(&create_destruct_mutex);
#endif /* USE_ITHREADS */
}

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@a7 1

d11 9
a19 3
#else
#ifdef OS2
typedef perl_os_thread pthread_t;
a21 1
#endif
d23 1
d27 7
d36 8
a43 1
#endif  /* OLD_PTHREADS_API */
a45 3



d53 2
a54 2
    struct ithread_s *next;	/* Next thread in the list */
    struct ithread_s *prev;	/* Prev thread in the list */
d56 4
a59 4
    I32 tid;              	/* Threads module's thread id */
    perl_mutex mutex; 		/* Mutex for updating things in this struct */
    I32 count;			/* How many SVs have a reference to us */
    signed char state;		/* Are we detached ? */
d62 1
a62 1
    SV* params;                 /* Args to pass function */
d86 1
a86 19


void Perl_ithread_set (pTHX_ ithread* thread)
{
  SV* thread_sv = newSViv(PTR2IV(thread));
  if(!hv_store(PL_modglobal, "threads::self", 12, thread_sv,0)) {
    croak("%s\n","Internal error, couldn't set TLS");
  }
}

ithread* Perl_ithread_get (pTHX) {
  SV** thread_sv = hv_fetch(PL_modglobal, "threads::self",12,0);
  if(!thread_sv) {
    croak("%s\n","Internal error, couldn't get TLS");
  }
  return INT2PTR(ithread*,SvIV(*thread_sv));
}


d94 1
d126 1
a126 2

	if(thread->interp) {
a127 4
	    ithread*        current_thread;
#ifdef OEMVS
	    void *ptr;
#endif
a128 6
	    current_thread = Perl_ithread_get(aTHX);
	    Perl_ithread_set(aTHX_ thread);



	    
a129 3



d131 1
a131 2
	    perl_destruct(thread->interp);
            perl_free(thread->interp);
d137 4
a140 1

d150 1
a150 1
	Perl_warn(aTHX_ "A thread exited while %" IVdf " threads were running",
d252 1
a252 1
	Perl_ithread_set(aTHX_ thread);
a279 1

d285 1
d339 1
d342 1
a342 1
      return INT2PTR(ithread*, SvIV(SvRV(sv)));
d346 1
a346 1
      return Perl_ithread_get(aTHX);
d348 1
d352 1
a352 1
 * ithread->create(); ( aka ithread->new() )
a360 5
	ithread*        current_thread = Perl_ithread_get(aTHX);

	SV**            tmps_tmp = PL_tmps_stack;
	I32             tmps_ix  = PL_tmps_ix;

a381 6
	Perl_ithread_set(aTHX_ thread);

	SAVEBOOL(PL_srand_called); /* Save this so it becomes the correct
	                              value */
	PL_srand_called = FALSE; /* Set it to false so we can detect
	                            if it gets set during the clone */
d389 1
a389 1
	   As it is tricky to spot an implicit aTHX, create a new scope
a394 1

a404 2
	    

a407 31


	    /* The code below checks that anything living on
	       the tmps stack and has been cloned (so it lives in the
	       ptr_table) has a refcount higher than 0

	       If the refcount is 0 it means that a something on the
	       stack/context was holding a reference to it and
	       since we init_stacks() in perl_clone that won't get
	       cleaned and we will get a leaked scalar.
	       The reason it was cloned was that it lived on the
	       @@_ stack.

	       Example of this can be found in bugreport 15837
	       where calls in the parameter list end up as a temp

	       One could argue that this fix should be in perl_clone
	    */
	       

	    while (tmps_ix > 0) { 
	      SV* sv = (SV*)ptr_table_fetch(PL_ptr_table, tmps_tmp[tmps_ix]);
	      tmps_ix--;
	      if (sv && SvREFCNT(sv) == 0) {
		SvREFCNT_inc(sv);
		SvREFCNT_dec(sv);
	      }
	    }
	    


d413 1
a413 1
	Perl_ithread_set(aTHX_ current_thread);
d437 1
a437 1
	      Perl_croak(aTHX_ "panic: pthread_attr_setstacksize failed");
a442 3
#  if defined(HAS_PTHREAD_ATTR_SETSCOPE) && defined(PTHREAD_SCOPE_SYSTEM)
	  pthread_attr_setscope( &attr, PTHREAD_SCOPE_SYSTEM );
#  endif
a450 1

d457 3
a459 6
   ithread *thread = Perl_ithread_get(aTHX);
   if (thread)
	return ithread_to_SV(aTHX_ obj, thread, Class, TRUE);
   else
	Perl_croak(aTHX_ "panic: cannot find thread data");
   return NULL; /* silence compiler warning */
a509 1
	  ithread*        current_thread;
a512 1
	  clone_params.flags |= CLONEf_JOIN_IN;
a513 12
	  current_thread = Perl_ithread_get(aTHX);
	  Perl_ithread_set(aTHX_ thread);

#if 0
	  {
	    I32 len = av_len(params)+1;
	    I32 i;
	    for(i = 0; i < len; i++) {
	      sv_dump(SvRV(AvARRAY(params)[i]));
	    }
	  }
#endif
a514 10
#if 0
	  {
	    I32 len = av_len(retparam)+1;
	    I32 i;
	    for(i = 0; i < len; i++) {
		sv_dump(SvRV(AvARRAY(retparam)[i]));
	    }
	  }
#endif
	  Perl_ithread_set(aTHX_ current_thread);
d521 1
a521 1
	/* We are finished with it */
d524 1
a524 1
    	
d569 1
a569 1
    XPUSHs( sv_2mortal(ithread_to_SV(aTHX_ NULL, curr_thread, classname, TRUE)));
d577 1
a577 1
     XPUSHs( sv_2mortal(ithread_to_SV(aTHX_ NULL, curr_thread, classname, TRUE)));
d630 1
d642 1
a642 1
	thread->count  = 1;  /* Immortal. */
d646 1
a646 1
	thread->state = PERL_ITHR_DETACHED;
d653 1
a653 1
	Perl_ithread_set(aTHX_ thread);
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@a95 1
        PerlInterpreter *freeperl = NULL;
d147 1
a147 1
            freeperl = thread->interp;
a151 5
#ifdef WIN32
	if (thread->handle)
	    CloseHandle(thread->handle);
	thread->handle = 0;
#endif
a152 2
        if (freeperl)
            perl_free(freeperl);
a375 4
#ifndef WIN32
	int		failure;
	const char*	panic = NULL;
#endif
d475 1
d478 1
d493 1
a493 1
	      panic = "panic: pthread_attr_setstacksize failed";
d497 1
a497 3
	    failure
	      = panic ? 1 : pthread_create( &thread->thr, attr,
					    Perl_ithread_run, (void *)thread);
d502 1
a502 3
	  failure
	    = panic ? 1 : pthread_create( &thread->thr, &attr,
					  Perl_ithread_run, (void *)thread);
a506 16
	if (
#ifdef WIN32
	    thread->handle == NULL
#else
	    failure
#endif
	    ) {
	  MUTEX_UNLOCK(&create_destruct_mutex);
	  sv_2mortal(params);
	  Perl_ithread_destruct(aTHX_ thread, "create failed");
#ifndef WIN32
	  if (panic)
	    Perl_croak(aTHX_ panic);
#endif
	  return &PL_sv_undef;
	}
a565 2
	CloseHandle(thread->handle);
	thread->handle = 0;
a574 1
	  PerlInterpreter *other_perl = thread->interp;
a580 4
	  /* ensure 'meaningful' addresses retain their meaning */
	  ptr_table_store(PL_ptr_table, &other_perl->Isv_undef, &PL_sv_undef);
	  ptr_table_store(PL_ptr_table, &other_perl->Isv_no, &PL_sv_no);
	  ptr_table_store(PL_ptr_table, &other_perl->Isv_yes, &PL_sv_yes);
@


1.1.1.4
log
@perl 5.8.6 from CPAN
@
text
@a391 6
	if (!thread) {	
	    MUTEX_UNLOCK(&create_destruct_mutex);
	    PerlLIO_write(PerlIO_fileno(Perl_error_log),
			  PL_no_mem, strlen(PL_no_mem));
	    my_exit(1);
	}
a757 5
	if (!thread) {
	    PerlLIO_write(PerlIO_fileno(Perl_error_log),
			  PL_no_mem, strlen(PL_no_mem));
	    my_exit(1);
	}
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@a88 36
/* free any data (such as the perl interpreter) attached to an
 * ithread structure. This is a bit like undef on SVs, where the SV
 * isn't freed, but the PVX is.
 * Must be called with thread->mutex already held
 */

static void
S_ithread_clear(pTHX_ ithread* thread)
{
    PerlInterpreter *interp;
    assert(thread->state & PERL_ITHR_FINISHED &&
    	    (thread->state & PERL_ITHR_DETACHED ||
	    thread->state & PERL_ITHR_JOINED));

    interp = thread->interp;
    if (interp) {
	dTHXa(interp);
	ithread* current_thread;
#ifdef OEMVS
	void *ptr;
#endif
	PERL_SET_CONTEXT(interp);
	current_thread = Perl_ithread_get(aTHX);
	Perl_ithread_set(aTHX_ thread);
	
	SvREFCNT_dec(thread->params);

	thread->params = Nullsv;
	perl_destruct(interp);
	thread->interp = NULL;
    }
    if (interp)
	perl_free(interp);
    PERL_SET_CONTEXT(aTHX);
}

d91 1
a91 1
 *  free an ithread structure and any attached data if its count == 0
d96 1
a98 1
	    MUTEX_UNLOCK(&thread->mutex);
d129 22
a150 1
	S_ithread_clear(aTHX_ thread);
d159 4
d171 2
a172 3
	if (ckWARN_d(WARN_THREADS))
	    Perl_warn(aTHX_ "A thread exited while %" IVdf " threads were running",
						      (IV)active_threads);
d208 1
a208 1
    SvIV_set(sv, PTR2IV(thread));
d307 1
a307 1
		if (SvTRUE(ERRSV) && ckWARN_d(WARN_THREADS)) {
d391 1
a391 1
	thread = (ithread *) PerlMemShared_malloc(sizeof(ithread));
d569 8
a576 6
    if (SvROK(obj)) {
	ithread *thread = SV_to_ithread(aTHX_ obj);
    }
    else if (ckWARN_d(WARN_THREADS)) {
	Perl_warn(aTHX_ "CLONE %" SVf,obj);
    }
a652 1
	S_ithread_clear(aTHX_ thread);
d763 1
a763 1
	thread  = (ithread *) PerlMemShared_malloc(sizeof(ithread));
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@a4 14
/* Workaround for XSUB.h bug under WIN32 */
#ifdef WIN32
#  undef setjmp
#  if !defined(__BORLANDC__)
#    define setjmp(x) _setjmp(x)
#  endif
#endif
#ifdef HAS_PPPORT_H
#  define NEED_PL_signals
#  define NEED_newRV_noinc
#  define NEED_sv_2pv_flags
#  include "ppport.h"
#  include "threads.h"
#endif
d8 1
d10 2
a11 6
#  include <windows.h>
   /* Supposed to be in Winbase.h */
#  ifndef STACK_SIZE_PARAM_IS_A_RESERVATION
#    define STACK_SIZE_PARAM_IS_A_RESERVATION 0x00010000
#  endif
#  include <win32thread.h>
d13 1
a13 1
#  ifdef OS2
d15 2
a16 10
#  else
#    include <pthread.h>
#  endif
#  include <thread.h>
#  define PERL_THREAD_SETSPECIFIC(k,v) pthread_setspecific(k,v)
#  ifdef OLD_PTHREADS_API
#    define PERL_THREAD_DETACH(t) pthread_detach(&(t))
#  else
#    define PERL_THREAD_DETACH(t) pthread_detach((t))
#  endif
d18 7
a24 2
#if !defined(HAS_GETPAGESIZE) && defined(I_SYS_PARAM)
#  include <sys/param.h>
d27 3
d31 16
a46 21
#define PERL_ITHR_DETACHED           1 /* Thread has been detached */
#define PERL_ITHR_JOINED             2 /* Thread has been joined */
#define PERL_ITHR_FINISHED           4 /* Thread has finished execution */
#define PERL_ITHR_THREAD_EXIT_ONLY   8 /* exit() only exits current thread */
#define PERL_ITHR_NONVIABLE         16 /* Thread creation failed */
#define PERL_ITHR_DIED              32 /* Thread finished by dying */

#define PERL_ITHR_UNCALLABLE  (PERL_ITHR_DETACHED|PERL_ITHR_JOINED)


typedef struct _ithread {
    struct _ithread *next;      /* Next thread in the list */
    struct _ithread *prev;      /* Prev thread in the list */
    PerlInterpreter *interp;    /* The threads interpreter */
    UV tid;                     /* Threads module's thread id */
    perl_mutex mutex;           /* Mutex for updating things in this struct */
    int count;                  /* Reference count. See S_ithread_create. */
    int state;                  /* Detached, joined, finished, etc. */
    int gimme;                  /* Context of create */
    SV *init_function;          /* Code to run */
    SV *params;                 /* Args to pass function */
d48 2
a49 2
    DWORD  thr;                 /* OS's idea if thread id */
    HANDLE handle;              /* OS's waitable handle */
d51 1
a51 1
    pthread_t thr;              /* OS's handle for the thread */
a52 3
    IV stack_size;
    SV *err;                    /* Error from abnormally terminated thread */
    char *err_class;            /* Error object's classname if applicable */
d55 1
d57 7
a63 16
#define MY_CXT_KEY "threads::_cxt" XS_VERSION

typedef struct {
    /* Used by Perl interpreter for thread context switching */
    ithread *context;
} my_cxt_t;

START_MY_CXT


#define MY_POOL_KEY "threads::_pool" XS_VERSION

typedef struct {
    /* Structure for 'main' thread
     * Also forms the 'base' for the doubly-linked list of threads */
    ithread main_thread;
d65 1
a65 2
    /* Protects the creation and destruction of threads*/
    perl_mutex create_destruct_mutex;
d67 3
a69 8
    UV tid_counter;
    IV joinable_threads;
    IV running_threads;
    IV detached_threads;
    IV total_threads;
    IV default_stack_size;
    IV page_size;
} my_pool_t;
a70 4
#define dMY_POOL \
    SV *my_pool_sv = *hv_fetch(PL_modglobal, MY_POOL_KEY,               \
                               sizeof(MY_POOL_KEY)-1, TRUE);            \
    my_pool_t *my_poolp = INT2PTR(my_pool_t*, SvUV(my_pool_sv))
d72 1
a72 6
#define MY_POOL (*my_poolp)


/* Used by Perl interpreter for thread context switching */
STATIC void
S_ithread_set(pTHX_ ithread *thread)
d74 4
a77 2
    dMY_CXT;
    MY_CXT.context = thread;
d80 6
a85 5
STATIC ithread *
S_ithread_get(pTHX)
{
    dMY_CXT;
    return (MY_CXT.context);
d89 4
a92 6
/* Free any data (such as the Perl interpreter) attached to an ithread
 * structure.  This is a bit like undef on SVs, where the SV isn't freed,
 * but the PVX is.  Must be called with thread->mutex already locked.  Also,
 * must be called with MY_POOL.create_destruct_mutex unlocked as destruction
 * of the interpreter can lead to recursive destruction calls that could
 * lead to a deadlock on that mutex.
d94 3
a96 2
STATIC void
S_ithread_clear(pTHX_ ithread *thread)
d99 3
a101 5

    assert(((thread->state & PERL_ITHR_FINISHED) &&
            (thread->state & PERL_ITHR_UNCALLABLE))
                ||
           (thread->state & PERL_ITHR_NONVIABLE));
d105 14
a118 16
        dTHXa(interp);

        PERL_SET_CONTEXT(interp);
        S_ithread_set(aTHX_ thread);

        SvREFCNT_dec(thread->params);
        thread->params = Nullsv;

        if (thread->err) {
            SvREFCNT_dec(thread->err);
            thread->err = Nullsv;
        }

        perl_destruct(interp);
        perl_free(interp);
        thread->interp = NULL;
d120 2
a121 1

d126 2
a127 3
/* Decrement the refcount of an ithread, and if it reaches zero, free it.
 * Must be called with the mutex held.
 * On return, mutex is released (or destroyed).
d129 2
a130 2
STATIC void
S_ithread_free(pTHX_ ithread *thread)
d132 40
a171 2
#ifdef WIN32
    HANDLE handle;
d173 2
a174 1
    dMY_POOL;
d176 10
a185 8
    if (! (thread->state & PERL_ITHR_NONVIABLE)) {
        assert(thread->count > 0);
        if (--thread->count > 0) {
            MUTEX_UNLOCK(&thread->mutex);
            return;
        }
        assert((thread->state & PERL_ITHR_FINISHED) &&
               (thread->state & PERL_ITHR_UNCALLABLE));
d187 3
a189 1
    MUTEX_UNLOCK(&thread->mutex);
d191 3
a193 13
    /* Main thread (0) is immortal and should never get here */
    assert(thread->tid != 0);

    /* Remove from circular list of threads */
    MUTEX_LOCK(&MY_POOL.create_destruct_mutex);
    assert(thread->prev && thread->next);
    thread->next->prev = thread->prev;
    thread->prev->next = thread->next;
    thread->next = NULL;
    thread->prev = NULL;
    MUTEX_UNLOCK(&MY_POOL.create_destruct_mutex);

    /* Thread is now disowned */
d195 2
a196 2
    S_ithread_clear(aTHX_ thread);

d198 4
a201 2
    handle = thread->handle;
    thread->handle = NULL;
a202 6
    MUTEX_UNLOCK(&thread->mutex);
    MUTEX_DESTROY(&thread->mutex);

#ifdef WIN32
    if (handle) {
        CloseHandle(handle);
d204 7
a210 47
#endif

    PerlMemShared_free(thread);

    /* total_threads >= 1 is used to veto cleanup by the main thread,
     * should it happen to exit while other threads still exist.
     * Decrement this as the very last thing in the thread's existence.
     * Otherwise, MY_POOL and global state such as PL_op_mutex may get
     * freed while we're still using it.
     */
    MUTEX_LOCK(&MY_POOL.create_destruct_mutex);
    MY_POOL.total_threads--;
    MUTEX_UNLOCK(&MY_POOL.create_destruct_mutex);
}


static void
S_ithread_count_inc(pTHX_ ithread *thread)
{
    MUTEX_LOCK(&thread->mutex);
    thread->count++;
    MUTEX_UNLOCK(&thread->mutex);
}


/* Warn if exiting with any unjoined threads */
STATIC int
S_exit_warning(pTHX)
{
    int veto_cleanup, warn;
    dMY_POOL;

    MUTEX_LOCK(&MY_POOL.create_destruct_mutex);
    veto_cleanup = (MY_POOL.total_threads > 0);
    warn         = (MY_POOL.running_threads || MY_POOL.joinable_threads);
    MUTEX_UNLOCK(&MY_POOL.create_destruct_mutex);

    if (warn) {
        if (ckWARN_d(WARN_THREADS)) {
            Perl_warn(aTHX_ "Perl exited with active threads:\n\t%"
                            IVdf " running and unjoined\n\t%"
                            IVdf " finished and unjoined\n\t%"
                            IVdf " running and detached\n",
                            MY_POOL.running_threads,
                            MY_POOL.joinable_threads,
                            MY_POOL.detached_threads);
        }
a211 13

    return (veto_cleanup);
}


/* Called from perl_destruct() in each thread.  If it's the main thread,
 * stop it from freeing everything if there are other threads still running.
 */
int
Perl_ithread_hook(pTHX)
{
    dMY_POOL;
    return ((aTHX == MY_POOL.main_thread.interp) ? S_exit_warning(aTHX) : 0);
a213 1

d219 1
a219 1
    ithread *thread = (ithread *)mg->mg_ptr;
d222 1
a222 1
    return (0);
d228 1
a228 1
    ithread *thread = (ithread *)mg->mg_ptr;
d230 17
a246 2
    S_ithread_free(aTHX_ thread);   /* Releases MUTEX */
    return (0);
d252 5
a256 2
    S_ithread_count_inc(aTHX_ (ithread *)mg->mg_ptr);
    return (0);
d260 7
a266 7
    ithread_mg_get,     /* get */
    0,                  /* set */
    0,                  /* len */
    0,                  /* clear */
    ithread_mg_free,    /* free */
    0,                  /* copy */
    ithread_mg_dup      /* dup */
d270 4
a273 59
/* Provided default, minimum and rational stack sizes */
STATIC IV
S_good_stack_size(pTHX_ IV stack_size)
{
    dMY_POOL;

    /* Use default stack size if no stack size specified */
    if (! stack_size) {
        return (MY_POOL.default_stack_size);
    }

#ifdef PTHREAD_STACK_MIN
    /* Can't use less than minimum */
    if (stack_size < PTHREAD_STACK_MIN) {
        if (ckWARN(WARN_THREADS)) {
            Perl_warn(aTHX_ "Using minimum thread stack size of %" IVdf, (IV)PTHREAD_STACK_MIN);
        }
        return (PTHREAD_STACK_MIN);
    }
#endif

    /* Round up to page size boundary */
    if (MY_POOL.page_size <= 0) {
#if defined(HAS_SYSCONF) && (defined(_SC_PAGESIZE) || defined(_SC_MMAP_PAGE_SIZE))
        SETERRNO(0, SS_NORMAL);
#  ifdef _SC_PAGESIZE
        MY_POOL.page_size = sysconf(_SC_PAGESIZE);
#  else
        MY_POOL.page_size = sysconf(_SC_MMAP_PAGE_SIZE);
#  endif
        if ((long)MY_POOL.page_size < 0) {
            if (errno) {
                SV * const error = get_sv("@@", FALSE);
                (void)SvUPGRADE(error, SVt_PV);
                Perl_croak(aTHX_ "PANIC: sysconf: %s", SvPV_nolen(error));
            } else {
                Perl_croak(aTHX_ "PANIC: sysconf: pagesize unknown");
            }
        }
#else
#  ifdef HAS_GETPAGESIZE
        MY_POOL.page_size = getpagesize();
#  else
#    if defined(I_SYS_PARAM) && defined(PAGESIZE)
        MY_POOL.page_size = PAGESIZE;
#    else
        MY_POOL.page_size = 8192;   /* A conservative default */
#    endif
#  endif
        if (MY_POOL.page_size <= 0) {
            Perl_croak(aTHX_ "PANIC: bad pagesize %" IVdf, (IV)MY_POOL.page_size);
        }
#endif
    }
    stack_size = ((stack_size + (MY_POOL.page_size - 1)) / MY_POOL.page_size) * MY_POOL.page_size;

    return (stack_size);
}

a274 3
/* Starts executing the thread.
 * Passed as the C level function to run in the new thread.
 */
d276 2
a277 2
STATIC THREAD_RET_TYPE
S_ithread_run(LPVOID arg)
d279 2
a280 2
STATIC void *
S_ithread_run(void * arg)
d282 59
a340 149
{
    ithread *thread = (ithread *)arg;
    int jmp_rc = 0;
    I32 oldscope;
    int exit_app = 0;   /* Thread terminated using 'exit' */
    int exit_code = 0;
    int died = 0;       /* Thread terminated abnormally */

    dJMPENV;

    dTHXa(thread->interp);

    dMY_POOL;

    /* Blocked until ->create() call finishes */
    MUTEX_LOCK(&thread->mutex);
    MUTEX_UNLOCK(&thread->mutex);

    PERL_SET_CONTEXT(thread->interp);
    S_ithread_set(aTHX_ thread);

    PL_perl_destruct_level = 2;

    {
        AV *params = (AV *)SvRV(thread->params);
        int len = (int)av_len(params)+1;
        int ii;

        dSP;
        ENTER;
        SAVETMPS;

        /* Put args on the stack */
        PUSHMARK(SP);
        for (ii=0; ii < len; ii++) {
            XPUSHs(av_shift(params));
        }
        PUTBACK;

        oldscope = PL_scopestack_ix;
        JMPENV_PUSH(jmp_rc);
        if (jmp_rc == 0) {
            /* Run the specified function */
            len = (int)call_sv(thread->init_function, thread->gimme|G_EVAL);
        } else if (jmp_rc == 2) {
            /* Thread exited */
            exit_app = 1;
            exit_code = STATUS_CURRENT;
            while (PL_scopestack_ix > oldscope) {
                LEAVE;
            }
        }
        JMPENV_POP;

        /* Remove args from stack and put back in params array */
        SPAGAIN;
        for (ii=len-1; ii >= 0; ii--) {
            SV *sv = POPs;
            if (jmp_rc == 0 && (! (thread->gimme & G_VOID))) {
                av_store(params, ii, SvREFCNT_inc(sv));
            }
        }

        FREETMPS;
        LEAVE;

        /* Check for abnormal termination */
        if (SvTRUE(ERRSV)) {
            died = PERL_ITHR_DIED;
            thread->err = newSVsv(ERRSV);
            /* If ERRSV is an object, remember the classname and then
             * rebless into 'main' so it will survive 'cloning'
             */
            if (sv_isobject(thread->err)) {
                thread->err_class = HvNAME(SvSTASH(SvRV(thread->err)));
                sv_bless(thread->err, gv_stashpv("main", 0));
            }

            if (ckWARN_d(WARN_THREADS)) {
                oldscope = PL_scopestack_ix;
                JMPENV_PUSH(jmp_rc);
                if (jmp_rc == 0) {
                    /* Warn that thread died */
                    Perl_warn(aTHX_ "Thread %" UVuf " terminated abnormally: %" SVf, thread->tid, ERRSV);
                } else if (jmp_rc == 2) {
                    /* Warn handler exited */
                    exit_app = 1;
                    exit_code = STATUS_CURRENT;
                    while (PL_scopestack_ix > oldscope) {
                        LEAVE;
                    }
                }
                JMPENV_POP;
            }
        }

        /* Release function ref */
        SvREFCNT_dec(thread->init_function);
        thread->init_function = Nullsv;
    }

    PerlIO_flush((PerlIO *)NULL);

    MUTEX_LOCK(&MY_POOL.create_destruct_mutex);
    MUTEX_LOCK(&thread->mutex);
    /* Mark as finished */
    thread->state |= (PERL_ITHR_FINISHED | died);
    /* Clear exit flag if required */
    if (thread->state & PERL_ITHR_THREAD_EXIT_ONLY) {
        exit_app = 0;
    }

    /* Adjust thread status counts */
    if (thread->state & PERL_ITHR_DETACHED) {
        MY_POOL.detached_threads--;
    } else {
        MY_POOL.running_threads--;
        MY_POOL.joinable_threads++;
    }
    MUTEX_UNLOCK(&thread->mutex);
    MUTEX_UNLOCK(&MY_POOL.create_destruct_mutex);

    /* Exit application if required */
    if (exit_app) {
        oldscope = PL_scopestack_ix;
        JMPENV_PUSH(jmp_rc);
        if (jmp_rc == 0) {
            /* Warn if there are unjoined threads */
            S_exit_warning(aTHX);
        } else if (jmp_rc == 2) {
            /* Warn handler exited */
            exit_code = STATUS_CURRENT;
            while (PL_scopestack_ix > oldscope) {
                LEAVE;
            }
        }
        JMPENV_POP;

        my_exit(exit_code);
    }

    /* At this point, the interpreter may have been freed, so call
     * free in the the context of of the 'main' interpreter which
     * can't have been freed due to the veto_cleanup mechanism.
     */
    aTHX = MY_POOL.main_thread.interp;

    MUTEX_LOCK(&thread->mutex);
    S_ithread_free(aTHX_ thread);   /* Releases MUTEX */
d343 1
a343 1
    return ((DWORD)0);
d345 1
a345 1
    return (0);
d349 2
a350 5

/* Type conversion helper functions */

STATIC SV *
S_ithread_to_SV(pTHX_ SV *obj, ithread *thread, char *classname, bool inc)
d354 10
a363 11

    if (inc)
        S_ithread_count_inc(aTHX_ thread);

    if (! obj) {
        obj = newSV(0);
    }

    sv = newSVrv(obj, classname);
    sv_setiv(sv, PTR2IV(thread));
    mg = sv_magicext(sv, Nullsv, PERL_MAGIC_shared_scalar, &ithread_vtbl, (char *)thread, 0);
d366 1
a366 2

    return (obj);
d369 2
a370 2
STATIC ithread *
S_SV_to_ithread(pTHX_ SV *sv)
d372 8
a379 6
    /* Argument is a thread */
    if (SvROK(sv)) {
      return (INT2PTR(ithread *, SvIV(SvRV(sv))));
    }
    /* Argument is classname, therefore return current thread */
    return (S_ithread_get(aTHX));
d382 4
d387 2
a388 11
/* threads->create()
 * Called in context of parent thread.
 * Called with MY_POOL.create_destruct_mutex locked.  (Unlocked on error.)
 */
STATIC ithread *
S_ithread_create(
        pTHX_ SV *init_function,
        IV        stack_size,
        int       gimme,
        int       exit_opt,
        SV       *params)
d390 3
a392 2
    ithread     *thread;
    ithread     *current_thread = S_ithread_get(aTHX);
d394 2
a395 2
    SV         **tmps_tmp = PL_tmps_stack;
    IV           tmps_ix  = PL_tmps_ix;
d397 2
a398 58
    int          rc_stack_size = 0;
    int          rc_thread_create = 0;
#endif
    dMY_POOL;

    /* Allocate thread structure in context of the main thread's interpreter */
    {
        PERL_SET_CONTEXT(MY_POOL.main_thread.interp);
        thread = (ithread *)PerlMemShared_malloc(sizeof(ithread));
    }
    PERL_SET_CONTEXT(aTHX);
    if (!thread) {
        MUTEX_UNLOCK(&MY_POOL.create_destruct_mutex);
        PerlLIO_write(PerlIO_fileno(Perl_error_log), PL_no_mem, strlen(PL_no_mem));
        my_exit(1);
    }
    Zero(thread, 1, ithread);

    /* Add to threads list */
    thread->next = &MY_POOL.main_thread;
    thread->prev = MY_POOL.main_thread.prev;
    MY_POOL.main_thread.prev = thread;
    thread->prev->next = thread;
    MY_POOL.total_threads++;

    /* 1 ref to be held by the local var 'thread' in S_ithread_run().
     * 1 ref to be held by the threads object that we assume we will
     *      be embedded in upon our return.
     * 1 ref to be the responsibility of join/detach, so we don't get
     *      freed until join/detach, even if no thread objects remain.
     *      This allows the following to work:
     *          { threads->create(sub{...}); } threads->object(1)->join;
     */
    thread->count = 3;

    /* Block new thread until ->create() call finishes */
    MUTEX_INIT(&thread->mutex);
    MUTEX_LOCK(&thread->mutex);

    thread->tid = MY_POOL.tid_counter++;
    thread->stack_size = S_good_stack_size(aTHX_ stack_size);
    thread->gimme = gimme;
    thread->state = exit_opt;

    /* "Clone" our interpreter into the thread's interpreter.
     * This gives thread access to "static data" and code.
     */
    PerlIO_flush((PerlIO *)NULL);
    S_ithread_set(aTHX_ thread);

    SAVEBOOL(PL_srand_called); /* Save this so it becomes the correct value */
    PL_srand_called = FALSE;   /* Set it to false so we can detect if it gets
                                  set during the clone */

#ifdef WIN32
    thread->interp = perl_clone(aTHX, CLONEf_KEEP_PTR_TABLE | CLONEf_CLONE_HOST);
#else
    thread->interp = perl_clone(aTHX, CLONEf_KEEP_PTR_TABLE);
a400 77
    /* perl_clone() leaves us in new interpreter's context.  As it is tricky
     * to spot an implicit aTHX, create a new scope with aTHX matching the
     * context for the duration of our work for new interpreter.
     */
    {
        CLONE_PARAMS clone_param;

        dTHXa(thread->interp);

        MY_CXT_CLONE;

        /* Here we remove END blocks since they should only run in the thread
         * they are created
         */
        SvREFCNT_dec(PL_endav);
        PL_endav = newAV();

        clone_param.flags = 0;
        if (SvPOK(init_function)) {
            thread->init_function = newSV(0);
            sv_copypv(thread->init_function, init_function);
        } else {
            thread->init_function =
		SvREFCNT_inc(sv_dup(init_function, &clone_param));
        }

        thread->params = sv_dup(params, &clone_param);
        SvREFCNT_inc_void(thread->params);

        /* The code below checks that anything living on the tmps stack and
         * has been cloned (so it lives in the ptr_table) has a refcount
         * higher than 0.
         *
         * If the refcount is 0 it means that a something on the stack/context
         * was holding a reference to it and since we init_stacks() in
         * perl_clone that won't get cleaned and we will get a leaked scalar.
         * The reason it was cloned was that it lived on the @@_ stack.
         *
         * Example of this can be found in bugreport 15837 where calls in the
         * parameter list end up as a temp.
         *
         * One could argue that this fix should be in perl_clone.
         */
        while (tmps_ix > 0) {
            SV* sv = (SV*)ptr_table_fetch(PL_ptr_table, tmps_tmp[tmps_ix]);
            tmps_ix--;
            if (sv && SvREFCNT(sv) == 0) {
                SvREFCNT_inc_void(sv);
                SvREFCNT_dec(sv);
            }
        }

        SvTEMP_off(thread->init_function);
        ptr_table_free(PL_ptr_table);
        PL_ptr_table = NULL;
        PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
    }
    S_ithread_set(aTHX_ current_thread);
    PERL_SET_CONTEXT(aTHX);

    /* Create/start the thread */
#ifdef WIN32
    thread->handle = CreateThread(NULL,
                                  (DWORD)thread->stack_size,
                                  S_ithread_run,
                                  (LPVOID)thread,
                                  STACK_SIZE_PARAM_IS_A_RESERVATION,
                                  &thread->thr);
#else
    {
        STATIC pthread_attr_t attr;
        STATIC int attr_inited = 0;
        STATIC int attr_joinable = PTHREAD_CREATE_JOINABLE;
        if (! attr_inited) {
            pthread_attr_init(&attr);
            attr_inited = 1;
        }
d402 114
d517 1
a517 2
        /* Threads start out joinable */
        PTHREAD_ATTR_SETDETACHSTATE(&attr, attr_joinable);
d519 3
a521 6

#  ifdef _POSIX_THREAD_ATTR_STACKSIZE
        /* Set thread's stack size */
        if (thread->stack_size > 0) {
            rc_stack_size = pthread_attr_setstacksize(&attr, (size_t)thread->stack_size);
        }
d524 7
a530 15
        /* Create the thread */
        if (! rc_stack_size) {
#  ifdef OLD_PTHREADS_API
            rc_thread_create = pthread_create(&thread->thr,
                                              attr,
                                              S_ithread_run,
                                              (void *)thread);
#  else
#    if defined(HAS_PTHREAD_ATTR_SETSCOPE) && defined(PTHREAD_SCOPE_SYSTEM)
            pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
#    endif
            rc_thread_create = pthread_create(&thread->thr,
                                              &attr,
                                              S_ithread_run,
                                              (void *)thread);
d532 3
a534 10
        }

#  ifdef _POSIX_THREAD_ATTR_STACKSIZE
        /* Try to get thread's actual stack size */
        {
            size_t stacksize;
#ifdef HPUX1020
            stacksize = pthread_attr_getstacksize(attr);
#else
            if (! pthread_attr_getstacksize(&attr, &stacksize))
d536 1
a536 6
                if (stacksize > 0) {
                    thread->stack_size = (IV)stacksize;
                }
        }
#  endif
    }
d538 2
a539 2

    /* Check for errors */
d541 1
a541 1
    if (thread->handle == NULL) {
d543 1
a543 1
    if (rc_stack_size || rc_thread_create) {
d545 4
a548 5
        /* Must unlock mutex for destruct call */
        MUTEX_UNLOCK(&MY_POOL.create_destruct_mutex);
        sv_2mortal(params);
        thread->state |= PERL_ITHR_NONVIABLE;
        S_ithread_free(aTHX_ thread);   /* Releases MUTEX */
d550 2
a551 7
        if (ckWARN_d(WARN_THREADS)) {
            if (rc_stack_size) {
                Perl_warn(aTHX_ "Thread creation failed: pthread_attr_setstacksize(%" IVdf ") returned %d", thread->stack_size, rc_stack_size);
            } else {
                Perl_warn(aTHX_ "Thread creation failed: pthread_create returned %d", rc_thread_create);
            }
        }
d553 5
a557 2
        return (NULL);
    }
d559 1
a559 3
    MY_POOL.running_threads++;
    sv_2mortal(params);
    return (thread);
d562 10
a571 1
#endif /* USE_ITHREADS */
d573 4
a576 5

MODULE = threads    PACKAGE = threads    PREFIX = ithread_
PROTOTYPES: DISABLE

#ifdef USE_ITHREADS
d579 9
a587 137
ithread_create(...)
    PREINIT:
        char *classname;
        ithread *thread;
        SV *function_to_call;
        AV *params;
        HV *specs;
        IV stack_size;
        int context;
        int exit_opt;
        SV *thread_exit_only;
        char *str;
        int idx;
        int ii;
        dMY_POOL;
    CODE:
        if ((items >= 2) && SvROK(ST(1)) && SvTYPE(SvRV(ST(1)))==SVt_PVHV) {
            if (--items < 2) {
                Perl_croak(aTHX_ "Usage: threads->create(\\%%specs, function, ...)");
            }
            specs = (HV*)SvRV(ST(1));
            idx = 1;
        } else {
            if (items < 2) {
                Perl_croak(aTHX_ "Usage: threads->create(function, ...)");
            }
            specs = NULL;
            idx = 0;
        }

        if (sv_isobject(ST(0))) {
            /* $thr->create() */
            classname = HvNAME(SvSTASH(SvRV(ST(0))));
            thread = INT2PTR(ithread *, SvIV(SvRV(ST(0))));
            MUTEX_LOCK(&thread->mutex);
            stack_size = thread->stack_size;
            exit_opt = thread->state & PERL_ITHR_THREAD_EXIT_ONLY;
            MUTEX_UNLOCK(&thread->mutex);
        } else {
            /* threads->create() */
            classname = (char *)SvPV_nolen(ST(0));
            stack_size = MY_POOL.default_stack_size;
            thread_exit_only = get_sv("threads::thread_exit_only", TRUE);
            exit_opt = (SvTRUE(thread_exit_only))
                                    ? PERL_ITHR_THREAD_EXIT_ONLY : 0;
        }

        function_to_call = ST(idx+1);

        context = -1;
        if (specs) {
            /* stack_size */
            if (hv_exists(specs, "stack", 5)) {
                stack_size = SvIV(*hv_fetch(specs, "stack", 5, 0));
            } else if (hv_exists(specs, "stacksize", 9)) {
                stack_size = SvIV(*hv_fetch(specs, "stacksize", 9, 0));
            } else if (hv_exists(specs, "stack_size", 10)) {
                stack_size = SvIV(*hv_fetch(specs, "stack_size", 10, 0));
            }

            /* context */
            if (hv_exists(specs, "context", 7)) {
                str = (char *)SvPV_nolen(*hv_fetch(specs, "context", 7, 0));
                switch (*str) {
                    case 'a':
                    case 'A':
                    case 'l':
                    case 'L':
                        context = G_ARRAY;
                        break;
                    case 's':
                    case 'S':
                        context = G_SCALAR;
                        break;
                    case 'v':
                    case 'V':
                        context = G_VOID;
                        break;
                    default:
                        Perl_croak(aTHX_ "Invalid context: %s", str);
                }
            } else if (hv_exists(specs, "array", 5)) {
                if (SvTRUE(*hv_fetch(specs, "array", 5, 0))) {
                    context = G_ARRAY;
                }
            } else if (hv_exists(specs, "list", 4)) {
                if (SvTRUE(*hv_fetch(specs, "list", 4, 0))) {
                    context = G_ARRAY;
                }
            } else if (hv_exists(specs, "scalar", 6)) {
                if (SvTRUE(*hv_fetch(specs, "scalar", 6, 0))) {
                    context = G_SCALAR;
                }
            } else if (hv_exists(specs, "void", 4)) {
                if (SvTRUE(*hv_fetch(specs, "void", 4, 0))) {
                    context = G_VOID;
                }
            }

            /* exit => thread_only */
            if (hv_exists(specs, "exit", 4)) {
                str = (char *)SvPV_nolen(*hv_fetch(specs, "exit", 4, 0));
                exit_opt = (*str == 't' || *str == 'T')
                                    ? PERL_ITHR_THREAD_EXIT_ONLY : 0;
            }
        }
        if (context == -1) {
            context = GIMME_V;  /* Implicit context */
        } else {
            context |= (GIMME_V & (~(G_ARRAY|G_SCALAR|G_VOID)));
        }

        /* Function args */
        params = newAV();
        if (items > 2) {
            for (ii=2; ii < items ; ii++) {
                av_push(params, SvREFCNT_inc(ST(idx+ii)));
            }
        }

        /* Create thread */
        MUTEX_LOCK(&MY_POOL.create_destruct_mutex);
        thread = S_ithread_create(aTHX_ function_to_call,
                                        stack_size,
                                        context,
                                        exit_opt,
                                        newRV_noinc((SV*)params));
        if (! thread) {
            XSRETURN_UNDEF;     /* Mutex already unlocked */
        }
        ST(0) = sv_2mortal(S_ithread_to_SV(aTHX_ Nullsv, thread, classname, FALSE));
        MUTEX_UNLOCK(&MY_POOL.create_destruct_mutex);

        /* Let thread run */
        MUTEX_UNLOCK(&thread->mutex);

        /* XSRETURN(1); - implied */
d589 81
d672 5
a676 15
ithread_list(...)
    PREINIT:
        char *classname;
        ithread *thread;
        int list_context;
        IV count = 0;
        int want_running = 0;
        int state;
        dMY_POOL;
    PPCODE:
        /* Class method only */
        if (SvROK(ST(0))) {
            Perl_croak(aTHX_ "Usage: threads->list(...)");
        }
        classname = (char *)SvPV_nolen(ST(0));
d678 1
a678 2
        /* Calling context */
        list_context = (GIMME_V == G_ARRAY);
d680 2
a681 44
        /* Running or joinable parameter */
        if (items > 1) {
            want_running = SvTRUE(ST(1));
        }

        /* Walk through threads list */
        MUTEX_LOCK(&MY_POOL.create_destruct_mutex);
        for (thread = MY_POOL.main_thread.next;
             thread != &MY_POOL.main_thread;
             thread = thread->next)
        {
            MUTEX_LOCK(&thread->mutex);
            state = thread->state;
            MUTEX_UNLOCK(&thread->mutex);

            /* Ignore detached or joined threads */
            if (state & PERL_ITHR_UNCALLABLE) {
                continue;
            }

            /* Filter per parameter */
            if (items > 1) {
                if (want_running) {
                    if (state & PERL_ITHR_FINISHED) {
                        continue;   /* Not running */
                    }
                } else {
                    if (! (state & PERL_ITHR_FINISHED)) {
                        continue;   /* Still running - not joinable yet */
                    }
                }
            }

            /* Push object on stack if list context */
            if (list_context) {
                XPUSHs(sv_2mortal(S_ithread_to_SV(aTHX_ Nullsv, thread, classname, TRUE)));
            }
            count++;
        }
        MUTEX_UNLOCK(&MY_POOL.create_destruct_mutex);
        /* If scalar context, send back count */
        if (! list_context) {
            XSRETURN_IV(count);
        }
d683 1
d686 15
a700 16
ithread_self(...)
    PREINIT:
        char *classname;
        ithread *thread;
    CODE:
        /* Class method only */
        if ((items != 1) || SvROK(ST(0))) {
            Perl_croak(aTHX_ "Usage: threads->self()");
        }
        classname = (char *)SvPV_nolen(ST(0));

        thread = S_ithread_get(aTHX);

        ST(0) = sv_2mortal(S_ithread_to_SV(aTHX_ Nullsv, thread, classname, TRUE));
        /* XSRETURN(1); - implied */

d703 19
a721 8
ithread_tid(...)
    PREINIT:
        ithread *thread;
    CODE:
        PERL_UNUSED_VAR(items);
        thread = S_SV_to_ithread(aTHX_ ST(0));
        XST_mUV(0, thread->tid);
        /* XSRETURN(1); - implied */
d725 6
a730 102
ithread_join(...)
    PREINIT:
        ithread *thread;
        ithread *current_thread;
        int join_err;
        AV *params = NULL;
        int len;
        int ii;
#ifndef WIN32
        int rc_join;
        void *retval;
#endif
        dMY_POOL;
    PPCODE:
        /* Object method only */
        if ((items != 1) || ! sv_isobject(ST(0))) {
            Perl_croak(aTHX_ "Usage: $thr->join()");
        }

        /* Check if the thread is joinable and not ourselves */
        thread = S_SV_to_ithread(aTHX_ ST(0));
        current_thread = S_ithread_get(aTHX);

        MUTEX_LOCK(&thread->mutex);
        if ((join_err = (thread->state & PERL_ITHR_UNCALLABLE))) {
            MUTEX_UNLOCK(&thread->mutex);
            Perl_croak(aTHX_ (join_err & PERL_ITHR_DETACHED)
                                ? "Cannot join a detached thread"
                                : "Thread already joined");
        } else if (thread->tid == current_thread->tid) {
            MUTEX_UNLOCK(&thread->mutex);
            Perl_croak(aTHX_ "Cannot join self");
        }

        /* Mark as joined */
        thread->state |= PERL_ITHR_JOINED;
        MUTEX_UNLOCK(&thread->mutex);

        MUTEX_LOCK(&MY_POOL.create_destruct_mutex);
        MY_POOL.joinable_threads--;
        MUTEX_UNLOCK(&MY_POOL.create_destruct_mutex);

        /* Join the thread */
#ifdef WIN32
        if (WaitForSingleObject(thread->handle, INFINITE) != WAIT_OBJECT_0) {
            /* Timeout/abandonment unexpected here; check $^E */
            Perl_croak(aTHX_ "PANIC: underlying join failed");
        };
#else
        if ((rc_join = pthread_join(thread->thr, &retval)) != 0) {
            /* In progress/deadlock/unknown unexpected here; check $! */
            errno = rc_join;
            Perl_croak(aTHX_ "PANIC: underlying join failed");
        };
#endif

        MUTEX_LOCK(&thread->mutex);
        /* Get the return value from the call_sv */
        /* Objects do not survive this process - FIXME */
        if (! (thread->gimme & G_VOID)) {
            AV *params_copy;
            PerlInterpreter *other_perl;
            CLONE_PARAMS clone_params;

            params_copy = (AV *)SvRV(thread->params);
            other_perl = thread->interp;
            clone_params.stashes = newAV();
            clone_params.flags = CLONEf_JOIN_IN;
            PL_ptr_table = ptr_table_new();
            S_ithread_set(aTHX_ thread);
            /* Ensure 'meaningful' addresses retain their meaning */
            ptr_table_store(PL_ptr_table, &other_perl->Isv_undef, &PL_sv_undef);
            ptr_table_store(PL_ptr_table, &other_perl->Isv_no, &PL_sv_no);
            ptr_table_store(PL_ptr_table, &other_perl->Isv_yes, &PL_sv_yes);
            params = (AV *)sv_dup((SV*)params_copy, &clone_params);
            S_ithread_set(aTHX_ current_thread);
            SvREFCNT_dec(clone_params.stashes);
            SvREFCNT_inc_void(params);
            ptr_table_free(PL_ptr_table);
            PL_ptr_table = NULL;
        }

        /* If thread didn't die, then we can free its interpreter */
        if (! (thread->state & PERL_ITHR_DIED)) {
            S_ithread_clear(aTHX_ thread);
        }
        S_ithread_free(aTHX_ thread);   /* Releases MUTEX */

        /* If no return values, then just return */
        if (! params) {
            XSRETURN_UNDEF;
        }

        /* Put return values on stack */
        len = (int)AvFILL(params);
        for (ii=0; ii <= len; ii++) {
            SV* param = av_shift(params);
            XPUSHs(sv_2mortal(param));
        }

        /* Free return value array */
        SvREFCNT_dec(params);
d732 2
d736 13
a748 5
ithread_yield(...)
    CODE:
        PERL_UNUSED_VAR(items);
        YIELD;

d751 6
a756 46
ithread_detach(...)
    PREINIT:
        ithread *thread;
        int detach_err;
        dMY_POOL;
    CODE:
        PERL_UNUSED_VAR(items);

        /* Detach the thread */
        thread = S_SV_to_ithread(aTHX_ ST(0));
        MUTEX_LOCK(&MY_POOL.create_destruct_mutex);
        MUTEX_LOCK(&thread->mutex);
        if (! (detach_err = (thread->state & PERL_ITHR_UNCALLABLE))) {
            /* Thread is detachable */
            thread->state |= PERL_ITHR_DETACHED;
#ifdef WIN32
            /* Windows has no 'detach thread' function */
#else
            PERL_THREAD_DETACH(thread->thr);
#endif
            if (thread->state & PERL_ITHR_FINISHED) {
                MY_POOL.joinable_threads--;
            } else {
                MY_POOL.running_threads--;
                MY_POOL.detached_threads++;
            }
        }
        MUTEX_UNLOCK(&thread->mutex);
        MUTEX_UNLOCK(&MY_POOL.create_destruct_mutex);

        if (detach_err) {
            Perl_croak(aTHX_ (detach_err & PERL_ITHR_DETACHED)
                                ? "Thread already detached"
                                : "Cannot detach a joined thread");
        }

        /* If thread is finished and didn't die,
         * then we can free its interpreter */
        MUTEX_LOCK(&thread->mutex);
        if ((thread->state & PERL_ITHR_FINISHED) &&
            ! (thread->state & PERL_ITHR_DIED))
        {
            S_ithread_clear(aTHX_ thread);
        }
        S_ithread_free(aTHX_ thread);   /* Releases MUTEX */

d759 1
a759 179
ithread_kill(...)
    PREINIT:
        ithread *thread;
        char *sig_name;
        IV signal;
    CODE:
        /* Must have safe signals */
        if (PL_signals & PERL_SIGNALS_UNSAFE_FLAG) {
            Perl_croak(aTHX_ "Cannot signal threads without safe signals");
        }

        /* Object method only */
        if ((items != 2) || ! sv_isobject(ST(0))) {
            Perl_croak(aTHX_ "Usage: $thr->kill('SIG...')");
        }

        /* Get signal */
        sig_name = SvPV_nolen(ST(1));
        if (isALPHA(*sig_name)) {
            if (*sig_name == 'S' && sig_name[1] == 'I' && sig_name[2] == 'G') {
                sig_name += 3;
            }
            if ((signal = whichsig(sig_name)) < 0) {
                Perl_croak(aTHX_ "Unrecognized signal name: %s", sig_name);
            }
        } else {
            signal = SvIV(ST(1));
        }

        /* Set the signal for the thread */
        thread = S_SV_to_ithread(aTHX_ ST(0));
        MUTEX_LOCK(&thread->mutex);
        if (thread->interp) {
            dTHXa(thread->interp);
            PL_psig_pend[signal]++;
            PL_sig_pending = 1;
        }
        MUTEX_UNLOCK(&thread->mutex);

        /* Return the thread to allow for method chaining */
        ST(0) = ST(0);
        /* XSRETURN(1); - implied */


void
ithread_DESTROY(...)
    CODE:
        PERL_UNUSED_VAR(items);
        sv_unmagic(SvRV(ST(0)), PERL_MAGIC_shared_scalar);


void
ithread_equal(...)
    PREINIT:
        int are_equal = 0;
    CODE:
        PERL_UNUSED_VAR(items);

        /* Compares TIDs to determine thread equality */
        if (sv_isobject(ST(0)) && sv_isobject(ST(1))) {
            ithread *thr1 = INT2PTR(ithread *, SvIV(SvRV(ST(0))));
            ithread *thr2 = INT2PTR(ithread *, SvIV(SvRV(ST(1))));
            are_equal = (thr1->tid == thr2->tid);
        }
        if (are_equal) {
            XST_mYES(0);
        } else {
            /* Return 0 on false for backward compatibility */
            XST_mIV(0, 0);
        }
        /* XSRETURN(1); - implied */


void
ithread_object(...)
    PREINIT:
        char *classname;
        UV tid;
        ithread *thread;
        int state;
        int have_obj = 0;
        dMY_POOL;
    CODE:
        /* Class method only */
        if (SvROK(ST(0))) {
            Perl_croak(aTHX_ "Usage: threads->object($tid)");
        }
        classname = (char *)SvPV_nolen(ST(0));

        if ((items < 2) || ! SvOK(ST(1))) {
            XSRETURN_UNDEF;
        }

        /* threads->object($tid) */
        tid = SvUV(ST(1));

        /* Walk through threads list */
        MUTEX_LOCK(&MY_POOL.create_destruct_mutex);
        for (thread = MY_POOL.main_thread.next;
             thread != &MY_POOL.main_thread;
             thread = thread->next)
        {
            /* Look for TID */
            if (thread->tid == tid) {
                /* Ignore if detached or joined */
                MUTEX_LOCK(&thread->mutex);
                state = thread->state;
                MUTEX_UNLOCK(&thread->mutex);
                if (! (state & PERL_ITHR_UNCALLABLE)) {
                    /* Put object on stack */
                    ST(0) = sv_2mortal(S_ithread_to_SV(aTHX_ Nullsv, thread, classname, TRUE));
                    have_obj = 1;
                }
                break;
            }
        }
        MUTEX_UNLOCK(&MY_POOL.create_destruct_mutex);

        if (! have_obj) {
            XSRETURN_UNDEF;
        }
        /* XSRETURN(1); - implied */


void
ithread__handle(...);
    PREINIT:
        ithread *thread;
    CODE:
        PERL_UNUSED_VAR(items);
        thread = S_SV_to_ithread(aTHX_ ST(0));
#ifdef WIN32
        XST_mUV(0, PTR2UV(&thread->handle));
#else
        XST_mUV(0, PTR2UV(&thread->thr));
#endif
        /* XSRETURN(1); - implied */


void
ithread_get_stack_size(...)
    PREINIT:
        IV stack_size;
        dMY_POOL;
    CODE:
        PERL_UNUSED_VAR(items);
        if (sv_isobject(ST(0))) {
            /* $thr->get_stack_size() */
            ithread *thread = INT2PTR(ithread *, SvIV(SvRV(ST(0))));
            stack_size = thread->stack_size;
        } else {
            /* threads->get_stack_size() */
            stack_size = MY_POOL.default_stack_size;
        }
        XST_mIV(0, stack_size);
        /* XSRETURN(1); - implied */


void
ithread_set_stack_size(...)
    PREINIT:
        IV old_size;
        dMY_POOL;
    CODE:
        if (items != 2) {
            Perl_croak(aTHX_ "Usage: threads->set_stack_size($size)");
        }
        if (sv_isobject(ST(0))) {
            Perl_croak(aTHX_ "Cannot change stack size of an existing thread");
        }
        if (! looks_like_number(ST(1))) {
            Perl_croak(aTHX_ "Stack size must be numeric");
        }

        old_size = MY_POOL.default_stack_size;
        MY_POOL.default_stack_size = S_good_stack_size(aTHX_ SvIV(ST(1)));
        XST_mIV(0, old_size);
        /* XSRETURN(1); - implied */

d762 1
a762 130
ithread_is_running(...)
    PREINIT:
        ithread *thread;
    CODE:
        /* Object method only */
        if ((items != 1) || ! sv_isobject(ST(0))) {
            Perl_croak(aTHX_ "Usage: $thr->is_running()");
        }

        thread = INT2PTR(ithread *, SvIV(SvRV(ST(0))));
        MUTEX_LOCK(&thread->mutex);
        ST(0) = (thread->state & PERL_ITHR_FINISHED) ? &PL_sv_no : &PL_sv_yes;
        MUTEX_UNLOCK(&thread->mutex);
        /* XSRETURN(1); - implied */


void
ithread_is_detached(...)
    PREINIT:
        ithread *thread;
    CODE:
        PERL_UNUSED_VAR(items);
        thread = S_SV_to_ithread(aTHX_ ST(0));
        MUTEX_LOCK(&thread->mutex);
        ST(0) = (thread->state & PERL_ITHR_DETACHED) ? &PL_sv_yes : &PL_sv_no;
        MUTEX_UNLOCK(&thread->mutex);
        /* XSRETURN(1); - implied */


void
ithread_is_joinable(...)
    PREINIT:
        ithread *thread;
    CODE:
        /* Object method only */
        if ((items != 1) || ! sv_isobject(ST(0))) {
            Perl_croak(aTHX_ "Usage: $thr->is_joinable()");
        }

        thread = INT2PTR(ithread *, SvIV(SvRV(ST(0))));
        MUTEX_LOCK(&thread->mutex);
        ST(0) = ((thread->state & PERL_ITHR_FINISHED) &&
                 ! (thread->state & PERL_ITHR_UNCALLABLE))
            ? &PL_sv_yes : &PL_sv_no;
        MUTEX_UNLOCK(&thread->mutex);
        /* XSRETURN(1); - implied */


void
ithread_wantarray(...)
    PREINIT:
        ithread *thread;
    CODE:
        PERL_UNUSED_VAR(items);
        thread = S_SV_to_ithread(aTHX_ ST(0));
        ST(0) = (thread->gimme & G_ARRAY) ? &PL_sv_yes :
                (thread->gimme & G_VOID)  ? &PL_sv_undef
                           /* G_SCALAR */ : &PL_sv_no;
        /* XSRETURN(1); - implied */


void
ithread_set_thread_exit_only(...)
    PREINIT:
        ithread *thread;
    CODE:
        if (items != 2) {
            Perl_croak(aTHX_ "Usage: ->set_thread_exit_only(boolean)");
        }
        thread = S_SV_to_ithread(aTHX_ ST(0));
        MUTEX_LOCK(&thread->mutex);
        if (SvTRUE(ST(1))) {
            thread->state |= PERL_ITHR_THREAD_EXIT_ONLY;
        } else {
            thread->state &= ~PERL_ITHR_THREAD_EXIT_ONLY;
        }
        MUTEX_UNLOCK(&thread->mutex);


void
ithread_error(...)
    PREINIT:
        ithread *thread;
        SV *err = NULL;
    CODE:
        /* Object method only */
        if ((items != 1) || ! sv_isobject(ST(0))) {
            Perl_croak(aTHX_ "Usage: $thr->err()");
        }

        thread = INT2PTR(ithread *, SvIV(SvRV(ST(0))));
        MUTEX_LOCK(&thread->mutex);

        /* If thread died, then clone the error into the calling thread */
        if (thread->state & PERL_ITHR_DIED) {
            PerlInterpreter *other_perl;
            CLONE_PARAMS clone_params;
            ithread *current_thread;

            other_perl = thread->interp;
            clone_params.stashes = newAV();
            clone_params.flags = CLONEf_JOIN_IN;
            PL_ptr_table = ptr_table_new();
            current_thread = S_ithread_get(aTHX);
            S_ithread_set(aTHX_ thread);
            /* Ensure 'meaningful' addresses retain their meaning */
            ptr_table_store(PL_ptr_table, &other_perl->Isv_undef, &PL_sv_undef);
            ptr_table_store(PL_ptr_table, &other_perl->Isv_no, &PL_sv_no);
            ptr_table_store(PL_ptr_table, &other_perl->Isv_yes, &PL_sv_yes);
            err = sv_dup(thread->err, &clone_params);
            S_ithread_set(aTHX_ current_thread);
            SvREFCNT_dec(clone_params.stashes);
            SvREFCNT_inc_void(err);
            /* If error was an object, bless it into the correct class */
            if (thread->err_class) {
                sv_bless(err, gv_stashpv(thread->err_class, 1));
            }
            ptr_table_free(PL_ptr_table);
            PL_ptr_table = NULL;
        }

        MUTEX_UNLOCK(&thread->mutex);

        if (! err) {
            XSRETURN_UNDEF;
        }

        ST(0) = sv_2mortal(err);
        /* XSRETURN(1); - implied */

a765 1

d769 28
a796 8
    SV *my_pool_sv = *hv_fetch(PL_modglobal, MY_POOL_KEY,
                               sizeof(MY_POOL_KEY)-1, TRUE);
    my_pool_t *my_poolp = (my_pool_t*)SvPVX(newSV(sizeof(my_pool_t)-1));

    MY_CXT_INIT;

    Zero(my_poolp, 1, my_pool_t);
    sv_setuv(my_pool_sv, PTR2UV(my_poolp));
d798 2
a799 34
    PL_perl_destruct_level = 2;
    MUTEX_INIT(&MY_POOL.create_destruct_mutex);
    MUTEX_LOCK(&MY_POOL.create_destruct_mutex);

    PL_threadhook = &Perl_ithread_hook;

    MY_POOL.tid_counter = 1;
#  ifdef THREAD_CREATE_NEEDS_STACK
    MY_POOL.default_stack_size = THREAD_CREATE_NEEDS_STACK;
#  endif

    /* The 'main' thread is thread 0.
     * It is detached (unjoinable) and immortal.
     */

    MUTEX_INIT(&MY_POOL.main_thread.mutex);

    /* Head of the threads list */
    MY_POOL.main_thread.next = &MY_POOL.main_thread;
    MY_POOL.main_thread.prev = &MY_POOL.main_thread;

    MY_POOL.main_thread.count = 1;                  /* Immortal */

    MY_POOL.main_thread.interp = aTHX;
    MY_POOL.main_thread.state = PERL_ITHR_DETACHED; /* Detached */
    MY_POOL.main_thread.stack_size = MY_POOL.default_stack_size;
#  ifdef WIN32
    MY_POOL.main_thread.thr = GetCurrentThreadId();
#  else
    MY_POOL.main_thread.thr = pthread_self();
#  endif

    S_ithread_set(aTHX_ &MY_POOL.main_thread);
    MUTEX_UNLOCK(&MY_POOL.create_destruct_mutex);
d802 1
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d359 1
a359 1
                SV * const error = get_sv("@@", 0);
d455 1
a455 1
            if (jmp_rc == 0 && (thread->gimme & G_WANT) != G_VOID) {
d873 1
a873 1
            thread_exit_only = get_sv("threads::thread_exit_only", GV_ADD);
d1125 1
a1125 1
        if ((thread->gimme & G_WANT) != G_VOID) {
d1462 3
a1464 3
        ST(0) = ((thread->gimme & G_WANT) == G_ARRAY) ? &PL_sv_yes :
                ((thread->gimme & G_WANT) == G_VOID)  ? &PL_sv_undef
                                       /* G_SCALAR */ : &PL_sv_no;
@


