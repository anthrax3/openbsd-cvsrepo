head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.6.0.4
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.2
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2010.09.24.14.59.32;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2003.12.03.02.43.54;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.03.02.43.54;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.04.07.21.13.09;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.46.35;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.48.24;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.26;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.11.18;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@
BEGIN {
    chdir 't' if -d 't';
    push @@INC, '../lib';
    require Config; import Config;
    unless ($Config{'useithreads'}) {
	print "1..0 # Skip: no useithreads\n";
 	exit 0;	
    }
}

use warnings;
use strict;
use threads;
use threads::shared;

# Note that we can't use  Test::More here, as we would need to
# call is() from within the DESTROY() function at global destruction time,
# and parts of Test::* may have already been freed by then

print "1..4\n";

my $test : shared = 1;

sub is($$$) {
    my ($got, $want, $desc) = @@_;
    unless ($got eq $want) {
	print "# EXPECTED: $want\n";
	print "# GOT:      got\n";
	print "not ";
    }
    print "ok $test - $desc\n";
    $test++;
}


#
# This tests for too much destruction
# which was caused by cloning stashes
# on join which led to double the dataspace
#
#########################

$|++;

{ 
    sub Foo::DESTROY { 
	my $self = shift;
	my ($package, $file, $line) = caller;
	is(threads->tid(),$self->{tid},
		"In destroy[$self->{tid}] it should be correct too" )
    }
    my $foo;
    $foo = bless {tid => 0}, 'Foo';			  
    my $bar = threads->create(sub { 
	is(threads->tid(),1, "And tid be 1 here");
	$foo->{tid} = 1;
	return $foo;
    })->join();
    $bar->{tid} = 0;
}
1;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@perl 5.8.2 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.3 from CPAN
@
text
@d21 1
a21 1
print "1..8\n";
a61 34

#
# This tests whether we can call Config::myconfig after threads have been
# started (interpreter cloned).  5.8.1 and 5.8.2 contained a bug that would
# disallow that too be done, because an attempt was made to change a variable
# with the : unique attribute.
#
#########################

threads->new( sub {1} )->join;
my $not = eval { Config::myconfig() } ? '' : 'not ';
print "${not}ok $test - Are we able to call Config::myconfig after clone\n";
$test++;

# bugid 24383 - :unique hashes weren't being made readonly on interpreter
# clone; check that they are.

our $unique_scalar : unique;
our @@unique_array : unique;
our %unique_hash : unique;
threads->new(
    sub {
	eval { $unique_scalar = 1 };
	print $@@ =~ /read-only/  ? '' : 'not ', "ok $test - unique_scalar\n";
	$test++;
	eval { $unique_array[0] = 1 };
	print $@@ =~ /read-only/  ? '' : 'not ', "ok $test - unique_array\n";
	$test++;
	eval { $unique_hash{abc} = 1 };
	print $@@ =~ /disallowed/  ? '' : 'not ', "ok $test - unique_hash\n";
	$test++;
    }
)->join;

@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@d21 1
a21 1
print "1..10\n";
a94 27

# bugid #24940 :unique should fail on my and sub declarations

for my $decl ('my $x : unique', 'sub foo : unique') {
    eval $decl;
    print $@@ =~
	/^The 'unique' attribute may only be applied to 'our' variables/
	    ? '' : 'not ', "ok $test - $decl\n";
    $test++;
}


# Returing a closure from a thread caused problems. If the last index in
# the anon sub's pad wasn't for a lexical, then a core dump could occur.
# Otherwise, there might be leaked scalars.

# XXX DAPM 9-Jan-04 - backed this out for now - returning a closure from a
# thread seems to crash win32

# sub f {
#     my $x = "foo";
#     sub { $x."bar" };
# }
# 
# my $string = threads->new(\&f)->join->();
# print $string eq 'foobar' ?  '' : 'not ', "ok $test - returning closure\n";
# $test++;
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@a15 1
use Hash::Util 'lock_keys';
d21 1
a21 1
print "1..14\n";
d29 1
a29 1
	print "# GOT:      $got\n";
a83 1
	my $TODO = ":unique needs to be re-implemented in a non-broken way";
d85 1
a85 2
	print $@@ =~ /read-only/
	  ? '' : 'not ', "ok $test # TODO $TODO unique_scalar\n";
d88 1
a88 2
	print $@@ =~ /read-only/
	  ? '' : 'not ', "ok $test # TODO $TODO - unique_array\n";
d91 1
a91 2
	print $@@ =~ /disallowed/
	  ? '' : 'not ', "ok $test # TODO $TODO - unique_hash\n";
a121 16

# Nothing is checking that total keys gets cloned correctly.

my %h = (1,2,3,4);
is (keys %h, 2, "keys correct in parent");

my $child = threads->new(sub { return scalar keys %h })->join;
is ($child, 2, "keys correct in child");

lock_keys (%h);
delete $h{1};

is (keys %h, 1, "keys correct in parent with restricted hash");

$child = threads->new(sub { return scalar keys %h })->join;
is ($child, 1, "keys correct in child with restricted hash");
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@a0 2
use strict;
use warnings;
d3 6
a8 8
    if ($ENV{'PERL_CORE'}){
        chdir 't';
        unshift @@INC, '../lib';
    }
    use Config;
    if (! $Config{'useithreads'}) {
        print("1..0 # Skip: Perl not compiled with 'useithreads'\n");
        exit(0);
d12 2
a13 2
use ExtUtils::testlib;

d15 2
d18 3
a20 17
BEGIN {
    eval {
        require threads::shared;
        threads::shared->import();
    };
    if ($@@ || ! $threads::shared::threads_shared) {
        print("1..0 # Skip: threads::shared not available\n");
        exit(0);
    }

    $| = 1;
    if ($] == 5.008) {
        print("1..11\n");   ### Number of tests that will be run ###
    } else {
        print("1..15\n");   ### Number of tests that will be run ###
    }
};
d22 1
a22 1
print("ok 1 - Loaded\n");
d24 1
a24 5
### Start of Testing ###

no warnings 'deprecated';       # Suppress warnings related to :unique

use Hash::Util 'lock_keys';
d26 1
a26 7
my $test :shared = 2;

# Note that we can't use Test::More here, as we would need to call is()
# from within the DESTROY() function at global destruction time, and
# parts of Test::* may have already been freed by then
sub is($$$)
{
d28 4
a31 5
    lock($test);
    if ($got ne $want) {
        print("# EXPECTED: $want\n");
        print("# GOT:      $got\n");
        print("not ");
d33 1
a33 1
    print("ok $test - $desc\n");
d38 22
a59 16
# This tests for too much destruction which was caused by cloning stashes
# on join which led to double the dataspace under 5.8.0
if ($] != 5.008)
{
    sub Foo::DESTROY
    {
        my $self = shift;
        my ($package, $file, $line) = caller;
        is(threads->tid(), $self->{tid}, "In destroy[$self->{tid}] it should be correct too" );
    }

    my $foo = bless {tid => 0}, 'Foo';
    my $bar = threads->create(sub {
        is(threads->tid(), 1, "And tid be 1 here");
        $foo->{tid} = 1;
        return ($foo);
d64 1
a64 1

d67 9
a75 15
# disallow that to be done because an attempt was made to change a variable
# with the :unique attribute.

{
    lock($test);
    if ($] == 5.008 || $] >= 5.008003) {
        threads->create( sub {1} )->join;
        my $not = eval { Config::myconfig() } ? '' : 'not ';
        print "${not}ok $test - Are we able to call Config::myconfig after clone\n";
    } else {
        print "ok $test # Skip Are we able to call Config::myconfig after clone\n";
    }
    $test++;
}

d83 17
a99 20
threads->create(sub {
        lock($test);
        my $TODO = ":unique needs to be re-implemented in a non-broken way";
        eval { $unique_scalar = 1 };
        print $@@ =~ /read-only/
          ? '' : 'not ', "ok $test # TODO $TODO - unique_scalar\n";
        $test++;
        eval { $unique_array[0] = 1 };
        print $@@ =~ /read-only/
          ? '' : 'not ', "ok $test # TODO $TODO - unique_array\n";
        $test++;
        if ($] >= 5.008003 && $^O ne 'MSWin32') {
            eval { $unique_hash{abc} = 1 };
            print $@@ =~ /disallowed/
              ? '' : 'not ', "ok $test # TODO $TODO - unique_hash\n";
        } else {
            print("ok $test # Skip $TODO - unique_hash\n");
        }
        $test++;
    })->join;
d104 5
a108 11
    {
        lock($test);
        if ($] >= 5.008005) {
            eval $decl;
            print $@@ =~ /^The 'unique' attribute may only be applied to 'our' variables/
                    ? '' : 'not ', "ok $test - $decl\n";
        } else {
            print("ok $test # Skip $decl\n");
        }
        $test++;
    }
d124 1
a124 1
# my $string = threads->create(\&f)->join->();
a127 1

d131 1
a131 1
is(keys(%h), 2, "keys correct in parent");
d133 2
a134 2
my $child = threads->create(sub { return (scalar(keys(%h))); })->join;
is($child, 2, "keys correct in child");
d136 2
a137 2
lock_keys(%h);
delete($h{1});
d139 1
a139 1
is(keys(%h), 1, "keys correct in parent with restricted hash");
d141 2
a142 2
$child = threads->create(sub { return (scalar(keys(%h))); })->join;
is($child, 1, "keys correct in child with restricted hash");
d144 1
a144 1
# EOF
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d11 1
a11 1
        print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
d21 6
a26 2
    if (! eval 'use threads::shared; 1') {
        print("1..0 # SKIP threads::shared not available\n");
d98 1
a98 1
        print "ok $test # SKIP Are we able to call Config::myconfig after clone\n";
d126 1
a126 1
            print("ok $test # SKIP $TODO - unique_hash\n");
d141 1
a141 1
            print("ok $test # SKIP $decl\n");
a179 2

exit(0);
@


