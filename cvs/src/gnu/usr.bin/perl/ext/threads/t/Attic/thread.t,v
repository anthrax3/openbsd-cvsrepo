head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.5.0.4
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.2
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.32;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.48.24;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.26;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.11.18;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@
BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(../lib .);
    require Config; import Config;
    unless ($Config{'useithreads'}) {
        print "1..0 # Skip: no useithreads\n";
        exit 0;
    }
    require "test.pl";
}

use ExtUtils::testlib;
use strict;
BEGIN { $| = 1; print "1..24\n" };
use threads;
use threads::shared;

print "ok 1\n";

sub content {
    print shift;
    return shift;
}
{
    my $t = threads->new(\&content, "ok 2\n", "ok 3\n", 1..1000);
    print $t->join();
}
{
    my $lock : shared;
    my $t;
    {
	lock($lock);
	$t = threads->new(sub { lock($lock); print "ok 5\n"});
	print "ok 4\n";
    }
    $t->join();
}

sub dorecurse {
    my $val = shift;
    my $ret;
    print $val;
    if(@@_) {
	$ret = threads->new(\&dorecurse, @@_);
	$ret->join;
    }
}
{
    my $t = threads->new(\&dorecurse, map { "ok $_\n" } 6..10);
    $t->join();
}

{
    # test that sleep lets other thread run
    my $t = threads->new(\&dorecurse, "ok 11\n");
    threads->yield; # help out non-preemptive thread implementations
    sleep 1;
    print "ok 12\n";
    $t->join();
}
{
    my $lock : shared;
    sub islocked {
	lock($lock);
	my $val = shift;
	my $ret;
	print $val;
	if (@@_) {
	    $ret = threads->new(\&islocked, shift);
	}
	return $ret;
    }
my $t = threads->new(\&islocked, "ok 13\n", "ok 14\n");
$t->join->join;
}



sub testsprintf {
    my $testno = shift;
    my $same = sprintf( "%0.f", $testno);
    return $testno eq $same;
}

sub threaded {
    my ($string, $string_end) = @@_;

  # Do the match, saving the output in appropriate variables
    $string =~ /(.*)(is)(.*)/;
  # Yield control, allowing the other thread to fill in the match variables
    threads->yield();
  # Examine the match variable contents; on broken perls this fails
    return $3 eq $string_end;
}


{ 
    curr_test(15);

    my $thr1 = threads->new(\&testsprintf, 15);
    my $thr2 = threads->new(\&testsprintf, 16);
    
    my $short = "This is a long string that goes on and on.";
    my $shorte = " a long string that goes on and on.";
    my $long  = "This is short.";
    my $longe  = " short.";
    my $foo = "This is bar bar bar.";
    my $fooe = " bar bar bar.";
    my $thr3 = new threads \&threaded, $short, $shorte;
    my $thr4 = new threads \&threaded, $long, $longe;
    my $thr5 = new threads \&testsprintf, 19;
    my $thr6 = new threads \&testsprintf, 20;
    my $thr7 = new threads \&threaded, $foo, $fooe;

    ok($thr1->join());
    ok($thr2->join());
    ok($thr3->join());
    ok($thr4->join());
    ok($thr5->join());
    ok($thr6->join());
    ok($thr7->join());
}

# test that 'yield' is importable

package Test1;

use threads 'yield';
yield;
main::ok(1);

package main;


# test async

{
    my $th = async {return 1 };
    ok($th);
    ok($th->join());
}

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d4 1
a4 1
    push @@INC, '../lib','.';
d15 1
a15 1
BEGIN { $| = 1; print "1..26\n" };
a142 19
{
    # there is a little chance this test case will falsly fail
    # since it tests rand	
    my %rand : shared;
    rand(10);
    threads->new( sub { $rand{int(rand(10000000000))}++ } ) foreach 1..25;
    $_->join foreach threads->list;
#    use Data::Dumper qw(Dumper);
#    print Dumper(\%rand);
    #$val = rand();
    ok((keys %rand == 25), "Check that rand works after a new thread");
}

# bugid #24165

run_perl(prog =>
    'use threads; sub a{threads->new(shift)} $t = a sub{}; $t->tid; $t->join; $t->tid');
is($?, 0, 'coredump in global destruction');

@


1.1.1.3
log
@perl 5.8.8 import
@
text
@d15 1
a15 1
BEGIN { $| = 1; print "1..31\n" };
a161 110
# test CLONE_SKIP() functionality

{
    my %c : shared;
    my %d : shared;

    # ---

    package A;
    sub CLONE_SKIP { $c{"A-$_[0]"}++; 1; }
    sub DESTROY    { $d{"A-". ref $_[0]}++ }

    package A1;
    our @@ISA = qw(A);
    sub CLONE_SKIP { $c{"A1-$_[0]"}++; 1; }
    sub DESTROY    { $d{"A1-". ref $_[0]}++ }

    package A2;
    our @@ISA = qw(A1);

    # ---

    package B;
    sub CLONE_SKIP { $c{"B-$_[0]"}++; 0; }
    sub DESTROY    { $d{"B-" . ref $_[0]}++ }

    package B1;
    our @@ISA = qw(B);
    sub CLONE_SKIP { $c{"B1-$_[0]"}++; 1; }
    sub DESTROY    { $d{"B1-" . ref $_[0]}++ }

    package B2;
    our @@ISA = qw(B1);

    # ---

    package C;
    sub CLONE_SKIP { $c{"C-$_[0]"}++; 1; }
    sub DESTROY    { $d{"C-" . ref $_[0]}++ }

    package C1;
    our @@ISA = qw(C);
    sub CLONE_SKIP { $c{"C1-$_[0]"}++; 0; }
    sub DESTROY    { $d{"C1-" . ref $_[0]}++ }

    package C2;
    our @@ISA = qw(C1);

    # ---

    package D;
    sub DESTROY    { $d{"D-" . ref $_[0]}++ }

    package D1;
    our @@ISA = qw(D);

    package main;

    {
	my @@objs;
	for my $class (qw(A A1 A2 B B1 B2 C C1 C2 D D1)) {
	    push @@objs, bless [], $class;
	}

	sub f {
	    my $depth = shift;
	    my $cloned = ""; # XXX due to recursion, doesn't get initialized
	    $cloned .= "$_" =~ /ARRAY/ ? '1' : '0' for @@objs;
	    is($cloned, ($depth ? '00010001111' : '11111111111'),
		"objs clone skip at depth $depth");
	    threads->new( \&f, $depth+1)->join if $depth < 2;
	    @@objs = ();
	}
	f(0);
    }

    curr_test(curr_test()+2);
    ok(eq_hash(\%c,
	{
	    qw(
		A-A	2
		A1-A1	2
		A1-A2	2
		B-B	2
		B1-B1	2
		B1-B2	2
		C-C	2
		C1-C1	2
		C1-C2	2
	    )
	}),
	"counts of calls to CLONE_SKIP");
    ok(eq_hash(\%d,
	{
	    qw(
		A-A	1
		A1-A1	1
		A1-A2	1
		B-B	3
		B1-B1	1
		B1-B2	1
		C-C	1
		C1-C1	3
		C1-C2	3
		D-D	3
		D-D1	3
	    )
	}),
	"counts of calls to DESTROY");
}
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@a0 2
use strict;
use warnings;
d3 6
a8 8
    if ($ENV{'PERL_CORE'}){
        chdir 't';
        unshift @@INC, '../lib';
    }
    use Config;
    if (! $Config{'useithreads'}) {
        print("1..0 # Skip: Perl not compiled with 'useithreads'\n");
        exit(0);
d10 1
a10 2

    require($ENV{PERL_CORE} ? "./test.pl" : "./t/test.pl");
d14 2
a15 1

d17 1
d19 1
a19 17
BEGIN {
    eval {
        require threads::shared;
        threads::shared->import();
    };
    if ($@@ || ! $threads::shared::threads_shared) {
        print("1..0 # Skip: threads::shared not available\n");
        exit(0);
    }

    $| = 1;
    print("1..34\n");   ### Number of tests that will be run ###
};

print("ok 1 - Loaded\n");

### Start of Testing ###
d26 1
a26 1
    my $t = threads->create(\&content, "ok 2\n", "ok 3\n", 1..1000);
d33 3
a35 3
        lock($lock);
        $t = threads->create(sub { lock($lock); print "ok 5\n"});
        print "ok 4\n";
d45 2
a46 2
        $ret = threads->create(\&dorecurse, @@_);
        $ret->join;
d50 1
a50 1
    my $t = threads->create(\&dorecurse, map { "ok $_\n" } 6..10);
d56 1
a56 1
    my $t = threads->create(\&dorecurse, "ok 11\n");
d65 8
a72 8
        lock($lock);
        my $val = shift;
        my $ret;
        print $val;
        if (@@_) {
            $ret = threads->create(\&islocked, shift);
        }
        return $ret;
d74 1
a74 1
my $t = threads->create(\&islocked, "ok 13\n", "ok 14\n");
d101 2
a102 2
    my $thr1 = threads->create(\&testsprintf, 15);
    my $thr2 = threads->create(\&testsprintf, 16);
d144 2
a145 2
    # There is a miniscule chance this test case may falsely fail
    # since it tests using rand()
d148 1
a148 1
    threads->create( sub { $rand{int(rand(10000000000))}++ } ) foreach 1..25;
d150 4
a153 1
    ok((keys %rand >= 23), "Check that rand() is randomized in new threads");
d158 2
a159 5
run_perl(prog => 'use threads 1.67;' .
                 'sub a{threads->create(shift)} $t = a sub{};' .
                 '$t->tid; $t->join; $t->tid',
         nolib => ($ENV{PERL_CORE}) ? 0 : 1,
         switches => ($ENV{PERL_CORE}) ? [] : [ '-Mblib' ]);
a161 24
# Attempt to free unreferenced scalar...
fresh_perl_is(<<'EOI', 'ok', { }, 'thread sub via scalar');
    use threads;
    my $test = sub {};
    threads->create($test)->join();
    print 'ok';
EOI

# Attempt to free unreferenced scalar...
fresh_perl_is(<<'EOI', 'ok', { }, 'thread sub via $_[0]');
    use threads;
    sub thr { threads->new($_[0]); }
    thr(sub { })->join;
    print 'ok';
EOI

# [perl #45053]  Memory corruption from eval return in void context
fresh_perl_is(<<'EOI', 'ok', { }, 'void eval return');
    use threads;
    threads->create(sub { eval '1' });
    $_->join() for threads->list;
    print 'ok';
EOI

a162 2
SKIP: {
    skip('CLONE_SKIP not implemented in Perl < 5.8.7', 5) if ($] < 5.008007);
d164 1
d221 15
a235 15
        my @@objs;
        for my $class (qw(A A1 A2 B B1 B2 C C1 C2 D D1)) {
            push @@objs, bless [], $class;
        }

        sub f {
            my $depth = shift;
            my $cloned = ""; # XXX due to recursion, doesn't get initialized
            $cloned .= "$_" =~ /ARRAY/ ? '1' : '0' for @@objs;
            is($cloned, ($depth ? '00010001111' : '11111111111'),
                "objs clone skip at depth $depth");
            threads->create( \&f, $depth+1)->join if $depth < 2;
            @@objs = ();
        }
        f(0);
d240 14
a253 14
        {
            qw(
                A-A     2
                A1-A1   2
                A1-A2   2
                B-B     2
                B1-B1   2
                B1-B2   2
                C-C     2
                C1-C1   2
                C1-C2   2
            )
        }),
        "counts of calls to CLONE_SKIP");
d255 16
a270 16
        {
            qw(
                A-A     1
                A1-A1   1
                A1-A2   1
                B-B     3
                B1-B1   1
                B1-B2   1
                C-C     1
                C1-C1   3
                C1-C2   3
                D-D     3
                D-D1    3
            )
        }),
        "counts of calls to DESTROY");
a272 1
# EOF
@


1.1.1.5
log
@import perl 5.10.1
@
text
@a8 3

    require($ENV{PERL_CORE} ? "./test.pl" : "./t/test.pl");

d11 2
a12 1
        skip_all(q/Perl not compiled with 'useithreads'/);
d14 2
d23 7
a29 2
    if (! eval 'use threads::shared; 1') {
        skip_all('threads::shared not available');
d174 1
a174 1
run_perl(prog => 'use threads 1.72;' .
a315 2

exit(0);
@


