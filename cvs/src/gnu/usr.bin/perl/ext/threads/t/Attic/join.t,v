head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.6.0.4
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.2
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.6
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.4
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.2
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.31;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.01.15.21.17.02;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.48.24;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.26;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.11.18;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require Config; import Config;
    unless ($Config{'useithreads'}) {
        print "1..0 # Skip: no useithreads\n";
        exit 0;
    }
}

use ExtUtils::testlib;
use strict;
BEGIN { print "1..10\n" };
use threads;
use threads::shared;

my $test_id = 1;
share($test_id);
use Devel::Peek qw(Dump);

sub ok {
    my ($ok, $name) = @@_;

    # You have to do it this way or VMS will get confused.
    print $ok ? "ok $test_id - $name\n" : "not ok $test_id - $name\n";

    printf "# Failed test at line %d\n", (caller)[2] unless $ok;
    $test_id++;
    return $ok;
}

ok(1,"");


{
    my $retval = threads->create(sub { return ("hi") })->join();
    ok($retval eq 'hi', "Check basic returnvalue");
}
{
    my ($thread) = threads->create(sub { return (1,2,3) });
    my @@retval = $thread->join();
    ok($retval[0] == 1 && $retval[1] == 2 && $retval[2] == 3);
}
{
    my $retval = threads->create(sub { return [1] })->join();
    ok($retval->[0] == 1,"Check that a array ref works");
}
{
    my $retval = threads->create(sub { return { foo => "bar" }})->join();
    ok($retval->{foo} eq 'bar',"Check that hash refs work");
}
{
    my $retval = threads->create( sub {
	open(my $fh, "+>threadtest") || die $!;
	print $fh "test\n";
	return $fh;
    })->join();
    ok(ref($retval) eq 'GLOB', "Check that we can return FH $retval");
    print $retval "test2\n";
#    seek($retval,0,0);
#    ok(<$retval> eq "test\n");
    close($retval);
    unlink("threadtest");
}
{
    my $test = "hi";
    my $retval = threads->create(sub { return $_[0]}, \$test)->join();
    ok($$retval eq 'hi');
}
{
    my $test = "hi";
    share($test);
    my $retval = threads->create(sub { return $_[0]}, \$test)->join();
    ok($$retval eq 'hi');
    $test = "foo";
    ok($$retval eq 'foo');
}
{
    my %foo;
    share(%foo);
    threads->create(sub { 
	my $foo;
	share($foo);
	$foo = "thread1";
	return $foo{bar} = \$foo;
    })->join();
    ok(1,"");
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d1 1
d4 1
a4 1
    push @@INC, '../lib';
d14 1
a14 1
BEGIN { print "1..12\n" };
a32 4
sub skip {
    ok(1, "# Skipped: @@_");
}

d43 1
a43 1
    ok($retval[0] == 1 && $retval[1] == 2 && $retval[2] == 3,'');
d47 1
a47 1
    ok($retval->[0] == 1,"Check that a array ref works",);
d69 1
a69 1
    ok($$retval eq 'hi','');
d75 1
a75 1
    ok($$retval eq 'hi','');
d77 1
a77 1
    ok($$retval eq 'foo','');
a89 51

# We parse ps output so this is OS-dependent.
if ($^O eq 'linux') {
  # First modify $0 in a subthread.
  print "# mainthread: \$0 = $0\n";
  threads->new( sub {
		  print "# subthread: \$0 = $0\n";
		  $0 = "foobar";
		  print "# subthread: \$0 = $0\n" } )->join;
  print "# mainthread: \$0 = $0\n";
  print "# pid = $$\n";
  if (open PS, "ps -f |") { # Note: must work in (all) systems.
    my ($sawpid, $sawexe);
    while (<PS>) {
      chomp;
      print "# [$_]\n";
      if (/^\S+\s+$$\s/) {
	$sawpid++;
	if (/\sfoobar\s*$/) { # Linux 2.2 leaves extra trailing spaces.
	  $sawexe++;
        }
	last;
      }
    }
    close PS or die;
    if ($sawpid) {
      ok($sawpid && $sawexe, 'altering $0 is effective');
    } else {
      skip("\$0 check: did not see pid $$ in 'ps -f |'");
    }
  } else {
    skip("\$0 check: opening 'ps -f |' failed: $!");
  }
} else {
  skip("\$0 check: only on Linux");
}

{
    my $t = threads->new(sub {});
    $t->join;
    my $x = threads->new(sub {});
    $x->join;
    eval {
      $t->join;
    };
    my $ok = 0;
    $ok++ if($@@ =~/Thread already joined/);
    ok($ok, "Double join works");
}


@


1.1.1.3
log
@perl 5.8.6 from CPAN
@
text
@a8 4
    if ($Config{'extensions'} !~ /\bDevel\/Peek\b/) {
	print "1..0 # Skip: Devel::Peek was not built\n";
	exit 0;
    }
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@d17 1
a17 1
BEGIN { print "1..14\n" };
a27 2
    lock $test_id; # make print and increment atomic

d147 1
a147 8
{
    # The "use IO" is not actually used for anything; its only purpose is to
    # incite a lot of calls to newCONSTSUB.  See the p5p archives for
    # the thread "maint@@20974 or before broke mp2 ithreads test".
    use IO;
    # this coredumped between #20930 and #21000
    $_->join for map threads->new(sub{ok($_, "stress newCONSTSUB")}), 1..2;
}
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@a0 3
use strict;
use warnings;

d2 6
a7 3
    if ($ENV{'PERL_CORE'}){
        chdir 't';
        unshift @@INC, '../lib';
d9 3
a11 4
    use Config;
    if (! $Config{'useithreads'}) {
        print("1..0 # Skip: Perl not compiled with 'useithreads'\n");
        exit(0);
d16 2
a17 1

d19 1
d21 3
a23 21
BEGIN {
    eval {
        require threads::shared;
        threads::shared->import();
    };
    if ($@@ || ! $threads::shared::threads_shared) {
        print("1..0 # Skip: threads::shared not available\n");
        exit(0);
    }

    $| = 1;
    print("1..20\n");   ### Number of tests that will be run ###
};

my $TEST;
BEGIN {
    share($TEST);
    $TEST = 1;
}

ok(1, 'Loaded');
d28 1
a28 2
    lock($TEST);
    my $id = $TEST++;
d31 1
a31 6
    if ($ok) {
        print("ok $id - $name\n");
    } else {
        print("not ok $id - $name\n");
        printf("# Failed test at line %d\n", (caller)[2]);
    }
d33 3
a35 1
    return ($ok);
d39 1
a39 1
    ok(1, '# Skipped: ' . $_[0]);
d42 1
a43 1
### Start of Testing ###
d64 3
a66 3
        open(my $fh, "+>threadtest") || die $!;
        print $fh "test\n";
        return $fh;
d70 2
d92 4
a95 4
        my $foo;
        share($foo);
        $foo = "thread1";
        return $foo{bar} = \$foo;
d102 17
a118 26
    # First modify $0 in a subthread.
    #print "# mainthread: \$0 = $0\n";
    threads->create(sub{ #print "# subthread: \$0 = $0\n";
                        $0 = "foobar";
                        #print "# subthread: \$0 = $0\n"
                 })->join;
    #print "# mainthread: \$0 = $0\n";
    #print "# pid = $$\n";
    if (open PS, "ps -f |") { # Note: must work in (all) systems.
        my ($sawpid, $sawexe);
        while (<PS>) {
            chomp;
            #print "# [$_]\n";
            if (/^\s*\S+\s+$$\s/) {
                $sawpid++;
                if (/\sfoobar\s*$/) { # Linux 2.2 leaves extra trailing spaces.
                    $sawexe++;
                }
                last;
            }
        }
        close PS or die;
        if ($sawpid) {
            ok($sawpid && $sawexe, 'altering $0 is effective');
        } else {
            skip("\$0 check: did not see pid $$ in 'ps -f |'");
d120 6
d127 1
a127 1
        skip("\$0 check: opening 'ps -f |' failed: $!");
d129 3
d133 1
a133 1
    skip("\$0 check: only on Linux");
d137 10
a146 7
    my $t = threads->create(sub {});
    $t->join();
    threads->create(sub {})->join();
    eval { $t->join(); };
    ok(($@@ =~ /Thread already joined/), "Double join works");
    eval { $t->detach(); };
    ok(($@@ =~ /Cannot detach a joined thread/), "Detach joined thread");
d150 2
a151 12
    my $t = threads->create(sub {});
    $t->detach();
    threads->create(sub {})->join();
    eval { $t->detach(); };
    ok(($@@ =~ /Thread already detached/), "Double detach works");
    eval { $t->join(); };
    ok(($@@ =~ /Cannot join a detached thread/), "Join detached thread");
}

{
    # The "use IO::File" is not actually used for anything; its only purpose
    # is incite a lot of calls to newCONSTSUB.  See the p5p archives for
d153 3
a155 22
    use IO::File;
    # This coredumped between #20930 and #21000
    $_->join for map threads->create(sub{ok($_, "stress newCONSTSUB")}), 1..2;
}

{
    my $go : shared = 0;

    my $t = threads->create( sub {
        lock($go);
        cond_wait($go) until $go;
    }); 

    my $joiner = threads->create(sub { $_[0]->join }, $t);

    threads->yield();
    sleep 1;
    eval { $t->join; };
    ok(($@@ =~ /^Thread already joined at/)?1:0, "Join pending join");

    { lock($go); $go = 1; cond_signal($go); }
    $joiner->join;
a156 30

{
    my $go : shared = 0;
    my $t = threads->create( sub {
        eval { threads->self->join; };
        ok(($@@ =~ /^Cannot join self/), "Join self");
        lock($go); $go = 1; cond_signal($go);
    });

    { lock ($go); cond_wait($go) until $go; }
    $t->join;
}

{
    my $go : shared = 0;
    my $t = threads->create( sub {
        lock($go);  cond_wait($go) until $go;
    });
    my $joiner = threads->create(sub { $_[0]->join; }, $t);

    threads->yield();
    sleep 1;
    eval { $t->detach };
    ok(($@@ =~ /^Cannot detach a joined thread at/)?1:0, "Detach pending join");

    { lock($go); $go = 1; cond_signal($go); }
    $joiner->join;
}

# EOF
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d11 1
a11 1
        print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
d21 6
a26 2
    if (! eval 'use threads::shared; 1') {
        print("1..0 # SKIP threads::shared not available\n");
d60 1
a60 1
    ok(1, '# SKIP ' . $_[0]);
a229 2

exit(0);
@


