head	1.2;
access;
symbols
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.20
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.18
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.16
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.14
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.12
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2009.10.12.18.24.37;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.26;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Merge in perl 5.10.1
@
text
@use warnings;

BEGIN {
    chdir 't' if -d 't';
    push @@INC ,'../lib';
    require Config; import Config;
    unless ($Config{'useithreads'}) {
        print "1..0 # Skip: no threads\n";
        exit 0;
    }
}
$|++;
print "1..31\n";
use strict;


use threads;

use threads::shared;

# We can't use the normal ok() type stuff here, as part of the test is
# to check that the numbers get printed in the right order. Instead, we
# set a 'base' number for each part of the test and specify the ok()
# number as an offset from that base.

my $Base = 0;

sub ok {
    my ($offset, $bool, $text) = @@_;
    print "not " unless $bool;
    print "ok ", $Base + $offset, " - $text\n";
}

# test locking

{
    my $lock : shared;
    my $tr;

    # test that a subthread can't lock until parent thread has unlocked

    {
	lock($lock);
	ok(1,1,"set first lock");
	$tr = async {
	    lock($lock);
	    ok(3,1,"set lock in subthread");
	};
	threads->yield;
	ok(2,1,"still got lock");
    }
    $tr->join;

    $Base += 3;

    # ditto with ref to thread

    {
	my $lockref = \$lock;
	lock($lockref);
	ok(1,1,"set first lockref");
	$tr = async {
	    lock($lockref);
	    ok(3,1,"set lockref in subthread");
	};
	threads->yield;
	ok(2,1,"still got lockref");
    }
    $tr->join;

    $Base += 3;

    # make sure recursive locks unlock at the right place
    {
	lock($lock);
	ok(1,1,"set first recursive lock");
	lock($lock);
	threads->yield;
	{
	    lock($lock);
	    threads->yield;
	}
	$tr = async {
	    lock($lock);
	    ok(3,1,"set recursive lock in subthread");
	};
	{
	    lock($lock);
	    threads->yield;
	    {
		lock($lock);
		threads->yield;
		lock($lock);
		threads->yield;
	    }
	}
	ok(2,1,"still got recursive lock");
    }
    $tr->join;

    $Base += 3;

    # Make sure a lock factory gives out fresh locks each time 
    # for both attribute and run-time shares

    sub lock_factory1 { my $lock : shared; return \$lock; }
    sub lock_factory2 { my $lock; share($lock); return \$lock; }

    my (@@locks1, @@locks2);
    push @@locks1, lock_factory1() for 1..2;
    push @@locks1, lock_factory2() for 1..2;
    push @@locks2, lock_factory1() for 1..2;
    push @@locks2, lock_factory2() for 1..2;

    ok(1,1,"lock factory: locking all locks");
    lock $locks1[0];
    lock $locks1[1];
    lock $locks1[2];
    lock $locks1[3];
    ok(2,1,"lock factory: locked all locks");
    $tr = async {
	ok(3,1,"lock factory: child: locking all locks");
	lock $locks2[0];
	lock $locks2[1];
	lock $locks2[2];
	lock $locks2[3];
	ok(4,1,"lock factory: child: locked all locks");
    };
    $tr->join;
	
    $Base += 4;
}

# test cond_signal()

{
    my $lock : shared;

    sub foo {
	lock($lock);
	ok(1,1,"cond_signal: created first lock");
	my $tr2 = threads->create(\&bar);
	cond_wait($lock);
	$tr2->join();
	ok(5,1,"cond_signal: joined");
    }

    sub bar {
	ok(2,1,"cond_signal: child before lock");
	lock($lock);
	ok(3,1,"cond_signal: child locked");
	cond_signal($lock);
	ok(4,1,"cond_signal: signalled");
    }

    my $tr  = threads->create(\&foo);
    $tr->join();

    $Base += 5;

    # ditto, but with lockrefs

    my $lockref = \$lock;
    sub foo2 {
	lock($lockref);
	ok(1,1,"cond_signal: ref: created first lock");
	my $tr2 = threads->create(\&bar2);
	cond_wait($lockref);
	$tr2->join();
	ok(5,1,"cond_signal: ref: joined");
    }

    sub bar2 {
	ok(2,1,"cond_signal: ref: child before lock");
	lock($lockref);
	ok(3,1,"cond_signal: ref: child locked");
	cond_signal($lockref);
	ok(4,1,"cond_signal: ref: signalled");
    }

    $tr  = threads->create(\&foo2);
    $tr->join();

    $Base += 5;

}


# test cond_broadcast()

{
    my $counter : shared = 0;

    # broad(N) forks off broad(N-1) and goes into a wait, in such a way
    # that it's guaranteed to reach the wait before its child enters the
    # locked region. When N reaches 0, the child instead does a
    # cond_broadcast to wake all its ancestors.

    sub broad {
	my $n = shift;
	my $th;
	{
	    lock($counter);
	    if ($n > 0) {
		$counter++;
		$th = threads->new(\&broad, $n-1);
		cond_wait($counter);
		$counter += 10;
	    }
	    else {
		ok(1, $counter == 3, "cond_broadcast: all three waiting");
		cond_broadcast($counter);
	    }
	}
	$th->join if $th;
    }

    threads->new(\&broad, 3)->join;
    ok(2, $counter == 33, "cond_broadcast: all three threads woken");
    print "# counter=$counter\n";

    $Base += 2;


    # ditto, but with refs and shared()

    my $counter2 = 0;
    share($counter2);
    my $r = \$counter2;

    sub broad2 {
	my $n = shift;
	my $th;
	{
	    lock($r);
	    if ($n > 0) {
		$$r++;
		$th = threads->new(\&broad2, $n-1);
		cond_wait($r);
		$$r += 10;
	    }
	    else {
		ok(1, $$r == 3, "cond_broadcast: ref: all three waiting");
		cond_broadcast($r);
	    }
	}
	$th->join if $th;
    }

    threads->new(\&broad2, 3)->join;;
    ok(2, $$r == 33, "cond_broadcast: ref: all three threads woken");
    print "# counter=$$r\n";

    $Base += 2;

}

# test warnings;

{
    my $warncount = 0;
    local $SIG{__WARN__} = sub { $warncount++ };

    my $lock : shared;

    cond_signal($lock);
    ok(1, $warncount == 1, 'get warning on cond_signal');
    cond_broadcast($lock);
    ok(2, $warncount == 2, 'get warning on cond_broadcast');
    no warnings 'threads';
    cond_signal($lock);
    ok(3, $warncount == 2, 'get no warning on cond_signal');
    cond_broadcast($lock);
    ok(4, $warncount == 2, 'get no warning on cond_broadcast');

    $Base += 4;
}



@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d30 2
a31 3
    my $not = '';
    $not = "not " unless $bool;
    print "${not}ok " . ($Base + $offset) . " - $text\n";
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@a0 1
use strict;
d4 6
a9 8
    if ($ENV{'PERL_CORE'}){
        chdir 't';
        unshift @@INC, '../lib';
    }
    use Config;
    if (! $Config{'useithreads'}) {
        print("1..0 # Skip: Perl not compiled with 'useithreads'\n");
        exit(0);
d12 3
a15 1
use ExtUtils::testlib;
d17 1
a17 4
my $Base = 0;
sub ok {
    my ($id, $ok, $name) = @@_;
    $id += $Base;
d19 1
a19 7
    # You have to do it this way or VMS will get confused.
    if ($ok) {
        print("ok $id - $name\n");
    } else {
        print("not ok $id - $name\n");
        printf("# Failed test at line %d\n", (caller)[2]);
    }
d21 4
a24 2
    return ($ok);
}
d26 1
a26 4
BEGIN {
    $| = 1;
    print("1..32\n");   ### Number of tests that will be run ###
};
d28 6
a33 4
use threads;
use threads::shared;
ok(1, 1, 'Loaded');
$Base++;
d35 1
a35 1
### Start of Testing ###
a36 1
# test locking
d44 8
a51 8
        lock($lock);
        ok(1, 1, "set first lock");
        $tr = async {
            lock($lock);
            ok(3, 1, "set lock in subthread");
        };
        threads->yield;
        ok(2, 1, "still got lock");
d60 9
a68 9
        my $lockref = \$lock;
        lock($lockref);
        ok(1,1,"set first lockref");
        $tr = async {
            lock($lockref);
            ok(3,1,"set lockref in subthread");
        };
        threads->yield;
        ok(2,1,"still got lockref");
d76 23
a98 23
        lock($lock);
        ok(1,1,"set first recursive lock");
        lock($lock);
        threads->yield;
        {
            lock($lock);
            threads->yield;
        }
        $tr = async {
            lock($lock);
            ok(3,1,"set recursive lock in subthread");
        };
        {
            lock($lock);
            threads->yield;
            {
                lock($lock);
                threads->yield;
                lock($lock);
                threads->yield;
            }
        }
        ok(2,1,"still got recursive lock");
d104 1
a104 1
    # Make sure a lock factory gives out fresh locks each time
d123 6
a128 6
        ok(3,1,"lock factory: child: locking all locks");
        lock $locks2[0];
        lock $locks2[1];
        lock $locks2[2];
        lock $locks2[3];
        ok(4,1,"lock factory: child: locked all locks");
d131 1
a131 1

d135 1
a136 1
# test cond_signal()
d141 6
a146 6
        lock($lock);
        ok(1,1,"cond_signal: created first lock");
        my $tr2 = threads->create(\&bar);
        cond_wait($lock);
        $tr2->join();
        ok(5,1,"cond_signal: joined");
d150 5
a154 5
        ok(2,1,"cond_signal: child before lock");
        lock($lock);
        ok(3,1,"cond_signal: child locked");
        cond_signal($lock);
        ok(4,1,"cond_signal: signalled");
d166 6
a171 6
        lock($lockref);
        ok(1,1,"cond_signal: ref: created first lock");
        my $tr2 = threads->create(\&bar2);
        cond_wait($lockref);
        $tr2->join();
        ok(5,1,"cond_signal: ref: joined");
d175 5
a179 5
        ok(2,1,"cond_signal: ref: child before lock");
        lock($lockref);
        ok(3,1,"cond_signal: ref: child locked");
        cond_signal($lockref);
        ok(4,1,"cond_signal: ref: signalled");
d186 1
d191 1
d201 16
a216 16
        my $n = shift;
        my $th;
        {
            lock($counter);
            if ($n > 0) {
                $counter++;
                $th = threads->create(\&broad, $n-1);
                cond_wait($counter);
                $counter += 10;
            }
            else {
                ok(1, $counter == 3, "cond_broadcast: all three waiting");
                cond_broadcast($counter);
            }
        }
        $th->join if $th;
d219 1
a219 1
    threads->create(\&broad, 3)->join;
d221 1
d233 16
a248 16
        my $n = shift;
        my $th;
        {
            lock($r);
            if ($n > 0) {
                $$r++;
                $th = threads->create(\&broad2, $n-1);
                cond_wait($r);
                $$r += 10;
            }
            else {
                ok(1, $$r == 3, "cond_broadcast: ref: all three waiting");
                cond_broadcast($r);
            }
        }
        $th->join if $th;
d251 1
a251 1
    threads->create(\&broad2, 3)->join;;
d253 1
d256 1
d259 1
a260 1
# test warnings;
d280 2
a281 1
# EOF
@


