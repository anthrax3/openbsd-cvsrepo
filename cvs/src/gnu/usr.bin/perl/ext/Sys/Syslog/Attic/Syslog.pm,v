head	1.12;
access;
symbols
	OPENBSD_4_6:1.11.0.4
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.12
date	2009.10.12.18.24.34;	author millert;	state dead;
branches;
next	1.11;

1.11
date	2009.05.13.15.19.59;	author simon;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.06;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.04;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.15.21.30.28;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.09.18.09.23;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.33;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.24;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.17;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.30.04.44.01;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.30.04.40.42;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.06.16.09.24;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.09.24;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.22.59;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.43.53;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.08.09.17.46.28;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.17.01;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.48.22;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.24;	author millert;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Merge in perl 5.10.1
@
text
@package Sys::Syslog;
use strict;
use warnings;
use warnings::register;
use Carp;
use Exporter ();
use Fcntl qw(O_WRONLY);
use File::Basename;
use POSIX qw(strftime setlocale LC_TIME);
use Socket ':all';
require 5.005;

{   no strict 'vars';
    $VERSION = '0.27';
    @@ISA = qw(Exporter);

    %EXPORT_TAGS = (
        standard => [qw(openlog syslog closelog setlogmask)],
        extended => [qw(setlogsock)],
        macros => [
            # levels
            qw(
                LOG_ALERT LOG_CRIT LOG_DEBUG LOG_EMERG LOG_ERR 
                LOG_INFO LOG_NOTICE LOG_WARNING
            ), 

            # standard facilities
            qw(
                LOG_AUTH LOG_AUTHPRIV LOG_CRON LOG_DAEMON LOG_FTP LOG_KERN
                LOG_LOCAL0 LOG_LOCAL1 LOG_LOCAL2 LOG_LOCAL3 LOG_LOCAL4
                LOG_LOCAL5 LOG_LOCAL6 LOG_LOCAL7 LOG_LPR LOG_MAIL LOG_NEWS
                LOG_SYSLOG LOG_USER LOG_UUCP
            ),
            # Mac OS X specific facilities
            qw( LOG_INSTALL LOG_LAUNCHD LOG_NETINFO LOG_RAS LOG_REMOTEAUTH ),
            # modern BSD specific facilities
            qw( LOG_CONSOLE LOG_NTP LOG_SECURITY ),
            # IRIX specific facilities
            qw( LOG_AUDIT LOG_LFMT ),

            # options
            qw(
                LOG_CONS LOG_PID LOG_NDELAY LOG_NOWAIT LOG_ODELAY LOG_PERROR 
            ), 

            # others macros
            qw(
                LOG_FACMASK LOG_NFACILITIES LOG_PRIMASK 
                LOG_MASK LOG_UPTO
            ), 
        ],
    );

    @@EXPORT = (
        @@{$EXPORT_TAGS{standard}}, 
    );

    @@EXPORT_OK = (
        @@{$EXPORT_TAGS{extended}}, 
        @@{$EXPORT_TAGS{macros}}, 
    );

    eval {
        require XSLoader;
        XSLoader::load('Sys::Syslog', $VERSION);
        1
    } or do {
        require DynaLoader;
        push @@ISA, 'DynaLoader';
        bootstrap Sys::Syslog $VERSION;
    };
}


# 
# Public variables
# 
use vars qw($host);             # host to send syslog messages to (see notes at end)

#
# Prototypes
#
sub silent_eval (&);

# 
# Global variables
# 
use vars qw($facility);
my $connected = 0;              # flag to indicate if we're connected or not
my $syslog_send;                # coderef of the function used to send messages
my $syslog_path = undef;        # syslog path for "stream" and "unix" mechanisms
my $syslog_xobj = undef;        # if defined, holds the external object used to send messages
my $transmit_ok = 0;            # flag to indicate if the last message was transmited
my $sock_timeout  = 0;          # socket timeout, see below
my $current_proto = undef;      # current mechanism used to transmit messages
my $ident = '';                 # identifiant prepended to each message
$facility = '';                 # current facility
my $maskpri = LOG_UPTO(&LOG_DEBUG);     # current log mask

my %options = (
    ndelay  => 0, 
    nofatal => 0, 
    nowait  => 0, 
    perror  => 0, 
    pid     => 0, 
);

# Default is now to first use the native mechanism, so Perl programs 
# behave like other normal Unix programs, then try other mechanisms.
my @@connectMethods = qw(native tcp udp unix pipe stream console);
if ($^O =~ /^(freebsd|linux)$/) {
    @@connectMethods = grep { $_ ne 'udp' } @@connectMethods;
}

# And on Win32 systems, we try to use the native mechanism for this 
# platform, the events logger, available through Win32::EventLog.
EVENTLOG: {
    my $is_Win32 = $^O =~ /Win32/i;

    if (can_load("Sys::Syslog::Win32")) {
        unshift @@connectMethods, 'eventlog';
    }
    elsif ($is_Win32) {
        warn $@@;
    }
}

my @@defaultMethods = @@connectMethods;
my @@fallbackMethods = ();

# The timeout in connection_ok() was pushed up to 0.25 sec in 
# Sys::Syslog v0.19 in order to address a heisenbug on MacOSX:
# http://london.pm.org/pipermail/london.pm/Week-of-Mon-20061211/005961.html
# 
# However, this also had the effect of slowing this test for 
# all other operating systems, which apparently impacted some 
# users (cf. CPAN-RT #34753). So, in order to make everybody 
# happy, the timeout is now zero by default on all systems 
# except on OSX where it is set to 250 msec, and can be set 
# with the infamous setlogsock() function.
$sock_timeout = 0.25 if $^O =~ /darwin/;

# coderef for a nicer handling of errors
my $err_sub = $options{nofatal} ? \&warnings::warnif : \&croak;


sub AUTOLOAD {
    # This AUTOLOAD is used to 'autoload' constants from the constant()
    # XS function.
    no strict 'vars';
    my $constname;
    ($constname = $AUTOLOAD) =~ s/.*:://;
    croak "Sys::Syslog::constant() not defined" if $constname eq 'constant';
    my ($error, $val) = constant($constname);
    croak $error if $error;
    no strict 'refs';
    *$AUTOLOAD = sub { $val };
    goto &$AUTOLOAD;
}


sub openlog {
    ($ident, my $logopt, $facility) = @@_;

    # default values
    $ident    ||= basename($0) || getlogin() || getpwuid($<) || 'syslog';
    $logopt   ||= '';
    $facility ||= LOG_USER();

    for my $opt (split /\b/, $logopt) {
        $options{$opt} = 1 if exists $options{$opt}
    }

    $err_sub = delete $options{nofatal} ? \&warnings::warnif : \&croak;
    return 1 unless $options{ndelay};
    connect_log();
} 

sub closelog {
    $facility = $ident = '';
    disconnect_log();
} 

sub setlogmask {
    my $oldmask = $maskpri;
    $maskpri = shift unless $_[0] == 0;
    $oldmask;
}
 
sub setlogsock {
    my ($setsock, $setpath, $settime) = @@_;

    # check arguments
    my $diag_invalid_arg
        = "Invalid argument passed to setlogsock; must be 'stream', 'pipe', "
        . "'unix', 'native', 'eventlog', 'tcp', 'udp' or 'inet'";
    croak $diag_invalid_arg unless defined $setsock;
    croak "Invalid number of arguments" unless @@_ >= 1 and @@_ <= 3;

    $syslog_path  = $setpath if defined $setpath;
    $sock_timeout = $settime if defined $settime;

    disconnect_log() if $connected;
    $transmit_ok = 0;
    @@fallbackMethods = ();
    @@connectMethods = @@defaultMethods;

    if (ref $setsock eq 'ARRAY') {
	@@connectMethods = @@$setsock;

    } elsif (lc $setsock eq 'stream') {
	if (not defined $syslog_path) {
	    my @@try = qw(/dev/log /dev/conslog);

            if (length &_PATH_LOG) {        # Undefined _PATH_LOG is "".
		unshift @@try, &_PATH_LOG;
            }

	    for my $try (@@try) {
		if (-w $try) {
		    $syslog_path = $try;
		    last;
		}
	    }

            if (not defined $syslog_path) {
                warnings::warnif "stream passed to setlogsock, but could not find any device";
                return undef
            }
        }

	if (not -w $syslog_path) {
            warnings::warnif "stream passed to setlogsock, but $syslog_path is not writable";
	    return undef;
	} else {
            @@connectMethods = qw(stream);
	}

    } elsif (lc $setsock eq 'unix') {
        if (length _PATH_LOG() || (defined $syslog_path && -w $syslog_path)) {
	    $syslog_path = _PATH_LOG() unless defined $syslog_path;
            @@connectMethods = qw(unix);
        } else {
            warnings::warnif 'unix passed to setlogsock, but path not available';
	    return undef;
        }

    } elsif (lc $setsock eq 'pipe') {
        for my $path ($syslog_path, &_PATH_LOG, "/dev/log") {
            next unless defined $path and length $path and -p $path and -w _;
            $syslog_path = $path;
            last
        }

        if (not $syslog_path) {
            warnings::warnif "pipe passed to setlogsock, but path not available";
            return undef
        }

        @@connectMethods = qw(pipe);

    } elsif (lc $setsock eq 'native') {
        @@connectMethods = qw(native);

    } elsif (lc $setsock eq 'eventlog') {
        if (can_load("Win32::EventLog")) {
            @@connectMethods = qw(eventlog);
        } else {
            warnings::warnif "eventlog passed to setlogsock, but no Win32 API available";
            $@@ = "";
            return undef;
        }

    } elsif (lc $setsock eq 'tcp') {
	if (getservbyname('syslog', 'tcp') || getservbyname('syslogng', 'tcp')) {
            @@connectMethods = qw(tcp);
            $host = $syslog_path;
	} else {
            warnings::warnif "tcp passed to setlogsock, but tcp service unavailable";
	    return undef;
	}

    } elsif (lc $setsock eq 'udp') {
	if (getservbyname('syslog', 'udp')) {
            @@connectMethods = qw(udp);
            $host = $syslog_path;
	} else {
            warnings::warnif "udp passed to setlogsock, but udp service unavailable";
	    return undef;
	}

    } elsif (lc $setsock eq 'inet') {
	@@connectMethods = ( 'tcp', 'udp' );

    } elsif (lc $setsock eq 'console') {
	@@connectMethods = qw(console);

    } else {
        croak $diag_invalid_arg
    }

    return 1;
}

sub syslog {
    my $priority = shift;
    my $mask = shift;
    my ($message, $buf);
    my (@@words, $num, $numpri, $numfac, $sum);
    my $failed = undef;
    my $fail_time = undef;
    my $error = $!;

    # if $ident is undefined, it means openlog() wasn't previously called
    # so do it now in order to have sensible defaults
    openlog() unless $ident;

    local $facility = $facility;    # may need to change temporarily.

    croak "syslog: expecting argument \$priority" unless defined $priority;
    croak "syslog: expecting argument \$format"   unless defined $mask;

    croak "syslog: invalid level/facility: $priority" if $priority =~ /^-\d+$/;
    @@words = split(/\W+/, $priority, 2);    # Allow "level" or "level|facility".
    undef $numpri;
    undef $numfac;

    for my $word (@@words) {
        next if length $word == 0;

        $num = xlate($word);        # Translate word to number.

        if ($num < 0) {
            croak "syslog: invalid level/facility: $word"
        }
        elsif ($num <= &LOG_PRIMASK) {
            croak "syslog: too many levels given: $word" if defined $numpri;
            $numpri = $num;
            return 0 unless LOG_MASK($numpri) & $maskpri;
        }
        else {
            croak "syslog: too many facilities given: $word" if defined $numfac;
            $facility = $word;
            $numfac = $num;
        }
    }

    croak "syslog: level must be given" unless defined $numpri;

    if (not defined $numfac) {  # Facility not specified in this call.
	$facility = 'user' unless $facility;
	$numfac = xlate($facility);
    }

    connect_log() unless $connected;

    if ($mask =~ /%m/) {
        # escape percent signs for sprintf()
        $error =~ s/%/%%/g if @@_;
        # replace %m with $error, if preceded by an even number of percent signs
        $mask =~ s/(?<!%)((?:%%)*)%m/$1$error/g;
    }

    $mask .= "\n" unless $mask =~ /\n$/;
    $message = @@_ ? sprintf($mask, @@_) : $mask;

    # See CPAN-RT#24431. Opened on Apple Radar as bug #4944407 on 2007.01.21
    # Supposedly resolved on Leopard.
    chomp $message if $^O =~ /darwin/;

    if ($current_proto eq 'native') {
        $buf = $message;
    }
    elsif ($current_proto eq 'eventlog') {
        $buf = $message;
    }
    else {
        my $whoami = $ident;
        $whoami .= "[$$]" if $options{pid};

        $sum = $numpri + $numfac;
        my $oldlocale = setlocale(LC_TIME);
        setlocale(LC_TIME, 'C');
        my $timestamp = strftime "%b %e %T", localtime;
        setlocale(LC_TIME, $oldlocale);
        $buf = "<$sum>$timestamp $whoami: $message\0";
    }

    # handle PERROR option
    # "native" mechanism already handles it by itself
    if ($options{perror} and $current_proto ne 'native') {
        chomp $message;
        my $whoami = $ident;
        $whoami .= "[$$]" if $options{pid};
        print STDERR "$whoami: $message\n";
    }

    # it's possible that we'll get an error from sending
    # (e.g. if method is UDP and there is no UDP listener,
    # then we'll get ECONNREFUSED on the send). So what we
    # want to do at this point is to fallback onto a different
    # connection method.
    while (scalar @@fallbackMethods || $syslog_send) {
	if ($failed && (time - $fail_time) > 60) {
	    # it's been a while... maybe things have been fixed
	    @@fallbackMethods = ();
	    disconnect_log();
	    $transmit_ok = 0; # make it look like a fresh attempt
	    connect_log();
        }

	if ($connected && !connection_ok()) {
	    # Something was OK, but has now broken. Remember coz we'll
	    # want to go back to what used to be OK.
	    $failed = $current_proto unless $failed;
	    $fail_time = time;
	    disconnect_log();
	}

	connect_log() unless $connected;
	$failed = undef if ($current_proto && $failed && $current_proto eq $failed);

	if ($syslog_send) {
            if ($syslog_send->($buf, $numpri, $numfac)) {
		$transmit_ok++;
		return 1;
	    }
	    # typically doesn't happen, since errors are rare from write().
	    disconnect_log();
	}
    }
    # could not send, could not fallback onto a working
    # connection method. Lose.
    return 0;
}

sub _syslog_send_console {
    my ($buf) = @@_;
    chop($buf); # delete the NUL from the end
    # The console print is a method which could block
    # so we do it in a child process and always return success
    # to the caller.
    if (my $pid = fork) {

	if ($options{nowait}) {
	    return 1;
	} else {
	    if (waitpid($pid, 0) >= 0) {
	    	return ($? >> 8);
	    } else {
		# it's possible that the caller has other
		# plans for SIGCHLD, so let's not interfere
		return 1;
	    }
	}
    } else {
        if (open(CONS, ">/dev/console")) {
	    my $ret = print CONS $buf . "\r";  # XXX: should this be \x0A ?
	    exit $ret if defined $pid;
	    close CONS;
	}
	exit if defined $pid;
    }
}

sub _syslog_send_stream {
    my ($buf) = @@_;
    # XXX: this only works if the OS stream implementation makes a write 
    # look like a putmsg() with simple header. For instance it works on 
    # Solaris 8 but not Solaris 7.
    # To be correct, it should use a STREAMS API, but perl doesn't have one.
    return syswrite(SYSLOG, $buf, length($buf));
}

sub _syslog_send_pipe {
    my ($buf) = @@_;
    return print SYSLOG $buf;
}

sub _syslog_send_socket {
    my ($buf) = @@_;
    return syswrite(SYSLOG, $buf, length($buf));
    #return send(SYSLOG, $buf, 0);
}

sub _syslog_send_native {
    my ($buf, $numpri) = @@_;
    syslog_xs($numpri, $buf);
    return 1;
}


# xlate()
# -----
# private function to translate names to numeric values
# 
sub xlate {
    my ($name) = @@_;

    return $name+0 if $name =~ /^\s*\d+\s*$/;
    $name = uc $name;
    $name = "LOG_$name" unless $name =~ /^LOG_/;

    # ExtUtils::Constant 0.20 introduced a new way to implement
    # constants, called ProxySubs.  When it was used to generate
    # the C code, the constant() function no longer returns the 
    # correct value.  Therefore, we first try a direct call to 
    # constant(), and if the value is an error we try to call the 
    # constant by its full name. 
    my $value = constant($name);

    if (index($value, "not a valid") >= 0) {
        $name = "Sys::Syslog::$name";
        $value = eval { no strict "refs"; &$name };
        $value = $@@ unless defined $value;
    }

    $value = -1 if index($value, "not a valid") >= 0;

    return defined $value ? $value : -1;
}


# connect_log()
# -----------
# This function acts as a kind of front-end: it tries to connect to 
# a syslog service using the selected methods, trying each one in the 
# selected order. 
# 
sub connect_log {
    @@fallbackMethods = @@connectMethods unless scalar @@fallbackMethods;

    if ($transmit_ok && $current_proto) {
        # Retry what we were on, because it has worked in the past.
	unshift(@@fallbackMethods, $current_proto);
    }

    $connected = 0;
    my @@errs = ();
    my $proto = undef;

    while ($proto = shift @@fallbackMethods) {
	no strict 'refs';
	my $fn = "connect_$proto";
	$connected = &$fn(\@@errs) if defined &$fn;
	last if $connected;
    }

    $transmit_ok = 0;
    if ($connected) {
	$current_proto = $proto;
        my ($old) = select(SYSLOG); $| = 1; select($old);
    } else {
	@@fallbackMethods = ();
        $err_sub->(join "\n\t- ", "no connection to syslog available", @@errs);
        return undef;
    }
}

sub connect_tcp {
    my ($errs) = @@_;

    my $tcp = getprotobyname('tcp');
    if (!defined $tcp) {
	push @@$errs, "getprotobyname failed for tcp";
	return 0;
    }

    my $syslog = getservbyname('syslog', 'tcp');
    $syslog = getservbyname('syslogng', 'tcp') unless defined $syslog;
    if (!defined $syslog) {
	push @@$errs, "getservbyname failed for syslog/tcp and syslogng/tcp";
	return 0;
    }

    my $addr;
    if (defined $host) {
        $addr = inet_aton($host);
        if (!$addr) {
	    push @@$errs, "can't lookup $host";
	    return 0;
	}
    } else {
        $addr = INADDR_LOOPBACK;
    }
    $addr = sockaddr_in($syslog, $addr);

    if (!socket(SYSLOG, AF_INET, SOCK_STREAM, $tcp)) {
	push @@$errs, "tcp socket: $!";
	return 0;
    }

    setsockopt(SYSLOG, SOL_SOCKET, SO_KEEPALIVE, 1);
    if (silent_eval { IPPROTO_TCP() }) {
        # These constants don't exist in 5.005. They were added in 1999
        setsockopt(SYSLOG, IPPROTO_TCP(), TCP_NODELAY(), 1);
    }
    if (!connect(SYSLOG, $addr)) {
	push @@$errs, "tcp connect: $!";
	return 0;
    }

    $syslog_send = \&_syslog_send_socket;

    return 1;
}

sub connect_udp {
    my ($errs) = @@_;

    my $udp = getprotobyname('udp');
    if (!defined $udp) {
	push @@$errs, "getprotobyname failed for udp";
	return 0;
    }

    my $syslog = getservbyname('syslog', 'udp');
    if (!defined $syslog) {
	push @@$errs, "getservbyname failed for syslog/udp";
	return 0;
    }

    my $addr;
    if (defined $host) {
        $addr = inet_aton($host);
        if (!$addr) {
	    push @@$errs, "can't lookup $host";
	    return 0;
	}
    } else {
        $addr = INADDR_LOOPBACK;
    }
    $addr = sockaddr_in($syslog, $addr);

    if (!socket(SYSLOG, AF_INET, SOCK_DGRAM, $udp)) {
	push @@$errs, "udp socket: $!";
	return 0;
    }
    if (!connect(SYSLOG, $addr)) {
	push @@$errs, "udp connect: $!";
	return 0;
    }

    # We want to check that the UDP connect worked. However the only
    # way to do that is to send a message and see if an ICMP is returned
    _syslog_send_socket("");
    if (!connection_ok()) {
	push @@$errs, "udp connect: nobody listening";
	return 0;
    }

    $syslog_send = \&_syslog_send_socket;

    return 1;
}

sub connect_stream {
    my ($errs) = @@_;
    # might want syslog_path to be variable based on syslog.h (if only
    # it were in there!)
    $syslog_path = '/dev/conslog' unless defined $syslog_path; 
    if (!-w $syslog_path) {
	push @@$errs, "stream $syslog_path is not writable";
	return 0;
    }
    if (!sysopen(SYSLOG, $syslog_path, O_WRONLY, 0400)) {
	push @@$errs, "stream can't open $syslog_path: $!";
	return 0;
    }
    $syslog_send = \&_syslog_send_stream;
    return 1;
}

sub connect_pipe {
    my ($errs) = @@_;

    $syslog_path ||= &_PATH_LOG || "/dev/log";

    if (not -w $syslog_path) {
        push @@$errs, "$syslog_path is not writable";
        return 0;
    }

    if (not open(SYSLOG, ">$syslog_path")) {
        push @@$errs, "can't write to $syslog_path: $!";
        return 0;
    }

    $syslog_send = \&_syslog_send_pipe;

    return 1;
}

sub connect_unix {
    my ($errs) = @@_;

    $syslog_path ||= _PATH_LOG() if length _PATH_LOG();

    if (not defined $syslog_path) {
        push @@$errs, "_PATH_LOG not available in syslog.h and no user-supplied socket path";
	return 0;
    }

    if (not (-S $syslog_path or -c _)) {
        push @@$errs, "$syslog_path is not a socket";
	return 0;
    }

    my $addr = sockaddr_un($syslog_path);
    if (!$addr) {
	push @@$errs, "can't locate $syslog_path";
	return 0;
    }
    if (!socket(SYSLOG, AF_UNIX, SOCK_STREAM, 0)) {
        push @@$errs, "unix stream socket: $!";
	return 0;
    }

    if (!connect(SYSLOG, $addr)) {
        if (!socket(SYSLOG, AF_UNIX, SOCK_DGRAM, 0)) {
	    push @@$errs, "unix dgram socket: $!";
	    return 0;
	}
        if (!connect(SYSLOG, $addr)) {
	    push @@$errs, "unix dgram connect: $!";
	    return 0;
	}
    }

    $syslog_send = \&_syslog_send_socket;

    return 1;
}

sub connect_native {
    my ($errs) = @@_;
    my $logopt = 0;

    # reconstruct the numeric equivalent of the options
    for my $opt (keys %options) {
        $logopt += xlate($opt) if $options{$opt}
    }

    openlog_xs($ident, $logopt, xlate($facility));
    $syslog_send = \&_syslog_send_native;

    return 1;
}

sub connect_eventlog {
    my ($errs) = @@_;

    $syslog_xobj = Sys::Syslog::Win32::_install();
    $syslog_send = \&Sys::Syslog::Win32::_syslog_send;

    return 1;
}

sub connect_console {
    my ($errs) = @@_;
    if (!-w '/dev/console') {
	push @@$errs, "console is not writable";
	return 0;
    }
    $syslog_send = \&_syslog_send_console;
    return 1;
}

# To test if the connection is still good, we need to check if any
# errors are present on the connection. The errors will not be raised
# by a write. Instead, sockets are made readable and the next read
# would cause the error to be returned. Unfortunately the syslog 
# 'protocol' never provides anything for us to read. But with 
# judicious use of select(), we can see if it would be readable...
sub connection_ok {
    return 1 if defined $current_proto and (
        $current_proto eq 'native' or $current_proto eq 'console'
        or $current_proto eq 'eventlog'
    );

    my $rin = '';
    vec($rin, fileno(SYSLOG), 1) = 1;
    my $ret = select $rin, undef, $rin, $sock_timeout;
    return ($ret ? 0 : 1);
}

sub disconnect_log {
    $connected = 0;
    $syslog_send = undef;

    if (defined $current_proto and $current_proto eq 'native') {
        closelog_xs();
        return 1;
    }
    elsif (defined $current_proto and $current_proto eq 'eventlog') {
        $syslog_xobj->Close();
        return 1;
    }

    return close SYSLOG;
}


#
# Wrappers around eval() that makes sure that nobody, and I say NOBODY, 
# ever knows that I wanted to test if something was here or not. 
# It is needed because some applications are trying to be too smart,
# do it wrong, and it ends up in EPIC FAIL. 
# Yes I'm speaking of YOU, SpamAssassin.
#
sub silent_eval (&) {
    local($SIG{__DIE__}, $SIG{__WARN__}, $@@);
    return eval { $_[0]->() }
}

sub can_load {
    local($SIG{__DIE__}, $SIG{__WARN__}, $@@);
    return eval "use $_[0]; 1"
}


"Eighth Rule: read the documentation."

__END__

=head1 NAME

Sys::Syslog - Perl interface to the UNIX syslog(3) calls

=head1 VERSION

Version 0.27

=head1 SYNOPSIS

    use Sys::Syslog;                          # all except setlogsock(), or:
    use Sys::Syslog qw(:DEFAULT setlogsock);  # default set, plus setlogsock()
    use Sys::Syslog qw(:standard :macros);    # standard functions, plus macros

    openlog $ident, $logopt, $facility;       # don't forget this
    syslog $priority, $format, @@args;
    $oldmask = setlogmask $mask_priority;
    closelog;


=head1 DESCRIPTION

C<Sys::Syslog> is an interface to the UNIX C<syslog(3)> program.
Call C<syslog()> with a string priority and a list of C<printf()> args
just like C<syslog(3)>.

You can find a kind of FAQ in L<"THE RULES OF SYS::SYSLOG">.  Please read 
it before coding, and again before asking questions. 


=head1 EXPORTS

C<Sys::Syslog> exports the following C<Exporter> tags: 

=over 4

=item *

C<:standard> exports the standard C<syslog(3)> functions: 

    openlog closelog setlogmask syslog

=item *

C<:extended> exports the Perl specific functions for C<syslog(3)>: 

    setlogsock

=item *

C<:macros> exports the symbols corresponding to most of your C<syslog(3)> 
macros and the C<LOG_UPTO()> and C<LOG_MASK()> functions. 
See L<"CONSTANTS"> for the supported constants and their meaning. 

=back

By default, C<Sys::Syslog> exports the symbols from the C<:standard> tag. 


=head1 FUNCTIONS

=over 4

=item B<openlog($ident, $logopt, $facility)>

Opens the syslog.
C<$ident> is prepended to every message.  C<$logopt> contains zero or
more of the options detailed below.  C<$facility> specifies the part 
of the system to report about, for example C<LOG_USER> or C<LOG_LOCAL0>:
see L<"Facilities"> for a list of well-known facilities, and your 
C<syslog(3)> documentation for the facilities available in your system. 
Check L<"SEE ALSO"> for useful links. Facility can be given as a string 
or a numeric macro. 

This function will croak if it can't connect to the syslog daemon.

Note that C<openlog()> now takes three arguments, just like C<openlog(3)>.

B<You should use C<openlog()> before calling C<syslog()>.>

B<Options>

=over 4

=item *

C<cons> - This option is ignored, since the failover mechanism will drop 
down to the console automatically if all other media fail.

=item *

C<ndelay> - Open the connection immediately (normally, the connection is
opened when the first message is logged).

=item *

C<nofatal> - When set to true, C<openlog()> and C<syslog()> will only 
emit warnings instead of dying if the connection to the syslog can't 
be established. 

=item *

C<nowait> - Don't wait for child processes that may have been created 
while logging the message.  (The GNU C library does not create a child
process, so this option has no effect on Linux.)

=item *

C<perror> - Write the message to standard error output as well to the
system log.

=item *

C<pid> - Include PID with each message.

=back

B<Examples>

Open the syslog with options C<ndelay> and C<pid>, and with facility C<LOCAL0>: 

    openlog($name, "ndelay,pid", "local0");

Same thing, but this time using the macro corresponding to C<LOCAL0>: 

    openlog($name, "ndelay,pid", LOG_LOCAL0);


=item B<syslog($priority, $message)>

=item B<syslog($priority, $format, @@args)>

If C<$priority> permits, logs C<$message> or C<sprintf($format, @@args)>
with the addition that C<%m> in $message or C<$format> is replaced with
C<"$!"> (the latest error message). 

C<$priority> can specify a level, or a level and a facility.  Levels and 
facilities can be given as strings or as macros.  When using the C<eventlog>
mechanism, priorities C<DEBUG> and C<INFO> are mapped to event type 
C<informational>, C<NOTICE> and C<WARNIN> to C<warning> and C<ERR> to 
C<EMERG> to C<error>.

If you didn't use C<openlog()> before using C<syslog()>, C<syslog()> will 
try to guess the C<$ident> by extracting the shortest prefix of 
C<$format> that ends in a C<":">.

B<Examples>

    syslog("info", $message);           # informational level
    syslog(LOG_INFO, $message);         # informational level

    syslog("info|local0", $message);        # information level, Local0 facility
    syslog(LOG_INFO|LOG_LOCAL0, $message);  # information level, Local0 facility

=over 4

=item B<Note>

C<Sys::Syslog> version v0.07 and older passed the C<$message> as the 
formatting string to C<sprintf()> even when no formatting arguments
were provided.  If the code calling C<syslog()> might execute with 
older versions of this module, make sure to call the function as
C<syslog($priority, "%s", $message)> instead of C<syslog($priority,
$message)>.  This protects against hostile formatting sequences that
might show up if $message contains tainted data.

=back


=item B<setlogmask($mask_priority)>

Sets the log mask for the current process to C<$mask_priority> and 
returns the old mask.  If the mask argument is 0, the current log mask 
is not modified.  See L<"Levels"> for the list of available levels. 
You can use the C<LOG_UPTO()> function to allow all levels up to a 
given priority (but it only accept the numeric macros as arguments).

B<Examples>

Only log errors: 

    setlogmask( LOG_MASK(LOG_ERR) );

Log everything except informational messages: 

    setlogmask( ~(LOG_MASK(LOG_INFO)) );

Log critical messages, errors and warnings: 

    setlogmask( LOG_MASK(LOG_CRIT) | LOG_MASK(LOG_ERR) | LOG_MASK(LOG_WARNING) );

Log all messages up to debug: 

    setlogmask( LOG_UPTO(LOG_DEBUG) );


=item B<setlogsock($sock_type)>

=item B<setlogsock($sock_type, $stream_location)> (added in Perl 5.004_02)

=item B<setlogsock($sock_type, $stream_location, $sock_timeout)> (added in 0.25)

Sets the socket type to be used for the next call to
C<openlog()> or C<syslog()> and returns true on success,
C<undef> on failure. The available mechanisms are: 

=over

=item *

C<"native"> - use the native C functions from your C<syslog(3)> library
(added in C<Sys::Syslog> 0.15).

=item *

C<"eventlog"> - send messages to the Win32 events logger (Win32 only; 
added in C<Sys::Syslog> 0.19).

=item *

C<"tcp"> - connect to a TCP socket, on the C<syslog/tcp> or C<syslogng/tcp> 
service. If defined, the second parameter is used as a hostname to connect to.

=item *

C<"udp"> - connect to a UDP socket, on the C<syslog/udp> service.
If defined, the second parameter is used as a hostname to connect to, 
and the third parameter as the timeout used to check for UDP response. 

=item *

C<"inet"> - connect to an INET socket, either TCP or UDP, tried in that 
order.  If defined, the second parameter is used as a hostname to connect to.

=item *

C<"unix"> - connect to a UNIX domain socket (in some systems a character 
special device).  The name of that socket is the second parameter or, if 
you omit the second parameter, the value returned by the C<_PATH_LOG> macro 
(if your system defines it), or F</dev/log> or F</dev/conslog>, whatever is 
writable.  

=item *

C<"stream"> - connect to the stream indicated by the pathname provided as 
the optional second parameter, or, if omitted, to F</dev/conslog>. 
For example Solaris and IRIX system may prefer C<"stream"> instead of C<"unix">. 

=item *

C<"pipe"> - connect to the named pipe indicated by the pathname provided as 
the optional second parameter, or, if omitted, to the value returned by 
the C<_PATH_LOG> macro (if your system defines it), or F</dev/log>
(added in C<Sys::Syslog> 0.21).

=item *

C<"console"> - send messages directly to the console, as for the C<"cons"> 
option of C<openlog()>.

=back

A reference to an array can also be passed as the first parameter.
When this calling method is used, the array should contain a list of
mechanisms which are attempted in order.

The default is to try C<native>, C<tcp>, C<udp>, C<unix>, C<pipe>, C<stream>, 
C<console>.
Under systems with the Win32 API, C<eventlog> will be added as the first 
mechanism to try if C<Win32::EventLog> is available.

Giving an invalid value for C<$sock_type> will C<croak>.

B<Examples>

Select the UDP socket mechanism: 

    setlogsock("udp");

Select the native, UDP socket then UNIX domain socket mechanisms: 

    setlogsock(["native", "udp", "unix"]);

=over

=item B<Note>

Now that the "native" mechanism is supported by C<Sys::Syslog> and selected 
by default, the use of the C<setlogsock()> function is discouraged because 
other mechanisms are less portable across operating systems.  Authors of 
modules and programs that use this function, especially its cargo-cult form 
C<setlogsock("unix")>, are advised to remove any occurence of it unless they 
specifically want to use a given mechanism (like TCP or UDP to connect to 
a remote host).

=back

=item B<closelog()>

Closes the log file and returns true on success.

=back


=head1 THE RULES OF SYS::SYSLOG

I<The First Rule of Sys::Syslog is:>
You do not call C<setlogsock>.

I<The Second Rule of Sys::Syslog is:>
You B<do not> call C<setlogsock>.

I<The Third Rule of Sys::Syslog is:>
The program crashes, C<die>s, calls C<closelog>, the log is over.

I<The Fourth Rule of Sys::Syslog is:>
One facility, one priority.

I<The Fifth Rule of Sys::Syslog is:>
One log at a time.

I<The Sixth Rule of Sys::Syslog is:>
No C<syslog> before C<openlog>.

I<The Seventh Rule of Sys::Syslog is:>
Logs will go on as long as they have to. 

I<The Eighth, and Final Rule of Sys::Syslog is:>
If this is your first use of Sys::Syslog, you must read the doc.


=head1 EXAMPLES

An example:

    openlog($program, 'cons,pid', 'user');
    syslog('info', '%s', 'this is another test');
    syslog('mail|warning', 'this is a better test: %d', time);
    closelog();

    syslog('debug', 'this is the last test');

Another example:

    openlog("$program $$", 'ndelay', 'user');
    syslog('notice', 'fooprogram: this is really done');

Example of use of C<%m>:

    $! = 55;
    syslog('info', 'problem was %m');   # %m == $! in syslog(3)

Log to UDP port on C<$remotehost> instead of logging locally:

    setlogsock("udp", $remotehost);
    openlog($program, 'ndelay', 'user');
    syslog('info', 'something happened over here');


=head1 CONSTANTS

=head2 Facilities

=over 4

=item *

C<LOG_AUDIT> - audit daemon (IRIX); falls back to C<LOG_AUTH>

=item *

C<LOG_AUTH> - security/authorization messages

=item *

C<LOG_AUTHPRIV> - security/authorization messages (private)

=item *

C<LOG_CONSOLE> - C</dev/console> output (FreeBSD); falls back to C<LOG_USER>

=item *

C<LOG_CRON> - clock daemons (B<cron> and B<at>)

=item *

C<LOG_DAEMON> - system daemons without separate facility value

=item *

C<LOG_FTP> - FTP daemon

=item *

C<LOG_KERN> - kernel messages

=item *

C<LOG_INSTALL> - installer subsystem (Mac OS X); falls back to C<LOG_USER>

=item *

C<LOG_LAUNCHD> - launchd - general bootstrap daemon (Mac OS X);
falls back to C<LOG_DAEMON>

=item *

C<LOG_LFMT> - logalert facility; falls back to C<LOG_USER>

=item *

C<LOG_LOCAL0> through C<LOG_LOCAL7> - reserved for local use

=item *

C<LOG_LPR> - line printer subsystem

=item *

C<LOG_MAIL> - mail subsystem

=item *

C<LOG_NETINFO> - NetInfo subsystem (Mac OS X); falls back to C<LOG_DAEMON>

=item *

C<LOG_NEWS> - USENET news subsystem

=item *

C<LOG_NTP> - NTP subsystem (FreeBSD, NetBSD); falls back to C<LOG_DAEMON>

=item *

C<LOG_RAS> - Remote Access Service (VPN / PPP) (Mac OS X);
falls back to C<LOG_AUTH>

=item *

C<LOG_REMOTEAUTH> - remote authentication/authorization (Mac OS X);
falls back to C<LOG_AUTH>

=item *

C<LOG_SECURITY> - security subsystems (firewalling, etc.) (FreeBSD);
falls back to C<LOG_AUTH>

=item *

C<LOG_SYSLOG> - messages generated internally by B<syslogd>

=item *

C<LOG_USER> (default) - generic user-level messages

=item *

C<LOG_UUCP> - UUCP subsystem

=back


=head2 Levels

=over 4

=item *

C<LOG_EMERG> - system is unusable

=item *

C<LOG_ALERT> - action must be taken immediately

=item *

C<LOG_CRIT> - critical conditions

=item *

C<LOG_ERR> - error conditions

=item *

C<LOG_WARNING> - warning conditions

=item *

C<LOG_NOTICE> - normal, but significant, condition

=item *

C<LOG_INFO> - informational message

=item *

C<LOG_DEBUG> - debug-level message

=back


=head1 DIAGNOSTICS

=over

=item C<Invalid argument passed to setlogsock>

B<(F)> You gave C<setlogsock()> an invalid value for C<$sock_type>. 

=item C<eventlog passed to setlogsock, but no Win32 API available>

B<(W)> You asked C<setlogsock()> to use the Win32 event logger but the 
operating system running the program isn't Win32 or does not provides Win32
compatible facilities.

=item C<no connection to syslog available>

B<(F)> C<syslog()> failed to connect to the specified socket.

=item C<stream passed to setlogsock, but %s is not writable>

B<(W)> You asked C<setlogsock()> to use a stream socket, but the given 
path is not writable. 

=item C<stream passed to setlogsock, but could not find any device>

B<(W)> You asked C<setlogsock()> to use a stream socket, but didn't 
provide a path, and C<Sys::Syslog> was unable to find an appropriate one.

=item C<tcp passed to setlogsock, but tcp service unavailable>

B<(W)> You asked C<setlogsock()> to use a TCP socket, but the service 
is not available on the system. 

=item C<syslog: expecting argument %s>

B<(F)> You forgot to give C<syslog()> the indicated argument.

=item C<syslog: invalid level/facility: %s>

B<(F)> You specified an invalid level or facility.

=item C<syslog: too many levels given: %s>

B<(F)> You specified too many levels. 

=item C<syslog: too many facilities given: %s>

B<(F)> You specified too many facilities. 

=item C<syslog: level must be given>

B<(F)> You forgot to specify a level.

=item C<udp passed to setlogsock, but udp service unavailable>

B<(W)> You asked C<setlogsock()> to use a UDP socket, but the service 
is not available on the system. 

=item C<unix passed to setlogsock, but path not available>

B<(W)> You asked C<setlogsock()> to use a UNIX socket, but C<Sys::Syslog> 
was unable to find an appropriate an appropriate device.

=back


=head1 SEE ALSO

=head2 Manual Pages

L<syslog(3)>

SUSv3 issue 6, IEEE Std 1003.1, 2004 edition, 
L<http://www.opengroup.org/onlinepubs/000095399/basedefs/syslog.h.html>

GNU C Library documentation on syslog, 
L<http://www.gnu.org/software/libc/manual/html_node/Syslog.html>

Solaris 10 documentation on syslog, 
L<http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view>

Mac OS X documentation on syslog,
L<http://developer.apple.com/documentation/Darwin/Reference/ManPages/man3/syslog.3.html>

IRIX 6.5 documentation on syslog,
L<http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&db=man&fname=3c+syslog>

AIX 5L 5.3 documentation on syslog, 
L<http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm>

HP-UX 11i documentation on syslog, 
L<http://docs.hp.com/en/B2355-60130/syslog.3C.html>

Tru64 5.1 documentation on syslog, 
L<http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM>

Stratus VOS 15.1, 
L<http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&file=ch5r502-01bi.html>

=head2 RFCs

I<RFC 3164 - The BSD syslog Protocol>, L<http://www.faqs.org/rfcs/rfc3164.html>
-- Please note that this is an informational RFC, and therefore does not 
specify a standard of any kind.

I<RFC 3195 - Reliable Delivery for syslog>, L<http://www.faqs.org/rfcs/rfc3195.html>

=head2 Articles

I<Syslogging with Perl>, L<http://lexington.pm.org/meetings/022001.html>

=head2 Event Log

Windows Event Log,
L<http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp>


=head1 AUTHORS & ACKNOWLEDGEMENTS

Tom Christiansen E<lt>F<tchrist (at) perl.com>E<gt> and Larry Wall
E<lt>F<larry (at) wall.org>E<gt>.

UNIX domain sockets added by Sean Robinson
E<lt>F<robinson_s (at) sc.maricopa.edu>E<gt> with support from Tim Bunce 
E<lt>F<Tim.Bunce (at) ig.co.uk>E<gt> and the C<perl5-porters> mailing list.

Dependency on F<syslog.ph> replaced with XS code by Tom Hughes
E<lt>F<tom (at) compton.nu>E<gt>.

Code for C<constant()>s regenerated by Nicholas Clark E<lt>F<nick (at) ccl4.org>E<gt>.

Failover to different communication modes by Nick Williams
E<lt>F<Nick.Williams (at) morganstanley.com>E<gt>.

Extracted from core distribution for publishing on the CPAN by 
SE<eacute>bastien Aperghis-Tramoni E<lt>sebastien (at) aperghis.netE<gt>.

XS code for using native C functions borrowed from C<L<Unix::Syslog>>, 
written by Marcus Harnisch E<lt>F<marcus.harnisch (at) gmx.net>E<gt>.

Yves Orton suggested and helped for making C<Sys::Syslog> use the native 
event logger under Win32 systems.

Jerry D. Hedden and Reini Urban provided greatly appreciated help to 
debug and polish C<Sys::Syslog> under Cygwin.


=head1 BUGS

Please report any bugs or feature requests to
C<bug-sys-syslog (at) rt.cpan.org>, or through the web interface at
L<http://rt.cpan.org/Public/Dist/Display.html?Name=Sys-Syslog>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.


=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Sys::Syslog

You can also look for information at:

=over 4

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Sys-Syslog>

=item * CPAN Ratings

L<http://cpanratings.perl.org/d/Sys-Syslog>

=item * RT: CPAN's request tracker

L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Sys-Syslog>

=item * Search CPAN

L<http://search.cpan.org/dist/Sys-Syslog/>

=item * Kobes' CPAN Search

L<http://cpan.uwinnipeg.ca/dist/Sys-Syslog>

=item * Perl Documentation

L<http://perldoc.perl.org/Sys/Syslog.html>

=back


=head1 COPYRIGHT

Copyright (C) 1990-2008 by Larry Wall and others.


=head1 LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

=begin comment

Notes for the future maintainer (even if it's still me..)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Using Google Code Search, I search who on Earth was relying on $host being 
public. It found 5 hits: 

* First was inside Indigo Star Perl2exe documentation. Just an old version 
of Sys::Syslog. 


* One real hit was inside DalWeathDB, a weather related program. It simply 
does a 

    $Sys::Syslog::host = '127.0.0.1';

- L<http://www.gallistel.net/nparker/weather/code/>


* Two hits were in TPC, a fax server thingy. It does a 

    $Sys::Syslog::host = $TPC::LOGHOST;

but also has this strange piece of code:

    # work around perl5.003 bug
    sub Sys::Syslog::hostname {}

I don't know what bug the author referred to.

- L<http://www.tpc.int/>
- L<ftp://ftp.tpc.int/tpc/server/UNIX/>
- L<ftp://ftp-usa.tpc.int/pub/tpc/server/UNIX/>


* Last hit was in Filefix, which seems to be a FIDOnet mail program (!).
This one does not use $host, but has the following piece of code:

    sub Sys::Syslog::hostname
    {
        use Sys::Hostname;
        return hostname;
    }

I guess this was a more elaborate form of the previous bit, maybe because 
of a bug in Sys::Syslog back then?

- L<ftp://ftp.kiae.su/pub/unix/fido/>


Links
-----
Linux Fast-STREAMS
- L<http://www.openss7.org/streams.html>

II12021: SYSLOGD HOWTO TCPIPINFO (z/OS, OS/390, MVS)
- L<http://www-1.ibm.com/support/docview.wss?uid=isg1II12021>

Getting the most out of the Event Viewer
- L<http://www.codeproject.com/dotnet/evtvwr.asp?print=true>

Log events to the Windows NT Event Log with JNI
- L<http://www.javaworld.com/javaworld/jw-09-2001/jw-0928-ntmessages.html>

=end comment

@


1.11
log
@update Sys::Syslog to CPAN version 0.27

testing by sthen@@ and jasper@@, thanks!
ok millert@@, jasper@@
@
text
@@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 1
d6 1
a11 1
require Exporter;
d14 1
a14 1
    $VERSION = '0.22';
d80 5
d94 1
d115 2
a117 1
    # use EventLog on Win32
d120 1
a120 5
    # some applications are trying to be too smart
    # yes I'm speaking of YOU, SpamAssassin, grr..
    local($SIG{__DIE__}, $SIG{__WARN__}, $@@);

    if (eval "use Sys::Syslog::Win32; 1") {
d131 12
d174 1
a174 1
    $err_sub = $options{nofatal} ? \&warnings::warnif : \&croak;
d191 12
a202 2
    my $setsock = shift;
    $syslog_path = shift;
d250 1
a250 1
            next unless defined $path and length $path and -w $path;
d266 1
a266 1
        if (eval "use Win32::EventLog; 1") {
d277 1
d286 1
d299 1
a299 2
        croak "Invalid argument passed to setlogsock; must be 'stream', 'pipe', ",
              "'unix', 'native', 'eventlog', 'tcp', 'udp' or 'inet'"
d323 1
d328 18
a345 15
    foreach (@@words) {
	$num = xlate($_);		    # Translate word to number.
	if ($num < 0) {
	    croak "syslog: invalid level/facility: $_"
	}
	elsif ($num <= &LOG_PRIMASK) {
	    croak "syslog: too many levels given: $_" if defined $numpri;
	    $numpri = $num;
	    return 0 unless LOG_MASK($numpri) & $maskpri;
	}
	else {
	    croak "syslog: too many facilities given: $_" if defined $numfac;
	    $facility = $_;
	    $numfac = $num;
	}
d498 2
a499 1
    my($name) = @@_;
d503 17
a519 4
    $name = "Sys::Syslog::$name";
    # Can't have just eval { &$name } || -1 because some LOG_XXX may be zero.
    my $value = eval { no strict 'refs'; &$name };
    $@@ = "";
d594 1
a594 1
    if (eval { IPPROTO_TCP() }) {
a597 1
    $@@ = "";
d666 1
a666 1
    if (!sysopen(SYSLOG, $syslog_path, 0400, O_WRONLY)) {
d744 1
a744 6
    eval { openlog_xs($ident, $logopt, xlate($facility)) };
    if ($@@) {
        push @@$errs, $@@;
        return 0;
    }

d783 1
a783 1
    my $ret = select $rin, undef, $rin, 0.25;
d803 20
a822 1
1;
d832 1
a832 1
Version 0.22
d1026 2
d1047 1
a1047 1
service. 
d1052 2
d1057 2
a1058 1
C<"inet"> - connect to an INET socket, either TCP or UDP, tried in that order. 
d1092 2
a1093 1
The default is to try C<native>, C<tcp>, C<udp>, C<unix>, C<stream>, C<console>.
d1180 1
a1180 2
    setlogsock('udp');
    $Sys::Syslog::host = $remotehost;
d1408 1
a1408 1
L<http://docs.sun.com/app/docs/doc/816-5168/6mbb3hruo?a=view>
d1410 5
a1414 2
IRIX 6.4 documentation on syslog,
L<http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0640&db=man&fname=3c+syslog>
d1420 1
a1420 1
L<http://docs.hp.com/en/B9106-90010/syslog.3C.html>
d1524 1
a1524 1
Copyright (C) 1990-2007 by Larry Wall and others.
d1587 3
@


1.9
log
@merge in perl 5.8.8
@
text
@d3 1
d5 5
a9 1
require 5.006;
d12 60
a71 16
our $VERSION = '0.13';
our @@ISA = qw(Exporter);

our %EXPORT_TAGS = (
    standard => [qw(openlog syslog closelog setlogmask)],
    extended => [qw(setlogsock)],
    macros => [qw(
        LOG_ALERT LOG_AUTH LOG_AUTHPRIV LOG_CONS LOG_CRIT LOG_CRON
        LOG_DAEMON LOG_DEBUG LOG_EMERG LOG_ERR LOG_FACMASK LOG_FTP
        LOG_INFO LOG_KERN LOG_LFMT LOG_LOCAL0 LOG_LOCAL1 LOG_LOCAL2
        LOG_LOCAL3 LOG_LOCAL4 LOG_LOCAL5 LOG_LOCAL6 LOG_LOCAL7 LOG_LPR
        LOG_MAIL LOG_NDELAY LOG_NEWS LOG_NFACILITIES LOG_NOTICE
        LOG_NOWAIT LOG_ODELAY LOG_PERROR LOG_PID LOG_PRIMASK LOG_SYSLOG
        LOG_USER LOG_UUCP LOG_WARNING
    )],
);
a72 3
our @@EXPORT = (
    @@{$EXPORT_TAGS{standard}}, 
);
d74 25
a98 3
our @@EXPORT_OK = (
    @@{$EXPORT_TAGS{extended}}, 
    @@{$EXPORT_TAGS{macros}}, 
d101 3
a103 3
# it would be nice to try stream/unix first, since that will be
# most efficient. However streams are dodgy - see _syslog_send_stream
my @@connectMethods = ( 'tcp', 'udp', 'unix', 'stream', 'console' );
a106 7
my @@defaultMethods = @@connectMethods;
my $syslog_path = undef;
my $transmit_ok = 0;
my $current_proto = undef;
my $failed = undef;
my $fail_time = undef;
our ($connected, @@fallbackMethods, $syslog_send, $host);
d108 7
a114 2
use Socket ':all';
use POSIX qw(strftime setlocale LC_TIME);
d116 7
a122 1
=head1 NAME
d124 2
a125 1
Sys::Syslog - Perl interface to the UNIX syslog(3) calls
d127 2
a128 1
=head1 VERSION
a129 1
Version 0.13
d131 13
a143 1
=head1 SYNOPSIS
a144 3
    use Sys::Syslog;                          # all except setlogsock(), or:
    use Sys::Syslog qw(:DEFAULT setlogsock);  # default set, plus setlogsock()
    use Sys::Syslog qw(:standard :macros);    # standard functions, plus macros
d146 2
a147 5
    setlogsock $sock_type;
    openlog $ident, $logopt, $facility;       # don't forget this
    syslog $priority, $format, @@args;
    $oldmask = setlogmask $mask_priority;
    closelog;
d149 4
d154 3
a156 1
=head1 DESCRIPTION
d158 4
a161 3
C<Sys::Syslog> is an interface to the UNIX C<syslog(3)> program.
Call C<syslog()> with a string priority and a list of C<printf()> args
just like C<syslog(3)>.
d163 4
d168 13
a180 1
=head1 EXPORTS
d182 2
a183 1
C<Sys::Syslog> exports the following C<Exporter> tags: 
d185 3
a187 1
=over 4
d189 3
a191 1
=item *
d193 6
a198 1
C<:standard> exports the standard C<syslog(3)> functions: 
d200 5
a204 1
    openlog closelog setlogmask syslog
d206 6
a211 1
=item *
d213 8
a220 1
C<:extended> exports the Perl specific functions for C<syslog(3)>: 
d222 6
a227 1
    setlogsock
d229 4
a232 1
=item *
d234 1
a234 2
C<:macros> exports the symbols corresponding to most of your C<syslog(3)> 
macros. See L<"CONSTANTS"> for the supported constants and their meaning. 
d236 2
a237 1
=back
d239 8
a246 1
By default, C<Sys::Syslog> exports the symbols from the C<:standard> tag. 
d248 7
d256 7
a262 1
=head1 FUNCTIONS
d264 2
a265 1
=over 4
d267 2
a268 1
=item B<openlog($ident, $logopt, $facility)>
d270 4
a273 8
Opens the syslog.
C<$ident> is prepended to every message.  C<$logopt> contains zero or
more of the words C<pid>, C<ndelay>, C<nowait>.  The C<cons> option is
ignored, since the failover mechanism will drop down to the console
automatically if all other media fail.  C<$facility> specifies the
part of the system to report about, for example C<LOG_USER> or C<LOG_LOCAL0>:
see your C<syslog(3)> documentation for the facilities available in
your system. Facility can be given as a string or a numeric macro. 
d275 2
a276 1
This function will croak if it can't connect to the syslog daemon.
d278 12
a289 1
Note that C<openlog()> now takes three arguments, just like C<openlog(3)>.
d291 1
a291 1
B<You should use openlog() before calling syslog().>
d293 2
a294 1
B<Options>
d296 3
a298 1
=over 4
d300 16
a315 1
=item *
d317 1
a317 2
C<ndelay> - Open the connection immediately (normally, the connection is
opened when the first message is logged).
d319 4
a322 1
=item *
d324 1
a324 3
C<nowait> - Don't wait for child processes that may have been created 
while logging the message.  (The GNU C library does not create a child
process, so this option has no effect on Linux.)
d326 6
a331 1
=item *
d333 2
a334 1
C<pid> - Include PID with each message.
d336 30
a365 1
=back
d367 13
a379 1
B<Examples>
d381 7
a387 1
Open the syslog with options C<ndelay> and C<pid>, and with facility C<LOCAL0>: 
d389 2
a390 1
    openlog($name, "ndelay,pid", "local0");
d392 13
a404 1
Same thing, but this time using the macro corresponding to C<LOCAL0>: 
d406 7
a412 1
    openlog($name, "ndelay,pid", LOG_LOCAL0);
d414 20
d435 8
a442 1
=item B<syslog($priority, $message)>
d444 4
a447 1
=item B<syslog($priority, $format, @@args)>
d449 5
a453 3
If C<$priority> permits, logs C<$message> or C<sprintf($format, @@args)>
with the addition that C<%m> in $message or C<$format> is replaced with
C<"$!"> (the latest error message). 
d455 5
a459 2
C<$priority> can specify a level, or a level and a facility.  Levels and 
facilities can be given as strings or as macros.
a460 3
If you didn't use C<openlog()> before using C<syslog()>, C<syslog()> will 
try to guess the C<$ident> by extracting the shortest prefix of 
C<$format> that ends in a C<":">.
d462 15
a476 1
B<Examples>
a477 2
    syslog("info", $message);           # informational level
    syslog(LOG_INFO, $message);         # informational level
d479 8
a486 2
    syslog("info|local0", $message);        # information level, Local0 facility
    syslog(LOG_INFO|LOG_LOCAL0, $message);  # information level, Local0 facility
d488 4
a491 1
=over 4
d493 3
a495 1
=item B<Note>
d497 17
a513 7
C<Sys::Syslog> version v0.07 and older passed the C<$message> as the 
formatting string to C<sprintf()> even when no formatting arguments
were provided.  If the code calling C<syslog()> might execute with 
older versions of this module, make sure to call the function as
C<syslog($priority, "%s", $message)> instead of C<syslog($priority,
$message)>.  This protects against hostile formatting sequences that
might show up if $message contains tainted data.
d515 2
a516 1
=back
d518 5
d524 6
a529 1
=item B<setlogmask($mask_priority)>
d531 11
a541 3
Sets the log mask for the current process to C<$mask_priority> and 
returns the old mask.  If the mask argument is 0, the current log mask 
is not modified.  See L<"Levels"> for the list of available levels. 
d543 4
a546 1
B<Examples>
d548 10
a557 1
Only log errors: 
d559 1
a559 1
    setlogmask(LOG_ERR);
d561 2
a562 1
Log critical messages, errors and warnings: 
d564 2
a565 1
    setlogmask(LOG_CRIT|LOG_ERR|LOG_WARNING);
d567 5
d573 5
a577 1
=item B<setlogsock($sock_type)>
d579 11
a589 1
=item B<setlogsock($sock_type, $stream_location)> (added in 5.004_02)
d591 8
a598 3
Sets the socket type to be used for the next call to
C<openlog()> or C<syslog()> and returns true on success,
C<undef> on failure.
d600 7
a606 11
A value of C<"unix"> will connect to the UNIX domain socket (in some
systems a character special device) returned by the C<_PATH_LOG> macro
(if your system defines it), or F</dev/log> or F</dev/conslog>,
whatever is writable.  A value of 'stream' will connect to the stream
indicated by the pathname provided as the optional second parameter.
(For example Solaris and IRIX require C<"stream"> instead of C<"unix">.)
A value of C<"inet"> will connect to an INET socket (either C<tcp> or C<udp>,
tried in that order) returned by C<getservbyname()>. C<"tcp"> and C<"udp"> can
also be given as values. The value C<"console"> will send messages
directly to the console, as for the C<"cons"> option in the logopts in
C<openlog()>.
d608 1
a608 3
A reference to an array can also be passed as the first parameter.
When this calling method is used, the array should contain a list of
sock_types which are attempted in order.
d610 2
a611 1
The default is to try C<tcp>, C<udp>, C<unix>, C<stream>, C<console>.
d613 16
a628 1
Giving an invalid value for C<$sock_type> will croak.
d630 2
d633 1
a633 1
=item B<closelog()>
d635 4
a638 1
Closes the log file and return true on success.
d640 4
a643 1
=back
d645 1
d647 2
a648 1
=head1 EXAMPLES
d650 2
a651 4
    openlog($program, 'cons,pid', 'user');
    syslog('info', '%s', 'this is another test');
    syslog('mail|warning', 'this is a better test: %d', time);
    closelog();
d653 1
a653 1
    syslog('debug', 'this is the last test');
d655 4
a658 3
    setlogsock('unix');
    openlog("$program $$", 'ndelay', 'user');
    syslog('notice', 'fooprogram: this is really done');
d660 4
a663 3
    setlogsock('inet');
    $! = 55;
    syslog('info', 'problem was %m'); # %m == $! in syslog(3)
d665 9
a673 5
    # Log to UDP port on $remotehost instead of logging locally
    setlogsock('udp');
    $Sys::Syslog::host = $remotehost;
    openlog($program, 'ndelay', 'user');
    syslog('info', 'something happened over here');
d675 10
d686 1
a686 1
=head1 CONSTANTS
d688 2
a689 1
=head2 Facilities
d691 3
a693 1
=over 4
d695 4
a698 1
=item *
d700 5
a704 1
C<LOG_AUTH> - security/authorization messages
d706 1
a706 1
=item *
d708 2
a709 1
C<LOG_AUTHPRIV> - security/authorization messages (private)
d711 2
a712 1
=item *
d714 2
a715 1
C<LOG_CRON> - clock daemon (B<cron> and B<at>)
d717 2
a718 1
=item *
d720 9
a728 1
C<LOG_DAEMON> - system daemons without separate facility value
d730 11
a740 1
=item *
d742 5
a746 1
C<LOG_FTP> - ftp daemon
d748 3
a750 1
=item *
d752 8
a759 1
C<LOG_KERN> - kernel messages
d761 2
a762 1
=item *
d764 1
a764 1
C<LOG_LOCAL0> through C<LOG_LOCAL7> - reserved for local use
d766 1
a766 1
=item *
d768 1
a768 1
C<LOG_LPR> - line printer subsystem
d770 1
a770 1
=item *
d772 1
a772 1
C<LOG_MAIL> - mail subsystem
d774 1
a774 1
=item *
d776 1
a776 1
C<LOG_NEWS> - USENET news subsystem
d778 3
a780 1
=item *
d782 4
a785 1
C<LOG_SYSLOG> - messages generated internally by B<syslogd>
a786 1
=item *
d788 1
a788 1
C<LOG_USER> (default) - generic user-level messages
d790 3
a792 1
=item *
d794 2
a795 1
C<LOG_UUCP> - UUCP subsystem
a796 1
=back
d798 1
d800 1
a800 1
=head2 Levels
d806 3
a808 1
C<LOG_EMERG> - system is unusable
d812 1
a812 1
C<LOG_ALERT> - action must be taken immediately
d814 1
a814 3
=item *

C<LOG_CRIT> - critical conditions
d818 3
a820 1
C<LOG_ERR> - error conditions
d822 1
a822 1
=item *
d824 1
a824 1
C<LOG_WARNING> - warning conditions
a825 1
=item *
d827 1
a827 1
C<LOG_NOTICE> - normal, but significant, condition
d829 1
a829 1
=item *
d831 1
a831 1
C<LOG_INFO> - informational message
d833 8
a840 1
=item *
d842 1
a842 1
C<LOG_DEBUG> - debug-level message
d844 1
a844 1
=back
d846 1
d848 1
a848 1
=head1 DIAGNOSTICS
d852 1
a852 1
=item Invalid argument passed to setlogsock
d854 2
a855 1
B<(F)> You gave C<setlogsock()> an invalid value for C<$sock_type>. 
d857 1
a857 1
=item no connection to syslog available
d859 2
a860 1
B<(F)> C<syslog()> failed to connect to the specified socket.
d862 1
a862 1
=item stream passed to setlogsock, but %s is not writable
d864 3
a866 2
B<(W)> You asked C<setlogsock()> to use a stream socket, but the given 
path is not writable. 
d868 1
a868 1
=item stream passed to setlogsock, but could not find any device
d870 3
a872 2
B<(W)> You asked C<setlogsock()> to use a stream socket, but didn't 
provide a path, and C<Sys::Syslog> was unable to find an appropriate one.
d874 1
a874 1
=item tcp passed to setlogsock, but tcp service unavailable
d876 14
a889 2
B<(W)> You asked C<setlogsock()> to use a TCP socket, but the service 
is not available on the system. 
d891 1
a891 1
=item syslog: expecting argument %s
d893 1
a893 1
B<(F)> You forgot to give C<syslog()> the indicated argument.
a894 1
=item syslog: invalid level/facility: %s
d896 1
a896 2
B<(F)> You specified an invalid level or facility, like C<LOG_KERN> 
(which is reserved to the kernel). 
d898 1
a898 1
=item syslog: too many levels given: %s
d900 3
a902 1
B<(F)> You specified too many levels. 
d904 5
a908 1
=item syslog: too many facilities given: %s
d910 3
a912 1
B<(F)> You specified too many facilities. 
d914 1
a914 1
=item syslog: level must be given
d916 2
a917 1
B<(F)> You forgot to specify a level.
d919 2
a920 1
=item udp passed to setlogsock, but udp service unavailable
d922 1
a922 2
B<(W)> You asked C<setlogsock()> to use a UDP socket, but the service 
is not available on the system. 
d924 1
a924 1
=item unix passed to setlogsock, but path not available
d926 7
a932 2
B<(W)> You asked C<setlogsock()> to use a UNIX socket, but C<Sys::Syslog> 
was unable to find an appropriate an appropriate device.
d937 17
a953 1
=head1 SEE ALSO
d955 1
a955 1
L<syslog(3)>
d957 1
a957 1
I<Syslogging with Perl>, L<http://lexington.pm.org/meetings/022001.html>
d959 1
d961 1
a961 1
=head1 AUTHOR
a962 2
Tom Christiansen E<lt>F<tchrist@@perl.com>E<gt> and Larry Wall
E<lt>F<larry@@wall.org>E<gt>.
d964 1
a964 3
UNIX domain sockets added by Sean Robinson
E<lt>F<robinson_s@@sc.maricopa.edu>E<gt> with support from Tim Bunce 
E<lt>F<Tim.Bunce@@ig.co.uk>E<gt> and the C<perl5-porters> mailing list.
d966 1
a966 2
Dependency on F<syslog.ph> replaced with XS code by Tom Hughes
E<lt>F<tom@@compton.nu>E<gt>.
d968 3
a970 1
Code for C<constant()>s regenerated by Nicholas Clark E<lt>F<nick@@ccl4.org>E<gt>.
d972 1
a972 2
Failover to different communication modes by Nick Williams
E<lt>F<Nick.Williams@@morganstanley.com>E<gt>.
d974 1
a974 2
Extracted from core distribution for publishing on the CPAN by 
SE<eacute>bastien Aperghis-Tramoni E<lt>sebastien@@aperghis.netE<gt>.
d976 2
d979 1
a979 1
=head1 BUGS
d981 2
a982 5
Please report any bugs or feature requests to
C<bug-sys-syslog at rt.cpan.org>, or through the web interface at
L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Sys-Syslog>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
d984 1
d986 2
a987 1
=head1 SUPPORT
d989 1
a989 1
You can find documentation for this module with the perldoc command.
d991 1
a991 1
    perldoc Sys::Syslog
d993 1
a993 1
You can also look for information at:
d995 1
a995 1
=over 4
d997 1
a997 1
=item * AnnoCPAN: Annotated CPAN documentation
d999 5
a1003 1
L<http://annocpan.org/dist/Sys-Syslog>
d1005 1
a1005 1
=item * CPAN Ratings
d1007 3
a1009 1
L<http://cpanratings.perl.org/d/Sys-Syslog>
d1011 1
a1011 1
=item * RT: CPAN's request tracker
d1013 4
a1016 1
L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Sys-Syslog>
d1018 1
a1018 1
=item * Search CPAN
d1020 2
a1021 1
L<http://search.cpan.org/dist/Sys-Syslog>
d1025 3
d1029 3
a1031 1
=head1 LICENSE
d1033 1
a1033 2
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
d1035 1
a1035 1
=cut
d1037 1
a1037 13
sub AUTOLOAD {
    # This AUTOLOAD is used to 'autoload' constants from the constant()
    # XS function.
    my $constname;
    our $AUTOLOAD;
    ($constname = $AUTOLOAD) =~ s/.*:://;
    croak "&Sys::Syslog::constant not defined" if $constname eq 'constant';
    my ($error, $val) = constant($constname);
	croak $error if $error;
    no strict 'refs';
    *$AUTOLOAD = sub { $val };
    goto &$AUTOLOAD;
}
d1039 1
a1039 9
eval {
    require XSLoader;
    XSLoader::load('Sys::Syslog', $VERSION);
    1
} or do {
    require DynaLoader;
    push @@ISA, 'DynaLoader';
    bootstrap Sys::Syslog $VERSION;
};
d1041 1
a1041 1
our $maskpri = &LOG_UPTO(&LOG_DEBUG);
d1043 1
a1043 8
sub openlog {
    our ($ident, $logopt, $facility) = @@_;  # package vars
    our $lo_pid = $logopt =~ /\bpid\b/;
    our $lo_ndelay = $logopt =~ /\bndelay\b/;
    our $lo_nowait = $logopt =~ /\bnowait\b/;
    return 1 unless $lo_ndelay;
    &connect;
} 
d1045 1
a1045 4
sub closelog {
    our $facility = our $ident = '';
    &disconnect;
} 
d1047 1
a1047 67
sub setlogmask {
    my $oldmask = $maskpri;
    $maskpri = shift unless $_[0] == 0;
    $oldmask;
}
 
sub setlogsock {
    my $setsock = shift;
    $syslog_path = shift;
    &disconnect if $connected;
    $transmit_ok = 0;
    @@fallbackMethods = ();
    @@connectMethods = @@defaultMethods;
    if (ref $setsock eq 'ARRAY') {
	@@connectMethods = @@$setsock;
    } elsif (lc($setsock) eq 'stream') {
	unless (defined $syslog_path) {
	    my @@try = qw(/dev/log /dev/conslog);
	    if (length &_PATH_LOG) { # Undefined _PATH_LOG is "".
		unshift @@try, &_PATH_LOG;
            }
	    for my $try (@@try) {
		if (-w $try) {
		    $syslog_path = $try;
		    last;
		}
	    }
	    carp "stream passed to setlogsock, but could not find any device"
		unless defined $syslog_path
        }
	unless (-w $syslog_path) {
	    carp "stream passed to setlogsock, but $syslog_path is not writable";
	    return undef;
	} else {
	    @@connectMethods = ( 'stream' );
	}
    } elsif (lc($setsock) eq 'unix') {
        if (length _PATH_LOG() && !defined $syslog_path) {
	    $syslog_path = _PATH_LOG();
	    @@connectMethods = ( 'unix' );
        } else {
	    carp 'unix passed to setlogsock, but path not available';
	    return undef;
        }
    } elsif (lc($setsock) eq 'tcp') {
	if (getservbyname('syslog', 'tcp') || getservbyname('syslogng', 'tcp')) {
	    @@connectMethods = ( 'tcp' );
	} else {
	    carp "tcp passed to setlogsock, but tcp service unavailable";
	    return undef;
	}
    } elsif (lc($setsock) eq 'udp') {
	if (getservbyname('syslog', 'udp')) {
	    @@connectMethods = ( 'udp' );
	} else {
	    carp "udp passed to setlogsock, but udp service unavailable";
	    return undef;
	}
    } elsif (lc($setsock) eq 'inet') {
	@@connectMethods = ( 'tcp', 'udp' );
    } elsif (lc($setsock) eq 'console') {
	@@connectMethods = ( 'console' );
    } else {
        croak "Invalid argument passed to setlogsock; must be 'stream', 'unix', 'tcp', 'udp' or 'inet'"
    }
    return 1;
}
d1049 7
a1055 7
sub syslog {
    my $priority = shift;
    my $mask = shift;
    my ($message, $whoami);
    my (@@words, $num, $numpri, $numfac, $sum);
    our $facility;
    local($facility) = $facility;	# may need to change temporarily.
d1057 1
a1057 2
    croak "syslog: expecting argument \$priority" unless defined $priority;
    croak "syslog: expecting argument \$format"   unless defined $mask;
d1059 1
a1059 19
    @@words = split(/\W+/, $priority, 2);# Allow "level" or "level|facility".
    undef $numpri;
    undef $numfac;
    foreach (@@words) {
	$num = &xlate($_);		# Translate word to number.
	if ($_ eq 'kern' || $num <= 0) {
	    croak "syslog: invalid level/facility: $_"
	}
	elsif ($num <= &LOG_PRIMASK) {
	    croak "syslog: too many levels given: $_" if defined($numpri);
	    $numpri = $num;
	    return 0 unless &LOG_MASK($numpri) & $maskpri;
	}
	else {
	    croak "syslog: too many facilities given: $_" if defined($numfac);
	    $facility = $_;
	    $numfac = $num;
	}
    }
d1061 1
a1061 1
    croak "syslog: level must be given" unless defined($numpri);
d1063 1
a1063 4
    if (!defined($numfac)) {	# Facility not specified in this call.
	$facility = 'user' unless $facility;
	$numfac = &xlate($facility);
    }
a1064 1
    &connect unless $connected;
d1066 1
a1066 1
    $whoami = our $ident;
d1068 2
a1069 4
    if (!$whoami && $mask =~ /^(\S.*?):\s?(.*)/) {
	$whoami = $1;
	$mask = $2;
    } 
d1071 2
a1072 5
    unless ($whoami) {
	($whoami = getlogin) ||
	    ($whoami = getpwuid($<)) ||
		($whoami = 'syslog');
    }
d1074 2
a1075 1
    $whoami .= "[$$]" if our $lo_pid;
d1077 2
a1078 7
    if ($mask =~ /%m/) {
	my $err = $!;
	# escape percent signs if sprintf will be called
	$err =~ s/%/%%/g if @@_;
	# replace %m with $err, if preceded by an even number of percent signs
	$mask =~ s/(?<!%)((?:%%)*)%m/$1$err/g;
    }
d1080 2
a1081 2
    $mask .= "\n" unless $mask =~ /\n$/;
    $message = @@_ ? sprintf($mask, @@_) : $mask;
d1083 2
a1084 6
    $sum = $numpri + $numfac;
    my $oldlocale = setlocale(LC_TIME);
    setlocale(LC_TIME, 'C');
    my $timestamp = strftime "%b %e %T", localtime;
    setlocale(LC_TIME, $oldlocale);
    my $buf = "<$sum>$timestamp $whoami: $message\0";
d1086 2
a1087 35
    # it's possible that we'll get an error from sending
    # (e.g. if method is UDP and there is no UDP listener,
    # then we'll get ECONNREFUSED on the send). So what we
    # want to do at this point is to fallback onto a different
    # connection method.
    while (scalar @@fallbackMethods || $syslog_send) {
	if ($failed && (time - $fail_time) > 60) {
	    # it's been a while... maybe things have been fixed
	    @@fallbackMethods = ();
	    disconnect();
	    $transmit_ok = 0; # make it look like a fresh attempt
	    &connect;
        }
	if ($connected && !connection_ok()) {
	    # Something was OK, but has now broken. Remember coz we'll
	    # want to go back to what used to be OK.
	    $failed = $current_proto unless $failed;
	    $fail_time = time;
	    disconnect();
	}
	&connect unless $connected;
	$failed = undef if ($current_proto && $failed && $current_proto eq $failed);
	if ($syslog_send) {
	    if (&{$syslog_send}($buf)) {
		$transmit_ok++;
		return 1;
	    }
	    # typically doesn't happen, since errors are rare from write().
	    disconnect();
	}
    }
    # could not send, could not fallback onto a working
    # connection method. Lose.
    return 0;
}
d1089 2
a1090 28
sub _syslog_send_console {
    my ($buf) = @@_;
    chop($buf); # delete the NUL from the end
    # The console print is a method which could block
    # so we do it in a child process and always return success
    # to the caller.
    if (my $pid = fork) {
	our $lo_nowait;
	if ($lo_nowait) {
	    return 1;
	} else {
	    if (waitpid($pid, 0) >= 0) {
	    	return ($? >> 8);
	    } else {
		# it's possible that the caller has other
		# plans for SIGCHLD, so let's not interfere
		return 1;
	    }
	}
    } else {
        if (open(CONS, ">/dev/console")) {
	    my $ret = print CONS $buf . "\r";
	    exit ($ret) if defined $pid;
	    close CONS;
	}
	exit if defined $pid;
    }
}
a1091 8
sub _syslog_send_stream {
    my ($buf) = @@_;
    # XXX: this only works if the OS stream implementation makes a write 
    # look like a putmsg() with simple header. For instance it works on 
    # Solaris 8 but not Solaris 7.
    # To be correct, it should use a STREAMS API, but perl doesn't have one.
    return syswrite(SYSLOG, $buf, length($buf));
}
d1093 1
a1093 5
sub _syslog_send_socket {
    my ($buf) = @@_;
    return syswrite(SYSLOG, $buf, length($buf));
    #return send(SYSLOG, $buf, 0);
}
d1095 401
a1495 10
sub xlate {
    my($name) = @@_;
    return $name+0 if $name =~ /^\s*\d+\s*$/;
    $name = uc $name;
    $name = "LOG_$name" unless $name =~ /^LOG_/;
    $name = "Sys::Syslog::$name";
    # Can't have just eval { &$name } || -1 because some LOG_XXX may be zero.
    my $value = eval { no strict 'refs'; &$name };
    defined $value ? $value : -1;
}
d1497 1
a1497 15
sub connect {
    @@fallbackMethods = @@connectMethods unless (scalar @@fallbackMethods);
    if ($transmit_ok && $current_proto) {
	# Retry what we were on, because it's worked in the past.
	unshift(@@fallbackMethods, $current_proto);
    }
    $connected = 0;
    my @@errs = ();
    my $proto = undef;
    while ($proto = shift(@@fallbackMethods)) {
	no strict 'refs';
	my $fn = "connect_$proto";
	$connected = &$fn(\@@errs) if defined &$fn;
	last if ($connected);
    }
d1499 3
a1501 9
    $transmit_ok = 0;
    if ($connected) {
	$current_proto = $proto;
        my($old) = select(SYSLOG); $| = 1; select($old);
    } else {
	@@fallbackMethods = ();
	croak join "\n\t- ", "no connection to syslog available", @@errs
    }
}
a1502 13
sub connect_tcp {
    my ($errs) = @@_;
    my $tcp = getprotobyname('tcp');
    if (!defined $tcp) {
	push(@@{$errs}, "getprotobyname failed for tcp");
	return 0;
    }
    my $syslog = getservbyname('syslog','tcp');
    $syslog = getservbyname('syslogng','tcp') unless (defined $syslog);
    if (!defined $syslog) {
	push(@@{$errs}, "getservbyname failed for syslog/tcp and syslogng/tcp");
	return 0;
    }
d1504 2
a1505 12
    my $this = sockaddr_in($syslog, INADDR_ANY);
    my $that;
    if (defined $host) {
	$that = inet_aton($host);
	if (!$that) {
	    push(@@{$errs}, "can't lookup $host");
	    return 0;
	}
    } else {
	$that = INADDR_LOOPBACK;
    }
    $that = sockaddr_in($syslog, $that);
d1507 4
a1510 3
    if (!socket(SYSLOG,AF_INET,SOCK_STREAM,$tcp)) {
	push(@@{$errs}, "tcp socket: $!");
	return 0;
a1511 9
    setsockopt(SYSLOG, SOL_SOCKET, SO_KEEPALIVE, 1);
    setsockopt(SYSLOG, IPPROTO_TCP, TCP_NODELAY, 1);
    if (!CORE::connect(SYSLOG,$that)) {
	push(@@{$errs}, "tcp connect: $!");
	return 0;
    }
    $syslog_send = \&_syslog_send_socket;
    return 1;
}
d1513 2
a1514 24
sub connect_udp {
    my ($errs) = @@_;
    my $udp = getprotobyname('udp');
    if (!defined $udp) {
	push(@@{$errs}, "getprotobyname failed for udp");
	return 0;
    }
    my $syslog = getservbyname('syslog','udp');
    if (!defined $syslog) {
	push(@@{$errs}, "getservbyname failed for syslog/udp");
	return 0;
    }
    my $this = sockaddr_in($syslog, INADDR_ANY);
    my $that;
    if (defined $host) {
	$that = inet_aton($host);
	if (!$that) {
	    push(@@{$errs}, "can't lookup $host");
	    return 0;
	}
    } else {
	$that = INADDR_LOOPBACK;
    }
    $that = sockaddr_in($syslog, $that);
d1516 1
a1516 18
    if (!socket(SYSLOG,AF_INET,SOCK_DGRAM,$udp)) {
	push(@@{$errs}, "udp socket: $!");
	return 0;
    }
    if (!CORE::connect(SYSLOG,$that)) {
	push(@@{$errs}, "udp connect: $!");
	return 0;
    }
    # We want to check that the UDP connect worked. However the only
    # way to do that is to send a message and see if an ICMP is returned
    _syslog_send_socket("");
    if (!connection_ok()) {
	push(@@{$errs}, "udp connect: nobody listening");
	return 0;
    }
    $syslog_send = \&_syslog_send_socket;
    return 1;
}
a1517 16
sub connect_stream {
    my ($errs) = @@_;
    # might want syslog_path to be variable based on syslog.h (if only
    # it were in there!)
    $syslog_path = '/dev/conslog'; 
    if (!-w $syslog_path) {
	push(@@{$errs}, "stream $syslog_path is not writable");
	return 0;
    }
    if (!open(SYSLOG, ">" . $syslog_path)) {
	push(@@{$errs}, "stream can't open $syslog_path: $!");
	return 0;
    }
    $syslog_send = \&_syslog_send_stream;
    return 1;
}
d1519 4
a1522 34
sub connect_unix {
    my ($errs) = @@_;
    if (length _PATH_LOG()) {
	$syslog_path = _PATH_LOG();
    } else {
        push(@@{$errs}, "_PATH_LOG not available in syslog.h");
	return 0;
    }
    if (! -S $syslog_path) {
	push(@@{$errs}, "$syslog_path is not a socket");
	return 0;
    }
    my $that = sockaddr_un($syslog_path);
    if (!$that) {
	push(@@{$errs}, "can't locate $syslog_path");
	return 0;
    }
    if (!socket(SYSLOG,AF_UNIX,SOCK_STREAM,0)) {
	push(@@{$errs}, "unix stream socket: $!");
	return 0;
    }
    if (!CORE::connect(SYSLOG,$that)) {
        if (!socket(SYSLOG,AF_UNIX,SOCK_DGRAM,0)) {
	    push(@@{$errs}, "unix dgram socket: $!");
	    return 0;
	}
        if (!CORE::connect(SYSLOG,$that)) {
	    push(@@{$errs}, "unix dgram connect: $!");
	    return 0;
	}
    }
    $syslog_send = \&_syslog_send_socket;
    return 1;
}
d1524 2
a1525 9
sub connect_console {
    my ($errs) = @@_;
    if (!-w '/dev/console') {
	push(@@{$errs}, "console is not writable");
	return 0;
    }
    $syslog_send = \&_syslog_send_console;
    return 1;
}
d1527 2
a1528 13
# to test if the connection is still good, we need to check if any
# errors are present on the connection. The errors will not be raised
# by a write. Instead, sockets are made readable and the next read
# would cause the error to be returned. Unfortunately the syslog 
# 'protocol' never provides anything for us to read. But with 
# judicious use of select(), we can see if it would be readable...
sub connection_ok {
    return 1 if (defined $current_proto && $current_proto eq 'console');
    my $rin = '';
    vec($rin, fileno(SYSLOG), 1) = 1;
    my $ret = select $rin, undef, $rin, 0;
    return ($ret ? 0 : 1);
}
d1530 1
a1530 5
sub disconnect {
    $connected = 0;
    $syslog_send = undef;
    return close SYSLOG;
}
a1531 1
1;
@


1.8
log
@sync in-tree perl with 5.8.6
@
text
@d2 3
a4 1
require 5.000;
a5 2
require DynaLoader;
use Carp;
d7 25
a31 4
@@ISA = qw(Exporter DynaLoader);
@@EXPORT = qw(openlog closelog setlogmask syslog);
@@EXPORT_OK = qw(setlogsock);
$VERSION = '0.05';
a34 1
#my @@connectMethods = ( 'stream', 'unix', 'tcp', 'udp' );
d45 1
d47 2
a48 2
use Socket;
use Sys::Hostname;
d52 5
a56 1
Sys::Syslog, openlog, closelog, setlogmask, syslog - Perl interface to the UNIX syslog(3) calls
d60 3
a62 2
    use Sys::Syslog;                          # all except setlogsock, or:
    use Sys::Syslog qw(:DEFAULT setlogsock);  # default set, plus setlogsock
d70 1
d73 1
a73 1
Sys::Syslog is an interface to the UNIX C<syslog(3)> program.
d77 4
a80 1
Syslog provides the functions:
d84 11
a94 1
=item openlog $ident, $logopt, $facility
d96 19
a114 2
I<$ident> is prepended to every message.  I<$logopt> contains zero or
more of the words I<pid>, I<ndelay>, I<nowait>.  The cons option is
d116 2
a117 2
automatically if all other media fail.  I<$facility> specifies the
part of the system to report about, for example LOG_USER or LOG_LOCAL0:
d119 5
a123 1
your system.
d127 54
a180 1
=item syslog $priority, $format, @@args
d182 16
a197 3
If I<$priority> permits, logs I<($format, @@args)>
printed as by C<printf(3V)>, with the addition that I<%m>
is replaced with C<"$!"> (the latest error message).
d199 3
a201 3
If you didn't use openlog() before using syslog(), syslog will try to
guess the I<$ident> by extracting the shortest prefix of I<$format>
that ends in a ":".
d203 1
a203 1
=item setlogmask $mask_priority
d205 1
a205 1
Sets log mask I<$mask_priority> and returns the old mask.
d207 10
a216 1
=item setlogsock $sock_type [$stream_location] (added in 5.004_02)
d219 2
a220 2
C<openlog()> or C<syslog()> and returns TRUE on success,
undef on failure.
d222 1
a222 1
A value of 'unix' will connect to the UNIX domain socket (in some
d227 6
a232 6
(For example Solaris and IRIX require 'stream' instead of 'unix'.)
A value of 'inet' will connect to an INET socket (either tcp or udp,
tried in that order) returned by getservbyname(). 'tcp' and 'udp' can
also be given as values. The value 'console' will send messages
directly to the console, as for the 'cons' option in the logopts in
openlog().
d238 3
a240 1
The default is to try tcp, udp, unix, stream, console.
a241 1
Giving an invalid value for sock_type will croak.
d243 1
a243 1
=item closelog
d245 1
a245 1
Closes the log file.
a248 1
Note that C<openlog> now takes three arguments, just like C<openlog(3)>.
d253 1
a253 1
    syslog('info', 'this is another test');
d273 162
d439 3
d449 1
a449 1
E<lt>F<Tim.Bunce@@ig.co.uk>E<gt> and the perl5-porters mailing list.
d454 1
a454 1
Code for constant()s regenerated by Nicholas Clark E<lt>F<nick@@ccl4.org>E<gt>.
d459 47
a510 1
    
d516 2
a517 3
    if ($error) {
	croak $error;
    }
d522 9
a530 1
bootstrap Sys::Syslog $VERSION;
d532 1
a532 1
$maskpri = &LOG_UPTO(&LOG_DEBUG);
d535 4
a538 4
    ($ident, $logopt, $facility) = @@_;  # package vars
    $lo_pid = $logopt =~ /\bpid\b/;
    $lo_ndelay = $logopt =~ /\bndelay\b/;
    $lo_nowait = $logopt =~ /\bnowait\b/;
d544 1
a544 1
    $facility = $ident = '';
d549 2
a550 2
    local($oldmask) = $maskpri;
    $maskpri = shift;
d555 1
a555 1
    local($setsock) = shift;
d576 1
a576 1
		unless defined $syslog_path;
d611 1
a611 1
        carp "Invalid argument passed to setlogsock; must be 'stream', 'unix', 'tcp', 'udp' or 'inet'";
d617 5
a621 4
    local($priority) = shift;
    local($mask) = shift;
    local($message, $whoami);
    local(@@words, $num, $numpri, $numfac, $sum);
d624 2
a625 2
    croak "syslog: expecting argument \$priority" unless $priority;
    croak "syslog: expecting argument \$format"   unless $mask;
d632 2
a633 2
	if (/^kern$/ || $num < 0) {
	    croak "syslog: invalid level/facility: $_";
d656 1
a656 1
    $whoami = $ident;
d669 9
a677 1
    $whoami .= "[$$]" if $lo_pid;
a678 1
    $mask =~ s/%m/$!/g;
d680 1
a680 1
    $message = sprintf ($mask, @@_);
d683 5
a687 1
    my $buf = "<$sum>$whoami: $message\0";
d732 1
d762 1
d770 1
a770 1
    local($name) = @@_;
d776 1
a776 1
    my $value = eval { &$name };
d790 1
d792 1
a792 1
	$connected = &$fn(\@@errs) unless (!defined &$fn);
d799 1
a799 1
        local($old) = select(SYSLOG); $| = 1; select($old);
d802 1
a802 4
	foreach my $err (@@errs) {
	    carp $err;
	}
	croak "no connection to syslog available";
a807 5
    unless ($host) {
	require Sys::Hostname;
	my($host_uniq) = Sys::Hostname::hostname();
	($host) = $host_uniq =~ /([A-Za-z0-9_.-]+)/; # allow FQDN (inc _)
    }
d816 1
a816 1
	push(@@{$errs}, "getservbyname failed for tcp");
d821 9
a829 4
    my $that = sockaddr_in($syslog, inet_aton($host));
    if (!$that) {
	push(@@{$errs}, "can't lookup $host");
	return 0;
d831 2
a848 5
    unless ($host) {
	require Sys::Hostname;
	my($host_uniq) = Sys::Hostname::hostname();
	($host) = $host_uniq =~ /([A-Za-z0-9_.-]+)/; # allow FQDN (inc _)
    }
d856 1
a856 1
	push(@@{$errs}, "getservbyname failed for udp");
d860 9
a868 4
    my $that = sockaddr_in($syslog, inet_aton($host));
    if (!$that) {
	push(@@{$errs}, "can't lookup $host");
	return 0;
d870 2
d916 4
a967 1
    close SYSLOG;
d970 1
@


1.7
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d131 6
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d10 1
a10 1
$VERSION = '0.04';
d397 1
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d10 1
a10 1
$VERSION = '0.03';
a28 9
# adapted from syslog.pl
#
# Tom Christiansen <tchrist@@convex.com>
# modified to use sockets by Larry Wall <lwall@@jpl-devvax.jpl.nasa.gov>
# NOTE: openlog now takes three arguments, just like openlog(3)
# Modified to add UNIX domain sockets by Sean Robinson <robinson_s@@sc.maricopa.edu>
#  with support from Tim Bunce <Tim.Bunce@@ig.co.uk> and the perl5-porters mailing list
# Modified to use an XS backend instead of syslog.ph by Tom Hughes <tom@@compton.nu>

d39 1
a39 1
    openlog $ident, $logopt, $facility;
d60 5
a64 1
part of the system
d72 4
d86 11
a96 8
A value of 'unix' will connect to the UNIX domain socket returned by
the C<_PATH_LOG> macro (if your system defines it) in F<syslog.ph>.  A
value of 'stream' will connect to the stream indicated by the pathname
provided as the optional second parameter.  A value of 'inet' will
connect to an INET socket (either tcp or udp, tried in that order)
returned by getservbyname(). 'tcp' and 'udp' can also be given as
values. The value 'console' will send messages directly to the
console, as for the 'cons' option in the logopts in openlog().
d204 15
a218 2
	$syslog_path = '/dev/log' unless($syslog_path);
	if (!-w $syslog_path) {
d263 2
a264 1
    croak "syslog: expected both priority and mask" unless $mask && $priority;
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d10 15
a24 1
$VERSION = '0.01';
a37 2
# Todo: enable connect to try all three types before failing (auto setlogsock)?

d61 1
a61 1
=over
d65 5
a69 3
I<$ident> is prepended to every message.
I<$logopt> contains zero or more of the words I<pid>, I<ndelay>, I<cons>, I<nowait>.
I<$facility> specifies the part of the system
d81 1
a81 1
=item setlogsock $sock_type (added in 5.004_02)
d87 12
a98 5
A value of 'unix' will connect to the UNIX domain socket returned by the
C<_PATH_LOG> macro (if you system defines it) in F<syslog.h>.  A value of
'inet' will connect to an INET socket returned by getservbyname().  If
C<_PATH_LOG> is unavailable or if getservbyname() fails, returns undef.  Any
other value croaks.
d100 3
a102 1
The default is for the INET socket to be used.
d139 1
a139 1
E<lt>F<robinson_s@@sc.maricopa.edu>E<gt> with support from Tim Bunce
d145 5
d155 1
a155 1

d159 4
a162 4
    croak "& not defined" if $constname eq 'constant';
    my $val = constant($constname);
    if ($! != 0) {
	croak "Your vendor has not defined Sys::Syslog macro $constname";
a175 1
    $lo_cons = $logopt =~ /\bcons\b/;
d194 1
d196 17
a212 3
    if (lc($setsock) eq 'unix') {
        if (length _PATH_LOG()) {
            $sock_type = 1;
d214 2
a215 1
            return undef;
d217 14
d232 3
a234 5
        if (getservbyname('syslog','udp')) {
            undef($sock_type);
        } else {
            return undef;
        }
d236 1
a236 1
        croak "Invalid argument passed to setlogsock; must be 'unix' or 'inet'";
d299 28
a326 6
    unless (send(SYSLOG,"<$sum>$whoami: $message\0",0)) {
	if ($lo_cons) {
	    if ($pid = fork) {
		unless ($lo_nowait) {
		    $died = waitpid($pid, 0);
		}
d328 25
a352 6
	    else {
		if (open(CONS,">/dev/console")) {
		    print CONS "<$facility.$priority>$whoami: $message\r";
		    close CONS;
		}
		exit if defined $pid;		# if fork failed, we're parent
d355 7
d365 14
d384 3
a386 1
    eval { &$name } || -1;
d390 68
d463 56
a518 7
    unless ( $sock_type ) {
        my $udp = getprotobyname('udp')                 || croak "getprotobyname failed for udp";
        my $syslog = getservbyname('syslog','udp')      || croak "getservbyname failed";
        my $this = sockaddr_in($syslog, INADDR_ANY);
        my $that = sockaddr_in($syslog, inet_aton($host) || croak "Can't lookup $host");
        socket(SYSLOG,AF_INET,SOCK_DGRAM,$udp)           || croak "socket: $!";
        connect(SYSLOG,$that)                            || croak "connect: $!";
d520 31
a550 8
        my $syslog = _PATH_LOG();
	length($syslog)                                  || croak "_PATH_LOG unavailable in syslog.h";
        my $that = sockaddr_un($syslog)                  || croak "Can't locate $syslog";
        socket(SYSLOG,AF_UNIX,SOCK_STREAM,0)             || croak "socket: $!";
        if (!connect(SYSLOG,$that)) {
            socket(SYSLOG,AF_UNIX,SOCK_DGRAM,0)          || croak "socket: $!";
            connect(SYSLOG,$that) || croak "connect: $! (SOCK_DGRAM after trying SOCK_STREAM)";
        }
d552 16
a567 2
    local($old) = select(SYSLOG); $| = 1; select($old);
    $connected = 1;
d573 1
@


1.3
log
@Change 5985 by gsar@@auger on 2000/04/28 07:30:28
forked child may not exit correctly if it failed to open /dev/console
(from Graham Barr)
@
text
@d73 5
a77 3
A value of 'unix' will connect to the UNIX domain socket returned by
C<_PATH_LOG> in F<syslog.ph>.  A value of 'inet' will connect to an
INET socket returned by getservbyname().  Any other value croaks.
d112 9
a120 4
Tom Christiansen E<lt>F<tchrist@@perl.com>E<gt> and Larry Wall E<lt>F<larry@@wall.org>E<gt>.
UNIX domain sockets added by Sean Robinson E<lt>F<robinson_s@@sc.maricopa.edu>E<gt>
with support from Tim Bunce <Tim.Bunce@@ig.co.uk> and the perl5-porters mailing list.
Dependency on F<syslog.ph> replaced with XS code bu Tom Hughes E<lt>F<tom@@compton.nu>E<gt>.
d169 1
a169 1
        if (defined &_PATH_LOG) {
d277 2
a278 2
        my $udp = getprotobyname('udp');
        my $syslog = getservbyname('syslog','udp');
d284 2
a285 1
        my $syslog = _PATH_LOG()                         || croak "_PATH_LOG not found in syslog.ph";
@


1.2
log
@Change 5969 by gsar@@auger on 2000/04/27 17:50:56
fix Sys::Syslog breakage on domain sockets (from Tom Hughes)
@
text
@a246 1
		    exit if defined $pid;		# if fork failed, we're parent
d249 1
@


1.1
log
@Initial revision
@
text
@d277 1
a277 1
        my $syslog = &_PATH_LOG                          || croak "_PATH_LOG not found in syslog.ph";
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d73 3
a75 5
A value of 'unix' will connect to the UNIX domain socket returned by the
C<_PATH_LOG> macro (if you system defines it) in F<syslog.h>.  A value of
'inet' will connect to an INET socket returned by getservbyname().  If
C<_PATH_LOG> is unavailable or if getservbyname() fails, returns undef.  Any
other value croaks.
d110 4
a113 9
Tom Christiansen E<lt>F<tchrist@@perl.com>E<gt> and Larry Wall
E<lt>F<larry@@wall.org>E<gt>.

UNIX domain sockets added by Sean Robinson
E<lt>F<robinson_s@@sc.maricopa.edu>E<gt> with support from Tim Bunce
E<lt>F<Tim.Bunce@@ig.co.uk>E<gt> and the perl5-porters mailing list.

Dependency on F<syslog.ph> replaced with XS code by Tom Hughes
E<lt>F<tom@@compton.nu>E<gt>.
d162 1
a162 1
        if (length _PATH_LOG()) {
d247 1
a249 1
		exit if defined $pid;		# if fork failed, we're parent
d270 2
a271 2
        my $udp = getprotobyname('udp')                 || croak "getprotobyname failed for udp";
        my $syslog = getservbyname('syslog','udp')      || croak "getservbyname failed";
d277 1
a277 2
        my $syslog = _PATH_LOG();
	length($syslog)                                  || croak "_PATH_LOG unavailable in syslog.h";
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d10 1
a10 15
$VERSION = '0.03';

# it would be nice to try stream/unix first, since that will be
# most efficient. However streams are dodgy - see _syslog_send_stream
#my @@connectMethods = ( 'stream', 'unix', 'tcp', 'udp' );
my @@connectMethods = ( 'tcp', 'udp', 'unix', 'stream', 'console' );
if ($^O =~ /^(freebsd|linux)$/) {
    @@connectMethods = grep { $_ ne 'udp' } @@connectMethods;
}
my @@defaultMethods = @@connectMethods;
my $syslog_path = undef;
my $transmit_ok = 0;
my $current_proto = undef;
my $failed = undef;
my $fail_time = undef;
d24 2
d49 1
a49 1
=over 4
d53 3
a55 5
I<$ident> is prepended to every message.  I<$logopt> contains zero or
more of the words I<pid>, I<ndelay>, I<nowait>.  The cons option is
ignored, since the failover mechanism will drop down to the console
automatically if all other media fail.  I<$facility> specifies the
part of the system
d67 1
a67 1
=item setlogsock $sock_type [$stream_location] (added in 5.004_02)
d73 5
a77 12
A value of 'unix' will connect to the UNIX domain socket returned by
the C<_PATH_LOG> macro (if your system defines it) in F<syslog.ph>.  A
value of 'stream' will connect to the stream indicated by the pathname
provided as the optional second parameter.  A value of 'inet' will
connect to an INET socket (either tcp or udp, tried in that order)
returned by getservbyname(). 'tcp' and 'udp' can also be given as
values. The value 'console' will send messages directly to the
console, as for the 'cons' option in the logopts in openlog().

A reference to an array can also be passed as the first parameter.
When this calling method is used, the array should contain a list of
sock_types which are attempted in order.
d79 1
a79 3
The default is to try tcp, udp, unix, stream, console.

Giving an invalid value for sock_type will croak.
d116 1
a116 1
E<lt>F<robinson_s@@sc.maricopa.edu>E<gt> with support from Tim Bunce 
a121 5
Code for constant()s regenerated by Nicholas Clark E<lt>F<nick@@ccl4.org>E<gt>.

Failover to different communication modes by Nick Williams
E<lt>F<Nick.Williams@@morganstanley.com>E<gt>.

d127 1
a127 1
    
d131 4
a134 4
    croak "&Sys::Syslog::constant not defined" if $constname eq 'constant';
    my ($error, $val) = constant($constname);
    if ($error) {
	croak $error;
d148 1
a166 1
    $syslog_path = shift;
d168 3
a170 17
    $transmit_ok = 0;
    @@fallbackMethods = ();
    @@connectMethods = @@defaultMethods;
    if (ref $setsock eq 'ARRAY') {
	@@connectMethods = @@$setsock;
    } elsif (lc($setsock) eq 'stream') {
	$syslog_path = '/dev/log' unless($syslog_path);
	if (!-w $syslog_path) {
	    carp "stream passed to setlogsock, but $syslog_path is not writable";
	    return undef;
	} else {
	    @@connectMethods = ( 'stream' );
	}
    } elsif (lc($setsock) eq 'unix') {
        if (length _PATH_LOG() && !defined $syslog_path) {
	    $syslog_path = _PATH_LOG();
	    @@connectMethods = ( 'unix' );
d172 1
a172 2
	    carp 'unix passed to setlogsock, but path not available';
	    return undef;
a173 14
    } elsif (lc($setsock) eq 'tcp') {
	if (getservbyname('syslog', 'tcp') || getservbyname('syslogng', 'tcp')) {
	    @@connectMethods = ( 'tcp' );
	} else {
	    carp "tcp passed to setlogsock, but tcp service unavailable";
	    return undef;
	}
    } elsif (lc($setsock) eq 'udp') {
	if (getservbyname('syslog', 'udp')) {
	    @@connectMethods = ( 'udp' );
	} else {
	    carp "udp passed to setlogsock, but udp service unavailable";
	    return undef;
	}
d175 5
a179 3
	@@connectMethods = ( 'tcp', 'udp' );
    } elsif (lc($setsock) eq 'console') {
	@@connectMethods = ( 'console' );
d181 1
a181 1
        carp "Invalid argument passed to setlogsock; must be 'stream', 'unix', 'tcp', 'udp' or 'inet'";
d244 6
a249 28
    my $buf = "<$sum>$whoami: $message\0";

    # it's possible that we'll get an error from sending
    # (e.g. if method is UDP and there is no UDP listener,
    # then we'll get ECONNREFUSED on the send). So what we
    # want to do at this point is to fallback onto a different
    # connection method.
    while (scalar @@fallbackMethods || $syslog_send) {
	if ($failed && (time - $fail_time) > 60) {
	    # it's been a while... maybe things have been fixed
	    @@fallbackMethods = ();
	    disconnect();
	    $transmit_ok = 0; # make it look like a fresh attempt
	    &connect;
        }
	if ($connected && !connection_ok()) {
	    # Something was OK, but has now broken. Remember coz we'll
	    # want to go back to what used to be OK.
	    $failed = $current_proto unless $failed;
	    $fail_time = time;
	    disconnect();
	}
	&connect unless $connected;
	$failed = undef if ($current_proto && $failed && $current_proto eq $failed);
	if ($syslog_send) {
	    if (&{$syslog_send}($buf)) {
		$transmit_ok++;
		return 1;
d251 6
a256 25
	    # typically doesn't happen, since errors are rare from write().
	    disconnect();
	}
    }
    # could not send, could not fallback onto a working
    # connection method. Lose.
    return 0;
}

sub _syslog_send_console {
    my ($buf) = @@_;
    chop($buf); # delete the NUL from the end
    # The console print is a method which could block
    # so we do it in a child process and always return success
    # to the caller.
    if (my $pid = fork) {
	if ($lo_nowait) {
	    return 1;
	} else {
	    if (waitpid($pid, 0) >= 0) {
	    	return ($? >> 8);
	    } else {
		# it's possible that the caller has other
		# plans for SIGCHLD, so let's not interfere
		return 1;
a258 7
    } else {
        if (open(CONS, ">/dev/console")) {
	    my $ret = print CONS $buf . "\r";
	    exit ($ret) if defined $pid;
	    close CONS;
	}
	exit if defined $pid;
a261 14
sub _syslog_send_stream {
    my ($buf) = @@_;
    # XXX: this only works if the OS stream implementation makes a write 
    # look like a putmsg() with simple header. For instance it works on 
    # Solaris 8 but not Solaris 7.
    # To be correct, it should use a STREAMS API, but perl doesn't have one.
    return syswrite(SYSLOG, $buf, length($buf));
}
sub _syslog_send_socket {
    my ($buf) = @@_;
    return syswrite(SYSLOG, $buf, length($buf));
    #return send(SYSLOG, $buf, 0);
}

d267 1
a267 3
    # Can't have just eval { &$name } || -1 because some LOG_XXX may be zero.
    my $value = eval { &$name };
    defined $value ? $value : -1;
a270 68
    @@fallbackMethods = @@connectMethods unless (scalar @@fallbackMethods);
    if ($transmit_ok && $current_proto) {
	# Retry what we were on, because it's worked in the past.
	unshift(@@fallbackMethods, $current_proto);
    }
    $connected = 0;
    my @@errs = ();
    my $proto = undef;
    while ($proto = shift(@@fallbackMethods)) {
	my $fn = "connect_$proto";
	$connected = &$fn(\@@errs) unless (!defined &$fn);
	last if ($connected);
    }

    $transmit_ok = 0;
    if ($connected) {
	$current_proto = $proto;
        local($old) = select(SYSLOG); $| = 1; select($old);
    } else {
	@@fallbackMethods = ();
	foreach my $err (@@errs) {
	    carp $err;
	}
	croak "no connection to syslog available";
    }
}

sub connect_tcp {
    my ($errs) = @@_;
    unless ($host) {
	require Sys::Hostname;
	my($host_uniq) = Sys::Hostname::hostname();
	($host) = $host_uniq =~ /([A-Za-z0-9_.-]+)/; # allow FQDN (inc _)
    }
    my $tcp = getprotobyname('tcp');
    if (!defined $tcp) {
	push(@@{$errs}, "getprotobyname failed for tcp");
	return 0;
    }
    my $syslog = getservbyname('syslog','tcp');
    $syslog = getservbyname('syslogng','tcp') unless (defined $syslog);
    if (!defined $syslog) {
	push(@@{$errs}, "getservbyname failed for tcp");
	return 0;
    }

    my $this = sockaddr_in($syslog, INADDR_ANY);
    my $that = sockaddr_in($syslog, inet_aton($host));
    if (!$that) {
	push(@@{$errs}, "can't lookup $host");
	return 0;
    }
    if (!socket(SYSLOG,AF_INET,SOCK_STREAM,$tcp)) {
	push(@@{$errs}, "tcp socket: $!");
	return 0;
    }
    setsockopt(SYSLOG, SOL_SOCKET, SO_KEEPALIVE, 1);
    setsockopt(SYSLOG, IPPROTO_TCP, TCP_NODELAY, 1);
    if (!CORE::connect(SYSLOG,$that)) {
	push(@@{$errs}, "tcp connect: $!");
	return 0;
    }
    $syslog_send = \&_syslog_send_socket;
    return 1;
}

sub connect_udp {
    my ($errs) = @@_;
d276 7
a282 56
    my $udp = getprotobyname('udp');
    if (!defined $udp) {
	push(@@{$errs}, "getprotobyname failed for udp");
	return 0;
    }
    my $syslog = getservbyname('syslog','udp');
    if (!defined $syslog) {
	push(@@{$errs}, "getservbyname failed for udp");
	return 0;
    }
    my $this = sockaddr_in($syslog, INADDR_ANY);
    my $that = sockaddr_in($syslog, inet_aton($host));
    if (!$that) {
	push(@@{$errs}, "can't lookup $host");
	return 0;
    }
    if (!socket(SYSLOG,AF_INET,SOCK_DGRAM,$udp)) {
	push(@@{$errs}, "udp socket: $!");
	return 0;
    }
    if (!CORE::connect(SYSLOG,$that)) {
	push(@@{$errs}, "udp connect: $!");
	return 0;
    }
    # We want to check that the UDP connect worked. However the only
    # way to do that is to send a message and see if an ICMP is returned
    _syslog_send_socket("");
    if (!connection_ok()) {
	push(@@{$errs}, "udp connect: nobody listening");
	return 0;
    }
    $syslog_send = \&_syslog_send_socket;
    return 1;
}

sub connect_stream {
    my ($errs) = @@_;
    # might want syslog_path to be variable based on syslog.h (if only
    # it were in there!)
    $syslog_path = '/dev/conslog'; 
    if (!-w $syslog_path) {
	push(@@{$errs}, "stream $syslog_path is not writable");
	return 0;
    }
    if (!open(SYSLOG, ">" . $syslog_path)) {
	push(@@{$errs}, "stream can't open $syslog_path: $!");
	return 0;
    }
    $syslog_send = \&_syslog_send_stream;
    return 1;
}

sub connect_unix {
    my ($errs) = @@_;
    if (length _PATH_LOG()) {
	$syslog_path = _PATH_LOG();
d284 8
a291 21
        push(@@{$errs}, "_PATH_LOG not available in syslog.h");
	return 0;
    }
    my $that = sockaddr_un($syslog_path);
    if (!$that) {
	push(@@{$errs}, "can't locate $syslog_path");
	return 0;
    }
    if (!socket(SYSLOG,AF_UNIX,SOCK_STREAM,0)) {
	push(@@{$errs}, "unix stream socket: $!");
	return 0;
    }
    if (!CORE::connect(SYSLOG,$that)) {
        if (!socket(SYSLOG,AF_UNIX,SOCK_DGRAM,0)) {
	    push(@@{$errs}, "unix dgram socket: $!");
	    return 0;
	}
        if (!CORE::connect(SYSLOG,$that)) {
	    push(@@{$errs}, "unix dgram connect: $!");
	    return 0;
	}
d293 2
a294 26
    $syslog_send = \&_syslog_send_socket;
    return 1;
}

sub connect_console {
    my ($errs) = @@_;
    if (!-w '/dev/console') {
	push(@@{$errs}, "console is not writable");
	return 0;
    }
    $syslog_send = \&_syslog_send_console;
    return 1;
}

# to test if the connection is still good, we need to check if any
# errors are present on the connection. The errors will not be raised
# by a write. Instead, sockets are made readable and the next read
# would cause the error to be returned. Unfortunately the syslog 
# 'protocol' never provides anything for us to read. But with 
# judicious use of select(), we can see if it would be readable...
sub connection_ok {
    return 1 if (defined $current_proto && $current_proto eq 'console');
    my $rin = '';
    vec($rin, fileno(SYSLOG), 1) = 1;
    my $ret = select $rin, undef, $rin, 0;
    return ($ret ? 0 : 1);
a299 1
    $syslog_send = undef;
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d10 1
a10 1
$VERSION = '0.04';
d29 9
d48 1
a48 1
    openlog $ident, $logopt, $facility;       # don't forget this
d69 1
a69 5
part of the system to report about, for example LOG_USER or LOG_LOCAL0:
see your C<syslog(3)> documentation for the facilities available in
your system.

B<You should use openlog() before calling syslog().>
a76 4
If you didn't use openlog() before using syslog(), syslog will try to
guess the I<$ident> by extracting the shortest prefix of I<$format>
that ends in a ":".

d87 8
a94 11
A value of 'unix' will connect to the UNIX domain socket (in some
systems a character special device) returned by the C<_PATH_LOG> macro
(if your system defines it), or F</dev/log> or F</dev/conslog>,
whatever is writable.  A value of 'stream' will connect to the stream
indicated by the pathname provided as the optional second parameter.
(For example Solaris and IRIX require 'stream' instead of 'unix'.)
A value of 'inet' will connect to an INET socket (either tcp or udp,
tried in that order) returned by getservbyname(). 'tcp' and 'udp' can
also be given as values. The value 'console' will send messages
directly to the console, as for the 'cons' option in the logopts in
openlog().
d202 2
a203 15
	unless (defined $syslog_path) {
	    my @@try = qw(/dev/log /dev/conslog);
	    if (length &_PATH_LOG) { # Undefined _PATH_LOG is "".
		unshift @@try, &_PATH_LOG;
            }
	    for my $try (@@try) {
		if (-w $try) {
		    $syslog_path = $try;
		    last;
		}
	    }
	    carp "stream passed to setlogsock, but could not find any device"
		unless defined $syslog_path;
        }
	unless (-w $syslog_path) {
d248 1
a248 2
    croak "syslog: expecting argument \$priority" unless $priority;
    croak "syslog: expecting argument \$format"   unless $mask;
@


1.1.1.5
log
@Import of stock perl 5.8.5
@
text
@d10 1
a10 1
$VERSION = '0.05';
a396 1
    return $name+0 if $name =~ /^\s*\d+\s*$/;
@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@a130 6
    # Log to UDP port on $remotehost instead of logging locally
    setlogsock('udp');
    $Sys::Syslog::host = $remotehost;
    openlog($program, 'ndelay', 'user');
    syslog('info', 'something happened over here');

@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d2 3
a4 1
use strict;
a5 2
require 5.006;
require Exporter;
d7 4
a10 25
our $VERSION = '0.13';
our @@ISA = qw(Exporter);

our %EXPORT_TAGS = (
    standard => [qw(openlog syslog closelog setlogmask)],
    extended => [qw(setlogsock)],
    macros => [qw(
        LOG_ALERT LOG_AUTH LOG_AUTHPRIV LOG_CONS LOG_CRIT LOG_CRON
        LOG_DAEMON LOG_DEBUG LOG_EMERG LOG_ERR LOG_FACMASK LOG_FTP
        LOG_INFO LOG_KERN LOG_LFMT LOG_LOCAL0 LOG_LOCAL1 LOG_LOCAL2
        LOG_LOCAL3 LOG_LOCAL4 LOG_LOCAL5 LOG_LOCAL6 LOG_LOCAL7 LOG_LPR
        LOG_MAIL LOG_NDELAY LOG_NEWS LOG_NFACILITIES LOG_NOTICE
        LOG_NOWAIT LOG_ODELAY LOG_PERROR LOG_PID LOG_PRIMASK LOG_SYSLOG
        LOG_USER LOG_UUCP LOG_WARNING
    )],
);

our @@EXPORT = (
    @@{$EXPORT_TAGS{standard}}, 
);

our @@EXPORT_OK = (
    @@{$EXPORT_TAGS{extended}}, 
    @@{$EXPORT_TAGS{macros}}, 
);
d14 1
a24 1
our ($connected, @@fallbackMethods, $syslog_send, $host);
d26 2
a27 2
use Socket ':all';
use POSIX qw(strftime setlocale LC_TIME);
d31 1
a31 5
Sys::Syslog - Perl interface to the UNIX syslog(3) calls

=head1 VERSION

Version 0.13
d35 2
a36 3
    use Sys::Syslog;                          # all except setlogsock(), or:
    use Sys::Syslog qw(:DEFAULT setlogsock);  # default set, plus setlogsock()
    use Sys::Syslog qw(:standard :macros);    # standard functions, plus macros
a43 1

d46 1
a46 1
C<Sys::Syslog> is an interface to the UNIX C<syslog(3)> program.
d50 1
a50 4

=head1 EXPORTS

C<Sys::Syslog> exports the following C<Exporter> tags: 
d54 1
a54 11
=item *

C<:standard> exports the standard C<syslog(3)> functions: 

    openlog closelog setlogmask syslog

=item *

C<:extended> exports the Perl specific functions for C<syslog(3)>: 

    setlogsock
d56 2
a57 19
=item *

C<:macros> exports the symbols corresponding to most of your C<syslog(3)> 
macros. See L<"CONSTANTS"> for the supported constants and their meaning. 

=back

By default, C<Sys::Syslog> exports the symbols from the C<:standard> tag. 


=head1 FUNCTIONS

=over 4

=item B<openlog($ident, $logopt, $facility)>

Opens the syslog.
C<$ident> is prepended to every message.  C<$logopt> contains zero or
more of the words C<pid>, C<ndelay>, C<nowait>.  The C<cons> option is
d59 2
a60 2
automatically if all other media fail.  C<$facility> specifies the
part of the system to report about, for example C<LOG_USER> or C<LOG_LOCAL0>:
d62 1
a62 5
your system. Facility can be given as a string or a numeric macro. 

This function will croak if it can't connect to the syslog daemon.

Note that C<openlog()> now takes three arguments, just like C<openlog(3)>.
d66 1
a66 54
B<Options>

=over 4

=item *

C<ndelay> - Open the connection immediately (normally, the connection is
opened when the first message is logged).

=item *

C<nowait> - Don't wait for child processes that may have been created 
while logging the message.  (The GNU C library does not create a child
process, so this option has no effect on Linux.)

=item *

C<pid> - Include PID with each message.

=back

B<Examples>

Open the syslog with options C<ndelay> and C<pid>, and with facility C<LOCAL0>: 

    openlog($name, "ndelay,pid", "local0");

Same thing, but this time using the macro corresponding to C<LOCAL0>: 

    openlog($name, "ndelay,pid", LOG_LOCAL0);


=item B<syslog($priority, $message)>

=item B<syslog($priority, $format, @@args)>

If C<$priority> permits, logs C<$message> or C<sprintf($format, @@args)>
with the addition that C<%m> in $message or C<$format> is replaced with
C<"$!"> (the latest error message). 

C<$priority> can specify a level, or a level and a facility.  Levels and 
facilities can be given as strings or as macros.

If you didn't use C<openlog()> before using C<syslog()>, C<syslog()> will 
try to guess the C<$ident> by extracting the shortest prefix of 
C<$format> that ends in a C<":">.

B<Examples>

    syslog("info", $message);           # informational level
    syslog(LOG_INFO, $message);         # informational level

    syslog("info|local0", $message);        # information level, Local0 facility
    syslog(LOG_INFO|LOG_LOCAL0, $message);  # information level, Local0 facility
d68 3
a70 16
=over 4

=item B<Note>

C<Sys::Syslog> version v0.07 and older passed the C<$message> as the 
formatting string to C<sprintf()> even when no formatting arguments
were provided.  If the code calling C<syslog()> might execute with 
older versions of this module, make sure to call the function as
C<syslog($priority, "%s", $message)> instead of C<syslog($priority,
$message)>.  This protects against hostile formatting sequences that
might show up if $message contains tainted data.

=back


=item B<setlogmask($mask_priority)>
d72 3
a74 3
Sets the log mask for the current process to C<$mask_priority> and 
returns the old mask.  If the mask argument is 0, the current log mask 
is not modified.  See L<"Levels"> for the list of available levels. 
d76 1
a76 1
B<Examples>
d78 1
a78 1
Only log errors: 
d80 1
a80 10
    setlogmask(LOG_ERR);

Log critical messages, errors and warnings: 

    setlogmask(LOG_CRIT|LOG_ERR|LOG_WARNING);


=item B<setlogsock($sock_type)>

=item B<setlogsock($sock_type, $stream_location)> (added in 5.004_02)
d83 2
a84 2
C<openlog()> or C<syslog()> and returns true on success,
C<undef> on failure.
d86 1
a86 1
A value of C<"unix"> will connect to the UNIX domain socket (in some
d91 6
a96 6
(For example Solaris and IRIX require C<"stream"> instead of C<"unix">.)
A value of C<"inet"> will connect to an INET socket (either C<tcp> or C<udp>,
tried in that order) returned by C<getservbyname()>. C<"tcp"> and C<"udp"> can
also be given as values. The value C<"console"> will send messages
directly to the console, as for the C<"cons"> option in the logopts in
C<openlog()>.
d102 1
a102 3
The default is to try C<tcp>, C<udp>, C<unix>, C<stream>, C<console>.

Giving an invalid value for C<$sock_type> will croak.
d104 1
d106 1
a106 1
=item B<closelog()>
d108 1
a108 1
Closes the log file and return true on success.
d112 1
d117 1
a117 1
    syslog('info', '%s', 'this is another test');
a136 162

=head1 CONSTANTS

=head2 Facilities

=over 4

=item *

C<LOG_AUTH> - security/authorization messages

=item *

C<LOG_AUTHPRIV> - security/authorization messages (private)

=item *

C<LOG_CRON> - clock daemon (B<cron> and B<at>)

=item *

C<LOG_DAEMON> - system daemons without separate facility value

=item *

C<LOG_FTP> - ftp daemon

=item *

C<LOG_KERN> - kernel messages

=item *

C<LOG_LOCAL0> through C<LOG_LOCAL7> - reserved for local use

=item *

C<LOG_LPR> - line printer subsystem

=item *

C<LOG_MAIL> - mail subsystem

=item *

C<LOG_NEWS> - USENET news subsystem

=item *

C<LOG_SYSLOG> - messages generated internally by B<syslogd>

=item *

C<LOG_USER> (default) - generic user-level messages

=item *

C<LOG_UUCP> - UUCP subsystem

=back


=head2 Levels

=over 4

=item *

C<LOG_EMERG> - system is unusable

=item *

C<LOG_ALERT> - action must be taken immediately

=item *

C<LOG_CRIT> - critical conditions

=item *

C<LOG_ERR> - error conditions

=item *

C<LOG_WARNING> - warning conditions

=item *

C<LOG_NOTICE> - normal, but significant, condition

=item *

C<LOG_INFO> - informational message

=item *

C<LOG_DEBUG> - debug-level message

=back


=head1 DIAGNOSTICS

=over 4

=item Invalid argument passed to setlogsock

B<(F)> You gave C<setlogsock()> an invalid value for C<$sock_type>. 

=item no connection to syslog available

B<(F)> C<syslog()> failed to connect to the specified socket.

=item stream passed to setlogsock, but %s is not writable

B<(W)> You asked C<setlogsock()> to use a stream socket, but the given 
path is not writable. 

=item stream passed to setlogsock, but could not find any device

B<(W)> You asked C<setlogsock()> to use a stream socket, but didn't 
provide a path, and C<Sys::Syslog> was unable to find an appropriate one.

=item tcp passed to setlogsock, but tcp service unavailable

B<(W)> You asked C<setlogsock()> to use a TCP socket, but the service 
is not available on the system. 

=item syslog: expecting argument %s

B<(F)> You forgot to give C<syslog()> the indicated argument.

=item syslog: invalid level/facility: %s

B<(F)> You specified an invalid level or facility, like C<LOG_KERN> 
(which is reserved to the kernel). 

=item syslog: too many levels given: %s

B<(F)> You specified too many levels. 

=item syslog: too many facilities given: %s

B<(F)> You specified too many facilities. 

=item syslog: level must be given

B<(F)> You forgot to specify a level.

=item udp passed to setlogsock, but udp service unavailable

B<(W)> You asked C<setlogsock()> to use a UDP socket, but the service 
is not available on the system. 

=item unix passed to setlogsock, but path not available

B<(W)> You asked C<setlogsock()> to use a UNIX socket, but C<Sys::Syslog> 
was unable to find an appropriate an appropriate device.

=back


a140 3
I<Syslogging with Perl>, L<http://lexington.pm.org/meetings/022001.html>


d148 1
a148 1
E<lt>F<Tim.Bunce@@ig.co.uk>E<gt> and the C<perl5-porters> mailing list.
d153 1
a153 1
Code for C<constant()>s regenerated by Nicholas Clark E<lt>F<nick@@ccl4.org>E<gt>.
a157 47
Extracted from core distribution for publishing on the CPAN by 
SE<eacute>bastien Aperghis-Tramoni E<lt>sebastien@@aperghis.netE<gt>.


=head1 BUGS

Please report any bugs or feature requests to
C<bug-sys-syslog at rt.cpan.org>, or through the web interface at
L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Sys-Syslog>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.


=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Sys::Syslog

You can also look for information at:

=over 4

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Sys-Syslog>

=item * CPAN Ratings

L<http://cpanratings.perl.org/d/Sys-Syslog>

=item * RT: CPAN's request tracker

L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Sys-Syslog>

=item * Search CPAN

L<http://search.cpan.org/dist/Sys-Syslog>

=back


=head1 LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

d163 1
d169 3
a171 2
	croak $error if $error;
    no strict 'refs';
d176 1
a176 9
eval {
    require XSLoader;
    XSLoader::load('Sys::Syslog', $VERSION);
    1
} or do {
    require DynaLoader;
    push @@ISA, 'DynaLoader';
    bootstrap Sys::Syslog $VERSION;
};
d178 1
a178 1
our $maskpri = &LOG_UPTO(&LOG_DEBUG);
d181 4
a184 4
    our ($ident, $logopt, $facility) = @@_;  # package vars
    our $lo_pid = $logopt =~ /\bpid\b/;
    our $lo_ndelay = $logopt =~ /\bndelay\b/;
    our $lo_nowait = $logopt =~ /\bnowait\b/;
d190 1
a190 1
    our $facility = our $ident = '';
d195 2
a196 2
    my $oldmask = $maskpri;
    $maskpri = shift unless $_[0] == 0;
d201 1
a201 1
    my $setsock = shift;
d222 1
a222 1
		unless defined $syslog_path
d257 1
a257 1
        croak "Invalid argument passed to setlogsock; must be 'stream', 'unix', 'tcp', 'udp' or 'inet'"
d263 4
a266 5
    my $priority = shift;
    my $mask = shift;
    my ($message, $whoami);
    my (@@words, $num, $numpri, $numfac, $sum);
    our $facility;
d269 2
a270 2
    croak "syslog: expecting argument \$priority" unless defined $priority;
    croak "syslog: expecting argument \$format"   unless defined $mask;
d277 2
a278 2
	if ($_ eq 'kern' || $num <= 0) {
	    croak "syslog: invalid level/facility: $_"
d301 1
a301 1
    $whoami = our $ident;
d314 1
a314 9
    $whoami .= "[$$]" if our $lo_pid;

    if ($mask =~ /%m/) {
	my $err = $!;
	# escape percent signs if sprintf will be called
	$err =~ s/%/%%/g if @@_;
	# replace %m with $err, if preceded by an even number of percent signs
	$mask =~ s/(?<!%)((?:%%)*)%m/$1$err/g;
    }
d316 1
d318 1
a318 1
    $message = @@_ ? sprintf($mask, @@_) : $mask;
d321 1
a321 5
    my $oldlocale = setlocale(LC_TIME);
    setlocale(LC_TIME, 'C');
    my $timestamp = strftime "%b %e %T", localtime;
    setlocale(LC_TIME, $oldlocale);
    my $buf = "<$sum>$timestamp $whoami: $message\0";
a365 1
	our $lo_nowait;
a394 1

d402 1
a402 1
    my($name) = @@_;
d408 1
a408 1
    my $value = eval { no strict 'refs'; &$name };
a421 1
	no strict 'refs';
d423 1
a423 1
	$connected = &$fn(\@@errs) if defined &$fn;
d430 1
a430 1
        my($old) = select(SYSLOG); $| = 1; select($old);
d433 4
a436 1
	croak join "\n\t- ", "no connection to syslog available", @@errs
d442 5
d455 1
a455 1
	push(@@{$errs}, "getservbyname failed for syslog/tcp and syslogng/tcp");
d460 4
a463 9
    my $that;
    if (defined $host) {
	$that = inet_aton($host);
	if (!$that) {
	    push(@@{$errs}, "can't lookup $host");
	    return 0;
	}
    } else {
	$that = INADDR_LOOPBACK;
a464 2
    $that = sockaddr_in($syslog, $that);

d481 5
d493 1
a493 1
	push(@@{$errs}, "getservbyname failed for syslog/udp");
d497 4
a500 9
    my $that;
    if (defined $host) {
	$that = inet_aton($host);
	if (!$that) {
	    push(@@{$errs}, "can't lookup $host");
	    return 0;
	}
    } else {
	$that = INADDR_LOOPBACK;
a501 2
    $that = sockaddr_in($syslog, $that);

a545 4
    if (! -S $syslog_path) {
	push(@@{$errs}, "$syslog_path is not a socket");
	return 0;
    }
d594 1
a596 1
    return close SYSLOG;
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@a2 1
use warnings::register;
d4 1
a4 5
use Fcntl qw(O_WRONLY);
use File::Basename;
use POSIX qw(strftime setlocale LC_TIME);
use Socket ':all';
require 5.005;
d7 16
a22 60
{   no strict 'vars';
    $VERSION = '0.22';
    @@ISA = qw(Exporter);

    %EXPORT_TAGS = (
        standard => [qw(openlog syslog closelog setlogmask)],
        extended => [qw(setlogsock)],
        macros => [
            # levels
            qw(
                LOG_ALERT LOG_CRIT LOG_DEBUG LOG_EMERG LOG_ERR 
                LOG_INFO LOG_NOTICE LOG_WARNING
            ), 

            # standard facilities
            qw(
                LOG_AUTH LOG_AUTHPRIV LOG_CRON LOG_DAEMON LOG_FTP LOG_KERN
                LOG_LOCAL0 LOG_LOCAL1 LOG_LOCAL2 LOG_LOCAL3 LOG_LOCAL4
                LOG_LOCAL5 LOG_LOCAL6 LOG_LOCAL7 LOG_LPR LOG_MAIL LOG_NEWS
                LOG_SYSLOG LOG_USER LOG_UUCP
            ),
            # Mac OS X specific facilities
            qw( LOG_INSTALL LOG_LAUNCHD LOG_NETINFO LOG_RAS LOG_REMOTEAUTH ),
            # modern BSD specific facilities
            qw( LOG_CONSOLE LOG_NTP LOG_SECURITY ),
            # IRIX specific facilities
            qw( LOG_AUDIT LOG_LFMT ),

            # options
            qw(
                LOG_CONS LOG_PID LOG_NDELAY LOG_NOWAIT LOG_ODELAY LOG_PERROR 
            ), 

            # others macros
            qw(
                LOG_FACMASK LOG_NFACILITIES LOG_PRIMASK 
                LOG_MASK LOG_UPTO
            ), 
        ],
    );

    @@EXPORT = (
        @@{$EXPORT_TAGS{standard}}, 
    );

    @@EXPORT_OK = (
        @@{$EXPORT_TAGS{extended}}, 
        @@{$EXPORT_TAGS{macros}}, 
    );

    eval {
        require XSLoader;
        XSLoader::load('Sys::Syslog', $VERSION);
        1
    } or do {
        require DynaLoader;
        push @@ISA, 'DynaLoader';
        bootstrap Sys::Syslog $VERSION;
    };
}
d24 3
d28 3
a30 25
# 
# Public variables
# 
use vars qw($host);             # host to send syslog messages to (see notes at end)

# 
# Global variables
# 
use vars qw($facility);
my $connected = 0;              # flag to indicate if we're connected or not
my $syslog_send;                # coderef of the function used to send messages
my $syslog_path = undef;        # syslog path for "stream" and "unix" mechanisms
my $syslog_xobj = undef;        # if defined, holds the external object used to send messages
my $transmit_ok = 0;            # flag to indicate if the last message was transmited
my $current_proto = undef;      # current mechanism used to transmit messages
my $ident = '';                 # identifiant prepended to each message
$facility = '';                 # current facility
my $maskpri = LOG_UPTO(&LOG_DEBUG);     # current log mask

my %options = (
    ndelay  => 0, 
    nofatal => 0, 
    nowait  => 0, 
    perror  => 0, 
    pid     => 0, 
d33 3
a35 3
# Default is now to first use the native mechanism, so Perl programs 
# behave like other normal Unix programs, then try other mechanisms.
my @@connectMethods = qw(native tcp udp unix pipe stream console);
d39 7
d47 2
a48 7
EVENTLOG: {
    # use EventLog on Win32
    my $is_Win32 = $^O =~ /Win32/i;

    # some applications are trying to be too smart
    # yes I'm speaking of YOU, SpamAssassin, grr..
    local($SIG{__DIE__}, $SIG{__WARN__}, $@@);
d50 1
a50 7
    if (eval "use Sys::Syslog::Win32; 1") {
        unshift @@connectMethods, 'eventlog';
    }
    elsif ($is_Win32) {
        warn $@@;
    }
}
d52 1
a52 2
my @@defaultMethods = @@connectMethods;
my @@fallbackMethods = ();
d54 1
a54 2
# coderef for a nicer handling of errors
my $err_sub = $options{nofatal} ? \&warnings::warnif : \&croak;
d56 1
d58 1
a58 13
sub AUTOLOAD {
    # This AUTOLOAD is used to 'autoload' constants from the constant()
    # XS function.
    no strict 'vars';
    my $constname;
    ($constname = $AUTOLOAD) =~ s/.*:://;
    croak "Sys::Syslog::constant() not defined" if $constname eq 'constant';
    my ($error, $val) = constant($constname);
    croak $error if $error;
    no strict 'refs';
    *$AUTOLOAD = sub { $val };
    goto &$AUTOLOAD;
}
d60 3
d64 5
a68 2
sub openlog {
    ($ident, my $logopt, $facility) = @@_;
a69 4
    # default values
    $ident    ||= basename($0) || getlogin() || getpwuid($<) || 'syslog';
    $logopt   ||= '';
    $facility ||= LOG_USER();
d71 1
a71 3
    for my $opt (split /\b/, $logopt) {
        $options{$opt} = 1 if exists $options{$opt}
    }
d73 3
a75 4
    $err_sub = $options{nofatal} ? \&warnings::warnif : \&croak;
    return 1 unless $options{ndelay};
    connect_log();
} 
a76 4
sub closelog {
    $facility = $ident = '';
    disconnect_log();
} 
d78 1
a78 13
sub setlogmask {
    my $oldmask = $maskpri;
    $maskpri = shift unless $_[0] == 0;
    $oldmask;
}
 
sub setlogsock {
    my $setsock = shift;
    $syslog_path = shift;
    disconnect_log() if $connected;
    $transmit_ok = 0;
    @@fallbackMethods = ();
    @@connectMethods = @@defaultMethods;
d80 1
a80 2
    if (ref $setsock eq 'ARRAY') {
	@@connectMethods = @@$setsock;
d82 1
a82 3
    } elsif (lc $setsock eq 'stream') {
	if (not defined $syslog_path) {
	    my @@try = qw(/dev/log /dev/conslog);
d84 1
a84 3
            if (length &_PATH_LOG) {        # Undefined _PATH_LOG is "".
		unshift @@try, &_PATH_LOG;
            }
d86 1
a86 6
	    for my $try (@@try) {
		if (-w $try) {
		    $syslog_path = $try;
		    last;
		}
	    }
d88 1
a88 5
            if (not defined $syslog_path) {
                warnings::warnif "stream passed to setlogsock, but could not find any device";
                return undef
            }
        }
d90 1
a90 6
	if (not -w $syslog_path) {
            warnings::warnif "stream passed to setlogsock, but $syslog_path is not writable";
	    return undef;
	} else {
            @@connectMethods = qw(stream);
	}
d92 1
a92 8
    } elsif (lc $setsock eq 'unix') {
        if (length _PATH_LOG() || (defined $syslog_path && -w $syslog_path)) {
	    $syslog_path = _PATH_LOG() unless defined $syslog_path;
            @@connectMethods = qw(unix);
        } else {
            warnings::warnif 'unix passed to setlogsock, but path not available';
	    return undef;
        }
d94 1
a94 6
    } elsif (lc $setsock eq 'pipe') {
        for my $path ($syslog_path, &_PATH_LOG, "/dev/log") {
            next unless defined $path and length $path and -w $path;
            $syslog_path = $path;
            last
        }
d96 1
a96 4
        if (not $syslog_path) {
            warnings::warnif "pipe passed to setlogsock, but path not available";
            return undef
        }
d98 2
a99 1
        @@connectMethods = qw(pipe);
d101 1
a101 2
    } elsif (lc $setsock eq 'native') {
        @@connectMethods = qw(native);
d103 1
a103 8
    } elsif (lc $setsock eq 'eventlog') {
        if (eval "use Win32::EventLog; 1") {
            @@connectMethods = qw(eventlog);
        } else {
            warnings::warnif "eventlog passed to setlogsock, but no Win32 API available";
            $@@ = "";
            return undef;
        }
a104 7
    } elsif (lc $setsock eq 'tcp') {
	if (getservbyname('syslog', 'tcp') || getservbyname('syslogng', 'tcp')) {
            @@connectMethods = qw(tcp);
	} else {
            warnings::warnif "tcp passed to setlogsock, but tcp service unavailable";
	    return undef;
	}
d106 1
a106 7
    } elsif (lc $setsock eq 'udp') {
	if (getservbyname('syslog', 'udp')) {
            @@connectMethods = qw(udp);
	} else {
            warnings::warnif "udp passed to setlogsock, but udp service unavailable";
	    return undef;
	}
d108 1
a108 2
    } elsif (lc $setsock eq 'inet') {
	@@connectMethods = ( 'tcp', 'udp' );
d110 1
a110 2
    } elsif (lc $setsock eq 'console') {
	@@connectMethods = qw(console);
d112 8
a119 4
    } else {
        croak "Invalid argument passed to setlogsock; must be 'stream', 'pipe', ",
              "'unix', 'native', 'eventlog', 'tcp', 'udp' or 'inet'"
    }
d121 1
a121 2
    return 1;
}
d123 1
a123 12
sub syslog {
    my $priority = shift;
    my $mask = shift;
    my ($message, $buf);
    my (@@words, $num, $numpri, $numfac, $sum);
    my $failed = undef;
    my $fail_time = undef;
    my $error = $!;

    # if $ident is undefined, it means openlog() wasn't previously called
    # so do it now in order to have sensible defaults
    openlog() unless $ident;
d125 1
a125 1
    local $facility = $facility;    # may need to change temporarily.
d127 1
a127 2
    croak "syslog: expecting argument \$priority" unless defined $priority;
    croak "syslog: expecting argument \$format"   unless defined $mask;
d129 1
a129 3
    @@words = split(/\W+/, $priority, 2);    # Allow "level" or "level|facility".
    undef $numpri;
    undef $numfac;
d131 1
a131 16
    foreach (@@words) {
	$num = xlate($_);		    # Translate word to number.
	if ($num < 0) {
	    croak "syslog: invalid level/facility: $_"
	}
	elsif ($num <= &LOG_PRIMASK) {
	    croak "syslog: too many levels given: $_" if defined $numpri;
	    $numpri = $num;
	    return 0 unless LOG_MASK($numpri) & $maskpri;
	}
	else {
	    croak "syslog: too many facilities given: $_" if defined $numfac;
	    $facility = $_;
	    $numfac = $num;
	}
    }
d133 2
a134 1
    croak "syslog: level must be given" unless defined $numpri;
d136 1
a136 4
    if (not defined $numfac) {  # Facility not specified in this call.
	$facility = 'user' unless $facility;
	$numfac = xlate($facility);
    }
d138 3
a140 1
    connect_log() unless $connected;
d142 1
a142 6
    if ($mask =~ /%m/) {
        # escape percent signs for sprintf()
        $error =~ s/%/%%/g if @@_;
        # replace %m with $error, if preceded by an even number of percent signs
        $mask =~ s/(?<!%)((?:%%)*)%m/$1$error/g;
    }
d144 1
a144 2
    $mask .= "\n" unless $mask =~ /\n$/;
    $message = @@_ ? sprintf($mask, @@_) : $mask;
d146 1
a146 30
    # See CPAN-RT#24431. Opened on Apple Radar as bug #4944407 on 2007.01.21
    # Supposedly resolved on Leopard.
    chomp $message if $^O =~ /darwin/;

    if ($current_proto eq 'native') {
        $buf = $message;
    }
    elsif ($current_proto eq 'eventlog') {
        $buf = $message;
    }
    else {
        my $whoami = $ident;
        $whoami .= "[$$]" if $options{pid};

        $sum = $numpri + $numfac;
        my $oldlocale = setlocale(LC_TIME);
        setlocale(LC_TIME, 'C');
        my $timestamp = strftime "%b %e %T", localtime;
        setlocale(LC_TIME, $oldlocale);
        $buf = "<$sum>$timestamp $whoami: $message\0";
    }

    # handle PERROR option
    # "native" mechanism already handles it by itself
    if ($options{perror} and $current_proto ne 'native') {
        chomp $message;
        my $whoami = $ident;
        $whoami .= "[$$]" if $options{pid};
        print STDERR "$whoami: $message\n";
    }
d148 1
a148 13
    # it's possible that we'll get an error from sending
    # (e.g. if method is UDP and there is no UDP listener,
    # then we'll get ECONNREFUSED on the send). So what we
    # want to do at this point is to fallback onto a different
    # connection method.
    while (scalar @@fallbackMethods || $syslog_send) {
	if ($failed && (time - $fail_time) > 60) {
	    # it's been a while... maybe things have been fixed
	    @@fallbackMethods = ();
	    disconnect_log();
	    $transmit_ok = 0; # make it look like a fresh attempt
	    connect_log();
        }
d150 1
a150 7
	if ($connected && !connection_ok()) {
	    # Something was OK, but has now broken. Remember coz we'll
	    # want to go back to what used to be OK.
	    $failed = $current_proto unless $failed;
	    $fail_time = time;
	    disconnect_log();
	}
d152 1
a152 2
	connect_log() unless $connected;
	$failed = undef if ($current_proto && $failed && $current_proto eq $failed);
d154 1
a154 13
	if ($syslog_send) {
            if ($syslog_send->($buf, $numpri, $numfac)) {
		$transmit_ok++;
		return 1;
	    }
	    # typically doesn't happen, since errors are rare from write().
	    disconnect_log();
	}
    }
    # could not send, could not fallback onto a working
    # connection method. Lose.
    return 0;
}
d156 1
a156 7
sub _syslog_send_console {
    my ($buf) = @@_;
    chop($buf); # delete the NUL from the end
    # The console print is a method which could block
    # so we do it in a child process and always return success
    # to the caller.
    if (my $pid = fork) {
a157 20
	if ($options{nowait}) {
	    return 1;
	} else {
	    if (waitpid($pid, 0) >= 0) {
	    	return ($? >> 8);
	    } else {
		# it's possible that the caller has other
		# plans for SIGCHLD, so let's not interfere
		return 1;
	    }
	}
    } else {
        if (open(CONS, ">/dev/console")) {
	    my $ret = print CONS $buf . "\r";  # XXX: should this be \x0A ?
	    exit $ret if defined $pid;
	    close CONS;
	}
	exit if defined $pid;
    }
}
d159 1
a159 8
sub _syslog_send_stream {
    my ($buf) = @@_;
    # XXX: this only works if the OS stream implementation makes a write 
    # look like a putmsg() with simple header. For instance it works on 
    # Solaris 8 but not Solaris 7.
    # To be correct, it should use a STREAMS API, but perl doesn't have one.
    return syswrite(SYSLOG, $buf, length($buf));
}
d161 1
a161 4
sub _syslog_send_pipe {
    my ($buf) = @@_;
    return print SYSLOG $buf;
}
d163 3
a165 5
sub _syslog_send_socket {
    my ($buf) = @@_;
    return syswrite(SYSLOG, $buf, length($buf));
    #return send(SYSLOG, $buf, 0);
}
d167 2
a168 5
sub _syslog_send_native {
    my ($buf, $numpri) = @@_;
    syslog_xs($numpri, $buf);
    return 1;
}
d170 3
d174 1
a174 15
# xlate()
# -----
# private function to translate names to numeric values
# 
sub xlate {
    my($name) = @@_;
    return $name+0 if $name =~ /^\s*\d+\s*$/;
    $name = uc $name;
    $name = "LOG_$name" unless $name =~ /^LOG_/;
    $name = "Sys::Syslog::$name";
    # Can't have just eval { &$name } || -1 because some LOG_XXX may be zero.
    my $value = eval { no strict 'refs'; &$name };
    $@@ = "";
    return defined $value ? $value : -1;
}
d176 2
d179 2
a180 8
# connect_log()
# -----------
# This function acts as a kind of front-end: it tries to connect to 
# a syslog service using the selected methods, trying each one in the 
# selected order. 
# 
sub connect_log {
    @@fallbackMethods = @@connectMethods unless scalar @@fallbackMethods;
d182 1
a182 4
    if ($transmit_ok && $current_proto) {
        # Retry what we were on, because it has worked in the past.
	unshift(@@fallbackMethods, $current_proto);
    }
d184 1
a184 3
    $connected = 0;
    my @@errs = ();
    my $proto = undef;
d186 7
a192 6
    while ($proto = shift @@fallbackMethods) {
	no strict 'refs';
	my $fn = "connect_$proto";
	$connected = &$fn(\@@errs) if defined &$fn;
	last if $connected;
    }
d194 1
a194 10
    $transmit_ok = 0;
    if ($connected) {
	$current_proto = $proto;
        my ($old) = select(SYSLOG); $| = 1; select($old);
    } else {
	@@fallbackMethods = ();
        $err_sub->(join "\n\t- ", "no connection to syslog available", @@errs);
        return undef;
    }
}
a195 2
sub connect_tcp {
    my ($errs) = @@_;
d197 1
a197 5
    my $tcp = getprotobyname('tcp');
    if (!defined $tcp) {
	push @@$errs, "getprotobyname failed for tcp";
	return 0;
    }
d199 3
a201 6
    my $syslog = getservbyname('syslog', 'tcp');
    $syslog = getservbyname('syslogng', 'tcp') unless defined $syslog;
    if (!defined $syslog) {
	push @@$errs, "getservbyname failed for syslog/tcp and syslogng/tcp";
	return 0;
    }
d203 1
a203 11
    my $addr;
    if (defined $host) {
        $addr = inet_aton($host);
        if (!$addr) {
	    push @@$errs, "can't lookup $host";
	    return 0;
	}
    } else {
        $addr = INADDR_LOOPBACK;
    }
    $addr = sockaddr_in($syslog, $addr);
d205 1
a205 4
    if (!socket(SYSLOG, AF_INET, SOCK_STREAM, $tcp)) {
	push @@$errs, "tcp socket: $!";
	return 0;
    }
d207 1
a207 10
    setsockopt(SYSLOG, SOL_SOCKET, SO_KEEPALIVE, 1);
    if (eval { IPPROTO_TCP() }) {
        # These constants don't exist in 5.005. They were added in 1999
        setsockopt(SYSLOG, IPPROTO_TCP(), TCP_NODELAY(), 1);
    }
    $@@ = "";
    if (!connect(SYSLOG, $addr)) {
	push @@$errs, "tcp connect: $!";
	return 0;
    }
d209 1
a209 1
    $syslog_send = \&_syslog_send_socket;
d211 1
a211 2
    return 1;
}
a212 2
sub connect_udp {
    my ($errs) = @@_;
d214 1
a214 5
    my $udp = getprotobyname('udp');
    if (!defined $udp) {
	push @@$errs, "getprotobyname failed for udp";
	return 0;
    }
d216 1
a216 5
    my $syslog = getservbyname('syslog', 'udp');
    if (!defined $syslog) {
	push @@$errs, "getservbyname failed for syslog/udp";
	return 0;
    }
d218 3
a220 11
    my $addr;
    if (defined $host) {
        $addr = inet_aton($host);
        if (!$addr) {
	    push @@$errs, "can't lookup $host";
	    return 0;
	}
    } else {
        $addr = INADDR_LOOPBACK;
    }
    $addr = sockaddr_in($syslog, $addr);
d222 11
a232 8
    if (!socket(SYSLOG, AF_INET, SOCK_DGRAM, $udp)) {
	push @@$errs, "udp socket: $!";
	return 0;
    }
    if (!connect(SYSLOG, $addr)) {
	push @@$errs, "udp connect: $!";
	return 0;
    }
d234 3
a236 7
    # We want to check that the UDP connect worked. However the only
    # way to do that is to send a message and see if an ICMP is returned
    _syslog_send_socket("");
    if (!connection_ok()) {
	push @@$errs, "udp connect: nobody listening";
	return 0;
    }
d238 1
a238 1
    $syslog_send = \&_syslog_send_socket;
d240 1
a240 2
    return 1;
}
a241 16
sub connect_stream {
    my ($errs) = @@_;
    # might want syslog_path to be variable based on syslog.h (if only
    # it were in there!)
    $syslog_path = '/dev/conslog' unless defined $syslog_path; 
    if (!-w $syslog_path) {
	push @@$errs, "stream $syslog_path is not writable";
	return 0;
    }
    if (!sysopen(SYSLOG, $syslog_path, 0400, O_WRONLY)) {
	push @@$errs, "stream can't open $syslog_path: $!";
	return 0;
    }
    $syslog_send = \&_syslog_send_stream;
    return 1;
}
d243 1
a243 2
sub connect_pipe {
    my ($errs) = @@_;
d245 1
a245 1
    $syslog_path ||= &_PATH_LOG || "/dev/log";
d247 1
a247 4
    if (not -w $syslog_path) {
        push @@$errs, "$syslog_path is not writable";
        return 0;
    }
a248 4
    if (not open(SYSLOG, ">$syslog_path")) {
        push @@$errs, "can't write to $syslog_path: $!";
        return 0;
    }
d250 1
a250 1
    $syslog_send = \&_syslog_send_pipe;
d252 4
a255 2
    return 1;
}
d257 1
a257 2
sub connect_unix {
    my ($errs) = @@_;
d259 3
a261 1
    $syslog_path ||= _PATH_LOG() if length _PATH_LOG();
d263 3
a265 4
    if (not defined $syslog_path) {
        push @@$errs, "_PATH_LOG not available in syslog.h and no user-supplied socket path";
	return 0;
    }
d267 5
a271 4
    if (not (-S $syslog_path or -c _)) {
        push @@$errs, "$syslog_path is not a socket";
	return 0;
    }
a272 9
    my $addr = sockaddr_un($syslog_path);
    if (!$addr) {
	push @@$errs, "can't locate $syslog_path";
	return 0;
    }
    if (!socket(SYSLOG, AF_UNIX, SOCK_STREAM, 0)) {
        push @@$errs, "unix stream socket: $!";
	return 0;
    }
d274 1
a274 10
    if (!connect(SYSLOG, $addr)) {
        if (!socket(SYSLOG, AF_UNIX, SOCK_DGRAM, 0)) {
	    push @@$errs, "unix dgram socket: $!";
	    return 0;
	}
        if (!connect(SYSLOG, $addr)) {
	    push @@$errs, "unix dgram connect: $!";
	    return 0;
	}
    }
d276 1
a276 1
    $syslog_send = \&_syslog_send_socket;
d278 1
a278 2
    return 1;
}
d280 1
a280 3
sub connect_native {
    my ($errs) = @@_;
    my $logopt = 0;
d282 1
a282 4
    # reconstruct the numeric equivalent of the options
    for my $opt (keys %options) {
        $logopt += xlate($opt) if $options{$opt}
    }
d284 1
a284 5
    eval { openlog_xs($ident, $logopt, xlate($facility)) };
    if ($@@) {
        push @@$errs, $@@;
        return 0;
    }
d286 1
a286 1
    $syslog_send = \&_syslog_send_native;
d288 1
a288 2
    return 1;
}
d290 1
a290 2
sub connect_eventlog {
    my ($errs) = @@_;
d292 1
a292 2
    $syslog_xobj = Sys::Syslog::Win32::_install();
    $syslog_send = \&Sys::Syslog::Win32::_syslog_send;
d294 1
a294 2
    return 1;
}
d296 1
a296 9
sub connect_console {
    my ($errs) = @@_;
    if (!-w '/dev/console') {
	push @@$errs, "console is not writable";
	return 0;
    }
    $syslog_send = \&_syslog_send_console;
    return 1;
}
d298 1
a298 11
# To test if the connection is still good, we need to check if any
# errors are present on the connection. The errors will not be raised
# by a write. Instead, sockets are made readable and the next read
# would cause the error to be returned. Unfortunately the syslog 
# 'protocol' never provides anything for us to read. But with 
# judicious use of select(), we can see if it would be readable...
sub connection_ok {
    return 1 if defined $current_proto and (
        $current_proto eq 'native' or $current_proto eq 'console'
        or $current_proto eq 'eventlog'
    );
d300 1
a300 5
    my $rin = '';
    vec($rin, fileno(SYSLOG), 1) = 1;
    my $ret = select $rin, undef, $rin, 0.25;
    return ($ret ? 0 : 1);
}
d302 1
a302 3
sub disconnect_log {
    $connected = 0;
    $syslog_send = undef;
d304 1
a304 8
    if (defined $current_proto and $current_proto eq 'native') {
        closelog_xs();
        return 1;
    }
    elsif (defined $current_proto and $current_proto eq 'eventlog') {
        $syslog_xobj->Close();
        return 1;
    }
d306 1
a306 2
    return close SYSLOG;
}
d308 1
a308 1
1;
d310 1
a310 1
__END__
d312 1
a312 1
=head1 NAME
d314 1
a314 1
Sys::Syslog - Perl interface to the UNIX syslog(3) calls
d316 1
a316 1
=head1 VERSION
d318 1
a318 1
Version 0.22
d320 1
a320 1
=head1 SYNOPSIS
d322 1
a322 3
    use Sys::Syslog;                          # all except setlogsock(), or:
    use Sys::Syslog qw(:DEFAULT setlogsock);  # default set, plus setlogsock()
    use Sys::Syslog qw(:standard :macros);    # standard functions, plus macros
d324 1
a324 4
    openlog $ident, $logopt, $facility;       # don't forget this
    syslog $priority, $format, @@args;
    $oldmask = setlogmask $mask_priority;
    closelog;
d326 1
d328 1
a328 1
=head1 DESCRIPTION
d330 1
a330 3
C<Sys::Syslog> is an interface to the UNIX C<syslog(3)> program.
Call C<syslog()> with a string priority and a list of C<printf()> args
just like C<syslog(3)>.
d332 1
a332 2
You can find a kind of FAQ in L<"THE RULES OF SYS::SYSLOG">.  Please read 
it before coding, and again before asking questions. 
d335 1
a335 3
=head1 EXPORTS

C<Sys::Syslog> exports the following C<Exporter> tags: 
d341 3
a343 1
C<:standard> exports the standard C<syslog(3)> functions: 
d345 1
a345 1
    openlog closelog setlogmask syslog
d349 1
a349 3
C<:extended> exports the Perl specific functions for C<syslog(3)>: 

    setlogsock
d353 1
a353 3
C<:macros> exports the symbols corresponding to most of your C<syslog(3)> 
macros and the C<LOG_UPTO()> and C<LOG_MASK()> functions. 
See L<"CONSTANTS"> for the supported constants and their meaning. 
d355 1
a355 1
=back
d357 1
a357 1
By default, C<Sys::Syslog> exports the symbols from the C<:standard> tag. 
d359 1
d361 1
a361 1
=head1 FUNCTIONS
d363 1
a363 1
=over 4
d365 1
a365 1
=item B<openlog($ident, $logopt, $facility)>
d367 1
a367 8
Opens the syslog.
C<$ident> is prepended to every message.  C<$logopt> contains zero or
more of the options detailed below.  C<$facility> specifies the part 
of the system to report about, for example C<LOG_USER> or C<LOG_LOCAL0>:
see L<"Facilities"> for a list of well-known facilities, and your 
C<syslog(3)> documentation for the facilities available in your system. 
Check L<"SEE ALSO"> for useful links. Facility can be given as a string 
or a numeric macro. 
d369 1
a369 1
This function will croak if it can't connect to the syslog daemon.
d371 1
a371 1
Note that C<openlog()> now takes three arguments, just like C<openlog(3)>.
a372 1
B<You should use C<openlog()> before calling C<syslog()>.>
d374 1
a374 1
B<Options>
d378 1
a378 1
=item *
d380 1
a380 2
C<cons> - This option is ignored, since the failover mechanism will drop 
down to the console automatically if all other media fail.
d382 1
a382 1
=item *
d384 1
a384 2
C<ndelay> - Open the connection immediately (normally, the connection is
opened when the first message is logged).
d386 1
a386 1
=item *
d388 2
a389 3
C<nofatal> - When set to true, C<openlog()> and C<syslog()> will only 
emit warnings instead of dying if the connection to the syslog can't 
be established. 
d391 1
a391 1
=item *
d393 2
a394 3
C<nowait> - Don't wait for child processes that may have been created 
while logging the message.  (The GNU C library does not create a child
process, so this option has no effect on Linux.)
d396 1
a396 1
=item *
d398 2
a399 2
C<perror> - Write the message to standard error output as well to the
system log.
d401 1
a401 1
=item *
d403 1
a403 3
C<pid> - Include PID with each message.

=back
d405 1
a405 1
B<Examples>
d407 2
a408 1
Open the syslog with options C<ndelay> and C<pid>, and with facility C<LOCAL0>: 
d410 1
a410 1
    openlog($name, "ndelay,pid", "local0");
d412 1
a412 1
Same thing, but this time using the macro corresponding to C<LOCAL0>: 
d414 1
a414 1
    openlog($name, "ndelay,pid", LOG_LOCAL0);
d416 1
d418 1
a418 1
=item B<syslog($priority, $message)>
d420 1
a420 5
=item B<syslog($priority, $format, @@args)>

If C<$priority> permits, logs C<$message> or C<sprintf($format, @@args)>
with the addition that C<%m> in $message or C<$format> is replaced with
C<"$!"> (the latest error message). 
d422 1
a422 5
C<$priority> can specify a level, or a level and a facility.  Levels and 
facilities can be given as strings or as macros.  When using the C<eventlog>
mechanism, priorities C<DEBUG> and C<INFO> are mapped to event type 
C<informational>, C<NOTICE> and C<WARNIN> to C<warning> and C<ERR> to 
C<EMERG> to C<error>.
d424 2
a425 3
If you didn't use C<openlog()> before using C<syslog()>, C<syslog()> will 
try to guess the C<$ident> by extracting the shortest prefix of 
C<$format> that ends in a C<":">.
d427 1
a427 1
B<Examples>
d429 2
a430 17
    syslog("info", $message);           # informational level
    syslog(LOG_INFO, $message);         # informational level

    syslog("info|local0", $message);        # information level, Local0 facility
    syslog(LOG_INFO|LOG_LOCAL0, $message);  # information level, Local0 facility

=over 4

=item B<Note>

C<Sys::Syslog> version v0.07 and older passed the C<$message> as the 
formatting string to C<sprintf()> even when no formatting arguments
were provided.  If the code calling C<syslog()> might execute with 
older versions of this module, make sure to call the function as
C<syslog($priority, "%s", $message)> instead of C<syslog($priority,
$message)>.  This protects against hostile formatting sequences that
might show up if $message contains tainted data.
d435 1
a435 1
=item B<setlogmask($mask_priority)>
d437 1
a437 5
Sets the log mask for the current process to C<$mask_priority> and 
returns the old mask.  If the mask argument is 0, the current log mask 
is not modified.  See L<"Levels"> for the list of available levels. 
You can use the C<LOG_UPTO()> function to allow all levels up to a 
given priority (but it only accept the numeric macros as arguments).
d439 1
a439 1
B<Examples>
a440 1
Only log errors: 
d442 1
a442 1
    setlogmask( LOG_MASK(LOG_ERR) );
d444 2
a445 1
Log everything except informational messages: 
d447 3
a449 1
    setlogmask( ~(LOG_MASK(LOG_INFO)) );
d451 2
a452 1
Log critical messages, errors and warnings: 
d454 1
a454 1
    setlogmask( LOG_MASK(LOG_CRIT) | LOG_MASK(LOG_ERR) | LOG_MASK(LOG_WARNING) );
d456 2
a457 1
Log all messages up to debug: 
d459 2
a460 1
    setlogmask( LOG_UPTO(LOG_DEBUG) );
d463 1
a463 1
=item B<setlogsock($sock_type)>
d465 5
a469 1
=item B<setlogsock($sock_type, $stream_location)> (added in Perl 5.004_02)
a470 3
Sets the socket type to be used for the next call to
C<openlog()> or C<syslog()> and returns true on success,
C<undef> on failure. The available mechanisms are: 
d472 1
a472 1
=over
d474 1
a474 1
=item *
d476 1
a476 2
C<"native"> - use the native C functions from your C<syslog(3)> library
(added in C<Sys::Syslog> 0.15).
d478 1
a478 1
=item *
d480 1
a480 2
C<"eventlog"> - send messages to the Win32 events logger (Win32 only; 
added in C<Sys::Syslog> 0.19).
d482 1
a482 1
=item *
d484 1
a484 2
C<"tcp"> - connect to a TCP socket, on the C<syslog/tcp> or C<syslogng/tcp> 
service. 
d486 1
a486 1
=item *
d488 1
a488 1
C<"udp"> - connect to a UDP socket, on the C<syslog/udp> service.
d490 1
a490 1
=item *
d492 1
a492 1
C<"inet"> - connect to an INET socket, either TCP or UDP, tried in that order. 
d494 1
a494 15
=item *

C<"unix"> - connect to a UNIX domain socket (in some systems a character 
special device).  The name of that socket is the second parameter or, if 
you omit the second parameter, the value returned by the C<_PATH_LOG> macro 
(if your system defines it), or F</dev/log> or F</dev/conslog>, whatever is 
writable.  

=item *

C<"stream"> - connect to the stream indicated by the pathname provided as 
the optional second parameter, or, if omitted, to F</dev/conslog>. 
For example Solaris and IRIX system may prefer C<"stream"> instead of C<"unix">. 

=item *
d496 1
a496 9
C<"pipe"> - connect to the named pipe indicated by the pathname provided as 
the optional second parameter, or, if omitted, to the value returned by 
the C<_PATH_LOG> macro (if your system defines it), or F</dev/log>
(added in C<Sys::Syslog> 0.21).

=item *

C<"console"> - send messages directly to the console, as for the C<"cons"> 
option of C<openlog()>.
a499 3
A reference to an array can also be passed as the first parameter.
When this calling method is used, the array should contain a list of
mechanisms which are attempted in order.
d501 1
a501 3
The default is to try C<native>, C<tcp>, C<udp>, C<unix>, C<stream>, C<console>.
Under systems with the Win32 API, C<eventlog> will be added as the first 
mechanism to try if C<Win32::EventLog> is available.
d503 2
a504 1
Giving an invalid value for C<$sock_type> will C<croak>.
d506 1
a506 1
B<Examples>
d508 13
a520 1
Select the UDP socket mechanism: 
d522 9
a530 1
    setlogsock("udp");
d532 1
a532 1
Select the native, UDP socket then UNIX domain socket mechanisms: 
d534 8
a541 1
    setlogsock(["native", "udp", "unix"]);
d543 4
a546 1
=over
d548 67
a614 1
=item B<Note>
d616 7
a622 7
Now that the "native" mechanism is supported by C<Sys::Syslog> and selected 
by default, the use of the C<setlogsock()> function is discouraged because 
other mechanisms are less portable across operating systems.  Authors of 
modules and programs that use this function, especially its cargo-cult form 
C<setlogsock("unix")>, are advised to remove any occurence of it unless they 
specifically want to use a given mechanism (like TCP or UDP to connect to 
a remote host).
d624 2
a625 1
=back
d627 19
a645 1
=item B<closelog()>
d647 1
a647 1
Closes the log file and returns true on success.
d649 4
a652 1
=back
d654 1
d656 1
a656 1
=head1 THE RULES OF SYS::SYSLOG
d658 4
a661 2
I<The First Rule of Sys::Syslog is:>
You do not call C<setlogsock>.
d663 5
a667 2
I<The Second Rule of Sys::Syslog is:>
You B<do not> call C<setlogsock>.
d669 1
a669 2
I<The Third Rule of Sys::Syslog is:>
The program crashes, C<die>s, calls C<closelog>, the log is over.
d671 7
a677 2
I<The Fourth Rule of Sys::Syslog is:>
One facility, one priority.
d679 2
a680 2
I<The Fifth Rule of Sys::Syslog is:>
One log at a time.
d682 6
a687 2
I<The Sixth Rule of Sys::Syslog is:>
No C<syslog> before C<openlog>.
d689 35
a723 2
I<The Seventh Rule of Sys::Syslog is:>
Logs will go on as long as they have to. 
d725 28
a752 2
I<The Eighth, and Final Rule of Sys::Syslog is:>
If this is your first use of Sys::Syslog, you must read the doc.
d754 8
d763 5
a767 1
=head1 EXAMPLES
d769 10
a778 1
An example:
d780 15
a794 4
    openlog($program, 'cons,pid', 'user');
    syslog('info', '%s', 'this is another test');
    syslog('mail|warning', 'this is a better test: %d', time);
    closelog();
d796 9
a804 1
    syslog('debug', 'this is the last test');
d806 13
a818 1
Another example:
d820 12
a831 2
    openlog("$program $$", 'ndelay', 'user');
    syslog('notice', 'fooprogram: this is really done');
d833 13
a845 1
Example of use of C<%m>:
d847 24
a870 2
    $! = 55;
    syslog('info', 'problem was %m');   # %m == $! in syslog(3)
d872 18
a889 1
Log to UDP port on C<$remotehost> instead of logging locally:
d891 16
a906 4
    setlogsock('udp');
    $Sys::Syslog::host = $remotehost;
    openlog($program, 'ndelay', 'user');
    syslog('info', 'something happened over here');
d908 34
d943 5
a947 389
=head1 CONSTANTS

=head2 Facilities

=over 4

=item *

C<LOG_AUDIT> - audit daemon (IRIX); falls back to C<LOG_AUTH>

=item *

C<LOG_AUTH> - security/authorization messages

=item *

C<LOG_AUTHPRIV> - security/authorization messages (private)

=item *

C<LOG_CONSOLE> - C</dev/console> output (FreeBSD); falls back to C<LOG_USER>

=item *

C<LOG_CRON> - clock daemons (B<cron> and B<at>)

=item *

C<LOG_DAEMON> - system daemons without separate facility value

=item *

C<LOG_FTP> - FTP daemon

=item *

C<LOG_KERN> - kernel messages

=item *

C<LOG_INSTALL> - installer subsystem (Mac OS X); falls back to C<LOG_USER>

=item *

C<LOG_LAUNCHD> - launchd - general bootstrap daemon (Mac OS X);
falls back to C<LOG_DAEMON>

=item *

C<LOG_LFMT> - logalert facility; falls back to C<LOG_USER>

=item *

C<LOG_LOCAL0> through C<LOG_LOCAL7> - reserved for local use

=item *

C<LOG_LPR> - line printer subsystem

=item *

C<LOG_MAIL> - mail subsystem

=item *

C<LOG_NETINFO> - NetInfo subsystem (Mac OS X); falls back to C<LOG_DAEMON>

=item *

C<LOG_NEWS> - USENET news subsystem

=item *

C<LOG_NTP> - NTP subsystem (FreeBSD, NetBSD); falls back to C<LOG_DAEMON>

=item *

C<LOG_RAS> - Remote Access Service (VPN / PPP) (Mac OS X);
falls back to C<LOG_AUTH>

=item *

C<LOG_REMOTEAUTH> - remote authentication/authorization (Mac OS X);
falls back to C<LOG_AUTH>

=item *

C<LOG_SECURITY> - security subsystems (firewalling, etc.) (FreeBSD);
falls back to C<LOG_AUTH>

=item *

C<LOG_SYSLOG> - messages generated internally by B<syslogd>

=item *

C<LOG_USER> (default) - generic user-level messages

=item *

C<LOG_UUCP> - UUCP subsystem

=back


=head2 Levels

=over 4

=item *

C<LOG_EMERG> - system is unusable

=item *

C<LOG_ALERT> - action must be taken immediately

=item *

C<LOG_CRIT> - critical conditions

=item *

C<LOG_ERR> - error conditions

=item *

C<LOG_WARNING> - warning conditions

=item *

C<LOG_NOTICE> - normal, but significant, condition

=item *

C<LOG_INFO> - informational message

=item *

C<LOG_DEBUG> - debug-level message

=back


=head1 DIAGNOSTICS

=over

=item C<Invalid argument passed to setlogsock>

B<(F)> You gave C<setlogsock()> an invalid value for C<$sock_type>. 

=item C<eventlog passed to setlogsock, but no Win32 API available>

B<(W)> You asked C<setlogsock()> to use the Win32 event logger but the 
operating system running the program isn't Win32 or does not provides Win32
compatible facilities.

=item C<no connection to syslog available>

B<(F)> C<syslog()> failed to connect to the specified socket.

=item C<stream passed to setlogsock, but %s is not writable>

B<(W)> You asked C<setlogsock()> to use a stream socket, but the given 
path is not writable. 

=item C<stream passed to setlogsock, but could not find any device>

B<(W)> You asked C<setlogsock()> to use a stream socket, but didn't 
provide a path, and C<Sys::Syslog> was unable to find an appropriate one.

=item C<tcp passed to setlogsock, but tcp service unavailable>

B<(W)> You asked C<setlogsock()> to use a TCP socket, but the service 
is not available on the system. 

=item C<syslog: expecting argument %s>

B<(F)> You forgot to give C<syslog()> the indicated argument.

=item C<syslog: invalid level/facility: %s>

B<(F)> You specified an invalid level or facility.

=item C<syslog: too many levels given: %s>

B<(F)> You specified too many levels. 

=item C<syslog: too many facilities given: %s>

B<(F)> You specified too many facilities. 

=item C<syslog: level must be given>

B<(F)> You forgot to specify a level.

=item C<udp passed to setlogsock, but udp service unavailable>

B<(W)> You asked C<setlogsock()> to use a UDP socket, but the service 
is not available on the system. 

=item C<unix passed to setlogsock, but path not available>

B<(W)> You asked C<setlogsock()> to use a UNIX socket, but C<Sys::Syslog> 
was unable to find an appropriate an appropriate device.

=back


=head1 SEE ALSO

=head2 Manual Pages

L<syslog(3)>

SUSv3 issue 6, IEEE Std 1003.1, 2004 edition, 
L<http://www.opengroup.org/onlinepubs/000095399/basedefs/syslog.h.html>

GNU C Library documentation on syslog, 
L<http://www.gnu.org/software/libc/manual/html_node/Syslog.html>

Solaris 10 documentation on syslog, 
L<http://docs.sun.com/app/docs/doc/816-5168/6mbb3hruo?a=view>

IRIX 6.4 documentation on syslog,
L<http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0640&db=man&fname=3c+syslog>

AIX 5L 5.3 documentation on syslog, 
L<http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm>

HP-UX 11i documentation on syslog, 
L<http://docs.hp.com/en/B9106-90010/syslog.3C.html>

Tru64 5.1 documentation on syslog, 
L<http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM>

Stratus VOS 15.1, 
L<http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&file=ch5r502-01bi.html>

=head2 RFCs

I<RFC 3164 - The BSD syslog Protocol>, L<http://www.faqs.org/rfcs/rfc3164.html>
-- Please note that this is an informational RFC, and therefore does not 
specify a standard of any kind.

I<RFC 3195 - Reliable Delivery for syslog>, L<http://www.faqs.org/rfcs/rfc3195.html>

=head2 Articles

I<Syslogging with Perl>, L<http://lexington.pm.org/meetings/022001.html>

=head2 Event Log

Windows Event Log,
L<http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp>


=head1 AUTHORS & ACKNOWLEDGEMENTS

Tom Christiansen E<lt>F<tchrist (at) perl.com>E<gt> and Larry Wall
E<lt>F<larry (at) wall.org>E<gt>.

UNIX domain sockets added by Sean Robinson
E<lt>F<robinson_s (at) sc.maricopa.edu>E<gt> with support from Tim Bunce 
E<lt>F<Tim.Bunce (at) ig.co.uk>E<gt> and the C<perl5-porters> mailing list.

Dependency on F<syslog.ph> replaced with XS code by Tom Hughes
E<lt>F<tom (at) compton.nu>E<gt>.

Code for C<constant()>s regenerated by Nicholas Clark E<lt>F<nick (at) ccl4.org>E<gt>.

Failover to different communication modes by Nick Williams
E<lt>F<Nick.Williams (at) morganstanley.com>E<gt>.

Extracted from core distribution for publishing on the CPAN by 
SE<eacute>bastien Aperghis-Tramoni E<lt>sebastien (at) aperghis.netE<gt>.

XS code for using native C functions borrowed from C<L<Unix::Syslog>>, 
written by Marcus Harnisch E<lt>F<marcus.harnisch (at) gmx.net>E<gt>.

Yves Orton suggested and helped for making C<Sys::Syslog> use the native 
event logger under Win32 systems.

Jerry D. Hedden and Reini Urban provided greatly appreciated help to 
debug and polish C<Sys::Syslog> under Cygwin.


=head1 BUGS

Please report any bugs or feature requests to
C<bug-sys-syslog (at) rt.cpan.org>, or through the web interface at
L<http://rt.cpan.org/Public/Dist/Display.html?Name=Sys-Syslog>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.


=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Sys::Syslog

You can also look for information at:

=over 4

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Sys-Syslog>

=item * CPAN Ratings

L<http://cpanratings.perl.org/d/Sys-Syslog>

=item * RT: CPAN's request tracker

L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Sys-Syslog>

=item * Search CPAN

L<http://search.cpan.org/dist/Sys-Syslog/>

=item * Kobes' CPAN Search

L<http://cpan.uwinnipeg.ca/dist/Sys-Syslog>

=item * Perl Documentation

L<http://perldoc.perl.org/Sys/Syslog.html>

=back


=head1 COPYRIGHT

Copyright (C) 1990-2007 by Larry Wall and others.


=head1 LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

=begin comment

Notes for the future maintainer (even if it's still me..)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Using Google Code Search, I search who on Earth was relying on $host being 
public. It found 5 hits: 

* First was inside Indigo Star Perl2exe documentation. Just an old version 
of Sys::Syslog. 


* One real hit was inside DalWeathDB, a weather related program. It simply 
does a 

    $Sys::Syslog::host = '127.0.0.1';

- L<http://www.gallistel.net/nparker/weather/code/>


* Two hits were in TPC, a fax server thingy. It does a 

    $Sys::Syslog::host = $TPC::LOGHOST;

but also has this strange piece of code:

    # work around perl5.003 bug
    sub Sys::Syslog::hostname {}

I don't know what bug the author referred to.

- L<http://www.tpc.int/>
- L<ftp://ftp.tpc.int/tpc/server/UNIX/>
- L<ftp://ftp-usa.tpc.int/pub/tpc/server/UNIX/>


* Last hit was in Filefix, which seems to be a FIDOnet mail program (!).
This one does not use $host, but has the following piece of code:

    sub Sys::Syslog::hostname
    {
        use Sys::Hostname;
        return hostname;
d949 3
d953 13
a965 2
I guess this was a more elaborate form of the previous bit, maybe because 
of a bug in Sys::Syslog back then?
d967 5
a971 15
- L<ftp://ftp.kiae.su/pub/unix/fido/>


Links
-----
II12021: SYSLOGD HOWTO TCPIPINFO (z/OS, OS/390, MVS)
- L<http://www-1.ibm.com/support/docview.wss?uid=isg1II12021>

Getting the most out of the Event Viewer
- L<http://www.codeproject.com/dotnet/evtvwr.asp?print=true>

Log events to the Windows NT Event Log with JNI
- L<http://www.javaworld.com/javaworld/jw-09-2001/jw-0928-ntmessages.html>

=end comment
d973 1
@


