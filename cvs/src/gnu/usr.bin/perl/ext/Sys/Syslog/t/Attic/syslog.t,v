head	1.3;
access;
symbols
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.10
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.8
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.6
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.4
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.2
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2009.10.12.18.24.35;	author millert;	state dead;
branches;
next	1.2;

1.2
date	2009.05.13.15.19.59;	author simon;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.03.02.43.53;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.03.02.43.53;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.03.28.18.48.22;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.24;	author millert;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Merge in perl 5.10.1
@
text
@#!perl -T

BEGIN {
    if ($ENV{PERL_CORE}) {
        chdir 't';
        @@INC = '../lib';
    }
}

use strict;
use Config;
use File::Spec;
use Test::More;

# we enable all Perl warnings, but we don't "use warnings 'all'" because 
# we want to disable the warnings generated by Sys::Syslog
no warnings;
use warnings qw(closure deprecated exiting glob io misc numeric once overflow
                pack portable recursion redefine regexp severe signal substr
                syntax taint uninitialized unpack untie utf8 void);

# if someone is using warnings::compat, the previous trick won't work, so we
# must manually disable warnings
$^W = 0 if $] < 5.006;

my $is_Win32  = $^O =~ /win32/i;
my $is_Cygwin = $^O =~ /cygwin/i;

# if testing in core, check that the module is at least available
if ($ENV{PERL_CORE}) {
    plan skip_all => "Sys::Syslog was not build" 
        unless $Config{'extensions'} =~ /\bSyslog\b/;
}

# we also need Socket
plan skip_all => "Socket was not build" 
    unless $Config{'extensions'} =~ /\bSocket\b/;

my $tests;
plan tests => $tests;

# any remaining warning should be severly punished
BEGIN { eval "use Test::NoWarnings"; $tests = $@@ ? 0 : 1; }

BEGIN { $tests += 1 }
# ok, now loads them
eval 'use Socket';
use_ok('Sys::Syslog', ':standard', ':extended', ':macros');

BEGIN { $tests += 1 }
# check that the documented functions are correctly provided
can_ok( 'Sys::Syslog' => qw(openlog syslog syslog setlogmask setlogsock closelog) );


BEGIN { $tests += 1 }
# check the diagnostics
# setlogsock()
eval { setlogsock() };
like( $@@, qr/^Invalid argument passed to setlogsock/, 
    "calling setlogsock() with no argument" );

BEGIN { $tests += 3 }
# syslog()
eval { syslog() };
like( $@@, qr/^syslog: expecting argument \$priority/, 
    "calling syslog() with no argument" );

eval { syslog(undef) };
like( $@@, qr/^syslog: expecting argument \$priority/, 
    "calling syslog() with one undef argument" );

eval { syslog('') };
like( $@@, qr/^syslog: expecting argument \$format/, 
    "calling syslog() with one empty argument" );


my $test_string = "uid $< is testing Perl $] syslog(3) capabilities";
my $r = 0;

BEGIN { $tests += 8 }
# try to open a syslog using a Unix or stream socket
SKIP: {
    skip "can't connect to Unix socket: _PATH_LOG unavailable", 8
      unless -e Sys::Syslog::_PATH_LOG();

    # The only known $^O eq 'svr4' that needs this is NCR MP-RAS,
    # but assuming 'stream' in SVR4 is probably not that bad.
    my $sock_type = $^O =~ /^(solaris|irix|svr4|powerux)$/ ? 'stream' : 'unix';

    eval { setlogsock($sock_type) };
    is( $@@, '', "setlogsock() called with '$sock_type'" );
    TODO: {
        local $TODO = "minor bug";
        ok( $r, "setlogsock() should return true: '$r'" );
    }

    # open syslog with a "local0" facility
    SKIP: {
        # openlog()
        $r = eval { openlog('perl', 'ndelay', 'local0') } || 0;
        skip "can't connect to syslog", 6 if $@@ =~ /^no connection to syslog available/;
        is( $@@, '', "openlog() called with facility 'local0'" );
        ok( $r, "openlog() should return true: '$r'" );

        # syslog()
        $r = eval { syslog('info', "$test_string by connecting to a $sock_type socket") } || 0;
        is( $@@, '', "syslog() called with level 'info'" );
        ok( $r, "syslog() should return true: '$r'" );

        # closelog()
        $r = eval { closelog() } || 0;
        is( $@@, '', "closelog()" );
        ok( $r, "closelog() should return true: '$r'" );
    }
}


BEGIN { $tests += 22 * 8 }
# try to open a syslog using all the available connection methods
my @@passed = ();
for my $sock_type (qw(native eventlog unix pipe stream inet tcp udp)) {
    SKIP: {
        skip "the 'stream' mechanism because a previous mechanism with similar interface succeeded", 22 
            if $sock_type eq 'stream' and grep {/pipe|unix/} @@passed;

        # setlogsock() called with an arrayref
        $r = eval { setlogsock([$sock_type]) } || 0;
        skip "can't use '$sock_type' socket", 22 unless $r;
        is( $@@, '', "[$sock_type] setlogsock() called with ['$sock_type']" );
        ok( $r, "[$sock_type] setlogsock() should return true: '$r'" );

        # setlogsock() called with a single argument
        $r = eval { setlogsock($sock_type) } || 0;
        skip "can't use '$sock_type' socket", 20 unless $r;
        is( $@@, '', "[$sock_type] setlogsock() called with '$sock_type'" );
        ok( $r, "[$sock_type] setlogsock() should return true: '$r'" );

        # openlog() without option NDELAY
        $r = eval { openlog('perl', '', 'local0') } || 0;
        skip "can't connect to syslog", 18 if $@@ =~ /^no connection to syslog available/;
        is( $@@, '', "[$sock_type] openlog() called with facility 'local0' and without option 'ndelay'" );
        ok( $r, "[$sock_type] openlog() should return true: '$r'" );

        # openlog() with the option NDELAY
        $r = eval { openlog('perl', 'ndelay', 'local0') } || 0;
        skip "can't connect to syslog", 16 if $@@ =~ /^no connection to syslog available/;
        is( $@@, '', "[$sock_type] openlog() called with facility 'local0' with option 'ndelay'" );
        ok( $r, "[$sock_type] openlog() should return true: '$r'" );

        # syslog() with negative level, should fail
        $r = eval { syslog(-1, "$test_string by connecting to a $sock_type socket") } || 0;
        like( $@@, '/^syslog: invalid level\/facility: /', "[$sock_type] syslog() called with level -1" );
        ok( !$r, "[$sock_type] syslog() should return false: '$r'" );

        # syslog() with invalid level, should fail
        $r = eval { syslog("plonk", "$test_string by connecting to a $sock_type socket") } || 0;
        like( $@@, '/^syslog: invalid level\/facility: /', "[$sock_type] syslog() called with level plonk" );
        ok( !$r, "[$sock_type] syslog() should return false: '$r'" );

        # syslog() with levels "info" and "notice" (as a strings), should fail
        $r = eval { syslog('info,notice', "$test_string by connecting to a $sock_type socket") } || 0;
        like( $@@, '/^syslog: too many levels given: notice/', "[$sock_type] syslog() called with level 'info,notice'" );
        ok( !$r, "[$sock_type] syslog() should return false: '$r'" );

        # syslog() with facilities "local0" and "local1" (as a strings), should fail
        $r = eval { syslog('local0,local1', "$test_string by connecting to a $sock_type socket") } || 0;
        like( $@@, '/^syslog: too many facilities given: local1/', "[$sock_type] syslog() called with level 'local0,local1'" );
        ok( !$r, "[$sock_type] syslog() should return false: '$r'" );

        # syslog() with level "info" (as a string), should pass
        $r = eval { syslog('info', "$test_string by connecting to a $sock_type socket") } || 0;
        is( $@@, '', "[$sock_type] syslog() called with level 'info' (string)" );
        ok( $r, "[$sock_type] syslog() should return true: '$r'" );

        # syslog() with level "info" (as a macro), should pass
        { local $! = 1;
          $r = eval { syslog(LOG_INFO(), "$test_string by connecting to a $sock_type socket, setting a fake errno: %m") } || 0;
        }
        is( $@@, '', "[$sock_type] syslog() called with level 'info' (macro)" );
        ok( $r, "[$sock_type] syslog() should return true: '$r'" );

        push @@passed, $sock_type;

        SKIP: {
            skip "skipping closelog() tests for 'console'", 2 if $sock_type eq 'console';
            # closelog()
            $r = eval { closelog() } || 0;
            is( $@@, '', "[$sock_type] closelog()" );
            ok( $r, "[$sock_type] closelog() should return true: '$r'" );
        }
    }
}


BEGIN { $tests += 10 }
SKIP: {
    skip "not testing setlogsock('stream') on Win32", 10 if $is_Win32;
    skip "the 'unix' mechanism works, so the tests will likely fail with the 'stream' mechanism", 10 
        if grep {/unix/} @@passed;

    skip "not testing setlogsock('stream'): _PATH_LOG unavailable", 10
        unless -e Sys::Syslog::_PATH_LOG();

    # setlogsock() with "stream" and an undef path
    $r = eval { setlogsock("stream", undef ) } || '';
    is( $@@, '', "setlogsock() called, with 'stream' and an undef path" );
    if ($is_Cygwin) {
        if (-x "/usr/sbin/syslog-ng") {
            ok( $r, "setlogsock() on Cygwin with syslog-ng should return true: '$r'" );
        }
        else {
            ok( !$r, "setlogsock() on Cygwin without syslog-ng should return false: '$r'" );
        }
    }
    else  {
        ok( $r, "setlogsock() should return true: '$r'" );
    }

    # setlogsock() with "stream" and an empty path
    $r = eval { setlogsock("stream", '' ) } || '';
    is( $@@, '', "setlogsock() called, with 'stream' and an empty path" );
    ok( !$r, "setlogsock() should return false: '$r'" );

    # setlogsock() with "stream" and /dev/null
    $r = eval { setlogsock("stream", '/dev/null' ) } || '';
    is( $@@, '', "setlogsock() called, with 'stream' and '/dev/null'" );
    ok( $r, "setlogsock() should return true: '$r'" );

    # setlogsock() with "stream" and a non-existing file
    $r = eval { setlogsock("stream", 'test.log' ) } || '';
    is( $@@, '', "setlogsock() called, with 'stream' and 'test.log' (file does not exist)" );
    ok( !$r, "setlogsock() should return false: '$r'" );

    # setlogsock() with "stream" and a local file
    SKIP: {
        my $logfile = "test.log";
        open(LOG, ">$logfile") or skip "can't create file '$logfile': $!", 2;
        close(LOG);
        $r = eval { setlogsock("stream", $logfile ) } || '';
        is( $@@, '', "setlogsock() called, with 'stream' and '$logfile' (file exists)" );
        ok( $r, "setlogsock() should return true: '$r'" );
        unlink($logfile);
    }
}


BEGIN { $tests += 3 + 4 * 3 }
# setlogmask()
{
    my $oldmask = 0;

    $oldmask = eval { setlogmask(0) } || 0;
    is( $@@, '', "setlogmask() called with a null mask" );
    $r = eval { setlogmask(0) } || 0;
    is( $@@, '', "setlogmask() called with a null mask (second time)" );
    is( $r, $oldmask, "setlogmask() must return the same mask as previous call");

    my @@masks = (
        LOG_MASK(LOG_ERR()), 
        ~LOG_MASK(LOG_INFO()), 
        LOG_MASK(LOG_CRIT()) | LOG_MASK(LOG_ERR()) | LOG_MASK(LOG_WARNING()), 
    );

    for my $newmask (@@masks) {
        $r = eval { setlogmask($newmask) } || 0;
        is( $@@, '', "setlogmask() called with a new mask" );
        is( $r, $oldmask, "setlogmask() must return the same mask as previous call");
        $r = eval { setlogmask(0) } || 0;
        is( $@@, '', "setlogmask() called with a null mask" );
        is( $r, $newmask, "setlogmask() must return the new mask");
        setlogmask($oldmask);
    }
}
@


1.2
log
@update Sys::Syslog to CPAN version 0.27

testing by sthen@@ and jasper@@, thanks!
ok millert@@, jasper@@
@
text
@@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#!./perl
d4 3
a6 22
    chdir 't' if -d 't';
    @@INC = '../lib';
    require Config; import Config;
    if ($Config{'extensions'} !~ /\bSyslog\b/) {
	print "1..0 # Skip: Sys::Syslog was not built\n";
	exit 0;
    }
    if ($Config{'extensions'} !~ /\bSocket\b/) {
	print "1..0 # Skip: Socket was not built\n";
	exit 0;
    }

    require Socket;

    # This code inspired by Sys::Syslog::connect():
    require Sys::Hostname;
    my ($host_uniq) = Sys::Hostname::hostname();
    my ($host)      = $host_uniq =~ /([A-Za-z0-9_.-]+)/;

    if (! defined Socket::inet_aton($host)) {
        print "1..0 # Skip: Can't lookup $host\n";
        exit 0;
d10 104
a113 5
BEGIN {
  eval {require Sys::Syslog} or do {
    if ($@@ =~ /Your vendor has not/) {
      print "1..0 # Skip: missing macros\n";
      exit 0;
a114 1
  }
a116 1
use Sys::Syslog qw(:DEFAULT setlogsock);
d118 60
a177 17
# Test this to 1 if your syslog accepts udp connections.
# Most don't (or at least shouldn't)
my $Test_Syslog_INET = 0;

my $test_string = "uid $< is testing perl $] syslog capabilities";

print "1..6\n";

if (Sys::Syslog::_PATH_LOG()) {
    if (-e Sys::Syslog::_PATH_LOG()) {
	# The only known $^O eq 'svr4' that needs this is NCR MP-RAS,
	# but assuming 'stream' in SVR4 is probably not that bad.
        if ($^O =~ /^(solaris|irix|svr4|powerux)$/) {
            # we should check for stream support here, not for solaris/irix
            print defined(eval { setlogsock('stream') }) ? "ok 1\n" : "not ok 1 # $!\n";
        } else { 
            print defined(eval { setlogsock('unix') }) ? "ok 1\n" : "not ok 1 # $!\n";
d179 11
a189 18
        if (defined(eval { openlog('perl', 'ndelay', 'local0') })) {
	    print "ok 2\n";
	    print defined(eval { syslog('info', $test_string ) })
		    ? "ok 3\n" : "not ok 3 # $!\n";
	} else {
	    if ($@@ =~ /no connection to syslog available/) {
		print "ok 2 # Skip: syslogd not running\n";
	    } else {
		print "not ok 2 # $@@\n";
	    }
	    print "ok 3 # Skip: openlog failed\n";
	}
    } else {
        for (1..3) {
            print
                "ok $_ # Skip: file ",
                Sys::Syslog::_PATH_LOG(),
                " does not exist\n";
d193 51
a243 2
else {
    for (1..3) { print "ok $_ # Skip: _PATH_LOG unavailable\n" }
d246 27
a272 11
if( $Test_Syslog_INET ) {
    print defined(eval { setlogsock('inet') }) ? "ok 4\n" 
                                               : "not ok 4\n";
    print defined(eval { openlog('perl', 'ndelay', 'local0') }) ? "ok 5\n" 
                                                                : "not ok 5 # $!\n";
    print defined(eval { syslog('info', $test_string ) }) ? "ok 6\n" 
                                                   : "not ok 6 # $!\n";
}
else {
    print "ok $_ # Skip: assuming syslog doesn't accept inet connections\n" 
      foreach (4..6);
@


1.1.1.1
log
@perl 5.8.2 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.8 import
@
text
@d1 1
a1 1
#!/usr/bin/perl -T
d4 10
a13 3
    if( $ENV{PERL_CORE} ) {
        chdir 't';
        @@INC = '../lib';
a14 1
}
d16 1
a16 12
use strict;
use Config;
use File::Spec;
use Test::More;

# check that the module is at least available
plan skip_all => "Sys::Syslog was not build" 
  unless $Config{'extensions'} =~ /\bSyslog\b/;

# we also need Socket
plan skip_all => "Socket was not build" 
  unless $Config{'extensions'} =~ /\bSocket\b/;
d18 9
a26 6
BEGIN {
    plan tests => 119;

    # ok, now loads them
    eval 'use Socket';
    use_ok('Sys::Syslog', ':standard', ':extended', ':macros');
d29 5
a33 32
# check that the documented functions are correctly provided
can_ok( 'Sys::Syslog' => qw(openlog syslog syslog setlogmask setlogsock closelog) );


# check the diagnostics
# setlogsock()
eval { setlogsock() };
like( $@@, qr/^Invalid argument passed to setlogsock; must be 'stream', 'unix', 'tcp', 'udp' or 'inet'/, 
    "calling setlogsock() with no argument" );

# syslog()
eval { syslog() };
like( $@@, qr/^syslog: expecting argument \$priority/, 
    "calling syslog() with no argument" );

my $test_string = "uid $< is testing Perl $] syslog(3) capabilities";
my $r = 0;

# try to open a syslog using a Unix or stream socket
SKIP: {
    skip "can't connect to Unix socket: _PATH_LOG unavailable", 8
      unless -e Sys::Syslog::_PATH_LOG();

    # The only known $^O eq 'svr4' that needs this is NCR MP-RAS,
    # but assuming 'stream' in SVR4 is probably not that bad.
    my $sock_type = $^O =~ /^(solaris|irix|svr4|powerux)$/ ? 'stream' : 'unix';

    eval { setlogsock($sock_type) };
    is( $@@, '', "setlogsock() called with '$sock_type'" );
    TODO: {
        local $TODO = "minor bug";
        ok( $r, "setlogsock() should return true: '$r'" );
d35 2
d38 1
a38 19
    # open syslog with a "local0" facility
    SKIP: {
        # openlog()
        $r = eval { openlog('perl', 'ndelay', 'local0') } || 0;
        skip "can't connect to syslog", 6 if $@@ =~ /^no connection to syslog available/;
        is( $@@, '', "openlog() called with facility 'local0'" );
        ok( $r, "openlog() should return true: '$r'" );

        # syslog()
        $r = eval { syslog('info', "$test_string by connecting to a $sock_type socket") } || 0;
        is( $@@, '', "syslog() called with level 'info'" );
        ok( $r, "syslog() should return true: '$r'" );

        # closelog()
        $r = eval { closelog() } || 0;
        is( $@@, '', "closelog()" );
        ok( $r, "closelog() should return true: '$r'" );
    }
}
d40 36
a75 47
# try to open a syslog using all the available connection methods
for my $sock_type (qw(stream unix inet tcp udp console)) {
    SKIP: {
        # setlogsock()
        $r = eval { setlogsock([$sock_type]) } || 0;
        skip "can't use '$sock_type' socket", 16 unless $r;
        is( $@@, '', "setlogsock() called with '$sock_type'" );
        ok( $r, "setlogsock() should return true: '$r'" );

        # openlog() without option NDELAY
        $r = eval { openlog('perl', '', 'local0') } || 0;
        skip "can't connect to syslog", 14 if $@@ =~ /^no connection to syslog available/;
        is( $@@, '', "openlog() called with facility 'local0' and without option 'ndelay'" );
        ok( $r, "openlog() should return true: '$r'" );

        # openlog() with the option NDELAY
        $r = eval { openlog('perl', 'ndelay', 'local0') } || 0;
        skip "can't connect to syslog", 12 if $@@ =~ /^no connection to syslog available/;
        is( $@@, '', "openlog() called with facility 'local0' with option 'ndelay'" );
        ok( $r, "openlog() should return true: '$r'" );

        # syslog() with level "info" (as a string), should pass
        $r = eval { syslog('info', "$test_string by connecting to a $sock_type socket") } || 0;
        is( $@@, '', "syslog() called with level 'info'" );
        ok( $r, "syslog() should return true: '$r'" );

        # syslog() with level "info" (as a macro), should pass
        $r = eval { syslog(LOG_INFO, "$test_string by connecting to a $sock_type socket") } || 0;
        is( $@@, '', "syslog() called with level 'info'" );
        ok( $r, "syslog() should return true: '$r'" );

        # syslog() with facility "kern" (as a string), should fail
        $r = eval { syslog('kern', "$test_string by connecting to a $sock_type socket") } || 0;
        like( $@@, '/^syslog: invalid level/facility: kern/', "syslog() called with facility 'kern'" );
        ok( !$r, "syslog() should return false: '$r'" );

        # syslog() with facility "kern" (as a macro), should fail
        $r = eval { syslog(LOG_KERN, "$test_string by connecting to a $sock_type socket") } || 0;
        like( $@@, '/^syslog: invalid level/facility: 0/', "syslog() called with facility 'kern'" );
        ok( !$r, "syslog() should return false: '$r'" );

        SKIP: {
            skip "skipping closelog() tests for 'console'", 2 if $sock_type eq 'console';
            # closelog()
            $r = eval { closelog() } || 0;
            is( $@@, '', "closelog()" );
            ok( $r, "closelog() should return true: '$r'" );
d79 3
d83 11
a93 19
# setlogmask()
{
    my $oldmask = 0;

    $oldmask = eval { setlogmask(0) } || 0;
    is( $@@, '', "setlogmask() called with a null mask" );
    $r = eval { setlogmask(0) } || 0;
    is( $@@, '', "setlogmask() called with a null mask (second time)" );
    is( $r, $oldmask, "setlogmask() must return the same mask as previous call");

    for my $newmask ( LOG_ERR , LOG_CRIT|LOG_ERR|LOG_WARNING ) {
        $r = eval { setlogmask($newmask) } || 0;
        is( $@@, '', "setlogmask() called with a new mask" );
        is( $r, $oldmask, "setlogmask() must return the same mask as previous call");
        $r = eval { setlogmask(0) } || 0;
        is( $@@, '', "setlogmask() called with a null mask" );
        is( $r, $newmask, "setlogmask() must return the new mask");
        setlogmask($oldmask);
    }
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d1 1
a1 1
#!perl -T
d4 1
a4 1
    if ($ENV{PERL_CORE}) {
d15 3
a17 15
# we enable all Perl warnings, but we don't "use warnings 'all'" because 
# we want to disable the warnings generated by Sys::Syslog
no warnings;
use warnings qw(closure deprecated exiting glob io misc numeric once overflow
                pack portable recursion redefine regexp severe signal substr
                syntax taint uninitialized unpack untie utf8 void);

my $is_Win32  = $^O =~ /win32/i;
my $is_Cygwin = $^O =~ /cygwin/i;

# if testing in core, check that the module is at least available
if ($ENV{PERL_CORE}) {
    plan skip_all => "Sys::Syslog was not build" 
        unless $Config{'extensions'} =~ /\bSyslog\b/;
}
d21 1
a21 1
    unless $Config{'extensions'} =~ /\bSocket\b/;
d23 2
a24 2
my $tests;
plan tests => $tests;
d26 4
a29 2
# any remaining warning should be severly punished
BEGIN { eval "use Test::NoWarnings"; $tests = $@@ ? 0 : 1; }
a30 6
BEGIN { $tests += 1 }
# ok, now loads them
eval 'use Socket';
use_ok('Sys::Syslog', ':standard', ':extended', ':macros');

BEGIN { $tests += 1 }
a34 1
BEGIN { $tests += 1 }
d38 1
a38 1
like( $@@, qr/^Invalid argument passed to setlogsock/, 
a40 1
BEGIN { $tests += 3 }
a45 9
eval { syslog(undef) };
like( $@@, qr/^syslog: expecting argument \$priority/, 
    "calling syslog() with one undef argument" );

eval { syslog('') };
like( $@@, qr/^syslog: expecting argument \$format/, 
    "calling syslog() with one empty argument" );


a48 1
BEGIN { $tests += 8 }
a84 2

BEGIN { $tests += 20 * 8 }
d86 1
a86 2
my @@passed = ();
for my $sock_type (qw(native eventlog unix pipe stream inet tcp udp)) {
d88 1
a88 4
        skip "the 'stream' mechanism because a previous mechanism with similar interface succeeded", 20 
            if $sock_type eq 'stream' and grep {/pipe|unix/} @@passed;

        # setlogsock() called with an arrayref
d90 3
a92 9
        skip "can't use '$sock_type' socket", 20 unless $r;
        is( $@@, '', "[$sock_type] setlogsock() called with ['$sock_type']" );
        ok( $r, "[$sock_type] setlogsock() should return true: '$r'" );

        # setlogsock() called with a single argument
        $r = eval { setlogsock($sock_type) } || 0;
        skip "can't use '$sock_type' socket", 18 unless $r;
        is( $@@, '', "[$sock_type] setlogsock() called with '$sock_type'" );
        ok( $r, "[$sock_type] setlogsock() should return true: '$r'" );
d96 3
a98 3
        skip "can't connect to syslog", 16 if $@@ =~ /^no connection to syslog available/;
        is( $@@, '', "[$sock_type] openlog() called with facility 'local0' and without option 'ndelay'" );
        ok( $r, "[$sock_type] openlog() should return true: '$r'" );
d102 3
a104 18
        skip "can't connect to syslog", 14 if $@@ =~ /^no connection to syslog available/;
        is( $@@, '', "[$sock_type] openlog() called with facility 'local0' with option 'ndelay'" );
        ok( $r, "[$sock_type] openlog() should return true: '$r'" );

        # syslog() with negative level, should fail
        $r = eval { syslog(-1, "$test_string by connecting to a $sock_type socket") } || 0;
        like( $@@, '/^syslog: invalid level\/facility: /', "[$sock_type] syslog() called with level -1" );
        ok( !$r, "[$sock_type] syslog() should return false: '$r'" );

        # syslog() with levels "info" and "notice" (as a strings), should fail
        $r = eval { syslog('info,notice', "$test_string by connecting to a $sock_type socket") } || 0;
        like( $@@, '/^syslog: too many levels given: notice/', "[$sock_type] syslog() called with level 'info,notice'" );
        ok( !$r, "[$sock_type] syslog() should return false: '$r'" );

        # syslog() with facilities "local0" and "local1" (as a strings), should fail
        $r = eval { syslog('local0,local1', "$test_string by connecting to a $sock_type socket") } || 0;
        like( $@@, '/^syslog: too many facilities given: local1/', "[$sock_type] syslog() called with level 'local0,local1'" );
        ok( !$r, "[$sock_type] syslog() should return false: '$r'" );
d108 2
a109 2
        is( $@@, '', "[$sock_type] syslog() called with level 'info' (string)" );
        ok( $r, "[$sock_type] syslog() should return true: '$r'" );
d112 3
a114 5
        { local $! = 1;
          $r = eval { syslog(LOG_INFO(), "$test_string by connecting to a $sock_type socket, setting a fake errno: %m") } || 0;
        }
        is( $@@, '', "[$sock_type] syslog() called with level 'info' (macro)" );
        ok( $r, "[$sock_type] syslog() should return true: '$r'" );
d116 9
a124 1
        push @@passed, $sock_type;
d130 2
a131 22
            is( $@@, '', "[$sock_type] closelog()" );
            ok( $r, "[$sock_type] closelog() should return true: '$r'" );
        }
    }
}


BEGIN { $tests += 10 }
SKIP: {
    skip "not testing setlogsock('stream') on Win32", 10 if $is_Win32;
    skip "the 'unix' mechanism works, so the tests will likely fail with the 'stream' mechanism", 10 
        if grep {/unix/} @@passed;

    # setlogsock() with "stream" and an undef path
    $r = eval { setlogsock("stream", undef ) } || '';
    is( $@@, '', "setlogsock() called, with 'stream' and an undef path" );
    if ($is_Cygwin) {
        if (-x "/usr/sbin/syslog-ng") {
            ok( $r, "setlogsock() on Cygwin with syslog-ng should return true: '$r'" );
        }
        else {
            ok( !$r, "setlogsock() on Cygwin without syslog-ng should return false: '$r'" );
a133 29
    else  {
        ok( $r, "setlogsock() should return true: '$r'" );
    }

    # setlogsock() with "stream" and an empty path
    $r = eval { setlogsock("stream", '' ) } || '';
    is( $@@, '', "setlogsock() called, with 'stream' and an empty path" );
    ok( !$r, "setlogsock() should return false: '$r'" );

    # setlogsock() with "stream" and /dev/null
    $r = eval { setlogsock("stream", '/dev/null' ) } || '';
    is( $@@, '', "setlogsock() called, with 'stream' and '/dev/null'" );
    ok( $r, "setlogsock() should return true: '$r'" );

    # setlogsock() with "stream" and a non-existing file
    $r = eval { setlogsock("stream", 'test.log' ) } || '';
    is( $@@, '', "setlogsock() called, with 'stream' and 'test.log' (file does not exist)" );
    ok( !$r, "setlogsock() should return false: '$r'" );

    # setlogsock() with "stream" and a local file
    SKIP: {
        my $logfile = "test.log";
        open(LOG, ">$logfile") or skip "can't create file '$logfile': $!", 2;
        close(LOG);
        $r = eval { setlogsock("stream", $logfile ) } || '';
        is( $@@, '', "setlogsock() called, with 'stream' and '$logfile' (file exists)" );
        ok( $r, "setlogsock() should return true: '$r'" );
        unlink($logfile);
    }
a135 2

BEGIN { $tests += 3 + 4 * 3 }
d146 1
a146 7
    my @@masks = (
        LOG_MASK(LOG_ERR()), 
        ~LOG_MASK(LOG_INFO()), 
        LOG_MASK(LOG_CRIT()) | LOG_MASK(LOG_ERR()) | LOG_MASK(LOG_WARNING()), 
    );

    for my $newmask (@@masks) {
@


