head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.2
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.1.1.5.0.16
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.10
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.12
	OPENBSD_5_8_BASE:1.1.1.5
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.4
	OPENBSD_5_7_BASE:1.1.1.5
	PERL_5_20_1:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.8
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.6
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.2
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.4.0.10
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.8
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.6
	OPENBSD_5_0:1.1.1.4.0.4
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.2
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.3.0.8
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.4
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.20
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.18
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.16
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.14
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.12
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.33.40;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	7JLVNm1wwPgqSqTa;

1.2
date	2017.02.05.00.32.13;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.52;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.23;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.09.24.14.48.52;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.08.46;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Apply local patches - perl-5.24.1
@
text
@#!./perl

BEGIN{
	# Don't do anything if POSIX is missing, or sigaction missing.
	use Config;
	eval 'use POSIX';
	if($@@ || $^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'dos' ||
	   $^O eq 'MacOS' || ($^O eq 'VMS' && !$Config{'d_sigaction'})) {
		print "1..0\n";
		exit 0;
	}
}

use Test::More tests => 36;

use strict;
use vars qw/$bad $bad7 $ok10 $bad18 $ok/;

$^W=1;

sub IGNORE {
    ++$bad7;
}

sub DEFAULT {
    ++$bad18;
}

sub foo {
    ++$ok;
}

my $newaction=POSIX::SigAction->new('::foo', new POSIX::SigSet(SIGUSR1), 0);
my $oldaction=POSIX::SigAction->new('::bar', new POSIX::SigSet(), 0);

{
	my $bad;
	local($SIG{__WARN__})=sub { $bad=1; };
	sigaction(SIGHUP, $newaction, $oldaction);
	is($bad, undef, "no warnings");
}

like($oldaction->{HANDLER}, qr/\A(?:DEFAULT|IGNORE)\z/, '$oldaction->{HANDLER}');

is($SIG{HUP}, '::foo');

sigaction(SIGHUP, $newaction, $oldaction);
is($oldaction->{HANDLER}, '::foo');

ok($oldaction->{MASK}->ismember(SIGUSR1), "SIGUSR1 ismember MASK");

SKIP: {
    skip("sigaction() thinks different in $^O", 1)
	if $^O eq 'linux' || $^O eq 'unicos';
    is($oldaction->{FLAGS}, 0);
}

$newaction=POSIX::SigAction->new('IGNORE');
sigaction(SIGHUP, $newaction);
kill 'HUP', $$;
is($bad, undef, "SIGHUP ignored");

is($SIG{HUP}, 'IGNORE');
sigaction(SIGHUP, POSIX::SigAction->new('DEFAULT'));
is($SIG{HUP}, 'DEFAULT');

$newaction=POSIX::SigAction->new(sub { ++$ok10; });
sigaction(SIGHUP, $newaction);
{
	local($^W)=0;
	kill 'HUP', $$;
}
is($ok10, 1, "SIGHUP handler called");

is(ref($SIG{HUP}), 'CODE');

sigaction(SIGHUP, POSIX::SigAction->new('::foo'));
# Make sure the signal mask gets restored after sigaction croak()s.
eval {
	my $act=POSIX::SigAction->new('::foo');
	delete $act->{HANDLER};
	sigaction(SIGINT, $act);
};
kill 'HUP', $$;
is($ok, 1, "signal mask gets restored after croak");

undef $ok;
# Make sure the signal mask gets restored after sigaction returns early.
my $x=defined sigaction(SIGKILL, $newaction, $oldaction);
kill 'HUP', $$;
is($x, '', "signal mask gets restored after early return");
is($ok, 1, "signal mask gets restored after early return");

$SIG{HUP}=sub {};
sigaction(SIGHUP, $newaction, $oldaction);
is(ref($oldaction->{HANDLER}), 'CODE');

eval {
	sigaction(SIGHUP, undef, $oldaction);
};
is($@@, '', "undef for new action");

eval {
	sigaction(SIGHUP, 0, $oldaction);
};
is($@@, '', "zero for new action");

eval {
	sigaction(SIGHUP, bless({},'Class'), $oldaction);
};
like($@@, qr/\Aaction is not of type POSIX::SigAction/,
     'any object not good as new action');

SKIP: {
    skip("SIGCONT not trappable in $^O", 1)
	if ($^O eq 'VMS');
    $newaction=POSIX::SigAction->new(sub { ++$ok10; });
    if (eval { SIGCONT; 1 }) {
	sigaction(SIGCONT, POSIX::SigAction->new('DEFAULT'));
	{
	    local($^W)=0;
	    kill 'CONT', $$;
	}
    }
    is($bad18, undef, "SIGCONT trappable");
}

{
    local $SIG{__WARN__} = sub { }; # Just suffer silently.

    my $hup20;
    my $hup21;

    sub hup20 { $hup20++ }
    sub hup21 { $hup21++ }

    sigaction("FOOBAR", $newaction);
    pass("no coredump, still alive");

    $newaction = POSIX::SigAction->new("hup20");
    sigaction("SIGHUP", $newaction);
    kill "HUP", $$;
    is($hup20, 1);

    $newaction = POSIX::SigAction->new("hup21");
    sigaction("HUP", $newaction);
    kill "HUP", $$;
    is ($hup21, 1);
}

# "safe" attribute.
# for this one, use the accessor instead of the attribute

# standard signal handling via %SIG is safe
$SIG{HUP} = \&foo;
$oldaction = POSIX::SigAction->new;
sigaction(SIGHUP, undef, $oldaction);
ok($oldaction->safe, "SIGHUP is safe");

# SigAction handling is not safe ...
sigaction(SIGHUP, POSIX::SigAction->new(\&foo));
sigaction(SIGHUP, undef, $oldaction);
ok(!$oldaction->safe, "SigAction not safe by default");

# ... unless we say so!
$newaction = POSIX::SigAction->new(\&foo);
$newaction->safe(1);
sigaction(SIGHUP, $newaction);
sigaction(SIGHUP, undef, $oldaction);
ok($oldaction->safe, "SigAction can be safe");

# And safe signal delivery must work
$ok = 0;
kill 'HUP', $$;
is($ok, 1, "safe signal delivery must work");

SKIP: {
    eval 'use POSIX qw(%SIGRT SIGRTMIN SIGRTMAX); scalar %SIGRT + SIGRTMIN() + SIGRTMAX()';
    $@@					# POSIX did not exort
    || SIGRTMIN() < 0 || SIGRTMAX() < 0	# HP-UX 10.20 exports both as -1
    || SIGRTMIN() > $Config{sig_count}	# AIX 4.3.3 exports bogus 888 and 999
	and skip("no SIGRT signals", 4);
    cmp_ok(SIGRTMAX(), '>', SIGRTMIN(), "SIGRTMAX > SIGRTMIN");
    is(scalar %SIGRT, SIGRTMAX() - SIGRTMIN() + 1, "scalar SIGRT");
    my $sigrtmin;
    my $h = sub { $sigrtmin = 1 };
    $SIGRT{SIGRTMIN} = $h;
    is($SIGRT{SIGRTMIN}, $h, "handler set & get");
    kill 'SIGRTMIN', $$;
    is($sigrtmin, 1, "SIGRTMIN handler works");
}

SKIP: {
    my %siginfo = (
        signo => SIGHUP,
        pid => $$,
        uid => $<,
    );
    my %opt_val = ( code => 'SI_USER' );
    my %always = map +($_ => 1), qw(signo code);
    my %skip = ( code => { darwin => "not set to SI_USER for kill()" } );
    $skip{pid}{$^O} = $skip{uid}{$^O} = "not set for kill()"
        if (($^O.$Config{osvers}) =~ /^darwin[0-8]\./
            ||
            ($^O.$Config{osvers}) =~ /^openbsd[0-6]\./);
    my $tests = keys %{{ %siginfo, %opt_val }};
    eval 'use POSIX qw(SA_SIGINFO); SA_SIGINFO';
    skip("no SA_SIGINFO", $tests) if $@@;
    skip("SA_SIGINFO is broken on AIX 4.2", $tests) if ($^O.$Config{osvers}) =~ m/^aix4\.2/;
    skip("SA_SIGINFO is broken on os390", $tests) if ($^O.$Config{osvers}) =~ m/os390/;
    eval "use POSIX qw($opt_val{$_}); \$siginfo{$_} = $opt_val{$_}"
        for keys %opt_val;
    sub hiphup {
        for my $field (sort keys %{{ %siginfo, %opt_val }}) {
            SKIP: {
                skip("siginfo_t has no $field field", 1)
                    unless %always{$field} or ($Config{"d_siginfo_si_$field"} || '') eq 'define';
                skip("no constant defined for SA_SIGINFO $field value $opt_val{$field}", 1)
                    unless defined $siginfo{$field};
                skip("SA_SIGINFO $field value is wrong on $^O: $skip{$field}{$^O}", 1)
                    if $skip{$field}{$^O};
                is($_[1]->{$field}, $siginfo{$field}, "SA_SIGINFO got right $field")
            }
        }
    }
    my $act = POSIX::SigAction->new('hiphup', 0, SA_SIGINFO);
    sigaction(SIGHUP, $act);
    kill 'HUP', $$;
}

eval { sigaction(-999, "foo"); };
like($@@, qr/Negative signals/,
    "Prevent negative signals instead of core dumping");

# RT 77432 - assertion failure with POSIX::SigAction
{
  local *SIG = {};
  ok(sigaction(SIGHUP, POSIX::SigAction->new),
     "sigaction would crash/assert with a replaced %SIG");
}
@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@d205 1
a205 1
            ($^O.$Config{osvers}) =~ /^openbsd[0-5]\./);
@


1.1
log
@Initial revision
@
text
@a2 5
BEGIN {
	chdir 't' if -d 't';
	unshift @@INC, '../lib';
}

d6 1
a6 1
	eval { use POSIX; };
d14 2
d17 1
a17 1
use vars qw/$bad7 $ok10 $bad18 $ok/;
a20 2
print "1..18\n";

d22 1
a22 1
	$bad7=1;
d26 1
a26 1
	$bad18=1;
d30 1
a30 1
	$ok=1;
d40 1
a40 1
	if($bad) { print "not ok 1\n" } else { print "ok 1\n"}
d43 3
a45 4
if($oldaction->{HANDLER} eq 'DEFAULT' ||
   $oldaction->{HANDLER} eq 'IGNORE')
  { print "ok 2\n" } else { print "not ok 2 # ", $oldaction->{HANDLER}, "\n"}
print $SIG{HUP} eq '::foo' ? "ok 3\n" : "not ok 3\n";
d48 8
a55 12
if($oldaction->{HANDLER} eq '::foo')
  { print "ok 4\n" } else { print "not ok 4\n"}
if($oldaction->{MASK}->ismember(SIGUSR1))
  { print "ok 5\n" } else { print "not ok 5\n"}
if($oldaction->{FLAGS}) {
    if ($^O eq 'linux' || $^O eq 'unicos') {
	print "ok 6 # Skip: sigaction() thinks different in $^O\n";
    } else {
	print "not ok 6\n";
    }
} else {
    print "ok 6\n";
d61 1
a61 1
print $bad7 ? "not ok 7\n" : "ok 7\n";
d63 1
a63 1
print $SIG{HUP} eq 'IGNORE' ? "ok 8\n" : "not ok 8\n";
d65 1
a65 1
print $SIG{HUP} eq 'DEFAULT' ? "ok 9\n" : "not ok 9\n";
d67 1
a67 1
$newaction=POSIX::SigAction->new(sub { $ok10=1; });
d73 1
a73 1
print $ok10 ? "ok 10\n" : "not ok 10\n";
d75 1
a75 1
print ref($SIG{HUP}) eq 'CODE' ? "ok 11\n" : "not ok 11\n";
d85 1
a85 1
print $ok ? "ok 12\n" : "not ok 12\n";
d91 2
a92 1
print !$x && $ok ? "ok 13\n" : "not ok 13\n";
d96 1
a96 1
print ref($oldaction->{HANDLER}) eq 'CODE' ? "ok 14\n" : "not ok 14\n";
d101 1
a101 1
print $@@ ? "not ok 15\n" : "ok 15\n";
d106 1
a106 1
print $@@ ? "not ok 16\n" : "ok 16\n";
d111 2
a112 1
print $@@ ? "ok 17\n" : "not ok 17\n";
d114 4
a117 4
if ($^O eq 'VMS') {
    print "ok 18 # Skip: SIGCONT not trappable in $^O\n";
} else {
    $newaction=POSIX::SigAction->new(sub { $ok10=1; });
d125 1
a125 1
    print $bad18 ? "not ok 18\n" : "ok 18\n";
d128 113
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d11 1
a11 1
	eval 'use POSIX';
d24 1
a24 1
print "1..25\n";
a135 48
{
    local $SIG{__WARN__} = sub { }; # Just suffer silently.

    my $hup20;
    my $hup21;

    sub hup20 { $hup20++ }
    sub hup21 { $hup21++ }

    sigaction("FOOBAR", $newaction);
    print "ok 19\n"; # no coredump, still alive

    $newaction = POSIX::SigAction->new("hup20");
    sigaction("SIGHUP", $newaction);
    kill "HUP", $$;
    print $hup20 == 1 ? "ok 20\n" : "not ok 20\n";

    $newaction = POSIX::SigAction->new("hup21");
    sigaction("HUP", $newaction);
    kill "HUP", $$;
    print $hup21 == 1 ? "ok 21\n" : "not ok 21\n";
}

# "safe" attribute.
# for this one, use the accessor instead of the attribute

# standard signal handling via %SIG is safe
$SIG{HUP} = \&foo;
$oldaction = POSIX::SigAction->new;
sigaction(SIGHUP, undef, $oldaction);
print $oldaction->safe ? "ok 22\n" : "not ok 22\n";

# SigAction handling is not safe ...
sigaction(SIGHUP, POSIX::SigAction->new(\&foo));
sigaction(SIGHUP, undef, $oldaction);
print $oldaction->safe ? "not ok 23\n" : "ok 23\n";

# ... unless we say so!
$newaction = POSIX::SigAction->new(\&foo);
$newaction->safe(1);
sigaction(SIGHUP, $newaction);
sigaction(SIGHUP, undef, $oldaction);
print $oldaction->safe ? "ok 24\n" : "not ok 24\n";

# And safe signal delivery must work
$ok = 0;
kill 'HUP', $$;
print $ok ? "ok 25\n" : "not ok 25\n";
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@a18 2
use Test::More tests => 31;

d20 1
a20 1
use vars qw/$bad $bad7 $ok10 $bad18 $ok/;
d24 2
d45 1
a45 1
	ok(!$bad, "no warnings");
d48 4
a51 4
ok($oldaction->{HANDLER} eq 'DEFAULT' ||
   $oldaction->{HANDLER} eq 'IGNORE', $oldaction->{HANDLER});

is($SIG{HUP}, '::foo');
d54 12
a65 8
is($oldaction->{HANDLER}, '::foo');

ok($oldaction->{MASK}->ismember(SIGUSR1), "SIGUSR1 ismember MASK");

SKIP: {
    skip("sigaction() thinks different in $^O", 1)
	if $^O eq 'linux' || $^O eq 'unicos';
    is($oldaction->{FLAGS}, 0);
d71 1
a71 1
ok(!$bad, "SIGHUP ignored");
d73 1
a73 1
is($SIG{HUP}, 'IGNORE');
d75 1
a75 1
is($SIG{HUP}, 'DEFAULT');
d83 1
a83 1
ok($ok10, "SIGHUP handler called");
d85 1
a85 1
is(ref($SIG{HUP}), 'CODE');
d95 1
a95 1
ok($ok, "signal mask gets restored after croak");
d101 1
a101 1
ok(!$x && $ok, "signal mask gets restored after early return");
d105 1
a105 1
is(ref($oldaction->{HANDLER}), 'CODE');
d110 1
a110 1
ok(!$@@, "undef for new action");
d115 1
a115 1
ok(!$@@, "zero for new action");
d120 1
a120 1
ok($@@, "any object not good as new action");
d122 3
a124 3
SKIP: {
    skip("SIGCONT not trappable in $^O", 1)
	if ($^O eq 'VMS');
d133 1
a133 1
    ok(!$bad18, "SIGCONT trappable");
d146 1
a146 1
    ok(1, "no coredump, still alive");
d151 1
a151 1
    is($hup20, 1);
d156 1
a156 1
    is ($hup21, 1);
d166 1
a166 1
ok($oldaction->safe, "SIGHUP is safe");
d171 1
a171 1
ok(!$oldaction->safe, "SigAction not safe by default");
d178 1
a178 1
ok($oldaction->safe, "SigAction can be safe");
d183 1
a183 32
ok($ok, "safe signal delivery must work");

SKIP: {
    eval 'use POSIX qw(%SIGRT SIGRTMIN SIGRTMAX); scalar %SIGRT + SIGRTMIN() + SIGRTMAX()';
    $@@					# POSIX did not exort
    || SIGRTMIN() < 0 || SIGRTMAX() < 0	# HP-UX 10.20 exports both as -1
    || SIGRTMIN() > $Config{sig_count}	# AIX 4.3.3 exports bogus 888 and 999
	and skip("no SIGRT signals", 4);
    ok(SIGRTMAX() > SIGRTMIN(), "SIGRTMAX > SIGRTMIN");
    is(scalar %SIGRT, SIGRTMAX() - SIGRTMIN() + 1, "scalar SIGRT");
    my $sigrtmin;
    my $h = sub { $sigrtmin = 1 };
    $SIGRT{SIGRTMIN} = $h;
    is($SIGRT{SIGRTMIN}, $h, "handler set & get");
    kill 'SIGRTMIN', $$;
    is($sigrtmin, 1, "SIGRTMIN handler works");
}

SKIP: {
    eval 'use POSIX qw(SA_SIGINFO); SA_SIGINFO';
    skip("no SA_SIGINFO", 1) if $@@;
    sub hiphup {
	is($_[1]->{signo}, SIGHUP, "SA_SIGINFO got right signal");
    }
    my $act = POSIX::SigAction->new('hiphup', 0, SA_SIGINFO);
    sigaction(SIGHUP, $act);
    kill 'HUP', $$;
}

eval { sigaction(-999, "foo"); };
like($@@, qr/Negative signals/,
    "Prevent negative signals instead of core dumping");
@


1.1.1.4
log
@Perl 5.12.2 from CPAN
@
text
@d3 5
a199 1
    skip("SA_SIGINFO is broken on AIX 4.2", 1) if $^O.$Config{osvers} =~ m/^aix4\.2/;
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d14 1
a14 1
use Test::More tests => 33;
d22 1
a22 1
    ++$bad7;
d26 1
a26 1
    ++$bad18;
d30 1
a30 1
    ++$ok;
d40 1
a40 1
	is($bad, undef, "no warnings");
d43 2
a44 1
like($oldaction->{HANDLER}, qr/\A(?:DEFAULT|IGNORE)\z/, '$oldaction->{HANDLER}');
d62 1
a62 1
is($bad, undef, "SIGHUP ignored");
d68 1
a68 1
$newaction=POSIX::SigAction->new(sub { ++$ok10; });
d74 1
a74 1
is($ok10, 1, "SIGHUP handler called");
d86 1
a86 1
is($ok, 1, "signal mask gets restored after croak");
d92 1
a92 2
is($x, '', "signal mask gets restored after early return");
is($ok, 1, "signal mask gets restored after early return");
d101 1
a101 1
is($@@, '', "undef for new action");
d106 1
a106 1
is($@@, '', "zero for new action");
d111 1
a111 2
like($@@, qr/\Aaction is not of type POSIX::SigAction/,
     'any object not good as new action');
d116 1
a116 1
    $newaction=POSIX::SigAction->new(sub { ++$ok10; });
d124 1
a124 1
    is($bad18, undef, "SIGCONT trappable");
d137 1
a137 1
    pass("no coredump, still alive");
d174 1
a174 1
is($ok, 1, "safe signal delivery must work");
d182 1
a182 1
    cmp_ok(SIGRTMAX(), '>', SIGRTMIN(), "SIGRTMAX > SIGRTMIN");
d195 1
a195 1
    skip("SA_SIGINFO is broken on AIX 4.2", 1) if ($^O.$Config{osvers}) =~ m/^aix4\.2/;
a206 7

# RT 77432 - assertion failure with POSIX::SigAction
{
  local *SIG = {};
  ok(sigaction(SIGHUP, POSIX::SigAction->new),
     "sigaction would crash/assert with a replaced %SIG");
}
@


