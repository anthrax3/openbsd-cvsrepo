head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.6.0.12
	OPENBSD_6_1_BASE:1.1.1.6
	OPENBSD_6_0:1.1.1.6.0.10
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.4
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.6
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.4
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.4.0.6
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.2
	OPENBSD_5_4_BASE:1.1.1.4
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.1.1.3.0.10
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.8
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.6
	OPENBSD_5_0:1.1.1.3.0.4
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.2
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.2.0.4
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.2
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2008.09.29.17.18.23;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.29.17.18.23;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.10.12.18.11.12;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.09.24.14.48.52;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.03.25.20.08.46;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.24.14.59.02;	author afresh1;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.17.20.53.06;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@#!perl -T

BEGIN {
    if ($ENV{PERL_CORE}) {
        chdir 't';
        @@INC = '../lib';
    }

    use Config;
    use Test::More;
    plan skip_all => "POSIX is unavailable" if $Config{'extensions'} !~ m!\bPOSIX\b!;
}

use strict;
use File::Spec;
use POSIX;
use Scalar::Util qw(looks_like_number);

sub check(@@) {
    grep { eval "&$_;1" or $@@!~/vendor has not defined POSIX macro/ } @@_
}       

my @@path_consts = check qw(
    _PC_CHOWN_RESTRICTED _PC_LINK_MAX _PC_NAME_MAX
    _PC_NO_TRUNC _PC_PATH_MAX
);

my @@path_consts_terminal = check qw(
    _PC_MAX_CANON _PC_MAX_INPUT _PC_VDISABLE
);

my @@path_consts_fifo = check qw(
    _PC_PIPE_BUF
);

my @@sys_consts = check qw(
    _SC_ARG_MAX _SC_CHILD_MAX _SC_CLK_TCK _SC_JOB_CONTROL
    _SC_NGROUPS_MAX _SC_OPEN_MAX _SC_PAGESIZE _SC_SAVED_IDS
    _SC_STREAM_MAX _SC_VERSION _SC_TZNAME_MAX
);

my $tests = 2 * 3 * @@path_consts +
            2 * 3 * @@path_consts_terminal +
            2 * 3 * @@path_consts_fifo +
                3 * @@sys_consts;
plan $tests 
     ? (tests => $tests) 
     : (skip_all => "No tests to run on this OS")
;

my $curdir = File::Spec->curdir;
$curdir = VMS::Filespec::fileify($curdir) if $^O eq 'VMS';

my $r;

my $TTY = "/dev/tty";

sub _check_and_report {
    my ($eval_status, $return_val, $description) = @@_;
    my $success = defined($return_val) || $! == 0;
    is( $eval_status, '', $description );
    SKIP: {
	skip "terminal constants set errno on QNX", 1
	    if $^O eq 'nto' and $description =~ $TTY;
        ok( $success, "\tchecking that the returned value is defined (" 
                        . (defined($return_val) ? "yes, it's $return_val)" : "it isn't)"
                        . " or that errno is clear ("
                        . (!($!+0) ? "it is)" : "it isn't, it's $!)"))
                        );
    }
    SKIP: {
        skip "constant not implemented on $^O or no limit in effect", 1 
            if !defined($return_val);
        ok( looks_like_number($return_val), "\tchecking that the returned value looks like a number" );
    }
}

# testing fpathconf() on a non-terminal file
SKIP: {
    my $fd = POSIX::open($curdir, O_RDONLY)
        or skip "could not open current directory ($!)", 3 * @@path_consts;

    for my $constant (@@path_consts) {
	    $! = 0;
            $r = eval { fpathconf( $fd, eval "$constant()" ) };
            _check_and_report( $@@, $r, "calling fpathconf($fd, $constant) " );
    }
    
    POSIX::close($fd);
}

# testing pathconf() on a non-terminal file
for my $constant (@@path_consts) {
	$! = 0;
        $r = eval { pathconf( $curdir, eval "$constant()" ) };
        _check_and_report( $@@, $r, qq[calling pathconf("$curdir", $constant)] );
}

SKIP: {
    my $n = 2 * 3 * @@path_consts_terminal;

    -c $TTY
	or skip("$TTY not a character file", $n);
    open(TTY, $TTY)
	or skip("failed to open $TTY: $!", $n);
    -t TTY
	or skip("TTY ($TTY) not a terminal file", $n);

    my $fd = fileno(TTY);

    # testing fpathconf() on a terminal file
    for my $constant (@@path_consts_terminal) {
	$! = 0;
	$r = eval { fpathconf( $fd, eval "$constant()" ) };
	_check_and_report( $@@, $r, qq[calling fpathconf($fd, $constant) ($TTY)] );
    }
    
    close($fd);
    # testing pathconf() on a terminal file
    for my $constant (@@path_consts_terminal) {
	$! = 0;
	$r = eval { pathconf( $TTY, eval "$constant()" ) };
	_check_and_report( $@@, $r, qq[calling pathconf($TTY, $constant)] );
    }
}

my $fifo = "fifo$$";

SKIP: {
    eval { mkfifo($fifo, 0666) }
	or skip("could not create fifo $fifo ($!)", 2 * 3 * @@path_consts_fifo);

  SKIP: {
      my $fd = POSIX::open($fifo, O_RDWR)
	  or skip("could not open $fifo ($!)", 3 * @@path_consts_fifo);

      for my $constant (@@path_consts_fifo) {
	  $! = 0;
	  $r = eval { fpathconf( $fd, eval "$constant()" ) };
	  _check_and_report( $@@, $r, "calling fpathconf($fd, $constant) ($fifo)" );
      }
    
      POSIX::close($fd);
  }

  # testing pathconf() on a fifo file
  for my $constant (@@path_consts_fifo) {
      $! = 0;
      $r = eval { pathconf( $fifo, eval "$constant()" ) };
      _check_and_report( $@@, $r, qq[calling pathconf($fifo, $constant)] );
  }
}

END {
    1 while unlink($fifo);
}

SKIP: {
    if($^O eq 'cygwin') {
        pop @@sys_consts;
        skip("No _SC_TZNAME_MAX on Cygwin", 3);
    }
        
}
# testing sysconf()
for my $constant (@@sys_consts) {
	$! = 0;
	$r = eval { sysconf( eval "$constant()" ) };
	_check_and_report( $@@, $r, "calling sysconf($constant)" );
}

@


1.1.1.1
log
@import perl 5.10.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.1
@
text
@d51 2
a52 5
# Don't test on "." as it can be networked storage which returns EINVAL
# Testing on "/" may not be portable to non-Unix as it may not be readable
# "/tmp" should be readable and likely also local.
my $testdir = File::Spec->tmpdir;
$testdir = VMS::Filespec::fileify($testdir) if $^O eq 'VMS';
d80 2
a81 3
    my $fd = POSIX::open($testdir, O_RDONLY)
        or skip "could not open test directory '$testdir' ($!)",
	  3 * @@path_consts;
d95 2
a96 2
        $r = eval { pathconf( $testdir, eval "$constant()" ) };
        _check_and_report( $@@, $r, qq[calling pathconf("$testdir", $constant)] );
@


1.1.1.3
log
@Perl 5.12.2 from CPAN
@
text
@d4 5
@


1.1.1.4
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d12 1
d37 4
a40 4
my $tests = 2 * 2 * @@path_consts +
            2 * 2 * @@path_consts_terminal +
            2 * 2 * @@path_consts_fifo +
                1 * @@sys_consts;
d57 16
a72 16
    my ($sub, $constant, $description) = @@_;
    $! = 0;
    my $return_val = eval {$sub->(eval "$constant()")};
    my $errno = $!; # Grab this before anything else changes it.
    is($@@, '', $description);

    # We can't test sysconf further without investigating the type of argument
    # provided
    return if $description =~ /sysconf/;

    if (defined $return_val) {
	like($return_val, qr/\A(?:-?[1-9][0-9]*|0 but true)\z/,
	     'the returned value should be a signed integer');
    } else {
	cmp_ok($errno, '==', 0, 'errno should be 0 as before the call')
	    or diag("\$!: $errno");
d80 1
a80 1
	  2 * @@path_consts;
d83 3
a85 2
	_check_and_report(sub { fpathconf($fd, shift) }, $constant,
			  "calling fpathconf($fd, $constant)");
d93 3
a95 2
    _check_and_report(sub { pathconf($testdir, shift) }, $constant,
		      "calling pathconf('$testdir', $constant)");
d99 1
a99 1
    my $n = 2 * 2 * @@path_consts_terminal;
d112 3
a114 2
	_check_and_report(sub { fpathconf($fd, shift) }, $constant,
			  "calling fpathconf($fd, $constant) ($TTY)");
d120 3
a122 2
	_check_and_report(sub { pathconf($TTY, shift) }, $constant,
			  "calling pathconf($TTY, $constant)");
d130 1
a130 1
	or skip("could not create fifo $fifo ($!)", 2 * 2 * @@path_consts_fifo);
d133 2
a134 2
      my $fd = POSIX::open($fifo, O_RDONLY | O_NONBLOCK)
	  or skip("could not open $fifo ($!)", 2 * @@path_consts_fifo);
d137 3
a139 2
	  _check_and_report(sub { fpathconf($fd, shift) }, $constant,
			    "calling fpathconf($fd, $constant) ($fifo)");
d147 3
a149 2
      _check_and_report(sub { pathconf($fifo, shift) }, $constant,
			"calling pathconf($fifo, $constant");
d160 1
a160 1
        skip("No _SC_TZNAME_MAX on Cygwin", 1);
d166 3
a168 2
    _check_and_report(sub {sysconf(shift)}, $constant,
		      "calling sysconf($constant)");
d170 1
@


1.1.1.5
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d70 2
a71 9
      SKIP:
	{
	    # POSIX specifies EINVAL is returned if the f?pathconf()
	    # isn't implemented for the specific path
	    skip "$description not implemented for this path", 1
		if $errno == EINVAL && $description =~ /pathconf/;
	    cmp_ok($errno, '==', 0, 'errno should be 0 as before the call')
		or diag("\$!: $errno");
	}
@


1.1.1.6
log
@Import perl-5.20.1
@
text
@d89 1
a89 3
        SKIP: {
            skip "pathconf($constant) hangs on Android", 2 if $constant eq '_PC_LINK_MAX' && $^O =~ /android/;
            _check_and_report(sub { fpathconf($fd, shift) }, $constant,
a90 1
        }
a97 2
   SKIP: {
      skip "pathconf($constant) hangs on Android", 2 if $constant eq '_PC_LINK_MAX' && $^O =~ /android/;
a99 1
   }
@


