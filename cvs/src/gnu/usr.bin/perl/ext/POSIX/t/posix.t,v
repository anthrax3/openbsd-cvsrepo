head	1.7;
access;
symbols
	PERL_5_24_2:1.1.1.10
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.6.0.8
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.7.0.6
	OPENBSD_5_5_BASE:1.1.1.7
	OPENBSD_5_4:1.1.1.7.0.2
	OPENBSD_5_4_BASE:1.1.1.7
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.6.0.10
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.8
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.6
	OPENBSD_5_0:1.1.1.6.0.4
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.2
	OPENBSD_4_9_BASE:1.1.1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.1.1.5.0.4
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.2
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.18
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.16
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.14
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.12
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.10
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.7
date	2017.02.05.00.32.13;	author afresh1;	state Exp;
branches;
next	1.6;
commitid	cxJ08BvJA9Pt2PTM;

1.6
date	2015.04.25.19.26.22;	author afresh1;	state Exp;
branches;
next	1.5;
commitid	3qGYFVvfrExB70FB;

1.5
date	2015.04.25.19.14.46;	author afresh1;	state Exp;
branches;
next	1.4;
commitid	XRK22kO4se3v2i2I;

1.4
date	2014.11.17.21.01.00;	author afresh1;	state Exp;
branches;
next	1.3;
commitid	LnErp1MFKSuew5Fr;

1.3
date	2014.11.17.20.57.06;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	QP75iYx42Uo7mMxO;

1.2
date	2014.07.14.07.22.07;	author pelikan;	state Exp;
branches;
next	1.1;
commitid	2T7dYu6PlirmmPvO;

1.1
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.52;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.04.07.21.13.08;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.23;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.11.12;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.48.52;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.08.46;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.03.24.14.59.02;	author afresh1;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.06;	author afresh1;	state Exp;
branches;
next	1.1.1.10;
commitid	B31cAbBIXiCqnL97;

1.1.1.10
date	2017.08.14.13.46.12;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.7
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    require Config; import Config;
    if ($^O ne 'VMS' and $Config{'extensions'} !~ /\bPOSIX\b/) {
	print "1..0\n";
	exit 0;
    }
    unshift @@INC, "../../t";
    require 'loc_tools.pl';
}

use Test::More tests => 94;

use POSIX qw(fcntl_h signal_h limits_h _exit getcwd open read strftime write
	     errno localeconv dup dup2 lseek access);
use strict 'subs';

sub next_test {
    my $builder = Test::More->builder;
    $builder->current_test($builder->current_test() + 1);
}

$| = 1;

$Is_W32     = $^O eq 'MSWin32';
$Is_Dos     = $^O eq 'dos';
$Is_MacOS   = $^O eq 'MacOS';
$Is_VMS     = $^O eq 'VMS';
$Is_OS2     = $^O eq 'os2';
$Is_UWin    = $^O eq 'uwin';
$Is_OS390   = $^O eq 'os390';

my $vms_unix_rpt = 0;
my $vms_efs = 0;
my $unix_mode = 1;

if ($Is_VMS) {
    $unix_mode = 0;
    if (eval 'require VMS::Feature') {
        $vms_unix_rpt = VMS::Feature::current("filename_unix_report");
        $vms_efs = VMS::Feature::current("efs_charset");
    } else {
        my $unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
        my $efs_charset = $ENV{'DECC$EFS_CHARSET'} || '';
        $vms_unix_rpt = $unix_rpt =~ /^[ET1]/i;
        $vms_efs = $efs_charset =~ /^[ET1]/i;
    }

    # Traditional VMS mode only if VMS is not in UNIX compatible mode.
    $unix_mode = ($vms_efs && $vms_unix_rpt);

}

my $testfd = open("Makefile.PL", O_RDONLY, 0);
like($testfd, qr/\A\d+\z/, 'O_RDONLY with open');
read($testfd, $buffer, 4) if $testfd > 2;
is( $buffer, "# Ex",                      '    with read' );

TODO:
{
    local $TODO = "read to array element not working";

    read($testfd, $buffer[1], 5) if $testfd > 2;
    is( $buffer[1], "perl\n",	               '    read to array element' );
}

my $test = next_test();
write(1,"ok $test\nnot ok $test\n", 5);

SKIP: {
    skip("no pipe() support on DOS", 2) if $Is_Dos;

    @@fds = POSIX::pipe();
    cmp_ok($fds[0], '>', $testfd, 'POSIX::pipe');

    CORE::open($reader = \*READER, "<&=".$fds[0]);
    CORE::open($writer = \*WRITER, ">&=".$fds[1]);
    my $test = next_test();
    print $writer "ok $test\n";
    close $writer;
    print <$reader>;
    close $reader;
}

SKIP: {
    skip("no sigaction support on win32/dos", 6) if $Is_W32 || $Is_Dos;

    my $sigset = new POSIX::SigSet 1, 3;
    $sigset->delset(1);
    ok(! $sigset->ismember(1),  'POSIX::SigSet->delset' );
    ok(  $sigset->ismember(3),  'POSIX::SigSet->ismember' );

    SKIP: {
        skip("no kill() support on Mac OS", 4) if $Is_MacOS;

        my $sigint_called = 0;

	my $mask   = new POSIX::SigSet &SIGINT;
	my $action = new POSIX::SigAction 'main::SigHUP', $mask, 0;
	sigaction(&SIGHUP, $action);
	$SIG{'INT'} = 'SigINT';

	# At least OpenBSD/i386 3.3 is okay, as is NetBSD 1.5.
	# But not NetBSD 1.6 & 1.6.1: the test makes perl crash.
	# So the kill() must not be done with this config in order to
	# finish the test.
	# For others (darwin & freebsd), let the test fail without crashing.
	# the test passes at least from freebsd 8.1
	my $todo = $^O eq 'netbsd' && $Config{osvers}=~/^1\.6/;
	my $why_todo = "# TODO $^O $Config{osvers} seems to lose blocked signals";
	if (!$todo) { 
	  kill 'HUP', $$; 
	} else {
	  print "not ok 9 - sigaction SIGHUP ",$why_todo,"\n";
	  print "not ok 10 - sig mask delayed SIGINT ",$why_todo,"\n";
	}
	sleep 1;

	$todo = 1 if ($^O eq 'freebsd' && $Config{osvers} < 8)
		  || ($^O eq 'darwin' && $Config{osvers} < '6.6');
	printf "%s 11 - masked SIGINT received %s\n",
	    $sigint_called ? "ok" : "not ok",
	    $todo ? $why_todo : '';

	print "ok 12 - signal masks successful\n";
	
	sub SigHUP {
	    print "ok 9 - sigaction SIGHUP\n";
	    kill 'INT', $$;
	    sleep 2;
	    print "ok 10 - sig mask delayed SIGINT\n";
	}

        sub SigINT {
            $sigint_called++;
	}

        # The order of the above tests is very important, so
        # we use literal prints and hard coded numbers.
        next_test() for 1..4;
    }
}

SKIP: {
    skip("_POSIX_OPEN_MAX undefined ($fds[1])",  1) unless &_POSIX_OPEN_MAX;

    cmp_ok(&_POSIX_OPEN_MAX, '>=', 16,
	   "The minimum allowed values according to susv2" );

}

my $pat;
if ( $unix_mode ) {
    $pat = qr#[\\/]POSIX$#i;
}
else {
    $pat = qr/\.POSIX]/i;
}
like( getcwd(), qr/$pat/, 'getcwd' );

# Check string conversion functions.

SKIP: { 
    skip("strtod() not present", 2) unless $Config{d_strtod};

    if (locales_enabled('LC_NUMERIC')) {
        $lc = &POSIX::setlocale(&POSIX::LC_NUMERIC);
        &POSIX::setlocale(&POSIX::LC_NUMERIC, 'C');
    }

    # we're just checking that strtod works, not how accurate it is
    ($n, $x) = &POSIX::strtod('3.14159_OR_SO');
    cmp_ok(abs("3.14159" - $n), '<', 1e-6, 'strtod works');
    is($x, 6, 'strtod works');

    &POSIX::setlocale(&POSIX::LC_NUMERIC, $lc) if locales_enabled('LC_NUMERIC');
}

SKIP: {
    skip("strtold() not present", 2) unless $Config{d_strtold};

    if (locales_enabled('LC_NUMERIC')) {
        $lc = &POSIX::setlocale(&POSIX::LC_NUMERIC);
        &POSIX::setlocale(&POSIX::LC_NUMERIC, 'C');
    }

    # we're just checking that strtold works, not how accurate it is
    ($n, $x) = &POSIX::strtod('2.718_ISH');
    cmp_ok(abs("2.718" - $n), '<', 1e-6, 'strtold works');
    is($x, 4, 'strtold works');

    &POSIX::setlocale(&POSIX::LC_NUMERIC, $lc) if locales_enabled('LC_NUMERIC');
}

SKIP: {
    skip("strtol() not present", 2) unless $Config{d_strtol};

    ($n, $x) = &POSIX::strtol('21_PENGUINS');
    is($n, 21, 'strtol() number');
    is($x, 9,  '         unparsed chars');
}

SKIP: {
    skip("strtoul() not present", 2) unless $Config{d_strtoul};

    ($n, $x) = &POSIX::strtoul('88_TEARS');
    is($n, 88, 'strtoul() number');
    is($x, 6,  '          unparsed chars');
}

# Pick up whether we're really able to dynamically load everything.
cmp_ok(&POSIX::acos(1.0), '==', 0.0, 'dynamic loading');

# This can coredump if struct tm has a timezone field and we
# didn't detect it.  If this fails, try adding
# -DSTRUCT_TM_HASZONE to your cflags when compiling ext/POSIX/POSIX.c.
# See ext/POSIX/hints/sunos_4.pl and ext/POSIX/hints/linux.pl 
$test = next_test();
print POSIX::strftime("ok $test # %H:%M, on %m/%d/%y\n", localtime());

# If that worked, validate the mini_mktime() routine's normalisation of
# input fields to strftime().
sub try_strftime {
    my $expect = shift;
    my $got = POSIX::strftime("%a %b %d %H:%M:%S %Y %j", @@_);
    is($got, $expect, "validating mini_mktime() and strftime(): $expect");
}

if (locales_enabled('LC_TIME')) {
    $lc = &POSIX::setlocale(&POSIX::LC_TIME);
    &POSIX::setlocale(&POSIX::LC_TIME, 'C');
}

try_strftime("Wed Feb 28 00:00:00 1996 059", 0,0,0, 28,1,96);
SKIP: {
    skip("VC++ 8 and Vista's CRTs regard 60 seconds as an invalid parameter", 1)
	if ($Is_W32
	    and (($Config{cc} eq 'cl' and
		    $Config{ccversion} =~ /^(\d+)/ and $1 >= 14)
		or ($Config{cc} eq 'icl' and
		    `cl --version 2>&1` =~ /^.*Version\s+([\d.]+)/ and $1 >= 14)
		or (Win32::GetOSVersion())[1] >= 6));

    try_strftime("Thu Feb 29 00:00:60 1996 060", 60,0,-24, 30,1,96);
}
try_strftime("Fri Mar 01 00:00:00 1996 061", 0,0,-24, 31,1,96);
try_strftime("Sun Feb 28 00:00:00 1999 059", 0,0,0, 28,1,99);
try_strftime("Mon Mar 01 00:00:00 1999 060", 0,0,24, 28,1,99);
try_strftime("Mon Feb 28 00:00:00 2000 059", 0,0,0, 28,1,100);
try_strftime("Tue Feb 29 00:00:00 2000 060", 0,0,0, 0,2,100);
try_strftime("Wed Mar 01 00:00:00 2000 061", 0,0,0, 1,2,100);
try_strftime("Fri Mar 31 00:00:00 2000 091", 0,0,0, 31,2,100);

{ # rt 72232

  # Std C/POSIX allows day/month to be negative and requires that
  # wday/yday be adjusted as needed
  # previously mini_mktime() would allow yday to dominate if mday and
  # month were both non-positive
  # check that yday doesn't dominate
  try_strftime("Thu Dec 30 00:00:00 1999 364", 0,0,0, -1,0,100);
  try_strftime("Thu Dec 30 00:00:00 1999 364", 0,0,0, -1,0,100,-1,10);
  # it would also allow a positive wday to override the calculated value
  # check that wday is recalculated too
  try_strftime("Thu Dec 30 00:00:00 1999 364", 0,0,0, -1,0,100,0,10);
}

&POSIX::setlocale(&POSIX::LC_TIME, $lc) if locales_enabled('LC_TIME');

{
    for my $test (0, 1) {
	$! = 0;
	# POSIX::errno is autoloaded. 
	# Autoloading requires many system calls.
	# errno() looks at $! to generate its result.
	# Autoloading should not munge the value.
	my $foo  = $!;
	my $errno = POSIX::errno();

        # Force numeric context.
	is( $errno + 0, $foo + 0,     'autoloading and errno() mix' );
    }
}

SKIP: {
  skip("no kill() support on Mac OS", 1) if $Is_MacOS;
  is (eval "kill 0", 0, "check we have CORE::kill")
    or print "\$\@@ is " . _qq($@@) . "\n";
}

# Check that we can import the POSIX kill routine
POSIX->import ('kill');
my $result = eval "kill 0";
is ($result, undef, "we should now have POSIX::kill");
# Check usage.
like ($@@, qr/^Usage: POSIX::kill\(pid, sig\)/, "check its usage message");

# Check unimplemented.
$result = eval {POSIX::offsetof};
is ($result, undef, "offsetof should fail");
like ($@@, qr/^Unimplemented: POSIX::offsetof\(\) is C-specific/,
      "check its unimplemented message");

# Check reimplemented.
$result = eval {POSIX::fgets};
is ($result, undef, "fgets should fail");
like ($@@, qr/^Use method IO::Handle::gets\(\) instead/,
      "check its redef message");

eval { use strict; POSIX->import("S_ISBLK"); my $x = S_ISBLK };
unlike( $@@, qr/Can't use string .* as a symbol ref/, "Can import autoloaded constants" );

SKIP: {
    skip("locales not available", 26) unless locales_enabled(qw(NUMERIC MONETARY));
    skip("localeconv() not available", 26) unless $Config{d_locconv};
    my $conv = localeconv;
    is(ref $conv, 'HASH', 'localconv returns a hash reference');

    foreach (qw(decimal_point thousands_sep grouping int_curr_symbol
		currency_symbol mon_decimal_point mon_thousands_sep
		mon_grouping positive_sign negative_sign)) {
    SKIP: {
	    skip("localeconv has no result for $_", 1)
		unless exists $conv->{$_};
	    unlike(delete $conv->{$_}, qr/\A\z/,
		   "localeconv returned a non-empty string for $_");
	}
    }

    my @@lconv = qw(
        int_frac_digits frac_digits
        p_cs_precedes   p_sep_by_space
        n_cs_precedes   n_sep_by_space
        p_sign_posn     n_sign_posn
    );

    SKIP: {
        skip('No HAS_LC_MONETARY_2008', 6) unless $Config{d_lc_monetary_2008};

        push @@lconv, qw(
            int_p_cs_precedes int_p_sep_by_space
            int_n_cs_precedes int_n_sep_by_space
            int_p_sign_posn   int_n_sign_posn
        );
    }

    foreach (@@lconv) {
    SKIP: {
	    skip("localeconv has no result for $_", 1)
		unless exists $conv->{$_};
	    like(delete $conv->{$_}, qr/\A-?\d+\z/,
		 "localeconv returned an integer for $_");
	}
    }
    is_deeply([%$conv], [], 'no unexpected keys returned by localeconv');
}

my $fd1 = open("Makefile.PL", O_RDONLY, 0);
like($fd1, qr/\A\d+\z/, 'O_RDONLY with open');
cmp_ok($fd1, '>', $testfd);
my $fd2 = dup($fd1);
like($fd2, qr/\A\d+\z/, 'dup');
cmp_ok($fd2, '>', $fd1);
is(POSIX::close($fd1), '0 but true', 'close');
is(POSIX::close($testfd), '0 but true', 'close');
$! = 0;
undef $buffer;
is(read($fd1, $buffer, 4), undef, 'read on closed file handle fails');
cmp_ok($!, '==', POSIX::EBADF);
undef $buffer;
read($fd2, $buffer, 4) if $fd2 > 2;
is($buffer, "# Ex", 'read');
# The descriptor $testfd was using is now free, and is lower than that which
# $fd1 was using. Hence if dup2() behaves as dup(), we'll know :-)
{
    $testfd = dup2($fd2, $fd1);
    is($testfd, $fd1, 'dup2');
    undef $buffer;
    read($testfd, $buffer, 4) if $testfd > 2;
    is($buffer, 'pect', 'read');
    is(lseek($testfd, 0, 0), 0, 'lseek back');
    # The two should share file position:
    undef $buffer;
    read($fd2, $buffer, 4) if $fd2 > 2;
    is($buffer, "# Ex", 'read');
}

# The FreeBSD man page warns:
# The access() system call is a potential security hole due to race
# conditions and should never be used.
is(access('Makefile.PL', POSIX::F_OK), '0 but true', 'access');
is(access('Makefile.PL', POSIX::R_OK), '0 but true', 'access');
$! = 0;
is(access('no such file', POSIX::F_OK), undef, 'access on missing file');
cmp_ok($!, '==', POSIX::ENOENT);
is(access('Makefile.PL/nonsense', POSIX::F_OK), undef,
   'access on not-a-directory');
SKIP: {
    skip("$^O is insufficiently POSIX", 1)
	if $Is_W32 || $Is_VMS;
    cmp_ok($!, '==', POSIX::ENOTDIR);
}

{   # tmpnam() is deprecated
    my @@warn;
    local $SIG{__WARN__} = sub { push @@warn, "@@_"; note "@@_"; };
    my $x = sub { POSIX::tmpnam() };
    my $foo = $x->();
    $foo = $x->();
    is(@@warn, 1, "POSIX::tmpnam() should warn only once per location");
    like($warn[0], qr!^Calling POSIX::tmpnam\(\) is deprecated at t/posix.t line \d+\.$!,
       "check POSIX::tmpnam warns by default");
    no warnings "deprecated";
    undef $warn;
    my $foo = POSIX::tmpnam();
    is($warn, undef, "... but the warning can be disabled");
}

# Check that output is not flushed by _exit. This test should be last
# in the file, and is not counted in the total number of tests.
if ($^O eq 'vos') {
 print "# TODO - hit VOS bug posix-885 - _exit flushes output buffers.\n";
} else {
 $| = 0;
 # The following line assumes buffered output, which may be not true:
 print '@@#!*$@@(!@@#$' unless ($Is_MacOS || $Is_OS2 || $Is_UWin || $Is_OS390 ||
                            $Is_VMS ||
			    (defined $ENV{PERLIO} &&
			     $ENV{PERLIO} eq 'unix' &&
			     $Config::Config{useperlio}));
 _exit(0);
}
@


1.6
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@d9 2
d13 1
a13 1
use Test::More tests => 115;
d167 1
a167 1
    if ($Config{d_setlocale}) {
d177 17
a193 1
    &POSIX::setlocale(&POSIX::LC_NUMERIC, $lc) if $Config{d_setlocale};
d230 1
a230 1
if ($Config{d_setlocale}) {
d269 1
a269 1
&POSIX::setlocale(&POSIX::LC_TIME, $lc) if $Config{d_setlocale};
a310 34
{
    no warnings 'deprecated';
    # Simplistic tests for the isXXX() functions (bug #16799)
    ok( POSIX::isalnum('1'),  'isalnum' );
    ok(!POSIX::isalnum('*'),  'isalnum' );
    ok( POSIX::isalpha('f'),  'isalpha' );
    ok(!POSIX::isalpha('7'),  'isalpha' );
    ok( POSIX::iscntrl("\cA"),'iscntrl' );
    ok(!POSIX::iscntrl("A"),  'iscntrl' );
    ok( POSIX::isdigit('1'),  'isdigit' );
    ok(!POSIX::isdigit('z'),  'isdigit' );
    ok( POSIX::isgraph('@@'),  'isgraph' );
    ok(!POSIX::isgraph(' '),  'isgraph' );
    ok( POSIX::islower('l'),  'islower' );
    ok(!POSIX::islower('L'),  'islower' );
    ok( POSIX::isupper('U'),  'isupper' );
    ok(!POSIX::isupper('u'),  'isupper' );
    ok( POSIX::isprint('$'),  'isprint' );
    ok(!POSIX::isprint("\n"), 'isprint' );
    ok( POSIX::ispunct('%'),  'ispunct' );
    ok(!POSIX::ispunct('u'),  'ispunct' );
    ok( POSIX::isspace("\t"), 'isspace' );
    ok(!POSIX::isspace('_'),  'isspace' );
    ok( POSIX::isxdigit('f'), 'isxdigit' );
    ok(!POSIX::isxdigit('g'), 'isxdigit' );
    # metaphysical question : what should be returned for an empty string ?
    # anyway this shouldn't segfault (bug #24554)
    ok( POSIX::isalnum(''),   'isalnum empty string' );
    ok( POSIX::isalnum(undef),'isalnum undef' );
    # those functions should stringify their arguments
    ok(!POSIX::isalpha([]),   'isalpha []' );
    ok( POSIX::isprint([]),   'isprint []' );
}

d315 2
a316 1
    skip("localeconv() not present", 20) unless $Config{d_locconv};
d347 1
a347 1
        
d403 15
@


1.5
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d11 1
a11 1
use Test::More tests => 109;
d346 18
a363 2
    foreach (qw(int_frac_digits frac_digits p_cs_precedes p_sep_by_space
		n_cs_precedes n_sep_by_space p_sign_posn n_sign_posn)) {
@


1.4
log
@Apply local patches to perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d11 1
a11 1
use Test::More tests => 115;
d346 2
a347 18
    my @@lconv = qw(
        int_frac_digits frac_digits
        p_cs_precedes   p_sep_by_space
        n_cs_precedes   n_sep_by_space
        p_sign_posn     n_sign_posn
    );

    SKIP: {
        skip('No HAS_LC_MONETARY_2008', 6) unless $Config{d_lc_monetary_2008};

        push @@lconv, qw(
            int_p_cs_precedes int_p_sep_by_space
            int_n_cs_precedes int_n_sep_by_space
            int_p_sign_posn   int_n_sign_posn
        );
    }
        
    foreach (@@lconv) {
@


1.3
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d11 1
a11 1
use Test::More tests => 109;
d346 18
a363 2
    foreach (qw(int_frac_digits frac_digits p_cs_precedes p_sep_by_space
		n_cs_precedes n_sep_by_space p_sign_posn n_sign_posn)) {
@


1.2
log
@international currency locale rules as per POSIX.1-2008

required for libc++

ok guenther afresh1
@
text
@d165 4
a168 1
    $lc = &POSIX::setlocale(&POSIX::LC_NUMERIC, 'C') if $Config{d_setlocale};
d212 5
a216 1
$lc = &POSIX::setlocale(&POSIX::LC_TIME, 'C') if $Config{d_setlocale};
d220 6
a225 3
	if ($Is_W32 and (($Config{cc} eq 'cl' and
	                 $Config{ccversion} =~ /^(\d+)/ and $1 >= 14) or
	                 (Win32::GetOSVersion())[1] >= 6));
d293 33
a325 30
# Simplistic tests for the isXXX() functions (bug #16799)
ok( POSIX::isalnum('1'),  'isalnum' );
ok(!POSIX::isalnum('*'),  'isalnum' );
ok( POSIX::isalpha('f'),  'isalpha' );
ok(!POSIX::isalpha('7'),  'isalpha' );
ok( POSIX::iscntrl("\cA"),'iscntrl' );
ok(!POSIX::iscntrl("A"),  'iscntrl' );
ok( POSIX::isdigit('1'),  'isdigit' );
ok(!POSIX::isdigit('z'),  'isdigit' );
ok( POSIX::isgraph('@@'),  'isgraph' );
ok(!POSIX::isgraph(' '),  'isgraph' );
ok( POSIX::islower('l'),  'islower' );
ok(!POSIX::islower('L'),  'islower' );
ok( POSIX::isupper('U'),  'isupper' );
ok(!POSIX::isupper('u'),  'isupper' );
ok( POSIX::isprint('$'),  'isprint' );
ok(!POSIX::isprint("\n"), 'isprint' );
ok( POSIX::ispunct('%'),  'ispunct' );
ok(!POSIX::ispunct('u'),  'ispunct' );
ok( POSIX::isspace("\t"), 'isspace' );
ok(!POSIX::isspace('_'),  'isspace' );
ok( POSIX::isxdigit('f'), 'isxdigit' );
ok(!POSIX::isxdigit('g'), 'isxdigit' );
# metaphysical question : what should be returned for an empty string ?
# anyway this shouldn't segfault (bug #24554)
ok( POSIX::isalnum(''),   'isalnum empty string' );
ok( POSIX::isalnum(undef),'isalnum undef' );
# those functions should stringify their arguments
ok(!POSIX::isalpha([]),   'isalpha []' );
ok( POSIX::isprint([]),   'isprint []' );
d347 1
a347 3
		n_cs_precedes n_sep_by_space p_sign_posn n_sign_posn
		int_p_cs_precedes int_p_sep_by_space int_n_cs_precedes
		int_n_sep_by_space int_p_sign_posn int_n_sign_posn)) {
@


1.1
log
@Initial revision
@
text
@a3 2
    chdir 't' if -d 't';
    @@INC = '../lib';
d11 1
a11 3
require "./test.pl";
plan(tests => 39);

d14 1
a14 1
	     errno);
d17 5
a25 1
$Is_MPE     = $^O eq 'mpeix';
d32 23
a54 1
ok( $testfd = open("TEST", O_RDONLY, 0),        'O_RDONLY with open' );
d56 1
a56 1
is( $buffer, "#!./",                      '    with read' );
d66 2
a67 2
write(1,"ok 4\nnot ok 4\n", 5);
next_test();
d73 1
a73 1
    ok( $fds[0] > $testfd,      'POSIX::pipe' );
d77 2
a78 1
    print $writer "ok 6\n";
a81 1
    next_test();
d101 15
a115 1
	kill 'HUP', $$;
d118 5
a122 4
        printf "%s 11 -   masked SIGINT received %s\n",
          $sigint_called ? "ok" : "not ok",
          $^O eq 'darwin' ? "# TODO Darwin seems to loose blocked signals" 
                          : '';
a143 1
    skip("_POSIX_OPEN_MAX is inaccurate on MPE", 1) if $Is_MPE;
d146 2
a147 1
    ok( &_POSIX_OPEN_MAX >= 16, "The minimum allowed values according to susv2" );
d152 2
a153 5
if ($Is_MacOS) {
    $pat = qr/:t:$/;
} 
elsif ( $Is_VMS ) {
    $pat = qr/\.T]/i;
d156 1
a156 1
    $pat = qr#[\\/]t$#i;
d163 1
a163 1
    skip("strtod() not present", 1) unless $Config{d_strtod};
d169 2
a170 1
    ok((abs("3.14159" - $n) < 1e-6) && ($x == 6), 'strtod works');
d192 1
a192 1
ok( &POSIX::acos(1.0) == 0.0,   'dynamic loading' );
d198 2
a199 2
print POSIX::strftime("ok 21 # %H:%M, on %D\n", localtime());
next_test();
d211 8
a218 1
try_strftime("Thu Feb 29 00:00:60 1996 060", 60,0,-24, 30,1,96);
d226 15
d282 110
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d14 2
a15 1
plan(tests => 61);
d79 1
a79 14

	# At least OpenBSD/i386 3.3 is okay, as is NetBSD 1.5.
	# But not NetBSD 1.6 & 1.6.1: the test makes perl crash.
	# So the kill() must not be done with this config in order to
	# finish the test.
	# For others (darwin & freebsd), let the test fail without crashing.
	my $todo = $^O eq 'netbsd' && $Config{osvers}=~/^1\.6/;
	my $why_todo = "# TODO $^O $Config{osvers} seems to loose blocked signals";
	if (!$todo) { 
	  kill 'HUP', $$; 
	} else {
	  print "not ok 9 - sigaction SIGHUP ",$why_todo,"\n";
	  print "not ok 10 - sig mask delayed SIGINT ",$why_todo,"\n";
	}
d82 4
a85 5
	$todo = 1 if ($^O eq 'freebsd')
		  || ($^O eq 'darwin' && $Config{osvers} lt '6.6');
	printf "%s 11 - masked SIGINT received %s\n",
	    $sigint_called ? "ok" : "not ok",
	    $todo ? $why_todo : '';
a225 24
# Simplistic tests for the isXXX() functions (bug #16799)
ok( POSIX::isalnum('1'),  'isalnum' );
ok(!POSIX::isalnum('*'),  'isalnum' );
ok( POSIX::isalpha('f'),  'isalpha' );
ok(!POSIX::isalpha('7'),  'isalpha' );
ok( POSIX::iscntrl("\cA"),'iscntrl' );
ok(!POSIX::iscntrl("A"),  'iscntrl' );
ok( POSIX::isdigit('1'),  'isdigit' );
ok(!POSIX::isdigit('z'),  'isdigit' );
ok( POSIX::isgraph('@@'),  'isgraph' );
ok(!POSIX::isgraph(' '),  'isgraph' );
ok( POSIX::islower('l'),  'islower' );
ok(!POSIX::islower('L'),  'islower' );
ok( POSIX::isupper('U'),  'isupper' );
ok(!POSIX::isupper('u'),  'isupper' );
ok( POSIX::isprint('$'),  'isprint' );
ok(!POSIX::isprint("\n"), 'isprint' );
ok( POSIX::ispunct('%'),  'ispunct' );
ok(!POSIX::ispunct('u'),  'ispunct' );
ok( POSIX::isspace("\t"), 'isspace' );
ok(!POSIX::isspace('_'),  'isspace' );
ok( POSIX::isxdigit('f'), 'isxdigit' );
ok(!POSIX::isxdigit('g'), 'isxdigit' );
 
@


1.1.1.3
log
@perl 5.8.3 from CPAN
@
text
@d14 1
a14 1
plan(tests => 65);
a261 7
# metaphysical question : what should be returned for an empty string ?
# anyway this shouldn't segfault (bug #24554)
ok( POSIX::isalnum(''),   'isalnum empty string' );
ok( POSIX::isalnum(undef),'isalnum undef' );
# those functions should stringify their arguments
ok(!POSIX::isalpha([]),   'isalpha []' );
ok( POSIX::isprint([]),   'isprint []' );
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d13 2
a14 2
BEGIN { require "./test.pl"; }
plan(tests => 66);
d85 1
a85 1
	my $why_todo = "# TODO $^O $Config{osvers} seems to lose blocked signals";
d176 1
a176 1
print POSIX::strftime("ok 21 # %H:%M, on %m/%d/%y\n", localtime());
d189 1
a189 8
SKIP: {
    skip("VC++ 8 and Vista's CRTs regard 60 seconds as an invalid parameter", 1)
	if ($Is_W32 and (($Config{cc} eq 'cl' and
	                 $Config{ccversion} =~ /^(\d+)/ and $1 >= 14) or
	                 (Win32::GetOSVersion())[1] >= 6));

    try_strftime("Thu Feb 29 00:00:60 1996 060", 60,0,-24, 30,1,96);
}
a268 3

eval { use strict; POSIX->import("S_ISBLK"); my $x = S_ISBLK };
unlike( $@@, qr/Can't use string .* as a symbol ref/, "Can import autoloaded constants" );
@


1.1.1.5
log
@import perl 5.10.1
@
text
@a30 22
my $vms_unix_rpt = 0;
my $vms_efs = 0;
my $unix_mode = 1;

if ($Is_VMS) {
    $unix_mode = 0;
    if (eval 'require VMS::Feature') {
        $vms_unix_rpt = VMS::Feature::current("filename_unix_report");
        $vms_efs = VMS::Feature::current("efs_charset");
    } else {
        my $unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
        my $efs_charset = $ENV{'DECC$EFS_CHARSET'} || '';
        $vms_unix_rpt = $unix_rpt =~ /^[ET1]/i;
        $vms_efs = $efs_charset =~ /^[ET1]/i;
    }

    # Traditional VMS mode only if VMS is not in UNIX compatible mode.
    $unix_mode = ($vms_efs && $vms_unix_rpt);

}


d131 2
a132 2
elsif ( $unix_mode ) {
    $pat = qr#[\\/]t$#i;
d135 1
a135 1
    $pat = qr/\.T]/i;
@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@d4 2
d13 1
a13 1
BEGIN { require "../../t/test.pl"; }
d53 1
a53 1
ok( $testfd = open("Makefile.PL", O_RDONLY, 0),        'O_RDONLY with open' );
d55 1
a55 1
is( $buffer, "# Ex",                      '    with read' );
d150 5
a154 2
if ( $unix_mode ) {
    $pat = qr#[\\/]POSIX$#i;
d157 1
a157 1
    $pat = qr/\.POSIX]/i;
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d11 2
a12 1
use Test::More tests => 106;
d15 1
a15 1
	     errno localeconv dup dup2 lseek access);
a17 5
sub next_test {
    my $builder = Test::More->builder;
    $builder->current_test($builder->current_test() + 1);
}

d50 2
a51 2
my $testfd = open("Makefile.PL", O_RDONLY, 0);
like($testfd, qr/\A\d+\z/, 'O_RDONLY with open');
d63 2
a64 2
my $test = next_test();
write(1,"ok $test\nnot ok $test\n", 5);
d70 1
a70 1
    cmp_ok($fds[0], '>', $testfd, 'POSIX::pipe');
d74 1
a74 2
    my $test = next_test();
    print $writer "ok $test\n";
d78 1
d115 1
a115 1
		  || ($^O eq 'darwin' && $Config{osvers} < '6.6');
d143 1
a143 2
    cmp_ok(&_POSIX_OPEN_MAX, '>=', 16,
	   "The minimum allowed values according to susv2" );
d159 1
a159 1
    skip("strtod() not present", 2) unless $Config{d_strtod};
d165 1
a165 2
    cmp_ok(abs("3.14159" - $n), '<', 1e-6, 'strtod works');
    is($x, 6, 'strtod works');
d187 1
a187 1
cmp_ok(&POSIX::acos(1.0), '==', 0.0, 'dynamic loading');
d193 2
a194 2
$test = next_test();
print POSIX::strftime("ok $test # %H:%M, on %m/%d/%y\n", localtime());
d296 1
a296 75

SKIP: {
    skip("localeconv() not present", 20) unless $Config{d_locconv};
    my $conv = localeconv;
    is(ref $conv, 'HASH', 'localconv returns a hash reference');

    foreach (qw(decimal_point thousands_sep grouping int_curr_symbol
		currency_symbol mon_decimal_point mon_thousands_sep
		mon_grouping positive_sign negative_sign)) {
    SKIP: {
	    skip("localeconv has no result for $_", 1)
		unless exists $conv->{$_};
	    unlike(delete $conv->{$_}, qr/\A\z/,
		   "localeconv returned a non-empty string for $_");
	}
    }

    foreach (qw(int_frac_digits frac_digits p_cs_precedes p_sep_by_space
		n_cs_precedes n_sep_by_space p_sign_posn n_sign_posn)) {
    SKIP: {
	    skip("localeconv has no result for $_", 1)
		unless exists $conv->{$_};
	    like(delete $conv->{$_}, qr/\A-?\d+\z/,
		 "localeconv returned an integer for $_");
	}
    }
    is_deeply([%$conv], [], 'no unexpected keys returned by localeconv');
}

my $fd1 = open("Makefile.PL", O_RDONLY, 0);
like($fd1, qr/\A\d+\z/, 'O_RDONLY with open');
cmp_ok($fd1, '>', $testfd);
my $fd2 = dup($fd1);
like($fd2, qr/\A\d+\z/, 'dup');
cmp_ok($fd2, '>', $fd1);
is(POSIX::close($fd1), '0 but true', 'close');
is(POSIX::close($testfd), '0 but true', 'close');
$! = 0;
undef $buffer;
is(read($fd1, $buffer, 4), undef, 'read on closed file handle fails');
cmp_ok($!, '==', POSIX::EBADF);
undef $buffer;
read($fd2, $buffer, 4) if $fd2 > 2;
is($buffer, "# Ex", 'read');
# The descriptor $testfd was using is now free, and is lower than that which
# $fd1 was using. Hence if dup2() behaves as dup(), we'll know :-)
{
    $testfd = dup2($fd2, $fd1);
    is($testfd, $fd1, 'dup2');
    undef $buffer;
    read($testfd, $buffer, 4) if $testfd > 2;
    is($buffer, 'pect', 'read');
    is(lseek($testfd, 0, 0), 0, 'lseek back');
    # The two should share file position:
    undef $buffer;
    read($fd2, $buffer, 4) if $fd2 > 2;
    is($buffer, "# Ex", 'read');
}

# The FreeBSD man page warns:
# The access() system call is a potential security hole due to race
# conditions and should never be used.
is(access('Makefile.PL', POSIX::F_OK), '0 but true', 'access');
is(access('Makefile.PL', POSIX::R_OK), '0 but true', 'access');
$! = 0;
is(access('no such file', POSIX::F_OK), undef, 'access on missing file');
cmp_ok($!, '==', POSIX::ENOENT);
is(access('Makefile.PL/nonsense', POSIX::F_OK), undef,
   'access on not-a-directory');
SKIP: {
    skip("$^O is insufficiently POSIX", 1)
	if $Is_W32 || $Is_VMS;
    cmp_ok($!, '==', POSIX::ENOTDIR);
}

@


1.1.1.8
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d11 1
a11 1
use Test::More tests => 109;
d26 1
a107 1
	# the test passes at least from freebsd 8.1
d118 1
a118 1
	$todo = 1 if ($^O eq 'freebsd' && $Config{osvers} < 8)
d144 1
a226 15

{ # rt 72232

  # Std C/POSIX allows day/month to be negative and requires that
  # wday/yday be adjusted as needed
  # previously mini_mktime() would allow yday to dominate if mday and
  # month were both non-positive
  # check that yday doesn't dominate
  try_strftime("Thu Dec 30 00:00:00 1999 364", 0,0,0, -1,0,100);
  try_strftime("Thu Dec 30 00:00:00 1999 364", 0,0,0, -1,0,100,-1,10);
  # it would also allow a positive wday to override the calculated value
  # check that wday is recalculated too
  try_strftime("Thu Dec 30 00:00:00 1999 364", 0,0,0, -1,0,100,0,10);
}

@


1.1.1.9
log
@Import perl-5.20.1
@
text
@d165 1
a165 4
    if ($Config{d_setlocale}) {
        $lc = &POSIX::setlocale(&POSIX::LC_NUMERIC);
        &POSIX::setlocale(&POSIX::LC_NUMERIC, 'C');
    }
d209 1
a209 5
if ($Config{d_setlocale}) {
    $lc = &POSIX::setlocale(&POSIX::LC_TIME);
    &POSIX::setlocale(&POSIX::LC_TIME, 'C');
}

d213 3
a215 6
	if ($Is_W32
	    and (($Config{cc} eq 'cl' and
		    $Config{ccversion} =~ /^(\d+)/ and $1 >= 14)
		or ($Config{cc} eq 'icl' and
		    `cl --version 2>&1` =~ /^.*Version\s+([\d.]+)/ and $1 >= 14)
		or (Win32::GetOSVersion())[1] >= 6));
d283 30
a312 33
{
    no warnings 'deprecated';
    # Simplistic tests for the isXXX() functions (bug #16799)
    ok( POSIX::isalnum('1'),  'isalnum' );
    ok(!POSIX::isalnum('*'),  'isalnum' );
    ok( POSIX::isalpha('f'),  'isalpha' );
    ok(!POSIX::isalpha('7'),  'isalpha' );
    ok( POSIX::iscntrl("\cA"),'iscntrl' );
    ok(!POSIX::iscntrl("A"),  'iscntrl' );
    ok( POSIX::isdigit('1'),  'isdigit' );
    ok(!POSIX::isdigit('z'),  'isdigit' );
    ok( POSIX::isgraph('@@'),  'isgraph' );
    ok(!POSIX::isgraph(' '),  'isgraph' );
    ok( POSIX::islower('l'),  'islower' );
    ok(!POSIX::islower('L'),  'islower' );
    ok( POSIX::isupper('U'),  'isupper' );
    ok(!POSIX::isupper('u'),  'isupper' );
    ok( POSIX::isprint('$'),  'isprint' );
    ok(!POSIX::isprint("\n"), 'isprint' );
    ok( POSIX::ispunct('%'),  'ispunct' );
    ok(!POSIX::ispunct('u'),  'ispunct' );
    ok( POSIX::isspace("\t"), 'isspace' );
    ok(!POSIX::isspace('_'),  'isspace' );
    ok( POSIX::isxdigit('f'), 'isxdigit' );
    ok(!POSIX::isxdigit('g'), 'isxdigit' );
    # metaphysical question : what should be returned for an empty string ?
    # anyway this shouldn't segfault (bug #24554)
    ok( POSIX::isalnum(''),   'isalnum empty string' );
    ok( POSIX::isalnum(undef),'isalnum undef' );
    # those functions should stringify their arguments
    ok(!POSIX::isalpha([]),   'isalpha []' );
    ok( POSIX::isprint([]),   'isprint []' );
}
@


1.1.1.10
log
@Import perl-5.24.2
@
text
@a8 2
    unshift @@INC, "../../t";
    require 'loc_tools.pl';
d11 1
a11 1
use Test::More tests => 94;
d165 1
a165 1
    if (locales_enabled('LC_NUMERIC')) {
d175 1
a175 17
    &POSIX::setlocale(&POSIX::LC_NUMERIC, $lc) if locales_enabled('LC_NUMERIC');
}

SKIP: {
    skip("strtold() not present", 2) unless $Config{d_strtold};

    if (locales_enabled('LC_NUMERIC')) {
        $lc = &POSIX::setlocale(&POSIX::LC_NUMERIC);
        &POSIX::setlocale(&POSIX::LC_NUMERIC, 'C');
    }

    # we're just checking that strtold works, not how accurate it is
    ($n, $x) = &POSIX::strtod('2.718_ISH');
    cmp_ok(abs("2.718" - $n), '<', 1e-6, 'strtold works');
    is($x, 4, 'strtold works');

    &POSIX::setlocale(&POSIX::LC_NUMERIC, $lc) if locales_enabled('LC_NUMERIC');
d212 1
a212 1
if (locales_enabled('LC_TIME')) {
d251 1
a251 1
&POSIX::setlocale(&POSIX::LC_TIME, $lc) if locales_enabled('LC_TIME');
d293 34
d331 1
a331 2
    skip("locales not available", 26) unless locales_enabled(qw(NUMERIC MONETARY));
    skip("localeconv() not available", 26) unless $Config{d_locconv};
d346 2
a347 18
    my @@lconv = qw(
        int_frac_digits frac_digits
        p_cs_precedes   p_sep_by_space
        n_cs_precedes   n_sep_by_space
        p_sign_posn     n_sign_posn
    );

    SKIP: {
        skip('No HAS_LC_MONETARY_2008', 6) unless $Config{d_lc_monetary_2008};

        push @@lconv, qw(
            int_p_cs_precedes int_p_sep_by_space
            int_n_cs_precedes int_n_sep_by_space
            int_p_sign_posn   int_n_sign_posn
        );
    }

    foreach (@@lconv) {
a401 15
}

{   # tmpnam() is deprecated
    my @@warn;
    local $SIG{__WARN__} = sub { push @@warn, "@@_"; note "@@_"; };
    my $x = sub { POSIX::tmpnam() };
    my $foo = $x->();
    $foo = $x->();
    is(@@warn, 1, "POSIX::tmpnam() should warn only once per location");
    like($warn[0], qr!^Calling POSIX::tmpnam\(\) is deprecated at t/posix.t line \d+\.$!,
       "check POSIX::tmpnam warns by default");
    no warnings "deprecated";
    undef $warn;
    my $foo = POSIX::tmpnam();
    is($warn, undef, "... but the warning can be disabled");
@


