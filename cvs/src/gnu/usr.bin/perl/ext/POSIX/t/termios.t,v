head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.3
	PERL_5_24_2:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.18
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.16
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.10
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.12
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.4
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.8
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.3.0.6
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.2
	OPENBSD_5_4_BASE:1.1.1.3
	PERL_5_16_3:1.1.1.3
	OPENBSD_5_3:1.1.1.2.0.10
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.8
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.6
	OPENBSD_5_0:1.1.1.2.0.4
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.8
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.4
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2008.09.29.17.18.23;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.29.17.18.23;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.09.24.14.48.52;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.03.25.20.08.46;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!perl -T

BEGIN {
    if ($ENV{PERL_CORE}) {
        chdir 't';
        @@INC = '../lib';
    }

    use Config;
    use Test::More;
    plan skip_all => "POSIX is unavailable" 
        if $Config{'extensions'} !~ m!\bPOSIX\b!;
}
use strict;
use POSIX;
BEGIN {
    plan skip_all => "POSIX::Termios not implemented" 
        if  !eval "POSIX::Termios->new;1"
        and $@@=~/not implemented/;
}


my @@getters = qw(getcflag getiflag getispeed getlflag getoflag getospeed);

plan tests => 3 + 2 * (3 + NCCS() + @@getters);

my $r;

# create a new object
my $termios = eval { POSIX::Termios->new };
is( $@@, '', "calling POSIX::Termios->new" );
ok( defined $termios, "\tchecking if the object is defined" );
isa_ok( $termios, "POSIX::Termios", "\tchecking the type of the object" );

# testing getattr()

SKIP: {
    -t STDIN or skip("STDIN not a tty", 2);
    $r = eval { $termios->getattr(0) };
    is( $@@, '', "calling getattr(0)" );
    ok( defined $r, "\tchecking if the returned value is defined: $r" );
}

SKIP: {
    -t STDOUT or skip("STDOUT not a tty", 2);
    $r = eval { $termios->getattr(1) };
    is( $@@, '', "calling getattr(1)" );
    ok( defined $r, "\tchecking if the returned value is defined: $r" );
}

SKIP: {
    -t STDERR or skip("STDERR not a tty", 2);
    $r = eval { $termios->getattr(2) };
    is( $@@, '', "calling getattr(2)" );
    ok( defined $r, "\tchecking if the returned value is defined: $r" );
}

# testing getcc()
for my $i (0..NCCS()-1) {
    $r = eval { $termios->getcc($i) };
    is( $@@, '', "calling getcc($i)" );
    ok( defined $r, "\tchecking if the returned value is defined: $r" );
}

# testing getcflag()
for my $method (@@getters) {
    $r = eval { $termios->$method() };
    is( $@@, '', "calling $method()" );
    ok( defined $r, "\tchecking if the returned value is defined: $r" );
}

@


1.1.1.1
log
@import perl 5.10.0 from CPAN
@
text
@@


1.1.1.2
log
@Perl 5.12.2 from CPAN
@
text
@d4 5
@


1.1.1.3
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d1 1
a1 1
#!perl -Tw
d3 6
d10 13
a22 2
use Config;
use Test::More;
d24 13
a36 3
BEGIN {
    plan skip_all => "POSIX is unavailable"
	if $Config{extensions} !~ m!\bPOSIX\b!;
d39 6
a44 1
use POSIX ':termios_h';
d46 6
a51 2
plan skip_all => $@@
    if !eval "POSIX::Termios->new; 1" && $@@ =~ /termios not implemented/;
d53 6
d60 6
a65 160
# A termios struct that we've successfully read from a terminal device:
my $termios;

foreach (undef, qw(STDIN STDOUT STDERR)) {
 SKIP:
    {
	my ($name, $handle);
	if (defined $_) {
	    $name = $_;
	    $handle = $::{$name};
	} else {
	    $name = POSIX::ctermid();
	    skip("Can't get name of controlling terminal", 4)
		unless defined $name;
	    open $handle, '<', $name or skip("can't open $name: $!", 4);
	}

	skip("$name not a tty", 4) unless -t $handle;

	my $t = eval { POSIX::Termios->new };
	is($@@, '', "calling POSIX::Termios->new");
	isa_ok($t, "POSIX::Termios", "checking the type of the object");

	my $fileno = fileno $handle;
	my $r = eval { $t->getattr($fileno) };
	is($@@, '', "calling getattr($fileno) for $name");
	if(isnt($r, undef, "returned value ($r) is defined")) {
	    $termios = $t;
	}
    }
}

open my $not_a_tty, '<', $^X or die "Can't open $^X: $!";

if (defined $termios) {
    # testing getcc()
    for my $i (0 .. NCCS-1) {
	my $r = eval { $termios->getcc($i) };
	is($@@, '', "calling getcc($i)");
	like($r, qr/\A-?[0-9]+\z/, 'returns an integer');
    }
    for my $i (NCCS, ~0) {
	my $r = eval { $termios->getcc($i) };
	like($@@, qr/\ABad getcc subscript/, "calling getcc($i)");
	is($r, undef, 'returns undef')
    }

    for my $method (qw(getcflag getiflag getispeed getlflag getoflag getospeed)) {
	my $r = eval { $termios->$method() };
	is($@@, '', "calling $method()");
	like($r, qr/\A-?[0-9]+\z/, 'returns an integer');
    }

    $! = 0;
    is($termios->setattr(fileno $not_a_tty), undef,
       'setattr on a non tty should fail');
    cmp_ok($!, '==', POSIX::ENOTTY, 'and set errno to ENOTTY');

    $! = 0;
    is($termios->setattr(fileno $not_a_tty, TCSANOW), undef,
       'setattr on a non tty should fail');
    cmp_ok($!, '==', POSIX::ENOTTY, 'and set errno to ENOTTY');
}

{
    my $t = POSIX::Termios->new();
    isa_ok($t, "POSIX::Termios", "checking the type of the object");

    # B0 is special
    my @@baud = (B50, B75, B110, B134, B150, B200, B300, B600, B1200, B1800,
		B2400, B4800, B9600, B19200, B38400);

    # On some platforms (eg Linux-that-I-tested), ispeed and ospeed are both
    # "stored" in the same bits of c_cflag (as the man page documents)
    # *as well as in struct members* (which you would assume obviates the need
    # for using c_cflag), and the get*() functions return the value encoded
    # within c_cflag, hence it's not possible to set/get them independently.
    foreach my $out (@@baud) {
	is($t->setispeed(0), '0 but true', "setispeed(0)");
	is($t->setospeed($out), '0 but true', "setospeed($out)");
	is($t->getospeed(), $out, "getospeed() for $out");
    }
    foreach my $in (@@baud) {
	is($t->setospeed(0), '0 but true', "setospeed(0)");
	is($t->setispeed($in), '0 but true', "setispeed($in)");
	is($t->getispeed(), $in, "getispeed() for $in");
    }

    my %state;
    my @@flags = qw(iflag oflag cflag lflag);
    # I'd prefer to use real values per flag, but can only find OPOST in
    # POSIX.pm for oflag
    my @@values = (0, 6, 9, 42);

    # initialise everything
    foreach (@@flags) {
	my $method = 'set' . $_;
	$t->$method(0);
	$state{$_} = 0;
    }

    sub testflags {
	my ($flag, $values, @@rest) = @@_;
	$! = 0;
	my $method = 'set' . $flag;
	foreach (@@$values) {
	    $t->$method($_);
	    $state{$flag} = $_;

	    my $state = join ', ', map {"$_=$state{$_}"} keys %state;
	    while (my ($flag, $expect) = each %state) {
		my $method = 'get' . $flag;
		is($t->$method(), $expect, "$method() for $state");
	    }

	    testflags(@@rest) if @@rest;
	}
    }

    testflags(map {($_, \@@values)} @@flags);

    for my $i (0 .. NCCS-1) {
	$t->setcc($i, 0);
    }
    for my $i (0 .. NCCS-1) {
	is($t->getcc($i), 0, "getcc($i)");
    }
    my $c = 0;
    for my $i (0 .. NCCS-1) {
	$t->setcc($i, ++$c);
    }
    for my $i (reverse 0 .. NCCS-1) {
	is($t->getcc($i), $c--, "getcc($i)");
    }
    for my $i (reverse 0 .. NCCS-1) {
	$t->setcc($i, ++$c);
    }
    for my $i (0 .. NCCS-1) {
	is($t->getcc($i), $c--, "getcc($i)");
    }

}

$! = 0;
is(tcdrain(fileno $not_a_tty), undef, 'tcdrain on a non tty should fail');
cmp_ok($!, '==', POSIX::ENOTTY, 'and set errno to ENOTTY');

$! = 0;
is(tcflow(fileno $not_a_tty, TCOON), undef, 'tcflow on a non tty should fail');
cmp_ok($!, '==', POSIX::ENOTTY, 'and set errno to ENOTTY');

$! = 0;
is(tcflush(fileno $not_a_tty, TCOFLUSH), undef,
   'tcflush on a non tty should fail');
cmp_ok($!, '==', POSIX::ENOTTY, 'and set errno to ENOTTY');

$! = 0;
is(tcsendbreak(fileno $not_a_tty, 0), undef,
   'tcsendbreak on a non tty should fail');
cmp_ok($!, '==', POSIX::ENOTTY, 'and set errno to ENOTTY');
a66 1
done_testing();
@


