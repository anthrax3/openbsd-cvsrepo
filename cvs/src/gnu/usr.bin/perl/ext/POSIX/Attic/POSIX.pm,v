head	1.14;
access;
symbols
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.14
date	2013.03.25.20.40.54;	author sthen;	state dead;
branches;
next	1.13;

1.13
date	2010.09.24.15.06.57;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.33;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.36.05;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.23.03;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.09.20;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.03;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.32;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.23;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.14;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.05.28;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.33;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.55.39;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.08;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.08;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.38.53;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.18;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.55;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.52;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.07;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.46.25;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.48.19;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.23;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.11.12;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.51;	author millert;	state Exp;
branches;
next	;


desc
@@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@package POSIX;
use strict;
use warnings;

our(@@ISA, %EXPORT_TAGS, @@EXPORT_OK, @@EXPORT, $AUTOLOAD, %SIGRT) = ();

our $VERSION = "1.19";

use AutoLoader;

use XSLoader ();

use Fcntl qw(FD_CLOEXEC F_DUPFD F_GETFD F_GETFL F_GETLK F_RDLCK F_SETFD
	     F_SETFL F_SETLK F_SETLKW F_UNLCK F_WRLCK O_ACCMODE O_APPEND
	     O_CREAT O_EXCL O_NOCTTY O_NONBLOCK O_RDONLY O_RDWR O_TRUNC
	     O_WRONLY SEEK_CUR SEEK_END SEEK_SET
	     S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG
	     S_IRGRP S_IROTH S_IRUSR S_IRWXG S_IRWXO S_IRWXU S_ISGID S_ISUID
	     S_IWGRP S_IWOTH S_IWUSR S_IXGRP S_IXOTH S_IXUSR);

# Grandfather old foo_h form to new :foo_h form
my $loaded;

sub import {
    load_imports() unless $loaded++;
    my $this = shift;
    my @@list = map { m/^\w+_h$/ ? ":$_" : $_ } @@_;
    local $Exporter::ExportLevel = 1;
    Exporter::import($this,@@list);
}

sub croak { require Carp;  goto &Carp::croak }
# declare usage to assist AutoLoad
sub usage;

XSLoader::load 'POSIX', $VERSION;

sub AUTOLOAD {
    no strict;
    no warnings 'uninitialized';
    if ($AUTOLOAD =~ /::(_?[a-z])/) {
	# require AutoLoader;
	$AutoLoader::AUTOLOAD = $AUTOLOAD;
	goto &AutoLoader::AUTOLOAD
    }
    local $! = 0;
    my $constname = $AUTOLOAD;
    $constname =~ s/.*:://;
    my ($error, $val) = constant($constname);
    croak $error if $error;
    *$AUTOLOAD = sub { $val };

    goto &$AUTOLOAD;
}

package POSIX::SigAction;

use AutoLoader 'AUTOLOAD';

package POSIX::SigRt;

use AutoLoader 'AUTOLOAD';

use Tie::Hash;

use vars qw($SIGACTION_FLAGS $_SIGRTMIN $_SIGRTMAX $_sigrtn @@ISA);
@@POSIX::SigRt::ISA = qw(Tie::StdHash);

$SIGACTION_FLAGS = 0;

tie %POSIX::SIGRT, 'POSIX::SigRt';

sub DESTROY {};

package POSIX;

1;
__END__

sub usage {
    my ($mess) = @@_;
    croak "Usage: POSIX::$mess";
}

sub redef {
    my ($mess) = @@_;
    croak "Use method $mess instead";
}

sub unimpl {
    my ($mess) = @@_;
    $mess =~ s/xxx//;
    croak "Unimplemented: POSIX::$mess";
}

sub assert {
    usage "assert(expr)" if @@_ != 1;
    if (!$_[0]) {
	croak "Assertion failed";
    }
}

sub tolower {
    usage "tolower(string)" if @@_ != 1;
    lc($_[0]);
}

sub toupper {
    usage "toupper(string)" if @@_ != 1;
    uc($_[0]);
}

sub closedir {
    usage "closedir(dirhandle)" if @@_ != 1;
    CORE::closedir($_[0]);
}

sub opendir {
    usage "opendir(directory)" if @@_ != 1;
    my $dirhandle;
    CORE::opendir($dirhandle, $_[0])
	? $dirhandle
	: undef;
}

sub readdir {
    usage "readdir(dirhandle)" if @@_ != 1;
    CORE::readdir($_[0]);
}

sub rewinddir {
    usage "rewinddir(dirhandle)" if @@_ != 1;
    CORE::rewinddir($_[0]);
}

sub errno {
    usage "errno()" if @@_ != 0;
    $! + 0;
}

sub creat {
    usage "creat(filename, mode)" if @@_ != 2;
    &open($_[0], &O_WRONLY | &O_CREAT | &O_TRUNC, $_[1]);
}

sub fcntl {
    usage "fcntl(filehandle, cmd, arg)" if @@_ != 3;
    CORE::fcntl($_[0], $_[1], $_[2]);
}

sub getgrgid {
    usage "getgrgid(gid)" if @@_ != 1;
    CORE::getgrgid($_[0]);
}

sub getgrnam {
    usage "getgrnam(name)" if @@_ != 1;
    CORE::getgrnam($_[0]);
}

sub atan2 {
    usage "atan2(x,y)" if @@_ != 2;
    CORE::atan2($_[0], $_[1]);
}

sub cos {
    usage "cos(x)" if @@_ != 1;
    CORE::cos($_[0]);
}

sub exp {
    usage "exp(x)" if @@_ != 1;
    CORE::exp($_[0]);
}

sub fabs {
    usage "fabs(x)" if @@_ != 1;
    CORE::abs($_[0]);
}

sub log {
    usage "log(x)" if @@_ != 1;
    CORE::log($_[0]);
}

sub pow {
    usage "pow(x,exponent)" if @@_ != 2;
    $_[0] ** $_[1];
}

sub sin {
    usage "sin(x)" if @@_ != 1;
    CORE::sin($_[0]);
}

sub sqrt {
    usage "sqrt(x)" if @@_ != 1;
    CORE::sqrt($_[0]);
}

sub getpwnam {
    usage "getpwnam(name)" if @@_ != 1;
    CORE::getpwnam($_[0]);
}

sub getpwuid {
    usage "getpwuid(uid)" if @@_ != 1;
    CORE::getpwuid($_[0]);
}

sub longjmp {
    unimpl "longjmp() is C-specific: use die instead";
}

sub setjmp {
    unimpl "setjmp() is C-specific: use eval {} instead";
}

sub siglongjmp {
    unimpl "siglongjmp() is C-specific: use die instead";
}

sub sigsetjmp {
    unimpl "sigsetjmp() is C-specific: use eval {} instead";
}

sub kill {
    usage "kill(pid, sig)" if @@_ != 2;
    CORE::kill $_[1], $_[0];
}

sub raise {
    usage "raise(sig)" if @@_ != 1;
    CORE::kill $_[0], $$;	# Is this good enough?
}

sub offsetof {
    unimpl "offsetof() is C-specific, stopped";
}

sub clearerr {
    redef "IO::Handle::clearerr()";
}

sub fclose {
    redef "IO::Handle::close()";
}

sub fdopen {
    redef "IO::Handle::new_from_fd()";
}

sub feof {
    redef "IO::Handle::eof()";
}

sub fgetc {
    redef "IO::Handle::getc()";
}

sub fgets {
    redef "IO::Handle::gets()";
}

sub fileno {
    redef "IO::Handle::fileno()";
}

sub fopen {
    redef "IO::File::open()";
}

sub fprintf {
    unimpl "fprintf() is C-specific--use printf instead";
}

sub fputc {
    unimpl "fputc() is C-specific--use print instead";
}

sub fputs {
    unimpl "fputs() is C-specific--use print instead";
}

sub fread {
    unimpl "fread() is C-specific--use read instead";
}

sub freopen {
    unimpl "freopen() is C-specific--use open instead";
}

sub fscanf {
    unimpl "fscanf() is C-specific--use <> and regular expressions instead";
}

sub fseek {
    redef "IO::Seekable::seek()";
}

sub fsync {
    redef "IO::Handle::sync()";
}

sub ferror {
    redef "IO::Handle::error()";
}

sub fflush {
    redef "IO::Handle::flush()";
}

sub fgetpos {
    redef "IO::Seekable::getpos()";
}

sub fsetpos {
    redef "IO::Seekable::setpos()";
}

sub ftell {
    redef "IO::Seekable::tell()";
}

sub fwrite {
    unimpl "fwrite() is C-specific--use print instead";
}

sub getc {
    usage "getc(handle)" if @@_ != 1;
    CORE::getc($_[0]);
}

sub getchar {
    usage "getchar()" if @@_ != 0;
    CORE::getc(STDIN);
}

sub gets {
    usage "gets()" if @@_ != 0;
    scalar <STDIN>;
}

sub perror {
    print STDERR "@@_: " if @@_;
    print STDERR $!,"\n";
}

sub printf {
    usage "printf(pattern, args...)" if @@_ < 1;
    CORE::printf STDOUT @@_;
}

sub putc {
    unimpl "putc() is C-specific--use print instead";
}

sub putchar {
    unimpl "putchar() is C-specific--use print instead";
}

sub puts {
    unimpl "puts() is C-specific--use print instead";
}

sub remove {
    usage "remove(filename)" if @@_ != 1;
    (-d $_[0]) ? CORE::rmdir($_[0]) : CORE::unlink($_[0]);
}

sub rename {
    usage "rename(oldfilename, newfilename)" if @@_ != 2;
    CORE::rename($_[0], $_[1]);
}

sub rewind {
    usage "rewind(filehandle)" if @@_ != 1;
    CORE::seek($_[0],0,0);
}

sub scanf {
    unimpl "scanf() is C-specific--use <> and regular expressions instead";
}

sub sprintf {
    usage "sprintf(pattern,args)" if @@_ == 0;
    CORE::sprintf(shift,@@_);
}

sub sscanf {
    unimpl "sscanf() is C-specific--use regular expressions instead";
}

sub tmpfile {
    redef "IO::File::new_tmpfile()";
}

sub ungetc {
    redef "IO::Handle::ungetc()";
}

sub vfprintf {
    unimpl "vfprintf() is C-specific";
}

sub vprintf {
    unimpl "vprintf() is C-specific";
}

sub vsprintf {
    unimpl "vsprintf() is C-specific";
}

sub abs {
    usage "abs(x)" if @@_ != 1;
    CORE::abs($_[0]);
}

sub atexit {
    unimpl "atexit() is C-specific: use END {} instead";
}

sub atof {
    unimpl "atof() is C-specific, stopped";
}

sub atoi {
    unimpl "atoi() is C-specific, stopped";
}

sub atol {
    unimpl "atol() is C-specific, stopped";
}

sub bsearch {
    unimpl "bsearch() not supplied";
}

sub calloc {
    unimpl "calloc() is C-specific, stopped";
}

sub div {
    unimpl "div() is C-specific, use /, % and int instead";
}

sub exit {
    usage "exit(status)" if @@_ != 1;
    CORE::exit($_[0]);
}

sub free {
    unimpl "free() is C-specific, stopped";
}

sub getenv {
    usage "getenv(name)" if @@_ != 1;
    $ENV{$_[0]};
}

sub labs {
    unimpl "labs() is C-specific, use abs instead";
}

sub ldiv {
    unimpl "ldiv() is C-specific, use /, % and int instead";
}

sub malloc {
    unimpl "malloc() is C-specific, stopped";
}

sub qsort {
    unimpl "qsort() is C-specific, use sort instead";
}

sub rand {
    unimpl "rand() is non-portable, use Perl's rand instead";
}

sub realloc {
    unimpl "realloc() is C-specific, stopped";
}

sub srand {
    unimpl "srand()";
}

sub system {
    usage "system(command)" if @@_ != 1;
    CORE::system($_[0]);
}

sub memchr {
    unimpl "memchr() is C-specific, use index() instead";
}

sub memcmp {
    unimpl "memcmp() is C-specific, use eq instead";
}

sub memcpy {
    unimpl "memcpy() is C-specific, use = instead";
}

sub memmove {
    unimpl "memmove() is C-specific, use = instead";
}

sub memset {
    unimpl "memset() is C-specific, use x instead";
}

sub strcat {
    unimpl "strcat() is C-specific, use .= instead";
}

sub strchr {
    unimpl "strchr() is C-specific, use index() instead";
}

sub strcmp {
    unimpl "strcmp() is C-specific, use eq instead";
}

sub strcpy {
    unimpl "strcpy() is C-specific, use = instead";
}

sub strcspn {
    unimpl "strcspn() is C-specific, use regular expressions instead";
}

sub strerror {
    usage "strerror(errno)" if @@_ != 1;
    local $! = $_[0];
    $! . "";
}

sub strlen {
    unimpl "strlen() is C-specific, use length instead";
}

sub strncat {
    unimpl "strncat() is C-specific, use .= instead";
}

sub strncmp {
    unimpl "strncmp() is C-specific, use eq instead";
}

sub strncpy {
    unimpl "strncpy() is C-specific, use = instead";
}

sub strpbrk {
    unimpl "strpbrk() is C-specific, stopped";
}

sub strrchr {
    unimpl "strrchr() is C-specific, use rindex() instead";
}

sub strspn {
    unimpl "strspn() is C-specific, stopped";
}

sub strstr {
    usage "strstr(big, little)" if @@_ != 2;
    CORE::index($_[0], $_[1]);
}

sub strtok {
    unimpl "strtok() is C-specific, stopped";
}

sub chmod {
    usage "chmod(mode, filename)" if @@_ != 2;
    CORE::chmod($_[0], $_[1]);
}

sub fstat {
    usage "fstat(fd)" if @@_ != 1;
    local *TMP;
    CORE::open(TMP, "<&$_[0]");		# Gross.
    my @@l = CORE::stat(TMP);
    CORE::close(TMP);
    @@l;
}

sub mkdir {
    usage "mkdir(directoryname, mode)" if @@_ != 2;
    CORE::mkdir($_[0], $_[1]);
}

sub stat {
    usage "stat(filename)" if @@_ != 1;
    CORE::stat($_[0]);
}

sub umask {
    usage "umask(mask)" if @@_ != 1;
    CORE::umask($_[0]);
}

sub wait {
    usage "wait()" if @@_ != 0;
    CORE::wait();
}

sub waitpid {
    usage "waitpid(pid, options)" if @@_ != 2;
    CORE::waitpid($_[0], $_[1]);
}

sub gmtime {
    usage "gmtime(time)" if @@_ != 1;
    CORE::gmtime($_[0]);
}

sub localtime {
    usage "localtime(time)" if @@_ != 1;
    CORE::localtime($_[0]);
}

sub time {
    usage "time()" if @@_ != 0;
    CORE::time;
}

sub alarm {
    usage "alarm(seconds)" if @@_ != 1;
    CORE::alarm($_[0]);
}

sub chdir {
    usage "chdir(directory)" if @@_ != 1;
    CORE::chdir($_[0]);
}

sub chown {
    usage "chown(uid, gid, filename)" if @@_ != 3;
    CORE::chown($_[0], $_[1], $_[2]);
}

sub execl {
    unimpl "execl() is C-specific, stopped";
}

sub execle {
    unimpl "execle() is C-specific, stopped";
}

sub execlp {
    unimpl "execlp() is C-specific, stopped";
}

sub execv {
    unimpl "execv() is C-specific, stopped";
}

sub execve {
    unimpl "execve() is C-specific, stopped";
}

sub execvp {
    unimpl "execvp() is C-specific, stopped";
}

sub fork {
    usage "fork()" if @@_ != 0;
    CORE::fork;
}

sub getegid {
    usage "getegid()" if @@_ != 0;
    $) + 0;
}

sub geteuid {
    usage "geteuid()" if @@_ != 0;
    $> + 0;
}

sub getgid {
    usage "getgid()" if @@_ != 0;
    $( + 0;
}

sub getgroups {
    usage "getgroups()" if @@_ != 0;
    my %seen;
    grep(!$seen{$_}++, split(' ', $) ));
}

sub getlogin {
    usage "getlogin()" if @@_ != 0;
    CORE::getlogin();
}

sub getpgrp {
    usage "getpgrp()" if @@_ != 0;
    CORE::getpgrp;
}

sub getpid {
    usage "getpid()" if @@_ != 0;
    $$;
}

sub getppid {
    usage "getppid()" if @@_ != 0;
    CORE::getppid;
}

sub getuid {
    usage "getuid()" if @@_ != 0;
    $<;
}

sub isatty {
    usage "isatty(filehandle)" if @@_ != 1;
    -t $_[0];
}

sub link {
    usage "link(oldfilename, newfilename)" if @@_ != 2;
    CORE::link($_[0], $_[1]);
}

sub rmdir {
    usage "rmdir(directoryname)" if @@_ != 1;
    CORE::rmdir($_[0]);
}

sub setbuf {
    redef "IO::Handle::setbuf()";
}

sub setvbuf {
    redef "IO::Handle::setvbuf()";
}

sub sleep {
    usage "sleep(seconds)" if @@_ != 1;
    $_[0] - CORE::sleep($_[0]);
}

sub unlink {
    usage "unlink(filename)" if @@_ != 1;
    CORE::unlink($_[0]);
}

sub utime {
    usage "utime(filename, atime, mtime)" if @@_ != 3;
    CORE::utime($_[1], $_[2], $_[0]);
}

sub load_imports {
%EXPORT_TAGS = (

    assert_h =>	[qw(assert NDEBUG)],

    ctype_h =>	[qw(isalnum isalpha iscntrl isdigit isgraph islower
		isprint ispunct isspace isupper isxdigit tolower toupper)],

    dirent_h =>	[],

    errno_h =>	[qw(E2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT
		EAGAIN EALREADY EBADF EBUSY ECHILD ECONNABORTED
		ECONNREFUSED ECONNRESET EDEADLK EDESTADDRREQ EDOM EDQUOT
		EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH EINPROGRESS
		EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK
		EMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH
		ENFILE ENOBUFS ENODEV ENOENT ENOEXEC ENOLCK ENOMEM
		ENOPROTOOPT ENOSPC ENOSYS ENOTBLK ENOTCONN ENOTDIR
		ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM
		EPFNOSUPPORT EPIPE EPROCLIM EPROTONOSUPPORT EPROTOTYPE
		ERANGE EREMOTE ERESTART EROFS ESHUTDOWN ESOCKTNOSUPPORT
		ESPIPE ESRCH ESTALE ETIMEDOUT ETOOMANYREFS ETXTBSY
		EUSERS EWOULDBLOCK EXDEV errno)],

    fcntl_h =>	[qw(FD_CLOEXEC F_DUPFD F_GETFD F_GETFL F_GETLK F_RDLCK
		F_SETFD F_SETFL F_SETLK F_SETLKW F_UNLCK F_WRLCK
		O_ACCMODE O_APPEND O_CREAT O_EXCL O_NOCTTY O_NONBLOCK
		O_RDONLY O_RDWR O_TRUNC O_WRONLY
		creat
		SEEK_CUR SEEK_END SEEK_SET
		S_IRGRP S_IROTH S_IRUSR S_IRWXG S_IRWXO S_IRWXU
		S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISGID S_ISREG S_ISUID
		S_IWGRP S_IWOTH S_IWUSR)],

    float_h =>	[qw(DBL_DIG DBL_EPSILON DBL_MANT_DIG
		DBL_MAX DBL_MAX_10_EXP DBL_MAX_EXP
		DBL_MIN DBL_MIN_10_EXP DBL_MIN_EXP
		FLT_DIG FLT_EPSILON FLT_MANT_DIG
		FLT_MAX FLT_MAX_10_EXP FLT_MAX_EXP
		FLT_MIN FLT_MIN_10_EXP FLT_MIN_EXP
		FLT_RADIX FLT_ROUNDS
		LDBL_DIG LDBL_EPSILON LDBL_MANT_DIG
		LDBL_MAX LDBL_MAX_10_EXP LDBL_MAX_EXP
		LDBL_MIN LDBL_MIN_10_EXP LDBL_MIN_EXP)],

    grp_h =>	[],

    limits_h =>	[qw( ARG_MAX CHAR_BIT CHAR_MAX CHAR_MIN CHILD_MAX
		INT_MAX INT_MIN LINK_MAX LONG_MAX LONG_MIN MAX_CANON
		MAX_INPUT MB_LEN_MAX NAME_MAX NGROUPS_MAX OPEN_MAX
		PATH_MAX PIPE_BUF SCHAR_MAX SCHAR_MIN SHRT_MAX SHRT_MIN
		SSIZE_MAX STREAM_MAX TZNAME_MAX UCHAR_MAX UINT_MAX
		ULONG_MAX USHRT_MAX _POSIX_ARG_MAX _POSIX_CHILD_MAX
		_POSIX_LINK_MAX _POSIX_MAX_CANON _POSIX_MAX_INPUT
		_POSIX_NAME_MAX _POSIX_NGROUPS_MAX _POSIX_OPEN_MAX
		_POSIX_PATH_MAX _POSIX_PIPE_BUF _POSIX_SSIZE_MAX
		_POSIX_STREAM_MAX _POSIX_TZNAME_MAX)],

    locale_h =>	[qw(LC_ALL LC_COLLATE LC_CTYPE LC_MESSAGES
		    LC_MONETARY LC_NUMERIC LC_TIME NULL
		    localeconv setlocale)],

    math_h =>	[qw(HUGE_VAL acos asin atan ceil cosh fabs floor fmod
		frexp ldexp log10 modf pow sinh tan tanh)],

    pwd_h =>	[],

    setjmp_h =>	[qw(longjmp setjmp siglongjmp sigsetjmp)],

    signal_h =>	[qw(SA_NOCLDSTOP SA_NOCLDWAIT SA_NODEFER SA_ONSTACK
		SA_RESETHAND SA_RESTART SA_SIGINFO SIGABRT SIGALRM
		SIGCHLD SIGCONT SIGFPE SIGHUP SIGILL SIGINT SIGKILL
		SIGPIPE %SIGRT SIGRTMIN SIGRTMAX SIGQUIT SIGSEGV SIGSTOP
		SIGTERM SIGTSTP SIGTTIN	SIGTTOU SIGUSR1 SIGUSR2
		SIG_BLOCK SIG_DFL SIG_ERR SIG_IGN SIG_SETMASK SIG_UNBLOCK
		raise sigaction signal sigpending sigprocmask sigsuspend)],

    stdarg_h =>	[],

    stddef_h =>	[qw(NULL offsetof)],

    stdio_h =>	[qw(BUFSIZ EOF FILENAME_MAX L_ctermid L_cuserid
		L_tmpname NULL SEEK_CUR SEEK_END SEEK_SET
		STREAM_MAX TMP_MAX stderr stdin stdout
		clearerr fclose fdopen feof ferror fflush fgetc fgetpos
		fgets fopen fprintf fputc fputs fread freopen
		fscanf fseek fsetpos ftell fwrite getchar gets
		perror putc putchar puts remove rewind
		scanf setbuf setvbuf sscanf tmpfile tmpnam
		ungetc vfprintf vprintf vsprintf)],

    stdlib_h =>	[qw(EXIT_FAILURE EXIT_SUCCESS MB_CUR_MAX NULL RAND_MAX
		abort atexit atof atoi atol bsearch calloc div
		free getenv labs ldiv malloc mblen mbstowcs mbtowc
		qsort realloc strtod strtol strtoul wcstombs wctomb)],

    string_h =>	[qw(NULL memchr memcmp memcpy memmove memset strcat
		strchr strcmp strcoll strcpy strcspn strerror strlen
		strncat strncmp strncpy strpbrk strrchr strspn strstr
		strtok strxfrm)],

    sys_stat_h => [qw(S_IRGRP S_IROTH S_IRUSR S_IRWXG S_IRWXO S_IRWXU
		S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISGID S_ISREG
		S_ISUID S_IWGRP S_IWOTH S_IWUSR S_IXGRP S_IXOTH S_IXUSR
		fstat mkfifo)],

    sys_times_h => [],

    sys_types_h => [],

    sys_utsname_h => [qw(uname)],

    sys_wait_h => [qw(WEXITSTATUS WIFEXITED WIFSIGNALED WIFSTOPPED
		WNOHANG WSTOPSIG WTERMSIG WUNTRACED)],

    termios_h => [qw( B0 B110 B1200 B134 B150 B1800 B19200 B200 B2400
		B300 B38400 B4800 B50 B600 B75 B9600 BRKINT CLOCAL
		CREAD CS5 CS6 CS7 CS8 CSIZE CSTOPB ECHO ECHOE ECHOK
		ECHONL HUPCL ICANON ICRNL IEXTEN IGNBRK IGNCR IGNPAR
		INLCR INPCK ISIG ISTRIP IXOFF IXON NCCS NOFLSH OPOST
		PARENB PARMRK PARODD TCIFLUSH TCIOFF TCIOFLUSH TCION
		TCOFLUSH TCOOFF TCOON TCSADRAIN TCSAFLUSH TCSANOW
		TOSTOP VEOF VEOL VERASE VINTR VKILL VMIN VQUIT VSTART
		VSTOP VSUSP VTIME
		cfgetispeed cfgetospeed cfsetispeed cfsetospeed tcdrain
		tcflow tcflush tcgetattr tcsendbreak tcsetattr )],

    time_h =>	[qw(CLK_TCK CLOCKS_PER_SEC NULL asctime clock ctime
		difftime mktime strftime tzset tzname)],

    unistd_h =>	[qw(F_OK NULL R_OK SEEK_CUR SEEK_END SEEK_SET
		STDERR_FILENO STDIN_FILENO STDOUT_FILENO W_OK X_OK
		_PC_CHOWN_RESTRICTED _PC_LINK_MAX _PC_MAX_CANON
		_PC_MAX_INPUT _PC_NAME_MAX _PC_NO_TRUNC _PC_PATH_MAX
		_PC_PIPE_BUF _PC_VDISABLE _POSIX_CHOWN_RESTRICTED
		_POSIX_JOB_CONTROL _POSIX_NO_TRUNC _POSIX_SAVED_IDS
		_POSIX_VDISABLE _POSIX_VERSION _SC_ARG_MAX
		_SC_CHILD_MAX _SC_CLK_TCK _SC_JOB_CONTROL
		_SC_NGROUPS_MAX _SC_OPEN_MAX _SC_PAGESIZE _SC_SAVED_IDS
		_SC_STREAM_MAX _SC_TZNAME_MAX _SC_VERSION
		_exit access ctermid cuserid
		dup2 dup execl execle execlp execv execve execvp
		fpathconf fsync getcwd getegid geteuid getgid getgroups
		getpid getuid isatty lseek pathconf pause setgid setpgid
		setsid setuid sysconf tcgetpgrp tcsetpgrp ttyname)],

    utime_h =>	[],

);

# Exporter::export_tags();
{
  # De-duplicate the export list: 
  my %export;
  @@export{map {@@$_} values %EXPORT_TAGS} = ();
  # Doing the de-dup with a temporary hash has the advantage that the SVs in
  # @@EXPORT are actually shared hash key sacalars, which will save some memory.
  push @@EXPORT, keys %export;
}

@@EXPORT_OK = qw(
		abs
		alarm
		atan2
		chdir
		chmod
		chown
		close
		closedir
		cos
		exit
		exp
		fcntl
		fileno
		fork
		getc
		getgrgid
		getgrnam
		getlogin
		getpgrp
		getppid
		getpwnam
		getpwuid
		gmtime
		isatty
		kill
		lchown
		link
		localtime
		log
		mkdir
		nice
		open
		opendir
		pipe
		printf
		rand
		read
		readdir
		rename
		rewinddir
		rmdir
		sin
		sleep
		sprintf
		sqrt
		srand
		stat
		system
		time
		times
		umask
		unlink
		utime
		wait
		waitpid
		write
);

require Exporter;
}

package POSIX::SigAction;

sub new { bless {HANDLER => $_[1], MASK => $_[2], FLAGS => $_[3] || 0, SAFE => 0}, $_[0] }
sub handler { $_[0]->{HANDLER} = $_[1] if @@_ > 1; $_[0]->{HANDLER} };
sub mask    { $_[0]->{MASK}    = $_[1] if @@_ > 1; $_[0]->{MASK} };
sub flags   { $_[0]->{FLAGS}   = $_[1] if @@_ > 1; $_[0]->{FLAGS} };
sub safe    { $_[0]->{SAFE}    = $_[1] if @@_ > 1; $_[0]->{SAFE} };

package POSIX::SigRt;


sub _init {
    $_SIGRTMIN = &POSIX::SIGRTMIN;
    $_SIGRTMAX = &POSIX::SIGRTMAX;
    $_sigrtn   = $_SIGRTMAX - $_SIGRTMIN;
}

sub _croak {
    &_init unless defined $_sigrtn;
    die "POSIX::SigRt not available" unless defined $_sigrtn && $_sigrtn > 0;
}

sub _getsig {
    &_croak;
    my $rtsig = $_[0];
    # Allow (SIGRT)?MIN( + n)?, a common idiom when doing these things in C.
    $rtsig = $_SIGRTMIN + ($1 || 0)
	if $rtsig =~ /^(?:(?:SIG)?RT)?MIN(\s*\+\s*(\d+))?$/;
    return $rtsig;
}

sub _exist {
    my $rtsig = _getsig($_[1]);
    my $ok    = $rtsig >= $_SIGRTMIN && $rtsig <= $_SIGRTMAX;
    ($rtsig, $ok);
}

sub _check {
    my ($rtsig, $ok) = &_exist;
    die "No POSIX::SigRt signal $_[1] (valid range SIGRTMIN..SIGRTMAX, or $_SIGRTMIN..$_SIGRTMAX)"
	unless $ok;
    return $rtsig;
}

sub new {
    my ($rtsig, $handler, $flags) = @@_;
    my $sigset = POSIX::SigSet->new($rtsig);
    my $sigact = POSIX::SigAction->new($handler,
				       $sigset,
				       $flags);
    POSIX::sigaction($rtsig, $sigact);
}

sub EXISTS { &_exist }
sub FETCH  { my $rtsig = &_check;
	     my $oa = POSIX::SigAction->new();
	     POSIX::sigaction($rtsig, undef, $oa);
	     return $oa->{HANDLER} }
sub STORE  { my $rtsig = &_check; new($rtsig, $_[2], $SIGACTION_FLAGS) }
sub DELETE { delete $SIG{ &_check } }
sub CLEAR  { &_exist; delete @@SIG{ &POSIX::SIGRTMIN .. &POSIX::SIGRTMAX } }
sub SCALAR { &_croak; $_sigrtn + 1 }
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@@


1.12
log
@Merge in perl 5.10.1
@
text
@d7 1
a7 1
our $VERSION = "1.17";
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d7 1
a7 1
our $VERSION = "1.13";
d16 4
a19 1
	     O_WRONLY);
a37 4
my %NON_CONSTS = (map {($_,1)}
                  qw(S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG WEXITSTATUS
                     WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG));

d49 3
a51 9
    if ($NON_CONSTS{$constname}) {
        my ($val, $error) = &int_macro_int($constname, $_[0]);
        croak $error if $error;
        *$AUTOLOAD = sub { &int_macro_int($constname, $_[0]) };
    } else {
        my ($error, $val) = constant($constname);
        croak $error if $error;
	*$AUTOLOAD = sub { $val };
    }
@


1.10
log
@merge in perl 5.8.8
@
text
@d2 2
d5 1
a5 1
our(@@ISA, %EXPORT_TAGS, @@EXPORT_OK, $AUTOLOAD) = ();
d7 1
a7 1
our $VERSION = "1.09";
d13 5
d40 2
d66 15
a80 1
sub new { bless {HANDLER => $_[1], MASK => $_[2], FLAGS => $_[3] || 0, SAFE => 0}, $_[0] }
d375 1
a375 1
    CORE::unlink($_[0]);
d838 4
a841 4
		SIGPIPE SIGQUIT SIGSEGV SIGSTOP SIGTERM SIGTSTP SIGTTIN
		SIGTTOU SIGUSR1 SIGUSR2 SIG_BLOCK SIG_DFL SIG_ERR
		SIG_IGN SIG_SETMASK SIG_UNBLOCK raise sigaction signal
		sigpending sigprocmask sigsuspend)],
d917 7
a923 2
for (values %EXPORT_TAGS) {
  push @@EXPORT, @@$_;
d990 1
d995 55
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d5 1
a5 1
our $VERSION = "1.08";
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d5 1
a5 1
our $VERSION = "1.07";
d626 1
a626 1
    usage "chown(filename, uid, gid)" if @@_ != 3;
d924 1
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d5 1
a5 1
our $VERSION = "1.06" ;
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d5 2
a10 2
our $VERSION = "1.05" ;

d54 6
a59 3
sub POSIX::SigAction::new {
    bless {HANDLER => $_[1], MASK => $_[2], FLAGS => $_[3] || 0}, $_[0];
}
d285 4
d428 1
a428 1
    unimpl "div() is C-specific, stopped";
d450 1
a450 1
    unimpl "ldiv() is C-specific, use / and int instead";
d885 1
a885 1
		fpathconf getcwd getegid geteuid getgid getgroups
d958 7
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d9 1
a9 1
our $VERSION = "1.03" ;
d23 2
d28 3
a30 2
my $EINVAL = constant("EINVAL", 0);
my $EAGAIN = constant("EAGAIN", 0);
d41 7
a47 2
    my $val = constant($constname, @@_ ? $_[0] : 0);
    if ($! == 0) {
a49 9
    elsif ($! == $EAGAIN) {	# Not really a constant, so always call.
	*$AUTOLOAD = sub { constant($constname, $_[0]) };
    }
    elsif ($! == $EINVAL) {
	croak "$constname is not a valid POSIX macro";
    }
    else {
	croak "Your vendor has not defined POSIX macro $constname, used";
    }
d54 8
a61 1
sub usage { 
d66 1
a66 1
sub redef { 
d71 1
a71 1
sub unimpl { 
a76 12
############################
package POSIX::SigAction;

sub new {
    bless {HANDLER => $_[1], MASK => $_[2], FLAGS => $_[3] || 0}, $_[0];
}

############################
package POSIX; # return to package POSIX so AutoSplit is happy
1;
__END__

a651 14
sub getcwd
{
    usage "getcwd()" if @@_ != 0;
    if ($^O eq 'MSWin32') {
	# this perhaps applies to everyone else also?
	require Cwd;
	$cwd = &Cwd::cwd;
    }
    else {
	chop($cwd = `pwd`);
    }
    $cwd;
}

a716 10
sub setgid {
    usage "setgid(gid)" if @@_ != 1;
    $( = $_[0];
}

sub setuid {
    usage "setuid(uid)" if @@_ != 1;
    $< = $_[0];
}

d723 1
a723 1
    CORE::sleep($_[0]);
d744 1
a744 1
    dirent_h =>	[qw()],
d781 1
a781 1
    grp_h =>	[qw()],
d794 3
a796 2
    locale_h =>	[qw(LC_ALL LC_COLLATE LC_CTYPE LC_MONETARY LC_NUMERIC
		LC_TIME NULL localeconv setlocale)],
d801 1
a801 1
    pwd_h =>	[qw()],
d813 1
a813 1
    stdarg_h =>	[qw()],
d842 1
a842 1
    sys_times_h => [qw()],
d844 1
a844 1
    sys_types_h => [qw()],
d874 1
a874 1
		_SC_NGROUPS_MAX _SC_OPEN_MAX _SC_SAVED_IDS
d882 1
a882 1
    utime_h =>	[qw()],
d892 55
a946 16
    closedir opendir readdir rewinddir
    fcntl open
    getgrgid getgrnam
    atan2 cos exp log sin sqrt
    getpwnam getpwuid
    kill
    fileno getc printf rename sprintf
    abs exit rand srand system
    chmod mkdir stat umask
    times
    wait waitpid
    gmtime localtime time 
    alarm chdir chown close fork getlogin getppid getpgrp link
	pipe read rmdir sleep unlink write
    utime
    nice
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d568 1
a568 1
    open(TMP, "<&$_[0]");		# Gross.
d570 1
a570 1
    close(TMP);
d896 1
a896 1
		STRERR_FILENO STDIN_FILENO STDOUT_FILENO W_OK X_OK
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
use vars qw($VERSION @@ISA %EXPORT_TAGS @@EXPORT_OK $AUTOLOAD); 
a4 1
use Carp;
a5 2
require Config;
use Symbol;
d7 1
a7 3
require Exporter;
require DynaLoader;
@@ISA = qw(Exporter DynaLoader);
d9 1
a9 1
$VERSION = "1.02" ;
d11 2
a12 56
%EXPORT_TAGS = (

    assert_h =>	[qw(assert NDEBUG)],

    ctype_h =>	[qw(isalnum isalpha iscntrl isdigit isgraph islower
		isprint ispunct isspace isupper isxdigit tolower toupper)],

    dirent_h =>	[qw()],

    errno_h =>	[qw(E2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT
		EAGAIN EALREADY EBADF EBUSY ECHILD ECONNABORTED
		ECONNREFUSED ECONNRESET EDEADLK EDESTADDRREQ EDOM EDQUOT
		EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH EINPROGRESS
		EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK
		EMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH
		ENFILE ENOBUFS ENODEV ENOENT ENOEXEC ENOLCK ENOMEM
		ENOPROTOOPT ENOSPC ENOSYS ENOTBLK ENOTCONN ENOTDIR
		ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM
		EPFNOSUPPORT EPIPE EPROCLIM EPROTONOSUPPORT EPROTOTYPE
		ERANGE EREMOTE ERESTART EROFS ESHUTDOWN ESOCKTNOSUPPORT
		ESPIPE ESRCH ESTALE ETIMEDOUT ETOOMANYREFS ETXTBSY
		EUSERS EWOULDBLOCK EXDEV errno)],

    fcntl_h =>	[qw(FD_CLOEXEC F_DUPFD F_GETFD F_GETFL F_GETLK F_RDLCK
		F_SETFD F_SETFL F_SETLK F_SETLKW F_UNLCK F_WRLCK
		O_ACCMODE O_APPEND O_CREAT O_EXCL O_NOCTTY O_NONBLOCK
		O_RDONLY O_RDWR O_TRUNC O_WRONLY
		creat
		SEEK_CUR SEEK_END SEEK_SET
		S_IRGRP S_IROTH S_IRUSR S_IRWXG S_IRWXO S_IRWXU
		S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISGID S_ISREG S_ISUID
		S_IWGRP S_IWOTH S_IWUSR)],

    float_h =>	[qw(DBL_DIG DBL_EPSILON DBL_MANT_DIG
		DBL_MAX DBL_MAX_10_EXP DBL_MAX_EXP
		DBL_MIN DBL_MIN_10_EXP DBL_MIN_EXP
		FLT_DIG FLT_EPSILON FLT_MANT_DIG
		FLT_MAX FLT_MAX_10_EXP FLT_MAX_EXP
		FLT_MIN FLT_MIN_10_EXP FLT_MIN_EXP
		FLT_RADIX FLT_ROUNDS
		LDBL_DIG LDBL_EPSILON LDBL_MANT_DIG
		LDBL_MAX LDBL_MAX_10_EXP LDBL_MAX_EXP
		LDBL_MIN LDBL_MIN_10_EXP LDBL_MIN_EXP)],

    grp_h =>	[qw()],

    limits_h =>	[qw( ARG_MAX CHAR_BIT CHAR_MAX CHAR_MIN CHILD_MAX
		INT_MAX INT_MIN LINK_MAX LONG_MAX LONG_MIN MAX_CANON
		MAX_INPUT MB_LEN_MAX NAME_MAX NGROUPS_MAX OPEN_MAX
		PATH_MAX PIPE_BUF SCHAR_MAX SCHAR_MIN SHRT_MAX SHRT_MIN
		SSIZE_MAX STREAM_MAX TZNAME_MAX UCHAR_MAX UINT_MAX
		ULONG_MAX USHRT_MAX _POSIX_ARG_MAX _POSIX_CHILD_MAX
		_POSIX_LINK_MAX _POSIX_MAX_CANON _POSIX_MAX_INPUT
		_POSIX_NAME_MAX _POSIX_NGROUPS_MAX _POSIX_OPEN_MAX
		_POSIX_PATH_MAX _POSIX_PIPE_BUF _POSIX_SSIZE_MAX
		_POSIX_STREAM_MAX _POSIX_TZNAME_MAX)],
a13 113
    locale_h =>	[qw(LC_ALL LC_COLLATE LC_CTYPE LC_MONETARY LC_NUMERIC
		LC_TIME NULL localeconv setlocale)],

    math_h =>	[qw(HUGE_VAL acos asin atan ceil cosh fabs floor fmod
		frexp ldexp log10 modf pow sinh tan tanh)],

    pwd_h =>	[qw()],

    setjmp_h =>	[qw(longjmp setjmp siglongjmp sigsetjmp)],

    signal_h =>	[qw(SA_NOCLDSTOP SA_NOCLDWAIT SA_NODEFER SA_ONSTACK
		SA_RESETHAND SA_RESTART SA_SIGINFO SIGABRT SIGALRM
		SIGCHLD SIGCONT SIGFPE SIGHUP SIGILL SIGINT SIGKILL
		SIGPIPE SIGQUIT SIGSEGV SIGSTOP SIGTERM SIGTSTP SIGTTIN
		SIGTTOU SIGUSR1 SIGUSR2 SIG_BLOCK SIG_DFL SIG_ERR
		SIG_IGN SIG_SETMASK SIG_UNBLOCK raise sigaction signal
		sigpending sigprocmask sigsuspend)],

    stdarg_h =>	[qw()],

    stddef_h =>	[qw(NULL offsetof)],

    stdio_h =>	[qw(BUFSIZ EOF FILENAME_MAX L_ctermid L_cuserid
		L_tmpname NULL SEEK_CUR SEEK_END SEEK_SET
		STREAM_MAX TMP_MAX stderr stdin stdout
		clearerr fclose fdopen feof ferror fflush fgetc fgetpos
		fgets fopen fprintf fputc fputs fread freopen
		fscanf fseek fsetpos ftell fwrite getchar gets
		perror putc putchar puts remove rewind
		scanf setbuf setvbuf sscanf tmpfile tmpnam
		ungetc vfprintf vprintf vsprintf)],

    stdlib_h =>	[qw(EXIT_FAILURE EXIT_SUCCESS MB_CUR_MAX NULL RAND_MAX
		abort atexit atof atoi atol bsearch calloc div
		free getenv labs ldiv malloc mblen mbstowcs mbtowc
		qsort realloc strtod strtol strtoul wcstombs wctomb)],

    string_h =>	[qw(NULL memchr memcmp memcpy memmove memset strcat
		strchr strcmp strcoll strcpy strcspn strerror strlen
		strncat strncmp strncpy strpbrk strrchr strspn strstr
		strtok strxfrm)],

    sys_stat_h => [qw(S_IRGRP S_IROTH S_IRUSR S_IRWXG S_IRWXO S_IRWXU
		S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISGID S_ISREG
		S_ISUID S_IWGRP S_IWOTH S_IWUSR S_IXGRP S_IXOTH S_IXUSR
		fstat mkfifo)],

    sys_times_h => [qw()],

    sys_types_h => [qw()],

    sys_utsname_h => [qw(uname)],

    sys_wait_h => [qw(WEXITSTATUS WIFEXITED WIFSIGNALED WIFSTOPPED
		WNOHANG WSTOPSIG WTERMSIG WUNTRACED)],

    termios_h => [qw( B0 B110 B1200 B134 B150 B1800 B19200 B200 B2400
		B300 B38400 B4800 B50 B600 B75 B9600 BRKINT CLOCAL
		CREAD CS5 CS6 CS7 CS8 CSIZE CSTOPB ECHO ECHOE ECHOK
		ECHONL HUPCL ICANON ICRNL IEXTEN IGNBRK IGNCR IGNPAR
		INLCR INPCK ISIG ISTRIP IXOFF IXON NCCS NOFLSH OPOST
		PARENB PARMRK PARODD TCIFLUSH TCIOFF TCIOFLUSH TCION
		TCOFLUSH TCOOFF TCOON TCSADRAIN TCSAFLUSH TCSANOW
		TOSTOP VEOF VEOL VERASE VINTR VKILL VMIN VQUIT VSTART
		VSTOP VSUSP VTIME
		cfgetispeed cfgetospeed cfsetispeed cfsetospeed tcdrain
		tcflow tcflush tcgetattr tcsendbreak tcsetattr )],

    time_h =>	[qw(CLK_TCK CLOCKS_PER_SEC NULL asctime clock ctime
		difftime mktime strftime tzset tzname)],

    unistd_h =>	[qw(F_OK NULL R_OK SEEK_CUR SEEK_END SEEK_SET
		STRERR_FILENO STDIN_FILENO STDOUT_FILENO W_OK X_OK
		_PC_CHOWN_RESTRICTED _PC_LINK_MAX _PC_MAX_CANON
		_PC_MAX_INPUT _PC_NAME_MAX _PC_NO_TRUNC _PC_PATH_MAX
		_PC_PIPE_BUF _PC_VDISABLE _POSIX_CHOWN_RESTRICTED
		_POSIX_JOB_CONTROL _POSIX_NO_TRUNC _POSIX_SAVED_IDS
		_POSIX_VDISABLE _POSIX_VERSION _SC_ARG_MAX
		_SC_CHILD_MAX _SC_CLK_TCK _SC_JOB_CONTROL
		_SC_NGROUPS_MAX _SC_OPEN_MAX _SC_SAVED_IDS
		_SC_STREAM_MAX _SC_TZNAME_MAX _SC_VERSION
		_exit access ctermid cuserid
		dup2 dup execl execle execlp execv execve execvp
		fpathconf getcwd getegid geteuid getgid getgroups
		getpid getuid isatty lseek pathconf pause setgid setpgid
		setsid setuid sysconf tcgetpgrp tcsetpgrp ttyname)],

    utime_h =>	[qw()],

);

Exporter::export_tags();

@@EXPORT_OK = qw(
    closedir opendir readdir rewinddir
    fcntl open
    getgrgid getgrnam
    atan2 cos exp log sin sqrt
    getpwnam getpwuid
    kill
    fileno getc printf rename sprintf
    abs exit rand srand system
    chmod mkdir stat umask
    times
    wait waitpid
    gmtime localtime time 
    alarm chdir chown close fork getlogin getppid getpgrp link
	pipe read rmdir sleep unlink write
    utime
    nice
);

# Grandfather old foo_h form to new :foo_h form
d15 1
d22 1
d24 1
a24 1
bootstrap POSIX $VERSION;
d31 1
d107 1
a107 1
    my $dirhandle = gensym;
d766 175
@


1.2
log
@perl 5.004_04
@
text
@d71 1
a71 1
		_POSIX_STREADM_MAX _POSIX_TZNAME_MAX)],
d182 1
d271 1
a271 1
    closedir($_[0]);
d277 1
a277 1
    opendir($dirhandle, $_[0])
d284 1
a284 1
    readdir($_[0]);
d289 1
a289 1
    rewinddir($_[0]);
d304 1
a304 1
    fcntl($_[0], $_[1], $_[2]);
d309 1
a309 1
    getgrgid($_[0]);
d314 1
a314 1
    getgrnam($_[0]);
d319 1
a319 1
    atan2($_[0], $_[1]);
d324 1
a324 1
    cos($_[0]);
d329 1
a329 1
    exp($_[0]);
d334 1
a334 1
    abs($_[0]);
d339 1
a339 1
    log($_[0]);
d349 1
a349 1
    sin($_[0]);
d354 1
a354 1
    sqrt($_[0]);
d359 1
a359 1
    getpwnam($_[0]);
d364 1
a364 1
    getpwuid($_[0]);
d385 1
a385 1
    kill $_[1], $_[0];
d390 1
a390 1
    kill $_[0], $$;	# Is this good enough?
d483 1
a483 1
    getc($_[0]);
d488 1
a488 1
    getc(STDIN);
d503 1
a503 1
    printf STDOUT @@_;
d520 1
a520 1
    unlink($_[0]);
d525 1
a525 1
    rename($_[0], $_[1]);
d530 1
a530 1
    seek($_[0],0,0);
d539 1
a539 1
    sprintf(shift,@@_);
d568 1
a568 1
    abs($_[0]);
d601 1
a601 1
    exit($_[0]);
d643 1
a643 1
    system($_[0]);
d722 1
a722 1
    index($_[0], $_[1]);
d731 1
a731 1
    chmod($_[0], $_[1]);
d738 1
a738 1
    my @@l = stat(TMP);
d745 1
a745 1
    mkdir($_[0], $_[1]);
d750 1
a750 1
    stat($_[0]);
d755 1
a755 1
    umask($_[0]);
d760 1
a760 1
    wait();
d765 1
a765 1
    waitpid($_[0], $_[1]);
d770 1
a770 1
    gmtime($_[0]);
d775 1
a775 1
    localtime($_[0]);
d780 1
a780 1
    time;
d785 1
a785 1
    alarm($_[0]);
d790 1
a790 1
    chdir($_[0]);
d795 1
a795 1
    chown($_[0], $_[1], $_[2]);
d824 1
a824 1
    fork;
d830 8
a837 1
    chop($cwd = `pwd`);
d864 1
a864 1
    getlogin();
d869 1
a869 1
    getpgrp($_[0]);
d879 1
a879 1
    getppid;
d894 1
a894 1
    link($_[0], $_[1]);
d899 5
a903 1
    rmdir($_[0]);
d916 4
d922 1
a922 1
    sleep($_[0]);
d927 1
a927 1
    unlink($_[0]);
d932 1
a932 1
    utime($_[1], $_[2], $_[0]);
@


1.1
log
@Initial revision
@
text
@d14 1
a14 1
$VERSION = "1.00" ;
d25 13
a37 5
    errno_h =>	[qw(E2BIG EACCES EAGAIN EBADF EBUSY ECHILD EDEADLK EDOM
		EEXIST EFAULT EFBIG EINTR EINVAL EIO EISDIR EMFILE
		EMLINK ENAMETOOLONG ENFILE ENODEV ENOENT ENOEXEC ENOLCK
		ENOMEM ENOSPC ENOSYS ENOTDIR ENOTEMPTY ENOTTY ENXIO
		EPERM EPIPE ERANGE EROFS ESPIPE ESRCH EXDEV errno)],
d83 7
a89 6
    signal_h =>	[qw(SA_NOCLDSTOP SIGABRT SIGALRM SIGCHLD SIGCONT SIGFPE
		SIGHUP SIGILL SIGINT SIGKILL SIGPIPE SIGQUIT SIGSEGV
		SIGSTOP SIGTERM SIGTSTP SIGTTIN SIGTTOU SIGUSR1 SIGUSR2
		SIG_BLOCK SIG_DFL SIG_ERR SIG_IGN SIG_SETMASK SIG_UNBLOCK
		raise sigaction signal sigpending sigprocmask
		sigsuspend)],
d108 1
a108 1
		qsort realloc strtod strtol stroul wcstombs wctomb)],
d206 1
a206 1
    my $val = constant($constname, $_[0]);
d243 1
a243 1
    bless {HANDLER => $_[1], MASK => $_[2], FLAGS => $_[3]};
d389 1
a389 1
    kill $$, $_[0];	# Is this good enough?
d397 1
a397 1
    redef "FileHandle::clearerr()";
d401 1
a401 1
    redef "FileHandle::close()";
d405 1
a405 1
    redef "FileHandle::new_from_fd()";
d409 1
a409 1
    redef "FileHandle::eof()";
d413 1
a413 1
    redef "FileHandle::getc()";
d417 1
a417 1
    redef "FileHandle::gets()";
d421 1
a421 1
    redef "FileHandle::fileno()";
d425 1
a425 1
    redef "FileHandle::open()";
d453 1
a453 1
    redef "FileHandle::seek()";
d457 1
a457 1
    redef "FileHandle::error()";
d461 1
a461 1
    redef "FileHandle::flush()";
d465 1
a465 1
    redef "FileHandle::getpos()";
d469 1
a469 1
    redef "FileHandle::setpos()";
d473 1
a473 1
    redef "FileHandle::tell()";
d546 1
a546 1
    redef "FileHandle::new_tmpfile()";
d550 1
a550 1
    redef "FileHandle::ungetc()";
a637 12
}

sub strtod {
    unimpl "strtod() is C-specific, stopped";
}

sub strtol {
    unimpl "strtol() is C-specific, stopped";
}

sub stroul {
    unimpl "stroul() is C-specific, stopped";
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d14 1
a14 1
$VERSION = "1.02" ;
d25 5
a29 13
    errno_h =>	[qw(E2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT
		EAGAIN EALREADY EBADF EBUSY ECHILD ECONNABORTED
		ECONNREFUSED ECONNRESET EDEADLK EDESTADDRREQ EDOM EDQUOT
		EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH EINPROGRESS
		EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK
		EMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH
		ENFILE ENOBUFS ENODEV ENOENT ENOEXEC ENOLCK ENOMEM
		ENOPROTOOPT ENOSPC ENOSYS ENOTBLK ENOTCONN ENOTDIR
		ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM
		EPFNOSUPPORT EPIPE EPROCLIM EPROTONOSUPPORT EPROTOTYPE
		ERANGE EREMOTE ERESTART EROFS ESHUTDOWN ESOCKTNOSUPPORT
		ESPIPE ESRCH ESTALE ETIMEDOUT ETOOMANYREFS ETXTBSY
		EUSERS EWOULDBLOCK EXDEV errno)],
d63 1
a63 1
		_POSIX_STREAM_MAX _POSIX_TZNAME_MAX)],
d75 6
a80 7
    signal_h =>	[qw(SA_NOCLDSTOP SA_NOCLDWAIT SA_NODEFER SA_ONSTACK
		SA_RESETHAND SA_RESTART SA_SIGINFO SIGABRT SIGALRM
		SIGCHLD SIGCONT SIGFPE SIGHUP SIGILL SIGINT SIGKILL
		SIGPIPE SIGQUIT SIGSEGV SIGSTOP SIGTERM SIGTSTP SIGTTIN
		SIGTTOU SIGUSR1 SIGUSR2 SIG_BLOCK SIG_DFL SIG_ERR
		SIG_IGN SIG_SETMASK SIG_UNBLOCK raise sigaction signal
		sigpending sigprocmask sigsuspend)],
d99 1
a99 1
		qsort realloc strtod strtol strtoul wcstombs wctomb)],
a172 1
    nice
d197 1
a197 1
    my $val = constant($constname, @@_ ? $_[0] : 0);
d234 1
a234 1
    bless {HANDLER => $_[1], MASK => $_[2], FLAGS => $_[3] || 0}, $_[0];
d261 1
a261 1
    CORE::closedir($_[0]);
d267 1
a267 1
    CORE::opendir($dirhandle, $_[0])
d274 1
a274 1
    CORE::readdir($_[0]);
d279 1
a279 1
    CORE::rewinddir($_[0]);
d294 1
a294 1
    CORE::fcntl($_[0], $_[1], $_[2]);
d299 1
a299 1
    CORE::getgrgid($_[0]);
d304 1
a304 1
    CORE::getgrnam($_[0]);
d309 1
a309 1
    CORE::atan2($_[0], $_[1]);
d314 1
a314 1
    CORE::cos($_[0]);
d319 1
a319 1
    CORE::exp($_[0]);
d324 1
a324 1
    CORE::abs($_[0]);
d329 1
a329 1
    CORE::log($_[0]);
d339 1
a339 1
    CORE::sin($_[0]);
d344 1
a344 1
    CORE::sqrt($_[0]);
d349 1
a349 1
    CORE::getpwnam($_[0]);
d354 1
a354 1
    CORE::getpwuid($_[0]);
d375 1
a375 1
    CORE::kill $_[1], $_[0];
d380 1
a380 1
    CORE::kill $_[0], $$;	# Is this good enough?
d388 1
a388 1
    redef "IO::Handle::clearerr()";
d392 1
a392 1
    redef "IO::Handle::close()";
d396 1
a396 1
    redef "IO::Handle::new_from_fd()";
d400 1
a400 1
    redef "IO::Handle::eof()";
d404 1
a404 1
    redef "IO::Handle::getc()";
d408 1
a408 1
    redef "IO::Handle::gets()";
d412 1
a412 1
    redef "IO::Handle::fileno()";
d416 1
a416 1
    redef "IO::File::open()";
d444 1
a444 1
    redef "IO::Seekable::seek()";
d448 1
a448 1
    redef "IO::Handle::error()";
d452 1
a452 1
    redef "IO::Handle::flush()";
d456 1
a456 1
    redef "IO::Seekable::getpos()";
d460 1
a460 1
    redef "IO::Seekable::setpos()";
d464 1
a464 1
    redef "IO::Seekable::tell()";
d473 1
a473 1
    CORE::getc($_[0]);
d478 1
a478 1
    CORE::getc(STDIN);
d493 1
a493 1
    CORE::printf STDOUT @@_;
d510 1
a510 1
    CORE::unlink($_[0]);
d515 1
a515 1
    CORE::rename($_[0], $_[1]);
d520 1
a520 1
    CORE::seek($_[0],0,0);
d529 1
a529 1
    CORE::sprintf(shift,@@_);
d537 1
a537 1
    redef "IO::File::new_tmpfile()";
d541 1
a541 1
    redef "IO::Handle::ungetc()";
d558 1
a558 1
    CORE::abs($_[0]);
d591 1
a591 1
    CORE::exit($_[0]);
d631 12
d645 1
a645 1
    CORE::system($_[0]);
d724 1
a724 1
    CORE::index($_[0], $_[1]);
d733 1
a733 1
    CORE::chmod($_[0], $_[1]);
d740 1
a740 1
    my @@l = CORE::stat(TMP);
d747 1
a747 1
    CORE::mkdir($_[0], $_[1]);
d752 1
a752 1
    CORE::stat($_[0]);
d757 1
a757 1
    CORE::umask($_[0]);
d762 1
a762 1
    CORE::wait();
d767 1
a767 1
    CORE::waitpid($_[0], $_[1]);
d772 1
a772 1
    CORE::gmtime($_[0]);
d777 1
a777 1
    CORE::localtime($_[0]);
d782 1
a782 1
    CORE::time;
d787 1
a787 1
    CORE::alarm($_[0]);
d792 1
a792 1
    CORE::chdir($_[0]);
d797 1
a797 1
    CORE::chown($_[0], $_[1], $_[2]);
d826 1
a826 1
    CORE::fork;
d832 1
a832 8
    if ($^O eq 'MSWin32') {
	# this perhaps applies to everyone else also?
	require Cwd;
	$cwd = &Cwd::cwd;
    }
    else {
	chop($cwd = `pwd`);
    }
d859 1
a859 1
    CORE::getlogin();
d864 1
a864 1
    CORE::getpgrp;
d874 1
a874 1
    CORE::getppid;
d889 1
a889 1
    CORE::link($_[0], $_[1]);
d894 1
a894 5
    CORE::rmdir($_[0]);
}

sub setbuf {
    redef "IO::Handle::setbuf()";
a906 4
sub setvbuf {
    redef "IO::Handle::setvbuf()";
}

d909 1
a909 1
    CORE::sleep($_[0]);
d914 1
a914 1
    CORE::unlink($_[0]);
d919 1
a919 1
    CORE::utime($_[1], $_[2], $_[0]);
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
our(@@ISA, %EXPORT_TAGS, @@EXPORT_OK, $AUTOLOAD) = ();
d5 1
d7 2
d10 62
a71 1
use XSLoader ();
d73 111
a183 1
our $VERSION = "1.03" ;
a185 2
my $loaded;

a186 1
    load_imports() unless $loaded++;
a192 1
sub croak { require Carp;  goto &Carp::croak }
d194 1
a194 1
XSLoader::load 'POSIX', $VERSION;
a200 1
	# require AutoLoader;
d276 1
a276 1
    my $dirhandle;
a934 175
sub load_imports {
%EXPORT_TAGS = (

    assert_h =>	[qw(assert NDEBUG)],

    ctype_h =>	[qw(isalnum isalpha iscntrl isdigit isgraph islower
		isprint ispunct isspace isupper isxdigit tolower toupper)],

    dirent_h =>	[qw()],

    errno_h =>	[qw(E2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT
		EAGAIN EALREADY EBADF EBUSY ECHILD ECONNABORTED
		ECONNREFUSED ECONNRESET EDEADLK EDESTADDRREQ EDOM EDQUOT
		EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH EINPROGRESS
		EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK
		EMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH
		ENFILE ENOBUFS ENODEV ENOENT ENOEXEC ENOLCK ENOMEM
		ENOPROTOOPT ENOSPC ENOSYS ENOTBLK ENOTCONN ENOTDIR
		ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM
		EPFNOSUPPORT EPIPE EPROCLIM EPROTONOSUPPORT EPROTOTYPE
		ERANGE EREMOTE ERESTART EROFS ESHUTDOWN ESOCKTNOSUPPORT
		ESPIPE ESRCH ESTALE ETIMEDOUT ETOOMANYREFS ETXTBSY
		EUSERS EWOULDBLOCK EXDEV errno)],

    fcntl_h =>	[qw(FD_CLOEXEC F_DUPFD F_GETFD F_GETFL F_GETLK F_RDLCK
		F_SETFD F_SETFL F_SETLK F_SETLKW F_UNLCK F_WRLCK
		O_ACCMODE O_APPEND O_CREAT O_EXCL O_NOCTTY O_NONBLOCK
		O_RDONLY O_RDWR O_TRUNC O_WRONLY
		creat
		SEEK_CUR SEEK_END SEEK_SET
		S_IRGRP S_IROTH S_IRUSR S_IRWXG S_IRWXO S_IRWXU
		S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISGID S_ISREG S_ISUID
		S_IWGRP S_IWOTH S_IWUSR)],

    float_h =>	[qw(DBL_DIG DBL_EPSILON DBL_MANT_DIG
		DBL_MAX DBL_MAX_10_EXP DBL_MAX_EXP
		DBL_MIN DBL_MIN_10_EXP DBL_MIN_EXP
		FLT_DIG FLT_EPSILON FLT_MANT_DIG
		FLT_MAX FLT_MAX_10_EXP FLT_MAX_EXP
		FLT_MIN FLT_MIN_10_EXP FLT_MIN_EXP
		FLT_RADIX FLT_ROUNDS
		LDBL_DIG LDBL_EPSILON LDBL_MANT_DIG
		LDBL_MAX LDBL_MAX_10_EXP LDBL_MAX_EXP
		LDBL_MIN LDBL_MIN_10_EXP LDBL_MIN_EXP)],

    grp_h =>	[qw()],

    limits_h =>	[qw( ARG_MAX CHAR_BIT CHAR_MAX CHAR_MIN CHILD_MAX
		INT_MAX INT_MIN LINK_MAX LONG_MAX LONG_MIN MAX_CANON
		MAX_INPUT MB_LEN_MAX NAME_MAX NGROUPS_MAX OPEN_MAX
		PATH_MAX PIPE_BUF SCHAR_MAX SCHAR_MIN SHRT_MAX SHRT_MIN
		SSIZE_MAX STREAM_MAX TZNAME_MAX UCHAR_MAX UINT_MAX
		ULONG_MAX USHRT_MAX _POSIX_ARG_MAX _POSIX_CHILD_MAX
		_POSIX_LINK_MAX _POSIX_MAX_CANON _POSIX_MAX_INPUT
		_POSIX_NAME_MAX _POSIX_NGROUPS_MAX _POSIX_OPEN_MAX
		_POSIX_PATH_MAX _POSIX_PIPE_BUF _POSIX_SSIZE_MAX
		_POSIX_STREAM_MAX _POSIX_TZNAME_MAX)],

    locale_h =>	[qw(LC_ALL LC_COLLATE LC_CTYPE LC_MONETARY LC_NUMERIC
		LC_TIME NULL localeconv setlocale)],

    math_h =>	[qw(HUGE_VAL acos asin atan ceil cosh fabs floor fmod
		frexp ldexp log10 modf pow sinh tan tanh)],

    pwd_h =>	[qw()],

    setjmp_h =>	[qw(longjmp setjmp siglongjmp sigsetjmp)],

    signal_h =>	[qw(SA_NOCLDSTOP SA_NOCLDWAIT SA_NODEFER SA_ONSTACK
		SA_RESETHAND SA_RESTART SA_SIGINFO SIGABRT SIGALRM
		SIGCHLD SIGCONT SIGFPE SIGHUP SIGILL SIGINT SIGKILL
		SIGPIPE SIGQUIT SIGSEGV SIGSTOP SIGTERM SIGTSTP SIGTTIN
		SIGTTOU SIGUSR1 SIGUSR2 SIG_BLOCK SIG_DFL SIG_ERR
		SIG_IGN SIG_SETMASK SIG_UNBLOCK raise sigaction signal
		sigpending sigprocmask sigsuspend)],

    stdarg_h =>	[qw()],

    stddef_h =>	[qw(NULL offsetof)],

    stdio_h =>	[qw(BUFSIZ EOF FILENAME_MAX L_ctermid L_cuserid
		L_tmpname NULL SEEK_CUR SEEK_END SEEK_SET
		STREAM_MAX TMP_MAX stderr stdin stdout
		clearerr fclose fdopen feof ferror fflush fgetc fgetpos
		fgets fopen fprintf fputc fputs fread freopen
		fscanf fseek fsetpos ftell fwrite getchar gets
		perror putc putchar puts remove rewind
		scanf setbuf setvbuf sscanf tmpfile tmpnam
		ungetc vfprintf vprintf vsprintf)],

    stdlib_h =>	[qw(EXIT_FAILURE EXIT_SUCCESS MB_CUR_MAX NULL RAND_MAX
		abort atexit atof atoi atol bsearch calloc div
		free getenv labs ldiv malloc mblen mbstowcs mbtowc
		qsort realloc strtod strtol strtoul wcstombs wctomb)],

    string_h =>	[qw(NULL memchr memcmp memcpy memmove memset strcat
		strchr strcmp strcoll strcpy strcspn strerror strlen
		strncat strncmp strncpy strpbrk strrchr strspn strstr
		strtok strxfrm)],

    sys_stat_h => [qw(S_IRGRP S_IROTH S_IRUSR S_IRWXG S_IRWXO S_IRWXU
		S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISGID S_ISREG
		S_ISUID S_IWGRP S_IWOTH S_IWUSR S_IXGRP S_IXOTH S_IXUSR
		fstat mkfifo)],

    sys_times_h => [qw()],

    sys_types_h => [qw()],

    sys_utsname_h => [qw(uname)],

    sys_wait_h => [qw(WEXITSTATUS WIFEXITED WIFSIGNALED WIFSTOPPED
		WNOHANG WSTOPSIG WTERMSIG WUNTRACED)],

    termios_h => [qw( B0 B110 B1200 B134 B150 B1800 B19200 B200 B2400
		B300 B38400 B4800 B50 B600 B75 B9600 BRKINT CLOCAL
		CREAD CS5 CS6 CS7 CS8 CSIZE CSTOPB ECHO ECHOE ECHOK
		ECHONL HUPCL ICANON ICRNL IEXTEN IGNBRK IGNCR IGNPAR
		INLCR INPCK ISIG ISTRIP IXOFF IXON NCCS NOFLSH OPOST
		PARENB PARMRK PARODD TCIFLUSH TCIOFF TCIOFLUSH TCION
		TCOFLUSH TCOOFF TCOON TCSADRAIN TCSAFLUSH TCSANOW
		TOSTOP VEOF VEOL VERASE VINTR VKILL VMIN VQUIT VSTART
		VSTOP VSUSP VTIME
		cfgetispeed cfgetospeed cfsetispeed cfsetospeed tcdrain
		tcflow tcflush tcgetattr tcsendbreak tcsetattr )],

    time_h =>	[qw(CLK_TCK CLOCKS_PER_SEC NULL asctime clock ctime
		difftime mktime strftime tzset tzname)],

    unistd_h =>	[qw(F_OK NULL R_OK SEEK_CUR SEEK_END SEEK_SET
		STRERR_FILENO STDIN_FILENO STDOUT_FILENO W_OK X_OK
		_PC_CHOWN_RESTRICTED _PC_LINK_MAX _PC_MAX_CANON
		_PC_MAX_INPUT _PC_NAME_MAX _PC_NO_TRUNC _PC_PATH_MAX
		_PC_PIPE_BUF _PC_VDISABLE _POSIX_CHOWN_RESTRICTED
		_POSIX_JOB_CONTROL _POSIX_NO_TRUNC _POSIX_SAVED_IDS
		_POSIX_VDISABLE _POSIX_VERSION _SC_ARG_MAX
		_SC_CHILD_MAX _SC_CLK_TCK _SC_JOB_CONTROL
		_SC_NGROUPS_MAX _SC_OPEN_MAX _SC_SAVED_IDS
		_SC_STREAM_MAX _SC_TZNAME_MAX _SC_VERSION
		_exit access ctermid cuserid
		dup2 dup execl execle execlp execv execve execvp
		fpathconf getcwd getegid geteuid getgid getgroups
		getpid getuid isatty lseek pathconf pause setgid setpgid
		setsid setuid sysconf tcgetpgrp tcsetpgrp ttyname)],

    utime_h =>	[qw()],

);

# Exporter::export_tags();
for (values %EXPORT_TAGS) {
  push @@EXPORT, @@$_;
}

@@EXPORT_OK = qw(
    closedir opendir readdir rewinddir
    fcntl open
    getgrgid getgrnam
    atan2 cos exp log sin sqrt
    getpwnam getpwuid
    kill
    fileno getc printf rename sprintf
    abs exit rand srand system
    chmod mkdir stat umask
    times
    wait waitpid
    gmtime localtime time 
    alarm chdir chown close fork getlogin getppid getpgrp link
	pipe read rmdir sleep unlink write
    utime
    nice
);

require Exporter;
}
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d568 1
a568 1
    CORE::open(TMP, "<&$_[0]");		# Gross.
d570 1
a570 1
    CORE::close(TMP);
d896 1
a896 1
		STDERR_FILENO STDIN_FILENO STDOUT_FILENO W_OK X_OK
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d9 1
a9 1
our $VERSION = "1.05" ;
a22 2
# declare usage to assist AutoLoad
sub usage;
d26 2
a27 3
my %NON_CONSTS = (map {($_,1)}
                  qw(S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG WEXITSTATUS
                     WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG));
d38 2
a39 7
    if ($NON_CONSTS{$constname}) {
        my ($val, $error) = &int_macro_int($constname, $_[0]);
        croak $error if $error;
        *$AUTOLOAD = sub { &int_macro_int($constname, $_[0]) };
    } else {
        my ($error, $val) = constant($constname);
        croak $error if $error;
d42 9
d55 1
a55 8
sub POSIX::SigAction::new {
    bless {HANDLER => $_[1], MASK => $_[2], FLAGS => $_[3] || 0}, $_[0];
}

1;
__END__

sub usage {
d60 1
a60 1
sub redef {
d65 1
a65 1
sub unimpl {
d71 12
d658 14
d737 10
d753 1
a753 1
    $_[0] - CORE::sleep($_[0]);
d774 1
a774 1
    dirent_h =>	[],
d811 1
a811 1
    grp_h =>	[],
d824 2
a825 3
    locale_h =>	[qw(LC_ALL LC_COLLATE LC_CTYPE LC_MESSAGES
		    LC_MONETARY LC_NUMERIC LC_TIME NULL
		    localeconv setlocale)],
d830 1
a830 1
    pwd_h =>	[],
d842 1
a842 1
    stdarg_h =>	[],
d871 1
a871 1
    sys_times_h => [],
d873 1
a873 1
    sys_types_h => [],
d903 1
a903 1
		_SC_NGROUPS_MAX _SC_OPEN_MAX _SC_PAGESIZE _SC_SAVED_IDS
d911 1
a911 1
    utime_h =>	[],
d921 16
a936 55
		abs
		alarm
		atan2
		chdir
		chmod
		chown
		close
		closedir
		cos
		exit
		exp
		fcntl
		fileno
		fork
		getc
		getgrgid
		getgrnam
		getlogin
		getpgrp
		getppid
		getpwnam
		getpwuid
		gmtime
		isatty
		kill
		link
		localtime
		log
		mkdir
		nice
		open
		opendir
		pipe
		printf
		rand
		read
		readdir
		rename
		rewinddir
		rmdir
		sin
		sleep
		sprintf
		sqrt
		srand
		stat
		system
		time
		times
		umask
		unlink
		utime
		wait
		waitpid
		write
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@a4 2
our $VERSION = "1.06" ;

d9 2
d54 3
a56 6
package POSIX::SigAction;

use AutoLoader 'AUTOLOAD';
sub new { bless {HANDLER => $_[1], MASK => $_[2], FLAGS => $_[3] || 0, SAFE => 0}, $_[0] }

package POSIX;
a281 4
sub fsync {
    redef "IO::Handle::sync()";
}

d421 1
a421 1
    unimpl "div() is C-specific, use /, % and int instead";
d443 1
a443 1
    unimpl "ldiv() is C-specific, use /, % and int instead";
d878 1
a878 1
		fpathconf fsync getcwd getegid geteuid getgid getgroups
a950 7

package POSIX::SigAction;

sub handler { $_[0]->{HANDLER} = $_[1] if @@_ > 1; $_[0]->{HANDLER} };
sub mask    { $_[0]->{MASK}    = $_[1] if @@_ > 1; $_[0]->{MASK} };
sub flags   { $_[0]->{FLAGS}   = $_[1] if @@_ > 1; $_[0]->{FLAGS} };
sub safe    { $_[0]->{SAFE}    = $_[1] if @@_ > 1; $_[0]->{SAFE} };
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d5 1
a5 1
our $VERSION = "1.07";
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d5 1
a5 1
our $VERSION = "1.08";
d626 1
a626 1
    usage "chown(uid, gid, filename)" if @@_ != 3;
a923 1
		lchown
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d5 1
a5 1
our $VERSION = "1.09";
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@a1 2
use strict;
use warnings;
d3 1
a3 1
our(@@ISA, %EXPORT_TAGS, @@EXPORT_OK, @@EXPORT, $AUTOLOAD, %SIGRT) = ();
d5 1
a5 1
our $VERSION = "1.13";
a10 5
use Fcntl qw(FD_CLOEXEC F_DUPFD F_GETFD F_GETFL F_GETLK F_RDLCK F_SETFD
	     F_SETFL F_SETLK F_SETLKW F_UNLCK F_WRLCK O_ACCMODE O_APPEND
	     O_CREAT O_EXCL O_NOCTTY O_NONBLOCK O_RDONLY O_RDWR O_TRUNC
	     O_WRONLY);

a32 2
    no strict;
    no warnings 'uninitialized';
d57 1
a57 15

package POSIX::SigRt;

use AutoLoader 'AUTOLOAD';

use Tie::Hash;

use vars qw($SIGACTION_FLAGS $_SIGRTMIN $_SIGRTMAX $_sigrtn @@ISA);
@@POSIX::SigRt::ISA = qw(Tie::StdHash);

$SIGACTION_FLAGS = 0;

tie %POSIX::SIGRT, 'POSIX::SigRt';

sub DESTROY {};
d352 1
a352 1
    (-d $_[0]) ? CORE::rmdir($_[0]) : CORE::unlink($_[0]);
d815 4
a818 4
		SIGPIPE %SIGRT SIGRTMIN SIGRTMAX SIGQUIT SIGSEGV SIGSTOP
		SIGTERM SIGTSTP SIGTTIN	SIGTTOU SIGUSR1 SIGUSR2
		SIG_BLOCK SIG_DFL SIG_ERR SIG_IGN SIG_SETMASK SIG_UNBLOCK
		raise sigaction signal sigpending sigprocmask sigsuspend)],
d894 2
a895 7
{
  # De-duplicate the export list: 
  my %export;
  @@export{map {@@$_} values %EXPORT_TAGS} = ();
  # Doing the de-dup with a temporary hash has the advantage that the SVs in
  # @@EXPORT are actually shared hash key sacalars, which will save some memory.
  push @@EXPORT, keys %export;
a961 1
sub new { bless {HANDLER => $_[1], MASK => $_[2], FLAGS => $_[3] || 0, SAFE => 0}, $_[0] }
a965 55

package POSIX::SigRt;


sub _init {
    $_SIGRTMIN = &POSIX::SIGRTMIN;
    $_SIGRTMAX = &POSIX::SIGRTMAX;
    $_sigrtn   = $_SIGRTMAX - $_SIGRTMIN;
}

sub _croak {
    &_init unless defined $_sigrtn;
    die "POSIX::SigRt not available" unless defined $_sigrtn && $_sigrtn > 0;
}

sub _getsig {
    &_croak;
    my $rtsig = $_[0];
    # Allow (SIGRT)?MIN( + n)?, a common idiom when doing these things in C.
    $rtsig = $_SIGRTMIN + ($1 || 0)
	if $rtsig =~ /^(?:(?:SIG)?RT)?MIN(\s*\+\s*(\d+))?$/;
    return $rtsig;
}

sub _exist {
    my $rtsig = _getsig($_[1]);
    my $ok    = $rtsig >= $_SIGRTMIN && $rtsig <= $_SIGRTMAX;
    ($rtsig, $ok);
}

sub _check {
    my ($rtsig, $ok) = &_exist;
    die "No POSIX::SigRt signal $_[1] (valid range SIGRTMIN..SIGRTMAX, or $_SIGRTMIN..$_SIGRTMAX)"
	unless $ok;
    return $rtsig;
}

sub new {
    my ($rtsig, $handler, $flags) = @@_;
    my $sigset = POSIX::SigSet->new($rtsig);
    my $sigact = POSIX::SigAction->new($handler,
				       $sigset,
				       $flags);
    POSIX::sigaction($rtsig, $sigact);
}

sub EXISTS { &_exist }
sub FETCH  { my $rtsig = &_check;
	     my $oa = POSIX::SigAction->new();
	     POSIX::sigaction($rtsig, undef, $oa);
	     return $oa->{HANDLER} }
sub STORE  { my $rtsig = &_check; new($rtsig, $_[2], $SIGACTION_FLAGS) }
sub DELETE { delete $SIG{ &_check } }
sub CLEAR  { &_exist; delete @@SIG{ &POSIX::SIGRTMIN .. &POSIX::SIGRTMAX } }
sub SCALAR { &_croak; $_sigrtn + 1 }
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d7 1
a7 1
our $VERSION = "1.17";
d16 1
a16 4
	     O_WRONLY SEEK_CUR SEEK_END SEEK_SET
	     S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG
	     S_IRGRP S_IROTH S_IRUSR S_IRWXG S_IRWXO S_IRWXU S_ISGID S_ISUID
	     S_IWGRP S_IWOTH S_IWUSR S_IXGRP S_IXOTH S_IXUSR);
d35 4
d50 9
a58 3
    my ($error, $val) = constant($constname);
    croak $error if $error;
    *$AUTOLOAD = sub { $val };
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d7 1
a7 1
our $VERSION = "1.19";
@


