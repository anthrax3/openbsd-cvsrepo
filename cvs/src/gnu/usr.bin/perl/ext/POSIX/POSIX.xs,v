head	1.23;
access;
symbols
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.22.0.8
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.15.0.10
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.8
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.6
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.12.0.10
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.23
date	2017.02.05.00.32.13;	author afresh1;	state Exp;
branches;
next	1.22;
commitid	cxJ08BvJA9Pt2PTM;

1.22
date	2015.04.25.19.26.22;	author afresh1;	state Exp;
branches;
next	1.21;
commitid	3qGYFVvfrExB70FB;

1.21
date	2015.04.25.19.14.46;	author afresh1;	state Exp;
branches;
next	1.20;
commitid	XRK22kO4se3v2i2I;

1.20
date	2014.11.17.21.01.00;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	LnErp1MFKSuew5Fr;

1.19
date	2014.11.17.20.57.06;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	QP75iYx42Uo7mMxO;

1.18
date	2014.07.14.07.22.06;	author pelikan;	state Exp;
branches;
next	1.17;
commitid	2T7dYu6PlirmmPvO;

1.17
date	2014.03.24.15.05.27;	author afresh1;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.25.20.40.54;	author sthen;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.24.15.06.57;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.12.18.24.33;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.29.17.36.06;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.28.19.23.04;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.15.21.30.28;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.09.18.09.20;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.07.21.33.03;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.03.03.02.32;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.24.16.28.03;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.23;	author millert;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.05.24.18.35.15;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.05.30;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.33;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.55.41;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.09;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.09;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.38.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.18;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.56;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.52;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.07;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.46.25;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.59;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.48.19;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.23;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.11.12;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.51;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.08.46;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.59.02;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.53.06;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;

1.6.2.1
date	2003.07.10.23.23.54;	author brad;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#define PERL_EXT_POSIX

#ifdef NETWARE
	#define _POSIX_
	/*
	 * Ideally this should be somewhere down in the includes
	 * but putting it in other places is giving compiler errors.
	 * Also here I am unable to check for HAS_UNAME since it wouldn't have
	 * yet come into the file at this stage - sgp 18th Oct 2000
	 */
	#include <sys/utsname.h>
#endif	/* NETWARE */

#define PERL_NO_GET_CONTEXT

#include "EXTERN.h"
#define PERLIO_NOT_STDIO 1
#include "perl.h"
#include "XSUB.h"
#if defined(PERL_IMPLICIT_SYS)
#  undef signal
#  undef open
#  undef setmode
#  define open PerlLIO_open3
#endif
#include <ctype.h>
#ifdef I_DIRENT    /* XXX maybe better to just rely on perl.h? */
#include <dirent.h>
#endif
#include <errno.h>
#ifdef WIN32
#include <sys/errno2.h>
#endif
#ifdef I_FLOAT
#include <float.h>
#endif
#ifdef I_FENV
#include <fenv.h>
#endif
#ifdef I_LIMITS
#include <limits.h>
#endif
#include <locale.h>
#include <math.h>
#ifdef I_PWD
#include <pwd.h>
#endif
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>

#ifdef I_STDDEF
#include <stddef.h>
#endif

#ifdef I_UNISTD
#include <unistd.h>
#endif

#if defined(USE_QUADMATH) && defined(I_QUADMATH)

#  undef M_E
#  undef M_LOG2E
#  undef M_LOG10E
#  undef M_LN2
#  undef M_LN10
#  undef M_PI
#  undef M_PI_2
#  undef M_PI_4
#  undef M_1_PI
#  undef M_2_PI
#  undef M_2_SQRTPI
#  undef M_SQRT2
#  undef M_SQRT1_2

#  define M_E        M_Eq
#  define M_LOG2E    M_LOG2Eq
#  define M_LOG10E   M_LOG10Eq
#  define M_LN2      M_LN2q
#  define M_LN10     M_LN10q
#  define M_PI       M_PIq
#  define M_PI_2     M_PI_2q
#  define M_PI_4     M_PI_4q
#  define M_1_PI     M_1_PIq
#  define M_2_PI     M_2_PIq
#  define M_2_SQRTPI M_2_SQRTPIq
#  define M_SQRT2    M_SQRT2q
#  define M_SQRT1_2  M_SQRT1_2q

#else

#  ifdef USE_LONG_DOUBLE
#    undef M_E
#    undef M_LOG2E
#    undef M_LOG10E
#    undef M_LN2
#    undef M_LN10
#    undef M_PI
#    undef M_PI_2
#    undef M_PI_4
#    undef M_1_PI
#    undef M_2_PI
#    undef M_2_SQRTPI
#    undef M_SQRT2
#    undef M_SQRT1_2
#    define FLOAT_C(c) CAT2(c,L)
#  else
#    define FLOAT_C(c) (c)
#  endif

#  ifndef M_E
#    define M_E		FLOAT_C(2.71828182845904523536028747135266250)
#  endif
#  ifndef M_LOG2E
#    define M_LOG2E	FLOAT_C(1.44269504088896340735992468100189214)
#  endif
#  ifndef M_LOG10E
#    define M_LOG10E	FLOAT_C(0.434294481903251827651128918916605082)
#  endif
#  ifndef M_LN2
#    define M_LN2	FLOAT_C(0.693147180559945309417232121458176568)
#  endif
#  ifndef M_LN10
#    define M_LN10	FLOAT_C(2.30258509299404568401799145468436421)
#  endif
#  ifndef M_PI
#    define M_PI	FLOAT_C(3.14159265358979323846264338327950288)
#  endif
#  ifndef M_PI_2
#    define M_PI_2	FLOAT_C(1.57079632679489661923132169163975144)
#  endif
#  ifndef M_PI_4
#    define M_PI_4	FLOAT_C(0.785398163397448309615660845819875721)
#  endif
#  ifndef M_1_PI
#    define M_1_PI	FLOAT_C(0.318309886183790671537767526745028724)
#  endif
#  ifndef M_2_PI
#    define M_2_PI	FLOAT_C(0.636619772367581343075535053490057448)
#  endif
#  ifndef M_2_SQRTPI
#    define M_2_SQRTPI	FLOAT_C(1.12837916709551257389615890312154517)
#  endif
#  ifndef M_SQRT2
#    define M_SQRT2	FLOAT_C(1.41421356237309504880168872420969808)
#  endif
#  ifndef M_SQRT1_2
#    define M_SQRT1_2	FLOAT_C(0.707106781186547524400844362104849039)
#  endif

#endif

#if !defined(INFINITY) && defined(NV_INF)
#  define INFINITY NV_INF
#endif

#if !defined(NAN) && defined(NV_NAN)
#  define NAN NV_NAN
#endif

#if !defined(Inf) && defined(NV_INF)
#  define Inf NV_INF
#endif

#if !defined(NaN) && defined(NV_NAN)
#  define NaN NV_NAN
#endif

/* We will have an emulation. */
#ifndef FP_INFINITE
#  define FP_INFINITE	0
#  define FP_NAN	1
#  define FP_NORMAL	2
#  define FP_SUBNORMAL	3
#  define FP_ZERO	4
#endif

/* We will have an emulation. */
#ifndef FE_TONEAREST
#  define FE_TOWARDZERO	0
#  define FE_TONEAREST	1
#  define FE_UPWARD	2
#  define FE_DOWNWARD	3
#endif

/* C89 math.h:

   acos asin atan atan2 ceil cos cosh exp fabs floor fmod frexp ldexp
   log log10 modf pow sin sinh sqrt tan tanh

 * Implemented in core:

   atan2 cos exp log pow sin sqrt

 * C99 math.h added:

   acosh asinh atanh cbrt copysign erf erfc exp2 expm1 fdim fma fmax
   fmin fpclassify hypot ilogb isfinite isgreater isgreaterequal isinf
   isless islessequal islessgreater isnan isnormal isunordered lgamma
   log1p log2 logb lrint lround nan nearbyint nextafter nexttoward remainder
   remquo rint round scalbn signbit tgamma trunc

   See:
   http://pubs.opengroup.org/onlinepubs/009695399/basedefs/math.h.html

 * Berkeley/SVID extensions:

   j0 j1 jn y0 y1 yn

 * Configure already (5.21.5) scans for:

   copysign*l* fpclassify isfinite isinf isnan isnan*l* ilogb*l* signbit scalbn*l*

 * For floating-point round mode (which matters for e.g. lrint and rint)

   fegetround fesetround

*/

/* XXX Constant FP_FAST_FMA (if true, FMA is faster) */

/* XXX Add ldiv(), lldiv()?  It's C99, but from stdlib.h, not math.h  */

/* XXX Beware old gamma() -- one cannot know whether that is the
 * gamma or the log of gamma, that's why the new tgamma and lgamma.
 * Though also remember lgamma_r. */

/* Certain AIX releases have the C99 math, but not in long double.
 * The <math.h> has them, e.g. __expl128, but no library has them!
 *
 * Also see the comments in hints/aix.sh about long doubles. */

#if defined(USE_QUADMATH) && defined(I_QUADMATH)
#  define c99_acosh	acoshq
#  define c99_asinh	asinhq
#  define c99_atanh	atanhq
#  define c99_cbrt	cbrtq
#  define c99_copysign	copysignq
#  define c99_erf	erfq
#  define c99_erfc	erfcq
/* no exp2q */
#  define c99_expm1	expm1q
#  define c99_fdim	fdimq
#  define c99_fma	fmaq
#  define c99_fmax	fmaxq
#  define c99_fmin	fminq
#  define c99_hypot	hypotq
#  define c99_ilogb	ilogbq
#  define c99_lgamma	lgammaq
#  define c99_log1p	log1pq
#  define c99_log2	log2q
/* no logbq */
#  if defined(USE_64_BIT_INT) && QUADKIND == QUAD_IS_LONG_LONG
#    define c99_lrint	llrintq
#    define c99_lround	llroundq
#  else
#    define c99_lrint	lrintq
#    define c99_lround	lroundq
#  endif
#  define c99_nan	nanq
#  define c99_nearbyint	nearbyintq
#  define c99_nextafter	nextafterq
/* no nexttowardq */
#  define c99_remainder	remainderq
#  define c99_remquo	remquoq
#  define c99_rint	rintq
#  define c99_round	roundq
#  define c99_scalbn	scalbnq
#  define c99_signbit	signbitq
#  define c99_tgamma	tgammaq
#  define c99_trunc	truncq
#  define bessel_j0 j0q
#  define bessel_j1 j1q
#  define bessel_jn jnq
#  define bessel_y0 y0q
#  define bessel_y1 y1q
#  define bessel_yn ynq
#elif defined(USE_LONG_DOUBLE) && \
  (defined(HAS_FREXPL) || defined(HAS_ILOGBL)) && defined(HAS_SQRTL)
/* Use some of the Configure scans for long double math functions
 * as the canary for all the C99 *l variants being defined. */
#  define c99_acosh	acoshl
#  define c99_asinh	asinhl
#  define c99_atanh	atanhl
#  define c99_cbrt	cbrtl
#  define c99_copysign	copysignl
#  define c99_erf	erfl
#  define c99_erfc	erfcl
#  define c99_exp2	exp2l
#  define c99_expm1	expm1l
#  define c99_fdim	fdiml
#  define c99_fma	fmal
#  define c99_fmax	fmaxl
#  define c99_fmin	fminl
#  define c99_hypot	hypotl
#  define c99_ilogb	ilogbl
#  define c99_lgamma	lgammal
#  define c99_log1p	log1pl
#  define c99_log2	log2l
#  define c99_logb	logbl
#  if defined(USE_64_BIT_INT) && QUADKIND == QUAD_IS_LONG_LONG && defined(HAS_LLRINTL)
#    define c99_lrint	llrintl
#  elif defined(HAS_LRINTL)
#    define c99_lrint	lrintl
#  endif
#  if defined(USE_64_BIT_INT) && QUADKIND == QUAD_IS_LONG_LONG && defined(HAS_LLROUNDL)
#    define c99_lround	llroundl
#  elif defined(HAS_LROUNDL)
#    define c99_lround	lroundl
#  endif
#  define c99_nan	nanl
#  define c99_nearbyint	nearbyintl
#  define c99_nextafter	nextafterl
#  define c99_nexttoward	nexttowardl
#  define c99_remainder	remainderl
#  define c99_remquo	remquol
#  define c99_rint	rintl
#  define c99_round	roundl
#  define c99_scalbn	scalbnl
#  ifdef HAS_SIGNBIT /* possibly bad assumption */
#    define c99_signbit	signbitl
#  endif
#  define c99_tgamma	tgammal
#  define c99_trunc	truncl
#else
#  define c99_acosh	acosh
#  define c99_asinh	asinh
#  define c99_atanh	atanh
#  define c99_cbrt	cbrt
#  define c99_copysign	copysign
#  define c99_erf	erf
#  define c99_erfc	erfc
#  define c99_exp2	exp2
#  define c99_expm1	expm1
#  define c99_fdim	fdim
#  define c99_fma	fma
#  define c99_fmax	fmax
#  define c99_fmin	fmin
#  define c99_hypot	hypot
#  define c99_ilogb	ilogb
#  define c99_lgamma	lgamma
#  define c99_log1p	log1p
#  define c99_log2	log2
#  define c99_logb	logb
#  if defined(USE_64_BIT_INT) && QUADKIND == QUAD_IS_LONG_LONG && defined(HAS_LLRINT)
#    define c99_lrint	llrint
#  else
#    define c99_lrint	lrint
#  endif
#  if defined(USE_64_BIT_INT) && QUADKIND == QUAD_IS_LONG_LONG && defined(HAS_LLROUND)
#    define c99_lround	llround
#  else
#    define c99_lround	lround
#  endif
#  define c99_nan	nan
#  define c99_nearbyint	nearbyint
#  define c99_nextafter	nextafter
#  define c99_nexttoward	nexttoward
#  define c99_remainder	remainder
#  define c99_remquo	remquo
#  define c99_rint	rint
#  define c99_round	round
#  define c99_scalbn	scalbn
/* We already define Perl_signbit in perl.h. */
#  ifdef HAS_SIGNBIT
#    define c99_signbit	signbit
#  endif
#  define c99_tgamma	tgamma
#  define c99_trunc	trunc
#endif

/* AIX xlc (__IBMC__) really doesn't have the following long double
 * math interfaces (no __acoshl128 aka acoshl, etc.), see
 * hints/aix.sh.  These are in the -lc128 but fail to be found
 * during dynamic linking/loading.
 *
 * XXX1 Better Configure scans
 * XXX2 Is this xlc version dependent? */
#if defined(USE_LONG_DOUBLE) && defined(__IBMC__)
#  undef c99_acosh
#  undef c99_asinh
#  undef c99_atanh
#  undef c99_cbrt
#  undef c99_copysign
#  undef c99_exp2
#  undef c99_expm1
#  undef c99_fdim
#  undef c99_fma
#  undef c99_fmax
#  undef c99_fmin
#  undef c99_hypot
#  undef c99_ilogb
#  undef c99_lrint
#  undef c99_lround
#  undef c99_log1p
#  undef c99_log2
#  undef c99_logb
#  undef c99_nan
#  undef c99_nearbyint
#  undef c99_nextafter
#  undef c99_nexttoward
#  undef c99_remainder
#  undef c99_remquo
#  undef c99_rint
#  undef c99_round
#  undef c99_scalbn
#  undef c99_tgamma
#  undef c99_trunc
#endif

#ifndef isunordered
#  ifdef Perl_isnan
#    define isunordered(x, y) (Perl_isnan(x) || Perl_isnan(y))
#  elif defined(HAS_UNORDERED)
#    define isunordered(x, y) unordered(x, y)
#  endif
#endif

/* XXX these isgreater/isnormal/isunordered macros definitions should
 * be moved further in the file to be part of the emulations, so that
 * platforms can e.g. #undef c99_isunordered and have it work like
 * it does for the other interfaces. */

#if !defined(isgreater) && defined(isunordered)
#  define isgreater(x, y)         (!isunordered((x), (y)) && (x) > (y))
#  define isgreaterequal(x, y)    (!isunordered((x), (y)) && (x) >= (y))
#  define isless(x, y)            (!isunordered((x), (y)) && (x) < (y))
#  define islessequal(x, y)       (!isunordered((x), (y)) && (x) <= (y))
#  define islessgreater(x, y)     (!isunordered((x), (y)) && \
                                     ((x) > (y) || (y) > (x)))
#endif

/* Check both the Configure symbol and the macro-ness (like C99 promises). */ 
#if defined(HAS_FPCLASSIFY) && defined(fpclassify)
#  define c99_fpclassify	fpclassify
#endif
/* Like isnormal(), the isfinite(), isinf(), and isnan() are also C99
   and also (sizeof-arg-aware) macros, but they are already well taken
   care of by Configure et al, and defined in perl.h as
   Perl_isfinite(), Perl_isinf(), and Perl_isnan(). */
#ifdef isnormal
#  define c99_isnormal	isnormal
#endif
#ifdef isgreater /* canary for all the C99 is*<cmp>* macros. */
#  define c99_isgreater	isgreater
#  define c99_isgreaterequal	isgreaterequal
#  define c99_isless		isless
#  define c99_islessequal	islessequal
#  define c99_islessgreater	islessgreater
#  define c99_isunordered	isunordered
#endif

/* The Great Wall of Undef where according to the definedness of HAS_FOO symbols
 * the corresponding c99_foo wrappers are undefined.  This list doesn't include
 * the isfoo() interfaces because they are either type-aware macros, or dealt
 * separately, already in perl.h */

#ifndef HAS_ACOSH
#  undef c99_acosh
#endif
#ifndef HAS_ASINH
#  undef c99_asinh
#endif
#ifndef HAS_ATANH
#  undef c99_atanh
#endif
#ifndef HAS_CBRT
#  undef c99_cbrt
#endif
#ifndef HAS_COPYSIGN
#  undef c99_copysign
#endif
#ifndef HAS_ERF
#  undef c99_erf
#endif
#ifndef HAS_ERFC
#  undef c99_erfc
#endif
#ifndef HAS_EXP2
#  undef c99_exp2
#endif
#ifndef HAS_EXPM1
#  undef c99_expm1
#endif
#ifndef HAS_FDIM
#  undef c99_fdim
#endif
#ifndef HAS_FMA
#  undef c99_fma
#endif
#ifndef HAS_FMAX
#  undef c99_fmax
#endif
#ifndef HAS_FMIN
#  undef c99_fmin
#endif
#ifndef HAS_FPCLASSIFY
#  undef c99_fpclassify
#endif
#ifndef HAS_HYPOT
#  undef c99_hypot
#endif
#ifndef HAS_ILOGB
#  undef c99_ilogb
#endif
#ifndef HAS_LGAMMA
#  undef c99_lgamma
#endif
#ifndef HAS_LOG1P
#  undef c99_log1p
#endif
#ifndef HAS_LOG2
#  undef c99_log2
#endif
#ifndef HAS_LOGB
#  undef c99_logb
#endif
#ifndef HAS_LRINT
#  undef c99_lrint
#endif
#ifndef HAS_LROUND
#  undef c99_lround
#endif
#ifndef HAS_NAN
#  undef c99_nan
#endif
#ifndef HAS_NEARBYINT
#  undef c99_nearbyint
#endif
#ifndef HAS_NEXTAFTER
#  undef c99_nextafter
#endif
#ifndef HAS_NEXTTOWARD
#  undef c99_nexttoward
#endif
#ifndef HAS_REMAINDER
#  undef c99_remainder
#endif
#ifndef HAS_REMQUO
#  undef c99_remquo
#endif
#ifndef HAS_RINT
#  undef c99_rint
#endif
#ifndef HAS_ROUND
#  undef c99_round
#endif
#ifndef HAS_SCALBN
#  undef c99_scalbn
#endif
#ifndef HAS_SIGNBIT
#  undef c99_signbit
#endif
#ifndef HAS_TGAMMA
#  undef c99_tgamma
#endif
#ifndef HAS_TRUNC
#  undef c99_trunc
#endif

#ifdef WIN32

/* Some APIs exist under Win32 with "underbar" names. */
#  undef c99_hypot
#  undef c99_logb
#  undef c99_nextafter
#  define c99_hypot _hypot
#  define c99_logb _logb
#  define c99_nextafter _nextafter

#  define bessel_j0 _j0
#  define bessel_j1 _j1
#  define bessel_jn _jn
#  define bessel_y0 _y0
#  define bessel_y1 _y1
#  define bessel_yn _yn

#endif

/* The Bessel functions: BSD, SVID, XPG4, and POSIX.  But not C99. */
#if defined(HAS_J0) && !defined(bessel_j0)
#  if defined(USE_LONG_DOUBLE) && defined(HAS_J0L)
#    define bessel_j0 j0l
#    define bessel_j1 j1l
#    define bessel_jn jnl
#    define bessel_y0 y0l
#    define bessel_y1 y1l
#    define bessel_yn ynl
#  else
#    define bessel_j0 j0
#    define bessel_j1 j1
#    define bessel_jn jn
#    define bessel_y0 y0
#    define bessel_y1 y1
#    define bessel_yn yn
#  endif
#endif

/* Emulations for missing math APIs.
 *
 * Keep in mind that the point of many of these functions is that
 * they, if available, are supposed to give more precise/more
 * numerically stable results.
 *
 * See e.g. http://www.johndcook.com/math_h.html
 */

#ifndef c99_acosh
static NV my_acosh(NV x)
{
  return Perl_log(x + Perl_sqrt(x * x - 1));
}
#  define c99_acosh my_acosh
#endif

#ifndef c99_asinh
static NV my_asinh(NV x)
{
  return Perl_log(x + Perl_sqrt(x * x + 1));
}
#  define c99_asinh my_asinh
#endif

#ifndef c99_atanh
static NV my_atanh(NV x)
{
  return (Perl_log(1 + x) - Perl_log(1 - x)) / 2;
}
#  define c99_atanh my_atanh
#endif

#ifndef c99_cbrt
static NV my_cbrt(NV x)
{
  static const NV one_third = (NV)1.0/3;
  return x >= 0.0 ? Perl_pow(x, one_third) : -Perl_pow(-x, one_third);
}
#  define c99_cbrt my_cbrt
#endif

#ifndef c99_copysign
static NV my_copysign(NV x, NV y)
{
  return y >= 0 ? (x < 0 ? -x : x) : (x < 0 ? x : -x);
}
#  define c99_copysign my_copysign
#endif

/* XXX cosh (though c89) */

#ifndef c99_erf
static NV my_erf(NV x)
{
  /* http://www.johndcook.com/cpp_erf.html -- public domain */
  NV a1 =  0.254829592;
  NV a2 = -0.284496736;
  NV a3 =  1.421413741;
  NV a4 = -1.453152027;
  NV a5 =  1.061405429;
  NV p  =  0.3275911;
  NV t, y;
  int sign = x < 0 ? -1 : 1; /* Save the sign. */
  x = PERL_ABS(x);

  /* Abramowitz and Stegun formula 7.1.26 */
  t = 1.0 / (1.0 + p * x);
  y = 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1) * t * Perl_exp(-x*x);

  return sign * y;
}
#  define c99_erf my_erf
#endif

#ifndef c99_erfc
static NV my_erfc(NV x) {
  /* This is not necessarily numerically stable, but better than nothing. */
  return 1.0 - c99_erf(x);
}
#  define c99_erfc my_erfc
#endif

#ifndef c99_exp2
static NV my_exp2(NV x)
{
  return Perl_pow((NV)2.0, x);
}
#  define c99_exp2 my_exp2
#endif

#ifndef c99_expm1
static NV my_expm1(NV x)
{
  if (PERL_ABS(x) < 1e-5)
    /* http://www.johndcook.com/cpp_expm1.html -- public domain.
     * Taylor series, the first four terms (the last term quartic). */
    /* Probably not enough for long doubles. */
    return x * (1.0 + x * (1/2.0 + x * (1/6.0 + x/24.0)));
  else
    return Perl_exp(x) - 1;
}
#  define c99_expm1 my_expm1
#endif

#ifndef c99_fdim
static NV my_fdim(NV x, NV y)
{
  return (Perl_isnan(x) || Perl_isnan(y)) ? NV_NAN : (x > y ? x - y : 0);
}
#  define c99_fdim my_fdim
#endif

#ifndef c99_fma
static NV my_fma(NV x, NV y, NV z)
{
  return (x * y) + z;
}
#  define c99_fma my_fma
#endif

#ifndef c99_fmax
static NV my_fmax(NV x, NV y)
{
  if (Perl_isnan(x)) {
    return Perl_isnan(y) ? NV_NAN : y;
  } else if (Perl_isnan(y)) {
    return x;
  }
  return x > y ? x : y;
}
#  define c99_fmax my_fmax
#endif

#ifndef c99_fmin
static NV my_fmin(NV x, NV y)
{
  if (Perl_isnan(x)) {
    return Perl_isnan(y) ? NV_NAN : y;
  } else if (Perl_isnan(y)) {
    return x;
  }
  return x < y ? x : y;
}
#  define c99_fmin my_fmin
#endif

#ifndef c99_fpclassify

static IV my_fpclassify(NV x)
{
#ifdef Perl_fp_class_inf
  if (Perl_fp_class_inf(x))    return FP_INFINITE;
  if (Perl_fp_class_nan(x))    return FP_NAN;
  if (Perl_fp_class_norm(x))   return FP_NORMAL;
  if (Perl_fp_class_denorm(x)) return FP_SUBNORMAL;
  if (Perl_fp_class_zero(x))   return FP_ZERO;
#  define c99_fpclassify my_fpclassify
#endif
  return -1;
}

#endif

#ifndef c99_hypot
static NV my_hypot(NV x, NV y)
{
  /* http://en.wikipedia.org/wiki/Hypot */
  NV t;
  x = PERL_ABS(x); /* Take absolute values. */
  if (y == 0)
    return x;
  if (Perl_isnan(y))
    return NV_INF;
  y = PERL_ABS(y);
  if (x < y) { /* Swap so that y is less. */
    t = x;
    x = y;
    y = t;
  }
  t = y / x;
  return x * Perl_sqrt(1.0 + t * t);
}
#  define c99_hypot my_hypot
#endif

#ifndef c99_ilogb
static IV my_ilogb(NV x)
{
  return (IV)(Perl_log(x) * M_LOG2E);
}
#  define c99_ilogb my_ilogb
#endif

/* tgamma and lgamma emulations based on
 * http://www.johndcook.com/cpp_gamma.html,
 * code placed in public domain.
 *
 * Note that these implementations (neither the johndcook originals
 * nor these) do NOT set the global signgam variable.  This is not
 * necessarily a bad thing. */

/* Note that the tgamma() and lgamma() implementations
 * here depend on each other. */

#if !defined(HAS_TGAMMA) || !defined(c99_tgamma)
static NV my_tgamma(NV x);
#  define c99_tgamma my_tgamma
#  define USE_MY_TGAMMA
#endif
#if !defined(HAS_LGAMMA) || !defined(c99_lgamma)
static NV my_lgamma(NV x);
#  define c99_lgamma my_lgamma
#  define USE_MY_LGAMMA
#endif

#ifdef USE_MY_TGAMMA
static NV my_tgamma(NV x)
{
  const NV gamma = 0.577215664901532860606512090; /* Euler's gamma constant. */
  if (Perl_isnan(x) || x < 0.0)
    return NV_NAN;
  if (x == 0.0 || x == NV_INF)
    return x == -0.0 ? -NV_INF : NV_INF;

  /* The function domain is split into three intervals:
   * (0, 0.001), [0.001, 12), and (12, infinity) */

  /* First interval: (0, 0.001)
   * For small values, 1/tgamma(x) has power series x + gamma x^2,
   * so in this range, 1/tgamma(x) = x + gamma x^2 with error on the order of x^3.
   * The relative error over this interval is less than 6e-7. */
  if (x < 0.001)
    return 1.0 / (x * (1.0 + gamma * x));

  /* Second interval: [0.001, 12) */
  if (x < 12.0) {
    double y = x; /* Working copy. */
    int n = 0;
    /* Numerator coefficients for approximation over the interval (1,2) */
    static const NV p[] = {
      -1.71618513886549492533811E+0,
      2.47656508055759199108314E+1,
      -3.79804256470945635097577E+2,
      6.29331155312818442661052E+2,
      8.66966202790413211295064E+2,
      -3.14512729688483675254357E+4,
      -3.61444134186911729807069E+4,
      6.64561438202405440627855E+4
    };
    /* Denominator coefficients for approximation over the interval (1, 2) */
    static const NV q[] = {
      -3.08402300119738975254353E+1,
      3.15350626979604161529144E+2,
      -1.01515636749021914166146E+3,
      -3.10777167157231109440444E+3,
      2.25381184209801510330112E+4,
      4.75584627752788110767815E+3,
      -1.34659959864969306392456E+5,
      -1.15132259675553483497211E+5
    };
    NV num = 0.0;
    NV den = 1.0;
    NV z;
    NV result;
    int i;

    if (x < 1.0)
      y += 1.0;
    else {
      n = (int)Perl_floor(y) - 1;
      y -= n;
    }
    z = y - 1;
    for (i = 0; i < 8; i++) {
      num = (num + p[i]) * z;
      den = den * z + q[i];
    }
    result = num / den + 1.0;

    if (x < 1.0) {
      /* Use the identity tgamma(z) = tgamma(z+1)/z
       * The variable "result" now holds tgamma of the original y + 1
       * Thus we use y - 1 to get back the original y. */
      result /= (y - 1.0);
    }
    else {
      /* Use the identity tgamma(z+n) = z*(z+1)* ... *(z+n-1)*tgamma(z) */
      for (i = 0; i < n; i++)
        result *= y++;
    }

    return result;
  }

  /* Third interval: [12, +Inf) */
#if LDBL_MANT_DIG == 113 /* IEEE quad prec */
  if (x > 1755.548) {
    return NV_INF;
  }
#else
  if (x > 171.624) {
    return NV_INF;
  }
#endif

  return Perl_exp(c99_lgamma(x));
}
#endif

#ifdef USE_MY_LGAMMA
static NV my_lgamma(NV x)
{
  if (Perl_isnan(x))
    return NV_NAN;
  if (x <= 0 || x == NV_INF)
    return NV_INF;
  if (x == 1.0 || x == 2.0)
    return 0;
  if (x < 12.0)
    return Perl_log(PERL_ABS(c99_tgamma(x)));
  /* Abramowitz and Stegun 6.1.41
   * Asymptotic series should be good to at least 11 or 12 figures
   * For error analysis, see Whittiker and Watson
   * A Course in Modern Analysis (1927), page 252 */
  {
    static const NV c[8] = {
      1.0/12.0,
      -1.0/360.0,
      1.0/1260.0,
      -1.0/1680.0,
      1.0/1188.0,
      -691.0/360360.0,
      1.0/156.0,
      -3617.0/122400.0
    };
    NV z = 1.0 / (x * x);
    NV sum = c[7];
    static const NV half_log_of_two_pi =
      0.91893853320467274178032973640562;
    NV series;
    int i;
    for (i = 6; i >= 0; i--) {
      sum *= z;
      sum += c[i];
    }
    series = sum / x;
    return (x - 0.5) * Perl_log(x) - x + half_log_of_two_pi + series;
  }
}
#endif

#ifndef c99_log1p
static NV my_log1p(NV x)
{
  /* http://www.johndcook.com/cpp_log_one_plus_x.html -- public domain.
   * Taylor series, the first four terms (the last term quartic). */
  if (x < -1.0)
    return NV_NAN;
  if (x == -1.0)
    return -NV_INF;
  if (PERL_ABS(x) > 1e-4)
    return Perl_log(1.0 + x);
  else
    /* Probably not enough for long doubles. */
    return x * (1.0 + x * (-1/2.0 + x * (1/3.0 - x/4.0)));
}
#  define c99_log1p my_log1p
#endif

#ifndef c99_log2
static NV my_log2(NV x)
{
  return Perl_log(x) * M_LOG2E;
}
#  define c99_log2 my_log2
#endif

/* XXX nextafter */

/* XXX nexttoward */

static int my_fegetround()
{
#ifdef HAS_FEGETROUND
  return fegetround();
#elif defined(HAS_FPGETROUND)
  switch (fpgetround()) {
  case FP_RN: return FE_TONEAREST;
  case FP_RZ: return FE_TOWARDZERO;
  case FP_RM: return FE_DOWNWARD;
  case FP_RP: return FE_UPWARD;
  default: return -1;
  }
#elif defined(FLT_ROUNDS)
  switch (FLT_ROUNDS) {
  case 0: return FE_TOWARDZERO;
  case 1: return FE_TONEAREST;
  case 2: return FE_UPWARD;
  case 3: return FE_DOWNWARD;
  default: return -1;
  }
#elif defined(__osf__) /* Tru64 */
  switch (read_rnd()) {
  case FP_RND_RN: return FE_TONEAREST;
  case FP_RND_RZ: return FE_TOWARDZERO;
  case FP_RND_RM: return FE_DOWNWARD;
  case FP_RND_RP: return FE_UPWARD;
  default: return -1;
  }
#else
  return -1;
#endif
}

/* Toward closest integer. */
#define MY_ROUND_NEAREST(x) ((NV)((IV)((x) >= 0.0 ? (x) + 0.5 : (x) - 0.5)))

/* Toward zero. */
#define MY_ROUND_TRUNC(x) ((NV)((IV)(x)))

/* Toward minus infinity. */
#define MY_ROUND_DOWN(x) ((NV)((IV)((x) >= 0.0 ? (x) : (x) - 0.5)))

/* Toward plus infinity. */
#define MY_ROUND_UP(x) ((NV)((IV)((x) >= 0.0 ? (x) + 0.5 : (x))))

#if (!defined(c99_nearbyint) || !defined(c99_lrint)) && defined(FE_TONEAREST)
static NV my_rint(NV x)
{
#ifdef FE_TONEAREST
  switch (my_fegetround()) {
  case FE_TONEAREST:  return MY_ROUND_NEAREST(x);
  case FE_TOWARDZERO: return MY_ROUND_TRUNC(x);
  case FE_DOWNWARD:   return MY_ROUND_DOWN(x);
  case FE_UPWARD:     return MY_ROUND_UP(x);
  default: return NV_NAN;
  }
#elif defined(HAS_FPGETROUND)
  switch (fpgetround()) {
  case FP_RN: return MY_ROUND_NEAREST(x);
  case FP_RZ: return MY_ROUND_TRUNC(x);
  case FP_RM: return MY_ROUND_DOWN(x);
  case FE_RP: return MY_ROUND_UP(x);
  default: return NV_NAN;
  }
#else
  return NV_NAN;
#endif
}
#endif

/* XXX nearbyint() and rint() are not really identical -- but the difference
 * is messy: nearbyint is defined NOT to raise FE_INEXACT floating point
 * exceptions, while rint() is defined to MAYBE raise them.  At the moment
 * Perl is blissfully unaware of such fine detail of floating point. */
#ifndef c99_nearbyint
#  ifdef FE_TONEAREST
#    define c99_nearbyrint my_rint
#  endif
#endif

#ifndef c99_lrint
#  ifdef FE_TONEAREST
static IV my_lrint(NV x)
{
  return (IV)my_rint(x);
}
#    define c99_lrint my_lrint
#  endif
#endif

#ifndef c99_lround
static IV my_lround(NV x)
{
  return (IV)MY_ROUND_NEAREST(x);
}
#  define c99_lround my_lround
#endif

/* XXX remainder */

/* XXX remquo */

#ifndef c99_rint
#  ifdef FE_TONEAREST
#    define c99_rint my_rint
#  endif
#endif

#ifndef c99_round
static NV my_round(NV x)
{
  return MY_ROUND_NEAREST(x);
}
#  define c99_round my_round
#endif

#ifndef c99_scalbn
#   if defined(Perl_ldexp) && FLT_RADIX == 2
static NV my_scalbn(NV x, int y)
{
  return Perl_ldexp(x, y);
}
#    define c99_scalbn my_scalbn
#  endif
#endif

/* XXX sinh (though c89) */

/* tgamma -- see lgamma */

/* XXX tanh (though c89) */

#ifndef c99_trunc
static NV my_trunc(NV x)
{
  return MY_ROUND_TRUNC(x);
}
#  define c99_trunc my_trunc
#endif

#undef NV_PAYLOAD_DEBUG

/* NOTE: the NaN payload API implementation is hand-rolled, since the
 * APIs are only proposed ones as of June 2015, so very few, if any,
 * platforms have implementations yet, so HAS_SETPAYLOAD and such are
 * unlikely to be helpful.
 *
 * XXX - if the core numification wants to actually generate
 * the nan payload in "nan(123)", and maybe "nans(456)", for
 * signaling payload", this needs to be moved to e.g. numeric.c
 * (look for grok_infnan)
 *
 * Conversely, if the core stringification wants the nan payload
 * and/or the nan quiet/signaling distinction, S_getpayload()
 * from this file needs to be moved, to e.g. sv.c (look for S_infnan_2pv),
 * and the (trivial) functionality of issignaling() copied
 * (for generating "NaNS", or maybe even "NaNQ") -- or maybe there
 * are too many formatting parameters for simple stringification?
 */

/* While it might make sense for the payload to be UV or IV,
 * to avoid conversion loss, the proposed ISO interfaces use
 * a floating point input, which is then truncated to integer,
 * and only the integer part being used.  This is workable,
 * except for: (1) the conversion loss (2) suboptimal for
 * 32-bit integer platforms.  A workaround API for (2) and
 * in general for bit-honesty would be an array of integers
 * as the payload... but the proposed C API does nothing of
 * the kind. */
#if NVSIZE == UVSIZE
#  define NV_PAYLOAD_TYPE UV
#else
#  define NV_PAYLOAD_TYPE NV
#endif

#ifdef LONGDOUBLE_DOUBLEDOUBLE
#  define NV_PAYLOAD_SIZEOF_ASSERT(a) assert(sizeof(a) == NVSIZE / 2)
#else
#  define NV_PAYLOAD_SIZEOF_ASSERT(a) assert(sizeof(a) == NVSIZE)
#endif

static void S_setpayload(NV* nvp, NV_PAYLOAD_TYPE payload, bool signaling)
{
  dTHX;
  static const U8 m[] = { NV_NAN_PAYLOAD_MASK };
  static const U8 p[] = { NV_NAN_PAYLOAD_PERM };
  UV a[(NVSIZE + UVSIZE - 1) / UVSIZE] = { 0 };
  int i;
  NV_PAYLOAD_SIZEOF_ASSERT(m);
  NV_PAYLOAD_SIZEOF_ASSERT(p);
  *nvp = NV_NAN;
  /* Divide the input into the array in "base unsigned integer" in
   * little-endian order.  Note that the integer might be smaller than
   * an NV (if UV is U32, for example). */
#if NVSIZE == UVSIZE
  a[0] = payload;  /* The trivial case. */
#else
  {
    NV t1 = c99_trunc(payload); /* towards zero (drop fractional) */
#ifdef NV_PAYLOAD_DEBUG
    Perl_warn(aTHX_ "t1 = %"NVgf" (payload %"NVgf")\n", t1, payload);
#endif
    if (t1 <= UV_MAX) {
      a[0] = (UV)t1;  /* Fast path, also avoids rounding errors (right?) */
    } else {
      /* UVSIZE < NVSIZE or payload > UV_MAX.
       *
       * This may happen for example if:
       * (1) UVSIZE == 32 and common 64-bit double NV
       *     (32-bit system not using -Duse64bitint)
       * (2) UVSIZE == 64 and the x86-style 80-bit long double NV
       *     (note that here the room for payload is actually the 64 bits)
       * (3) UVSIZE == 64 and the 128-bit IEEE 764 quadruple NV
       *     (112 bits in mantissa, 111 bits room for payload)
       *
       * NOTE: this is very sensitive to correctly functioning
       * fmod()/fmodl(), and correct casting of big-unsigned-integer to NV.
       * If these don't work right, especially the low order bits
       * are in danger.  For example Solaris and AIX seem to have issues
       * here, especially if using 32-bit UVs. */
      NV t2;
      for (i = 0, t2 = t1; i < (int)C_ARRAY_LENGTH(a); i++) {
        a[i] = (UV)Perl_fmod(t2, (NV)UV_MAX);
        t2 = Perl_floor(t2 / (NV)UV_MAX);
      }
    }
  }
#endif
#ifdef NV_PAYLOAD_DEBUG
  for (i = 0; i < (int)C_ARRAY_LENGTH(a); i++) {
    Perl_warn(aTHX_ "a[%d] = 0x%"UVxf"\n", i, a[i]);
  }
#endif
  for (i = 0; i < (int)sizeof(p); i++) {
    if (m[i] && p[i] < sizeof(p)) {
      U8 s = (p[i] % UVSIZE) << 3;
      UV u = a[p[i] / UVSIZE] & ((UV)0xFF << s);
      U8 b = (U8)((u >> s) & m[i]);
      ((U8 *)(nvp))[i] &= ~m[i]; /* For NaNs with non-zero payload bits. */
      ((U8 *)(nvp))[i] |= b;
#ifdef NV_PAYLOAD_DEBUG
      Perl_warn(aTHX_ "set p[%2d] = %02x (i = %d, m = %02x, s = %2d, b = %02x, u = %08"UVxf")\n", i, ((U8 *)(nvp))[i], i, m[i], s, b, u);
#endif
      a[p[i] / UVSIZE] &= ~u;
    }
  }
  if (signaling) {
    NV_NAN_SET_SIGNALING(nvp);
  }
#ifdef USE_LONG_DOUBLE
# if LONG_DOUBLEKIND == 3 || LONG_DOUBLEKIND == 4
#  if LONG_DOUBLESIZE > 10
  memset((char *)nvp + 10, '\0', LONG_DOUBLESIZE - 10); /* x86 long double */
#  endif
# endif
#endif
  for (i = 0; i < (int)C_ARRAY_LENGTH(a); i++) {
    if (a[i]) {
      Perl_warn(aTHX_ "payload lost bits (%"UVxf")", a[i]);
      break;
    }
  }
#ifdef NV_PAYLOAD_DEBUG
  for (i = 0; i < NVSIZE; i++) {
    PerlIO_printf(Perl_debug_log, "%02x ", ((U8 *)(nvp))[i]);
  }
  PerlIO_printf(Perl_debug_log, "\n");
#endif
}

static NV_PAYLOAD_TYPE S_getpayload(NV nv)
{
  dTHX;
  static const U8 m[] = { NV_NAN_PAYLOAD_MASK };
  static const U8 p[] = { NV_NAN_PAYLOAD_PERM };
  UV a[(NVSIZE + UVSIZE - 1) / UVSIZE] = { 0 };
  int i;
  NV payload;
  NV_PAYLOAD_SIZEOF_ASSERT(m);
  NV_PAYLOAD_SIZEOF_ASSERT(p);
  payload = 0;
  for (i = 0; i < (int)sizeof(p); i++) {
    if (m[i] && p[i] < NVSIZE) {
      U8 s = (p[i] % UVSIZE) << 3;
      a[p[i] / UVSIZE] |= (UV)(((U8 *)(&nv))[i] & m[i]) << s;
    }
  }
  for (i = (int)C_ARRAY_LENGTH(a) - 1; i >= 0; i--) {
#ifdef NV_PAYLOAD_DEBUG
    Perl_warn(aTHX_ "a[%d] = %"UVxf"\n", i, a[i]);
#endif
    payload *= UV_MAX;
    payload += a[i];
  }
#ifdef NV_PAYLOAD_DEBUG
  for (i = 0; i < NVSIZE; i++) {
    PerlIO_printf(Perl_debug_log, "%02x ", ((U8 *)(&nv))[i]);
  }
  PerlIO_printf(Perl_debug_log, "\n");
#endif
  return payload;
}

/* XXX This comment is just to make I_TERMIO and I_SGTTY visible to
   metaconfig for future extension writers.  We don't use them in POSIX.
   (This is really sneaky :-)  --AD
*/
#if defined(I_TERMIOS)
#include <termios.h>
#endif
#ifdef I_STDLIB
#include <stdlib.h>
#endif
#ifndef __ultrix__
#include <string.h>
#endif
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>
#ifdef I_UNISTD
#include <unistd.h>
#endif
#include <fcntl.h>

#ifdef HAS_TZNAME
#  if !defined(WIN32) && !defined(__CYGWIN__) && !defined(NETWARE) && !defined(__UWIN__)
extern char *tzname[];
#  endif
#else
#if !defined(WIN32) && !defined(__UWIN__) || (defined(__MINGW32__) && !defined(tzname))
char *tzname[] = { "" , "" };
#endif
#endif

#if defined(__VMS) && !defined(__POSIX_SOURCE)

#  include <utsname.h>

#  undef mkfifo
#  define mkfifo(a,b) (not_here("mkfifo"),-1)

   /* The POSIX notion of ttyname() is better served by getname() under VMS */
   static char ttnambuf[64];
#  define ttyname(fd) (isatty(fd) > 0 ? getname(fd,ttnambuf,0) : NULL)

#else
#if defined (__CYGWIN__)
#    define tzname _tzname
#endif
#if defined (WIN32) || defined (NETWARE)
#  undef mkfifo
#  define mkfifo(a,b) not_here("mkfifo")
#  define ttyname(a) (char*)not_here("ttyname")
#  define sigset_t long
#  define pid_t long
#  ifdef _MSC_VER
#    define mode_t short
#  endif
#  ifdef __MINGW32__
#    define mode_t short
#    ifndef tzset
#      define tzset()		not_here("tzset")
#    endif
#    ifndef _POSIX_OPEN_MAX
#      define _POSIX_OPEN_MAX	FOPEN_MAX	/* XXX bogus ? */
#    endif
#  endif
#  define sigaction(a,b,c)	not_here("sigaction")
#  define sigpending(a)		not_here("sigpending")
#  define sigprocmask(a,b,c)	not_here("sigprocmask")
#  define sigsuspend(a)		not_here("sigsuspend")
#  define sigemptyset(a)	not_here("sigemptyset")
#  define sigaddset(a,b)	not_here("sigaddset")
#  define sigdelset(a,b)	not_here("sigdelset")
#  define sigfillset(a)		not_here("sigfillset")
#  define sigismember(a,b)	not_here("sigismember")
#ifndef NETWARE
#  undef setuid
#  undef setgid
#  define setuid(a)		not_here("setuid")
#  define setgid(a)		not_here("setgid")
#endif	/* NETWARE */
#ifndef USE_LONG_DOUBLE
#  define strtold(s1,s2)	not_here("strtold")
#endif  /* USE_LONG_DOUBLE */
#else

#  ifndef HAS_MKFIFO
#    if defined(OS2) || defined(__amigaos4__)
#      define mkfifo(a,b) not_here("mkfifo")
#    else	/* !( defined OS2 ) */
#      ifndef mkfifo
#        define mkfifo(path, mode) (mknod((path), (mode) | S_IFIFO, 0))
#      endif
#    endif
#  endif /* !HAS_MKFIFO */

#  ifdef I_GRP
#    include <grp.h>
#  endif
#  include <sys/times.h>
#  ifdef HAS_UNAME
#    include <sys/utsname.h>
#  endif
#  ifndef __amigaos4__
#    include <sys/wait.h>
#  endif
#  ifdef I_UTIME
#    include <utime.h>
#  endif
#endif /* WIN32 || NETWARE */
#endif /* __VMS */

typedef int SysRet;
typedef long SysRetLong;
typedef sigset_t* POSIX__SigSet;
typedef HV* POSIX__SigAction;
typedef int POSIX__SigNo;
typedef int POSIX__Fd;
#ifdef I_TERMIOS
typedef struct termios* POSIX__Termios;
#else /* Define termios types to int, and call not_here for the functions.*/
#define POSIX__Termios int
#define speed_t int
#define tcflag_t int
#define cc_t int
#define cfgetispeed(x) not_here("cfgetispeed")
#define cfgetospeed(x) not_here("cfgetospeed")
#define tcdrain(x) not_here("tcdrain")
#define tcflush(x,y) not_here("tcflush")
#define tcsendbreak(x,y) not_here("tcsendbreak")
#define cfsetispeed(x,y) not_here("cfsetispeed")
#define cfsetospeed(x,y) not_here("cfsetospeed")
#define ctermid(x) (char *) not_here("ctermid")
#define tcflow(x,y) not_here("tcflow")
#define tcgetattr(x,y) not_here("tcgetattr")
#define tcsetattr(x,y,z) not_here("tcsetattr")
#endif

/* Possibly needed prototypes */
#ifndef WIN32
START_EXTERN_C
double strtod (const char *, char **);
long strtol (const char *, char **, int);
unsigned long strtoul (const char *, char **, int);
#ifdef HAS_STRTOLD
long double strtold (const char *, char **);
#endif
END_EXTERN_C
#endif

#ifndef HAS_DIFFTIME
#ifndef difftime
#define difftime(a,b) not_here("difftime")
#endif
#endif
#ifndef HAS_FPATHCONF
#define fpathconf(f,n)	(SysRetLong) not_here("fpathconf")
#endif
#ifndef HAS_MKTIME
#define mktime(a) not_here("mktime")
#endif
#ifndef HAS_NICE
#define nice(a) not_here("nice")
#endif
#ifndef HAS_PATHCONF
#define pathconf(f,n)	(SysRetLong) not_here("pathconf")
#endif
#ifndef HAS_SYSCONF
#define sysconf(n)	(SysRetLong) not_here("sysconf")
#endif
#ifndef HAS_READLINK
#define readlink(a,b,c) not_here("readlink")
#endif
#ifndef HAS_SETPGID
#define setpgid(a,b) not_here("setpgid")
#endif
#ifndef HAS_SETSID
#define setsid() not_here("setsid")
#endif
#ifndef HAS_STRCOLL
#define strcoll(s1,s2) not_here("strcoll")
#endif
#ifndef HAS_STRTOD
#define strtod(s1,s2) not_here("strtod")
#endif
#ifndef HAS_STRTOLD
#define strtold(s1,s2) not_here("strtold")
#endif
#ifndef HAS_STRTOL
#define strtol(s1,s2,b) not_here("strtol")
#endif
#ifndef HAS_STRTOUL
#define strtoul(s1,s2,b) not_here("strtoul")
#endif
#ifndef HAS_STRXFRM
#define strxfrm(s1,s2,n) not_here("strxfrm")
#endif
#ifndef HAS_TCGETPGRP
#define tcgetpgrp(a) not_here("tcgetpgrp")
#endif
#ifndef HAS_TCSETPGRP
#define tcsetpgrp(a,b) not_here("tcsetpgrp")
#endif
#ifndef HAS_TIMES
#ifndef NETWARE
#define times(a) not_here("times")
#endif	/* NETWARE */
#endif
#ifndef HAS_UNAME
#define uname(a) not_here("uname")
#endif
#ifndef HAS_WAITPID
#define waitpid(a,b,c) not_here("waitpid")
#endif

#ifndef HAS_MBLEN
#ifndef mblen
#define mblen(a,b) not_here("mblen")
#endif
#endif
#ifndef HAS_MBSTOWCS
#define mbstowcs(s, pwcs, n) not_here("mbstowcs")
#endif
#ifndef HAS_MBTOWC
#define mbtowc(pwc, s, n) not_here("mbtowc")
#endif
#ifndef HAS_WCSTOMBS
#define wcstombs(s, pwcs, n) not_here("wcstombs")
#endif
#ifndef HAS_WCTOMB
#define wctomb(s, wchar) not_here("wcstombs")
#endif
#if !defined(HAS_MBLEN) && !defined(HAS_MBSTOWCS) && !defined(HAS_MBTOWC) && !defined(HAS_WCSTOMBS) && !defined(HAS_WCTOMB)
/* If we don't have these functions, then we wouldn't have gotten a typedef
   for wchar_t, the wide character type.  Defining wchar_t allows the
   functions referencing it to compile.  Its actual type is then meaningless,
   since without the above functions, all sections using it end up calling
   not_here() and croak.  --Kaveh Ghazi (ghazi@@noc.rutgers.edu) 9/18/94. */
#ifndef wchar_t
#define wchar_t char
#endif
#endif

#ifndef HAS_LOCALECONV
#   define localeconv() not_here("localeconv")
#else
struct lconv_offset {
    const char *name;
    size_t offset;
};

static const struct lconv_offset lconv_strings[] = {
#ifdef USE_LOCALE_NUMERIC
    {"decimal_point",     STRUCT_OFFSET(struct lconv, decimal_point)},
    {"thousands_sep",     STRUCT_OFFSET(struct lconv, thousands_sep)},
#  ifndef NO_LOCALECONV_GROUPING
    {"grouping",          STRUCT_OFFSET(struct lconv, grouping)},
#  endif
#endif
#ifdef USE_LOCALE_MONETARY
    {"int_curr_symbol",   STRUCT_OFFSET(struct lconv, int_curr_symbol)},
    {"currency_symbol",   STRUCT_OFFSET(struct lconv, currency_symbol)},
    {"mon_decimal_point", STRUCT_OFFSET(struct lconv, mon_decimal_point)},
#  ifndef NO_LOCALECONV_MON_THOUSANDS_SEP
    {"mon_thousands_sep", STRUCT_OFFSET(struct lconv, mon_thousands_sep)},
#  endif
#  ifndef NO_LOCALECONV_MON_GROUPING
    {"mon_grouping",      STRUCT_OFFSET(struct lconv, mon_grouping)},
#  endif
    {"positive_sign",     STRUCT_OFFSET(struct lconv, positive_sign)},
    {"negative_sign",     STRUCT_OFFSET(struct lconv, negative_sign)},
#endif
    {NULL, 0}
};

#ifdef USE_LOCALE_NUMERIC

/* The Linux man pages say these are the field names for the structure
 * components that are LC_NUMERIC; the rest being LC_MONETARY */
#   define isLC_NUMERIC_STRING(name) (strEQ(name, "decimal_point")     \
                                      || strEQ(name, "thousands_sep")  \
                                                                        \
                                      /* There should be no harm done   \
                                       * checking for this, even if     \
                                       * NO_LOCALECONV_GROUPING */      \
                                      || strEQ(name, "grouping"))
#else
#   define isLC_NUMERIC_STRING(name) (0)
#endif

static const struct lconv_offset lconv_integers[] = {
#ifdef USE_LOCALE_MONETARY
    {"int_frac_digits",   STRUCT_OFFSET(struct lconv, int_frac_digits)},
    {"frac_digits",       STRUCT_OFFSET(struct lconv, frac_digits)},
    {"p_cs_precedes",     STRUCT_OFFSET(struct lconv, p_cs_precedes)},
    {"p_sep_by_space",    STRUCT_OFFSET(struct lconv, p_sep_by_space)},
    {"n_cs_precedes",     STRUCT_OFFSET(struct lconv, n_cs_precedes)},
    {"n_sep_by_space",    STRUCT_OFFSET(struct lconv, n_sep_by_space)},
    {"p_sign_posn",       STRUCT_OFFSET(struct lconv, p_sign_posn)},
    {"n_sign_posn",       STRUCT_OFFSET(struct lconv, n_sign_posn)},
#ifdef HAS_LC_MONETARY_2008
    {"int_p_cs_precedes",  STRUCT_OFFSET(struct lconv, int_p_cs_precedes)},
    {"int_p_sep_by_space", STRUCT_OFFSET(struct lconv, int_p_sep_by_space)},
    {"int_n_cs_precedes",  STRUCT_OFFSET(struct lconv, int_n_cs_precedes)},
    {"int_n_sep_by_space", STRUCT_OFFSET(struct lconv, int_n_sep_by_space)},
    {"int_p_sign_posn",    STRUCT_OFFSET(struct lconv, int_p_sign_posn)},
    {"int_n_sign_posn",    STRUCT_OFFSET(struct lconv, int_n_sign_posn)},
#endif
#endif
    {NULL, 0}
};

#endif /* HAS_LOCALECONV */

#ifdef HAS_LONG_DOUBLE
#  if LONG_DOUBLESIZE > NVSIZE
#    undef HAS_LONG_DOUBLE  /* XXX until we figure out how to use them */
#  endif
#endif

#ifndef HAS_LONG_DOUBLE
#ifdef LDBL_MAX
#undef LDBL_MAX
#endif
#ifdef LDBL_MIN
#undef LDBL_MIN
#endif
#ifdef LDBL_EPSILON
#undef LDBL_EPSILON
#endif
#endif

/* Background: in most systems the low byte of the wait status
 * is the signal (the lowest 7 bits) and the coredump flag is
 * the eight bit, and the second lowest byte is the exit status.
 * BeOS bucks the trend and has the bytes in different order.
 * See beos/beos.c for how the reality is bent even in BeOS
 * to follow the traditional.  However, to make the POSIX
 * wait W*() macros to work in BeOS, we need to unbend the
 * reality back in place. --jhi */
/* In actual fact the code below is to blame here. Perl has an internal
 * representation of the exit status ($?), which it re-composes from the
 * OS's representation using the W*() POSIX macros. The code below
 * incorrectly uses the W*() macros on the internal representation,
 * which fails for OSs that have a different representation (namely BeOS
 * and Haiku). WMUNGE() is a hack that converts the internal
 * representation into the OS specific one, so that the W*() macros work
 * as expected. The better solution would be not to use the W*() macros
 * in the first place, though. -- Ingo Weinhold
 */
#if defined(__HAIKU__)
#    define WMUNGE(x) (((x) & 0xFF00) >> 8 | ((x) & 0x00FF) << 8)
#else
#    define WMUNGE(x) (x)
#endif

static int
not_here(const char *s)
{
    croak("POSIX::%s not implemented on this architecture", s);
    return -1;
}

#include "const-c.inc"

static void
restore_sigmask(pTHX_ SV *osset_sv)
{
     /* Fortunately, restoring the signal mask can't fail, because
      * there's nothing we can do about it if it does -- we're not
      * supposed to return -1 from sigaction unless the disposition
      * was unaffected.
      */
#if !(defined(__amigaos4__) && defined(__NEWLIB__))
     sigset_t *ossetp = (sigset_t *) SvPV_nolen( osset_sv );
     (void)sigprocmask(SIG_SETMASK, ossetp, (sigset_t *)0);
#endif
}

static void *
allocate_struct(pTHX_ SV *rv, const STRLEN size, const char *packname) {
    SV *const t = newSVrv(rv, packname);
    void *const p = sv_grow(t, size + 1);

    SvCUR_set(t, size);
    SvPOK_on(t);
    return p;
}

#ifdef WIN32

/*
 * (1) The CRT maintains its own copy of the environment, separate from
 * the Win32API copy.
 *
 * (2) CRT getenv() retrieves from this copy. CRT putenv() updates this
 * copy, and then calls SetEnvironmentVariableA() to update the Win32API
 * copy.
 *
 * (3) win32_getenv() and win32_putenv() call GetEnvironmentVariableA() and
 * SetEnvironmentVariableA() directly, bypassing the CRT copy of the
 * environment.
 *
 * (4) The CRT strftime() "%Z" implementation calls __tzset(). That
 * calls CRT tzset(), but only the first time it is called, and in turn
 * that uses CRT getenv("TZ") to retrieve the timezone info from the CRT
 * local copy of the environment and hence gets the original setting as
 * perl never updates the CRT copy when assigning to $ENV{TZ}.
 *
 * Therefore, we need to retrieve the value of $ENV{TZ} and call CRT
 * putenv() to update the CRT copy of the environment (if it is different)
 * whenever we're about to call tzset().
 *
 * In addition to all that, when perl is built with PERL_IMPLICIT_SYS
 * defined:
 *
 * (a) Each interpreter has its own copy of the environment inside the
 * perlhost structure. That allows applications that host multiple
 * independent Perl interpreters to isolate environment changes from
 * each other. (This is similar to how the perlhost mechanism keeps a
 * separate working directory for each Perl interpreter, so that calling
 * chdir() will not affect other interpreters.)
 *
 * (b) Only the first Perl interpreter instantiated within a process will
 * "write through" environment changes to the process environment.
 *
 * (c) Even the primary Perl interpreter won't update the CRT copy of the
 * the environment, only the Win32API copy (it calls win32_putenv()).
 *
 * As with CPerlHost::Getenv() and CPerlHost::Putenv() themselves, it makes
 * sense to only update the process environment when inside the main
 * interpreter, but we don't have access to CPerlHost's m_bTopLevel member
 * from here so we'll just have to check PL_curinterp instead.
 *
 * Therefore, we can simply #undef getenv() and putenv() so that those names
 * always refer to the CRT functions, and explicitly call win32_getenv() to
 * access perl's %ENV.
 *
 * We also #undef malloc() and free() to be sure we are using the CRT
 * functions otherwise under PERL_IMPLICIT_SYS they are redefined to calls
 * into VMem::Malloc() and VMem::Free() and all allocations will be freed
 * when the Perl interpreter is being destroyed so we'd end up with a pointer
 * into deallocated memory in environ[] if a program embedding a Perl
 * interpreter continues to operate even after the main Perl interpreter has
 * been destroyed.
 *
 * Note that we don't free() the malloc()ed memory unless and until we call
 * malloc() again ourselves because the CRT putenv() function simply puts its
 * pointer argument into the environ[] array (it doesn't make a copy of it)
 * so this memory must otherwise be leaked.
 */

#undef getenv
#undef putenv
#undef malloc
#undef free

static void
fix_win32_tzenv(void)
{
    static char* oldenv = NULL;
    char* newenv;
    const char* perl_tz_env = win32_getenv("TZ");
    const char* crt_tz_env = getenv("TZ");
    if (perl_tz_env == NULL)
        perl_tz_env = "";
    if (crt_tz_env == NULL)
        crt_tz_env = "";
    if (strcmp(perl_tz_env, crt_tz_env) != 0) {
        newenv = (char*)malloc((strlen(perl_tz_env) + 4) * sizeof(char));
        if (newenv != NULL) {
            sprintf(newenv, "TZ=%s", perl_tz_env);
            putenv(newenv);
            if (oldenv != NULL)
                free(oldenv);
            oldenv = newenv;
        }
    }
}

#endif

/*
 * my_tzset - wrapper to tzset() with a fix to make it work (better) on Win32.
 * This code is duplicated in the Time-Piece module, so any changes made here
 * should be made there too.
 */
static void
my_tzset(pTHX)
{
#ifdef WIN32
#if defined(USE_ITHREADS) && defined(PERL_IMPLICIT_SYS)
    if (PL_curinterp == aTHX)
#endif
        fix_win32_tzenv();
#endif
    tzset();
}

MODULE = SigSet		PACKAGE = POSIX::SigSet		PREFIX = sig

void
new(packname = "POSIX::SigSet", ...)
    const char *	packname
    CODE:
	{
	    int i;
	    sigset_t *const s
		= (sigset_t *) allocate_struct(aTHX_ (ST(0) = sv_newmortal()),
					       sizeof(sigset_t),
					       packname);
	    sigemptyset(s);
	    for (i = 1; i < items; i++)
		sigaddset(s, SvIV(ST(i)));
	    XSRETURN(1);
	}

SysRet
addset(sigset, sig)
	POSIX::SigSet	sigset
	POSIX::SigNo	sig
   ALIAS:
	delset = 1
   CODE:
	RETVAL = ix ? sigdelset(sigset, sig) : sigaddset(sigset, sig);
   OUTPUT:
	RETVAL

SysRet
emptyset(sigset)
	POSIX::SigSet	sigset
   ALIAS:
	fillset = 1
   CODE:
	RETVAL = ix ? sigfillset(sigset) : sigemptyset(sigset);
   OUTPUT:
	RETVAL

int
sigismember(sigset, sig)
	POSIX::SigSet	sigset
	POSIX::SigNo	sig

MODULE = Termios	PACKAGE = POSIX::Termios	PREFIX = cf

void
new(packname = "POSIX::Termios", ...)
    const char *	packname
    CODE:
	{
#ifdef I_TERMIOS
	    void *const p = allocate_struct(aTHX_ (ST(0) = sv_newmortal()),
					    sizeof(struct termios), packname);
	    /* The previous implementation stored a pointer to an uninitialised
	       struct termios. Seems safer to initialise it, particularly as
	       this implementation exposes the struct to prying from perl-space.
	    */
	    memset(p, 0, 1 + sizeof(struct termios));
	    XSRETURN(1);
#else
	    not_here("termios");
#endif
	}

SysRet
getattr(termios_ref, fd = 0)
	POSIX::Termios	termios_ref
	POSIX::Fd		fd
    CODE:
	RETVAL = tcgetattr(fd, termios_ref);
    OUTPUT:
	RETVAL

# If we define TCSANOW here then both a found and not found constant sub
# are created causing a Constant subroutine TCSANOW redefined warning
#ifndef TCSANOW
#  define DEF_SETATTR_ACTION 0
#else
#  define DEF_SETATTR_ACTION TCSANOW
#endif
SysRet
setattr(termios_ref, fd = 0, optional_actions = DEF_SETATTR_ACTION)
	POSIX::Termios	termios_ref
	POSIX::Fd	fd
	int		optional_actions
    CODE:
	/* The second argument to the call is mandatory, but we'd like to give
	   it a useful default. 0 isn't valid on all operating systems - on
           Solaris (at least) TCSANOW, TCSADRAIN and TCSAFLUSH have the same
           values as the equivalent ioctls, TCSETS, TCSETSW and TCSETSF.  */
	if (optional_actions < 0) {
            SETERRNO(EINVAL, LIB_INVARG);
            RETVAL = -1;
        } else {
            RETVAL = tcsetattr(fd, optional_actions, termios_ref);
        }
    OUTPUT:
	RETVAL

speed_t
getispeed(termios_ref)
	POSIX::Termios	termios_ref
    ALIAS:
	getospeed = 1
    CODE:
	RETVAL = ix ? cfgetospeed(termios_ref) : cfgetispeed(termios_ref);
    OUTPUT:
	RETVAL

tcflag_t
getiflag(termios_ref)
	POSIX::Termios	termios_ref
    ALIAS:
	getoflag = 1
	getcflag = 2
	getlflag = 3
    CODE:
#ifdef I_TERMIOS /* References a termios structure member so ifdef it out. */
	switch(ix) {
	case 0:
	    RETVAL = termios_ref->c_iflag;
	    break;
	case 1:
	    RETVAL = termios_ref->c_oflag;
	    break;
	case 2:
	    RETVAL = termios_ref->c_cflag;
	    break;
	case 3:
	    RETVAL = termios_ref->c_lflag;
	    break;
        default:
	    RETVAL = 0; /* silence compiler warning */
	}
#else
	not_here(GvNAME(CvGV(cv)));
	RETVAL = 0;
#endif
    OUTPUT:
	RETVAL

cc_t
getcc(termios_ref, ccix)
	POSIX::Termios	termios_ref
	unsigned int	ccix
    CODE:
#ifdef I_TERMIOS /* References a termios structure member so ifdef it out. */
	if (ccix >= NCCS)
	    croak("Bad getcc subscript");
	RETVAL = termios_ref->c_cc[ccix];
#else
     not_here("getcc");
     RETVAL = 0;
#endif
    OUTPUT:
	RETVAL

SysRet
setispeed(termios_ref, speed)
	POSIX::Termios	termios_ref
	speed_t		speed
    ALIAS:
	setospeed = 1
    CODE:
	RETVAL = ix
	    ? cfsetospeed(termios_ref, speed) : cfsetispeed(termios_ref, speed);
    OUTPUT:
	RETVAL

void
setiflag(termios_ref, flag)
	POSIX::Termios	termios_ref
	tcflag_t	flag
    ALIAS:
	setoflag = 1
	setcflag = 2
	setlflag = 3
    CODE:
#ifdef I_TERMIOS /* References a termios structure member so ifdef it out. */
	switch(ix) {
	case 0:
	    termios_ref->c_iflag = flag;
	    break;
	case 1:
	    termios_ref->c_oflag = flag;
	    break;
	case 2:
	    termios_ref->c_cflag = flag;
	    break;
	case 3:
	    termios_ref->c_lflag = flag;
	    break;
	}
#else
	not_here(GvNAME(CvGV(cv)));
#endif

void
setcc(termios_ref, ccix, cc)
	POSIX::Termios	termios_ref
	unsigned int	ccix
	cc_t		cc
    CODE:
#ifdef I_TERMIOS /* References a termios structure member so ifdef it out. */
	if (ccix >= NCCS)
	    croak("Bad setcc subscript");
	termios_ref->c_cc[ccix] = cc;
#else
	    not_here("setcc");
#endif


MODULE = POSIX		PACKAGE = POSIX

INCLUDE: const-xs.inc

int
WEXITSTATUS(status)
	int status
    ALIAS:
	POSIX::WIFEXITED = 1
	POSIX::WIFSIGNALED = 2
	POSIX::WIFSTOPPED = 3
	POSIX::WSTOPSIG = 4
	POSIX::WTERMSIG = 5
    CODE:
#if !defined(WEXITSTATUS) || !defined(WIFEXITED) || !defined(WIFSIGNALED) \
      || !defined(WIFSTOPPED) || !defined(WSTOPSIG) || !defined(WTERMSIG)
        RETVAL = 0; /* Silence compilers that notice this, but don't realise
		       that not_here() can't return.  */
#endif
	switch(ix) {
	case 0:
#ifdef WEXITSTATUS
	    RETVAL = WEXITSTATUS(WMUNGE(status));
#else
	    not_here("WEXITSTATUS");
#endif
	    break;
	case 1:
#ifdef WIFEXITED
	    RETVAL = WIFEXITED(WMUNGE(status));
#else
	    not_here("WIFEXITED");
#endif
	    break;
	case 2:
#ifdef WIFSIGNALED
	    RETVAL = WIFSIGNALED(WMUNGE(status));
#else
	    not_here("WIFSIGNALED");
#endif
	    break;
	case 3:
#ifdef WIFSTOPPED
	    RETVAL = WIFSTOPPED(WMUNGE(status));
#else
	    not_here("WIFSTOPPED");
#endif
	    break;
	case 4:
#ifdef WSTOPSIG
	    RETVAL = WSTOPSIG(WMUNGE(status));
#else
	    not_here("WSTOPSIG");
#endif
	    break;
	case 5:
#ifdef WTERMSIG
	    RETVAL = WTERMSIG(WMUNGE(status));
#else
	    not_here("WTERMSIG");
#endif
	    break;
	default:
	    croak("Illegal alias %d for POSIX::W*", (int)ix);
	}
    OUTPUT:
	RETVAL

SysRet
open(filename, flags = O_RDONLY, mode = 0666)
	char *		filename
	int		flags
	Mode_t		mode
    CODE:
	if (flags & (O_APPEND|O_CREAT|O_TRUNC|O_RDWR|O_WRONLY|O_EXCL))
	    TAINT_PROPER("open");
	RETVAL = open(filename, flags, mode);
    OUTPUT:
	RETVAL


HV *
localeconv()
    CODE:
#ifndef HAS_LOCALECONV
	localeconv(); /* A stub to call not_here(). */
#else
	struct lconv *lcbuf;

        /* localeconv() deals with both LC_NUMERIC and LC_MONETARY, but
         * LC_MONETARY is already in the correct locale */
        DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
        STORE_LC_NUMERIC_FORCE_TO_UNDERLYING();

	RETVAL = newHV();
	sv_2mortal((SV*)RETVAL);
	if ((lcbuf = localeconv())) {
	    const struct lconv_offset *strings = lconv_strings;
	    const struct lconv_offset *integers = lconv_integers;
	    const char *ptr = (const char *) lcbuf;

	    while (strings->name) {
                /* This string may be controlled by either LC_NUMERIC, or
                 * LC_MONETARY */
                bool is_utf8_locale
#if defined(USE_LOCALE_NUMERIC) && defined(USE_LOCALE_MONETARY)
                 = _is_cur_LC_category_utf8((isLC_NUMERIC_STRING(strings->name))
                                             ? LC_NUMERIC
                                             : LC_MONETARY);
#elif defined(USE_LOCALE_NUMERIC)
                 = _is_cur_LC_category_utf8(LC_NUMERIC);
#elif defined(USE_LOCALE_MONETARY)
                 = _is_cur_LC_category_utf8(LC_MONETARY);
#else
                 = FALSE;
#endif

		const char *value = *((const char **)(ptr + strings->offset));

		if (value && *value) {
		    (void) hv_store(RETVAL,
                        strings->name,
                        strlen(strings->name),
                        newSVpvn_utf8(value,
                                      strlen(value),

                                      /* We mark it as UTF-8 if a utf8 locale
                                       * and is valid and variant under UTF-8 */
                                      is_utf8_locale
                                        && ! is_invariant_string((U8 *) value, 0)
                                        && is_utf8_string((U8 *) value, 0)),
                        0);
                }
                strings++;
	    }

	    while (integers->name) {
		const char value = *((const char *)(ptr + integers->offset));

		if (value != CHAR_MAX)
		    (void) hv_store(RETVAL, integers->name,
				    strlen(integers->name), newSViv(value), 0);
                integers++;
            }
	}
        RESTORE_LC_NUMERIC_STANDARD();
#endif  /* HAS_LOCALECONV */
    OUTPUT:
	RETVAL

char *
setlocale(category, locale = 0)
	int		category
	const char *    locale
    PREINIT:
	char *		retval;
    CODE:
#ifdef USE_LOCALE_NUMERIC
        /* A 0 (or NULL) locale means only query what the current one is.  We
         * have the LC_NUMERIC name saved, because we are normally switched
         * into the C locale for it.  Switch back so an LC_ALL query will yield
         * the correct results; all other categories don't require special
         * handling */
        if (locale == 0) {
            if (category == LC_NUMERIC) {
                XSRETURN_PV(PL_numeric_name);
            }
#   ifdef LC_ALL
            else if (category == LC_ALL) {
                SET_NUMERIC_UNDERLYING();
            }
#   endif
        }
#endif
#ifdef WIN32    /* Use wrapper on Windows */
	retval = Perl_my_setlocale(aTHX_ category, locale);
#else
	retval = setlocale(category, locale);
#endif
        DEBUG_L(PerlIO_printf(Perl_debug_log,
            "%s:%d: %s\n", __FILE__, __LINE__,
                _setlocale_debug_string(category, locale, retval)));
	if (! retval) {
            /* Should never happen that a query would return an error, but be
             * sure and reset to C locale */
            if (locale == 0) {
                SET_NUMERIC_STANDARD();
            }
            XSRETURN_UNDEF;
        }

        /* Save retval since subsequent setlocale() calls may overwrite it. */
        retval = savepv(retval);
        SAVEFREEPV(retval);

        /* For locale == 0, we may have switched to NUMERIC_UNDERLYING.  Switch
         * back */
        if (locale == 0) {
            SET_NUMERIC_STANDARD();
            XSRETURN_PV(retval);
        }
        else {
	    RETVAL = retval;
#ifdef USE_LOCALE_CTYPE
	    if (category == LC_CTYPE
#ifdef LC_ALL
		|| category == LC_ALL
#endif
		)
	    {
		char *newctype;
#ifdef LC_ALL
		if (category == LC_ALL) {
		    newctype = setlocale(LC_CTYPE, NULL);
                    DEBUG_Lv(PerlIO_printf(Perl_debug_log,
                        "%s:%d: %s\n", __FILE__, __LINE__,
                        _setlocale_debug_string(LC_CTYPE, NULL, newctype)));
                }
		else
#endif
		    newctype = RETVAL;
		new_ctype(newctype);
	    }
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
	    if (category == LC_COLLATE
#ifdef LC_ALL
		|| category == LC_ALL
#endif
		)
	    {
		char *newcoll;
#ifdef LC_ALL
		if (category == LC_ALL) {
		    newcoll = setlocale(LC_COLLATE, NULL);
                    DEBUG_Lv(PerlIO_printf(Perl_debug_log,
                        "%s:%d: %s\n", __FILE__, __LINE__,
                        _setlocale_debug_string(LC_COLLATE, NULL, newcoll)));
                }
		else
#endif
		    newcoll = RETVAL;
		new_collate(newcoll);
	    }
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
	    if (category == LC_NUMERIC
#ifdef LC_ALL
		|| category == LC_ALL
#endif
		)
	    {
		char *newnum;
#ifdef LC_ALL
		if (category == LC_ALL) {
		    newnum = setlocale(LC_NUMERIC, NULL);
                    DEBUG_Lv(PerlIO_printf(Perl_debug_log,
                        "%s:%d: %s\n", __FILE__, __LINE__,
                        _setlocale_debug_string(LC_NUMERIC, NULL, newnum)));
                }
		else
#endif
		    newnum = RETVAL;
		new_numeric(newnum);
	    }
#endif /* USE_LOCALE_NUMERIC */
	}
    OUTPUT:
	RETVAL

NV
acos(x)
	NV		x
    ALIAS:
	acosh = 1
	asin = 2
	asinh = 3
	atan = 4
	atanh = 5
	cbrt = 6
	ceil = 7
	cosh = 8
	erf = 9
	erfc = 10
	exp2 = 11
	expm1 = 12
	floor = 13
	j0 = 14
	j1 = 15
	lgamma = 16
	log10 = 17
	log1p = 18
	log2 = 19
	logb = 20
	nearbyint = 21
	rint = 22
	round = 23
	sinh = 24
	tan = 25
	tanh = 26
	tgamma = 27
	trunc = 28
	y0 = 29
	y1 = 30
    CODE:
	PERL_UNUSED_VAR(x);
	RETVAL = NV_NAN;
	switch (ix) {
	case 0:
	    RETVAL = Perl_acos(x); /* C89 math */
	    break;
	case 1:
#ifdef c99_acosh
	    RETVAL = c99_acosh(x);
#else
	    not_here("acosh");
#endif
	    break;
	case 2:
	    RETVAL = Perl_asin(x); /* C89 math */
	    break;
	case 3:
#ifdef c99_asinh
	    RETVAL = c99_asinh(x);
#else
	    not_here("asinh");
#endif
	    break;
	case 4:
	    RETVAL = Perl_atan(x); /* C89 math */
	    break;
	case 5:
#ifdef c99_atanh
	    RETVAL = c99_atanh(x);
#else
	    not_here("atanh");
#endif
	    break;
	case 6:
#ifdef c99_cbrt
	    RETVAL = c99_cbrt(x);
#else
	    not_here("cbrt");
#endif
	    break;
	case 7:
	    RETVAL = Perl_ceil(x); /* C89 math */
	    break;
	case 8:
	    RETVAL = Perl_cosh(x); /* C89 math */
	    break;
	case 9:
#ifdef c99_erf
	    RETVAL = c99_erf(x);
#else
	    not_here("erf");
#endif
	    break;
	case 10:
#ifdef c99_erfc
	    RETVAL = c99_erfc(x);
#else
	    not_here("erfc");
#endif
	    break;
	case 11:
#ifdef c99_exp2
	    RETVAL = c99_exp2(x);
#else
	    not_here("exp2");
#endif
	    break;
	case 12:
#ifdef c99_expm1
	    RETVAL = c99_expm1(x);
#else
	    not_here("expm1");
#endif
	    break;
	case 13:
	    RETVAL = Perl_floor(x); /* C89 math */
	    break;
	case 14:
#ifdef bessel_j0
	    RETVAL = bessel_j0(x);
#else
	    not_here("j0");
#endif
	    break;
	case 15:
#ifdef bessel_j1
	    RETVAL = bessel_j1(x);
#else
	    not_here("j1");
#endif
	    break;
	case 16:
        /* XXX Note: the lgamma modifies a global variable (signgam),
         * which is evil.  Some platforms have lgamma_r, which has
         * extra output parameter instead of the global variable. */
#ifdef c99_lgamma
	    RETVAL = c99_lgamma(x);
#else
	    not_here("lgamma");
#endif
	    break;
	case 17:
	    RETVAL = log10(x); /* C89 math */
	    break;
	case 18:
#ifdef c99_log1p
	    RETVAL = c99_log1p(x);
#else
	    not_here("log1p");
#endif
	    break;
	case 19:
#ifdef c99_log2
	    RETVAL = c99_log2(x);
#else
	    not_here("log2");
#endif
	    break;
	case 20:
#ifdef c99_logb
	    RETVAL = c99_logb(x);
#elif defined(c99_log2) && FLT_RADIX == 2
	    RETVAL = Perl_floor(c99_log2(PERL_ABS(x)));
#else
	    not_here("logb");
#endif
	    break;
	case 21:
#ifdef c99_nearbyint
	    RETVAL = c99_nearbyint(x);
#else
	    not_here("nearbyint");
#endif
	    break;
	case 22:
#ifdef c99_rint
	    RETVAL = c99_rint(x);
#else
	    not_here("rint");
#endif
	    break;
	case 23:
#ifdef c99_round
	    RETVAL = c99_round(x);
#else
	    not_here("round");
#endif
	    break;
	case 24:
	    RETVAL = Perl_sinh(x); /* C89 math */
	    break;
	case 25:
	    RETVAL = Perl_tan(x); /* C89 math */
	    break;
	case 26:
	    RETVAL = Perl_tanh(x); /* C89 math */
	    break;
	case 27:
#ifdef c99_tgamma
	    RETVAL = c99_tgamma(x);
#else
	    not_here("tgamma");
#endif
	    break;
	case 28:
#ifdef c99_trunc
	    RETVAL = c99_trunc(x);
#else
	    not_here("trunc");
#endif
	    break;
	case 29:
#ifdef bessel_y0
	    RETVAL = bessel_y0(x);
#else
	    not_here("y0");
#endif
	    break;
        case 30:
	default:
#ifdef bessel_y1
	    RETVAL = bessel_y1(x);
#else
	    not_here("y1");
#endif
	}
    OUTPUT:
	RETVAL

IV
fegetround()
    CODE:
#ifdef HAS_FEGETROUND
	RETVAL = my_fegetround();
#else
	RETVAL = -1;
	not_here("fegetround");
#endif
    OUTPUT:
	RETVAL

IV
fesetround(x)
	IV	x
    CODE:
#ifdef HAS_FEGETROUND /* canary for fesetround */
	RETVAL = fesetround(x);
#elif defined(HAS_FPGETROUND) /* canary for fpsetround */
	switch (x) {
	case FE_TONEAREST:  RETVAL = fpsetround(FP_RN); break;
	case FE_TOWARDZERO: RETVAL = fpsetround(FP_RZ); break;
	case FE_DOWNWARD:   RETVAL = fpsetround(FP_RM); break;
	case FE_UPWARD:     RETVAL = fpsetround(FP_RP); break;
        default: RETVAL = -1; break;
	}
#elif defined(__osf__) /* Tru64 */
	switch (x) {
	case FE_TONEAREST:  RETVAL = write_rnd(FP_RND_RN); break;
	case FE_TOWARDZERO: RETVAL = write_rnd(FP_RND_RZ); break;
	case FE_DOWNWARD:   RETVAL = write_rnd(FP_RND_RM); break;
	case FE_UPWARD:     RETVAL = write_rnd(FP_RND_RP); break;
        default: RETVAL = -1; break;
	}
#else
	PERL_UNUSED_VAR(x);
	RETVAL = -1;
	not_here("fesetround");
#endif
    OUTPUT:
	RETVAL

IV
fpclassify(x)
	NV		x
    ALIAS:
	ilogb = 1
	isfinite = 2
	isinf = 3
	isnan = 4
	isnormal = 5
	lrint = 6
	lround = 7
        signbit = 8
    CODE:
        PERL_UNUSED_VAR(x);
	RETVAL = -1;
	switch (ix) {
	case 0:
#ifdef c99_fpclassify
	    RETVAL = c99_fpclassify(x);
#else
	    not_here("fpclassify");
#endif
	    break;
	case 1:
#ifdef c99_ilogb
	    RETVAL = c99_ilogb(x);
#else
	    not_here("ilogb");
#endif
	    break;
	case 2:
	    RETVAL = Perl_isfinite(x);
	    break;
	case 3:
	    RETVAL = Perl_isinf(x);
	    break;
	case 4:
	    RETVAL = Perl_isnan(x);
	    break;
	case 5:
#ifdef c99_isnormal
	    RETVAL = c99_isnormal(x);
#else
	    not_here("isnormal");
#endif
	    break;
	case 6:
#ifdef c99_lrint
	    RETVAL = c99_lrint(x);
#else
	    not_here("lrint");
#endif
	    break;
	case 7:
#ifdef c99_lround
	    RETVAL = c99_lround(x);
#else
	    not_here("lround");
#endif
	    break;
	case 8:
	default:
#ifdef Perl_signbit
	    RETVAL = Perl_signbit(x);
#else
	    RETVAL = (x < 0) || (x == -0.0);
#endif
	    break;
	}
    OUTPUT:
	RETVAL

NV
getpayload(nv)
	NV nv
    CODE:
	RETVAL = S_getpayload(nv);
    OUTPUT:
	RETVAL

void
setpayload(nv, payload)
	NV nv
	NV payload
    CODE:
	S_setpayload(&nv, payload, FALSE);
    OUTPUT:
	nv

void
setpayloadsig(nv, payload)
	NV nv
	NV payload
    CODE:
	nv = NV_NAN;
	S_setpayload(&nv, payload, TRUE);
    OUTPUT:
	nv

int
issignaling(nv)
	NV nv
    CODE:
	RETVAL = Perl_isnan(nv) && NV_NAN_IS_SIGNALING(&nv);
    OUTPUT:
	RETVAL

NV
copysign(x,y)
	NV		x
	NV		y
    ALIAS:
	fdim = 1
	fmax = 2
	fmin = 3
	fmod = 4
	hypot = 5
	isgreater = 6
	isgreaterequal = 7
	isless = 8
	islessequal = 9
	islessgreater = 10
	isunordered = 11
	nextafter = 12
	nexttoward = 13
	remainder = 14
    CODE:
        PERL_UNUSED_VAR(x);
        PERL_UNUSED_VAR(y);
	RETVAL = NV_NAN;
	switch (ix) {
	case 0:
#ifdef c99_copysign
	    RETVAL = c99_copysign(x, y);
#else
	    not_here("copysign");
#endif
	    break;
	case 1:
#ifdef c99_fdim
	    RETVAL = c99_fdim(x, y);
#else
	    not_here("fdim");
#endif
	    break;
	case 2:
#ifdef c99_fmax
	    RETVAL = c99_fmax(x, y);
#else
	    not_here("fmax");
#endif
	    break;
	case 3:
#ifdef c99_fmin
	    RETVAL = c99_fmin(x, y);
#else
	    not_here("fmin");
#endif
	    break;
	case 4:
	    RETVAL = Perl_fmod(x, y); /* C89 math */
	    break;
	case 5:
#ifdef c99_hypot
	    RETVAL = c99_hypot(x, y);
#else
	    not_here("hypot");
#endif
	    break;
	case 6:
#ifdef c99_isgreater
	    RETVAL = c99_isgreater(x, y);
#else
	    not_here("isgreater");
#endif
	    break;
	case 7:
#ifdef c99_isgreaterequal
	    RETVAL = c99_isgreaterequal(x, y);
#else
	    not_here("isgreaterequal");
#endif
	    break;
	case 8:
#ifdef c99_isless
	    RETVAL = c99_isless(x, y);
#else
	    not_here("isless");
#endif
	    break;
	case 9:
#ifdef c99_islessequal
	    RETVAL = c99_islessequal(x, y);
#else
	    not_here("islessequal");
#endif
	    break;
	case 10:
#ifdef c99_islessgreater
	    RETVAL = c99_islessgreater(x, y);
#else
	    not_here("islessgreater");
#endif
	    break;
	case 11:
#ifdef c99_isunordered
	    RETVAL = c99_isunordered(x, y);
#else
	    not_here("isunordered");
#endif
	    break;
	case 12:
#ifdef c99_nextafter
	    RETVAL = c99_nextafter(x, y);
#else
	    not_here("nextafter");
#endif
	    break;
	case 13:
#ifdef c99_nexttoward
	    RETVAL = c99_nexttoward(x, y);
#else
	    not_here("nexttoward");
#endif
	    break;
	case 14:
	default:
#ifdef c99_remainder
          RETVAL = c99_remainder(x, y);
#else
          not_here("remainder");
#endif
	    break;
	}
	OUTPUT:
	    RETVAL

void
frexp(x)
	NV		x
    PPCODE:
	int expvar;
	/* (We already know stack is long enough.) */
	PUSHs(sv_2mortal(newSVnv(Perl_frexp(x,&expvar)))); /* C89 math */
	PUSHs(sv_2mortal(newSViv(expvar)));

NV
ldexp(x,exp)
	NV		x
	int		exp

void
modf(x)
	NV		x
    PPCODE:
	NV intvar;
	/* (We already know stack is long enough.) */
	PUSHs(sv_2mortal(newSVnv(Perl_modf(x,&intvar)))); /* C89 math */
	PUSHs(sv_2mortal(newSVnv(intvar)));

void
remquo(x,y)
	NV		x
	NV		y
    PPCODE:
#ifdef c99_remquo
        int intvar;
        PUSHs(sv_2mortal(newSVnv(c99_remquo(x,y,&intvar))));
        PUSHs(sv_2mortal(newSVnv(intvar)));
#else
	PERL_UNUSED_VAR(x);
	PERL_UNUSED_VAR(y);
	not_here("remquo");
#endif

NV
scalbn(x,y)
	NV		x
	IV		y
    CODE:
#ifdef c99_scalbn
	RETVAL = c99_scalbn(x, y);
#else
	PERL_UNUSED_VAR(x);
	PERL_UNUSED_VAR(y);
	RETVAL = NV_NAN;
	not_here("scalbn");
#endif
    OUTPUT:
	RETVAL

NV
fma(x,y,z)
	NV		x
	NV		y
	NV		z
    CODE:
#ifdef c99_fma
	RETVAL = c99_fma(x, y, z);
#else
	PERL_UNUSED_VAR(x);
	PERL_UNUSED_VAR(y);
	PERL_UNUSED_VAR(z);
	not_here("fma");
#endif
    OUTPUT:
	RETVAL

NV
nan(payload = 0)
	NV payload
    CODE:
#ifdef NV_NAN
        /* If no payload given, just return the default NaN.
         * This makes a difference in platforms where the default
         * NaN is not all zeros. */
	if (items == 0) {
          RETVAL = NV_NAN;
	} else {
          S_setpayload(&RETVAL, payload, FALSE);
        }
#elif defined(c99_nan)
	{
	  STRLEN elen = my_snprintf(PL_efloatbuf, PL_efloatsize, "%g", nv);
          if ((IV)elen == -1) {
	    RETVAL = NV_NAN;
          } else {
            RETVAL = c99_nan(PL_efloatbuf);
          }
        }
#else
	not_here("nan");
#endif
    OUTPUT:
	RETVAL

NV
jn(x,y)
	IV		x
	NV		y
    ALIAS:
	yn = 1
    CODE:
	RETVAL = NV_NAN;
        switch (ix) {
	case 0:
#ifdef bessel_jn
          RETVAL = bessel_jn(x, y);
#else
	  PERL_UNUSED_VAR(x);
	  PERL_UNUSED_VAR(y);
          not_here("jn");
#endif
            break;
	case 1:
	default:
#ifdef bessel_yn
          RETVAL = bessel_yn(x, y);
#else
	  PERL_UNUSED_VAR(x);
	  PERL_UNUSED_VAR(y);
          not_here("yn");
#endif
            break;
	}
    OUTPUT:
	RETVAL

SysRet
sigaction(sig, optaction, oldaction = 0)
	int			sig
	SV *			optaction
	POSIX::SigAction	oldaction
    CODE:
#if defined(WIN32) || defined(NETWARE) || (defined(__amigaos4__) && defined(__NEWLIB__))
	RETVAL = not_here("sigaction");
#else
# This code is really grody because we are trying to make the signal
# interface look beautiful, which is hard.

	{
	    dVAR;
	    POSIX__SigAction action;
	    GV *siggv = gv_fetchpvs("SIG", GV_ADD, SVt_PVHV);
	    struct sigaction act;
	    struct sigaction oact;
	    sigset_t sset;
	    SV *osset_sv;
	    sigset_t osset;
	    POSIX__SigSet sigset;
	    SV** svp;
	    SV** sigsvp;

            if (sig < 0) {
                croak("Negative signals are not allowed");
            }

	    if (sig == 0 && SvPOK(ST(0))) {
	        const char *s = SvPVX_const(ST(0));
		int i = whichsig(s);

	        if (i < 0 && memEQ(s, "SIG", 3))
		    i = whichsig(s + 3);
	        if (i < 0) {
	            if (ckWARN(WARN_SIGNAL))
		        Perl_warner(aTHX_ packWARN(WARN_SIGNAL),
                                    "No such signal: SIG%s", s);
	            XSRETURN_UNDEF;
		}
	        else
		    sig = i;
            }
#ifdef NSIG
	    if (sig > NSIG) { /* NSIG - 1 is still okay. */
	        Perl_warner(aTHX_ packWARN(WARN_SIGNAL),
                            "No such signal: %d", sig);
	        XSRETURN_UNDEF;
	    }
#endif
	    sigsvp = hv_fetch(GvHVn(siggv),
			      PL_sig_name[sig],
			      strlen(PL_sig_name[sig]),
			      TRUE);

	    /* Check optaction and set action */
	    if(SvTRUE(optaction)) {
		if(sv_isa(optaction, "POSIX::SigAction"))
			action = (HV*)SvRV(optaction);
		else
			croak("action is not of type POSIX::SigAction");
	    }
	    else {
		action=0;
	    }

	    /* sigaction() is supposed to look atomic. In particular, any
	     * signal handler invoked during a sigaction() call should
	     * see either the old or the new disposition, and not something
	     * in between. We use sigprocmask() to make it so.
	     */
	    sigfillset(&sset);
	    RETVAL=sigprocmask(SIG_BLOCK, &sset, &osset);
	    if(RETVAL == -1)
               XSRETURN_UNDEF;
	    ENTER;
	    /* Restore signal mask no matter how we exit this block. */
	    osset_sv = newSVpvn((char *)(&osset), sizeof(sigset_t));
	    SAVEFREESV( osset_sv );
	    SAVEDESTRUCTOR_X(restore_sigmask, osset_sv);

	    RETVAL=-1; /* In case both oldaction and action are 0. */

	    /* Remember old disposition if desired. */
	    if (oldaction) {
		svp = hv_fetchs(oldaction, "HANDLER", TRUE);
		if(!svp)
		    croak("Can't supply an oldaction without a HANDLER");
		if(SvTRUE(*sigsvp)) { /* TBD: what if "0"? */
			sv_setsv(*svp, *sigsvp);
		}
		else {
			sv_setpvs(*svp, "DEFAULT");
		}
		RETVAL = sigaction(sig, (struct sigaction *)0, & oact);
		if(RETVAL == -1) {
                   LEAVE;
                   XSRETURN_UNDEF;
                }
		/* Get back the mask. */
		svp = hv_fetchs(oldaction, "MASK", TRUE);
		if (sv_isa(*svp, "POSIX::SigSet")) {
		    sigset = (sigset_t *) SvPV_nolen(SvRV(*svp));
		}
		else {
		    sigset = (sigset_t *) allocate_struct(aTHX_ *svp,
							  sizeof(sigset_t),
							  "POSIX::SigSet");
		}
		*sigset = oact.sa_mask;

		/* Get back the flags. */
		svp = hv_fetchs(oldaction, "FLAGS", TRUE);
		sv_setiv(*svp, oact.sa_flags);

		/* Get back whether the old handler used safe signals. */
		svp = hv_fetchs(oldaction, "SAFE", TRUE);
		sv_setiv(*svp,
		/* compare incompatible pointers by casting to integer */
		    PTR2nat(oact.sa_handler) == PTR2nat(PL_csighandlerp));
	    }

	    if (action) {
		/* Safe signals use "csighandler", which vectors through the
		   PL_sighandlerp pointer when it's safe to do so.
		   (BTW, "csighandler" is very different from "sighandler".) */
		svp = hv_fetchs(action, "SAFE", FALSE);
		act.sa_handler =
			DPTR2FPTR(
			    void (*)(int),
			    (*svp && SvTRUE(*svp))
				? PL_csighandlerp : PL_sighandlerp
			);

		/* Vector new Perl handler through %SIG.
		   (The core signal handlers read %SIG to dispatch.) */
		svp = hv_fetchs(action, "HANDLER", FALSE);
		if (!svp)
		    croak("Can't supply an action without a HANDLER");
		sv_setsv(*sigsvp, *svp);

		/* This call actually calls sigaction() with almost the
		   right settings, including appropriate interpretation
		   of DEFAULT and IGNORE.  However, why are we doing
		   this when we're about to do it again just below?  XXX */
		SvSETMAGIC(*sigsvp);

		/* And here again we duplicate -- DEFAULT/IGNORE checking. */
		if(SvPOK(*svp)) {
			const char *s=SvPVX_const(*svp);
			if(strEQ(s,"IGNORE")) {
				act.sa_handler = SIG_IGN;
			}
			else if(strEQ(s,"DEFAULT")) {
				act.sa_handler = SIG_DFL;
			}
		}

		/* Set up any desired mask. */
		svp = hv_fetchs(action, "MASK", FALSE);
		if (svp && sv_isa(*svp, "POSIX::SigSet")) {
		    sigset = (sigset_t *) SvPV_nolen(SvRV(*svp));
		    act.sa_mask = *sigset;
		}
		else
		    sigemptyset(& act.sa_mask);

		/* Set up any desired flags. */
		svp = hv_fetchs(action, "FLAGS", FALSE);
		act.sa_flags = svp ? SvIV(*svp) : 0;

		/* Don't worry about cleaning up *sigsvp if this fails,
		 * because that means we tried to disposition a
		 * nonblockable signal, in which case *sigsvp is
		 * essentially meaningless anyway.
		 */
		RETVAL = sigaction(sig, & act, (struct sigaction *)0);
		if(RETVAL == -1) {
                    LEAVE;
		    XSRETURN_UNDEF;
                }
	    }

	    LEAVE;
	}
#endif
    OUTPUT:
	RETVAL

SysRet
sigpending(sigset)
	POSIX::SigSet		sigset
    ALIAS:
	sigsuspend = 1
    CODE:
#ifdef __amigaos4__
	RETVAL = not_here("sigpending");
#else
	RETVAL = ix ? sigsuspend(sigset) : sigpending(sigset);
#endif
    OUTPUT:
	RETVAL
    CLEANUP:
    PERL_ASYNC_CHECK();

SysRet
sigprocmask(how, sigset, oldsigset = 0)
	int			how
	POSIX::SigSet		sigset = NO_INIT
	POSIX::SigSet		oldsigset = NO_INIT
INIT:
	if (! SvOK(ST(1))) {
	    sigset = NULL;
	} else if (sv_isa(ST(1), "POSIX::SigSet")) {
	    sigset = (sigset_t *) SvPV_nolen(SvRV(ST(1)));
	} else {
	    croak("sigset is not of type POSIX::SigSet");
	}

	if (items < 3 || ! SvOK(ST(2))) {
	    oldsigset = NULL;
	} else if (sv_isa(ST(2), "POSIX::SigSet")) {
	    oldsigset = (sigset_t *) SvPV_nolen(SvRV(ST(2)));
	} else {
	    croak("oldsigset is not of type POSIX::SigSet");
	}

void
_exit(status)
	int		status

SysRet
dup2(fd1, fd2)
	int		fd1
	int		fd2
    CODE:
	if (fd1 >= 0 && fd2 >= 0) {
#ifdef WIN32
            /* RT #98912 - More Microsoft muppetry - failing to
               actually implemented the well known documented POSIX
               behaviour for a POSIX API.
               http://msdn.microsoft.com/en-us/library/8syseb29.aspx  */
            RETVAL = dup2(fd1, fd2) == -1 ? -1 : fd2;
#else
            RETVAL = dup2(fd1, fd2);
#endif
        } else {
            SETERRNO(EBADF,RMS_IFI);
            RETVAL = -1;
        }
    OUTPUT:
	RETVAL

SV *
lseek(fd, offset, whence)
	POSIX::Fd	fd
	Off_t		offset
	int		whence
    CODE:
	{
              Off_t pos = PerlLIO_lseek(fd, offset, whence);
              RETVAL = sizeof(Off_t) > sizeof(IV)
                ? newSVnv((NV)pos) : newSViv((IV)pos);
        }
    OUTPUT:
	RETVAL

void
nice(incr)
	int		incr
    PPCODE:
	errno = 0;
	if ((incr = nice(incr)) != -1 || errno == 0) {
	    if (incr == 0)
		XPUSHs(newSVpvs_flags("0 but true", SVs_TEMP));
	    else
		XPUSHs(sv_2mortal(newSViv(incr)));
	}

void
pipe()
    PPCODE:
	int fds[2];
	if (pipe(fds) != -1) {
	    EXTEND(SP,2);
	    PUSHs(sv_2mortal(newSViv(fds[0])));
	    PUSHs(sv_2mortal(newSViv(fds[1])));
	}

SysRet
read(fd, buffer, nbytes)
    PREINIT:
        SV *sv_buffer = SvROK(ST(1)) ? SvRV(ST(1)) : ST(1);
    INPUT:
	POSIX::Fd	fd
        size_t          nbytes
        char *          buffer = sv_grow( sv_buffer, nbytes+1 );
    CLEANUP:
        if (RETVAL >= 0) {
            SvCUR_set(sv_buffer, RETVAL);
            SvPOK_only(sv_buffer);
            *SvEND(sv_buffer) = '\0';
            SvTAINTED_on(sv_buffer);
        }

SysRet
setpgid(pid, pgid)
	pid_t		pid
	pid_t		pgid

pid_t
setsid()

pid_t
tcgetpgrp(fd)
	POSIX::Fd	fd

SysRet
tcsetpgrp(fd, pgrp_id)
	POSIX::Fd	fd
	pid_t		pgrp_id

void
uname()
    PPCODE:
#ifdef HAS_UNAME
	struct utsname buf;
	if (uname(&buf) >= 0) {
	    EXTEND(SP, 5);
	    PUSHs(newSVpvn_flags(buf.sysname, strlen(buf.sysname), SVs_TEMP));
	    PUSHs(newSVpvn_flags(buf.nodename, strlen(buf.nodename), SVs_TEMP));
	    PUSHs(newSVpvn_flags(buf.release, strlen(buf.release), SVs_TEMP));
	    PUSHs(newSVpvn_flags(buf.version, strlen(buf.version), SVs_TEMP));
	    PUSHs(newSVpvn_flags(buf.machine, strlen(buf.machine), SVs_TEMP));
	}
#else
	uname((char *) 0); /* A stub to call not_here(). */
#endif

SysRet
write(fd, buffer, nbytes)
	POSIX::Fd	fd
	char *		buffer
	size_t		nbytes

SV *
tmpnam()
    PREINIT:
	STRLEN i;
	int len;
    CODE:
	RETVAL = newSVpvs("");
	SvGROW(RETVAL, L_tmpnam);
	/* Yes, we know tmpnam() is bad.  So bad that some compilers
	 * and linkers warn against using it.  But it is here for
	 * completeness.  POSIX.pod warns against using it.
	 *
	 * Then again, maybe this should be removed at some point.
	 * No point in enabling dangerous interfaces. */
        if (ckWARN_d(WARN_DEPRECATED)) {
	    HV *warned = get_hv("POSIX::_warned", GV_ADD | GV_ADDMULTI);
            if (! hv_exists(warned, (const char *)&PL_op, sizeof(PL_op))) {
                Perl_warner(aTHX_ packWARN(WARN_DEPRECATED), "Calling POSIX::tmpnam() is deprecated");
                (void)hv_store(warned, (const char *)&PL_op, sizeof(PL_op), &PL_sv_yes, 0);
            }
        }
	len = strlen(tmpnam(SvPV(RETVAL, i)));
	SvCUR_set(RETVAL, len);
    OUTPUT:
	RETVAL

void
abort()

int
mblen(s, n)
	char *		s
	size_t		n

size_t
mbstowcs(s, pwcs, n)
	wchar_t *	s
	char *		pwcs
	size_t		n

int
mbtowc(pwc, s, n)
	wchar_t *	pwc
	char *		s
	size_t		n

int
wcstombs(s, pwcs, n)
	char *		s
	wchar_t *	pwcs
	size_t		n

int
wctomb(s, wchar)
	char *		s
	wchar_t		wchar

int
strcoll(s1, s2)
	char *		s1
	char *		s2

void
strtod(str)
	char *		str
    PREINIT:
	double num;
	char *unparsed;
    PPCODE:
        DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
        STORE_LC_NUMERIC_FORCE_TO_UNDERLYING();
	num = strtod(str, &unparsed);
	PUSHs(sv_2mortal(newSVnv(num)));
	if (GIMME_V == G_ARRAY) {
	    EXTEND(SP, 1);
	    if (unparsed)
		PUSHs(sv_2mortal(newSViv(strlen(unparsed))));
	    else
		PUSHs(&PL_sv_undef);
	}
        RESTORE_LC_NUMERIC_STANDARD();

#ifdef HAS_STRTOLD

void
strtold(str)
	char *		str
    PREINIT:
	long double num;
	char *unparsed;
    PPCODE:
        DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
        STORE_LC_NUMERIC_FORCE_TO_UNDERLYING();
	num = strtold(str, &unparsed);
	PUSHs(sv_2mortal(newSVnv(num)));
	if (GIMME_V == G_ARRAY) {
	    EXTEND(SP, 1);
	    if (unparsed)
		PUSHs(sv_2mortal(newSViv(strlen(unparsed))));
	    else
		PUSHs(&PL_sv_undef);
	}
        RESTORE_LC_NUMERIC_STANDARD();

#endif

void
strtol(str, base = 0)
	char *		str
	int		base
    PREINIT:
	long num;
	char *unparsed;
    PPCODE:
	if (base == 0 || (base >= 2 && base <= 36)) {
            num = strtol(str, &unparsed, base);
#if IVSIZE < LONGSIZE
            if (num < IV_MIN || num > IV_MAX)
                PUSHs(sv_2mortal(newSVnv((double)num)));
            else
#endif
                PUSHs(sv_2mortal(newSViv((IV)num)));
            if (GIMME_V == G_ARRAY) {
                EXTEND(SP, 1);
                if (unparsed)
                    PUSHs(sv_2mortal(newSViv(strlen(unparsed))));
                else
                    PUSHs(&PL_sv_undef);
            }
        } else {
	    SETERRNO(EINVAL, LIB_INVARG);
            PUSHs(&PL_sv_undef);
            if (GIMME_V == G_ARRAY) {
               EXTEND(SP, 1);
               PUSHs(&PL_sv_undef);
            }
        }

void
strtoul(str, base = 0)
	const char *	str
	int		base
    PREINIT:
	unsigned long num;
	char *unparsed;
    PPCODE:
	PERL_UNUSED_VAR(str);
	PERL_UNUSED_VAR(base);
	if (base == 0 || (base >= 2 && base <= 36)) {
            num = strtoul(str, &unparsed, base);
#if IVSIZE <= LONGSIZE
            if (num > IV_MAX)
                PUSHs(sv_2mortal(newSVnv((double)num)));
            else
#endif
                PUSHs(sv_2mortal(newSViv((IV)num)));
            if (GIMME_V == G_ARRAY) {
                EXTEND(SP, 1);
                if (unparsed)
                    PUSHs(sv_2mortal(newSViv(strlen(unparsed))));
                else
                  PUSHs(&PL_sv_undef);
            }
	} else {
	    SETERRNO(EINVAL, LIB_INVARG);
            PUSHs(&PL_sv_undef);
            if (GIMME_V == G_ARRAY) {
               EXTEND(SP, 1);
               PUSHs(&PL_sv_undef);
            }
        }

void
strxfrm(src)
	SV *		src
    CODE:
	{
          STRLEN srclen;
          STRLEN dstlen;
          STRLEN buflen;
          char *p = SvPV(src,srclen);
          srclen++;
          buflen = srclen * 4 + 1;
          ST(0) = sv_2mortal(newSV(buflen));
          dstlen = strxfrm(SvPVX(ST(0)), p, (size_t)buflen);
          if (dstlen >= buflen) {
              dstlen++;
              SvGROW(ST(0), dstlen);
              strxfrm(SvPVX(ST(0)), p, (size_t)dstlen);
              dstlen--;
          }
          SvCUR_set(ST(0), dstlen);
	    SvPOK_only(ST(0));
	}

SysRet
mkfifo(filename, mode)
	char *		filename
	Mode_t		mode
    ALIAS:
	access = 1
    CODE:
	if(ix) {
	    RETVAL = access(filename, mode);
	} else {
	    TAINT_PROPER("mkfifo");
	    RETVAL = mkfifo(filename, mode);
	}
    OUTPUT:
	RETVAL

SysRet
tcdrain(fd)
	POSIX::Fd	fd
    ALIAS:
	close = 1
	dup = 2
    CODE:
	if (fd >= 0) {
	    RETVAL = ix == 1 ? close(fd)
	      : (ix < 1 ? tcdrain(fd) : dup(fd));
	} else {
	    SETERRNO(EBADF,RMS_IFI);
	    RETVAL = -1;
	}
    OUTPUT:
	RETVAL


SysRet
tcflow(fd, action)
	POSIX::Fd	fd
	int		action
    ALIAS:
	tcflush = 1
	tcsendbreak = 2
    CODE:
        if (action >= 0) {
            RETVAL = ix == 1 ? tcflush(fd, action)
              : (ix < 1 ? tcflow(fd, action) : tcsendbreak(fd, action));
        } else {
            SETERRNO(EINVAL,LIB_INVARG);
            RETVAL = -1;
        }
    OUTPUT:
	RETVAL

void
asctime(sec, min, hour, mday, mon, year, wday = 0, yday = 0, isdst = -1)
	int		sec
	int		min
	int		hour
	int		mday
	int		mon
	int		year
	int		wday
	int		yday
	int		isdst
    ALIAS:
	mktime = 1
    PPCODE:
	{
	    dXSTARG;
	    struct tm mytm;
	    init_tm(&mytm);	/* XXX workaround - see init_tm() in core util.c */
	    mytm.tm_sec = sec;
	    mytm.tm_min = min;
	    mytm.tm_hour = hour;
	    mytm.tm_mday = mday;
	    mytm.tm_mon = mon;
	    mytm.tm_year = year;
	    mytm.tm_wday = wday;
	    mytm.tm_yday = yday;
	    mytm.tm_isdst = isdst;
	    if (ix) {
	        const time_t result = mktime(&mytm);
		if (result == (time_t)-1)
		    SvOK_off(TARG);
		else if (result == 0)
		    sv_setpvn(TARG, "0 but true", 10);
		else
		    sv_setiv(TARG, (IV)result);
	    } else {
		sv_setpv(TARG, asctime(&mytm));
	    }
	    ST(0) = TARG;
	    XSRETURN(1);
	}

long
clock()

char *
ctime(time)
	Time_t		&time

void
times()
	PPCODE:
	struct tms tms;
	clock_t realtime;
	realtime = times( &tms );
	EXTEND(SP,5);
	PUSHs( sv_2mortal( newSViv( (IV) realtime ) ) );
	PUSHs( sv_2mortal( newSViv( (IV) tms.tms_utime ) ) );
	PUSHs( sv_2mortal( newSViv( (IV) tms.tms_stime ) ) );
	PUSHs( sv_2mortal( newSViv( (IV) tms.tms_cutime ) ) );
	PUSHs( sv_2mortal( newSViv( (IV) tms.tms_cstime ) ) );

double
difftime(time1, time2)
	Time_t		time1
	Time_t		time2

#XXX: if $xsubpp::WantOptimize is always the default
#     sv_setpv(TARG, ...) could be used rather than
#     ST(0) = sv_2mortal(newSVpv(...))
void
strftime(fmt, sec, min, hour, mday, mon, year, wday = -1, yday = -1, isdst = -1)
	SV *		fmt
	int		sec
	int		min
	int		hour
	int		mday
	int		mon
	int		year
	int		wday
	int		yday
	int		isdst
    CODE:
	{
	    char *buf;
            SV *sv;

            /* allowing user-supplied (rather than literal) formats
             * is normally frowned upon as a potential security risk;
             * but this is part of the API so we have to allow it */
            GCC_DIAG_IGNORE(-Wformat-nonliteral);
	    buf = my_strftime(SvPV_nolen(fmt), sec, min, hour, mday, mon, year, wday, yday, isdst);
            GCC_DIAG_RESTORE;
            sv = sv_newmortal();
	    if (buf) {
                STRLEN len = strlen(buf);
		sv_usepvn_flags(sv, buf, len, SV_HAS_TRAILING_NUL);
		if (SvUTF8(fmt)
                    || (! is_invariant_string((U8*) buf, len)
                        && is_utf8_string((U8*) buf, len)
#ifdef USE_LOCALE_TIME
                        && _is_cur_LC_category_utf8(LC_TIME)
#endif
                )) {
		    SvUTF8_on(sv);
		}
            }
            else {  /* We can't distinguish between errors and just an empty
                     * return; in all cases just return an empty string */
                SvUPGRADE(sv, SVt_PV);
                SvPV_set(sv, (char *) "");
                SvPOK_on(sv);
                SvCUR_set(sv, 0);
                SvLEN_set(sv, 0);   /* Won't attempt to free the string when sv
                                       gets destroyed */
            }
            ST(0) = sv;
	}

void
tzset()
  PPCODE:
    my_tzset(aTHX);

void
tzname()
    PPCODE:
	EXTEND(SP,2);
	PUSHs(newSVpvn_flags(tzname[0], strlen(tzname[0]), SVs_TEMP));
	PUSHs(newSVpvn_flags(tzname[1], strlen(tzname[1]), SVs_TEMP));

char *
ctermid(s = 0)
	char *          s = 0;
    CODE:
#ifdef HAS_CTERMID_R
	s = (char *) safemalloc((size_t) L_ctermid);
#endif
	RETVAL = ctermid(s);
    OUTPUT:
	RETVAL
    CLEANUP:
#ifdef HAS_CTERMID_R
	Safefree(s);
#endif

char *
cuserid(s = 0)
	char *		s = 0;
    CODE:
#ifdef HAS_CUSERID
  RETVAL = cuserid(s);
#else
  PERL_UNUSED_VAR(s);
  RETVAL = 0;
  not_here("cuserid");
#endif
    OUTPUT:
  RETVAL

SysRetLong
fpathconf(fd, name)
	POSIX::Fd	fd
	int		name

SysRetLong
pathconf(filename, name)
	char *		filename
	int		name

SysRet
pause()
    CLEANUP:
    PERL_ASYNC_CHECK();

unsigned int
sleep(seconds)
	unsigned int	seconds
    CODE:
	RETVAL = PerlProc_sleep(seconds);
    OUTPUT:
	RETVAL

SysRet
setgid(gid)
	Gid_t		gid

SysRet
setuid(uid)
	Uid_t		uid

SysRetLong
sysconf(name)
	int		name

char *
ttyname(fd)
	POSIX::Fd	fd

void
getcwd()
    PPCODE:
      {
	dXSTARG;
	getcwd_sv(TARG);
	XSprePUSH; PUSHTARG;
      }

SysRet
lchown(uid, gid, path)
       Uid_t           uid
       Gid_t           gid
       char *          path
    CODE:
#ifdef HAS_LCHOWN
       /* yes, the order of arguments is different,
        * but consistent with CORE::chown() */
       RETVAL = lchown(path, uid, gid);
#else
       PERL_UNUSED_VAR(uid);
       PERL_UNUSED_VAR(gid);
       PERL_UNUSED_VAR(path);
       RETVAL = not_here("lchown");
#endif
    OUTPUT:
       RETVAL
@


1.22
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@d37 3
d60 95
a154 6
/* XXX This comment is just to make I_TERMIO and I_SGTTY visible to
   metaconfig for future extension writers.  We don't use them in POSIX.
   (This is really sneaky :-)  --AD
*/
#if defined(I_TERMIOS)
#include <termios.h>
d156 3
a158 2
#ifdef I_STDLIB
#include <stdlib.h>
d160 3
a162 2
#ifndef __ultrix__
#include <string.h>
d164 3
a166 5
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>
#ifdef I_UNISTD
#include <unistd.h>
a167 1
#include <fcntl.h>
d169 7
a175 7
#ifdef HAS_TZNAME
#  if !defined(WIN32) && !defined(__CYGWIN__) && !defined(NETWARE) && !defined(__UWIN__)
extern char *tzname[];
#  endif
#else
#if !defined(WIN32) && !defined(__UWIN__) || (defined(__MINGW32__) && !defined(tzname))
char *tzname[] = { "" , "" };
d177 7
d186 35
a220 1
#if defined(__VMS) && !defined(__POSIX_SOURCE)
d222 1
a222 1
#  include <utsname.h>
d224 3
a226 2
#  undef mkfifo
#  define mkfifo(a,b) (not_here("mkfifo"),-1)
d228 4
a231 3
   /* The POSIX notion of ttyname() is better served by getname() under VMS */
   static char ttnambuf[64];
#  define ttyname(fd) (isatty(fd) > 0 ? getname(fd,ttnambuf,0) : NULL)
d233 77
a309 12
#else
#if defined (__CYGWIN__)
#    define tzname _tzname
#endif
#if defined (WIN32) || defined (NETWARE)
#  undef mkfifo
#  define mkfifo(a,b) not_here("mkfifo")
#  define ttyname(a) (char*)not_here("ttyname")
#  define sigset_t long
#  define pid_t long
#  ifdef _MSC_VER
#    define mode_t short
d311 11
a321 8
#  ifdef __MINGW32__
#    define mode_t short
#    ifndef tzset
#      define tzset()		not_here("tzset")
#    endif
#    ifndef _POSIX_OPEN_MAX
#      define _POSIX_OPEN_MAX	FOPEN_MAX	/* XXX bogus ? */
#    endif
d323 2
a324 15
#  define sigaction(a,b,c)	not_here("sigaction")
#  define sigpending(a)		not_here("sigpending")
#  define sigprocmask(a,b,c)	not_here("sigprocmask")
#  define sigsuspend(a)		not_here("sigsuspend")
#  define sigemptyset(a)	not_here("sigemptyset")
#  define sigaddset(a,b)	not_here("sigaddset")
#  define sigdelset(a,b)	not_here("sigdelset")
#  define sigfillset(a)		not_here("sigfillset")
#  define sigismember(a,b)	not_here("sigismember")
#ifndef NETWARE
#  undef setuid
#  undef setgid
#  define setuid(a)		not_here("setuid")
#  define setgid(a)		not_here("setgid")
#endif	/* NETWARE */
d326 23
a348 13

#  ifndef HAS_MKFIFO
#    if defined(OS2)
#      define mkfifo(a,b) not_here("mkfifo")
#    else	/* !( defined OS2 ) */
#      ifndef mkfifo
#        define mkfifo(path, mode) (mknod((path), (mode) | S_IFIFO, 0))
#      endif
#    endif
#  endif /* !HAS_MKFIFO */

#  ifdef I_GRP
#    include <grp.h>
d350 4
a353 3
#  include <sys/times.h>
#  ifdef HAS_UNAME
#    include <sys/utsname.h>
d355 12
a366 3
#  include <sys/wait.h>
#  ifdef I_UTIME
#    include <utime.h>
d368 3
a370 2
#endif /* WIN32 || NETWARE */
#endif /* __VMS */
d372 45
a416 22
typedef int SysRet;
typedef long SysRetLong;
typedef sigset_t* POSIX__SigSet;
typedef HV* POSIX__SigAction;
#ifdef I_TERMIOS
typedef struct termios* POSIX__Termios;
#else /* Define termios types to int, and call not_here for the functions.*/
#define POSIX__Termios int
#define speed_t int
#define tcflag_t int
#define cc_t int
#define cfgetispeed(x) not_here("cfgetispeed")
#define cfgetospeed(x) not_here("cfgetospeed")
#define tcdrain(x) not_here("tcdrain")
#define tcflush(x,y) not_here("tcflush")
#define tcsendbreak(x,y) not_here("tcsendbreak")
#define cfsetispeed(x,y) not_here("cfsetispeed")
#define cfsetospeed(x,y) not_here("cfsetospeed")
#define ctermid(x) (char *) not_here("ctermid")
#define tcflow(x,y) not_here("tcflow")
#define tcgetattr(x,y) not_here("tcgetattr")
#define tcsetattr(x,y,z) not_here("tcsetattr")
d419 12
a430 7
/* Possibly needed prototypes */
#ifndef WIN32
START_EXTERN_C
double strtod (const char *, char **);
long strtol (const char *, char **, int);
unsigned long strtoul (const char *, char **, int);
END_EXTERN_C
d433 3
a435 3
#ifndef HAS_DIFFTIME
#ifndef difftime
#define difftime(a,b) not_here("difftime")
d437 6
d444 7
a450 2
#ifndef HAS_FPATHCONF
#define fpathconf(f,n)	(SysRetLong) not_here("fpathconf")
d452 8
a459 2
#ifndef HAS_MKTIME
#define mktime(a) not_here("mktime")
d461 2
a462 2
#ifndef HAS_NICE
#define nice(a) not_here("nice")
d464 2
a465 2
#ifndef HAS_PATHCONF
#define pathconf(f,n)	(SysRetLong) not_here("pathconf")
d467 2
a468 2
#ifndef HAS_SYSCONF
#define sysconf(n)	(SysRetLong) not_here("sysconf")
d470 2
a471 2
#ifndef HAS_READLINK
#define readlink(a,b,c) not_here("readlink")
d473 2
a474 2
#ifndef HAS_SETPGID
#define setpgid(a,b) not_here("setpgid")
d476 2
a477 2
#ifndef HAS_SETSID
#define setsid() not_here("setsid")
d479 2
a480 2
#ifndef HAS_STRCOLL
#define strcoll(s1,s2) not_here("strcoll")
d482 2
a483 2
#ifndef HAS_STRTOD
#define strtod(s1,s2) not_here("strtod")
d485 2
a486 2
#ifndef HAS_STRTOL
#define strtol(s1,s2,b) not_here("strtol")
d488 2
a489 2
#ifndef HAS_STRTOUL
#define strtoul(s1,s2,b) not_here("strtoul")
d491 2
a492 2
#ifndef HAS_STRXFRM
#define strxfrm(s1,s2,n) not_here("strxfrm")
d494 2
a495 2
#ifndef HAS_TCGETPGRP
#define tcgetpgrp(a) not_here("tcgetpgrp")
d497 2
a498 2
#ifndef HAS_TCSETPGRP
#define tcsetpgrp(a,b) not_here("tcsetpgrp")
d500 2
a501 4
#ifndef HAS_TIMES
#ifndef NETWARE
#define times(a) not_here("times")
#endif	/* NETWARE */
d503 2
a504 2
#ifndef HAS_UNAME
#define uname(a) not_here("uname")
d506 2
a507 2
#ifndef HAS_WAITPID
#define waitpid(a,b,c) not_here("waitpid")
d509 2
a510 4

#ifndef HAS_MBLEN
#ifndef mblen
#define mblen(a,b) not_here("mblen")
d512 2
d515 2
a516 2
#ifndef HAS_MBSTOWCS
#define mbstowcs(s, pwcs, n) not_here("mbstowcs")
d518 2
a519 2
#ifndef HAS_MBTOWC
#define mbtowc(pwc, s, n) not_here("mbtowc")
d521 2
a522 2
#ifndef HAS_WCSTOMBS
#define wcstombs(s, pwcs, n) not_here("wcstombs")
d524 2
a525 2
#ifndef HAS_WCTOMB
#define wctomb(s, wchar) not_here("wcstombs")
d527 2
a528 8
#if !defined(HAS_MBLEN) && !defined(HAS_MBSTOWCS) && !defined(HAS_MBTOWC) && !defined(HAS_WCSTOMBS) && !defined(HAS_WCTOMB)
/* If we don't have these functions, then we wouldn't have gotten a typedef
   for wchar_t, the wide character type.  Defining wchar_t allows the
   functions referencing it to compile.  Its actual type is then meaningless,
   since without the above functions, all sections using it end up calling
   not_here() and croak.  --Kaveh Ghazi (ghazi@@noc.rutgers.edu) 9/18/94. */
#ifndef wchar_t
#define wchar_t char
d530 2
d533 2
a534 18

#ifdef HAS_LOCALECONV
struct lconv_offset {
    const char *name;
    size_t offset;
};

const struct lconv_offset lconv_strings[] = {
    {"decimal_point",     offsetof(struct lconv, decimal_point)},
    {"thousands_sep",     offsetof(struct lconv, thousands_sep)},
#ifndef NO_LOCALECONV_GROUPING
    {"grouping",          offsetof(struct lconv, grouping)},
#endif
    {"int_curr_symbol",   offsetof(struct lconv, int_curr_symbol)},
    {"currency_symbol",   offsetof(struct lconv, currency_symbol)},
    {"mon_decimal_point", offsetof(struct lconv, mon_decimal_point)},
#ifndef NO_LOCALECONV_MON_THOUSANDS_SEP
    {"mon_thousands_sep", offsetof(struct lconv, mon_thousands_sep)},
d536 2
a537 2
#ifndef NO_LOCALECONV_MON_GROUPING
    {"mon_grouping",      offsetof(struct lconv, mon_grouping)},
d539 2
a540 21
    {"positive_sign",     offsetof(struct lconv, positive_sign)},
    {"negative_sign",     offsetof(struct lconv, negative_sign)},
    {NULL, 0}
};

const struct lconv_offset lconv_integers[] = {
    {"int_frac_digits",     offsetof(struct lconv, int_frac_digits)},
    {"frac_digits",         offsetof(struct lconv, frac_digits)},
    {"p_cs_precedes",       offsetof(struct lconv, p_cs_precedes)},
    {"p_sep_by_space",      offsetof(struct lconv, p_sep_by_space)},
    {"n_cs_precedes",       offsetof(struct lconv, n_cs_precedes)},
    {"n_sep_by_space",      offsetof(struct lconv, n_sep_by_space)},
    {"p_sign_posn",         offsetof(struct lconv, p_sign_posn)},
    {"n_sign_posn",         offsetof(struct lconv, n_sign_posn)},
#ifdef HAS_LC_MONETARY_2008
    {"int_p_cs_precedes",   offsetof(struct lconv, int_p_cs_precedes)},
    {"int_p_sep_by_space",  offsetof(struct lconv, int_p_sep_by_space)},
    {"int_n_cs_precedes",   offsetof(struct lconv, int_n_cs_precedes)},
    {"int_n_sep_by_space",  offsetof(struct lconv, int_n_sep_by_space)},
    {"int_p_sign_posn",     offsetof(struct lconv, int_p_sign_posn)},
    {"int_n_sign_posn",     offsetof(struct lconv, int_n_sign_posn)},
d542 2
a543 5
    {NULL, 0}
};

#else
#define localeconv() not_here("localeconv")
d545 2
a546 5

#ifdef HAS_LONG_DOUBLE
#  if LONG_DOUBLESIZE > NVSIZE
#    undef HAS_LONG_DOUBLE  /* XXX until we figure out how to use them */
#  endif
d548 2
a549 4

#ifndef HAS_LONG_DOUBLE
#ifdef LDBL_MAX
#undef LDBL_MAX
d551 2
a552 2
#ifdef LDBL_MIN
#undef LDBL_MIN
d554 2
a555 2
#ifdef LDBL_EPSILON
#undef LDBL_EPSILON
d557 2
d561 45
a605 17
/* Background: in most systems the low byte of the wait status
 * is the signal (the lowest 7 bits) and the coredump flag is
 * the eight bit, and the second lowest byte is the exit status.
 * BeOS bucks the trend and has the bytes in different order.
 * See beos/beos.c for how the reality is bent even in BeOS
 * to follow the traditional.  However, to make the POSIX
 * wait W*() macros to work in BeOS, we need to unbend the
 * reality back in place. --jhi */
/* In actual fact the code below is to blame here. Perl has an internal
 * representation of the exit status ($?), which it re-composes from the
 * OS's representation using the W*() POSIX macros. The code below
 * incorrectly uses the W*() macros on the internal representation,
 * which fails for OSs that have a different representation (namely BeOS
 * and Haiku). WMUNGE() is a hack that converts the internal
 * representation into the OS specific one, so that the W*() macros work
 * as expected. The better solution would be not to use the W*() macros
 * in the first place, though. -- Ingo Weinhold
d607 15
a621 4
#if defined(__HAIKU__)
#    define WMUNGE(x) (((x) & 0xFF00) >> 8 | ((x) & 0x00FF) << 8)
#else
#    define WMUNGE(x) (x)
d624 2
a625 2
static int
not_here(const char *s)
d627 1
a627 2
    croak("POSIX::%s not implemented on this architecture", s);
    return -1;
d629 2
d632 8
a639 1
#include "const-c.inc"
d641 2
a642 2
static void
restore_sigmask(pTHX_ SV *osset_sv)
d644 1
a644 7
     /* Fortunately, restoring the signal mask can't fail, because
      * there's nothing we can do about it if it does -- we're not
      * supposed to return -1 from sigaction unless the disposition
      * was unaffected.
      */
     sigset_t *ossetp = (sigset_t *) SvPV_nolen( osset_sv );
     (void)sigprocmask(SIG_SETMASK, ossetp, (sigset_t *)0);
d646 22
d669 4
a672 4
static void *
allocate_struct(pTHX_ SV *rv, const STRLEN size, const char *packname) {
    SV *const t = newSVrv(rv, packname);
    void *const p = sv_grow(t, size + 1);
d674 4
a677 3
    SvCUR_set(t, size);
    SvPOK_on(t);
    return p;
d679 2
d682 7
a688 1
#ifdef WIN32
d690 13
a702 60
/*
 * (1) The CRT maintains its own copy of the environment, separate from
 * the Win32API copy.
 *
 * (2) CRT getenv() retrieves from this copy. CRT putenv() updates this
 * copy, and then calls SetEnvironmentVariableA() to update the Win32API
 * copy.
 *
 * (3) win32_getenv() and win32_putenv() call GetEnvironmentVariableA() and
 * SetEnvironmentVariableA() directly, bypassing the CRT copy of the
 * environment.
 *
 * (4) The CRT strftime() "%Z" implementation calls __tzset(). That
 * calls CRT tzset(), but only the first time it is called, and in turn
 * that uses CRT getenv("TZ") to retrieve the timezone info from the CRT
 * local copy of the environment and hence gets the original setting as
 * perl never updates the CRT copy when assigning to $ENV{TZ}.
 *
 * Therefore, we need to retrieve the value of $ENV{TZ} and call CRT
 * putenv() to update the CRT copy of the environment (if it is different)
 * whenever we're about to call tzset().
 *
 * In addition to all that, when perl is built with PERL_IMPLICIT_SYS
 * defined:
 *
 * (a) Each interpreter has its own copy of the environment inside the
 * perlhost structure. That allows applications that host multiple
 * independent Perl interpreters to isolate environment changes from
 * each other. (This is similar to how the perlhost mechanism keeps a
 * separate working directory for each Perl interpreter, so that calling
 * chdir() will not affect other interpreters.)
 *
 * (b) Only the first Perl interpreter instantiated within a process will
 * "write through" environment changes to the process environment.
 *
 * (c) Even the primary Perl interpreter won't update the CRT copy of the
 * the environment, only the Win32API copy (it calls win32_putenv()).
 *
 * As with CPerlHost::Getenv() and CPerlHost::Putenv() themselves, it makes
 * sense to only update the process environment when inside the main
 * interpreter, but we don't have access to CPerlHost's m_bTopLevel member
 * from here so we'll just have to check PL_curinterp instead.
 *
 * Therefore, we can simply #undef getenv() and putenv() so that those names
 * always refer to the CRT functions, and explicitly call win32_getenv() to
 * access perl's %ENV.
 *
 * We also #undef malloc() and free() to be sure we are using the CRT
 * functions otherwise under PERL_IMPLICIT_SYS they are redefined to calls
 * into VMem::Malloc() and VMem::Free() and all allocations will be freed
 * when the Perl interpreter is being destroyed so we'd end up with a pointer
 * into deallocated memory in environ[] if a program embedding a Perl
 * interpreter continues to operate even after the main Perl interpreter has
 * been destroyed.
 *
 * Note that we don't free() the malloc()ed memory unless and until we call
 * malloc() again ourselves because the CRT putenv() function simply puts its
 * pointer argument into the environ[] array (it doesn't make a copy of it)
 * so this memory must otherwise be leaked.
 */
d704 7
a710 4
#undef getenv
#undef putenv
#undef malloc
#undef free
d712 2
a713 2
static void
fix_win32_tzenv(void)
d715 1
a715 18
    static char* oldenv = NULL;
    char* newenv;
    const char* perl_tz_env = win32_getenv("TZ");
    const char* crt_tz_env = getenv("TZ");
    if (perl_tz_env == NULL)
        perl_tz_env = "";
    if (crt_tz_env == NULL)
        crt_tz_env = "";
    if (strcmp(perl_tz_env, crt_tz_env) != 0) {
        newenv = (char*)malloc((strlen(perl_tz_env) + 4) * sizeof(char));
        if (newenv != NULL) {
            sprintf(newenv, "TZ=%s", perl_tz_env);
            putenv(newenv);
            if (oldenv != NULL)
                free(oldenv);
            oldenv = newenv;
        }
    }
d717 2
d720 11
d733 2
a734 7
/*
 * my_tzset - wrapper to tzset() with a fix to make it work (better) on Win32.
 * This code is duplicated in the Time-Piece module, so any changes made here
 * should be made there too.
 */
static void
my_tzset(pTHX)
d736 8
a743 3
#ifdef WIN32
#if defined(USE_ITHREADS) && defined(PERL_IMPLICIT_SYS)
    if (PL_curinterp == aTHX)
d745 12
a756 1
        fix_win32_tzenv();
d758 1
a758 1
    tzset();
d761 23
a783 2
typedef int (*isfunc_t)(int);
typedef void (*any_dptr_t)(void *);
d785 2
a786 4
/* This needs to be ALIASed in a custom way, hence can't easily be defined as
   a regular XSUB.  */
static XSPROTO(is_common); /* prototype to pass -Wmissing-prototypes */
static XSPROTO(is_common)
d788 26
a813 2
    dXSARGS;
    static PTR_TBL_t * is_common_ptr_table;
d815 63
a877 2
    if (items != 1)
       croak_xs_usage(cv,  "charstring");
d879 11
a889 9
    {
	dXSTARG;
	STRLEN	len;
        /*int	RETVAL = 0;   YYY means uncomment this to return false on an
                            * empty string input */
	int	RETVAL;
	unsigned char *s = (unsigned char *) SvPV(ST(0), len);
	unsigned char *e = s + len;
	isfunc_t isfunc = (isfunc_t) XSANY.any_dptr;
d891 2
a892 1
        if (ckWARN_d(WARN_DEPRECATED)) {
d894 10
a903 3
            /* Warn exactly once for each lexical place this function is
             * called.  See thread at
             * http://markmail.org/thread/jhqcag5njmx7jpyu */
d905 3
a907 10
	    if (! is_common_ptr_table) {
               is_common_ptr_table = ptr_table_new();
            }
	    if (! ptr_table_fetch(is_common_ptr_table, PL_op)) {
                Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                            "Calling POSIX::%"HEKf"() is deprecated",
                            HEKfARG(GvNAME_HEK(CvGV(cv))));
                ptr_table_store(is_common_ptr_table, PL_op, (void *) 1);
            }
        }
d909 35
a943 7
        /*if (e > s) { YYY */
	for (RETVAL = 1; RETVAL && s < e; s++)
	    if (!isfunc(*s))
		RETVAL = 0;
        /*} YYY */
	XSprePUSH;
	PUSHi((IV)RETVAL);
d945 3
a947 1
    XSRETURN(1);
d949 1
d951 17
a967 1
MODULE = POSIX		PACKAGE = POSIX
d969 2
a970 1
BOOT:
d972 4
a975 2
    CV *cv;
    const char *file = __FILE__;
d977 1
d979 1
a979 2
    /* silence compiler warning about not_here() defined but not used */
    if (0) not_here("");
d981 31
a1011 35
    /* Ensure we get the function, not a macro implementation. Like the C89
       standard says we can...  */
#undef isalnum
    cv = newXS("POSIX::isalnum", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &isalnum;
#undef isalpha
    cv = newXS("POSIX::isalpha", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &isalpha;
#undef iscntrl
    cv = newXS("POSIX::iscntrl", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &iscntrl;
#undef isdigit
    cv = newXS("POSIX::isdigit", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &isdigit;
#undef isgraph
    cv = newXS("POSIX::isgraph", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &isgraph;
#undef islower
    cv = newXS("POSIX::islower", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &islower;
#undef isprint
    cv = newXS("POSIX::isprint", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &isprint;
#undef ispunct
    cv = newXS("POSIX::ispunct", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &ispunct;
#undef isspace
    cv = newXS("POSIX::isspace", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &isspace;
#undef isupper
    cv = newXS("POSIX::isupper", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &isupper;
#undef isxdigit
    cv = newXS("POSIX::isxdigit", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &isxdigit;
d1014 2
a1015 1
MODULE = SigSet		PACKAGE = POSIX::SigSet		PREFIX = sig
d1017 2
a1018 15
void
new(packname = "POSIX::SigSet", ...)
    const char *	packname
    CODE:
	{
	    int i;
	    sigset_t *const s
		= (sigset_t *) allocate_struct(aTHX_ (ST(0) = sv_newmortal()),
					       sizeof(sigset_t),
					       packname);
	    sigemptyset(s);
	    for (i = 1; i < items; i++)
		sigaddset(s, SvIV(ST(i)));
	    XSRETURN(1);
	}
d1020 2
a1021 10
SysRet
addset(sigset, sig)
	POSIX::SigSet	sigset
	int		sig
   ALIAS:
	delset = 1
   CODE:
	RETVAL = ix ? sigdelset(sigset, sig) : sigaddset(sigset, sig);
   OUTPUT:
	RETVAL
d1023 2
a1024 9
SysRet
emptyset(sigset)
	POSIX::SigSet	sigset
   ALIAS:
	fillset = 1
   CODE:
	RETVAL = ix ? sigfillset(sigset) : sigemptyset(sigset);
   OUTPUT:
	RETVAL
d1026 24
a1049 4
int
sigismember(sigset, sig)
	POSIX::SigSet	sigset
	int		sig
d1051 1204
a2254 18
MODULE = Termios	PACKAGE = POSIX::Termios	PREFIX = cf

void
new(packname = "POSIX::Termios", ...)
    const char *	packname
    CODE:
	{
#ifdef I_TERMIOS
	    void *const p = allocate_struct(aTHX_ (ST(0) = sv_newmortal()),
					    sizeof(struct termios), packname);
	    /* The previous implementation stored a pointer to an uninitialised
	       struct termios. Seems safer to initialise it, particularly as
	       this implementation exposes the struct to prying from perl-space.
	    */
	    memset(p, 0, 1 + sizeof(struct termios));
	    XSRETURN(1);
#else
	    not_here("termios");
d2256 4
a2260 7

SysRet
getattr(termios_ref, fd = 0)
	POSIX::Termios	termios_ref
	int		fd
    CODE:
	RETVAL = tcgetattr(fd, termios_ref);
d2264 3
a2266 24
# If we define TCSANOW here then both a found and not found constant sub
# are created causing a Constant subroutine TCSANOW redefined warning
#ifndef TCSANOW
#  define DEF_SETATTR_ACTION 0
#else
#  define DEF_SETATTR_ACTION TCSANOW
#endif
SysRet
setattr(termios_ref, fd = 0, optional_actions = DEF_SETATTR_ACTION)
	POSIX::Termios	termios_ref
	int		fd
	int		optional_actions
    CODE:
	/* The second argument to the call is mandatory, but we'd like to give
	   it a useful default. 0 isn't valid on all operating systems - on
	   Solaris (at least) TCSANOW, TCSADRAIN and TCSAFLUSH have the same
	   values as the equivalent ioctls, TCSETS, TCSETSW and TCSETSF.  */
	RETVAL = tcsetattr(fd, optional_actions, termios_ref);
    OUTPUT:
	RETVAL

speed_t
getispeed(termios_ref)
	POSIX::Termios	termios_ref
d2268 30
a2297 1
	getospeed = 1
d2299 3
a2301 14
	RETVAL = ix ? cfgetospeed(termios_ref) : cfgetispeed(termios_ref);
    OUTPUT:
	RETVAL

tcflag_t
getiflag(termios_ref)
	POSIX::Termios	termios_ref
    ALIAS:
	getoflag = 1
	getcflag = 2
	getlflag = 3
    CODE:
#ifdef I_TERMIOS /* References a termios structure member so ifdef it out. */
	switch(ix) {
d2303 1
a2303 1
	    RETVAL = termios_ref->c_iflag;
d2306 5
a2310 1
	    RETVAL = termios_ref->c_oflag;
d2313 1
a2313 1
	    RETVAL = termios_ref->c_cflag;
d2316 160
a2475 1
	    RETVAL = termios_ref->c_lflag;
d2477 4
a2480 3
        default:
	    RETVAL = 0; /* silence compiler warning */
	}
d2482 1
a2482 2
	not_here(GvNAME(CvGV(cv)));
	RETVAL = 0;
d2484 1
d2488 2
a2489 4
cc_t
getcc(termios_ref, ccix)
	POSIX::Termios	termios_ref
	unsigned int	ccix
d2491 2
a2492 4
#ifdef I_TERMIOS /* References a termios structure member so ifdef it out. */
	if (ccix >= NCCS)
	    croak("Bad getcc subscript");
	RETVAL = termios_ref->c_cc[ccix];
d2494 2
a2495 2
     not_here("getcc");
     RETVAL = 0;
d2500 3
a2502 6
SysRet
setispeed(termios_ref, speed)
	POSIX::Termios	termios_ref
	speed_t		speed
    ALIAS:
	setospeed = 1
d2504 17
a2520 28
	RETVAL = ix
	    ? cfsetospeed(termios_ref, speed) : cfsetispeed(termios_ref, speed);
    OUTPUT:
	RETVAL

void
setiflag(termios_ref, flag)
	POSIX::Termios	termios_ref
	tcflag_t	flag
    ALIAS:
	setoflag = 1
	setcflag = 2
	setlflag = 3
    CODE:
#ifdef I_TERMIOS /* References a termios structure member so ifdef it out. */
	switch(ix) {
	case 0:
	    termios_ref->c_iflag = flag;
	    break;
	case 1:
	    termios_ref->c_oflag = flag;
	    break;
	case 2:
	    termios_ref->c_cflag = flag;
	    break;
	case 3:
	    termios_ref->c_lflag = flag;
	    break;
d2523 3
a2525 1
	not_here(GvNAME(CvGV(cv)));
d2527 2
d2530 3
a2532 22
void
setcc(termios_ref, ccix, cc)
	POSIX::Termios	termios_ref
	unsigned int	ccix
	cc_t		cc
    CODE:
#ifdef I_TERMIOS /* References a termios structure member so ifdef it out. */
	if (ccix >= NCCS)
	    croak("Bad setcc subscript");
	termios_ref->c_cc[ccix] = cc;
#else
	    not_here("setcc");
#endif


MODULE = POSIX		PACKAGE = POSIX

INCLUDE: const-xs.inc

int
WEXITSTATUS(status)
	int status
d2534 8
a2541 5
	POSIX::WIFEXITED = 1
	POSIX::WIFSIGNALED = 2
	POSIX::WIFSTOPPED = 3
	POSIX::WSTOPSIG = 4
	POSIX::WTERMSIG = 5
d2543 3
a2545 6
#if !defined(WEXITSTATUS) || !defined(WIFEXITED) || !defined(WIFSIGNALED) \
      || !defined(WIFSTOPPED) || !defined(WSTOPSIG) || !defined(WTERMSIG)
        RETVAL = 0; /* Silence compilers that notice this, but don't realise
		       that not_here() can't return.  */
#endif
	switch(ix) {
d2547 2
a2548 2
#ifdef WEXITSTATUS
	    RETVAL = WEXITSTATUS(WMUNGE(status));
d2550 1
a2550 1
	    not_here("WEXITSTATUS");
d2554 2
a2555 2
#ifdef WIFEXITED
	    RETVAL = WIFEXITED(WMUNGE(status));
d2557 1
a2557 1
	    not_here("WIFEXITED");
d2561 11
a2571 2
#ifdef WIFSIGNALED
	    RETVAL = WIFSIGNALED(WMUNGE(status));
d2573 1
a2573 1
	    not_here("WIFSIGNALED");
d2576 3
a2578 3
	case 3:
#ifdef WIFSTOPPED
	    RETVAL = WIFSTOPPED(WMUNGE(status));
d2580 1
a2580 1
	    not_here("WIFSTOPPED");
d2583 3
a2585 3
	case 4:
#ifdef WSTOPSIG
	    RETVAL = WSTOPSIG(WMUNGE(status));
d2587 1
a2587 1
	    not_here("WSTOPSIG");
d2590 4
a2593 3
	case 5:
#ifdef WTERMSIG
	    RETVAL = WTERMSIG(WMUNGE(status));
d2595 1
a2595 1
	    not_here("WTERMSIG");
a2597 2
	default:
	    Perl_croak(aTHX_ "Illegal alias %d for POSIX::W*", (int)ix);
d2602 3
a2604 5
SysRet
open(filename, flags = O_RDONLY, mode = 0666)
	char *		filename
	int		flags
	Mode_t		mode
d2606 1
a2606 3
	if (flags & (O_APPEND|O_CREAT|O_TRUNC|O_RDWR|O_WRONLY|O_EXCL))
	    TAINT_PROPER("open");
	RETVAL = open(filename, flags, mode);
d2610 8
d2619 4
a2622 2
HV *
localeconv()
d2624 2
a2625 28
#ifdef HAS_LOCALECONV
	struct lconv *lcbuf;
	RETVAL = newHV();
	sv_2mortal((SV*)RETVAL);
	if ((lcbuf = localeconv())) {
	    const struct lconv_offset *strings = lconv_strings;
	    const struct lconv_offset *integers = lconv_integers;
	    const char *ptr = (const char *) lcbuf;

	    do {
		const char *value = *((const char **)(ptr + strings->offset));

		if (value && *value)
		    (void) hv_store(RETVAL, strings->name, strlen(strings->name),
				    newSVpv(value, 0), 0);
	    } while ((++strings)->name);

	    do {
		const char value = *((const char *)(ptr + integers->offset));

		if (value != CHAR_MAX)
		    (void) hv_store(RETVAL, integers->name,
				    strlen(integers->name), newSViv(value), 0);
	    } while ((++integers)->name);
	}
#else
	localeconv(); /* A stub to call not_here(). */
#endif
d2627 1
a2627 1
	RETVAL
d2629 3
a2631 6
char *
setlocale(category, locale = 0)
	int		category
	char *		locale
    PREINIT:
	char *		retval;
d2633 1
a2633 64
#ifdef WIN32    /* Use wrapper on Windows */
	retval = Perl_my_setlocale(aTHX_ category, locale);
#else
	retval = setlocale(category, locale);
#endif
	if (! retval) {
            XSRETURN_UNDEF;
        }
        else {
	    /* Save retval since subsequent setlocale() calls
	     * may overwrite it. */
	    RETVAL = savepv(retval);
#ifdef USE_LOCALE_CTYPE
	    if (category == LC_CTYPE
#ifdef LC_ALL
		|| category == LC_ALL
#endif
		)
	    {
		char *newctype;
#ifdef LC_ALL
		if (category == LC_ALL)
		    newctype = setlocale(LC_CTYPE, NULL);
		else
#endif
		    newctype = RETVAL;
		new_ctype(newctype);
	    }
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
	    if (category == LC_COLLATE
#ifdef LC_ALL
		|| category == LC_ALL
#endif
		)
	    {
		char *newcoll;
#ifdef LC_ALL
		if (category == LC_ALL)
		    newcoll = setlocale(LC_COLLATE, NULL);
		else
#endif
		    newcoll = RETVAL;
		new_collate(newcoll);
	    }
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
	    if (category == LC_NUMERIC
#ifdef LC_ALL
		|| category == LC_ALL
#endif
		)
	    {
		char *newnum;
#ifdef LC_ALL
		if (category == LC_ALL)
		    newnum = setlocale(LC_NUMERIC, NULL);
		else
#endif
		    newnum = RETVAL;
		new_numeric(newnum);
	    }
#endif /* USE_LOCALE_NUMERIC */
	}
a2635 2
    CLEANUP:
        Safefree(RETVAL);
d2638 1
a2638 1
acos(x)
d2640 1
d2642 18
a2659 10
	asin = 1
	atan = 2
	ceil = 3
	cosh = 4
	floor = 5
	log10 = 6
	sinh = 7
	tan = 8
	tanh = 9
    CODE:
d2662 5
a2666 1
	    RETVAL = acos(x);
d2669 5
a2673 1
	    RETVAL = asin(x);
d2676 5
a2680 1
	    RETVAL = atan(x);
d2683 5
a2687 1
	    RETVAL = ceil(x);
d2690 1
a2690 1
	    RETVAL = cosh(x);
d2693 5
a2697 1
	    RETVAL = floor(x);
d2700 5
a2704 1
	    RETVAL = log10(x);
d2707 5
a2711 1
	    RETVAL = sinh(x);
d2714 40
a2753 1
	    RETVAL = tan(x);
d2755 1
d2757 6
a2762 1
	    RETVAL = tanh(x);
d2764 2
a2765 7
    OUTPUT:
	RETVAL

NV
fmod(x,y)
	NV		x
	NV		y
d2773 1
a2773 1
	PUSHs(sv_2mortal(newSVnv(frexp(x,&expvar))));
d2787 1
a2787 1
	PUSHs(sv_2mortal(newSVnv(Perl_modf(x,&intvar))));
d2790 108
d2904 1
a2904 1
#if defined(WIN32) || defined(NETWARE)
d2907 1
a2907 1
# This code is really grody because we're trying to make the signal
d3094 3
d3098 1
d3135 1
d3137 12
a3148 7
	/* RT #98912 - More Microsoft muppetry - failing to actually implemented
	   the well known documented POSIX behaviour for a POSIX API.
	   http://msdn.microsoft.com/en-us/library/8syseb29.aspx   */
	RETVAL = dup2(fd1, fd2) == -1 ? -1 : fd2;
#else
	RETVAL = dup2(fd1, fd2);
#endif
d3154 1
a3154 1
	int		fd
d3158 5
a3162 3
	Off_t pos = PerlLIO_lseek(fd, offset, whence);
	RETVAL = sizeof(Off_t) > sizeof(IV)
		 ? newSVnv((NV)pos) : newSViv((IV)pos);
d3193 1
a3193 1
        int             fd
d3214 1
a3214 1
	int		fd
d3218 1
a3218 1
	int		fd
d3240 1
a3240 1
	int		fd
d3250 1
a3250 1
	RETVAL = newSVpvn("", 0);
d3252 13
d3313 2
a3314 1
        STORE_NUMERIC_STANDARD_FORCE_LOCAL();
d3317 1
a3317 1
	if (GIMME == G_ARRAY) {
d3324 3
a3326 1
        RESTORE_NUMERIC_STANDARD();
d3329 1
a3329 1
strtol(str, base = 0)
a3330 1
	int		base
d3332 1
a3332 1
	long num;
d3335 5
a3339 8
	num = strtol(str, &unparsed, base);
#if IVSIZE <= LONGSIZE
	if (num < IV_MIN || num > IV_MAX)
	    PUSHs(sv_2mortal(newSVnv((double)num)));
	else
#endif
	    PUSHs(sv_2mortal(newSViv((IV)num)));
	if (GIMME == G_ARRAY) {
d3346 35
d3390 4
a3393 1
	num = strtoul(str, &unparsed, base);
d3395 20
a3414 12
	if (num > IV_MAX)
	    PUSHs(sv_2mortal(newSVnv((double)num)));
	else
#endif
	    PUSHs(sv_2mortal(newSViv((IV)num)));
	if (GIMME == G_ARRAY) {
	    EXTEND(SP, 1);
	    if (unparsed)
		PUSHs(sv_2mortal(newSViv(strlen(unparsed))));
	    else
		PUSHs(&PL_sv_undef);
	}
d3423 1
d3426 4
a3429 3
          ST(0) = sv_2mortal(newSV(srclen*4+1));
          dstlen = strxfrm(SvPVX(ST(0)), p, (size_t)srclen);
          if (dstlen > srclen) {
d3457 1
a3457 1
	int		fd
d3462 7
a3468 2
	RETVAL = ix == 1 ? close(fd)
	    : (ix < 1 ? tcdrain(fd) : dup(fd));
d3475 1
a3475 1
	int		fd
d3481 7
a3487 2
	RETVAL = ix == 1 ? tcflush(fd, action)
	    : (ix < 1 ? tcflow(fd, action) : tcsendbreak(fd, action));
d3576 1
d3584 1
d3586 9
a3594 3
		SV *const sv = sv_newmortal();
		sv_usepvn_flags(sv, buf, strlen(buf), SV_HAS_TRAILING_NUL);
		if (SvUTF8(fmt)) {
d3597 11
a3607 2
		ST(0) = sv;
	    }
d3644 1
d3653 1
a3653 1
	int		fd
d3688 1
a3688 1
	int		fd
d3710 3
@


1.21
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d312 16
a327 8
    {"int_frac_digits",   offsetof(struct lconv, int_frac_digits)},
    {"frac_digits",       offsetof(struct lconv, frac_digits)},
    {"p_cs_precedes",     offsetof(struct lconv, p_cs_precedes)},
    {"p_sep_by_space",    offsetof(struct lconv, p_sep_by_space)},
    {"n_cs_precedes",     offsetof(struct lconv, n_cs_precedes)},
    {"n_sep_by_space",    offsetof(struct lconv, n_sep_by_space)},
    {"p_sign_posn",       offsetof(struct lconv, p_sign_posn)},
    {"n_sign_posn",       offsetof(struct lconv, n_sign_posn)},
@


1.20
log
@Apply local patches to perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d312 8
a319 16
    {"int_frac_digits",     offsetof(struct lconv, int_frac_digits)},
    {"frac_digits",         offsetof(struct lconv, frac_digits)},
    {"p_cs_precedes",       offsetof(struct lconv, p_cs_precedes)},
    {"p_sep_by_space",      offsetof(struct lconv, p_sep_by_space)},
    {"n_cs_precedes",       offsetof(struct lconv, n_cs_precedes)},
    {"n_sep_by_space",      offsetof(struct lconv, n_sep_by_space)},
    {"p_sign_posn",         offsetof(struct lconv, p_sign_posn)},
    {"n_sign_posn",         offsetof(struct lconv, n_sign_posn)},
#ifdef HAS_LC_MONETARY_2008
    {"int_p_cs_precedes",   offsetof(struct lconv, int_p_cs_precedes)},
    {"int_p_sep_by_space",  offsetof(struct lconv, int_p_sep_by_space)},
    {"int_n_cs_precedes",   offsetof(struct lconv, int_n_cs_precedes)},
    {"int_n_sep_by_space",  offsetof(struct lconv, int_n_sep_by_space)},
    {"int_p_sign_posn",     offsetof(struct lconv, int_p_sign_posn)},
    {"int_n_sign_posn",     offsetof(struct lconv, int_n_sign_posn)},
#endif
@


1.19
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d312 16
a327 8
    {"int_frac_digits",   offsetof(struct lconv, int_frac_digits)},
    {"frac_digits",       offsetof(struct lconv, frac_digits)},
    {"p_cs_precedes",     offsetof(struct lconv, p_cs_precedes)},
    {"p_sep_by_space",    offsetof(struct lconv, p_sep_by_space)},
    {"n_cs_precedes",     offsetof(struct lconv, n_cs_precedes)},
    {"n_sep_by_space",    offsetof(struct lconv, n_sep_by_space)},
    {"p_sign_posn",       offsetof(struct lconv, p_sign_posn)},
    {"n_sign_posn",       offsetof(struct lconv, n_sign_posn)},
@


1.18
log
@international currency locale rules as per POSIX.1-2008

required for libc++

ok guenther afresh1
@
text
@d31 3
d89 2
a90 6
#  include <libdef.h>       /* LIB$_INVARG constant */
#  include <lib$routines.h> /* prototype for lib$ediv() */
#  include <starlet.h>      /* prototype for sys$gettim() */
#  if DECC_VERSION < 50000000
#    define pid_t int       /* old versions of DECC miss this in types.h */
#  endif
a93 6
#  define tzset() not_here("tzset")

#if ((__VMS_VER >= 70000000) && (__DECC_VER >= 50200000)) || (__CRTL_VER >= 70000000)
#    define HAS_TZNAME  /* shows up in VMS 7.0 or Dec C 5.6 */
#    include <utsname.h>
#  endif /* __VMS_VER >= 70000000 or Dec C 5.6 */
a98 27
   /* The non-POSIX CRTL times() has void return type, so we just get the
      current time directly */
   clock_t vms_times(struct tms *bufptr) {
	dTHX;
	clock_t retval;
	/* Get wall time and convert to 10 ms intervals to
	 * produce the return value that the POSIX standard expects */
#  if defined(__DECC) && defined (__ALPHA)
#    include <ints.h>
	uint64 vmstime;
	_ckvmssts(sys$gettim(&vmstime));
	vmstime /= 100000;
	retval = vmstime & 0x7fffffff;
#  else
	/* (Older hw or ccs don't have an atomic 64-bit type, so we
	 * juggle 32-bit ints (and a float) to produce a time_t result
	 * with minimal loss of information.) */
	long int vmstime[2],remainder,divisor = 100000;
	_ckvmssts(sys$gettim((unsigned long int *)vmstime));
	vmstime[1] &= 0x7fff;  /* prevent overflow in EDIV */
	_ckvmssts(lib$ediv(&divisor,vmstime,(long int *)&retval,&remainder));
#  endif
	/* Fill in the struct tms using the CRTL routine . . .*/
	times((tbuffer_t *)bufptr);
	return (clock_t) retval;
   }
#  define times(t) vms_times(t)
a161 154
#ifdef WIN32
   /* Perl on Windows assigns WSAGetLastError() return values to errno
    * (in win32/win32sck.c).  Therefore we need to map these values
    * back to standard symbolic names, but only for those names having
    * no existing value or an existing value >= 100. (VC++ 2010 defines
    * a group of names with values >= 100 in its errno.h which we *do*
    * need to redefine.) The Errno.pm module does a similar mapping.
    */
#  ifdef EWOULDBLOCK
#    undef EWOULDBLOCK
#  endif
#  define EWOULDBLOCK WSAEWOULDBLOCK
#  ifdef EINPROGRESS
#    undef EINPROGRESS
#  endif
#  define EINPROGRESS WSAEINPROGRESS
#  ifdef EALREADY
#    undef EALREADY
#  endif
#  define EALREADY WSAEALREADY
#  ifdef ENOTSOCK
#    undef ENOTSOCK
#  endif
#  define ENOTSOCK WSAENOTSOCK
#  ifdef EDESTADDRREQ
#    undef EDESTADDRREQ
#  endif
#  define EDESTADDRREQ WSAEDESTADDRREQ
#  ifdef EMSGSIZE
#    undef EMSGSIZE
#  endif
#  define EMSGSIZE WSAEMSGSIZE
#  ifdef EPROTOTYPE
#    undef EPROTOTYPE
#  endif
#  define EPROTOTYPE WSAEPROTOTYPE
#  ifdef ENOPROTOOPT
#    undef ENOPROTOOPT
#  endif
#  define ENOPROTOOPT WSAENOPROTOOPT
#  ifdef EPROTONOSUPPORT
#    undef EPROTONOSUPPORT
#  endif
#  define EPROTONOSUPPORT WSAEPROTONOSUPPORT
#  ifdef ESOCKTNOSUPPORT
#    undef ESOCKTNOSUPPORT
#  endif
#  define ESOCKTNOSUPPORT WSAESOCKTNOSUPPORT
#  ifdef EOPNOTSUPP
#    undef EOPNOTSUPP
#  endif
#  define EOPNOTSUPP WSAEOPNOTSUPP
#  ifdef EPFNOSUPPORT
#    undef EPFNOSUPPORT
#  endif
#  define EPFNOSUPPORT WSAEPFNOSUPPORT
#  ifdef EAFNOSUPPORT
#    undef EAFNOSUPPORT
#  endif
#  define EAFNOSUPPORT WSAEAFNOSUPPORT
#  ifdef EADDRINUSE
#    undef EADDRINUSE
#  endif
#  define EADDRINUSE WSAEADDRINUSE
#  ifdef EADDRNOTAVAIL
#    undef EADDRNOTAVAIL
#  endif
#  define EADDRNOTAVAIL WSAEADDRNOTAVAIL
#  ifdef ENETDOWN
#    undef ENETDOWN
#  endif
#  define ENETDOWN WSAENETDOWN
#  ifdef ENETUNREACH
#    undef ENETUNREACH
#  endif
#  define ENETUNREACH WSAENETUNREACH
#  ifdef ENETRESET
#    undef ENETRESET
#  endif
#  define ENETRESET WSAENETRESET
#  ifdef ECONNABORTED
#    undef ECONNABORTED
#  endif
#  define ECONNABORTED WSAECONNABORTED
#  ifdef ECONNRESET
#    undef ECONNRESET
#  endif
#  define ECONNRESET WSAECONNRESET
#  ifdef ENOBUFS
#    undef ENOBUFS
#  endif
#  define ENOBUFS WSAENOBUFS
#  ifdef EISCONN
#    undef EISCONN
#  endif
#  define EISCONN WSAEISCONN
#  ifdef ENOTCONN
#    undef ENOTCONN
#  endif
#  define ENOTCONN WSAENOTCONN
#  ifdef ESHUTDOWN
#    undef ESHUTDOWN
#  endif
#  define ESHUTDOWN WSAESHUTDOWN
#  ifdef ETOOMANYREFS
#    undef ETOOMANYREFS
#  endif
#  define ETOOMANYREFS WSAETOOMANYREFS
#  ifdef ETIMEDOUT
#    undef ETIMEDOUT
#  endif
#  define ETIMEDOUT WSAETIMEDOUT
#  ifdef ECONNREFUSED
#    undef ECONNREFUSED
#  endif
#  define ECONNREFUSED WSAECONNREFUSED
#  ifdef ELOOP
#    undef ELOOP
#  endif
#  define ELOOP WSAELOOP
#  ifdef EHOSTDOWN
#    undef EHOSTDOWN
#  endif
#  define EHOSTDOWN WSAEHOSTDOWN
#  ifdef EHOSTUNREACH
#    undef EHOSTUNREACH
#  endif
#  define EHOSTUNREACH WSAEHOSTUNREACH
#  ifdef EPROCLIM
#    undef EPROCLIM
#  endif
#  define EPROCLIM WSAEPROCLIM
#  ifdef EUSERS
#    undef EUSERS
#  endif
#  define EUSERS WSAEUSERS
#  ifdef EDQUOT
#    undef EDQUOT
#  endif
#  define EDQUOT WSAEDQUOT
#  ifdef ESTALE
#    undef ESTALE
#  endif
#  define ESTALE WSAESTALE
#  ifdef EREMOTE
#    undef EREMOTE
#  endif
#  define EREMOTE WSAEREMOTE
#  ifdef EDISCON
#    undef EDISCON
#  endif
#  define EDISCON WSAEDISCON
#endif

a319 6
    {"int_p_cs_precedes",	offsetof(struct lconv, int_p_cs_precedes)},
    {"int_p_sep_by_space",	offsetof(struct lconv, int_p_sep_by_space)},
    {"int_n_cs_precedes",	offsetof(struct lconv, int_n_cs_precedes)},
    {"int_n_sep_by_space",	offsetof(struct lconv, int_n_sep_by_space)},
    {"int_p_sign_posn",		offsetof(struct lconv, int_p_sign_posn)},
    {"int_n_sign_posn",		offsetof(struct lconv, int_n_sign_posn)},
d519 2
a520 1
    SV *charstring;
d527 2
d534 18
d555 1
d569 4
d737 2
d940 3
d944 5
a948 1
	if (retval) {
a1003 2
	else
	    RETVAL = NULL;
d1007 1
a1007 2
        if (RETVAL)
	    Safefree(RETVAL);
d1475 1
a1475 1
	SET_NUMERIC_LOCAL();
d1485 1
d1680 8
a1687 1
	    char *buf = my_strftime(SvPV_nolen(fmt), sec, min, hour, mday, mon, year, wday, yday, isdst);
@


1.17
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d508 6
@


1.16
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d376 1
d380 1
d551 1
a551 1
#if defined(__BEOS__) || defined(__HAIKU__)
@


1.15
log
@merge in perl 5.12.2 plus local changes
@
text
@a84 20
#ifndef PERL_UNUSED_DECL
#  ifdef HASATTRIBUTE
#    if (defined(__GNUC__) && defined(__cplusplus)) || defined(__INTEL_COMPILER)
#      define PERL_UNUSED_DECL
#    else
#      define PERL_UNUSED_DECL __attribute__((unused))
#    endif
#  else
#    define PERL_UNUSED_DECL
#  endif
#endif

#ifndef dNOOP
#define dNOOP extern int Perl___notused PERL_UNUSED_DECL
#endif

#ifndef dVAR
#define dVAR dNOOP
#endif

a142 3
#  ifdef __BORLANDC__
#    define tzname _tzname
#  endif
d199 4
a202 3
    * back to standard symbolic names, as long as the same name isn't
    * already defined by errno.h itself.  The Errno.pm module does
    * a similar mapping.
d204 2
a205 53
#  ifndef EWOULDBLOCK
#    define EWOULDBLOCK WSAEWOULDBLOCK
#  endif
#  ifndef EINPROGRESS
#    define EINPROGRESS WSAEINPROGRESS
#  endif
#  ifndef EALREADY
#    define EALREADY WSAEALREADY
#  endif
#  ifndef ENOTSOCK
#    define ENOTSOCK WSAENOTSOCK
#  endif
#  ifndef EDESTADDRREQ
#    define EDESTADDRREQ WSAEDESTADDRREQ
#  endif
#  ifndef EMSGSIZE
#    define EMSGSIZE WSAEMSGSIZE
#  endif
#  ifndef EPROTOTYPE
#    define EPROTOTYPE WSAEPROTOTYPE
#  endif
#  ifndef ENOPROTOOPT
#    define ENOPROTOOPT WSAENOPROTOOPT
#  endif
#  ifndef EPROTONOSUPPORT
#    define EPROTONOSUPPORT WSAEPROTONOSUPPORT
#  endif
#  ifndef ESOCKTNOSUPPORT
#    define ESOCKTNOSUPPORT WSAESOCKTNOSUPPORT
#  endif
#  ifndef EOPNOTSUPP
#    define EOPNOTSUPP WSAEOPNOTSUPP
#  endif
#  ifndef EPFNOSUPPORT
#    define EPFNOSUPPORT WSAEPFNOSUPPORT
#  endif
#  ifndef EAFNOSUPPORT
#    define EAFNOSUPPORT WSAEAFNOSUPPORT
#  endif
#  ifndef EADDRINUSE
#    define EADDRINUSE WSAEADDRINUSE
#  endif
#  ifndef EADDRNOTAVAIL
#    define EADDRNOTAVAIL WSAEADDRNOTAVAIL
#  endif
#  ifndef ENETDOWN
#    define ENETDOWN WSAENETDOWN
#  endif
#  ifndef ENETUNREACH
#    define ENETUNREACH WSAENETUNREACH
#  endif
#  ifndef ENETRESET
#    define ENETRESET WSAENETRESET
d207 139
a345 59
#  ifndef ECONNABORTED
#    define ECONNABORTED WSAECONNABORTED
#  endif
#  ifndef ECONNRESET
#    define ECONNRESET WSAECONNRESET
#  endif
#  ifndef ENOBUFS
#    define ENOBUFS WSAENOBUFS
#  endif
#  ifndef EISCONN
#    define EISCONN WSAEISCONN
#  endif
#  ifndef ENOTCONN
#    define ENOTCONN WSAENOTCONN
#  endif
#  ifndef ESHUTDOWN
#    define ESHUTDOWN WSAESHUTDOWN
#  endif
#  ifndef ETOOMANYREFS
#    define ETOOMANYREFS WSAETOOMANYREFS
#  endif
#  ifndef ETIMEDOUT
#    define ETIMEDOUT WSAETIMEDOUT
#  endif
#  ifndef ECONNREFUSED
#    define ECONNREFUSED WSAECONNREFUSED
#  endif
#  ifndef ELOOP
#    define ELOOP WSAELOOP
#  endif
#  ifndef ENAMETOOLONG
#    define ENAMETOOLONG WSAENAMETOOLONG
#  endif
#  ifndef EHOSTDOWN
#    define EHOSTDOWN WSAEHOSTDOWN
#  endif
#  ifndef EHOSTUNREACH
#    define EHOSTUNREACH WSAEHOSTUNREACH
#  endif
#  ifndef ENOTEMPTY
#    define ENOTEMPTY WSAENOTEMPTY
#  endif
#  ifndef EPROCLIM
#    define EPROCLIM WSAEPROCLIM
#  endif
#  ifndef EUSERS
#    define EUSERS WSAEUSERS
#  endif
#  ifndef EDQUOT
#    define EDQUOT WSAEDQUOT
#  endif
#  ifndef ESTALE
#    define ESTALE WSAESTALE
#  endif
#  ifndef EREMOTE
#    define EREMOTE WSAEREMOTE
#  endif
#  ifndef EDISCON
#    define EDISCON WSAEDISCON
d347 1
d471 39
a509 1
#ifndef HAS_LOCALECONV
d576 10
d645 1
a645 1
 * pointer argument into the environ[] arrary (it doesn't make a copy of it)
d696 74
d772 1
a772 1
POSIX::SigSet
d778 5
a782 2
	    Newx(RETVAL, 1, sigset_t);
	    sigemptyset(RETVAL);
d784 2
a785 1
		sigaddset(RETVAL, SvIV(ST(i)));
a786 8
    OUTPUT:
	RETVAL

void
DESTROY(sigset)
	POSIX::SigSet	sigset
    CODE:
	Safefree(sigset);
d789 1
a789 1
sigaddset(sigset, sig)
d792 6
d800 1
a800 10
sigdelset(sigset, sig)
	POSIX::SigSet	sigset
	int		sig

SysRet
sigemptyset(sigset)
	POSIX::SigSet	sigset

SysRet
sigfillset(sigset)
d802 6
d816 1
a816 1
POSIX::Termios
d822 8
a829 1
	    Newx(RETVAL, 1, struct termios);
a831 1
        RETVAL = 0;
a833 12
    OUTPUT:
	RETVAL

void
DESTROY(termios_ref)
	POSIX::Termios	termios_ref
    CODE:
#ifdef I_TERMIOS
	Safefree(termios_ref);
#else
	    not_here("termios");
#endif
d844 7
d852 1
a852 1
setattr(termios_ref, fd = 0, optional_actions = 0)
d857 4
d866 1
a866 9
cfgetispeed(termios_ref)
	POSIX::Termios	termios_ref

speed_t
cfgetospeed(termios_ref)
	POSIX::Termios	termios_ref

tcflag_t
getiflag(termios_ref)
d868 2
d871 1
a871 6
#ifdef I_TERMIOS /* References a termios structure member so ifdef it out. */
	RETVAL = termios_ref->c_iflag;
#else
     not_here("getiflag");
     RETVAL = 0;
#endif
d876 1
a876 1
getoflag(termios_ref)
d878 4
d884 14
a897 1
	RETVAL = termios_ref->c_oflag;
d899 2
a900 28
     not_here("getoflag");
     RETVAL = 0;
#endif
    OUTPUT:
	RETVAL

tcflag_t
getcflag(termios_ref)
	POSIX::Termios	termios_ref
    CODE:
#ifdef I_TERMIOS /* References a termios structure member so ifdef it out. */
	RETVAL = termios_ref->c_cflag;
#else
     not_here("getcflag");
     RETVAL = 0;
#endif
    OUTPUT:
	RETVAL

tcflag_t
getlflag(termios_ref)
	POSIX::Termios	termios_ref
    CODE:
#ifdef I_TERMIOS /* References a termios structure member so ifdef it out. */
	RETVAL = termios_ref->c_lflag;
#else
     not_here("getlflag");
     RETVAL = 0;
d922 1
a922 1
cfsetispeed(termios_ref, speed)
d925 2
a926 10

SysRet
cfsetospeed(termios_ref, speed)
	POSIX::Termios	termios_ref
	speed_t		speed

void
setiflag(termios_ref, iflag)
	POSIX::Termios	termios_ref
	tcflag_t	iflag
d928 4
a931 5
#ifdef I_TERMIOS /* References a termios structure member so ifdef it out. */
	termios_ref->c_iflag = iflag;
#else
	    not_here("setiflag");
#endif
d934 1
a934 1
setoflag(termios_ref, oflag)
d936 5
a940 1
	tcflag_t	oflag
d943 14
a956 1
	termios_ref->c_oflag = oflag;
d958 1
a958 23
	    not_here("setoflag");
#endif

void
setcflag(termios_ref, cflag)
	POSIX::Termios	termios_ref
	tcflag_t	cflag
    CODE:
#ifdef I_TERMIOS /* References a termios structure member so ifdef it out. */
	termios_ref->c_cflag = cflag;
#else
	    not_here("setcflag");
#endif

void
setlflag(termios_ref, lflag)
	POSIX::Termios	termios_ref
	tcflag_t	lflag
    CODE:
#ifdef I_TERMIOS /* References a termios structure member so ifdef it out. */
	termios_ref->c_lflag = lflag;
#else
	    not_here("setlflag");
d1039 1
a1039 1
	    Perl_croak(aTHX_ "Illegal alias %d for POSIX::W*", ix);
a1043 154
int
isalnum(charstring)
	SV *	charstring
    PREINIT:
	STRLEN	len;
    CODE:
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
	for (RETVAL = 1; RETVAL && s < e; s++)
	    if (!isalnum(*s))
		RETVAL = 0;
    OUTPUT:
	RETVAL

int
isalpha(charstring)
	SV *	charstring
    PREINIT:
	STRLEN	len;
    CODE:
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
	for (RETVAL = 1; RETVAL && s < e; s++)
	    if (!isalpha(*s))
		RETVAL = 0;
    OUTPUT:
	RETVAL

int
iscntrl(charstring)
	SV *	charstring
    PREINIT:
	STRLEN	len;
    CODE:
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
	for (RETVAL = 1; RETVAL && s < e; s++)
	    if (!iscntrl(*s))
		RETVAL = 0;
    OUTPUT:
	RETVAL

int
isdigit(charstring)
	SV *	charstring
    PREINIT:
	STRLEN	len;
    CODE:
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
	for (RETVAL = 1; RETVAL && s < e; s++)
	    if (!isdigit(*s))
		RETVAL = 0;
    OUTPUT:
	RETVAL

int
isgraph(charstring)
	SV *	charstring
    PREINIT:
	STRLEN	len;
    CODE:
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
	for (RETVAL = 1; RETVAL && s < e; s++)
	    if (!isgraph(*s))
		RETVAL = 0;
    OUTPUT:
	RETVAL

int
islower(charstring)
	SV *	charstring
    PREINIT:
	STRLEN	len;
    CODE:
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
	for (RETVAL = 1; RETVAL && s < e; s++)
	    if (!islower(*s))
		RETVAL = 0;
    OUTPUT:
	RETVAL

int
isprint(charstring)
	SV *	charstring
    PREINIT:
	STRLEN	len;
    CODE:
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
	for (RETVAL = 1; RETVAL && s < e; s++)
	    if (!isprint(*s))
		RETVAL = 0;
    OUTPUT:
	RETVAL

int
ispunct(charstring)
	SV *	charstring
    PREINIT:
	STRLEN	len;
    CODE:
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
	for (RETVAL = 1; RETVAL && s < e; s++)
	    if (!ispunct(*s))
		RETVAL = 0;
    OUTPUT:
	RETVAL

int
isspace(charstring)
	SV *	charstring
    PREINIT:
	STRLEN	len;
    CODE:
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
	for (RETVAL = 1; RETVAL && s < e; s++)
	    if (!isspace(*s))
		RETVAL = 0;
    OUTPUT:
	RETVAL

int
isupper(charstring)
	SV *	charstring
    PREINIT:
	STRLEN	len;
    CODE:
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
	for (RETVAL = 1; RETVAL && s < e; s++)
	    if (!isupper(*s))
		RETVAL = 0;
    OUTPUT:
	RETVAL

int
isxdigit(charstring)
	SV *	charstring
    PREINIT:
	STRLEN	len;
    CODE:
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
	for (RETVAL = 1; RETVAL && s < e; s++)
	    if (!isxdigit(*s))
		RETVAL = 0;
    OUTPUT:
	RETVAL

d1065 19
a1083 62
	    /* the strings */
	    if (lcbuf->decimal_point && *lcbuf->decimal_point)
		hv_store(RETVAL, "decimal_point", 13,
		    newSVpv(lcbuf->decimal_point, 0), 0);
	    if (lcbuf->thousands_sep && *lcbuf->thousands_sep)
		hv_store(RETVAL, "thousands_sep", 13,
		    newSVpv(lcbuf->thousands_sep, 0), 0);
#ifndef NO_LOCALECONV_GROUPING
	    if (lcbuf->grouping && *lcbuf->grouping)
		hv_store(RETVAL, "grouping", 8,
		    newSVpv(lcbuf->grouping, 0), 0);
#endif
	    if (lcbuf->int_curr_symbol && *lcbuf->int_curr_symbol)
		hv_store(RETVAL, "int_curr_symbol", 15,
		    newSVpv(lcbuf->int_curr_symbol, 0), 0);
	    if (lcbuf->currency_symbol && *lcbuf->currency_symbol)
		hv_store(RETVAL, "currency_symbol", 15,
		    newSVpv(lcbuf->currency_symbol, 0), 0);
	    if (lcbuf->mon_decimal_point && *lcbuf->mon_decimal_point)
		hv_store(RETVAL, "mon_decimal_point", 17,
		    newSVpv(lcbuf->mon_decimal_point, 0), 0);
#ifndef NO_LOCALECONV_MON_THOUSANDS_SEP
	    if (lcbuf->mon_thousands_sep && *lcbuf->mon_thousands_sep)
		hv_store(RETVAL, "mon_thousands_sep", 17,
		    newSVpv(lcbuf->mon_thousands_sep, 0), 0);
#endif
#ifndef NO_LOCALECONV_MON_GROUPING
	    if (lcbuf->mon_grouping && *lcbuf->mon_grouping)
		hv_store(RETVAL, "mon_grouping", 12,
		    newSVpv(lcbuf->mon_grouping, 0), 0);
#endif
	    if (lcbuf->positive_sign && *lcbuf->positive_sign)
		hv_store(RETVAL, "positive_sign", 13,
		    newSVpv(lcbuf->positive_sign, 0), 0);
	    if (lcbuf->negative_sign && *lcbuf->negative_sign)
		hv_store(RETVAL, "negative_sign", 13,
		    newSVpv(lcbuf->negative_sign, 0), 0);
	    /* the integers */
	    if (lcbuf->int_frac_digits != CHAR_MAX)
		hv_store(RETVAL, "int_frac_digits", 15,
		    newSViv(lcbuf->int_frac_digits), 0);
	    if (lcbuf->frac_digits != CHAR_MAX)
		hv_store(RETVAL, "frac_digits", 11,
		    newSViv(lcbuf->frac_digits), 0);
	    if (lcbuf->p_cs_precedes != CHAR_MAX)
		hv_store(RETVAL, "p_cs_precedes", 13,
		    newSViv(lcbuf->p_cs_precedes), 0);
	    if (lcbuf->p_sep_by_space != CHAR_MAX)
		hv_store(RETVAL, "p_sep_by_space", 14,
		    newSViv(lcbuf->p_sep_by_space), 0);
	    if (lcbuf->n_cs_precedes != CHAR_MAX)
		hv_store(RETVAL, "n_cs_precedes", 13,
		    newSViv(lcbuf->n_cs_precedes), 0);
	    if (lcbuf->n_sep_by_space != CHAR_MAX)
		hv_store(RETVAL, "n_sep_by_space", 14,
		    newSViv(lcbuf->n_sep_by_space), 0);
	    if (lcbuf->p_sign_posn != CHAR_MAX)
		hv_store(RETVAL, "p_sign_posn", 11,
		    newSViv(lcbuf->p_sign_posn), 0);
	    if (lcbuf->n_sign_posn != CHAR_MAX)
		hv_store(RETVAL, "n_sign_posn", 11,
		    newSViv(lcbuf->n_sign_posn), 0);
d1166 44
a1209 20

NV
asin(x)
	NV		x

NV
atan(x)
	NV		x

NV
ceil(x)
	NV		x

NV
cosh(x)
	NV		x

NV
floor(x)
	NV		x
a1229 4
NV
log10(x)
	NV		x

a1238 12
NV
sinh(x)
	NV		x

NV
tan(x)
	NV		x

NV
tanh(x)
	NV		x

d1342 1
a1342 2
		    IV tmp = SvIV((SV*)SvRV(*svp));
		    sigset = INT2PTR(sigset_t*, tmp);
d1345 3
a1347 2
		    Newx(sigset, 1, sigset_t);
		    sv_setptrobj(*svp, sigset, "POSIX::SigSet");
d1385 1
a1385 1
		mg_set(*sigsvp);
d1401 1
a1401 2
		    IV tmp = SvIV((SV*)SvRV(*svp));
		    sigset = INT2PTR(sigset_t*, tmp);
d1432 8
d1450 1
a1450 2
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    sigset = INT2PTR(POSIX__SigSet,tmp);
d1458 1
a1458 2
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    oldsigset = INT2PTR(POSIX__SigSet,tmp);
a1462 4
SysRet
sigsuspend(signal_mask)
	POSIX::SigSet		signal_mask

a1467 8
close(fd)
	int		fd

SysRet
dup(fd)
	int		fd

SysRet
d1471 11
d1711 2
d1714 6
a1719 2
	TAINT_PROPER("mkfifo");
	RETVAL = mkfifo(filename, mode);
d1726 8
d1740 8
d1749 1
a1749 12

SysRet
tcflush(fd, queue_selector)
	int		fd
	int		queue_selector

SysRet
tcsendbreak(fd, duration)
	int		fd
	int		duration

char *
d1760 3
a1762 1
    CODE:
d1764 1
d1766 1
a1766 1
	    init_tm(&mytm);	/* XXX workaround - see init_tm() above */
d1776 13
a1788 1
	    RETVAL = asctime(&mytm);
a1789 2
    OUTPUT:
	RETVAL
a1815 29
SysRetLong
mktime(sec, min, hour, mday, mon, year, wday = 0, yday = 0, isdst = -1)
	int		sec
	int		min
	int		hour
	int		mday
	int		mon
	int		year
	int		wday
	int		yday
	int		isdst
    CODE:
	{
	    struct tm mytm;
	    init_tm(&mytm);	/* XXX workaround - see init_tm() above */
	    mytm.tm_sec = sec;
	    mytm.tm_min = min;
	    mytm.tm_hour = hour;
	    mytm.tm_mday = mday;
	    mytm.tm_mon = mon;
	    mytm.tm_year = year;
	    mytm.tm_wday = wday;
	    mytm.tm_yday = yday;
	    mytm.tm_isdst = isdst;
	    RETVAL = (SysRetLong) mktime(&mytm);
	}
    OUTPUT:
	RETVAL

a1855 5
SysRet
access(filename, mode)
	char *		filename
	Mode_t		mode

d1896 10
a1909 7
    CLEANUP:
#ifndef WIN32
	if (RETVAL >= 0) {
	    PL_gid  = getgid();
	    PL_egid = getegid();
	}
#endif
a1913 7
    CLEANUP:
#ifndef WIN32
	if (RETVAL >= 0) {
	    PL_uid  = getuid();
	    PL_euid = geteuid();
	}
#endif
@


1.14
log
@Merge in perl 5.10.1
@
text
@a72 3
#ifdef MACOS_TRADITIONAL
#undef fdopen
#endif
d196 1
a196 1
#    if defined(OS2) || defined(MACOS_TRADITIONAL)
d205 6
a210 12
#  ifdef MACOS_TRADITIONAL
#    define ttyname(a) (char*)not_here("ttyname")
#    define tzset() not_here("tzset")
#  else
#    ifdef I_GRP
#      include <grp.h>
#    endif
#    include <sys/times.h>
#    ifdef HAS_UNAME
#      include <sys/utsname.h>
#    endif
#    include <sys/wait.h>
d212 1
d219 123
d890 2
a891 2
#if !(defined(WEXITSTATUS) || defined(WIFEXITED) || defined(WIFSIGNALED) \
      || defined(WIFSTOPPED) || defined(WSTOPSIG) || defined (WTERMSIG))
d1343 1
a1343 1
	    GV *siggv = gv_fetchpv("SIG", TRUE, SVt_PVHV);
d1406 1
a1406 1
	    osset_sv = newSVpv((char *)(&osset), sizeof(sigset_t));
d1421 1
a1421 1
			sv_setpv(*svp, "DEFAULT");
d1424 2
a1425 1
		if(RETVAL == -1)
d1427 1
d1507 2
a1508 1
		if(RETVAL == -1)
d1510 1
d1587 1
a1587 1
		XPUSHs(sv_2mortal(newSVpvn("0 but true", 10)));
d1642 5
a1646 5
	    PUSHs(sv_2mortal(newSVpv(buf.sysname, 0)));
	    PUSHs(sv_2mortal(newSVpv(buf.nodename, 0)));
	    PUSHs(sv_2mortal(newSVpv(buf.release, 0)));
	    PUSHs(sv_2mortal(newSVpv(buf.version, 0)));
	    PUSHs(sv_2mortal(newSVpv(buf.machine, 0)));
d1911 1
a1911 1
	char *		fmt
d1923 1
a1923 1
	    char *buf = my_strftime(fmt, sec, min, hour, mday, mon, year, wday, yday, isdst);
d1925 6
a1930 2
		ST(0) = sv_2mortal(newSVpv(buf, 0));
		Safefree(buf);
d1943 2
a1944 2
	PUSHs(sv_2mortal(newSVpvn(tzname[0],strlen(tzname[0]))));
	PUSHs(sv_2mortal(newSVpvn(tzname[1],strlen(tzname[1]))));
@


1.13
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@a251 1
char *cuserid (char *);
a257 3
#ifndef HAS_CUSERID
#define cuserid(a) (char *) not_here("cuserid")
#endif
d378 11
a388 1
#ifdef __BEOS__
d395 1
a395 1
not_here(char *s)
a402 172
/* These were implemented in the old "constant" subroutine. They are actually
   macros that take an integer argument and return an integer result.  */
static int
int_macro_int (const char *name, STRLEN len, IV *arg_result) {
  /* Initially switch on the length of the name.  */
  /* This code has been edited from a "constant" function generated by:

use ExtUtils::Constant qw (constant_types C_constant XS_constant);

my $types = {map {($_, 1)} qw(IV)};
my @@names = (qw(S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG WEXITSTATUS WIFEXITED
	       WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG));

print constant_types(); # macro defs
foreach (C_constant ("POSIX", 'int_macro_int', 'IV', $types, undef, 5, @@names) ) {
    print $_, "\n"; # C constant subs
}
print "#### XS Section:\n";
print XS_constant ("POSIX", $types);
   */

  switch (len) {
  case 7:
    /* Names all of length 7.  */
    /* S_ISBLK S_ISCHR S_ISDIR S_ISREG */
    /* Offset 5 gives the best switch position.  */
    switch (name[5]) {
    case 'E':
      if (memEQ(name, "S_ISREG", 7)) {
      /*                    ^       */
#ifdef S_ISREG
        *arg_result = S_ISREG(*arg_result);
        return PERL_constant_ISIV;
#else
        return PERL_constant_NOTDEF;
#endif
      }
      break;
    case 'H':
      if (memEQ(name, "S_ISCHR", 7)) {
      /*                    ^       */
#ifdef S_ISCHR
        *arg_result = S_ISCHR(*arg_result);
        return PERL_constant_ISIV;
#else
        return PERL_constant_NOTDEF;
#endif
      }
      break;
    case 'I':
      if (memEQ(name, "S_ISDIR", 7)) {
      /*                    ^       */
#ifdef S_ISDIR
        *arg_result = S_ISDIR(*arg_result);
        return PERL_constant_ISIV;
#else
        return PERL_constant_NOTDEF;
#endif
      }
      break;
    case 'L':
      if (memEQ(name, "S_ISBLK", 7)) {
      /*                    ^       */
#ifdef S_ISBLK
        *arg_result = S_ISBLK(*arg_result);
        return PERL_constant_ISIV;
#else
        return PERL_constant_NOTDEF;
#endif
      }
      break;
    }
    break;
  case 8:
    /* Names all of length 8.  */
    /* S_ISFIFO WSTOPSIG WTERMSIG */
    /* Offset 3 gives the best switch position.  */
    switch (name[3]) {
    case 'O':
      if (memEQ(name, "WSTOPSIG", 8)) {
      /*                  ^          */
#ifdef WSTOPSIG
        int i = *arg_result;
        *arg_result = WSTOPSIG(WMUNGE(i));
        return PERL_constant_ISIV;
#else
        return PERL_constant_NOTDEF;
#endif
      }
      break;
    case 'R':
      if (memEQ(name, "WTERMSIG", 8)) {
      /*                  ^          */
#ifdef WTERMSIG
        int i = *arg_result;
        *arg_result = WTERMSIG(WMUNGE(i));
        return PERL_constant_ISIV;
#else
        return PERL_constant_NOTDEF;
#endif
      }
      break;
    case 'S':
      if (memEQ(name, "S_ISFIFO", 8)) {
      /*                  ^          */
#ifdef S_ISFIFO
        *arg_result = S_ISFIFO(*arg_result);
        return PERL_constant_ISIV;
#else
        return PERL_constant_NOTDEF;
#endif
      }
      break;
    }
    break;
  case 9:
    if (memEQ(name, "WIFEXITED", 9)) {
#ifdef WIFEXITED
      int i = *arg_result;
      *arg_result = WIFEXITED(WMUNGE(i));
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 10:
    if (memEQ(name, "WIFSTOPPED", 10)) {
#ifdef WIFSTOPPED
      int i = *arg_result;
      *arg_result = WIFSTOPPED(WMUNGE(i));
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 11:
    /* Names all of length 11.  */
    /* WEXITSTATUS WIFSIGNALED */
    /* Offset 1 gives the best switch position.  */
    switch (name[1]) {
    case 'E':
      if (memEQ(name, "WEXITSTATUS", 11)) {
      /*                ^                */
#ifdef WEXITSTATUS
	int i = *arg_result;
        *arg_result = WEXITSTATUS(WMUNGE(i));
        return PERL_constant_ISIV;
#else
        return PERL_constant_NOTDEF;
#endif
      }
      break;
    case 'I':
      if (memEQ(name, "WIFSIGNALED", 11)) {
      /*                ^                */
#ifdef WIFSIGNALED
	int i = *arg_result;
        *arg_result = WIFSIGNALED(WMUNGE(i));
        return PERL_constant_ISIV;
#else
        return PERL_constant_NOTDEF;
#endif
      }
      break;
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

d415 110
d529 1
a529 1
    char *		packname
d574 1
a574 1
    char *		packname
d765 63
a827 41
void
int_macro_int(sv, iv)
    PREINIT:
	dXSTARG;
	STRLEN		len;
        int		type;
    INPUT:
	SV *		sv;
        const char *	s = SvPV(sv, len);
	IV		iv;
    PPCODE:
        /* Change this to int_macro_int(s, len, &iv, &nv);
           if you need to return both NVs and IVs */
	type = int_macro_int(s, len, &iv);
      /* Return 1 or 2 items. First is error message, or undef if no error.
           Second, if present, is found value */
        switch (type) {
        case PERL_constant_NOTFOUND:
          sv = sv_2mortal(newSVpvf("%s is not a valid POSIX macro", s));
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
          break;
        case PERL_constant_NOTDEF:
          sv = sv_2mortal(newSVpvf(
	    "Your vendor has not defined POSIX macro %s, used", s));
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
          break;
        case PERL_constant_ISIV:
          PUSHi(iv);
          break;
        default:
          sv = sv_2mortal(newSVpvf(
	    "Unexpected return type %d while processing POSIX macro %s, used",
               type, s));
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
        }
d1631 1
a1631 1
	char *		str
d1813 2
d1846 9
@


1.12
log
@merge in perl 5.8.8
@
text
@d54 1
a54 1
/* XXX This comment is just to make I_TERMIO and I_SGTTY visible to 
d201 1
a201 1
#    else	/* !( defined OS2 ) */ 
d212 3
a214 1
#    include <grp.h>
d268 1
a268 1
#define fpathconf(f,n) 	(SysRetLong) not_here("fpathconf")
d277 1
a277 1
#define pathconf(f,n) 	(SysRetLong) not_here("pathconf")
d280 1
a280 1
#define sysconf(n) 	(SysRetLong) not_here("sysconf")
a625 1

d735 1
a735 1
	int		ccix
d805 1
a805 1
	int		ccix
d1063 1
a1063 1
#endif                    
d1111 2
d1114 5
a1118 2
	RETVAL = setlocale(category, locale);
	if (RETVAL) {
d1171 2
d1175 3
a1177 1

d1260 1
d1271 5
d1278 1
a1278 1
		int i = whichsig((char *)s);
d1281 1
a1281 1
		    i = whichsig((char *)s + 3);
d1291 7
d1333 1
a1333 1
		svp = hv_fetch(oldaction, "HANDLER", 7, TRUE);
d1346 1
a1346 1
		svp = hv_fetch(oldaction, "MASK", 4, TRUE);
d1358 1
a1358 1
		svp = hv_fetch(oldaction, "FLAGS", 5, TRUE);
d1362 1
a1362 1
		svp = hv_fetch(oldaction, "SAFE", 4, TRUE);
d1372 1
a1372 1
		svp = hv_fetch(action, "SAFE", 4, FALSE);
d1375 1
a1375 1
			    void (*)(),
d1382 1
a1382 1
		svp = hv_fetch(action, "HANDLER", 7, FALSE);
d1405 1
a1405 1
		svp = hv_fetch(action, "MASK", 4, FALSE);
d1415 1
a1415 1
		svp = hv_fetch(action, "FLAGS", 5, FALSE);
d1695 1
a1695 1
          ST(0) = sv_2mortal(NEWSV(800,srclen*4+1));
d1739 1
a1739 1
asctime(sec, min, hour, mday, mon, year, wday = 0, yday = 0, isdst = 0)
d1793 1
a1793 1
mktime(sec, min, hour, mday, mon, year, wday = 0, yday = 0, isdst = 0)
d1816 1
a1816 1
	    RETVAL = mktime(&mytm);
d1865 1
a1865 1
	s = safemalloc((size_t) L_ctermid);
@


1.11
log
@sync in-tree perl with 5.8.6
@
text
@d88 20
a413 1
__END__
d587 1
a587 1
	    New(0, RETVAL, 1, sigset_t);
d633 1
a633 1
	    New(0, RETVAL, 1, struct termios);
d1261 2
a1262 2
	        char *s = SvPVX(ST(0));
		int i = whichsig(s);
d1265 1
a1265 1
		    i = whichsig(s + 3);
d1329 1
a1329 1
		    New(0, sigset, 1, sigset_t);
d1340 3
a1342 1
		sv_setiv(*svp, oact.sa_handler == PL_csighandlerp);
d1350 6
a1355 2
		act.sa_handler = (*svp && SvTRUE(*svp))
				 ? PL_csighandlerp : PL_sighandlerp;
d1372 1
a1372 1
			char *s=SvPVX(*svp);
d1401 2
a1402 2
               if(RETVAL == -1)
                   XSRETURN_UNDEF;
d1504 1
a1504 1
            SvCUR(sv_buffer) = RETVAL;
d1680 1
a1680 1
          SvCUR(ST(0)) = dstlen;
@


1.10
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d1393 1
a1393 1
	POSIX::SigSet		sigset
d1396 7
a1402 2
	if ( items < 3 ) {
	    oldsigset = 0;
d1404 4
a1407 1
	else if (sv_derived_from(ST(2), "POSIX::SigSet")) {
d1410 2
a1411 5
	}
	else {
	    New(0, oldsigset, 1, sigset_t);
	    sigemptyset(oldsigset);
	    sv_setref_pv(ST(2), "POSIX::SigSet", (void*)oldsigset);
@


1.9
log
@merge local changes into perl-5.8.3
@
text
@d1016 1
d1809 12
a1820 1
	char *		s = 0;
d1878 15
@


1.8
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d845 3
a847 1
	unsigned char *	charstring
d849 2
a850 2
	unsigned char *s = charstring;
	unsigned char *e = s + SvCUR(ST(0));
d859 3
a861 1
	unsigned char *	charstring
d863 2
a864 2
	unsigned char *s = charstring;
	unsigned char *e = s + SvCUR(ST(0));
d873 3
a875 1
	unsigned char *	charstring
d877 2
a878 2
	unsigned char *s = charstring;
	unsigned char *e = s + SvCUR(ST(0));
d887 3
a889 1
	unsigned char *	charstring
d891 2
a892 2
	unsigned char *s = charstring;
	unsigned char *e = s + SvCUR(ST(0));
d901 3
a903 1
	unsigned char *	charstring
d905 2
a906 2
	unsigned char *s = charstring;
	unsigned char *e = s + SvCUR(ST(0));
d915 3
a917 1
	unsigned char *	charstring
d919 2
a920 2
	unsigned char *s = charstring;
	unsigned char *e = s + SvCUR(ST(0));
d929 3
a931 1
	unsigned char *	charstring
d933 2
a934 2
	unsigned char *s = charstring;
	unsigned char *e = s + SvCUR(ST(0));
d943 3
a945 1
	unsigned char *	charstring
d947 2
a948 2
	unsigned char *s = charstring;
	unsigned char *e = s + SvCUR(ST(0));
d957 3
a959 1
	unsigned char *	charstring
d961 2
a962 2
	unsigned char *s = charstring;
	unsigned char *e = s + SvCUR(ST(0));
d971 3
a973 1
	unsigned char *	charstring
d975 2
a976 2
	unsigned char *s = charstring;
	unsigned char *e = s + SvCUR(ST(0));
d985 3
a987 1
	unsigned char *	charstring
d989 2
a990 2
	unsigned char *s = charstring;
	unsigned char *e = s + SvCUR(ST(0));
d1830 7
d1841 7
@


1.7
log
@Pull in change 17805 by hv@@hv-crypt.org on 2002/08/29 13:49:04

Fix based on:
Subject: [perl #16799] Perl 5.8.0 breaks POSIX::isprint() (and other POSIX::xxx)
From: "esm@@pobox.com (via RT)" <perlbug@@perl.org>
Date: 27 Aug 2002 22:10:16 -0000
Message-Id: <rt-16799-35846.14.4842888832041@@bugs6.perl.org>
@
text
@d64 1
d66 1
d79 1
a79 1
#  if !defined(WIN32) && !defined(__CYGWIN__) && !defined(NETWARE)
d83 1
a83 1
#if !defined(WIN32) || (defined(__MINGW32__) && !defined(tzname))
d1217 20
a1236 4
	    SV** sigsvp = hv_fetch(GvHVn(siggv),
				 PL_sig_name[sig],
				 strlen(PL_sig_name[sig]),
				 TRUE);
d1295 4
d1302 9
a1310 2
		/* Vector new handler through %SIG.  (We always use sighandler
		   for the C signal handler, which reads %SIG to dispatch.) */
d1315 8
a1322 1
		mg_set(*sigsvp);	/* handles DEFAULT and IGNORE */
a1330 6
			else {
				act.sa_handler = PL_sighandlerp;
			}
		}
		else {
			act.sa_handler = PL_sighandlerp;
d1407 1
a1407 1
SysRetLong
d1412 6
d1419 1
a1419 1
SysRet
d1422 8
d1596 5
a1600 1
	if (num <= IV_MAX)
a1601 2
	else
	    PUSHs(sv_2mortal(newSVnv((double)num)));
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d846 1
a846 1
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
d858 1
a858 1
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
d870 1
a870 1
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
d882 1
a882 1
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
d894 1
a894 1
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
d906 1
a906 1
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
d918 1
a918 1
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
d930 1
a930 1
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
d942 1
a942 1
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
d954 1
a954 1
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
d966 1
a966 1
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
@


1.6.2.1
log
@MFC:
Fix by millert@@

Pull in change 17805 by hv@@hv-crypt.org on 2002/08/29 13:49:04

Fix based on:
Subject: [perl #16799] Perl 5.8.0 breaks POSIX::isprint() (and other POSIX::xxx)
From: "esm@@pobox.com (via RT)" <perlbug@@perl.org>
Date: 27 Aug 2002 22:10:16 -0000
Message-Id: <rt-16799-35846.14.4842888832041@@bugs6.perl.org>

ok deraadt@@ millert@@
@
text
@d846 1
a846 1
	unsigned char *e = s + SvCUR(ST(0));
d858 1
a858 1
	unsigned char *e = s + SvCUR(ST(0));
d870 1
a870 1
	unsigned char *e = s + SvCUR(ST(0));
d882 1
a882 1
	unsigned char *e = s + SvCUR(ST(0));
d894 1
a894 1
	unsigned char *e = s + SvCUR(ST(0));
d906 1
a906 1
	unsigned char *e = s + SvCUR(ST(0));
d918 1
a918 1
	unsigned char *e = s + SvCUR(ST(0));
d930 1
a930 1
	unsigned char *e = s + SvCUR(ST(0));
d942 1
a942 1
	unsigned char *e = s + SvCUR(ST(0));
d954 1
a954 1
	unsigned char *e = s + SvCUR(ST(0));
d966 1
a966 1
	unsigned char *e = s + SvCUR(ST(0));
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d1 12
a12 3
#ifdef WIN32
#define _POSIX_
#endif
d20 1
a20 1
#if defined(PERL_OBJECT) || defined(PERL_CAPI) || defined(PERL_IMPLICIT_SYS)
d50 4
d76 10
d138 1
a138 1
#if defined (WIN32)
d168 3
d173 1
d200 1
a200 1
#endif /* WIN32 */
d226 7
a232 2243

/* Possibly needed prototypes */
char *cuserid (char *);
double strtod (const char *, char **);
long strtol (const char *, char **, int);
unsigned long strtoul (const char *, char **, int);

#ifndef HAS_CUSERID
#define cuserid(a) (char *) not_here("cuserid")
#endif
#ifndef HAS_DIFFTIME
#ifndef difftime
#define difftime(a,b) not_here("difftime")
#endif
#endif
#ifndef HAS_FPATHCONF
#define fpathconf(f,n) 	(SysRetLong) not_here("fpathconf")
#endif
#ifndef HAS_MKTIME
#define mktime(a) not_here("mktime")
#endif
#ifndef HAS_NICE
#define nice(a) not_here("nice")
#endif
#ifndef HAS_PATHCONF
#define pathconf(f,n) 	(SysRetLong) not_here("pathconf")
#endif
#ifndef HAS_SYSCONF
#define sysconf(n) 	(SysRetLong) not_here("sysconf")
#endif
#ifndef HAS_READLINK
#define readlink(a,b,c) not_here("readlink")
#endif
#ifndef HAS_SETPGID
#define setpgid(a,b) not_here("setpgid")
#endif
#ifndef HAS_SETSID
#define setsid() not_here("setsid")
#endif
#ifndef HAS_STRCOLL
#define strcoll(s1,s2) not_here("strcoll")
#endif
#ifndef HAS_STRTOD
#define strtod(s1,s2) not_here("strtod")
#endif
#ifndef HAS_STRTOL
#define strtol(s1,s2,b) not_here("strtol")
#endif
#ifndef HAS_STRTOUL
#define strtoul(s1,s2,b) not_here("strtoul")
#endif
#ifndef HAS_STRXFRM
#define strxfrm(s1,s2,n) not_here("strxfrm")
#endif
#ifndef HAS_TCGETPGRP
#define tcgetpgrp(a) not_here("tcgetpgrp")
#endif
#ifndef HAS_TCSETPGRP
#define tcsetpgrp(a,b) not_here("tcsetpgrp")
#endif
#ifndef HAS_TIMES
#define times(a) not_here("times")
#endif
#ifndef HAS_UNAME
#define uname(a) not_here("uname")
#endif
#ifndef HAS_WAITPID
#define waitpid(a,b,c) not_here("waitpid")
#endif

#ifndef HAS_MBLEN
#ifndef mblen
#define mblen(a,b) not_here("mblen")
#endif
#endif
#ifndef HAS_MBSTOWCS
#define mbstowcs(s, pwcs, n) not_here("mbstowcs")
#endif
#ifndef HAS_MBTOWC
#define mbtowc(pwc, s, n) not_here("mbtowc")
#endif
#ifndef HAS_WCSTOMBS
#define wcstombs(s, pwcs, n) not_here("wcstombs")
#endif
#ifndef HAS_WCTOMB
#define wctomb(s, wchar) not_here("wcstombs")
#endif
#if !defined(HAS_MBLEN) && !defined(HAS_MBSTOWCS) && !defined(HAS_MBTOWC) && !defined(HAS_WCSTOMBS) && !defined(HAS_WCTOMB)
/* If we don't have these functions, then we wouldn't have gotten a typedef
   for wchar_t, the wide character type.  Defining wchar_t allows the
   functions referencing it to compile.  Its actual type is then meaningless,
   since without the above functions, all sections using it end up calling
   not_here() and croak.  --Kaveh Ghazi (ghazi@@noc.rutgers.edu) 9/18/94. */
#ifndef wchar_t
#define wchar_t char
#endif
#endif

#ifndef HAS_LOCALECONV
#define localeconv() not_here("localeconv")
#endif

#ifdef HAS_TZNAME
#  if !defined(WIN32) && !defined(__CYGWIN__)
extern char *tzname[];
#  endif
#else
#if !defined(WIN32) || (defined(__MINGW32__) && !defined(tzname))
char *tzname[] = { "" , "" };
#endif
#endif

/* XXX struct tm on some systems (SunOS4/BSD) contains extra (non POSIX)
 * fields for which we don't have Configure support yet:
 *   char *tm_zone;   -- abbreviation of timezone name
 *   long tm_gmtoff;  -- offset from GMT in seconds
 * To workaround core dumps from the uninitialised tm_zone we get the
 * system to give us a reasonable struct to copy.  This fix means that
 * strftime uses the tm_zone and tm_gmtoff values returned by
 * localtime(time()). That should give the desired result most of the
 * time. But probably not always!
 *
 * This is a temporary workaround to be removed once Configure
 * support is added and NETaa14816 is considered in full.
 * It does not address tzname aspects of NETaa14816.
 */
#ifdef HAS_GNULIBC
# ifndef STRUCT_TM_HASZONE
#    define STRUCT_TM_HASZONE
# endif
#endif

#ifdef STRUCT_TM_HASZONE
static void
init_tm(struct tm *ptm)		/* see mktime, strftime and asctime	*/
{
    Time_t now;
    (void)time(&now);
    Copy(localtime(&now), ptm, 1, struct tm);
}

#else
# define init_tm(ptm)
#endif

/*
 * mini_mktime - normalise struct tm values without the localtime()
 * semantics (and overhead) of mktime().
 */
static void
mini_mktime(struct tm *ptm)
{
    int yearday;
    int secs;
    int month, mday, year, jday;
    int odd_cent, odd_year;

#define	DAYS_PER_YEAR	365
#define	DAYS_PER_QYEAR	(4*DAYS_PER_YEAR+1)
#define	DAYS_PER_CENT	(25*DAYS_PER_QYEAR-1)
#define	DAYS_PER_QCENT	(4*DAYS_PER_CENT+1)
#define	SECS_PER_HOUR	(60*60)
#define	SECS_PER_DAY	(24*SECS_PER_HOUR)
/* parentheses deliberately absent on these two, otherwise they don't work */
#define	MONTH_TO_DAYS	153/5
#define	DAYS_TO_MONTH	5/153
/* offset to bias by March (month 4) 1st between month/mday & year finding */
#define	YEAR_ADJUST	(4*MONTH_TO_DAYS+1)
/* as used here, the algorithm leaves Sunday as day 1 unless we adjust it */
#define	WEEKDAY_BIAS	6	/* (1+6)%7 makes Sunday 0 again */

/*
 * Year/day algorithm notes:
 *
 * With a suitable offset for numeric value of the month, one can find
 * an offset into the year by considering months to have 30.6 (153/5) days,
 * using integer arithmetic (i.e., with truncation).  To avoid too much
 * messing about with leap days, we consider January and February to be
 * the 13th and 14th month of the previous year.  After that transformation,
 * we need the month index we use to be high by 1 from 'normal human' usage,
 * so the month index values we use run from 4 through 15.
 *
 * Given that, and the rules for the Gregorian calendar (leap years are those
 * divisible by 4 unless also divisible by 100, when they must be divisible
 * by 400 instead), we can simply calculate the number of days since some
 * arbitrary 'beginning of time' by futzing with the (adjusted) year number,
 * the days we derive from our month index, and adding in the day of the
 * month.  The value used here is not adjusted for the actual origin which
 * it normally would use (1 January A.D. 1), since we're not exposing it.
 * We're only building the value so we can turn around and get the
 * normalised values for the year, month, day-of-month, and day-of-year.
 *
 * For going backward, we need to bias the value we're using so that we find
 * the right year value.  (Basically, we don't want the contribution of
 * March 1st to the number to apply while deriving the year).  Having done
 * that, we 'count up' the contribution to the year number by accounting for
 * full quadracenturies (400-year periods) with their extra leap days, plus
 * the contribution from full centuries (to avoid counting in the lost leap
 * days), plus the contribution from full quad-years (to count in the normal
 * leap days), plus the leftover contribution from any non-leap years.
 * At this point, if we were working with an actual leap day, we'll have 0
 * days left over.  This is also true for March 1st, however.  So, we have
 * to special-case that result, and (earlier) keep track of the 'odd'
 * century and year contributions.  If we got 4 extra centuries in a qcent,
 * or 4 extra years in a qyear, then it's a leap day and we call it 29 Feb.
 * Otherwise, we add back in the earlier bias we removed (the 123 from
 * figuring in March 1st), find the month index (integer division by 30.6),
 * and the remainder is the day-of-month.  We then have to convert back to
 * 'real' months (including fixing January and February from being 14/15 in
 * the previous year to being in the proper year).  After that, to get
 * tm_yday, we work with the normalised year and get a new yearday value for
 * January 1st, which we subtract from the yearday value we had earlier,
 * representing the date we've re-built.  This is done from January 1
 * because tm_yday is 0-origin.
 *
 * Since POSIX time routines are only guaranteed to work for times since the
 * UNIX epoch (00:00:00 1 Jan 1970 UTC), the fact that this algorithm
 * applies Gregorian calendar rules even to dates before the 16th century
 * doesn't bother me.  Besides, you'd need cultural context for a given
 * date to know whether it was Julian or Gregorian calendar, and that's
 * outside the scope for this routine.  Since we convert back based on the
 * same rules we used to build the yearday, you'll only get strange results
 * for input which needed normalising, or for the 'odd' century years which
 * were leap years in the Julian calander but not in the Gregorian one.
 * I can live with that.
 *
 * This algorithm also fails to handle years before A.D. 1 gracefully, but
 * that's still outside the scope for POSIX time manipulation, so I don't
 * care.
 */

    year = 1900 + ptm->tm_year;
    month = ptm->tm_mon;
    mday = ptm->tm_mday;
    /* allow given yday with no month & mday to dominate the result */
    if (ptm->tm_yday >= 0 && mday <= 0 && month <= 0) {
	month = 0;
	mday = 0;
	jday = 1 + ptm->tm_yday;
    }
    else {
	jday = 0;
    }
    if (month >= 2)
	month+=2;
    else
	month+=14, year--;
    yearday = DAYS_PER_YEAR * year + year/4 - year/100 + year/400;
    yearday += month*MONTH_TO_DAYS + mday + jday;
    /*
     * Note that we don't know when leap-seconds were or will be,
     * so we have to trust the user if we get something which looks
     * like a sensible leap-second.  Wild values for seconds will
     * be rationalised, however.
     */
    if ((unsigned) ptm->tm_sec <= 60) {
	secs = 0;
    }
    else {
	secs = ptm->tm_sec;
	ptm->tm_sec = 0;
    }
    secs += 60 * ptm->tm_min;
    secs += SECS_PER_HOUR * ptm->tm_hour;
    if (secs < 0) {
	if (secs-(secs/SECS_PER_DAY*SECS_PER_DAY) < 0) {
	    /* got negative remainder, but need positive time */
	    /* back off an extra day to compensate */
	    yearday += (secs/SECS_PER_DAY)-1;
	    secs -= SECS_PER_DAY * (secs/SECS_PER_DAY - 1);
	}
	else {
	    yearday += (secs/SECS_PER_DAY);
	    secs -= SECS_PER_DAY * (secs/SECS_PER_DAY);
	}
    }
    else if (secs >= SECS_PER_DAY) {
	yearday += (secs/SECS_PER_DAY);
	secs %= SECS_PER_DAY;
    }
    ptm->tm_hour = secs/SECS_PER_HOUR;
    secs %= SECS_PER_HOUR;
    ptm->tm_min = secs/60;
    secs %= 60;
    ptm->tm_sec += secs;
    /* done with time of day effects */
    /*
     * The algorithm for yearday has (so far) left it high by 428.
     * To avoid mistaking a legitimate Feb 29 as Mar 1, we need to
     * bias it by 123 while trying to figure out what year it
     * really represents.  Even with this tweak, the reverse
     * translation fails for years before A.D. 0001.
     * It would still fail for Feb 29, but we catch that one below.
     */
    jday = yearday;	/* save for later fixup vis-a-vis Jan 1 */
    yearday -= YEAR_ADJUST;
    year = (yearday / DAYS_PER_QCENT) * 400;
    yearday %= DAYS_PER_QCENT;
    odd_cent = yearday / DAYS_PER_CENT;
    year += odd_cent * 100;
    yearday %= DAYS_PER_CENT;
    year += (yearday / DAYS_PER_QYEAR) * 4;
    yearday %= DAYS_PER_QYEAR;
    odd_year = yearday / DAYS_PER_YEAR;
    year += odd_year;
    yearday %= DAYS_PER_YEAR;
    if (!yearday && (odd_cent==4 || odd_year==4)) { /* catch Feb 29 */
	month = 1;
	yearday = 29;
    }
    else {
	yearday += YEAR_ADJUST;	/* recover March 1st crock */
	month = yearday*DAYS_TO_MONTH;
	yearday -= month*MONTH_TO_DAYS;
	/* recover other leap-year adjustment */
	if (month > 13) {
	    month-=14;
	    year++;
	}
	else {
	    month-=2;
	}
    }
    ptm->tm_year = year - 1900;
    if (yearday) {
      ptm->tm_mday = yearday;
      ptm->tm_mon = month;
    }
    else {
      ptm->tm_mday = 31;
      ptm->tm_mon = month - 1;
    }
    /* re-build yearday based on Jan 1 to get tm_yday */
    year--;
    yearday = year*DAYS_PER_YEAR + year/4 - year/100 + year/400;
    yearday += 14*MONTH_TO_DAYS + 1;
    ptm->tm_yday = jday - yearday;
    /* fix tm_wday if not overridden by caller */
    if ((unsigned)ptm->tm_wday > 6)
	ptm->tm_wday = (jday + WEEKDAY_BIAS) % 7;
}

#ifdef HAS_LONG_DOUBLE
#  if LONG_DOUBLESIZE > NVSIZE
#    undef HAS_LONG_DOUBLE  /* XXX until we figure out how to use them */
#  endif
#endif

#ifndef HAS_LONG_DOUBLE
#ifdef LDBL_MAX
#undef LDBL_MAX
#endif
#ifdef LDBL_MIN
#undef LDBL_MIN
#endif
#ifdef LDBL_EPSILON
#undef LDBL_EPSILON
#endif
#endif

static int
not_here(char *s)
{
    croak("POSIX::%s not implemented on this architecture", s);
    return -1;
}

static
NV
constant(char *name, int arg)
{
    errno = 0;
    switch (*name) {
    case 'A':
	if (strEQ(name, "ARG_MAX"))
#ifdef ARG_MAX
	    return ARG_MAX;
#else
	    goto not_there;
#endif
	break;
    case 'B':
	if (strEQ(name, "BUFSIZ"))
#ifdef BUFSIZ
	    return BUFSIZ;
#else
	    goto not_there;
#endif
	if (strEQ(name, "BRKINT"))
#ifdef BRKINT
	    return BRKINT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "B9600"))
#ifdef B9600
	    return B9600;
#else
	    goto not_there;
#endif
	if (strEQ(name, "B19200"))
#ifdef B19200
	    return B19200;
#else
	    goto not_there;
#endif
	if (strEQ(name, "B38400"))
#ifdef B38400
	    return B38400;
#else
	    goto not_there;
#endif
	if (strEQ(name, "B0"))
#ifdef B0
	    return B0;
#else
	    goto not_there;
#endif
	if (strEQ(name, "B110"))
#ifdef B110
	    return B110;
#else
	    goto not_there;
#endif
	if (strEQ(name, "B1200"))
#ifdef B1200
	    return B1200;
#else
	    goto not_there;
#endif
	if (strEQ(name, "B134"))
#ifdef B134
	    return B134;
#else
	    goto not_there;
#endif
	if (strEQ(name, "B150"))
#ifdef B150
	    return B150;
#else
	    goto not_there;
#endif
	if (strEQ(name, "B1800"))
#ifdef B1800
	    return B1800;
#else
	    goto not_there;
#endif
	if (strEQ(name, "B200"))
#ifdef B200
	    return B200;
#else
	    goto not_there;
#endif
	if (strEQ(name, "B2400"))
#ifdef B2400
	    return B2400;
#else
	    goto not_there;
#endif
	if (strEQ(name, "B300"))
#ifdef B300
	    return B300;
#else
	    goto not_there;
#endif
	if (strEQ(name, "B4800"))
#ifdef B4800
	    return B4800;
#else
	    goto not_there;
#endif
	if (strEQ(name, "B50"))
#ifdef B50
	    return B50;
#else
	    goto not_there;
#endif
	if (strEQ(name, "B600"))
#ifdef B600
	    return B600;
#else
	    goto not_there;
#endif
	if (strEQ(name, "B75"))
#ifdef B75
	    return B75;
#else
	    goto not_there;
#endif
	break;
    case 'C':
	if (strEQ(name, "CHAR_BIT"))
#ifdef CHAR_BIT
	    return CHAR_BIT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CHAR_MAX"))
#ifdef CHAR_MAX
	    return CHAR_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CHAR_MIN"))
#ifdef CHAR_MIN
	    return CHAR_MIN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CHILD_MAX"))
#ifdef CHILD_MAX
	    return CHILD_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CLK_TCK"))
#ifdef CLK_TCK
	    return CLK_TCK;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CLOCAL"))
#ifdef CLOCAL
	    return CLOCAL;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CLOCKS_PER_SEC"))
#ifdef CLOCKS_PER_SEC
	    return CLOCKS_PER_SEC;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CREAD"))
#ifdef CREAD
	    return CREAD;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CS5"))
#ifdef CS5
	    return CS5;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CS6"))
#ifdef CS6
	    return CS6;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CS7"))
#ifdef CS7
	    return CS7;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CS8"))
#ifdef CS8
	    return CS8;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CSIZE"))
#ifdef CSIZE
	    return CSIZE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CSTOPB"))
#ifdef CSTOPB
	    return CSTOPB;
#else
	    goto not_there;
#endif
	break;
    case 'D':
	if (strEQ(name, "DBL_MAX"))
#ifdef DBL_MAX
	    return DBL_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "DBL_MIN"))
#ifdef DBL_MIN
	    return DBL_MIN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "DBL_DIG"))
#ifdef DBL_DIG
	    return DBL_DIG;
#else
	    goto not_there;
#endif
	if (strEQ(name, "DBL_EPSILON"))
#ifdef DBL_EPSILON
	    return DBL_EPSILON;
#else
	    goto not_there;
#endif
	if (strEQ(name, "DBL_MANT_DIG"))
#ifdef DBL_MANT_DIG
	    return DBL_MANT_DIG;
#else
	    goto not_there;
#endif
	if (strEQ(name, "DBL_MAX_10_EXP"))
#ifdef DBL_MAX_10_EXP
	    return DBL_MAX_10_EXP;
#else
	    goto not_there;
#endif
	if (strEQ(name, "DBL_MAX_EXP"))
#ifdef DBL_MAX_EXP
	    return DBL_MAX_EXP;
#else
	    goto not_there;
#endif
	if (strEQ(name, "DBL_MIN_10_EXP"))
#ifdef DBL_MIN_10_EXP
	    return DBL_MIN_10_EXP;
#else
	    goto not_there;
#endif
	if (strEQ(name, "DBL_MIN_EXP"))
#ifdef DBL_MIN_EXP
	    return DBL_MIN_EXP;
#else
	    goto not_there;
#endif
	break;
    case 'E':
	switch (name[1]) {
	case 'A':
	    if (strEQ(name, "EACCES"))
#ifdef EACCES
		return EACCES;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EADDRINUSE"))
#ifdef EADDRINUSE
		return EADDRINUSE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EADDRNOTAVAIL"))
#ifdef EADDRNOTAVAIL
		return EADDRNOTAVAIL;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EAFNOSUPPORT"))
#ifdef EAFNOSUPPORT
		return EAFNOSUPPORT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EAGAIN"))
#ifdef EAGAIN
		return EAGAIN;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EALREADY"))
#ifdef EALREADY
		return EALREADY;
#else
		goto not_there;
#endif
	    break;
	case 'B':
	    if (strEQ(name, "EBADF"))
#ifdef EBADF
		return EBADF;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EBUSY"))
#ifdef EBUSY
		return EBUSY;
#else
		goto not_there;
#endif
	    break;
	case 'C':
	    if (strEQ(name, "ECHILD"))
#ifdef ECHILD
		return ECHILD;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ECHO"))
#ifdef ECHO
		return ECHO;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ECHOE"))
#ifdef ECHOE
		return ECHOE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ECHOK"))
#ifdef ECHOK
		return ECHOK;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ECHONL"))
#ifdef ECHONL
		return ECHONL;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ECONNABORTED"))
#ifdef ECONNABORTED
		return ECONNABORTED;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ECONNREFUSED"))
#ifdef ECONNREFUSED
		return ECONNREFUSED;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ECONNRESET"))
#ifdef ECONNRESET
		return ECONNRESET;
#else
		goto not_there;
#endif
	    break;
	case 'D':
	    if (strEQ(name, "EDEADLK"))
#ifdef EDEADLK
		return EDEADLK;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EDESTADDRREQ"))
#ifdef EDESTADDRREQ
		return EDESTADDRREQ;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EDOM"))
#ifdef EDOM
		return EDOM;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EDQUOT"))
#ifdef EDQUOT
		return EDQUOT;
#else
		goto not_there;
#endif
	    break;
	case 'E':
	    if (strEQ(name, "EEXIST"))
#ifdef EEXIST
		return EEXIST;
#else
		goto not_there;
#endif
	    break;
	case 'F':
	    if (strEQ(name, "EFAULT"))
#ifdef EFAULT
		return EFAULT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EFBIG"))
#ifdef EFBIG
		return EFBIG;
#else
		goto not_there;
#endif
	    break;
	case 'H':
	    if (strEQ(name, "EHOSTDOWN"))
#ifdef EHOSTDOWN
		return EHOSTDOWN;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EHOSTUNREACH"))
#ifdef EHOSTUNREACH
		return EHOSTUNREACH;
#else
		goto not_there;
#endif
    	    break;
	case 'I':
	    if (strEQ(name, "EINPROGRESS"))
#ifdef EINPROGRESS
		return EINPROGRESS;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EINTR"))
#ifdef EINTR
		return EINTR;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EINVAL"))
#ifdef EINVAL
		return EINVAL;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EIO"))
#ifdef EIO
		return EIO;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EISCONN"))
#ifdef EISCONN
		return EISCONN;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EISDIR"))
#ifdef EISDIR
		return EISDIR;
#else
		goto not_there;
#endif
	    break;
	case 'L':
	    if (strEQ(name, "ELOOP"))
#ifdef ELOOP
		return ELOOP;
#else
		goto not_there;
#endif
	    break;
	case 'M':
	    if (strEQ(name, "EMFILE"))
#ifdef EMFILE
		return EMFILE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EMLINK"))
#ifdef EMLINK
		return EMLINK;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EMSGSIZE"))
#ifdef EMSGSIZE
		return EMSGSIZE;
#else
		goto not_there;
#endif
	    break;
	case 'N':
	    if (strEQ(name, "ENETDOWN"))
#ifdef ENETDOWN
		return ENETDOWN;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENETRESET"))
#ifdef ENETRESET
		return ENETRESET;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENETUNREACH"))
#ifdef ENETUNREACH
		return ENETUNREACH;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOBUFS"))
#ifdef ENOBUFS
		return ENOBUFS;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOEXEC"))
#ifdef ENOEXEC
		return ENOEXEC;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOMEM"))
#ifdef ENOMEM
		return ENOMEM;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOPROTOOPT"))
#ifdef ENOPROTOOPT
		return ENOPROTOOPT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOSPC"))
#ifdef ENOSPC
		return ENOSPC;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOTBLK"))
#ifdef ENOTBLK
		return ENOTBLK;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOTCONN"))
#ifdef ENOTCONN
		return ENOTCONN;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOTDIR"))
#ifdef ENOTDIR
		return ENOTDIR;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOTEMPTY"))
#ifdef ENOTEMPTY
		return ENOTEMPTY;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOTSOCK"))
#ifdef ENOTSOCK
		return ENOTSOCK;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOTTY"))
#ifdef ENOTTY
		return ENOTTY;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENFILE"))
#ifdef ENFILE
		return ENFILE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENODEV"))
#ifdef ENODEV
		return ENODEV;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOENT"))
#ifdef ENOENT
		return ENOENT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOLCK"))
#ifdef ENOLCK
		return ENOLCK;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOSYS"))
#ifdef ENOSYS
		return ENOSYS;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENXIO"))
#ifdef ENXIO
		return ENXIO;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENAMETOOLONG"))
#ifdef ENAMETOOLONG
		return ENAMETOOLONG;
#else
		goto not_there;
#endif
	    break;
	case 'O':
	    if (strEQ(name, "EOF"))
#ifdef EOF
		return EOF;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EOPNOTSUPP"))
#ifdef EOPNOTSUPP
		return EOPNOTSUPP;
#else
		goto not_there;
#endif
	    break;
	case 'P':
	    if (strEQ(name, "EPERM"))
#ifdef EPERM
		return EPERM;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EPFNOSUPPORT"))
#ifdef EPFNOSUPPORT
		return EPFNOSUPPORT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EPIPE"))
#ifdef EPIPE
		return EPIPE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EPROCLIM"))
#ifdef EPROCLIM
		return EPROCLIM;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EPROTONOSUPPORT"))
#ifdef EPROTONOSUPPORT
		return EPROTONOSUPPORT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EPROTOTYPE"))
#ifdef EPROTOTYPE
		return EPROTOTYPE;
#else
		goto not_there;
#endif
	    break;
	case 'R':
	    if (strEQ(name, "ERANGE"))
#ifdef ERANGE
		return ERANGE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EREMOTE"))
#ifdef EREMOTE
		return EREMOTE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ERESTART"))
#ifdef ERESTART
		return ERESTART;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EROFS"))
#ifdef EROFS
		return EROFS;
#else
		goto not_there;
#endif
	    break;
	case 'S':
	    if (strEQ(name, "ESHUTDOWN"))
#ifdef ESHUTDOWN
		return ESHUTDOWN;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ESOCKTNOSUPPORT"))
#ifdef ESOCKTNOSUPPORT
		return ESOCKTNOSUPPORT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ESPIPE"))
#ifdef ESPIPE
		return ESPIPE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ESRCH"))
#ifdef ESRCH
		return ESRCH;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ESTALE"))
#ifdef ESTALE
		return ESTALE;
#else
		goto not_there;
#endif
	    break;
	case 'T':
	    if (strEQ(name, "ETIMEDOUT"))
#ifdef ETIMEDOUT
		return ETIMEDOUT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ETOOMANYREFS"))
#ifdef ETOOMANYREFS
		return ETOOMANYREFS;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ETXTBSY"))
#ifdef ETXTBSY
		return ETXTBSY;
#else
		goto not_there;
#endif
    	    break;
	case 'U':
	    if (strEQ(name, "EUSERS"))
#ifdef EUSERS
		return EUSERS;
#else
		goto not_there;
#endif
    	    break;
    	case 'W':
	    if (strEQ(name, "EWOULDBLOCK"))
#ifdef EWOULDBLOCK
		return EWOULDBLOCK;
#else
		goto not_there;
#endif
    	    break;
	case 'X':
	    if (strEQ(name, "EXIT_FAILURE"))
#ifdef EXIT_FAILURE
		return EXIT_FAILURE;
#else
		return 1;
#endif
	    if (strEQ(name, "EXIT_SUCCESS"))
#ifdef EXIT_SUCCESS
		return EXIT_SUCCESS;
#else
		return 0;
#endif
	    if (strEQ(name, "EXDEV"))
#ifdef EXDEV
		return EXDEV;
#else
		goto not_there;
#endif
	    break;
	}
	if (strEQ(name, "E2BIG"))
#ifdef E2BIG
	    return E2BIG;
#else
	    goto not_there;
#endif
	break;
    case 'F':
	if (strnEQ(name, "FLT_", 4)) {
	    if (strEQ(name, "FLT_MAX"))
#ifdef FLT_MAX
		return FLT_MAX;
#else
		goto not_there;
#endif
	    if (strEQ(name, "FLT_MIN"))
#ifdef FLT_MIN
		return FLT_MIN;
#else
		goto not_there;
#endif
	    if (strEQ(name, "FLT_ROUNDS"))
#ifdef FLT_ROUNDS
		return FLT_ROUNDS;
#else
		goto not_there;
#endif
	    if (strEQ(name, "FLT_DIG"))
#ifdef FLT_DIG
		return FLT_DIG;
#else
		goto not_there;
#endif
	    if (strEQ(name, "FLT_EPSILON"))
#ifdef FLT_EPSILON
		return FLT_EPSILON;
#else
		goto not_there;
#endif
	    if (strEQ(name, "FLT_MANT_DIG"))
#ifdef FLT_MANT_DIG
		return FLT_MANT_DIG;
#else
		goto not_there;
#endif
	    if (strEQ(name, "FLT_MAX_10_EXP"))
#ifdef FLT_MAX_10_EXP
		return FLT_MAX_10_EXP;
#else
		goto not_there;
#endif
	    if (strEQ(name, "FLT_MAX_EXP"))
#ifdef FLT_MAX_EXP
		return FLT_MAX_EXP;
#else
		goto not_there;
#endif
	    if (strEQ(name, "FLT_MIN_10_EXP"))
#ifdef FLT_MIN_10_EXP
		return FLT_MIN_10_EXP;
#else
		goto not_there;
#endif
	    if (strEQ(name, "FLT_MIN_EXP"))
#ifdef FLT_MIN_EXP
		return FLT_MIN_EXP;
#else
		goto not_there;
#endif
	    if (strEQ(name, "FLT_RADIX"))
#ifdef FLT_RADIX
		return FLT_RADIX;
#else
		goto not_there;
#endif
	    break;
	}
	if (strnEQ(name, "F_", 2)) {
	    if (strEQ(name, "F_DUPFD"))
#ifdef F_DUPFD
		return F_DUPFD;
#else
		goto not_there;
#endif
	    if (strEQ(name, "F_GETFD"))
#ifdef F_GETFD
		return F_GETFD;
#else
		goto not_there;
#endif
	    if (strEQ(name, "F_GETFL"))
#ifdef F_GETFL
		return F_GETFL;
#else
		goto not_there;
#endif
	    if (strEQ(name, "F_GETLK"))
#ifdef F_GETLK
		return F_GETLK;
#else
		goto not_there;
#endif
	    if (strEQ(name, "F_OK"))
#ifdef F_OK
		return F_OK;
#else
		goto not_there;
#endif
	    if (strEQ(name, "F_RDLCK"))
#ifdef F_RDLCK
		return F_RDLCK;
#else
		goto not_there;
#endif
	    if (strEQ(name, "F_SETFD"))
#ifdef F_SETFD
		return F_SETFD;
#else
		goto not_there;
#endif
	    if (strEQ(name, "F_SETFL"))
#ifdef F_SETFL
		return F_SETFL;
#else
		goto not_there;
#endif
	    if (strEQ(name, "F_SETLK"))
#ifdef F_SETLK
		return F_SETLK;
#else
		goto not_there;
#endif
	    if (strEQ(name, "F_SETLKW"))
#ifdef F_SETLKW
		return F_SETLKW;
#else
		goto not_there;
#endif
	    if (strEQ(name, "F_UNLCK"))
#ifdef F_UNLCK
		return F_UNLCK;
#else
		goto not_there;
#endif
	    if (strEQ(name, "F_WRLCK"))
#ifdef F_WRLCK
		return F_WRLCK;
#else
		goto not_there;
#endif
	    break;
	}
	if (strEQ(name, "FD_CLOEXEC"))
#ifdef FD_CLOEXEC
	    return FD_CLOEXEC;
#else
	    goto not_there;
#endif
	if (strEQ(name, "FILENAME_MAX"))
#ifdef FILENAME_MAX
	    return FILENAME_MAX;
#else
	    goto not_there;
#endif
	break;
    case 'H':
	if (strEQ(name, "HUGE_VAL"))
#if defined(USE_LONG_DOUBLE) && defined(HUGE_VALL)
	  /* HUGE_VALL is admittedly non-POSIX but if we are using long doubles
	   * we might as well use long doubles. --jhi */
	    return HUGE_VALL;
#endif
#ifdef HUGE_VAL
	    return HUGE_VAL;
#else
	    goto not_there;
#endif
	if (strEQ(name, "HUPCL"))
#ifdef HUPCL
	    return HUPCL;
#else
	    goto not_there;
#endif
	break;
    case 'I':
	if (strEQ(name, "INT_MAX"))
#ifdef INT_MAX
	    return INT_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "INT_MIN"))
#ifdef INT_MIN
	    return INT_MIN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "ICANON"))
#ifdef ICANON
	    return ICANON;
#else
	    goto not_there;
#endif
	if (strEQ(name, "ICRNL"))
#ifdef ICRNL
	    return ICRNL;
#else
	    goto not_there;
#endif
	if (strEQ(name, "IEXTEN"))
#ifdef IEXTEN
	    return IEXTEN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "IGNBRK"))
#ifdef IGNBRK
	    return IGNBRK;
#else
	    goto not_there;
#endif
	if (strEQ(name, "IGNCR"))
#ifdef IGNCR
	    return IGNCR;
#else
	    goto not_there;
#endif
	if (strEQ(name, "IGNPAR"))
#ifdef IGNPAR
	    return IGNPAR;
#else
	    goto not_there;
#endif
	if (strEQ(name, "INLCR"))
#ifdef INLCR
	    return INLCR;
#else
	    goto not_there;
#endif
	if (strEQ(name, "INPCK"))
#ifdef INPCK
	    return INPCK;
#else
	    goto not_there;
#endif
	if (strEQ(name, "ISIG"))
#ifdef ISIG
	    return ISIG;
#else
	    goto not_there;
#endif
	if (strEQ(name, "ISTRIP"))
#ifdef ISTRIP
	    return ISTRIP;
#else
	    goto not_there;
#endif
	if (strEQ(name, "IXOFF"))
#ifdef IXOFF
	    return IXOFF;
#else
	    goto not_there;
#endif
	if (strEQ(name, "IXON"))
#ifdef IXON
	    return IXON;
#else
	    goto not_there;
#endif
	break;
    case 'L':
	if (strnEQ(name, "LC_", 3)) {
	    if (strEQ(name, "LC_ALL"))
#ifdef LC_ALL
		return LC_ALL;
#else
		goto not_there;
#endif
	    if (strEQ(name, "LC_COLLATE"))
#ifdef LC_COLLATE
		return LC_COLLATE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "LC_CTYPE"))
#ifdef LC_CTYPE
		return LC_CTYPE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "LC_MONETARY"))
#ifdef LC_MONETARY
		return LC_MONETARY;
#else
		goto not_there;
#endif
	    if (strEQ(name, "LC_NUMERIC"))
#ifdef LC_NUMERIC
		return LC_NUMERIC;
#else
		goto not_there;
#endif
	    if (strEQ(name, "LC_TIME"))
#ifdef LC_TIME
		return LC_TIME;
#else
		goto not_there;
#endif
	    break;
	}
	if (strnEQ(name, "LDBL_", 5)) {
	    if (strEQ(name, "LDBL_MAX"))
#ifdef LDBL_MAX
		return LDBL_MAX;
#else
		goto not_there;
#endif
	    if (strEQ(name, "LDBL_MIN"))
#ifdef LDBL_MIN
		return LDBL_MIN;
#else
		goto not_there;
#endif
	    if (strEQ(name, "LDBL_DIG"))
#ifdef LDBL_DIG
		return LDBL_DIG;
#else
		goto not_there;
#endif
	    if (strEQ(name, "LDBL_EPSILON"))
#ifdef LDBL_EPSILON
		return LDBL_EPSILON;
#else
		goto not_there;
#endif
	    if (strEQ(name, "LDBL_MANT_DIG"))
#ifdef LDBL_MANT_DIG
		return LDBL_MANT_DIG;
#else
		goto not_there;
#endif
	    if (strEQ(name, "LDBL_MAX_10_EXP"))
#ifdef LDBL_MAX_10_EXP
		return LDBL_MAX_10_EXP;
#else
		goto not_there;
#endif
	    if (strEQ(name, "LDBL_MAX_EXP"))
#ifdef LDBL_MAX_EXP
		return LDBL_MAX_EXP;
#else
		goto not_there;
#endif
	    if (strEQ(name, "LDBL_MIN_10_EXP"))
#ifdef LDBL_MIN_10_EXP
		return LDBL_MIN_10_EXP;
#else
		goto not_there;
#endif
	    if (strEQ(name, "LDBL_MIN_EXP"))
#ifdef LDBL_MIN_EXP
		return LDBL_MIN_EXP;
#else
		goto not_there;
#endif
	    break;
	}
	if (strnEQ(name, "L_", 2)) {
	    if (strEQ(name, "L_ctermid"))
#ifdef L_ctermid
		return L_ctermid;
#else
		goto not_there;
#endif
	    if (strEQ(name, "L_cuserid"))
#ifdef L_cuserid
		return L_cuserid;
#else
		goto not_there;
#endif
	    /* L_tmpnam[e] was a typo--retained for compatibility */
	    if (strEQ(name, "L_tmpname") || strEQ(name, "L_tmpnam"))
#ifdef L_tmpnam
		return L_tmpnam;
#else
		goto not_there;
#endif
	    break;
	}
	if (strEQ(name, "LONG_MAX"))
#ifdef LONG_MAX
	    return LONG_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "LONG_MIN"))
#ifdef LONG_MIN
	    return LONG_MIN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "LINK_MAX"))
#ifdef LINK_MAX
	    return LINK_MAX;
#else
	    goto not_there;
#endif
	break;
    case 'M':
	if (strEQ(name, "MAX_CANON"))
#ifdef MAX_CANON
	    return MAX_CANON;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MAX_INPUT"))
#ifdef MAX_INPUT
	    return MAX_INPUT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MB_CUR_MAX"))
#ifdef MB_CUR_MAX
	    return MB_CUR_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MB_LEN_MAX"))
#ifdef MB_LEN_MAX
	    return MB_LEN_MAX;
#else
	    goto not_there;
#endif
	break;
    case 'N':
	if (strEQ(name, "NULL")) return 0;
	if (strEQ(name, "NAME_MAX"))
#ifdef NAME_MAX
	    return NAME_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "NCCS"))
#ifdef NCCS
	    return NCCS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "NGROUPS_MAX"))
#ifdef NGROUPS_MAX
	    return NGROUPS_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "NOFLSH"))
#ifdef NOFLSH
	    return NOFLSH;
#else
	    goto not_there;
#endif
	break;
    case 'O':
	if (strnEQ(name, "O_", 2)) {
	    if (strEQ(name, "O_APPEND"))
#ifdef O_APPEND
		return O_APPEND;
#else
		goto not_there;
#endif
	    if (strEQ(name, "O_CREAT"))
#ifdef O_CREAT
		return O_CREAT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "O_TRUNC"))
#ifdef O_TRUNC
		return O_TRUNC;
#else
		goto not_there;
#endif
	    if (strEQ(name, "O_RDONLY"))
#ifdef O_RDONLY
		return O_RDONLY;
#else
		goto not_there;
#endif
	    if (strEQ(name, "O_RDWR"))
#ifdef O_RDWR
		return O_RDWR;
#else
		goto not_there;
#endif
	    if (strEQ(name, "O_WRONLY"))
#ifdef O_WRONLY
		return O_WRONLY;
#else
		goto not_there;
#endif
	    if (strEQ(name, "O_EXCL"))
#ifdef O_EXCL
		return O_EXCL;
#else
		goto not_there;
#endif
	    if (strEQ(name, "O_NOCTTY"))
#ifdef O_NOCTTY
		return O_NOCTTY;
#else
		goto not_there;
#endif
	    if (strEQ(name, "O_NONBLOCK"))
#ifdef O_NONBLOCK
		return O_NONBLOCK;
#else
		goto not_there;
#endif
	    if (strEQ(name, "O_ACCMODE"))
#ifdef O_ACCMODE
		return O_ACCMODE;
#else
		goto not_there;
#endif
	    break;
	}
	if (strEQ(name, "OPEN_MAX"))
#ifdef OPEN_MAX
	    return OPEN_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "OPOST"))
#ifdef OPOST
	    return OPOST;
#else
	    goto not_there;
#endif
	break;
    case 'P':
	if (strEQ(name, "PATH_MAX"))
#ifdef PATH_MAX
	    return PATH_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PARENB"))
#ifdef PARENB
	    return PARENB;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PARMRK"))
#ifdef PARMRK
	    return PARMRK;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PARODD"))
#ifdef PARODD
	    return PARODD;
#else
	    goto not_there;
#endif
	if (strEQ(name, "PIPE_BUF"))
#ifdef PIPE_BUF
	    return PIPE_BUF;
#else
	    goto not_there;
#endif
	break;
    case 'R':
	if (strEQ(name, "RAND_MAX"))
#ifdef RAND_MAX
	    return RAND_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "R_OK"))
#ifdef R_OK
	    return R_OK;
#else
	    goto not_there;
#endif
	break;
    case 'S':
	if (strnEQ(name, "SIG", 3)) {
	    if (name[3] == '_') {
		if (strEQ(name, "SIG_BLOCK"))
#ifdef SIG_BLOCK
		    return SIG_BLOCK;
#else
		    goto not_there;
#endif
#ifdef SIG_DFL
		if (strEQ(name, "SIG_DFL")) return (IV)SIG_DFL;
#endif
#ifdef SIG_ERR
		if (strEQ(name, "SIG_ERR")) return (IV)SIG_ERR;
#endif
#ifdef SIG_IGN
		if (strEQ(name, "SIG_IGN")) return (IV)SIG_IGN;
#endif
		if (strEQ(name, "SIG_SETMASK"))
#ifdef SIG_SETMASK
		    return SIG_SETMASK;
#else
		    goto not_there;
#endif
		if (strEQ(name, "SIG_UNBLOCK"))
#ifdef SIG_UNBLOCK
		    return SIG_UNBLOCK;
#else
		    goto not_there;
#endif
		break;
	    }
	    if (strEQ(name, "SIGABRT"))
#ifdef SIGABRT
		return SIGABRT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGALRM"))
#ifdef SIGALRM
		return SIGALRM;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGCHLD"))
#ifdef SIGCHLD
		return SIGCHLD;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGCONT"))
#ifdef SIGCONT
		return SIGCONT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGFPE"))
#ifdef SIGFPE
		return SIGFPE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGHUP"))
#ifdef SIGHUP
		return SIGHUP;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGILL"))
#ifdef SIGILL
		return SIGILL;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGINT"))
#ifdef SIGINT
		return SIGINT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGKILL"))
#ifdef SIGKILL
		return SIGKILL;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGPIPE"))
#ifdef SIGPIPE
		return SIGPIPE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGQUIT"))
#ifdef SIGQUIT
		return SIGQUIT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGSEGV"))
#ifdef SIGSEGV
		return SIGSEGV;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGSTOP"))
#ifdef SIGSTOP
		return SIGSTOP;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGTERM"))
#ifdef SIGTERM
		return SIGTERM;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGTSTP"))
#ifdef SIGTSTP
		return SIGTSTP;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGTTIN"))
#ifdef SIGTTIN
		return SIGTTIN;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGTTOU"))
#ifdef SIGTTOU
		return SIGTTOU;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGUSR1"))
#ifdef SIGUSR1
		return SIGUSR1;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SIGUSR2"))
#ifdef SIGUSR2
		return SIGUSR2;
#else
		goto not_there;
#endif
	    break;
	}
	if (name[1] == '_') {
	    if (strEQ(name, "S_ISGID"))
#ifdef S_ISGID
		return S_ISGID;
#else
		goto not_there;
#endif
	    if (strEQ(name, "S_ISUID"))
#ifdef S_ISUID
		return S_ISUID;
#else
		goto not_there;
#endif
	    if (strEQ(name, "S_IRGRP"))
#ifdef S_IRGRP
		return S_IRGRP;
#else
		goto not_there;
#endif
	    if (strEQ(name, "S_IROTH"))
#ifdef S_IROTH
		return S_IROTH;
#else
		goto not_there;
#endif
	    if (strEQ(name, "S_IRUSR"))
#ifdef S_IRUSR
		return S_IRUSR;
#else
		goto not_there;
#endif
	    if (strEQ(name, "S_IRWXG"))
#ifdef S_IRWXG
		return S_IRWXG;
#else
		goto not_there;
#endif
	    if (strEQ(name, "S_IRWXO"))
#ifdef S_IRWXO
		return S_IRWXO;
#else
		goto not_there;
#endif
	    if (strEQ(name, "S_IRWXU"))
#ifdef S_IRWXU
		return S_IRWXU;
#else
		goto not_there;
#endif
	    if (strEQ(name, "S_IWGRP"))
#ifdef S_IWGRP
		return S_IWGRP;
#else
		goto not_there;
#endif
	    if (strEQ(name, "S_IWOTH"))
#ifdef S_IWOTH
		return S_IWOTH;
#else
		goto not_there;
#endif
	    if (strEQ(name, "S_IWUSR"))
#ifdef S_IWUSR
		return S_IWUSR;
#else
		goto not_there;
#endif
	    if (strEQ(name, "S_IXGRP"))
#ifdef S_IXGRP
		return S_IXGRP;
#else
		goto not_there;
#endif
	    if (strEQ(name, "S_IXOTH"))
#ifdef S_IXOTH
		return S_IXOTH;
#else
		goto not_there;
#endif
	    if (strEQ(name, "S_IXUSR"))
#ifdef S_IXUSR
		return S_IXUSR;
#else
		goto not_there;
#endif
	    errno = EAGAIN;		/* the following aren't constants */
#ifdef S_ISBLK
	    if (strEQ(name, "S_ISBLK")) return S_ISBLK(arg);
#endif
#ifdef S_ISCHR
	    if (strEQ(name, "S_ISCHR")) return S_ISCHR(arg);
#endif
#ifdef S_ISDIR
	    if (strEQ(name, "S_ISDIR")) return S_ISDIR(arg);
#endif
#ifdef S_ISFIFO
	    if (strEQ(name, "S_ISFIFO")) return S_ISFIFO(arg);
#endif
#ifdef S_ISREG
	    if (strEQ(name, "S_ISREG")) return S_ISREG(arg);
#endif
	    break;
	}
	if (strEQ(name, "SEEK_CUR"))
#ifdef SEEK_CUR
	    return SEEK_CUR;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SEEK_END"))
#ifdef SEEK_END
	    return SEEK_END;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SEEK_SET"))
#ifdef SEEK_SET
	    return SEEK_SET;
#else
	    goto not_there;
#endif
	if (strEQ(name, "STREAM_MAX"))
#ifdef STREAM_MAX
	    return STREAM_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SHRT_MAX"))
#ifdef SHRT_MAX
	    return SHRT_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SHRT_MIN"))
#ifdef SHRT_MIN
	    return SHRT_MIN;
#else
	    goto not_there;
#endif
	if (strnEQ(name, "SA_", 3)) {
	    if (strEQ(name, "SA_NOCLDSTOP"))
#ifdef SA_NOCLDSTOP
		return SA_NOCLDSTOP;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SA_NOCLDWAIT"))
#ifdef SA_NOCLDWAIT
		return SA_NOCLDWAIT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SA_NODEFER"))
#ifdef SA_NODEFER
		return SA_NODEFER;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SA_ONSTACK"))
#ifdef SA_ONSTACK
		return SA_ONSTACK;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SA_RESETHAND"))
#ifdef SA_RESETHAND
		return SA_RESETHAND;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SA_RESTART"))
#ifdef SA_RESTART
		return SA_RESTART;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SA_SIGINFO"))
#ifdef SA_SIGINFO
		return SA_SIGINFO;
#else
		goto not_there;
#endif
	    break;
	}
	if (strEQ(name, "SCHAR_MAX"))
#ifdef SCHAR_MAX
	    return SCHAR_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SCHAR_MIN"))
#ifdef SCHAR_MIN
	    return SCHAR_MIN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SSIZE_MAX"))
#ifdef SSIZE_MAX
	    return SSIZE_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "STDIN_FILENO"))
#ifdef STDIN_FILENO
	    return STDIN_FILENO;
#else
	    goto not_there;
#endif
	if (strEQ(name, "STDOUT_FILENO"))
#ifdef STDOUT_FILENO
	    return STDOUT_FILENO;
#else
	    goto not_there;
#endif
	if (strEQ(name, "STDERR_FILENO"))
#ifdef STDERR_FILENO
	    return STDERR_FILENO;
#else
	    goto not_there;
#endif
	break;
    case 'T':
	if (strEQ(name, "TCIFLUSH"))
#ifdef TCIFLUSH
	    return TCIFLUSH;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCIOFF"))
#ifdef TCIOFF
	    return TCIOFF;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCIOFLUSH"))
#ifdef TCIOFLUSH
	    return TCIOFLUSH;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCION"))
#ifdef TCION
	    return TCION;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCOFLUSH"))
#ifdef TCOFLUSH
	    return TCOFLUSH;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCOOFF"))
#ifdef TCOOFF
	    return TCOOFF;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCOON"))
#ifdef TCOON
	    return TCOON;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCSADRAIN"))
#ifdef TCSADRAIN
	    return TCSADRAIN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCSAFLUSH"))
#ifdef TCSAFLUSH
	    return TCSAFLUSH;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TCSANOW"))
#ifdef TCSANOW
	    return TCSANOW;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TMP_MAX"))
#ifdef TMP_MAX
	    return TMP_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TOSTOP"))
#ifdef TOSTOP
	    return TOSTOP;
#else
	    goto not_there;
#endif
	if (strEQ(name, "TZNAME_MAX"))
#ifdef TZNAME_MAX
	    return TZNAME_MAX;
#else
	    goto not_there;
#endif
	break;
    case 'U':
	if (strEQ(name, "UCHAR_MAX"))
#ifdef UCHAR_MAX
	    return UCHAR_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "UINT_MAX"))
#ifdef UINT_MAX
	    return UINT_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "ULONG_MAX"))
#ifdef ULONG_MAX
	    return ULONG_MAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "USHRT_MAX"))
#ifdef USHRT_MAX
	    return USHRT_MAX;
#else
	    goto not_there;
#endif
	break;
    case 'V':
	if (strEQ(name, "VEOF"))
#ifdef VEOF
	    return VEOF;
#else
	    goto not_there;
#endif
	if (strEQ(name, "VEOL"))
#ifdef VEOL
	    return VEOL;
#else
	    goto not_there;
#endif
	if (strEQ(name, "VERASE"))
#ifdef VERASE
	    return VERASE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "VINTR"))
#ifdef VINTR
	    return VINTR;
#else
	    goto not_there;
d234 3
a236 5
	if (strEQ(name, "VKILL"))
#ifdef VKILL
	    return VKILL;
#else
	    goto not_there;
d238 3
a240 5
	if (strEQ(name, "VMIN"))
#ifdef VMIN
	    return VMIN;
#else
	    goto not_there;
a241 5
	if (strEQ(name, "VQUIT"))
#ifdef VQUIT
	    return VQUIT;
#else
	    goto not_there;
d243 2
a244 5
	if (strEQ(name, "VSTART"))
#ifdef VSTART
	    return VSTART;
#else
	    goto not_there;
d246 2
a247 5
	if (strEQ(name, "VSTOP"))
#ifdef VSTOP
	    return VSTOP;
#else
	    goto not_there;
d249 2
a250 5
	if (strEQ(name, "VSUSP"))
#ifdef VSUSP
	    return VSUSP;
#else
	    goto not_there;
d252 2
a253 5
	if (strEQ(name, "VTIME"))
#ifdef VTIME
	    return VTIME;
#else
	    goto not_there;
d255 2
a256 7
	break;
    case 'W':
	if (strEQ(name, "W_OK"))
#ifdef W_OK
	    return W_OK;
#else
	    goto not_there;
d258 2
a259 5
	if (strEQ(name, "WNOHANG"))
#ifdef WNOHANG
	    return WNOHANG;
#else
	    goto not_there;
d261 2
a262 5
	if (strEQ(name, "WUNTRACED"))
#ifdef WUNTRACED
	    return WUNTRACED;
#else
	    goto not_there;
d264 2
a265 3
	errno = EAGAIN;		/* the following aren't constants */
#ifdef WEXITSTATUS
	if (strEQ(name, "WEXITSTATUS")) return WEXITSTATUS(arg);
d267 2
a268 2
#ifdef WIFEXITED
	if (strEQ(name, "WIFEXITED")) return WIFEXITED(arg);
d270 2
a271 2
#ifdef WIFSIGNALED
	if (strEQ(name, "WIFSIGNALED")) return WIFSIGNALED(arg);
d273 2
a274 2
#ifdef WIFSTOPPED
	if (strEQ(name, "WIFSTOPPED")) return WIFSTOPPED(arg);
d276 2
a277 2
#ifdef WSTOPSIG
	if (strEQ(name, "WSTOPSIG")) return WSTOPSIG(arg);
d279 2
a280 2
#ifdef WTERMSIG
	if (strEQ(name, "WTERMSIG")) return WTERMSIG(arg);
d282 2
a283 7
	break;
    case 'X':
	if (strEQ(name, "X_OK"))
#ifdef X_OK
	    return X_OK;
#else
	    goto not_there;
d285 2
a286 8
	break;
    case '_':
	if (strnEQ(name, "_PC_", 4)) {
	    if (strEQ(name, "_PC_CHOWN_RESTRICTED"))
#if defined(_PC_CHOWN_RESTRICTED) || HINT_SC_EXIST
		return _PC_CHOWN_RESTRICTED;
#else
		goto not_there;
d288 4
a291 5
	    if (strEQ(name, "_PC_LINK_MAX"))
#if defined(_PC_LINK_MAX) || HINT_SC_EXIST
		return _PC_LINK_MAX;
#else
		goto not_there;
d293 2
a294 5
	    if (strEQ(name, "_PC_MAX_CANON"))
#if defined(_PC_MAX_CANON) || HINT_SC_EXIST
		return _PC_MAX_CANON;
#else
		goto not_there;
d296 2
a297 5
	    if (strEQ(name, "_PC_MAX_INPUT"))
#if defined(_PC_MAX_INPUT) || HINT_SC_EXIST
		return _PC_MAX_INPUT;
#else
		goto not_there;
d299 4
a302 5
	    if (strEQ(name, "_PC_NAME_MAX"))
#if defined(_PC_NAME_MAX) || HINT_SC_EXIST
		return _PC_NAME_MAX;
#else
		goto not_there;
a303 5
	    if (strEQ(name, "_PC_NO_TRUNC"))
#if defined(_PC_NO_TRUNC) || HINT_SC_EXIST
		return _PC_NO_TRUNC;
#else
		goto not_there;
d305 2
a306 5
	    if (strEQ(name, "_PC_PATH_MAX"))
#if defined(_PC_PATH_MAX) || HINT_SC_EXIST
		return _PC_PATH_MAX;
#else
		goto not_there;
d308 2
a309 5
	    if (strEQ(name, "_PC_PIPE_BUF"))
#if defined(_PC_PIPE_BUF) || HINT_SC_EXIST
		return _PC_PIPE_BUF;
#else
		goto not_there;
d311 2
a312 5
	    if (strEQ(name, "_PC_VDISABLE"))
#if defined(_PC_VDISABLE) || HINT_SC_EXIST
		return _PC_VDISABLE;
#else
		goto not_there;
d314 2
a315 8
	    break;
	}
	if (strnEQ(name, "_POSIX_", 7)) {
	    if (strEQ(name, "_POSIX_ARG_MAX"))
#ifdef _POSIX_ARG_MAX
		return _POSIX_ARG_MAX;
#else
		return 0;
d317 8
a324 5
	    if (strEQ(name, "_POSIX_CHILD_MAX"))
#ifdef _POSIX_CHILD_MAX
		return _POSIX_CHILD_MAX;
#else
		return 0;
a325 5
	    if (strEQ(name, "_POSIX_CHOWN_RESTRICTED"))
#ifdef _POSIX_CHOWN_RESTRICTED
		return _POSIX_CHOWN_RESTRICTED;
#else
		return 0;
d327 3
a329 5
	    if (strEQ(name, "_POSIX_JOB_CONTROL"))
#ifdef _POSIX_JOB_CONTROL
		return _POSIX_JOB_CONTROL;
#else
		return 0;
d331 5
a335 5
	    if (strEQ(name, "_POSIX_LINK_MAX"))
#ifdef _POSIX_LINK_MAX
		return _POSIX_LINK_MAX;
#else
		return 0;
d337 4
a340 5
	    if (strEQ(name, "_POSIX_MAX_CANON"))
#ifdef _POSIX_MAX_CANON
		return _POSIX_MAX_CANON;
#else
		return 0;
d342 2
a343 5
	    if (strEQ(name, "_POSIX_MAX_INPUT"))
#ifdef _POSIX_MAX_INPUT
		return _POSIX_MAX_INPUT;
#else
		return 0;
d345 2
a346 5
	    if (strEQ(name, "_POSIX_NAME_MAX"))
#ifdef _POSIX_NAME_MAX
		return _POSIX_NAME_MAX;
#else
		return 0;
a347 5
	    if (strEQ(name, "_POSIX_NGROUPS_MAX"))
#ifdef _POSIX_NGROUPS_MAX
		return _POSIX_NGROUPS_MAX;
#else
		return 0;
d349 11
a359 3
	    if (strEQ(name, "_POSIX_NO_TRUNC"))
#ifdef _POSIX_NO_TRUNC
		return _POSIX_NO_TRUNC;
d361 1
a361 1
		return 0;
d363 44
a406 3
	    if (strEQ(name, "_POSIX_OPEN_MAX"))
#ifdef _POSIX_OPEN_MAX
		return _POSIX_OPEN_MAX;
d408 1
a408 1
		return 0;
d410 8
a417 3
	    if (strEQ(name, "_POSIX_PATH_MAX"))
#ifdef _POSIX_PATH_MAX
		return _POSIX_PATH_MAX;
d419 1
a419 1
		return 0;
d421 8
a428 3
	    if (strEQ(name, "_POSIX_PIPE_BUF"))
#ifdef _POSIX_PIPE_BUF
		return _POSIX_PIPE_BUF;
d430 1
a430 1
		return 0;
d432 8
a439 3
	    if (strEQ(name, "_POSIX_SAVED_IDS"))
#ifdef _POSIX_SAVED_IDS
		return _POSIX_SAVED_IDS;
d441 1
a441 1
		return 0;
d443 16
a458 3
	    if (strEQ(name, "_POSIX_SSIZE_MAX"))
#ifdef _POSIX_SSIZE_MAX
		return _POSIX_SSIZE_MAX;
d460 1
a460 1
		return 0;
d462 9
a470 3
	    if (strEQ(name, "_POSIX_STREAM_MAX"))
#ifdef _POSIX_STREAM_MAX
		return _POSIX_STREAM_MAX;
d472 1
a472 1
		return 0;
d474 8
a481 3
	    if (strEQ(name, "_POSIX_TZNAME_MAX"))
#ifdef _POSIX_TZNAME_MAX
		return _POSIX_TZNAME_MAX;
d483 1
a483 1
		return 0;
d485 10
a494 3
	    if (strEQ(name, "_POSIX_VDISABLE"))
#ifdef _POSIX_VDISABLE
		return _POSIX_VDISABLE;
d496 1
a496 1
		return 0;
d498 8
a505 3
	    if (strEQ(name, "_POSIX_VERSION"))
#ifdef _POSIX_VERSION
		return _POSIX_VERSION;
d507 1
a507 1
		return 0;
d509 14
a522 6
	    break;
	}
	if (strnEQ(name, "_SC_", 4)) {
	    if (strEQ(name, "_SC_ARG_MAX"))
#if defined(_SC_ARG_MAX) || HINT_SC_EXIST
		return _SC_ARG_MAX;
d524 1
a524 1
		goto not_there;
d526 9
a534 9
	    if (strEQ(name, "_SC_CHILD_MAX"))
#if defined(_SC_CHILD_MAX) || HINT_SC_EXIST
		return _SC_CHILD_MAX;
#else
		goto not_there;
#endif
	    if (strEQ(name, "_SC_CLK_TCK"))
#if defined(_SC_CLK_TCK) || HINT_SC_EXIST
		return _SC_CLK_TCK;
d536 1
a536 1
		goto not_there;
d538 2
a539 44
	    if (strEQ(name, "_SC_JOB_CONTROL"))
#if defined(_SC_JOB_CONTROL) || HINT_SC_EXIST
		return _SC_JOB_CONTROL;
#else
		goto not_there;
#endif
	    if (strEQ(name, "_SC_NGROUPS_MAX"))
#if defined(_SC_NGROUPS_MAX) || HINT_SC_EXIST
		return _SC_NGROUPS_MAX;
#else
		goto not_there;
#endif
	    if (strEQ(name, "_SC_OPEN_MAX"))
#if defined(_SC_OPEN_MAX) || HINT_SC_EXIST
		return _SC_OPEN_MAX;
#else
		goto not_there;
#endif
	    if (strEQ(name, "_SC_SAVED_IDS"))
#if defined(_SC_SAVED_IDS) || HINT_SC_EXIST
		return _SC_SAVED_IDS;
#else
		goto not_there;
#endif
	    if (strEQ(name, "_SC_STREAM_MAX"))
#if defined(_SC_STREAM_MAX) || HINT_SC_EXIST
		return _SC_STREAM_MAX;
#else
		goto not_there;
#endif
	    if (strEQ(name, "_SC_TZNAME_MAX"))
#if defined(_SC_TZNAME_MAX) || HINT_SC_EXIST
		return _SC_TZNAME_MAX;
#else
		goto not_there;
#endif
	    if (strEQ(name, "_SC_VERSION"))
#if defined(_SC_VERSION) || HINT_SC_EXIST
		return _SC_VERSION;
#else
		goto not_there;
#endif
	    break;
	}
d541 4
a544 2
    errno = EINVAL;
    return 0;
d546 10
a555 3
not_there:
    errno = ENOENT;
    return 0;
d797 43
a839 4
NV
constant(name,arg)
	char *		name
	int		arg
d1194 1
a1194 1
sigaction(sig, action, oldaction = 0)
d1196 1
a1196 1
	POSIX::SigAction	action
d1199 1
a1199 1
#ifdef WIN32
d1206 1
d1210 3
a1218 1
	    STRLEN n_a;
d1220 29
a1248 1
	    /* Remember old handler name if desired. */
a1249 1
		char *hand = SvPVx(*sigsvp, n_a);
d1251 26
a1276 1
		sv_setpv(*svp, *hand ? hand : "DEFAULT");
d1285 1
a1285 1
		sv_setpv(*sigsvp, SvPV(*svp, n_a));
d1287 15
a1301 1
		act.sa_handler = PL_sighandlerp;
d1307 1
a1307 1
		    sigset =  INT2PTR(sigset_t*, tmp);
a1315 1
	    }
d1317 5
a1321 4
	    /* Now work around sigaction oddities */
	    if (action && oldaction)
		RETVAL = sigaction(sig, & act, & oact);
	    else if (action)
d1323 3
a1325 17
	    else if (oldaction)
		RETVAL = sigaction(sig, (struct sigaction *)0, & oact);
	    else
		RETVAL = -1;

	    if (oldaction) {
		/* Get back the mask. */
		svp = hv_fetch(oldaction, "MASK", 4, TRUE);
		if (sv_isa(*svp, "POSIX::SigSet")) {
		    IV tmp = SvIV((SV*)SvRV(*svp));
		    sigset = INT2PTR(sigset_t*, tmp);
		}
		else {
		    New(0, sigset, 1, sigset_t);
		    sv_setptrobj(*svp, sigset, "POSIX::SigSet");
		}
		*sigset = oact.sa_mask;
d1327 1
a1327 4
		/* Get back the flags. */
		svp = hv_fetch(oldaction, "FLAGS", 5, TRUE);
		sv_setiv(*svp, oact.sa_flags);
	    }
d1573 1
a1573 1
          ST(0) = sv_2mortal(NEWSV(800,srclen));
d1716 4
a1719 58
	    char tmpbuf[128];
	    struct tm mytm;
	    int len;
	    init_tm(&mytm);	/* XXX workaround - see init_tm() above */
	    mytm.tm_sec = sec;
	    mytm.tm_min = min;
	    mytm.tm_hour = hour;
	    mytm.tm_mday = mday;
	    mytm.tm_mon = mon;
	    mytm.tm_year = year;
	    mytm.tm_wday = wday;
	    mytm.tm_yday = yday;
	    mytm.tm_isdst = isdst;
	    mini_mktime(&mytm);
	    len = strftime(tmpbuf, sizeof tmpbuf, fmt, &mytm);
	    /*
	    ** The following is needed to handle to the situation where 
	    ** tmpbuf overflows.  Basically we want to allocate a buffer
	    ** and try repeatedly.  The reason why it is so complicated
	    ** is that getting a return value of 0 from strftime can indicate
	    ** one of the following:
	    ** 1. buffer overflowed,
	    ** 2. illegal conversion specifier, or
	    ** 3. the format string specifies nothing to be returned(not
	    **	  an error).  This could be because format is an empty string
	    **    or it specifies %p that yields an empty string in some locale.
	    ** If there is a better way to make it portable, go ahead by
	    ** all means.
	    */
	    if ((len > 0 && len < sizeof(tmpbuf)) || (len == 0 && *fmt == '\0'))
		ST(0) = sv_2mortal(newSVpv(tmpbuf, len));
            else {
		/* Possibly buf overflowed - try again with a bigger buf */
                int     fmtlen = strlen(fmt);
		int	bufsize = fmtlen + sizeof(tmpbuf);
		char* 	buf;
		int	buflen;

		New(0, buf, bufsize, char);
		while (buf) {
		    buflen = strftime(buf, bufsize, fmt, &mytm);
		    if (buflen > 0 && buflen < bufsize)
                        break;
                    /* heuristic to prevent out-of-memory errors */
                    if (bufsize > 100*fmtlen) {
                        Safefree(buf);
                        buf = NULL;
                        break;
                    }
		    bufsize *= 2;
		    Renew(buf, bufsize, char);
		}
		if (buf) {
		    ST(0) = sv_2mortal(newSVpvn(buf, buflen));
		    Safefree(buf);
		}
                else
		    ST(0) = sv_2mortal(newSVpvn(tmpbuf, len));
d1759 8
d1774 10
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d58 3
d86 1
a86 1
   clock_t vms_times(struct tms *PL_bufptr) {
d107 1
a107 1
	times((tbuffer_t *)PL_bufptr);
d145 2
d150 1
a150 1
#    ifdef OS2
d159 10
a168 4
#  include <grp.h>
#  include <sys/times.h>
#  ifdef HAS_UNAME
#    include <sys/utsname.h>
a169 1
#  include <sys/wait.h>
d542 1
a542 1
#  if LONG_DOUBLESIZE > DOUBLESIZE
d547 1
a547 1
#ifndef HAS_LONG_DOUBLE 
d567 1
a567 5
#if defined(HAS_LONG_DOUBLE) && (LONG_DOUBLESIZE > DOUBLESIZE)
long double
#else
double
#endif
d1526 5
d2305 3
a2307 3
	if (strEQ(name, "STRERR_FILENO"))
#ifdef STRERR_FILENO
	    return STRERR_FILENO;
d3019 1
a3019 1
double
d3175 1
a3175 1
	if (lcbuf = localeconv()) {
d3308 1
a3308 1
double
d3310 1
a3310 1
	double		x
d3312 1
a3312 1
double
d3314 1
a3314 1
	double		x
d3316 1
a3316 1
double
d3318 1
a3318 1
	double		x
d3320 1
a3320 1
double
d3322 1
a3322 1
	double		x
d3324 1
a3324 1
double
d3326 1
a3326 1
	double		x
d3328 1
a3328 1
double
d3330 1
a3330 1
	double		x
d3332 1
a3332 1
double
d3334 2
a3335 2
	double		x
	double		y
d3339 1
a3339 1
	double		x
d3346 1
a3346 1
double
d3348 1
a3348 1
	double		x
d3351 1
a3351 1
double
d3353 1
a3353 1
	double		x
d3357 1
a3357 1
	double		x
d3359 1
a3359 1
	double intvar;
d3361 1
a3361 1
	PUSHs(sv_2mortal(newSVnv(modf(x,&intvar))));
d3364 1
a3364 1
double
d3366 1
a3366 1
	double		x
d3368 1
a3368 1
double
d3370 1
a3370 1
	double		x
d3372 1
a3372 1
double
d3374 1
a3374 1
	double		x
d3420 2
a3421 3
		    unsigned long tmp;
		    tmp = (unsigned long)SvNV((SV*)SvRV(*svp));
		    sigset = (sigset_t*) tmp;
d3446 2
a3447 3
		    unsigned long tmp;
		    tmp = (unsigned long)SvNV((SV*)SvRV(*svp));
		    sigset = (sigset_t*) tmp;
d3518 1
a3518 1
int
d3561 1
a3561 1
int
d3695 1
a3695 1
SV *
d3830 4
a3833 1
char *
@


1.3
log
@perl5.005_03 (stock)
@
text
@d4 3
d11 1
a11 1
#ifdef PERL_OBJECT	/* XXX _very_ temporary hacks */
d84 1
d109 3
d145 6
a150 2
#    ifndef mkfifo
#      define mkfifo(path, mode) (mknod((path), (mode) | S_IFIFO, 0))
d191 4
a194 4
char *cuserid _((char *));
double strtod _((const char *, char **));
long strtol _((const char *, char **, int));
unsigned long strtoul _((const char *, char **, int));
d292 1
a292 1
#  ifndef WIN32
d317 1
a317 1
#    define STRUCT_TM_HAS_ZONE
d323 1
a323 2
init_tm(ptm)		/* see mktime, strftime and asctime	*/
    struct tm *ptm;
d334 196
d557 1
a557 1
#ifdef HAS_LONG_DOUBLE
d1728 4
a1731 3
	    if (strEQ(name, "L_tmpname"))
#ifdef L_tmpname
		return L_tmpname;
d3255 1
a3255 1
		perl_new_ctype(newctype);
d3272 1
a3272 1
		perl_new_collate(newcoll);
d3289 1
a3289 1
		perl_new_numeric(newnum);
a3376 3
	if (!PL_siggv)
	    gv_fetchpv("SIG", TRUE, SVt_PVHV);

d3378 1
d3383 3
a3385 3
	    SV** sigsvp = hv_fetch(GvHVn(PL_siggv),
				 sig_name[sig],
				 strlen(sig_name[sig]),
d3404 1
a3404 1
		act.sa_handler = sighandler;
d3470 1
a3470 1
	    oldsigset = (POSIX__SigSet) tmp;
d3575 12
a3586 3
char *
tmpnam(s = 0)
	char *		s = 0;
d3651 5
a3655 1
	if (num >= IV_MIN && num <= IV_MAX)
a3656 2
	else
	    PUSHs(sv_2mortal(newSVnv((double)num)));
d3848 1
a3848 1
	    (void) mktime(&mytm);
d3864 1
a3864 2
	    if ( ( len > 0 && len < sizeof(tmpbuf) )
	    		|| ( len == 0 && strlen(fmt) == 0 ) ) {
d3866 1
a3866 1
	    } else {
d3868 2
a3869 1
		int	bufsize = strlen(fmt) + sizeof(tmpbuf);
d3874 1
a3874 1
		while( buf ) {
d3876 8
a3883 1
		    if ( buflen > 0 && buflen < bufsize ) break;
d3887 2
a3888 2
		if ( buf ) {
		    ST(0) = sv_2mortal(newSVpv(buf, buflen));
a3889 2
		} else {
		    ST(0) = sv_2mortal(newSVpv(tmpbuf, len));
d3891 2
d3903 2
a3904 2
	PUSHs(sv_2mortal(newSVpv(tzname[0],strlen(tzname[0]))));
	PUSHs(sv_2mortal(newSVpv(tzname[1],strlen(tzname[1]))));
@


1.2
log
@perl 5.004_04
@
text
@d1 3
d8 6
a31 1
#ifdef I_STDARG
d33 1
a33 1
#endif
d37 1
d52 3
a54 1
#include <unistd.h>	/* see hints/sunos_4_1.sh */
d65 1
a65 1
#  undef mkfifo  /* #defined in perl.h */
a71 70
#else
     /* The default VMS emulation of Unix signals isn't very POSIXish */
     typedef int sigset_t;
#    define sigpending(a) (not_here("sigpending"),0)

     /* sigset_t is atomic under VMS, so these routines are easy */
     int sigemptyset(sigset_t *set) {
	if (!set) { SETERRNO(EFAULT,SS$_ACCVIO); return -1; }
	*set = 0; return 0;
     }
     int sigfillset(sigset_t *set) {
	int i;
	if (!set) { SETERRNO(EFAULT,SS$_ACCVIO); return -1; }
	for (i = 0; i < NSIG; i++) *set |= (1 << i);
	return 0;
     }
     int sigaddset(sigset_t *set, int sig) {
	if (!set) { SETERRNO(EFAULT,SS$_ACCVIO); return -1; }
	if (sig > NSIG) { SETERRNO(EINVAL,LIB$_INVARG); return -1; }
	*set |= (1 << (sig - 1));
	return 0;
     }
     int sigdelset(sigset_t *set, int sig) {
	if (!set) { SETERRNO(EFAULT,SS$_ACCVIO); return -1; }
	if (sig > NSIG) { SETERRNO(EINVAL,LIB$_INVARG); return -1; }
	*set &= ~(1 << (sig - 1));
	return 0;
     }
     int sigismember(sigset_t *set, int sig) {
	if (!set) { SETERRNO(EFAULT,SS$_ACCVIO); return -1; }
	if (sig > NSIG) { SETERRNO(EINVAL,LIB$_INVARG); return -1; }
	*set & (1 << (sig - 1));
     }
     /* The tools for sigprocmask() are there, just not the routine itself */
#    ifndef SIG_UNBLOCK
#      define SIG_UNBLOCK 1
#    endif
#    ifndef SIG_BLOCK
#      define SIG_BLOCK 2
#    endif
#    ifndef SIG_SETMASK
#      define SIG_SETMASK 3
#    endif
     int sigprocmask(int how, sigset_t *set, sigset_t *oset) {
	if (!set || !oset) {
	  set_errno(EFAULT); set_vaxc_errno(SS$_ACCVIO);
	  return -1;
	}
	switch (how) {
	  case SIG_SETMASK:
	    *oset = sigsetmask(*set);
	    break;
	  case SIG_BLOCK:
	    *oset = sigblock(*set);
	    break;
	  case SIG_UNBLOCK:
	    *oset = sigblock(0);
	    sigsetmask(*oset & ~*set);
	    break;
	  default:
	    set_errno(EINVAL); set_vaxc_errno(LIB$_INVARG);
	    return -1;
	}
	return 0;
     }
#    define sigaction sigvec
#    define sa_flags sv_onstack
#    define sa_handler sv_handler
#    define sa_mask sv_mask
#    define sigsuspend(set) sigpause(*set)
d80 1
a80 1
   clock_t vms_times(struct tms *bufptr) {
d100 1
a100 1
	times((tbuffer_t *)bufptr);
d105 38
d152 2
a153 1
#endif
d281 1
d283 1
d285 1
d288 1
d304 6
d325 7
a331 1
#ifndef HAS_LONG_DOUBLE /* XXX What to do about long doubles? */
d344 1
a344 2
not_here(s)
char *s;
d350 7
a356 4
static double
constant(name, arg)
char *name;
int arg;
d823 2
d2318 1
a2318 1
#ifdef _PC_CHOWN_RESTRICTED
d2324 1
a2324 1
#ifdef _PC_LINK_MAX
d2330 1
a2330 1
#ifdef _PC_MAX_CANON
d2336 1
a2336 1
#ifdef _PC_MAX_INPUT
d2342 1
a2342 1
#ifdef _PC_NAME_MAX
d2348 1
a2348 1
#ifdef _PC_NO_TRUNC
d2354 1
a2354 1
#ifdef _PC_PATH_MAX
d2360 1
a2360 1
#ifdef _PC_PIPE_BUF
d2366 1
a2366 1
#ifdef _PC_VDISABLE
d2492 1
a2492 1
#ifdef _SC_ARG_MAX
d2498 1
a2498 1
#ifdef _SC_CHILD_MAX
d2504 1
a2504 1
#ifdef _SC_CLK_TCK
d2510 1
a2510 1
#ifdef _SC_JOB_CONTROL
d2516 1
a2516 1
#ifdef _SC_NGROUPS_MAX
d2522 1
a2522 1
#ifdef _SC_OPEN_MAX
d2528 1
a2528 1
#ifdef _SC_SAVED_IDS
d2534 1
a2534 1
#ifdef _SC_STREAM_MAX
d2540 1
a2540 1
#ifdef _SC_TZNAME_MAX
d2546 1
a2546 1
#ifdef _SC_VERSION
d2570 1
a2570 1
	    RETVAL = (sigset_t*)safemalloc(sizeof(sigset_t));
d2582 1
a2582 1
	safefree((char *)sigset);
d2616 1
a2616 1
	    RETVAL = (struct termios*)safemalloc(sizeof(struct termios));
d2619 1
d2630 1
a2630 1
	safefree((char *)termios_ref);
d2669 2
a2670 1
	    not_here("getiflag");
d2682 2
a2683 1
	    not_here("getoflag");
d2695 2
a2696 1
	    not_here("getcflag");
d2708 2
a2709 1
	    not_here("getlflag");
d2724 2
a2725 1
	    not_here("getcc");
d2811 1
a2811 1
	unsigned char *e = s + na;	/* "na" set by typemap side effect */
d2823 1
a2823 1
	unsigned char *e = s + na;	/* "na" set by typemap side effect */
d2835 1
a2835 1
	unsigned char *e = s + na;	/* "na" set by typemap side effect */
d2847 1
a2847 1
	unsigned char *e = s + na;	/* "na" set by typemap side effect */
d2859 1
a2859 1
	unsigned char *e = s + na;	/* "na" set by typemap side effect */
d2871 1
a2871 1
	unsigned char *e = s + na;	/* "na" set by typemap side effect */
d2883 1
a2883 1
	unsigned char *e = s + na;	/* "na" set by typemap side effect */
d2895 1
a2895 1
	unsigned char *e = s + na;	/* "na" set by typemap side effect */
d2907 1
a2907 1
	unsigned char *e = s + na;	/* "na" set by typemap side effect */
d2919 1
a2919 1
	unsigned char *e = s + na;	/* "na" set by typemap side effect */
d2931 1
a2931 1
	unsigned char *e = s + na;	/* "na" set by typemap side effect */
a2956 1
	SET_NUMERIC_LOCAL();
d2965 1
d2969 1
d2979 1
d2983 2
d2988 1
d3164 3
a3166 1

d3170 1
a3170 1
	if (!siggv)
d3178 1
a3178 1
	    SV** sigsvp = hv_fetch(GvHVn(siggv),
d3182 1
d3186 1
a3186 1
		char *hand = SvPVx(*sigsvp, na);
d3197 1
a3197 1
		sv_setpv(*sigsvp, SvPV(*svp, na));
d3236 1
a3236 1
		    sigset = (sigset_t*)safemalloc(sizeof(sigset_t));
d3246 1
d3258 14
a3271 1
	POSIX::SigSet		oldsigset
d3309 1
a3309 1
	    EXTEND(sp,2);
d3353 1
a3353 1
	    EXTEND(sp, 5);
d3421 1
a3421 1
	    EXTEND(sp, 1);
d3425 1
a3425 1
		PUSHs(&sv_undef);
d3442 1
a3442 1
	    EXTEND(sp, 1);
d3446 1
a3446 1
		PUSHs(&sv_undef);
d3463 1
a3463 1
	    EXTEND(sp, 1);
d3467 1
a3467 1
		PUSHs(&sv_undef);
d3564 1
a3564 1
	EXTEND(sp,5);
d3606 1
a3606 1
strftime(fmt, sec, min, hour, mday, mon, year, wday = 0, yday = 0, isdst = 0)
d3632 1
d3634 37
a3670 1
	    ST(0) = sv_2mortal(newSVpv(tmpbuf, len));
d3679 1
a3679 1
	EXTEND(sp,2);
@


1.1
log
@Initial revision
@
text
@d2 1
a35 1
#include <stdio.h>
d43 3
a45 1
#include <unistd.h>
a46 1
#  include <file.h>         /* == fcntl.h for DECC; no fcntl.h for VAXC */
d50 3
d58 7
a64 3
   /* The default VMS emulation of Unix signals isn't very POSIXish */
   typedef int sigset_t;
#  define sigpending(a) (not_here("sigpending"),0)
d66 2
a67 2
   /* sigset_t is atomic under VMS, so these routines are easy */
   int sigemptyset(sigset_t *set) {
d70 2
a71 2
   }
   int sigfillset(sigset_t *set) {
d76 2
a77 2
   }
   int sigaddset(sigset_t *set, int sig) {
d82 2
a83 2
   }
   int sigdelset(sigset_t *set, int sig) {
d88 2
a89 2
   }
   int sigismember(sigset_t *set, int sig) {
d93 12
a104 12
   }
   /* The tools for sigprocmask() are there, just not the routine itself */
#  ifndef SIG_UNBLOCK
#    define SIG_UNBLOCK 1
#  endif
#  ifndef SIG_BLOCK
#    define SIG_BLOCK 2
#  endif
#  ifndef SIG_SETMASK
#    define SIG_SETMASK 3
#  endif
   int sigprocmask(int how, sigset_t *set, sigset_t *oset) {
d125 7
a131 6
    }
#  define sigaction sigvec
#  define sa_flags sv_onstack
#  define sa_handler sv_handler
#  define sa_mask sv_mask
#  define sigsuspend(set) sigpause(*set)
a163 1
#  include <fcntl.h>
d201 3
d240 9
a267 7
#ifndef HAS_FGETPOS
#define fgetpos(a,b) not_here("fgetpos")
#endif
#ifndef HAS_FSETPOS
#define fsetpos(a,b) not_here("fsetpos")
#endif

d631 18
d655 6
d707 18
d733 6
d745 6
d774 14
d789 6
d813 6
d825 6
d845 6
d853 30
d889 6
d901 3
a903 3
	    if (strEQ(name, "ENOEXEC"))
#ifdef ENOEXEC
		return ENOEXEC;
d907 3
a909 3
	    if (strEQ(name, "ENOTTY"))
#ifdef ENOTTY
		return ENOTTY;
d925 12
d987 6
d1001 6
d1013 18
d1039 12
d1059 12
d1083 6
d1090 36
d1735 1
a1735 1
		if (strEQ(name, "SIG_DFL")) return (int)SIG_DFL;
d1738 1
a1738 1
		if (strEQ(name, "SIG_ERR")) return (int)SIG_ERR;
d1741 1
a1741 1
		if (strEQ(name, "SIG_IGN")) return (int)SIG_IGN;
d2012 2
a2013 1
	if (strEQ(name, "SA_NOCLDSTOP"))
d2015 25
a2039 1
	    return SA_NOCLDSTOP;
d2041 13
a2053 1
	    goto not_there;
d2055 2
d2802 1
a2802 1
	char *		charstring
d2804 3
a2806 3
	char *s;
	RETVAL = 1;
	for (s = charstring; *s && RETVAL; s++)
d2814 1
a2814 1
	char *		charstring
d2816 3
a2818 3
	char *s;
	RETVAL = 1;
	for (s = charstring; *s && RETVAL; s++)
d2826 1
a2826 1
	char *		charstring
d2828 3
a2830 3
	char *s;
	RETVAL = 1;
	for (s = charstring; *s && RETVAL; s++)
d2838 1
a2838 1
	char *		charstring
d2840 3
a2842 3
	char *s;
	RETVAL = 1;
	for (s = charstring; *s && RETVAL; s++)
d2850 1
a2850 1
	char *		charstring
d2852 3
a2854 3
	char *s;
	RETVAL = 1;
	for (s = charstring; *s && RETVAL; s++)
d2862 1
a2862 1
	char *		charstring
d2864 3
a2866 3
	char *s;
	RETVAL = 1;
	for (s = charstring; *s && RETVAL; s++)
d2874 1
a2874 1
	char *		charstring
d2876 3
a2878 3
	char *s;
	RETVAL = 1;
	for (s = charstring; *s && RETVAL; s++)
d2886 1
a2886 1
	char *		charstring
d2888 3
a2890 3
	char *s;
	RETVAL = 1;
	for (s = charstring; *s && RETVAL; s++)
d2898 1
a2898 1
	char *		charstring
d2900 3
a2902 3
	char *s;
	RETVAL = 1;
	for (s = charstring; *s && RETVAL; s++)
d2910 1
a2910 1
	char *		charstring
d2912 3
a2914 3
	char *s;
	RETVAL = 1;
	for (s = charstring; *s && RETVAL; s++)
d2922 1
a2922 1
	char *		charstring
d2924 3
a2926 3
	char *s;
	RETVAL = 1;
	for (s = charstring; *s && RETVAL; s++)
d2951 1
d3017 1
a3017 1
setlocale(category, locale)
d3020 58
d3299 1
a3299 2
            if (tainting)
                sv_magic(sv_buffer, 0, 't', 0, 0);
d3382 60
d3537 5
a3541 5
	PUSHs( sv_2mortal( newSVnv( realtime ) ) );
	PUSHs( sv_2mortal( newSVnv( tms.tms_utime ) ) );
	PUSHs( sv_2mortal( newSVnv( tms.tms_stime ) ) );
	PUSHs( sv_2mortal( newSVnv( tms.tms_cutime ) ) );
	PUSHs( sv_2mortal( newSVnv( tms.tms_cstime ) ) );
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a0 3
#ifdef WIN32
#define _POSIX_
#endif
a1 1
#define PERLIO_NOT_STDIO 1
a3 6
#ifdef PERL_OBJECT	/* XXX _very_ temporary hacks */
#  undef signal
#  undef open
#  undef setmode
#  define open PerlLIO_open3
#endif
d22 1
d24 1
a24 1

a27 1

d35 1
a42 1
#ifdef I_UNISTD
a43 3
#endif
#include <fcntl.h>

d45 1
a48 3
#  if DECC_VERSION < 50000000
#    define pid_t int       /* old versions of DECC miss this in types.h */
#  endif
d50 1
a50 1
#  undef mkfifo
d54 69
a122 4
#if ((__VMS_VER >= 70000000) && (__DECC_VER >= 50200000)) || (__CRTL_VER >= 70000000)
#    define HAS_TZNAME  /* shows up in VMS 7.0 or Dec C 5.6 */
#    include <utsname.h>
#  endif /* __VMS_VER >= 70000000 or Dec C 5.6 */
d130 1
a130 1
   clock_t vms_times(struct tms *PL_bufptr) {
d150 1
a150 1
	times((tbuffer_t *)PL_bufptr);
d155 1
a155 38
#if defined (WIN32)
#  undef mkfifo
#  define mkfifo(a,b) not_here("mkfifo")
#  define ttyname(a) (char*)not_here("ttyname")
#  define sigset_t long
#  define pid_t long
#  ifdef __BORLANDC__
#    define tzname _tzname
#  endif
#  ifdef _MSC_VER
#    define mode_t short
#  endif
#  ifdef __MINGW32__
#    define mode_t short
#    ifndef tzset
#      define tzset()		not_here("tzset")
#    endif
#    ifndef _POSIX_OPEN_MAX
#      define _POSIX_OPEN_MAX	FOPEN_MAX	/* XXX bogus ? */
#    endif
#  endif
#  define sigaction(a,b,c)	not_here("sigaction")
#  define sigpending(a)		not_here("sigpending")
#  define sigprocmask(a,b,c)	not_here("sigprocmask")
#  define sigsuspend(a)		not_here("sigsuspend")
#  define sigemptyset(a)	not_here("sigemptyset")
#  define sigaddset(a,b)	not_here("sigaddset")
#  define sigdelset(a,b)	not_here("sigdelset")
#  define sigfillset(a)		not_here("sigfillset")
#  define sigismember(a,b)	not_here("sigismember")
#else

#  ifndef HAS_MKFIFO
#    ifndef mkfifo
#      define mkfifo(path, mode) (mknod((path), (mode) | S_IFIFO, 0))
#    endif
#  endif /* !HAS_MKFIFO */

d165 1
a165 2
#endif /* WIN32 */
#endif /* __VMS */
a192 3
double strtod _((const char *, char **));
long strtol _((const char *, char **, int));
unsigned long strtoul _((const char *, char **, int));
a228 9
#ifndef HAS_STRTOD
#define strtod(s1,s2) not_here("strtod")
#endif
#ifndef HAS_STRTOL
#define strtol(s1,s2,b) not_here("strtol")
#endif
#ifndef HAS_STRTOUL
#define strtoul(s1,s2,b) not_here("strtoul")
#endif
d248 7
a287 1
#  ifndef WIN32
a288 1
#  endif
a289 1
#if !defined(WIN32) || (defined(__MINGW32__) && !defined(tzname))
a291 1
#endif
a306 6
#ifdef HAS_GNULIBC
# ifndef STRUCT_TM_HASZONE
#    define STRUCT_TM_HAS_ZONE
# endif
#endif

d322 1
a322 7
#ifdef HAS_LONG_DOUBLE
#  if LONG_DOUBLESIZE > DOUBLESIZE
#    undef HAS_LONG_DOUBLE  /* XXX until we figure out how to use them */
#  endif
#endif

#ifndef HAS_LONG_DOUBLE 
d335 2
a336 1
not_here(char *s)
d342 4
a345 7
static
#ifdef HAS_LONG_DOUBLE
long double
#else
double
#endif
constant(char *name, int arg)
a617 18
	    if (strEQ(name, "EADDRINUSE"))
#ifdef EADDRINUSE
		return EADDRINUSE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EADDRNOTAVAIL"))
#ifdef EADDRNOTAVAIL
		return EADDRNOTAVAIL;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EAFNOSUPPORT"))
#ifdef EAFNOSUPPORT
		return EAFNOSUPPORT;
#else
		goto not_there;
#endif
a623 6
	    if (strEQ(name, "EALREADY"))
#ifdef EALREADY
		return EALREADY;
#else
		goto not_there;
#endif
a669 18
	    if (strEQ(name, "ECONNABORTED"))
#ifdef ECONNABORTED
		return ECONNABORTED;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ECONNREFUSED"))
#ifdef ECONNREFUSED
		return ECONNREFUSED;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ECONNRESET"))
#ifdef ECONNRESET
		return ECONNRESET;
#else
		goto not_there;
#endif
a677 6
	    if (strEQ(name, "EDESTADDRREQ"))
#ifdef EDESTADDRREQ
		return EDESTADDRREQ;
#else
		goto not_there;
#endif
a683 6
	    if (strEQ(name, "EDQUOT"))
#ifdef EDQUOT
		return EDQUOT;
#else
		goto not_there;
#endif
a706 14
	case 'H':
	    if (strEQ(name, "EHOSTDOWN"))
#ifdef EHOSTDOWN
		return EHOSTDOWN;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EHOSTUNREACH"))
#ifdef EHOSTUNREACH
		return EHOSTUNREACH;
#else
		goto not_there;
#endif
    	    break;
a707 6
	    if (strEQ(name, "EINPROGRESS"))
#ifdef EINPROGRESS
		return EINPROGRESS;
#else
		goto not_there;
#endif
a725 6
	    if (strEQ(name, "EISCONN"))
#ifdef EISCONN
		return EISCONN;
#else
		goto not_there;
#endif
a732 8
	case 'L':
	    if (strEQ(name, "ELOOP"))
#ifdef ELOOP
		return ELOOP;
#else
		goto not_there;
#endif
	    break;
a745 6
	    if (strEQ(name, "EMSGSIZE"))
#ifdef EMSGSIZE
		return EMSGSIZE;
#else
		goto not_there;
#endif
a747 30
	    if (strEQ(name, "ENETDOWN"))
#ifdef ENETDOWN
		return ENETDOWN;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENETRESET"))
#ifdef ENETRESET
		return ENETRESET;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENETUNREACH"))
#ifdef ENETUNREACH
		return ENETUNREACH;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOBUFS"))
#ifdef ENOBUFS
		return ENOBUFS;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOEXEC"))
#ifdef ENOEXEC
		return ENOEXEC;
#else
		goto not_there;
#endif
a753 6
	    if (strEQ(name, "ENOPROTOOPT"))
#ifdef ENOPROTOOPT
		return ENOPROTOOPT;
#else
		goto not_there;
#endif
d760 3
a762 3
	    if (strEQ(name, "ENOTBLK"))
#ifdef ENOTBLK
		return ENOTBLK;
d766 3
a768 3
	    if (strEQ(name, "ENOTCONN"))
#ifdef ENOTCONN
		return ENOTCONN;
a783 12
	    if (strEQ(name, "ENOTSOCK"))
#ifdef ENOTSOCK
		return ENOTSOCK;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ENOTTY"))
#ifdef ENOTTY
		return ENOTTY;
#else
		goto not_there;
#endif
a833 6
	    if (strEQ(name, "EOPNOTSUPP"))
#ifdef EOPNOTSUPP
		return EOPNOTSUPP;
#else
		goto not_there;
#endif
a841 6
	    if (strEQ(name, "EPFNOSUPPORT"))
#ifdef EPFNOSUPPORT
		return EPFNOSUPPORT;
#else
		goto not_there;
#endif
a847 18
	    if (strEQ(name, "EPROCLIM"))
#ifdef EPROCLIM
		return EPROCLIM;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EPROTONOSUPPORT"))
#ifdef EPROTONOSUPPORT
		return EPROTONOSUPPORT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "EPROTOTYPE"))
#ifdef EPROTOTYPE
		return EPROTOTYPE;
#else
		goto not_there;
#endif
a855 12
	    if (strEQ(name, "EREMOTE"))
#ifdef EREMOTE
		return EREMOTE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ERESTART"))
#ifdef ERESTART
		return ERESTART;
#else
		goto not_there;
#endif
a863 12
	    if (strEQ(name, "ESHUTDOWN"))
#ifdef ESHUTDOWN
		return ESHUTDOWN;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ESOCKTNOSUPPORT"))
#ifdef ESOCKTNOSUPPORT
		return ESOCKTNOSUPPORT;
#else
		goto not_there;
#endif
a875 6
	    if (strEQ(name, "ESTALE"))
#ifdef ESTALE
		return ESTALE;
#else
		goto not_there;
#endif
a876 36
	case 'T':
	    if (strEQ(name, "ETIMEDOUT"))
#ifdef ETIMEDOUT
		return ETIMEDOUT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ETOOMANYREFS"))
#ifdef ETOOMANYREFS
		return ETOOMANYREFS;
#else
		goto not_there;
#endif
	    if (strEQ(name, "ETXTBSY"))
#ifdef ETXTBSY
		return ETXTBSY;
#else
		goto not_there;
#endif
    	    break;
	case 'U':
	    if (strEQ(name, "EUSERS"))
#ifdef EUSERS
		return EUSERS;
#else
		goto not_there;
#endif
    	    break;
    	case 'W':
	    if (strEQ(name, "EWOULDBLOCK"))
#ifdef EWOULDBLOCK
		return EWOULDBLOCK;
#else
		goto not_there;
#endif
    	    break;
d1486 1
a1486 1
		if (strEQ(name, "SIG_DFL")) return (IV)SIG_DFL;
d1489 1
a1489 1
		if (strEQ(name, "SIG_ERR")) return (IV)SIG_ERR;
d1492 1
a1492 1
		if (strEQ(name, "SIG_IGN")) return (IV)SIG_IGN;
d1763 1
a1763 2
	if (strnEQ(name, "SA_", 3)) {
	    if (strEQ(name, "SA_NOCLDSTOP"))
d1765 1
a1765 1
		return SA_NOCLDSTOP;
d1767 1
a1767 1
		goto not_there;
a1768 38
	    if (strEQ(name, "SA_NOCLDWAIT"))
#ifdef SA_NOCLDWAIT
		return SA_NOCLDWAIT;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SA_NODEFER"))
#ifdef SA_NODEFER
		return SA_NODEFER;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SA_ONSTACK"))
#ifdef SA_ONSTACK
		return SA_ONSTACK;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SA_RESETHAND"))
#ifdef SA_RESETHAND
		return SA_RESETHAND;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SA_RESTART"))
#ifdef SA_RESTART
		return SA_RESTART;
#else
		goto not_there;
#endif
	    if (strEQ(name, "SA_SIGINFO"))
#ifdef SA_SIGINFO
		return SA_SIGINFO;
#else
		goto not_there;
#endif
	    break;
	}
d2030 1
a2030 1
#if defined(_PC_CHOWN_RESTRICTED) || HINT_SC_EXIST
d2036 1
a2036 1
#if defined(_PC_LINK_MAX) || HINT_SC_EXIST
d2042 1
a2042 1
#if defined(_PC_MAX_CANON) || HINT_SC_EXIST
d2048 1
a2048 1
#if defined(_PC_MAX_INPUT) || HINT_SC_EXIST
d2054 1
a2054 1
#if defined(_PC_NAME_MAX) || HINT_SC_EXIST
d2060 1
a2060 1
#if defined(_PC_NO_TRUNC) || HINT_SC_EXIST
d2066 1
a2066 1
#if defined(_PC_PATH_MAX) || HINT_SC_EXIST
d2072 1
a2072 1
#if defined(_PC_PIPE_BUF) || HINT_SC_EXIST
d2078 1
a2078 1
#if defined(_PC_VDISABLE) || HINT_SC_EXIST
d2204 1
a2204 1
#if defined(_SC_ARG_MAX) || HINT_SC_EXIST
d2210 1
a2210 1
#if defined(_SC_CHILD_MAX) || HINT_SC_EXIST
d2216 1
a2216 1
#if defined(_SC_CLK_TCK) || HINT_SC_EXIST
d2222 1
a2222 1
#if defined(_SC_JOB_CONTROL) || HINT_SC_EXIST
d2228 1
a2228 1
#if defined(_SC_NGROUPS_MAX) || HINT_SC_EXIST
d2234 1
a2234 1
#if defined(_SC_OPEN_MAX) || HINT_SC_EXIST
d2240 1
a2240 1
#if defined(_SC_SAVED_IDS) || HINT_SC_EXIST
d2246 1
a2246 1
#if defined(_SC_STREAM_MAX) || HINT_SC_EXIST
d2252 1
a2252 1
#if defined(_SC_TZNAME_MAX) || HINT_SC_EXIST
d2258 1
a2258 1
#if defined(_SC_VERSION) || HINT_SC_EXIST
d2282 1
a2282 1
	    New(0, RETVAL, 1, sigset_t);
d2294 1
a2294 1
	Safefree(sigset);
d2328 1
a2328 1
	    New(0, RETVAL, 1, struct termios);
a2330 1
        RETVAL = 0;
d2341 1
a2341 1
	Safefree(termios_ref);
d2380 1
a2380 2
     not_here("getiflag");
     RETVAL = 0;
d2392 1
a2392 2
     not_here("getoflag");
     RETVAL = 0;
d2404 1
a2404 2
     not_here("getcflag");
     RETVAL = 0;
d2416 1
a2416 2
     not_here("getlflag");
     RETVAL = 0;
d2431 1
a2431 2
     not_here("getcc");
     RETVAL = 0;
d2514 1
a2514 1
	unsigned char *	charstring
d2516 3
a2518 3
	unsigned char *s = charstring;
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
	for (RETVAL = 1; RETVAL && s < e; s++)
d2526 1
a2526 1
	unsigned char *	charstring
d2528 3
a2530 3
	unsigned char *s = charstring;
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
	for (RETVAL = 1; RETVAL && s < e; s++)
d2538 1
a2538 1
	unsigned char *	charstring
d2540 3
a2542 3
	unsigned char *s = charstring;
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
	for (RETVAL = 1; RETVAL && s < e; s++)
d2550 1
a2550 1
	unsigned char *	charstring
d2552 3
a2554 3
	unsigned char *s = charstring;
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
	for (RETVAL = 1; RETVAL && s < e; s++)
d2562 1
a2562 1
	unsigned char *	charstring
d2564 3
a2566 3
	unsigned char *s = charstring;
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
	for (RETVAL = 1; RETVAL && s < e; s++)
d2574 1
a2574 1
	unsigned char *	charstring
d2576 3
a2578 3
	unsigned char *s = charstring;
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
	for (RETVAL = 1; RETVAL && s < e; s++)
d2586 1
a2586 1
	unsigned char *	charstring
d2588 3
a2590 3
	unsigned char *s = charstring;
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
	for (RETVAL = 1; RETVAL && s < e; s++)
d2598 1
a2598 1
	unsigned char *	charstring
d2600 3
a2602 3
	unsigned char *s = charstring;
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
	for (RETVAL = 1; RETVAL && s < e; s++)
d2610 1
a2610 1
	unsigned char *	charstring
d2612 3
a2614 3
	unsigned char *s = charstring;
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
	for (RETVAL = 1; RETVAL && s < e; s++)
d2622 1
a2622 1
	unsigned char *	charstring
d2624 3
a2626 3
	unsigned char *s = charstring;
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
	for (RETVAL = 1; RETVAL && s < e; s++)
d2634 1
a2634 1
	unsigned char *	charstring
d2636 3
a2638 3
	unsigned char *s = charstring;
	unsigned char *e = s + PL_na;	/* "PL_na" set by typemap side effect */
	for (RETVAL = 1; RETVAL && s < e; s++)
a2670 1
#ifndef NO_LOCALECONV_GROUPING
a2673 1
#endif
a2682 1
#ifndef NO_LOCALECONV_MON_THOUSANDS_SEP
a2685 2
#endif                    
#ifndef NO_LOCALECONV_MON_GROUPING
a2688 1
#endif
d2728 1
a2728 1
setlocale(category, locale = 0)
a2730 58
    CODE:
	RETVAL = setlocale(category, locale);
	if (RETVAL) {
#ifdef USE_LOCALE_CTYPE
	    if (category == LC_CTYPE
#ifdef LC_ALL
		|| category == LC_ALL
#endif
		)
	    {
		char *newctype;
#ifdef LC_ALL
		if (category == LC_ALL)
		    newctype = setlocale(LC_CTYPE, NULL);
		else
#endif
		    newctype = RETVAL;
		perl_new_ctype(newctype);
	    }
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
	    if (category == LC_COLLATE
#ifdef LC_ALL
		|| category == LC_ALL
#endif
		)
	    {
		char *newcoll;
#ifdef LC_ALL
		if (category == LC_ALL)
		    newcoll = setlocale(LC_COLLATE, NULL);
		else
#endif
		    newcoll = RETVAL;
		perl_new_collate(newcoll);
	    }
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
	    if (category == LC_NUMERIC
#ifdef LC_ALL
		|| category == LC_ALL
#endif
		)
	    {
		char *newnum;
#ifdef LC_ALL
		if (category == LC_ALL)
		    newnum = setlocale(LC_NUMERIC, NULL);
		else
#endif
		    newnum = RETVAL;
		perl_new_numeric(newnum);
	    }
#endif /* USE_LOCALE_NUMERIC */
	}
    OUTPUT:
	RETVAL

d2806 1
a2806 3
#ifdef WIN32
	RETVAL = not_here("sigaction");
#else
d2810 1
a2810 1
	if (!PL_siggv)
d2818 1
a2818 1
	    SV** sigsvp = hv_fetch(GvHVn(PL_siggv),
a2821 1
	    STRLEN n_a;
d2825 1
a2825 1
		char *hand = SvPVx(*sigsvp, n_a);
d2836 1
a2836 1
		sv_setpv(*sigsvp, SvPV(*svp, n_a));
d2875 1
a2875 1
		    New(0, sigset, 1, sigset_t);
a2884 1
#endif
d2896 1
a2896 14
	POSIX::SigSet		oldsigset = NO_INIT
INIT:
	if ( items < 3 ) {
	    oldsigset = 0;
	}
	else if (sv_derived_from(ST(2), "POSIX::SigSet")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    oldsigset = (POSIX__SigSet) tmp;
	}
	else {
	    New(0, oldsigset, 1, sigset_t);
	    sigemptyset(oldsigset);
	    sv_setref_pv(ST(2), "POSIX::SigSet", (void*)oldsigset);
	}
d2934 1
a2934 1
	    EXTEND(SP,2);
d2952 2
a2953 1
            SvTAINTED_on(sv_buffer);
d2979 1
a2979 1
	    EXTEND(SP, 5);
a3035 60
void
strtod(str)
	char *		str
    PREINIT:
	double num;
	char *unparsed;
    PPCODE:
	SET_NUMERIC_LOCAL();
	num = strtod(str, &unparsed);
	PUSHs(sv_2mortal(newSVnv(num)));
	if (GIMME == G_ARRAY) {
	    EXTEND(SP, 1);
	    if (unparsed)
		PUSHs(sv_2mortal(newSViv(strlen(unparsed))));
	    else
		PUSHs(&PL_sv_undef);
	}

void
strtol(str, base = 0)
	char *		str
	int		base
    PREINIT:
	long num;
	char *unparsed;
    PPCODE:
	num = strtol(str, &unparsed, base);
	if (num >= IV_MIN && num <= IV_MAX)
	    PUSHs(sv_2mortal(newSViv((IV)num)));
	else
	    PUSHs(sv_2mortal(newSVnv((double)num)));
	if (GIMME == G_ARRAY) {
	    EXTEND(SP, 1);
	    if (unparsed)
		PUSHs(sv_2mortal(newSViv(strlen(unparsed))));
	    else
		PUSHs(&PL_sv_undef);
	}

void
strtoul(str, base = 0)
	char *		str
	int		base
    PREINIT:
	unsigned long num;
	char *unparsed;
    PPCODE:
	num = strtoul(str, &unparsed, base);
	if (num <= IV_MAX)
	    PUSHs(sv_2mortal(newSViv((IV)num)));
	else
	    PUSHs(sv_2mortal(newSVnv((double)num)));
	if (GIMME == G_ARRAY) {
	    EXTEND(SP, 1);
	    if (unparsed)
		PUSHs(sv_2mortal(newSViv(strlen(unparsed))));
	    else
		PUSHs(&PL_sv_undef);
	}

d3130 6
a3135 6
	EXTEND(SP,5);
	PUSHs( sv_2mortal( newSViv( (IV) realtime ) ) );
	PUSHs( sv_2mortal( newSViv( (IV) tms.tms_utime ) ) );
	PUSHs( sv_2mortal( newSViv( (IV) tms.tms_stime ) ) );
	PUSHs( sv_2mortal( newSViv( (IV) tms.tms_cutime ) ) );
	PUSHs( sv_2mortal( newSViv( (IV) tms.tms_cstime ) ) );
d3172 1
a3172 1
strftime(fmt, sec, min, hour, mday, mon, year, wday = -1, yday = -1, isdst = -1)
a3197 1
	    (void) mktime(&mytm);
d3199 1
a3199 37
	    /*
	    ** The following is needed to handle to the situation where 
	    ** tmpbuf overflows.  Basically we want to allocate a buffer
	    ** and try repeatedly.  The reason why it is so complicated
	    ** is that getting a return value of 0 from strftime can indicate
	    ** one of the following:
	    ** 1. buffer overflowed,
	    ** 2. illegal conversion specifier, or
	    ** 3. the format string specifies nothing to be returned(not
	    **	  an error).  This could be because format is an empty string
	    **    or it specifies %p that yields an empty string in some locale.
	    ** If there is a better way to make it portable, go ahead by
	    ** all means.
	    */
	    if ( ( len > 0 && len < sizeof(tmpbuf) )
	    		|| ( len == 0 && strlen(fmt) == 0 ) ) {
		ST(0) = sv_2mortal(newSVpv(tmpbuf, len));
	    } else {
		/* Possibly buf overflowed - try again with a bigger buf */
		int	bufsize = strlen(fmt) + sizeof(tmpbuf);
		char* 	buf;
		int	buflen;

		New(0, buf, bufsize, char);
		while( buf ) {
		    buflen = strftime(buf, bufsize, fmt, &mytm);
		    if ( buflen > 0 && buflen < bufsize ) break;
		    bufsize *= 2;
		    Renew(buf, bufsize, char);
		}
		if ( buf ) {
		    ST(0) = sv_2mortal(newSVpv(buf, buflen));
		    Safefree(buf);
		} else {
		    ST(0) = sv_2mortal(newSVpv(tmpbuf, len));
		}
	    }
d3208 1
a3208 1
	EXTEND(SP,2);
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a3 3

#define PERL_NO_GET_CONTEXT

d8 1
a8 1
#if defined(PERL_OBJECT) || defined(PERL_CAPI) || defined(PERL_IMPLICIT_SYS)
a80 1
	dTHX;
a104 3
#if defined (__CYGWIN__)
#    define tzname _tzname
#endif
d138 2
a139 6
#    ifdef OS2
#      define mkfifo(a,b) not_here("mkfifo")
#    else	/* !( defined OS2 ) */ 
#      ifndef mkfifo
#        define mkfifo(path, mode) (mknod((path), (mode) | S_IFIFO, 0))
#      endif
d180 4
a183 4
char *cuserid (char *);
double strtod (const char *, char **);
long strtol (const char *, char **, int);
unsigned long strtoul (const char *, char **, int);
d281 1
a281 1
#  if !defined(WIN32) && !defined(__CYGWIN__)
d306 1
a306 1
#    define STRUCT_TM_HASZONE
d312 2
a313 1
init_tm(struct tm *ptm)		/* see mktime, strftime and asctime	*/
a323 196
/*
 * mini_mktime - normalise struct tm values without the localtime()
 * semantics (and overhead) of mktime().
 */
static void
mini_mktime(struct tm *ptm)
{
    int yearday;
    int secs;
    int month, mday, year, jday;
    int odd_cent, odd_year;

#define	DAYS_PER_YEAR	365
#define	DAYS_PER_QYEAR	(4*DAYS_PER_YEAR+1)
#define	DAYS_PER_CENT	(25*DAYS_PER_QYEAR-1)
#define	DAYS_PER_QCENT	(4*DAYS_PER_CENT+1)
#define	SECS_PER_HOUR	(60*60)
#define	SECS_PER_DAY	(24*SECS_PER_HOUR)
/* parentheses deliberately absent on these two, otherwise they don't work */
#define	MONTH_TO_DAYS	153/5
#define	DAYS_TO_MONTH	5/153
/* offset to bias by March (month 4) 1st between month/mday & year finding */
#define	YEAR_ADJUST	(4*MONTH_TO_DAYS+1)
/* as used here, the algorithm leaves Sunday as day 1 unless we adjust it */
#define	WEEKDAY_BIAS	6	/* (1+6)%7 makes Sunday 0 again */

/*
 * Year/day algorithm notes:
 *
 * With a suitable offset for numeric value of the month, one can find
 * an offset into the year by considering months to have 30.6 (153/5) days,
 * using integer arithmetic (i.e., with truncation).  To avoid too much
 * messing about with leap days, we consider January and February to be
 * the 13th and 14th month of the previous year.  After that transformation,
 * we need the month index we use to be high by 1 from 'normal human' usage,
 * so the month index values we use run from 4 through 15.
 *
 * Given that, and the rules for the Gregorian calendar (leap years are those
 * divisible by 4 unless also divisible by 100, when they must be divisible
 * by 400 instead), we can simply calculate the number of days since some
 * arbitrary 'beginning of time' by futzing with the (adjusted) year number,
 * the days we derive from our month index, and adding in the day of the
 * month.  The value used here is not adjusted for the actual origin which
 * it normally would use (1 January A.D. 1), since we're not exposing it.
 * We're only building the value so we can turn around and get the
 * normalised values for the year, month, day-of-month, and day-of-year.
 *
 * For going backward, we need to bias the value we're using so that we find
 * the right year value.  (Basically, we don't want the contribution of
 * March 1st to the number to apply while deriving the year).  Having done
 * that, we 'count up' the contribution to the year number by accounting for
 * full quadracenturies (400-year periods) with their extra leap days, plus
 * the contribution from full centuries (to avoid counting in the lost leap
 * days), plus the contribution from full quad-years (to count in the normal
 * leap days), plus the leftover contribution from any non-leap years.
 * At this point, if we were working with an actual leap day, we'll have 0
 * days left over.  This is also true for March 1st, however.  So, we have
 * to special-case that result, and (earlier) keep track of the 'odd'
 * century and year contributions.  If we got 4 extra centuries in a qcent,
 * or 4 extra years in a qyear, then it's a leap day and we call it 29 Feb.
 * Otherwise, we add back in the earlier bias we removed (the 123 from
 * figuring in March 1st), find the month index (integer division by 30.6),
 * and the remainder is the day-of-month.  We then have to convert back to
 * 'real' months (including fixing January and February from being 14/15 in
 * the previous year to being in the proper year).  After that, to get
 * tm_yday, we work with the normalised year and get a new yearday value for
 * January 1st, which we subtract from the yearday value we had earlier,
 * representing the date we've re-built.  This is done from January 1
 * because tm_yday is 0-origin.
 *
 * Since POSIX time routines are only guaranteed to work for times since the
 * UNIX epoch (00:00:00 1 Jan 1970 UTC), the fact that this algorithm
 * applies Gregorian calendar rules even to dates before the 16th century
 * doesn't bother me.  Besides, you'd need cultural context for a given
 * date to know whether it was Julian or Gregorian calendar, and that's
 * outside the scope for this routine.  Since we convert back based on the
 * same rules we used to build the yearday, you'll only get strange results
 * for input which needed normalising, or for the 'odd' century years which
 * were leap years in the Julian calander but not in the Gregorian one.
 * I can live with that.
 *
 * This algorithm also fails to handle years before A.D. 1 gracefully, but
 * that's still outside the scope for POSIX time manipulation, so I don't
 * care.
 */

    year = 1900 + ptm->tm_year;
    month = ptm->tm_mon;
    mday = ptm->tm_mday;
    /* allow given yday with no month & mday to dominate the result */
    if (ptm->tm_yday >= 0 && mday <= 0 && month <= 0) {
	month = 0;
	mday = 0;
	jday = 1 + ptm->tm_yday;
    }
    else {
	jday = 0;
    }
    if (month >= 2)
	month+=2;
    else
	month+=14, year--;
    yearday = DAYS_PER_YEAR * year + year/4 - year/100 + year/400;
    yearday += month*MONTH_TO_DAYS + mday + jday;
    /*
     * Note that we don't know when leap-seconds were or will be,
     * so we have to trust the user if we get something which looks
     * like a sensible leap-second.  Wild values for seconds will
     * be rationalised, however.
     */
    if ((unsigned) ptm->tm_sec <= 60) {
	secs = 0;
    }
    else {
	secs = ptm->tm_sec;
	ptm->tm_sec = 0;
    }
    secs += 60 * ptm->tm_min;
    secs += SECS_PER_HOUR * ptm->tm_hour;
    if (secs < 0) {
	if (secs-(secs/SECS_PER_DAY*SECS_PER_DAY) < 0) {
	    /* got negative remainder, but need positive time */
	    /* back off an extra day to compensate */
	    yearday += (secs/SECS_PER_DAY)-1;
	    secs -= SECS_PER_DAY * (secs/SECS_PER_DAY - 1);
	}
	else {
	    yearday += (secs/SECS_PER_DAY);
	    secs -= SECS_PER_DAY * (secs/SECS_PER_DAY);
	}
    }
    else if (secs >= SECS_PER_DAY) {
	yearday += (secs/SECS_PER_DAY);
	secs %= SECS_PER_DAY;
    }
    ptm->tm_hour = secs/SECS_PER_HOUR;
    secs %= SECS_PER_HOUR;
    ptm->tm_min = secs/60;
    secs %= 60;
    ptm->tm_sec += secs;
    /* done with time of day effects */
    /*
     * The algorithm for yearday has (so far) left it high by 428.
     * To avoid mistaking a legitimate Feb 29 as Mar 1, we need to
     * bias it by 123 while trying to figure out what year it
     * really represents.  Even with this tweak, the reverse
     * translation fails for years before A.D. 0001.
     * It would still fail for Feb 29, but we catch that one below.
     */
    jday = yearday;	/* save for later fixup vis-a-vis Jan 1 */
    yearday -= YEAR_ADJUST;
    year = (yearday / DAYS_PER_QCENT) * 400;
    yearday %= DAYS_PER_QCENT;
    odd_cent = yearday / DAYS_PER_CENT;
    year += odd_cent * 100;
    yearday %= DAYS_PER_CENT;
    year += (yearday / DAYS_PER_QYEAR) * 4;
    yearday %= DAYS_PER_QYEAR;
    odd_year = yearday / DAYS_PER_YEAR;
    year += odd_year;
    yearday %= DAYS_PER_YEAR;
    if (!yearday && (odd_cent==4 || odd_year==4)) { /* catch Feb 29 */
	month = 1;
	yearday = 29;
    }
    else {
	yearday += YEAR_ADJUST;	/* recover March 1st crock */
	month = yearday*DAYS_TO_MONTH;
	yearday -= month*MONTH_TO_DAYS;
	/* recover other leap-year adjustment */
	if (month > 13) {
	    month-=14;
	    year++;
	}
	else {
	    month-=2;
	}
    }
    ptm->tm_year = year - 1900;
    if (yearday) {
      ptm->tm_mday = yearday;
      ptm->tm_mon = month;
    }
    else {
      ptm->tm_mday = 31;
      ptm->tm_mon = month - 1;
    }
    /* re-build yearday based on Jan 1 to get tm_yday */
    year--;
    yearday = year*DAYS_PER_YEAR + year/4 - year/100 + year/400;
    yearday += 14*MONTH_TO_DAYS + 1;
    ptm->tm_yday = jday - yearday;
    /* fix tm_wday if not overridden by caller */
    if ((unsigned)ptm->tm_wday > 6)
	ptm->tm_wday = (jday + WEEKDAY_BIAS) % 7;
}
d351 1
a351 1
#if defined(HAS_LONG_DOUBLE) && (LONG_DOUBLESIZE > DOUBLESIZE)
d1522 3
a1524 4
	    /* L_tmpnam[e] was a typo--retained for compatibility */
	    if (strEQ(name, "L_tmpname") || strEQ(name, "L_tmpnam"))
#ifdef L_tmpnam
		return L_tmpnam;
d3048 1
a3048 1
		new_ctype(newctype);
d3065 1
a3065 1
		new_collate(newcoll);
d3082 1
a3082 1
		new_numeric(newnum);
d3170 3
a3173 1
	    GV *siggv = gv_fetchpv("SIG", TRUE, SVt_PVHV);
d3178 3
a3180 3
	    SV** sigsvp = hv_fetch(GvHVn(siggv),
				 PL_sig_name[sig],
				 strlen(PL_sig_name[sig]),
d3199 1
a3199 1
		act.sa_handler = PL_sighandlerp;
d3265 1
a3265 1
	    oldsigset = INT2PTR(POSIX__SigSet,tmp);
d3370 3
a3372 12
SV *
tmpnam()
    PREINIT:
	STRLEN i;
	int len;
    CODE:
	RETVAL = newSVpvn("", 0);
	SvGROW(RETVAL, L_tmpnam);
	len = strlen(tmpnam(SvPV(RETVAL, i)));
	SvCUR_set(RETVAL, len);
    OUTPUT:
	RETVAL
d3437 3
a3439 2
#if IVSIZE <= LONGSIZE
	if (num < IV_MIN || num > IV_MAX)
a3440 3
	else
#endif
	    PUSHs(sv_2mortal(newSViv((IV)num)));
d3632 1
a3632 1
	    mini_mktime(&mytm);
d3648 2
a3649 1
	    if ((len > 0 && len < sizeof(tmpbuf)) || (len == 0 && *fmt == '\0'))
d3651 1
a3651 1
            else {
d3653 1
a3653 2
                int     fmtlen = strlen(fmt);
		int	bufsize = fmtlen + sizeof(tmpbuf);
d3658 1
a3658 1
		while (buf) {
d3660 1
a3660 8
		    if (buflen > 0 && buflen < bufsize)
                        break;
                    /* heuristic to prevent out-of-memory errors */
                    if (bufsize > 100*fmtlen) {
                        Safefree(buf);
                        buf = NULL;
                        break;
                    }
d3664 2
a3665 2
		if (buf) {
		    ST(0) = sv_2mortal(newSVpvn(buf, buflen));
d3667 2
a3669 2
                else
		    ST(0) = sv_2mortal(newSVpvn(tmpbuf, len));
d3680 2
a3681 2
	PUSHs(sv_2mortal(newSVpvn(tzname[0],strlen(tzname[0]))));
	PUSHs(sv_2mortal(newSVpvn(tzname[1],strlen(tzname[1]))));
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a57 3
#ifdef MACOS_TRADITIONAL
#undef fdopen
#endif
d83 1
a83 1
   clock_t vms_times(struct tms *bufptr) {
d104 1
a104 1
	times((tbuffer_t *)bufptr);
a141 2
#  define setuid(a)		not_here("setuid")
#  define setgid(a)		not_here("setgid")
d145 1
a145 1
#    if defined(OS2) || defined(MACOS_TRADITIONAL)
d154 4
a157 10
#  ifdef MACOS_TRADITIONAL
#    define ttyname(a) (char*)not_here("ttyname")
#    define tzset() not_here("tzset")
#  else
#    include <grp.h>
#    include <sys/times.h>
#    ifdef HAS_UNAME
#      include <sys/utsname.h>
#    endif
#    include <sys/wait.h>
d159 1
d532 1
a532 1
#  if LONG_DOUBLESIZE > NVSIZE
d537 1
a537 1
#ifndef HAS_LONG_DOUBLE
d557 5
a561 1
NV
a1519 5
#if defined(USE_LONG_DOUBLE) && defined(HUGE_VALL)
	  /* HUGE_VALL is admittedly non-POSIX but if we are using long doubles
	   * we might as well use long doubles. --jhi */
	    return HUGE_VALL;
#endif
d2294 3
a2296 3
	if (strEQ(name, "STDERR_FILENO"))
#ifdef STDERR_FILENO
	    return STDERR_FILENO;
d3008 1
a3008 1
NV
d3164 1
a3164 1
	if ((lcbuf = localeconv())) {
d3297 1
a3297 1
NV
d3299 1
a3299 1
	NV		x
d3301 1
a3301 1
NV
d3303 1
a3303 1
	NV		x
d3305 1
a3305 1
NV
d3307 1
a3307 1
	NV		x
d3309 1
a3309 1
NV
d3311 1
a3311 1
	NV		x
d3313 1
a3313 1
NV
d3315 1
a3315 1
	NV		x
d3317 1
a3317 1
NV
d3319 1
a3319 1
	NV		x
d3321 1
a3321 1
NV
d3323 2
a3324 2
	NV		x
	NV		y
d3328 1
a3328 1
	NV		x
d3335 1
a3335 1
NV
d3337 1
a3337 1
	NV		x
d3340 1
a3340 1
NV
d3342 1
a3342 1
	NV		x
d3346 1
a3346 1
	NV		x
d3348 1
a3348 1
	NV intvar;
d3350 1
a3350 1
	PUSHs(sv_2mortal(newSVnv(Perl_modf(x,&intvar))));
d3353 1
a3353 1
NV
d3355 1
a3355 1
	NV		x
d3357 1
a3357 1
NV
d3359 1
a3359 1
	NV		x
d3361 1
a3361 1
NV
d3363 1
a3363 1
	NV		x
d3409 3
a3411 2
		    IV tmp = SvIV((SV*)SvRV(*svp));
		    sigset =  INT2PTR(sigset_t*, tmp);
d3436 3
a3438 2
		    IV tmp = SvIV((SV*)SvRV(*svp));
		    sigset = INT2PTR(sigset_t*, tmp);
d3509 1
a3509 1
void
d3552 1
a3552 1
void
d3686 1
a3686 1
void
d3821 1
a3821 4
#XXX: if $xsubpp::WantOptimize is always the default
#     sv_setpv(TARG, ...) could be used rather than
#     ST(0) = sv_2mortal(newSVpv(...))
void
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d1 3
a3 12
#define PERL_EXT_POSIX

#ifdef NETWARE
	#define _POSIX_
	/*
	 * Ideally this should be somewhere down in the includes
	 * but putting it in other places is giving compiler errors.
	 * Also here I am unable to check for HAS_UNAME since it wouldn't have
	 * yet come into the file at this stage - sgp 18th Oct 2000
	 */
	#include <sys/utsname.h>
#endif	/* NETWARE */
d11 1
a11 1
#if defined(PERL_IMPLICIT_SYS)
a40 4
#ifdef I_UNISTD
#include <unistd.h>
#endif

a62 10
#ifdef HAS_TZNAME
#  if !defined(WIN32) && !defined(__CYGWIN__) && !defined(NETWARE)
extern char *tzname[];
#  endif
#else
#if !defined(WIN32) || (defined(__MINGW32__) && !defined(tzname))
char *tzname[] = { "" , "" };
#endif
#endif

d115 1
a115 1
#if defined (WIN32) || defined (NETWARE)
a144 3
#ifndef NETWARE
#  undef setuid
#  undef setgid
a146 1
#endif	/* NETWARE */
d173 1
a173 1
#endif /* WIN32 || NETWARE */
d182 2302
a2483 16
#else /* Define termios types to int, and call not_here for the functions.*/
#define POSIX__Termios int
#define speed_t int
#define tcflag_t int
#define cc_t int
#define cfgetispeed(x) not_here("cfgetispeed")
#define cfgetospeed(x) not_here("cfgetospeed")
#define tcdrain(x) not_here("tcdrain")
#define tcflush(x,y) not_here("tcflush")
#define tcsendbreak(x,y) not_here("tcsendbreak")
#define cfsetispeed(x,y) not_here("cfsetispeed")
#define cfsetospeed(x,y) not_here("cfsetospeed")
#define ctermid(x) (char *) not_here("ctermid")
#define tcflow(x,y) not_here("tcflow")
#define tcgetattr(x,y) not_here("tcgetattr")
#define tcsetattr(x,y,z) not_here("tcsetattr")
d2485 7
a2491 7

/* Possibly needed prototypes */
char *cuserid (char *);
#ifndef WIN32
double strtod (const char *, char **);
long strtol (const char *, char **, int);
unsigned long strtoul (const char *, char **, int);
d2493 5
a2497 3

#ifndef HAS_CUSERID
#define cuserid(a) (char *) not_here("cuserid")
d2499 5
a2503 3
#ifndef HAS_DIFFTIME
#ifndef difftime
#define difftime(a,b) not_here("difftime")
d2505 3
d2509 2
a2510 2
#ifndef HAS_FPATHCONF
#define fpathconf(f,n) 	(SysRetLong) not_here("fpathconf")
d2512 2
a2513 2
#ifndef HAS_MKTIME
#define mktime(a) not_here("mktime")
d2515 2
a2516 2
#ifndef HAS_NICE
#define nice(a) not_here("nice")
d2518 2
a2519 2
#ifndef HAS_PATHCONF
#define pathconf(f,n) 	(SysRetLong) not_here("pathconf")
d2521 2
a2522 2
#ifndef HAS_SYSCONF
#define sysconf(n) 	(SysRetLong) not_here("sysconf")
d2524 7
a2530 2
#ifndef HAS_READLINK
#define readlink(a,b,c) not_here("readlink")
d2532 8
a2539 2
#ifndef HAS_SETPGID
#define setpgid(a,b) not_here("setpgid")
d2541 5
a2545 2
#ifndef HAS_SETSID
#define setsid() not_here("setsid")
d2547 5
a2551 2
#ifndef HAS_STRCOLL
#define strcoll(s1,s2) not_here("strcoll")
d2553 5
a2557 2
#ifndef HAS_STRTOD
#define strtod(s1,s2) not_here("strtod")
d2559 5
a2563 2
#ifndef HAS_STRTOL
#define strtol(s1,s2,b) not_here("strtol")
d2565 5
a2569 2
#ifndef HAS_STRTOUL
#define strtoul(s1,s2,b) not_here("strtoul")
d2571 5
a2575 2
#ifndef HAS_STRXFRM
#define strxfrm(s1,s2,n) not_here("strxfrm")
d2577 5
a2581 2
#ifndef HAS_TCGETPGRP
#define tcgetpgrp(a) not_here("tcgetpgrp")
d2583 5
a2587 2
#ifndef HAS_TCSETPGRP
#define tcsetpgrp(a,b) not_here("tcsetpgrp")
d2589 8
a2596 4
#ifndef HAS_TIMES
#ifndef NETWARE
#define times(a) not_here("times")
#endif	/* NETWARE */
d2598 5
a2602 2
#ifndef HAS_UNAME
#define uname(a) not_here("uname")
d2604 5
a2608 2
#ifndef HAS_WAITPID
#define waitpid(a,b,c) not_here("waitpid")
d2610 5
a2614 4

#ifndef HAS_MBLEN
#ifndef mblen
#define mblen(a,b) not_here("mblen")
d2616 5
d2622 5
a2626 2
#ifndef HAS_MBSTOWCS
#define mbstowcs(s, pwcs, n) not_here("mbstowcs")
d2628 5
a2632 2
#ifndef HAS_MBTOWC
#define mbtowc(pwc, s, n) not_here("mbtowc")
d2634 5
a2638 2
#ifndef HAS_WCSTOMBS
#define wcstombs(s, pwcs, n) not_here("wcstombs")
d2640 5
a2644 2
#ifndef HAS_WCTOMB
#define wctomb(s, wchar) not_here("wcstombs")
d2646 5
a2650 8
#if !defined(HAS_MBLEN) && !defined(HAS_MBSTOWCS) && !defined(HAS_MBTOWC) && !defined(HAS_WCSTOMBS) && !defined(HAS_WCTOMB)
/* If we don't have these functions, then we wouldn't have gotten a typedef
   for wchar_t, the wide character type.  Defining wchar_t allows the
   functions referencing it to compile.  Its actual type is then meaningless,
   since without the above functions, all sections using it end up calling
   not_here() and croak.  --Kaveh Ghazi (ghazi@@noc.rutgers.edu) 9/18/94. */
#ifndef wchar_t
#define wchar_t char
d2652 5
d2658 5
a2662 3

#ifndef HAS_LOCALECONV
#define localeconv() not_here("localeconv")
d2664 5
a2668 5

#ifdef HAS_LONG_DOUBLE
#  if LONG_DOUBLESIZE > NVSIZE
#    undef HAS_LONG_DOUBLE  /* XXX until we figure out how to use them */
#  endif
d2670 5
a2674 4

#ifndef HAS_LONG_DOUBLE
#ifdef LDBL_MAX
#undef LDBL_MAX
d2676 5
a2680 2
#ifdef LDBL_MIN
#undef LDBL_MIN
d2682 5
a2686 2
#ifdef LDBL_EPSILON
#undef LDBL_EPSILON
d2688 5
d2694 3
a2696 11

/* Background: in most systems the low byte of the wait status
 * is the signal (the lowest 7 bits) and the coredump flag is
 * the eight bit, and the second lowest byte is the exit status.
 * BeOS bucks the trend and has the bytes in different order.
 * See beos/beos.c for how the reality is bent even in BeOS
 * to follow the traditional.  However, to make the POSIX
 * wait W*() macros to work in BeOS, we need to unbend the
 * reality back in place. --jhi */
#ifdef __BEOS__
#    define WMUNGE(x) (((x) & 0xFF00) >> 8 | ((x) & 0x00FF) << 8)
d2698 1
a2698 1
#    define WMUNGE(x) (x)
d2700 3
a2702 44

static int
not_here(char *s)
{
    croak("POSIX::%s not implemented on this architecture", s);
    return -1;
}

#include "const-c.inc"

/* These were implemented in the old "constant" subroutine. They are actually
   macros that take an integer argument and return an integer result.  */
static int
int_macro_int (const char *name, STRLEN len, IV *arg_result) {
  /* Initially switch on the length of the name.  */
  /* This code has been edited from a "constant" function generated by:

use ExtUtils::Constant qw (constant_types C_constant XS_constant);

my $types = {map {($_, 1)} qw(IV)};
my @@names = (qw(S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG WEXITSTATUS WIFEXITED
	       WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG));

print constant_types(); # macro defs
foreach (C_constant ("POSIX", 'int_macro_int', 'IV', $types, undef, 5, @@names) ) {
    print $_, "\n"; # C constant subs
}
print "#### XS Section:\n";
print XS_constant ("POSIX", $types);
__END__
   */

  switch (len) {
  case 7:
    /* Names all of length 7.  */
    /* S_ISBLK S_ISCHR S_ISDIR S_ISREG */
    /* Offset 5 gives the best switch position.  */
    switch (name[5]) {
    case 'E':
      if (memEQ(name, "S_ISREG", 7)) {
      /*                    ^       */
#ifdef S_ISREG
        *arg_result = S_ISREG(*arg_result);
        return PERL_constant_ISIV;
d2704 1
a2704 1
        return PERL_constant_NOTDEF;
d2706 6
a2711 8
      }
      break;
    case 'H':
      if (memEQ(name, "S_ISCHR", 7)) {
      /*                    ^       */
#ifdef S_ISCHR
        *arg_result = S_ISCHR(*arg_result);
        return PERL_constant_ISIV;
d2713 1
a2713 1
        return PERL_constant_NOTDEF;
d2715 3
a2717 8
      }
      break;
    case 'I':
      if (memEQ(name, "S_ISDIR", 7)) {
      /*                    ^       */
#ifdef S_ISDIR
        *arg_result = S_ISDIR(*arg_result);
        return PERL_constant_ISIV;
d2719 1
a2719 1
        return PERL_constant_NOTDEF;
d2721 3
a2723 8
      }
      break;
    case 'L':
      if (memEQ(name, "S_ISBLK", 7)) {
      /*                    ^       */
#ifdef S_ISBLK
        *arg_result = S_ISBLK(*arg_result);
        return PERL_constant_ISIV;
d2725 1
a2725 1
        return PERL_constant_NOTDEF;
d2727 3
a2729 16
      }
      break;
    }
    break;
  case 8:
    /* Names all of length 8.  */
    /* S_ISFIFO WSTOPSIG WTERMSIG */
    /* Offset 3 gives the best switch position.  */
    switch (name[3]) {
    case 'O':
      if (memEQ(name, "WSTOPSIG", 8)) {
      /*                  ^          */
#ifdef WSTOPSIG
        int i = *arg_result;
        *arg_result = WSTOPSIG(WMUNGE(i));
        return PERL_constant_ISIV;
d2731 1
a2731 1
        return PERL_constant_NOTDEF;
d2733 3
a2735 9
      }
      break;
    case 'R':
      if (memEQ(name, "WTERMSIG", 8)) {
      /*                  ^          */
#ifdef WTERMSIG
        int i = *arg_result;
        *arg_result = WTERMSIG(WMUNGE(i));
        return PERL_constant_ISIV;
d2737 1
a2737 1
        return PERL_constant_NOTDEF;
d2739 3
a2741 8
      }
      break;
    case 'S':
      if (memEQ(name, "S_ISFIFO", 8)) {
      /*                  ^          */
#ifdef S_ISFIFO
        *arg_result = S_ISFIFO(*arg_result);
        return PERL_constant_ISIV;
d2743 1
a2743 1
        return PERL_constant_NOTDEF;
d2745 3
a2747 10
      }
      break;
    }
    break;
  case 9:
    if (memEQ(name, "WIFEXITED", 9)) {
#ifdef WIFEXITED
      int i = *arg_result;
      *arg_result = WIFEXITED(WMUNGE(i));
      return PERL_constant_ISIV;
d2749 1
a2749 1
      return PERL_constant_NOTDEF;
d2751 3
a2753 8
    }
    break;
  case 10:
    if (memEQ(name, "WIFSTOPPED", 10)) {
#ifdef WIFSTOPPED
      int i = *arg_result;
      *arg_result = WIFSTOPPED(WMUNGE(i));
      return PERL_constant_ISIV;
d2755 1
a2755 1
      return PERL_constant_NOTDEF;
d2757 3
a2759 14
    }
    break;
  case 11:
    /* Names all of length 11.  */
    /* WEXITSTATUS WIFSIGNALED */
    /* Offset 1 gives the best switch position.  */
    switch (name[1]) {
    case 'E':
      if (memEQ(name, "WEXITSTATUS", 11)) {
      /*                ^                */
#ifdef WEXITSTATUS
	int i = *arg_result;
        *arg_result = WEXITSTATUS(WMUNGE(i));
        return PERL_constant_ISIV;
d2761 1
a2761 1
        return PERL_constant_NOTDEF;
d2763 3
a2765 9
      }
      break;
    case 'I':
      if (memEQ(name, "WIFSIGNALED", 11)) {
      /*                ^                */
#ifdef WIFSIGNALED
	int i = *arg_result;
        *arg_result = WIFSIGNALED(WMUNGE(i));
        return PERL_constant_ISIV;
d2767 1
a2767 1
        return PERL_constant_NOTDEF;
d2769 2
a2770 2
      }
      break;
d2772 2
a2773 4
    break;
  }
  return PERL_constant_NOTFOUND;
}
d2775 3
a2777 10
static void
restore_sigmask(pTHX_ SV *osset_sv)
{
     /* Fortunately, restoring the signal mask can't fail, because
      * there's nothing we can do about it if it does -- we're not
      * supposed to return -1 from sigaction unless the disposition
      * was unaffected.
      */
     sigset_t *ossetp = (sigset_t *) SvPV_nolen( osset_sv );
     (void)sigprocmask(SIG_SETMASK, ossetp, (sigset_t *)0);
d3019 4
a3022 43
INCLUDE: const-xs.inc

void
int_macro_int(sv, iv)
    PREINIT:
	dXSTARG;
	STRLEN		len;
        int		type;
    INPUT:
	SV *		sv;
        const char *	s = SvPV(sv, len);
	IV		iv;
    PPCODE:
        /* Change this to int_macro_int(s, len, &iv, &nv);
           if you need to return both NVs and IVs */
	type = int_macro_int(s, len, &iv);
      /* Return 1 or 2 items. First is error message, or undef if no error.
           Second, if present, is found value */
        switch (type) {
        case PERL_constant_NOTFOUND:
          sv = sv_2mortal(newSVpvf("%s is not a valid POSIX macro", s));
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
          break;
        case PERL_constant_NOTDEF:
          sv = sv_2mortal(newSVpvf(
	    "Your vendor has not defined POSIX macro %s, used", s));
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
          break;
        case PERL_constant_ISIV:
          PUSHi(iv);
          break;
        default:
          sv = sv_2mortal(newSVpvf(
	    "Unexpected return type %d while processing POSIX macro %s, used",
               type, s));
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
        }
d3377 1
a3377 1
sigaction(sig, optaction, oldaction = 0)
d3379 1
a3379 1
	SV *			optaction
d3382 1
a3382 1
#if defined(WIN32) || defined(NETWARE)
a3388 1
	    POSIX__SigAction action;
a3391 3
	    sigset_t sset;
	    SV *osset_sv;
	    sigset_t osset;
d3398 1
d3400 1
a3400 29
	    /* Check optaction and set action */
	    if(SvTRUE(optaction)) {
		if(sv_isa(optaction, "POSIX::SigAction"))
			action = (HV*)SvRV(optaction);
		else
			croak("action is not of type POSIX::SigAction");
	    }
	    else {
		action=0;
	    }

	    /* sigaction() is supposed to look atomic. In particular, any
	     * signal handler invoked during a sigaction() call should
	     * see either the old or the new disposition, and not something
	     * in between. We use sigprocmask() to make it so.
	     */
	    sigfillset(&sset);
	    RETVAL=sigprocmask(SIG_BLOCK, &sset, &osset);
	    if(RETVAL == -1)
               XSRETURN_UNDEF;
	    ENTER;
	    /* Restore signal mask no matter how we exit this block. */
	    osset_sv = newSVpv((char *)(&osset), sizeof(sigset_t));
	    SAVEFREESV( osset_sv );
	    SAVEDESTRUCTOR_X(restore_sigmask, osset_sv);

	    RETVAL=-1; /* In case both oldaction and action are 0. */

	    /* Remember old disposition if desired. */
d3402 1
d3404 1
a3404 26
		if(!svp)
		    croak("Can't supply an oldaction without a HANDLER");
		if(SvTRUE(*sigsvp)) { /* TBD: what if "0"? */
			sv_setsv(*svp, *sigsvp);
		}
		else {
			sv_setpv(*svp, "DEFAULT");
		}
		RETVAL = sigaction(sig, (struct sigaction *)0, & oact);
		if(RETVAL == -1)
                   XSRETURN_UNDEF;
		/* Get back the mask. */
		svp = hv_fetch(oldaction, "MASK", 4, TRUE);
		if (sv_isa(*svp, "POSIX::SigSet")) {
		    IV tmp = SvIV((SV*)SvRV(*svp));
		    sigset = INT2PTR(sigset_t*, tmp);
		}
		else {
		    New(0, sigset, 1, sigset_t);
		    sv_setptrobj(*svp, sigset, "POSIX::SigSet");
		}
		*sigset = oact.sa_mask;

		/* Get back the flags. */
		svp = hv_fetch(oldaction, "FLAGS", 5, TRUE);
		sv_setiv(*svp, oact.sa_flags);
d3413 1
a3413 1
		sv_setsv(*sigsvp, *svp);
d3415 1
a3415 15
		if(SvPOK(*svp)) {
			char *s=SvPVX(*svp);
			if(strEQ(s,"IGNORE")) {
				act.sa_handler = SIG_IGN;
			}
			else if(strEQ(s,"DEFAULT")) {
				act.sa_handler = SIG_DFL;
			}
			else {
				act.sa_handler = PL_sighandlerp;
			}
		}
		else {
			act.sa_handler = PL_sighandlerp;
		}
d3421 1
a3421 1
		    sigset = INT2PTR(sigset_t*, tmp);
d3430 1
d3432 4
a3435 5
		/* Don't worry about cleaning up *sigsvp if this fails,
		 * because that means we tried to disposition a
		 * nonblockable signal, in which case *sigsvp is
		 * essentially meaningless anyway.
		 */
d3437 21
a3457 2
               if(RETVAL == -1)
                   XSRETURN_UNDEF;
a3458 2

	    LEAVE;
d3704 1
a3704 1
          ST(0) = sv_2mortal(NEWSV(800,srclen*4+1));
d3847 58
a3904 4
	    char *buf = my_strftime(fmt, sec, min, hour, mday, mon, year, wday, yday, isdst);
	    if (buf) {
		ST(0) = sv_2mortal(newSVpv(buf, 0));
		Safefree(buf);
a3943 8
SysRet
setgid(gid)
	Gid_t		gid

SysRet
setuid(uid)
	Uid_t		uid

a3950 10

void
getcwd()
    PPCODE:
      {
	dXSTARG;
	getcwd_sv(TARG);
	XSprePUSH; PUSHTARG;
      }

@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@a63 1
#ifndef __ultrix__
a64 1
#endif
d77 1
a77 1
#  if !defined(WIN32) && !defined(__CYGWIN__) && !defined(NETWARE) && !defined(__UWIN__)
d81 1
a81 1
#if !defined(WIN32) && !defined(__UWIN__) || (defined(__MINGW32__) && !defined(tzname))
d846 1
a846 1
	unsigned char *e = s + SvCUR(ST(0));
d858 1
a858 1
	unsigned char *e = s + SvCUR(ST(0));
d870 1
a870 1
	unsigned char *e = s + SvCUR(ST(0));
d882 1
a882 1
	unsigned char *e = s + SvCUR(ST(0));
d894 1
a894 1
	unsigned char *e = s + SvCUR(ST(0));
d906 1
a906 1
	unsigned char *e = s + SvCUR(ST(0));
d918 1
a918 1
	unsigned char *e = s + SvCUR(ST(0));
d930 1
a930 1
	unsigned char *e = s + SvCUR(ST(0));
d942 1
a942 1
	unsigned char *e = s + SvCUR(ST(0));
d954 1
a954 1
	unsigned char *e = s + SvCUR(ST(0));
d966 1
a966 1
	unsigned char *e = s + SvCUR(ST(0));
d1215 4
a1218 20
	    SV** sigsvp;
	    if (sig == 0 && SvPOK(ST(0))) {
	        char *s = SvPVX(ST(0));
		int i = whichsig(s);

	        if (i < 0 && memEQ(s, "SIG", 3))
		    i = whichsig(s + 3);
	        if (i < 0) {
	            if (ckWARN(WARN_SIGNAL))
		        Perl_warner(aTHX_ packWARN(WARN_SIGNAL),
                                    "No such signal: SIG%s", s);
	            XSRETURN_UNDEF;
		}
	        else
		    sig = i;
            }
	    sigsvp = hv_fetch(GvHVn(siggv),
			      PL_sig_name[sig],
			      strlen(PL_sig_name[sig]),
			      TRUE);
a1276 4

		/* Get back whether the old handler used safe signals. */
		svp = hv_fetch(oldaction, "SAFE", 4, TRUE);
		sv_setiv(*svp, oact.sa_handler == PL_csighandlerp);
d1280 2
a1281 9
		/* Safe signals use "csighandler", which vectors through the
		   PL_sighandlerp pointer when it's safe to do so.
		   (BTW, "csighandler" is very different from "sighandler".) */
		svp = hv_fetch(action, "SAFE", 4, FALSE);
		act.sa_handler = (*svp && SvTRUE(*svp))
				 ? PL_csighandlerp : PL_sighandlerp;

		/* Vector new Perl handler through %SIG.
		   (The core signal handlers read %SIG to dispatch.) */
d1286 1
a1286 8

		/* This call actually calls sigaction() with almost the
		   right settings, including appropriate interpretation
		   of DEFAULT and IGNORE.  However, why are we doing
		   this when we're about to do it again just below?  XXX */
		mg_set(*sigsvp);

		/* And here again we duplicate -- DEFAULT/IGNORE checking. */
d1295 6
d1377 1
a1377 1
SV *
a1381 6
    CODE:
	Off_t pos = PerlLIO_lseek(fd, offset, whence);
	RETVAL = sizeof(Off_t) > sizeof(IV)
		 ? newSVnv((NV)pos) : newSViv((IV)pos);
    OUTPUT:
	RETVAL
d1383 1
a1383 1
void
a1385 8
    PPCODE:
	errno = 0;
	if ((incr = nice(incr)) != -1 || errno == 0) {
	    if (incr == 0)
		XPUSHs(sv_2mortal(newSVpvn("0 but true", 10)));
	    else
		XPUSHs(sv_2mortal(newSViv(incr)));
	}
d1552 3
a1554 2
#if IVSIZE <= LONGSIZE
	if (num > IV_MAX)
a1555 3
	else
#endif
	    PUSHs(sv_2mortal(newSViv((IV)num)));
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d845 1
a845 3
	SV *	charstring
    PREINIT:
	STRLEN	len;
d847 2
a848 2
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
d857 1
a857 3
	SV *	charstring
    PREINIT:
	STRLEN	len;
d859 2
a860 2
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
d869 1
a869 3
	SV *	charstring
    PREINIT:
	STRLEN	len;
d871 2
a872 2
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
d881 1
a881 3
	SV *	charstring
    PREINIT:
	STRLEN	len;
d883 2
a884 2
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
d893 1
a893 3
	SV *	charstring
    PREINIT:
	STRLEN	len;
d895 2
a896 2
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
d905 1
a905 3
	SV *	charstring
    PREINIT:
	STRLEN	len;
d907 2
a908 2
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
d917 1
a917 3
	SV *	charstring
    PREINIT:
	STRLEN	len;
d919 2
a920 2
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
d929 1
a929 3
	SV *	charstring
    PREINIT:
	STRLEN	len;
d931 2
a932 2
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
d941 1
a941 3
	SV *	charstring
    PREINIT:
	STRLEN	len;
d943 2
a944 2
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
d953 1
a953 3
	SV *	charstring
    PREINIT:
	STRLEN	len;
d955 2
a956 2
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
d965 1
a965 3
	SV *	charstring
    PREINIT:
	STRLEN	len;
d967 2
a968 2
	unsigned char *s = (unsigned char *) SvPV(charstring, len);
	unsigned char *e = s + len;
a1807 7
    CLEANUP:
#ifndef WIN32
	if (RETVAL >= 0) {
	    PL_gid  = getgid();
	    PL_egid = getegid();
	}
#endif
a1811 7
    CLEANUP:
#ifndef WIN32
	if (RETVAL >= 0) {
	    PL_uid  = getuid();
	    PL_euid = geteuid();
	}
#endif
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@a1015 1
	sv_2mortal((SV*)RETVAL);
d1808 1
a1808 12
	char *          s = 0;
    CODE:
#ifdef HAS_CTERMID_R
	s = safemalloc((size_t) L_ctermid);
#endif
	RETVAL = ctermid(s);
    OUTPUT:
	RETVAL
    CLEANUP:
#ifdef HAS_CTERMID_R
	Safefree(s);
#endif
a1865 15
SysRet
lchown(uid, gid, path)
       Uid_t           uid
       Gid_t           gid
       char *          path
    CODE:
#ifdef HAS_LCHOWN
       /* yes, the order of arguments is different,
        * but consistent with CORE::chown() */
       RETVAL = lchown(path, uid, gid);
#else
       RETVAL = not_here("lchown");
#endif
    OUTPUT:
       RETVAL
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@d1393 1
a1393 1
	POSIX::SigSet		sigset = NO_INIT
d1396 2
a1397 7
	if (! SvOK(ST(1))) {
	    sigset = NULL;
	} else if (sv_isa(ST(1), "POSIX::SigSet")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    sigset = INT2PTR(POSIX__SigSet,tmp);
	} else {
	    croak("sigset is not of type POSIX::SigSet");
d1399 1
a1399 4

	if (items < 3 || ! SvOK(ST(2))) {
	    oldsigset = NULL;
	} else if (sv_isa(ST(2), "POSIX::SigSet")) {
d1402 5
a1406 2
	} else {
	    croak("oldsigset is not of type POSIX::SigSet");
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@a87 20
#ifndef PERL_UNUSED_DECL
#  ifdef HASATTRIBUTE
#    if (defined(__GNUC__) && defined(__cplusplus)) || defined(__INTEL_COMPILER)
#      define PERL_UNUSED_DECL
#    else
#      define PERL_UNUSED_DECL __attribute__((unused))
#    endif
#  else
#    define PERL_UNUSED_DECL
#  endif
#endif

#ifndef dNOOP
#define dNOOP extern int Perl___notused PERL_UNUSED_DECL
#endif

#ifndef dVAR
#define dVAR dNOOP
#endif

d394 1
d568 1
a568 1
	    Newx(RETVAL, 1, sigset_t);
d614 1
a614 1
	    Newx(RETVAL, 1, struct termios);
d1242 2
a1243 2
	        const char *s = SvPVX_const(ST(0));
		int i = whichsig((char *)s);
d1246 1
a1246 1
		    i = whichsig((char *)s + 3);
d1310 1
a1310 1
		    Newx(sigset, 1, sigset_t);
d1321 1
a1321 3
		sv_setiv(*svp,
		/* compare incompatible pointers by casting to integer */
		    PTR2nat(oact.sa_handler) == PTR2nat(PL_csighandlerp));
d1329 2
a1330 6
		act.sa_handler =
			DPTR2FPTR(
			    void (*)(),
			    (*svp && SvTRUE(*svp))
				? PL_csighandlerp : PL_sighandlerp
			);
d1347 1
a1347 1
			const char *s=SvPVX_const(*svp);
d1376 2
a1377 2
		if(RETVAL == -1)
		    XSRETURN_UNDEF;
d1479 1
a1479 1
            SvCUR_set(sv_buffer, RETVAL);
d1655 1
a1655 1
          SvCUR_set(ST(0), dstlen);
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d54 1
a54 1
/* XXX This comment is just to make I_TERMIO and I_SGTTY visible to
d201 1
a201 1
#    else	/* !( defined OS2 ) */
d212 1
a212 3
#    ifdef I_GRP
#      include <grp.h>
#    endif
d266 1
a266 1
#define fpathconf(f,n)	(SysRetLong) not_here("fpathconf")
d275 1
a275 1
#define pathconf(f,n)	(SysRetLong) not_here("pathconf")
d278 1
a278 1
#define sysconf(n)	(SysRetLong) not_here("sysconf")
d624 1
d734 1
a734 1
	unsigned int	ccix
d804 1
a804 1
	unsigned int	ccix
d1062 1
a1062 1
#endif
a1109 2
    PREINIT:
	char *		retval;
d1111 2
a1112 5
	retval = setlocale(category, locale);
	if (retval) {
	    /* Save retval since subsequent setlocale() calls
	     * may overwrite it. */
	    RETVAL = savepv(retval);
a1164 2
	else
	    RETVAL = NULL;
d1167 1
a1167 3
    CLEANUP:
        if (RETVAL)
	    Safefree(RETVAL);
a1249 1
	    dVAR;
a1259 5

            if (sig < 0) {
                croak("Negative signals are not allowed");
            }

d1262 1
a1262 1
		int i = whichsig(s);
d1265 1
a1265 1
		    i = whichsig(s + 3);
a1274 7
#ifdef NSIG
	    if (sig > NSIG) { /* NSIG - 1 is still okay. */
	        Perl_warner(aTHX_ packWARN(WARN_SIGNAL),
                            "No such signal: %d", sig);
	        XSRETURN_UNDEF;
	    }
#endif
d1310 1
a1310 1
		svp = hv_fetchs(oldaction, "HANDLER", TRUE);
d1323 1
a1323 1
		svp = hv_fetchs(oldaction, "MASK", TRUE);
d1335 1
a1335 1
		svp = hv_fetchs(oldaction, "FLAGS", TRUE);
d1339 1
a1339 1
		svp = hv_fetchs(oldaction, "SAFE", TRUE);
d1349 1
a1349 1
		svp = hv_fetchs(action, "SAFE", FALSE);
d1352 1
a1352 1
			    void (*)(int),
d1359 1
a1359 1
		svp = hv_fetchs(action, "HANDLER", FALSE);
d1382 1
a1382 1
		svp = hv_fetchs(action, "MASK", FALSE);
d1392 1
a1392 1
		svp = hv_fetchs(action, "FLAGS", FALSE);
d1672 1
a1672 1
          ST(0) = sv_2mortal(newSV(srclen*4+1));
d1716 1
a1716 1
asctime(sec, min, hour, mday, mon, year, wday = 0, yday = 0, isdst = -1)
d1770 1
a1770 1
mktime(sec, min, hour, mday, mon, year, wday = 0, yday = 0, isdst = -1)
d1793 1
a1793 1
	    RETVAL = (SysRetLong) mktime(&mytm);
d1842 1
a1842 1
	s = (char *) safemalloc((size_t) L_ctermid);
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d252 1
d259 3
d382 1
a382 11
/* In actual fact the code below is to blame here. Perl has an internal
 * representation of the exit status ($?), which it re-composes from the
 * OS's representation using the W*() POSIX macros. The code below
 * incorrectly uses the W*() macros on the internal representation,
 * which fails for OSs that have a different representation (namely BeOS
 * and Haiku). WMUNGE() is a hack that converts the internal
 * representation into the OS specific one, so that the W*() macros work
 * as expected. The better solution would be not to use the W*() macros
 * in the first place, though. -- Ingo Weinhold
 */
#if defined(__BEOS__) || defined(__HAIKU__)
d389 1
a389 1
not_here(const char *s)
d397 172
a580 110
#ifdef WIN32

/*
 * (1) The CRT maintains its own copy of the environment, separate from
 * the Win32API copy.
 *
 * (2) CRT getenv() retrieves from this copy. CRT putenv() updates this
 * copy, and then calls SetEnvironmentVariableA() to update the Win32API
 * copy.
 *
 * (3) win32_getenv() and win32_putenv() call GetEnvironmentVariableA() and
 * SetEnvironmentVariableA() directly, bypassing the CRT copy of the
 * environment.
 *
 * (4) The CRT strftime() "%Z" implementation calls __tzset(). That
 * calls CRT tzset(), but only the first time it is called, and in turn
 * that uses CRT getenv("TZ") to retrieve the timezone info from the CRT
 * local copy of the environment and hence gets the original setting as
 * perl never updates the CRT copy when assigning to $ENV{TZ}.
 *
 * Therefore, we need to retrieve the value of $ENV{TZ} and call CRT
 * putenv() to update the CRT copy of the environment (if it is different)
 * whenever we're about to call tzset().
 *
 * In addition to all that, when perl is built with PERL_IMPLICIT_SYS
 * defined:
 *
 * (a) Each interpreter has its own copy of the environment inside the
 * perlhost structure. That allows applications that host multiple
 * independent Perl interpreters to isolate environment changes from
 * each other. (This is similar to how the perlhost mechanism keeps a
 * separate working directory for each Perl interpreter, so that calling
 * chdir() will not affect other interpreters.)
 *
 * (b) Only the first Perl interpreter instantiated within a process will
 * "write through" environment changes to the process environment.
 *
 * (c) Even the primary Perl interpreter won't update the CRT copy of the
 * the environment, only the Win32API copy (it calls win32_putenv()).
 *
 * As with CPerlHost::Getenv() and CPerlHost::Putenv() themselves, it makes
 * sense to only update the process environment when inside the main
 * interpreter, but we don't have access to CPerlHost's m_bTopLevel member
 * from here so we'll just have to check PL_curinterp instead.
 *
 * Therefore, we can simply #undef getenv() and putenv() so that those names
 * always refer to the CRT functions, and explicitly call win32_getenv() to
 * access perl's %ENV.
 *
 * We also #undef malloc() and free() to be sure we are using the CRT
 * functions otherwise under PERL_IMPLICIT_SYS they are redefined to calls
 * into VMem::Malloc() and VMem::Free() and all allocations will be freed
 * when the Perl interpreter is being destroyed so we'd end up with a pointer
 * into deallocated memory in environ[] if a program embedding a Perl
 * interpreter continues to operate even after the main Perl interpreter has
 * been destroyed.
 *
 * Note that we don't free() the malloc()ed memory unless and until we call
 * malloc() again ourselves because the CRT putenv() function simply puts its
 * pointer argument into the environ[] arrary (it doesn't make a copy of it)
 * so this memory must otherwise be leaked.
 */

#undef getenv
#undef putenv
#undef malloc
#undef free

static void
fix_win32_tzenv(void)
{
    static char* oldenv = NULL;
    char* newenv;
    const char* perl_tz_env = win32_getenv("TZ");
    const char* crt_tz_env = getenv("TZ");
    if (perl_tz_env == NULL)
        perl_tz_env = "";
    if (crt_tz_env == NULL)
        crt_tz_env = "";
    if (strcmp(perl_tz_env, crt_tz_env) != 0) {
        newenv = (char*)malloc((strlen(perl_tz_env) + 4) * sizeof(char));
        if (newenv != NULL) {
            sprintf(newenv, "TZ=%s", perl_tz_env);
            putenv(newenv);
            if (oldenv != NULL)
                free(oldenv);
            oldenv = newenv;
        }
    }
}

#endif

/*
 * my_tzset - wrapper to tzset() with a fix to make it work (better) on Win32.
 * This code is duplicated in the Time-Piece module, so any changes made here
 * should be made there too.
 */
static void
my_tzset(pTHX)
{
#ifdef WIN32
#if defined(USE_ITHREADS) && defined(PERL_IMPLICIT_SYS)
    if (PL_curinterp == aTHX)
#endif
        fix_win32_tzenv();
#endif
    tzset();
}

d585 1
a585 1
    const char *	packname
d630 1
a630 1
    const char *	packname
d821 41
a861 63
int
WEXITSTATUS(status)
	int status
    ALIAS:
	POSIX::WIFEXITED = 1
	POSIX::WIFSIGNALED = 2
	POSIX::WIFSTOPPED = 3
	POSIX::WSTOPSIG = 4
	POSIX::WTERMSIG = 5
    CODE:
#if !(defined(WEXITSTATUS) || defined(WIFEXITED) || defined(WIFSIGNALED) \
      || defined(WIFSTOPPED) || defined(WSTOPSIG) || defined (WTERMSIG))
        RETVAL = 0; /* Silence compilers that notice this, but don't realise
		       that not_here() can't return.  */
#endif
	switch(ix) {
	case 0:
#ifdef WEXITSTATUS
	    RETVAL = WEXITSTATUS(WMUNGE(status));
#else
	    not_here("WEXITSTATUS");
#endif
	    break;
	case 1:
#ifdef WIFEXITED
	    RETVAL = WIFEXITED(WMUNGE(status));
#else
	    not_here("WIFEXITED");
#endif
	    break;
	case 2:
#ifdef WIFSIGNALED
	    RETVAL = WIFSIGNALED(WMUNGE(status));
#else
	    not_here("WIFSIGNALED");
#endif
	    break;
	case 3:
#ifdef WIFSTOPPED
	    RETVAL = WIFSTOPPED(WMUNGE(status));
#else
	    not_here("WIFSTOPPED");
#endif
	    break;
	case 4:
#ifdef WSTOPSIG
	    RETVAL = WSTOPSIG(WMUNGE(status));
#else
	    not_here("WSTOPSIG");
#endif
	    break;
	case 5:
#ifdef WTERMSIG
	    RETVAL = WTERMSIG(WMUNGE(status));
#else
	    not_here("WTERMSIG");
#endif
	    break;
	default:
	    Perl_croak(aTHX_ "Illegal alias %d for POSIX::W*", ix);
	}
    OUTPUT:
	RETVAL
d1665 1
a1665 1
	const char *	str
a1846 2
  PPCODE:
    my_tzset(aTHX);
a1877 9
    CODE:
#ifdef HAS_CUSERID
  RETVAL = cuserid(s);
#else
  RETVAL = 0;
  not_here("cuserid");
#endif
    OUTPUT:
  RETVAL
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@d73 3
d199 1
a199 1
#    if defined(OS2)
d208 12
a219 6
#  ifdef I_GRP
#    include <grp.h>
#  endif
#  include <sys/times.h>
#  ifdef HAS_UNAME
#    include <sys/utsname.h>
a220 1
#  include <sys/wait.h>
a226 123
#ifdef WIN32
   /* Perl on Windows assigns WSAGetLastError() return values to errno
    * (in win32/win32sck.c).  Therefore we need to map these values
    * back to standard symbolic names, as long as the same name isn't
    * already defined by errno.h itself.  The Errno.pm module does
    * a similar mapping.
    */
#  ifndef EWOULDBLOCK
#    define EWOULDBLOCK WSAEWOULDBLOCK
#  endif
#  ifndef EINPROGRESS
#    define EINPROGRESS WSAEINPROGRESS
#  endif
#  ifndef EALREADY
#    define EALREADY WSAEALREADY
#  endif
#  ifndef ENOTSOCK
#    define ENOTSOCK WSAENOTSOCK
#  endif
#  ifndef EDESTADDRREQ
#    define EDESTADDRREQ WSAEDESTADDRREQ
#  endif
#  ifndef EMSGSIZE
#    define EMSGSIZE WSAEMSGSIZE
#  endif
#  ifndef EPROTOTYPE
#    define EPROTOTYPE WSAEPROTOTYPE
#  endif
#  ifndef ENOPROTOOPT
#    define ENOPROTOOPT WSAENOPROTOOPT
#  endif
#  ifndef EPROTONOSUPPORT
#    define EPROTONOSUPPORT WSAEPROTONOSUPPORT
#  endif
#  ifndef ESOCKTNOSUPPORT
#    define ESOCKTNOSUPPORT WSAESOCKTNOSUPPORT
#  endif
#  ifndef EOPNOTSUPP
#    define EOPNOTSUPP WSAEOPNOTSUPP
#  endif
#  ifndef EPFNOSUPPORT
#    define EPFNOSUPPORT WSAEPFNOSUPPORT
#  endif
#  ifndef EAFNOSUPPORT
#    define EAFNOSUPPORT WSAEAFNOSUPPORT
#  endif
#  ifndef EADDRINUSE
#    define EADDRINUSE WSAEADDRINUSE
#  endif
#  ifndef EADDRNOTAVAIL
#    define EADDRNOTAVAIL WSAEADDRNOTAVAIL
#  endif
#  ifndef ENETDOWN
#    define ENETDOWN WSAENETDOWN
#  endif
#  ifndef ENETUNREACH
#    define ENETUNREACH WSAENETUNREACH
#  endif
#  ifndef ENETRESET
#    define ENETRESET WSAENETRESET
#  endif
#  ifndef ECONNABORTED
#    define ECONNABORTED WSAECONNABORTED
#  endif
#  ifndef ECONNRESET
#    define ECONNRESET WSAECONNRESET
#  endif
#  ifndef ENOBUFS
#    define ENOBUFS WSAENOBUFS
#  endif
#  ifndef EISCONN
#    define EISCONN WSAEISCONN
#  endif
#  ifndef ENOTCONN
#    define ENOTCONN WSAENOTCONN
#  endif
#  ifndef ESHUTDOWN
#    define ESHUTDOWN WSAESHUTDOWN
#  endif
#  ifndef ETOOMANYREFS
#    define ETOOMANYREFS WSAETOOMANYREFS
#  endif
#  ifndef ETIMEDOUT
#    define ETIMEDOUT WSAETIMEDOUT
#  endif
#  ifndef ECONNREFUSED
#    define ECONNREFUSED WSAECONNREFUSED
#  endif
#  ifndef ELOOP
#    define ELOOP WSAELOOP
#  endif
#  ifndef ENAMETOOLONG
#    define ENAMETOOLONG WSAENAMETOOLONG
#  endif
#  ifndef EHOSTDOWN
#    define EHOSTDOWN WSAEHOSTDOWN
#  endif
#  ifndef EHOSTUNREACH
#    define EHOSTUNREACH WSAEHOSTUNREACH
#  endif
#  ifndef ENOTEMPTY
#    define ENOTEMPTY WSAENOTEMPTY
#  endif
#  ifndef EPROCLIM
#    define EPROCLIM WSAEPROCLIM
#  endif
#  ifndef EUSERS
#    define EUSERS WSAEUSERS
#  endif
#  ifndef EDQUOT
#    define EDQUOT WSAEDQUOT
#  endif
#  ifndef ESTALE
#    define ESTALE WSAESTALE
#  endif
#  ifndef EREMOTE
#    define EREMOTE WSAEREMOTE
#  endif
#  ifndef EDISCON
#    define EDISCON WSAEDISCON
#  endif
#endif

d775 2
a776 2
#if !defined(WEXITSTATUS) || !defined(WIFEXITED) || !defined(WIFSIGNALED) \
      || !defined(WIFSTOPPED) || !defined(WSTOPSIG) || !defined(WTERMSIG)
d1228 1
a1228 1
	    GV *siggv = gv_fetchpvs("SIG", GV_ADD, SVt_PVHV);
d1291 1
a1291 1
	    osset_sv = newSVpvn((char *)(&osset), sizeof(sigset_t));
d1306 1
a1306 1
			sv_setpvs(*svp, "DEFAULT");
d1309 1
a1309 2
		if(RETVAL == -1) {
                   LEAVE;
a1310 1
                }
d1390 1
a1390 2
		if(RETVAL == -1) {
                    LEAVE;
a1391 1
                }
d1468 1
a1468 1
		XPUSHs(newSVpvs_flags("0 but true", SVs_TEMP));
d1523 5
a1527 5
	    PUSHs(newSVpvn_flags(buf.sysname, strlen(buf.sysname), SVs_TEMP));
	    PUSHs(newSVpvn_flags(buf.nodename, strlen(buf.nodename), SVs_TEMP));
	    PUSHs(newSVpvn_flags(buf.release, strlen(buf.release), SVs_TEMP));
	    PUSHs(newSVpvn_flags(buf.version, strlen(buf.version), SVs_TEMP));
	    PUSHs(newSVpvn_flags(buf.machine, strlen(buf.machine), SVs_TEMP));
d1792 1
a1792 1
	SV *		fmt
d1804 1
a1804 1
	    char *buf = my_strftime(SvPV_nolen(fmt), sec, min, hour, mday, mon, year, wday, yday, isdst);
d1806 2
a1807 6
		SV *const sv = sv_newmortal();
		sv_usepvn_flags(sv, buf, strlen(buf), SV_HAS_TRAILING_NUL);
		if (SvUTF8(fmt)) {
		    SvUTF8_on(sv);
		}
		ST(0) = sv;
d1820 2
a1821 2
	PUSHs(newSVpvn_flags(tzname[0], strlen(tzname[0]), SVs_TEMP));
	PUSHs(newSVpvn_flags(tzname[1], strlen(tzname[1]), SVs_TEMP));
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d85 20
d163 3
d222 3
a224 4
    * back to standard symbolic names, but only for those names having
    * no existing value or an existing value >= 100. (VC++ 2010 defines
    * a group of names with values >= 100 in its errno.h which we *do*
    * need to redefine.) The Errno.pm module does a similar mapping.
d226 53
a278 2
#  ifdef EWOULDBLOCK
#    undef EWOULDBLOCK
d280 59
a338 139
#  define EWOULDBLOCK WSAEWOULDBLOCK
#  ifdef EINPROGRESS
#    undef EINPROGRESS
#  endif
#  define EINPROGRESS WSAEINPROGRESS
#  ifdef EALREADY
#    undef EALREADY
#  endif
#  define EALREADY WSAEALREADY
#  ifdef ENOTSOCK
#    undef ENOTSOCK
#  endif
#  define ENOTSOCK WSAENOTSOCK
#  ifdef EDESTADDRREQ
#    undef EDESTADDRREQ
#  endif
#  define EDESTADDRREQ WSAEDESTADDRREQ
#  ifdef EMSGSIZE
#    undef EMSGSIZE
#  endif
#  define EMSGSIZE WSAEMSGSIZE
#  ifdef EPROTOTYPE
#    undef EPROTOTYPE
#  endif
#  define EPROTOTYPE WSAEPROTOTYPE
#  ifdef ENOPROTOOPT
#    undef ENOPROTOOPT
#  endif
#  define ENOPROTOOPT WSAENOPROTOOPT
#  ifdef EPROTONOSUPPORT
#    undef EPROTONOSUPPORT
#  endif
#  define EPROTONOSUPPORT WSAEPROTONOSUPPORT
#  ifdef ESOCKTNOSUPPORT
#    undef ESOCKTNOSUPPORT
#  endif
#  define ESOCKTNOSUPPORT WSAESOCKTNOSUPPORT
#  ifdef EOPNOTSUPP
#    undef EOPNOTSUPP
#  endif
#  define EOPNOTSUPP WSAEOPNOTSUPP
#  ifdef EPFNOSUPPORT
#    undef EPFNOSUPPORT
#  endif
#  define EPFNOSUPPORT WSAEPFNOSUPPORT
#  ifdef EAFNOSUPPORT
#    undef EAFNOSUPPORT
#  endif
#  define EAFNOSUPPORT WSAEAFNOSUPPORT
#  ifdef EADDRINUSE
#    undef EADDRINUSE
#  endif
#  define EADDRINUSE WSAEADDRINUSE
#  ifdef EADDRNOTAVAIL
#    undef EADDRNOTAVAIL
#  endif
#  define EADDRNOTAVAIL WSAEADDRNOTAVAIL
#  ifdef ENETDOWN
#    undef ENETDOWN
#  endif
#  define ENETDOWN WSAENETDOWN
#  ifdef ENETUNREACH
#    undef ENETUNREACH
#  endif
#  define ENETUNREACH WSAENETUNREACH
#  ifdef ENETRESET
#    undef ENETRESET
#  endif
#  define ENETRESET WSAENETRESET
#  ifdef ECONNABORTED
#    undef ECONNABORTED
#  endif
#  define ECONNABORTED WSAECONNABORTED
#  ifdef ECONNRESET
#    undef ECONNRESET
#  endif
#  define ECONNRESET WSAECONNRESET
#  ifdef ENOBUFS
#    undef ENOBUFS
#  endif
#  define ENOBUFS WSAENOBUFS
#  ifdef EISCONN
#    undef EISCONN
#  endif
#  define EISCONN WSAEISCONN
#  ifdef ENOTCONN
#    undef ENOTCONN
#  endif
#  define ENOTCONN WSAENOTCONN
#  ifdef ESHUTDOWN
#    undef ESHUTDOWN
#  endif
#  define ESHUTDOWN WSAESHUTDOWN
#  ifdef ETOOMANYREFS
#    undef ETOOMANYREFS
#  endif
#  define ETOOMANYREFS WSAETOOMANYREFS
#  ifdef ETIMEDOUT
#    undef ETIMEDOUT
#  endif
#  define ETIMEDOUT WSAETIMEDOUT
#  ifdef ECONNREFUSED
#    undef ECONNREFUSED
#  endif
#  define ECONNREFUSED WSAECONNREFUSED
#  ifdef ELOOP
#    undef ELOOP
#  endif
#  define ELOOP WSAELOOP
#  ifdef EHOSTDOWN
#    undef EHOSTDOWN
#  endif
#  define EHOSTDOWN WSAEHOSTDOWN
#  ifdef EHOSTUNREACH
#    undef EHOSTUNREACH
#  endif
#  define EHOSTUNREACH WSAEHOSTUNREACH
#  ifdef EPROCLIM
#    undef EPROCLIM
#  endif
#  define EPROCLIM WSAEPROCLIM
#  ifdef EUSERS
#    undef EUSERS
#  endif
#  define EUSERS WSAEUSERS
#  ifdef EDQUOT
#    undef EDQUOT
#  endif
#  define EDQUOT WSAEDQUOT
#  ifdef ESTALE
#    undef ESTALE
#  endif
#  define ESTALE WSAESTALE
#  ifdef EREMOTE
#    undef EREMOTE
#  endif
#  define EREMOTE WSAEREMOTE
#  ifdef EDISCON
#    undef EDISCON
a339 1
#  define EDISCON WSAEDISCON
d463 1
a463 39
#ifdef HAS_LOCALECONV
struct lconv_offset {
    const char *name;
    size_t offset;
};

const struct lconv_offset lconv_strings[] = {
    {"decimal_point",     offsetof(struct lconv, decimal_point)},
    {"thousands_sep",     offsetof(struct lconv, thousands_sep)},
#ifndef NO_LOCALECONV_GROUPING
    {"grouping",          offsetof(struct lconv, grouping)},
#endif
    {"int_curr_symbol",   offsetof(struct lconv, int_curr_symbol)},
    {"currency_symbol",   offsetof(struct lconv, currency_symbol)},
    {"mon_decimal_point", offsetof(struct lconv, mon_decimal_point)},
#ifndef NO_LOCALECONV_MON_THOUSANDS_SEP
    {"mon_thousands_sep", offsetof(struct lconv, mon_thousands_sep)},
#endif
#ifndef NO_LOCALECONV_MON_GROUPING
    {"mon_grouping",      offsetof(struct lconv, mon_grouping)},
#endif
    {"positive_sign",     offsetof(struct lconv, positive_sign)},
    {"negative_sign",     offsetof(struct lconv, negative_sign)},
    {NULL, 0}
};

const struct lconv_offset lconv_integers[] = {
    {"int_frac_digits",   offsetof(struct lconv, int_frac_digits)},
    {"frac_digits",       offsetof(struct lconv, frac_digits)},
    {"p_cs_precedes",     offsetof(struct lconv, p_cs_precedes)},
    {"p_sep_by_space",    offsetof(struct lconv, p_sep_by_space)},
    {"n_cs_precedes",     offsetof(struct lconv, n_cs_precedes)},
    {"n_sep_by_space",    offsetof(struct lconv, n_sep_by_space)},
    {"p_sign_posn",       offsetof(struct lconv, p_sign_posn)},
    {"n_sign_posn",       offsetof(struct lconv, n_sign_posn)},
    {NULL, 0}
};

#else
a529 10
static void *
allocate_struct(pTHX_ SV *rv, const STRLEN size, const char *packname) {
    SV *const t = newSVrv(rv, packname);
    void *const p = sv_grow(t, size + 1);

    SvCUR_set(t, size);
    SvPOK_on(t);
    return p;
}

d589 1
a589 1
 * pointer argument into the environ[] array (it doesn't make a copy of it)
a639 74
typedef int (*isfunc_t)(int);
typedef void (*any_dptr_t)(void *);

/* This needs to be ALIASed in a custom way, hence can't easily be defined as
   a regular XSUB.  */
static XSPROTO(is_common); /* prototype to pass -Wmissing-prototypes */
static XSPROTO(is_common)
{
    dXSARGS;
    SV *charstring;
    if (items != 1)
       croak_xs_usage(cv,  "charstring");

    {
	dXSTARG;
	STRLEN	len;
	int	RETVAL;
	unsigned char *s = (unsigned char *) SvPV(ST(0), len);
	unsigned char *e = s + len;
	isfunc_t isfunc = (isfunc_t) XSANY.any_dptr;

	for (RETVAL = 1; RETVAL && s < e; s++)
	    if (!isfunc(*s))
		RETVAL = 0;
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

MODULE = POSIX		PACKAGE = POSIX

BOOT:
{
    CV *cv;
    const char *file = __FILE__;

    /* Ensure we get the function, not a macro implementation. Like the C89
       standard says we can...  */
#undef isalnum
    cv = newXS("POSIX::isalnum", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &isalnum;
#undef isalpha
    cv = newXS("POSIX::isalpha", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &isalpha;
#undef iscntrl
    cv = newXS("POSIX::iscntrl", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &iscntrl;
#undef isdigit
    cv = newXS("POSIX::isdigit", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &isdigit;
#undef isgraph
    cv = newXS("POSIX::isgraph", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &isgraph;
#undef islower
    cv = newXS("POSIX::islower", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &islower;
#undef isprint
    cv = newXS("POSIX::isprint", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &isprint;
#undef ispunct
    cv = newXS("POSIX::ispunct", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &ispunct;
#undef isspace
    cv = newXS("POSIX::isspace", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &isspace;
#undef isupper
    cv = newXS("POSIX::isupper", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &isupper;
#undef isxdigit
    cv = newXS("POSIX::isxdigit", is_common, file);
    XSANY.any_dptr = (any_dptr_t) &isxdigit;
}

d642 1
a642 1
void
d648 2
a649 5
	    sigset_t *const s
		= (sigset_t *) allocate_struct(aTHX_ (ST(0) = sv_newmortal()),
					       sizeof(sigset_t),
					       packname);
	    sigemptyset(s);
d651 1
a651 2
		sigaddset(s, SvIV(ST(i)));
	    XSRETURN(1);
d653 8
d663 1
a663 1
addset(sigset, sig)
a665 6
   ALIAS:
	delset = 1
   CODE:
	RETVAL = ix ? sigdelset(sigset, sig) : sigaddset(sigset, sig);
   OUTPUT:
	RETVAL
d668 10
a677 1
emptyset(sigset)
a678 6
   ALIAS:
	fillset = 1
   CODE:
	RETVAL = ix ? sigfillset(sigset) : sigemptyset(sigset);
   OUTPUT:
	RETVAL
d687 1
a687 1
void
d693 1
a693 8
	    void *const p = allocate_struct(aTHX_ (ST(0) = sv_newmortal()),
					    sizeof(struct termios), packname);
	    /* The previous implementation stored a pointer to an uninitialised
	       struct termios. Seems safer to initialise it, particularly as
	       this implementation exposes the struct to prying from perl-space.
	    */
	    memset(p, 0, 1 + sizeof(struct termios));
	    XSRETURN(1);
d696 1
d699 12
a720 7
# If we define TCSANOW here then both a found and not found constant sub
# are created causing a Constant subroutine TCSANOW redefined warning
#ifndef TCSANOW
#  define DEF_SETATTR_ACTION 0
#else
#  define DEF_SETATTR_ACTION TCSANOW
#endif
d722 1
a722 1
setattr(termios_ref, fd = 0, optional_actions = DEF_SETATTR_ACTION)
a726 4
	/* The second argument to the call is mandatory, but we'd like to give
	   it a useful default. 0 isn't valid on all operating systems - on
	   Solaris (at least) TCSANOW, TCSADRAIN and TCSAFLUSH have the same
	   values as the equivalent ioctls, TCSETS, TCSETSW and TCSETSF.  */
d732 35
a766 1
getispeed(termios_ref)
a767 2
    ALIAS:
	getospeed = 1
d769 6
a774 1
	RETVAL = ix ? cfgetospeed(termios_ref) : cfgetispeed(termios_ref);
d779 1
a779 1
getiflag(termios_ref)
a780 4
    ALIAS:
	getoflag = 1
	getcflag = 2
	getlflag = 3
d783 1
a783 14
	switch(ix) {
	case 0:
	    RETVAL = termios_ref->c_iflag;
	    break;
	case 1:
	    RETVAL = termios_ref->c_oflag;
	    break;
	case 2:
	    RETVAL = termios_ref->c_cflag;
	    break;
	case 3:
	    RETVAL = termios_ref->c_lflag;
	    break;
	}
d785 2
a786 2
	not_here(GvNAME(CvGV(cv)));
	RETVAL = 0;
d808 1
a808 1
setispeed(termios_ref, speed)
d811 32
a842 2
    ALIAS:
	setospeed = 1
d844 5
a848 4
	RETVAL = ix
	    ? cfsetospeed(termios_ref, speed) : cfsetispeed(termios_ref, speed);
    OUTPUT:
	RETVAL
d851 1
a851 1
setiflag(termios_ref, flag)
d853 1
a853 5
	tcflag_t	flag
    ALIAS:
	setoflag = 1
	setcflag = 2
	setlflag = 3
d856 1
a856 14
	switch(ix) {
	case 0:
	    termios_ref->c_iflag = flag;
	    break;
	case 1:
	    termios_ref->c_oflag = flag;
	    break;
	case 2:
	    termios_ref->c_cflag = flag;
	    break;
	case 3:
	    termios_ref->c_lflag = flag;
	    break;
	}
d858 1
a858 1
	not_here(GvNAME(CvGV(cv)));
d939 1
a939 1
	    Perl_croak(aTHX_ "Illegal alias %d for POSIX::W*", (int)ix);
d944 154
d1119 62
a1180 19
	    const struct lconv_offset *strings = lconv_strings;
	    const struct lconv_offset *integers = lconv_integers;
	    const char *ptr = (const char *) lcbuf;

	    do {
		const char *value = *((const char **)(ptr + strings->offset));

		if (value && *value)
		    (void) hv_store(RETVAL, strings->name, strlen(strings->name),
				    newSVpv(value, 0), 0);
	    } while ((++strings)->name);

	    do {
		const char value = *((const char *)(ptr + integers->offset));

		if (value != CHAR_MAX)
		    (void) hv_store(RETVAL, integers->name,
				    strlen(integers->name), newSViv(value), 0);
	    } while ((++integers)->name);
d1263 20
a1282 44
    ALIAS:
	asin = 1
	atan = 2
	ceil = 3
	cosh = 4
	floor = 5
	log10 = 6
	sinh = 7
	tan = 8
	tanh = 9
    CODE:
	switch (ix) {
	case 0:
	    RETVAL = acos(x);
	    break;
	case 1:
	    RETVAL = asin(x);
	    break;
	case 2:
	    RETVAL = atan(x);
	    break;
	case 3:
	    RETVAL = ceil(x);
	    break;
	case 4:
	    RETVAL = cosh(x);
	    break;
	case 5:
	    RETVAL = floor(x);
	    break;
	case 6:
	    RETVAL = log10(x);
	    break;
	case 7:
	    RETVAL = sinh(x);
	    break;
	case 8:
	    RETVAL = tan(x);
	    break;
	default:
	    RETVAL = tanh(x);
	}
    OUTPUT:
	RETVAL
d1303 4
d1316 12
d1431 2
a1432 1
		    sigset = (sigset_t *) SvPV_nolen(SvRV(*svp));
d1435 2
a1436 3
		    sigset = (sigset_t *) allocate_struct(aTHX_ *svp,
							  sizeof(sigset_t),
							  "POSIX::SigSet");
d1474 1
a1474 1
		SvSETMAGIC(*sigsvp);
d1490 2
a1491 1
		    sigset = (sigset_t *) SvPV_nolen(SvRV(*svp));
a1521 8
    ALIAS:
	sigsuspend = 1
    CODE:
	RETVAL = ix ? sigsuspend(sigset) : sigpending(sigset);
    OUTPUT:
	RETVAL
    CLEANUP:
    PERL_ASYNC_CHECK();
d1532 2
a1533 1
	    sigset = (sigset_t *) SvPV_nolen(SvRV(ST(1)));
d1541 2
a1542 1
	    oldsigset = (sigset_t *) SvPV_nolen(SvRV(ST(2)));
d1547 4
d1556 8
a1566 11
    CODE:
#ifdef WIN32
	/* RT #98912 - More Microsoft muppetry - failing to actually implemented
	   the well known documented POSIX behaviour for a POSIX API.
	   http://msdn.microsoft.com/en-us/library/8syseb29.aspx   */
	RETVAL = dup2(fd1, fd2) == -1 ? -1 : fd2;
#else
	RETVAL = dup2(fd1, fd2);
#endif
    OUTPUT:
	RETVAL
a1795 2
    ALIAS:
	access = 1
d1797 2
a1798 6
	if(ix) {
	    RETVAL = access(filename, mode);
	} else {
	    TAINT_PROPER("mkfifo");
	    RETVAL = mkfifo(filename, mode);
	}
a1804 8
    ALIAS:
	close = 1
	dup = 2
    CODE:
	RETVAL = ix == 1 ? close(fd)
	    : (ix < 1 ? tcdrain(fd) : dup(fd));
    OUTPUT:
	RETVAL
a1810 8
    ALIAS:
	tcflush = 1
	tcsendbreak = 2
    CODE:
	RETVAL = ix == 1 ? tcflush(fd, action)
	    : (ix < 1 ? tcflow(fd, action) : tcsendbreak(fd, action));
    OUTPUT:
	RETVAL
d1812 12
a1823 1
void
d1834 1
a1834 3
    ALIAS:
	mktime = 1
    PPCODE:
a1835 1
	    dXSTARG;
d1837 1
a1837 1
	    init_tm(&mytm);	/* XXX workaround - see init_tm() in core util.c */
d1847 1
a1847 13
	    if (ix) {
	        const time_t result = mktime(&mytm);
		if (result == (time_t)-1)
		    SvOK_off(TARG);
		else if (result == 0)
		    sv_setpvn(TARG, "0 but true", 10);
		else
		    sv_setiv(TARG, (IV)result);
	    } else {
		sv_setpv(TARG, asctime(&mytm));
	    }
	    ST(0) = TARG;
	    XSRETURN(1);
d1849 2
d1877 29
d1946 5
a1990 10
    CLEANUP:
    PERL_ASYNC_CHECK();

unsigned int
sleep(seconds)
	unsigned int	seconds
    CODE:
	RETVAL = PerlProc_sleep(seconds);
    OUTPUT:
	RETVAL
d1995 7
d2006 7
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a375 1
START_EXTERN_C
a378 1
END_EXTERN_C
d549 1
a549 1
#if defined(__HAIKU__)
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@a30 3
#ifdef WIN32
#include <sys/errno2.h>
#endif
d86 6
a91 2

#  include <utsname.h>
d95 6
d106 27
d196 154
d707 1
a707 2
    static PTR_TBL_t * is_common_ptr_table;

a713 2
        /*int	RETVAL = 0;   YYY means uncomment this to return false on an
                            * empty string input */
a718 18
        if (ckWARN_d(WARN_DEPRECATED)) {

            /* Warn exactly once for each lexical place this function is
             * called.  See thread at
             * http://markmail.org/thread/jhqcag5njmx7jpyu */

	    if (! is_common_ptr_table) {
               is_common_ptr_table = ptr_table_new();
            }
	    if (! ptr_table_fetch(is_common_ptr_table, PL_op)) {
                Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                            "Calling POSIX::%"HEKf"() is deprecated",
                            HEKfARG(GvNAME_HEK(CvGV(cv))));
                ptr_table_store(is_common_ptr_table, PL_op, (void *) 1);
            }
        }

        /*if (e > s) { YYY */
a721 1
        /*} YYY */
a734 4

    /* silence compiler warning about not_here() defined but not used */
    if (0) not_here("");

a898 2
        default:
	    RETVAL = 0; /* silence compiler warning */
a1099 3
#ifdef WIN32    /* Use wrapper on Windows */
	retval = Perl_my_setlocale(aTHX_ category, locale);
#else
d1101 1
a1101 5
#endif
	if (! retval) {
            XSRETURN_UNDEF;
        }
        else {
d1157 2
d1162 2
a1163 1
        Safefree(RETVAL);
d1631 1
a1631 1
        STORE_NUMERIC_STANDARD_FORCE_LOCAL();
a1640 1
        RESTORE_NUMERIC_STANDARD();
d1835 1
a1835 8
	    char *buf;

            /* allowing user-supplied (rather than literal) formats
             * is normally frowned upon as a potential security risk;
             * but this is part of the API so we have to allow it */
            GCC_DIAG_IGNORE(-Wformat-nonliteral);
	    buf = my_strftime(SvPV_nolen(fmt), sec, min, hour, mday, mon, year, wday, yday, isdst);
            GCC_DIAG_RESTORE;
@


