head	1.15;
access;
symbols
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.12.0.10
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.15
date	2010.09.24.14.59.15;	author millert;	state dead;
branches;
next	1.14;

1.14
date	2009.10.12.18.24.24;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.29.17.36.02;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.28.19.23.01;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.15.21.30.25;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.09.18.09.06;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.07.21.33.02;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.03.03.02.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.27.22.25.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.25.06.27.10;	author camield;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.08;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.05.06;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.25;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.55.05;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.01;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.01;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.38.39;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.05;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.42;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.42;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.12.59;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.45.55;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.44;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.47.55;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.14;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.11.15;	author millert;	state Exp;
branches;
next	;


desc
@@


1.15
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@/* 

 DB_File.xs -- Perl 5 interface to Berkeley DB 

 written by Paul Marquess <pmqs@@cpan.org>
 last modified 4th February 2007
 version 1.818

 All comments/suggestions/problems are welcome

     Copyright (c) 1995-2009 Paul Marquess. All rights reserved.
     This program is free software; you can redistribute it and/or
     modify it under the same terms as Perl itself.

 Changes:
	0.1 - 	Initial Release
	0.2 - 	No longer bombs out if dbopen returns an error.
	0.3 - 	Added some support for multiple btree compares
	1.0 - 	Complete support for multiple callbacks added.
	      	Fixed a problem with pushing a value onto an empty list.
	1.01 - 	Fixed a SunOS core dump problem.
		The return value from TIEHASH wasn't set to NULL when
		dbopen returned an error.
	1.02 - 	Use ALIAS to define TIEARRAY.
		Removed some redundant commented code.
		Merged OS2 code into the main distribution.
		Allow negative subscripts with RECNO interface.
		Changed the default flags to O_CREAT|O_RDWR
	1.03 - 	Added EXISTS
	1.04 -  fixed a couple of bugs in hash_cb. Patches supplied by
		Dave Hammen, hammen@@gothamcity.jsc.nasa.gov
	1.05 -  Added logic to allow prefix & hash types to be specified via
		Makefile.PL
	1.06 -  Minor namespace cleanup: Localized PrintBtree.
	1.07 -  Fixed bug with RECNO, where bval wasn't defaulting to "\n". 
	1.08 -  No change to DB_File.xs
	1.09 -  Default mode for dbopen changed to 0666
	1.10 -  Fixed fd method so that it still returns -1 for
		in-memory files when db 1.86 is used.
	1.11 -  No change to DB_File.xs
	1.12 -  No change to DB_File.xs
	1.13 -  Tidied up a few casts.     
	1.14 -	Made it illegal to tie an associative array to a RECNO
		database and an ordinary array to a HASH or BTREE database.
	1.50 -  Make work with both DB 1.x or DB 2.x
	1.51 -  Fixed a bug in mapping 1.x O_RDONLY flag to 2.x DB_RDONLY equivalent
	1.52 -  Patch from Gisle Aas <gisle@@aas.no> to suppress "use of 
		undefined value" warning with db_get and db_seq.
	1.53 -  Added DB_RENUMBER to flags for recno.
	1.54 -  Fixed bug in the fd method
        1.55 -  Fix for AIX from Jarkko Hietaniemi
        1.56 -  No change to DB_File.xs
        1.57 -  added the #undef op to allow building with Threads support.
	1.58 -  Fixed a problem with the use of sv_setpvn. When the
		size is specified as 0, it does a strlen on the data.
		This was ok for DB 1.x, but isn't for DB 2.x.
        1.59 -  No change to DB_File.xs
        1.60 -  Some code tidy up
        1.61 -  added flagSet macro for DB 2.5.x
		fixed typo in O_RDONLY test.
        1.62 -  No change to DB_File.xs
        1.63 -  Fix to alllow DB 2.6.x to build.
        1.64 -  Tidied up the 1.x to 2.x flags mapping code.
		Added a patch from Mark Kettenis <kettenis@@wins.uva.nl>
		to fix a flag mapping problem with O_RDONLY on the Hurd
        1.65 -  Fixed a bug in the PUSH logic.
		Added BOOT check that using 2.3.4 or greater
        1.66 -  Added DBM filter code
        1.67 -  Backed off the use of newSVpvn.
		Fixed DBM Filter code for Perl 5.004.
		Fixed a small memory leak in the filter code.
        1.68 -  fixed backward compatability bug with R_IAFTER & R_IBEFORE
		merged in the 5.005_58 changes
        1.69 -  fixed a bug in push -- DB_APPEND wasn't working properly.
		Fixed the R_SETCURSOR bug introduced in 1.68
		Added a new Perl variable $DB_File::db_ver 
        1.70 -  Initialise $DB_File::db_ver and $DB_File::db_version with 
		GV_ADD|GV_ADDMULT -- bug spotted by Nick Ing-Simmons.
		Added a BOOT check to test for equivalent versions of db.h &
		libdb.a/so.
        1.71 -  Support for Berkeley DB version 3.
		Support for Berkeley DB 2/3's backward compatability mode.
		Rewrote push
        1.72 -  No change to DB_File.xs
        1.73 -  No change to DB_File.xs
        1.74 -  A call to open needed parenthesised to stop it clashing
                with a win32 macro.
		Added Perl core patches 7703 & 7801.
        1.75 -  Fixed Perl core patch 7703.
		Added suppport to allow DB_File to be built with 
		Berkeley DB 3.2 -- btree_compare, btree_prefix and hash_cb
		needed to be changed.
        1.76 -  No change to DB_File.xs
        1.77 -  Tidied up a few types used in calling newSVpvn.
        1.78 -  Core patch 10335, 10372, 10534, 10549, 11051 included.
        1.79 -  NEXTKEY ignores the input key.
                Added lots of casts
        1.800 - Moved backward compatability code into ppport.h.
                Use the new constants code.
        1.801 - No change to DB_File.xs
        1.802 - No change to DB_File.xs
        1.803 - FETCH, STORE & DELETE don't map the flags parameter
                into the equivalent Berkeley DB function anymore.
        1.804 - no change.
        1.805 - recursion detection added to the callbacks
                Support for 4.1.X added.
                Filter code can now cope with read-only $_
        1.806 - recursion detection beefed up.
        1.807 - no change
        1.808 - leak fixed in ParseOpenInfo
        1.809 - no change
        1.810 - no change
        1.811 - no change
        1.812 - no change
        1.813 - no change
        1.814 - no change
        1.814 - C++ casting fixes

*/

#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"  
#include "perl.h"
#include "XSUB.h"

#ifdef _NOT_CORE
#  include "ppport.h"
#endif

/* Mention DB_VERSION_MAJOR_CFG, DB_VERSION_MINOR_CFG, and
   DB_VERSION_PATCH_CFG here so that Configure pulls them all in. */

/* Being the Berkeley DB we prefer the <sys/cdefs.h> (which will be
 * shortly #included by the <db.h>) __attribute__ to the possibly
 * already defined __attribute__, for example by GNUC or by Perl. */

/* #if DB_VERSION_MAJOR_CFG < 2  */
#ifndef DB_VERSION_MAJOR
#    undef __attribute__
#endif

#ifdef COMPAT185
#    include <db_185.h>
#else
#    include <db.h>
#endif

/* Wall starts with 5.7.x */

#if PERL_REVISION > 5 || (PERL_REVISION == 5 && PERL_VERSION >= 7)

/* Since we dropped the gccish definition of __attribute__ we will want
 * to redefine dNOOP, however (so that dTHX continues to work).  Yes,
 * all this means that we can't do attribute checking on the DB_File,
 * boo, hiss. */
#  ifndef DB_VERSION_MAJOR

#    undef  dNOOP
#    define dNOOP extern int Perl___notused

    /* Ditto for dXSARGS. */
#    undef  dXSARGS
#    define dXSARGS				\
	dSP; dMARK;			\
	I32 ax = mark - PL_stack_base + 1;	\
	I32 items = sp - mark

#  endif

/* avoid -Wall; DB_File xsubs never make use of `ix' setup for ALIASes */
#  undef dXSI32
#  define dXSI32 dNOOP

#endif /* Perl >= 5.7 */

#include <fcntl.h> 

/* #define TRACE */

#ifdef TRACE
#    define Trace(x)        printf x
#else
#    define Trace(x)
#endif


#define DBT_clear(x)	Zero(&x, 1, DBT) ;

#ifdef DB_VERSION_MAJOR

#if DB_VERSION_MAJOR == 2
#    define BERKELEY_DB_1_OR_2
#endif

#if DB_VERSION_MAJOR > 3 || (DB_VERSION_MAJOR == 3 && DB_VERSION_MINOR >= 2)
#    define AT_LEAST_DB_3_2
#endif

#if DB_VERSION_MAJOR > 3 || (DB_VERSION_MAJOR == 3 && DB_VERSION_MINOR >= 3)
#    define AT_LEAST_DB_3_3
#endif

#if DB_VERSION_MAJOR > 4 || (DB_VERSION_MAJOR == 4 && DB_VERSION_MINOR >= 1)
#    define AT_LEAST_DB_4_1
#endif

#if DB_VERSION_MAJOR > 4 || (DB_VERSION_MAJOR == 4 && DB_VERSION_MINOR >= 3)
#    define AT_LEAST_DB_4_3
#endif

#ifdef AT_LEAST_DB_3_3
#   define WANT_ERROR
#endif

/* map version 2 features & constants onto their version 1 equivalent */

#ifdef DB_Prefix_t
#    undef DB_Prefix_t
#endif
#define DB_Prefix_t	size_t

#ifdef DB_Hash_t
#    undef DB_Hash_t
#endif
#define DB_Hash_t	u_int32_t

/* DBTYPE stays the same */
/* HASHINFO, RECNOINFO and BTREEINFO  map to DB_INFO */
#if DB_VERSION_MAJOR == 2
    typedef DB_INFO	INFO ;
#else /* DB_VERSION_MAJOR > 2 */
#    define DB_FIXEDLEN	(0x8000)
#endif /* DB_VERSION_MAJOR == 2 */

/* version 2 has db_recno_t in place of recno_t	*/
typedef db_recno_t	recno_t;


#define R_CURSOR        DB_SET_RANGE
#define R_FIRST         DB_FIRST
#define R_IAFTER        DB_AFTER
#define R_IBEFORE       DB_BEFORE
#define R_LAST          DB_LAST
#define R_NEXT          DB_NEXT
#define R_NOOVERWRITE   DB_NOOVERWRITE
#define R_PREV          DB_PREV

#if DB_VERSION_MAJOR == 2 && DB_VERSION_MINOR < 5
#  define R_SETCURSOR	0x800000
#else
#  define R_SETCURSOR	(-100)
#endif

#define R_RECNOSYNC     0
#define R_FIXEDLEN	DB_FIXEDLEN
#define R_DUP		DB_DUP


#define db_HA_hash 	h_hash
#define db_HA_ffactor	h_ffactor
#define db_HA_nelem	h_nelem
#define db_HA_bsize	db_pagesize
#define db_HA_cachesize	db_cachesize
#define db_HA_lorder	db_lorder

#define db_BT_compare	bt_compare
#define db_BT_prefix	bt_prefix
#define db_BT_flags	flags
#define db_BT_psize	db_pagesize
#define db_BT_cachesize	db_cachesize
#define db_BT_lorder	db_lorder
#define db_BT_maxkeypage
#define db_BT_minkeypage


#define db_RE_reclen	re_len
#define db_RE_flags	flags
#define db_RE_bval	re_pad
#define db_RE_bfname	re_source
#define db_RE_psize	db_pagesize
#define db_RE_cachesize	db_cachesize
#define db_RE_lorder	db_lorder

#define TXN	NULL,

#define do_SEQ(db, key, value, flag)	(db->cursor->c_get)(db->cursor, &key, &value, flag)


#define DBT_flags(x)	x.flags = 0
#define DB_flags(x, v)	x |= v 

#if DB_VERSION_MAJOR == 2 && DB_VERSION_MINOR < 5
#    define flagSet(flags, bitmask)	((flags) & (bitmask))
#else
#    define flagSet(flags, bitmask)	(((flags) & DB_OPFLAGS_MASK) == (bitmask))
#endif

#else /* db version 1.x */

#define BERKELEY_DB_1
#define BERKELEY_DB_1_OR_2

typedef union INFO {
        HASHINFO 	hash ;
        RECNOINFO 	recno ;
        BTREEINFO 	btree ;
      } INFO ;


#ifdef mDB_Prefix_t 
#  ifdef DB_Prefix_t
#    undef DB_Prefix_t
#  endif
#  define DB_Prefix_t	mDB_Prefix_t 
#endif

#ifdef mDB_Hash_t
#  ifdef DB_Hash_t
#    undef DB_Hash_t
#  endif
#  define DB_Hash_t	mDB_Hash_t
#endif

#define db_HA_hash 	hash.hash
#define db_HA_ffactor	hash.ffactor
#define db_HA_nelem	hash.nelem
#define db_HA_bsize	hash.bsize
#define db_HA_cachesize	hash.cachesize
#define db_HA_lorder	hash.lorder

#define db_BT_compare	btree.compare
#define db_BT_prefix	btree.prefix
#define db_BT_flags	btree.flags
#define db_BT_psize	btree.psize
#define db_BT_cachesize	btree.cachesize
#define db_BT_lorder	btree.lorder
#define db_BT_maxkeypage btree.maxkeypage
#define db_BT_minkeypage btree.minkeypage

#define db_RE_reclen	recno.reclen
#define db_RE_flags	recno.flags
#define db_RE_bval	recno.bval
#define db_RE_bfname	recno.bfname
#define db_RE_psize	recno.psize
#define db_RE_cachesize	recno.cachesize
#define db_RE_lorder	recno.lorder

#define TXN	

#define do_SEQ(db, key, value, flag)	(db->dbp->seq)(db->dbp, &key, &value, flag)
#define DBT_flags(x)	
#define DB_flags(x, v)	
#define flagSet(flags, bitmask)        ((flags) & (bitmask))

#endif /* db version 1 */



#define db_DELETE(db, key, flags)       ((db->dbp)->del)(db->dbp, TXN &key, 0)
#define db_STORE(db, key, value, flags) ((db->dbp)->put)(db->dbp, TXN &key, &value, 0)
#define db_FETCH(db, key, flags)        ((db->dbp)->get)(db->dbp, TXN &key, &value, 0)

#define db_sync(db, flags)              ((db->dbp)->sync)(db->dbp, flags)
#define db_get(db, key, value, flags)   ((db->dbp)->get)(db->dbp, TXN &key, &value, flags)

#ifdef DB_VERSION_MAJOR
#define db_DESTROY(db)                  (!db->aborted && ( db->cursor->c_close(db->cursor),\
					  (db->dbp->close)(db->dbp, 0) ))
#define db_close(db)			((db->dbp)->close)(db->dbp, 0)
#define db_del(db, key, flags)          (flagSet(flags, R_CURSOR) 					\
						? ((db->cursor)->c_del)(db->cursor, 0)		\
						: ((db->dbp)->del)(db->dbp, NULL, &key, flags) )

#else /* ! DB_VERSION_MAJOR */

#define db_DESTROY(db)                  (!db->aborted && ((db->dbp)->close)(db->dbp))
#define db_close(db)			((db->dbp)->close)(db->dbp)
#define db_del(db, key, flags)          ((db->dbp)->del)(db->dbp, &key, flags)
#define db_put(db, key, value, flags)   ((db->dbp)->put)(db->dbp, &key, &value, flags)

#endif /* ! DB_VERSION_MAJOR */


#define db_seq(db, key, value, flags)   do_SEQ(db, key, value, flags)

typedef struct {
	DBTYPE	type ;
	DB * 	dbp ;
	SV *	compare ;
	bool	in_compare ;
	SV *	prefix ;
	bool	in_prefix ;
	SV *	hash ;
	bool	in_hash ;
	bool	aborted ;
	int	in_memory ;
#ifdef BERKELEY_DB_1_OR_2
	INFO 	info ;
#endif	
#ifdef DB_VERSION_MAJOR
	DBC *	cursor ;
#endif
	SV *    filter_fetch_key ;
	SV *    filter_store_key ;
	SV *    filter_fetch_value ;
	SV *    filter_store_value ;
	int     filtering ;

	} DB_File_type;

typedef DB_File_type * DB_File ;
typedef DBT DBTKEY ;

#define my_sv_setpvn(sv, d, s) sv_setpvn(sv, (s ? d : (const char *)""), s)

#define OutputValue(arg, name)  					\
	{ if (RETVAL == 0) {						\
	      SvGETMAGIC(arg) ;          				\
	      my_sv_setpvn(arg, (const char *)name.data, name.size) ;			\
	      TAINT;                                       		\
	      SvTAINTED_on(arg);                                       	\
	      SvUTF8_off(arg);                                       	\
	      DBM_ckFilter(arg, filter_fetch_value,"filter_fetch_value") ; 	\
	  }								\
	}

#define OutputKey(arg, name)	 					\
	{ if (RETVAL == 0) 						\
	  { 								\
		SvGETMAGIC(arg) ;          				\
		if (db->type != DB_RECNO) {				\
		    my_sv_setpvn(arg, (const char *)name.data, name.size); 		\
		}							\
		else 							\
		    sv_setiv(arg, (I32)*(I32*)name.data - 1); 		\
	      TAINT;                                       		\
	      SvTAINTED_on(arg);                                       	\
	      SvUTF8_off(arg);                                       	\
	      DBM_ckFilter(arg, filter_fetch_key,"filter_fetch_key") ; 	\
	  } 								\
	}

#define my_SvUV32(sv) ((u_int32_t)SvUV(sv))

#ifdef CAN_PROTOTYPE
extern void __getBerkeleyDBInfo(void);
#endif

/* Internal Global Data */

#define MY_CXT_KEY "DB_File::_guts" XS_VERSION

typedef struct {
    recno_t	x_Value; 
    recno_t	x_zero;
    DB_File	x_CurrentDB;
    DBTKEY	x_empty;
} my_cxt_t;

START_MY_CXT

#define Value		(MY_CXT.x_Value)
#define zero		(MY_CXT.x_zero)
#define CurrentDB	(MY_CXT.x_CurrentDB)
#define empty		(MY_CXT.x_empty)

#define ERR_BUFF "DB_File::Error"

#ifdef DB_VERSION_MAJOR

static int
#ifdef CAN_PROTOTYPE
db_put(DB_File db, DBTKEY key, DBT value, u_int flags)
#else
db_put(db, key, value, flags)
DB_File		db ;
DBTKEY		key ;
DBT		value ;
u_int		flags ;
#endif
{
    int status ;

    if (flagSet(flags, R_IAFTER) || flagSet(flags, R_IBEFORE)) {
        DBC * temp_cursor ;
	DBT l_key, l_value;
        
#if DB_VERSION_MAJOR == 2 && DB_VERSION_MINOR < 6
        if (((db->dbp)->cursor)(db->dbp, NULL, &temp_cursor) != 0)
#else
        if (((db->dbp)->cursor)(db->dbp, NULL, &temp_cursor, 0) != 0)
#endif
	    return (-1) ;

	memset(&l_key, 0, sizeof(l_key));
	l_key.data = key.data;
	l_key.size = key.size;
	memset(&l_value, 0, sizeof(l_value));
	l_value.data = value.data;
	l_value.size = value.size;

	if ( temp_cursor->c_get(temp_cursor, &l_key, &l_value, DB_SET) != 0) {
	    (void)temp_cursor->c_close(temp_cursor);
	    return (-1);
	}

	status = temp_cursor->c_put(temp_cursor, &key, &value, flags);
	(void)temp_cursor->c_close(temp_cursor);
	    
        return (status) ;
    }	
    
    
    if (flagSet(flags, R_CURSOR)) {
	return ((db->cursor)->c_put)(db->cursor, &key, &value, DB_CURRENT);
    }

    if (flagSet(flags, R_SETCURSOR)) {
	if ((db->dbp)->put(db->dbp, NULL, &key, &value, 0) != 0)
		return -1 ;
        return ((db->cursor)->c_get)(db->cursor, &key, &value, DB_SET_RANGE);
    
    }

    return ((db->dbp)->put)(db->dbp, NULL, &key, &value, flags) ;

}

#endif /* DB_VERSION_MAJOR */

static void
tidyUp(DB_File db)
{
    db->aborted = TRUE ;
}


static int
#ifdef AT_LEAST_DB_3_2

#ifdef CAN_PROTOTYPE
btree_compare(DB * db, const DBT *key1, const DBT *key2)
#else
btree_compare(db, key1, key2)
DB * db ;
const DBT * key1 ;
const DBT * key2 ;
#endif /* CAN_PROTOTYPE */

#else /* Berkeley DB < 3.2 */

#ifdef CAN_PROTOTYPE
btree_compare(const DBT *key1, const DBT *key2)
#else
btree_compare(key1, key2)
const DBT * key1 ;
const DBT * key2 ;
#endif

#endif

{
#ifdef dTHX
    dTHX;
#endif    
    dSP ;
    dMY_CXT ;
    void * data1, * data2 ;
    int retval ;
    int count ;
    

    if (CurrentDB->in_compare) {
        tidyUp(CurrentDB);
        croak ("DB_File btree_compare: recursion detected\n") ;
    }

    data1 = (char *) key1->data ;
    data2 = (char *) key2->data ;

#ifndef newSVpvn
    /* As newSVpv will assume that the data pointer is a null terminated C 
       string if the size parameter is 0, make sure that data points to an 
       empty string if the length is 0
    */
    if (key1->size == 0)
        data1 = "" ; 
    if (key2->size == 0)
        data2 = "" ;
#endif	

    ENTER ;
    SAVETMPS;
    SAVESPTR(CurrentDB);
    CurrentDB->in_compare = FALSE;
    SAVEINT(CurrentDB->in_compare);
    CurrentDB->in_compare = TRUE;

    PUSHMARK(SP) ;
    EXTEND(SP,2) ;
    PUSHs(sv_2mortal(newSVpvn((const char*)data1,key1->size)));
    PUSHs(sv_2mortal(newSVpvn((const char*)data2,key2->size)));
    PUTBACK ;

    count = perl_call_sv(CurrentDB->compare, G_SCALAR); 

    SPAGAIN ;

    if (count != 1){
        tidyUp(CurrentDB);
        croak ("DB_File btree_compare: expected 1 return value from compare sub, got %d\n", count) ;
    }

    retval = POPi ;

    PUTBACK ;
    FREETMPS ;
    LEAVE ;

    return (retval) ;

}

static DB_Prefix_t
#ifdef AT_LEAST_DB_3_2

#ifdef CAN_PROTOTYPE
btree_prefix(DB * db, const DBT *key1, const DBT *key2)
#else
btree_prefix(db, key1, key2)
Db * db ;
const DBT * key1 ;
const DBT * key2 ;
#endif

#else /* Berkeley DB < 3.2 */

#ifdef CAN_PROTOTYPE
btree_prefix(const DBT *key1, const DBT *key2)
#else
btree_prefix(key1, key2)
const DBT * key1 ;
const DBT * key2 ;
#endif

#endif
{
#ifdef dTHX
    dTHX;
#endif    
    dSP ;
    dMY_CXT ;
    char * data1, * data2 ;
    int retval ;
    int count ;
    
    if (CurrentDB->in_prefix){
        tidyUp(CurrentDB);
        croak ("DB_File btree_prefix: recursion detected\n") ;
    }

    data1 = (char *) key1->data ;
    data2 = (char *) key2->data ;

#ifndef newSVpvn
    /* As newSVpv will assume that the data pointer is a null terminated C 
       string if the size parameter is 0, make sure that data points to an 
       empty string if the length is 0
    */
    if (key1->size == 0)
        data1 = "" ;
    if (key2->size == 0)
        data2 = "" ;
#endif	

    ENTER ;
    SAVETMPS;
    SAVESPTR(CurrentDB);
    CurrentDB->in_prefix = FALSE;
    SAVEINT(CurrentDB->in_prefix);
    CurrentDB->in_prefix = TRUE;

    PUSHMARK(SP) ;
    EXTEND(SP,2) ;
    PUSHs(sv_2mortal(newSVpvn(data1,key1->size)));
    PUSHs(sv_2mortal(newSVpvn(data2,key2->size)));
    PUTBACK ;

    count = perl_call_sv(CurrentDB->prefix, G_SCALAR); 

    SPAGAIN ;

    if (count != 1){
        tidyUp(CurrentDB);
        croak ("DB_File btree_prefix: expected 1 return value from prefix sub, got %d\n", count) ;
    }
 
    retval = POPi ;
 
    PUTBACK ;
    FREETMPS ;
    LEAVE ;

    return (retval) ;
}


#ifdef BERKELEY_DB_1
#    define HASH_CB_SIZE_TYPE size_t
#else
#    define HASH_CB_SIZE_TYPE u_int32_t
#endif

static DB_Hash_t
#ifdef AT_LEAST_DB_3_2

#ifdef CAN_PROTOTYPE
hash_cb(DB * db, const void *data, u_int32_t size)
#else
hash_cb(db, data, size)
DB * db ;
const void * data ;
HASH_CB_SIZE_TYPE size ;
#endif

#else /* Berkeley DB < 3.2 */

#ifdef CAN_PROTOTYPE
hash_cb(const void *data, HASH_CB_SIZE_TYPE size)
#else
hash_cb(data, size)
const void * data ;
HASH_CB_SIZE_TYPE size ;
#endif

#endif
{
#ifdef dTHX
    dTHX;
#endif    
    dSP ;
    dMY_CXT;
    int retval = 0;
    int count ;

    if (CurrentDB->in_hash){
        tidyUp(CurrentDB);
        croak ("DB_File hash callback: recursion detected\n") ;
    }

#ifndef newSVpvn
    if (size == 0)
        data = "" ;
#endif	

     /* DGH - Next two lines added to fix corrupted stack problem */
    ENTER ;
    SAVETMPS;
    SAVESPTR(CurrentDB);
    CurrentDB->in_hash = FALSE;
    SAVEINT(CurrentDB->in_hash);
    CurrentDB->in_hash = TRUE;

    PUSHMARK(SP) ;


    XPUSHs(sv_2mortal(newSVpvn((char*)data,size)));
    PUTBACK ;

    count = perl_call_sv(CurrentDB->hash, G_SCALAR); 

    SPAGAIN ;

    if (count != 1){
        tidyUp(CurrentDB);
        croak ("DB_File hash_cb: expected 1 return value from hash sub, got %d\n", count) ;
    }

    retval = POPi ;

    PUTBACK ;
    FREETMPS ;
    LEAVE ;

    return (retval) ;
}

#ifdef WANT_ERROR

static void
#ifdef AT_LEAST_DB_4_3
db_errcall_cb(const DB_ENV* dbenv, const char * db_errpfx, const char * buffer)
#else
db_errcall_cb(const char * db_errpfx, char * buffer)
#endif
{
#ifdef dTHX
    dTHX;
#endif    
    SV * sv = perl_get_sv(ERR_BUFF, FALSE) ;
    if (sv) {
        if (db_errpfx)
            sv_setpvf(sv, "%s: %s", db_errpfx, buffer) ;
        else
            sv_setpv(sv, buffer) ;
    }
} 
#endif

#if defined(TRACE) && defined(BERKELEY_DB_1_OR_2)

static void
#ifdef CAN_PROTOTYPE
PrintHash(INFO *hash)
#else
PrintHash(hash)
INFO * hash ;
#endif
{
    printf ("HASH Info\n") ;
    printf ("  hash      = %s\n", 
		(hash->db_HA_hash != NULL ? "redefined" : "default")) ;
    printf ("  bsize     = %d\n", hash->db_HA_bsize) ;
    printf ("  ffactor   = %d\n", hash->db_HA_ffactor) ;
    printf ("  nelem     = %d\n", hash->db_HA_nelem) ;
    printf ("  cachesize = %d\n", hash->db_HA_cachesize) ;
    printf ("  lorder    = %d\n", hash->db_HA_lorder) ;

}

static void
#ifdef CAN_PROTOTYPE
PrintRecno(INFO *recno)
#else
PrintRecno(recno)
INFO * recno ;
#endif
{
    printf ("RECNO Info\n") ;
    printf ("  flags     = %d\n", recno->db_RE_flags) ;
    printf ("  cachesize = %d\n", recno->db_RE_cachesize) ;
    printf ("  psize     = %d\n", recno->db_RE_psize) ;
    printf ("  lorder    = %d\n", recno->db_RE_lorder) ;
    printf ("  reclen    = %lu\n", (unsigned long)recno->db_RE_reclen) ;
    printf ("  bval      = %d 0x%x\n", recno->db_RE_bval, recno->db_RE_bval) ;
    printf ("  bfname    = %d [%s]\n", recno->db_RE_bfname, recno->db_RE_bfname) ;
}

static void
#ifdef CAN_PROTOTYPE
PrintBtree(INFO *btree)
#else
PrintBtree(btree)
INFO * btree ;
#endif
{
    printf ("BTREE Info\n") ;
    printf ("  compare    = %s\n", 
		(btree->db_BT_compare ? "redefined" : "default")) ;
    printf ("  prefix     = %s\n", 
		(btree->db_BT_prefix ? "redefined" : "default")) ;
    printf ("  flags      = %d\n", btree->db_BT_flags) ;
    printf ("  cachesize  = %d\n", btree->db_BT_cachesize) ;
    printf ("  psize      = %d\n", btree->db_BT_psize) ;
#ifndef DB_VERSION_MAJOR
    printf ("  maxkeypage = %d\n", btree->db_BT_maxkeypage) ;
    printf ("  minkeypage = %d\n", btree->db_BT_minkeypage) ;
#endif
    printf ("  lorder     = %d\n", btree->db_BT_lorder) ;
}

#else

#define PrintRecno(recno)
#define PrintHash(hash)
#define PrintBtree(btree)

#endif /* TRACE */


static I32
#ifdef CAN_PROTOTYPE
GetArrayLength(pTHX_ DB_File db)
#else
GetArrayLength(db)
DB_File db ;
#endif
{
    DBT		key ;
    DBT		value ;
    int		RETVAL ;

    DBT_clear(key) ;
    DBT_clear(value) ;
    RETVAL = do_SEQ(db, key, value, R_LAST) ;
    if (RETVAL == 0)
        RETVAL = *(I32 *)key.data ;
    else /* No key means empty file */
        RETVAL = 0 ;

    return ((I32)RETVAL) ;
}

static recno_t
#ifdef CAN_PROTOTYPE
GetRecnoKey(pTHX_ DB_File db, I32 value)
#else
GetRecnoKey(db, value)
DB_File  db ;
I32      value ;
#endif
{
    if (value < 0) {
	/* Get the length of the array */
	I32 length = GetArrayLength(aTHX_ db) ;

	/* check for attempt to write before start of array */
	if (length + value + 1 <= 0) {
            tidyUp(db);
	    croak("Modification of non-creatable array value attempted, subscript %ld", (long)value) ;
	}

	value = length + value + 1 ;
    }
    else
        ++ value ;

    return value ;
}


static DB_File
#ifdef CAN_PROTOTYPE
ParseOpenInfo(pTHX_ int isHASH, char *name, int flags, int mode, SV *sv)
#else
ParseOpenInfo(isHASH, name, flags, mode, sv)
int    isHASH ;
char * name ;
int    flags ;
int    mode ;
SV *   sv ;
#endif
{

#ifdef BERKELEY_DB_1_OR_2 /* Berkeley DB Version 1  or 2 */

    SV **	svp;
    HV *	action ;
    DB_File	RETVAL = (DB_File)safemalloc(sizeof(DB_File_type)) ;
    void *	openinfo = NULL ;
    INFO	* info  = &RETVAL->info ;
    STRLEN	n_a;
    dMY_CXT;

#ifdef TRACE    
    printf("In ParseOpenInfo name=[%s] flags=[%d] mode=[%d] SV NULL=[%d]\n", 
		    name, flags, mode, sv == NULL) ;  
#endif
    Zero(RETVAL, 1, DB_File_type) ;

    /* Default to HASH */
    RETVAL->filtering = 0 ;
    RETVAL->filter_fetch_key = RETVAL->filter_store_key = 
    RETVAL->filter_fetch_value = RETVAL->filter_store_value =
    RETVAL->hash = RETVAL->compare = RETVAL->prefix = NULL ;
    RETVAL->type = DB_HASH ;

     /* DGH - Next line added to avoid SEGV on existing hash DB */
    CurrentDB = RETVAL; 

    /* fd for 1.86 hash in memory files doesn't return -1 like 1.85 */
    RETVAL->in_memory = (name == NULL) ;

    if (sv)
    {
        if (! SvROK(sv) )
            croak ("type parameter is not a reference") ;

        svp  = hv_fetch( (HV*)SvRV(sv), "GOT", 3, FALSE) ;
        if (svp && SvOK(*svp))
            action  = (HV*) SvRV(*svp) ;
	else
	    croak("internal error") ;

        if (sv_isa(sv, "DB_File::HASHINFO"))
        {

	    if (!isHASH)
	        croak("DB_File can only tie an associative array to a DB_HASH database") ;

            RETVAL->type = DB_HASH ;
            openinfo = (void*)info ;
  
            svp = hv_fetch(action, "hash", 4, FALSE); 

            if (svp && SvOK(*svp))
            {
                info->db_HA_hash = hash_cb ;
		RETVAL->hash = newSVsv(*svp) ;
            }
            else
	        info->db_HA_hash = NULL ;

           svp = hv_fetch(action, "ffactor", 7, FALSE);
           info->db_HA_ffactor = svp ? SvIV(*svp) : 0;
         
           svp = hv_fetch(action, "nelem", 5, FALSE);
           info->db_HA_nelem = svp ? SvIV(*svp) : 0;
         
           svp = hv_fetch(action, "bsize", 5, FALSE);
           info->db_HA_bsize = svp ? SvIV(*svp) : 0;
           
           svp = hv_fetch(action, "cachesize", 9, FALSE);
           info->db_HA_cachesize = svp ? SvIV(*svp) : 0;
         
           svp = hv_fetch(action, "lorder", 6, FALSE);
           info->db_HA_lorder = svp ? SvIV(*svp) : 0;

           PrintHash(info) ; 
        }
        else if (sv_isa(sv, "DB_File::BTREEINFO"))
        {
	    if (!isHASH)
	        croak("DB_File can only tie an associative array to a DB_BTREE database");

            RETVAL->type = DB_BTREE ;
            openinfo = (void*)info ;
   
            svp = hv_fetch(action, "compare", 7, FALSE);
            if (svp && SvOK(*svp))
            {
                info->db_BT_compare = btree_compare ;
		RETVAL->compare = newSVsv(*svp) ;
            }
            else
                info->db_BT_compare = NULL ;

            svp = hv_fetch(action, "prefix", 6, FALSE);
            if (svp && SvOK(*svp))
            {
                info->db_BT_prefix = btree_prefix ;
		RETVAL->prefix = newSVsv(*svp) ;
            }
            else
                info->db_BT_prefix = NULL ;

            svp = hv_fetch(action, "flags", 5, FALSE);
            info->db_BT_flags = svp ? SvIV(*svp) : 0;
   
            svp = hv_fetch(action, "cachesize", 9, FALSE);
            info->db_BT_cachesize = svp ? SvIV(*svp) : 0;
         
#ifndef DB_VERSION_MAJOR
            svp = hv_fetch(action, "minkeypage", 10, FALSE);
            info->btree.minkeypage = svp ? SvIV(*svp) : 0;
        
            svp = hv_fetch(action, "maxkeypage", 10, FALSE);
            info->btree.maxkeypage = svp ? SvIV(*svp) : 0;
#endif

            svp = hv_fetch(action, "psize", 5, FALSE);
            info->db_BT_psize = svp ? SvIV(*svp) : 0;
         
            svp = hv_fetch(action, "lorder", 6, FALSE);
            info->db_BT_lorder = svp ? SvIV(*svp) : 0;

            PrintBtree(info) ;
         
        }
        else if (sv_isa(sv, "DB_File::RECNOINFO"))
        {
	    if (isHASH)
	        croak("DB_File can only tie an array to a DB_RECNO database");

            RETVAL->type = DB_RECNO ;
            openinfo = (void *)info ;

	    info->db_RE_flags = 0 ;

            svp = hv_fetch(action, "flags", 5, FALSE);
            info->db_RE_flags = (u_long) (svp ? SvIV(*svp) : 0);
         
            svp = hv_fetch(action, "reclen", 6, FALSE);
            info->db_RE_reclen = (size_t) (svp ? SvIV(*svp) : 0);
         
            svp = hv_fetch(action, "cachesize", 9, FALSE);
            info->db_RE_cachesize = (u_int) (svp ? SvIV(*svp) : 0);
         
            svp = hv_fetch(action, "psize", 5, FALSE);
            info->db_RE_psize = (u_int) (svp ? SvIV(*svp) : 0);
         
            svp = hv_fetch(action, "lorder", 6, FALSE);
            info->db_RE_lorder = (int) (svp ? SvIV(*svp) : 0);

#ifdef DB_VERSION_MAJOR
	    info->re_source = name ;
	    name = NULL ;
#endif
            svp = hv_fetch(action, "bfname", 6, FALSE); 
            if (svp && SvOK(*svp)) {
		char * ptr = SvPV(*svp,n_a) ;
#ifdef DB_VERSION_MAJOR
		name = (char*) n_a ? ptr : NULL ;
#else
                info->db_RE_bfname = (char*) (n_a ? ptr : NULL) ;
#endif
	    }
	    else
#ifdef DB_VERSION_MAJOR
		name = NULL ;
#else
                info->db_RE_bfname = NULL ;
#endif
         
	    svp = hv_fetch(action, "bval", 4, FALSE);
#ifdef DB_VERSION_MAJOR
            if (svp && SvOK(*svp))
            {
		int value ;
                if (SvPOK(*svp))
		    value = (int)*SvPV(*svp, n_a) ;
		else
		    value = SvIV(*svp) ;

		if (info->flags & DB_FIXEDLEN) {
		    info->re_pad = value ;
		    info->flags |= DB_PAD ;
		}
		else {
		    info->re_delim = value ;
		    info->flags |= DB_DELIMITER ;
		}

            }
#else
            if (svp && SvOK(*svp))
            {
                if (SvPOK(*svp))
		    info->db_RE_bval = (u_char)*SvPV(*svp, n_a) ;
		else
		    info->db_RE_bval = (u_char)(unsigned long) SvIV(*svp) ;
		DB_flags(info->flags, DB_DELIMITER) ;

            }
            else
 	    {
		if (info->db_RE_flags & R_FIXEDLEN)
                    info->db_RE_bval = (u_char) ' ' ;
		else
                    info->db_RE_bval = (u_char) '\n' ;
		DB_flags(info->flags, DB_DELIMITER) ;
	    }
#endif

#ifdef DB_RENUMBER
	    info->flags |= DB_RENUMBER ;
#endif
         
            PrintRecno(info) ;
        }
        else
            croak("type is not of type DB_File::HASHINFO, DB_File::BTREEINFO or DB_File::RECNOINFO");
    }


    /* OS2 Specific Code */
#ifdef OS2
#ifdef __EMX__
    flags |= O_BINARY;
#endif /* __EMX__ */
#endif /* OS2 */

#ifdef DB_VERSION_MAJOR

    {
        int	 	Flags = 0 ;
        int		status ;

        /* Map 1.x flags to 2.x flags */
        if ((flags & O_CREAT) == O_CREAT)
            Flags |= DB_CREATE ;

#if O_RDONLY == 0
        if (flags == O_RDONLY)
#else
        if ((flags & O_RDONLY) == O_RDONLY && (flags & O_RDWR) != O_RDWR)
#endif
            Flags |= DB_RDONLY ;

#ifdef O_TRUNC
        if ((flags & O_TRUNC) == O_TRUNC)
            Flags |= DB_TRUNCATE ;
#endif

        status = db_open(name, RETVAL->type, Flags, mode, NULL, (DB_INFO*)openinfo, &RETVAL->dbp) ; 
        if (status == 0)
#if DB_VERSION_MAJOR == 2 && DB_VERSION_MINOR < 6
            status = (RETVAL->dbp->cursor)(RETVAL->dbp, NULL, &RETVAL->cursor) ;
#else
            status = (RETVAL->dbp->cursor)(RETVAL->dbp, NULL, &RETVAL->cursor,
			0) ;
#endif

        if (status)
	    RETVAL->dbp = NULL ;

    }
#else

#if defined(DB_LIBRARY_COMPATIBILITY_API) && DB_VERSION_MAJOR > 2
    RETVAL->dbp = __db185_open(name, flags, mode, RETVAL->type, openinfo) ; 
#else    
    RETVAL->dbp = dbopen(name, flags, mode, RETVAL->type, openinfo) ; 
#endif /* DB_LIBRARY_COMPATIBILITY_API */

#endif

    return (RETVAL) ;

#else /* Berkeley DB Version > 2 */

    SV **	svp;
    HV *	action ;
    DB_File	RETVAL = (DB_File)safemalloc(sizeof(DB_File_type)) ;
    DB *	dbp ;
    STRLEN	n_a;
    int		status ;
    dMY_CXT;

/* printf("In ParseOpenInfo name=[%s] flags=[%d] mode = [%d]\n", name, flags, mode) ;  */
    Zero(RETVAL, 1, DB_File_type) ;

    /* Default to HASH */
    RETVAL->filtering = 0 ;
    RETVAL->filter_fetch_key = RETVAL->filter_store_key = 
    RETVAL->filter_fetch_value = RETVAL->filter_store_value =
    RETVAL->hash = RETVAL->compare = RETVAL->prefix = NULL ;
    RETVAL->type = DB_HASH ;

     /* DGH - Next line added to avoid SEGV on existing hash DB */
    CurrentDB = RETVAL; 

    /* fd for 1.86 hash in memory files doesn't return -1 like 1.85 */
    RETVAL->in_memory = (name == NULL) ;

    status = db_create(&RETVAL->dbp, NULL,0) ;
    /* printf("db_create returned %d %s\n", status, db_strerror(status)) ; */
    if (status) {
	RETVAL->dbp = NULL ;
        return (RETVAL) ;
    }	
    dbp = RETVAL->dbp ;

#ifdef WANT_ERROR
	    RETVAL->dbp->set_errcall(RETVAL->dbp, db_errcall_cb) ;
#endif
    if (sv)
    {
        if (! SvROK(sv) )
            croak ("type parameter is not a reference") ;

        svp  = hv_fetch( (HV*)SvRV(sv), "GOT", 3, FALSE) ;
        if (svp && SvOK(*svp))
            action  = (HV*) SvRV(*svp) ;
	else
	    croak("internal error") ;

        if (sv_isa(sv, "DB_File::HASHINFO"))
        {

	    if (!isHASH)
	        croak("DB_File can only tie an associative array to a DB_HASH database") ;

            RETVAL->type = DB_HASH ;
  
            svp = hv_fetch(action, "hash", 4, FALSE); 

            if (svp && SvOK(*svp))
            {
		(void)dbp->set_h_hash(dbp, hash_cb) ;
		RETVAL->hash = newSVsv(*svp) ;
            }

           svp = hv_fetch(action, "ffactor", 7, FALSE);
	   if (svp)
	       (void)dbp->set_h_ffactor(dbp, my_SvUV32(*svp)) ;
         
           svp = hv_fetch(action, "nelem", 5, FALSE);
	   if (svp)
               (void)dbp->set_h_nelem(dbp, my_SvUV32(*svp)) ;
         
           svp = hv_fetch(action, "bsize", 5, FALSE);
	   if (svp)
               (void)dbp->set_pagesize(dbp, my_SvUV32(*svp));
           
           svp = hv_fetch(action, "cachesize", 9, FALSE);
	   if (svp)
               (void)dbp->set_cachesize(dbp, 0, my_SvUV32(*svp), 0) ;
         
           svp = hv_fetch(action, "lorder", 6, FALSE);
	   if (svp)
               (void)dbp->set_lorder(dbp, (int)SvIV(*svp)) ;

           PrintHash(info) ; 
        }
        else if (sv_isa(sv, "DB_File::BTREEINFO"))
        {
	    if (!isHASH)
	        croak("DB_File can only tie an associative array to a DB_BTREE database");

            RETVAL->type = DB_BTREE ;
   
            svp = hv_fetch(action, "compare", 7, FALSE);
            if (svp && SvOK(*svp))
            {
                (void)dbp->set_bt_compare(dbp, btree_compare) ;
		RETVAL->compare = newSVsv(*svp) ;
            }

            svp = hv_fetch(action, "prefix", 6, FALSE);
            if (svp && SvOK(*svp))
            {
                (void)dbp->set_bt_prefix(dbp, btree_prefix) ;
		RETVAL->prefix = newSVsv(*svp) ;
            }

           svp = hv_fetch(action, "flags", 5, FALSE);
	   if (svp)
	       (void)dbp->set_flags(dbp, my_SvUV32(*svp)) ;
   
           svp = hv_fetch(action, "cachesize", 9, FALSE);
	   if (svp)
               (void)dbp->set_cachesize(dbp, 0, my_SvUV32(*svp), 0) ;
         
           svp = hv_fetch(action, "psize", 5, FALSE);
	   if (svp)
               (void)dbp->set_pagesize(dbp, my_SvUV32(*svp)) ;
         
           svp = hv_fetch(action, "lorder", 6, FALSE);
	   if (svp)
               (void)dbp->set_lorder(dbp, (int)SvIV(*svp)) ;

            PrintBtree(info) ;
         
        }
        else if (sv_isa(sv, "DB_File::RECNOINFO"))
        {
	    int fixed = FALSE ;

	    if (isHASH)
	        croak("DB_File can only tie an array to a DB_RECNO database");

            RETVAL->type = DB_RECNO ;

           svp = hv_fetch(action, "flags", 5, FALSE);
	   if (svp) {
		int flags = SvIV(*svp) ;
		/* remove FIXDLEN, if present */
		if (flags & DB_FIXEDLEN) {
		    fixed = TRUE ;
		    flags &= ~DB_FIXEDLEN ;
	   	}
	   }

           svp = hv_fetch(action, "cachesize", 9, FALSE);
	   if (svp) {
               status = dbp->set_cachesize(dbp, 0, my_SvUV32(*svp), 0) ;
	   }
         
           svp = hv_fetch(action, "psize", 5, FALSE);
	   if (svp) {
               status = dbp->set_pagesize(dbp, my_SvUV32(*svp)) ;
	    }
         
           svp = hv_fetch(action, "lorder", 6, FALSE);
	   if (svp) {
               status = dbp->set_lorder(dbp, (int)SvIV(*svp)) ;
	   }

	    svp = hv_fetch(action, "bval", 4, FALSE);
            if (svp && SvOK(*svp))
            {
		int value ;
                if (SvPOK(*svp))
		    value = (int)*SvPV(*svp, n_a) ;
		else
		    value = (int)SvIV(*svp) ;

		if (fixed) {
		    status = dbp->set_re_pad(dbp, value) ;
		}
		else {
		    status = dbp->set_re_delim(dbp, value) ;
		}

            }

	   if (fixed) {
               svp = hv_fetch(action, "reclen", 6, FALSE);
	       if (svp) {
		   u_int32_t len =  my_SvUV32(*svp) ;
                   status = dbp->set_re_len(dbp, len) ;
	       }    
	   }
         
	    if (name != NULL) {
	        status = dbp->set_re_source(dbp, name) ;
	        name = NULL ;
	    }	

            svp = hv_fetch(action, "bfname", 6, FALSE); 
            if (svp && SvOK(*svp)) {
		char * ptr = SvPV(*svp,n_a) ;
		name = (char*) n_a ? ptr : NULL ;
	    }
	    else
		name = NULL ;
         

	    status = dbp->set_flags(dbp, (u_int32_t)DB_RENUMBER) ;
         
		if (flags){
	            (void)dbp->set_flags(dbp, (u_int32_t)flags) ;
		}
            PrintRecno(info) ;
        }
        else
            croak("type is not of type DB_File::HASHINFO, DB_File::BTREEINFO or DB_File::RECNOINFO");
    }

    {
        u_int32_t 	Flags = 0 ;
        int		status ;

        /* Map 1.x flags to 3.x flags */
        if ((flags & O_CREAT) == O_CREAT)
            Flags |= DB_CREATE ;

#if O_RDONLY == 0
        if (flags == O_RDONLY)
#else
        if ((flags & O_RDONLY) == O_RDONLY && (flags & O_RDWR) != O_RDWR)
#endif
            Flags |= DB_RDONLY ;

#ifdef O_TRUNC
        if ((flags & O_TRUNC) == O_TRUNC)
            Flags |= DB_TRUNCATE ;
#endif

#ifdef AT_LEAST_DB_4_4
        /* need this for recno */
        if ((flags & O_TRUNC) == O_TRUNC)
            Flags |= DB_CREATE ;
#endif

#ifdef AT_LEAST_DB_4_1
        status = (RETVAL->dbp->open)(RETVAL->dbp, NULL, name, NULL, RETVAL->type, 
	    			Flags, mode) ; 
#else
        status = (RETVAL->dbp->open)(RETVAL->dbp, name, NULL, RETVAL->type, 
	    			Flags, mode) ; 
#endif
	/* printf("open returned %d %s\n", status, db_strerror(status)) ; */

        if (status == 0) {

            status = (RETVAL->dbp->cursor)(RETVAL->dbp, NULL, &RETVAL->cursor,
			0) ;
	    /* printf("cursor returned %d %s\n", status, db_strerror(status)) ; */
	}

        if (status)
	    RETVAL->dbp = NULL ;

    }

    return (RETVAL) ;

#endif /* Berkeley DB Version > 2 */

} /* ParseOpenInfo */


#include "constants.h"   

MODULE = DB_File	PACKAGE = DB_File	PREFIX = db_

INCLUDE: constants.xs

BOOT:
  {
#ifdef dTHX
    dTHX;
#endif    
#ifdef WANT_ERROR
    SV * sv_err = perl_get_sv(ERR_BUFF, GV_ADD|GV_ADDMULTI) ; 
#endif
    MY_CXT_INIT;
    __getBerkeleyDBInfo() ;
 
    DBT_clear(empty) ; 
    empty.data = &zero ;
    empty.size =  sizeof(recno_t) ;
  }



DB_File
db_DoTie_(isHASH, dbtype, name=undef, flags=O_CREAT|O_RDWR, mode=0666, type=DB_HASH)
	int		isHASH
	char *		dbtype
	int		flags
	int		mode
	CODE:
	{
	    char *	name = (char *) NULL ; 
	    SV *	sv = (SV *) NULL ; 
	    STRLEN	n_a;

	    if (items >= 3 && SvOK(ST(2))) 
	        name = (char*) SvPV(ST(2), n_a) ; 

            if (items == 6)
	        sv = ST(5) ;

	    RETVAL = ParseOpenInfo(aTHX_ isHASH, name, flags, mode, sv) ;
	    if (RETVAL->dbp == NULL) {
	        Safefree(RETVAL);
	        RETVAL = NULL ;
	    }
	}
	OUTPUT:	
	    RETVAL

int
db_DESTROY(db)
	DB_File		db
	PREINIT:
	  dMY_CXT;
	INIT:
	  CurrentDB = db ;
	  Trace(("DESTROY %p\n", db));
	CLEANUP:
	  Trace(("DESTROY %p done\n", db));
	  if (db->hash)
	    SvREFCNT_dec(db->hash) ;
	  if (db->compare)
	    SvREFCNT_dec(db->compare) ;
	  if (db->prefix)
	    SvREFCNT_dec(db->prefix) ;
	  if (db->filter_fetch_key)
	    SvREFCNT_dec(db->filter_fetch_key) ;
	  if (db->filter_store_key)
	    SvREFCNT_dec(db->filter_store_key) ;
	  if (db->filter_fetch_value)
	    SvREFCNT_dec(db->filter_fetch_value) ;
	  if (db->filter_store_value)
	    SvREFCNT_dec(db->filter_store_value) ;
	  safefree(db) ;
#ifdef DB_VERSION_MAJOR
	  if (RETVAL > 0)
	    RETVAL = -1 ;
#endif


int
db_DELETE(db, key, flags=0)
	DB_File		db
	DBTKEY		key
	u_int		flags
	PREINIT:
	  dMY_CXT;
	INIT:
	  CurrentDB = db ;


int
db_EXISTS(db, key)
	DB_File		db
	DBTKEY		key
	PREINIT:
	  dMY_CXT;
	CODE:
	{
          DBT		value ;
	
	  DBT_clear(value) ; 
	  CurrentDB = db ;
	  RETVAL = (((db->dbp)->get)(db->dbp, TXN &key, &value, 0) == 0) ;
	}
	OUTPUT:
	  RETVAL

void
db_FETCH(db, key, flags=0)
	DB_File		db
	DBTKEY		key
	u_int		flags
	PREINIT:
	  dMY_CXT ;
	  int RETVAL ;
	CODE:
	{
            DBT		value ;

	    DBT_clear(value) ; 
	    CurrentDB = db ;
	    RETVAL = db_get(db, key, value, flags) ;
	    ST(0) = sv_newmortal();
	    OutputValue(ST(0), value)
	}

int
db_STORE(db, key, value, flags=0)
	DB_File		db
	DBTKEY		key
	DBT		value
	u_int		flags
	PREINIT:
	  dMY_CXT;
	INIT:
	  CurrentDB = db ;


void
db_FIRSTKEY(db)
	DB_File		db
	PREINIT:
	  dMY_CXT ;
	  int RETVAL ;
	CODE:
	{
	    DBTKEY	key ;
	    DBT		value ;

	    DBT_clear(key) ; 
	    DBT_clear(value) ; 
	    CurrentDB = db ;
	    RETVAL = do_SEQ(db, key, value, R_FIRST) ;
	    ST(0) = sv_newmortal();
	    OutputKey(ST(0), key) ;
	}

void
db_NEXTKEY(db, key)
	DB_File		db
	DBTKEY		key = NO_INIT
	PREINIT:
	  dMY_CXT ;
	  int RETVAL ;
	CODE:
	{
	    DBT		value ;

	    DBT_clear(key) ; 
	    DBT_clear(value) ; 
	    CurrentDB = db ;
	    RETVAL = do_SEQ(db, key, value, R_NEXT) ;
	    ST(0) = sv_newmortal();
	    OutputKey(ST(0), key) ;
	}

#
# These would be nice for RECNO
#

int
unshift(db, ...)
	DB_File		db
	ALIAS:		UNSHIFT = 1
	PREINIT:
	  dMY_CXT;
	CODE:
	{
	    DBTKEY	key ;
	    DBT		value ;
	    int		i ;
	    int		One ;
	    STRLEN	n_a;

	    DBT_clear(key) ; 
	    DBT_clear(value) ; 
	    CurrentDB = db ;
#ifdef DB_VERSION_MAJOR
	    /* get the first value */
	    RETVAL = do_SEQ(db, key, value, DB_FIRST) ;	 
	    RETVAL = 0 ;
#else
	    RETVAL = -1 ;
#endif
	    for (i = items-1 ; i > 0 ; --i)
	    {
		DBM_ckFilter(ST(i), filter_store_value, "filter_store_value");
	        value.data = SvPVbyte(ST(i), n_a) ;
	        value.size = n_a ;
	        One = 1 ;
	        key.data = &One ;
	        key.size = sizeof(int) ;
#ifdef DB_VERSION_MAJOR
           	RETVAL = (db->cursor->c_put)(db->cursor, &key, &value, DB_BEFORE) ;
#else
	        RETVAL = (db->dbp->put)(db->dbp, &key, &value, R_IBEFORE) ;
#endif
	        if (RETVAL != 0)
	            break;
	    }
	}
	OUTPUT:
	    RETVAL

void
pop(db)
	DB_File		db
	PREINIT:
	  dMY_CXT;
	ALIAS:		POP = 1
	PREINIT:
	  I32 RETVAL;
	CODE:
	{
	    DBTKEY	key ;
	    DBT		value ;

	    DBT_clear(key) ; 
	    DBT_clear(value) ; 
	    CurrentDB = db ;

	    /* First get the final value */
	    RETVAL = do_SEQ(db, key, value, R_LAST) ;	 
	    ST(0) = sv_newmortal();
	    /* Now delete it */
	    if (RETVAL == 0)
	    {
		/* the call to del will trash value, so take a copy now */
		OutputValue(ST(0), value) ;
	        RETVAL = db_del(db, key, R_CURSOR) ;
	        if (RETVAL != 0) 
	            sv_setsv(ST(0), &PL_sv_undef); 
	    }
	}

void
shift(db)
	DB_File		db
	PREINIT:
	  dMY_CXT;
	ALIAS:		SHIFT = 1
	PREINIT:
	  I32 RETVAL;
	CODE:
	{
	    DBT		value ;
	    DBTKEY	key ;

	    DBT_clear(key) ; 
	    DBT_clear(value) ; 
	    CurrentDB = db ;
	    /* get the first value */
	    RETVAL = do_SEQ(db, key, value, R_FIRST) ;	 
	    ST(0) = sv_newmortal();
	    /* Now delete it */
	    if (RETVAL == 0)
	    {
		/* the call to del will trash value, so take a copy now */
		OutputValue(ST(0), value) ;
	        RETVAL = db_del(db, key, R_CURSOR) ;
	        if (RETVAL != 0)
	            sv_setsv (ST(0), &PL_sv_undef) ;
	    }
	}


I32
push(db, ...)
	DB_File		db
	PREINIT:
	  dMY_CXT;
	ALIAS:		PUSH = 1
	CODE:
	{
	    DBTKEY	key ;
	    DBT		value ;
	    DB *	Db = db->dbp ;
	    int		i ;
	    STRLEN	n_a;
	    int		keyval ;

	    DBT_flags(key) ; 
	    DBT_flags(value) ; 
	    CurrentDB = db ;
	    /* Set the Cursor to the Last element */
	    RETVAL = do_SEQ(db, key, value, R_LAST) ;
#ifndef DB_VERSION_MAJOR		    		    
	    if (RETVAL >= 0)
#endif	    
	    {
	    	if (RETVAL == 0)
		    keyval = *(int*)key.data ;
		else
		    keyval = 0 ;
	        for (i = 1 ; i < items ; ++i)
	        {
		    DBM_ckFilter(ST(i), filter_store_value, "filter_store_value");
	            value.data = SvPVbyte(ST(i), n_a) ;
	            value.size = n_a ;
		    ++ keyval ;
	            key.data = &keyval ;
	            key.size = sizeof(int) ;
		    RETVAL = (Db->put)(Db, TXN &key, &value, 0) ;
	            if (RETVAL != 0)
	                break;
	        }
	    }
	}
	OUTPUT:
	    RETVAL

I32
length(db)
	DB_File		db
	PREINIT:
	  dMY_CXT;
	ALIAS:		FETCHSIZE = 1
	CODE:
	    CurrentDB = db ;
	    RETVAL = GetArrayLength(aTHX_ db) ;
	OUTPUT:
	    RETVAL


#
# Now provide an interface to the rest of the DB functionality
#

int
db_del(db, key, flags=0)
	DB_File		db
	DBTKEY		key
	u_int		flags
	PREINIT:
	  dMY_CXT;
	CODE:
	  CurrentDB = db ;
	  RETVAL = db_del(db, key, flags) ;
#ifdef DB_VERSION_MAJOR
	  if (RETVAL > 0)
	    RETVAL = -1 ;
	  else if (RETVAL == DB_NOTFOUND)
	    RETVAL = 1 ;
#endif
	OUTPUT:
	  RETVAL


int
db_get(db, key, value, flags=0)
	DB_File		db
	DBTKEY		key
	DBT		value = NO_INIT
	u_int		flags
	PREINIT:
	  dMY_CXT;
	CODE:
	  CurrentDB = db ;
	  DBT_clear(value) ; 
	  RETVAL = db_get(db, key, value, flags) ;
#ifdef DB_VERSION_MAJOR
	  if (RETVAL > 0)
	    RETVAL = -1 ;
	  else if (RETVAL == DB_NOTFOUND)
	    RETVAL = 1 ;
#endif
	OUTPUT:
	  RETVAL
	  value

int
db_put(db, key, value, flags=0)
	DB_File		db
	DBTKEY		key
	DBT		value
	u_int		flags
	PREINIT:
	  dMY_CXT;
	CODE:
	  CurrentDB = db ;
	  RETVAL = db_put(db, key, value, flags) ;
#ifdef DB_VERSION_MAJOR
	  if (RETVAL > 0)
	    RETVAL = -1 ;
	  else if (RETVAL == DB_KEYEXIST)
	    RETVAL = 1 ;
#endif
	OUTPUT:
	  RETVAL
	  key		if (flagSet(flags, R_IAFTER) || flagSet(flags, R_IBEFORE)) OutputKey(ST(1), key);

int
db_fd(db)
	DB_File		db
	PREINIT:
	  dMY_CXT ;
	CODE:
	  CurrentDB = db ;
#ifdef DB_VERSION_MAJOR
	  RETVAL = -1 ;
	  {
	    int	status = 0 ;
	    status = (db->in_memory
		      ? -1 
		      : ((db->dbp)->fd)(db->dbp, &RETVAL) ) ;
	    if (status != 0)
	      RETVAL = -1 ;
	  }
#else
	  RETVAL = (db->in_memory
		? -1 
		: ((db->dbp)->fd)(db->dbp) ) ;
#endif
	OUTPUT:
	  RETVAL

int
db_sync(db, flags=0)
	DB_File		db
	u_int		flags
	PREINIT:
	  dMY_CXT;
	CODE:
	  CurrentDB = db ;
	  RETVAL = db_sync(db, flags) ;
#ifdef DB_VERSION_MAJOR
	  if (RETVAL > 0)
	    RETVAL = -1 ;
#endif
	OUTPUT:
	  RETVAL


int
db_seq(db, key, value, flags)
	DB_File		db
	DBTKEY		key 
	DBT		value = NO_INIT
	u_int		flags
	PREINIT:
	  dMY_CXT;
	CODE:
	  CurrentDB = db ;
	  DBT_clear(value) ; 
	  RETVAL = db_seq(db, key, value, flags);
#ifdef DB_VERSION_MAJOR
	  if (RETVAL > 0)
	    RETVAL = -1 ;
	  else if (RETVAL == DB_NOTFOUND)
	    RETVAL = 1 ;
#endif
	OUTPUT:
	  RETVAL
	  key
	  value

SV *
filter_fetch_key(db, code)
	DB_File		db
	SV *		code
	SV *		RETVAL = &PL_sv_undef ;
	CODE:
	    DBM_setFilter(db->filter_fetch_key, code) ;

SV *
filter_store_key(db, code)
	DB_File		db
	SV *		code
	SV *		RETVAL = &PL_sv_undef ;
	CODE:
	    DBM_setFilter(db->filter_store_key, code) ;

SV *
filter_fetch_value(db, code)
	DB_File		db
	SV *		code
	SV *		RETVAL = &PL_sv_undef ;
	CODE:
	    DBM_setFilter(db->filter_fetch_value, code) ;

SV *
filter_store_value(db, code)
	DB_File		db
	SV *		code
	SV *		RETVAL = &PL_sv_undef ;
	CODE:
	    DBM_setFilter(db->filter_store_value, code) ;

@


1.14
log
@Merge in perl 5.10.1
@
text
@@


1.13
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d7 1
a7 1
 version 1.815
d11 1
a11 1
     Copyright (c) 1995-2005 Paul Marquess. All rights reserved.
@


1.12
log
@merge in perl 5.8.8
@
text
@d6 2
a7 2
 last modified 11th November 2005
 version 1.814
d117 1
d414 1
a414 1
#define my_sv_setpvn(sv, d, s) sv_setpvn(sv, (s ? d : (void*)""), s)
d419 1
a419 1
	      my_sv_setpvn(arg, name.data, name.size) ;			\
d432 1
a432 1
		    my_sv_setpvn(arg, name.data, name.size); 		\
d601 2
a602 2
    PUSHs(sv_2mortal(newSVpvn(data1,key1->size)));
    PUSHs(sv_2mortal(newSVpvn(data2,key2->size)));
d1195 1
a1195 1
        status = db_open(name, RETVAL->type, Flags, mode, NULL, openinfo, &RETVAL->dbp) ; 
@


1.11
log
@sync in-tree perl with 5.8.6
@
text
@d6 2
a7 2
 last modified 7th August 2004
 version 1.810
d11 1
a11 1
     Copyright (c) 1995-2004 Paul Marquess. All rights reserved.
d113 4
d198 4
d206 8
d787 2
a788 1
#if 0
d790 3
a792 1
#ifdef CAN_PROTOTYPE
a793 4
#else
db_errcall_cb(db_errpfx, buffer)
const char * db_errpfx;
char * buffer;
d1253 3
d1450 6
a1465 1
	    /* RETVAL->dbp->set_errcall(RETVAL->dbp, db_errcall_cb) ;*/
d1495 3
a1497 1
    /* SV * sv_err = perl_get_sv(ERR_BUFF, GV_ADD|GV_ADDMULTI) ;  */
@


1.10
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d6 2
a7 2
 last modified 20th June 2004
 version 1.809
d112 1
d401 1
d403 1
a403 1
	      TAINT;                                       	\
d413 1
d419 1
a419 1
	      TAINT;                                       	\
@


1.9
log
@merge local changes into perl-5.8.3
@
text
@d6 2
a7 2
 last modified 22nd December 2003
 version 1.808
d11 1
a11 1
     Copyright (c) 1995-2003 Paul Marquess. All rights reserved.
d111 1
d936 4
a939 1
/* printf("In ParseOpenInfo name=[%s] flags=[%d] mode = [%d]\n", name, flags, mode) ;  */
@


1.8
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d6 2
a7 2
 last modified 22nd October 2002
 version 1.807
d110 1
d402 1
d417 1
d1495 2
a1496 1
	    if (RETVAL->dbp == NULL)
d1498 1
d1661 2
a1662 1
	        value.data = SvPV(ST(i), n_a) ;
d1771 2
a1772 1
	            value.data = SvPV(ST(i), n_a) ;
@


1.7
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d5 3
a7 3
 written by Paul Marquess <Paul.Marquess@@btinternet.com>
 last modified 1st March 2002
 version 1.803
d11 1
a11 1
     Copyright (c) 1995-2002 Paul Marquess. All rights reserved.
d104 6
a170 1
#define DBM_FILTERING
d191 4
d347 2
a348 2
#define db_DESTROY(db)                  ( db->cursor->c_close(db->cursor),\
					  (db->dbp->close)(db->dbp, 0) )
d356 1
a356 1
#define db_DESTROY(db)                  ((db->dbp)->close)(db->dbp)
d370 1
d372 1
d374 2
a382 1
#ifdef DBM_FILTERING
a387 1
#endif /* DBM_FILTERING */
a393 26
#ifdef DBM_FILTERING

#define ckFilter(arg,type,name)					\
	if (db->type) {						\
	    SV * save_defsv ;					\
            /* printf("filtering %s\n", name) ; */ 		\
	    if (db->filtering)					\
	        croak("recursion detected in %s", name) ;	\
	    db->filtering = TRUE ;				\
	    save_defsv = newSVsv(DEFSV) ;			\
	    sv_setsv(DEFSV, arg) ;				\
	    PUSHMARK(sp) ;					\
	    (void) perl_call_sv(db->type, G_DISCARD|G_NOARGS); 	\
	    sv_setsv(arg, DEFSV) ;				\
	    sv_setsv(DEFSV, save_defsv) ;			\
	    SvREFCNT_dec(save_defsv) ;				\
	    db->filtering = FALSE ;				\
	    /* printf("end of filtering %s\n", name) ; */ 	\
	}

#else

#define ckFilter(arg,type, name)

#endif /* DBM_FILTERING */

d399 3
a401 1
	      ckFilter(arg, filter_fetch_value,"filter_fetch_value") ; 	\
d413 3
a415 1
	      ckFilter(arg, filter_fetch_key,"filter_fetch_key") ; 	\
d443 2
d507 6
d548 6
d570 4
d585 2
a586 1
    if (count != 1)
d588 1
d595 1
d633 5
d654 4
d669 2
a670 1
    if (count != 1)
d672 1
d719 1
a719 1
    int retval ;
d722 5
d735 4
d742 1
d750 2
a751 1
    if (count != 1)
d753 1
d764 22
d895 2
a896 1
	if (length + value + 1 <= 0)
d898 1
a935 1
#ifdef DBM_FILTERING
a938 1
#endif /* DBM_FILTERING */
a1207 1
#ifdef DBM_FILTERING
a1210 1
#endif /* DBM_FILTERING */
d1422 4
d1428 1
d1431 3
a1433 1
        if (status == 0)
d1436 2
a1437 1
	/* printf("cursor returned %d %s\n", status, db_strerror(status)) ; */
d1459 4
d1505 1
d1507 1
a1513 1
#ifdef DBM_FILTERING
a1521 1
#endif /* DBM_FILTERING */
a1570 1
	    /* RETVAL = ((db->dbp)->get)(db->dbp, TXN &key, &value, flags) ; */
a1923 20
#ifdef DBM_FILTERING

#define setFilter(type)					\
	{						\
	    if (db->type)				\
	        RETVAL = sv_mortalcopy(db->type) ;	\
	    ST(0) = RETVAL ;				\
	    if (db->type && (code == &PL_sv_undef)) {	\
                SvREFCNT_dec(db->type) ;		\
	        db->type = NULL ;			\
	    }						\
	    else if (code) {				\
	        if (db->type)				\
	            sv_setsv(db->type, code) ;		\
	        else					\
	            db->type = newSVsv(code) ;		\
	    }	    					\
	}


d1930 1
a1930 1
	    setFilter(filter_fetch_key) ;
d1938 1
a1938 1
	    setFilter(filter_store_key) ;
d1946 1
a1946 1
	    setFilter(filter_fetch_value) ;
d1954 1
a1954 1
	    setFilter(filter_store_value) ;
a1955 1
#endif /* DBM_FILTERING */
@


1.6
log
@%ul -> %lu

submitted to perlbug@@

ok millert@@
@
text
@d6 2
a7 2
 last modified 17 December 2000
 version 1.75
d11 1
a11 1
     Copyright (c) 1995-2000 Paul Marquess. All rights reserved.
d93 11
d107 1
d112 2
a113 5
#ifndef PERL_VERSION
#    include "patchlevel.h"
#    define PERL_REVISION	5
#    define PERL_VERSION	PATCHLEVEL
#    define PERL_SUBVERSION	SUBVERSION
d116 2
a117 11
#if PERL_REVISION == 5 && (PERL_VERSION < 4 || (PERL_VERSION == 4 && PERL_SUBVERSION <= 75 ))

#    define PL_sv_undef		sv_undef
#    define PL_na		na

#endif

/* DEFSV appears first in 5.004_56 */
#ifndef DEFSV
#    define DEFSV		GvSV(defgv)
#endif
d123 3
a125 7
#undef __attribute__

/* If Perl has been compiled with Threads support,the symbol op will
   be defined here. This clashes with a field name in db.h, so get rid of it.
 */
#ifdef op
#    undef op
d134 21
a154 3
#ifdef CAN_PROTOTYPE
extern void __getBerkeleyDBInfo(void);
#endif
d156 3
a158 6
#ifndef pTHX
#    define pTHX
#    define pTHX_
#    define aTHX
#    define aTHX_
#endif
d160 1
a160 3
#ifndef newSVpvn
#    define newSVpvn(a,b)	newSVpv(a,b)
#endif
d330 3
a332 3
#define db_DELETE(db, key, flags)       ((db->dbp)->del)(db->dbp, TXN &key, flags)
#define db_STORE(db, key, value, flags) ((db->dbp)->put)(db->dbp, TXN &key, &value, flags)
#define db_FETCH(db, key, flags)        ((db->dbp)->get)(db->dbp, TXN &key, &value, flags)
d388 1
a388 1
            /* printf("filtering %s\n", name) ;*/		\
d400 1
a400 1
	    /*printf("end of filtering %s\n", name) ;*/		\
d430 5
d437 16
a452 4
static recno_t Value ; 
static recno_t zero = 0 ;
static DB_File CurrentDB ;
static DBTKEY empty ;
d546 1
d551 2
a552 2
    data1 = key1->data ;
    data2 = key2->data ;
d618 2
a619 1
    void * data1, * data2 ;
d623 2
a624 2
    data1 = key1->data ;
    data2 = key2->data ;
d697 1
d873 1
d1147 1
d1204 1
a1204 1
	       (void)dbp->set_h_ffactor(dbp, SvIV(*svp)) ;
d1208 1
a1208 1
               (void)dbp->set_h_nelem(dbp, SvIV(*svp)) ;
d1212 1
a1212 1
               (void)dbp->set_pagesize(dbp, SvIV(*svp));
d1216 1
a1216 1
               (void)dbp->set_cachesize(dbp, 0, SvIV(*svp), 0) ;
d1220 1
a1220 1
               (void)dbp->set_lorder(dbp, SvIV(*svp)) ;
d1247 1
a1247 1
	       (void)dbp->set_flags(dbp, SvIV(*svp)) ;
d1251 1
a1251 1
               (void)dbp->set_cachesize(dbp, 0, SvIV(*svp), 0) ;
d1255 1
a1255 1
               (void)dbp->set_pagesize(dbp, SvIV(*svp)) ;
d1259 1
a1259 1
               (void)dbp->set_lorder(dbp, SvIV(*svp)) ;
d1285 1
a1285 1
               status = dbp->set_cachesize(dbp, 0, SvIV(*svp), 0) ;
d1290 1
a1290 1
               status = dbp->set_pagesize(dbp, SvIV(*svp)) ;
d1295 1
a1295 1
               status = dbp->set_lorder(dbp, SvIV(*svp)) ;
d1305 1
a1305 1
		    value = SvIV(*svp) ;
d1319 1
a1319 1
		   u_int32_t len =  (u_int32_t)SvIV(*svp) ;
d1338 1
a1338 1
	    status = dbp->set_flags(dbp, DB_RENUMBER) ;
d1341 1
a1341 1
	            (void)dbp->set_flags(dbp, flags) ;
d1350 1
a1350 1
        int	 	Flags = 0 ;
d1390 1
a1390 230
static double 
#ifdef CAN_PROTOTYPE
constant(char *name, int arg)
#else
constant(name, arg)
char *name;
int arg;
#endif
{
    errno = 0;
    switch (*name) {
    case 'A':
	break;
    case 'B':
	if (strEQ(name, "BTREEMAGIC"))
#ifdef BTREEMAGIC
	    return BTREEMAGIC;
#else
	    goto not_there;
#endif
	if (strEQ(name, "BTREEVERSION"))
#ifdef BTREEVERSION
	    return BTREEVERSION;
#else
	    goto not_there;
#endif
	break;
    case 'C':
	break;
    case 'D':
	if (strEQ(name, "DB_LOCK"))
#ifdef DB_LOCK
	    return DB_LOCK;
#else
	    goto not_there;
#endif
	if (strEQ(name, "DB_SHMEM"))
#ifdef DB_SHMEM
	    return DB_SHMEM;
#else
	    goto not_there;
#endif
	if (strEQ(name, "DB_TXN"))
#ifdef DB_TXN
	    return (U32)DB_TXN;
#else
	    goto not_there;
#endif
	break;
    case 'E':
	break;
    case 'F':
	break;
    case 'G':
	break;
    case 'H':
	if (strEQ(name, "HASHMAGIC"))
#ifdef HASHMAGIC
	    return HASHMAGIC;
#else
	    goto not_there;
#endif
	if (strEQ(name, "HASHVERSION"))
#ifdef HASHVERSION
	    return HASHVERSION;
#else
	    goto not_there;
#endif
	break;
    case 'I':
	break;
    case 'J':
	break;
    case 'K':
	break;
    case 'L':
	break;
    case 'M':
	if (strEQ(name, "MAX_PAGE_NUMBER"))
#ifdef MAX_PAGE_NUMBER
	    return (U32)MAX_PAGE_NUMBER;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MAX_PAGE_OFFSET"))
#ifdef MAX_PAGE_OFFSET
	    return MAX_PAGE_OFFSET;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MAX_REC_NUMBER"))
#ifdef MAX_REC_NUMBER
	    return (U32)MAX_REC_NUMBER;
#else
	    goto not_there;
#endif
	break;
    case 'N':
	break;
    case 'O':
	break;
    case 'P':
	break;
    case 'Q':
	break;
    case 'R':
	if (strEQ(name, "RET_ERROR"))
#ifdef RET_ERROR
	    return RET_ERROR;
#else
	    goto not_there;
#endif
	if (strEQ(name, "RET_SPECIAL"))
#ifdef RET_SPECIAL
	    return RET_SPECIAL;
#else
	    goto not_there;
#endif
	if (strEQ(name, "RET_SUCCESS"))
#ifdef RET_SUCCESS
	    return RET_SUCCESS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "R_CURSOR"))
#ifdef R_CURSOR
	    return R_CURSOR;
#else
	    goto not_there;
#endif
	if (strEQ(name, "R_DUP"))
#ifdef R_DUP
	    return R_DUP;
#else
	    goto not_there;
#endif
	if (strEQ(name, "R_FIRST"))
#ifdef R_FIRST
	    return R_FIRST;
#else
	    goto not_there;
#endif
	if (strEQ(name, "R_FIXEDLEN"))
#ifdef R_FIXEDLEN
	    return R_FIXEDLEN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "R_IAFTER"))
#ifdef R_IAFTER
	    return R_IAFTER;
#else
	    goto not_there;
#endif
	if (strEQ(name, "R_IBEFORE"))
#ifdef R_IBEFORE
	    return R_IBEFORE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "R_LAST"))
#ifdef R_LAST
	    return R_LAST;
#else
	    goto not_there;
#endif
	if (strEQ(name, "R_NEXT"))
#ifdef R_NEXT
	    return R_NEXT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "R_NOKEY"))
#ifdef R_NOKEY
	    return R_NOKEY;
#else
	    goto not_there;
#endif
	if (strEQ(name, "R_NOOVERWRITE"))
#ifdef R_NOOVERWRITE
	    return R_NOOVERWRITE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "R_PREV"))
#ifdef R_PREV
	    return R_PREV;
#else
	    goto not_there;
#endif
	if (strEQ(name, "R_RECNOSYNC"))
#ifdef R_RECNOSYNC
	    return R_RECNOSYNC;
#else
	    goto not_there;
#endif
	if (strEQ(name, "R_SETCURSOR"))
#ifdef R_SETCURSOR
	    return R_SETCURSOR;
#else
	    goto not_there;
#endif
	if (strEQ(name, "R_SNAPSHOT"))
#ifdef R_SNAPSHOT
	    return R_SNAPSHOT;
#else
	    goto not_there;
#endif
	break;
    case 'S':
	break;
    case 'T':
	break;
    case 'U':
	break;
    case 'V':
	break;
    case 'W':
	break;
    case 'X':
	break;
    case 'Y':
	break;
    case 'Z':
	break;
    case '_':
	break;
    }
    errno = EINVAL;
    return 0;
d1392 1
a1392 4
not_there:
    errno = ENOENT;
    return 0;
}
d1394 1
a1394 1
MODULE = DB_File	PACKAGE = DB_File	PREFIX = db_
d1398 1
a1405 4
double
constant(name,arg)
	char *		name
	int		arg
d1436 2
d1469 2
d1479 2
d1492 1
a1492 1
int
d1497 3
d1518 2
d1524 1
a1524 1
int
d1527 3
d1543 1
a1543 1
int
d1546 4
a1549 1
	DBTKEY		key
d1554 1
d1570 2
a1577 1
	    DB *	Db = db->dbp ;
d1600 1
a1600 1
	        RETVAL = (Db->put)(Db, &key, &value, R_IBEFORE) ;
d1609 1
a1609 1
I32
d1612 2
d1615 2
d1640 1
a1640 1
I32
d1643 2
d1646 2
d1674 2
d1718 2
d1737 2
d1758 2
d1780 2
d1798 2
a1799 1
	int		status = 0 ;
d1804 8
a1811 5
	  status = (db->in_memory
		? -1 
		: ((db->dbp)->fd)(db->dbp, &RETVAL) ) ;
	  if (status != 0)
	    RETVAL = -1 ;
d1824 2
d1843 2
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d737 1
a737 1
    printf ("  reclen    = %ul\n", (unsigned long)recno->db_RE_reclen) ;
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d6 2
a7 2
 last modified 16th January 2000
 version 1.72
d85 8
d138 4
d173 4
d262 1
d492 13
d512 3
d564 13
d584 2
d634 7
d642 2
d645 12
a656 1
hash_cb(const void *data, size_t size)
d660 3
a662 1
size_t size ;
d1338 1
a1338 1
        status = RETVAL->dbp->open(RETVAL->dbp, name, NULL, RETVAL->type, 
@


1.3
log
@perl5.005_03 (stock)
@
text
@d6 2
a7 2
 last modified 6th March 1999
 version 1.65
d11 1
a11 1
     Copyright (c) 1995-9 Paul Marquess. All rights reserved.
d68 17
a84 2


d93 4
a96 4
#include "patchlevel.h"
#define PERL_REVISION	5
#define PERL_VERSION	PATCHLEVEL
#define PERL_SUBVERSION	SUBVERSION
d106 5
d121 18
a138 1
#undef op
a139 1
#include <db.h>
d144 7
d153 1
d157 4
d164 1
a164 1
#undef DB_Prefix_t
d169 1
a169 1
#undef DB_Hash_t
d175 5
a179 1
typedef DB_INFO	INFO ;
d193 7
a199 1
#define R_SETCURSOR     0
d204 1
d239 1
a239 1
#define flagSet(flags, bitmask)        ((flags) & (bitmask))
d241 1
a241 1
#define flagSet(flags, bitmask)        (((flags) & DB_OPFLAGS_MASK) == (bitmask))
d246 2
d256 4
a259 4
#ifdef DB_Prefix_t
#undef DB_Prefix_t
#endif
#define DB_Prefix_t	mDB_Prefix_t 
d263 4
a266 4
#ifdef DB_Hash_t
#undef DB_Hash_t
#endif
#define DB_Hash_t	mDB_Hash_t
d312 2
a313 1
#define db_DESTROY(db)                  ((db->dbp)->close)(db->dbp, 0)
d319 1
a319 1
#else
d326 1
a326 1
#endif
d338 1
d340 1
d344 8
d357 26
d385 5
a389 4
#define OutputValue(arg, name)  				\
	{ if (RETVAL == 0) {					\
	      my_sv_setpvn(arg, name.data, name.size) ;		\
	  }							\
d392 10
a401 9
#define OutputKey(arg, name)	 				\
	{ if (RETVAL == 0) 					\
	  { 							\
		if (db->type != DB_RECNO) {			\
		    my_sv_setpvn(arg, name.data, name.size); 	\
		}						\
		else 						\
		    sv_setiv(arg, (I32)*(I32*)name.data - 1); 	\
	  } 							\
d414 3
d422 1
a422 1

d426 6
a431 7
    if (flagSet(flags, R_CURSOR)) {
	status = ((db->cursor)->c_del)(db->cursor, 0);
	if (status != 0)
	    return status ;

#if DB_VERSION_MAJOR == 2 && DB_VERSION_MINOR < 5
	flags &= ~R_CURSOR ;
d433 1
a433 1
	flags &= ~DB_OPFLAGS_MASK ;
d435 13
d449 16
a472 8
static void
GetVersionInfo()
{
    SV * ver_sv = perl_get_sv("DB_File::db_version", TRUE) ;
#ifdef DB_VERSION_MAJOR
    int Major, Minor, Patch ;

    (void)db_version(&Major, &Minor, &Patch) ;
d474 3
a476 15
    /* check that libdb is recent enough  -- we need 2.3.4 or greater */
    if (Major == 2 && (Minor < 3 || (Minor ==  3 && Patch < 4)))
	croak("DB_File needs Berkeley DB 2.3.4 or greater, you have %d.%d.%d\n",
		 Major, Minor, Patch) ;
 
#if PERL_VERSION > 3
    sv_setpvf(ver_sv, "%d.%d", Major, Minor) ;
#else
    {
        char buffer[40] ;
        sprintf(buffer, "%d.%d", Major, Minor) ;
        sv_setpv(ver_sv, buffer) ; 
    }
#endif
 
a477 7
    sv_setiv(ver_sv, 1) ;
#endif

}


static int
d481 1
d483 3
d494 1
d503 1
d510 2
a511 2
    PUSHs(sv_2mortal(newSVpv(data1,key1->size)));
    PUSHs(sv_2mortal(newSVpv(data2,key2->size)));
d531 3
d537 1
d539 3
d550 1
d559 1
d566 2
a567 2
    PUSHs(sv_2mortal(newSVpv(data1,key1->size)));
    PUSHs(sv_2mortal(newSVpv(data2,key2->size)));
d587 3
d593 1
d595 3
d602 1
d605 1
d613 1
a613 1
    XPUSHs(sv_2mortal(newSVpv((char*)data,size)));
d633 1
a633 1
#ifdef TRACE
d636 3
d641 1
d655 3
d660 1
d673 3
d678 1
d705 3
d710 1
d716 2
a717 2
    DBT_flags(key) ;
    DBT_flags(value) ;
d728 3
d734 1
d738 1
a738 1
	I32 length = GetArrayLength(db) ;
d752 1
d754 3
d763 1
d765 3
d779 5
d1028 4
d1033 2
a1037 1
}
d1039 248
a1287 7
static int
not_here(s)
char *s;
{
    croak("DB_File::%s not implemented on this architecture", s);
    return -1;
}
d1290 3
d1296 1
d1529 1
a1529 1
    GetVersionInfo() ;
d1531 1
a1533 1
    DBT_flags(empty) ; 
d1560 1
a1560 1
	    RETVAL = ParseOpenInfo(isHASH, name, flags, mode, sv) ;
d1579 11
a1589 1
	  Safefree(db) ;
d1613 1
a1613 1
	  DBT_flags(value) ; 
d1629 1
a1629 1
	    DBT_flags(value) ; 
d1655 2
a1656 2
	    DBT_flags(key) ; 
	    DBT_flags(value) ; 
d1671 1
a1671 1
	    DBT_flags(value) ; 
d1695 2
a1696 2
	    DBT_flags(key) ; 
	    DBT_flags(value) ; 
d1733 2
a1734 2
	    DBT_flags(key) ; 
	    DBT_flags(value) ; 
d1760 2
a1761 2
	    DBT_flags(key) ; 
	    DBT_flags(value) ; 
d1789 1
a1793 12
#ifdef DB_VERSION_MAJOR
	   	RETVAL = 0 ;
		key = empty ;
	        for (i = 1 ; i < items  ; ++i)
	        {
	            value.data = SvPV(ST(i), n_a) ;
	            value.size = n_a ;
	            RETVAL = (Db->put)(Db, NULL, &key, &value, DB_APPEND) ;
	            if (RETVAL != 0)
	                break;
		}
#else
d1796 1
d1798 1
d1800 5
a1804 3
		if (RETVAL == 1)
		    key = empty ;
	        for (i = items - 1 ; i > 0 ; --i)
d1808 4
a1811 1
	            RETVAL = (Db->put)(Db, &key, &value, R_IAFTER) ;
a1815 1
#endif
a1819 1

d1826 1
a1826 1
	    RETVAL = GetArrayLength(db) ;
d1861 1
a1861 1
	  DBT_flags(value) ; 
d1936 1
a1936 1
	  DBT_flags(value) ; 
d1949 53
@


1.2
log
@perl 5.004_04
@
text
@d5 3
a7 3
 written by Paul Marquess (pmarquess@@bfsec.bt.co.uk)
 last modified 29th Jun 1997
 version 1.15
d11 1
a11 1
     Copyright (c) 1995, 1996, 1997 Paul Marquess. All rights reserved.
d42 6
a47 4
	1.13 -  Tidied up a few casts.
	1.14 -  Made it illegal to tie an associative array to a RECNO
	        database and an ordinary array to a HASH or BTREE database.
	1.15 -  Patch from Gisle Aas <gisle@@aas.no> to suppress "use of 
d49 20
d77 26
a103 3
/* #ifdef DB_VERSION_MAJOR */
/* #include <db_185.h> */
/* #endif */
d107 87
d208 60
a267 5
union INFO {
        HASHINFO 	hash ;
        RECNOINFO 	recno ;
        BTREEINFO 	btree ;
      } ;
d276 4
a279 1
	union INFO info ;
d285 1
a285 18

/* #define TRACE */

#define db_DESTROY(db)                  ((db->dbp)->close)(db->dbp)
#define db_DELETE(db, key, flags)       ((db->dbp)->del)(db->dbp, &key, flags)
#define db_STORE(db, key, value, flags) ((db->dbp)->put)(db->dbp, &key, &value, flags)
#define db_FETCH(db, key, flags)        ((db->dbp)->get)(db->dbp, &key, &value, flags)

#define db_close(db)			((db->dbp)->close)(db->dbp)
#define db_del(db, key, flags)          ((db->dbp)->del)(db->dbp, &key, flags)
#define db_fd(db)                       (db->in_memory	\
						? -1 	\
						: ((db->dbp)->fd)(db->dbp) )
#define db_put(db, key, value, flags)   ((db->dbp)->put)(db->dbp, &key, &value, flags)
#define db_get(db, key, value, flags)   ((db->dbp)->get)(db->dbp, &key, &value, flags)
#define db_seq(db, key, value, flags)   ((db->dbp)->seq)(db->dbp, &key, &value, flags)
#define db_sync(db, flags)              ((db->dbp)->sync)(db->dbp, flags)

d289 1
a289 1
	      sv_setpvn(arg, name.data, name.size) ;		\
d294 1
a294 1
	{ if (RETVAL == 0) \
d297 1
a297 1
		    sv_setpvn(arg, name.data, name.size); 	\
d304 1
d307 1
d309 62
a370 2
static recno_t zero = 0 ;
static DBTKEY empty = { &zero, sizeof(recno_t) } ;
d398 2
a399 2
    PUSHMARK(sp) ;
    EXTEND(sp,2) ;
d445 2
a446 2
    PUSHMARK(sp) ;
    EXTEND(sp,2) ;
d483 1
a483 1
    PUSHMARK(sp) ;
d509 1
a509 1
HASHINFO * hash ;
d512 7
a518 6
    printf ("  hash      = %s\n", (hash->hash != NULL ? "redefined" : "default")) ;
    printf ("  bsize     = %d\n", hash->bsize) ;
    printf ("  ffactor   = %d\n", hash->ffactor) ;
    printf ("  nelem     = %d\n", hash->nelem) ;
    printf ("  cachesize = %d\n", hash->cachesize) ;
    printf ("  lorder    = %d\n", hash->lorder) ;
d524 1
a524 1
RECNOINFO * recno ;
d527 7
a533 7
    printf ("  flags     = %d\n", recno->flags) ;
    printf ("  cachesize = %d\n", recno->cachesize) ;
    printf ("  psize     = %d\n", recno->psize) ;
    printf ("  lorder    = %d\n", recno->lorder) ;
    printf ("  reclen    = %lu\n", (unsigned long)recno->reclen) ;
    printf ("  bval      = %d 0x%x\n", recno->bval, recno->bval) ;
    printf ("  bfname    = %d [%s]\n", recno->bfname, recno->bfname) ;
d538 1
a538 1
BTREEINFO * btree ;
d541 12
a552 8
    printf ("  compare    = %s\n", (btree->compare ? "redefined" : "default")) ;
    printf ("  prefix     = %s\n", (btree->prefix ? "redefined" : "default")) ;
    printf ("  flags      = %d\n", btree->flags) ;
    printf ("  cachesize  = %d\n", btree->cachesize) ;
    printf ("  psize      = %d\n", btree->psize) ;
    printf ("  maxkeypage = %d\n", btree->maxkeypage) ;
    printf ("  minkeypage = %d\n", btree->minkeypage) ;
    printf ("  lorder     = %d\n", btree->lorder) ;
d566 1
a566 1
DB * db ;
d572 3
a574 1
    RETVAL = (db->seq)(db, &key, &value, R_LAST) ;
d577 1
a577 1
    else if (RETVAL == 1) /* No key means empty file */
d590 1
a590 1
	I32 length = GetArrayLength(db->dbp) ;
d616 5
a620 1
    union INFO	* info  = &RETVAL->info ;
d656 1
a656 1
                info->hash.hash = hash_cb ;
d660 1
a660 1
	        info->hash.hash = NULL ;
a661 3
           svp = hv_fetch(action, "bsize", 5, FALSE);
           info->hash.bsize = svp ? SvIV(*svp) : 0;
           
d663 1
a663 1
           info->hash.ffactor = svp ? SvIV(*svp) : 0;
d666 1
a666 1
           info->hash.nelem = svp ? SvIV(*svp) : 0;
d668 3
d672 1
a672 1
           info->hash.cachesize = svp ? SvIV(*svp) : 0;
d675 1
a675 1
           info->hash.lorder = svp ? SvIV(*svp) : 0;
d690 1
a690 1
                info->btree.compare = btree_compare ;
d694 1
a694 1
                info->btree.compare = NULL ;
d699 1
a699 1
                info->btree.prefix = btree_prefix ;
d703 1
a703 1
                info->btree.prefix = NULL ;
d706 1
a706 1
            info->btree.flags = svp ? SvIV(*svp) : 0;
d709 1
a709 1
            info->btree.cachesize = svp ? SvIV(*svp) : 0;
d711 1
d717 1
d720 1
a720 1
            info->btree.psize = svp ? SvIV(*svp) : 0;
d723 1
a723 1
            info->btree.lorder = svp ? SvIV(*svp) : 0;
d736 2
d739 4
a742 1
            info->recno.flags = (u_long) (svp ? SvIV(*svp) : 0);
d745 1
a745 1
            info->recno.cachesize = (u_int) (svp ? SvIV(*svp) : 0);
d748 1
a748 1
            info->recno.psize = (u_int) (svp ? SvIV(*svp) : 0);
d751 21
a771 4
            info->recno.lorder = (int) (svp ? SvIV(*svp) : 0);
         
            svp = hv_fetch(action, "reclen", 6, FALSE);
            info->recno.reclen = (size_t) (svp ? SvIV(*svp) : 0);
d774 20
d797 1
a797 1
		    info->recno.bval = (u_char)*SvPV(*svp, na) ;
d799 3
a801 1
		    info->recno.bval = (u_char)(unsigned long) SvIV(*svp) ;
d805 2
a806 2
		if (info->recno.flags & R_FIXEDLEN)
                    info->recno.bval = (u_char) ' ' ;
d808 2
a809 1
                    info->recno.bval = (u_char) '\n' ;
d811 5
a816 8
            svp = hv_fetch(action, "bfname", 6, FALSE); 
            if (svp && SvOK(*svp)) {
		char * ptr = SvPV(*svp,na) ;
                info->recno.bfname = (char*) (na ? ptr : NULL) ;
	    }
	    else
		info->recno.bfname = NULL ;

d831 36
d868 1
a1103 6
	if (strEQ(name, "__R_UNUSED"))
#ifdef __R_UNUSED
	    return __R_UNUSED;
#else
	    goto not_there;
#endif
d1116 9
d1141 1
d1144 1
a1144 1
	        name = (char*) SvPV(ST(2), na) ; 
d1169 4
d1192 1
d1194 1
a1194 1
	  RETVAL = (((db->dbp)->get)(db->dbp, &key, &value, 0) == 0) ;
d1206 1
a1206 1
	    DBT		value  ;
d1208 1
d1210 2
a1211 1
	    RETVAL = ((db->dbp)->get)(db->dbp, &key, &value, flags) ;
d1213 1
a1213 2
	    if (RETVAL == 0)
	        sv_setpvn(ST(0), value.data, value.size);
d1231 1
a1231 1
	    DBTKEY		key ;
a1232 1
	    DB *	Db = db->dbp ;
d1234 2
d1237 1
a1237 1
	    RETVAL = (Db->seq)(Db, &key, &value, R_FIRST) ;
d1239 1
a1239 7
	    if (RETVAL == 0)
	    {
	        if (db->type != DB_RECNO)
	            sv_setpvn(ST(0), key.data, key.size);
	        else
	            sv_setiv(ST(0), (I32)*(I32*)key.data - 1);
	    }
a1248 1
	    DB *	Db = db->dbp ;
d1250 1
d1252 1
a1252 1
	    RETVAL = (Db->seq)(Db, &key, &value, R_NEXT) ;
d1254 1
a1254 7
	    if (RETVAL == 0)
	    {
	        if (db->type != DB_RECNO)
	            sv_setpvn(ST(0), key.data, key.size);
	        else
	            sv_setiv(ST(0), (I32)*(I32*)key.data - 1);
	    }
d1264 1
d1272 1
d1274 2
d1277 5
d1283 1
d1286 2
a1287 2
	        value.data = SvPV(ST(i), na) ;
	        value.size = na ;
d1291 3
d1295 1
d1306 1
a1310 1
	    DB *	Db = db->dbp ;
d1312 2
d1315 1
d1317 1
a1317 1
	    RETVAL = (Db->seq)(Db, &key, &value, R_LAST) ;	
d1323 2
a1324 2
	        sv_setpvn(ST(0), value.data, value.size);
	        RETVAL = (Db->del)(Db, &key, R_CURSOR) ;
d1326 1
a1326 1
	            sv_setsv(ST(0), &sv_undef); 
d1333 1
a1337 1
	    DB *	Db = db->dbp ;
d1339 2
d1343 1
a1343 1
	    RETVAL = (Db->seq)(Db, &key, &value, R_FIRST) ;	 
d1349 2
a1350 2
	        sv_setpvn(ST(0), value.data, value.size);
	        RETVAL = (Db->del)(Db, &key, R_CURSOR) ; 
d1352 1
a1352 1
	            sv_setsv (ST(0), &sv_undef) ;
d1360 1
a1363 1
	    DBTKEY *	keyptr = &key ; 
d1367 1
d1369 2
d1372 12
d1385 1
a1385 1
	    RETVAL = (Db->seq)(Db, &key, &value, R_LAST) ;
d1389 1
a1389 1
		    keyptr = &empty ;
d1392 3
a1394 3
	            value.data = SvPV(ST(i), na) ;
	            value.size = na ;
	            RETVAL = (Db->put)(Db, keyptr, &value, R_IAFTER) ;
d1399 1
d1408 1
d1411 1
a1411 1
	    RETVAL = GetArrayLength(db->dbp) ;
d1425 1
a1425 1
	INIT:
d1427 9
d1444 1
a1444 1
	INIT:
d1446 8
d1455 1
d1464 1
a1464 1
	INIT:
d1466 7
d1474 2
a1475 1
	  key		if (flags & (R_IAFTER|R_IBEFORE)) OutputKey(ST(1), key);
d1480 2
a1481 1
	INIT:
d1483 14
d1502 1
a1502 1
	INIT:
d1504 7
d1519 1
a1519 1
	INIT:
d1521 8
d1530 1
@


1.1
log
@Initial revision
@
text
@d6 2
a7 2
 last modified 14th November 1995
 version 1.01
d11 4
d24 25
d56 3
d62 20
d88 2
a94 6
union INFO {
        HASHINFO 	hash ;
        RECNOINFO 	recno ;
        BTREEINFO 	btree ;
      } ;

d96 1
a96 1
/* #define TRACE  */
d105 3
a107 1
#define db_fd(db)                       ((db->dbp)->fd)(db->dbp) 
d114 5
a118 2
#define OutputValue(arg, name)  \
	{ if (RETVAL == 0) sv_setpvn(arg, name.data, name.size) ; }
d123 1
a123 1
		if (db->type != DB_RECNO) 			\
d125 1
d174 1
a174 1
        croak ("DB_File btree_compare: expected 1 return value from %s, got %d\n", count) ;
d221 1
a221 1
        croak ("DB_File btree_prefix: expected 1 return value from %s, got %d\n", count) ;
d244 4
d249 1
d258 1
a258 1
        croak ("DB_File hash_cb: expected 1 return value from %s, got %d\n", count) ;
d274 1
a274 1
HASHINFO hash ;
d277 6
a282 6
    printf ("  hash      = %s\n", (hash.hash != NULL ? "redefined" : "default")) ;
    printf ("  bsize     = %d\n", hash.bsize) ;
    printf ("  ffactor   = %d\n", hash.ffactor) ;
    printf ("  nelem     = %d\n", hash.nelem) ;
    printf ("  cachesize = %d\n", hash.cachesize) ;
    printf ("  lorder    = %d\n", hash.lorder) ;
d288 1
a288 1
RECNOINFO recno ;
d291 7
a297 7
    printf ("  flags     = %d\n", recno.flags) ;
    printf ("  cachesize = %d\n", recno.cachesize) ;
    printf ("  psize     = %d\n", recno.psize) ;
    printf ("  lorder    = %d\n", recno.lorder) ;
    printf ("  reclen    = %d\n", recno.reclen) ;
    printf ("  bval      = %d\n", recno.bval) ;
    printf ("  bfname    = %s\n", recno.bfname) ;
d300 1
d302 1
a302 1
BTREEINFO btree ;
d305 8
a312 8
    printf ("  compare    = %s\n", (btree.compare ? "redefined" : "default")) ;
    printf ("  prefix     = %s\n", (btree.prefix ? "redefined" : "default")) ;
    printf ("  flags      = %d\n", btree.flags) ;
    printf ("  cachesize  = %d\n", btree.cachesize) ;
    printf ("  psize      = %d\n", btree.psize) ;
    printf ("  maxkeypage = %d\n", btree.maxkeypage) ;
    printf ("  minkeypage = %d\n", btree.minkeypage) ;
    printf ("  lorder     = %d\n", btree.lorder) ;
d338 22
a359 1
    return (RETVAL) ;
d363 2
a364 1
ParseOpenInfo(name, flags, mode, sv, string)
a368 1
char * string ;
a371 1
    union INFO	info ;
d374 1
a374 1
    /* DBTYPE	type = DB_HASH ; */
d376 1
d380 6
d391 6
a396 1
        action = (HV*)SvRV(sv);
d399 4
d404 1
a404 1
            openinfo = (void*)&info ;
d410 1
a410 1
                info.hash.hash = hash_cb ;
d414 1
a414 1
	        info.hash.hash = NULL ;
d417 1
a417 1
           info.hash.bsize = svp ? SvIV(*svp) : 0;
d420 1
a420 1
           info.hash.ffactor = svp ? SvIV(*svp) : 0;
d423 1
a423 1
           info.hash.nelem = svp ? SvIV(*svp) : 0;
d426 1
a426 1
           info.hash.cachesize = svp ? SvIV(*svp) : 0;
d429 1
a429 1
           info.hash.lorder = svp ? SvIV(*svp) : 0;
d435 3
d439 1
a439 1
            openinfo = (void*)&info ;
d444 1
a444 1
                info.btree.compare = btree_compare ;
d448 1
a448 1
                info.btree.compare = NULL ;
d453 1
a453 1
                info.btree.prefix = btree_prefix ;
d457 1
a457 1
                info.btree.prefix = NULL ;
d460 1
a460 1
            info.btree.flags = svp ? SvIV(*svp) : 0;
d463 1
a463 1
            info.btree.cachesize = svp ? SvIV(*svp) : 0;
d466 1
a466 1
            info.btree.minkeypage = svp ? SvIV(*svp) : 0;
d469 1
a469 1
            info.btree.maxkeypage = svp ? SvIV(*svp) : 0;
d472 1
a472 1
            info.btree.psize = svp ? SvIV(*svp) : 0;
d475 1
a475 1
            info.btree.lorder = svp ? SvIV(*svp) : 0;
d482 3
d486 1
a486 1
            openinfo = (void *)&info ;
d489 1
a489 1
            info.recno.flags = (u_long) svp ? SvIV(*svp) : 0;
d492 1
a492 1
            info.recno.cachesize = (u_int) svp ? SvIV(*svp) : 0;
d495 1
a495 1
            info.recno.psize = (int) svp ? SvIV(*svp) : 0;
d498 1
a498 1
            info.recno.lorder = (int) svp ? SvIV(*svp) : 0;
d501 1
a501 1
            info.recno.reclen = (size_t) svp ? SvIV(*svp) : 0;
d507 1
a507 1
		    info.recno.bval = (u_char)*SvPV(*svp, na) ;
d509 1
a509 1
		    info.recno.bval = (u_char)(unsigned long) SvIV(*svp) ;
d513 2
a514 2
		if (info.recno.flags & R_FIXEDLEN)
                    info.recno.bval = (u_char) ' ' ;
d516 1
a516 1
                    info.recno.bval = (u_char) '\n' ;
d520 6
a525 1
            info.recno.bfname = (char *) svp ? SvPV(*svp,na) : 0;
d534 7
a542 10
#if 0
    /* kludge mode on: RETVAL->type for DB_RECNO is set to DB_BTREE
		       so remember a DB_RECNO by saving the address
		       of one of it's internal routines
    */
    if (RETVAL->dbp && type == DB_RECNO)
        DB_recno_close = RETVAL->dbp->close ;
#endif


d802 2
a803 1
db_TIEHASH(dbtype, name=undef, flags=O_RDWR, mode=0640, type=DB_HASH)
d812 2
a813 2
	    if (items >= 2 && SvOK(ST(1))) 
	        name = (char*) SvPV(ST(1), na) ; 
d815 2
a816 2
            if (items == 5)
	        sv = ST(4) ;
d818 1
a818 1
	    RETVAL = ParseOpenInfo(name, flags, mode, sv, "new") ;
a824 3
BOOT:
    newXS("DB_File::TIEARRAY", XS_DB_File_db_TIEHASH, file);

d848 15
d903 1
a903 1
	        if (Db->type != DB_RECNO)
d924 1
a924 1
	        if (Db->type != DB_RECNO)
d979 2
d982 2
a983 2
	        if (RETVAL == 0)
	            sv_setpvn(ST(0), value.data, value.size);
d992 1
a993 1
	    DBT		value ;
d998 1
a998 1
	    RETVAL = (Db->seq)(Db, &key, &value, R_FIRST) ;	
d1003 5
a1007 3
	        RETVAL = (Db->del)(Db, &key, R_CURSOR) ;
	        if (RETVAL == 0)
	            sv_setpvn(ST(0), value.data, value.size);
d1071 1
a1071 1
	DBT		value
d1107 1
a1107 1
	DBT		value
d1114 1
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d5 3
a7 3
 written by Paul Marquess <Paul.Marquess@@btinternet.com>
 last modified 6th March 1999
 version 1.65
a10 4
     Copyright (c) 1995-9 Paul Marquess. All rights reserved.
     This program is free software; you can redistribute it and/or
     modify it under the same terms as Perl itself.

a19 47
	1.02 - 	Use ALIAS to define TIEARRAY.
		Removed some redundant commented code.
		Merged OS2 code into the main distribution.
		Allow negative subscripts with RECNO interface.
		Changed the default flags to O_CREAT|O_RDWR
	1.03 - 	Added EXISTS
	1.04 -  fixed a couple of bugs in hash_cb. Patches supplied by
		Dave Hammen, hammen@@gothamcity.jsc.nasa.gov
	1.05 -  Added logic to allow prefix & hash types to be specified via
		Makefile.PL
	1.06 -  Minor namespace cleanup: Localized PrintBtree.
	1.07 -  Fixed bug with RECNO, where bval wasn't defaulting to "\n". 
	1.08 -  No change to DB_File.xs
	1.09 -  Default mode for dbopen changed to 0666
	1.10 -  Fixed fd method so that it still returns -1 for
		in-memory files when db 1.86 is used.
	1.11 -  No change to DB_File.xs
	1.12 -  No change to DB_File.xs
	1.13 -  Tidied up a few casts.     
	1.14 -	Made it illegal to tie an associative array to a RECNO
		database and an ordinary array to a HASH or BTREE database.
	1.50 -  Make work with both DB 1.x or DB 2.x
	1.51 -  Fixed a bug in mapping 1.x O_RDONLY flag to 2.x DB_RDONLY equivalent
	1.52 -  Patch from Gisle Aas <gisle@@aas.no> to suppress "use of 
		undefined value" warning with db_get and db_seq.
	1.53 -  Added DB_RENUMBER to flags for recno.
	1.54 -  Fixed bug in the fd method
        1.55 -  Fix for AIX from Jarkko Hietaniemi
        1.56 -  No change to DB_File.xs
        1.57 -  added the #undef op to allow building with Threads support.
	1.58 -  Fixed a problem with the use of sv_setpvn. When the
		size is specified as 0, it does a strlen on the data.
		This was ok for DB 1.x, but isn't for DB 2.x.
        1.59 -  No change to DB_File.xs
        1.60 -  Some code tidy up
        1.61 -  added flagSet macro for DB 2.5.x
		fixed typo in O_RDONLY test.
        1.62 -  No change to DB_File.xs
        1.63 -  Fix to alllow DB 2.6.x to build.
        1.64 -  Tidied up the 1.x to 2.x flags mapping code.
		Added a patch from Mark Kettenis <kettenis@@wins.uva.nl>
		to fix a flag mapping problem with O_RDONLY on the Hurd
        1.65 -  Fixed a bug in the PUSH logic.
		Added BOOT check that using 2.3.4 or greater



a25 26
#ifndef PERL_VERSION
#include "patchlevel.h"
#define PERL_REVISION	5
#define PERL_VERSION	PATCHLEVEL
#define PERL_SUBVERSION	SUBVERSION
#endif

#if PERL_REVISION == 5 && (PERL_VERSION < 4 || (PERL_VERSION == 4 && PERL_SUBVERSION <= 75 ))

#    define PL_sv_undef		sv_undef
#    define PL_na		na

#endif

/* Being the Berkeley DB we prefer the <sys/cdefs.h> (which will be
 * shortly #included by the <db.h>) __attribute__ to the possibly
 * already defined __attribute__, for example by GNUC or by Perl. */

#undef __attribute__

/* If Perl has been compiled with Threads support,the symbol op will
   be defined here. This clashes with a field name in db.h, so get rid of it.
 */
#ifdef op
#undef op
#endif
d30 7
a36 1
/* #define TRACE */
d38 2
d41 1
a41 78

#ifdef DB_VERSION_MAJOR

/* map version 2 features & constants onto their version 1 equivalent */

#ifdef DB_Prefix_t
#undef DB_Prefix_t
#endif
#define DB_Prefix_t	size_t

#ifdef DB_Hash_t
#undef DB_Hash_t
#endif
#define DB_Hash_t	u_int32_t

/* DBTYPE stays the same */
/* HASHINFO, RECNOINFO and BTREEINFO  map to DB_INFO */
typedef DB_INFO	INFO ;

/* version 2 has db_recno_t in place of recno_t	*/
typedef db_recno_t	recno_t;


#define R_CURSOR        DB_SET_RANGE
#define R_FIRST         DB_FIRST
#define R_IAFTER        DB_AFTER
#define R_IBEFORE       DB_BEFORE
#define R_LAST          DB_LAST
#define R_NEXT          DB_NEXT
#define R_NOOVERWRITE   DB_NOOVERWRITE
#define R_PREV          DB_PREV
#define R_SETCURSOR     0
#define R_RECNOSYNC     0
#define R_FIXEDLEN	DB_FIXEDLEN
#define R_DUP		DB_DUP

#define db_HA_hash 	h_hash
#define db_HA_ffactor	h_ffactor
#define db_HA_nelem	h_nelem
#define db_HA_bsize	db_pagesize
#define db_HA_cachesize	db_cachesize
#define db_HA_lorder	db_lorder

#define db_BT_compare	bt_compare
#define db_BT_prefix	bt_prefix
#define db_BT_flags	flags
#define db_BT_psize	db_pagesize
#define db_BT_cachesize	db_cachesize
#define db_BT_lorder	db_lorder
#define db_BT_maxkeypage
#define db_BT_minkeypage


#define db_RE_reclen	re_len
#define db_RE_flags	flags
#define db_RE_bval	re_pad
#define db_RE_bfname	re_source
#define db_RE_psize	db_pagesize
#define db_RE_cachesize	db_cachesize
#define db_RE_lorder	db_lorder

#define TXN	NULL,

#define do_SEQ(db, key, value, flag)	(db->cursor->c_get)(db->cursor, &key, &value, flag)


#define DBT_flags(x)	x.flags = 0
#define DB_flags(x, v)	x |= v 

#if DB_VERSION_MAJOR == 2 && DB_VERSION_MINOR < 5
#define flagSet(flags, bitmask)        ((flags) & (bitmask))
#else
#define flagSet(flags, bitmask)        (((flags) & DB_OPFLAGS_MASK) == (bitmask))
#endif

#else /* db version 1.x */

typedef union INFO {
d45 1
a45 1
      } INFO ;
d48 1
a48 6
#ifdef mDB_Prefix_t 
#ifdef DB_Prefix_t
#undef DB_Prefix_t
#endif
#define DB_Prefix_t	mDB_Prefix_t 
#endif
d50 4
a53 6
#ifdef mDB_Hash_t
#ifdef DB_Hash_t
#undef DB_Hash_t
#endif
#define DB_Hash_t	mDB_Hash_t
#endif
a54 52
#define db_HA_hash 	hash.hash
#define db_HA_ffactor	hash.ffactor
#define db_HA_nelem	hash.nelem
#define db_HA_bsize	hash.bsize
#define db_HA_cachesize	hash.cachesize
#define db_HA_lorder	hash.lorder

#define db_BT_compare	btree.compare
#define db_BT_prefix	btree.prefix
#define db_BT_flags	btree.flags
#define db_BT_psize	btree.psize
#define db_BT_cachesize	btree.cachesize
#define db_BT_lorder	btree.lorder
#define db_BT_maxkeypage btree.maxkeypage
#define db_BT_minkeypage btree.minkeypage

#define db_RE_reclen	recno.reclen
#define db_RE_flags	recno.flags
#define db_RE_bval	recno.bval
#define db_RE_bfname	recno.bfname
#define db_RE_psize	recno.psize
#define db_RE_cachesize	recno.cachesize
#define db_RE_lorder	recno.lorder

#define TXN	

#define do_SEQ(db, key, value, flag)	(db->dbp->seq)(db->dbp, &key, &value, flag)
#define DBT_flags(x)	
#define DB_flags(x, v)	
#define flagSet(flags, bitmask)        ((flags) & (bitmask))

#endif /* db version 1 */



#define db_DELETE(db, key, flags)       ((db->dbp)->del)(db->dbp, TXN &key, flags)
#define db_STORE(db, key, value, flags) ((db->dbp)->put)(db->dbp, TXN &key, &value, flags)
#define db_FETCH(db, key, flags)        ((db->dbp)->get)(db->dbp, TXN &key, &value, flags)

#define db_sync(db, flags)              ((db->dbp)->sync)(db->dbp, flags)
#define db_get(db, key, value, flags)   ((db->dbp)->get)(db->dbp, TXN &key, &value, flags)

#ifdef DB_VERSION_MAJOR
#define db_DESTROY(db)                  ((db->dbp)->close)(db->dbp, 0)
#define db_close(db)			((db->dbp)->close)(db->dbp, 0)
#define db_del(db, key, flags)          (flagSet(flags, R_CURSOR) 					\
						? ((db->cursor)->c_del)(db->cursor, 0)		\
						: ((db->dbp)->del)(db->dbp, NULL, &key, flags) )

#else

#define db_DESTROY(db)                  ((db->dbp)->close)(db->dbp)
d57 1
d59 3
a62 4
#endif


#define db_seq(db, key, value, flags)   do_SEQ(db, key, value, flags)
d64 2
a65 23
typedef struct {
	DBTYPE	type ;
	DB * 	dbp ;
	SV *	compare ;
	SV *	prefix ;
	SV *	hash ;
	int	in_memory ;
	INFO 	info ;
#ifdef DB_VERSION_MAJOR
	DBC *	cursor ;
#endif
	} DB_File_type;

typedef DB_File_type * DB_File ;
typedef DBT DBTKEY ;

#define my_sv_setpvn(sv, d, s) sv_setpvn(sv, (s ? d : (void*)""), s)

#define OutputValue(arg, name)  				\
	{ if (RETVAL == 0) {					\
	      my_sv_setpvn(arg, name.data, name.size) ;		\
	  }							\
	}
d68 1
a68 1
	{ if (RETVAL == 0) 					\
d70 2
a71 3
		if (db->type != DB_RECNO) {			\
		    my_sv_setpvn(arg, name.data, name.size); 	\
		}						\
a76 1

d79 1
d81 1
a81 63
static DB_File CurrentDB ;
static DBTKEY empty ;

#ifdef DB_VERSION_MAJOR

static int
db_put(db, key, value, flags)
DB_File		db ;
DBTKEY		key ;
DBT		value ;
u_int		flags ;

{
    int status ;

    if (flagSet(flags, R_CURSOR)) {
	status = ((db->cursor)->c_del)(db->cursor, 0);
	if (status != 0)
	    return status ;

#if DB_VERSION_MAJOR == 2 && DB_VERSION_MINOR < 5
	flags &= ~R_CURSOR ;
#else
	flags &= ~DB_OPFLAGS_MASK ;
#endif

    }

    return ((db->dbp)->put)(db->dbp, NULL, &key, &value, flags) ;

}

#endif /* DB_VERSION_MAJOR */

static void
GetVersionInfo()
{
    SV * ver_sv = perl_get_sv("DB_File::db_version", TRUE) ;
#ifdef DB_VERSION_MAJOR
    int Major, Minor, Patch ;

    (void)db_version(&Major, &Minor, &Patch) ;

    /* check that libdb is recent enough  -- we need 2.3.4 or greater */
    if (Major == 2 && (Minor < 3 || (Minor ==  3 && Patch < 4)))
	croak("DB_File needs Berkeley DB 2.3.4 or greater, you have %d.%d.%d\n",
		 Major, Minor, Patch) ;
 
#if PERL_VERSION > 3
    sv_setpvf(ver_sv, "%d.%d", Major, Minor) ;
#else
    {
        char buffer[40] ;
        sprintf(buffer, "%d.%d", Major, Minor) ;
        sv_setpv(ver_sv, buffer) ; 
    }
#endif
 
#else
    sv_setiv(ver_sv, 1) ;
#endif

}
d109 2
a110 2
    PUSHMARK(SP) ;
    EXTEND(SP,2) ;
d120 1
a120 1
        croak ("DB_File btree_compare: expected 1 return value from compare sub, got %d\n", count) ;
d156 2
a157 2
    PUSHMARK(SP) ;
    EXTEND(SP,2) ;
d167 1
a167 1
        croak ("DB_File btree_prefix: expected 1 return value from prefix sub, got %d\n", count) ;
d190 1
a190 6
     /* DGH - Next two lines added to fix corrupted stack problem */
    ENTER ;
    SAVETMPS;

    PUSHMARK(SP) ;

d199 1
a199 1
        croak ("DB_File hash_cb: expected 1 return value from hash sub, got %d\n", count) ;
d215 1
a215 1
INFO * hash ;
d218 6
a223 7
    printf ("  hash      = %s\n", 
		(hash->db_HA_hash != NULL ? "redefined" : "default")) ;
    printf ("  bsize     = %d\n", hash->db_HA_bsize) ;
    printf ("  ffactor   = %d\n", hash->db_HA_ffactor) ;
    printf ("  nelem     = %d\n", hash->db_HA_nelem) ;
    printf ("  cachesize = %d\n", hash->db_HA_cachesize) ;
    printf ("  lorder    = %d\n", hash->db_HA_lorder) ;
d229 1
a229 1
INFO * recno ;
d232 7
a238 7
    printf ("  flags     = %d\n", recno->db_RE_flags) ;
    printf ("  cachesize = %d\n", recno->db_RE_cachesize) ;
    printf ("  psize     = %d\n", recno->db_RE_psize) ;
    printf ("  lorder    = %d\n", recno->db_RE_lorder) ;
    printf ("  reclen    = %ul\n", (unsigned long)recno->db_RE_reclen) ;
    printf ("  bval      = %d 0x%x\n", recno->db_RE_bval, recno->db_RE_bval) ;
    printf ("  bfname    = %d [%s]\n", recno->db_RE_bfname, recno->db_RE_bfname) ;
a240 1
static void
d242 1
a242 1
INFO * btree ;
d245 8
a252 12
    printf ("  compare    = %s\n", 
		(btree->db_BT_compare ? "redefined" : "default")) ;
    printf ("  prefix     = %s\n", 
		(btree->db_BT_prefix ? "redefined" : "default")) ;
    printf ("  flags      = %d\n", btree->db_BT_flags) ;
    printf ("  cachesize  = %d\n", btree->db_BT_cachesize) ;
    printf ("  psize      = %d\n", btree->db_BT_psize) ;
#ifndef DB_VERSION_MAJOR
    printf ("  maxkeypage = %d\n", btree->db_BT_maxkeypage) ;
    printf ("  minkeypage = %d\n", btree->db_BT_minkeypage) ;
#endif
    printf ("  lorder     = %d\n", btree->db_BT_lorder) ;
d266 1
a266 1
DB_File db ;
d272 1
a272 3
    DBT_flags(key) ;
    DBT_flags(value) ;
    RETVAL = do_SEQ(db, key, value, R_LAST) ;
d275 1
a275 1
    else /* No key means empty file */
d278 1
a278 22
    return ((I32)RETVAL) ;
}

static recno_t
GetRecnoKey(db, value)
DB_File  db ;
I32      value ;
{
    if (value < 0) {
	/* Get the length of the array */
	I32 length = GetArrayLength(db) ;

	/* check for attempt to write before start of array */
	if (length + value + 1 <= 0)
	    croak("Modification of non-creatable array value attempted, subscript %ld", (long)value) ;

	value = length + value + 1 ;
    }
    else
        ++ value ;

    return value ;
d282 1
a282 2
ParseOpenInfo(isHASH, name, flags, mode, sv)
int    isHASH ;
d287 1
d291 1
d294 1
a294 2
    INFO	* info  = &RETVAL->info ;
    STRLEN	n_a;
a295 4
/* printf("In ParseOpenInfo name=[%s] flags=[%d] mode = [%d]\n", name, flags, mode) ;  */
    Zero(RETVAL, 1, DB_File_type) ;

    /* Default to HASH */
a298 6
     /* DGH - Next line added to avoid SEGV on existing hash DB */
    CurrentDB = RETVAL; 

    /* fd for 1.86 hash in memory files doesn't return -1 like 1.85 */
    RETVAL->in_memory = (name == NULL) ;

d304 1
a304 6
        svp  = hv_fetch( (HV*)SvRV(sv), "GOT", 3, FALSE) ;
        if (svp && SvOK(*svp))
            action  = (HV*) SvRV(*svp) ;
	else
	    croak("internal error") ;

a306 4

	    if (!isHASH)
	        croak("DB_File can only tie an associative array to a DB_HASH database") ;

d308 1
a308 1
            openinfo = (void*)info ;
d314 1
a314 1
                info->db_HA_hash = hash_cb ;
d318 1
a318 1
	        info->db_HA_hash = NULL ;
d320 3
d324 1
a324 1
           info->db_HA_ffactor = svp ? SvIV(*svp) : 0;
d327 1
a327 1
           info->db_HA_nelem = svp ? SvIV(*svp) : 0;
a328 3
           svp = hv_fetch(action, "bsize", 5, FALSE);
           info->db_HA_bsize = svp ? SvIV(*svp) : 0;
           
d330 1
a330 1
           info->db_HA_cachesize = svp ? SvIV(*svp) : 0;
d333 1
a333 1
           info->db_HA_lorder = svp ? SvIV(*svp) : 0;
a338 3
	    if (!isHASH)
	        croak("DB_File can only tie an associative array to a DB_BTREE database");

d340 1
a340 1
            openinfo = (void*)info ;
d345 1
a345 1
                info->db_BT_compare = btree_compare ;
d349 1
a349 1
                info->db_BT_compare = NULL ;
d354 1
a354 1
                info->db_BT_prefix = btree_prefix ;
d358 1
a358 1
                info->db_BT_prefix = NULL ;
d361 1
a361 1
            info->db_BT_flags = svp ? SvIV(*svp) : 0;
d364 1
a364 1
            info->db_BT_cachesize = svp ? SvIV(*svp) : 0;
a365 1
#ifndef DB_VERSION_MAJOR
d367 1
a367 1
            info->btree.minkeypage = svp ? SvIV(*svp) : 0;
d370 1
a370 2
            info->btree.maxkeypage = svp ? SvIV(*svp) : 0;
#endif
d373 1
a373 1
            info->db_BT_psize = svp ? SvIV(*svp) : 0;
d376 1
a376 1
            info->db_BT_lorder = svp ? SvIV(*svp) : 0;
a382 3
	    if (isHASH)
	        croak("DB_File can only tie an array to a DB_RECNO database");

d384 1
a384 3
            openinfo = (void *)info ;

	    info->db_RE_flags = 0 ;
d387 1
a387 4
            info->db_RE_flags = (u_long) (svp ? SvIV(*svp) : 0);
         
            svp = hv_fetch(action, "reclen", 6, FALSE);
            info->db_RE_reclen = (size_t) (svp ? SvIV(*svp) : 0);
d390 1
a390 1
            info->db_RE_cachesize = (u_int) (svp ? SvIV(*svp) : 0);
d393 1
a393 1
            info->db_RE_psize = (u_int) (svp ? SvIV(*svp) : 0);
d396 4
a399 21
            info->db_RE_lorder = (int) (svp ? SvIV(*svp) : 0);

#ifdef DB_VERSION_MAJOR
	    info->re_source = name ;
	    name = NULL ;
#endif
            svp = hv_fetch(action, "bfname", 6, FALSE); 
            if (svp && SvOK(*svp)) {
		char * ptr = SvPV(*svp,n_a) ;
#ifdef DB_VERSION_MAJOR
		name = (char*) n_a ? ptr : NULL ;
#else
                info->db_RE_bfname = (char*) (n_a ? ptr : NULL) ;
#endif
	    }
	    else
#ifdef DB_VERSION_MAJOR
		name = NULL ;
#else
                info->db_RE_bfname = NULL ;
#endif
a401 20
#ifdef DB_VERSION_MAJOR
            if (svp && SvOK(*svp))
            {
		int value ;
                if (SvPOK(*svp))
		    value = (int)*SvPV(*svp, n_a) ;
		else
		    value = SvIV(*svp) ;

		if (info->flags & DB_FIXEDLEN) {
		    info->re_pad = value ;
		    info->flags |= DB_PAD ;
		}
		else {
		    info->re_delim = value ;
		    info->flags |= DB_DELIMITER ;
		}

            }
#else
d405 1
a405 1
		    info->db_RE_bval = (u_char)*SvPV(*svp, n_a) ;
d407 1
a407 3
		    info->db_RE_bval = (u_char)(unsigned long) SvIV(*svp) ;
		DB_flags(info->flags, DB_DELIMITER) ;

d411 2
a412 2
		if (info->db_RE_flags & R_FIXEDLEN)
                    info->db_RE_bval = (u_char) ' ' ;
d414 1
a414 2
                    info->db_RE_bval = (u_char) '\n' ;
		DB_flags(info->flags, DB_DELIMITER) ;
d416 3
a418 1
#endif
a419 4
#ifdef DB_RENUMBER
	    info->flags |= DB_RENUMBER ;
#endif
         
d427 1
a427 6
    /* OS2 Specific Code */
#ifdef OS2
#ifdef __EMX__
    flags |= O_BINARY;
#endif /* __EMX__ */
#endif /* OS2 */
d429 7
a435 20
#ifdef DB_VERSION_MAJOR

    {
        int	 	Flags = 0 ;
        int		status ;

        /* Map 1.x flags to 2.x flags */
        if ((flags & O_CREAT) == O_CREAT)
            Flags |= DB_CREATE ;

#if O_RDONLY == 0
        if (flags == O_RDONLY)
#else
        if ((flags & O_RDONLY) == O_RDONLY && (flags & O_RDWR) != O_RDWR)
#endif
            Flags |= DB_RDONLY ;

#ifdef O_TRUNC
        if ((flags & O_TRUNC) == O_TRUNC)
            Flags |= DB_TRUNCATE ;
a437 16
        status = db_open(name, RETVAL->type, Flags, mode, NULL, openinfo, &RETVAL->dbp) ; 
        if (status == 0)
#if DB_VERSION_MAJOR == 2 && DB_VERSION_MINOR < 6
            status = (RETVAL->dbp->cursor)(RETVAL->dbp, NULL, &RETVAL->cursor) ;
#else
            status = (RETVAL->dbp->cursor)(RETVAL->dbp, NULL, &RETVAL->cursor,
			0) ;
#endif

        if (status)
	    RETVAL->dbp = NULL ;

    }
#else
    RETVAL->dbp = dbopen(name, flags, mode, RETVAL->type, openinfo) ; 
#endif
d673 6
a690 9
BOOT:
  {
    GetVersionInfo() ;
 
    empty.data = &zero ;
    empty.size =  sizeof(recno_t) ;
    DBT_flags(empty) ; 
  }

d698 1
a698 2
db_DoTie_(isHASH, dbtype, name=undef, flags=O_CREAT|O_RDWR, mode=0666, type=DB_HASH)
	int		isHASH
a705 1
	    STRLEN	n_a;
d707 2
a708 2
	    if (items >= 3 && SvOK(ST(2))) 
	        name = (char*) SvPV(ST(2), n_a) ; 
d710 2
a711 2
            if (items == 6)
	        sv = ST(5) ;
d713 1
a713 1
	    RETVAL = ParseOpenInfo(isHASH, name, flags, mode, sv) ;
d720 3
a735 4
#ifdef DB_VERSION_MAJOR
	  if (RETVAL > 0)
	    RETVAL = -1 ;
#endif
a745 16

int
db_EXISTS(db, key)
	DB_File		db
	DBTKEY		key
	CODE:
	{
          DBT		value ;
	
	  DBT_flags(value) ; 
	  CurrentDB = db ;
	  RETVAL = (((db->dbp)->get)(db->dbp, TXN &key, &value, 0) == 0) ;
	}
	OUTPUT:
	  RETVAL

d753 1
a753 1
            DBT		value ;
a754 1
	    DBT_flags(value) ; 
d756 1
a756 2
	    /* RETVAL = ((db->dbp)->get)(db->dbp, TXN &key, &value, flags) ; */
	    RETVAL = db_get(db, key, value, flags) ;
d758 2
a759 1
	    OutputValue(ST(0), value)
d777 1
a777 1
	    DBTKEY	key ;
d779 1
a780 2
	    DBT_flags(key) ; 
	    DBT_flags(value) ; 
d782 1
a782 1
	    RETVAL = do_SEQ(db, key, value, R_FIRST) ;
d784 7
a790 1
	    OutputKey(ST(0), key) ;
d800 1
a801 1
	    DBT_flags(value) ; 
d803 1
a803 1
	    RETVAL = do_SEQ(db, key, value, R_NEXT) ;
d805 7
a811 1
	    OutputKey(ST(0), key) ;
a820 1
	ALIAS:		UNSHIFT = 1
a827 1
	    STRLEN	n_a;
a828 2
	    DBT_flags(key) ; 
	    DBT_flags(value) ; 
a829 5
#ifdef DB_VERSION_MAJOR
	    /* get the first value */
	    RETVAL = do_SEQ(db, key, value, DB_FIRST) ;	 
	    RETVAL = 0 ;
#else
a830 1
#endif
d833 2
a834 2
	        value.data = SvPV(ST(i), n_a) ;
	        value.size = n_a ;
a837 3
#ifdef DB_VERSION_MAJOR
           	RETVAL = (db->cursor->c_put)(db->cursor, &key, &value, DB_BEFORE) ;
#else
a838 1
#endif
a848 1
	ALIAS:		POP = 1
d853 1
a854 2
	    DBT_flags(key) ; 
	    DBT_flags(value) ; 
a855 1

d857 1
a857 1
	    RETVAL = do_SEQ(db, key, value, R_LAST) ;	 
d862 3
a864 5
		/* the call to del will trash value, so take a copy now */
		OutputValue(ST(0), value) ;
	        RETVAL = db_del(db, key, R_CURSOR) ;
	        if (RETVAL != 0) 
	            sv_setsv(ST(0), &PL_sv_undef); 
a870 1
	ALIAS:		SHIFT = 1
d873 1
d875 1
a875 1
	    DBTKEY	key ;
a876 2
	    DBT_flags(key) ; 
	    DBT_flags(value) ; 
d879 1
a879 1
	    RETVAL = do_SEQ(db, key, value, R_FIRST) ;	 
d884 3
a886 5
		/* the call to del will trash value, so take a copy now */
		OutputValue(ST(0), value) ;
	        RETVAL = db_del(db, key, R_CURSOR) ;
	        if (RETVAL != 0)
	            sv_setsv (ST(0), &PL_sv_undef) ;
a893 1
	ALIAS:		PUSH = 1
d897 1
a900 1
	    STRLEN	n_a;
a901 2
	    DBT_flags(key) ; 
	    DBT_flags(value) ; 
a902 12
#ifdef DB_VERSION_MAJOR
	   	RETVAL = 0 ;
		key = empty ;
	        for (i = 1 ; i < items  ; ++i)
	        {
	            value.data = SvPV(ST(i), n_a) ;
	            value.size = n_a ;
	            RETVAL = (Db->put)(Db, NULL, &key, &value, DB_APPEND) ;
	            if (RETVAL != 0)
	                break;
		}
#else
d904 1
a904 1
	    RETVAL = do_SEQ(db, key, value, R_LAST) ;
d908 1
a908 1
		    key = empty ;
d911 3
a913 3
	            value.data = SvPV(ST(i), n_a) ;
	            value.size = n_a ;
	            RETVAL = (Db->put)(Db, &key, &value, R_IAFTER) ;
a917 1
#endif
a925 1
	ALIAS:		FETCHSIZE = 1
d928 1
a928 1
	    RETVAL = GetArrayLength(db) ;
d942 1
a942 1
	CODE:
a943 9
	  RETVAL = db_del(db, key, flags) ;
#ifdef DB_VERSION_MAJOR
	  if (RETVAL > 0)
	    RETVAL = -1 ;
	  else if (RETVAL == DB_NOTFOUND)
	    RETVAL = 1 ;
#endif
	OUTPUT:
	  RETVAL
d950 1
a950 1
	DBT		value = NO_INIT
d952 1
a952 1
	CODE:
a953 8
	  DBT_flags(value) ; 
	  RETVAL = db_get(db, key, value, flags) ;
#ifdef DB_VERSION_MAJOR
	  if (RETVAL > 0)
	    RETVAL = -1 ;
	  else if (RETVAL == DB_NOTFOUND)
	    RETVAL = 1 ;
#endif
a954 1
	  RETVAL
d963 1
a963 1
	CODE:
a964 7
	  RETVAL = db_put(db, key, value, flags) ;
#ifdef DB_VERSION_MAJOR
	  if (RETVAL > 0)
	    RETVAL = -1 ;
	  else if (RETVAL == DB_KEYEXIST)
	    RETVAL = 1 ;
#endif
d966 1
a966 2
	  RETVAL
	  key		if (flagSet(flags, R_IAFTER) || flagSet(flags, R_IBEFORE)) OutputKey(ST(1), key);
d971 1
a971 2
	int		status = 0 ;
	CODE:
a972 14
#ifdef DB_VERSION_MAJOR
	  RETVAL = -1 ;
	  status = (db->in_memory
		? -1 
		: ((db->dbp)->fd)(db->dbp, &RETVAL) ) ;
	  if (status != 0)
	    RETVAL = -1 ;
#else
	  RETVAL = (db->in_memory
		? -1 
		: ((db->dbp)->fd)(db->dbp) ) ;
#endif
	OUTPUT:
	  RETVAL
d978 1
a978 1
	CODE:
a979 7
	  RETVAL = db_sync(db, flags) ;
#ifdef DB_VERSION_MAJOR
	  if (RETVAL > 0)
	    RETVAL = -1 ;
#endif
	OUTPUT:
	  RETVAL
d986 1
a986 1
	DBT		value = NO_INIT
d988 1
a988 1
	CODE:
a989 8
	  DBT_flags(value) ; 
	  RETVAL = db_seq(db, key, value, flags);
#ifdef DB_VERSION_MAJOR
	  if (RETVAL > 0)
	    RETVAL = -1 ;
	  else if (RETVAL == DB_NOTFOUND)
	    RETVAL = 1 ;
#endif
a990 1
	  RETVAL
a992 1

@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d6 2
a7 2
 last modified 16th January 2000
 version 1.72
d11 1
a11 1
     Copyright (c) 1995-2000 Paul Marquess. All rights reserved.
d68 2
a69 17
        1.66 -  Added DBM filter code
        1.67 -  Backed off the use of newSVpvn.
		Fixed DBM Filter code for Perl 5.004.
		Fixed a small memory leak in the filter code.
        1.68 -  fixed backward compatability bug with R_IAFTER & R_IBEFORE
		merged in the 5.005_58 changes
        1.69 -  fixed a bug in push -- DB_APPEND wasn't working properly.
		Fixed the R_SETCURSOR bug introduced in 1.68
		Added a new Perl variable $DB_File::db_ver 
        1.70 -  Initialise $DB_File::db_ver and $DB_File::db_version with 
		GV_ADD|GV_ADDMULT -- bug spotted by Nick Ing-Simmons.
		Added a BOOT check to test for equivalent versions of db.h &
		libdb.a/so.
        1.71 -  Support for Berkeley DB version 3.
		Support for Berkeley DB 2/3's backward compatability mode.
		Rewrote push
        1.72 -  No change to DB_File.xs
d78 4
a81 4
#    include "patchlevel.h"
#    define PERL_REVISION	5
#    define PERL_VERSION	PATCHLEVEL
#    define PERL_SUBVERSION	SUBVERSION
a90 5
/* DEFSV appears first in 5.004_56 */
#ifndef DEFSV
#    define DEFSV		GvSV(defgv)
#endif

d101 1
a101 18
#    undef op
#endif

#ifdef COMPAT185
#    include <db_185.h>
#else
#    include <db.h>
#endif

#ifndef pTHX
#    define pTHX
#    define pTHX_
#    define aTHX
#    define aTHX_
#endif

#ifndef newSVpvn
#    define newSVpvn(a,b)	newSVpv(a,b)
d103 1
a107 7
#define DBM_FILTERING

#ifdef TRACE
#    define Trace(x)        printf x
#else
#    define Trace(x)
#endif
a109 1
#define DBT_clear(x)	Zero(&x, 1, DBT) ;
a112 4
#if DB_VERSION_MAJOR == 2
#    define BERKELEY_DB_1_OR_2
#endif

d116 1
a116 1
#    undef DB_Prefix_t
d121 1
a121 1
#    undef DB_Hash_t
d127 1
a127 5
#if DB_VERSION_MAJOR == 2
    typedef DB_INFO	INFO ;
#else /* DB_VERSION_MAJOR > 2 */
#    define DB_FIXEDLEN	(0x8000)
#endif /* DB_VERSION_MAJOR == 2 */
d141 1
a141 7

#if DB_VERSION_MAJOR == 2 && DB_VERSION_MINOR < 5
#  define R_SETCURSOR	0x800000
#else
#  define R_SETCURSOR	(-100)
#endif

a145 1

d180 1
a180 1
#    define flagSet(flags, bitmask)	((flags) & (bitmask))
d182 1
a182 1
#    define flagSet(flags, bitmask)	(((flags) & DB_OPFLAGS_MASK) == (bitmask))
a186 2
#define BERKELEY_DB_1_OR_2

d195 4
a198 4
#  ifdef DB_Prefix_t
#    undef DB_Prefix_t
#  endif
#  define DB_Prefix_t	mDB_Prefix_t 
d202 4
a205 4
#  ifdef DB_Hash_t
#    undef DB_Hash_t
#  endif
#  define DB_Hash_t	mDB_Hash_t
d251 1
a251 2
#define db_DESTROY(db)                  ( db->cursor->c_close(db->cursor),\
					  (db->dbp->close)(db->dbp, 0) )
d257 1
a257 1
#else /* ! DB_VERSION_MAJOR */
d264 1
a264 1
#endif /* ! DB_VERSION_MAJOR */
a275 1
#ifdef BERKELEY_DB_1_OR_2
a276 1
#endif	
a279 8
#ifdef DBM_FILTERING
	SV *    filter_fetch_key ;
	SV *    filter_store_key ;
	SV *    filter_fetch_value ;
	SV *    filter_store_value ;
	int     filtering ;
#endif /* DBM_FILTERING */

a284 26
#ifdef DBM_FILTERING

#define ckFilter(arg,type,name)					\
	if (db->type) {						\
	    SV * save_defsv ;					\
            /* printf("filtering %s\n", name) ;*/		\
	    if (db->filtering)					\
	        croak("recursion detected in %s", name) ;	\
	    db->filtering = TRUE ;				\
	    save_defsv = newSVsv(DEFSV) ;			\
	    sv_setsv(DEFSV, arg) ;				\
	    PUSHMARK(sp) ;					\
	    (void) perl_call_sv(db->type, G_DISCARD|G_NOARGS); 	\
	    sv_setsv(arg, DEFSV) ;				\
	    sv_setsv(DEFSV, save_defsv) ;			\
	    SvREFCNT_dec(save_defsv) ;				\
	    db->filtering = FALSE ;				\
	    /*printf("end of filtering %s\n", name) ;*/		\
	}

#else

#define ckFilter(arg,type, name)

#endif /* DBM_FILTERING */

d287 4
a290 5
#define OutputValue(arg, name)  					\
	{ if (RETVAL == 0) {						\
	      my_sv_setpvn(arg, name.data, name.size) ;			\
	      ckFilter(arg, filter_fetch_value,"filter_fetch_value") ; 	\
	  }								\
d293 9
a301 10
#define OutputKey(arg, name)	 					\
	{ if (RETVAL == 0) 						\
	  { 								\
		if (db->type != DB_RECNO) {				\
		    my_sv_setpvn(arg, name.data, name.size); 		\
		}							\
		else 							\
		    sv_setiv(arg, (I32)*(I32*)name.data - 1); 		\
	      ckFilter(arg, filter_fetch_key,"filter_fetch_key") ; 	\
	  } 								\
a313 3
#ifdef CAN_PROTOTYPE
db_put(DB_File db, DBTKEY key, DBT value, u_int flags)
#else
d319 1
a319 1
#endif
d323 7
a329 6
    if (flagSet(flags, R_IAFTER) || flagSet(flags, R_IBEFORE)) {
        DBC * temp_cursor ;
	DBT l_key, l_value;
        
#if DB_VERSION_MAJOR == 2 && DB_VERSION_MINOR < 6
        if (((db->dbp)->cursor)(db->dbp, NULL, &temp_cursor) != 0)
d331 1
a331 1
        if (((db->dbp)->cursor)(db->dbp, NULL, &temp_cursor, 0) != 0)
a332 13
	    return (-1) ;

	memset(&l_key, 0, sizeof(l_key));
	l_key.data = key.data;
	l_key.size = key.size;
	memset(&l_value, 0, sizeof(l_value));
	l_value.data = value.data;
	l_value.size = value.size;

	if ( temp_cursor->c_get(temp_cursor, &l_key, &l_value, DB_SET) != 0) {
	    (void)temp_cursor->c_close(temp_cursor);
	    return (-1);
	}
a333 16
	status = temp_cursor->c_put(temp_cursor, &key, &value, flags);
	(void)temp_cursor->c_close(temp_cursor);
	    
        return (status) ;
    }	
    
    
    if (flagSet(flags, R_CURSOR)) {
	return ((db->cursor)->c_put)(db->cursor, &key, &value, DB_CURRENT);
    }

    if (flagSet(flags, R_SETCURSOR)) {
	if ((db->dbp)->put(db->dbp, NULL, &key, &value, 0) != 0)
		return -1 ;
        return ((db->cursor)->c_get)(db->cursor, &key, &value, DB_SET_RANGE);
    
d342 30
a373 3
#ifdef CAN_PROTOTYPE
btree_compare(const DBT *key1, const DBT *key2)
#else
a376 1
#endif
a377 3
#ifdef dTHX
    dTHX;
#endif    
a385 1
#ifndef newSVpvn
a393 1
#endif	
d400 2
a401 2
    PUSHs(sv_2mortal(newSVpvn(data1,key1->size)));
    PUSHs(sv_2mortal(newSVpvn(data2,key2->size)));
a420 3
#ifdef CAN_PROTOTYPE
btree_prefix(const DBT *key1, const DBT *key2)
#else
a423 1
#endif
a424 3
#ifdef dTHX
    dTHX;
#endif    
a432 1
#ifndef newSVpvn
a440 1
#endif	
d447 2
a448 2
    PUSHs(sv_2mortal(newSVpvn(data1,key1->size)));
    PUSHs(sv_2mortal(newSVpvn(data2,key2->size)));
a467 3
#ifdef CAN_PROTOTYPE
hash_cb(const void *data, size_t size)
#else
a470 1
#endif
a471 3
#ifdef dTHX
    dTHX;
#endif    
a475 1
#ifndef newSVpvn
a477 1
#endif	
d485 1
a485 1
    XPUSHs(sv_2mortal(newSVpvn((char*)data,size)));
d505 1
a505 1
#if defined(TRACE) && defined(BERKELEY_DB_1_OR_2)
a507 3
#ifdef CAN_PROTOTYPE
PrintHash(INFO *hash)
#else
a509 1
#endif
a522 3
#ifdef CAN_PROTOTYPE
PrintRecno(INFO *recno)
#else
a524 1
#endif
a536 3
#ifdef CAN_PROTOTYPE
PrintBtree(INFO *btree)
#else
a538 1
#endif
a564 3
#ifdef CAN_PROTOTYPE
GetArrayLength(pTHX_ DB_File db)
#else
a566 1
#endif
d572 2
a573 2
    DBT_clear(key) ;
    DBT_clear(value) ;
a583 3
#ifdef CAN_PROTOTYPE
GetRecnoKey(pTHX_ DB_File db, I32 value)
#else
a586 1
#endif
d590 1
a590 1
	I32 length = GetArrayLength(aTHX_ db) ;
a603 1

a604 3
#ifdef CAN_PROTOTYPE
ParseOpenInfo(pTHX_ int isHASH, char *name, int flags, int mode, SV *sv)
#else
a610 1
#endif
a611 3

#ifdef BERKELEY_DB_1_OR_2 /* Berkeley DB Version 1  or 2 */

a622 5
#ifdef DBM_FILTERING
    RETVAL->filtering = 0 ;
    RETVAL->filter_fetch_key = RETVAL->filter_store_key = 
    RETVAL->filter_fetch_value = RETVAL->filter_store_value =
#endif /* DBM_FILTERING */
a866 4

#if defined(DB_LIBRARY_COMPATIBILITY_API) && DB_VERSION_MAJOR > 2
    RETVAL->dbp = __db185_open(name, flags, mode, RETVAL->type, openinfo) ; 
#else    
a867 2
#endif /* DB_LIBRARY_COMPATIBILITY_API */

d871 1
a872 248
#else /* Berkeley DB Version > 2 */

    SV **	svp;
    HV *	action ;
    DB_File	RETVAL = (DB_File)safemalloc(sizeof(DB_File_type)) ;
    DB *	dbp ;
    STRLEN	n_a;
    int		status ;

/* printf("In ParseOpenInfo name=[%s] flags=[%d] mode = [%d]\n", name, flags, mode) ;  */
    Zero(RETVAL, 1, DB_File_type) ;

    /* Default to HASH */
#ifdef DBM_FILTERING
    RETVAL->filtering = 0 ;
    RETVAL->filter_fetch_key = RETVAL->filter_store_key = 
    RETVAL->filter_fetch_value = RETVAL->filter_store_value =
#endif /* DBM_FILTERING */
    RETVAL->hash = RETVAL->compare = RETVAL->prefix = NULL ;
    RETVAL->type = DB_HASH ;

     /* DGH - Next line added to avoid SEGV on existing hash DB */
    CurrentDB = RETVAL; 

    /* fd for 1.86 hash in memory files doesn't return -1 like 1.85 */
    RETVAL->in_memory = (name == NULL) ;

    status = db_create(&RETVAL->dbp, NULL,0) ;
    /* printf("db_create returned %d %s\n", status, db_strerror(status)) ; */
    if (status) {
	RETVAL->dbp = NULL ;
        return (RETVAL) ;
    }	
    dbp = RETVAL->dbp ;

    if (sv)
    {
        if (! SvROK(sv) )
            croak ("type parameter is not a reference") ;

        svp  = hv_fetch( (HV*)SvRV(sv), "GOT", 3, FALSE) ;
        if (svp && SvOK(*svp))
            action  = (HV*) SvRV(*svp) ;
	else
	    croak("internal error") ;

        if (sv_isa(sv, "DB_File::HASHINFO"))
        {

	    if (!isHASH)
	        croak("DB_File can only tie an associative array to a DB_HASH database") ;

            RETVAL->type = DB_HASH ;
  
            svp = hv_fetch(action, "hash", 4, FALSE); 

            if (svp && SvOK(*svp))
            {
		(void)dbp->set_h_hash(dbp, hash_cb) ;
		RETVAL->hash = newSVsv(*svp) ;
            }

           svp = hv_fetch(action, "ffactor", 7, FALSE);
	   if (svp)
	       (void)dbp->set_h_ffactor(dbp, SvIV(*svp)) ;
         
           svp = hv_fetch(action, "nelem", 5, FALSE);
	   if (svp)
               (void)dbp->set_h_nelem(dbp, SvIV(*svp)) ;
         
           svp = hv_fetch(action, "bsize", 5, FALSE);
	   if (svp)
               (void)dbp->set_pagesize(dbp, SvIV(*svp));
           
           svp = hv_fetch(action, "cachesize", 9, FALSE);
	   if (svp)
               (void)dbp->set_cachesize(dbp, 0, SvIV(*svp), 0) ;
         
           svp = hv_fetch(action, "lorder", 6, FALSE);
	   if (svp)
               (void)dbp->set_lorder(dbp, SvIV(*svp)) ;

           PrintHash(info) ; 
        }
        else if (sv_isa(sv, "DB_File::BTREEINFO"))
        {
	    if (!isHASH)
	        croak("DB_File can only tie an associative array to a DB_BTREE database");

            RETVAL->type = DB_BTREE ;
   
            svp = hv_fetch(action, "compare", 7, FALSE);
            if (svp && SvOK(*svp))
            {
                (void)dbp->set_bt_compare(dbp, btree_compare) ;
		RETVAL->compare = newSVsv(*svp) ;
            }

            svp = hv_fetch(action, "prefix", 6, FALSE);
            if (svp && SvOK(*svp))
            {
                (void)dbp->set_bt_prefix(dbp, btree_prefix) ;
		RETVAL->prefix = newSVsv(*svp) ;
            }

           svp = hv_fetch(action, "flags", 5, FALSE);
	   if (svp)
	       (void)dbp->set_flags(dbp, SvIV(*svp)) ;
   
           svp = hv_fetch(action, "cachesize", 9, FALSE);
	   if (svp)
               (void)dbp->set_cachesize(dbp, 0, SvIV(*svp), 0) ;
         
           svp = hv_fetch(action, "psize", 5, FALSE);
	   if (svp)
               (void)dbp->set_pagesize(dbp, SvIV(*svp)) ;
         
           svp = hv_fetch(action, "lorder", 6, FALSE);
	   if (svp)
               (void)dbp->set_lorder(dbp, SvIV(*svp)) ;

            PrintBtree(info) ;
         
        }
        else if (sv_isa(sv, "DB_File::RECNOINFO"))
        {
	    int fixed = FALSE ;

	    if (isHASH)
	        croak("DB_File can only tie an array to a DB_RECNO database");

            RETVAL->type = DB_RECNO ;

           svp = hv_fetch(action, "flags", 5, FALSE);
	   if (svp) {
		int flags = SvIV(*svp) ;
		/* remove FIXDLEN, if present */
		if (flags & DB_FIXEDLEN) {
		    fixed = TRUE ;
		    flags &= ~DB_FIXEDLEN ;
	   	}
	   }

           svp = hv_fetch(action, "cachesize", 9, FALSE);
	   if (svp) {
               status = dbp->set_cachesize(dbp, 0, SvIV(*svp), 0) ;
	   }
         
           svp = hv_fetch(action, "psize", 5, FALSE);
	   if (svp) {
               status = dbp->set_pagesize(dbp, SvIV(*svp)) ;
	    }
         
           svp = hv_fetch(action, "lorder", 6, FALSE);
	   if (svp) {
               status = dbp->set_lorder(dbp, SvIV(*svp)) ;
	   }

	    svp = hv_fetch(action, "bval", 4, FALSE);
            if (svp && SvOK(*svp))
            {
		int value ;
                if (SvPOK(*svp))
		    value = (int)*SvPV(*svp, n_a) ;
		else
		    value = SvIV(*svp) ;

		if (fixed) {
		    status = dbp->set_re_pad(dbp, value) ;
		}
		else {
		    status = dbp->set_re_delim(dbp, value) ;
		}

            }

	   if (fixed) {
               svp = hv_fetch(action, "reclen", 6, FALSE);
	       if (svp) {
		   u_int32_t len =  (u_int32_t)SvIV(*svp) ;
                   status = dbp->set_re_len(dbp, len) ;
	       }    
	   }
         
	    if (name != NULL) {
	        status = dbp->set_re_source(dbp, name) ;
	        name = NULL ;
	    }	

            svp = hv_fetch(action, "bfname", 6, FALSE); 
            if (svp && SvOK(*svp)) {
		char * ptr = SvPV(*svp,n_a) ;
		name = (char*) n_a ? ptr : NULL ;
	    }
	    else
		name = NULL ;
         

	    status = dbp->set_flags(dbp, DB_RENUMBER) ;
         
		if (flags){
	            (void)dbp->set_flags(dbp, flags) ;
		}
            PrintRecno(info) ;
        }
        else
            croak("type is not of type DB_File::HASHINFO, DB_File::BTREEINFO or DB_File::RECNOINFO");
    }

    {
        int	 	Flags = 0 ;
        int		status ;

        /* Map 1.x flags to 3.x flags */
        if ((flags & O_CREAT) == O_CREAT)
            Flags |= DB_CREATE ;

#if O_RDONLY == 0
        if (flags == O_RDONLY)
#else
        if ((flags & O_RDONLY) == O_RDONLY && (flags & O_RDWR) != O_RDWR)
#endif
            Flags |= DB_RDONLY ;

#ifdef O_TRUNC
        if ((flags & O_TRUNC) == O_TRUNC)
            Flags |= DB_TRUNCATE ;
#endif

        status = RETVAL->dbp->open(RETVAL->dbp, name, NULL, RETVAL->type, 
	    			Flags, mode) ; 
	/* printf("open returned %d %s\n", status, db_strerror(status)) ; */

        if (status == 0)
            status = (RETVAL->dbp->cursor)(RETVAL->dbp, NULL, &RETVAL->cursor,
			0) ;
	/* printf("cursor returned %d %s\n", status, db_strerror(status)) ; */

        if (status)
	    RETVAL->dbp = NULL ;

    }

    return (RETVAL) ;

#endif /* Berkeley DB Version > 2 */

} /* ParseOpenInfo */
d874 7
a882 3
#ifdef CAN_PROTOTYPE
constant(char *name, int arg)
#else
a885 1
#endif
d1118 1
a1118 1
    __getBerkeleyDBInfo() ;
a1119 1
    DBT_clear(empty) ; 
d1122 1
d1149 1
a1149 1
	    RETVAL = ParseOpenInfo(aTHX_ isHASH, name, flags, mode, sv) ;
d1168 1
a1168 11
#ifdef DBM_FILTERING
	  if (db->filter_fetch_key)
	    SvREFCNT_dec(db->filter_fetch_key) ;
	  if (db->filter_store_key)
	    SvREFCNT_dec(db->filter_store_key) ;
	  if (db->filter_fetch_value)
	    SvREFCNT_dec(db->filter_fetch_value) ;
	  if (db->filter_store_value)
	    SvREFCNT_dec(db->filter_store_value) ;
#endif /* DBM_FILTERING */
	  safefree(db) ;
d1192 1
a1192 1
	  DBT_clear(value) ; 
d1208 1
a1208 1
	    DBT_clear(value) ; 
d1234 2
a1235 2
	    DBT_clear(key) ; 
	    DBT_clear(value) ; 
d1250 1
a1250 1
	    DBT_clear(value) ; 
d1274 2
a1275 2
	    DBT_clear(key) ; 
	    DBT_clear(value) ; 
d1312 2
a1313 2
	    DBT_clear(key) ; 
	    DBT_clear(value) ; 
d1339 2
a1340 2
	    DBT_clear(key) ; 
	    DBT_clear(value) ; 
a1367 1
	    int		keyval ;
d1372 12
a1385 1
#ifndef DB_VERSION_MAJOR		    		    
a1386 1
#endif	    
d1388 3
a1390 5
	    	if (RETVAL == 0)
		    keyval = *(int*)key.data ;
		else
		    keyval = 0 ;
	        for (i = 1 ; i < items ; ++i)
d1394 1
a1394 4
		    ++ keyval ;
	            key.data = &keyval ;
	            key.size = sizeof(int) ;
		    RETVAL = (Db->put)(Db, TXN &key, &value, 0) ;
d1399 1
d1404 1
d1411 1
a1411 1
	    RETVAL = GetArrayLength(aTHX_ db) ;
d1446 1
a1446 1
	  DBT_clear(value) ; 
d1521 1
a1521 1
	  DBT_clear(value) ; 
a1533 53
#ifdef DBM_FILTERING

#define setFilter(type)					\
	{						\
	    if (db->type)				\
	        RETVAL = sv_mortalcopy(db->type) ;	\
	    ST(0) = RETVAL ;				\
	    if (db->type && (code == &PL_sv_undef)) {	\
                SvREFCNT_dec(db->type) ;		\
	        db->type = NULL ;			\
	    }						\
	    else if (code) {				\
	        if (db->type)				\
	            sv_setsv(db->type, code) ;		\
	        else					\
	            db->type = newSVsv(code) ;		\
	    }	    					\
	}


SV *
filter_fetch_key(db, code)
	DB_File		db
	SV *		code
	SV *		RETVAL = &PL_sv_undef ;
	CODE:
	    setFilter(filter_fetch_key) ;

SV *
filter_store_key(db, code)
	DB_File		db
	SV *		code
	SV *		RETVAL = &PL_sv_undef ;
	CODE:
	    setFilter(filter_store_key) ;

SV *
filter_fetch_value(db, code)
	DB_File		db
	SV *		code
	SV *		RETVAL = &PL_sv_undef ;
	CODE:
	    setFilter(filter_fetch_value) ;

SV *
filter_store_value(db, code)
	DB_File		db
	SV *		code
	SV *		RETVAL = &PL_sv_undef ;
	CODE:
	    setFilter(filter_store_value) ;

#endif /* DBM_FILTERING */
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d6 2
a7 2
 last modified 17 December 2000
 version 1.75
a84 8
        1.73 -  No change to DB_File.xs
        1.74 -  A call to open needed parenthesised to stop it clashing
                with a win32 macro.
		Added Perl core patches 7703 & 7801.
        1.75 -  Fixed Perl core patch 7703.
		Added suppport to allow DB_File to be built with 
		Berkeley DB 3.2 -- btree_compare, btree_prefix and hash_cb
		needed to be changed.
a129 4
#ifdef CAN_PROTOTYPE
extern void __getBerkeleyDBInfo(void);
#endif

a160 4
#if DB_VERSION_MAJOR > 3 || (DB_VERSION_MAJOR == 3 && DB_VERSION_MINOR >= 2)
#    define AT_LEAST_DB_3_2
#endif

a245 1
#define BERKELEY_DB_1
a474 13
#ifdef AT_LEAST_DB_3_2

#ifdef CAN_PROTOTYPE
btree_compare(DB * db, const DBT *key1, const DBT *key2)
#else
btree_compare(db, key1, key2)
DB * db ;
const DBT * key1 ;
const DBT * key2 ;
#endif /* CAN_PROTOTYPE */

#else /* Berkeley DB < 3.2 */

a481 3

#endif

a530 13
#ifdef AT_LEAST_DB_3_2

#ifdef CAN_PROTOTYPE
btree_prefix(DB * db, const DBT *key1, const DBT *key2)
#else
btree_prefix(db, key1, key2)
Db * db ;
const DBT * key1 ;
const DBT * key2 ;
#endif

#else /* Berkeley DB < 3.2 */

a537 2

#endif
a585 7

#ifdef BERKELEY_DB_1
#    define HASH_CB_SIZE_TYPE size_t
#else
#    define HASH_CB_SIZE_TYPE u_int32_t
#endif

a586 2
#ifdef AT_LEAST_DB_3_2

d588 1
a588 12
hash_cb(DB * db, const void *data, u_int32_t size)
#else
hash_cb(db, data, size)
DB * db ;
const void * data ;
HASH_CB_SIZE_TYPE size ;
#endif

#else /* Berkeley DB < 3.2 */

#ifdef CAN_PROTOTYPE
hash_cb(const void *data, HASH_CB_SIZE_TYPE size)
d592 1
a592 3
HASH_CB_SIZE_TYPE size ;
#endif

d1268 1
a1268 1
        status = (RETVAL->dbp->open)(RETVAL->dbp, name, NULL, RETVAL->type, 
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d6 2
a7 2
 last modified 1st March 2002
 version 1.803
d11 1
a11 1
     Copyright (c) 1995-2002 Paul Marquess. All rights reserved.
a92 11
        1.76 -  No change to DB_File.xs
        1.77 -  Tidied up a few types used in calling newSVpvn.
        1.78 -  Core patch 10335, 10372, 10534, 10549, 11051 included.
        1.79 -  NEXTKEY ignores the input key.
                Added lots of casts
        1.800 - Moved backward compatability code into ppport.h.
                Use the new constants code.
        1.801 - No change to DB_File.xs
        1.802 - No change to DB_File.xs
        1.803 - FETCH, STORE & DELETE don't map the flags parameter
                into the equivalent Berkeley DB function anymore.
a95 1
#define PERL_NO_GET_CONTEXT
d100 5
a104 2
#ifdef _NOT_CORE
#  include "ppport.h"
d107 11
a117 2
/* Mention DB_VERSION_MAJOR_CFG, DB_VERSION_MINOR_CFG, and
   DB_VERSION_PATCH_CFG here so that Configure pulls them all in. */
d123 7
a129 3
/* #if DB_VERSION_MAJOR_CFG < 2  */
#ifndef DB_VERSION_MAJOR
#    undef __attribute__
d138 3
a140 1
/* Wall starts with 5.7.x */
d142 6
a147 1
#if PERL_REVISION > 5 || (PERL_REVISION == 5 && PERL_VERSION >= 7)
d149 3
a151 23
/* Since we dropped the gccish definition of __attribute__ we will want
 * to redefine dNOOP, however (so that dTHX continues to work).  Yes,
 * all this means that we can't do attribute checking on the DB_File,
 * boo, hiss. */
#  ifndef DB_VERSION_MAJOR

#    undef  dNOOP
#    define dNOOP extern int Perl___notused

    /* Ditto for dXSARGS. */
#    undef  dXSARGS
#    define dXSARGS				\
	dSP; dMARK;			\
	I32 ax = mark - PL_stack_base + 1;	\
	I32 items = sp - mark

#  endif

/* avoid -Wall; DB_File xsubs never make use of `ix' setup for ALIASes */
#  undef dXSI32
#  define dXSI32 dNOOP

#endif /* Perl >= 5.7 */
d321 3
a323 3
#define db_DELETE(db, key, flags)       ((db->dbp)->del)(db->dbp, TXN &key, 0)
#define db_STORE(db, key, value, flags) ((db->dbp)->put)(db->dbp, TXN &key, &value, 0)
#define db_FETCH(db, key, flags)        ((db->dbp)->get)(db->dbp, TXN &key, &value, 0)
d379 1
a379 1
            /* printf("filtering %s\n", name) ; */ 		\
d391 1
a391 1
	    /* printf("end of filtering %s\n", name) ; */ 	\
a420 5
#define my_SvUV32(sv) ((u_int32_t)SvUV(sv))

#ifdef CAN_PROTOTYPE
extern void __getBerkeleyDBInfo(void);
#endif
d423 4
a426 16

#define MY_CXT_KEY "DB_File::_guts" XS_VERSION

typedef struct {
    recno_t	x_Value; 
    recno_t	x_zero;
    DB_File	x_CurrentDB;
    DBTKEY	x_empty;
} my_cxt_t;

START_MY_CXT

#define Value		(MY_CXT.x_Value)
#define zero		(MY_CXT.x_zero)
#define CurrentDB	(MY_CXT.x_CurrentDB)
#define empty		(MY_CXT.x_empty)
a519 1
    dMY_CXT ;
d524 2
a525 2
    data1 = (char *) key1->data ;
    data2 = (char *) key2->data ;
d591 1
a591 2
    dMY_CXT ;
    char * data1, * data2 ;
d595 2
a596 2
    data1 = (char *) key1->data ;
    data2 = (char *) key2->data ;
a668 1
    dMY_CXT;
a843 1
    dMY_CXT;
a1116 1
    dMY_CXT;
d1173 1
a1173 1
	       (void)dbp->set_h_ffactor(dbp, my_SvUV32(*svp)) ;
d1177 1
a1177 1
               (void)dbp->set_h_nelem(dbp, my_SvUV32(*svp)) ;
d1181 1
a1181 1
               (void)dbp->set_pagesize(dbp, my_SvUV32(*svp));
d1185 1
a1185 1
               (void)dbp->set_cachesize(dbp, 0, my_SvUV32(*svp), 0) ;
d1189 1
a1189 1
               (void)dbp->set_lorder(dbp, (int)SvIV(*svp)) ;
d1216 1
a1216 1
	       (void)dbp->set_flags(dbp, my_SvUV32(*svp)) ;
d1220 1
a1220 1
               (void)dbp->set_cachesize(dbp, 0, my_SvUV32(*svp), 0) ;
d1224 1
a1224 1
               (void)dbp->set_pagesize(dbp, my_SvUV32(*svp)) ;
d1228 1
a1228 1
               (void)dbp->set_lorder(dbp, (int)SvIV(*svp)) ;
d1254 1
a1254 1
               status = dbp->set_cachesize(dbp, 0, my_SvUV32(*svp), 0) ;
d1259 1
a1259 1
               status = dbp->set_pagesize(dbp, my_SvUV32(*svp)) ;
d1264 1
a1264 1
               status = dbp->set_lorder(dbp, (int)SvIV(*svp)) ;
d1274 1
a1274 1
		    value = (int)SvIV(*svp) ;
d1288 1
a1288 1
		   u_int32_t len =  my_SvUV32(*svp) ;
d1307 1
a1307 1
	    status = dbp->set_flags(dbp, (u_int32_t)DB_RENUMBER) ;
d1310 1
a1310 1
	            (void)dbp->set_flags(dbp, (u_int32_t)flags) ;
d1319 1
a1319 1
        u_int32_t 	Flags = 0 ;
d1359 235
a1593 1
#include "constants.h"   
a1596 2
INCLUDE: constants.xs

a1598 1
    MY_CXT_INIT;
d1606 4
a1639 2
	PREINIT:
	  dMY_CXT;
a1670 2
	PREINIT:
	  dMY_CXT;
a1678 2
	PREINIT:
	  dMY_CXT;
d1690 1
a1690 1
void
a1694 3
	PREINIT:
	  dMY_CXT ;
	  int RETVAL ;
a1712 2
	PREINIT:
	  dMY_CXT;
d1717 1
a1717 1
void
a1719 3
	PREINIT:
	  dMY_CXT ;
	  int RETVAL ;
d1733 1
a1733 1
void
d1736 1
a1736 4
	DBTKEY		key = NO_INIT
	PREINIT:
	  dMY_CXT ;
	  int RETVAL ;
a1740 1
	    DBT_clear(key) ; 
a1755 2
	PREINIT:
	  dMY_CXT;
d1762 1
d1785 1
a1785 1
	        RETVAL = (db->dbp->put)(db->dbp, &key, &value, R_IBEFORE) ;
d1794 1
a1794 1
void
a1796 2
	PREINIT:
	  dMY_CXT;
a1797 2
	PREINIT:
	  I32 RETVAL;
d1821 1
a1821 1
void
a1823 2
	PREINIT:
	  dMY_CXT;
a1824 2
	PREINIT:
	  I32 RETVAL;
a1850 2
	PREINIT:
	  dMY_CXT;
a1892 2
	PREINIT:
	  dMY_CXT;
a1909 2
	PREINIT:
	  dMY_CXT;
a1928 2
	PREINIT:
	  dMY_CXT;
a1948 2
	PREINIT:
	  dMY_CXT;
d1965 1
a1965 2
	PREINIT:
	  dMY_CXT ;
d1970 5
a1974 8
	  {
	    int	status = 0 ;
	    status = (db->in_memory
		      ? -1 
		      : ((db->dbp)->fd)(db->dbp, &RETVAL) ) ;
	    if (status != 0)
	      RETVAL = -1 ;
	  }
a1986 2
	PREINIT:
	  dMY_CXT;
a2003 2
	PREINIT:
	  dMY_CXT;
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d5 3
a7 3
 written by Paul Marquess <pmqs@@cpan.org>
 last modified 22nd October 2002
 version 1.807
d11 1
a11 1
     Copyright (c) 1995-2003 Paul Marquess. All rights reserved.
a103 6
        1.804 - no change.
        1.805 - recursion detection added to the callbacks
                Support for 4.1.X added.
                Filter code can now cope with read-only $_
        1.806 - recursion detection beefed up.
        1.807 - no change
d165 1
a185 4
#if DB_VERSION_MAJOR > 4 || (DB_VERSION_MAJOR == 4 && DB_VERSION_MINOR >= 1)
#    define AT_LEAST_DB_4_1
#endif

d338 2
a339 2
#define db_DESTROY(db)                  (!db->aborted && ( db->cursor->c_close(db->cursor),\
					  (db->dbp->close)(db->dbp, 0) ))
d347 1
a347 1
#define db_DESTROY(db)                  (!db->aborted && ((db->dbp)->close)(db->dbp))
a360 1
	bool	in_compare ;
a361 1
	bool	in_prefix ;
a362 2
	bool	in_hash ;
	bool	aborted ;
d370 1
d376 1
d383 26
d414 1
a414 3
	      TAINT;                                       	\
	      SvTAINTED_on(arg);                                       	\
	      DBM_ckFilter(arg, filter_fetch_value,"filter_fetch_value") ; 	\
d426 1
a426 3
	      TAINT;                                       	\
	      SvTAINTED_on(arg);                                       	\
	      DBM_ckFilter(arg, filter_fetch_key,"filter_fetch_key") ; 	\
a453 2
#define ERR_BUFF "DB_File::Error"

a515 6
static void
tidyUp(DB_File db)
{
    db->aborted = TRUE ;
}

a550 6

    if (CurrentDB->in_compare) {
        tidyUp(CurrentDB);
        croak ("DB_File btree_compare: recursion detected\n") ;
    }

a566 4
    SAVESPTR(CurrentDB);
    CurrentDB->in_compare = FALSE;
    SAVEINT(CurrentDB->in_compare);
    CurrentDB->in_compare = TRUE;
d578 1
a578 2
    if (count != 1){
        tidyUp(CurrentDB);
a579 1
    }
a585 1

a622 5
    if (CurrentDB->in_prefix){
        tidyUp(CurrentDB);
        croak ("DB_File btree_prefix: recursion detected\n") ;
    }

a638 4
    SAVESPTR(CurrentDB);
    CurrentDB->in_prefix = FALSE;
    SAVEINT(CurrentDB->in_prefix);
    CurrentDB->in_prefix = TRUE;
d650 1
a650 2
    if (count != 1){
        tidyUp(CurrentDB);
a651 1
    }
d698 1
a698 1
    int retval = 0;
a700 5
    if (CurrentDB->in_hash){
        tidyUp(CurrentDB);
        croak ("DB_File hash callback: recursion detected\n") ;
    }

a708 4
    SAVESPTR(CurrentDB);
    CurrentDB->in_hash = FALSE;
    SAVEINT(CurrentDB->in_hash);
    CurrentDB->in_hash = TRUE;
a711 1

d719 1
a719 2
    if (count != 1){
        tidyUp(CurrentDB);
a720 1
    }
a730 22
#if 0
static void
#ifdef CAN_PROTOTYPE
db_errcall_cb(const char * db_errpfx, char * buffer)
#else
db_errcall_cb(db_errpfx, buffer)
const char * db_errpfx;
char * buffer;
#endif
{
#ifdef dTHX
    dTHX;
#endif    
    SV * sv = perl_get_sv(ERR_BUFF, FALSE) ;
    if (sv) {
        if (db_errpfx)
            sv_setpvf(sv, "%s: %s", db_errpfx, buffer) ;
        else
            sv_setpv(sv, buffer) ;
    }
} 
#endif
d766 1
a766 1
    printf ("  reclen    = %lu\n", (unsigned long)recno->db_RE_reclen) ;
d840 1
a840 2
	if (length + value + 1 <= 0) {
            tidyUp(db);
a841 1
	}
d879 1
d883 1
d1153 1
d1157 1
a1368 4
#ifdef AT_LEAST_DB_4_1
        status = (RETVAL->dbp->open)(RETVAL->dbp, NULL, name, NULL, RETVAL->type, 
	    			Flags, mode) ; 
#else
a1370 1
#endif
d1373 1
a1373 3
        if (status == 0) {
	    /* RETVAL->dbp->set_errcall(RETVAL->dbp, db_errcall_cb) ;*/

d1376 1
a1376 2
	    /* printf("cursor returned %d %s\n", status, db_strerror(status)) ; */
	}
a1397 4
#ifdef dTHX
    dTHX;
#endif    
    /* SV * sv_err = perl_get_sv(ERR_BUFF, GV_ADD|GV_ADDMULTI) ;  */
a1439 1
	  Trace(("DESTROY %p\n", db));
a1440 1
	  Trace(("DESTROY %p done\n", db));
d1447 1
d1456 1
d1506 1
d1860 20
d1886 1
a1886 1
	    DBM_setFilter(db->filter_fetch_key, code) ;
d1894 1
a1894 1
	    DBM_setFilter(db->filter_store_key, code) ;
d1902 1
a1902 1
	    DBM_setFilter(db->filter_fetch_value, code) ;
d1910 1
a1910 1
	    DBM_setFilter(db->filter_store_value, code) ;
d1912 1
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d6 2
a7 2
 last modified 22nd December 2003
 version 1.808
a109 1
        1.808 - leak fixed in ParseOpenInfo
a400 1
	      SvUTF8_off(arg);                                       	\
a414 1
	      SvUTF8_off(arg);                                       	\
d1492 1
a1492 2
	    if (RETVAL->dbp == NULL) {
	        Safefree(RETVAL);
a1493 1
	    }
d1656 1
a1656 2
		DBM_ckFilter(ST(i), filter_store_value, "filter_store_value");
	        value.data = SvPVbyte(ST(i), n_a) ;
d1765 1
a1765 2
		    DBM_ckFilter(ST(i), filter_store_value, "filter_store_value");
	            value.data = SvPVbyte(ST(i), n_a) ;
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d6 2
a7 2
 last modified 20th June 2004
 version 1.809
d11 1
a11 1
     Copyright (c) 1995-2004 Paul Marquess. All rights reserved.
a110 1
        1.809 - no change
d935 1
a935 4
#ifdef TRACE    
    printf("In ParseOpenInfo name=[%s] flags=[%d] mode=[%d] SV NULL=[%d]\n", 
		    name, flags, mode, sv == NULL) ;  
#endif
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@d6 2
a7 2
 last modified 7th August 2004
 version 1.810
a111 1
        1.810 - no change
a399 1
	      SvGETMAGIC(arg) ;          				\
d401 1
a401 1
	      TAINT;                                       		\
a410 1
		SvGETMAGIC(arg) ;          				\
d416 1
a416 1
	      TAINT;                                       		\
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d6 2
a7 2
 last modified 11th November 2005
 version 1.814
d11 1
a11 1
     Copyright (c) 1995-2005 Paul Marquess. All rights reserved.
a112 4
        1.811 - no change
        1.812 - no change
        1.813 - no change
        1.814 - no change
a193 4
#if DB_VERSION_MAJOR > 3 || (DB_VERSION_MAJOR == 3 && DB_VERSION_MINOR >= 3)
#    define AT_LEAST_DB_3_3
#endif

a197 8
#if DB_VERSION_MAJOR > 4 || (DB_VERSION_MAJOR == 4 && DB_VERSION_MINOR >= 3)
#    define AT_LEAST_DB_4_3
#endif

#ifdef AT_LEAST_DB_3_3
#   define WANT_ERROR
#endif

d771 1
a771 2
#ifdef WANT_ERROR

d773 2
a774 2
#ifdef AT_LEAST_DB_4_3
db_errcall_cb(const DB_ENV* dbenv, const char * db_errpfx, const char * buffer)
d776 3
a778 1
db_errcall_cb(const char * db_errpfx, char * buffer)
a1237 3
#ifdef WANT_ERROR
	    RETVAL->dbp->set_errcall(RETVAL->dbp, db_errcall_cb) ;
#endif
a1431 6
#ifdef AT_LEAST_DB_4_4
        /* need this for recno */
        if ((flags & O_TRUNC) == O_TRUNC)
            Flags |= DB_CREATE ;
#endif

d1442 1
d1472 1
a1472 3
#ifdef WANT_ERROR
    SV * sv_err = perl_get_sv(ERR_BUFF, GV_ADD|GV_ADDMULTI) ; 
#endif
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d6 2
a7 2
 last modified 4th February 2007
 version 1.815
a116 1
        1.814 - C++ casting fixes
d413 1
a413 1
#define my_sv_setpvn(sv, d, s) sv_setpvn(sv, (s ? d : (const char *)""), s)
d418 1
a418 1
	      my_sv_setpvn(arg, (const char *)name.data, name.size) ;			\
d431 1
a431 1
		    my_sv_setpvn(arg, (const char *)name.data, name.size); 		\
d600 2
a601 2
    PUSHs(sv_2mortal(newSVpvn((const char*)data1,key1->size)));
    PUSHs(sv_2mortal(newSVpvn((const char*)data2,key2->size)));
d1194 1
a1194 1
        status = db_open(name, RETVAL->type, Flags, mode, NULL, (DB_INFO*)openinfo, &RETVAL->dbp) ; 
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d7 1
a7 1
 version 1.818
d11 1
a11 1
     Copyright (c) 1995-2009 Paul Marquess. All rights reserved.
@


