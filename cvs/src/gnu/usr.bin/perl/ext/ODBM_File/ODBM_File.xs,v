head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.6
	OPENBSD_6_2_BASE:1.12
	PERL_5_24_2:1.1.1.11
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.16
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.10
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.12
	OPENBSD_5_8_BASE:1.11
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.11.0.4
	OPENBSD_5_7_BASE:1.11
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.11.0.8
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.10.0.18
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.16
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.14
	OPENBSD_5_0:1.10.0.12
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.10
	OPENBSD_4_9_BASE:1.10
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.10.0.8
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2017.02.05.00.32.13;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	cxJ08BvJA9Pt2PTM;

1.11
date	2013.03.25.20.40.54;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.05;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.03;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.09.17;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.32;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.23;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.14;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.05.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.31;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.55.33;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.07;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.07;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.38.50;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.17;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.53;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.52;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.46.24;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.48.17;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.23;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.08.45;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2017.08.14.13.46.11;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.12
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#define PERL_NO_GET_CONTEXT

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#if defined(PERL_IMPLICIT_SYS)
#  undef open
#  define open PerlLIO_open3
#endif

#ifdef I_DBM
#  include <dbm.h>
#else
#  ifdef I_RPCSVC_DBM
#    include <rpcsvc/dbm.h>
#  endif
#endif

#ifndef HAS_DBMINIT_PROTO
int	dbminit(char* filename);
int	dbmclose(void);
datum	fetch(datum key);
int	store(datum key, datum dat);
int	delete(datum key); 
datum	firstkey(void);
datum	nextkey(datum key);
#endif

#ifdef DBM_BUG_DUPLICATE_FREE 
/*
 * DBM on at least Ultrix and HPUX call dbmclose() from dbminit(),
 * resulting in duplicate free() because dbmclose() does *not*
 * check if it has already been called for this DBM.
 * If some malloc/free calls have been done between dbmclose() and
 * the next dbminit(), the memory might be used for something else when
 * it is freed.
 * Verified to work on ultrix4.3.  Probably will work on HP/UX.
 * Set DBM_BUG_DUPLICATE_FREE in the extension hint file.
 */
/* Close the previous dbm, and fail to open a new dbm */
#define dbmclose()	((void) dbminit("/non/exist/ent"))
#endif

#include <fcntl.h>

#define fetch_key 0
#define store_key 1
#define fetch_value 2
#define store_value 3

typedef struct {
	void * 	dbp ;
	SV *    filter[4];
	int     filtering ;
	} ODBM_File_type;

typedef ODBM_File_type * ODBM_File ;
typedef datum datum_key ;
typedef datum datum_key_copy ;
typedef datum datum_value ;

#define odbm_FETCH(db,key)			fetch(key)
#define odbm_STORE(db,key,value,flags)		store(key,value)
#define odbm_DELETE(db,key)			delete(key)
#define odbm_FIRSTKEY(db)			firstkey()
#define odbm_NEXTKEY(db,key)			nextkey(key)

#define MY_CXT_KEY "ODBM_File::_guts" XS_VERSION

typedef struct {
    int		x_dbmrefcnt;
} my_cxt_t;

START_MY_CXT

#define dbmrefcnt	(MY_CXT.x_dbmrefcnt)

#ifndef DBM_REPLACE
#define DBM_REPLACE 0
#endif

MODULE = ODBM_File	PACKAGE = ODBM_File	PREFIX = odbm_

BOOT:
{
    MY_CXT_INIT;
}

ODBM_File
odbm_TIEHASH(dbtype, filename, flags, mode)
	char *		dbtype
	char *		filename
	int		flags
	int		mode
	CODE:
	{
	    char *tmpbuf;
	    void * dbp ;
	    dMY_CXT;

	    if (dbmrefcnt++)
		croak("Old dbm can only open one database");
	    Newx(tmpbuf, strlen(filename) + 5, char);
	    SAVEFREEPV(tmpbuf);
	    sprintf(tmpbuf,"%s.dir",filename);
            if ((flags & O_CREAT)) {
               const int oflags = O_CREAT | O_TRUNC | O_WRONLY | O_EXCL;
               int created = 0;
               int fd;
               if (mode < 0)
                   goto creat_done;
               if ((fd = open(tmpbuf,oflags,mode)) < 0 && errno != EEXIST)
                   goto creat_done;
               if (close(fd) < 0)
                   goto creat_done;
               sprintf(tmpbuf,"%s.pag",filename);
               if ((fd = open(tmpbuf,oflags,mode)) < 0 && errno != EEXIST)
                   goto creat_done;
               if (close(fd) < 0)
                   goto creat_done;
               created = 1;
            creat_done:
               if (!created)
                   croak("ODBM_File: Can't create %s", filename);
            }
            else {
               int opened = 0;
               int fd;
               if ((fd = open(tmpbuf,O_RDONLY,mode)) < 0)
                   goto rdonly_done;
               if (close(fd) < 0)
                   goto rdonly_done;
               opened = 1;
            rdonly_done:
               if (!opened)
                   croak("ODBM_FILE: Can't open %s", filename);
	    }
	    dbp = (void*)(dbminit(filename) >= 0 ? &dbmrefcnt : 0);
	    RETVAL = (ODBM_File)safecalloc(1, sizeof(ODBM_File_type));
	    RETVAL->dbp = dbp ;
	}
	OUTPUT:
	  RETVAL

void
DESTROY(db)
	ODBM_File	db
	PREINIT:
	dMY_CXT;
	int i = store_value;
	CODE:
	dbmrefcnt--;
	dbmclose();
	do {
	    if (db->filter[i])
		SvREFCNT_dec(db->filter[i]);
	} while (i-- > 0);
	safefree(db);

datum_value
odbm_FETCH(db, key)
	ODBM_File	db
	datum_key_copy	key

int
odbm_STORE(db, key, value, flags = DBM_REPLACE)
	ODBM_File	db
	datum_key	key
	datum_value	value
	int		flags
    CLEANUP:
	if (RETVAL) {
	    if (RETVAL < 0 && errno == EPERM)
		croak("No write permission to odbm file");
	    croak("odbm store returned %d, errno %d, key \"%s\"",
			RETVAL,errno,key.dptr);
	}

int
odbm_DELETE(db, key)
	ODBM_File	db
	datum_key	key

datum_key
odbm_FIRSTKEY(db)
	ODBM_File	db

datum_key
odbm_NEXTKEY(db, key)
	ODBM_File	db
	datum_key	key


#define setFilter(type)					\
	{						\
	    if (db->type)				\
	        RETVAL = sv_mortalcopy(db->type) ; 	\
	    ST(0) = RETVAL ;				\
	    if (db->type && (code == &PL_sv_undef)) {	\
                SvREFCNT_dec(db->type) ;		\
	        db->type = Nullsv ;			\
	    }						\
	    else if (code) {				\
	        if (db->type)				\
	            sv_setsv(db->type, code) ;		\
	        else					\
	            db->type = newSVsv(code) ;		\
	    }	    					\
	}



SV *
filter_fetch_key(db, code)
	ODBM_File	db
	SV *		code
	SV *		RETVAL = &PL_sv_undef ;
	ALIAS:
	ODBM_File::filter_fetch_key = fetch_key
	ODBM_File::filter_store_key = store_key
	ODBM_File::filter_fetch_value = fetch_value
	ODBM_File::filter_store_value = store_value
	CODE:
	    DBM_setFilter(db->filter[ix], code);
@


1.11
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d6 4
d106 31
a136 10
	    if (stat(tmpbuf, &PL_statbuf) < 0) {
		if (flags & O_CREAT) {
		    if (mode < 0 || close(creat(tmpbuf,mode)) < 0)
			croak("ODBM_File: Can't create %s", filename);
		    sprintf(tmpbuf,"%s.pag",filename);
		    if (close(creat(tmpbuf,mode)) < 0)
			croak("ODBM_File: Can't create %s", filename);
		}
		else
		    croak("ODBM_FILE: Can't open %s", filename);
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d1 2
d42 5
d49 1
a49 4
	SV *    filter_fetch_key ;
	SV *    filter_store_key ;
	SV *    filter_fetch_value ;
	SV *    filter_store_value ;
d114 1
a114 2
	    RETVAL = (ODBM_File)safemalloc(sizeof(ODBM_File_type)) ;
    	    Zero(RETVAL, 1, ODBM_File_type) ;
a115 2
	    ST(0) = sv_mortalcopy(&PL_sv_undef);
	    sv_setptrobj(ST(0), RETVAL, dbtype);
d117 2
d125 1
d129 4
d193 5
d199 1
a199 26
	    DBM_setFilter(db->filter_fetch_key, code) ;

SV *
filter_store_key(db, code)
	ODBM_File	db
	SV *		code
	SV *		RETVAL =  &PL_sv_undef ;
	CODE:
	    DBM_setFilter(db->filter_store_key, code) ;

SV *
filter_fetch_value(db, code)
	ODBM_File	db
	SV *		code
	SV *		RETVAL =  &PL_sv_undef ;
	CODE:
	    DBM_setFilter(db->filter_fetch_value, code) ;

SV *
filter_store_value(db, code)
	ODBM_File	db
	SV *		code
	SV *		RETVAL =  &PL_sv_undef ;
	CODE:
	    DBM_setFilter(db->filter_store_value, code) ;

@


1.9
log
@merge in perl 5.8.8
@
text
@d18 1
a18 1
int	delete(datum key);
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d95 1
a95 1
	    New(0, tmpbuf, strlen(filename) + 5, char);
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d35 1
a35 1
#define dbmclose()	((void) dbminit("/tmp/x/y/z/z/y"))
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@a5 5
/* If using the DB3 emulation, ENTER is defined both
 * by DB3 and Perl.  We drop the Perl definition now.
 * See also INSTALL section on DB3.
 * -- Stanislav Brabec <utx@@penguin.cz> */
#  undef ENTER
a53 19
#define ckFilter(arg,type,name)					\
	if (db->type) {						\
	    SV * save_defsv ;					\
            /* printf("filtering %s\n", name) ;*/		\
	    if (db->filtering)					\
	        croak("recursion detected in %s", name) ;	\
	    db->filtering = TRUE ;				\
	    save_defsv = newSVsv(DEFSV) ;			\
	    sv_setsv(DEFSV, arg) ;				\
	    PUSHMARK(sp) ;					\
	    (void) perl_call_sv(db->type, G_DISCARD|G_NOARGS); 	\
	    sv_setsv(arg, DEFSV) ;				\
	    sv_setsv(DEFSV, save_defsv) ;			\
	    SvREFCNT_dec(save_defsv) ;				\
	    db->filtering = FALSE ;				\
	    /*printf("end of filtering %s\n", name) ;*/		\
	}


d186 1
a186 1
	    setFilter(filter_fetch_key) ;
d194 1
a194 1
	    setFilter(filter_store_key) ;
d202 1
a202 1
	    setFilter(filter_fetch_value) ;
d210 1
a210 1
	    setFilter(filter_store_value) ;
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d18 10
d56 1
d84 9
a92 1
static int dbmrefcnt;
d100 5
d115 2
d144 2
d154 1
a154 1
	datum_key	key
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d6 5
@


1.3
log
@perl5.005_03 (stock)
@
text
@a4 3
#ifdef NULL
#undef NULL  /* XXX Why? */
#endif
d30 31
a60 1
typedef void* ODBM_File;
a75 4
#ifndef NULL
#  define NULL 0
#endif

d85 1
d102 4
a105 1
	    RETVAL = (void*)(dbminit(filename) >= 0 ? &dbmrefcnt : 0);
d116 1
d118 1
a118 1
datum
d121 1
a121 1
	datum		key
d126 2
a127 2
	datum		key
	datum		value
d140 1
a140 1
	datum		key
d142 1
a142 1
datum
d146 1
a146 1
datum
d149 53
a201 1
	datum		key
@


1.2
log
@perl 5.004_04
@
text
@d6 1
a6 1
#undef NULL
d49 4
d67 1
a67 1
	    if (stat(tmpbuf, &statbuf) < 0) {
d79 1
a79 1
	    ST(0) = sv_mortalcopy(&sv_undef);
@


1.1
log
@Initial revision
@
text
@d16 15
d57 1
a57 1
	    char tmpbuf[1025];
d60 2
d76 1
a76 1
	    sv_setptrobj(ST(0), RETVAL, "ODBM_File");
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d6 1
a6 1
#undef NULL  /* XXX Why? */
a15 15
#ifdef DBM_BUG_DUPLICATE_FREE 
/*
 * DBM on at least Ultrix and HPUX call dbmclose() from dbminit(),
 * resulting in duplicate free() because dbmclose() does *not*
 * check if it has already been called for this DBM.
 * If some malloc/free calls have been done between dbmclose() and
 * the next dbminit(), the memory might be used for something else when
 * it is freed.
 * Verified to work on ultrix4.3.  Probably will work on HP/UX.
 * Set DBM_BUG_DUPLICATE_FREE in the extension hint file.
 */
/* Close the previous dbm, and fail to open a new dbm */
#define dbmclose()	((void) dbminit("/tmp/x/y/z/z/y"))
#endif

a33 4
#ifndef NULL
#  define NULL 0
#endif

d42 1
a42 1
	    char *tmpbuf;
a44 2
	    New(0, tmpbuf, strlen(filename) + 5, char);
	    SAVEFREEPV(tmpbuf);
d46 1
a46 1
	    if (stat(tmpbuf, &PL_statbuf) < 0) {
d58 2
a59 2
	    ST(0) = sv_mortalcopy(&PL_sv_undef);
	    sv_setptrobj(ST(0), RETVAL, dbtype);
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d5 3
d33 1
a33 31
typedef struct {
	void * 	dbp ;
	SV *    filter_fetch_key ;
	SV *    filter_store_key ;
	SV *    filter_fetch_value ;
	SV *    filter_store_value ;
	int     filtering ;
	} ODBM_File_type;

typedef ODBM_File_type * ODBM_File ;
typedef datum datum_key ;
typedef datum datum_value ;

#define ckFilter(arg,type,name)					\
	if (db->type) {						\
	    SV * save_defsv ;					\
            /* printf("filtering %s\n", name) ;*/		\
	    if (db->filtering)					\
	        croak("recursion detected in %s", name) ;	\
	    db->filtering = TRUE ;				\
	    save_defsv = newSVsv(DEFSV) ;			\
	    sv_setsv(DEFSV, arg) ;				\
	    PUSHMARK(sp) ;					\
	    (void) perl_call_sv(db->type, G_DISCARD|G_NOARGS); 	\
	    sv_setsv(arg, DEFSV) ;				\
	    sv_setsv(DEFSV, save_defsv) ;			\
	    SvREFCNT_dec(save_defsv) ;				\
	    db->filtering = FALSE ;				\
	    /*printf("end of filtering %s\n", name) ;*/		\
	}

d49 4
a61 1
	    void * dbp ;
d78 1
a78 4
	    dbp = (void*)(dbminit(filename) >= 0 ? &dbmrefcnt : 0);
	    RETVAL = (ODBM_File)safemalloc(sizeof(ODBM_File_type)) ;
    	    Zero(RETVAL, 1, ODBM_File_type) ;
	    RETVAL->dbp = dbp ;
a88 1
	safefree(db);
d90 1
a90 1
datum_value
d93 1
a93 1
	datum_key	key
d98 2
a99 2
	datum_key	key
	datum_value	value
d112 1
a112 1
	datum_key	key
d114 1
a114 1
datum_key
d118 1
a118 1
datum_key
d121 1
a121 53
	datum_key	key


#define setFilter(type)					\
	{						\
	    if (db->type)				\
	        RETVAL = sv_mortalcopy(db->type) ; 	\
	    ST(0) = RETVAL ;				\
	    if (db->type && (code == &PL_sv_undef)) {	\
                SvREFCNT_dec(db->type) ;		\
	        db->type = Nullsv ;			\
	    }						\
	    else if (code) {				\
	        if (db->type)				\
	            sv_setsv(db->type, code) ;		\
	        else					\
	            db->type = newSVsv(code) ;		\
	    }	    					\
	}



SV *
filter_fetch_key(db, code)
	ODBM_File	db
	SV *		code
	SV *		RETVAL = &PL_sv_undef ;
	CODE:
	    setFilter(filter_fetch_key) ;

SV *
filter_store_key(db, code)
	ODBM_File	db
	SV *		code
	SV *		RETVAL =  &PL_sv_undef ;
	CODE:
	    setFilter(filter_store_key) ;

SV *
filter_fetch_value(db, code)
	ODBM_File	db
	SV *		code
	SV *		RETVAL =  &PL_sv_undef ;
	CODE:
	    setFilter(filter_fetch_value) ;

SV *
filter_store_value(db, code)
	ODBM_File	db
	SV *		code
	SV *		RETVAL =  &PL_sv_undef ;
	CODE:
	    setFilter(filter_store_value) ;
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a5 5
/* If using the DB3 emulation, ENTER is defined both
 * by DB3 and Perl.  We drop the Perl definition now.
 * See also INSTALL section on DB3.
 * -- Stanislav Brabec <utx@@penguin.cz> */
#  undef ENTER
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a17 10
#ifndef HAS_DBMINIT_PROTO
int	dbminit(char* filename);
int	dbmclose(void);
datum	fetch(datum key);
int	store(datum key, datum dat);
int	delete(datum key);
datum	firstkey(void);
datum	nextkey(datum key);
#endif

a45 1
typedef datum datum_key_copy ;
d73 1
a73 9
#define MY_CXT_KEY "ODBM_File::_guts" XS_VERSION

typedef struct {
    int		x_dbmrefcnt;
} my_cxt_t;

START_MY_CXT

#define dbmrefcnt	(MY_CXT.x_dbmrefcnt)
a80 5
BOOT:
{
    MY_CXT_INIT;
}

a90 2
	    dMY_CXT;

a117 2
	PREINIT:
	dMY_CXT;
d126 1
a126 1
	datum_key_copy	key
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d6 5
d59 19
d210 1
a210 1
	    DBM_setFilter(db->filter_fetch_key, code) ;
d218 1
a218 1
	    DBM_setFilter(db->filter_store_key, code) ;
d226 1
a226 1
	    DBM_setFilter(db->filter_fetch_value, code) ;
d234 1
a234 1
	    DBM_setFilter(db->filter_store_value, code) ;
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d35 1
a35 1
#define dbmclose()	((void) dbminit("/non/exist/ent"))
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d95 1
a95 1
	    Newx(tmpbuf, strlen(filename) + 5, char);
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d18 1
a18 1
int	delete(datum key); 
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a0 2
#define PERL_NO_GET_CONTEXT

a39 5
#define fetch_key 0
#define store_key 1
#define fetch_value 2
#define store_value 3

d42 4
a45 1
	SV *    filter[4];
d110 2
a111 1
	    RETVAL = (ODBM_File)safecalloc(1, sizeof(ODBM_File_type));
d113 2
a115 2
	OUTPUT:
	  RETVAL
a121 1
	int i = store_value;
a124 4
	do {
	    if (db->filter[i])
		SvREFCNT_dec(db->filter[i]);
	} while (i-- > 0);
a184 5
	ALIAS:
	ODBM_File::filter_fetch_key = fetch_key
	ODBM_File::filter_store_key = store_key
	ODBM_File::filter_fetch_value = fetch_value
	ODBM_File::filter_store_value = store_value
d186 26
a211 1
	    DBM_setFilter(db->filter[ix], code);
@


1.1.1.11
log
@Import perl-5.24.2
@
text
@a5 4
#if defined(PERL_IMPLICIT_SYS)
#  undef open
#  define open PerlLIO_open3
#endif
d102 10
a111 31
            if ((flags & O_CREAT)) {
               const int oflags = O_CREAT | O_TRUNC | O_WRONLY | O_EXCL;
               int created = 0;
               int fd;
               if (mode < 0)
                   goto creat_done;
               if ((fd = open(tmpbuf,oflags,mode)) < 0 && errno != EEXIST)
                   goto creat_done;
               if (close(fd) < 0)
                   goto creat_done;
               sprintf(tmpbuf,"%s.pag",filename);
               if ((fd = open(tmpbuf,oflags,mode)) < 0 && errno != EEXIST)
                   goto creat_done;
               if (close(fd) < 0)
                   goto creat_done;
               created = 1;
            creat_done:
               if (!created)
                   croak("ODBM_File: Can't create %s", filename);
            }
            else {
               int opened = 0;
               int fd;
               if ((fd = open(tmpbuf,O_RDONLY,mode)) < 0)
                   goto rdonly_done;
               if (close(fd) < 0)
                   goto rdonly_done;
               opened = 1;
            rdonly_done:
               if (!opened)
                   croak("ODBM_FILE: Can't open %s", filename);
@


