head	1.13;
access;
symbols
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.10.0.8
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.6
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.4
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;


1.13
date	2010.09.24.14.59.21;	author millert;	state dead;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.29;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.36.05;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.16.19.13.57;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.03;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.03.03.02.30;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.26.18.32.56;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.09.00.45.36;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.23;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.12;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.05.22;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.30;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.55.27;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.38.46;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.14;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.51;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.50;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.48.16;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.22;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.11.21;	author millert;	state Exp;
branches;
next	;


desc
@@


1.13
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@# IO::Socket.pm
#
# Copyright (c) 1997-8 Graham Barr <gbarr@@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package IO::Socket;

require 5.006;

use IO::Handle;
use Socket 1.3;
use Carp;
use strict;
our(@@ISA, $VERSION, @@EXPORT_OK);
use Exporter;
use Errno;

# legacy

require IO::Socket::INET;
require IO::Socket::UNIX if ($^O ne 'epoc' && $^O ne 'symbian');

@@ISA = qw(IO::Handle);

$VERSION = "1.31";

@@EXPORT_OK = qw(sockatmark);

sub import {
    my $pkg = shift;
    if (@@_ && $_[0] eq 'sockatmark') { # not very extensible but for now, fast
	Exporter::export_to_level('IO::Socket', 1, $pkg, 'sockatmark');
    } else {
	my $callpkg = caller;
	Exporter::export 'Socket', $callpkg, @@_;
    }
}

sub new {
    my($class,%arg) = @@_;
    my $sock = $class->SUPER::new();

    $sock->autoflush(1);

    ${*$sock}{'io_socket_timeout'} = delete $arg{Timeout};

    return scalar(%arg) ? $sock->configure(\%arg)
			: $sock;
}

my @@domain2pkg;

sub register_domain {
    my($p,$d) = @@_;
    $domain2pkg[$d] = $p;
}

sub configure {
    my($sock,$arg) = @@_;
    my $domain = delete $arg->{Domain};

    croak 'IO::Socket: Cannot configure a generic socket'
	unless defined $domain;

    croak "IO::Socket: Unsupported socket domain"
	unless defined $domain2pkg[$domain];

    croak "IO::Socket: Cannot configure socket in domain '$domain'"
	unless ref($sock) eq "IO::Socket";

    bless($sock, $domain2pkg[$domain]);
    $sock->configure($arg);
}

sub socket {
    @@_ == 4 or croak 'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)';
    my($sock,$domain,$type,$protocol) = @@_;

    socket($sock,$domain,$type,$protocol) or
    	return undef;

    ${*$sock}{'io_socket_domain'} = $domain;
    ${*$sock}{'io_socket_type'}   = $type;
    ${*$sock}{'io_socket_proto'}  = $protocol;

    $sock;
}

sub socketpair {
    @@_ == 4 || croak 'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)';
    my($class,$domain,$type,$protocol) = @@_;
    my $sock1 = $class->new();
    my $sock2 = $class->new();

    socketpair($sock1,$sock2,$domain,$type,$protocol) or
    	return ();

    ${*$sock1}{'io_socket_type'}  = ${*$sock2}{'io_socket_type'}  = $type;
    ${*$sock1}{'io_socket_proto'} = ${*$sock2}{'io_socket_proto'} = $protocol;

    ($sock1,$sock2);
}

sub connect {
    @@_ == 2 or croak 'usage: $sock->connect(NAME)';
    my $sock = shift;
    my $addr = shift;
    my $timeout = ${*$sock}{'io_socket_timeout'};
    my $err;
    my $blocking;

    $blocking = $sock->blocking(0) if $timeout;
    if (!connect($sock, $addr)) {
	if (defined $timeout && ($!{EINPROGRESS} || $!{EWOULDBLOCK})) {
	    require IO::Select;

	    my $sel = new IO::Select $sock;

	    undef $!;
	    if (!$sel->can_write($timeout)) {
		$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);
		$@@ = "connect: timeout";
	    }
	    elsif (!connect($sock,$addr) &&
                not ($!{EISCONN} || ($! == 10022 && $^O eq 'MSWin32'))
            ) {
		# Some systems refuse to re-connect() to
		# an already open socket and set errno to EISCONN.
		# Windows sets errno to WSAEINVAL (10022)
		$err = $!;
		$@@ = "connect: $!";
	    }
	}
        elsif ($blocking || !($!{EINPROGRESS} || $!{EWOULDBLOCK}))  {
	    $err = $!;
	    $@@ = "connect: $!";
	}
    }

    $sock->blocking(1) if $blocking;

    $! = $err if $err;

    $err ? undef : $sock;
}

# Enable/disable blocking IO on sockets.
# Without args return the current status of blocking,
# with args change the mode as appropriate, returning the
# old setting, or in case of error during the mode change
# undef.

sub blocking {
    my $sock = shift;

    return $sock->SUPER::blocking(@@_)
        if $^O ne 'MSWin32';

    # Windows handles blocking differently
    #
    # http://groups.google.co.uk/group/perl.perl5.porters/browse_thread/thread/b4e2b1d88280ddff/630b667a66e3509f?#630b667a66e3509f
    # http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winsock/winsock/ioctlsocket_2.asp
    #
    # 0x8004667e is FIONBIO
    #
    # which is used to set blocking behaviour.

    # NOTE: 
    # This is a little confusing, the perl keyword for this is
    # 'blocking' but the OS level behaviour is 'non-blocking', probably
    # because sockets are blocking by default.
    # Therefore internally we have to reverse the semantics.

    my $orig= !${*$sock}{io_sock_nonblocking};
        
    return $orig unless @@_;

    my $block = shift;
    
    if ( !$block != !$orig ) {
        ${*$sock}{io_sock_nonblocking} = $block ? 0 : 1;
        ioctl($sock, 0x8004667e, pack("L!",${*$sock}{io_sock_nonblocking}))
            or return undef;
    }
    
    return $orig;        
}


sub close {
    @@_ == 1 or croak 'usage: $sock->close()';
    my $sock = shift;
    ${*$sock}{'io_socket_peername'} = undef;
    $sock->SUPER::close();
}

sub bind {
    @@_ == 2 or croak 'usage: $sock->bind(NAME)';
    my $sock = shift;
    my $addr = shift;

    return bind($sock, $addr) ? $sock
			      : undef;
}

sub listen {
    @@_ >= 1 && @@_ <= 2 or croak 'usage: $sock->listen([QUEUE])';
    my($sock,$queue) = @@_;
    $queue = 5
	unless $queue && $queue > 0;

    return listen($sock, $queue) ? $sock
				 : undef;
}

sub accept {
    @@_ == 1 || @@_ == 2 or croak 'usage $sock->accept([PKG])';
    my $sock = shift;
    my $pkg = shift || $sock;
    my $timeout = ${*$sock}{'io_socket_timeout'};
    my $new = $pkg->new(Timeout => $timeout);
    my $peer = undef;

    if(defined $timeout) {
	require IO::Select;

	my $sel = new IO::Select $sock;

	unless ($sel->can_read($timeout)) {
	    $@@ = 'accept: timeout';
	    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);
	    return;
	}
    }

    $peer = accept($new,$sock)
	or return;

    return wantarray ? ($new, $peer)
    	      	     : $new;
}

sub sockname {
    @@_ == 1 or croak 'usage: $sock->sockname()';
    getsockname($_[0]);
}

sub peername {
    @@_ == 1 or croak 'usage: $sock->peername()';
    my($sock) = @@_;
    ${*$sock}{'io_socket_peername'} ||= getpeername($sock);
}

sub connected {
    @@_ == 1 or croak 'usage: $sock->connected()';
    my($sock) = @@_;
    getpeername($sock);
}

sub send {
    @@_ >= 2 && @@_ <= 4 or croak 'usage: $sock->send(BUF, [FLAGS, [TO]])';
    my $sock  = $_[0];
    my $flags = $_[2] || 0;
    my $peer  = $_[3] || $sock->peername;

    croak 'send: Cannot determine peer address'
	 unless(defined $peer);

    my $r = defined(getpeername($sock))
	? send($sock, $_[1], $flags)
	: send($sock, $_[1], $flags, $peer);

    # remember who we send to, if it was successful
    ${*$sock}{'io_socket_peername'} = $peer
	if(@@_ == 4 && defined $r);

    $r;
}

sub recv {
    @@_ == 3 || @@_ == 4 or croak 'usage: $sock->recv(BUF, LEN [, FLAGS])';
    my $sock  = $_[0];
    my $len   = $_[2];
    my $flags = $_[3] || 0;

    # remember who we recv'd from
    ${*$sock}{'io_socket_peername'} = recv($sock, $_[1]='', $len, $flags);
}

sub shutdown {
    @@_ == 2 or croak 'usage: $sock->shutdown(HOW)';
    my($sock, $how) = @@_;
    ${*$sock}{'io_socket_peername'} = undef;
    shutdown($sock, $how);
}

sub setsockopt {
    @@_ == 4 or croak '$sock->setsockopt(LEVEL, OPTNAME, OPTVAL)';
    setsockopt($_[0],$_[1],$_[2],$_[3]);
}

my $intsize = length(pack("i",0));

sub getsockopt {
    @@_ == 3 or croak '$sock->getsockopt(LEVEL, OPTNAME)';
    my $r = getsockopt($_[0],$_[1],$_[2]);
    # Just a guess
    $r = unpack("i", $r)
	if(defined $r && length($r) == $intsize);
    $r;
}

sub sockopt {
    my $sock = shift;
    @@_ == 1 ? $sock->getsockopt(SOL_SOCKET,@@_)
	    : $sock->setsockopt(SOL_SOCKET,@@_);
}

sub atmark {
    @@_ == 1 or croak 'usage: $sock->atmark()';
    my($sock) = @@_;
    sockatmark($sock);
}

sub timeout {
    @@_ == 1 || @@_ == 2 or croak 'usage: $sock->timeout([VALUE])';
    my($sock,$val) = @@_;
    my $r = ${*$sock}{'io_socket_timeout'};

    ${*$sock}{'io_socket_timeout'} = defined $val ? 0 + $val : $val
	if(@@_ == 2);

    $r;
}

sub sockdomain {
    @@_ == 1 or croak 'usage: $sock->sockdomain()';
    my $sock = shift;
    ${*$sock}{'io_socket_domain'};
}

sub socktype {
    @@_ == 1 or croak 'usage: $sock->socktype()';
    my $sock = shift;
    ${*$sock}{'io_socket_type'}
}

sub protocol {
    @@_ == 1 or croak 'usage: $sock->protocol()';
    my($sock) = @@_;
    ${*$sock}{'io_socket_proto'};
}

1;

__END__

=head1 NAME

IO::Socket - Object interface to socket communications

=head1 SYNOPSIS

    use IO::Socket;

=head1 DESCRIPTION

C<IO::Socket> provides an object interface to creating and using sockets. It
is built upon the L<IO::Handle> interface and inherits all the methods defined
by L<IO::Handle>.

C<IO::Socket> only defines methods for those operations which are common to all
types of socket. Operations which are specified to a socket in a particular 
domain have methods defined in sub classes of C<IO::Socket>

C<IO::Socket> will export all functions (and constants) defined by L<Socket>.

=head1 CONSTRUCTOR

=over 4

=item new ( [ARGS] )

Creates an C<IO::Socket>, which is a reference to a
newly created symbol (see the C<Symbol> package). C<new>
optionally takes arguments, these arguments are in key-value pairs.
C<new> only looks for one key C<Domain> which tells new which domain
the socket will be in. All other arguments will be passed to the
configuration method of the package for that domain, See below.

 NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE

As of VERSION 1.18 all IO::Socket objects have autoflush turned on
by default. This was not the case with earlier releases.

 NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE

=back

=head1 METHODS

See L<perlfunc> for complete descriptions of each of the following
supported C<IO::Socket> methods, which are just front ends for the
corresponding built-in functions:

    socket
    socketpair
    bind
    listen
    accept
    send
    recv
    peername (getpeername)
    sockname (getsockname)
    shutdown

Some methods take slightly different arguments to those defined in L<perlfunc>
in attempt to make the interface more flexible. These are

=over 4

=item accept([PKG])

perform the system call C<accept> on the socket and return a new
object. The new object will be created in the same class as the listen
socket, unless C<PKG> is specified. This object can be used to
communicate with the client that was trying to connect.

In a scalar context the new socket is returned, or undef upon
failure. In a list context a two-element array is returned containing
the new socket and the peer address; the list will be empty upon
failure.

The timeout in the [PKG] can be specified as zero to effect a "poll",
but you shouldn't do that because a new IO::Select object will be
created behind the scenes just to do the single poll.  This is
horrendously inefficient.  Use rather true select() with a zero
timeout on the handle, or non-blocking IO.

=item socketpair(DOMAIN, TYPE, PROTOCOL)

Call C<socketpair> and return a list of two sockets created, or an
empty list on failure.

=back

Additional methods that are provided are:

=over 4

=item atmark

True if the socket is currently positioned at the urgent data mark,
false otherwise.

    use IO::Socket;

    my $sock = IO::Socket::INET->new('some_server');
    $sock->read($data, 1024) until $sock->atmark;

Note: this is a reasonably new addition to the family of socket
functions, so all systems may not support this yet.  If it is
unsupported by the system, an attempt to use this method will
abort the program.

The atmark() functionality is also exportable as sockatmark() function:

	use IO::Socket 'sockatmark';

This allows for a more traditional use of sockatmark() as a procedural
socket function.  If your system does not support sockatmark(), the
C<use> declaration will fail at compile time.

=item connected

If the socket is in a connected state the peer address is returned.
If the socket is not in a connected state then undef will be returned.

=item protocol

Returns the numerical number for the protocol being used on the socket, if
known. If the protocol is unknown, as with an AF_UNIX socket, zero
is returned.

=item sockdomain

Returns the numerical number for the socket domain type. For example, for
an AF_INET socket the value of &AF_INET will be returned.

=item sockopt(OPT [, VAL])

Unified method to both set and get options in the SOL_SOCKET level. If called
with one argument then getsockopt is called, otherwise setsockopt is called.

=item socktype

Returns the numerical number for the socket type. For example, for
a SOCK_STREAM socket the value of &SOCK_STREAM will be returned.

=item timeout([VAL])

Set or get the timeout value associated with this socket. If called without
any arguments then the current setting is returned. If called with an argument
the current setting is changed and the previous value returned.

=back

=head1 SEE ALSO

L<Socket>, L<IO::Handle>, L<IO::Socket::INET>, L<IO::Socket::UNIX>

=head1 AUTHOR

Graham Barr.  atmark() by Lincoln Stein.  Currently maintained by the
Perl Porters.  Please report all bugs to <perl5-porters@@perl.org>.

=head1 COPYRIGHT

Copyright (c) 1997-8 Graham Barr <gbarr@@pobox.com>. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

The atmark() implementation: Copyright 2001, Lincoln Stein <lstein@@cshl.org>.
This module is distributed under the same terms as Perl itself.
Feel free to use, modify and redistribute it as long as you retain
the correct attribution.

=cut
@


1.12
log
@Merge in perl 5.10.1
@
text
@@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d26 1
a26 1
$VERSION = "1.30_01";
@


1.10
log
@Back-port a getpeername() fix from IO version 1.30.
Also add a missing defined() that fixes send on unix domain sockets.
@
text
@d26 1
a26 1
$VERSION = "1.29";
d115 1
a115 1
	if (defined $timeout && $!{EINPROGRESS}) {
d120 1
d125 3
a127 1
	    elsif (!connect($sock,$addr) && not $!{EISCONN}) {
d130 1
d135 1
a135 1
        elsif ($blocking || !$!{EINPROGRESS})  {
d148 50
d268 1
a268 1
	 unless(defined($peer));
d299 1
a299 1
    @@_ == 4 or croak '$sock->setsockopt(LEVEL, OPTNAME)';
@


1.9
log
@merge in perl 5.8.8
@
text
@d198 1
a198 3
    getpeername($sock)
      || ${*$sock}{'io_socket_peername'}
      || undef;
d214 1
a214 1
	 unless($peer);
d240 1
@


1.8
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d22 1
a22 1
require IO::Socket::UNIX if ($^O ne 'epoc');
d26 1
a26 1
$VERSION = "1.28";
d407 1
a407 1
    $sock->read(1024,$data) until $sock->atmark;
@


1.7
log
@repeated words; millert ok ok
@
text
@d26 1
a26 1
$VERSION = "1.27";
d276 1
a276 1
    my $r = ${*$sock}{'io_socket_timeout'} || undef;
d278 1
a278 1
    ${*$sock}{'io_socket_timeout'} = 0 + $val
@


1.6
log
@From Andrushock, s/sucess/success/g
@
text
@d424 1
a424 1
If the socket is in a connected state the the peer address is returned.
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d222 1
a222 1
    # remember who we send to, if it was sucessful
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d9 1
a9 1
require 5.005_64;
d15 1
a15 1
our(@@ISA, $VERSION);
d26 3
a28 1
$VERSION = "1.26";
d32 6
a37 2
    my $callpkg = caller;
    Exporter::export 'Socket', $callpkg, @@_;
d112 1
a113 1

d115 1
a115 1
	if ($timeout && $!{EINPROGRESS}) {
d124 1
a124 1
	    elsif(!connect($sock,$addr) && not $!{EISCONN}) {
d131 1
a131 1
	else {
d171 1
a171 1
    if($timeout) {
d267 6
d372 15
a386 7
perform the system call C<accept> on the socket and return a new object. The
new object will be created in the same class as the listen socket, unless
C<PKG> is specified. This object can be used to communicate with the client
that was trying to connect. In a scalar context the new socket is returned,
or undef upon failure. In a list context a two-element array is returned
containing the new socket and the peer address; the list will
be empty upon failure.
d399 6
a404 1
=item timeout([VAL])
d406 2
a407 3
Set or get the timeout value associated with this socket. If called without
any arguments then the current setting is returned. If called with an argument
the current setting is changed and the previous value returned.
d409 4
a412 1
=item sockopt(OPT [, VAL])
d414 1
a414 2
Unified method to both set and get options in the SOL_SOCKET level. If called
with one argument then getsockopt is called, otherwise setsockopt is called.
d416 1
a416 1
=item sockdomain
d418 3
a420 2
Returns the numerical number for the socket domain type. For example, for
a AF_INET socket the value of &AF_INET will be returned.
d422 1
a422 1
=item socktype
d424 2
a425 2
Returns the numerical number for the socket type. For example, for
a SOCK_STREAM socket the value of &SOCK_STREAM will be returned.
d433 16
a448 1
=item connected
d450 3
a452 2
If the socket is in a connected state the the peer address is returned.
If the socket is not in a connected state then undef will be returned.
d462 2
a463 2
Graham Barr. Currently maintained by the Perl Porters.  Please report all
bugs to <perl5-porters@@perl.org>.
d470 5
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d364 1
a364 1
or undef upon failure. In an array context a two-element array is returned
@


1.2
log
@perl5.005_03 (stock)
@
text
@d3 2
a4 2
# Copyright (c) 1996 Graham Barr <Graham.Barr@@tiuk.ti.com>. All rights
# reserved. This program is free software; you can redistribute it and/or
d9 1
a9 70
=head1 NAME

IO::Socket - Object interface to socket communications

=head1 SYNOPSIS

    use IO::Socket;

=head1 DESCRIPTION

C<IO::Socket> provides an object interface to creating and using sockets. It
is built upon the L<IO::Handle> interface and inherits all the methods defined
by L<IO::Handle>.

C<IO::Socket> only defines methods for those operations which are common to all
types of socket. Operations which are specified to a socket in a particular 
domain have methods defined in sub classes of C<IO::Socket>

C<IO::Socket> will export all functions (and constants) defined by L<Socket>.

=head1 CONSTRUCTOR

=over 4

=item new ( [ARGS] )

Creates an C<IO::Socket>, which is a reference to a
newly created symbol (see the C<Symbol> package). C<new>
optionally takes arguments, these arguments are in key-value pairs.
C<new> only looks for one key C<Domain> which tells new which domain
the socket will be in. All other arguments will be passed to the
configuration method of the package for that domain, See below.

C<IO::Socket>s will be in autoflush mode after creation.  Note that
versions of IO::Socket prior to 1.1603 (as shipped with Perl 5.004_04)
did not do this.   So if you need backward compatibility, you should
set autoflush explicitly.

=back

=head1 METHODS

See L<perlfunc> for complete descriptions of each of the following
supported C<IO::Socket> methods, which are just front ends for the
corresponding built-in functions:

    socket
    socketpair
    bind
    listen
    accept
    send
    recv
    peername (getpeername)
    sockname (getsockname)

Some methods take slightly different arguments to those defined in L<perlfunc>
in attempt to make the interface more flexible. These are

=over 4

=item accept([PKG])

perform the system call C<accept> on the socket and return a new object. The
new object will be created in the same class as the listen socket, unless
C<PKG> is specified. This object can be used to communicate with the client
that was trying to connect. In a scalar context the new socket is returned,
or undef upon failure. In an array context a two-element array is returned
containing the new socket and the peer address, the list will
be empty upon failure.
a10 37
Additional methods that are provided are

=item timeout([VAL])

Set or get the timeout value associated with this socket. If called without
any arguments then the current setting is returned. If called with an argument
the current setting is changed and the previous value returned.

=item sockopt(OPT [, VAL])

Unified method to both set and get options in the SOL_SOCKET level. If called
with one argument then getsockopt is called, otherwise setsockopt is called.

=item sockdomain

Returns the numerical number for the socket domain type. For example, for
a AF_INET socket the value of &AF_INET will be returned.

=item socktype

Returns the numerical number for the socket type. For example, for
a SOCK_STREAM socket the value of &SOCK_STREAM will be returned.

=item protocol

Returns the numerical number for the protocol being used on the socket, if
known. If the protocol is unknown, as with an AF_UNIX socket, zero
is returned.

=back

=cut


require 5.000;

use Config;
d15 1
a15 1
use vars qw(@@ISA $VERSION);
d17 6
d26 1
a26 1
$VERSION = "1.1603";
d36 3
a38 2
    my $fh = $class->SUPER::new();
    $fh->autoflush;
d40 1
a40 1
    ${*$fh}{'io_socket_timeout'} = delete $arg{Timeout};
d42 2
a43 2
    return scalar(%arg) ? $fh->configure(\%arg)
			: $fh;
d46 1
a46 1
my @@domain2pkg = ();
d54 1
a54 1
    my($fh,$arg) = @@_;
d64 1
a64 1
	unless ref($fh) eq "IO::Socket";
d66 2
a67 2
    bless($fh, $domain2pkg[$domain]);
    $fh->configure($arg);
d71 2
a72 2
    @@_ == 4 or croak 'usage: $fh->socket(DOMAIN, TYPE, PROTOCOL)';
    my($fh,$domain,$type,$protocol) = @@_;
d74 1
a74 1
    socket($fh,$domain,$type,$protocol) or
d77 3
a79 3
    ${*$fh}{'io_socket_domain'} = $domain;
    ${*$fh}{'io_socket_type'}   = $type;
    ${*$fh}{'io_socket_proto'}  = $protocol;
d81 1
a81 1
    $fh;
d85 1
a85 1
    @@_ == 4 || croak 'usage: IO::Socket->pair(DOMAIN, TYPE, PROTOCOL)';
d87 2
a88 2
    my $fh1 = $class->new();
    my $fh2 = $class->new();
d90 1
a90 1
    socketpair($fh1,$fh2,$domain,$type,$protocol) or
d93 2
a94 2
    ${*$fh1}{'io_socket_type'}  = ${*$fh2}{'io_socket_type'}  = $type;
    ${*$fh1}{'io_socket_proto'} = ${*$fh2}{'io_socket_proto'} = $protocol;
d96 1
a96 1
    ($fh1,$fh2);
d100 30
a129 20
    @@_ == 2 || @@_ == 3 or croak 'usage: $fh->connect(NAME) or $fh->connect(PORT, ADDR)';
    my $fh = shift;
    my $addr = @@_ == 1 ? shift : sockaddr_in(@@_);
    my $timeout = ${*$fh}{'io_socket_timeout'};
    local($SIG{ALRM}) = $timeout ? sub { undef $fh; }
				 : $SIG{ALRM} || 'DEFAULT';

     eval {
    	croak 'connect: Bad address'
    	    if(@@_ == 2 && !defined $_[1]);

    	if($timeout) {
    	    defined $Config{d_alarm} && defined alarm($timeout) or
    	    	$timeout = 0;
    	}

	my $ok = connect($fh, $addr);

    	alarm(0)
    	    if($timeout);
d131 1
a131 2
	croak "connect: timeout"
	    unless defined $fh;
d133 1
a133 2
	undef $fh unless $ok;
    };
d135 1
a135 1
    $fh;
d139 3
a141 3
    @@_ == 2 || @@_ == 3 or croak 'usage: $fh->bind(NAME) or $fh->bind(PORT, ADDR)';
    my $fh = shift;
    my $addr = @@_ == 1 ? shift : sockaddr_in(@@_);
d143 2
a144 2
    return bind($fh, $addr) ? $fh
			    : undef;
d148 2
a149 2
    @@_ >= 1 && @@_ <= 2 or croak 'usage: $fh->listen([QUEUE])';
    my($fh,$queue) = @@_;
d153 2
a154 2
    return listen($fh, $queue) ? $fh
			       : undef;
d158 4
a161 4
    @@_ == 1 || @@_ == 2 or croak 'usage $fh->accept([PKG])';
    my $fh = shift;
    my $pkg = shift || $fh;
    my $timeout = ${*$fh}{'io_socket_timeout'};
d165 17
a181 14
    eval {
    	if($timeout) {
    	    my $fdset = "";
    	    vec($fdset, $fh->fileno,1) = 1;
    	    croak "accept: timeout"
    	    	unless select($fdset,undef,undef,$timeout);
    	}
    	$peer = accept($new,$fh);
    };

    return wantarray ? defined $peer ? ($new, $peer)
    	    	    	    	     : () 
    	      	     : defined $peer ? $new
    	    	    	    	     : undef;
d185 1
a185 1
    @@_ == 1 or croak 'usage: $fh->sockname()';
d190 4
a193 4
    @@_ == 1 or croak 'usage: $fh->peername()';
    my($fh) = @@_;
    getpeername($fh)
      || ${*$fh}{'io_socket_peername'}
d197 6
d204 2
a205 2
    @@_ >= 2 && @@_ <= 4 or croak 'usage: $fh->send(BUF, [FLAGS, [TO]])';
    my $fh    = $_[0];
d207 1
a207 1
    my $peer  = $_[3] || $fh->peername;
d212 3
a214 3
    my $r = defined(getpeername($fh))
	? send($fh, $_[1], $flags)
	: send($fh, $_[1], $flags, $peer);
d217 1
a217 1
    ${*$fh}{'io_socket_peername'} = $peer
d224 1
a224 1
    @@_ == 3 || @@_ == 4 or croak 'usage: $fh->recv(BUF, LEN [, FLAGS])';
d233 5
d240 1
a240 1
    @@_ == 4 or croak '$fh->setsockopt(LEVEL, OPTNAME)';
d247 1
a247 1
    @@_ == 3 or croak '$fh->getsockopt(LEVEL, OPTNAME)';
d256 3
a258 3
    my $fh = shift;
    @@_ == 1 ? $fh->getsockopt(SOL_SOCKET,@@_)
	    : $fh->setsockopt(SOL_SOCKET,@@_);
d262 3
a264 3
    @@_ == 1 || @@_ == 2 or croak 'usage: $fh->timeout([VALUE])';
    my($fh,$val) = @@_;
    my $r = ${*$fh}{'io_socket_timeout'} || undef;
d266 1
a266 1
    ${*$fh}{'io_socket_timeout'} = 0 + $val
d273 3
a275 3
    @@_ == 1 or croak 'usage: $fh->sockdomain()';
    my $fh = shift;
    ${*$fh}{'io_socket_domain'};
d279 3
a281 3
    @@_ == 1 or croak 'usage: $fh->socktype()';
    my $fh = shift;
    ${*$fh}{'io_socket_type'}
d285 3
a287 3
    @@_ == 1 or croak 'usage: $fh->protocol()';
    my($fh) = @@_;
    ${*$fh}{'io_socket_protocol'};
d290 1
a290 1
=head1 SUB-CLASSES
d292 1
a292 1
=cut
d294 1
a294 3
##
## AF_INET
##
d296 1
a296 1
package IO::Socket::INET;
d298 1
a298 5
use strict;
use vars qw(@@ISA);
use Socket;
use Carp;
use Exporter;
d300 1
a300 1
@@ISA = qw(IO::Socket);
d302 1
a302 1
IO::Socket::INET->register_domain( AF_INET );
d304 3
a306 4
my %socket_type = ( tcp => SOCK_STREAM,
		    udp => SOCK_DGRAM,
		    icmp => SOCK_RAW,
		  );
d308 3
a310 1
=head2 IO::Socket::INET
d312 1
a312 2
C<IO::Socket::INET> provides a constructor to create an AF_INET domain socket
and some related methods. The constructor can take the following options
d314 1
a314 9
    PeerAddr	Remote host address          <hostname>[:<port>]
    PeerPort	Remote port or service       <service>[(<no>)] | <no>
    LocalAddr	Local host bind	address      hostname[:port]
    LocalPort	Local host bind	port         <service>[(<no>)] | <no>
    Proto	Protocol name (or number)    "tcp" | "udp" | ...
    Type	Socket type                  SOCK_STREAM | SOCK_DGRAM | ...
    Listen	Queue size for listen
    Reuse	Set SO_REUSEADDR before binding
    Timeout	Timeout	value for various operations
d316 1
d318 1
a318 3
If C<Listen> is defined then a listen socket is created, else if the
socket type, which is derived from the protocol, is SOCK_STREAM then
connect() is called.
d320 6
a325 6
The C<PeerAddr> can be a hostname or the IP-address on the
"xx.xx.xx.xx" form.  The C<PeerPort> can be a number or a symbolic
service name.  The service name might be followed by a number in
parenthesis which is used if the service is not known by the system.
The C<PeerPort> specification can also be embedded in the C<PeerAddr>
by preceding it with a ":".
d327 1
a327 4
If C<Proto> is not given and you specify a symbolic C<PeerPort> port,
then the constructor will try to derive C<Proto> from the service
name.  As a last resort C<Proto> "tcp" is assumed.  The C<Type>
parameter will be deduced from C<Proto> if not specified.
d329 2
a330 2
If the constructor is only passed a single argument, it is assumed to
be a C<PeerAddr> specification.
d332 1
a332 1
Examples:
d334 1
a334 3
   $sock = IO::Socket::INET->new(PeerAddr => 'www.perl.org',
                                 PeerPort => 'http(80)',
                                 Proto    => 'tcp');
d336 1
a336 1
   $sock = IO::Socket::INET->new(PeerAddr => 'localhost:smtp(25)');
d338 3
a340 4
   $sock = IO::Socket::INET->new(Listen    => 5,
                                 LocalAddr => 'localhost',
                                 LocalPort => 9000,
                                 Proto     => 'tcp');
d342 10
a351 1
   $sock = IO::Socket::INET->new('127.0.0.1:25');
d353 2
a354 2

=head2 METHODS
d358 1
a358 1
=item sockaddr ()
d360 7
a366 17
Return the address part of the sockaddr structure for the socket

=item sockport ()

Return the port number that the socket is using on the local host

=item sockhost ()

Return the address part of the sockaddr structure for the socket in a
text form xx.xx.xx.xx

=item peeraddr ()

Return the address part of the sockaddr structure for the socket on
the peer host

=item peerport ()
d368 1
a368 1
Return the port number for the socket on the peer host.
d370 2
a371 4
=item peerhost ()

Return the address part of the sockaddr structure for the socket on the
peer host in a text form xx.xx.xx.xx
d375 1
a375 1
=cut
d377 1
a377 6
sub new
{
  my $class = shift;
  unshift(@@_, "PeerAddr") if @@_ == 1;
  return $class->SUPER::new(@@_);
}
d379 1
a379 4
sub _sock_info {
  my($addr,$port,$proto) = @@_;
  my @@proto = ();
  my @@serv = ();
d381 3
a383 2
  $port = $1
	if(defined $addr && $addr =~ s,:([\w\(\)/]+)$,,);
d385 1
a385 3
  if(defined $proto) {
    @@proto = $proto =~ m,\D, ? getprotobyname($proto)
			     : getprotobynumber($proto);
d387 2
a388 2
    $proto = $proto[2] || undef;
  }
d390 1
a390 2
  if(defined $port) {
    $port =~ s,\((\d+)\)$,,;
d392 2
a393 2
    my $defport = $1 || undef;
    my $pnum = ($port =~ m,^(\d+)$,)[0];
d395 1
a395 2
    @@serv= getservbyname($port, $proto[0] || "")
	if($port =~ m,\D,);
d397 2
a398 1
    $port = $pnum || $serv[2] || $defport || undef;
d400 1
a400 3
    $proto = (getprotobyname($serv[3]))[2] || undef
	if @@serv && !$proto;
  }
d402 3
a404 14
 return ($addr || undef,
	 $port || undef,
	 $proto || undef
	);
}

sub _error {
    my $fh = shift;
    $@@ = join("",ref($fh),": ",@@_);
    carp $@@ if $^W;
    close($fh)
	if(defined fileno($fh));
    return undef;
}
d406 1
a406 8
sub configure {
    my($fh,$arg) = @@_;
    my($lport,$rport,$laddr,$raddr,$proto,$type);


    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},
					$arg->{LocalPort},
					$arg->{Proto});
d408 2
a409 129
    $laddr = defined $laddr ? inet_aton($laddr)
			    : INADDR_ANY;

    return _error($fh,"Bad hostname '",$arg->{LocalAddr},"'")
	unless(defined $laddr);

    unless(exists $arg->{Listen}) {
	($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},
					    $arg->{PeerPort},
					    $proto);
    }

    if(defined $raddr) {
	$raddr = inet_aton($raddr);
	return _error($fh,"Bad hostname '",$arg->{PeerAddr},"'")
		unless(defined $raddr);
    }

    $proto ||= (getprotobyname "tcp")[2];
    return _error($fh,'Cannot determine protocol')
	unless($proto);

    my $pname = (getprotobynumber($proto))[0];
    $type = $arg->{Type} || $socket_type{$pname};

    $fh->socket(AF_INET, $type, $proto) or
	return _error($fh,"$!");

    if ($arg->{Reuse}) {
	$fh->sockopt(SO_REUSEADDR,1) or
		return _error($fh);
    }

    $fh->bind($lport || 0, $laddr) or
	return _error($fh,"$!");

    if(exists $arg->{Listen}) {
	$fh->listen($arg->{Listen} || 5) or
	    return _error($fh,"$!");
    }
    else {
	return _error($fh,'Cannot determine remote port')
		unless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);

	if($type == SOCK_STREAM || defined $raddr) {
	    return _error($fh,'Bad peer address')
	    	unless(defined $raddr);

	    $fh->connect($rport,$raddr) or
		return _error($fh,"$!");
	}
    }

    $fh;
}

sub sockaddr {
    @@_ == 1 or croak 'usage: $fh->sockaddr()';
    my($fh) = @@_;
    (sockaddr_in($fh->sockname))[1];
}

sub sockport {
    @@_ == 1 or croak 'usage: $fh->sockport()';
    my($fh) = @@_;
    (sockaddr_in($fh->sockname))[0];
}

sub sockhost {
    @@_ == 1 or croak 'usage: $fh->sockhost()';
    my($fh) = @@_;
    inet_ntoa($fh->sockaddr);
}

sub peeraddr {
    @@_ == 1 or croak 'usage: $fh->peeraddr()';
    my($fh) = @@_;
    (sockaddr_in($fh->peername))[1];
}

sub peerport {
    @@_ == 1 or croak 'usage: $fh->peerport()';
    my($fh) = @@_;
    (sockaddr_in($fh->peername))[0];
}

sub peerhost {
    @@_ == 1 or croak 'usage: $fh->peerhost()';
    my($fh) = @@_;
    inet_ntoa($fh->peeraddr);
}

##
## AF_UNIX
##

package IO::Socket::UNIX;

use strict;
use vars qw(@@ISA $VERSION);
use Socket;
use Carp;
use Exporter;

@@ISA = qw(IO::Socket);

IO::Socket::UNIX->register_domain( AF_UNIX );

=head2 IO::Socket::UNIX

C<IO::Socket::UNIX> provides a constructor to create an AF_UNIX domain socket
and some related methods. The constructor can take the following options

    Type    	Type of socket (eg SOCK_STREAM or SOCK_DGRAM)
    Local   	Path to local fifo
    Peer    	Path to peer fifo
    Listen  	Create a listen socket

=head2 METHODS

=over 4

=item hostpath()

Returns the pathname to the fifo at the local end

=item peerpath()

Returns the pathname to the fifo at the peer end
a412 41
=cut

sub configure {
    my($fh,$arg) = @@_;
    my($bport,$cport);

    my $type = $arg->{Type} || SOCK_STREAM;

    $fh->socket(AF_UNIX, $type, 0) or
	return undef;

    if(exists $arg->{Local}) {
	my $addr = sockaddr_un($arg->{Local});
	$fh->bind($addr) or
	    return undef;
    }
    if(exists $arg->{Listen}) {
	$fh->listen($arg->{Listen} || 5) or
	    return undef;
    }
    elsif(exists $arg->{Peer}) {
	my $addr = sockaddr_un($arg->{Peer});
	$fh->connect($addr) or
	    return undef;
    }

    $fh;
}

sub hostpath {
    @@_ == 1 or croak 'usage: $fh->hostpath()';
    my $n = $_[0]->sockname || return undef;
    (sockaddr_un($n))[0];
}

sub peerpath {
    @@_ == 1 or croak 'usage: $fh->peerpath()';
    my $n = $_[0]->peername || return undef;
    (sockaddr_un($n))[0];
}

d415 1
a415 1
L<Socket>, L<IO::Handle>
d419 2
a420 1
Graham Barr E<lt>F<Graham.Barr@@tiuk.ti.com>E<gt>
d424 3
a426 3
Copyright (c) 1996 Graham Barr. All rights reserved. This program is free
software; you can redistribute it and/or modify it under the same terms
as Perl itself.
a428 2

1; # Keep require happy
@


1.1
log
@perl 5.004_04
@
text
@d189 1
a189 1
    socketpair($fh1,$fh1,$domain,$type,$protocol) or
d667 1
a667 1
Returns the pathanme to the fifo at the peer end
@


1.1.1.1
log
@perl5.005_03
@
text
@d189 1
a189 1
    socketpair($fh1,$fh2,$domain,$type,$protocol) or
d667 1
a667 1
Returns the pathname to the fifo at the peer end
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d3 2
a4 2
# Copyright (c) 1997-8 Graham Barr <gbarr@@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
d9 70
a78 1
require 5.005_64;
d80 37
d121 1
a121 1
our(@@ISA, $VERSION);
a122 6
use Errno;

# legacy

require IO::Socket::INET;
require IO::Socket::UNIX if ($^O ne 'epoc');
d126 1
a126 1
$VERSION = "1.26";
d136 2
a137 3
    my $sock = $class->SUPER::new();

    $sock->autoflush(1);
d139 1
a139 1
    ${*$sock}{'io_socket_timeout'} = delete $arg{Timeout};
d141 2
a142 2
    return scalar(%arg) ? $sock->configure(\%arg)
			: $sock;
d145 1
a145 1
my @@domain2pkg;
d153 1
a153 1
    my($sock,$arg) = @@_;
d163 1
a163 1
	unless ref($sock) eq "IO::Socket";
d165 2
a166 2
    bless($sock, $domain2pkg[$domain]);
    $sock->configure($arg);
d170 2
a171 2
    @@_ == 4 or croak 'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)';
    my($sock,$domain,$type,$protocol) = @@_;
d173 1
a173 1
    socket($sock,$domain,$type,$protocol) or
d176 3
a178 3
    ${*$sock}{'io_socket_domain'} = $domain;
    ${*$sock}{'io_socket_type'}   = $type;
    ${*$sock}{'io_socket_proto'}  = $protocol;
d180 1
a180 1
    $sock;
d184 1
a184 1
    @@_ == 4 || croak 'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)';
d186 2
a187 2
    my $sock1 = $class->new();
    my $sock2 = $class->new();
d189 1
a189 1
    socketpair($sock1,$sock2,$domain,$type,$protocol) or
d192 2
a193 2
    ${*$sock1}{'io_socket_type'}  = ${*$sock2}{'io_socket_type'}  = $type;
    ${*$sock1}{'io_socket_proto'} = ${*$sock2}{'io_socket_proto'} = $protocol;
d195 1
a195 1
    ($sock1,$sock2);
d199 20
a218 30
    @@_ == 2 or croak 'usage: $sock->connect(NAME)';
    my $sock = shift;
    my $addr = shift;
    my $timeout = ${*$sock}{'io_socket_timeout'};
    my $err;
    my $blocking;
    $blocking = $sock->blocking(0) if $timeout;

    if (!connect($sock, $addr)) {
	if ($timeout && $!{EINPROGRESS}) {
	    require IO::Select;

	    my $sel = new IO::Select $sock;

	    if (!$sel->can_write($timeout)) {
		$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);
		$@@ = "connect: timeout";
	    }
	    elsif(!connect($sock,$addr) && not $!{EISCONN}) {
		# Some systems refuse to re-connect() to
		# an already open socket and set errno to EISCONN.
		$err = $!;
		$@@ = "connect: $!";
	    }
	}
	else {
	    $err = $!;
	    $@@ = "connect: $!";
	}
    }
d220 2
a221 1
    $sock->blocking(1) if $blocking;
d223 2
a224 1
    $! = $err if $err;
d226 1
a226 1
    $err ? undef : $sock;
d230 3
a232 3
    @@_ == 2 or croak 'usage: $sock->bind(NAME)';
    my $sock = shift;
    my $addr = shift;
d234 2
a235 2
    return bind($sock, $addr) ? $sock
			      : undef;
d239 2
a240 2
    @@_ >= 1 && @@_ <= 2 or croak 'usage: $sock->listen([QUEUE])';
    my($sock,$queue) = @@_;
d244 2
a245 2
    return listen($sock, $queue) ? $sock
				 : undef;
d249 4
a252 4
    @@_ == 1 || @@_ == 2 or croak 'usage $sock->accept([PKG])';
    my $sock = shift;
    my $pkg = shift || $sock;
    my $timeout = ${*$sock}{'io_socket_timeout'};
d256 14
a269 17
    if($timeout) {
	require IO::Select;

	my $sel = new IO::Select $sock;

	unless ($sel->can_read($timeout)) {
	    $@@ = 'accept: timeout';
	    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);
	    return;
	}
    }

    $peer = accept($new,$sock)
	or return;

    return wantarray ? ($new, $peer)
    	      	     : $new;
d273 1
a273 1
    @@_ == 1 or croak 'usage: $sock->sockname()';
d278 4
a281 4
    @@_ == 1 or croak 'usage: $sock->peername()';
    my($sock) = @@_;
    getpeername($sock)
      || ${*$sock}{'io_socket_peername'}
a284 6
sub connected {
    @@_ == 1 or croak 'usage: $sock->connected()';
    my($sock) = @@_;
    getpeername($sock);
}

d286 2
a287 2
    @@_ >= 2 && @@_ <= 4 or croak 'usage: $sock->send(BUF, [FLAGS, [TO]])';
    my $sock  = $_[0];
d289 1
a289 1
    my $peer  = $_[3] || $sock->peername;
d294 3
a296 3
    my $r = defined(getpeername($sock))
	? send($sock, $_[1], $flags)
	: send($sock, $_[1], $flags, $peer);
d299 1
a299 1
    ${*$sock}{'io_socket_peername'} = $peer
d306 1
a306 1
    @@_ == 3 || @@_ == 4 or croak 'usage: $sock->recv(BUF, LEN [, FLAGS])';
a314 5
sub shutdown {
    @@_ == 2 or croak 'usage: $sock->shutdown(HOW)';
    my($sock, $how) = @@_;
    shutdown($sock, $how);
}
d317 1
a317 1
    @@_ == 4 or croak '$sock->setsockopt(LEVEL, OPTNAME)';
d324 1
a324 1
    @@_ == 3 or croak '$sock->getsockopt(LEVEL, OPTNAME)';
d333 3
a335 3
    my $sock = shift;
    @@_ == 1 ? $sock->getsockopt(SOL_SOCKET,@@_)
	    : $sock->setsockopt(SOL_SOCKET,@@_);
d339 3
a341 3
    @@_ == 1 || @@_ == 2 or croak 'usage: $sock->timeout([VALUE])';
    my($sock,$val) = @@_;
    my $r = ${*$sock}{'io_socket_timeout'} || undef;
d343 1
a343 1
    ${*$sock}{'io_socket_timeout'} = 0 + $val
d350 3
a352 3
    @@_ == 1 or croak 'usage: $sock->sockdomain()';
    my $sock = shift;
    ${*$sock}{'io_socket_domain'};
d356 3
a358 3
    @@_ == 1 or croak 'usage: $sock->socktype()';
    my $sock = shift;
    ${*$sock}{'io_socket_type'}
d362 3
a364 3
    @@_ == 1 or croak 'usage: $sock->protocol()';
    my($sock) = @@_;
    ${*$sock}{'io_socket_proto'};
d367 40
a406 1
1;
d408 3
a410 1
__END__
d412 11
a422 1
=head1 NAME
d424 2
a425 1
IO::Socket - Object interface to socket communications
d427 1
a427 1
=head1 SYNOPSIS
d429 3
a431 1
    use IO::Socket;
d433 1
a433 1
=head1 DESCRIPTION
d435 4
a438 3
C<IO::Socket> provides an object interface to creating and using sockets. It
is built upon the L<IO::Handle> interface and inherits all the methods defined
by L<IO::Handle>.
d440 1
a440 3
C<IO::Socket> only defines methods for those operations which are common to all
types of socket. Operations which are specified to a socket in a particular 
domain have methods defined in sub classes of C<IO::Socket>
a441 1
C<IO::Socket> will export all functions (and constants) defined by L<Socket>.
d443 1
a443 1
=head1 CONSTRUCTOR
d447 17
a463 1
=item new ( [ARGS] )
d465 1
a465 6
Creates an C<IO::Socket>, which is a reference to a
newly created symbol (see the C<Symbol> package). C<new>
optionally takes arguments, these arguments are in key-value pairs.
C<new> only looks for one key C<Domain> which tells new which domain
the socket will be in. All other arguments will be passed to the
configuration method of the package for that domain, See below.
d467 1
a467 1
 NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
d469 1
a469 2
As of VERSION 1.18 all IO::Socket objects have autoflush turned on
by default. This was not the case with earlier releases.
d471 2
a472 1
 NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
d476 148
a623 1
=head1 METHODS
d625 5
a629 3
See L<perlfunc> for complete descriptions of each of the following
supported C<IO::Socket> methods, which are just front ends for the
corresponding built-in functions:
d631 3
a633 10
    socket
    socketpair
    bind
    listen
    accept
    send
    recv
    peername (getpeername)
    sockname (getsockname)
    shutdown
d635 1
a635 2
Some methods take slightly different arguments to those defined in L<perlfunc>
in attempt to make the interface more flexible. These are
d637 5
a641 1
=over 4
d643 1
a643 1
=item accept([PKG])
d645 1
a645 7
perform the system call C<accept> on the socket and return a new object. The
new object will be created in the same class as the listen socket, unless
C<PKG> is specified. This object can be used to communicate with the client
that was trying to connect. In a scalar context the new socket is returned,
or undef upon failure. In an array context a two-element array is returned
containing the new socket and the peer address; the list will
be empty upon failure.
d647 1
a647 1
=item socketpair(DOMAIN, TYPE, PROTOCOL)
d649 2
a650 2
Call C<socketpair> and return a list of two sockets created, or an
empty list on failure.
d652 4
a655 1
=back
d657 1
a657 1
Additional methods that are provided are:
d661 1
a661 1
=item timeout([VAL])
d663 1
a663 3
Set or get the timeout value associated with this socket. If called without
any arguments then the current setting is returned. If called with an argument
the current setting is changed and the previous value returned.
d665 1
a665 1
=item sockopt(OPT [, VAL])
d667 1
a667 2
Unified method to both set and get options in the SOL_SOCKET level. If called
with one argument then getsockopt is called, otherwise setsockopt is called.
d669 1
a669 1
=item sockdomain
d671 1
a671 2
Returns the numerical number for the socket domain type. For example, for
a AF_INET socket the value of &AF_INET will be returned.
d673 3
a675 1
=item socktype
d677 1
a677 2
Returns the numerical number for the socket type. For example, for
a SOCK_STREAM socket the value of &SOCK_STREAM will be returned.
d679 2
a680 1
=item protocol
d682 14
a695 3
Returns the numerical number for the protocol being used on the socket, if
known. If the protocol is unknown, as with an AF_UNIX socket, zero
is returned.
d697 2
a698 1
=item connected
d700 5
a704 2
If the socket is in a connected state the the peer address is returned.
If the socket is not in a connected state then undef will be returned.
d706 5
a710 1
=back
d714 1
a714 1
L<Socket>, L<IO::Handle>, L<IO::Socket::INET>, L<IO::Socket::UNIX>
d718 1
a718 2
Graham Barr. Currently maintained by the Perl Porters.  Please report all
bugs to <perl5-porters@@perl.org>.
d722 3
a724 3
Copyright (c) 1997-8 Graham Barr <gbarr@@pobox.com>. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
d727 2
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d364 1
a364 1
or undef upon failure. In a list context a two-element array is returned
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d9 1
a9 1
require 5.006;
d15 1
a15 1
our(@@ISA, $VERSION, @@EXPORT_OK);
d26 1
a26 3
$VERSION = "1.27";

@@EXPORT_OK = qw(sockatmark);
d30 2
a31 6
    if (@@_ && $_[0] eq 'sockatmark') { # not very extensible but for now, fast
	Exporter::export_to_level('IO::Socket', 1, $pkg, 'sockatmark');
    } else {
	my $callpkg = caller;
	Exporter::export 'Socket', $callpkg, @@_;
    }
d106 1
a107 1
    $blocking = $sock->blocking(0) if $timeout;
d109 1
a109 1
	if (defined $timeout && $!{EINPROGRESS}) {
d118 1
a118 1
	    elsif (!connect($sock,$addr) && not $!{EISCONN}) {
d125 1
a125 1
        elsif ($blocking || !$!{EINPROGRESS})  {
d165 1
a165 1
    if(defined $timeout) {
a260 6
sub atmark {
    @@_ == 1 or croak 'usage: $sock->atmark()';
    my($sock) = @@_;
    sockatmark($sock);
}

d360 7
a366 15
perform the system call C<accept> on the socket and return a new
object. The new object will be created in the same class as the listen
socket, unless C<PKG> is specified. This object can be used to
communicate with the client that was trying to connect.

In a scalar context the new socket is returned, or undef upon
failure. In a list context a two-element array is returned containing
the new socket and the peer address; the list will be empty upon
failure.

The timeout in the [PKG] can be specified as zero to effect a "poll",
but you shouldn't do that because a new IO::Select object will be
created behind the scenes just to do the single poll.  This is
horrendously inefficient.  Use rather true select() with a zero
timeout on the handle, or non-blocking IO.
d379 1
a379 1
=item atmark
d381 3
a383 2
True if the socket is currently positioned at the urgent data mark,
false otherwise.
d385 1
a385 1
    use IO::Socket;
d387 2
a388 2
    my $sock = IO::Socket::INET->new('some_server');
    $sock->read(1024,$data) until $sock->atmark;
d390 1
a390 4
Note: this is a reasonably new addition to the family of socket
functions, so all systems may not support this yet.  If it is
unsupported by the system, an attempt to use this method will
abort the program.
d392 2
a393 1
The atmark() functionality is also exportable as sockatmark() function:
d395 1
a395 1
	use IO::Socket 'sockatmark';
d397 2
a398 8
This allows for a more traditional use of sockatmark() as a procedural
socket function.  If your system does not support sockatmark(), the
C<use> declaration will fail at compile time.

=item connected

If the socket is in a connected state the the peer address is returned.
If the socket is not in a connected state then undef will be returned.
d406 1
a406 1
=item sockdomain
d408 2
a409 18
Returns the numerical number for the socket domain type. For example, for
an AF_INET socket the value of &AF_INET will be returned.

=item sockopt(OPT [, VAL])

Unified method to both set and get options in the SOL_SOCKET level. If called
with one argument then getsockopt is called, otherwise setsockopt is called.

=item socktype

Returns the numerical number for the socket type. For example, for
a SOCK_STREAM socket the value of &SOCK_STREAM will be returned.

=item timeout([VAL])

Set or get the timeout value associated with this socket. If called without
any arguments then the current setting is returned. If called with an argument
the current setting is changed and the previous value returned.
d419 2
a420 2
Graham Barr.  atmark() by Lincoln Stein.  Currently maintained by the
Perl Porters.  Please report all bugs to <perl5-porters@@perl.org>.
a426 5

The atmark() implementation: Copyright 2001, Lincoln Stein <lstein@@cshl.org>.
This module is distributed under the same terms as Perl itself.
Feel free to use, modify and redistribute it as long as you retain
the correct attribution.
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d26 1
a26 1
$VERSION = "1.28";
d222 1
a222 1
    # remember who we send to, if it was successful
d276 1
a276 1
    my $r = ${*$sock}{'io_socket_timeout'};
d278 1
a278 1
    ${*$sock}{'io_socket_timeout'} = defined $val ? 0 + $val : $val
d424 1
a424 1
If the socket is in a connected state the peer address is returned.
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d22 1
a22 1
require IO::Socket::UNIX if ($^O ne 'epoc' && $^O ne 'symbian');
d26 1
a26 1
$VERSION = "1.29";
d407 1
a407 1
    $sock->read($data, 1024) until $sock->atmark;
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d26 1
a26 1
$VERSION = "1.30_01";
d115 1
a115 1
	if (defined $timeout && ($!{EINPROGRESS} || $!{EWOULDBLOCK})) {
a119 1
	    undef $!;
d124 1
a124 3
	    elsif (!connect($sock,$addr) &&
                not ($!{EISCONN} || ($! == 10022 && $^O eq 'MSWin32'))
            ) {
a126 1
		# Windows sets errno to WSAEINVAL (10022)
d131 1
a131 1
        elsif ($blocking || !($!{EINPROGRESS} || $!{EWOULDBLOCK}))  {
a143 50
# Enable/disable blocking IO on sockets.
# Without args return the current status of blocking,
# with args change the mode as appropriate, returning the
# old setting, or in case of error during the mode change
# undef.

sub blocking {
    my $sock = shift;

    return $sock->SUPER::blocking(@@_)
        if $^O ne 'MSWin32';

    # Windows handles blocking differently
    #
    # http://groups.google.co.uk/group/perl.perl5.porters/browse_thread/thread/b4e2b1d88280ddff/630b667a66e3509f?#630b667a66e3509f
    # http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winsock/winsock/ioctlsocket_2.asp
    #
    # 0x8004667e is FIONBIO
    #
    # which is used to set blocking behaviour.

    # NOTE: 
    # This is a little confusing, the perl keyword for this is
    # 'blocking' but the OS level behaviour is 'non-blocking', probably
    # because sockets are blocking by default.
    # Therefore internally we have to reverse the semantics.

    my $orig= !${*$sock}{io_sock_nonblocking};
        
    return $orig unless @@_;

    my $block = shift;
    
    if ( !$block != !$orig ) {
        ${*$sock}{io_sock_nonblocking} = $block ? 0 : 1;
        ioctl($sock, 0x8004667e, pack("L!",${*$sock}{io_sock_nonblocking}))
            or return undef;
    }
    
    return $orig;        
}


sub close {
    @@_ == 1 or croak 'usage: $sock->close()';
    my $sock = shift;
    ${*$sock}{'io_socket_peername'} = undef;
    $sock->SUPER::close();
}

d198 3
a200 1
    ${*$sock}{'io_socket_peername'} ||= getpeername($sock);
d216 1
a216 1
	 unless(defined $peer);
a241 1
    ${*$sock}{'io_socket_peername'} = undef;
d246 1
a246 1
    @@_ == 4 or croak '$sock->setsockopt(LEVEL, OPTNAME, OPTVAL)';
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d26 1
a26 1
$VERSION = "1.31";
@


