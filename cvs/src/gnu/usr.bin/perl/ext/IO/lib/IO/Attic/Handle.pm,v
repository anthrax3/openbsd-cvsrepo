head	1.11;
access;
symbols
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;


1.11
date	2010.09.24.14.59.21;	author millert;	state dead;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.29;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.05;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.03;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.09.18.09.12;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.30;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.23;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.11;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.05.20;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.29;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.55.25;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.38.46;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.14;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.50;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.50;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.46.22;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.48.15;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.22;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.11.21;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package IO::Handle;

=head1 NAME

IO::Handle - supply object methods for I/O handles

=head1 SYNOPSIS

    use IO::Handle;

    $io = new IO::Handle;
    if ($io->fdopen(fileno(STDIN),"r")) {
        print $io->getline;
        $io->close;
    }

    $io = new IO::Handle;
    if ($io->fdopen(fileno(STDOUT),"w")) {
        $io->print("Some text\n");
    }

    # setvbuf is not available by default on Perls 5.8.0 and later.
    use IO::Handle '_IOLBF';
    $io->setvbuf($buffer_var, _IOLBF, 1024);

    undef $io;       # automatically closes the file if it's open

    autoflush STDOUT 1;

=head1 DESCRIPTION

C<IO::Handle> is the base class for all other IO handle classes. It is
not intended that objects of C<IO::Handle> would be created directly,
but instead C<IO::Handle> is inherited from by several other classes
in the IO hierarchy.

If you are reading this documentation, looking for a replacement for
the C<FileHandle> package, then I suggest you read the documentation
for C<IO::File> too.

=head1 CONSTRUCTOR

=over 4

=item new ()

Creates a new C<IO::Handle> object.

=item new_from_fd ( FD, MODE )

Creates an C<IO::Handle> like C<new> does.
It requires two parameters, which are passed to the method C<fdopen>;
if the fdopen fails, the object is destroyed. Otherwise, it is returned
to the caller.

=back

=head1 METHODS

See L<perlfunc> for complete descriptions of each of the following
supported C<IO::Handle> methods, which are just front ends for the
corresponding built-in functions:

    $io->close
    $io->eof
    $io->fcntl( FUNCTION, SCALAR )
    $io->fileno
    $io->format_write( [FORMAT_NAME] )
    $io->getc
    $io->ioctl( FUNCTION, SCALAR )
    $io->read ( BUF, LEN, [OFFSET] )
    $io->print ( ARGS )
    $io->printf ( FMT, [ARGS] )
    $io->say ( ARGS )
    $io->stat
    $io->sysread ( BUF, LEN, [OFFSET] )
    $io->syswrite ( BUF, [LEN, [OFFSET]] )
    $io->truncate ( LEN )

See L<perlvar> for complete descriptions of each of the following
supported C<IO::Handle> methods.  All of them return the previous
value of the attribute and takes an optional single argument that when
given will set the value.  If no argument is given the previous value
is unchanged (except for $io->autoflush will actually turn ON
autoflush by default).

    $io->autoflush ( [BOOL] )                         $|
    $io->format_page_number( [NUM] )                  $%
    $io->format_lines_per_page( [NUM] )               $=
    $io->format_lines_left( [NUM] )                   $-
    $io->format_name( [STR] )                         $~
    $io->format_top_name( [STR] )                     $^
    $io->input_line_number( [NUM])                    $.

The following methods are not supported on a per-filehandle basis.

    IO::Handle->format_line_break_characters( [STR] ) $:
    IO::Handle->format_formfeed( [STR])               $^L
    IO::Handle->output_field_separator( [STR] )       $,
    IO::Handle->output_record_separator( [STR] )      $\

    IO::Handle->input_record_separator( [STR] )       $/

Furthermore, for doing normal I/O you might need these:

=over 4

=item $io->fdopen ( FD, MODE )

C<fdopen> is like an ordinary C<open> except that its first parameter
is not a filename but rather a file handle name, an IO::Handle object,
or a file descriptor number.  (For the documentation of the C<open>
method, see L<IO::File>.)

=item $io->opened

Returns true if the object is currently a valid file descriptor, false
otherwise.

=item $io->getline

This works like <$io> described in L<perlop/"I/O Operators">
except that it's more readable and can be safely called in a
list context but still returns just one line.  If used as the conditional
+within a C<while> or C-style C<for> loop, however, you will need to
+emulate the functionality of <$io> with C<< defined($_ = $io->getline) >>.

=item $io->getlines

This works like <$io> when called in a list context to read all
the remaining lines in a file, except that it's more readable.
It will also croak() if accidentally called in a scalar context.

=item $io->ungetc ( ORD )

Pushes a character with the given ordinal value back onto the given
handle's input stream.  Only one character of pushback per handle is
guaranteed.

=item $io->write ( BUF, LEN [, OFFSET ] )

This C<write> is like C<write> found in C, that is it is the
opposite of read. The wrapper for the perl C<write> function is
called C<format_write>.

=item $io->error

Returns a true value if the given handle has experienced any errors
since it was opened or since the last call to C<clearerr>, or if the
handle is invalid. It only returns false for a valid handle with no
outstanding errors.

=item $io->clearerr

Clear the given handle's error indicator. Returns -1 if the handle is
invalid, 0 otherwise.

=item $io->sync

C<sync> synchronizes a file's in-memory state  with  that  on the
physical medium. C<sync> does not operate at the perlio api level, but
operates on the file descriptor (similar to sysread, sysseek and
systell). This means that any data held at the perlio api level will not
be synchronized. To synchronize data that is buffered at the perlio api
level you must use the flush method. C<sync> is not implemented on all
platforms. Returns "0 but true" on success, C<undef> on error, C<undef>
for an invalid handle. See L<fsync(3c)>.

=item $io->flush

C<flush> causes perl to flush any buffered data at the perlio api level.
Any unread data in the buffer will be discarded, and any unwritten data
will be written to the underlying file descriptor. Returns "0 but true"
on success, C<undef> on error.

=item $io->printflush ( ARGS )

Turns on autoflush, print ARGS and then restores the autoflush status of the
C<IO::Handle> object. Returns the return value from print.

=item $io->blocking ( [ BOOL ] )

If called with an argument C<blocking> will turn on non-blocking IO if
C<BOOL> is false, and turn it off if C<BOOL> is true.

C<blocking> will return the value of the previous setting, or the
current setting if C<BOOL> is not given. 

If an error occurs C<blocking> will return undef and C<$!> will be set.

=back


If the C functions setbuf() and/or setvbuf() are available, then
C<IO::Handle::setbuf> and C<IO::Handle::setvbuf> set the buffering
policy for an IO::Handle.  The calling sequences for the Perl functions
are the same as their C counterparts--including the constants C<_IOFBF>,
C<_IOLBF>, and C<_IONBF> for setvbuf()--except that the buffer parameter
specifies a scalar variable to use as a buffer. You should only
change the buffer before any I/O, or immediately after calling flush.

WARNING: The IO::Handle::setvbuf() is not available by default on
Perls 5.8.0 and later because setvbuf() is rather specific to using
the stdio library, while Perl prefers the new perlio subsystem instead.

WARNING: A variable used as a buffer by C<setbuf> or C<setvbuf> B<must not
be modified> in any way until the IO::Handle is closed or C<setbuf> or
C<setvbuf> is called again, or memory corruption may result! Remember that
the order of global destruction is undefined, so even if your buffer
variable remains in scope until program termination, it may be undefined
before the file IO::Handle is closed. Note that you need to import the
constants C<_IOFBF>, C<_IOLBF>, and C<_IONBF> explicitly. Like C, setbuf
returns nothing. setvbuf returns "0 but true", on success, C<undef> on
failure.

Lastly, there is a special method for working under B<-T> and setuid/gid
scripts:

=over 4

=item $io->untaint

Marks the object as taint-clean, and as such data read from it will also
be considered taint-clean. Note that this is a very trusting action to
take, and appropriate consideration for the data source and potential
vulnerability should be kept in mind. Returns 0 on success, -1 if setting
the taint-clean flag failed. (eg invalid handle)

=back

=head1 NOTE

An C<IO::Handle> object is a reference to a symbol/GLOB reference (see
the C<Symbol> package).  Some modules that
inherit from C<IO::Handle> may want to keep object related variables
in the hash table part of the GLOB. In an attempt to prevent modules
trampling on each other I propose the that any such module should prefix
its variables with its own name separated by _'s. For example the IO::Socket
module keeps a C<timeout> variable in 'io_socket_timeout'.

=head1 SEE ALSO

L<perlfunc>, 
L<perlop/"I/O Operators">,
L<IO::File>

=head1 BUGS

Due to backwards compatibility, all filehandles resemble objects
of class C<IO::Handle>, or actually classes derived from that class.
They actually aren't.  Which means you can't derive your own 
class from C<IO::Handle> and inherit those methods.

=head1 HISTORY

Derived from FileHandle.pm by Graham Barr E<lt>F<gbarr@@pobox.com>E<gt>

=cut

use 5.006_001;
use strict;
our($VERSION, @@EXPORT_OK, @@ISA);
use Carp;
use Symbol;
use SelectSaver;
use IO ();	# Load the XS module

require Exporter;
@@ISA = qw(Exporter);

$VERSION = "1.28";
$VERSION = eval $VERSION;

@@EXPORT_OK = qw(
    autoflush
    output_field_separator
    output_record_separator
    input_record_separator
    input_line_number
    format_page_number
    format_lines_per_page
    format_lines_left
    format_name
    format_top_name
    format_line_break_characters
    format_formfeed
    format_write

    print
    printf
    say
    getline
    getlines

    printflush
    flush

    SEEK_SET
    SEEK_CUR
    SEEK_END
    _IOFBF
    _IOLBF
    _IONBF
);

################################################
## Constructors, destructors.
##

sub new {
    my $class = ref($_[0]) || $_[0] || "IO::Handle";
    @@_ == 1 or croak "usage: new $class";
    my $io = gensym;
    bless $io, $class;
}

sub new_from_fd {
    my $class = ref($_[0]) || $_[0] || "IO::Handle";
    @@_ == 3 or croak "usage: new_from_fd $class FD, MODE";
    my $io = gensym;
    shift;
    IO::Handle::fdopen($io, @@_)
	or return undef;
    bless $io, $class;
}

#
# There is no need for DESTROY to do anything, because when the
# last reference to an IO object is gone, Perl automatically
# closes its associated files (if any).  However, to avoid any
# attempts to autoload DESTROY, we here define it to do nothing.
#
sub DESTROY {}


################################################
## Open and close.
##

sub _open_mode_string {
    my ($mode) = @@_;
    $mode =~ /^\+?(<|>>?)$/
      or $mode =~ s/^r(\+?)$/$1</
      or $mode =~ s/^w(\+?)$/$1>/
      or $mode =~ s/^a(\+?)$/$1>>/
      or croak "IO::Handle: bad open mode: $mode";
    $mode;
}

sub fdopen {
    @@_ == 3 or croak 'usage: $io->fdopen(FD, MODE)';
    my ($io, $fd, $mode) = @@_;
    local(*GLOB);

    if (ref($fd) && "".$fd =~ /GLOB\(/o) {
	# It's a glob reference; Alias it as we cannot get name of anon GLOBs
	my $n = qualify(*GLOB);
	*GLOB = *{*$fd};
	$fd =  $n;
    } elsif ($fd =~ m#^\d+$#) {
	# It's an FD number; prefix with "=".
	$fd = "=$fd";
    }

    open($io, _open_mode_string($mode) . '&' . $fd)
	? $io : undef;
}

sub close {
    @@_ == 1 or croak 'usage: $io->close()';
    my($io) = @@_;

    close($io);
}

################################################
## Normal I/O functions.
##

# flock
# select

sub opened {
    @@_ == 1 or croak 'usage: $io->opened()';
    defined fileno($_[0]);
}

sub fileno {
    @@_ == 1 or croak 'usage: $io->fileno()';
    fileno($_[0]);
}

sub getc {
    @@_ == 1 or croak 'usage: $io->getc()';
    getc($_[0]);
}

sub eof {
    @@_ == 1 or croak 'usage: $io->eof()';
    eof($_[0]);
}

sub print {
    @@_ or croak 'usage: $io->print(ARGS)';
    my $this = shift;
    print $this @@_;
}

sub printf {
    @@_ >= 2 or croak 'usage: $io->printf(FMT,[ARGS])';
    my $this = shift;
    printf $this @@_;
}

sub say {
    @@_ or croak 'usage: $io->say(ARGS)';
    my $this = shift;
    local $\ = "\n";
    print $this @@_;
}

sub getline {
    @@_ == 1 or croak 'usage: $io->getline()';
    my $this = shift;
    return scalar <$this>;
} 

*gets = \&getline;  # deprecated

sub getlines {
    @@_ == 1 or croak 'usage: $io->getlines()';
    wantarray or
	croak 'Can\'t call $io->getlines in a scalar context, use $io->getline';
    my $this = shift;
    return <$this>;
}

sub truncate {
    @@_ == 2 or croak 'usage: $io->truncate(LEN)';
    truncate($_[0], $_[1]);
}

sub read {
    @@_ == 3 || @@_ == 4 or croak 'usage: $io->read(BUF, LEN [, OFFSET])';
    read($_[0], $_[1], $_[2], $_[3] || 0);
}

sub sysread {
    @@_ == 3 || @@_ == 4 or croak 'usage: $io->sysread(BUF, LEN [, OFFSET])';
    sysread($_[0], $_[1], $_[2], $_[3] || 0);
}

sub write {
    @@_ >= 2 && @@_ <= 4 or croak 'usage: $io->write(BUF [, LEN [, OFFSET]])';
    local($\) = "";
    $_[2] = length($_[1]) unless defined $_[2];
    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);
}

sub syswrite {
    @@_ >= 2 && @@_ <= 4 or croak 'usage: $io->syswrite(BUF [, LEN [, OFFSET]])';
    if (defined($_[2])) {
	syswrite($_[0], $_[1], $_[2], $_[3] || 0);
    } else {
	syswrite($_[0], $_[1]);
    }
}

sub stat {
    @@_ == 1 or croak 'usage: $io->stat()';
    stat($_[0]);
}

################################################
## State modification functions.
##

sub autoflush {
    my $old = new SelectSaver qualify($_[0], caller);
    my $prev = $|;
    $| = @@_ > 1 ? $_[1] : 1;
    $prev;
}

sub output_field_separator {
    carp "output_field_separator is not supported on a per-handle basis"
	if ref($_[0]);
    my $prev = $,;
    $, = $_[1] if @@_ > 1;
    $prev;
}

sub output_record_separator {
    carp "output_record_separator is not supported on a per-handle basis"
	if ref($_[0]);
    my $prev = $\;
    $\ = $_[1] if @@_ > 1;
    $prev;
}

sub input_record_separator {
    carp "input_record_separator is not supported on a per-handle basis"
	if ref($_[0]);
    my $prev = $/;
    $/ = $_[1] if @@_ > 1;
    $prev;
}

sub input_line_number {
    local $.;
    () = tell qualify($_[0], caller) if ref($_[0]);
    my $prev = $.;
    $. = $_[1] if @@_ > 1;
    $prev;
}

sub format_page_number {
    my $old;
    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
    my $prev = $%;
    $% = $_[1] if @@_ > 1;
    $prev;
}

sub format_lines_per_page {
    my $old;
    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
    my $prev = $=;
    $= = $_[1] if @@_ > 1;
    $prev;
}

sub format_lines_left {
    my $old;
    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
    my $prev = $-;
    $- = $_[1] if @@_ > 1;
    $prev;
}

sub format_name {
    my $old;
    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
    my $prev = $~;
    $~ = qualify($_[1], caller) if @@_ > 1;
    $prev;
}

sub format_top_name {
    my $old;
    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
    my $prev = $^;
    $^ = qualify($_[1], caller) if @@_ > 1;
    $prev;
}

sub format_line_break_characters {
    carp "format_line_break_characters is not supported on a per-handle basis"
	if ref($_[0]);
    my $prev = $:;
    $: = $_[1] if @@_ > 1;
    $prev;
}

sub format_formfeed {
    carp "format_formfeed is not supported on a per-handle basis"
	if ref($_[0]);
    my $prev = $^L;
    $^L = $_[1] if @@_ > 1;
    $prev;
}

sub formline {
    my $io = shift;
    my $picture = shift;
    local($^A) = $^A;
    local($\) = "";
    formline($picture, @@_);
    print $io $^A;
}

sub format_write {
    @@_ < 3 || croak 'usage: $io->write( [FORMAT_NAME] )';
    if (@@_ == 2) {
	my ($io, $fmt) = @@_;
	my $oldfmt = $io->format_name(qualify($fmt,caller));
	CORE::write($io);
	$io->format_name($oldfmt);
    } else {
	CORE::write($_[0]);
    }
}

sub fcntl {
    @@_ == 3 || croak 'usage: $io->fcntl( OP, VALUE );';
    my ($io, $op) = @@_;
    return fcntl($io, $op, $_[2]);
}

sub ioctl {
    @@_ == 3 || croak 'usage: $io->ioctl( OP, VALUE );';
    my ($io, $op) = @@_;
    return ioctl($io, $op, $_[2]);
}

# this sub is for compatability with older releases of IO that used
# a sub called constant to detemine if a constant existed -- GMB
#
# The SEEK_* and _IO?BF constants were the only constants at that time
# any new code should just chech defined(&CONSTANT_NAME)

sub constant {
    no strict 'refs';
    my $name = shift;
    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})
	? &{$name}() : undef;
}


# so that flush.pl can be deprecated

sub printflush {
    my $io = shift;
    my $old;
    $old = new SelectSaver qualify($io, caller) if ref($io);
    local $| = 1;
    if(ref($io)) {
        print $io @@_;
    }
    else {
	print @@_;
    }
}

1;
@


1.10
log
@Merge in perl 5.10.1
@
text
@@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d66 1
d70 1
d112 2
a113 1
or a file descriptor number.
d271 1
a271 1
$VERSION = "1.27";
d418 2
a419 1
    print $this @@_, "\n";
a593 1
# XXX undocumented
a599 1
# XXX undocumented
@


1.8
log
@merge in perl 5.8.8
@
text
@d72 1
d268 1
a268 1
$VERSION = "1.25";
d288 1
d412 6
d582 1
a582 1
	my $oldfmt = $io->format_name($fmt);
@


1.7
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d120 3
a122 1
list context but still returns just one line.
d267 1
a267 1
$VERSION = "1.24";
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d265 1
a265 1
$VERSION = "1.23";
d497 1
a497 1
    my $tell = tell qualify($_[0], caller) if ref($_[0]);
d504 2
a505 1
    my $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d512 2
a513 1
    my $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d520 2
a521 1
    my $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d528 2
a529 1
    my $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d536 2
a537 1
    my $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d612 2
a613 1
    my $old = new SelectSaver qualify($io, caller) if ref($io);
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@a0 1

d22 1
d196 4
d265 1
a265 1
$VERSION = "1.21_00";
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d51 1
a51 1
Creates a C<IO::Handle> like C<new> does.
d103 1
a103 1
=over 
d108 1
a108 1
is not a filename but rather a file handle name, a IO::Handle object,
d209 1
a209 1
=over
d223 1
a223 1
A C<IO::Handle> object is a reference to a symbol/GLOB reference (see
d250 1
a250 1
require 5.005_64;
d261 2
a262 1
$VERSION = "1.21";
d599 1
a599 1
# so that flush.pl can be depriciated
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d74 1
a74 1
    $io->syswrite ( BUF, LEN, [OFFSET] )
d113 2
a114 1
Returns true if the object is currently a valid file descriptor.
d119 2
a120 2
except that it's more readable and can be safely called in an
array context but still returns just one line.
d124 2
a125 2
This works like <$io> when called in an array context to
read all the remaining lines in a file, except that it's more readable.
d143 3
a145 1
since it was opened or since the last call to C<clearerr>.
d149 2
a150 1
Clear the given handle's error indicator.
d156 6
a161 4
operates on the file descriptor, this means that any data held at the
perlio api level will not be synchronized. To synchronize data that is
buffered at the perlio api level you must use the flush method. C<sync>
is not implemented on all platforms. See L<fsync(3c)>.
d167 2
a168 1
will be written to the underlying file descriptor.
d173 1
a173 1
C<IO::Handle> object.
d193 12
a204 5
specifies a scalar variable to use as a buffer.  WARNING: A variable
used as a buffer by C<setbuf> or C<setvbuf> must not be modified in any
way until the IO::Handle is closed or C<setbuf> or C<setvbuf> is called
again, or memory corruption may result! Note that you need to import
the constants C<_IOFBF>, C<_IOLBF>, and C<_IONBF> explicitly.
d216 2
a217 1
vulnerability should be kept in mind.
d443 5
a447 2
    $_[2] = length($_[1]) unless defined $_[2];
    syswrite($_[0], $_[1], $_[2], $_[3] || 0);
@


1.2
log
@perl5.005_03 (stock)
@
text
@d12 4
a15 4
    $fh = new IO::Handle;
    if ($fh->fdopen(fileno(STDIN),"r")) {
        print $fh->getline;
        $fh->close;
d18 3
a20 3
    $fh = new IO::Handle;
    if ($fh->fdopen(fileno(STDOUT),"w")) {
        $fh->print("Some text\n");
d24 1
a24 1
    $fh->setvbuf($buffer_var, _IOLBF, 1024);
d26 1
a26 1
    undef $fh;       # automatically closes the file if it's open
d39 1
a39 3
for C<IO::File>

A C<IO::Handle> object is a reference to a symbol (see the C<Symbol> package)
d64 12
a75 11
    close
    fileno
    getc
    eof
    read
    truncate
    stat
    print
    printf
    sysread
    syswrite
d78 20
a97 1
supported C<IO::Handle> methods:
d99 1
a99 13
    autoflush
    output_field_separator
    output_record_separator
    input_record_separator
    input_line_number
    format_page_number
    format_lines_per_page
    format_lines_left
    format_name
    format_top_name
    format_line_break_characters
    format_formfeed
    format_write
d105 1
a105 1
=item $fh->fdopen ( FD, MODE )
d111 1
a111 1
=item $fh->opened
d115 1
a115 1
=item $fh->getline
d117 1
a117 1
This works like <$fh> described in L<perlop/"I/O Operators">
d121 1
a121 1
=item $fh->getlines
d123 1
a123 1
This works like <$fh> when called in an array context to
d127 1
a127 1
=item $fh->ungetc ( ORD )
d130 2
a131 1
handle's input stream.
d133 1
a133 1
=item $fh->write ( BUF, LEN [, OFFSET }\] )
d139 1
a139 5
=item $fh->flush

Flush the given handle's buffer.

=item $fh->error
d144 1
a144 1
=item $fh->clearerr
d148 30
d180 1
d189 1
a189 1
again, or memory corruption may result!  Note that you need to import
d197 1
a197 1
=item $fh->untaint
d208 2
a209 1
A C<IO::Handle> object is a GLOB reference. Some modules that
d231 1
a231 1
Derived from FileHandle.pm by Graham Barr E<lt>F<bodg@@tiuk.ti.com>E<gt>
d235 1
a235 1
require 5.000;
d237 1
a237 1
use vars qw($VERSION $XS_VERSION @@EXPORT_OK $AUTOLOAD @@ISA);
d241 1
d246 1
a246 2
$VERSION = "1.1505";
$XS_VERSION = "1.15";
d268 3
a278 24

################################################
## Interaction with the XS.
##

require DynaLoader;
@@IO::ISA = qw(DynaLoader);
bootstrap IO $XS_VERSION;

sub AUTOLOAD {
    if ($AUTOLOAD =~ /::(_?[a-z])/) {
	$AutoLoader::AUTOLOAD = $AUTOLOAD;
	goto &AutoLoader::AUTOLOAD
    }
    my $constname = $AUTOLOAD;
    $constname =~ s/.*:://;
    my $val = constant($constname);
    defined $val or croak "$constname is not a valid IO::Handle macro";
    no strict 'refs';
    *$AUTOLOAD = sub { $val };
    goto &$AUTOLOAD;
}


d286 2
a287 2
    my $fh = gensym;
    bless $fh, $class;
d293 1
a293 1
    my $fh = gensym;
d295 1
a295 1
    IO::Handle::fdopen($fh, @@_)
d297 1
a297 1
    bless $fh, $class;
d324 2
a325 2
    @@_ == 3 or croak 'usage: $fh->fdopen(FD, MODE)';
    my ($fh, $fd, $mode) = @@_;
d338 2
a339 2
    open($fh, _open_mode_string($mode) . '&' . $fd)
	? $fh : undef;
d343 2
a344 2
    @@_ == 1 or croak 'usage: $fh->close()';
    my($fh) = @@_;
d346 1
a346 1
    close($fh);
d357 1
a357 1
    @@_ == 1 or croak 'usage: $fh->opened()';
d362 1
a362 1
    @@_ == 1 or croak 'usage: $fh->fileno()';
d367 1
a367 1
    @@_ == 1 or croak 'usage: $fh->getc()';
d372 1
a372 1
    @@_ == 1 or croak 'usage: $fh->eof()';
d377 1
a377 1
    @@_ or croak 'usage: $fh->print([ARGS])';
d383 1
a383 1
    @@_ >= 2 or croak 'usage: $fh->printf(FMT,[ARGS])';
d389 1
a389 1
    @@_ == 1 or croak 'usage: $fh->getline';
d397 1
a397 1
    @@_ == 1 or croak 'usage: $fh->getline()';
d399 1
a399 1
	croak 'Can\'t call $fh->getlines in a scalar context, use $fh->getline';
d405 1
a405 1
    @@_ == 2 or croak 'usage: $fh->truncate(LEN)';
d410 1
a410 1
    @@_ == 3 || @@_ == 4 or croak '$fh->read(BUF, LEN [, OFFSET])';
d415 1
a415 1
    @@_ == 3 || @@_ == 4 or croak '$fh->sysread(BUF, LEN [, OFFSET])';
d420 1
a420 1
    @@_ == 3 || @@_ == 4 or croak '$fh->write(BUF, LEN [, OFFSET])';
d422 1
d427 2
a428 1
    @@_ == 3 || @@_ == 4 or croak '$fh->syswrite(BUF, LEN [, OFFSET])';
d433 1
a433 1
    @@_ == 1 or croak 'usage: $fh->stat()';
d442 1
a442 1
    my $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d449 2
d457 2
d465 2
d473 2
a474 1
    # localizing $. doesn't work as advertised.  grrrrrr.
d516 2
d524 2
d532 1
a532 1
    my $fh = shift;
d537 1
a537 1
    print $fh $^A;
d541 1
a541 1
    @@_ < 3 || croak 'usage: $fh->write( [FORMAT_NAME] )';
d543 4
a546 4
	my ($fh, $fmt) = @@_;
	my $oldfmt = $fh->format_name($fmt);
	CORE::write($fh);
	$fh->format_name($oldfmt);
d552 1
d554 3
a556 4
    @@_ == 3 || croak 'usage: $fh->fcntl( OP, VALUE );';
    my ($fh, $op, $val) = @@_;
    my $r = fcntl($fh, $op, $val);
    defined $r && $r eq "0 but true" ? 0 : $r;
d559 1
d561 31
a591 4
    @@_ == 3 || croak 'usage: $fh->ioctl( OP, VALUE );';
    my ($fh, $op, $val) = @@_;
    my $r = ioctl($fh, $op, $val);
    defined $r && $r eq "0 but true" ? 0 : $r;
@


1.1
log
@perl 5.004_04
@
text
@d210 1
a210 1
$VERSION = "1.1504";
d426 1
a426 1
    my $old = new SelectSaver qualify($_[0], caller);
a432 1
    my $old = new SelectSaver qualify($_[0], caller);
a438 1
    my $old = new SelectSaver qualify($_[0], caller);
a444 1
    my $old = new SelectSaver qualify($_[0], caller);
d451 1
a451 1
    my $old = new SelectSaver qualify($_[0], caller);
d458 1
a458 1
    my $old = new SelectSaver qualify($_[0], caller);
d465 1
a465 1
    my $old = new SelectSaver qualify($_[0], caller);
d472 1
a472 1
    my $old = new SelectSaver qualify($_[0], caller);
d479 1
a479 1
    my $old = new SelectSaver qualify($_[0], caller);
d486 1
a486 1
    my $old = new SelectSaver qualify($_[0], caller);
a492 1
    my $old = new SelectSaver qualify($_[0], caller);
a498 1
    my $old = new SelectSaver qualify($_[0], caller);
d518 1
a518 1
	write($fh);
d521 1
a521 1
	write($_[0]);
@


1.1.1.1
log
@perl5.005_03
@
text
@d210 1
a210 1
$VERSION = "1.1505";
d426 1
a426 1
    my $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d433 1
d440 1
d447 1
d454 1
a454 1
    # localizing $. doesn't work as advertised.  grrrrrr.
d461 1
a461 1
    my $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d468 1
a468 1
    my $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d475 1
a475 1
    my $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d482 1
a482 1
    my $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d489 1
a489 1
    my $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d496 1
d503 1
d523 1
a523 1
	CORE::write($fh);
d526 1
a526 1
	CORE::write($_[0]);
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d12 4
a15 4
    $io = new IO::Handle;
    if ($io->fdopen(fileno(STDIN),"r")) {
        print $io->getline;
        $io->close;
d18 3
a20 3
    $io = new IO::Handle;
    if ($io->fdopen(fileno(STDOUT),"w")) {
        $io->print("Some text\n");
d24 1
a24 1
    $io->setvbuf($buffer_var, _IOLBF, 1024);
d26 1
a26 1
    undef $io;       # automatically closes the file if it's open
d39 3
a41 1
for C<IO::File> too.
d66 11
a76 12
    $io->close
    $io->eof
    $io->fileno
    $io->format_write( [FORMAT_NAME] )
    $io->getc
    $io->read ( BUF, LEN, [OFFSET] )
    $io->print ( ARGS )
    $io->printf ( FMT, [ARGS] )
    $io->stat
    $io->sysread ( BUF, LEN, [OFFSET] )
    $io->syswrite ( BUF, LEN, [OFFSET] )
    $io->truncate ( LEN )
d79 1
a79 20
supported C<IO::Handle> methods.  All of them return the previous
value of the attribute and takes an optional single argument that when
given will set the value.  If no argument is given the previous value
is unchanged (except for $io->autoflush will actually turn ON
autoflush by default).

    $io->autoflush ( [BOOL] )                         $|
    $io->format_page_number( [NUM] )                  $%
    $io->format_lines_per_page( [NUM] )               $=
    $io->format_lines_left( [NUM] )                   $-
    $io->format_name( [STR] )                         $~
    $io->format_top_name( [STR] )                     $^
    $io->input_line_number( [NUM])                    $.

The following methods are not supported on a per-filehandle basis.

    IO::Handle->format_line_break_characters( [STR] ) $:
    IO::Handle->format_formfeed( [STR])               $^L
    IO::Handle->output_field_separator( [STR] )       $,
    IO::Handle->output_record_separator( [STR] )      $\
d81 13
a93 1
    IO::Handle->input_record_separator( [STR] )       $/
d99 1
a99 1
=item $io->fdopen ( FD, MODE )
d105 1
a105 1
=item $io->opened
d109 1
a109 1
=item $io->getline
d111 1
a111 1
This works like <$io> described in L<perlop/"I/O Operators">
d115 1
a115 1
=item $io->getlines
d117 1
a117 1
This works like <$io> when called in an array context to
d121 1
a121 1
=item $io->ungetc ( ORD )
d124 1
a124 2
handle's input stream.  Only one character of pushback per handle is
guaranteed.
d126 1
a126 1
=item $io->write ( BUF, LEN [, OFFSET ] )
d132 5
a136 1
=item $io->error
d141 1
a141 1
=item $io->clearerr
a144 30
=item $io->sync

C<sync> synchronizes a file's in-memory state  with  that  on the
physical medium. C<sync> does not operate at the perlio api level, but
operates on the file descriptor, this means that any data held at the
perlio api level will not be synchronized. To synchronize data that is
buffered at the perlio api level you must use the flush method. C<sync>
is not implemented on all platforms. See L<fsync(3c)>.

=item $io->flush

C<flush> causes perl to flush any buffered data at the perlio api level.
Any unread data in the buffer will be discarded, and any unwritten data
will be written to the underlying file descriptor.

=item $io->printflush ( ARGS )

Turns on autoflush, print ARGS and then restores the autoflush status of the
C<IO::Handle> object.

=item $io->blocking ( [ BOOL ] )

If called with an argument C<blocking> will turn on non-blocking IO if
C<BOOL> is false, and turn it off if C<BOOL> is true.

C<blocking> will return the value of the previous setting, or the
current setting if C<BOOL> is not given. 

If an error occurs C<blocking> will return undef and C<$!> will be set.

a146 1

d155 1
a155 1
again, or memory corruption may result! Note that you need to import
d163 1
a163 1
=item $io->untaint
d174 1
a174 2
A C<IO::Handle> object is a reference to a symbol/GLOB reference (see
the C<Symbol> package).  Some modules that
d196 1
a196 1
Derived from FileHandle.pm by Graham Barr E<lt>F<gbarr@@pobox.com>E<gt>
d200 1
a200 1
require 5.005_64;
d202 1
a202 1
our($VERSION, @@EXPORT_OK, @@ISA);
a205 1
use IO ();	# Load the XS module
d210 2
a211 1
$VERSION = "1.21";
a232 3
    printflush
    flush

d241 24
d272 2
a273 2
    my $io = gensym;
    bless $io, $class;
d279 1
a279 1
    my $io = gensym;
d281 1
a281 1
    IO::Handle::fdopen($io, @@_)
d283 1
a283 1
    bless $io, $class;
d310 2
a311 2
    @@_ == 3 or croak 'usage: $io->fdopen(FD, MODE)';
    my ($io, $fd, $mode) = @@_;
d324 2
a325 2
    open($io, _open_mode_string($mode) . '&' . $fd)
	? $io : undef;
d329 2
a330 2
    @@_ == 1 or croak 'usage: $io->close()';
    my($io) = @@_;
d332 1
a332 1
    close($io);
d343 1
a343 1
    @@_ == 1 or croak 'usage: $io->opened()';
d348 1
a348 1
    @@_ == 1 or croak 'usage: $io->fileno()';
d353 1
a353 1
    @@_ == 1 or croak 'usage: $io->getc()';
d358 1
a358 1
    @@_ == 1 or croak 'usage: $io->eof()';
d363 1
a363 1
    @@_ or croak 'usage: $io->print(ARGS)';
d369 1
a369 1
    @@_ >= 2 or croak 'usage: $io->printf(FMT,[ARGS])';
d375 1
a375 1
    @@_ == 1 or croak 'usage: $io->getline()';
d383 1
a383 1
    @@_ == 1 or croak 'usage: $io->getlines()';
d385 1
a385 1
	croak 'Can\'t call $io->getlines in a scalar context, use $io->getline';
d391 1
a391 1
    @@_ == 2 or croak 'usage: $io->truncate(LEN)';
d396 1
a396 1
    @@_ == 3 || @@_ == 4 or croak 'usage: $io->read(BUF, LEN [, OFFSET])';
d401 1
a401 1
    @@_ == 3 || @@_ == 4 or croak 'usage: $io->sysread(BUF, LEN [, OFFSET])';
d406 1
a406 1
    @@_ >= 2 && @@_ <= 4 or croak 'usage: $io->write(BUF [, LEN [, OFFSET]])';
a407 1
    $_[2] = length($_[1]) unless defined $_[2];
d412 1
a412 2
    @@_ >= 2 && @@_ <= 4 or croak 'usage: $io->syswrite(BUF [, LEN [, OFFSET]])';
    $_[2] = length($_[1]) unless defined $_[2];
d417 1
a417 1
    @@_ == 1 or croak 'usage: $io->stat()';
d426 1
a426 1
    my $old = new SelectSaver qualify($_[0], caller);
a432 2
    carp "output_field_separator is not supported on a per-handle basis"
	if ref($_[0]);
a438 2
    carp "output_record_separator is not supported on a per-handle basis"
	if ref($_[0]);
a444 2
    carp "input_record_separator is not supported on a per-handle basis"
	if ref($_[0]);
d451 1
a451 2
    local $.;
    my $tell = tell qualify($_[0], caller) if ref($_[0]);
a492 2
    carp "format_line_break_characters is not supported on a per-handle basis"
	if ref($_[0]);
a498 2
    carp "format_formfeed is not supported on a per-handle basis"
	if ref($_[0]);
d505 1
a505 1
    my $io = shift;
d510 1
a510 1
    print $io $^A;
d514 1
a514 1
    @@_ < 3 || croak 'usage: $io->write( [FORMAT_NAME] )';
d516 4
a519 4
	my ($io, $fmt) = @@_;
	my $oldfmt = $io->format_name($fmt);
	CORE::write($io);
	$io->format_name($oldfmt);
a524 1
# XXX undocumented
d526 4
a529 3
    @@_ == 3 || croak 'usage: $io->fcntl( OP, VALUE );';
    my ($io, $op) = @@_;
    return fcntl($io, $op, $_[2]);
a531 1
# XXX undocumented
d533 4
a536 31
    @@_ == 3 || croak 'usage: $io->ioctl( OP, VALUE );';
    my ($io, $op) = @@_;
    return ioctl($io, $op, $_[2]);
}

# this sub is for compatability with older releases of IO that used
# a sub called constant to detemine if a constant existed -- GMB
#
# The SEEK_* and _IO?BF constants were the only constants at that time
# any new code should just chech defined(&CONSTANT_NAME)

sub constant {
    no strict 'refs';
    my $name = shift;
    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})
	? &{$name}() : undef;
}


# so that flush.pl can be depriciated

sub printflush {
    my $io = shift;
    my $old = new SelectSaver qualify($io, caller) if ref($io);
    local $| = 1;
    if(ref($io)) {
        print $io @@_;
    }
    else {
	print @@_;
    }
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d74 1
a74 1
    $io->syswrite ( BUF, [LEN, [OFFSET]] )
d113 1
a113 2
Returns true if the object is currently a valid file descriptor, false
otherwise.
d118 2
a119 2
except that it's more readable and can be safely called in a
list context but still returns just one line.
d123 2
a124 2
This works like <$io> when called in a list context to read all
the remaining lines in a file, except that it's more readable.
d142 1
a142 3
since it was opened or since the last call to C<clearerr>, or if the
handle is invalid. It only returns false for a valid handle with no
outstanding errors.
d146 1
a146 2
Clear the given handle's error indicator. Returns -1 if the handle is
invalid, 0 otherwise.
d152 4
a155 6
operates on the file descriptor (similar to sysread, sysseek and
systell). This means that any data held at the perlio api level will not
be synchronized. To synchronize data that is buffered at the perlio api
level you must use the flush method. C<sync> is not implemented on all
platforms. Returns "0 but true" on success, C<undef> on error, C<undef>
for an invalid handle. See L<fsync(3c)>.
d161 1
a161 2
will be written to the underlying file descriptor. Returns "0 but true"
on success, C<undef> on error.
d166 1
a166 1
C<IO::Handle> object. Returns the return value from print.
d186 5
a190 12
specifies a scalar variable to use as a buffer. You should only
change the buffer before any I/O, or immediately after calling flush.

WARNING: A variable used as a buffer by C<setbuf> or C<setvbuf> B<must not
be modified> in any way until the IO::Handle is closed or C<setbuf> or
C<setvbuf> is called again, or memory corruption may result! Remember that
the order of global destruction is undefined, so even if your buffer
variable remains in scope until program termination, it may be undefined
before the file IO::Handle is closed. Note that you need to import the
constants C<_IOFBF>, C<_IOLBF>, and C<_IONBF> explicitly. Like C, setbuf
returns nothing. setvbuf returns "0 but true", on success, C<undef> on
failure.
d202 1
a202 2
vulnerability should be kept in mind. Returns 0 on success, -1 if setting
the taint-clean flag failed. (eg invalid handle)
d428 2
a429 5
    if (defined($_[2])) {
	syswrite($_[0], $_[1], $_[2], $_[3] || 0);
    } else {
	syswrite($_[0], $_[1]);
    }
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d51 1
a51 1
Creates an C<IO::Handle> like C<new> does.
d103 1
a103 1
=over 4
d108 1
a108 1
is not a filename but rather a file handle name, an IO::Handle object,
d209 1
a209 1
=over 4
d223 1
a223 1
An C<IO::Handle> object is a reference to a symbol/GLOB reference (see
d250 1
a250 1
use 5.006_001;
d261 1
a261 2
$VERSION = "1.21_00";
$VERSION = eval $VERSION;
d598 1
a598 1
# so that flush.pl can be deprecated
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d1 1
a22 1
    # setvbuf is not available by default on Perls 5.8.0 and later.
a195 4
WARNING: The IO::Handle::setvbuf() is not available by default on
Perls 5.8.0 and later because setvbuf() is rather specific to using
the stdio library, while Perl prefers the new perlio subsystem instead.

d261 1
a261 1
$VERSION = "1.23";
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d265 1
a265 1
$VERSION = "1.24";
d497 1
a497 1
    () = tell qualify($_[0], caller) if ref($_[0]);
d504 1
a504 2
    my $old;
    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d511 1
a511 2
    my $old;
    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d518 1
a518 2
    my $old;
    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d525 1
a525 2
    my $old;
    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d532 1
a532 2
    my $old;
    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
d607 1
a607 2
    my $old;
    $old = new SelectSaver qualify($io, caller) if ref($io);
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d120 1
a120 3
list context but still returns just one line.  If used as the conditional
+within a C<while> or C-style C<for> loop, however, you will need to
+emulate the functionality of <$io> with C<< defined($_ = $io->getline) >>.
d265 1
a265 1
$VERSION = "1.25";
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@a71 1
    $io->say ( ARGS )
d267 1
a267 1
$VERSION = "1.27";
a286 1
    say
a409 6
sub say {
    @@_ or croak 'usage: $io->say(ARGS)';
    my $this = shift;
    print $this @@_, "\n";
}

d574 1
a574 1
	my $oldfmt = $io->format_name(qualify($fmt,caller));
@


1.1.1.9
log
@import perl 5.10.1
@
text
@a65 1
    $io->fcntl( FUNCTION, SCALAR )
a68 1
    $io->ioctl( FUNCTION, SCALAR )
d110 1
a110 2
or a file descriptor number.  (For the documentation of the C<open>
method, see L<IO::File>.)
d268 1
a268 1
$VERSION = "1.28";
d415 1
a415 2
    local $\ = "\n";
    print $this @@_;
d590 1
d597 1
@


