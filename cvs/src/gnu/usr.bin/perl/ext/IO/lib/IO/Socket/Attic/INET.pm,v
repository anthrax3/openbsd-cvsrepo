head	1.9;
access;
symbols
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.3.0.6
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.4
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2010.09.24.14.59.21;	author millert;	state dead;
branches;
next	1.8;

1.8
date	2009.10.12.18.24.29;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.05;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.03;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.03.03.02.30;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.27.22.25.23;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.24.18.35.12;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.30.04.43.18;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.06.16.09.14;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.09.14;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.22.51;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.43.50;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.16;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.22;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.11.21;	author millert;	state Exp;
branches;
next	;


desc
@@


1.9
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@# IO::Socket::INET.pm
#
# Copyright (c) 1997-8 Graham Barr <gbarr@@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package IO::Socket::INET;

use strict;
our(@@ISA, $VERSION);
use IO::Socket;
use Socket;
use Carp;
use Exporter;
use Errno;

@@ISA = qw(IO::Socket);
$VERSION = "1.31";

my $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;

IO::Socket::INET->register_domain( AF_INET );

my %socket_type = ( tcp  => SOCK_STREAM,
		    udp  => SOCK_DGRAM,
		    icmp => SOCK_RAW
		  );
my %proto_number;
$proto_number{tcp}  = Socket::IPPROTO_TCP()  if defined &Socket::IPPROTO_TCP;
$proto_number{udp}  = Socket::IPPROTO_UDP()  if defined &Socket::IPPROTO_UDP;
$proto_number{icmp} = Socket::IPPROTO_ICMP() if defined &Socket::IPPROTO_ICMP;
my %proto_name = reverse %proto_number;

sub new {
    my $class = shift;
    unshift(@@_, "PeerAddr") if @@_ == 1;
    return $class->SUPER::new(@@_);
}

sub _cache_proto {
    my @@proto = @@_;
    for (map lc($_), $proto[0], split(' ', $proto[1])) {
	$proto_number{$_} = $proto[2];
    }
    $proto_name{$proto[2]} = $proto[0];
}

sub _get_proto_number {
    my $name = lc(shift);
    return undef unless defined $name;
    return $proto_number{$name} if exists $proto_number{$name};

    my @@proto = getprotobyname($name);
    return undef unless @@proto;
    _cache_proto(@@proto);

    return $proto[2];
}

sub _get_proto_name {
    my $num = shift;
    return undef unless defined $num;
    return $proto_name{$num} if exists $proto_name{$num};

    my @@proto = getprotobynumber($num);
    return undef unless @@proto;
    _cache_proto(@@proto);

    return $proto[0];
}

sub _sock_info {
  my($addr,$port,$proto) = @@_;
  my $origport = $port;
  my @@serv = ();

  $port = $1
	if(defined $addr && $addr =~ s,:([\w\(\)/]+)$,,);

  if(defined $proto  && $proto =~ /\D/) {
    my $num = _get_proto_number($proto);
    unless (defined $num) {
      $@@ = "Bad protocol '$proto'";
      return;
    }
    $proto = $num;
  }

  if(defined $port) {
    my $defport = ($port =~ s,\((\d+)\)$,,) ? $1 : undef;
    my $pnum = ($port =~ m,^(\d+)$,)[0];

    @@serv = getservbyname($port, _get_proto_name($proto) || "")
	if ($port =~ m,\D,);

    $port = $serv[2] || $defport || $pnum;
    unless (defined $port) {
	$@@ = "Bad service '$origport'";
	return;
    }

    $proto = _get_proto_number($serv[3]) if @@serv && !$proto;
  }

 return ($addr || undef,
	 $port || undef,
	 $proto || undef
	);
}

sub _error {
    my $sock = shift;
    my $err = shift;
    {
      local($!);
      my $title = ref($sock).": ";
      $@@ = join("", $_[0] =~ /^$title/ ? "" : $title, @@_);
      $sock->close()
	if(defined fileno($sock));
    }
    $! = $err;
    return undef;
}

sub _get_addr {
    my($sock,$addr_str, $multi) = @@_;
    my @@addr;
    if ($multi && $addr_str !~ /^\d+(?:\.\d+){3}$/) {
	(undef, undef, undef, undef, @@addr) = gethostbyname($addr_str);
    } else {
	my $h = inet_aton($addr_str);
	push(@@addr, $h) if defined $h;
    }
    @@addr;
}

sub configure {
    my($sock,$arg) = @@_;
    my($lport,$rport,$laddr,$raddr,$proto,$type);


    $arg->{LocalAddr} = $arg->{LocalHost}
	if exists $arg->{LocalHost} && !exists $arg->{LocalAddr};

    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},
					$arg->{LocalPort},
					$arg->{Proto})
			or return _error($sock, $!, $@@);

    $laddr = defined $laddr ? inet_aton($laddr)
			    : INADDR_ANY;

    return _error($sock, $EINVAL, "Bad hostname '",$arg->{LocalAddr},"'")
	unless(defined $laddr);

    $arg->{PeerAddr} = $arg->{PeerHost}
	if exists $arg->{PeerHost} && !exists $arg->{PeerAddr};

    unless(exists $arg->{Listen}) {
	($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},
					    $arg->{PeerPort},
					    $proto)
			or return _error($sock, $!, $@@);
    }

    $proto ||= _get_proto_number('tcp');

    $type = $arg->{Type} || $socket_type{lc _get_proto_name($proto)};

    my @@raddr = ();

    if(defined $raddr) {
	@@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});
	return _error($sock, $EINVAL, "Bad hostname '",$arg->{PeerAddr},"'")
	    unless @@raddr;
    }

    while(1) {

	$sock->socket(AF_INET, $type, $proto) or
	    return _error($sock, $!, "$!");

        if (defined $arg->{Blocking}) {
	    defined $sock->blocking($arg->{Blocking})
		or return _error($sock, $!, "$!");
	}

	if ($arg->{Reuse} || $arg->{ReuseAddr}) {
	    $sock->sockopt(SO_REUSEADDR,1) or
		    return _error($sock, $!, "$!");
	}

	if ($arg->{ReusePort}) {
	    $sock->sockopt(SO_REUSEPORT,1) or
		    return _error($sock, $!, "$!");
	}

	if ($arg->{Broadcast}) {
		$sock->sockopt(SO_BROADCAST,1) or
		    return _error($sock, $!, "$!");
	}

	if($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {
	    $sock->bind($lport || 0, $laddr) or
		    return _error($sock, $!, "$!");
	}

	if(exists $arg->{Listen}) {
	    $sock->listen($arg->{Listen} || 5) or
		return _error($sock, $!, "$!");
	    last;
	}

 	# don't try to connect unless we're given a PeerAddr
 	last unless exists($arg->{PeerAddr});
 
        $raddr = shift @@raddr;

	return _error($sock, $EINVAL, 'Cannot determine remote port')
		unless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);

	last
	    unless($type == SOCK_STREAM || defined $raddr);

	return _error($sock, $EINVAL, "Bad hostname '",$arg->{PeerAddr},"'")
	    unless defined $raddr;

#        my $timeout = ${*$sock}{'io_socket_timeout'};
#        my $before = time() if $timeout;

	undef $@@;
        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {
#            ${*$sock}{'io_socket_timeout'} = $timeout;
            return $sock;
        }

	return _error($sock, $!, $@@ || "Timeout")
	    unless @@raddr;

#	if ($timeout) {
#	    my $new_timeout = $timeout - (time() - $before);
#	    return _error($sock,
#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),
#                         "Timeout") if $new_timeout <= 0;
#	    ${*$sock}{'io_socket_timeout'} = $new_timeout;
#        }

    }

    $sock;
}

sub connect {
    @@_ == 2 || @@_ == 3 or
       croak 'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)';
    my $sock = shift;
    return $sock->SUPER::connect(@@_ == 1 ? shift : pack_sockaddr_in(@@_));
}

sub bind {
    @@_ == 2 || @@_ == 3 or
       croak 'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)';
    my $sock = shift;
    return $sock->SUPER::bind(@@_ == 1 ? shift : pack_sockaddr_in(@@_))
}

sub sockaddr {
    @@_ == 1 or croak 'usage: $sock->sockaddr()';
    my($sock) = @@_;
    my $name = $sock->sockname;
    $name ? (sockaddr_in($name))[1] : undef;
}

sub sockport {
    @@_ == 1 or croak 'usage: $sock->sockport()';
    my($sock) = @@_;
    my $name = $sock->sockname;
    $name ? (sockaddr_in($name))[0] : undef;
}

sub sockhost {
    @@_ == 1 or croak 'usage: $sock->sockhost()';
    my($sock) = @@_;
    my $addr = $sock->sockaddr;
    $addr ? inet_ntoa($addr) : undef;
}

sub peeraddr {
    @@_ == 1 or croak 'usage: $sock->peeraddr()';
    my($sock) = @@_;
    my $name = $sock->peername;
    $name ? (sockaddr_in($name))[1] : undef;
}

sub peerport {
    @@_ == 1 or croak 'usage: $sock->peerport()';
    my($sock) = @@_;
    my $name = $sock->peername;
    $name ? (sockaddr_in($name))[0] : undef;
}

sub peerhost {
    @@_ == 1 or croak 'usage: $sock->peerhost()';
    my($sock) = @@_;
    my $addr = $sock->peeraddr;
    $addr ? inet_ntoa($addr) : undef;
}

1;

__END__

=head1 NAME

IO::Socket::INET - Object interface for AF_INET domain sockets

=head1 SYNOPSIS

    use IO::Socket::INET;

=head1 DESCRIPTION

C<IO::Socket::INET> provides an object interface to creating and using sockets
in the AF_INET domain. It is built upon the L<IO::Socket> interface and
inherits all the methods defined by L<IO::Socket>.

=head1 CONSTRUCTOR

=over 4

=item new ( [ARGS] )

Creates an C<IO::Socket::INET> object, which is a reference to a
newly created symbol (see the C<Symbol> package). C<new>
optionally takes arguments, these arguments are in key-value pairs.

In addition to the key-value pairs accepted by L<IO::Socket>,
C<IO::Socket::INET> provides.


    PeerAddr	Remote host address          <hostname>[:<port>]
    PeerHost	Synonym for PeerAddr
    PeerPort	Remote port or service       <service>[(<no>)] | <no>
    LocalAddr	Local host bind	address      hostname[:port]
    LocalHost	Synonym for LocalAddr
    LocalPort	Local host bind	port         <service>[(<no>)] | <no>
    Proto	Protocol name (or number)    "tcp" | "udp" | ...
    Type	Socket type                  SOCK_STREAM | SOCK_DGRAM | ...
    Listen	Queue size for listen
    ReuseAddr	Set SO_REUSEADDR before binding
    Reuse	Set SO_REUSEADDR before binding (deprecated, prefer ReuseAddr)
    ReusePort	Set SO_REUSEPORT before binding
    Broadcast	Set SO_BROADCAST before binding
    Timeout	Timeout	value for various operations
    MultiHomed  Try all addresses for multi-homed hosts
    Blocking    Determine if connection will be blocking mode

If C<Listen> is defined then a listen socket is created, else if the
socket type, which is derived from the protocol, is SOCK_STREAM then
connect() is called.

Although it is not illegal, the use of C<MultiHomed> on a socket
which is in non-blocking mode is of little use. This is because the
first connect will never fail with a timeout as the connect call
will not block.

The C<PeerAddr> can be a hostname or the IP-address on the
"xx.xx.xx.xx" form.  The C<PeerPort> can be a number or a symbolic
service name.  The service name might be followed by a number in
parenthesis which is used if the service is not known by the system.
The C<PeerPort> specification can also be embedded in the C<PeerAddr>
by preceding it with a ":".

If C<Proto> is not given and you specify a symbolic C<PeerPort> port,
then the constructor will try to derive C<Proto> from the service
name.  As a last resort C<Proto> "tcp" is assumed.  The C<Type>
parameter will be deduced from C<Proto> if not specified.

If the constructor is only passed a single argument, it is assumed to
be a C<PeerAddr> specification.

If C<Blocking> is set to 0, the connection will be in nonblocking mode.
If not specified it defaults to 1 (blocking mode).

Examples:

   $sock = IO::Socket::INET->new(PeerAddr => 'www.perl.org',
                                 PeerPort => 'http(80)',
                                 Proto    => 'tcp');

   $sock = IO::Socket::INET->new(PeerAddr => 'localhost:smtp(25)');

   $sock = IO::Socket::INET->new(Listen    => 5,
                                 LocalAddr => 'localhost',
                                 LocalPort => 9000,
                                 Proto     => 'tcp');

   $sock = IO::Socket::INET->new('127.0.0.1:25');

   $sock = IO::Socket::INET->new(PeerPort  => 9999,
                                 PeerAddr  => inet_ntoa(INADDR_BROADCAST),
                                 Proto     => udp,    
                                 LocalAddr => 'localhost',
                                 Broadcast => 1 ) 
                             or die "Can't bind : $@@\n";

 NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE

As of VERSION 1.18 all IO::Socket objects have autoflush turned on
by default. This was not the case with earlier releases.

 NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE

=back

=head2 METHODS

=over 4

=item sockaddr ()

Return the address part of the sockaddr structure for the socket

=item sockport ()

Return the port number that the socket is using on the local host

=item sockhost ()

Return the address part of the sockaddr structure for the socket in a
text form xx.xx.xx.xx

=item peeraddr ()

Return the address part of the sockaddr structure for the socket on
the peer host

=item peerport ()

Return the port number for the socket on the peer host.

=item peerhost ()

Return the address part of the sockaddr structure for the socket on the
peer host in a text form xx.xx.xx.xx

=back

=head1 SEE ALSO

L<Socket>, L<IO::Socket>

=head1 AUTHOR

Graham Barr. Currently maintained by the Perl Porters.  Please report all
bugs to <perl5-porters@@perl.org>.

=head1 COPYRIGHT

Copyright (c) 1996-8 Graham Barr <gbarr@@pobox.com>. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
@


1.8
log
@Merge in perl 5.10.1
@
text
@@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d30 1
a30 1
$proto_number{upd}  = Socket::IPPROTO_UDP()  if defined &Socket::IPPROTO_UDP;
@


1.6
log
@merge in perl 5.8.8
@
text
@d18 1
a18 1
$VERSION = "1.29";
d28 5
d40 32
a74 1
  my @@proto = ();
d81 2
a82 4
    if(@@proto = getprotobyname($proto)) {
      $proto = $proto[2] || undef;
    }
    else {
d86 1
d93 1
a93 1
    @@serv = getservbyname($port, $proto[0] || "")
d102 1
a102 2
    $proto = (getprotobyname($serv[3]))[2] || undef
	if @@serv && !$proto;
d118 1
a118 1
      close($sock)
d166 1
a166 1
    $proto ||= (getprotobyname('tcp'))[2];
d168 1
a168 2
    my $pname = (getprotobynumber($proto))[0];
    $type = $arg->{Type} || $socket_type{lc $pname};
@


1.5
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d18 1
a18 1
$VERSION = "1.27";
d135 1
a135 1
    $type = $arg->{Type} || $socket_type{$pname};
d322 1
a322 1
    MultiHomed  Try all adresses for multi-homed hosts
@


1.4
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d18 1
a18 1
$VERSION = "1.26";
a131 2
    $sock->blocking($arg->{Blocking}) if defined $arg->{Blocking};

d149 5
@


1.3
log
@merge in perl 5.6.1 with our local changes
@
text
@d18 1
a18 1
$VERSION = "1.25";
d44 2
a45 5
  if(defined $proto) {
    if (@@proto = ( $proto =~ m,\D,
		? getprotobyname($proto)
		: getprotobynumber($proto))
    ) {
d55 1
a55 3
    $port =~ s,\((\d+)\)$,,;

    my $defport = $1 || undef;
d61 1
a61 1
    $port = $pnum || $serv[2] || $defport || undef;
d82 2
a83 1
      $@@ = join("",ref($sock),": ",@@_);
d132 2
d162 5
d195 1
d201 1
a201 1
	return _error($sock, $!, "Timeout")
d317 1
d320 1
a320 1

d328 1
a328 1
first connect will never fail with a timeout as the connaect call
d346 3
d364 6
@


1.2
log
@Change 5982 by gsar@@auger on 2000/04/28 04:48:25
avoid error in IO::Socket::INET when given an unknown service name
with a port number (from Brian Raven <brianr@@ssprdmh01.liffe.com>)
@
text
@d154 1
a154 1
	if ($arg->{Reuse}) {
d159 5
d310 3
a312 1
    Reuse	Set SO_REUSEADDR before binding
@


1.1
log
@Initial revision
@
text
@d37 1
d63 6
a68 3
    if ($port =~ m,\D,) {
      unless (@@serv = getservbyname($port, $proto[0] || "")) {
	$@@ = "Bad service '$port'";
a69 1
      }
a70 2

    $port = $pnum || $serv[2] || $defport || undef;
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@a36 1
  my $origport = $port;
d62 6
a67 2
    @@serv = getservbyname($port, $proto[0] || "")
	if ($port =~ m,\D,);
a69 4
    unless (defined $port) {
	$@@ = "Bad service '$origport'";
	return;
    }
d153 1
a153 1
	if ($arg->{Reuse} || $arg->{ReuseAddr}) {
a157 5
	if ($arg->{ReusePort}) {
	    $sock->sockopt(SO_REUSEPORT,1) or
		    return _error($sock, $!, "$!");
	}

d304 1
a304 3
    ReuseAddr	Set SO_REUSEADDR before binding
    Reuse	Set SO_REUSEADDR before binding (deprecated, prefer ReuseAddr)
    ReusePort	Set SO_REUSEPORT before binding
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d18 1
a18 1
$VERSION = "1.26";
d44 5
a48 2
  if(defined $proto  && $proto =~ /\D/) {
    if(@@proto = getprotobyname($proto)) {
d58 3
a60 1
    my $defport = ($port =~ s,\((\d+)\)$,,) ? $1 : undef;
d66 1
a66 1
    $port = $serv[2] || $defport || $pnum;
d87 1
a87 2
      my $title = ref($sock).": ";
      $@@ = join("", $_[0] =~ /^$title/ ? "" : $title, @@_);
a135 2
    $sock->blocking($arg->{Blocking}) if defined $arg->{Blocking};

a163 5
	if ($arg->{Broadcast}) {
		$sock->sockopt(SO_BROADCAST,1) or
		    return _error($sock, $!, "$!");
	}

a191 1
	undef $@@;
d197 1
a197 1
	return _error($sock, $!, $@@ || "Timeout")
a312 1
    Broadcast	Set SO_BROADCAST before binding
d315 1
a315 1
    Blocking    Determine if connection will be blocking mode
d323 1
a323 1
first connect will never fail with a timeout as the connect call
a340 3
If C<Blocking> is set to 0, the connection will be in nonblocking mode.
If not specified it defaults to 1 (blocking mode).

a355 6
   $sock = IO::Socket::INET->new(PeerPort  => 9999,
                                 PeerAddr  => inet_ntoa(INADDR_BROADCAST),
                                 Proto     => udp,    
                                 LocalAddr => 'localhost',
                                 Broadcast => 1 ) 
                             or die "Can't bind : $@@\n";
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d18 1
a18 1
$VERSION = "1.27";
d132 2
a150 5

        if (defined $arg->{Blocking}) {
	    defined $sock->blocking($arg->{Blocking})
		or return _error($sock, $!, "$!");
	}
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d18 1
a18 1
$VERSION = "1.29";
d135 1
a135 1
    $type = $arg->{Type} || $socket_type{lc $pname};
d322 1
a322 1
    MultiHomed  Try all addresses for multi-homed hosts
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d18 1
a18 1
$VERSION = "1.31";
a27 5
my %proto_number;
$proto_number{tcp}  = Socket::IPPROTO_TCP()  if defined &Socket::IPPROTO_TCP;
$proto_number{upd}  = Socket::IPPROTO_UDP()  if defined &Socket::IPPROTO_UDP;
$proto_number{icmp} = Socket::IPPROTO_ICMP() if defined &Socket::IPPROTO_ICMP;
my %proto_name = reverse %proto_number;
a34 32
sub _cache_proto {
    my @@proto = @@_;
    for (map lc($_), $proto[0], split(' ', $proto[1])) {
	$proto_number{$_} = $proto[2];
    }
    $proto_name{$proto[2]} = $proto[0];
}

sub _get_proto_number {
    my $name = lc(shift);
    return undef unless defined $name;
    return $proto_number{$name} if exists $proto_number{$name};

    my @@proto = getprotobyname($name);
    return undef unless @@proto;
    _cache_proto(@@proto);

    return $proto[2];
}

sub _get_proto_name {
    my $num = shift;
    return undef unless defined $num;
    return $proto_name{$num} if exists $proto_name{$num};

    my @@proto = getprotobynumber($num);
    return undef unless @@proto;
    _cache_proto(@@proto);

    return $proto[0];
}

d38 1
d45 4
a48 2
    my $num = _get_proto_number($proto);
    unless (defined $num) {
a51 1
    $proto = $num;
d58 1
a58 1
    @@serv = getservbyname($port, _get_proto_name($proto) || "")
d67 2
a68 1
    $proto = _get_proto_number($serv[3]) if @@serv && !$proto;
d84 1
a84 1
      $sock->close()
d132 1
a132 1
    $proto ||= _get_proto_number('tcp');
d134 2
a135 1
    $type = $arg->{Type} || $socket_type{lc _get_proto_name($proto)};
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d30 1
a30 1
$proto_number{udp}  = Socket::IPPROTO_UDP()  if defined &Socket::IPPROTO_UDP;
@


