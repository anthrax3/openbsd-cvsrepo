head	1.2;
access;
symbols
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.16
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.14
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.12
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.10
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.8
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.6
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.4
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.2
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2009.10.12.18.24.31;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.51;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.01.15.21.16.57;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.23;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Merge in perl 5.10.1
@
text
@BEGIN {
        chdir 't' if -d 't';
        @@INC = '../lib';
}

use MIME::QuotedPrint;

$x70 = "x" x 70;

@@tests =
  (
   # plain ascii should not be encoded
   ["quoted printable"  =>
    "quoted printable"],

   # 8-bit chars should be encoded
   ["v\xe5re kj\xe6re norske tegn b\xf8r \xe6res" =>
    "v=E5re kj=E6re norske tegn b=F8r =E6res"],

   # trailing space should be encoded
   ["  " => "=20=20"],
   ["\tt\t" => "\tt=09"],
   ["test  \ntest\n\t \t \n" => "test=20=20\ntest\n=09=20=09=20\n"],

   # "=" is special an should be decoded
   ["=\n" => "=3D\n"],
   ["\0\xff" => "=00=FF"],

   # Very long lines should be broken (not more than 76 chars
   ["The Quoted-Printable encoding is intended to represent data that largly consists of octets that correspond to printable characters in the ASCII character set." =>
    "The Quoted-Printable encoding is intended to represent data that largly con=
sists of octets that correspond to printable characters in the ASCII charac=
ter set."
    ],

   # Long lines after short lines were broken through 2.01.
   ["short line
In America, any boy may become president and I suppose that's just one of the risks he takes. -- Adlai Stevenson" =>
    "short line
In America, any boy may become president and I suppose that's just one of t=
he risks he takes. -- Adlai Stevenson"],

   # My (roderick@@argon.org) first crack at fixing that bug failed for
   # multiple long lines.
   ["College football is a game which would be much more interesting if the faculty played instead of the students, and even more interesting if the
trustees played.  There would be a great increase in broken arms, legs, and necks, and simultaneously an appreciable diminution in the loss to humanity. -- H. L. Mencken" =>
    "College football is a game which would be much more interesting if the facu=
lty played instead of the students, and even more interesting if the
trustees played.  There would be a great increase in broken arms, legs, and=
 necks, and simultaneously an appreciable diminution in the loss to humanit=
y. -- H. L. Mencken"],

   # Don't break a line that's near but not over 76 chars.
   ["$x70!23"		=> "$x70!23"],
   ["$x70!234"		=> "$x70!234"],
   ["$x70!2345"		=> "$x70!2345"],
   ["$x70!23456"	=> "$x70!23456"],
   ["$x70!23\n"		=> "$x70!23\n"],
   ["$x70!234\n"	=> "$x70!234\n"],
   ["$x70!2345\n"	=> "$x70!2345\n"],
   ["$x70!23456\n"	=> "$x70!23456\n"],

   # Not allowed to break =XX escapes using soft line break
   ["$x70===xxxx" => "$x70=3D=\n=3D=3Dxxxx"],
   ["$x70!===xxx" => "$x70!=3D=\n=3D=3Dxxx"],
   ["$x70!!===xx" => "$x70!!=3D=\n=3D=3Dxx"],
   ["$x70!!!===x" => "$x70!!!=\n=3D=3D=3Dx"],
   #                            ^
   #                    70123456|
   #                           max
   #                        line width
);

$notests = @@tests + 3;
print "1..$notests\n";

$testno = 0;
for (@@tests) {
    $testno++;
    ($plain, $encoded) = @@$_;
    if (ord('A') == 193) {  # EBCDIC 8 bit chars are different
        if ($testno == 2) { $plain =~ s/\xe5/\x47/; $plain =~ s/\xe6/\x9c/g; $plain =~ s/\xf8/\x70/; }
        if ($testno == 7) { $plain =~ s/\xff/\xdf/; }
    }
    $x = encode_qp($plain);
    if ($x ne $encoded) {
	print "Encode test failed\n";
	print "Got:      '$x'\n";
	print "Expected: '$encoded'\n";
	print "not ok $testno\n";
	next;
    }
    $x = decode_qp($encoded);
    if ($x ne $plain) {
	print "Decode test failed\n";
	print "Got:      '$x'\n";
	print "Expected: '$plain'\n";
	print "not ok $testno\n";
	next;
    }
    print "ok $testno\n";
}

# Some extra testing for a case that was wrong until libwww-perl-5.09
print "not " unless decode_qp("foo  \n\nfoo =\n\nfoo=20\n\n") eq
                                "foo\n\nfoo \nfoo \n\n";
$testno++; print "ok $testno\n";

# Same test but with "\r\n" terminated lines
print "not " unless decode_qp("foo  \r\n\r\nfoo =\r\n\r\nfoo=20\r\n\r\n") eq
                                "foo\r\n\r\nfoo \r\nfoo \r\n\r\n";
$testno++; print "ok $testno\n";

print "not " if eval { encode_qp("XXX \x{100}") } || $@@ !~ /^The Quoted-Printable encoding is only defined for bytes/;
$testno++; print "ok $testno\n";
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d2 2
a3 4
        if ($ENV{PERL_CORE}) {
                chdir 't' if -d 't';
                @@INC = '../lib';
        }
d26 2
a27 2
   ["=30\n" => "=3D30\n"],
   ["\0\xff0" => "=00=FF0"],
a57 2
   ["$x70!234567"	=> "$x70!2345=\n67"],
   ["$x70!23456="	=> "$x70!2345=\n6=3D"],
a61 2
   ["$x70!234567\n"	=> "$x70!2345=\n67\n"],
   ["$x70!23456=\n"	=> "$x70!2345=\n6=3D\n"],
d64 8
a71 22
   ["$x70===xxxxx"  => "$x70=3D=\n=3D=3Dxxxxx"],
   ["$x70!===xxxx"  => "$x70!=3D=\n=3D=3Dxxxx"],
   ["$x70!2===xxx"  => "$x70!2=3D=\n=3D=3Dxxx"],
   ["$x70!23===xx"  => "$x70!23=\n=3D=3D=3Dxx"],
   ["$x70!234===x"  => "$x70!234=\n=3D=3D=3Dx"],
   ["$x70!2=\n"     => "$x70!2=3D\n"],
   ["$x70!23=\n"    => "$x70!23=\n=3D\n"],
   ["$x70!234=\n"   => "$x70!234=\n=3D\n"],
   ["$x70!2345=\n"  => "$x70!2345=\n=3D\n"],
   ["$x70!23456=\n" => "$x70!2345=\n6=3D\n"],
   #                              ^
   #                      70123456|
   #                             max
   #                          line width

   # some extra special cases we have had problems with
   ["$x70!2=x=x" => "$x70!2=3D=\nx=3Dx"],
   ["$x70!2345$x70!2345$x70!23456\n", "$x70!2345=\n$x70!2345=\n$x70!23456\n"],

   # trailing whitespace
   ["foo \t ", "foo=20=09=20"],
   ["foo\t \n \t", "foo=09=20\n=20=09"],
d74 1
a74 1
$notests = @@tests + 13;
d111 1
a111 34
                                "foo\n\nfoo \nfoo \n\n";
$testno++; print "ok $testno\n";

# Trailing whitespace
print "not " unless decode_qp("foo  ") eq "foo  ";
$testno++; print "ok $testno\n";

print "not " unless decode_qp("foo  \n") eq "foo\n";
$testno++; print "ok $testno\n";

print "not " unless decode_qp("foo = \t\x20\nbar\t\x20\n") eq "foo bar\n";
$testno++; print "ok $testno\n";

print "not " unless decode_qp("foo = \t\x20\r\nbar\t\x20\r\n") eq "foo bar\n";
$testno++; print "ok $testno\n";

print "not " unless decode_qp("foo = \t\x20\n") eq "foo ";
$testno++; print "ok $testno\n";

print "not " unless decode_qp("foo = \t\x20\r\n") eq "foo ";
$testno++; print "ok $testno\n";

print "not " unless decode_qp("foo = \t\x20y\r\n") eq "foo = \t\x20y\n";
$testno++; print "ok $testno\n";

print "not " unless decode_qp("foo =xy\n") eq "foo =xy\n";
$testno++; print "ok $testno\n";

# Test with with alternative line break
print "not " unless encode_qp("$x70!2345$x70\n", "***") eq "$x70!2345=***$x70***";
$testno++; print "ok $testno\n";

# Test with no line breaks
print "not " unless encode_qp("$x70!2345$x70\n", "") eq "$x70!2345$x70=0A";
d114 1
a114 1
print "not " if $] >= 5.006 && (eval 'encode_qp("XXX \x{100}")' || !$@@);
@


1.1.1.3
log
@perl 5.8.6 from CPAN
@
text
@a14 1
   ["", ""],
d16 1
a16 1
    "quoted printable=\n"],
d20 1
a20 1
    "v=E5re kj=E6re norske tegn b=F8r =E6res=\n"],
d23 2
a24 2
   ["  " => "=20=20=\n"],
   ["\tt\t" => "\tt=09=\n"],
d29 1
a29 1
   ["\0\xff0" => "=00=FF0=\n"],
d35 1
a35 1
ter set.=\n"
d43 1
a43 1
he risks he takes. -- Adlai Stevenson=\n"],
d53 1
a53 1
y. -- H. L. Mencken=\n"],
d56 6
a61 6
   ["$x70!23"		=> "$x70!23=\n"],
   ["$x70!234"		=> "$x70!234=\n"],
   ["$x70!2345"		=> "$x70!2345=\n"],
   ["$x70!23456"	=> "$x70!23456=\n"],
   ["$x70!234567"	=> "$x70!2345=\n67=\n"],
   ["$x70!23456="	=> "$x70!2345=\n6=3D=\n"],
d70 5
a74 5
   ["$x70===xxxxx"  => "$x70=3D=\n=3D=3Dxxxxx=\n"],
   ["$x70!===xxxx"  => "$x70!=3D=\n=3D=3Dxxxx=\n"],
   ["$x70!2===xxx"  => "$x70!2=3D=\n=3D=3Dxxx=\n"],
   ["$x70!23===xx"  => "$x70!23=\n=3D=3D=3Dxx=\n"],
   ["$x70!234===x"  => "$x70!234=\n=3D=3D=3Dx=\n"],
d86 1
a86 1
   ["$x70!2=x=x" => "$x70!2=3D=\nx=3Dx=\n"],
d90 2
a91 2
   ["foo \t ", "foo=20=09=20=\n"],
   ["foo\t \n \t", "foo=09=20\n=20=09=\n"],
d94 1
a94 1
$notests = @@tests + 16;
a165 18

# Test binary encoding
print "not " unless encode_qp("foo", undef, 1) eq "foo=\n";
$testno++; print "ok $testno\n";

print "not " unless encode_qp("foo\nbar\r\n", undef, 1) eq "foo=0Abar=0D=0A=\n";
$testno++; print "ok $testno\n";

print "not " unless encode_qp(join("", map chr, 0..255), undef, 1) eq <<'EOT'; $testno++; print "ok $testno\n";
=00=01=02=03=04=05=06=07=08=09=0A=0B=0C=0D=0E=0F=10=11=12=13=14=15=16=17=18=
=19=1A=1B=1C=1D=1E=1F !"#$%&'()*+,-./0123456789:;<=3D>?@@ABCDEFGHIJKLMNOPQRS=
TUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~=7F=80=81=82=83=84=85=86=87=88=
=89=8A=8B=8C=8D=8E=8F=90=91=92=93=94=95=96=97=98=99=9A=9B=9C=9D=9E=9F=A0=A1=
=A2=A3=A4=A5=A6=A7=A8=A9=AA=AB=AC=AD=AE=AF=B0=B1=B2=B3=B4=B5=B6=B7=B8=B9=BA=
=BB=BC=BD=BE=BF=C0=C1=C2=C3=C4=C5=C6=C7=C8=C9=CA=CB=CC=CD=CE=CF=D0=D1=D2=D3=
=D4=D5=D6=D7=D8=D9=DA=DB=DC=DD=DE=DF=E0=E1=E2=E3=E4=E5=E6=E7=E8=E9=EA=EB=EC=
=ED=EE=EF=F0=F1=F2=F3=F4=F5=F6=F7=F8=F9=FA=FB=FC=FD=FE=FF=
EOT
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@a11 5
$IsASCII  = ord('A') == 65;
$IsEBCDIC = ord('A') == 193;

if ($IsASCII) {

a94 89
} elsif ($IsEBCDIC) {

@@tests =
  (
   # plain ascii should not be encoded
   ["", ""],
   ["quoted printable"  =>
    "quoted printable=\n"],

   # 8-bit chars should be encoded
   ["v\x47re kj\x9cre norske tegn b\x70r \x47res" =>
    "v=47re kj=9Cre norske tegn b=70r =47res=\n"],

   # trailing space should be encoded
   ["  " => "=40=40=\n"],
   ["\tt\t" => "\tt=05=\n"],
   ["test  \ntest\n\t \t \n" => "test=40=40\ntest\n=05=40=05=40\n"],

   # "=" is special an should be decoded
   ["=30\n" => "=7E30\n"],
   ["\0\xff0" => "=00=FF0=\n"],

   # Very long lines should be broken (not more than 76 chars
   ["The Quoted-Printable encoding is intended to represent data that largly consists of octets that correspond to printable characters in the ASCII character set." =>
    "The Quoted-Printable encoding is intended to represent data that largly con=
sists of octets that correspond to printable characters in the ASCII charac=
ter set.=\n"
    ],

   # Long lines after short lines were broken through 2.01.
   ["short line
In America, any boy may become president and I suppose that's just one of the risks he takes. -- Adlai Stevenson" =>
    "short line
In America, any boy may become president and I suppose that's just one of t=
he risks he takes. -- Adlai Stevenson=\n"],

   # My (roderick@@argon.org) first crack at fixing that bug failed for
   # multiple long lines.
   ["College football is a game which would be much more interesting if the faculty played instead of the students, and even more interesting if the
trustees played.  There would be a great increase in broken arms, legs, and necks, and simultaneously an appreciable diminution in the loss to humanity. -- H. L. Mencken" =>
    "College football is a game which would be much more interesting if the facu=
lty played instead of the students, and even more interesting if the
trustees played.  There would be a great increase in broken arms, legs, and=
 necks, and simultaneously an appreciable diminution in the loss to humanit=
y. -- H. L. Mencken=\n"],

   # Don't break a line that's near but not over 76 chars.
   ["$x70!23"		=> "$x70!23=\n"],
   ["$x70!234"		=> "$x70!234=\n"],
   ["$x70!2345"		=> "$x70!2345=\n"],
   ["$x70!23456"	=> "$x70!23456=\n"],
   ["$x70!234567"	=> "$x70!2345=\n67=\n"],
   ["$x70!23456="	=> "$x70!2345=\n6=7E=\n"],
   ["$x70!23\n"		=> "$x70!23\n"],
   ["$x70!234\n"	=> "$x70!234\n"],
   ["$x70!2345\n"	=> "$x70!2345\n"],
   ["$x70!23456\n"	=> "$x70!23456\n"],
   ["$x70!234567\n"	=> "$x70!2345=\n67\n"],
   ["$x70!23456=\n"	=> "$x70!2345=\n6=7E\n"],

   # Not allowed to break =XX escapes using soft line break
   ["$x70===xxxxx"  => "$x70=7E=\n=7E=7Exxxxx=\n"],
   ["$x70!===xxxx"  => "$x70!=7E=\n=7E=7Exxxx=\n"],
   ["$x70!2===xxx"  => "$x70!2=7E=\n=7E=7Exxx=\n"],
   ["$x70!23===xx"  => "$x70!23=\n=7E=7E=7Exx=\n"],
   ["$x70!234===x"  => "$x70!234=\n=7E=7E=7Ex=\n"],
   ["$x70!2=\n"     => "$x70!2=7E\n"],
   ["$x70!23=\n"    => "$x70!23=\n=7E\n"],
   ["$x70!234=\n"   => "$x70!234=\n=7E\n"],
   ["$x70!2345=\n"  => "$x70!2345=\n=7E\n"],
   ["$x70!23456=\n" => "$x70!2345=\n6=7E\n"],
   #                              ^
   #                      70123456|
   #                             max
   #                          line width

   # some extra special cases we have had problems with
   ["$x70!2=x=x" => "$x70!2=7E=\nx=7Ex=\n"],
   ["$x70!2345$x70!2345$x70!23456\n", "$x70!2345=\n$x70!2345=\n$x70!23456\n"],

   # trailing whitespace
   ["foo \t ", "foo=40=05=40=\n"],
   ["foo\t \n \t", "foo=05=40\n=40=05=\n"],
);

} else {
  die sprintf "Unknown character set: ord('A') == %d\n", ord('A');
}

a124 2
if ($IsASCII) {

a187 69

} elsif ($IsEBCDIC) {

# Some extra testing for a case that was wrong until libwww-perl-5.05
print "not " unless decode_qp("foo  \n\nfoo =\n\nfoo=40\n\n") eq
                                "foo\n\nfoo \nfoo \n\n";
$testno++; print "ok $testno\n";

# Same test but with "\r\n" terminated lines
print "not " unless decode_qp("foo  \r\n\r\nfoo =\r\n\r\nfoo=40\r\n\r\n") eq
                                "foo\n\nfoo \nfoo \n\n";
$testno++; print "ok $testno\n";

# Trailing whitespace
print "not " unless decode_qp("foo  ") eq "foo  ";
$testno++; print "ok $testno\n";

print "not " unless decode_qp("foo  \n") eq "foo\n";
$testno++; print "ok $testno\n";

print "not " unless decode_qp("foo = \t\x40\nbar\t\x40\n") eq "foo bar\n";
$testno++; print "ok $testno\n";

print "not " unless decode_qp("foo = \t\x40\r\nbar\t\x40\r\n") eq "foo bar\n";
$testno++; print "ok $testno\n";

print "not " unless decode_qp("foo = \t\x40\n") eq "foo ";
$testno++; print "ok $testno\n";

print "not " unless decode_qp("foo = \t\x40\r\n") eq "foo ";
$testno++; print "ok $testno\n";

print "not " unless decode_qp("foo = \t\x40y\r\n") eq "foo = \t\x40y\n";
$testno++; print "ok $testno\n";

print "not " unless decode_qp("foo =xy\n") eq "foo =xy\n";
$testno++; print "ok $testno\n";

# Test with with alternative line break
print "not " unless encode_qp("$x70!2345$x70\n", "***") eq "$x70!2345=***$x70***";
$testno++; print "ok $testno\n";

# Test with no line breaks
print "not " unless encode_qp("$x70!2345$x70\n", "") eq "$x70!2345$x70=15";
$testno++; print "ok $testno\n";

# Test binary encoding
print "not " unless encode_qp("foo", undef, 1) eq "foo=\n";
$testno++; print "ok $testno\n";

print "not " unless encode_qp("foo\nbar\r\n", undef, 1) eq "foo=15bar=0D=15=\n";
$testno++; print "ok $testno\n";

print "not " unless encode_qp(join("", map chr, 0..255), undef, 1) eq <<'EOT'; $testno++; print "ok $testno\n";
=00=01=02=03=04=05=06=07=08=09=0A=0B=0C=0D=0E=0F=10=11=12=13=14=15=16=17=18=
=19=1A=1B=1C=1D=1E=1F=20=21=22=23=24=25=26=27=28=29=2A=2B=2C=2D=2E=2F=30=31=
=32=33=34=35=36=37=38=39=3A=3B=3C=3D=3E=3F =41=42=43=44=45=46=47=48=49=4A.<=
(+|&=51=52=53=54=55=56=57=58=59!$*);^-/=62=63=64=65=66=67=68=69=6A,%_>?=70=
=71=72=73=74=75=76=77=78`:#@@'=7E"=80abcdefghi=8A=8B=8C=8D=8E=8F=90jklmnopqr=
=9A=9B=9C=9D=9E=9F=A0~stuvwxyz=AA=AB=AC=AD=AE=AF=B0=B1=B2=B3=B4=B5=B6=B7=B8=
=B9=BA=BB=BC=BD=BE=BF{ABCDEFGHI=CA=CB=CC=CD=CE=CF}JKLMNOPQR=DA=DB=DC=DD=DE=
=DF\=E1STUVWXYZ=EA=EB=EC=ED=EE=EF0123456789=FA=FB=FC=FD=FE=FF=
EOT

print "not " if $] >= 5.006 && (eval 'encode_qp("XXX \x{100}")' || !$@@);
$testno++; print "ok $testno\n";

}

@


