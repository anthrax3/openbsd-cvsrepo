head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.5.0.4
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.2
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.18
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.16
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.14
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.12
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.10
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.19;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.44;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.45.59;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.17;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.11.18;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package Encode::CN::HZ;

use strict;

use vars qw($VERSION);
$VERSION = do { my @@r = (q$Revision: 1.4 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };

use Encode ();

use base qw(Encode::Encoding);
__PACKAGE__->Define('hz');

# HZ is only escaped GB, so we implement it with the
# GB2312(raw) encoding here. Cf. RFCs 1842 & 1843.



sub needs_lines  { 1 }

sub perlio_ok { 
    return 0; # for the time being
}

sub decode
{
    my ($obj,$str,$chk) = @@_;
    my $gb = Encode::find_encoding('gb2312-raw');

    $str =~ s{~			# starting tilde
	(?:
	    (~)			# another tilde - escaped (set $1)
		|		#     or
	    \n			# \n - output nothing
		|		#     or
	    \{			# opening brace of GB data
		(		#  set $2 to any number of...
		    (?:	
			[^~]	#  non-tilde GB character
			    |   #     or
			~(?!\}) #  tilde not followed by a closing brace
		    )*
		)
	    ~\}			# closing brace of GB data
		|		# XXX: invalid escape - maybe die on $chk?
	)
    }{
	(defined $1)	? '~'			# two tildes make one tilde
	    :
	(defined $2)	? $gb->decode($2, $chk)	# decode the characters
	    :
	''					# ~\n and invalid escape = ''
    }egx;

    return $str;
}

sub encode
{
    my ($obj,$str,$chk) = @@_;
    my ($out, $in_gb);
    my $gb = Encode::find_encoding('gb2312-raw');

    $str =~ s/~/~~/g;

    # XXX: Since CHECK and partial decoding has not been implemented yet,
    #      we'll use a very crude way to test for GB2312ness.

    for my $index (0 .. length($str) - 1) {
	no warnings 'utf8';

	my $char = substr($str, $index, 1);
	# try to encode this character
	# with CHECK on so it stops at proper place.
	# also note that the assignement was braced in eval
	#  -- dankogai
	my $try;
	eval{ $try = $gb->encode($char, 1) };
	
	if (defined($try)) {		# is a GB character:
	    if ($in_gb) {
		$out .= $try;		#  in GB mode - just append it
	    }
	    else {
		$in_gb = 1;		#  enter GB mode, then append it
		$out .= "~{$try";
	    }
	}				# not a GB character:
	elsif ($in_gb) {
	    $in_gb = 0;			#  leave GB mode, then append it
	    $out .= "~}$char";
	}
	else {
	    $out .= $char;		#  not in GB mode - just append it
	}
    }

    $out .= '~}' if $in_gb;		# add closing brace if needed

    return $out;
}

1;
__END__


=head1 NAME

Encode::CN::HZ -- internally used by Encode::CN

=cut
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d6 1
a6 1
$VERSION = do { my @@r = (q$Revision: 1.5 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };
d8 1
a8 1
use Encode qw(:fallbacks);
d13 3
a15 2
# HZ is a combination of ASCII and escaped GB, so we implement it
# with the GB2312(raw) encoding here. Cf. RFCs 1842 & 1843.
a16 1
# not ported for EBCDIC.  Which should be used, "~" or "\x7E"?
d20 3
a22 1
sub perlio_ok    { 1 }
d24 1
a24 1
sub decode ($$;$)
a25 1
    use bytes;
d27 26
d54 1
a54 37
    my $GB = Encode::find_encoding('gb2312-raw');
    my $ret = '';
    my $in_ascii = 1; # default mode is ASCII.

    while (length $str) {
	if ($in_ascii) { # ASCII mode
	    if ($str =~ s/^([\x00-\x7D\x7F]+)//) { # no '~' => ASCII
		$ret .= $1;
		# EBCDIC should need ascii2native, but not ported.
	    }
	    elsif ($str =~ s/^\x7E\x7E//) { # escaped tilde
		$ret .= '~';
	    }
	    elsif ($str =~ s/^\x7E\cJ//) { # '\cJ' == LF in ASCII
		1; # no-op
	    }
	    elsif ($str =~ s/^\x7E\x7B//) { # '~{'
		$in_ascii = 0; # to GB
	    }
	    else { # encounters an invalid escape, \x80 or greater
		last;
	    }
	}
	else { # GB mode; the byte ranges are as in RFC 1843.
	    if ($str =~ s/^((?:[\x21-\x77][\x21-\x7E])+)//) {
		$ret .= $GB->decode($1, $chk);
	    }
	    elsif ($str =~ s/^\x7E\x7D//) { # '~}'
		$in_ascii = 1;
	    }
	    else { # invalid
		last;
	    }
	}
    }
    $_[1] = $str if $chk;
    return $ret;
d57 5
a61 9
sub cat_decode {
    use bytes;

    my ($obj, undef, $src, $pos, $trm, $chk) = @@_;
    my ($rdst, $rsrc, $rpos) = \@@_[1..3];

    my $GB = Encode::find_encoding('gb2312-raw');
    my $ret = '';
    my $in_ascii = 1; # default mode is ASCII.
d63 1
a63 1
    my $ini_pos = pos($$rsrc);
d65 2
a66 1
    substr($src, 0, $pos) = '';
d68 23
a90 37
    my $ini_len = bytes::length($src);

    # $trm is the first of the pair '~~', then 2nd tilde is to be removed.
    # XXX: Is better C<$src =~ s/^\x7E// or die if ...>?
    $src =~ s/^\x7E// if $trm eq "\x7E";

    while (length $src) {
	my $now;
	if ($in_ascii) { # ASCII mode
	    if ($src =~ s/^([\x00-\x7D\x7F])//) { # no '~' => ASCII
		$now = $1;
	    }
	    elsif ($src =~ s/^\x7E\x7E//) { # escaped tilde
		$now = '~';
	    }
	    elsif ($src =~ s/^\x7E\cJ//) { # '\cJ' == LF in ASCII
		next;
	    }
	    elsif ($src =~ s/^\x7E\x7B//) { # '~{'
		$in_ascii = 0; # to GB
		next;
	    }
	    else { # encounters an invalid escape, \x80 or greater
		last;
	    }
	}
	else { # GB mode; the byte ranges are as in RFC 1843.
	    if ($src =~ s/^((?:[\x21-\x77][\x21-\x7F])+)//) {
		$now = $GB->decode($1, $chk);
	    }
	    elsif ($src =~ s/^\x7E\x7D//) { # '~}'
		$in_ascii = 1;
		next;
	    }
	    else { # invalid
		last;
	    }
d92 2
a93 10

	next if ! defined $now;

	$ret .= $now;

	if ($now eq $trm) {
	    $$rdst .= $ret;
	    $$rpos = $ini_pos + $pos + $ini_len - bytes::length($src);
	    pos($$rsrc) = $ini_pos;
	    return 1;
d97 1
a97 6
    $$rdst .= $ret;
    $$rpos = $ini_pos + $pos + $ini_len - bytes::length($src);
    pos($$rsrc) = $ini_pos;
    return ''; # terminator not found
}

d99 1
a99 53
sub encode($$;$)
{
    my ($obj,$str,$chk) = @@_;

    my $GB = Encode::find_encoding('gb2312-raw');
    my $ret = '';
    my $in_ascii = 1; # default mode is ASCII.

    no warnings 'utf8'; # $str may be malformed UTF8 at the end of a chunk.

    while (length $str) {
	if ($str =~ s/^([[:ascii:]]+)//) {
	    my $tmp = $1;
	    $tmp =~ s/~/~~/g; # escapes tildes
	    if (! $in_ascii) {
		$ret .= "\x7E\x7D"; # '~}'
		$in_ascii = 1;
	    }
	    $ret .= pack 'a*', $tmp; # remove UTF8 flag.
	}
	elsif ($str =~ s/(.)//) {
	    my $tmp = $GB->encode($1, $chk);
	    last if !defined $tmp;
	    if (length $tmp == 2) { # maybe a valid GB char (XXX)
		if ($in_ascii) {
		    $ret .= "\x7E\x7B"; # '~{'
		    $in_ascii = 0;
		}
		$ret .= $tmp;
	    }
	    elsif (length $tmp) { # maybe FALLBACK in ASCII (XXX)
		if (!$in_ascii) {
		    $ret .= "\x7E\x7D"; # '~}'
		    $in_ascii = 1;
		}
		$ret .= $tmp;
	    }
	}
	else { # if $str is malformed UTF8 *and* if length $str != 0.
	    last;
	}
    }
    $_[1] = $str if $chk;

  # The state at the end of the chunk is discarded, even if in GB mode.
  # That results in the combination of GB-OUT and GB-IN, i.e. "~}~{".
  # Parhaps it is harmless, but further investigations may be required...

    if (! $in_ascii) {
	$ret .= "\x7E\x7D"; # '~}'
	$in_ascii = 1;
    }
    return $ret;
d104 1
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@d6 1
a6 1
$VERSION = do { my @@r = (q$Revision: 2.1 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };
d20 2
d24 1
d62 1
a62 1
    $_[1] = '' if $chk; # needs_lines guarantees no partial character
d67 2
d159 1
a159 2
	    my $s = $1;
	    my $tmp = $GB->encode($s, $chk);
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@a3 1
use warnings;
d6 1
a6 1
$VERSION = do { my @@r = ( q$Revision: 2.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @@r };
d18 1
a18 1
sub needs_lines { 1 }
d20 3
a22 2
sub decode ($$;$) {
    my ( $obj, $str, $chk ) = @@_;
d24 1
a24 1
    my $GB  = Encode::find_encoding('gb2312-raw');
d26 1
a26 1
    my $in_ascii = 1;    # default mode is ASCII.
d28 30
a57 32
    while ( length $str ) {
        if ($in_ascii) {    # ASCII mode
            if ( $str =~ s/^([\x00-\x7D\x7F]+)// ) {    # no '~' => ASCII
                $ret .= $1;

                # EBCDIC should need ascii2native, but not ported.
            }
            elsif ( $str =~ s/^\x7E\x7E// ) {           # escaped tilde
                $ret .= '~';
            }
            elsif ( $str =~ s/^\x7E\cJ// ) {    # '\cJ' == LF in ASCII
                1;                              # no-op
            }
            elsif ( $str =~ s/^\x7E\x7B// ) {    # '~{'
                $in_ascii = 0;                   # to GB
            }
            else {    # encounters an invalid escape, \x80 or greater
                last;
            }
        }
        else {        # GB mode; the byte ranges are as in RFC 1843.
            no warnings 'uninitialized';
            if ( $str =~ s/^((?:[\x21-\x77][\x21-\x7E])+)// ) {
                $ret .= $GB->decode( $1, $chk );
            }
            elsif ( $str =~ s/^\x7E\x7D// ) {    # '~}'
                $in_ascii = 1;
            }
            else {                               # invalid
                last;
            }
        }
d59 1
a59 1
    $_[1] = '' if $chk;    # needs_lines guarantees no partial character
d64 2
a65 2
    my ( $obj, undef, $src, $pos, $trm, $chk ) = @@_;
    my ( $rdst, $rsrc, $rpos ) = \@@_[ 1 .. 3 ];
d67 1
a67 1
    my $GB  = Encode::find_encoding('gb2312-raw');
d69 1
a69 1
    my $in_ascii = 1;      # default mode is ASCII.
d73 1
a73 1
    substr( $src, 0, $pos ) = '';
d81 43
a123 43
    while ( length $src ) {
        my $now;
        if ($in_ascii) {    # ASCII mode
            if ( $src =~ s/^([\x00-\x7D\x7F])// ) {    # no '~' => ASCII
                $now = $1;
            }
            elsif ( $src =~ s/^\x7E\x7E// ) {          # escaped tilde
                $now = '~';
            }
            elsif ( $src =~ s/^\x7E\cJ// ) {    # '\cJ' == LF in ASCII
                next;
            }
            elsif ( $src =~ s/^\x7E\x7B// ) {    # '~{'
                $in_ascii = 0;                   # to GB
                next;
            }
            else {    # encounters an invalid escape, \x80 or greater
                last;
            }
        }
        else {        # GB mode; the byte ranges are as in RFC 1843.
            if ( $src =~ s/^((?:[\x21-\x77][\x21-\x7F])+)// ) {
                $now = $GB->decode( $1, $chk );
            }
            elsif ( $src =~ s/^\x7E\x7D// ) {    # '~}'
                $in_ascii = 1;
                next;
            }
            else {                               # invalid
                last;
            }
        }

        next if !defined $now;

        $ret .= $now;

        if ( $now eq $trm ) {
            $$rdst .= $ret;
            $$rpos = $ini_pos + $pos + $ini_len - bytes::length($src);
            pos($$rsrc) = $ini_pos;
            return 1;
        }
d129 1
a129 1
    return '';    # terminator not found
a131 2
sub encode($$;$) {
    my ( $obj, $str, $chk ) = @@_;
d133 5
a137 1
    my $GB  = Encode::find_encoding('gb2312-raw');
d139 1
a139 1
    my $in_ascii = 1;    # default mode is ASCII.
d141 1
a141 1
    no warnings 'utf8';  # $str may be malformed UTF8 at the end of a chunk.
d143 32
a174 32
    while ( length $str ) {
        if ( $str =~ s/^([[:ascii:]]+)// ) {
            my $tmp = $1;
            $tmp =~ s/~/~~/g;    # escapes tildes
            if ( !$in_ascii ) {
                $ret .= "\x7E\x7D";    # '~}'
                $in_ascii = 1;
            }
            $ret .= pack 'a*', $tmp;    # remove UTF8 flag.
        }
        elsif ( $str =~ s/(.)// ) {
            my $s = $1;
            my $tmp = $GB->encode( $s, $chk );
            last if !defined $tmp;
            if ( length $tmp == 2 ) {    # maybe a valid GB char (XXX)
                if ($in_ascii) {
                    $ret .= "\x7E\x7B";    # '~{'
                    $in_ascii = 0;
                }
                $ret .= $tmp;
            }
            elsif ( length $tmp ) {        # maybe FALLBACK in ASCII (XXX)
                if ( !$in_ascii ) {
                    $ret .= "\x7E\x7D";    # '~}'
                    $in_ascii = 1;
                }
                $ret .= $tmp;
            }
        }
        else {    # if $str is malformed UTF8 *and* if length $str != 0.
            last;
        }
d178 7
a184 7
    # The state at the end of the chunk is discarded, even if in GB mode.
    # That results in the combination of GB-OUT and GB-IN, i.e. "~}~{".
    # Parhaps it is harmless, but further investigations may be required...

    if ( !$in_ascii ) {
        $ret .= "\x7E\x7D";    # '~}'
        $in_ascii = 1;
@


1.1.1.5
log
@import perl 5.10.1
@
text
@a4 1
use utf8 ();
d7 1
a7 1
$VERSION = do { my @@r = ( q$Revision: 2.5 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @@r };
a185 1
    utf8::encode($ret); # https://rt.cpan.org/Ticket/Display.html?id=35120
@


