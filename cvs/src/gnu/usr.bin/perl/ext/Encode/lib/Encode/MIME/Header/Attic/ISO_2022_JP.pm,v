head	1.4;
access;
symbols
	OPENBSD_4_8:1.3.0.8
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	PERL_5_10_0:1.1.1.2
	OPENBSD_4_4:1.2.0.10
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.8
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.6
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.4
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2
	PERL_5_8_8:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2010.09.24.14.59.19;	author millert;	state dead;
branches;
next	1.3;

1.3
date	2008.09.29.17.36.04;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.28.19.23.03;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.28.18.48.03;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.03.28.18.48.03;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.09.29.17.18.17;	author millert;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package Encode::MIME::Header::ISO_2022_JP;

use strict;
use warnings;

use base qw(Encode::MIME::Header);

$Encode::Encoding{'MIME-Header-ISO_2022_JP'} =
  bless { encode => 'B', bpl => 76, Name => 'MIME-Header-ISO_2022_JP' } =>
  __PACKAGE__;

use constant HEAD => '=?ISO-2022-JP?B?';
use constant TAIL => '?=';

use Encode::CJKConstants qw(%RE);

our $VERSION = do { my @@r = ( q$Revision: 1.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @@r };

# I owe the below codes totally to
#   Jcode by Dan Kogai & http://www.din.or.jp/~ohzaki/perl.htm#JP_Base64

sub encode {
    my $self = shift;
    my $str  = shift;

    utf8::encode($str) if ( Encode::is_utf8($str) );
    Encode::from_to( $str, 'utf8', 'euc-jp' );

    my ($trailing_crlf) = ( $str =~ /(\n|\r|\x0d\x0a)$/o );

    $str = _mime_unstructured_header( $str, $self->{bpl} );

    not $trailing_crlf and $str =~ s/(\n|\r|\x0d\x0a)$//o;

    return $str;
}

sub _mime_unstructured_header {
    my ( $oldheader, $bpl ) = @@_;
    my $crlf = $oldheader =~ /\n$/;
    my ( $header, @@words, @@wordstmp, $i ) = ('');

    $oldheader =~ s/\s+$//;

    @@wordstmp = split /\s+/, $oldheader;

    for ( $i = 0 ; $i < $#wordstmp ; $i++ ) {
        if (    $wordstmp[$i] !~ /^[\x21-\x7E]+$/
            and $wordstmp[ $i + 1 ] !~ /^[\x21-\x7E]+$/ )
        {
            $wordstmp[ $i + 1 ] = "$wordstmp[$i] $wordstmp[$i + 1]";
        }
        else {
            push( @@words, $wordstmp[$i] );
        }
    }

    push( @@words, $wordstmp[-1] );

    for my $word (@@words) {
        if ( $word =~ /^[\x21-\x7E]+$/ ) {
            $header =~ /(?:.*\n)*(.*)/;
            if ( length($1) + length($word) > $bpl ) {
                $header .= "\n $word";
            }
            else {
                $header .= $word;
            }
        }
        else {
            $header = _add_encoded_word( $word, $header, $bpl );
        }

        $header =~ /(?:.*\n)*(.*)/;

        if ( length($1) == $bpl ) {
            $header .= "\n ";
        }
        else {
            $header .= ' ';
        }
    }

    $header =~ s/\n? $//mg;

    $crlf ? "$header\n" : $header;
}

sub _add_encoded_word {
    my ( $str, $line, $bpl ) = @@_;
    my $result = '';

    while ( length($str) ) {
        my $target = $str;
        $str = '';

        if (
            length($line) + 22 +
            ( $target =~ /^(?:$RE{EUC_0212}|$RE{EUC_C})/o ) * 8 > $bpl )
        {
            $line =~ s/[ \t\n\r]*$/\n/;
            $result .= $line;
            $line = ' ';
        }

        while (1) {
            my $iso_2022_jp = $target;
            Encode::from_to( $iso_2022_jp, 'euc-jp', 'iso-2022-jp' );

            my $encoded =
              HEAD . MIME::Base64::encode_base64( $iso_2022_jp, '' ) . TAIL;

            if ( length($encoded) + length($line) > $bpl ) {
                $target =~
                  s/($RE{EUC_0212}|$RE{EUC_KANA}|$RE{EUC_C}|$RE{ASCII})$//o;
                $str = $1 . $str;
            }
            else {
                $line .= $encoded;
                last;
            }
        }

    }

    $result . $line;
}

1;
__END__

@


1.3
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@@


1.2
log
@merge in perl 5.8.8
@
text
@d4 2
d8 3
a10 3
$Encode::Encoding{'MIME-Header-ISO_2022_JP'}
  = bless {encode => 'B', bpl => 76, Name => 'MIME-Header-ISO_2022_JP'}
   => __PACKAGE__;
d12 2
a13 2
use constant HEAD   => '=?ISO-2022-JP?B?';
use constant TAIL   => '?=';
d17 1
a17 2
our $VERSION = do { my @@r = (q$Revision: 1.1 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };

d23 2
a24 2
	my $self = shift;
	my $str  = shift;
d26 2
a27 2
	utf8::encode($str) if( Encode::is_utf8($str) );
	Encode::from_to($str, 'utf8', 'euc-jp');
d29 1
a29 1
	my($trailing_crlf) = ($str =~ /(\n|\r|\x0d\x0a)$/o);
d31 1
a31 1
	$str = _mime_unstructured_header($str, $self->{bpl});
d33 1
a33 1
	not $trailing_crlf and $str =~ s/(\n|\r|\x0d\x0a)$//o;
d35 1
a35 1
	return $str;
a37 1

d39 44
a82 42
    my ($oldheader, $bpl) = @@_;
	my $crlf = $oldheader =~ /\n$/;
	my($header, @@words, @@wordstmp, $i) = ('');

	$oldheader =~ s/\s+$//;

	@@wordstmp = split /\s+/, $oldheader;

	for ($i = 0; $i < $#wordstmp; $i++){
		if( $wordstmp[$i] !~ /^[\x21-\x7E]+$/ and $wordstmp[$i + 1] !~ /^[\x21-\x7E]+$/){
			$wordstmp[$i + 1] = "$wordstmp[$i] $wordstmp[$i + 1]";
		}
		else{
			push(@@words, $wordstmp[$i]);
		}
	}

	push(@@words, $wordstmp[-1]);

	for my $word (@@words){
		if ($word =~ /^[\x21-\x7E]+$/) {
			$header =~ /(?:.*\n)*(.*)/;
			if (length($1) + length($word) > $bpl) {
				$header .= "\n $word";
			}
			else{
				$header .= $word;
			}
		}
		else{
			$header = _add_encoded_word($word, $header, $bpl);
		}

		$header =~ /(?:.*\n)*(.*)/;

		if(length($1) == $bpl){
			$header .= "\n ";
		}
		else {
			$header .= ' ';
		}
	}
d84 1
a84 1
	$header =~ s/\n? $//mg;
d86 1
a86 1
	$crlf ? "$header\n" : $header;
a88 1

d90 2
a91 2
	my($str, $line, $bpl) = @@_;
	my $result = '';
d93 30
a122 26
	while( length($str) ){
		my $target = $str;
		$str = '';

		if(length($line) + 22 + ($target =~ /^(?:$RE{EUC_0212}|$RE{EUC_C})/o) * 8 > $bpl){
			$line =~ s/[ \t\n\r]*$/\n/;
			$result .= $line;
			$line = ' ';
		}

		while(1){
			my $iso_2022_jp = $target;
			Encode::from_to($iso_2022_jp, 'euc-jp', 'iso-2022-jp');

			my $encoded
			 = HEAD . MIME::Base64::encode_base64($iso_2022_jp, '') . TAIL;

			if(length($encoded) + length($line) > $bpl){
				$target =~ s/($RE{EUC_0212}|$RE{EUC_KANA}|$RE{EUC_C}|$RE{ASCII})$//o;
				$str = $1 . $str;
			}
			else{
				$line .= $encoded;
				last;
			}
		}
d124 1
a124 1
	}
d126 1
a126 1
	$result . $line;
a127 1

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@perl 5.8.8 import
@
text
@@


1.1.1.2
log
@import perl 5.10.0 from CPAN
@
text
@a3 2
use warnings;

d6 3
a8 3
$Encode::Encoding{'MIME-Header-ISO_2022_JP'} =
  bless { encode => 'B', bpl => 76, Name => 'MIME-Header-ISO_2022_JP' } =>
  __PACKAGE__;
d10 2
a11 2
use constant HEAD => '=?ISO-2022-JP?B?';
use constant TAIL => '?=';
d15 2
a16 1
our $VERSION = do { my @@r = ( q$Revision: 1.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @@r };
d22 2
a23 2
    my $self = shift;
    my $str  = shift;
d25 2
a26 2
    utf8::encode($str) if ( Encode::is_utf8($str) );
    Encode::from_to( $str, 'utf8', 'euc-jp' );
d28 1
a28 1
    my ($trailing_crlf) = ( $str =~ /(\n|\r|\x0d\x0a)$/o );
d30 1
a30 1
    $str = _mime_unstructured_header( $str, $self->{bpl} );
d32 1
a32 1
    not $trailing_crlf and $str =~ s/(\n|\r|\x0d\x0a)$//o;
d34 1
a34 1
    return $str;
d37 1
d39 42
a80 44
    my ( $oldheader, $bpl ) = @@_;
    my $crlf = $oldheader =~ /\n$/;
    my ( $header, @@words, @@wordstmp, $i ) = ('');

    $oldheader =~ s/\s+$//;

    @@wordstmp = split /\s+/, $oldheader;

    for ( $i = 0 ; $i < $#wordstmp ; $i++ ) {
        if (    $wordstmp[$i] !~ /^[\x21-\x7E]+$/
            and $wordstmp[ $i + 1 ] !~ /^[\x21-\x7E]+$/ )
        {
            $wordstmp[ $i + 1 ] = "$wordstmp[$i] $wordstmp[$i + 1]";
        }
        else {
            push( @@words, $wordstmp[$i] );
        }
    }

    push( @@words, $wordstmp[-1] );

    for my $word (@@words) {
        if ( $word =~ /^[\x21-\x7E]+$/ ) {
            $header =~ /(?:.*\n)*(.*)/;
            if ( length($1) + length($word) > $bpl ) {
                $header .= "\n $word";
            }
            else {
                $header .= $word;
            }
        }
        else {
            $header = _add_encoded_word( $word, $header, $bpl );
        }

        $header =~ /(?:.*\n)*(.*)/;

        if ( length($1) == $bpl ) {
            $header .= "\n ";
        }
        else {
            $header .= ' ';
        }
    }
d82 1
a82 1
    $header =~ s/\n? $//mg;
d84 1
a84 1
    $crlf ? "$header\n" : $header;
d87 1
d89 2
a90 2
    my ( $str, $line, $bpl ) = @@_;
    my $result = '';
d92 26
a117 30
    while ( length($str) ) {
        my $target = $str;
        $str = '';

        if (
            length($line) + 22 +
            ( $target =~ /^(?:$RE{EUC_0212}|$RE{EUC_C})/o ) * 8 > $bpl )
        {
            $line =~ s/[ \t\n\r]*$/\n/;
            $result .= $line;
            $line = ' ';
        }

        while (1) {
            my $iso_2022_jp = $target;
            Encode::from_to( $iso_2022_jp, 'euc-jp', 'iso-2022-jp' );

            my $encoded =
              HEAD . MIME::Base64::encode_base64( $iso_2022_jp, '' ) . TAIL;

            if ( length($encoded) + length($line) > $bpl ) {
                $target =~
                  s/($RE{EUC_0212}|$RE{EUC_KANA}|$RE{EUC_C}|$RE{ASCII})$//o;
                $str = $1 . $str;
            }
            else {
                $line .= $encoded;
                last;
            }
        }
d119 1
a119 1
    }
d121 1
a121 1
    $result . $line;
d123 1
@

