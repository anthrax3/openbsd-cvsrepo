head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.5.0.4
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.2
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.18
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.16
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.14
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.12
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.10
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.19;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.44;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.45.59;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.17;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.11.18;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package Encode::JP::JIS7;
use strict;

our $VERSION = do { my @@r = (q$Revision: 1.8 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };

use Encode qw(:fallbacks);

for my $name ('7bit-jis', 'iso-2022-jp', 'iso-2022-jp-1'){
    my $h2z     = ($name eq '7bit-jis')    ? 0 : 1;
    my $jis0212 = ($name eq 'iso-2022-jp') ? 0 : 1;

    $Encode::Encoding{$name} =
        bless {
               Name      =>   $name,
               h2z       =>   $h2z,
               jis0212   =>   $jis0212,
              } => __PACKAGE__;
}

use base qw(Encode::Encoding);

# we override this to 1 so PerlIO works
sub needs_lines { 1 }

use Encode::CJKConstants qw(:all);

our $DEBUG = 0;

#
# decode is identical for all 2022 variants
#

sub decode($$;$)
{
    my ($obj, $str, $chk) = @@_;
    my $residue = '';
    if ($chk){
	$str =~ s/([^\x00-\x7f].*)$//so;
	$1 and $residue = $1;
    }
    $residue .= jis_euc(\$str);
    $_[1] = $residue if $chk;
    return Encode::decode('euc-jp', $str, FB_PERLQQ);
}

#
# encode is different
#

sub encode($$;$)
{
    require Encode::JP::H2Z;
    my ($obj, $utf8, $chk) = @@_;
    # empty the input string in the stack so perlio is ok
    $_[1] = '' if $chk;
    my ($h2z, $jis0212) = @@$obj{qw(h2z jis0212)};
    my $octet = Encode::encode('euc-jp', $utf8, FB_PERLQQ) ;
    $h2z and &Encode::JP::H2Z::h2z(\$octet);
    euc_jis(\$octet, $jis0212);
    return $octet;
}


# JIS<->EUC

sub jis_euc {
    my $r_str = shift;
    $$r_str =~ s(
		 ($RE{JIS_0212}|$RE{JIS_0208}|$RE{ISO_ASC}|$RE{JIS_KANA})
		 ([^\e]*)
		 )
    {
	my ($esc, $chunk) = ($1, $2);
	if ($esc !~ /$RE{ISO_ASC}/o) {
	    $chunk =~ tr/\x21-\x7e/\xa1-\xfe/;
	    if ($esc =~ /$RE{JIS_KANA}/o) {
		$chunk =~ s/([\xa1-\xdf])/\x8e$1/og;
	    }
	    elsif ($esc =~ /$RE{JIS_0212}/o) {
		$chunk =~ s/([\xa1-\xfe][\xa1-\xfe])/\x8f$1/og;
	    }
	}
	$chunk;
    }geox;
    my ($residue) = ($$r_str =~ s/(\e.*)$//so);
    return $residue;
}

sub euc_jis{
    no warnings qw(uninitialized);
    my $r_str = shift;
    my $jis0212 = shift;
    $$r_str =~ s{
	((?:$RE{EUC_C})+|(?:$RE{EUC_KANA})+|(?:$RE{EUC_0212})+)
	}{
	    my $chunk = $1;
	    my $esc =
		( $chunk =~ tr/\x8E//d ) ? $ESC{KANA} :
		    ( $chunk =~ tr/\x8F//d ) ? $ESC{JIS_0212} :
			$ESC{JIS_0208};
	    if ($esc eq $ESC{JIS_0212} && !$jis0212){
		# fallback to '?'
		$chunk =~ tr/\xA1-\xFE/\x3F/;
	    }else{
		$chunk =~ tr/\xA1-\xFE/\x21-\x7E/;
	    }
	    $esc . $chunk . $ESC{ASC};
	}geox;
    $$r_str =~
	s/\Q$ESC{ASC}\E
	    (\Q$ESC{KANA}\E|\Q$ESC{JIS_0212}\E|\Q$ESC{JIS_0208}\E)/$1/gox;
    $$r_str;
}

1;
__END__


=head1 NAME

Encode::JP::JIS7 -- internally used by Encode::JP

=cut
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d4 1
a4 1
our $VERSION = do { my @@r = (q$Revision: 1.12 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };
d27 2
d38 2
a39 1
	$str =~ s/([^\x00-\x7f].*)$//so and $residue = $1;
a62 43
#
# cat_decode
#
my $re_scan_jis_g = qr{
   \G ( ($RE{JIS_0212}) |  $RE{JIS_0208}  |
        ($RE{ISO_ASC})  | ($RE{JIS_KANA}) | )
      ([^\e]*)
}x;
sub cat_decode { # ($obj, $dst, $src, $pos, $trm, $chk)
    my ($obj, undef, undef, $pos, $trm) = @@_; # currently ignores $chk
    my ($rdst, $rsrc, $rpos) = \@@_[1,2,3];
    local ${^ENCODING};
    use bytes;
    my $opos = pos($$rsrc);
    pos($$rsrc) = $pos;
    while ($$rsrc =~ /$re_scan_jis_g/gc) {
	my ($esc, $esc_0212, $esc_asc, $esc_kana, $chunk) =
	  ($1, $2, $3, $4, $5);

	unless ($chunk) { $esc or last;  next; }

	if ($esc && !$esc_asc) {
	    $chunk =~ tr/\x21-\x7e/\xa1-\xfe/;
	    if ($esc_kana) {
		$chunk =~ s/([\xa1-\xdf])/\x8e$1/og;
	    } elsif ($esc_0212) {
		$chunk =~ s/([\xa1-\xfe][\xa1-\xfe])/\x8f$1/og;
	    }
	    $chunk = Encode::decode('euc-jp', $chunk, 0);
	}
	elsif ((my $npos = index($chunk, $trm)) >= 0) {
	    $$rdst .= substr($chunk, 0, $npos + length($trm));
	    $$rpos += length($esc) + $npos + length($trm);
	    pos($$rsrc) = $opos;
	    return 1;
	}
	$$rdst .= $chunk;
	$$rpos = pos($$rsrc);
    }
    $$rpos = pos($$rsrc);
    pos($$rsrc) = $opos;
    return '';
}
a64 3
my $re_scan_jis = qr{
   (?:($RE{JIS_0212})|$RE{JIS_0208}|($RE{ISO_ASC})|($RE{JIS_KANA}))([^\e]*)
}x;
a66 1
    local ${^ENCODING};
d68 4
a71 1
    $$r_str =~ s($re_scan_jis)
d73 2
a74 3
	my ($esc_0212, $esc_asc, $esc_kana, $chunk) =
	   ($1, $2, $3, $4);
	if (!$esc_asc) {
d76 1
a76 1
	    if ($esc_kana) {
d79 1
a79 1
	    elsif ($esc_0212) {
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
our $VERSION = do { my @@r = (q$Revision: 2.0 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d3 2
a4 2
use warnings;
our $VERSION = do { my @@r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @@r };
d8 10
a17 9
for my $name ( '7bit-jis', 'iso-2022-jp', 'iso-2022-jp-1' ) {
    my $h2z     = ( $name eq '7bit-jis' )    ? 0 : 1;
    my $jis0212 = ( $name eq 'iso-2022-jp' ) ? 0 : 1;

    $Encode::Encoding{$name} = bless {
        Name    => $name,
        h2z     => $h2z,
        jis0212 => $jis0212,
    } => __PACKAGE__;
d31 3
a33 2
sub decode($$;$) {
    my ( $obj, $str, $chk ) = @@_;
d35 2
a36 2
    if ($chk) {
        $str =~ s/([^\x00-\x7f].*)$//so and $residue = $1;
d38 1
a38 1
    $residue .= jis_euc( \$str );
d40 1
a40 1
    return Encode::decode( 'euc-jp', $str, FB_PERLQQ );
d47 2
a48 1
sub encode($$;$) {
d50 1
a50 2
    my ( $obj, $utf8, $chk ) = @@_;

d53 4
a56 4
    my ( $h2z, $jis0212 ) = @@$obj{qw(h2z jis0212)};
    my $octet = Encode::encode( 'euc-jp', $utf8, $chk );
    $h2z and &Encode::JP::H2Z::h2z( \$octet );
    euc_jis( \$octet, $jis0212 );
d68 3
a70 4

sub cat_decode {    # ($obj, $dst, $src, $pos, $trm, $chk)
    my ( $obj, undef, undef, $pos, $trm ) = @@_;    # currently ignores $chk
    my ( $rdst, $rsrc, $rpos ) = \@@_[ 1, 2, 3 ];
d75 23
a97 24
    while ( $$rsrc =~ /$re_scan_jis_g/gc ) {
        my ( $esc, $esc_0212, $esc_asc, $esc_kana, $chunk ) =
          ( $1, $2, $3, $4, $5 );

        unless ($chunk) { $esc or last; next; }

        if ( $esc && !$esc_asc ) {
            $chunk =~ tr/\x21-\x7e/\xa1-\xfe/;
            if ($esc_kana) {
                $chunk =~ s/([\xa1-\xdf])/\x8e$1/og;
            }
            elsif ($esc_0212) {
                $chunk =~ s/([\xa1-\xfe][\xa1-\xfe])/\x8f$1/og;
            }
            $chunk = Encode::decode( 'euc-jp', $chunk, 0 );
        }
        elsif ( ( my $npos = index( $chunk, $trm ) ) >= 0 ) {
            $$rdst .= substr( $chunk, 0, $npos + length($trm) );
            $$rpos += length($esc) + $npos + length($trm);
            pos($$rsrc) = $opos;
            return 1;
        }
        $$rdst .= $chunk;
        $$rpos = pos($$rsrc);
d114 12
a125 12
    my ($esc_0212, $esc_asc, $esc_kana, $chunk) =
       ($1, $2, $3, $4);
    if (!$esc_asc) {
        $chunk =~ tr/\x21-\x7e/\xa1-\xfe/;
        if ($esc_kana) {
        $chunk =~ s/([\xa1-\xdf])/\x8e$1/og;
        }
        elsif ($esc_0212) {
        $chunk =~ s/([\xa1-\xfe][\xa1-\xfe])/\x8f$1/og;
        }
    }
    $chunk;
d127 1
a127 1
    my ($residue) = ( $$r_str =~ s/(\e.*)$//so );
d131 1
a131 1
sub euc_jis {
d133 1
a133 1
    my $r_str   = shift;
d136 18
a153 17
    ((?:$RE{EUC_C})+|(?:$RE{EUC_KANA})+|(?:$RE{EUC_0212})+)
    }{
        my $chunk = $1;
        my $esc =
        ( $chunk =~ tr/\x8E//d ) ? $ESC{KANA} :
            ( $chunk =~ tr/\x8F//d ) ? $ESC{JIS_0212} :
            $ESC{JIS_0208};
        if ($esc eq $ESC{JIS_0212} && !$jis0212){
        # fallback to '?'
        $chunk =~ tr/\xA1-\xFE/\x3F/;
        }else{
        $chunk =~ tr/\xA1-\xFE/\x21-\x7E/;
        }
        $esc . $chunk . $ESC{ASC};
    }geox;
    $$r_str =~ s/\Q$ESC{ASC}\E
        (\Q$ESC{KANA}\E|\Q$ESC{JIS_0212}\E|\Q$ESC{JIS_0208}\E)/$1/gox;
@


1.1.1.5
log
@import perl 5.10.1
@
text
@d4 1
a4 1
our $VERSION = do { my @@r = ( q$Revision: 2.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @@r };
a132 1
    local ${^ENCODING};
@


