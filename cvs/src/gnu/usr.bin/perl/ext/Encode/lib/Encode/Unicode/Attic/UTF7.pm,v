head	1.6;
access;
symbols
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.4.0.6
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.3.0.18
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.16
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	PERL_5_8_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2010.09.24.14.59.19;	author millert;	state dead;
branches;
next	1.5;

1.5
date	2009.10.12.18.24.28;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2008.09.29.17.36.04;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.09.18.09.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.03.03.02.29;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.03.02.43.44;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.03.02.43.44;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.08.09.17.45.59;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.01.15.21.16.47;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.17;	author millert;	state Exp;
branches;
next	;


desc
@@


1.6
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#
# $Id: UTF7.pm,v 1.5 2009/10/12 18:24:28 millert Exp $
#
package Encode::Unicode::UTF7;
use strict;
use warnings;
no warnings 'redefine';
use base qw(Encode::Encoding);
__PACKAGE__->Define('UTF-7');
our $VERSION = do { my @@r = ( q$Revision: 1.5 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @@r };
use MIME::Base64;
use Encode;

#
# Algorithms taken from Unicode::String by Gisle Aas
#

our $OPTIONAL_DIRECT_CHARS = 1;
my $specials = quotemeta "\'(),-./:?";
$OPTIONAL_DIRECT_CHARS
  and $specials .= quotemeta "!\"#$%&*;<=>@@[]^_`{|}";

# \s will not work because it matches U+3000 DEOGRAPHIC SPACE
# We use qr/[\n\r\t\ ] instead
my $re_asis    = qr/(?:[\n\r\t\ A-Za-z0-9$specials])/;
my $re_encoded = qr/(?:[^\n\r\t\ A-Za-z0-9$specials])/;
my $e_utf16    = find_encoding("UTF-16BE");

sub needs_lines { 1 }

sub encode($$;$) {
    my ( $obj, $str, $chk ) = @@_;
    my $len = length($str);
    pos($str) = 0;
    my $bytes = '';
    while ( pos($str) < $len ) {
        if ( $str =~ /\G($re_asis+)/ogc ) {
            $bytes .= $1;
        }
        elsif ( $str =~ /\G($re_encoded+)/ogsc ) {
            if ( $1 eq "+" ) {
                $bytes .= "+-";
            }
            else {
                my $s = $1;
                my $base64 = encode_base64( $e_utf16->encode($s), '' );
                $base64 =~ s/=+$//;
                $bytes .= "+$base64-";
            }
        }
        else {
            die "This should not happen! (pos=" . pos($str) . ")";
        }
    }
    $_[1] = '' if $chk;
    return $bytes;
}

sub decode($$;$) {
    my ( $obj, $bytes, $chk ) = @@_;
    my $len = length($bytes);
    my $str = "";
    no warnings 'uninitialized';
    while ( pos($bytes) < $len ) {
        if ( $bytes =~ /\G([^+]+)/ogc ) {
            $str .= $1;
        }
        elsif ( $bytes =~ /\G\+-/ogc ) {
            $str .= "+";
        }
        elsif ( $bytes =~ /\G\+([A-Za-z0-9+\/]+)-?/ogsc ) {
            my $base64 = $1;
            my $pad    = length($base64) % 4;
            $base64 .= "=" x ( 4 - $pad ) if $pad;
            $str .= $e_utf16->decode( decode_base64($base64) );
        }
        elsif ( $bytes =~ /\G\+/ogc ) {
            $^W and warn "Bad UTF7 data escape";
            $str .= "+";
        }
        else {
            die "This should not happen " . pos($bytes);
        }
    }
    $_[1] = '' if $chk;
    return $str;
}
1;
__END__

=head1 NAME

Encode::Unicode::UTF7 -- UTF-7 encoding

=head1 SYNOPSIS

    use Encode qw/encode decode/; 
    $utf7 = encode("UTF-7", $utf8);
    $utf8 = decode("UTF-7", $ucs2);

=head1 ABSTRACT

This module implements UTF-7 encoding documented in RFC 2152.  UTF-7,
as its name suggests, is a 7-bit re-encoded version of UTF-16BE.  It
is designed to be MTA-safe and expected to be a standard way to
exchange Unicoded mails via mails.  But with the advent of UTF-8 and
8-bit compliant MTAs, UTF-7 is hardly ever used.

UTF-7 was not supported by Encode until version 1.95 because of that.
But Unicode::String, a module by Gisle Aas which adds Unicode supports
to non-utf8-savvy perl did support UTF-7, the UTF-7 support was added
so Encode can supersede Unicode::String 100%.

=head1 In Practice

When you want to encode Unicode for mails and web pages, however, do
not use UTF-7 unless you are sure your recipients and readers can
handle it.  Very few MUAs and WWW Browsers support these days (only
Mozilla seems to support one).  For general cases, use UTF-8 for
message body and MIME-Header for header instead.

=head1 SEE ALSO

L<Encode>, L<Encode::Unicode>, L<Unicode::String>

RFC 2781 L<http://www.ietf.org/rfc/rfc2152.txt>

=cut
@


1.5
log
@Merge in perl 5.10.1
@
text
@d2 1
a2 1
# $Id: UTF7.pm,v 2.4 2006/06/03 20:28:48 dankogai Exp $
d10 1
a10 1
our $VERSION = do { my @@r = ( q$Revision: 2.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @@r };
@


1.4
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@@


1.3
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d2 1
a2 1
# $Id: UTF7.pm,v 1.2 2003/12/03 03:02:29 millert Exp $
d6 1
d10 1
a10 1
our $VERSION = do { my @@r = (q$Revision: 1.2 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };
d19 4
a22 3
my $specials =   quotemeta "\'(),-./:?";
$OPTIONAL_DIRECT_CHARS and
    $specials .= quotemeta "!\"#$%&*;<=>@@[]^_`{|}";
d24 2
a25 2
# We use qr/[\n\r\t\ ] instead 
my $re_asis =     qr/(?:[\n\r\t\ A-Za-z0-9$specials])/;
d27 1
a27 1
my $e_utf16 = find_encoding("UTF-16BE");
d29 1
a29 1
sub needs_lines { 1 };
d31 2
a32 2
sub encode($$;$){
    my ($obj, $str, $chk) = @@_;
d36 18
a53 15
    while (pos($str) < $len){
	if    ($str =~ /\G($re_asis+)/ogc){
	    $bytes .= $1;
	}elsif($str =~ /\G($re_encoded+)/ogsc){
	    if ($1 eq "+"){
		$bytes .= "+-";
	    }else{
		my $s = $1;
		my $base64 = encode_base64($e_utf16->encode($s), '');
		$base64 =~ s/=+$//;
		$bytes .= "+$base64-";
	    }
	}else{
	    die "This should not happen! (pos=" . pos($str) . ")";
	}
d58 3
a60 3
	   
sub decode{
    my ($obj, $bytes, $chk) = @@_;
d63 21
a83 16
    while (pos($bytes) < $len) {
	if    ($bytes =~ /\G([^+]+)/ogc) {
	    $str .= $1;
	}elsif($bytes =~ /\G\+-/ogc) {
	    $str .= "+";
	}elsif($bytes =~ /\G\+([A-Za-z0-9+\/]+)-?/ogsc) {
	    my $base64 = $1;
	    my $pad = length($base64) % 4;
	    $base64 .= "=" x (4 - $pad) if $pad;
	    $str .= $e_utf16->decode(decode_base64($base64));
	}elsif($bytes =~ /\G\+/ogc) {
	    $^W and warn "Bad UTF7 data escape";
	    $str .= "+";
	}else{
	    die "This should not happen " . pos($bytes);
	}
@


1.2
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d2 1
a2 1
# $Id: UTF7.pm,v 0.2 2003/05/19 04:56:03 dankogai Exp $
d9 1
a9 1
our $VERSION = do { my @@r = (q$Revision: 0.2 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };
d41 2
a42 1
		my $base64 = encode_base64($e_utf16->encode($1), '');
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@perl 5.8.2 from CPAN
@
text
@@


1.1.1.2
log
@Import of stock perl 5.8.5
@
text
@d2 1
a2 1
# $Id: UTF7.pm,v 1.2 2003/12/03 03:02:29 millert Exp $
d9 1
a9 1
our $VERSION = do { my @@r = (q$Revision: 1.2 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };
d41 1
a41 2
		my $s = $1;
		my $base64 = encode_base64($e_utf16->encode($s), '');
@


1.1.1.3
log
@perl 5.8.6 from CPAN
@
text
@d2 1
a2 1
# $Id: UTF7.pm,v 2.1 2004/05/25 16:27:14 dankogai Exp $
d9 1
a9 1
our $VERSION = do { my @@r = (q$Revision: 2.1 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d2 1
a2 1
# $Id: UTF7.pm,v 2.4 2006/06/03 20:28:48 dankogai Exp $
a5 1
use warnings;
d9 1
a9 1
our $VERSION = do { my @@r = ( q$Revision: 2.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @@r };
d18 3
a20 4
my $specials = quotemeta "\'(),-./:?";
$OPTIONAL_DIRECT_CHARS
  and $specials .= quotemeta "!\"#$%&*;<=>@@[]^_`{|}";

d22 2
a23 2
# We use qr/[\n\r\t\ ] instead
my $re_asis    = qr/(?:[\n\r\t\ A-Za-z0-9$specials])/;
d25 1
a25 1
my $e_utf16    = find_encoding("UTF-16BE");
d27 1
a27 1
sub needs_lines { 1 }
d29 2
a30 2
sub encode($$;$) {
    my ( $obj, $str, $chk ) = @@_;
d34 15
a48 18
    while ( pos($str) < $len ) {
        if ( $str =~ /\G($re_asis+)/ogc ) {
            $bytes .= $1;
        }
        elsif ( $str =~ /\G($re_encoded+)/ogsc ) {
            if ( $1 eq "+" ) {
                $bytes .= "+-";
            }
            else {
                my $s = $1;
                my $base64 = encode_base64( $e_utf16->encode($s), '' );
                $base64 =~ s/=+$//;
                $bytes .= "+$base64-";
            }
        }
        else {
            die "This should not happen! (pos=" . pos($str) . ")";
        }
d53 3
a55 3

sub decode($$;$) {
    my ( $obj, $bytes, $chk ) = @@_;
d58 16
a73 21
    no warnings 'uninitialized';
    while ( pos($bytes) < $len ) {
        if ( $bytes =~ /\G([^+]+)/ogc ) {
            $str .= $1;
        }
        elsif ( $bytes =~ /\G\+-/ogc ) {
            $str .= "+";
        }
        elsif ( $bytes =~ /\G\+([A-Za-z0-9+\/]+)-?/ogsc ) {
            my $base64 = $1;
            my $pad    = length($base64) % 4;
            $base64 .= "=" x ( 4 - $pad ) if $pad;
            $str .= $e_utf16->decode( decode_base64($base64) );
        }
        elsif ( $bytes =~ /\G\+/ogc ) {
            $^W and warn "Bad UTF7 data escape";
            $str .= "+";
        }
        else {
            die "This should not happen " . pos($bytes);
        }
@


