head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.4.0.8
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.4
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.19;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.44;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.48.04;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.18;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@BEGIN {
    if ($ENV{'PERL_CORE'}){
        chdir 't';
        unshift @@INC, '../lib';
    }
    require Config; import Config;
    if ($Config{'extensions'} !~ /\bEncode\b/) {
      print "1..0 # Skip: Encode was not built\n";
      exit 0;
    }
    if (ord("A") == 193) {
	print "1..0 # Skip: EBCDIC\n";
	exit 0;
    }
    unless (PerlIO::Layer->find('perlio')){
        print "1..0 # Skip: PerlIO required\n";
        exit 0;
    }
    $| = 1;
}

use strict;
use File::Basename;
use File::Spec;
use File::Compare qw(compare_text);
use File::Copy;
use FileHandle;

#use Test::More qw(no_plan);
use Test::More tests => 28;

our $DEBUG = 0;

use Encode (":all");
{
    no warnings;
    @@ARGV and $DEBUG = shift;
    #require Encode::JP::JIS7;
    #require Encode::KR::2022_KR;
    #$Encode::JP::JIS7::DEBUG = $DEBUG;
}



my $seq = 0;
my $dir = dirname(__FILE__);

my %e = 
    (
     jisx0208 => [ qw/euc-jp shiftjis 7bit-jis iso-2022-jp iso-2022-jp-1/],
     #ksc5601  => [ qw/euc-kr iso-2022-kr/],
     ksc5601  => [ qw/euc-kr/],
     #gb2312   => [ qw/euc-cn hz/],
     gb2312   => [ qw/euc-cn/],
    );

$/ = "\x0a"; # may fix VMS problem for test #28 and #29

for my $src(sort keys %e) {
    my $ufile = File::Spec->catfile($dir,"$src.utf");
    open my $fh, "<:utf8", $ufile or die "$ufile : $!";
    my @@uline = <$fh>;
    my $utext = join('' => @@uline);
    close $fh;

    for my $e (@@{$e{$src}}){
	my $sfile = File::Spec->catfile($dir,"$$.sio");
	my $pfile = File::Spec->catfile($dir,"$$.pio");
    
	# first create a file without perlio
	dump2file($sfile, &encode($e, $utext, 0));
    
	# then create a file via perlio without autoflush

    TODO:{
	    #local $TODO = "$e: !perlio_ok" unless (perlio_ok($e) or $DEBUG);
	    todo_skip "$e: !perlio_ok", 4 unless (perlio_ok($e) or $DEBUG);
	    no warnings 'uninitialized';
	    open $fh, ">:encoding($e)", $pfile or die "$sfile : $!";
	    $fh->autoflush(0);
	    print $fh $utext;
	    close $fh;
	    $seq++;
	    is(compare_text($sfile, $pfile), 0 => ">:encoding($e)");
	    if ($DEBUG){
		copy $sfile, "$sfile.$seq";
		copy $pfile, "$pfile.$seq";
	    }
	    
	    # this time print line by line.
	    # works even for ISO-2022 but not ISO-2022-KR
	    open $fh, ">:encoding($e)", $pfile or die "$sfile : $!";
	    $fh->autoflush(1);
	    for my $l (@@uline) {
		print $fh $l;
	    }
	    close $fh;
	    $seq++;
	    is(compare_text($sfile, $pfile), 0 => ">:encoding($e) by lines");
	    if ($DEBUG){
		copy $sfile, "$sfile.$seq";
		copy $pfile, "$pfile.$seq";
	    }
	    my $dtext;
	    open $fh, "<:encoding($e)", $pfile or die "$pfile : $!";
	    $fh->autoflush(0);
	    $dtext = join('' => <$fh>);
	    close $fh;
	    $seq++;
	    ok($utext eq $dtext, "<:encoding($e)");
	    if ($DEBUG){
		dump2file("$sfile.$seq", $utext);
		dump2file("$pfile.$seq", $dtext);
	    }
	    if (perlio_ok($e) or $DEBUG){
		$dtext = '';
		open $fh, "<:encoding($e)", $pfile or die "$pfile : $!";
		while(defined(my $l = <$fh>)) {
		    $dtext .= $l;
		}
		close $fh;
	    }
	    $seq++;
	    ok($utext eq $dtext,  "<:encoding($e) by lines");
	    if ($DEBUG){
		dump2file("$sfile.$seq", $utext);
		dump2file("$pfile.$seq", $dtext);
	    }
	}
	$DEBUG or unlink ($sfile, $pfile);
    }
}
    

sub dump2file{
    no warnings;
    open my $fh, ">", $_[0] or die "$_[0]: $!";
    binmode $fh;
    print $fh $_[1];
    close $fh;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d30 1
a30 1
use Test::More tests => 38;
d43 2
d51 1
d53 2
a54 1
     gb2312   => [ qw/euc-cn hz/],
d59 1
a59 1
for my $src (sort keys %e) {
d75 3
a77 2
    SKIP:{
	    skip "$e: !perlio_ok", 4 unless (perlio_ok($e) or $DEBUG);
d130 1
a130 4
     if ( ! $DEBUG ) {
            1 while unlink ($sfile);
            1 while unlink ($pfile);
        }
d133 1
a134 46
# BOM Test

SKIP:{
    my $pev = PerlIO::encoding->VERSION;
    skip "PerlIO::encoding->VERSION = $pev <= 0.07 ", 6
	unless ($pev >= 0.07 or $DEBUG);

    my $file = File::Spec->catfile($dir,"jisx0208.utf");
    open my $fh, "<:utf8", $file or die "$file : $!";
    my $str = join('' => <$fh>);
    close $fh;
    my %bom = (
	       'UTF-16BE' => pack('n', 0xFeFF),
	       'UTF-16LE' => pack('v', 0xFeFF),
	       'UTF-32BE' => pack('N', 0xFeFF),
	       'UTF-32LE' => pack('V', 0xFeFF),
	      );
    # reading
    for my $utf (sort keys %bom){
	my $bomed = $bom{$utf} . encode($utf, $str);
	my $sfile = File::Spec->catfile($dir,".${utf}_${seq}_$$");
	dump2file($sfile, $bomed);
	my $utf_nobom = $utf; $utf_nobom =~ s/(LE|BE)$//o;
	# reading
	open $fh, "<:encoding($utf_nobom)", $sfile or die "$sfile : $!";
	my $cmp = join '' => <$fh>;
	close $fh;
	is($str, $cmp, "<:encoding($utf_nobom) eq $utf");
	unlink $sfile;  $seq++;
    }
    # writing
    for my $utf_nobom (qw/UTF-16 UTF-32/){
	my $utf = $utf_nobom . 'BE';
	my $sfile = File::Spec->catfile($dir,".${utf_nobom}_${seq}_$$");
	my $bomed = $bom{$utf} . encode($utf, $str);
	open  $fh, ">:encoding($utf_nobom)", $sfile or die "$sfile : $!";
	print $fh $str;
	close $fh;
	open my $fh, "<", $sfile or die "$sfile : $!";
	read $fh, my $cmp, -s $sfile;
	close $fh;
	use bytes ();
	ok($bomed eq $cmp, ">:encoding($utf_nobom) eq $utf");
	unlink $sfile; $seq++;
    }
}
@


1.1.1.3
log
@perl 5.8.8 import
@
text
@d170 1
a170 1
	open my $fh, "<:bytes", $sfile or die "$sfile : $!";
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d12 2
a13 2
    print "1..0 # Skip: EBCDIC\n";
    exit 0;
d63 2
a64 2
    my $sfile = File::Spec->catfile($dir,"$$.sio");
    my $pfile = File::Spec->catfile($dir,"$$.pio");
d66 2
a67 2
    # first create a file without perlio
    dump2file($sfile, &encode($e, $utext, 0));
d69 1
a69 1
    # then create a file via perlio without autoflush
d72 53
a124 53
        skip "$e: !perlio_ok", 4 unless (perlio_ok($e) or $DEBUG);
        no warnings 'uninitialized';
        open $fh, ">:encoding($e)", $pfile or die "$sfile : $!";
        $fh->autoflush(0);
        print $fh $utext;
        close $fh;
        $seq++;
        is(compare_text($sfile, $pfile), 0 => ">:encoding($e)");
        if ($DEBUG){
        copy $sfile, "$sfile.$seq";
        copy $pfile, "$pfile.$seq";
        }
        
        # this time print line by line.
        # works even for ISO-2022 but not ISO-2022-KR
        open $fh, ">:encoding($e)", $pfile or die "$sfile : $!";
        $fh->autoflush(1);
        for my $l (@@uline) {
        print $fh $l;
        }
        close $fh;
        $seq++;
        is(compare_text($sfile, $pfile), 0 => ">:encoding($e) by lines");
        if ($DEBUG){
        copy $sfile, "$sfile.$seq";
        copy $pfile, "$pfile.$seq";
        }
        my $dtext;
        open $fh, "<:encoding($e)", $pfile or die "$pfile : $!";
        $fh->autoflush(0);
        $dtext = join('' => <$fh>);
        close $fh;
        $seq++;
        ok($utext eq $dtext, "<:encoding($e)");
        if ($DEBUG){
        dump2file("$sfile.$seq", $utext);
        dump2file("$pfile.$seq", $dtext);
        }
        if (perlio_ok($e) or $DEBUG){
        $dtext = '';
        open $fh, "<:encoding($e)", $pfile or die "$pfile : $!";
        while(defined(my $l = <$fh>)) {
            $dtext .= $l;
        }
        close $fh;
        }
        $seq++;
        ok($utext eq $dtext,  "<:encoding($e) by lines");
        if ($DEBUG){
        dump2file("$sfile.$seq", $utext);
        dump2file("$pfile.$seq", $dtext);
        }
    }
d137 1
a137 1
    unless ($pev >= 0.07 or $DEBUG);
d144 5
a148 5
           'UTF-16BE' => pack('n', 0xFeFF),
           'UTF-16LE' => pack('v', 0xFeFF),
           'UTF-32BE' => pack('N', 0xFeFF),
           'UTF-32LE' => pack('V', 0xFeFF),
          );
d151 10
a160 10
    my $bomed = $bom{$utf} . encode($utf, $str);
    my $sfile = File::Spec->catfile($dir,".${utf}_${seq}_$$");
    dump2file($sfile, $bomed);
    my $utf_nobom = $utf; $utf_nobom =~ s/(LE|BE)$//o;
    # reading
    open $fh, "<:encoding($utf_nobom)", $sfile or die "$sfile : $!";
    my $cmp = join '' => <$fh>;
    close $fh;
    is($str, $cmp, "<:encoding($utf_nobom) eq $utf");
    unlink $sfile;  $seq++;
d164 12
a175 12
    my $utf = $utf_nobom . 'BE';
    my $sfile = File::Spec->catfile($dir,".${utf_nobom}_${seq}_$$");
    my $bomed = $bom{$utf} . encode($utf, $str);
    open  $fh, ">:encoding($utf_nobom)", $sfile or die "$sfile : $!";
    print $fh $str;
    close $fh;
    open my $fh, "<:bytes", $sfile or die "$sfile : $!";
    read $fh, my $cmp, -s $sfile;
    close $fh;
    use bytes ();
    ok($bomed eq $cmp, ">:encoding($utf_nobom) eq $utf");
    unlink $sfile; $seq++;
@


