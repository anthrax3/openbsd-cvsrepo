head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.4.0.8
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.4
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.6
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.4
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.2
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.19;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.01.15.21.16.48;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.48.04;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.18;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@BEGIN {
    if ($ENV{'PERL_CORE'}){
        chdir 't';
        unshift @@INC, '../lib';
    }
    require Config; import Config;
    if ($Config{'extensions'} !~ /\bEncode\b/) {
      print "1..0 # Skip: Encode was not built\n";
      exit 0;
    }
    if (ord("A") == 193) {
	print "1..0 # Skip: EBCDIC\n";
	exit 0;
    }
    $| = 1;
}

use strict;
#use Test::More qw(no_plan);
use Test::More tests => 22;
use Encode q(:all);

my $original = '';
my $nofallback  = '';
my ($fallenback, $quiet, $perlqq, $htmlcref, $xmlcref);
for my $i (0x20..0x7e){
    $original .= chr($i);
}
$fallenback = $quiet = 
$perlqq = $htmlcref = $xmlcref = $nofallback = $original;

my $residue = '';
for my $i (0x80..0xff){
    $original   .= chr($i);
    $residue    .= chr($i);
    $fallenback .= '?';
    $perlqq     .= sprintf("\\x{%04x}", $i);
    $htmlcref    .= sprintf("&#%d;", $i);
    $xmlcref    .= sprintf("&#x%x;", $i);
}
utf8::upgrade($original);
my $meth   = find_encoding('ascii');

my $src = $original;
my $dst = $meth->encode($src, FB_DEFAULT);
is($dst, $fallenback, "FB_DEFAULT");
is($src, $original,   "FB_DEFAULT residue");

$src = $original;
eval{ $dst = $meth->encode($src, FB_CROAK) };
like($@@, qr/does not map to ascii/o, "FB_CROAK");
is($src, $original, "FB_CROAK residue");

$src = $original;
eval{ $dst = $meth->encode($src, FB_CROAK) };
like($@@, qr/does not map to ascii/o, "FB_CROAK");
is($src, $original, "FB_CROAK residue");


$src = $nofallback;
eval{ $dst = $meth->encode($src, FB_CROAK) };
is($@@, '', "FB_CROAK on success");
is($src, '', "FB_CROAK on success residue");

$src = $original;
$dst = $meth->encode($src, FB_QUIET);
is($dst, $quiet,   "FB_QUIET");
is($src, $residue, "FB_QUIET residue");

{
    my $message;
    local $SIG{__WARN__} = sub { $message = $_[0] };
    $src = $original;
    $dst = $meth->encode($src, FB_WARN);
    is($dst, $quiet,   "FB_WARN");
    is($src, $residue, "FB_WARN residue");
    like($message, qr/does not map to ascii/o, "FB_WARN message");

    $message = '';

    $src = $original;
    $dst = $meth->encode($src, WARN_ON_ERR);

    is($dst, $fallenback, "WARN_ON_ERR");
    is($src, '',  "WARN_ON_ERR residue");
    like($message, qr/does not map to ascii/o, "WARN_ON_ERR message");
}

$src = $original;
$dst = $meth->encode($src, FB_PERLQQ);
is($dst, $perlqq,   "FB_PERLQQ");
is($src, '', "FB_PERLQQ residue");

$src = $original;
$dst = $meth->encode($src, FB_HTMLCREF);
is($dst, $htmlcref,   "FB_HTMLCREF");
is($src, '', "FB_HTMLCREF residue");

$src = $original;
$dst = $meth->encode($src, FB_XMLCREF);
is($dst, $xmlcref,   "FB_XMLCREF");
is($src, '', "FB_XMLCREF residue");
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.6 from CPAN
@
text
@d20 1
a20 1
use Test::More tests => 36;
d23 3
a25 3
my $uo = '';
my $nf  = '';
my ($af, $aq, $ap, $ah, $ax, $uf, $uq, $up, $uh, $ux);
d27 1
a27 1
    $uo .= chr($i);
d29 2
a30 3
$af = $aq = $ap = $ah = $ax = 
$uf = $uq = $up = $uh = $ux = 
$nf = $uo;
d34 1
a34 1
    $uo   .= chr($i);
d36 4
a39 8
    $af .= '?';
    $uf .= "\x{FFFD}";
    $ap .= sprintf("\\x{%04x}", $i);
    $up .= sprintf("\\x%02X", $i);
    $ah .= sprintf("&#%d;", $i);
    $uh .= sprintf("&#%d;", $i);
    $ax .= sprintf("&#x%x;", $i);
    $ux .= sprintf("&#x%x;", $i);
d41 2
d44 25
a68 45
my $ao = $uo;
utf8::upgrade($uo);

my $ascii  = find_encoding('ascii');
my $utf8   = find_encoding('utf8');

my $src = $uo;
my $dst = $ascii->encode($src, FB_DEFAULT);
is($dst, $af, "FB_DEFAULT ascii");
is($src, $uo, "FB_DEFAULT residue ascii");

$src = $ao;
$dst = $utf8->decode($src, FB_DEFAULT);
is($dst, $uf, "FB_DEFAULT utf8");
is($src, $ao, "FB_DEFAULT residue utf8");

$src = $uo;
eval{ $dst = $ascii->encode($src, FB_CROAK) };
like($@@, qr/does not map to ascii/o, "FB_CROAK ascii");
is($src, $uo, "FB_CROAK residue ascii");

$src = $ao;
eval{ $dst = $utf8->decode($src, FB_CROAK) };
like($@@, qr/does not map to Unicode/o, "FB_CROAK utf8");
is($src, $ao, "FB_CROAK residue utf8");

$src = $nf;
eval{ $dst = $ascii->encode($src, FB_CROAK) };
is($@@, '', "FB_CROAK on success ascii");
is($src, '', "FB_CROAK on success residue ascii");

$src = $nf;
eval{ $dst = $utf8->decode($src, FB_CROAK) };
is($@@, '', "FB_CROAK on success utf8");
is($src, '', "FB_CROAK on success residue utf8");

$src = $uo;
$dst = $ascii->encode($src, FB_QUIET);
is($dst, $aq,   "FB_QUIET ascii");
is($src, $residue, "FB_QUIET residue ascii");

$src = $ao;
$dst = $utf8->decode($src, FB_QUIET);
is($dst, $uq,   "FB_QUIET utf8");
is($src, $residue, "FB_QUIET residue utf8");
d71 1
a71 1
    my $message = '';
d73 5
a77 6

    $src = $uo;
    $dst = $ascii->encode($src, FB_WARN);
    is($dst, $aq,   "FB_WARN ascii");
    is($src, $residue, "FB_WARN residue ascii");
    like($message, qr/does not map to ascii/o, "FB_WARN message ascii");
a79 5
    $src = $ao;
    $dst = $utf8->decode($src, FB_WARN);
    is($dst, $uq,   "FB_WARN utf8");
    is($src, $residue, "FB_WARN residue utf8");
    like($message, qr/does not map to Unicode/o, "FB_WARN message utf8");
d81 2
a82 6
    $message = '';
    $src = $uo;
    $dst = $ascii->encode($src, WARN_ON_ERR);
    is($dst, $af, "WARN_ON_ERR ascii");
    is($src, '',  "WARN_ON_ERR residue ascii");
    like($message, qr/does not map to ascii/o, "WARN_ON_ERR message ascii");
d84 3
a86 6
    $message = '';
    $src = $ao;
    $dst = $utf8->decode($src, WARN_ON_ERR);
    is($dst, $uf, "WARN_ON_ERR utf8");
    is($src, '',  "WARN_ON_ERR residue utf8");
    like($message, qr/does not map to Unicode/o, "WARN_ON_ERR message ascii");
d89 14
a102 29
$src = $uo;
$dst = $ascii->encode($src, FB_PERLQQ);
is($dst, $ap,   "FB_PERLQQ ascii");
is($src, '', "FB_PERLQQ residue ascii");

$src = $ao;
$dst = $utf8->decode($src, FB_PERLQQ);
is($dst, $up,   "FB_PERLQQ utf8");
is($src, '', "FB_PERLQQ residue utf8");

$src = $uo;
$dst = $ascii->encode($src, FB_HTMLCREF);
is($dst, $ah,   "FB_HTMLCREF ascii");
is($src, '', "FB_HTMLCREF residue ascii");

#$src = $ao;
#$dst = $utf8->decode($src, FB_HTMLCREF);
#is($dst, $uh,   "FB_HTMLCREF utf8");
#is($src, '', "FB_HTMLCREF residue utf8");

$src = $uo;
$dst = $ascii->encode($src, FB_XMLCREF);
is($dst, $ax,   "FB_XMLCREF ascii");
is($src, '', "FB_XMLCREF residue ascii");

#$src = $ao;
#$dst = $utf8->decode($src, FB_XMLCREF);
#is($dst, $ax,   "FB_XMLCREF utf8");
#is($src, '', "FB_XMLCREF residue utf8");
@


1.1.1.3
log
@perl 5.8.8 import
@
text
@d20 1
a20 1
use Test::More tests => 44;
d25 1
a25 1
my ($af, $aq, $ap, $ah, $ax, $uf, $uq, $up, $uh, $ux, $ac, $uc);
d29 2
a30 2
$af = $aq = $ap = $ah = $ax = $ac =
$uf = $uq = $up = $uh = $ux = $uc =
d42 1
a42 1
    $uh .= sprintf("\\x%02X", $i);
d44 1
a44 3
    $ux .= sprintf("\\x%02X", $i);
    $ac .= sprintf("<U+%04X>", $i);
    $uc .= sprintf("[%02X]", $i);
d127 2
a128 2
is($dst, $ap, "FB_PERLQQ encode");
is($src, $uo, "FB_PERLQQ residue encode");
d131 3
a133 3
$dst = $ascii->decode($src, FB_PERLQQ);
is($dst, $up, "FB_PERLQQ decode");
is($src, $ao, "FB_PERLQQ residue decode");
d137 2
a138 2
is($dst, $ah, "FB_HTMLCREF encode");
is($src, $uo, "FB_HTMLCREF residue encode");
d140 4
a143 4
$src = $ao;
$dst = $ascii->decode($src, FB_HTMLCREF);
is($dst, $uh, "FB_HTMLCREF decode");
is($src, $ao, "FB_HTMLCREF residue decode");
d147 2
a148 7
is($dst, $ax, "FB_XMLCREF encode");
is($src, $uo, "FB_XMLCREF residue encode");

$src = $ao;
$dst = $ascii->decode($src, FB_XMLCREF);
is($dst, $ux, "FB_XMLCREF decode");
is($src, $ao, "FB_XMLCREF residue decode");
d150 4
a153 9
$src = $uo;
$dst = $ascii->encode($src, sub{ sprintf "<U+%04X>", shift });
is($dst, $ac, "coderef encode");
is($src, $uo, "coderef residue encode");

$src = $ao;
$dst = $ascii->decode($src, sub{ sprintf "[%02X]", shift });
is($dst, $uc, "coderef decode");
is($src, $ao, "coderef residue decode");
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d12 2
a13 2
    print "1..0 # Skip: EBCDIC\n";
    exit 0;
d20 1
a20 1
use Test::More tests => 48;
a165 12

$src = "\x{3000}";
$dst = $ascii->encode($src, sub{ $_[0] });
is $dst, 0x3000."", qq{$ascii->encode(\$src, sub{ \$_[0] } )};
$dst = encode("ascii", "\x{3000}", sub{ $_[0] });
is $dst, 0x3000."", qq{encode("ascii", "\\x{3000}", sub{ \$_[0] })};

$src = pack "C*", 0xFF;
$dst = $ascii->decode($src, sub{ $_[0] });
is $dst, 0xFF."", qq{$ascii->encode(\$src, sub{ \$_[0] } )};
$dst = decode("ascii", (pack "C*", 0xFF), sub{ $_[0] });
is $dst, 0xFF."", qq{decode("ascii", (pack "C*", 0xFF), sub{ \$_[0] })};
@


