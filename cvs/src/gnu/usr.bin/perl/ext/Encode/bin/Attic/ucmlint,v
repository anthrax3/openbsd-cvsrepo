head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.4.0.4
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.2
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.18
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.16
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.14
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.12
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.10
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.8
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.6
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.4
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.2
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.19;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.08.09.17.45.59;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.17;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.10.12.18.11.15;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#!/usr/local/bin/perl
#
# $Id: ucmlint,v 0.2 2002/04/22 02:45:50 dankogai Exp $
#

use strict;
our  $VERSION = do { my @@r = (q$Revision: 0.2 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };

use Getopt::Std;
our %Opt;
getopts("Dehfv", \%Opt);

if ($Opt{e}){
   eval{ require Encode; };
   $@@ and die "can't load Encode : $@@";
}

$Opt{h} and help();
@@ARGV or help();

sub help{
    print <<"";
$0 -[Dehfv] [ucm files ...]
  -D debug mode on
  -e test with Encode module also (requires perl 5.7.3 or higher)
  -h shows this message
  -f forces roundtrip check even for |[123]
  -v verbose mode

}

$| = 1;
my (%Hdr, %U2E, %E2U);
my $in_charmap = 0;
my $nerror = 0;
my $nwarning = 0;

sub nit($;$){
    my ($msg, $level) = @@_;
    my $lstr;
    if ($level == 2){
	$lstr = 'notice';
    }elsif ($level == 1){
	$lstr = 'warning'; $nwarning++;
    }else{
	$lstr = 'error'; $nerror++;
    }
    print "$ARGV:$lstr in line $.: $msg\n";
}

for $ARGV (@@ARGV){
    open UCM, $ARGV or die "$ARGV:$!";
    %Hdr = %U2E = %E2U = ();
    $in_charmap = $nerror = $nwarning = 0;
    $. = 0;
    while(<UCM>){
	chomp;
	s/\s*#.*$//o; /^$/ and next;
	if ($_ eq "CHARMAP"){ 
	    $in_charmap = 1;
	    for my $must (qw/code_set_name mb_cur_min mb_cur_max/){
		exists $Hdr{$must} or nit "<$must> nonexistent";
	    }
	    $Hdr{mb_cur_min} > $Hdr{mb_cur_max}
	    and nit sprintf("mb_cur_min(%d) > mb_cur_max(%d)",
			    $Hdr{mb_cur_min},$Hdr{mb_cur_max});
	    $in_charmap = 1;
	    next;
	}
	unless ($in_charmap){
	    my($hkey, $hvalue) = /^<(\S+)>\s+[\"\']?([^\"\']+)/o or next;
	    $Opt{D} and warn "$hkey => $hvalue";
	    if ($hkey eq "code_set_name"){ # name check
		exists $Hdr{code_set_name} 
		and nit "Duplicate <code_set_name>: $hkey";
	    }
	    if ($hkey eq "code_set_alias"){ # alias check
		$hvalue eq $Hdr{code_set_name}
		and nit qq(alias "$hvalue" is already in <code_set_name>);
	    }
	    $Hdr{$hkey} = $hvalue;
	}else{
	    my $name = $Hdr{code_set_name};
	    my($unistr, $encstr, $fb) = /^(\S+)\s+(\S+)\s(\S+)/o or next;
	    $Opt{v} and nit $_, 2;
	    my $uni = uniparse($unistr);
	    my $enc = encparse($encstr);
	    $fb =~ /^\|([0123])$/ or nit "malformed fallback: $fb";
	    $fb = $1; 
	    $Opt{f} and $fb = 0;
	    unless ($fb == 1){ # check uni -> enc
		if (exists $U2E{$uni}){
		    nit "dupe encode map: U$uni => $U2E{$uni} and $enc", 1;
		}else{
		    $U2E{$uni} = $enc;
		    if ($Opt{e} and $fb != 3) {
			my $e = hex2enc($enc);
			my $u = hex2uni($uni);
			my $eu = Encode::encode($name, $u);
			$e eq $eu
			    or nit qq(encode('$name', $uni) != $enc);
		    }
		}
	    }
	    unless ($fb == 3){  # check enc -> uni
		if (exists $E2U{$enc}){
		    nit "dupe decode map: $enc => U$E2U{$enc} and U$uni", 1;
		}else{
		    $E2U{$enc} = $uni;
		    if ($Opt{e} and $fb != 1) {
			my $e = hex2enc($enc);
			my $u = hex2uni($uni);
			$Opt{D} and warn "$uni, $enc";
			my $de = Encode::decode($name, $e);
			$de eq $u
			    or nit qq(decode('$name', $enc) != $uni);
		    }
		}
	    }
	    # warn "$uni, $enc, $fb";
	}
    }
    $in_charmap or nit "Where is CHARMAP?";
    checkRT();
    printf ("$ARGV: %s error%s found\n", 
	    ($nerror == 0 ? 'no' : $nerror),
	    ($nerror > 1 ? 's' : ''));
}

exit;

sub hex2enc{
    pack("C*", map {hex($_)} split(",", shift));
}
sub hex2uni{
    join("", map { chr(hex($_)) } split(",", shift));
}

sub checkRT{
    for my $uni (keys %E2U){
	my $enc = $U2E{$uni} or next; # okay
	$E2U{$U2E{$uni}} eq $uni or
	    nit "RT failure: U$uni => $enc =>U$E2U{$U2E{$uni}}";
    }
    for my $enc (keys %E2U){
	my $uni =  $E2U{$enc} or next; # okay
	$U2E{$E2U{$enc}} eq $enc or
	    nit "RT failure: $enc => U$uni => $U2E{$E2U{$enc}}";
    }
}


sub uniparse{
    my $str = shift;
    my @@u;
    push @@u, $1 while($str =~ /\G<U(.*?)>/ig);
    for my $u (@@u){
	$u =~ /^([0-9A-Za-z]+)$/o
	    or nit "malformed Unicode character: $u";
    }
    return join(',', @@u);
}

sub encparse{
    my $str = shift;
    my @@e;
    for my $e (split /\\x/io, $str){
	$e or next; # first \x
	$e =~ /^([0-9A-Za-z]{1,2})$/io
	    or nit "Hex $e in $str is bogus";
	push @@e, $1;
    }
    return join(',', @@e);
}



__END__

A UCM file looks like this.

  #
  # Comments
  #
  <code_set_name> "US-ascii" # Required
  <code_set_alias> "ascii"   # Optional
  <mb_cur_min> 1             # Required; usually 1
  <mb_cur_max> 1             # Max. # of bytes/char
  <subchar> \x3F             # Substitution char
  #
  CHARMAP
  <U0000> \x00 |0 # <control>
  <U0001> \x01 |0 # <control>
  <U0002> \x02 |0 # <control>
  ....
  <U007C> \x7C |0 # VERTICAL LINE
  <U007D> \x7D |0 # RIGHT CURLY BRACKET
  <U007E> \x7E |0 # TILDE
  <U007F> \x7F |0 # <control>
  END CHARMAP

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@Import of stock perl 5.8.5
@
text
@d3 1
a3 1
# $Id: ucmlint,v 2.0 2004/05/16 20:55:16 dankogai Exp $
d7 1
a7 1
our  $VERSION = do { my @@r = (q$Revision: 2.0 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
# $Id: ucmlint,v 2.1 2006/05/03 18:24:10 dankogai Exp $
d7 1
a7 1
our  $VERSION = do { my @@r = (q$Revision: 2.1 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };
d42 1
a42 1
    $lstr = 'notice';
d44 1
a44 1
    $lstr = 'warning'; $nwarning++;
d46 1
a46 1
    $lstr = 'error'; $nerror++;
d57 65
a121 65
    chomp;
    s/\s*#.*$//o; /^$/ and next;
    if ($_ eq "CHARMAP"){ 
        $in_charmap = 1;
        for my $must (qw/code_set_name mb_cur_min mb_cur_max/){
        exists $Hdr{$must} or nit "<$must> nonexistent";
        }
        $Hdr{mb_cur_min} > $Hdr{mb_cur_max}
        and nit sprintf("mb_cur_min(%d) > mb_cur_max(%d)",
                $Hdr{mb_cur_min},$Hdr{mb_cur_max});
        $in_charmap = 1;
        next;
    }
    unless ($in_charmap){
        my($hkey, $hvalue) = /^<(\S+)>\s+[\"\']?([^\"\']+)/o or next;
        $Opt{D} and warn "$hkey => $hvalue";
        if ($hkey eq "code_set_name"){ # name check
        exists $Hdr{code_set_name} 
        and nit "Duplicate <code_set_name>: $hkey";
        }
        if ($hkey eq "code_set_alias"){ # alias check
        $hvalue eq $Hdr{code_set_name}
        and nit qq(alias "$hvalue" is already in <code_set_name>);
        }
        $Hdr{$hkey} = $hvalue;
    }else{
        my $name = $Hdr{code_set_name};
        my($unistr, $encstr, $fb) = /^(\S+)\s+(\S+)\s(\S+)/o or next;
        $Opt{v} and nit $_, 2;
        my $uni = uniparse($unistr);
        my $enc = encparse($encstr);
        $fb =~ /^\|([0123])$/ or nit "malformed fallback: $fb";
        $fb = $1; 
        $Opt{f} and $fb = 0;
        unless ($fb == 1){ # check uni -> enc
        if (exists $U2E{$uni}){
            nit "dupe encode map: U$uni => $U2E{$uni} and $enc", 1;
        }else{
            $U2E{$uni} = $enc;
            if ($Opt{e} and $fb != 3) {
            my $e = hex2enc($enc);
            my $u = hex2uni($uni);
            my $eu = Encode::encode($name, $u);
            $e eq $eu
                or nit qq(encode('$name', $uni) != $enc);
            }
        }
        }
        unless ($fb == 3){  # check enc -> uni
        if (exists $E2U{$enc}){
            nit "dupe decode map: $enc => U$E2U{$enc} and U$uni", 1;
        }else{
            $E2U{$enc} = $uni;
            if ($Opt{e} and $fb != 1) {
            my $e = hex2enc($enc);
            my $u = hex2uni($uni);
            $Opt{D} and warn "$uni, $enc";
            my $de = Encode::decode($name, $e);
            $de eq $u
                or nit qq(decode('$name', $enc) != $uni);
            }
        }
        }
        # warn "$uni, $enc, $fb";
    }
d126 2
a127 2
        ($nerror == 0 ? 'no' : $nerror),
        ($nerror > 1 ? 's' : ''));
d141 3
a143 3
    my $enc = $U2E{$uni} or next; # okay
    $E2U{$U2E{$uni}} eq $uni or
        nit "RT failure: U$uni => $enc =>U$E2U{$U2E{$uni}}";
d146 3
a148 3
    my $uni =  $E2U{$enc} or next; # okay
    $U2E{$E2U{$enc}} eq $enc or
        nit "RT failure: $enc => U$uni => $U2E{$E2U{$enc}}";
d158 2
a159 2
    $u =~ /^([0-9A-Za-z]+)$/o
        or nit "malformed Unicode character: $u";
d168 4
a171 4
    $e or next; # first \x
    $e =~ /^([0-9A-Za-z]{1,2})$/io
        or nit "Hex $e in $str is bogus";
    push @@e, $1;
@


1.1.1.4
log
@import perl 5.10.1
@
text
@d3 1
a3 1
# $Id: ucmlint,v 2.2 2008/03/12 09:51:11 dankogai Exp $
d7 1
a7 1
our  $VERSION = do { my @@r = (q$Revision: 2.2 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };
d33 1
a33 1
my (%Hdr, %U2E, %E2U, %Fallback);
d42 1
a42 1
        $lstr = 'notice';
d44 1
a44 1
        $lstr = 'warning'; $nwarning++;
d46 1
a46 1
        $lstr = 'error'; $nerror++;
d53 1
a53 1
    %Hdr = %U2E = %E2U = %Fallback = ();
d57 45
a101 6
        chomp;
        s/\s*#.*$//o; /^$/ and next;
        if ($_ eq "CHARMAP"){ 
            $in_charmap = 1;
            for my $must (qw/code_set_name mb_cur_min mb_cur_max/){
                exists $Hdr{$must} or nit "<$must> nonexistent";
d103 5
a107 18
            $Hdr{mb_cur_min} > $Hdr{mb_cur_max}
                and nit sprintf("mb_cur_min(%d) > mb_cur_max(%d)",
                                $Hdr{mb_cur_min},$Hdr{mb_cur_max});
            $in_charmap = 1;
            next;
        }
        unless ($in_charmap){
            my($hkey, $hvalue) = /^<(\S+)>\s+[\"\']?([^\"\']+)/o or next;
            $Opt{D} and warn "$hkey => $hvalue";
            if ($hkey eq "code_set_name"){ # name check
                exists $Hdr{code_set_name} 
                    and nit "Duplicate <code_set_name>: $hkey";
            }
            if ($hkey eq "code_set_alias"){ # alias check
                $hvalue eq $Hdr{code_set_name}
                    and nit qq(alias "$hvalue" is already in <code_set_name>);
            }
            $Hdr{$hkey} = $hvalue;
d109 8
a116 22
            my $name = $Hdr{code_set_name};
            my($unistr, $encstr, $fb) = /^(\S+)\s+(\S+)\s(\S+)/o or next;
            $Opt{v} and nit $_, 2;
            my $uni = uniparse($unistr);
            my $enc = encparse($encstr);
            $fb =~ /^\|([0123])$/ or nit "malformed fallback: $fb";
            $fb = $1; 
            $Opt{f} and $fb = 0;
            unless ($fb == 3){ # check uni -> enc
                if (exists $U2E{$uni}){
                    nit "dupe encode map: U$uni => $U2E{$uni} and $enc", 1;
                }else{
                    $U2E{$uni} = $enc;
                    $Fallback{$uni}{$enc} = 1 if $fb == 1;
                    if ($Opt{e}) {
                        my $e = hex2enc($enc);
                        my $u = hex2uni($uni);
                        my $eu = Encode::encode($name, $u);
                        $e eq $eu
                            or nit qq(encode('$name', $uni) != $enc);
                    }
                }
a117 17
            unless ($fb == 1){  # check enc -> uni
                if (exists $E2U{$enc}){
                    nit "dupe decode map: $enc => U$E2U{$enc} and U$uni", 1;
                }else{
                    $E2U{$enc} = $uni;
                    $Fallback{$enc}{$uni} = 1 if $fb == 3;
                    if ($Opt{e}) {
                        my $e = hex2enc($enc);
                        my $u = hex2uni($uni);
                        $Opt{D} and warn "$uni, $enc";
                        my $de = Encode::decode($name, $e);
                        $de eq $u
                            or nit qq(decode('$name', $enc) != $uni);
                    }
                }
            }
            # warn "$uni, $enc, $fb";
d119 3
d126 2
a127 2
            ($nerror == 0 ? 'no' : $nerror),
            ($nerror > 1 ? 's' : ''));
d141 3
a143 3
        my $enc = $U2E{$uni} or next; # okay
        $E2U{$U2E{$uni}} eq $uni or $Fallback{$uni}{$enc} or
            nit "RT failure: U$uni => $enc =>U$E2U{$U2E{$uni}}";
d146 3
a148 3
        my $uni = $E2U{$enc} or next; # okay
        $U2E{$E2U{$enc}} eq $enc or $Fallback{$enc}{$uni} or
            nit "RT failure: $enc => U$uni => $U2E{$E2U{$enc}}";
d158 2
a159 2
        $u =~ /^([0-9A-Za-z]+)$/o
            or nit "malformed Unicode character: $u";
d168 4
a171 4
        $e or next; # first \x
        $e =~ /^([0-9A-Za-z]{1,2})$/io
            or nit "Hex $e in $str is bogus";
        push @@e, $1;
@


