head	1.3;
access;
symbols
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.1.1.7.0.6
	OPENBSD_4_6_BASE:1.1.1.7
	OPENBSD_4_5:1.1.1.7.0.2
	OPENBSD_4_5_BASE:1.1.1.7
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.1.1.6.0.10
	OPENBSD_4_4_BASE:1.1.1.6
	OPENBSD_4_3:1.1.1.6.0.8
	OPENBSD_4_3_BASE:1.1.1.6
	OPENBSD_4_2:1.1.1.6.0.6
	OPENBSD_4_2_BASE:1.1.1.6
	OPENBSD_4_1:1.1.1.6.0.4
	OPENBSD_4_1_BASE:1.1.1.6
	OPENBSD_4_0:1.1.1.6.0.2
	OPENBSD_4_0_BASE:1.1.1.6
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.1.1.5.0.6
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.4
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.2
	OPENBSD_3_7_BASE:1.1.1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2010.09.24.14.59.18;	author millert;	state dead;
branches;
next	1.2;

1.2
date	2009.10.22.20.46.10;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.43;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.04.07.21.13.00;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.45.58;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.01.15.21.16.47;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.48.02;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.16;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.11.15;	author millert;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#
# $Id: Encode.pm,v 2.35 2009/07/13 00:49:38 dankogai Exp $
#
package Encode;
use strict;
use warnings;
our $VERSION = sprintf "%d.%02d", q$Revision: 2.35 $ =~ /(\d+)/g;
sub DEBUG () { 0 }
use XSLoader ();
XSLoader::load( __PACKAGE__, $VERSION );

require Exporter;
use base qw/Exporter/;

# Public, encouraged API is exported by default

our @@EXPORT = qw(
  decode  decode_utf8  encode  encode_utf8 str2bytes bytes2str
  encodings  find_encoding clone_encoding
);
our @@FB_FLAGS = qw(
  DIE_ON_ERR WARN_ON_ERR RETURN_ON_ERR LEAVE_SRC
  PERLQQ HTMLCREF XMLCREF STOP_AT_PARTIAL
);
our @@FB_CONSTS = qw(
  FB_DEFAULT FB_CROAK FB_QUIET FB_WARN
  FB_PERLQQ FB_HTMLCREF FB_XMLCREF
);
our @@EXPORT_OK = (
    qw(
      _utf8_off _utf8_on define_encoding from_to is_16bit is_8bit
      is_utf8 perlio_ok resolve_alias utf8_downgrade utf8_upgrade
      ),
    @@FB_FLAGS, @@FB_CONSTS,
);

our %EXPORT_TAGS = (
    all          => [ @@EXPORT,    @@EXPORT_OK ],
    default      => [ @@EXPORT ],
    fallbacks    => [ @@FB_CONSTS ],
    fallback_all => [ @@FB_CONSTS, @@FB_FLAGS ],
);

# Documentation moved after __END__ for speed - NI-S

our $ON_EBCDIC = ( ord("A") == 193 );

use Encode::Alias;

# Make a %Encoding package variable to allow a certain amount of cheating
our %Encoding;
our %ExtModule;
require Encode::Config;
#  See
#  https://bugzilla.redhat.com/show_bug.cgi?id=435505#c2
#  to find why sig handers inside eval{} are disabled.
eval {
    local $SIG{__DIE__};
    local $SIG{__WARN__};
    require Encode::ConfigLocal;
};

sub encodings {
    my $class = shift;
    my %enc;
    if ( @@_ and $_[0] eq ":all" ) {
        %enc = ( %Encoding, %ExtModule );
    }
    else {
        %enc = %Encoding;
        for my $mod ( map { m/::/o ? $_ : "Encode::$_" } @@_ ) {
            DEBUG and warn $mod;
            for my $enc ( keys %ExtModule ) {
                $ExtModule{$enc} eq $mod and $enc{$enc} = $mod;
            }
        }
    }
    return sort { lc $a cmp lc $b }
      grep      { !/^(?:Internal|Unicode|Guess)$/o } keys %enc;
}

sub perlio_ok {
    my $obj = ref( $_[0] ) ? $_[0] : find_encoding( $_[0] );
    $obj->can("perlio_ok") and return $obj->perlio_ok();
    return 0;    # safety net
}

sub define_encoding {
    my $obj  = shift;
    my $name = shift;
    $Encoding{$name} = $obj;
    my $lc = lc($name);
    define_alias( $lc => $obj ) unless $lc eq $name;
    while (@@_) {
        my $alias = shift;
        define_alias( $alias, $obj );
    }
    return $obj;
}

sub getEncoding {
    my ( $class, $name, $skip_external ) = @@_;

    ref($name) && $name->can('renew') and return $name;
    exists $Encoding{$name} and return $Encoding{$name};
    my $lc = lc $name;
    exists $Encoding{$lc} and return $Encoding{$lc};

    my $oc = $class->find_alias($name);
    defined($oc) and return $oc;
    $lc ne $name and $oc = $class->find_alias($lc);
    defined($oc) and return $oc;

    unless ($skip_external) {
        if ( my $mod = $ExtModule{$name} || $ExtModule{$lc} ) {
            $mod =~ s,::,/,g;
            $mod .= '.pm';
            eval { require $mod; };
            exists $Encoding{$name} and return $Encoding{$name};
        }
    }
    return;
}

sub find_encoding($;$) {
    my ( $name, $skip_external ) = @@_;
    return __PACKAGE__->getEncoding( $name, $skip_external );
}

sub resolve_alias($) {
    my $obj = find_encoding(shift);
    defined $obj and return $obj->name;
    return;
}

sub clone_encoding($) {
    my $obj = find_encoding(shift);
    ref $obj or return;
    eval { require Storable };
    $@@ and return;
    return Storable::dclone($obj);
}

sub encode($$;$) {
    my ( $name, $string, $check ) = @@_;
    return undef unless defined $string;
    $string .= '' if ref $string;    # stringify;
    $check ||= 0;
    unless ( defined $name ) {
        require Carp;
        Carp::croak("Encoding name should not be undef");
    }
    my $enc = find_encoding($name);
    unless ( defined $enc ) {
        require Carp;
        Carp::croak("Unknown encoding '$name'");
    }
    my $octets = $enc->encode( $string, $check );
    $_[1] = $string if $check and !ref $check and !( $check & LEAVE_SRC() );
    return $octets;
}
*str2bytes = \&encode;

sub decode($$;$) {
    my ( $name, $octets, $check ) = @@_;
    return undef unless defined $octets;
    $octets .= '' if ref $octets;
    $check ||= 0;
    my $enc = find_encoding($name);
    unless ( defined $enc ) {
        require Carp;
        Carp::croak("Unknown encoding '$name'");
    }
    my $string = $enc->decode( $octets, $check );
    $_[1] = $octets if $check and !ref $check and !( $check & LEAVE_SRC() );
    return $string;
}
*bytes2str = \&decode;

sub from_to($$$;$) {
    my ( $string, $from, $to, $check ) = @@_;
    return undef unless defined $string;
    $check ||= 0;
    my $f = find_encoding($from);
    unless ( defined $f ) {
        require Carp;
        Carp::croak("Unknown encoding '$from'");
    }
    my $t = find_encoding($to);
    unless ( defined $t ) {
        require Carp;
        Carp::croak("Unknown encoding '$to'");
    }
    my $uni = $f->decode($string);
    $_[0] = $string = $t->encode( $uni, $check );
    return undef if ( $check && length($uni) );
    return defined( $_[0] ) ? length($string) : undef;
}

sub encode_utf8($) {
    my ($str) = @@_;
    utf8::encode($str);
    return $str;
}

sub decode_utf8($;$) {
    my ( $str, $check ) = @@_;
    return $str if is_utf8($str);
    if ($check) {
        return decode( "utf8", $str, $check );
    }
    else {
        return decode( "utf8", $str );
        return $str;
    }
}

predefine_encodings(1);

#
# This is to restore %Encoding if really needed;
#

sub predefine_encodings {
    require Encode::Encoding;
    no warnings 'redefine';
    my $use_xs = shift;
    if ($ON_EBCDIC) {

        # was in Encode::UTF_EBCDIC
        package Encode::UTF_EBCDIC;
        push @@Encode::UTF_EBCDIC::ISA, 'Encode::Encoding';
        *decode = sub {
            my ( $obj, $str, $chk ) = @@_;
            my $res = '';
            for ( my $i = 0 ; $i < length($str) ; $i++ ) {
                $res .=
                  chr(
                    utf8::unicode_to_native( ord( substr( $str, $i, 1 ) ) )
                  );
            }
            $_[1] = '' if $chk;
            return $res;
        };
        *encode = sub {
            my ( $obj, $str, $chk ) = @@_;
            my $res = '';
            for ( my $i = 0 ; $i < length($str) ; $i++ ) {
                $res .=
                  chr(
                    utf8::native_to_unicode( ord( substr( $str, $i, 1 ) ) )
                  );
            }
            $_[1] = '' if $chk;
            return $res;
        };
        $Encode::Encoding{Unicode} =
          bless { Name => "UTF_EBCDIC" } => "Encode::UTF_EBCDIC";
    }
    else {

        package Encode::Internal;
        push @@Encode::Internal::ISA, 'Encode::Encoding';
        *decode = sub {
            my ( $obj, $str, $chk ) = @@_;
            utf8::upgrade($str);
            $_[1] = '' if $chk;
            return $str;
        };
        *encode = \&decode;
        $Encode::Encoding{Unicode} =
          bless { Name => "Internal" } => "Encode::Internal";
    }

    {

        # was in Encode::utf8
        package Encode::utf8;
        push @@Encode::utf8::ISA, 'Encode::Encoding';

        #
        if ($use_xs) {
            Encode::DEBUG and warn __PACKAGE__, " XS on";
            *decode = \&decode_xs;
            *encode = \&encode_xs;
        }
        else {
            Encode::DEBUG and warn __PACKAGE__, " XS off";
            *decode = sub {
                my ( $obj, $octets, $chk ) = @@_;
                my $str = Encode::decode_utf8($octets);
                if ( defined $str ) {
                    $_[1] = '' if $chk;
                    return $str;
                }
                return undef;
            };
            *encode = sub {
                my ( $obj, $string, $chk ) = @@_;
                my $octets = Encode::encode_utf8($string);
                $_[1] = '' if $chk;
                return $octets;
            };
        }
        *cat_decode = sub {    # ($obj, $dst, $src, $pos, $trm, $chk)
                               # currently ignores $chk
            my ( $obj, undef, undef, $pos, $trm ) = @@_;
            my ( $rdst, $rsrc, $rpos ) = \@@_[ 1, 2, 3 ];
            use bytes;
            if ( ( my $npos = index( $$rsrc, $trm, $pos ) ) >= 0 ) {
                $$rdst .=
                  substr( $$rsrc, $pos, $npos - $pos + length($trm) );
                $$rpos = $npos + length($trm);
                return 1;
            }
            $$rdst .= substr( $$rsrc, $pos );
            $$rpos = length($$rsrc);
            return '';
        };
        $Encode::Encoding{utf8} =
          bless { Name => "utf8" } => "Encode::utf8";
        $Encode::Encoding{"utf-8-strict"} =
          bless { Name => "utf-8-strict", strict_utf8 => 1 } =>
          "Encode::utf8";
    }
}

1;

__END__

=head1 NAME

Encode - character encodings

=head1 SYNOPSIS

    use Encode;

=head2 Table of Contents

Encode consists of a collection of modules whose details are too big
to fit in one document.  This POD itself explains the top-level APIs
and general topics at a glance.  For other topics and more details,
see the PODs below:

  Name			        Description
  --------------------------------------------------------
  Encode::Alias         Alias definitions to encodings
  Encode::Encoding      Encode Implementation Base Class
  Encode::Supported     List of Supported Encodings
  Encode::CN            Simplified Chinese Encodings
  Encode::JP            Japanese Encodings
  Encode::KR            Korean Encodings
  Encode::TW            Traditional Chinese Encodings
  --------------------------------------------------------

=head1 DESCRIPTION

The C<Encode> module provides the interfaces between Perl's strings
and the rest of the system.  Perl strings are sequences of
B<characters>.

The repertoire of characters that Perl can represent is at least that
defined by the Unicode Consortium. On most platforms the ordinal
values of the characters (as returned by C<ord(ch)>) is the "Unicode
codepoint" for the character (the exceptions are those platforms where
the legacy encoding is some variant of EBCDIC rather than a super-set
of ASCII - see L<perlebcdic>).

Traditionally, computer data has been moved around in 8-bit chunks
often called "bytes". These chunks are also known as "octets" in
networking standards. Perl is widely used to manipulate data of many
types - not only strings of characters representing human or computer
languages but also "binary" data being the machine's representation of
numbers, pixels in an image - or just about anything.

When Perl is processing "binary data", the programmer wants Perl to
process "sequences of bytes". This is not a problem for Perl - as a
byte has 256 possible values, it easily fits in Perl's much larger
"logical character".

=head2 TERMINOLOGY

=over 2

=item *

I<character>: a character in the range 0..(2**32-1) (or more).
(What Perl's strings are made of.)

=item *

I<byte>: a character in the range 0..255
(A special case of a Perl character.)

=item *

I<octet>: 8 bits of data, with ordinal values 0..255
(Term for bytes passed to or from a non-Perl context, e.g. a disk file.)

=back

=head1 PERL ENCODING API

=over 2

=item $octets  = encode(ENCODING, $string [, CHECK])

Encodes a string from Perl's internal form into I<ENCODING> and returns
a sequence of octets.  ENCODING can be either a canonical name or
an alias.  For encoding names and aliases, see L</"Defining Aliases">.
For CHECK, see L</"Handling Malformed Data">.

For example, to convert a string from Perl's internal format to
iso-8859-1 (also known as Latin1),

  $octets = encode("iso-8859-1", $string);

B<CAVEAT>: When you run C<$octets = encode("utf8", $string)>, then
$octets B<may not be equal to> $string.  Though they both contain the
same data, the UTF8 flag for $octets is B<always> off.  When you
encode anything, UTF8 flag of the result is always off, even when it
contains completely valid utf8 string. See L</"The UTF8 flag"> below.

If the $string is C<undef> then C<undef> is returned.

=item $string = decode(ENCODING, $octets [, CHECK])

Decodes a sequence of octets assumed to be in I<ENCODING> into Perl's
internal form and returns the resulting string.  As in encode(),
ENCODING can be either a canonical name or an alias. For encoding names
and aliases, see L</"Defining Aliases">.  For CHECK, see
L</"Handling Malformed Data">.

For example, to convert ISO-8859-1 data to a string in Perl's internal format:

  $string = decode("iso-8859-1", $octets);

B<CAVEAT>: When you run C<$string = decode("utf8", $octets)>, then $string
B<may not be equal to> $octets.  Though they both contain the same data,
the UTF8 flag for $string is on unless $octets entirely consists of
ASCII data (or EBCDIC on EBCDIC machines).  See L</"The UTF8 flag">
below.

If the $string is C<undef> then C<undef> is returned.

=item [$obj =] find_encoding(ENCODING)

Returns the I<encoding object> corresponding to ENCODING.  Returns
undef if no matching ENCODING is find.

This object is what actually does the actual (en|de)coding.

  $utf8 = decode($name, $bytes);

is in fact

  $utf8 = do{
    $obj = find_encoding($name);
    croak qq(encoding "$name" not found) unless ref $obj;
    $obj->decode($bytes)
  };

with more error checking.

Therefore you can save time by reusing this object as follows;

  my $enc = find_encoding("iso-8859-1");
  while(<>){
     my $utf8 = $enc->decode($_);
     # and do someting with $utf8;
  }

Besides C<< ->decode >> and C<< ->encode >>, other methods are
available as well.  For instance, C<< -> name >> returns the canonical
name of the encoding object.

  find_encoding("latin1")->name; # iso-8859-1

See L<Encode::Encoding> for details.

=item [$length =] from_to($octets, FROM_ENC, TO_ENC [, CHECK])

Converts B<in-place> data between two encodings. The data in $octets
must be encoded as octets and not as characters in Perl's internal
format. For example, to convert ISO-8859-1 data to Microsoft's CP1250
encoding:

  from_to($octets, "iso-8859-1", "cp1250");

and to convert it back:

  from_to($octets, "cp1250", "iso-8859-1");

Note that because the conversion happens in place, the data to be
converted cannot be a string constant; it must be a scalar variable.

from_to() returns the length of the converted string in octets on
success, I<undef> on error.

B<CAVEAT>: The following operations look the same but are not quite so;

  from_to($data, "iso-8859-1", "utf8"); #1
  $data = decode("iso-8859-1", $data);  #2

Both #1 and #2 make $data consist of a completely valid UTF-8 string
but only #2 turns UTF8 flag on.  #1 is equivalent to

  $data = encode("utf8", decode("iso-8859-1", $data));

See L</"The UTF8 flag"> below.

Also note that

  from_to($octets, $from, $to, $check);

is equivalent to

  $octets = encode($to, decode($from, $octets), $check);

Yes, it does not respect the $check during decoding.  It is
deliberately done that way.  If you need minute control, C<decode>
then C<encode> as follows;

  $octets = encode($to, decode($from, $octets, $check_from), $check_to);

=item $octets = encode_utf8($string);

Equivalent to C<$octets = encode("utf8", $string);> The characters
that comprise $string are encoded in Perl's internal format and the
result is returned as a sequence of octets. All possible
characters have a UTF-8 representation so this function cannot fail.


=item $string = decode_utf8($octets [, CHECK]);

equivalent to C<$string = decode("utf8", $octets [, CHECK])>.
The sequence of octets represented by
$octets is decoded from UTF-8 into a sequence of logical
characters. Not all sequences of octets form valid UTF-8 encodings, so
it is possible for this call to fail.  For CHECK, see
L</"Handling Malformed Data">.

=back

=head2 Listing available encodings

  use Encode;
  @@list = Encode->encodings();

Returns a list of the canonical names of the available encodings that
are loaded.  To get a list of all available encodings including the
ones that are not loaded yet, say

  @@all_encodings = Encode->encodings(":all");

Or you can give the name of a specific module.

  @@with_jp = Encode->encodings("Encode::JP");

When "::" is not in the name, "Encode::" is assumed.

  @@ebcdic = Encode->encodings("EBCDIC");

To find out in detail which encodings are supported by this package,
see L<Encode::Supported>.

=head2 Defining Aliases

To add a new alias to a given encoding, use:

  use Encode;
  use Encode::Alias;
  define_alias(newName => ENCODING);

After that, newName can be used as an alias for ENCODING.
ENCODING may be either the name of an encoding or an
I<encoding object>

But before you do so, make sure the alias is nonexistent with
C<resolve_alias()>, which returns the canonical name thereof.
i.e.

  Encode::resolve_alias("latin1") eq "iso-8859-1" # true
  Encode::resolve_alias("iso-8859-12")   # false; nonexistent
  Encode::resolve_alias($name) eq $name  # true if $name is canonical

resolve_alias() does not need C<use Encode::Alias>; it can be
exported via C<use Encode qw(resolve_alias)>.

See L<Encode::Alias> for details.

=head2 Finding IANA Character Set Registry names

The canonical name of a given encoding does not necessarily agree with
IANA IANA Character Set Registry, commonly seen as C<< Content-Type:
text/plain; charset=I<whatever> >>.  For most cases canonical names
work but sometimes it does not (notably 'utf-8-strict').

Therefore as of Encode version 2.21, a new method C<mime_name()> is added.

  use Encode;
  my $enc = find_encoding('UTF-8');
  warn $enc->name;      # utf-8-strict
  warn $enc->mime_name; # UTF-8

See also:  L<Encode::Encoding>

=head1 Encoding via PerlIO

If your perl supports I<PerlIO> (which is the default), you can use a
PerlIO layer to decode and encode directly via a filehandle.  The
following two examples are totally identical in their functionality.

  # via PerlIO
  open my $in,  "<:encoding(shiftjis)", $infile  or die;
  open my $out, ">:encoding(euc-jp)",   $outfile or die;
  while(<$in>){ print $out $_; }

  # via from_to
  open my $in,  "<", $infile  or die;
  open my $out, ">", $outfile or die;
  while(<$in>){
    from_to($_, "shiftjis", "euc-jp", 1);
    print $out $_;
  }

Unfortunately, it may be that encodings are PerlIO-savvy.  You can check
if your encoding is supported by PerlIO by calling the C<perlio_ok>
method.

  Encode::perlio_ok("hz");             # False
  find_encoding("euc-cn")->perlio_ok;  # True where PerlIO is available

  use Encode qw(perlio_ok);            # exported upon request
  perlio_ok("euc-jp")

Fortunately, all encodings that come with Encode core are PerlIO-savvy
except for hz and ISO-2022-kr.  For gory details, see
L<Encode::Encoding> and L<Encode::PerlIO>.

=head1 Handling Malformed Data

The optional I<CHECK> argument tells Encode what to do when it
encounters malformed data.  Without CHECK, Encode::FB_DEFAULT ( == 0 )
is assumed.

As of version 2.12 Encode supports coderef values for CHECK.  See below.

=over 2

=item B<NOTE:> Not all encoding support this feature

Some encodings ignore I<CHECK> argument.  For example,
L<Encode::Unicode> ignores I<CHECK> and it always croaks on error.

=back

Now here is the list of I<CHECK> values available

=over 2

=item I<CHECK> = Encode::FB_DEFAULT ( == 0)

If I<CHECK> is 0, (en|de)code will put a I<substitution character> in
place of a malformed character.  When you encode, E<lt>subcharE<gt>
will be used.  When you decode the code point C<0xFFFD> is used.  If
the data is supposed to be UTF-8, an optional lexical warning
(category utf8) is given.

=item I<CHECK> = Encode::FB_CROAK ( == 1)

If I<CHECK> is 1, methods will die on error immediately with an error
message.  Therefore, when I<CHECK> is set to 1,  you should trap the
error with eval{} unless you really want to let it die.

=item I<CHECK> = Encode::FB_QUIET

If I<CHECK> is set to Encode::FB_QUIET, (en|de)code will immediately
return the portion of the data that has been processed so far when an
error occurs. The data argument will be overwritten with everything
after that point (that is, the unprocessed part of data).  This is
handy when you have to call decode repeatedly in the case where your
source data may contain partial multi-byte character sequences,
(i.e. you are reading with a fixed-width buffer). Here is a sample
code that does exactly this:

  my $buffer = ''; my $string = '';
  while(read $fh, $buffer, 256, length($buffer)){
    $string .= decode($encoding, $buffer, Encode::FB_QUIET);
    # $buffer now contains the unprocessed partial character
  }

=item I<CHECK> = Encode::FB_WARN

This is the same as above, except that it warns on error.  Handy when
you are debugging the mode above.

=item perlqq mode (I<CHECK> = Encode::FB_PERLQQ)

=item HTML charref mode (I<CHECK> = Encode::FB_HTMLCREF)

=item XML charref mode (I<CHECK> = Encode::FB_XMLCREF)

For encodings that are implemented by Encode::XS, CHECK ==
Encode::FB_PERLQQ turns (en|de)code into C<perlqq> fallback mode.

When you decode, C<\xI<HH>> will be inserted for a malformed character,
where I<HH> is the hex representation of the octet  that could not be
decoded to utf8.  And when you encode, C<\x{I<HHHH>}> will be inserted,
where I<HHHH> is the Unicode ID of the character that cannot be found
in the character repertoire of the encoding.

HTML/XML character reference modes are about the same, in place of
C<\x{I<HHHH>}>, HTML uses C<&#I<NNN>;> where I<NNN> is a decimal number and
XML uses C<&#xI<HHHH>;> where I<HHHH> is the hexadecimal number.

In Encode 2.10 or later, C<LEAVE_SRC> is also implied.

=item The bitmask

These modes are actually set via a bitmask.  Here is how the FB_XX
constants are laid out.  You can import the FB_XX constants via
C<use Encode qw(:fallbacks)>; you can import the generic bitmask
constants via C<use Encode qw(:fallback_all)>.

                     FB_DEFAULT FB_CROAK FB_QUIET FB_WARN  FB_PERLQQ
 DIE_ON_ERR    0x0001             X
 WARN_ON_ERR   0x0002                               X
 RETURN_ON_ERR 0x0004                      X        X
 LEAVE_SRC     0x0008                                        X
 PERLQQ        0x0100                                        X
 HTMLCREF      0x0200
 XMLCREF       0x0400

=back

=over 2

=item Encode::LEAVE_SRC

If the C<Encode::LEAVE_SRC> bit is not set, but I<CHECK> is, then the second
argument to C<encode()> or C<decode()> may be assigned to by the functions. If
you're not interested in this, then bitwise-or the bitmask with it.

=back

=head2 coderef for CHECK

As of Encode 2.12 CHECK can also be a code reference which takes the
ord value of unmapped caharacter as an argument and returns a string
that represents the fallback character.  For instance,

  $ascii = encode("ascii", $utf8, sub{ sprintf "<U+%04X>", shift });

Acts like FB_PERLQQ but E<lt>U+I<XXXX>E<gt> is used instead of
\x{I<XXXX>}.

=head1 Defining Encodings

To define a new encoding, use:

    use Encode qw(define_encoding);
    define_encoding($object, 'canonicalName' [, alias...]);

I<canonicalName> will be associated with I<$object>.  The object
should provide the interface described in L<Encode::Encoding>.
If more than two arguments are provided then additional
arguments are taken as aliases for I<$object>.

See L<Encode::Encoding> for more details.

=head1 The UTF8 flag

Before the introduction of Unicode support in perl, The C<eq> operator
just compared the strings represented by two scalars. Beginning with
perl 5.8, C<eq> compares two strings with simultaneous consideration of
I<the UTF8 flag>. To explain why we made it so, I will quote page 402 of
C<Programming Perl, 3rd ed.>

=over 2

=item Goal #1:

Old byte-oriented programs should not spontaneously break on the old
byte-oriented data they used to work on.

=item Goal #2:

Old byte-oriented programs should magically start working on the new
character-oriented data when appropriate.

=item Goal #3:

Programs should run just as fast in the new character-oriented mode
as in the old byte-oriented mode.

=item Goal #4:

Perl should remain one language, rather than forking into a
byte-oriented Perl and a character-oriented Perl.

=back

Back when C<Programming Perl, 3rd ed.> was written, not even Perl 5.6.0
was born and many features documented in the book remained
unimplemented for a long time.  Perl 5.8 corrected this and the introduction
of the UTF8 flag is one of them.  You can think of this perl notion as of a
byte-oriented mode (UTF8 flag off) and a character-oriented mode (UTF8
flag on).

Here is how Encode takes care of the UTF8 flag.

=over 2

=item *

When you encode, the resulting UTF8 flag is always off.

=item *

When you decode, the resulting UTF8 flag is on unless you can
unambiguously represent data.  Here is the definition of
dis-ambiguity.

After C<$utf8 = decode('foo', $octet);>,

  When $octet is...   The UTF8 flag in $utf8 is
  ---------------------------------------------
  In ASCII only (or EBCDIC only)            OFF
  In ISO-8859-1                              ON
  In any other Encoding                      ON
  ---------------------------------------------

As you see, there is one exception, In ASCII.  That way you can assume
Goal #1.  And with Encode Goal #2 is assumed but you still have to be
careful in such cases mentioned in B<CAVEAT> paragraphs.

This UTF8 flag is not visible in perl scripts, exactly for the same
reason you cannot (or you I<don't have to>) see if a scalar contains a
string, integer, or floating point number.   But you can still peek
and poke these if you will.  See the section below.

=back

=head2 Messing with Perl's Internals

The following API uses parts of Perl's internals in the current
implementation.  As such, they are efficient but may change.

=over 2

=item is_utf8(STRING [, CHECK])

[INTERNAL] Tests whether the UTF8 flag is turned on in the STRING.
If CHECK is true, also checks the data in STRING for being well-formed
UTF-8.  Returns true if successful, false otherwise.

As of perl 5.8.1, L<utf8> also has utf8::is_utf8().

=item _utf8_on(STRING)

[INTERNAL] Turns on the UTF8 flag in STRING.  The data in STRING is
B<not> checked for being well-formed UTF-8.  Do not use unless you
B<know> that the STRING is well-formed UTF-8.  Returns the previous
state of the UTF8 flag (so please don't treat the return value as
indicating success or failure), or C<undef> if STRING is not a string.

This function does not work on tainted values.

=item _utf8_off(STRING)

[INTERNAL] Turns off the UTF8 flag in STRING.  Do not use frivolously.
Returns the previous state of the UTF8 flag (so please don't treat the
return value as indicating success or failure), or C<undef> if STRING is
not a string.

This function does not work on tainted values.

=back

=head1 UTF-8 vs. utf8 vs. UTF8

  ....We now view strings not as sequences of bytes, but as sequences
  of numbers in the range 0 .. 2**32-1 (or in the case of 64-bit
  computers, 0 .. 2**64-1) -- Programming Perl, 3rd ed.

That has been the perl's notion of UTF-8 but official UTF-8 is more
strict; Its ranges is much narrower (0 .. 10FFFF), some sequences are
not allowed (i.e. Those used in the surrogate pair, 0xFFFE, et al).

Now that is overruled by Larry Wall himself.

  From: Larry Wall <larry@@wall.org>
  Date: December 04, 2004 11:51:58 JST
  To: perl-unicode@@perl.org
  Subject: Re: Make Encode.pm support the real UTF-8
  Message-Id: <20041204025158.GA28754@@wall.org>
  
  On Fri, Dec 03, 2004 at 10:12:12PM +0000, Tim Bunce wrote:
  : I've no problem with 'utf8' being perl's unrestricted uft8 encoding,
  : but "UTF-8" is the name of the standard and should give the
  : corresponding behaviour.
  
  For what it's worth, that's how I've always kept them straight in my
  head.
  
  Also for what it's worth, Perl 6 will mostly default to strict but
  make it easy to switch back to lax.
  
  Larry

Do you copy?  As of Perl 5.8.7, B<UTF-8> means strict, official UTF-8
while B<utf8> means liberal, lax, version thereof.  And Encode version
2.10 or later thus groks the difference between C<UTF-8> and C<utf8>.

  encode("utf8",  "\x{FFFF_FFFF}", 1); # okay
  encode("UTF-8", "\x{FFFF_FFFF}", 1); # croaks

C<UTF-8> in Encode is actually a canonical name for C<utf-8-strict>.
Yes, the hyphen between "UTF" and "8" is important.  Without it Encode
goes "liberal"

  find_encoding("UTF-8")->name # is 'utf-8-strict'
  find_encoding("utf-8")->name # ditto. names are case insensitive
  find_encoding("utf_8")->name  # ditto. "_" are treated as "-"
  find_encoding("UTF8")->name  # is 'utf8'.

The UTF8 flag is internally called UTF8, without a hyphen. It indicates
whether a string is internally encoded as utf8, also without a hypen.

=head1 SEE ALSO

L<Encode::Encoding>,
L<Encode::Supported>,
L<Encode::PerlIO>,
L<encoding>,
L<perlebcdic>,
L<perlfunc/open>,
L<perlunicode>, L<perluniintro>, L<perlunifaq>, L<perlunitut>
L<utf8>,
the Perl Unicode Mailing List E<lt>perl-unicode@@perl.orgE<gt>

=head1 MAINTAINER

This project was originated by Nick Ing-Simmons and later maintained
by Dan Kogai E<lt>dankogai@@dan.co.jpE<gt>.  See AUTHORS for a full
list of people involved.  For any questions, use
E<lt>perl-unicode@@perl.orgE<gt> so we can all share.

While Dan Kogai retains the copyright as a maintainer, the credit
should go to all those involoved.  See AUTHORS for those submitted
codes.

=head1 COPYRIGHT

Copyright 2002-2006 Dan Kogai E<lt>dankogai@@dan.co.jpE<gt>

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
@


1.2
log
@Fix a typo
@
text
@@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
# $Id: Encode.pm,v 1.75 2002/06/01 18:07:42 dankogai Exp $
d6 3
a8 2
our $VERSION = do { my @@r = (q$Revision: 1.75 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };
our $DEBUG = 0;
d10 1
a10 1
XSLoader::load(__PACKAGE__, $VERSION);
d18 2
a19 2
  decode  decode_utf8  encode  encode_utf8
  encodings  find_encoding
d21 12
a32 11

our @@FB_FLAGS  = qw(DIE_ON_ERR WARN_ON_ERR RETURN_ON_ERR LEAVE_SRC
		    PERLQQ HTMLCREF XMLCREF);
our @@FB_CONSTS = qw(FB_DEFAULT FB_CROAK FB_QUIET FB_WARN
		    FB_PERLQQ FB_HTMLCREF FB_XMLCREF);

our @@EXPORT_OK =
    (
     qw(
       _utf8_off _utf8_on define_encoding from_to is_16bit is_8bit
       is_utf8 perlio_ok resolve_alias utf8_downgrade utf8_upgrade
d34 2
a35 2
     @@FB_FLAGS, @@FB_CONSTS,
    );
d37 6
a42 6
our %EXPORT_TAGS =
    (
     all          =>  [ @@EXPORT, @@EXPORT_OK ],
     fallbacks    =>  [ @@FB_CONSTS ],
     fallback_all =>  [ @@FB_CONSTS, @@FB_FLAGS ],
    );
d46 1
a46 1
our $ON_EBCDIC = (ord("A") == 193);
d54 8
a61 1
eval { require Encode::ConfigLocal };
d63 1
a63 2
sub encodings
{
d66 14
a79 14
    if (@@_ and $_[0] eq ":all"){
	%enc = ( %Encoding, %ExtModule );
    }else{
	%enc = %Encoding;
	for my $mod (map {m/::/o ? $_ : "Encode::$_" } @@_){
	    $DEBUG and warn $mod;
	    for my $enc (keys %ExtModule){
		$ExtModule{$enc} eq $mod and $enc{$enc} = $mod;
	    }
	}
    }
    return
	sort { lc $a cmp lc $b }
             grep {!/^(?:Internal|Unicode|Guess)$/o} keys %enc;
d82 2
a83 2
sub perlio_ok{
    my $obj = ref($_[0]) ? $_[0] : find_encoding($_[0]);
d85 1
a85 1
    return 0; # safety net
d88 1
a88 2
sub define_encoding
{
d93 4
a96 4
    define_alias($lc => $obj) unless $lc eq $name;
    while (@@_){
	my $alias = shift;
	define_alias($alias, $obj);
d101 2
a102 3
sub getEncoding
{
    my ($class, $name, $skip_external) = @@_;
d104 1
a104 1
    ref($name) && $name->can('new_sequence') and return $name;
d114 7
a120 7
    unless ($skip_external)
    {
	if (my $mod = $ExtModule{$name} || $ExtModule{$lc}){
	    $mod =~ s,::,/,g ; $mod .= '.pm';
	    eval{ require $mod; };
	    exists $Encoding{$name} and return $Encoding{$name};
	}
d125 3
a127 4
sub find_encoding
{
    my ($name, $skip_external) = @@_;
    return __PACKAGE__->getEncoding($name,$skip_external);
d130 1
a130 1
sub resolve_alias {
d136 17
a152 4
sub encode($$;$)
{
    my ($name, $string, $check) = @@_;
    $check ||=0;
d154 3
a156 3
    unless(defined $enc){
	require Carp;
	Carp::croak("Unknown encoding '$name'");
d158 2
a159 2
    my $octets = $enc->encode($string,$check);
    return undef if ($check && length($string));
d162 1
d164 5
a168 4
sub decode($$;$)
{
    my ($name,$octets,$check) = @@_;
    $check ||=0;
d170 3
a172 3
    unless(defined $enc){
	require Carp;
	Carp::croak("Unknown encoding '$name'");
d174 2
a175 2
    my $string = $enc->decode($octets,$check);
    $_[1] = $octets if $check;
d178 1
d180 4
a183 4
sub from_to($$$;$)
{
    my ($string,$from,$to,$check) = @@_;
    $check ||=0;
d185 3
a187 3
    unless (defined $f){
	require Carp;
	Carp::croak("Unknown encoding '$from'");
d190 8
a197 9
    unless (defined $t){
	require Carp;
	Carp::croak("Unknown encoding '$to'");
    }
    my $uni = $f->decode($string,$check);
    return undef if ($check && length($string));
    $string =  $t->encode($uni,$check);
    return undef if ($check && length($uni));
    return defined($_[0] = $string) ? length($string) : undef ;
d200 1
a200 2
sub encode_utf8($)
{
d206 10
a215 5
sub decode_utf8($)
{
    my ($str) = @@_;
    return undef unless utf8::decode($str);
    return $str;
d218 1
a218 1
predefine_encodings();
d224 4
a227 2
sub predefine_encodings{
    use Encode::Encoding;
d229 44
a272 37
	# was in Encode::UTF_EBCDIC
	package Encode::UTF_EBCDIC;
	push @@Encode::UTF_EBCDIC::ISA, 'Encode::Encoding';
	*decode = sub{
	    my ($obj,$str,$chk) = @@_;
	    my $res = '';
	    for (my $i = 0; $i < length($str); $i++) {
		$res .=
		    chr(utf8::unicode_to_native(ord(substr($str,$i,1))));
	    }
	    $_[1] = '' if $chk;
	    return $res;
	};
	*encode = sub{
	    my ($obj,$str,$chk) = @@_;
	    my $res = '';
	    for (my $i = 0; $i < length($str); $i++) {
		$res .=
		    chr(utf8::native_to_unicode(ord(substr($str,$i,1))));
	    }
	    $_[1] = '' if $chk;
	    return $res;
	};
	$Encode::Encoding{Unicode} =
	    bless {Name => "UTF_EBCDIC"} => "Encode::UTF_EBCDIC";
    } else {
	package Encode::Internal;
	push @@Encode::Internal::ISA, 'Encode::Encoding';
	*decode = sub{
	    my ($obj,$str,$chk) = @@_;
	    utf8::upgrade($str);
	    $_[1] = '' if $chk;
	    return $str;
	};
	*encode = \&decode;
	$Encode::Encoding{Unicode} =
	    bless {Name => "Internal"} => "Encode::Internal";
d276 49
a324 20
	# was in Encode::utf8
	package Encode::utf8;
	push @@Encode::utf8::ISA, 'Encode::Encoding';
	*decode = sub{
	    my ($obj,$octets,$chk) = @@_;
	    my $str = Encode::decode_utf8($octets);
	    if (defined $str) {
		$_[1] = '' if $chk;
		return $str;
	    }
	    return undef;
	};
	*encode = sub {
	    my ($obj,$string,$chk) = @@_;
	    my $octets = Encode::encode_utf8($string);
	    $_[1] = '' if $chk;
	    return $octets;
	};
	$Encode::Encoding{utf8} =
	    bless {Name => "utf8"} => "Encode::utf8";
d420 7
a426 9
B<CAVEAT>: When you run C<$octets = encode("utf8", $string)>, then $octets
B<may not be equal to> $string.  Though they both contain the same data, the utf8 flag
for $octets is B<always> off.  When you encode anything, utf8 flag of
the result is always off, even when it contains completely valid utf8
string. See L</"The UTF-8 flag"> below.

encode($valid_encoding, undef) is harmless but warns you for 
C<Use of uninitialized value in subroutine entry>. 
encode($valid_encoding, '') is harmless and warnless.
d442 2
a443 2
the utf8 flag for $string is on unless $octets entirely consists of
ASCII data (or EBCDIC on EBCDIC machines).  See L</"The UTF-8 flag">
d446 36
a481 3
decode($valid_encoding, undef) is harmless but warns you for 
C<Use of uninitialized value in subroutine entry>. 
decode($valid_encoding, '') is harmless and warnless.
d487 2
a488 1
format. For example, to convert ISO-8859-1 data to Microsoft's CP1250 encoding:
d499 2
a500 2
from_to() returns the length of the converted string in octets on success, undef
otherwise.
d508 1
a508 1
but only #2 turns utf8 flag on.  #1 is equivalent to
d512 15
a526 1
See L</"The UTF-8 flag"> below.
d594 16
d612 3
a614 3
If your perl supports I<PerlIO> (which is the default), you can use a PerlIO layer to decode
and encode directly via a filehandle.  The following two examples
are totally identical in their functionality.
d640 2
a641 1
except for hz and ISO-2022-kr.  For gory details, see L<Encode::Encoding> and L<Encode::PerlIO>.
d645 6
d653 10
a662 3
The I<CHECK> argument is used as follows.  When you omit it,
the behaviour is the same as if you had passed a value of 0 for
I<CHECK>.
d666 4
a669 4
If I<CHECK> is 0, (en|de)code will put a I<substitution character>
in place of a malformed character.  For UCM-based encodings,
E<lt>subcharE<gt> will be used.  For Unicode, the code point C<0xFFFD> is used.
If the data is supposed to be UTF-8, an optional lexical warning
d676 1
a676 1
fatal error with eval{} unless you really want to let it die on error.
d681 12
a692 14
return the portion of the data that has been processed so far when
an error occurs. The data argument will be overwritten with
everything after that point (that is, the unprocessed part of data).
This is handy when you have to call decode repeatedly in the case
where your source data may contain partial multi-byte character
sequences, for example because you are reading with a fixed-width
buffer. Here is some sample code that does exactly this:

  my $data = ''; my $utf8 = '';
  while(defined(read $fh, $buffer, 256)){
    # buffer may end in a partial character so we append
    $data .= $buffer;
    $utf8 .= decode($encoding, $data, Encode::FB_QUIET);
    # $data now contains the unprocessed partial character
d716 4
a719 2
C<\x{I<HHHH>}>, HTML uses C<&#I<NNNN>>; where I<NNNN> is a decimal digit and
XML uses C<&#xI<HHHH>>; where I<HHHH> is the hexadecimal digit.
d732 1
a732 1
 LEAVE_SRC     0x0008
d737 17
a753 1
=head2 Unimplemented fallback schemes
d755 1
a755 2
In the future, you will be able to use a code reference to a callback
function for the value of I<CHECK> but its API is still undecided.
d757 2
a758 1
The fallback scheme does not work on EBCDIC platforms.
d774 1
a774 1
=head1 The UTF-8 flag
d776 1
a776 1
Before the introduction of utf8 support in perl, The C<eq> operator
d778 3
a780 3
perl 5.8, C<eq> compares two strings with simultaneous consideration
of I<the utf8 flag>. To explain why we made it so, I will quote page
402 of C<Programming Perl, 3rd ed.>
d809 2
a810 2
of the UTF-8 flag is one of them.  You can think of this perl notion as of a
byte-oriented mode (utf8 flag off) and a character-oriented mode (utf8
d813 1
a813 1
Here is how Encode takes care of the utf8 flag.
d819 1
a819 1
When you encode, the resulting utf8 flag is always off.
d821 1
a821 1
=item
d823 1
a823 1
When you decode, the resulting utf8 flag is on unless you can
d829 1
a829 1
  When $octet is...   The utf8 flag in $utf8 is
d836 1
a836 1
As you see, there is one exception, In ASCII.  That way you can assue
d840 1
a840 1
This utf8 flag is not visible in perl scripts, exactly for the same
d856 1
a856 1
[INTERNAL] Tests whether the UTF-8 flag is turned on in the STRING.
d860 2
d864 1
a864 1
[INTERNAL] Turns on the UTF-8 flag in STRING.  The data in STRING is
d867 1
a867 1
state of the UTF-8 flag (so please don't treat the return value as
d870 2
d874 2
a875 2
[INTERNAL] Turns off the UTF-8 flag in STRING.  Do not use frivolously.
Returns the previous state of the UTF-8 flag (so please don't treat the
d879 2
d883 50
d941 1
a941 1
L<perlunicode>,
d951 11
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d2 1
a2 1
# $Id: Encode.pm,v 1.98 2003/08/20 11:16:34 dankogai Exp dankogai $
d6 2
a7 2
our $VERSION = do { my @@r = (q$Revision: 1.9801 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };
sub DEBUG () { 0 }
d18 1
a18 1
  encodings  find_encoding clone_encoding
d63 1
a63 1
	    DEBUG and warn $mod;
d98 1
a98 1
    ref($name) && $name->can('renew') and return $name;
d119 1
a119 1
sub find_encoding($;$)
d125 1
a125 1
sub resolve_alias($){
a130 8
sub clone_encoding($){
    my $obj = find_encoding(shift);
    ref $obj or return;
    eval { require Storable };
    $@@ and return;
    return Storable::dclone($obj);
}

a133 1
    return undef unless defined $string;
d141 1
a141 1
    $_[1] = $string if $check;
a147 1
    return undef unless defined $octets;
a161 1
    return undef unless defined $string;
d194 1
a194 1
predefine_encodings(1);
a201 2
    no warnings 'redefine';
    my $use_xs = shift;
d246 4
a249 19
	# 
	if ($use_xs){
	    Encode::DEBUG and warn __PACKAGE__, " XS on";
	    *decode = \&decode_xs;
	    *encode = \&encode_xs;
	}else{
	    Encode::DEBUG and warn __PACKAGE__, " XS off";
	    *decode = sub{
		my ($obj,$octets,$chk) = @@_;
		my $str = Encode::decode_utf8($octets);
		if (defined $str) {
		    $_[1] = '' if $chk;
		    return $str;
		}
		return undef;
	    };
	    *encode = sub {
		my ($obj,$string,$chk) = @@_;
		my $octets = Encode::encode_utf8($string);
d251 1
a251 11
		return $octets;
	    };
	}
	*cat_decode = sub{ # ($obj, $dst, $src, $pos, $trm, $chk)
	    my ($obj, undef, undef, $pos, $trm) = @@_; # currently ignores $chk
	    my ($rdst, $rsrc, $rpos) = \@@_[1,2,3];
	    use bytes;
	    if ((my $npos = index($$rsrc, $trm, $pos)) >= 0) {
		$$rdst .= substr($$rsrc, $pos, $npos - $pos + length($trm));
		$$rpos = $npos + length($trm);
		return 1;
d253 7
a259 3
	    $$rdst .= substr($$rsrc, $pos);
	    $$rpos = length($$rsrc);
	    return '';
d520 2
a525 2
=over 2

a598 2
=back

d667 1
a667 1
=item *
a704 2

As of perl 5.8.1, L<utf8> also has utf8::is_utif8().
@


1.1.1.3
log
@perl 5.8.3 from CPAN
@
text
@d2 1
a2 1
# $Id: Encode.pm,v 1.99 2003/12/29 02:47:16 dankogai Exp dankogai $
d6 1
a6 1
our $VERSION = do { my @@r = (q$Revision: 1.99 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };
d198 1
a198 1
sub decode_utf8($;$)
d200 3
a202 7
    my ($str, $check) = @@_;
    if ($check){
	return decode("utf8", $str, $check);
    }else{
	return undef unless utf8::decode($str);
	return $str;
    }
@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@d2 1
a2 1
# $Id: Encode.pm,v 2.1 2004/05/25 16:23:30 dankogai Exp $
d6 1
a6 1
our $VERSION = do { my @@r = (q$Revision: 2.1 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };
d746 1
a746 1
As of perl 5.8.1, L<utf8> also has utf8::is_utf8().
@


1.1.1.5
log
@perl 5.8.6 from CPAN
@
text
@d2 1
a2 1
# $Id: Encode.pm,v 2.8 2004/10/24 12:32:06 dankogai Exp $
d6 1
a6 1
our $VERSION = do { my @@r = (q$Revision: 2.8 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @@r };
a142 1
    return undef if ref $string;
a157 1
    return undef if ref $octets;
d432 1
a432 2
format. For example, to convert ISO-8859-1 data to Microsoft's CP1250
encoding:
d443 2
a444 2
from_to() returns the length of the converted string in octets on
success, I<undef> on error.
d554 1
a554 2
except for hz and ISO-2022-kr.  For gory details, see
L<Encode::Encoding> and L<Encode::PerlIO>.
d558 3
a560 13
The optional I<CHECK> argument is used as follows.  When you omit it,
Encode::FB_DEFAULT ( == 0 ) is assumed.

=over 2

=item B<NOTE:> Not all encoding suppport this feature

Some encodings ignore I<CHECK> argument.  For example,
L<Encode::Unicode> ignores I<CHECK> and it always croaks on error.

=back

Now here is the list of I<CHECK> values available
d566 5
a570 5
If I<CHECK> is 0, (en|de)code will put a I<substitution character> in
place of a malformed character.  When you encode to UCM-based encodings,
E<lt>subcharE<gt> will be used.  When you decode from UCM-based
encodings, the code point C<0xFFFD> is used.  If the data is supposed
to be UTF-8, an optional lexical warning (category utf8) is given.
d576 1
a576 1
error with eval{} unless you really want to let it die.
d581 7
a587 7
return the portion of the data that has been processed so far when an
error occurs. The data argument will be overwritten with everything
after that point (that is, the unprocessed part of data).  This is
handy when you have to call decode repeatedly in the case where your
source data may contain partial multi-byte character sequences,
(i.e. you are reading with a fixed-width buffer). Here is a sample
code that does exactly this:
d618 2
a619 2
C<\x{I<HHHH>}>, HTML uses C<&#I<NNNN>;> where I<NNNN> is a decimal digit and
XML uses C<&#xI<HHHH>;> where I<HHHH> is the hexadecimal digit.
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d2 1
a2 1
# $Id: Encode.pm,v 2.12 2005/09/08 14:17:17 dankogai Exp dankogai $
d6 1
a6 1
our $VERSION = sprintf "%d.%02d", q$Revision: 2.12 $ =~ /(\d+)/g;
d22 1
a22 1
		    PERLQQ HTMLCREF XMLCREF STOP_AT_PARTIAL);
d143 1
a143 1
    $string .= '' if ref $string; # stringify;
d151 1
a151 1
    $_[1] = $string if $check and !($check & LEAVE_SRC());
d159 1
a159 1
    $octets .= '' if ref $octets;
d167 1
a167 1
    $_[1] = $octets if $check and !($check & LEAVE_SRC());
d206 1
a206 1
	return decode("utf8", $str);
a302 2
	$Encode::Encoding{"utf-8-strict"} =
	    bless {Name => "utf-8-strict", strict_utf8 => 1 } => "Encode::utf8";
d404 3
a406 1
If the $string is C<undef> then C<undef> is returned.
d426 3
a428 1
If the $string is C<undef> then C<undef> is returned.
d562 2
a563 5
The optional I<CHECK> argument tells Encode what to do when it
encounters malformed data.  Without CHECK, Encode::FB_DEFAULT ( == 0 )
is assumed.

As of version 2.12 Encode supports coderef values for CHECK.  See below.
d567 1
a567 1
=item B<NOTE:> Not all encoding support this feature
d581 4
a584 4
place of a malformed character.  When you encode, E<lt>subcharE<gt>
will be used.  When you decode the code point C<0xFFFD> is used.  If
the data is supposed to be UTF-8, an optional lexical warning
(category utf8) is given.
d603 6
a608 4
  my $buffer = ''; my $string = '';
  while(read $fh, $buffer, 256, length($buffer)){
    $string .= decode($encoding, $buffer, Encode::FB_QUIET);
    # $buffer now contains the unprocessed partial character
d632 2
a633 4
C<\x{I<HHHH>}>, HTML uses C<&#I<NNN>;> where I<NNN> is a decimal number and
XML uses C<&#xI<HHHH>;> where I<HHHH> is the hexadecimal number.

In Encode 2.10 or later, C<LEAVE_SRC> is also implied.
d646 1
a646 1
 LEAVE_SRC     0x0008                                        X
d653 1
a653 5
=head2 coderef for CHECK

As of Encode 2.12 CHECK can also be a code reference which takes the
ord value of unmapped caharacter as an argument and returns a string
that represents the fallback character.  For instance,
d655 2
a656 1
  $ascii = encode("ascii", $utf8, sub{ sprintf "<U+%04X>", shift });
d658 1
a658 2
Acts like FB_PERLQQ but E<lt>U+I<XXXX>E<gt> is used instead of
\x{I<XXXX>}.
d736 1
a736 1
As you see, there is one exception, In ASCII.  That way you can assume
a777 48

=head1 UTF-8 vs. utf8

  ....We now view strings not as sequences of bytes, but as sequences
  of numbers in the range 0 .. 2**32-1 (or in the case of 64-bit
  computers, 0 .. 2**64-1) -- Programming Perl, 3rd ed.

That has been the perl's notion of UTF-8 but official UTF-8 is more
strict; Its ranges is much narrower (0 .. 10FFFF), some sequences are
not allowed (i.e. Those used in the surrogate pair, 0xFFFE, et al).

Now that is overruled by Larry Wall himself.

  From: Larry Wall <larry@@wall.org>
  Date: December 04, 2004 11:51:58 JST
  To: perl-unicode@@perl.org
  Subject: Re: Make Encode.pm support the real UTF-8
  Message-Id: <20041204025158.GA28754@@wall.org>
  
  On Fri, Dec 03, 2004 at 10:12:12PM +0000, Tim Bunce wrote:
  : I've no problem with 'utf8' being perl's unrestricted uft8 encoding,
  : but "UTF-8" is the name of the standard and should give the
  : corresponding behaviour.
  
  For what it's worth, that's how I've always kept them straight in my
  head.
  
  Also for what it's worth, Perl 6 will mostly default to strict but
  make it easy to switch back to lax.
  
  Larry

Do you copy?  As of Perl 5.8.7, B<UTF-8> means strict, official UTF-8
while B<utf8> means liberal, lax, version thereof.  And Encode version
2.10 or later thus groks the difference between C<UTF-8> and C"utf8".

  encode("utf8",  "\x{FFFF_FFFF}", 1); # okay
  encode("UTF-8", "\x{FFFF_FFFF}", 1); # croaks

C<UTF-8> in Encode is actually a canonical name for C<utf-8-strict>.
Yes, the hyphen between "UTF" and "8" is important.  Without it Encode
goes "liberal"

  find_encoding("UTF-8")->name # is 'utf-8-strict'
  find_encoding("utf-8")->name # ditto. names are case insensitive
  find_encoding("utf8")->name  # ditto. "_" are treated as "-"
  find_encoding("UTF8")->name  # is 'utf8'.

@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d2 1
a2 1
# $Id: Encode.pm,v 2.23 2007/05/29 18:15:32 dankogai Exp dankogai $
d6 1
a6 2
use warnings;
our $VERSION = sprintf "%d.%02d", q$Revision: 2.23 $ =~ /(\d+)/g;
d9 1
a9 1
XSLoader::load( __PACKAGE__, $VERSION );
d17 1
a17 1
  decode  decode_utf8  encode  encode_utf8 str2bytes bytes2str
d20 11
a30 12
our @@FB_FLAGS = qw(
  DIE_ON_ERR WARN_ON_ERR RETURN_ON_ERR LEAVE_SRC
  PERLQQ HTMLCREF XMLCREF STOP_AT_PARTIAL
);
our @@FB_CONSTS = qw(
  FB_DEFAULT FB_CROAK FB_QUIET FB_WARN
  FB_PERLQQ FB_HTMLCREF FB_XMLCREF
);
our @@EXPORT_OK = (
    qw(
      _utf8_off _utf8_on define_encoding from_to is_16bit is_8bit
      is_utf8 perlio_ok resolve_alias utf8_downgrade utf8_upgrade
d32 2
a33 2
    @@FB_FLAGS, @@FB_CONSTS,
);
d35 6
a40 5
our %EXPORT_TAGS = (
    all          => [ @@EXPORT,    @@EXPORT_OK ],
    fallbacks    => [@@FB_CONSTS],
    fallback_all => [ @@FB_CONSTS, @@FB_FLAGS ],
);
d44 1
a44 1
our $ON_EBCDIC = ( ord("A") == 193 );
d54 2
a55 1
sub encodings {
d58 14
a71 14
    if ( @@_ and $_[0] eq ":all" ) {
        %enc = ( %Encoding, %ExtModule );
    }
    else {
        %enc = %Encoding;
        for my $mod ( map { m/::/o ? $_ : "Encode::$_" } @@_ ) {
            DEBUG and warn $mod;
            for my $enc ( keys %ExtModule ) {
                $ExtModule{$enc} eq $mod and $enc{$enc} = $mod;
            }
        }
    }
    return sort { lc $a cmp lc $b }
      grep      { !/^(?:Internal|Unicode|Guess)$/o } keys %enc;
d74 2
a75 2
sub perlio_ok {
    my $obj = ref( $_[0] ) ? $_[0] : find_encoding( $_[0] );
d77 1
a77 1
    return 0;    # safety net
d80 2
a81 1
sub define_encoding {
d86 4
a89 4
    define_alias( $lc => $obj ) unless $lc eq $name;
    while (@@_) {
        my $alias = shift;
        define_alias( $alias, $obj );
d94 3
a96 2
sub getEncoding {
    my ( $class, $name, $skip_external ) = @@_;
d108 7
a114 7
    unless ($skip_external) {
        if ( my $mod = $ExtModule{$name} || $ExtModule{$lc} ) {
            $mod =~ s,::,/,g;
            $mod .= '.pm';
            eval { require $mod; };
            exists $Encoding{$name} and return $Encoding{$name};
        }
d119 4
a122 3
sub find_encoding($;$) {
    my ( $name, $skip_external ) = @@_;
    return __PACKAGE__->getEncoding( $name, $skip_external );
d125 1
a125 1
sub resolve_alias($) {
d131 1
a131 1
sub clone_encoding($) {
d139 3
a141 2
sub encode($$;$) {
    my ( $name, $string, $check ) = @@_;
d143 2
a144 2
    $string .= '' if ref $string;    # stringify;
    $check ||= 0;
d146 3
a148 3
    unless ( defined $enc ) {
        require Carp;
        Carp::croak("Unknown encoding '$name'");
d150 2
a151 2
    my $octets = $enc->encode( $string, $check );
    $_[1] = $string if $check and !ref $check and !( $check & LEAVE_SRC() );
a153 1
*str2bytes = \&encode;
d155 3
a157 2
sub decode($$;$) {
    my ( $name, $octets, $check ) = @@_;
d160 1
a160 1
    $check ||= 0;
d162 3
a164 3
    unless ( defined $enc ) {
        require Carp;
        Carp::croak("Unknown encoding '$name'");
d166 2
a167 2
    my $string = $enc->decode( $octets, $check );
    $_[1] = $octets if $check and !ref $check and !( $check & LEAVE_SRC() );
a169 1
*bytes2str = \&decode;
d171 3
a173 2
sub from_to($$$;$) {
    my ( $string, $from, $to, $check ) = @@_;
d175 1
a175 1
    $check ||= 0;
d177 3
a179 3
    unless ( defined $f ) {
        require Carp;
        Carp::croak("Unknown encoding '$from'");
d182 9
a190 8
    unless ( defined $t ) {
        require Carp;
        Carp::croak("Unknown encoding '$to'");
    }
    my $uni = $f->decode($string);
    $_[0] = $string = $t->encode( $uni, $check );
    return undef if ( $check && length($uni) );
    return defined( $_[0] ) ? length($string) : undef;
d193 2
a194 1
sub encode_utf8($) {
d200 8
a207 9
sub decode_utf8($;$) {
    my ( $str, $check ) = @@_;
    return $str if is_utf8($str);
    if ($check) {
        return decode( "utf8", $str, $check );
    }
    else {
        return decode( "utf8", $str );
        return $str;
d217 2
a218 2
sub predefine_encodings {
    require Encode::Encoding;
d222 37
a258 44

        # was in Encode::UTF_EBCDIC
        package Encode::UTF_EBCDIC;
        push @@Encode::UTF_EBCDIC::ISA, 'Encode::Encoding';
        *decode = sub {
            my ( $obj, $str, $chk ) = @@_;
            my $res = '';
            for ( my $i = 0 ; $i < length($str) ; $i++ ) {
                $res .=
                  chr(
                    utf8::unicode_to_native( ord( substr( $str, $i, 1 ) ) )
                  );
            }
            $_[1] = '' if $chk;
            return $res;
        };
        *encode = sub {
            my ( $obj, $str, $chk ) = @@_;
            my $res = '';
            for ( my $i = 0 ; $i < length($str) ; $i++ ) {
                $res .=
                  chr(
                    utf8::native_to_unicode( ord( substr( $str, $i, 1 ) ) )
                  );
            }
            $_[1] = '' if $chk;
            return $res;
        };
        $Encode::Encoding{Unicode} =
          bless { Name => "UTF_EBCDIC" } => "Encode::UTF_EBCDIC";
    }
    else {

        package Encode::Internal;
        push @@Encode::Internal::ISA, 'Encode::Encoding';
        *decode = sub {
            my ( $obj, $str, $chk ) = @@_;
            utf8::upgrade($str);
            $_[1] = '' if $chk;
            return $str;
        };
        *encode = \&decode;
        $Encode::Encoding{Unicode} =
          bless { Name => "Internal" } => "Encode::Internal";
d262 43
a304 49

        # was in Encode::utf8
        package Encode::utf8;
        push @@Encode::utf8::ISA, 'Encode::Encoding';

        #
        if ($use_xs) {
            Encode::DEBUG and warn __PACKAGE__, " XS on";
            *decode = \&decode_xs;
            *encode = \&encode_xs;
        }
        else {
            Encode::DEBUG and warn __PACKAGE__, " XS off";
            *decode = sub {
                my ( $obj, $octets, $chk ) = @@_;
                my $str = Encode::decode_utf8($octets);
                if ( defined $str ) {
                    $_[1] = '' if $chk;
                    return $str;
                }
                return undef;
            };
            *encode = sub {
                my ( $obj, $string, $chk ) = @@_;
                my $octets = Encode::encode_utf8($string);
                $_[1] = '' if $chk;
                return $octets;
            };
        }
        *cat_decode = sub {    # ($obj, $dst, $src, $pos, $trm, $chk)
                               # currently ignores $chk
            my ( $obj, undef, undef, $pos, $trm ) = @@_;
            my ( $rdst, $rsrc, $rpos ) = \@@_[ 1, 2, 3 ];
            use bytes;
            if ( ( my $npos = index( $$rsrc, $trm, $pos ) ) >= 0 ) {
                $$rdst .=
                  substr( $$rsrc, $pos, $npos - $pos + length($trm) );
                $$rpos = $npos + length($trm);
                return 1;
            }
            $$rdst .= substr( $$rsrc, $pos );
            $$rpos = length($$rsrc);
            return '';
        };
        $Encode::Encoding{utf8} =
          bless { Name => "utf8" } => "Encode::utf8";
        $Encode::Encoding{"utf-8-strict"} =
          bless { Name => "utf-8-strict", strict_utf8 => 1 } =>
          "Encode::utf8";
d400 5
a404 5
B<CAVEAT>: When you run C<$octets = encode("utf8", $string)>, then
$octets B<may not be equal to> $string.  Though they both contain the
same data, the UTF8 flag for $octets is B<always> off.  When you
encode anything, UTF8 flag of the result is always off, even when it
contains completely valid utf8 string. See L</"The UTF8 flag"> below.
d422 2
a423 2
the UTF8 flag for $string is on unless $octets entirely consists of
ASCII data (or EBCDIC on EBCDIC machines).  See L</"The UTF8 flag">
a427 35
=item [$obj =] find_encoding(ENCODING)

Returns the I<encoding object> corresponding to ENCODING.  Returns
undef if no matching ENCODING is find.

This object is what actually does the actual (en|de)coding.

  $utf8 = decode($name, $bytes);

is in fact

  $utf8 = do{
    $obj = find_encoding($name);
    croak qq(encoding "$name" not found) unless ref $obj;
    $obj->decode($bytes)
  };

with more error checking.

Therefore you can save time by reusing this object as follows;

  my $enc = find_encoding("iso-8859-1");
  while(<>){
     my $utf8 = $enc->decode($_);
     # and do someting with $utf8;
  }

Besides C<< ->decode >> and C<< ->encode >>, other methods are
available as well.  For instance, C<< -> name >> returns the canonical
name of the encoding object.

  find_encoding("latin1")->name; # iso-8859-1

See L<Encode::Encoding> for details.

d453 1
a453 1
but only #2 turns UTF8 flag on.  #1 is equivalent to
d457 1
a457 15
See L</"The UTF8 flag"> below.

Also note that

  from_to($octets, $from, $to, $check);

is equivalent to

  $octets = encode($to, decode($from, $octets), $check);

Yes, it does not respect the $check during decoding.  It is
deliberately done that way.  If you need minute control, C<decode>
then C<encode> as follows;

  $octets = encode($to, decode($from, $octets, $check_from), $check_to);
a524 16
=head2 Finding IANA Character Set Registry names

The canonical name of a given encoding does not necessarily agree with
IANA IANA Character Set Registry, commonly seen as C<< Content-Type:
text/plain; charset=I<whatever> >>.  For most cases canonical names
work but sometimes it does not (notably 'utf-8-strict').

Therefore as of Encode version 2.21, a new method C<mime_name()> is added.

  use Encode;
  my $enc = find_encoding('UTF-8');
  warn $enc->name;      # utf-8-strict
  warn $enc->mime_name; # UTF-8

See also:  L<Encode::Encoding>

d527 3
a529 3
If your perl supports I<PerlIO> (which is the default), you can use a
PerlIO layer to decode and encode directly via a filehandle.  The
following two examples are totally identical in their functionality.
d654 1
a654 11
=over 2

=item Encode::LEAVE_SRC

If the C<Encode::LEAVE_SRC> bit is not set, but I<CHECK> is, then the second
argument to C<encode()> or C<decode()> may be assigned to by the functions. If
you're not interested in this, then bitwise-or the bitmask with it.

=back

=Head2 coderef for CHECK
d679 1
a679 1
=head1 The UTF8 flag
d681 1
a681 1
Before the introduction of Unicode support in perl, The C<eq> operator
d683 3
a685 3
perl 5.8, C<eq> compares two strings with simultaneous consideration of
I<the UTF8 flag>. To explain why we made it so, I will quote page 402 of
C<Programming Perl, 3rd ed.>
d714 2
a715 2
of the UTF8 flag is one of them.  You can think of this perl notion as of a
byte-oriented mode (UTF8 flag off) and a character-oriented mode (UTF8
d718 1
a718 1
Here is how Encode takes care of the UTF8 flag.
d724 1
a724 1
When you encode, the resulting UTF8 flag is always off.
d728 1
a728 1
When you decode, the resulting UTF8 flag is on unless you can
d734 1
a734 1
  When $octet is...   The UTF8 flag in $utf8 is
d745 1
a745 1
This UTF8 flag is not visible in perl scripts, exactly for the same
d761 1
a761 1
[INTERNAL] Tests whether the UTF8 flag is turned on in the STRING.
d769 1
a769 1
[INTERNAL] Turns on the UTF8 flag in STRING.  The data in STRING is
d772 1
a772 1
state of the UTF8 flag (so please don't treat the return value as
d777 2
a778 2
[INTERNAL] Turns off the UTF8 flag in STRING.  Do not use frivolously.
Returns the previous state of the UTF8 flag (so please don't treat the
d784 1
a784 1
=head1 UTF-8 vs. utf8 vs. UTF8
d828 1
a828 1
  find_encoding("utf_8")->name  # ditto. "_" are treated as "-"
a830 2
The UTF8 flag is internally called UTF8, without a hyphen. It indicates
whether a string is internally encoded as utf8, also without a hypen.
d840 1
a840 1
L<perlunicode>, L<perluniintro>, L<perlunifaq>, L<perlunitut>
a849 11

While Dan Kogai retains the copyright as a maintainer, the credit
should go to all those involoved.  See AUTHORS for those submitted
codes.

=head1 COPYRIGHT

Copyright 2002-2006 Dan Kogai E<lt>dankogai@@dan.co.jpE<gt>

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d2 1
a2 1
# $Id: Encode.pm,v 2.35 2009/07/13 00:49:38 dankogai Exp $
d7 1
a7 1
our $VERSION = sprintf "%d.%02d", q$Revision: 2.35 $ =~ /(\d+)/g;
d39 1
a39 2
    default      => [ @@EXPORT ],
    fallbacks    => [ @@FB_CONSTS ],
d53 1
a53 8
#  See
#  https://bugzilla.redhat.com/show_bug.cgi?id=435505#c2
#  to find why sig handers inside eval{} are disabled.
eval {
    local $SIG{__DIE__};
    local $SIG{__WARN__};
    require Encode::ConfigLocal;
};
a140 4
    unless ( defined $name ) {
        require Carp;
        Carp::croak("Encoding name should not be undef");
    }
d737 1
a737 1
=head2 coderef for CHECK
a857 2
This function does not work on tainted values.

a863 2

This function does not work on tainted values.
@


