head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.2
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.16
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.10
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.12
	OPENBSD_5_8_BASE:1.10
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.10.0.4
	OPENBSD_5_7_BASE:1.10
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.10.0.8
	OPENBSD_5_6_BASE:1.10
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.8
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.11
date	2017.02.05.00.32.12;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	cxJ08BvJA9Pt2PTM;

1.10
date	2013.03.25.20.40.54;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.24.15.06.56;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.12.18.24.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.04;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.02;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.22;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.05.14;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.55.15;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.04;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.04;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.38.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.01;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.16;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.11.11;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.09.24.14.48.53;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.08.44;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/* dlutils.c - handy functions and definitions for dl_*.xs files
 *
 * Currently this file is simply #included into dl_*.xs/.c files.
 * It should really be split into a dlutils.h and dlutils.c
 *
 * Modified:
 * 29th Feburary 2000 - Alan Burlison: Added functionality to close dlopen'd
 *                      files when the interpreter exits
 */

#define PERL_EUPXS_ALWAYS_EXPORT
#ifndef START_MY_CXT /* Some IDEs try compiling this standalone. */
#   define PERL_EXT
#   include "EXTERN.h"
#   include "perl.h"
#   include "XSUB.h"
#endif

#ifndef XS_VERSION
#  define XS_VERSION "0"
#endif
#define MY_CXT_KEY "DynaLoader::_guts" XS_VERSION

/* disable version checking since DynaLoader can't be DynaLoaded */
#undef dXSBOOTARGSXSAPIVERCHK
#define dXSBOOTARGSXSAPIVERCHK dXSBOOTARGSNOVERCHK

typedef struct {
    SV*		x_dl_last_error;	/* pointer to allocated memory for
					   last error message */
#if defined(PERL_IN_DL_HPUX_XS) || defined(PERL_IN_DL_DLOPEN_XS)
    int		x_dl_nonlazy;		/* flag for immediate rather than lazy
					   linking (spots unresolved symbol) */
#endif
#ifdef DL_LOADONCEONLY
    HV *	x_dl_loaded_files;	/* only needed on a few systems */
#endif
#ifdef DL_CXT_EXTRA
    my_cxtx_t	x_dl_cxtx;		/* extra platform-specific data */
#endif
#ifdef DEBUGGING
    int		x_dl_debug;	/* value copied from $DynaLoader::dl_debug */
#endif
} my_cxt_t;

START_MY_CXT

#define dl_last_error	(SvPVX(MY_CXT.x_dl_last_error))
#if defined(PERL_IN_DL_HPUX_XS) || defined(PERL_IN_DL_DLOPEN_XS)
#define dl_nonlazy	(MY_CXT.x_dl_nonlazy)
#endif
#ifdef DL_LOADONCEONLY
#define dl_loaded_files	(MY_CXT.x_dl_loaded_files)
#endif
#ifdef DL_CXT_EXTRA
#define dl_cxtx		(MY_CXT.x_dl_cxtx)
#endif
#ifdef DEBUGGING
#define dl_debug	(MY_CXT.x_dl_debug)
#endif

#ifdef DEBUGGING
#define DLDEBUG(level,code) \
    STMT_START {					\
	dMY_CXT;					\
	if (dl_debug>=level) { code; }			\
    } STMT_END
#else
#define DLDEBUG(level,code)	NOOP
#endif

#ifdef DL_UNLOAD_ALL_AT_EXIT
/* Close all dlopen'd files */
static void
dl_unload_all_files(pTHX_ void *unused)
{
    CV *sub;
    AV *dl_librefs;
    SV *dl_libref;

    if ((sub = get_cvs("DynaLoader::dl_unload_file", 0)) != NULL) {
        dl_librefs = get_av("DynaLoader::dl_librefs", 0);
        EXTEND(SP,1);
        while ((dl_libref = av_pop(dl_librefs)) != &PL_sv_undef) {
           dSP;
           ENTER;
           SAVETMPS;
           PUSHMARK(SP);
           PUSHs(sv_2mortal(dl_libref));
           PUTBACK;
           call_sv((SV*)sub, G_DISCARD | G_NODEBUG);
           FREETMPS;
           LEAVE;
        }
    }
}
#endif

static void
dl_generic_private_init(pTHX)	/* called by dl_*.xs dl_private_init() */
{
#if defined(PERL_IN_DL_HPUX_XS) || defined(PERL_IN_DL_DLOPEN_XS)
    char *perl_dl_nonlazy;
    UV uv;
#endif
    MY_CXT_INIT;

    MY_CXT.x_dl_last_error = newSVpvs("");
#ifdef DL_LOADONCEONLY
    dl_loaded_files = NULL;
#endif
#ifdef DEBUGGING
    {
	SV *sv = get_sv("DynaLoader::dl_debug", 0);
	dl_debug = sv ? SvIV(sv) : 0;
    }
#endif

#if defined(PERL_IN_DL_HPUX_XS) || defined(PERL_IN_DL_DLOPEN_XS)
    if ( (perl_dl_nonlazy = getenv("PERL_DL_NONLAZY")) != NULL
	&& grok_atoUV(perl_dl_nonlazy, &uv, NULL)
	&& uv <= INT_MAX
    ) {
	dl_nonlazy = (int)uv;
    } else
	dl_nonlazy = 0;
    if (dl_nonlazy)
	DLDEBUG(1,PerlIO_printf(Perl_debug_log, "DynaLoader bind mode is 'non-lazy'\n"));
#endif
#ifdef DL_LOADONCEONLY
    if (!dl_loaded_files)
	dl_loaded_files = newHV(); /* provide cache for dl_*.xs if needed */
#endif
#ifdef DL_UNLOAD_ALL_AT_EXIT
    call_atexit(&dl_unload_all_files, (void*)0);
#endif
}


#ifndef SYMBIAN
/* SaveError() takes printf style args and saves the result in dl_last_error */
static void
SaveError(pTHX_ const char* pat, ...)
{
    va_list args;
    SV *msv;
    const char *message;
    STRLEN len;

    /* This code is based on croak/warn, see mess() in util.c */

    va_start(args, pat);
    msv = vmess(pat, &args);
    va_end(args);

    message = SvPV(msv,len);
    len++;		/* include terminating null char */

    {
	dMY_CXT;
    /* Copy message into dl_last_error (including terminating null char) */
	sv_setpvn(MY_CXT.x_dl_last_error, message, len) ;
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: stored error msg '%s'\n",dl_last_error));
    }
}
#endif

@


1.10
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d13 1
d24 4
d31 1
d34 1
d49 1
d51 1
d83 1
d89 1
a89 1
           XPUSHs(sv_2mortal(dl_libref));
d102 1
d104 2
d108 1
a108 2
    MY_CXT.x_dl_last_error = newSVpvn("", 0);
    dl_nonlazy = 0;
d118 9
a126 2
    if ( (perl_dl_nonlazy = getenv("PERL_DL_NONLAZY")) != NULL )
	dl_nonlazy = atoi(perl_dl_nonlazy);
d129 1
a144 1
    dMY_CXT;
d159 2
d162 3
a164 2
    sv_setpvn(MY_CXT.x_dl_last_error, message, len) ;
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: stored error msg '%s'\n",dl_last_error));
@


1.9
log
@merge in perl 5.12.2 plus local changes
@
text
@d11 1
@


1.8
log
@Merge in perl 5.10.1
@
text
@d71 1
a71 1
    if ((sub = get_cv("DynaLoader::dl_unload_file", 0)) != NULL) {
@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d71 2
a72 2
    if ((sub = get_cv("DynaLoader::dl_unload_file", FALSE)) != NULL) {
        dl_librefs = get_av("DynaLoader::dl_librefs", FALSE);
@


1.6
log
@merge in perl 5.8.8
@
text
@d11 6
d97 1
a97 1
    dl_loaded_files = Nullhv;
d119 1
d143 1
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d115 1
a115 1
SaveError(pTHX_ char* pat, ...)
d120 1
a120 1
    char *message;
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d11 4
d16 15
a30 2
/* pointer to allocated memory for last error message */
static char *LastError  = (char*)NULL;
d32 1
a32 2
/* flag for immediate rather than lazy linking (spots unresolved symbol) */
static int dl_nonlazy = 0;
d34 2
d37 7
a43 1
static HV *dl_loaded_files = Nullhv;	/* only needed on a few systems */
a45 1

d47 5
a51 2
static int dl_debug = 0;	/* value copied from $DynaLoader::dl_debug */
#define DLDEBUG(level,code)	if (dl_debug>=level) { code; }
d53 1
a53 1
#define DLDEBUG(level,code)
d56 1
a56 1

d59 1
a59 1
dl_unload_all_files(pTHXo_ void *unused)
d80 1
a80 1

d83 1
a83 1
dl_generic_private_init(pTHXo)	/* called by dl_*.xs dl_private_init() */
d86 7
d94 4
a97 2
    SV *sv = get_sv("DynaLoader::dl_debug", 0);
    dl_debug = sv ? SvIV(sv) : 0;
d113 1
a113 1
/* SaveError() takes printf style args and saves the result in LastError */
d115 1
a115 1
SaveError(pTHXo_ char* pat, ...)
d117 1
d132 3
a134 9
    /* Allocate some memory for the error message */
    if (LastError)
        LastError = (char*)saferealloc(LastError, len) ;
    else
        LastError = (char *) safemalloc(len) ;

    /* Copy message into LastError (including terminating null char)	*/
    strncpy(LastError, message, len) ;
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: stored error msg '%s'\n",LastError));
@


1.3
log
@perl5.005_03 (stock)
@
text
@d6 3
d24 1
a24 1
static int dl_debug = 0;	/* value copied from $DynaLoader::dl_error */
d31 1
d33 25
a57 1
dl_generic_private_init(CPERLarg)	/* called by dl_*.xs dl_private_init() */
d61 2
a62 1
    dl_debug = SvIV( perl_get_sv("DynaLoader::dl_debug", 0x04) );
d67 1
a67 1
	DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "DynaLoader bind mode is 'non-lazy'\n"));
d72 3
d80 1
a80 1
SaveError(CPERLarg_ char* pat, ...)
d83 1
d85 1
a85 1
    int len;
d90 1
a90 1
    message = mess(pat, &args);
d93 2
a94 1
    len = strlen(message) + 1 ;	/* include terminating null char */
d104 1
a104 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "DynaLoader: stored error msg '%s'\n",LastError));
@


1.2
log
@perl 5.004_04
@
text
@d29 1
a29 1
dl_generic_private_init()	/* called by dl_*.xs dl_private_init() */
a46 1
#ifdef STANDARD_C
d48 1
a48 8
SaveError(char* pat, ...)
#else
/*VARARGS0*/
static void
SaveError(pat, va_alist)
    char *pat;
    va_dcl
#endif
a55 1
#ifdef I_STDARG
a56 3
#else
    va_start(args);
#endif
@


1.1
log
@Initial revision
@
text
@d38 1
a38 1
	DLDEBUG(1,fprintf(stderr,"DynaLoader bind mode is 'non-lazy'\n"));
d78 1
a78 1
        LastError = safemalloc(len) ;
d82 1
a82 13
    DLDEBUG(2,fprintf(stderr,"DynaLoader: stored error msg '%s'\n",LastError));
}


/* prepend underscore to s. write into buf. return buf. */
char *
dl_add_underscore(s, buf)
char *s;
char *buf;
{
    *buf = '_';
    (void)strcpy(buf + 1, s);
    return buf;
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d29 1
a29 1
dl_generic_private_init(CPERLarg)	/* called by dl_*.xs dl_private_init() */
d38 1
a38 1
	DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "DynaLoader bind mode is 'non-lazy'\n"));
d47 1
d49 8
a56 1
SaveError(CPERLarg_ char* pat, ...)
d64 1
d66 3
d78 1
a78 1
        LastError = (char *) safemalloc(len) ;
d82 13
a94 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "DynaLoader: stored error msg '%s'\n",LastError));
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a5 3
 * Modified:
 * 29th Feburary 2000 - Alan Burlison: Added functionality to close dlopen'd
 *                      files when the interpreter exits
d21 1
a21 1
static int dl_debug = 0;	/* value copied from $DynaLoader::dl_debug */
a27 1
/* Close all dlopen'd files */
d29 1
a29 25
dl_unload_all_files(pTHXo_ void *unused)
{
    CV *sub;
    AV *dl_librefs;
    SV *dl_libref;

    if ((sub = get_cv("DynaLoader::dl_unload_file", FALSE)) != NULL) {
        dl_librefs = get_av("DynaLoader::dl_librefs", FALSE);
        while ((dl_libref = av_pop(dl_librefs)) != &PL_sv_undef) {
           dSP;
           ENTER;
           SAVETMPS;
           PUSHMARK(SP);
           XPUSHs(sv_2mortal(dl_libref));
           PUTBACK;
           call_sv((SV*)sub, G_DISCARD | G_NODEBUG);
           FREETMPS;
           LEAVE;
        }
    }
}


static void
dl_generic_private_init(pTHXo)	/* called by dl_*.xs dl_private_init() */
d33 1
a33 2
    SV *sv = get_sv("DynaLoader::dl_debug", 0);
    dl_debug = sv ? SvIV(sv) : 0;
d38 1
a38 1
	DLDEBUG(1,PerlIO_printf(Perl_debug_log, "DynaLoader bind mode is 'non-lazy'\n"));
a42 3
#ifdef DL_UNLOAD_ALL_AT_EXIT
    call_atexit(&dl_unload_all_files, (void*)0);
#endif
d48 1
a48 1
SaveError(pTHXo_ char* pat, ...)
a50 1
    SV *msv;
d52 1
a52 1
    STRLEN len;
d57 1
a57 1
    msv = vmess(pat, &args);
d60 1
a60 2
    message = SvPV(msv,len);
    len++;		/* include terminating null char */
d70 1
a70 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: stored error msg '%s'\n",LastError));
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a10 4
#ifndef XS_VERSION
#  define XS_VERSION "0"
#endif
#define MY_CXT_KEY "DynaLoader::_guts" XS_VERSION
d12 2
a13 15
typedef struct {
    SV*		x_dl_last_error;	/* pointer to allocated memory for
					   last error message */
    int		x_dl_nonlazy;		/* flag for immediate rather than lazy
					   linking (spots unresolved symbol) */
#ifdef DL_LOADONCEONLY
    HV *	x_dl_loaded_files;	/* only needed on a few systems */
#endif
#ifdef DL_CXT_EXTRA
    my_cxtx_t	x_dl_cxtx;		/* extra platform-specific data */
#endif
#ifdef DEBUGGING
    int		x_dl_debug;	/* value copied from $DynaLoader::dl_debug */
#endif
} my_cxt_t;
d15 2
a16 1
START_MY_CXT
a17 2
#define dl_last_error	(SvPVX(MY_CXT.x_dl_last_error))
#define dl_nonlazy	(MY_CXT.x_dl_nonlazy)
d19 1
a19 7
#define dl_loaded_files	(MY_CXT.x_dl_loaded_files)
#endif
#ifdef DL_CXT_EXTRA
#define dl_cxtx		(MY_CXT.x_dl_cxtx)
#endif
#ifdef DEBUGGING
#define dl_debug	(MY_CXT.x_dl_debug)
d21 1
d24 2
a25 5
#define DLDEBUG(level,code) \
    STMT_START {					\
	dMY_CXT;					\
	if (dl_debug>=level) { code; }			\
    } STMT_END
d27 1
a27 1
#define DLDEBUG(level,code)	NOOP
d30 1
a30 1
#ifdef DL_UNLOAD_ALL_AT_EXIT
d33 1
a33 1
dl_unload_all_files(pTHX_ void *unused)
d54 1
a54 1
#endif
d57 1
a57 1
dl_generic_private_init(pTHX)	/* called by dl_*.xs dl_private_init() */
a59 7
    MY_CXT_INIT;

    MY_CXT.x_dl_last_error = newSVpvn("", 0);
    dl_nonlazy = 0;
#ifdef DL_LOADONCEONLY
    dl_loaded_files = Nullhv;
#endif
d61 2
a62 4
    {
	SV *sv = get_sv("DynaLoader::dl_debug", 0);
	dl_debug = sv ? SvIV(sv) : 0;
    }
d78 1
a78 1
/* SaveError() takes printf style args and saves the result in dl_last_error */
d80 1
a80 1
SaveError(pTHX_ char* pat, ...)
a81 1
    dMY_CXT;
d96 9
a104 3
    /* Copy message into dl_last_error (including terminating null char) */
    sv_setpvn(MY_CXT.x_dl_last_error, message, len) ;
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: stored error msg '%s'\n",dl_last_error));
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d115 1
a115 1
SaveError(pTHX_ const char* pat, ...)
d120 1
a120 1
    const char *message;
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@a10 6
#ifndef START_MY_CXT /* Some IDEs try compiling this standalone. */
#   include "EXTERN.h"
#   include "perl.h"
#   include "XSUB.h"
#endif

d91 1
a91 1
    dl_loaded_files = NULL;
a112 1
#ifndef SYMBIAN
a135 1
#endif
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d71 2
a72 2
    if ((sub = get_cv("DynaLoader::dl_unload_file", 0)) != NULL) {
        dl_librefs = get_av("DynaLoader::dl_librefs", 0);
@


1.1.1.8
log
@Perl 5.12.2 from CPAN
@
text
@d71 1
a71 1
    if ((sub = get_cvs("DynaLoader::dl_unload_file", 0)) != NULL) {
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a10 1
#define PERL_EUPXS_ALWAYS_EXPORT
@


