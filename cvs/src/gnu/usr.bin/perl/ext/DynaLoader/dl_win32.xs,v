head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.4.0.10
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.4
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.6
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.12;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2010.09.24.14.48.53;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.53;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.08.44;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/* dl_win32.xs
 * 
 * Platform:	Win32 (Windows NT/Windows 95)
 * Author:	Wei-Yuen Tan (wyt@@hip.com)
 * Created:	A warm day in June, 1995
 *
 * Modified:
 *    August 23rd 1995 - rewritten after losing everything when I
 *                       wiped off my NT partition (eek!)
 */

/* Porting notes:

I merely took Paul's dl_dlopen.xs, took out extraneous stuff and
replaced the appropriate SunOS calls with the corresponding Win32
calls.

*/

#define WIN32_LEAN_AND_MEAN
#ifdef __GNUC__
#define Win32_Winsock
#endif
#include <windows.h>
#include <string.h>

#define PERL_NO_GET_CONTEXT
#define PERL_EXT
#define PERL_IN_DL_WIN32_XS

#include "EXTERN.h"
#include "perl.h"
#include "win32.h"

#include "XSUB.h"

typedef struct {
    SV *	x_error_sv;
} my_cxtx_t;		/* this *must* be named my_cxtx_t */

#define DL_CXT_EXTRA	/* ask for dl_cxtx to be defined in dlutils.c */
#include "dlutils.c"	/* SaveError() etc	*/

#define dl_error_sv	(dl_cxtx.x_error_sv)

static char *
OS_Error_String(pTHX)
{
    dMY_CXT;
    DWORD err = GetLastError();
    STRLEN len;
    SV ** l_dl_error_svp = &dl_error_sv;
    SV * l_dl_error_sv;
    if (!*l_dl_error_svp)
	*l_dl_error_svp = newSVpvs("");
    l_dl_error_sv = *l_dl_error_svp;
    PerlProc_GetOSError(l_dl_error_sv,err);
    return SvPV(l_dl_error_sv,len);
}

static void
dl_private_init(pTHX)
{
    (void)dl_generic_private_init(aTHX);
}

/* 
    This function assumes the list staticlinkmodules
    will be formed from package names with '::' replaced
    with '/'. Thus Win32::OLE is in the list as Win32/OLE
*/
static int
dl_static_linked(char *filename)
{
    const char * const *p;
    char *ptr, *hptr;
    static const char subStr[] = "/auto/";
    char szBuffer[MAX_PATH];

    /* avoid buffer overflow when called with invalid filenames */
    if (strlen(filename) >= sizeof(szBuffer))
        return 0;

    /* change all the '\\' to '/' */
    strcpy(szBuffer, filename);
    for(ptr = szBuffer; ptr = strchr(ptr, '\\'); ++ptr)
	*ptr = '/';

    /* delete the file name */
    ptr = strrchr(szBuffer, '/');
    if(ptr != NULL)
	*ptr = '\0';

    /* remove leading lib path */
    ptr = strstr(szBuffer, subStr);
    if(ptr != NULL)
	ptr += sizeof(subStr)-1;
    else
	ptr = szBuffer;

    for (p = staticlinkmodules; *p;p++) {
	if (hptr = strstr(ptr, *p)) {
	    /* found substring, need more detailed check if module name match */
	    if (hptr==ptr) {
		return strcmp(ptr, *p)==0;
	    }
	    if (hptr[strlen(*p)] == 0)
		return hptr[-1]=='/';
	}
    };
    return 0;
}

MODULE = DynaLoader	PACKAGE = DynaLoader

BOOT:
    (void)dl_private_init(aTHX);

void
dl_load_file(filename,flags=0)
    char *		filename
#flags is unused
    SV *		flags = NO_INIT
    PREINIT:
    void *retv;
    SV * retsv;
    CODE:
  {
    PERL_UNUSED_VAR(flags);
    DLDEBUG(1,PerlIO_printf(Perl_debug_log,"dl_load_file(%s):\n", filename));
    if (dl_static_linked(filename) == 0) {
	retv = PerlProc_DynaLoad(filename);
    }
    else
	retv = (void*) Win_GetModuleHandle(NULL);
    DLDEBUG(2,PerlIO_printf(Perl_debug_log," libref=%x\n", retv));

    if (retv == NULL) {
	SaveError(aTHX_ "load_file:%s",
		  OS_Error_String(aTHX)) ;
	retsv = &PL_sv_undef;
    }
    else
	retsv = sv_2mortal(newSViv((IV)retv));
    ST(0) = retsv;
  }

int
dl_unload_file(libref)
    void *	libref
  CODE:
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_unload_file(%lx):\n", PTR2ul(libref)));
    RETVAL = FreeLibrary((HMODULE)libref);
    if (!RETVAL)
        SaveError(aTHX_ "unload_file:%s", OS_Error_String(aTHX)) ;
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " retval = %d\n", RETVAL));
  OUTPUT:
    RETVAL

void
dl_find_symbol(libhandle, symbolname, ign_err=0)
    void *	libhandle
    char *	symbolname
    int	        ign_err
    PREINIT:
    void *retv;
    CODE:
    DLDEBUG(2,PerlIO_printf(Perl_debug_log,"dl_find_symbol(handle=%x, symbol=%s)\n",
		      libhandle, symbolname));
    retv = (void*) GetProcAddress((HINSTANCE) libhandle, symbolname);
    DLDEBUG(2,PerlIO_printf(Perl_debug_log,"  symbolref = %x\n", retv));
    ST(0) = sv_newmortal();
    if (retv == NULL) {
        if (!ign_err) SaveError(aTHX_ "find_symbol:%s", OS_Error_String(aTHX));
    } else
	sv_setiv( ST(0), (IV)retv);


void
dl_undef_symbols()
    CODE:



# These functions should not need changing on any platform:

void
dl_install_xsub(perl_name, symref, filename="$Package")
    char *		perl_name
    void *		symref 
    char *		filename
    CODE:
    DLDEBUG(2,PerlIO_printf(Perl_debug_log,"dl_install_xsub(name=%s, symref=%x)\n",
		      perl_name, symref));
    ST(0) = sv_2mortal(newRV((SV*)newXS(perl_name,
					(void(*)(pTHX_ CV *))symref,
					filename)));


SV *
dl_error()
    CODE:
    dMY_CXT;
    RETVAL = newSVsv(MY_CXT.x_dl_last_error);
    OUTPUT:
    RETVAL

#if defined(USE_ITHREADS)

void
CLONE(...)
    CODE:
    MY_CXT_CLONE;

    PERL_UNUSED_VAR(items);

    /* MY_CXT_CLONE just does a memcpy on the whole structure, so to avoid
     * using Perl variables that belong to another thread, we create our 
     * own for this thread.
     */
    MY_CXT.x_dl_last_error = newSVpvs("");

#endif

# end.
@


1.1
log
@Initial revision
@
text
@d28 2
d52 7
a58 4
    if (!dl_error_sv)
	dl_error_sv = newSVpvn("",0);
    PerlProc_GetOSError(dl_error_sv,err);
    return SvPV(dl_error_sv,len);
d75 1
a75 1
    char **p;
d77 1
a77 1
    static char subStr[] = "/auto/";
d80 4
d119 1
a119 1
void *
d122 2
a123 1
    int			flags
d125 2
d129 1
d132 1
a132 1
	RETVAL = PerlProc_DynaLoad(filename);
d135 4
a138 4
	RETVAL = (void*) Win_GetModuleHandle(NULL);
    DLDEBUG(2,PerlIO_printf(Perl_debug_log," libref=%x\n", RETVAL));
    ST(0) = sv_newmortal() ;
    if (RETVAL == NULL)
d141 2
d144 2
a145 1
	sv_setiv( ST(0), (IV)RETVAL);
d153 1
a153 1
    RETVAL = FreeLibrary(libref);
d160 2
a161 2
void *
dl_find_symbol(libhandle, symbolname)
d164 3
d170 7
a176 8
    RETVAL = (void*) GetProcAddress((HINSTANCE) libhandle, symbolname);
    DLDEBUG(2,PerlIO_printf(Perl_debug_log,"  symbolref = %x\n", RETVAL));
    ST(0) = sv_newmortal() ;
    if (RETVAL == NULL)
	SaveError(aTHX_ "find_symbol:%s",
		  OS_Error_String(aTHX)) ;
    else
	sv_setiv( ST(0), (IV)RETVAL);
d181 1
a181 1
    PPCODE:
d200 1
a200 1
char *
d204 1
a204 1
    RETVAL = dl_last_error;
d215 2
d221 1
a221 1
    MY_CXT.x_dl_last_error = newSVpvn("", 0);
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a74 4
    /* avoid buffer overflow when called with invalid filenames */
    if (strlen(filename) >= sizeof(szBuffer))
        return 0;

@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d70 1
a70 1
    const char * const *p;
d72 1
a72 1
    static const char subStr[] = "/auto/";
d114 1
a114 1
void
a118 1
    void *retv;
d123 1
a123 1
	retv = PerlProc_DynaLoad(filename);
d126 2
a127 2
	retv = (void*) Win_GetModuleHandle(NULL);
    DLDEBUG(2,PerlIO_printf(Perl_debug_log," libref=%x\n", retv));
d129 1
a129 1
    if (retv == NULL)
d133 1
a133 1
	sv_setiv( ST(0), (IV)retv);
d148 1
a148 1
void
a151 2
    PREINIT:
    void *retv;
d155 2
a156 2
    retv = (void*) GetProcAddress((HINSTANCE) libhandle, symbolname);
    DLDEBUG(2,PerlIO_printf(Perl_debug_log,"  symbolref = %x\n", retv));
d158 1
a158 1
    if (retv == NULL)
d162 1
a162 1
	sv_setiv( ST(0), (IV)retv);
d167 1
a167 1
    CODE:
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@a203 2
    PERL_UNUSED_VAR(items);

@


