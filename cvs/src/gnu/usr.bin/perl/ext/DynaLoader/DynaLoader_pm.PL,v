head	1.2;
access;
symbols
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.12.0.10
	OPENBSD_6_0_BASE:1.1.1.12
	OPENBSD_5_9:1.1.1.12.0.4
	OPENBSD_5_9_BASE:1.1.1.12
	OPENBSD_5_8:1.1.1.12.0.6
	OPENBSD_5_8_BASE:1.1.1.12
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.1.1.12.0.2
	OPENBSD_5_7_BASE:1.1.1.12
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.1.1.11.0.4
	OPENBSD_5_6_BASE:1.1.1.11
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.10.0.6
	OPENBSD_5_5_BASE:1.1.1.10
	OPENBSD_5_4:1.1.1.10.0.2
	OPENBSD_5_4_BASE:1.1.1.10
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.1.1.9.0.14
	OPENBSD_5_3_BASE:1.1.1.9
	OPENBSD_5_2:1.1.1.9.0.12
	OPENBSD_5_2_BASE:1.1.1.9
	OPENBSD_5_1_BASE:1.1.1.9
	OPENBSD_5_1:1.1.1.9.0.10
	OPENBSD_5_0:1.1.1.9.0.8
	OPENBSD_5_0_BASE:1.1.1.9
	OPENBSD_4_9:1.1.1.9.0.6
	OPENBSD_4_9_BASE:1.1.1.9
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.1.1.9.0.4
	OPENBSD_4_8_BASE:1.1.1.9
	OPENBSD_4_7:1.1.1.9.0.2
	OPENBSD_4_7_BASE:1.1.1.9
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.1.1.8.0.6
	OPENBSD_4_6_BASE:1.1.1.8
	OPENBSD_4_5:1.1.1.8.0.2
	OPENBSD_4_5_BASE:1.1.1.8
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.1.1.7.0.18
	OPENBSD_4_4_BASE:1.1.1.7
	OPENBSD_4_3:1.1.1.7.0.16
	OPENBSD_4_3_BASE:1.1.1.7
	OPENBSD_4_2:1.1.1.7.0.14
	OPENBSD_4_2_BASE:1.1.1.7
	OPENBSD_4_1:1.1.1.7.0.12
	OPENBSD_4_1_BASE:1.1.1.7
	OPENBSD_4_0:1.1.1.7.0.10
	OPENBSD_4_0_BASE:1.1.1.7
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.1.1.7.0.8
	OPENBSD_3_9_BASE:1.1.1.7
	OPENBSD_3_8:1.1.1.7.0.6
	OPENBSD_3_8_BASE:1.1.1.7
	OPENBSD_3_7:1.1.1.7.0.4
	OPENBSD_3_7_BASE:1.1.1.7
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.1.1.7.0.2
	OPENBSD_3_6_BASE:1.1.1.7
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.12;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	99.04.29.22.38.41;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.38.41;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.09;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.46;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.43;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.21.13.00;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.57;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.16;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.11.11;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.08.44;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@use Config;

sub to_string {
    my ($value) = @@_;
    $value =~ s/\\/\\\\/g;
    $value =~ s/'/\\'/g;
    return "'$value'";
}

#
# subroutine expand_os_specific expands $^O-specific preprocessing information
# so that it will not be re-calculated at runtime in Dynaloader.pm
#
# Syntax of preprocessor should be kept extremely simple:
#  - directives are in double angle brackets <<...>>
#  - <<=string>> will be just evaluated
#  - for $^O-specific there are two forms:
#   <<$^O-eq-osname>>
#   <<$^O-ne-osname>>
#  this directive should be closed with respectively
#   <</$^O-eq-osname>>
#   <</$^O-ne-osname>>
#  construct <<|$^O-ne-osname>> means #else
#  nested <<$^O...>>-constructs are allowed but nested values must be for 
#   different OS-names!
#   
#  -- added by VKON, 03-10-2004 to separate $^O-specific between OSes
#     (so that Win32 never checks for $^O eq 'VMS' for example)
#
# The $^O tests test both for $^O and for $Config{osname}.
# The latter is better for some for cross-compilation setups.
#
sub expand_os_specific {
    my $s = shift;
    for ($s) {
	s/<<=(.*?)>>/$1/gee;
	s/<<\$\^O-(eq|ne)-(\w+)>>(.*?)<<\/\$\^O-\1-\2>>/
	  my ($op, $os, $expr) = ($1,$2,$3);
	  if ($op ne 'eq' and $op ne 'ne') {die "wrong eq-ne arg in $&"};
	  if ($expr =~ m[^(.*?)<<\|\$\^O-$op-$os>>(.*?)$]s) {
	      # #if;#else;#endif
	      my ($if,$el) = ($1,$2);
	      if (($op eq 'eq' and ($^O eq $os || $Config{osname} eq $os)) || ($op eq 'ne' and ($^O ne $os || $Config{osname} ne $os))) {
		  $if
	      }
	      else {
		  $el
	      }
	  }
	  else {
	      # #if;#endif
	      if (($op eq 'eq' and ($^O eq $os || $Config{osname} eq $os)) || ($op eq 'ne' and ($^O ne $os || $Config{osname} ne $os))) {
		  $expr
	      }
	      else {
	      	  ""
	      }
	  }
	/ges;
	if (/<<(=|\$\^O-)/) {die "bad <<\$^O-eq/ne-osname>> expression.".
	    " Unclosed brackets?";
	}
    }
    $s;
}

unlink "DynaLoader.pm" if -f "DynaLoader.pm";
open OUT, ">DynaLoader.pm" or die $!;
print OUT <<'EOT';

# Generated from DynaLoader_pm.PL, this file is unique for every OS

package DynaLoader;

#   And Gandalf said: 'Many folk like to know beforehand what is to
#   be set on the table; but those who have laboured to prepare the
#   feast like to keep their secret; for wonder makes the words of
#   praise louder.'

#   (Quote from Tolkien suggested by Anno Siegel.)
#
# See pod text at end of file for documentation.
# See also ext/DynaLoader/README in source tree for other information.
#
# Tim.Bunce@@ig.co.uk, August 1994

BEGIN {
    $VERSION = '1.38';
}

EOT

if (!$ENV{PERL_BUILD_EXPAND_CONFIG_VARS}) {
    print OUT "use Config;\n";
}

print OUT <<'EOT';

# enable debug/trace messages from DynaLoader perl code
$dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;

#
# Flags to alter dl_load_file behaviour.  Assigned bits:
#   0x01  make symbols available for linking later dl_load_file's.
#         (only known to work on Solaris 2 using dlopen(RTLD_GLOBAL))
#         (ignored under VMS; effect is built-in to image linking)
#         (ignored under Android; the linker always uses RTLD_LOCAL)
#
# This is called as a class method $module->dl_load_flags.  The
# definition here will be inherited and result on "default" loading
# behaviour unless a sub-class of DynaLoader defines its own version.
#

sub dl_load_flags { 0x00 }

EOT

if ($ENV{PERL_BUILD_EXPAND_CONFIG_VARS}) {
    print OUT "(\$dl_dlext, \$dl_so, \$dlsrc) = (",
              to_string($Config{'dlext'}), ",",
              to_string($Config{'so'}), ",",
              to_string($Config{'dlsrc'}), ")\n;" ;
}
else {
    print OUT <<'EOT';
($dl_dlext, $dl_so, $dlsrc) = @@Config::Config{qw(dlext so dlsrc)};
EOT
}

print OUT expand_os_specific(<<'EOT');

<<$^O-eq-VMS>>
# Some systems need special handling to expand file specifications
# (VMS support by Charles Bailey <bailey@@HMIVAX.HUMGEN.UPENN.EDU>)
# See dl_expandspec() for more details. Should be harmless but
# inefficient to define on systems that don't need it.
$Is_VMS    = $^O eq 'VMS';
<</$^O-eq-VMS>>
$do_expand = <<$^O-eq-VMS>>1<<|$^O-eq-VMS>>0<</$^O-eq-VMS>>;

@@dl_require_symbols = ();       # names of symbols we need<<$^O-eq-freemint>>
@@dl_resolve_using   = ();       # names of files to link with<</$^O-eq-freemint>><<$^O-eq-hpux>>
@@dl_resolve_using   = ();       # names of files to link with<</$^O-eq-hpux>>
@@dl_library_path    = ();       # path to look for files

#XSLoader.pm may have added elements before we were required
#@@dl_shared_objects  = ();       # shared objects for symbols we have 
#@@dl_librefs         = ();       # things we have loaded
#@@dl_modules         = ();       # Modules we have loaded

EOT

my $cfg_dl_library_path = <<'EOT';
push(@@dl_library_path, split(' ', $Config::Config{libpth}));
EOT

sub dquoted_comma_list {
    join(", ", map {'"'.quotemeta($_).'"'} @@_);
}

if ($ENV{PERL_BUILD_EXPAND_CONFIG_VARS}) {
    eval $cfg_dl_library_path;
    if (!$ENV{PERL_BUILD_EXPAND_ENV_VARS}) {
        my $dl_library_path = dquoted_comma_list(@@dl_library_path);
        print OUT <<EOT;
# The below \@@dl_library_path has been expanded (%Config) in Perl build time.

\@@dl_library_path = ($dl_library_path);

EOT
    }
}
else {
    print OUT <<EOT;
# Initialise \@@dl_library_path with the 'standard' library path
# for this platform as determined by Configure.

$cfg_dl_library_path

EOT
}

my $ldlibpthname;
my $ldlibpthname_defined;
my $pthsep;

if ($ENV{PERL_BUILD_EXPAND_CONFIG_VARS}) {
    $ldlibpthname         = to_string($Config::Config{ldlibpthname});
    $ldlibpthname_defined = to_string(defined $Config::Config{ldlibpthname} ? 1 : 0);
    $pthsep               = to_string($Config::Config{path_sep});
}
else {
    $ldlibpthname         = q($Config::Config{ldlibpthname});
    $ldlibpthname_defined = q(defined $Config::Config{ldlibpthname});
    $pthsep               = q($Config::Config{path_sep});
}
print OUT <<EOT;
my \$ldlibpthname         = $ldlibpthname;
my \$ldlibpthname_defined = $ldlibpthname_defined;
my \$pthsep               = $pthsep;

EOT

my $env_dl_library_path = <<'EOT';
if ($ldlibpthname_defined &&
    exists $ENV{$ldlibpthname}) {
    push(@@dl_library_path, split(/$pthsep/, $ENV{$ldlibpthname}));
}

# E.g. HP-UX supports both its native SHLIB_PATH *and* LD_LIBRARY_PATH.

if ($ldlibpthname_defined &&
    $ldlibpthname ne 'LD_LIBRARY_PATH' &&
    exists $ENV{LD_LIBRARY_PATH}) {
    push(@@dl_library_path, split(/$pthsep/, $ENV{LD_LIBRARY_PATH}));
}
EOT

if ($ENV{PERL_BUILD_EXPAND_CONFIG_VARS} && $ENV{PERL_BUILD_EXPAND_ENV_VARS}) {
    eval $env_dl_library_path;
}
else {
    print OUT <<EOT;
# Add to \@@dl_library_path any extra directories we can gather from environment
# during runtime.

$env_dl_library_path

EOT
}

if ($ENV{PERL_BUILD_EXPAND_CONFIG_VARS} && $ENV{PERL_BUILD_EXPAND_ENV_VARS}) {
    my $dl_library_path = dquoted_comma_list(@@dl_library_path);
    print OUT <<EOT;
# The below \@@dl_library_path has been expanded (%Config, %ENV)
# in Perl build time.

\@@dl_library_path = ($dl_library_path);

EOT
}

if ( $Config::Config{d_libname_unique} ) {
    printf OUT <<'EOT', length($Config::Config{dlext}) + 1;
sub mod2fname {
    my $parts = shift;
    my $so_len = %d;
    my $name_max = 255; # No easy way to get this here
    
    my $libname = "PL_" .  join("__", @@$parts);
    
    return $libname if (length($libname)+$so_len) <= $name_max;
    
    # It's too darned big, so we need to go strip. We use the same
    # algorithm as xsubpp does. First, strip out doubled __
    $libname =~ s/__/_/g;
    return $libname if (length($libname)+$so_len) <= $name_max;
    
    # Strip duplicate letters
    1 while $libname =~ s/(.)\1/\U$1/i;
    return $libname if (length($libname)+$so_len) <= $name_max;
    
    # Still too long. Truncate.
    $libname = substr($libname, 0, $name_max - $so_len);
    return $libname;
}
EOT
}

# following long string contains $^O-specific stuff, which is factored out
print OUT expand_os_specific(<<'EOT');
# No prizes for guessing why we don't say 'bootstrap DynaLoader;' here.
# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB
boot_DynaLoader('DynaLoader') if defined(&boot_DynaLoader) &&
                                !defined(&dl_error);

if ($dl_debug) {
    print STDERR "DynaLoader.pm loaded (@@INC, @@dl_library_path)\n";
    print STDERR "DynaLoader not linked into this perl\n"
	    unless defined(&boot_DynaLoader);
}

1; # End of main code


sub croak   { require Carp; Carp::croak(@@_)   }

sub bootstrap_inherit {
    my $module = $_[0];
    local *isa = *{"$module\::ISA"};
    local @@isa = (@@isa, 'DynaLoader');
    # Cannot goto due to delocalization.  Will report errors on a wrong line?
    bootstrap(@@_);
}

sub bootstrap {
    # use local vars to enable $module.bs script to edit values
    local(@@args) = @@_;
    local($module) = $args[0];
    local(@@dirs, $file);

    unless ($module) {
	require Carp;
	Carp::confess("Usage: DynaLoader::bootstrap(module)");
    }

    # A common error on platforms which don't support dynamic loading.
    # Since it's fatal and potentially confusing we give a detailed message.
    croak("Can't load module $module, dynamic loading not available in this perl.\n".
	"  (You may need to build a new perl executable which either supports\n".
	"  dynamic loading or has the $module module statically linked into it.)\n")
	unless defined(&dl_load_file);


    <<$^O-eq-os2>>
    # Can dynaload, but cannot dynaload Perl modules...
    die 'Dynaloaded Perl modules are not available in this build of Perl' if $OS2::is_static;

    <</$^O-eq-os2>>
    my @@modparts = split(/::/,$module);
    my $modfname = $modparts[-1];
    my $modfname_orig = $modfname; # For .bs file search

    # Some systems have restrictions on files names for DLL's etc.
    # mod2fname returns appropriate file base name (typically truncated)
    # It may also edit @@modparts if required.
    $modfname = &mod2fname(\@@modparts) if defined &mod2fname;

    <<$^O-eq-NetWare>>
    # Truncate the module name to 8.3 format for NetWare
	if ((length($modfname) > 8)) {
		$modfname = substr($modfname, 0, 8);
	}
    <</$^O-eq-NetWare>>

    my $modpname = join('/',@@modparts);

    print STDERR "DynaLoader::bootstrap for $module ",
		       "(auto/$modpname/$modfname.$dl_dlext)\n"
	if $dl_debug;

    my $dir;
    foreach (@@INC) {
	<<$^O-eq-VMS>>chop($_ = VMS::Filespec::unixpath($_));<</$^O-eq-VMS>>
	    $dir = "$_/auto/$modpname";
	
	next unless -d $dir; # skip over uninteresting directories
	
	# check for common cases to avoid autoload of dl_findfile
        my $try = "$dir/$modfname.$dl_dlext";
	last if $file = ($do_expand) ? dl_expandspec($try) : ((-f $try) && $try);
	
	# no luck here, save dir for possible later dl_findfile search
	push @@dirs, $dir;
    }
    # last resort, let dl_findfile have a go in all known locations
    $file = dl_findfile(map("-L$_",@@dirs,@@INC), $modfname) unless $file;

    croak("Can't locate loadable object for module $module in \@@INC (\@@INC contains: @@INC)")
	unless $file;	# wording similar to error from 'require'

    <<$^O-eq-VMS>>$file = uc($file) if $Config::Config{d_vms_case_sensitive_symbols};<</$^O-eq-VMS>>
    my $bootname = "boot_$module";
    $bootname =~ s/\W/_/g;
    @@dl_require_symbols = ($bootname);

    # Execute optional '.bootstrap' perl script for this module.
    # The .bs file can be used to configure @@dl_resolve_using etc to
    # match the needs of the individual module on this architecture.
    # N.B. The .bs file does not following the naming convention used
    # by mod2fname.
    my $bs = "$dir/$modfname_orig";
    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
    if (-s $bs) { # only read file if it's not empty
        print STDERR "BS: $bs ($^O, $dlsrc)\n" if $dl_debug;
        eval { do $bs; };
        warn "$bs: $@@\n" if $@@;
    }

    my $boot_symbol_ref;

    <<$^O-eq-darwin>>
    if ($boot_symbol_ref = dl_find_symbol(0, $bootname, 1)) {
        goto boot; #extension library has already been loaded, e.g. darwin
    }
    <</$^O-eq-darwin>>

    # Many dynamic extension loading problems will appear to come from
    # this section of code: XYZ failed at line 123 of DynaLoader.pm.
    # Often these errors are actually occurring in the initialisation
    # C code of the extension XS file. Perl reports the error as being
    # in this perl code simply because this was the last perl code
    # it executed.

    my $flags = $module->dl_load_flags;
    <<$^O-eq-android>>
    # See the note above regarding the linker.
    $flags = 0x00;
    <</$^O-eq-android>>
    my $libref = dl_load_file($file, $flags) or
	croak("Can't load '$file' for module $module: ".dl_error());

    push(@@dl_librefs,$libref);  # record loaded object
<<$^O-eq-freemint>>
    my @@unresolved = dl_undef_symbols();
    if (@@unresolved) {
	require Carp;
	Carp::carp("Undefined symbols present after loading $file: @@unresolved\n");
    }
<</$^O-eq-freemint>>
    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or
         croak("Can't find '$bootname' symbol in $file\n");

    push(@@dl_modules, $module); # record loaded module

  boot:
    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);

    # See comment block above

	push(@@dl_shared_objects, $file); # record files loaded

    &$xs(@@args);
}

sub dl_findfile {
    # This function does not automatically consider the architecture
    # or the perl library auto directories.
    my (@@args) = @@_;
    my (@@dirs,  $dir);   # which directories to search
    my (@@found);         # full paths to real files we have found
    #my $dl_ext= <<=to_string($Config::Config{'dlext'})>>; # $Config::Config{'dlext'} suffix for perl extensions
    #my $dl_so = <<=to_string($Config::Config{'so'})>>; # $Config::Config{'so'} suffix for shared libraries

    print STDERR "dl_findfile(@@args)\n" if $dl_debug;

    # accumulate directories but process files as they appear
    arg: foreach(@@args) {
        #  Special fast case: full filepath requires no search
	<<$^O-eq-VMS>>
        if (m%[:>/\]]% && -f $_) {
	    push(@@found,dl_expandspec(VMS::Filespec::vmsify($_)));
	    last arg unless wantarray;
	    next;
        }
	<</$^O-eq-VMS>>
	<<$^O-ne-VMS>>
        if (m:/: && -f $_) {
	    push(@@found,$_);
	    last arg unless wantarray;
	    next;
	}
	<</$^O-ne-VMS>>

        # Deal with directories first:
        #  Using a -L prefix is the preferred option (faster and more robust)
        if (m:^-L:) { s/^-L//; push(@@dirs, $_); next; }

        #  Otherwise we try to try to spot directories by a heuristic
        #  (this is a more complicated issue than it first appears)
        if (m:/: && -d $_) {   push(@@dirs, $_); next; }

	<<$^O-eq-VMS>>
        # VMS: we may be using native VMS directory syntax instead of
        # Unix emulation, so check this as well
        if (/[:>\]]/ && -d $_) {   push(@@dirs, $_); next; }
	<</$^O-eq-VMS>>

        #  Only files should get this far...
        my(@@names, $name);    # what filenames to look for
        if (m:-l: ) {          # convert -lname to appropriate library name
            s/-l//;
            push(@@names,"lib$_.$dl_so");
            push(@@names,"lib$_.a");
        } else {                # Umm, a bare name. Try various alternatives:
            # these should be ordered with the most likely first
            push(@@names,"$_.$dl_dlext")    unless m/\.$dl_dlext$/o;
            push(@@names,"$_.$dl_so")     unless m/\.$dl_so$/o;
	    <<$^O-eq-cygwin>>
            push(@@names,"cyg$_.$dl_so")  unless m:/:;
	    <</$^O-eq-cygwin>>
            push(@@names,"lib$_.$dl_so")  unless m:/:;
            push(@@names, $_);
        }
	my $dirsep = '/';
	<<$^O-eq-symbian>>
	$dirsep = '\\';
	if ($0 =~ /^([a-z]):/i) {
	    my $drive = $1;
	    @@dirs = map { "$drive:$_" } @@dirs;
	    @@dl_library_path = map { "$drive:$_" } @@dl_library_path;
	}
	<</$^O-eq-symbian>>
        foreach $dir (@@dirs, @@dl_library_path) {
            next unless -d $dir;
	    <<$^O-eq-VMS>>
            chop($dir = VMS::Filespec::unixpath($dir));
	    <</$^O-eq-VMS>>
            foreach $name (@@names) {
		my($file) = "$dir$dirsep$name";
                print STDERR " checking in $dir for $name\n" if $dl_debug;
		$file = ($do_expand) ? dl_expandspec($file) : (-f $file && $file);
		#$file = _check_file($file);
		if ($file) {
                    push(@@found, $file);
                    next arg; # no need to look any further
                }
            }
        }
    }
    if ($dl_debug) {
        foreach(@@dirs) {
            print STDERR " dl_findfile ignored non-existent directory: $_\n" unless -d $_;
        }
        print STDERR "dl_findfile found: @@found\n";
    }
    return $found[0] unless wantarray;
    @@found;
}


<<$^O-eq-VMS>>
# dl_expandspec should be defined in dl_vms.xs
<<|$^O-eq-VMS>>
sub dl_expandspec {
    my($spec) = @@_;
    # Optional function invoked if DynaLoader.pm sets $do_expand.
    # Most systems do not require or use this function.
    # Some systems may implement it in the dl_*.xs file in which case
    # this Perl version should be excluded at build time.

    # This function is designed to deal with systems which treat some
    # 'filenames' in a special way. For example VMS 'Logical Names'
    # (something like unix environment variables - but different).
    # This function should recognise such names and expand them into
    # full file paths.
    # Must return undef if $spec is invalid or file does not exist.

    my $file = $spec; # default output to input

	return undef unless -f $file;
    print STDERR "dl_expandspec($spec) => $file\n" if $dl_debug;
    $file;
}
<</$^O-eq-VMS>>

sub dl_find_symbol_anywhere
{
    my $sym = shift;
    my $libref;
    foreach $libref (@@dl_librefs) {
	my $symref = dl_find_symbol($libref,$sym,1);
	return $symref if $symref;
    }
    return undef;
}

__END__

=head1 NAME

DynaLoader - Dynamically load C libraries into Perl code

=head1 SYNOPSIS

    package YourPackage;
    require DynaLoader;
    @@ISA = qw(... DynaLoader ...);
    bootstrap YourPackage;

    # optional method for 'global' loading
    sub dl_load_flags { 0x01 }     


=head1 DESCRIPTION

This document defines a standard generic interface to the dynamic
linking mechanisms available on many platforms.  Its primary purpose is
to implement automatic dynamic loading of Perl modules.

This document serves as both a specification for anyone wishing to
implement the DynaLoader for a new platform and as a guide for
anyone wishing to use the DynaLoader directly in an application.

The DynaLoader is designed to be a very simple high-level
interface that is sufficiently general to cover the requirements
of SunOS, HP-UX, Linux, VMS and other platforms.

It is also hoped that the interface will cover the needs of OS/2, NT
etc and also allow pseudo-dynamic linking (using C<ld -A> at runtime).

It must be stressed that the DynaLoader, by itself, is practically
useless for accessing non-Perl libraries because it provides almost no
Perl-to-C 'glue'.  There is, for example, no mechanism for calling a C
library function or supplying arguments.  A C::DynaLib module
is available from CPAN sites which performs that function for some
common system types.  And since the year 2000, there's also Inline::C,
a module that allows you to write Perl subroutines in C.  Also available
from your local CPAN site.

DynaLoader Interface Summary

  @@dl_library_path
  @@dl_resolve_using
  @@dl_require_symbols
  $dl_debug
  $dl_dlext
  @@dl_librefs
  @@dl_modules
  @@dl_shared_objects
                                                  Implemented in:
  bootstrap($modulename)                               Perl
  @@filepaths = dl_findfile(@@names)                     Perl
  $flags = $modulename->dl_load_flags                  Perl
  $symref  = dl_find_symbol_anywhere($symbol)          Perl

  $libref  = dl_load_file($filename, $flags)           C
  $status  = dl_unload_file($libref)                   C
  $symref  = dl_find_symbol($libref, $symbol)          C
  @@symbols = dl_undef_symbols()                        C
  dl_install_xsub($name, $symref [, $filename])        C
  $message = dl_error                                  C

=over 4

=item @@dl_library_path

The standard/default list of directories in which dl_findfile() will
search for libraries etc.  Directories are searched in order:
$dl_library_path[0], [1], ... etc

@@dl_library_path is initialised to hold the list of 'normal' directories
(F</usr/lib>, etc) determined by B<Configure> (C<$Config{'libpth'}>).  This should
ensure portability across a wide range of platforms.

@@dl_library_path should also be initialised with any other directories
that can be determined from the environment at runtime (such as
LD_LIBRARY_PATH for SunOS).

After initialisation @@dl_library_path can be manipulated by an
application using push and unshift before calling dl_findfile().
Unshift can be used to add directories to the front of the search order
either to save search time or to override libraries with the same name
in the 'normal' directories.

The load function that dl_load_file() calls may require an absolute
pathname.  The dl_findfile() function and @@dl_library_path can be
used to search for and return the absolute pathname for the
library/object that you wish to load.

=item @@dl_resolve_using

A list of additional libraries or other shared objects which can be
used to resolve any undefined symbols that might be generated by a
later call to load_file().

This is only required on some platforms which do not handle dependent
libraries automatically.  For example the Socket Perl extension
library (F<auto/Socket/Socket.so>) contains references to many socket
functions which need to be resolved when it's loaded.  Most platforms
will automatically know where to find the 'dependent' library (e.g.,
F</usr/lib/libsocket.so>).  A few platforms need to be told the
location of the dependent library explicitly.  Use @@dl_resolve_using
for this.

Example usage:

    @@dl_resolve_using = dl_findfile('-lsocket');

=item @@dl_require_symbols

A list of one or more symbol names that are in the library/object file
to be dynamically loaded.  This is only required on some platforms.

=item @@dl_librefs

An array of the handles returned by successful calls to dl_load_file(),
made by bootstrap, in the order in which they were loaded.
Can be used with dl_find_symbol() to look for a symbol in any of
the loaded files.

=item @@dl_modules

An array of module (package) names that have been bootstrap'ed.

=item @@dl_shared_objects

An array of file names for the shared objects that were loaded.

=item dl_error()

Syntax:

    $message = dl_error();

Error message text from the last failed DynaLoader function.  Note
that, similar to errno in unix, a successful function call does not
reset this message.

Implementations should detect the error as soon as it occurs in any of
the other functions and save the corresponding message for later
retrieval.  This will avoid problems on some platforms (such as SunOS)
where the error message is very temporary (e.g., dlerror()).

=item $dl_debug

Internal debugging messages are enabled when $dl_debug is set true.
Currently setting $dl_debug only affects the Perl side of the
DynaLoader.  These messages should help an application developer to
resolve any DynaLoader usage problems.

$dl_debug is set to C<$ENV{'PERL_DL_DEBUG'}> if defined.

For the DynaLoader developer/porter there is a similar debugging
variable added to the C code (see dlutils.c) and enabled if Perl was
built with the B<-DDEBUGGING> flag.  This can also be set via the
PERL_DL_DEBUG environment variable.  Set to 1 for minimal information or
higher for more.

=item $dl_dlext

When specified (localised) in a module's F<.pm> file, indicates the extension
which the module's loadable object will have. For example:

    local $DynaLoader::dl_dlext = 'unusual_ext';

would indicate that the module's loadable object has an extension of
C<unusual_ext> instead of the more usual C<$Config{dlext}>.  NOTE: This also
requires that the module's F<Makefile.PL> specify (in C<WriteMakefile()>):

    DLEXT => 'unusual_ext',

=item dl_findfile()

Syntax:

    @@filepaths = dl_findfile(@@names)

Determine the full paths (including file suffix) of one or more
loadable files given their generic names and optionally one or more
directories.  Searches directories in @@dl_library_path by default and
returns an empty list if no files were found.

Names can be specified in a variety of platform independent forms.  Any
names in the form B<-lname> are converted into F<libname.*>, where F<.*> is
an appropriate suffix for the platform.

If a name does not already have a suitable prefix and/or suffix then
the corresponding file will be searched for by trying combinations of
prefix and suffix appropriate to the platform: "$name.o", "lib$name.*"
and "$name".

If any directories are included in @@names they are searched before
@@dl_library_path.  Directories may be specified as B<-Ldir>.  Any other
names are treated as filenames to be searched for.

Using arguments of the form C<-Ldir> and C<-lname> is recommended.

Example: 

    @@dl_resolve_using = dl_findfile(qw(-L/usr/5lib -lposix));


=item dl_expandspec()

Syntax:

    $filepath = dl_expandspec($spec)

Some unusual systems, such as VMS, require special filename handling in
order to deal with symbolic names for files (i.e., VMS's Logical Names).

To support these systems a dl_expandspec() function can be implemented
either in the F<dl_*.xs> file or code can be added to the dl_expandspec()
function in F<DynaLoader.pm>.  See F<DynaLoader_pm.PL> for more information.

=item dl_load_file()

Syntax:

    $libref = dl_load_file($filename, $flags)

Dynamically load $filename, which must be the path to a shared object
or library.  An opaque 'library reference' is returned as a handle for
the loaded object.  Returns undef on error.

The $flags argument to alters dl_load_file behaviour.  
Assigned bits:

 0x01  make symbols available for linking later dl_load_file's.
       (only known to work on Solaris 2 using dlopen(RTLD_GLOBAL))
       (ignored under VMS; this is a normal part of image linking)

(On systems that provide a handle for the loaded object such as SunOS
and HPUX, $libref will be that handle.  On other systems $libref will
typically be $filename or a pointer to a buffer containing $filename.
The application should not examine or alter $libref in any way.)

This is the function that does the real work.  It should use the
current values of @@dl_require_symbols and @@dl_resolve_using if required.

    SunOS: dlopen($filename)
    HP-UX: shl_load($filename)
    Linux: dld_create_reference(@@dl_require_symbols); dld_link($filename)
    VMS:   lib$find_image_symbol($filename,$dl_require_symbols[0])

(The dlopen() function is also used by Solaris and some versions of
Linux, and is a common choice when providing a "wrapper" on other
mechanisms as is done in the OS/2 port.)

=item dl_unload_file()

Syntax:

    $status = dl_unload_file($libref)

Dynamically unload $libref, which must be an opaque 'library reference' as
returned from dl_load_file.  Returns one on success and zero on failure.
This function is optional and may not necessarily be provided on all platforms.

If it is defined and perl is compiled with the C macro C<DL_UNLOAD_ALL_AT_EXIT>
defined, then it is called automatically when the interpreter exits for
every shared object or library loaded by DynaLoader::bootstrap.  All such
library references are stored in @@dl_librefs by DynaLoader::Bootstrap as it
loads the libraries.  The files are unloaded in last-in, first-out order.

This unloading is usually necessary when embedding a shared-object perl (e.g.
one configured with -Duseshrplib) within a larger application, and the perl
interpreter is created and destroyed several times within the lifetime of the
application.  In this case it is possible that the system dynamic linker will
unload and then subsequently reload the shared libperl without relocating any
references to it from any files DynaLoaded by the previous incarnation of the
interpreter.  As a result, any shared objects opened by DynaLoader may point to
a now invalid 'ghost' of the libperl shared object, causing apparently random
memory corruption and crashes.  This behaviour is most commonly seen when using
Apache and mod_perl built with the APXS mechanism.

    SunOS: dlclose($libref)
    HP-UX: ???
    Linux: ???
    VMS:   ???

(The dlclose() function is also used by Solaris and some versions of
Linux, and is a common choice when providing a "wrapper" on other
mechanisms as is done in the OS/2 port.)

=item dl_load_flags()

Syntax:

    $flags = dl_load_flags $modulename;

Designed to be a method call, and to be overridden by a derived class
(i.e. a class which has DynaLoader in its @@ISA).  The definition in
DynaLoader itself returns 0, which produces standard behavior from
dl_load_file().

=item dl_find_symbol()

Syntax:

    $symref = dl_find_symbol($libref, $symbol)

Return the address of the symbol $symbol or C<undef> if not found.  If the
target system has separate functions to search for symbols of different
types then dl_find_symbol() should search for function symbols first and
then other types.

The exact manner in which the address is returned in $symref is not
currently defined.  The only initial requirement is that $symref can
be passed to, and understood by, dl_install_xsub().

    SunOS: dlsym($libref, $symbol)
    HP-UX: shl_findsym($libref, $symbol)
    Linux: dld_get_func($symbol) and/or dld_get_symbol($symbol)
    VMS:   lib$find_image_symbol($libref,$symbol)


=item dl_find_symbol_anywhere()

Syntax:

    $symref = dl_find_symbol_anywhere($symbol)

Applies dl_find_symbol() to the members of @@dl_librefs and returns
the first match found.

=item dl_undef_symbols()

Example

    @@symbols = dl_undef_symbols()

Return a list of symbol names which remain undefined after load_file().
Returns C<()> if not known.  Don't worry if your platform does not provide
a mechanism for this.  Most do not need it and hence do not provide it,
they just return an empty list.


=item dl_install_xsub()

Syntax:

    dl_install_xsub($perl_name, $symref [, $filename])

Create a new Perl external subroutine named $perl_name using $symref as
a pointer to the function which implements the routine.  This is simply
a direct call to newXS()/newXS_flags().  Returns a reference to the installed
function.

The $filename parameter is used by Perl to identify the source file for
the function if required by die(), caller() or the debugger.  If
$filename is not defined then "DynaLoader" will be used.


=item bootstrap()

Syntax:

bootstrap($module [...])

This is the normal entry point for automatic dynamic loading in Perl.

It performs the following actions:

=over 8

=item *

locates an auto/$module directory by searching @@INC

=item *

uses dl_findfile() to determine the filename to load

=item *

sets @@dl_require_symbols to C<("boot_$module")>

=item *

executes an F<auto/$module/$module.bs> file if it exists
(typically used to add to @@dl_resolve_using any files which
are required to load the module on the current platform)

=item *

calls dl_load_flags() to determine how to load the file.

=item *

calls dl_load_file() to load the file

=item *

calls dl_undef_symbols() and warns if any symbols are undefined

=item *

calls dl_find_symbol() for "boot_$module"

=item *

calls dl_install_xsub() to install it as "${module}::bootstrap"

=item *

calls &{"${module}::bootstrap"} to bootstrap the module (actually
it uses the function reference returned by dl_install_xsub for speed)

=back

All arguments to bootstrap() are passed to the module's bootstrap function.
The default code generated by F<xsubpp> expects $module [, $version]
If the optional $version argument is not given, it defaults to
C<$XS_VERSION // $VERSION> in the module's symbol table. The default code
compares the Perl-space version with the version of the compiled XS code,
and croaks with an error if they do not match.

=back


=head1 AUTHOR

Tim Bunce, 11 August 1994.

This interface is based on the work and comments of (in no particular
order): Larry Wall, Robert Sanders, Dean Roehrich, Jeff Okamoto, Anno
Siegel, Thomas Neumann, Paul Marquess, Charles Bailey, myself and others.

Larry Wall designed the elegant inherited bootstrap mechanism and
implemented the first Perl 5 dynamic loader using it.

Solaris global loading added by Nick Ing-Simmons with design/coding
assistance from Tim Bunce, January 1996.

=cut
EOT

close OUT or die $!;

@


1.1
log
@Initial revision
@
text
@a0 1

d5 1
a5 1
    $value =~ s/\\/\\\\'/g;
d10 57
d71 1
a71 1
# Generated from DynaLoader.pm.PL (resolved %Config::Config values)
d80 1
a80 1
#   (Quote from Tolkien sugested by Anno Siegel.)
d87 3
a89 1
$VERSION = $VERSION = "1.03";	# avoid typo warning
d91 1
a91 2
require AutoLoader;
*AUTOLOAD = \&AutoLoader::AUTOLOAD;
d93 3
a95 6
# The following require can't be removed during maintenance
# releases, sadly, because of the risk of buggy code that does 
# require Carp; Carp::croak "..."; without brackets dying 
# if Carp hasn't been loaded in earlier compile time. :-( 
# We'll let those bugs get found on the development track.
require Carp if $] < 5.00450; 
d97 1
d107 1
a115 2
# ($dl_dlext, $dlsrc)
#         = @@Config::Config{'dlext', 'dlsrc'};
d118 11
a128 3
print OUT "  (\$dl_dlext, \$dlsrc) = (",
          to_string($Config::Config{'dlext'}), ",",
          to_string($Config::Config{'dlsrc'}), ")\n;" ;
d130 1
a130 1
print OUT <<'EOT';
d132 1
d137 32
a168 1
$do_expand = $Is_VMS = $^O eq 'VMS';
d170 33
a202 5
@@dl_require_symbols = ();       # names of symbols we need
@@dl_resolve_using   = ();       # names of files to link with
@@dl_library_path    = ();       # path to look for files
@@dl_librefs         = ();       # things we have loaded
@@dl_modules         = ();       # Modules we have loaded
d204 5
a208 2
# This is a fix to support DLD's unfortunate desire to relink -lc
@@dl_resolve_using = dl_findfile('-lc') if $dlsrc eq "dl_dld.xs";
d210 1
a210 2
# Initialise @@dl_library_path with the 'standard' library path
# for this platform as determined by Configure
d212 5
a216 1
# push(@@dl_library_path, split(' ', $Config::Config{'libpth'});
d219 12
a230 2
print OUT "push(\@@dl_library_path, split(' ', ",
          to_string($Config::Config{'libpth'}), "));\n";
d232 5
a236 1
print OUT <<'EOT';
d238 1
a238 5
# Add to @@dl_library_path any extra directories we can gather from
# environment variables. So far LD_LIBRARY_PATH is the only known
# variable used for this purpose. Others may be added later.
push(@@dl_library_path, split(/:/, $ENV{LD_LIBRARY_PATH}))
    if $ENV{LD_LIBRARY_PATH};
d240 2
d243 29
d273 1
d275 1
a275 2
                                !defined(&dl_load_file);

d288 7
a294 2
# The bootstrap function cannot be autoloaded (without complications)
# so we define it here:
d314 6
d322 1
d329 7
d339 2
a340 1
		"(auto/$modpname/$modfname.$dl_dlext)\n" if $dl_debug;
d342 1
d344 3
a346 2
	chop($_ = VMS::Filespec::unixpath($_)) if $Is_VMS;
	my $dir = "$_/auto/$modpname";
d348 1
a348 1

d350 3
a352 3
	my $try = "$dir/$modfname.$dl_dlext";
	last if $file = ($do_expand) ? dl_expandspec($try) : (-f $try && $try);

d362 1
d370 4
a373 2
    my $bs = $file;
    $bs =~ s/(\.\w+)?$/\.bs/; # look for .bs 'beside' the library
d380 8
d395 7
a401 2
    my $libref = dl_load_file($file, $module->dl_load_flags) or
	croak("Can't load '$file' for module $module: ".dl_error()."\n");
d404 1
a404 1

d410 3
d414 1
a414 2
    my $boot_symbol_ref = dl_find_symbol($libref, $bootname) or
         croak("Can't find '$bootname' symbol in $file\n");
d416 1
d419 3
a421 1
    push(@@dl_modules, $module); # record loaded module
a422 1
    # See comment block above
a425 13

#sub _check_file {   # private utility to handle dl_expandspec vs -f tests
#    my($file) = @@_;
#    return $file if (!$do_expand && -f $file); # the common case
#    return $file if ( $do_expand && ($file=dl_expandspec($file)));
#    return undef;
#}


# Let autosplit and the autoloader deal with these functions:
__END__


a426 1
    # Read ext/DynaLoader/DynaLoader.doc for detailed information.
d432 2
a433 8
EOT

print OUT '    my $dl_ext= ' . to_string($Config::Config{'dlext'}) .
          "; # \$Config::Config{'dlext'} suffix for perl extensions\n";
print OUT '    my $dl_so = ' . to_string($Config::Config{'so'}) .
          "; # \$Config::Config{'so'} suffix for shared libraries\n";

print OUT <<'EOT';
d440 2
a441 1
        if ($Is_VMS && m%[:>/\]]% && -f $_) {
d446 3
a448 1
        elsif (m:/: && -f $_ && !$do_expand) {
d453 1
d463 2
a464 1
        # VMS: we may be using native VMS directry syntax instead of
d466 2
a467 1
        if ($Is_VMS && /[:>\]]/ && -d $_) {   push(@@dirs, $_); next; }
d477 1
a477 1
            push(@@names,"$_.$dl_ext")    unless m/\.$dl_ext$/o;
d479 3
a482 1
            push(@@names,"$_.a")          if !m/\.a$/ and $dlsrc eq "dl_dld.xs";
d485 9
d496 3
a498 1
            chop($dir = VMS::Filespec::unixpath($dir)) if $Is_VMS;
d500 1
a500 1
		my($file) = "$dir/$name";
d522 3
d530 1
a530 1
    # this autoload version will not be called but is harmless.
a540 4
    if ($Is_VMS) { # dl_expandspec should be defined in dl_vms.xs
	require Carp;
	Carp::croak("dl_expandspec: should be defined in XS file!\n");
    } else {
a541 1
    }
d545 1
d552 1
a552 1
	my $symref = dl_find_symbol($libref,$sym);
d558 2
a563 2
dl_error(), dl_findfile(), dl_expandspec(), dl_load_file(), dl_find_symbol(), dl_find_symbol_anywhere(), dl_undef_symbols(), dl_install_xsub(), dl_load_flags(), bootstrap() - routines used by DynaLoader modules

d587 1
a587 1
of SunOS, HP-UX, NeXT, Linux, VMS and other platforms.
d597 3
a599 1
common system types.
d607 1
d610 1
d618 1
d686 4
d720 13
d774 2
a775 3
either in the F<dl_*.xs> file or code can be added to the autoloadable
dl_expandspec() function in F<DynaLoader.pm>.  See F<DynaLoader.pm> for
more information.
a804 1
    NeXT:  rld_load($filename, @@dl_resolve_using)
d811 1
a811 1
=item dl_loadflags()
d815 37
a851 1
    $flags = dl_loadflags $modulename;
a875 1
    NeXT:  rld_lookup("_$symbol")
d908 1
a908 1
a direct call to newXSUB().  Returns a reference to the installed
d920 1
a920 1
bootstrap($module)
d972 7
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d6 1
a6 1
    $value =~ s/\\/\\\\/g;
d31 1
a31 1
$VERSION = "1.04";	# avoid typo warning
a74 1
$Is_MacOS  = $^O eq 'MacOS';
d79 2
a80 2
#@@dl_librefs         = ();       # things we have loaded
#@@dl_modules         = ();       # Modules we have loaded
d96 3
a98 15
# Add to @@dl_library_path any extra directories we can gather
# from environment variables.
if ($Is_MacOS) {
    push(@@dl_library_path, split(/,/, $ENV{LD_LIBRARY_PATH}))
   	if exists $ENV{LD_LIBRARY_PATH};
} else {
    push(@@dl_library_path, split(/:/, $ENV{$Config::Config{ldlibpthname}}))
    	if exists      $Config::Config{ldlibpthname}        &&
                       $Config::Config{ldlibpthname}  ne '' &&
                exists $ENV{$Config::Config{ldlibpthname}}       ;;
    push(@@dl_library_path, split(/:/, $ENV{$Config::Config{ldlibpthname}}))
    	if exists      $Config::Config{ldlibpthname}        &&
                       $Config::Config{ldlibpthname}  ne '' &&
                exists $ENV{$Config::Config{ldlibpthname}}       ;;
# E.g. HP-UX supports both its native SHLIB_PATH *and* LD_LIBRARY_PATH.
d100 2
a101 2
    if exists $ENV{LD_LIBRARY_PATH};
}
a118 8
sub bootstrap_inherit {
    my $module = $_[0];
    local *isa = *{"$module\::ISA"};
    local @@isa = (@@isa, 'DynaLoader');
    # Cannot goto due to delocalization.  Will report errors on a wrong line?
    bootstrap(@@_);
}

d148 1
a148 1
    my $modpname = join(($Is_MacOS ? ':' : '/'),@@modparts);
d151 1
a151 4
		($Is_MacOS
                      ? "(auto/$modpname/$modfname.$dl_dlext)\n" :
		 	"(:auto:$modpname:$modfname.$dl_dlext)\n")
	if $dl_debug;
d155 1
a155 7
	my $dir;
	if ($Is_MacOS) {
	    chop $_  if /:$/;
	    $dir = "$_:auto:$modpname";
	} else {
	    $dir = "$_/auto/$modpname";
	}
d159 1
a159 1
	my $try = $Is_MacOS ? "$dir:$modfname.$dl_dlext" : "$dir/$modfname.$dl_dlext";
a170 1
    $file = uc($file) if $Is_VMS && $Config{d_vms_case_sensitive_symbols};
d179 1
a179 1
    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
d194 1
a194 1
	croak("Can't load '$file' for module $module: ".dl_error());
a253 6
	elsif ($Is_MacOS) {
	    if (m/:/ && -f $_) {
	    	push(@@found,$_);
	    	last arg unless wantarray;
	    }
	}
a263 24
	if ($Is_MacOS) {
            #  Otherwise we try to try to spot directories by a heuristic
            #  (this is a more complicated issue than it first appears)
	    if (m/:/ && -d $_) {   push(@@dirs, $_); next; }
            #  Only files should get this far...
            my(@@names, $name);    # what filenames to look for
	    s/^-l//;
	    push(@@names, $_);
            foreach $dir (@@dirs, @@dl_library_path) {
            	next unless -d $dir;
		$dir =~ s/^([^:]+)$/:$1/;
		$dir =~ s/:$//;
            	foreach $name (@@names) {
	    	    my($file) = "$dir:$name";
                    print STDERR " checking in $dir for $name\n" if $dl_debug;
		    if (-f $file) {
                    	push(@@found, $file);
                    	next arg; # no need to look any further
                    }
                }
	    }
	    next;
	}
	
d353 1
a353 1
dl_error(), dl_findfile(), dl_expandspec(), dl_load_file(), dl_unload_file(), dl_find_symbol(), dl_find_symbol_anywhere(), dl_undef_symbols(), dl_install_xsub(), dl_load_flags(), bootstrap() - routines used by DynaLoader modules
a404 1
  $status  = dl_unload_file($libref)                   C
a578 36
Linux, and is a common choice when providing a "wrapper" on other
mechanisms as is done in the OS/2 port.)

=item dl_unload_file()

Syntax:

    $status = dl_unload_file($libref)

Dynamically unload $libref, which must be an opaque 'library reference' as
returned from dl_load_file.  Returns one on success and zero on failure.

This function is optional and may not necessarily be provided on all platforms.
If it is defined, it is called automatically when the interpreter exits for
every shared object or library loaded by DynaLoader::bootstrap.  All such
library references are stored in @@dl_librefs by DynaLoader::Bootstrap as it
loads the libraries.  The files are unloaded in last-in, first-out order.

This unloading is usually necessary when embedding a shared-object perl (e.g.
one configured with -Duseshrplib) within a larger application, and the perl
interpreter is created and destroyed several times within the lifetime of the
application.  In this case it is possible that the system dynamic linker will
unload and then subsequently reload the shared libperl without relocating any
references to it from any files DynaLoaded by the previous incarnation of the
interpreter.  As a result, any shared objects opened by DynaLoader may point to
a now invalid 'ghost' of the libperl shared object, causing apparently random
memory corruption and crashes.  This behaviour is most commonly seen when using
Apache and mod_perl built with the APXS mechanism.

    SunOS: dlclose($libref)
    HP-UX: ???
    Linux: ???
    NeXT:  ???
    VMS:   ???

(The dlclose() function is also used by Solaris and some versions of
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d1 1
d15 1
a15 1
# Generated from DynaLoader.pm.PL
d24 1
a24 1
#   (Quote from Tolkien suggested by Anno Siegel.)
d31 1
a31 3
use vars qw($VERSION *AUTOLOAD);

$VERSION = 1.04;	# avoid typo warning
a35 2
use Config;

d43 1
d74 1
a74 2
$Is_VMS    = $^O eq 'VMS';
$do_expand = $Is_VMS;
d80 2
a81 2
@@dl_librefs         = ();       # things we have loaded
@@dl_modules         = ();       # Modules we have loaded
d86 2
a87 1
EOT
d89 1
a89 2
my $cfg_dl_library_path = <<'EOT';
push(@@dl_library_path, split(' ', $Config::Config{libpth}));
d92 2
a93 3
sub dquoted_comma_list {
    join(", ", map {qq("$_")} @@_);
}
d95 1
a95 48
if ($ENV{PERL_BUILD_EXPAND_CONFIG_VARS}) {
    eval $cfg_dl_library_path;
    if (!$ENV{PERL_BUILD_EXPAND_ENV_VARS}) {
        my $dl_library_path = dquoted_comma_list(@@dl_library_path);
        print OUT <<EOT;
# The below \@@dl_library_path has been expanded (%Config) in Perl build time.

\@@dl_library_path = ($dl_library_path);

EOT
    }
}
else {
    print OUT <<EOT;
# Initialise \@@dl_library_path with the 'standard' library path
# for this platform as determined by Configure.

$cfg_dl_library_path

EOT
}

my $ldlibpthname;
my $ldlibpthname_defined;
my $pthsep;

if ($ENV{PERL_BUILD_EXPAND_CONFIG_VARS}) {
    $ldlibpthname         = $Config::Config{ldlibpthname};
    $ldlibpthname_defined = defined $Config::Config{ldlibpthname} ? 1 : 0;
    $pthsep               = $Config::Config{path_sep};
}
else {
    $ldlibpthname         = q($Config::Config{ldlibpthname});
    $ldlibpthname_defined = q(defined $Config::Config{ldlibpthname});
    $pthsep               = q($Config::Config{path_sep});
    print OUT <<EOT;
my \$ldlibpthname         = $ldlibpthname;
my \$ldlibpthname_defined = $ldlibpthname_defined;
my \$pthsep               = $pthsep;

EOT
}

my $env_dl_library_path = <<'EOT';
if ($ldlibpthname_defined &&
    exists $ENV{$ldlibpthname}) {
    push(@@dl_library_path, split(/$pthsep/, $ENV{$ldlibpthname}));
}
d97 14
d112 2
a113 5

if ($ldlibpthname_defined &&
    $ldlibpthname ne 'LD_LIBRARY_PATH' &&
    exists $ENV{LD_LIBRARY_PATH}) {
    push(@@dl_library_path, split(/$pthsep/, $ENV{LD_LIBRARY_PATH}));
a114 9
EOT

if ($ENV{PERL_BUILD_EXPAND_CONFIG_VARS} && $ENV{PERL_BUILD_EXPAND_ENV_VARS}) {
    eval $env_dl_library_path;
}
else {
    print OUT <<EOT;
# Add to \@@dl_library_path any extra directories we can gather from environment
# during runtime.
a115 17
$env_dl_library_path

EOT
}

if ($ENV{PERL_BUILD_EXPAND_CONFIG_VARS} && $ENV{PERL_BUILD_EXPAND_ENV_VARS}) {
    my $dl_library_path = dquoted_comma_list(@@dl_library_path);
    print OUT <<EOT;
# The below \@@dl_library_path has been expanded (%Config, %ENV)
# in Perl build time.

\@@dl_library_path = ($dl_library_path);

EOT
}

print OUT <<'EOT';
a116 1
# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB
d118 2
a119 1
                                !defined(&dl_error);
d173 2
a174 2
		       ? "(:auto:$modpname:$modfname.$dl_dlext)\n" :
		       "(auto/$modpname/$modfname.$dl_dlext)\n")
d201 1
a201 1
    $file = uc($file) if $Is_VMS && $Config::Config{d_vms_case_sensitive_symbols};
d329 1
a329 1
        # VMS: we may be using native VMS directory syntax instead of
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a79 3
my $Mac_FS;
$Mac_FS = eval { require Mac::FileSpec::Unixish } if $Is_MacOS;

d83 2
a84 4

#XSLoader.pm may have added elements before we were required
#@@dl_librefs         = ();       # things we have loaded
#@@dl_modules         = ();       # Modules we have loaded
a234 5
    # Truncate the module name to 8.3 format for NetWare
	if (($^O eq 'NetWare') && (length($modfname) > 8)) {
		$modfname = substr($modfname, 0, 8);
	}

d247 2
a248 6
	    my $path = $_;
	    if ($Mac_FS && ! -d $path) {
		$path = Mac::FileSpec::Unixish::nativize($path);
	    }
	    $path .= ":"  unless /:$/;
	    $dir = "${path}auto:$modpname";
a251 1
	
d253 1
a253 1
	
d256 2
a257 2
	last if $file = ($do_expand) ? dl_expandspec($try) : ((-f $try) && $try);
	
a282 8
    my $boot_symbol_ref;

    if ($^O eq 'darwin') {
        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {
            goto boot; #extension library has already been loaded, e.g. darwin
        }
    }

d301 1
a301 1
    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or
d304 2
a307 3
  boot:
    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);

d515 1
a515 3
common system types.  And since the year 2000, there's also Inline::C,
a module that allows you to write Perl subroutines in C.  Also available
from your local CPAN site.
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d32 1
a32 1
$VERSION = '1.04';	# avoid typo warning
a231 9
EOT

print OUT <<'EOT' if $^O eq 'os2';
    # Can dynaload, but cannot dynaload Perl modules...
    die 'Dynaloaded Perl modules are not available in this build of Perl' if $OS2::is_static;

EOT

print OUT <<'EOT';
d772 1
a772 1
=item dl_load_flags()
d776 1
a776 1
    $flags = dl_load_flags $modulename;
@


1.1.1.6
log
@perl 5.8.3 from CPAN
@
text
@d513 2
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d32 1
a32 1
$VERSION = '1.05';	# avoid typo warning
a87 1
#@@dl_shared_objects  = ();       # shared objects for symbols we have 
a341 3

	push(@@dl_shared_objects, $file); # record files loaded

a557 1
  @@dl_shared_objects
a631 4

=item @@dl_shared_objects

An array of file names for the shared objects that were loaded.
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@a9 57
#
# subroutine expand_os_specific expands $^O-specific preprocessing information
# so that it will not be re-calculated at runtime in Dynaloader.pm
#
# Syntax of preprocessor should be kept extremely simple:
#  - directives are in double angle brackets <<...>>
#  - <<=string>> will be just evaluated
#  - for $^O-specific there are two forms:
#   <<$^O-eq-osname>>
#   <<$^O-ne-osname>>
#  this directive should be closed with respectively
#   <</$^O-eq-osname>>
#   <</$^O-ne-osname>>
#  construct <<|$^O-ne-osname>> means #else
#  nested <<$^O...>>-constructs are allowed but nested values must be for 
#   different OS-names!
#   
#  -- added by VKON, 03-10-2004 to separate $^O-specific between OSes
#     (so that Win32 never checks for $^O eq 'VMS' for example)
#
# The $^O tests test both for $^O and for $Config{osname}.
# The latter is better for some for cross-compilation setups.
#
sub expand_os_specific {
    my $s = shift;
    for ($s) {
	s/<<=(.*?)>>/$1/gee;
	s/<<\$\^O-(eq|ne)-(\w+)>>(.*?)<<\/\$\^O-\1-\2>>/
	  my ($op, $os, $expr) = ($1,$2,$3);
	  if ($op ne 'eq' and $op ne 'ne') {die "wrong eq-ne arg in $&"};
	  if ($expr =~ m[^(.*?)<<\|\$\^O-$op-$os>>(.*?)$]s) {
	      # #if;#else;#endif
	      my ($if,$el) = ($1,$2);
	      if (($op eq 'eq' and ($^O eq $os || $Config{osname} eq $os)) || ($op eq 'ne' and ($^O ne $os || $Config{osname} ne $os))) {
		  $if
	      }
	      else {
		  $el
	      }
	  }
	  else {
	      # #if;#endif
	      if (($op eq 'eq' and ($^O eq $os || $Config{osname} eq $os)) || ($op eq 'ne' and ($^O ne $os || $Config{osname} ne $os))) {
		  $expr
	      }
	      else {
	      	  ""
	      }
	  }
	/ges;
	if (/<<(=|\$\^O-)/) {die "bad <<\$^O-eq/ne-osname>> expression.".
	    " Unclosed brackets?";
	}
    }
    $s;
}

d14 1
a14 1
# Generated from DynaLoader_pm.PL
d30 3
a32 3
BEGIN {
    $VERSION = '1.08';
}
d39 7
d66 3
a68 4
$dl_dlext = $Config::Config{'dlext'};
$dl_so = $Config::Config{'so'};
print OUT "  (\$dl_dlext, \$dlsrc) = ('$dl_dlext', ",
          to_string($Config::Config{'dlsrc'}), ")\n;";
d70 1
a70 1
print OUT expand_os_specific(<<'EOT');
a71 1
<<$^O-eq-VMS>>
d77 2
a78 2
<</$^O-eq-VMS>>
$do_expand = <<$^O-eq-VMS>>1<<|$^O-eq-VMS>>0<</$^O-eq-VMS>>;
a79 1
<<$^O-eq-MacOS>>
d81 1
a81 2
$Mac_FS = eval { require Mac::FileSpec::Unixish };
<</$^O-eq-MacOS>>
d102 1
a102 1
    join(", ", map {'"'.quotemeta($_).'"'} @@_);
d132 3
a134 3
    $ldlibpthname         = to_string($Config::Config{ldlibpthname});
    $ldlibpthname_defined = to_string(defined $Config::Config{ldlibpthname} ? 1 : 0);
    $pthsep               = to_string($Config::Config{path_sep});
d140 1
a140 2
}
print OUT <<EOT;
d146 1
d187 1
a187 3

# following long string contains $^O-specific stuff, which is factored out
print OUT expand_os_specific(<<'EOT');
d233 1
d235 1
a235 1
    <<$^O-eq-os2>>
d239 3
a241 1
    <</$^O-eq-os2>>
a249 1
    <<$^O-eq-NetWare>>
d251 1
a251 1
	if ((length($modfname) > 8)) {
a253 1
    <</$^O-eq-NetWare>>
d255 1
a255 1
    my $modpname = join(<<$^O-eq-MacOS>>':'<<|$^O-eq-MacOS>>'/'<</$^O-eq-MacOS>>,@@modparts);
d258 3
a260 2
		       <<$^O-eq-MacOS>> "(:auto:$modpname:$modfname.<<=$dl_dlext>>)\n" 
		       <<|$^O-eq-MacOS>>"(auto/$modpname/$modfname.<<=$dl_dlext>>)\n"<</$^O-eq-MacOS>>
d264 3
a266 2
	<<$^O-eq-VMS>>chop($_ = VMS::Filespec::unixpath($_));<</$^O-eq-VMS>>
	<<$^O-eq-MacOS>>
d272 4
a275 4
	    my $dir = "${path}auto:$modpname";
	<<|$^O-eq-MacOS>>
	    my $dir = "$_/auto/$modpname";
	<</$^O-eq-MacOS>>
d280 2
a281 4
	my $try = <<$^O-eq-MacOS>> "$dir:$modfname.<<=$dl_dlext>>" <<|$^O-eq-MacOS>> "$dir/$modfname.<<=$dl_dlext>>"<</$^O-eq-MacOS>>;
	last if $file = <<$^O-eq-VMS>>($do_expand) ? dl_expandspec($try) : ((-f $try) && $try);
	<<|$^O-eq-VMS>>(-f $try) && $try;
	<</$^O-eq-VMS>>
d292 1
a292 1
    <<$^O-eq-VMS>>$file = uc($file) if $Config::Config{d_vms_case_sensitive_symbols};<</$^O-eq-VMS>>
d310 4
a313 3
    <<$^O-eq-darwin>>
    if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {
        goto boot; #extension library has already been loaded, e.g. darwin
a314 1
    <</$^O-eq-darwin>>
d369 8
a376 2
    #my $dl_ext= <<=to_string($Config::Config{'dlext'})>>; # $Config::Config{'dlext'} suffix for perl extensions
    #my $dl_so = <<=to_string($Config::Config{'so'})>>; # $Config::Config{'so'} suffix for shared libraries
d383 1
a383 2
	<<$^O-eq-VMS>>
        if (m%[:>/\]]% && -f $_) {
d388 1
a388 2
	<</$^O-eq-VMS>>
	<<$^O-eq-MacOS>>
d393 2
a394 3
	<</$^O-eq-MacOS>>
	<<$^O-ne-VMS>>
        if (m:/: && -f $_) {
a398 1
	<</$^O-ne-VMS>>
d404 1
a404 1
	<<$^O-eq-MacOS>>
d426 1
a426 1
	<</$^O-eq-MacOS>>
a431 1
	<<$^O-eq-VMS>>
d434 1
a434 2
        if (/[:>\]]/ && -d $_) {   push(@@dirs, $_); next; }
	<</$^O-eq-VMS>>
d440 1
a440 1
            push(@@names,"lib$_.<<=$dl_so>>");
d444 3
a446 3
            push(@@names,"$_.<<=$dl_dlext>>")    unless m/\.<<=$dl_dlext>>$/o;
            push(@@names,"$_.<<=$dl_so>>")     unless m/\.<<=$dl_so>>$/o;
            push(@@names,"lib$_.<<=$dl_so>>")  unless m:/:;
a449 9
	my $dirsep = '/';
	<<$^O-eq-symbian>>
	$dirsep = '\\';
	if ($0 =~ /^([a-z]):/i) {
	    my $drive = $1;
	    @@dirs = map { "$drive:$_" } @@dirs;
	    @@dl_library_path = map { "$drive:$_" } @@dl_library_path;
	}
	<</$^O-eq-symbian>>
d452 1
a452 3
	    <<$^O-eq-VMS>>
            chop($dir = VMS::Filespec::unixpath($dir));
	    <</$^O-eq-VMS>>
d454 1
a454 1
		my($file) = "$dir$dirsep$name";
d492 1
a492 2
    <<$^O-eq-VMS>>
        # dl_expandspec should be defined in dl_vms.xs
d495 1
a495 1
    <<|$^O-eq-VMS>>
d497 1
a497 1
    <</$^O-eq-VMS>>
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d88 1
a88 1
    $VERSION = '1.10';
d112 2
d116 4
a119 11
if ($ENV{PERL_BUILD_EXPAND_CONFIG_VARS}) {
    print OUT "(\$dl_dlext, \$dl_so, \$dlsrc) = (",
              to_string($Config{'dlext'}), ",",
              to_string($Config{'so'}), ",",
              to_string($Config{'dlsrc'}), ")\n;" ;
}
else {
    print OUT <<'EOT';
($dl_dlext, $dl_so, $dlsrc) = @@Config::Config{qw(dlext so dlsrc)};
EOT
}
d313 2
a314 2
		       <<$^O-eq-MacOS>> "(:auto:$modpname:$modfname.$dl_dlext)\n" 
		       <<|$^O-eq-MacOS>>"(auto/$modpname/$modfname.$dl_dlext)\n"<</$^O-eq-MacOS>>
d333 4
a336 2
	my $try = <<$^O-eq-MacOS>> "$dir:$modfname.$dl_dlext" <<|$^O-eq-MacOS>> "$dir/$modfname.$dl_dlext"<</$^O-eq-MacOS>>;
	last if $file = ($do_expand) ? dl_expandspec($try) : ((-f $try) && $try);
d495 1
a495 1
            push(@@names,"lib$_.$dl_so");
d499 3
a501 3
            push(@@names,"$_.$dl_dlext")    unless m/\.$dl_dlext$/o;
            push(@@names,"$_.$dl_so")     unless m/\.$dl_so$/o;
            push(@@names,"lib$_.$dl_so")  unless m:/:;
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d88 1
a88 1
    $VERSION = '1.14';
d91 3
d137 5
d273 3
d315 1
a315 1
    my $modpname = join('/',@@modparts);
d318 2
a319 1
		       "(auto/$modpname/$modfname.$dl_dlext)\n"
d324 8
d333 1
d338 1
a338 1
	my $try = "$dir/$modfname.$dl_dlext";
d407 13
d442 6
d460 24
a503 3
	    <<$^O-eq-cygwin>>
            push(@@names,"cyg$_.$dl_so")  unless m:/:;
	    <</$^O-eq-cygwin>>
a544 3
<<$^O-eq-VMS>>
# dl_expandspec should be defined in dl_vms.xs
<<|$^O-eq-VMS>>
d550 1
a550 1
    # this Perl version should be excluded at build time.
d561 5
d567 1
a570 1
<</$^O-eq-VMS>>
a582 2
__END__

d783 3
a785 2
either in the F<dl_*.xs> file or code can be added to the dl_expandspec()
function in F<DynaLoader.pm>.  See F<DynaLoader_pm.PL> for more information.
d932 1
a932 1
bootstrap($module [...])
a983 7

All arguments to bootstrap() are passed to the module's bootstrap function.
The default code generated by F<xsubpp> expects $module [, $version]
If the optional $version argument is not given, it defaults to
C<$XS_VERSION // $VERSION> in the module's symbol table. The default code
compares the Perl-space version with the version of the compiled XS code,
and croaks with an error if they do not match.
@


1.1.1.11
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d88 1
a88 1
    $VERSION = '1.18';
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@d88 1
a88 1
    $VERSION = '1.25';
a100 1
#         (ignored under Android; the linker always uses RTLD_LOCAL)
a237 26
if ( $Config::Config{d_libname_unique} ) {
    printf OUT <<'EOT', length($Config::Config{dlext}) + 1;
sub mod2fname {
    my $parts = shift;
    my $so_len = %d;
    my $name_max = 255; # No easy way to get this here
    
    my $libname = "PL_" .  join("__", @@$parts);
    
    return $libname if (length($libname)+$so_len) <= $name_max;
    
    # It's too darned big, so we need to go strip. We use the same
    # algorithm as xsubpp does. First, strip out doubled __
    $libname =~ s/__/_/g;
    return $libname if (length($libname)+$so_len) <= $name_max;
    
    # Strip duplicate letters
    1 while $libname =~ s/(.)\1/\U$1/i;
    return $libname if (length($libname)+$so_len) <= $name_max;
    
    # Still too long. Truncate.
    $libname = substr($libname, 0, $name_max - $so_len);
    return $libname;
}
EOT
}
d317 1
a317 1
        my $try = "$dir/$modfname.$dl_dlext";
d360 1
a360 6
    my $flags = $module->dl_load_flags;
    <<$^O-eq-android>>
    # See the note above regarding the linker.
    $flags = 0x00;
    <</$^O-eq-android>>
    my $libref = dl_load_file($file, $flags) or
a568 1
  $dl_dlext
a680 13
=item $dl_dlext

When specified (localised) in a module's F<.pm> file, indicates the extension
which the module's loadable object will have. For example:

    local $DynaLoader::dl_dlext = 'unusual_ext';

would indicate that the module's loadable object has an extension of
C<unusual_ext> instead of the more usual C<$Config{dlext}>.  NOTE: This also
requires that the module's F<Makefile.PL> specify (in C<WriteMakefile()>):

    DLEXT => 'unusual_ext',

d768 1
d770 1
a770 3

If it is defined and perl is compiled with the C macro C<DL_UNLOAD_ALL_AT_EXIT>
defined, then it is called automatically when the interpreter exits for
@


