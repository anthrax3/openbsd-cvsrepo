head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.2
	OPENBSD_6_2_BASE:1.12
	PERL_5_24_2:1.1.1.11
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.10
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2017.02.05.00.32.12;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	cxJ08BvJA9Pt2PTM;

1.11
date	2014.11.17.20.57.05;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	QP75iYx42Uo7mMxO;

1.10
date	2014.03.24.15.05.27;	author afresh1;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.25.20.40.54;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.12.18.24.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.04;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.02;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.22;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.05.14;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.55.14;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.03;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.03;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.38.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.01;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.16;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.11.11;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.08.44;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	1.1.1.11;
commitid	B31cAbBIXiCqnL97;

1.1.1.11
date	2017.08.14.13.46.11;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.12
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/* dl_vms.xs
 * 
 * Platform:  OpenVMS, VAX or AXP or IA64
 * Author:    Charles Bailey  bailey@@newman.upenn.edu
 * Revised:   See http://public.activestate.com/cgi-bin/perlbrowse
 *
 *                           Implementation Note
 *     This section is added as an aid to users and DynaLoader developers, in
 * order to clarify the process of dynamic linking under VMS.
 *     dl_vms.xs uses the supported VMS dynamic linking call, which allows
 * a running program to map an arbitrary file of executable code and call
 * routines within that file.  This is done via the VMS RTL routine
 * lib$find_image_symbol, whose calling sequence is as follows:
 *   status = lib$find_image_symbol(imgname,symname,symval,defspec);
 *   where
 *     status  = a standard VMS status value (unsigned long int)
 *     imgname = a fixed-length string descriptor, passed by
 *               reference, containing the NAME ONLY of the image
 *               file to be mapped.  An attempt will be made to
 *               translate this string as a logical name, so it may
 *               not contain any characters which are not allowed in
 *               logical names.  If no translation is found, imgname
 *               is used directly as the name of the image file.
 *     symname = a fixed-length string descriptor, passed by
 *               reference, containing the name of the routine
 *               to be located.
 *     symval  = an unsigned long int, passed by reference, into
 *               which is written the entry point address of the
 *               routine whose name is specified in symname.
 *     defspec = a fixed-length string descriptor, passed by
 *               reference, containing a default file specification
 *               whichis used to fill in any missing parts of the
 *               image file specification after the imgname argument
 *               is processed.
 * In order to accommodate the handling of the imgname argument, the routine
 * dl_expandspec() is provided for use by perl code (e.g. dl_findfile)
 * which wants to see what image file lib$find_image_symbol would use if
 * it were passed a given file specification.  The file specification passed
 * to dl_expandspec() and dl_load_file() can be partial or complete, and can
 * use VMS or Unix syntax; these routines perform the necessary conversions.
 *    In general, writers of perl extensions need only conform to the
 * procedures set out in the DynaLoader documentation, and let the details
 * be taken care of by the routines here and in DynaLoader.pm.  If anyone
 * comes across any incompatibilities, please let me know.  Thanks.
 *
 */

#define PERL_EXT
#include "EXTERN.h"
#define PERL_IN_DL_VMS_XS
#include "perl.h"
#include "XSUB.h"

#include <descrip.h>
#include <fscndef.h>
#include <lib$routines.h>
#include <rms.h>
#include <ssdef.h>
#include <starlet.h>

#if defined(VMS_WE_ARE_CASE_SENSITIVE)
#define DL_CASE_SENSITIVE 1<<4
#else
#define DL_CASE_SENSITIVE 0
#endif

typedef unsigned long int vmssts;

struct libref {
  struct dsc$descriptor_s name;
  struct dsc$descriptor_s defspec;
};

typedef struct {
    AV *	x_require_symbols;
/* "Static" data for dl_expand_filespec() - This is static to save
 * initialization on each call; if you need context-independence,
 * just make these auto variables in dl_expandspec() and dl_load_file()
 */
    char	x_esa[NAM$C_MAXRSS];
    char	x_rsa[NAM$C_MAXRSS];
    struct FAB	x_fab;
    struct NAM	x_nam;
} my_cxtx_t;		/* this *must* be named my_cxtx_t */

#define DL_CXT_EXTRA	/* ask for dl_cxtx to be defined in dlutils.c */
#include "dlutils.c"    /* dl_debug, dl_last_error; SaveError not used  */

#define dl_require_symbols	(dl_cxtx.x_require_symbols)
#define dl_esa			(dl_cxtx.x_esa)
#define dl_rsa			(dl_cxtx.x_rsa)
#define dl_fab			(dl_cxtx.x_fab)
#define dl_nam			(dl_cxtx.x_nam)

/* $PutMsg action routine - records error message in dl_last_error */
static vmssts
copy_errmsg(struct dsc$descriptor_s *msg, vmssts unused)
{
    dTHX;
    dMY_CXT;
    if (*(msg->dsc$a_pointer) == '%') { /* first line */
        sv_setpvn(MY_CXT.x_dl_last_error, msg->dsc$a_pointer, (STRLEN)msg->dsc$w_length);
    }
    else { /* continuation line */
        sv_catpvn(MY_CXT.x_dl_last_error, msg->dsc$a_pointer, (STRLEN)msg->dsc$w_length);
    }
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "Saved error message: %s\n", dl_last_error));
    return 0;
}

/* Use $PutMsg to retrieve error message for failure status code */
static void
dl_set_error(vmssts sts, vmssts stv)
{
    vmssts vec[3];
    dTHX;

    vec[0] = stv ? 2 : 1;
    vec[1] = sts;  vec[2] = stv;
    _ckvmssts(sys$putmsg(vec,copy_errmsg,0,0));
}

/* wrapper for lib$find_image_symbol, so signalled errors can be saved
 * for dl_error and then returned */
static unsigned long int
my_find_image_symbol(struct dsc$descriptor_s *imgname,
                     struct dsc$descriptor_s *symname,
                     void (**entry)(),
                     struct dsc$descriptor_s *defspec)
{
  unsigned long int retsts;
  VAXC$ESTABLISH((__vms_handler)lib$sig_to_ret);
  retsts = lib$find_image_symbol(imgname,symname,entry,defspec,DL_CASE_SENSITIVE);
  return retsts;
}


static void
dl_private_init(pTHX)
{
    dl_generic_private_init(aTHX);
    {
	dMY_CXT;
	dl_require_symbols = get_av("DynaLoader::dl_require_symbols", GV_ADDMULTI);
	/* Set up the static control blocks for dl_expand_filespec() */
	dl_fab = cc$rms_fab;
	dl_nam = cc$rms_nam;
	dl_fab.fab$l_nam = &dl_nam;
	dl_nam.nam$l_esa = dl_esa;
	dl_nam.nam$b_ess = sizeof dl_esa;
	dl_nam.nam$l_rsa = dl_rsa;
	dl_nam.nam$b_rss = sizeof dl_rsa;
    }
}
MODULE = DynaLoader PACKAGE = DynaLoader

BOOT:
    (void)dl_private_init(aTHX);

void
dl_expandspec(filespec)
    char *	filespec
    CODE:
    char vmsspec[NAM$C_MAXRSS], defspec[NAM$C_MAXRSS];
    size_t deflen;
    vmssts sts;
    dMY_CXT;

    tovmsspec(filespec,vmsspec);
    dl_fab.fab$l_fna = vmsspec;
    dl_fab.fab$b_fns = strlen(vmsspec);
    dl_fab.fab$l_dna = 0;
    dl_fab.fab$b_dns = 0;
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_expand_filespec(%s):\n",vmsspec));
    /* On the first pass, just parse the specification string */
    dl_nam.nam$b_nop = NAM$M_SYNCHK;
    sts = sys$parse(&dl_fab);
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tSYNCHK sys$parse = %d\n",sts));
    if (!(sts & 1)) {
      dl_set_error(dl_fab.fab$l_sts,dl_fab.fab$l_stv);
      ST(0) = &PL_sv_undef;
    }
    else {
      /* Now set up a default spec - everything but the name */
      deflen = dl_nam.nam$l_name - dl_esa;
      memcpy(defspec,dl_esa,deflen);
      memcpy(defspec+deflen,dl_nam.nam$l_type,
             dl_nam.nam$b_type + dl_nam.nam$b_ver);
      deflen += dl_nam.nam$b_type + dl_nam.nam$b_ver;
      memcpy(vmsspec,dl_nam.nam$l_name,dl_nam.nam$b_name);
      DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tsplit filespec: name = %.*s, default = %.*s\n",
                        dl_nam.nam$b_name,vmsspec,deflen,defspec));
      /* . . . and go back to expand it */
      dl_nam.nam$b_nop = 0;
      dl_fab.fab$l_dna = defspec;
      dl_fab.fab$b_dns = deflen;
      dl_fab.fab$b_fns = dl_nam.nam$b_name;
      sts = sys$parse(&dl_fab);
      DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tname/default sys$parse = %d\n",sts));
      if (!(sts & 1)) {
        dl_set_error(dl_fab.fab$l_sts,dl_fab.fab$l_stv);
        ST(0) = &PL_sv_undef;
      }
      else {
        /* Now find the actual file */
        sts = sys$search(&dl_fab);
        DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tsys$search = %d\n",sts));
        if (!(sts & 1)) {
          dl_set_error(dl_fab.fab$l_sts,dl_fab.fab$l_stv);
          ST(0) = &PL_sv_undef;
        }
        else {
          ST(0) = sv_2mortal(newSVpvn(dl_nam.nam$l_rsa,dl_nam.nam$b_rsl));
          DLDEBUG(1,PerlIO_printf(Perl_debug_log, "\tresult = \\%.*s\\\n",
                            dl_nam.nam$b_rsl,dl_nam.nam$l_rsa));
        }
      }
    }

void
dl_load_file(filename, flags=0)
    char *	filename
    int		flags
    PREINIT:
    dTHX;
    dMY_CXT;
    char vmsspec[NAM$C_MAXRSS];
    SV *reqSV, **reqSVhndl;
    STRLEN deflen;
    struct dsc$descriptor_s
      specdsc = {0, DSC$K_DTYPE_T, DSC$K_CLASS_S, 0},
      symdsc  = {0, DSC$K_DTYPE_T, DSC$K_CLASS_S, 0};
    struct fscnlst {
      unsigned short int len;
      unsigned short int code;
      char *string;
    }  namlst[2] = {{0,FSCN$_NAME,0},{0,0,0}};
    struct libref *dlptr;
    vmssts sts, failed = 0;
    void (*entry)();
    CODE:

    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_load_file(%s,%x):\n", filename,flags));
    specdsc.dsc$a_pointer = tovmsspec(filename,vmsspec);
    specdsc.dsc$w_length = strlen(specdsc.dsc$a_pointer);
    if (specdsc.dsc$w_length == 0) { /* undef in, empty out */
        XSRETURN_EMPTY;
    }
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tVMS-ified filename is %s\n",
                      specdsc.dsc$a_pointer));
    Newx(dlptr,1,struct libref);
    dlptr->name.dsc$b_dtype = dlptr->defspec.dsc$b_dtype = DSC$K_DTYPE_T;
    dlptr->name.dsc$b_class = dlptr->defspec.dsc$b_class = DSC$K_CLASS_S;
    sts = sys$filescan(&specdsc,namlst,0);
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tsys$filescan: returns %d, name is %.*s\n",
                      sts,namlst[0].len,namlst[0].string));
    if (!(sts & 1)) {
      failed = 1;
      dl_set_error(sts,0);
    }
    else {
      dlptr->name.dsc$w_length = namlst[0].len;
      dlptr->name.dsc$a_pointer = savepvn(namlst[0].string,namlst[0].len);
      dlptr->defspec.dsc$w_length = specdsc.dsc$w_length - namlst[0].len;
      Newx(dlptr->defspec.dsc$a_pointer, dlptr->defspec.dsc$w_length + 1, char);
      deflen = namlst[0].string - specdsc.dsc$a_pointer; 
      memcpy(dlptr->defspec.dsc$a_pointer,specdsc.dsc$a_pointer,deflen);
      memcpy(dlptr->defspec.dsc$a_pointer + deflen,
             namlst[0].string + namlst[0].len,
             dlptr->defspec.dsc$w_length - deflen);
      DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tlibref = name: %s, defspec: %.*s\n",
                        dlptr->name.dsc$a_pointer,
                        dlptr->defspec.dsc$w_length,
                        dlptr->defspec.dsc$a_pointer));
      if (!(reqSVhndl = av_fetch(dl_require_symbols,0,FALSE)) || !(reqSV = *reqSVhndl)) {
        DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\t@@dl_require_symbols empty, returning untested libref\n"));
      }
      else {
        symdsc.dsc$w_length = SvCUR(reqSV);
        symdsc.dsc$a_pointer = SvPVX(reqSV);
        DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\t$dl_require_symbols[0] = %.*s\n",
                          symdsc.dsc$w_length, symdsc.dsc$a_pointer));
        sts = my_find_image_symbol(&(dlptr->name),&symdsc,
                                    &entry,&(dlptr->defspec));
        DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tlib$find_image_symbol returns %d\n",sts));
        if (!(sts&1)) {
          failed = 1;
          dl_set_error(sts,0);
        }
      }
    }

    if (failed) {
      Safefree(dlptr->name.dsc$a_pointer);
      Safefree(dlptr->defspec.dsc$a_pointer);
      Safefree(dlptr);
      ST(0) = &PL_sv_undef;
    }
    else {
      ST(0) = sv_2mortal(newSViv(PTR2IV(dlptr)));
    }


void
dl_find_symbol(librefptr,symname,ign_err=0)
    void *	librefptr
    SV *	symname
    int	        ign_err
    PREINIT:
    struct libref thislib = *((struct libref *)librefptr);
    struct dsc$descriptor_s
      symdsc = {SvCUR(symname),DSC$K_DTYPE_T,DSC$K_CLASS_S,SvPVX(symname)};
    void (*entry)();
    vmssts sts;
    CODE:

    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_find_symbol(%.*s,%.*s):\n",
                      thislib.name.dsc$w_length, thislib.name.dsc$a_pointer,
                      symdsc.dsc$w_length,symdsc.dsc$a_pointer));
    sts = my_find_image_symbol(&(thislib.name),&symdsc,
                               &entry,&(thislib.defspec));
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tlib$find_image_symbol returns %d\n",sts));
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tentry point is %d\n",
                      (unsigned long int) entry));
    if (!(sts & 1)) {
      if (!ign_err) dl_set_error(sts,0);
      ST(0) = &PL_sv_undef;
    }
    else ST(0) = sv_2mortal(newSViv(PTR2IV(entry)));


void
dl_undef_symbols()
    PPCODE:


# These functions should not need changing on any platform:

void
dl_install_xsub(perl_name, symref, filename="$Package")
    char *	perl_name
    void *	symref 
    const char *	filename
    CODE:
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "dl_install_xsub(name=%s, symref=%x)\n",
        perl_name, symref));
    ST(0) = sv_2mortal(newRV((SV*)newXS_flags(perl_name,
					      (void(*)(pTHX_ CV *))symref,
					      filename, NULL,
					      XS_DYNAMIC_FILENAME)));


SV *
dl_error()
    CODE:
    dMY_CXT;
    RETVAL = newSVsv(MY_CXT.x_dl_last_error);
    OUTPUT:
    RETVAL

#if defined(USE_ITHREADS)

void
CLONE(...)
    CODE:
    MY_CXT_CLONE;

    PERL_UNUSED_VAR(items);

    /* MY_CXT_CLONE just does a memcpy on the whole structure, so to avoid
     * using Perl variables that belong to another thread, we create our 
     * own for this thread.
     */
    MY_CXT.x_dl_last_error = newSVpvs("");
    dl_require_symbols = get_av("DynaLoader::dl_require_symbols", GV_ADDMULTI);

    /* Set up the "static" control blocks for dl_expand_filespec() */
    dl_fab = cc$rms_fab;
    dl_nam = cc$rms_nam;
    dl_fab.fab$l_nam = &dl_nam;
    dl_nam.nam$l_esa = dl_esa;
    dl_nam.nam$b_ess = sizeof dl_esa;
    dl_nam.nam$l_rsa = dl_rsa;
    dl_nam.nam$b_rss = sizeof dl_rsa;

#endif

# end.
@


1.11
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d48 1
d50 1
d305 1
a305 1
dl_find_symbol(librefptr,symname)
d308 1
d326 1
a326 1
      dl_set_error(sts,0);
d353 1
a353 1
char *
d357 1
a357 1
    RETVAL = dl_last_error ;
d359 1
a359 1
      RETVAL
d374 1
a374 1
    MY_CXT.x_dl_last_error = newSVpvn("", 0);
d376 9
@


1.10
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d306 1
a306 1
    CODE:
d312 1
d364 2
@


1.9
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d130 1
a130 1
  VAXC$ESTABLISH(lib$sig_to_ret);
@


1.8
log
@Merge in perl 5.10.1
@
text
@d95 1
a95 3
copy_errmsg(msg,unused)
    struct dsc$descriptor_s *   msg;
    vmssts  unused;
d111 1
a111 3
dl_set_error(sts,stv)
    vmssts  sts;
    vmssts  stv;
@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@a51 5
/* N.B.:
 * dl_debug and dl_last_error are static vars; you'll need to deal
 * with them appropriately if you need context independence
 */

d102 1
a102 7
      if (dl_last_error)
        strncpy((dl_last_error = saferealloc(dl_last_error,msg->dsc$w_length+1)),
                 msg->dsc$a_pointer, msg->dsc$w_length);
      else
        strncpy((dl_last_error = safemalloc(msg->dsc$w_length+1)),
                 msg->dsc$a_pointer, msg->dsc$w_length);
      dl_last_error[msg->dsc$w_length] = '\0';
d105 1
a105 5
      int errlen = strlen(dl_last_error);
      dl_last_error = saferealloc(dl_last_error, errlen + msg->dsc$w_length + 2);
      dl_last_error[errlen] = '\n';  dl_last_error[errlen+1] = '\0';
      strncat(dl_last_error, msg->dsc$a_pointer, msg->dsc$w_length);
      dl_last_error[errlen+msg->dsc$w_length+1] = '\0';
d107 1
a124 13
static unsigned int
findsym_handler(void *sig, void *mech)
{
    dTHX;
    unsigned long int myvec[8],args, *usig = (unsigned long int *) sig;
    /* Be paranoid and assume signal vector passed in might be readonly */
    myvec[0] = args = usig[0] > 10 ? 9 : usig[0] - 1;
    while (--args) myvec[args] = usig[args];
    _ckvmssts(sys$putmsg(myvec,copy_errmsg,0,0));
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "findsym_handler: received\n\t%s\n",dl_last_error));
    return SS$_CONTINUE;
}

d134 1
a134 1
  VAXC$ESTABLISH(findsym_handler);
d146 1
a146 1
	dl_require_symbols = get_av("DynaLoader::dl_require_symbols", 0x4);
d326 1
a326 1
      /* error message already saved by findsym_handler */
d343 1
a343 1
    char *	filename
d360 16
@


1.6
log
@merge in perl 5.8.8
@
text
@d3 1
a3 1
 * Platform:  OpenVMS, VAX or AXP
d5 1
a5 1
 * Revised:   12-Dec-1994
d250 2
a251 2
dl_load_file(filespec, flags)
    char *	filespec
d272 2
a273 2
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_load_file(%s,%x):\n", filespec,flags));
    specdsc.dsc$a_pointer = tovmsspec(filespec,vmsspec);
d275 4
a278 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tVMS-ified filespec is %s\n",
d344 1
a344 1
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_find_dymbol(%.*s,%.*s):\n",
d374 4
a377 3
    ST(0) = sv_2mortal(newRV((SV*)newXS(perl_name,
				      (void(*)(pTHX_ CV *))symref,
				      filename)));
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d277 1
a277 1
    New(1399,dlptr,1,struct libref);
d291 1
a291 1
      New(1097, dlptr->defspec.dsc$a_pointer, dlptr->defspec.dsc$w_length + 1, char);
@


1.4
log
@perl-5.6.0 + local changes
@
text
@a51 4
#include "dlutils.c"    /* dl_debug, LastError; SaveError not used  */

static AV *dl_require_symbols = Nullav;

d53 1
a53 1
 * dl_debug and LastError are static vars; you'll need to deal
d77 3
a79 1
/* Static data for dl_expand_filespec() - This is static to save
d83 14
a96 3
static char dlesa[NAM$C_MAXRSS], dlrsa[NAM$C_MAXRSS];
static struct FAB dlfab;
static struct NAM dlnam;
d98 1
a98 1
/* $PutMsg action routine - records error message in LastError */
d104 2
d107 2
a108 2
      if (LastError)
        strncpy((LastError = saferealloc(LastError,msg->dsc$w_length+1)),
d111 1
a111 1
        strncpy((LastError = safemalloc(msg->dsc$w_length+1)),
d113 1
a113 1
      LastError[msg->dsc$w_length] = '\0';
d116 5
a120 5
      int errlen = strlen(LastError);
      LastError = saferealloc(LastError, errlen + msg->dsc$w_length + 2);
      LastError[errlen] = '\n';  LastError[errlen+1] = '\0';
      strncat(LastError, msg->dsc$a_pointer, msg->dsc$w_length);
      LastError[errlen+msg->dsc$w_length+1] = '\0';
d148 1
a148 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "findsym_handler: received\n\t%s\n",LastError));
d171 12
a182 9
    dl_require_symbols = get_av("DynaLoader::dl_require_symbols", 0x4);
    /* Set up the static control blocks for dl_expand_filespec() */
    dlfab = cc$rms_fab;
    dlnam = cc$rms_nam;
    dlfab.fab$l_nam = &dlnam;
    dlnam.nam$l_esa = dlesa;
    dlnam.nam$b_ess = sizeof dlesa;
    dlnam.nam$l_rsa = dlrsa;
    dlnam.nam$b_rss = sizeof dlrsa;
d196 1
d199 4
a202 4
    dlfab.fab$l_fna = vmsspec;
    dlfab.fab$b_fns = strlen(vmsspec);
    dlfab.fab$l_dna = 0;
    dlfab.fab$b_dns = 0;
d205 2
a206 2
    dlnam.nam$b_nop = NAM$M_SYNCHK;
    sts = sys$parse(&dlfab);
d209 1
a209 1
      dl_set_error(dlfab.fab$l_sts,dlfab.fab$l_stv);
d214 6
a219 6
      deflen = dlnam.nam$l_name - dlesa;
      memcpy(defspec,dlesa,deflen);
      memcpy(defspec+deflen,dlnam.nam$l_type,
             dlnam.nam$b_type + dlnam.nam$b_ver);
      deflen += dlnam.nam$b_type + dlnam.nam$b_ver;
      memcpy(vmsspec,dlnam.nam$l_name,dlnam.nam$b_name);
d221 1
a221 1
                        dlnam.nam$b_name,vmsspec,deflen,defspec));
d223 5
a227 5
      dlnam.nam$b_nop = 0;
      dlfab.fab$l_dna = defspec;
      dlfab.fab$b_dns = deflen;
      dlfab.fab$b_fns = dlnam.nam$b_name;
      sts = sys$parse(&dlfab);
d230 1
a230 1
        dl_set_error(dlfab.fab$l_sts,dlfab.fab$l_stv);
d235 1
a235 1
        sts = sys$search(&dlfab);
d238 1
a238 1
          dl_set_error(dlfab.fab$l_sts,dlfab.fab$l_stv);
d242 1
a242 1
          ST(0) = sv_2mortal(newSVpvn(dlnam.nam$l_rsa,dlnam.nam$b_rsl));
d244 1
a244 1
                            dlnam.nam$b_rsl,dlnam.nam$l_rsa));
d255 1
d379 2
a380 1
    RETVAL = LastError ;
@


1.3
log
@perl5.005_03 (stock)
@
text
@d68 6
d121 1
d131 1
d137 1
a137 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "findsym_handler: received\n\t%s\n",LastError));
d151 1
a151 1
  retsts = lib$find_image_symbol(imgname,symname,entry,defspec);
d157 1
a157 1
dl_private_init()
d159 2
a160 2
    dl_generic_private_init();
    dl_require_symbols = perl_get_av("DynaLoader::dl_require_symbols", 0x4);
d173 1
a173 1
    (void)dl_private_init();
d188 1
a188 1
    DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_expand_filespec(%s):\n",vmsspec));
d192 1
a192 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tSYNCHK sys$parse = %d\n",sts));
d205 1
a205 1
      DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tsplit filespec: name = %.*s, default = %.*s\n",
d213 1
a213 1
      DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tname/default sys$parse = %d\n",sts));
d221 1
a221 1
        DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tsys$search = %d\n",sts));
d227 2
a228 2
          ST(0) = sv_2mortal(newSVpv(dlnam.nam$l_rsa,dlnam.nam$b_rsl));
          DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "\tresult = \\%.*s\\\n",
d239 1
d256 1
a256 1
    DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_load_file(%s,%x):\n", filespec,flags));
d259 1
a259 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tVMS-ified filespec is %s\n",
d265 1
a265 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tsys$filescan: returns %d, name is %.*s\n",
d281 1
a281 1
      DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tlibref = name: %s, defspec: %.*s\n",
d286 1
a286 1
        DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\t@@dl_require_symbols empty, returning untested libref\n"));
d291 1
a291 1
        DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\t$dl_require_symbols[0] = %.*s\n",
d295 1
a295 1
        DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tlib$find_image_symbol returns %d\n",sts));
d310 1
a310 1
      ST(0) = sv_2mortal(newSViv((IV) dlptr));
d325 1
a325 1
    DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_find_dymbol(%.*s,%.*s):\n",
d330 2
a331 2
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tlib$find_image_symbol returns %d\n",sts));
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tentry point is %d\n",
d337 1
a337 1
    else ST(0) = sv_2mortal(newSViv((IV) entry));
d353 1
a353 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "dl_install_xsub(name=%s, symref=%x)\n",
d355 3
a357 1
    ST(0)=sv_2mortal(newRV((SV*)newXS(perl_name, (void(*)())symref, filename)));
@


1.2
log
@perl 5.004_04
@
text
@d4 1
a4 1
 * Author:    Charles Bailey  bailey@@genetics.upenn.edu
d187 1
a187 1
      ST(0) = &sv_undef;
d208 1
a208 1
        ST(0) = &sv_undef;
d216 1
a216 1
          ST(0) = &sv_undef;
d266 1
a266 1
      dlptr->defspec.dsc$a_pointer = safemalloc(dlptr->defspec.dsc$w_length + 1);
d298 1
a298 1
      ST(0) = &sv_undef;
d326 1
a326 1
      ST(0) = &sv_undef;
@


1.1
log
@Initial revision
@
text
@d129 1
a129 1
    DLDEBUG(2,fprintf(stderr,"findsym_handler: received\n\t%s\n",LastError));
d180 1
a180 1
    DLDEBUG(1,fprintf(stderr,"dl_expand_filespec(%s):\n",vmsspec));
d184 1
a184 1
    DLDEBUG(2,fprintf(stderr,"\tSYNCHK sys$parse = %d\n",sts));
d197 1
a197 1
      DLDEBUG(2,fprintf(stderr,"\tsplit filespec: name = %.*s, default = %.*s\n",
d205 1
a205 1
      DLDEBUG(2,fprintf(stderr,"\tname/default sys$parse = %d\n",sts));
d213 1
a213 1
        DLDEBUG(2,fprintf(stderr,"\tsys$search = %d\n",sts));
d220 1
a220 1
          DLDEBUG(1,fprintf(stderr,"\tresult = \\%.*s\\\n",
d227 1
a227 1
dl_load_file(filespec)
d229 2
a230 1
    CODE:
d245 1
d247 1
a247 1
    DLDEBUG(1,fprintf(stderr,"dl_load_file(%s):\n",filespec));
d250 1
a250 1
    DLDEBUG(2,fprintf(stderr,"\tVMS-ified filespec is %s\n",
d252 1
a252 1
    New(7901,dlptr,1,struct libref);
d256 1
a256 1
    DLDEBUG(2,fprintf(stderr,"\tsys$filescan: returns %d, name is %.*s\n",
d272 1
a272 1
      DLDEBUG(2,fprintf(stderr,"\tlibref = name: %s, defspec: %.*s\n",
d277 1
a277 1
        DLDEBUG(2,fprintf(stderr,"\t@@dl_require_symbols empty, returning untested libref\n"));
d282 1
a282 1
        DLDEBUG(2,fprintf(stderr,"\t$dl_require_symbols[0] = %.*s\n",
d286 1
a286 1
        DLDEBUG(2,fprintf(stderr,"\tlib$find_image_symbol returns %d\n",sts));
d316 1
a316 1
    DLDEBUG(1,fprintf(stderr,"dl_find_dymbol(%.*s,%.*s):\n",
d321 2
a322 2
    DLDEBUG(2,fprintf(stderr,"\tlib$find_image_symbol returns %d\n",sts));
    DLDEBUG(2,fprintf(stderr,"\tentry point is %d\n",
d344 1
a344 1
    DLDEBUG(2,fprintf(stderr,"dl_install_xsub(name=%s, symref=%x)\n",
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d4 1
a4 1
 * Author:    Charles Bailey  bailey@@newman.upenn.edu
d129 1
a129 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "findsym_handler: received\n\t%s\n",LastError));
d180 1
a180 1
    DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_expand_filespec(%s):\n",vmsspec));
d184 1
a184 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tSYNCHK sys$parse = %d\n",sts));
d187 1
a187 1
      ST(0) = &PL_sv_undef;
d197 1
a197 1
      DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tsplit filespec: name = %.*s, default = %.*s\n",
d205 1
a205 1
      DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tname/default sys$parse = %d\n",sts));
d208 1
a208 1
        ST(0) = &PL_sv_undef;
d213 1
a213 1
        DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tsys$search = %d\n",sts));
d216 1
a216 1
          ST(0) = &PL_sv_undef;
d220 1
a220 1
          DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "\tresult = \\%.*s\\\n",
d227 1
a227 1
dl_load_file(filespec, flags)
d229 1
a229 2
    int		flags
    PREINIT:
a243 1
    CODE:
d245 1
a245 1
    DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_load_file(%s,%x):\n", filespec,flags));
d248 1
a248 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tVMS-ified filespec is %s\n",
d250 1
a250 1
    New(1399,dlptr,1,struct libref);
d254 1
a254 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tsys$filescan: returns %d, name is %.*s\n",
d264 1
a264 1
      New(1097, dlptr->defspec.dsc$a_pointer, dlptr->defspec.dsc$w_length + 1, char);
d270 1
a270 1
      DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tlibref = name: %s, defspec: %.*s\n",
d275 1
a275 1
        DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\t@@dl_require_symbols empty, returning untested libref\n"));
d280 1
a280 1
        DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\t$dl_require_symbols[0] = %.*s\n",
d284 1
a284 1
        DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tlib$find_image_symbol returns %d\n",sts));
d296 1
a296 1
      ST(0) = &PL_sv_undef;
d314 1
a314 1
    DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_find_dymbol(%.*s,%.*s):\n",
d319 2
a320 2
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tlib$find_image_symbol returns %d\n",sts));
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "\tentry point is %d\n",
d324 1
a324 1
      ST(0) = &PL_sv_undef;
d342 1
a342 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "dl_install_xsub(name=%s, symref=%x)\n",
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a67 6
#if defined(VMS_WE_ARE_CASE_SENSITIVE)
#define DL_CASE_SENSITIVE 1<<4
#else
#define DL_CASE_SENSITIVE 0
#endif

a114 1
    dTHX;
a123 1
    dTHX;
d129 1
a129 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "findsym_handler: received\n\t%s\n",LastError));
d143 1
a143 1
  retsts = lib$find_image_symbol(imgname,symname,entry,defspec,DL_CASE_SENSITIVE);
d149 1
a149 1
dl_private_init(pTHX)
d151 2
a152 2
    dl_generic_private_init(aTHX);
    dl_require_symbols = get_av("DynaLoader::dl_require_symbols", 0x4);
d165 1
a165 1
    (void)dl_private_init(aTHX);
d180 1
a180 1
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_expand_filespec(%s):\n",vmsspec));
d184 1
a184 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tSYNCHK sys$parse = %d\n",sts));
d197 1
a197 1
      DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tsplit filespec: name = %.*s, default = %.*s\n",
d205 1
a205 1
      DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tname/default sys$parse = %d\n",sts));
d213 1
a213 1
        DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tsys$search = %d\n",sts));
d219 2
a220 2
          ST(0) = sv_2mortal(newSVpvn(dlnam.nam$l_rsa,dlnam.nam$b_rsl));
          DLDEBUG(1,PerlIO_printf(Perl_debug_log, "\tresult = \\%.*s\\\n",
a230 1
    dTHX;
d247 1
a247 1
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_load_file(%s,%x):\n", filespec,flags));
d250 1
a250 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tVMS-ified filespec is %s\n",
d256 1
a256 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tsys$filescan: returns %d, name is %.*s\n",
d272 1
a272 1
      DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tlibref = name: %s, defspec: %.*s\n",
d277 1
a277 1
        DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\t@@dl_require_symbols empty, returning untested libref\n"));
d282 1
a282 1
        DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\t$dl_require_symbols[0] = %.*s\n",
d286 1
a286 1
        DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tlib$find_image_symbol returns %d\n",sts));
d301 1
a301 1
      ST(0) = sv_2mortal(newSViv(PTR2IV(dlptr)));
d316 1
a316 1
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_find_dymbol(%.*s,%.*s):\n",
d321 2
a322 2
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tlib$find_image_symbol returns %d\n",sts));
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tentry point is %d\n",
d328 1
a328 1
    else ST(0) = sv_2mortal(newSViv(PTR2IV(entry)));
d344 1
a344 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "dl_install_xsub(name=%s, symref=%x)\n",
d346 1
a346 3
    ST(0) = sv_2mortal(newRV((SV*)newXS(perl_name,
				      (void(*)(pTHX_ CV *))symref,
				      filename)));
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d52 4
d57 1
a57 1
 * dl_debug and dl_last_error are static vars; you'll need to deal
d81 1
a81 3
typedef struct {
    AV *	x_require_symbols;
/* "Static" data for dl_expand_filespec() - This is static to save
d85 3
a87 14
    char	x_esa[NAM$C_MAXRSS];
    char	x_rsa[NAM$C_MAXRSS];
    struct FAB	x_fab;
    struct NAM	x_nam;
} my_cxtx_t;		/* this *must* be named my_cxtx_t */

#define DL_CXT_EXTRA	/* ask for dl_cxtx to be defined in dlutils.c */
#include "dlutils.c"    /* dl_debug, dl_last_error; SaveError not used  */

#define dl_require_symbols	(dl_cxtx.x_require_symbols)
#define dl_esa			(dl_cxtx.x_esa)
#define dl_rsa			(dl_cxtx.x_rsa)
#define dl_fab			(dl_cxtx.x_fab)
#define dl_nam			(dl_cxtx.x_nam)
d89 1
a89 1
/* $PutMsg action routine - records error message in dl_last_error */
a94 2
    dTHX;
    dMY_CXT;
d96 2
a97 2
      if (dl_last_error)
        strncpy((dl_last_error = saferealloc(dl_last_error,msg->dsc$w_length+1)),
d100 1
a100 1
        strncpy((dl_last_error = safemalloc(msg->dsc$w_length+1)),
d102 1
a102 1
      dl_last_error[msg->dsc$w_length] = '\0';
d105 5
a109 5
      int errlen = strlen(dl_last_error);
      dl_last_error = saferealloc(dl_last_error, errlen + msg->dsc$w_length + 2);
      dl_last_error[errlen] = '\n';  dl_last_error[errlen+1] = '\0';
      strncat(dl_last_error, msg->dsc$a_pointer, msg->dsc$w_length);
      dl_last_error[errlen+msg->dsc$w_length+1] = '\0';
d137 1
a137 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "findsym_handler: received\n\t%s\n",dl_last_error));
d160 9
a168 12
    {
	dMY_CXT;
	dl_require_symbols = get_av("DynaLoader::dl_require_symbols", 0x4);
	/* Set up the static control blocks for dl_expand_filespec() */
	dl_fab = cc$rms_fab;
	dl_nam = cc$rms_nam;
	dl_fab.fab$l_nam = &dl_nam;
	dl_nam.nam$l_esa = dl_esa;
	dl_nam.nam$b_ess = sizeof dl_esa;
	dl_nam.nam$l_rsa = dl_rsa;
	dl_nam.nam$b_rss = sizeof dl_rsa;
    }
a181 1
    dMY_CXT;
d184 4
a187 4
    dl_fab.fab$l_fna = vmsspec;
    dl_fab.fab$b_fns = strlen(vmsspec);
    dl_fab.fab$l_dna = 0;
    dl_fab.fab$b_dns = 0;
d190 2
a191 2
    dl_nam.nam$b_nop = NAM$M_SYNCHK;
    sts = sys$parse(&dl_fab);
d194 1
a194 1
      dl_set_error(dl_fab.fab$l_sts,dl_fab.fab$l_stv);
d199 6
a204 6
      deflen = dl_nam.nam$l_name - dl_esa;
      memcpy(defspec,dl_esa,deflen);
      memcpy(defspec+deflen,dl_nam.nam$l_type,
             dl_nam.nam$b_type + dl_nam.nam$b_ver);
      deflen += dl_nam.nam$b_type + dl_nam.nam$b_ver;
      memcpy(vmsspec,dl_nam.nam$l_name,dl_nam.nam$b_name);
d206 1
a206 1
                        dl_nam.nam$b_name,vmsspec,deflen,defspec));
d208 5
a212 5
      dl_nam.nam$b_nop = 0;
      dl_fab.fab$l_dna = defspec;
      dl_fab.fab$b_dns = deflen;
      dl_fab.fab$b_fns = dl_nam.nam$b_name;
      sts = sys$parse(&dl_fab);
d215 1
a215 1
        dl_set_error(dl_fab.fab$l_sts,dl_fab.fab$l_stv);
d220 1
a220 1
        sts = sys$search(&dl_fab);
d223 1
a223 1
          dl_set_error(dl_fab.fab$l_sts,dl_fab.fab$l_stv);
d227 1
a227 1
          ST(0) = sv_2mortal(newSVpvn(dl_nam.nam$l_rsa,dl_nam.nam$b_rsl));
d229 1
a229 1
                            dl_nam.nam$b_rsl,dl_nam.nam$l_rsa));
a239 1
    dMY_CXT;
d363 1
a363 2
    dMY_CXT;
    RETVAL = dl_last_error ;
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d277 1
a277 1
    Newx(dlptr,1,struct libref);
d291 1
a291 1
      Newx(dlptr->defspec.dsc$a_pointer, dlptr->defspec.dsc$w_length + 1, char);
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
 * Platform:  OpenVMS, VAX or AXP or IA64
d5 1
a5 1
 * Revised:   See http://public.activestate.com/cgi-bin/perlbrowse
d250 2
a251 2
dl_load_file(filename, flags=0)
    char *	filename
d272 2
a273 2
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_load_file(%s,%x):\n", filename,flags));
    specdsc.dsc$a_pointer = tovmsspec(filename,vmsspec);
d275 1
a275 4
    if (specdsc.dsc$w_length == 0) { /* undef in, empty out */
        XSRETURN_EMPTY;
    }
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "\tVMS-ified filename is %s\n",
d341 1
a341 1
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_find_symbol(%.*s,%.*s):\n",
d371 3
a373 4
    ST(0) = sv_2mortal(newRV((SV*)newXS_flags(perl_name,
					      (void(*)(pTHX_ CV *))symref,
					      filename, NULL,
					      XS_DYNAMIC_FILENAME)));
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d52 5
d107 7
a113 1
        sv_setpvn(MY_CXT.x_dl_last_error, msg->dsc$a_pointer, (STRLEN)msg->dsc$w_length);
d116 5
a120 1
        sv_catpvn(MY_CXT.x_dl_last_error, msg->dsc$a_pointer, (STRLEN)msg->dsc$w_length);
a121 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "Saved error message: %s\n", dl_last_error));
d139 13
d161 1
a161 1
  VAXC$ESTABLISH(lib$sig_to_ret);
d173 1
a173 1
	dl_require_symbols = get_av("DynaLoader::dl_require_symbols", GV_ADDMULTI);
d353 1
a353 1
      dl_set_error(sts,0);
d370 1
a370 1
    const char *	filename
a386 16

#if defined(USE_ITHREADS)

void
CLONE(...)
    CODE:
    MY_CXT_CLONE;

    /* MY_CXT_CLONE just does a memcpy on the whole structure, so to avoid
     * using Perl variables that belong to another thread, we create our 
     * own for this thread.
     */
    MY_CXT.x_dl_last_error = newSVpvn("", 0);
    dl_require_symbols = get_av("DynaLoader::dl_require_symbols", GV_ADDMULTI);

#endif
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d95 3
a97 1
copy_errmsg(struct dsc$descriptor_s *msg, vmssts unused)
d113 3
a115 1
dl_set_error(vmssts sts, vmssts stv)
@


1.1.1.9
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d130 1
a130 1
  VAXC$ESTABLISH((__vms_handler)lib$sig_to_ret);
@


1.1.1.10
log
@Import perl-5.20.1
@
text
@d306 1
a306 1
    PREINIT:
a311 1
    CODE:
a362 2

    PERL_UNUSED_VAR(items);
@


1.1.1.11
log
@Import perl-5.24.2
@
text
@a47 1
#define PERL_EXT
a48 1
#define PERL_IN_DL_VMS_XS
d303 1
a303 1
dl_find_symbol(librefptr,symname,ign_err=0)
a305 1
    int	        ign_err
d323 1
a323 1
      if (!ign_err) dl_set_error(sts,0);
d350 1
a350 1
SV *
d354 1
a354 1
    RETVAL = newSVsv(MY_CXT.x_dl_last_error);
d356 1
a356 1
    RETVAL
d371 1
a371 1
    MY_CXT.x_dl_last_error = newSVpvs("");
a372 9

    /* Set up the "static" control blocks for dl_expand_filespec() */
    dl_fab = cc$rms_fab;
    dl_nam = cc$rms_nam;
    dl_fab.fab$l_nam = &dl_nam;
    dl_nam.nam$l_esa = dl_esa;
    dl_nam.nam$b_ess = sizeof dl_esa;
    dl_nam.nam$l_rsa = dl_rsa;
    dl_nam.nam$b_rss = sizeof dl_rsa;
@


