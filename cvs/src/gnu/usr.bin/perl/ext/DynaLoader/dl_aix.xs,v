head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.12.0.10
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	PERL_5_20_2:1.1.1.11
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.9.0.14
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.6.0.14
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.13
date	2017.02.05.00.32.12;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	cxJ08BvJA9Pt2PTM;

1.12
date	2014.11.17.20.57.05;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	QP75iYx42Uo7mMxO;

1.11
date	2014.03.24.15.05.27;	author afresh1;	state Exp;
branches;
next	1.10;

1.10
date	2013.03.25.20.40.54;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.12.18.24.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.04;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.02;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.22;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.09;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.05.10;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.25;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.55.09;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.02;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.02;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.38.41;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.09;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.46;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.48.01;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.16;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.11.11;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.08.44;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.13
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/* dl_aix.xs
 *
 * Written: 8/31/94 by Wayne Scott (wscott@@ichips.intel.com)
 *
 *  All I did was take Jens-Uwe Mager's libdl emulation library for
 *  AIX and merged it with the dl_dlopen.xs file to create a dynamic library
 *  package that works for AIX.
 *
 *  I did change all malloc's, free's, strdup's, calloc's to use the perl
 *  equilvant.  I also removed some stuff we will not need.  Call fini()
 *  on startup...   It can probably be trimmed more.
 */

#define PERLIO_NOT_STDIO 0
#define PERL_EXT
#define PERL_IN_DL_AIX_XS

/*
 * On AIX 4.3 and above the emulation layer is not needed any more, and
 * indeed if perl uses its emulation and perl is linked into apache
 * which is supposed to use the native dlopen conflicts arise.
 * Jens-Uwe Mager jum@@helios.de
 */
#ifdef USE_NATIVE_DLOPEN

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include <dlfcn.h>

#include "dlutils.c"	/* SaveError() etc	*/

#else

/*
 * @@(#)dlfcn.c	1.5 revision of 93/02/14  20:14:17
 * This is an unpublished work copyright (c) 1992 Helios Software GmbH
 * 3000 Hannover 1, Germany
 */
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* When building as a 64-bit binary on AIX, define this to get the
 * correct structure definitions.  Also determines the field-name
 * macros and gates some logic in readEntries().  -- Steven N. Hirsch
 * <hirschs@@btv.ibm.com> */
#ifdef USE_64_BIT_ALL
#   define __XCOFF64__
#   define __XCOFF32__
#endif

#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ldr.h>
#include <a.out.h>
#undef FREAD
#undef FWRITE
#include <ldfcn.h>

#ifdef USE_64_BIT_ALL
#   define AIX_SCNHDR SCNHDR_64
#   define AIX_LDHDR LDHDR_64
#   define AIX_LDSYM LDSYM_64
#   define AIX_LDHDRSZ LDHDRSZ_64
#else
#   define AIX_SCNHDR SCNHDR
#   define AIX_LDHDR LDHDR
#   define AIX_LDSYM LDSYM
#   define AIX_LDHDRSZ LDHDRSZ
#endif

/* When using Perl extensions written in C++ the longer versions
 * of load() and unload() from libC and libC_r need to be used,
 * otherwise statics in the extensions won't get initialized right.
 * -- Stephanie Beals <bealzy@@us.ibm.com> */

/* Older AIX C compilers cannot deal with C++ double-slash comments in
   the ibmcxx and/or xlC includes.  Since we only need a single file,
   be more fine-grained about what's included <hirschs@@btv.ibm.com> */

#ifdef USE_libC /* The define comes, when it comes, from hints/aix.pl. */
#   define LOAD   loadAndInit
#   define UNLOAD terminateAndUnload
#   if defined(USE_vacpp_load_h)
#       include "/usr/vacpp/include/load.h"
#   elif defined(USE_ibmcxx_load_h)
#       include "/usr/ibmcxx/include/load.h"
#   elif defined(USE_xlC_load_h)
#       include "/usr/lpp/xlC/include/load.h"
#   elif defined(USE_load_h)
#       include "/usr/include/load.h"
#   endif
#else
#   define LOAD   load
#   define UNLOAD unload
#endif

/*
 * AIX 4.3 does remove some useful definitions from ldfcn.h. Define
 * these here to compensate for that lossage.
 */
#ifndef BEGINNING
# define BEGINNING SEEK_SET
#endif
#ifndef FSEEK
# define FSEEK(ldptr,o,p)	fseek(IOPTR(ldptr),(p==BEGINNING)?(OFFSET(ldptr) +o):o,p)
#endif
#ifndef FREAD
# define FREAD(p,s,n,ldptr)	fread(p,s,n,IOPTR(ldptr))
#endif

#ifndef RTLD_LAZY
# define RTLD_LAZY 0
#endif
#ifndef RTLD_GLOBAL
# define RTLD_GLOBAL 0
#endif

/*
 * We simulate dlopen() et al. through a call to load. Because AIX has
 * no call to find an exported symbol we read the loader section of the
 * loaded module and build a list of exported symbols and their virtual
 * address.
 */

typedef struct {
	char		*name;		/* the symbols's name */
	void		*addr;		/* its relocated virtual address */
} Export, *ExportPtr;

/*
 * The void * handle returned from dlopen is actually a ModulePtr.
 */
typedef struct Module {
	struct Module	*next;
	char		*name;		/* module name for refcounting */
	int		refCnt;		/* the number of references */
	void		*entry;		/* entry point from load */
	int		nExports;	/* the number of exports found */
	ExportPtr	exports;	/* the array of exports */
} Module, *ModulePtr;

typedef struct {
    /*
     * We keep a list of all loaded modules to be able to reference count
     * duplicate dlopen's.
     */
    ModulePtr	x_modList;

    /*
     * The last error from one of the dl* routines is kept in static
     * variables here. Each error is returned only once to the caller.
     */
    char	x_errbuf[BUFSIZ];
    int		x_errvalid;
    void *	x_mainModule;
} my_cxtx_t;		/* this *must* be named my_cxtx_t */

#define DL_CXT_EXTRA	/* ask for dl_cxtx to be defined in dlutils.c */
#include "dlutils.c"	/* SaveError() etc	*/

#define dl_modList	(dl_cxtx.x_modList)
#define dl_errbuf	(dl_cxtx.x_errbuf)
#define dl_errvalid	(dl_cxtx.x_errvalid)
#define dl_mainModule	(dl_cxtx.x_mainModule)

static void caterr(char *);
static int readExports(ModulePtr);
static void *findMain(void);

/* these statics are ok because they're constants */
static char *strerror_failed   = "(strerror failed)";
static char *strerror_r_failed = "(strerror_r failed)";

char *strerrorcat(char *str, int err) {
    int strsiz = strlen(str);
    int msgsiz;
    char *msg;

    dTHX;

    if ((msg = strerror(err)) == 0)
      msg = strerror_failed;
    msgsiz = strlen(msg);		/* Note msg = buf and free() above. */
    if (strsiz + msgsiz < BUFSIZ)	/* Do not move this after #endif. */
      strcat(str, msg);

    return str;
}

char *strerrorcpy(char *str, int err) {
    int msgsiz;
    char *msg;

    dTHX;

    if ((msg = strerror(err)) == 0)
      msg = strerror_failed;
    msgsiz = strlen(msg);	/* Note msg = buf and free() above. */
    if (msgsiz < BUFSIZ)	/* Do not move this after #endif. */
      strcpy(str, msg);

    return str;
}
  
/* ARGSUSED */
void *dlopen(char *path, int mode)
{
	dTHX;
	dMY_CXT;
	ModulePtr mp;

	/*
	 * Upon the first call register a terminate handler that will
	 * close all libraries.
	 */
	if (dl_mainModule == NULL) {
		if ((dl_mainModule = findMain()) == NULL)
			return NULL;
	}
	/*
	 * Scan the list of modules if have the module already loaded.
	 */
	for (mp = dl_modList; mp; mp = mp->next)
		if (strcmp(mp->name, path) == 0) {
			mp->refCnt++;
			return mp;
		}
	Newxz(mp,1,Module);
	if (mp == NULL) {
		dl_errvalid++;
		strcpy(dl_errbuf, "Newz: ");
		strerrorcat(dl_errbuf, errno);
		return NULL;
	}
	
	if ((mp->name = savepv(path)) == NULL) {
		dl_errvalid++;
		strcpy(dl_errbuf, "savepv: ");
		strerrorcat(dl_errbuf, errno);
		safefree(mp);
		return NULL;
	}

	/*
	 * load should be declared load(const char *...). Thus we
	 * cast the path to a normal char *. Ugly.
	 */
	if ((mp->entry = (void *)LOAD((char *)path,
#ifdef L_LIBPATH_EXEC
				      L_LIBPATH_EXEC |
#endif
				      L_NOAUTODEFER,
				      NULL)) == NULL) {
	        int saverrno = errno;
		
		safefree(mp->name);
		safefree(mp);
		dl_errvalid++;
		strcpy(dl_errbuf, "dlopen: ");
		strcat(dl_errbuf, path);
		strcat(dl_errbuf, ": ");
		/*
		 * If AIX says the file is not executable, the error
		 * can be further described by querying the loader about
		 * the last error.
		 */
		if (saverrno == ENOEXEC) {
			char *moreinfo[BUFSIZ/sizeof(char *)];
			if (loadquery(L_GETMESSAGES, moreinfo, sizeof(moreinfo)) == -1)
				strerrorcpy(dl_errbuf, saverrno);
			else {
				char **p;
				for (p = moreinfo; *p; p++)
					caterr(*p);
			}
		} else
			strerrorcat(dl_errbuf, saverrno);
		return NULL;
	}
	mp->refCnt = 1;
	mp->next = dl_modList;
	dl_modList = mp;
	/*
	 * Assume anonymous exports come from the module this dlopen
	 * is linked into, that holds true as long as dlopen and all
	 * of the perl core are in the same shared object. Also bind
	 * against the main part, in the case a perl is not the main
	 * part, e.g mod_perl as DSO in Apache so perl modules can
	 * also reference Apache symbols.
	 */
	if (loadbind(0, (void *)dlopen, mp->entry) == -1 ||
	    loadbind(0, dl_mainModule, mp->entry)) {
	        int saverrno = errno;

		dlclose(mp);
		dl_errvalid++;
		strcpy(dl_errbuf, "loadbind: ");
		strerrorcat(dl_errbuf, saverrno);
		return NULL;
	}
	if (readExports(mp) == -1) {
		dlclose(mp);
		return NULL;
	}
	return mp;
}

/*
 * Attempt to decipher an AIX loader error message and append it
 * to our static error message buffer.
 */
static void caterr(char *s)
{
	dTHX;
	dMY_CXT;
	char *p = s;

	while (*p >= '0' && *p <= '9')
		p++;
	switch(atoi(s)) {
	case L_ERROR_TOOMANY:
		strcat(dl_errbuf, "too many errors");
		break;
	case L_ERROR_NOLIB:
		strcat(dl_errbuf, "can't load library");
		strcat(dl_errbuf, p);
		break;
	case L_ERROR_UNDEF:
		strcat(dl_errbuf, "can't find symbol");
		strcat(dl_errbuf, p);
		break;
	case L_ERROR_RLDBAD:
		strcat(dl_errbuf, "bad RLD");
		strcat(dl_errbuf, p);
		break;
	case L_ERROR_FORMAT:
		strcat(dl_errbuf, "bad exec format in");
		strcat(dl_errbuf, p);
		break;
	case L_ERROR_ERRNO:
		strerrorcat(dl_errbuf, atoi(++p));
		break;
	default:
		strcat(dl_errbuf, s);
		break;
	}
}

void *dlsym(void *handle, const char *symbol)
{
	dTHX;
	dMY_CXT;
	ModulePtr mp = (ModulePtr)handle;
	ExportPtr ep;
	int i;

	/*
	 * Could speed up search, but I assume that one assigns
	 * the result to function pointers anyways.
	 */
	for (ep = mp->exports, i = mp->nExports; i; i--, ep++)
		if (strcmp(ep->name, symbol) == 0)
			return ep->addr;
	dl_errvalid++;
	strcpy(dl_errbuf, "dlsym: undefined symbol ");
	strcat(dl_errbuf, symbol);
	return NULL;
}

char *dlerror(void)
{
	dTHX;
	dMY_CXT;
	if (dl_errvalid) {
		dl_errvalid = 0;
		return dl_errbuf;
	}
	return NULL;
}

int dlclose(void *handle)
{
	dTHX;
	dMY_CXT;
	ModulePtr mp = (ModulePtr)handle;
	int result;
	ModulePtr mp1;

	if (--mp->refCnt > 0)
		return 0;
	result = UNLOAD(mp->entry);
	if (result == -1) {
		dl_errvalid++;
		strerrorcpy(dl_errbuf, errno);
	}
	if (mp->exports) {
		ExportPtr ep;
		int i;
		for (ep = mp->exports, i = mp->nExports; i; i--, ep++)
			if (ep->name)
				safefree(ep->name);
		safefree(mp->exports);
	}
	if (mp == dl_modList)
		dl_modList = mp->next;
	else {
		for (mp1 = dl_modList; mp1; mp1 = mp1->next)
			if (mp1->next == mp) {
				mp1->next = mp->next;
				break;
			}
	}
	safefree(mp->name);
	safefree(mp);
	return result;
}

/* Added by Wayne Scott 
 * This is needed because the ldopen system call calls
 * calloc to allocated a block of date.  The ldclose call calls free.
 * Without this we get this system calloc and perl's free, resulting
 * in a "Bad free" message.  This way we always use perl's malloc.
 */
void *calloc(size_t ne, size_t sz) 
{
  void *out;

  out = (void *) safemalloc(ne*sz);
  memzero(out, ne*sz);
  return(out);
}
 
/*
 * Build the export table from the XCOFF .loader section.
 */
static int readExports(ModulePtr mp)
{
	dTHX;
	dMY_CXT;
	LDFILE *ldp = NULL;
	AIX_SCNHDR sh;
	AIX_LDHDR *lhp;
	char *ldbuf;
	AIX_LDSYM *ls;
	int i;
	ExportPtr ep;

	if ((ldp = ldopen(mp->name, ldp)) == NULL) {
		struct ld_info *lp;
		char *buf;
		int size = 4*1024;
		if (errno != ENOENT) {
			dl_errvalid++;
			strcpy(dl_errbuf, "readExports: ");
			strerrorcat(dl_errbuf, errno);
			return -1;
		}
		/*
		 * The module might be loaded due to the LIBPATH
		 * environment variable. Search for the loaded
		 * module using L_GETINFO.
		 */
		if ((buf = safemalloc(size)) == NULL) {
			dl_errvalid++;
			strcpy(dl_errbuf, "readExports: ");
			strerrorcat(dl_errbuf, errno);
			return -1;
		}
		while ((i = loadquery(L_GETINFO, buf, size)) == -1 && errno == ENOMEM) {
			safefree(buf);
			size += 4*1024;
			if ((buf = safemalloc(size)) == NULL) {
				dl_errvalid++;
				strcpy(dl_errbuf, "readExports: ");
				strerrorcat(dl_errbuf, errno);
				return -1;
			}
		}
		if (i == -1) {
			dl_errvalid++;
			strcpy(dl_errbuf, "readExports: ");
			strerrorcat(dl_errbuf, errno);
			safefree(buf);
			return -1;
		}
		/*
		 * Traverse the list of loaded modules. The entry point
		 * returned by LOAD() does actually point to the data
		 * segment origin.
		 */
		lp = (struct ld_info *)buf;
		while (lp) {
			if (lp->ldinfo_dataorg == mp->entry) {
				ldp = ldopen(lp->ldinfo_filename, ldp);
				break;
			}
			if (lp->ldinfo_next == 0)
				lp = NULL;
			else
				lp = (struct ld_info *)((char *)lp + lp->ldinfo_next);
		}
		safefree(buf);
		if (!ldp) {
			dl_errvalid++;
			strcpy(dl_errbuf, "readExports: ");
			strerrorcat(dl_errbuf, errno);
			return -1;
		}
	}
#ifdef USE_64_BIT_ALL
	if (TYPE(ldp) != U803XTOCMAGIC) {
#else
	if (TYPE(ldp) != U802TOCMAGIC) {
#endif
		dl_errvalid++;
		strcpy(dl_errbuf, "readExports: bad magic");
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	if (ldnshread(ldp, _LOADER, &sh) != SUCCESS) {
		dl_errvalid++;
		strcpy(dl_errbuf, "readExports: cannot read loader section header");
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	/*
	 * We read the complete loader section in one chunk, this makes
	 * finding long symbol names residing in the string table easier.
	 */
	if ((ldbuf = (char *)safemalloc(sh.s_size)) == NULL) {
		dl_errvalid++;
		strcpy(dl_errbuf, "readExports: ");
		strerrorcat(dl_errbuf, errno);
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	if (FSEEK(ldp, sh.s_scnptr, BEGINNING) != OKFSEEK) {
		dl_errvalid++;
		strcpy(dl_errbuf, "readExports: cannot seek to loader section");
		safefree(ldbuf);
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
/* This first case is a hack, since it assumes that the 3rd parameter to
   FREAD is 1. See the redefinition of FREAD above to see how this works. */
	if (FREAD(ldbuf, sh.s_size, 1, ldp) != 1) {
		dl_errvalid++;
		strcpy(dl_errbuf, "readExports: cannot read loader section");
		safefree(ldbuf);
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	lhp = (AIX_LDHDR *)ldbuf;
	ls = (AIX_LDSYM *)(ldbuf+AIX_LDHDRSZ);
	/*
	 * Count the number of exports to include in our export table.
	 */
	for (i = lhp->l_nsyms; i; i--, ls++) {
		if (!LDR_EXPORT(*ls))
			continue;
		mp->nExports++;
	}
	Newxz(mp->exports, mp->nExports, Export);
	if (mp->exports == NULL) {
		dl_errvalid++;
		strcpy(dl_errbuf, "readExports: ");
		strerrorcat(dl_errbuf, errno);
		safefree(ldbuf);
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	/*
	 * Fill in the export table. All entries are relative to
	 * the entry point we got from load.
	 */
	ep = mp->exports;
	ls = (AIX_LDSYM *)(ldbuf+AIX_LDHDRSZ);
	for (i = lhp->l_nsyms; i; i--, ls++) {
		char *symname;
		if (!LDR_EXPORT(*ls))
			continue;
#ifndef USE_64_BIT_ALL
		if (ls->l_zeroes == 0)
#endif
			symname = ls->l_offset+lhp->l_stoff+ldbuf;
#ifndef USE_64_BIT_ALL
		else
			symname = ls->l_name;
#endif
		ep->name = savepv(symname);
		ep->addr = (void *)((unsigned long)mp->entry + ls->l_value);
		ep++;
	}
	safefree(ldbuf);
	while(ldclose(ldp) == FAILURE)
		;
	return 0;
}

/*
 * Find the main modules entry point. This is used as export pointer
 * for loadbind() to be able to resolve references to the main part.
 */
static void * findMain(void)
{
	dTHX;
	dMY_CXT;
	struct ld_info *lp;
	char *buf;
	int size = 4*1024;
	int i;
	void *ret;

	if ((buf = safemalloc(size)) == NULL) {
		dl_errvalid++;
		strcpy(dl_errbuf, "findMain: ");
		strerrorcat(dl_errbuf, errno);
		return NULL;
	}
	while ((i = loadquery(L_GETINFO, buf, size)) == -1 && errno == ENOMEM) {
		safefree(buf);
		size += 4*1024;
		if ((buf = safemalloc(size)) == NULL) {
			dl_errvalid++;
			strcpy(dl_errbuf, "findMain: ");
			strerrorcat(dl_errbuf, errno);
			return NULL;
		}
	}
	if (i == -1) {
		dl_errvalid++;
		strcpy(dl_errbuf, "findMain: ");
		strerrorcat(dl_errbuf, errno);
		safefree(buf);
		return NULL;
	}
	/*
	 * The first entry is the main module. The entry point
	 * returned by load() does actually point to the data
	 * segment origin.
	 */
	lp = (struct ld_info *)buf;
	ret = lp->ldinfo_dataorg;
	safefree(buf);
	return ret;
}
#endif /* USE_NATIVE_DLOPEN */

/* dl_dlopen.xs
 * 
 * Platform:	SunOS/Solaris, possibly others which use dlopen.
 * Author:	Paul Marquess (Paul.Marquess@@btinternet.com)
 * Created:	10th July 1994
 *
 * Modified:
 * 15th July 1994   - Added code to explicitly save any error messages.
 * 3rd August 1994  - Upgraded to v3 spec.
 * 9th August 1994  - Changed to use IV
 * 10th August 1994 - Tim Bunce: Added RTLD_LAZY, switchable debugging,
 *                    basic FreeBSD support, removed ClearError
 *
 */

/* Porting notes:

	see dl_dlopen.xs

*/

static void
dl_private_init(pTHX)
{
    (void)dl_generic_private_init(aTHX);
}
 
MODULE = DynaLoader     PACKAGE = DynaLoader

BOOT:
    (void)dl_private_init(aTHX);


void
dl_load_file(filename, flags=0)
	char *	filename
	int	flags
        PREINIT:
        void *retv;
	PPCODE:
	DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_load_file(%s,%x):\n", filename,flags));
	if (flags & 0x01)
	    Perl_warn(aTHX_ "Can't make loaded symbols global on this platform while loading %s",filename);
	retv = dlopen(filename, RTLD_GLOBAL|RTLD_LAZY) ;
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, " libref=%x\n", retv));
	ST(0) = sv_newmortal() ;
	if (retv == NULL)
	    SaveError(aTHX_ "%s",dlerror()) ;
	else
	    sv_setiv( ST(0), PTR2IV(retv) );
        XSRETURN(1);

int
dl_unload_file(libref)
    void *	libref
  CODE:
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_unload_file(%lx):\n", libref));
    RETVAL = (dlclose(libref) == 0 ? 1 : 0);
    if (!RETVAL)
        SaveError(aTHX_ "%s", dlerror()) ;
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " retval = %d\n", RETVAL));
  OUTPUT:
    RETVAL

void
dl_find_symbol(libhandle, symbolname, ign_err=0)
	void *		libhandle
	char *		symbolname
        int	        ign_err
	PREINIT:
        void *retv;
        CODE:
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "dl_find_symbol(handle=%x, symbol=%s)\n",
		libhandle, symbolname));
	retv = dlsym(libhandle, symbolname);
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "  symbolref = %x\n", retv));
	ST(0) = sv_newmortal();
	if (retv == NULL) {
            if (!ign_err)
	        SaveError(aTHX_ "%s", dlerror());
	} else
	    sv_setiv( ST(0), PTR2IV(retv));


void
dl_undef_symbols()
	CODE:



# These functions should not need changing on any platform:

void
dl_install_xsub(perl_name, symref, filename="$Package")
    char *	perl_name
    void *	symref 
    const char *	filename
    CODE:
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "dl_install_xsub(name=%s, symref=%x)\n",
	perl_name, symref));
    ST(0) = sv_2mortal(newRV((SV*)newXS_flags(perl_name,
					      (void(*)(pTHX_ CV *))symref,
					      filename, NULL,
					      XS_DYNAMIC_FILENAME)));


SV *
dl_error()
    CODE:
    dMY_CXT;
    RETVAL = newSVsv(MY_CXT.x_dl_last_error);
    OUTPUT:
    RETVAL

#if defined(USE_ITHREADS)

void
CLONE(...)
    CODE:
    MY_CXT_CLONE;

    PERL_UNUSED_VAR(items);

    /* MY_CXT_CLONE just does a memcpy on the whole structure, so to avoid
     * using Perl variables that belong to another thread, we create our 
     * own for this thread.
     */
    MY_CXT.x_dl_last_error = newSVpvs("");

#endif

# end.
@


1.12
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d15 2
d725 1
a725 1
dl_find_symbol(libhandle, symbolname)
d728 1
d736 5
a740 4
	ST(0) = sv_newmortal() ;
	if (retv == NULL)
	    SaveError(aTHX_ "%s",dlerror()) ;
	else
d766 1
a766 1
char *
d770 1
a770 1
    RETVAL = dl_last_error ;
d787 1
a787 1
    MY_CXT.x_dl_last_error = newSVpvn("", 0);
@


1.11
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d777 2
@


1.10
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d213 1
a213 1
	register ModulePtr mp;
d319 1
a319 1
	register char *p = s;
d356 3
a358 3
	register ModulePtr mp = (ModulePtr)handle;
	register ExportPtr ep;
	register int i;
d388 1
a388 1
	register ModulePtr mp = (ModulePtr)handle;
d390 1
a390 1
	register ModulePtr mp1;
d400 2
a401 2
		register ExportPtr ep;
		register int i;
d691 1
a691 1
void *
d695 3
a697 1
	CODE:
d701 2
a702 2
	RETVAL = dlopen(filename, RTLD_GLOBAL|RTLD_LAZY) ;
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, " libref=%x\n", RETVAL));
d704 1
a704 1
	if (RETVAL == NULL)
d707 2
a708 1
	    sv_setiv( ST(0), PTR2IV(RETVAL) );
d722 1
a722 1
void *
d726 3
a728 1
	CODE:
d731 2
a732 2
	RETVAL = dlsym(libhandle, symbolname);
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "  symbolref = %x\n", RETVAL));
d734 1
a734 1
	if (RETVAL == NULL)
d737 1
a737 1
	    sv_setiv( ST(0), PTR2IV(RETVAL));
d742 1
a742 1
	PPCODE:
@


1.9
log
@Merge in perl 5.10.1
@
text
@d11 1
a11 1
 *  on statup...   It can probably be trimmed more.
@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d747 1
a747 1
    char *	filename
d764 15
@


1.7
log
@merge in perl 5.8.8
@
text
@a181 14
#ifdef USE_5005THREADS
    char *buf = malloc(BUFSIZ);

    if (buf == 0)
      return 0;
    if (strerror_r(err, buf, BUFSIZ) == 0)
      msg = buf;
    else
      msg = strerror_r_failed;
    msgsiz = strlen(msg);
    if (strsiz + msgsiz < BUFSIZ)
      strcat(str, msg);
    free(buf);
#else
a188 1
#endif
a196 14
#ifdef USE_5005THREADS
    char *buf = malloc(BUFSIZ);

    if (buf == 0)
      return 0;
    if (strerror_r(err, buf, BUFSIZ) == 0)
      msg = buf;
    else
      msg = strerror_r_failed;
    msgsiz = strlen(msg);
    if (msgsiz < BUFSIZ)
      strcpy(str, msg);
    free(buf);
#else
a203 1
#endif
d751 4
a754 3
    ST(0) = sv_2mortal(newRV((SV*)newXS(perl_name,
					(void(*)(pTHX_ CV *))symref,
					filename)));
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d261 1
a261 1
	Newz(1000,mp,1,Module);
d601 1
a601 1
	Newz(1001, mp->exports, mp->nExports, Export);
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d17 17
d114 7
d145 18
a162 5
/*
 * We keep a list of all loaded modules to be able to reference count
 * duplicate dlopen's.
 */
static ModulePtr modList;		/* XXX threaded */
d164 4
a167 6
/*
 * The last error from one of the dl* routines is kept in static
 * variables here. Each error is returned only once to the caller.
 */
static char errbuf[BUFSIZ];		/* XXX threaded */
static int errvalid;			/* XXX threaded */
d173 1
d182 1
a182 1
#ifdef USE_THREADS
d196 2
d212 1
a212 1
#ifdef USE_THREADS
d226 2
d242 1
a243 1
	static void *mainModule;		/* XXX threaded */
d249 2
a250 2
	if (mainModule == NULL) {
		if ((mainModule = findMain()) == NULL)
d256 1
a256 1
	for (mp = modList; mp; mp = mp->next)
d263 3
a265 3
		errvalid++;
		strcpy(errbuf, "Newz: ");
		strerrorcat(errbuf, errno);
d270 3
a272 3
		errvalid++;
		strcpy(errbuf, "savepv: ");
		strerrorcat(errbuf, errno);
d291 4
a294 4
		errvalid++;
		strcpy(errbuf, "dlopen: ");
		strcat(errbuf, path);
		strcat(errbuf, ": ");
d303 1
a303 1
				strerrorcpy(errbuf, saverrno);
d310 1
a310 1
			strerrorcat(errbuf, saverrno);
d314 2
a315 2
	mp->next = modList;
	modList = mp;
d325 1
a325 1
	    loadbind(0, mainModule, mp->entry)) {
d329 3
a331 3
		errvalid++;
		strcpy(errbuf, "loadbind: ");
		strerrorcat(errbuf, saverrno);
d347 2
d355 1
a355 1
		strcat(errbuf, "too many errors");
d358 2
a359 2
		strcat(errbuf, "can't load library");
		strcat(errbuf, p);
d362 2
a363 2
		strcat(errbuf, "can't find symbol");
		strcat(errbuf, p);
d366 2
a367 2
		strcat(errbuf, "bad RLD");
		strcat(errbuf, p);
d370 2
a371 2
		strcat(errbuf, "bad exec format in");
		strcat(errbuf, p);
d374 1
a374 1
		strerrorcat(errbuf, atoi(++p));
d377 1
a377 1
		strcat(errbuf, s);
d384 2
d397 3
a399 3
	errvalid++;
	strcpy(errbuf, "dlsym: undefined symbol ");
	strcat(errbuf, symbol);
d405 5
a409 3
	if (errvalid) {
		errvalid = 0;
		return errbuf;
d416 2
d426 2
a427 2
		errvalid++;
		strerrorcpy(errbuf, errno);
d437 2
a438 2
	if (mp == modList)
		modList = mp->next;
d440 1
a440 1
		for (mp1 = modList; mp1; mp1 = mp1->next)
d472 1
d486 3
a488 3
			errvalid++;
			strcpy(errbuf, "readExports: ");
			strerrorcat(errbuf, errno);
d497 3
a499 3
			errvalid++;
			strcpy(errbuf, "readExports: ");
			strerrorcat(errbuf, errno);
d506 3
a508 3
				errvalid++;
				strcpy(errbuf, "readExports: ");
				strerrorcat(errbuf, errno);
d513 3
a515 3
			errvalid++;
			strcpy(errbuf, "readExports: ");
			strerrorcat(errbuf, errno);
d537 3
a539 3
			errvalid++;
			strcpy(errbuf, "readExports: ");
			strerrorcat(errbuf, errno);
d548 2
a549 2
		errvalid++;
		strcpy(errbuf, "readExports: bad magic");
d555 2
a556 2
		errvalid++;
		strcpy(errbuf, "readExports: cannot read loader section header");
d566 3
a568 3
		errvalid++;
		strcpy(errbuf, "readExports: ");
		strerrorcat(errbuf, errno);
d574 2
a575 2
		errvalid++;
		strcpy(errbuf, "readExports: cannot seek to loader section");
d584 2
a585 2
		errvalid++;
		strcpy(errbuf, "readExports: cannot read loader section");
d603 3
a605 3
		errvalid++;
		strcpy(errbuf, "readExports: ");
		strerrorcat(errbuf, errno);
d645 2
d654 3
a656 3
		errvalid++;
		strcpy(errbuf, "findMain: ");
		strerrorcat(errbuf, errno);
d663 3
a665 3
			errvalid++;
			strcpy(errbuf, "findMain: ");
			strerrorcat(errbuf, errno);
d670 3
a672 3
		errvalid++;
		strcpy(errbuf, "findMain: ");
		strerrorcat(errbuf, errno);
d686 1
a708 3
#include "dlutils.c"	/* SaveError() etc	*/


d729 1
a729 1
	RETVAL = dlopen(filename, 1) ;
d789 2
a790 1
    RETVAL = LastError ;
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d14 2
d41 2
d65 1
d69 2
a70 2
#   if defined(USE_xlC_load_h)
#       include "/usr/lpp/xlC/include/load.h"
d73 4
a96 6
/* If using PerlIO, redefine these macros from <ldfcn.h> */
#ifdef USE_PERLIO
#define FSEEK(ldptr,o,p)        PerlIO_seek(IOPTR(ldptr),(p==BEGINNING)?(OFFSET(ldptr)+o):o,p)
#define FREAD(p,s,n,ldptr)      PerlIO_read(IOPTR(ldptr),p,s*n)
#endif

d122 2
a123 2
 * We keep a list of all loaded modules to be able to call the fini
 * handlers at atexit() time.
d136 1
a136 1
static void terminate(void);
d203 1
a203 1
	static int inited;			/* XXX threaded */
d209 3
a211 3
	if (!inited) {
		inited++;
		atexit(terminate);
d279 4
a282 1
	 * of the perl core are in the same shared object.
d284 2
a285 1
	if (loadbind(0, (void *)dlopen, mp->entry) == -1) {
d313 1
a313 1
		strcat(errbuf, "to many errors");
a402 6
static void terminate(void)
{
	while (modList)
		dlclose(modList);
}

a533 3
#ifdef USE_PERLIO
	if (FREAD(ldbuf, sh.s_size, 1, ldp) != sh.s_size) {
#else
a534 1
#endif
d590 46
d688 11
@


1.3
log
@perl5.005_03 (stock)
@
text
@d23 9
d41 33
d122 1
a122 1
static ModulePtr modList;
d128 2
a129 2
static char errbuf[BUFSIZ];
static int errvalid;
a133 1
static void *findMain(void);
d148 1
a148 1
    if (strerror_r(err, buf, sizeof(buf)) == 0)
d176 1
a176 1
    if (strerror_r(err, buf, sizeof(buf)) == 0)
d198 1
d200 1
a200 1
	static void *mainModule;
d204 1
a204 2
	 * close all libraries. Also get a reference to the main module
	 * for use with loadbind.
d206 2
a207 3
	if (!mainModule) {
		if ((mainModule = findMain()) == NULL)
			return NULL;
d233 1
d238 8
a245 1
	if ((mp->entry = (void *)load((char *)path, L_NOAUTODEFER, NULL)) == NULL) {
d257 4
a260 4
		if (errno == ENOEXEC) {
			char *tmp[BUFSIZ/sizeof(char *)];
			if (loadquery(L_GETMESSAGES, tmp, sizeof(tmp)) == -1)
				strerrorcpy(errbuf, errno);
d263 1
a263 1
				for (p = tmp; *p; p++)
d267 1
a267 1
			strerrorcat(errbuf, errno);
d273 8
a280 1
	if (loadbind(0, mainModule, mp->entry) == -1) {
d284 1
a284 1
		strerrorcat(errbuf, errno);
d369 1
a369 1
	result = unload(mp->entry);
d422 1
d424 2
a425 2
	SCNHDR sh;
	LDHDR *lhp;
d427 1
a427 1
	LDSYM *ls;
d471 1
a471 1
		 * returned by load() does actually point to the data
d493 3
d497 1
d545 2
a546 2
	lhp = (LDHDR *)ldbuf;
	ls = (LDSYM *)(ldbuf+LDHDRSZ);
d570 1
a570 1
	ls = (LDSYM *)(ldbuf+LDHDRSZ);
d575 1
d577 1
d579 1
d582 1
a592 46
/*
 * Find the main modules entry point. This is used as export pointer
 * for loadbind() to be able to resolve references to the main part.
 */
static void * findMain(void)
{
	struct ld_info *lp;
	char *buf;
	int size = 4*1024;
	int i;
	void *ret;

	if ((buf = safemalloc(size)) == NULL) {
		errvalid++;
		strcpy(errbuf, "findMain: ");
		strerrorcat(errbuf, errno);
		return NULL;
	}
	while ((i = loadquery(L_GETINFO, buf, size)) == -1 && errno == ENOMEM) {
		safefree(buf);
		size += 4*1024;
		if ((buf = safemalloc(size)) == NULL) {
			errvalid++;
			strcpy(errbuf, "findMain: ");
			strerrorcat(errbuf, errno);
			return NULL;
		}
	}
	if (i == -1) {
		errvalid++;
		strcpy(errbuf, "findMain: ");
		strerrorcat(errbuf, errno);
		safefree(buf);
		return NULL;
	}
	/*
	 * The first entry is the main module. The entry point
	 * returned by load() does actually point to the data
	 * segment origin.
	 */
	lp = (struct ld_info *)buf;
	ret = lp->ldinfo_dataorg;
	safefree(buf);
	return ret;
}

d596 1
a596 1
 * Author:	Paul Marquess (pmarquess@@bfsec.bt.co.uk)
d618 1
a618 1
dl_private_init()
d620 1
a620 1
    (void)dl_generic_private_init();
d626 1
a626 1
    (void)dl_private_init();
d634 1
a634 1
	DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_load_file(%s,%x):\n", filename,flags));
d636 1
a636 1
	    warn("Can't make loaded symbols global on this platform while loading %s",filename);
d638 1
a638 1
	DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), " libref=%x\n", RETVAL));
d641 1
a641 1
	    SaveError("%s",dlerror()) ;
d643 1
a643 1
	    sv_setiv( ST(0), (IV)RETVAL);
d651 1
a651 1
	DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "dl_find_symbol(handle=%x, symbol=%s)\n",
d654 1
a654 1
	DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "  symbolref = %x\n", RETVAL));
d657 1
a657 1
	    SaveError("%s",dlerror()) ;
d659 1
a659 1
	    sv_setiv( ST(0), (IV)RETVAL);
d676 1
a676 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "dl_install_xsub(name=%s, symref=%x)\n",
d678 3
a680 1
    ST(0)=sv_2mortal(newRV((SV*)newXS(perl_name, (void(*)())symref, filename)));
@


1.2
log
@perl 5.004_04
@
text
@d32 14
d94 59
d182 1
a182 1
		strcat(errbuf, strerror(errno));
d189 1
a189 1
		strcat(errbuf, strerror(errno));
d212 1
a212 1
				strcpy(errbuf, strerror(errno));
d219 1
a219 1
			strcat(errbuf, strerror(errno));
d229 1
a229 1
		strcat(errbuf, strerror(errno));
d270 1
a270 1
		strcat(errbuf, strerror(atoi(++p)));
d317 1
a317 1
		strcpy(errbuf, strerror(errno));
d382 1
a382 1
			strcat(errbuf, strerror(errno));
d393 1
a393 1
			strcat(errbuf, strerror(errno));
d402 1
a402 1
				strcat(errbuf, strerror(errno));
d409 1
a409 1
			strcat(errbuf, strerror(errno));
d433 1
a433 1
			strcat(errbuf, strerror(errno));
d458 1
a458 1
		strcat(errbuf, strerror(errno));
d499 1
a499 1
		strcat(errbuf, strerror(errno));
d544 1
a544 1
		strcat(errbuf, strerror(errno));
d553 1
a553 1
			strcat(errbuf, strerror(errno));
d560 1
a560 1
		strcat(errbuf, strerror(errno));
@


1.1
log
@Initial revision
@
text
@d32 6
d398 5
d404 1
d539 3
a541 2
dl_load_file(filename)
	char *		filename
d543 3
a545 1
	DLDEBUG(1,fprintf(stderr,"dl_load_file(%s):\n", filename));
d547 1
a547 1
	DLDEBUG(2,fprintf(stderr," libref=%x\n", RETVAL));
d560 1
a560 1
	DLDEBUG(2,fprintf(stderr,"dl_find_symbol(handle=%x, symbol=%s)\n",
d563 1
a563 1
	DLDEBUG(2,fprintf(stderr,"  symbolref = %x\n", RETVAL));
d585 1
a585 1
    DLDEBUG(2,fprintf(stderr,"dl_install_xsub(name=%s, symref=%x)\n",
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a32 20
 * AIX 4.3 does remove some useful definitions from ldfcn.h. Define
 * these here to compensate for that lossage.
 */
#ifndef BEGINNING
# define BEGINNING SEEK_SET
#endif
#ifndef FSEEK
# define FSEEK(ldptr,o,p)	fseek(IOPTR(ldptr),(p==BEGINNING)?(OFFSET(ldptr) +o):o,p)
#endif
#ifndef FREAD
# define FREAD(p,s,n,ldptr)	fread(p,s,n,IOPTR(ldptr))
#endif

/* If using PerlIO, redefine these macros from <ldfcn.h> */
#ifdef USE_PERLIO
#define FSEEK(ldptr,o,p)        PerlIO_seek(IOPTR(ldptr),(p==BEGINNING)?(OFFSET(ldptr)+o):o,p)
#define FREAD(p,s,n,ldptr)      PerlIO_read(IOPTR(ldptr),p,s*n)
#endif

/*
a73 59
static char *strerror_failed   = "(strerror failed)";
static char *strerror_r_failed = "(strerror_r failed)";

char *strerrorcat(char *str, int err) {
    int strsiz = strlen(str);
    int msgsiz;
    char *msg;

#ifdef USE_THREADS
    char *buf = malloc(BUFSIZ);

    if (buf == 0)
      return 0;
    if (strerror_r(err, buf, sizeof(buf)) == 0)
      msg = buf;
    else
      msg = strerror_r_failed;
    msgsiz = strlen(msg);
    if (strsiz + msgsiz < BUFSIZ)
      strcat(str, msg);
    free(buf);
#else
    if ((msg = strerror(err)) == 0)
      msg = strerror_failed;
    msgsiz = strlen(msg);		/* Note msg = buf and free() above. */
    if (strsiz + msgsiz < BUFSIZ)	/* Do not move this after #endif. */
      strcat(str, msg);
#endif

    return str;
}

char *strerrorcpy(char *str, int err) {
    int msgsiz;
    char *msg;

#ifdef USE_THREADS
    char *buf = malloc(BUFSIZ);

    if (buf == 0)
      return 0;
    if (strerror_r(err, buf, sizeof(buf)) == 0)
      msg = buf;
    else
      msg = strerror_r_failed;
    msgsiz = strlen(msg);
    if (msgsiz < BUFSIZ)
      strcpy(str, msg);
    free(buf);
#else
    if ((msg = strerror(err)) == 0)
      msg = strerror_failed;
    msgsiz = strlen(msg);	/* Note msg = buf and free() above. */
    if (msgsiz < BUFSIZ)	/* Do not move this after #endif. */
      strcpy(str, msg);
#endif

    return str;
}
d103 1
a103 1
		strerrorcat(errbuf, errno);
d110 1
a110 1
		strerrorcat(errbuf, errno);
d133 1
a133 1
				strerrorcpy(errbuf, errno);
d140 1
a140 1
			strerrorcat(errbuf, errno);
d150 1
a150 1
		strerrorcat(errbuf, errno);
d191 1
a191 1
		strerrorcat(errbuf, atoi(++p));
d238 1
a238 1
		strerrorcpy(errbuf, errno);
d303 1
a303 1
			strerrorcat(errbuf, errno);
d314 1
a314 1
			strerrorcat(errbuf, errno);
d323 1
a323 1
				strerrorcat(errbuf, errno);
d330 1
a330 1
			strerrorcat(errbuf, errno);
d354 1
a354 1
			strerrorcat(errbuf, errno);
d379 1
a379 1
		strerrorcat(errbuf, errno);
a391 5
/* This first case is a hack, since it assumes that the 3rd parameter to
   FREAD is 1. See the redefinition of FREAD above to see how this works. */
#ifdef USE_PERLIO
	if (FREAD(ldbuf, sh.s_size, 1, ldp) != sh.s_size) {
#else
a392 1
#endif
d414 1
a414 1
		strerrorcat(errbuf, errno);
d459 1
a459 1
		strerrorcat(errbuf, errno);
d468 1
a468 1
			strerrorcat(errbuf, errno);
d475 1
a475 1
		strerrorcat(errbuf, errno);
d527 2
a528 3
dl_load_file(filename, flags=0)
	char *	filename
	int	flags
d530 1
a530 3
	DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_load_file(%s,%x):\n", filename,flags));
	if (flags & 0x01)
	    warn("Can't make loaded symbols global on this platform while loading %s",filename);
d532 1
a532 1
	DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), " libref=%x\n", RETVAL));
d545 1
a545 1
	DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "dl_find_symbol(handle=%x, symbol=%s)\n",
d548 1
a548 1
	DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "  symbolref = %x\n", RETVAL));
d570 1
a570 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "dl_install_xsub(name=%s, symref=%x)\n",
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a22 9
/* When building as a 64-bit binary on AIX, define this to get the
 * correct structure definitions.  Also determines the field-name
 * macros and gates some logic in readEntries().  -- Steven N. Hirsch
 * <hirschs@@btv.ibm.com> */
#ifdef USE_64_BIT_ALL
#   define __XCOFF64__
#   define __XCOFF32__
#endif

a31 33
#ifdef USE_64_BIT_ALL
#   define AIX_SCNHDR SCNHDR_64
#   define AIX_LDHDR LDHDR_64
#   define AIX_LDSYM LDSYM_64
#   define AIX_LDHDRSZ LDHDRSZ_64
#else
#   define AIX_SCNHDR SCNHDR
#   define AIX_LDHDR LDHDR
#   define AIX_LDSYM LDSYM
#   define AIX_LDHDRSZ LDHDRSZ
#endif

/* When using Perl extensions written in C++ the longer versions
 * of load() and unload() from libC and libC_r need to be used,
 * otherwise statics in the extensions won't get initialized right.
 * -- Stephanie Beals <bealzy@@us.ibm.com> */

/* Older AIX C compilers cannot deal with C++ double-slash comments in
   the ibmcxx and/or xlC includes.  Since we only need a single file,
   be more fine-grained about what's included <hirschs@@btv.ibm.com> */
#ifdef USE_libC /* The define comes, when it comes, from hints/aix.pl. */
#   define LOAD   loadAndInit
#   define UNLOAD terminateAndUnload
#   if defined(USE_xlC_load_h)
#       include "/usr/lpp/xlC/include/load.h"
#   elif defined(USE_ibmcxx_load_h)
#       include "/usr/ibmcxx/include/load.h"
#   endif
#else
#   define LOAD   load
#   define UNLOAD unload
#endif

d80 1
a80 1
static ModulePtr modList;		/* XXX threaded */
d86 2
a87 2
static char errbuf[BUFSIZ];		/* XXX threaded */
static int errvalid;			/* XXX threaded */
d92 1
d107 1
a107 1
    if (strerror_r(err, buf, BUFSIZ) == 0)
d135 1
a135 1
    if (strerror_r(err, buf, BUFSIZ) == 0)
a156 1
	dTHX;
d158 1
a158 1
	static int inited;			/* XXX threaded */
d162 2
a163 1
	 * close all libraries.
d165 3
a167 2
	if (!inited) {
		inited++;
a192 1

d197 1
a197 8
	if ((mp->entry = (void *)LOAD((char *)path,
#ifdef L_LIBPATH_EXEC
				      L_LIBPATH_EXEC |
#endif
				      L_NOAUTODEFER,
				      NULL)) == NULL) {
	        int saverrno = errno;
		
d209 4
a212 4
		if (saverrno == ENOEXEC) {
			char *moreinfo[BUFSIZ/sizeof(char *)];
			if (loadquery(L_GETMESSAGES, moreinfo, sizeof(moreinfo)) == -1)
				strerrorcpy(errbuf, saverrno);
d215 1
a215 1
				for (p = moreinfo; *p; p++)
d219 1
a219 1
			strerrorcat(errbuf, saverrno);
d225 1
a225 8
	/*
	 * Assume anonymous exports come from the module this dlopen
	 * is linked into, that holds true as long as dlopen and all
	 * of the perl core are in the same shared object.
	 */
	if (loadbind(0, (void *)dlopen, mp->entry) == -1) {
	        int saverrno = errno;

d229 1
a229 1
		strerrorcat(errbuf, saverrno);
d314 1
a314 1
	result = UNLOAD(mp->entry);
a366 1
	dTHX;
d368 2
a369 2
	AIX_SCNHDR sh;
	AIX_LDHDR *lhp;
d371 1
a371 1
	AIX_LDSYM *ls;
d415 1
a415 1
		 * returned by LOAD() does actually point to the data
a436 3
#ifdef USE_64_BIT_ALL
	if (TYPE(ldp) != U803XTOCMAGIC) {
#else
a437 1
#endif
d485 2
a486 2
	lhp = (AIX_LDHDR *)ldbuf;
	ls = (AIX_LDSYM *)(ldbuf+AIX_LDHDRSZ);
d510 1
a510 1
	ls = (AIX_LDSYM *)(ldbuf+AIX_LDHDRSZ);
a514 1
#ifndef USE_64_BIT_ALL
a515 1
#endif
a516 1
#ifndef USE_64_BIT_ALL
a518 1
#endif
d529 46
d578 1
a578 1
 * Author:	Paul Marquess (Paul.Marquess@@btinternet.com)
d600 1
a600 1
dl_private_init(pTHX)
d602 1
a602 1
    (void)dl_generic_private_init(aTHX);
d608 1
a608 1
    (void)dl_private_init(aTHX);
d616 1
a616 1
	DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_load_file(%s,%x):\n", filename,flags));
d618 1
a618 1
	    Perl_warn(aTHX_ "Can't make loaded symbols global on this platform while loading %s",filename);
d620 1
a620 1
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, " libref=%x\n", RETVAL));
d623 1
a623 1
	    SaveError(aTHX_ "%s",dlerror()) ;
d625 1
a625 1
	    sv_setiv( ST(0), PTR2IV(RETVAL) );
d633 1
a633 1
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "dl_find_symbol(handle=%x, symbol=%s)\n",
d636 1
a636 1
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "  symbolref = %x\n", RETVAL));
d639 1
a639 1
	    SaveError(aTHX_ "%s",dlerror()) ;
d641 1
a641 1
	    sv_setiv( ST(0), PTR2IV(RETVAL));
d658 1
a658 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "dl_install_xsub(name=%s, symref=%x)\n",
d660 1
a660 3
    ST(0) = sv_2mortal(newRV((SV*)newXS(perl_name,
					(void(*)(pTHX_ CV *))symref,
					filename)));
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a13 2
#define PERLIO_NOT_STDIO 0

a38 2
#undef FREAD
#undef FWRITE
a60 1

d64 2
a65 2
#   if defined(USE_vacpp_load_h)
#       include "/usr/vacpp/include/load.h"
a67 4
#   elif defined(USE_xlC_load_h)
#       include "/usr/lpp/xlC/include/load.h"
#   elif defined(USE_load_h)
#       include "/usr/include/load.h"
d88 6
d119 2
a120 2
 * We keep a list of all loaded modules to be able to reference count
 * duplicate dlopen's.
d133 1
a133 1
static void *findMain(void);
d200 1
a200 1
	static void *mainModule;		/* XXX threaded */
d206 3
a208 3
	if (mainModule == NULL) {
		if ((mainModule = findMain()) == NULL)
			return NULL;
d276 1
a276 4
	 * of the perl core are in the same shared object. Also bind
	 * against the main part, in the case a perl is not the main
	 * part, e.g mod_perl as DSO in Apache so perl modules can
	 * also reference Apache symbols.
d278 1
a278 2
	if (loadbind(0, (void *)dlopen, mp->entry) == -1 ||
	    loadbind(0, mainModule, mp->entry)) {
d306 1
a306 1
		strcat(errbuf, "too many errors");
d396 6
d533 3
d537 1
a592 46
/*
 * Find the main modules entry point. This is used as export pointer
 * for loadbind() to be able to resolve references to the main part.
 */
static void * findMain(void)
{
	struct ld_info *lp;
	char *buf;
	int size = 4*1024;
	int i;
	void *ret;

	if ((buf = safemalloc(size)) == NULL) {
		errvalid++;
		strcpy(errbuf, "findMain: ");
		strerrorcat(errbuf, errno);
		return NULL;
	}
	while ((i = loadquery(L_GETINFO, buf, size)) == -1 && errno == ENOMEM) {
		safefree(buf);
		size += 4*1024;
		if ((buf = safemalloc(size)) == NULL) {
			errvalid++;
			strcpy(errbuf, "findMain: ");
			strerrorcat(errbuf, errno);
			return NULL;
		}
	}
	if (i == -1) {
		errvalid++;
		strcpy(errbuf, "findMain: ");
		strerrorcat(errbuf, errno);
		safefree(buf);
		return NULL;
	}
	/*
	 * The first entry is the main module. The entry point
	 * returned by load() does actually point to the data
	 * segment origin.
	 */
	lp = (struct ld_info *)buf;
	ret = lp->ldinfo_dataorg;
	safefree(buf);
	return ret;
}

a644 11
int
dl_unload_file(libref)
    void *	libref
  CODE:
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_unload_file(%lx):\n", libref));
    RETVAL = (dlclose(libref) == 0 ? 1 : 0);
    if (!RETVAL)
        SaveError(aTHX_ "%s", dlerror()) ;
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " retval = %d\n", RETVAL));
  OUTPUT:
    RETVAL
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a16 17
 * On AIX 4.3 and above the emulation layer is not needed any more, and
 * indeed if perl uses its emulation and perl is linked into apache
 * which is supposed to use the native dlopen conflicts arise.
 * Jens-Uwe Mager jum@@helios.de
 */
#ifdef USE_NATIVE_DLOPEN

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include <dlfcn.h>

#include "dlutils.c"	/* SaveError() etc	*/

#else

/*
a96 7
#ifndef RTLD_LAZY
# define RTLD_LAZY 0
#endif
#ifndef RTLD_GLOBAL
# define RTLD_GLOBAL 0
#endif

d121 5
a125 15
typedef struct {
    /*
     * We keep a list of all loaded modules to be able to reference count
     * duplicate dlopen's.
     */
    ModulePtr	x_modList;

    /*
     * The last error from one of the dl* routines is kept in static
     * variables here. Each error is returned only once to the caller.
     */
    char	x_errbuf[BUFSIZ];
    int		x_errvalid;
    void *	x_mainModule;
} my_cxtx_t;		/* this *must* be named my_cxtx_t */
d127 6
a132 7
#define DL_CXT_EXTRA	/* ask for dl_cxtx to be defined in dlutils.c */
#include "dlutils.c"	/* SaveError() etc	*/

#define dl_modList	(dl_cxtx.x_modList)
#define dl_errbuf	(dl_cxtx.x_errbuf)
#define dl_errvalid	(dl_cxtx.x_errvalid)
#define dl_mainModule	(dl_cxtx.x_mainModule)
a137 1
/* these statics are ok because they're constants */
d146 1
a146 1
#ifdef USE_5005THREADS
a159 2
    dTHX;

d174 1
a174 1
#ifdef USE_5005THREADS
a187 2
    dTHX;

a201 1
	dMY_CXT;
d203 1
d209 2
a210 2
	if (dl_mainModule == NULL) {
		if ((dl_mainModule = findMain()) == NULL)
d216 1
a216 1
	for (mp = dl_modList; mp; mp = mp->next)
d223 3
a225 3
		dl_errvalid++;
		strcpy(dl_errbuf, "Newz: ");
		strerrorcat(dl_errbuf, errno);
d230 3
a232 3
		dl_errvalid++;
		strcpy(dl_errbuf, "savepv: ");
		strerrorcat(dl_errbuf, errno);
d251 4
a254 4
		dl_errvalid++;
		strcpy(dl_errbuf, "dlopen: ");
		strcat(dl_errbuf, path);
		strcat(dl_errbuf, ": ");
d263 1
a263 1
				strerrorcpy(dl_errbuf, saverrno);
d270 1
a270 1
			strerrorcat(dl_errbuf, saverrno);
d274 2
a275 2
	mp->next = dl_modList;
	dl_modList = mp;
d285 1
a285 1
	    loadbind(0, dl_mainModule, mp->entry)) {
d289 3
a291 3
		dl_errvalid++;
		strcpy(dl_errbuf, "loadbind: ");
		strerrorcat(dl_errbuf, saverrno);
a306 2
	dTHX;
	dMY_CXT;
d313 1
a313 1
		strcat(dl_errbuf, "too many errors");
d316 2
a317 2
		strcat(dl_errbuf, "can't load library");
		strcat(dl_errbuf, p);
d320 2
a321 2
		strcat(dl_errbuf, "can't find symbol");
		strcat(dl_errbuf, p);
d324 2
a325 2
		strcat(dl_errbuf, "bad RLD");
		strcat(dl_errbuf, p);
d328 2
a329 2
		strcat(dl_errbuf, "bad exec format in");
		strcat(dl_errbuf, p);
d332 1
a332 1
		strerrorcat(dl_errbuf, atoi(++p));
d335 1
a335 1
		strcat(dl_errbuf, s);
a341 2
	dTHX;
	dMY_CXT;
d353 3
a355 3
	dl_errvalid++;
	strcpy(dl_errbuf, "dlsym: undefined symbol ");
	strcat(dl_errbuf, symbol);
d361 3
a363 5
	dTHX;
	dMY_CXT;
	if (dl_errvalid) {
		dl_errvalid = 0;
		return dl_errbuf;
a369 2
	dTHX;
	dMY_CXT;
d378 2
a379 2
		dl_errvalid++;
		strerrorcpy(dl_errbuf, errno);
d389 2
a390 2
	if (mp == dl_modList)
		dl_modList = mp->next;
d392 1
a392 1
		for (mp1 = dl_modList; mp1; mp1 = mp1->next)
a423 1
	dMY_CXT;
d437 3
a439 3
			dl_errvalid++;
			strcpy(dl_errbuf, "readExports: ");
			strerrorcat(dl_errbuf, errno);
d448 3
a450 3
			dl_errvalid++;
			strcpy(dl_errbuf, "readExports: ");
			strerrorcat(dl_errbuf, errno);
d457 3
a459 3
				dl_errvalid++;
				strcpy(dl_errbuf, "readExports: ");
				strerrorcat(dl_errbuf, errno);
d464 3
a466 3
			dl_errvalid++;
			strcpy(dl_errbuf, "readExports: ");
			strerrorcat(dl_errbuf, errno);
d488 3
a490 3
			dl_errvalid++;
			strcpy(dl_errbuf, "readExports: ");
			strerrorcat(dl_errbuf, errno);
d499 2
a500 2
		dl_errvalid++;
		strcpy(dl_errbuf, "readExports: bad magic");
d506 2
a507 2
		dl_errvalid++;
		strcpy(dl_errbuf, "readExports: cannot read loader section header");
d517 3
a519 3
		dl_errvalid++;
		strcpy(dl_errbuf, "readExports: ");
		strerrorcat(dl_errbuf, errno);
d525 2
a526 2
		dl_errvalid++;
		strcpy(dl_errbuf, "readExports: cannot seek to loader section");
d535 2
a536 2
		dl_errvalid++;
		strcpy(dl_errbuf, "readExports: cannot read loader section");
d554 3
a556 3
		dl_errvalid++;
		strcpy(dl_errbuf, "readExports: ");
		strerrorcat(dl_errbuf, errno);
a595 2
	dTHX;
	dMY_CXT;
d603 3
a605 3
		dl_errvalid++;
		strcpy(dl_errbuf, "findMain: ");
		strerrorcat(dl_errbuf, errno);
d612 3
a614 3
			dl_errvalid++;
			strcpy(dl_errbuf, "findMain: ");
			strerrorcat(dl_errbuf, errno);
d619 3
a621 3
		dl_errvalid++;
		strcpy(dl_errbuf, "findMain: ");
		strerrorcat(dl_errbuf, errno);
a634 1
#endif /* USE_NATIVE_DLOPEN */
d657 3
d680 1
a680 1
	RETVAL = dlopen(filename, RTLD_GLOBAL|RTLD_LAZY) ;
d740 1
a740 2
    dMY_CXT;
    RETVAL = dl_last_error ;
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d261 1
a261 1
	Newxz(mp,1,Module);
d601 1
a601 1
	Newxz(mp->exports, mp->nExports, Export);
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d182 14
d203 1
d212 14
d233 1
d781 3
a783 4
    ST(0) = sv_2mortal(newRV((SV*)newXS_flags(perl_name,
					      (void(*)(pTHX_ CV *))symref,
					      filename, NULL,
					      XS_DYNAMIC_FILENAME)));
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d747 1
a747 1
    const char *	filename
a763 15

#if defined(USE_ITHREADS)

void
CLONE(...)
    CODE:
    MY_CXT_CLONE;

    /* MY_CXT_CLONE just does a memcpy on the whole structure, so to avoid
     * using Perl variables that belong to another thread, we create our 
     * own for this thread.
     */
    MY_CXT.x_dl_last_error = newSVpvn("", 0);

#endif
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d11 1
a11 1
 *  on startup...   It can probably be trimmed more.
@


1.1.1.10
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d213 1
a213 1
	ModulePtr mp;
d319 1
a319 1
	char *p = s;
d356 3
a358 3
	ModulePtr mp = (ModulePtr)handle;
	ExportPtr ep;
	int i;
d388 1
a388 1
	ModulePtr mp = (ModulePtr)handle;
d390 1
a390 1
	ModulePtr mp1;
d400 2
a401 2
		ExportPtr ep;
		int i;
d691 1
a691 1
void
d695 1
a695 3
        PREINIT:
        void *retv;
	PPCODE:
d699 2
a700 2
	retv = dlopen(filename, RTLD_GLOBAL|RTLD_LAZY) ;
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, " libref=%x\n", retv));
d702 1
a702 1
	if (retv == NULL)
d705 1
a705 2
	    sv_setiv( ST(0), PTR2IV(retv) );
        XSRETURN(1);
d719 1
a719 1
void
d723 1
a723 3
	PREINIT:
        void *retv;
        CODE:
d726 2
a727 2
	retv = dlsym(libhandle, symbolname);
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "  symbolref = %x\n", retv));
d729 1
a729 1
	if (retv == NULL)
d732 1
a732 1
	    sv_setiv( ST(0), PTR2IV(retv));
d737 1
a737 1
	CODE:
@


1.1.1.11
log
@Import perl-5.20.1
@
text
@a776 2
    PERL_UNUSED_VAR(items);

@


