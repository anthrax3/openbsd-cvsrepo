head	1.2;
access;
symbols
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.4
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.3.0.10
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.4
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.6
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.22
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.20
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.16
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.14
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.12
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.10
	OPENBSD_5_0:1.1.1.2.0.8
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.6
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.4
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.2
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.12;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2008.09.29.17.18.16;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.29.17.18.16;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.10.12.18.11.11;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	1.1.1.4;
commitid	B31cAbBIXiCqnL97;

1.1.1.4
date	2017.08.14.13.46.11;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/* dl_symbian.xs
 * 
 * Platform:	Symbian 7.0s
 * Author:	Jarkko Hietaniemi <jarkko.hietaniemi@@nokia.com>
 * Copyright:	2004, Nokia
 * License:	Artistic/GPL
 *
 */

/*
 * In Symbian DLLs there is no name information, one can only access
 * the functions by their ordinals.  Perl, however, very much would like
 * to load functions by their names.  We fake this by having a special
 * setup function at the ordinal 1 (this is arranged by building the DLLs
 * in a special way).  The setup function builds a Perl hash mapping the
 * names to the ordinals, and the hash is then used by dlsym().
 *
 */

#include <e32base.h>
#include <eikdll.h>
#include <utf.h>

/* This is a useful pattern: first include the Symbian headers,
 * only after that the Perl ones.  Otherwise you will get a lot
 * trouble because of Symbian's New(), Copy(), etc definitions. */

#define PERL_EXT
#define PERL_IN_DL_SYMBIAN_XS

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

START_EXTERN_C

void *dlopen(const char *filename, int flag);
void *dlsym(void *handle, const char *symbol);
int   dlclose(void *handle);
const char *dlerror(void);

extern void*  memset(void *s, int c, size_t n);
extern size_t strlen(const char *s);

END_EXTERN_C

#include "dlutils.c"

#define RTLD_LAZY   0x0001
#define RTLD_NOW    0x0002
#define RTLD_GLOBAL 0x0004

#ifndef NULL
#  define NULL 0
#endif

/* No need to pull in symbian_dll.cpp for this. */
#define symbian_get_vars() ((void*)Dll::Tls())

const TInt KPerlDllSetupFunction = 1;

typedef struct {
    RLibrary	handle;
    TInt	error;
    HV*		symbols;
} PerlSymbianLibHandle;

typedef void (*PerlSymbianLibInit)(void *);

void* dlopen(const char *filename, int flags) {
    TBuf16<KMaxFileName> utf16fn;
    const TUint8* utf8fn = (const TUint8*)filename;
    PerlSymbianLibHandle* h = NULL;
    TInt error;

    error =
        CnvUtfConverter::ConvertToUnicodeFromUtf8(utf16fn, TPtrC8(utf8fn));
    if (error == KErrNone) {
        h = new PerlSymbianLibHandle;
        if (h) {
            h->error   = KErrNone;
            h->symbols = (HV *)NULL;
        } else
            error = KErrNoMemory;
    }

    if (h && error == KErrNone) {
        error = (h->handle).Load(utf16fn);
        if (error == KErrNone) {
            TLibraryFunction init = (h->handle).Lookup(KPerlDllSetupFunction);
            ((PerlSymbianLibInit)init)(h);
        } else {
	    free(h);
            h = NULL;
        }
    }

    if (h)
        h->error = error;

    return h;
}

void* dlsym(void *handle, const char *symbol) {
    if (handle) {
        dTHX;
        PerlSymbianLibHandle* h = (PerlSymbianLibHandle*)handle;
        HV* symbols = h->symbols;
        if (symbols) {
            SV** svp = hv_fetch(symbols, symbol, strlen(symbol), FALSE);
            if (svp && *svp && SvIOK(*svp)) {
                IV ord = SvIV(*svp);
                if (ord > 0)
                    return (void*)((h->handle).Lookup(ord));
            }
        }
    }
    return NULL;
}

int dlclose(void *handle) {
    PerlSymbianLibHandle* h = (PerlSymbianLibHandle*)handle;
    if (h) {
        (h->handle).Close();
        if (h->symbols) {
            dTHX;
            hv_undef(h->symbols);
            h->symbols = NULL;
        }
        return 0;
    } else
        return 1;
}

const char* dlerror(void) {
    return 0;	/* Bad interface: assumes static data. */
}

static void
dl_private_init(pTHX)
{
    (void)dl_generic_private_init(aTHX);
}
 
MODULE = DynaLoader	PACKAGE = DynaLoader

PROTOTYPES:  ENABLE

BOOT:
    (void)dl_private_init(aTHX);


void
dl_load_file(filename, flags=0)
    char *	filename
    int		flags
  PREINIT:
    PerlSymbianLibHandle* h;
  CODE:
{
    ST(0) = sv_newmortal();
    h = (PerlSymbianLibHandle*)dlopen(filename, flags);
    if (h && h->error == KErrNone)
	sv_setiv(ST(0), PTR2IV(h));
    else
        SaveError(aTHX_ "(dl_load_file %s %d)"
                        filename, h ? h->error : -1);
}


int
dl_unload_file(libhandle)
    void *	libhandle
  CODE:
    RETVAL = (dlclose(libhandle) == 0 ? 1 : 0);
  OUTPUT:
    RETVAL


void
dl_find_symbol(libhandle, symbolname, ign_err=0)
    void *	libhandle
    char *	symbolname
    int	        ign_err
    PREINIT:
    void *sym;
    CODE:
    PerlSymbianLibHandle* h = (PerlSymbianLibHandle*)libhandle;
    sym = dlsym(libhandle, symbolname);
    ST(0) = sv_newmortal();
    if (sym) {
       sv_setiv(ST(0), PTR2IV(sym));
    } else {
       if (!ign_err)
           SaveError(aTHX_ "(dl_find_symbol %s %d)",
                     symbolname, h ? h->error : -1);
    }


void
dl_undef_symbols()
    CODE:



# These functions should not need changing on any platform:

void
dl_install_xsub(perl_name, symref, filename="$Package")
    char *		perl_name
    void *		symref 
    const char *	filename
    CODE:
    ST(0) = sv_2mortal(newRV((SV*)newXS_flags(perl_name,
					      (void(*)(pTHX_ CV *))symref,
					      filename, NULL,
					      XS_DYNAMIC_FILENAME)));


SV *
dl_error()
    CODE:
    dMY_CXT;
    RETVAL = newSVsv(MY_CXT.x_dl_last_error);
    OUTPUT:
    RETVAL

#if defined(USE_ITHREADS)

void
CLONE(...)
    CODE:
    MY_CXT_CLONE;

    PERL_UNUSED_VAR(items);

    /* MY_CXT_CLONE just does a memcpy on the whole structure, so to avoid
     * using Perl variables that belong to another thread, we create our 
     * own for this thread.
     */
    MY_CXT.x_dl_last_error = newSVpvs("");

#endif

# end.
@


1.1
log
@Initial revision
@
text
@d28 2
a29 1
#define DL_SYMBIAN_XS
d82 1
a82 1
            h->symbols = Nullhv;
d166 2
a167 2
	PerlIO_printf(Perl_debug_log, "(dl_load_file %s %d)",
                      filename, h ? h->error : -1);
d181 1
a181 1
dl_find_symbol(libhandle, symbolname)
d184 1
d191 1
a191 1
    if (sym)
d193 3
a195 2
    else
       PerlIO_printf(Perl_debug_log, "(dl_find_symbol %s %d)",
d197 1
d212 1
a212 1
    char *		filename
d220 1
a220 1
char *
d224 1
a224 1
    RETVAL = dl_last_error;
d227 17
@


1.1.1.1
log
@import perl 5.10.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.1
@
text
@d81 1
a81 1
            h->symbols = (HV *)NULL;
d208 1
a208 1
    const char *	filename
a222 15

#if defined(USE_ITHREADS)

void
CLONE(...)
    CODE:
    MY_CXT_CLONE;

    /* MY_CXT_CLONE just does a memcpy on the whole structure, so to avoid
     * using Perl variables that belong to another thread, we create our 
     * own for this thread.
     */
    MY_CXT.x_dl_last_error = newSVpvn("", 0);

#endif
@


1.1.1.3
log
@Import perl-5.20.1
@
text
@a230 2
    PERL_UNUSED_VAR(items);

@


1.1.1.4
log
@Import perl-5.24.2
@
text
@d28 1
a28 2
#define PERL_EXT
#define PERL_IN_DL_SYMBIAN_XS
d165 2
a166 2
        SaveError(aTHX_ "(dl_load_file %s %d)"
                        filename, h ? h->error : -1);
d180 1
a180 1
dl_find_symbol(libhandle, symbolname, ign_err=0)
a182 1
    int	        ign_err
d189 1
a189 1
    if (sym) {
d191 2
a192 3
    } else {
       if (!ign_err)
           SaveError(aTHX_ "(dl_find_symbol %s %d)",
a193 1
    }
d216 1
a216 1
SV *
d220 1
a220 1
    RETVAL = newSVsv(MY_CXT.x_dl_last_error);
d237 1
a237 1
    MY_CXT.x_dl_last_error = newSVpvs("");
@


