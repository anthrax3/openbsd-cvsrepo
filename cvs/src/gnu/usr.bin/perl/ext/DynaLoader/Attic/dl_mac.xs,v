head	1.8;
access;
symbols
	OPENBSD_5_3:1.7.0.10
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.8
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.5.0.6
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.4.0.20
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.18
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.16
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.14
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.12
	OPENBSD_4_0_BASE:1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.4.0.10
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.8
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.6
	OPENBSD_3_7_BASE:1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	PERL_5_8_0:1.1.1.2
	OPENBSD_3_2:1.2.0.6
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	PERL_5_6_1:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.8
date	2013.03.25.20.40.54;	author sthen;	state dead;
branches;
next	1.7;

1.7
date	2010.09.24.15.06.56;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.12.18.24.27;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2008.09.29.17.36.04;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.03.03.02.28;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.27.22.25.22;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.24.18.35.10;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.24.18.22.47;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.24.18.22.47;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.45.57;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.01.15.21.16.46;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.16;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.11.11;	author millert;	state Exp;
branches;
next	;


desc
@@


1.8
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@/* dl_mac.xs
 * 
 * Platform:	Macintosh CFM
 * Author:	Matthias Neeracher <neeri@@iis.ee.ethz.ch>
 *		Adapted from dl_dlopen.xs reference implementation by
 *              Paul Marquess (pmarquess@@bfsec.bt.co.uk)
 * $Log: dl_mac.xs,v $
 * Revision 1.3  1998/04/07 01:47:24  neeri
 * MacPerl 5.2.0r4b1
 *
 * Revision 1.2  1997/08/08 16:39:18  neeri
 * MacPerl 5.1.4b1 + time() fix
 *
 * Revision 1.1  1997/04/07 20:48:23  neeri
 * Synchronized with MacPerl 5.1.4a1
 *
 */

#define MAC_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include <CodeFragments.h>

typedef CFragConnectionID ConnectionID;

typedef struct {
    ConnectionID **	x_connections;
} my_cxtx_t;		/* this *must* be named my_cxtx_t */

#define DL_CXT_EXTRA	/* ask for dl_cxtx to be defined in dlutils.c */
#include "dlutils.c"	/* SaveError() etc	*/

#define dl_connections	(dl_cxtx.x_connections)

static void terminate(pTHX_ void *ptr)
{
    dMY_CXT;
    int size = GetHandleSize((Handle) dl_connections) / sizeof(ConnectionID);
    HLock((Handle) dl_connections);
    while (size)
    	CloseConnection(*dl_connections + --size);
    DisposeHandle((Handle) dl_connections);
    dl_connections = nil;
}

static void
dl_private_init(pTHX)
{
    (void)dl_generic_private_init(aTHX);
}

MODULE = DynaLoader	PACKAGE = DynaLoader

BOOT:
    (void)dl_private_init(aTHX);


ConnectionID
dl_load_file(filename, flags=0)
    char *		filename
    int			flags
    PREINIT:
    OSErr		err;
    FSSpec		spec;
    ConnectionID	connID;
    Ptr			mainAddr;
    Str255		errName;
    CODE:
    DLDEBUG(1,PerlIO_printf(Perl_debug_log,"dl_load_file(%s):\n", filename));
    err = GUSIPath2FSp(filename, &spec);
    if (!err)
    	err = 
	    GetDiskFragment(
	    	&spec, 0, 0, spec.name, kLoadCFrag, &connID, &mainAddr, errName);
    if (!err) {
	dMY_CXT;
    	if (!dl_connections) {
	    dl_connections = (ConnectionID **)NewHandle(0);
	    call_atexit(terminate, (void*)0);
    	}
        PtrAndHand((Ptr) &connID, (Handle) dl_connections, sizeof(ConnectionID));
    	RETVAL = connID;
    } else
    	RETVAL = (ConnectionID) 0;
    DLDEBUG(2,PerlIO_printf(Perl_debug_log," libref=%d\n", RETVAL));
    ST(0) = sv_newmortal() ;
    if (err)
    	SaveError(aTHX_ "DynaLoader error [%d, %#s]", err, errName) ;
    else
    	sv_setiv( ST(0), (IV)RETVAL);

void *
dl_find_symbol(connID, symbol)
    ConnectionID	connID
    Str255		symbol
    CODE:
    {
    	OSErr		    err;
    	Ptr		    symAddr;
    	CFragSymbolClass    symClass;
    	DLDEBUG(2,PerlIO_printf(Perl_debug_log,"dl_find_symbol(handle=%x, symbol=%#s)\n",
	    connID, symbol));
   	err = FindSymbol(connID, symbol, &symAddr, &symClass);
    	if (err)
    	    symAddr = (Ptr) 0;
    	RETVAL = (void *) symAddr;
    	DLDEBUG(2,PerlIO_printf(Perl_debug_log,"  symbolref = %x\n", RETVAL));
    	ST(0) = sv_newmortal() ;
    	if (err)
	    SaveError(aTHX_ "DynaLoader error [%d]!", err) ;
    	else
	    sv_setiv( ST(0), (IV)RETVAL);
    }

void
dl_undef_symbols()
    PPCODE:



# These functions should not need changing on any platform:

void
dl_install_xsub(perl_name, symref, filename="$Package")
    char *		perl_name
    void *		symref 
    const char *	filename
    CODE:
    DLDEBUG(2,PerlIO_printf(Perl_debug_log,"dl_install_xsub(name=%s, symref=%x)\n",
		perl_name, symref));
    ST(0) = sv_2mortal(newRV((SV*)newXS_flags(perl_name,
					      (void(*)(pTHX_ CV *))symref,
					      filename, NULL,
					      XS_DYNAMIC_FILENAME)));


char *
dl_error()
    CODE:
    dMY_CXT;
    RETVAL = dl_last_error ;
    OUTPUT:
    RETVAL

#if defined(USE_ITHREADS)

void
CLONE(...)
    CODE:
    MY_CXT_CLONE;

    /* MY_CXT_CLONE just does a memcpy on the whole structure, so to avoid
     * using Perl variables that belong to another thread, we create our 
     * own for this thread.
     */
    MY_CXT.x_dl_last_error = newSVpvn("", 0);

#endif

# end.
@


1.7
log
@merge in perl 5.12.2 plus local changes
@
text
@@


1.6
log
@Merge in perl 5.10.1
@
text
@@


1.5
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d129 1
a129 1
    char *		filename
d146 15
@


1.4
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d133 4
a136 1
    ST(0)=sv_2mortal(newRV((SV*)newXS(perl_name, (void(*)())symref, filename)));
@


1.3
log
@Resolve conflicts, remove old files, merge local changes
@
text
@@


1.2
log
@merge in perl 5.6.1 with our local changes
@
text
@d26 5
d32 1
d35 1
a35 3
typedef CFragConnectionID ConnectionID;

static ConnectionID **	connections;
d37 1
a37 1
static void terminate(void)
d39 3
a41 2
    int size = GetHandleSize((Handle) connections) / sizeof(ConnectionID);
    HLock((Handle) connections);
d43 3
a45 3
    	CloseConnection(*connections + --size);
    DisposeHandle((Handle) connections);
    connections = nil;
d78 4
a81 3
    	if (!connections) {
	    connections = (ConnectionID **)NewHandle(0);
	    atexit(terminate);
d83 1
a83 1
        PtrAndHand((Ptr) &connID, (Handle) connections, sizeof(ConnectionID));
d139 2
a140 1
    RETVAL = LastError ;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.6.1
@
text
@@


1.1.1.2
log
@stock perl 5.8.0 from CPAN
@
text
@a25 1
typedef CFragConnectionID ConnectionID;
d27 1
a27 3
typedef struct {
    ConnectionID **	x_connections;
} my_cxtx_t;		/* this *must* be named my_cxtx_t */
d29 1
a29 2
#define DL_CXT_EXTRA	/* ask for dl_cxtx to be defined in dlutils.c */
#include "dlutils.c"	/* SaveError() etc	*/
d31 1
a31 1
#define dl_connections	(dl_cxtx.x_connections)
d33 1
a33 1
static void terminate(pTHX_ void *ptr)
d35 2
a36 3
    dMY_CXT;
    int size = GetHandleSize((Handle) dl_connections) / sizeof(ConnectionID);
    HLock((Handle) dl_connections);
d38 3
a40 3
    	CloseConnection(*dl_connections + --size);
    DisposeHandle((Handle) dl_connections);
    dl_connections = nil;
d73 3
a75 4
	dMY_CXT;
    	if (!dl_connections) {
	    dl_connections = (ConnectionID **)NewHandle(0);
	    call_atexit(terminate, (void*)0);
d77 1
a77 1
        PtrAndHand((Ptr) &connID, (Handle) dl_connections, sizeof(ConnectionID));
d133 1
a133 2
    dMY_CXT;
    RETVAL = dl_last_error ;
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@a7 3
 * Revision 1.4  2003/12/03 03:02:28  millert
 * Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
 *
@


1.1.1.4
log
@perl 5.8.6 from CPAN
@
text
@d8 3
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d133 1
a133 4
    ST(0) = sv_2mortal(newRV((SV*)newXS_flags(perl_name,
					      (void(*)(pTHX_ CV *))symref,
					      filename, NULL,
					      XS_DYNAMIC_FILENAME)));
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d129 1
a129 1
    const char *	filename
a145 15

#if defined(USE_ITHREADS)

void
CLONE(...)
    CODE:
    MY_CXT_CLONE;

    /* MY_CXT_CLONE just does a memcpy on the whole structure, so to avoid
     * using Perl variables that belong to another thread, we create our 
     * own for this thread.
     */
    MY_CXT.x_dl_last_error = newSVpvn("", 0);

#endif
@


