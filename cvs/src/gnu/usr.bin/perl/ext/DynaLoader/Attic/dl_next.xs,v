head	1.11;
access;
symbols
	OPENBSD_6_0:1.10.0.10
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.11
date	2017.02.05.00.32.12;	author afresh1;	state dead;
branches;
next	1.10;
commitid	cxJ08BvJA9Pt2PTM;

1.10
date	2014.11.17.20.57.05;	author afresh1;	state Exp;
branches;
next	1.9;
commitid	QP75iYx42Uo7mMxO;

1.9
date	2014.03.24.15.05.27;	author afresh1;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.12.18.24.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.04;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.02;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.22;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.05.13;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.55.13;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.03;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.03;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.38.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.01;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.16;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.11.11;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.11
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/* dl_next.xs
 * 
 * Platform:	NeXT NS 3.2
 * Author:	Anno Siegel (siegel@@zrz.TU-Berlin.DE)
 * Based on:	dl_dlopen.xs by Paul Marquess
 * Created:	Aug 15th, 1994
 *
 */

/*
 *  And Gandalf said: 'Many folk like to know beforehand what is to
 *  be set on the table; but those who have laboured to prepare the
 *  feast like to keep their secret; for wonder makes the words of
 *  praise louder.'
 *
 *     [p.970 of _The Lord of the Rings_, VI/v: "The Steward and the King"]
 */

/* Porting notes:

dl_next.xs is itself a port from dl_dlopen.xs by Paul Marquess.  It
should not be used as a base for further ports though it may be used
as an example for how dl_dlopen.xs can be ported to other platforms.

The method used here is just to supply the sun style dlopen etc.
functions in terms of NeXTs rld_*.  The xs code proper is unchanged
from Paul's original.

The port could use some streamlining.  For one, error handling could
be simplified.

Anno Siegel

*/

#if NS_TARGET_MAJOR >= 4
#else
/* include these before perl headers */
#include <mach-o/rld.h>
#include <streams/streams.h>
#endif

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#define DL_LOADONCEONLY

typedef struct {
    AV *	x_resolve_using;
} my_cxtx_t;		/* this *must* be named my_cxtx_t */

#define DL_CXT_EXTRA	/* ask for dl_cxtx to be defined in dlutils.c */
#include "dlutils.c"	/* SaveError() etc	*/

#define dl_resolve_using	(dl_cxtx.x_resolve_using)

static char *dlerror()
{
    dTHX;
    dMY_CXT;
    return dl_last_error;
}

int dlclose(handle) /* stub only */
void *handle;
{
    return 0;
}

#if NS_TARGET_MAJOR >= 4
#import <mach-o/dyld.h>

enum dyldErrorSource
{
    OFImage,
};

static void TranslateError
    (const char *path, enum dyldErrorSource type, int number)
{
    dTHX;
    dMY_CXT;
    char *error;
    unsigned int index;
    static char *OFIErrorStrings[] =
    {
	"%s(%d): Object Image Load Failure\n",
	"%s(%d): Object Image Load Success\n",
	"%s(%d): Not a recognisable object file\n",
	"%s(%d): No valid architecture\n",
	"%s(%d): Object image has an invalid format\n",
	"%s(%d): Invalid access (permissions?)\n",
	"%s(%d): Unknown error code from NSCreateObjectFileImageFromFile\n",
    };
#define NUM_OFI_ERRORS (sizeof(OFIErrorStrings) / sizeof(OFIErrorStrings[0]))

    switch (type)
    {
    case OFImage:
	index = number;
	if (index > NUM_OFI_ERRORS - 1)
	    index = NUM_OFI_ERRORS - 1;
	error = Perl_form_nocontext(OFIErrorStrings[index], path, number);
	break;

    default:
	error = Perl_form_nocontext("%s(%d): Totally unknown error type %d\n",
		     path, number, type);
	break;
    }
    Safefree(dl_last_error);
    dl_last_error = savepv(error);
}

static char *dlopen(char *path, int mode /* mode is ignored */)
{
    int dyld_result;
    NSObjectFileImage ofile;
    NSModule handle = NULL;

    dyld_result = NSCreateObjectFileImageFromFile(path, &ofile);
    if (dyld_result != NSObjectFileImageSuccess)
	TranslateError(path, OFImage, dyld_result);
    else
    {
    	// NSLinkModule will cause the run to abort on any link error's
	// not very friendly but the error recovery functionality is limited.
	handle = NSLinkModule(ofile, path, TRUE);
    }
    
    return handle;
}

void *
dlsym(handle, symbol)
void *handle;
char *symbol;
{
    void *addr;

    if (NSIsSymbolNameDefined(symbol))
	addr = NSAddressOfSymbol(NSLookupAndBindSymbol(symbol));
    else
    	addr = NULL;

    return addr;
}

#else /* NS_TARGET_MAJOR <= 3 */

static NXStream *OpenError(void)
{
    return NXOpenMemory( (char *) 0, 0, NX_WRITEONLY);
}

static void TransferError(NXStream *s)
{
    char *buffer;
    int len, maxlen;
    dTHX;
    dMY_CXT;

    if ( dl_last_error ) {
        Safefree(dl_last_error);
    }
    NXGetMemoryBuffer(s, &buffer, &len, &maxlen);
    Newx(dl_last_error, len, char);
    strcpy(dl_last_error, buffer);
}

static void CloseError(NXStream *s)
{
    if ( s ) {
      NXCloseMemory( s, NX_FREEBUFFER);
    }
}

static char *dlopen(char *path, int mode /* mode is ignored */)
{
    int rld_success;
    NXStream *nxerr;
    I32 i, psize;
    char *result;
    char **p;
    STRLEN n_a;
    dTHX;
    dMY_CXT;
	
    /* Do not load what is already loaded into this process */
    if (hv_fetch(dl_loaded_files, path, strlen(path), 0))
	return path;

    nxerr = OpenError();
    psize = AvFILL(dl_resolve_using) + 3;
    p = (char **) safemalloc(psize * sizeof(char*));
    p[0] = path;
    for(i=1; i<psize-1; i++) {
	p[i] = SvPVx(*av_fetch(dl_resolve_using, i-1, TRUE), n_a);
    }
    p[psize-1] = 0;
    rld_success = rld_load(nxerr, (struct mach_header **)0, p,
			    (const char *) 0);
    safefree((char*) p);
    if (rld_success) {
	result = path;
	/* prevent multiple loads of same file into same process */
	hv_store(dl_loaded_files, path, strlen(path), &PL_sv_yes, 0);
    } else {
	TransferError(nxerr);
	result = (char*) 0;
    }
    CloseError(nxerr);
    return result;
}

void *
dlsym(handle, symbol)
void *handle;
char *symbol;
{
    NXStream	*nxerr = OpenError();
    unsigned long	symref = 0;

    if (!rld_lookup(nxerr, Perl_form_nocontext("_%s", symbol), &symref))
	TransferError(nxerr);
    CloseError(nxerr);
    return (void*) symref;
}

#endif /* NS_TARGET_MAJOR >= 4 */


/* ----- code from dl_dlopen.xs below here ----- */


static void
dl_private_init(pTHX)
{
    (void)dl_generic_private_init(aTHX);
    {
	dMY_CXT;
	dl_resolve_using = get_av("DynaLoader::dl_resolve_using", GV_ADDMULTI);
    }
}
 
MODULE = DynaLoader     PACKAGE = DynaLoader

BOOT:
    (void)dl_private_init(aTHX);



void
dl_load_file(filename, flags=0)
    char *	filename
    int		flags
    PREINIT:
    int mode = 1;
    void *retv;
    CODE:
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_load_file(%s,%x):\n", filename,flags));
    if (flags & 0x01)
	Perl_warn(aTHX_ "Can't make loaded symbols global on this platform while loading %s",filename);
    retv = dlopen(filename, mode) ;
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " libref=%x\n", retv));
    ST(0) = sv_newmortal() ;
    if (retv == NULL)
	SaveError(aTHX_ "%s",dlerror()) ;
    else
	sv_setiv( ST(0), PTR2IV(retv) );


void
dl_find_symbol(libhandle, symbolname)
    void *		libhandle
    char *		symbolname
    PREINIT:
    void *retv;
    CODE:
#if NS_TARGET_MAJOR >= 4
    symbolname = Perl_form_nocontext("_%s", symbolname);
#endif
    DLDEBUG(2, PerlIO_printf(Perl_debug_log,
			     "dl_find_symbol(handle=%lx, symbol=%s)\n",
			     (unsigned long) libhandle, symbolname));
    retv = dlsym(libhandle, symbolname);
    DLDEBUG(2, PerlIO_printf(Perl_debug_log,
			     "  symbolref = %lx\n", (unsigned long) retv));
    ST(0) = sv_newmortal() ;
    if (retv == NULL)
	SaveError(aTHX_ "%s",dlerror()) ;
    else
	sv_setiv( ST(0), PTR2IV(retv) );


void
dl_undef_symbols()
    CODE:



# These functions should not need changing on any platform:

void
dl_install_xsub(perl_name, symref, filename="$Package")
    char *	perl_name
    void *	symref 
    const char *	filename
    CODE:
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "dl_install_xsub(name=%s, symref=%x)\n",
	    perl_name, symref));
    ST(0) = sv_2mortal(newRV((SV*)newXS_flags(perl_name,
					      (void(*)(pTHX_ CV *))symref,
					      filename, NULL,
					      XS_DYNAMIC_FILENAME)));


char *
dl_error()
    CODE:
    dMY_CXT;
    RETVAL = dl_last_error ;
    OUTPUT:
    RETVAL

#if defined(USE_ITHREADS)

void
CLONE(...)
    CODE:
    MY_CXT_CLONE;

    PERL_UNUSED_VAR(items);

    /* MY_CXT_CLONE just does a memcpy on the whole structure, so to avoid
     * using Perl variables that belong to another thread, we create our 
     * own for this thread.
     */
    MY_CXT.x_dl_last_error = newSVpvn("", 0);
    dl_resolve_using = get_av("DynaLoader::dl_resolve_using", GV_ADDMULTI);

#endif

# end.
@


1.10
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@@


1.9
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d334 2
@


1.8
log
@Merge in perl 5.10.1
@
text
@d254 1
a254 1
void *
d260 1
d265 2
a266 2
    RETVAL = dlopen(filename, mode) ;
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " libref=%x\n", RETVAL));
d268 1
a268 1
    if (RETVAL == NULL)
d271 1
a271 1
	sv_setiv( ST(0), PTR2IV(RETVAL) );
d274 1
a274 1
void *
d278 2
d287 1
a287 1
    RETVAL = dlsym(libhandle, symbolname);
d289 1
a289 1
			     "  symbolref = %lx\n", (unsigned long) RETVAL));
d291 1
a291 1
    if (RETVAL == NULL)
d294 1
a294 1
	sv_setiv( ST(0), PTR2IV(RETVAL) );
d299 1
a299 1
    PPCODE:
@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d11 7
a17 5
    And Gandalf said: 'Many folk like to know beforehand what is to
    be set on the table; but those who have laboured to prepare the
    feast like to keep their secret; for wonder makes the words of
    praise louder.'
*/
d306 1
a306 1
    char *	filename
d323 16
@


1.6
log
@merge in perl 5.8.8
@
text
@d308 4
a311 3
    ST(0) = sv_2mortal(newRV((SV*)newXS(perl_name,
					(void(*)(pTHX_ CV *))symref,
					filename)));
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d166 1
a166 1
    New(1097, dl_last_error, len, char);
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d47 5
d54 1
a54 3

static char * dl_last_error = (char *) 0;
static AV *dl_resolve_using = Nullav;
d58 2
d81 1
d88 1
a88 1
	"%s(%d): Not an recognisable object file\n",
d159 2
d185 2
d239 4
a242 1
    dl_resolve_using = get_av("DynaLoader::dl_resolve_using", GV_ADDMULTI);
d316 2
a317 1
    RETVAL = LastError ;
@


1.3
log
@perl5.005_03 (stock)
@
text
@d75 1
d96 1
a96 1
	error = form(OFIErrorStrings[index], path, number);
d100 1
a100 1
	error = form("%s(%d): Totally unknown error type %d\n",
d213 1
a213 1
    if (!rld_lookup(nxerr, form("_%s", symbol), &symref))
d226 1
a226 1
dl_private_init()
d228 2
a229 2
    (void)dl_generic_private_init();
    dl_resolve_using = perl_get_av("DynaLoader::dl_resolve_using", 0x4);
d235 1
a235 1
    (void)dl_private_init();
d246 1
a246 1
    DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_load_file(%s,%x):\n", filename,flags));
d248 1
a248 1
	warn("Can't make loaded symbols global on this platform while loading %s",filename);
d250 1
a250 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), " libref=%x\n", RETVAL));
d253 1
a253 1
	SaveError("%s",dlerror()) ;
d255 1
a255 1
	sv_setiv( ST(0), (IV)RETVAL);
d264 1
a264 1
    symbolname = form("_%s", symbolname);
d266 1
a266 1
    DLDEBUG(2, PerlIO_printf(PerlIO_stderr(),
d270 1
a270 1
    DLDEBUG(2, PerlIO_printf(PerlIO_stderr(),
d274 1
a274 1
	SaveError("%s",dlerror()) ;
d276 1
a276 1
	sv_setiv( ST(0), (IV)RETVAL);
d293 1
a293 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "dl_install_xsub(name=%s, symref=%x)\n",
d295 3
a297 1
    ST(0)=sv_2mortal(newRV((SV*)newXS(perl_name, (void(*)())symref, filename)));
@


1.2
log
@perl 5.004_04
@
text
@d103 1
a103 1
    safefree(dl_last_error);
d154 1
a154 1
        safefree(dl_last_error);
d157 1
a157 1
    dl_last_error = safemalloc(len);
d175 1
d186 1
a186 1
	p[i] = SvPVx(*av_fetch(dl_resolve_using, i-1, TRUE), na);
d195 1
a195 1
	hv_store(dl_loaded_files, path, strlen(path), &sv_yes, 0);
@


1.1
log
@Initial revision
@
text
@d34 2
d39 1
d53 91
a143 2
NXStream *
OpenError()
d148 1
a148 3
void
TransferError( s)
NXStream *s;
d161 1
a161 3
void
CloseError( s)
NXStream *s;
d168 1
a168 9
char *dlerror()
{
    return dl_last_error;
}

char *
dlopen(path, mode)
char * path;
int mode; /* mode is ignored */
a202 7
int
dlclose(handle) /* stub only */
void *handle;
{
    return 0;
}

a208 1
    char	symbuf[1024];
d211 1
a211 2
    sprintf(symbuf, "_%s", symbol);
    if (!rld_lookup(nxerr, symbuf, &symref)) {
a212 1
    }
d217 2
d238 1
a238 1
dl_load_file(filename)
d240 3
d244 3
a246 2
    int mode = 1;
    DLDEBUG(1,fprintf(stderr,"dl_load_file(%s):\n", filename));
d248 1
a248 1
    DLDEBUG(2,fprintf(stderr," libref=%x\n", RETVAL));
d261 6
a266 2
    DLDEBUG(2,fprintf(stderr,"dl_find_symbol(handle=%x, symbol=%s)\n",
	    libhandle, symbolname));
d268 2
a269 1
    DLDEBUG(2,fprintf(stderr,"  symbolref = %x\n", RETVAL));
d291 1
a291 1
    DLDEBUG(2,fprintf(stderr,"dl_install_xsub(name=%s, symref=%x)\n",
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a33 2
#if NS_TARGET_MAJOR >= 4
#else
a36 1
#endif
d50 2
a51 91
static char *dlerror()
{
    return dl_last_error;
}

int dlclose(handle) /* stub only */
void *handle;
{
    return 0;
}

#if NS_TARGET_MAJOR >= 4
#import <mach-o/dyld.h>

enum dyldErrorSource
{
    OFImage,
};

static void TranslateError
    (const char *path, enum dyldErrorSource type, int number)
{
    char *error;
    unsigned int index;
    static char *OFIErrorStrings[] =
    {
	"%s(%d): Object Image Load Failure\n",
	"%s(%d): Object Image Load Success\n",
	"%s(%d): Not an recognisable object file\n",
	"%s(%d): No valid architecture\n",
	"%s(%d): Object image has an invalid format\n",
	"%s(%d): Invalid access (permissions?)\n",
	"%s(%d): Unknown error code from NSCreateObjectFileImageFromFile\n",
    };
#define NUM_OFI_ERRORS (sizeof(OFIErrorStrings) / sizeof(OFIErrorStrings[0]))

    switch (type)
    {
    case OFImage:
	index = number;
	if (index > NUM_OFI_ERRORS - 1)
	    index = NUM_OFI_ERRORS - 1;
	error = form(OFIErrorStrings[index], path, number);
	break;

    default:
	error = form("%s(%d): Totally unknown error type %d\n",
		     path, number, type);
	break;
    }
    Safefree(dl_last_error);
    dl_last_error = savepv(error);
}

static char *dlopen(char *path, int mode /* mode is ignored */)
{
    int dyld_result;
    NSObjectFileImage ofile;
    NSModule handle = NULL;

    dyld_result = NSCreateObjectFileImageFromFile(path, &ofile);
    if (dyld_result != NSObjectFileImageSuccess)
	TranslateError(path, OFImage, dyld_result);
    else
    {
    	// NSLinkModule will cause the run to abort on any link error's
	// not very friendly but the error recovery functionality is limited.
	handle = NSLinkModule(ofile, path, TRUE);
    }
    
    return handle;
}

void *
dlsym(handle, symbol)
void *handle;
char *symbol;
{
    void *addr;

    if (NSIsSymbolNameDefined(symbol))
	addr = NSAddressOfSymbol(NSLookupAndBindSymbol(symbol));
    else
    	addr = NULL;

    return addr;
}

#else /* NS_TARGET_MAJOR <= 3 */

static NXStream *OpenError(void)
d56 3
a58 1
static void TransferError(NXStream *s)
d64 1
a64 1
        Safefree(dl_last_error);
d67 1
a67 1
    New(1097, dl_last_error, len, char);
d71 3
a73 1
static void CloseError(NXStream *s)
d80 9
a88 1
static char *dlopen(char *path, int mode /* mode is ignored */)
a94 1
    STRLEN n_a;
d105 1
a105 1
	p[i] = SvPVx(*av_fetch(dl_resolve_using, i-1, TRUE), n_a);
d114 1
a114 1
	hv_store(dl_loaded_files, path, strlen(path), &PL_sv_yes, 0);
d123 7
d136 1
d139 2
a140 1
    if (!rld_lookup(nxerr, form("_%s", symbol), &symref))
d142 1
a146 2
#endif /* NS_TARGET_MAJOR >= 4 */

d166 1
a166 1
dl_load_file(filename, flags=0)
d168 1
a168 2
    int		flags
    PREINIT:
d170 1
a170 4
    CODE:
    DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_load_file(%s,%x):\n", filename,flags));
    if (flags & 0x01)
	warn("Can't make loaded symbols global on this platform while loading %s",filename);
d172 1
a172 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), " libref=%x\n", RETVAL));
d185 2
a186 6
#if NS_TARGET_MAJOR >= 4
    symbolname = form("_%s", symbolname);
#endif
    DLDEBUG(2, PerlIO_printf(PerlIO_stderr(),
			     "dl_find_symbol(handle=%lx, symbol=%s)\n",
			     (unsigned long) libhandle, symbolname));
d188 1
a188 2
    DLDEBUG(2, PerlIO_printf(PerlIO_stderr(),
			     "  symbolref = %lx\n", (unsigned long) RETVAL));
d210 1
a210 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "dl_install_xsub(name=%s, symref=%x)\n",
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a74 1
    dTHX;
d95 1
a95 1
	error = Perl_form_nocontext(OFIErrorStrings[index], path, number);
d99 1
a99 1
	error = Perl_form_nocontext("%s(%d): Totally unknown error type %d\n",
d212 1
a212 1
    if (!rld_lookup(nxerr, Perl_form_nocontext("_%s", symbol), &symref))
d225 1
a225 1
dl_private_init(pTHX)
d227 2
a228 2
    (void)dl_generic_private_init(aTHX);
    dl_resolve_using = get_av("DynaLoader::dl_resolve_using", GV_ADDMULTI);
d234 1
a234 1
    (void)dl_private_init(aTHX);
d245 1
a245 1
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_load_file(%s,%x):\n", filename,flags));
d247 1
a247 1
	Perl_warn(aTHX_ "Can't make loaded symbols global on this platform while loading %s",filename);
d249 1
a249 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " libref=%x\n", RETVAL));
d252 1
a252 1
	SaveError(aTHX_ "%s",dlerror()) ;
d254 1
a254 1
	sv_setiv( ST(0), PTR2IV(RETVAL) );
d263 1
a263 1
    symbolname = Perl_form_nocontext("_%s", symbolname);
d265 1
a265 1
    DLDEBUG(2, PerlIO_printf(Perl_debug_log,
d269 1
a269 1
    DLDEBUG(2, PerlIO_printf(Perl_debug_log,
d273 1
a273 1
	SaveError(aTHX_ "%s",dlerror()) ;
d275 1
a275 1
	sv_setiv( ST(0), PTR2IV(RETVAL) );
d292 1
a292 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "dl_install_xsub(name=%s, symref=%x)\n",
d294 1
a294 3
    ST(0) = sv_2mortal(newRV((SV*)newXS(perl_name,
					(void(*)(pTHX_ CV *))symref,
					filename)));
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d47 1
a47 3
typedef struct {
    AV *	x_resolve_using;
} my_cxtx_t;		/* this *must* be named my_cxtx_t */
a48 2
#define DL_CXT_EXTRA	/* ask for dl_cxtx to be defined in dlutils.c */
#include "dlutils.c"	/* SaveError() etc	*/
d50 2
a51 1
#define dl_resolve_using	(dl_cxtx.x_resolve_using)
a54 2
    dTHX;
    dMY_CXT;
a75 1
    dMY_CXT;
d82 1
a82 1
	"%s(%d): Not a recognisable object file\n",
a152 2
    dTHX;
    dMY_CXT;
a176 2
    dTHX;
    dMY_CXT;
d229 1
a229 4
    {
	dMY_CXT;
	dl_resolve_using = get_av("DynaLoader::dl_resolve_using", GV_ADDMULTI);
    }
d303 1
a303 2
    dMY_CXT;
    RETVAL = dl_last_error ;
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d166 1
a166 1
    Newx(dl_last_error, len, char);
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d308 3
a310 4
    ST(0) = sv_2mortal(newRV((SV*)newXS_flags(perl_name,
					      (void(*)(pTHX_ CV *))symref,
					      filename, NULL,
					      XS_DYNAMIC_FILENAME)));
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d11 5
a15 7
 *  And Gandalf said: 'Many folk like to know beforehand what is to
 *  be set on the table; but those who have laboured to prepare the
 *  feast like to keep their secret; for wonder makes the words of
 *  praise louder.'
 *
 *     [p.970 of _The Lord of the Rings_, VI/v: "The Steward and the King"]
 */
d304 1
a304 1
    const char *	filename
a320 16

#if defined(USE_ITHREADS)

void
CLONE(...)
    CODE:
    MY_CXT_CLONE;

    /* MY_CXT_CLONE just does a memcpy on the whole structure, so to avoid
     * using Perl variables that belong to another thread, we create our 
     * own for this thread.
     */
    MY_CXT.x_dl_last_error = newSVpvn("", 0);
    dl_resolve_using = get_av("DynaLoader::dl_resolve_using", GV_ADDMULTI);

#endif
@


1.1.1.8
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d254 1
a254 1
void
a259 1
    void *retv;
d264 2
a265 2
    retv = dlopen(filename, mode) ;
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " libref=%x\n", retv));
d267 1
a267 1
    if (retv == NULL)
d270 1
a270 1
	sv_setiv( ST(0), PTR2IV(retv) );
d273 1
a273 1
void
a276 2
    PREINIT:
    void *retv;
d284 1
a284 1
    retv = dlsym(libhandle, symbolname);
d286 1
a286 1
			     "  symbolref = %lx\n", (unsigned long) retv));
d288 1
a288 1
    if (retv == NULL)
d291 1
a291 1
	sv_setiv( ST(0), PTR2IV(retv) );
d296 1
a296 1
    CODE:
@


1.1.1.9
log
@Import perl-5.20.1
@
text
@a333 2
    PERL_UNUSED_VAR(items);

@


