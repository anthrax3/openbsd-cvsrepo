head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.2
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.8
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.11.0.8
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.7.0.14
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.12
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.10
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.7.0.8
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.6.0.6
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.16
date	2017.02.05.00.32.12;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	cxJ08BvJA9Pt2PTM;

1.15
date	2015.04.25.19.26.22;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	3qGYFVvfrExB70FB;

1.14
date	2015.04.25.19.14.45;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	XRK22kO4se3v2i2I;

1.13
date	2014.11.26.18.17.16;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	u0GJXFdc8UQ0R6Te;

1.12
date	2014.11.17.20.57.05;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	QP75iYx42Uo7mMxO;

1.11
date	2013.03.25.20.40.54;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.27;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.04;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.02;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.27.22.25.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.24.18.35.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.06.17.05.12;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.04.29.22.51.27;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.11.30.07.55.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.02.17.09.23.58;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.03;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.03;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.38.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.09;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.47;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.48.01;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.16;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.11.11;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.08.44;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.16
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/* dl_dlopen.xs
 * 
 * Platform:	SunOS/Solaris, possibly others which use dlopen.
 * Author:	Paul Marquess (Paul.Marquess@@btinternet.com)
 * Created:	10th July 1994
 *
 * Modified:
 * 15th July 1994     - Added code to explicitly save any error messages.
 * 3rd August 1994    - Upgraded to v3 spec.
 * 9th August 1994    - Changed to use IV
 * 10th August 1994   - Tim Bunce: Added RTLD_LAZY, switchable debugging,
 *                      basic FreeBSD support, removed ClearError
 * 29th February 2000 - Alan Burlison: Added functionality to close dlopen'd
 *                      files when the interpreter exits
 * 2015-03-12         - rurban: Added optional 3rd dl_find_symbol argument
 *
 */

/* Porting notes:


   Definition of Sunos dynamic Linking functions
   =============================================
   In order to make this implementation easier to understand here is a
   quick definition of the SunOS Dynamic Linking functions which are
   used here.

   dlopen
   ------
     void *
     dlopen(path, mode)
     char * path; 
     int    mode;

     This function takes the name of a dynamic object file and returns
     a descriptor which can be used by dlsym later. It returns NULL on
     error.

     The mode parameter must be set to 1 for Solaris 1 and to
     RTLD_LAZY (==2) on Solaris 2.


   dlclose
   -------
     int
     dlclose(handle)
     void * handle;

     This function takes the handle returned by a previous invocation of
     dlopen and closes the associated dynamic object file.  It returns zero
     on success, and non-zero on failure.


   dlsym
   ------
     void *
     dlsym(handle, symbol)
     void * handle; 
     char * symbol;

     Takes the handle returned from dlopen and the name of a symbol to
     get the address of. If the symbol was found a pointer is
     returned.  It returns NULL on error. If DL_PREPEND_UNDERSCORE is
     defined an underscore will be added to the start of symbol. This
     is required on some platforms (freebsd).

   dlerror
   ------
     char * dlerror()

     Returns a null-terminated string which describes the last error
     that occurred with either dlopen or dlsym. After each call to
     dlerror the error message will be reset to a null pointer. The
     SaveError function is used to save the error as soon as it happens.


   Return Types
   ============
   In this implementation the two functions, dl_load_file &
   dl_find_symbol, return void *. This is because the underlying SunOS
   dynamic linker calls also return void *.  This is not necessarily
   the case for all architectures. For example, some implementation
   will want to return a char * for dl_load_file.

   If void * is not appropriate for your architecture, you will have to
   change the void * to whatever you require. If you are not certain of
   how Perl handles C data types, I suggest you start by consulting	
   Dean Roerich's Perl 5 API document. Also, have a look in the typemap 
   file (in the ext directory) for a fairly comprehensive list of types 
   that are already supported. If you are completely stuck, I suggest you
   post a message to perl5-porters, comp.lang.perl.misc or if you are really 
   desperate to me.

   Remember when you are making any changes that the return value from 
   dl_load_file is used as a parameter in the dl_find_symbol 
   function. Also the return value from find_symbol is used as a parameter 
   to install_xsub.


   Dealing with Error Messages
   ============================
   In order to make the handling of dynamic linking errors as generic as
   possible you should store any error messages associated with your
   implementation with the StoreError function.

   In the case of SunOS the function dlerror returns the error message 
   associated with the last dynamic link error. As the SunOS dynamic 
   linker functions dlopen & dlsym both return NULL on error every call 
   to a SunOS dynamic link routine is coded like this

	RETVAL = dlopen(filename, 1) ;
	if (RETVAL == NULL)
	    SaveError("%s",dlerror()) ;

   Note that SaveError() takes a printf format string. Use a "%s" as
   the first parameter if the error may contain any % characters.

*/

#define PERL_NO_GET_CONTEXT
#define PERL_EXT

#include "EXTERN.h"
#define PERL_IN_DL_DLOPEN_XS
#include "perl.h"
#include "XSUB.h"

#ifdef I_DLFCN
#include <dlfcn.h>	/* the dynamic linker include file for Sunos/Solaris */
#else
#include <nlist.h>
#include <link.h>
#endif

#ifndef RTLD_LAZY
# define RTLD_LAZY 1	/* Solaris 1 */
#endif

#ifndef HAS_DLERROR
# ifdef __NetBSD__
#  define dlerror() strerror(errno)
# else
#  define dlerror() "Unknown error - dlerror() not implemented"
# endif
#endif


#include "dlutils.c"	/* SaveError() etc	*/


static void
dl_private_init(pTHX)
{
    (void)dl_generic_private_init(aTHX);
}

MODULE = DynaLoader	PACKAGE = DynaLoader

BOOT:
    (void)dl_private_init(aTHX);


void
dl_load_file(filename, flags=0)
    char *	filename
    int		flags
  PREINIT:
    int mode = RTLD_LAZY;
    void *handle;
  CODE:
{
#if defined(DLOPEN_WONT_DO_RELATIVE_PATHS)
    char pathbuf[PATH_MAX + 2];
    if (*filename != '/' && strchr(filename, '/')) {
        const size_t filename_len = strlen(filename);
        if (getcwd(pathbuf, PATH_MAX - filename_len)) {
            const size_t path_len = strlen(pathbuf);
            pathbuf[path_len] = '/';
            filename = (char *) memcpy(pathbuf + path_len + 1, filename, filename_len + 1);
	}
    }
#endif
#ifdef RTLD_NOW
    {
	dMY_CXT;
	if (dl_nonlazy)
	    mode = RTLD_NOW;
    }
#endif
    if (flags & 0x01)
#ifdef RTLD_GLOBAL
	mode |= RTLD_GLOBAL;
#else
	Perl_warn(aTHX_ "Can't make loaded symbols global on this platform while loading %s",filename);
#endif
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_load_file(%s,%x):\n", filename,flags));
    handle = dlopen(filename, mode) ;
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " libref=%lx\n", (unsigned long) handle));
    ST(0) = sv_newmortal() ;
    if (handle == NULL)
	SaveError(aTHX_ "%s",dlerror()) ;
    else
	sv_setiv( ST(0), PTR2IV(handle));
}


int
dl_unload_file(libref)
    void *	libref
  CODE:
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_unload_file(%lx):\n", PTR2ul(libref)));
    RETVAL = (dlclose(libref) == 0 ? 1 : 0);
    if (!RETVAL)
        SaveError(aTHX_ "%s", dlerror()) ;
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " retval = %d\n", RETVAL));
  OUTPUT:
    RETVAL


void
dl_find_symbol(libhandle, symbolname, ign_err=0)
    void *	libhandle
    char *	symbolname
    int	        ign_err
    PREINIT:
    void *sym;
    CODE:
#ifdef DLSYM_NEEDS_UNDERSCORE
    symbolname = Perl_form_nocontext("_%s", symbolname);
#endif
    DLDEBUG(2, PerlIO_printf(Perl_debug_log,
			     "dl_find_symbol(handle=%lx, symbol=%s)\n",
			     (unsigned long) libhandle, symbolname));
    sym = dlsym(libhandle, symbolname);
    DLDEBUG(2, PerlIO_printf(Perl_debug_log,
			     "  symbolref = %lx\n", (unsigned long) sym));
    ST(0) = sv_newmortal();
    if (sym == NULL) {
        if (!ign_err)
	    SaveError(aTHX_ "%s", dlerror());
    } else
	sv_setiv( ST(0), PTR2IV(sym));


void
dl_undef_symbols()
    CODE:



# These functions should not need changing on any platform:

void
dl_install_xsub(perl_name, symref, filename="$Package")
    char *		perl_name
    void *		symref 
    const char *	filename
    CODE:
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "dl_install_xsub(name=%s, symref=%"UVxf")\n",
		perl_name, PTR2UV(symref)));
    ST(0) = sv_2mortal(newRV((SV*)newXS_flags(perl_name,
					      DPTR2FPTR(XSUBADDR_t, symref),
					      filename, NULL,
					      XS_DYNAMIC_FILENAME)));


SV *
dl_error()
    CODE:
    dMY_CXT;
    RETVAL = newSVsv(MY_CXT.x_dl_last_error);
    OUTPUT:
    RETVAL

#if defined(USE_ITHREADS)

void
CLONE(...)
    CODE:
    MY_CXT_CLONE;

    PERL_UNUSED_VAR(items);

    /* MY_CXT_CLONE just does a memcpy on the whole structure, so to avoid
     * using Perl variables that belong to another thread, we create our 
     * own for this thread.
     */
    MY_CXT.x_dl_last_error = newSVpvs("");

#endif

# end.
@


1.15
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@d15 1
d121 1
d124 1
d175 5
a179 4
	if (getcwd(pathbuf, PATH_MAX - strlen(filename))) {
	    my_strlcat(pathbuf, "/", sizeof(pathbuf));
	    my_strlcat(pathbuf, filename, sizeof(pathbuf));
	    filename = pathbuf;
d221 1
a221 1
dl_find_symbol(libhandle, symbolname)
d224 1
d237 5
a241 4
    ST(0) = sv_newmortal() ;
    if (sym == NULL)
	SaveError(aTHX_ "%s",dlerror()) ;
    else
d267 1
a267 1
char *
d271 1
a271 1
    RETVAL = dl_last_error ;
d288 1
a288 1
    MY_CXT.x_dl_last_error = newSVpvn("", 0);
@


1.14
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d173 2
a174 2
	    strcat(pathbuf, "/");
	    strcat(pathbuf, filename);
@


1.13
log
@Use perl's my_strlcat in DynaLoader

OK millert@@
@
text
@d173 2
a174 2
	    my_strlcat(pathbuf, "/", sizeof(pathbuf));
	    my_strlcat(pathbuf, filename, sizeof(pathbuf));
@


1.12
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d173 2
a174 2
	    strcat(pathbuf, "/");
	    strcat(pathbuf, filename);
@


1.11
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d276 2
@


1.10
log
@Merge in perl 5.10.1
@
text
@d13 1
a13 1
 * 29th Feburary 2000 - Alan Burlison: Added functionality to close dlopen'd
d118 2
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d249 1
a249 1
    char *		filename
d266 15
@


1.8
log
@merge in perl 5.8.8
@
text
@d253 4
a256 3
    ST(0) = sv_2mortal(newRV((SV*)newXS(perl_name,
					DPTR2FPTR(XSUBADDR_t, symref),
					filename)));
@


1.7
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d251 2
a252 2
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "dl_install_xsub(name=%s, symref=%lx)\n",
		perl_name, (unsigned long) symref));
d254 1
a254 1
					(void(*)(pTHX_ CV *))symref,
@


1.6
log
@merge in perl 5.6.1 with our local changes
@
text
@d158 1
a158 1
void *
d164 1
d178 5
a182 2
    if (dl_nonlazy)
	mode = RTLD_NOW;
d191 2
a192 2
    RETVAL = dlopen(filename, mode) ;
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " libref=%lx\n", (unsigned long) RETVAL));
d194 1
a194 1
    if (RETVAL == NULL)
d197 1
a197 1
	sv_setiv( ST(0), PTR2IV(RETVAL));
d214 1
a214 1
void *
d218 2
d227 1
a227 1
    RETVAL = dlsym(libhandle, symbolname);
d229 1
a229 1
			     "  symbolref = %lx\n", (unsigned long) RETVAL));
d231 1
a231 1
    if (RETVAL == NULL)
d234 1
a234 1
	sv_setiv( ST(0), PTR2IV(RETVAL));
d239 1
a239 1
    PPCODE:
d261 2
a262 1
    RETVAL = LastError ;
@


1.5
log
@perl-5.6.0 + local changes
@
text
@d115 1
a115 1
   the first parameter if the error may contain and % characters.
d201 1
a201 1
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_unload_file(%lx):\n", libref));
@


1.4
log
@perl5.005_03 (stock)
@
text
@d4 1
a4 1
 * Author:	Paul Marquess (pmarquess@@bfsec.bt.co.uk)
d8 7
a14 5
 * 15th July 1994   - Added code to explicitly save any error messages.
 * 3rd August 1994  - Upgraded to v3 spec.
 * 9th August 1994  - Changed to use IV
 * 10th August 1994 - Tim Bunce: Added RTLD_LAZY, switchable debugging,
 *                    basic FreeBSD support, removed ClearError
d42 11
d73 1
a73 1
     SaveError function is used to save the error as soo as it happens.
d147 1
a147 1
dl_private_init()
d149 1
a149 1
    (void)dl_generic_private_init();
d155 1
a155 1
    (void)dl_private_init();
d162 1
a162 1
    PREINIT:
d164 12
a175 1
    CODE:
d184 1
a184 1
	warn("Can't make loaded symbols global on this platform while loading %s",filename);
d186 1
a186 1
    DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_load_file(%s,%x):\n", filename,flags));
d188 1
a188 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), " libref=%lx\n", (unsigned long) RETVAL));
d191 1
a191 1
	SaveError("%s",dlerror()) ;
d193 15
a207 1
	sv_setiv( ST(0), (IV)RETVAL);
d216 1
a216 1
    symbolname = form("_%s", symbolname);
d218 1
a218 1
    DLDEBUG(2, PerlIO_printf(PerlIO_stderr(),
d222 1
a222 1
    DLDEBUG(2, PerlIO_printf(PerlIO_stderr(),
d226 1
a226 1
	SaveError("%s",dlerror()) ;
d228 1
a228 1
	sv_setiv( ST(0), (IV)RETVAL);
d245 1
a245 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "dl_install_xsub(name=%s, symref=%lx)\n",
d247 3
a249 1
    ST(0)=sv_2mortal(newRV((SV*)newXS(perl_name, (void(*)_((CV *)))symref, filename)));
@


1.3
log
@perl 5.004_04
@
text
@d209 1
a209 1
    ST(0)=sv_2mortal(newRV((SV*)newXS(perl_name, (void(*)())symref, filename)));
@


1.2
log
@__NetBSD__ is going away from our gcc specs
@
text
@d122 1
a122 1
# if defined(__NetBSD__) || defined(__OpenBSD__)
d146 5
a150 2
dl_load_file(filename)
    char *		filename
a151 1
    int mode = RTLD_LAZY;
d156 7
a162 1
    DLDEBUG(1,fprintf(stderr,"dl_load_file(%s):\n", filename));
d164 1
a164 1
    DLDEBUG(2,fprintf(stderr," libref=%x\n", RETVAL));
d178 1
a178 2
    char symbolname_buf[1024];
    symbolname = dl_add_underscore(symbolname, symbolname_buf);
d180 3
a182 2
    DLDEBUG(2,fprintf(stderr,"dl_find_symbol(handle=%x, symbol=%s)\n",
	libhandle, symbolname));
d184 2
a185 1
    DLDEBUG(2,fprintf(stderr,"  symbolref = %x\n", RETVAL));
d207 2
a208 2
    DLDEBUG(2,fprintf(stderr,"dl_install_xsub(name=%s, symref=%x)\n",
		perl_name, symref));
@


1.1
log
@Initial revision
@
text
@d122 1
a122 1
# ifdef __NetBSD__
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d146 3
a148 4
dl_load_file(filename, flags=0)
    char *	filename
    int		flags
    PREINIT:
a149 1
    CODE:
d154 1
a154 7
    if (flags & 0x01)
#ifdef RTLD_GLOBAL
	mode |= RTLD_GLOBAL;
#else
	warn("Can't make loaded symbols global on this platform while loading %s",filename);
#endif
    DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_load_file(%s,%x):\n", filename,flags));
d156 1
a156 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), " libref=%lx\n", (unsigned long) RETVAL));
d170 2
a171 1
    symbolname = form("_%s", symbolname);
d173 2
a174 3
    DLDEBUG(2, PerlIO_printf(PerlIO_stderr(),
			     "dl_find_symbol(handle=%lx, symbol=%s)\n",
			     (unsigned long) libhandle, symbolname));
d176 1
a176 2
    DLDEBUG(2, PerlIO_printf(PerlIO_stderr(),
			     "  symbolref = %lx\n", (unsigned long) RETVAL));
d198 3
a200 3
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "dl_install_xsub(name=%s, symref=%lx)\n",
		perl_name, (unsigned long) symref));
    ST(0)=sv_2mortal(newRV((SV*)newXS(perl_name, (void(*)_((CV *)))symref, filename)));
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d4 1
a4 1
 * Author:	Paul Marquess (Paul.Marquess@@btinternet.com)
d8 5
a12 7
 * 15th July 1994     - Added code to explicitly save any error messages.
 * 3rd August 1994    - Upgraded to v3 spec.
 * 9th August 1994    - Changed to use IV
 * 10th August 1994   - Tim Bunce: Added RTLD_LAZY, switchable debugging,
 *                      basic FreeBSD support, removed ClearError
 * 29th Feburary 2000 - Alan Burlison: Added functionality to close dlopen'd
 *                      files when the interpreter exits
a39 11
   dlclose
   -------
     int
     dlclose(handle)
     void * handle;

     This function takes the handle returned by a previous invocation of
     dlopen and closes the associated dynamic object file.  It returns zero
     on success, and non-zero on failure.


d60 1
a60 1
     SaveError function is used to save the error as soon as it happens.
d134 1
a134 1
dl_private_init(pTHX)
d136 1
a136 1
    (void)dl_generic_private_init(aTHX);
d142 1
a142 1
    (void)dl_private_init(aTHX);
d149 1
a149 1
  PREINIT:
d151 1
a151 12
  CODE:
{
#if defined(DLOPEN_WONT_DO_RELATIVE_PATHS)
    char pathbuf[PATH_MAX + 2];
    if (*filename != '/' && strchr(filename, '/')) {
	if (getcwd(pathbuf, PATH_MAX - strlen(filename))) {
	    strcat(pathbuf, "/");
	    strcat(pathbuf, filename);
	    filename = pathbuf;
	}
    }
#endif
d160 1
a160 1
	Perl_warn(aTHX_ "Can't make loaded symbols global on this platform while loading %s",filename);
d162 1
a162 1
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_load_file(%s,%x):\n", filename,flags));
d164 1
a164 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " libref=%lx\n", (unsigned long) RETVAL));
d167 1
a167 1
	SaveError(aTHX_ "%s",dlerror()) ;
d169 1
a169 15
	sv_setiv( ST(0), PTR2IV(RETVAL));
}


int
dl_unload_file(libref)
    void *	libref
  CODE:
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_unload_file(%lx):\n", libref));
    RETVAL = (dlclose(libref) == 0 ? 1 : 0);
    if (!RETVAL)
        SaveError(aTHX_ "%s", dlerror()) ;
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " retval = %d\n", RETVAL));
  OUTPUT:
    RETVAL
d178 1
a178 1
    symbolname = Perl_form_nocontext("_%s", symbolname);
d180 1
a180 1
    DLDEBUG(2, PerlIO_printf(Perl_debug_log,
d184 1
a184 1
    DLDEBUG(2, PerlIO_printf(Perl_debug_log,
d188 1
a188 1
	SaveError(aTHX_ "%s",dlerror()) ;
d190 1
a190 1
	sv_setiv( ST(0), PTR2IV(RETVAL));
d207 1
a207 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "dl_install_xsub(name=%s, symref=%lx)\n",
d209 1
a209 3
    ST(0) = sv_2mortal(newRV((SV*)newXS(perl_name,
					(void(*)(pTHX_ CV *))symref,
					filename)));
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d115 1
a115 1
   the first parameter if the error may contain any % characters.
d201 1
a201 1
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_unload_file(%lx):\n", PTR2ul(libref)));
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d158 1
a158 1
void
a163 1
    void *handle;
d177 2
a178 5
    {
	dMY_CXT;
	if (dl_nonlazy)
	    mode = RTLD_NOW;
    }
d187 2
a188 2
    handle = dlopen(filename, mode) ;
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " libref=%lx\n", (unsigned long) handle));
d190 1
a190 1
    if (handle == NULL)
d193 1
a193 1
	sv_setiv( ST(0), PTR2IV(handle));
d210 1
a210 1
void
a213 2
    PREINIT:
    void *sym;
d221 1
a221 1
    sym = dlsym(libhandle, symbolname);
d223 1
a223 1
			     "  symbolref = %lx\n", (unsigned long) sym));
d225 1
a225 1
    if (sym == NULL)
d228 1
a228 1
	sv_setiv( ST(0), PTR2IV(sym));
d233 1
a233 1
    CODE:
d255 1
a255 2
    dMY_CXT;
    RETVAL = dl_last_error ;
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d251 2
a252 2
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "dl_install_xsub(name=%s, symref=%"UVxf")\n",
		perl_name, PTR2UV(symref)));
d254 1
a254 1
					DPTR2FPTR(XSUBADDR_t, symref),
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d253 3
a255 4
    ST(0) = sv_2mortal(newRV((SV*)newXS_flags(perl_name,
					      DPTR2FPTR(XSUBADDR_t, symref),
					      filename, NULL,
					      XS_DYNAMIC_FILENAME)));
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d249 1
a249 1
    const char *	filename
a265 15

#if defined(USE_ITHREADS)

void
CLONE(...)
    CODE:
    MY_CXT_CLONE;

    /* MY_CXT_CLONE just does a memcpy on the whole structure, so to avoid
     * using Perl variables that belong to another thread, we create our 
     * own for this thread.
     */
    MY_CXT.x_dl_last_error = newSVpvn("", 0);

#endif
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d13 1
a13 1
 * 29th February 2000 - Alan Burlison: Added functionality to close dlopen'd
a117 2

#define PERL_NO_GET_CONTEXT
@


1.1.1.10
log
@Import perl-5.20.1
@
text
@a275 2
    PERL_UNUSED_VAR(items);

@


