head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.2
	OPENBSD_6_2_BASE:1.11
	PERL_5_24_2:1.1.1.10
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.10
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.6.0.18
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.16
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.14
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.12
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.10
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.6.0.8
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.6
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.11
date	2017.02.05.00.32.12;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	cxJ08BvJA9Pt2PTM;

1.10
date	2014.11.17.20.57.05;	author afresh1;	state Exp;
branches;
next	1.9;
commitid	QP75iYx42Uo7mMxO;

1.9
date	2014.03.24.15.05.27;	author afresh1;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.12.18.24.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.04;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.09.18.09.08;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.22;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.05.13;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.55.12;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.03;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.03;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.38.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.08.09.17.45.57;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.16;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.11.11;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	1.1.1.10;
commitid	B31cAbBIXiCqnL97;

1.1.1.10
date	2017.08.14.13.46.11;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.11
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*
 * Author: Jeff Okamoto (okamoto@@corp.hp.com)
 * Version: 2.1, 1995/1/25
 */

/* o Added BIND_VERBOSE to dl_nonlazy condition to add names of missing
 *   symbols to stderr message on fatal error.
 *
 * o Added BIND_NONFATAL comment to default condition.
 *
 * Chuck Phillips (cdp@@fc.hp.com)
 * Version: 2.2, 1997/5/4 */

#ifdef __hp9000s300
#define magic hpux_magic
#define MAGIC HPUX_MAGIC
#endif

#include <dl.h>
#ifdef __hp9000s300
#undef magic
#undef MAGIC
#endif

#define PERL_EXT
#include "EXTERN.h"
#define PERL_IN_DL_HPUX_XS
#include "perl.h"
#include "XSUB.h"

typedef struct {
    AV *	x_resolve_using;
} my_cxtx_t;		/* this *must* be named my_cxtx_t */

#define DL_CXT_EXTRA	/* ask for dl_cxtx to be defined in dlutils.c */
#include "dlutils.c"	/* for SaveError() etc */

#define dl_resolve_using	(dl_cxtx.x_resolve_using)

static void
dl_private_init(pTHX)
{
    (void)dl_generic_private_init(aTHX);
    {
	dMY_CXT;
	dl_resolve_using = get_av("DynaLoader::dl_resolve_using", GV_ADDMULTI);
    }
}

MODULE = DynaLoader     PACKAGE = DynaLoader

BOOT:
    (void)dl_private_init(aTHX);


void
dl_load_file(filename, flags=0)
    char *	filename
    int		flags
    PREINIT:
    shl_t obj = NULL;
    int	i, max, bind_type;
    dMY_CXT;
    CODE:
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_load_file(%s,%x):\n", filename,flags));
    if (flags & 0x01)
	Perl_warn(aTHX_ "Can't make loaded symbols global on this platform while loading %s",filename);
    if (dl_nonlazy) {
      bind_type = BIND_IMMEDIATE|BIND_VERBOSE;
    } else {
      bind_type = BIND_DEFERRED;
      /* For certain libraries, like DCE, deferred binding often causes run
       * time problems.  Adding BIND_NONFATAL to BIND_IMMEDIATE still allows
       * unresolved references in situations like this.  */
      /* bind_type = BIND_IMMEDIATE|BIND_NONFATAL; */
    }
    /* BIND_NOSTART removed from bind_type because it causes the shared library's	*/
    /* initialisers not to be run.  This causes problems with all of the static objects */
    /* in the library.	   */
#ifdef DEBUGGING
    if (dl_debug)
	bind_type |= BIND_VERBOSE;
#endif /* DEBUGGING */

    max = AvFILL(dl_resolve_using);
    for (i = 0; i <= max; i++) {
	char *sym = SvPVX(*av_fetch(dl_resolve_using, i, 0));
	DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_load_file(%s) (dependent)\n", sym));
	obj = shl_load(sym, bind_type, 0L);
	if (obj == NULL) {
	    goto end;
	}
    }

    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_load_file(%s): ", filename));
    obj = shl_load(filename, bind_type, 0L);

    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " libref=%p\n", (void*)obj));
end:
    ST(0) = sv_newmortal() ;
    if (obj == NULL)
        SaveError(aTHX_ "%s",Strerror(errno));
    else
        sv_setiv( ST(0), PTR2IV(obj) );


int
dl_unload_file(libref)
    void *	libref
  CODE:
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_unload_file(%lx):\n", PTR2ul(libref)));
    RETVAL = (shl_unload((shl_t)libref) == 0 ? 1 : 0);
    if (!RETVAL)
	SaveError(aTHX_ "%s", Strerror(errno));
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " retval = %d\n", RETVAL));
  OUTPUT:
    RETVAL


void
dl_find_symbol(libhandle, symbolname, ign_err=0)
    void *	libhandle
    char *	symbolname
    int   	ign_err
    PREINIT:
    shl_t obj = (shl_t) libhandle;
    void *symaddr = NULL;
    int status;
    CODE:
#ifdef __hp9000s300
    symbolname = Perl_form_nocontext("_%s", symbolname);
#endif
    DLDEBUG(2, PerlIO_printf(Perl_debug_log,
			     "dl_find_symbol(handle=%lx, symbol=%s)\n",
			     (unsigned long) libhandle, symbolname));

    ST(0) = sv_newmortal() ;
    errno = 0;

    status = shl_findsym(&obj, symbolname, TYPE_PROCEDURE, &symaddr);
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "  symbolref(PROCEDURE) = %p\n", (void*)symaddr));

    if (status == -1 && errno == 0) {	/* try TYPE_DATA instead */
	status = shl_findsym(&obj, symbolname, TYPE_DATA, &symaddr);
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "  symbolref(DATA) = %p\n", (void*)symaddr));
    }

    if (status == -1) {
	if (!ign_err) SaveError(aTHX_ "%s",(errno) ? Strerror(errno) : "Symbol not found") ;
    } else {
	sv_setiv( ST(0), PTR2IV(symaddr) );
    }


void
dl_undef_symbols()
    CODE:



# These functions should not need changing on any platform:

void
dl_install_xsub(perl_name, symref, filename="$Package")
    char *	perl_name
    void *	symref 
    const char *	filename
    CODE:
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "dl_install_xsub(name=%s, symref=%p)\n",
                            perl_name, (void*)symref));
    ST(0) = sv_2mortal(newRV((SV*)newXS_flags(perl_name,
					      (void(*)(pTHX_ CV *))symref,
					      filename, NULL,
					      XS_DYNAMIC_FILENAME)));

SV *
dl_error()
    CODE:
    dMY_CXT;
    RETVAL = newSVsv(MY_CXT.x_dl_last_error);
    OUTPUT:
    RETVAL

#if defined(USE_ITHREADS)

void
CLONE(...)
    CODE:
    MY_CXT_CLONE;

    PERL_UNUSED_VAR(items);

    /* MY_CXT_CLONE just does a memcpy on the whole structure, so to avoid
     * using Perl variables that belong to another thread, we create our 
     * own for this thread.
     */
    MY_CXT.x_dl_last_error = newSVpvs("");
    dl_resolve_using = get_av("DynaLoader::dl_resolve_using", GV_ADDMULTI);

#endif

# end.
@


1.10
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d25 1
d27 1
d98 1
a98 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " libref=%x\n", obj));
d112 1
a112 1
    RETVAL = (shl_unload(libref) == 0 ? 1 : 0);
d121 1
a121 1
dl_find_symbol(libhandle, symbolname)
d124 1
d141 1
a141 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "  symbolref(PROCEDURE) = %x\n", symaddr));
d145 1
a145 1
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "  symbolref(DATA) = %x\n", symaddr));
d149 1
a149 1
	SaveError(aTHX_ "%s",(errno) ? Strerror(errno) : "Symbol not found") ;
d169 2
a170 2
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "dl_install_xsub(name=%s, symref=%x)\n",
	    perl_name, symref));
d176 1
a176 1
char *
d180 1
a180 1
    RETVAL = dl_last_error ;
d197 1
a197 1
    MY_CXT.x_dl_last_error = newSVpvn("", 0);
@


1.9
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d122 1
a122 1
    CODE:
d126 1
d187 2
@


1.8
log
@Merge in perl 5.10.1
@
text
@d54 1
a54 1
void *
d118 1
a118 1
void *
d153 1
a153 1
    PPCODE:
@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d163 1
a163 1
    char *	filename
d179 16
@


1.6
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d167 4
a170 4
    ST(0) = sv_2mortal(newRV((SV*)newXS(perl_name,
					(void(*)(pTHX_ CV *))symref,
					filename)));

@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d105 13
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d29 3
d33 1
d36 1
a36 2
static AV *dl_resolve_using = Nullav;

d42 4
a45 1
    dl_resolve_using = get_av("DynaLoader::dl_resolve_using", GV_ADDMULTI);
d61 1
d162 2
a163 1
    RETVAL = LastError ;
@


1.3
log
@perl5.005_03 (stock)
@
text
@d36 1
a36 1
dl_private_init()
d38 2
a39 2
    (void)dl_generic_private_init();
    dl_resolve_using = perl_get_av("DynaLoader::dl_resolve_using", 0x4);
d45 1
a45 1
    (void)dl_private_init();
d56 1
a56 1
    DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_load_file(%s,%x):\n", filename,flags));
d58 1
a58 1
	warn("Can't make loaded symbols global on this platform while loading %s",filename);
d79 1
a79 1
	DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_load_file(%s) (dependent)\n", sym));
d86 1
a86 1
    DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_load_file(%s): ", filename));
d89 1
a89 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), " libref=%x\n", obj));
d93 1
a93 1
        SaveError("%s",Strerror(errno));
d95 1
a95 1
        sv_setiv( ST(0), (IV)obj);
d107 1
a107 1
    symbolname = form("_%s", symbolname);
d109 1
a109 1
    DLDEBUG(2, PerlIO_printf(PerlIO_stderr(),
d117 1
a117 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "  symbolref(PROCEDURE) = %x\n", symaddr));
d121 1
a121 1
	DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "  symbolref(DATA) = %x\n", symaddr));
d125 1
a125 1
	SaveError("%s",(errno) ? Strerror(errno) : "Symbol not found") ;
d127 1
a127 1
	sv_setiv( ST(0), (IV)symaddr);
d145 1
a145 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "dl_install_xsub(name=%s, symref=%x)\n",
d147 3
a149 1
    ST(0)=sv_2mortal(newRV((SV*)newXS(perl_name, (void(*)())symref, filename)));
@


1.2
log
@perl 5.004_04
@
text
@d68 3
d80 1
a80 1
	obj = shl_load(sym, bind_type | BIND_NOSTART, 0L);
d87 1
a87 1
    obj = shl_load(filename, bind_type | BIND_NOSTART, 0L);
@


1.1
log
@Initial revision
@
text
@d6 8
d49 4
a52 3
dl_load_file(filename)
    char *		filename
    CODE:
d55 17
a71 5

    if (dl_nonlazy)
	bind_type = BIND_IMMEDIATE;
    else
	bind_type = BIND_DEFERRED;
d76 1
a76 1
	DLDEBUG(1,fprintf(stderr, "dl_load_file(%s) (dependent)\n", sym));
d83 1
a83 1
    DLDEBUG(1,fprintf(stderr,"dl_load_file(%s): ", filename));
d86 1
a86 1
    DLDEBUG(2,fprintf(stderr," libref=%x\n", obj));
d104 1
a104 2
    char symbolname_buf[MAXPATHLEN];
    symbolname = dl_add_underscore(symbolname, symbolname_buf);
d106 4
a109 2
    DLDEBUG(2,fprintf(stderr,"dl_find_symbol(handle=%x, symbol=%s)\n",
		libhandle, symbolname));
d114 1
a114 1
    DLDEBUG(2,fprintf(stderr,"  symbolref(PROCEDURE) = %x\n", symaddr));
d118 1
a118 1
	DLDEBUG(2,fprintf(stderr,"  symbolref(DATA) = %x\n", symaddr));
d142 1
a142 1
    DLDEBUG(2,fprintf(stderr,"dl_install_xsub(name=%s, symref=%x)\n",
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a5 8
/* o Added BIND_VERBOSE to dl_nonlazy condition to add names of missing
 *   symbols to stderr message on fatal error.
 *
 * o Added BIND_NONFATAL comment to default condition.
 *
 * Chuck Phillips (cdp@@fc.hp.com)
 * Version: 2.2, 1997/5/4 */

d41 3
a43 4
dl_load_file(filename, flags=0)
    char *	filename
    int		flags
    PREINIT:
d46 5
a50 20
    CODE:
    DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_load_file(%s,%x):\n", filename,flags));
    if (flags & 0x01)
	warn("Can't make loaded symbols global on this platform while loading %s",filename);
    if (dl_nonlazy) {
      bind_type = BIND_IMMEDIATE|BIND_VERBOSE;
    } else {
      bind_type = BIND_DEFERRED;
      /* For certain libraries, like DCE, deferred binding often causes run
       * time problems.  Adding BIND_NONFATAL to BIND_IMMEDIATE still allows
       * unresolved references in situations like this.  */
      /* bind_type = BIND_IMMEDIATE|BIND_NONFATAL; */
    }
    /* BIND_NOSTART removed from bind_type because it causes the shared library's	*/
    /* initialisers not to be run.  This causes problems with all of the static objects */
    /* in the library.	   */
#ifdef DEBUGGING
    if (dl_debug)
	bind_type |= BIND_VERBOSE;
#endif /* DEBUGGING */
d55 2
a56 2
	DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_load_file(%s) (dependent)\n", sym));
	obj = shl_load(sym, bind_type, 0L);
d62 2
a63 2
    DLDEBUG(1,PerlIO_printf(PerlIO_stderr(), "dl_load_file(%s): ", filename));
    obj = shl_load(filename, bind_type, 0L);
d65 1
a65 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), " libref=%x\n", obj));
d83 2
a84 1
    symbolname = form("_%s", symbolname);
d86 2
a87 4
    DLDEBUG(2, PerlIO_printf(PerlIO_stderr(),
			     "dl_find_symbol(handle=%lx, symbol=%s)\n",
			     (unsigned long) libhandle, symbolname));

d92 1
a92 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "  symbolref(PROCEDURE) = %x\n", symaddr));
d96 1
a96 1
	DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "  symbolref(DATA) = %x\n", symaddr));
d120 1
a120 1
    DLDEBUG(2,PerlIO_printf(PerlIO_stderr(), "dl_install_xsub(name=%s, symref=%x)\n",
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d36 1
a36 1
dl_private_init(pTHX)
d38 2
a39 2
    (void)dl_generic_private_init(aTHX);
    dl_resolve_using = get_av("DynaLoader::dl_resolve_using", GV_ADDMULTI);
d45 1
a45 1
    (void)dl_private_init(aTHX);
d56 1
a56 1
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_load_file(%s,%x):\n", filename,flags));
d58 1
a58 1
	Perl_warn(aTHX_ "Can't make loaded symbols global on this platform while loading %s",filename);
d79 1
a79 1
	DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_load_file(%s) (dependent)\n", sym));
d86 1
a86 1
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_load_file(%s): ", filename));
d89 1
a89 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " libref=%x\n", obj));
d93 1
a93 1
        SaveError(aTHX_ "%s",Strerror(errno));
d95 1
a95 1
        sv_setiv( ST(0), PTR2IV(obj) );
d107 1
a107 1
    symbolname = Perl_form_nocontext("_%s", symbolname);
d109 1
a109 1
    DLDEBUG(2, PerlIO_printf(Perl_debug_log,
d117 1
a117 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "  symbolref(PROCEDURE) = %x\n", symaddr));
d121 1
a121 1
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "  symbolref(DATA) = %x\n", symaddr));
d125 1
a125 1
	SaveError(aTHX_ "%s",(errno) ? Strerror(errno) : "Symbol not found") ;
d127 1
a127 1
	sv_setiv( ST(0), PTR2IV(symaddr) );
d145 1
a145 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "dl_install_xsub(name=%s, symref=%x)\n",
d147 1
a147 3
    ST(0) = sv_2mortal(newRV((SV*)newXS(perl_name,
					(void(*)(pTHX_ CV *))symref,
					filename)));
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a28 3
typedef struct {
    AV *	x_resolve_using;
} my_cxtx_t;		/* this *must* be named my_cxtx_t */
a29 1
#define DL_CXT_EXTRA	/* ask for dl_cxtx to be defined in dlutils.c */
d32 2
a33 1
#define dl_resolve_using	(dl_cxtx.x_resolve_using)
d39 1
a39 4
    {
	dMY_CXT;
	dl_resolve_using = get_av("DynaLoader::dl_resolve_using", GV_ADDMULTI);
    }
a54 1
    dMY_CXT;
d155 1
a155 2
    dMY_CXT;
    RETVAL = dl_last_error ;
@


1.1.1.5
log
@Import of stock perl 5.8.5
@
text
@a104 13
int
dl_unload_file(libref)
    void *	libref
  CODE:
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_unload_file(%lx):\n", PTR2ul(libref)));
    RETVAL = (shl_unload(libref) == 0 ? 1 : 0);
    if (!RETVAL)
	SaveError(aTHX_ "%s", Strerror(errno));
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " retval = %d\n", RETVAL));
  OUTPUT:
    RETVAL


@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d167 4
a170 4
    ST(0) = sv_2mortal(newRV((SV*)newXS_flags(perl_name,
					      (void(*)(pTHX_ CV *))symref,
					      filename, NULL,
					      XS_DYNAMIC_FILENAME)));
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d163 1
a163 1
    const char *	filename
a178 16

#if defined(USE_ITHREADS)

void
CLONE(...)
    CODE:
    MY_CXT_CLONE;

    /* MY_CXT_CLONE just does a memcpy on the whole structure, so to avoid
     * using Perl variables that belong to another thread, we create our 
     * own for this thread.
     */
    MY_CXT.x_dl_last_error = newSVpvn("", 0);
    dl_resolve_using = get_av("DynaLoader::dl_resolve_using", GV_ADDMULTI);

#endif
@


1.1.1.8
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d54 1
a54 1
void
d118 1
a118 1
void
d153 1
a153 1
    CODE:
@


1.1.1.9
log
@Import perl-5.20.1
@
text
@d122 1
a122 1
    PREINIT:
a125 1
    CODE:
a185 2

    PERL_UNUSED_VAR(items);
@


1.1.1.10
log
@Import perl-5.24.2
@
text
@a24 1
#define PERL_EXT
a25 1
#define PERL_IN_DL_HPUX_XS
d96 1
a96 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, " libref=%p\n", (void*)obj));
d110 1
a110 1
    RETVAL = (shl_unload((shl_t)libref) == 0 ? 1 : 0);
d119 1
a119 1
dl_find_symbol(libhandle, symbolname, ign_err=0)
a121 1
    int   	ign_err
d138 1
a138 1
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "  symbolref(PROCEDURE) = %p\n", (void*)symaddr));
d142 1
a142 1
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "  symbolref(DATA) = %p\n", (void*)symaddr));
d146 1
a146 1
	if (!ign_err) SaveError(aTHX_ "%s",(errno) ? Strerror(errno) : "Symbol not found") ;
d166 2
a167 2
    DLDEBUG(2,PerlIO_printf(Perl_debug_log, "dl_install_xsub(name=%s, symref=%p)\n",
                            perl_name, (void*)symref));
d173 1
a173 1
SV *
d177 1
a177 1
    RETVAL = newSVsv(MY_CXT.x_dl_last_error);
d194 1
a194 1
    MY_CXT.x_dl_last_error = newSVpvs("");
@


