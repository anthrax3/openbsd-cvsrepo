head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.11.0.10
	OPENBSD_6_0_BASE:1.1.1.11
	OPENBSD_5_9:1.1.1.11.0.4
	OPENBSD_5_9_BASE:1.1.1.11
	OPENBSD_5_8:1.1.1.11.0.6
	OPENBSD_5_8_BASE:1.1.1.11
	PERL_5_20_2:1.1.1.11
	OPENBSD_5_7:1.1.1.11.0.2
	OPENBSD_5_7_BASE:1.1.1.11
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.1.1.10.0.4
	OPENBSD_5_6_BASE:1.1.1.10
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.9.0.6
	OPENBSD_5_5_BASE:1.1.1.9
	OPENBSD_5_4:1.1.1.9.0.2
	OPENBSD_5_4_BASE:1.1.1.9
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.1.1.8.0.10
	OPENBSD_5_3_BASE:1.1.1.8
	OPENBSD_5_2:1.1.1.8.0.8
	OPENBSD_5_2_BASE:1.1.1.8
	OPENBSD_5_1_BASE:1.1.1.8
	OPENBSD_5_1:1.1.1.8.0.6
	OPENBSD_5_0:1.1.1.8.0.4
	OPENBSD_5_0_BASE:1.1.1.8
	OPENBSD_4_9:1.1.1.8.0.2
	OPENBSD_4_9_BASE:1.1.1.8
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.1.1.7.0.4
	OPENBSD_4_8_BASE:1.1.1.7
	OPENBSD_4_7:1.1.1.7.0.2
	OPENBSD_4_7_BASE:1.1.1.7
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.1.1.6.0.6
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.2
	OPENBSD_4_5_BASE:1.1.1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.10
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.8
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.6
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.4
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.2
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.12
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.10
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.8
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.14;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	99.04.29.22.39.13;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.39.13;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.25;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.43.52;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.19;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.26;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.11.14;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.09.24.14.48.53;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.08.46;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.03.24.14.59.02;	author afresh1;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.11.17.20.53.06;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package re;

# pragma for controlling the regexp engine
use strict;
use warnings;

our $VERSION     = "0.32";
our @@ISA         = qw(Exporter);
our @@EXPORT_OK   = ('regmust',
                    qw(is_regexp regexp_pattern
                       regname regnames regnames_count));
our %EXPORT_OK = map { $_ => 1 } @@EXPORT_OK;

my %bitmask = (
    taint   => 0x00100000, # HINT_RE_TAINT
    eval    => 0x00200000, # HINT_RE_EVAL
);

my $flags_hint = 0x02000000; # HINT_RE_FLAGS
my $PMMOD_SHIFT = 0;
my %reflags = (
    m => 1 << ($PMMOD_SHIFT + 0),
    s => 1 << ($PMMOD_SHIFT + 1),
    i => 1 << ($PMMOD_SHIFT + 2),
    x => 1 << ($PMMOD_SHIFT + 3),
    n => 1 << ($PMMOD_SHIFT + 5),
    p => 1 << ($PMMOD_SHIFT + 6),
    strict => 1 << ($PMMOD_SHIFT + 10),
# special cases:
    d => 0,
    l => 1,
    u => 2,
    a => 3,
    aa => 4,
);

sub setcolor {
 eval {				# Ignore errors
  require Term::Cap;

  my $terminal = Tgetent Term::Cap ({OSPEED => 9600}); # Avoid warning.
  my $props = $ENV{PERL_RE_TC} || 'md,me,so,se,us,ue';
  my @@props = split /,/, $props;
  my $colors = join "\t", map {$terminal->Tputs($_,1)} @@props;

  $colors =~ s/\0//g;
  $ENV{PERL_RE_COLORS} = $colors;
 };
 if ($@@) {
    $ENV{PERL_RE_COLORS} ||= qq'\t\t> <\t> <\t\t';
 }

}

my %flags = (
    COMPILE         => 0x0000FF,
    PARSE           => 0x000001,
    OPTIMISE        => 0x000002,
    TRIEC           => 0x000004,
    DUMP            => 0x000008,
    FLAGS           => 0x000010,
    TEST            => 0x000020,

    EXECUTE         => 0x00FF00,
    INTUIT          => 0x000100,
    MATCH           => 0x000200,
    TRIEE           => 0x000400,

    EXTRA           => 0xFF0000,
    TRIEM           => 0x010000,
    OFFSETS         => 0x020000,
    OFFSETSDBG      => 0x040000,
    STATE           => 0x080000,
    OPTIMISEM       => 0x100000,
    STACK           => 0x280000,
    BUFFERS         => 0x400000,
    GPOS            => 0x800000,
);
$flags{ALL} = -1 & ~($flags{OFFSETS}|$flags{OFFSETSDBG}|$flags{BUFFERS});
$flags{All} = $flags{all} = $flags{DUMP} | $flags{EXECUTE};
$flags{Extra} = $flags{EXECUTE} | $flags{COMPILE} | $flags{GPOS};
$flags{More} = $flags{MORE} = $flags{All} | $flags{TRIEC} | $flags{TRIEM} | $flags{STATE};
$flags{State} = $flags{DUMP} | $flags{EXECUTE} | $flags{STATE};
$flags{TRIE} = $flags{DUMP} | $flags{EXECUTE} | $flags{TRIEC};

if (defined &DynaLoader::boot_DynaLoader) {
    require XSLoader;
    XSLoader::load();
}
# else we're miniperl
# We need to work for miniperl, because the XS toolchain uses Text::Wrap, which
# uses re 'taint'.

sub _load_unload {
    my ($on)= @@_;
    if ($on) {
	# We call install() every time, as if we didn't, we wouldn't
	# "see" any changes to the color environment var since
	# the last time it was called.

	# install() returns an integer, which if casted properly
	# in C resolves to a structure containing the regexp
	# hooks. Setting it to a random integer will guarantee
	# segfaults.
	$^H{regcomp} = install();
    } else {
        delete $^H{regcomp};
    }
}

sub bits {
    my $on = shift;
    my $bits = 0;
    my $turning_all_off = ! @@_ && ! $on;
    my %seen;   # Has flag already been seen?
    if ($turning_all_off) {

        # Pretend were called with certain parameters, which are best dealt
        # with that way.
        push @@_, keys %bitmask; # taint and eval
        push @@_, 'strict';
    }

    # Process each subpragma parameter
   ARG:
    foreach my $idx (0..$#_){
        my $s=$_[$idx];
        if ($s eq 'Debug' or $s eq 'Debugcolor') {
            setcolor() if $s =~/color/i;
            ${^RE_DEBUG_FLAGS} = 0 unless defined ${^RE_DEBUG_FLAGS};
            for my $idx ($idx+1..$#_) {
                if ($flags{$_[$idx]}) {
                    if ($on) {
                        ${^RE_DEBUG_FLAGS} |= $flags{$_[$idx]};
                    } else {
                        ${^RE_DEBUG_FLAGS} &= ~ $flags{$_[$idx]};
                    }
                } else {
                    require Carp;
                    Carp::carp("Unknown \"re\" Debug flag '$_[$idx]', possible flags: ",
                               join(", ",sort keys %flags ) );
                }
            }
            _load_unload($on ? 1 : ${^RE_DEBUG_FLAGS});
            last;
        } elsif ($s eq 'debug' or $s eq 'debugcolor') {
	    setcolor() if $s =~/color/i;
	    _load_unload($on);
	    last;
        } elsif (exists $bitmask{$s}) {
	    $bits |= $bitmask{$s};
	} elsif ($EXPORT_OK{$s}) {
	    require Exporter;
	    re->export_to_level(2, 're', $s);
        } elsif ($s eq 'strict') {
            if ($on) {
                $^H{reflags} |= $reflags{$s};
                warnings::warnif('experimental::re_strict',
                                 "\"use re 'strict'\" is experimental");

                # Turn on warnings if not already done.
                if (! warnings::enabled('regexp')) {
                    require warnings;
                    warnings->import('regexp');
                    $^H{re_strict} = 1;
                }
            }
            else {
                $^H{reflags} &= ~$reflags{$s} if $^H{reflags};

                # Turn off warnings if we turned them on.
                warnings->unimport('regexp') if $^H{re_strict};
            }
	    if ($^H{reflags}) {
                $^H |= $flags_hint;
            }
            else {
                $^H &= ~$flags_hint;
            }
	} elsif ($s =~ s/^\///) {
	    my $reflags = $^H{reflags} || 0;
	    my $seen_charset;
	    while ($s =~ m/( . )/gx) {
                local $_ = $1;
		if (/[adul]/) {
                    # The 'a' may be repeated; hide this from the rest of the
                    # code by counting and getting rid of all of them, then
                    # changing to 'aa' if there is a repeat.
                    if ($_ eq 'a') {
                        my $sav_pos = pos $s;
                        my $a_count = $s =~ s/a//g;
                        pos $s = $sav_pos - 1;  # -1 because got rid of the 'a'
                        if ($a_count > 2) {
			    require Carp;
                            Carp::carp(
                            qq 'The "a" flag may only appear a maximum of twice'
                            );
                        }
                        elsif ($a_count == 2) {
                            $_ = 'aa';
                        }
                    }
		    if ($on) {
			if ($seen_charset) {
			    require Carp;
                            if ($seen_charset ne $_) {
                                Carp::carp(
                                qq 'The "$seen_charset" and "$_" flags '
                                .qq 'are exclusive'
                                );
                            }
                            else {
                                Carp::carp(
                                qq 'The "$seen_charset" flag may not appear '
                                .qq 'twice'
                                );
                            }
			}
			$^H{reflags_charset} = $reflags{$_};
			$seen_charset = $_;
		    }
		    else {
			delete $^H{reflags_charset}
                                     if defined $^H{reflags_charset}
                                        && $^H{reflags_charset} == $reflags{$_};
		    }
		} elsif (exists $reflags{$_}) {
                    $seen{$_}++;
                    $on
		      ? $reflags |= $reflags{$_}
		      : ($reflags &= ~$reflags{$_});
		} else {
		    require Carp;
		    Carp::carp(
		     qq'Unknown regular expression flag "$_"'
		    );
		    next ARG;
		}
	    }
	    ($^H{reflags} = $reflags or defined $^H{reflags_charset})
	                    ? $^H |= $flags_hint
	                    : ($^H &= ~$flags_hint);
	} else {
	    require Carp;
	    Carp::carp("Unknown \"re\" subpragma '$s' (known ones are: ",
                       join(', ', map {qq('$_')} 'debug', 'debugcolor', sort keys %bitmask),
                       ")");
	}
    }
    if (exists $seen{'x'} && $seen{'x'} > 1
        && (warnings::enabled("deprecated")
            || warnings::enabled("regexp")))
    {
        my $message = "Having more than one /x regexp modifier is deprecated";
        if (warnings::enabled("deprecated")) {
            warnings::warn("deprecated", $message);
        }
        else {
            warnings::warn("regexp", $message);
        }
    }

    if ($turning_all_off) {
        _load_unload(0);
        $^H{reflags} = 0;
        $^H{reflags_charset} = 0;
        $^H &= ~$flags_hint;
    }

    $bits;
}

sub import {
    shift;
    $^H |= bits(1, @@_);
}

sub unimport {
    shift;
    $^H &= ~ bits(0, @@_);
}

1;

__END__

=head1 NAME

re - Perl pragma to alter regular expression behaviour

=head1 SYNOPSIS

    use re 'taint';
    ($x) = ($^X =~ /^(.*)$/s);     # $x is tainted here

    $pat = '(?{ $foo = 1 })';
    use re 'eval';
    /foo${pat}bar/;		   # won't fail (when not under -T
                                   # switch)

    {
	no re 'taint';		   # the default
	($x) = ($^X =~ /^(.*)$/s); # $x is not tainted here

	no re 'eval';		   # the default
	/foo${pat}bar/;		   # disallowed (with or without -T
                                   # switch)
    }

    use re 'strict';               # Raise warnings for more conditions

    use re '/ix';
    "FOO" =~ / foo /; # /ix implied
    no re '/x';
    "FOO" =~ /foo/; # just /i implied

    use re 'debug';		   # output debugging info during
    /^(.*)$/s;			   # compile and run time


    use re 'debugcolor';	   # same as 'debug', but with colored
                                   # output
    ...

    use re qw(Debug All);          # Same as "use re 'debug'", but you
                                   # can use "Debug" with things other
                                   # than 'All'
    use re qw(Debug More);         # 'All' plus output more details
    no re qw(Debug ALL);           # Turn on (almost) all re debugging
                                   # in this scope

    use re qw(is_regexp regexp_pattern); # import utility functions
    my ($pat,$mods)=regexp_pattern(qr/foo/i);
    if (is_regexp($obj)) { 
        print "Got regexp: ",
            scalar regexp_pattern($obj); # just as perl would stringify
    }                                    # it but no hassle with blessed
                                         # re's.

(We use $^X in these examples because it's tainted by default.)

=head1 DESCRIPTION

=head2 'taint' mode

When C<use re 'taint'> is in effect, and a tainted string is the target
of a regexp, the regexp memories (or values returned by the m// operator
in list context) are tainted.  This feature is useful when regexp operations
on tainted data aren't meant to extract safe substrings, but to perform
other transformations.

=head2 'eval' mode

When C<use re 'eval'> is in effect, a regexp is allowed to contain
C<(?{ ... })> zero-width assertions and C<(??{ ... })> postponed
subexpressions that are derived from variable interpolation, rather than
appearing literally within the regexp.  That is normally disallowed, since
it is a
potential security risk.  Note that this pragma is ignored when the regular
expression is obtained from tainted data, i.e.  evaluation is always
disallowed with tainted regular expressions.  See L<perlre/(?{ code })> 
and L<perlre/(??{ code })>.

For the purpose of this pragma, interpolation of precompiled regular
expressions (i.e., the result of C<qr//>) is I<not> considered variable
interpolation.  Thus:

    /foo${pat}bar/

I<is> allowed if $pat is a precompiled regular expression, even
if $pat contains C<(?{ ... })> assertions or C<(??{ ... })> subexpressions.

=head2 'strict' mode

Note that this is an experimental feature which may be changed or removed in a
future Perl release.

When C<use re 'strict'> is in effect, stricter checks are applied than
otherwise when compiling regular expressions patterns.  These may cause more
warnings to be raised than otherwise, and more things to be fatal instead of
just warnings.  The purpose of this is to find and report at compile time some
things, which may be legal, but have a reasonable possibility of not being the
programmer's actual intent.  This automatically turns on the C<"regexp">
warnings category (if not already on) within its scope.

As an example of something that is caught under C<"strict'>, but not
otherwise, is the pattern

 qr/\xABC/

The C<"\x"> construct without curly braces should be followed by exactly two
hex digits; this one is followed by three.  This currently evaluates as
equivalent to

 qr/\x{AB}C/

that is, the character whose code point value is C<0xAB>, followed by the
letter C<C>.  But since C<C> is a a hex digit, there is a reasonable chance
that the intent was

 qr/\x{ABC}/

that is the single character at C<0xABC>.  Under C<'strict'> it is an error to
not follow C<\x> with exactly two hex digits.  When not under C<'strict'> a
warning is generated if there is only one hex digit, and no warning is raised
if there are more than two.

It is expected that what exactly C<'strict'> does will evolve over time as we
gain experience with it.  This means that programs that compile under it in
today's Perl may not compile, or may have more or fewer warnings, in future
Perls.  There is no backwards compatibility promises with regards to it.  Also
there are already proposals for an alternate syntax for enabling it.  For
these reasons, using it will raise a C<experimental::re_strict> class warning,
unless that category is turned off.

Note that if a pattern compiled within C<'strict'> is recompiled, say by
interpolating into another pattern, outside of C<'strict'>, it is not checked
again for strictness.  This is because if it works under strict it must work
under non-strict.

=head2 '/flags' mode

When C<use re '/flags'> is specified, the given flags are automatically
added to every regular expression till the end of the lexical scope.

C<no re '/flags'> will turn off the effect of C<use re '/flags'> for the
given flags.

For example, if you want all your regular expressions to have /msx on by
default, simply put

    use re '/msx';

at the top of your code.

The character set /adul flags cancel each other out. So, in this example,

    use re "/u";
    "ss" =~ /\xdf/;
    use re "/d";
    "ss" =~ /\xdf/;

the second C<use re> does an implicit C<no re '/u'>.

Turning on one of the character set flags with C<use re> takes precedence over the
C<locale> pragma and the 'unicode_strings' C<feature>, for regular
expressions. Turning off one of these flags when it is active reverts to
the behaviour specified by whatever other pragmata are in scope. For
example:

    use feature "unicode_strings";
    no re "/u"; # does nothing
    use re "/l";
    no re "/l"; # reverts to unicode_strings behaviour

=head2 'debug' mode

When C<use re 'debug'> is in effect, perl emits debugging messages when
compiling and using regular expressions.  The output is the same as that
obtained by running a C<-DDEBUGGING>-enabled perl interpreter with the
B<-Dr> switch. It may be quite voluminous depending on the complexity
of the match.  Using C<debugcolor> instead of C<debug> enables a
form of output that can be used to get a colorful display on terminals
that understand termcap color sequences.  Set C<$ENV{PERL_RE_TC}> to a
comma-separated list of C<termcap> properties to use for highlighting
strings on/off, pre-point part on/off.
See L<perldebug/"Debugging Regular Expressions"> for additional info.

As of 5.9.5 the directive C<use re 'debug'> and its equivalents are
lexically scoped, as the other directives are.  However they have both 
compile-time and run-time effects.

See L<perlmodlib/Pragmatic Modules>.

=head2 'Debug' mode

Similarly C<use re 'Debug'> produces debugging output, the difference
being that it allows the fine tuning of what debugging output will be
emitted. Options are divided into three groups, those related to
compilation, those related to execution and those related to special
purposes. The options are as follows:

=over 4

=item Compile related options

=over 4

=item COMPILE

Turns on all compile related debug options.

=item PARSE

Turns on debug output related to the process of parsing the pattern.

=item OPTIMISE

Enables output related to the optimisation phase of compilation.

=item TRIEC

Detailed info about trie compilation.

=item DUMP

Dump the final program out after it is compiled and optimised.

=item FLAGS

Dump the flags associated with the program

=item TEST

Print output intended for testing the internals of the compile process

=back

=item Execute related options

=over 4

=item EXECUTE

Turns on all execute related debug options.

=item MATCH

Turns on debugging of the main matching loop.

=item TRIEE

Extra debugging of how tries execute.

=item INTUIT

Enable debugging of start-point optimisations.

=back

=item Extra debugging options

=over 4

=item EXTRA

Turns on all "extra" debugging options.

=item BUFFERS

Enable debugging the capture group storage during match. Warning,
this can potentially produce extremely large output.

=item TRIEM

Enable enhanced TRIE debugging. Enhances both TRIEE
and TRIEC.

=item STATE

Enable debugging of states in the engine.

=item STACK

Enable debugging of the recursion stack in the engine. Enabling
or disabling this option automatically does the same for debugging
states as well. This output from this can be quite large.

=item GPOS

Enable debugging of the \G modifier.

=item OPTIMISEM

Enable enhanced optimisation debugging and start-point optimisations.
Probably not useful except when debugging the regexp engine itself.

=item OFFSETS

Dump offset information. This can be used to see how regops correlate
to the pattern. Output format is

   NODENUM:POSITION[LENGTH]

Where 1 is the position of the first char in the string. Note that position
can be 0, or larger than the actual length of the pattern, likewise length
can be zero.

=item OFFSETSDBG

Enable debugging of offsets information. This emits copious
amounts of trace information and doesn't mesh well with other
debug options.

Almost definitely only useful to people hacking
on the offsets part of the debug engine.


=back

=item Other useful flags

These are useful shortcuts to save on the typing.

=over 4

=item ALL

Enable all options at once except OFFSETS, OFFSETSDBG and BUFFERS.
(To get every single option without exception, use both ALL and EXTRA.)

=item All

Enable DUMP and all execute options. Equivalent to:

  use re 'debug';

=item MORE

=item More

Enable the options enabled by "All", plus STATE, TRIEC, and TRIEM.

=back

=back

As of 5.9.5 the directive C<use re 'debug'> and its equivalents are
lexically scoped, as are the other directives.  However they have both
compile-time and run-time effects.

=head2 Exportable Functions

As of perl 5.9.5 're' debug contains a number of utility functions that
may be optionally exported into the caller's namespace. They are listed
below.

=over 4

=item is_regexp($ref)

Returns true if the argument is a compiled regular expression as returned
by C<qr//>, false if it is not.

This function will not be confused by overloading or blessing. In
internals terms, this extracts the regexp pointer out of the
PERL_MAGIC_qr structure so it cannot be fooled.

=item regexp_pattern($ref)

If the argument is a compiled regular expression as returned by C<qr//>,
then this function returns the pattern.

In list context it returns a two element list, the first element
containing the pattern and the second containing the modifiers used when
the pattern was compiled.

  my ($pat, $mods) = regexp_pattern($ref);

In scalar context it returns the same as perl would when stringifying a raw
C<qr//> with the same pattern inside.  If the argument is not a compiled
reference then this routine returns false but defined in scalar context,
and the empty list in list context. Thus the following

    if (regexp_pattern($ref) eq '(?^i:foo)')

will be warning free regardless of what $ref actually is.

Like C<is_regexp> this function will not be confused by overloading
or blessing of the object.

=item regmust($ref)

If the argument is a compiled regular expression as returned by C<qr//>,
then this function returns what the optimiser considers to be the longest
anchored fixed string and longest floating fixed string in the pattern.

A I<fixed string> is defined as being a substring that must appear for the
pattern to match. An I<anchored fixed string> is a fixed string that must
appear at a particular offset from the beginning of the match. A I<floating
fixed string> is defined as a fixed string that can appear at any point in
a range of positions relative to the start of the match. For example,

    my $qr = qr/here .* there/x;
    my ($anchored, $floating) = regmust($qr);
    print "anchored:'$anchored'\nfloating:'$floating'\n";

results in

    anchored:'here'
    floating:'there'

Because the C<here> is before the C<.*> in the pattern, its position
can be determined exactly. That's not true, however, for the C<there>;
it could appear at any point after where the anchored string appeared.
Perl uses both for its optimisations, preferring the longer, or, if they are
equal, the floating.

B<NOTE:> This may not necessarily be the definitive longest anchored and
floating string. This will be what the optimiser of the Perl that you
are using thinks is the longest. If you believe that the result is wrong
please report it via the L<perlbug> utility.

=item regname($name,$all)

Returns the contents of a named buffer of the last successful match. If
$all is true, then returns an array ref containing one entry per buffer,
otherwise returns the first defined buffer.

=item regnames($all)

Returns a list of all of the named buffers defined in the last successful
match. If $all is true, then it returns all names defined, if not it returns
only names which were involved in the match.

=item regnames_count()

Returns the number of distinct names defined in the pattern used
for the last successful match.

B<Note:> this result is always the actual number of distinct
named buffers defined, it may not actually match that which is
returned by C<regnames()> and related routines when those routines
have not been called with the $all parameter set.

=back

=head1 SEE ALSO

L<perlmodlib/Pragmatic Modules>.

=cut
@


1.1
log
@Initial revision
@
text
@d3 283
a285 1
$VERSION = 0.02;
d298 2
a299 1
    /foo${pat}bar/;		   # won't fail (when not under -T switch)
d306 2
a307 1
	/foo${pat}bar/;		   # disallowed (with or without -T switch)
d310 9
a318 3
    use re 'debug';		   # NOT lexically scoped (as others are)
    /^(.*)$/s;			   # output debugging info during
    				   #     compile and run time
d320 3
a322 1
    use re 'debugcolor';	   # same as 'debug', but with colored output
d325 15
d344 2
d347 2
a348 2
of a regex, the regex memories (or values returned by the m// operator
in list context) are tainted.  This feature is useful when regex operations
d352 7
a358 3
When C<use re 'eval'> is in effect, a regex is allowed to contain
C<(?{ ... })> zero-width assertions even if the regex contains
variable interpolation.  This is normally disallowed, since it is a 
d361 2
a362 1
disallowed with tainted regular expressions.  See L<perlre/(?{ code })>.
d364 1
a364 1
For the purpose of this pragma, interpolation of precompiled regular 
d370 72
a441 2
I<is> allowed if $pat is a precompiled regular expression, even 
if $pat contains C<(?{ ... })> assertions.
d443 16
a458 1
When C<use re 'debug'> is in effect, perl emits debugging messages when 
d466 2
a467 2
strings on/off, pre-point part on/off.  
See L<perldebug/"Debugging regular expressions"> for additional info.
d469 3
a471 2
The directive C<use re 'debug'> is I<not lexically scoped>, as the
other directives are.  It has both compile-time and run-time effects.
d475 230
a704 1
=cut
d706 3
a708 4
my %bitmask = (
taint	=> 0x00100000,
eval	=> 0x00200000,
);
d710 1
a710 3
sub setcolor {
 eval {				# Ignore errors
  require Term::Cap;
d712 3
a714 3
  my $terminal = Tgetent Term::Cap ({OSPEED => 9600}); # Avoid warning.
  my $props = $ENV{PERL_RE_TC} || 'md,me,so,se'; # can use us/ue later
  my @@props = split /,/, $props;
d716 1
d718 2
a719 2
  $ENV{TERMCAP_COLORS} = join "\t", map {$terminal->Tputs($_,1)} @@props;
 };
d721 4
a724 4
 not defined $ENV{TERMCAP_COLORS} or ($ENV{TERMCAP_COLORS} =~ tr/\t/\t/) >= 4
    or not defined $ENV{PERL_RE_TC}
    or die "Not enough fields in \$ENV{PERL_RE_TC}=`$ENV{PERL_RE_TC}'";
}
d726 1
a726 21
sub bits {
    my $on = shift;
    my $bits = 0;
    unless(@@_) {
	require Carp;
	Carp::carp("Useless use of \"re\" pragma");
    }
    foreach my $s (@@_){
      if ($s eq 'debug' or $s eq 'debugcolor') {
 	  setcolor() if $s eq 'debugcolor';
	  require DynaLoader;
	  @@ISA = ('DynaLoader');
	  bootstrap re;
	  install() if $on;
	  uninstall() unless $on;
	  next;
      }
      $bits |= $bitmask{$s} || 0;
    }
    $bits;
}
d728 1
a728 4
sub import {
    shift;
    $^H |= bits(1,@@_);
}
d730 1
a730 4
sub unimport {
    shift;
    $^H &= ~ bits(0,@@_);
}
d732 1
a732 1
1;
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d44 2
a45 2
C<(?{ ... })> zero-width assertions even if regular expression contains
variable interpolation.  That is normally disallowed, since it is a 
d48 1
a48 1
disallowed with tainted regular expresssions.  See L<perlre/(?{ code })>.
a76 2
# N.B. File::Basename contains a literal for 'taint' as a fallback.  If
# taint is changed here, File::Basename must be updated as well.
d87 1
a87 1
  my $props = $ENV{PERL_RE_TC} || 'md,me,so,se,us,ue';
a88 1
  my $colors = join "\t", map {$terminal->Tputs($_,1)} @@props;
d90 2
a91 2
  $colors =~ s/\0//g;
  $ENV{PERL_RE_COLORS} = $colors;
d93 4
d109 3
a111 2
	  require XSLoader;
	  XSLoader::load('re');
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
our $VERSION = 0.03;
d45 1
a45 1
variable interpolation.  That is normally disallowed, since it is a
d50 1
a50 1
For the purpose of this pragma, interpolation of precompiled regular
d56 1
a56 1
I<is> allowed if $pat is a precompiled regular expression, even
d59 1
a59 1
When C<use re 'debug'> is in effect, perl emits debugging messages when
d67 1
a67 1
strings on/off, pre-point part on/off.
d80 2
a81 2
taint		=> 0x00100000,
eval		=> 0x00200000,
d101 1
a101 1
    unless (@@_) {
d114 1
a114 6
      if (exists $bitmask{$s}) {
	  $bits |= $bitmask{$s};
      } else {
	  require Carp;
	  Carp::carp("Unknown \"re\" subpragma '$s' (known ones are: @@{[join(', ', map {qq('$_')} 'debug', 'debugcolor', sort keys %bitmask)]})");
      }
d121 1
a121 1
    $^H |= bits(1, @@_);
d126 1
a126 1
    $^H &= ~ bits(0, @@_);
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
our $VERSION = 0.04;
d80 2
a81 2
taint		=> 0x00100000, # HINT_RE_TAINT
eval		=> 0x00200000, # HINT_RE_EVAL
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
our $VERSION = 0.05;
d48 1
a48 1
disallowed with tainted regular expressions.  See L<perlre/(?{ code })>.
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 169
# pragma for controlling the regex engine
use strict;
use warnings;

our $VERSION     = "0.08";
our @@ISA         = qw(Exporter);
our @@EXPORT_OK   = qw(is_regexp regexp_pattern regmust 
                      regname regnames regnames_count);
our %EXPORT_OK = map { $_ => 1 } @@EXPORT_OK;

# *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING ***
#
# If you modify these values see comment below!

my %bitmask = (
    taint   => 0x00100000, # HINT_RE_TAINT
    eval    => 0x00200000, # HINT_RE_EVAL
);

# - File::Basename contains a literal for 'taint' as a fallback.  If
# taint is changed here, File::Basename must be updated as well.
#
# - ExtUtils::ParseXS uses a hardcoded 
# BEGIN { $^H |= 0x00200000 } 
# in it to allow re.xs to be built. So if 'eval' is changed here then
# ExtUtils::ParseXS must be changed as well.
#
# *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING ***

sub setcolor {
 eval {				# Ignore errors
  require Term::Cap;

  my $terminal = Tgetent Term::Cap ({OSPEED => 9600}); # Avoid warning.
  my $props = $ENV{PERL_RE_TC} || 'md,me,so,se,us,ue';
  my @@props = split /,/, $props;
  my $colors = join "\t", map {$terminal->Tputs($_,1)} @@props;

  $colors =~ s/\0//g;
  $ENV{PERL_RE_COLORS} = $colors;
 };
 if ($@@) {
    $ENV{PERL_RE_COLORS} ||= qq'\t\t> <\t> <\t\t';
 }

}

my %flags = (
    COMPILE         => 0x0000FF,
    PARSE           => 0x000001,
    OPTIMISE        => 0x000002,
    TRIEC           => 0x000004,
    DUMP            => 0x000008,
    FLAGS           => 0x000010,

    EXECUTE         => 0x00FF00,
    INTUIT          => 0x000100,
    MATCH           => 0x000200,
    TRIEE           => 0x000400,

    EXTRA           => 0xFF0000,
    TRIEM           => 0x010000,
    OFFSETS         => 0x020000,
    OFFSETSDBG      => 0x040000,
    STATE           => 0x080000,
    OPTIMISEM       => 0x100000,
    STACK           => 0x280000,
    BUFFERS         => 0x400000,
);
$flags{ALL} = -1 & ~($flags{OFFSETS}|$flags{OFFSETSDBG}|$flags{BUFFERS});
$flags{All} = $flags{all} = $flags{DUMP} | $flags{EXECUTE};
$flags{Extra} = $flags{EXECUTE} | $flags{COMPILE};
$flags{More} = $flags{MORE} = $flags{All} | $flags{TRIEC} | $flags{TRIEM} | $flags{STATE};
$flags{State} = $flags{DUMP} | $flags{EXECUTE} | $flags{STATE};
$flags{TRIE} = $flags{DUMP} | $flags{EXECUTE} | $flags{TRIEC};

my $installed;
my $installed_error;

sub _do_install {
    if ( ! defined($installed) ) {
        require XSLoader;
        $installed = eval { XSLoader::load('re', $VERSION) } || 0;
        $installed_error = $@@;
    }
}

sub _load_unload {
    my ($on)= @@_;
    if ($on) {
        _do_install();        
        if ( ! $installed ) {
            die "'re' not installed!? ($installed_error)";
	} else {
	    # We call install() every time, as if we didn't, we wouldn't
	    # "see" any changes to the color environment var since
	    # the last time it was called.

	    # install() returns an integer, which if casted properly
	    # in C resolves to a structure containing the regex
	    # hooks. Setting it to a random integer will guarantee
	    # segfaults.
	    $^H{regcomp} = install();
        }
    } else {
        delete $^H{regcomp};
    }
}

sub bits {
    my $on = shift;
    my $bits = 0;
    unless (@@_) {
	require Carp;
	Carp::carp("Useless use of \"re\" pragma"); 
    }
    foreach my $idx (0..$#_){
        my $s=$_[$idx];
        if ($s eq 'Debug' or $s eq 'Debugcolor') {
            setcolor() if $s =~/color/i;
            ${^RE_DEBUG_FLAGS} = 0 unless defined ${^RE_DEBUG_FLAGS};
            for my $idx ($idx+1..$#_) {
                if ($flags{$_[$idx]}) {
                    if ($on) {
                        ${^RE_DEBUG_FLAGS} |= $flags{$_[$idx]};
                    } else {
                        ${^RE_DEBUG_FLAGS} &= ~ $flags{$_[$idx]};
                    }
                } else {
                    require Carp;
                    Carp::carp("Unknown \"re\" Debug flag '$_[$idx]', possible flags: ",
                               join(", ",sort keys %flags ) );
                }
            }
            _load_unload($on ? 1 : ${^RE_DEBUG_FLAGS});
            last;
        } elsif ($s eq 'debug' or $s eq 'debugcolor') {
	    setcolor() if $s =~/color/i;
	    _load_unload($on);
	    last;
        } elsif (exists $bitmask{$s}) {
	    $bits |= $bitmask{$s};
	} elsif ($EXPORT_OK{$s}) {
	    _do_install();
	    require Exporter;
	    re->export_to_level(2, 're', $s);
	} else {
	    require Carp;
	    Carp::carp("Unknown \"re\" subpragma '$s' (known ones are: ",
                       join(', ', map {qq('$_')} 'debug', 'debugcolor', sort keys %bitmask),
                       ")");
	}
    }
    $bits;
}

sub import {
    shift;
    $^H |= bits(1, @@_);
}

sub unimport {
    shift;
    $^H &= ~ bits(0, @@_);
}

1;

__END__
d26 3
a28 3
    use re 'debug';		   # output debugging info during
    /^(.*)$/s;			   #     compile and run time

a32 11
    use re qw(Debug All);          # Finer tuned debugging options.
    use re qw(Debug More);
    no re qw(Debug ALL);           # Turn of all re debugging in this scope

    use re qw(is_regexp regexp_pattern); # import utility functions
    my ($pat,$mods)=regexp_pattern(qr/foo/i);
    if (is_regexp($obj)) { 
        print "Got regexp: ",
            scalar regexp_pattern($obj); # just as perl would stringify it
    }                                    # but no hassle with blessed re's.

a36 2
=head2 'taint' mode

a42 2
=head2 'eval' mode

a58 2
=head2 'debug' mode

d70 2
a71 3
As of 5.9.5 the directive C<use re 'debug'> and its equivalents are
lexically scoped, as the other directives are.  However they have both 
compile-time and run-time effects.
d75 1
a75 1
=head2 'Debug' mode
d77 6
a82 5
Similarly C<use re 'Debug'> produces debugging output, the difference
being that it allows the fine tuning of what debugging output will be
emitted. Options are divided into three groups, those related to
compilation, those related to execution and those related to special
purposes. The options are as follows:
d84 3
a86 1
=over 4
d88 4
a91 1
=item Compile related options
d93 4
a96 1
=over 4
d98 25
a122 1
=item COMPILE
d124 4
a127 1
Turns on all compile related debug options.
d129 4
a132 1
=item PARSE
d134 1
a134 224
Turns on debug output related to the process of parsing the pattern.

=item OPTIMISE

Enables output related to the optimisation phase of compilation.

=item TRIEC

Detailed info about trie compilation.

=item DUMP

Dump the final program out after it is compiled and optimised.

=back

=item Execute related options

=over 4

=item EXECUTE

Turns on all execute related debug options.

=item MATCH

Turns on debugging of the main matching loop.

=item TRIEE

Extra debugging of how tries execute.

=item INTUIT

Enable debugging of start point optimisations.

=back

=item Extra debugging options

=over 4

=item EXTRA

Turns on all "extra" debugging options.

=item BUFFERS

Enable debugging the capture buffer storage during match. Warning,
this can potentially produce extremely large output.

=item TRIEM

Enable enhanced TRIE debugging. Enhances both TRIEE
and TRIEC.

=item STATE

Enable debugging of states in the engine.

=item STACK

Enable debugging of the recursion stack in the engine. Enabling
or disabling this option automatically does the same for debugging
states as well. This output from this can be quite large.

=item OPTIMISEM

Enable enhanced optimisation debugging and start point optimisations.
Probably not useful except when debugging the regex engine itself.

=item OFFSETS

Dump offset information. This can be used to see how regops correlate
to the pattern. Output format is

   NODENUM:POSITION[LENGTH]

Where 1 is the position of the first char in the string. Note that position
can be 0, or larger than the actual length of the pattern, likewise length
can be zero.

=item OFFSETSDBG

Enable debugging of offsets information. This emits copious
amounts of trace information and doesn't mesh well with other
debug options.

Almost definitely only useful to people hacking
on the offsets part of the debug engine.

=back

=item Other useful flags

These are useful shortcuts to save on the typing.

=over 4

=item ALL

Enable all options at once except OFFSETS, OFFSETSDBG and BUFFERS

=item All

Enable DUMP and all execute options. Equivalent to:

  use re 'debug';

=item MORE

=item More

Enable TRIEM and all execute compile and execute options.

=back

=back

As of 5.9.5 the directive C<use re 'debug'> and its equivalents are
lexically scoped, as the other directives are.  However they have both
compile-time and run-time effects.

=head2 Exportable Functions

As of perl 5.9.5 're' debug contains a number of utility functions that
may be optionally exported into the caller's namespace. They are listed
below.

=over 4

=item is_regexp($ref)

Returns true if the argument is a compiled regular expression as returned
by C<qr//>, false if it is not.

This function will not be confused by overloading or blessing. In
internals terms, this extracts the regexp pointer out of the
PERL_MAGIC_qr structure so it it cannot be fooled.

=item regexp_pattern($ref)

If the argument is a compiled regular expression as returned by C<qr//>,
then this function returns the pattern.

In list context it returns a two element list, the first element
containing the pattern and the second containing the modifiers used when
the pattern was compiled.

  my ($pat, $mods) = regexp_pattern($ref);

In scalar context it returns the same as perl would when strigifying a raw
C<qr//> with the same pattern inside.  If the argument is not a compiled
reference then this routine returns false but defined in scalar context,
and the empty list in list context. Thus the following

    if (regexp_pattern($ref) eq '(?i-xsm:foo)')

will be warning free regardless of what $ref actually is.

Like C<is_regexp> this function will not be confused by overloading
or blessing of the object.

=item regmust($ref)

If the argument is a compiled regular expression as returned by C<qr//>,
then this function returns what the optimiser consiers to be the longest
anchored fixed string and longest floating fixed string in the pattern.

A I<fixed string> is defined as being a substring that must appear for the
pattern to match. An I<anchored fixed string> is a fixed string that must
appear at a particular offset from the beginning of the match. A I<floating
fixed string> is defined as a fixed string that can appear at any point in
a range of positions relative to the start of the match. For example,

    my $qr = qr/here .* there/x;
    my ($anchored, $floating) = regmust($qr);
    print "anchored:'$anchored'\nfloating:'$floating'\n";

results in

    anchored:'here'
    floating:'there'

Because the C<here> is before the C<.*> in the pattern, its position
can be determined exactly. That's not true, however, for the C<there>;
it could appear at any point after where the anchored string appeared.
Perl uses both for its optimisations, prefering the longer, or, if they are
equal, the floating.

B<NOTE:> This may not necessarily be the definitive longest anchored and
floating string. This will be what the optimiser of the Perl that you
are using thinks is the longest. If you believe that the result is wrong
please report it via the L<perlbug> utility.

=item regname($name,$all)

Returns the contents of a named buffer of the last successful match. If
$all is true, then returns an array ref containing one entry per buffer,
otherwise returns the first defined buffer.

=item regnames($all)

Returns a list of all of the named buffers defined in the last successful
match. If $all is true, then it returns all names defined, if not it returns
only names which were involved in the match.

=item regnames_count()

Returns the number of distinct names defined in the pattern used
for the last successful match.

B<Note:> this result is always the actual number of distinct
named buffers defined, it may not actually match that which is
returned by C<regnames()> and related routines when those routines
have not been called with the $all parameter set.

=back

=head1 SEE ALSO

L<perlmodlib/Pragmatic Modules>.

=cut
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d7 1
a7 1
our $VERSION     = "0.09";
d9 2
a10 5
my @@XS_FUNCTIONS = qw(regmust);
my %XS_FUNCTIONS = map { $_ => 1 } @@XS_FUNCTIONS;
our @@EXPORT_OK   = (@@XS_FUNCTIONS,
                    qw(is_regexp regexp_pattern
                       regname regnames regnames_count));
a144 8
        } elsif ($XS_FUNCTIONS{$s}) {
            _do_install();
            if (! $installed) {
                require Carp;
                Carp::croak("\"re\" function '$s' not available");
            }
            require Exporter;
            re->export_to_level(2, 're', $s);
d146 1
@


1.1.1.8
log
@Perl 5.12.2 from CPAN
@
text
@d3 1
a3 1
# pragma for controlling the regexp engine
d7 1
a7 1
our $VERSION     = "0.11";
d9 3
a11 1
our @@EXPORT_OK   = ('regmust',
d16 4
d25 10
a73 1
    GPOS            => 0x800000,
d77 1
a77 1
$flags{Extra} = $flags{EXECUTE} | $flags{COMPILE} | $flags{GPOS};
d82 9
a90 3
if (defined &DynaLoader::boot_DynaLoader) {
    require XSLoader;
    XSLoader::load( __PACKAGE__, $VERSION);
a91 3
# else we're miniperl
# We need to work for miniperl, because the XS toolchain uses Text::Wrap, which
# uses re 'taint'.
d96 14
a109 9
	# We call install() every time, as if we didn't, we wouldn't
	# "see" any changes to the color environment var since
	# the last time it was called.

	# install() returns an integer, which if casted properly
	# in C resolves to a structure containing the regexp
	# hooks. Setting it to a random integer will guarantee
	# segfaults.
	$^H{regcomp} = install();
d148 8
d229 2
a230 2
of a regexp, the regexp memories (or values returned by the m// operator
in list context) are tainted.  This feature is useful when regexp operations
d236 2
a237 3
When C<use re 'eval'> is in effect, a regexp is allowed to contain
C<(?{ ... })> zero-width assertions and C<(??{ ... })> postponed
subexpressions, even if the regular expression contains
d241 1
a241 2
disallowed with tainted regular expressions.  See L<perlre/(?{ code })> 
and L<perlre/(??{ code })>.
d250 1
a250 1
if $pat contains C<(?{ ... })> assertions or C<(??{ ... })> subexpressions.
d360 1
a360 1
Probably not useful except when debugging the regexp engine itself.
d442 1
a442 1
In scalar context it returns the same as perl would when stringifying a raw
d457 1
a457 1
then this function returns what the optimiser considers to be the longest
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d7 1
a7 1
our $VERSION     = "0.19_01";
a18 16
my $flags_hint = 0x02000000; # HINT_RE_FLAGS
my $PMMOD_SHIFT = 0;
my %reflags = (
    m => 1 << ($PMMOD_SHIFT + 0),
    s => 1 << ($PMMOD_SHIFT + 1),
    i => 1 << ($PMMOD_SHIFT + 2),
    x => 1 << ($PMMOD_SHIFT + 3),
    p => 1 << ($PMMOD_SHIFT + 4),
# special cases:
    d => 0,
    l => 1,
    u => 2,
    a => 3,
    aa => 4,
);

d69 1
a69 1
    XSLoader::load();
d95 4
a98 1
   ARG:
a127 62
	} elsif ($s =~ s/^\///) {
	    my $reflags = $^H{reflags} || 0;
	    my $seen_charset;
	    while ($s =~ m/( . )/gx) {
                local $_ = $1;
		if (/[adul]/) {
                    # The 'a' may be repeated; hide this from the rest of the
                    # code by counting and getting rid of all of them, then
                    # changing to 'aa' if there is a repeat.
                    if ($_ eq 'a') {
                        my $sav_pos = pos $s;
                        my $a_count = $s =~ s/a//g;
                        pos $s = $sav_pos - 1;  # -1 because got rid of the 'a'
                        if ($a_count > 2) {
			    require Carp;
                            Carp::carp(
                            qq 'The "a" flag may only appear a maximum of twice'
                            );
                        }
                        elsif ($a_count == 2) {
                            $_ = 'aa';
                        }
                    }
		    if ($on) {
			if ($seen_charset) {
			    require Carp;
                            if ($seen_charset ne $_) {
                                Carp::carp(
                                qq 'The "$seen_charset" and "$_" flags '
                                .qq 'are exclusive'
                                );
                            }
                            else {
                                Carp::carp(
                                qq 'The "$seen_charset" flag may not appear '
                                .qq 'twice'
                                );
                            }
			}
			$^H{reflags_charset} = $reflags{$_};
			$seen_charset = $_;
		    }
		    else {
			delete $^H{reflags_charset}
			 if  defined $^H{reflags_charset}
			  && $^H{reflags_charset} == $reflags{$_};
		    }
		} elsif (exists $reflags{$_}) {
		    $on
		      ? $reflags |= $reflags{$_}
		      : ($reflags &= ~$reflags{$_});
		} else {
		    require Carp;
		    Carp::carp(
		     qq'Unknown regular expression flag "$_"'
		    );
		    next ARG;
		}
	    }
	    ($^H{reflags} = $reflags or defined $^H{reflags_charset})
	     ? $^H |= $flags_hint
	     : ($^H &= ~$flags_hint);
a172 5
    use re '/ix';
    "FOO" =~ / foo /; # /ix implied
    no re '/x';
    "FOO" =~ /foo/; # just /i implied

a222 35
=head2 '/flags' mode

When C<use re '/flags'> is specified, the given flags are automatically
added to every regular expression till the end of the lexical scope.

C<no re '/flags'> will turn off the effect of C<use re '/flags'> for the
given flags.

For example, if you want all your regular expressions to have /msx on by
default, simply put

    use re '/msx';

at the top of your code.

The character set /adul flags cancel each other out. So, in this example,

    use re "/u";
    "ss" =~ /\xdf/;
    use re "/d";
    "ss" =~ /\xdf/;

the second C<use re> does an implicit C<no re '/u'>.

Turning on one of the character set flags with C<use re> takes precedence over the
C<locale> pragma and the 'unicode_strings' C<feature>, for regular
expressions. Turning off one of these flags when it is active reverts to
the behaviour specified by whatever other pragmata are in scope. For
example:

    use feature "unicode_strings";
    no re "/u"; # does nothing
    use re "/l";
    no re "/l"; # reverts to unicode_strings behaviour

d234 1
a234 1
See L<perldebug/"Debugging Regular Expressions"> for additional info.
d310 1
a310 1
Enable debugging the capture group storage during match. Warning,
d400 1
a400 1
PERL_MAGIC_qr structure so it cannot be fooled.
d418 1
a418 1
    if (regexp_pattern($ref) eq '(?^i:foo)')
@


1.1.1.10
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d7 1
a7 1
our $VERSION     = "0.23";
d238 1
a238 2
    /foo${pat}bar/;		   # won't fail (when not under -T
                                   # switch)
d245 1
a245 2
	/foo${pat}bar/;		   # disallowed (with or without -T
                                   # switch)
d254 1
a254 1
    /^(.*)$/s;			   # compile and run time
d257 1
a257 2
    use re 'debugcolor';	   # same as 'debug', but with colored
                                   # output
d260 3
a262 6
    use re qw(Debug All);          # Same as "use re 'debug'", but you
                                   # can use "Debug" with things other
                                   # than 'All'
    use re qw(Debug More);         # 'All' plus output more details
    no re qw(Debug ALL);           # Turn on (almost) all re debugging
                                   # in this scope
d268 2
a269 3
            scalar regexp_pattern($obj); # just as perl would stringify
    }                                    # it but no hassle with blessed
                                         # re's.
d287 2
a288 3
subexpressions that are derived from variable interpolation, rather than
appearing literally within the regexp.  That is normally disallowed, since
it is a
d411 1
a411 1
Enable debugging of start-point optimisations.
d445 1
a445 1
Enable enhanced optimisation debugging and start-point optimisations.
d478 1
a478 2
Enable all options at once except OFFSETS, OFFSETSDBG and BUFFERS.
(To get every single option without exception, use both ALL and EXTRA.)
d490 1
a490 1
Enable the options enabled by "All", plus STATE, TRIEC, and TRIEM.
d497 1
a497 1
lexically scoped, as are the other directives.  However they have both
@


1.1.1.11
log
@Import perl-5.20.1
@
text
@d7 1
a7 1
our $VERSION     = "0.26";
d573 1
a573 1
Perl uses both for its optimisations, preferring the longer, or, if they are
@


