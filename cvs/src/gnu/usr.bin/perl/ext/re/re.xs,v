head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.11
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.10.0.10
	OPENBSD_6_0_BASE:1.1.1.10
	OPENBSD_5_9:1.1.1.10.0.4
	OPENBSD_5_9_BASE:1.1.1.10
	OPENBSD_5_8:1.1.1.10.0.6
	OPENBSD_5_8_BASE:1.1.1.10
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.1.1.10.0.2
	OPENBSD_5_7_BASE:1.1.1.10
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.1.1.9.0.4
	OPENBSD_5_6_BASE:1.1.1.9
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.8.0.6
	OPENBSD_5_5_BASE:1.1.1.8
	OPENBSD_5_4:1.1.1.8.0.2
	OPENBSD_5_4_BASE:1.1.1.8
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.1.1.7.0.10
	OPENBSD_5_3_BASE:1.1.1.7
	OPENBSD_5_2:1.1.1.7.0.8
	OPENBSD_5_2_BASE:1.1.1.7
	OPENBSD_5_1_BASE:1.1.1.7
	OPENBSD_5_1:1.1.1.7.0.6
	OPENBSD_5_0:1.1.1.7.0.4
	OPENBSD_5_0_BASE:1.1.1.7
	OPENBSD_4_9:1.1.1.7.0.2
	OPENBSD_4_9_BASE:1.1.1.7
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.1.1.6.0.4
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.2
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.24
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.22
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.20
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.18
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.16
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.14
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.12
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.10
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.8
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.6
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.14;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	99.04.29.22.39.13;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.39.13;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.25;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.23.02;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.26;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.11.14;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.48.53;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.08.46;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.24.14.59.02;	author afresh1;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.11.17.20.53.06;	author afresh1;	state Exp;
branches;
next	1.1.1.11;
commitid	B31cAbBIXiCqnL97;

1.1.1.11
date	2017.08.14.13.46.12;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#if defined(PERL_EXT_RE_DEBUG) && !defined(DEBUGGING)
#  define DEBUGGING
#endif

#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "re_comp.h"

#undef dXSBOOTARGSXSAPIVERCHK
/* skip API version checking due to different interp struct size but,
   this hack is until #123007 is resolved */
#define dXSBOOTARGSXSAPIVERCHK dXSBOOTARGSNOVERCHK

START_EXTERN_C

extern REGEXP*	my_re_compile (pTHX_ SV * const pattern, const U32 pm_flags);
extern REGEXP*	my_re_op_compile (pTHX_ SV ** const patternp, int pat_count,
		    OP *expr, const regexp_engine* eng, REGEXP *VOL old_re,
		     bool *is_bare_re, U32 rx_flags, U32 pm_flags);

extern I32	my_regexec (pTHX_ REGEXP * const prog, char* stringarg, char* strend,
			    char* strbeg, SSize_t minend, SV* screamer,
			    void* data, U32 flags);

extern char*	my_re_intuit_start(pTHX_
                    REGEXP * const rx,
                    SV *sv,
                    const char * const strbeg,
                    char *strpos,
                    char *strend,
                    const U32 flags,
                    re_scream_pos_data *data);

extern SV*	my_re_intuit_string (pTHX_ REGEXP * const prog);

extern void	my_regfree (pTHX_ REGEXP * const r);

extern void	my_reg_numbered_buff_fetch(pTHX_ REGEXP * const rx, const I32 paren,
					   SV * const usesv);
extern void	my_reg_numbered_buff_store(pTHX_ REGEXP * const rx, const I32 paren,
					   SV const * const value);
extern I32	my_reg_numbered_buff_length(pTHX_ REGEXP * const rx,
					    const SV * const sv, const I32 paren);

extern SV*	my_reg_named_buff(pTHX_ REGEXP * const, SV * const, SV * const,
                              const U32);
extern SV*	my_reg_named_buff_iter(pTHX_ REGEXP * const rx,
                                   const SV * const lastkey, const U32 flags);

extern SV*      my_reg_qr_package(pTHX_ REGEXP * const rx);
#if defined(USE_ITHREADS)
extern void*	my_regdupe (pTHX_ REGEXP * const r, CLONE_PARAMS *param);
#endif

EXTERN_C const struct regexp_engine my_reg_engine;

END_EXTERN_C

const struct regexp_engine my_reg_engine = { 
        my_re_compile, 
        my_regexec, 
        my_re_intuit_start, 
        my_re_intuit_string, 
        my_regfree, 
        my_reg_numbered_buff_fetch,
        my_reg_numbered_buff_store,
        my_reg_numbered_buff_length,
        my_reg_named_buff,
        my_reg_named_buff_iter,
        my_reg_qr_package,
#if defined(USE_ITHREADS)
        my_regdupe,
#endif
        my_re_op_compile,
};

MODULE = re	PACKAGE = re

void
install()
    PPCODE:
        PL_colorset = 0;	/* Allow reinspection of ENV. */
        /* PL_debug |= DEBUG_r_FLAG; */
	XPUSHs(sv_2mortal(newSViv(PTR2IV(&my_reg_engine))));

void
regmust(sv)
    SV * sv
PROTOTYPE: $
PREINIT:
    REGEXP *re;
PPCODE:
{
    if ((re = SvRX(sv)) /* assign deliberate */
       /* only for re engines we know about */
       && (RX_ENGINE(re) == &my_reg_engine
           || RX_ENGINE(re) == &PL_core_reg_engine))
    {
        SV *an = &PL_sv_no;
        SV *fl = &PL_sv_no;
        if (RX_ANCHORED_SUBSTR(re)) {
            an = sv_2mortal(newSVsv(RX_ANCHORED_SUBSTR(re)));
        } else if (RX_ANCHORED_UTF8(re)) {
            an = sv_2mortal(newSVsv(RX_ANCHORED_UTF8(re)));
        }
        if (RX_FLOAT_SUBSTR(re)) {
            fl = sv_2mortal(newSVsv(RX_FLOAT_SUBSTR(re)));
        } else if (RX_FLOAT_UTF8(re)) {
            fl = sv_2mortal(newSVsv(RX_FLOAT_UTF8(re)));
        }
        EXTEND(SP, 2);
        PUSHs(an);
        PUSHs(fl);
        XSRETURN(2);
    }
    XSRETURN_UNDEF;
}

@


1.1
log
@Initial revision
@
text
@d1 1
a1 2
/* We need access to debugger hooks */
#ifndef DEBUGGING
d5 1
d9 1
d11 45
a55 4
extern regexp*	my_regcomp _((char* exp, char* xend, PMOP* pm));
extern I32	my_regexec _((regexp* prog, char* stringarg, char* strend,
			      char* strbeg, I32 minend, SV* screamer,
			      void* data, U32 flags));
d57 1
a57 1
static int oldfl;
d59 1
a59 1
#define R_DB 512
d61 17
a77 20
static void
deinstall(void)
{
    dTHR;
    PL_regexecp = &regexec_flags;
    PL_regcompp = &pregcomp;
    if (!oldfl)
	PL_debug &= ~R_DB;
}

static void
install(void)
{
    dTHR;
    PL_colorset = 0;			/* Allow reinspection of ENV. */
    PL_regexecp = &my_regexec;
    PL_regcompp = &my_regcomp;
    oldfl = PL_debug & R_DB;
    PL_debug |= R_DB;
}
d83 4
d89 32
a120 1
deinstall()
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@a5 1
#define PERL_NO_GET_CONTEXT
d10 4
a13 9
extern regexp*	my_regcomp (pTHX_ char* exp, char* xend, PMOP* pm);
extern I32	my_regexec (pTHX_ regexp* prog, char* stringarg, char* strend,
			    char* strbeg, I32 minend, SV* screamer,
			    void* data, U32 flags);
extern void	my_regfree (pTHX_ struct regexp* r);
extern char*	my_re_intuit_start (pTHX_ regexp *prog, SV *sv, char *strpos,
				    char *strend, U32 flags,
				    struct re_scream_pos_data_s *data);
extern SV*	my_re_intuit_string (pTHX_ regexp *prog);
d20 1
a20 1
deinstall(pTHX)
d23 2
a24 6
    PL_regexecp = Perl_regexec_flags;
    PL_regcompp = Perl_pregcomp;
    PL_regint_start = Perl_re_intuit_start;
    PL_regint_string = Perl_re_intuit_string;
    PL_regfree = Perl_pregfree;

d30 1
a30 1
install(pTHX)
a35 3
    PL_regint_start = &my_re_intuit_start;
    PL_regint_string = &my_re_intuit_string;
    PL_regfree = &my_regfree;
a43 2
  CODE:
    install(aTHX);
a46 2
  CODE:
    deinstall(aTHX);
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d28 1
d42 1
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d1 2
a2 1
#if defined(PERL_EXT_RE_DEBUG) && !defined(DEBUGGING)
a10 2
START_EXTERN_C

d21 1
a21 9
END_EXTERN_C

#define MY_CXT_KEY "re::_guts" XS_VERSION

typedef struct {
    int		x_oldflag;		/* debug flag */
} my_cxt_t;

START_MY_CXT
d23 1
a23 1
#define oldflag		(MY_CXT.x_oldflag)
d26 1
a26 1
uninstall(pTHX)
a27 1
    dMY_CXT;
d34 2
a35 2
    if (!oldflag)
	PL_debug &= ~DEBUG_r_FLAG;
a40 1
    dMY_CXT;
d47 2
a48 2
    oldflag = PL_debug & DEBUG_r_FLAG;
    PL_debug |= DEBUG_r_FLAG;
a52 6
BOOT:
{
   MY_CXT_INIT;
}


d59 1
a59 1
uninstall()
d61 1
a61 1
    uninstall(aTHX);
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@a8 2
#include "re_comp.h"

d12 2
a13 2
extern REGEXP*	my_re_compile (pTHX_ const SV * const pattern, const U32 pm_flags);
extern I32	my_regexec (pTHX_ REGEXP * const prog, char* stringarg, char* strend,
d16 3
a18 3

extern char*	my_re_intuit_start (pTHX_ REGEXP * const prog, SV *sv, char *strpos,
				    char *strend, const U32 flags,
d20 1
a20 1
extern SV*	my_re_intuit_string (pTHX_ REGEXP * const prog);
d22 1
a22 1
extern void	my_regfree (pTHX_ REGEXP * const r);
d24 1
a24 16
extern void	my_reg_numbered_buff_fetch(pTHX_ REGEXP * const rx, const I32 paren,
					   SV * const usesv);
extern void	my_reg_numbered_buff_store(pTHX_ REGEXP * const rx, const I32 paren,
					   SV const * const value);
extern I32	my_reg_numbered_buff_length(pTHX_ REGEXP * const rx,
					    const SV * const sv, const I32 paren);

extern SV*	my_reg_named_buff(pTHX_ REGEXP * const, SV * const, SV * const,
                              const U32);
extern SV*	my_reg_named_buff_iter(pTHX_ REGEXP * const rx,
                                   const SV * const lastkey, const U32 flags);

extern SV*      my_reg_qr_package(pTHX_ REGEXP * const rx);
#if defined(USE_ITHREADS)
extern void*	my_regdupe (pTHX_ REGEXP * const r, CLONE_PARAMS *param);
#endif
d26 3
a28 1
EXTERN_C const struct regexp_engine my_reg_engine;
d30 1
a30 1
END_EXTERN_C
d32 1
a32 16
const struct regexp_engine my_reg_engine = { 
        my_re_compile, 
        my_regexec, 
        my_re_intuit_start, 
        my_re_intuit_string, 
        my_regfree, 
        my_reg_numbered_buff_fetch,
        my_reg_numbered_buff_store,
        my_reg_numbered_buff_length,
        my_reg_named_buff,
        my_reg_named_buff_iter,
        my_reg_qr_package,
#if defined(USE_ITHREADS)
        my_regdupe 
#endif
};
d34 9
a42 1
MODULE = re	PACKAGE = re
d44 3
a46 7
void
install()
    PPCODE:
        PL_colorset = 0;	/* Allow reinspection of ENV. */
        /* PL_debug |= DEBUG_r_FLAG; */
	XPUSHs(sv_2mortal(newSViv(PTR2IV(&my_reg_engine))));
	
d48 2
a49 7
void
regexp_pattern(sv)
    SV * sv
PROTOTYPE: $
PREINIT:
    REGEXP *re;
PPCODE:
d51 9
a59 74
    /*
       Checks if a reference is a regex or not. If the parameter is
       not a ref, or is not the result of a qr// then returns false
       in scalar context and an empty list in list context.
       Otherwise in list context it returns the pattern and the
       modifiers, in scalar context it returns the pattern just as it
       would if the qr// was stringified normally, regardless as
       to the class of the variable and any strigification overloads
       on the object. 
    */

    if ((re = SvRX(sv))) /* assign deliberate */
    {
        /* Housten, we have a regex! */
        SV *pattern;
        STRLEN patlen = 0;
        STRLEN left = 0;
        char reflags[6];
        
        if ( GIMME_V == G_ARRAY ) {
            /*
               we are in list context so stringify
               the modifiers that apply. We ignore "negative
               modifiers" in this scenario. 
            */

            char *fptr = INT_PAT_MODS;
            char ch;
            U16 match_flags = (U16)((re->extflags & PMf_COMPILETIME) >> 12);

            while((ch = *fptr++)) {
                if(match_flags & 1) {
                    reflags[left++] = ch;
                }
                match_flags >>= 1;
            }

            pattern = sv_2mortal(newSVpvn(re->precomp,re->prelen));
            if (re->extflags & RXf_UTF8) SvUTF8_on(pattern);

            /* return the pattern and the modifiers */
            XPUSHs(pattern);
            XPUSHs(sv_2mortal(newSVpvn(reflags,left)));
            XSRETURN(2);
        } else {
            /* Scalar, so use the string that Perl would return */
            /* return the pattern in (?msix:..) format */
            pattern = sv_2mortal(newSVpvn(re->wrapped,re->wraplen));
            if (re->extflags & RXf_UTF8) 
                SvUTF8_on(pattern);
            XPUSHs(pattern);
            XSRETURN(1);
        }
    } else {
        /* It ain't a regexp folks */
        if ( GIMME_V == G_ARRAY ) {
            /* return the empty list */
            XSRETURN_UNDEF;
        } else {
            /* Because of the (?:..) wrapping involved in a 
               stringified pattern it is impossible to get a 
               result for a real regexp that would evaluate to 
               false. Therefore we can return PL_sv_no to signify
               that the object is not a regex, this means that one 
               can say
               
                 if (regex($might_be_a_regex) eq '(?:foo)') { }
               
               and not worry about undefined values.
            */
            XSRETURN_NO;
        }    
    }
    /* NOT-REACHED */
d62 1
d64 1
a64 7
void
regmust(sv)
    SV * sv
PROTOTYPE: $
PREINIT:
    REGEXP *re;
PPCODE:
d66 1
a66 19
    if ((re = SvRX(sv))) /* assign deliberate */
    {
        SV *an = &PL_sv_no;
        SV *fl = &PL_sv_no;
        if (re->anchored_substr) {
            an = newSVsv(re->anchored_substr);
        } else if (re->anchored_utf8) {
            an = newSVsv(re->anchored_utf8);
        }
        if (re->float_substr) {
            fl = newSVsv(re->float_substr);
        } else if (re->float_utf8) {
            fl = newSVsv(re->float_utf8);
        }
        XPUSHs(an);
        XPUSHs(fl);
        XSRETURN(2);
    }
    XSRETURN_UNDEF;
d69 10
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d72 86
d171 4
a174 4
        if (RX_ANCHORED_SUBSTR(re)) {
            an = newSVsv(RX_ANCHORED_SUBSTR(re));
        } else if (RX_ANCHORED_UTF8(re)) {
            an = newSVsv(RX_ANCHORED_UTF8(re));
d176 4
a179 4
        if (RX_FLOAT_SUBSTR(re)) {
            fl = newSVsv(RX_FLOAT_SUBSTR(re));
        } else if (RX_FLOAT_UTF8(re)) {
            fl = newSVsv(RX_FLOAT_UTF8(re));
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d14 1
a14 1
extern REGEXP*	my_re_compile (pTHX_ SV * const pattern, const U32 pm_flags);
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d81 1
a81 4
    if ((re = SvRX(sv)) /* assign deliberate */
       /* only for re engines we know about */
       && (RX_ENGINE(re) == &my_reg_engine
           || RX_ENGINE(re) == &PL_core_reg_engine))
d86 1
a86 1
            an = sv_2mortal(newSVsv(RX_ANCHORED_SUBSTR(re)));
d88 1
a88 1
            an = sv_2mortal(newSVsv(RX_ANCHORED_UTF8(re)));
d91 1
a91 1
            fl = sv_2mortal(newSVsv(RX_FLOAT_SUBSTR(re)));
d93 1
a93 1
            fl = sv_2mortal(newSVsv(RX_FLOAT_UTF8(re)));
@


1.1.1.9
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a14 4
extern REGEXP*	my_re_op_compile (pTHX_ SV ** const patternp, int pat_count,
		    OP *expr, const regexp_engine* eng, REGEXP *VOL old_re,
		     bool *is_bare_re, U32 rx_flags, U32 pm_flags);

d60 1
a60 1
        my_regdupe,
a61 1
        my_re_op_compile,
d98 2
a99 3
        EXTEND(SP, 2);
        PUSHs(an);
        PUSHs(fl);
@


1.1.1.10
log
@Import perl-5.20.1
@
text
@d20 1
a20 1
			    char* strbeg, SSize_t minend, SV* screamer,
d23 3
a25 9
extern char*	my_re_intuit_start(pTHX_
                    REGEXP * const rx,
                    SV *sv,
                    const char * const strbeg,
                    char *strpos,
                    char *strend,
                    const U32 flags,
                    re_scream_pos_data *data);

@


1.1.1.11
log
@Import perl-5.24.2
@
text
@a10 4
#undef dXSBOOTARGSXSAPIVERCHK
/* skip API version checking due to different interp struct size but,
   this hack is until #123007 is resolved */
#define dXSBOOTARGSXSAPIVERCHK dXSBOOTARGSNOVERCHK
@


