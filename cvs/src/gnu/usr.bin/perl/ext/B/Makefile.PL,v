head	1.2;
access;
symbols
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.11.0.10
	OPENBSD_6_0_BASE:1.1.1.11
	OPENBSD_5_9:1.1.1.11.0.4
	OPENBSD_5_9_BASE:1.1.1.11
	OPENBSD_5_8:1.1.1.11.0.6
	OPENBSD_5_8_BASE:1.1.1.11
	PERL_5_20_2:1.1.1.11
	OPENBSD_5_7:1.1.1.11.0.2
	OPENBSD_5_7_BASE:1.1.1.11
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.1.1.10.0.4
	OPENBSD_5_6_BASE:1.1.1.10
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.9.0.6
	OPENBSD_5_5_BASE:1.1.1.9
	OPENBSD_5_4:1.1.1.9.0.2
	OPENBSD_5_4_BASE:1.1.1.9
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.1.1.8.0.14
	OPENBSD_5_3_BASE:1.1.1.8
	OPENBSD_5_2:1.1.1.8.0.12
	OPENBSD_5_2_BASE:1.1.1.8
	OPENBSD_5_1_BASE:1.1.1.8
	OPENBSD_5_1:1.1.1.8.0.10
	OPENBSD_5_0:1.1.1.8.0.8
	OPENBSD_5_0_BASE:1.1.1.8
	OPENBSD_4_9:1.1.1.8.0.6
	OPENBSD_4_9_BASE:1.1.1.8
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.1.1.8.0.4
	OPENBSD_4_8_BASE:1.1.1.8
	OPENBSD_4_7:1.1.1.8.0.2
	OPENBSD_4_7_BASE:1.1.1.8
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.1.1.7.0.6
	OPENBSD_4_6_BASE:1.1.1.7
	OPENBSD_4_5:1.1.1.7.0.2
	OPENBSD_4_5_BASE:1.1.1.7
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.1.1.6.0.10
	OPENBSD_4_4_BASE:1.1.1.6
	OPENBSD_4_3:1.1.1.6.0.8
	OPENBSD_4_3_BASE:1.1.1.6
	OPENBSD_4_2:1.1.1.6.0.6
	OPENBSD_4_2_BASE:1.1.1.6
	OPENBSD_4_1:1.1.1.6.0.4
	OPENBSD_4_1_BASE:1.1.1.6
	OPENBSD_4_0:1.1.1.6.0.2
	OPENBSD_4_0_BASE:1.1.1.6
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.1.1.5.0.10
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.8
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.6
	OPENBSD_3_7_BASE:1.1.1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.1.1.5.0.4
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.11;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	99.04.29.22.38.38;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.38.38;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.01;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.38;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.53;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.40;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.47.51;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.13;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.11.11;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.08.42;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@use ExtUtils::MakeMaker;
use ExtUtils::Constant 0.23 'WriteConstants';
use File::Spec;
use strict;
use warnings;

my $core = grep { $_ eq 'PERL_CORE=1' } @@ARGV;

my $headerpath;
if ($core) {
    $headerpath = File::Spec->catdir(File::Spec->updir, File::Spec->updir);
} else {
	require Config;
    $headerpath = File::Spec->catdir($Config::Config{archlibexp}, "CORE");
}

my @@names = ({ name => 'HEf_SVKEY', macro => 1, type => "IV" },
             qw(SVTYPEMASK SVt_PVGV SVt_PVHV PAD_FAKELEX_ANON
                PAD_FAKELEX_MULTI SVpad_STATE SVpad_TYPED SVpad_OUR));

my @@depend;

# First element in each tuple is the file; second is a regex snippet
# giving the prefix to limit the names of symbols to define that come
# from that file.  If none, all symbols will be defined whose values
# match the pattern below.
foreach my $tuple (['cop.h'],
                   ['cv.h', 'CVf'],
                   ['gv.h', 'G[PV]f'],
                   ['op.h'],
                   ['opcode.h', 'OPp'],
                   ['op_reg_common.h','(?:(?:RXf_)?PMf_)'],
                   ['pad.h','PADNAMEt_'],
                   ['regexp.h','RXf_'],
                   ['sv.h', 'SV(?:[fps]|pad)_'],
                  ) {
    my $file = $tuple->[0];
    my $pfx = $tuple->[1] || '';
    my $path = File::Spec->catfile($headerpath, $file);
    push @@depend, $path;
    open my $fh, '<', $path or die "Cannot open $path: $!";
    while (<$fh>) {
	push @@names, $1 if (/ \#define \s+ ( $pfx \w+ ) \s+
            ( [()|\dx]+ [UuLl]{0,2}            # Parens, '|', digits, 'x',
                                               # followed by optional long,
                                               # unsigned qualifiers
            | 0x[0-9a-fA-F]+                   # hex values
            | \(? \d+ [UuLl]{0,2} \s* << .*?   # digits left shifted by anything
                                               # followed by optional
                                               # long, unsigned qualifiers
            ) \s* (?: $| \/ \* )               # ending at comment or $
        /x);
    }
    close $fh;
}

WriteMakefile(
    NAME	    => "B",
    VERSION_FROM    => "B.pm",
    realclean	    => {FILES=> 'const-c.inc const-xs.inc'},
    depend          => {'Makefile' => "@@depend"},
);

# Currently only SVt_PVGV and SVt_PVHV aren't macros, but everything we name
# should exist, so ensure that the C compile breaks if anything does not.
WriteConstants(
    PROXYSUBS => {push => 'EXPORT_OK'},
    NAME => 'B',
    NAMES => [map {ref $_ ? $_ : {name=>$_, macro=>1, type=>"UV"}} @@names],
    XS_SUBNAME => undef,
);
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
use Config;
d7 46
a52 9
my $e = $Config{'exe_ext'};
my $o = $Config{'obj_ext'};
my $exeout_flag = '-o ';
if ($^O eq 'MSWin32') {
    if ($Config{'cc'} =~ /^cl/i) {
	$exeout_flag = '-Fe';
    }
    elsif ($Config{'cc'} =~ /^bcc/i) {
	$exeout_flag = '-e';
d54 1
d58 4
a61 6
    NAME	=> "B",
    VERSION	=> "a5",
    MAN3PODS => {},
    clean	=> {
	FILES		=> "perl$e byteperl$e *$o B.c *~"
    }
d64 8
a71 22
sub MY::post_constants {
    "\nLIBS = $Config{libs}\n"
}

# Leave out doing byteperl for now. Probably should be built in the
# core directory or somewhere else rather than here
#sub MY::top_targets {
#    my $self = shift;
#    my $targets = $self->MM::top_targets();
#    $targets =~ s/^(all ::.*)$/$1 byteperl$e/m;
#    return <<"EOT" . $targets;

#
# byteperl is *not* a standard perl+XSUB executable. It's a special
# program for running standalone bytecode executables. It isn't an XSUB
# at the moment because a standlone Perl program needs to set up curpad
# which is overwritten on exit from an XSUB.
#
#byteperl$e : byteperl$o B$o \$(PERL_SRC)/byterun$o
#	\$(CC) ${exeout_flag}byteperl$e byteperl$o B$o byterun$o \$(LDFLAGS) \$(PERL_ARCHLIB)/CORE/$Config{libperl} \$(LIBS)
#EOT
#}
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d19 1
a19 2
    PL_FILES	=> { 'defsubs_h.PL' => 'defsubs.h' },
    MAN3PODS	=> {},
d21 1
a21 1
	FILES		=> "perl$e *$o B.c defsubs.h *~"
d23 1
a23 1
);   
d25 3
a27 1
package MY;
d29 7
a35 3
sub post_constants {
    "\nLIBS = $Config::Config{libs}\n"
}    
d37 10
a46 5
sub postamble {
'
B$(OBJ_EXT) : defsubs.h 
'
}
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@a2 1
use File::Spec;
d32 4
a35 15
sub upupfile {
    File::Spec->catfile(File::Spec->updir,
			File::Spec->updir, $_[0]);
}

sub MY::postamble {
    my $op_h   = upupfile('op.h');
    my $cop_h  = upupfile('cop.h');
    my $noecho = shift->{NOECHO};
"
B\$(OBJ_EXT) : defsubs.h              

defsubs.h :: $op_h $cop_h                     
	$noecho \$(NOOP)
" 
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d18 6
a23 6
    NAME	    => "B",
    VERSION_FROM    => "B.pm",
    PL_FILES	    => { 'defsubs_h.PL' => 'defsubs.h' },
    MAN3PODS	    => {},
    clean	    => {
	FILES	    => "perl$e *$o B.c defsubs.h *~"
d25 1
a25 1
);
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d31 1
a31 1
}
d43 1
a43 1
B\$(OBJ_EXT) : defsubs.h
d45 1
a45 1
defsubs.h :: $op_h $cop_h defsubs_h.PL
d47 1
a47 1
"
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d46 1
a46 1
	\$(PERL) -I\$(INST_ARCHLIB) -I\$(INST_LIB) -I\$(PERL_ARCHLIB) -I\$(PERL_LIB) defsubs_h.PL defsubs.h
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@a7 1
my $core = grep { $_ eq 'PERL_CORE=1' } @@ARGV;
d33 3
a35 11
sub headerfilefile {
    push @@makefileopts, MAN3PODS => {};
}

sub headerpath {
    if ($core) {
	return File::Spec->catdir(File::Spec->updir,
				   File::Spec->updir);
    } else {
	return File::Spec->catdir($Config::Config{archlibexp}, "CORE");
    }
d39 2
a40 2
    my $headerpath = headerpath();
    my @@headers = map { File::Spec->catfile($headerpath, $_) } qw(op.h cop.h);
a41 1

d45 2
a46 2
defsubs.h :: @@headers defsubs_h.PL
	\$(PERL) -I\$(INST_ARCHLIB) -I\$(INST_LIB) -I\$(PERL_ARCHLIB) -I\$(PERL_LIB) defsubs_h.PL defsubs.h $headerpath
a47 7
}

sub MY::processPL {
    my $text = shift->SUPER::processPL(@@_);
    # Append our extra parameter
    $text =~ s/^\t.*defsubs_h\.PL.*/$& . ' ' . headerpath()/me;
    $text;
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d22 1
d32 4
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d2 1
a2 1
use ExtUtils::Constant 0.23 'WriteConstants';
a3 2
use strict;
use warnings;
d5 3
d9 8
d21 4
a24 1
    realclean	    => {FILES=> 'const-c.inc const-xs.inc'},
d27 4
a30 6
my $headerpath;
if ($core) {
    $headerpath = File::Spec->catdir(File::Spec->updir, File::Spec->updir);
} else {
	require Config;
    $headerpath = File::Spec->catdir($Config::Config{archlibexp}, "CORE");
d33 7
a39 22
my @@names = qw(CVf_ANON CVf_CLONE CVf_CLONED CVf_CONST CVf_LVALUE CVf_METHOD
	       CVf_NODEBUG CVf_UNIQUE CVf_WEAKOUTSIDE
	       GVf_IMPORTED_AV GVf_IMPORTED_CV GVf_IMPORTED_HV GVf_IMPORTED_SV
	       HEf_SVKEY
	       SVTYPEMASK SVt_PVGV SVt_PVHV
	       SVf_FAKE SVf_IOK SVf_IVisUV SVf_NOK SVf_POK SVf_READONLY
	       SVf_ROK SVp_IOK SVp_NOK SVp_POK SVpad_OUR SVs_RMG SVs_SMG
	       PAD_FAKELEX_ANON PAD_FAKELEX_MULTI);

if ($] >= 5.009) {
    push @@names, 'CVf_ISXSUB';
} else {
    # Constant not present after 5.8.x
    push @@names, 'AVf_REAL';
    # This is only present in 5.10, but it's useful to B::Deparse to be able
    # to import a dummy value from B
    push @@names, {name=>"OPpPAD_STATE", default=>["IV", "0"]};
}  

if ($] < 5.011) {
    # Constant not present after 5.10.x
    push @@names, 'CVf_LOCKED';
d42 11
a52 20
# First element in each tuple is the file; second is a regex snippet
# giving the prefix to limit the names of symbols to define that come
# from that file.  If none, all symbols will be defined whose values
# match the pattern below.
foreach my $tuple (['op_reg_common.h','(?:(?:RXf_)?PMf_)'],
		   ['op.h'],
		   ['cop.h'],
		   ['regexp.h','RXf_']) {
    my $file = $tuple->[0];
    my $pfx = $tuple->[1] || '';
    my $path = File::Spec->catfile($headerpath, $file);
    open my $fh, '<', $path or die "Cannot open $path: $!";
    while (<$fh>) {
	push @@names, $1 if (/ \#define \s+ ( $pfx \w+ ) \s+
			      ( [()|\dx]+             # Parens, '|', digits, 'x'
			      | \(? \d+ \s* << .*?    # digits left shifted by anything
			      ) \s* (?: $| \/ \* )    # ending at comment or $
			    /x);
    }
    close $fh;
d55 6
a60 8
# Currently only SVt_PVGV and SVt_PVHV aren't macros, but everything we name
# should exist, so ensure that the C compile breaks if anything does not.
WriteConstants(
    PROXYSUBS => {push => 'EXPORT_OK'},
    NAME => 'B',
    NAMES => [map {ref $_ ? $_ : {name=>$_, macro=>1}} @@names],
    XS_SUBNAME => undef,
);
@


1.1.1.10
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d23 4
a26 1
my @@names = qw(HEf_SVKEY
d28 2
d32 14
d51 4
a54 8
foreach my $tuple (['cop.h'],
                   ['cv.h', 'CVf'],
                   ['gv.h', 'GVf'],
                   ['op.h'],
                   ['op_reg_common.h','(?:(?:RXf_)?PMf_)'],
                   ['regexp.h','RXf_'],
                   ['sv.h', 'SV(?:[fps]|pad)_'],
                  ) {
@


1.1.1.11
log
@Import perl-5.20.1
@
text
@d23 3
a25 2
my @@names = ({ name => 'HEf_SVKEY', macro => 1, type => "IV" },
             qw(SVTYPEMASK SVt_PVGV SVt_PVHV PAD_FAKELEX_ANON PAD_FAKELEX_MULTI));
d59 1
a59 1
    NAMES => [map {ref $_ ? $_ : {name=>$_, macro=>1, type=>"UV"}} @@names],
@


