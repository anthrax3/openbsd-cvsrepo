head	1.1;
branch	1.1.1;
access;
symbols
	PERL_5_24_2:1.1.1.9
	OPENBSD_6_1:1.1.1.9.0.18
	OPENBSD_6_1_BASE:1.1.1.9
	OPENBSD_6_0:1.1.1.9.0.16
	OPENBSD_6_0_BASE:1.1.1.9
	OPENBSD_5_9:1.1.1.9.0.10
	OPENBSD_5_9_BASE:1.1.1.9
	OPENBSD_5_8:1.1.1.9.0.12
	OPENBSD_5_8_BASE:1.1.1.9
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.1.1.9.0.4
	OPENBSD_5_7_BASE:1.1.1.9
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.1.1.9.0.8
	OPENBSD_5_6_BASE:1.1.1.9
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.9.0.6
	OPENBSD_5_5_BASE:1.1.1.9
	OPENBSD_5_4:1.1.1.9.0.2
	OPENBSD_5_4_BASE:1.1.1.9
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.1.1.8.0.18
	OPENBSD_5_3_BASE:1.1.1.8
	OPENBSD_5_2:1.1.1.8.0.16
	OPENBSD_5_2_BASE:1.1.1.8
	OPENBSD_5_1_BASE:1.1.1.8
	OPENBSD_5_1:1.1.1.8.0.14
	OPENBSD_5_0:1.1.1.8.0.12
	OPENBSD_5_0_BASE:1.1.1.8
	OPENBSD_4_9:1.1.1.8.0.10
	OPENBSD_4_9_BASE:1.1.1.8
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.1.1.8.0.8
	OPENBSD_4_8_BASE:1.1.1.8
	OPENBSD_4_7:1.1.1.8.0.4
	OPENBSD_4_7_BASE:1.1.1.8
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.1.1.8.0.6
	OPENBSD_4_6_BASE:1.1.1.8
	OPENBSD_4_5:1.1.1.8.0.2
	OPENBSD_4_5_BASE:1.1.1.8
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.1.1.7.0.10
	OPENBSD_4_4_BASE:1.1.1.7
	OPENBSD_4_3:1.1.1.7.0.8
	OPENBSD_4_3_BASE:1.1.1.7
	OPENBSD_4_2:1.1.1.7.0.6
	OPENBSD_4_2_BASE:1.1.1.7
	OPENBSD_4_1:1.1.1.7.0.4
	OPENBSD_4_1_BASE:1.1.1.7
	OPENBSD_4_0:1.1.1.7.0.2
	OPENBSD_4_0_BASE:1.1.1.7
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.1.1.6.0.6
	OPENBSD_3_9_BASE:1.1.1.6
	OPENBSD_3_8:1.1.1.6.0.4
	OPENBSD_3_8_BASE:1.1.1.6
	OPENBSD_3_7:1.1.1.6.0.2
	OPENBSD_3_7_BASE:1.1.1.6
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.1.1.5.0.4
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	99.04.29.22.38.38;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.38.38;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.02;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.40;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.53;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.41;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.47.53;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.13;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.08.43;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@package B::Terse;
use strict;
use B qw(peekop class walkoptree_slow walkoptree_exec
	 main_start main_root cstring svref_2object);
use B::Asmdata qw(@@specialsv_name);

sub terse {
    my ($order, $cvref) = @@_;
    my $cv = svref_2object($cvref);
    if ($order eq "exec") {
	walkoptree_exec($cv->START, "terse");
    } else {
	walkoptree_slow($cv->ROOT, "terse");
    }
}

sub compile {
    my $order = shift;
    my @@options = @@_;
    if (@@options) {
	return sub {
	    my $objname;
	    foreach $objname (@@options) {
		$objname = "main::$objname" unless $objname =~ /::/;
		eval "terse(\$order, \\&$objname)";
		die "terse($order, \\&$objname) failed: $@@" if $@@;
	    }
	}
    } else {
	if ($order eq "exec") {
	    return sub { walkoptree_exec(main_start, "terse") }
	} else {
	    return sub { walkoptree_slow(main_root, "terse") }
	}
    }
}

sub indent {
    my $level = shift;
    return "    " x $level;
}

sub B::OP::terse {
    my ($op, $level) = @@_;
    my $targ = $op->targ;
    $targ = ($targ > 0) ? " [$targ]" : "";
    print indent($level), peekop($op), $targ, "\n";
}

sub B::SVOP::terse {
    my ($op, $level) = @@_;
    print indent($level), peekop($op), "  ";
    $op->sv->terse(0);
}

sub B::GVOP::terse {
    my ($op, $level) = @@_;
    print indent($level), peekop($op), "  ";
    $op->gv->terse(0);
}

sub B::PMOP::terse {
    my ($op, $level) = @@_;
    my $precomp = $op->precomp;
    print indent($level), peekop($op),
	defined($precomp) ? " /$precomp/\n" : " (regexp not compiled)\n";

}

sub B::PVOP::terse {
    my ($op, $level) = @@_;
    print indent($level), peekop($op), " ", cstring($op->pv), "\n";
}

sub B::COP::terse {
    my ($op, $level) = @@_;
    my $label = $op->label;
    if ($label) {
	$label = " label ".cstring($label);
    }
    print indent($level), peekop($op), $label, "\n";
}

sub B::PV::terse {
    my ($sv, $level) = @@_;
    print indent($level);
    printf "%s (0x%lx) %s\n", class($sv), $$sv, cstring($sv->PV);
}

sub B::AV::terse {
    my ($sv, $level) = @@_;
    print indent($level);
    printf "%s (0x%lx) FILL %d\n", class($sv), $$sv, $sv->FILL;
}

sub B::GV::terse {
    my ($gv, $level) = @@_;
    my $stash = $gv->STASH->NAME;
    if ($stash eq "main") {
	$stash = "";
    } else {
	$stash = $stash . "::";
    }
    print indent($level);
    printf "%s (0x%lx) *%s%s\n", class($gv), $$gv, $stash, $gv->NAME;
}

sub B::IV::terse {
    my ($sv, $level) = @@_;
    print indent($level);
    printf "%s (0x%lx) %d\n", class($sv), $$sv, $sv->IV;
}

sub B::NV::terse {
    my ($sv, $level) = @@_;
    print indent($level);
    printf "%s (0x%lx) %s\n", class($sv), $$sv, $sv->NV;
}

sub B::NULL::terse {
    my ($sv, $level) = @@_;
    print indent($level);
    printf "%s (0x%lx)\n", class($sv), $$sv;
}
    
sub B::SPECIAL::terse {
    my ($sv, $level) = @@_;
    print indent($level);
    printf "%s #%d %s\n", class($sv), $$sv, $specialsv_name[$$sv];
}

1;

__END__

=head1 NAME

B::Terse - Walk Perl syntax tree, printing terse info about ops

=head1 SYNOPSIS

	perl -MO=Terse[,OPTIONS] foo.pl

=head1 DESCRIPTION

See F<ext/B/README>.

=head1 AUTHOR

Malcolm Beattie, C<mbeattie@@sable.ox.ac.uk>

=cut
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@a19 1
    B::clearsym();
d56 1
a56 1
sub B::PADOP::terse {
d58 2
a59 1
    print indent($level), peekop($op), "  ", $op->padix, "\n";
d81 1
a81 1
    print indent($level), peekop($op), $label || "", "\n";
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d3 2
a4 2
use B qw(peekop class walkoptree walkoptree_exec walkoptree_slow
	 main_start main_root cstring svref_2object SVf_IVisUV);
d18 1
a18 1
    my $order = @@_ ? shift : "";
d40 1
a40 1
    my $level = @@_ ? shift : 0;
d105 1
a105 1
    printf "%s (0x%lx) *%s%s\n", class($gv), $$gv, $stash, $gv->SAFENAME;
d111 1
a111 2
    my $v = $sv->FLAGS & SVf_IVisUV ? "%u" : "%d";
    printf "%s (0x%lx) $v\n", class($sv), $$sv, $sv->int_value;
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a1 3

our $VERSION = '1.00';

a118 21
}

sub B::RV::terse {
    my ($rv, $level) = @@_;
    print indent($level);
    printf "%s (0x%lx) %s\n", class($rv), $$rv, printref($rv);
}

sub printref {
    my $rv = shift;
    my $rcl = class($rv->RV);
    if ($rcl eq 'PV') {
	return "\\" . cstring($rv->RV->$rcl);
    } elsif ($rcl eq 'NV') {
	return "\\" . $rv->RV->$rcl;
    } elsif ($rcl eq 'IV') {
	return sprintf "\\%" . ($rv->RV->FLAGS & SVf_IVisUV ? "u" : "d"),
	    $rv->RV->int_value;
    } elsif ($rcl eq 'RV') {
	return "\\" . printref($rv->RV);
    }
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.02';
d6 2
a7 1
use B qw(class);
a8 2
use B::Concise qw(concise_subref set_style_standard);
use Carp;
d11 2
a12 2
    my ($order, $subref) = @@_;
    set_style_standard("terse");
d14 1
a14 1
	concise_subref('exec', $subref);
d16 1
a16 1
	concise_subref('basic', $subref);
a17 1

d21 19
a39 5
    my @@args = @@_;
    my $order = @@args ? shift(@@args) : "";
    $order = "-exec" if $order eq "exec";
    unshift @@args, $order if $order ne "";
    B::Concise::compile("-terse", @@args);
a46 2
# Don't use this, at least on OPs in subroutines: it has no way of
# getting to the pad, and will give wrong answers or crash.
d48 4
a51 2
    carp "B::OP::terse is deprecated; use B::Concise instead";
    B::Concise::b_terse(@@_);
d54 89
a142 6
sub B::SV::terse {
    my($sv, $level) = (@@_, 0);
    my %info;
    B::Concise::concise_sv($sv, \%info);
    my $s = B::Concise::fmt_line(\%info, "#svclass~(?((#svaddr))?)~#svval", 0);
    print indent($level), $s, "\n";
d150 1
a150 1

d171 1
a171 14
This version of B::Terse is really just a wrapper that calls B::Concise
with the B<-terse> option. It is provided for compatibility with old scripts
(and habits) but using B::Concise directly is now recommended instead.

For compatiblilty with the old B::Terse, this module also adds a
method named C<terse> to B::OP and B::SV objects. The B::SV method is
largely compatible with the old one, though authors of new software
might be advised to choose a more user-friendly output format. The
B::OP C<terse> method, however, doesn't work well. Since B::Terse was
first written, much more information in OPs has migrated to the
scratchpad datastructure, but the C<terse> interface doesn't have any
way of getting to the correct pad. As a kludge, the new version will
always use the pad for the main program, but for OPs in subroutines
this will give the wrong answer or crash.
d175 1
a175 3
The original version of B::Terse was written by Malcolm Beattie,
E<lt>mbeattie@@sable.ox.ac.ukE<gt>. This wrapper was written by Stephen
McCamant, E<lt>smcc@@MIT.EDUE<gt>.
@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@d19 1
d31 1
a31 1
    my ($level) = @@_ ? shift : 0;
d46 2
a47 6
    my $s = indent($level)
	. B::Concise::fmt_line(\%info, $sv,
				 "#svclass~(?((#svaddr))?)~#svval", 0);
    chomp $s;
    print "$s\n" unless defined wantarray;
    $s;
d52 2
a53 3
    my $s = indent($level) . sprintf "%s (0x%lx)", class($sv), $$sv;
    print "$s\n" unless defined wantarray;
    $s;
d58 2
a59 4
    my $s = indent($level)
	. sprintf( "%s #%d %s", class($sv), $$sv, $specialsv_name[$$sv]);
    print "$s\n" unless defined wantarray;
    $s;
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
our $VERSION = '1.03_01';
d54 1
a54 1
    my ($sv, $level) = (@@_, 0);
d61 1
a61 1
    my ($sv, $level) = (@@_, 0);
d86 1
a86 1
For compatibility with the old B::Terse, this module also adds a
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.05';
d6 2
a7 1
use B qw(class @@specialsv_name);
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d3 1
a3 1
our $VERSION = '1.06';
d81 1
a81 9
This module prints the contents of the parse tree, but without as much
information as L<B::Debug>.  For comparison, C<print "Hello, world.">
produced 96 lines of output from B::Debug, but only 6 from B::Terse.

This module is useful for people who are writing their own back end,
or who are learning about the Perl internals.  It's not useful to the
average programmer.

This version of B::Terse is really just a wrapper that calls L<B::Concise>
@


