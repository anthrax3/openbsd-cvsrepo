head	1.2;
access;
symbols
	OPENBSD_4_4:1.1.1.7.0.10
	OPENBSD_4_4_BASE:1.1.1.7
	OPENBSD_4_3:1.1.1.7.0.8
	OPENBSD_4_3_BASE:1.1.1.7
	OPENBSD_4_2:1.1.1.7.0.6
	OPENBSD_4_2_BASE:1.1.1.7
	OPENBSD_4_1:1.1.1.7.0.4
	OPENBSD_4_1_BASE:1.1.1.7
	OPENBSD_4_0:1.1.1.7.0.2
	OPENBSD_4_0_BASE:1.1.1.7
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.1.1.6.0.6
	OPENBSD_3_9_BASE:1.1.1.6
	OPENBSD_3_8:1.1.1.6.0.4
	OPENBSD_3_8_BASE:1.1.1.6
	OPENBSD_3_7:1.1.1.6.0.2
	OPENBSD_3_7_BASE:1.1.1.6
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.1.1.5.0.4
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2008.09.29.17.36.01;	author millert;	state dead;
branches;
next	1.1;

1.1
date	99.04.29.22.38.38;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.38.38;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.02;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.39;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.53;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.41;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.16.42;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.47.53;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@#      C.pm
#
#      Copyright (c) 1996, 1997, 1998 Malcolm Beattie
#
#      You may distribute under the terms of either the GNU General Public
#      License or the Artistic License, as specified in the README file.
#
package B::C;
use Exporter ();
@@ISA = qw(Exporter);
@@EXPORT_OK = qw(output_all output_boilerplate output_main
		init_sections set_callback save_unused_subs objsym);

use B qw(minus_c sv_undef walkoptree walksymtable main_root main_start peekop
	 class cstring cchar svref_2object compile_stats comppadlist hash
	 threadsv_names main_cv init_av);
use B::Asmdata qw(@@specialsv_name);

use FileHandle;
use Carp;
use strict;

my $hv_index = 0;
my $gv_index = 0;
my $re_index = 0;
my $pv_index = 0;
my $anonsub_index = 0;

my %symtable;
my $warn_undefined_syms;
my $verbose;
my @@unused_sub_packages;
my $nullop_count;
my $pv_copy_on_grow;
my ($debug_cops, $debug_av, $debug_cv, $debug_mg);

my @@threadsv_names;
BEGIN {
    @@threadsv_names = threadsv_names();
}

# Code sections
my ($init, $decl, $symsect, $binopsect, $condopsect, $copsect, $cvopsect,
    $gvopsect, $listopsect, $logopsect, $loopsect, $opsect, $pmopsect,
    $pvopsect, $svopsect, $unopsect, $svsect, $xpvsect, $xpvavsect,
    $xpvhvsect, $xpvcvsect, $xpvivsect, $xpvnvsect, $xpvmgsect, $xpvlvsect,
    $xrvsect, $xpvbmsect, $xpviosect, $bootstrap);

sub walk_and_save_optree;
my $saveoptree_callback = \&walk_and_save_optree;
sub set_callback { $saveoptree_callback = shift }
sub saveoptree { &$saveoptree_callback(@@_) }

sub walk_and_save_optree {
    my ($name, $root, $start) = @@_;
    walkoptree($root, "save");
    return objsym($start);
}

# Current workaround/fix for op_free() trying to free statically
# defined OPs is to set op_seq = -1 and check for that in op_free().
# Instead of hardwiring -1 in place of $op->seq, we use $op_seq
# so that it can be changed back easily if necessary. In fact, to
# stop compilers from moaning about a U16 being initialised with an
# uncast -1 (the printf format is %d so we can't tweak it), we have
# to "know" that op_seq is a U16 and use 65535. Ugh.
my $op_seq = 65535;

sub AVf_REAL () { 1 }

# XXX This shouldn't really be hardcoded here but it saves
# looking up the name of every BASEOP in B::OP
sub OP_THREADSV () { 345 }

sub savesym {
    my ($obj, $value) = @@_;
    my $sym = sprintf("s\\_%x", $$obj);
    $symtable{$sym} = $value;
}

sub objsym {
    my $obj = shift;
    return $symtable{sprintf("s\\_%x", $$obj)};
}

sub getsym {
    my $sym = shift;
    my $value;

    return 0 if $sym eq "sym_0";	# special case
    $value = $symtable{$sym};
    if (defined($value)) {
	return $value;
    } else {
	warn "warning: undefined symbol $sym\n" if $warn_undefined_syms;
	return "UNUSED";
    }
}

sub savepv {
    my $pv = shift;
    my $pvsym = 0;
    my $pvmax = 0;
    if ($pv_copy_on_grow) {
	my $cstring = cstring($pv);
	if ($cstring ne "0") { # sic
	    $pvsym = sprintf("pv%d", $pv_index++);
	    $decl->add(sprintf("static char %s[] = %s;", $pvsym, $cstring));
	}
    } else {
	$pvmax = length($pv) + 1;
    }
    return ($pvsym, $pvmax);
}

sub B::OP::save {
    my ($op, $level) = @@_;
    my $type = $op->type;
    $nullop_count++ unless $type;
    if ($type == OP_THREADSV) {
	# saves looking up ppaddr but it's a bit naughty to hard code this
	$init->add(sprintf("(void)find_threadsv(%s);",
			   cstring($threadsv_names[$op->targ])));
    }
    $opsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x",
			 ${$op->next}, ${$op->sibling}, $op->ppaddr, $op->targ,
			 $type, $op_seq, $op->flags, $op->private));
    savesym($op, sprintf("&op_list[%d]", $opsect->index));
}

sub B::FAKEOP::new {
    my ($class, %objdata) = @@_;
    bless \%objdata, $class;
}

sub B::FAKEOP::save {
    my ($op, $level) = @@_;
    $opsect->add(sprintf("%s, %s, %s, %u, %u, %u, 0x%x, 0x%x",
			 $op->next, $op->sibling, $op->ppaddr, $op->targ,
			 $op->type, $op_seq, $op->flags, $op->private));
    return sprintf("&op_list[%d]", $opsect->index);
}

sub B::FAKEOP::next { $_[0]->{"next"} || 0 }
sub B::FAKEOP::type { $_[0]->{type} || 0}
sub B::FAKEOP::sibling { $_[0]->{sibling} || 0 }
sub B::FAKEOP::ppaddr { $_[0]->{ppaddr} || 0 }
sub B::FAKEOP::targ { $_[0]->{targ} || 0 }
sub B::FAKEOP::flags { $_[0]->{flags} || 0 }
sub B::FAKEOP::private { $_[0]->{private} || 0 }

sub B::UNOP::save {
    my ($op, $level) = @@_;
    $unopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, s\\_%x",
			   ${$op->next}, ${$op->sibling}, $op->ppaddr,
			   $op->targ, $op->type, $op_seq, $op->flags,
			   $op->private, ${$op->first}));
    savesym($op, sprintf("(OP*)&unop_list[%d]", $unopsect->index));
}

sub B::BINOP::save {
    my ($op, $level) = @@_;
    $binopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x",
			    ${$op->next}, ${$op->sibling}, $op->ppaddr,
			    $op->targ, $op->type, $op_seq, $op->flags,
			    $op->private, ${$op->first}, ${$op->last}));
    savesym($op, sprintf("(OP*)&binop_list[%d]", $binopsect->index));
}

sub B::LISTOP::save {
    my ($op, $level) = @@_;
    $listopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x, %u",
			     ${$op->next}, ${$op->sibling}, $op->ppaddr,
			     $op->targ, $op->type, $op_seq, $op->flags,
			     $op->private, ${$op->first}, ${$op->last},
			     $op->children));
    savesym($op, sprintf("(OP*)&listop_list[%d]", $listopsect->index));
}

sub B::LOGOP::save {
    my ($op, $level) = @@_;
    $logopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x",
			    ${$op->next}, ${$op->sibling}, $op->ppaddr,
			    $op->targ, $op->type, $op_seq, $op->flags,
			    $op->private, ${$op->first}, ${$op->other}));
    savesym($op, sprintf("(OP*)&logop_list[%d]", $logopsect->index));
}

sub B::CONDOP::save {
    my ($op, $level) = @@_;
    $condopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x, s\\_%x",
			     ${$op->next}, ${$op->sibling}, $op->ppaddr,
			     $op->targ, $op->type, $op_seq, $op->flags,
			     $op->private, ${$op->first}, ${$op->true},
			     ${$op->false}));
    savesym($op, sprintf("(OP*)&condop_list[%d]", $condopsect->index));
}

sub B::LOOP::save {
    my ($op, $level) = @@_;
    #warn sprintf("LOOP: redoop %s, nextop %s, lastop %s\n",
    #		 peekop($op->redoop), peekop($op->nextop),
    #		 peekop($op->lastop)); # debug
    $loopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x, %u, s\\_%x, s\\_%x, s\\_%x",
			   ${$op->next}, ${$op->sibling}, $op->ppaddr,
			   $op->targ, $op->type, $op_seq, $op->flags,
			   $op->private, ${$op->first}, ${$op->last},
			   $op->children, ${$op->redoop}, ${$op->nextop},
			   ${$op->lastop}));
    savesym($op, sprintf("(OP*)&loop_list[%d]", $loopsect->index));
}

sub B::PVOP::save {
    my ($op, $level) = @@_;
    $pvopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, %s",
			   ${$op->next}, ${$op->sibling}, $op->ppaddr,
			   $op->targ, $op->type, $op_seq, $op->flags,
			   $op->private, cstring($op->pv)));
    savesym($op, sprintf("(OP*)&pvop_list[%d]", $pvopsect->index));
}

sub B::SVOP::save {
    my ($op, $level) = @@_;
    my $svsym = $op->sv->save;
    $svopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, %s",
			   ${$op->next}, ${$op->sibling}, $op->ppaddr,
			   $op->targ, $op->type, $op_seq, $op->flags,
			   $op->private, "(SV*)$svsym"));
    savesym($op, sprintf("(OP*)&svop_list[%d]", $svopsect->index));
}

sub B::GVOP::save {
    my ($op, $level) = @@_;
    my $gvsym = $op->gv->save;
    $gvopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, Nullgv",
			   ${$op->next}, ${$op->sibling}, $op->ppaddr,
			   $op->targ, $op->type, $op_seq, $op->flags,
			   $op->private));
    $init->add(sprintf("gvop_list[%d].op_gv = %s;", $gvopsect->index, $gvsym));
    savesym($op, sprintf("(OP*)&gvop_list[%d]", $gvopsect->index));
}

sub B::COP::save {
    my ($op, $level) = @@_;
    my $gvsym = $op->filegv->save;
    my $stashsym = $op->stash->save;
    warn sprintf("COP: line %d file %s\n", $op->line, $op->filegv->SV->PV)
	if $debug_cops;
    $copsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, %s, Nullhv, Nullgv, %u, %d, %u",
			  ${$op->next}, ${$op->sibling}, $op->ppaddr,
			  $op->targ, $op->type, $op_seq, $op->flags,
			  $op->private, cstring($op->label), $op->cop_seq,
			  $op->arybase, $op->line));
    my $copix = $copsect->index;
    $init->add(sprintf("cop_list[%d].cop_filegv = %s;", $copix, $gvsym),
	       sprintf("cop_list[%d].cop_stash = %s;", $copix, $stashsym));
    savesym($op, "(OP*)&cop_list[$copix]");
}

sub B::PMOP::save {
    my ($op, $level) = @@_;
    my $replroot = $op->pmreplroot;
    my $replstart = $op->pmreplstart;
    my $replrootfield = sprintf("s\\_%x", $$replroot);
    my $replstartfield = sprintf("s\\_%x", $$replstart);
    my $gvsym;
    my $ppaddr = $op->ppaddr;
    if ($$replroot) {
	# OP_PUSHRE (a mutated version of OP_MATCH for the regexp
	# argument to a split) stores a GV in op_pmreplroot instead
	# of a substitution syntax tree. We don't want to walk that...
	if ($ppaddr eq "pp_pushre") {
	    $gvsym = $replroot->save;
#	    warn "PMOP::save saving a pp_pushre with GV $gvsym\n"; # debug
	    $replrootfield = 0;
	} else {
	    $replstartfield = saveoptree("*ignore*", $replroot, $replstart);
	}
    }
    # pmnext handling is broken in perl itself, I think. Bad op_pmnext
    # fields aren't noticed in perl's runtime (unless you try reset) but we
    # segfault when trying to dereference it to find op->op_pmnext->op_type
    $pmopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x, %u, %s, %s, 0, 0, 0x%x, 0x%x",
			   ${$op->next}, ${$op->sibling}, $ppaddr, $op->targ,
			   $op->type, $op_seq, $op->flags, $op->private,
			   ${$op->first}, ${$op->last}, $op->children,
			   $replrootfield, $replstartfield,
			   $op->pmflags, $op->pmpermflags,));
    my $pm = sprintf("pmop_list[%d]", $pmopsect->index);
    my $re = $op->precomp;
    if (defined($re)) {
	my $resym = sprintf("re%d", $re_index++);
	$decl->add(sprintf("static char *$resym = %s;", cstring($re)));
	$init->add(sprintf("$pm.op_pmregexp = pregcomp($resym, $resym + %u, &$pm);",
			   length($re)));
    }
    if ($gvsym) {
	$init->add("$pm.op_pmreplroot = (OP*)$gvsym;");
    }
    savesym($op, sprintf("(OP*)&pmop_list[%d]", $pmopsect->index));
}

sub B::SPECIAL::save {
    my ($sv) = @@_;
    # special case: $$sv is not the address but an index into specialsv_list
#   warn "SPECIAL::save specialsv $$sv\n"; # debug
    my $sym = $specialsv_name[$$sv];
    if (!defined($sym)) {
	confess "unknown specialsv index $$sv passed to B::SPECIAL::save";
    }
    return $sym;
}

sub B::OBJECT::save {}

sub B::NULL::save {
    my ($sv) = @@_;
    my $sym = objsym($sv);
    return $sym if defined $sym;
#   warn "Saving SVt_NULL SV\n"; # debug
    # debug
    #if ($$sv == 0) {
    #	warn "NULL::save for sv = 0 called from @@{[(caller(1))[3]]}\n";
    #}
    $svsect->add(sprintf("0, %u, 0x%x", $sv->REFCNT + 1, $sv->FLAGS));
    return savesym($sv, sprintf("&sv_list[%d]", $svsect->index));
}

sub B::IV::save {
    my ($sv) = @@_;
    my $sym = objsym($sv);
    return $sym if defined $sym;
    $xpvivsect->add(sprintf("0, 0, 0, %d", $sv->IVX));
    $svsect->add(sprintf("&xpviv_list[%d], %lu, 0x%x",
			 $xpvivsect->index, $sv->REFCNT + 1, $sv->FLAGS));
    return savesym($sv, sprintf("&sv_list[%d]", $svsect->index));
}

sub B::NV::save {
    my ($sv) = @@_;
    my $sym = objsym($sv);
    return $sym if defined $sym;
    $xpvnvsect->add(sprintf("0, 0, 0, %d, %s", $sv->IVX, $sv->NVX));
    $svsect->add(sprintf("&xpvnv_list[%d], %lu, 0x%x",
			 $xpvnvsect->index, $sv->REFCNT + 1, $sv->FLAGS));
    return savesym($sv, sprintf("&sv_list[%d]", $svsect->index));
}

sub B::PVLV::save {
    my ($sv) = @@_;
    my $sym = objsym($sv);
    return $sym if defined $sym;
    my $pv = $sv->PV;
    my $len = length($pv);
    my ($pvsym, $pvmax) = savepv($pv);
    my ($lvtarg, $lvtarg_sym);
    $xpvlvsect->add(sprintf("%s, %u, %u, %d, %g, 0, 0, %u, %u, 0, %s",
			    $pvsym, $len, $pvmax, $sv->IVX, $sv->NVX, 
			    $sv->TARGOFF, $sv->TARGLEN, cchar($sv->TYPE)));
    $svsect->add(sprintf("&xpvlv_list[%d], %lu, 0x%x",
			 $xpvlvsect->index, $sv->REFCNT + 1, $sv->FLAGS));
    if (!$pv_copy_on_grow) {
	$init->add(sprintf("xpvlv_list[%d].xpv_pv = savepvn(%s, %u);",
			   $xpvlvsect->index, cstring($pv), $len));
    }
    $sv->save_magic;
    return savesym($sv, sprintf("&sv_list[%d]", $svsect->index));
}

sub B::PVIV::save {
    my ($sv) = @@_;
    my $sym = objsym($sv);
    return $sym if defined $sym;
    my $pv = $sv->PV;
    my $len = length($pv);
    my ($pvsym, $pvmax) = savepv($pv);
    $xpvivsect->add(sprintf("%s, %u, %u, %d", $pvsym, $len, $pvmax, $sv->IVX));
    $svsect->add(sprintf("&xpviv_list[%d], %u, 0x%x",
			 $xpvivsect->index, $sv->REFCNT + 1, $sv->FLAGS));
    if (!$pv_copy_on_grow) {
	$init->add(sprintf("xpviv_list[%d].xpv_pv = savepvn(%s, %u);",
			   $xpvivsect->index, cstring($pv), $len));
    }
    return savesym($sv, sprintf("&sv_list[%d]", $svsect->index));
}

sub B::PVNV::save {
    my ($sv) = @@_;
    my $sym = objsym($sv);
    return $sym if defined $sym;
    my $pv = $sv->PV;
    my $len = length($pv);
    my ($pvsym, $pvmax) = savepv($pv);
    $xpvnvsect->add(sprintf("%s, %u, %u, %d, %s",
			    $pvsym, $len, $pvmax, $sv->IVX, $sv->NVX));
    $svsect->add(sprintf("&xpvnv_list[%d], %lu, 0x%x",
			 $xpvnvsect->index, $sv->REFCNT + 1, $sv->FLAGS));
    if (!$pv_copy_on_grow) {
	$init->add(sprintf("xpvnv_list[%d].xpv_pv = savepvn(%s,%u);",
			   $xpvnvsect->index, cstring($pv), $len));
    }
    return savesym($sv, sprintf("&sv_list[%d]", $svsect->index));
}

sub B::BM::save {
    my ($sv) = @@_;
    my $sym = objsym($sv);
    return $sym if defined $sym;
    my $pv = $sv->PV . "\0" . $sv->TABLE;
    my $len = length($pv);
    $xpvbmsect->add(sprintf("0, %u, %u, %d, %s, 0, 0, %d, %u, 0x%x",
			    $len, $len + 258, $sv->IVX, $sv->NVX,
			    $sv->USEFUL, $sv->PREVIOUS, $sv->RARE));
    $svsect->add(sprintf("&xpvbm_list[%d], %lu, 0x%x",
			 $xpvbmsect->index, $sv->REFCNT + 1, $sv->FLAGS));
    $sv->save_magic;
    $init->add(sprintf("xpvbm_list[%d].xpv_pv = savepvn(%s, %u);",
		       $xpvbmsect->index, cstring($pv), $len),
	       sprintf("xpvbm_list[%d].xpv_cur = %u;",
		       $xpvbmsect->index, $len - 257));
    return savesym($sv, sprintf("&sv_list[%d]", $svsect->index));
}

sub B::PV::save {
    my ($sv) = @@_;
    my $sym = objsym($sv);
    return $sym if defined $sym;
    my $pv = $sv->PV;
    my $len = length($pv);
    my ($pvsym, $pvmax) = savepv($pv);
    $xpvsect->add(sprintf("%s, %u, %u", $pvsym, $len, $pvmax));
    $svsect->add(sprintf("&xpv_list[%d], %lu, 0x%x",
			 $xpvsect->index, $sv->REFCNT + 1, $sv->FLAGS));
    if (!$pv_copy_on_grow) {
	$init->add(sprintf("xpv_list[%d].xpv_pv = savepvn(%s, %u);",
			   $xpvsect->index, cstring($pv), $len));
    }
    return savesym($sv, sprintf("&sv_list[%d]", $svsect->index));
}

sub B::PVMG::save {
    my ($sv) = @@_;
    my $sym = objsym($sv);
    return $sym if defined $sym;
    my $pv = $sv->PV;
    my $len = length($pv);
    my ($pvsym, $pvmax) = savepv($pv);
    $xpvmgsect->add(sprintf("%s, %u, %u, %d, %s, 0, 0",
			    $pvsym, $len, $pvmax, $sv->IVX, $sv->NVX));
    $svsect->add(sprintf("&xpvmg_list[%d], %lu, 0x%x",
			 $xpvmgsect->index, $sv->REFCNT + 1, $sv->FLAGS));
    if (!$pv_copy_on_grow) {
	$init->add(sprintf("xpvmg_list[%d].xpv_pv = savepvn(%s, %u);",
			   $xpvmgsect->index, cstring($pv), $len));
    }
    $sym = savesym($sv, sprintf("&sv_list[%d]", $svsect->index));
    $sv->save_magic;
    return $sym;
}

sub B::PVMG::save_magic {
    my ($sv) = @@_;
    #warn sprintf("saving magic for %s (0x%x)\n", class($sv), $$sv); # debug
    my $stash = $sv->SvSTASH;
    if ($$stash) {
	warn sprintf("xmg_stash = %s (0x%x)\n", $stash->NAME, $$stash)
	    if $debug_mg;
	# XXX Hope stash is already going to be saved.
	$init->add(sprintf("SvSTASH(s\\_%x) = s\\_%x;", $$sv, $$stash));
    }
    my @@mgchain = $sv->MAGIC;
    my ($mg, $type, $obj, $ptr);
    foreach $mg (@@mgchain) {
	$type = $mg->TYPE;
	$obj = $mg->OBJ;
	$ptr = $mg->PTR;
	my $len = defined($ptr) ? length($ptr) : 0;
	if ($debug_mg) {
	    warn sprintf("magic %s (0x%x), obj %s (0x%x), type %s, ptr %s\n",
			 class($sv), $$sv, class($obj), $$obj,
			 cchar($type), cstring($ptr));
	}
	$init->add(sprintf("sv_magic((SV*)s\\_%x, (SV*)s\\_%x, %s, %s, %d);",
			   $$sv, $$obj, cchar($type),cstring($ptr),$len));
    }
}

sub B::RV::save {
    my ($sv) = @@_;
    my $sym = objsym($sv);
    return $sym if defined $sym;
    $xrvsect->add($sv->RV->save);
    $svsect->add(sprintf("&xrv_list[%d], %lu, 0x%x",
			 $xrvsect->index, $sv->REFCNT + 1, $sv->FLAGS));
    return savesym($sv, sprintf("&sv_list[%d]", $svsect->index));
}

sub try_autoload {
    my ($cvstashname, $cvname) = @@_;
    warn sprintf("No definition for sub %s::%s\n", $cvstashname, $cvname);
    # Handle AutoLoader classes explicitly. Any more general AUTOLOAD
    # use should be handled by the class itself.
    no strict 'refs';
    my $isa = \@@{"$cvstashname\::ISA"};
    if (grep($_ eq "AutoLoader", @@$isa)) {
	warn "Forcing immediate load of sub derived from AutoLoader\n";
	# Tweaked version of AutoLoader::AUTOLOAD
	my $dir = $cvstashname;
	$dir =~ s(::)(/)g;
	eval { require "auto/$dir/$cvname.al" };
	if ($@@) {
	    warn qq(failed require "auto/$dir/$cvname.al": $@@\n);
	    return 0;
	} else {
	    return 1;
	}
    }
}

sub B::CV::save {
    my ($cv) = @@_;
    my $sym = objsym($cv);
    if (defined($sym)) {
#	warn sprintf("CV 0x%x already saved as $sym\n", $$cv); # debug
	return $sym;
    }
    # Reserve a place in svsect and xpvcvsect and record indices
    my $sv_ix = $svsect->index + 1;
    $svsect->add("svix$sv_ix");
    my $xpvcv_ix = $xpvcvsect->index + 1;
    $xpvcvsect->add("xpvcvix$xpvcv_ix");
    # Save symbol now so that GvCV() doesn't recurse back to us via CvGV()
    $sym = savesym($cv, "&sv_list[$sv_ix]");
    warn sprintf("saving CV 0x%x as $sym\n", $$cv) if $debug_cv;
    my $gv = $cv->GV;
    my $cvstashname = $gv->STASH->NAME;
    my $cvname = $gv->NAME;
    my $root = $cv->ROOT;
    my $cvxsub = $cv->XSUB;
    if (!$$root && !$cvxsub) {
	if (try_autoload($cvstashname, $cvname)) {
	    # Recalculate root and xsub
	    $root = $cv->ROOT;
	    $cvxsub = $cv->XSUB;
	    if ($$root || $cvxsub) {
		warn "Successful forced autoload\n";
	    }
	}
    }
    my $startfield = 0;
    my $padlist = $cv->PADLIST;
    my $pv = $cv->PV;
    my $xsub = 0;
    my $xsubany = "Nullany";
    if ($$root) {
	warn sprintf("saving op tree for CV 0x%x, root = 0x%x\n",
		     $$cv, $$root) if $debug_cv;
	my $ppname = "";
	if ($$gv) {
	    my $stashname = $gv->STASH->NAME;
	    my $gvname = $gv->NAME;
	    if ($gvname ne "__ANON__") {
		$ppname = (${$gv->FORM} == $$cv) ? "pp_form_" : "pp_sub_";
		$ppname .= ($stashname eq "main") ?
			    $gvname : "$stashname\::$gvname";
		$ppname =~ s/::/__/g;
	    }
	}
	if (!$ppname) {
	    $ppname = "pp_anonsub_$anonsub_index";
	    $anonsub_index++;
	}
	$startfield = saveoptree($ppname, $root, $cv->START, $padlist->ARRAY);
	warn sprintf("done saving op tree for CV 0x%x, name %s, root 0x%x\n",
		     $$cv, $ppname, $$root) if $debug_cv;
	if ($$padlist) {
	    warn sprintf("saving PADLIST 0x%x for CV 0x%x\n",
			 $$padlist, $$cv) if $debug_cv;
	    $padlist->save;
	    warn sprintf("done saving PADLIST 0x%x for CV 0x%x\n",
			 $$padlist, $$cv) if $debug_cv;
	}
    }
    elsif ($cvxsub) {
	$xsubany = sprintf("ANYINIT((void*)0x%x)", $cv->XSUBANY);
	# Try to find out canonical name of XSUB function from EGV.
	# XXX Doesn't work for XSUBs with PREFIX set (or anyone who
	# calls newXS() manually with weird arguments).
	my $egv = $gv->EGV;
	my $stashname = $egv->STASH->NAME;
	$stashname =~ s/::/__/g;
	$xsub = sprintf("XS_%s_%s", $stashname, $egv->NAME);
	$decl->add("void $xsub _((CV*));");
    }
    else {
	warn sprintf("No definition for sub %s::%s (unable to autoload)\n",
		     $cvstashname, $cvname); # debug
    }
    $symsect->add(sprintf("xpvcvix%d\t%s, %u, 0, %d, %s, 0, Nullhv, Nullhv, %s, s\\_%x, $xsub, $xsubany, Nullgv, Nullgv, %d, s\\_%x, (CV*)s\\_%x, 0x%x",
			  $xpvcv_ix, cstring($pv), length($pv), $cv->IVX,
			  $cv->NVX, $startfield, ${$cv->ROOT}, $cv->DEPTH,
                        $$padlist, ${$cv->OUTSIDE}, $cv->CvFLAGS));

    if (${$cv->OUTSIDE} == ${main_cv()}){
	$init->add(sprintf("CvOUTSIDE(s\\_%x)=PL_main_cv;",$$cv));
    }

    if ($$gv) {
	$gv->save;
	$init->add(sprintf("CvGV(s\\_%x) = s\\_%x;",$$cv,$$gv));
	warn sprintf("done saving GV 0x%x for CV 0x%x\n",
		     $$gv, $$cv) if $debug_cv;
    }
    my $filegv = $cv->FILEGV;
    if ($$filegv) {
	$filegv->save;
	$init->add(sprintf("CvFILEGV(s\\_%x) = s\\_%x;", $$cv, $$filegv));
	warn sprintf("done saving FILEGV 0x%x for CV 0x%x\n",
		     $$filegv, $$cv) if $debug_cv;
    }
    my $stash = $cv->STASH;
    if ($$stash) {
	$stash->save;
	$init->add(sprintf("CvSTASH(s\\_%x) = s\\_%x;", $$cv, $$stash));
	warn sprintf("done saving STASH 0x%x for CV 0x%x\n",
		     $$stash, $$cv) if $debug_cv;
    }
    $symsect->add(sprintf("svix%d\t(XPVCV*)&xpvcv_list[%u], %lu, 0x%x",
			  $sv_ix, $xpvcv_ix, $cv->REFCNT + 1, $cv->FLAGS));
    return $sym;
}

sub B::GV::save {
    my ($gv) = @@_;
    my $sym = objsym($gv);
    if (defined($sym)) {
	#warn sprintf("GV 0x%x already saved as $sym\n", $$gv); # debug
	return $sym;
    } else {
	my $ix = $gv_index++;
	$sym = savesym($gv, "gv_list[$ix]");
	#warn sprintf("Saving GV 0x%x as $sym\n", $$gv); # debug
    }
    my $gvname = $gv->NAME;
    my $name = cstring($gv->STASH->NAME . "::" . $gvname);
    #warn "GV name is $name\n"; # debug
    my $egv = $gv->EGV;
    my $egvsym;
    if ($$gv != $$egv) {
	#warn(sprintf("EGV name is %s, saving it now\n",
	#	     $egv->STASH->NAME . "::" . $egv->NAME)); # debug
	$egvsym = $egv->save;
    }
    $init->add(qq[$sym = gv_fetchpv($name, TRUE, SVt_PV);],
	       sprintf("SvFLAGS($sym) = 0x%x;", $gv->FLAGS),
	       sprintf("GvFLAGS($sym) = 0x%x;", $gv->GvFLAGS),
	       sprintf("GvLINE($sym) = %u;", $gv->LINE));
    # Shouldn't need to do save_magic since gv_fetchpv handles that
    #$gv->save_magic;
    my $refcnt = $gv->REFCNT + 1;
    $init->add(sprintf("SvREFCNT($sym) += %u;", $refcnt - 1)) if $refcnt > 1;
    my $gvrefcnt = $gv->GvREFCNT;
    if ($gvrefcnt > 1) {
	$init->add(sprintf("GvREFCNT($sym) += %u;", $gvrefcnt - 1));
    }
    if (defined($egvsym)) {
	# Shared glob *foo = *bar
	$init->add("gp_free($sym);",
		   "GvGP($sym) = GvGP($egvsym);");
    } elsif ($gvname !~ /^([^A-Za-z]|STDIN|STDOUT|STDERR|ARGV|SIG|ENV)$/) {
	# Don't save subfields of special GVs (*_, *1, *# and so on)
#	warn "GV::save saving subfields\n"; # debug
	my $gvsv = $gv->SV;
	if ($$gvsv) {
	    $init->add(sprintf("GvSV($sym) = s\\_%x;", $$gvsv));
#	    warn "GV::save \$$name\n"; # debug
	    $gvsv->save;
	}
	my $gvav = $gv->AV;
	if ($$gvav) {
	    $init->add(sprintf("GvAV($sym) = s\\_%x;", $$gvav));
#	    warn "GV::save \@@$name\n"; # debug
	    $gvav->save;
	}
	my $gvhv = $gv->HV;
	if ($$gvhv) {
	    $init->add(sprintf("GvHV($sym) = s\\_%x;", $$gvhv));
#	    warn "GV::save \%$name\n"; # debug
	    $gvhv->save;
	}
	my $gvcv = $gv->CV;
	if ($$gvcv) {
	    $init->add(sprintf("GvCV($sym) = (CV*)s\\_%x;", $$gvcv));
#	    warn "GV::save &$name\n"; # debug
	    $gvcv->save;
	}
	my $gvfilegv = $gv->FILEGV;
	if ($$gvfilegv) {
	    $init->add(sprintf("GvFILEGV($sym) = (GV*)s\\_%x;",$$gvfilegv));
#	    warn "GV::save GvFILEGV(*$name)\n"; # debug
	    $gvfilegv->save;
	}
	my $gvform = $gv->FORM;
	if ($$gvform) {
	    $init->add(sprintf("GvFORM($sym) = (CV*)s\\_%x;", $$gvform));
#	    warn "GV::save GvFORM(*$name)\n"; # debug
	    $gvform->save;
	}
	my $gvio = $gv->IO;
	if ($$gvio) {
	    $init->add(sprintf("GvIOp($sym) = s\\_%x;", $$gvio));
#	    warn "GV::save GvIO(*$name)\n"; # debug
	    $gvio->save;
	}
    }
    return $sym;
}
sub B::AV::save {
    my ($av) = @@_;
    my $sym = objsym($av);
    return $sym if defined $sym;
    my $avflags = $av->AvFLAGS;
    $xpvavsect->add(sprintf("0, -1, -1, 0, 0.0, 0, Nullhv, 0, 0, 0x%x",
			    $avflags));
    $svsect->add(sprintf("&xpvav_list[%d], %lu, 0x%x",
			 $xpvavsect->index, $av->REFCNT + 1, $av->FLAGS));
    my $sv_list_index = $svsect->index;
    my $fill = $av->FILL;
    $av->save_magic;
    warn sprintf("saving AV 0x%x FILL=$fill AvFLAGS=0x%x", $$av, $avflags)
	if $debug_av;
    # XXX AVf_REAL is wrong test: need to save comppadlist but not stack
    #if ($fill > -1 && ($avflags & AVf_REAL)) {
    if ($fill > -1) {
	my @@array = $av->ARRAY;
	if ($debug_av) {
	    my $el;
	    my $i = 0;
	    foreach $el (@@array) {
		warn sprintf("AV 0x%x[%d] = %s 0x%x\n",
			     $$av, $i++, class($el), $$el);
	    }
	}
	my @@names = map($_->save, @@array);
	# XXX Better ways to write loop?
	# Perhaps svp[0] = ...; svp[1] = ...; svp[2] = ...;
	# Perhaps I32 i = 0; svp[i++] = ...; svp[i++] = ...; svp[i++] = ...;
	$init->add("{",
		   "\tSV **svp;",
		   "\tAV *av = (AV*)&sv_list[$sv_list_index];",
		   "\tav_extend(av, $fill);",
		   "\tsvp = AvARRAY(av);",
	       map("\t*svp++ = (SV*)$_;", @@names),
		   "\tAvFILLp(av) = $fill;",
		   "}");
    } else {
	my $max = $av->MAX;
	$init->add("av_extend((AV*)&sv_list[$sv_list_index], $max);")
	    if $max > -1;
    }
    return savesym($av, "(AV*)&sv_list[$sv_list_index]");
}

sub B::HV::save {
    my ($hv) = @@_;
    my $sym = objsym($hv);
    return $sym if defined $sym;
    my $name = $hv->NAME;
    if ($name) {
	# It's a stash

	# A perl bug means HvPMROOT isn't altered when a PMOP is freed. Usually
	# the only symptom is that sv_reset tries to reset the PMf_USED flag of
	# a trashed op but we look at the trashed op_type and segfault.
	#my $adpmroot = ${$hv->PMROOT};
	my $adpmroot = 0;
	$decl->add("static HV *hv$hv_index;");
	# XXX Beware of weird package names containing double-quotes, \n, ...?
	$init->add(qq[hv$hv_index = gv_stashpv("$name", TRUE);]);
	if ($adpmroot) {
	    $init->add(sprintf("HvPMROOT(hv$hv_index) = (PMOP*)s\\_%x;",
			       $adpmroot));
	}
	$sym = savesym($hv, "hv$hv_index");
	$hv_index++;
	return $sym;
    }
    # It's just an ordinary HV
    $xpvhvsect->add(sprintf("0, 0, %d, 0, 0.0, 0, Nullhv, %d, 0, 0, 0",
			    $hv->MAX, $hv->RITER));
    $svsect->add(sprintf("&xpvhv_list[%d], %lu, 0x%x",
			 $xpvhvsect->index, $hv->REFCNT + 1, $hv->FLAGS));
    my $sv_list_index = $svsect->index;
    my @@contents = $hv->ARRAY;
    if (@@contents) {
	my $i;
	for ($i = 1; $i < @@contents; $i += 2) {
	    $contents[$i] = $contents[$i]->save;
	}
	$init->add("{", "\tHV *hv = (HV*)&sv_list[$sv_list_index];");
	while (@@contents) {
	    my ($key, $value) = splice(@@contents, 0, 2);
	    $init->add(sprintf("\thv_store(hv, %s, %u, %s, %s);",
			       cstring($key),length($key),$value, hash($key)));
	}
	$init->add("}");
    }
    return savesym($hv, "(HV*)&sv_list[$sv_list_index]");
}

sub B::IO::save {
    my ($io) = @@_;
    my $sym = objsym($io);
    return $sym if defined $sym;
    my $pv = $io->PV;
    my $len = length($pv);
    $xpviosect->add(sprintf("0, %u, %u, %d, %s, 0, 0, 0, 0, 0, %d, %d, %d, %d, %s, Nullgv, %s, Nullgv, %s, Nullgv, %d, %s, 0x%x",
			    $len, $len+1, $io->IVX, $io->NVX, $io->LINES,
			    $io->PAGE, $io->PAGE_LEN, $io->LINES_LEFT,
			    cstring($io->TOP_NAME), cstring($io->FMT_NAME), 
			    cstring($io->BOTTOM_NAME), $io->SUBPROCESS,
			    cchar($io->IoTYPE), $io->IoFLAGS));
    $svsect->add(sprintf("&xpvio_list[%d], %lu, 0x%x",
			 $xpviosect->index, $io->REFCNT + 1, $io->FLAGS));
    $sym = savesym($io, sprintf("(IO*)&sv_list[%d]", $svsect->index));
    my ($field, $fsym);
    foreach $field (qw(TOP_GV FMT_GV BOTTOM_GV)) {
      	$fsym = $io->$field();
	if ($$fsym) {
	    $init->add(sprintf("Io$field($sym) = (GV*)s\\_%x;", $$fsym));
	    $fsym->save;
	}
    }
    $io->save_magic;
    return $sym;
}

sub B::SV::save {
    my $sv = shift;
    # This is where we catch an honest-to-goodness Nullsv (which gets
    # blessed into B::SV explicitly) and any stray erroneous SVs.
    return 0 unless $$sv;
    confess sprintf("cannot save that type of SV: %s (0x%x)\n",
		    class($sv), $$sv);
}

sub output_all {
    my $init_name = shift;
    my $section;
    my @@sections = ($opsect, $unopsect, $binopsect, $logopsect, $condopsect,
		    $listopsect, $pmopsect, $svopsect, $gvopsect, $pvopsect,
		    $cvopsect, $loopsect, $copsect, $svsect, $xpvsect,
		    $xpvavsect, $xpvhvsect, $xpvcvsect, $xpvivsect, $xpvnvsect,
		    $xpvmgsect, $xpvlvsect, $xrvsect, $xpvbmsect, $xpviosect);
    $bootstrap->output(\*STDOUT, "/* bootstrap %s */\n");
    $symsect->output(\*STDOUT, "#define %s\n");
    print "\n";
    output_declarations();
    foreach $section (@@sections) {
	my $lines = $section->index + 1;
	if ($lines) {
	    my $name = $section->name;
	    my $typename = ($name eq "xpvcv") ? "XPVCV_or_similar" : uc($name);
	    print "Static $typename ${name}_list[$lines];\n";
	}
    }
    $decl->output(\*STDOUT, "%s\n");
    print "\n";
    foreach $section (@@sections) {
	my $lines = $section->index + 1;
	if ($lines) {
	    my $name = $section->name;
	    my $typename = ($name eq "xpvcv") ? "XPVCV_or_similar" : uc($name);
	    printf "static %s %s_list[%u] = {\n", $typename, $name, $lines;
	    $section->output(\*STDOUT, "\t{ %s },\n");
	    print "};\n\n";
	}
    }

    print <<"EOT";
static int $init_name()
{
	dTHR;
EOT
    $init->output(\*STDOUT, "\t%s\n");
    print "\treturn 0;\n}\n";
    if ($verbose) {
	warn compile_stats();
	warn "NULLOP count: $nullop_count\n";
    }
}

sub output_declarations {
    print <<'EOT';
#ifdef BROKEN_STATIC_REDECL
#define Static extern
#else
#define Static static
#endif /* BROKEN_STATIC_REDECL */

#ifdef BROKEN_UNION_INIT
/*
 * Cribbed from cv.h with ANY (a union) replaced by void*.
 * Some pre-Standard compilers can't cope with initialising unions. Ho hum.
 */
typedef struct {
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xp_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    IV		xof_off;	/* integer value */
    double	xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* magic for scalar array */
    HV*		xmg_stash;	/* class package */

    HV *	xcv_stash;
    OP *	xcv_start;
    OP *	xcv_root;
    void      (*xcv_xsub) _((CV*));
    void *	xcv_xsubany;
    GV *	xcv_gv;
    GV *	xcv_filegv;
    long	xcv_depth;		/* >= 2 indicates recursive call */
    AV *	xcv_padlist;
    CV *	xcv_outside;
#ifdef USE_THREADS
    perl_mutex *xcv_mutexp;
    struct perl_thread *xcv_owner;	/* current owner thread */
#endif /* USE_THREADS */
    U8		xcv_flags;
} XPVCV_or_similar;
#define ANYINIT(i) i
#else
#define XPVCV_or_similar XPVCV
#define ANYINIT(i) {i}
#endif /* BROKEN_UNION_INIT */
#define Nullany ANYINIT(0)

#define UNUSED 0
#define sym_0 0

EOT
    print "static GV *gv_list[$gv_index];\n" if $gv_index;
    print "\n";
}


sub output_boilerplate {
    print <<'EOT';
#include "EXTERN.h"
#include "perl.h"
#ifndef PATCHLEVEL
#include "patchlevel.h"
#endif

/* Workaround for mapstart: the only op which needs a different ppaddr */
#undef pp_mapstart
#define pp_mapstart pp_grepstart

static void xs_init _((void));
static PerlInterpreter *my_perl;
EOT
}

sub output_main {
    print <<'EOT';
int
#ifndef CAN_PROTOTYPE
main(argc, argv, env)
int argc;
char **argv;
char **env;
#else  /* def(CAN_PROTOTYPE) */
main(int argc, char **argv, char **env)
#endif  /* def(CAN_PROTOTYPE) */
{
    int exitstatus;
    int i;
    char **fakeargv;

    PERL_SYS_INIT(&argc,&argv);
 
    perl_init_i18nl10n(1);

    if (!PL_do_undump) {
	my_perl = perl_alloc();
	if (!my_perl)
	    exit(1);
	perl_construct( my_perl );
    }

#ifdef CSH
    if (!PL_cshlen) 
      PL_cshlen = strlen(PL_cshname);
#endif

#ifdef ALLOW_PERL_OPTIONS
#define EXTRA_OPTIONS 2
#else
#define EXTRA_OPTIONS 3
#endif /* ALLOW_PERL_OPTIONS */
    New(666, fakeargv, argc + EXTRA_OPTIONS + 1, char *);
    fakeargv[0] = argv[0];
    fakeargv[1] = "-e";
    fakeargv[2] = "";
#ifndef ALLOW_PERL_OPTIONS
    fakeargv[3] = "--";
#endif /* ALLOW_PERL_OPTIONS */
    for (i = 1; i < argc; i++)
	fakeargv[i + EXTRA_OPTIONS] = argv[i];
    fakeargv[argc + EXTRA_OPTIONS] = 0;
    
    exitstatus = perl_parse(my_perl, xs_init, argc + EXTRA_OPTIONS,
			    fakeargv, NULL);
    if (exitstatus)
	exit( exitstatus );

    sv_setpv(GvSV(gv_fetchpv("0", TRUE, SVt_PV)), argv[0]);
    PL_main_cv = PL_compcv;
    PL_compcv = 0;

    exitstatus = perl_init();
    if (exitstatus)
	exit( exitstatus );

    exitstatus = perl_run( my_perl );

    perl_destruct( my_perl );
    perl_free( my_perl );

    exit( exitstatus );
}

static void
xs_init()
{
}
EOT
}

sub dump_symtable {
    # For debugging
    my ($sym, $val);
    warn "----Symbol table:\n";
    while (($sym, $val) = each %symtable) {
	warn "$sym => $val\n";
    }
    warn "---End of symbol table\n";
}

sub save_object {
    my $sv;
    foreach $sv (@@_) {
	svref_2object($sv)->save;
    }
}       

sub Dummy_BootStrap { }            

sub B::GV::savecv {
    my $gv = shift;
    my $cv = $gv->CV;
    my $name = $gv->NAME;
    if ($$cv) {
	if ($name eq "bootstrap" && $cv->XSUB) {
	    my $file = $cv->FILEGV->SV->PV;
	    $bootstrap->add($file);
	    my $name = $gv->STASH->NAME.'::'.$name;
	    no strict 'refs';
            *{$name} = \&Dummy_BootStrap;   
	    $cv = $gv->CV;
	}
	if ($debug_cv) {
	    warn sprintf("saving extra CV &%s::%s (0x%x) from GV 0x%x\n",
			 $gv->STASH->NAME, $name, $$cv, $$gv);
	}
      my $package=$gv->STASH->NAME;
      # This seems to undo all the ->isa and prefix stuff we do below
      # so disable again for now
      if (0 && ! grep(/^$package$/,@@unused_sub_packages)){
          warn sprintf("omitting cv in superclass %s", $gv->STASH->NAME) 
              if $debug_cv;
          return ;
      }
	$gv->save;
    }
    elsif ($name eq 'ISA')
     {
      $gv->save;
     }

}



sub save_unused_subs {
    my %search_pack;
    map { $search_pack{$_} = 1 } @@_;
    @@unused_sub_packages=@@_;
    no strict qw(vars refs);
    walksymtable(\%{"main::"}, "savecv", sub {
	my $package = shift;
	$package =~ s/::$//;
	return 0 if ($package =~ /::::/);  # skip ::::ISA::CACHE etc.
	#warn "Considering $package\n";#debug
	return 1 if exists $search_pack{$package};
      #sub try for a partial match
      if (grep(/^$package\:\:/,@@unused_sub_packages)){ 
          return 1;   
      }       
	#warn "    (nothing explicit)\n";#debug
	# Omit the packages which we use (and which cause grief
	# because of fancy "goto &$AUTOLOAD" stuff).
	# XXX Surely there must be a nicer way to do this.
	if ($package eq "FileHandle"
	    || $package eq "Config"
	    || $package eq "SelectSaver") {
	    return 0;
	}
	foreach my $u (keys %search_pack) {
	    if ($package =~ /^${u}::/) {
		warn "$package starts with $u\n";
		return 1
	    }
	    if ($package->isa($u)) {
		warn "$package isa $u\n";
		return 1
	    }
	    return 1 if $package->isa($u);
	}
	foreach my $m (qw(new DESTROY TIESCALAR TIEARRAY TIEHASH)) {
	    if (defined(&{$package."::$m"})) {
		warn "$package has method $m: -u$package assumed\n";#debug
              push @@unused_sub_package, $package;
		return 1;
	    }
	}
	return 0;
    });
}

sub save_main {
    warn "Walking tree\n";
    my $curpad_nam = (comppadlist->ARRAY)[0]->save;
    my $curpad_sym = (comppadlist->ARRAY)[1]->save;
    my $init_av    = init_av->save;
    my $inc_hv     = svref_2object(\%INC)->save;
    my $inc_av     = svref_2object(\@@INC)->save;
    walkoptree(main_root, "save");
    warn "done main optree, walking symtable for extras\n" if $debug_cv;
    save_unused_subs(@@unused_sub_packages);

    $init->add(sprintf("PL_main_root = s\\_%x;", ${main_root()}),
	       sprintf("PL_main_start = s\\_%x;", ${main_start()}),
	       "PL_curpad = AvARRAY($curpad_sym);",
	       "PL_initav = $init_av;",
	       "GvHV(PL_incgv) = $inc_hv;",
	       "GvAV(PL_incgv) = $inc_av;",
               "av_store(CvPADLIST(PL_main_cv),0,SvREFCNT_inc($curpad_nam));",
               "av_store(CvPADLIST(PL_main_cv),1,SvREFCNT_inc($curpad_sym));");
    warn "Writing output\n";
    output_boilerplate();
    print "\n";
    output_all("perl_init");
    print "\n";
    output_main();
}

sub init_sections {
    my @@sections = (init => \$init, decl => \$decl, sym => \$symsect,
		    binop => \$binopsect, condop => \$condopsect,
		    cop => \$copsect, cvop => \$cvopsect, gvop => \$gvopsect,
		    listop => \$listopsect, logop => \$logopsect,
		    loop => \$loopsect, op => \$opsect, pmop => \$pmopsect,
		    pvop => \$pvopsect, svop => \$svopsect, unop => \$unopsect,
		    sv => \$svsect, xpv => \$xpvsect, xpvav => \$xpvavsect,
		    xpvhv => \$xpvhvsect, xpvcv => \$xpvcvsect,
		    xpviv => \$xpvivsect, xpvnv => \$xpvnvsect,
		    xpvmg => \$xpvmgsect, xpvlv => \$xpvlvsect,
		    xrv => \$xrvsect, xpvbm => \$xpvbmsect,
		    xpvio => \$xpviosect, bootstrap => \$bootstrap);
    my ($name, $sectref);
    while (($name, $sectref) = splice(@@sections, 0, 2)) {
	$$sectref = new B::Section $name, \%symtable, 0;
    }
}

sub compile {
    my @@options = @@_;
    my ($option, $opt, $arg);
  OPTION:
    while ($option = shift @@options) {
	if ($option =~ /^-(.)(.*)/) {
	    $opt = $1;
	    $arg = $2;
	} else {
	    unshift @@options, $option;
	    last OPTION;
	}
	if ($opt eq "-" && $arg eq "-") {
	    shift @@options;
	    last OPTION;
	}
	if ($opt eq "w") {
	    $warn_undefined_syms = 1;
	} elsif ($opt eq "D") {
	    $arg ||= shift @@options;
	    foreach $arg (split(//, $arg)) {
		if ($arg eq "o") {
		    B->debug(1);
		} elsif ($arg eq "c") {
		    $debug_cops = 1;
		} elsif ($arg eq "A") {
		    $debug_av = 1;
		} elsif ($arg eq "C") {
		    $debug_cv = 1;
		} elsif ($arg eq "M") {
		    $debug_mg = 1;
		} else {
		    warn "ignoring unknown debug option: $arg\n";
		}
	    }
	} elsif ($opt eq "o") {
	    $arg ||= shift @@options;
	    open(STDOUT, ">$arg") or return "$arg: $!\n";
	} elsif ($opt eq "v") {
	    $verbose = 1;
	} elsif ($opt eq "u") {
	    $arg ||= shift @@options;
	    push(@@unused_sub_packages, $arg);
	} elsif ($opt eq "f") {
	    $arg ||= shift @@options;
	    if ($arg eq "cog") {
		$pv_copy_on_grow = 1;
	    } elsif ($arg eq "no-cog") {
		$pv_copy_on_grow = 0;
	    }
	} elsif ($opt eq "O") {
	    $arg = 1 if $arg eq "";
	    $pv_copy_on_grow = 0;
	    if ($arg >= 1) {
		# Optimisations for -O1
		$pv_copy_on_grow = 1;
	    }
	}
    }
    init_sections();
    if (@@options) {
	return sub {
	    my $objname;
	    foreach $objname (@@options) {
		eval "save_object(\\$objname)";
	    }
	    output_all();
	}
    } else {
	return sub { save_main() };
    }
}

1;

__END__

=head1 NAME

B::C - Perl compiler's C backend

=head1 SYNOPSIS

	perl -MO=C[,OPTIONS] foo.pl

=head1 DESCRIPTION

This compiler backend takes Perl source and generates C source code
corresponding to the internal structures that perl uses to run
your program. When the generated C source is compiled and run, it
cuts out the time which perl would have taken to load and parse
your program into its internal semi-compiled form. That means that
compiling with this backend will not help improve the runtime
execution speed of your program but may improve the start-up time.
Depending on the environment in which your program runs this may be
either a help or a hindrance.

=head1 OPTIONS

If there are any non-option arguments, they are taken to be
names of objects to be saved (probably doesn't work properly yet).
Without extra arguments, it saves the main program.

=over 4

=item B<-ofilename>

Output to filename instead of STDOUT

=item B<-v>

Verbose compilation (currently gives a few compilation statistics).

=item B<-->

Force end of options

=item B<-uPackname>

Force apparently unused subs from package Packname to be compiled.
This allows programs to use eval "foo()" even when sub foo is never
seen to be used at compile time. The down side is that any subs which
really are never used also have code generated. This option is
necessary, for example, if you have a signal handler foo which you
initialise with C<$SIG{BAR} = "foo">.  A better fix, though, is just
to change it to C<$SIG{BAR} = \&foo>. You can have multiple B<-u>
options. The compiler tries to figure out which packages may possibly
have subs in which need compiling but the current version doesn't do
it very well. In particular, it is confused by nested packages (i.e.
of the form C<A::B>) where package C<A> does not contain any subs.

=item B<-D>

Debug options (concatenated or separate flags like C<perl -D>).

=item B<-Do>

OPs, prints each OP as it's processed

=item B<-Dc>

COPs, prints COPs as processed (incl. file & line num)

=item B<-DA>

prints AV information on saving

=item B<-DC>

prints CV information on saving

=item B<-DM>

prints MAGIC information on saving

=item B<-f>

Force optimisations on or off one at a time.

=item B<-fcog>

Copy-on-grow: PVs declared and initialised statically.

=item B<-fno-cog>

No copy-on-grow.

=item B<-On>

Optimisation level (n = 0, 1, 2, ...). B<-O> means B<-O1>.  Currently,
B<-O1> and higher set B<-fcog>.

=head1 EXAMPLES

    perl -MO=C,-ofoo.c foo.pl
    perl cc_harness -o foo foo.c

Note that C<cc_harness> lives in the C<B> subdirectory of your perl
library directory. The utility called C<perlcc> may also be used to
help make use of this compiler.

    perl -MO=C,-v,-DcA bar.pl > /dev/null

=head1 BUGS

Plenty. Current status: experimental.

=head1 AUTHOR

Malcolm Beattie, C<mbeattie@@sable.ox.ac.uk>

=cut
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@a7 36
package B::C::Section;
use B ();
use base B::Section;

sub new
{
 my $class = shift;
 my $o = $class->SUPER::new(@@_);
 push(@@$o,[]);
 return $o;
}

sub add
{  
 my $section = shift;
 push(@@{$section->[-1]},@@_);
}

sub index
{  
 my $section = shift;
 return scalar(@@{$section->[-1]})-1;
}

sub output
{   
 my ($section, $fh, $format) = @@_;
 my $sym = $section->symtable || {};
 my $default = $section->default;
 foreach (@@{$section->[-1]})
  {
   s{(s\\_[0-9a-f]+)}{ exists($sym->{$1}) ? $sym->{$1} : $default; }ge;
   printf $fh $format, $_;
  }
}

d11 2
a12 2
@@EXPORT_OK = qw(output_all output_boilerplate output_main mark_unused
		init_sections set_callback save_unused_subs objsym save_context);
d16 1
a16 2
	 threadsv_names main_cv init_av opnumber amagic_generation
	 AVf_REAL HEf_SVKEY);
a21 1
use Config;
a27 1
my $initsub_index = 0;
a29 1
my %xsub;
d32 1
a32 1
my %unused_sub_packages;
d34 1
a34 1
my $pv_copy_on_grow = 0;
a35 1
my $max_string_len;
d43 2
a44 2
my ($init, $decl, $symsect, $binopsect, $condopsect, $copsect, 
    $padopsect, $listopsect, $logopsect, $loopsect, $opsect, $pmopsect,
d47 1
a47 1
    $xrvsect, $xpvbmsect, $xpviosect );
d69 5
a73 3
# Look this up here so we can do just a number compare
# rather than looking up the name of every BASEOP in B::OP
my $OP_THREADSV = opnumber('threadsv');
d101 1
a101 2
    my $pv = shift;         
    $pv    = '' unless defined $pv;  # Is this sane ?
d104 1
a104 1
    if ($pv_copy_on_grow) { 
a117 2
    my $sym = objsym($op);
    return $sym if defined $sym;
d120 1
a120 1
    if ($type == $OP_THREADSV) {
d125 2
a126 2
    $opsect->add(sprintf("s\\_%x, s\\_%x, NULL, %u, %u, %u, 0x%x, 0x%x",
			 ${$op->next}, ${$op->sibling}, $op->targ,
d128 1
a128 3
    my $ix = $opsect->index;
    $init->add(sprintf("op_list[$ix].op_ppaddr = %s;", $op->ppaddr));
    savesym($op, "&op_list[$ix]");
d138 2
a139 2
    $opsect->add(sprintf("%s, %s, NULL, %u, %u, %u, 0x%x, 0x%x",
			 $op->next, $op->sibling, $op->targ,
d141 1
a141 3
    my $ix = $opsect->index;
    $init->add(sprintf("op_list[$ix].op_ppaddr = %s;", $op->ppaddr));
    return "&op_list[$ix]";
d154 2
a155 4
    my $sym = objsym($op);
    return $sym if defined $sym;
    $unopsect->add(sprintf("s\\_%x, s\\_%x, NULL, %u, %u, %u, 0x%x, 0x%x, s\\_%x",
			   ${$op->next}, ${$op->sibling},
d158 1
a158 3
    my $ix = $unopsect->index;
    $init->add(sprintf("unop_list[$ix].op_ppaddr = %s;", $op->ppaddr));
    savesym($op, "(OP*)&unop_list[$ix]");
d163 2
a164 4
    my $sym = objsym($op);
    return $sym if defined $sym;
    $binopsect->add(sprintf("s\\_%x, s\\_%x, NULL, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x",
			    ${$op->next}, ${$op->sibling},
d167 1
a167 3
    my $ix = $binopsect->index;
    $init->add(sprintf("binop_list[$ix].op_ppaddr = %s;", $op->ppaddr));
    savesym($op, "(OP*)&binop_list[$ix]");
d172 2
a173 4
    my $sym = objsym($op);
    return $sym if defined $sym;
    $listopsect->add(sprintf("s\\_%x, s\\_%x, NULL, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x, %u",
			     ${$op->next}, ${$op->sibling},
d177 1
a177 3
    my $ix = $listopsect->index;
    $init->add(sprintf("listop_list[$ix].op_ppaddr = %s;", $op->ppaddr));
    savesym($op, "(OP*)&listop_list[$ix]");
d182 2
a183 4
    my $sym = objsym($op);
    return $sym if defined $sym;
    $logopsect->add(sprintf("s\\_%x, s\\_%x, NULL, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x",
			    ${$op->next}, ${$op->sibling},
d186 11
a196 3
    my $ix = $logopsect->index;
    $init->add(sprintf("logop_list[$ix].op_ppaddr = %s;", $op->ppaddr));
    savesym($op, "(OP*)&logop_list[$ix]");
a200 2
    my $sym = objsym($op);
    return $sym if defined $sym;
d204 2
a205 2
    $loopsect->add(sprintf("s\\_%x, s\\_%x, NULL, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x, %u, s\\_%x, s\\_%x, s\\_%x",
			   ${$op->next}, ${$op->sibling},
d210 1
a210 3
    my $ix = $loopsect->index;
    $init->add(sprintf("loop_list[$ix].op_ppaddr = %s;", $op->ppaddr));
    savesym($op, "(OP*)&loop_list[$ix]");
d215 2
a216 4
    my $sym = objsym($op);
    return $sym if defined $sym;
    $pvopsect->add(sprintf("s\\_%x, s\\_%x, NULL,  %u, %u, %u, 0x%x, 0x%x, %s",
			   ${$op->next}, ${$op->sibling},
d219 1
a219 3
    my $ix = $pvopsect->index;
    $init->add(sprintf("pvop_list[$ix].op_ppaddr = %s;", $op->ppaddr));
    savesym($op, "(OP*)&pvop_list[$ix]");
a223 2
    my $sym = objsym($op);
    return $sym if defined $sym;
d225 2
a226 2
    $svopsect->add(sprintf("s\\_%x, s\\_%x, NULL, %u, %u, %u, 0x%x, 0x%x, Nullsv",
			   ${$op->next}, ${$op->sibling},
d228 2
a229 5
			   $op->private));
    my $ix = $svopsect->index;
    $init->add(sprintf("svop_list[$ix].op_ppaddr = %s;", $op->ppaddr));
    $init->add("svop_list[$ix].op_sv = (SV*)$svsym;");
    savesym($op, "(OP*)&svop_list[$ix]");
d232 1
a232 1
sub B::PADOP::save {
d234 3
a236 4
    my $sym = objsym($op);
    return $sym if defined $sym;
    $padopsect->add(sprintf("s\\_%x, s\\_%x, NULL, %u, %u, %u, 0x%x, 0x%x, 0",
			   ${$op->next}, ${$op->sibling},
d239 2
a240 4
    $init->add(sprintf("padop_list[%d].op_ppaddr = %s;", $padopsect->index, $op->ppaddr));
    my $ix = $padopsect->index;
    $init->add(sprintf("padop_list[$ix].op_padix = %ld;", $op->padix));
    savesym($op, "(OP*)&padop_list[$ix]");
d245 3
a247 3
    my $sym = objsym($op);
    return $sym if defined $sym;
    warn sprintf("COP: line %d file %s\n", $op->line, $op->file)
d249 2
a250 2
    $copsect->add(sprintf("s\\_%x, s\\_%x, NULL, %u, %u, %u, 0x%x, 0x%x, %s, NULL, NULL, %u, %d, %u",
			  ${$op->next}, ${$op->sibling},
d254 4
a257 5
    my $ix = $copsect->index;
    $init->add(sprintf("cop_list[$ix].op_ppaddr = %s;", $op->ppaddr));
    $init->add(sprintf("CopFILE_set(&cop_list[$ix], %s);", cstring($op->file)),
	       sprintf("CopSTASHPV_set(&cop_list[$ix], %s);", cstring($op->stashpv)));
    savesym($op, "(OP*)&cop_list[$ix]");
a261 2
    my $sym = objsym($op);
    return $sym if defined $sym;
d272 1
a272 1
	if ($op->name eq "pushre") {
d283 2
a284 2
    $pmopsect->add(sprintf("s\\_%x, s\\_%x, NULL, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x, %u, %s, %s, 0, 0, 0x%x, 0x%x",
			   ${$op->next}, ${$op->sibling}, $op->targ,
a289 1
    $init->add(sprintf("$pm.op_ppaddr = %s;", $ppaddr));
d300 1
a300 1
    savesym($op, "(OP*)&$pm");
d322 4
a325 5
    if ($$sv == 0) {
    	warn "NULL::save for sv = 0 called from @@{[(caller(1))[3]]}\n";
	return savesym($sv, "Nullsv /* XXX */");
    }
    $svsect->add(sprintf("0, %u, 0x%x", $sv->REFCNT , $sv->FLAGS));
d335 1
a335 1
			 $xpvivsect->index, $sv->REFCNT , $sv->FLAGS));
d343 1
a343 3
    my $val= $sv->NVX;
    $val .= '.00' if $val =~ /^-?\d+$/;
    $xpvnvsect->add(sprintf("0, 0, 0, %d, %s", $sv->IVX, $val));
d345 1
a345 1
			 $xpvnvsect->index, $sv->REFCNT , $sv->FLAGS));
a348 21
sub savepvn {
    my ($dest,$pv) = @@_;
    my @@res;
    if (defined $max_string_len && length($pv) > $max_string_len) {
	push @@res, sprintf("New(0,%s,%u,char);", $dest, length($pv)+1);
	my $offset = 0;
	while (length $pv) {
	    my $str = substr $pv, 0, $max_string_len, '';
	    push @@res, sprintf("Copy(%s,$dest+$offset,%u,char);",
			       cstring($str), length($str));
	    $offset += length $str;
	}
	push @@res, sprintf("%s[%u] = '\\0';", $dest, $offset);
    }
    else {
	push @@res, sprintf("%s = savepvn(%s, %u);", $dest,
			   cstring($pv), length($pv));
    }
    return @@res;
}

d361 1
a361 1
			 $xpvlvsect->index, $sv->REFCNT , $sv->FLAGS));
d363 2
a364 2
	$init->add(savepvn(sprintf("xpvlv_list[%d].xpv_pv",
				   $xpvlvsect->index), $pv));
d379 1
a379 1
			 $xpvivsect->index, $sv->REFCNT , $sv->FLAGS));
d381 2
a382 2
	$init->add(savepvn(sprintf("xpviv_list[%d].xpv_pv",
				   $xpvivsect->index), $pv));
d391 1
a391 2
    my $pv = $sv->PV;     
    $pv = '' unless defined $pv;
a393 2
    my $val= $sv->NVX;
    $val .= '.00' if $val =~ /^-?\d+$/;
d395 1
a395 1
			    $pvsym, $len, $pvmax, $sv->IVX, $val));
d397 1
a397 1
			 $xpvnvsect->index, $sv->REFCNT , $sv->FLAGS));
d399 2
a400 2
	$init->add(savepvn(sprintf("xpvnv_list[%d].xpv_pv",
				   $xpvnvsect->index), $pv));
d415 1
a415 1
			 $xpvbmsect->index, $sv->REFCNT , $sv->FLAGS));
d417 2
a418 2
    $init->add(savepvn(sprintf("xpvbm_list[%d].xpv_pv",
			       $xpvbmsect->index), $pv),
d433 1
a433 1
			 $xpvsect->index, $sv->REFCNT , $sv->FLAGS));
d435 2
a436 2
	$init->add(savepvn(sprintf("xpv_list[%d].xpv_pv",
				   $xpvsect->index), $pv));
d451 1
a451 1
			 $xpvmgsect->index, $sv->REFCNT , $sv->FLAGS));
d453 2
a454 2
	$init->add(savepvn(sprintf("xpvmg_list[%d].xpv_pv",
				   $xpvmgsect->index), $pv));
a464 1
    $stash->save;
d472 1
a472 1
    my ($mg, $type, $obj, $ptr,$len,$ptrsv);
d477 1
a477 1
	$len=$mg->LENGTH;
d483 1
a483 8
	$obj->save;
	if ($len == HEf_SVKEY){
		#The pointer is an SV*
		$ptrsv=svref_2object($ptr)->save;
		$init->add(sprintf("sv_magic((SV*)s\\_%x, (SV*)s\\_%x, %s,(char *) %s, %d);",
			   $$sv, $$obj, cchar($type),$ptrsv,$len));
	}else{
		$init->add(sprintf("sv_magic((SV*)s\\_%x, (SV*)s\\_%x, %s, %s, %d);",
a484 1
	}
d492 1
a492 3
    my $rv = $sv->RV->save;
    $rv =~ s/^\([AGHS]V\s*\*\)\s*(\&sv_list.*)$/$1/;
    $xrvsect->add($rv);
d494 1
a494 1
			 $xrvsect->index, $sv->REFCNT , $sv->FLAGS));
d519 1
a519 1
sub Dummy_initxs{};
a527 30
    my $gv = $cv->GV;
    my ($cvname, $cvstashname);
    if ($$gv){
    	$cvname = $gv->NAME;
    	$cvstashname = $gv->STASH->NAME;
    }
    my $root = $cv->ROOT;
    my $cvxsub = $cv->XSUB;
    #INIT is removed from the symbol table, so this call must come
    # from PL_initav->save. Re-bootstrapping  will push INIT back in
    # so nullop should be sent.
    if ($cvxsub && ($cvname ne "INIT")) {
	my $egv = $gv->EGV;
	my $stashname = $egv->STASH->NAME;
         if ($cvname eq "bootstrap")
          {                                   
           my $file = $gv->FILE;    
           $decl->add("/* bootstrap $file */"); 
           warn "Bootstrap $stashname $file\n";
           $xsub{$stashname}='Dynamic'; 
	   # $xsub{$stashname}='Static' unless  $xsub{$stashname};
           return qq/NULL/;
          }                                   
        warn sprintf("stub for XSUB $cvstashname\:\:$cvname CV 0x%x\n", $$cv) if $debug_cv;
	return qq/(perl_get_cv("$stashname\:\:$cvname",TRUE))/;
    }
    if ($cvxsub && $cvname eq "INIT") {
	 no strict 'refs';
   	 return svref_2object(\&Dummy_initxs)->save;
    }
d534 6
a539 1
    warn sprintf("saving $cvstashname\:\:$cvname CV 0x%x as $sym\n", $$cv) if $debug_cv;
a566 4
	        if ($gvname eq "INIT"){
		       $ppname .= "_$initsub_index";
		       $initsub_index++;
		    }
d584 11
d598 2
a599 3
    }              
    $pv = '' unless defined $pv; # Avoid use of undef warnings
    $symsect->add(sprintf("xpvcvix%d\t%s, %u, 0, %d, %s, 0, Nullhv, Nullhv, %s, s\\_%x, $xsub, $xsubany, Nullgv, \"\", %d, s\\_%x, (CV*)s\\_%x, 0x%x",
a605 1
	$init->add(sprintf("SvREFCNT_inc(PL_main_cv);"));
d614 7
a620 1
    $init->add(sprintf("CvFILE($sym) = %s;", cstring($cv->FILE)));
d629 1
a629 1
			  $sv_ix, $xpvcv_ix, $cv->REFCNT +1 , $cv->FLAGS));
a643 1
    my $is_empty = $gv->is_empty;
d647 1
d649 4
a652 7
    unless ($is_empty) {
	my $egv = $gv->EGV;
	if ($$gv != $$egv) {
	    #warn(sprintf("EGV name is %s, saving it now\n",
	    #	     $egv->STASH->NAME . "::" . $egv->NAME)); # debug
	    $egvsym = $egv->save;
	}
d656 2
a657 3
	       sprintf("GvFLAGS($sym) = 0x%x;", $gv->GvFLAGS));
    $init->add(sprintf("GvLINE($sym) = %u;", $gv->LINE)) unless $is_empty;

a661 3

    return $sym if $is_empty;

a674 1
	    $gvsv->save;
d677 1
a680 1
	    $gvav->save;
d683 1
a686 1
	    $gvhv->save;
d689 1
d692 11
a702 17
	if ($$gvcv) { 
	    my $origname=cstring($gvcv->GV->EGV->STASH->NAME .
		 "::" . $gvcv->GV->EGV->NAME);  
	    if (0 && $gvcv->XSUB && $name ne $origname) { #XSUB alias
	        # must save as a 'stub' so newXS() has a CV to populate
                $init->add("{ CV *cv;");
                $init->add("\tcv=perl_get_cv($origname,TRUE);");
                $init->add("\tGvCV($sym)=cv;");
                $init->add("\tSvREFCNT_inc((SV *)cv);");
                $init->add("}");    
	    } else {     
               $init->add(sprintf("GvCV($sym) = (CV*)(%s);", $gvcv->save));
#              warn "GV::save &$name\n"; # debug
	    } 
        }     
	$init->add(sprintf("GvFILE($sym) = %s;", cstring($gv->FILE)));
#	warn "GV::save GvFILE(*$name)\n"; # debug
a704 1
	    $gvform->save;
d707 1
a710 1
	    $gvio->save;
d713 1
d726 1
a726 1
			 $xpvavsect->index, $av->REFCNT  , $av->FLAGS));
d792 1
a792 1
			 $xpvhvsect->index, $hv->REFCNT  , $hv->FLAGS));
a804 2
#	    $init->add(sprintf("\thv_store(hv, %s, %u, %s, %s);",
#			       cstring($key),length($key),$value, 0));
a807 1
    $hv->save_magic();
a815 1
    $pv = '' unless defined $pv;
d824 1
a824 1
			 $xpviosect->index, $io->REFCNT , $io->FLAGS));
d851 2
a852 2
		    $listopsect, $pmopsect, $svopsect, $padopsect, $pvopsect,
		    $loopsect, $copsect, $svsect, $xpvsect,
d855 1
a883 2
	dTARG;
	djSP;
d918 1
a918 1
    void      (*xcv_xsub) (CV*);
d921 2
a922 2
    char *	xcv_file;
    long	xcv_depth;	/* >= 2 indicates recursive call */
d929 1
a929 1
    cv_flags_t	xcv_flags;
d951 3
a953 1
#include "XSUB.h"
d956 2
a957 4
#undef Perl_pp_mapstart
#define Perl_pp_mapstart Perl_pp_grepstart
#define XS_DynaLoader_boot_DynaLoader boot_DynaLoader
EXTERN_C void boot_DynaLoader (pTHX_ CV* cv);
d959 1
a959 2
static void xs_init (pTHX);
static void dl_init (pTHX);
d967 6
d974 1
d980 1
a980 1
    PERL_SYS_INIT3(&argc,&argv,&env);
d982 2
a988 1
	PL_perl_destruct_level = 0;
a1023 1
    dl_init(aTHX);
a1029 2
    PERL_SYS_TERM();

a1032 1
/* yanked from perl.c */
d1034 1
a1034 1
xs_init(pTHX)
d1036 1
a1036 3
    char *file = __FILE__;
    dTARG;
    djSP;
a1037 57
    print "\n#ifdef USE_DYNAMIC_LOADING";
    print qq/\n\tnewXS("DynaLoader::boot_DynaLoader", boot_DynaLoader, file);/;
    print "\n#endif\n" ;
    # delete $xsub{'DynaLoader'}; 
    delete $xsub{'UNIVERSAL'}; 
    print("/* bootstrapping code*/\n\tSAVETMPS;\n");
    print("\ttarg=sv_newmortal();\n");
    print "#ifdef DYNALOADER_BOOTSTRAP\n";
    print "\tPUSHMARK(sp);\n";
    print qq/\tXPUSHp("DynaLoader",strlen("DynaLoader"));\n/;
    print qq/\tPUTBACK;\n/;
    print "\tboot_DynaLoader(aTHX_ NULL);\n";
    print qq/\tSPAGAIN;\n/;
    print "#endif\n";
    foreach my $stashname (keys %xsub){
	if ($xsub{$stashname} ne 'Dynamic') {
	   my $stashxsub=$stashname;
	   $stashxsub  =~ s/::/__/g; 
	   print "\tPUSHMARK(sp);\n";
	   print qq/\tXPUSHp("$stashname",strlen("$stashname"));\n/;
	   print qq/\tPUTBACK;\n/;
	   print "\tboot_$stashxsub(aTHX_ NULL);\n";
	   print qq/\tSPAGAIN;\n/;
	}   
    }
    print("\tFREETMPS;\n/* end bootstrapping code */\n");
    print "}\n";
    
print <<'EOT';
static void
dl_init(pTHX)
{
    char *file = __FILE__;
    dTARG;
    djSP;
EOT
    print("/* Dynamicboot strapping code*/\n\tSAVETMPS;\n");
    print("\ttarg=sv_newmortal();\n");
    foreach my $stashname (@@DynaLoader::dl_modules) {
	warn "Loaded $stashname\n";
	if (exists($xsub{$stashname}) && $xsub{$stashname} eq 'Dynamic') {
  	   my $stashxsub=$stashname;
	   $stashxsub  =~ s/::/__/g; 
   	   print "\tPUSHMARK(sp);\n";
   	   print qq/\tXPUSHp("$stashname",/,length($stashname),qq/);\n/;
	   print qq/\tPUTBACK;\n/;
           print "#ifdef DYNALOADER_BOOTSTRAP\n";
	   warn "bootstrapping $stashname added to xs_init\n";
	   print qq/\tperl_call_method("bootstrap",G_DISCARD);\n/;
           print "\n#else\n";
	   print "\tboot_$stashxsub(aTHX_ NULL);\n";
           print "#endif\n";
	   print qq/\tSPAGAIN;\n/;
	}   
    }
    print("\tFREETMPS;\n/* end Dynamic bootstrapping code */\n");
    print "}\n";
d1039 1
d1059 24
a1082 46
sub B::GV::savecv 
{
 my $gv = shift;
 my $package=$gv->STASH->NAME;
 my $name = $gv->NAME;
 my $cv = $gv->CV;
 my $sv = $gv->SV;
 my $av = $gv->AV;
 my $hv = $gv->HV;

 # We may be looking at this package just because it is a branch in the 
 # symbol table which is on the path to a package which we need to save
 # e.g. this is 'Getopt' and we need to save 'Getopt::Long'
 # 
 return unless ($unused_sub_packages{$package});
 return unless ($$cv || $$av || $$sv || $$hv);
 $gv->save;
}

sub mark_package
{    
 my $package = shift;
 unless ($unused_sub_packages{$package})
  {    
   no strict 'refs';
   $unused_sub_packages{$package} = 1;
   if (defined @@{$package.'::ISA'})
    {
     foreach my $isa (@@{$package.'::ISA'}) 
      {
       if ($isa eq 'DynaLoader')
        {
         unless (defined(&{$package.'::bootstrap'}))
          {                    
           warn "Forcing bootstrap of $package\n";
           eval { $package->bootstrap }; 
          }
        }
#      else
        {
         unless ($unused_sub_packages{$isa})
          {
           warn "$isa saved (it is in $package\'s \@@ISA)\n";
           mark_package($isa);
          }
        }
d1084 1
d1086 5
a1090 73
  }
 return 1;
}
     
sub should_save
{
 no strict qw(vars refs);
 my $package = shift;
 $package =~ s/::$//;
 return $unused_sub_packages{$package} = 0 if ($package =~ /::::/);  # skip ::::ISA::CACHE etc.
 # warn "Considering $package\n";#debug
 foreach my $u (grep($unused_sub_packages{$_},keys %unused_sub_packages)) 
  {  
   # If this package is a prefix to something we are saving, traverse it 
   # but do not mark it for saving if it is not already
   # e.g. to get to Getopt::Long we need to traverse Getopt but need
   # not save Getopt
   return 1 if ($u =~ /^$package\:\:/);
  }
 if (exists $unused_sub_packages{$package})
  {
   # warn "Cached $package is ".$unused_sub_packages{$package}."\n"; 
   delete_unsaved_hashINC($package) unless  $unused_sub_packages{$package} ;
   return $unused_sub_packages{$package}; 
  }
 # Omit the packages which we use (and which cause grief
 # because of fancy "goto &$AUTOLOAD" stuff).
 # XXX Surely there must be a nicer way to do this.
 if ($package eq "FileHandle" || $package eq "Config" || 
     $package eq "SelectSaver" || $package =~/^(B|IO)::/) 
  {
   delete_unsaved_hashINC($package);
   return $unused_sub_packages{$package} = 0;
  }
 # Now see if current package looks like an OO class this is probably too strong.
 foreach my $m (qw(new DESTROY TIESCALAR TIEARRAY TIEHASH TIEHANDLE)) 
  {
   if ($package->can($m)) 
    {
     warn "$package has method $m: saving package\n";#debug
     return mark_package($package);
    }
  }
 delete_unsaved_hashINC($package);
 return $unused_sub_packages{$package} = 0;
}
sub delete_unsaved_hashINC{
	my $packname=shift;
	$packname =~ s/\:\:/\//g;
	$packname .= '.pm';
#	warn "deleting $packname" if $INC{$packname} ;# debug
	delete $INC{$packname};
}
sub walkpackages 
{
 my ($symref, $recurse, $prefix) = @@_;
 my $sym;
 my $ref;
 no strict 'vars';
 local(*glob);
 $prefix = '' unless defined $prefix;
 while (($sym, $ref) = each %$symref) 
  {             
   *glob = $ref;
   if ($sym =~ /::$/) 
    {
     $sym = $prefix . $sym;
     if ($sym ne "main::" && &$recurse($sym)) 
      {
       walkpackages(\%glob, $recurse, $sym);
      }
    } 
  }
a1093 9
sub save_unused_subs 
{
 no strict qw(refs);
 &descend_marked_unused;
 warn "Prescan\n";
 walkpackages(\%{"main::"}, sub { should_save($_[0]); return 1 });
 warn "Saving methods\n";
 walksymtable(\%{"main::"}, "savecv", \&should_save);
}
d1095 44
a1138 13
sub save_context
{
 my $curpad_nam = (comppadlist->ARRAY)[0]->save;
 my $curpad_sym = (comppadlist->ARRAY)[1]->save;
 my $inc_hv     = svref_2object(\%INC)->save;
 my $inc_av     = svref_2object(\@@INC)->save;
 my $amagic_generate= amagic_generation;          
 $init->add(   "PL_curpad = AvARRAY($curpad_sym);",
	       "GvHV(PL_incgv) = $inc_hv;",
	       "GvAV(PL_incgv) = $inc_av;",
               "av_store(CvPADLIST(PL_main_cv),0,SvREFCNT_inc($curpad_nam));",
               "av_store(CvPADLIST(PL_main_cv),1,SvREFCNT_inc($curpad_sym));",
  		"PL_amagic_generation= $amagic_generate;" );
a1140 7
sub descend_marked_unused {
    foreach my $pack (keys %unused_sub_packages)
    {
    	mark_package($pack);
    }
}
 
a1141 1
    warn "Starting compile\n";
d1143 5
a1147 1
    seek(STDOUT,0,0); #exclude print statements in BEGIN{} into output
d1150 2
a1151 2
    save_unused_subs();
    my $init_av = init_av->save;
d1154 6
a1159 2
              "PL_initav = (AV *) $init_av;");                                
    save_context();
d1171 1
a1171 1
		    cop => \$copsect, padop => \$padopsect,
d1180 1
a1180 1
		    xpvio => \$xpviosect);
d1183 1
a1183 1
	$$sectref = new B::C::Section $name, \%symtable, 0;
a1184 6
}           

sub mark_unused
{
 my ($arg,$val) = @@_;
 $unused_sub_packages{$arg} = $val;
d1229 1
a1229 1
	    mark_unused($arg,undef);
a1243 2
	} elsif ($opt eq "l") {
	    $max_string_len = $arg;
a1358 9
=item B<-llimit>

Some C compilers impose an arbitrary limit on the length of string
constants (e.g. 2048 characters for Microsoft Visual C++).  The
B<-llimit> options tells the C backend not to generate string literals
exceeding that limit.

=back

d1368 1
a1368 1
    perl -MO=C,-v,-DcA,-l2048 bar.pl > /dev/null
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d228 1
a228 1
    $listopsect->add(sprintf("s\\_%x, s\\_%x, NULL, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x",
d231 2
a232 1
			     $op->private, ${$op->first}, ${$op->last}));
d258 1
a258 1
    $loopsect->add(sprintf("s\\_%x, s\\_%x, NULL, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x, s\\_%x, s\\_%x, s\\_%x",
d262 1
a262 1
			   ${$op->redoop}, ${$op->nextop},
d354 1
a354 1
    $pmopsect->add(sprintf("s\\_%x, s\\_%x, NULL, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x, %s, %s, 0, 0, 0x%x, 0x%x",
d357 1
a357 1
			   ${$op->first}, ${$op->last}, 
d1023 1
d1025 1
a1025 1
	dSP;
d1053 1
a1053 1
    NV		xnv_nv;		/* numeric value, if any */
d1060 2
a1061 2
    void      (*xcv_xsub) (pTHXo_ CV*);
    ANY		xcv_xsubany;
d1177 1
a1177 1
    dSP;
d1213 1
a1213 1
    dSP;
d1341 1
a1341 1
   if (UNIVERSAL::can($package, $m))
d1371 1
a1371 1
     if ($sym ne "main::" && $sym ne "<none>::" && &$recurse($sym)) 
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a8 3

our $VERSION = '1.01';

d16 1
a16 1
 push @@$o, { values => [] };
d21 1
a21 1
{
d23 1
a23 1
 push(@@{$section->[-1]{values}},@@_);
d27 1
a27 1
{
d29 1
a29 1
 return scalar(@@{$section->[-1]{values}})-1;
d33 1
a33 1
{
d37 1
a37 2
 my $i;
 foreach (@@{$section->[-1]{values}})
d40 1
a40 2
   printf $fh $format, $_, $i;
   ++$i;
a43 101
package B::C::InitSection;

# avoid use vars
@@B::C::InitSection::ISA = qw(B::C::Section);

sub new {
    my $class = shift;
    my $max_lines = 10000; #pop;
    my $section = $class->SUPER::new( @@_ );

    $section->[-1]{evals} = [];
    $section->[-1]{chunks} = [];
    $section->[-1]{nosplit} = 0;
    $section->[-1]{current} = [];
    $section->[-1]{count} = 0;
    $section->[-1]{max_lines} = $max_lines;

    return $section;
}

sub split {
    my $section = shift;
    $section->[-1]{nosplit}--
      if $section->[-1]{nosplit} > 0;
}

sub no_split {
    shift->[-1]{nosplit}++;
}

sub inc_count {
    my $section = shift;

    $section->[-1]{count} += $_[0];
    # this is cheating
    $section->add();
}

sub add {
    my $section = shift->[-1];
    my $current = $section->{current};
    my $nosplit = $section->{nosplit};

    push @@$current, @@_;
    $section->{count} += scalar(@@_);
    if( !$nosplit && $section->{count} >= $section->{max_lines} ) {
        push @@{$section->{chunks}}, $current;
        $section->{current} = [];
        $section->{count} = 0;
    }
}

sub add_eval {
    my $section = shift;
    my @@strings = @@_;

    foreach my $i ( @@strings ) {
        $i =~ s/\"/\\\"/g;
    }
    push @@{$section->[-1]{evals}}, @@strings;
}

sub output {
    my( $section, $fh, $format, $init_name ) = @@_;
    my $sym = $section->symtable || {};
    my $default = $section->default;
    push @@{$section->[-1]{chunks}}, $section->[-1]{current};

    my $name = "aaaa";
    foreach my $i ( @@{$section->[-1]{chunks}} ) {
        print $fh <<"EOT";
static int perl_init_${name}()
{
	dTARG;
	dSP;
EOT
        foreach my $j ( @@$i ) {
            $j =~ s{(s\\_[0-9a-f]+)}
                   { exists($sym->{$1}) ? $sym->{$1} : $default; }ge;
            print $fh "\t$j\n";
        }
        print $fh "\treturn 0;\n}\n";

        $section->SUPER::add( "perl_init_${name}();" );
        ++$name;
    }
    foreach my $i ( @@{$section->[-1]{evals}} ) {
        $section->SUPER::add( sprintf q{eval_pv("%s",1);}, $i );
    }

    print $fh <<"EOT";
static int ${init_name}()
{
	dTARG;
	dSP;
EOT
    $section->SUPER::output( $fh, $format );
    print $fh "\treturn 0;\n}\n";
}


a45 10
our %REGEXP;

{ # block necessary for caller to work
    my $caller = caller;
    if( $caller eq 'O' ) {
        require XSLoader;
        XSLoader::load( 'B::C' );
    }
}

d52 2
a53 2
	 threadsv_names main_cv init_av end_av regex_padav opnumber amagic_generation
	 AVf_REAL HEf_SVKEY SVf_POK SVf_ROK CVf_CONST);
a64 1
my $cv_index = 0;
a72 1
my $use_xsloader;
a74 5
my $optimize_ppaddr = 0;
my $optimize_warn_sv = 0;
my $use_perl_script_name = 0;
my $save_data_fh = 0;
my $save_sig = 0;
a77 2
my $ithreads = $Config{useithreads} eq 'define';

a88 3
my @@op_sections = \( $binopsect, $condopsect, $copsect, $padopsect, $listopsect,
                     $logopsect, $loopsect, $opsect, $pmopsect, $pvopsect, $svopsect,
                     $unopsect );
a138 8
sub savere {
    my $re = shift;
    my $sym = sprintf("re%d", $re_index++);
    $decl->add(sprintf("static char *$sym = %s;", cstring($re)));

    return ($sym,length(pack "a*",$re));
}

d140 2
a141 1
    my $pv = pack "a*", shift;
d144 6
a149 14
    if ($pv_copy_on_grow) {
        $pvsym = sprintf("pv%d", $pv_index++);

        if( defined $max_string_len && length($pv) > $max_string_len ) {
            my $chars = join ', ', map { cchar $_ } split //, $pv;
            $decl->add(sprintf("static char %s[] = { %s };", $pvsym, $chars));
        }
        else {
	     my $cstring = cstring($pv);
            if ($cstring ne "0") { # sic
                $decl->add(sprintf("static char %s[] = %s;",
                                   $pvsym, $cstring));
	    }
        }
d151 1
a151 1
	$pvmax = length(pack "a*",$pv) + 1;
a155 39
sub save_rv {
    my $sv = shift;
#    confess "Can't save RV: not ROK" unless $sv->FLAGS & SVf_ROK;
    my $rv = $sv->RV->save;

    $rv =~ s/^\(([AGHS]V|IO)\s*\*\)\s*(\&sv_list.*)$/$2/;

    return $rv;
}

# savesym, pvmax, len, pv
sub save_pv_or_rv {
    my $sv = shift;

    my $rok = $sv->FLAGS & SVf_ROK;
    my $pok = $sv->FLAGS & SVf_POK;
    my( $len, $pvmax, $savesym, $pv ) = ( 0, 0 );
    if( $rok ) {
       $savesym = '(char*)' . save_rv( $sv );
    }
    else {
       $pv = $pok ? (pack "a*", $sv->PV) : undef;
       $len = $pok ? length($pv) : 0;
       ($savesym, $pvmax) = $pok ? savepv($pv) : ( 'NULL', 0 );
    }

    return ( $savesym, $pvmax, $len, $pv );
}

# see also init_op_ppaddr below; initializes the ppaddt to the
# OpTYPE; init_op_ppaddr iterates over the ops and sets
# op_ppaddr to PL_ppaddr[op_ppaddr]; this avoids an explicit assignmente
# in perl_init ( ~10 bytes/op with GCC/i386 )
sub B::OP::fake_ppaddr {
    return $optimize_ppaddr ?
      sprintf("INT2PTR(void*,OP_%s)", uc( $_[0]->name ) ) :
      'NULL';
}

d167 2
a168 2
    $opsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x",
			 ${$op->next}, ${$op->sibling}, $op->fake_ppaddr, $op->targ,
d171 1
a171 2
    $init->add(sprintf("op_list[$ix].op_ppaddr = %s;", $op->ppaddr))
        unless $optimize_ppaddr;
d182 2
a183 2
    $opsect->add(sprintf("%s, %s, %s, %u, %u, %u, 0x%x, 0x%x",
			 $op->next, $op->sibling, $op->fake_ppaddr, $op->targ,
d186 1
a186 2
    $init->add(sprintf("op_list[$ix].op_ppaddr = %s;", $op->ppaddr))
        unless $optimize_ppaddr;
d202 2
a203 2
    $unopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, s\\_%x",
			   ${$op->next}, ${$op->sibling}, $op->fake_ppaddr,
d207 1
a207 2
    $init->add(sprintf("unop_list[$ix].op_ppaddr = %s;", $op->ppaddr))
        unless $optimize_ppaddr;
d215 2
a216 2
    $binopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x",
			    ${$op->next}, ${$op->sibling}, $op->fake_ppaddr,
d220 1
a220 2
    $init->add(sprintf("binop_list[$ix].op_ppaddr = %s;", $op->ppaddr))
        unless $optimize_ppaddr;
d228 2
a229 2
    $listopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x",
			     ${$op->next}, ${$op->sibling}, $op->fake_ppaddr,
d233 1
a233 2
    $init->add(sprintf("listop_list[$ix].op_ppaddr = %s;", $op->ppaddr))
        unless $optimize_ppaddr;
d241 2
a242 2
    $logopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x",
			    ${$op->next}, ${$op->sibling}, $op->fake_ppaddr,
d246 1
a246 2
    $init->add(sprintf("logop_list[$ix].op_ppaddr = %s;", $op->ppaddr))
        unless $optimize_ppaddr;
d257 2
a258 2
    $loopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x, s\\_%x, s\\_%x, s\\_%x",
			   ${$op->next}, ${$op->sibling}, $op->fake_ppaddr,
d264 1
a264 2
    $init->add(sprintf("loop_list[$ix].op_ppaddr = %s;", $op->ppaddr))
        unless $optimize_ppaddr;
d272 2
a273 2
    $pvopsect->add(sprintf("s\\_%x, s\\_%x, %s,  %u, %u, %u, 0x%x, 0x%x, %s",
			   ${$op->next}, ${$op->sibling}, $op->fake_ppaddr,
d277 1
a277 2
    $init->add(sprintf("pvop_list[$ix].op_ppaddr = %s;", $op->ppaddr))
        unless $optimize_ppaddr;
d285 3
a287 5
    my $sv = $op->sv;
    my $svsym = '(SV*)' . $sv->save;
    my $is_const_addr = $svsym =~ m/Null|\&/;
    $svopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, %s",
			   ${$op->next}, ${$op->sibling}, $op->fake_ppaddr,
d289 1
a289 2
			   $op->private,
                           ( $is_const_addr ? $svsym : 'Nullsv' )));
d291 2
a292 4
    $init->add(sprintf("svop_list[$ix].op_ppaddr = %s;", $op->ppaddr))
        unless $optimize_ppaddr;
    $init->add("svop_list[$ix].op_sv = $svsym;")
        unless $is_const_addr;
d300 2
a301 2
    $padopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, %d",
			   ${$op->next}, ${$op->sibling}, $op->fake_ppaddr,
d303 2
a304 1
			   $op->private,$op->padix));
d306 1
a306 3
    $init->add(sprintf("padop_list[$ix].op_ppaddr = %s;", $op->ppaddr))
        unless $optimize_ppaddr;
#    $init->add(sprintf("padop_list[$ix].op_padix = %ld;", $op->padix));
d316 2
a317 29
    # shameless cut'n'paste from B::Deparse
    my $warn_sv;
    my $warnings = $op->warnings;
    my $is_special = $warnings->isa("B::SPECIAL");
    if ($is_special && $$warnings == 4) {
        # use warnings 'all';
        $warn_sv = $optimize_warn_sv ?
            'INT2PTR(SV*,1)' :
            'pWARN_ALL';
    }
    elsif ($is_special && $$warnings == 5) {
        # no warnings 'all';
        $warn_sv = $optimize_warn_sv ?
            'INT2PTR(SV*,2)' :
            'pWARN_NONE';
    }
    elsif ($is_special) {
        # use warnings;
        $warn_sv = $optimize_warn_sv ?
            'INT2PTR(SV*,3)' :
            'pWARN_STD';
    }
    else {
        # something else
        $warn_sv = $warnings->save;
    }

    $copsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, %s, NULL, NULL, %u, %d, %u, %s",
			  ${$op->next}, ${$op->sibling}, $op->fake_ppaddr,
d320 1
a320 2
			  $op->arybase, $op->line,
                          ( $optimize_warn_sv ? $warn_sv : 'NULL' )));
d322 1
a322 4
    $init->add(sprintf("cop_list[$ix].op_ppaddr = %s;", $op->ppaddr))
        unless $optimize_ppaddr;
    $init->add(sprintf("cop_list[$ix].cop_warnings = %s;", $warn_sv ))
        unless $optimize_warn_sv;
a324 1

d334 1
a334 1
    my $replrootfield;
d338 1
a338 5
    # under ithreads, OP_PUSHRE.op_replroot is an integer
    $replrootfield = sprintf("s\\_%x", $$replroot) if ref $replroot;
    if($ithreads && $op->name eq "pushre") {
        $replrootfield = "INT2PTR(OP*,${replroot})";
    } elsif ($$replroot) {
d353 2
a354 2
    $pmopsect->add(sprintf("s\\_%x, s\\_%x, %s, %u, %u, %u, 0x%x, 0x%x, s\\_%x, s\\_%x, %s, %s, 0, %u, 0x%x, 0x%x, 0x%x",
			   ${$op->next}, ${$op->sibling}, $op->fake_ppaddr, $op->targ,
d358 1
a358 2
                           ( $ithreads ? $op->pmoffset : 0 ),
			   $op->pmflags, $op->pmpermflags, $op->pmdynflags ));
d360 1
a360 2
    $init->add(sprintf("$pm.op_ppaddr = %s;", $ppaddr))
        unless $optimize_ppaddr;
d363 4
a366 3
	my( $resym, $relen ) = savere( $re );
	$init->add(sprintf("PM_SETRE(&$pm,pregcomp($resym, $resym + %u, &$pm));",
			   $relen));
d395 1
a395 1
	return savesym($sv, "(void*)Nullsv /* XXX */");
a425 2
    # work with byte offsets/lengths
    my $pv = pack "a*", $pv;
d469 4
a472 2
    my( $savesym, $pvmax, $len, $pv ) = save_pv_or_rv( $sv );
    $xpvivsect->add(sprintf("%s, %u, %u, %d", $savesym, $len, $pvmax, $sv->IVX));
d475 1
a475 1
    if (defined($pv) && !$pv_copy_on_grow) {
d486 4
a489 1
    my( $savesym, $pvmax, $len, $pv ) = save_pv_or_rv( $sv );
d493 1
a493 1
			    $savesym, $len, $pvmax, $sv->IVX, $val));
d496 1
a496 1
    if (defined($pv) && !$pv_copy_on_grow) {
d507 1
a507 1
    my $pv = pack "a*", ($sv->PV . "\0" . $sv->TABLE);
d526 4
a529 2
    my( $savesym, $pvmax, $len, $pv ) = save_pv_or_rv( $sv );
    $xpvsect->add(sprintf("%s, %u, %u", $savesym, $len, $pvmax));
d532 1
a532 1
    if (defined($pv) && !$pv_copy_on_grow) {
d543 3
a545 2
    my( $savesym, $pvmax, $len, $pv ) = save_pv_or_rv( $sv );

d547 1
a547 2
                            $savesym, $len, $pvmax,
                            $sv->IVX, $sv->NVX));
d549 4
a552 4
                         $xpvmgsect->index, $sv->REFCNT , $sv->FLAGS));
    if (defined($pv) && !$pv_copy_on_grow) {
        $init->add(savepvn(sprintf("xpvmg_list[%d].xpv_pv",
                                   $xpvmgsect->index), $pv));
d574 1
d582 1
a582 6

        unless( $type eq 'r' ) {
          $obj = $mg->OBJ;
          $obj->save;
        }

d588 1
a588 15
        }elsif( $type eq 'r' ){
            my $rx = $mg->REGEX;
            my $pmop = $REGEXP{$rx};

            confess "PMOP not found for REGEXP $rx" unless $pmop;

            my( $resym, $relen ) = savere( $mg->precomp );
            my $pmsym = $pmop->save;
            $init->add( split /\n/, sprintf <<CODE, $$sv, cchar($type), cstring($ptr) );
{
    REGEXP* rx = pregcomp($resym, $resym + $relen, (PMOP*)$pmsym);
    sv_magic((SV*)s\\_%x, (SV*)rx, %s, %s, %d);
}
CODE
        }else{
d599 3
a601 14
    my $rv = save_rv( $sv );
    # GVs need to be handled at runtime
    if( ref( $sv->RV ) eq 'B::GV' ) {
        $xrvsect->add( "(SV*)Nullgv" );
        $init->add(sprintf("xrv_list[%d].xrv_rv = (SV*)%s;\n", $xrvsect->index, $rv));
    }
    # and stashes, too
    elsif( $sv->RV->isa( 'B::HV' ) && $sv->RV->NAME ) {
        $xrvsect->add( "(SV*)Nullhv" );
        $init->add(sprintf("xrv_list[%d].xrv_rv = (SV*)%s;\n", $xrvsect->index, $rv));
    }
    else {
        $xrvsect->add($rv);
    }
a644 13
    my $isconst = $cv->CvFLAGS & CVf_CONST;
    if( $isconst ) {
        my $value = $cv->XSUBANY;
        my $stash = $gv->STASH;
        my $vsym = $value->save;
        my $stsym = $stash->save;
        my $name = cstring($cvname);
        $decl->add( "static CV* cv$cv_index;" );
        $init->add( "cv$cv_index = newCONSTSUB( $stsym, NULL, $vsym );" );
        my $sym = savesym( $cv, "cv$cv_index" );
        $cv_index++;
        return $sym;
    }
d648 1
a648 1
    if (!$isconst && $cvxsub && ($cvname ne "INIT")) {
d652 2
a653 2
          { 
           my $file = $gv->FILE;
d656 1
a656 10
           # if it not isa('DynaLoader'), it should hopefully be XSLoaded
           # ( attributes being an exception, of course )
           if( $stashname ne 'attributes' &&
               !UNIVERSAL::isa($stashname,'DynaLoader') ) {
            $xsub{$stashname}='Dynamic-XSLoaded';
            $use_xsloader = 1;
           }
           else {
            $xsub{$stashname}='Dynamic';
           }
d659 1
a659 10
          }
         else
          {
           # XSUBs for IO::File, IO::Handle, IO::Socket,
           # IO::Seekable and IO::Poll
           # are defined in IO.xs, so let's bootstrap it
           svref_2object( \&IO::bootstrap )->save
            if grep { $stashname eq $_ } qw(IO::File IO::Handle IO::Socket
                                              IO::Seekable IO::Poll);
          }
d743 1
a743 6
    if( $ithreads ) {
        $init->add( savepvn( "CvFILE($sym)", $cv->FILE) );
    }
    else {
        $init->add(sprintf("CvFILE($sym) = %s;", cstring($cv->FILE)));
    }
d752 1
a752 1
			  $sv_ix, $xpvcv_ix, $cv->REFCNT +1*0 , $cv->FLAGS));
d769 1
a769 2
    my $fullname = $gv->STASH->NAME . "::" . $gvname;
    my $name = cstring($fullname);
d781 1
a781 1
	       sprintf("SvFLAGS($sym) = 0x%x;", $gv->FLAGS ),
d784 1
a784 2
    # XXX hack for when Perl accesses PVX of GVs
    $init->add("SvPVX($sym) = emptystring;\n");
a786 1
    # XXX will always be > 1!!!
d788 1
a788 1
    $init->add(sprintf("SvREFCNT($sym) += %u;", $refcnt - 1 )) if $refcnt > 1;
a791 1
    # XXX B::walksymtable creates an extra reference to the GV
d796 1
a796 23
    # some non-alphavetic globs require some parts to be saved
    # ( ex. %!, but not $! )
    sub Save_HV() { 1 }
    sub Save_AV() { 2 }
    sub Save_SV() { 4 }
    sub Save_CV() { 8 }
    sub Save_FORM() { 16 }
    sub Save_IO() { 32 }
    my $savefields = 0;
    if( $gvname !~ /^([^A-Za-z]|STDIN|STDOUT|STDERR|ARGV|SIG|ENV)$/ ) {
        $savefields = Save_HV|Save_AV|Save_SV|Save_CV|Save_FORM|Save_IO;
    }
    elsif( $gvname eq '!' ) {
        $savefields = Save_HV;
    }
    # attributes::bootstrap is created in perl_parse
    # saving it would overwrite it, because perl_init() is
    # called after perl_parse()
    $savefields&=~Save_CV if $fullname eq 'attributes::bootstrap';

    # save it
    # XXX is that correct?
    if (defined($egvsym) && $egvsym !~ m/Null/ ) {
d800 1
a800 1
    } elsif ($savefields) {
d804 1
a804 1
	if ($$gvsv && $savefields&Save_SV) {
d810 1
a810 1
	if ($$gvav && $savefields&Save_AV) {
d816 1
a816 1
	if ($$gvhv && $savefields&Save_HV) {
d822 1
a822 1
	if ($$gvcv && $savefields&Save_CV) {
d832 1
a832 1
	    } else {
d840 1
a840 1
	if ($$gvform && $savefields&Save_FORM) {
d846 1
a846 1
	if ($$gvio && $savefields&Save_IO) {
a848 6
            if( $fullname =~ m/::DATA$/ && $save_data_fh ) {
                no strict 'refs';
                my $fh = *{$fullname}{IO};
                use strict 'refs';
                $gvio->save_data( $fullname, <$fh> ) if $fh->opened;
            }
a853 1

d880 1
a880 1
#	my @@names = map($_->save, @@array);
a883 15

        # micro optimization: op/pat.t ( and other code probably )
        # has very large pads ( 20k/30k elements ) passing them to
        # ->add is a performance bottleneck: passing them as a
        # single string cuts runtime from 6min20sec to 40sec

        # you want to keep this out of the no_split/split
        # map("\t*svp++ = (SV*)$_;", @@names),
        my $acc = '';
        foreach my $i ( 0..$#array ) {
              $acc .= "\t*svp++ = (SV*)" . $array[$i]->save . ";\n\t";
        }
        $acc .= "\n";

        $init->no_split;
d888 3
a890 3
		   "\tsvp = AvARRAY(av);" );
        $init->add($acc);
	$init->add("\tAvFILLp(av) = $fill;",
a891 5
        $init->split;
        # we really added a lot of lines ( B::C::InitSection->add
        # should really scan for \n, but that would slow
        # it down
        $init->inc_count( $#array );
a935 1
        $init->no_split;
d940 1
a940 2
			       cstring($key),length(pack "a*",$key),
                               $value, hash($key)));
a944 1
        $init->split;
a949 18
sub B::IO::save_data {
    my( $io, $globname, @@data ) = @@_;
    my $data = join '', @@data;

    # XXX using $DATA might clobber it!
    my $sym = svref_2object( \\$data )->save;
    $init->add( split /\n/, <<CODE );
    {
        GV* gv = (GV*)gv_fetchpv( "$globname", TRUE, SVt_PV );
        SV* sv = $sym;
        GvSV( gv ) = sv;
    }
CODE
    # for PerlIO::scalar
    $use_xsloader = 1;
    $init->add_eval( sprintf 'open(%s, "<", $%s)', $globname, $globname );
}

a965 10
    # deal with $x = *STDIN/STDOUT/STDERR{IO}
    my $perlio_func;
    foreach ( qw(stdin stdout stderr) ) {
        $io->IsSTD($_) and $perlio_func = $_;
    }
    if( $perlio_func ) {
        $init->add( "IoIFP(${sym})=PerlIO_${perlio_func}();" );
        $init->add( "IoOFP(${sym})=PerlIO_${perlio_func}();" );
    }

a1005 3
    # XXX hack for when Perl accesses PVX of GVs
    print 'Static char emptystring[] = "\0";';

d1014 1
a1014 1
	    $section->output(\*STDOUT, "\t{ %s }, /* %d */\n");
d1019 8
a1026 1
    $init->output(\*STDOUT, "\t%s\n", $init_name );
d1058 1
a1058 1
    void      (*xcv_xsub) (pTHX_ CV*);
d1065 1
a1065 1
#ifdef USE_5005THREADS
d1068 1
a1068 1
#endif /* USE_5005THREADS */
d1080 1
a1095 2
#undef OP_MAPSTART
#define OP_MAPSTART OP_GREPSTART
a1104 46
sub init_op_addr {
    my( $op_type, $num ) = @@_;
    my $op_list = $op_type."_list";

    $init->add( split /\n/, <<EOT );
    {
        int i;

        for( i = 0; i < ${num}; ++i )
        {
            ${op_list}\[i].op_ppaddr = PL_ppaddr[INT2PTR(int,${op_list}\[i].op_ppaddr)];
        }
    }
EOT
}

sub init_op_warn {
    my( $op_type, $num ) = @@_;
    my $op_list = $op_type."_list";

    # for resons beyond imagination, MSVC5 considers pWARN_ALL non-const
    $init->add( split /\n/, <<EOT );
    {
        int i;

        for( i = 0; i < ${num}; ++i )
        {
            switch( (int)(${op_list}\[i].cop_warnings) )
            {
            case 1:
                ${op_list}\[i].cop_warnings = pWARN_ALL;
                break;
            case 2:
                ${op_list}\[i].cop_warnings = pWARN_NONE;
                break;
            case 3:
                ${op_list}\[i].cop_warnings = pWARN_STD;
                break;
            default:
                break;
            }
        }
    }
EOT
}

a1106 5
/* if USE_IMPLICIT_SYS, we need a 'real' exit */
#if defined(exit)
#undef exit
#endif

a1112 3
    GV* tmpgv;
    SV* tmpsv;
    int options_count;
d1115 1
a1115 1

a1122 14
EOT
    if( $ithreads ) {
        # XXX init free elems!
        my $pad_len = regex_padav->FILL + 1 - 1; # first is an avref

        print <<EOT;
#ifdef USE_ITHREADS
    for( i = 0; i < $pad_len; ++i ) {
        av_push( PL_regex_padav, newSViv(0) );
    }
    PL_regex_pad = AvARRAY( PL_regex_padav );
#endif
EOT
    }
a1123 1
    print <<'EOT';
d1130 2
a1132 2
#else
#define EXTRA_OPTIONS 4
a1134 1

a1137 10
    options_count = 3;
EOT
    # honour -T
    print <<EOT;
    if( ${^TAINT} ) {
        fakeargv[options_count] = "-T";
        ++options_count;
    }
EOT
    print <<'EOT';
d1139 1
a1139 2
    fakeargv[options_count] = "--";
    ++options_count;
d1142 4
a1145 4
	fakeargv[i + options_count - 1] = argv[i];
    fakeargv[argc + options_count - 1] = 0;

    exitstatus = perl_parse(my_perl, xs_init, argc + options_count - 1,
a1146 1

d1150 2
a1151 31
    TAINT;
EOT

    if( $use_perl_script_name ) {
        my $dollar_0 = $0;
        $dollar_0 =~ s/\\/\\\\/g;
        $dollar_0 = '"' . $dollar_0 . '"';

        print <<EOT;
    if ((tmpgv = gv_fetchpv("0",TRUE, SVt_PV))) {/* $0 */
        tmpsv = GvSV(tmpgv);
        sv_setpv(tmpsv, ${dollar_0});
        SvSETMAGIC(tmpsv);
    }
EOT
    }

    print <<'EOT';
    if ((tmpgv = gv_fetchpv("\030",TRUE, SVt_PV))) {/* $^X */
        tmpsv = GvSV(tmpgv);
#ifdef WIN32
        sv_setpv(tmpsv,"perl.exe");
#else
        sv_setpv(tmpsv,"perl");
#endif
        SvSETMAGIC(tmpsv);
    }

    TAINT_NOT;

    /* PL_main_cv = PL_compcv; */
d1184 1
a1184 1
    print "#ifdef USE_DYNAMIC_LOADING\n";
d1192 1
a1192 1
	if ($xsub{$stashname} !~ m/Dynamic/ ) {
d1217 1
a1217 1
	if (exists($xsub{$stashname}) && $xsub{$stashname} =~ m/Dynamic/) {
d1223 1
a1223 1
           print "#ifdef USE_DYNAMIC_LOADING\n";
d1225 2
a1226 7
           if( $xsub{$stashname} eq 'Dynamic' ) {
              print qq/\tperl_call_method("bootstrap",G_DISCARD);\n/;
           }
           else {
              print qq/\tperl_call_pv("XSLoader::load",G_DISCARD);\n/;
           }
           print "#else\n";
a1263 2
 my $fullname = $gv->STASH->NAME . "::" . $gv->NAME;

a1410 4
    # this is mainly for the test suite
    my $warner = $SIG{__WARN__};
    local $SIG{__WARN__} = sub { print STDERR @@_ };

a1416 26
    # XSLoader was used, force saving of XSLoader::load
    if( $use_xsloader ) {
        my $cv = svref_2object( \&XSLoader::load );
        $cv->save;
    }
    # save %SIG ( in case it was set in a BEGIN block )
    if( $save_sig ) {
        local $SIG{__WARN__} = $warner;
        $init->no_split;
        $init->add("{", "\tHV* hv = get_hv(\"main::SIG\",1);" );
        foreach my $k ( keys %SIG ) {
            next unless ref $SIG{$k};
            my $cv = svref_2object( \$SIG{$k} );
            my $sv = $cv->save;
            $init->add('{',sprintf 'SV* sv = (SV*)%s;', $sv );
            $init->add(sprintf("\thv_store(hv, %s, %u, %s, %s);",
                               cstring($k),length(pack "a*",$k),
                               'sv', hash($k)));
            $init->add('mg_set(sv);','}');
        }
        $init->add('}');
        $init->split;
    }
    # honour -w
    $init->add( sprintf "    PL_dowarn = ( %s ) ? G_WARN_ON : G_WARN_OFF;", $^W );
    #
a1417 1
    my $end_av = end_av->save;
d1420 1
a1420 2
              "PL_initav = (AV *) $init_av;",
              "PL_endav = (AV*) $end_av;");
a1421 12
    # init op addrs ( must be the last action, otherwise
    # some ops might not be initialized
    if( $optimize_ppaddr ) {
        foreach my $i ( @@op_sections ) {
            my $section = $$i;
            next unless $section->index >= 0;
            init_op_addr( $section->name, $section->index + 1);
        }
    }
    init_op_warn( $copsect->name, $copsect->index + 1)
      if $optimize_warn_sv && $copsect->index >= 0;

d1431 1
a1431 1
    my @@sections = (decl => \$decl, sym => \$symsect,
d1447 1
a1447 2
    $init = new B::C::InitSection 'init', \%symtable, 0;
}
a1457 12
    my @@eval_at_startup;
    my %option_map = ( 'cog' => \$pv_copy_on_grow,
                       'save-data' => \$save_data_fh,
                       'ppaddr' => \$optimize_ppaddr,
                       'warn-sv' => \$optimize_warn_sv,
                       'use-script-name' => \$use_perl_script_name,
                       'save-sig-hash' => \$save_sig,
                     );
    my %optimization_map = ( 0 => [ qw() ], # special case
                             1 => [ qw(-fcog) ],
                             2 => [ qw(-fwarn-sv -fppaddr) ],
                           );
d1500 5
a1504 8
            $arg =~ m/(no-)?(.*)/;
            my $no = defined($1) && $1 eq 'no-';
            $arg = $no ? $2 : $arg;
            if( exists $option_map{$arg} ) {
                ${$option_map{$arg}} = !$no;
            } else {
                die "Invalid optimization '$arg'";
            }
d1507 5
a1511 8
            my @@opt;
            foreach my $i ( 1 .. $arg ) {
                push @@opt, @@{$optimization_map{$i}}
                    if exists $optimization_map{$i};
            }
            unshift @@options, @@opt;
        } elsif ($opt eq "e") {
            push @@eval_at_startup, $arg;
a1516 3
    foreach my $i ( @@eval_at_startup ) {
        $init->add_eval( $i );
    }
d1614 1
a1614 5
Force options/optimisations on or off one at a time. You can explicitly
disable an option using B<-fno-option>. All options default to
B<disabled>.

=over 4
d1620 1
a1620 13
=item B<-fsave-data>

Save package::DATA filehandles ( only available with PerlIO ).

=item B<-fppaddr>

Optimize the initialization of op_ppaddr.

=item B<-fwarn-sv>

Optimize the initialization of cop_warnings.

=item B<-fuse-script-name>
d1622 1
a1622 7
Use the script name instead of the program name as $0.

=item B<-fsave-sig-hash>

Save compile-time modifications to the %SIG hash.

=back
d1626 2
a1627 17
Optimisation level (n = 0, 1, 2, ...). B<-O> means B<-O1>.

=over 4

=item B<-O0>

Disable all optimizations.

=item B<-O1>

Enable B<-fcog>.

=item B<-O2>

Enable B<-fppaddr>, B<-fwarn-sv>.

=back
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d10 1
a10 1
our $VERSION = '1.02';
d1015 1
a1015 1
    $symsect->add(sprintf("xpvcvix%d\t%s, %u, 0, %d, %s, 0, Nullhv, Nullhv, %s, s\\_%x, $xsub, $xsubany, Nullgv, \"\", %d, s\\_%x, (CV*)s\\_%x, 0x%x, 0x%x",
d1018 1
a1018 2
                        $$padlist, ${$cv->OUTSIDE}, $cv->CvFLAGS,
			$cv->OUTSIDE_SEQ));
a1442 3
    U32		xcv_outside_seq; /* the COP sequence (at the point of our
				  * compilation) in the lexically enclosing
				  * sub */
a1621 9
    else {
	print <<EOT;
    if ((tmpgv = gv_fetchpv("0",TRUE, SVt_PV))) {/* $0 */
        tmpsv = GvSV(tmpgv);
        sv_setpv(tmpsv, argv[0]);
        SvSETMAGIC(tmpsv);
    }
EOT
    }
d1853 1
a1856 1
   local(*glob);
@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@d8 1
d10 1
a10 5
package B::C;

our $VERSION = '1.04';

package B::C::Section;
d229 9
a337 32
# This pair is needed becase B::FAKEOP::save doesn't scalar dereference
# $op->next and $op->sibling

{
  # For 5.9 the hard coded text is the values for op_opt and op_static in each
  # op.  The value of op_opt is irrelevant, and the value of op_static needs to
  # be 1 to tell op_free that this is a statically defined op and that is
  # shouldn't be freed.

  # For 5.8:
  # Current workaround/fix for op_free() trying to free statically
  # defined OPs is to set op_seq = -1 and check for that in op_free().
  # Instead of hardwiring -1 in place of $op->seq, we use $op_seq
  # so that it can be changed back easily if necessary. In fact, to
  # stop compilers from moaning about a U16 being initialised with an
  # uncast -1 (the printf format is %d so we can't tweak it), we have
  # to "know" that op_seq is a U16 and use 65535. Ugh.

  my $static = $] > 5.009 ? '0, 1, 0' : sprintf "%u", 65535;
  sub B::OP::_save_common_middle {
    my $op = shift;
    sprintf ("%s, %u, %u, $static, 0x%x, 0x%x",
	     $op->fake_ppaddr, $op->targ, $op->type, $op->flags, $op->private);
  }
}

sub B::OP::_save_common {
 my $op = shift;
 return sprintf("s\\_%x, s\\_%x, %s",
		${$op->next}, ${$op->sibling}, $op->_save_common_middle);
}

d349 3
a351 1
    $opsect->add($op->_save_common);
d365 3
a367 2
    $opsect->add(sprintf("%s, %s, %s",
			 $op->next, $op->sibling, $op->_save_common_middle));
d386 4
a389 1
    $unopsect->add(sprintf("%s, s\\_%x", $op->_save_common, ${$op->first}));
d400 4
a403 2
    $binopsect->add(sprintf("%s, s\\_%x, s\\_%x",
			    $op->_save_common, ${$op->first}, ${$op->last}));
d414 4
a417 2
    $listopsect->add(sprintf("%s, s\\_%x, s\\_%x",
			     $op->_save_common, ${$op->first}, ${$op->last}));
d428 4
a431 2
    $logopsect->add(sprintf("%s, s\\_%x, s\\_%x",
			    $op->_save_common, ${$op->first}, ${$op->other}));
d445 4
a448 2
    $loopsect->add(sprintf("%s, s\\_%x, s\\_%x, s\\_%x, s\\_%x, s\\_%x",
			   $op->_save_common, ${$op->first}, ${$op->last},
d461 4
a464 1
    $pvopsect->add(sprintf("%s, %s", $op->_save_common, cstring($op->pv)));
d478 5
a482 2
    $svopsect->add(sprintf("%s, %s", $op->_save_common,
			   ( $is_const_addr ? $svsym : 'Nullsv' )));
d495 4
a498 2
    $padopsect->add(sprintf("%s, %d",
			    $op->_save_common, $op->padix));
d539 4
a542 2
    $copsect->add(sprintf("%s, %s, NULL, NULL, %u, %d, %u, %s",
			  $op->_save_common, cstring($op->label), $op->cop_seq,
d585 4
a588 2
    $pmopsect->add(sprintf("%s, s\\_%x, s\\_%x, %s, %s, 0, %u, 0x%x, 0x%x, 0x%x",
			   $op->_save_common, ${$op->first}, ${$op->last},
a1438 2
EOT
    print <<'EOT' if $] < 5.009;
a1442 2
EOT
    print <<'EOT';
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d11 1
a11 1
our $VERSION = '1.04_01';
d172 1
a172 1
	 HEf_SVKEY SVf_POK SVf_ROK CVf_CONST);
d662 1
a662 1
	push @@res, sprintf("Newx(%s,%u,char);", $dest, length($pv)+1);
d1185 3
a1187 3
    my $line = "0, -1, -1, 0, 0.0, 0, Nullhv, 0, 0";
    $line .= sprintf(", 0x%x", $av->AvFLAGS) if $] < 5.009;
    $xpvavsect->add($line);
d1193 2
a1194 5
    if ($debug_av) {
	$line = sprintf("saving AV 0x%x FILL=$fill", $$av);
	$line .= sprintf(" AvFLAGS=0x%x", $av->AvFLAGS) if $] < 5.009;
	warn $line;
    }
d1585 1
a1585 1
    Newx(fakeargv, argc + EXTRA_OPTIONS + 1, char *);
@


