head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.6
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.7
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.6.0.10
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.4
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.6
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.8
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.6
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.2
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.4.0.34
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.32
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.30
	OPENBSD_5_0:1.1.1.4.0.28
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.26
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.24
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.20
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.22
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.18
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.16
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.14
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.12
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.10
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.8
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.6
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.4
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.2
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.3.0.8
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.6
	OPENBSD_3_5_BASE:1.1.1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.8
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.6
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.4
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.11;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	99.04.29.22.38.38;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.38.38;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.22.40;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.53;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.08.43;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	1.1.1.7;
commitid	B31cAbBIXiCqnL97;

1.1.1.7
date	2017.08.14.13.46.10;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package B::Showlex;

our $VERSION = '1.05';

use strict;
use B qw(svref_2object comppadlist class);
use B::Terse ();
use B::Concise ();

#
# Invoke as
#     perl -MO=Showlex,foo bar.pl
# to see the names of lexical variables used by &foo
# or as
#     perl -MO=Showlex bar.pl
# to see the names of file scope lexicals used by bar.pl
#


# borrowed from B::Concise
our $walkHandle = \*STDOUT;

sub walk_output { # updates $walkHandle
    $walkHandle = B::Concise::walk_output(@@_);
    #print "got $walkHandle";
    #print $walkHandle "using it";
    $walkHandle;
}

sub shownamearray {
    my ($name, $av) = @@_;
    my @@els = $av->ARRAY;
    my $count = @@els;
    my $i;
    print $walkHandle "$name has $count entries\n";
    for ($i = 0; $i < $count; $i++) {
	my $sv = $els[$i];
	if (class($sv) ne "SPECIAL") {
	    printf $walkHandle "$i: (0x%lx) %s\n",
				$$sv, $sv->PVX // "undef" || "const";
	} else {
	    printf $walkHandle "$i: %s\n", $sv->terse;
	    #printf $walkHandle "$i: %s\n", B::Concise::concise_sv($sv);
	}
    }
}

sub showvaluearray {
    my ($name, $av) = @@_;
    my @@els = $av->ARRAY;
    my $count = @@els;
    my $i;
    print $walkHandle "$name has $count entries\n";
    for ($i = 0; $i < $count; $i++) {
	printf $walkHandle "$i: %s\n", $els[$i]->terse;
	#print $walkHandle "$i: %s\n", B::Concise::concise_sv($els[$i]);
    }
}

sub showlex {
    my ($objname, $namesav, $valsav) = @@_;
    shownamearray("Pad of lexical names for $objname", $namesav);
    showvaluearray("Pad of lexical values for $objname", $valsav);
}

my ($newlex, $nosp1); # rendering state vars

sub padname_terse {
    my $name = shift;
    return $name->terse if class($name) eq 'SPECIAL';
    my $str = $name->PVX;
    return sprintf "(0x%lx) %s",
	       $$name,
	       length $str ? qq'"$str"' : defined $str ? "const" : 'undef';
}

sub newlex { # drop-in for showlex
    my ($objname, $names, $vals) = @@_;
    my @@names = $names->ARRAY;
    my @@vals  = $vals->ARRAY;
    my $count = @@names;
    print $walkHandle "$objname Pad has $count entries\n";
    printf $walkHandle "0: %s\n", padname_terse($names[0]) unless $nosp1;
    for (my $i = 1; $i < $count; $i++) {
	printf $walkHandle "$i: %s = %s\n", padname_terse($names[$i]),
					    $vals[$i]->terse,
	    unless $nosp1
	       and class($names[$i]) eq 'SPECIAL' || !$names[$i]->LEN;
    }
}

sub showlex_obj {
    my ($objname, $obj) = @@_;
    $objname =~ s/^&main::/&/;
    showlex($objname, svref_2object($obj)->PADLIST->ARRAY) if !$newlex;
    newlex ($objname, svref_2object($obj)->PADLIST->ARRAY) if  $newlex;
}

sub showlex_main {
    showlex("comppadlist", comppadlist->ARRAY)	if !$newlex;
    newlex ("main", comppadlist->ARRAY)		if  $newlex;
}

sub compile {
    my @@options = grep(/^-/, @@_);
    my @@args = grep(!/^-/, @@_);
    for my $o (@@options) {
	$newlex = 1 if $o eq "-newlex";
	$nosp1  = 1 if $o eq "-nosp";
    }

    return \&showlex_main unless @@args;
    return sub {
	my $objref;
	foreach my $objname (@@args) {
	    next unless $objname;	# skip nulls w/o carping

	    if (ref $objname) {
		print $walkHandle "B::Showlex::compile($objname)\n";
		$objref = $objname;
	    } else {
		$objname = "main::$objname" unless $objname =~ /::/;
		print $walkHandle "$objname:\n";
		no strict 'refs';
		die "err: unknown function ($objname)\n"
		    unless *{$objname}{CODE};
		$objref = \&$objname;
	    }
	    showlex_obj($objname, $objref);
	}
    }
}

1;

__END__

=head1 NAME

B::Showlex - Show lexical variables used in functions or files

=head1 SYNOPSIS

	perl -MO=Showlex[,-OPTIONS][,SUBROUTINE] foo.pl

=head1 DESCRIPTION

When a comma-separated list of subroutine names is given as options, Showlex
prints the lexical variables used in those subroutines.  Otherwise, it prints
the file-scope lexicals in the file.

=head1 EXAMPLES

Traditional form:

 $ perl -MO=Showlex -e 'my ($i,$j,$k)=(1,"foo")'
 Pad of lexical names for comppadlist has 4 entries
 0: (0x8caea4) undef
 1: (0x9db0fb0) $i
 2: (0x9db0f38) $j
 3: (0x9db0f50) $k
 Pad of lexical values for comppadlist has 5 entries
 0: SPECIAL #1 &PL_sv_undef
 1: NULL (0x9da4234)
 2: NULL (0x9db0f2c)
 3: NULL (0x9db0f44)
 4: NULL (0x9da4264)
 -e syntax OK

New-style form:

 $ perl -MO=Showlex,-newlex -e 'my ($i,$j,$k)=(1,"foo")'
 main Pad has 4 entries
 0: (0x8caea4) undef
 1: (0xa0c4fb8) "$i" = NULL (0xa0b8234)
 2: (0xa0c4f40) "$j" = NULL (0xa0c4f34)
 3: (0xa0c4f58) "$k" = NULL (0xa0c4f4c)
 -e syntax OK

New form, no specials, outside O framework:

 $ perl -MB::Showlex -e \
    'my ($i,$j,$k)=(1,"foo"); B::Showlex::compile(-newlex,-nosp)->()'
 main Pad has 4 entries
 1: (0x998ffb0) "$i" = IV (0x9983234) 1
 2: (0x998ff68) "$j" = PV (0x998ff5c) "foo"
 3: (0x998ff80) "$k" = NULL (0x998ff74)

Note that this example shows the values of the lexicals, whereas the other
examples did not (as they're compile-time only).

=head2 OPTIONS

The C<-newlex> option produces a more readable C<< name => value >> format,
and is shown in the second example above.

The C<-nosp> option eliminates reporting of SPECIALs, such as C<0: SPECIAL
#1 &PL_sv_undef> above.  Reporting of SPECIALs can sometimes overwhelm
your declared lexicals.

=head1 SEE ALSO

L<B::Showlex> can also be used outside of the O framework, as in the third
example.  See L<B::Concise> for a fuller explanation of reasons.

=head1 TODO

Some of the reported info, such as hex addresses, is not particularly
valuable.  Other information would be more useful for the typical
programmer, such as line-numbers, pad-slot reuses, etc..  Given this,
-newlex is not a particularly good flag-name.

=head1 AUTHOR

Malcolm Beattie, C<mbeattie@@sable.ox.ac.uk>

=cut
@


1.1
log
@Initial revision
@
text
@d2 3
d8 1
d17 30
a46 1
#    
d48 1
a48 1
sub showarray {
d53 1
a53 1
    print "$name has $count entries\n";
d55 2
a56 2
	print "$i: ";
	$els[$i]->terse;
d62 28
a89 2
    showarray("Pad of lexical names for $objname", $namesav);
    showarray("Pad of lexical values for $objname", $valsav);
d95 2
a96 1
    showlex($objname, svref_2object($obj)->PADLIST->ARRAY);
d100 2
a101 1
    showlex("comppadlist", comppadlist->ARRAY);
d105 17
a121 5
    my @@options = @@_;
    if (@@options) {
	return sub {
	    my $objname;
	    foreach $objname (@@options) {
d123 5
a127 1
		eval "showlex_obj('&$objname', \\&$objname)";
d129 1
a130 2
    } else {
	return \&showlex_main;
d144 1
a144 1
	perl -MO=Showlex[,SUBROUTINE] foo.pl
d148 64
a211 3
When a subroutine name is provided in OPTIONS, prints the lexical
variables used in that subroutine.  Otherwise, prints the file-scope
lexicals in the file.
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d15 1
a15 18
sub shownamearray {
    my ($name, $av) = @@_;
    my @@els = $av->ARRAY;
    my $count = @@els;
    my $i;
    print "$name has $count entries\n";
    for ($i = 0; $i < $count; $i++) {
        print "$i: ";
	my $sv = $els[$i];
	if (class($sv) ne "SPECIAL") {
	    printf "%s (0x%lx) %s\n", class($sv), $$sv, $sv->PVX;
	} else {
            $sv->terse;
	}
    }
}

sub showvaluearray {
d29 2
a30 2
    shownamearray("Pad of lexical names for $objname", $namesav);
    showvaluearray("Pad of lexical values for $objname", $valsav);
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@a1 3

our $VERSION = '1.00';

@


1.1.1.4
log
@perl 5.8.6 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.02';
a7 1
use B::Concise ();
d16 1
a16 12
#


# borrowed from B::Concise
our $walkHandle = \*STDOUT;

sub walk_output { # updates $walkHandle
    $walkHandle = B::Concise::walk_output(@@_);
    #print "got $walkHandle";
    #print $walkHandle "using it";
    $walkHandle;
}
d23 1
a23 1
    print $walkHandle "$name has $count entries\n";
d25 1
d28 1
a28 1
	    printf $walkHandle "$i: %s (0x%lx) %s\n", class($sv), $$sv, $sv->PVX;
d30 1
a30 2
	    printf $walkHandle "$i: %s\n", $sv->terse;
	    #printf $walkHandle "$i: %s\n", B::Concise::concise_sv($sv);
d40 1
a40 1
    print $walkHandle "$name has $count entries\n";
d42 2
a43 2
	printf $walkHandle "$i: %s\n", $els[$i]->terse;
	#print $walkHandle "$i: %s\n", B::Concise::concise_sv($els[$i]);
a52 15
my ($newlex, $nosp1); # rendering state vars

sub newlex { # drop-in for showlex
    my ($objname, $names, $vals) = @@_;
    my @@names = $names->ARRAY;
    my @@vals  = $vals->ARRAY;
    my $count = @@names;
    print $walkHandle "$objname Pad has $count entries\n";
    printf $walkHandle "0: %s\n", $names[0]->terse unless $nosp1;
    for (my $i = 1; $i < $count; $i++) {
	printf $walkHandle "$i: %s = %s\n", $names[$i]->terse, $vals[$i]->terse
	    unless $nosp1 and $names[$i]->terse =~ /SPECIAL/;
    }
}

d56 1
a56 2
    showlex($objname, svref_2object($obj)->PADLIST->ARRAY) if !$newlex;
    newlex ($objname, svref_2object($obj)->PADLIST->ARRAY) if  $newlex;
d60 1
a60 2
    showlex("comppadlist", comppadlist->ARRAY)	if !$newlex;
    newlex ("main", comppadlist->ARRAY)		if  $newlex;
d64 5
a68 17
    my @@options = grep(/^-/, @@_);
    my @@args = grep(!/^-/, @@_);
    for my $o (@@options) {
	$newlex = 1 if $o eq "-newlex";
	$nosp1  = 1 if $o eq "-nosp";
    }

    return \&showlex_main unless @@args;
    return sub {
	my $objref;
	foreach my $objname (@@args) {
	    next unless $objname;	# skip nulls w/o carping

	    if (ref $objname) {
		print $walkHandle "B::Showlex::compile($objname)\n";
		$objref = $objname;
	    } else {
d70 1
a70 5
		print $walkHandle "$objname:\n";
		no strict 'refs';
		die "err: unknown function ($objname)\n"
		    unless *{$objname}{CODE};
		$objref = \&$objname;
a71 1
	    showlex_obj($objname, $objref);
d73 2
d88 1
a88 1
	perl -MO=Showlex[,-OPTIONS][,SUBROUTINE] foo.pl
d92 3
a94 64
When a comma-separated list of subroutine names is given as options, Showlex
prints the lexical variables used in those subroutines.  Otherwise, it prints
the file-scope lexicals in the file.

=head1 EXAMPLES

Traditional form:

 $ perl -MO=Showlex -e 'my ($i,$j,$k)=(1,"foo")'
 Pad of lexical names for comppadlist has 4 entries
 0: SPECIAL #1 &PL_sv_undef
 1: PVNV (0x9db0fb0) $i
 2: PVNV (0x9db0f38) $j
 3: PVNV (0x9db0f50) $k
 Pad of lexical values for comppadlist has 5 entries
 0: SPECIAL #1 &PL_sv_undef
 1: NULL (0x9da4234)
 2: NULL (0x9db0f2c)
 3: NULL (0x9db0f44)
 4: NULL (0x9da4264)
 -e syntax OK

New-style form:

 $ perl -MO=Showlex,-newlex -e 'my ($i,$j,$k)=(1,"foo")'
 main Pad has 4 entries
 0: SPECIAL #1 &PL_sv_undef
 1: PVNV (0xa0c4fb8) "$i" = NULL (0xa0b8234)
 2: PVNV (0xa0c4f40) "$j" = NULL (0xa0c4f34)
 3: PVNV (0xa0c4f58) "$k" = NULL (0xa0c4f4c)
 -e syntax OK

New form, no specials, outside O framework:

 $ perl -MB::Showlex -e \
    'my ($i,$j,$k)=(1,"foo"); B::Showlex::compile(-newlex,-nosp)->()'
 main Pad has 4 entries
 1: PVNV (0x998ffb0) "$i" = IV (0x9983234) 1
 2: PVNV (0x998ff68) "$j" = PV (0x998ff5c) "foo"
 3: PVNV (0x998ff80) "$k" = NULL (0x998ff74)

Note that this example shows the values of the lexicals, whereas the other
examples did not (as they're compile-time only).

=head2 OPTIONS

The C<-newlex> option produces a more readable C<< name => value >> format,
and is shown in the second example above.

The C<-nosp> option eliminates reporting of SPECIALs, such as C<0: SPECIAL
#1 &PL_sv_undef> above.  Reporting of SPECIALs can sometimes overwhelm
your declared lexicals.

=head1 SEE ALSO

C<B::Showlex> can also be used outside of the O framework, as in the third
example.  See C<B::Concise> for a fuller explanation of reasons.

=head1 TODO

Some of the reported info, such as hex addresses, is not particularly
valuable.  Other information would be more useful for the typical
programmer, such as line-numbers, pad-slot reuses, etc..  Given this,
-newlex isnt a particularly good flag-name.
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d3 1
a3 1
our $VERSION = '1.03';
d191 2
a192 2
L<B::Showlex> can also be used outside of the O framework, as in the third
example.  See L<B::Concise> for a fuller explanation of reasons.
@


1.1.1.6
log
@Import perl-5.20.1
@
text
@d3 1
a3 1
our $VERSION = '1.04';
d199 1
a199 1
-newlex is not a particularly good flag-name.
@


1.1.1.7
log
@Import perl-5.24.2
@
text
@d3 1
a3 1
our $VERSION = '1.05';
d39 1
a39 2
	    printf $walkHandle "$i: (0x%lx) %s\n",
				$$sv, $sv->PVX // "undef" || "const";
a66 9
sub padname_terse {
    my $name = shift;
    return $name->terse if class($name) eq 'SPECIAL';
    my $str = $name->PVX;
    return sprintf "(0x%lx) %s",
	       $$name,
	       length $str ? qq'"$str"' : defined $str ? "const" : 'undef';
}

d73 1
a73 1
    printf $walkHandle "0: %s\n", padname_terse($names[0]) unless $nosp1;
d75 2
a76 4
	printf $walkHandle "$i: %s = %s\n", padname_terse($names[$i]),
					    $vals[$i]->terse,
	    unless $nosp1
	       and class($names[$i]) eq 'SPECIAL' || !$names[$i]->LEN;
d146 4
a149 4
 0: (0x8caea4) undef
 1: (0x9db0fb0) $i
 2: (0x9db0f38) $j
 3: (0x9db0f50) $k
d162 4
a165 4
 0: (0x8caea4) undef
 1: (0xa0c4fb8) "$i" = NULL (0xa0b8234)
 2: (0xa0c4f40) "$j" = NULL (0xa0c4f34)
 3: (0xa0c4f58) "$k" = NULL (0xa0c4f4c)
d173 3
a175 3
 1: (0x998ffb0) "$i" = IV (0x9983234) 1
 2: (0x998ff68) "$j" = PV (0x998ff5c) "foo"
 3: (0x998ff80) "$k" = NULL (0x998ff74)
@


