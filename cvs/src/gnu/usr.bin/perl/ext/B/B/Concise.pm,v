head	1.13;
access;
symbols
	PERL_5_24_2:1.1.1.13
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.12.0.10
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.8
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.2.0.4
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2
	PERL_5_8_0:1.1.1.2
	OPENBSD_3_2:1.1.1.1.0.6
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.4
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	PERL_5_6_1:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.13
date	2017.02.05.00.32.11;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	cxJ08BvJA9Pt2PTM;

1.12
date	2014.11.17.20.57.05;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	QP75iYx42Uo7mMxO;

1.11
date	2014.03.24.15.05.27;	author afresh1;	state Exp;
branches;
next	1.10;

1.10
date	2013.03.25.20.40.53;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.24.15.06.56;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.12.18.24.23;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.01;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.01;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.15.21.30.24;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.09.18.09.03;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.03.03.02.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.04.22.36.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.24.18.22.39;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.24.18.22.39;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.10.27.22.14.53;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.12.03.02.43.41;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.45.53;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.01.15.21.16.42;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.47.52;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.13;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.11.11;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.09.24.14.48.52;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.08.43;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	1.1.1.13;
commitid	B31cAbBIXiCqnL97;

1.1.1.13
date	2017.08.14.13.46.10;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.13
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package B::Concise;
# Copyright (C) 2000-2003 Stephen McCamant. All rights reserved.
# This program is free software; you can redistribute and/or modify it
# under the same terms as Perl itself.

# Note: we need to keep track of how many use declarations/BEGIN
# blocks this module uses, so we can avoid printing them when user
# asks for the BEGIN blocks in her program. Update the comments and
# the count in concise_specials if you add or delete one. The
# -MO=Concise counts as use #1.

use strict; # use #2
use warnings; # uses #3 and #4, since warnings uses Carp

use Exporter (); # use #5

our $VERSION   = "0.996";
our @@ISA       = qw(Exporter);
our @@EXPORT_OK = qw( set_style set_style_standard add_callback
		     concise_subref concise_cv concise_main
		     add_style walk_output compile reset_sequence );
our %EXPORT_TAGS =
    ( io	=> [qw( walk_output compile reset_sequence )],
      style	=> [qw( add_style set_style_standard )],
      cb	=> [qw( add_callback )],
      mech	=> [qw( concise_subref concise_cv concise_main )],  );

# use #6
use B qw(class ppname main_start main_root main_cv cstring svref_2object
	 SVf_IOK SVf_NOK SVf_POK SVf_IVisUV SVf_FAKE OPf_KIDS OPf_SPECIAL
	 CVf_ANON PAD_FAKELEX_ANON PAD_FAKELEX_MULTI SVf_ROK);

my %style =
  ("terse" =>
   ["(?(#label =>\n)?)(*(    )*)#class (#addr) #name (?([#targ])?) "
    . "#svclass~(?((#svaddr))?)~#svval~(?(label \"#coplabel\")?)\n",
    "(*(    )*)goto #class (#addr)\n",
    "#class pp_#name"],
   "concise" =>
   ["#hyphseq2 (*(   (x( ;)x))*)<#classsym> #exname#arg(?([#targarglife])?)"
    . "~#flags(?(/#private)?)(?(:#hints)?)(x(;~->#next)x)\n"
    , "  (*(    )*)     goto #seq\n",
    "(?(<#seq>)?)#exname#arg(?([#targarglife])?)"],
   "linenoise" =>
   ["(x(;(*( )*))x)#noise#arg(?([#targarg])?)(x( ;\n)x)",
    "gt_#seq ",
    "(?(#seq)?)#noise#arg(?([#targarg])?)"],
   "debug" =>
   ["#class (#addr)\n\top_next\t\t#nextaddr\n\t(?(op_other\t#otheraddr\n\t)?)"
    . "op_sibling\t#sibaddr\n\t"
    . "op_ppaddr\tPL_ppaddr[OP_#NAME]\n\top_type\t\t#typenum\n"
    . "\top_flags\t#flagval\n\top_private\t#privval\t#hintsval\n"
    . "(?(\top_first\t#firstaddr\n)?)(?(\top_last\t\t#lastaddr\n)?)"
    . "(?(\top_sv\t\t#svaddr\n)?)",
    "    GOTO #addr\n",
    "#addr"],
   "env" => [$ENV{B_CONCISE_FORMAT}, $ENV{B_CONCISE_GOTO_FORMAT},
	     $ENV{B_CONCISE_TREE_FORMAT}],
  );

# Renderings, ie how Concise prints, is controlled by these vars
# primary:
our $stylename;		# selects current style from %style
my $order = "basic";	# how optree is walked & printed: basic, exec, tree

# rendering mechanics:
# these 'formats' are the line-rendering templates
# they're updated from %style when $stylename changes
my ($format, $gotofmt, $treefmt);

# lesser players:
my $base = 36;		# how <sequence#> is displayed
my $big_endian = 1;	# more <sequence#> display
my $tree_style = 0;	# tree-order details
my $banner = 1;		# print banner before optree is traversed
my $do_main = 0;	# force printing of main routine
my $show_src;		# show source code

# another factor: can affect all styles!
our @@callbacks;		# allow external management

set_style_standard("concise");

my $curcv;
my $cop_seq_base;

sub set_style {
    ($format, $gotofmt, $treefmt) = @@_;
    #warn "set_style: deprecated, use set_style_standard instead\n"; # someday
    die "expecting 3 style-format args\n" unless @@_ == 3;
}

sub add_style {
    my ($newstyle,@@args) = @@_;
    die "style '$newstyle' already exists, choose a new name\n"
	if exists $style{$newstyle};
    die "expecting 3 style-format args\n" unless @@args == 3;
    $style{$newstyle} = [@@args];
    $stylename = $newstyle; # update rendering state
}

sub set_style_standard {
    ($stylename) = @@_; # update rendering state
    die "err: style '$stylename' unknown\n" unless exists $style{$stylename};
    set_style(@@{$style{$stylename}});
}

sub add_callback {
    push @@callbacks, @@_;
}

# output handle, used with all Concise-output printing
our $walkHandle;	# public for your convenience
BEGIN { $walkHandle = \*STDOUT }

sub walk_output { # updates $walkHandle
    my $handle = shift;
    return $walkHandle unless $handle; # allow use as accessor

    if (ref $handle eq 'SCALAR') {
	require Config;
	die "no perlio in this build, can't call walk_output (\\\$scalar)\n"
	    unless $Config::Config{useperlio};
	# in 5.8+, open(FILEHANDLE,MODE,REFERENCE) writes to string
	open my $tmp, '>', $handle;	# but cant re-set existing STDOUT
	$walkHandle = $tmp;		# so use my $tmp as intermediate var
	return $walkHandle;
    }
    my $iotype = ref $handle;
    die "expecting argument/object that can print\n"
	unless $iotype eq 'GLOB' or $iotype and $handle->can('print');
    $walkHandle = $handle;
}

sub concise_subref {
    my($order, $coderef, $name) = @@_;
    my $codeobj = svref_2object($coderef);

    return concise_stashref(@@_)
	unless ref($codeobj) =~ '^B::(?:CV|FM)\z';
    concise_cv_obj($order, $codeobj, $name);
}

sub concise_stashref {
    my($order, $h) = @@_;
    local *s;
    foreach my $k (sort keys %$h) {
	next unless defined $h->{$k};
	*s = $h->{$k};
	my $coderef = *s{CODE} or next;
	reset_sequence();
	print "FUNC: ", *s, "\n";
	my $codeobj = svref_2object($coderef);
	next unless ref $codeobj eq 'B::CV';
	eval { concise_cv_obj($order, $codeobj, $k) };
	warn "err $@@ on $codeobj" if $@@;
    }
}

# This should have been called concise_subref, but it was exported
# under this name in versions before 0.56
*concise_cv = \&concise_subref;

sub concise_cv_obj {
    my ($order, $cv, $name) = @@_;
    # name is either a string, or a CODE ref (copy of $cv arg??)

    $curcv = $cv;

    if (ref($cv->XSUBANY) =~ /B::(\w+)/) {
	print $walkHandle "$name is a constant sub, optimized to a $1\n";
	return;
    }
    if ($cv->XSUB) {
	print $walkHandle "$name is XS code\n";
	return;
    }
    if (class($cv->START) eq "NULL") {
	no strict 'refs';
	if (ref $name eq 'CODE') {
	    print $walkHandle "coderef $name has no START\n";
	}
	elsif (exists &$name) {
	    print $walkHandle "$name exists in stash, but has no START\n";
	}
	else {
	    print $walkHandle "$name not in symbol table\n";
	}
	return;
    }
    sequence($cv->START);
    if ($order eq "exec") {
	walk_exec($cv->START);
    }
    elsif ($order eq "basic") {
	# walk_topdown($cv->ROOT, sub { $_[0]->concise($_[1]) }, 0);
	my $root = $cv->ROOT;
	unless (ref $root eq 'B::NULL') {
	    walk_topdown($root, sub { $_[0]->concise($_[1]) }, 0);
	} else {
	    print $walkHandle "B::NULL encountered doing ROOT on $cv. avoiding disaster\n";
	}
    } else {
	print $walkHandle tree($cv->ROOT, 0);
    }
}

sub concise_main {
    my($order) = @@_;
    sequence(main_start);
    $curcv = main_cv;
    if ($order eq "exec") {
	return if class(main_start) eq "NULL";
	walk_exec(main_start);
    } elsif ($order eq "tree") {
	return if class(main_root) eq "NULL";
	print $walkHandle tree(main_root, 0);
    } elsif ($order eq "basic") {
	return if class(main_root) eq "NULL";
	walk_topdown(main_root,
		     sub { $_[0]->concise($_[1]) }, 0);
    }
}

sub concise_specials {
    my($name, $order, @@cv_s) = @@_;
    my $i = 1;
    if ($name eq "BEGIN") {
	splice(@@cv_s, 0, 8); # skip 7 BEGIN blocks in this file. NOW 8 ??
    } elsif ($name eq "CHECK") {
	pop @@cv_s; # skip the CHECK block that calls us
    }
    for my $cv (@@cv_s) {
	print $walkHandle "$name $i:\n";
	$i++;
	concise_cv_obj($order, $cv, $name);
    }
}

my $start_sym = "\e(0"; # "\cN" sometimes also works
my $end_sym   = "\e(B"; # "\cO" respectively

my @@tree_decorations =
  (["  ", "--", "+-", "|-", "| ", "`-", "-", 1],
   [" ", "-", "+", "+", "|", "`", "", 0],
   ["  ", map("$start_sym$_$end_sym", "qq", "wq", "tq", "x ", "mq", "q"), 1],
   [" ", map("$start_sym$_$end_sym", "q", "w", "t", "x", "m"), "", 0],
  );

my @@render_packs; # collect -stash=<packages>

sub compileOpts {
    # set rendering state from options and args
    my (@@options,@@args);
    if (@@_) {
	@@options = grep(/^-/, @@_);
	@@args = grep(!/^-/, @@_);
    }
    for my $o (@@options) {
	# mode/order
	if ($o eq "-basic") {
	    $order = "basic";
	} elsif ($o eq "-exec") {
	    $order = "exec";
	} elsif ($o eq "-tree") {
	    $order = "tree";
	}
	# tree-specific
	elsif ($o eq "-compact") {
	    $tree_style |= 1;
	} elsif ($o eq "-loose") {
	    $tree_style &= ~1;
	} elsif ($o eq "-vt") {
	    $tree_style |= 2;
	} elsif ($o eq "-ascii") {
	    $tree_style &= ~2;
	}
	# sequence numbering
	elsif ($o =~ /^-base(\d+)$/) {
	    $base = $1;
	} elsif ($o eq "-bigendian") {
	    $big_endian = 1;
	} elsif ($o eq "-littleendian") {
	    $big_endian = 0;
	}
	# miscellaneous, presentation
	elsif ($o eq "-nobanner") {
	    $banner = 0;
	} elsif ($o eq "-banner") {
	    $banner = 1;
	}
	elsif ($o eq "-main") {
	    $do_main = 1;
	} elsif ($o eq "-nomain") {
	    $do_main = 0;
	} elsif ($o eq "-src") {
	    $show_src = 1;
	}
	elsif ($o =~ /^-stash=(.*)/) {
	    my $pkg = $1;
	    no strict 'refs';
	    if (! %{$pkg.'::'}) {
		eval "require $pkg";
	    } else {
		require Config;
		if (!$Config::Config{usedl}
		    && keys %{$pkg.'::'} == 1
		    && $pkg->can('bootstrap')) {
		    # It is something that we're statically linked to, but hasn't
		    # yet been used.
		    eval "require $pkg";
		}
	    }
	    push @@render_packs, $pkg;
	}
	# line-style options
	elsif (exists $style{substr($o, 1)}) {
	    $stylename = substr($o, 1);
	    set_style_standard($stylename);
	} else {
	    warn "Option $o unrecognized";
	}
    }
    return (@@args);
}

sub compile {
    my (@@args) = compileOpts(@@_);
    return sub {
	my @@newargs = compileOpts(@@_); # accept new rendering options
	warn "disregarding non-options: @@newargs\n" if @@newargs;

	for my $objname (@@args) {
	    next unless $objname; # skip null args to avoid noisy responses

	    if ($objname eq "BEGIN") {
		concise_specials("BEGIN", $order,
				 B::begin_av->isa("B::AV") ?
				 B::begin_av->ARRAY : ());
	    } elsif ($objname eq "INIT") {
		concise_specials("INIT", $order,
				 B::init_av->isa("B::AV") ?
				 B::init_av->ARRAY : ());
	    } elsif ($objname eq "CHECK") {
		concise_specials("CHECK", $order,
				 B::check_av->isa("B::AV") ?
				 B::check_av->ARRAY : ());
	    } elsif ($objname eq "UNITCHECK") {
		concise_specials("UNITCHECK", $order,
				 B::unitcheck_av->isa("B::AV") ?
				 B::unitcheck_av->ARRAY : ());
	    } elsif ($objname eq "END") {
		concise_specials("END", $order,
				 B::end_av->isa("B::AV") ?
				 B::end_av->ARRAY : ());
	    }
	    else {
		# convert function names to subrefs
		if (ref $objname) {
		    print $walkHandle "B::Concise::compile($objname)\n"
			if $banner;
		    concise_subref($order, ($objname)x2);
		    next;
		} else {
		    $objname = "main::" . $objname unless $objname =~ /::/;
		    no strict 'refs';
		    my $glob = \*$objname;
		    unless (*$glob{CODE} || *$glob{FORMAT}) {
			print $walkHandle "$objname:\n" if $banner;
			print $walkHandle "err: unknown function ($objname)\n";
			return;
		    }
		    if (my $objref = *$glob{CODE}) {
			print $walkHandle "$objname:\n" if $banner;
			concise_subref($order, $objref, $objname);
		    }
		    if (my $objref = *$glob{FORMAT}) {
			print $walkHandle "$objname (FORMAT):\n"
			    if $banner;
			concise_subref($order, $objref, $objname);
		    }
		}
	    }
	}
	for my $pkg (@@render_packs) {
	    no strict 'refs';
	    concise_stashref($order, \%{$pkg.'::'});
	}

	if (!@@args or $do_main or @@render_packs) {
	    print $walkHandle "main program:\n" if $do_main;
	    concise_main($order);
	}
	return @@args;	# something
    }
}

my %labels;
my $lastnext;	# remembers op-chain, used to insert gotos

my %opclass = ('OP' => "0", 'UNOP' => "1", 'BINOP' => "2", 'LOGOP' => "|",
	       'LISTOP' => "@@", 'PMOP' => "/", 'SVOP' => "\$", 'GVOP' => "*",
	       'PVOP' => '"', 'LOOP' => "{", 'COP' => ";", 'PADOP' => "#",
	       'METHOP' => '.', UNOP_AUX => '+');

no warnings 'qw'; # "Possible attempt to put comments..."; use #7
my @@linenoise =
  qw'#  () sc (  @@? 1  $* gv *{ m$ m@@ m% m? p/ *$ $  $# & a& pt \\ s\\ rf bl
     `  *? <> ?? ?/ r/ c/ // qr s/ /c y/ =  @@= C  sC Cp sp df un BM po +1 +I
     -1 -I 1+ I+ 1- I- ** *  i* /  i/ %$ i% x  +  i+ -  i- .  "  << >> <  i<
     >  i> <= i, >= i. == i= != i! <? i? s< s> s, s. s= s! s? b& b^ b| -0 -i
     !  ~  a2 si cs rd sr e^ lg sq in %x %o ab le ss ve ix ri sf FL od ch cy
     uf lf uc lc qm @@  [f [  @@[ eh vl ky dl ex %  ${ @@{ uk pk st jn )  )[ a@@
     a% sl +] -] [- [+ so rv GS GW MS MW .. f. .f && || ^^ ?: &= |= -> s{ s}
     v} ca wa di rs ;; ;  ;d }{ {  }  {} f{ it {l l} rt }l }n }r dm }g }e ^o
     ^c ^| ^# um bm t~ u~ ~d DB db ^s se ^g ^r {w }w pf pr ^O ^K ^R ^W ^d ^v
     ^e ^t ^k t. fc ic fl .s .p .b .c .l .a .h g1 s1 g2 s2 ?. l? -R -W -X -r
     -w -x -e -o -O -z -s -M -A -C -S -c -b -f -d -p -l -u -g -k -t -T -B cd
     co cr u. cm ut r. l@@ s@@ r@@ mD uD oD rD tD sD wD cD f$ w$ p$ sh e$ k$ g3
     g4 s4 g5 s5 T@@ C@@ L@@ G@@ A@@ S@@ Hg Hc Hr Hw Mg Mc Ms Mr Sg Sc So rq do {e
     e} {t t} g6 G6 6e g7 G7 7e g8 G8 8e g9 G9 9e 6s 7s 8s 9s 6E 7E 8E 9E Pn
     Pu GP SP EP Gn Gg GG SG EG g0 c$ lk t$ ;s n> // /= CO';

my $chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

sub op_flags { # common flags (see BASOP.op_flags in op.h)
    my($x) = @@_;
    my(@@v);
    push @@v, "v" if ($x & 3) == 1;
    push @@v, "s" if ($x & 3) == 2;
    push @@v, "l" if ($x & 3) == 3;
    push @@v, "K" if $x & 4;
    push @@v, "P" if $x & 8;
    push @@v, "R" if $x & 16;
    push @@v, "M" if $x & 32;
    push @@v, "S" if $x & 64;
    push @@v, "*" if $x & 128;
    return join("", @@v);
}

sub base_n {
    my $x = shift;
    return "-" . base_n(-$x) if $x < 0;
    my $str = "";
    do { $str .= substr($chars, $x % $base, 1) } while $x = int($x / $base);
    $str = reverse $str if $big_endian;
    return $str;
}

my %sequence_num;
my $seq_max = 1;

sub reset_sequence {
    # reset the sequence
    %sequence_num = ();
    $seq_max = 1;
    $lastnext = 0;
}

sub seq {
    my($op) = @@_;
    return "-" if not exists $sequence_num{$$op};
    return base_n($sequence_num{$$op});
}

sub walk_topdown {
    my($op, $sub, $level) = @@_;
    $sub->($op, $level);
    if ($op->flags & OPf_KIDS) {
	for (my $kid = $op->first; $$kid; $kid = $kid->sibling) {
	    walk_topdown($kid, $sub, $level + 1);
	}
    }
    if (class($op) eq "PMOP") {
	my $maybe_root = $op->code_list;
	if ( ref($maybe_root) and $maybe_root->isa("B::OP")
	 and not $op->flags & OPf_KIDS) {
	    walk_topdown($maybe_root, $sub, $level + 1);
	}
	$maybe_root = $op->pmreplroot;
	if (ref($maybe_root) and $maybe_root->isa("B::OP")) {
	    # It really is the root of the replacement, not something
	    # else stored here for lack of space elsewhere
	    walk_topdown($maybe_root, $sub, $level + 1);
	}
    }
}

sub walklines {
    my($ar, $level) = @@_;
    for my $l (@@$ar) {
	if (ref($l) eq "ARRAY") {
	    walklines($l, $level + 1);
	} else {
	    $l->concise($level);
	}
    }
}

sub walk_exec {
    my($top, $level) = @@_;
    my %opsseen;
    my @@lines;
    my @@todo = ([$top, \@@lines]);
    while (@@todo and my($op, $targ) = @@{shift @@todo}) {
	for (; $$op; $op = $op->next) {
	    last if $opsseen{$$op}++;
	    push @@$targ, $op;
	    my $name = $op->name;
	    if (class($op) eq "LOGOP") {
		my $ar = [];
		push @@$targ, $ar;
		push @@todo, [$op->other, $ar];
	    } elsif ($name eq "subst" and $ {$op->pmreplstart}) {
		my $ar = [];
		push @@$targ, $ar;
		push @@todo, [$op->pmreplstart, $ar];
	    } elsif ($name =~ /^enter(loop|iter)$/) {
		$labels{${$op->nextop}} = "NEXT";
		$labels{${$op->lastop}} = "LAST";
		$labels{${$op->redoop}} = "REDO";
	    }
	}
    }
    walklines(\@@lines, 0);
}

# The structure of this routine is purposely modeled after op.c's peep()
sub sequence {
    my($op) = @@_;
    my $oldop = 0;
    return if class($op) eq "NULL" or exists $sequence_num{$$op};
    for (; $$op; $op = $op->next) {
	last if exists $sequence_num{$$op};
	my $name = $op->name;
	$sequence_num{$$op} = $seq_max++;
	if (class($op) eq "LOGOP") {
	    sequence($op->other);
	} elsif (class($op) eq "LOOP") {
	    sequence($op->redoop);
	    sequence( $op->nextop);
	    sequence($op->lastop);
	} elsif ($name eq "subst" and $ {$op->pmreplstart}) {
	    sequence($op->pmreplstart);
	}
	$oldop = $op;
    }
}

sub fmt_line {    # generate text-line for op.
    my($hr, $op, $text, $level) = @@_;

    $_->($hr, $op, \$text, \$level, $stylename) for @@callbacks;

    return '' if $hr->{SKIP};	# suppress line if a callback said so
    return '' if $hr->{goto} and $hr->{goto} eq '-';	# no goto nowhere

    # spec: (?(text1#varText2)?)
    $text =~ s/\(\?\(([^\#]*?)\#(\w+)([^\#]*?)\)\?\)/
	$hr->{$2} ? $1.$hr->{$2}.$3 : ""/eg;

    # spec: (x(exec_text;basic_text)x)
    $text =~ s/\(x\((.*?);(.*?)\)x\)/$order eq "exec" ? $1 : $2/egs;

    # spec: (*(text)*)
    $text =~ s/\(\*\(([^;]*?)\)\*\)/$1 x $level/egs;

    # spec: (*(text1;text2)*)
    $text =~ s/\(\*\((.*?);(.*?)\)\*\)/$1 x ($level - 1) . $2 x ($level>0)/egs;

    # convert #Var to tag=>val form: Var\t#var
    $text =~ s/\#([A-Z][a-z]+)(\d+)?/\t\u$1\t\L#$1$2/gs;

    # spec: #varN
    $text =~ s/\#([a-zA-Z]+)(\d+)/sprintf("%-$2s", $hr->{$1})/eg;

    $text =~ s/\#([a-zA-Z]+)/$hr->{$1}/eg;	# populate #var's
    $text =~ s/[ \t]*~+[ \t]*/ /g;		# squeeze tildes

    $text = "# $hr->{src}\n$text" if $show_src and $hr->{src};

    chomp $text;
    return "$text\n" if $text ne "" and $order ne "tree";
    return $text; # suppress empty lines
}



# use require rather than use here to avoid disturbing tests that dump
# BEGIN blocks
require B::Op_private;



our %hints; # used to display each COP's op_hints values

# strict refs, subs, vars
@@hints{2,512,1024,32,64,128} = ('$', '&', '*', 'x$', 'x&', 'x*');
# integers, locale, bytes
@@hints{1,4,8,16} = ('i', 'l', 'b');
# block scope, localise %^H, $^OPEN (in), $^OPEN (out)
@@hints{256,131072,262144,524288} = ('{','%','<','>');
# overload new integer, float, binary, string, re
@@hints{4096,8192,16384,32768,65536} = ('I', 'F', 'B', 'S', 'R');
# taint and eval
@@hints{1048576,2097152} = ('T', 'E');
# filetest access, UTF-8
@@hints{4194304,8388608} = ('X', 'U');

sub _flags {
    my($hash, $x) = @@_;
    my @@s;
    for my $flag (sort {$b <=> $a} keys %$hash) {
	if ($hash->{$flag} and $x & $flag and $x >= $flag) {
	    $x -= $flag;
	    push @@s, $hash->{$flag};
	}
    }
    push @@s, $x if $x;
    return join(",", @@s);
}

# return a string like 'LVINTRO,1' for the op $name with op_private
# value $x

sub private_flags {
    my($name, $x) = @@_;
    my $entry = $B::Op_private::bits{$name};
    return $x ? "$x" : '' unless $entry;

    my @@flags;
    my $bit;
    for ($bit = 7; $bit >= 0; $bit--) {
        next unless exists $entry->{$bit};
        my $e = $entry->{$bit};
        if (ref($e) eq 'HASH') {
            # bit field

            my ($bitmin, $bitmax, $bitmask, $enum, $label) =
                    @@{$e}{qw(bitmin bitmax bitmask enum label)};
            $bit = $bitmin;
            next if defined $label && $label eq '-'; # display as raw number

            my $val = $x & $bitmask;
            $x &= ~$bitmask;
            $val >>= $bitmin;

            if (defined $enum) {
                # try to convert numeric $val into symbolic
                my @@enum = @@$enum;
                while (@@enum) {
                    my $ix    = shift @@enum;
                    my $name  = shift @@enum;
                    my $label = shift @@enum;
                    if ($val == $ix) {
                        $val = $label;
                        last;
                    }
                }
            }
            next if $val eq '0'; # don't display anonymous zero values
            push @@flags, defined $label ? "$label=$val" : $val;

        }
        else {
            # flag bit
            my $label = $B::Op_private::labels{$e};
            next if defined $label && $label eq '-'; # display as raw number
            if ($x & (1<<$bit)) {
                $x -= (1<<$bit);
                push @@flags, $label;
            }
        }
    }

    push @@flags, $x if $x; # display unknown bits numerically
    return join ",", @@flags;
}

sub hints_flags {
    my($x) = @@_;
    _flags(\%hints, $x);
}

sub concise_sv {
    my($sv, $hr, $preferpv) = @@_;
    $hr->{svclass} = class($sv);
    $hr->{svclass} = "UV"
      if $hr->{svclass} eq "IV" and $sv->FLAGS & SVf_IVisUV;
    Carp::cluck("bad concise_sv: $sv") unless $sv and $$sv;
    $hr->{svaddr} = sprintf("%#x", $$sv);
    if ($hr->{svclass} eq "GV" && $sv->isGV_with_GP()) {
	my $gv = $sv;
	my $stash = $gv->STASH;
	if (class($stash) eq "SPECIAL") {
	    $stash = "<none>";
	}
	else {
	    $stash = $stash->NAME;
	}
	if ($stash eq "main") {
	    $stash = "";
	} else {
	    $stash = $stash . "::";
	}
	$hr->{svval} = "*$stash" . $gv->SAFENAME;
	return "*$stash" . $gv->SAFENAME;
    } else {
	if ($] >= 5.011) {
	    while (class($sv) eq "IV" && $sv->FLAGS & SVf_ROK) {
		$hr->{svval} .= "\\";
		$sv = $sv->RV;
	    }
	} else {
	    while (class($sv) eq "RV") {
		$hr->{svval} .= "\\";
		$sv = $sv->RV;
	    }
	}
	if (class($sv) eq "SPECIAL") {
	    $hr->{svval} .= ["Null", "sv_undef", "sv_yes", "sv_no"]->[$$sv];
	} elsif ($preferpv
	      && ($sv->FLAGS & SVf_POK || class($sv) eq "REGEXP")) {
	    $hr->{svval} .= cstring($sv->PV);
	} elsif ($sv->FLAGS & SVf_NOK) {
	    $hr->{svval} .= $sv->NV;
	} elsif ($sv->FLAGS & SVf_IOK) {
	    $hr->{svval} .= $sv->int_value;
	} elsif ($sv->FLAGS & SVf_POK || class($sv) eq "REGEXP") {
	    $hr->{svval} .= cstring($sv->PV);
	} elsif (class($sv) eq "HV") {
	    $hr->{svval} .= 'HASH';
	}

	$hr->{svval} = 'undef' unless defined $hr->{svval};
	my $out = $hr->{svclass};
	return $out .= " $hr->{svval}" ; 
    }
}

my %srclines;

sub fill_srclines {
    my $fullnm = shift;
    if ($fullnm eq '-e') {
	$srclines{$fullnm} = [ $fullnm, "-src not supported for -e" ];
	return;
    }
    open (my $fh, '<', $fullnm)
	or warn "# $fullnm: $!, (chdirs not supported by this feature yet)\n"
	and return;
    my @@l = <$fh>;
    chomp @@l;
    unshift @@l, $fullnm; # like @@{_<$fullnm} in debug, array starts at 1
    $srclines{$fullnm} = \@@l;
}

sub concise_op {
    my ($op, $level, $format) = @@_;
    my %h;
    $h{exname} = $h{name} = $op->name;
    $h{NAME} = uc $h{name};
    $h{class} = class($op);
    $h{extarg} = $h{targ} = $op->targ;
    $h{extarg} = "" unless $h{extarg};
    $h{privval} = $op->private;
    # for null ops, targ holds the old type
    my $origname = $h{name} eq "null" && $h{targ}
      ? substr(ppname($h{targ}), 3)
      : $h{name};
    $h{private} = private_flags($origname, $op->private);
    if ($op->folded) {
      $h{private} &&= "$h{private},";
      $h{private} .= "FOLD";
    }

    if ($h{name} ne $origname) { # a null op
	$h{exname} = "ex-$origname";
	$h{extarg} = "";
    } elsif ($h{private} =~ /\bREFC\b/) {
	# targ holds a reference count
        my $refs = "ref" . ($h{targ} != 1 ? "s" : "");
        $h{targarglife} = $h{targarg} = "$h{targ} $refs";
    } elsif ($h{targ}) {
	my $count = $h{name} eq 'padrange'
            ? ($op->private & $B::Op_private::defines{'OPpPADRANGE_COUNTMASK'})
            : 1;
	my (@@targarg, @@targarglife);
	for my $i (0..$count-1) {
	    my ($targarg, $targarglife);
	    my $padname = (($curcv->PADLIST->ARRAY)[0]->ARRAY)[$h{targ}+$i];
	    if (defined $padname and class($padname) ne "SPECIAL" and
		$padname->LEN)
	    {
		$targarg  = $padname->PVX;
		if ($padname->FLAGS & SVf_FAKE) {
		    # These changes relate to the jumbo closure fix.
		    # See changes 19939 and 20005
		    my $fake = '';
		    $fake .= 'a'
			if $padname->PARENT_FAKELEX_FLAGS & PAD_FAKELEX_ANON;
		    $fake .= 'm'
			if $padname->PARENT_FAKELEX_FLAGS & PAD_FAKELEX_MULTI;
		    $fake .= ':' . $padname->PARENT_PAD_INDEX
			if $curcv->CvFLAGS & CVf_ANON;
		    $targarglife = "$targarg:FAKE:$fake";
		}
		else {
		    my $intro = $padname->COP_SEQ_RANGE_LOW - $cop_seq_base;
		    my $finish = int($padname->COP_SEQ_RANGE_HIGH) - $cop_seq_base;
		    $finish = "end" if $finish == 999999999 - $cop_seq_base;
		    $targarglife = "$targarg:$intro,$finish";
		}
	    } else {
		$targarglife = $targarg = "t" . ($h{targ}+$i);
	    }
	    push @@targarg,     $targarg;
	    push @@targarglife, $targarglife;
	}
	$h{targarg}     = join '; ', @@targarg;
	$h{targarglife} = join '; ', @@targarglife;
    }
    $h{arg} = "";
    $h{svclass} = $h{svaddr} = $h{svval} = "";
    if ($h{class} eq "PMOP") {
	my $extra = '';
	my $precomp = $op->precomp;
	if (defined $precomp) {
	    $precomp = cstring($precomp); # Escape literal control sequences
 	    $precomp = "/$precomp/";
	} else {
	    $precomp = "";
	}
	if ($op->name eq 'subst') {
	    if (class($op->pmreplstart) ne "NULL") {
		undef $lastnext;
		$extra = " replstart->" . seq($op->pmreplstart);
	    }
	}
	elsif ($op->name eq 'pushre') {
	    # with C<@@stash_array = split(/pat/, str);>,
	    #  *stash_array is stored in /pat/'s pmreplroot.
	    my $gv = $op->pmreplroot;
	    if (!ref($gv)) {
		# threaded: the value is actually a pad offset for where
		# the GV is kept (op_pmtargetoff)
		if ($gv) {
		    $gv = (($curcv->PADLIST->ARRAY)[1]->ARRAY)[$gv]->NAME;
		}
	    }
	    else {
		# unthreaded: its a GV (if it exists)
		$gv = (ref($gv) eq "B::GV") ? $gv->NAME : undef;
	    }
	    $extra = " => \@@$gv" if $gv;
	}
	$h{arg} = "($precomp$extra)";
    } elsif ($h{class} eq "PVOP" and $h{name} !~ '^transr?\z') {
	$h{arg} = '("' . $op->pv . '")';
	$h{svval} = '"' . $op->pv . '"';
    } elsif ($h{class} eq "COP") {
	my $label = $op->label;
	$h{coplabel} = $label;
	$label = $label ? "$label: " : "";
	my $loc = $op->file;
	my $pathnm = $loc;
	$loc =~ s[.*/][];
	my $ln = $op->line;
	$loc .= ":$ln";
	my($stash, $cseq) = ($op->stash->NAME, $op->cop_seq - $cop_seq_base);
	$h{arg} = "($label$stash $cseq $loc)";
	if ($show_src) {
	    fill_srclines($pathnm) unless exists $srclines{$pathnm};
	    # Would love to retain Jim's use of // but this code needs to be
	    # portable to 5.8.x
	    my $line = $srclines{$pathnm}[$ln];
	    $line = "-src unavailable under -e" unless defined $line;
	    $h{src} = "$ln: $line";
	}
    } elsif ($h{class} eq "LOOP") {
	$h{arg} = "(next->" . seq($op->nextop) . " last->" . seq($op->lastop)
	  . " redo->" . seq($op->redoop) . ")";
    } elsif ($h{class} eq "LOGOP") {
	undef $lastnext;
	$h{arg} = "(other->" . seq($op->other) . ")";
	$h{otheraddr} = sprintf("%#x", $ {$op->other});
    }
    elsif ($h{class} eq "SVOP" or $h{class} eq "PADOP") {
	unless ($h{name} eq 'aelemfast' and $op->flags & OPf_SPECIAL) {
	    my $idx = ($h{class} eq "SVOP") ? $op->targ : $op->padix;
	    if ($h{class} eq "PADOP" or !${$op->sv}) {
		my $sv = (($curcv->PADLIST->ARRAY)[1]->ARRAY)[$idx];
		$h{arg} = "[" . concise_sv($sv, \%h, 0) . "]";
		$h{targarglife} = $h{targarg} = "";
	    } else {
		$h{arg} = "(" . concise_sv($op->sv, \%h, 0) . ")";
	    }
	}
    }
    elsif ($h{class} eq "METHOP") {
        my $prefix = '';
        if ($h{name} eq 'method_redir' or $h{name} eq 'method_redir_super') {
            my $rclass_sv = $op->rclass;
            $rclass_sv = (($curcv->PADLIST->ARRAY)[1]->ARRAY)[$rclass_sv]
                unless ref $rclass_sv;
            $prefix .= 'PACKAGE "'.$rclass_sv->PV.'", ';
        }
        if ($h{name} ne "method") {
            if (${$op->meth_sv}) {
                $h{arg} = "($prefix" . concise_sv($op->meth_sv, \%h, 1) . ")";
            } else {
                my $sv = (($curcv->PADLIST->ARRAY)[1]->ARRAY)[$op->targ];
                $h{arg} = "[$prefix" . concise_sv($sv, \%h, 1) . "]";
                $h{targarglife} = $h{targarg} = "";
            }
        }
    }
    elsif ($h{class} eq "UNOP_AUX") {
        $h{arg} = "(" . $op->string($curcv) . ")";
    }

    $h{seq} = $h{hyphseq} = seq($op);
    $h{seq} = "" if $h{seq} eq "-";
    $h{opt} = $op->opt;
    $h{label} = $labels{$$op};
    $h{next} = $op->next;
    $h{next} = (class($h{next}) eq "NULL") ? "(end)" : seq($h{next});
    $h{nextaddr} = sprintf("%#x", $ {$op->next});
    $h{sibaddr} = sprintf("%#x", $ {$op->sibling});
    $h{firstaddr} = sprintf("%#x", $ {$op->first}) if $op->can("first");
    $h{lastaddr} = sprintf("%#x", $ {$op->last}) if $op->can("last");

    $h{classsym} = $opclass{$h{class}};
    $h{flagval} = $op->flags;
    $h{flags} = op_flags($op->flags);
    if ($op->can("hints")) {
      $h{hintsval} = $op->hints;
      $h{hints} = hints_flags($h{hintsval});
    } else {
      $h{hintsval} = $h{hints} = '';
    }
    $h{addr} = sprintf("%#x", $$op);
    $h{typenum} = $op->type;
    $h{noise} = $linenoise[$op->type];

    return fmt_line(\%h, $op, $format, $level);
}

sub B::OP::concise {
    my($op, $level) = @@_;
    if ($order eq "exec" and $lastnext and $$lastnext != $$op) {
	# insert a 'goto' line
	my $synth = {"seq" => seq($lastnext), "class" => class($lastnext),
		     "addr" => sprintf("%#x", $$lastnext),
		     "goto" => seq($lastnext), # simplify goto '-' removal
	     };
	print $walkHandle fmt_line($synth, $op, $gotofmt, $level+1);
    }
    $lastnext = $op->next;
    print $walkHandle concise_op($op, $level, $format);
}

# B::OP::terse (see Terse.pm) now just calls this
sub b_terse {
    my($op, $level) = @@_;

    # This isn't necessarily right, but there's no easy way to get
    # from an OP to the right CV. This is a limitation of the
    # ->terse() interface style, and there isn't much to do about
    # it. In particular, we can die in concise_op if the main pad
    # isn't long enough, or has the wrong kind of entries, compared to
    # the pad a sub was compiled with. The fix for that would be to
    # make a backwards compatible "terse" format that never even
    # looked at the pad, just like the old B::Terse. I don't think
    # that's worth the effort, though.
    $curcv = main_cv unless $curcv;

    if ($order eq "exec" and $lastnext and $$lastnext != $$op) {
	# insert a 'goto'
	my $h = {"seq" => seq($lastnext), "class" => class($lastnext),
		 "addr" => sprintf("%#x", $$lastnext)};
	print # $walkHandle
	    fmt_line($h, $op, $style{"terse"}[1], $level+1);
    }
    $lastnext = $op->next;
    print # $walkHandle 
	concise_op($op, $level, $style{"terse"}[0]);
}

sub tree {
    my $op = shift;
    my $level = shift;
    my $style = $tree_decorations[$tree_style];
    my($space, $single, $kids, $kid, $nokid, $last, $lead, $size) = @@$style;
    my $name = concise_op($op, $level, $treefmt);
    if (not $op->flags & OPf_KIDS) {
	return $name . "\n";
    }
    my @@lines;
    for (my $kid = $op->first; $$kid; $kid = $kid->sibling) {
	push @@lines, tree($kid, $level+1);
    }
    my $i;
    for ($i = $#lines; substr($lines[$i], 0, 1) eq " "; $i--) {
	$lines[$i] = $space . $lines[$i];
    }
    if ($i > 0) {
	$lines[$i] = $last . $lines[$i];
	while ($i-- > 1) {
	    if (substr($lines[$i], 0, 1) eq " ") {
		$lines[$i] = $nokid . $lines[$i];
	    } else {
		$lines[$i] = $kid . $lines[$i];
	    }
	}
	$lines[$i] = $kids . $lines[$i];
    } else {
	$lines[0] = $single . $lines[0];
    }
    return("$name$lead" . shift @@lines,
           map(" " x (length($name)+$size) . $_, @@lines));
}

# *** Warning: fragile kludge ahead ***
# Because the B::* modules run in the same interpreter as the code
# they're compiling, their presence tends to distort the view we have of
# the code we're looking at. In particular, perl gives sequence numbers
# to COPs. If the program we're looking at were run on its own, this
# would start at 1. Because all of B::Concise and all the modules it
# uses are compiled first, though, by the time we get to the user's
# program the sequence number is already pretty high, which could be
# distracting if you're trying to tell OPs apart. Therefore we'd like to
# subtract an offset from all the sequence numbers we display, to
# restore the simpler view of the world. The trick is to know what that
# offset will be, when we're still compiling B::Concise!  If we
# hardcoded a value, it would have to change every time B::Concise or
# other modules we use do. To help a little, what we do here is compile
# a little code at the end of the module, and compute the base sequence
# number for the user's program as being a small offset later, so all we
# have to worry about are changes in the offset.

# [For 5.8.x and earlier perl is generating sequence numbers for all ops,
#  and using them to reference labels]


# When you say "perl -MO=Concise -e '$a'", the output should look like:

# 4  <@@> leave[t1] vKP/REFC ->(end)
# 1     <0> enter ->2
 #^ smallest OP sequence number should be 1
# 2     <;> nextstate(main 1 -e:1) v ->3
 #                         ^ smallest COP sequence number should be 1
# -     <1> ex-rv2sv vK/1 ->4
# 3        <$> gvsv(*a) s ->4

# If the second of the marked numbers there isn't 1, it means you need
# to update the corresponding magic number in the next line.
# Remember, this needs to stay the last things in the module.

my $cop_seq_mnum = 16;
$cop_seq_base = svref_2object(eval 'sub{0;}')->START->cop_seq + $cop_seq_mnum;

1;

__END__

=head1 NAME

B::Concise - Walk Perl syntax tree, printing concise info about ops

=head1 SYNOPSIS

    perl -MO=Concise[,OPTIONS] foo.pl

    use B::Concise qw(set_style add_callback);

=head1 DESCRIPTION

This compiler backend prints the internal OPs of a Perl program's syntax
tree in one of several space-efficient text formats suitable for debugging
the inner workings of perl or other compiler backends. It can print OPs in
the order they appear in the OP tree, in the order they will execute, or
in a text approximation to their tree structure, and the format of the
information displayed is customizable. Its function is similar to that of
perl's B<-Dx> debugging flag or the B<B::Terse> module, but it is more
sophisticated and flexible.

=head1 EXAMPLE

Here's two outputs (or 'renderings'), using the -exec and -basic
(i.e. default) formatting conventions on the same code snippet.

    % perl -MO=Concise,-exec -e '$a = $b + 42'
    1  <0> enter
    2  <;> nextstate(main 1 -e:1) v
    3  <#> gvsv[*b] s
    4  <$> const[IV 42] s
 *  5  <2> add[t3] sK/2
    6  <#> gvsv[*a] s
    7  <2> sassign vKS/2
    8  <@@> leave[1 ref] vKP/REFC

In this -exec rendering, each opcode is executed in the order shown.
The add opcode, marked with '*', is discussed in more detail.

The 1st column is the op's sequence number, starting at 1, and is
displayed in base 36 by default.  Here they're purely linear; the
sequences are very helpful when looking at code with loops and
branches.

The symbol between angle brackets indicates the op's type, for
example; <2> is a BINOP, <@@> a LISTOP, and <#> is a PADOP, which is
used in threaded perls. (see L</"OP class abbreviations">).

The opname, as in B<'add[t1]'>, may be followed by op-specific
information in parentheses or brackets (ex B<'[t1]'>).

The op-flags (ex B<'sK/2'>) are described in (L</"OP flags
abbreviations">).

    % perl -MO=Concise -e '$a = $b + 42'
    8  <@@> leave[1 ref] vKP/REFC ->(end)
    1     <0> enter ->2
    2     <;> nextstate(main 1 -e:1) v ->3
    7     <2> sassign vKS/2 ->8
 *  5        <2> add[t1] sK/2 ->6
    -           <1> ex-rv2sv sK/1 ->4
    3              <$> gvsv(*b) s ->4
    4           <$> const(IV 42) s ->5
    -        <1> ex-rv2sv sKRM*/1 ->7
    6           <$> gvsv(*a) s ->7

The default rendering is top-down, so they're not in execution order.
This form reflects the way the stack is used to parse and evaluate
expressions; the add operates on the two terms below it in the tree.

Nullops appear as C<ex-opname>, where I<opname> is an op that has been
optimized away by perl.  They're displayed with a sequence-number of
'-', because they are not executed (they don't appear in previous
example), they're printed here because they reflect the parse.

The arrow points to the sequence number of the next op; they're not
displayed in -exec mode, for obvious reasons.

Note that because this rendering was done on a non-threaded perl, the
PADOPs in the previous examples are now SVOPs, and some (but not all)
of the square brackets have been replaced by round ones.  This is a
subtle feature to provide some visual distinction between renderings
on threaded and un-threaded perls.


=head1 OPTIONS

Arguments that don't start with a hyphen are taken to be the names of
subroutines or formats to render; if no
such functions are specified, the main
body of the program (outside any subroutines, and not including use'd
or require'd files) is rendered.  Passing C<BEGIN>, C<UNITCHECK>,
C<CHECK>, C<INIT>, or C<END> will cause all of the corresponding
special blocks to be printed.  Arguments must follow options.

Options affect how things are rendered (ie printed).  They're presented
here by their visual effect, 1st being strongest.  They're grouped
according to how they interrelate; within each group the options are
mutually exclusive (unless otherwise stated).

=head2 Options for Opcode Ordering

These options control the 'vertical display' of opcodes.  The display
'order' is also called 'mode' elsewhere in this document.

=over 4

=item B<-basic>

Print OPs in the order they appear in the OP tree (a preorder
traversal, starting at the root). The indentation of each OP shows its
level in the tree, and the '->' at the end of the line indicates the
next opcode in execution order.  This mode is the default, so the flag
is included simply for completeness.

=item B<-exec>

Print OPs in the order they would normally execute (for the majority
of constructs this is a postorder traversal of the tree, ending at the
root). In most cases the OP that usually follows a given OP will
appear directly below it; alternate paths are shown by indentation. In
cases like loops when control jumps out of a linear path, a 'goto'
line is generated.

=item B<-tree>

Print OPs in a text approximation of a tree, with the root of the tree
at the left and 'left-to-right' order of children transformed into
'top-to-bottom'. Because this mode grows both to the right and down,
it isn't suitable for large programs (unless you have a very wide
terminal).

=back

=head2 Options for Line-Style

These options select the line-style (or just style) used to render
each opcode, and dictates what info is actually printed into each line.

=over 4

=item B<-concise>

Use the author's favorite set of formatting conventions. This is the
default, of course.

=item B<-terse>

Use formatting conventions that emulate the output of B<B::Terse>. The
basic mode is almost indistinguishable from the real B<B::Terse>, and the
exec mode looks very similar, but is in a more logical order and lacks
curly brackets. B<B::Terse> doesn't have a tree mode, so the tree mode
is only vaguely reminiscent of B<B::Terse>.

=item B<-linenoise>

Use formatting conventions in which the name of each OP, rather than being
written out in full, is represented by a one- or two-character abbreviation.
This is mainly a joke.

=item B<-debug>

Use formatting conventions reminiscent of B<B::Debug>; these aren't
very concise at all.

=item B<-env>

Use formatting conventions read from the environment variables
C<B_CONCISE_FORMAT>, C<B_CONCISE_GOTO_FORMAT>, and C<B_CONCISE_TREE_FORMAT>.

=back

=head2 Options for tree-specific formatting

=over 4

=item B<-compact>

Use a tree format in which the minimum amount of space is used for the
lines connecting nodes (one character in most cases). This squeezes out
a few precious columns of screen real estate.

=item B<-loose>

Use a tree format that uses longer edges to separate OP nodes. This format
tends to look better than the compact one, especially in ASCII, and is
the default.

=item B<-vt>

Use tree connecting characters drawn from the VT100 line-drawing set.
This looks better if your terminal supports it.

=item B<-ascii>

Draw the tree with standard ASCII characters like C<+> and C<|>. These don't
look as clean as the VT100 characters, but they'll work with almost any
terminal (or the horizontal scrolling mode of less(1)) and are suitable
for text documentation or email. This is the default.

=back

These are pairwise exclusive, i.e. compact or loose, vt or ascii.

=head2 Options controlling sequence numbering

=over 4

=item B<-base>I<n>

Print OP sequence numbers in base I<n>. If I<n> is greater than 10, the
digit for 11 will be 'a', and so on. If I<n> is greater than 36, the digit
for 37 will be 'A', and so on until 62. Values greater than 62 are not
currently supported. The default is 36.

=item B<-bigendian>

Print sequence numbers with the most significant digit first. This is the
usual convention for Arabic numerals, and the default.

=item B<-littleendian>

Print sequence numbers with the least significant digit first.  This is
obviously mutually exclusive with bigendian.

=back

=head2 Other options

=over 4

=item B<-src>

With this option, the rendering of each statement (starting with the
nextstate OP) will be preceded by the 1st line of source code that
generates it.  For example:

    1  <0> enter
    # 1: my $i;
    2  <;> nextstate(main 1 junk.pl:1) v:{
    3  <0> padsv[$i:1,10] vM/LVINTRO
    # 3: for $i (0..9) {
    4  <;> nextstate(main 3 junk.pl:3) v:{
    5  <0> pushmark s
    6  <$> const[IV 0] s
    7  <$> const[IV 9] s
    8  <{> enteriter(next->j last->m redo->9)[$i:1,10] lKS
    k  <0> iter s
    l  <|> and(other->9) vK/1
    # 4:     print "line ";
    9      <;> nextstate(main 2 junk.pl:4) v
    a      <0> pushmark s
    b      <$> const[PV "line "] s
    c      <@@> print vK
    # 5:     print "$i\n";
    ...

=item B<-stash="somepackage">

With this, "somepackage" will be required, then the stash is
inspected, and each function is rendered.

=back

The following options are pairwise exclusive.

=over 4

=item B<-main>

Include the main program in the output, even if subroutines were also
specified.  This rendering is normally suppressed when a subroutine
name or reference is given.

=item B<-nomain>

This restores the default behavior after you've changed it with '-main'
(it's not normally needed).  If no subroutine name/ref is given, main is
rendered, regardless of this flag.

=item B<-nobanner>

Renderings usually include a banner line identifying the function name
or stringified subref.  This suppresses the printing of the banner.

TBC: Remove the stringified coderef; while it provides a 'cookie' for
each function rendered, the cookies used should be 1,2,3.. not a
random hex-address.  It also complicates string comparison of two
different trees.

=item B<-banner>

restores default banner behavior.

=item B<-banneris> => subref

TBC: a hookpoint (and an option to set it) for a user-supplied
function to produce a banner appropriate for users needs.  It's not
ideal, because the rendering-state variables, which are a natural
candidate for use in concise.t, are unavailable to the user.

=back

=head2 Option Stickiness

If you invoke Concise more than once in a program, you should know that
the options are 'sticky'.  This means that the options you provide in
the first call will be remembered for the 2nd call, unless you
re-specify or change them.

=head1 ABBREVIATIONS

The concise style uses symbols to convey maximum info with minimal
clutter (like hex addresses).  With just a little practice, you can
start to see the flowers, not just the branches, in the trees.

=head2 OP class abbreviations

These symbols appear before the op-name, and indicate the
B:: namespace that represents the ops in your Perl code.

    0      OP (aka BASEOP)  An OP with no children
    1      UNOP             An OP with one child
    +      UNOP_AUX         A UNOP with auxillary fields
    2      BINOP            An OP with two children
    |      LOGOP            A control branch OP
    @@      LISTOP           An OP that could have lots of children
    /      PMOP             An OP with a regular expression
    $      SVOP             An OP with an SV
    "      PVOP             An OP with a string
    {      LOOP             An OP that holds pointers for a loop
    ;      COP              An OP that marks the start of a statement
    #      PADOP            An OP with a GV on the pad
    .      METHOP           An OP with method call info

=head2 OP flags abbreviations

OP flags are either public or private.  The public flags alter the
behavior of each opcode in consistent ways, and are represented by 0
or more single characters.

    v      OPf_WANT_VOID    Want nothing (void context)
    s      OPf_WANT_SCALAR  Want single value (scalar context)
    l      OPf_WANT_LIST    Want list of any length (list context)
                            Want is unknown
    K      OPf_KIDS         There is a firstborn child.
    P      OPf_PARENS       This operator was parenthesized.
                             (Or block needs explicit scope entry.)
    R      OPf_REF          Certified reference.
                             (Return container, not containee).
    M      OPf_MOD          Will modify (lvalue).
    S      OPf_STACKED      Some arg is arriving on the stack.
    *      OPf_SPECIAL      Do something weird for this op (see op.h)

Private flags, if any are set for an opcode, are displayed after a '/'

    8  <@@> leave[1 ref] vKP/REFC ->(end)
    7     <2> sassign vKS/2 ->8

They're opcode specific, and occur less often than the public ones, so
they're represented by short mnemonics instead of single-chars; see
B::Op_private and F<regen/op_private> for more details.

=head1 FORMATTING SPECIFICATIONS

For each line-style ('concise', 'terse', 'linenoise', etc.) there are
3 format-specs which control how OPs are rendered.

The first is the 'default' format, which is used in both basic and exec
modes to print all opcodes.  The 2nd, goto-format, is used in exec
mode when branches are encountered.  They're not real opcodes, and are
inserted to look like a closing curly brace.  The tree-format is tree
specific.

When a line is rendered, the correct format-spec is copied and scanned
for the following items; data is substituted in, and other
manipulations like basic indenting are done, for each opcode rendered.

There are 3 kinds of items that may be populated; special patterns,
#vars, and literal text, which is copied verbatim.  (Yes, it's a set
of s///g steps.)

=head2 Special Patterns

These items are the primitives used to perform indenting, and to
select text from amongst alternatives.

=over 4

=item B<(x(>I<exec_text>B<;>I<basic_text>B<)x)>

Generates I<exec_text> in exec mode, or I<basic_text> in basic mode.

=item B<(*(>I<text>B<)*)>

Generates one copy of I<text> for each indentation level.

=item B<(*(>I<text1>B<;>I<text2>B<)*)>

Generates one fewer copies of I<text1> than the indentation level, followed
by one copy of I<text2> if the indentation level is more than 0.

=item B<(?(>I<text1>B<#>I<var>I<Text2>B<)?)>

If the value of I<var> is true (not empty or zero), generates the
value of I<var> surrounded by I<text1> and I<Text2>, otherwise
nothing.

=item B<~>

Any number of tildes and surrounding whitespace will be collapsed to
a single space.

=back

=head2 # Variables

These #vars represent opcode properties that you may want as part of
your rendering.  The '#' is intended as a private sigil; a #var's
value is interpolated into the style-line, much like "read $this".

These vars take 3 forms:

=over 4

=item B<#>I<var>

A property named 'var' is assumed to exist for the opcodes, and is
interpolated into the rendering.

=item B<#>I<var>I<N>

Generates the value of I<var>, left justified to fill I<N> spaces.
Note that this means while you can have properties 'foo' and 'foo2',
you cannot render 'foo2', but you could with 'foo2a'.  You would be
wise not to rely on this behavior going forward ;-)

=item B<#>I<Var>

This ucfirst form of #var generates a tag-value form of itself for
display; it converts '#Var' into a 'Var => #var' style, which is then
handled as described above.  (Imp-note: #Vars cannot be used for
conditional-fills, because the => #var transform is done after the check
for #Var's value).

=back

The following variables are 'defined' by B::Concise; when they are
used in a style, their respective values are plugged into the
rendering of each opcode.

Only some of these are used by the standard styles, the others are
provided for you to delve into optree mechanics, should you wish to
add a new style (see L</add_style> below) that uses them.  You can
also add new ones using L</add_callback>.

=over 4

=item B<#addr>

The address of the OP, in hexadecimal.

=item B<#arg>

The OP-specific information of the OP (such as the SV for an SVOP, the
non-local exit pointers for a LOOP, etc.) enclosed in parentheses.

=item B<#class>

The B-determined class of the OP, in all caps.

=item B<#classsym>

A single symbol abbreviating the class of the OP.

=item B<#coplabel>

The label of the statement or block the OP is the start of, if any.

=item B<#exname>

The name of the OP, or 'ex-foo' if the OP is a null that used to be a foo.

=item B<#extarg>

The target of the OP, or nothing for a nulled OP.

=item B<#firstaddr>

The address of the OP's first child, in hexadecimal.

=item B<#flags>

The OP's flags, abbreviated as a series of symbols.

=item B<#flagval>

The numeric value of the OP's flags.

=item B<#hints>

The COP's hint flags, rendered with abbreviated names if possible. An empty
string if this is not a COP. Here are the symbols used:

    $ strict refs
    & strict subs
    * strict vars
   x$ explicit use/no strict refs
   x& explicit use/no strict subs
   x* explicit use/no strict vars
    i integers
    l locale
    b bytes
    { block scope
    % localise %^H
    < open in
    > open out
    I overload int
    F overload float
    B overload binary
    S overload string
    R overload re
    T taint
    E eval
    X filetest access
    U utf-8

=item B<#hintsval>

The numeric value of the COP's hint flags, or an empty string if this is not
a COP.

=item B<#hyphseq>

The sequence number of the OP, or a hyphen if it doesn't have one.

=item B<#label>

'NEXT', 'LAST', or 'REDO' if the OP is a target of one of those in exec
mode, or empty otherwise.

=item B<#lastaddr>

The address of the OP's last child, in hexadecimal.

=item B<#name>

The OP's name.

=item B<#NAME>

The OP's name, in all caps.

=item B<#next>

The sequence number of the OP's next OP.

=item B<#nextaddr>

The address of the OP's next OP, in hexadecimal.

=item B<#noise>

A one- or two-character abbreviation for the OP's name.

=item B<#private>

The OP's private flags, rendered with abbreviated names if possible.

=item B<#privval>

The numeric value of the OP's private flags.

=item B<#seq>

The sequence number of the OP. Note that this is a sequence number
generated by B::Concise.

=item B<#seqnum>

5.8.x and earlier only. 5.9 and later do not provide this.

The real sequence number of the OP, as a regular number and not adjusted
to be relative to the start of the real program. (This will generally be
a fairly large number because all of B<B::Concise> is compiled before
your program is).

=item B<#opt>

Whether or not the op has been optimized by the peephole optimizer.

Only available in 5.9 and later.

=item B<#sibaddr>

The address of the OP's next youngest sibling, in hexadecimal.

=item B<#svaddr>

The address of the OP's SV, if it has an SV, in hexadecimal.

=item B<#svclass>

The class of the OP's SV, if it has one, in all caps (e.g., 'IV').

=item B<#svval>

The value of the OP's SV, if it has one, in a short human-readable format.

=item B<#targ>

The numeric value of the OP's targ.

=item B<#targarg>

The name of the variable the OP's targ refers to, if any, otherwise the
letter t followed by the OP's targ in decimal.

=item B<#targarglife>

Same as B<#targarg>, but followed by the COP sequence numbers that delimit
the variable's lifetime (or 'end' for a variable in an open scope) for a
variable.

=item B<#typenum>

The numeric value of the OP's type, in decimal.

=back

=head1 One-Liner Command tips

=over 4

=item perl -MO=Concise,bar foo.pl

Renders only bar() from foo.pl.  To see main, drop the ',bar'.  To see
both, add ',-main'

=item perl -MDigest::MD5=md5 -MO=Concise,md5 -e1

Identifies md5 as an XS function.  The export is needed so that BC can
find it in main.

=item perl -MPOSIX -MO=Concise,_POSIX_ARG_MAX -e1

Identifies _POSIX_ARG_MAX as a constant sub, optimized to an IV.
Although POSIX isn't entirely consistent across platforms, this is
likely to be present in virtually all of them.

=item perl -MPOSIX -MO=Concise,a -e 'print _POSIX_SAVED_IDS'

This renders a print statement, which includes a call to the function.
It's identical to rendering a file with a use call and that single
statement, except for the filename which appears in the nextstate ops.

=item perl -MPOSIX -MO=Concise,a -e 'sub a{_POSIX_SAVED_IDS}'

This is B<very> similar to previous, only the first two ops differ.  This
subroutine rendering is more representative, insofar as a single main
program will have many subs.

=item perl -MB::Concise -e 'B::Concise::compile("-exec","-src", \%B::Concise::)->()'

This renders all functions in the B::Concise package with the source
lines.  It eschews the O framework so that the stashref can be passed
directly to B::Concise::compile().  See -stash option for a more
convenient way to render a package.

=back

=head1 Using B::Concise outside of the O framework

The common (and original) usage of B::Concise was for command-line
renderings of simple code, as given in EXAMPLE.  But you can also use
B<B::Concise> from your code, and call compile() directly, and
repeatedly.  By doing so, you can avoid the compile-time only
operation of O.pm, and even use the debugger to step through
B::Concise::compile() itself.

Once you're doing this, you may alter Concise output by adding new
rendering styles, and by optionally adding callback routines which
populate new variables, if such were referenced from those (just
added) styles.  

=head2 Example: Altering Concise Renderings

    use B::Concise qw(set_style add_callback);
    add_style($yourStyleName => $defaultfmt, $gotofmt, $treefmt);
    add_callback
      ( sub {
            my ($h, $op, $format, $level, $stylename) = @@_;
            $h->{variable} = some_func($op);
        });
    $walker = B::Concise::compile(@@options,@@subnames,@@subrefs);
    $walker->();

=head2 set_style()

B<set_style> accepts 3 arguments, and updates the three format-specs
comprising a line-style (basic-exec, goto, tree).  It has one minor
drawback though; it doesn't register the style under a new name.  This
can become an issue if you render more than once and switch styles.
Thus you may prefer to use add_style() and/or set_style_standard()
instead.

=head2 set_style_standard($name)

This restores one of the standard line-styles: C<terse>, C<concise>,
C<linenoise>, C<debug>, C<env>, into effect.  It also accepts style
names previously defined with add_style().

=head2 add_style ()

This subroutine accepts a new style name and three style arguments as
above, and creates, registers, and selects the newly named style.  It is
an error to re-add a style; call set_style_standard() to switch between
several styles.

=head2 add_callback ()

If your newly minted styles refer to any new #variables, you'll need
to define a callback subroutine that will populate (or modify) those
variables.  They are then available for use in the style you've
chosen.

The callbacks are called for each opcode visited by Concise, in the
same order as they are added.  Each subroutine is passed five
parameters.

  1. A hashref, containing the variable names and values which are
     populated into the report-line for the op
  2. the op, as a B<B::OP> object
  3. a reference to the format string
  4. the formatting (indent) level
  5. the selected stylename

To define your own variables, simply add them to the hash, or change
existing values if you need to.  The level and format are passed in as
references to scalars, but it is unlikely that they will need to be
changed or even used.

=head2 Running B::Concise::compile()

B<compile> accepts options as described above in L</OPTIONS>, and
arguments, which are either coderefs, or subroutine names.

It constructs and returns a $treewalker coderef, which when invoked,
traverses, or walks, and renders the optrees of the given arguments to
STDOUT.  You can reuse this, and can change the rendering style used
each time; thereafter the coderef renders in the new style.

B<walk_output> lets you change the print destination from STDOUT to
another open filehandle, or into a string passed as a ref (unless
you've built perl with -Uuseperlio).

  my $walker = B::Concise::compile('-terse','aFuncName', \&aSubRef); # 1
  walk_output(\my $buf);
  $walker->();			        # 1 renders -terse
  set_style_standard('concise');	# 2
  $walker->();  		        # 2 renders -concise
  $walker->(@@new);			# 3 renders whatever
  print "3 different renderings: terse, concise, and @@new: $buf\n";

When $walker is called, it traverses the subroutines supplied when it
was created, and renders them using the current style.  You can change
the style afterwards in several different ways:

  1. call C<compile>, altering style or mode/order
  2. call C<set_style_standard>
  3. call $walker, passing @@new options

Passing new options to the $walker is the easiest way to change
amongst any pre-defined styles (the ones you add are automatically
recognized as options), and is the only way to alter rendering order
without calling compile again.  Note however that rendering state is
still shared amongst multiple $walker objects, so they must still be
used in a coordinated manner.

=head2 B::Concise::reset_sequence()

This function (not exported) lets you reset the sequence numbers (note
that they're numbered arbitrarily, their goal being to be human
readable).  Its purpose is mostly to support testing, i.e. to compare
the concise output from two identical anonymous subroutines (but
different instances).  Without the reset, B::Concise, seeing that
they're separate optrees, generates different sequence numbers in
the output.

=head2 Errors

Errors in rendering (non-existent function-name, non-existent coderef)
are written to the STDOUT, or wherever you've set it via
walk_output().

Errors using the various *style* calls, and bad args to walk_output(),
result in die().  Use an eval if you wish to catch these errors and
continue processing.

=head1 AUTHOR

Stephen McCamant, E<lt>smcc@@CSUA.Berkeley.EDUE<gt>.

=cut
@


1.12
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d17 1
a17 1
our $VERSION   = "0.992";
d403 2
a404 1
	       'PVOP' => '"', 'LOOP' => "{", 'COP' => ";", 'PADOP' => "#");
d475 6
a480 1
	my $maybe_root = $op->pmreplroot;
d536 9
a544 23
	if ($name =~ /^(null|scalar|lineseq|scope)$/) {
	    next if $oldop and $ {$op->next};
	} else {
	    $sequence_num{$$op} = $seq_max++;
	    if (class($op) eq "LOGOP") {
		my $other = $op->other;
		$other = $other->next while $other->name eq "null";
		sequence($other);
	    } elsif (class($op) eq "LOOP") {
		my $redoop = $op->redoop;
		$redoop = $redoop->next while $redoop->name eq "null";
		sequence($redoop);
		my $nextop = $op->nextop;
		$nextop = $nextop->next while $nextop->name eq "null";
		sequence($nextop);
		my $lastop = $op->lastop;
		$lastop = $lastop->next while $lastop->name eq "null";
		sequence($lastop);
	    } elsif ($name eq "subst" and $ {$op->pmreplstart}) {
		my $replstart = $op->pmreplstart;
		$replstart = $replstart->next while $replstart->name eq "null";
		sequence($replstart);
	    }
a586 1
our %priv; # used to display each opcode's BASEOP.op_private values
d588 6
a593 65
$priv{$_}{128} = "LVINTRO"
  for qw(pos substr vec threadsv gvsv rv2sv rv2hv rv2gv rv2av rv2arylen
         aelem helem aslice hslice padsv padav padhv enteriter entersub
         padrange pushmark);
$priv{$_}{64} = "REFC" for qw(leave leavesub leavesublv leavewrite);
$priv{$_}{128} = "LV" for qw(leave leaveloop);
@@{$priv{aassign}}{32,64} = qw(STATE COMMON);
@@{$priv{sassign}}{32,64,128} = qw(STATE BKWARD CV2GV);
$priv{$_}{64} = "RTIME" for qw(match subst substcont qr);
@@{$priv{$_}}{1,2,4,8,16,64} = qw(<UTF >UTF IDENT SQUASH DEL COMPL GROWS)
  for qw(trans transr);
$priv{repeat}{64} = "DOLIST";
$priv{leaveloop}{64} = "CONT";
@@{$priv{$_}}{32,64,96} = qw(DREFAV DREFHV DREFSV)
  for qw(rv2gv rv2sv padsv aelem helem);
$priv{$_}{16} = "STATE" for qw(padav padhv padsv);
@@{$priv{rv2gv}}{4,16} = qw(NOINIT FAKE);
@@{$priv{entersub}}{1,4,16,32,64} = qw(INARGS TARG DBG DEREF);
@@{$priv{rv2cv}}{1,8,128} = qw(CONST AMPER NO());
$priv{gv}{32} = "EARLYCV";
$priv{$_}{16} = "LVDEFER" for qw(aelem helem);
$priv{$_}{16} = "OURINTR" for qw(gvsv rv2sv rv2av rv2hv r2gv enteriter);
$priv{$_}{8} = "LVSUB"
  for qw(rv2av rv2gv rv2hv padav padhv aelem helem aslice hslice
         av2arylen keys rkeys substr pos vec);
$priv{$_}{4} = "SLICEWARN"
  for qw(rv2hv rv2av padav padhv hslice aslice);
@@{$priv{$_}}{32,64} = qw(BOOL BOOL?) for qw(rv2hv padhv);
$priv{substr}{16} = "REPL1ST";
$priv{$_}{16} = "TARGMY"
  for map(($_,"s$_"), qw(chop chomp)),
      map(($_,"i_$_"), qw(postinc postdec multiply divide modulo add
                          subtract negate)),
      qw(pow concat stringify left_shift right_shift bit_and bit_xor
         bit_or complement atan2 sin cos rand exp log sqrt int hex oct
         abs length index rindex sprintf ord chr crypt quotemeta join
         push unshift flock chdir chown chroot unlink chmod utime rename
         link symlink mkdir rmdir wait waitpid system exec kill getppid
         getpgrp setpgrp getpriority setpriority time sleep);
$priv{$_}{4} = "REVERSED" for qw(enteriter iter);
@@{$priv{const}}{2,4,8,16,64} = qw(NOVER SHORT STRICT ENTERED BARE);
$priv{$_}{64} = "LINENUM" for qw(flip flop);
$priv{list}{64} = "GUESSED";
$priv{delete}{64} = "SLICE";
$priv{exists}{64} = "SUB";
@@{$priv{sort}}{1,2,4,8,16,32,64} = qw(NUM INT REV INPLACE DESC QSORT STABLE);
$priv{reverse}{8} = "INPLACE";
$priv{threadsv}{64} = "SVREFd";
@@{$priv{$_}}{16,32,64,128} = qw(INBIN INCR OUTBIN OUTCR)
  for qw(open backtick);
$priv{$_}{32} = "HUSH" for qw(nextstate dbstate);
$priv{$_}{2} = "FTACCESS"
  for qw(ftrread ftrwrite ftrexec fteread ftewrite fteexec);
@@{$priv{entereval}}{2,4,8,16} = qw(HAS_HH UNI BYTES COPHH);
@@{$priv{$_}}{4,8,16} = qw(FTSTACKED FTSTACKING FTAFTERt)
  for qw(ftrread ftrwrite ftrexec fteread ftewrite fteexec ftis fteowned
         ftrowned ftzero ftsize ftmtime ftatime ftctime ftsock ftchr
         ftblk ftfile ftdir ftpipe ftlink ftsuid ftsgid ftsvtx fttty
         fttext ftbinary);
$priv{$_}{2} = "GREPLEX"
  for qw(mapwhile mapstart grepwhile grepstart);
$priv{$_}{128} = "+1" for qw(caller wantarray runcv);
@@{$priv{coreargs}}{1,2,64,128} = qw(DREF1 DREF2 $MOD MARK);
$priv{$_}{128} = "UTF" for qw(last redo next goto dump);
$priv{split}{128} = "IMPLIM";
d623 3
d628 50
a677 1
    _flags($priv{$name}, $x);
d766 13
a778 3
    if ($h{name} eq "null" and $h{targ}) {
	# targ holds the old type
	$h{exname} = "ex-" . substr(ppname($h{targ}), 3);
d780 4
a783 6
    } elsif ($op->name =~ /^leave(sub(lv)?|write)?$/) {
	# targ potentially holds a reference count
	if ($op->private & 64) {
	    my $refs = "ref" . ($h{targ} != 1 ? "s" : "");
	    $h{targarglife} = $h{targarg} = "$h{targ} $refs";
	}
d785 3
a787 1
	my $count = $h{name} eq 'padrange' ? ($op->private & 127) : 1;
d792 3
a794 1
	    if (defined $padname and class($padname) ne "SPECIAL") {
a890 1
	    my $preferpv = $h{name} eq "method_named";
d893 1
a893 1
		$h{arg} = "[" . concise_sv($sv, \%h, $preferpv) . "]";
d896 1
a896 1
		$h{arg} = "(" . concise_sv($op->sv, \%h, $preferpv) . ")";
d900 22
a935 6
    $h{privval} = $op->private;
    $h{private} = private_flags($h{name}, $op->private);
    if ($op->folded) {
      $h{private} &&= "$h{private},";
      $h{private} .= "FOLD";
    }
d1060 1
a1060 2
# Why is this different for MacOS?  Does it matter?
my $cop_seq_mnum = $^O eq 'MacOS' ? 12 : 11;
d1390 1
d1400 1
d1428 1
a1428 4
F<op.h> for gory details, or try this quick 2-liner:

  $> perl -MB::Concise -de 1
  DB<1> |x \%B::Concise::priv
@


1.11
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d17 1
a17 1
our $VERSION   = "0.95_01";
d49 2
a50 1
   ["#class (#addr)\n\top_next\t\t#nextaddr\n\top_sibling\t#sibaddr\n\t"
d598 28
a625 30
  for ("pos", "substr", "vec", "threadsv", "gvsv", "rv2sv", "rv2hv", "rv2gv",
       "rv2av", "rv2arylen", "aelem", "helem", "aslice", "hslice", "padsv",
       "padav", "padhv", "enteriter", "entersub", "padrange", "pushmark");
$priv{$_}{64} = "REFC" for ("leave", "leavesub", "leavesublv", "leavewrite");
$priv{"aassign"}{64} = "COMMON";
$priv{"aassign"}{32} = "STATE";
$priv{"sassign"}{32} = "STATE";
$priv{"sassign"}{64} = "BKWARD";
$priv{"sassign"}{128}= "CV2GV";
$priv{$_}{64} = "RTIME" for ("match", "subst", "substcont", "qr");
@@{$priv{"trans"}}{1,2,4,8,16,64} = ("<UTF", ">UTF", "IDENT", "SQUASH", "DEL",
				    "COMPL", "GROWS");
$priv{transr} = $priv{trans};
$priv{"repeat"}{64} = "DOLIST";
$priv{"leaveloop"}{64} = "CONT";
$priv{$_}{4} = "DREFed" for (qw(rv2sv rv2av rv2hv));
@@{$priv{$_}}{32,64,96} = ("DREFAV", "DREFHV", "DREFSV")
  for (qw(rv2gv rv2sv padsv aelem helem));
$priv{$_}{16} = "STATE" for ("padav", "padhv", "padsv");
@@{$priv{rv2gv}}{4,16} = qw "NOINIT FAKE";
@@{$priv{"entersub"}}{1,4,16,32,64} = qw( INARGS TARG DBG DEREF );
@@{$priv{rv2cv}}{1,8,128} = ("CONST","AMPER","NO()");
$priv{"gv"}{32} = "EARLYCV";
$priv{"aelem"}{16} = $priv{"helem"}{16} = "LVDEFER";
$priv{$_}{16} = "OURINTR" for ("gvsv", "rv2sv", "rv2av", "rv2hv", "r2gv",
	"enteriter");
$priv{$_}{8} = 'LVSUB' for qw(rv2av rv2gv rv2hv padav padhv aelem helem
                        aslice hslice av2arylen keys rkeys substr pos vec);
@@{$priv{$_}}{32,64} = ('BOOL','BOOL?') for 'rv2hv', 'padhv';
$priv{substr}{16} = 'REPL1ST';
d627 21
a647 24
  for (map(($_,"s$_"),"chop", "chomp"),
       map(($_,"i_$_"), "postinc", "postdec", "multiply", "divide", "modulo",
	   "add", "subtract", "negate"), "pow", "concat", "stringify",
       "left_shift", "right_shift", "bit_and", "bit_xor", "bit_or",
       "complement", "atan2", "sin", "cos", "rand", "exp", "log", "sqrt",
       "int", "hex", "oct", "abs", "length", "index", "rindex", "sprintf",
       "ord", "chr", "crypt", "quotemeta", "join", "push", "unshift", "flock",
       "chdir", "chown", "chroot", "unlink", "chmod", "utime", "rename",
       "link", "symlink", "mkdir", "rmdir", "wait", "waitpid", "system",
       "exec", "kill", "getppid", "getpgrp", "setpgrp", "getpriority",
       "setpriority", "time", "sleep");
$priv{$_}{4} = "REVERSED" for ("enteriter", "iter");
@@{$priv{"const"}}{2,4,8,16,64,128} =
    ("NOVER","SHORT","STRICT","ENTERED","BARE","FOLD");
$priv{"flip"}{64} = $priv{"flop"}{64} = "LINENUM";
$priv{"list"}{64} = "GUESSED";
$priv{"delete"}{64} = "SLICE";
$priv{"exists"}{64} = "SUB";
@@{$priv{"sort"}}{1,2,4,8,16,32,64} = ("NUM", "INT", "REV", "INPLACE","DESC","QSORT","STABLE");
$priv{"reverse"}{8} = "INPLACE";
$priv{"threadsv"}{64} = "SVREFd";
@@{$priv{$_}}{16,32,64,128} = ("INBIN","INCR","OUTBIN","OUTCR")
  for ("open", "backtick");
$priv{"exit"}{128} = "VMS";
d649 7
a655 8
  for ("ftrread", "ftrwrite", "ftrexec", "fteread", "ftewrite", "fteexec");
@@{$priv{"entereval"}}{2,4,8,16} = qw "HAS_HH UNI BYTES COPHH";
@@{$priv{$_}}{4,8,16} = ("FTSTACKED","FTSTACKING","FTAFTERt")
for ("ftrread", "ftrwrite", "ftrexec", "fteread", "ftewrite", "fteexec",
     "ftis", "fteowned", "ftrowned", "ftzero", "ftsize", "ftmtime",
     "ftatime", "ftctime", "ftsock", "ftchr", "ftblk", "ftfile", "ftdir",
     "ftpipe", "ftlink", "ftsuid", "ftsgid", "ftsvtx", "fttty", "fttext",
     "ftbinary");
d657 5
a661 4
for ("mapwhile", "mapstart", "grepwhile", "grepstart");
$priv{$_}{128} = '+1' for qw "caller wantarray runcv";
@@{$priv{coreargs}}{1,2,64,128} = ('DREF1','DREF2','$MOD','MARK');
$priv{$_}{128} = 'UTF' for qw "last redo next goto dump";
d890 1
d921 4
d1647 1
a1647 1
Whether or not the op has been optimised by the peephole optimiser.
d1814 7
a1820 7
    my $walker = B::Concise::compile('-terse','aFuncName', \&aSubRef);  # 1
    walk_output(\my $buf);
    $walker->();			# 1 renders -terse
    set_style_standard('concise');	# 2
    $walker->();			# 2 renders -concise
    $walker->(@@new);			# 3 renders whatever
    print "3 different renderings: terse, concise, and @@new: $buf\n";
@


1.10
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d17 1
a17 1
our $VERSION   = "0.89";
d50 1
a50 2
    . "op_ppaddr\tPL_ppaddr[OP_#NAME]\n\top_type\t\t#typenum\n" .
    ($] > 5.009 ? '' : "\top_seq\t\t#seqnum\n")
d139 1
a139 1
	unless ref $codeobj eq 'B::CV';
a357 1
		my $objref;
d361 2
a362 1
		    $objref = $objname;
a364 1
		    print $walkHandle "$objname:\n";
d366 3
a368 1
		    unless (exists &$objname) {
d372 9
a380 1
		    $objref = \&$objname;
a381 1
		concise_subref($order, $objref, $objname);
d512 3
a514 9
		if ($] > 5.009) {
		    $labels{${$op->nextop}} = "NEXT";
		    $labels{${$op->lastop}} = "LAST";
		    $labels{${$op->redoop}} = "REDO";
		} else {
		    $labels{$op->nextop->seq} = "NEXT";
		    $labels{$op->lastop->seq} = "LAST";
		    $labels{$op->redoop->seq} = "REDO";		
		}
d599 1
a599 1
       "padav", "padhv", "enteriter", "entersub");
d602 1
a602 1
$priv{"aassign"}{32} = $] < 5.009 ? "PHASH" : "STATE";
d625 1
d641 1
a641 1
    ("NOVER","SHORT","STRICT","ENTERED","BARE","WARN");
d655 8
a662 12
if ($] >= 5.009) {
  # Stacked filetests are post 5.8.x
  @@{$priv{$_}}{4,8,16} = ("FTSTACKED","FTSTACKING","FTAFTERt")
    for ("ftrread", "ftrwrite", "ftrexec", "fteread", "ftewrite", "fteexec",
         "ftis", "fteowned", "ftrowned", "ftzero", "ftsize", "ftmtime",
	 "ftatime", "ftctime", "ftsock", "ftchr", "ftblk", "ftfile", "ftdir",
	 "ftpipe", "ftlink", "ftsuid", "ftsgid", "ftsvtx", "fttty", "fttext",
	 "ftbinary");
  # Lexical $_ is post 5.8.x
  $priv{$_}{2} = "GREPLEX"
    for ("mapwhile", "mapstart", "grepwhile", "grepstart");
}
d665 1
d714 8
a721 1
	my $stash = $gv->STASH->NAME; if ($stash eq "main") {
d742 2
a743 1
	} elsif ($preferpv && $sv->FLAGS & SVf_POK) {
d749 1
a749 1
	} elsif ($sv->FLAGS & SVf_POK) {
d797 8
a804 7
	my $padname = (($curcv->PADLIST->ARRAY)[0]->ARRAY)[$h{targ}];
	if (defined $padname and class($padname) ne "SPECIAL") {
	    $h{targarg}  = $padname->PVX;
	    if ($padname->FLAGS & SVf_FAKE) {
		if ($] < 5.009) {
		    $h{targarglife} = "$h{targarg}:FAKE";
		} else {
d809 1
a809 1
		   	if $padname->PARENT_FAKELEX_FLAGS & PAD_FAKELEX_ANON;
d811 1
a811 1
		   	if $padname->PARENT_FAKELEX_FLAGS & PAD_FAKELEX_MULTI;
d814 1
a814 1
		    $h{targarglife} = "$h{targarg}:FAKE:$fake";
d816 8
d825 2
a826 8
	    else {
		my $intro = $padname->COP_SEQ_RANGE_LOW - $cop_seq_base;
		my $finish = int($padname->COP_SEQ_RANGE_HIGH) - $cop_seq_base;
		$finish = "end" if $finish == 999999999 - $cop_seq_base;
		$h{targarglife} = "$h{targarg}:$intro,$finish";
	    }
	} else {
	    $h{targarglife} = $h{targarg} = "t" . $h{targ};
d828 2
d834 1
d842 7
a848 3
	my $pmreplroot = $op->pmreplroot;
	my $pmreplstart;
	if (ref($pmreplroot) eq "B::GV") {
d851 13
a863 13
	    $h{arg} = "($precomp => \@@" . $pmreplroot->NAME . ")";
	} elsif (!ref($pmreplroot) and $pmreplroot) {
	    # same as the last case, except the value is actually a
	    # pad offset for where the GV is kept (this happens under
	    # ithreads)
	    my $gv = (($curcv->PADLIST->ARRAY)[1]->ARRAY)[$pmreplroot];
	    $h{arg} = "($precomp => \@@" . $gv->NAME . ")";
	} elsif ($ {$op->pmreplstart}) {
	    undef $lastnext;
	    $pmreplstart = "replstart->" . seq($op->pmreplstart);
	    $h{arg} = "(" . join(" ", $precomp, $pmreplstart) . ")";
	} else {
	    $h{arg} = "($precomp)";
d865 1
d910 2
a911 7
    if ($] > 5.009) {
	$h{opt} = $op->opt;
	$h{label} = $labels{$$op};
    } else {
	$h{seqnum} = $op->seq;
	$h{label} = $labels{$op->seq};
    }
d1144 2
a1145 1
subroutines to render; if no such functions are specified, the main
@


1.9
log
@merge in perl 5.12.2 plus local changes
@
text
@d17 1
a17 1
our $VERSION   = "0.78";
d309 1
a309 1
		    # It is something that we're staticly linked to, but hasn't
d465 1
a465 1
    elsif (class($op) eq "PMOP") {
d589 1
a589 1
    return "$text\n" if $text ne "";
d598 1
a598 1
       "padav", "padhv", "enteriter");
d604 1
d608 1
d611 1
d615 3
a617 2
@@{$priv{"entersub"}}{16,32,64} = ("DBG","TARG","NOMOD");
@@{$priv{$_}}{4,8,128} = ("INARGS","AMPER","NO()") for ("entersub", "rv2cv");
d622 3
d638 2
a639 1
@@{$priv{"const"}}{4,8,16,32,64,128} = ("SHORT","STRICT","ENTERED",'$[',"BARE","WARN");
d652 1
a652 1
$priv{"entereval"}{2} = "HAS_HH";
d655 1
a655 1
  $priv{$_}{4} = "FTSTACKED"
d665 2
d671 3
a673 3
@@hints{2,512,1024} = ('$', '&', '*');
# integers, locale, bytes, arybase
@@hints{1,4,8,16,32} = ('i', 'l', 'b', '[');
d848 1
a848 1
    } elsif ($h{class} eq "PVOP" and $h{name} ne "trans") {
d861 1
a861 3
	my $arybase = $op->arybase;
	$arybase = $arybase ? ' $[=' . $arybase : "";
	$h{arg} = "($label$stash $cseq $loc$arybase)";
d1264 1
a1264 1
Print seqence numbers with the least significant digit first.  This is
d1550 3
a1555 1
    [ arybase
@


1.8
log
@Merge in perl 5.10.1
@
text
@d17 1
a17 1
our $VERSION   = "0.76";
d302 1
a302 1
	    if (!defined %{$pkg.'::'}) {
d637 1
d1745 1
a1745 1
=head2 add_style()
d1752 1
a1752 1
=head2 add_callback()
@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d17 1
a17 1
our $VERSION   = "0.74";
d31 1
a31 1
	 CVf_ANON PAD_FAKELEX_ANON PAD_FAKELEX_MULTI);
d302 12
a313 1
	    eval "require $pkg" unless defined %{$pkg.'::'};
d712 10
a721 3
	while (class($sv) eq "RV") {
	    $hr->{svval} .= "\\";
	    $sv = $sv->RV;
@


1.6
log
@merge in perl 5.8.8
@
text
@d17 1
a17 1
our $VERSION   = "0.66";
d31 1
a31 1
	 CVf_ANON);
d40 2
a41 2
   ["#hyphseq2 (*(   (x( ;)x))*)<#classsym> "
    . "#exname#arg(?([#targarglife])?)~#flags(?(/#private)?)(x(;~->#next)x)\n"
d52 1
a52 1
    . "\top_flags\t#flagval\n\top_private\t#privval\n"
d77 1
d146 1
d148 2
a149 1
	local *s = $h->{$k};
d155 2
a156 2
	eval { concise_cv_obj($order, $codeobj) }
	or warn "err $@@ on $codeobj";
d169 5
d250 1
d286 1
d296 8
d337 4
d366 6
a371 1
	if (!@@args or $do_main) {
d574 3
d590 2
a591 1
$priv{"aassign"}{32} = "PHASH" if $] < 5.009;
d600 1
d625 1
a625 4
$priv{$_}{64} = "LOCALE"
  for ("sort", "prtf", "sprintf", "slt", "sle", "seq", "sne", "sgt", "sge",
       "scmp", "lc", "uc", "lcfirst", "ucfirst");
@@{$priv{"sort"}}{1,2,4,8,16} = ("NUM", "INT", "REV", "INPLACE","DESC");
d632 1
d646 17
a662 2
sub private_flags {
    my($name, $x) = @@_;
d664 2
a665 2
    for my $flag (128, 96, 64, 32, 16, 8, 4, 2, 1) {
	if ($priv{$name}{$flag} and $x & $flag and $x >= $flag) {
d667 1
a667 1
	    push @@s, $priv{$name}{$flag};
d674 10
d691 1
a691 1
    if ($hr->{svclass} eq "GV") {
d693 1
a693 2
	my $stash = $gv->STASH->NAME;
	if ($stash eq "main") {
d725 17
d771 6
a776 3
		    $fake .= 'a' if $padname->IVX & 1; # PAD_FAKELEX_ANON
		    $fake .= 'm' if $padname->IVX & 2; # PAD_FAKELEX_MULTI
		    $fake .= ':' . $padname->NVX if $curcv->CvFLAGS & CVf_ANON;
d781 2
a782 2
		my $intro = $padname->NVX - $cop_seq_base;
		my $finish = int($padname->IVX) - $cop_seq_base;
d827 1
d829 2
a830 1
	$loc .= ":" . $op->line;
d835 8
a866 1
	$h{static} = $op->static;
d884 6
d1039 2
a1040 3
Here's an example of 2 outputs (aka 'renderings'), using the
-exec and -basic (i.e. default) formatting conventions on the same code
snippet.
d1052 2
a1053 2
Each line corresponds to an opcode. The opcode marked with '*' is used
in a few examples below.
d1056 3
a1058 2
displayed in base 36 by default.  This rendering is in -exec (i.e.
execution) order.
d1064 1
a1064 1
The opname, as in B<'add[t1]'>, which may be followed by op-specific
d1067 1
a1067 1
The op-flags (ex B<'sK/2'>) follow, and are described in (L</"OP flags
d1104 3
a1106 3
subroutines to print the OPs of; if no such functions are specified,
the main body of the program (outside any subroutines, and not
including use'd or require'd files) is rendered.  Passing C<BEGIN>,
d1108 1
a1108 1
special blocks to be printed.
d1244 36
a1279 1
These are pairwise exclusive.
d1515 31
a1606 7
=item B<#static>

Whether or not the op is statically defined.  This flag is used by the
B::C compiler backend and indicates that the op should not be freed.

Only available in 5.9 and later.

d1641 41
@


1.5
log
@sync in-tree perl with 5.8.6
@
text
@d17 1
a17 1
our $VERSION   = "0.64";
d135 1
a135 1
    my($order, $coderef) = @@_;
d138 1
a138 1
    return concise_stashref(@@_)	
d140 1
a140 1
    concise_cv_obj($order, $codeobj);
d159 1
a159 1
sub concise_cv { concise_subref(@@_); }
d162 3
a164 1
    my ($order, $cv) = @@_;
d166 17
a182 1
    die "err: coderef has no START\n" if class($cv->START) eq "NULL";
d186 9
a194 2
    } elsif ($order eq "basic") {
	walk_topdown($cv->ROOT, sub { $_[0]->concise($_[1]) }, 0);
d221 1
a221 1
	splice(@@cv_s, 0, 7); # skip 7 BEGIN blocks in this file
d228 1
a228 1
	concise_cv_obj($order, $cv);
d245 5
a249 2
    my @@options = grep(/^-/, @@_);
    my @@args = grep(!/^-/, @@_);
d309 2
a310 2
			       B::begin_av->isa("B::AV") ?
			       B::begin_av->ARRAY : ());
d313 2
a314 2
			       B::init_av->isa("B::AV") ?
			       B::init_av->ARRAY : ());
d317 2
a318 2
			       B::check_av->isa("B::AV") ?
			       B::check_av->ARRAY : ());
d321 2
a322 2
                                     B::end_av->isa("B::AV") ?
			       B::end_av->ARRAY : ());
d335 4
a338 2
		    die "err: unknown function ($objname)\n"
			unless *{$objname}{CODE};
d341 1
a341 1
		concise_subref($order, $objref);
d379 1
a379 1
sub op_flags {
d427 1
a427 1
    if (class($op) eq "PMOP") {
d552 2
a553 1
my %priv;
d562 1
a562 1
$priv{$_}{64} = "RTIME" for ("match", "subst", "substcont");
d630 1
a630 1
    my($sv, $hr) = @@_;
d634 1
d653 2
d765 2
a766 1
    } elsif ($h{class} eq "SVOP") {
d768 5
a772 3
	    if (! ${$op->sv}) {
		my $sv = (($curcv->PADLIST->ARRAY)[1]->ARRAY)[$op->targ];
		$h{arg} = "[" . concise_sv($sv, \%h) . "]";
d775 1
a775 1
		$h{arg} = "(" . concise_sv($op->sv, \%h) . ")";
a777 3
    } elsif ($h{class} eq "PADOP") {
	my $sv = (($curcv->PADLIST->ARRAY)[1]->ARRAY)[$op->padix];
	$h{arg} = "[" . concise_sv($sv, \%h) . "]";
d944 1
a944 1
information displyed is customizable. Its function is similar to that of
d950 30
a979 2
Here's is a short example of output (aka 'rendering'), using the
default formatting conventions :
d986 1
a986 1
    5        <2> add[t1] sK/2 ->6
d993 17
a1009 5
Each line corresponds to an opcode. Null ops appear as C<ex-opname>,
where I<opname> is the op that has been optimized away by perl.

The number on the first row indicates the op's sequence number. It's
given in base 36 by default.
a1010 14
The symbol between angle brackets indicates the op's type : for example,
<2> is a BINOP, <@@> a LISTOP, etc. (see L</"OP class abbreviations">).

The opname may be followed by op-specific information in parentheses
(e.g. C<gvsv(*b)>), and by targ information in brackets (e.g.
C<leave[t1]>).

Next come the op flags. The common flags are listed below
(L</"OP flags abbreviations">). The private flags follow, separated
by a slash. For example, C<vKP/REFC> means that the leave op has
public flags OPf_WANT_VOID, OPf_KIDS, and OPf_PARENS, and the private
flag OPpREFCOUNTED.

Finally an arrow points to the sequence number of the next op.
d1017 1
a1017 1
including use'd or require'd files) is printed. Passing C<BEGIN>,
d1037 3
a1039 2
level in the tree.  This mode is the default, so the flag is included
simply for completeness.
d1226 3
a1228 2
These symbols represent various flags which alter behavior of the
opcode, sometimes in opcode-specific ways.
d1233 1
d1243 12
d1346 1
a1346 1
also add new ones using L<add_callback>.
d1381 1
a1381 1
The address of the OP's first child, in hexidecimal.
d1402 1
a1402 1
The address of the OP's last child, in hexidecimal.
d1418 1
a1418 1
The address of the OP's next OP, in hexidecimal.
d1461 1
a1461 1
The address of the OP's next youngest sibling, in hexidecimal.
d1465 1
a1465 1
The address of the OP's SV, if it has an SV, in hexidecimal.
d1546 4
a1549 3
If your newly minted styles refer to any #variables, you'll need to
define a callback subroutine that will populate (or modify) those
variables.  They are then available for use in the style you've chosen.
d1578 2
a1579 2
another open filehandle, or (unless you've built with -Uuseperlio)
into a string passed as a ref.
d1616 7
a1622 6
All detected errors, (invalid arguments, internal errors, etc.) are
resolved with a die($message). Use an eval if you wish to catch these
errors and continue processing.

In particular, B<compile> will die if you've asked for a non-existent
function-name, a non-existent coderef, or a non-CODE reference.
@


1.4
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d17 1
a17 3
# Maint doesn't have patch 22353 (op_seq changes)

our $VERSION   = "0.61";
d19 8
a26 3
our @@EXPORT_OK = qw(set_style set_style_standard add_callback
		    concise_subref concise_cv concise_main
		    add_style walk_output);
d41 2
a42 2
    . "#exname#arg(?([#targarglife])?)~#flags(?(/#private)?)(x(;~->#next)x)\n",
    "  (*(    )*)     goto #seq\n",
d50 3
a52 2
    . "op_ppaddr\tPL_ppaddr[OP_#NAME]\n\top_type\t\t#typenum\n\top_seq\t\t"
    . "#seqnum\n\top_flags\t#flagval\n\top_private\t#privval\n"
d76 1
d78 1
a78 1
# another factor:
d112 2
a113 1
our $walkHandle = \*STDOUT;	# public for your convenience
d117 2
d120 3
d124 1
a124 1
	open my $tmp, '>', $handle;	# but cant re-set an existing filehandle
d126 1
a126 1
	return;
d128 3
a131 3
    my $iotype = ref $walkHandle;
    die "expecting argument/object that can print\n"
	unless $iotype eq 'GLOB' or $iotype and $walkHandle->can('print');
d137 3
a139 1
    die "err: not a coderef: $coderef\n" unless ref $codeobj eq 'B::CV';#CODE';
d143 14
d217 3
a219 1
sub compile {
a221 1
    my $do_main = 0;
d223 1
d230 3
a232 1
	} elsif ($o eq "-compact") {
d240 3
a242 3
	} elsif ($o eq "-main") {
	    $do_main = 1;
	} elsif ($o =~ /^-base(\d+)$/) {
d248 3
d252 6
a257 1
	    $banner = 0;
d259 1
d267 5
d273 30
a302 18
	if (@@args) {
	    for my $objname (@@args) {
		if ($objname eq "BEGIN") {
		    concise_specials("BEGIN", $order,
				     B::begin_av->isa("B::AV") ?
				     B::begin_av->ARRAY : ());
		} elsif ($objname eq "INIT") {
		    concise_specials("INIT", $order,
				     B::init_av->isa("B::AV") ?
				     B::init_av->ARRAY : ());
		} elsif ($objname eq "CHECK") {
		    concise_specials("CHECK", $order,
				     B::check_av->isa("B::AV") ?
				     B::check_av->ARRAY : ());
		} elsif ($objname eq "END") {
		    concise_specials("END", $order,
				     B::end_av->isa("B::AV") ?
				     B::end_av->ARRAY : ());
d304 6
a309 15
		    # convert function names to subrefs
		    my $objref;
		    if (ref $objname) {
			print $walkHandle "B::Concise::compile($objname)\n"
			    if $banner;
			$objref = $objname;
		    } else {
			$objname = "main::" . $objname unless $objname =~ /::/;
			print $walkHandle "$objname:\n";
			no strict 'refs';
			die "err: unknown function ($objname)\n"
			    unless *{$objname}{CODE};
			$objref = \&$objname;
		    }
		    concise_subref($order, $objref);
d311 1
d318 1
d380 1
d437 9
a445 3
		$labels{$op->nextop->seq} = "NEXT";
		$labels{$op->lastop->seq} = "LAST";
		$labels{$op->redoop->seq} = "REDO";		
d489 4
a492 1
    my($hr, $text, $level) = @@_;
d494 1
d496 1
d500 1
d502 2
d505 2
d508 5
d515 2
a516 2
    $text =~ s/\#([a-zA-Z]+)/$hr->{$1}/eg;  # populate data into template
    $text =~ s/[ \t]*~+[ \t]*/ /g;
d538 1
a538 2
$priv{"entersub"}{16} = "DBG";
$priv{"entersub"}{32} = "TARG";
d556 2
a557 1
@@{$priv{"const"}}{8,16,32,64,128} = ("STRICT","ENTERED", '$[', "BARE", "WARN");
d565 1
a565 1
@@{$priv{"sort"}}{1,2,4,8} = ("NUM", "INT", "REV", "INPLACE");
d630 4
a633 1
	return $hr->{svclass} . " " .  $hr->{svval};
d747 8
a754 1
    $h{seqnum} = $op->seq;
a767 1
    $h{label} = $labels{$op->seq};
d771 1
a771 2
    $_->(\%h, $op, \$format, \$level, $stylename) for @@callbacks;
    return fmt_line(\%h, $format, $level);
d778 5
a782 3
	my $h = {"seq" => seq($lastnext), "class" => class($lastnext),
		 "addr" => sprintf("%#x", $$lastnext)};
	print $walkHandle fmt_line($h, $gotofmt, $level+1);
d807 2
a808 1
	print fmt_line($h, $style{"terse"}[1], $level+1);
d811 2
a812 1
    print concise_op($op, $level, $style{"terse"}[0]);
d851 10
a860 11
# they're compiling, their presence tends to distort the view we have
# of the code we're looking at. In particular, perl gives sequence
# numbers to both OPs in general and COPs in particular. If the
# program we're looking at were run on its own, these numbers would
# start at 1. Because all of B::Concise and all the modules it uses
# are compiled first, though, by the time we get to the user's program
# the sequence numbers are alreay at pretty high numbers, which would
# be distracting if you're trying to tell OPs apart. Therefore we'd
# like to subtract an offset from all the sequence numbers we display,
# to restore the simpler view of the world. The trick is to know what
# that offset will be, when we're still compiling B::Concise!  If we
d862 9
a870 11
# other modules we use do. To help a little, what we do here is
# compile a little code at the end of the module, and compute the base
# sequence number for the user's program as being a small offset
# later, so all we have to worry about are changes in the offset.
# (Note that we now only play this game with COP sequence numbers. OP
# sequence numbers aren't used to refer to OPs from a distance, and
# they don't have much significance, so we just generate our own
# sequence numbers which are easier to control. This way we also don't
# stand in the way of a possible future removal of OP sequence
# numbers).
 
d1094 2
d1101 18
a1118 1
specified.  This is the only option that is not sticky (see below)
d1122 8
a1129 4
B::Concise::compile normally prints a banner line identifying the
function name, or in case of a subref, a generic message including
(unfortunately) the stringified coderef.  This option suppresses the
printing of the banner.
d1140 40
d1191 12
a1202 4
When a line is rendered, the correct format string is scanned for the
following items, and data is substituted in, or other manipulations,
like basic indenting.  Any text that doesn't match a special pattern
(the items below) is copied verbatim.  (Yes, it's a set of s///g steps.)
d1225 17
d1244 2
a1245 1
Generates the value of the variable I<var>.
d1249 12
a1260 6
Generates the value of I<var>, left jutified to fill I<N> spaces.

=item B<~>

Any number of tildes and surrounding whitespace will be collapsed to
a single space.
d1264 8
a1271 1
The following variables are recognized:
d1277 1
a1277 1
The address of the OP, in hexidecimal.
d1282 1
a1282 1
non-local exit pointers for a LOOP, etc.) enclosed in paretheses.
d1359 2
a1360 3
The sequence number of the OP. Note that this is now a sequence number
generated by B::Concise, rather than the real op_seq value (for which
see B<#seqnum>).
d1364 2
d1371 13
a1420 30
=head1 ABBREVIATIONS

=head2 OP flags abbreviations

    v      OPf_WANT_VOID    Want nothing (void context)
    s      OPf_WANT_SCALAR  Want single value (scalar context)
    l      OPf_WANT_LIST    Want list of any length (list context)
    K      OPf_KIDS         There is a firstborn child.
    P      OPf_PARENS       This operator was parenthesized.
                             (Or block needs explicit scope entry.)
    R      OPf_REF          Certified reference.
                             (Return container, not containee).
    M      OPf_MOD          Will modify (lvalue).
    S      OPf_STACKED      Some arg is arriving on the stack.
    *      OPf_SPECIAL      Do something weird for this op (see op.h)

=head2 OP class abbreviations

    0      OP (aka BASEOP)  An OP with no children
    1      UNOP             An OP with one child
    2      BINOP            An OP with two children
    |      LOGOP            A control branch OP
    @@      LISTOP           An OP that could have lots of children
    /      PMOP             An OP with a regular expression
    $      SVOP             An OP with an SV
    "      PVOP             An OP with a string
    {      LOOP             An OP that holds pointers for a loop
    ;      COP              An OP that marks the start of a statement
    #      PADOP            An OP with a GV on the pad

d1423 3
a1425 1
You can use B<B::Concise>, and call compile() directly, and
d1427 2
a1428 2
operation of 'perl -MO=Concise ..'.  For example, you can use the
debugger to step through B::Concise::compile() itself.
d1430 4
a1433 4
When doing so, you can alter Concise output by providing new output
styles, and optionally by adding callback routines which populate new
variables that may be rendered as part of those styles.  For all
following sections, please review L</FORMATTING SPECIFICATIONS>.
d1438 1
a1438 1
    set_style($your_format, $your_gotofmt, $your_treefmt);
d1443 3
a1445 3
        }
      );
    B::Concise::compile(@@options)->();
d1496 4
a1499 4
compile() constructs and returns a coderef, which when invoked, scans
the optree, and prints the results to STDOUT.  Once you have the
coderef, you may change the output style; thereafter the coderef renders
in the new style.
d1502 2
a1503 1
another open filehandle, or into a string passed as a ref.
d1505 1
d1507 20
a1526 12
    my $walker = B::Concise::compile('-concise','funcName', \&aSubRef);
    print "Concise Banner for Functions: $buf\n";
    $walker->();
    print "Concise Rendering(s)?: $buf\n";

For each subroutine visited by Concise, the $buf will contain a
banner naming the function or coderef about to be traversed.
Once $walker is invoked, it prints the actual renderings for each.

To switch back to one of the standard styles like C<concise> or
C<terse>, call C<set_style_standard>, or pass the style name into
B::Concise::compile() (as done above).
@


1.3
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d17 3
a19 1
our $VERSION   = "0.56";
d22 2
a23 1
		    concise_subref concise_cv concise_main);
d27 2
a28 1
	 SVf_IOK SVf_NOK SVf_POK SVf_IVisUV SVf_FAKE OPf_KIDS CVf_ANON);
d30 1
a30 1
my %style = 
d57 21
a77 1
my($format, $gotofmt, $treefmt);
a79 1
my @@callbacks;
d83 11
d97 3
a99 2
    my($name) = @@_;
    set_style(@@{$style{$name}});
d106 17
d124 4
a127 2
    my($order, $subref) = @@_;
    concise_cv_obj($order, svref_2object($subref));
d137 1
d144 1
a144 1
	print tree($cv->ROOT, 0)
d157 1
a157 1
	print tree(main_root, 0);
d173 2
a174 2
    for my $cv (@@cv_s) {	
	print "$name $i:\n";
d183 1
a183 1
my @@tree_decorations = 
a188 8
my $tree_style = 0;

my $base = 36;
my $big_endian = 1;

my $order = "basic";

set_style_standard("concise");
d217 6
a222 2
	} elsif (exists $style{substr($o, 1)}) {
	    set_style(@@{$style{substr($o, 1)}});
d247 15
a261 4
		    $objname = "main::" . $objname unless $objname =~ /::/;
		    print "$objname:\n";
		    eval "concise_subref(\$order, \\&$objname)";
		    die "concise_subref($order, \\&$objname) failed: $@@" if $@@;
d266 1
a266 1
	    print "main program:\n" if $do_main;
d273 1
a273 1
my $lastnext;
d326 6
d431 4
a434 3
sub fmt_line {
    my($hr, $fmt, $level) = @@_;
    my $text = $fmt;
d436 2
a437 1
      $hr->{$2} ? $1.$hr->{$2}.$3 : ""/eg;
d441 3
a443 2
    $text =~ s/#([a-zA-Z]+)(\d+)/sprintf("%-$2s", $hr->{$1})/eg;
    $text =~ s/#([a-zA-Z]+)/$hr->{$1}/eg;
d445 3
a447 1
    return $text;
d457 1
a457 1
$priv{"aassign"}{32} = "PHASH";
d465 1
a465 1
  for ("entersub", map("rv2${_}v", "a", "s", "h", "g"), "aelem", "helem");
d493 1
a493 1
@@{$priv{"sort"}}{1,2,4} = ("NUM", "INT", "REV");
d500 12
d585 11
a595 1
		$h{targarglife} = "$h{targarg}:FAKE";
d657 8
a664 6
	if (! ${$op->sv}) {
	    my $sv = (($curcv->PADLIST->ARRAY)[1]->ARRAY)[$op->targ];
	    $h{arg} = "[" . concise_sv($sv, \%h) . "]";
	    $h{targarglife} = $h{targarg} = "";
	} else {
	    $h{arg} = "(" . concise_sv($op->sv, \%h) . ")";
d689 2
a690 1
    $_->(\%h, $op, \$format, \$level) for @@callbacks;
d697 1
d700 1
a700 1
	print fmt_line($h, $gotofmt, $level+1);
d703 1
a703 1
    print concise_op($op, $level, $format);
d722 1
d754 1
a754 1
		$lines[$i] = $kid . $lines[$i];		
d789 1
a789 1

d835 2
a836 2
Here's is a short example of output, using the default formatting
conventions :
d850 1
a850 1
Each line corresponds to an operator. Null ops appear as C<ex-opname>,
d880 10
d916 44
d984 5
a988 1
=item B<-main>
d990 1
a990 2
Include the main program in the output, even if subroutines were also
specified.
d1006 2
a1007 1
Print seqence numbers with the least significant digit first.
d1009 1
a1009 1
=item B<-concise>
d1011 1
a1011 2
Use the author's favorite set of formatting conventions. This is the
default, of course.
d1013 1
a1013 1
=item B<-terse>
d1015 1
a1015 5
Use formatting conventions that emulate the output of B<B::Terse>. The
basic mode is almost indistinguishable from the real B<B::Terse>, and the
exec mode looks very similar, but is in a more logical order and lacks
curly brackets. B<B::Terse> doesn't have a tree mode, so the tree mode
is only vaguely reminiscient of B<B::Terse>.
d1017 2
a1018 1
=item B<-linenoise>
d1020 1
a1020 3
Use formatting conventions in which the name of each OP, rather than being
written out in full, is represented by a one- or two-character abbreviation.
This is mainly a joke.
d1022 4
a1025 1
=item B<-debug>
d1027 1
a1027 2
Use formatting conventions reminiscient of B<B::Debug>; these aren't
very concise at all.
d1029 1
a1029 1
=item B<-env>
d1031 4
a1034 2
Use formatting conventions read from the environment variables
C<B_CONCISE_FORMAT>, C<B_CONCISE_GOTO_FORMAT>, and C<B_CONCISE_TREE_FORMAT>.
d1036 1
a1036 1
=back
d1038 2
a1039 1
=head1 FORMATTING SPECIFICATIONS
d1041 10
a1050 6
For each general style ('concise', 'terse', 'linenoise', etc.) there are
three specifications: one of how OPs should appear in the basic or exec
modes, one of how 'goto' lines should appear (these occur in the exec
mode only), and one of how nodes should appear in tree mode. Each has the
same format, described below. Any text that doesn't match a special
pattern is copied verbatim.
d1256 11
a1266 2
It is possible to extend B<B::Concise> by using it outside of the B<O>
framework and providing new styles and new variables.
d1269 1
a1269 1
    set_style($format, $gotofmt, $treefmt);
d1271 2
a1272 4
    (
        sub
        {
            my ($h, $op, $level, $format) = @@_;
d1275 1
a1275 1
    );
d1278 38
a1315 11
You can specify a style by calling the B<set_style> subroutine.  If you
have a new variable in your style, or you want to change the value of an
existing variable, you will need to add a callback to specify the value
for that variable.

This is done by calling B<add_callback> passing references to any
callback subroutines.  The subroutines are called in the same order as
they are added.  Each subroutine is passed four parameters.  These are a
reference to a hash, the keys of which are the names of the variables
and the values of which are their values, the op, the level and the
format.
d1322 23
d1346 18
a1363 1
C<terse>, use C<set_style_standard>.
d1365 2
a1366 2
To see the output, call the subroutine returned by B<compile> in the
same way that B<O> does.
@


1.2
log
@spelling
@
text
@d2 1
a2 1
# Copyright (C) 2000, 2001 Stephen McCamant. All rights reserved.
d6 5
a10 2
use strict;
use warnings;
d12 2
a13 1
use Exporter ();
d15 3
a17 1
our $VERSION   = "0.52";
d19 2
a20 1
our @@EXPORT_OK = qw(set_style add_callback);
d22 1
d24 1
a24 1
	 SVf_IOK SVf_NOK SVf_POK OPf_KIDS);
d55 1
a55 1
my($seq_base, $cop_seq_base);
d62 5
d71 11
a81 3
sub concise_cv {
    my ($order, $cvref) = @@_;
    my $cv = svref_2object($cvref);
d83 1
d93 32
d141 1
a141 1
set_style(@@{$style{concise}});
d176 2
a177 2
    if (@@args) {
	return sub {
d179 22
a200 3
		$objname = "main::" . $objname unless $objname =~ /::/;
		eval "concise_cv(\$order, \\&$objname)";
		die "concise_cv($order, \\&$objname) failed: $@@" if $@@;
d203 3
a205 15
    }
    if (!@@args or $do_main) {
	if ($order eq "exec") {
	    return sub { return if class(main_start) eq "NULL";
			 $curcv = main_cv;
			 walk_exec(main_start) }
	} elsif ($order eq "tree") {
	    return sub { return if class(main_root) eq "NULL";
			 $curcv = main_cv;
			 print tree(main_root, 0) }
	} elsif ($order eq "basic") {
	    return sub { return if class(main_root) eq "NULL";
			 $curcv = main_cv;
			 walk_topdown(main_root,
				      sub { $_[0]->concise($_[1]) }, 0); }
d217 1
a217 1
no warnings 'qw'; # "Possible attempt to put comments..."
d233 1
a233 1
     Pu GP SP EP Gn Gg GG SG EG g0 c$ lk t$ ;s n>';
d261 8
a268 1
sub seq { return $_[0]->seq ? base_n($_[0]->seq - $seq_base) : "-" }
d278 7
a284 3
    if (class($op) eq "PMOP" and $ {$op->pmreplroot}
	and $op->pmreplroot->isa("B::OP")) {
	walk_topdown($op->pmreplroot, $sub, $level + 1);
d309 1
a309 2
	    if ($name
		=~ /^(or|and|(map|grep)while|entertry|range|cond_expr)$/) {
d327 36
d381 1
a381 1
       "padav", "padhv");
d398 2
a399 1
$priv{$_}{16} = "OURINTR" for ("gvsv", "rv2sv", "rv2av", "rv2hv", "r2gv");
d422 2
a423 4
$priv{$_}{16} = "INBIN" for ("open", "backtick");
$priv{$_}{32} = "INCR" for ("open", "backtick");
$priv{$_}{64} = "OUTBIN" for ("open", "backtick");
$priv{$_}{128} = "OUTCR" for ("open", "backtick");
d425 2
d441 36
d486 1
d489 6
d499 9
a507 4
	    my $intro = $padname->NVX - $cop_seq_base;
	    my $finish = int($padname->IVX) - $cop_seq_base;
	    $finish = "end" if $finish == 999999999 - $cop_seq_base;
	    $h{targarglife} = "$h{targarg}:$intro,$finish";
d517 4
a520 7
	    # Escape literal control sequences
	    for ($precomp) {
		s/\t/\\t/g; s/\n/\\n/g; s/\r/\\r/g;
		# How can we do the below portably?
		#s/([\0-\037\177-\377])/"\\".sprintf("%03o", ord($1))/eg;
	    }
	    $precomp = "/$precomp/";
a521 1
	else { $precomp = ""; }
d524 1
a524 1
	if ($$pmreplroot && $pmreplroot->isa("B::GV")) {
d526 1
a526 1
	    #  *stash_array is stored in pmreplroot.
d528 6
d562 4
a565 13
	my $sv = $op->sv;
	$h{svclass} = class($sv);
	$h{svaddr} = sprintf("%#x", $$sv);
	if ($h{svclass} eq "GV") {
	    my $gv = $sv;
	    my $stash = $gv->STASH->NAME;
	    if ($stash eq "main") {
		$stash = "";
	    } else {
		$stash = $stash . "::";
	    }
	    $h{arg} = "(*$stash" . $gv->SAFENAME . ")";
	    $h{svval} = "*$stash" . $gv->SAFENAME;
d567 1
a567 14
	    while (class($sv) eq "RV") {
		$h{svval} .= "\\";
		$sv = $sv->RV;
	    }
	    if (class($sv) eq "SPECIAL") {
		$h{svval} = ["Null", "sv_undef", "sv_yes", "sv_no"]->[$$sv];
	    } elsif ($sv->FLAGS & SVf_NOK) {
		$h{svval} = $sv->NV;
	    } elsif ($sv->FLAGS & SVf_IOK) {
		$h{svval} = $sv->IV;
	    } elsif ($sv->FLAGS & SVf_POK) {
		$h{svval} = cstring($sv->PV);
	    }
	    $h{arg} = "($h{svclass} $h{svval})";
d569 3
d607 24
d683 6
d700 3
a702 3
# If either of the marked numbers there aren't 1, it means you need to
# update the corresponding magic number in the next two lines.
# Remember, these need to stay the last things in the module.
d704 1
a704 1
# Why these are different for MacOS?  Does it matter?
a705 1
my $seq_mnum = $^O eq 'MacOS' ? 100 : 84;
a706 1
$seq_base = svref_2object(eval 'sub{}')->START->seq + $seq_mnum;
d739 1
a739 1
    8  <@@> leave[t1] vKP/REFC ->(end)
d774 5
a778 3
subroutines to print the OPs of; if no such functions are specified, the
main body of the program (outside any subroutines, and not including use'd
or require'd files) is printed.
d1003 1
a1003 1
The two-character abbreviation for the OP's name.
d1015 3
a1017 1
The sequence number of the OP.
d1127 3
d1135 1
a1135 1
Stephen McCamant, C<smcc@@CSUA.Berkeley.EDU>
@


1.1
log
@Initial revision
@
text
@a5 1
our $VERSION = "0.51";
d7 8
d48 9
d87 2
a92 1
    ($format, $gotofmt, $treefmt) = @@{$style{"concise"}};
d117 1
a117 1
	    ($format, $gotofmt, $treefmt) = @@{$style{substr($o, 1)}};
d154 1
a154 1
	       'PVOP' => '"', 'LOOP' => "{", 'COP' => ";");
d156 1
d304 1
a304 1
@@{$priv{"const"}}{8,16,32,64,128} = ("STRICT","ENTERED", "$[", "BARE", "WARN");
d360 10
a369 1
	$precomp = defined($precomp) ? "/$precomp/" : "";
d371 2
a372 2
	my ($pmreplroot, $pmreplstart);
	if ($ {$pmreplroot = $op->pmreplroot} && $pmreplroot->isa("B::GV")) {
d453 1
d502 38
a539 4
# This is a bit of a hack; the 2 and 15 were determined empirically.
# These need to stay the last things in the module.
$cop_seq_base = svref_2object(eval 'sub{0;}')->START->cop_seq + 2;
$seq_base = svref_2object(eval 'sub{}')->START->seq + 15;
d553 2
d566 38
d689 1
a689 1
Use formatting conventions that emulate the ouput of B<B::Terse>. The
d775 1
a775 1
=item B<#classym>
d803 1
a803 1
=item B<#hyphenseq>
d920 38
@


1.1.1.1
log
@stock perl 5.6.1
@
text
@@


1.1.1.2
log
@stock perl 5.8.0 from CPAN
@
text
@d6 1
a7 8
use warnings;

use Exporter ();

our $VERSION   = "0.52";
our @@ISA       = qw(Exporter);
our @@EXPORT_OK = qw(set_style add_callback);

a40 9
my @@callbacks;

sub set_style {
    ($format, $gotofmt, $treefmt) = @@_;
}

sub add_callback {
    push @@callbacks, @@_;
}
a70 2
set_style(@@{$style{concise}});

d75 1
d100 1
a100 1
	    set_style(@@{$style{substr($o, 1)}});
d137 1
a137 1
	       'PVOP' => '"', 'LOOP' => "{", 'COP' => ";", 'PADOP' => "#");
a138 1
no warnings 'qw'; # "Possible attempt to put comments..."
d286 1
a286 1
@@{$priv{"const"}}{8,16,32,64,128} = ("STRICT","ENTERED", '$[', "BARE", "WARN");
d342 1
a342 10
	if (defined $precomp) {
	    # Escape literal control sequences
	    for ($precomp) {
		s/\t/\\t/g; s/\n/\\n/g; s/\r/\\r/g;
		# How can we do the below portably?
		#s/([\0-\037\177-\377])/"\\".sprintf("%03o", ord($1))/eg;
	    }
	    $precomp = "/$precomp/";
	}
	else { $precomp = ""; }
d344 2
a345 2
	my $pmreplstart;
	if ($$pmreplroot && $pmreplroot->isa("B::GV")) {
a425 1
    $_->(\%h, $op, \$format, \$level) for @@callbacks;
d474 4
a477 38
# *** Warning: fragile kludge ahead ***
# Because the B::* modules run in the same interpreter as the code
# they're compiling, their presence tends to distort the view we have
# of the code we're looking at. In particular, perl gives sequence
# numbers to both OPs in general and COPs in particular. If the
# program we're looking at were run on its own, these numbers would
# start at 1. Because all of B::Concise and all the modules it uses
# are compiled first, though, by the time we get to the user's program
# the sequence numbers are alreay at pretty high numbers, which would
# be distracting if you're trying to tell OPs apart. Therefore we'd
# like to subtract an offset from all the sequence numbers we display,
# to restore the simpler view of the world. The trick is to know what
# that offset will be, when we're still compiling B::Concise!  If we
# hardcoded a value, it would have to change every time B::Concise or
# other modules we use do. To help a little, what we do here is
# compile a little code at the end of the module, and compute the base
# sequence number for the user's program as being a small offset
# later, so all we have to worry about are changes in the offset.

# When you say "perl -MO=Concise -e '$a'", the output should look like:

# 4  <@@> leave[t1] vKP/REFC ->(end)
# 1     <0> enter ->2
 #^ smallest OP sequence number should be 1
# 2     <;> nextstate(main 1 -e:1) v ->3
 #                         ^ smallest COP sequence number should be 1
# -     <1> ex-rv2sv vK/1 ->4
# 3        <$> gvsv(*a) s ->4

# If either of the marked numbers there aren't 1, it means you need to
# update the corresponding magic number in the next two lines.
# Remember, these need to stay the last things in the module.

# Why these are different for MacOS?  Does it matter?
my $cop_seq_mnum = $^O eq 'MacOS' ? 12 : 11;
my $seq_mnum = $^O eq 'MacOS' ? 100 : 84;
$cop_seq_base = svref_2object(eval 'sub{0;}')->START->cop_seq + $cop_seq_mnum;
$seq_base = svref_2object(eval 'sub{}')->START->seq + $seq_mnum;
a490 2
    use B::Concise qw(set_style add_callback);

a501 38
=head1 EXAMPLE

Here's is a short example of output, using the default formatting
conventions :

    % perl -MO=Concise -e '$a = $b + 42'
    8  <@@> leave[t1] vKP/REFC ->(end)
    1     <0> enter ->2
    2     <;> nextstate(main 1 -e:1) v ->3
    7     <2> sassign vKS/2 ->8
    5        <2> add[t1] sK/2 ->6
    -           <1> ex-rv2sv sK/1 ->4
    3              <$> gvsv(*b) s ->4
    4           <$> const(IV 42) s ->5
    -        <1> ex-rv2sv sKRM*/1 ->7
    6           <$> gvsv(*a) s ->7

Each line corresponds to an operator. Null ops appear as C<ex-opname>,
where I<opname> is the op that has been optimized away by perl.

The number on the first row indicates the op's sequence number. It's
given in base 36 by default.

The symbol between angle brackets indicates the op's type : for example,
<2> is a BINOP, <@@> a LISTOP, etc. (see L</"OP class abbreviations">).

The opname may be followed by op-specific information in parentheses
(e.g. C<gvsv(*b)>), and by targ information in brackets (e.g.
C<leave[t1]>).

Next come the op flags. The common flags are listed below
(L</"OP flags abbreviations">). The private flags follow, separated
by a slash. For example, C<vKP/REFC> means that the leave op has
public flags OPf_WANT_VOID, OPf_KIDS, and OPf_PARENS, and the private
flag OPpREFCOUNTED.

Finally an arrow points to the sequence number of the next op.

d673 1
a673 1
=item B<#classsym>
d701 1
a701 1
=item B<#hyphseq>
a817 38
    #      PADOP            An OP with a GV on the pad

=head1 Using B::Concise outside of the O framework

It is possible to extend B<B::Concise> by using it outside of the B<O>
framework and providing new styles and new variables.

    use B::Concise qw(set_style add_callback);
    set_style($format, $gotofmt, $treefmt);
    add_callback
    (
        sub
        {
            my ($h, $op, $level, $format) = @@_;
            $h->{variable} = some_func($op);
        }
    );
    B::Concise::compile(@@options)->();

You can specify a style by calling the B<set_style> subroutine.  If you
have a new variable in your style, or you want to change the value of an
existing variable, you will need to add a callback to specify the value
for that variable.

This is done by calling B<add_callback> passing references to any
callback subroutines.  The subroutines are called in the same order as
they are added.  Each subroutine is passed four parameters.  These are a
reference to a hash, the keys of which are the names of the variables
and the values of which are their values, the op, the level and the
format.

To define your own variables, simply add them to the hash, or change
existing values if you need to.  The level and format are passed in as
references to scalars, but it is unlikely that they will need to be
changed or even used.

To see the output, call the subroutine returned by B<compile> in the
same way that B<O> does.
@


1.1.1.3
log
@perl 5.8.2 from CPAN
@
text
@d2 1
a2 1
# Copyright (C) 2000-2003 Stephen McCamant. All rights reserved.
d6 2
a7 5
# Note: we need to keep track of how many use declarations/BEGIN
# blocks this module uses, so we can avoid printing them when user
# asks for the BEGIN blocks in her program. Update the comments and
# the count in concise_specials if you add or delete one. The
# -MO=Concise counts as use #1.
d9 1
a9 2
use strict; # use #2
use warnings; # uses #3 and #4, since warnings uses Carp
d11 1
a11 3
use Exporter (); # use #5

our $VERSION   = "0.56";
d13 1
a13 2
our @@EXPORT_OK = qw(set_style set_style_standard add_callback
		    concise_subref concise_cv concise_main);
a14 1
# use #6
d16 1
a16 1
	 SVf_IOK SVf_NOK SVf_POK SVf_IVisUV SVf_FAKE OPf_KIDS CVf_ANON);
d47 1
a47 1
my $cop_seq_base;
a53 5
sub set_style_standard {
    my($name) = @@_;
    set_style(@@{$style{$name}});
}

d58 3
a60 11
sub concise_subref {
    my($order, $subref) = @@_;
    concise_cv_obj($order, svref_2object($subref));
}

# This should have been called concise_subref, but it was exported
# under this name in versions before 0.56
sub concise_cv { concise_subref(@@_); }

sub concise_cv_obj {
    my ($order, $cv) = @@_;
a61 1
    sequence($cv->START);
a70 32
sub concise_main {
    my($order) = @@_;
    sequence(main_start);
    $curcv = main_cv;
    if ($order eq "exec") {
	return if class(main_start) eq "NULL";
	walk_exec(main_start);
    } elsif ($order eq "tree") {
	return if class(main_root) eq "NULL";
	print tree(main_root, 0);
    } elsif ($order eq "basic") {
	return if class(main_root) eq "NULL";
	walk_topdown(main_root,
		     sub { $_[0]->concise($_[1]) }, 0);
    }
}

sub concise_specials {
    my($name, $order, @@cv_s) = @@_;
    my $i = 1;
    if ($name eq "BEGIN") {
	splice(@@cv_s, 0, 7); # skip 7 BEGIN blocks in this file
    } elsif ($name eq "CHECK") {
	pop @@cv_s; # skip the CHECK block that calls us
    }
    for my $cv (@@cv_s) {	
	print "$name $i:\n";
	$i++;
	concise_cv_obj($order, $cv);
    }
}

d87 1
a87 1
set_style_standard("concise");
d122 2
a123 2
    return sub {
	if (@@args) {
d125 3
a127 22
		if ($objname eq "BEGIN") {
		    concise_specials("BEGIN", $order,
				     B::begin_av->isa("B::AV") ?
				     B::begin_av->ARRAY : ());
		} elsif ($objname eq "INIT") {
		    concise_specials("INIT", $order,
				     B::init_av->isa("B::AV") ?
				     B::init_av->ARRAY : ());
		} elsif ($objname eq "CHECK") {
		    concise_specials("CHECK", $order,
				     B::check_av->isa("B::AV") ?
				     B::check_av->ARRAY : ());
		} elsif ($objname eq "END") {
		    concise_specials("END", $order,
				     B::end_av->isa("B::AV") ?
				     B::end_av->ARRAY : ());
		} else {
		    $objname = "main::" . $objname unless $objname =~ /::/;
		    print "$objname:\n";
		    eval "concise_subref(\$order, \\&$objname)";
		    die "concise_subref($order, \\&$objname) failed: $@@" if $@@;
		}
d130 15
a144 3
	if (!@@args or $do_main) {
	    print "main program:\n" if $do_main;
	    concise_main($order);
d156 1
a156 1
no warnings 'qw'; # "Possible attempt to put comments..."; use #7
d172 1
a172 1
     Pu GP SP EP Gn Gg GG SG EG g0 c$ lk t$ ;s n> // /= CO';
d200 1
a200 8
my %sequence_num;
my $seq_max = 1;

sub seq {
    my($op) = @@_;
    return "-" if not exists $sequence_num{$$op};
    return base_n($sequence_num{$$op});
}
d210 3
a212 7
    if (class($op) eq "PMOP") {
	my $maybe_root = $op->pmreplroot;
	if (ref($maybe_root) and $maybe_root->isa("B::OP")) {
	    # It really is the root of the replacement, not something
	    # else stored here for lack of space elsewhere
	    walk_topdown($maybe_root, $sub, $level + 1);
	}
d237 2
a238 1
	    if (class($op) eq "LOGOP") {
a255 36
# The structure of this routine is purposely modeled after op.c's peep()
sub sequence {
    my($op) = @@_;
    my $oldop = 0;
    return if class($op) eq "NULL" or exists $sequence_num{$$op};
    for (; $$op; $op = $op->next) {
	last if exists $sequence_num{$$op};
	my $name = $op->name;
	if ($name =~ /^(null|scalar|lineseq|scope)$/) {
	    next if $oldop and $ {$op->next};
	} else {
	    $sequence_num{$$op} = $seq_max++;
	    if (class($op) eq "LOGOP") {
		my $other = $op->other;
		$other = $other->next while $other->name eq "null";
		sequence($other);
	    } elsif (class($op) eq "LOOP") {
		my $redoop = $op->redoop;
		$redoop = $redoop->next while $redoop->name eq "null";
		sequence($redoop);
		my $nextop = $op->nextop;
		$nextop = $nextop->next while $nextop->name eq "null";
		sequence($nextop);
		my $lastop = $op->lastop;
		$lastop = $lastop->next while $lastop->name eq "null";
		sequence($lastop);
	    } elsif ($name eq "subst" and $ {$op->pmreplstart}) {
		my $replstart = $op->pmreplstart;
		$replstart = $replstart->next while $replstart->name eq "null";
		sequence($replstart);
	    }
	}
	$oldop = $op;
    }
}

d274 1
a274 1
       "padav", "padhv", "enteriter");
d291 1
a291 2
$priv{$_}{16} = "OURINTR" for ("gvsv", "rv2sv", "rv2av", "rv2hv", "r2gv",
	"enteriter");
d314 4
a317 2
@@{$priv{$_}}{16,32,64,128} = ("INBIN","INCR","OUTBIN","OUTCR")
  for ("open", "backtick");
a318 2
$priv{$_}{2} = "FTACCESS"
  for ("ftrread", "ftrwrite", "ftrexec", "fteread", "ftewrite", "fteexec");
a332 36
sub concise_sv {
    my($sv, $hr) = @@_;
    $hr->{svclass} = class($sv);
    $hr->{svclass} = "UV"
      if $hr->{svclass} eq "IV" and $sv->FLAGS & SVf_IVisUV;
    $hr->{svaddr} = sprintf("%#x", $$sv);
    if ($hr->{svclass} eq "GV") {
	my $gv = $sv;
	my $stash = $gv->STASH->NAME;
	if ($stash eq "main") {
	    $stash = "";
	} else {
	    $stash = $stash . "::";
	}
	$hr->{svval} = "*$stash" . $gv->SAFENAME;
	return "*$stash" . $gv->SAFENAME;
    } else {
	while (class($sv) eq "RV") {
	    $hr->{svval} .= "\\";
	    $sv = $sv->RV;
	}
	if (class($sv) eq "SPECIAL") {
	    $hr->{svval} .= ["Null", "sv_undef", "sv_yes", "sv_no"]->[$$sv];
	} elsif ($sv->FLAGS & SVf_NOK) {
	    $hr->{svval} .= $sv->NV;
	} elsif ($sv->FLAGS & SVf_IOK) {
	    $hr->{svval} .= $sv->int_value;
	} elsif ($sv->FLAGS & SVf_POK) {
	    $hr->{svval} .= cstring($sv->PV);
	} elsif (class($sv) eq "HV") {
	    $hr->{svval} .= 'HASH';
	}
	return $hr->{svclass} . " " .  $hr->{svval};
    }
}

a341 1
	# targ holds the old type
a343 6
    } elsif ($op->name =~ /^leave(sub(lv)?|write)?$/) {
	# targ potentially holds a reference count
	if ($op->private & 64) {
	    my $refs = "ref" . ($h{targ} != 1 ? "s" : "");
	    $h{targarglife} = $h{targarg} = "$h{targ} $refs";
	}
d348 4
a351 9
	    if ($padname->FLAGS & SVf_FAKE) {
		$h{targarglife} = "$h{targarg}:FAKE";
	    }
	    else {
		my $intro = $padname->NVX - $cop_seq_base;
		my $finish = int($padname->IVX) - $cop_seq_base;
		$finish = "end" if $finish == 999999999 - $cop_seq_base;
		$h{targarglife} = "$h{targarg}:$intro,$finish";
	    }
d361 7
a367 4
	    $precomp = cstring($precomp); # Escape literal control sequences
 	    $precomp = "/$precomp/";
	} else {
	    $precomp = "";
d369 1
d372 1
a372 1
	if (ref($pmreplroot) eq "B::GV") {
d374 1
a374 1
	    #  *stash_array is stored in /pat/'s pmreplroot.
a375 6
	} elsif (!ref($pmreplroot) and $pmreplroot) {
	    # same as the last case, except the value is actually a
	    # pad offset for where the GV is kept (this happens under
	    # ithreads)
	    my $gv = (($curcv->PADLIST->ARRAY)[1]->ARRAY)[$pmreplroot];
	    $h{arg} = "($precomp => \@@" . $gv->NAME . ")";
d404 13
a416 4
	if (! ${$op->sv}) {
	    my $sv = (($curcv->PADLIST->ARRAY)[1]->ARRAY)[$op->targ];
	    $h{arg} = "[" . concise_sv($sv, \%h) . "]";
	    $h{targarglife} = $h{targarg} = "";
d418 14
a431 1
	    $h{arg} = "(" . concise_sv($op->sv, \%h) . ")";
a432 3
    } elsif ($h{class} eq "PADOP") {
	my $sv = (($curcv->PADLIST->ARRAY)[1]->ARRAY)[$op->padix];
	$h{arg} = "[" . concise_sv($sv, \%h) . "]";
a467 24
# B::OP::terse (see Terse.pm) now just calls this
sub b_terse {
    my($op, $level) = @@_;

    # This isn't necessarily right, but there's no easy way to get
    # from an OP to the right CV. This is a limitation of the
    # ->terse() interface style, and there isn't much to do about
    # it. In particular, we can die in concise_op if the main pad
    # isn't long enough, or has the wrong kind of entries, compared to
    # the pad a sub was compiled with. The fix for that would be to
    # make a backwards compatible "terse" format that never even
    # looked at the pad, just like the old B::Terse. I don't think
    # that's worth the effort, though.
    $curcv = main_cv unless $curcv;

    if ($order eq "exec" and $lastnext and $$lastnext != $$op) {
	my $h = {"seq" => seq($lastnext), "class" => class($lastnext),
		 "addr" => sprintf("%#x", $$lastnext)};
	print fmt_line($h, $style{"terse"}[1], $level+1);
    }
    $lastnext = $op->next;
    print concise_op($op, $level, $style{"terse"}[0]);
}

a519 6
# (Note that we now only play this game with COP sequence numbers. OP
# sequence numbers aren't used to refer to OPs from a distance, and
# they don't have much significance, so we just generate our own
# sequence numbers which are easier to control. This way we also don't
# stand in the way of a possible future removal of OP sequence
# numbers).
d531 3
a533 3
# If the second of the marked numbers there isn't 1, it means you need
# to update the corresponding magic number in the next line.
# Remember, this needs to stay the last things in the module.
d535 1
a535 1
# Why is this different for MacOS?  Does it matter?
d537 1
d539 1
d572 1
a572 1
    8  <@@> leave[1 ref] vKP/REFC ->(end)
d607 3
a609 5
subroutines to print the OPs of; if no such functions are specified,
the main body of the program (outside any subroutines, and not
including use'd or require'd files) is printed. Passing C<BEGIN>,
C<CHECK>, C<INIT>, or C<END> will cause all of the corresponding
special blocks to be printed.
d689 1
a689 1
Use formatting conventions that emulate the output of B<B::Terse>. The
d834 1
a834 1
A one- or two-character abbreviation for the OP's name.
d846 1
a846 3
The sequence number of the OP. Note that this is now a sequence number
generated by B::Concise, rather than the real op_seq value (for which
see B<#seqnum>).
a955 3
To switch back to one of the standard styles like C<concise> or
C<terse>, use C<set_style_standard>.

d961 1
a961 1
Stephen McCamant, E<lt>smcc@@CSUA.Berkeley.EDUE<gt>.
@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@d17 1
a17 3
# Maint doesn't have patch 22353 (op_seq changes)

our $VERSION   = "0.61";
d20 1
a20 2
		    concise_subref concise_cv concise_main
		    add_style walk_output);
d24 1
a24 2
	 SVf_IOK SVf_NOK SVf_POK SVf_IVisUV SVf_FAKE OPf_KIDS OPf_SPECIAL
	 CVf_ANON);
d26 1
a26 1
my %style =
d53 1
a53 21
# Renderings, ie how Concise prints, is controlled by these vars
# primary:
our $stylename;		# selects current style from %style
my $order = "basic";	# how optree is walked & printed: basic, exec, tree

# rendering mechanics:
# these 'formats' are the line-rendering templates
# they're updated from %style when $stylename changes
my ($format, $gotofmt, $treefmt);

# lesser players:
my $base = 36;		# how <sequence#> is displayed
my $big_endian = 1;	# more <sequence#> display
my $tree_style = 0;	# tree-order details
my $banner = 1;		# print banner before optree is traversed

# another factor:
our @@callbacks;		# allow external management

set_style_standard("concise");

d56 1
a59 11
    #warn "set_style: deprecated, use set_style_standard instead\n"; # someday
    die "expecting 3 style-format args\n" unless @@_ == 3;
}

sub add_style {
    my ($newstyle,@@args) = @@_;
    die "style '$newstyle' already exists, choose a new name\n"
	if exists $style{$newstyle};
    die "expecting 3 style-format args\n" unless @@args == 3;
    $style{$newstyle} = [@@args];
    $stylename = $newstyle; # update rendering state
d63 2
a64 3
    ($stylename) = @@_; # update rendering state
    die "err: style '$stylename' unknown\n" unless exists $style{$stylename};
    set_style(@@{$style{$stylename}});
a70 17
# output handle, used with all Concise-output printing
our $walkHandle = \*STDOUT;	# public for your convenience

sub walk_output { # updates $walkHandle
    my $handle = shift;
    if (ref $handle eq 'SCALAR') {
	# in 5.8+, open(FILEHANDLE,MODE,REFERENCE) writes to string
	open my $tmp, '>', $handle;	# but cant re-set an existing filehandle
	$walkHandle = $tmp;		# so use my $tmp as intermediate var
	return;
    }
    $walkHandle = $handle;
    my $iotype = ref $walkHandle;
    die "expecting argument/object that can print\n"
	unless $iotype eq 'GLOB' or $iotype and $walkHandle->can('print');
}

d72 2
a73 4
    my($order, $coderef) = @@_;
    my $codeobj = svref_2object($coderef);
    die "err: not a coderef: $coderef\n" unless ref $codeobj eq 'B::CV';#CODE';
    concise_cv_obj($order, $codeobj);
a82 1
    die "err: coderef has no START\n" if class($cv->START) eq "NULL";
d89 1
a89 1
	print $walkHandle tree($cv->ROOT, 0);
d102 1
a102 1
	print $walkHandle tree(main_root, 0);
d118 2
a119 2
    for my $cv (@@cv_s) {
	print $walkHandle "$name $i:\n";
d128 1
a128 1
my @@tree_decorations =
d134 8
d170 2
a171 6
	} elsif ($o eq "-banner") {
	    $banner = 0;
	}
	elsif (exists $style{substr($o, 1)}) {
	    $stylename = substr($o, 1);
	    set_style_standard($stylename);
d196 4
a199 15
		    # convert function names to subrefs
		    my $objref;
		    if (ref $objname) {
			print $walkHandle "B::Concise::compile($objname)\n"
			    if $banner;
			$objref = $objname;
		    } else {
			$objname = "main::" . $objname unless $objname =~ /::/;
			print $walkHandle "$objname:\n";
			no strict 'refs';
			die "err: unknown function ($objname)\n"
			    unless *{$objname}{CODE};
			$objref = \&$objname;
		    }
		    concise_subref($order, $objref);
d204 1
a204 1
	    print $walkHandle "main program:\n" if $do_main;
d211 1
a211 1
my $lastnext;	# remembers op-chain, used to insert gotos
a263 6
sub reset_sequence {
    # reset the sequence
    %sequence_num = ();
    $seq_max = 1;
}

d363 3
a365 4
sub fmt_line {    # generate text-line for op.
    my($hr, $text, $level) = @@_;
    return '' if $hr->{SKIP};	# suppress line if a callback said so

d367 1
a367 2
	$hr->{$2} ? $1.$hr->{$2}.$3 : ""/eg;

d371 2
a372 3
    $text =~ s/\#([a-zA-Z]+)(\d+)/sprintf("%-$2s", $hr->{$1})/eg;

    $text =~ s/\#([a-zA-Z]+)/$hr->{$1}/eg;  # populate data into template
d374 1
a374 3
    chomp $text;
    return "$text\n" if $text ne "";
    return $text; # suppress empty lines
d384 1
a384 1
$priv{"aassign"}{32} = "PHASH" if $] < 5.009;
d392 1
a392 1
  for (qw(rv2gv rv2sv padsv aelem helem));
d420 1
a420 1
@@{$priv{"sort"}}{1,2,4,8} = ("NUM", "INT", "REV", "INPLACE");
a426 12
if ($] >= 5.009) {
  # Stacked filetests are post 5.8.x
  $priv{$_}{4} = "FTSTACKED"
    for ("ftrread", "ftrwrite", "ftrexec", "fteread", "ftewrite", "fteexec",
         "ftis", "fteowned", "ftrowned", "ftzero", "ftsize", "ftmtime",
	 "ftatime", "ftctime", "ftsock", "ftchr", "ftblk", "ftfile", "ftdir",
	 "ftpipe", "ftlink", "ftsuid", "ftsgid", "ftsvtx", "fttty", "fttext",
	 "ftbinary");
  # Lexical $_ is post 5.8.x
  $priv{$_}{2} = "GREPLEX"
    for ("mapwhile", "mapstart", "grepwhile", "grepstart");
}
d500 1
a500 11
		if ($] < 5.009) {
		    $h{targarglife} = "$h{targarg}:FAKE";
		} else {
		    # These changes relate to the jumbo closure fix.
		    # See changes 19939 and 20005
		    my $fake = '';
		    $fake .= 'a' if $padname->IVX & 1; # PAD_FAKELEX_ANON
		    $fake .= 'm' if $padname->IVX & 2; # PAD_FAKELEX_MULTI
		    $fake .= ':' . $padname->NVX if $curcv->CvFLAGS & CVf_ANON;
		    $h{targarglife} = "$h{targarg}:FAKE:$fake";
		}
d562 6
a567 8
	unless ($h{name} eq 'aelemfast' and $op->flags & OPf_SPECIAL) {
	    if (! ${$op->sv}) {
		my $sv = (($curcv->PADLIST->ARRAY)[1]->ARRAY)[$op->targ];
		$h{arg} = "[" . concise_sv($sv, \%h) . "]";
		$h{targarglife} = $h{targarg} = "";
	    } else {
		$h{arg} = "(" . concise_sv($op->sv, \%h) . ")";
	    }
d592 1
a592 2

    $_->(\%h, $op, \$format, \$level, $stylename) for @@callbacks;
a598 1
	# insert a 'goto' line
d601 1
a601 1
	print $walkHandle fmt_line($h, $gotofmt, $level+1);
d604 1
a604 1
    print $walkHandle concise_op($op, $level, $format);
a622 1
	# insert a 'goto'
d654 1
a654 1
		$lines[$i] = $kid . $lines[$i];
d689 1
a689 1
 
d735 2
a736 2
Here's is a short example of output (aka 'rendering'), using the
default formatting conventions :
d750 1
a750 1
Each line corresponds to an opcode. Null ops appear as C<ex-opname>,
a779 10
Options affect how things are rendered (ie printed).  They're presented
here by their visual effect, 1st being strongest.  They're grouped
according to how they interrelate; within each group the options are
mutually exclusive (unless otherwise stated).

=head2 Options for Opcode Ordering

These options control the 'vertical display' of opcodes.  The display
'order' is also called 'mode' elsewhere in this document.

a805 44
=back

=head2 Options for Line-Style

These options select the line-style (or just style) used to render
each opcode, and dictates what info is actually printed into each line.

=over 4

=item B<-concise>

Use the author's favorite set of formatting conventions. This is the
default, of course.

=item B<-terse>

Use formatting conventions that emulate the output of B<B::Terse>. The
basic mode is almost indistinguishable from the real B<B::Terse>, and the
exec mode looks very similar, but is in a more logical order and lacks
curly brackets. B<B::Terse> doesn't have a tree mode, so the tree mode
is only vaguely reminiscent of B<B::Terse>.

=item B<-linenoise>

Use formatting conventions in which the name of each OP, rather than being
written out in full, is represented by a one- or two-character abbreviation.
This is mainly a joke.

=item B<-debug>

Use formatting conventions reminiscent of B<B::Debug>; these aren't
very concise at all.

=item B<-env>

Use formatting conventions read from the environment variables
C<B_CONCISE_FORMAT>, C<B_CONCISE_GOTO_FORMAT>, and C<B_CONCISE_TREE_FORMAT>.

=back

=head2 Options for tree-specific formatting

=over 4

d830 1
a830 1
=back
d832 2
a833 5
These are pairwise exclusive, i.e. compact or loose, vt or ascii.

=head2 Options controlling sequence numbering

=over 4
d849 1
a849 2
Print seqence numbers with the least significant digit first.  This is
obviously mutually exclusive with bigendian.
d851 4
a854 1
=back
d856 1
a856 1
=head2 Other options
d858 5
a862 1
=over 4
d864 1
a864 1
=item B<-main>
d866 3
a868 2
Include the main program in the output, even if subroutines were also
specified.  This is the only option that is not sticky (see below)
d870 1
a870 1
=item B<-banner>
d872 2
a873 4
B::Concise::compile normally prints a banner line identifying the
function name, or in case of a subref, a generic message including
(unfortunately) the stringified coderef.  This option suppresses the
printing of the banner.
d875 1
a875 1
=back
d877 2
a878 1
=head2 Option Stickiness
d880 1
a880 4
If you invoke Concise more than once in a program, you should know that
the options are 'sticky'.  This means that the options you provide in
the first call will be remembered for the 2nd call, unless you
re-specify or change them.
d884 6
a889 13
For each line-style ('concise', 'terse', 'linenoise', etc.) there are
3 format-specs which control how OPs are rendered.

The first is the 'default' format, which is used in both basic and exec
modes to print all opcodes.  The 2nd, goto-format, is used in exec
mode when branches are encountered.  They're not real opcodes, and are
inserted to look like a closing curly brace.  The tree-format is tree
specific.

When a line is rendered, the correct format string is scanned for the
following items, and data is substituted in, or other manipulations,
like basic indenting.  Any text that doesn't match a special pattern
(the items below) is copied verbatim.  (Yes, it's a set of s///g steps.)
d1095 2
a1096 11
You can use B<B::Concise>, and call compile() directly, and
repeatedly.  By doing so, you can avoid the compile-time only
operation of 'perl -MO=Concise ..'.  For example, you can use the
debugger to step through B::Concise::compile() itself.

When doing so, you can alter Concise output by providing new output
styles, and optionally by adding callback routines which populate new
variables that may be rendered as part of those styles.  For all
following sections, please review L</FORMATTING SPECIFICATIONS>.

=head2 Example: Altering Concise Renderings
d1099 1
a1099 1
    set_style($your_format, $your_gotofmt, $your_treefmt);
d1101 4
a1104 2
      ( sub {
            my ($h, $op, $format, $level, $stylename) = @@_;
d1107 1
a1107 1
      );
d1110 11
a1120 38
=head2 set_style()

B<set_style> accepts 3 arguments, and updates the three format-specs
comprising a line-style (basic-exec, goto, tree).  It has one minor
drawback though; it doesn't register the style under a new name.  This
can become an issue if you render more than once and switch styles.
Thus you may prefer to use add_style() and/or set_style_standard()
instead.

=head2 set_style_standard($name)

This restores one of the standard line-styles: C<terse>, C<concise>,
C<linenoise>, C<debug>, C<env>, into effect.  It also accepts style
names previously defined with add_style().

=head2 add_style()

This subroutine accepts a new style name and three style arguments as
above, and creates, registers, and selects the newly named style.  It is
an error to re-add a style; call set_style_standard() to switch between
several styles.

=head2 add_callback()

If your newly minted styles refer to any #variables, you'll need to
define a callback subroutine that will populate (or modify) those
variables.  They are then available for use in the style you've chosen.

The callbacks are called for each opcode visited by Concise, in the
same order as they are added.  Each subroutine is passed five
parameters.

  1. A hashref, containing the variable names and values which are
     populated into the report-line for the op
  2. the op, as a B<B::OP> object
  3. a reference to the format string
  4. the formatting (indent) level
  5. the selected stylename
a1126 23
=head2 Running B::Concise::compile()

B<compile> accepts options as described above in L</OPTIONS>, and
arguments, which are either coderefs, or subroutine names.

compile() constructs and returns a coderef, which when invoked, scans
the optree, and prints the results to STDOUT.  Once you have the
coderef, you may change the output style; thereafter the coderef renders
in the new style.

B<walk_output> lets you change the print destination from STDOUT to
another open filehandle, or into a string passed as a ref.

    walk_output(\my $buf);
    my $walker = B::Concise::compile('-concise','funcName', \&aSubRef);
    print "Concise Banner for Functions: $buf\n";
    $walker->();
    print "Concise Rendering(s)?: $buf\n";

For each subroutine visited by Concise, the $buf will contain a
banner naming the function or coderef about to be traversed.
Once $walker is invoked, it prints the actual renderings for each.

d1128 1
a1128 18
C<terse>, call C<set_style_standard>, or pass the style name into
B::Concise::compile() (as done above).

=head2 B::Concise::reset_sequence()

This function (not exported) lets you reset the sequence numbers (note
that they're numbered arbitrarily, their goal being to be human
readable).  Its purpose is mostly to support testing, i.e. to compare
the concise output from two identical anonymous subroutines (but
different instances).  Without the reset, B::Concise, seeing that
they're separate optrees, generates different sequence numbers in
the output.

=head2 Errors

All detected errors, (invalid arguments, internal errors, etc.) are
resolved with a die($message). Use an eval if you wish to catch these
errors and continue processing.
d1130 2
a1131 2
In particular, B<compile> will die if you've asked for a non-existent
function-name, a non-existent coderef, or a non-CODE reference.
@


1.1.1.5
log
@perl 5.8.6 from CPAN
@
text
@d17 3
a19 1
our $VERSION   = "0.64";
d21 3
a23 8
our @@EXPORT_OK = qw( set_style set_style_standard add_callback
		     concise_subref concise_cv concise_main
		     add_style walk_output compile reset_sequence );
our %EXPORT_TAGS =
    ( io	=> [qw( walk_output compile reset_sequence )],
      style	=> [qw( add_style set_style_standard )],
      cb	=> [qw( add_callback )],
      mech	=> [qw( concise_subref concise_cv concise_main )],  );
d38 2
a39 2
    . "#exname#arg(?([#targarglife])?)~#flags(?(/#private)?)(x(;~->#next)x)\n"
    , "  (*(    )*)     goto #seq\n",
d47 2
a48 3
    . "op_ppaddr\tPL_ppaddr[OP_#NAME]\n\top_type\t\t#typenum\n" .
    ($] > 5.009 ? '' : "\top_seq\t\t#seqnum\n")
    . "\top_flags\t#flagval\n\top_private\t#privval\n"
a71 1
my $do_main = 0;	# force printing of main routine
d73 1
a73 1
# another factor: can affect all styles!
d107 1
a107 2
our $walkHandle;	# public for your convenience
BEGIN { $walkHandle = \*STDOUT }
a110 2
    return $walkHandle unless $handle; # allow use as accessor

a111 3
	require Config;
	die "no perlio in this build, can't call walk_output (\\\$scalar)\n"
	    unless $Config::Config{useperlio};
d113 1
a113 1
	open my $tmp, '>', $handle;	# but cant re-set existing STDOUT
d115 1
a115 1
	return $walkHandle;
d117 2
a118 1
    my $iotype = ref $handle;
d120 1
a120 2
	unless $iotype eq 'GLOB' or $iotype and $handle->can('print');
    $walkHandle = $handle;
d126 1
a126 3

    return concise_stashref(@@_)	
	unless ref $codeobj eq 'B::CV';
a129 14
sub concise_stashref {
    my($order, $h) = @@_;
    foreach my $k (sort keys %$h) {
	local *s = $h->{$k};
	my $coderef = *s{CODE} or next;
	reset_sequence();
	print "FUNC: ", *s, "\n";
	my $codeobj = svref_2object($coderef);
	next unless ref $codeobj eq 'B::CV';
	eval { concise_cv_obj($order, $codeobj) }
	or warn "err $@@ on $codeobj";
    }
}

d190 1
a190 3

sub compileOpts {
    # set rendering state from options and args
d193 1
a194 1
	# mode/order
d201 1
a201 3
	}
	# tree-specific
	elsif ($o eq "-compact") {
d209 3
a211 3
	}
	# sequence numbering
	elsif ($o =~ /^-base(\d+)$/) {
d217 1
a217 2
	}
	elsif ($o eq "-nobanner") {
a218 7
	} elsif ($o eq "-banner") {
	    $banner = 1;
	}
	elsif ($o eq "-main") {
	    $do_main = 1;
	} elsif ($o eq "-nomain") {
	    $do_main = 0;
a219 1
	# line-style options
a226 5
    return (@@args);
}

sub compile {
    my (@@args) = compileOpts(@@_);
d228 18
a245 30
	my @@newargs = compileOpts(@@_); # accept new rendering options
	warn "disregarding non-options: @@newargs\n" if @@newargs;

	for my $objname (@@args) {
	    next unless $objname; # skip null args to avoid noisy responses

	    if ($objname eq "BEGIN") {
		concise_specials("BEGIN", $order,
			       B::begin_av->isa("B::AV") ?
			       B::begin_av->ARRAY : ());
	    } elsif ($objname eq "INIT") {
		concise_specials("INIT", $order,
			       B::init_av->isa("B::AV") ?
			       B::init_av->ARRAY : ());
	    } elsif ($objname eq "CHECK") {
		concise_specials("CHECK", $order,
			       B::check_av->isa("B::AV") ?
			       B::check_av->ARRAY : ());
	    } elsif ($objname eq "END") {
		concise_specials("END", $order,
                                     B::end_av->isa("B::AV") ?
			       B::end_av->ARRAY : ());
	    }
	    else {
		# convert function names to subrefs
		my $objref;
		if (ref $objname) {
		    print $walkHandle "B::Concise::compile($objname)\n"
			if $banner;
		    $objref = $objname;
d247 15
a261 6
		    $objname = "main::" . $objname unless $objname =~ /::/;
		    print $walkHandle "$objname:\n";
		    no strict 'refs';
		    die "err: unknown function ($objname)\n"
			unless *{$objname}{CODE};
		    $objref = \&$objname;
a262 1
		concise_subref($order, $objref);
a268 1
	return @@args;	# something
a329 1
    $lastnext = 0;
d386 3
a388 9
		if ($] > 5.009) {
		    $labels{${$op->nextop}} = "NEXT";
		    $labels{${$op->lastop}} = "LAST";
		    $labels{${$op->redoop}} = "REDO";
		} else {
		    $labels{$op->nextop->seq} = "NEXT";
		    $labels{$op->lastop->seq} = "LAST";
		    $labels{$op->redoop->seq} = "REDO";		
		}
d432 1
a432 4
    my($hr, $op, $text, $level) = @@_;

    $_->($hr, $op, \$text, \$level, $stylename) for @@callbacks;

a433 1
    return '' if $hr->{goto} and $hr->{goto} eq '-';	# no goto nowhere
a434 1
    # spec: (?(text1#varText2)?)
a437 1
    # spec: (x(exec_text;basic_text)x)
a438 2

    # spec: (*(text)*)
a439 2

    # spec: (*(text1;text2)*)
a440 5

    # convert #Var to tag=>val form: Var\t#var
    $text =~ s/\#([A-Z][a-z]+)(\d+)?/\t\u$1\t\L#$1$2/gs;

    # spec: #varN
d443 2
a444 2
    $text =~ s/\#([a-zA-Z]+)/$hr->{$1}/eg;	# populate #var's
    $text =~ s/[ \t]*~+[ \t]*/ /g;		# squeeze tildes
d466 2
a467 1
@@{$priv{"entersub"}}{16,32,64} = ("DBG","TARG","NOMOD");
d485 1
a485 2
$priv{$_}{4} = "REVERSED" for ("enteriter", "iter");
@@{$priv{"const"}}{4,8,16,32,64,128} = ("SHORT","STRICT","ENTERED",'$[',"BARE","WARN");
d493 1
a493 1
@@{$priv{"sort"}}{1,2,4,8,16} = ("NUM", "INT", "REV", "INPLACE","DESC");
d558 1
a558 4

	$hr->{svval} = 'undef' unless defined $hr->{svval};
	my $out = $hr->{svclass};
	return $out .= " $hr->{svval}" ; 
d672 1
a672 8
    if ($] > 5.009) {
	$h{opt} = $op->opt;
	$h{static} = $op->static;
	$h{label} = $labels{$$op};
    } else {
	$h{seqnum} = $op->seq;
	$h{label} = $labels{$op->seq};
    }
d686 1
d690 2
a691 1
    return fmt_line(\%h, $op, $format, $level);
d698 3
a700 5
	my $synth = {"seq" => seq($lastnext), "class" => class($lastnext),
		     "addr" => sprintf("%#x", $$lastnext),
		     "goto" => seq($lastnext), # simplify goto '-' removal
	     };
	print $walkHandle fmt_line($synth, $op, $gotofmt, $level+1);
d725 1
a725 2
	print # $walkHandle
	    fmt_line($h, $op, $style{"terse"}[1], $level+1);
d728 1
a728 2
    print # $walkHandle 
	concise_op($op, $level, $style{"terse"}[0]);
d767 11
a777 10
# they're compiling, their presence tends to distort the view we have of
# the code we're looking at. In particular, perl gives sequence numbers
# to COPs. If the program we're looking at were run on its own, this
# would start at 1. Because all of B::Concise and all the modules it
# uses are compiled first, though, by the time we get to the user's
# program the sequence number is already pretty high, which could be
# distracting if you're trying to tell OPs apart. Therefore we'd like to
# subtract an offset from all the sequence numbers we display, to
# restore the simpler view of the world. The trick is to know what that
# offset will be, when we're still compiling B::Concise!  If we
d779 11
a789 9
# other modules we use do. To help a little, what we do here is compile
# a little code at the end of the module, and compute the base sequence
# number for the user's program as being a small offset later, so all we
# have to worry about are changes in the offset.

# [For 5.8.x and earlier perl is generating sequence numbers for all ops,
#  and using them to reference labels]


a1012 2
These are pairwise exclusive.

d1018 1
a1018 18
specified.  This rendering is normally suppressed when a subroutine
name or reference is given.

=item B<-nomain>

This restores the default behavior after you've changed it with '-main'
(it's not normally needed).  If no subroutine name/ref is given, main is
rendered, regardless of this flag.

=item B<-nobanner>

Renderings usually include a banner line identifying the function name
or stringified subref.  This suppresses the printing of the banner.

TBC: Remove the stringified coderef; while it provides a 'cookie' for
each function rendered, the cookies used should be 1,2,3.. not a
random hex-address.  It also complicates string comparison of two
different trees.
d1022 4
a1025 8
restores default banner behavior.

=item B<-banneris> => subref

TBC: a hookpoint (and an option to set it) for a user-supplied
function to produce a banner appropriate for users needs.  It's not
ideal, because the rendering-state variables, which are a natural
candidate for use in concise.t, are unavailable to the user.
a1035 40
=head1 ABBREVIATIONS

The concise style uses symbols to convey maximum info with minimal
clutter (like hex addresses).  With just a little practice, you can
start to see the flowers, not just the branches, in the trees.

=head2 OP class abbreviations

These symbols appear before the op-name, and indicate the
B:: namespace that represents the ops in your Perl code.

    0      OP (aka BASEOP)  An OP with no children
    1      UNOP             An OP with one child
    2      BINOP            An OP with two children
    |      LOGOP            A control branch OP
    @@      LISTOP           An OP that could have lots of children
    /      PMOP             An OP with a regular expression
    $      SVOP             An OP with an SV
    "      PVOP             An OP with a string
    {      LOOP             An OP that holds pointers for a loop
    ;      COP              An OP that marks the start of a statement
    #      PADOP            An OP with a GV on the pad

=head2 OP flags abbreviations

These symbols represent various flags which alter behavior of the
opcode, sometimes in opcode-specific ways.

    v      OPf_WANT_VOID    Want nothing (void context)
    s      OPf_WANT_SCALAR  Want single value (scalar context)
    l      OPf_WANT_LIST    Want list of any length (list context)
    K      OPf_KIDS         There is a firstborn child.
    P      OPf_PARENS       This operator was parenthesized.
                             (Or block needs explicit scope entry.)
    R      OPf_REF          Certified reference.
                             (Return container, not containee).
    M      OPf_MOD          Will modify (lvalue).
    S      OPf_STACKED      Some arg is arriving on the stack.
    *      OPf_SPECIAL      Do something weird for this op (see op.h)

d1047 4
a1050 12
When a line is rendered, the correct format-spec is copied and scanned
for the following items; data is substituted in, and other
manipulations like basic indenting are done, for each opcode rendered.

There are 3 kinds of items that may be populated; special patterns,
#vars, and literal text, which is copied verbatim.  (Yes, it's a set
of s///g steps.)

=head2 Special Patterns

These items are the primitives used to perform indenting, and to
select text from amongst alternatives.
d1073 1
a1073 1
=item B<~>
d1075 1
a1075 2
Any number of tildes and surrounding whitespace will be collapsed to
a single space.
d1077 1
a1077 1
=back
d1079 1
a1079 1
=head2 # Variables
d1081 1
a1081 3
These #vars represent opcode properties that you may want as part of
your rendering.  The '#' is intended as a private sigil; a #var's
value is interpolated into the style-line, much like "read $this".
d1083 2
a1084 23
These vars take 3 forms:

=over 4

=item B<#>I<var>

A property named 'var' is assumed to exist for the opcodes, and is
interpolated into the rendering.

=item B<#>I<var>I<N>

Generates the value of I<var>, left justified to fill I<N> spaces.
Note that this means while you can have properties 'foo' and 'foo2',
you cannot render 'foo2', but you could with 'foo2a'.  You would be
wise not to rely on this behavior going forward ;-)

=item B<#>I<Var>

This ucfirst form of #var generates a tag-value form of itself for
display; it converts '#Var' into a 'Var => #var' style, which is then
handled as described above.  (Imp-note: #Vars cannot be used for
conditional-fills, because the => #var transform is done after the check
for #Var's value).
d1088 1
a1088 8
The following variables are 'defined' by B::Concise; when they are
used in a style, their respective values are plugged into the
rendering of each opcode.

Only some of these are used by the standard styles, the others are
provided for you to delve into optree mechanics, should you wish to
add a new style (see L</add_style> below) that uses them.  You can
also add new ones using L<add_callback>.
d1094 1
a1094 1
The address of the OP, in hexadecimal.
d1099 1
a1099 1
non-local exit pointers for a LOOP, etc.) enclosed in parentheses.
d1176 3
a1178 2
The sequence number of the OP. Note that this is a sequence number
generated by B::Concise.
a1181 2
5.8.x and earlier only. 5.9 and later do not provide this.

a1186 13
=item B<#opt>

Whether or not the op has been optimised by the peephole optimiser.

Only available in 5.9 and later.

=item B<#static>

Whether or not the op is statically defined.  This flag is used by the
B::C compiler backend and indicates that the op should not be freed.

Only available in 5.9 and later.

d1224 30
d1256 1
a1256 3
The common (and original) usage of B::Concise was for command-line
renderings of simple code, as given in EXAMPLE.  But you can also use
B<B::Concise> from your code, and call compile() directly, and
d1258 2
a1259 2
operation of O.pm, and even use the debugger to step through
B::Concise::compile() itself.
d1261 4
a1264 4
Once you're doing this, you may alter Concise output by adding new
rendering styles, and by optionally adding callback routines which
populate new variables, if such were referenced from those (just
added) styles.  
d1269 1
a1269 1
    add_style($yourStyleName => $defaultfmt, $gotofmt, $treefmt);
d1274 3
a1276 3
        });
    $walker = B::Concise::compile(@@options,@@subnames,@@subrefs);
    $walker->();
d1327 4
a1330 4
It constructs and returns a $treewalker coderef, which when invoked,
traverses, or walks, and renders the optrees of the given arguments to
STDOUT.  You can reuse this, and can change the rendering style used
each time; thereafter the coderef renders in the new style.
d1333 1
a1333 2
another open filehandle, or (unless you've built with -Uuseperlio)
into a string passed as a ref.
a1334 1
    my $walker = B::Concise::compile('-terse','aFuncName', \&aSubRef);  # 1
d1336 12
a1347 20
    $walker->();			# 1 renders -terse
    set_style_standard('concise');	# 2
    $walker->();			# 2 renders -concise
    $walker->(@@new);			# 3 renders whatever
    print "3 different renderings: terse, concise, and @@new: $buf\n";

When $walker is called, it traverses the subroutines supplied when it
was created, and renders them using the current style.  You can change
the style afterwards in several different ways:

  1. call C<compile>, altering style or mode/order
  2. call C<set_style_standard>
  3. call $walker, passing @@new options

Passing new options to the $walker is the easiest way to change
amongst any pre-defined styles (the ones you add are automatically
recognized as options), and is the only way to alter rendering order
without calling compile again.  Note however that rendering state is
still shared amongst multiple $walker objects, so they must still be
used in a coordinated manner.
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d17 1
a17 1
our $VERSION   = "0.66";
d135 1
a135 1
    my($order, $coderef, $name) = @@_;
d138 1
a138 1
    return concise_stashref(@@_)
d140 1
a140 1
    concise_cv_obj($order, $codeobj, $name);
d159 1
a159 1
*concise_cv = \&concise_subref;
d162 1
a162 3
    my ($order, $cv, $name) = @@_;
    # name is either a string, or a CODE ref (copy of $cv arg??)

d164 1
a164 17
    if ($cv->XSUB) {
	print $walkHandle "$name is XS code\n";
	return;
    }
    if (class($cv->START) eq "NULL") {
	no strict 'refs';
	if (ref $name eq 'CODE') {
	    print $walkHandle "coderef $name has no START\n";
	}
	elsif (exists &$name) {
	    print $walkHandle "$name exists in stash, but has no START\n";
	}
	else {
	    print $walkHandle "$name not in symbol table\n";
	}
	return;
    }
d168 2
a169 9
    }
    elsif ($order eq "basic") {
	# walk_topdown($cv->ROOT, sub { $_[0]->concise($_[1]) }, 0);
	my $root = $cv->ROOT;
	unless (ref $root eq 'B::NULL') {
	    walk_topdown($root, sub { $_[0]->concise($_[1]) }, 0);
	} else {
	    print $walkHandle "B::NULL encountered doing ROOT on $cv. avoiding disaster\n";
	}
d196 1
a196 1
	splice(@@cv_s, 0, 8); # skip 7 BEGIN blocks in this file. NOW 8 ??
d203 1
a203 1
	concise_cv_obj($order, $cv, $name);
d220 2
a221 5
    my (@@options,@@args);
    if (@@_) {
	@@options = grep(/^-/, @@_);
	@@args = grep(!/^-/, @@_);
    }
d281 2
a282 2
				 B::begin_av->isa("B::AV") ?
				 B::begin_av->ARRAY : ());
d285 2
a286 2
				 B::init_av->isa("B::AV") ?
				 B::init_av->ARRAY : ());
d289 2
a290 2
				 B::check_av->isa("B::AV") ?
				 B::check_av->ARRAY : ());
d293 2
a294 2
				 B::end_av->isa("B::AV") ?
				 B::end_av->ARRAY : ());
d307 2
a308 4
		    unless (exists &$objname) {
			print $walkHandle "err: unknown function ($objname)\n";
			return;
		    }
d311 1
a311 1
		concise_subref($order, $objref, $objname);
d349 1
a349 1
sub op_flags { # common flags (see BASOP.op_flags in op.h)
d397 1
a397 1
    elsif (class($op) eq "PMOP") {
d522 1
a522 2
our %priv; # used to display each opcode's BASEOP.op_private values

d531 1
a531 1
$priv{$_}{64} = "RTIME" for ("match", "subst", "substcont", "qr");
d599 1
a599 1
    my($sv, $hr, $preferpv) = @@_;
a602 1
    Carp::cluck("bad concise_sv: $sv") unless $sv and $$sv;
a620 2
	} elsif ($preferpv && $sv->FLAGS & SVf_POK) {
	    $hr->{svval} .= cstring($sv->PV);
d731 1
a731 2
    }
    elsif ($h{class} eq "SVOP" or $h{class} eq "PADOP") {
d733 3
a735 5
	    my $idx = ($h{class} eq "SVOP") ? $op->targ : $op->padix;
	    my $preferpv = $h{name} eq "method_named";
	    if ($h{class} eq "PADOP" or !${$op->sv}) {
		my $sv = (($curcv->PADLIST->ARRAY)[1]->ARRAY)[$idx];
		$h{arg} = "[" . concise_sv($sv, \%h, $preferpv) . "]";
d738 1
a738 1
		$h{arg} = "(" . concise_sv($op->sv, \%h, $preferpv) . ")";
d741 3
d910 1
a910 1
information displayed is customizable. Its function is similar to that of
d916 2
a917 30
Here's an example of 2 outputs (aka 'renderings'), using the
-exec and -basic (i.e. default) formatting conventions on the same code
snippet.

    % perl -MO=Concise,-exec -e '$a = $b + 42'
    1  <0> enter
    2  <;> nextstate(main 1 -e:1) v
    3  <#> gvsv[*b] s
    4  <$> const[IV 42] s
 *  5  <2> add[t3] sK/2
    6  <#> gvsv[*a] s
    7  <2> sassign vKS/2
    8  <@@> leave[1 ref] vKP/REFC

Each line corresponds to an opcode. The opcode marked with '*' is used
in a few examples below.

The 1st column is the op's sequence number, starting at 1, and is
displayed in base 36 by default.  This rendering is in -exec (i.e.
execution) order.

The symbol between angle brackets indicates the op's type, for
example; <2> is a BINOP, <@@> a LISTOP, and <#> is a PADOP, which is
used in threaded perls. (see L</"OP class abbreviations">).

The opname, as in B<'add[t1]'>, which may be followed by op-specific
information in parentheses or brackets (ex B<'[t1]'>).

The op-flags (ex B<'sK/2'>) follow, and are described in (L</"OP flags
abbreviations">).
d924 1
a924 1
 *  5        <2> add[t1] sK/2 ->6
d931 5
a935 17
The default rendering is top-down, so they're not in execution order.
This form reflects the way the stack is used to parse and evaluate
expressions; the add operates on the two terms below it in the tree.

Nullops appear as C<ex-opname>, where I<opname> is an op that has been
optimized away by perl.  They're displayed with a sequence-number of
'-', because they are not executed (they don't appear in previous
example), they're printed here because they reflect the parse.

The arrow points to the sequence number of the next op; they're not
displayed in -exec mode, for obvious reasons.

Note that because this rendering was done on a non-threaded perl, the
PADOPs in the previous examples are now SVOPs, and some (but not all)
of the square brackets have been replaced by round ones.  This is a
subtle feature to provide some visual distinction between renderings
on threaded and un-threaded perls.
d937 14
d957 1
a957 1
including use'd or require'd files) is rendered.  Passing C<BEGIN>,
d977 2
a978 3
level in the tree, and the '->' at the end of the line indicates the
next opcode in execution order.  This mode is the default, so the flag
is included simply for completeness.
d1165 2
a1166 3
OP flags are either public or private.  The public flags alter the
behavior of each opcode in consistent ways, and are represented by 0
or more single characters.
a1170 1
                            Want is unknown
a1179 12
Private flags, if any are set for an opcode, are displayed after a '/'

    8  <@@> leave[1 ref] vKP/REFC ->(end)
    7     <2> sassign vKS/2 ->8

They're opcode specific, and occur less often than the public ones, so
they're represented by short mnemonics instead of single-chars; see
F<op.h> for gory details, or try this quick 2-liner:

  $> perl -MB::Concise -de 1
  DB<1> |x \%B::Concise::priv

d1271 1
a1271 1
also add new ones using L</add_callback>.
d1306 1
a1306 1
The address of the OP's first child, in hexadecimal.
d1327 1
a1327 1
The address of the OP's last child, in hexadecimal.
d1343 1
a1343 1
The address of the OP's next OP, in hexadecimal.
d1386 1
a1386 1
The address of the OP's next youngest sibling, in hexadecimal.
d1390 1
a1390 1
The address of the OP's SV, if it has an SV, in hexadecimal.
d1471 3
a1473 4
If your newly minted styles refer to any new #variables, you'll need
to define a callback subroutine that will populate (or modify) those
variables.  They are then available for use in the style you've
chosen.
d1502 2
a1503 2
another open filehandle, or into a string passed as a ref (unless
you've built perl with -Uuseperlio).
d1540 6
a1545 7
Errors in rendering (non-existent function-name, non-existent coderef)
are written to the STDOUT, or wherever you've set it via
walk_output().

Errors using the various *style* calls, and bad args to walk_output(),
result in die().  Use an eval if you wish to catch these errors and
continue processing.
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d17 1
a17 1
our $VERSION   = "0.74";
d31 1
a31 1
	 CVf_ANON PAD_FAKELEX_ANON PAD_FAKELEX_MULTI);
d40 2
a41 2
   ["#hyphseq2 (*(   (x( ;)x))*)<#classsym> #exname#arg(?([#targarglife])?)"
    . "~#flags(?(/#private)?)(?(:#hints)?)(x(;~->#next)x)\n"
d52 1
a52 1
    . "\top_flags\t#flagval\n\top_private\t#privval\t#hintsval\n"
a76 1
my $show_src;		# show source code
a144 1
    local *s;
d146 1
a146 2
	next unless defined $h->{$k};
	*s = $h->{$k};
d152 2
a153 2
	eval { concise_cv_obj($order, $codeobj, $k) };
	warn "err $@@ on $codeobj" if $@@;
a165 5

    if (ref($cv->XSUBANY) =~ /B::(\w+)/) {
	print $walkHandle "$name is a constant sub, optimized to a $1\n";
	return;
    }
a241 1
my @@render_packs; # collect -stash=<packages>
a276 1
	# miscellaneous, presentation
a285 8
	} elsif ($o eq "-src") {
	    $show_src = 1;
	}
	elsif ($o =~ /^-stash=(.*)/) {
	    my $pkg = $1;
	    no strict 'refs';
	    eval "require $pkg" unless defined %{$pkg.'::'};
	    push @@render_packs, $pkg;
a318 4
	    } elsif ($objname eq "UNITCHECK") {
		concise_specials("UNITCHECK", $order,
				 B::unitcheck_av->isa("B::AV") ?
				 B::unitcheck_av->ARRAY : ());
d344 1
a344 6
	for my $pkg (@@render_packs) {
	    no strict 'refs';
	    concise_stashref($order, \%{$pkg.'::'});
	}

	if (!@@args or $do_main or @@render_packs) {
a546 3

    $text = "# $hr->{src}\n$text" if $show_src and $hr->{src};

d560 1
a560 2
$priv{"aassign"}{32} = $] < 5.009 ? "PHASH" : "STATE";
$priv{"sassign"}{32} = "STATE";
a568 1
$priv{$_}{16} = "STATE" for ("padav", "padhv", "padsv");
d593 4
a596 1
@@{$priv{"sort"}}{1,2,4,8,16,32,64} = ("NUM", "INT", "REV", "INPLACE","DESC","QSORT","STABLE");
a602 1
$priv{"entereval"}{2} = "HAS_HH";
d616 2
a617 17
our %hints; # used to display each COP's op_hints values

# strict refs, subs, vars
@@hints{2,512,1024} = ('$', '&', '*');
# integers, locale, bytes, arybase
@@hints{1,4,8,16,32} = ('i', 'l', 'b', '[');
# block scope, localise %^H, $^OPEN (in), $^OPEN (out)
@@hints{256,131072,262144,524288} = ('{','%','<','>');
# overload new integer, float, binary, string, re
@@hints{4096,8192,16384,32768,65536} = ('I', 'F', 'B', 'S', 'R');
# taint and eval
@@hints{1048576,2097152} = ('T', 'E');
# filetest access, UTF-8
@@hints{4194304,8388608} = ('X', 'U');

sub _flags {
    my($hash, $x) = @@_;
d619 2
a620 2
    for my $flag (sort {$b <=> $a} keys %$hash) {
	if ($hash->{$flag} and $x & $flag and $x >= $flag) {
d622 1
a622 1
	    push @@s, $hash->{$flag};
a628 10
sub private_flags {
    my($name, $x) = @@_;
    _flags($priv{$name}, $x);
}

sub hints_flags {
    my($x) = @@_;
    _flags(\%hints, $x);
}

d636 1
a636 1
    if ($hr->{svclass} eq "GV" && $sv->isGV_with_GP()) {
d638 2
a639 1
	my $stash = $gv->STASH->NAME; if ($stash eq "main") {
a670 17
my %srclines;

sub fill_srclines {
    my $fullnm = shift;
    if ($fullnm eq '-e') {
	$srclines{$fullnm} = [ $fullnm, "-src not supported for -e" ];
	return;
    }
    open (my $fh, '<', $fullnm)
	or warn "# $fullnm: $!, (chdirs not supported by this feature yet)\n"
	and return;
    my @@l = <$fh>;
    chomp @@l;
    unshift @@l, $fullnm; # like @@{_<$fullnm} in debug, array starts at 1
    $srclines{$fullnm} = \@@l;
}

d700 3
a702 6
		    $fake .= 'a'
		   	if $padname->PARENT_FAKELEX_FLAGS & PAD_FAKELEX_ANON;
		    $fake .= 'm'
		   	if $padname->PARENT_FAKELEX_FLAGS & PAD_FAKELEX_MULTI;
		    $fake .= ':' . $padname->PARENT_PAD_INDEX
			if $curcv->CvFLAGS & CVf_ANON;
d707 2
a708 2
		my $intro = $padname->COP_SEQ_RANGE_LOW - $cop_seq_base;
		my $finish = int($padname->COP_SEQ_RANGE_HIGH) - $cop_seq_base;
a752 1
	my $pathnm = $loc;
d754 1
a754 2
	my $ln = $op->line;
	$loc .= ":$ln";
a758 8
	if ($show_src) {
	    fill_srclines($pathnm) unless exists $srclines{$pathnm};
	    # Would love to retain Jim's use of // but this code needs to be
	    # portable to 5.8.x
	    my $line = $srclines{$pathnm}[$ln];
	    $line = "-src unavailable under -e" unless defined $line;
	    $h{src} = "$ln: $line";
	}
d783 1
a800 6
    if ($op->can("hints")) {
      $h{hintsval} = $op->hints;
      $h{hints} = hints_flags($h{hintsval});
    } else {
      $h{hintsval} = $h{hints} = '';
    }
d950 3
a952 2
Here's two outputs (or 'renderings'), using the -exec and -basic
(i.e. default) formatting conventions on the same code snippet.
d964 2
a965 2
In this -exec rendering, each opcode is executed in the order shown.
The add opcode, marked with '*', is discussed in more detail.
d968 2
a969 3
displayed in base 36 by default.  Here they're purely linear; the
sequences are very helpful when looking at code with loops and
branches.
d975 1
a975 1
The opname, as in B<'add[t1]'>, may be followed by op-specific
d978 1
a978 1
The op-flags (ex B<'sK/2'>) are described in (L</"OP flags
d1015 3
a1017 3
subroutines to render; if no such functions are specified, the main
body of the program (outside any subroutines, and not including use'd
or require'd files) is rendered.  Passing C<BEGIN>, C<UNITCHECK>,
d1019 1
a1019 1
special blocks to be printed.  Arguments must follow options.
d1155 1
a1155 36
=over 4

=item B<-src>

With this option, the rendering of each statement (starting with the
nextstate OP) will be preceded by the 1st line of source code that
generates it.  For example:

    1  <0> enter
    # 1: my $i;
    2  <;> nextstate(main 1 junk.pl:1) v:{
    3  <0> padsv[$i:1,10] vM/LVINTRO
    # 3: for $i (0..9) {
    4  <;> nextstate(main 3 junk.pl:3) v:{
    5  <0> pushmark s
    6  <$> const[IV 0] s
    7  <$> const[IV 9] s
    8  <{> enteriter(next->j last->m redo->9)[$i:1,10] lKS
    k  <0> iter s
    l  <|> and(other->9) vK/1
    # 4:     print "line ";
    9      <;> nextstate(main 2 junk.pl:4) v
    a      <0> pushmark s
    b      <$> const[PV "line "] s
    c      <@@> print vK
    # 5:     print "$i\n";
    ...

=item B<-stash="somepackage">

With this, "somepackage" will be required, then the stash is
inspected, and each function is rendered.

=back

The following options are pairwise exclusive.
a1390 31
=item B<#hints>

The COP's hint flags, rendered with abbreviated names if possible. An empty
string if this is not a COP. Here are the symbols used:

    $ strict refs
    & strict subs
    * strict vars
    i integers
    l locale
    b bytes
    [ arybase
    { block scope
    % localise %^H
    < open in
    > open out
    I overload int
    F overload float
    B overload binary
    S overload string
    R overload re
    T taint
    E eval
    X filetest access
    U utf-8

=item B<#hintsval>

The numeric value of the COP's hint flags, or an empty string if this is not
a COP.

d1452 7
a1492 41

=back

=head1 One-Liner Command tips

=over 4

=item perl -MO=Concise,bar foo.pl

Renders only bar() from foo.pl.  To see main, drop the ',bar'.  To see
both, add ',-main'

=item perl -MDigest::MD5=md5 -MO=Concise,md5 -e1

Identifies md5 as an XS function.  The export is needed so that BC can
find it in main.

=item perl -MPOSIX -MO=Concise,_POSIX_ARG_MAX -e1

Identifies _POSIX_ARG_MAX as a constant sub, optimized to an IV.
Although POSIX isn't entirely consistent across platforms, this is
likely to be present in virtually all of them.

=item perl -MPOSIX -MO=Concise,a -e 'print _POSIX_SAVED_IDS'

This renders a print statement, which includes a call to the function.
It's identical to rendering a file with a use call and that single
statement, except for the filename which appears in the nextstate ops.

=item perl -MPOSIX -MO=Concise,a -e 'sub a{_POSIX_SAVED_IDS}'

This is B<very> similar to previous, only the first two ops differ.  This
subroutine rendering is more representative, insofar as a single main
program will have many subs.

=item perl -MB::Concise -e 'B::Concise::compile("-exec","-src", \%B::Concise::)->()'

This renders all functions in the B::Concise package with the source
lines.  It eschews the O framework so that the stashref can be passed
directly to B::Concise::compile().  See -stash option for a more
convenient way to render a package.
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d17 1
a17 1
our $VERSION   = "0.76";
d31 1
a31 1
	 CVf_ANON PAD_FAKELEX_ANON PAD_FAKELEX_MULTI SVf_ROK);
d302 1
a302 12
	    if (!defined %{$pkg.'::'}) {
		eval "require $pkg";
	    } else {
		require Config;
		if (!$Config::Config{usedl}
		    && keys %{$pkg.'::'} == 1
		    && $pkg->can('bootstrap')) {
		    # It is something that we're staticly linked to, but hasn't
		    # yet been used.
		    eval "require $pkg";
		}
	    }
d701 3
a703 10
	if ($] >= 5.011) {
	    while (class($sv) eq "IV" && $sv->FLAGS & SVf_ROK) {
		$hr->{svval} .= "\\";
		$sv = $sv->RV;
	    }
	} else {
	    while (class($sv) eq "RV") {
		$hr->{svval} .= "\\";
		$sv = $sv->RV;
	    }
@


1.1.1.9
log
@Perl 5.12.2 from CPAN
@
text
@d17 1
a17 1
our $VERSION   = "0.78";
d302 1
a302 1
	    if (! %{$pkg.'::'}) {
a636 1
$priv{"reverse"}{8} = "INPLACE";
d1744 1
a1744 1
=head2 add_style ()
d1751 1
a1751 1
=head2 add_callback ()
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d17 1
a17 1
our $VERSION   = "0.89";
d309 1
a309 1
		    # It is something that we're statically linked to, but hasn't
d465 1
a465 1
    if (class($op) eq "PMOP") {
d589 1
a589 1
    return "$text\n" if $text ne "" and $order ne "tree";
d598 1
a598 1
       "padav", "padhv", "enteriter", "entersub");
a603 1
$priv{"sassign"}{128}= "CV2GV";
a606 1
$priv{transr} = $priv{trans};
a608 1
$priv{$_}{4} = "DREFed" for (qw(rv2sv rv2av rv2hv));
d612 2
a613 3
@@{$priv{rv2gv}}{4,16} = qw "NOINIT FAKE";
@@{$priv{"entersub"}}{1,4,16,32,64} = qw( INARGS TARG DBG DEREF );
@@{$priv{rv2cv}}{1,8,128} = ("CONST","AMPER","NO()");
a617 3
$priv{$_}{8} = 'LVSUB' for qw(rv2av rv2gv rv2hv padav padhv aelem helem
                        aslice hslice av2arylen keys rkeys substr pos vec);
$priv{substr}{16} = 'REPL1ST';
d631 1
a631 2
@@{$priv{"const"}}{2,4,8,16,64,128} =
    ("NOVER","SHORT","STRICT","ENTERED","BARE","WARN");
d644 1
a644 1
@@{$priv{"entereval"}}{2,4,8,16} = qw "HAS_HH UNI BYTES COPHH";
d647 1
a647 1
  @@{$priv{$_}}{4,8,16} = ("FTSTACKED","FTSTACKING","FTAFTERt")
a656 2
$priv{$_}{128} = '+1' for qw "caller wantarray runcv";
@@{$priv{coreargs}}{1,2,64,128} = ('DREF1','DREF2','$MOD','MARK');
d661 3
a663 3
@@hints{2,512,1024,32,64,128} = ('$', '&', '*', 'x$', 'x&', 'x*');
# integers, locale, bytes
@@hints{1,4,8,16} = ('i', 'l', 'b');
d838 1
a838 1
    } elsif ($h{class} eq "PVOP" and $h{name} !~ '^transr?\z') {
d851 3
a853 1
	$h{arg} = "($label$stash $cseq $loc)";
d1256 1
a1256 1
Print sequence numbers with the least significant digit first.  This is
a1541 3
   x$ explicit use/no strict refs
   x& explicit use/no strict subs
   x* explicit use/no strict vars
d1545 1
@


1.1.1.11
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d17 1
a17 1
our $VERSION   = "0.95_01";
d50 2
a51 1
    . "op_ppaddr\tPL_ppaddr[OP_#NAME]\n\top_type\t\t#typenum\n"
d140 1
a140 1
	unless ref($codeobj) =~ '^B::(?:CV|FM)\z';
d359 1
d363 1
a363 2
		    concise_subref($order, ($objname)x2);
		    next;
d366 1
d368 1
a368 3
		    my $glob = \*$objname;
		    unless (*$glob{CODE} || *$glob{FORMAT}) {
			print $walkHandle "$objname:\n" if $banner;
d372 1
a372 9
		    if (my $objref = *$glob{CODE}) {
			print $walkHandle "$objname:\n" if $banner;
			concise_subref($order, $objref, $objname);
		    }
		    if (my $objref = *$glob{FORMAT}) {
			print $walkHandle "$objname (FORMAT):\n"
			    if $banner;
			concise_subref($order, $objref, $objname);
		    }
d374 1
d505 9
a513 3
		$labels{${$op->nextop}} = "NEXT";
		$labels{${$op->lastop}} = "LAST";
		$labels{${$op->redoop}} = "REDO";
d598 1
a598 1
       "padav", "padhv", "enteriter", "entersub", "padrange", "pushmark");
d601 1
a601 1
$priv{"aassign"}{32} = "STATE";
a623 1
@@{$priv{$_}}{32,64} = ('BOOL','BOOL?') for 'rv2hv', 'padhv';
d639 1
a639 1
    ("NOVER","SHORT","STRICT","ENTERED","BARE","FOLD");
d653 12
a664 8
@@{$priv{$_}}{4,8,16} = ("FTSTACKED","FTSTACKING","FTAFTERt")
for ("ftrread", "ftrwrite", "ftrexec", "fteread", "ftewrite", "fteexec",
     "ftis", "fteowned", "ftrowned", "ftzero", "ftsize", "ftmtime",
     "ftatime", "ftctime", "ftsock", "ftchr", "ftblk", "ftfile", "ftdir",
     "ftpipe", "ftlink", "ftsuid", "ftsgid", "ftsvtx", "fttty", "fttext",
     "ftbinary");
$priv{$_}{2} = "GREPLEX"
for ("mapwhile", "mapstart", "grepwhile", "grepstart");
a666 1
$priv{$_}{128} = 'UTF' for qw "last redo next goto dump";
d715 1
a715 8
	my $stash = $gv->STASH;
	if (class($stash) eq "SPECIAL") {
	    $stash = "<none>";
	}
	else {
	    $stash = $stash->NAME;
	}
	if ($stash eq "main") {
d736 1
a736 2
	} elsif ($preferpv
	      && ($sv->FLAGS & SVf_POK || class($sv) eq "REGEXP")) {
d742 1
a742 1
	} elsif ($sv->FLAGS & SVf_POK || class($sv) eq "REGEXP") {
d790 7
a796 8
	my $count = $h{name} eq 'padrange' ? ($op->private & 127) : 1;
	my (@@targarg, @@targarglife);
	for my $i (0..$count-1) {
	    my ($targarg, $targarglife);
	    my $padname = (($curcv->PADLIST->ARRAY)[0]->ARRAY)[$h{targ}+$i];
	    if (defined $padname and class($padname) ne "SPECIAL") {
		$targarg  = $padname->PVX;
		if ($padname->FLAGS & SVf_FAKE) {
d801 1
a801 1
			if $padname->PARENT_FAKELEX_FLAGS & PAD_FAKELEX_ANON;
d803 1
a803 1
			if $padname->PARENT_FAKELEX_FLAGS & PAD_FAKELEX_MULTI;
d806 1
a806 1
		    $targarglife = "$targarg:FAKE:$fake";
a807 8
		else {
		    my $intro = $padname->COP_SEQ_RANGE_LOW - $cop_seq_base;
		    my $finish = int($padname->COP_SEQ_RANGE_HIGH) - $cop_seq_base;
		    $finish = "end" if $finish == 999999999 - $cop_seq_base;
		    $targarglife = "$targarg:$intro,$finish";
		}
	    } else {
		$targarglife = $targarg = "t" . ($h{targ}+$i);
d809 8
a816 2
	    push @@targarg,     $targarg;
	    push @@targarglife, $targarglife;
a817 2
	$h{targarg}     = join '; ', @@targarg;
	$h{targarglife} = join '; ', @@targarglife;
a821 1
	my $extra = '';
d829 3
a831 7
	if ($op->name eq 'subst') {
	    if (class($op->pmreplstart) ne "NULL") {
		undef $lastnext;
		$extra = " replstart->" . seq($op->pmreplstart);
	    }
	}
	elsif ($op->name eq 'pushre') {
d834 13
a846 13
	    my $gv = $op->pmreplroot;
	    if (!ref($gv)) {
		# threaded: the value is actually a pad offset for where
		# the GV is kept (op_pmtargetoff)
		if ($gv) {
		    $gv = (($curcv->PADLIST->ARRAY)[1]->ARRAY)[$gv]->NAME;
		}
	    }
	    else {
		# unthreaded: its a GV (if it exists)
		$gv = (ref($gv) eq "B::GV") ? $gv->NAME : undef;
	    }
	    $extra = " => \@@$gv" if $gv;
a847 1
	$h{arg} = "($precomp$extra)";
d892 7
a898 2
    $h{opt} = $op->opt;
    $h{label} = $labels{$$op};
d1131 1
a1131 2
subroutines or formats to render; if no
such functions are specified, the main
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@d17 1
a17 1
our $VERSION   = "0.992";
d49 1
a49 2
   ["#class (#addr)\n\top_next\t\t#nextaddr\n\t(?(op_other\t#otheraddr\n\t)?)"
    . "op_sibling\t#sibaddr\n\t"
d597 30
a626 28
  for qw(pos substr vec threadsv gvsv rv2sv rv2hv rv2gv rv2av rv2arylen
         aelem helem aslice hslice padsv padav padhv enteriter entersub
         padrange pushmark);
$priv{$_}{64} = "REFC" for qw(leave leavesub leavesublv leavewrite);
$priv{$_}{128} = "LV" for qw(leave leaveloop);
@@{$priv{aassign}}{32,64} = qw(STATE COMMON);
@@{$priv{sassign}}{32,64,128} = qw(STATE BKWARD CV2GV);
$priv{$_}{64} = "RTIME" for qw(match subst substcont qr);
@@{$priv{$_}}{1,2,4,8,16,64} = qw(<UTF >UTF IDENT SQUASH DEL COMPL GROWS)
  for qw(trans transr);
$priv{repeat}{64} = "DOLIST";
$priv{leaveloop}{64} = "CONT";
@@{$priv{$_}}{32,64,96} = qw(DREFAV DREFHV DREFSV)
  for qw(rv2gv rv2sv padsv aelem helem);
$priv{$_}{16} = "STATE" for qw(padav padhv padsv);
@@{$priv{rv2gv}}{4,16} = qw(NOINIT FAKE);
@@{$priv{entersub}}{1,4,16,32,64} = qw(INARGS TARG DBG DEREF);
@@{$priv{rv2cv}}{1,8,128} = qw(CONST AMPER NO());
$priv{gv}{32} = "EARLYCV";
$priv{$_}{16} = "LVDEFER" for qw(aelem helem);
$priv{$_}{16} = "OURINTR" for qw(gvsv rv2sv rv2av rv2hv r2gv enteriter);
$priv{$_}{8} = "LVSUB"
  for qw(rv2av rv2gv rv2hv padav padhv aelem helem aslice hslice
         av2arylen keys rkeys substr pos vec);
$priv{$_}{4} = "SLICEWARN"
  for qw(rv2hv rv2av padav padhv hslice aslice);
@@{$priv{$_}}{32,64} = qw(BOOL BOOL?) for qw(rv2hv padhv);
$priv{substr}{16} = "REPL1ST";
d628 24
a651 21
  for map(($_,"s$_"), qw(chop chomp)),
      map(($_,"i_$_"), qw(postinc postdec multiply divide modulo add
                          subtract negate)),
      qw(pow concat stringify left_shift right_shift bit_and bit_xor
         bit_or complement atan2 sin cos rand exp log sqrt int hex oct
         abs length index rindex sprintf ord chr crypt quotemeta join
         push unshift flock chdir chown chroot unlink chmod utime rename
         link symlink mkdir rmdir wait waitpid system exec kill getppid
         getpgrp setpgrp getpriority setpriority time sleep);
$priv{$_}{4} = "REVERSED" for qw(enteriter iter);
@@{$priv{const}}{2,4,8,16,64} = qw(NOVER SHORT STRICT ENTERED BARE);
$priv{$_}{64} = "LINENUM" for qw(flip flop);
$priv{list}{64} = "GUESSED";
$priv{delete}{64} = "SLICE";
$priv{exists}{64} = "SUB";
@@{$priv{sort}}{1,2,4,8,16,32,64} = qw(NUM INT REV INPLACE DESC QSORT STABLE);
$priv{reverse}{8} = "INPLACE";
$priv{threadsv}{64} = "SVREFd";
@@{$priv{$_}}{16,32,64,128} = qw(INBIN INCR OUTBIN OUTCR)
  for qw(open backtick);
$priv{$_}{32} = "HUSH" for qw(nextstate dbstate);
d653 8
a660 7
  for qw(ftrread ftrwrite ftrexec fteread ftewrite fteexec);
@@{$priv{entereval}}{2,4,8,16} = qw(HAS_HH UNI BYTES COPHH);
@@{$priv{$_}}{4,8,16} = qw(FTSTACKED FTSTACKING FTAFTERt)
  for qw(ftrread ftrwrite ftrexec fteread ftewrite fteexec ftis fteowned
         ftrowned ftzero ftsize ftmtime ftatime ftctime ftsock ftchr
         ftblk ftfile ftdir ftpipe ftlink ftsuid ftsgid ftsvtx fttty
         fttext ftbinary);
d662 4
a665 5
  for qw(mapwhile mapstart grepwhile grepstart);
$priv{$_}{128} = "+1" for qw(caller wantarray runcv);
@@{$priv{coreargs}}{1,2,64,128} = qw(DREF1 DREF2 $MOD MARK);
$priv{$_}{128} = "UTF" for qw(last redo next goto dump);
$priv{split}{128} = "IMPLIM";
a893 1
	$h{otheraddr} = sprintf("%#x", $ {$op->other});
a923 4
    if ($op->folded) {
      $h{private} &&= "$h{private},";
      $h{private} .= "FOLD";
    }
d1646 1
a1646 1
Whether or not the op has been optimized by the peephole optimizer.
d1813 7
a1819 7
  my $walker = B::Concise::compile('-terse','aFuncName', \&aSubRef); # 1
  walk_output(\my $buf);
  $walker->();			        # 1 renders -terse
  set_style_standard('concise');	# 2
  $walker->();  		        # 2 renders -concise
  $walker->(@@new);			# 3 renders whatever
  print "3 different renderings: terse, concise, and @@new: $buf\n";
@


1.1.1.13
log
@Import perl-5.24.2
@
text
@d17 1
a17 1
our $VERSION   = "0.996";
d403 1
a403 2
	       'PVOP' => '"', 'LOOP' => "{", 'COP' => ";", 'PADOP' => "#",
	       'METHOP' => '.', UNOP_AUX => '+');
d474 1
a474 6
	my $maybe_root = $op->code_list;
	if ( ref($maybe_root) and $maybe_root->isa("B::OP")
	 and not $op->flags & OPf_KIDS) {
	    walk_topdown($maybe_root, $sub, $level + 1);
	}
	$maybe_root = $op->pmreplroot;
d530 23
a552 9
	$sequence_num{$$op} = $seq_max++;
	if (class($op) eq "LOGOP") {
	    sequence($op->other);
	} elsif (class($op) eq "LOOP") {
	    sequence($op->redoop);
	    sequence( $op->nextop);
	    sequence($op->lastop);
	} elsif ($name eq "subst" and $ {$op->pmreplstart}) {
	    sequence($op->pmreplstart);
d595 1
d597 65
a661 6

# use require rather than use here to avoid disturbing tests that dump
# BEGIN blocks
require B::Op_private;


a690 3
# return a string like 'LVINTRO,1' for the op $name with op_private
# value $x

d693 1
a693 50
    my $entry = $B::Op_private::bits{$name};
    return $x ? "$x" : '' unless $entry;

    my @@flags;
    my $bit;
    for ($bit = 7; $bit >= 0; $bit--) {
        next unless exists $entry->{$bit};
        my $e = $entry->{$bit};
        if (ref($e) eq 'HASH') {
            # bit field

            my ($bitmin, $bitmax, $bitmask, $enum, $label) =
                    @@{$e}{qw(bitmin bitmax bitmask enum label)};
            $bit = $bitmin;
            next if defined $label && $label eq '-'; # display as raw number

            my $val = $x & $bitmask;
            $x &= ~$bitmask;
            $val >>= $bitmin;

            if (defined $enum) {
                # try to convert numeric $val into symbolic
                my @@enum = @@$enum;
                while (@@enum) {
                    my $ix    = shift @@enum;
                    my $name  = shift @@enum;
                    my $label = shift @@enum;
                    if ($val == $ix) {
                        $val = $label;
                        last;
                    }
                }
            }
            next if $val eq '0'; # don't display anonymous zero values
            push @@flags, defined $label ? "$label=$val" : $val;

        }
        else {
            # flag bit
            my $label = $B::Op_private::labels{$e};
            next if defined $label && $label eq '-'; # display as raw number
            if ($x & (1<<$bit)) {
                $x -= (1<<$bit);
                push @@flags, $label;
            }
        }
    }

    push @@flags, $x if $x; # display unknown bits numerically
    return join ",", @@flags;
d782 3
a784 13
    $h{privval} = $op->private;
    # for null ops, targ holds the old type
    my $origname = $h{name} eq "null" && $h{targ}
      ? substr(ppname($h{targ}), 3)
      : $h{name};
    $h{private} = private_flags($origname, $op->private);
    if ($op->folded) {
      $h{private} &&= "$h{private},";
      $h{private} .= "FOLD";
    }

    if ($h{name} ne $origname) { # a null op
	$h{exname} = "ex-$origname";
d786 6
a791 4
    } elsif ($h{private} =~ /\bREFC\b/) {
	# targ holds a reference count
        my $refs = "ref" . ($h{targ} != 1 ? "s" : "");
        $h{targarglife} = $h{targarg} = "$h{targ} $refs";
d793 1
a793 3
	my $count = $h{name} eq 'padrange'
            ? ($op->private & $B::Op_private::defines{'OPpPADRANGE_COUNTMASK'})
            : 1;
d798 1
a798 3
	    if (defined $padname and class($padname) ne "SPECIAL" and
		$padname->LEN)
	    {
d895 1
d898 1
a898 1
		$h{arg} = "[" . concise_sv($sv, \%h, 0) . "]";
d901 1
a901 1
		$h{arg} = "(" . concise_sv($op->sv, \%h, 0) . ")";
a904 22
    elsif ($h{class} eq "METHOP") {
        my $prefix = '';
        if ($h{name} eq 'method_redir' or $h{name} eq 'method_redir_super') {
            my $rclass_sv = $op->rclass;
            $rclass_sv = (($curcv->PADLIST->ARRAY)[1]->ARRAY)[$rclass_sv]
                unless ref $rclass_sv;
            $prefix .= 'PACKAGE "'.$rclass_sv->PV.'", ';
        }
        if ($h{name} ne "method") {
            if (${$op->meth_sv}) {
                $h{arg} = "($prefix" . concise_sv($op->meth_sv, \%h, 1) . ")";
            } else {
                my $sv = (($curcv->PADLIST->ARRAY)[1]->ARRAY)[$op->targ];
                $h{arg} = "[$prefix" . concise_sv($sv, \%h, 1) . "]";
                $h{targarglife} = $h{targarg} = "";
            }
        }
    }
    elsif ($h{class} eq "UNOP_AUX") {
        $h{arg} = "(" . $op->string($curcv) . ")";
    }

d919 6
d1049 2
a1050 1
my $cop_seq_mnum = 16;
a1379 1
    +      UNOP_AUX         A UNOP with auxillary fields
a1388 1
    .      METHOP           An OP with method call info
d1416 4
a1419 1
B::Op_private and F<regen/op_private> for more details.
@


