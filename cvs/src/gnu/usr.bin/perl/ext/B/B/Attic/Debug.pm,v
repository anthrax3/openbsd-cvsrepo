head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.9.0.4
	OPENBSD_4_8_BASE:1.1.1.9
	OPENBSD_4_7:1.1.1.9.0.2
	OPENBSD_4_7_BASE:1.1.1.9
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.1.1.8.0.6
	OPENBSD_4_6_BASE:1.1.1.8
	OPENBSD_4_5:1.1.1.8.0.2
	OPENBSD_4_5_BASE:1.1.1.8
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.1.1.7.0.10
	OPENBSD_4_4_BASE:1.1.1.7
	OPENBSD_4_3:1.1.1.7.0.8
	OPENBSD_4_3_BASE:1.1.1.7
	OPENBSD_4_2:1.1.1.7.0.6
	OPENBSD_4_2_BASE:1.1.1.7
	OPENBSD_4_1:1.1.1.7.0.4
	OPENBSD_4_1_BASE:1.1.1.7
	OPENBSD_4_0:1.1.1.7.0.2
	OPENBSD_4_0_BASE:1.1.1.7
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.1.1.6.0.6
	OPENBSD_3_9_BASE:1.1.1.6
	OPENBSD_3_8:1.1.1.6.0.4
	OPENBSD_3_8_BASE:1.1.1.6
	OPENBSD_3_7:1.1.1.6.0.2
	OPENBSD_3_7_BASE:1.1.1.6
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.1.1.5.0.4
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2010.09.24.14.59.14;	author millert;	state dead;
branches;
next	1.1;

1.1
date	99.04.29.22.38.38;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.38.38;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.02;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.39;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.53;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.41;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.16.42;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.47.53;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.13;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.11.11;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package B::Debug;
use strict;
use B qw(peekop class walkoptree walkoptree_exec
         main_start main_root cstring sv_undef);
use B::Asmdata qw(@@specialsv_name);

my %done_gv;

sub B::OP::debug {
    my ($op) = @@_;
    printf <<'EOT', class($op), $$op, ${$op->next}, ${$op->sibling}, $op->ppaddr, $op->targ, $op->type, $op->seq, $op->flags, $op->private;
%s (0x%lx)
	op_next		0x%x
	op_sibling	0x%x
	op_ppaddr	%s
	op_targ		%d
	op_type		%d
	op_seq		%d
	op_flags	%d
	op_private	%d
EOT
}

sub B::UNOP::debug {
    my ($op) = @@_;
    $op->B::OP::debug();
    printf "\top_first\t0x%x\n", ${$op->first};
}

sub B::BINOP::debug {
    my ($op) = @@_;
    $op->B::UNOP::debug();
    printf "\top_last\t\t0x%x\n", ${$op->last};
}

sub B::LOGOP::debug {
    my ($op) = @@_;
    $op->B::UNOP::debug();
    printf "\top_other\t0x%x\n", ${$op->other};
}

sub B::CONDOP::debug {
    my ($op) = @@_;
    $op->B::UNOP::debug();
    printf "\top_true\t0x%x\n", ${$op->true};
    printf "\top_false\t0x%x\n", ${$op->false};
}

sub B::LISTOP::debug {
    my ($op) = @@_;
    $op->B::BINOP::debug();
    printf "\top_children\t%d\n", $op->children;
}

sub B::PMOP::debug {
    my ($op) = @@_;
    $op->B::LISTOP::debug();
    printf "\top_pmreplroot\t0x%x\n", ${$op->pmreplroot};
    printf "\top_pmreplstart\t0x%x\n", ${$op->pmreplstart};
    printf "\top_pmnext\t0x%x\n", ${$op->pmnext};
    printf "\top_pmregexp->precomp\t%s\n", cstring($op->precomp);
    printf "\top_pmflags\t0x%x\n", $op->pmflags;
    $op->pmshort->debug;
    $op->pmreplroot->debug;
}

sub B::COP::debug {
    my ($op) = @@_;
    $op->B::OP::debug();
    my ($filegv) = $op->filegv;
    printf <<'EOT', $op->label, ${$op->stash}, $$filegv, $op->seq, $op->arybase, $op->line;
	cop_label	%s
	cop_stash	0x%x
	cop_filegv	0x%x
	cop_seq		%d
	cop_arybase	%d
	cop_line	%d
EOT
    $filegv->debug;
}

sub B::SVOP::debug {
    my ($op) = @@_;
    $op->B::OP::debug();
    printf "\top_sv\t\t0x%x\n", ${$op->sv};
    $op->sv->debug;
}

sub B::PVOP::debug {
    my ($op) = @@_;
    $op->B::OP::debug();
    printf "\top_pv\t\t0x%x\n", $op->pv;
}

sub B::GVOP::debug {
    my ($op) = @@_;
    $op->B::OP::debug();
    printf "\top_gv\t\t0x%x\n", ${$op->gv};
    $op->gv->debug;
}

sub B::CVOP::debug {
    my ($op) = @@_;
    $op->B::OP::debug();
    printf "\top_cv\t\t0x%x\n", ${$op->cv};
}

sub B::NULL::debug {
    my ($sv) = @@_;
    if ($$sv == ${sv_undef()}) {
	print "&sv_undef\n";
    } else {
	printf "NULL (0x%x)\n", $$sv;
    }
}

sub B::SV::debug {
    my ($sv) = @@_;
    if (!$$sv) {
	print class($sv), " = NULL\n";
	return;
    }
    printf <<'EOT', class($sv), $$sv, $sv->REFCNT, $sv->FLAGS;
%s (0x%x)
	REFCNT		%d
	FLAGS		0x%x
EOT
}

sub B::PV::debug {
    my ($sv) = @@_;
    $sv->B::SV::debug();
    my $pv = $sv->PV();
    printf <<'EOT', cstring($pv), length($pv);
	xpv_pv		%s
	xpv_cur		%d
EOT
}

sub B::IV::debug {
    my ($sv) = @@_;
    $sv->B::SV::debug();
    printf "\txiv_iv\t\t%d\n", $sv->IV;
}

sub B::NV::debug {
    my ($sv) = @@_;
    $sv->B::IV::debug();
    printf "\txnv_nv\t\t%s\n", $sv->NV;
}

sub B::PVIV::debug {
    my ($sv) = @@_;
    $sv->B::PV::debug();
    printf "\txiv_iv\t\t%d\n", $sv->IV;
}

sub B::PVNV::debug {
    my ($sv) = @@_;
    $sv->B::PVIV::debug();
    printf "\txnv_nv\t\t%s\n", $sv->NV;
}

sub B::PVLV::debug {
    my ($sv) = @@_;
    $sv->B::PVNV::debug();
    printf "\txlv_targoff\t%d\n", $sv->TARGOFF;
    printf "\txlv_targlen\t%u\n", $sv->TARGLEN;
    printf "\txlv_type\t%s\n", cstring(chr($sv->TYPE));
}

sub B::BM::debug {
    my ($sv) = @@_;
    $sv->B::PVNV::debug();
    printf "\txbm_useful\t%d\n", $sv->USEFUL;
    printf "\txbm_previous\t%u\n", $sv->PREVIOUS;
    printf "\txbm_rare\t%s\n", cstring(chr($sv->RARE));
}

sub B::CV::debug {
    my ($sv) = @@_;
    $sv->B::PVNV::debug();
    my ($stash) = $sv->STASH;
    my ($start) = $sv->START;
    my ($root) = $sv->ROOT;
    my ($padlist) = $sv->PADLIST;
    my ($gv) = $sv->GV;
    my ($filegv) = $sv->FILEGV;
    printf <<'EOT', $$stash, $$start, $$root, $$gv, $$filegv, $sv->DEPTH, $padlist, ${$sv->OUTSIDE};
	STASH		0x%x
	START		0x%x
	ROOT		0x%x
	GV		0x%x
	FILEGV		0x%x
	DEPTH		%d
	PADLIST		0x%x			       
	OUTSIDE		0x%x
EOT
    $start->debug if $start;
    $root->debug if $root;
    $gv->debug if $gv;
    $filegv->debug if $filegv;
    $padlist->debug if $padlist;
}

sub B::AV::debug {
    my ($av) = @@_;
    $av->B::SV::debug;
    my(@@array) = $av->ARRAY;
    print "\tARRAY\t\t(", join(", ", map("0x" . $$_, @@array)), ")\n";
    printf <<'EOT', scalar(@@array), $av->MAX, $av->OFF, $av->AvFLAGS;
	FILL		%d    
	MAX		%d
	OFF		%d
	AvFLAGS		%d
EOT
}
    
sub B::GV::debug {
    my ($gv) = @@_;
    if ($done_gv{$$gv}++) {
	printf "GV %s::%s\n", $gv->STASH->NAME, $gv->NAME;
	return;
    }
    my ($sv) = $gv->SV;
    my ($av) = $gv->AV;
    my ($cv) = $gv->CV;
    $gv->B::SV::debug;
    printf <<'EOT', $gv->NAME, $gv->STASH->NAME, $gv->STASH, $$sv, $gv->GvREFCNT, $gv->FORM, $$av, ${$gv->HV}, ${$gv->EGV}, $$cv, $gv->CVGEN, $gv->LINE, $gv->FILEGV, $gv->GvFLAGS;
	NAME		%s
	STASH		%s (0x%x)
	SV		0x%x
	GvREFCNT	%d
	FORM		0x%x
	AV		0x%x
	HV		0x%x
	EGV		0x%x
	CV		0x%x
	CVGEN		%d
	LINE		%d
	FILEGV		0x%x
	GvFLAGS		0x%x
EOT
    $sv->debug if $sv;
    $av->debug if $av;
    $cv->debug if $cv;
}

sub B::SPECIAL::debug {
    my $sv = shift;
    print $specialsv_name[$$sv], "\n";
}

sub compile {
    my $order = shift;
    if ($order eq "exec") {
        return sub { walkoptree_exec(main_start, "debug") }
    } else {
        return sub { walkoptree(main_root, "debug") }
    }
}

1;

__END__

=head1 NAME

B::Debug - Walk Perl syntax tree, printing debug info about ops

=head1 SYNOPSIS

	perl -MO=Debug[,OPTIONS] foo.pl

=head1 DESCRIPTION

See F<ext/B/README>.

=head1 AUTHOR

Malcolm Beattie, C<mbeattie@@sable.ox.ac.uk>

=cut
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d42 7
d70 2
a71 1
    printf <<'EOT', $op->label, $op->stashpv, $op->file, $op->seq, $op->arybase, $op->line, ${$op->warnings};
d73 2
a74 2
	cop_stashpv	%s
	cop_file	%s
a77 1
	cop_warnings	0x%x
d79 1
d95 1
a95 1
sub B::PADOP::debug {
d98 2
a99 1
    printf "\top_padix\t\t%ld\n", $op->padix;
a186 1
    my ($file) = $sv->FILE;
d188 2
a189 1
    printf <<'EOT', $$stash, $$start, $$root, $$gv, $file, $sv->DEPTH, $padlist, ${$sv->OUTSIDE};
d194 1
a194 1
	FILE		%s
d202 1
d229 1
a229 1
    printf <<'EOT', $gv->NAME, $gv->STASH->NAME, $gv->STASH, $$sv, $gv->GvREFCNT, $gv->FORM, $$av, ${$gv->HV}, ${$gv->EGV}, $$cv, $gv->CVGEN, $gv->LINE, $gv->FILE, $gv->GvFLAGS;
d241 1
a241 1
	FILE		%s
a255 1
    B::clearsym();
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@a35 10
sub B::LOOP::debug {
    my ($op) = @@_;
    $op->B::BINOP::debug();
    printf <<'EOT', ${$op->redoop}, ${$op->nextop}, ${$op->lastop};
       op_redoop       0x%x
       op_nextop       0x%x
       op_lastop       0x%x
EOT
}

d56 1
d212 1
a212 1
	printf "GV %s::%s\n", $gv->STASH->NAME, $gv->SAFENAME;
d219 1
a219 1
    printf <<'EOT', $gv->SAFENAME, $gv->STASH->NAME, $gv->STASH, $$sv, $gv->GvREFCNT, $gv->FORM, $$av, ${$gv->HV}, ${$gv->EGV}, $$cv, $gv->CVGEN, $gv->LINE, $gv->FILE, $gv->GvFLAGS;
d247 1
a247 1
    if ($order && $order eq "exec") {
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a1 3

our $VERSION = '1.00';

d93 1
a93 1
    printf "\top_pv\t\t%s\n", cstring($op->pv);
a127 9
}

sub B::RV::debug {
    my ($rv) = @@_;
    B::SV::debug($rv);
    printf <<'EOT', ${$rv->RV};
	RV		0x%x
EOT
    $rv->RV->debug;
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.01';
d43 3
a45 3
	op_redoop	0x%x
	op_nextop	0x%x
	op_lastop	0x%x
d75 1
a75 2
    my $cop_io = class($op->io) eq 'SPECIAL' ? '' : $op->io->as_string;
    printf <<'EOT', $op->label, $op->stashpv, $op->file, $op->cop_seq, $op->arybase, $op->line, ${$op->warnings}, cstring($cop_io);
a82 1
	cop_io		%s
d105 6
d201 1
a201 1
    printf <<'EOT', $$stash, $$start, $$root, $$gv, $file, $sv->DEPTH, $padlist, ${$sv->OUTSIDE}, $sv->OUTSIDE_SEQ;
d208 1
a208 1
	PADLIST		0x%x
a209 1
	OUTSIDE_SEQ	%d
d223 1
a223 1
	FILL		%d
d229 1
a229 1

@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.02';
d14 1
a14 1
    printf <<'EOT', class($op), $$op, ${$op->next}, ${$op->sibling}, $op->ppaddr, $op->targ, $op->type;
a20 8
EOT
    if ($] > 5.009) {
	printf <<'EOT', $op->opt, $op->static;
	op_opt		%d
	op_static	%d
EOT
    } else {
	printf <<'EOT', $op->seq;
a21 3
EOT
    }
    printf <<'EOT', $op->flags, $op->private;
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
our $VERSION = '1.02_01';
d230 1
a230 1
    printf <<'EOT', scalar(@@array), $av->MAX, $av->OFF;
a233 2
EOT
    printf <<'EOT', $av->AvFLAGS if $] < 5.009;
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.05';
d7 2
a8 1
         main_start main_root cstring sv_undef @@specialsv_name);
d23 1
a23 1
	printf <<'EOT', $op->opt;
d25 1
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d3 1
a3 1
our $VERSION = '1.11';
a5 1
require 5.006;
d7 2
a8 14
         main_start main_root cstring sv_undef);
use Config;
my (@@optype, @@specialsv_name);
require B;
if ($] < 5.009) {
  require B::Asmdata;
  B::Asmdata->import qw(@@optype @@specialsv_name);
} else {
  B->import qw(@@optype @@specialsv_name);
}
my $have_B_Flags;
if (!$ENV{PERL_CORE}){ # avoid CORE test crashes
  eval { require B::Flags and $have_B_Flags++ };
}
a10 7
sub _printop {
  my $op = shift;
  my $addr = ${$op} ? $op->ppaddr : '';
  $addr =~ s/^PL_ppaddr// if $addr;
  return sprintf "0x%x %s %s", ${$op}, ${$op} ? class($op) : '', $addr;
}

d13 1
a13 1
    printf <<'EOT', class($op), $$op, $op->ppaddr, _printop($op->next), _printop($op->sibling), $op->targ, $op->type;
d15 2
a17 2
	op_next		%s
	op_sibling	%s
d30 1
a30 7
    if ($have_B_Flags) {
        printf <<'EOT', $op->flags, $op->flagspv, $op->private, $op->privatepv;
	op_flags	%d	%s
	op_private	%d	%s
EOT
    } else {
        printf <<'EOT', $op->flags, $op->private;
a33 1
    }
d39 1
a39 1
    printf "\top_first\t%s\n", _printop($op->first);
d45 1
a45 1
    printf "\top_last \t%s\n", _printop($op->last);
d51 4
a54 4
    printf <<'EOT', _printop($op->redoop), _printop($op->nextop), _printop($op->lastop);
	op_redoop	%s
	op_nextop	%s
	op_lastop	%s
d61 1
a61 1
    printf "\top_other\t%s\n", _printop($op->other);
d73 1
a73 1
    printf "\top_pmreplroot\t0x%x\n", $] < 5.008 ? ${$op->pmreplroot} : $op->pmreplroot;
d75 2
a76 8
    printf "\top_pmnext\t0x%x\n", ${$op->pmnext} if $] < 5.009005;
    if ($Config{'useithreads'}) {
      printf "\top_pmstashpv\t%s\n", cstring($op->pmstashpv);
      printf "\top_pmoffset\t%d\n", $op->pmoffset;
    } else {
      printf "\top_pmstash\t%s\n", cstring($op->pmstash);
    }
    printf "\top_precomp\t%s\n", cstring($op->precomp);
d78 1
a78 4
    printf "\top_reflags\t0x%x\n", $op->reflags if $] >= 5.009;
    printf "\top_pmpermflags\t0x%x\n", $op->pmpermflags if $] < 5.009;
    printf "\top_pmdynflags\t0x%x\n", $op->pmdynflags if $] < 5.009;
    $op->pmreplroot->debug if $] < 5.008;
d86 3
a88 3
	cop_label	"%s"
	cop_stashpv	"%s"
	cop_file	"%s"
d113 1
a113 1
    printf "\top_padix\t%ld\n", $op->padix;
d226 1
a226 2
    # tied arrays may leave out FETCHSIZE
    my (@@array) = eval { $av->ARRAY; };
d228 1
a228 3
    my $fill = eval { scalar(@@array) };
    if ($Config{'useithreads'}) {
      printf <<'EOT', $fill, $av->MAX, $av->OFF;
a232 6
    } else {
      printf <<'EOT', $fill, $av->MAX;
	FILL		%d
	MAX		%d
EOT
    }
d297 1
a297 46
See F<ext/B/README> and the newer L<B::Concise>, L<B::Terse>.

=head1 OPTIONS

With option -exec, walks tree in execute order,
otherwise in basic order.

=head1 Changes

  1.11 2008-07-14 rurban
	avoid B::Flags in CORE tests not to crash on old XS in @@INC

  1.10 2008-06-28 rurban
	require 5.006; Test::More not possible in 5.00505
	our => my
	
  1.09 2008-06-18 rurban
	minor META.yml syntax fix
	5.8.0 ending nextstate test failure: be more tolerant
	PREREQ_PM Test::More

  1.08 2008-06-17 rurban
	support 5.00558 - 5.6.2

  1.07 2008-06-16 rurban
	debug.t: fix strawberry perl quoting issue

  1.06 2008-06-11 rurban
	added B::Flags output
	dual-life CPAN as B-Debug-1.06 and CORE
	protect scalar(@@array) if tied arrays leave out FETCHSIZE

  1.05_03 2008-04-16 rurban
	ithread fixes in B::AV
	B-C-1.04_??

  B-C-1.04_09 2008-02-24 rurban
	support 5.8 (import Asmdata)

  1.05_02 2008-02-21 rurban
	added _printop
	B-C-1.04_08 and CORE

  1.05_01 2008-02-05 rurban
	5.10 fix for op->seq
	B-C-1.04_04
a301 27
Reini Urban C<rurban@@cpan.org>

=head1 LICENSE

Copyright (c) 1996, 1997 Malcolm Beattie
Copyright (c) 2008 Reini Urban

	This program is free software; you can redistribute it and/or modify
	it under the terms of either:

	a) the GNU General Public License as published by the Free
	Software Foundation; either version 1, or (at your option) any
	later version, or

	b) the "Artistic License" which comes with this kit.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
    the GNU General Public License or the Artistic License for more details.

    You should have received a copy of the Artistic License with this kit,
    in the file named "Artistic".  If not, you can get one from the Perl
    distribution. You should also have received a copy of the GNU General
    Public License, in the file named "Copying". If not, you can get one
    from the Perl distribution or else write to the Free Software Foundation,
    Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
@


