head	1.2;
access;
symbols
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.10
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.8
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.6
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.4
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.2
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.12
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.10
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.8
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2008.09.29.17.36.01;	author millert;	state dead;
branches;
next	1.1;

1.1
date	99.04.29.22.38.38;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.38.38;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.01;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.53;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.43.41;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.47.52;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@package B::Bblock;
use Exporter ();
@@ISA = "Exporter";
@@EXPORT_OK = qw(find_leaders);

use B qw(peekop walkoptree walkoptree_exec
	 main_root main_start svref_2object);
use B::Terse;
use strict;

my $bblock;
my @@bblock_ends;

sub mark_leader {
    my $op = shift;
    if ($$op) {
	$bblock->{$$op} = $op;
    }
}

sub find_leaders {
    my ($root, $start) = @@_;
    $bblock = {};
    mark_leader($start);
    walkoptree($root, "mark_if_leader");
    return $bblock;
}

# Debugging
sub walk_bblocks {
    my ($root, $start) = @@_;
    my ($op, $lastop, $leader, $bb);
    $bblock = {};
    mark_leader($start);
    walkoptree($root, "mark_if_leader");
    my @@leaders = values %$bblock;
    while ($leader = shift @@leaders) {
	$lastop = $leader;
	$op = $leader->next;
	while ($$op && !exists($bblock->{$$op})) {
	    $bblock->{$$op} = $leader;
	    $lastop = $op;
	    $op = $op->next;
	}
	push(@@bblock_ends, [$leader, $lastop]);
    }
    foreach $bb (@@bblock_ends) {
	($leader, $lastop) = @@$bb;
	printf "%s .. %s\n", peekop($leader), peekop($lastop);
	for ($op = $leader; $$op != $$lastop; $op = $op->next) {
	    printf "    %s\n", peekop($op);
	}
	printf "    %s\n", peekop($lastop);
    }
    print "-------\n";
    walkoptree_exec($start, "terse");
}

sub walk_bblocks_obj {
    my $cvref = shift;
    my $cv = svref_2object($cvref);
    walk_bblocks($cv->ROOT, $cv->START);
}

sub B::OP::mark_if_leader {}

sub B::COP::mark_if_leader {
    my $op = shift;
    if ($op->label) {
	mark_leader($op);
    }
}

sub B::LOOP::mark_if_leader {
    my $op = shift;
    mark_leader($op->next);
    mark_leader($op->nextop);
    mark_leader($op->redoop);
    mark_leader($op->lastop->next);
}

sub B::LOGOP::mark_if_leader {
    my $op = shift;
    my $ppaddr = $op->ppaddr;
    mark_leader($op->next);
    if ($ppaddr eq "pp_entertry") {
	mark_leader($op->other->next);
    } else {
	mark_leader($op->other);
    }
}

sub B::CONDOP::mark_if_leader {
    my $op = shift;
    mark_leader($op->next);
    mark_leader($op->true);
    mark_leader($op->false);
}

sub B::PMOP::mark_if_leader {
    my $op = shift;
    if ($op->ppaddr ne "pp_pushre") {
	my $replroot = $op->pmreplroot;
	if ($$replroot) {
	    mark_leader($replroot);
	    mark_leader($op->next);
	    mark_leader($op->pmreplstart);
	}
    }
}

# PMOP stuff omitted

sub compile {
    my @@options = @@_;
    if (@@options) {
	return sub {
	    my $objname;
	    foreach $objname (@@options) {
		$objname = "main::$objname" unless $objname =~ /::/;
		eval "walk_bblocks_obj(\\&$objname)";
		die "walk_bblocks_obj(\\&$objname) failed: $@@" if $@@;
	    }
	}
    } else {
	return sub { walk_bblocks(main_root, main_start) };
    }
}

# Basic block leaders:
#     Any COP (pp_nextstate) with a non-NULL label
#     [The op after a pp_enter] Omit
#     [The op after a pp_entersub. Don't count this one.]
#     The ops pointed at by nextop, redoop and lastop->op_next of a LOOP
#     The ops pointed at by op_next and op_other of a LOGOP, except
#     for pp_entertry which has op_next and op_other->op_next
#     The ops pointed at by op_true and op_false of a CONDOP
#     The op pointed at by op_pmreplstart of a PMOP
#     The op pointed at by op_other->op_pmreplstart of pp_substcont?
#     [The op after a pp_return] Omit

1;

__END__

=head1 NAME

B::Bblock - Walk basic blocks

=head1 SYNOPSIS

	perl -MO=Bblock[,OPTIONS] foo.pl

=head1 DESCRIPTION

See F<ext/B/README>.

=head1 AUTHOR

Malcolm Beattie, C<mbeattie@@sable.ox.ac.uk>

=cut
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d7 1
a7 3
	 main_root main_start svref_2object
         OPf_SPECIAL OPf_STACKED );

a20 6
sub remove_sortblock{
    foreach (keys %$bblock){
        my $leader=$$bblock{$_};	
	delete $$bblock{$_} if( $leader == 0);   
    }
}
d24 2
a25 3
    mark_leader($start) if ( ref $start ne "B::NULL" );
    walkoptree($root, "mark_if_leader") if ((ref $root) ne "B::NULL") ;
    remove_sortblock();
d84 1
a84 1
    my $opname = $op->name;
d86 1
a86 1
    if ($opname eq "entertry") {
d93 1
a93 1
sub B::LISTOP::mark_if_leader {
a94 3
    my $first=$op->first;
    $first=$first->next while ($first->name eq "null");
    mark_leader($op->first) unless (exists( $bblock->{$$first}));
d96 2
a97 6
    if ($op->name eq "sort" and $op->flags & OPf_SPECIAL
	and $op->flags & OPf_STACKED){
        my $root=$op->first->sibling->first;
        my $leader=$root->first;
        $bblock->{$$leader} = 0;
    }
d102 1
a102 1
    if ($op->name ne "pushre") {
a115 1
    B::clearsym();
d137 1
d156 1
a156 3
This module is used by the B::CC back end.  It walks "basic blocks".
A basic block is a series of operations which is known to execute from
start to finish, with no possiblity of branching or halting.
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@a1 3

our $VERSION = '1.00';

d168 1
a168 6
  # External interface
  perl -MO=Bblock[,OPTIONS] foo.pl

  # Programmatic API
  use B::Bblock qw(find_leaders);
  my $leaders = find_leaders($root_op, $start_op);
a174 29

It can be used either stand alone or from inside another program.

=for _private
Somebody who understands the stand-alone options document them, please.

=head2 Functions

=over 4

=item B<find_leaders>

  my $leaders = find_leaders($root_op, $start_op);

Given the root of the op tree and an op from which to start
processing, it will return a hash ref representing all the ops which
start a block.

=for _private
The above description may be somewhat wrong.

The values of %$leaders are the op objects themselves.  Keys are $$op
addresses.

=for _private
Above cribbed from B::CC's comments.  What's a $$op address?

=back

@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.02';
d13 1
a13 1
use B::Concise qw(concise_cv concise_main set_style_standard);
d67 2
a142 4
		print "-------\n";
		set_style_standard("terse");
		eval "concise_cv('exec', \\&$objname)";
		die "concise_cv('exec', \\&$objname) failed: $@@" if $@@;
d146 1
a146 6
	return sub {
	    walk_bblocks(main_root, main_start);
	    print "-------\n";
	    set_style_standard("terse");
	    concise_main("exec");
	};
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
our $VERSION = '1.02_01';
d189 1
a189 1
start to finish, with no possibility of branching or halting.
@


