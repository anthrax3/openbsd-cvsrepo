head	1.2;
access;
symbols
	OPENBSD_4_4:1.1.1.6.0.10
	OPENBSD_4_4_BASE:1.1.1.6
	OPENBSD_4_3:1.1.1.6.0.8
	OPENBSD_4_3_BASE:1.1.1.6
	OPENBSD_4_2:1.1.1.6.0.6
	OPENBSD_4_2_BASE:1.1.1.6
	OPENBSD_4_1:1.1.1.6.0.4
	OPENBSD_4_1_BASE:1.1.1.6
	OPENBSD_4_0:1.1.1.6.0.2
	OPENBSD_4_0_BASE:1.1.1.6
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.1.1.5.0.10
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.8
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.6
	OPENBSD_3_7_BASE:1.1.1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.1.1.5.0.4
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2008.09.29.17.36.01;	author millert;	state dead;
branches;
next	1.1;

1.1
date	99.04.29.22.38.38;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.38.38;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.02;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.39;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.53;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.41;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.47.52;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@#      Bytecode.pm
#
#      Copyright (c) 1996-1998 Malcolm Beattie
#
#      You may distribute under the terms of either the GNU General Public
#      License or the Artistic License, as specified in the README file.
#
package B::Bytecode;
use strict;
use Carp;
use IO::File;

use B qw(minus_c main_cv main_root main_start comppadlist
	 class peekop walkoptree svref_2object cstring walksymtable);
use B::Asmdata qw(@@optype @@specialsv_name);
use B::Assembler qw(assemble_fh);

my %optype_enum;
my $i;
for ($i = 0; $i < @@optype; $i++) {
    $optype_enum{$optype[$i]} = $i;
}

# Following is SVf_POK|SVp_POK
# XXX Shouldn't be hardwired
sub POK () { 0x04040000 }

# Following is SVf_IOK|SVp_OK
# XXX Shouldn't be hardwired
sub IOK () { 0x01010000 }

my ($verbose, $module_only, $no_assemble, $debug_bc, $debug_cv);
my $assembler_pid;

# Optimisation options. On the command line, use hyphens instead of
# underscores for compatibility with gcc-style options. We use
# underscores here because they are OK in (strict) barewords.
my ($strip_syntree, $compress_nullops, $omit_seq, $bypass_nullops);
my %optimise = (strip_syntax_tree	=> \$strip_syntree,
		compress_nullops	=> \$compress_nullops,
		omit_sequence_numbers	=> \$omit_seq,
		bypass_nullops		=> \$bypass_nullops);

my $nextix = 0;
my %symtable;	# maps object addresses to object indices.
		# Filled in at allocation (newsv/newop) time.
my %saved;	# maps object addresses (for SVish classes) to "saved yet?"
		# flag. Set at FOO::bytecode time usually by SV::bytecode.
		# Manipulated via saved(), mark_saved(), unmark_saved().

my $svix = -1;	# we keep track of when the sv register contains an element
		# of the object table to avoid unnecessary repeated
		# consecutive ldsv instructions.
my $opix = -1;	# Ditto for the op register.

sub ldsv {
    my $ix = shift;
    if ($ix != $svix) {
	print "ldsv $ix\n";
	$svix = $ix;
    }
}

sub stsv {
    my $ix = shift;
    print "stsv $ix\n";
    $svix = $ix;
}

sub set_svix {
    $svix = shift;
}

sub ldop {
    my $ix = shift;
    if ($ix != $opix) {
	print "ldop $ix\n";
	$opix = $ix;
    }
}

sub stop {
    my $ix = shift;
    print "stop $ix\n";
    $opix = $ix;
}

sub set_opix {
    $opix = shift;
}

sub pvstring {
    my $str = shift;
    if (defined($str)) {
	return cstring($str . "\0");
    } else {
	return '""';
    }
}

sub saved { $saved{${$_[0]}} }
sub mark_saved { $saved{${$_[0]}} = 1 }
sub unmark_saved { $saved{${$_[0]}} = 0 }

sub debug { $debug_bc = shift }

sub B::OBJECT::nyi {
    my $obj = shift;
    warn sprintf("bytecode save method for %s (0x%x) not yet implemented\n",
		 class($obj), $$obj);
}

#
# objix may stomp on the op register (for op objects)
# or the sv register (for SV objects)
#
sub B::OBJECT::objix {
    my $obj = shift;
    my $ix = $symtable{$$obj};
    if (defined($ix)) {
	return $ix;
    } else {
	$obj->newix($nextix);
	return $symtable{$$obj} = $nextix++;
    }
}

sub B::SV::newix {
    my ($sv, $ix) = @@_;
    printf "newsv %d\t# %s\n", $sv->FLAGS & 0xf, class($sv);
    stsv($ix);    
}

sub B::GV::newix {
    my ($gv, $ix) = @@_;
    my $gvname = $gv->NAME;
    my $name = cstring($gv->STASH->NAME . "::" . $gvname);
    print "gv_fetchpv $name\n";
    stsv($ix);
}

sub B::HV::newix {
    my ($hv, $ix) = @@_;
    my $name = $hv->NAME;
    if ($name) {
	# It's a stash
	printf "gv_stashpv %s\n", cstring($name);
	stsv($ix);
    } else {
	# It's an ordinary HV. Fall back to ordinary newix method
	$hv->B::SV::newix($ix);
    }
}

sub B::SPECIAL::newix {
    my ($sv, $ix) = @@_;
    # Special case. $$sv is not the address of the SV but an
    # index into svspecialsv_list.
    printf "ldspecsv $$sv\t# %s\n", $specialsv_name[$$sv];
    stsv($ix);
}

sub B::OP::newix {
    my ($op, $ix) = @@_;
    my $class = class($op);
    my $typenum = $optype_enum{$class};
    croak "OP::newix: can't understand class $class" unless defined($typenum);
    print "newop $typenum\t# $class\n";
    stop($ix);
}

sub B::OP::walkoptree_debug {
    my $op = shift;
    warn(sprintf("walkoptree: %s\n", peekop($op)));
}

sub B::OP::bytecode {
    my $op = shift;
    my $next = $op->next;
    my $nextix;
    my $sibix = $op->sibling->objix;
    my $ix = $op->objix;
    my $type = $op->type;

    if ($bypass_nullops) {
	$next = $next->next while $$next && $next->type == 0;
    }
    $nextix = $next->objix;

    printf "# %s\n", peekop($op) if $debug_bc;
    ldop($ix);
    print "op_next $nextix\n";
    print "op_sibling $sibix\n" unless $strip_syntree;
    printf "op_type %s\t# %d\n", $op->ppaddr, $type;
    printf("op_seq %d\n", $op->seq) unless $omit_seq;
    if ($type || !$compress_nullops) {
	printf "op_targ %d\nop_flags 0x%x\nop_private 0x%x\n",
	    $op->targ, $op->flags, $op->private;
    }
}

sub B::UNOP::bytecode {
    my $op = shift;
    my $firstix = $op->first->objix;
    $op->B::OP::bytecode;
    if (($op->type || !$compress_nullops) && !$strip_syntree) {
	print "op_first $firstix\n";
    }
}

sub B::LOGOP::bytecode {
    my $op = shift;
    my $otherix = $op->other->objix;
    $op->B::UNOP::bytecode;
    print "op_other $otherix\n";
}

sub B::SVOP::bytecode {
    my $op = shift;
    my $sv = $op->sv;
    my $svix = $sv->objix;
    $op->B::OP::bytecode;
    print "op_sv $svix\n";
    $sv->bytecode;
}

sub B::GVOP::bytecode {
    my $op = shift;
    my $gv = $op->gv;
    my $gvix = $gv->objix;
    $op->B::OP::bytecode;
    print "op_gv $gvix\n";
    $gv->bytecode;
}

sub B::PVOP::bytecode {
    my $op = shift;
    my $pv = $op->pv;
    $op->B::OP::bytecode;
    #
    # This would be easy except that OP_TRANS uses a PVOP to store an
    # endian-dependent array of 256 shorts instead of a plain string.
    #
    if ($op->ppaddr eq "pp_trans") {
	my @@shorts = unpack("s256", $pv); # assembler handles endianness
	print "op_pv_tr ", join(",", @@shorts), "\n";
    } else {
	printf "newpv %s\nop_pv\n", pvstring($pv);
    }
}

sub B::BINOP::bytecode {
    my $op = shift;
    my $lastix = $op->last->objix;
    $op->B::UNOP::bytecode;
    if (($op->type || !$compress_nullops) && !$strip_syntree) {
	print "op_last $lastix\n";
    }
}

sub B::CONDOP::bytecode {
    my $op = shift;
    my $trueix = $op->true->objix;
    my $falseix = $op->false->objix;
    $op->B::UNOP::bytecode;
    print "op_true $trueix\nop_false $falseix\n";
}

sub B::LISTOP::bytecode {
    my $op = shift;
    my $children = $op->children;
    $op->B::BINOP::bytecode;
    if (($op->type || !$compress_nullops) && !$strip_syntree) {
	print "op_children $children\n";
    }
}

sub B::LOOP::bytecode {
    my $op = shift;
    my $redoopix = $op->redoop->objix;
    my $nextopix = $op->nextop->objix;
    my $lastopix = $op->lastop->objix;
    $op->B::LISTOP::bytecode;
    print "op_redoop $redoopix\nop_nextop $nextopix\nop_lastop $lastopix\n";
}

sub B::COP::bytecode {
    my $op = shift;
    my $stash = $op->stash;
    my $stashix = $stash->objix;
    my $filegv = $op->filegv;
    my $filegvix = $filegv->objix;
    my $line = $op->line;
    if ($debug_bc) {
	printf "# line %s:%d\n", $filegv->SV->PV, $line;
    }
    $op->B::OP::bytecode;
    printf <<"EOT", pvstring($op->label), $op->cop_seq, $op->arybase;
newpv %s
cop_label
cop_stash $stashix
cop_seq %d
cop_filegv $filegvix
cop_arybase %d
cop_line $line
EOT
    $filegv->bytecode;
    $stash->bytecode;
}

sub B::PMOP::bytecode {
    my $op = shift;
    my $replroot = $op->pmreplroot;
    my $replrootix = $replroot->objix;
    my $replstartix = $op->pmreplstart->objix;
    my $ppaddr = $op->ppaddr;
    # pmnext is corrupt in some PMOPs (see misc.t for example)
    #my $pmnextix = $op->pmnext->objix;

    if ($$replroot) {
	# OP_PUSHRE (a mutated version of OP_MATCH for the regexp
	# argument to a split) stores a GV in op_pmreplroot instead
	# of a substitution syntax tree. We don't want to walk that...
	if ($ppaddr eq "pp_pushre") {
	    $replroot->bytecode;
	} else {
	    walkoptree($replroot, "bytecode");
	}
    }
    $op->B::LISTOP::bytecode;
    if ($ppaddr eq "pp_pushre") {
	printf "op_pmreplrootgv $replrootix\n";
    } else {
	print "op_pmreplroot $replrootix\nop_pmreplstart $replstartix\n";
    }
    my $re = pvstring($op->precomp);
    # op_pmnext omitted since a perl bug means it's sometime corrupt
    printf <<"EOT", $op->pmflags, $op->pmpermflags;
op_pmflags 0x%x
op_pmpermflags 0x%x
newpv $re
pregcomp
EOT
}

sub B::SV::bytecode {
    my $sv = shift;
    return if saved($sv);
    my $ix = $sv->objix;
    my $refcnt = $sv->REFCNT;
    my $flags = sprintf("0x%x", $sv->FLAGS);
    ldsv($ix);
    print "sv_refcnt $refcnt\nsv_flags $flags\n";
    mark_saved($sv);
}

sub B::PV::bytecode {
    my $sv = shift;
    return if saved($sv);
    $sv->B::SV::bytecode;
    printf("newpv %s\nxpv\n", pvstring($sv->PV)) if $sv->FLAGS & POK;
}

sub B::IV::bytecode {
    my $sv = shift;
    return if saved($sv);
    my $iv = $sv->IVX;
    $sv->B::SV::bytecode;
    printf "%s $iv\n", $sv->needs64bits ? "xiv64" : "xiv32";
}

sub B::NV::bytecode {
    my $sv = shift;
    return if saved($sv);
    $sv->B::SV::bytecode;
    printf "xnv %s\n", $sv->NVX;
}

sub B::RV::bytecode {
    my $sv = shift;
    return if saved($sv);
    my $rv = $sv->RV;
    my $rvix = $rv->objix;
    $rv->bytecode;
    $sv->B::SV::bytecode;
    print "xrv $rvix\n";
}

sub B::PVIV::bytecode {
    my $sv = shift;
    return if saved($sv);
    my $iv = $sv->IVX;
    $sv->B::PV::bytecode;
    printf "%s $iv\n", $sv->needs64bits ? "xiv64" : "xiv32";
}

sub B::PVNV::bytecode {
    my ($sv, $flag) = @@_;
    # The $flag argument is passed through PVMG::bytecode by BM::bytecode
    # and AV::bytecode and indicates special handling. $flag = 1 is used by
    # BM::bytecode and means that we should ensure we save the whole B-M
    # table. It consists of 257 bytes (256 char array plus a final \0)
    # which follow the ordinary PV+\0 and the 257 bytes are *not* reflected
    # in SvCUR. $flag = 2 is used by AV::bytecode and means that we only
    # call SV::bytecode instead of saving PV and calling NV::bytecode since
    # PV/NV/IV stuff is different for AVs.
    return if saved($sv);
    if ($flag == 2) {
	$sv->B::SV::bytecode;
    } else {
	my $pv = $sv->PV;
	$sv->B::IV::bytecode;
	printf "xnv %s\n", $sv->NVX;
	if ($flag == 1) {
	    $pv .= "\0" . $sv->TABLE;
	    printf "newpv %s\npv_cur %d\nxpv\n", pvstring($pv),length($pv)-257;
	} else {
	    printf("newpv %s\nxpv\n", pvstring($pv)) if $sv->FLAGS & POK;
	}
    }
}

sub B::PVMG::bytecode {
    my ($sv, $flag) = @@_;
    # See B::PVNV::bytecode for an explanation of $flag.
    return if saved($sv);
    # XXX We assume SvSTASH is already saved and don't save it later ourselves
    my $stashix = $sv->SvSTASH->objix;
    my @@mgchain = $sv->MAGIC;
    my (@@mgobjix, $mg);
    #
    # We need to traverse the magic chain and get objix for each OBJ
    # field *before* we do B::PVNV::bytecode since objix overwrites
    # the sv register. However, we need to write the magic-saving
    # bytecode *after* B::PVNV::bytecode since sv isn't initialised
    # to refer to $sv until then.
    #
    @@mgobjix = map($_->OBJ->objix, @@mgchain);
    $sv->B::PVNV::bytecode($flag);
    print "xmg_stash $stashix\n";
    foreach $mg (@@mgchain) {
	printf "sv_magic %s\nmg_obj %d\nnewpv %s\nmg_pv\n",
	    cstring($mg->TYPE), shift(@@mgobjix), pvstring($mg->PTR);
    }
}

sub B::PVLV::bytecode {
    my $sv = shift;
    return if saved($sv);
    $sv->B::PVMG::bytecode;
    printf <<'EOT', $sv->TARGOFF, $sv->TARGLEN, cstring($sv->TYPE);
xlv_targoff %d
xlv_targlen %d
xlv_type %s
EOT
}

sub B::BM::bytecode {
    my $sv = shift;
    return if saved($sv);
    # See PVNV::bytecode for an explanation of what the argument does
    $sv->B::PVMG::bytecode(1);
    printf "xbm_useful %d\nxbm_previous %d\nxbm_rare %d\n",
	$sv->USEFUL, $sv->PREVIOUS, $sv->RARE;
}

sub B::GV::bytecode {
    my $gv = shift;
    return if saved($gv);
    my $ix = $gv->objix;
    mark_saved($gv);
    my $gvname = $gv->NAME;
    my $name = cstring($gv->STASH->NAME . "::" . $gvname);
    my $egv = $gv->EGV;
    my $egvix = $egv->objix;
    ldsv($ix);
    printf <<"EOT", $gv->FLAGS, $gv->GvFLAGS, $gv->LINE;
sv_flags 0x%x
xgv_flags 0x%x
gp_line %d
EOT
    my $refcnt = $gv->REFCNT;
    printf("sv_refcnt_add %d\n", $refcnt - 1) if $refcnt > 1;
    my $gvrefcnt = $gv->GvREFCNT;
    printf("gp_refcnt_add %d\n", $gvrefcnt - 1) if $gvrefcnt > 1;
    if ($gvrefcnt > 1 &&  $ix != $egvix) {
	print "gp_share $egvix\n";
    } else {
	if ($gvname !~ /^([^A-Za-z]|STDIN|STDOUT|STDERR|ARGV|SIG|ENV)$/) {
	    my $i;
	    my @@subfield_names = qw(SV AV HV CV FILEGV FORM IO);
	    my @@subfields = map($gv->$_(), @@subfield_names);
	    my @@ixes = map($_->objix, @@subfields);
	    # Reset sv register for $gv
	    ldsv($ix);
	    for ($i = 0; $i < @@ixes; $i++) {
		printf "gp_%s %d\n", lc($subfield_names[$i]), $ixes[$i];
	    }
	    # Now save all the subfields
	    my $sv;
	    foreach $sv (@@subfields) {
		$sv->bytecode;
	    }
	}
    }
}

sub B::HV::bytecode {
    my $hv = shift;
    return if saved($hv);
    mark_saved($hv);
    my $name = $hv->NAME;
    my $ix = $hv->objix;
    if (!$name) {
	# It's an ordinary HV. Stashes have NAME set and need no further
	# saving beyond the gv_stashpv that $hv->objix already ensures.
	my @@contents = $hv->ARRAY;
	my ($i, @@ixes);
	for ($i = 1; $i < @@contents; $i += 2) {
	    push(@@ixes, $contents[$i]->objix);
	}
	for ($i = 1; $i < @@contents; $i += 2) {
	    $contents[$i]->bytecode;
	}
	ldsv($ix);
	for ($i = 0; $i < @@contents; $i += 2) {
	    printf("newpv %s\nhv_store %d\n",
		   pvstring($contents[$i]), $ixes[$i / 2]);
	}
	printf "sv_refcnt %d\nsv_flags 0x%x\n", $hv->REFCNT, $hv->FLAGS;
    }
}

sub B::AV::bytecode {
    my $av = shift;
    return if saved($av);
    my $ix = $av->objix;
    my $fill = $av->FILL;
    my $max = $av->MAX;
    my (@@array, @@ixes);
    if ($fill > -1) {
	@@array = $av->ARRAY;
	@@ixes = map($_->objix, @@array);
	my $sv;
	foreach $sv (@@array) {
	    $sv->bytecode;
	}
    }
    # See PVNV::bytecode for the meaning of the flag argument of 2.
    $av->B::PVMG::bytecode(2);
    # Recover sv register and set AvMAX and AvFILL to -1 (since we
    # create an AV with NEWSV and SvUPGRADE rather than doing newAV
    # which is what sets AvMAX and AvFILL.
    ldsv($ix);
    printf "xav_flags 0x%x\nxav_max -1\nxav_fill -1\n", $av->AvFLAGS;
    if ($fill > -1) {
	my $elix;
	foreach $elix (@@ixes) {
	    print "av_push $elix\n";
	}
    } else {
	if ($max > -1) {
	    print "av_extend $max\n";
	}
    }
}

sub B::CV::bytecode {
    my $cv = shift;
    return if saved($cv);
    my $ix = $cv->objix;
    $cv->B::PVMG::bytecode;
    my $i;
    my @@subfield_names = qw(ROOT START STASH GV FILEGV PADLIST OUTSIDE);
    my @@subfields = map($cv->$_(), @@subfield_names);
    my @@ixes = map($_->objix, @@subfields);
    # Save OP tree from CvROOT (first element of @@subfields)
    my $root = shift @@subfields;
    if ($$root) {
	walkoptree($root, "bytecode");
    }
    # Reset sv register for $cv (since above ->objix calls stomped on it)
    ldsv($ix);
    for ($i = 0; $i < @@ixes; $i++) {
	printf "xcv_%s %d\n", lc($subfield_names[$i]), $ixes[$i];
    }
    printf "xcv_depth %d\nxcv_flags 0x%x\n", $cv->DEPTH, $cv->FLAGS;
    # Now save all the subfields (except for CvROOT which was handled
    # above) and CvSTART (now the initial element of @@subfields).
    shift @@subfields; # bye-bye CvSTART
    my $sv;
    foreach $sv (@@subfields) {
	$sv->bytecode;
    }
}

sub B::IO::bytecode {
    my $io = shift;
    return if saved($io);
    my $ix = $io->objix;
    my $top_gv = $io->TOP_GV;
    my $top_gvix = $top_gv->objix;
    my $fmt_gv = $io->FMT_GV;
    my $fmt_gvix = $fmt_gv->objix;
    my $bottom_gv = $io->BOTTOM_GV;
    my $bottom_gvix = $bottom_gv->objix;

    $io->B::PVMG::bytecode;
    ldsv($ix);
    print "xio_top_gv $top_gvix\n";
    print "xio_fmt_gv $fmt_gvix\n";
    print "xio_bottom_gv $bottom_gvix\n";
    my $field;
    foreach $field (qw(TOP_NAME FMT_NAME BOTTOM_NAME)) {
	printf "newpv %s\nxio_%s\n", pvstring($io->$field()), lc($field);
    }
    foreach $field (qw(LINES PAGE PAGE_LEN LINES_LEFT SUBPROCESS)) {
	printf "xio_%s %d\n", lc($field), $io->$field();
    }
    printf "xio_type %s\nxio_flags 0x%x\n", cstring($io->IoTYPE), $io->IoFLAGS;
    $top_gv->bytecode;
    $fmt_gv->bytecode;
    $bottom_gv->bytecode;
}

sub B::SPECIAL::bytecode {
    # nothing extra needs doing
}

sub bytecompile_object {
    my $sv;
    foreach $sv (@@_) {
	svref_2object($sv)->bytecode;
    }
}

sub B::GV::bytecodecv {
    my $gv = shift;
    my $cv = $gv->CV;
    if ($$cv && !saved($cv)) {
	if ($debug_cv) {
	    warn sprintf("saving extra CV &%s::%s (0x%x) from GV 0x%x\n",
			 $gv->STASH->NAME, $gv->NAME, $$cv, $$gv);
	}
	$gv->bytecode;
    }
}

sub bytecompile_main {
    my $curpad = (comppadlist->ARRAY)[1];
    my $curpadix = $curpad->objix;
    $curpad->bytecode;
    walkoptree(main_root, "bytecode");
    warn "done main program, now walking symbol table\n" if $debug_bc;
    my ($pack, %exclude);
    foreach $pack (qw(B O AutoLoader DynaLoader Config DB VMS strict vars
		      FileHandle Exporter Carp UNIVERSAL IO Fcntl Symbol
		      SelectSaver blib Cwd))
    {
	$exclude{$pack."::"} = 1;
    }
    no strict qw(vars refs);
    walksymtable(\%{"main::"}, "bytecodecv", sub {
	warn "considering $_[0]\n" if $debug_bc;
	return !defined($exclude{$_[0]});
    });
    if (!$module_only) {
	printf "main_root %d\n", main_root->objix;
	printf "main_start %d\n", main_start->objix;
	printf "curpad $curpadix\n";
	# XXX Do min_intro_pending and max_intro_pending matter?
    }
}

sub prepare_assemble {
    my $newfh = IO::File->new_tmpfile;
    select($newfh);
    binmode $newfh;
    return $newfh;
}

sub do_assemble {
    my $fh = shift;
    seek($fh, 0, 0); # rewind the temporary file
    assemble_fh($fh, sub { print OUT @@_ });
}

sub compile {
    my @@options = @@_;
    my ($option, $opt, $arg);
    open(OUT, ">&STDOUT");
    binmode OUT;
    select(OUT);
  OPTION:
    while ($option = shift @@options) {
	if ($option =~ /^-(.)(.*)/) {
	    $opt = $1;
	    $arg = $2;
	} else {
	    unshift @@options, $option;
	    last OPTION;
	}
	if ($opt eq "-" && $arg eq "-") {
	    shift @@options;
	    last OPTION;
	} elsif ($opt eq "o") {
	    $arg ||= shift @@options;
	    open(OUT, ">$arg") or return "$arg: $!\n";
	    binmode OUT;
	} elsif ($opt eq "D") {
	    $arg ||= shift @@options;
	    foreach $arg (split(//, $arg)) {
		if ($arg eq "b") {
		    $| = 1;
		    debug(1);
		} elsif ($arg eq "o") {
		    B->debug(1);
		} elsif ($arg eq "a") {
		    B::Assembler::debug(1);
		} elsif ($arg eq "C") {
		    $debug_cv = 1;
		}
	    }
	} elsif ($opt eq "v") {
	    $verbose = 1;
	} elsif ($opt eq "m") {
	    $module_only = 1;
	} elsif ($opt eq "S") {
	    $no_assemble = 1;
	} elsif ($opt eq "f") {
	    $arg ||= shift @@options;
	    my $value = $arg !~ s/^no-//;
	    $arg =~ s/-/_/g;
	    my $ref = $optimise{$arg};
	    if (defined($ref)) {
		$$ref = $value;
	    } else {
		warn qq(ignoring unknown optimisation option "$arg"\n);
	    }
	} elsif ($opt eq "O") {
	    $arg = 1 if $arg eq "";
	    my $ref;
	    foreach $ref (values %optimise) {
		$$ref = 0;
	    }
	    if ($arg >= 6) {
		$strip_syntree = 1;
	    }
	    if ($arg >= 2) {
		$bypass_nullops = 1;
	    }
	    if ($arg >= 1) {
		$compress_nullops = 1;
		$omit_seq = 1;
	    }
	}
    }
    if (@@options) {
	return sub {
	    my $objname;
	    my $newfh; 
	    $newfh = prepare_assemble() unless $no_assemble;
	    foreach $objname (@@options) {
		eval "bytecompile_object(\\$objname)";
	    }
	    do_assemble($newfh) unless $no_assemble;
	}
    } else {
	return sub {
	    my $newfh; 
	    $newfh = prepare_assemble() unless $no_assemble;
	    bytecompile_main();
	    do_assemble($newfh) unless $no_assemble;
	}
    }
}

1;

__END__

=head1 NAME

B::Bytecode - Perl compiler's bytecode backend

=head1 SYNOPSIS

	perl -MO=Bytecode[,OPTIONS] foo.pl

=head1 DESCRIPTION

This compiler backend takes Perl source and generates a
platform-independent bytecode encapsulating code to load the
internal structures perl uses to run your program. When the
generated bytecode is loaded in, your program is ready to run,
reducing the time which perl would have taken to load and parse
your program into its internal semi-compiled form. That means that
compiling with this backend will not help improve the runtime
execution speed of your program but may improve the start-up time.
Depending on the environment in which your program runs this may
or may not be a help.

The resulting bytecode can be run with a special byteperl executable
or (for non-main programs) be loaded via the C<byteload_fh> function
in the F<B> module.

=head1 OPTIONS

If there are any non-option arguments, they are taken to be names of
objects to be saved (probably doesn't work properly yet).  Without
extra arguments, it saves the main program.

=over 4

=item B<-ofilename>

Output to filename instead of STDOUT.

=item B<-->

Force end of options.

=item B<-f>

Force optimisations on or off one at a time. Each can be preceded
by B<no-> to turn the option off (e.g. B<-fno-compress-nullops>).

=item B<-fcompress-nullops>

Only fills in the necessary fields of ops which have
been optimised away by perl's internal compiler.

=item B<-fomit-sequence-numbers>

Leaves out code to fill in the op_seq field of all ops
which is only used by perl's internal compiler.

=item B<-fbypass-nullops>

If op->op_next ever points to a NULLOP, replaces the op_next field
with the first non-NULLOP in the path of execution.

=item B<-fstrip-syntax-tree>

Leaves out code to fill in the pointers which link the internal syntax
tree together. They're not needed at run-time but leaving them out
will make it impossible to recompile or disassemble the resulting
program.  It will also stop C<goto label> statements from working.

=item B<-On>

Optimisation level (n = 0, 1, 2, ...). B<-O> means B<-O1>.
B<-O1> sets B<-fcompress-nullops> B<-fomit-sequence numbers>.
B<-O6> adds B<-fstrip-syntax-tree>.

=item B<-D>

Debug options (concatenated or separate flags like C<perl -D>).

=item B<-Do>

Prints each OP as it's processed.

=item B<-Db>

Print debugging information about bytecompiler progress.

=item B<-Da>

Tells the (bytecode) assembler to include source assembler lines
in its output as bytecode comments.

=item B<-DC>

Prints each CV taken from the final symbol tree walk.

=item B<-S>

Output (bytecode) assembler source rather than piping it
through the assembler and outputting bytecode.

=item B<-m>

Compile as a module rather than a standalone program. Currently this
just means that the bytecodes for initialising C<main_start>,
C<main_root> and C<curpad> are omitted.

=back

=head1 EXAMPLES

        perl -MO=Bytecode,-O6,-o,foo.plc foo.pl

        perl -MO=Bytecode,-S foo.pl > foo.S
        assemble foo.S > foo.plc
        byteperl foo.plc

        perl -MO=Bytecode,-m,-oFoo.pmc Foo.pm

=head1 BUGS

Plenty. Current status: experimental.

=head1 AUTHOR

Malcolm Beattie, C<mbeattie@@sable.ox.ac.uk>

=cut
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d14 1
a14 3
	 class peekop walkoptree svref_2object cstring walksymtable
	 SVf_POK SVp_POK SVf_IOK SVp_IOK
	);
d26 1
a26 1
sub POK () { SVf_POK|SVp_POK }
d28 1
a28 1
# Following is SVf_IOK|SVp_IOK
d30 1
a30 1
sub IOK () { SVf_IOK|SVp_IOK }
d194 1
a194 1
    printf "op_type %s\t# %d\n", "pp_" . $op->name, $type;
d227 1
a227 1
sub B::PADOP::bytecode {
d229 2
a230 1
    my $padix = $op->padix;
d232 2
a233 1
    print "op_padix $padix\n";
d244 1
a244 1
    if ($op->name eq "trans") {
d261 8
d289 4
a292 2
    my $stashpv = $op->stashpv;
    my $file = $op->file;
a293 2
    my $warnings = $op->warnings;
    my $warningsix = $warnings->objix;
d295 1
a295 1
	printf "# line %s:%d\n", $file, $line;
d298 1
a298 1
    printf <<"EOT", pvstring($op->label), pvstring($stashpv), $op->cop_seq, pvstring($file), $op->arybase;
d301 1
a301 2
newpv %s
cop_stashpv
d303 1
a303 2
newpv %s
cop_file
a305 1
cop_warnings $warningsix
d307 2
d316 1
a316 1
    my $opname = $op->name;
d324 1
a324 1
	if ($opname eq "pushre") {
d331 1
a331 1
    if ($opname eq "pushre") {
d398 1
a398 2
    my $sv = shift;
    my $flag = shift || 0;
d472 4
d477 1
a477 1
    printf <<"EOT", $gv->FLAGS, $gv->GvFLAGS;
d480 1
a483 10
    return if $gv->is_empty;
    printf <<"EOT", $gv->LINE, pvstring($gv->FILE);
gp_line %d
newpv %s
gp_file
EOT
    my $gvname = $gv->NAME;
    my $name = cstring($gv->STASH->NAME . "::" . $gvname);
    my $egv = $gv->EGV;
    my $egvix = $egv->objix;
d491 1
a491 1
	    my @@subfield_names = qw(SV AV HV CV FORM IO);
d574 1
a574 1
    my @@subfield_names = qw(ROOT START STASH GV PADLIST OUTSIDE);
d587 1
a587 2
    printf "xcv_depth %d\nxcv_flags 0x%x\n", $cv->DEPTH, $cv->CvFLAGS;
    printf "newpv %s\nxcv_file\n", pvstring($cv->FILE);
d656 1
a656 1
    foreach $pack (qw(B O AutoLoader DynaLoader XSLoader Config DB VMS strict vars
a709 4
	} elsif ($opt eq "a") {
	    $arg ||= shift @@options;
	    open(OUT, ">>$arg") or return "$arg: $!\n";
	    binmode OUT;
a818 4
=item B<-afilename>

Append output to filename.

d892 1
a892 4
    perl -MO=Bytecode,-O6,-o,foo.plc foo.pl

    perl -MO=Bytecode,-S foo.pl > foo.S
    assemble foo.S > foo.plc
d894 3
a896 3
Note that C<assemble> lives in the C<B> subdirectory of your perl
library directory. The utility called perlcc may also be used to 
help make use of this compiler.
d898 1
a898 1
    perl -MO=Bytecode,-m,-oFoo.pmc Foo.pm
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@a8 1

d11 3
a13 1
use B qw(main_cv main_root main_start comppadlist
d15 1
a15 4
	 init_av begin_av end_av
	 SVf_POK SVp_POK SVf_IOK SVp_IOK SVf_NOK SVp_NOK
	 SVf_READONLY GVf_IMPORTED_AV GVf_IMPORTED_CV GVf_IMPORTED_HV
	 GVf_IMPORTED_SV SVTYPEMASK
d18 1
a18 1
use B::Assembler qw(newasm endasm assemble);
d34 2
a35 29
# Following is SVf_NOK|SVp_NOK
# XXX Shouldn't be hardwired
sub NOK () { SVf_NOK|SVp_NOK }

# nonexistant flags (see B::GV::bytecode for usage)
sub GVf_IMPORTED_IO () { 0; }
sub GVf_IMPORTED_FORM () { 0; }

my ($verbose, $no_assemble, $debug_bc, $debug_cv);
my @@packages;	# list of packages to compile

sub asm (@@) {	# print replacement that knows about assembling
    if ($no_assemble) {
	print @@_;
    } else {
	my $buf = join '', @@_;
	assemble($_) for (split /\n/, $buf);
    }
}

sub asmf (@@) {	# printf replacement that knows about assembling
    if ($no_assemble) {
	printf shift(), @@_;
    } else {
	my $format = shift;
	my $buf = sprintf $format, @@_;
	assemble($_) for (split /\n/, $buf);
    }
}
d40 3
a42 2
my ($compress_nullops, $omit_seq, $bypass_nullops);
my %optimise = (compress_nullops	=> \$compress_nullops,
a45 4
my $strip_syntree;	# this is left here in case stripping the
			# syntree ever becomes safe again
			#	-- BKS, June 2000

a48 1

a52 3
my %strtable;	# maps shared strings to object indices
		# Filled in at allocation (pvix) time

a55 1

d61 1
a61 1
	asm "ldsv $ix\n";
d68 1
a68 1
    asm "stsv $ix\n";
d79 1
a79 1
	asm "ldop $ix\n";
d86 1
a86 1
    asm "stop $ix\n";
a102 8
sub nv {
    # print full precision
    my $str = sprintf "%.40f", $_[0];
    $str =~ s/0+$//;		# remove trailing zeros
    $str =~ s/\.$/.0/;
    return $str;
}

a108 9
sub pvix {	# save a shared PV (mainly for COPs)
    return $strtable{$_[0]} if defined($strtable{$_[0]});
    asmf "newpv %s\n", pvstring($_[0]);
    my $ix = $nextix++;
    $strtable{$_[0]} = $ix;
    asmf "stpv %d\n", $ix;
    return $ix;
}

d132 1
a132 1
    asmf "newsv %d\t# %s\n", $sv->FLAGS & SVTYPEMASK, class($sv);
d140 1
a140 1
    asm "gv_fetchpv $name\n";
d149 1
a149 1
	asmf "gv_stashpv %s\n", cstring($name);
d161 1
a161 1
    asmf "ldspecsv $$sv\t# %s\n", $specialsv_name[$$sv];
d169 2
a170 2
    croak("OP::newix: can't understand class $class") unless defined($typenum);
    asm "newop $typenum\t# $class\n";
d183 1
a183 1
    my $sibix = $op->sibling->objix unless $strip_syntree;
d192 1
a192 1
    asmf "# %s\n", peekop($op) if $debug_bc;
d194 4
a197 4
    asm "op_next $nextix\n";
    asm "op_sibling $sibix\n" unless $strip_syntree;
    asmf "op_type %s\t# %d\n", "pp_" . $op->name, $type;
    asmf("op_seq %d\n", $op->seq) unless $omit_seq;
d199 1
a199 1
	asmf "op_targ %d\nop_flags 0x%x\nop_private 0x%x\n",
d206 1
a206 1
    my $firstix = $op->first->objix unless $strip_syntree;
d209 1
a209 1
	asm "op_first $firstix\n";
d217 1
a217 1
    asm "op_other $otherix\n";
d225 1
a225 1
    asm "op_sv $svix\n";
d233 1
a233 1
    asm "op_padix $padix\n";
d246 1
a246 1
	asm "op_pv_tr ", join(",", @@shorts), "\n";
d248 1
a248 1
	asmf "newpv %s\nop_pv\n", pvstring($pv);
d254 1
a254 1
    my $lastix = $op->last->objix unless $strip_syntree;
d257 10
a266 1
	asm "op_last $lastix\n";
d276 1
a276 1
    asm "op_redoop $redoopix\nop_nextop $nextopix\nop_lastop $lastopix\n";
d281 1
a283 4
    if ($debug_bc) { # do this early to aid debugging
	asmf "# line %s:%d\n", $file, $line;
    }
    my $stashpv = $op->stashpv;
d286 3
a288 4
    my $labelix = pvix($op->label);
    my $stashix = pvix($stashpv);
    my $fileix = pvix($file);
    $warnings->bytecode;
d290 5
a294 3
    asmf <<"EOT", $labelix, $stashix, $op->cop_seq, $fileix, $op->arybase;
cop_label %d
cop_stashpv %d
d296 2
a297 1
cop_file %d
d325 1
a325 1
	asmf "op_pmreplrootgv $replrootix\n";
d327 1
a327 1
	asm "op_pmreplroot $replrootix\nop_pmreplstart $replstartix\n";
d331 1
a331 1
    asmf <<"EOT", $op->pmflags, $op->pmpermflags;
d346 1
a346 1
    asm "sv_refcnt $refcnt\nsv_flags $flags\n";
d354 1
a354 1
    asmf("newpv %s\nxpv\n", pvstring($sv->PV)) if $sv->FLAGS & POK;
d362 1
a362 1
    asmf "%s $iv\n", $sv->needs64bits ? "xiv64" : "xiv32" if $sv->FLAGS & IOK; # could be PVNV
d369 1
a369 1
    asmf "xnv %s\n", nv($sv->NVX);
d379 1
a379 1
    asm "xrv $rvix\n";
d387 1
a387 1
    asmf "%s $iv\n", $sv->needs64bits ? "xiv64" : "xiv32";
d407 1
a407 1
	asmf "xnv %s\n", nv($sv->NVX);
d410 1
a410 1
	    asmf "newpv %s\npv_cur %d\nxpv\n", pvstring($pv),length($pv)-257;
d412 1
a412 1
	    asmf("newpv %s\nxpv\n", pvstring($pv)) if $sv->FLAGS & POK;
d434 1
a434 1
    asm "xmg_stash $stashix\n";
d436 1
a436 1
	asmf "sv_magic %s\nmg_obj %d\nnewpv %s\nmg_pv\n",
d445 1
a445 1
    asmf <<'EOT', $sv->TARGOFF, $sv->TARGLEN, cstring($sv->TYPE);
d457 1
a457 1
    asmf "xbm_useful %d\nxbm_previous %d\nxbm_rare %d\n",
a460 12
sub empty_gv {	# is a GV empty except for imported stuff?
    my $gv = shift;

    return 0 if ($gv->SV->FLAGS & SVTYPEMASK);	# sv not SVt_NULL
    my @@subfield_names = qw(AV HV CV FORM IO);
    @@subfield_names = grep {;
				no strict 'refs';
				!($gv->GvFLAGS & ${\"GVf_IMPORTED_$_"}->()) && ${$gv->$_()};
			} @@subfield_names;
    return scalar @@subfield_names;
}

a463 2
    return unless grep { $_ eq $gv->STASH->NAME; } @@packages;
    return if $gv->NAME =~ m/^\(/;	# ignore overloads - they'll be rebuilt
d467 1
a467 1
    asmf <<"EOT", $gv->FLAGS, $gv->GvFLAGS;
d472 1
a472 1
    asmf("sv_refcnt_add %d\n", $refcnt - 1) if $refcnt > 1;
d474 1
a474 1
    asmf <<"EOT", $gv->LINE, pvix($gv->FILE);
d476 2
a477 1
gp_file %d
d484 1
a484 1
    asmf("gp_refcnt_add %d\n", $gvrefcnt - 1) if $gvrefcnt > 1;
d486 1
a486 1
	asm "gp_share $egvix\n";
a490 4
	    @@subfield_names = grep {;
					no strict 'refs';
					!($gv->GvFLAGS & ${\"GVf_IMPORTED_$_"}->());
				} @@subfield_names;
d496 1
a496 1
		asmf "gp_%s %d\n", lc($subfield_names[$i]), $ixes[$i];
d526 1
a526 1
	    asmf("newpv %s\nhv_store %d\n",
d529 1
a529 1
	asmf "sv_refcnt %d\nsv_flags 0x%x\n", $hv->REFCNT, $hv->FLAGS;
d554 1
a554 2
    asmf "sv_flags 0x%x\n", $av->FLAGS & ~SVf_READONLY; # SvREADONLY_off($av) in case PADCONST
    asmf "xav_flags 0x%x\nxav_max -1\nxav_fill -1\n", $av->AvFLAGS;
d558 1
a558 1
	    asm "av_push $elix\n";
d562 1
a562 1
	    asm "av_extend $max\n";
a564 1
    asmf "sv_flags 0x%x\n", $av->FLAGS; # restore flags from above
a569 2
    return if ${$cv->GV} && ($cv->GV->GvFLAGS & GVf_IMPORTED_CV);
    my $fileix = pvix($cv->FILE);
d584 1
a584 1
	asmf "xcv_%s %d\n", lc($subfield_names[$i]), $ixes[$i];
d586 2
a587 2
    asmf "xcv_depth %d\nxcv_flags 0x%x\n", $cv->DEPTH, $cv->CvFLAGS;
    asmf "xcv_file %d\n", $fileix;
d610 3
a612 3
    asm "xio_top_gv $top_gvix\n";
    asm "xio_fmt_gv $fmt_gvix\n";
    asm "xio_bottom_gv $bottom_gvix\n";
d615 1
a615 1
	asmf "newpv %s\nxio_%s\n", pvstring($io->$field()), lc($field);
d618 1
a618 1
	asmf "xio_%s %d\n", lc($field), $io->$field();
d620 1
a620 1
    asmf "xio_type %s\nxio_flags 0x%x\n", cstring($io->IoTYPE), $io->IoFLAGS;
d631 2
a632 1
    for my $sv (@@_) {
d640 1
a640 1
    if ($$cv && !saved($cv) && !($gv->FLAGS & GVf_IMPORTED_CV)) {
a648 43
sub save_call_queues {
    if (begin_av()->isa("B::AV")) {	# this is just to save 'use Foo;' calls
	for my $cv (begin_av()->ARRAY) {
	    next unless grep { $_ eq $cv->STASH->NAME; } @@packages;
	    my $op = $cv->START;
OPLOOP:
	    while ($$op) {
	 	if ($op->name eq 'require') { # save any BEGIN that does a require
		    $cv->bytecode;
		    asmf "push_begin %d\n", $cv->objix;
		    last OPLOOP;
		}
		$op = $op->next;
	    }
	}
    }
    if (init_av()->isa("B::AV")) {
	for my $cv (init_av()->ARRAY) {
	    next unless grep { $_ eq $cv->STASH->NAME; } @@packages;
	    $cv->bytecode;
	    asmf "push_init %d\n", $cv->objix;
	}
    }
    if (end_av()->isa("B::AV")) {
	for my $cv (end_av()->ARRAY) {
	    next unless grep { $_ eq $cv->STASH->NAME; } @@packages;
	    $cv->bytecode;
	    asmf "push_end %d\n", $cv->objix;
	}
    }
}

sub symwalk {
    no strict 'refs';
    my $ok = 1 if grep { (my $name = $_[0]) =~ s/::$//; $_ eq $name;} @@packages;
    if (grep { /^$_[0]/; } @@packages) {
	walksymtable(\%{"$_[0]"}, "bytecodecv", \&symwalk, $_[0]);
    }
    warn "considering $_[0] ... " . ($ok ? "accepted\n" : "rejected\n")
	if $debug_bc;
    $ok;
}

d653 1
a653 2
    save_call_queues();
    walkoptree(main_root, "bytecode") unless ref(main_root) eq "B::NULL";
d655 17
a671 5
    if (@@packages) {
	no strict qw(refs);
	walksymtable(\%{"main::"}, "bytecodecv", \&symwalk);
    } else {
	die "No packages requested for compilation!\n";
d673 13
a685 4
    asmf "main_root %d\n", main_root->objix;
    asmf "main_start %d\n", main_start->objix;
    asmf "curpad $curpadix\n";
    # XXX Do min_intro_pending and max_intro_pending matter?
d693 1
a693 1
    select OUT;
d730 2
d750 3
a759 5
	} elsif ($opt eq "u") {
	    $arg ||= shift @@options;
	    push @@packages, $arg;
	} else {
	    warn qq(ignoring unknown option "$opt$arg"\n);
a761 4
    if (! @@packages) {
	warn "No package specified for compilation, assuming main::\n";
	@@packages = qw(main);
    }
d763 9
a771 1
	die "Extraneous options left on B::Bytecode commandline: @@options\n";
d773 3
a775 2
	return sub { 
	    newasm(\&apr) unless $no_assemble;
d777 2
a778 2
	    endasm() unless $no_assemble;
	};
a781 2
sub apr { print @@_; }

d851 7
d862 1
a862 1
B<-O2> adds B<-fbypass-nullops>.
d890 6
a895 4
=item B<-upackage>
  
Stores package in the output.
  
d900 1
a900 1
    perl -MO=Bytecode,-O6,-ofoo.plc,-umain foo.pl
d902 1
a902 1
    perl -MO=Bytecode,-S,-umain foo.pl > foo.S
d909 1
a909 1
    perl -MO=Bytecode,-uFoo,-oFoo.pmc Foo.pm
d913 1
a913 2
Output is still huge and there are still occasional crashes during
either compilation or ByteLoading. Current status: experimental.
d915 1
a915 1
=head1 AUTHORS
a917 1
Benjamin Stuhl, C<sho_pi@@hotmail.com>
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a9 2
our $VERSION = '1.00';

d970 1
a970 1

d972 1
a972 1

@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d1 7
a7 7
# B::Bytecode.pm
# Copyright (c) 2003 Enache Adrian. All rights reserved.
# This module is free software; you can redistribute and/or modify
# it under the same terms as Perl itself.

# Based on the original Bytecode.pm module written by Malcolm Beattie.

d10 1
a10 1
our $VERSION = '1.01';
d13 53
a65 25
use Config;
use B qw(class main_cv main_root main_start cstring comppadlist
	defstash curstash begin_av init_av end_av inc_gv warnhook diehook
	dowarn SVt_PVGV SVt_PVHV OPf_SPECIAL OPf_STACKED OPf_MOD
	OPpLVAL_INTRO SVf_FAKE SVf_READONLY);
use B::Asmdata qw(@@specialsv_name);
use B::Assembler qw(asm newasm endasm);

#################################################

my ($varix, $opix, $savebegins, %walked, %files, @@cloop);
my %strtab = (0,0);
my %svtab = (0,0);
my %optab = (0,0);
my %spectab = (0,0);
my $tix = 1;
sub asm;
sub nice ($) { }

BEGIN {
    my $ithreads = $Config{'useithreads'} eq 'define';
    eval qq{
	sub ITHREADS() { $ithreads }
	sub VERSION() { $] }
    }; die $@@ if $@@;
d68 15
a82 1
#################################################
d84 19
a102 3
sub pvstring {
    my $pv = shift;
    defined($pv) ? cstring ($pv."\0") : "\"\"";
d105 4
a108 8
sub pvix {
    my $str = pvstring shift;
    my $ix = $strtab{$str};
    defined($ix) ? $ix : do {
	asm "newpv", $str;
	asm "stpv", $strtab{$str} = $tix;
	$tix++;
    }
d111 2
a112 10
sub B::OP::ix {
    my $op = shift;
    my $ix = $optab{$$op};
    defined($ix) ? $ix : do {
	nice "[".$op->name." $tix]";
	asm "newopx", $op->size | $op->type <<7;
	$optab{$$op} = $opix = $ix = $tix++;
	$op->bsave($ix);
	$ix;
    }
d115 5
a119 7
sub B::SPECIAL::ix {
    my $spec = shift;
    my $ix = $spectab{$$spec};
    defined($ix) ? $ix : do {
	nice '['.$specialsv_name[$$spec].']';
	asm "ldspecsvx", $$spec;
	$spectab{$$spec} = $varix = $tix++;
d123 4
a126 10
sub B::SV::ix {
    my $sv = shift;
    my $ix = $svtab{$$sv};
    defined($ix) ? $ix : do {
	nice '['.class($sv).']';
	asm "newsvx", $sv->FLAGS;
	$svtab{$$sv} = $varix = $ix = $tix++;
	$sv->bsave($ix);
	$ix;
    }
d129 2
a130 54
sub B::GV::ix {
    my ($gv,$desired) = @@_;
    my $ix = $svtab{$$gv};
    defined($ix) ? $ix : do {
	if ($gv->GP) {
	    my ($svix, $avix, $hvix, $cvix, $ioix, $formix);
	    nice "[GV]";
	    my $name = $gv->STASH->NAME . "::" . $gv->NAME;
	    asm "gv_fetchpvx", cstring $name;
	    $svtab{$$gv} = $varix = $ix = $tix++;
	    asm "sv_flags", $gv->FLAGS;
	    asm "sv_refcnt", $gv->REFCNT;
	    asm "xgv_flags", $gv->GvFLAGS;

	    asm "gp_refcnt", $gv->GvREFCNT;
	    asm "load_glob", $ix if $name eq "CORE::GLOBAL::glob";
	    return $ix
		    unless $desired || desired $gv;
	    $svix = $gv->SV->ix;
	    $avix = $gv->AV->ix;
	    $hvix = $gv->HV->ix;

    # XXX {{{{
	    my $cv = $gv->CV;
	    $cvix = $$cv && defined $files{$cv->FILE} ? $cv->ix : 0;
	    my $form = $gv->FORM;
	    $formix = $$form && defined $files{$form->FILE} ? $form->ix : 0;

	    $ioix = $name !~ /STDOUT$/ ? $gv->IO->ix : 0;	
							    # }}}} XXX

	    nice "-GV-",
	    asm "ldsv", $varix = $ix unless $ix == $varix;
	    asm "gp_sv", $svix;
	    asm "gp_av", $avix;
	    asm "gp_hv", $hvix;
	    asm "gp_cv", $cvix;
	    asm "gp_io", $ioix;
	    asm "gp_cvgen", $gv->CVGEN;
	    asm "gp_form", $formix;
	    asm "gp_file", pvix $gv->FILE;
	    asm "gp_line", $gv->LINE;
	    asm "formfeed", $svix if $name eq "main::\cL";
	} else {
	    nice "[GV]";
	    asm "newsvx", $gv->FLAGS;
	    $svtab{$$gv} = $varix = $ix = $tix++;
	    my $stashix = $gv->STASH->ix;
	    $gv->B::PVMG::bsave($ix);
	    asm "xgv_flags", $gv->GvFLAGS;
	    asm "xgv_stash", $stashix;
	}
	$ix;
    }
d133 6
a138 34
sub B::HV::ix {
    my $hv = shift;
    my $ix = $svtab{$$hv};
    defined($ix) ? $ix : do {
	my ($ix,$i,@@array);
	my $name = $hv->NAME;
	if ($name) {
	    nice "[STASH]";
	    asm "gv_stashpvx", cstring $name;
	    asm "sv_flags", $hv->FLAGS;
	    $svtab{$$hv} = $varix = $ix = $tix++;
	    asm "xhv_name", pvix $name;
	    # my $pmrootix = $hv->PMROOT->ix;	# XXX
	    asm "ldsv", $varix = $ix unless $ix == $varix;
	    # asm "xhv_pmroot", $pmrootix;	# XXX
	} else {
	    nice "[HV]";
	    asm "newsvx", $hv->FLAGS;
	    $svtab{$$hv} = $varix = $ix = $tix++;
	    my $stashix = $hv->SvSTASH->ix;
	    for (@@array = $hv->ARRAY) {
		next if $i = not $i;
		$_ = $_->ix;
	    }
	    nice "-HV-",
	    asm "ldsv", $varix = $ix unless $ix == $varix;
	    ($i = not $i) ? asm ("newpv", pvstring $_) : asm("hv_store", $_)
		for @@array;
	    asm "xnv", $hv->NVX;
	    asm "xmg_stash", $stashix;
	    asm "xhv_riter", $hv->RITER;
	}
	asm "sv_refcnt", $hv->REFCNT;
	$ix;
d142 6
a147 3
sub B::NULL::ix {
    my $sv = shift;
    $$sv ? $sv->B::SV::ix : 0;
d150 3
a152 1
sub B::NULL::opwalk { 0 }
d154 1
a154 1
#################################################
d156 7
a162 173
sub B::NULL::bsave {
    my ($sv,$ix) = @@_;

    nice '-'.class($sv).'-',
    asm "ldsv", $varix = $ix unless $ix == $varix;
    asm "sv_refcnt", $sv->REFCNT;
}

sub B::SV::bsave;
    *B::SV::bsave = *B::NULL::bsave;

sub B::RV::bsave {
    my ($sv,$ix) = @@_;
    my $rvix = $sv->RV->ix;
    $sv->B::NULL::bsave($ix);
    asm "xrv", $rvix;
}

sub B::PV::bsave {
    my ($sv,$ix) = @@_;
    $sv->B::NULL::bsave($ix);
    asm "newpv", pvstring $sv->PVBM;
    asm "xpv";
}

sub B::IV::bsave {
    my ($sv,$ix) = @@_;
    $sv->B::NULL::bsave($ix);
    asm "xiv", $sv->IVX;
}

sub B::NV::bsave {
    my ($sv,$ix) = @@_;
    $sv->B::NULL::bsave($ix);
    asm "xnv", sprintf "%.40g", $sv->NVX;
}

sub B::PVIV::bsave {
    my ($sv,$ix) = @@_;
    $sv->POK ?
	$sv->B::PV::bsave($ix):
    $sv->ROK ?
	$sv->B::RV::bsave($ix):
	$sv->B::NULL::bsave($ix);
    asm "xiv", !ITHREADS && $sv->FLAGS & (SVf_FAKE|SVf_READONLY) ?
	"0 but true" : $sv->IVX;
}

sub B::PVNV::bsave {
    my ($sv,$ix) = @@_;
    $sv->B::PVIV::bsave($ix);
    asm "xnv", sprintf "%.40g", $sv->NVX;
}

sub B::PVMG::domagic {
    my ($sv,$ix) = @@_;
    nice '-MAGICAL-';
    my @@mglist = $sv->MAGIC;
    my (@@mgix, @@namix);
    for (@@mglist) {
	push @@mgix, $_->OBJ->ix;
	push @@namix, $_->PTR->ix if $_->LENGTH == B::HEf_SVKEY;
    }

    nice '-'.class($sv).'-',
    asm "ldsv", $varix = $ix unless $ix == $varix;
    for (@@mglist) {
	asm "sv_magic", cstring $_->TYPE;
	asm "mg_obj", shift @@mgix;
	my $length = $_->LENGTH;
	if ($length == B::HEf_SVKEY) {
	    asm "mg_namex", shift @@namix;
	} elsif ($length) {
	    asm "newpv", pvstring $_->PTR;
	    asm "mg_name";
	}
    }
}

sub B::PVMG::bsave {
    my ($sv,$ix) = @@_;
    my $stashix = $sv->SvSTASH->ix;
    $sv->B::PVNV::bsave($ix);
    asm "xmg_stash", $stashix;
    $sv->domagic($ix) if $sv->MAGICAL;
}

sub B::PVLV::bsave {
    my ($sv,$ix) = @@_;
    my $targix = $sv->TARG->ix;
    $sv->B::PVMG::bsave($ix);
    asm "xlv_targ", $targix;
    asm "xlv_targoff", $sv->TARGOFF;
    asm "xlv_targlen", $sv->TARGLEN;
    asm "xlv_type", $sv->TYPE;

}

sub B::BM::bsave {
    my ($sv,$ix) = @@_;
    $sv->B::PVMG::bsave($ix);
    asm "xpv_cur", $sv->CUR;
    asm "xbm_useful", $sv->USEFUL;
    asm "xbm_previous", $sv->PREVIOUS;
    asm "xbm_rare", $sv->RARE;
}

sub B::IO::bsave {
    my ($io,$ix) = @@_;
    my $topix = $io->TOP_GV->ix;
    my $fmtix = $io->FMT_GV->ix;
    my $bottomix = $io->BOTTOM_GV->ix;
    $io->B::PVMG::bsave($ix);
    asm "xio_lines", $io->LINES;
    asm "xio_page", $io->PAGE;
    asm "xio_page_len", $io->PAGE_LEN;
    asm "xio_lines_left", $io->LINES_LEFT;
    asm "xio_top_name", pvix $io->TOP_NAME;
    asm "xio_top_gv", $topix;
    asm "xio_fmt_name", pvix $io->FMT_NAME;
    asm "xio_fmt_gv", $fmtix;
    asm "xio_bottom_name", pvix $io->BOTTOM_NAME;
    asm "xio_bottom_gv", $bottomix;
    asm "xio_subprocess", $io->SUBPROCESS;
    asm "xio_type", ord $io->IoTYPE;
    # asm "xio_flags", ord($io->IoFLAGS) & ~32;		# XXX XXX
}

sub B::CV::bsave {
    my ($cv,$ix) = @@_;
    my $stashix = $cv->STASH->ix;
    my $gvix = $cv->GV->ix;
    my $padlistix = $cv->PADLIST->ix;
    my $outsideix = $cv->OUTSIDE->ix;
    my $constix = $cv->CONST ? $cv->XSUBANY->ix : 0;
    my $startix = $cv->START->opwalk;
    my $rootix = $cv->ROOT->ix;

    $cv->B::PVMG::bsave($ix);
    asm "xcv_stash", $stashix;
    asm "xcv_start", $startix;
    asm "xcv_root", $rootix;
    asm "xcv_xsubany", $constix;
    asm "xcv_gv", $gvix;
    asm "xcv_file", pvix $cv->FILE if $cv->FILE;	# XXX AD
    asm "xcv_padlist", $padlistix;
    asm "xcv_outside", $outsideix;
    asm "xcv_flags", $cv->CvFLAGS;
    asm "xcv_outside_seq", $cv->OUTSIDE_SEQ;
    asm "xcv_depth", $cv->DEPTH;
}

sub B::FM::bsave {
    my ($form,$ix) = @@_;

    $form->B::CV::bsave($ix);
    asm "xfm_lines", $form->LINES;
}

sub B::AV::bsave {
    my ($av,$ix) = @@_;
    return $av->B::PVMG::bsave($ix) if $av->MAGICAL;
    my @@array = $av->ARRAY;
    $_ = $_->ix for @@array;
    my $stashix = $av->SvSTASH->ix;

    nice "-AV-",
    asm "ldsv", $varix = $ix unless $ix == $varix;
    asm "av_extend", $av->MAX if $av->MAX >= 0;
    asm "av_pushx", $_ for @@array;
    asm "sv_refcnt", $av->REFCNT;
    asm "xav_flags", $av->AvFLAGS;
    asm "xmg_stash", $stashix;
d165 4
a168 6
sub B::GV::desired {
    my $gv = shift;
    my ($cv, $form);
    $files{$gv->FILE} && $gv->LINE
    || ${$cv = $gv->CV} && $files{$cv->FILE}
    || ${$form = $gv->FORM} && $files{$form->FILE}
d171 12
a182 18
sub B::HV::bwalk {
    my $hv = shift;
    return if $walked{$$hv}++;
    my %stash = $hv->ARRAY;
    while (my($k,$v) = each %stash) {
	if ($v->SvTYPE == SVt_PVGV) {
	    my $hash = $v->HV;
	    if ($$hash && $hash->NAME) {
		$hash->bwalk;
	    } 
	    $v->ix(1) if desired $v;
	} else {
	    nice "[prototype]";
	    asm "gv_fetchpvx", cstring $hv->NAME . "::$k";
	    $svtab{$$v} = $varix = $tix;
	    $v->bsave($tix++);
	    asm "sv_flags", $v->FLAGS;
	}
d186 5
a190 1
######################################################
d192 7
d200 10
a209 8
sub B::OP::bsave_thin {
    my ($op, $ix) = @@_;
    my $next = $op->next;
    my $nextix = $optab{$$next};
    $nextix = 0, push @@cloop, $op unless defined $nextix;
    if ($ix != $opix) {
	nice '-'.$op->name.'-',
	asm "ldop", $opix = $ix;
a210 4
    asm "op_next", $nextix;
    asm "op_targ", $op->targ if $op->type;		# tricky
    asm "op_flags", $op->flags;
    asm "op_private", $op->private;
d213 7
a219 2
sub B::OP::bsave;
    *B::OP::bsave = *B::OP::bsave_thin;
d221 1
a221 1
sub B::UNOP::bsave {
d223 5
a227 17
    my $name = $op->name;
    my $flags = $op->flags;
    my $first = $op->first;
    my $firstix = 
	$name =~ /fl[io]p/
			# that's just neat
    ||	(!ITHREADS && $name eq 'regcomp')
			# trick for /$a/o in pp_regcomp
    ||	$name eq 'rv2sv'
	    && $op->flags & OPf_MOD	
	    && $op->private & OPpLVAL_INTRO
			# change #18774 made my life hard
    ?	$first->ix
    :	0;

    $op->B::OP::bsave($ix);
    asm "op_first", $firstix;
d230 3
a232 16
sub B::BINOP::bsave {
    my ($op, $ix) = @@_;
    if ($op->name eq 'aassign' && $op->private & B::OPpASSIGN_HASH()) {
	my $last = $op->last;
	my $lastix = do {
	    local *B::OP::bsave = *B::OP::bsave_fat;
	    local *B::UNOP::bsave = *B::UNOP::bsave_fat;
	    $last->ix;
	};
	asm "ldop", $lastix unless $lastix == $opix;
	asm "op_targ", $last->targ;
	$op->B::OP::bsave($ix);
	asm "op_last", $lastix;
    } else {
	$op->B::OP::bsave($ix);
    }
d235 7
a241 1
# not needed if no pseudohashes
d243 4
a246 1
*B::BINOP::bsave = *B::OP::bsave if VERSION >= 5.009;
d248 11
a258 1
# deal with sort / formline 
d260 8
a267 9
sub B::LISTOP::bsave {
    my ($op, $ix) = @@_;
    my $name = $op->name;
    sub blocksort() { OPf_SPECIAL|OPf_STACKED }
    if ($name eq 'sort' && ($op->flags & blocksort) == blocksort) {
	my $first = $op->first;
	my $pushmark = $first->sibling;
	my $rvgv = $pushmark->first;
	my $leave = $rvgv->first;
d269 6
a274 1
	my $leaveix = $leave->ix;
d276 8
a283 3
	my $rvgvix = $rvgv->ix;
	asm "ldop", $rvgvix unless $rvgvix == $opix;
	asm "op_first", $leaveix;
d285 6
a290 3
	my $pushmarkix = $pushmark->ix;
	asm "ldop", $pushmarkix unless $pushmarkix == $opix;
	asm "op_first", $rvgvix;
d292 11
a302 8
	my $firstix = $first->ix;
	asm "ldop", $firstix unless $firstix == $opix;
	asm "op_sibling", $pushmarkix;

	$op->B::OP::bsave($ix);
	asm "op_first", $firstix;
    } elsif ($name eq 'formline') {
	$op->B::UNOP::bsave_fat($ix);
d304 1
a304 1
	$op->B::OP::bsave($ix);
d308 8
a315 1
# fat versions
d317 8
a324 3
sub B::OP::bsave_fat {
    my ($op, $ix) = @@_;
    my $siblix = $op->sibling->ix;
d326 24
a349 3
    $op->B::OP::bsave_thin($ix);
    asm "op_sibling", $siblix;
    # asm "op_seq", -1;			XXX don't allocate OPs piece by piece
d352 34
a385 3
sub B::UNOP::bsave_fat {
    my ($op,$ix) = @@_;
    my $firstix = $op->first->ix;
d387 9
a395 2
    $op->B::OP::bsave($ix);
    asm "op_first", $firstix;
d398 6
a403 8
sub B::BINOP::bsave_fat {
    my ($op,$ix) = @@_;
    my $last = $op->last;
    my $lastix = $op->last->ix;
    if (VERSION < 5.009 && $op->name eq 'aassign' && $last->name eq 'null') {
	asm "ldop", $lastix unless $lastix == $opix;
	asm "op_targ", $last->targ;
    }
d405 6
a410 2
    $op->B::UNOP::bsave($ix);
    asm "op_last", $lastix;
d413 6
a418 3
sub B::LOGOP::bsave {
    my ($op,$ix) = @@_;
    my $otherix = $op->other->ix;
d420 8
a427 2
    $op->B::UNOP::bsave($ix);
    asm "op_other", $otherix;
d430 7
a436 3
sub B::PMOP::bsave {
    my ($op,$ix) = @@_;
    my ($rrop, $rrarg, $rstart);
d438 23
a460 10
    # my $pmnextix = $op->pmnext->ix;	# XXX

    if (ITHREADS) {
	if ($op->name eq 'subst') {
	    $rrop = "op_pmreplroot";
	    $rrarg = $op->pmreplroot->ix;
	    $rstart = $op->pmreplstart->ix;
	} elsif ($op->name eq 'pushre') {
	    $rrop = "op_pmreplrootpo";
	    $rrarg = $op->pmreplroot;
a461 9
	$op->B::BINOP::bsave($ix);
	asm "op_pmstashpv", pvix $op->pmstashpv;
    } else {
	$rrop = "op_pmreplrootgv";
	$rrarg = $op->pmreplroot->ix;
	$rstart = $op->pmreplstart->ix if $op->name eq 'subst';
	my $stashix = $op->pmstash->ix;
	$op->B::BINOP::bsave($ix);
	asm "op_pmstash", $stashix;
d463 1
d465 23
a487 2
    asm $rrop, $rrarg if $rrop;
    asm "op_pmreplstart", $rstart if $rstart;
d489 9
a497 6
    asm "op_pmflags", $op->pmflags;
    asm "op_pmpermflags", $op->pmpermflags;
    asm "op_pmdynflags", $op->pmdynflags;
    # asm "op_pmnext", $pmnextix;	# XXX
    asm "newpv", pvstring $op->precomp;
    asm "pregcomp";
d500 7
a506 6
sub B::SVOP::bsave {
    my ($op,$ix) = @@_;
    my $svix = $op->sv->ix;

    $op->B::OP::bsave($ix);
    asm "op_sv", $svix;
d509 2
a510 2
sub B::PADOP::bsave {
    my ($op,$ix) = @@_;
d512 7
a518 2
    $op->B::OP::bsave($ix);
    asm "op_padix", $op->padix;
d521 27
a547 7
sub B::PVOP::bsave {
    my ($op,$ix) = @@_;
    $op->B::OP::bsave($ix);
    return unless my $pv = $op->pv;

    if ($op->name eq 'trans') {
        asm "op_pv_tr", join ',', length($pv)/2, unpack("s*", $pv);
d549 20
a568 2
        asm "newpv", pvstring $pv;
        asm "op_pv";
d572 24
a595 10
sub B::LOOP::bsave {
    my ($op,$ix) = @@_;
    my $nextix = $op->nextop->ix;
    my $lastix = $op->lastop->ix;
    my $redoix = $op->redoop->ix;

    $op->B::BINOP::bsave($ix);
    asm "op_redoop", $redoix;
    asm "op_nextop", $nextix;
    asm "op_lastop", $lastix;
d598 28
a625 8
sub B::COP::bsave {
    my ($cop,$ix) = @@_;
    my $warnix = $cop->warnings->ix;
    my $ioix = $cop->io->ix;
    if (ITHREADS) {
	$cop->B::OP::bsave($ix);
	asm "cop_stashpv", pvix $cop->stashpv;
	asm "cop_file", pvix $cop->file;
d627 3
a629 5
    	my $stashix = $cop->stash->ix;
    	my $fileix = $cop->filegv->ix(1);
	$cop->B::OP::bsave($ix);
	asm "cop_stash", $stashix;
	asm "cop_filegv", $fileix;
d631 1
a631 6
    asm "cop_label", pvix $cop->label if $cop->label;	# XXX AD
    asm "cop_seq", $cop->cop_seq;
    asm "cop_arybase", $cop->arybase;
    asm "cop_line", $cop->line;
    asm "cop_warnings", $warnix;
    asm "cop_io", $ioix;
d634 68
a701 13
sub B::OP::opwalk {
    my $op = shift;
    my $ix = $optab{$$op};
    defined($ix) ? $ix : do {
	my $ix;
	my @@oplist = $op->oplist;
	push @@cloop, undef;
	$ix = $_->ix while $_ = pop @@oplist;
	while ($_ = pop @@cloop) {
	    asm "ldop", $optab{$$_};
	    asm "op_next", $optab{${$_->next}};
	}
	$ix;
d705 11
a715 1
#################################################
d717 11
a727 23
sub save_cq {
    my $av;
    if (($av=begin_av)->isa("B::AV")) {
	if ($savebegins) {
	    for ($av->ARRAY) {
		next unless $_->FILE eq $0;
		asm "push_begin", $_->ix;
	    }
	} else {
	    for ($av->ARRAY) {
		next unless $_->FILE eq $0;
		# XXX BEGIN { goto A while 1; A: }
		for (my $op = $_->START; $$op; $op = $op->next) {
		    next unless $op->name eq 'require' || 
			# this kludge needed for tests
			$op->name eq 'gv' && do {
			    my $gv = class($op) eq 'SVOP' ?
				$op->gv :
			    	(($_->PADLIST->ARRAY)[1]->ARRAY)[$op->padix];
			    $$gv && $gv->NAME =~ /use_ok|plan/
			};
		    asm "push_begin", $_->ix;
		    last;
d729 1
d733 12
a744 4
    if (($av=init_av)->isa("B::AV")) {
	for ($av->ARRAY) {
	    next unless $_->FILE eq $0;
	    asm "push_init", $_->ix;
d747 25
a771 5
    if (($av=end_av)->isa("B::AV")) {
	for ($av->ARRAY) {
	    next unless $_->FILE eq $0;
	    asm "push_end", $_->ix;
	}
d773 4
d780 10
a789 36
    my ($head, $scan, $T_inhinc, $keep_syn);
    my $cwd = '';
    $files{$0} = 1;
    sub keep_syn {
	$keep_syn = 1;
	*B::OP::bsave = *B::OP::bsave_fat;
	*B::UNOP::bsave = *B::UNOP::bsave_fat;
	*B::BINOP::bsave = *B::BINOP::bsave_fat;
	*B::LISTOP::bsave = *B::LISTOP::bsave_fat;
    }
    sub bwarn { print STDERR "Bytecode.pm: @@_\n" }

    for (@@_) {
	if (/^-S/) {
	    *newasm = *endasm = sub { };
	    *asm = sub { print "    @@_\n" };
	    *nice = sub ($) { print "\n@@_\n" };
	} elsif (/^-H/) {
	    require ByteLoader;
	    $head = "#! $^X\nuse ByteLoader $ByteLoader::VERSION;\n";
	} elsif (/^-k/) {
	    keep_syn;
	} elsif (/^-o(.*)$/) {
	    open STDOUT, ">$1" or die "open $1: $!";
	} elsif (/^-f(.*)$/) {
	    $files{$1} = 1;
	} elsif (/^-s(.*)$/) {
	    $scan = length($1) ? $1 : $0;
	} elsif (/^-b/) {
	    $savebegins = 1;
    # this is here for the testsuite
	} elsif (/^-TI/) {
	    $T_inhinc = 1;
	} elsif (/^-TF(.*)/) {
	    my $thatfile = $1;
	    *B::COP::file = sub { $thatfile };
d791 2
a792 1
	    bwarn "Ignoring '$_' option";
d794 23
a816 10
    }
    if ($scan) {
	my $f;
	if (open $f, $scan) {
	    while (<$f>) {
		/^#\s*line\s+\d+\s+("?)(.*)\1/ and $files{$2} = 1;
		/^#/ and next;
		if (/\bgoto\b\s*[^&]/ && !$keep_syn) {
		    bwarn "keeping the syntax tree: \"goto\" op found";
		    keep_syn;
d819 30
d850 1
a850 1
	    bwarn "cannot rescan '$scan'";
a851 1
	close $f;
d853 12
a864 32
    binmode STDOUT;
    return sub {
	print $head if $head;
	newasm sub { print @@_ };

	defstash->bwalk;
	asm "main_start", main_start->opwalk;
	asm "main_root", main_root->ix;
	asm "main_cv", main_cv->ix;
	asm "curpad", (comppadlist->ARRAY)[1]->ix;

	asm "signal", cstring "__WARN__"		# XXX
	    if warnhook->ix;
	asm "incav", inc_gv->AV->ix if $T_inhinc;
	save_cq;
	asm "incav", inc_gv->AV->ix if $T_inhinc;
	asm "dowarn", dowarn;

	{
	    no strict 'refs';
	    nice "<DATA>";
	    my $dh = *{defstash->NAME."::DATA"};
	    unless (eof $dh) {
		local undef $/;
		asm "data", ord 'D';
		print <$dh>;
	    } else {
		asm "ret";
	    }
	}

	endasm;
d868 2
d872 2
d880 1
a880 1
B<perl -MO=Bytecode>[B<,-H>][B<,-o>I<script.plc>] I<script.pl>
d884 14
a897 2
Compiles a Perl script into a bytecode format that could be loaded
later by the ByteLoader module and executed as a regular Perl script.
d899 19
a917 1
=head1 EXAMPLE
d919 1
a919 3
    $ perl -MO=Bytecode,-H,-ohi -e 'print "hi!\n"'
    $ perl hi
    hi!
d921 2
a922 1
=head1 OPTIONS
d924 1
a924 1
=over 4
d926 2
a927 1
=item B<-b>
d929 1
a929 2
Save all the BEGIN blocks. Normally only BEGIN blocks that C<require>
other files (ex. C<use Foo;>) are saved.
d931 2
a932 1
=item B<-H>
d934 1
a934 1
prepend a C<use ByteLoader VERSION;> line to the produced bytecode.
d936 2
a937 1
=item B<-k>
d939 1
a939 1
keep the syntax tree - it is stripped by default.
d941 3
a943 1
=item B<-o>I<outfile>
d945 1
a945 1
put the bytecode in <outfile> instead of dumping it to STDOUT.
d947 1
a947 1
=item B<-s>
d949 1
a949 2
scan the script for C<# line ..> directives and for <goto LABEL>
expressions. When gotos are found keep the syntax tree.
d951 1
a951 1
=back
d953 1
a953 1
=head1 KNOWN BUGS
d955 1
a955 1
=over 4
d957 1
a957 1
=item *
d959 2
a960 1
C<BEGIN { goto A: while 1; A: }> won't even compile.
d962 1
a962 1
=item *
d964 1
a964 1
C<?...?> and C<reset> do not work as expected.
d966 1
a966 1
=item *
d968 2
a969 1
variables in C<(?{ ... })> constructs are not properly scoped.
d971 1
a971 1
=item *
d973 1
a973 1
scripts that use source filters will fail miserably. 
d977 3
a979 1
=head1 NOTICE
d981 2
a982 1
There are also undocumented bugs and options.
d984 10
a993 1
THIS CODE IS HIGHLY EXPERIMENTAL. USE AT YOUR OWN RISK.
d997 2
a998 4
Originally written by Malcolm Beattie <mbeattie@@sable.ox.ac.uk> and
modified by Benjamin Stuhl <sho_pi@@hotmail.com>.

Rewritten by Enache Adrian <enache@@rdslink.ro>, 2003 a.d.
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d10 1
a10 1
our $VERSION = '1.01_01';
d175 1
a175 3
	    if (VERSION < 5.009) {
		asm "xnv", $hv->NVX;
	    }
a236 5
    if (VERSION >= 5.009) {
	# See note below in B::PVNV::bsave
	return if $sv->isa('B::AV');
	return if $sv->isa('B::HV');
    }
a243 9
    if (VERSION >= 5.009) {
	# Magical AVs end up here, but AVs now don't have an NV slot actually
	# allocated. Hence don't write out assembly to store the NV slot if
	# we're actually an array.
	return if $sv->isa('B::AV');
	# Likewise HVs have no NV slot actually allocated.
	# I don't think that they can get here, but better safe than sorry
	return if $sv->isa('B::HV');
    }
d364 1
a364 3
    if (VERSION < 5.009) {
	asm "xav_flags", $av->AvFLAGS;
    }
@


