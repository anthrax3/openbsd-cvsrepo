head	1.1;
branch	1.1.1;
access;
symbols
	PERL_5_24_2:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.52
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.50
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.44
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.46
	OPENBSD_5_8_BASE:1.1.1.1
	PERL_5_20_2:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.38
	OPENBSD_5_7_BASE:1.1.1.1
	PERL_5_20_1:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.42
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.40
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.36
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.34
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.32
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.30
	OPENBSD_5_0:1.1.1.1.0.28
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.26
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.24
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.20
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.22
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.18
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.16
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.14
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.12
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.10
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.8
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.6
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.4
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.2
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!perl
#examples poached from perldoc -f sort

# sort lexically
@@articles = sort @@files;

# same thing, but with explicit sort routine
@@articles = sort {$a cmp $b} @@files;

# now case-insensitively
@@articles = sort {uc($a) cmp uc($b)} @@files;

# same thing in reversed order
@@articles = sort {$b cmp $a} @@files;

# sort numerically ascending
@@articles = sort {$a <=> $b} @@files;

# sort numerically descending
@@articles = sort {$b <=> $a} @@files;

# this sorts the %age hash by value instead of key
# using an in-line function
@@eldest = sort { $age{$b} <=> $age{$a} } keys %age;

# sort using explicit subroutine name
sub byage {
    $age{$a} <=> $age{$b};  # presuming numeric
}
@@sortedclass = sort byage @@class;

sub backwards { $b cmp $a }
@@harry  = qw(dog cat x Cain Abel);
@@george = qw(gone chased yz Punished Axed);
print sort @@harry;
# prints AbelCaincatdogx
print sort backwards @@harry;
# prints xdogcatCainAbel
print sort @@george, 'to', @@harry;
# prints AbelAxedCainPunishedcatchaseddoggonetoxyz

# inefficiently sort by descending numeric compare using
# the first integer after the first = sign, or the
# whole record case-insensitively otherwise
@@new = @@old[ sort {
    $nums[$b] <=> $nums[$a]
	|| $caps[$a] cmp $caps[$b]
	} 0..$#old  ];

# same thing, but without any temps
@@new = map { $_->[0] }
sort { $b->[1] <=> $a->[1] 
	   || $a->[2] cmp $b->[2]
	   } map { [$_, /=(\d+)/, uc($_)] } @@old;

# using a prototype allows you to use any comparison subroutine
# as a sort subroutine (including other package's subroutines)
package other;
sub backwards ($$) { $_[1] cmp $_[0]; }     # $a and $b are not set here
package main;
@@new = sort other::backwards @@old;

# repeat, condensed. $main::a and $b are unaffected
sub other::backwards ($$) { $_[1] cmp $_[0]; }
@@new = sort other::backwards @@old;

# guarantee stability, regardless of algorithm
use sort 'stable';
@@new = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @@old;

# force use of mergesort (not portable outside Perl 5.8)
use sort '_mergesort';
@@new = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @@old;

# you should have a good reason to do this!
@@articles = sort {$FooPack::b <=> $FooPack::a} @@files;

# fancy
@@result = sort { $a <=> $b } grep { $_ == $_ } @@input;

# void return context sort
sort { $a <=> $b } @@input;

# more void context, propagating ?
sort { $a <=> $b } grep { $_ == $_ } @@input;

# scalar return context sort
$s = sort { $a <=> $b } @@input;

$s = sort { $a <=> $b } grep { $_ == $_ } @@input;

@


1.1.1.1
log
@perl 5.8.6 from CPAN
@
text
@@
