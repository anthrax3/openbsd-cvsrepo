head	1.2;
access;
symbols
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.5.0.10
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.4
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.6
	OPENBSD_5_8_BASE:1.1.1.5
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.2
	OPENBSD_5_7_BASE:1.1.1.5
	PERL_5_20_1:1.1.1.5
	OPENBSD_5_6:1.1.1.4.0.4
	OPENBSD_5_6_BASE:1.1.1.4
	PERL_5_18_2:1.1.1.4
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.3.0.6
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.2
	OPENBSD_5_4_BASE:1.1.1.3
	PERL_5_16_3:1.1.1.3
	OPENBSD_5_3:1.1.1.2.0.10
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.8
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.6
	OPENBSD_5_0:1.1.1.2.0.4
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.8
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.4
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.11;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2008.09.29.17.18.14;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.29.17.18.14;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.09.24.14.48.52;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.03.25.20.08.43;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!perl

BEGIN {
    unshift @@INC, 't';
    require Config;
    if (($Config::Config{'extensions'} !~ /\bB\b/) ){
        print "1..0 # Skip -- Perl configured without B module\n";
        exit 0;
    }
}
use OptreeCheck;
use Config;
plan tests => 18;

SKIP: {
skip "no perlio in this build", 4 unless $Config::Config{useperlio};

# The regression this was testing is that the first aelemfast, derived
# from a lexical array, is supposed to be a BASEOP "<0>", while the
# second, from a global, is an SVOP "<$>" or a PADOP "<#>" depending
# on threading. In buggy versions, both showed up as SVOPs/PADOPs. See
# B.xs:cc_opclass() for the relevant code.

# All this is much simpler, now that aelemfast_lex has been broken out from
# aelemfast
checkOptree ( name	=> 'OP_AELEMFAST opclass',
	      code	=> sub { my @@x; our @@y; $x[127] + $y[-128]},
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 7  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->7
# 1        <;> nextstate(main 634 optree_misc.t:25) v:>,<,% ->2
# 2        <0> padav[@@x:634,636] vM/LVINTRO ->3
# -        <;> ex-nextstate(main 1594 optree_misc.t:27) v:>,<,% ->3
# -        <1> rv2av[t4] vK/OURINTR,1 ->3
# -           <#> gv[*y] s ->-
# 3        <;> nextstate(main 636 optree_misc.t:25) v:>,<,%,{ ->4
# 6        <2> add[t6] sK/2 ->7
# -           <1> ex-aelem sK/2 ->5
# 4              <0> aelemfast_lex[@@x:634,636] sR/127 ->5
# -              <0> ex-const s ->-
# -           <1> ex-aelem sK/2 ->6
# -              <1> ex-rv2av sKR/1 ->-
# 5                 <#> aelemfast[*y] s/128 ->6
# -              <0> ex-const s/FOLD ->-
EOT_EOT
# 7  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->7
# 1        <;> nextstate(main 634 optree_misc.t:27) v:>,<,% ->2
# 2        <0> padav[@@x:634,636] vM/LVINTRO ->3
# -        <;> ex-nextstate(main 1594 optree_misc.t:27) v:>,<,% ->3
# -        <1> rv2av[t3] vK/OURINTR,1 ->3
# -           <$> gv(*y) s ->-
# 3        <;> nextstate(main 636 optree_misc.t:27) v:>,<,%,{ ->4
# 6        <2> add[t4] sK/2 ->7
# -           <1> ex-aelem sK/2 ->5
# 4              <0> aelemfast_lex[@@x:634,636] sR/127 ->5
# -              <0> ex-const s ->-
# -           <1> ex-aelem sK/2 ->6
# -              <1> ex-rv2av sKR/1 ->-
# 5                 <$> aelemfast(*y) s/128 ->6
# -              <0> ex-const s/FOLD ->-
EONT_EONT

checkOptree ( name	=> 'PMOP children',
	      code	=> sub { $foo =~ s/(a)/$1/ },
	      strip_open_hints => 1,
	      ( $] < 5.017002
		?  (expect => <<'EOT_EOT16', expect_nt => <<'EONT_EONT16')
# 6  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->6
# 1        <;> nextstate(main 1 -e:1) v:>,<,%,{ ->2
# 3        </> subst(/"(a)"/ replstart->4) KS ->6
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <#> gvsv[*foo] s ->3
# 5           <|> substcont(other->3) sK/1 ->(end)
# -              <1> ex-rv2sv sK/1 ->5
# 4                 <#> gvsv[*1] s ->5
EOT_EOT16
# 6  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->6
# 1        <;> nextstate(main 1 -e:1) v:>,<,%,{ ->2
# 3        </> subst(/"(a)"/ replstart->4) KS ->6
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <$> gvsv(*foo) s ->3
# 5           <|> substcont(other->3) sK/1 ->(end)
# -              <1> ex-rv2sv sK/1 ->5
# 4                 <$> gvsv(*1) s ->5
EONT_EONT16

		:  (expect => <<'EOT_EOT',   expect_nt => <<'EONT_EONT')));
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 1 -e:1) v:>,<,%,{ ->2
# 4        </> subst(/"(a)"/) sKS ->5
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <#> gvsv[*foo] s ->3
# -           <1> ex-rv2sv sK/1 ->4
# 3              <#> gvsv[*1] s ->4
EOT_EOT
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 1 -e:1) v:>,<,%,{ ->2
# 4        </> subst(/"(a)"/) sKS ->5
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <$> gvsv(*foo) s ->3
# -           <1> ex-rv2sv sK/1 ->4
# 3              <$> gvsv(*1) s ->4
EONT_EONT

} #skip

my $t = <<'EOT_EOT';
# 8  <@@> leave[1 ref] vKP/REFC ->(end)
# 1     <0> enter ->2
# 2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
# 7     <2> sassign vKS/2 ->8
# 5        <@@> index[t2] sK/2 ->6
# -           <0> ex-pushmark s ->3
# 3           <$> const[PV "foo"] s ->4
# 4           <$> const[PVMG "foo"] s ->5
# -        <1> ex-rv2sv sKRM*/1 ->7
# 6           <#> gvsv[*_] s ->7
EOT_EOT
my $nt = <<'EONT_EONT';
# 8  <@@> leave[1 ref] vKP/REFC ->(end)
# 1     <0> enter ->2
# 2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
# 7     <2> sassign vKS/2 ->8
# 5        <@@> index[t1] sK/2 ->6
# -           <0> ex-pushmark s ->3
# 3           <$> const(PV "foo") s ->4
# 4           <$> const(PVMG "foo") s ->5
# -        <1> ex-rv2sv sKRM*/1 ->7
# 6           <$> gvsv(*_) s ->7
EONT_EONT

checkOptree ( name      => 'index and PVBM',
	      prog	=> '$_ = index q(foo), q(foo)',
	      strip_open_hints => 1,
	      expect	=> $t,  expect_nt => $nt);

my $tmpfile = tempfile();
open my $fh, '>', $tmpfile or die "Cannot open $tmpfile: $!";
print $fh "no warnings;format =\n@@<<<\n\$a\n@@>>>\n\@@b\n.";
close $fh;

checkOptree ( name      => 'formats',
	      bcopts    => 'STDOUT',
	      progfile	=> $tmpfile,
	      strip_open_hints => 1,
	      skip	=> ($] < 5.017003),
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# main::STDOUT (FORMAT):
# c  <1> leavewrite[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->c
# 1        <;> nextstate(main 1 -:4) v:>,<,% ->2
# 5        <@@> formline vK/2 ->6
# 2           <0> pushmark s ->3
# 3           <$> const[PV "@@<<<\n"] s ->4
# -           <@@> lineseq lK ->5
# -              <;> ex-nextstate(main 3 tmp35894B:3) v:>,<,% ->4
# -              <1> ex-rv2sv sK/1 ->-
# 4                 <#> gvsv[*a] s ->5
# 6        <;> nextstate(main 1 -:6) v:>,<,% ->7
# b        <@@> formline sK/2 ->c
# 7           <0> pushmark s ->8
# 8           <$> const[PV "@@>>>\n"] s ->9
# -           <@@> lineseq lK ->b
# -              <;> ex-nextstate(main 3 tmp35894B:5) v:>,<,% ->9
# a              <1> rv2av[t3] lK/1 ->b
# 9                 <#> gv[*b] s ->a
EOT_EOT
# main::STDOUT (FORMAT):
# c  <1> leavewrite[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->c
# 1        <;> nextstate(main 1 -:4) v:>,<,% ->2
# 5        <@@> formline vK/2 ->6
# 2           <0> pushmark s ->3
# 3           <$> const(PV "@@<<<\n") s ->4
# -           <@@> lineseq lK ->5
# -              <;> ex-nextstate(main 3 tmp35894B:3) v:>,<,% ->4
# -              <1> ex-rv2sv sK/1 ->-
# 4                 <$> gvsv(*a) s ->5
# 6        <;> nextstate(main 1 -:6) v:>,<,% ->7
# b        <@@> formline sK/2 ->c
# 7           <0> pushmark s ->8
# 8           <$> const(PV "@@>>>\n") s ->9
# -           <@@> lineseq lK ->b
# -              <;> ex-nextstate(main 3 tmp35894B:5) v:>,<,% ->9
# a              <1> rv2av[t3] lK/1 ->b
# 9                 <$> gv(*b) s ->a
EONT_EONT

checkOptree ( name      => 'padrange',
	      code	=> sub { my ($x,$y); @@a = ($x,$y); ($x,$y) = @@a },
	      strip_open_hints => 1,
	      skip	=> ($] < 5.017006),
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# f  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->f
# 1        <;> nextstate(main 1 -e:1) v:>,<,% ->2
# -        <@@> list vKP ->3
# 2           <0> padrange[$x:1,2; $y:1,2] vM/LVINTRO,2 ->3
# -           <0> padsv[$x:1,2] vM/LVINTRO ->-
# -           <0> padsv[$y:1,2] vM/LVINTRO ->-
# 3        <;> nextstate(main 2 -e:1) v:>,<,% ->4
# 8        <2> aassign[t4] vKS/COM_AGG ->9
# -           <1> ex-list lKP ->5
# 4              <0> padrange[$x:1,2; $y:1,2] /2 ->5
# -              <0> padsv[$x:1,2] s ->-
# -              <0> padsv[$y:1,2] s ->-
# -           <1> ex-list lK ->8
# 5              <0> pushmark s ->6
# 7              <1> rv2av[t3] lKRM*/1 ->8
# 6                 <#> gv[*a] s ->7
# 9        <;> nextstate(main 2 -e:1) v:>,<,%,{ ->a
# e        <2> aassign[t6] KS/COM_RC1 ->f
# -           <1> ex-list lK ->d
# a              <0> pushmark s ->b
# c              <1> rv2av[t5] lK/1 ->d
# b                 <#> gv[*a] s ->c
# -           <1> ex-list lKPRM* ->e
# d              <0> padrange[$x:1,2; $y:1,2] RM/2 ->e
# -              <0> padsv[$x:1,2] sRM* ->-
# -              <0> padsv[$y:1,2] sRM* ->-
EOT_EOT
# f  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->f
# 1        <;> nextstate(main 1 -e:1) v:>,<,% ->2
# -        <@@> list vKP ->3
# 2           <0> padrange[$x:1,2; $y:1,2] vM/LVINTRO,2 ->3
# -           <0> padsv[$x:1,2] vM/LVINTRO ->-
# -           <0> padsv[$y:1,2] vM/LVINTRO ->-
# 3        <;> nextstate(main 2 -e:1) v:>,<,% ->4
# 8        <2> aassign[t4] vKS/COM_AGG ->9
# -           <1> ex-list lKP ->5
# 4              <0> padrange[$x:1,2; $y:1,2] /2 ->5
# -              <0> padsv[$x:1,2] s ->-
# -              <0> padsv[$y:1,2] s ->-
# -           <1> ex-list lK ->8
# 5              <0> pushmark s ->6
# 7              <1> rv2av[t3] lKRM*/1 ->8
# 6                 <$> gv(*a) s ->7
# 9        <;> nextstate(main 2 -e:1) v:>,<,%,{ ->a
# e        <2> aassign[t6] KS/COM_RC1 ->f
# -           <1> ex-list lK ->d
# a              <0> pushmark s ->b
# c              <1> rv2av[t5] lK/1 ->d
# b                 <$> gv(*a) s ->c
# -           <1> ex-list lKPRM* ->e
# d              <0> padrange[$x:1,2; $y:1,2] RM/2 ->e
# -              <0> padsv[$x:1,2] sRM* ->-
# -              <0> padsv[$y:1,2] sRM* ->-
EONT_EONT

checkOptree ( name      => 'padrange and @@_',
	      code	=> sub { my ($a,$b) = @@_;
				 my ($c,$d) = @@X::_;
				 package Y;
				 my ($e,$f) = @@_;
			     },
	      strip_open_hints => 1,
	      skip	=> ($] < 5.017006),
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# d  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->d
# 1        <;> nextstate(main 1 p3:1) v:>,<,% ->2
# 3        <2> aassign[t5] vKS ->4
# -           <1> ex-list lK ->-
# 2              <0> padrange[$a:1,4; $b:1,4] */LVINTRO,2 ->3
# -              <1> rv2av[t4] lK/1 ->-
# -                 <#> gv[*_] s ->-
# -           <1> ex-list lKPRM* ->3
# -              <0> pushmark sRM*/LVINTRO ->-
# -              <0> padsv[$a:1,4] sRM*/LVINTRO ->-
# -              <0> padsv[$b:1,4] sRM*/LVINTRO ->-
# 4        <;> nextstate(main 2 p3:2) v:>,<,% ->5
# 9        <2> aassign[t10] vKS/COM_RC1 ->a
# -           <1> ex-list lK ->8
# 5              <0> pushmark s ->6
# 7              <1> rv2av[t9] lK/1 ->8
# 6                 <#> gv[*X::_] s ->7
# -           <1> ex-list lKPRM* ->9
# 8              <0> padrange[$c:2,4; $d:2,4] RM/LVINTRO,2 ->9
# -              <0> padsv[$c:2,4] sRM*/LVINTRO ->-
# -              <0> padsv[$d:2,4] sRM*/LVINTRO ->-
# a        <;> nextstate(Y 3 p3:4) v:>,<,%,{ ->b
# c        <2> aassign[t15] KS ->d
# -           <1> ex-list lK ->-
# b              <0> padrange[$e:3,4; $f:3,4] */LVINTRO,2 ->c
# -              <1> rv2av[t14] lK/1 ->-
# -                 <#> gv[*_] s ->-
# -           <1> ex-list lKPRM* ->c
# -              <0> pushmark sRM*/LVINTRO ->-
# -              <0> padsv[$e:3,4] sRM*/LVINTRO ->-
# -              <0> padsv[$f:3,4] sRM*/LVINTRO ->-
EOT_EOT
# d  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->d
# 1        <;> nextstate(main 1 p3:1) v:>,<,% ->2
# 3        <2> aassign[t5] vKS ->4
# -           <1> ex-list lK ->-
# 2              <0> padrange[$a:1,4; $b:1,4] */LVINTRO,2 ->3
# -              <1> rv2av[t4] lK/1 ->-
# -                 <$> gv(*_) s ->-
# -           <1> ex-list lKPRM* ->3
# -              <0> pushmark sRM*/LVINTRO ->-
# -              <0> padsv[$a:1,4] sRM*/LVINTRO ->-
# -              <0> padsv[$b:1,4] sRM*/LVINTRO ->-
# 4        <;> nextstate(main 2 p3:2) v:>,<,% ->5
# 9        <2> aassign[t10] vKS/COM_RC1 ->a
# -           <1> ex-list lK ->8
# 5              <0> pushmark s ->6
# 7              <1> rv2av[t9] lK/1 ->8
# 6                 <$> gv(*X::_) s ->7
# -           <1> ex-list lKPRM* ->9
# 8              <0> padrange[$c:2,4; $d:2,4] RM/LVINTRO,2 ->9
# -              <0> padsv[$c:2,4] sRM*/LVINTRO ->-
# -              <0> padsv[$d:2,4] sRM*/LVINTRO ->-
# a        <;> nextstate(Y 3 p3:4) v:>,<,%,{ ->b
# c        <2> aassign[t15] KS ->d
# -           <1> ex-list lK ->-
# b              <0> padrange[$e:3,4; $f:3,4] */LVINTRO,2 ->c
# -              <1> rv2av[t14] lK/1 ->-
# -                 <$> gv(*_) s ->-
# -           <1> ex-list lKPRM* ->c
# -              <0> pushmark sRM*/LVINTRO ->-
# -              <0> padsv[$e:3,4] sRM*/LVINTRO ->-
# -              <0> padsv[$f:3,4] sRM*/LVINTRO ->-
EONT_EONT

checkOptree ( name      => 'consolidate padranges',
	      code	=> sub { my ($a,$b); my ($c,$d); 1 },
	      strip_open_hints => 1,
	      skip	=> ($] < 5.017006),
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 900 optree_misc.t:334) v:>,<,% ->2
# -        <@@> list vKP ->-
# 2           <0> padrange[$a:900,902; $b:900,902; $c:901,902; $d:901,902] vM/LVINTRO,4 ->3
# -           <0> padsv[$a:900,902] vM/LVINTRO ->-
# -           <0> padsv[$b:900,902] vM/LVINTRO ->-
# -        <;> nextstate(main 901 optree_misc.t:334) v:>,<,% ->-
# -        <@@> list vKP ->3
# -           <0> pushmark vM/LVINTRO ->-
# -           <0> padsv[$c:901,902] vM/LVINTRO ->-
# -           <0> padsv[$d:901,902] vM/LVINTRO ->-
# 3        <;> nextstate(main 902 optree_misc.t:334) v:>,<,%,{ ->4
# 4        <$> const[IV 1] s ->5
EOT_EOT
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 900 optree_misc.t:334) v:>,<,% ->2
# -        <@@> list vKP ->-
# 2           <0> padrange[$a:900,902; $b:900,902; $c:901,902; $d:901,902] vM/LVINTRO,4 ->3
# -           <0> padsv[$a:900,902] vM/LVINTRO ->-
# -           <0> padsv[$b:900,902] vM/LVINTRO ->-
# -        <;> nextstate(main 901 optree_misc.t:334) v:>,<,% ->-
# -        <@@> list vKP ->3
# -           <0> pushmark vM/LVINTRO ->-
# -           <0> padsv[$c:901,902] vM/LVINTRO ->-
# -           <0> padsv[$d:901,902] vM/LVINTRO ->-
# 3        <;> nextstate(main 902 optree_misc.t:334) v:>,<,%,{ ->4
# 4        <$> const(IV 1) s ->5
EONT_EONT


checkOptree ( name      => 'consolidate padranges and singletons',
	      code	=> sub { my ($a,$b); my $c; my ($d,$e);
				 my @@f; my $g; my ($h,$i); my %j; 1 },
	      strip_open_hints => 1,
	      skip	=> ($] < 5.017006),
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 903 optree_misc.t:371) v:>,<,% ->2
# -        <@@> list vKP ->-
# 2           <0> padrange[$a:903,910; $b:903,910; $c:904,910; $d:905,910; $e:905,910; @@f:906,910; $g:907,910; $h:908,910; $i:908,910; %j:909,910] vM/LVINTRO,10 ->3
# -           <0> padsv[$a:903,910] vM/LVINTRO ->-
# -           <0> padsv[$b:903,910] vM/LVINTRO ->-
# -        <;> nextstate(main 904 optree_misc.t:371) v:>,<,% ->-
# -        <0> padsv[$c:904,910] vM/LVINTRO ->-
# -        <;> nextstate(main 905 optree_misc.t:371) v:>,<,%,{ ->-
# -        <@@> list vKP ->-
# -           <0> pushmark vM/LVINTRO ->-
# -           <0> padsv[$d:905,910] vM/LVINTRO ->-
# -           <0> padsv[$e:905,910] vM/LVINTRO ->-
# -        <;> nextstate(main 906 optree_misc.t:372) v:>,<,%,{ ->-
# -        <0> padav[@@f:906,910] vM/LVINTRO ->-
# -        <;> nextstate(main 907 optree_misc.t:372) v:>,<,%,{ ->-
# -        <0> padsv[$g:907,910] vM/LVINTRO ->-
# -        <;> nextstate(main 908 optree_misc.t:372) v:>,<,%,{ ->-
# -        <@@> list vKP ->-
# -           <0> pushmark vM/LVINTRO ->-
# -           <0> padsv[$h:908,910] vM/LVINTRO ->-
# -           <0> padsv[$i:908,910] vM/LVINTRO ->-
# -        <;> nextstate(main 909 optree_misc.t:372) v:>,<,%,{ ->-
# -        <0> padhv[%j:909,910] vM/LVINTRO ->3
# 3        <;> nextstate(main 910 optree_misc.t:372) v:>,<,%,{ ->4
# 4        <$> const[IV 1] s ->5
EOT_EOT
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 903 optree_misc.t:371) v:>,<,% ->2
# -        <@@> list vKP ->-
# 2           <0> padrange[$a:903,910; $b:903,910; $c:904,910; $d:905,910; $e:905,910; @@f:906,910; $g:907,910; $h:908,910; $i:908,910; %j:909,910] vM/LVINTRO,10 ->3
# -           <0> padsv[$a:903,910] vM/LVINTRO ->-
# -           <0> padsv[$b:903,910] vM/LVINTRO ->-
# -        <;> nextstate(main 904 optree_misc.t:371) v:>,<,% ->-
# -        <0> padsv[$c:904,910] vM/LVINTRO ->-
# -        <;> nextstate(main 905 optree_misc.t:371) v:>,<,%,{ ->-
# -        <@@> list vKP ->-
# -           <0> pushmark vM/LVINTRO ->-
# -           <0> padsv[$d:905,910] vM/LVINTRO ->-
# -           <0> padsv[$e:905,910] vM/LVINTRO ->-
# -        <;> nextstate(main 906 optree_misc.t:372) v:>,<,%,{ ->-
# -        <0> padav[@@f:906,910] vM/LVINTRO ->-
# -        <;> nextstate(main 907 optree_misc.t:372) v:>,<,%,{ ->-
# -        <0> padsv[$g:907,910] vM/LVINTRO ->-
# -        <;> nextstate(main 908 optree_misc.t:372) v:>,<,%,{ ->-
# -        <@@> list vKP ->-
# -           <0> pushmark vM/LVINTRO ->-
# -           <0> padsv[$h:908,910] vM/LVINTRO ->-
# -           <0> padsv[$i:908,910] vM/LVINTRO ->-
# -        <;> nextstate(main 909 optree_misc.t:372) v:>,<,%,{ ->-
# -        <0> padhv[%j:909,910] vM/LVINTRO ->3
# 3        <;> nextstate(main 910 optree_misc.t:372) v:>,<,%,{ ->4
# 4        <$> const(IV 1) s ->5
EONT_EONT


checkOptree ( name      => 'm?x?',
	      code	=> sub { m?x?; },
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 3  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->3
# 1        <;> nextstate(main 914 optree_misc.t:434) v:>,<,%,{ ->2
# 2        </> match(/"x"/) /RTIME ->3
EOT_EOT
# 3  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->3
# 1        <;> nextstate(main 914 optree_misc.t:434) v:>,<,%,{ ->2
# 2        </> match(/"x"/) /RTIME ->3
EONT_EONT


unlink $tmpfile;
@


1.1
log
@Initial revision
@
text
@d4 1
a4 7
    if ($ENV{PERL_CORE}){
	chdir('t') if -d 't';
	@@INC = ('.', '../lib', '../ext/B/t');
    } else {
	unshift @@INC, 't';
	push @@INC, "../../t";
    }
d13 1
a13 1
plan tests => 2;
d16 1
a16 1
skip "no perlio in this build", 1 unless $Config::Config{useperlio};
d18 1
a18 1
# The regression this is testing is that the first aelemfast, derived
d24 2
d27 1
a27 1
	      code	=> sub { my @@x; our @@y; $x[0] + $y[0]},
d30 2
a31 2
# a  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->a
d34 7
a40 7
# 3        <;> nextstate(main 635 optree_misc.t:25) v:>,<,% ->4
# 5        <1> rv2av[t4] vK/OURINTR,1 ->6
# 4           <#> gv[*y] s ->5
# 6        <;> nextstate(main 636 optree_misc.t:25) v:>,<,%,{ ->7
# 9        <2> add[t6] sK/2 ->a
# -           <1> ex-aelem sK/2 ->8
# 7              <0> aelemfast[@@x:634,636] sR* ->8
d42 1
a42 1
# -           <1> ex-aelem sK/2 ->9
d44 2
a45 2
# 8                 <#> aelemfast[*y] s ->9
# -              <0> ex-const s ->-
d47 2
a48 2
# a  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->a
d51 7
a57 7
# 3        <;> nextstate(main 635 optree_misc.t:27) v:>,<,% ->4
# 5        <1> rv2av[t3] vK/OURINTR,1 ->6
# 4           <$> gv(*y) s ->5
# 6        <;> nextstate(main 636 optree_misc.t:27) v:>,<,%,{ ->7
# 9        <2> add[t4] sK/2 ->a
# -           <1> ex-aelem sK/2 ->8
# 7              <0> aelemfast[@@x:634,636] sR* ->8
d59 1
a59 1
# -           <1> ex-aelem sK/2 ->9
d61 2
a62 2
# 8                 <$> aelemfast(*y) s ->9
# -              <0> ex-const s ->-
d65 45
d121 1
a121 1
# 4           <$> const[GV "foo"] s ->5
d133 1
a133 1
# 4           <$> const(GV "foo") s ->5
a137 5
if ($] < 5.009) {
    $t =~ s/GV /BM /;
    $nt =~ s/GV /BM /;
} 

d143 306
a448 1
__END__
d450 1
@


1.1.1.1
log
@import perl 5.10.0 from CPAN
@
text
@@


1.1.1.2
log
@Perl 5.12.2 from CPAN
@
text
@d4 7
a10 1
    unshift @@INC, 't';
@


1.1.1.3
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d13 1
a13 1
plan tests => 6;
d16 1
a16 1
skip "no perlio in this build", 4 unless $Config::Config{useperlio};
d18 1
a18 1
# The regression this was testing is that the first aelemfast, derived
a23 2
# All this is much simpler, now that aelemfast_lex has been broken out from
# aelemfast
d38 1
a38 1
# 7              <0> aelemfast_lex[@@x:634,636] sR ->8
d55 1
a55 1
# 7              <0> aelemfast_lex[@@x:634,636] sR ->8
a62 24
checkOptree ( name	=> 'PMOP children',
	      code	=> sub { $foo =~ s/(a)/$1/ },
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 6  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->6
# 1        <;> nextstate(main 1 -e:1) v:>,<,%,{ ->2
# 3        </> subst(/"(a)"/ replstart->4) KS ->6
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <#> gvsv[*foo] s ->3
# 5           <|> substcont(other->3) sK/1 ->(end)
# -              <1> ex-rv2sv sK/1 ->5
# 4                 <#> gvsv[*1] s ->5
EOT_EOT
# 6  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->6
# 1        <;> nextstate(main 1 -e:1) v:>,<,%,{ ->2
# 3        </> subst(/"(a)"/ replstart->4) KS ->6
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <$> gvsv(*foo) s ->3
# 5           <|> substcont(other->3) sK/1 ->(end)
# -              <1> ex-rv2sv sK/1 ->5
# 4                 <$> gvsv(*1) s ->5
EONT_EONT
d74 1
a74 1
# 4           <$> const[PVMG "foo"] s ->5
d86 1
a86 1
# 4           <$> const(PVMG "foo") s ->5
d100 3
@


1.1.1.4
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d13 1
a13 1
plan tests => 18;
d68 1
a68 2
	      ( $] < 5.017002
		?  (expect => <<'EOT_EOT16', expect_nt => <<'EONT_EONT16')
d78 1
a78 1
EOT_EOT16
a87 20
EONT_EONT16

		:  (expect => <<'EOT_EOT',   expect_nt => <<'EONT_EONT')));
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 1 -e:1) v:>,<,%,{ ->2
# 4        </> subst(/"(a)"/) KS ->5
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <#> gvsv[*foo] s ->3
# -           <1> ex-rv2sv sK/1 ->4
# 3              <#> gvsv[*1] s ->4
EOT_EOT
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 1 -e:1) v:>,<,%,{ ->2
# 4        </> subst(/"(a)"/) KS ->5
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <$> gvsv(*foo) s ->3
# -           <1> ex-rv2sv sK/1 ->4
# 3              <$> gvsv(*1) s ->4
d117 5
a125 309

my $tmpfile = tempfile();
open my $fh, '>', $tmpfile or die "Cannot open $tmpfile: $!";
print $fh "no warnings;format =\n@@<<<\n\$a\n@@>>>\n\@@b\n.";
close $fh;

checkOptree ( name      => 'formats',
	      bcopts    => 'STDOUT',
	      progfile	=> $tmpfile,
	      strip_open_hints => 1,
	      skip	=> ($] < 5.017003),
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# main::STDOUT (FORMAT):
# c  <1> leavewrite[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->c
# 1        <;> nextstate(main 1 -:4) v:>,<,% ->2
# 5        <@@> formline vK/2 ->6
# 2           <0> pushmark s ->3
# 3           <$> const[PV "@@<<<\n"] s ->4
# -           <@@> lineseq lK ->5
# -              <0> ex-nextstate v ->4
# -              <1> ex-rv2sv sK/1 ->-
# 4                 <#> gvsv[*a] s ->5
# 6        <;> nextstate(main 1 -:6) v:>,<,% ->7
# b        <@@> formline sK/2 ->c
# 7           <0> pushmark s ->8
# 8           <$> const[PV "@@>>>\n"] s ->9
# -           <@@> lineseq lK ->b
# -              <0> ex-nextstate v ->9
# a              <1> rv2av[t3] lK/1 ->b
# 9                 <#> gv[*b] s ->a
EOT_EOT
# main::STDOUT (FORMAT):
# c  <1> leavewrite[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->c
# 1        <;> nextstate(main 1 -:4) v:>,<,% ->2
# 5        <@@> formline vK/2 ->6
# 2           <0> pushmark s ->3
# 3           <$> const(PV "@@<<<\n") s ->4
# -           <@@> lineseq lK ->5
# -              <0> ex-nextstate v ->4
# -              <1> ex-rv2sv sK/1 ->-
# 4                 <$> gvsv(*a) s ->5
# 6        <;> nextstate(main 1 -:6) v:>,<,% ->7
# b        <@@> formline sK/2 ->c
# 7           <0> pushmark s ->8
# 8           <$> const(PV "@@>>>\n") s ->9
# -           <@@> lineseq lK ->b
# -              <0> ex-nextstate v ->9
# a              <1> rv2av[t3] lK/1 ->b
# 9                 <$> gv(*b) s ->a
EONT_EONT

checkOptree ( name      => 'padrange',
	      code	=> sub { my ($x,$y); @@a = ($x,$y); ($x,$y) = @@a },
	      strip_open_hints => 1,
	      skip	=> ($] < 5.017006),
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# f  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->f
# 1        <;> nextstate(main 1 -e:1) v:>,<,% ->2
# -        <@@> list vKP ->3
# 2           <0> padrange[$x:1,2; $y:1,2] vM/LVINTRO,2 ->3
# -           <0> padsv[$x:1,2] vM/LVINTRO ->-
# -           <0> padsv[$y:1,2] vM/LVINTRO ->-
# 3        <;> nextstate(main 2 -e:1) v:>,<,% ->4
# 8        <2> aassign[t4] vKS ->9
# -           <1> ex-list lKP ->5
# 4              <0> padrange[$x:1,2; $y:1,2] l/2 ->5
# -              <0> padsv[$x:1,2] l ->-
# -              <0> padsv[$y:1,2] l ->-
# -           <1> ex-list lK ->8
# 5              <0> pushmark s ->6
# 7              <1> rv2av[t3] lKRM*/1 ->8
# 6                 <#> gv[*a] s ->7
# 9        <;> nextstate(main 2 -e:1) v:>,<,%,{ ->a
# e        <2> aassign[t6] KS ->f
# -           <1> ex-list lK ->d
# a              <0> pushmark s ->b
# c              <1> rv2av[t5] lK/1 ->d
# b                 <#> gv[*a] s ->c
# -           <1> ex-list lKPRM* ->e
# d              <0> padrange[$x:1,2; $y:1,2] lRM/2 ->e
# -              <0> padsv[$x:1,2] lRM* ->-
# -              <0> padsv[$y:1,2] lRM* ->-
EOT_EOT
# f  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->f
# 1        <;> nextstate(main 1 -e:1) v:>,<,% ->2
# -        <@@> list vKP ->3
# 2           <0> padrange[$x:1,2; $y:1,2] vM/LVINTRO,2 ->3
# -           <0> padsv[$x:1,2] vM/LVINTRO ->-
# -           <0> padsv[$y:1,2] vM/LVINTRO ->-
# 3        <;> nextstate(main 2 -e:1) v:>,<,% ->4
# 8        <2> aassign[t4] vKS ->9
# -           <1> ex-list lKP ->5
# 4              <0> padrange[$x:1,2; $y:1,2] l/2 ->5
# -              <0> padsv[$x:1,2] l ->-
# -              <0> padsv[$y:1,2] l ->-
# -           <1> ex-list lK ->8
# 5              <0> pushmark s ->6
# 7              <1> rv2av[t3] lKRM*/1 ->8
# 6                 <$> gv(*a) s ->7
# 9        <;> nextstate(main 2 -e:1) v:>,<,%,{ ->a
# e        <2> aassign[t6] KS ->f
# -           <1> ex-list lK ->d
# a              <0> pushmark s ->b
# c              <1> rv2av[t5] lK/1 ->d
# b                 <$> gv(*a) s ->c
# -           <1> ex-list lKPRM* ->e
# d              <0> padrange[$x:1,2; $y:1,2] lRM/2 ->e
# -              <0> padsv[$x:1,2] lRM* ->-
# -              <0> padsv[$y:1,2] lRM* ->-
EONT_EONT

checkOptree ( name      => 'padrange and @@_',
	      code	=> sub { my ($a,$b) = @@_;
				 my ($c,$d) = @@X::_;
				 package Y;
				 my ($e,$f) = @@_;
			     },
	      strip_open_hints => 1,
	      skip	=> ($] < 5.017006),
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# d  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->d
# 1        <;> nextstate(main 1 p3:1) v:>,<,% ->2
# 3        <2> aassign[t5] vKS ->4
# -           <1> ex-list lK ->-
# 2              <0> padrange[$a:1,4; $b:1,4] l*/LVINTRO,2 ->3
# -              <1> rv2av[t4] lK/1 ->-
# -                 <#> gv[*_] s ->-
# -           <1> ex-list lKPRM* ->3
# -              <0> pushmark sRM*/LVINTRO ->-
# -              <0> padsv[$a:1,4] lRM*/LVINTRO ->-
# -              <0> padsv[$b:1,4] lRM*/LVINTRO ->-
# 4        <;> nextstate(main 2 p3:2) v:>,<,% ->5
# 9        <2> aassign[t10] vKS ->a
# -           <1> ex-list lK ->8
# 5              <0> pushmark s ->6
# 7              <1> rv2av[t9] lK/1 ->8
# 6                 <#> gv[*X::_] s ->7
# -           <1> ex-list lKPRM* ->9
# 8              <0> padrange[$c:2,4; $d:2,4] lRM/LVINTRO,2 ->9
# -              <0> padsv[$c:2,4] lRM*/LVINTRO ->-
# -              <0> padsv[$d:2,4] lRM*/LVINTRO ->-
# a        <;> nextstate(Y 3 p3:4) v:>,<,%,{ ->b
# c        <2> aassign[t15] KS ->d
# -           <1> ex-list lK ->-
# b              <0> padrange[$e:3,4; $f:3,4] l*/LVINTRO,2 ->c
# -              <1> rv2av[t14] lK/1 ->-
# -                 <#> gv[*_] s ->-
# -           <1> ex-list lKPRM* ->c
# -              <0> pushmark sRM*/LVINTRO ->-
# -              <0> padsv[$e:3,4] lRM*/LVINTRO ->-
# -              <0> padsv[$f:3,4] lRM*/LVINTRO ->-
EOT_EOT
# d  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->d
# 1        <;> nextstate(main 1 p3:1) v:>,<,% ->2
# 3        <2> aassign[t5] vKS ->4
# -           <1> ex-list lK ->-
# 2              <0> padrange[$a:1,4; $b:1,4] l*/LVINTRO,2 ->3
# -              <1> rv2av[t4] lK/1 ->-
# -                 <$> gv(*_) s ->-
# -           <1> ex-list lKPRM* ->3
# -              <0> pushmark sRM*/LVINTRO ->-
# -              <0> padsv[$a:1,4] lRM*/LVINTRO ->-
# -              <0> padsv[$b:1,4] lRM*/LVINTRO ->-
# 4        <;> nextstate(main 2 p3:2) v:>,<,% ->5
# 9        <2> aassign[t10] vKS ->a
# -           <1> ex-list lK ->8
# 5              <0> pushmark s ->6
# 7              <1> rv2av[t9] lK/1 ->8
# 6                 <$> gv(*X::_) s ->7
# -           <1> ex-list lKPRM* ->9
# 8              <0> padrange[$c:2,4; $d:2,4] lRM/LVINTRO,2 ->9
# -              <0> padsv[$c:2,4] lRM*/LVINTRO ->-
# -              <0> padsv[$d:2,4] lRM*/LVINTRO ->-
# a        <;> nextstate(Y 3 p3:4) v:>,<,%,{ ->b
# c        <2> aassign[t15] KS ->d
# -           <1> ex-list lK ->-
# b              <0> padrange[$e:3,4; $f:3,4] l*/LVINTRO,2 ->c
# -              <1> rv2av[t14] lK/1 ->-
# -                 <$> gv(*_) s ->-
# -           <1> ex-list lKPRM* ->c
# -              <0> pushmark sRM*/LVINTRO ->-
# -              <0> padsv[$e:3,4] lRM*/LVINTRO ->-
# -              <0> padsv[$f:3,4] lRM*/LVINTRO ->-
EONT_EONT

checkOptree ( name      => 'consolidate padranges',
	      code	=> sub { my ($a,$b); my ($c,$d); 1 },
	      strip_open_hints => 1,
	      skip	=> ($] < 5.017006),
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 900 optree_misc.t:334) v:>,<,% ->2
# -        <@@> list vKP ->-
# 2           <0> padrange[$a:900,902; $b:900,902; $c:901,902; $d:901,902] vM/LVINTRO,4 ->3
# -           <0> padsv[$a:900,902] vM/LVINTRO ->-
# -           <0> padsv[$b:900,902] vM/LVINTRO ->-
# -        <;> nextstate(main 901 optree_misc.t:334) v:>,<,% ->-
# -        <@@> list vKP ->3
# -           <0> pushmark vM/LVINTRO ->-
# -           <0> padsv[$c:901,902] vM/LVINTRO ->-
# -           <0> padsv[$d:901,902] vM/LVINTRO ->-
# 3        <;> nextstate(main 902 optree_misc.t:334) v:>,<,%,{ ->4
# 4        <$> const[IV 1] s ->5
EOT_EOT
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 900 optree_misc.t:334) v:>,<,% ->2
# -        <@@> list vKP ->-
# 2           <0> padrange[$a:900,902; $b:900,902; $c:901,902; $d:901,902] vM/LVINTRO,4 ->3
# -           <0> padsv[$a:900,902] vM/LVINTRO ->-
# -           <0> padsv[$b:900,902] vM/LVINTRO ->-
# -        <;> nextstate(main 901 optree_misc.t:334) v:>,<,% ->-
# -        <@@> list vKP ->3
# -           <0> pushmark vM/LVINTRO ->-
# -           <0> padsv[$c:901,902] vM/LVINTRO ->-
# -           <0> padsv[$d:901,902] vM/LVINTRO ->-
# 3        <;> nextstate(main 902 optree_misc.t:334) v:>,<,%,{ ->4
# 4        <$> const(IV 1) s ->5
EONT_EONT


checkOptree ( name      => 'consolidate padranges and singletons',
	      code	=> sub { my ($a,$b); my $c; my ($d,$e);
				 my @@f; my $g; my ($h,$i); my %j; 1 },
	      strip_open_hints => 1,
	      skip	=> ($] < 5.017006),
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 903 optree_misc.t:371) v:>,<,% ->2
# -        <@@> list vKP ->-
# 2           <0> padrange[$a:903,910; $b:903,910; $c:904,910; $d:905,910; $e:905,910; @@f:906,910; $g:907,910; $h:908,910; $i:908,910; %j:909,910] vM/LVINTRO,10 ->3
# -           <0> padsv[$a:903,910] vM/LVINTRO ->-
# -           <0> padsv[$b:903,910] vM/LVINTRO ->-
# -        <;> nextstate(main 904 optree_misc.t:371) v:>,<,% ->-
# -        <0> padsv[$c:904,910] vM/LVINTRO ->-
# -        <;> nextstate(main 905 optree_misc.t:371) v:>,<,%,{ ->-
# -        <@@> list vKP ->-
# -           <0> pushmark vM/LVINTRO ->-
# -           <0> padsv[$d:905,910] vM/LVINTRO ->-
# -           <0> padsv[$e:905,910] vM/LVINTRO ->-
# -        <;> nextstate(main 906 optree_misc.t:372) v:>,<,%,{ ->-
# -        <0> padav[@@f:906,910] vM/LVINTRO ->-
# -        <;> nextstate(main 907 optree_misc.t:372) v:>,<,%,{ ->-
# -        <0> padsv[$g:907,910] vM/LVINTRO ->-
# -        <;> nextstate(main 908 optree_misc.t:372) v:>,<,%,{ ->-
# -        <@@> list vKP ->-
# -           <0> pushmark vM/LVINTRO ->-
# -           <0> padsv[$h:908,910] vM/LVINTRO ->-
# -           <0> padsv[$i:908,910] vM/LVINTRO ->-
# -        <;> nextstate(main 909 optree_misc.t:372) v:>,<,%,{ ->-
# -        <0> padhv[%j:909,910] vM/LVINTRO ->3
# 3        <;> nextstate(main 910 optree_misc.t:372) v:>,<,%,{ ->4
# 4        <$> const[IV 1] s ->5
EOT_EOT
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 903 optree_misc.t:371) v:>,<,% ->2
# -        <@@> list vKP ->-
# 2           <0> padrange[$a:903,910; $b:903,910; $c:904,910; $d:905,910; $e:905,910; @@f:906,910; $g:907,910; $h:908,910; $i:908,910; %j:909,910] vM/LVINTRO,10 ->3
# -           <0> padsv[$a:903,910] vM/LVINTRO ->-
# -           <0> padsv[$b:903,910] vM/LVINTRO ->-
# -        <;> nextstate(main 904 optree_misc.t:371) v:>,<,% ->-
# -        <0> padsv[$c:904,910] vM/LVINTRO ->-
# -        <;> nextstate(main 905 optree_misc.t:371) v:>,<,%,{ ->-
# -        <@@> list vKP ->-
# -           <0> pushmark vM/LVINTRO ->-
# -           <0> padsv[$d:905,910] vM/LVINTRO ->-
# -           <0> padsv[$e:905,910] vM/LVINTRO ->-
# -        <;> nextstate(main 906 optree_misc.t:372) v:>,<,%,{ ->-
# -        <0> padav[@@f:906,910] vM/LVINTRO ->-
# -        <;> nextstate(main 907 optree_misc.t:372) v:>,<,%,{ ->-
# -        <0> padsv[$g:907,910] vM/LVINTRO ->-
# -        <;> nextstate(main 908 optree_misc.t:372) v:>,<,%,{ ->-
# -        <@@> list vKP ->-
# -           <0> pushmark vM/LVINTRO ->-
# -           <0> padsv[$h:908,910] vM/LVINTRO ->-
# -           <0> padsv[$i:908,910] vM/LVINTRO ->-
# -        <;> nextstate(main 909 optree_misc.t:372) v:>,<,%,{ ->-
# -        <0> padhv[%j:909,910] vM/LVINTRO ->3
# 3        <;> nextstate(main 910 optree_misc.t:372) v:>,<,%,{ ->4
# 4        <$> const(IV 1) s ->5
EONT_EONT


checkOptree ( name      => 'm?x?',
	      code	=> sub { m?x?; },
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 3  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->3
# 1        <;> nextstate(main 914 optree_misc.t:434) v:>,<,%,{ ->2
# 2        </> match(/"x"/) /RTIME ->3
EOT_EOT
# 3  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->3
# 1        <;> nextstate(main 914 optree_misc.t:434) v:>,<,%,{ ->2
# 2        </> match(/"x"/) /RTIME ->3
EONT_EONT


unlink $tmpfile;
@


1.1.1.5
log
@Import perl-5.20.1
@
text
@d27 1
a27 1
	      code	=> sub { my @@x; our @@y; $x[127] + $y[-128]},
d40 1
a40 1
# 7              <0> aelemfast_lex[@@x:634,636] sR/127 ->8
d44 2
a45 2
# 8                 <#> aelemfast[*y] s/128 ->9
# -              <0> ex-const s/FOLD ->-
d57 1
a57 1
# 7              <0> aelemfast_lex[@@x:634,636] sR/127 ->8
d61 2
a62 2
# 8                 <$> aelemfast(*y) s/128 ->9
# -              <0> ex-const s/FOLD ->-
@


