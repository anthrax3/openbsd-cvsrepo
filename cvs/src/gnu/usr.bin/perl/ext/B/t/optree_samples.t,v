head	1.2;
access;
symbols
	OPENBSD_6_0:1.1.1.7.0.10
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.4
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.6
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.6.0.4
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.6
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.2
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.4.0.10
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.8
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.6
	OPENBSD_5_0:1.1.1.4.0.4
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.2
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.3.0.8
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.4
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.10
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.8
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.6
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.4
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.2
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.1.0.6
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.4
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.2
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.11;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.03.28.18.47.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.14;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.09.24.14.48.53;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.08.43;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!perl

BEGIN {
    unshift @@INC, 't';
    require Config;
    if (($Config::Config{'extensions'} !~ /\bB\b/) ){
        print "1..0 # Skip -- Perl configured without B module\n";
        exit 0;
    }
    if (!$Config::Config{useperlio}) {
        print "1..0 # Skip -- need perlio to walk the optree\n";
        exit 0;
    }
}
use OptreeCheck;
use Config;
plan tests	=> 46;

pass("GENERAL OPTREE EXAMPLES");

pass("IF,THEN,ELSE, ?:");

checkOptree ( name	=> '-basic sub {if shift print then,else}',
	      bcopts	=> '-basic',
	      code	=> sub { if (shift) { print "then" }
				 else       { print "else" }
			     },
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 7  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->7
# 1        <;> nextstate(main 665 optree_samples.t:24) v:>,<,% ->2
# -        <1> null K/1 ->-
# 3           <|> cond_expr(other->4) K/1 ->8
# 2              <0> shift s* ->3
# -              <@@> scope K ->-
# -                 <;> ex-nextstate(main 1594 optree_samples.t:25) v:>,<,% ->4
# 6                 <@@> print sK ->7
# 4                    <0> pushmark s ->5
# 5                    <$> const[PV "then"] s ->6
# d              <@@> leave KP ->7
# 8                 <0> enter ->9
# 9                 <;> nextstate(main 663 optree_samples.t:25) v:>,<,% ->a
# c                 <@@> print sK ->d
# a                    <0> pushmark s ->b
# b                    <$> const[PV "else"] s ->c
EOT_EOT
# 7  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->7
# 1        <;> nextstate(main 665 optree_samples.t:24) v:>,<,% ->2
# -        <1> null K/1 ->-
# 3           <|> cond_expr(other->4) K/1 ->8
# 2              <0> shift s* ->3
# -              <@@> scope K ->-
# -                 <;> ex-nextstate(main 1594 optree_samples.t:25) v:>,<,% ->4
# 6                 <@@> print sK ->7
# 4                    <0> pushmark s ->5
# 5                    <$> const(PV "then") s ->6
# d              <@@> leave KP ->7
# 8                 <0> enter ->9
# 9                 <;> nextstate(main 663 optree_samples.t:25) v:>,<,% ->a
# c                 <@@> print sK ->d
# a                    <0> pushmark s ->b
# b                    <$> const(PV "else") s ->c
EONT_EONT

checkOptree ( name	=> '-basic (see above, with my $a = shift)',
	      bcopts	=> '-basic',
	      code	=> sub { my $a = shift;
				 if ($a) { print "foo" }
				 else    { print "bar" }
			     },
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# b  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->b
# 1        <;> nextstate(main 666 optree_samples.t:70) v:>,<,% ->2
# 4        <2> sassign vKS/2 ->5
# 2           <0> shift s* ->3
# 3           <0> padsv[$a:666,670] sRM*/LVINTRO ->4
# 5        <;> nextstate(main 670 optree_samples.t:71) v:>,<,% ->6
# -        <1> null K/1 ->-
# 7           <|> cond_expr(other->8) K/1 ->c
# 6              <0> padsv[$a:666,670] s ->7
# -              <@@> scope K ->-
# -                 <;> ex-nextstate(main 1603 optree_samples.t:70) v:>,<,% ->8
# a                 <@@> print sK ->b
# 8                    <0> pushmark s ->9
# 9                    <$> const[PV "foo"] s ->a
# h              <@@> leave KP ->b
# c                 <0> enter ->d
# d                 <;> nextstate(main 668 optree_samples.t:72) v:>,<,% ->e
# g                 <@@> print sK ->h
# e                    <0> pushmark s ->f
# f                    <$> const[PV "bar"] s ->g
EOT_EOT
# b  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->b
# 1        <;> nextstate(main 666 optree_samples.t:72) v:>,<,% ->2
# 4        <2> sassign vKS/2 ->5
# 2           <0> shift s* ->3
# 3           <0> padsv[$a:666,670] sRM*/LVINTRO ->4
# 5        <;> nextstate(main 670 optree_samples.t:73) v:>,<,% ->6
# -        <1> null K/1 ->-
# 7           <|> cond_expr(other->8) K/1 ->c
# 6              <0> padsv[$a:666,670] s ->7
# -              <@@> scope K ->-
# -                 <;> ex-nextstate(main 1603 optree_samples.t:70) v:>,<,% ->8
# a                 <@@> print sK ->b
# 8                    <0> pushmark s ->9
# 9                    <$> const(PV "foo") s ->a
# h              <@@> leave KP ->b
# c                 <0> enter ->d
# d                 <;> nextstate(main 668 optree_samples.t:74) v:>,<,% ->e
# g                 <@@> print sK ->h
# e                    <0> pushmark s ->f
# f                    <$> const(PV "bar") s ->g
EONT_EONT

checkOptree ( name	=> '-exec sub {if shift print then,else}',
	      bcopts	=> '-exec',
	      code	=> sub { if (shift) { print "then" }
				 else       { print "else" }
			     },
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 674 optree_samples.t:125) v:>,<,%
# 2  <0> shift s*
# 3  <|> cond_expr(other->4) K/1
# 4      <0> pushmark s
# 5      <$> const[PV "then"] s
# 6      <@@> print sK
#            goto 7
# 8  <0> enter 
# 9  <;> nextstate(main 672 optree_samples.t:126) v:>,<,%
# a  <0> pushmark s
# b  <$> const[PV "else"] s
# c  <@@> print sK
# d  <@@> leave KP
# 7  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 674 optree_samples.t:129) v:>,<,%
# 2  <0> shift s*
# 3  <|> cond_expr(other->4) K/1
# 4      <0> pushmark s
# 5      <$> const(PV "then") s
# 6      <@@> print sK
#            goto 7
# 8  <0> enter 
# 9  <;> nextstate(main 672 optree_samples.t:130) v:>,<,%
# a  <0> pushmark s
# b  <$> const(PV "else") s
# c  <@@> print sK
# d  <@@> leave KP
# 7  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> '-exec (see above, with my $a = shift)',
	      bcopts	=> '-exec',
	      code	=> sub { my $a = shift;
				 if ($a) { print "foo" }
				 else    { print "bar" }
			     },
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 675 optree_samples.t:165) v:>,<,%
# 2  <0> shift s*
# 3  <0> padsv[$a:675,679] sRM*/LVINTRO
# 4  <2> sassign vKS/2
# 5  <;> nextstate(main 679 optree_samples.t:166) v:>,<,%
# 6  <0> padsv[$a:675,679] s
# 7  <|> cond_expr(other->8) K/1
# 8      <0> pushmark s
# 9      <$> const[PV "foo"] s
# a      <@@> print sK
#            goto b
# c  <0> enter 
# d  <;> nextstate(main 677 optree_samples.t:167) v:>,<,%
# e  <0> pushmark s
# f  <$> const[PV "bar"] s
# g  <@@> print sK
# h  <@@> leave KP
# b  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 675 optree_samples.t:171) v:>,<,%
# 2  <0> shift s*
# 3  <0> padsv[$a:675,679] sRM*/LVINTRO
# 4  <2> sassign vKS/2
# 5  <;> nextstate(main 679 optree_samples.t:172) v:>,<,%
# 6  <0> padsv[$a:675,679] s
# 7  <|> cond_expr(other->8) K/1
# 8      <0> pushmark s
# 9      <$> const(PV "foo") s
# a      <@@> print sK
#            goto b
# c  <0> enter 
# d  <;> nextstate(main 677 optree_samples.t:173) v:>,<,%
# e  <0> pushmark s
# f  <$> const(PV "bar") s
# g  <@@> print sK
# h  <@@> leave KP
# b  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> '-exec sub { print (shift) ? "foo" : "bar" }',
	      code	=> sub { print (shift) ? "foo" : "bar" },
	      bcopts	=> '-exec',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 680 optree_samples.t:213) v:>,<,%
# 2  <0> pushmark s
# 3  <0> shift s*
# 4  <@@> print sK
# 5  <|> cond_expr(other->6) K/1
# 6      <$> const[PV "foo"] s
#            goto 7
# 8  <$> const[PV "bar"] s
# 7  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 680 optree_samples.t:221) v:>,<,%
# 2  <0> pushmark s
# 3  <0> shift s*
# 4  <@@> print sK
# 5  <|> cond_expr(other->6) K/1
# 6      <$> const(PV "foo") s
#            goto 7
# 8  <$> const(PV "bar") s
# 7  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

pass ("FOREACH");

checkOptree ( name	=> '-exec sub { foreach (1..10) {print "foo $_"} }',
	      code	=> sub { foreach (1..10) {print "foo $_"} },
	      bcopts	=> '-exec',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 443 optree.t:158) v:>,<,%
# 2  <0> pushmark s
# 3  <$> const[IV 1] s
# 4  <$> const[IV 10] s
# 5  <#> gv[*_] s
# 6  <{> enteriter(next->d last->g redo->7) KS/DEF
# e  <0> iter s
# f  <|> and(other->7) K/1
# 7      <;> nextstate(main 442 optree.t:158) v:>,<,%
# 8      <0> pushmark s
# 9      <$> const[PV "foo "] s
# a      <#> gvsv[*_] s
# b      <2> concat[t4] sK/2
# c      <@@> print vK
# d      <0> unstack s
#            goto e
# g  <2> leaveloop K/2
# h  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 444 optree_samples.t:182) v:>,<,%
# 2  <0> pushmark s
# 3  <$> const(IV 1) s
# 4  <$> const(IV 10) s
# 5  <$> gv(*_) s
# 6  <{> enteriter(next->d last->g redo->7) KS/DEF
# e  <0> iter s
# f  <|> and(other->7) K/1
# 7      <;> nextstate(main 443 optree_samples.t:182) v:>,<,%
# 8      <0> pushmark s
# 9      <$> const(PV "foo ") s
# a      <$> gvsv(*_) s
# b      <2> concat[t3] sK/2
# c      <@@> print vK
# d      <0> unstack s
#            goto e
# g  <2> leaveloop K/2
# h  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> '-basic sub { print "foo $_" foreach (1..10) }',
	      code	=> sub { print "foo $_" foreach (1..10) }, 
	      bcopts	=> '-basic',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# g  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->g
# 1        <;> nextstate(main 445 optree.t:167) v:>,<,% ->2
# f        <2> leaveloop K/2 ->g
# 6           <{> enteriter(next->c last->f redo->7) KS/DEF ->d
# -              <0> ex-pushmark s ->2
# -              <1> ex-list lK ->5
# 2                 <0> pushmark s ->3
# 3                 <$> const[IV 1] s ->4
# 4                 <$> const[IV 10] s ->5
# 5              <#> gv[*_] s ->6
# -           <1> null K/1 ->f
# e              <|> and(other->7) K/1 ->f
# d                 <0> iter s ->e
# -                 <@@> lineseq sK ->-
# b                    <@@> print vK ->c
# 7                       <0> pushmark s ->8
# -                       <1> ex-stringify sK/1 ->b
# -                          <0> ex-pushmark s ->8
# a                          <2> concat[t2] sK/2 ->b
# 8                             <$> const[PV "foo "] s ->9
# -                             <1> ex-rv2sv sK/1 ->a
# 9                                <#> gvsv[*_] s ->a
# c                    <0> unstack s ->d
EOT_EOT
# g  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->g
# 1        <;> nextstate(main 446 optree_samples.t:192) v:>,<,% ->2
# f        <2> leaveloop K/2 ->g
# 6           <{> enteriter(next->c last->f redo->7) KS/DEF ->d
# -              <0> ex-pushmark s ->2
# -              <1> ex-list lK ->5
# 2                 <0> pushmark s ->3
# 3                 <$> const(IV 1) s ->4
# 4                 <$> const(IV 10) s ->5
# 5              <$> gv(*_) s ->6
# -           <1> null K/1 ->f
# e              <|> and(other->7) K/1 ->f
# d                 <0> iter s ->e
# -                 <@@> lineseq sK ->-
# b                    <@@> print vK ->c
# 7                       <0> pushmark s ->8
# -                       <1> ex-stringify sK/1 ->b
# -                          <0> ex-pushmark s ->8
# a                          <2> concat[t1] sK/2 ->b
# 8                             <$> const(PV "foo ") s ->9
# -                             <1> ex-rv2sv sK/1 ->a
# 9                                <$> gvsv(*_) s ->a
# c                    <0> unstack s ->d
EONT_EONT

checkOptree ( name	=> '-exec -e foreach (1..10) {print qq{foo $_}}',
	      prog	=> 'foreach (1..10) {print qq{foo $_}}',
	      bcopts	=> '-exec',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <0> enter 
# 2  <;> nextstate(main 2 -e:1) v:>,<,%,{
# 3  <0> pushmark s
# 4  <$> const[IV 1] s
# 5  <$> const[IV 10] s
# 6  <#> gv[*_] s
# 7  <{> enteriter(next->e last->h redo->8) vKS/DEF
# f  <0> iter s
# g  <|> and(other->8) vK/1
# 8      <;> nextstate(main 1 -e:1) v:>,<,%
# 9      <0> pushmark s
# a      <$> const[PV "foo "] s
# b      <#> gvsv[*_] s
# c      <2> concat[t4] sK/2
# d      <@@> print vK
# e      <0> unstack v
#            goto f
# h  <2> leaveloop vK/2
# i  <@@> leave[1 ref] vKP/REFC
EOT_EOT
# 1  <0> enter 
# 2  <;> nextstate(main 2 -e:1) v:>,<,%,{
# 3  <0> pushmark s
# 4  <$> const(IV 1) s
# 5  <$> const(IV 10) s
# 6  <$> gv(*_) s
# 7  <{> enteriter(next->e last->h redo->8) vKS/DEF
# f  <0> iter s
# g  <|> and(other->8) vK/1
# 8      <;> nextstate(main 1 -e:1) v:>,<,%
# 9      <0> pushmark s
# a      <$> const(PV "foo ") s
# b      <$> gvsv(*_) s
# c      <2> concat[t3] sK/2
# d      <@@> print vK
# e      <0> unstack v
#            goto f
# h  <2> leaveloop vK/2
# i  <@@> leave[1 ref] vKP/REFC
EONT_EONT

checkOptree ( name	=> '-exec sub { print "foo $_" foreach (1..10) }',
	      code	=> sub { print "foo $_" foreach (1..10) }, 
	      bcopts	=> '-exec',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 445 optree.t:167) v:>,<,%
# 2  <0> pushmark s
# 3  <$> const[IV 1] s
# 4  <$> const[IV 10] s
# 5  <#> gv[*_] s
# 6  <{> enteriter(next->c last->f redo->7) KS/DEF
# d  <0> iter s
# e  <|> and(other->7) K/1
# 7      <0> pushmark s
# 8      <$> const[PV "foo "] s
# 9      <#> gvsv[*_] s
# a      <2> concat[t2] sK/2
# b      <@@> print vK
# c      <0> unstack s
#            goto d
# f  <2> leaveloop K/2
# g  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 447 optree_samples.t:252) v:>,<,%
# 2  <0> pushmark s
# 3  <$> const(IV 1) s
# 4  <$> const(IV 10) s
# 5  <$> gv(*_) s
# 6  <{> enteriter(next->c last->f redo->7) KS/DEF
# d  <0> iter s
# e  <|> and(other->7) K/1
# 7      <0> pushmark s
# 8      <$> const(PV "foo ") s
# 9      <$> gvsv(*_) s
# a      <2> concat[t1] sK/2
# b      <@@> print vK
# c      <0> unstack s
#            goto d
# f  <2> leaveloop K/2
# g  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

pass("GREP: SAMPLES FROM PERLDOC -F GREP");

checkOptree ( name	=> '@@foo = grep(!/^\#/, @@bar)',
	      code	=> '@@foo = grep(!/^\#/, @@bar)',
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 496 (eval 20):1) v:{
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*bar] s
# 5  <1> rv2av[t4] lKM/1
# 6  <@@> grepstart lK
# 7  <|> grepwhile(other->8)[t5] lK
# 8      </> match(/"^#"/) s/RTIME
# 9      <1> not sK/1
#            goto 7
# a  <0> pushmark s
# b  <#> gv[*foo] s
# c  <1> rv2av[t2] lKRM*/1
# d  <2> aassign[t6] KS/COM_AGG
# e  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 496 (eval 20):1) v:{
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*bar) s
# 5  <1> rv2av[t2] lKM/1
# 6  <@@> grepstart lK
# 7  <|> grepwhile(other->8)[t3] lK
# 8      </> match(/"^\\#"/) s/RTIME
# 9      <1> not sK/1
#            goto 7
# a  <0> pushmark s
# b  <$> gv(*foo) s
# c  <1> rv2av[t1] lKRM*/1
# d  <2> aassign[t4] KS/COM_AGG
# e  <1> leavesub[1 ref] K/REFC,1
EONT_EONT


pass("MAP: SAMPLES FROM PERLDOC -F MAP");

checkOptree ( name	=> '%h = map { getkey($_) => $_ } @@a',
	      code	=> '%h = map { getkey($_) => $_ } @@a',
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 501 (eval 22):1) v:{
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*a] s
# 5  <1> rv2av[t8] lKM/1
# 6  <@@> mapstart lK*                 < 5.017002
# 6  <@@> mapstart lK                  >=5.017002
# 7  <|> mapwhile(other->8)[t9] lK
# 8      <0> enter l
# 9      <;> nextstate(main 500 (eval 22):1) v:{
# a      <0> pushmark s
# b      <#> gvsv[*_] s
# c      <#> gv[*getkey] s/EARLYCV
# d      <1> entersub[t5] lKS/TARG
# e      <#> gvsv[*_] s
# f      <@@> leave lKP
#            goto 7
# g  <0> pushmark s
# h  <#> gv[*h] s
# i  <1> rv2hv[t2] lKRM*/1         < 5.019006
# i  <1> rv2hv lKRM*/1             >=5.019006
# j  <2> aassign[t10] KS/COM_AGG
# k  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 501 (eval 22):1) v:{
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*a) s
# 5  <1> rv2av[t3] lKM/1
# 6  <@@> mapstart lK*                 < 5.017002
# 6  <@@> mapstart lK                  >=5.017002
# 7  <|> mapwhile(other->8)[t4] lK
# 8      <0> enter l
# 9      <;> nextstate(main 500 (eval 22):1) v:{
# a      <0> pushmark s
# b      <$> gvsv(*_) s
# c      <$> gv(*getkey) s/EARLYCV
# d      <1> entersub[t2] lKS/TARG
# e      <$> gvsv(*_) s
# f      <@@> leave lKP
#            goto 7
# g  <0> pushmark s
# h  <$> gv(*h) s
# i  <1> rv2hv[t1] lKRM*/1         < 5.019006
# i  <1> rv2hv lKRM*/1             >=5.019006
# j  <2> aassign[t5] KS/COM_AGG
# k  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> '%h=(); for $_(@@a){$h{getkey($_)} = $_}',
	      code	=> '%h=(); for $_(@@a){$h{getkey($_)} = $_}',
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 505 (eval 24):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*h] s
# 5  <1> rv2hv[t2] lKRM*/1         < 5.019006
# 5  <1> rv2hv lKRM*/1             >=5.019006
# 6  <2> aassign[t3] vKS
# 7  <;> nextstate(main 506 (eval 24):1) v:{
# 8  <0> pushmark sM
# 9  <#> gv[*a] s
# a  <1> rv2av[t6] sKRM/1
# b  <#> gv[*_] s
# c  <1> rv2gv sKRM/1
# d  <{> enteriter(next->o last->r redo->e) KS/DEF
# p  <0> iter s
# q  <|> and(other->e) K/1
# e      <;> nextstate(main 505 (eval 24):1) v:{
# f      <#> gvsv[*_] s
# g      <#> gv[*h] s
# h      <1> rv2hv sKR/1
# i      <0> pushmark s
# j      <#> gvsv[*_] s
# k      <#> gv[*getkey] s/EARLYCV
# l      <1> entersub[t10] sKS/TARG
# m      <2> helem sKRM*/2
# n      <2> sassign vKS/2
# o      <0> unstack s
#            goto p
# r  <2> leaveloop KP/2
# s  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 505 (eval 24):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*h) s
# 5  <1> rv2hv[t1] lKRM*/1         < 5.019006
# 5  <1> rv2hv lKRM*/1             >=5.019006
# 6  <2> aassign[t2] vKS
# 7  <;> nextstate(main 506 (eval 24):1) v:{
# 8  <0> pushmark sM
# 9  <$> gv(*a) s
# a  <1> rv2av[t3] sKRM/1
# b  <$> gv(*_) s
# c  <1> rv2gv sKRM/1
# d  <{> enteriter(next->o last->r redo->e) KS/DEF
# p  <0> iter s
# q  <|> and(other->e) K/1
# e      <;> nextstate(main 505 (eval 24):1) v:{
# f      <$> gvsv(*_) s
# g      <$> gv(*h) s
# h      <1> rv2hv sKR/1
# i      <0> pushmark s
# j      <$> gvsv(*_) s
# k      <$> gv(*getkey) s/EARLYCV
# l      <1> entersub[t4] sKS/TARG
# m      <2> helem sKRM*/2
# n      <2> sassign vKS/2
# o      <0> unstack s
#            goto p
# r  <2> leaveloop KP/2
# s  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> 'map $_+42, 10..20',
	      code	=> 'map $_+42, 10..20',
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 497 (eval 20):1) v
# 2  <0> pushmark s
# 3  <$> const[AV ] s
# 4  <1> rv2av lKPM/1
# 5  <@@> mapstart K
# 6  <|> mapwhile(other->7)[t5] K
# 7      <#> gvsv[*_] s
# 8      <$> const[IV 42] s
# 9      <2> add[t2] sK/2
#            goto 6
# a  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 511 (eval 26):1) v
# 2  <0> pushmark s
# 3  <$> const(AV ) s
# 4  <1> rv2av lKPM/1
# 5  <@@> mapstart K
# 6  <|> mapwhile(other->7)[t4] K
# 7      <$> gvsv(*_) s
# 8      <$> const(IV 42) s
# 9      <2> add[t1] sK/2
#            goto 6
# a  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

pass("CONSTANTS");

checkOptree ( name	=> '-e use constant j => qq{junk}; print j',
	      prog	=> 'use constant j => qq{junk}; print j',
	      bcopts	=> '-exec',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <0> enter 
# 2  <;> nextstate(main 71 -e:1) v:>,<,%,{
# 3  <0> pushmark s
# 4  <$> const[PV "junk"] s*      < 5.017002
# 4  <$> const[PV "junk"] s*/FOLD >=5.017002
# 5  <@@> print vK
# 6  <@@> leave[1 ref] vKP/REFC
EOT_EOT
# 1  <0> enter 
# 2  <;> nextstate(main 71 -e:1) v:>,<,%,{
# 3  <0> pushmark s
# 4  <$> const(PV "junk") s*      < 5.017002
# 4  <$> const(PV "junk") s*/FOLD >=5.017002
# 5  <@@> print vK
# 6  <@@> leave[1 ref] vKP/REFC
EONT_EONT

pass("rpeep - return \$x at end of sub");

checkOptree ( name	=> '-exec sub { return 1 }',
	      code	=> sub { return 1 },
	      bcopts	=> '-exec',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 1 -e:1) v:>,<,%
# 2  <$> const[IV 1] s
# 3  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 1 -e:1) v:>,<,%
# 2  <$> const(IV 1) s
# 3  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

pass("rpeep - if ($a || $b)");

checkOptree ( name	=> 'if ($a || $b) { } return 1',
	      code	=> 'if ($a || $b) { } return 1',
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 997 (eval 15):1) v
# 2  <#> gvsv[*a] s
# 3  <|> or(other->4) sK/1
# 4      <#> gvsv[*b] s
# 5      <|> and(other->6) vK/1
# 6  <0> stub v
# 7  <;> nextstate(main 997 (eval 15):1) v
# 8  <$> const[IV 1] s
# 9  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 997 (eval 15):1) v
# 2  <$> gvsv(*a) s
# 3  <|> or(other->4) sK/1
# 4      <$> gvsv(*b) s
# 5      <|> and(other->6) vK/1
# 6  <0> stub v
# 7  <;> nextstate(main 3 (eval 3):1) v
# 8  <$> const(IV 1) s
# 9  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

pass("rpeep - unless ($a && $b)");

checkOptree ( name	=> 'unless ($a && $b) { } return 1',
	      code	=> 'unless ($a && $b) { } return 1',
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 997 (eval 15):1) v
# 2  <#> gvsv[*a] s
# 3  <|> and(other->4) sK/1
# 4      <#> gvsv[*b] s
# 5      <|> or(other->6) vK/1
# 6  <0> stub v
# 7  <;> nextstate(main 997 (eval 15):1) v
# 8  <$> const[IV 1] s
# 9  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 997 (eval 15):1) v
# 2  <$> gvsv(*a) s
# 3  <|> and(other->4) sK/1
# 4      <$> gvsv(*b) s
# 5      <|> or(other->6) vK/1
# 6  <0> stub v
# 7  <;> nextstate(main 3 (eval 3):1) v
# 8  <$> const(IV 1) s
# 9  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

pass("rpeep - my $a; my @@b; my %c; print 'f'");

checkOptree ( name	=> 'my $a; my @@b; my %c; return 1',
	      code	=> 'my $a; my @@b; my %c; return 1',
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 991 (eval 17):1) v
# 2  <0> padrange[$a:991,994; @@b:992,994; %c:993,994] vM/LVINTRO,3
# 3  <;> nextstate(main 994 (eval 17):1) v:{
# 4  <$> const[IV 1] s
# 5  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 991 (eval 17):1) v
# 2  <0> padrange[$a:991,994; @@b:992,994; %c:993,994] vM/LVINTRO,3
# 3  <;> nextstate(main 994 (eval 17):1) v:{
# 4  <$> const(IV 1) s
# 5  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

__END__

#######################################################################

checkOptree ( name	=> '-exec sub a { print (shift) ? "foo" : "bar" }',
	      code	=> sub { print (shift) ? "foo" : "bar" },
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
   insert threaded reference here
EOT_EOT
   insert non-threaded reference here
EONT_EONT

@


1.1
log
@Initial revision
@
text
@d4 1
a4 2
    chdir 't';
    @@INC = ('../lib', '../ext/B/t');
d10 2
a11 2
    if ($] < 5.009) {
        print "1..0 # Skip -- TODO - provide golden result regexps for 5.8\n";
a13 1
    require './test.pl';
d17 1
a17 3
plan tests	=> 20;
SKIP: {
    skip "no perlio in this build", 20 unless $Config::Config{useperlio};
d28 1
d30 3
a32 3
# 9  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->9
# 1        <;> nextstate(main 426 optree.t:16) v ->2
d34 2
a35 4
# 5           <|> cond_expr(other->6) K/1 ->a
# 4              <1> shift sK/1 ->5
# 3                 <1> rv2av[t2] sKRM/1 ->4
# 2                    <#> gv[*_] s ->3
d37 14
a50 14
# -                 <0> ex-nextstate v ->6
# 8                 <@@> print sK ->9
# 6                    <0> pushmark s ->7
# 7                    <$> const[PV "then"] s ->8
# f              <@@> leave KP ->9
# a                 <0> enter ->b
# b                 <;> nextstate(main 424 optree.t:17) v ->c
# e                 <@@> print sK ->f
# c                    <0> pushmark s ->d
# d                    <$> const[PV "else"] s ->e
EOT_EOT
# 9  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->9
# 1        <;> nextstate(main 427 optree_samples.t:18) v ->2
d52 2
a53 4
# 5           <|> cond_expr(other->6) K/1 ->a
# 4              <1> shift sK/1 ->5
# 3                 <1> rv2av[t1] sKRM/1 ->4
# 2                    <$> gv(*_) s ->3
d55 10
a64 10
# -                 <0> ex-nextstate v ->6
# 8                 <@@> print sK ->9
# 6                    <0> pushmark s ->7
# 7                    <$> const(PV "then") s ->8
# f              <@@> leave KP ->9
# a                 <0> enter ->b
# b                 <;> nextstate(main 425 optree_samples.t:19) v ->c
# e                 <@@> print sK ->f
# c                    <0> pushmark s ->d
# d                    <$> const(PV "else") s ->e
d73 1
d75 7
a81 9
# d  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->d
# 1        <;> nextstate(main 431 optree.t:68) v ->2
# 6        <2> sassign vKS/2 ->7
# 4           <1> shift sK/1 ->5
# 3              <1> rv2av[t3] sKRM/1 ->4
# 2                 <#> gv[*_] s ->3
# 5           <0> padsv[$a:431,435] sRM*/LVINTRO ->6
# 7        <;> nextstate(main 435 optree.t:69) v ->8
d83 2
a84 2
# 9           <|> cond_expr(other->a) K/1 ->e
# 8              <0> padsv[$a:431,435] s ->9
d86 18
a103 20
# -                 <0> ex-nextstate v ->a
# c                 <@@> print sK ->d
# a                    <0> pushmark s ->b
# b                    <$> const[PV "foo"] s ->c
# j              <@@> leave KP ->d
# e                 <0> enter ->f
# f                 <;> nextstate(main 433 optree.t:70) v ->g
# i                 <@@> print sK ->j
# g                    <0> pushmark s ->h
# h                    <$> const[PV "bar"] s ->i
EOT_EOT
# d  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->d
# 1        <;> nextstate(main 428 optree_samples.t:48) v ->2
# 6        <2> sassign vKS/2 ->7
# 4           <1> shift sK/1 ->5
# 3              <1> rv2av[t2] sKRM/1 ->4
# 2                 <$> gv(*_) s ->3
# 5           <0> padsv[$a:428,432] sRM*/LVINTRO ->6
# 7        <;> nextstate(main 432 optree_samples.t:49) v ->8
d105 2
a106 2
# 9           <|> cond_expr(other->a) K/1 ->e
# 8              <0> padsv[$a:428,432] s ->9
d108 10
a117 10
# -                 <0> ex-nextstate v ->a
# c                 <@@> print sK ->d
# a                    <0> pushmark s ->b
# b                    <$> const(PV "foo") s ->c
# j              <@@> leave KP ->d
# e                 <0> enter ->f
# f                 <;> nextstate(main 430 optree_samples.t:50) v ->g
# i                 <@@> print sK ->j
# g                    <0> pushmark s ->h
# h                    <$> const(PV "bar") s ->i
d125 1
d127 29
a155 33
# 1  <;> nextstate(main 426 optree.t:16) v
# 2  <#> gv[*_] s
# 3  <1> rv2av[t2] sKRM/1
# 4  <1> shift sK/1
# 5  <|> cond_expr(other->6) K/1
# 6      <0> pushmark s
# 7      <$> const[PV "then"] s
# 8      <@@> print sK
#            goto 9
# a  <0> enter 
# b  <;> nextstate(main 424 optree.t:17) v
# c  <0> pushmark s
# d  <$> const[PV "else"] s
# e  <@@> print sK
# f  <@@> leave KP
# 9  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 436 optree_samples.t:123) v
# 2  <$> gv(*_) s
# 3  <1> rv2av[t1] sKRM/1
# 4  <1> shift sK/1
# 5  <|> cond_expr(other->6) K/1
# 6      <0> pushmark s
# 7      <$> const(PV "then") s
# 8      <@@> print sK
#            goto 9
# a  <0> enter 
# b  <;> nextstate(main 434 optree_samples.t:124) v
# c  <0> pushmark s
# d  <$> const(PV "else") s
# e  <@@> print sK
# f  <@@> leave KP
# 9  <1> leavesub[1 ref] K/REFC,1
d164 1
d166 37
a202 41
# 1  <;> nextstate(main 423 optree.t:16) v
# 2  <#> gv[*_] s
# 3  <1> rv2av[t3] sKRM/1
# 4  <1> shift sK/1
# 5  <0> padsv[$a:423,427] sRM*/LVINTRO
# 6  <2> sassign vKS/2
# 7  <;> nextstate(main 427 optree.t:17) v
# 8  <0> padsv[$a:423,427] s
# 9  <|> cond_expr(other->a) K/1
# a      <0> pushmark s
# b      <$> const[PV "foo"] s
# c      <@@> print sK
#            goto d
# e  <0> enter 
# f  <;> nextstate(main 425 optree.t:18) v
# g  <0> pushmark s
# h  <$> const[PV "bar"] s
# i  <@@> print sK
# j  <@@> leave KP
# d  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 437 optree_samples.t:112) v
# 2  <$> gv(*_) s
# 3  <1> rv2av[t2] sKRM/1
# 4  <1> shift sK/1
# 5  <0> padsv[$a:437,441] sRM*/LVINTRO
# 6  <2> sassign vKS/2
# 7  <;> nextstate(main 441 optree_samples.t:113) v
# 8  <0> padsv[$a:437,441] s
# 9  <|> cond_expr(other->a) K/1
# a      <0> pushmark s
# b      <$> const(PV "foo") s
# c      <@@> print sK
#            goto d
# e  <0> enter 
# f  <;> nextstate(main 439 optree_samples.t:114) v
# g  <0> pushmark s
# h  <$> const(PV "bar") s
# i  <@@> print sK
# j  <@@> leave KP
# d  <1> leavesub[1 ref] K/REFC,1
d208 1
d210 1
a210 1
# 1  <;> nextstate(main 428 optree.t:31) v
d212 7
a218 9
# 3  <#> gv[*_] s
# 4  <1> rv2av[t2] sKRM/1
# 5  <1> shift sK/1
# 6  <@@> print sK
# 7  <|> cond_expr(other->8) K/1
# 8      <$> const[PV "foo"] s
#            goto 9
# a  <$> const[PV "bar"] s
# 9  <1> leavesub[1 ref] K/REFC,1
d220 1
a220 1
# 1  <;> nextstate(main 442 optree_samples.t:144) v
d222 7
a228 9
# 3  <$> gv(*_) s
# 4  <1> rv2av[t1] sKRM/1
# 5  <1> shift sK/1
# 6  <@@> print sK
# 7  <|> cond_expr(other->8) K/1
# 8      <$> const(PV "foo") s
#            goto 9
# a  <$> const(PV "bar") s
# 9  <1> leavesub[1 ref] K/REFC,1
d236 1
d238 1
a238 1
# 1  <;> nextstate(main 443 optree.t:158) v
d243 1
a243 1
# 6  <{> enteriter(next->d last->g redo->7) lKS
d246 1
a246 1
# 7      <;> nextstate(main 442 optree.t:158) v
d257 1
a257 1
# 1  <;> nextstate(main 444 optree_samples.t:182) v
d262 1
a262 1
# 6  <{> enteriter(next->d last->g redo->7) lKS
d265 1
a265 1
# 7      <;> nextstate(main 443 optree_samples.t:182) v
d280 1
d282 14
a295 15
# h  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->h
# 1        <;> nextstate(main 445 optree.t:167) v ->2
# 2        <;> nextstate(main 445 optree.t:167) v ->3
# g        <2> leaveloop K/2 ->h
# 7           <{> enteriter(next->d last->g redo->8) lKS ->e
# -              <0> ex-pushmark s ->3
# -              <1> ex-list lK ->6
# 3                 <0> pushmark s ->4
# 4                 <$> const[IV 1] s ->5
# 5                 <$> const[IV 10] s ->6
# 6              <#> gv[*_] s ->7
# -           <1> null K/1 ->g
# f              <|> and(other->8) K/1 ->g
# e                 <0> iter s ->f
d297 24
a320 25
# c                    <@@> print vK ->d
# 8                       <0> pushmark s ->9
# -                       <1> ex-stringify sK/1 ->c
# -                          <0> ex-pushmark s ->9
# b                          <2> concat[t2] sK/2 ->c
# 9                             <$> const[PV "foo "] s ->a
# -                             <1> ex-rv2sv sK/1 ->b
# a                                <#> gvsv[*_] s ->b
# d                    <0> unstack s ->e
EOT_EOT
# h  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->h
# 1        <;> nextstate(main 446 optree_samples.t:192) v ->2
# 2        <;> nextstate(main 446 optree_samples.t:192) v ->3
# g        <2> leaveloop K/2 ->h
# 7           <{> enteriter(next->d last->g redo->8) lKS ->e
# -              <0> ex-pushmark s ->3
# -              <1> ex-list lK ->6
# 3                 <0> pushmark s ->4
# 4                 <$> const(IV 1) s ->5
# 5                 <$> const(IV 10) s ->6
# 6              <$> gv(*_) s ->7
# -           <1> null K/1 ->g
# f              <|> and(other->8) K/1 ->g
# e                 <0> iter s ->f
d322 9
a330 9
# c                    <@@> print vK ->d
# 8                       <0> pushmark s ->9
# -                       <1> ex-stringify sK/1 ->c
# -                          <0> ex-pushmark s ->9
# b                          <2> concat[t1] sK/2 ->c
# 9                             <$> const(PV "foo ") s ->a
# -                             <1> ex-rv2sv sK/1 ->b
# a                                <$> gvsv(*_) s ->b
# d                    <0> unstack s ->e
d336 1
d339 1
a339 1
# 2  <;> nextstate(main 2 -e:1) v
d344 1
a344 1
# 7  <{> enteriter(next->e last->h redo->8) lKS
d347 1
a347 1
# 8      <;> nextstate(main 1 -e:1) v
d359 1
a359 1
# 2  <;> nextstate(main 2 -e:1) v
d364 1
a364 1
# 7  <{> enteriter(next->e last->h redo->8) lKS
d367 1
a367 1
# 8      <;> nextstate(main 1 -e:1) v
d382 1
d384 17
a400 18
# 1  <;> nextstate(main 445 optree.t:167) v
# 2  <;> nextstate(main 445 optree.t:167) v
# 3  <0> pushmark s
# 4  <$> const[IV 1] s
# 5  <$> const[IV 10] s
# 6  <#> gv[*_] s
# 7  <{> enteriter(next->d last->g redo->8) lKS
# e  <0> iter s
# f  <|> and(other->8) K/1
# 8      <0> pushmark s
# 9      <$> const[PV "foo "] s
# a      <#> gvsv[*_] s
# b      <2> concat[t2] sK/2
# c      <@@> print vK
# d      <0> unstack s
#            goto e
# g  <2> leaveloop K/2
# h  <1> leavesub[1 ref] K/REFC,1
d402 17
a418 18
# 1  <;> nextstate(main 447 optree_samples.t:252) v
# 2  <;> nextstate(main 447 optree_samples.t:252) v
# 3  <0> pushmark s
# 4  <$> const(IV 1) s
# 5  <$> const(IV 10) s
# 6  <$> gv(*_) s
# 7  <{> enteriter(next->d last->g redo->8) lKS
# e  <0> iter s
# f  <|> and(other->8) K/1
# 8      <0> pushmark s
# 9      <$> const(PV "foo ") s
# a      <$> gvsv(*_) s
# b      <2> concat[t1] sK/2
# c      <@@> print vK
# d      <0> unstack s
#            goto e
# g  <2> leaveloop K/2
# h  <1> leavesub[1 ref] K/REFC,1
d427 1
a427 1
# 1  <;> nextstate(main 496 (eval 20):1) v
d440 1
a440 1
# d  <2> aassign[t6] KS/COMMON
d443 1
a443 1
# 1  <;> nextstate(main 496 (eval 20):1) v
d456 1
a456 1
# d  <2> aassign[t4] KS/COMMON
d467 1
a467 1
# 1  <;> nextstate(main 501 (eval 22):1) v
d472 2
a473 1
# 6  <@@> mapstart lK*
d476 1
a476 1
# 9      <;> nextstate(main 500 (eval 22):1) v
d478 5
a482 7
# b      <0> pushmark s
# c      <#> gvsv[*_] s
# d      <#> gv[*getkey] s/EARLYCV
# e      <1> entersub[t5] lKS/TARG,1
# f      <#> gvsv[*_] s
# g      <@@> list lK
# h      <@@> leave lKP
d484 6
a489 5
# i  <0> pushmark s
# j  <#> gv[*h] s
# k  <1> rv2hv[t2] lKRM*/1
# l  <2> aassign[t10] KS/COMMON
# m  <1> leavesub[1 ref] K/REFC,1
d491 1
a491 1
# 1  <;> nextstate(main 501 (eval 22):1) v
d496 2
a497 1
# 6  <@@> mapstart lK*
d500 1
a500 1
# 9      <;> nextstate(main 500 (eval 22):1) v
d502 5
a506 7
# b      <0> pushmark s
# c      <$> gvsv(*_) s
# d      <$> gv(*getkey) s/EARLYCV
# e      <1> entersub[t2] lKS/TARG,1
# f      <$> gvsv(*_) s
# g      <@@> list lK
# h      <@@> leave lKP
d508 6
a513 5
# i  <0> pushmark s
# j  <$> gv(*h) s
# k  <1> rv2hv[t1] lKRM*/1
# l  <2> aassign[t5] KS/COMMON
# m  <1> leavesub[1 ref] K/REFC,1
d524 2
a525 1
# 5  <1> rv2hv[t2] lKRM*/1
d527 1
a527 1
# 7  <;> nextstate(main 506 (eval 24):1) v
d533 1
a533 1
# d  <{> enteriter(next->o last->r redo->e) lKS
d536 1
a536 1
# e      <;> nextstate(main 505 (eval 24):1) v
d543 1
a543 1
# l      <1> entersub[t10] sKS/TARG,1
d548 1
a548 1
# r  <2> leaveloop K/2
d555 2
a556 1
# 5  <1> rv2hv[t1] lKRM*/1
d558 1
a558 1
# 7  <;> nextstate(main 506 (eval 24):1) v
d564 1
a564 1
# d  <{> enteriter(next->o last->r redo->e) lKS
d567 1
a567 1
# e      <;> nextstate(main 505 (eval 24):1) v
d574 1
a574 1
# l      <1> entersub[t4] sKS/TARG,1
d579 1
a579 1
# r  <2> leaveloop K/2
d592 1
a592 1
# 6  <|> mapwhile(other->7)[t7] K
d617 1
d620 1
a620 1
# 2  <;> nextstate(main 71 -e:1) v
d622 2
a623 1
# 4  <$> const[PV "junk"] s
d628 1
a628 1
# 2  <;> nextstate(main 71 -e:1) v
d630 2
a631 1
# 4  <$> const(PV "junk") s
d636 88
a723 1
} # skip
@


1.1.1.1
log
@perl 5.8.6 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.8 import
@
text
@d4 2
a5 7
    if ($ENV{PERL_CORE}){
	chdir('t') if -d 't';
	@@INC = ('.', '../lib', '../ext/B/t');
    } else {
	unshift @@INC, 't';
	push @@INC, "../../t";
    }
d11 5
a15 1
    # require 'test.pl'; # now done by OptreeCheck
d609 1
a609 1
# 6  <|> mapwhile(other->7)[t5] K
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@a32 1
	      strip_open_hints => 1,
d36 1
a36 1
# 1        <;> nextstate(main 426 optree.t:16) v:>,<,% ->2
d49 1
a49 1
# b                 <;> nextstate(main 424 optree.t:17) v:>,<,% ->c
d56 1
a56 1
# 1        <;> nextstate(main 427 optree_samples.t:18) v:>,<,% ->2
d69 1
a69 1
# b                 <;> nextstate(main 425 optree_samples.t:19) v:>,<,% ->c
a80 1
	      strip_open_hints => 1,
d84 1
a84 1
# 1        <;> nextstate(main 431 optree.t:68) v:>,<,% ->2
d90 1
a90 1
# 7        <;> nextstate(main 435 optree.t:69) v:>,<,% ->8
d101 1
a101 1
# f                 <;> nextstate(main 433 optree.t:70) v:>,<,% ->g
d108 1
a108 1
# 1        <;> nextstate(main 428 optree_samples.t:48) v:>,<,% ->2
d114 1
a114 1
# 7        <;> nextstate(main 432 optree_samples.t:49) v:>,<,% ->8
d125 1
a125 1
# f                 <;> nextstate(main 430 optree_samples.t:50) v:>,<,% ->g
a135 1
	      strip_open_hints => 1,
d137 1
a137 1
# 1  <;> nextstate(main 426 optree.t:16) v:>,<,%
d147 1
a147 1
# b  <;> nextstate(main 424 optree.t:17) v:>,<,%
d154 1
a154 1
# 1  <;> nextstate(main 436 optree_samples.t:123) v:>,<,%
d164 1
a164 1
# b  <;> nextstate(main 434 optree_samples.t:124) v:>,<,%
a177 1
	      strip_open_hints => 1,
d179 1
a179 1
# 1  <;> nextstate(main 423 optree.t:16) v:>,<,%
d185 1
a185 1
# 7  <;> nextstate(main 427 optree.t:17) v:>,<,%
d193 1
a193 1
# f  <;> nextstate(main 425 optree.t:18) v:>,<,%
d200 1
a200 1
# 1  <;> nextstate(main 437 optree_samples.t:112) v:>,<,%
d206 1
a206 1
# 7  <;> nextstate(main 441 optree_samples.t:113) v:>,<,%
d214 1
a214 1
# f  <;> nextstate(main 439 optree_samples.t:114) v:>,<,%
a224 1
	      strip_open_hints => 1,
d226 1
a226 1
# 1  <;> nextstate(main 428 optree.t:31) v:>,<,%
d238 1
a238 1
# 1  <;> nextstate(main 442 optree_samples.t:144) v:>,<,%
a255 1
	      strip_open_hints => 1,
d257 1
a257 1
# 1  <;> nextstate(main 443 optree.t:158) v:>,<,%
d262 1
a262 1
# 6  <{> enteriter(next->d last->g redo->7) lKS/8
d265 1
a265 1
# 7      <;> nextstate(main 442 optree.t:158) v:>,<,%
d276 1
a276 1
# 1  <;> nextstate(main 444 optree_samples.t:182) v:>,<,%
d281 1
a281 1
# 6  <{> enteriter(next->d last->g redo->7) lKS/8
d284 1
a284 1
# 7      <;> nextstate(main 443 optree_samples.t:182) v:>,<,%
a298 1
	      strip_open_hints => 1,
d302 2
a303 2
# 1        <;> nextstate(main 445 optree.t:167) v:>,<,% ->2
# 2        <;> nextstate(main 445 optree.t:167) v:>,<,% ->3
d305 1
a305 1
# 7           <{> enteriter(next->d last->g redo->8) lKS/8 ->e
d328 2
a329 2
# 1        <;> nextstate(main 446 optree_samples.t:192) v:>,<,% ->2
# 2        <;> nextstate(main 446 optree_samples.t:192) v:>,<,% ->3
d331 1
a331 1
# 7           <{> enteriter(next->d last->g redo->8) lKS/8 ->e
a355 1
	      strip_open_hints => 1,
d358 1
a358 1
# 2  <;> nextstate(main 2 -e:1) v:>,<,%
d363 1
a363 1
# 7  <{> enteriter(next->e last->h redo->8) lKS/8
d366 1
a366 1
# 8      <;> nextstate(main 1 -e:1) v:>,<,%
d378 1
a378 1
# 2  <;> nextstate(main 2 -e:1) v:>,<,%
d383 1
a383 1
# 7  <{> enteriter(next->e last->h redo->8) lKS/8
d386 1
a386 1
# 8      <;> nextstate(main 1 -e:1) v:>,<,%
a400 1
	      strip_open_hints => 1,
d402 2
a403 2
# 1  <;> nextstate(main 445 optree.t:167) v:>,<,%
# 2  <;> nextstate(main 445 optree.t:167) v:>,<,%
d408 1
a408 1
# 7  <{> enteriter(next->d last->g redo->8) lKS/8
d421 2
a422 2
# 1  <;> nextstate(main 447 optree_samples.t:252) v:>,<,%
# 2  <;> nextstate(main 447 optree_samples.t:252) v:>,<,%
d427 1
a427 1
# 7  <{> enteriter(next->d last->g redo->8) lKS/8
d447 1
a447 1
# 1  <;> nextstate(main 496 (eval 20):1) v:{
d463 1
a463 1
# 1  <;> nextstate(main 496 (eval 20):1) v:{
d487 1
a487 1
# 1  <;> nextstate(main 501 (eval 22):1) v:{
d495 1
a495 1
# 9      <;> nextstate(main 500 (eval 22):1) v:{
d511 1
a511 1
# 1  <;> nextstate(main 501 (eval 22):1) v:{
d519 1
a519 1
# 9      <;> nextstate(main 500 (eval 22):1) v:{
d546 1
a546 1
# 7  <;> nextstate(main 506 (eval 24):1) v:{
d552 1
a552 1
# d  <{> enteriter(next->o last->r redo->e) lKS/8
d555 1
a555 1
# e      <;> nextstate(main 505 (eval 24):1) v:{
d576 1
a576 1
# 7  <;> nextstate(main 506 (eval 24):1) v:{
d582 1
a582 1
# d  <{> enteriter(next->o last->r redo->e) lKS/8
d585 1
a585 1
# e      <;> nextstate(main 505 (eval 24):1) v:{
a634 1
	      strip_open_hints => 1,
d637 1
a637 1
# 2  <;> nextstate(main 71 -e:1) v:>,<,%,{
d644 1
a644 1
# 2  <;> nextstate(main 71 -e:1) v:>,<,%,{
@


1.1.1.4
log
@Perl 5.12.2 from CPAN
@
text
@d4 7
a10 1
    unshift @@INC, 't';
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d10 1
a10 4
    if (!$Config::Config{useperlio}) {
        print "1..0 # Skip -- need perlio to walk the optree\n";
        exit 0;
    }
d14 3
a16 1
plan tests	=> 34;
d29 3
a31 3
# 7  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->7
# 1        <;> nextstate(main 665 optree_samples.t:24) v:>,<,% ->2
d33 4
a36 2
# 3           <|> cond_expr(other->4) K/1 ->8
# 2              <0> shift s* ->3
d38 14
a51 14
# -                 <0> ex-nextstate v ->4
# 6                 <@@> print sK ->7
# 4                    <0> pushmark s ->5
# 5                    <$> const[PV "then"] s ->6
# d              <@@> leave KP ->7
# 8                 <0> enter ->9
# 9                 <;> nextstate(main 663 optree_samples.t:25) v:>,<,% ->a
# c                 <@@> print sK ->d
# a                    <0> pushmark s ->b
# b                    <$> const[PV "else"] s ->c
EOT_EOT
# 7  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->7
# 1        <;> nextstate(main 665 optree_samples.t:24) v:>,<,% ->2
d53 4
a56 2
# 3           <|> cond_expr(other->4) K/1 ->8
# 2              <0> shift s* ->3
d58 10
a67 10
# -                 <0> ex-nextstate v ->4
# 6                 <@@> print sK ->7
# 4                    <0> pushmark s ->5
# 5                    <$> const(PV "then") s ->6
# d              <@@> leave KP ->7
# 8                 <0> enter ->9
# 9                 <;> nextstate(main 663 optree_samples.t:25) v:>,<,% ->a
# c                 <@@> print sK ->d
# a                    <0> pushmark s ->b
# b                    <$> const(PV "else") s ->c
d78 9
a86 7
# b  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->b
# 1        <;> nextstate(main 666 optree_samples.t:70) v:>,<,% ->2
# 4        <2> sassign vKS/2 ->5
# 2           <0> shift s* ->3
# 3           <0> padsv[$a:666,670] sRM*/LVINTRO ->4
# 5        <;> nextstate(main 670 optree_samples.t:71) v:>,<,% ->6
d88 2
a89 2
# 7           <|> cond_expr(other->8) K/1 ->c
# 6              <0> padsv[$a:666,670] s ->7
d91 20
a110 18
# -                 <0> ex-nextstate v ->8
# a                 <@@> print sK ->b
# 8                    <0> pushmark s ->9
# 9                    <$> const[PV "foo"] s ->a
# h              <@@> leave KP ->b
# c                 <0> enter ->d
# d                 <;> nextstate(main 668 optree_samples.t:72) v:>,<,% ->e
# g                 <@@> print sK ->h
# e                    <0> pushmark s ->f
# f                    <$> const[PV "bar"] s ->g
EOT_EOT
# b  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->b
# 1        <;> nextstate(main 666 optree_samples.t:72) v:>,<,% ->2
# 4        <2> sassign vKS/2 ->5
# 2           <0> shift s* ->3
# 3           <0> padsv[$a:666,670] sRM*/LVINTRO ->4
# 5        <;> nextstate(main 670 optree_samples.t:73) v:>,<,% ->6
d112 2
a113 2
# 7           <|> cond_expr(other->8) K/1 ->c
# 6              <0> padsv[$a:666,670] s ->7
d115 10
a124 10
# -                 <0> ex-nextstate v ->8
# a                 <@@> print sK ->b
# 8                    <0> pushmark s ->9
# 9                    <$> const(PV "foo") s ->a
# h              <@@> leave KP ->b
# c                 <0> enter ->d
# d                 <;> nextstate(main 668 optree_samples.t:74) v:>,<,% ->e
# g                 <@@> print sK ->h
# e                    <0> pushmark s ->f
# f                    <$> const(PV "bar") s ->g
d134 33
a166 29
# 1  <;> nextstate(main 674 optree_samples.t:125) v:>,<,%
# 2  <0> shift s*
# 3  <|> cond_expr(other->4) K/1
# 4      <0> pushmark s
# 5      <$> const[PV "then"] s
# 6      <@@> print sK
#            goto 7
# 8  <0> enter 
# 9  <;> nextstate(main 672 optree_samples.t:126) v:>,<,%
# a  <0> pushmark s
# b  <$> const[PV "else"] s
# c  <@@> print sK
# d  <@@> leave KP
# 7  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 674 optree_samples.t:129) v:>,<,%
# 2  <0> shift s*
# 3  <|> cond_expr(other->4) K/1
# 4      <0> pushmark s
# 5      <$> const(PV "then") s
# 6      <@@> print sK
#            goto 7
# 8  <0> enter 
# 9  <;> nextstate(main 672 optree_samples.t:130) v:>,<,%
# a  <0> pushmark s
# b  <$> const(PV "else") s
# c  <@@> print sK
# d  <@@> leave KP
# 7  <1> leavesub[1 ref] K/REFC,1
d177 41
a217 37
# 1  <;> nextstate(main 675 optree_samples.t:165) v:>,<,%
# 2  <0> shift s*
# 3  <0> padsv[$a:675,679] sRM*/LVINTRO
# 4  <2> sassign vKS/2
# 5  <;> nextstate(main 679 optree_samples.t:166) v:>,<,%
# 6  <0> padsv[$a:675,679] s
# 7  <|> cond_expr(other->8) K/1
# 8      <0> pushmark s
# 9      <$> const[PV "foo"] s
# a      <@@> print sK
#            goto b
# c  <0> enter 
# d  <;> nextstate(main 677 optree_samples.t:167) v:>,<,%
# e  <0> pushmark s
# f  <$> const[PV "bar"] s
# g  <@@> print sK
# h  <@@> leave KP
# b  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 675 optree_samples.t:171) v:>,<,%
# 2  <0> shift s*
# 3  <0> padsv[$a:675,679] sRM*/LVINTRO
# 4  <2> sassign vKS/2
# 5  <;> nextstate(main 679 optree_samples.t:172) v:>,<,%
# 6  <0> padsv[$a:675,679] s
# 7  <|> cond_expr(other->8) K/1
# 8      <0> pushmark s
# 9      <$> const(PV "foo") s
# a      <@@> print sK
#            goto b
# c  <0> enter 
# d  <;> nextstate(main 677 optree_samples.t:173) v:>,<,%
# e  <0> pushmark s
# f  <$> const(PV "bar") s
# g  <@@> print sK
# h  <@@> leave KP
# b  <1> leavesub[1 ref] K/REFC,1
d225 1
a225 1
# 1  <;> nextstate(main 680 optree_samples.t:213) v:>,<,%
d227 21
a247 17
# 3  <0> shift s*
# 4  <@@> print sK
# 5  <|> cond_expr(other->6) K/1
# 6      <$> const[PV "foo"] s
#            goto 7
# 8  <$> const[PV "bar"] s
# 7  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 680 optree_samples.t:221) v:>,<,%
# 2  <0> pushmark s
# 3  <0> shift s*
# 4  <@@> print sK
# 5  <|> cond_expr(other->6) K/1
# 6      <$> const(PV "foo") s
#            goto 7
# 8  <$> const(PV "bar") s
# 7  <1> leavesub[1 ref] K/REFC,1
d301 2
a302 2
# g  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->g
d304 12
a315 11
# f        <2> leaveloop K/2 ->g
# 6           <{> enteriter(next->c last->f redo->7) lKS/8 ->d
# -              <0> ex-pushmark s ->2
# -              <1> ex-list lK ->5
# 2                 <0> pushmark s ->3
# 3                 <$> const[IV 1] s ->4
# 4                 <$> const[IV 10] s ->5
# 5              <#> gv[*_] s ->6
# -           <1> null K/1 ->f
# e              <|> and(other->7) K/1 ->f
# d                 <0> iter s ->e
d317 9
a325 9
# b                    <@@> print vK ->c
# 7                       <0> pushmark s ->8
# -                       <1> ex-stringify sK/1 ->b
# -                          <0> ex-pushmark s ->8
# a                          <2> concat[t2] sK/2 ->b
# 8                             <$> const[PV "foo "] s ->9
# -                             <1> ex-rv2sv sK/1 ->a
# 9                                <#> gvsv[*_] s ->a
# c                    <0> unstack s ->d
d327 2
a328 2
# g  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->g
d330 12
a341 11
# f        <2> leaveloop K/2 ->g
# 6           <{> enteriter(next->c last->f redo->7) lKS/8 ->d
# -              <0> ex-pushmark s ->2
# -              <1> ex-list lK ->5
# 2                 <0> pushmark s ->3
# 3                 <$> const(IV 1) s ->4
# 4                 <$> const(IV 10) s ->5
# 5              <$> gv(*_) s ->6
# -           <1> null K/1 ->f
# e              <|> and(other->7) K/1 ->f
# d                 <0> iter s ->e
d343 9
a351 9
# b                    <@@> print vK ->c
# 7                       <0> pushmark s ->8
# -                       <1> ex-stringify sK/1 ->b
# -                          <0> ex-pushmark s ->8
# a                          <2> concat[t1] sK/2 ->b
# 8                             <$> const(PV "foo ") s ->9
# -                             <1> ex-rv2sv sK/1 ->a
# 9                                <$> gvsv(*_) s ->a
# c                    <0> unstack s ->d
d360 1
a360 1
# 2  <;> nextstate(main 2 -e:1) v:>,<,%,{
d380 1
a380 1
# 2  <;> nextstate(main 2 -e:1) v:>,<,%,{
d406 17
a422 16
# 2  <0> pushmark s
# 3  <$> const[IV 1] s
# 4  <$> const[IV 10] s
# 5  <#> gv[*_] s
# 6  <{> enteriter(next->c last->f redo->7) lKS/8
# d  <0> iter s
# e  <|> and(other->7) K/1
# 7      <0> pushmark s
# 8      <$> const[PV "foo "] s
# 9      <#> gvsv[*_] s
# a      <2> concat[t2] sK/2
# b      <@@> print vK
# c      <0> unstack s
#            goto d
# f  <2> leaveloop K/2
# g  <1> leavesub[1 ref] K/REFC,1
d425 17
a441 16
# 2  <0> pushmark s
# 3  <$> const(IV 1) s
# 4  <$> const(IV 10) s
# 5  <$> gv(*_) s
# 6  <{> enteriter(next->c last->f redo->7) lKS/8
# d  <0> iter s
# e  <|> and(other->7) K/1
# 7      <0> pushmark s
# 8      <$> const(PV "foo ") s
# 9      <$> gvsv(*_) s
# a      <2> concat[t1] sK/2
# b      <@@> print vK
# c      <0> unstack s
#            goto d
# f  <2> leaveloop K/2
# g  <1> leavesub[1 ref] K/REFC,1
d503 1
a503 1
# e      <1> entersub[t5] lKS/TARG
d527 1
a527 1
# e      <1> entersub[t2] lKS/TARG
d565 1
a565 1
# l      <1> entersub[t10] sKS/TARG
d570 1
a570 1
# r  <2> leaveloop KP/2
d595 1
a595 1
# l      <1> entersub[t4] sKS/TARG
d600 1
a600 1
# r  <2> leaveloop KP/2
d643 1
a643 1
# 4  <$> const[PV "junk"] s*
d650 1
a650 1
# 4  <$> const(PV "junk") s*
d654 2
@


1.1.1.6
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d472 1
a472 2
# 6  <@@> mapstart lK*                 < 5.017002
# 6  <@@> mapstart lK                  >=5.017002
d496 1
a496 2
# 6  <@@> mapstart lK*                 < 5.017002
# 6  <@@> mapstart lK                  >=5.017002
d620 1
a620 2
# 4  <$> const[PV "junk"] s*      < 5.017002
# 4  <$> const[PV "junk"] s*/FOLD >=5.017002
d627 1
a627 2
# 4  <$> const(PV "junk") s*      < 5.017002
# 4  <$> const(PV "junk") s*/FOLD >=5.017002
@


1.1.1.7
log
@Import perl-5.20.1
@
text
@d17 1
a17 1
plan tests	=> 46;
d478 7
a484 5
# b      <#> gvsv[*_] s
# c      <#> gv[*getkey] s/EARLYCV
# d      <1> entersub[t5] lKS/TARG
# e      <#> gvsv[*_] s
# f      <@@> leave lKP
d486 5
a490 6
# g  <0> pushmark s
# h  <#> gv[*h] s
# i  <1> rv2hv[t2] lKRM*/1         < 5.019006
# i  <1> rv2hv lKRM*/1             >=5.019006
# j  <2> aassign[t10] KS/COMMON
# k  <1> leavesub[1 ref] K/REFC,1
d503 7
a509 5
# b      <$> gvsv(*_) s
# c      <$> gv(*getkey) s/EARLYCV
# d      <1> entersub[t2] lKS/TARG
# e      <$> gvsv(*_) s
# f      <@@> leave lKP
d511 5
a515 6
# g  <0> pushmark s
# h  <$> gv(*h) s
# i  <1> rv2hv[t1] lKRM*/1         < 5.019006
# i  <1> rv2hv lKRM*/1             >=5.019006
# j  <2> aassign[t5] KS/COMMON
# k  <1> leavesub[1 ref] K/REFC,1
d526 1
a526 2
# 5  <1> rv2hv[t2] lKRM*/1         < 5.019006
# 5  <1> rv2hv lKRM*/1             >=5.019006
d556 1
a556 2
# 5  <1> rv2hv[t1] lKRM*/1         < 5.019006
# 5  <1> rv2hv lKRM*/1             >=5.019006
a633 89
EONT_EONT

pass("rpeep - return \$x at end of sub");

checkOptree ( name	=> '-exec sub { return 1 }',
	      code	=> sub { return 1 },
	      bcopts	=> '-exec',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 1 -e:1) v:>,<,%
# 2  <$> const[IV 1] s
# 3  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 1 -e:1) v:>,<,%
# 2  <$> const(IV 1) s
# 3  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

pass("rpeep - if ($a || $b)");

checkOptree ( name	=> 'if ($a || $b) { } return 1',
	      code	=> 'if ($a || $b) { } return 1',
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 997 (eval 15):1) v
# 2  <#> gvsv[*a] s
# 3  <|> or(other->4) sK/1
# 4      <#> gvsv[*b] s
# 5      <|> and(other->6) vK/1
# 6  <0> stub v
# 7  <;> nextstate(main 997 (eval 15):1) v
# 8  <$> const[IV 1] s
# 9  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 997 (eval 15):1) v
# 2  <$> gvsv(*a) s
# 3  <|> or(other->4) sK/1
# 4      <$> gvsv(*b) s
# 5      <|> and(other->6) vK/1
# 6  <0> stub v
# 7  <;> nextstate(main 3 (eval 3):1) v
# 8  <$> const(IV 1) s
# 9  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

pass("rpeep - unless ($a && $b)");

checkOptree ( name	=> 'unless ($a && $b) { } return 1',
	      code	=> 'unless ($a && $b) { } return 1',
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 997 (eval 15):1) v
# 2  <#> gvsv[*a] s
# 3  <|> and(other->4) sK/1
# 4      <#> gvsv[*b] s
# 5      <|> or(other->6) vK/1
# 6  <0> stub v
# 7  <;> nextstate(main 997 (eval 15):1) v
# 8  <$> const[IV 1] s
# 9  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 997 (eval 15):1) v
# 2  <$> gvsv(*a) s
# 3  <|> and(other->4) sK/1
# 4      <$> gvsv(*b) s
# 5      <|> or(other->6) vK/1
# 6  <0> stub v
# 7  <;> nextstate(main 3 (eval 3):1) v
# 8  <$> const(IV 1) s
# 9  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

pass("rpeep - my $a; my @@b; my %c; print 'f'");

checkOptree ( name	=> 'my $a; my @@b; my %c; return 1',
	      code	=> 'my $a; my @@b; my %c; return 1',
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 991 (eval 17):1) v
# 2  <0> padrange[$a:991,994; @@b:992,994; %c:993,994] vM/LVINTRO,3
# 3  <;> nextstate(main 994 (eval 17):1) v:{
# 4  <$> const[IV 1] s
# 5  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 991 (eval 17):1) v
# 2  <0> padrange[$a:991,994; @@b:992,994; %c:993,994] vM/LVINTRO,3
# 3  <;> nextstate(main 994 (eval 17):1) v:{
# 4  <$> const(IV 1) s
# 5  <1> leavesub[1 ref] K/REFC,1
@


