head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.6.0.12
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.6
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.8
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.6.0.4
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.6
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.2
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.4.0.10
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.8
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.6
	OPENBSD_5_0:1.1.1.4.0.4
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.2
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.3.0.8
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.4
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.10
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.8
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.6
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.4
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.2
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.1.0.6
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.4
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.2
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.11;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.03.28.18.47.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.14;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.09.24.14.48.52;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.08.43;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

# This tests the B:: module(s) with CHECK, BEGIN, END and INIT blocks. The
# text excerpts below marked with "# " in front are the expected output. They
# are there twice, EOT for threading, and EONT for a non-threading Perl. The
# output is matched losely. If the match fails even though the "got" and
# "expected" output look exactly the same, then watch for trailing, invisible
# spaces.

BEGIN {
    unshift @@INC, 't';
    require Config;
    if (($Config::Config{'extensions'} !~ /\bB\b/) ){
        print "1..0 # Skip -- Perl configured without B module\n";
        exit 0;
    }
}

# import checkOptree(), and %gOpts (containing test state)
use OptreeCheck;	# ALSO DOES @@ARGV HANDLING !!!!!!
use Config;

plan tests => 15;

require_ok("B::Concise");

my $out = runperl(
    switches => ["-MO=Concise,BEGIN,CHECK,INIT,END,-exec"],
    prog => q{$a=$b && print q/foo/},
    stderr => 1 );

#print "out:$out\n";

my $src = q[our ($beg, $chk, $init, $end, $uc) = qq{'foo'}; BEGIN { $beg++ } CHECK { $chk++ } INIT { $init++ } END { $end++ } UNITCHECK {$uc++}];


checkOptree ( name	=> 'BEGIN',
	      bcopts	=> 'BEGIN',
	      prog	=> $src,
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# BEGIN 1:
# a  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->a
# 1        <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$ ->2
# 3        <1> require sK/1 ->4
# 2           <$> const[PV "strict.pm"] s/BARE ->3
# -        <;> ex-nextstate(B::Concise -837 Concise.pm:366) v:*,&,{,x*,x&,x$,$ ->4
# -        <@@> lineseq K ->-
# 4           <;> nextstate(B::Concise -275 Concise.pm:356) :*,&,{,x*,x&,x$,$ ->5
# 9           <1> entersub[t1] KS*/TARG,STRICT ->a
# 5              <0> pushmark s ->6
# 6              <$> const[PV "strict"] sM ->7
# 7              <$> const[PV "refs"] sM ->8
# 8              <.> method_named[PV "unimport"] ->9
# BEGIN 2:
# k  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq K ->k
# b        <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$ ->c
# d        <1> require sK/1 ->e
# c           <$> const[PV "strict.pm"] s/BARE ->d
# -        <;> ex-nextstate(B::Concise -812 Concise.pm:386) v:*,&,x*,x&,x$,$ ->e
# -        <@@> lineseq K ->-
# e           <;> nextstate(B::Concise -265 Concise.pm:367) :*,&,x*,x&,x$,$ ->f
# j           <1> entersub[t1] KS*/TARG,STRICT ->k
# f              <0> pushmark s ->g
# g              <$> const[PV "strict"] sM ->h
# h              <$> const[PV "refs"] sM ->i
# i              <.> method_named[PV "unimport"] ->j
# BEGIN 3:
# u  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->u
# l        <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$ ->m
# n        <1> require sK/1 ->o
# m           <$> const[PV "warnings.pm"] s/BARE ->n
# -        <;> ex-nextstate(B::Concise -798 Concise.pm:406) v:*,&,{,x*,x&,x$,$ ->o
# -        <@@> lineseq K ->-
# o           <;> nextstate(B::Concise -254 Concise.pm:386) :*,&,{,x*,x&,x$,$ ->p
# t           <1> entersub[t1] KS*/TARG,STRICT ->u
# p              <0> pushmark s ->q
# q              <$> const[PV "warnings"] sM ->r
# r              <$> const[PV "qw"] sM ->s
# s              <.> method_named[PV "unimport"] ->t
# BEGIN 4:
# y  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->y
# v        <;> nextstate(main 2 -e:1) v:>,<,%,{ ->w
# x        <1> postinc[t3] sK/1 ->y
# -           <1> ex-rv2sv sKRM/1 ->x
# w              <#> gvsv[*beg] s ->x
EOT_EOT
# BEGIN 1:
# a  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->a
# 1        <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$ ->2
# 3        <1> require sK/1 ->4
# 2           <$> const(PV "strict.pm") s/BARE ->3
# -        <;> ex-nextstate(B::Concise -837 Concise.pm:366) v:*,&,{,x*,x&,x$,$ ->4
# -        <@@> lineseq K ->-
# 4           <;> nextstate(B::Concise -275 Concise.pm:356) :*,&,{,x*,x&,x$,$ ->5
# 9           <1> entersub[t1] KS*/TARG,STRICT ->a
# 5              <0> pushmark s ->6
# 6              <$> const(PV "strict") sM ->7
# 7              <$> const(PV "refs") sM ->8
# 8              <.> method_named(PV "unimport") ->9
# BEGIN 2:
# k  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq K ->k
# b        <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$ ->c
# d        <1> require sK/1 ->e
# c           <$> const(PV "strict.pm") s/BARE ->d
# -        <;> ex-nextstate(B::Concise -812 Concise.pm:386) v:*,&,x*,x&,x$,$ ->e
# -        <@@> lineseq K ->-
# e           <;> nextstate(B::Concise -265 Concise.pm:367) :*,&,x*,x&,x$,$ ->f
# j           <1> entersub[t1] KS*/TARG,STRICT ->k
# f              <0> pushmark s ->g
# g              <$> const(PV "strict") sM ->h
# h              <$> const(PV "refs") sM ->i
# i              <.> method_named(PV "unimport") ->j
# BEGIN 3:
# u  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->u
# l        <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$ ->m
# n        <1> require sK/1 ->o
# m           <$> const(PV "warnings.pm") s/BARE ->n
# -        <;> ex-nextstate(B::Concise -798 Concise.pm:406) v:*,&,{,x*,x&,x$,$ ->o
# -        <@@> lineseq K ->-
# o           <;> nextstate(B::Concise -254 Concise.pm:386) :*,&,{,x*,x&,x$,$ ->p
# t           <1> entersub[t1] KS*/TARG,STRICT ->u
# p              <0> pushmark s ->q
# q              <$> const(PV "warnings") sM ->r
# r              <$> const(PV "qw") sM ->s
# s              <.> method_named(PV "unimport") ->t
# BEGIN 4:
# y  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->y
# v        <;> nextstate(main 2 -e:1) v:>,<,%,{ ->w
# x        <1> postinc[t2] sK/1 ->y
# -           <1> ex-rv2sv sKRM/1 ->x
# w              <$> gvsv(*beg) s ->x
EONT_EONT


checkOptree ( name	=> 'END',
	      bcopts	=> 'END',
	      prog	=> $src,
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# END 1:
# 4  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->4
# 1        <;> nextstate(main 5 -e:6) v:>,<,%,{ ->2
# 3        <1> postinc[t3] sK/1 ->4
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <#> gvsv[*end] s ->3
EOT_EOT
# END 1:
# 4  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->4
# 1        <;> nextstate(main 5 -e:6) v:>,<,%,{ ->2
# 3        <1> postinc[t2] sK/1 ->4
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <$> gvsv(*end) s ->3
EONT_EONT


checkOptree ( name	=> 'CHECK',
	      bcopts	=> 'CHECK',
	      prog	=> $src,
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# CHECK 1:
# 4  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->4
# 1        <;> nextstate(main 3 -e:4) v:>,<,%,{ ->2
# 3        <1> postinc[t3] sK/1 ->4
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <#> gvsv[*chk] s ->3
EOT_EOT
# CHECK 1:
# 4  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->4
# 1        <;> nextstate(main 3 -e:4) v:>,<,%,{ ->2
# 3        <1> postinc[t2] sK/1 ->4
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <$> gvsv(*chk) s ->3
EONT_EONT

checkOptree ( name	=> 'UNITCHECK',
	      bcopts=> 'UNITCHECK',
	      prog	=> $src,
	      strip_open_hints => 1,
	      expect=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# UNITCHECK 1:
# 4  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->4
# 1        <;> nextstate(main 3 -e:4) v:>,<,%,{ ->2
# 3        <1> postinc[t3] sK/1 ->4
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <#> gvsv[*uc] s ->3
EOT_EOT
# UNITCHECK 1:
# 4  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->4
# 1        <;> nextstate(main 3 -e:4) v:>,<,%,{ ->2
# 3        <1> postinc[t2] sK/1 ->4
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <$> gvsv(*uc) s ->3
EONT_EONT

checkOptree ( name	=> 'INIT',
	      bcopts	=> 'INIT',
	      #todo	=> 'get working',
	      prog	=> $src,
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# INIT 1:
# 4  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->4
# 1        <;> nextstate(main 4 -e:5) v:>,<,%,{ ->2
# 3        <1> postinc[t3] sK/1 ->4
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <#> gvsv[*init] s ->3
EOT_EOT
# INIT 1:
# 4  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->4
# 1        <;> nextstate(main 4 -e:5) v:>,<,%,{ ->2
# 3        <1> postinc[t2] sK/1 ->4
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <$> gvsv(*init) s ->3
EONT_EONT


checkOptree ( name	=> 'all of BEGIN END INIT CHECK UNITCHECK -exec',
	      bcopts	=> [qw/ BEGIN END INIT CHECK UNITCHECK -exec /],
	      prog	=> $src,
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# BEGIN 1:
# 1  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$
# 2  <$> const[PV "strict.pm"] s/BARE
# 3  <1> require sK/1
# 4  <;> nextstate(B::Concise -275 Concise.pm:356) :*,&,{,x*,x&,x$,$
# 5  <0> pushmark s
# 6  <$> const[PV "strict"] sM
# 7  <$> const[PV "refs"] sM
# 8  <.> method_named[PV "unimport"] 
# 9  <1> entersub[t1] KS*/TARG,STRICT
# a  <1> leavesub[1 ref] K/REFC,1
# BEGIN 2:
# b  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$
# c  <$> const[PV "strict.pm"] s/BARE
# d  <1> require sK/1
# e  <;> nextstate(B::Concise -265 Concise.pm:367) :*,&,x*,x&,x$,$
# f  <0> pushmark s
# g  <$> const[PV "strict"] sM
# h  <$> const[PV "refs"] sM
# i  <.> method_named[PV "unimport"] 
# j  <1> entersub[t1] KS*/TARG,STRICT
# k  <1> leavesub[1 ref] K/REFC,1
# BEGIN 3:
# l  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$
# m  <$> const[PV "warnings.pm"] s/BARE
# n  <1> require sK/1
# o  <;> nextstate(B::Concise -254 Concise.pm:386) :*,&,{,x*,x&,x$,$
# p  <0> pushmark s
# q  <$> const[PV "warnings"] sM
# r  <$> const[PV "qw"] sM
# s  <.> method_named[PV "unimport"] 
# t  <1> entersub[t1] KS*/TARG,STRICT
# u  <1> leavesub[1 ref] K/REFC,1
# BEGIN 4:
# v  <;> nextstate(main 2 -e:1) v:>,<,%,{
# w  <#> gvsv[*beg] s
# x  <1> postinc[t3] sK/1
# y  <1> leavesub[1 ref] K/REFC,1
# END 1:
# z  <;> nextstate(main 5 -e:1) v:>,<,%,{
# 10 <#> gvsv[*end] s
# 11 <1> postinc[t3] sK/1
# 12 <1> leavesub[1 ref] K/REFC,1
# INIT 1:
# 13 <;> nextstate(main 4 -e:1) v:>,<,%,{
# 14 <#> gvsv[*init] s
# 15 <1> postinc[t3] sK/1
# 16 <1> leavesub[1 ref] K/REFC,1
# CHECK 1:
# 17 <;> nextstate(main 3 -e:1) v:>,<,%,{
# 18 <#> gvsv[*chk] s
# 19 <1> postinc[t3] sK/1
# 1a <1> leavesub[1 ref] K/REFC,1
# UNITCHECK 1:
# 1b <;> nextstate(main 6 -e:1) v:>,<,%,{
# 1c <#> gvsv[*uc] s
# 1d <1> postinc[t3] sK/1
# 1e <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# BEGIN 1:
# 1  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$
# 2  <$> const(PV "strict.pm") s/BARE
# 3  <1> require sK/1
# 4  <;> nextstate(B::Concise -275 Concise.pm:356) :*,&,{,x*,x&,x$,$
# 5  <0> pushmark s
# 6  <$> const(PV "strict") sM
# 7  <$> const(PV "refs") sM
# 8  <.> method_named(PV "unimport") 
# 9  <1> entersub[t1] KS*/TARG,STRICT
# a  <1> leavesub[1 ref] K/REFC,1
# BEGIN 2:
# b  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$
# c  <$> const(PV "strict.pm") s/BARE
# d  <1> require sK/1
# e  <;> nextstate(B::Concise -265 Concise.pm:367) :*,&,x*,x&,x$,$
# f  <0> pushmark s
# g  <$> const(PV "strict") sM
# h  <$> const(PV "refs") sM
# i  <.> method_named(PV "unimport") 
# j  <1> entersub[t1] KS*/TARG,STRICT
# k  <1> leavesub[1 ref] K/REFC,1
# BEGIN 3:
# l  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$
# m  <$> const(PV "warnings.pm") s/BARE
# n  <1> require sK/1
# o  <;> nextstate(B::Concise -254 Concise.pm:386) :*,&,{,x*,x&,x$,$
# p  <0> pushmark s
# q  <$> const(PV "warnings") sM
# r  <$> const(PV "qw") sM
# s  <.> method_named(PV "unimport") 
# t  <1> entersub[t1] KS*/TARG,STRICT
# u  <1> leavesub[1 ref] K/REFC,1
# BEGIN 4:
# v  <;> nextstate(main 2 -e:1) v:>,<,%,{
# w  <$> gvsv(*beg) s
# x  <1> postinc[t2] sK/1
# y  <1> leavesub[1 ref] K/REFC,1
# END 1:
# z  <;> nextstate(main 5 -e:1) v:>,<,%,{
# 10 <$> gvsv(*end) s
# 11 <1> postinc[t2] sK/1
# 12 <1> leavesub[1 ref] K/REFC,1
# INIT 1:
# 13 <;> nextstate(main 4 -e:1) v:>,<,%,{
# 14 <$> gvsv(*init) s
# 15 <1> postinc[t2] sK/1
# 16 <1> leavesub[1 ref] K/REFC,1
# CHECK 1:
# 17 <;> nextstate(main 3 -e:1) v:>,<,%,{
# 18 <$> gvsv(*chk) s
# 19 <1> postinc[t2] sK/1
# 1a <1> leavesub[1 ref] K/REFC,1
# UNITCHECK 1:
# 1b <;> nextstate(main 6 -e:1) v:>,<,%,{
# 1c <$> gvsv(*uc) s
# 1d <1> postinc[t2] sK/1
# 1e <1> leavesub[1 ref] K/REFC,1
EONT_EONT


# perl "-I../lib" -MO=Concise,BEGIN,CHECK,INIT,END,-exec -e '$a=$b && print q/foo/'



checkOptree ( name	=> 'regression test for patch 25352',
	      bcopts	=> [qw/ BEGIN END INIT CHECK -exec /],
	      prog	=> 'print q/foo/',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# BEGIN 1:
# 1  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$
# 2  <$> const[PV "strict.pm"] s/BARE
# 3  <1> require sK/1
# 4  <;> nextstate(B::Concise -275 Concise.pm:356) :*,&,{,x*,x&,x$,$
# 5  <0> pushmark s
# 6  <$> const[PV "strict"] sM
# 7  <$> const[PV "refs"] sM
# 8  <.> method_named[PV "unimport"] 
# 9  <1> entersub[t1] KS*/TARG,STRICT
# a  <1> leavesub[1 ref] K/REFC,1
# BEGIN 2:
# b  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$
# c  <$> const[PV "strict.pm"] s/BARE
# d  <1> require sK/1
# e  <;> nextstate(B::Concise -265 Concise.pm:367) :*,&,x*,x&,x$,$
# f  <0> pushmark s
# g  <$> const[PV "strict"] sM
# h  <$> const[PV "refs"] sM
# i  <.> method_named[PV "unimport"] 
# j  <1> entersub[t1] KS*/TARG,STRICT
# k  <1> leavesub[1 ref] K/REFC,1
# BEGIN 3:
# l  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$
# m  <$> const[PV "warnings.pm"] s/BARE
# n  <1> require sK/1
# o  <;> nextstate(B::Concise -254 Concise.pm:386) :*,&,{,x*,x&,x$,$
# p  <0> pushmark s
# q  <$> const[PV "warnings"] sM
# r  <$> const[PV "qw"] sM
# s  <.> method_named[PV "unimport"] 
# t  <1> entersub[t1] KS*/TARG,STRICT
# u  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# BEGIN 1:
# 1  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$
# 2  <$> const(PV "strict.pm") s/BARE
# 3  <1> require sK/1
# 4  <;> nextstate(B::Concise -275 Concise.pm:356) :*,&,{,x*,x&,x$,$
# 5  <0> pushmark s
# 6  <$> const(PV "strict") sM
# 7  <$> const(PV "refs") sM
# 8  <.> method_named(PV "unimport") 
# 9  <1> entersub[t1] KS*/TARG,STRICT
# a  <1> leavesub[1 ref] K/REFC,1
# BEGIN 2:
# b  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$
# c  <$> const(PV "strict.pm") s/BARE
# d  <1> require sK/1
# e  <;> nextstate(B::Concise -265 Concise.pm:367) :*,&,x*,x&,x$,$
# f  <0> pushmark s
# g  <$> const(PV "strict") sM
# h  <$> const(PV "refs") sM
# i  <.> method_named(PV "unimport") 
# j  <1> entersub[t1] KS*/TARG,STRICT
# k  <1> leavesub[1 ref] K/REFC,1
# BEGIN 3:
# l  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$
# m  <$> const(PV "warnings.pm") s/BARE
# n  <1> require sK/1
# o  <;> nextstate(B::Concise -254 Concise.pm:386) :*,&,{,x*,x&,x$,$
# p  <0> pushmark s
# q  <$> const(PV "warnings") sM
# r  <$> const(PV "qw") sM
# s  <.> method_named(PV "unimport") 
# t  <1> entersub[t1] KS*/TARG,STRICT
# u  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
@


1.1
log
@Initial revision
@
text
@d3 7
d11 1
a11 2
    chdir 't';
    @@INC = ('../lib', '../ext/B/t');
a16 1
    require './test.pl';
d23 1
a23 1
plan tests => 6;
d34 1
a34 2
my $src = q[our ($beg, $chk, $init, $end) = qq{'foo'}; BEGIN { $beg++ } CHECK { $chk++ } INIT { $init++ } END { $end++ }];

d40 1
d43 3
a45 3
# b  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->b
# 1        <;> nextstate(B::Concise -242 Concise.pm:304) v/2 ->2
d48 1
a48 1
# 4        <;> nextstate(B::Concise -242 Concise.pm:304) v/2 ->5
d50 6
a55 6
# 5           <;> nextstate(B::Concise -242 Concise.pm:304) /2 ->6
# a           <1> entersub[t1] KS*/TARG,2 ->b
# 6              <0> pushmark s ->7
# 7              <$> const[PV "strict"] sM ->8
# 8              <$> const[PV "refs"] sM ->9
# 9              <$> method_named[PVIV 1520340202] ->a
d57 6
a62 6
# m  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->m
# c        <;> nextstate(B::Concise -227 Concise.pm:327) v/2 ->d
# e        <1> require sK/1 ->f
# d           <$> const[PV "warnings.pm"] s/BARE ->e
# f        <;> nextstate(B::Concise -227 Concise.pm:327) v/2 ->g
d64 6
a69 6
# g           <;> nextstate(B::Concise -227 Concise.pm:327) /2 ->h
# l           <1> entersub[t1] KS*/TARG,2 ->m
# h              <0> pushmark s ->i
# i              <$> const[PV "warnings"] sM ->j
# j              <$> const[PV "qw"] sM ->k
# k              <$> method_named[PVIV 1520340202] ->l
d71 20
a90 6
# q  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->q
# n        <;> nextstate(main 2 -e:3) v ->o
# p        <1> postinc[t3] sK/1 ->q
# -           <1> ex-rv2sv sKRM/1 ->p
# o              <#> gvsv[*beg] s ->p
d93 3
a95 3
# b  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->b
# 1        <;> nextstate(B::Concise -242 Concise.pm:304) v/2 ->2
d98 1
a98 1
# 4        <;> nextstate(B::Concise -242 Concise.pm:304) v/2 ->5
d100 6
a105 6
# 5           <;> nextstate(B::Concise -242 Concise.pm:304) /2 ->6
# a           <1> entersub[t1] KS*/TARG,2 ->b
# 6              <0> pushmark s ->7
# 7              <$> const(PV "strict") sM ->8
# 8              <$> const(PV "refs") sM ->9
# 9              <$> method_named(PVIV 1520340202) ->a
d107 6
a112 6
# m  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->m
# c        <;> nextstate(B::Concise -227 Concise.pm:327) v/2 ->d
# e        <1> require sK/1 ->f
# d           <$> const(PV "warnings.pm") s/BARE ->e
# f        <;> nextstate(B::Concise -227 Concise.pm:327) v/2 ->g
d114 6
a119 6
# g           <;> nextstate(B::Concise -227 Concise.pm:327) /2 ->h
# l           <1> entersub[t1] KS*/TARG,2 ->m
# h              <0> pushmark s ->i
# i              <$> const(PV "warnings") sM ->j
# j              <$> const(PV "qw") sM ->k
# k              <$> method_named(PVIV 1520340202) ->l
d121 20
a140 6
# q  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->q
# n        <;> nextstate(main 2 -e:3) v ->o
# p        <1> postinc[t2] sK/1 ->q
# -           <1> ex-rv2sv sKRM/1 ->p
# o              <$> gvsv(*beg) s ->p
d147 1
d152 1
a152 1
# 1        <;> nextstate(main 5 -e:6) v ->2
d160 1
a160 1
# 1        <;> nextstate(main 5 -e:6) v ->2
d170 1
d175 1
a175 1
# 1        <;> nextstate(main 3 -e:4) v ->2
d183 1
a183 1
# 1        <;> nextstate(main 3 -e:4) v ->2
d189 21
d215 1
d220 1
a220 1
# 1        <;> nextstate(main 4 -e:5) v ->2
d228 1
a228 1
# 1        <;> nextstate(main 4 -e:5) v ->2
d235 2
a236 3
checkOptree ( name	=> 'all of BEGIN END INIT CHECK -exec',
	      bcopts	=> [qw/ BEGIN END INIT CHECK -exec /],
	      #todo	=> 'get working',
d238 1
d241 1
a241 1
# 1  <;> nextstate(B::Concise -242 Concise.pm:304) v/2
d244 7
a250 8
# 4  <;> nextstate(B::Concise -242 Concise.pm:304) v/2
# 5  <;> nextstate(B::Concise -242 Concise.pm:304) /2
# 6  <0> pushmark s
# 7  <$> const[PV "strict"] sM
# 8  <$> const[PV "refs"] sM
# 9  <$> method_named[PVIV 1520340202] 
# a  <1> entersub[t1] KS*/TARG,2
# b  <1> leavesub[1 ref] K/REFC,1
d252 10
a261 11
# c  <;> nextstate(B::Concise -227 Concise.pm:327) v/2
# d  <$> const[PV "warnings.pm"] s/BARE
# e  <1> require sK/1
# f  <;> nextstate(B::Concise -227 Concise.pm:327) v/2
# g  <;> nextstate(B::Concise -227 Concise.pm:327) /2
# h  <0> pushmark s
# i  <$> const[PV "warnings"] sM
# j  <$> const[PV "qw"] sM
# k  <$> method_named[PVIV 1520340202] 
# l  <1> entersub[t1] KS*/TARG,2
# m  <1> leavesub[1 ref] K/REFC,1
d263 9
a271 8
# n  <;> nextstate(main 2 -e:3) v
# o  <#> gvsv[*beg] s
# p  <1> postinc[t3] sK/1
# q  <1> leavesub[1 ref] K/REFC,1
# END 1:
# r  <;> nextstate(main 5 -e:6) v
# s  <#> gvsv[*end] s
# t  <1> postinc[t3] sK/1
d273 3
a275 3
# INIT 1:
# v  <;> nextstate(main 4 -e:5) v
# w  <#> gvsv[*init] s
d278 3
a280 3
# CHECK 1:
# z  <;> nextstate(main 3 -e:4) v
# 10 <#> gvsv[*chk] s
d283 15
d300 1
a300 1
# 1  <;> nextstate(B::Concise -242 Concise.pm:304) v/2
d303 7
a309 8
# 4  <;> nextstate(B::Concise -242 Concise.pm:304) v/2
# 5  <;> nextstate(B::Concise -242 Concise.pm:304) /2
# 6  <0> pushmark s
# 7  <$> const(PV "strict") sM
# 8  <$> const(PV "refs") sM
# 9  <$> method_named(PVIV 1520340202) 
# a  <1> entersub[t1] KS*/TARG,2
# b  <1> leavesub[1 ref] K/REFC,1
d311 10
a320 11
# c  <;> nextstate(B::Concise -227 Concise.pm:327) v/2
# d  <$> const(PV "warnings.pm") s/BARE
# e  <1> require sK/1
# f  <;> nextstate(B::Concise -227 Concise.pm:327) v/2
# g  <;> nextstate(B::Concise -227 Concise.pm:327) /2
# h  <0> pushmark s
# i  <$> const(PV "warnings") sM
# j  <$> const(PV "qw") sM
# k  <$> method_named(PVIV 1520340202) 
# l  <1> entersub[t1] KS*/TARG,2
# m  <1> leavesub[1 ref] K/REFC,1
d322 9
a330 8
# n  <;> nextstate(main 2 -e:3) v
# o  <$> gvsv(*beg) s
# p  <1> postinc[t2] sK/1
# q  <1> leavesub[1 ref] K/REFC,1
# END 1:
# r  <;> nextstate(main 5 -e:6) v
# s  <$> gvsv(*end) s
# t  <1> postinc[t2] sK/1
d332 3
a334 3
# INIT 1:
# v  <;> nextstate(main 4 -e:5) v
# w  <$> gvsv(*init) s
d337 3
a339 3
# CHECK 1:
# z  <;> nextstate(main 3 -e:4) v
# 10 <$> gvsv(*chk) s
d342 93
@


1.1.1.1
log
@perl 5.8.6 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.8 import
@
text
@a2 7
# This tests the B:: module(s) with CHECK, BEGIN, END and INIT blocks. The
# text excerpts below marked with "# " in front are the expected output. They
# are there twice, EOT for threading, and EONT for a non-threading Perl. The
# output is matched losely. If the match fails even though the "got" and
# "expected" output look exactly the same, then watch for trailing, invisible
# spaces.

d4 2
a5 7
    if ($ENV{PERL_CORE}){
	chdir('t') if -d 't';
	@@INC = ('.', '../lib', '../ext/B/t');
    } else {
	unshift @@INC, 't';
	push @@INC, "../../t";
    }
d11 1
a11 1
    # require 'test.pl'; # now done by OptreeCheck
d18 1
a18 1
plan tests => 7;
a31 6
my @@warnings_todo;
@@warnings_todo = (todo =>
   "Change 23768 (Remove Carp from warnings.pm) alters expected output, not"
   . "propagated to 5.8.x")
    if $] < 5.009;

a35 1
	      @@warnings_todo,
d40 1
a40 1
# 1        <;> nextstate(B::Concise -234 Concise.pm:328) v/2 ->2
d42 2
a43 2
# 2           <$> const[PV "warnings.pm"] s/BARE ->3
# 4        <;> nextstate(B::Concise -234 Concise.pm:328) v/2 ->5
d45 1
a45 1
# 5           <;> nextstate(B::Concise -234 Concise.pm:328) /2 ->6
d48 2
a49 2
# 7              <$> const[PV "warnings"] sM ->8
# 8              <$> const[PV "qw"] sM ->9
d52 20
a71 6
# f  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->f
# c        <;> nextstate(main 2 -e:1) v ->d
# e        <1> postinc[t3] sK/1 ->f
# -           <1> ex-rv2sv sKRM/1 ->e
# d              <#> gvsv[*beg] s ->e
d76 1
a76 1
# 1        <;> nextstate(B::Concise -234 Concise.pm:328) v/2 ->2
d78 2
a79 2
# 2           <$> const(PV "warnings.pm") s/BARE ->3
# 4        <;> nextstate(B::Concise -234 Concise.pm:328) v/2 ->5
d81 1
a81 1
# 5           <;> nextstate(B::Concise -234 Concise.pm:328) /2 ->6
d84 2
a85 2
# 7              <$> const(PV "warnings") sM ->8
# 8              <$> const(PV "qw") sM ->9
d88 20
a107 6
# f  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->f
# c        <;> nextstate(main 2 -e:1) v ->d
# e        <1> postinc[t2] sK/1 ->f
# -           <1> ex-rv2sv sKRM/1 ->e
# d              <$> gvsv(*beg) s ->e
d180 1
a181 1
	      @@warnings_todo,
d184 2
a185 2
# 1  <;> nextstate(B::Concise -234 Concise.pm:328) v/2
# 2  <$> const[PV "warnings.pm"] s/BARE
d187 2
a188 2
# 4  <;> nextstate(B::Concise -234 Concise.pm:328) v/2
# 5  <;> nextstate(B::Concise -234 Concise.pm:328) /2
d190 2
a191 2
# 7  <$> const[PV "warnings"] sM
# 8  <$> const[PV "qw"] sM
d196 16
a211 4
# c  <;> nextstate(main 2 -e:1) v
# d  <#> gvsv[*beg] s
# e  <1> postinc[t3] sK/1
# f  <1> leavesub[1 ref] K/REFC,1
d213 4
a216 4
# g  <;> nextstate(main 5 -e:1) v
# h  <#> gvsv[*end] s
# i  <1> postinc[t3] sK/1
# j  <1> leavesub[1 ref] K/REFC,1
d218 4
a221 4
# k  <;> nextstate(main 4 -e:1) v
# l  <#> gvsv[*init] s
# m  <1> postinc[t3] sK/1
# n  <1> leavesub[1 ref] K/REFC,1
d223 4
a226 4
# o  <;> nextstate(main 3 -e:1) v
# p  <#> gvsv[*chk] s
# q  <1> postinc[t3] sK/1
# r  <1> leavesub[1 ref] K/REFC,1
d229 2
a230 2
# 1  <;> nextstate(B::Concise -234 Concise.pm:328) v/2
# 2  <$> const(PV "warnings.pm") s/BARE
d232 2
a233 2
# 4  <;> nextstate(B::Concise -234 Concise.pm:328) v/2
# 5  <;> nextstate(B::Concise -234 Concise.pm:328) /2
d235 2
a236 2
# 7  <$> const(PV "warnings") sM
# 8  <$> const(PV "qw") sM
d241 16
a256 4
# c  <;> nextstate(main 2 -e:1) v
# d  <$> gvsv(*beg) s
# e  <1> postinc[t2] sK/1
# f  <1> leavesub[1 ref] K/REFC,1
d258 4
a261 4
# g  <;> nextstate(main 5 -e:1) v
# h  <$> gvsv(*end) s
# i  <1> postinc[t2] sK/1
# j  <1> leavesub[1 ref] K/REFC,1
d263 4
a266 4
# k  <;> nextstate(main 4 -e:1) v
# l  <$> gvsv(*init) s
# m  <1> postinc[t2] sK/1
# n  <1> leavesub[1 ref] K/REFC,1
d268 4
a271 41
# o  <;> nextstate(main 3 -e:1) v
# p  <$> gvsv(*chk) s
# q  <1> postinc[t2] sK/1
# r  <1> leavesub[1 ref] K/REFC,1
EONT_EONT


# perl "-I../lib" -MO=Concise,BEGIN,CHECK,INIT,END,-exec -e '$a=$b && print q/foo/'



checkOptree ( name	=> 'regression test for patch 25352',
	      bcopts	=> [qw/ BEGIN END INIT CHECK -exec /],
	      prog	=> 'print q/foo/',
	      @@warnings_todo,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# BEGIN 1:
# 1  <;> nextstate(B::Concise -234 Concise.pm:359) v/2
# 2  <$> const[PV "warnings.pm"] s/BARE
# 3  <1> require sK/1
# 4  <;> nextstate(B::Concise -234 Concise.pm:359) v/2
# 5  <;> nextstate(B::Concise -234 Concise.pm:359) /2
# 6  <0> pushmark s
# 7  <$> const[PV "warnings"] sM
# 8  <$> const[PV "qw"] sM
# 9  <$> method_named[PV "unimport"] 
# a  <1> entersub[t1] KS*/TARG,2
# b  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# BEGIN 1:
# 1  <;> nextstate(B::Concise -234 Concise.pm:359) v/2
# 2  <$> const(PV "warnings.pm") s/BARE
# 3  <1> require sK/1
# 4  <;> nextstate(B::Concise -234 Concise.pm:359) v/2
# 5  <;> nextstate(B::Concise -234 Concise.pm:359) /2
# 6  <0> pushmark s
# 7  <$> const(PV "warnings") sM
# 8  <$> const(PV "qw") sM
# 9  <$> method_named(PV "unimport") 
# a  <1> entersub[t1] KS*/TARG,2
# b  <1> leavesub[1 ref] K/REFC,1
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d30 1
a30 1
plan tests => 7 + ($] > 5.009 ? 1 : 0);
d41 1
a41 1
my $src = q[our ($beg, $chk, $init, $end, $uc) = qq{'foo'}; BEGIN { $beg++ } CHECK { $chk++ } INIT { $init++ } END { $end++ } UNITCHECK {$uc++}];
d50 1
a54 1
	      strip_open_hints => 1,
d59 1
a59 1
# 1        <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,$ ->2
d61 2
a62 2
# 2           <$> const[PV "strict.pm"] s/BARE ->3
# 4        <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,$ ->5
d64 1
a64 1
# 5           <;> nextstate(B::Concise -275 Concise.pm:356) :*,&,{,$ ->6
d67 10
a76 38
# 7              <$> const[PV "strict"] sM ->8
# 8              <$> const[PV "refs"] sM ->9
# 9              <$> method_named[PV "unimport"] ->a
# BEGIN 2:
# m  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq K ->m
# c        <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,$ ->d
# e        <1> require sK/1 ->f
# d           <$> const[PV "strict.pm"] s/BARE ->e
# f        <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,$ ->g
# -        <@@> lineseq K ->-
# g           <;> nextstate(B::Concise -265 Concise.pm:367) :*,&,$ ->h
# l           <1> entersub[t1] KS*/TARG,2 ->m
# h              <0> pushmark s ->i
# i              <$> const[PV "strict"] sM ->j
# j              <$> const[PV "refs"] sM ->k
# k              <$> method_named[PV "unimport"] ->l
# BEGIN 3:
# x  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->x
# n        <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,$ ->o
# p        <1> require sK/1 ->q
# o           <$> const[PV "warnings.pm"] s/BARE ->p
# q        <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,$ ->r
# -        <@@> lineseq K ->-
# r           <;> nextstate(B::Concise -254 Concise.pm:386) :*,&,{,$ ->s
# w           <1> entersub[t1] KS*/TARG,2 ->x
# s              <0> pushmark s ->t
# t              <$> const[PV "warnings"] sM ->u
# u              <$> const[PV "qw"] sM ->v
# v              <$> method_named[PV "unimport"] ->w
# BEGIN 4:
# 11 <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->11
# y        <;> nextstate(main 2 -e:1) v:>,<,%,{ ->z
# 10       <1> postinc[t3] sK/1 ->11
# -           <1> ex-rv2sv sKRM/1 ->10
# z              <#> gvsv[*beg] s ->10
d81 1
a81 1
# 1        <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,$ ->2
d83 2
a84 2
# 2           <$> const(PV "strict.pm") s/BARE ->3
# 4        <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,$ ->5
d86 1
a86 1
# 5           <;> nextstate(B::Concise -275 Concise.pm:356) :*,&,{,$ ->6
d89 10
a98 38
# 7              <$> const(PV "strict") sM ->8
# 8              <$> const(PV "refs") sM ->9
# 9              <$> method_named(PV "unimport") ->a
# BEGIN 2:
# m  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq K ->m
# c        <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,$ ->d
# e        <1> require sK/1 ->f
# d           <$> const(PV "strict.pm") s/BARE ->e
# f        <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,$ ->g
# -        <@@> lineseq K ->-
# g           <;> nextstate(B::Concise -265 Concise.pm:367) :*,&,$ ->h
# l           <1> entersub[t1] KS*/TARG,2 ->m
# h              <0> pushmark s ->i
# i              <$> const(PV "strict") sM ->j
# j              <$> const(PV "refs") sM ->k
# k              <$> method_named(PV "unimport") ->l
# BEGIN 3:
# x  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->x
# n        <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,$ ->o
# p        <1> require sK/1 ->q
# o           <$> const(PV "warnings.pm") s/BARE ->p
# q        <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,$ ->r
# -        <@@> lineseq K ->-
# r           <;> nextstate(B::Concise -254 Concise.pm:386) :*,&,{,$ ->s
# w           <1> entersub[t1] KS*/TARG,2 ->x
# s              <0> pushmark s ->t
# t              <$> const(PV "warnings") sM ->u
# u              <$> const(PV "qw") sM ->v
# v              <$> method_named(PV "unimport") ->w
# BEGIN 4:
# 11 <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->11
# y        <;> nextstate(main 2 -e:1) v:>,<,%,{ ->z
# 10       <1> postinc[t2] sK/1 ->11
# -           <1> ex-rv2sv sKRM/1 ->10
# z              <$> gvsv(*beg) s ->10
a104 1
	      strip_open_hints => 1,
d109 1
a109 1
# 1        <;> nextstate(main 5 -e:6) v:>,<,%,{ ->2
d117 1
a117 1
# 1        <;> nextstate(main 5 -e:6) v:>,<,%,{ ->2
a126 1
	      strip_open_hints => 1,
d131 1
a131 1
# 1        <;> nextstate(main 3 -e:4) v:>,<,%,{ ->2
d139 1
a139 1
# 1        <;> nextstate(main 3 -e:4) v:>,<,%,{ ->2
a144 23
if ($] >= 5.009) {
    checkOptree ( name	=> 'UNITCHECK',
		  bcopts=> 'UNITCHECK',
		  prog	=> $src,
		  strip_open_hints => 1,
		  expect=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# UNITCHECK 1:
# 4  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->4
# 1        <;> nextstate(main 3 -e:4) v:>,<,%,{ ->2
# 3        <1> postinc[t3] sK/1 ->4
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <#> gvsv[*uc] s ->3
EOT_EOT
# UNITCHECK 1:
# 4  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->4
# 1        <;> nextstate(main 3 -e:4) v:>,<,%,{ ->2
# 3        <1> postinc[t2] sK/1 ->4
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <$> gvsv(*uc) s ->3
EONT_EONT
}
a149 1
	      strip_open_hints => 1,
d154 1
a154 1
# 1        <;> nextstate(main 4 -e:5) v:>,<,%,{ ->2
d162 1
a162 1
# 1        <;> nextstate(main 4 -e:5) v:>,<,%,{ ->2
d169 2
a170 2
checkOptree ( name	=> 'all of BEGIN END INIT CHECK UNITCHECK -exec',
	      bcopts	=> [qw/ BEGIN END INIT CHECK UNITCHECK -exec /],
a172 1
	      strip_open_hints => 1,
d175 2
a176 2
# 1  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,$
# 2  <$> const[PV "strict.pm"] s/BARE
d178 2
a179 2
# 4  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,$
# 5  <;> nextstate(B::Concise -275 Concise.pm:356) :*,&,{,$
d181 3
a183 3
# 7  <$> const[PV "strict"] sM
# 8  <$> const[PV "refs"] sM
# 9  <$> method_named[PV "unimport"] 
d187 4
a190 28
# c  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,$
# d  <$> const[PV "strict.pm"] s/BARE
# e  <1> require sK/1
# f  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,$
# g  <;> nextstate(B::Concise -265 Concise.pm:367) :*,&,$
# h  <0> pushmark s
# i  <$> const[PV "strict"] sM
# j  <$> const[PV "refs"] sM
# k  <$> method_named[PV "unimport"] 
# l  <1> entersub[t1] KS*/TARG,2
# m  <1> leavesub[1 ref] K/REFC,1
# BEGIN 3:
# n  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,$
# o  <$> const[PV "warnings.pm"] s/BARE
# p  <1> require sK/1
# q  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,$
# r  <;> nextstate(B::Concise -254 Concise.pm:386) :*,&,{,$
# s  <0> pushmark s
# t  <$> const[PV "warnings"] sM
# u  <$> const[PV "qw"] sM
# v  <$> method_named[PV "unimport"] 
# w  <1> entersub[t1] KS*/TARG,2
# x  <1> leavesub[1 ref] K/REFC,1
# BEGIN 4:
# y  <;> nextstate(main 2 -e:1) v:>,<,%,{
# z  <#> gvsv[*beg] s
# 10 <1> postinc[t3] sK/1
# 11 <1> leavesub[1 ref] K/REFC,1
d192 4
a195 4
# 12 <;> nextstate(main 5 -e:1) v:>,<,%,{
# 13 <#> gvsv[*end] s
# 14 <1> postinc[t3] sK/1
# 15 <1> leavesub[1 ref] K/REFC,1
d197 4
a200 4
# 16 <;> nextstate(main 4 -e:1) v:>,<,%,{
# 17 <#> gvsv[*init] s
# 18 <1> postinc[t3] sK/1
# 19 <1> leavesub[1 ref] K/REFC,1
d202 4
a205 9
# 1a <;> nextstate(main 3 -e:1) v:>,<,%,{
# 1b <#> gvsv[*chk] s
# 1c <1> postinc[t3] sK/1
# 1d <1> leavesub[1 ref] K/REFC,1
# UNITCHECK 1:
# 1e <;> nextstate(main 6 -e:1) v:>,<,%,{
# 1f <#> gvsv[*uc] s
# 1g <1> postinc[t3] sK/1
# 1h <1> leavesub[1 ref] K/REFC,1
d208 2
a209 2
# 1  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,$
# 2  <$> const(PV "strict.pm") s/BARE
d211 2
a212 2
# 4  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,$
# 5  <;> nextstate(B::Concise -275 Concise.pm:356) :*,&,{,$
d214 3
a216 3
# 7  <$> const(PV "strict") sM
# 8  <$> const(PV "refs") sM
# 9  <$> method_named(PV "unimport") 
d220 4
a223 28
# c  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,$
# d  <$> const(PV "strict.pm") s/BARE
# e  <1> require sK/1
# f  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,$
# g  <;> nextstate(B::Concise -265 Concise.pm:367) :*,&,$
# h  <0> pushmark s
# i  <$> const(PV "strict") sM
# j  <$> const(PV "refs") sM
# k  <$> method_named(PV "unimport") 
# l  <1> entersub[t1] KS*/TARG,2
# m  <1> leavesub[1 ref] K/REFC,1
# BEGIN 3:
# n  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,$
# o  <$> const(PV "warnings.pm") s/BARE
# p  <1> require sK/1
# q  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,$
# r  <;> nextstate(B::Concise -254 Concise.pm:386) :*,&,{,$
# s  <0> pushmark s
# t  <$> const(PV "warnings") sM
# u  <$> const(PV "qw") sM
# v  <$> method_named(PV "unimport") 
# w  <1> entersub[t1] KS*/TARG,2
# x  <1> leavesub[1 ref] K/REFC,1
# BEGIN 4:
# y  <;> nextstate(main 2 -e:1) v:>,<,%,{
# z  <$> gvsv(*beg) s
# 10 <1> postinc[t2] sK/1
# 11 <1> leavesub[1 ref] K/REFC,1
d225 4
a228 4
# 12 <;> nextstate(main 5 -e:1) v:>,<,%,{
# 13 <$> gvsv(*end) s
# 14 <1> postinc[t2] sK/1
# 15 <1> leavesub[1 ref] K/REFC,1
d230 4
a233 4
# 16 <;> nextstate(main 4 -e:1) v:>,<,%,{
# 17 <$> gvsv(*init) s
# 18 <1> postinc[t2] sK/1
# 19 <1> leavesub[1 ref] K/REFC,1
d235 4
a238 9
# 1a <;> nextstate(main 3 -e:1) v:>,<,%,{
# 1b <$> gvsv(*chk) s
# 1c <1> postinc[t2] sK/1
# 1d <1> leavesub[1 ref] K/REFC,1
# UNITCHECK 1:
# 1e <;> nextstate(main 6 -e:1) v:>,<,%,{
# 1f <$> gvsv(*uc) s
# 1g <1> postinc[t2] sK/1
# 1h <1> leavesub[1 ref] K/REFC,1
d252 2
a253 2
# 1  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,$
# 2  <$> const[PV "strict.pm"] s/BARE
d255 2
a256 2
# 4  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,$
# 5  <;> nextstate(B::Concise -275 Concise.pm:356) :*,&,{,$
d258 2
a259 2
# 7  <$> const[PV "strict"] sM
# 8  <$> const[PV "refs"] sM
a262 24
# BEGIN 2:
# c  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,$
# d  <$> const[PV "strict.pm"] s/BARE
# e  <1> require sK/1
# f  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,$
# g  <;> nextstate(B::Concise -265 Concise.pm:367) :*,&,$
# h  <0> pushmark s
# i  <$> const[PV "strict"] sM
# j  <$> const[PV "refs"] sM
# k  <$> method_named[PV "unimport"] 
# l  <1> entersub[t1] KS*/TARG,2
# m  <1> leavesub[1 ref] K/REFC,1
# BEGIN 3:
# n  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,$
# o  <$> const[PV "warnings.pm"] s/BARE
# p  <1> require sK/1
# q  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,$
# r  <;> nextstate(B::Concise -254 Concise.pm:386) :*,&,{,$
# s  <0> pushmark s
# t  <$> const[PV "warnings"] sM
# u  <$> const[PV "qw"] sM
# v  <$> method_named[PV "unimport"] 
# w  <1> entersub[t1] KS*/TARG,2
# x  <1> leavesub[1 ref] K/REFC,1
d265 2
a266 2
# 1  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,$
# 2  <$> const(PV "strict.pm") s/BARE
d268 2
a269 2
# 4  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,$
# 5  <;> nextstate(B::Concise -275 Concise.pm:356) :*,&,{,$
d271 2
a272 2
# 7  <$> const(PV "strict") sM
# 8  <$> const(PV "refs") sM
a275 24
# BEGIN 2:
# c  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,$
# d  <$> const(PV "strict.pm") s/BARE
# e  <1> require sK/1
# f  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,$
# g  <;> nextstate(B::Concise -265 Concise.pm:367) :*,&,$
# h  <0> pushmark s
# i  <$> const(PV "strict") sM
# j  <$> const(PV "refs") sM
# k  <$> method_named(PV "unimport") 
# l  <1> entersub[t1] KS*/TARG,2
# m  <1> leavesub[1 ref] K/REFC,1
# BEGIN 3:
# n  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,$
# o  <$> const(PV "warnings.pm") s/BARE
# p  <1> require sK/1
# q  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,$
# r  <;> nextstate(B::Concise -254 Concise.pm:386) :*,&,{,$
# s  <0> pushmark s
# t  <$> const(PV "warnings") sM
# u  <$> const(PV "qw") sM
# v  <$> method_named(PV "unimport") 
# w  <1> entersub[t1] KS*/TARG,2
# x  <1> leavesub[1 ref] K/REFC,1
@


1.1.1.4
log
@Perl 5.12.2 from CPAN
@
text
@d11 7
a17 1
    unshift @@INC, 't';
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d17 1
d24 1
a24 1
plan tests => 13 + ($] > 5.009 ? 2 : 0);
d51 3
a53 3
# a  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->a
# 1        <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$ ->2
d56 1
a56 1
# 4        <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$ ->5
d58 6
a63 6
# -           <0> null ->5
# 9           <1> entersub[t1] KS*/TARG,2 ->a
# 5              <0> pushmark s ->6
# 6              <$> const[PV "strict"] sM ->7
# 7              <$> const[PV "refs"] sM ->8
# 8              <$> method_named[PV "unimport"] ->9
d65 6
a70 6
# k  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq K ->k
# b        <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$ ->c
# d        <1> require sK/1 ->e
# c           <$> const[PV "strict.pm"] s/BARE ->d
# e        <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$ ->f
d72 6
a77 6
# -           <0> null ->f
# j           <1> entersub[t1] KS*/TARG,2 ->k
# f              <0> pushmark s ->g
# g              <$> const[PV "strict"] sM ->h
# h              <$> const[PV "refs"] sM ->i
# i              <$> method_named[PV "unimport"] ->j
d79 6
a84 6
# u  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->u
# l        <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$ ->m
# n        <1> require sK/1 ->o
# m           <$> const[PV "warnings.pm"] s/BARE ->n
# o        <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$ ->p
d86 6
a91 6
# -           <0> null ->p
# t           <1> entersub[t1] KS*/TARG,2 ->u
# p              <0> pushmark s ->q
# q              <$> const[PV "warnings"] sM ->r
# r              <$> const[PV "qw"] sM ->s
# s              <$> method_named[PV "unimport"] ->t
d93 6
a98 6
# y  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->y
# v        <;> nextstate(main 2 -e:1) v:>,<,%,{ ->w
# x        <1> postinc[t3] sK/1 ->y
# -           <1> ex-rv2sv sKRM/1 ->x
# w              <#> gvsv[*beg] s ->x
d101 3
a103 3
# a  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->a
# 1        <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$ ->2
d106 1
a106 1
# 4        <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$ ->5
d108 6
a113 6
# -           <0> null ->5
# 9           <1> entersub[t1] KS*/TARG,2 ->a
# 5              <0> pushmark s ->6
# 6              <$> const(PV "strict") sM ->7
# 7              <$> const(PV "refs") sM ->8
# 8              <$> method_named(PV "unimport") ->9
d115 6
a120 6
# k  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq K ->k
# b        <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$ ->c
# d        <1> require sK/1 ->e
# c           <$> const(PV "strict.pm") s/BARE ->d
# e        <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$ ->f
d122 6
a127 6
# -           <0> null ->f
# j           <1> entersub[t1] KS*/TARG,2 ->k
# f              <0> pushmark s ->g
# g              <$> const(PV "strict") sM ->h
# h              <$> const(PV "refs") sM ->i
# i              <$> method_named(PV "unimport") ->j
d129 6
a134 6
# u  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->u
# l        <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$ ->m
# n        <1> require sK/1 ->o
# m           <$> const(PV "warnings.pm") s/BARE ->n
# o        <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$ ->p
d136 6
a141 6
# -           <0> null ->p
# t           <1> entersub[t1] KS*/TARG,2 ->u
# p              <0> pushmark s ->q
# q              <$> const(PV "warnings") sM ->r
# r              <$> const(PV "qw") sM ->s
# s              <$> method_named(PV "unimport") ->t
d143 6
a148 6
# y  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->y
# v        <;> nextstate(main 2 -e:1) v:>,<,%,{ ->w
# x        <1> postinc[t2] sK/1 ->y
# -           <1> ex-rv2sv sKRM/1 ->x
# w              <$> gvsv(*beg) s ->x
d252 1
a252 1
# 1  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$
d255 8
a262 7
# 4  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$
# 5  <0> pushmark s
# 6  <$> const[PV "strict"] sM
# 7  <$> const[PV "refs"] sM
# 8  <$> method_named[PV "unimport"] 
# 9  <1> entersub[t1] KS*/TARG,2
# a  <1> leavesub[1 ref] K/REFC,1
d264 11
a274 10
# b  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$
# c  <$> const[PV "strict.pm"] s/BARE
# d  <1> require sK/1
# e  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$
# f  <0> pushmark s
# g  <$> const[PV "strict"] sM
# h  <$> const[PV "refs"] sM
# i  <$> method_named[PV "unimport"] 
# j  <1> entersub[t1] KS*/TARG,2
# k  <1> leavesub[1 ref] K/REFC,1
d276 11
a286 10
# l  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$
# m  <$> const[PV "warnings.pm"] s/BARE
# n  <1> require sK/1
# o  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$
# p  <0> pushmark s
# q  <$> const[PV "warnings"] sM
# r  <$> const[PV "qw"] sM
# s  <$> method_named[PV "unimport"] 
# t  <1> entersub[t1] KS*/TARG,2
# u  <1> leavesub[1 ref] K/REFC,1
d288 4
a291 4
# v  <;> nextstate(main 2 -e:1) v:>,<,%,{
# w  <#> gvsv[*beg] s
# x  <1> postinc[t3] sK/1
# y  <1> leavesub[1 ref] K/REFC,1
d293 4
a296 4
# z  <;> nextstate(main 5 -e:1) v:>,<,%,{
# 10 <#> gvsv[*end] s
# 11 <1> postinc[t3] sK/1
# 12 <1> leavesub[1 ref] K/REFC,1
d298 4
a301 4
# 13 <;> nextstate(main 4 -e:1) v:>,<,%,{
# 14 <#> gvsv[*init] s
# 15 <1> postinc[t3] sK/1
# 16 <1> leavesub[1 ref] K/REFC,1
d303 4
a306 4
# 17 <;> nextstate(main 3 -e:1) v:>,<,%,{
# 18 <#> gvsv[*chk] s
# 19 <1> postinc[t3] sK/1
# 1a <1> leavesub[1 ref] K/REFC,1
d308 4
a311 4
# 1b <;> nextstate(main 6 -e:1) v:>,<,%,{
# 1c <#> gvsv[*uc] s
# 1d <1> postinc[t3] sK/1
# 1e <1> leavesub[1 ref] K/REFC,1
d314 1
a314 1
# 1  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$
d317 8
a324 7
# 4  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$
# 5  <0> pushmark s
# 6  <$> const(PV "strict") sM
# 7  <$> const(PV "refs") sM
# 8  <$> method_named(PV "unimport") 
# 9  <1> entersub[t1] KS*/TARG,2
# a  <1> leavesub[1 ref] K/REFC,1
d326 11
a336 10
# b  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$
# c  <$> const(PV "strict.pm") s/BARE
# d  <1> require sK/1
# e  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$
# f  <0> pushmark s
# g  <$> const(PV "strict") sM
# h  <$> const(PV "refs") sM
# i  <$> method_named(PV "unimport") 
# j  <1> entersub[t1] KS*/TARG,2
# k  <1> leavesub[1 ref] K/REFC,1
d338 11
a348 10
# l  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$
# m  <$> const(PV "warnings.pm") s/BARE
# n  <1> require sK/1
# o  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$
# p  <0> pushmark s
# q  <$> const(PV "warnings") sM
# r  <$> const(PV "qw") sM
# s  <$> method_named(PV "unimport") 
# t  <1> entersub[t1] KS*/TARG,2
# u  <1> leavesub[1 ref] K/REFC,1
d350 4
a353 4
# v  <;> nextstate(main 2 -e:1) v:>,<,%,{
# w  <$> gvsv(*beg) s
# x  <1> postinc[t2] sK/1
# y  <1> leavesub[1 ref] K/REFC,1
d355 4
a358 4
# z  <;> nextstate(main 5 -e:1) v:>,<,%,{
# 10 <$> gvsv(*end) s
# 11 <1> postinc[t2] sK/1
# 12 <1> leavesub[1 ref] K/REFC,1
d360 4
a363 4
# 13 <;> nextstate(main 4 -e:1) v:>,<,%,{
# 14 <$> gvsv(*init) s
# 15 <1> postinc[t2] sK/1
# 16 <1> leavesub[1 ref] K/REFC,1
d365 4
a368 4
# 17 <;> nextstate(main 3 -e:1) v:>,<,%,{
# 18 <$> gvsv(*chk) s
# 19 <1> postinc[t2] sK/1
# 1a <1> leavesub[1 ref] K/REFC,1
d370 4
a373 4
# 1b <;> nextstate(main 6 -e:1) v:>,<,%,{
# 1c <$> gvsv(*uc) s
# 1d <1> postinc[t2] sK/1
# 1e <1> leavesub[1 ref] K/REFC,1
d387 1
a387 1
# 1  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$
d390 8
a397 7
# 4  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$
# 5  <0> pushmark s
# 6  <$> const[PV "strict"] sM
# 7  <$> const[PV "refs"] sM
# 8  <$> method_named[PV "unimport"] 
# 9  <1> entersub[t1] KS*/TARG,2
# a  <1> leavesub[1 ref] K/REFC,1
d399 11
a409 10
# b  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$
# c  <$> const[PV "strict.pm"] s/BARE
# d  <1> require sK/1
# e  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$
# f  <0> pushmark s
# g  <$> const[PV "strict"] sM
# h  <$> const[PV "refs"] sM
# i  <$> method_named[PV "unimport"] 
# j  <1> entersub[t1] KS*/TARG,2
# k  <1> leavesub[1 ref] K/REFC,1
d411 11
a421 10
# l  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$
# m  <$> const[PV "warnings.pm"] s/BARE
# n  <1> require sK/1
# o  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$
# p  <0> pushmark s
# q  <$> const[PV "warnings"] sM
# r  <$> const[PV "qw"] sM
# s  <$> method_named[PV "unimport"] 
# t  <1> entersub[t1] KS*/TARG,2
# u  <1> leavesub[1 ref] K/REFC,1
d424 1
a424 1
# 1  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$
d427 8
a434 7
# 4  <;> nextstate(B::Concise -275 Concise.pm:356) v:*,&,{,x*,x&,x$,$
# 5  <0> pushmark s
# 6  <$> const(PV "strict") sM
# 7  <$> const(PV "refs") sM
# 8  <$> method_named(PV "unimport") 
# 9  <1> entersub[t1] KS*/TARG,2
# a  <1> leavesub[1 ref] K/REFC,1
d436 11
a446 10
# b  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$
# c  <$> const(PV "strict.pm") s/BARE
# d  <1> require sK/1
# e  <;> nextstate(B::Concise -265 Concise.pm:367) v:*,&,x*,x&,x$,$
# f  <0> pushmark s
# g  <$> const(PV "strict") sM
# h  <$> const(PV "refs") sM
# i  <$> method_named(PV "unimport") 
# j  <1> entersub[t1] KS*/TARG,2
# k  <1> leavesub[1 ref] K/REFC,1
d448 11
a458 10
# l  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$
# m  <$> const(PV "warnings.pm") s/BARE
# n  <1> require sK/1
# o  <;> nextstate(B::Concise -254 Concise.pm:386) v:*,&,{,x*,x&,x$,$
# p  <0> pushmark s
# q  <$> const(PV "warnings") sM
# r  <$> const(PV "qw") sM
# s  <$> method_named(PV "unimport") 
# t  <1> entersub[t1] KS*/TARG,2
# u  <1> leavesub[1 ref] K/REFC,1
@


1.1.1.6
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d23 1
a23 1
plan tests => 15;
d37 6
d46 1
d196 6
a201 5
checkOptree ( name	=> 'UNITCHECK',
	      bcopts=> 'UNITCHECK',
	      prog	=> $src,
	      strip_open_hints => 1,
	      expect=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
d218 1
d247 1
d377 1
@


