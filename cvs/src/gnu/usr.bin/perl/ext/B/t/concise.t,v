head	1.2;
access;
symbols
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.11.0.10
	OPENBSD_6_0_BASE:1.1.1.11
	OPENBSD_5_9:1.1.1.11.0.4
	OPENBSD_5_9_BASE:1.1.1.11
	OPENBSD_5_8:1.1.1.11.0.6
	OPENBSD_5_8_BASE:1.1.1.11
	PERL_5_20_2:1.1.1.11
	OPENBSD_5_7:1.1.1.11.0.2
	OPENBSD_5_7_BASE:1.1.1.11
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.1.1.10.0.4
	OPENBSD_5_6_BASE:1.1.1.10
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.9.0.6
	OPENBSD_5_5_BASE:1.1.1.9
	OPENBSD_5_4:1.1.1.9.0.2
	OPENBSD_5_4_BASE:1.1.1.9
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.1.1.8.0.10
	OPENBSD_5_3_BASE:1.1.1.8
	OPENBSD_5_2:1.1.1.8.0.8
	OPENBSD_5_2_BASE:1.1.1.8
	OPENBSD_5_1_BASE:1.1.1.8
	OPENBSD_5_1:1.1.1.8.0.6
	OPENBSD_5_0:1.1.1.8.0.4
	OPENBSD_5_0_BASE:1.1.1.8
	OPENBSD_4_9:1.1.1.8.0.2
	OPENBSD_4_9_BASE:1.1.1.8
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.1.1.7.0.4
	OPENBSD_4_8_BASE:1.1.1.7
	OPENBSD_4_7:1.1.1.7.0.2
	OPENBSD_4_7_BASE:1.1.1.7
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.1.1.6.0.6
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.2
	OPENBSD_4_5_BASE:1.1.1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.6
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.4
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.2
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.11;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.14.53;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.53;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.41;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.45.54;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.47.54;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.13;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.11.11;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.09.24.14.48.52;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.08.43;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    unshift @@INC, 't';
    require Config;
    if (($Config::Config{'extensions'} !~ /\bB\b/) ){
        print "1..0 # Skip -- Perl configured without B module\n";
        exit 0;
    }
    require 'test.pl';		# we use runperl from 'test.pl', so can't use Test::More
}

plan tests => 163;

require_ok("B::Concise");

$out = runperl(switches => ["-MO=Concise"], prog => '$a', stderr => 1);

# If either of the next two tests fail, it probably means you need to
# fix the section labeled 'fragile kludge' in Concise.pm

($op_base) = ($out =~ /^(\d+)\s*<0>\s*enter/m);

is($op_base, 1, "Smallest OP sequence number");

($op_base_p1, $cop_base)
  = ($out =~ /^(\d+)\s*<;>\s*nextstate\(main (-?\d+) /m);

is($op_base_p1, 2, "Second-smallest OP sequence number");

is($cop_base, 1, "Smallest COP sequence number");

# test that with -exec B::Concise navigates past logops (bug #18175)

$out = runperl(
    switches => ["-MO=Concise,-exec"],
    prog => q{$a=$b && print q/foo/},
    stderr => 1,
);
#diag($out);
like($out, qr/print/, "'-exec' option output has print opcode");

######## API tests v.60 

use Config;	# used for perlio check
B::Concise->import(qw( set_style set_style_standard add_callback 
		       add_style walk_output reset_sequence ));

## walk_output argument checking

# test that walk_output rejects non-HANDLE args
foreach my $foo ("string", [], {}) {
    eval {  walk_output($foo) };
    isnt ($@@, '', "walk_output() rejects arg '$foo'");
    $@@=''; # clear the fail for next test
}
# test accessor mode when arg undefd or 0
foreach my $foo (undef, 0) {
    my $handle = walk_output($foo);
    is ($handle, \*STDOUT, "walk_output set to STDOUT (default)");
}

{   # any object that can print should be ok for walk_output
    package Hugo;
    sub new { my $foo = bless {} };
    sub print { CORE::print @@_ }
}
my $foo = new Hugo;	# suggested this API fix
eval {  walk_output($foo) };
is ($@@, '', "walk_output() accepts obj that can print");

# test that walk_output accepts a HANDLE arg
SKIP: {
    skip("no perlio in this build", 4)
        unless $Config::Config{useperlio};

    foreach my $foo (\*STDOUT, \*STDERR) {
	eval {  walk_output($foo) };
	is ($@@, '', "walk_output() accepts STD* " . ref $foo);
    }

    # now test a ref to scalar
    eval {  walk_output(\my $junk) };
    is ($@@, '', "walk_output() accepts ref-to-sprintf target");

    $junk = "non-empty";
    eval {  walk_output(\$junk) };
    is ($@@, '', "walk_output() accepts ref-to-non-empty-scalar");
}

## add_style
my @@stylespec;
$@@='';
eval { add_style ('junk_B' => @@stylespec) };
like ($@@, qr/expecting 3 style-format args/,
    "add_style rejects insufficient args");

@@stylespec = (0,0,0); # right length, invalid values
$@@='';
eval { add_style ('junk' => @@stylespec) };
is ($@@, '', "add_style accepts: stylename => 3-arg-array");

$@@='';
eval { add_style (junk => @@stylespec) };
like ($@@, qr/style 'junk' already exists, choose a new name/,
    "add_style correctly disallows re-adding same style-name" );

# test new arg-checks on set_style
$@@='';
eval { set_style (@@stylespec) };
is ($@@, '', "set_style accepts 3 style-format args");

@@stylespec = (); # bad style

eval { set_style (@@stylespec) };
like ($@@, qr/expecting 3 style-format args/,
      "set_style rejects bad style-format args");

#### for content with doc'd options

our($a, $b);
my $func = sub{ $a = $b+42 };	# canonical example asub

sub render {
    walk_output(\my $out);
    eval { B::Concise::compile(@@_)->() };
    # diag "rendering $@@\n";
    return ($out, $@@) if wantarray;
    return $out;
}

SKIP: {
    # tests output to GLOB, using perlio feature directly
    skip "no perlio on this build", 127
	unless $Config::Config{useperlio};
    
    set_style_standard('concise');  # MUST CALL before output needed
    
    @@options = qw(
		  -basic -exec -tree -compact -loose -vt -ascii
		  -base10 -bigendian -littleendian
		  );
    foreach $opt (@@options) {
	($out) = render($opt, $func);
	isnt($out, '', "got output with option $opt");
    }
    
    ## test output control via walk_output
    
    my $treegen = B::Concise::compile('-basic', $func); # reused
    
    { # test output into a package global string (sprintf-ish)
	our $thing;
	walk_output(\$thing);
	$treegen->();
	ok($thing, "walk_output to our SCALAR, output seen");
    }
    
    # test walkoutput acceptance of a scalar-bound IO handle
    open (my $fh, '>', \my $buf);
    walk_output($fh);
    $treegen->();
    ok($buf, "walk_output to GLOB, output seen");
    
    ## test B::Concise::compile error checking
    
    # call compile on non-CODE ref items
    if (0) {
	# pending STASH splaying
	
	foreach my $ref ([], {}) {
	    my $typ = ref $ref;
	    walk_output(\my $out);
	    eval { B::Concise::compile('-basic', $ref)->() };
	    like ($@@, qr/^err: not a coderef: $typ/,
		  "compile detects $typ-ref where expecting subref");
	    is($out,'', "no output when errd"); # announcement prints
	}
    }
    
    # test against a bogus autovivified subref.
    # in debugger, it should look like:
    #  1  CODE(0x84840cc)
    #      -> &CODE(0x84840cc) in ???

    my ($res,$err);
    TODO: {
	#local $TODO = "\tdoes this handling make sense ?";

	sub declared_only;
	($res,$err) = render('-basic', \&declared_only);
	like ($res, qr/coderef CODE\(0x[0-9a-fA-F]+\) has no START/,
	      "'sub decl_only' seen as having no START");

	sub defd_empty {};
	($res,$err) = render('-basic', \&defd_empty);
	my @@lines = split(/\n/, $res);
	is(scalar @@lines, 3,
	   "'sub defd_empty {}' seen as 3 liner");

	is(1, $res =~ /leavesub/ && $res =~ /(next|db)state/,
	   "'sub defd_empty {}' seen as 2 ops: leavesub,nextstate");

	($res,$err) = render('-basic', \&not_even_declared);
	like ($res, qr/coderef CODE\(0x[0-9a-fA-F]+\) has no START/,
	      "'\&not_even_declared' seen as having no START");

	{
	    package Bar;
	    our $AUTOLOAD = 'garbage';
	    sub AUTOLOAD { print "# in AUTOLOAD body: $AUTOLOAD\n" }
	}
	($res,$err) = render('-basic', Bar::auto_func);
	like ($res, qr/unknown function \(Bar::auto_func\)/,
	      "Bar::auto_func seen as unknown function");

	($res,$err) = render('-basic', \&Bar::auto_func);
	like ($res, qr/coderef CODE\(0x[0-9a-fA-F]+\) has no START/,
	      "'\&Bar::auto_func' seen as having no START");

	($res,$err) = render('-basic', \&Bar::AUTOLOAD);
	like ($res, qr/in AUTOLOAD body: /, "found body of Bar::AUTOLOAD");

    }
    ($res,$err) = render('-basic', Foo::bar);
    like ($res, qr/unknown function \(Foo::bar\)/,
	  "BC::compile detects fn-name as unknown function");

    # v.62 tests

    pass ("TEST POST-COMPILE OPTION-HANDLING IN WALKER SUBROUTINE");
    
    my $sample;

    my $walker = B::Concise::compile('-basic', $func);
    walk_output(\$sample);
    $walker->('-exec');
    like($sample, qr/goto/m, "post-compile -exec");

    walk_output(\$sample);
    $walker->('-basic');
    unlike($sample, qr/goto/m, "post-compile -basic");


    # bang at it combinatorically
    my %combos;
    my @@modes = qw( -basic -exec );
    my @@styles = qw( -concise -debug -linenoise -terse );

    # prep samples
    for $style (@@styles) {
	for $mode (@@modes) {
	    walk_output(\$sample);
	    reset_sequence();
	    $walker->($style, $mode);
	    $combos{"$style$mode"} = $sample;
	}
    }
    # crosscheck that samples are all text-different
    @@list = sort keys %combos;
    for $i (0..$#list) {
	for $j ($i+1..$#list) {
	    isnt ($combos{$list[$i]}, $combos{$list[$j]},
		  "combos for $list[$i] and $list[$j] are different, as expected");
	}
    }
    
    # add samples with styles in different order
    for $mode (@@modes) {
	for $style (@@styles) {
	    reset_sequence();
	    walk_output(\$sample);
	    $walker->($mode, $style);
	    $combos{"$mode$style"} = $sample;
	}
    }
    # test commutativity of flags, ie that AB == BA
    for $mode (@@modes) {
	for $style (@@styles) {
	    is ( $combos{"$style$mode"},
		 $combos{"$mode$style"},
		 "results for $style$mode vs $mode$style are the same" );
	}
    }

    my %save = %combos;
    %combos = ();	# outputs for $mode=any($order) and any($style)

    # add more samples with switching modes & sticky styles
    for $style (@@styles) {
	walk_output(\$sample);
	reset_sequence();
	$walker->($style);
	for $mode (@@modes) {
	    walk_output(\$sample);
	    reset_sequence();
	    $walker->($mode);
	    $combos{"$style/$mode"} = $sample;
	}
    }
    # crosscheck that samples are all text-different
    @@nm = sort keys %combos;
    for $i (0..$#nm) {
	for $j ($i+1..$#nm) {
	    isnt ($combos{$nm[$i]}, $combos{$nm[$j]},
		  "results for $nm[$i] and $nm[$j] are different, as expected");
	}
    }
    
    # add samples with switching styles & sticky modes
    for $mode (@@modes) {
	walk_output(\$sample);
	reset_sequence();
	$walker->($mode);
	for $style (@@styles) {
	    walk_output(\$sample);
	    reset_sequence();
	    $walker->($style);
	    $combos{"$mode/$style"} = $sample;
	}
    }
    # test commutativity of flags, ie that AB == BA
    for $mode (@@modes) {
	for $style (@@styles) {
	    is ( $combos{"$style/$mode"},
		 $combos{"$mode/$style"},
		 "results for $style/$mode vs $mode/$style are the same" );
	}
    }


    #now do double crosschecks: commutativity across stick / nostick
    %combos = (%combos, %save);

    # test commutativity of flags, ie that AB == BA
    for $mode (@@modes) {
	for $style (@@styles) {

	    is ( $combos{"$style$mode"},
		 $combos{"$style/$mode"},
		 "$style$mode VS $style/$mode are the same" );

	    is ( $combos{"$mode$style"},
		 $combos{"$mode/$style"},
		 "$mode$style VS $mode/$style are the same" );

	    is ( $combos{"$style$mode"},
		 $combos{"$mode/$style"},
		 "$style$mode VS $mode/$style are the same" );

	    is ( $combos{"$mode$style"},
		 $combos{"$style/$mode"},
		 "$mode$style VS $style/$mode are the same" );
	}
    }
}


# test proper NULLING of pointer, derefd by CvSTART, when a coderef is
# undefd.  W/o this, the pointer can dangle into freed and reused
# optree mem, which no longer points to opcodes.

# Using B::Concise to render Config::AUTOLOAD's optree at BEGIN-time
# triggers this obscure bug, cuz AUTOLOAD has a bootstrap version,
# which is used at load-time then undeffed.  It is normally
# re-vivified later, but not in time for this (BEGIN/CHECK)-time
# rendering.

$out = runperl ( switches => ["-MO=Concise,Config::AUTOLOAD"],
		 prog => 'use Config; BEGIN { $Config{awk} }',
		 stderr => 1 );

like($out, qr/Config::AUTOLOAD exists in stash, but has no START/,
    "coderef properly undefined");

$out = runperl ( switches => ["-MO=Concise,Config::AUTOLOAD"],
		 prog => 'use Config; CHECK { $Config{awk} }',
		 stderr => 1 );

like($out, qr/Config::AUTOLOAD exists in stash, but has no START/,
    "coderef properly undefined");

# test -stash and -src rendering
$out = runperl ( switches => ["-MO=-qq,Concise,-stash=B::Concise,-src"],
		 prog => '-e 1', stderr => 1 );

like($out, qr/FUNC: \*B::Concise::concise_cv_obj/,
     "stash rendering of B::Concise includes Concise::concise_cv_obj");

like($out, qr/FUNC: \*B::Concise::walk_output/,
     "stash rendering includes Concise::walk_output");

like($out, qr/\# 4\d\d: \s+ \$l->concise\(\$level\);/,
     "src-line rendering works");

$out = runperl ( switches => ["-MStorable", "-MO=Concise,-stash=Storable,-src"],
		 prog => '-e 1', stderr => 1 );

like($out, qr/FUNC: \*Storable::BIN_MAJOR/,
     "stash rendering has constant sub: Storable::BIN_MAJOR");

like($out, qr/BIN_MAJOR is a constant sub, optimized to a IV/,
     "stash rendering identifies it as constant");

$out = runperl ( switches => ["-MO=Concise,-stash=ExtUtils::Mksymlists,-src,-exec"],
		 prog => '-e 1', stderr => 1 );

like($out, qr/FUNC: \*ExtUtils::Mksymlists::_write_vms/,
     "stash rendering loads package as needed");

$out = runperl ( switches => ["-MO=Concise,-stash=Data::Dumper,-src,-exec"],
		 prog => '-e 1', stderr => 1 );

SKIP: {
    skip "Data::Dumper is statically linked", 1
	if $Config{static_ext} =~ m|\bData/Dumper\b|;
    like($out, qr/FUNC: \*Data::Dumper::format_refaddr/,
	"stash rendering loads package as needed");
}

my $prog = q{package FOO; sub bar { print q{bar} } package main; FOO::bar(); };

# this would fail if %INC used for -stash test
$out = runperl ( switches => ["-MO=Concise,-src,-stash=FOO,-main"],
		 prog => $prog, stderr => 1 );

like($out, qr/FUNC: \*FOO::bar/,
     "stash rendering works on inlined package");

# Test that consecutive nextstate ops are not nulled out when PERLDBf_NOOPT
# is set.
# XXX Does this test belong here?

$out = runperl ( switches => ["-MO=Concise"],
		 prog => 'BEGIN{$^P = 0x04} 1 if 0; print',
		 stderr => 1 );
like $out, qr/nextstate.*nextstate/s,
  'nulling of nextstate-nextstate happeneth not when $^P | PERLDBf_NOOPT';


# A very basic test for -tree output
$out =
 runperl(
  switches => ["-MO=Concise,-tree"], prog => 'print', stderr => 1
 );
ok index $out=~s/\r\n/\n/gr=~s/gvsv\(\*_\)/gvsv[*_]/r, <<'end'=~s/\r\n/\n/gr =>>= 0, '-tree output';
<6>leave[1 ref]-+-<1>enter
                |-<2>nextstate(main 1 -e:1)
                `-<5>print-+-<3>pushmark
                           `-ex-rv2sv---<4>gvsv[*_]
end

# -nobanner
$out =
 runperl(
  switches => ["-MO=Concise,-nobanner,foo"], prog=>'sub foo{}', stderr => 1
 );
unlike $out, qr/main::foo/, '-nobanner';

# glob
$out =
 runperl(
  switches => ["-MO=Concise"], prog=>'glob(q{.})', stderr => 1
 );
like $out, qr/\*<none>::/, 'glob(q{.})';

# Test op_other in -debug
$out = runperl(
    switches => ["-MO=Concise,-debug,xx"],
    prog => q{sub xx { if ($a) { return $b } }},
    stderr => 1,
);

$out =~s/\r\n/\n/g;

# Look for OP_AND
$end = <<'EOF';
LOGOP \(0x\w+\)
	op_next		0x\w+
	op_other	(0x\w+)
	op_sibling	0
	op_ppaddr	PL_ppaddr\[OP_AND\]
EOF

$end =~ s/\r\n/\n/g;

like $out, qr/$end/, 'OP_AND has op_other';

# like(..) above doesn't fill in $1
$out =~ $end;
my $next = $1;

# Check it points to a PUSHMARK
$end = <<'EOF';
OP \(<NEXT>\)
	op_next		0x\w+
	op_sibling	0x\w+
	op_ppaddr	PL_ppaddr\[OP_PUSHMARK\]
EOF

$end =~ s/<NEXT>/$next/;

like $out, qr/$end/, 'OP_AND->op_other points correctly';

__END__
@


1.1
log
@Initial revision
@
text
@d4 7
a10 3
    chdir 't';
    @@INC = '../lib';
    require './test.pl';
d13 1
a13 1
plan tests => 4;
d26 2
a27 1
($op_base_p1, $cop_base) = ($out =~ /^(\d+)\s*<;>\s*nextstate\(main (\d+) /m);
d32 474
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d9 1
a9 1
plan tests => 5;
d22 1
a22 2
($op_base_p1, $cop_base)
  = ($out =~ /^(\d+)\s*<;>\s*nextstate\(main (-?\d+) /m);
a26 10

# test that with -exec B::Concise navigates past logops (bug #18175)

$out = runperl(
    switches => ["-MO=Concise,-exec"],
    prog => q{$a||=$b && print q/foo/},
    stderr => 1,
);

like($out, qr/print/, "-exec option with ||=");
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@a5 5
    require Config;
    if (($Config::Config{'extensions'} !~ /\bB\b/) ){
        print "1..0 # Skip -- Perl configured without B module\n";
        exit 0;
    }
@


1.1.1.4
log
@perl 5.8.6 from CPAN
@
text
@d14 1
a14 1
plan tests => 142;
d38 1
a38 1
    prog => q{$a=$b && print q/foo/},
d42 1
a42 280
like($out, qr/print/, "'-exec' option output has print opcode");

######## API tests v.60 

use Config;	# used for perlio check
B::Concise->import(qw( set_style set_style_standard add_callback 
		       add_style walk_output reset_sequence ));

## walk_output argument checking

# test that walk_output rejects non-HANDLE args
foreach my $foo ("string", [], {}) {
    eval {  walk_output($foo) };
    isnt ($@@, '', "walk_output() rejects arg '$foo'");
    $@@=''; # clear the fail for next test
}
# test accessor mode when arg undefd or 0
foreach my $foo (undef, 0) {
    my $handle = walk_output($foo);
    is ($handle, \*STDOUT, "walk_output set to STDOUT (default)");
}

{   # any object that can print should be ok for walk_output
    package Hugo;
    sub new { my $foo = bless {} };
    sub print { CORE::print @@_ }
}
my $foo = new Hugo;	# suggested this API fix
eval {  walk_output($foo) };
is ($@@, '', "walk_output() accepts obj that can print");

# test that walk_output accepts a HANDLE arg
SKIP: {
    skip("no perlio in this build", 4)
        unless $Config::Config{useperlio};

    foreach my $foo (\*STDOUT, \*STDERR) {
	eval {  walk_output($foo) };
	is ($@@, '', "walk_output() accepts STD* " . ref $foo);
    }

    # now test a ref to scalar
    eval {  walk_output(\my $junk) };
    is ($@@, '', "walk_output() accepts ref-to-sprintf target");

    $junk = "non-empty";
    eval {  walk_output(\$junk) };
    is ($@@, '', "walk_output() accepts ref-to-non-empty-scalar");
}

## add_style
my @@stylespec;
$@@='';
eval { add_style ('junk_B' => @@stylespec) };
like ($@@, 'expecting 3 style-format args',
    "add_style rejects insufficient args");

@@stylespec = (0,0,0); # right length, invalid values
$@@='';
eval { add_style ('junk' => @@stylespec) };
is ($@@, '', "add_style accepts: stylename => 3-arg-array");

$@@='';
eval { add_style (junk => @@stylespec) };
like ($@@, qr/style 'junk' already exists, choose a new name/,
    "add_style correctly disallows re-adding same style-name" );

# test new arg-checks on set_style
$@@='';
eval { set_style (@@stylespec) };
is ($@@, '', "set_style accepts 3 style-format args");

@@stylespec = (); # bad style

eval { set_style (@@stylespec) };
like ($@@, qr/expecting 3 style-format args/,
    "set_style rejects bad style-format args");

#### for content with doc'd options

my $func = sub{ $a = $b+42 };	# canonical example asub

SKIP: {
    # tests output to GLOB, using perlio feature directly
    skip "no perlio on this build", 122
	unless $Config::Config{useperlio};
    
    set_style_standard('concise');  # MUST CALL before output needed
    
    @@options = qw(
		  -basic -exec -tree -compact -loose -vt -ascii
		  -base10 -bigendian -littleendian
		  );
    foreach $opt (@@options) {
	walk_output(\my $out);
	my $treegen = B::Concise::compile($opt, $func);
	$treegen->();
	#print "foo:$out\n";
	isnt($out, '', "got output with option $opt");
    }
    
    ## test output control via walk_output
    
    my $treegen = B::Concise::compile('-basic', $func); # reused
    
    { # test output into a package global string (sprintf-ish)
	our $thing;
	walk_output(\$thing);
	$treegen->();
	ok($thing, "walk_output to our SCALAR, output seen");
    }
    
    # test walkoutput acceptance of a scalar-bound IO handle
    open (my $fh, '>', \my $buf);
    walk_output($fh);
    $treegen->();
    ok($buf, "walk_output to GLOB, output seen");
    
    ## Test B::Concise::compile error checking
    
    # call compile on non-CODE ref items
    if (0) {
	# pending STASH splaying
	
	foreach my $ref ([], {}) {
	    my $typ = ref $ref;
	    walk_output(\my $out);
	    eval { B::Concise::compile('-basic', $ref)->() };
	    like ($@@, qr/^err: not a coderef: $typ/,
		  "compile detects $typ-ref where expecting subref");
	    # is($out,'', "no output when errd"); # announcement prints
	}
    }
    
    # test against a bogus autovivified subref.
    # in debugger, it should look like:
    #  1  CODE(0x84840cc)
    #      -> &CODE(0x84840cc) in ???
    sub nosuchfunc;
    eval {  B::Concise::compile('-basic', \&nosuchfunc)->()  };
    like ($@@, qr/^err: coderef has no START/,
	  "compile detects CODE-ref w/o actual code");

    foreach my $opt (qw( -concise -exec )) {
	eval { B::Concise::compile($opt,'non_existent_function')->() };
	like ($@@, qr/unknown function \(main::non_existent_function\)/,
	      "'$opt' reports non-existent-function properly");
    }

    # v.62 tests

    pass ("TEST POST-COMPILE OPTION-HANDLING IN WALKER SUBROUTINE");
    
    my $sample;

    my $walker = B::Concise::compile('-basic', $func);
    walk_output(\$sample);
    $walker->('-exec');
    like($sample, qr/goto/m, "post-compile -exec");

    walk_output(\$sample);
    $walker->('-basic');
    unlike($sample, qr/goto/m, "post-compile -basic");


    # bang at it combinatorically
    my %combos;
    my @@modes = qw( -basic -exec );
    my @@styles = qw( -concise -debug -linenoise -terse );

    # prep samples
    for $style (@@styles) {
	for $mode (@@modes) {
	    walk_output(\$sample);
	    reset_sequence();
	    $walker->($style, $mode);
	    $combos{"$style$mode"} = $sample;
	}
    }
    # crosscheck that samples are all text-different
    @@list = sort keys %combos;
    for $i (0..$#list) {
	for $j ($i+1..$#list) {
	    isnt ($combos{$list[$i]}, $combos{$list[$j]},
		  "combos for $list[$i] and $list[$j] are different, as expected");
	}
    }
    
    # add samples with styles in different order
    for $mode (@@modes) {
	for $style (@@styles) {
	    reset_sequence();
	    walk_output(\$sample);
	    $walker->($mode, $style);
	    $combos{"$mode$style"} = $sample;
	}
    }
    # test commutativity of flags, ie that AB == BA
    for $mode (@@modes) {
	for $style (@@styles) {
	    is ( $combos{"$style$mode"},
		 $combos{"$mode$style"},
		 "results for $style$mode vs $mode$style are the same" );
	}
    }

    my %save = %combos;
    my %combos;	# outputs for $mode=any($order) and any($style)

    # add more samples with switching modes & sticky styles
    for $style (@@styles) {
	walk_output(\$sample);
	reset_sequence();
	$walker->($style);
	for $mode (@@modes) {
	    walk_output(\$sample);
	    reset_sequence();
	    $walker->($mode);
	    $combos{"$style/$mode"} = $sample;
	}
    }
    # crosscheck that samples are all text-different
    @@nm = sort keys %combos;
    for $i (0..$#nm) {
	for $j ($i+1..$#nm) {
	    isnt ($combos{$nm[$i]}, $combos{$nm[$j]},
		  "results for $nm[$i] and $nm[$j] are different, as expected");
	}
    }
    
    # add samples with switching styles & sticky modes
    for $mode (@@modes) {
	walk_output(\$sample);
	reset_sequence();
	$walker->($mode);
	for $style (@@styles) {
	    walk_output(\$sample);
	    reset_sequence();
	    $walker->($style);
	    $combos{"$mode/$style"} = $sample;
	}
    }
    # test commutativity of flags, ie that AB == BA
    for $mode (@@modes) {
	for $style (@@styles) {
	    is ( $combos{"$style/$mode"},
		 $combos{"$mode/$style"},
		 "results for $style/$mode vs $mode/$style are the same" );
	}
    }


    #now do double crosschecks: commutativity across stick / nostick
    my %combos = (%combos, %save);

    # test commutativity of flags, ie that AB == BA
    for $mode (@@modes) {
	for $style (@@styles) {

	    is ( $combos{"$style$mode"},
		 $combos{"$style/$mode"},
		 "$style$mode VS $style/$mode are the same" );

	    is ( $combos{"$mode$style"},
		 $combos{"$mode/$style"},
		 "$mode$style VS $mode/$style are the same" );

	    is ( $combos{"$style$mode"},
		 $combos{"$mode/$style"},
		 "$style$mode VS $mode/$style are the same" );

	    is ( $combos{"$mode$style"},
		 $combos{"$style/$mode"},
		 "$mode$style VS $style/$mode are the same" );
	}
    }
}

__END__

@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d4 2
a5 7
    if ($ENV{PERL_CORE}){
	chdir('t') if -d 't';
	@@INC = ('.', '../lib');
    } else {
	unshift @@INC, 't';
	push @@INC, "../../t";
    }
d11 1
a11 2
    require 'test.pl';		# we use runperl from 'test.pl', so can't use Test::More
    sub diag { print "# @@_\n" } # but this is still handy
d14 1
a14 1
plan tests => 149;
d41 1
a41 1
#diag($out);
d118 1
a118 1
      "set_style rejects bad style-format args");
a121 1
our($a, $b);
a123 8
sub render {
    walk_output(\my $out);
    eval { B::Concise::compile(@@_)->() };
    # diag "rendering $@@\n";
    return ($out, $@@) if wantarray;
    return $out;
}

d126 1
a126 1
    skip "no perlio on this build", 127
d136 4
a139 1
	($out) = render($opt, $func);
d160 1
a160 1
    ## test B::Concise::compile error checking
d172 1
a172 1
	    is($out,'', "no output when errd"); # announcement prints
d180 9
a188 38

    my ($res,$err);
    TODO: {
	#local $TODO = "\tdoes this handling make sense ?";

	sub declared_only;
	($res,$err) = render('-basic', \&declared_only);
	like ($res, qr/coderef CODE\(0x[0-9a-fA-F]+\) has no START/,
	      "'sub decl_only' seen as having no START");

	sub defd_empty {};
	($res,$err) = render('-basic', \&defd_empty);
	is(scalar split(/\n/, $res), 3,
	   "'sub defd_empty {}' seen as 3 liner");

	is(1, $res =~ /leavesub/ && $res =~ /nextstate/,
	   "'sub defd_empty {}' seen as 2 ops: leavesub,nextstate");

	($res,$err) = render('-basic', \&not_even_declared);
	like ($res, qr/coderef CODE\(0x[0-9a-fA-F]+\) has no START/,
	      "'\&not_even_declared' seen as having no START");

	{
	    package Bar;
	    our $AUTOLOAD = 'garbage';
	    sub AUTOLOAD { print "# in AUTOLOAD body: $AUTOLOAD\n" }
	}
	($res,$err) = render('-basic', Bar::auto_func);
	like ($res, qr/unknown function \(Bar::auto_func\)/,
	      "Bar::auto_func seen as unknown function");

	($res,$err) = render('-basic', \&Bar::auto_func);
	like ($res, qr/coderef CODE\(0x[0-9a-fA-F]+\) has no START/,
	      "'\&Bar::auto_func' seen as having no START");

	($res,$err) = render('-basic', \&Bar::AUTOLOAD);
	like ($res, qr/in AUTOLOAD body: /, "found body of Bar::AUTOLOAD");

a189 3
    ($res,$err) = render('-basic', Foo::bar);
    like ($res, qr/unknown function \(Foo::bar\)/,
	  "BC::compile detects fn-name as unknown function");
d249 1
a249 1
    %combos = ();	# outputs for $mode=any($order) and any($style)
d295 1
a295 1
    %combos = (%combos, %save);
a318 25


# test proper NULLING of pointer, derefd by CvSTART, when a coderef is
# undefd.  W/o this, the pointer can dangle into freed and reused
# optree mem, which no longer points to opcodes.

# Using B::Concise to render Config::AUTOLOAD's optree at BEGIN-time
# triggers this obscure bug, cuz AUTOLOAD has a bootstrap version,
# which is used at load-time then undeffed.  It is normally
# re-vivified later, but not in time for this (BEGIN/CHECK)-time
# rendering.

$out = runperl ( switches => ["-MO=Concise,Config::AUTOLOAD"],
		 prog => 'use Config; BEGIN { $Config{awk} }',
		 stderr => 1 );

like($out, qr/Config::AUTOLOAD exists in stash, but has no START/,
    "coderef properly undefined");

$out = runperl ( switches => ["-MO=Concise,Config::AUTOLOAD"],
		 prog => 'use Config; CHECK { $Config{awk} }',
		 stderr => 1 );

like($out, qr/Config::AUTOLOAD exists in stash, but has no START/,
    "coderef properly undefined");
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d20 1
a20 1
plan tests => 156;
d207 1
a207 1
	is(1, $res =~ /leavesub/ && $res =~ /(next|db)state/,
d389 1
a389 20
# test -stash and -src rendering
# todo: stderr=1 puts '-e syntax OK' into $out,
# conceivably fouling one of the lines that are tested
$out = runperl ( switches => ["-MO=Concise,-stash=B::Concise,-src"],
		 prog => '-e 1', stderr => 1 );

like($out, qr/FUNC: \*B::Concise::concise_cv_obj/,
     "stash rendering of B::Concise includes Concise::concise_cv_obj");

like($out, qr/FUNC: \*B::Concise::walk_output/,
     "stash rendering includes Concise::walk_output");

like($out, qr/FUNC: \*B::Concise::PAD_FAKELEX_MULTI/,
     "stash rendering includes constant sub: PAD_FAKELEX_MULTI");

like($out, qr/PAD_FAKELEX_MULTI is a constant sub, optimized to a IV/,
     "stash rendering identifies it as constant");

like($out, qr/\# 4\d\d: \s+ \$l->concise\(\$level\);/,
     "src-line rendering works");
a390 16
$out = runperl ( switches => ["-MO=Concise,-stash=Data::Dumper,-src,-exec"],
		 prog => '-e 1', stderr => 1 );

like($out, qr/FUNC: \*Data::Dumper::format_refaddr/,
     "stash rendering loads package as needed");

my $prog = q{package FOO; sub bar { print "bar" } package main; FOO::bar(); };

# this would fail if %INC used for -stash test
$out = runperl ( switches => ["-MO=Concise,-src,-stash=FOO,-main"],
		 prog => $prog, stderr => 1 );

like($out, qr/FUNC: \*FOO::bar/,
     "stash rendering works on inlined package");

__END__
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d17 1
d20 1
a20 1
plan tests => 157;
d204 1
a204 2
	my @@lines = split(/\n/, $res);
	is(scalar @@lines, 3,
a408 6

$out = runperl ( switches => ["-MO=Concise,-stash=ExtUtils::Mksymlists,-src,-exec"],
		 prog => '-e 1', stderr => 1 );

like($out, qr/FUNC: \*ExtUtils::Mksymlists::_write_vms/,
     "stash rendering loads package as needed");
@


1.1.1.8
log
@Perl 5.12.2 from CPAN
@
text
@d4 7
a10 1
    unshift @@INC, 't';
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d13 1
a13 1
plan tests => 159;
d95 1
a95 1
like ($@@, qr/expecting 3 style-format args/,
d395 1
a395 7
like($out, qr/\# 4\d\d: \s+ \$l->concise\(\$level\);/,
     "src-line rendering works");

$out = runperl ( switches => ["-MStorable", "-MO=Concise,-stash=Storable,-src"],
		 prog => '-e 1', stderr => 1 );

like($out, qr/FUNC: \*Storable::BIN_MAJOR/,
d398 1
a398 1
like($out, qr/BIN_MAJOR is a constant sub, optimized to a IV/,
d401 3
d416 1
a416 1
my $prog = q{package FOO; sub bar { print q{bar} } package main; FOO::bar(); };
a423 23

# Test that consecutive nextstate ops are not nulled out when PERLDBf_NOOPT
# is set.
# XXX Does this test belong here?

$out = runperl ( switches => ["-MO=Concise"],
		 prog => 'BEGIN{$^P = 0x04} 1 if 0; print',
		 stderr => 1 );
like $out, qr/nextstate.*nextstate/s,
  'nulling of nextstate-nextstate happeneth not when $^P | PERLDBf_NOOPT';


# A very basic test for -tree output
$out =
 runperl(
  switches => ["-MO=Concise,-tree"], prog => 'print', stderr => 1
 );
ok index $out=~s/\r\n/\n/gr=~s/gvsv\(\*_\)/gvsv[*_]/r, <<'end'=~s/\r\n/\n/gr =>>= 0, '-tree output';
<6>leave[1 ref]-+-<1>enter
                |-<2>nextstate(main 1 -e:1)
                `-<5>print-+-<3>pushmark
                           `-ex-rv2sv---<4>gvsv[*_]
end
@


1.1.1.10
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d13 1
a13 1
plan tests => 161;
a449 14

# -nobanner
$out =
 runperl(
  switches => ["-MO=Concise,-nobanner,foo"], prog=>'sub foo{}', stderr => 1
 );
unlike $out, 'main::foo', '-nobanner';

# glob
$out =
 runperl(
  switches => ["-MO=Concise"], prog=>'<.>', stderr => 1
 );
like $out, '\*<none>::', '<.>';
@


1.1.1.11
log
@Import perl-5.20.1
@
text
@d13 1
a13 1
plan tests => 163;
d416 2
a417 6
SKIP: {
    skip "Data::Dumper is statically linked", 1
	if $Config{static_ext} =~ m|\bData/Dumper\b|;
    like($out, qr/FUNC: \*Data::Dumper::format_refaddr/,
	"stash rendering loads package as needed");
}
d461 1
a461 1
  switches => ["-MO=Concise"], prog=>'glob(q{.})', stderr => 1
d463 1
a463 39
like $out, '\*<none>::', 'glob(q{.})';

# Test op_other in -debug
$out = runperl(
    switches => ["-MO=Concise,-debug,xx"],
    prog => q{sub xx { if ($a) { return $b } }},
    stderr => 1,
);

$out =~s/\r\n/\n/g;

# Look for OP_AND
$end = <<'EOF';
LOGOP \(0x\w+\)
	op_next		0x\w+
	op_other	(0x\w+)
	op_sibling	0
	op_ppaddr	PL_ppaddr\[OP_AND\]
EOF

$end =~ s/\r\n/\n/g;

like $out, $end, 'OP_AND has op_other';

# like(..) above doesn't fill in $1
$out =~ $end;
my $next = $1;

# Check it points to a PUSHMARK
$end = <<'EOF';
OP \(<NEXT>\)
	op_next		0x\w+
	op_sibling	0x\w+
	op_ppaddr	PL_ppaddr\[OP_PUSHMARK\]
EOF

$end =~ s/<NEXT>/$next/;

like $out, $end, 'OP_AND->op_other points correctly';
@


