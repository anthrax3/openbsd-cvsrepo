head	1.1;
branch	1.1.1;
access;
symbols
	PERL_5_24_2:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.14
	OPENBSD_6_1_BASE:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.12
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.6
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.8
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.2
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.4
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.6
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.2
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2013.03.25.20.08.44;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.03.25.20.08.44;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl

BEGIN {
    unshift @@INC, 't';
    require Config;
    if (($Config::Config{'extensions'} !~ /\bB\b/) ){
        print "1..0 # Skip -- Perl configured without B module\n";
        exit 0;
    }
}

use warnings;
use strict;
use Test::More;

BEGIN { use_ok( 'B' ); }

# Somewhat minimal tests.

my %seen;

sub B::OP::pie {
    my $self = shift;
    return ++$seen{$self->name};
}

my %debug;
sub B::OP::walkoptree_debug {
    my $self = shift;
    return ++$debug{$self->name};
}

my $victim = sub {
    # This gives us a substcont, which gets to the second recursive call
    # point (in the if statement in the XS code)
    $_[0] =~ s/(a)/$1/;
    # PMOP_pmreplroot(cPMOPo) is NULL for this
    $_[0] =~ s/(b)//;
    # This gives an OP_PUSHRE
    split /c/;
};

is (B::walkoptree_debug, 0, 'walkoptree_debug() is 0');
B::walkoptree(B::svref_2object($victim)->ROOT, "pie");
foreach (qw(substcont pushre split leavesub)) {
    is ($seen{$_}, 1, "Our victim had a $_ OP");
}
is_deeply ([keys %debug], [], 'walkoptree_debug was not called');

B::walkoptree_debug(2);
is (B::walkoptree_debug, 1, 'walkoptree_debug() is 1');
%seen = ();

B::walkoptree(B::svref_2object($victim)->ROOT, "pie");
foreach (qw(substcont pushre split leavesub)) {
    is ($seen{$_}, 1, "Our victim had a $_ OP");
}
is_deeply (\%debug, \%seen, 'walkoptree_debug was called correctly');

my %seen2;

# Now try to exercise the code in walkoptree that decides that it can't re-use
# the object and reference.
sub B::OP::fiddle {
    my $name = $_[0]->name;
    ++$seen2{$name};
    if ($name =~ /^s/) {
	# Take another reference to the reference
	push @@::junk, \$_[0];
    } elsif ($name =~ /^p/) {
	# Take another reference to the object
	push @@::junk, \${$_[0]};
    } elsif ($name =~ /^l/) {
	undef $_[0];
    } elsif ($name =~ /g/) {
	${$_[0]} = "Muhahahahaha!";
    } elsif ($name =~ /^c/) {
	bless \$_[0];
    }
}

B::walkoptree(B::svref_2object($victim)->ROOT, "fiddle");
is_deeply (\%seen2, \%seen, 'everything still seen');

done_testing();
@


1.1.1.1
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@@


1.1.1.2
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d36 1
a36 1
    $_[0] =~ s/(a)/ $1/;
@

