head	1.2;
access;
symbols
	OPENBSD_6_0:1.1.1.7.0.10
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.4
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.6
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.6.0.4
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.6
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.2
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.4.0.10
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.8
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.6
	OPENBSD_5_0:1.1.1.4.0.4
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.2
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.3.0.8
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.4
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.10
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.8
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.6
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.4
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.2
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.1.0.6
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.4
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.2
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.11;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.03.28.18.47.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.14;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.09.24.14.48.52;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.08.43;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!perl

BEGIN {
    unshift @@INC, 't';
    require Config;
    if (($Config::Config{'extensions'} !~ /\bB\b/) ){
        print "1..0 # Skip -- Perl configured without B module\n";
        exit 0;
    }
    if (!$Config::Config{useperlio}) {
        print "1..0 # Skip -- need perlio to walk the optree\n";
        exit 0;
    }
}
use OptreeCheck;
use Config;
plan tests	=> 42;

pass("OPTIMIZER TESTS - VAR INITIALIZATION");

checkOptree ( name	=> 'sub {my $a}',
	      bcopts	=> '-exec',
	      code	=> sub {my $a},
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 45 optree.t:23) v:>,<,%
# 2  <0> padsv[$a:45,46] sM/LVINTRO
# 3  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 45 optree.t:23) v:>,<,%
# 2  <0> padsv[$a:45,46] sM/LVINTRO
# 3  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> '-exec sub {my $a}',
	      bcopts	=> '-exec',
	      code	=> sub {my $a},
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 49 optree.t:52) v:>,<,%
# 2  <0> padsv[$a:49,50] sM/LVINTRO
# 3  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 49 optree.t:45) v:>,<,%
# 2  <0> padsv[$a:49,50] sM/LVINTRO
# 3  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> 'sub {our $a}',
	      bcopts	=> '-exec',
	      code	=> sub {our $a},
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <;> nextstate(main 21 optree.t:47) v:>,<,%
2  <#> gvsv[*a] s/OURINTR
3  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 51 optree.t:56) v:>,<,%
# 2  <$> gvsv(*a) s/OURINTR
# 3  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> 'sub {local $a}',
	      bcopts	=> '-exec',
	      code	=> sub {local $a},
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <;> nextstate(main 23 optree.t:57) v:>,<,%,{
2  <#> gvsv[*a] s/LVINTRO
3  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 53 optree.t:67) v:>,<,%,{
# 2  <$> gvsv(*a) s/LVINTRO
# 3  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> 'my $a',
	      prog	=> 'my $a',
	      bcopts	=> '-basic',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 4  <@@> leave[1 ref] vKP/REFC ->(end)
# 1     <0> enter ->2
# 2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
# 3     <0> padsv[$a:1,2] vM/LVINTRO ->4
EOT_EOT
# 4  <@@> leave[1 ref] vKP/REFC ->(end)
# 1     <0> enter ->2
# 2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
# 3     <0> padsv[$a:1,2] vM/LVINTRO ->4
EONT_EONT

checkOptree ( name	=> 'our $a',
	      prog	=> 'our $a',
	      bcopts	=> '-basic',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
3  <@@> leave[1 ref] vKP/REFC ->(end)
1     <0> enter ->2
2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
-     <1> rv2sv vK/OURINTR,1 ->3
-        <#> gv[*a] s ->-
EOT_EOT
# 3  <@@> leave[1 ref] vKP/REFC ->(end)
# 1     <0> enter ->2
# 2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
# -     <1> rv2sv vK/OURINTR,1 ->3
# -        <$> gv(*a) s ->-
EONT_EONT

checkOptree ( name	=> 'local $c',
	      prog	=> 'local $c',
	      errs      => ['Name "main::c" used only once: possible typo at -e line 1.'],
	      bcopts	=> '-basic',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
4  <@@> leave[1 ref] vKP/REFC ->(end)
1     <0> enter ->2
2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
-     <1> ex-rv2sv vKM/LVINTRO,1 ->4
3        <#> gvsv[*c] s/LVINTRO ->4
EOT_EOT
# 4  <@@> leave[1 ref] vKP/REFC ->(end)
# 1     <0> enter ->2
# 2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
# -     <1> ex-rv2sv vKM/LVINTRO,1 ->4
# 3        <$> gvsv(*c) s/LVINTRO ->4
EONT_EONT

pass("MY, OUR, LOCAL, BOTH SUB AND MAIN, = undef");

checkOptree ( name	=> 'sub {my $a=undef}',
	      code	=> sub {my $a=undef},
	      bcopts	=> '-basic',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
5  <1> leavesub[1 ref] K/REFC,1 ->(end)
-     <@@> lineseq KP ->5
1        <;> nextstate(main 641 optree_varinit.t:130) v:>,<,% ->2
4        <2> sassign sKS/2 ->5
2           <0> undef s ->3
3           <0> padsv[$a:641,642] sRM*/LVINTRO ->4
EOT_EOT
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 641 optree_varinit.t:130) v:>,<,% ->2
# 4        <2> sassign sKS/2 ->5
# 2           <0> undef s ->3
# 3           <0> padsv[$a:641,642] sRM*/LVINTRO ->4
EONT_EONT

checkOptree ( name	=> 'sub {our $a=undef}',
	      code	=> sub {our $a=undef},
	      note	=> 'the global must be reset',
	      bcopts	=> '-basic',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
5  <1> leavesub[1 ref] K/REFC,1 ->(end)
-     <@@> lineseq KP ->5
1        <;> nextstate(main 26 optree.t:109) v:>,<,%,{ ->2
4        <2> sassign sKS/2 ->5
2           <0> undef s ->3
-           <1> ex-rv2sv sKRM*/OURINTR,1 ->4
3              <#> gvsv[*a] s/OURINTR ->4
EOT_EOT
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 446 optree_varinit.t:137) v:>,<,%,{ ->2
# 4        <2> sassign sKS/2 ->5
# 2           <0> undef s ->3
# -           <1> ex-rv2sv sKRM*/OURINTR,1 ->4
# 3              <$> gvsv(*a) s/OURINTR ->4
EONT_EONT

checkOptree ( name	=> 'sub {local $a=undef}',
	      code	=> sub {local $a=undef},
	      note	=> 'local not used enough to bother',
	      bcopts	=> '-basic',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
5  <1> leavesub[1 ref] K/REFC,1 ->(end)
-     <@@> lineseq KP ->5
1        <;> nextstate(main 28 optree.t:122) v:>,<,%,{ ->2
4        <2> sassign sKS/2 ->5
2           <0> undef s ->3
-           <1> ex-rv2sv sKRM*/LVINTRO,1 ->4
3              <#> gvsv[*a] s/LVINTRO ->4
EOT_EOT
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 58 optree.t:141) v:>,<,%,{ ->2
# 4        <2> sassign sKS/2 ->5
# 2           <0> undef s ->3
# -           <1> ex-rv2sv sKRM*/LVINTRO,1 ->4
# 3              <$> gvsv(*a) s/LVINTRO ->4
EONT_EONT

checkOptree ( name	=> 'my $a=undef',
	      prog	=> 'my $a=undef',
	      bcopts	=> '-basic',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
6  <@@> leave[1 ref] vKP/REFC ->(end)
1     <0> enter ->2
2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
5     <2> sassign vKS/2 ->6
3        <0> undef s ->4
4        <0> padsv[$a:1,2] sRM*/LVINTRO ->5
EOT_EOT
# 6  <@@> leave[1 ref] vKP/REFC ->(end)
# 1     <0> enter ->2
# 2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
# 5     <2> sassign vKS/2 ->6
# 3        <0> undef s ->4
# 4        <0> padsv[$a:1,2] sRM*/LVINTRO ->5
EONT_EONT

checkOptree ( name	=> 'our $a=undef',
	      prog	=> 'our $a=undef',
	      note	=> 'global must be reassigned',
	      bcopts	=> '-basic',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
6  <@@> leave[1 ref] vKP/REFC ->(end)
1     <0> enter ->2
2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
5     <2> sassign vKS/2 ->6
3        <0> undef s ->4
-        <1> ex-rv2sv sKRM*/OURINTR,1 ->5
4           <#> gvsv[*a] s/OURINTR ->5
EOT_EOT
# 6  <@@> leave[1 ref] vKP/REFC ->(end)
# 1     <0> enter ->2
# 2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
# 5     <2> sassign vKS/2 ->6
# 3        <0> undef s ->4
# -        <1> ex-rv2sv sKRM*/OURINTR,1 ->5
# 4           <$> gvsv(*a) s/OURINTR ->5
EONT_EONT

checkOptree ( name	=> 'local $c=undef',
	      prog	=> 'local $c=undef',
	      errs      => ['Name "main::c" used only once: possible typo at -e line 1.'],
	      note	=> 'locals are rare, probably not worth doing',
	      bcopts	=> '-basic',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
6  <@@> leave[1 ref] vKP/REFC ->(end)
1     <0> enter ->2
2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
5     <2> sassign vKS/2 ->6
3        <0> undef s ->4
-        <1> ex-rv2sv sKRM*/LVINTRO,1 ->5
4           <#> gvsv[*c] s/LVINTRO ->5
EOT_EOT
# 6  <@@> leave[1 ref] vKP/REFC ->(end)
# 1     <0> enter ->2
# 2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
# 5     <2> sassign vKS/2 ->6
# 3        <0> undef s ->4
# -        <1> ex-rv2sv sKRM*/LVINTRO,1 ->5
# 4           <$> gvsv(*c) s/LVINTRO ->5
EONT_EONT

checkOptree ( name	=> 'sub {my $a=()}',
	      code	=> sub {my $a=()},
	      bcopts	=> '-exec',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <;> nextstate(main -439 optree.t:105) v:>,<,%
2  <0> stub sP
3  <0> padsv[$a:-439,-438] sRM*/LVINTRO
4  <2> sassign sKS/2
5  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 438 optree_varinit.t:247) v:>,<,%
# 2  <0> stub sP
# 3  <0> padsv[$a:438,439] sRM*/LVINTRO
# 4  <2> sassign sKS/2
# 5  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> 'sub {our $a=()}',
	      code	=> sub {our $a=()},
              #todo	=> 'probly not worth doing',
	      bcopts	=> '-exec',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <;> nextstate(main 31 optree.t:177) v:>,<,%,{
2  <0> stub sP
3  <#> gvsv[*a] s/OURINTR
4  <2> sassign sKS/2
5  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 440 optree_varinit.t:262) v:>,<,%,{
# 2  <0> stub sP
# 3  <$> gvsv(*a) s/OURINTR
# 4  <2> sassign sKS/2
# 5  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> 'sub {local $a=()}',
	      code	=> sub {local $a=()},
              #todo	=> 'probly not worth doing',
	      bcopts	=> '-exec',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <;> nextstate(main 33 optree.t:190) v:>,<,%,{
2  <0> stub sP
3  <#> gvsv[*a] s/LVINTRO
4  <2> sassign sKS/2
5  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 63 optree.t:225) v:>,<,%,{
# 2  <0> stub sP
# 3  <$> gvsv(*a) s/LVINTRO
# 4  <2> sassign sKS/2
# 5  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> 'my $a=()',
	      prog	=> 'my $a=()',
	      bcopts	=> '-exec',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <0> enter 
2  <;> nextstate(main 1 -e:1) v:>,<,%,{
3  <0> stub sP
4  <0> padsv[$a:1,2] sRM*/LVINTRO
5  <2> sassign vKS/2
6  <@@> leave[1 ref] vKP/REFC
EOT_EOT
# 1  <0> enter 
# 2  <;> nextstate(main 1 -e:1) v:>,<,%,{
# 3  <0> stub sP
# 4  <0> padsv[$a:1,2] sRM*/LVINTRO
# 5  <2> sassign vKS/2
# 6  <@@> leave[1 ref] vKP/REFC
EONT_EONT

checkOptree ( name	=> 'our $a=()',
	      prog	=> 'our $a=()',
              #todo	=> 'probly not worth doing',
	      bcopts	=> '-exec',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <0> enter 
2  <;> nextstate(main 1 -e:1) v:>,<,%,{
3  <0> stub sP
4  <#> gvsv[*a] s/OURINTR
5  <2> sassign vKS/2
6  <@@> leave[1 ref] vKP/REFC
EOT_EOT
# 1  <0> enter 
# 2  <;> nextstate(main 1 -e:1) v:>,<,%,{
# 3  <0> stub sP
# 4  <$> gvsv(*a) s/OURINTR
# 5  <2> sassign vKS/2
# 6  <@@> leave[1 ref] vKP/REFC
EONT_EONT

checkOptree ( name	=> 'local $c=()',
	      prog	=> 'local $c=()',
	      errs      => ['Name "main::c" used only once: possible typo at -e line 1.'],
              #todo	=> 'probly not worth doing',
	      bcopts	=> '-exec',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <0> enter 
2  <;> nextstate(main 1 -e:1) v:>,<,%,{
3  <0> stub sP
4  <#> gvsv[*c] s/LVINTRO
5  <2> sassign vKS/2
6  <@@> leave[1 ref] vKP/REFC
EOT_EOT
# 1  <0> enter 
# 2  <;> nextstate(main 1 -e:1) v:>,<,%,{
# 3  <0> stub sP
# 4  <$> gvsv(*c) s/LVINTRO
# 5  <2> sassign vKS/2
# 6  <@@> leave[1 ref] vKP/REFC
EONT_EONT

checkOptree ( name	=> 'my ($a,$b)=()',
	      prog	=> 'my ($a,$b)=()',
              #todo	=> 'probly not worth doing',
	      bcopts	=> '-exec',
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <0> enter 
# 2  <;> nextstate(main 1 -e:1) v:>,<,%,{
# 3  <0> pushmark s
# 4  <0> padrange[$a:1,2; $b:1,2] RM/LVINTRO,2
# 5  <2> aassign[t3] vKS
# 6  <@@> leave[1 ref] vKP/REFC
EOT_EOT
# 1  <0> enter 
# 2  <;> nextstate(main 1 -e:1) v:>,<,%,{
# 3  <0> pushmark s
# 4  <0> padrange[$a:1,2; $b:1,2] RM/LVINTRO,2
# 5  <2> aassign[t3] vKS
# 6  <@@> leave[1 ref] vKP/REFC
EONT_EONT
@


1.1
log
@Initial revision
@
text
@d4 1
a4 2
    chdir 't';
    @@INC = ('../lib', '../ext/B/t');
d10 4
a13 1
    require './test.pl';
d17 1
a17 3
plan tests	=> 22;
SKIP: {
skip "no perlio in this build", 22 unless $Config::Config{useperlio};
d24 1
d26 2
a27 2
# 1  <;> nextstate(main 45 optree.t:23) v
# 2  <0> padsv[$a:45,46] M/LVINTRO
d30 2
a31 2
# 1  <;> nextstate(main 45 optree.t:23) v
# 2  <0> padsv[$a:45,46] M/LVINTRO
d38 1
d40 2
a41 2
# 1  <;> nextstate(main 49 optree.t:52) v
# 2  <0> padsv[$a:49,50] M/LVINTRO
d44 2
a45 2
# 1  <;> nextstate(main 49 optree.t:45) v
# 2  <0> padsv[$a:49,50] M/LVINTRO
d52 1
d54 1
a54 1
1  <;> nextstate(main 21 optree.t:47) v
d58 1
a58 1
# 1  <;> nextstate(main 51 optree.t:56) v
d66 1
d68 1
a68 1
1  <;> nextstate(main 23 optree.t:57) v
d72 1
a72 1
# 1  <;> nextstate(main 53 optree.t:67) v
d80 1
d84 1
a84 1
# 2     <;> nextstate(main 1 -e:1) v ->3
d89 1
a89 1
# 2     <;> nextstate(main 1 -e:1) v ->3
d96 1
d98 1
a98 1
4  <@@> leave[1 ref] vKP/REFC ->(end)
d100 3
a102 3
2     <;> nextstate(main 1 -e:1) v ->3
-     <1> ex-rv2sv vK/17 ->4
3        <#> gvsv[*a] s/OURINTR ->4
d104 1
a104 1
# 4  <@@> leave[1 ref] vKP/REFC ->(end)
d106 3
a108 3
# 2     <;> nextstate(main 1 -e:1) v ->3
# -     <1> ex-rv2sv vK/17 ->4
# 3        <$> gvsv(*a) s/OURINTR ->4
d111 3
a113 2
checkOptree ( name	=> 'local $a',
	      prog	=> 'local $a',
d115 1
d119 3
a121 3
2     <;> nextstate(main 1 -e:1) v ->3
-     <1> ex-rv2sv vKM/129 ->4
3        <#> gvsv[*a] s/LVINTRO ->4
d125 3
a127 3
# 2     <;> nextstate(main 1 -e:1) v ->3
# -     <1> ex-rv2sv vKM/129 ->4
# 3        <$> gvsv(*a) s/LVINTRO ->4
d135 1
d137 13
a149 9
3  <1> leavesub[1 ref] K/REFC,1 ->(end)
-     <@@> lineseq KP ->3
1        <;> nextstate(main 24 optree.t:99) v ->2
2        <0> padsv[$a:24,25] sRM*/LVINTRO ->3
EOT_EOT
# 3  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->3
# 1        <;> nextstate(main 54 optree.t:149) v ->2
# 2        <0> padsv[$a:54,55] sRM*/LVINTRO ->3
d156 1
d160 1
a160 1
1        <;> nextstate(main 26 optree.t:109) v ->2
d163 1
a163 1
-           <1> ex-rv2sv sKRM*/17 ->4
d168 1
a168 1
# 1        <;> nextstate(main 446 optree_varinit.t:137) v ->2
d171 1
a171 1
# -           <1> ex-rv2sv sKRM*/17 ->4
d179 1
d183 1
a183 1
1        <;> nextstate(main 28 optree.t:122) v ->2
d186 1
a186 1
-           <1> ex-rv2sv sKRM*/129 ->4
d191 1
a191 1
# 1        <;> nextstate(main 58 optree.t:141) v ->2
d194 1
a194 1
# -           <1> ex-rv2sv sKRM*/129 ->4
d201 1
d203 1
a203 1
4  <@@> leave[1 ref] vKP/REFC ->(end)
d205 4
a208 2
2     <;> nextstate(main 1 -e:1) v ->3
3     <0> padsv[$a:1,2] vRM*/LVINTRO ->4
d210 1
a210 1
# 4  <@@> leave[1 ref] vKP/REFC ->(end)
d212 4
a215 2
# 2     <;> nextstate(main 1 -e:1) v ->3
# 3     <0> padsv[$a:1,2] vRM*/LVINTRO ->4
d222 1
d226 1
a226 1
2     <;> nextstate(main 1 -e:1) v ->3
d229 1
a229 1
-        <1> ex-rv2sv sKRM*/17 ->5
d234 1
a234 1
# 2     <;> nextstate(main 1 -e:1) v ->3
d237 1
a237 1
# -        <1> ex-rv2sv sKRM*/17 ->5
d241 4
a244 3
checkOptree ( name	=> 'local $a=undef',
	      prog	=> 'local $a=undef',
	      note	=> 'locals are rare, probly not worth doing',
d246 1
d250 1
a250 1
2     <;> nextstate(main 1 -e:1) v ->3
d253 2
a254 2
-        <1> ex-rv2sv sKRM*/129 ->5
4           <#> gvsv[*a] s/LVINTRO ->5
d258 1
a258 1
# 2     <;> nextstate(main 1 -e:1) v ->3
d261 2
a262 2
# -        <1> ex-rv2sv sKRM*/129 ->5
# 4           <$> gvsv(*a) s/LVINTRO ->5
d268 1
d270 1
a270 1
1  <;> nextstate(main -439 optree.t:105) v
d276 1
a276 1
# 1  <;> nextstate(main 438 optree_varinit.t:247) v
d287 1
d289 1
a289 1
1  <;> nextstate(main 31 optree.t:177) v
d295 1
a295 1
# 1  <;> nextstate(main 440 optree_varinit.t:262) v
d306 1
d308 1
a308 1
1  <;> nextstate(main 33 optree.t:190) v
d314 1
a314 1
# 1  <;> nextstate(main 63 optree.t:225) v
d324 1
d327 1
a327 1
2  <;> nextstate(main 1 -e:1) v
d334 1
a334 1
# 2  <;> nextstate(main 1 -e:1) v
d345 1
d348 1
a348 1
2  <;> nextstate(main 1 -e:1) v
d355 1
a355 1
# 2  <;> nextstate(main 1 -e:1) v
d362 3
a364 2
checkOptree ( name	=> 'local $a=()',
	      prog	=> 'local $a=()',
d367 1
d370 1
a370 1
2  <;> nextstate(main 1 -e:1) v
d372 1
a372 1
4  <#> gvsv[*a] s/LVINTRO
d377 1
a377 1
# 2  <;> nextstate(main 1 -e:1) v
d379 1
a379 1
# 4  <$> gvsv(*a) s/LVINTRO
d388 1
d391 1
a391 1
# 2  <;> nextstate(main 1 -e:1) v
d393 3
a395 5
# 4  <0> pushmark sRM*/128
# 5  <0> padsv[$a:1,2] lRM*/LVINTRO
# 6  <0> padsv[$b:1,2] lRM*/LVINTRO
# 7  <2> aassign[t3] vKS
# 8  <@@> leave[1 ref] vKP/REFC
d398 1
a398 1
# 2  <;> nextstate(main 1 -e:1) v
d400 3
a402 5
# 4  <0> pushmark sRM*/128
# 5  <0> padsv[$a:1,2] lRM*/LVINTRO
# 6  <0> padsv[$b:1,2] lRM*/LVINTRO
# 7  <2> aassign[t3] vKS
# 8  <@@> leave[1 ref] vKP/REFC
a403 5

} #skip

__END__

@


1.1.1.1
log
@perl 5.8.6 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.8 import
@
text
@d4 2
a5 7
    if ($ENV{PERL_CORE}){
	chdir('t') if -d 't';
	@@INC = ('.', '../lib', '../ext/B/t');
    } else {
	unshift @@INC, 't';
	push @@INC, "../../t";
    }
d11 1
a11 1
    # require 'test.pl'; # now done by OptreeCheck
a106 1
	      errs      => ['Name "main::a" used only once: possible typo at -e line 1.'],
d128 9
a136 13
5  <1> leavesub[1 ref] K/REFC,1 ->(end)
-     <@@> lineseq KP ->5
1        <;> nextstate(main 641 optree_varinit.t:130) v ->2
4        <2> sassign sKS/2 ->5
2           <0> undef s ->3
3           <0> padsv[$a:641,642] sRM*/LVINTRO ->4
EOT_EOT
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 641 optree_varinit.t:130) v ->2
# 4        <2> sassign sKS/2 ->5
# 2           <0> undef s ->3
# 3           <0> padsv[$a:641,642] sRM*/LVINTRO ->4
d187 1
a187 1
6  <@@> leave[1 ref] vKP/REFC ->(end)
d190 1
a190 3
5     <2> sassign vKS/2 ->6
3        <0> undef s ->4
4        <0> padsv[$a:1,2] sRM*/LVINTRO ->5
d192 1
a192 1
# 6  <@@> leave[1 ref] vKP/REFC ->(end)
d195 1
a195 3
# 5     <2> sassign vKS/2 ->6
# 3        <0> undef s ->4
# 4        <0> padsv[$a:1,2] sRM*/LVINTRO ->5
a221 1
	      errs      => ['Name "main::a" used only once: possible typo at -e line 1.'],
a335 1
	      errs      => ['Name "main::a" used only once: possible typo at -e line 1.'],
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@a28 1
	      strip_open_hints => 1,
d30 1
a30 1
# 1  <;> nextstate(main 45 optree.t:23) v:>,<,%
d34 1
a34 1
# 1  <;> nextstate(main 45 optree.t:23) v:>,<,%
a41 1
	      strip_open_hints => 1,
d43 1
a43 1
# 1  <;> nextstate(main 49 optree.t:52) v:>,<,%
d47 1
a47 1
# 1  <;> nextstate(main 49 optree.t:45) v:>,<,%
a54 1
	      strip_open_hints => 1,
d56 1
a56 1
1  <;> nextstate(main 21 optree.t:47) v:>,<,%
d60 1
a60 1
# 1  <;> nextstate(main 51 optree.t:56) v:>,<,%
a67 1
	      strip_open_hints => 1,
d69 1
a69 1
1  <;> nextstate(main 23 optree.t:57) v:>,<,%,{
d73 1
a73 1
# 1  <;> nextstate(main 53 optree.t:67) v:>,<,%,{
a80 1
	      strip_open_hints => 1,
d84 1
a84 1
# 2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
d89 1
a89 1
# 2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
a95 1
	      strip_open_hints => 1,
d99 1
a99 1
2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
d105 1
a105 1
# 2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
a113 1
	      strip_open_hints => 1,
d117 1
a117 1
2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
d123 1
a123 1
# 2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
a132 1
	      strip_open_hints => 1,
d136 1
a136 1
1        <;> nextstate(main 641 optree_varinit.t:130) v:>,<,% ->2
d143 1
a143 1
# 1        <;> nextstate(main 641 optree_varinit.t:130) v:>,<,% ->2
a152 1
	      strip_open_hints => 1,
d156 1
a156 1
1        <;> nextstate(main 26 optree.t:109) v:>,<,%,{ ->2
d164 1
a164 1
# 1        <;> nextstate(main 446 optree_varinit.t:137) v:>,<,%,{ ->2
a174 1
	      strip_open_hints => 1,
d178 1
a178 1
1        <;> nextstate(main 28 optree.t:122) v:>,<,%,{ ->2
d186 1
a186 1
# 1        <;> nextstate(main 58 optree.t:141) v:>,<,%,{ ->2
a195 1
	      strip_open_hints => 1,
d199 1
a199 1
2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
d206 1
a206 1
# 2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
a215 1
	      strip_open_hints => 1,
d219 1
a219 1
2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
d227 1
a227 1
# 2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
a238 1
	      strip_open_hints => 1,
d242 1
a242 1
2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
d250 1
a250 1
# 2     <;> nextstate(main 1 -e:1) v:>,<,%,{ ->3
a259 1
	      strip_open_hints => 1,
d261 1
a261 1
1  <;> nextstate(main -439 optree.t:105) v:>,<,%
d267 1
a267 1
# 1  <;> nextstate(main 438 optree_varinit.t:247) v:>,<,%
a277 1
	      strip_open_hints => 1,
d279 1
a279 1
1  <;> nextstate(main 31 optree.t:177) v:>,<,%,{
d285 1
a285 1
# 1  <;> nextstate(main 440 optree_varinit.t:262) v:>,<,%,{
a295 1
	      strip_open_hints => 1,
d297 1
a297 1
1  <;> nextstate(main 33 optree.t:190) v:>,<,%,{
d303 1
a303 1
# 1  <;> nextstate(main 63 optree.t:225) v:>,<,%,{
a312 1
	      strip_open_hints => 1,
d315 1
a315 1
2  <;> nextstate(main 1 -e:1) v:>,<,%,{
d322 1
a322 1
# 2  <;> nextstate(main 1 -e:1) v:>,<,%,{
a332 1
	      strip_open_hints => 1,
d335 1
a335 1
2  <;> nextstate(main 1 -e:1) v:>,<,%,{
d342 1
a342 1
# 2  <;> nextstate(main 1 -e:1) v:>,<,%,{
a353 1
	      strip_open_hints => 1,
d356 1
a356 1
2  <;> nextstate(main 1 -e:1) v:>,<,%,{
d363 1
a363 1
# 2  <;> nextstate(main 1 -e:1) v:>,<,%,{
a373 1
	      strip_open_hints => 1,
d376 1
a376 1
# 2  <;> nextstate(main 1 -e:1) v:>,<,%,{
d385 1
a385 1
# 2  <;> nextstate(main 1 -e:1) v:>,<,%,{
@


1.1.1.4
log
@Perl 5.12.2 from CPAN
@
text
@d4 7
a10 1
    unshift @@INC, 't';
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d10 1
a10 4
    if (!$Config::Config{useperlio}) {
        print "1..0 # Skip -- need perlio to walk the optree\n";
        exit 0;
    }
d14 3
a16 1
plan tests	=> 42;
d243 1
a243 1
	      note	=> 'locals are rare, probably not worth doing',
d407 5
@


1.1.1.6
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d393 5
a397 3
# 4  <0> padrange[$a:1,2; $b:1,2] lRM/LVINTRO,2
# 5  <2> aassign[t3] vKS
# 6  <@@> leave[1 ref] vKP/REFC
d402 5
a406 3
# 4  <0> padrange[$a:1,2; $b:1,2] lRM/LVINTRO,2
# 5  <2> aassign[t3] vKS
# 6  <@@> leave[1 ref] vKP/REFC
@


1.1.1.7
log
@Import perl-5.20.1
@
text
@d111 3
a113 3
checkOptree ( name	=> 'local $c',
	      prog	=> 'local $c',
	      errs      => ['Name "main::c" used only once: possible typo at -e line 1.'],
d121 1
a121 1
3        <#> gvsv[*c] s/LVINTRO ->4
d127 1
a127 1
# 3        <$> gvsv(*c) s/LVINTRO ->4
d241 3
a243 3
checkOptree ( name	=> 'local $c=undef',
	      prog	=> 'local $c=undef',
	      errs      => ['Name "main::c" used only once: possible typo at -e line 1.'],
d254 1
a254 1
4           <#> gvsv[*c] s/LVINTRO ->5
d262 1
a262 1
# 4           <$> gvsv(*c) s/LVINTRO ->5
d362 3
a364 3
checkOptree ( name	=> 'local $c=()',
	      prog	=> 'local $c=()',
	      errs      => ['Name "main::c" used only once: possible typo at -e line 1.'],
d372 1
a372 1
4  <#> gvsv[*c] s/LVINTRO
d379 1
a379 1
# 4  <$> gvsv(*c) s/LVINTRO
@


