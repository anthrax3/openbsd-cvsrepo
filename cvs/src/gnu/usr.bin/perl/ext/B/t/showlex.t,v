head	1.2;
access;
symbols
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.8
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.7.0.10
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.4
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.6
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.6.0.8
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.6
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.2
	OPENBSD_5_4_BASE:1.1.1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.1.1.5.0.10
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.8
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.6
	OPENBSD_5_0:1.1.1.5.0.4
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.2
	OPENBSD_4_9_BASE:1.1.1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.1.1.4.0.18
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.14
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.16
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.12
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.6
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.4
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.2
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.2.0.2
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.11;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.14.53;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.53;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.08.09.17.45.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.47.54;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.09.24.14.48.52;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.08.44;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	1.1.1.8;
commitid	B31cAbBIXiCqnL97;

1.1.1.8
date	2017.08.14.13.46.10;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    unshift @@INC, 't';
    require Config;
    if (($Config::Config{'extensions'} !~ /\bB\b/) ){
        print "1..0 # Skip -- Perl configured without B module\n";
        exit 0;
    }
    require 'test.pl';
}

$| = 1;
use warnings;
use strict;
use Config;
use B::Showlex ();

plan tests => 15;

my $verbose = @@ARGV; # set if ANY ARGS

my $a;
my $Is_VMS = $^O eq 'VMS';

my $path = join " ", map { qq["-I$_"] } @@INC;
$path = '"-I../lib" "-Iperl_root:[lib]"' if $Is_VMS;   # gets too long otherwise
my $is_thread = $Config{use5005threads} && $Config{use5005threads} eq 'define';

if ($is_thread) {
    ok "# use5005threads: test skipped\n";
} else {
    $a = `$^X $path "-MO=Showlex" -e "my \@@one" 2>&1`;
    like ($a, qr/undef.*: \([^)]*\) \@@one.*Nullsv.*AV/s,
	  "canonical usage works");
}

# v1.01 tests

my ($na,$nb,$nc);	# holds regex-strs
my ($out, $newlex);	# output, option-flag

sub padrep {
    my ($varname,$newlex) = @@_;
    return ($newlex)
	? '\(0x[0-9a-fA-F]+\) "\\'.$varname.'" = '
	: "\\\(0x[0-9a-fA-F]+\\\) \\$varname\n";
}

for $newlex ('', '-newlex') {

    $out = runperl ( switches => ["-MO=Showlex,$newlex"],
		     prog => 'my ($a,$b)', stderr => 1 );
    $na = padrep('$a',$newlex);
    $nb = padrep('$b',$newlex);
    like ($out, qr/1: $na/ms, 'found $a in "my ($a,$b)"');
    like ($out, qr/2: $nb/ms, 'found $b in "my ($a,$b)"');

    print $out if $verbose;

SKIP: {
    skip "no perlio in this build", 5
    unless $Config::Config{useperlio};

    our $buf = 'arb startval';
    my $ak = B::Showlex::walk_output (\$buf);

    my $walker = B::Showlex::compile( $newlex, sub{my($foo,$bar)} );
    $walker->();
    $na = padrep('$foo',$newlex);
    $nb = padrep('$bar',$newlex);
    like ($buf, qr/1: $na/ms, 'found $foo in "sub { my ($foo,$bar) }"');
    like ($buf, qr/2: $nb/ms, 'found $bar in "sub { my ($foo,$bar) }"');

    print $buf if $verbose;

    $ak = B::Showlex::walk_output (\$buf);

    my $src = 'sub { my ($scalar,@@arr,%hash) }';
    my $sub = eval $src;
    $walker = B::Showlex::compile($sub);
    $walker->();
    $na = padrep('$scalar',$newlex);
    $nb = padrep('@@arr',$newlex);
    $nc = padrep('%hash',$newlex);
    like ($buf, qr/1: $na/ms, 'found $scalar in "'. $src .'"');
    like ($buf, qr/2: $nb/ms, 'found @@arr    in "'. $src .'"');
    like ($buf, qr/3: $nc/ms, 'found %hash   in "'. $src .'"');

    print $buf if $verbose;

    # fibonacci function under test
    my $asub = sub {
	my ($self,%props)=@@_;
	my $total;
	{ # inner block vars
	    my (@@fib)=(1,2);
	    for (my $i=2; $i<10; $i++) {
		$fib[$i] = $fib[$i-2] + $fib[$i-1];
	    }
	    for my $i(0..10) {
		$total += $i;
	    }
	}
    };
    $walker = B::Showlex::compile($asub, $newlex, -nosp);
    $walker->();
    print $buf if $verbose;

    $walker = B::Concise::compile($asub, '-exec');
    $walker->();

}
}
@


1.1
log
@Initial revision
@
text
@d4 5
a8 5
    chdir 't' if -d 't';
    if ($^O eq 'MacOS') {
	@@INC = qw(: ::lib ::macos:lib);
    } else {
	@@INC = '../lib';
d10 1
d13 1
a13 1
$|  = 1;
d17 1
d19 1
a19 1
print "1..1\n";
d21 1
a21 3
my $test = 1;

sub ok { print "ok $test\n"; $test++ }
a24 1
my $Is_MacOS = $^O eq 'MacOS';
a27 1
my $redir = $Is_MacOS ? "" : "2>&1";
d31 1
a31 1
    print "# use5005threads: test $test skipped\n";
d33 81
a113 2
    $a = `$^X $path "-MO=Showlex" -e "my \@@one" $redir`;
    print "# [$a]\nnot " unless $a =~ /sv_undef.*PVNV.*\@@one.*sv_undef.*AV/s;
a114 1
ok;
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@Import of stock perl 5.8.5
@
text
@a9 5
    require Config;
    if (($Config::Config{'extensions'} !~ /\bB\b/) ){
        print "1..0 # Skip -- Perl configured without B module\n";
        exit 0;
    }
@


1.1.1.3
log
@perl 5.8.6 from CPAN
@
text
@a14 1
    require './test.pl';
d17 1
a17 1
$| = 1;
a20 1
use B::Showlex ();
d22 1
a22 1
plan tests => 15;
d24 3
a26 1
my $verbose = @@ARGV; # set if ANY ARGS
d38 1
a38 1
    ok "# use5005threads: test skipped\n";
d41 1
a41 80
    like ($a, qr/sv_undef.*PVNV.*\@@one.*sv_undef.*AV/s,
	  "canonical usage works");
}

# v1.01 tests

my ($na,$nb,$nc);	# holds regex-strs
my ($out, $newlex);	# output, option-flag

sub padrep {
    my ($varname,$newlex) = @@_;
    return ($newlex)
	? 'PVNV \(0x[0-9a-fA-F]+\) "\\'.$varname.'" = '
	: "PVNV \\\(0x[0-9a-fA-F]+\\\) \\$varname\n";
}

for $newlex ('', '-newlex') {

    $out = runperl ( switches => ["-MO=Showlex,$newlex"],
		     prog => 'my ($a,$b)', stderr => 1 );
    $na = padrep('$a',$newlex);
    $nb = padrep('$b',$newlex);
    like ($out, qr/1: $na/ms, 'found $a in "my ($a,$b)"');
    like ($out, qr/2: $nb/ms, 'found $b in "my ($a,$b)"');

    print $out if $verbose;

SKIP: {
    skip "no perlio in this build", 5
    unless $Config::Config{useperlio};

    our $buf = 'arb startval';
    my $ak = B::Showlex::walk_output (\$buf);

    my $walker = B::Showlex::compile( $newlex, sub{my($foo,$bar)} );
    $walker->();
    $na = padrep('$foo',$newlex);
    $nb = padrep('$bar',$newlex);
    like ($buf, qr/1: $na/ms, 'found $foo in "sub { my ($foo,$bar) }"');
    like ($buf, qr/2: $nb/ms, 'found $bar in "sub { my ($foo,$bar) }"');

    print $buf if $verbose;

    $ak = B::Showlex::walk_output (\$buf);

    my $src = 'sub { my ($scalar,@@arr,%hash) }';
    my $sub = eval $src;
    $walker = B::Showlex::compile($sub);
    $walker->();
    $na = padrep('$scalar',$newlex);
    $nb = padrep('@@arr',$newlex);
    $nc = padrep('%hash',$newlex);
    like ($buf, qr/1: $na/ms, 'found $scalar in "'. $src .'"');
    like ($buf, qr/2: $nb/ms, 'found @@arr    in "'. $src .'"');
    like ($buf, qr/3: $nc/ms, 'found %hash   in "'. $src .'"');

    print $buf if $verbose;

    # fibonacci function under test
    my $asub = sub {
	my ($self,%props)=@@_;
	my $total;
	{ # inner block vars
	    my (@@fib)=(1,2);
	    for (my $i=2; $i<10; $i++) {
		$fib[$i] = $fib[$i-2] + $fib[$i-1];
	    }
	    for my $i(0..10) {
		$total += $i;
	    }
	}
    };
    $walker = B::Showlex::compile($asub, $newlex, -nosp);
    $walker->();
    print $buf if $verbose;

    $walker = B::Concise::compile($asub, '-exec');
    $walker->();

}
d43 1
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@d4 3
a6 8
    if ($ENV{PERL_CORE}){
	chdir('t') if -d 't';
	if ($^O eq 'MacOS') {
	    @@INC = qw(: ::lib ::macos:lib);
	} else {
	    @@INC = '.';
	    push @@INC, '../lib';
	}
d8 1
a8 2
	unshift @@INC, 't';
	push @@INC, "../../t";
d15 1
a15 1
    require 'test.pl';
@


1.1.1.5
log
@Perl 5.12.2 from CPAN
@
text
@d4 12
a15 1
    unshift @@INC, 't';
@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d25 1
d29 1
d35 1
a35 1
    $a = `$^X $path "-MO=Showlex" -e "my \@@one" 2>&1`;
@


1.1.1.7
log
@Import perl-5.20.1
@
text
@d34 1
a34 1
    like ($a, qr/sv_undef.*PVNV.*\@@one.*Nullsv.*AV/s,
@


1.1.1.8
log
@Import perl-5.24.2
@
text
@d34 1
a34 1
    like ($a, qr/undef.*: \([^)]*\) \@@one.*Nullsv.*AV/s,
d46 2
a47 2
	? '\(0x[0-9a-fA-F]+\) "\\'.$varname.'" = '
	: "\\\(0x[0-9a-fA-F]+\\\) \\$varname\n";
@


