head	1.2;
access;
symbols
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.8
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.7.0.10
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.4
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.6
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.6.0.4
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.6
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.2
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.4.0.10
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.8
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.6
	OPENBSD_5_0:1.1.1.4.0.4
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.2
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.3.0.8
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.4
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.10
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.8
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.6
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.4
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.2
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.1.0.6
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.4
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.2
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.11;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.03.28.18.47.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.13;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.09.24.14.48.53;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.08.44;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	1.1.1.8;
commitid	B31cAbBIXiCqnL97;

1.1.1.8
date	2017.08.14.13.46.10;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package OptreeCheck;
use parent 'Exporter';
use strict;
use warnings;
use vars qw($TODO $Level $using_open);
require "test.pl";

our $VERSION = '0.13';

# now export checkOptree, and those test.pl functions used by tests
our @@EXPORT = qw( checkOptree plan skip skip_all pass is like unlike
		  require_ok runperl tempfile);


# The hints flags will differ if ${^OPEN} is set.
# The approach taken is to put the hints-with-open in the golden results, and
# flag that they need to be taken out if ${^OPEN} is set.

if (((caller 0)[10]||{})->{'open<'}) {
    $using_open = 1;
}

=head1 NAME

OptreeCheck - check optrees as rendered by B::Concise

=head1 SYNOPSIS

OptreeCheck supports 'golden-sample' regression testing of perl's
parser, optimizer, bytecode generator, via a single function:
checkOptree(%in).

It invokes B::Concise upon the sample code, checks that the rendering
'agrees' with the golden sample, and reports mismatches.

Additionally, the module processes @@ARGV (which is typically unused in
the Core test harness), and thus provides a means to run the tests in
various modes.

=head1 EXAMPLE

  # your test file
  use OptreeCheck;
  plan tests => 1;

  checkOptree (
    name   => "test-name',	# optional, made from others if not given

    # code-under-test: must provide 1 of them
    code   => sub {my $a},	# coderef, or source (wrapped and evald)
    prog   => 'sort @@a',	# run in subprocess, aka -MO=Concise
    bcopts => '-exec',		# $opt or \@@opts, passed to BC::compile

    errs   => 'Name "main::a" used only once: possible typo at -e line 1.',
				# str, regex, [str+] [regex+],

    # various test options
    # errs   => '.*',		# match against any emitted errs, -w warnings
    # skip => 1,		# skips test
    # todo => 'excuse',		# anticipated failures
    # fail => 1			# force fail (by redirecting result)

    # the 'golden-sample's, (must provide both)

    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT' );  # start HERE-DOCS
 # 1  <;> nextstate(main 45 optree.t:23) v
 # 2  <0> padsv[$a:45,46] M/LVINTRO
 # 3  <1> leavesub[1 ref] K/REFC,1
 EOT_EOT
 # 1  <;> nextstate(main 45 optree.t:23) v
 # 2  <0> padsv[$a:45,46] M/LVINTRO
 # 3  <1> leavesub[1 ref] K/REFC,1
 EONT_EONT

 __END__

=head2 Failure Reports

 Heres a sample failure, as induced by the following command.
 Note the argument; option=value, after the test-file, more on that later

 $> PERL_CORE=1 ./perl ext/B/t/optree_check.t  testmode=cross
 ...
 ok 19 - canonical example w -basic
 not ok 20 - -exec code: $a=$b+42
 # Failed at test.pl line 249
 #      got '1  <;> nextstate(main 600 optree_check.t:208) v
 # 2  <#> gvsv[*b] s
 # 3  <$> const[IV 42] s
 # 4  <2> add[t3] sK/2
 # 5  <#> gvsv[*a] s
 # 6  <2> sassign sKS/2
 # 7  <1> leavesub[1 ref] K/REFC,1
 # '
 # expected /(?ms-xi:^1  <;> (?:next|db)state(.*?) v
 # 2  <\$> gvsv\(\*b\) s
 # 3  <\$> const\(IV 42\) s
 # 4  <2> add\[t\d+\] sK/2
 # 5  <\$> gvsv\(\*a\) s
 # 6  <2> sassign sKS/2
 # 7  <1> leavesub\[\d+ refs?\] K/REFC,1
 # $)/
 # got:          '2  <#> gvsv[*b] s'
 # want:  (?^:2  <\$> gvsv\(\*b\) s)
 # got:          '3  <$> const[IV 42] s'
 # want:  (?^:3  <\$> const\(IV 42\) s)
 # got:          '5  <#> gvsv[*a] s'
 # want:  (?^:5  <\$> gvsv\(\*a\) s)
 # remainder:
 # 2  <#> gvsv[*b] s
 # 3  <$> const[IV 42] s
 # 5  <#> gvsv[*a] s
 # these lines not matched:
 # 2  <#> gvsv[*b] s
 # 3  <$> const[IV 42] s
 # 5  <#> gvsv[*a] s

Errors are reported 3 different ways;

The 1st form is directly from test.pl's like() and unlike().  Note
that this form is used as input, so you can easily cut-paste results
into test-files you are developing.  Just make sure you recognize
insane results, to avoid canonizing them as golden samples.

The 2nd and 3rd forms show only the unexpected results and opcodes.
This is done because it's blindingly tedious to find a single opcode
causing the failure.  2 different ways are done in case one is
unhelpful.

=head1 TestCase Overview

checkOptree(%tc) constructs a testcase object from %tc, and then calls
methods which eventually call test.pl's like() to produce test
results.

=head2 getRendering

getRendering() runs code or prog or progfile through B::Concise, and
captures its rendering.  Errors emitted during rendering are checked
against expected errors, and are reported as diagnostics by default,
or as failures if 'report=fail' cmdline-option is given.

prog is run in a sub-shell, with $bcopts passed through. This is the way
to run code intended for main.  The code arg in contrast, is always a
CODEREF, either because it starts that way as an arg, or because it's
wrapped and eval'd as $sub = sub {$code};

=head2 mkCheckRex

mkCheckRex() selects the golden-sample for the threaded-ness of the
platform, and produces a regex which matches the expected rendering,
and fails when it doesn't match.

The regex includes 'workarounds' which accommodate expected rendering
variations. These include:

  string constants		# avoid injection
  line numbers, etc		# args of nexstate()
  hexadecimal-numbers

  pad-slot-assignments		# for 5.8 compat, and testmode=cross
  (map|grep)(start|while)	# for 5.8 compat

=head2 mylike

mylike() calls either unlike() or like(), depending on
expectations.  Mismatch reports are massaged, because the actual
difference can easily be lost in the forest of opcodes.

=head1 checkOptree API and Operation

Since the arg is a hash, the api is wide-open, and this really is
about what elements must be or are in the hash, and what they do.  %tc
is passed to newTestCase(), the ctor, which adds in %proto, a global
prototype object.

=head2 name => STRING

If name property is not provided, it is synthesized from these params:
bcopts, note, prog, code.  This is more convenient than trying to do
it manually.

=head2 code or prog or progfile

Either code or prog or progfile must be present.

=head2 prog => $perl_source_string

prog => $src provides a snippet of code, which is run in a sub-process,
via test.pl:runperl, and through B::Concise like so:

    './perl -w -MO=Concise,$bcopts_massaged -e $src'

=head2 progfile => $perl_script

progfile => $file provides a file containing a snippet of code which is
run as per the prog => $src example above.

=head2 code => $perl_source_string || CODEREF

The $code arg is passed to B::Concise::compile(), and run in-process.
If $code is a string, it's first wrapped and eval'd into a $coderef.
In either case, $coderef is then passed to B::Concise::compile():

    $subref = eval "sub{$code}";
    $render = B::Concise::compile($subref)->();

=head2 expect and expect_nt

expect and expect_nt args are the B<golden-sample> renderings, and are
sampled from known-ok threaded and un-threaded bleadperl (5.9.1) builds.
They're both required, and the correct one is selected for the platform
being tested, and saved into the synthesized property B<wanted>.

Individual sample lines may be suffixed with whitespace followed
by (<|<=|==|>=|>)5.nnnn (up to two times) to
select that line only for the listed perl
version; the whitespace and conditional are stripped.

=head2 bcopts => $bcopts || [ @@bcopts ]

When getRendering() runs, it passes bcopts into B::Concise::compile().
The bcopts arg can be a single string, or an array of strings.

=head2 errs => $err_str_regex || [ @@err_str_regexs ] 

getRendering() processes the code or prog or progfile arg under warnings,
and both parsing and optree-traversal errors are collected.  These are
validated against the one or more errors you specify.

=head1 testcase modifier properties

These properties are set as %tc parameters to change test behavior.

=head2 skip => 'reason'

invokes skip('reason'), causing test to skip.

=head2 todo => 'reason'

invokes todo('reason')

=head2 fail => 1

For code arguments, this option causes getRendering to redirect the
rendering operation to STDERR, which causes the regex match to fail.

=head2 noanchors => 1

If set, this relaxes the regex check, which is normally pretty strict.
It's used primarily to validate checkOptree via tests in optree_check.


=head1 Synthesized object properties

These properties are added into the test object during execution.

=head2 wanted

This stores the chosen expect expect_nt string.  The OptreeCheck
object may in the future delete the raw strings once wanted is set,
thus saving space.

=head2 cross => 1

This tag is added if testmode=cross is passed in as argument.
It causes test-harness to purposely use the wrong string.


=head2 checkErrs

checkErrs() is a getRendering helper that verifies that expected errs
against those found when rendering the code on the platform.  It is
run after rendering, and before mkCheckRex.

=cut

use Config;
use Carp;
use B::Concise qw(walk_output);

BEGIN {
    $SIG{__WARN__} = sub {
	my $err = shift;
	$err =~ m/Subroutine re::(un)?install redefined/ and return;
    };
}

sub import {
    my $pkg = shift;
    $pkg->export_to_level(1,'checkOptree', @@EXPORT);
    getCmdLine();	# process @@ARGV
}


# %gOpts params comprise a global test-state.  Initial values here are
# HELP strings, they MUST BE REPLACED by runtime values before use, as
# is done by getCmdLine(), via import

our %gOpts = 	# values are replaced at runtime !!
    (
     # scalar values are help string
     selftest	=> 'self-tests mkCheckRex vs the reference rendering',

     fail	=> 'force all test to fail, print to stdout',
     dump	=> 'dump cmdline arg processing',
     noanchors	=> 'dont anchor match rex',

     # array values are one-of selections, with 1st value as default
     #  array: 2nd value is used as help-str, 1st val (still) default
     help	=> [0, 'provides help and exits', 0],
     testmode	=> [qw/ native cross both /],

     # fixup for VMS, cygwin, which don't have stderr b4 stdout
     rxnoorder	=> [1, 'if 1, dont req match on -e lines, and -banner',0],
     strip	=> [1, 'if 1, catch errs and remove from renderings',0],
     stripv	=> 'if strip&&1, be verbose about it',
     errs	=> 'expected compile errs, array if several',
    );


# Not sure if this is too much cheating. Officially we say that
# $Config::Config{usethreads} is true if some sort of threading is in
# use, in which case we ought to be able to use it in place of the ||
# below.  However, it is now possible to Configure perl with "threads"
# but neither ithreads or 5005threads, which forces the re-entrant
# APIs, but no perl user visible threading.

# This seems to have the side effect that most of perl doesn't think
# that it's threaded, hence the ops aren't threaded either.  Not sure
# if this is actually a "supported" configuration, but given that
# ponie uses it, it's going to be used by something official at least
# in the interim. So it's nice for tests to all pass.

our $threaded = 1
  if $Config::Config{useithreads} || $Config::Config{use5005threads};
our $platform = ($threaded) ? "threaded" : "plain";
our $thrstat = ($threaded)  ? "threaded" : "nonthreaded";

our %modes = (
	      both	=> [ 'expect', 'expect_nt'],
	      native	=> [ ($threaded) ? 'expect' : 'expect_nt'],
	      cross	=> [ !($threaded) ? 'expect' : 'expect_nt'],
	      expect	=> [ 'expect' ],
	      expect_nt	=> [ 'expect_nt' ],
	      );

our %msgs # announce cross-testing.
    = (
       # cross-platform
       'expect_nt-threaded' => " (nT on T) ",
       'expect-nonthreaded' => " (T on nT) ",
       # native - nothing to say (must stay empty - used for $crosstesting)
       'expect_nt-nonthreaded'	=> '',
       'expect-threaded'	=> '',
       );

#######
sub getCmdLine {	# import assistant
    # offer help
    print(qq{\n$0 accepts args to update these state-vars:
	     turn on a flag by typing its name,
	     select a value from list by typing name=val.\n    },
	  mydumper(\%gOpts))
	if grep /help/, @@ARGV;

    # replace values for each key !! MUST MARK UP %gOpts
    foreach my $opt (keys %gOpts) {

	# scan ARGV for known params
	if (ref $gOpts{$opt} eq 'ARRAY') {

	    # $opt is a One-Of construct
	    # replace with valid selection from the list

	    # uhh this WORKS. but it's inscrutable
	    # grep s/$opt=(\w+)/grep {$_ eq $1} @@ARGV and $gOpts{$opt}=$1/e, @@ARGV;
	    my $tval;  # temp
	    if (grep s/$opt=(\w+)/$tval=$1/e, @@ARGV) {
		# check val before accepting
		my @@allowed = @@{$gOpts{$opt}};
		if (grep { $_ eq $tval } @@allowed) {
		    $gOpts{$opt} = $tval;
		}
		else {die "invalid value: '$tval' for $opt\n"}
	    }

	    # take 1st val as default
	    $gOpts{$opt} = ${$gOpts{$opt}}[0]
		if ref $gOpts{$opt} eq 'ARRAY';
        }
        else { # handle scalars

	    # if 'opt' is present, true
	    $gOpts{$opt} = (grep /^$opt/, @@ARGV) ? 1 : 0;

	    # override with 'foo' if 'opt=foo' appears
	    grep s/$opt=(.*)/$gOpts{$opt}=$1/e, @@ARGV;
	}
     }
    print("$0 heres current state:\n", mydumper(\%gOpts))
	if $gOpts{help} or $gOpts{dump};

    exit if $gOpts{help};
}
# the above arg-handling cruft should be replaced by a Getopt call

##############################
# the API (1 function)

sub checkOptree {
    my $tc = newTestCases(@@_);	# ctor
    my ($rendering);

    print "checkOptree args: ",mydumper($tc) if $tc->{dump};
    SKIP: {
	if ($tc->{skip}) {
	    skip("$tc->{skip} $tc->{name}",
		    ($gOpts{selftest}
			? 1
			: 1 + @@{$modes{$gOpts{testmode}}}
			)
	    );
	}

	return runSelftest($tc) if $gOpts{selftest};

	$tc->getRendering();	# get the actual output
	$tc->checkErrs();

	local $Level = $Level + 2;
      TODO:
	foreach my $want (@@{$modes{$gOpts{testmode}}}) {
	    local $TODO = $tc->{todo} if $tc->{todo};

	    $tc->{cross} = $msgs{"$want-$thrstat"};

	    $tc->mkCheckRex($want);
	    $tc->mylike();
	}
    }
    return;
}

sub newTestCases {
    # make test objects (currently 1) from args (passed to checkOptree)
    my $tc = bless { @@_ }, __PACKAGE__
	or die "test cases are hashes";

    $tc->label();

    # cpy globals into each test
    foreach my $k (keys %gOpts) {
	if ($gOpts{$k}) {
	    $tc->{$k} = $gOpts{$k} unless defined $tc->{$k};
	}
    }
    if ($tc->{errs}) {
	$tc->{errs} = [$tc->{errs}] unless ref $tc->{errs} eq 'ARRAY';
    }
    return $tc;
}

sub label {
    # may help get/keep test output consistent
    my ($tc) = @@_;
    return $tc->{name} if $tc->{name};

    my $buf = (ref $tc->{bcopts}) 
	? join(',', @@{$tc->{bcopts}}) : $tc->{bcopts};

    foreach (qw( note prog code )) {
	$buf .= " $_: $tc->{$_}" if $tc->{$_} and not ref $tc->{$_};
    }
    return $tc->{name} = $buf;
}

#################
# render and its helpers

sub getRendering {
    my $tc = shift;
    fail("getRendering: code or prog or progfile is required")
	unless $tc->{code} or $tc->{prog} or $tc->{progfile};

    my @@opts = get_bcopts($tc);
    my $rendering = ''; # suppress "Use of uninitialized value in open"
    my @@errs;		# collect errs via 


    if ($tc->{prog}) {
	$rendering = runperl( switches => ['-w',join(',',"-MO=Concise",@@opts)],
			      prog => $tc->{prog}, stderr => 1,
			      ); # verbose => 1);
    } elsif ($tc->{progfile}) {
	$rendering = runperl( switches => ['-w',join(',',"-MO=Concise",@@opts)],
			      progfile => $tc->{progfile}, stderr => 1,
			      ); # verbose => 1);
    } else {
	my $code = $tc->{code};
	unless (ref $code eq 'CODE') {
	    # treat as source, and wrap into subref 
	    #  in caller's package ( to test arg-fixup, comment next line)
	    my $pkg = '{ package '.caller(1) .';';
	    {
		BEGIN { $^H = 0 }
		no warnings;
		$code = eval "$pkg sub { $code } }";
	    }
	    # return errors
	    if ($@@) { chomp $@@; push @@errs, $@@ }
	}
	# set walk-output b4 compiling, which writes 'announce' line
	walk_output(\$rendering);

	my $opwalker = B::Concise::compile(@@opts, $code);
	die "bad BC::compile retval" unless ref $opwalker eq 'CODE';

      B::Concise::reset_sequence();
	$opwalker->();

	# kludge error into rendering if its empty.
	$rendering = $@@ if $@@ and ! $rendering;
    }
    # separate banner, other stuff whose printing order isnt guaranteed
    if ($tc->{strip}) {
	$rendering =~ s/(B::Concise::compile.*?\n)//;
	print "stripped from rendering <$1>\n" if $1 and $tc->{stripv};

	#while ($rendering =~ s/^(.*?(-e) line \d+\.)\n//g) {
	while ($rendering =~ s/^(.*?(-e|\(eval \d+\).*?) line \d+\.)\n//g) {
	    print "stripped <$1> $2\n" if $tc->{stripv};
	    push @@errs, $1;
	}
	$rendering =~ s/-e syntax OK\n//;
	$rendering =~ s/-e had compilation errors\.\n//;
    }
    $tc->{got}	   = $rendering;
    $tc->{goterrs} = \@@errs if @@errs;
    return $rendering, @@errs;
}

sub get_bcopts {
    # collect concise passthru-options if any
    my ($tc) = shift;
    my @@opts = ();
    if ($tc->{bcopts}) {
	@@opts = (ref $tc->{bcopts} eq 'ARRAY')
	    ? @@{$tc->{bcopts}} : ($tc->{bcopts});
    }
    return @@opts;
}

sub checkErrs {
    # check rendering errs against expected errors, reduce and report
    my $tc = shift;

    # check for agreement (order not important)
    my (%goterrs, @@missed);
    @@goterrs{@@{$tc->{goterrs}}} = (1) x scalar @@{$tc->{goterrs}}
	if $tc->{goterrs};

    foreach my $want (@@{$tc->{errs}}) {
	if (ref $want) {
	    my $seen;
	    foreach my $k (keys %goterrs) {
		next unless $k =~ $want;
		delete $goterrs{$k};
		++$seen;
	    }
	    push @@missed, $want unless $seen;
	} else {
	    push @@missed, $want unless defined delete $goterrs{$want};
	}
    }

    @@missed = sort @@missed;
    my @@got = sort keys %goterrs;

    if (@@{$tc->{errs}}) {
	is(@@missed + @@got, 0, "Only got expected errors for $tc->{name}")
    } else {
	# @@missed must be 0 here.
	is(scalar @@got, 0, "Got no errors for $tc->{name}")
    }
    _diag(join "\n", "got unexpected:", @@got) if @@got;
    _diag(join "\n", "missed expected:", @@missed) if @@missed;
}

=head1 mkCheckRex ($tc)

It selects the correct golden-sample from the test-case object, and
converts it into a Regexp which should match against the original
golden-sample (used in selftest, see below), and on the renderings
obtained by applying the code on the perl being tested.

The selection is driven by platform mostly, but also by test-mode,
which rather complicates the code.  This is worsened by the potential
need to make platform specific conversions on the reftext.

but is otherwise as strict as possible.  For example, it should *not*
match when opcode flags change, or when optimizations convert an op to
an ex-op.


=head2 match criteria

The selected golden-sample is massaged to eliminate various match
irrelevancies.  This is done so that the tests don't fail just because
you added a line to the top of the test file.  (Recall that the
renderings contain the program's line numbers).  Similar cleanups are
done on "strings", hex-constants, etc.

The need to massage is reflected in the 2 golden-sample approach of
the test-cases; we want the match to be as rigorous as possible, and
thats easier to achieve when matching against 1 input than 2.

Opcode arguments (text within braces) are disregarded for matching
purposes.  This loses some info in 'add[t5]', but greatly simplifies
matching 'nextstate(main 22 (eval 10):1)'.  Besides, we are testing
for regressions, not for complete accuracy.

The regex is anchored by default, but can be suppressed with
'noanchors', allowing 1-liner tests to succeed if opcode is found.

=cut

# needless complexity due to 'too much info' from B::Concise v.60
my $announce = 'B::Concise::compile\(CODE\(0x[0-9a-f]+\)\)';;

sub mkCheckRex {
    # converts expected text into Regexp which should match against
    # unaltered version.  also adjusts threaded => non-threaded
    my ($tc, $want) = @@_;

    my $str = $tc->{expect} || $tc->{expect_nt};	# standard bias
    $str = $tc->{$want} if $want && $tc->{$want};	# stated pref

    die("no '$want' golden-sample found: $tc->{name}") unless $str;

    $str =~ s/^\# //mg;	# ease cut-paste testcase authoring

    # strip out conditional lines

    $str =~ s{^(.*?)   \s+(<|<=|==|>=|>)\s*(5\.\d+)
		    (?:\s+(<|<=|==|>=|>)\s*(5\.\d+))? \ *\n}
     {
	my ($line, $cmp, $version, $cmp2, $v2) = ($1,$2,$3,$4,$5,$6);
	my $repl = "";
	if (  $cmp eq '<'  ? $] <  $version
	    : $cmp eq '<=' ? $] <= $version
	    : $cmp eq '==' ? $] == $version
	    : $cmp eq '>=' ? $] >= $version
	    : $cmp eq '>'  ? $] >  $version
	    : die("bad comparison '$cmp' in string [$str]\n")
	 and !$cmp2 || (
	      $cmp2 eq '<'  ? $] <  $v2
	    : $cmp2 eq '<=' ? $] <= $v2
	    : $cmp2 eq '==' ? $] == $v2
	    : $cmp2 eq '>=' ? $] >= $v2
	    : $cmp2 eq '>'  ? $] >  $v2
	    : die("bad comparison '$cmp2' in string [$str]\n")
	  )
	) {
	    $repl = "$line\n";
	}
	$repl;
     }gemx;

    $tc->{wantstr} = $str;

    # make UNOP_AUX flag type literal
    $str =~ s/<\+>/<\\+>/;
    # make targ args wild
    $str =~ s/\[t\d+\]/[t\\d+]/msg;

    # escape bracing, etc.. manual \Q (doesn't escape '+')
    $str =~ s/([\[\]()*.\$\@@\#\|{}])/\\$1/msg;
    # $str =~ s/(?<!\\)([\[\]\(\)*.\$\@@\#\|{}])/\\$1/msg;

    # treat dbstate like nextstate (no in-debugger false reports)
    # Note also that there may be 1 level of () nexting, if there's an eval
    # Seems easiest to explicitly match the eval, rather than trying to parse
    # for full balancing and then substitute .*?
    # In which case, we can continue to match for the eval in the rexexp built
    # from the golden result.

    $str =~ s!(?:next|db)state
	      \\\(			# opening literal ( (backslash escaped)
	      [^()]*?			# not ()
	      (\\\(eval\ \d+\\\)	# maybe /eval \d+/ in ()
	       [^()]*?			# which might be followed by something
	      )?
	      \\\)			# closing literal )
	     !'(?:next|db)state\\([^()]*?' .
	      ($1 && '\\(eval \\d+\\)[^()]*')	# Match the eval if present
	      . '\\)'!msgxe;
    # widened for -terse mode
    $str =~ s/(?:next|db)state/(?:next|db)state/msg;
    if (!$using_open && $tc->{strip_open_hints}) {
      $str =~ s[(			# capture
		 \(\?:next\|db\)state	# the regexp matching next/db state
		 .*			# all sorts of things follow it
		 v			# The opening v
		)
		(?:(:>,<,%,\\{)		# hints when open.pm is in force
		   |(:>,<,%))		# (two variations)
		(\ ->(?:-|[0-9a-z]+))?
		$
	       ]
	[$1 . ($2 && ':{') . $4]xegm;	# change to the hints without open.pm
    }


    # don't care about:
    $str =~ s/:-?\d+,-?\d+/:-?\\d+,-?\\d+/msg;		# FAKE line numbers
    $str =~ s/match\\\(.*?\\\)/match\(.*?\)/msg;	# match args
    $str =~ s/(0x[0-9A-Fa-f]+)/0x[0-9A-Fa-f]+/msg;	# hexnum values
    $str =~ s/".*?"/".*?"/msg;				# quoted strings
    $str =~ s/FAKE:(\w):\d+/FAKE:$1:\\d+/msg;		# parent pad index

    $str =~ s/(\d refs?)/\\d+ refs?/msg;		# 1 ref, 2+ refs (plural)
    $str =~ s/leavesub \[\d\]/leavesub [\\d]/msg;	# for -terse
    #$str =~ s/(\s*)\n/\n/msg;				# trailing spaces
    
    croak "whitespace only reftext found for '$want': $tc->{name}"
	unless $str =~ /\w+/; # fail unless a real test
    
    # $str = '.*'	if 1;	# sanity test
    # $str .= 'FAIL'	if 1;	# sanity test

    # allow -eval, banner at beginning of anchored matches
    $str = "(-e .*?)?(B::Concise::compile.*?)?\n" . $str
	unless $tc->{noanchors} or $tc->{rxnoorder};
    
    my $qr = ($tc->{noanchors})	? qr/$str/ms : qr/^$str$/ms ;

    $tc->{rex}		= $qr;
    $tc->{rexstr}	= $str;
    $tc;
}

##############
# compare and report

sub mylike {
    # reworked mylike to use hash-obj
    my $tc	= shift;
    my $got	= $tc->{got};
    my $want	= $tc->{rex};
    my $cmnt	= $tc->{name};
    my $cross	= $tc->{cross};

    # bad is anticipated failure
    my $bad = ($cross && $tc->{crossfail}) || (!$cross && $tc->{fail});

    my $ok = $bad ? unlike ($got, $want, $cmnt) : like ($got, $want, $cmnt);

    reduceDiffs ($tc) if not $ok;

    return $ok;
}

sub reduceDiffs {
    # isolate the real diffs and report them.
    # i.e. these kinds of errs:
    # 1. missing or extra ops.  this skews all following op-sequences
    # 2. single op diff, the rest of the chain is unaltered
    # in either case, std err report is inadequate;

    my $tc	= shift;
    my $got	= $tc->{got};
    my @@got	= split(/\n/, $got);
    my $want	= $tc->{wantstr};
    my @@want	= split(/\n/, $want);

    # split rexstr into units that should eat leading lines.
    my @@rexs = map qr/$_/, split (/\n/, $tc->{rexstr});

    foreach my $rex (@@rexs) {
        my $exp = shift @@want;
        my $line = shift @@got;
        # remove matches, and report
        unless ($got =~ s/($rex\n)//msg) {
            _diag("got:\t\t'$line'\nwant:\t $rex\n");
        }
    }
    _diag("remainder:\n$got");
    _diag("these lines not matched:\n$got\n");
}

=head1 Global modes

Unusually, this module also processes @@ARGV for command-line arguments
which set global modes.  These 'options' change the way the tests run,
essentially reusing the tests for different purposes.



Additionally, there's an experimental control-arg interface (i.e.
subject to change) which allows the user to set global modes.


=head1 Testing Method

At 1st, optreeCheck used one reference-text, but the differences
between Threaded and Non-threaded renderings meant that a single
reference (sampled from say, threaded) would be tricky and iterative
to convert for testing on a non-threaded build.  Worse, this conflicts
with making tests both strict and precise.

We now use 2 reference texts, the right one is used based upon the
build's threaded-ness.  This has several benefits:

 1. native reference data allows closer/easier matching by regex.
 2. samples can be eyeballed to grok T-nT differences.
 3. data can help to validate mkCheckRex() operation.
 4. can develop regexes which accommodate T-nT differences.
 5. can test with both native and cross-converted regexes.

Cross-testing (expect_nt on threaded, expect on non-threaded) exposes
differences in B::Concise output, so mkCheckRex has code to do some
cross-test manipulations.  This area needs more work.

=head1 Test Modes

One consequence of a single-function API is difficulty controlling
test-mode.  I've chosen for now to use a package hash, %gOpts, to store
test-state.  These properties alter checkOptree() function, either
short-circuiting to selftest, or running a loop that runs the testcase
2^N times, varying conditions each time.  (current N is 2 only).

So Test-mode is controlled with cmdline args, also called options below.
Run with 'help' to see the test-state, and how to change it.

=head2  selftest

This argument invokes runSelftest(), which tests a regex against the
reference renderings that they're made from.  Failure of a regex match
its 'mold' is a strong indicator that mkCheckRex is buggy.

That said, selftest mode currently runs a cross-test too, they're not
completely orthogonal yet.  See below.

=head2 testmode=cross

Cross-testing is purposely creating a T-NT mismatch, looking at the
fallout, which helps to understand the T-NT differences.

The tweaking appears contrary to the 2-refs philosophy, but the tweaks
will be made in conversion-specific code, which (will) handles T->NT
and NT->T separately.  The tweaking is incomplete.

A reasonable 1st step is to add tags to indicate when TonNT or NTonT
is known to fail.  This needs an option to force failure, so the
test.pl reporting mechanics show results to aid the user.

=head2 testmode=native

This is normal mode.  Other valid values are: native, cross, both.

=head2 checkOptree Notes

Accepts test code, renders its optree using B::Concise, and matches
that rendering against a regex built from one of 2 reference
renderings %tc data.

The regex is built by mkCheckRex(\%tc), which scrubs %tc data to
remove match-irrelevancies, such as (args) and [args].  For example,
it strips leading '# ', making it easy to cut-paste new tests into
your test-file, run it, and cut-paste actual results into place.  You
then retest and reedit until all 'errors' are gone.  (now make sure you
haven't 'enshrined' a bug).

name: The test name.  May be augmented by a label, which is built from
important params, and which helps keep names in sync with whats being
tested.

=cut

sub runSelftest {
    # tests the regex produced by mkCheckRex()
    # by using on the expect* text it was created with
    # failures indicate a code bug, 
    # OR regexs plugged into the expect* text (which defeat conversions)
    my $tc = shift;

    for my $provenance (qw/ expect expect_nt /) {
	#next unless $tc->{$provenance};

	$tc->mkCheckRex($provenance);
	$tc->{got} = $tc->{wantstr};	# fake the rendering
	$tc->mylike();
    }
}

my $dumploaded = 0;

sub mydumper {

    do { Dumper(@@_); return } if $dumploaded;

    eval "require Data::Dumper"
	or do{
	    print "Sorry, Data::Dumper is not available\n";
	    print "half hearted attempt:\n";
	    foreach my $it (@@_) {
		if (ref $it eq 'HASH') {
		    print " $_ => $it->{$_}\n" foreach sort keys %$it;
		}
	    }
	    return;
	};

    Data::Dumper->import;
    $Data::Dumper::Sortkeys = 1;
    $dumploaded++;
    Dumper(@@_);
}

############################
# support for test writing

sub preamble {
    my $testct = shift || 1;
    return <<EO_HEADER;
#!perl

BEGIN {
    chdir q(t);
    \@@INC = qw(../lib ../ext/B/t);
    require q(./test.pl);
}
use OptreeCheck;
plan tests => $testct;

EO_HEADER

}

sub OptreeCheck::wrap {
    my $code = shift;
    $code =~ s/(?:(\#.*?)\n)//gsm;
    $code =~ s/\s+/ /mgs;	       
    chomp $code;
    return unless $code =~ /\S/;
    my $comment = $1;
    
    my $testcode = qq{
	
checkOptree(note   => q{$comment},
	    bcopts => q{-exec},
	    code   => q{$code},
	    expect => <<EOT_EOT, expect_nt => <<EONT_EONT);
ThreadedRef
    paste your 'golden-example' here, then retest
EOT_EOT
NonThreadedRef
    paste your 'golden-example' here, then retest
EONT_EONT
    
};
    return $testcode;
}

sub OptreeCheck::gentest {
    my ($code,$opts) = @@_;
    my $rendering = getRendering({code => $code});
    my $testcode = OptreeCheck::wrap($code);
    return unless $testcode;

    # run the prog, capture 'reference' concise output
    my $preamble = preamble(1);
    my $got = runperl( prog => "$preamble $testcode", stderr => 1,
		       #switches => ["-I../ext/B/t", "-MOptreeCheck"], 
		       );  #verbose => 1);
    
    # extract the 'reftext' ie the got 'block'
    if ($got =~ m/got \'.*?\n(.*)\n\# \'\n\# expected/s) {
	my $goldentxt = $1;
	#and plug it into the test-src
	if ($threaded) {
	    $testcode =~ s/ThreadedRef/$goldentxt/;
	} else {
	    $testcode =~ s/NonThreadRef/$goldentxt/;
	}
	my $b4 = q{expect => <<EOT_EOT, expect_nt => <<EONT_EONT};
	my $af = q{expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT'};
	$testcode =~ s/$b4/$af/;
	
	return $testcode;
    }
    return '';
}


sub OptreeCheck::processExamples {
    my @@files = @@_;

    # gets array of paragraphs, which should be code-samples.  They're
    # turned into optreeCheck tests,

    foreach my $file (@@files) {
	open (my $fh, $file) or die "cant open $file: $!\n";
	$/ = "";
	my @@chunks = <$fh>;
	print preamble (scalar @@chunks);
	foreach my $t (@@chunks) {
	    print "\n\n=for gentest\n\n# chunk: $t=cut\n\n";
	    print OptreeCheck::gentest ($t);
	}
    }
}

# OK - now for the final insult to your good taste...  

if ($0 =~ /OptreeCheck\.pm/) {

    #use lib 't';
    require './t/test.pl';

    # invoked as program.  Work like former gentest.pl,
    # ie read files given as cmdline args,
    # convert them to usable test files.

    require Getopt::Std;
    Getopt::Std::getopts('') or 
	die qq{ $0 sample-files*    # no options

	  expecting filenames as args.  Each should have paragraphs,
	  these are converted to checkOptree() tests, and printed to
	  stdout.  Redirect to file then edit for test. \n};

  OptreeCheck::processExamples(@@ARGV);
}

1;

__END__

=head1 TEST DEVELOPMENT SUPPORT

This optree regression testing framework needs tests in order to find
bugs.  To that end, OptreeCheck has support for developing new tests,
according to the following model:

 1. write a set of sample code into a single file, one per
    paragraph.  Add <=for gentest> blocks if you care to, or just look at
    f_map and f_sort in ext/B/t/ for examples.

 2. run OptreeCheck as a program on the file

   ./perl -Ilib ext/B/t/OptreeCheck.pm -w ext/B/t/f_map
   ./perl -Ilib ext/B/t/OptreeCheck.pm -w ext/B/t/f_sort

   gentest reads the sample code, runs each to generate a reference
   rendering, folds this rendering into an optreeCheck() statement,
   and prints it to stdout.

 3. run the output file as above, redirect to files, then rerun on
    same build (for sanity check), and on thread-opposite build.  With
    editor in 1 window, and cmd in other, it's fairly easy to cut-paste
    the gots into the expects, easier than running step 2 on both
    builds then trying to sdiff them together.

=head1 CAVEATS

This code is purely for testing core. While checkOptree feels flexible
enough to be stable, the whole selftest framework is subject to change
w/o notice.

=cut
@


1.1
log
@Initial revision
@
text
@d1 21
a21 4
# non-package OptreeCheck.pm
# pm allows 'use OptreeCheck', which also imports
# no package decl means all functions defined into main
# otherwise, it's like "require './test.pl'"
d29 16
a44 4
OptreeCheck supports regression testing of perl's parser, optimizer,
bytecode generator, via a single function: checkOptree(%args).  It
invokes B::Concise upon sample code, and checks that it 'agrees' with
reference renderings.
d47 1
a47 1
    name   => "test-name',	# optional, (synth from others)
d49 1
a49 1
    # 2 kinds of code-under-test: must provide 1
d52 4
d57 1
a57 1
    bcopts => '-exec',		# $opt or \@@opts, passed to BC::compile
a61 2
    # debug => 1,		# turns on regex debug for match test !!
    # retry => 1		# retry with debug on test failure
d63 3
a65 1
    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT' );
d75 1
a75 1
=head1 checkOptree(%in) Overview
d77 1
a77 2
optreeCheck() calls getRendering(), which runs code or prog through
B::Concise, and captures its rendering.
d79 2
a80 2
It then calls mkCheckRex() to produce a regex which will match the
expected rendering, and fail when it doesn't match.
d82 100
a181 1
Finally, it compares the 2; like($rendering,/$regex/,$testname).
d183 1
d185 1
a185 1
=head1 checkOptree(%Args) API
d187 1
a187 1
Accepts %Args, with following requirements and actions:
d189 2
a190 3
Either code or prog must be present.  prog is some source code, and is
passed through via test.pl:runperl, to B::Concise like this: (bcopts
are fixed up for cmdline)
d194 25
a218 3
code is a subref, or $src, like above.  If it's not a subref, it's
treated like source-code, is wrapped as a subroutine, and is passed to
B::Concise::compile().
d220 1
a220 2
    $subref = eval "sub{$src}";
    B::Concise::compile($subref).
d222 2
a223 2
expect and expect_nt are the reference optree renderings.  Theyre
required, except when the code/prog compilation fails.
d225 1
a225 1
I suppose I should also explain these more, but they seem obvious.
d227 3
a229 2
    # prog   => 'sort @@a',	# run in subprocess, aka -MO=Concise
    # noanchors => 1,		# no /^$/.  needed for 1-liners like above
d231 3
a233 12
    # skip => 1,		# skips test
    # todo => 'excuse',		# anticipated failures
    # fail => 1			# fails (by redirecting result)
    # debug => 1,		# turns on regex debug for match test !!
    # retry => 1		# retry with debug on test failure

=head1 Test Philosophy

2 platforms --> 2 reftexts: You want an accurate test, independent of
which platform you're on.  So, two refdata properties, 'expect' and
'expect_nt', carry renderings taken from threaded and non-threaded
builds.  This has several benefits:
d235 1
a235 5
 1. native reference data allows closer matching by regex.
 2. samples can be eyeballed to grok t-nt differences.
 3. data can help to validate mkCheckRex() operation.
 4. can develop regexes which accomodate t-nt differences.
 5. can test with both native and cross+converted regexes.
d237 1
a237 3
Cross-testing (expect_nt on threaded, expect on non-threaded) exposes
differences in B::Concise output, so mkCheckRex has code to do some
cross-test manipulations.  This area needs more work.
d239 1
a239 1
=head1 Test Modes
d241 1
a241 5
One consequence of a single-function API is difficulty controlling
test-mode.  Ive chosen for now to use a package hash, %gOpts, to store
test-state.  These properties alter checkOptree() function, either
short-circuiting to selftest, or running a loop that runs the testcase
2^N times, varying conditions each time.  (current N is 2 only).
d243 1
a243 2
So Test-mode is controlled with cmdline args, also called options below.
Run with 'help' to see the test-state, and how to change it.
d245 2
a246 1
=head2  selftest
d248 1
a248 3
This argument invokes runSelftest(), which tests a regex against the
reference renderings that they're made from.  Failure of a regex match
its 'mold' is a strong indicator that mkCheckRex is buggy.
d250 2
a251 2
That said, selftest mode currently runs a cross-test too, they're not
completely orthogonal yet.  See below.
a252 1
=head2 testmode=cross
d254 1
a254 3
Cross-testing is purposely creating a T-NT mismatch, looking at the
fallout, and tweaking the regex to deal with it.  Thus tests lead to
'provably' complete understanding of the differences.
d256 1
a256 3
The tweaking appears contrary to the 2-refs philosophy, but the tweaks
will be made in conversion-specific code, which (will) handles T->NT
and NT->T separately.  The tweaking is incomplete.
d258 1
a258 3
A reasonable 1st step is to add tags to indicate when TonNT or NTonT
is known to fail.  This needs an option to force failure, so the
test.pl reporting mechanics show results to aid the user.
d260 3
a262 1
=head2 testmode=native
d264 1
a264 1
This is normal mode.  Other valid values are: native, cross, both.
d266 2
a267 1
=head2 checkOptree Notes
a268 2
Accepts test code, renders its optree using B::Concise, and matches that
rendering against a regex built from one of 2 reference-renderings %in data.
d270 1
a270 6
The regex is built by mkCheckRex(\%in), which scrubs %in data to
remove match-irrelevancies, such as (args) and [args].  For example,
it strips leading '# ', making it easy to cut-paste new tests into
your test-file, run it, and cut-paste actual results into place.  You
then retest and reedit until all 'errors' are gone.  (now make sure you
haven't 'enshrined' a bug).
d272 3
a274 3
name: The test name.  May be augmented by a label, which is built from
important params, and which helps keep names in sync with whats being
tested.'
a280 2
use Data::Dumper;
$Data::Dumper::Sortkeys = 1;
d289 6
a294 2
# but wait - more skullduggery !
sub OptreeCheck::import {  &getCmdLine; }	# process @@ARGV
a302 4
     rextract	=> 'writes src-code todo same Optree matching',
     vbasic	=> 'prints $str and $rex',
     retry	=> 'retry failures after turning on re debug',
     retrydbg	=> 'retry failures after turning on re debug',
d304 1
a304 2
     selfdbg	=> 'redo failing selftests with re debug',
     xtest	=> 'extended thread/non-thread testing',
d306 1
a306 2
     dump	=> 'dump cmdline arg prcessing',
     rexpedant	=> 'try tighter regex, still buggy',
a307 1
     help	=> 0,	# 1 ends in die
d310 3
a312 4
     testmode => [qw/ native cross both /],

     # fixup for VMS, cygwin, which dont have stderr b4 stdout
     #  2nd value is used as help-str, 1st val (still) default
d314 1
d318 1
a318 1
     errs	=> 'expected compile errs',
d323 12
a334 9
# $Config::Config{usethreads} is true if some sort of threading is in use,
# in which case we ought to be able to use it in place of the || below.
# However, it is now possible to Configure perl with "threads" but neither
# ithreads or 5005threads, which forces the re-entrant APIs, but no perl
# user visible threading. This seems to have the side effect that most of perl
# doesn't think that it's threaded, hence the ops aren't threaded either.
# Not sure if this is actually a "supported" configuration, but given that
# ponie uses it, it's going to be used by something official at least in the
# interim. So it's nice for tests to all pass.
a339 5
our ($MatchRetry,$MatchRetryDebug);	# let mylike be generic
# test.pl-ish hack
*MatchRetry = \$gOpts{retry};		# but alias it into %gOpts
*MatchRetryDebug = \$gOpts{retrydbg};	# but alias it into %gOpts

d351 3
a353 3
       'expect_nt-threaded' => " (Non-threaded-ref on Threaded-build)",
       'expect-nonthreaded' => " (Threaded-ref on Non-threaded-build)",
       # native - nothing to say
d364 1
a364 1
	  Dumper \%gOpts)
d395 1
a395 1
	    $gOpts{$opt} = (grep /$opt/, @@ARGV) ? 1 : 0;
d401 1
a401 1
    print("$0 heres current state:\n", Dumper \%gOpts)
d408 2
a409 2
##################################
# API
d412 2
a413 2
    my %in = @@_;
    my ($in, $res) = (\%in,0);	 # set up privates.
d415 1
a415 1
    print "checkOptree args: ",Dumper \%in if $in{dump};
d417 7
a423 8
	label(\%in);
	skip($in{name}, 1) if $in{skip};

	# cpy globals into each test
	foreach $k (keys %gOpts) {
	    if ($gOpts{$k}) {
		$in{$k} = $gOpts{$k} unless $in{$k};
	    }
a424 1
	#die "no reftext found for $want: $in->{name}" unless $str;
d426 1
a426 1
	return runSelftest(\%in) if $gOpts{selftest};
d428 2
a429 1
	my ($rendering,@@errs) = getRendering(\%in);	# get the actual output
d431 1
a431 9
	if ($in->{errs}) {
	    if (@@errs) {
		like ("@@errs", qr/$in->{errs}\s*/, "$in->{name} - matched expected errs");
		next;
	    }
	}
	fail("FORCED: $in{name}:\n$rendering") if $gOpts{fail}; # silly ?

	# Test rendering against ..
d433 2
a434 2
	foreach $want (@@{$modes{$gOpts{testmode}}}) {
	    local $TODO = $in{todo} if $in{todo};
d436 1
a436 2
	    my ($rex,$txt,$rexstr) = mkCheckRex(\%in,$want);
	    my $cross = $msgs{"$want-$thrstat"};
d438 2
a439 16
	    # bad is anticipated failure on cross testing ONLY
	    my $bad = (0 or ( $cross && $in{crossfail})
			 or (!$cross && $in{fail})
			 or 0); # no undefs! pedant

	    # couldn't bear to pass \%in to likeyn
	    $res = mylike ( # custom test mode stuff
		[ !$bad,
		  $in{retry} || $gOpts{retry},
		  $in{debug} || $gOpts{retrydbg},
		  $rexstr,
		],
		# remaining is std API
		$rendering, qr/$rex/ms, "$cross $in{name} $in{label}")
	    || 0;
	    printhelp(\%in, $rendering, $rex);
d442 1
a442 1
    $res;
d445 18
a462 2
#################
# helpers
d466 2
a467 2
    my ($in) = @@_;
    return if $in->{name};
d469 2
a470 2
    my $buf = (ref $in->{bcopts}) 
	? join(',', @@{$in->{bcopts}}) : $in->{bcopts};
d473 1
a473 1
	$buf .= " $_: $in->{$_}" if $in->{$_} and not ref $in->{$_};
d475 1
a475 1
    return $in->{label} = $buf;
d478 2
a479 74
sub testCombo {
    # generate a set of test-cases from the options
    my $in = @@_;
    my @@cases;
    foreach $want (@@{$modes{$gOpts{testmode}}}) {
	push @@cases, [ %in ]
    }
    return @@cases;
}

sub runSelftest {
    # tests the test-cases offered (expect, expect_nt)
    # needs Unification with above.
    my ($in) = @@_;
    my $ok;
    foreach $want (@@{$modes{$gOpts{testmode}}}) {}

    for my $provenance (qw/ expect expect_nt /) {
	next unless $in->{$provenance};
	my ($rex,$gospel) = mkCheckRex($in, $provenance);
	return unless $gospel;

	my $cross = $msgs{"$provenance-$thrstat"};
	my $bad = (0 or ( $cross && $in->{crossfail})
		   or   (!$cross && $in->{fail})
		   or 0);
	    # couldn't bear to pass \%in to likeyn
	    $res = mylike ( [ !$bad,
			      $in->{retry} || $gOpts{retry},
			      $in->{debug} || $gOpts{retrydbg},
			      #label($in)
			      ],
			    $rendering, qr/$rex/ms, "$cross $in{name}")
		|| 0;
    }
    $ok;
}

# use re;
sub mylike {
    # note dependence on unlike()
    my ($control) = shift;
    my ($yes,$retry,$debug,$postmortem) = @@$control; # or dies
    my ($got, $expected, $name, @@mess) = @@_; # pass thru mostly

    die "unintended usage, expecting Regex". Dumper \@@_
	unless ref $_[1] eq 'Regexp';

    #ok($got=~/$expected/, "wow");

    # same as A ^ B, but B has side effects
    my $ok = ( (!$yes   and unlike($got, $expected, $name, @@mess))
	       or ($yes and   like($got, $expected, $name, @@mess)));

    if (not $ok and $postmortem) {
	# split rexstr into units that should eat leading lines.
	my @@rexs = map qr/^$_/, split (/\n/,$postmortem);
	foreach my $rex (@@rexs) {
	    #$got =~ s/($rex)/ate: $1/msg;	# noisy
	    $got =~ s/($rex)\n//msg;		# remove matches
	}
	print "these lines not matched:\n$got\n";
    }

    if (not $ok and $retry) {
	# redo, perhaps with use re debug - NOT ROBUST
	eval "use re 'debug'" if $debug;
	$ok = (!$yes   and unlike($got, $expected, "(RETRY) $name", @@mess)
	       or $yes and   like($got, $expected, "(RETRY) $name", @@mess));

	no re 'debug';
    }
    return $ok;
}
d482 3
a484 3
    my ($in) = @@_;
    die "getRendering: code or prog is required\n"
	unless $in->{code} or $in->{prog};
d486 1
a486 1
    my @@opts = get_bcopts($in);
d491 1
a491 1
    if ($in->{prog}) {
d493 5
a497 1
			      prog => $in->{prog}, stderr => 1,
d500 1
a500 1
	my $code = $in->{code};
d502 8
a509 2
	    # treat as source, and wrap
	    $code = eval "sub { $code }";
d511 1
a511 1
	    push @@errs, $@@ if $@@;
d515 1
a515 4
	if ($in->{fail}) {
	    fail("forced failure: stdout follows");
	    walk_output(\*STDOUT);
	}
d521 3
d525 2
a526 1
    if ($in->{strip}) {
d528 1
a528 1
	print "stripped from rendering <$1>\n" if $1 and $in->{stripv};
d530 3
a532 2
	while ($rendering =~ s/^(.*?-e line .*?\n)//g) {
	    print "stripped <$1>\n" if $in->{stripv};
d538 2
d545 1
a545 1
    my ($in) = shift;
d547 3
a549 3
    if ($in->{bcopts}) {
	@@opts = (ref $in->{bcopts} eq 'ARRAY')
	    ? @@{$in->{bcopts}} : ($in->{bcopts});
d554 22
a575 1
=head1 mkCheckRex
d577 23
a599 2
mkCheckRex receives the full testcase object, and constructs a regex.
1st, it selects a reftxt from either the expect or expect_nt items.
a600 2
Once selected, the reftext is massaged & converted into a Regex that
accepts 'good' concise renderings, with appropriate input variations,
a604 3
selection is driven by platform mostly, but also by test-mode, which
rather complicates the code.  this is worsened by the potential need
to make platform specific conversions on the reftext.
d608 10
d619 1
a619 1
purposes.  This loses some info in 'add[t5]', but greatly simplifys
d634 6
a639 2
    my ($in, $want) = @@_;
    eval "no re 'debug'";
d641 1
a641 2
    my $str = $in->{expect} || $in->{expect_nt};	# standard bias
    $str = $in->{$want} if $want;			# stated pref
d643 28
a670 1
    #fail("rex-str is empty, won't allow false positives") unless $str;
d672 4
a675 2
    $str =~ s/^\# //mg;		# ease cut-paste testcase authoring
    my $reftxt = $str;		# extra return val !!
d677 1
a677 6
    # convert all (args) and [args] to temp forms wo bracing
    $str =~ s/\[(.*?)\]/__CAPSQR$1__/msg;
    $str =~ s/\((.*?)\)/__CAPRND$1__/msg;
    $str =~ s/\((.*?)\)/__CAPRND$1__/msg; # nested () in nextstate
    
    # escape bracing, etc.. manual \Q (doesnt escape '+')
d679 1
d681 17
a697 7
    # now replace temp forms with original, preserving reference bracing 
    $str =~ s/__CAPSQR(.*?)__\b/\\[$1\\]/msg; # \b is important
    $str =~ s/__CAPRND(.*?)__\b/\\($1\\)/msg;
    $str =~ s/__CAPRND(.*?)__\b/\\($1\\)/msg; # nested () in nextstate
    
    # no 'invisible' failures in debugger
    $str =~ s/(?:next|db)state(\\\(.*?\\\))/(?:next|db)state(.*?)/msg;
d700 14
d720 1
d722 1
a722 1
    $str =~ s/(\d refs?)/\\d refs?/msg;
d724 3
a726 2

    croak "no reftext found for $want: $in->{name}"
d728 1
a728 1

d734 1
a734 1
	unless $in->{noanchors} or $in->{rxnoorder};
d736 9
a744 3
    eval "use re 'debug'" if $debug;
    my $qr = ($in->{noanchors})	? qr/$str/ms : qr/^$str$/ms ;
    no re 'debug';
d746 16
a761 2
    return ($qr, $reftxt, $str) if wantarray;
    return $qr;
d764 114
d879 1
a879 4
sub printhelp {
    # crufty - may be still useful
    my ($in, $rendering, $rex) = @@_;
    print "<$rendering>\nVS\n<$rex>\n" if $gOpts{vbasic};
d881 14
a894 7
    # save this output to afile, edit out 'ok's and 1..N
    # then perl -d afile, and add re 'debug' to suit.
    print("\$str = q%$rendering%;\n".
	  "\$rex = qr%$rex%;\n\n".
	  #"print \"\$str =~ m%\$rex%ms \";\n".
	  "\$str =~ m{\$rex}ms or print \"doh\\n\";\n\n")
	if $in{rextract} or $gOpts{rextract};
d897 3
d901 21
a921 1
#########################
d956 1
d958 2
a959 1
NonThreadRef
d980 1
a980 1
	my $reftext = $1;
d983 1
a983 1
	    $testcode =~ s/ThreadedRef/$reftext/;
d985 1
a985 1
	    $testcode =~ s/NonThreadRef/$reftext/;
a990 7
	my $got;
	if ($internal_retest) {
	    $got = runperl( prog => "$preamble $testcode", stderr => 1,
			    #switches => ["-I../ext/B/t", "-MOptreeCheck"], 
			    verbose => 1);
	    print "got: $got\n";
	}
d999 3
a1001 1
    # gets array of paragraphs, which should be tests.
d1008 1
a1008 1
	foreach $t (@@chunks) {
d1048 2
a1049 1
    paragraph.  f_map and f_sort in ext/B/t/ are examples.
a1064 13

=head1 TODO

There's a considerable amount of cruft in the whole arg-handling setup.
I'll replace / strip it before 5.10

Treat %in as a test object, interwork better with Test::*

Refactor mkCheckRex() and selfTest() to isolate the selftest,
crosstest, etc selection mechanics.

improve retry, retrydbg, esp. it's control of eval "use re debug".
This seems to work part of the time, but isn't stable enough.
@


1.1.1.1
log
@perl 5.8.6 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.8 import
@
text
@d1 4
a4 10
package OptreeCheck;
use base 'Exporter';
require "test.pl";

our $VERSION = '0.01';

# now export checkOptree, and those test.pl functions used by tests
our @@EXPORT = qw( checkOptree plan skip skip_all pass is like unlike
		  require_ok runperl );

d12 4
a15 16
OptreeCheck supports 'golden-sample' regression testing of perl's
parser, optimizer, bytecode generator, via a single function:
checkOptree(%in).

It invokes B::Concise upon the sample code, checks that the rendering
'agrees' with the golden sample, and reports mismatches.

Additionally, the module processes @@ARGV (which is typically unused in
the Core test harness), and thus provides a means to run the tests in
various modes.

=head1 EXAMPLE

  # your test file
  use OptreeCheck;
  plan tests => 1;
d18 1
a18 1
    name   => "test-name',	# optional, made from others if not given
d20 1
a20 1
    # code-under-test: must provide 1 of them
d23 1
a24 4

    errs   => 'Useless variable "@@main::a" .*'	# str, regex, [str+] [regex+],

    # various test options
d29 2
a30 2
    # retry => 1		# retry on test failure
    # debug => 1,		# use re 'debug' for retried failures !!
d32 1
a32 3
    # the 'golden-sample's, (must provide both)

    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT' );  # start HERE-DOCS
d42 1
a42 1
 __END__
d44 2
a45 1
=head2 Failure Reports
d47 2
a48 2
 Heres a sample failure, as induced by the following command.
 Note the argument; option=value, after the test-file, more on that later
d50 1
a50 100
 $> PERL_CORE=1 ./perl ext/B/t/optree_check.t  testmode=cross
 ...
 ok 19 - canonical example w -basic
 not ok 20 - -exec code: $a=$b+42
 # Failed at test.pl line 249
 #      got '1  <;> nextstate(main 600 optree_check.t:208) v
 # 2  <#> gvsv[*b] s
 # 3  <$> const[IV 42] s
 # 4  <2> add[t3] sK/2
 # 5  <#> gvsv[*a] s
 # 6  <2> sassign sKS/2
 # 7  <1> leavesub[1 ref] K/REFC,1
 # '
 # expected /(?ms-xi:^1  <;> (?:next|db)state(.*?) v
 # 2  <\$> gvsv\(\*b\) s
 # 3  <\$> const\(IV 42\) s
 # 4  <2> add\[t\d+\] sK/2
 # 5  <\$> gvsv\(\*a\) s
 # 6  <2> sassign sKS/2
 # 7  <1> leavesub\[\d+ refs?\] K/REFC,1
 # $)/
 # got:          '2  <#> gvsv[*b] s'
 # want:  (?-xism:2  <\$> gvsv\(\*b\) s)
 # got:          '3  <$> const[IV 42] s'
 # want:  (?-xism:3  <\$> const\(IV 42\) s)
 # got:          '5  <#> gvsv[*a] s'
 # want:  (?-xism:5  <\$> gvsv\(\*a\) s)
 # remainder:
 # 2  <#> gvsv[*b] s
 # 3  <$> const[IV 42] s
 # 5  <#> gvsv[*a] s
 # these lines not matched:
 # 2  <#> gvsv[*b] s
 # 3  <$> const[IV 42] s
 # 5  <#> gvsv[*a] s

Errors are reported 3 different ways;

The 1st form is directly from test.pl's like() and unlike().  Note
that this form is used as input, so you can easily cut-paste results
into test-files you are developing.  Just make sure you recognize
insane results, to avoid canonizing them as golden samples.

The 2nd and 3rd forms show only the unexpected results and opcodes.
This is done because it's blindingly tedious to find a single opcode
causing the failure.  2 different ways are done in case one is
unhelpful.

=head1 TestCase Overview

checkOptree(%tc) constructs a testcase object from %tc, and then calls
methods which eventually call test.pl's like() to produce test
results.

=head2 getRendering

getRendering() runs code or prog through B::Concise, and captures its
rendering.  Errors emitted during rendering are checked against
expected errors, and are reported as diagnostics by default, or as
failures if 'report=fail' cmdline-option is given.

prog is run in a sub-shell, with $bcopts passed through. This is the way
to run code intended for main.  The code arg in contrast, is always a
CODEREF, either because it starts that way as an arg, or because it's
wrapped and eval'd as $sub = sub {$code};

=head2 mkCheckRex

mkCheckRex() selects the golden-sample for the threaded-ness of the
platform, and produces a regex which matches the expected rendering,
and fails when it doesn't match.

The regex includes 'workarounds' which accommodate expected rendering
variations. These include:

  string constants		# avoid injection
  line numbers, etc		# args of nexstate()
  hexadecimal-numbers

  pad-slot-assignments		# for 5.8 compat, and testmode=cross
  (map|grep)(start|while)	# for 5.8 compat

=head2 mylike

mylike() calls either unlike() or like(), depending on
expectations.  Mismatch reports are massaged, because the actual
difference can easily be lost in the forest of opcodes.

=head1 checkOptree API and Operation

Since the arg is a hash, the api is wide-open, and this really is
about what elements must be or are in the hash, and what they do.  %tc
is passed to newTestCase(), the ctor, which adds in %proto, a global
prototype object.

=head2 name => STRING

If name property is not provided, it is synthesized from these params:
bcopts, note, prog, code.  This is more convenient than trying to do
it manually.
a51 1
=head2 code or prog
d53 1
a53 1
Either code or prog must be present.
d55 1
a55 1
=head2 prog => $perl_source_string
d57 3
a59 2
prog => $src provides a snippet of code, which is run in a sub-process,
via test.pl:runperl, and through B::Concise like so:
d63 3
a65 1
=head2 code => $perl_source_string || CODEREF
d67 2
a68 3
The $code arg is passed to B::Concise::compile(), and run in-process.
If $code is a string, it's first wrapped and eval'd into a $coderef.
In either case, $coderef is then passed to B::Concise::compile():
d70 2
a71 2
    $subref = eval "sub{$code}";
    $render = B::Concise::compile($subref)->();
d73 1
a73 1
=head2 expect and expect_nt
d75 2
a76 4
expect and expect_nt args are the B<golden-sample> renderings, and are
sampled from known-ok threaded and un-threaded bleadperl (5.9.1) builds.
They're both required, and the correct one is selected for the platform
being tested, and saved into the synthesized property B<wanted>.
d78 12
a89 1
=head2 bcopts => $bcopts || [ @@bcopts ]
d91 5
a95 2
When getRendering() runs, it passes bcopts into B::Concise::compile().
The bcopts arg can be a single string, or an array of strings.
d97 3
a99 1
=head2 errs => $err_str_regex || [ @@err_str_regexs ] 
d101 1
a101 3
getRendering() processes the code or prog arg under warnings, and both
parsing and optree-traversal errors are collected.  These are
validated against the one or more errors you specify.
d103 5
a107 1
=head1 testcase modifier properties
d109 2
a110 1
These properties are set as %tc parameters to change test behavior.
d112 1
a112 1
=head2 skip => 'reason'
d114 3
a116 1
invokes skip('reason'), causing test to skip.
d118 2
a119 1
=head2 todo => 'reason'
d121 1
a121 1
invokes todo('reason')
d123 3
a125 1
=head2 fail => 1
d127 3
a129 2
For code arguments, this option causes getRendering to redirect the
rendering operation to STDERR, which causes the regex match to fail.
d131 3
a133 1
=head2 retry => 1
d135 1
a135 2
If retry is set, and a test fails, it is run a second time, possibly
with regex debug.
d137 1
a137 1
=head2 debug => 1
d139 1
a139 2
If a failure is retried, this turns on eval "use re 'debug'", thus
turning on regex debug.  It's quite verbose, and not hugely helpful.
d141 2
a142 36
=head2 noanchors => 1

If set, this relaxes the regex check, which is normally pretty strict.
It's used primarily to validate checkOptree via tests in optree_check.


=head1 Synthesized object properties

These properties are added into the test object during execution.

=head2 wanted

This stores the chosen expect expect_nt string.  The OptreeCheck
object may in the future delete the raw strings once wanted is set,
thus saving space.

=head2 cross => 1

This tag is added if testmode=cross is passed in as argument.
It causes test-harness to purposely use the wrong string.


=head2 checkErrs

checkErrs() is a getRendering helper that verifies that expected errs
against those found when rendering the code on the platform.  It is
run after rendering, and before mkCheckRex.

Errors can be reported 3 different ways; diag, fail, print.

  diag - uses test.pl _diag()
  fail - causes double-testing
  print-.no # in front of the output (may mess up test harnesses)

The 3 ways are selectable at runtimve via cmdline-arg:
report={diag,fail,print}.  
d144 6
d151 3
d160 2
d170 2
a171 6
sub import {
    my $pkg = shift;
    $pkg->export_to_level(1,'checkOptree', @@EXPORT);
    getCmdLine();	# process @@ARGV
}

d180 2
d183 1
a183 1
     debug	=> 'turn on re debug for those retries',
d185 2
a186 1

d189 1
d191 1
d194 1
a194 7
     #  array: 2nd value is used as help-str, 1st val (still) default
     help	=> [0, 'provides help and exits', 0],
     testmode	=> [qw/ native cross both /],

     # reporting mode for rendering errs
     report	=> [qw/ diag fail print /],
     errcont	=> [1, 'if 1, tests match even if report is fail', 0],
d197 2
d202 1
a202 1
     errs	=> 'expected compile errs, array if several',
d207 9
a215 12
# $Config::Config{usethreads} is true if some sort of threading is in
# use, in which case we ought to be able to use it in place of the ||
# below.  However, it is now possible to Configure perl with "threads"
# but neither ithreads or 5005threads, which forces the re-entrant
# APIs, but no perl user visible threading.

# This seems to have the side effect that most of perl doesn't think
# that it's threaded, hence the ops aren't threaded either.  Not sure
# if this is actually a "supported" configuration, but given that
# ponie uses it, it's going to be used by something official at least
# in the interim. So it's nice for tests to all pass.

d221 5
d237 3
a239 3
       'expect_nt-threaded' => " (nT on T) ",
       'expect-nonthreaded' => " (T on nT) ",
       # native - nothing to say (must stay empty - used for $crosstesting)
d250 1
a250 1
	  mydumper(\%gOpts))
d281 1
a281 1
	    $gOpts{$opt} = (grep /^$opt/, @@ARGV) ? 1 : 0;
d287 1
a287 1
    print("$0 heres current state:\n", mydumper(\%gOpts))
d294 2
a295 2
##############################
# the API (1 function)
d298 2
a299 2
    my $tc = newTestCases(@@_);	# ctor
    my ($rendering);
d301 1
a301 1
    print "checkOptree args: ",mydumper($tc) if $tc->{dump};
d303 10
a312 1
	skip("$tc->{skip} $tc->{name}", 1) if $tc->{skip};
d314 1
a314 1
	return runSelftest($tc) if $gOpts{selftest};
d316 9
a324 2
	$tc->getRendering();	# get the actual output
	$tc->checkErrs();
d326 1
d329 1
a329 1
	    local $TODO = $tc->{todo} if $tc->{todo};
d331 2
a332 1
	    $tc->{cross} = $msgs{"$want-$thrstat"};
d334 16
a349 2
	    $tc->mkCheckRex($want);
	    $tc->mylike();
d355 2
a356 29
sub newTestCases {
    # make test objects (currently 1) from args (passed to checkOptree)
    my $tc = bless { @@_ }, __PACKAGE__
	or die "test cases are hashes";

    $tc->label();

    # cpy globals into each test
    foreach $k (keys %gOpts) {
	if ($gOpts{$k}) {
	    $tc->{$k} = $gOpts{$k} unless defined $tc->{$k};
	}
    }
    # transform errs to self-hash for efficient set-math
    if ($tc->{errs}) {
	if (not ref $tc->{errs}) {
	    $tc->{errs} = { $tc->{errs} => 1};
	}
	elsif (ref $tc->{errs} eq 'ARRAY') {
	    my %errs;
	    @@errs{@@{$tc->{errs}}} = (1) x @@{$tc->{errs}};
	    $tc->{errs} = \%errs;
	}
	elsif (ref $tc->{errs} eq 'Regexp') {
	    warn "regexp err matching not yet implemented";
	}
    }
    return $tc;
}
d360 2
a361 2
    my ($tc) = @@_;
    return $tc->{name} if $tc->{name};
d363 2
a364 2
    my $buf = (ref $tc->{bcopts}) 
	? join(',', @@{$tc->{bcopts}}) : $tc->{bcopts};
d367 39
a405 1
	$buf .= " $_: $tc->{$_}" if $tc->{$_} and not ref $tc->{$_};
d407 1
a407 1
    return $tc->{name} = $buf;
d410 36
a445 2
#################
# render and its helpers
d448 3
a450 3
    my $tc = shift;
    fail("getRendering: code or prog is required")
	unless $tc->{code} or $tc->{prog};
d452 1
a452 1
    my @@opts = get_bcopts($tc);
d457 1
a457 1
    if ($tc->{prog}) {
d459 1
a459 1
			      prog => $tc->{prog}, stderr => 1,
d462 1
a462 1
	my $code = $tc->{code};
d464 2
a465 4
	    # treat as source, and wrap into subref 
	    #  in caller's package ( to test arg-fixup, comment next line)
	    my $pkg = '{ package '.caller(1) .';';
	    $code = eval "$pkg sub { $code } }";
d467 1
a467 1
	    if ($@@) { chomp $@@; push @@errs, $@@ }
d471 1
a471 1
	if ($tc->{fail}) {
a479 3

	# kludge error into rendering if its empty.
	$rendering = $@@ if $@@ and ! $rendering;
d481 1
a481 2
    # separate banner, other stuff whose printing order isnt guaranteed
    if ($tc->{strip}) {
d483 1
a483 1
	print "stripped from rendering <$1>\n" if $1 and $tc->{stripv};
d485 2
a486 3
	#while ($rendering =~ s/^(.*?(-e) line \d+\.)\n//g) {
	while ($rendering =~ s/^(.*?(-e|\(eval \d+\).*?) line \d+\.)\n//g) {
	    print "stripped <$1> $2\n" if $tc->{stripv};
a491 2
    $tc->{got}	   = $rendering;
    $tc->{goterrs} = \@@errs if @@errs;
d497 1
a497 1
    my ($tc) = shift;
d499 3
a501 3
    if ($tc->{bcopts}) {
	@@opts = (ref $tc->{bcopts} eq 'ARRAY')
	    ? @@{$tc->{bcopts}} : ($tc->{bcopts});
d506 1
a506 15
sub checkErrs {
    # check rendering errs against expected errors, reduce and report
    my $tc = shift;

    # check for agreement, by hash (order less important)
    my (%goterrs, @@got);
    @@goterrs{@@{$tc->{goterrs}}} = (1) x scalar @@{$tc->{goterrs}};
    
    foreach my $k (keys %{$tc->{errs}}) {
	if (@@got = grep /^$k$/, keys %goterrs) {
	    delete $tc->{errs}{$k};
	    delete $goterrs{$_} foreach @@got;
	}
    }
    $tc->{goterrs} = \%goterrs;
d508 2
a509 36
    # relook at altered
    if (%{$tc->{errs}} or %{$tc->{goterrs}}) {
	$tc->diag_or_fail();
    }
    fail("FORCED: $tc->{name}:\n$rendering") if $gOpts{fail}; # silly ?
}

sub diag_or_fail {
    # help checkErrs
    my $tc = shift;

    my @@lines;
    push @@lines, "got unexpected:", sort keys %{$tc->{goterrs}} if %{$tc->{goterrs}};
    push @@lines, "missed expected:", sort keys %{$tc->{errs}}   if %{$tc->{errs}};

    if (@@lines) {
	unshift @@lines, $tc->{name};
	my $report = join("\n", @@lines);

	if    ($gOpts{report} eq 'diag')	{ _diag ($report) }
	elsif ($gOpts{report} eq 'fail')	{ fail  ($report) }
	else					{ print ($report) }
	next unless $gOpts{errcont}; # skip block
    }
}

=head1 mkCheckRex ($tc)

It selects the correct golden-sample from the test-case object, and
converts it into a Regexp which should match against the original
golden-sample (used in selftest, see below), and on the renderings
obtained by applying the code on the perl being tested.

The selection is driven by platform mostly, but also by test-mode,
which rather complicates the code.  This is worsened by the potential
need to make platform specific conversions on the reftext.
d511 2
d517 3
a522 10
The selected golden-sample is massaged to eliminate various match
irrelevancies.  This is done so that the tests dont fail just because
you added a line to the top of the test file.  (Recall that the
renderings contain the program's line numbers).  Similar cleanups are
done on "strings", hex-constants, etc.

The need to massage is reflected in the 2 golden-sample approach of
the test-cases; we want the match to be as rigorous as possible, and
thats easier to achieve when matching against 1 input than 2.

d524 1
a524 1
purposes.  This loses some info in 'add[t5]', but greatly simplifies
d539 1
a539 1
    my ($tc, $want) = @@_;
d542 2
a543 4
    my $str = $tc->{expect} || $tc->{expect_nt};	# standard bias
    $str = $tc->{$want} if $want && $tc->{$want};	# stated pref

    die("no '$want' golden-sample found: $tc->{name}") unless $str;
d545 1
a545 1
    $str =~ s/^\# //mg;	# ease cut-paste testcase authoring
d547 2
a548 9
    if ($] < 5.009) {
	# add 5.8 private flags, which bleadperl (5.9.1) doesn't have/use/render
	# works because it adds no wildcards, which are butchered below..
        $str =~ s|(mapstart l?K\*?)|$1/2|mg;
        $str =~ s|(grepstart l?K\*?)|$1/2|msg;
        $str =~ s|(mapwhile.*? l?K)|$1/1|msg;
	$str =~ s|(grepwhile.*? l?K)|$1/1|msg;
    }
    $tc->{wantstr} = $str;
d563 1
a563 1
    # treat dbstate like nextstate (no in-debugger false reports)
d574 1
a574 1
    $str =~ s/(\d refs?)/\\d+ refs?/msg;		# 1 ref, 2+ refs (plural)
a575 6
    #$str =~ s/(\s*)\n/\n/msg;				# trailing spaces
    
    # these fix up pad-slot assignment args
    if ($] < 5.009 or $tc->{cross}) {
	$str =~ s/\[t\d+\\]/\[t\\d+\\]/msg;	# pad slot assignments
    }
d577 1
a577 1
    croak "no reftext found for $want: $tc->{name}"
d585 1
a585 1
	unless $tc->{noanchors} or $tc->{rxnoorder};
d588 1
a588 1
    my $qr = ($tc->{noanchors})	? qr/$str/ms : qr/^$str$/ms ;
d591 2
a592 3
    $tc->{rex}		= $qr;
    $tc->{rexstr}	= $str;
    $tc;
a594 23
##############
# compare and report

sub mylike {
    # reworked mylike to use hash-obj
    my $tc	= shift;
    my $got	= $tc->{got};
    my $want	= $tc->{rex};
    my $cmnt	= $tc->{name};
    my $cross	= $tc->{cross};

    my $msgs	= $tc->{msgs};
    my $retry	= $tc->{retry}; # || $gopts{retry};
    my $debug	= $tc->{debug}; #|| $gopts{retrydbg};

    # bad is anticipated failure
    my $bad = (0 or ( $cross && $tc->{crossfail})
	       or (!$cross && $tc->{fail})
	       or 0); # no undefs !

    # same as A ^ B, but B has side effects
    my $ok = ( $bad  &&  unlike ($got, $want, $cmnt, @@$msgs)
	       or !$bad && like ($got, $want, $cmnt, @@$msgs));
d596 4
a599 1
    reduceDiffs ($tc) if not $ok;
d601 7
a607 8
    if (not $ok and $retry) {
	# redo, perhaps with use re debug - NOT ROBUST
	eval "use re 'debug'" if $debug;
	$ok = ( $bad  &&  unlike ($got, $want, "(RETRY) $cmnt", @@$msgs)
		or !$bad && like ($got, $want, "(RETRY) $cmnt", @@$msgs));
	eval "no re 'debug'";
    }
    return $ok;
a609 38
sub reduceDiffs {
    # isolate the real diffs and report them.
    # i.e. these kinds of errs:
    # 1. missing or extra ops.  this skews all following op-sequences
    # 2. single op diff, the rest of the chain is unaltered
    # in either case, std err report is inadequate;

    my $tc	= shift;
    my $got	= $tc->{got};
    my @@got	= split(/\n/, $got);
    my $want	= $tc->{wantstr};
    my @@want	= split(/\n/, $want);

    # split rexstr into units that should eat leading lines.
    my @@rexs = map qr/$_/, split (/\n/, $tc->{rexstr});

    foreach my $rex (@@rexs) {
        my $exp = shift @@want;
        my $line = shift @@got;
        # remove matches, and report
        unless ($got =~ s/($rex\n)//msg) {
            _diag("got:\t\t'$line'\nwant:\t $rex\n");
        }
    }
    _diag("remainder:\n$got");
    _diag("these lines not matched:\n$got\n");
}

=head1 Global modes

Unusually, this module also processes @@ARGV for command-line arguments
which set global modes.  These 'options' change the way the tests run,
essentially reusing the tests for different purposes.



Additionally, there's an experimental control-arg interface (i.e.
subject to change) which allows the user to set global modes.
d611 1
a611 119

=head1 Testing Method

At 1st, optreeCheck used one reference-text, but the differences
between Threaded and Non-threaded renderings meant that a single
reference (sampled from say, threaded) would be tricky and iterative
to convert for testing on a non-threaded build.  Worse, this conflicts
with making tests both strict and precise.

We now use 2 reference texts, the right one is used based upon the
build's threaded-ness.  This has several benefits:

 1. native reference data allows closer/easier matching by regex.
 2. samples can be eyeballed to grok T-nT differences.
 3. data can help to validate mkCheckRex() operation.
 4. can develop regexes which accommodate T-nT differences.
 5. can test with both native and cross-converted regexes.

Cross-testing (expect_nt on threaded, expect on non-threaded) exposes
differences in B::Concise output, so mkCheckRex has code to do some
cross-test manipulations.  This area needs more work.

=head1 Test Modes

One consequence of a single-function API is difficulty controlling
test-mode.  I've chosen for now to use a package hash, %gOpts, to store
test-state.  These properties alter checkOptree() function, either
short-circuiting to selftest, or running a loop that runs the testcase
2^N times, varying conditions each time.  (current N is 2 only).

So Test-mode is controlled with cmdline args, also called options below.
Run with 'help' to see the test-state, and how to change it.

=head2  selftest

This argument invokes runSelftest(), which tests a regex against the
reference renderings that they're made from.  Failure of a regex match
its 'mold' is a strong indicator that mkCheckRex is buggy.

That said, selftest mode currently runs a cross-test too, they're not
completely orthogonal yet.  See below.

=head2 testmode=cross

Cross-testing is purposely creating a T-NT mismatch, looking at the
fallout, which helps to understand the T-NT differences.

The tweaking appears contrary to the 2-refs philosophy, but the tweaks
will be made in conversion-specific code, which (will) handles T->NT
and NT->T separately.  The tweaking is incomplete.

A reasonable 1st step is to add tags to indicate when TonNT or NTonT
is known to fail.  This needs an option to force failure, so the
test.pl reporting mechanics show results to aid the user.

=head2 testmode=native

This is normal mode.  Other valid values are: native, cross, both.

=head2 checkOptree Notes

Accepts test code, renders its optree using B::Concise, and matches
that rendering against a regex built from one of 2 reference
renderings %tc data.

The regex is built by mkCheckRex(\%tc), which scrubs %tc data to
remove match-irrelevancies, such as (args) and [args].  For example,
it strips leading '# ', making it easy to cut-paste new tests into
your test-file, run it, and cut-paste actual results into place.  You
then retest and reedit until all 'errors' are gone.  (now make sure you
haven't 'enshrined' a bug).

name: The test name.  May be augmented by a label, which is built from
important params, and which helps keep names in sync with whats being
tested.

=cut

sub runSelftest {
    # tests the regex produced by mkCheckRex()
    # by using on the expect* text it was created with
    # failures indicate a code bug, 
    # OR regexs plugged into the expect* text (which defeat conversions)
    my $tc = shift;

    for my $provenance (qw/ expect expect_nt /) {
	#next unless $tc->{$provenance};

	$tc->mkCheckRex($provenance);
	$tc->{got} = $tc->{wantstr};	# fake the rendering
	$tc->mylike();
    }
}

my $dumploaded = 0;

sub mydumper {

    do { Dumper(@@_); return } if $dumploaded;

    eval "require Data::Dumper"
	or do{
	    print "Sorry, Data::Dumper is not available\n";
	    print "half hearted attempt:\n";
	    foreach $it (@@_) {
		if (ref $it eq 'HASH') {
		    print " $_ => $it->{$_}\n" foreach sort keys %$it;
		}
	    }
	    return;
	};

    Data::Dumper->import;
    $Data::Dumper::Sortkeys = 1;
    $dumploaded++;
    Dumper(@@_);
}

############################
a645 1
    paste your 'golden-example' here, then retest
d647 1
a647 2
NonThreadedRef
    paste your 'golden-example' here, then retest
d668 1
a668 1
	my $goldentxt = $1;
d671 1
a671 1
	    $testcode =~ s/ThreadedRef/$goldentxt/;
d673 1
a673 1
	    $testcode =~ s/NonThreadRef/$goldentxt/;
d694 1
a694 3

    # gets array of paragraphs, which should be code-samples.  Theyre
    # turned into optreeCheck tests,
d741 1
a741 2
    paragraph.  Add <=for gentest> blocks if you care to, or just look at
    f_map and f_sort in ext/B/t/ for examples.
d757 13
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@a2 3
use strict;
use warnings;
use vars qw($TODO $Level $using_open);
d5 1
a5 1
our $VERSION = '0.02';
d9 1
a9 1
		  require_ok runperl);
a11 8
# The hints flags will differ if ${^OPEN} is set.
# The approach taken is to put the hints-with-open in the golden results, and
# flag that they need to be taken out if ${^OPEN} is set.

if (((caller 0)[10]||{})->{'open<'}) {
    $using_open = 1;
}

a430 1
	local $Level = $Level + 2;
d432 1
a432 1
	foreach my $want (@@{$modes{$gOpts{testmode}}}) {
d441 1
a441 1
    return;
d452 1
a452 1
    foreach my $k (keys %gOpts) {
d511 1
a511 5
	    {
		no strict;
		no warnings;
		$code = eval "$pkg sub { $code } }";
	    }
d517 4
a520 1

a564 1
    $tc->{goterrs} ||= [];
d579 1
a579 1
    fail("FORCED: $tc->{name}:\n") if $gOpts{fail}; # silly ?
d665 5
a669 3
    # make targ args wild
    $str =~ s/\[t\d+\]/[t\\d+]/msg;

a671 1
    # $str =~ s/(?<!\\)([\[\]\(\)*.\$\@@\#\|{}])/\\$1/msg;
d673 5
d679 1
a679 16
    # Note also that there may be 1 level of () nexting, if there's an eval
    # Seems easiest to explicitly match the eval, rather than trying to parse
    # for full balancing and then substitute .*?
    # In which case, we can continue to match for the eval in the rexexp built
    # from the golden result.

    $str =~ s!(?:next|db)state
	      \\\(			# opening literal ( (backslash escaped)
	      [^()]*?			# not ()
	      (\\\(eval\ \d+\\\)	# maybe /eval \d+/ in ()
	       [^()]*?			# which might be followed by something
	      )?
	      \\\)			# closing literal )
	     !'(?:next|db)state\\([^()]*?' .
	      ($1 && '\\(eval \\d+\\)[^()]*')	# Match the eval if present
	      . '\\)'!msgxe;
a681 34
    if (!$using_open && $tc->{strip_open_hints}) {
      $str =~ s[(			# capture
		 \(\?:next\|db\)state	# the regexp matching next/db state
		 .*			# all sorts of things follow it
		 v			# The opening v
		)
		(?:(:>,<,%,\\{)		# hints when open.pm is in force
		   |(:>,<,%))		# (two variations)
		(\ ->[0-9a-z]+)?
		$
	       ]
	[$1 . ($2 && ':{') . $4]xegm;	# change to the hints without open.pm
    }

    if ($] < 5.009) {
	# 5.8.x doesn't provide the hints in the OP, which means that
	# B::Concise doesn't show the symbolic hints. So strip all the
	# symbolic hints from the golden results.
	$str =~ s[(			# capture
		   \(\?:next\|db\)state	# the regexp matching next/db state
		   .*			# all sorts of things follow it
		  v			# The opening v
		  )
		  :(?:\\[{*]		# \{ or \*
		      |[^,\\])		# or other symbols on their own
		    (?:,
		     (?:\\[{*]
			|[^,\\])
		      )*		# maybe some more joined with commas
		(\ ->[0-9a-z]+)?
		$
	       ]
	[$1$2]xgm;			# change to the hints without flags
    }
a687 1
    $str =~ s/FAKE:(\w):\d+/FAKE:$1:\\d+/msg;		# parent pad index
d693 5
d700 1
a700 1
    
d708 1
d710 1
d896 1
a896 1
	    foreach my $it (@@_) {
d980 7
d1004 1
a1004 1
	foreach my $t (@@chunks) {
@


1.1.1.4
log
@Perl 5.12.2 from CPAN
@
text
@d332 1
a332 1
     # fixup for VMS, cygwin, which don't have stderr b4 stdout
d634 1
a634 1
irrelevancies.  This is done so that the tests don't fail just because
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d8 1
a8 1
our $VERSION = '0.07';
d54 1
a54 2
    errs   => 'Name "main::a" used only once: possible typo at -e line 1.',
				# str, regex, [str+] [regex+],
d61 2
d105 1
a105 1
 # want:  (?^:2  <\$> gvsv\(\*b\) s)
d107 1
a107 1
 # want:  (?^:3  <\$> const\(IV 42\) s)
d109 1
a109 1
 # want:  (?^:5  <\$> gvsv\(\*a\) s)
d239 10
d277 11
d315 2
d320 1
a320 1
     dump	=> 'dump cmdline arg processing',
d328 4
d469 1
d471 11
a481 1
	$tc->{errs} = [$tc->{errs}] unless ref $tc->{errs} eq 'ARRAY';
d524 1
a524 1
		BEGIN { $^H = 0 }
d576 9
a584 16
    # check for agreement (order not important)
    my (%goterrs, @@missed);
    @@goterrs{@@{$tc->{goterrs}}} = (1) x scalar @@{$tc->{goterrs}}
	if $tc->{goterrs};

    foreach my $want (@@{$tc->{errs}}) {
	if (ref $want) {
	    my $seen;
	    foreach my $k (keys %goterrs) {
		next unless $k =~ $want;
		delete $goterrs{$k};
		++$seen;
	    }
	    push @@missed, $want unless $seen;
	} else {
	    push @@missed, $want unless defined delete $goterrs{$want};
d587 8
d596 3
a598 2
    @@missed = sort @@missed;
    my @@got = sort keys %goterrs;
d600 12
a611 5
    if (@@{$tc->{errs}}) {
	is(@@missed + @@got, 0, "Only got expected errors for $tc->{name}")
    } else {
	# @@missed must be 0 here.
	is(scalar @@got, 0, "Got no errors for $tc->{name}")
a612 2
    _diag(join "\n", "got unexpected:", @@got) if @@got;
    _diag(join "\n", "missed expected:", @@missed) if @@missed;
d660 1
d682 1
a682 1
    # escape bracing, etc.. manual \Q (doesn't escape '+')
d751 1
a751 1
    croak "whitespace only reftext found for '$want': $tc->{name}"
d779 4
d784 7
a790 3
    my $bad = ($cross && $tc->{crossfail}) || (!$cross && $tc->{fail});

    my $ok = $bad ? unlike ($got, $want, $cmnt) : like ($got, $want, $cmnt);
d794 7
d1040 1
a1040 1
    # gets array of paragraphs, which should be code-samples.  They're
@


1.1.1.6
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d8 1
a8 1
our $VERSION = '0.09';
d12 1
a12 1
		  require_ok runperl tempfile);
d138 4
a141 4
getRendering() runs code or prog or progfile through B::Concise, and
captures its rendering.  Errors emitted during rendering are checked
against expected errors, and are reported as diagnostics by default,
or as failures if 'report=fail' cmdline-option is given.
d183 1
a183 1
=head2 code or prog or progfile
d185 1
a185 1
Either code or prog or progfile must be present.
a193 5
=head2 progfile => $perl_script

progfile => $file provides a file containing a snippet of code which is
run as per the prog => $src example above.

a209 4
Individual sample lines may be suffixed with whitespace followed
by (<|<=|==|>=|>)5.nnnn to select that line only for the listed perl
version; the whitespace and conditional are stripped.

d217 2
a218 2
getRendering() processes the code or prog or progfile arg under warnings,
and both parsing and optree-traversal errors are collected.  These are
d407 1
a407 8
	if ($tc->{skip}) {
	    skip("$tc->{skip} $tc->{name}",
		    ($gOpts{selftest}
			? 1
			: 1 + @@{$modes{$gOpts{testmode}}}
			)
	    );
	}
d466 2
a467 2
    fail("getRendering: code or prog or progfile is required")
	unless $tc->{code} or $tc->{prog} or $tc->{progfile};
a477 4
    } elsif ($tc->{progfile}) {
	$rendering = runperl( switches => ['-w',join(',',"-MO=Concise",@@opts)],
			      progfile => $tc->{progfile}, stderr => 1,
			      ); # verbose => 1);
d622 8
a629 18
    # strip out conditional lines

    $str =~ s{^(.*?)\s+(<|<=|==|>=|>)\s*(5\.\d+)\ *\n}
     {
	my ($line, $cmp, $version) = ($1,$2,$3);
	my $repl = "";
	if (  $cmp eq '<'  ? $] <  $version
	    : $cmp eq '<=' ? $] <= $version
	    : $cmp eq '==' ? $] == $version
	    : $cmp eq '>=' ? $] >= $version
	    : $cmp eq '>'  ? $] >  $version
	    : die("bad comparision '$cmp' in string [$str]\n")
	) {
	    $repl = "$line\n";
	}
	$repl;
     }gem;

d666 1
a666 1
		(\ ->(?:-|[0-9a-z]+))?
d672 20
@


1.1.1.7
log
@Import perl-5.20.1
@
text
@d2 1
a2 1
use parent 'Exporter';
d8 1
a8 1
our $VERSION = '0.11';
d216 1
a216 2
by (<|<=|==|>=|>)5.nnnn (up to two times) to
select that line only for the listed perl
d644 1
a644 2
    $str =~ s{^(.*?)   \s+(<|<=|==|>=|>)\s*(5\.\d+)
		    (?:\s+(<|<=|==|>=|>)\s*(5\.\d+))? \ *\n}
d646 1
a646 1
	my ($line, $cmp, $version, $cmp2, $v2) = ($1,$2,$3,$4,$5,$6);
a653 8
	 and !$cmp2 || (
	      $cmp2 eq '<'  ? $] <  $v2
	    : $cmp2 eq '<=' ? $] <= $v2
	    : $cmp2 eq '==' ? $] == $v2
	    : $cmp2 eq '>=' ? $] >= $v2
	    : $cmp2 eq '>'  ? $] >  $v2
	    : die("bad comparision '$cmp2' in string [$str]\n")
	  )
d658 1
a658 1
     }gemx;
@


1.1.1.8
log
@Import perl-5.24.2
@
text
@d8 1
a8 1
our $VERSION = '0.13';
d655 1
a655 1
	    : die("bad comparison '$cmp' in string [$str]\n")
d662 1
a662 1
	    : die("bad comparison '$cmp2' in string [$str]\n")
a671 2
    # make UNOP_AUX flag type literal
    $str =~ s/<\+>/<\\+>/;
@


