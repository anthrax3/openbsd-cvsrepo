head	1.2;
access;
symbols
	OPENBSD_6_0:1.1.1.7.0.10
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.4
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.6
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.6.0.4
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.6
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.2
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.4.0.10
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.8
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.6
	OPENBSD_5_0:1.1.1.4.0.4
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.2
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.3.0.4
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.2
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.2.0.6
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.2
	OPENBSD_4_5_BASE:1.1.1.2
	PERL_5_10_0:1.1.1.2
	OPENBSD_4_4:1.1.1.1.0.10
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.8
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.6
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.4
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.2
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.11;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2006.03.28.18.47.54;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.03.28.18.47.54;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.09.29.17.18.13;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2009.10.12.18.11.11;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.09.24.14.48.52;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.08.43;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

# Verify that B::Concise properly reports whether functions are XS,
# perl, or optimized constant subs.

BEGIN {
    unshift @@INC, 't';
    require Config;
    if (($Config::Config{'extensions'} !~ /\bB\b/) ){
        print "1..0 # Skip -- Perl configured without B module\n";
        exit 0;
    }
    unless ($Config::Config{useperlio}) {
        print "1..0 # Skip -- Perl configured without perlio\n";
        exit 0;
    }
}

use Carp;
use Test::More 'no_plan';

require_ok("B::Concise");

my %matchers = 
    ( constant	=> qr{ (?-x: is a constant sub, optimized to a \w+)
		      |(?-x: exists in stash, but has no START) }x,
      XS	=> qr/ is XS code/,
      perl	=> qr/ (next|db)state/,
      core	=> qr/ coreargs/, # CORE:: subs have no nextstate
      noSTART	=> qr/ has no START/,
);

use constant a_constant => 3;
use constant a_list_constant => 4,5,6;

my @@subs_to_test = (
    'a stub'		  => noSTART  => \&baz,
    'a Perl sub'	  => perl     => sub { foo(); bar (); },
    'a constant Perl sub' => constant => sub () { 3 },
    'a constant constant' => constant => \&a_constant,
    'a list constant'	  => constant => \&a_list_constant,
    'an XSUB'		  => XS	      => \&utf8::encode,
    'a CORE:: sub'	  => core     => \&CORE::lc,
);
  
############

B::Concise::compile('-nobanner');	# set a silent default

while (@@subs_to_test) {
    my ($func_name, $want, $sub) = splice @@subs_to_test, 0, 3;

    croak "unknown type $want: $func_name\n"
	unless defined $matchers{$want};

    my ($buf, $err) = render($sub);
    my $res = like($buf, $matchers{$want}, "$want sub:\t $func_name");

    unless ($res) {
	# Test failed.  Report type that would give success.
	for my $m (keys %matchers) {
	    diag ("$name is of type $m"), last if $buf =~ $matchers{$m};
	}
    }
}

sub render {
    my ($func_name) = @@_;

    B::Concise::reset_sequence();
    B::Concise::walk_output(\my $buf);

    my $walker = B::Concise::compile($func_name);
    eval { $walker->() };
    diag("err: $@@ $buf") if $@@;
    diag("verbose: $buf") if $opts{V};

    return ($buf, $@@);
}

__END__
@


1.1
log
@Initial revision
@
text
@d3 2
a4 70
# 2 purpose file: 1-test 2-demonstrate (via args, -v -a options)

=head1 SYNOPSIS

To verify that B::Concise properly reports whether functions are XS or
perl, we test against 2 (currently) core packages which have lots of
XS functions: B and Digest::MD5.  They're listed in %$testpkgs, along
with a list of functions that are (or are not) XS.  For brevity, you
can specify the shorter list; if they're non-xs routines, start list
with a '!'.  Data::Dumper is also tested, partly to prove the non-!
usage.

We demand-load each package, scan its stash for function names, and
mark them as XS/not-XS according to the list given for each package.
Then we test B::Concise's report on each.

=head1 OPTIONS AND ARGUMENTS

C<-v> and C<-V> trigger 2 levels of verbosity.

C<-a> uses Module::CoreList to run all core packages through the test, which
gives some interesting results.

C<-c> causes the expected XS/non-XS results to be marked with
corrections, which are then reported at program END, in a
Data::Dumper statement

C<< -r <file> >> reads a file, as written by C<-c>, and adjusts the expected
results accordingly.  The file is 'required', so @@INC settings apply.

If module-names are given as args, those packages are run through the
test harness; this is handy for collecting further items to test, and
may be useful otherwise (ie just to see).

=head1 EXAMPLES

All following examples avoid using PERL_CORE=1, since that changes @@INC

=over 4

=item ./perl -Ilib -wS ext/B/t/concise-xs.t -c Storable

Tests Storable.pm for XS/non-XS routines, writes findings (along with
test results) to stdout.  You could edit results to produce a test
file, as in next example

=item ./perl -Ilib -wS ext/B/t/concise-xs.t -r ./storable

Loads file, and uses it to set expectations, and run tests

=item ./perl -Ilib -wS ext/B/t/concise-xs.t -avc > ../foo-avc 2> ../foo-avc2

Gets module list from Module::Corelist, and runs them all through the
test.  Since -c is used, this generates corrections, which are saved
in a file, which is edited down to produce ../all-xs

=item ./perl -Ilib -wS ext/B/t/concise-xs.t -cr ../all-xs > ../foo 2> ../foo2

This runs the tests specified in the file created in previous example.
-c is used again, and stdout verifies that all the expected results
given by -r ../all-xs are now seen.

Looking at ../foo2, you'll see 34 occurrences of the following error:

# err: Can't use an undefined value as a SCALAR reference at
# lib/B/Concise.pm line 634, <DATA> line 1.

=back

=cut
d7 1
a7 7
    if ($ENV{PERL_CORE}) {
	chdir('t') if -d 't';
	@@INC = ('.', '../lib');
    } else {
	unshift @@INC, 't';
	push @@INC, "../../t";
    }
a18 1
use Getopt::Std;
d20 1
a20 4
# One 5.009-only test to go when no 6; is integrated (25344)
use Test::More tests => ( 1 * !!$Config::Config{useithreads}
			  + 1 * ($] > 5.009)
			  + 778);
d24 22
a45 29
my $testpkgs = {

    Digest::MD5 => [qw/ ! import /],

    B => [qw/ ! class clearsym compile_stats debug objsym parents
	      peekop savesym timing_info walkoptree_exec
	      walkoptree_slow walksymtable /],

    Data::Dumper => [qw/ bootstrap Dumpxs /],

    B::Deparse => [qw/ ASSIGN CVf_ASSERTION CVf_LOCKED CVf_LVALUE
		   CVf_METHOD LIST_CONTEXT OP_CONST OP_LIST OP_RV2SV
		   OP_STRINGIFY OPf_KIDS OPf_MOD OPf_REF OPf_SPECIAL
		   OPf_STACKED OPf_WANT OPf_WANT_LIST OPf_WANT_SCALAR
		   OPf_WANT_VOID OPpCONST_ARYBASE OPpCONST_BARE
		   OPpENTERSUB_AMPER OPpEXISTS_SUB OPpITER_REVERSED
		   OPpLVAL_INTRO OPpOUR_INTRO OPpSLICE OPpSORT_DESCEND
		   OPpSORT_INPLACE OPpSORT_INTEGER OPpSORT_NUMERIC
		   OPpSORT_REVERSE OPpTARGET_MY OPpTRANS_COMPLEMENT
		   OPpTRANS_DELETE OPpTRANS_SQUASH PMf_CONTINUE
		   PMf_EVAL PMf_EXTENDED PMf_FOLD PMf_GLOBAL PMf_KEEP
		   PMf_MULTILINE PMf_ONCE PMf_SINGLELINE PMf_SKIPWHITE
		   POSTFIX SVf_FAKE SVf_IOK SVf_NOK SVf_POK SVf_ROK
		   SVpad_OUR SVs_RMG SVs_SMG SWAP_CHILDREN main_cv
		   main_root main_start opnumber perlstring
		   svref_2object /],

};

a48 23
getopts('vaVcr:', \my %opts) or
    die <<EODIE;

usage: PERL_CORE=1 ./perl ext/B/t/concise-xs.t [-av] [module-list]
    tests ability to discern XS funcs using Digest::MD5 package
    -v	: runs verbosely
    -V	: more verbosity
    -a	: runs all modules in CoreList
    -c  : writes test corrections as a Data::Dumper expression
    -r <file>	: reads file of tests, as written by -c
    <args>	: additional modules are loaded and tested
    	(will report failures, since no XS funcs are known aprior)

EODIE
    ;

if (%opts) {
    require Data::Dumper;
    Data::Dumper->import('Dumper');
    $Data::Dumper::Sortkeys = 1;
}
my @@argpkgs = @@ARGV;
my %report;
d50 2
a51 19
if ($opts{r}) {
    my $refpkgs = require "$opts{r}";
    $testpkgs->{$_} = $refpkgs->{$_} foreach keys %$refpkgs;
}

unless ($opts{a}) {
    unless (@@argpkgs) {
	foreach $pkg (sort keys %$testpkgs) {
	    test_pkg($pkg, $testpkgs->{$pkg});
	}
    } else {
	foreach $pkg (@@argpkgs) {
	    test_pkg($pkg, $testpkgs->{$pkg});
	}
    }
} else {
    corecheck();
}
############
d53 2
a54 8
sub test_pkg {
    my ($pkg_name, $xslist) = @@_;
    require_ok($pkg_name);

    unless (ref $xslist eq 'ARRAY') {
	warn "no XS/non-XS function list given, assuming empty XS list";
	$xslist = [''];
    }
d56 2
a57 2
    my $assumeXS = 0;	# assume list enumerates XS funcs, not perl ones
    $assumeXS = 1	if $xslist->[0] and $xslist->[0] eq '!';
d59 4
a62 25
    # build %stash: keys are func-names, vals: 1 if XS, 0 if not
    my (%stash) = map
	( ($_ => $assumeXS)
	  => ( grep exists &{"$pkg_name\::$_"}	# grab CODE symbols
	       => grep !/__ANON__/		# but not anon subs
	       => keys %{$pkg_name.'::'}	# from symbol table
	       ));

    # now invert according to supplied list
    $stash{$_} = int ! $assumeXS foreach @@$xslist;

    # and cleanup cruft (easier than preventing)
    delete @@stash{'!',''};

    if ($opts{v}) {
	diag("xslist: " => Dumper($xslist));
	diag("$pkg_name stash: " => Dumper(\%stash));
    }
    my $err;
    foreach $func_name (reverse sort keys %stash) {
	my $res = checkXS("${pkg_name}::$func_name", $stash{$func_name});
	if (!$res) {
	    $stash{$func_name} ^= 1;
	    print "$func_name ";
	    $err++;
a64 15
    $report{$pkg_name} = \%stash if $opts{c} and $err || $opts{v};
}

sub checkXS {
    my ($func_name, $wantXS) = @@_;

    my ($buf, $err) = render($func_name);
    if ($wantXS) {
	like($buf, qr/\Q$func_name is XS code/,
	     "XS code:\t $func_name");
    } else {
	unlike($buf, qr/\Q$func_name is XS code/,
	       "perl code:\t $func_name");
    }
    #returns like or unlike, whichever was called
a78 36
}

sub corecheck {

    eval { require Module::CoreList };
    if ($@@) {
	warn "Module::CoreList not available on $]\n";
	return;
    }
    my $mods = $Module::CoreList::version{'5.009002'};
    $mods = [ sort keys %$mods ];
    print Dumper($mods);

    foreach my $pkgnm (@@$mods) {
	test_pkg($pkgnm);
    }
}

END {
    if ($opts{c}) {
	# print "Corrections: ", Dumper(\%report);
	print "# Tested Package Subroutines, 1's are XS, 0's are perl\n";
	print "\$VAR1 = {\n";

	foreach my $pkg (sort keys %report) {
	    my (@@xs, @@perl);
	    my $stash = $report{$pkg};

	    @@xs   = sort grep $stash->{$_} == 1, keys %$stash;
	    @@perl = sort grep $stash->{$_} == 0, keys %$stash;

	    my @@list = (@@xs > @@perl) ? ( '!', @@perl) : @@xs;
	    print "\t$pkg => [qw/ @@list /],\n";
	}
	print "};\n";
    }
@


1.1.1.1
log
@perl 5.8.8 import
@
text
@@


1.1.1.2
log
@import perl 5.10.0 from CPAN
@
text
@d7 11
a17 35
To verify that B::Concise properly reports whether functions are XS,
perl, or optimized constant subs, we test against a few core packages
which have a stable API, and which have functions of all 3 types.

=head1 WHAT IS TESTED

5 core packages are tested; Digest::MD5, B, B::Deparse, Data::Dumper,
and POSIX.  These have a mix of the 3 expected implementation types;
perl, XS, and constant (optimized constant subs).

%$testpkgs specifies what packages are tested; each package is loaded,
and the stash is scanned for the function-names in that package.

Each value in %$testpkgs is a hash-of-lists (HoL) whose keys are
implementation-types and values are lists of function-names of that type.

To keep these HoLs smaller and more managable, they may carry an
additional 'dflt' => $impl_Type, which means that unnamed functions
are expected to be of that default implementation type.  Those unnamed
functions are known from the scan of the package stash.

=head1 HOW THEY'RE TESTED

Each function is 'rendered' by B::Concise, and result is matched
against regexs for each possible implementation-type.  For some
packages, some functions may be unimplemented on some platforms.

To slay this maintenance dragon, the regexs used in like() match
against renderings which indicate that there is no implementation.

If a function is implemented differently on different platforms, the
test for that function will fail on one of those platforms.  These
specific functions can be skipped by a 'skip' => [ @@list ] to the HoL
mentioned previously.  See usage for skip in B's HoL, which avoids
testing a function which doesnt exist on non-threaded builds.
d27 2
a28 3
corrections, which are then reported at program END, in a form that's
readily cut-and-pastable into this file.

d39 2
d95 4
a98 1
use Test::More 'no_plan';
d102 1
a102 7
my %matchers = 
    ( constant	=> qr{ (?-x: is a constant sub, optimized to a \w+)
		      |(?-x: exists in stash, but has no START) }x,
      XS	=> qr/ is XS code/,
      perl	=> qr/ (next|db)state/,
      noSTART	=> qr/ exists in stash, but has no START/,
);
d104 1
a104 2
my $testpkgs = {
    # packages to test, with expected types for named funcs
d106 22
a127 2
    Digest::MD5 => { perl => [qw/ import /],
		     dflt => 'XS' },
a128 82
    Data::Dumper => { XS => [qw/ bootstrap Dumpxs /],
		      dflt => 'perl' },
    B => { 
	dflt => 'constant',		# all but 47/297
	skip => [ 'regex_padav' ],	# threaded only
	perl => [qw(
		    walksymtable walkoptree_slow walkoptree_exec
		    timing_info savesym peekop parents objsym debug
		    compile_stats clearsym class
		    )],
	XS => [qw(
		  warnhook walkoptree_debug walkoptree threadsv_names
		  svref_2object sv_yes sv_undef sv_no save_BEGINs
		  regex_padav ppname perlstring opnumber minus_c
		  main_start main_root main_cv init_av inc_gv hash
		  formfeed end_av dowarn diehook defstash curstash
		  cstring comppadlist check_av cchar cast_I32 bootstrap
		  begin_av amagic_generation sub_generation address
		  ), $] > 5.009 ? ('unitcheck_av') : ()],
    },

    B::Deparse => { dflt => 'perl',	# 235 functions

	XS => [qw( svref_2object perlstring opnumber main_start
		   main_root main_cv )],

	constant => [qw/ ASSIGN CVf_LOCKED CVf_LVALUE
		     CVf_METHOD LIST_CONTEXT OP_CONST OP_LIST OP_RV2SV
		     OP_STRINGIFY OPf_KIDS OPf_MOD OPf_REF OPf_SPECIAL
		     OPf_STACKED OPf_WANT OPf_WANT_LIST OPf_WANT_SCALAR
		     OPf_WANT_VOID OPpCONST_ARYBASE OPpCONST_BARE
		     OPpENTERSUB_AMPER OPpEXISTS_SUB OPpITER_REVERSED
		     OPpLVAL_INTRO OPpOUR_INTRO OPpSLICE OPpSORT_DESCEND
		     OPpSORT_INPLACE OPpSORT_INTEGER OPpSORT_NUMERIC
		     OPpSORT_REVERSE OPpTARGET_MY OPpTRANS_COMPLEMENT
		     OPpTRANS_DELETE OPpTRANS_SQUASH PMf_CONTINUE
		     PMf_EVAL PMf_EXTENDED PMf_FOLD PMf_GLOBAL PMf_KEEP
		     PMf_MULTILINE PMf_ONCE PMf_SINGLELINE
		     POSTFIX SVf_FAKE SVf_IOK SVf_NOK SVf_POK SVf_ROK
		     SVpad_OUR SVs_RMG SVs_SMG SWAP_CHILDREN OPpPAD_STATE
		     /, $] > 5.009 ? ('RXf_SKIPWHITE') : ('PMf_SKIPWHITE')],
		 },

    POSIX => { dflt => 'constant',			# all but 252/589
	       skip => [qw/ _POSIX_JOB_CONTROL /],	# platform varying
	       perl => [qw/ import croak AUTOLOAD /],

	       XS => [qw/ write wctomb wcstombs uname tzset tzname
		      ttyname tmpnam times tcsetpgrp tcsendbreak
		      tcgetpgrp tcflush tcflow tcdrain tanh tan
		      sysconf strxfrm strtoul strtol strtod
		      strftime strcoll sinh sigsuspend sigprocmask
		      sigpending sigaction setuid setsid setpgid
		      setlocale setgid read pipe pause pathconf
		      open nice modf mktime mkfifo mbtowc mbstowcs
		      mblen lseek log10 localeconv ldexp lchown
		      isxdigit isupper isspace ispunct isprint
		      islower isgraph isdigit iscntrl isalpha
		      isalnum int_macro_int getcwd frexp fpathconf
		      fmod floor dup2 dup difftime cuserid ctime
		      ctermid cosh constant close clock ceil
		      bootstrap atan asin asctime acos access abort
		      _exit
		      /],
	       },

    IO::Socket => { dflt => 'constant',		# 157/190

		    perl => [qw/ timeout socktype sockopt sockname
			     socketpair socket sockdomain sockaddr_un
			     sockaddr_in shutdown setsockopt send
			     register_domain recv protocol peername
			     new listen import getsockopt croak
			     connected connect configure confess close
			     carp bind atmark accept
			     /, $] > 5.009 ? ('blocking') : () ],

		    XS => [qw/ unpack_sockaddr_un unpack_sockaddr_in
			   sockatmark sockaddr_family pack_sockaddr_un
			   pack_sockaddr_in inet_ntoa inet_aton
			   /],
		},
d145 1
a145 1
    	(will report failures, since no XS funcs are known apriori)
d179 2
a180 2
    my ($pkg, $fntypes) = @@_;
    require_ok($pkg);
d182 9
a190 1
    # build %stash: keys are func-names, vals filled in below
d192 2
a193 2
	( ($_ => 0)
	  => ( grep exists &{"$pkg\::$_"}	# grab CODE symbols
d195 1
a195 1
	       => keys %{$pkg.'::'}		# from symbol table
d198 5
a202 13
    for my $type (keys %matchers) {
	foreach my $fn (@@{$fntypes->{$type}}) {
	    carp "$fn can only be one of $type, $stash{$fn}\n"
		if $stash{$fn};
	    $stash{$fn} = $type;
	}
    }
    # set default type for un-named functions
    my $dflt = $fntypes->{dflt} || 'perl';
    for my $k (keys %stash) {
	$stash{$k} = $dflt unless $stash{$k};
    }
    $stash{$_} = 'skip' foreach @@{$fntypes->{skip}};
d205 2
a206 2
	diag("fntypes: " => Dumper($fntypes));
	diag("$pkg stash: " => Dumper(\%stash));
d208 7
a214 5
    foreach my $fn (reverse sort keys %stash) {
	next if $stash{$fn} eq 'skip';
	my $res = checkXS("${pkg}::$fn", $stash{$fn});
	if ($res ne '1') {
	    push @@{$report{$pkg}{$res}}, $fn;
d217 1
d221 1
a221 4
    my ($func_name, $want) = @@_;

    croak "unknown type $want: $func_name\n"
	unless defined $matchers{$want};
d224 6
a229 7
    my $res = like($buf, $matchers{$want}, "$want sub:\t $func_name");

    unless ($res) {
	# test failed. return type that would give success
	for my $m (keys %matchers) {
	    return $m if $buf =~ $matchers{$m};
	}
d231 1
a231 1
    $res;
d249 1
d266 3
a268 2
	$Data::Dumper::Indent = 1;
	print "Corrections: ", Dumper(\%report);
d271 8
a278 4
	    for my $type (keys %matchers) {
		print "$pkg: $type: @@{$report{$pkg}{$type}}\n"
		    if @@{$report{$pkg}{$type}};
	    }
d280 1
@


1.1.1.3
log
@import perl 5.10.1
@
text
@d162 1
a162 1
	constant => [qw/ ASSIGN CVf_LVALUE
d176 1
a176 3
		     /, $] > 5.009 ? ('RXf_SKIPWHITE') : ('PMf_SKIPWHITE'),
		    'CVf_LOCKED', # This ends up as a constant, pre or post 5.10
		    ],
d180 1
a180 10
	       skip => [qw/ _POSIX_JOB_CONTROL /,	# platform varying
			# Might be XS or imported from Fcntl, depending on your
			# perl version:
			qw / S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG /,
			# Might be XS or AUTOLOADed, depending on your perl
			# version:
			qw /WEXITSTATUS WIFEXITED WIFSIGNALED WIFSTOPPED
			    WSTOPSIG WTERMSIG/,
		       'int_macro_int', # Removed in POSIX 1.16
		       ],
d194 1
a194 1
		      isalnum getcwd frexp fpathconf
@


1.1.1.4
log
@Perl 5.12.2 from CPAN
@
text
@d98 7
a104 1
    unshift @@INC, 't';
d157 1
a157 1
    B::Deparse => { dflt => 'perl',	# 236 functions
d170 4
a173 4
		     OPpSORT_REVERSE OPpREVERSE_INPLACE OPpTARGET_MY
		     OPpTRANS_COMPLEMENT OPpTRANS_DELETE OPpTRANS_SQUASH
		     PMf_CONTINUE PMf_EVAL PMf_EXTENDED PMf_FOLD PMf_GLOBAL
		     PMf_KEEP PMf_MULTILINE PMf_ONCE PMf_SINGLELINE
a227 1
            # skip inet_ntop and inet_pton as they're not exported by default
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d23 1
a23 1
To keep these HoLs smaller and more manageable, they may carry an
d41 1
a41 1
testing a function which doesn't exist on non-threaded builds.
d130 1
a130 2
    Data::Dumper => { XS => [qw/ bootstrap Dumpxs _vstring /],
		      constant => ['_bad_vsmg'],
a157 1
		     OP_GLOB
d160 1
a160 1
		     OPf_WANT_VOID OPpCONST_BARE OPpCONST_NOVER
d167 1
a167 2
		     PMf_KEEP PMf_NONDESTRUCT PMf_SKIPWHITE RXf_PMf_CHARSET
		     PMf_MULTILINE PMf_ONCE PMf_SINGLELINE RXf_PMf_KEEPCOPY
a169 1
		     OPpCONST_ARYBASE OPpEVAL_BYTES OPpSUBSTR_REPL_FIRST
d186 1
a186 2
	       perl => [qw/ import load_imports croak usage printf sprintf
			perror AUTOLOAD /],
d203 1
a203 1
		      _exit sleep
d215 1
a215 1
			     carp bind atmark accept sockaddr_in6
a220 1
			   unpack_sockaddr_in6 pack_sockaddr_in6
@


1.1.1.6
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d130 2
a131 4
    Data::Dumper => { XS => [qw/ bootstrap Dumpxs /,
			$] >= 5.015 ? qw/_vstring / : () ],
		    $] >= 5.015
			?  (constant => ['_bad_vsmg']) : (),
d149 1
a149 1
		  unitcheck_av) ],
d159 1
d169 2
a170 2
		     PMf_KEEP PMf_NONDESTRUCT
		     PMf_MULTILINE PMf_ONCE PMf_SINGLELINE
d173 2
a174 4
		     OPpCONST_ARYBASE RXf_SKIPWHITE/,
		     $] >= 5.015 ? qw(
		     OP_GLOB PMf_SKIPWHITE RXf_PMf_CHARSET RXf_PMf_KEEPCOPY
		     OPpEVAL_BYTES OPpSUBSTR_REPL_FIRST) : (),
d190 2
a191 5
	       perl => [qw/ import croak AUTOLOAD /,
			$] >= 5.015
			    ? qw/load_imports usage printf sprintf perror/
			    : (),
			],
d208 2
a209 2
		      _exit
		      /, $] >= 5.015 ? ('sleep') : () ],
d221 1
a221 1
			     blocking/ ],
a253 1
    { my $x = \*Data::Dumper::Sortkeys } # shut up 'used once' warning
a355 1
    { my $x = \*Module::CoreList::version } # shut up 'used once' warning
a366 1
	{ my $x = \*Data::Dumper::Indent } # shut up 'used once' warning
@


1.1.1.7
log
@Import perl-5.20.1
@
text
@a177 1
		     $] >= 5.019 ? qw(OP_PUSHMARK OP_NULL) : (),
@


