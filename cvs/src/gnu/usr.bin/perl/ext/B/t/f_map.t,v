head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.7.0.10
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.4
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.6
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.6.0.4
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.6
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.2
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.4.0.10
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.8
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.6
	OPENBSD_5_0:1.1.1.4.0.4
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.2
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.3.0.8
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.4
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.10
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.8
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.6
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.4
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.2
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.1.0.6
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.4
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.2
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.11;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.03.28.18.47.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.14;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.09.24.14.48.52;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.08.43;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!perl

BEGIN {
    unshift @@INC, 't';
    require Config;
    if (($Config::Config{'extensions'} !~ /\bB\b/) ){
        print "1..0 # Skip -- Perl configured without B module\n";
        exit 0;
    }
    if (!$Config::Config{useperlio}) {
        print "1..0 # Skip -- need perlio to walk the optree\n";
        exit 0;
    }
}
use OptreeCheck;
plan tests => 18;


=head1 f_map.t

Code test snippets here are adapted from `perldoc -f map`

Due to a bleadperl optimization (Dave Mitchell, circa may 04), the
(map|grep)(start|while) opcodes have different flags in 5.9, their
private flags /1, /2 are gone in blead (for the cases covered)

When the optree stuff was integrated into 5.8.6, these tests failed,
and were todo'd.  They're now done, by version-specific tweaking in
mkCheckRex(), therefore the skip is removed too.

=for gentest

# chunk: #!perl
# examples shamelessly snatched from perldoc -f map

=cut

=for gentest

# chunk: # translates a list of numbers to the corresponding characters.
@@chars = map(chr, @@nums);

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{@@chars = map(chr, @@nums); },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 475 (eval 10):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*nums] s
# 5  <1> rv2av[t7] lKM/1
# 6  <@@> mapstart lK
# 7  <|> mapwhile(other->8)[t8] lK
# 8      <#> gvsv[*_] s
# 9      <1> chr[t5] sK/1
#            goto 7
# a  <0> pushmark s
# b  <#> gv[*chars] s
# c  <1> rv2av[t2] lKRM*/1
# d  <2> aassign[t9] KS/COM_AGG
# e  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 559 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*nums) s
# 5  <1> rv2av[t4] lKM/1
# 6  <@@> mapstart lK
# 7  <|> mapwhile(other->8)[t5] lK
# 8      <$> gvsv(*_) s
# 9      <1> chr[t3] sK/1
#            goto 7
# a  <0> pushmark s
# b  <$> gv(*chars) s
# c  <1> rv2av[t1] lKRM*/1
# d  <2> aassign[t6] KS/COM_AGG
# e  <1> leavesub[1 ref] K/REFC,1
EONT_EONT


=for gentest

# chunk: %hash = map { getkey($_) => $_ } @@array;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{%hash = map { getkey($_) => $_ } @@array; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 476 (eval 10):1) v:{
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*array] s
# 5  <1> rv2av[t8] lKM/1
# 6  <@@> mapstart lK
# 7  <|> mapwhile(other->8)[t9] lK
# 8      <0> enter l
# 9      <;> nextstate(main 475 (eval 10):1) v:{
# a      <0> pushmark s
# b      <#> gvsv[*_] s
# c      <#> gv[*getkey] s/EARLYCV
# d      <1> entersub[t5] lKS/TARG
# e      <#> gvsv[*_] s
# f      <@@> leave lKP
#            goto 7
# g  <0> pushmark s
# h  <#> gv[*hash] s
# i  <1> rv2hv lKRM*/1
# j  <2> aassign[t10] KS/COM_AGG
# k  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 560 (eval 15):1) v:{
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*array) s
# 5  <1> rv2av[t3] lKM/1
# 6  <@@> mapstart lK
# 7  <|> mapwhile(other->8)[t4] lK
# 8      <0> enter l
# 9      <;> nextstate(main 559 (eval 15):1) v:{
# a      <0> pushmark s
# b      <$> gvsv(*_) s
# c      <$> gv(*getkey) s/EARLYCV
# d      <1> entersub[t2] lKS/TARG
# e      <$> gvsv(*_) s
# f      <@@> leave lKP
#            goto 7
# g  <0> pushmark s
# h  <$> gv(*hash) s
# i  <1> rv2hv lKRM*/1
# j  <2> aassign[t5] KS/COM_AGG
# k  <1> leavesub[1 ref] K/REFC,1
EONT_EONT


=for gentest

# chunk: {
    %hash = ();
    foreach $_ (@@array) {
	$hash{getkey($_)} = $_;
    }
}

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{{ %hash = (); foreach $_ (@@array) { $hash{getkey($_)} = $_; } } },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 478 (eval 10):1) v:{
# 2  <{> enterloop(next->u last->u redo->3) 
# 3  <;> nextstate(main 475 (eval 10):1) v
# 4  <0> pushmark s
# 5  <0> pushmark s
# 6  <#> gv[*hash] s
# 7  <1> rv2hv lKRM*/1
# 8  <2> aassign[t3] vKS
# 9  <;> nextstate(main 476 (eval 10):1) v:{
# a  <0> pushmark sM
# b  <#> gv[*array] s
# c  <1> rv2av[t6] sKRM/1
# d  <#> gv[*_] s
# e  <1> rv2gv sKRM/1
# f  <{> enteriter(next->q last->t redo->g) KS/DEF
# r  <0> iter s
# s  <|> and(other->g) K/1
# g      <;> nextstate(main 475 (eval 10):1) v:{
# h      <#> gvsv[*_] s
# i      <#> gv[*hash] s
# j      <1> rv2hv sKR/1
# k      <0> pushmark s
# l      <#> gvsv[*_] s
# m      <#> gv[*getkey] s/EARLYCV
# n      <1> entersub[t10] sKS/TARG
# o      <2> helem sKRM*/2
# p      <2> sassign vKS/2
# q      <0> unstack s
#            goto r
# t  <2> leaveloop KP/2
# u  <2> leaveloop K/2
# v  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 562 (eval 15):1) v:{
# 2  <{> enterloop(next->u last->u redo->3) 
# 3  <;> nextstate(main 559 (eval 15):1) v
# 4  <0> pushmark s
# 5  <0> pushmark s
# 6  <$> gv(*hash) s
# 7  <1> rv2hv lKRM*/1
# 8  <2> aassign[t2] vKS
# 9  <;> nextstate(main 560 (eval 15):1) v:{
# a  <0> pushmark sM
# b  <$> gv(*array) s
# c  <1> rv2av[t3] sKRM/1
# d  <$> gv(*_) s
# e  <1> rv2gv sKRM/1
# f  <{> enteriter(next->q last->t redo->g) KS/DEF
# r  <0> iter s
# s  <|> and(other->g) K/1
# g      <;> nextstate(main 559 (eval 15):1) v:{
# h      <$> gvsv(*_) s
# i      <$> gv(*hash) s
# j      <1> rv2hv sKR/1
# k      <0> pushmark s
# l      <$> gvsv(*_) s
# m      <$> gv(*getkey) s/EARLYCV
# n      <1> entersub[t4] sKS/TARG
# o      <2> helem sKRM*/2
# p      <2> sassign vKS/2
# q      <0> unstack s
#            goto r
# t  <2> leaveloop KP/2
# u  <2> leaveloop K/2
# v  <1> leavesub[1 ref] K/REFC,1
EONT_EONT


=for gentest

# chunk: #%hash = map {  "\L$_", 1  } @@array;  # perl guesses EXPR.  wrong
%hash = map { +"\L$_", 1  } @@array;  # perl guesses BLOCK. right

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{%hash = map { +"\L$_", 1 } @@array; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 476 (eval 10):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*array] s
# 5  <1> rv2av[t7] lKM/1
# 6  <@@> mapstart lK
# 7  <|> mapwhile(other->8)[t9] lK
# 8      <#> gvsv[*_] s
# 9      <1> lc[t4] sK/1
# a      <$> const[IV 1] s
#            goto 7
# b  <0> pushmark s
# c  <#> gv[*hash] s
# d  <1> rv2hv lKRM*/1
# e  <2> aassign[t10] KS/COM_AGG
# f  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 560 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*array) s
# 5  <1> rv2av[t4] lKM/1
# 6  <@@> mapstart lK
# 7  <|> mapwhile(other->8)[t5] lK
# 8      <$> gvsv(*_) s
# 9      <1> lc[t2] sK/1
# a      <$> const(IV 1) s
#            goto 7
# b  <0> pushmark s
# c  <$> gv(*hash) s
# d  <1> rv2hv lKRM*/1
# e  <2> aassign[t6] KS/COM_AGG
# f  <1> leavesub[1 ref] K/REFC,1
EONT_EONT


=for gentest

# chunk: %hash = map { ("\L$_", 1) } @@array;  # this also works

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{%hash = map { ("\L$_", 1) } @@array; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 476 (eval 10):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*array] s
# 5  <1> rv2av[t7] lKM/1
# 6  <@@> mapstart lK
# 7  <|> mapwhile(other->8)[t9] lK
# 8      <#> gvsv[*_] s
# 9      <1> lc[t4] sK/1
# a      <$> const[IV 1] s
#            goto 7
# b  <0> pushmark s
# c  <#> gv[*hash] s
# d  <1> rv2hv lKRM*/1
# e  <2> aassign[t10] KS/COM_AGG
# f  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 560 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*array) s
# 5  <1> rv2av[t4] lKM/1
# 6  <@@> mapstart lK
# 7  <|> mapwhile(other->8)[t5] lK
# 8      <$> gvsv(*_) s
# 9      <1> lc[t2] sK/1
# a      <$> const(IV 1) s
#            goto 7
# b  <0> pushmark s
# c  <$> gv(*hash) s
# d  <1> rv2hv lKRM*/1
# e  <2> aassign[t6] KS/COM_AGG
# f  <1> leavesub[1 ref] K/REFC,1
EONT_EONT


=for gentest

# chunk: %hash = map {  lc($_), 1  } @@array;  # as does this.

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{%hash = map { lc($_), 1 } @@array; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 476 (eval 10):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*array] s
# 5  <1> rv2av[t6] lKM/1
# 6  <@@> mapstart lK
# 7  <|> mapwhile(other->8)[t8] lK
# 8      <#> gvsv[*_] s
# 9      <1> lc[t4] sK/1
# a      <$> const[IV 1] s
#            goto 7
# b  <0> pushmark s
# c  <#> gv[*hash] s
# d  <1> rv2hv lKRM*/1
# e  <2> aassign[t9] KS/COM_AGG
# f  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 589 (eval 26):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*array) s
# 5  <1> rv2av[t3] lKM/1
# 6  <@@> mapstart lK
# 7  <|> mapwhile(other->8)[t4] lK
# 8      <$> gvsv(*_) s
# 9      <1> lc[t2] sK/1
# a      <$> const(IV 1) s
#            goto 7
# b  <0> pushmark s
# c  <$> gv(*hash) s
# d  <1> rv2hv lKRM*/1
# e  <2> aassign[t5] KS/COM_AGG
# f  <1> leavesub[1 ref] K/REFC,1
EONT_EONT


=for gentest

# chunk: %hash = map +( lc($_), 1 ), @@array;  # this is EXPR and works!

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{%hash = map +( lc($_), 1 ), @@array; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 475 (eval 10):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*array] s
# 5  <1> rv2av[t6] lKM/1
# 6  <@@> mapstart lK
# 7  <|> mapwhile(other->8)[t7] lK
# 8      <#> gvsv[*_] s
# 9      <1> lc[t4] sK/1
# a      <$> const[IV 1] s
#            goto 7
# b  <0> pushmark s
# c  <#> gv[*hash] s
# d  <1> rv2hv lKRM*/1
# e  <2> aassign[t8] KS/COM_AGG
# f  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 593 (eval 28):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*array) s
# 5  <1> rv2av[t3] lKM/1
# 6  <@@> mapstart lK
# 7  <|> mapwhile(other->8)[t4] lK
# 8      <$> gvsv(*_) s
# 9      <1> lc[t2] sK/1
# a      <$> const(IV 1) s
#            goto 7
# b  <0> pushmark s
# c  <$> gv(*hash) s
# d  <1> rv2hv lKRM*/1
# e  <2> aassign[t5] KS/COM_AGG
# f  <1> leavesub[1 ref] K/REFC,1
EONT_EONT


=for gentest

# chunk: %hash = map  ( lc($_), 1 ), @@array;  # evaluates to (1, @@array)

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{%hash = map ( lc($_), 1 ), @@array; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 475 (eval 10):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <0> pushmark s
# 5  <$> const[IV 1] sM
# 6  <@@> mapstart lK
# 7  <|> mapwhile(other->8)[t5] lK
# 8      <#> gvsv[*_] s
# 9      <1> lc[t4] sK/1
#            goto 7
# a  <0> pushmark s
# b  <#> gv[*hash] s
# c  <1> rv2hv lKRM*/1
# d  <2> aassign[t6] KS/COM_AGG
# e  <#> gv[*array] s
# f  <1> rv2av[t8] K/1
# g  <@@> list K
# h  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 597 (eval 30):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <0> pushmark s
# 5  <$> const(IV 1) sM
# 6  <@@> mapstart lK
# 7  <|> mapwhile(other->8)[t3] lK
# 8      <$> gvsv(*_) s
# 9      <1> lc[t2] sK/1
#            goto 7
# a  <0> pushmark s
# b  <$> gv(*hash) s
# c  <1> rv2hv lKRM*/1
# d  <2> aassign[t4] KS/COM_AGG
# e  <$> gv(*array) s
# f  <1> rv2av[t5] K/1
# g  <@@> list K
# h  <1> leavesub[1 ref] K/REFC,1
EONT_EONT


=for gentest

# chunk: @@hashes = map +{ lc($_), 1 }, @@array # EXPR, so needs , at end

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{@@hashes = map +{ lc($_), 1 }, @@array },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 475 (eval 10):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*array] s
# 5  <1> rv2av[t6] lKM/1
# 6  <@@> mapstart lK
# 7  <|> mapwhile(other->8)[t7] lK
# 8      <0> pushmark s
# 9      <#> gvsv[*_] s
# a      <1> lc[t4] sK/1
# b      <$> const[IV 1] s
# c      <@@> anonhash sK*/1
#            goto 7
# d  <0> pushmark s
# e  <#> gv[*hashes] s
# f  <1> rv2av[t2] lKRM*/1
# g  <2> aassign[t8] KS/COM_AGG
# h  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 601 (eval 32):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*array) s
# 5  <1> rv2av[t3] lKM/1
# 6  <@@> mapstart lK
# 7  <|> mapwhile(other->8)[t4] lK
# 8      <0> pushmark s
# 9      <$> gvsv(*_) s
# a      <1> lc[t2] sK/1
# b      <$> const(IV 1) s
# c      <@@> anonhash sK*/1
#            goto 7
# d  <0> pushmark s
# e  <$> gv(*hashes) s
# f  <1> rv2av[t1] lKRM*/1
# g  <2> aassign[t5] KS/COM_AGG
# h  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
@


1.1
log
@Initial revision
@
text
@d4 1
a4 2
    chdir q(t);
    @@INC = qw(../lib ../ext/B/t);
a13 5
    if ($] < 5.009) {
        print "1..0 # Skip -- TODO - provide golden result regexps for 5.8\n";
        exit 0;
    }
   require q(./test.pl);
d16 6
a21 1
plan tests => 9;
d23 7
d62 1
a62 1
# d  <2> aassign[t9] KS/COMMON
d78 1
a78 1
# d  <2> aassign[t6] KS/COMMON
d93 1
a93 1
# 1  <;> nextstate(main 476 (eval 10):1) v
d98 1
a98 1
# 6  <@@> mapstart lK*
d101 1
a101 1
# 9      <;> nextstate(main 475 (eval 10):1) v
d103 11
a113 13
# b      <0> pushmark s
# c      <#> gvsv[*_] s
# d      <#> gv[*getkey] s/EARLYCV
# e      <1> entersub[t5] lKS/TARG,1
# f      <#> gvsv[*_] s
# g      <@@> list lK
# h      <@@> leave lKP
#            goto 7
# i  <0> pushmark s
# j  <#> gv[*hash] s
# k  <1> rv2hv[t2] lKRM*/1
# l  <2> aassign[t10] KS/COMMON
# m  <1> leavesub[1 ref] K/REFC,1
d115 1
a115 1
# 1  <;> nextstate(main 560 (eval 15):1) v
d120 1
a120 1
# 6  <@@> mapstart lK*
d123 1
a123 1
# 9      <;> nextstate(main 559 (eval 15):1) v
d125 11
a135 13
# b      <0> pushmark s
# c      <$> gvsv(*_) s
# d      <$> gv(*getkey) s/EARLYCV
# e      <1> entersub[t2] lKS/TARG,1
# f      <$> gvsv(*_) s
# g      <@@> list lK
# h      <@@> leave lKP
#            goto 7
# i  <0> pushmark s
# j  <$> gv(*hash) s
# k  <1> rv2hv[t1] lKRM*/1
# l  <2> aassign[t5] KS/COMMON
# m  <1> leavesub[1 ref] K/REFC,1
d154 1
a154 1
# 1  <;> nextstate(main 478 (eval 10):1) v
d160 1
a160 1
# 7  <1> rv2hv[t2] lKRM*/1
d162 1
a162 1
# 9  <;> nextstate(main 476 (eval 10):1) v
d168 1
a168 1
# f  <{> enteriter(next->q last->t redo->g) lKS
d171 1
a171 1
# g      <;> nextstate(main 475 (eval 10):1) v
d178 1
a178 1
# n      <1> entersub[t10] sKS/TARG,1
d183 1
a183 1
# t  <2> leaveloop K/2
d187 1
a187 1
# 1  <;> nextstate(main 562 (eval 15):1) v
d193 1
a193 1
# 7  <1> rv2hv[t1] lKRM*/1
d195 1
a195 1
# 9  <;> nextstate(main 560 (eval 15):1) v
d201 1
a201 1
# f  <{> enteriter(next->q last->t redo->g) lKS
d204 1
a204 1
# g      <;> nextstate(main 559 (eval 15):1) v
d211 1
a211 1
# n      <1> entersub[t4] sKS/TARG,1
d216 1
a216 1
# t  <2> leaveloop K/2
d238 1
a238 1
# 6  <@@> mapstart lK*
d240 9
a248 13
# 8      <0> pushmark s
# 9      <#> gvsv[*_] s
# a      <1> lc[t4] sK/1
# b      <@@> stringify[t5] sK/1
# c      <$> const[IV 1] s
# d      <@@> list lK
# -      <@@> scope lK
#            goto 7
# e  <0> pushmark s
# f  <#> gv[*hash] s
# g  <1> rv2hv[t2] lKRM*/1
# h  <2> aassign[t10] KS/COMMON
# i  <1> leavesub[1 ref] K/REFC,1
d255 1
a255 1
# 6  <@@> mapstart lK*
d257 9
a265 13
# 8      <0> pushmark s
# 9      <$> gvsv(*_) s
# a      <1> lc[t2] sK/1
# b      <@@> stringify[t3] sK/1
# c      <$> const(IV 1) s
# d      <@@> list lK
# -      <@@> scope lK
#            goto 7
# e  <0> pushmark s
# f  <$> gv(*hash) s
# g  <1> rv2hv[t1] lKRM*/1
# h  <2> aassign[t6] KS/COMMON
# i  <1> leavesub[1 ref] K/REFC,1
d284 1
a284 1
# 6  <@@> mapstart lK*
d286 9
a294 13
# 8      <0> pushmark s
# 9      <#> gvsv[*_] s
# a      <1> lc[t4] sK/1
# b      <@@> stringify[t5] sK/1
# c      <$> const[IV 1] s
# d      <@@> list lKP
# -      <@@> scope lK
#            goto 7
# e  <0> pushmark s
# f  <#> gv[*hash] s
# g  <1> rv2hv[t2] lKRM*/1
# h  <2> aassign[t10] KS/COMMON
# i  <1> leavesub[1 ref] K/REFC,1
d301 1
a301 1
# 6  <@@> mapstart lK*
d303 9
a311 13
# 8      <0> pushmark s
# 9      <$> gvsv(*_) s
# a      <1> lc[t2] sK/1
# b      <@@> stringify[t3] sK/1
# c      <$> const(IV 1) s
# d      <@@> list lKP
# -      <@@> scope lK
#            goto 7
# e  <0> pushmark s
# f  <$> gv(*hash) s
# g  <1> rv2hv[t1] lKRM*/1
# h  <2> aassign[t6] KS/COMMON
# i  <1> leavesub[1 ref] K/REFC,1
d330 1
a330 1
# 6  <@@> mapstart lK*
d332 3
a334 6
# 8      <0> pushmark s
# 9      <#> gvsv[*_] s
# a      <1> lc[t4] sK/1
# b      <$> const[IV 1] s
# c      <@@> list lK
# -      <@@> scope lK
d336 5
a340 5
# d  <0> pushmark s
# e  <#> gv[*hash] s
# f  <1> rv2hv[t2] lKRM*/1
# g  <2> aassign[t9] KS/COMMON
# h  <1> leavesub[1 ref] K/REFC,1
d347 1
a347 1
# 6  <@@> mapstart lK*
d349 3
a351 6
# 8      <0> pushmark s
# 9      <$> gvsv(*_) s
# a      <1> lc[t2] sK/1
# b      <$> const(IV 1) s
# c      <@@> list lK
# -      <@@> scope lK
d353 5
a357 5
# d  <0> pushmark s
# e  <$> gv(*hash) s
# f  <1> rv2hv[t1] lKRM*/1
# g  <2> aassign[t5] KS/COMMON
# h  <1> leavesub[1 ref] K/REFC,1
d378 3
a380 5
# 8      <0> pushmark s
# 9      <#> gvsv[*_] s
# a      <1> lc[t4] sK/1
# b      <$> const[IV 1] s
# c      <@@> list lKP
d382 5
a386 5
# d  <0> pushmark s
# e  <#> gv[*hash] s
# f  <1> rv2hv[t2] lKRM*/1
# g  <2> aassign[t8] KS/COMMON
# h  <1> leavesub[1 ref] K/REFC,1
d395 3
a397 5
# 8      <0> pushmark s
# 9      <$> gvsv(*_) s
# a      <1> lc[t2] sK/1
# b      <$> const(IV 1) s
# c      <@@> list lKP
d399 5
a403 5
# d  <0> pushmark s
# e  <$> gv(*hash) s
# f  <1> rv2hv[t1] lKRM*/1
# g  <2> aassign[t5] KS/COMMON
# h  <1> leavesub[1 ref] K/REFC,1
d429 2
a430 2
# c  <1> rv2hv[t2] lKRM*/1
# d  <2> aassign[t6] KS/COMMON
d448 2
a449 2
# c  <1> rv2hv[t1] lKRM*/1
# d  <2> aassign[t4] KS/COMMON
d478 1
a478 2
# c      <@@> anonhash sKRM/1
# d      <1> srefgen sK/1
d480 5
a484 5
# e  <0> pushmark s
# f  <#> gv[*hashes] s
# g  <1> rv2av[t2] lKRM*/1
# h  <2> aassign[t8] KS/COMMON
# i  <1> leavesub[1 ref] K/REFC,1
d497 1
a497 2
# c      <@@> anonhash sKRM/1
# d      <1> srefgen sK/1
d499 5
a503 5
# e  <0> pushmark s
# f  <$> gv(*hashes) s
# g  <1> rv2av[t1] lKRM*/1
# h  <2> aassign[t5] KS/COMMON
# i  <1> leavesub[1 ref] K/REFC,1
@


1.1.1.1
log
@perl 5.8.6 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.8 import
@
text
@d4 2
a5 7
    if ($ENV{PERL_CORE}){
	chdir('t') if -d 't';
	@@INC = ('.', '../lib', '../ext/B/t');
    } else {
	unshift @@INC, 't';
	push @@INC, "../../t";
    }
d15 5
a19 1
    # require q(test.pl); # now done by OptreeCheck
a23 12

=head1 f_map.t

Code test snippets here are adapted from `perldoc -f map`

Due to a bleadperl optimization (Dave Mitchell, circa may 04), the
(map|grep)(start|while) opcodes have different flags in 5.9, their
private flags /1, /2 are gone in blead (for the cases covered)

When the optree stuff was integrated into 5.8.6, these tests failed,
and were todo'd.  Theyre now done, by version-specific tweaking in
mkCheckRex(), therefore the skip is removed too.
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d100 1
a100 1
# 1  <;> nextstate(main 476 (eval 10):1) v:{
d108 1
a108 1
# 9      <;> nextstate(main 475 (eval 10):1) v:{
d124 1
a124 1
# 1  <;> nextstate(main 560 (eval 15):1) v:{
d132 1
a132 1
# 9      <;> nextstate(main 559 (eval 15):1) v:{
d165 1
a165 1
# 1  <;> nextstate(main 478 (eval 10):1) v:{
d173 1
a173 1
# 9  <;> nextstate(main 476 (eval 10):1) v:{
d179 1
a179 1
# f  <{> enteriter(next->q last->t redo->g) lKS/8
d182 1
a182 1
# g      <;> nextstate(main 475 (eval 10):1) v:{
d198 1
a198 1
# 1  <;> nextstate(main 562 (eval 15):1) v:{
d206 1
a206 1
# 9  <;> nextstate(main 560 (eval 15):1) v:{
d212 1
a212 1
# f  <{> enteriter(next->q last->t redo->g) lKS/8
d215 1
a215 1
# g      <;> nextstate(main 559 (eval 15):1) v:{
d515 2
a516 1
# c      <@@> anonhash sK*/1
d518 5
a522 5
# d  <0> pushmark s
# e  <#> gv[*hashes] s
# f  <1> rv2av[t2] lKRM*/1
# g  <2> aassign[t8] KS/COMMON
# h  <1> leavesub[1 ref] K/REFC,1
d535 2
a536 1
# c      <@@> anonhash sK*/1
d538 5
a542 5
# d  <0> pushmark s
# e  <$> gv(*hashes) s
# f  <1> rv2av[t1] lKRM*/1
# g  <2> aassign[t5] KS/COMMON
# h  <1> leavesub[1 ref] K/REFC,1
@


1.1.1.4
log
@Perl 5.12.2 from CPAN
@
text
@d4 7
a10 1
    unshift @@INC, 't';
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d14 1
d17 1
a17 1
plan tests => 18;
d29 1
a29 1
and were todo'd.  They're now done, by version-specific tweaking in
d107 1
a107 1
# e      <1> entersub[t5] lKS/TARG
d131 1
a131 1
# e      <1> entersub[t2] lKS/TARG
d183 1
a183 1
# n      <1> entersub[t10] sKS/TARG
d188 1
a188 1
# t  <2> leaveloop KP/2
d216 1
a216 1
# n      <1> entersub[t4] sKS/TARG
d221 1
a221 1
# t  <2> leaveloop KP/2
@


1.1.1.6
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d98 1
a98 2
# 6  <@@> mapstart lK*              < 5.017002
# 6  <@@> mapstart lK               >=5.017002
d122 1
a122 2
# 6  <@@> mapstart lK*              < 5.017002
# 6  <@@> mapstart lK               >=5.017002
d242 1
a242 2
# 6  <@@> mapstart lK*              < 5.017002
# 6  <@@> mapstart lK               >=5.017002
d250 1
a250 1
# -      <@@> scope lK              < 5.017002
d263 1
a263 2
# 6  <@@> mapstart lK*              < 5.017002
# 6  <@@> mapstart lK               >=5.017002
d271 1
a271 1
# -      <@@> scope lK              < 5.017002
d296 1
a296 2
# 6  <@@> mapstart lK*              < 5.017002
# 6  <@@> mapstart lK               >=5.017002
d304 1
a304 1
# -      <@@> scope lK              < 5.017002
d317 1
a317 2
# 6  <@@> mapstart lK*              < 5.017002
# 6  <@@> mapstart lK               >=5.017002
d325 1
a325 1
# -      <@@> scope lK              < 5.017002
d350 1
a350 2
# 6  <@@> mapstart lK*              < 5.017002
# 6  <@@> mapstart lK               >=5.017002
d357 1
a357 1
# -      <@@> scope lK              < 5.017002
d370 1
a370 2
# 6  <@@> mapstart lK*              < 5.017002
# 6  <@@> mapstart lK               >=5.017002
d377 1
a377 1
# -      <@@> scope lK              < 5.017002
@


1.1.1.7
log
@Import perl-5.20.1
@
text
@d104 13
a116 12
# b      <#> gvsv[*_] s
# c      <#> gv[*getkey] s/EARLYCV
# d      <1> entersub[t5] lKS/TARG
# e      <#> gvsv[*_] s
# f      <@@> leave lKP
#            goto 7
# g  <0> pushmark s
# h  <#> gv[*hash] s
# i  <1> rv2hv[t2] lKRM*/1         < 5.019006
# i  <1> rv2hv lKRM*/1             >=5.019006
# j  <2> aassign[t10] KS/COMMON
# k  <1> leavesub[1 ref] K/REFC,1
d129 13
a141 12
# b      <$> gvsv(*_) s
# c      <$> gv(*getkey) s/EARLYCV
# d      <1> entersub[t2] lKS/TARG
# e      <$> gvsv(*_) s
# f      <@@> leave lKP
#            goto 7
# g  <0> pushmark s
# h  <$> gv(*hash) s
# i  <1> rv2hv[t1] lKRM*/1         < 5.019006
# i  <1> rv2hv lKRM*/1             >=5.019006
# j  <2> aassign[t5] KS/COMMON
# k  <1> leavesub[1 ref] K/REFC,1
d166 1
a166 2
# 7  <1> rv2hv[t2] lKRM*/1         < 5.019006
# 7  <1> rv2hv lKRM*/1             >=5.019006
d199 1
a199 2
# 7  <1> rv2hv[t1] lKRM*/1         < 5.019006
# 7  <1> rv2hv lKRM*/1             >=5.019006
d257 1
a257 2
# g  <1> rv2hv[t2] lKRM*/1         < 5.019006
# g  <1> rv2hv lKRM*/1             >=5.019006
d279 1
a279 2
# g  <1> rv2hv[t1] lKRM*/1         < 5.019006
# g  <1> rv2hv lKRM*/1             >=5.019006
d313 1
a313 2
# g  <1> rv2hv[t2] lKRM*/1         < 5.019006
# g  <1> rv2hv lKRM*/1             >=5.019006
d335 1
a335 2
# g  <1> rv2hv[t1] lKRM*/1         < 5.019006
# g  <1> rv2hv lKRM*/1             >=5.019006
d368 1
a368 2
# f  <1> rv2hv[t2] lKRM*/1         < 5.019006
# f  <1> rv2hv lKRM*/1             >=5.019006
d389 1
a389 2
# f  <1> rv2hv[t1] lKRM*/1         < 5.019006
# f  <1> rv2hv lKRM*/1             >=5.019006
d420 1
a420 2
# f  <1> rv2hv[t2] lKRM*/1         < 5.019006
# f  <1> rv2hv lKRM*/1             >=5.019006
d439 1
a439 2
# f  <1> rv2hv[t1] lKRM*/1         < 5.019006
# f  <1> rv2hv lKRM*/1             >=5.019006
d467 1
a467 2
# c  <1> rv2hv[t2] lKRM*/1         < 5.019006
# c  <1> rv2hv lKRM*/1             >=5.019006
d486 1
a486 2
# c  <1> rv2hv[t1] lKRM*/1         < 5.019006
# c  <1> rv2hv lKRM*/1             >=5.019006
@


