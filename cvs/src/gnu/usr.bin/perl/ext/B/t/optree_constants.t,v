head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.6.0.8
	OPENBSD_6_1_BASE:1.1.1.6
	OPENBSD_6_0:1.1.1.6.0.10
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.4
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.6
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.4
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.4.0.6
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.2
	OPENBSD_5_4_BASE:1.1.1.4
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.1.1.3.0.10
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.8
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.6
	OPENBSD_5_0:1.1.1.3.0.4
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.2
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.2.0.4
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.2
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2008.09.29.17.18.14;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.29.17.18.14;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.10.12.18.11.11;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.09.24.14.48.52;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.03.25.20.08.43;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@#!perl

BEGIN {
    if ($ENV{PERL_CORE}) {
	chdir('t') if -d 't';
	@@INC = ('.', '../lib', '../ext/B/t');
    } else {
	unshift @@INC, 't';
	push @@INC, "../../t";
    }
    require Config;
    if (($Config::Config{'extensions'} !~ /\bB\b/) ){
        print "1..0 # Skip -- Perl configured without B module\n";
        exit 0;
    }
    # require 'test.pl'; # now done by OptreeCheck
}

use OptreeCheck;	# ALSO DOES @@ARGV HANDLING !!!!!!
use Config;

my $tests = 30;
plan tests => $tests;
SKIP: {
skip "no perlio in this build", $tests unless $Config::Config{useperlio};

#################################

use constant {		# see also t/op/gv.t line 282
    myaref	=> [ 1,2,3 ],
    myfl	=> 1.414213,
    myglob	=> \*STDIN,
    myhref	=> { a	=> 1 },
    myint	=> 42,
    myrex	=> qr/foo/,
    mystr	=> 'hithere',
    mysub	=> \&ok,
    myundef	=> undef,
    myunsub	=> \&nosuch,
};

sub myyes() { 1==1 }
sub myno () { return 1!=1 }
sub pi () { 3.14159 };

my $want = {	# expected types, how value renders in-line, todos (maybe)
    mystr	=> [ 'PV', '"'.mystr.'"' ],
    myhref	=> [ 'RV', '\\\\HASH'],
    pi		=> [ 'NV', pi ],
    myglob	=> [ 'RV', '\\\\' ],
    mysub	=> [ 'RV', '\\\\' ],
    myunsub	=> [ 'RV', '\\\\' ],
    # these are not inlined, at least not per BC::Concise
    #myyes	=> [ 'RV', ],
    #myno	=> [ 'RV', ],
    $] > 5.009 ? (
    myaref	=> [ 'RV', '\\\\' ],
    myfl	=> [ 'NV', myfl ],
    myint	=> [ 'IV', myint ],
    myrex	=> [ 'RV', '\\\\' ],
    myundef	=> [ 'NULL', ],
    ) : (
    myaref	=> [ 'PVIV', '' ],
    myfl	=> [ 'PVNV', myfl ],
    myint	=> [ 'PVIV', myint ],
    myrex	=> [ 'PVNV', '' ],
    myundef	=> [ 'PVIV', ],
    )
};

use constant WEEKDAYS
    => qw ( Sunday Monday Tuesday Wednesday Thursday Friday Saturday );


$::{napier} = \2.71828;	# counter-example (doesn't get optimized).
eval "sub napier ();";


# should be able to undefine constant::import here ???
INIT { 
    # eval 'sub constant::import () {}';
    # undef *constant::import::{CODE};
};

#################################
pass("RENDER CONSTANT SUBS RETURNING SCALARS");

for $func (sort keys %$want) {
    # no strict 'refs';	# why not needed ?
    checkOptree ( name      => "$func() as a coderef",
		  code      => \&{$func},
		  noanchors => 1,
		  expect    => <<EOT_EOT, expect_nt => <<EONT_EONT);
 is a constant sub, optimized to a $want->{$func}[0]
EOT_EOT
 is a constant sub, optimized to a $want->{$func}[0]
EONT_EONT

}

pass("RENDER CALLS TO THOSE CONSTANT SUBS");

for $func (sort keys %$want) {
    # print "# doing $func\n";
    checkOptree ( name    => "call $func",
		  code    => "$func",
		  ($want->{$func}[2]) ? ( todo => $want->{$func}[2]) : (),
		  bc_opts => '-nobanner',
		  expect  => <<EOT_EOT, expect_nt => <<EONT_EONT);
3  <1> leavesub[2 refs] K/REFC,1 ->(end)
-     <\@@> lineseq KP ->3
1        <;> dbstate(main 833 (eval 44):1) v ->2
2        <\$> const[$want->{$func}[0] $want->{$func}[1]] s ->3
EOT_EOT
3  <1> leavesub[2 refs] K/REFC,1 ->(end)
-     <\@@> lineseq KP ->3
1        <;> dbstate(main 833 (eval 44):1) v ->2
2        <\$> const($want->{$func}[0] $want->{$func}[1]) s ->3
EONT_EONT

}

##############
pass("MORE TESTS");

checkOptree ( name	=> 'myyes() as coderef',
	      code	=> sub () { 1==1 },
	      noanchors => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
 is a constant sub, optimized to a SPECIAL
EOT_EOT
 is a constant sub, optimized to a SPECIAL
EONT_EONT


checkOptree ( name	=> 'myyes() as coderef',
	      prog	=> 'sub a() { 1==1 }; print a',
	      noanchors => 1,
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 6  <@@> leave[1 ref] vKP/REFC ->(end)
# 1     <0> enter ->2
# 2     <;> nextstate(main 2 -e:1) v:>,<,%,{ ->3
# 5     <@@> print vK ->6
# 3        <0> pushmark s ->4
# 4        <$> const[SPECIAL sv_yes] s ->5
EOT_EOT
# 6  <@@> leave[1 ref] vKP/REFC ->(end)
# 1     <0> enter ->2
# 2     <;> nextstate(main 2 -e:1) v:>,<,%,{ ->3
# 5     <@@> print vK ->6
# 3        <0> pushmark s ->4
# 4        <$> const(SPECIAL sv_yes) s ->5
EONT_EONT


# Need to do this as a prog, not code, as only the first constant to use
# PL_sv_no actually gets to use the real thing - every one following is
# copied.
checkOptree ( name	=> 'myno() as coderef',
	      prog	=> 'sub a() { 1!=1 }; print a',
	      noanchors => 1,
	      strip_open_hints => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 6  <@@> leave[1 ref] vKP/REFC ->(end)
# 1     <0> enter ->2
# 2     <;> nextstate(main 2 -e:1) v:>,<,%,{ ->3
# 5     <@@> print vK ->6
# 3        <0> pushmark s ->4
# 4        <$> const[SPECIAL sv_no] s ->5
EOT_EOT
# 6  <@@> leave[1 ref] vKP/REFC ->(end)
# 1     <0> enter ->2
# 2     <;> nextstate(main 2 -e:1) v:>,<,%,{ ->3
# 5     <@@> print vK ->6
# 3        <0> pushmark s ->4
# 4        <$> const(SPECIAL sv_no) s ->5
EONT_EONT


my ($expect, $expect_nt) = (<<'EOT_EOT', <<'EONT_EONT');
# 3  <1> leavesub[2 refs] K/REFC,1 ->(end)
# -     <@@> lineseq K ->3
# 1        <;> nextstate(constant 61 constant.pm:118) v:*,& ->2
# 2        <0> padav[@@list:FAKE:m:96] ->3
EOT_EOT
# 3  <1> leavesub[2 refs] K/REFC,1 ->(end)
# -     <@@> lineseq K ->3
# 1        <;> nextstate(constant 61 constant.pm:118) v:*,& ->2
# 2        <0> padav[@@list:FAKE:m:71] ->3
EONT_EONT

if($] < 5.009) {
    # 5.8.x doesn't add the m flag to padav
    s/FAKE:m:\d+/FAKE/ foreach ($expect, $expect_nt);
}

checkOptree ( name	=> 'constant sub returning list',
	      code	=> \&WEEKDAYS,
	      noanchors => 1,
	      expect => $expect, expect_nt => $expect_nt);


sub printem {
    printf "myint %d mystr %s myfl %f pi %f\n"
	, myint, mystr, myfl, pi;
}

my ($expect, $expect_nt) = (<<'EOT_EOT', <<'EONT_EONT');
# 9  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->9
# 1        <;> nextstate(main 635 optree_constants.t:163) v:>,<,% ->2
# 8        <@@> prtf sK ->9
# 2           <0> pushmark s ->3
# 3           <$> const[PV "myint %d mystr %s myfl %f pi %f\n"] s ->4
# 4           <$> const[IV 42] s ->5
# 5           <$> const[PV "hithere"] s ->6
# 6           <$> const[NV 1.414213] s ->7
# 7           <$> const[NV 3.14159] s ->8
EOT_EOT
# 9  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->9
# 1        <;> nextstate(main 635 optree_constants.t:163) v:>,<,% ->2
# 8        <@@> prtf sK ->9
# 2           <0> pushmark s ->3
# 3           <$> const(PV "myint %d mystr %s myfl %f pi %f\n") s ->4
# 4           <$> const(IV 42) s ->5
# 5           <$> const(PV "hithere") s ->6
# 6           <$> const(NV 1.414213) s ->7
# 7           <$> const(NV 3.14159) s ->8
EONT_EONT

if($] < 5.009) {
    # 5.8.x's use constant has larger types
    foreach ($expect, $expect_nt) {
	s/IV 42/PV$&/;
	s/NV 1.41/PV$&/;
    }
}

checkOptree ( name	=> 'call many in a print statement',
	      code	=> \&printem,
	      strip_open_hints => 1,
	      expect => $expect, expect_nt => $expect_nt);

} #skip

__END__

=head NB

Optimized constant subs are stored as bare scalars in the stash
(package hash), which formerly held only GVs (typeglobs).

But you cant create them manually - you cant assign a scalar to a
stash element, and expect it to work like a constant-sub, even if you
provide a prototype.

This is a feature; alternative is too much action-at-a-distance.  The
following test demonstrates - napier is not seen as a function at all,
much less an optimized one.

=cut

checkOptree ( name	=> 'not evertnapier',
	      code	=> \&napier,
	      noanchors => 1,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
 has no START
EOT_EOT
 has no START
EONT_EONT


@


1.1.1.1
log
@import perl 5.10.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.1
@
text
@a45 2
my $RV_class = $] >= 5.011 ? 'IV' : 'RV';

d48 1
a48 1
    myhref	=> [ $RV_class, '\\\\HASH'],
d50 3
a52 3
    myglob	=> [ $RV_class, '\\\\' ],
    mysub	=> [ $RV_class, '\\\\' ],
    myunsub	=> [ $RV_class, '\\\\' ],
d54 2
a55 2
    #myyes	=> [ $RV_class, ],
    #myno	=> [ $RV_class, ],
d57 1
a57 1
    myaref	=> [ $RV_class, '\\\\' ],
d60 1
a60 5
    $] >= 5.011 ? (
    myrex	=> [ $RV_class, '\\\\"\\(?-xism:Foo\\)"' ],
    ) : (
    myrex	=> [ $RV_class, '\\\\' ],
    ),
@


1.1.1.3
log
@Perl 5.12.2 from CPAN
@
text
@d4 7
a10 1
    unshift @@INC, 't';
@


1.1.1.4
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d10 1
a10 4
    if (!$Config::Config{useperlio}) {
        print "1..0 # Skip -- need perlio to walk the optree\n";
        exit 0;
    }
d16 4
a19 1
plan tests => 67;
d57 1
a57 1
    myrex	=> [ $RV_class, '\\\\"\\(?^:Foo\\)"' ],
d113 1
a113 1
2        <\$> const[$want->{$func}[0] $want->{$func}[1]] s* ->3
d118 1
a118 1
2        <\$> const($want->{$func}[0] $want->{$func}[1]) s* ->3
d146 1
a146 1
# 4        <$> const[SPECIAL sv_yes] s* ->5
d153 1
a153 1
# 4        <$> const(SPECIAL sv_yes) s* ->5
d170 1
a170 1
# 4        <$> const[SPECIAL sv_no] s* ->5
d177 1
a177 1
# 4        <$> const(SPECIAL sv_no) s* ->5
d184 1
a184 1
# 1        <;> nextstate(constant 61 constant.pm:118) v:*,&,x*,x&,x$ ->2
d189 1
a189 1
# 1        <;> nextstate(constant 61 constant.pm:118) v:*,&,x*,x&,x$ ->2
d214 6
a219 6
# 2           <0> pushmark sM ->3
# 3           <$> const[PV "myint %d mystr %s myfl %f pi %f\n"] sM ->4
# 4           <$> const[IV 42] sM* ->5
# 5           <$> const[PV "hithere"] sM* ->6
# 6           <$> const[NV 1.414213] sM* ->7
# 7           <$> const[NV 3.14159] sM* ->8
d225 6
a230 6
# 2           <0> pushmark sM ->3
# 3           <$> const(PV "myint %d mystr %s myfl %f pi %f\n") sM ->4
# 4           <$> const(IV 42) sM* ->5
# 5           <$> const(PV "hithere") sM* ->6
# 6           <$> const(NV 1.414213) sM* ->7
# 7           <$> const(NV 3.14159) sM* ->8
a232 3
if($] < 5.015) {
    s/M(?=\*? ->)//g for $expect, $expect_nt;
}
d246 1
a246 150
# test constant expression folding

checkOptree ( name	=> 'arithmetic constant folding in print',
	      code	=> 'print 1+2+3',
	      strip_open_hints => 1,
	      expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 937 (eval 53):1) v ->2
# 4        <@@> print sK ->5
# 2           <0> pushmark s ->3
# 3           <$> const[IV 6] s ->4
EOT_EOT
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 937 (eval 53):1) v ->2
# 4        <@@> print sK ->5
# 2           <0> pushmark s ->3
# 3           <$> const(IV 6) s ->4
EONT_EONT

checkOptree ( name	=> 'string constant folding in print',
	      code	=> 'print "foo"."bar"',
	      strip_open_hints => 1,
	      expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 942 (eval 55):1) v ->2
# 4        <@@> print sK ->5
# 2           <0> pushmark s ->3
# 3           <$> const[PV "foobar"] s ->4
EOT_EOT
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 942 (eval 55):1) v ->2
# 4        <@@> print sK ->5
# 2           <0> pushmark s ->3
# 3           <$> const(PV "foobar") s ->4
EONT_EONT

checkOptree ( name	=> 'boolean or folding',
	      code	=> 'print "foobar" if 1 or 0',
	      strip_open_hints => 1,
	      expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 942 (eval 55):1) v ->2
# 4        <@@> print sK ->5
# 2           <0> pushmark s ->3
# 3           <$> const[PV "foobar"] s ->4
EOT_EOT
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 942 (eval 55):1) v ->2
# 4        <@@> print sK ->5
# 2           <0> pushmark s ->3
# 3           <$> const(PV "foobar") s ->4
EONT_EONT

checkOptree ( name	=> 'lc*,uc*,gt,lt,ge,le,cmp',
	      code	=> sub {
		  $s = uc('foo.').ucfirst('bar.').lc('LOW.').lcfirst('LOW');
		  print "a-lt-b" if "a" lt "b";
		  print "b-gt-a" if "b" gt "a";
		  print "a-le-b" if "a" le "b";
		  print "b-ge-a" if "b" ge "a";
		  print "b-cmp-a" if "b" cmp "a";
		  print "a-gt-b" if "a" gt "b";	# should be suppressed
	      },
	      strip_open_hints => 1,
	      expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# r  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->r
# 1        <;> nextstate(main 916 optree_constants.t:307) v:>,<,%,{ ->2
# 4        <2> sassign vKS/2 ->5
# 2           <$> const[PV "FOO.Bar.low.lOW"] s ->3
# -           <1> ex-rv2sv sKRM*/1 ->4
# 3              <#> gvsv[*s] s ->4
# 5        <;> nextstate(main 916 optree_constants.t:308) v:>,<,%,{ ->6
# 8        <@@> print vK ->9
# 6           <0> pushmark s ->7
# 7           <$> const[PV "a-lt-b"] s ->8
# 9        <;> nextstate(main 916 optree_constants.t:309) v:>,<,%,{ ->a
# c        <@@> print vK ->d
# a           <0> pushmark s ->b
# b           <$> const[PV "b-gt-a"] s ->c
# d        <;> nextstate(main 916 optree_constants.t:310) v:>,<,%,{ ->e
# g        <@@> print vK ->h
# e           <0> pushmark s ->f
# f           <$> const[PV "a-le-b"] s ->g
# h        <;> nextstate(main 916 optree_constants.t:311) v:>,<,%,{ ->i
# k        <@@> print vK ->l
# i           <0> pushmark s ->j
# j           <$> const[PV "b-ge-a"] s ->k
# l        <;> nextstate(main 916 optree_constants.t:312) v:>,<,%,{ ->m
# o        <@@> print vK ->p
# m           <0> pushmark s ->n
# n           <$> const[PV "b-cmp-a"] s ->o
# p        <;> nextstate(main 916 optree_constants.t:313) v:>,<,%,{ ->q
# q        <$> const[PVNV 0] s/SHORT ->r
EOT_EOT
# r  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->r
# 1        <;> nextstate(main 916 optree_constants.t:307) v:>,<,%,{ ->2
# 4        <2> sassign vKS/2 ->5
# 2           <$> const(PV "FOO.Bar.low.lOW") s ->3
# -           <1> ex-rv2sv sKRM*/1 ->4
# 3              <$> gvsv(*s) s ->4
# 5        <;> nextstate(main 916 optree_constants.t:308) v:>,<,%,{ ->6
# 8        <@@> print vK ->9
# 6           <0> pushmark s ->7
# 7           <$> const(PV "a-lt-b") s ->8
# 9        <;> nextstate(main 916 optree_constants.t:309) v:>,<,%,{ ->a
# c        <@@> print vK ->d
# a           <0> pushmark s ->b
# b           <$> const(PV "b-gt-a") s ->c
# d        <;> nextstate(main 916 optree_constants.t:310) v:>,<,%,{ ->e
# g        <@@> print vK ->h
# e           <0> pushmark s ->f
# f           <$> const(PV "a-le-b") s ->g
# h        <;> nextstate(main 916 optree_constants.t:311) v:>,<,%,{ ->i
# k        <@@> print vK ->l
# i           <0> pushmark s ->j
# j           <$> const(PV "b-ge-a") s ->k
# l        <;> nextstate(main 916 optree_constants.t:312) v:>,<,%,{ ->m
# o        <@@> print vK ->p
# m           <0> pushmark s ->n
# n           <$> const(PV "b-cmp-a") s ->o
# p        <;> nextstate(main 916 optree_constants.t:313) v:>,<,%,{ ->q
# q        <$> const(SPECIAL sv_no) s/SHORT ->r
EONT_EONT

checkOptree ( name	=> 'mixed constant folding, with explicit braces',
	      code	=> 'print "foo"."bar".(2+3)',
	      strip_open_hints => 1,
	      expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 977 (eval 28):1) v ->2
# 4        <@@> print sK ->5
# 2           <0> pushmark s ->3
# 3           <$> const[PV "foobar5"] s ->4
EOT_EOT
# 5  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->5
# 1        <;> nextstate(main 977 (eval 28):1) v ->2
# 4        <@@> print sK ->5
# 2           <0> pushmark s ->3
# 3           <$> const(PV "foobar5") s ->4
EONT_EONT
@


1.1.1.5
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d52 1
d62 7
d113 1
a113 2
2        <\$> const[$want->{$func}[0] $want->{$func}[1]] s* ->3      < 5.017002
2        <\$> const[$want->{$func}[0] $want->{$func}[1]] s*/FOLD ->3 >=5.017002
d118 1
a118 2
2        <\$> const($want->{$func}[0] $want->{$func}[1]) s* ->3      < 5.017002
2        <\$> const($want->{$func}[0] $want->{$func}[1]) s*/FOLD ->3 >=5.017002
d146 1
a146 2
# 4        <$> const[SPECIAL sv_yes] s* ->5         < 5.017002
# 4        <$> const[SPECIAL sv_yes] s*/FOLD ->5    >=5.017002
d153 1
a153 2
# 4        <$> const(SPECIAL sv_yes) s* ->5         < 5.017002
# 4        <$> const(SPECIAL sv_yes) s*/FOLD ->5    >=5.017002
d170 1
a170 2
# 4        <$> const[SPECIAL sv_no] s* ->5         < 5.017002
# 4        <$> const[SPECIAL sv_no] s*/FOLD ->5    >=5.017002
d177 1
a177 2
# 4        <$> const(SPECIAL sv_no) s* ->5         < 5.017002
# 4        <$> const(SPECIAL sv_no) s*/FOLD ->5    >=5.017002
d193 4
d215 5
a219 10
# 3           <$> const[PV "myint %d mystr %s myfl %f pi %f\n"] sM ->4 < 5.017002
# 4           <$> const[IV 42] sM* ->5          < 5.017002
# 5           <$> const[PV "hithere"] sM* ->6   < 5.017002
# 6           <$> const[NV 1.414213] sM* ->7    < 5.017002
# 7           <$> const[NV 3.14159] sM* ->8     < 5.017002
# 3           <$> const[PV "myint %d mystr %s myfl %f pi %f\n"] sM/FOLD ->4 >= 5.017002
# 4           <$> const[IV 42] sM*/FOLD ->5          >=5.017002 
# 5           <$> const[PV "hithere"] sM*/FOLD ->6   >=5.017002
# 6           <$> const[NV 1.414213] sM*/FOLD ->7    >=5.017002
# 7           <$> const[NV 3.14159] sM*/FOLD ->8     >=5.017002
d226 5
a230 10
# 3           <$> const(PV "myint %d mystr %s myfl %f pi %f\n") sM ->4 < 5.017002
# 4           <$> const(IV 42) sM* ->5          < 5.017002
# 5           <$> const(PV "hithere") sM* ->6   < 5.017002
# 6           <$> const(NV 1.414213) sM* ->7    < 5.017002
# 7           <$> const(NV 3.14159) sM* ->8     < 5.017002
# 3           <$> const(PV "myint %d mystr %s myfl %f pi %f\n") sM/FOLD ->4 >= 5.017002
# 4           <$> const(IV 42) sM*/FOLD ->5          >=5.017002 
# 5           <$> const(PV "hithere") sM*/FOLD ->6   >=5.017002
# 6           <$> const(NV 1.414213) sM*/FOLD ->7    >=5.017002
# 7           <$> const(NV 3.14159) sM*/FOLD ->8     >=5.017002
d236 7
d260 1
a260 2
# 3           <$> const[IV 6] s ->4      < 5.017002
# 3           <$> const[IV 6] s/FOLD ->4 >=5.017002
d267 1
a267 2
# 3           <$> const(IV 6) s ->4      < 5.017002
# 3           <$> const(IV 6) s/FOLD ->4 >=5.017002
d279 1
a279 2
# 3           <$> const[PV "foobar"] s ->4      < 5.017002
# 3           <$> const[PV "foobar"] s/FOLD ->4 >=5.017002
d286 1
a286 2
# 3           <$> const(PV "foobar") s ->4      < 5.017002
# 3           <$> const(PV "foobar") s/FOLD ->4 >=5.017002
d324 1
a324 2
# 2           <$> const[PV "FOO.Bar.low.lOW"] s ->3      < 5.017002
# 2           <$> const[PV "FOO.Bar.low.lOW"] s/FOLD ->3 >=5.017002
d348 1
a348 2
# q        <$> const[PVNV 0] s/SHORT ->r      < 5.017002
# q        <$> const[PVNV 0] s/FOLD,SHORT ->r >=5.017002
d354 1
a354 2
# 2           <$> const(PV "FOO.Bar.low.lOW") s ->3      < 5.017002
# 2           <$> const(PV "FOO.Bar.low.lOW") s/FOLD ->3 >=5.017002
d378 1
a378 2
# q        <$> const(SPECIAL sv_no) s/SHORT ->r      < 5.017002
# q        <$> const(SPECIAL sv_no) s/FOLD,SHORT ->r >=5.017002
d390 1
a390 2
# 3           <$> const[PV "foobar5"] s ->4      < 5.017002
# 3           <$> const[PV "foobar5"] s/FOLD ->4 >=5.017002
d397 1
a397 2
# 3           <$> const(PV "foobar5") s ->4      < 5.017002
# 3           <$> const(PV "foobar5") s/FOLD ->4 >=5.017002
@


1.1.1.6
log
@Import perl-5.20.1
@
text
@d23 1
a23 1
use constant {		# see also t/op/gv.t line 358
d179 1
a179 4
my ($expect, $expect_nt) =
    $] >= 5.019003
	? (" is a constant sub, optimized to a AV\n") x 2
	: (<<'EOT_EOT', <<'EONT_EONT');
d209 1
a209 1
# 3           <$> const[PV "myint %d mystr %s myfl %f pi %f\n"] sM/FOLD ->4
d214 1
d225 1
a225 1
# 3           <$> const(PV "myint %d mystr %s myfl %f pi %f\n") sM/FOLD ->4
d230 1
a239 3
if($] < 5.017002 || $] >= 5.019004) {
    s|\\n"[])] sM\K/FOLD|| for $expect, $expect_nt;
}
d297 1
a297 2
# 4        <@@> print sK ->5      < 5.019004
# 4        <@@> print sK/FOLD ->5 >=5.019004
d304 1
a304 2
# 4        <@@> print sK ->5      < 5.019004
# 4        <@@> print sK/FOLD ->5 >=5.019004
d330 1
a330 2
# 8        <@@> print vK ->9      < 5.019004
# 8        <@@> print vK/FOLD ->9 >=5.019004
d334 1
a334 2
# c        <@@> print vK ->d      < 5.019004
# c        <@@> print vK/FOLD ->d >=5.019004
d338 1
a338 2
# g        <@@> print vK ->h      < 5.019004
# g        <@@> print vK/FOLD ->h >=5.019004
d342 1
a342 2
# k        <@@> print vK ->l      < 5.019004
# k        <@@> print vK/FOLD ->l >=5.019004
d346 1
a346 2
# o        <@@> print vK ->p      < 5.019004
# o        <@@> print vK/FOLD ->p >=5.019004
d351 1
a351 2
# q        <$> const[PVNV 0] s/FOLD,SHORT ->r >=5.017002 < 5.019003
# q        <$> const[SPECIAL sv_no] s/SHORT,FOLD ->r >=5.019003
d362 1
a362 2
# 8        <@@> print vK ->9      < 5.019004
# 8        <@@> print vK/FOLD ->9 >=5.019004
d366 1
a366 2
# c        <@@> print vK ->d      < 5.019004
# c        <@@> print vK/FOLD ->d >=5.019004
d370 1
a370 2
# g        <@@> print vK ->h      < 5.019004
# g        <@@> print vK/FOLD ->h >=5.019004
d374 1
a374 2
# k        <@@> print vK ->l      < 5.019004
# k        <@@> print vK/FOLD ->l >=5.019004
d378 1
a378 2
# o        <@@> print vK ->p      < 5.019004
# o        <@@> print vK/FOLD ->p >=5.019004
d383 1
a383 1
# q        <$> const(SPECIAL sv_no) s/SHORT,FOLD ->r >=5.017002
@


