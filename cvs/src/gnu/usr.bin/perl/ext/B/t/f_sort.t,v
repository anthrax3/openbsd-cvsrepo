head	1.2;
access;
symbols
	PERL_5_24_2:1.1.1.8
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.7.0.10
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.4
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.6
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.6.0.4
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.6
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.2
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.4.0.10
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.8
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.6
	OPENBSD_5_0:1.1.1.4.0.4
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.2
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.3.0.8
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.4
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.10
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.8
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.6
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.4
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.2
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.1.0.6
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.4
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.2
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.11;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.01.15.21.16.43;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.03.28.18.47.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.14;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.09.24.14.48.52;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.08.43;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	1.1.1.8;
commitid	B31cAbBIXiCqnL97;

1.1.1.8
date	2017.08.14.13.46.10;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!perl

BEGIN {
    unshift @@INC, 't';
    require Config;
    if (($Config::Config{'extensions'} !~ /\bB\b/) ){
        print "1..0 # Skip -- Perl configured without B module\n";
        exit 0;
    }
    if (!$Config::Config{useperlio}) {
        print "1..0 # Skip -- need perlio to walk the optree\n";
        exit 0;
    }
}
use OptreeCheck;
plan tests => 40;

=head1 f_sort.t

Code test snippets here are adapted from `perldoc -f map`

Due to a bleadperl optimization (Dave Mitchell, circa apr 04), the
(map|grep)(start|while) opcodes have different flags in 5.9, their
private flags /1, /2 are gone in blead (for the cases covered)

When the optree stuff was integrated into 5.8.6, these tests failed,
and were todo'd.  They're now done, by version-specific tweaking in
mkCheckRex(), therefore the skip is removed too.

=head1 Test Notes

# chunk: #!perl
#examples poached from perldoc -f sort

NOTE: name is no longer a required arg for checkOptree, as label is
synthesized out of others.  HOWEVER, if the test-code has newlines in
it, the label must be overridden by an explicit name.

This is because t/TEST is quite particular about the test output it
processes, and multi-line labels violate its 1-line-per-test
expectations.

=for gentest

# chunk: # sort lexically
@@articles = sort @@files;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{@@articles = sort @@files; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 545 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*files] s
# 5  <1> rv2av[t4] lK/1
# 6  <@@> sort lK
# 7  <0> pushmark s
# 8  <#> gv[*articles] s
# 9  <1> rv2av[t2] lKRM*/1
# a  <2> aassign[t5] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 545 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*files) s
# 5  <1> rv2av[t2] lK/1
# 6  <@@> sort lK
# 7  <0> pushmark s
# 8  <$> gv(*articles) s
# 9  <1> rv2av[t1] lKRM*/1
# a  <2> aassign[t3] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: # same thing, but with explicit sort routine
@@articles = sort {$a cmp $b} @@files;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{@@articles = sort {$a cmp $b} @@files; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 546 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*files] s
# 5  <1> rv2av[t7] lK/1
# 6  <@@> sort lK
# 7  <0> pushmark s
# 8  <#> gv[*articles] s
# 9  <1> rv2av[t2] lKRM*/1
# a  <2> aassign[t3] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 546 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*files) s
# 5  <1> rv2av[t3] lK/1
# 6  <@@> sort lK
# 7  <0> pushmark s
# 8  <$> gv(*articles) s
# 9  <1> rv2av[t1] lKRM*/1
# a  <2> aassign[t2] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: # now case-insensitively
@@articles = sort {uc($a) cmp uc($b)} @@files;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{@@articles = sort {uc($a) cmp uc($b)} @@files; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 546 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*files] s
# 5  <1> rv2av[t9] lK/1		< 5.019002
# 5  <1> rv2av[t9] lKM/1	>=5.019002
# 6  <@@> sort lKS*
# 7  <0> pushmark s
# 8  <#> gv[*articles] s
# 9  <1> rv2av[t2] lKRM*/1
# a  <2> aassign[t10] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 546 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*files) s
# 5  <1> rv2av[t5] lK/1		< 5.019002
# 5  <1> rv2av[t5] lKM/1	>=5.019002
# 6  <@@> sort lKS*
# 7  <0> pushmark s
# 8  <$> gv(*articles) s
# 9  <1> rv2av[t1] lKRM*/1
# a  <2> aassign[t6] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: # same thing in reversed order
@@articles = sort {$b cmp $a} @@files;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{@@articles = sort {$b cmp $a} @@files; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 546 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*files] s
# 5  <1> rv2av[t7] lK/1
# 6  <@@> sort lK/DESC
# 7  <0> pushmark s
# 8  <#> gv[*articles] s
# 9  <1> rv2av[t2] lKRM*/1
# a  <2> aassign[t3] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 546 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*files) s
# 5  <1> rv2av[t3] lK/1
# 6  <@@> sort lK/DESC
# 7  <0> pushmark s
# 8  <$> gv(*articles) s
# 9  <1> rv2av[t1] lKRM*/1
# a  <2> aassign[t2] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: # sort numerically ascending
@@articles = sort {$a <=> $b} @@files;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{@@articles = sort {$a <=> $b} @@files; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 546 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*files] s
# 5  <1> rv2av[t7] lK/1
# 6  <@@> sort lK/NUM
# 7  <0> pushmark s
# 8  <#> gv[*articles] s
# 9  <1> rv2av[t2] lKRM*/1
# a  <2> aassign[t3] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 546 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*files) s
# 5  <1> rv2av[t3] lK/1
# 6  <@@> sort lK/NUM
# 7  <0> pushmark s
# 8  <$> gv(*articles) s
# 9  <1> rv2av[t1] lKRM*/1
# a  <2> aassign[t2] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: # sort numerically descending
@@articles = sort {$b <=> $a} @@files;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{@@articles = sort {$b <=> $a} @@files; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 587 (eval 26):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*files] s
# 5  <1> rv2av[t7] lK/1
# 6  <@@> sort lK/DESC,NUM
# 7  <0> pushmark s
# 8  <#> gv[*articles] s
# 9  <1> rv2av[t2] lKRM*/1
# a  <2> aassign[t3] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 546 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*files) s
# 5  <1> rv2av[t3] lK/1
# 6  <@@> sort lK/DESC,NUM
# 7  <0> pushmark s
# 8  <$> gv(*articles) s
# 9  <1> rv2av[t1] lKRM*/1
# a  <2> aassign[t2] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EONT_EONT


=for gentest

# chunk: # this sorts the %age hash by value instead of key
# using an in-line function
@@eldest = sort { $age{$b} <=> $age{$a} } keys %age;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{@@eldest = sort { $age{$b} <=> $age{$a} } keys %age; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 592 (eval 28):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*age] s
# 5  <1> rv2hv[t9] lKRM/1       < 5.019006
# 5  <1> rv2hv lKRM/1           >=5.019006
# 6  <1> keys[t10] lK/1		< 5.019002
# 6  <1> keys[t10] lKM/1	>=5.019002
# 7  <@@> sort lKS*
# 8  <0> pushmark s
# 9  <#> gv[*eldest] s
# a  <1> rv2av[t2] lKRM*/1
# b  <2> aassign[t11] KS/COM_AGG
# c  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 546 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*age) s
# 5  <1> rv2hv[t3] lKRM/1       < 5.019006
# 5  <1> rv2hv lKRM/1           >=5.019006
# 6  <1> keys[t4] lK/1		< 5.019002
# 6  <1> keys[t4] lKM/1		>=5.019002
# 7  <@@> sort lKS*
# 8  <0> pushmark s
# 9  <$> gv(*eldest) s
# a  <1> rv2av[t1] lKRM*/1
# b  <2> aassign[t5] KS/COM_AGG
# c  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: # sort using explicit subroutine name
sub byage {
    $age{$a} <=> $age{$b};  # presuming numeric
}
@@sortedclass = sort byage @@class;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{sub byage { $age{$a} <=> $age{$b}; } @@sortedclass = sort byage @@class; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 597 (eval 30):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> const[PV "byage"] s/BARE
# 5  <#> gv[*class] s
# 6  <1> rv2av[t4] lK/1		< 5.019002
# 6  <1> rv2av[t4] lKM/1	>=5.019002
# 7  <@@> sort lKS
# 8  <0> pushmark s
# 9  <#> gv[*sortedclass] s
# a  <1> rv2av[t2] lKRM*/1
# b  <2> aassign[t5] KS/COM_AGG
# c  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 546 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> const(PV "byage") s/BARE
# 5  <$> gv(*class) s
# 6  <1> rv2av[t2] lK/1		< 5.019002
# 6  <1> rv2av[t2] lKM/1	>=5.019002
# 7  <@@> sort lKS
# 8  <0> pushmark s
# 9  <$> gv(*sortedclass) s
# a  <1> rv2av[t1] lKRM*/1
# b  <2> aassign[t3] KS/COM_AGG
# c  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: sub backwards { $b cmp $a }
@@harry  = qw(dog cat x Cain Abel);
@@george = qw(gone chased yz Punished Axed);
print sort @@harry;
# prints AbelCaincatdogx
print sort backwards @@harry;
# prints xdogcatCainAbel
print sort @@george, 'to', @@harry;
# prints AbelAxedCainPunishedcatchaseddoggonetoxyz

=cut

checkOptree(name   => q{sort USERSUB LIST },
	    bcopts => q{-exec},
	    code   => q{sub backwards { $b cmp $a }
			@@harry = qw(dog cat x Cain Abel);
			@@george = qw(gone chased yz Punished Axed);
			print sort @@harry; print sort backwards @@harry; 
			print sort @@george, 'to', @@harry; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 602 (eval 32):2) v
# 2  <0> pushmark s
# 3  <$> const[PV "dog"] s
# 4  <$> const[PV "cat"] s
# 5  <$> const[PV "x"] s
# 6  <$> const[PV "Cain"] s
# 7  <$> const[PV "Abel"] s
# 8  <0> pushmark s
# 9  <#> gv[*harry] s
# a  <1> rv2av[t2] lKRM*/1
# b  <2> aassign[t3] vKS
# c  <;> nextstate(main 602 (eval 32):3) v
# d  <0> pushmark s
# e  <$> const[PV "gone"] s
# f  <$> const[PV "chased"] s
# g  <$> const[PV "yz"] s
# h  <$> const[PV "Punished"] s
# i  <$> const[PV "Axed"] s
# j  <0> pushmark s
# k  <#> gv[*george] s
# l  <1> rv2av[t5] lKRM*/1
# m  <2> aassign[t6] vKS
# n  <;> nextstate(main 602 (eval 32):4) v:{
# o  <0> pushmark s
# p  <0> pushmark s
# q  <#> gv[*harry] s
# r  <1> rv2av[t8] lK/1
# s  <@@> sort lK
# t  <@@> print vK
# u  <;> nextstate(main 602 (eval 32):4) v:{
# v  <0> pushmark s
# w  <0> pushmark s
# x  <$> const[PV "backwards"] s/BARE
# y  <#> gv[*harry] s
# z  <1> rv2av[t10] lK/1	< 5.019002
# z  <1> rv2av[t10] lKM/1	>=5.019002
# 10 <@@> sort lKS
# 11 <@@> print vK
# 12 <;> nextstate(main 602 (eval 32):5) v:{
# 13 <0> pushmark s
# 14 <0> pushmark s
# 15 <#> gv[*george] s
# 16 <1> rv2av[t12] lK/1
# 17 <$> const[PV "to"] s
# 18 <#> gv[*harry] s
# 19 <1> rv2av[t14] lK/1
# 1a <@@> sort lK
# 1b <@@> print sK
# 1c <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 602 (eval 32):2) v
# 2  <0> pushmark s
# 3  <$> const(PV "dog") s
# 4  <$> const(PV "cat") s
# 5  <$> const(PV "x") s
# 6  <$> const(PV "Cain") s
# 7  <$> const(PV "Abel") s
# 8  <0> pushmark s
# 9  <$> gv(*harry) s
# a  <1> rv2av[t1] lKRM*/1
# b  <2> aassign[t2] vKS
# c  <;> nextstate(main 602 (eval 32):3) v
# d  <0> pushmark s
# e  <$> const(PV "gone") s
# f  <$> const(PV "chased") s
# g  <$> const(PV "yz") s
# h  <$> const(PV "Punished") s
# i  <$> const(PV "Axed") s
# j  <0> pushmark s
# k  <$> gv(*george) s
# l  <1> rv2av[t3] lKRM*/1
# m  <2> aassign[t4] vKS
# n  <;> nextstate(main 602 (eval 32):4) v:{
# o  <0> pushmark s
# p  <0> pushmark s
# q  <$> gv(*harry) s
# r  <1> rv2av[t5] lK/1
# s  <@@> sort lK
# t  <@@> print vK
# u  <;> nextstate(main 602 (eval 32):4) v:{
# v  <0> pushmark s
# w  <0> pushmark s
# x  <$> const(PV "backwards") s/BARE
# y  <$> gv(*harry) s
# z  <1> rv2av[t6] lK/1		< 5.019002
# z  <1> rv2av[t6] lKM/1	>=5.019002
# 10 <@@> sort lKS
# 11 <@@> print vK
# 12 <;> nextstate(main 602 (eval 32):5) v:{
# 13 <0> pushmark s
# 14 <0> pushmark s
# 15 <$> gv(*george) s
# 16 <1> rv2av[t7] lK/1
# 17 <$> const(PV "to") s
# 18 <$> gv(*harry) s
# 19 <1> rv2av[t8] lK/1
# 1a <@@> sort lK
# 1b <@@> print sK
# 1c <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: # inefficiently sort by descending numeric compare using
# the first integer after the first = sign, or the
# whole record case-insensitively otherwise
@@new = @@old[ sort {
    $nums[$b] <=> $nums[$a]
	|| $caps[$a] cmp $caps[$b]
	} 0..$#old  ];

=cut
=for gentest

# chunk: # same thing, but without any temps
@@new = map { $_->[0] }
sort { $b->[1] <=> $a->[1] 
	   || $a->[2] cmp $b->[2]
	   } map { [$_, /=(\d+)/, uc($_)] } @@old;

=cut

checkOptree(name   => q{Compound sort/map Expression },
	    bcopts => q{-exec},
	    code   => q{ @@new = map { $_->[0] }
			 sort { $b->[1] <=> $a->[1] || $a->[2] cmp $b->[2] }
			 map { [$_, /=(\d+)/, uc($_)] } @@old; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 609 (eval 34):3) v:{
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <0> pushmark s
# 5  <0> pushmark s
# 6  <#> gv[*old] s
# 7  <1> rv2av[t19] lKM/1
# 8  <@@> mapstart lK
# 9  <|> mapwhile(other->a)[t20] lKM
# a      <0> enter l
# b      <;> nextstate(main 608 (eval 34):2) v:{
# c      <0> pushmark s
# d      <#> gvsv[*_] s
# e      </> match(/"=(\\d+)"/) l/RTIME
# f      <#> gvsv[*_] s
# g      <1> uc[t17] sK/1
# h      <@@> anonlist sK*/1
# i      <@@> leave lKP
#            goto 9
# j  <@@> sort lKMS*
# k  <@@> mapstart lK
# l  <|> mapwhile(other->m)[t26] lK
# m      <+> multideref($_->[0]) sK
#            goto l
# n  <0> pushmark s
# o  <#> gv[*new] s
# p  <1> rv2av[t2] lKRM*/1
# q  <2> aassign[t22] KS/COM_AGG
# r  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 609 (eval 34):3) v:{
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <0> pushmark s
# 5  <0> pushmark s
# 6  <$> gv(*old) s
# 7  <1> rv2av[t10] lKM/1
# 8  <@@> mapstart lK
# 9  <|> mapwhile(other->a)[t11] lKM
# a      <0> enter l
# b      <;> nextstate(main 608 (eval 34):2) v:{
# c      <0> pushmark s
# d      <$> gvsv(*_) s
# e      </> match(/"=(\\d+)"/) l/RTIME
# f      <$> gvsv(*_) s
# g      <1> uc[t9] sK/1
# h      <@@> anonlist sK*/1
# i      <@@> leave lKP
#            goto 9
# j  <@@> sort lKMS*
# k  <@@> mapstart lK
# l  <|> mapwhile(other->m)[t12] lK
# m      <+> multideref($_->[0]) sK
#            goto l
# n  <0> pushmark s
# o  <$> gv(*new) s
# p  <1> rv2av[t1] lKRM*/1
# q  <2> aassign[t13] KS/COM_AGG
# r  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: # using a prototype allows you to use any comparison subroutine
# as a sort subroutine (including other package's subroutines)
package other;
sub backwards ($$) { $_[1] cmp $_[0]; }     # $a and $b are not set here
package main;
@@new = sort other::backwards @@old;

=cut

checkOptree(name   => q{sort other::sub LIST },
	    bcopts => q{-exec},
	    code   => q{package other; sub backwards ($$) { $_[1] cmp $_[0]; }
			package main; @@new = sort other::backwards @@old; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 614 (eval 36):2) v:{
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> const[PV "other::backwards"] s/BARE
# 5  <#> gv[*old] s
# 6  <1> rv2av[t4] lK/1	< 5.019002
# 6  <1> rv2av[t4] lKM/1	>=5.019002
# 7  <@@> sort lKS
# 8  <0> pushmark s
# 9  <#> gv[*new] s
# a  <1> rv2av[t2] lKRM*/1
# b  <2> aassign[t5] KS/COM_AGG
# c  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 614 (eval 36):2) v:{
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> const(PV "other::backwards") s/BARE
# 5  <$> gv(*old) s
# 6  <1> rv2av[t2] lK/1		< 5.019002
# 6  <1> rv2av[t2] lKM/1	>=5.019002
# 7  <@@> sort lKS
# 8  <0> pushmark s
# 9  <$> gv(*new) s
# a  <1> rv2av[t1] lKRM*/1
# b  <2> aassign[t3] KS/COM_AGG
# c  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: # repeat, condensed. $main::a and $b are unaffected
sub other::backwards ($$) { $_[1] cmp $_[0]; }
@@new = sort other::backwards @@old;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{sub other::backwards ($$) { $_[1] cmp $_[0]; } @@new = sort other::backwards @@old; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 619 (eval 38):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> const[PV "other::backwards"] s/BARE
# 5  <#> gv[*old] s
# 6  <1> rv2av[t4] lK/1		< 5.019002
# 6  <1> rv2av[t4] lKM/1	>=5.019002
# 7  <@@> sort lKS
# 8  <0> pushmark s
# 9  <#> gv[*new] s
# a  <1> rv2av[t2] lKRM*/1
# b  <2> aassign[t5] KS/COM_AGG
# c  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 546 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> const(PV "other::backwards") s/BARE
# 5  <$> gv(*old) s
# 6  <1> rv2av[t2] lK/1		< 5.019002
# 6  <1> rv2av[t2] lKM/1	>=5.019002
# 7  <@@> sort lKS
# 8  <0> pushmark s
# 9  <$> gv(*new) s
# a  <1> rv2av[t1] lKRM*/1
# b  <2> aassign[t3] KS/COM_AGG
# c  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: # guarantee stability, regardless of algorithm
use sort 'stable';
@@new = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @@old;

=cut

my ($expect, $expect_nt) = (<<'EOT_EOT', <<'EONT_EONT');
# 1  <;> nextstate(main 656 (eval 40):1) v:%,{
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*old] s
# 5  <1> rv2av[t9] lK/1		< 5.019002
# 5  <1> rv2av[t9] lKM/1	>=5.019002
# 6  <@@> sort lKS*/STABLE
# 7  <0> pushmark s
# 8  <#> gv[*new] s
# 9  <1> rv2av[t2] lKRM*/1
# a  <2> aassign[t14] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 578 (eval 15):1) v:%,{
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*old) s
# 5  <1> rv2av[t5] lK/1		< 5.019002
# 5  <1> rv2av[t5] lKM/1	>=5.019002
# 6  <@@> sort lKS*/STABLE
# 7  <0> pushmark s
# 8  <$> gv(*new) s
# 9  <1> rv2av[t1] lKRM*/1
# a  <2> aassign[t6] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EONT_EONT


checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{use sort 'stable'; @@new = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @@old; },
	    expect => $expect, expect_nt => $expect_nt);

=for gentest

# chunk: # force use of mergesort (not portable outside Perl 5.8)
use sort '_mergesort';
@@new = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @@old;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{use sort '_mergesort'; @@new = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @@old; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 662 (eval 42):1) v:%,{
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*old] s
# 5  <1> rv2av[t9] lK/1		< 5.019002
# 5  <1> rv2av[t9] lKM/1	>=5.019002
# 6  <@@> sort lKS*
# 7  <0> pushmark s
# 8  <#> gv[*new] s
# 9  <1> rv2av[t2] lKRM*/1
# a  <2> aassign[t14] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 578 (eval 15):1) v:%,{
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*old) s
# 5  <1> rv2av[t5] lK/1		< 5.019002
# 5  <1> rv2av[t5] lKM/1	>=5.019002
# 6  <@@> sort lKS*
# 7  <0> pushmark s
# 8  <$> gv(*new) s
# 9  <1> rv2av[t1] lKRM*/1
# a  <2> aassign[t6] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: # you should have a good reason to do this!
@@articles = sort {$FooPack::b <=> $FooPack::a} @@files;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{@@articles = sort {$FooPack::b <=> $FooPack::a} @@files; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 667 (eval 44):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*files] s
# 5  <1> rv2av[t7] lK/1		< 5.019002
# 5  <1> rv2av[t7] lKM/1	>=5.019002
# 6  <@@> sort lKS*
# 7  <0> pushmark s
# 8  <#> gv[*articles] s
# 9  <1> rv2av[t2] lKRM*/1
# a  <2> aassign[t8] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 546 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*files) s
# 5  <1> rv2av[t3] lK/1		< 5.019002
# 5  <1> rv2av[t3] lKM/1	>=5.019002
# 6  <@@> sort lKS*
# 7  <0> pushmark s
# 8  <$> gv(*articles) s
# 9  <1> rv2av[t1] lKRM*/1
# a  <2> aassign[t4] KS/COM_AGG
# b  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: # fancy
@@result = sort { $a <=> $b } grep { $_ == $_ } @@input;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{@@result = sort { $a <=> $b } grep { $_ == $_ } @@input; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 673 (eval 46):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <0> pushmark s
# 5  <#> gv[*input] s
# 6  <1> rv2av[t9] lKM/1
# 7  <@@> grepstart lK*              < 5.017002
# 7  <@@> grepstart lK               >=5.017002
# 8  <|> grepwhile(other->9)[t10] lK
# 9      <#> gvsv[*_] s
# a      <#> gvsv[*_] s
# b      <2> eq sK/2
# -      <@@> scope sK              < 5.017002
#            goto 8
# c  <@@> sort lK/NUM
# d  <0> pushmark s
# e  <#> gv[*result] s
# f  <1> rv2av[t2] lKRM*/1
# g  <2> aassign[t3] KS/COM_AGG
# h  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 547 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <0> pushmark s
# 5  <$> gv(*input) s
# 6  <1> rv2av[t3] lKM/1
# 7  <@@> grepstart lK*              < 5.017002
# 7  <@@> grepstart lK               >=5.017002
# 8  <|> grepwhile(other->9)[t4] lK
# 9      <$> gvsv(*_) s
# a      <$> gvsv(*_) s
# b      <2> eq sK/2
# -      <@@> scope sK              < 5.017002
#            goto 8
# c  <@@> sort lK/NUM
# d  <0> pushmark s
# e  <$> gv(*result) s
# f  <1> rv2av[t1] lKRM*/1
# g  <2> aassign[t2] KS/COM_AGG
# h  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: # void return context sort
sort { $a <=> $b } @@input;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{sort { $a <=> $b } @@input; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 678 (eval 48):1) v
# 2  <0> pushmark s
# 3  <#> gv[*input] s
# 4  <1> rv2av[t5] lK/1
# 5  <@@> sort K/NUM
# 6  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 546 (eval 15):1) v
# 2  <0> pushmark s
# 3  <$> gv(*input) s
# 4  <1> rv2av[t2] lK/1
# 5  <@@> sort K/NUM
# 6  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: # more void context, propagating ?
sort { $a <=> $b } grep { $_ == $_ } @@input;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{sort { $a <=> $b } grep { $_ == $_ } @@input; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 684 (eval 50):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*input] s
# 5  <1> rv2av[t7] lKM/1
# 6  <@@> grepstart lK*              < 5.017002
# 6  <@@> grepstart lK               >=5.017002
# 7  <|> grepwhile(other->8)[t8] lK
# 8      <#> gvsv[*_] s
# 9      <#> gvsv[*_] s
# a      <2> eq sK/2
# -      <@@> scope sK              < 5.017002
#            goto 7
# b  <@@> sort K/NUM
# c  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 547 (eval 15):1) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*input) s
# 5  <1> rv2av[t2] lKM/1
# 6  <@@> grepstart lK*              < 5.017002
# 6  <@@> grepstart lK               >=5.017002
# 7  <|> grepwhile(other->8)[t3] lK
# 8      <$> gvsv(*_) s
# 9      <$> gvsv(*_) s
# a      <2> eq sK/2
# -      <@@> scope sK              < 5.017002
#            goto 7
# b  <@@> sort K/NUM
# c  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: # scalar return context sort
$s = sort { $a <=> $b } @@input;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{$s = sort { $a <=> $b } @@input; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 689 (eval 52):1) v:{
# 2  <0> pushmark s
# 3  <#> gv[*input] s
# 4  <1> rv2av[t6] lK/1
# 5  <@@> sort sK/NUM
# 6  <#> gvsv[*s] s
# 7  <2> sassign sKS/2
# 8  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 546 (eval 15):1) v:{
# 2  <0> pushmark s
# 3  <$> gv(*input) s
# 4  <1> rv2av[t2] lK/1
# 5  <@@> sort sK/NUM
# 6  <$> gvsv(*s) s
# 7  <2> sassign sKS/2
# 8  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    

=for gentest

# chunk: $s = sort { $a <=> $b } grep { $_ == $_ } @@input;

=cut

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{$s = sort { $a <=> $b } grep { $_ == $_ } @@input; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 695 (eval 54):1) v:{
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <#> gv[*input] s
# 5  <1> rv2av[t8] lKM/1
# 6  <@@> grepstart lK*              < 5.017002
# 6  <@@> grepstart lK               >=5.017002
# 7  <|> grepwhile(other->8)[t9] lK
# 8      <#> gvsv[*_] s
# 9      <#> gvsv[*_] s
# a      <2> eq sK/2
# -      <@@> scope sK              < 5.017002
#            goto 7
# b  <@@> sort sK/NUM
# c  <#> gvsv[*s] s
# d  <2> sassign sKS/2
# e  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 547 (eval 15):1) v:{
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*input) s
# 5  <1> rv2av[t2] lKM/1
# 6  <@@> grepstart lK*              < 5.017002
# 6  <@@> grepstart lK               >=5.017002
# 7  <|> grepwhile(other->8)[t3] lK
# 8      <$> gvsv(*_) s
# 9      <$> gvsv(*_) s
# a      <2> eq sK/2
# -      <@@> scope sK              < 5.017002
#            goto 7
# b  <@@> sort sK/NUM
# c  <$> gvsv(*s) s
# d  <2> sassign sKS/2
# e  <1> leavesub[1 ref] K/REFC,1
EONT_EONT
    
@


1.1
log
@Initial revision
@
text
@d4 1
a4 2
    chdir q(t);
    @@INC = qw(../lib ../ext/B/t);
a13 5
    if ($] < 5.009) {
        print "1..0 # Skip -- TODO - provide golden result regexps for 5.8\n";
        exit 0;
    }
    require q(./test.pl);
d16 3
a18 1
plan tests => 20;
d20 9
d63 1
a63 1
# a  <2> aassign[t5] KS
d75 1
a75 1
# a  <2> aassign[t3] KS
d100 1
a100 1
# a  <2> aassign[t5] KS
d112 1
a112 1
# a  <2> aassign[t2] KS
d132 2
a133 1
# 5  <1> rv2av[t9] lK/1
d138 1
a138 1
# a  <2> aassign[t10] KS
d145 2
a146 1
# 5  <1> rv2av[t5] lK/1
d151 1
a151 1
# a  <2> aassign[t6] KS
d176 1
a176 1
# a  <2> aassign[t5] KS
d188 1
a188 1
# a  <2> aassign[t2] KS
d213 1
a213 1
# a  <2> aassign[t5] KS
d225 1
a225 1
# a  <2> aassign[t2] KS
d250 1
a250 1
# a  <2> aassign[t5] KS
d262 1
a262 1
# a  <2> aassign[t2] KS
d283 4
a286 2
# 5  <1> rv2hv[t9] lKRM/1
# 6  <1> keys[t10] lK/1
d291 1
a291 1
# b  <2> aassign[t11] KS
d298 4
a301 2
# 5  <1> rv2hv[t3] lKRM/1
# 6  <1> keys[t4] lK/1
d306 1
a306 1
# b  <2> aassign[t5] KS
d330 2
a331 1
# 6  <1> rv2av[t4] lK/1
d336 1
a336 1
# b  <2> aassign[t5] KS
d344 2
a345 1
# 6  <1> rv2av[t2] lK/1
d350 1
a350 1
# b  <2> aassign[t3] KS
d399 1
a399 1
# n  <;> nextstate(main 602 (eval 32):4) v
d406 1
a406 1
# u  <;> nextstate(main 602 (eval 32):4) v
d411 2
a412 1
# z  <1> rv2av[t10] lK/1
d415 1
a415 1
# 12 <;> nextstate(main 602 (eval 32):5) v
d449 1
a449 1
# n  <;> nextstate(main 602 (eval 32):4) v
d456 1
a456 1
# u  <;> nextstate(main 602 (eval 32):4) v
d461 2
a462 1
# z  <1> rv2av[t6] lK/1
d465 1
a465 1
# 12 <;> nextstate(main 602 (eval 32):5) v
d506 1
a506 1
# 1  <;> nextstate(main 609 (eval 34):3) v
d513 2
a514 2
# 8  <@@> mapstart lK*
# 9  <|> mapwhile(other->a)[t20] lK
d516 1
a516 1
# b      <;> nextstate(main 608 (eval 34):2) v
d522 2
a523 3
# h      <@@> anonlist sKRM/1
# i      <1> srefgen sK/1
# j      <@@> leave lKP
d525 10
a534 15
# k  <@@> sort lKMS*
# l  <@@> mapstart lK*
# m  <|> mapwhile(other->n)[t26] lK
# n      <#> gv[*_] s
# o      <1> rv2sv sKM/DREFAV,1
# p      <1> rv2av[t4] sKR/1
# q      <$> const[IV 0] s
# r      <2> aelem sK/2
# -      <@@> scope lK
#            goto m
# s  <0> pushmark s
# t  <#> gv[*new] s
# u  <1> rv2av[t2] lKRM*/1
# v  <2> aassign[t27] KS/COMMON
# w  <1> leavesub[1 ref] K/REFC,1
d536 1
a536 1
# 1  <;> nextstate(main 609 (eval 34):3) v
d543 2
a544 2
# 8  <@@> mapstart lK*
# 9  <|> mapwhile(other->a)[t11] lK
d546 1
a546 1
# b      <;> nextstate(main 608 (eval 34):2) v
d552 2
a553 3
# h      <@@> anonlist sKRM/1
# i      <1> srefgen sK/1
# j      <@@> leave lKP
d555 10
a564 15
# k  <@@> sort lKMS*
# l  <@@> mapstart lK*
# m  <|> mapwhile(other->n)[t12] lK
# n      <$> gv(*_) s
# o      <1> rv2sv sKM/DREFAV,1
# p      <1> rv2av[t2] sKR/1
# q      <$> const(IV 0) s
# r      <2> aelem sK/2
# -      <@@> scope lK
#            goto m
# s  <0> pushmark s
# t  <$> gv(*new) s
# u  <1> rv2av[t1] lKRM*/1
# v  <2> aassign[t13] KS/COMMON
# w  <1> leavesub[1 ref] K/REFC,1
d584 1
a584 1
# 1  <;> nextstate(main 614 (eval 36):2) v
d589 2
a590 1
# 6  <1> rv2av[t4] lK/1
d595 1
a595 1
# b  <2> aassign[t5] KS
d598 1
a598 1
# 1  <;> nextstate(main 614 (eval 36):2) v
d603 2
a604 1
# 6  <1> rv2av[t2] lK/1
d609 1
a609 1
# b  <2> aassign[t3] KS
d631 2
a632 1
# 6  <1> rv2av[t4] lK/1
d637 1
a637 1
# b  <2> aassign[t5] KS
d645 2
a646 1
# 6  <1> rv2av[t2] lK/1
d651 1
a651 1
# b  <2> aassign[t3] KS
d664 2
a665 5
checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{use sort 'stable'; @@new = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @@old; },
	    expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 656 (eval 40):1) v
d669 3
a671 2
# 5  <1> rv2av[t9] lK/1
# 6  <@@> sort lKS*
d675 1
a675 1
# a  <2> aassign[t14] KS
d678 1
a678 1
# 1  <;> nextstate(main 578 (eval 15):1) v
d682 3
a684 2
# 5  <1> rv2av[t5] lK/1
# 6  <@@> sort lKS*
d688 1
a688 1
# a  <2> aassign[t6] KS
d691 6
a696 1
    
d710 1
a710 1
# 1  <;> nextstate(main 662 (eval 42):1) v
d714 2
a715 1
# 5  <1> rv2av[t9] lK/1
d720 1
a720 1
# a  <2> aassign[t14] KS
d723 1
a723 1
# 1  <;> nextstate(main 578 (eval 15):1) v
d727 2
a728 1
# 5  <1> rv2av[t5] lK/1
d733 1
a733 1
# a  <2> aassign[t6] KS
d753 2
a754 1
# 5  <1> rv2av[t7] lK/1
d759 1
a759 1
# a  <2> aassign[t8] KS
d766 2
a767 1
# 5  <1> rv2av[t3] lK/1
d772 1
a772 1
# a  <2> aassign[t4] KS
d794 2
a795 1
# 7  <@@> grepstart lK*
d800 1
a800 1
# -      <@@> scope sK
d806 1
a806 1
# g  <2> aassign[t5] KS/COMMON
d815 2
a816 1
# 7  <@@> grepstart lK*
d821 1
a821 1
# -      <@@> scope sK
d827 1
a827 1
# g  <2> aassign[t2] KS/COMMON
d875 2
a876 1
# 6  <@@> grepstart lK*
d881 1
a881 1
# -      <@@> scope sK
d891 2
a892 1
# 6  <@@> grepstart lK*
d897 1
a897 1
# -      <@@> scope sK
d915 1
a915 1
# 1  <;> nextstate(main 689 (eval 52):1) v
d924 1
a924 1
# 1  <;> nextstate(main 546 (eval 15):1) v
d945 1
a945 1
# 1  <;> nextstate(main 695 (eval 54):1) v
d950 2
a951 1
# 6  <@@> grepstart lK*
d956 1
a956 1
# -      <@@> scope sK
d963 1
a963 1
# 1  <;> nextstate(main 547 (eval 15):1) v
d968 2
a969 1
# 6  <@@> grepstart lK*
d974 1
a974 1
# -      <@@> scope sK
@


1.1.1.1
log
@perl 5.8.6 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.8 import
@
text
@d4 2
a5 7
    if ($ENV{PERL_CORE}){
	chdir('t') if -d 't';
	@@INC = ('.', '../lib', '../ext/B/t');
    } else {
	unshift @@INC, 't';
	push @@INC, "../../t";
    }
d15 5
a19 1
    # require q(test.pl); # now done by OptreeCheck;
a23 11
=head1 f_sort.t

Code test snippets here are adapted from `perldoc -f map`

Due to a bleadperl optimization (Dave Mitchell, circa apr 04), the
(map|grep)(start|while) opcodes have different flags in 5.9, their
private flags /1, /2 are gone in blead (for the cases covered)

When the optree stuff was integrated into 5.8.6, these tests failed,
and were todo'd.  Theyre now done, by version-specific tweaking in
mkCheckRex(), therefore the skip is removed too.
d95 1
a95 1
# a  <2> aassign[t3] KS
d169 1
a169 1
# a  <2> aassign[t3] KS
d206 1
a206 1
# a  <2> aassign[t3] KS
d243 1
a243 1
# a  <2> aassign[t3] KS
d790 1
a790 1
# g  <2> aassign[t3] KS/COMMON
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d70 1
a70 1
# a  <2> aassign[t5] KS/COMMON
d82 1
a82 1
# a  <2> aassign[t3] KS/COMMON
d107 1
a107 1
# a  <2> aassign[t3] KS/COMMON
d119 1
a119 1
# a  <2> aassign[t2] KS/COMMON
d144 1
a144 1
# a  <2> aassign[t10] KS/COMMON
d156 1
a156 1
# a  <2> aassign[t6] KS/COMMON
d181 1
a181 1
# a  <2> aassign[t3] KS/COMMON
d193 1
a193 1
# a  <2> aassign[t2] KS/COMMON
d218 1
a218 1
# a  <2> aassign[t3] KS/COMMON
d230 1
a230 1
# a  <2> aassign[t2] KS/COMMON
d255 1
a255 1
# a  <2> aassign[t3] KS/COMMON
d267 1
a267 1
# a  <2> aassign[t2] KS/COMMON
d294 1
a294 1
# b  <2> aassign[t11] KS/COMMON
d307 1
a307 1
# b  <2> aassign[t5] KS/COMMON
d336 1
a336 1
# b  <2> aassign[t5] KS/COMMON
d349 1
a349 1
# b  <2> aassign[t3] KS/COMMON
d398 1
a398 1
# n  <;> nextstate(main 602 (eval 32):4) v:{
d405 1
a405 1
# u  <;> nextstate(main 602 (eval 32):4) v:{
d413 1
a413 1
# 12 <;> nextstate(main 602 (eval 32):5) v:{
d447 1
a447 1
# n  <;> nextstate(main 602 (eval 32):4) v:{
d454 1
a454 1
# u  <;> nextstate(main 602 (eval 32):4) v:{
d462 1
a462 1
# 12 <;> nextstate(main 602 (eval 32):5) v:{
d503 1
a503 1
# 1  <;> nextstate(main 609 (eval 34):3) v:{
d513 1
a513 1
# b      <;> nextstate(main 608 (eval 34):2) v:{
d519 3
a521 2
# h      <@@> anonlist sK*/1
# i      <@@> leave lKP
d523 8
a530 8
# j  <@@> sort lKMS*
# k  <@@> mapstart lK*
# l  <|> mapwhile(other->m)[t26] lK
# m      <#> gv[*_] s
# n      <1> rv2sv sKM/DREFAV,1
# o      <1> rv2av[t4] sKR/1
# p      <$> const[IV 0] s
# q      <2> aelem sK/2
d532 6
a537 6
#            goto l
# r  <0> pushmark s
# s  <#> gv[*new] s
# t  <1> rv2av[t2] lKRM*/1
# u  <2> aassign[t27] KS/COMMON
# v  <1> leavesub[1 ref] K/REFC,1
d539 1
a539 1
# 1  <;> nextstate(main 609 (eval 34):3) v:{
d549 1
a549 1
# b      <;> nextstate(main 608 (eval 34):2) v:{
d555 3
a557 2
# h      <@@> anonlist sK*/1
# i      <@@> leave lKP
d559 8
a566 8
# j  <@@> sort lKMS*
# k  <@@> mapstart lK*
# l  <|> mapwhile(other->m)[t12] lK
# m      <$> gv(*_) s
# n      <1> rv2sv sKM/DREFAV,1
# o      <1> rv2av[t2] sKR/1
# p      <$> const(IV 0) s
# q      <2> aelem sK/2
d568 6
a573 6
#            goto l
# r  <0> pushmark s
# s  <$> gv(*new) s
# t  <1> rv2av[t1] lKRM*/1
# u  <2> aassign[t13] KS/COMMON
# v  <1> leavesub[1 ref] K/REFC,1
d593 1
a593 1
# 1  <;> nextstate(main 614 (eval 36):2) v:{
d603 1
a603 1
# b  <2> aassign[t5] KS/COMMON
d606 1
a606 1
# 1  <;> nextstate(main 614 (eval 36):2) v:{
d616 1
a616 1
# b  <2> aassign[t3] KS/COMMON
d643 1
a643 1
# b  <2> aassign[t5] KS/COMMON
d656 1
a656 1
# b  <2> aassign[t3] KS/COMMON
d669 5
a673 2
my ($expect, $expect_nt) = (<<'EOT_EOT', <<'EONT_EONT');
# 1  <;> nextstate(main 656 (eval 40):1) v:%,{
d678 1
a678 1
# 6  <@@> sort lKS*/STABLE
d682 1
a682 1
# a  <2> aassign[t14] KS/COMMON
d685 1
a685 1
# 1  <;> nextstate(main 578 (eval 15):1) v:%,{
d690 1
a690 1
# 6  <@@> sort lKS*/STABLE
d694 1
a694 1
# a  <2> aassign[t6] KS/COMMON
d697 1
a697 10

if($] < 5.009) {
    # 5.8.x doesn't show the /STABLE flag, so massage the golden results.
    s!/STABLE!!s foreach ($expect, $expect_nt);
}

checkOptree(note   => q{},
	    bcopts => q{-exec},
	    code   => q{use sort 'stable'; @@new = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @@old; },
	    expect => $expect, expect_nt => $expect_nt);
d711 1
a711 1
# 1  <;> nextstate(main 662 (eval 42):1) v:%,{
d720 1
a720 1
# a  <2> aassign[t14] KS/COMMON
d723 1
a723 1
# 1  <;> nextstate(main 578 (eval 15):1) v:%,{
d732 1
a732 1
# a  <2> aassign[t6] KS/COMMON
d757 1
a757 1
# a  <2> aassign[t8] KS/COMMON
d769 1
a769 1
# a  <2> aassign[t4] KS/COMMON
d908 1
a908 1
# 1  <;> nextstate(main 689 (eval 52):1) v:{
d917 1
a917 1
# 1  <;> nextstate(main 546 (eval 15):1) v:{
d938 1
a938 1
# 1  <;> nextstate(main 695 (eval 54):1) v:{
d955 1
a955 1
# 1  <;> nextstate(main 547 (eval 15):1) v:{
@


1.1.1.4
log
@Perl 5.12.2 from CPAN
@
text
@d4 7
a10 1
    unshift @@INC, 't';
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d14 1
d17 1
a17 1
plan tests => 40;
d28 1
a28 1
and were todo'd.  They're now done, by version-specific tweaking in
@


1.1.1.6
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d503 1
a503 2
# 8  <@@> mapstart lK*              < 5.017002
# 8  <@@> mapstart lK               >=5.017002
d516 1
a516 2
# k  <@@> mapstart lK*              < 5.017002
# k  <@@> mapstart lK               >=5.017002
d523 1
a523 1
# -      <@@> scope lK              < 5.017002
d538 1
a538 2
# 8  <@@> mapstart lK*              < 5.017002
# 8  <@@> mapstart lK               >=5.017002
d551 1
a551 2
# k  <@@> mapstart lK*              < 5.017002
# k  <@@> mapstart lK               >=5.017002
d558 1
a558 1
# -      <@@> scope lK              < 5.017002
d686 4
d788 1
a788 2
# 7  <@@> grepstart lK*              < 5.017002
# 7  <@@> grepstart lK               >=5.017002
d793 1
a793 1
# -      <@@> scope sK              < 5.017002
d808 1
a808 2
# 7  <@@> grepstart lK*              < 5.017002
# 7  <@@> grepstart lK               >=5.017002
d813 1
a813 1
# -      <@@> scope sK              < 5.017002
d867 1
a867 2
# 6  <@@> grepstart lK*              < 5.017002
# 6  <@@> grepstart lK               >=5.017002
d872 1
a872 1
# -      <@@> scope sK              < 5.017002
d882 1
a882 2
# 6  <@@> grepstart lK*              < 5.017002
# 6  <@@> grepstart lK               >=5.017002
d887 1
a887 1
# -      <@@> scope sK              < 5.017002
d940 1
a940 2
# 6  <@@> grepstart lK*              < 5.017002
# 6  <@@> grepstart lK               >=5.017002
d945 1
a945 1
# -      <@@> scope sK              < 5.017002
d957 1
a957 2
# 6  <@@> grepstart lK*              < 5.017002
# 6  <@@> grepstart lK               >=5.017002
d962 1
a962 1
# -      <@@> scope sK              < 5.017002
@


1.1.1.7
log
@Import perl-5.20.1
@
text
@d132 1
a132 2
# 5  <1> rv2av[t9] lK/1		< 5.019002
# 5  <1> rv2av[t9] lKM/1	>=5.019002
d144 1
a144 2
# 5  <1> rv2av[t5] lK/1		< 5.019002
# 5  <1> rv2av[t5] lKM/1	>=5.019002
d281 2
a282 4
# 5  <1> rv2hv[t9] lKRM/1       < 5.019006
# 5  <1> rv2hv lKRM/1           >=5.019006
# 6  <1> keys[t10] lK/1		< 5.019002
# 6  <1> keys[t10] lKM/1	>=5.019002
d294 2
a295 4
# 5  <1> rv2hv[t3] lKRM/1       < 5.019006
# 5  <1> rv2hv lKRM/1           >=5.019006
# 6  <1> keys[t4] lK/1		< 5.019002
# 6  <1> keys[t4] lKM/1		>=5.019002
d324 1
a324 2
# 6  <1> rv2av[t4] lK/1		< 5.019002
# 6  <1> rv2av[t4] lKM/1	>=5.019002
d337 1
a337 2
# 6  <1> rv2av[t2] lK/1		< 5.019002
# 6  <1> rv2av[t2] lKM/1	>=5.019002
d403 1
a403 2
# z  <1> rv2av[t10] lK/1	< 5.019002
# z  <1> rv2av[t10] lKM/1	>=5.019002
d452 1
a452 2
# z  <1> rv2av[t6] lK/1		< 5.019002
# z  <1> rv2av[t6] lKM/1	>=5.019002
d505 1
a505 2
# 9  <|> mapwhile(other->a)[t20] lK     < 5.019002
# 9  <|> mapwhile(other->a)[t20] lKM    >=5.019002
d542 1
a542 2
# 9  <|> mapwhile(other->a)[t11] lK     < 5.019002
# 9  <|> mapwhile(other->a)[t11] lKM    >=5.019002
d593 1
a593 2
# 6  <1> rv2av[t4] lK/1	< 5.019002
# 6  <1> rv2av[t4] lKM/1	>=5.019002
d606 1
a606 2
# 6  <1> rv2av[t2] lK/1		< 5.019002
# 6  <1> rv2av[t2] lKM/1	>=5.019002
d633 1
a633 2
# 6  <1> rv2av[t4] lK/1		< 5.019002
# 6  <1> rv2av[t4] lKM/1	>=5.019002
d646 1
a646 2
# 6  <1> rv2av[t2] lK/1		< 5.019002
# 6  <1> rv2av[t2] lKM/1	>=5.019002
d669 1
a669 2
# 5  <1> rv2av[t9] lK/1		< 5.019002
# 5  <1> rv2av[t9] lKM/1	>=5.019002
d681 1
a681 2
# 5  <1> rv2av[t5] lK/1		< 5.019002
# 5  <1> rv2av[t5] lKM/1	>=5.019002
d712 1
a712 2
# 5  <1> rv2av[t9] lK/1		< 5.019002
# 5  <1> rv2av[t9] lKM/1	>=5.019002
d724 1
a724 2
# 5  <1> rv2av[t5] lK/1		< 5.019002
# 5  <1> rv2av[t5] lKM/1	>=5.019002
d749 1
a749 2
# 5  <1> rv2av[t7] lK/1		< 5.019002
# 5  <1> rv2av[t7] lKM/1	>=5.019002
d761 1
a761 2
# 5  <1> rv2av[t3] lK/1		< 5.019002
# 5  <1> rv2av[t3] lKM/1	>=5.019002
@


1.1.1.8
log
@Import perl-5.24.2
@
text
@d63 1
a63 1
# a  <2> aassign[t5] KS/COM_AGG
d75 1
a75 1
# a  <2> aassign[t3] KS/COM_AGG
d100 1
a100 1
# a  <2> aassign[t3] KS/COM_AGG
d112 1
a112 1
# a  <2> aassign[t2] KS/COM_AGG
d138 1
a138 1
# a  <2> aassign[t10] KS/COM_AGG
d151 1
a151 1
# a  <2> aassign[t6] KS/COM_AGG
d176 1
a176 1
# a  <2> aassign[t3] KS/COM_AGG
d188 1
a188 1
# a  <2> aassign[t2] KS/COM_AGG
d213 1
a213 1
# a  <2> aassign[t3] KS/COM_AGG
d225 1
a225 1
# a  <2> aassign[t2] KS/COM_AGG
d250 1
a250 1
# a  <2> aassign[t3] KS/COM_AGG
d262 1
a262 1
# a  <2> aassign[t2] KS/COM_AGG
d291 1
a291 1
# b  <2> aassign[t11] KS/COM_AGG
d306 1
a306 1
# b  <2> aassign[t5] KS/COM_AGG
d336 1
a336 1
# b  <2> aassign[t5] KS/COM_AGG
d350 1
a350 1
# b  <2> aassign[t3] KS/COM_AGG
d513 4
a516 2
# 8  <@@> mapstart lK
# 9  <|> mapwhile(other->a)[t20] lKM
d528 2
a529 1
# k  <@@> mapstart lK
d531 6
a536 1
# m      <+> multideref($_->[0]) sK
d538 5
a542 5
# n  <0> pushmark s
# o  <#> gv[*new] s
# p  <1> rv2av[t2] lKRM*/1
# q  <2> aassign[t22] KS/COM_AGG
# r  <1> leavesub[1 ref] K/REFC,1
d551 4
a554 2
# 8  <@@> mapstart lK
# 9  <|> mapwhile(other->a)[t11] lKM
d566 2
a567 1
# k  <@@> mapstart lK
d569 6
a574 1
# m      <+> multideref($_->[0]) sK
d576 5
a580 5
# n  <0> pushmark s
# o  <$> gv(*new) s
# p  <1> rv2av[t1] lKRM*/1
# q  <2> aassign[t13] KS/COM_AGG
# r  <1> leavesub[1 ref] K/REFC,1
d611 1
a611 1
# b  <2> aassign[t5] KS/COM_AGG
d625 1
a625 1
# b  <2> aassign[t3] KS/COM_AGG
d653 1
a653 1
# b  <2> aassign[t5] KS/COM_AGG
d667 1
a667 1
# b  <2> aassign[t3] KS/COM_AGG
d691 1
a691 1
# a  <2> aassign[t14] KS/COM_AGG
d704 1
a704 1
# a  <2> aassign[t6] KS/COM_AGG
d736 1
a736 1
# a  <2> aassign[t14] KS/COM_AGG
d749 1
a749 1
# a  <2> aassign[t6] KS/COM_AGG
d775 1
a775 1
# a  <2> aassign[t8] KS/COM_AGG
d788 1
a788 1
# a  <2> aassign[t4] KS/COM_AGG
d822 1
a822 1
# g  <2> aassign[t3] KS/COM_AGG
d843 1
a843 1
# g  <2> aassign[t2] KS/COM_AGG
@


