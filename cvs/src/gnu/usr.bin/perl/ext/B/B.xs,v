head	1.2;
access;
symbols
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.13.0.10
	OPENBSD_6_0_BASE:1.1.1.13
	OPENBSD_5_9:1.1.1.13.0.4
	OPENBSD_5_9_BASE:1.1.1.13
	OPENBSD_5_8:1.1.1.13.0.6
	OPENBSD_5_8_BASE:1.1.1.13
	PERL_5_20_2:1.1.1.13
	OPENBSD_5_7:1.1.1.13.0.2
	OPENBSD_5_7_BASE:1.1.1.13
	PERL_5_20_1:1.1.1.13
	OPENBSD_5_6:1.1.1.12.0.4
	OPENBSD_5_6_BASE:1.1.1.12
	PERL_5_18_2:1.1.1.12
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.11.0.6
	OPENBSD_5_5_BASE:1.1.1.11
	OPENBSD_5_4:1.1.1.11.0.2
	OPENBSD_5_4_BASE:1.1.1.11
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.1.1.10.0.10
	OPENBSD_5_3_BASE:1.1.1.10
	OPENBSD_5_2:1.1.1.10.0.8
	OPENBSD_5_2_BASE:1.1.1.10
	OPENBSD_5_1_BASE:1.1.1.10
	OPENBSD_5_1:1.1.1.10.0.6
	OPENBSD_5_0:1.1.1.10.0.4
	OPENBSD_5_0_BASE:1.1.1.10
	OPENBSD_4_9:1.1.1.10.0.2
	OPENBSD_4_9_BASE:1.1.1.10
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.1.1.9.0.4
	OPENBSD_4_8_BASE:1.1.1.9
	OPENBSD_4_7:1.1.1.9.0.2
	OPENBSD_4_7_BASE:1.1.1.9
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.1.1.8.0.6
	OPENBSD_4_6_BASE:1.1.1.8
	OPENBSD_4_5:1.1.1.8.0.2
	OPENBSD_4_5_BASE:1.1.1.8
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.1.1.7.0.10
	OPENBSD_4_4_BASE:1.1.1.7
	OPENBSD_4_3:1.1.1.7.0.8
	OPENBSD_4_3_BASE:1.1.1.7
	OPENBSD_4_2:1.1.1.7.0.6
	OPENBSD_4_2_BASE:1.1.1.7
	OPENBSD_4_1:1.1.1.7.0.4
	OPENBSD_4_1_BASE:1.1.1.7
	OPENBSD_4_0:1.1.1.7.0.2
	OPENBSD_4_0_BASE:1.1.1.7
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.1.1.6.0.6
	OPENBSD_3_9_BASE:1.1.1.6
	OPENBSD_3_8:1.1.1.6.0.4
	OPENBSD_3_8_BASE:1.1.1.6
	OPENBSD_3_7:1.1.1.6.0.2
	OPENBSD_3_7_BASE:1.1.1.6
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.1.1.5.0.4
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.11;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	99.04.29.22.38.38;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.38.38;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.01;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.38;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.53;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.40;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.16.42;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.47.51;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.13;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.11.11;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.48.52;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.08.42;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*	B.xs
 *
 *	Copyright (c) 1996 Malcolm Beattie
 *
 *	You may distribute under the terms of either the GNU General Public
 *	License or the Artistic License, as specified in the README file.
 *
 */

#define PERL_NO_GET_CONTEXT
#define PERL_EXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#ifdef PerlIO
typedef PerlIO * InputStream;
#else
typedef FILE * InputStream;
#endif


static const char* const svclassnames[] = {
    "B::NULL",
    "B::IV",
    "B::NV",
    "B::PV",
    "B::INVLIST",
    "B::PVIV",
    "B::PVNV",
    "B::PVMG",
    "B::REGEXP",
    "B::GV",
    "B::PVLV",
    "B::AV",
    "B::HV",
    "B::CV",
    "B::FM",
    "B::IO",
};

typedef enum {
    OPc_NULL,	/* 0 */
    OPc_BASEOP,	/* 1 */
    OPc_UNOP,	/* 2 */
    OPc_BINOP,	/* 3 */
    OPc_LOGOP,	/* 4 */
    OPc_LISTOP,	/* 5 */
    OPc_PMOP,	/* 6 */
    OPc_SVOP,	/* 7 */
    OPc_PADOP,	/* 8 */
    OPc_PVOP,	/* 9 */
    OPc_LOOP,	/* 10 */
    OPc_COP,	/* 11 */
    OPc_METHOP,	/* 12 */
    OPc_UNOP_AUX /* 13 */
} opclass;

static const char* const opclassnames[] = {
    "B::NULL",
    "B::OP",
    "B::UNOP",
    "B::BINOP",
    "B::LOGOP",
    "B::LISTOP",
    "B::PMOP",
    "B::SVOP",
    "B::PADOP",
    "B::PVOP",
    "B::LOOP",
    "B::COP",
    "B::METHOP",
    "B::UNOP_AUX"
};

static const size_t opsizes[] = {
    0,	
    sizeof(OP),
    sizeof(UNOP),
    sizeof(BINOP),
    sizeof(LOGOP),
    sizeof(LISTOP),
    sizeof(PMOP),
    sizeof(SVOP),
    sizeof(PADOP),
    sizeof(PVOP),
    sizeof(LOOP),
    sizeof(COP),
    sizeof(METHOP),
    sizeof(UNOP_AUX),
};

#define MY_CXT_KEY "B::_guts" XS_VERSION

typedef struct {
    SV *	x_specialsv_list[7];
    int		x_walkoptree_debug;	/* Flag for walkoptree debug hook */
} my_cxt_t;

START_MY_CXT

#define walkoptree_debug	(MY_CXT.x_walkoptree_debug)
#define specialsv_list		(MY_CXT.x_specialsv_list)


static void B_init_my_cxt(pTHX_ my_cxt_t * cxt) {
    cxt->x_specialsv_list[0] = Nullsv;
    cxt->x_specialsv_list[1] = &PL_sv_undef;
    cxt->x_specialsv_list[2] = &PL_sv_yes;
    cxt->x_specialsv_list[3] = &PL_sv_no;
    cxt->x_specialsv_list[4] = (SV *) pWARN_ALL;
    cxt->x_specialsv_list[5] = (SV *) pWARN_NONE;
    cxt->x_specialsv_list[6] = (SV *) pWARN_STD;
}

static opclass
cc_opclass(pTHX_ const OP *o)
{
    bool custom = 0;

    if (!o)
	return OPc_NULL;

    if (o->op_type == 0) {
	if (o->op_targ == OP_NEXTSTATE || o->op_targ == OP_DBSTATE)
	    return OPc_COP;
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;
    }

    if (o->op_type == OP_SASSIGN)
	return ((o->op_private & OPpASSIGN_BACKWARDS) ? OPc_UNOP : OPc_BINOP);

    if (o->op_type == OP_AELEMFAST) {
#ifdef USE_ITHREADS
	    return OPc_PADOP;
#else
	    return OPc_SVOP;
#endif
    }
    
#ifdef USE_ITHREADS
    if (o->op_type == OP_GV || o->op_type == OP_GVSV ||
	o->op_type == OP_RCATLINE)
	return OPc_PADOP;
#endif

    if (o->op_type == OP_CUSTOM)
        custom = 1;

    switch (OP_CLASS(o)) {
    case OA_BASEOP:
	return OPc_BASEOP;

    case OA_UNOP:
	return OPc_UNOP;

    case OA_BINOP:
	return OPc_BINOP;

    case OA_LOGOP:
	return OPc_LOGOP;

    case OA_LISTOP:
	return OPc_LISTOP;

    case OA_PMOP:
	return OPc_PMOP;

    case OA_SVOP:
	return OPc_SVOP;

    case OA_PADOP:
	return OPc_PADOP;

    case OA_PVOP_OR_SVOP:
        /*
         * Character translations (tr///) are usually a PVOP, keeping a 
         * pointer to a table of shorts used to look up translations.
         * Under utf8, however, a simple table isn't practical; instead,
         * the OP is an SVOP (or, under threads, a PADOP),
         * and the SV is a reference to a swash
         * (i.e., an RV pointing to an HV).
         */
	return (!custom &&
		   (o->op_private & (OPpTRANS_TO_UTF|OPpTRANS_FROM_UTF))
	       )
#if  defined(USE_ITHREADS)
		? OPc_PADOP : OPc_PVOP;
#else
		? OPc_SVOP : OPc_PVOP;
#endif

    case OA_LOOP:
	return OPc_LOOP;

    case OA_COP:
	return OPc_COP;

    case OA_BASEOP_OR_UNOP:
	/*
	 * UNI(OP_foo) in toke.c returns token UNI or FUNC1 depending on
	 * whether parens were seen. perly.y uses OPf_SPECIAL to
	 * signal whether a BASEOP had empty parens or none.
	 * Some other UNOPs are created later, though, so the best
	 * test is OPf_KIDS, which is set in newUNOP.
	 */
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;

    case OA_FILESTATOP:
	/*
	 * The file stat OPs are created via UNI(OP_foo) in toke.c but use
	 * the OPf_REF flag to distinguish between OP types instead of the
	 * usual OPf_SPECIAL flag. As usual, if OPf_KIDS is set, then we
	 * return OPc_UNOP so that walkoptree can find our children. If
	 * OPf_KIDS is not set then we check OPf_REF. Without OPf_REF set
	 * (no argument to the operator) it's an OP; with OPf_REF set it's
	 * an SVOP (and op_sv is the GV for the filehandle argument).
	 */
	return ((o->op_flags & OPf_KIDS) ? OPc_UNOP :
#ifdef USE_ITHREADS
		(o->op_flags & OPf_REF) ? OPc_PADOP : OPc_BASEOP);
#else
		(o->op_flags & OPf_REF) ? OPc_SVOP : OPc_BASEOP);
#endif
    case OA_LOOPEXOP:
	/*
	 * next, last, redo, dump and goto use OPf_SPECIAL to indicate that a
	 * label was omitted (in which case it's a BASEOP) or else a term was
	 * seen. In this last case, all except goto are definitely PVOP but
	 * goto is either a PVOP (with an ordinary constant label), an UNOP
	 * with OPf_STACKED (with a non-constant non-sub) or an UNOP for
	 * OP_REFGEN (with goto &sub) in which case OPf_STACKED also seems to
	 * get set.
	 */
	if (o->op_flags & OPf_STACKED)
	    return OPc_UNOP;
	else if (o->op_flags & OPf_SPECIAL)
	    return OPc_BASEOP;
	else
	    return OPc_PVOP;
    case OA_METHOP:
	return OPc_METHOP;
    case OA_UNOP_AUX:
	return OPc_UNOP_AUX;
    }
    warn("can't determine class of operator %s, assuming BASEOP\n",
	 OP_NAME(o));
    return OPc_BASEOP;
}

static SV *
make_op_object(pTHX_ const OP *o)
{
    SV *opsv = sv_newmortal();
    sv_setiv(newSVrv(opsv, opclassnames[cc_opclass(aTHX_ o)]), PTR2IV(o));
    return opsv;
}


static SV *
get_overlay_object(pTHX_ const OP *o, const char * const name, U32 namelen)
{
    HE *he;
    SV **svp;
    SV *key;
    SV *sv =get_sv("B::overlay", 0);
    if (!sv || !SvROK(sv))
	return NULL;
    sv = SvRV(sv);
    if (SvTYPE(sv) != SVt_PVHV)
	return NULL;
    key = newSViv(PTR2IV(o));
    he = hv_fetch_ent((HV*)sv, key, 0, 0);
    SvREFCNT_dec(key);
    if (!he)
	return NULL;
    sv = HeVAL(he);
    if (!sv || !SvROK(sv))
	return NULL;
    sv = SvRV(sv);
    if (SvTYPE(sv) != SVt_PVHV)
	return NULL;
    svp = hv_fetch((HV*)sv, name, namelen, 0);
    if (!svp)
	return NULL;
    sv = *svp;
    return sv;
}


static SV *
make_sv_object(pTHX_ SV *sv)
{
    SV *const arg = sv_newmortal();
    const char *type = 0;
    IV iv;
    dMY_CXT;

    for (iv = 0; iv < (IV)(sizeof(specialsv_list)/sizeof(SV*)); iv++) {
	if (sv == specialsv_list[iv]) {
	    type = "B::SPECIAL";
	    break;
	}
    }
    if (!type) {
	type = svclassnames[SvTYPE(sv)];
	iv = PTR2IV(sv);
    }
    sv_setiv(newSVrv(arg, type), iv);
    return arg;
}

static SV *
make_temp_object(pTHX_ SV *temp)
{
    SV *target;
    SV *arg = sv_newmortal();
    const char *const type = svclassnames[SvTYPE(temp)];
    const IV iv = PTR2IV(temp);

    target = newSVrv(arg, type);
    sv_setiv(target, iv);

    /* Need to keep our "temp" around as long as the target exists.
       Simplest way seems to be to hang it from magic, and let that clear
       it up.  No vtable, so won't actually get in the way of anything.  */
    sv_magicext(target, temp, PERL_MAGIC_sv, NULL, NULL, 0);
    /* magic object has had its reference count increased, so we must drop
       our reference.  */
    SvREFCNT_dec(temp);
    return arg;
}

static SV *
make_warnings_object(pTHX_ const COP *const cop)
{
    const STRLEN *const warnings = cop->cop_warnings;
    const char *type = 0;
    dMY_CXT;
    IV iv = sizeof(specialsv_list)/sizeof(SV*);

    /* Counting down is deliberate. Before the split between make_sv_object
       and make_warnings_obj there appeared to be a bug - Nullsv and pWARN_STD
       were both 0, so you could never get a B::SPECIAL for pWARN_STD  */

    while (iv--) {
	if ((SV*)warnings == specialsv_list[iv]) {
	    type = "B::SPECIAL";
	    break;
	}
    }
    if (type) {
	SV *arg = sv_newmortal();
	sv_setiv(newSVrv(arg, type), iv);
	return arg;
    } else {
	/* B assumes that warnings are a regular SV. Seems easier to keep it
	   happy by making them into a regular SV.  */
	return make_temp_object(aTHX_ newSVpvn((char *)(warnings + 1), *warnings));
    }
}

static SV *
make_cop_io_object(pTHX_ COP *cop)
{
    SV *const value = newSV(0);

    Perl_emulate_cop_io(aTHX_ cop, value);

    if(SvOK(value)) {
	return make_sv_object(aTHX_ value);
    } else {
	SvREFCNT_dec(value);
	return make_sv_object(aTHX_ NULL);
    }
}

static SV *
make_mg_object(pTHX_ MAGIC *mg)
{
    SV *arg = sv_newmortal();
    sv_setiv(newSVrv(arg, "B::MAGIC"), PTR2IV(mg));
    return arg;
}

static SV *
cstring(pTHX_ SV *sv, bool perlstyle)
{
    SV *sstr;

    if (!SvOK(sv))
	return newSVpvs_flags("0", SVs_TEMP);

    sstr = newSVpvs_flags("\"", SVs_TEMP);

    if (perlstyle && SvUTF8(sv)) {
	SV *tmpsv = sv_newmortal(); /* Temporary SV to feed sv_uni_display */
	const STRLEN len = SvCUR(sv);
	const char *s = sv_uni_display(tmpsv, sv, 8*len, UNI_DISPLAY_QQ);
	while (*s)
	{
	    if (*s == '"')
		sv_catpvs(sstr, "\\\"");
	    else if (*s == '$')
		sv_catpvs(sstr, "\\$");
	    else if (*s == '@@')
		sv_catpvs(sstr, "\\@@");
	    else if (*s == '\\')
	    {
		if (strchr("nrftax\\",*(s+1)))
		    sv_catpvn(sstr, s++, 2);
		else
		    sv_catpvs(sstr, "\\\\");
	    }
	    else /* should always be printable */
		sv_catpvn(sstr, s, 1);
	    ++s;
	}
    }
    else
    {
	/* XXX Optimise? */
	STRLEN len;
	const char *s = SvPV(sv, len);
	for (; len; len--, s++)
	{
	    /* At least try a little for readability */
	    if (*s == '"')
		sv_catpvs(sstr, "\\\"");
	    else if (*s == '\\')
		sv_catpvs(sstr, "\\\\");
            /* trigraphs - bleagh */
            else if (!perlstyle && *s == '?' && len>=3 && s[1] == '?') {
                Perl_sv_catpvf(aTHX_ sstr, "\\%03o", '?');
            }
	    else if (perlstyle && *s == '$')
		sv_catpvs(sstr, "\\$");
	    else if (perlstyle && *s == '@@')
		sv_catpvs(sstr, "\\@@");
	    else if (isPRINT(*s))
		sv_catpvn(sstr, s, 1);
	    else if (*s == '\n')
		sv_catpvs(sstr, "\\n");
	    else if (*s == '\r')
		sv_catpvs(sstr, "\\r");
	    else if (*s == '\t')
		sv_catpvs(sstr, "\\t");
	    else if (*s == '\a')
		sv_catpvs(sstr, "\\a");
	    else if (*s == '\b')
		sv_catpvs(sstr, "\\b");
	    else if (*s == '\f')
		sv_catpvs(sstr, "\\f");
	    else if (!perlstyle && *s == '\v')
		sv_catpvs(sstr, "\\v");
	    else
	    {
		/* Don't want promotion of a signed -1 char in sprintf args */
		const unsigned char c = (unsigned char) *s;
		Perl_sv_catpvf(aTHX_ sstr, "\\%03o", c);
	    }
	    /* XXX Add line breaks if string is long */
	}
    }
    sv_catpvs(sstr, "\"");
    return sstr;
}

static SV *
cchar(pTHX_ SV *sv)
{
    SV *sstr = newSVpvs_flags("'", SVs_TEMP);
    const char *s = SvPV_nolen(sv);
    /* Don't want promotion of a signed -1 char in sprintf args */
    const unsigned char c = (unsigned char) *s;

    if (c == '\'')
	sv_catpvs(sstr, "\\'");
    else if (c == '\\')
	sv_catpvs(sstr, "\\\\");
    else if (isPRINT(c))
	sv_catpvn(sstr, s, 1);
    else if (c == '\n')
	sv_catpvs(sstr, "\\n");
    else if (c == '\r')
	sv_catpvs(sstr, "\\r");
    else if (c == '\t')
	sv_catpvs(sstr, "\\t");
    else if (c == '\a')
	sv_catpvs(sstr, "\\a");
    else if (c == '\b')
	sv_catpvs(sstr, "\\b");
    else if (c == '\f')
	sv_catpvs(sstr, "\\f");
    else if (c == '\v')
	sv_catpvs(sstr, "\\v");
    else
	Perl_sv_catpvf(aTHX_ sstr, "\\%03o", c);
    sv_catpvs(sstr, "'");
    return sstr;
}

#define PMOP_pmreplstart(o)	o->op_pmstashstartu.op_pmreplstart
#define PMOP_pmreplroot(o)	o->op_pmreplrootu.op_pmreplroot

static SV *
walkoptree(pTHX_ OP *o, const char *method, SV *ref)
{
    dSP;
    OP *kid;
    SV *object;
    const char *const classname = opclassnames[cc_opclass(aTHX_ o)];
    dMY_CXT;

    /* Check that no-one has changed our reference, or is holding a reference
       to it.  */
    if (SvREFCNT(ref) == 1 && SvROK(ref) && SvTYPE(ref) == SVt_RV
	&& (object = SvRV(ref)) && SvREFCNT(object) == 1
	&& SvTYPE(object) == SVt_PVMG && SvIOK_only(object)
	&& !SvMAGICAL(object) && !SvMAGIC(object) && SvSTASH(object)) {
	/* Looks good, so rebless it for the class we need:  */
	sv_bless(ref, gv_stashpv(classname, GV_ADD));
    } else {
	/* Need to make a new one. */
	ref = sv_newmortal();
	object = newSVrv(ref, classname);
    }
    sv_setiv(object, PTR2IV(o));

    if (walkoptree_debug) {
	PUSHMARK(sp);
	XPUSHs(ref);
	PUTBACK;
	perl_call_method("walkoptree_debug", G_DISCARD);
    }
    PUSHMARK(sp);
    XPUSHs(ref);
    PUTBACK;
    perl_call_method(method, G_DISCARD);
    if (o && (o->op_flags & OPf_KIDS)) {
	for (kid = ((UNOP*)o)->op_first; kid; kid = OpSIBLING(kid)) {
	    ref = walkoptree(aTHX_ kid, method, ref);
	}
    }
    if (o && (cc_opclass(aTHX_ o) == OPc_PMOP) && o->op_type != OP_PUSHRE
           && (kid = PMOP_pmreplroot(cPMOPo)))
    {
	ref = walkoptree(aTHX_ kid, method, ref);
    }
    return ref;
}

static SV **
oplist(pTHX_ OP *o, SV **SP)
{
    for(; o; o = o->op_next) {
	if (o->op_opt == 0)
	    break;
	o->op_opt = 0;
	XPUSHs(make_op_object(aTHX_ o));
        switch (o->op_type) {
	case OP_SUBST:
            SP = oplist(aTHX_ PMOP_pmreplstart(cPMOPo), SP);
            continue;
	case OP_SORT:
	    if (o->op_flags & OPf_STACKED && o->op_flags & OPf_SPECIAL) {
		OP *kid = OpSIBLING(cLISTOPo->op_first);   /* pass pushmark */
		kid = kUNOP->op_first;                      /* pass rv2gv */
		kid = kUNOP->op_first;                      /* pass leave */
		SP = oplist(aTHX_ kid->op_next, SP);
	    }
	    continue;
        }
	switch (PL_opargs[o->op_type] & OA_CLASS_MASK) {
	case OA_LOGOP:
	    SP = oplist(aTHX_ cLOGOPo->op_other, SP);
	    break;
	case OA_LOOP:
	    SP = oplist(aTHX_ cLOOPo->op_lastop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_nextop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_redoop, SP);
	    break;
	}
    }
    return SP;
}

typedef OP	*B__OP;
typedef UNOP	*B__UNOP;
typedef BINOP	*B__BINOP;
typedef LOGOP	*B__LOGOP;
typedef LISTOP	*B__LISTOP;
typedef PMOP	*B__PMOP;
typedef SVOP	*B__SVOP;
typedef PADOP	*B__PADOP;
typedef PVOP	*B__PVOP;
typedef LOOP	*B__LOOP;
typedef COP	*B__COP;
typedef METHOP  *B__METHOP;

typedef SV	*B__SV;
typedef SV	*B__IV;
typedef SV	*B__PV;
typedef SV	*B__NV;
typedef SV	*B__PVMG;
typedef SV	*B__REGEXP;
typedef SV	*B__PVLV;
typedef SV	*B__BM;
typedef SV	*B__RV;
typedef SV	*B__FM;
typedef AV	*B__AV;
typedef HV	*B__HV;
typedef CV	*B__CV;
typedef GV	*B__GV;
typedef IO	*B__IO;

typedef MAGIC	*B__MAGIC;
typedef HE      *B__HE;
typedef struct refcounted_he	*B__RHE;
#ifdef PadlistARRAY
typedef PADLIST	*B__PADLIST;
#endif
typedef PADNAMELIST *B__PADNAMELIST;
typedef PADNAME	*B__PADNAME;


#ifdef MULTIPLICITY
#  define ASSIGN_COMMON_ALIAS(prefix, var) \
    STMT_START { XSANY.any_i32 = STRUCT_OFFSET(struct interpreter, prefix##var); } STMT_END
#else
#  define ASSIGN_COMMON_ALIAS(prefix, var) \
    STMT_START { XSANY.any_ptr = (void *)&PL_##var; } STMT_END
#endif

/* This needs to be ALIASed in a custom way, hence can't easily be defined as
   a regular XSUB.  */
static XSPROTO(intrpvar_sv_common); /* prototype to pass -Wmissing-prototypes */
static XSPROTO(intrpvar_sv_common)
{
    dVAR;
    dXSARGS;
    SV *ret;
    if (items != 0)
       croak_xs_usage(cv,  "");
#ifdef MULTIPLICITY
    ret = *(SV **)(XSANY.any_i32 + (char *)my_perl);
#else
    ret = *(SV **)(XSANY.any_ptr);
#endif
    ST(0) = make_sv_object(aTHX_ ret);
    XSRETURN(1);
}



#define SVp                 0x0
#define U32p                0x1
#define line_tp             0x2
#define OPp                 0x3
#define PADOFFSETp          0x4
#define U8p                 0x5
#define IVp                 0x6
#define char_pp             0x7
/* Keep this last:  */
#define op_offset_special   0x8

/* table that drives most of the B::*OP methods */

static const struct OP_methods {
    const char *name;
    U8 namelen;
    U8    type; /* if op_offset_special, access is handled on a case-by-case basis */
    U16 offset;
} op_methods[] = {
  { STR_WITH_LEN("next"),    OPp,    STRUCT_OFFSET(struct op, op_next),     },/* 0*/
  { STR_WITH_LEN("sibling"), op_offset_special, 0,                          },/* 1*/
  { STR_WITH_LEN("targ"),    PADOFFSETp, STRUCT_OFFSET(struct op, op_targ), },/* 2*/
  { STR_WITH_LEN("flags"),   U8p,    STRUCT_OFFSET(struct op, op_flags),    },/* 3*/
  { STR_WITH_LEN("private"), U8p,    STRUCT_OFFSET(struct op, op_private),  },/* 4*/
  { STR_WITH_LEN("first"),   OPp,    STRUCT_OFFSET(struct unop, op_first),  },/* 5*/
  { STR_WITH_LEN("last"),    OPp,    STRUCT_OFFSET(struct binop, op_last),  },/* 6*/
  { STR_WITH_LEN("other"),   OPp,    STRUCT_OFFSET(struct logop, op_other), },/* 7*/
  { STR_WITH_LEN("pmreplstart"), op_offset_special, 0,                 },/* 8*/
  { STR_WITH_LEN("redoop"),  OPp,    STRUCT_OFFSET(struct loop, op_redoop), },/* 9*/
  { STR_WITH_LEN("nextop"),  OPp,    STRUCT_OFFSET(struct loop, op_nextop), },/*10*/
  { STR_WITH_LEN("lastop"),  OPp,    STRUCT_OFFSET(struct loop, op_lastop), },/*11*/
  { STR_WITH_LEN("pmflags"), U32p,   STRUCT_OFFSET(struct pmop, op_pmflags),},/*12*/
  { STR_WITH_LEN("code_list"),OPp,   STRUCT_OFFSET(struct pmop, op_code_list),},/*13*/
  { STR_WITH_LEN("sv"),      SVp,     STRUCT_OFFSET(struct svop, op_sv),    },/*14*/
  { STR_WITH_LEN("gv"),      SVp,     STRUCT_OFFSET(struct svop, op_sv),    },/*15*/
  { STR_WITH_LEN("padix"),   PADOFFSETp,STRUCT_OFFSET(struct padop, op_padix),},/*16*/
  { STR_WITH_LEN("cop_seq"), U32p,    STRUCT_OFFSET(struct cop, cop_seq),   },/*17*/
  { STR_WITH_LEN("line"),    line_tp, STRUCT_OFFSET(struct cop, cop_line),  },/*18*/
  { STR_WITH_LEN("hints"),   U32p,    STRUCT_OFFSET(struct cop, cop_hints), },/*19*/
#ifdef USE_ITHREADS
  { STR_WITH_LEN("pmoffset"),IVp,     STRUCT_OFFSET(struct pmop, op_pmoffset),},/*20*/
  { STR_WITH_LEN("filegv"),  op_offset_special, 0,                     },/*21*/
  { STR_WITH_LEN("file"),    char_pp, STRUCT_OFFSET(struct cop, cop_file),  },/*22*/
  { STR_WITH_LEN("stash"),   op_offset_special, 0,                     },/*23*/
  { STR_WITH_LEN("stashpv"), op_offset_special, 0,                     },/*24*/
  { STR_WITH_LEN("stashoff"),PADOFFSETp,STRUCT_OFFSET(struct cop,cop_stashoff),},/*25*/
#else
  { STR_WITH_LEN("pmoffset"),op_offset_special, 0,                     },/*20*/
  { STR_WITH_LEN("filegv"),  SVp,     STRUCT_OFFSET(struct cop, cop_filegv),},/*21*/
  { STR_WITH_LEN("file"),    op_offset_special, 0,                     },/*22*/
  { STR_WITH_LEN("stash"),   SVp,     STRUCT_OFFSET(struct cop, cop_stash), },/*23*/
  { STR_WITH_LEN("stashpv"), op_offset_special, 0,                     },/*24*/
  { STR_WITH_LEN("stashoff"),op_offset_special, 0,                     },/*25*/
#endif
  { STR_WITH_LEN("size"),    op_offset_special, 0,                     },/*26*/
  { STR_WITH_LEN("name"),    op_offset_special, 0,                     },/*27*/
  { STR_WITH_LEN("desc"),    op_offset_special, 0,                     },/*28*/
  { STR_WITH_LEN("ppaddr"),  op_offset_special, 0,                     },/*29*/
  { STR_WITH_LEN("type"),    op_offset_special, 0,                     },/*30*/
  { STR_WITH_LEN("opt"),     op_offset_special, 0,                     },/*31*/
  { STR_WITH_LEN("spare"),   op_offset_special, 0,                     },/*32*/
  { STR_WITH_LEN("children"),op_offset_special, 0,                     },/*33*/
  { STR_WITH_LEN("pmreplroot"), op_offset_special, 0,                  },/*34*/
  { STR_WITH_LEN("pmstashpv"), op_offset_special, 0,                   },/*35*/
  { STR_WITH_LEN("pmstash"), op_offset_special, 0,                     },/*36*/
  { STR_WITH_LEN("precomp"), op_offset_special, 0,                     },/*37*/
  { STR_WITH_LEN("reflags"), op_offset_special, 0,                     },/*38*/
  { STR_WITH_LEN("sv"),      op_offset_special, 0,                     },/*39*/
  { STR_WITH_LEN("gv"),      op_offset_special, 0,                     },/*40*/
  { STR_WITH_LEN("pv"),      op_offset_special, 0,                     },/*41*/
  { STR_WITH_LEN("label"),   op_offset_special, 0,                     },/*42*/
  { STR_WITH_LEN("arybase"), op_offset_special, 0,                     },/*43*/
  { STR_WITH_LEN("warnings"),op_offset_special, 0,                     },/*44*/
  { STR_WITH_LEN("io"),      op_offset_special, 0,                     },/*45*/
  { STR_WITH_LEN("hints_hash"),op_offset_special, 0,                   },/*46*/
  { STR_WITH_LEN("slabbed"), op_offset_special, 0,                     },/*47*/
  { STR_WITH_LEN("savefree"),op_offset_special, 0,                     },/*48*/
  { STR_WITH_LEN("static"),  op_offset_special, 0,                     },/*49*/
  { STR_WITH_LEN("folded"),  op_offset_special, 0,                     },/*50*/
  { STR_WITH_LEN("moresib"), op_offset_special, 0,                     },/*51*/
  { STR_WITH_LEN("parent"),  op_offset_special, 0,                     },/*52*/
  { STR_WITH_LEN("first"),   op_offset_special, 0,                     },/*53*/
  { STR_WITH_LEN("meth_sv"), op_offset_special, 0,                     },/*54*/
  { STR_WITH_LEN("pmregexp"),op_offset_special, 0,                     },/*55*/
#  ifdef USE_ITHREADS
  { STR_WITH_LEN("rclass"),  op_offset_special, 0,                     },/*56*/
#  else
  { STR_WITH_LEN("rclass"),  op_offset_special, 0,                     },/*56*/
#  endif
};

#include "const-c.inc"

MODULE = B	PACKAGE = B

INCLUDE: const-xs.inc

PROTOTYPES: DISABLE

BOOT:
{
    CV *cv;
    const char *file = __FILE__;
    SV *sv;
    MY_CXT_INIT;
    B_init_my_cxt(aTHX_ &(MY_CXT));
    cv = newXS("B::init_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, initav);
    cv = newXS("B::check_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, checkav_save);
    cv = newXS("B::unitcheck_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, unitcheckav_save);
    cv = newXS("B::begin_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, beginav_save);
    cv = newXS("B::end_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, endav);
    cv = newXS("B::main_cv", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, main_cv);
    cv = newXS("B::inc_gv", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, incgv);
    cv = newXS("B::defstash", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, defstash);
    cv = newXS("B::curstash", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, curstash);
#ifdef PL_formfeed
    cv = newXS("B::formfeed", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, formfeed);
#endif
#ifdef USE_ITHREADS
    cv = newXS("B::regex_padav", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, regex_padav);
#endif
    cv = newXS("B::warnhook", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, warnhook);
    cv = newXS("B::diehook", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, diehook);
    sv = get_sv("B::OP::does_parent", GV_ADDMULTI);
#ifdef PERL_OP_PARENT
    sv_setsv(sv, &PL_sv_yes);
#else
    sv_setsv(sv, &PL_sv_no);
#endif
}

#ifndef PL_formfeed

void
formfeed()
    PPCODE:
	PUSHs(make_sv_object(aTHX_ GvSV(gv_fetchpvs("\f", GV_ADD, SVt_PV))));

#endif

long 
amagic_generation()
    CODE:
	RETVAL = PL_amagic_generation;
    OUTPUT:
	RETVAL

void
comppadlist()
    PREINIT:
	PADLIST *padlist = CvPADLIST(PL_main_cv ? PL_main_cv : PL_compcv);
    PPCODE:
#ifdef PadlistARRAY
	{
	    SV * const rv = sv_newmortal();
	    sv_setiv(newSVrv(rv, padlist ? "B::PADLIST" : "B::NULL"),
		     PTR2IV(padlist));
	    PUSHs(rv);
	}
#else
	PUSHs(make_sv_object(aTHX_ (SV *)padlist));
#endif

void
sv_undef()
    ALIAS:
	sv_no = 1
	sv_yes = 2
    PPCODE:
	PUSHs(make_sv_object(aTHX_ ix > 1 ? &PL_sv_yes
					  : ix < 1 ? &PL_sv_undef
						   : &PL_sv_no));

void
main_root()
    ALIAS:
	main_start = 1
    PPCODE:
	PUSHs(make_op_object(aTHX_ ix ? PL_main_start : PL_main_root));

UV
sub_generation()
    ALIAS:
	dowarn = 1
    CODE:
	RETVAL = ix ? PL_dowarn : PL_sub_generation;
    OUTPUT:
	RETVAL

void
walkoptree(op, method)
	B::OP op
	const char *	method
    CODE:
	(void) walkoptree(aTHX_ op, method, &PL_sv_undef);

int
walkoptree_debug(...)
    CODE:
	dMY_CXT;
	RETVAL = walkoptree_debug;
	if (items > 0 && SvTRUE(ST(1)))
	    walkoptree_debug = 1;
    OUTPUT:
	RETVAL

#define address(sv) PTR2IV(sv)

IV
address(sv)
	SV *	sv

void
svref_2object(sv)
	SV *	sv
    PPCODE:
	if (!SvROK(sv))
	    croak("argument is not a reference");
	PUSHs(make_sv_object(aTHX_ SvRV(sv)));

void
opnumber(name)
const char *	name
CODE:
{
 int i; 
 IV  result = -1;
 ST(0) = sv_newmortal();
 if (strncmp(name,"pp_",3) == 0)
   name += 3;
 for (i = 0; i < PL_maxo; i++)
  {
   if (strcmp(name, PL_op_name[i]) == 0)
    {
     result = i;
     break;
    }
  }
 sv_setiv(ST(0),result);
}

void
ppname(opnum)
	int	opnum
    CODE:
	ST(0) = sv_newmortal();
	if (opnum >= 0 && opnum < PL_maxo)
	    Perl_sv_setpvf(aTHX_ ST(0), "pp_%s", PL_op_name[opnum]);

void
hash(sv)
	SV *	sv
    CODE:
	STRLEN len;
	U32 hash = 0;
	const char *s = SvPVbyte(sv, len);
	PERL_HASH(hash, s, len);
	ST(0) = sv_2mortal(Perl_newSVpvf(aTHX_ "0x%"UVxf, (UV)hash));

#define cast_I32(foo) (I32)foo
IV
cast_I32(i)
	IV	i

void
minus_c()
    ALIAS:
	save_BEGINs = 1
    CODE:
	if (ix)
	    PL_savebegin = TRUE;
	else
	    PL_minus_c = TRUE;

void
cstring(sv)
	SV *	sv
    ALIAS:
	perlstring = 1
	cchar = 2
    PPCODE:
	PUSHs(ix == 2 ? cchar(aTHX_ sv) : cstring(aTHX_ sv, (bool)ix));

void
threadsv_names()
    PPCODE:


#ifdef USE_ITHREADS
void
CLONE(...)
PPCODE:
    PUTBACK; /* some vars go out of scope now in machine code */
    {
	MY_CXT_CLONE;
	B_init_my_cxt(aTHX_ &(MY_CXT));
    }
    return; /* dont execute another implied XSPP PUTBACK */

#endif

MODULE = B	PACKAGE = B::OP


# The type checking code in B has always been identical for all OP types,
# irrespective of whether the action is actually defined on that OP.
# We should fix this
void
next(o)
	B::OP		o
    ALIAS:
	B::OP::next          =  0
	B::OP::sibling       =  1
	B::OP::targ          =  2
	B::OP::flags         =  3
	B::OP::private       =  4
	B::UNOP::first       =  5
	B::BINOP::last       =  6
	B::LOGOP::other      =  7
	B::PMOP::pmreplstart =  8
	B::LOOP::redoop      =  9
	B::LOOP::nextop      = 10
	B::LOOP::lastop      = 11
	B::PMOP::pmflags     = 12
	B::PMOP::code_list   = 13
	B::SVOP::sv          = 14
	B::SVOP::gv          = 15
	B::PADOP::padix      = 16
	B::COP::cop_seq      = 17
	B::COP::line         = 18
	B::COP::hints        = 19
	B::PMOP::pmoffset    = 20
	B::COP::filegv       = 21
	B::COP::file         = 22
	B::COP::stash        = 23
	B::COP::stashpv      = 24
	B::COP::stashoff     = 25
	B::OP::size          = 26
	B::OP::name          = 27
	B::OP::desc          = 28
	B::OP::ppaddr        = 29
	B::OP::type          = 30
	B::OP::opt           = 31
	B::OP::spare         = 32
	B::LISTOP::children  = 33
	B::PMOP::pmreplroot  = 34
	B::PMOP::pmstashpv   = 35
	B::PMOP::pmstash     = 36
	B::PMOP::precomp     = 37
	B::PMOP::reflags     = 38
	B::PADOP::sv         = 39
	B::PADOP::gv         = 40
	B::PVOP::pv          = 41
	B::COP::label        = 42
	B::COP::arybase      = 43
	B::COP::warnings     = 44
	B::COP::io           = 45
	B::COP::hints_hash   = 46
	B::OP::slabbed       = 47
	B::OP::savefree      = 48
	B::OP::static        = 49
	B::OP::folded        = 50
	B::OP::moresib       = 51
	B::OP::parent        = 52
	B::METHOP::first     = 53
	B::METHOP::meth_sv   = 54
	B::PMOP::pmregexp    = 55
	B::METHOP::rclass    = 56
    PREINIT:
	SV *ret;
    PPCODE:
	if (ix < 0 || (U32)ix >= C_ARRAY_LENGTH(op_methods))
	    croak("Illegal alias %d for B::*OP::next", (int)ix);
	ret = get_overlay_object(aTHX_ o,
			    op_methods[ix].name, op_methods[ix].namelen);
	if (ret) {
	    ST(0) = ret;
	    XSRETURN(1);
	}

	/* handle non-direct field access */

	if (op_methods[ix].type == op_offset_special)
	    switch (ix) {
	    case 1: /* B::OP::op_sibling */
		ret = make_op_object(aTHX_ OpSIBLING(o));
		break;

	    case 8: /* B::PMOP::pmreplstart */
		ret = make_op_object(aTHX_
				cPMOPo->op_type == OP_SUBST
				    ?  cPMOPo->op_pmstashstartu.op_pmreplstart
				    : NULL
		      );
		break;
#ifdef USE_ITHREADS
	    case 21: /* B::COP::filegv */
		ret = make_sv_object(aTHX_ (SV *)CopFILEGV((COP*)o));
		break;
#endif
#ifndef USE_ITHREADS
	    case 22: /* B::COP::file */
		ret = sv_2mortal(newSVpv(CopFILE((COP*)o), 0));
		break;
#endif
#ifdef USE_ITHREADS
	    case 23: /* B::COP::stash */
		ret = make_sv_object(aTHX_ (SV *)CopSTASH((COP*)o));
		break;
#endif
	    case 24: /* B::COP::stashpv */
		ret = sv_2mortal(CopSTASH((COP*)o)
				&& SvTYPE(CopSTASH((COP*)o)) == SVt_PVHV
		    ? newSVhek(HvNAME_HEK(CopSTASH((COP*)o)))
		    : &PL_sv_undef);
		break;
	    case 26: /* B::OP::size */
		ret = sv_2mortal(newSVuv((UV)(opsizes[cc_opclass(aTHX_ o)])));
		break;
	    case 27: /* B::OP::name */
	    case 28: /* B::OP::desc */
		ret = sv_2mortal(newSVpv(
			    (char *)(ix == 28 ? OP_DESC(o) : OP_NAME(o)), 0));
		break;
	    case 29: /* B::OP::ppaddr */
		{
		    int i;
		    ret = sv_2mortal(Perl_newSVpvf(aTHX_ "PL_ppaddr[OP_%s]",
						  PL_op_name[o->op_type]));
		    for (i=13; (STRLEN)i < SvCUR(ret); ++i)
			SvPVX(ret)[i] = toUPPER(SvPVX(ret)[i]);
		}
		break;
	    case 30: /* B::OP::type  */
	    case 31: /* B::OP::opt   */
	    case 32: /* B::OP::spare */
	    case 47: /* B::OP::slabbed  */
	    case 48: /* B::OP::savefree */
	    case 49: /* B::OP::static   */
	    case 50: /* B::OP::folded   */
	    case 51: /* B::OP::moresib  */
	    /* These are all bitfields, so we can't take their addresses */
		ret = sv_2mortal(newSVuv((UV)(
				      ix == 30 ? o->op_type
		                    : ix == 31 ? o->op_opt
		                    : ix == 47 ? o->op_slabbed
		                    : ix == 48 ? o->op_savefree
		                    : ix == 49 ? o->op_static
		                    : ix == 50 ? o->op_folded
		                    : ix == 51 ? o->op_moresib
		                    :            o->op_spare)));
		break;
	    case 33: /* B::LISTOP::children */
		{
		    OP *kid;
		    UV i = 0;
		    for (kid = ((LISTOP*)o)->op_first; kid; kid = OpSIBLING(kid))
			i++;
		    ret = sv_2mortal(newSVuv(i));
		}
		break;
	    case 34: /* B::PMOP::pmreplroot */
		if (cPMOPo->op_type == OP_PUSHRE) {
#ifdef USE_ITHREADS
		    ret = sv_newmortal();
		    sv_setiv(ret, cPMOPo->op_pmreplrootu.op_pmtargetoff);
#else
		    GV *const target = cPMOPo->op_pmreplrootu.op_pmtargetgv;
		    ret = sv_newmortal();
		    sv_setiv(newSVrv(ret, target ?
				     svclassnames[SvTYPE((SV*)target)] : "B::SV"),
			     PTR2IV(target));
#endif
		}
		else {
		    OP *const root = cPMOPo->op_pmreplrootu.op_pmreplroot;
		    ret = make_op_object(aTHX_ root);
		}
		break;
#ifdef USE_ITHREADS
	    case 35: /* B::PMOP::pmstashpv */
		ret = sv_2mortal(newSVpv(PmopSTASHPV(cPMOPo),0));
		break;
#else
	    case 36: /* B::PMOP::pmstash */
		ret = make_sv_object(aTHX_ (SV *) PmopSTASH(cPMOPo));
		break;
#endif
	    case 37: /* B::PMOP::precomp */
	    case 38: /* B::PMOP::reflags */
		{
		    REGEXP *rx = PM_GETRE(cPMOPo);
		    ret = sv_newmortal();
		    if (rx) {
			if (ix==38) {
			    sv_setuv(ret, RX_EXTFLAGS(rx));
			}
			else {
			    sv_setpvn(ret, RX_PRECOMP(rx), RX_PRELEN(rx));
                            if (RX_UTF8(rx))
                                SvUTF8_on(ret);
			}
		    }
		}
		break;
	    case 39: /* B::PADOP::sv */
	    case 40: /* B::PADOP::gv */
		/* PADOPs should only be created on threaded builds.
                 * They don't have an sv or gv field, just an op_padix
                 * field. Leave it to the caller to retrieve padix
                 * and look up th value in the pad. Don't do it here,
                 * becuase PL_curpad is the pad of the caller, not the
                 * pad of the sub the op is part of */
		ret = make_sv_object(aTHX_ NULL);
		break;
	    case 41: /* B::PVOP::pv */
		/* OP_TRANS uses op_pv to point to a table of 256 or >=258
		 * shorts whereas other PVOPs point to a null terminated
		 * string.  */
		if (    (cPVOPo->op_type == OP_TRANS
			|| cPVOPo->op_type == OP_TRANSR) &&
			(cPVOPo->op_private & OPpTRANS_COMPLEMENT) &&
			!(cPVOPo->op_private & OPpTRANS_DELETE))
		{
		    const short* const tbl = (short*)cPVOPo->op_pv;
		    const short entries = 257 + tbl[256];
		    ret = newSVpvn_flags(cPVOPo->op_pv, entries * sizeof(short), SVs_TEMP);
		}
		else if (cPVOPo->op_type == OP_TRANS || cPVOPo->op_type == OP_TRANSR) {
		    ret = newSVpvn_flags(cPVOPo->op_pv, 256 * sizeof(short), SVs_TEMP);
		}
		else
		    ret = newSVpvn_flags(cPVOPo->op_pv, strlen(cPVOPo->op_pv), SVs_TEMP);
		break;
	    case 42: /* B::COP::label */
		ret = sv_2mortal(newSVpv(CopLABEL(cCOPo),0));
		break;
	    case 43: /* B::COP::arybase */
		ret = sv_2mortal(newSVuv(0));
		break;
	    case 44: /* B::COP::warnings */
		ret = make_warnings_object(aTHX_ cCOPo);
		break;
	    case 45: /* B::COP::io */
		ret = make_cop_io_object(aTHX_ cCOPo);
		break;
	    case 46: /* B::COP::hints_hash */
		ret = sv_newmortal();
		sv_setiv(newSVrv(ret, "B::RHE"),
			PTR2IV(CopHINTHASH_get(cCOPo)));
		break;
	    case 52: /* B::OP::parent */
#ifdef PERL_OP_PARENT
		ret = make_op_object(aTHX_ op_parent(o));
#else
		ret = make_op_object(aTHX_ NULL);
#endif
		break;
	    case 53: /* B::METHOP::first   */
                /* METHOP struct has an op_first/op_meth_sv union
                 * as its first extra field. How to interpret the
                 * union depends on the op type. For the purposes of
                 * B, we treat it as a struct with both fields present,
                 * where one of the fields always happens to be null
                 * (i.e. we return NULL in preference to croaking with
                 * 'method not implemented').
                 */
		ret = make_op_object(aTHX_
                            o->op_type == OP_METHOD
                                ? cMETHOPx(o)->op_u.op_first : NULL);
		break;
	    case 54: /* B::METHOP::meth_sv */
                /* see comment above about METHOP */
		ret = make_sv_object(aTHX_
                            o->op_type == OP_METHOD
                                ? NULL : cMETHOPx(o)->op_u.op_meth_sv);
		break;
	    case 55: /* B::PMOP::pmregexp */
		ret = make_sv_object(aTHX_ (SV *)PM_GETRE(cPMOPo));
		break;
	    case 56: /* B::METHOP::rclass */
#ifdef USE_ITHREADS
		ret = sv_2mortal(newSVuv(
		    (o->op_type == OP_METHOD_REDIR ||
		     o->op_type == OP_METHOD_REDIR_SUPER) ?
		      cMETHOPx(o)->op_rclass_targ : 0
		));
#else
		ret = make_sv_object(aTHX_
		    (o->op_type == OP_METHOD_REDIR ||
		     o->op_type == OP_METHOD_REDIR_SUPER) ?
		      cMETHOPx(o)->op_rclass_sv : NULL
		);
#endif
		break;
	    default:
		croak("method %s not implemented", op_methods[ix].name);
	} else {
	    /* do a direct structure offset lookup */
	    const char *const ptr = (char *)o + op_methods[ix].offset;
	    switch (op_methods[ix].type) {
	    case OPp:
		ret = make_op_object(aTHX_ *((OP **)ptr));
		break;
	    case PADOFFSETp:
		ret = sv_2mortal(newSVuv(*((PADOFFSET*)ptr)));
		break;
	    case U8p:
		ret = sv_2mortal(newSVuv(*((U8*)ptr)));
		break;
	    case U32p:
		ret = sv_2mortal(newSVuv(*((U32*)ptr)));
		break;
	    case SVp:
		ret = make_sv_object(aTHX_ *((SV **)ptr));
		break;
	    case line_tp:
		ret = sv_2mortal(newSVuv(*((line_t *)ptr)));
		break;
	    case IVp:
		ret = sv_2mortal(newSViv(*((IV*)ptr)));
		break;
	    case char_pp:
		ret = sv_2mortal(newSVpv(*((char **)ptr), 0));
		break;
	    default:
		croak("Illegal type 0x%x for B::*OP::%s",
		      (unsigned)op_methods[ix].type, op_methods[ix].name);
	    }
	}
	ST(0) = ret;
	XSRETURN(1);


void
oplist(o)
	B::OP		o
    PPCODE:
	SP = oplist(aTHX_ o, SP);



MODULE = B	PACKAGE = B::UNOP_AUX

# UNOP_AUX class ops are like UNOPs except that they have an extra
# op_aux pointer that points to an array of UNOP_AUX_item unions.
# Element -1 of the array contains the length


# return a string representation of op_aux where possible The op's CV is
# needed as an extra arg to allow GVs and SVs moved into the pad to be
# accessed okay.

void
string(o, cv)
	B::OP  o
	B::CV  cv
    PREINIT:
	SV *ret;
    PPCODE:
        switch (o->op_type) {
        case OP_MULTIDEREF:
            ret = multideref_stringify(o, cv);
            break;
        default:
            ret = sv_2mortal(newSVpvn("", 0));
        }
	ST(0) = ret;
	XSRETURN(1);


# Return the contents of the op_aux array as a list of IV/GV/etc objects.
# How to interpret each array element is op-dependent. The op's CV is
# needed as an extra arg to allow GVs and SVs which have been moved into
# the pad to be accessed okay.

void
aux_list(o, cv)
	B::OP  o
	B::CV  cv
    PPCODE:
        PERL_UNUSED_VAR(cv); /* not needed on unthreaded builds */
        switch (o->op_type) {
        default:
            XSRETURN(0); /* by default, an empty list */

        case OP_MULTIDEREF:
#ifdef USE_ITHREADS
#  define ITEM_SV(item) *av_fetch(comppad, (item)->pad_offset, FALSE);
#else
#  define ITEM_SV(item) UNOP_AUX_item_sv(item)
#endif
            {
                UNOP_AUX_item *items = cUNOP_AUXo->op_aux;
                UV actions = items->uv;
                UV len = items[-1].uv;
                SV *sv;
                bool last = 0;
                bool is_hash = FALSE;
#ifdef USE_ITHREADS
                PADLIST * const padlist = CvPADLIST(cv);
                PAD *comppad = PadlistARRAY(padlist)[1];
#endif

                /* len should never be big enough to truncate or wrap */
                assert(len <= SSize_t_MAX);
                EXTEND(SP, (SSize_t)len);
                PUSHs(sv_2mortal(newSViv(actions)));

                while (!last) {
                    switch (actions & MDEREF_ACTION_MASK) {

                    case MDEREF_reload:
                        actions = (++items)->uv;
                        PUSHs(sv_2mortal(newSVuv(actions)));
                        continue;
                        NOT_REACHED; /* NOTREACHED */

                    case MDEREF_HV_padhv_helem:
                        is_hash = TRUE;
                        /* FALLTHROUGH */
                    case MDEREF_AV_padav_aelem:
                        PUSHs(sv_2mortal(newSVuv((++items)->pad_offset)));
                        goto do_elem;
                        NOT_REACHED; /* NOTREACHED */

                    case MDEREF_HV_gvhv_helem:
                        is_hash = TRUE;
                        /* FALLTHROUGH */
                    case MDEREF_AV_gvav_aelem:
                        sv = ITEM_SV(++items);
                        PUSHs(make_sv_object(aTHX_ sv));
                        goto do_elem;
                        NOT_REACHED; /* NOTREACHED */

                    case MDEREF_HV_gvsv_vivify_rv2hv_helem:
                        is_hash = TRUE;
                        /* FALLTHROUGH */
                    case MDEREF_AV_gvsv_vivify_rv2av_aelem:
                        sv = ITEM_SV(++items);
                        PUSHs(make_sv_object(aTHX_ sv));
                        goto do_vivify_rv2xv_elem;
                        NOT_REACHED; /* NOTREACHED */

                    case MDEREF_HV_padsv_vivify_rv2hv_helem:
                        is_hash = TRUE;
                        /* FALLTHROUGH */
                    case MDEREF_AV_padsv_vivify_rv2av_aelem:
                        PUSHs(sv_2mortal(newSVuv((++items)->pad_offset)));
                        goto do_vivify_rv2xv_elem;
                        NOT_REACHED; /* NOTREACHED */

                    case MDEREF_HV_pop_rv2hv_helem:
                    case MDEREF_HV_vivify_rv2hv_helem:
                        is_hash = TRUE;
                        /* FALLTHROUGH */
                    do_vivify_rv2xv_elem:
                    case MDEREF_AV_pop_rv2av_aelem:
                    case MDEREF_AV_vivify_rv2av_aelem:
                    do_elem:
                        switch (actions & MDEREF_INDEX_MASK) {
                        case MDEREF_INDEX_none:
                            last = 1;
                            break;
                        case MDEREF_INDEX_const:
                            if (is_hash) {
                                sv = ITEM_SV(++items);
                                PUSHs(make_sv_object(aTHX_ sv));
                            }
                            else
                                PUSHs(sv_2mortal(newSViv((++items)->iv)));
                            break;
                        case MDEREF_INDEX_padsv:
                            PUSHs(sv_2mortal(newSVuv((++items)->pad_offset)));
                            break;
                        case MDEREF_INDEX_gvsv:
                            sv = ITEM_SV(++items);
                            PUSHs(make_sv_object(aTHX_ sv));
                            break;
                        }
                        if (actions & MDEREF_FLAG_last)
                            last = 1;
                        is_hash = FALSE;

                        break;
                    } /* switch */

                    actions >>= MDEREF_SHIFT;
                } /* while */
                XSRETURN(len);

            } /* OP_MULTIDEREF */
        } /* switch */



MODULE = B	PACKAGE = B::SV

#define MAGICAL_FLAG_BITS (SVs_GMG|SVs_SMG|SVs_RMG)

U32
REFCNT(sv)
	B::SV	sv
    ALIAS:
	FLAGS = 0xFFFFFFFF
	SvTYPE = SVTYPEMASK
	POK = SVf_POK
	ROK = SVf_ROK
	MAGICAL = MAGICAL_FLAG_BITS
    CODE:
	RETVAL = ix ? (SvFLAGS(sv) & (U32)ix) : SvREFCNT(sv);
    OUTPUT:
	RETVAL

void
object_2svref(sv)
	B::SV	sv
    PPCODE:
	ST(0) = sv_2mortal(newRV(sv));
	XSRETURN(1);
	
MODULE = B	PACKAGE = B::IV		PREFIX = Sv

IV
SvIV(sv)
	B::IV	sv

MODULE = B	PACKAGE = B::IV

#define sv_SVp		0x00000
#define sv_IVp		0x10000
#define sv_UVp		0x20000
#define sv_STRLENp	0x30000
#define sv_U32p		0x40000
#define sv_U8p		0x50000
#define sv_char_pp	0x60000
#define sv_NVp		0x70000
#define sv_char_p	0x80000
#define sv_SSize_tp	0x90000
#define sv_I32p		0xA0000
#define sv_U16p		0xB0000

#define IV_ivx_ix	sv_IVp | STRUCT_OFFSET(struct xpviv, xiv_iv)
#define IV_uvx_ix	sv_UVp | STRUCT_OFFSET(struct xpvuv, xuv_uv)
#define NV_nvx_ix	sv_NVp | STRUCT_OFFSET(struct xpvnv, xnv_u.xnv_nv)

#define PV_cur_ix	sv_STRLENp | STRUCT_OFFSET(struct xpv, xpv_cur)
#define PV_len_ix	sv_STRLENp | STRUCT_OFFSET(struct xpv, xpv_len)

#define PVMG_stash_ix	sv_SVp | STRUCT_OFFSET(struct xpvmg, xmg_stash)

#define PVBM_useful_ix	sv_IVp | STRUCT_OFFSET(struct xpviv, xiv_u.xivu_iv)

#define PVLV_targoff_ix	sv_U32p | STRUCT_OFFSET(struct xpvlv, xlv_targoff)
#define PVLV_targlen_ix	sv_U32p | STRUCT_OFFSET(struct xpvlv, xlv_targlen)
#define PVLV_targ_ix	sv_SVp | STRUCT_OFFSET(struct xpvlv, xlv_targ)
#define PVLV_type_ix	sv_char_p | STRUCT_OFFSET(struct xpvlv, xlv_type)

#define PVGV_stash_ix	sv_SVp | STRUCT_OFFSET(struct xpvgv, xnv_u.xgv_stash)
#define PVGV_flags_ix	sv_STRLENp | STRUCT_OFFSET(struct xpvgv, xpv_cur)
#define PVIO_lines_ix	sv_IVp | STRUCT_OFFSET(struct xpvio, xiv_iv)

#define PVIO_page_ix	    sv_IVp | STRUCT_OFFSET(struct xpvio, xio_page)
#define PVIO_page_len_ix    sv_IVp | STRUCT_OFFSET(struct xpvio, xio_page_len)
#define PVIO_lines_left_ix  sv_IVp | STRUCT_OFFSET(struct xpvio, xio_lines_left)
#define PVIO_top_name_ix    sv_char_pp | STRUCT_OFFSET(struct xpvio, xio_top_name)
#define PVIO_top_gv_ix	    sv_SVp | STRUCT_OFFSET(struct xpvio, xio_top_gv)
#define PVIO_fmt_name_ix    sv_char_pp | STRUCT_OFFSET(struct xpvio, xio_fmt_name)
#define PVIO_fmt_gv_ix	    sv_SVp | STRUCT_OFFSET(struct xpvio, xio_fmt_gv)
#define PVIO_bottom_name_ix sv_char_pp | STRUCT_OFFSET(struct xpvio, xio_bottom_name)
#define PVIO_bottom_gv_ix   sv_SVp | STRUCT_OFFSET(struct xpvio, xio_bottom_gv)
#define PVIO_type_ix	    sv_char_p | STRUCT_OFFSET(struct xpvio, xio_type)
#define PVIO_flags_ix	    sv_U8p | STRUCT_OFFSET(struct xpvio, xio_flags)

#define PVAV_max_ix	sv_SSize_tp | STRUCT_OFFSET(struct xpvav, xav_max)

#define PVCV_stash_ix	sv_SVp | STRUCT_OFFSET(struct xpvcv, xcv_stash) 
#define PVCV_gv_ix	sv_SVp | STRUCT_OFFSET(struct xpvcv, xcv_gv_u.xcv_gv)
#define PVCV_file_ix	sv_char_pp | STRUCT_OFFSET(struct xpvcv, xcv_file)
#define PVCV_outside_ix	sv_SVp | STRUCT_OFFSET(struct xpvcv, xcv_outside)
#define PVCV_outside_seq_ix sv_U32p | STRUCT_OFFSET(struct xpvcv, xcv_outside_seq)
#define PVCV_flags_ix	sv_U32p | STRUCT_OFFSET(struct xpvcv, xcv_flags)

#define PVHV_max_ix	sv_STRLENp | STRUCT_OFFSET(struct xpvhv, xhv_max)
#define PVHV_keys_ix	sv_STRLENp | STRUCT_OFFSET(struct xpvhv, xhv_keys)

# The type checking code in B has always been identical for all SV types,
# irrespective of whether the action is actually defined on that SV.
# We should fix this
void
IVX(sv)
	B::SV		sv
    ALIAS:
	B::IV::IVX = IV_ivx_ix
	B::IV::UVX = IV_uvx_ix
	B::NV::NVX = NV_nvx_ix
	B::PV::CUR = PV_cur_ix
	B::PV::LEN = PV_len_ix
	B::PVMG::SvSTASH = PVMG_stash_ix
	B::PVLV::TARGOFF = PVLV_targoff_ix
	B::PVLV::TARGLEN = PVLV_targlen_ix
	B::PVLV::TARG = PVLV_targ_ix
	B::PVLV::TYPE = PVLV_type_ix
	B::GV::STASH = PVGV_stash_ix
	B::GV::GvFLAGS = PVGV_flags_ix
	B::BM::USEFUL = PVBM_useful_ix
	B::IO::LINES =  PVIO_lines_ix
	B::IO::PAGE = PVIO_page_ix
	B::IO::PAGE_LEN = PVIO_page_len_ix
	B::IO::LINES_LEFT = PVIO_lines_left_ix
	B::IO::TOP_NAME = PVIO_top_name_ix
	B::IO::TOP_GV = PVIO_top_gv_ix
	B::IO::FMT_NAME = PVIO_fmt_name_ix
	B::IO::FMT_GV = PVIO_fmt_gv_ix
	B::IO::BOTTOM_NAME = PVIO_bottom_name_ix
	B::IO::BOTTOM_GV = PVIO_bottom_gv_ix
	B::IO::IoTYPE = PVIO_type_ix
	B::IO::IoFLAGS = PVIO_flags_ix
	B::AV::MAX = PVAV_max_ix
	B::CV::STASH = PVCV_stash_ix
	B::CV::FILE = PVCV_file_ix
	B::CV::OUTSIDE = PVCV_outside_ix
	B::CV::OUTSIDE_SEQ = PVCV_outside_seq_ix
	B::CV::CvFLAGS = PVCV_flags_ix
	B::HV::MAX = PVHV_max_ix
	B::HV::KEYS = PVHV_keys_ix
    PREINIT:
	char *ptr;
	SV *ret;
    PPCODE:
	ptr = (ix & 0xFFFF) + (char *)SvANY(sv);
	switch ((U8)(ix >> 16)) {
	case (U8)(sv_SVp >> 16):
	    ret = make_sv_object(aTHX_ *((SV **)ptr));
	    break;
	case (U8)(sv_IVp >> 16):
	    ret = sv_2mortal(newSViv(*((IV *)ptr)));
	    break;
	case (U8)(sv_UVp >> 16):
	    ret = sv_2mortal(newSVuv(*((UV *)ptr)));
	    break;
	case (U8)(sv_STRLENp >> 16):
	    ret = sv_2mortal(newSVuv(*((STRLEN *)ptr)));
	    break;
	case (U8)(sv_U32p >> 16):
	    ret = sv_2mortal(newSVuv(*((U32 *)ptr)));
	    break;
	case (U8)(sv_U8p >> 16):
	    ret = sv_2mortal(newSVuv(*((U8 *)ptr)));
	    break;
	case (U8)(sv_char_pp >> 16):
	    ret = sv_2mortal(newSVpv(*((char **)ptr), 0));
	    break;
	case (U8)(sv_NVp >> 16):
	    ret = sv_2mortal(newSVnv(*((NV *)ptr)));
	    break;
	case (U8)(sv_char_p >> 16):
	    ret = newSVpvn_flags((char *)ptr, 1, SVs_TEMP);
	    break;
	case (U8)(sv_SSize_tp >> 16):
	    ret = sv_2mortal(newSViv(*((SSize_t *)ptr)));
	    break;
	case (U8)(sv_I32p >> 16):
	    ret = sv_2mortal(newSVuv(*((I32 *)ptr)));
	    break;
	case (U8)(sv_U16p >> 16):
	    ret = sv_2mortal(newSVuv(*((U16 *)ptr)));
	    break;
	default:
	    croak("Illegal alias 0x%08x for B::*IVX", (unsigned)ix);
	}
	ST(0) = ret;
	XSRETURN(1);

void
packiv(sv)
	B::IV	sv
    ALIAS:
	needs64bits = 1
    CODE:
	if (ix) {
	    ST(0) = boolSV((I32)SvIVX(sv) != SvIVX(sv));
	} else if (sizeof(IV) == 8) {
	    U32 wp[2];
	    const IV iv = SvIVX(sv);
	    /*
	     * The following way of spelling 32 is to stop compilers on
	     * 32-bit architectures from moaning about the shift count
	     * being >= the width of the type. Such architectures don't
	     * reach this code anyway (unless sizeof(IV) > 8 but then
	     * everything else breaks too so I'm not fussed at the moment).
	     */
#ifdef UV_IS_QUAD
	    wp[0] = htonl(((UV)iv) >> (sizeof(UV)*4));
#else
	    wp[0] = htonl(((U32)iv) >> (sizeof(UV)*4));
#endif
	    wp[1] = htonl(iv & 0xffffffff);
	    ST(0) = newSVpvn_flags((char *)wp, 8, SVs_TEMP);
	} else {
	    U32 w = htonl((U32)SvIVX(sv));
	    ST(0) = newSVpvn_flags((char *)&w, 4, SVs_TEMP);
	}

MODULE = B	PACKAGE = B::NV		PREFIX = Sv

NV
SvNV(sv)
	B::NV	sv

MODULE = B	PACKAGE = B::REGEXP

void
REGEX(sv)
	B::REGEXP	sv
    ALIAS:
	precomp = 1
	qr_anoncv = 2
	compflags = 3
    PPCODE:
	if (ix == 1) {
	    PUSHs(newSVpvn_flags(RX_PRECOMP(sv), RX_PRELEN(sv), SVs_TEMP));
	} else if (ix == 2) {
	    PUSHs(make_sv_object(aTHX_ (SV *)ReANY(sv)->qr_anoncv));
	} else {
	    dXSTARG;
	    if (ix)
		PUSHu(RX_COMPFLAGS(sv));
	    else
	    /* FIXME - can we code this method more efficiently?  */
		PUSHi(PTR2IV(sv));
	}

MODULE = B	PACKAGE = B::PV

void
RV(sv)
        B::PV   sv
    PPCODE:
        if (!SvROK(sv))
            croak( "argument is not SvROK" );
	PUSHs(make_sv_object(aTHX_ SvRV(sv)));

void
PV(sv)
	B::PV	sv
    ALIAS:
	PVX = 1
	PVBM = 2
	B::BM::TABLE = 3
    PREINIT:
	const char *p;
	STRLEN len = 0;
	U32 utf8 = 0;
    CODE:
	if (ix == 3) {
#ifndef PERL_FBM_TABLE_OFFSET
	    const MAGIC *const mg = mg_find(sv, PERL_MAGIC_bm);

	    if (!mg)
                croak("argument to B::BM::TABLE is not a PVBM");
	    p = mg->mg_ptr;
	    len = mg->mg_len;
#else
	    p = SvPV(sv, len);
	    /* Boyer-Moore table is just after string and its safety-margin \0 */
	    p += len + PERL_FBM_TABLE_OFFSET;
	    len = 256;
#endif
	} else if (ix == 2) {
	    /* This used to read 257. I think that that was buggy - should have
	       been 258. (The "\0", the flags byte, and 256 for the table.)
	       The only user of this method is B::Bytecode in B::PV::bsave.
	       I'm guessing that nothing tested the runtime correctness of
	       output of bytecompiled string constant arguments to index (etc).

	       Note the start pointer is and has always been SvPVX(sv), not
	       SvPVX(sv) + SvCUR(sv) PVBM was added in 651aa52ea1faa806, and
	       first used by the compiler in 651aa52ea1faa806. It's used to
	       get a "complete" dump of the buffer at SvPVX(), not just the
	       PVBM table. This permits the generated bytecode to "load"
	       SvPVX in "one" hit.

	       5.15 and later store the BM table via MAGIC, so the compiler
	       should handle this just fine without changes if PVBM now
	       always returns the SvPVX() buffer.  */
#ifdef isREGEXP
	    p = isREGEXP(sv)
		 ? RX_WRAPPED_const((REGEXP*)sv)
		 : SvPVX_const(sv);
#else
	    p = SvPVX_const(sv);
#endif
#ifdef PERL_FBM_TABLE_OFFSET
	    len = SvCUR(sv) + (SvVALID(sv) ? 256 + PERL_FBM_TABLE_OFFSET : 0);
#else
	    len = SvCUR(sv);
#endif
	} else if (ix) {
#ifdef isREGEXP
	    p = isREGEXP(sv) ? RX_WRAPPED((REGEXP*)sv) : SvPVX(sv);
#else
	    p = SvPVX(sv);
#endif
	    len = strlen(p);
	} else if (SvPOK(sv)) {
	    len = SvCUR(sv);
	    p = SvPVX_const(sv);
	    utf8 = SvUTF8(sv);
        }
#ifdef isREGEXP
	else if (isREGEXP(sv)) {
	    len = SvCUR(sv);
	    p = RX_WRAPPED_const((REGEXP*)sv);
	    utf8 = SvUTF8(sv);
	}
#endif
        else {
            /* XXX for backward compatibility, but should fail */
            /* croak( "argument is not SvPOK" ); */
	    p = NULL;
        }
	ST(0) = newSVpvn_flags(p, len, SVs_TEMP | utf8);

MODULE = B	PACKAGE = B::PVMG

void
MAGIC(sv)
	B::PVMG	sv
	MAGIC *	mg = NO_INIT
    PPCODE:
	for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic)
	    XPUSHs(make_mg_object(aTHX_ mg));

MODULE = B	PACKAGE = B::MAGIC

void
MOREMAGIC(mg)
	B::MAGIC	mg
    ALIAS:
	PRIVATE = 1
	TYPE = 2
	FLAGS = 3
	LENGTH = 4
	OBJ = 5
	PTR = 6
	REGEX = 7
	precomp = 8
    PPCODE:
	switch (ix) {
	case 0:
	    XPUSHs(mg->mg_moremagic ? make_mg_object(aTHX_ mg->mg_moremagic)
				    : &PL_sv_undef);
	    break;
	case 1:
	    mPUSHu(mg->mg_private);
	    break;
	case 2:
	    PUSHs(newSVpvn_flags(&(mg->mg_type), 1, SVs_TEMP));
	    break;
	case 3:
	    mPUSHu(mg->mg_flags);
	    break;
	case 4:
	    mPUSHi(mg->mg_len);
	    break;
	case 5:
	    PUSHs(make_sv_object(aTHX_ mg->mg_obj));
	    break;
	case 6:
	    if (mg->mg_ptr) {
		if (mg->mg_len >= 0) {
		    PUSHs(newSVpvn_flags(mg->mg_ptr, mg->mg_len, SVs_TEMP));
		} else if (mg->mg_len == HEf_SVKEY) {
		    PUSHs(make_sv_object(aTHX_ (SV*)mg->mg_ptr));
		} else
		    PUSHs(sv_newmortal());
	    } else
		PUSHs(sv_newmortal());
	    break;
	case 7:
	    if(mg->mg_type == PERL_MAGIC_qr) {
                mPUSHi(PTR2IV(mg->mg_obj));
	    } else {
		croak("REGEX is only meaningful on r-magic");
	    }
	    break;
	case 8:
	    if (mg->mg_type == PERL_MAGIC_qr) {
		REGEXP *rx = (REGEXP *)mg->mg_obj;
		PUSHs(newSVpvn_flags(rx ? RX_PRECOMP(rx) : NULL,
				     rx ? RX_PRELEN(rx) : 0, SVs_TEMP));
	    } else {
		croak( "precomp is only meaningful on r-magic" );
	    }
	    break;
	}

MODULE = B	PACKAGE = B::BM		PREFIX = Bm

U32
BmPREVIOUS(sv)
	B::BM	sv
    CODE:
        PERL_UNUSED_VAR(sv);
	RETVAL = BmPREVIOUS(sv);
    OUTPUT:
        RETVAL


U8
BmRARE(sv)
	B::BM	sv
    CODE:
        PERL_UNUSED_VAR(sv);
	RETVAL = BmRARE(sv);
    OUTPUT:
        RETVAL


MODULE = B	PACKAGE = B::GV		PREFIX = Gv

void
GvNAME(gv)
	B::GV	gv
    ALIAS:
	FILE = 1
	B::HV::NAME = 2
    CODE:
	ST(0) = sv_2mortal(newSVhek(!ix ? GvNAME_HEK(gv)
					: (ix == 1 ? GvFILE_HEK(gv)
						   : HvNAME_HEK((HV *)gv))));

bool
is_empty(gv)
        B::GV   gv
    ALIAS:
	isGV_with_GP = 1
    CODE:
	if (ix) {
	    RETVAL = isGV_with_GP(gv) ? TRUE : FALSE;
	} else {
            RETVAL = GvGP(gv) == Null(GP*);
	}
    OUTPUT:
        RETVAL

void*
GvGP(gv)
	B::GV	gv

#define GP_sv_ix	(SVp << 16) | STRUCT_OFFSET(struct gp, gp_sv)
#define GP_io_ix	(SVp << 16) | STRUCT_OFFSET(struct gp, gp_io)
#define GP_cv_ix	(SVp << 16) | STRUCT_OFFSET(struct gp, gp_cv)
#define GP_cvgen_ix	(U32p << 16) | STRUCT_OFFSET(struct gp, gp_cvgen)
#define GP_refcnt_ix	(U32p << 16) | STRUCT_OFFSET(struct gp, gp_refcnt)
#define GP_hv_ix	(SVp << 16) | STRUCT_OFFSET(struct gp, gp_hv)
#define GP_av_ix	(SVp << 16) | STRUCT_OFFSET(struct gp, gp_av)
#define GP_form_ix	(SVp << 16) | STRUCT_OFFSET(struct gp, gp_form)
#define GP_egv_ix	(SVp << 16) | STRUCT_OFFSET(struct gp, gp_egv)

void
SV(gv)
	B::GV	gv
    ALIAS:
	SV = GP_sv_ix
	IO = GP_io_ix
	CV = GP_cv_ix
	CVGEN = GP_cvgen_ix
	GvREFCNT = GP_refcnt_ix
	HV = GP_hv_ix
	AV = GP_av_ix
	FORM = GP_form_ix
	EGV = GP_egv_ix
    PREINIT:
	GP *gp;
	char *ptr;
	SV *ret;
    PPCODE:
	gp = GvGP(gv);
	if (!gp) {
	    const GV *const gv = CvGV(cv);
	    Perl_croak(aTHX_ "NULL gp in B::GV::%s", gv ? GvNAME(gv) : "???");
	}
	ptr = (ix & 0xFFFF) + (char *)gp;
	switch ((U8)(ix >> 16)) {
	case SVp:
	    ret = make_sv_object(aTHX_ *((SV **)ptr));
	    break;
	case U32p:
	    ret = sv_2mortal(newSVuv(*((U32*)ptr)));
	    break;
	default:
	    croak("Illegal alias 0x%08x for B::*SV", (unsigned)ix);
	}
	ST(0) = ret;
	XSRETURN(1);

U32
GvLINE(gv)
        B::GV   gv

U32
GvGPFLAGS(gv)
        B::GV   gv

void
FILEGV(gv)
	B::GV	gv
    PPCODE:
	PUSHs(make_sv_object(aTHX_ (SV *)GvFILEGV(gv)));

MODULE = B	PACKAGE = B::IO		PREFIX = Io


bool
IsSTD(io,name)
	B::IO	io
	const char*	name
    PREINIT:
	PerlIO* handle = 0;
    CODE:
	if( strEQ( name, "stdin" ) ) {
	    handle = PerlIO_stdin();
	}
	else if( strEQ( name, "stdout" ) ) {
	    handle = PerlIO_stdout();
	}
	else if( strEQ( name, "stderr" ) ) {
	    handle = PerlIO_stderr();
	}
	else {
	    croak( "Invalid value '%s'", name );
	}
	RETVAL = handle == IoIFP(io);
    OUTPUT:
	RETVAL

MODULE = B	PACKAGE = B::AV		PREFIX = Av

SSize_t
AvFILL(av)
	B::AV	av

void
AvARRAY(av)
	B::AV	av
    PPCODE:
	if (AvFILL(av) >= 0) {
	    SV **svp = AvARRAY(av);
	    I32 i;
	    for (i = 0; i <= AvFILL(av); i++)
		XPUSHs(make_sv_object(aTHX_ svp[i]));
	}

void
AvARRAYelt(av, idx)
	B::AV	av
	int	idx
    PPCODE:
    	if (idx >= 0 && AvFILL(av) >= 0 && idx <= AvFILL(av))
	    XPUSHs(make_sv_object(aTHX_ (AvARRAY(av)[idx])));
	else
	    XPUSHs(make_sv_object(aTHX_ NULL));


MODULE = B	PACKAGE = B::FM		PREFIX = Fm

IV
FmLINES(format)
	B::FM	format
    CODE:
        PERL_UNUSED_VAR(format);
       RETVAL = 0;
    OUTPUT:
        RETVAL


MODULE = B	PACKAGE = B::CV		PREFIX = Cv

U32
CvCONST(cv)
	B::CV	cv

void
CvSTART(cv)
	B::CV	cv
    ALIAS:
	ROOT = 1
    PPCODE:
	PUSHs(make_op_object(aTHX_ CvISXSUB(cv) ? NULL
			     : ix ? CvROOT(cv) : CvSTART(cv)));

I32
CvDEPTH(cv)
        B::CV   cv

#ifdef PadlistARRAY

B::PADLIST
CvPADLIST(cv)
	B::CV	cv
    CODE:
	RETVAL = CvISXSUB(cv) ? NULL : CvPADLIST(cv);
    OUTPUT:
	RETVAL

#else

B::AV
CvPADLIST(cv)
	B::CV	cv
    PPCODE:
	PUSHs(make_sv_object(aTHX_ (SV *)CvPADLIST(cv)));


#endif

SV *
CvHSCXT(cv)
	B::CV	cv
    CODE:
	RETVAL = newSVuv(CvISXSUB(cv) ? PTR2UV(CvHSCXT(cv)) : 0);
    OUTPUT:
	RETVAL

void
CvXSUB(cv)
	B::CV	cv
    ALIAS:
	XSUBANY = 1
    CODE:
	ST(0) = ix && CvCONST(cv)
	    ? make_sv_object(aTHX_ (SV *)CvXSUBANY(cv).any_ptr)
	    : sv_2mortal(newSViv(CvISXSUB(cv)
				 ? (ix ? CvXSUBANY(cv).any_iv
				       : PTR2IV(CvXSUB(cv)))
				 : 0));

void
const_sv(cv)
	B::CV	cv
    PPCODE:
	PUSHs(make_sv_object(aTHX_ (SV *)cv_const_sv(cv)));

void
GV(cv)
	B::CV cv
    CODE:
	ST(0) = make_sv_object(aTHX_ (SV*)CvGV(cv));

SV *
NAME_HEK(cv)
	B::CV cv
    CODE:
	RETVAL = CvNAMED(cv) ? newSVhek(CvNAME_HEK(cv)) : &PL_sv_undef;
    OUTPUT:
	RETVAL

MODULE = B	PACKAGE = B::HV		PREFIX = Hv

STRLEN
HvFILL(hv)
	B::HV	hv

I32
HvRITER(hv)
	B::HV	hv

void
HvARRAY(hv)
	B::HV	hv
    PPCODE:
	if (HvUSEDKEYS(hv) > 0) {
	    HE *he;
            SSize_t extend_size;
	    (void)hv_iterinit(hv);
            /* 2*HvUSEDKEYS() should never be big enough to truncate or wrap */
	    assert(HvUSEDKEYS(hv) <= (SSize_t_MAX >> 1));
            extend_size = (SSize_t)HvUSEDKEYS(hv) * 2;
	    EXTEND(sp, extend_size);
	    while ((he = hv_iternext(hv))) {
                if (HeSVKEY(he)) {
                    mPUSHs(HeSVKEY(he));
                } else if (HeKUTF8(he)) {
                    PUSHs(newSVpvn_flags(HeKEY(he), HeKLEN(he), SVf_UTF8|SVs_TEMP));
                } else {
                    mPUSHp(HeKEY(he), HeKLEN(he));
                }
		PUSHs(make_sv_object(aTHX_ HeVAL(he)));
	    }
	}

MODULE = B	PACKAGE = B::HE		PREFIX = He

void
HeVAL(he)
	B::HE he
    ALIAS:
	SVKEY_force = 1
    PPCODE:
	PUSHs(make_sv_object(aTHX_ ix ? HeSVKEY_force(he) : HeVAL(he)));

U32
HeHASH(he)
	B::HE he

MODULE = B	PACKAGE = B::RHE

SV*
HASH(h)
	B::RHE h
    CODE:
	RETVAL = newRV( (SV*)cophh_2hv(h, 0) );
    OUTPUT:
	RETVAL


#ifdef PadlistARRAY

MODULE = B	PACKAGE = B::PADLIST	PREFIX = Padlist

SSize_t
PadlistMAX(padlist)
	B::PADLIST	padlist
    ALIAS: B::PADNAMELIST::MAX = 0
    CODE:
        PERL_UNUSED_VAR(ix);
	RETVAL = PadlistMAX(padlist);
    OUTPUT:
	RETVAL

B::PADNAMELIST
PadlistNAMES(padlist)
	B::PADLIST	padlist

void
PadlistARRAY(padlist)
	B::PADLIST	padlist
    PPCODE:
	if (PadlistMAX(padlist) >= 0) {
	    dXSTARG;
	    PAD **padp = PadlistARRAY(padlist);
            SSize_t i;
	    sv_setiv(newSVrv(TARG, PadlistNAMES(padlist)
				    ? "B::PADNAMELIST"
				    : "B::NULL"),
		     PTR2IV(PadlistNAMES(padlist)));
	    XPUSHTARG;
	    for (i = 1; i <= PadlistMAX(padlist); i++)
		XPUSHs(make_sv_object(aTHX_ (SV *)padp[i]));
	}

void
PadlistARRAYelt(padlist, idx)
	B::PADLIST	padlist
	SSize_t 	idx
    PPCODE:
	if (idx < 0 || idx > PadlistMAX(padlist))
	    XPUSHs(make_sv_object(aTHX_ NULL));
	else if (!idx) {
	    PL_stack_sp--;
	    PUSHMARK(PL_stack_sp-1);
	    XS_B__PADLIST_NAMES(aTHX_ cv);
	    return;
	}
	else
	    XPUSHs(make_sv_object(aTHX_
				  (SV *)PadlistARRAY(padlist)[idx]));

U32
PadlistREFCNT(padlist)
	B::PADLIST	padlist
    CODE:
        PERL_UNUSED_VAR(padlist);
	RETVAL = PadlistREFCNT(padlist);
    OUTPUT:
	RETVAL

#endif

MODULE = B	PACKAGE = B::PADNAMELIST	PREFIX = Padnamelist

void
PadnamelistARRAY(pnl)
	B::PADNAMELIST	pnl
    PPCODE:
	if (PadnamelistMAX(pnl) >= 0) {
	    PADNAME **padp = PadnamelistARRAY(pnl);
            SSize_t i = 0;
	    for (; i <= PadnamelistMAX(pnl); i++)
	    {
		SV *rv = sv_newmortal();
		sv_setiv(newSVrv(rv,padp[i] ? "B::PADNAME" : "B::SPECIAL"),
			 PTR2IV(padp[i]));
		XPUSHs(rv);
	    }
	}

B::PADNAME
PadnamelistARRAYelt(pnl, idx)
	B::PADNAMELIST	pnl
	SSize_t 	idx
    CODE:
	if (idx < 0 || idx > PadnamelistMAX(pnl))
	    RETVAL = NULL;
	else
	    RETVAL = PadnamelistARRAY(pnl)[idx];
    OUTPUT:
	RETVAL

MODULE = B	PACKAGE = B::PADNAME	PREFIX = Padname

#define PN_type_ix \
	sv_SVp | STRUCT_OFFSET(struct padname,xpadn_type_u.xpadn_typestash)
#define PN_ourstash_ix \
	sv_SVp | STRUCT_OFFSET(struct padname,xpadn_ourstash)
#define PN_len_ix \
	sv_U8p | STRUCT_OFFSET(struct padname,xpadn_len)
#define PN_refcnt_ix \
	sv_U32p | STRUCT_OFFSET(struct padname, xpadn_refcnt)
#define PN_cop_seq_range_low_ix \
	sv_U32p | STRUCT_OFFSET(struct padname, xpadn_low)
#define PN_cop_seq_range_high_ix \
	sv_U32p | STRUCT_OFFSET(struct padname, xpadn_high)
#define PNL_refcnt_ix \
	sv_U32p | STRUCT_OFFSET(struct padnamelist, xpadnl_refcnt)
#define PL_id_ix \
	sv_U32p | STRUCT_OFFSET(struct padlist, xpadl_id)
#define PL_outid_ix \
	sv_U32p | STRUCT_OFFSET(struct padlist, xpadl_outid)


void
PadnameTYPE(pn)
	B::PADNAME	pn
    ALIAS:
	B::PADNAME::TYPE	= PN_type_ix
	B::PADNAME::OURSTASH	= PN_ourstash_ix
	B::PADNAME::LEN		= PN_len_ix
	B::PADNAME::REFCNT	= PN_refcnt_ix
	B::PADNAME::COP_SEQ_RANGE_LOW	 = PN_cop_seq_range_low_ix
	B::PADNAME::COP_SEQ_RANGE_HIGH	 = PN_cop_seq_range_high_ix
	B::PADNAMELIST::REFCNT	= PNL_refcnt_ix
	B::PADLIST::id		= PL_id_ix
	B::PADLIST::outid	= PL_outid_ix
    PREINIT:
	char *ptr;
	SV *ret;
    PPCODE:
	ptr = (ix & 0xFFFF) + (char *)pn;
	switch ((U8)(ix >> 16)) {
	case (U8)(sv_SVp >> 16):
	    ret = make_sv_object(aTHX_ *((SV **)ptr));
	    break;
	case (U8)(sv_U32p >> 16):
	    ret = sv_2mortal(newSVuv(*((U32 *)ptr)));
	    break;
	case (U8)(sv_U8p >> 16):
	    ret = sv_2mortal(newSVuv(*((U8 *)ptr)));
	    break;
	default:
	    NOT_REACHED;
	}
	ST(0) = ret;
	XSRETURN(1);

SV *
PadnamePV(pn)
	B::PADNAME	pn
    PREINIT:
	dXSTARG;
    PPCODE:
	PERL_UNUSED_ARG(RETVAL);
	sv_setpvn(TARG, PadnamePV(pn), PadnameLEN(pn));
	SvUTF8_on(TARG);
	XPUSHTARG;

BOOT:
{
    /* Uses less memory than an ALIAS.  */
    GV *gv = gv_fetchpvs("B::PADNAME::TYPE", 1, SVt_PVGV);
    sv_setsv((SV *)gv_fetchpvs("B::PADNAME::SvSTASH",1,SVt_PVGV),(SV *)gv);
    sv_setsv((SV *)gv_fetchpvs("B::PADNAME::PROTOCV",1,SVt_PVGV),(SV *)gv);
    sv_setsv((SV *)gv_fetchpvs("B::PADNAME::PVX",1,SVt_PVGV),
	     (SV *)gv_fetchpvs("B::PADNAME::PV" ,1,SVt_PVGV));
    sv_setsv((SV *)gv_fetchpvs("B::PADNAME::PARENT_PAD_INDEX" ,1,SVt_PVGV),
	     (SV *)gv_fetchpvs("B::PADNAME::COP_SEQ_RANGE_LOW",1,
				SVt_PVGV));
    sv_setsv((SV *)gv_fetchpvs("B::PADNAME::PARENT_FAKELEX_FLAGS",1,
				SVt_PVGV),
	     (SV *)gv_fetchpvs("B::PADNAME::COP_SEQ_RANGE_HIGH"  ,1,
				SVt_PVGV));
}

U32
PadnameFLAGS(pn)
	B::PADNAME	pn
    CODE:
	RETVAL = PadnameFLAGS(pn);
	/* backward-compatibility hack, which should be removed if the
	   flags field becomes large enough to hold SVf_FAKE (and
	   PADNAMEt_OUTER should be renumbered to match SVf_FAKE) */
	STATIC_ASSERT_STMT(SVf_FAKE >= 1<<(sizeof(PadnameFLAGS((B__PADNAME)NULL)) * 8));
	if (PadnameOUTER(pn))
	    RETVAL |= SVf_FAKE;
    OUTPUT:
	RETVAL
@


1.1
log
@Initial revision
@
text
@d10 2
a14 10
#include "INTERN.h"

#ifdef PERL_OBJECT
#undef op_name
#undef opargs 
#undef op_desc
#define op_name (pPerl->Perl_get_op_names())
#define opargs (pPerl->Perl_get_opargs())
#define op_desc (pPerl->Perl_get_op_descs())
#endif
d23 1
a23 1
static char *svclassnames[] = {
a26 1
    "B::RV",
d28 1
d32 2
a33 1
    "B::BM",
a37 1
    "B::GV",
d48 9
a56 9
    OPc_CONDOP,	/* 5 */
    OPc_LISTOP,	/* 6 */
    OPc_PMOP,	/* 7 */
    OPc_SVOP,	/* 8 */
    OPc_GVOP,	/* 9 */
    OPc_PVOP,	/* 10 */
    OPc_CVOP,	/* 11 */
    OPc_LOOP,	/* 12 */
    OPc_COP	/* 13 */
d59 1
a59 1
static char *opclassnames[] = {
a64 1
    "B::CONDOP",
d68 1
a68 1
    "B::GVOP",
a69 1
    "B::CVOP",
d71 3
a73 1
    "B::COP"	
d76 39
a114 1
static int walkoptree_debug = 0;	/* Flag for walkoptree debug hook */
d117 1
a117 1
cc_opclass(OP *o)
d119 2
d124 3
a126 1
    if (o->op_type == 0)
d128 1
d133 18
a150 1
    switch (opargs[o->op_type] & OA_CLASS_MASK) {
a162 3
    case OA_CONDOP:
	return OPc_CONDOP;

d172 2
a173 2
    case OA_GVOP:
	return OPc_GVOP;
d175 17
a191 2
    case OA_PVOP:
	return OPc_PVOP;
d217 1
a217 1
	 * a GVOP (and op_gv is the GV for the filehandle argument).
d220 5
a224 2
		(o->op_flags & OPf_REF) ? OPc_GVOP : OPc_BASEOP);

d241 4
d247 1
a247 1
	 op_name[o->op_type]);
d251 11
a261 2
static char *
cc_opclassname(OP *o)
d263 25
a287 1
    return opclassnames[cc_opclass(o)];
d290 1
d292 1
a292 1
make_sv_object(SV *arg, SV *sv)
d294 2
a295 1
    char *type = 0;
d297 4
a300 3
    
    for (iv = 0; iv < sizeof(PL_specialsv_list)/sizeof(SV*); iv++) {
	if (sv == PL_specialsv_list[iv]) {
d307 1
a307 1
	iv = (IV)sv;
d314 1
a314 1
make_mg_object(SV *arg, MAGIC *mg)
d316 15
a330 1
    sv_setiv(newSVrv(arg, "B::MAGIC"), (IV)mg);
d335 1
a335 1
cstring(SV *sv)
d337 53
a389 3
    SV *sstr = newSVpv("", 0);
    STRLEN len;
    char *s;
d392 28
a419 1
	sv_setpvn(sstr, "0", 1);
d423 2
a424 2
	s = SvPV(sv, len);
	sv_catpv(sstr, "\"");
d429 1
a429 1
		sv_catpv(sstr, "\\\"");
d431 10
a440 2
		sv_catpv(sstr, "\\\\");
	    else if (*s >= ' ' && *s < 127) /* XXX not portable */
d443 1
a443 1
		sv_catpv(sstr, "\\n");
d445 1
a445 1
		sv_catpv(sstr, "\\r");
d447 1
a447 1
		sv_catpv(sstr, "\\t");
d449 1
a449 1
		sv_catpv(sstr, "\\a");
d451 1
a451 1
		sv_catpv(sstr, "\\b");
d453 3
a455 3
		sv_catpv(sstr, "\\f");
	    else if (*s == '\v')
		sv_catpv(sstr, "\\v");
a457 2
		/* no trigraph support */
		char escbuff[5]; /* to fit backslash, 3 octals + trailing \0 */
d459 2
a460 3
		unsigned char c = (unsigned char) *s;
		sprintf(escbuff, "\\%03o", c);
		sv_catpv(sstr, escbuff);
a463 1
	sv_catpv(sstr, "\"");
d465 1
d470 1
a470 1
cchar(SV *sv)
d472 10
a481 9
    SV *sstr = newSVpv("'", 0);
    STRLEN n_a;
    char *s = SvPV(sv, n_a);

    if (*s == '\'')
	sv_catpv(sstr, "\\'");
    else if (*s == '\\')
	sv_catpv(sstr, "\\\\");
    else if (*s >= ' ' && *s < 127) /* XXX not portable */
d483 14
a496 14
    else if (*s == '\n')
	sv_catpv(sstr, "\\n");
    else if (*s == '\r')
	sv_catpv(sstr, "\\r");
    else if (*s == '\t')
	sv_catpv(sstr, "\\t");
    else if (*s == '\a')
	sv_catpv(sstr, "\\a");
    else if (*s == '\b')
	sv_catpv(sstr, "\\b");
    else if (*s == '\f')
	sv_catpv(sstr, "\\f");
    else if (*s == '\v')
	sv_catpv(sstr, "\\v");
d498 2
a499 9
    {
	/* no trigraph support */
	char escbuff[5]; /* to fit backslash, 3 octals + trailing \0 */
	/* Don't want promotion of a signed -1 char in sprintf args */
	unsigned char c = (unsigned char) *s;
	sprintf(escbuff, "\\%03o", c);
	sv_catpv(sstr, escbuff);
    }
    sv_catpv(sstr, "'");
d503 2
a504 8
#ifdef INDIRECT_BGET_MACROS
void freadpv(U32 len, void *data)
{
    New(666, pv.xpv_pv, len, char);
    fread(pv.xpv_pv, 1, len, (FILE*)data);
    pv.xpv_len = len;
    pv.xpv_cur = len - 1;
}
d506 2
a507 1
void byteload_fh(InputStream fp)
d509 20
a528 24
    struct bytestream bs;
    bs.data = fp;
    bs.fgetc = (int(*) _((void*)))fgetc;
    bs.fread = (int(*) _((char*,size_t,size_t,void*)))fread;
    bs.freadpv = freadpv;
    byterun(bs);
}

static int fgetc_fromstring(void *data)
{
    char **strp = (char **)data;
    return *(*strp)++;
}

static int fread_fromstring(char *argp, size_t elemsize, size_t nelem,
			    void *data)
{
    char **strp = (char **)data;
    size_t len = elemsize * nelem;
    
    memcpy(argp, *strp, len);
    *strp += len;
    return (int)len;
}
a529 42
static void freadpv_fromstring(U32 len, void *data)
{
    char **strp = (char **)data;
    
    New(666, pv.xpv_pv, len, char);
    memcpy(pv.xpv_pv, *strp, len);
    pv.xpv_len = len;
    pv.xpv_cur = len - 1;
    *strp += len;
}    

void byteload_string(char *str)
{
    struct bytestream bs;
    bs.data = &str;
    bs.fgetc = fgetc_fromstring;
    bs.fread = fread_fromstring;
    bs.freadpv = freadpv_fromstring;
    byterun(bs);
}
#else
void byteload_fh(InputStream fp)
{
    byterun(fp);
}

void byteload_string(char *str)
{
    croak("Must compile with -DINDIRECT_BGET_MACROS for byteload_string");
}    
#endif /* INDIRECT_BGET_MACROS */

void
walkoptree(SV *opsv, char *method)
{
    dSP;
    OP *o;
    
    if (!SvROK(opsv))
	croak("opsv is not a reference");
    opsv = sv_mortalcopy(opsv);
    o = (OP*)SvIV((SV*)SvRV(opsv));
d532 1
a532 1
	XPUSHs(opsv);
d537 1
a537 1
    XPUSHs(opsv);
d541 42
a582 5
	OP *kid;
	for (kid = ((UNOP*)o)->op_first; kid; kid = kid->op_sibling) {
	    /* Use the same opsv. Rely on methods not to mess it up. */
	    sv_setiv(newSVrv(opsv, cc_opclassname(kid)), (IV)kid);
	    walkoptree(opsv, method);
d585 1
a591 1
typedef CONDOP	*B__CONDOP;
d595 1
a595 1
typedef GVOP	*B__GVOP;
d599 1
d606 1
d610 1
d618 35
a653 1
MODULE = B	PACKAGE = B	PREFIX = B_
a654 1
PROTOTYPES: DISABLE
d656 94
a749 2
BOOT:
    INIT_SPECIALSV_LIST;
d751 1
a751 8
#define B_main_cv()	PL_main_cv
#define B_init_av()	PL_initav
#define B_main_root()	PL_main_root
#define B_main_start()	PL_main_start
#define B_comppadlist()	(PL_main_cv ? CvPADLIST(PL_main_cv) : CvPADLIST(PL_compcv))
#define B_sv_undef()	&PL_sv_undef
#define B_sv_yes()	&PL_sv_yes
#define B_sv_no()	&PL_sv_no
d753 1
a753 2
B::AV
B_init_av()
d755 44
a798 2
B::CV
B_main_cv()
d800 1
a800 2
B::OP
B_main_root()
d802 4
a805 2
B::OP
B_main_start()
d807 1
a807 2
B::AV
B_comppadlist()
d809 6
a814 2
B::SV
B_sv_undef()
d816 15
a830 2
B::SV
B_sv_yes()
d832 9
a840 2
B::SV
B_sv_no()
d842 6
a847 1
MODULE = B	PACKAGE = B
d849 8
d859 5
a863 3
walkoptree(opsv, method)
	SV *	opsv
	char *	method
d868 1
d875 1
a875 14
int
byteload_fh(fp)
	InputStream    fp
    CODE:
	byteload_fh(fp);
	RETVAL = 1;
    OUTPUT:
	RETVAL

void
byteload_string(str)
	char *	str

#define address(sv) (IV)sv
d881 1
a881 1
B::SV
d884 1
a884 1
    CODE:
d887 22
a908 3
	RETVAL = (SV*)SvRV(sv);
    OUTPUT:
	RETVAL
d915 2
a916 4
	if (opnum >= 0 && opnum < PL_maxo) {
	    sv_setpvn(ST(0), "pp_", 3);
	    sv_catpv(ST(0), op_name[opnum]);
	}
a921 1
	char *s;
d924 3
a926 6
	char hexhash[11]; /* must fit "0xffffffff" plus trailing \0 */
	s = SvPV(sv, len);
	while (len--)
	    hash = hash * 33 + *s++;
	sprintf(hexhash, "0x%x", hash);
	ST(0) = sv_2mortal(newSVpv(hexhash, 0));
d935 2
d938 4
a941 1
	PL_minus_c = TRUE;
d943 1
a943 1
SV *
d946 5
a950 4

SV *
cchar(sv)
	SV *	sv
a954 3
#ifdef USE_THREADS
	int i;
	STRLEN len = strlen(PL_threadsv_names);
a955 4
	EXTEND(sp, len);
	for (i = 0; i < len; i++)
	    PUSHs(sv_2mortal(newSVpv(&PL_threadsv_names[i], 1)));
#endif
d957 10
d968 1
a968 8
#define OP_next(o)	o->op_next
#define OP_sibling(o)	o->op_sibling
#define OP_desc(o)	op_desc[o->op_type]
#define OP_targ(o)	o->op_targ
#define OP_type(o)	o->op_type
#define OP_seq(o)	o->op_seq
#define OP_flags(o)	o->op_flags
#define OP_private(o)	o->op_private
d970 1
a970 1
MODULE = B	PACKAGE = B::OP		PREFIX = OP_
a971 3
B::OP
OP_next(o)
	B::OP		o
d973 5
a977 2
B::OP
OP_sibling(o)
d979 69
d1049 1
a1049 11
char *
OP_ppaddr(o)
	B::OP		o
    CODE:
	ST(0) = sv_newmortal();
	sv_setpvn(ST(0), "pp_", 3);
	sv_catpv(ST(0), op_name[o->op_type]);

char *
OP_desc(o)
	B::OP		o
d1051 250
a1300 3
U16
OP_targ(o)
	B::OP		o
a1301 3
U16
OP_type(o)
	B::OP		o
d1303 2
a1304 2
U16
OP_seq(o)
d1306 2
a1308 3
U8
OP_flags(o)
	B::OP		o
a1309 3
U8
OP_private(o)
	B::OP		o
d1311 1
a1311 1
#define UNOP_first(o)	o->op_first
d1313 3
a1315 1
MODULE = B	PACKAGE = B::UNOP		PREFIX = UNOP_
a1316 3
B::OP 
UNOP_first(o)
	B::UNOP	o
d1318 3
a1320 1
#define BINOP_last(o)	o->op_last
d1322 16
a1337 1
MODULE = B	PACKAGE = B::BINOP		PREFIX = BINOP_
a1338 3
B::OP
BINOP_last(o)
	B::BINOP	o
d1340 4
a1343 1
#define LOGOP_other(o)	o->op_other
d1345 27
a1371 1
MODULE = B	PACKAGE = B::LOGOP		PREFIX = LOGOP_
d1373 86
a1458 3
B::OP
LOGOP_other(o)
	B::LOGOP	o
d1460 2
a1461 2
#define CONDOP_true(o)	o->op_true
#define CONDOP_false(o)	o->op_false
a1462 1
MODULE = B	PACKAGE = B::CONDOP		PREFIX = CONDOP_
a1463 3
B::OP
CONDOP_true(o)
	B::CONDOP	o
d1465 1
a1465 3
B::OP
CONDOP_false(o)
	B::CONDOP	o
d1467 1
a1467 3
#define LISTOP_children(o)	o->op_children

MODULE = B	PACKAGE = B::LISTOP		PREFIX = LISTOP_
d1470 8
a1477 16
LISTOP_children(o)
	B::LISTOP	o

#define PMOP_pmreplroot(o)	o->op_pmreplroot
#define PMOP_pmreplstart(o)	o->op_pmreplstart
#define PMOP_pmnext(o)		o->op_pmnext
#define PMOP_pmregexp(o)	o->op_pmregexp
#define PMOP_pmflags(o)		o->op_pmflags
#define PMOP_pmpermflags(o)	o->op_pmpermflags

MODULE = B	PACKAGE = B::PMOP		PREFIX = PMOP_

void
PMOP_pmreplroot(o)
	B::PMOP		o
	OP *		root = NO_INIT
d1479 3
a1481 11
	ST(0) = sv_newmortal();
	root = o->op_pmreplroot;
	/* OP_PUSHRE stores an SV* instead of an OP* in op_pmreplroot */
	if (o->op_type == OP_PUSHRE) {
	    sv_setiv(newSVrv(ST(0), root ?
			     svclassnames[SvTYPE((SV*)root)] : "B::SV"),
		     (IV)root);
	}
	else {
	    sv_setiv(newSVrv(ST(0), cc_opclassname(root)), (IV)root);
	}
d1483 8
a1490 3
B::OP
PMOP_pmreplstart(o)
	B::PMOP		o
d1492 3
a1494 3
B::PMOP
PMOP_pmnext(o)
	B::PMOP		o
d1496 1
a1496 3
U16
PMOP_pmflags(o)
	B::PMOP		o
d1498 144
a1641 124
U16
PMOP_pmpermflags(o)
	B::PMOP		o

void
PMOP_precomp(o)
	B::PMOP		o
	REGEXP *	rx = NO_INIT
    CODE:
	ST(0) = sv_newmortal();
	rx = o->op_pmregexp;
	if (rx)
	    sv_setpvn(ST(0), rx->precomp, rx->prelen);

#define SVOP_sv(o)	o->op_sv

MODULE = B	PACKAGE = B::SVOP		PREFIX = SVOP_


B::SV
SVOP_sv(o)
	B::SVOP	o

#define GVOP_gv(o)	o->op_gv

MODULE = B	PACKAGE = B::GVOP		PREFIX = GVOP_


B::GV
GVOP_gv(o)
	B::GVOP	o

MODULE = B	PACKAGE = B::PVOP		PREFIX = PVOP_

void
PVOP_pv(o)
	B::PVOP	o
    CODE:
	/*
	 * OP_TRANS uses op_pv to point to a table of 256 shorts
	 * whereas other PVOPs point to a null terminated string.
	 */
	ST(0) = sv_2mortal(newSVpv(o->op_pv, (o->op_type == OP_TRANS) ?
				   256 * sizeof(short) : 0));

#define LOOP_redoop(o)	o->op_redoop
#define LOOP_nextop(o)	o->op_nextop
#define LOOP_lastop(o)	o->op_lastop

MODULE = B	PACKAGE = B::LOOP		PREFIX = LOOP_


B::OP
LOOP_redoop(o)
	B::LOOP	o

B::OP
LOOP_nextop(o)
	B::LOOP	o

B::OP
LOOP_lastop(o)
	B::LOOP	o

#define COP_label(o)	o->cop_label
#define COP_stash(o)	o->cop_stash
#define COP_filegv(o)	o->cop_filegv
#define COP_cop_seq(o)	o->cop_seq
#define COP_arybase(o)	o->cop_arybase
#define COP_line(o)	o->cop_line

MODULE = B	PACKAGE = B::COP		PREFIX = COP_

char *
COP_label(o)
	B::COP	o

B::HV
COP_stash(o)
	B::COP	o

B::GV
COP_filegv(o)
	B::COP	o

U32
COP_cop_seq(o)
	B::COP	o

I32
COP_arybase(o)
	B::COP	o

U16
COP_line(o)
	B::COP	o

MODULE = B	PACKAGE = B::SV		PREFIX = Sv

U32
SvREFCNT(sv)
	B::SV	sv

U32
SvFLAGS(sv)
	B::SV	sv

MODULE = B	PACKAGE = B::IV		PREFIX = Sv

IV
SvIV(sv)
	B::IV	sv

IV
SvIVX(sv)
	B::IV	sv

MODULE = B	PACKAGE = B::IV

#define needs64bits(sv) ((I32)SvIVX(sv) != SvIVX(sv))

int
needs64bits(sv)
	B::IV	sv
d1646 2
d1649 3
a1651 1
	if (sizeof(IV) == 8) {
d1653 1
a1653 1
	    IV iv = SvIVX(sv);
d1661 5
a1665 1
	    wp[0] = htonl(((U32)iv) >> (sizeof(IV)*4));
d1667 1
a1667 1
	    ST(0) = sv_2mortal(newSVpv((char *)wp, 8));
d1670 1
a1670 1
	    ST(0) = sv_2mortal(newSVpv((char *)&w, 4));
d1675 1
a1675 1
double
d1679 1
a1679 3
double
SvNVX(sv)
	B::NV	sv
d1681 20
a1700 1
MODULE = B	PACKAGE = B::RV		PREFIX = Sv
d1702 1
a1702 3
B::SV
SvRV(sv)
	B::RV	sv
d1704 7
a1710 1
MODULE = B	PACKAGE = B::PV		PREFIX = Sv
d1713 1
a1713 1
SvPV(sv)
d1715 8
d1724 68
a1791 2
	ST(0) = sv_newmortal();
	sv_setpvn(ST(0), SvPVX(sv), SvCUR(sv));
d1793 1
a1793 1
MODULE = B	PACKAGE = B::PVMG	PREFIX = Sv
d1796 1
a1796 1
SvMAGIC(sv)
d1801 1
a1801 15
	    XPUSHs(make_mg_object(sv_newmortal(), mg));

MODULE = B	PACKAGE = B::PVMG

B::HV
SvSTASH(sv)
	B::PVMG	sv

#define MgMOREMAGIC(mg) mg->mg_moremagic
#define MgPRIVATE(mg) mg->mg_private
#define MgTYPE(mg) mg->mg_type
#define MgFLAGS(mg) mg->mg_flags
#define MgOBJ(mg) mg->mg_obj

MODULE = B	PACKAGE = B::MAGIC	PREFIX = Mg	
d1803 1
a1803 19
B::MAGIC
MgMOREMAGIC(mg)
	B::MAGIC	mg

U16
MgPRIVATE(mg)
	B::MAGIC	mg

char
MgTYPE(mg)
	B::MAGIC	mg

U8
MgFLAGS(mg)
	B::MAGIC	mg

B::SV
MgOBJ(mg)
	B::MAGIC	mg
d1806 1
a1806 1
MgPTR(mg)
d1808 58
a1865 4
    CODE:
	ST(0) = sv_newmortal();
	if (mg->mg_ptr)
	    sv_setpvn(ST(0), mg->mg_ptr, mg->mg_len);
d1867 1
a1867 1
MODULE = B	PACKAGE = B::PVLV	PREFIX = Lv
d1870 1
a1870 19
LvTARGOFF(sv)
	B::PVLV	sv

U32
LvTARGLEN(sv)
	B::PVLV	sv

char
LvTYPE(sv)
	B::PVLV	sv

B::SV
LvTARG(sv)
	B::PVLV sv

MODULE = B	PACKAGE = B::BM		PREFIX = Bm

I32
BmUSEFUL(sv)
d1872 5
a1877 3
U16
BmPREVIOUS(sv)
	B::BM	sv
d1882 5
a1887 9
void
BmTABLE(sv)
	B::BM	sv
	STRLEN	len = NO_INIT
	char *	str = NO_INIT
    CODE:
	str = SvPV(sv, len);
	/* Boyer-Moore table is just after string and its safety-margin \0 */
	ST(0) = sv_2mortal(newSVpv(str + len + 1, 256));
d1894 3
d1898 17
a1914 5
	ST(0) = sv_2mortal(newSVpv(GvNAME(gv), GvNAMELEN(gv)));

B::HV
GvSTASH(gv)
	B::GV	gv
d1916 2
a1917 2
B::SV
GvSV(gv)
d1920 9
a1928 3
B::IO
GvIO(gv)
	B::GV	gv
d1930 2
a1931 18
B::CV
GvFORM(gv)
	B::GV	gv

B::AV
GvAV(gv)
	B::GV	gv

B::HV
GvHV(gv)
	B::GV	gv

B::GV
GvEGV(gv)
	B::GV	gv

B::CV
GvCV(gv)
d1933 33
a1967 4
GvCVGEN(gv)
	B::GV	gv

U16
d1969 1
a1969 7
	B::GV	gv

B::GV
GvFILEGV(gv)
	B::GV	gv

MODULE = B	PACKAGE = B::GV
d1972 2
a1973 2
GvREFCNT(gv)
	B::GV	gv
d1975 2
a1976 2
U8
GvFLAGS(gv)
d1978 2
a1982 3
long
IoLINES(io)
	B::IO	io
d1984 2
a1985 48
long
IoPAGE(io)
	B::IO	io

long
IoPAGE_LEN(io)
	B::IO	io

long
IoLINES_LEFT(io)
	B::IO	io

char *
IoTOP_NAME(io)
	B::IO	io

B::GV
IoTOP_GV(io)
	B::IO	io

char *
IoFMT_NAME(io)
	B::IO	io

B::GV
IoFMT_GV(io)
	B::IO	io

char *
IoBOTTOM_NAME(io)
	B::IO	io

B::GV
IoBOTTOM_GV(io)
	B::IO	io

short
IoSUBPROCESS(io)
	B::IO	io

MODULE = B	PACKAGE = B::IO

char
IoTYPE(io)
	B::IO	io

U8
IoFLAGS(io)
d1987 19
a2012 10
SSize_t
AvMAX(av)
	B::AV	av

#define AvOFF(av) ((XPVAV*)SvANY(av))->xof_off

IV
AvOFF(av)
	B::AV	av

d2021 1
a2021 1
		XPUSHs(make_sv_object(sv_newmortal(), svp[i]));
d2024 21
a2044 1
MODULE = B	PACKAGE = B::AV
a2045 3
U8
AvFLAGS(av)
	B::AV	av
d2049 2
a2050 2
B::HV
CvSTASH(cv)
d2053 1
a2053 1
B::OP
d2056 5
d2062 3
a2064 3
B::OP
CvROOT(cv)
	B::CV	cv
d2066 1
a2066 3
B::GV
CvGV(cv)
	B::CV	cv
d2068 2
a2069 2
B::GV
CvFILEGV(cv)
d2071 4
d2076 1
a2076 3
long
CvDEPTH(cv)
	B::CV	cv
d2081 5
d2087 2
a2088 2
B::CV
CvOUTSIDE(cv)
d2090 4
d2098 2
d2101 6
a2106 1
	ST(0) = sv_2mortal(newSViv((IV)CvXSUB(cv)));
d2108 5
d2115 2
a2116 2
CvXSUBANY(cv)
	B::CV	cv
d2118 1
a2118 7
	ST(0) = sv_2mortal(newSViv(CvXSUBANY(cv).any_iv));

MODULE = B    PACKAGE = B::CV

U8
CvFLAGS(cv)
      B::CV   cv
d2120 7
d2134 2
a2135 2
STRLEN
HvMAX(hv)
d2138 2
a2139 2
I32
HvKEYS(hv)
d2141 20
d2162 85
a2246 3
I32
HvRITER(hv)
	B::HV	hv
d2248 1
a2248 3
char *
HvNAME(hv)
	B::HV	hv
d2250 1
a2250 3
B::PMOP
HvPMROOT(hv)
	B::HV	hv
d2253 2
a2254 2
HvARRAY(hv)
	B::HV	hv
d2256 9
a2264 9
	if (HvKEYS(hv) > 0) {
	    SV *sv;
	    char *key;
	    I32 len;
	    (void)hv_iterinit(hv);
	    EXTEND(sp, HvKEYS(hv) * 2);
	    while (sv = hv_iternextsv(hv, &key, &len)) {
		PUSHs(newSVpv(key, len));
		PUSHs(make_sv_object(sv_newmortal(), sv));
d2267 110
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@a9 1
#define PERL_NO_GET_CONTEXT
d13 1
d16 6
a21 6
#undef PL_op_name
#undef PL_opargs 
#undef PL_op_desc
#define PL_op_name (get_op_names())
#define PL_opargs (get_opargs())
#define PL_op_desc (get_op_descs())
d56 9
a64 8
    OPc_LISTOP,	/* 5 */
    OPc_PMOP,	/* 6 */
    OPc_SVOP,	/* 7 */
    OPc_PADOP,	/* 8 */
    OPc_PVOP,	/* 9 */
    OPc_CVOP,	/* 10 */
    OPc_LOOP,	/* 11 */
    OPc_COP	/* 12 */
d73 1
d77 1
a77 1
    "B::PADOP",
a85 2
static SV *specialsv_list[4];

d87 1
a87 1
cc_opclass(pTHX_ OP *o)
d98 1
a98 6
#ifdef USE_ITHREADS
    if (o->op_type == OP_GV || o->op_type == OP_GVSV || o->op_type == OP_AELEMFAST)
	return OPc_PADOP;
#endif

    switch (PL_opargs[o->op_type] & OA_CLASS_MASK) {
d111 3
d123 2
a124 2
    case OA_PADOP:
	return OPc_PADOP;
d126 2
a127 10
    case OA_PVOP_OR_SVOP:
        /*
         * Character translations (tr///) are usually a PVOP, keeping a 
         * pointer to a table of shorts used to look up translations.
         * Under utf8, however, a simple table isn't practical; instead,
         * the OP is an SVOP, and the SV is a reference to a swash
         * (i.e., an RV pointing to an HV).
         */
	return (o->op_private & (OPpTRANS_TO_UTF|OPpTRANS_FROM_UTF))
		? OPc_SVOP : OPc_PVOP;
d153 1
a153 1
	 * an SVOP (and op_sv is the GV for the filehandle argument).
d156 2
a157 5
#ifdef USE_ITHREADS
		(o->op_flags & OPf_REF) ? OPc_PADOP : OPc_BASEOP);
#else
		(o->op_flags & OPf_REF) ? OPc_SVOP : OPc_BASEOP);
#endif
d176 1
a176 1
	 PL_op_name[o->op_type]);
d181 1
a181 1
cc_opclassname(pTHX_ OP *o)
d183 1
a183 1
    return opclassnames[cc_opclass(aTHX_ o)];
d187 1
a187 1
make_sv_object(pTHX_ SV *arg, SV *sv)
d192 2
a193 2
    for (iv = 0; iv < sizeof(specialsv_list)/sizeof(SV*); iv++) {
	if (sv == specialsv_list[iv]) {
d200 1
a200 1
	iv = PTR2IV(sv);
d207 1
a207 1
make_mg_object(pTHX_ SV *arg, MAGIC *mg)
d209 1
a209 1
    sv_setiv(newSVrv(arg, "B::MAGIC"), PTR2IV(mg));
d214 1
a214 1
cstring(pTHX_ SV *sv)
d216 1
a216 1
    SV *sstr = newSVpvn("", 0);
d267 1
a267 1
cchar(pTHX_ SV *sv)
d269 1
a269 1
    SV *sstr = newSVpvn("'", 1);
d306 68
d375 1
a375 1
walkoptree(pTHX_ SV *opsv, char *method)
d383 1
a383 1
    o = INT2PTR(OP*,SvIV((SV*)SvRV(opsv)));
d398 2
a399 2
	    sv_setiv(newSVrv(opsv, cc_opclassname(aTHX_ kid)), PTR2IV(kid));
	    walkoptree(aTHX_ opsv, method);
d408 1
d412 1
a412 1
typedef PADOP	*B__PADOP;
d438 1
a438 9
{
    HV *stash = gv_stashpvn("B", 1, TRUE);
    AV *export_ok = perl_get_av("B::EXPORT_OK",TRUE);
    specialsv_list[0] = Nullsv;
    specialsv_list[1] = &PL_sv_undef;
    specialsv_list[2] = &PL_sv_yes;
    specialsv_list[3] = &PL_sv_no;
#include "defsubs.h"
}
a443 1
#define B_amagic_generation()	PL_amagic_generation
a460 3
long 
B_amagic_generation()

a479 2
    CODE:
	walkoptree(aTHX_ opsv, method);
d490 14
a503 1
#define address(sv) PTR2IV(sv)
d517 1
a517 22
	RETVAL              

void
opnumber(name)
char *	name
CODE:
{
 int i; 
 IV  result = -1;
 ST(0) = sv_newmortal();
 if (strncmp(name,"pp_",3) == 0)
   name += 3;
 for (i = 0; i < PL_maxo; i++)
  {
   if (strcmp(name, PL_op_name[i]) == 0)
    {
     result = i;
     break;
    }
  }
 sv_setiv(ST(0),result);
}
d526 1
a526 1
	    sv_catpv(ST(0), PL_op_name[opnum]);
d536 1
a536 1
	char hexhash[19]; /* must fit "0xffffffffffffffff" plus trailing \0 */
d538 3
a540 2
	PERL_HASH(hash, s, len);
	sprintf(hexhash, "0x%"UVxf, (UV)hash);
a555 4
    CODE:
	RETVAL = cstring(aTHX_ sv);
    OUTPUT:
	RETVAL
a559 4
    CODE:
	RETVAL = cchar(aTHX_ sv);
    OUTPUT:
	RETVAL
d570 1
a570 1
	    PUSHs(sv_2mortal(newSVpvn(&PL_threadsv_names[i], 1)));
d576 1
a576 1
#define OP_desc(o)	PL_op_desc[o->op_type]
d594 1
a594 1
OP_name(o)
d598 2
a599 16
	sv_setpv(ST(0), PL_op_name[o->op_type]);


char *
OP_ppaddr(o)
	B::OP		o
    PREINIT:
	int i;
	SV *sv = sv_newmortal();
    CODE:
	sv_setpvn(sv, "PL_ppaddr[OP_", 13);
	sv_catpv(sv, PL_op_name[o->op_type]);
	for (i=13; i<SvCUR(sv); ++i)
	    SvPVX(sv)[i] = toUPPER(SvPVX(sv)[i]);
	sv_catpv(sv, "]");
	ST(0) = sv;
d605 1
a605 1
PADOFFSET
d649 13
d690 1
a690 1
		     PTR2IV(root));
d693 1
a693 1
	    sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ root)), PTR2IV(root));
d722 1
a722 2
#define SVOP_sv(o)	cSVOPo->op_sv
#define SVOP_gv(o)	((GV*)cSVOPo->op_sv)
d726 1
d731 1
a731 3
B::GV
SVOP_gv(o)
	B::SVOP	o
d733 1
a733 11
#define PADOP_padix(o)	o->op_padix
#define PADOP_sv(o)	(o->op_padix ? PL_curpad[o->op_padix] : Nullsv)
#define PADOP_gv(o)	((o->op_padix \
			  && SvTYPE(PL_curpad[o->op_padix]) == SVt_PVGV) \
			 ? (GV*)PL_curpad[o->op_padix] : Nullgv)

MODULE = B	PACKAGE = B::PADOP		PREFIX = PADOP_

PADOFFSET
PADOP_padix(o)
	B::PADOP o
a734 3
B::SV
PADOP_sv(o)
	B::PADOP o
d737 2
a738 2
PADOP_gv(o)
	B::PADOP o
d773 2
a774 3
#define COP_stashpv(o)	CopSTASHPV(o)
#define COP_stash(o)	CopSTASH(o)
#define COP_file(o)	CopFILE(o)
d777 1
a777 2
#define COP_line(o)	CopLINE(o)
#define COP_warnings(o)	o->cop_warnings
a784 4
char *
COP_stashpv(o)
	B::COP	o

d789 2
a790 2
char *
COP_file(o)
a804 4
B::SV
COP_warnings(o)
	B::COP	o

a824 5
UV 
SvUVX(sv) 
	B::IV   sv
                      

d847 1
a847 5
#ifdef UV_IS_QUAD
	    wp[0] = htonl(((UV)iv) >> (sizeof(UV)*4));
#else
	    wp[0] = htonl(((U32)iv) >> (sizeof(UV)*4));
#endif
d849 1
a849 1
	    ST(0) = sv_2mortal(newSVpvn((char *)wp, 8));
d852 1
a852 1
	    ST(0) = sv_2mortal(newSVpvn((char *)&w, 4));
a879 8
STRLEN
SvLEN(sv)
	B::PV	sv

STRLEN
SvCUR(sv)
	B::PV	sv

d888 1
a888 1
	    XPUSHs(make_mg_object(aTHX_ sv_newmortal(), mg));
a900 1
#define MgLENGTH(mg) mg->mg_len
a923 4
I32 
MgLENGTH(mg)
	B::MAGIC	mg
 
d929 2
a930 8
 	if (mg->mg_ptr){
		if (mg->mg_len >= 0){
	    		sv_setpvn(ST(0), mg->mg_ptr, mg->mg_len);
		} else {
			if (mg->mg_len == HEf_SVKEY)	
				sv_setsv(ST(0),newRV((SV*)mg->mg_ptr));
		}
	}
d972 1
a972 1
	ST(0) = sv_2mortal(newSVpvn(str + len + 1, 256));
d980 1
a980 9
	ST(0) = sv_2mortal(newSVpvn(GvNAME(gv), GvNAMELEN(gv)));

bool
is_empty(gv)
        B::GV   gv
    CODE:
        RETVAL = GvGP(gv) == Null(GP*);
    OUTPUT:
        RETVAL
a1021 4
char *
GvFILE(gv)
	B::GV	gv

d1116 1
a1116 1
		XPUSHs(make_sv_object(aTHX_ sv_newmortal(), svp[i]));
d1143 2
a1144 2
char *
CvFILE(cv)
d1163 1
a1163 1
	ST(0) = sv_2mortal(newSViv(PTR2IV(CvXSUB(cv))));
d1216 2
a1217 2
		PUSHs(newSVpvn(key, len));
		PUSHs(make_sv_object(aTHX_ sv_newmortal(), sv));
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d84 1
a84 1
static SV *specialsv_list[6];
a388 2
    specialsv_list[4] = pWARN_ALL;
    specialsv_list[5] = pWARN_NONE;
a393 2
#define B_begin_av()	PL_beginav_save
#define B_end_av()	PL_endav
a404 6
B::AV
B_begin_av()

B::AV
B_end_av()

a517 5
void
save_BEGINs()
    CODE:
	PL_minus_c |= 0x10;

d570 2
a571 3
	RETVAL = PL_op_name[o->op_type];
    OUTPUT:
	RETVAL
d574 1
a574 1
void
d636 2
a642 9
	OP *		kid = NO_INIT
	int		i = NO_INIT
    CODE:
	i = 0;
	for (kid = o->op_first; kid; kid = kid->op_sibling)
	    i++;
	RETVAL = i;
    OUTPUT:
        RETVAL
d696 2
a697 2
#define SVOP_sv(o)     cSVOPo->op_sv
#define SVOP_gv(o)     ((GV*)cSVOPo->op_sv)
d865 1
a865 1
NV
d869 1
a869 1
NV
a880 4
char*
SvPVX(sv)
	B::PV	sv

d1213 1
a1213 1
U16
d1254 1
a1254 1
	    while ((sv = hv_iternextsv(hv, &key, &len))) {
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d15 9
d82 1
a82 6
#define MY_CXT_KEY "B::_guts" XS_VERSION

typedef struct {
    int		x_walkoptree_debug;	/* Flag for walkoptree debug hook */
    SV *	x_specialsv_list[7];
} my_cxt_t;
d84 1
a84 4
START_MY_CXT

#define walkoptree_debug	(MY_CXT.x_walkoptree_debug)
#define specialsv_list		(MY_CXT.x_specialsv_list)
a203 1
    dMY_CXT;
d227 1
a227 1
cstring(pTHX_ SV *sv, bool perlstyle)
a231 1
    char escbuff[5]; /* to fit backslash, 3 octals + trailing \0 */
a234 28
    else if (perlstyle && SvUTF8(sv))
    {
	SV *tmpsv = sv_newmortal(); /* Temporary SV to feed sv_uni_display */
	len = SvCUR(sv);
	s = sv_uni_display(tmpsv, sv, 8*len, UNI_DISPLAY_QQ);
	sv_setpv(sstr,"\"");
	while (*s)
	{
	    if (*s == '"')
		sv_catpv(sstr, "\\\"");
	    else if (*s == '$')
		sv_catpv(sstr, "\\$");
	    else if (*s == '@@')
		sv_catpv(sstr, "\\@@");
	    else if (*s == '\\')
	    {
		if (strchr("nrftax\\",*(s+1)))
		    sv_catpvn(sstr, s++, 2);
		else
		    sv_catpv(sstr, "\\\\");
	    }
	    else /* should always be printable */
		sv_catpvn(sstr, s, 1);
	    ++s;
	}
	sv_catpv(sstr, "\"");
	return sstr;
    }
d247 1
a247 15
            /* trigraphs - bleagh */
            else if (!perlstyle && *s == '?' && len>=3 && s[1] == '?')
            {
                sprintf(escbuff, "\\%03o", '?');
                sv_catpv(sstr, escbuff);
            }
	    else if (perlstyle && *s == '$')
		sv_catpv(sstr, "\\$");
	    else if (perlstyle && *s == '@@')
		sv_catpv(sstr, "\\@@");
#ifdef EBCDIC
	    else if (isPRINT(*s))
#else
	    else if (*s >= ' ' && *s < 127)
#endif /* EBCDIC */
d261 1
a261 1
	    else if (!perlstyle && *s == '\v')
d265 2
d290 1
a290 5
#ifdef EBCDIC
    else if (isPRINT(*s))
#else
    else if (*s >= ' ' && *s < 127)
#endif /* EBCDIC */
d323 2
a324 3
    OP *o, *kid;
    dMY_CXT;

d340 1
a346 6
    if (o && (cc_opclass(aTHX_ o) == OPc_PMOP)
	    && (kid = cPMOPo->op_pmreplroot))
    {
	sv_setiv(newSVrv(opsv, opclassnames[OPc_PMOP]), PTR2IV(kid));
	walkoptree(aTHX_ opsv, method);
    }
a384 1
    MY_CXT_INIT;
a390 1
    specialsv_list[6] = pWARN_STD;
a404 3
#ifdef USE_ITHREADS
#define B_regex_padav()	PL_regex_padav
#endif
a414 7
#ifdef USE_ITHREADS

B::AV
B_regex_padav()

#endif

a451 1
	dMY_CXT;
d531 1
a531 1
	PL_savebegin = TRUE;
d537 1
a537 9
	RETVAL = cstring(aTHX_ sv, 0);
    OUTPUT:
	RETVAL

SV *
perlstring(sv)
	SV *	sv
    CODE:
	RETVAL = cstring(aTHX_ sv, 1);
d552 1
a552 1
#ifdef USE_5005THREADS
d599 1
a599 1
	for (i=13; (STRLEN)i < SvCUR(sv); ++i)
d670 1
a670 4
#define PMOP_pmregexp(o)	PM_GETRE(o)
#ifdef USE_ITHREADS
#define PMOP_pmoffset(o)	o->op_pmoffset
#endif
a672 1
#define PMOP_pmdynflags(o)      o->op_pmdynflags
a684 3
#ifdef USE_ITHREADS
            sv_setiv(ST(0), INT2PTR(PADOFFSET,root) );
#else
a687 1
#endif
d701 1
a701 9
#ifdef USE_ITHREADS

IV
PMOP_pmoffset(o)
	B::PMOP		o

#endif

U32
d705 1
a705 1
U32
a708 4
U8
PMOP_pmdynflags(o)
        B::PMOP         o

d715 1
a715 1
	rx = PM_GETRE(o);
d759 1
a759 1
	 * OP_TRANS uses op_pv to point to a table of 256 or >=258 shorts
d762 2
a763 13
	if (o->op_type == OP_TRANS &&
		(o->op_private & OPpTRANS_COMPLEMENT) &&
		!(o->op_private & OPpTRANS_DELETE))
	{
	    short* tbl = (short*)o->op_pv;
	    short entries = 257 + tbl[256];
	    ST(0) = sv_2mortal(newSVpv(o->op_pv, entries * sizeof(short)));
	}
	else if (o->op_type == OP_TRANS) {
	    ST(0) = sv_2mortal(newSVpv(o->op_pv, 256 * sizeof(short)));
	}
	else
	    ST(0) = sv_2mortal(newSVpv(o->op_pv, 0));
a907 13
B::SV
SvRV(sv)
        B::PV   sv
    CODE:
        if( SvROK(sv) ) {
            RETVAL = SvRV(sv);
        }
        else {
            croak( "argument is not SvROK" );
        }
    OUTPUT:
        RETVAL

d912 2
a913 10
        ST(0) = sv_newmortal();
        if( SvPOK(sv) ) { 
            sv_setpvn(ST(0), SvPVX(sv), SvCUR(sv));
            SvFLAGS(ST(0)) |= SvUTF8(sv);
        }
        else {
            /* XXX for backward compatibility, but should fail */
            /* croak( "argument is not SvPOK" ); */
            sv_setpvn(ST(0), NULL, 0);
        }
a944 1
#define MgREGEX(mg) PTR2IV(mg->mg_obj)
a966 37
    CODE:
        if( mg->mg_type != 'r' ) {
            RETVAL = MgOBJ(mg);
        }
        else {
            croak( "OBJ is not meaningful on r-magic" );
        }
    OUTPUT:
        RETVAL

IV
MgREGEX(mg)
	B::MAGIC	mg
    CODE:
        if( mg->mg_type == 'r' ) {
            RETVAL = MgREGEX(mg);
        }
        else {
            croak( "REGEX is only meaningful on r-magic" );
        }
    OUTPUT:
        RETVAL

SV*
precomp(mg)
        B::MAGIC        mg
    CODE:
        if (mg->mg_type == 'r') {
            REGEXP* rx = (REGEXP*)mg->mg_obj;
            if( rx )
                RETVAL = newSVpvn( rx->precomp, rx->prelen );
        }
        else {
            croak( "precomp is only meaningful on r-magic" );
        }
    OUTPUT:
        RETVAL
a1147 23
bool
IsSTD(io,name)
	B::IO	io
	char*	name
    PREINIT:
	PerlIO* handle = 0;
    CODE:
	if( strEQ( name, "stdin" ) ) {
	    handle = PerlIO_stdin();
	}
	else if( strEQ( name, "stdout" ) ) {
	    handle = PerlIO_stdout();
	}
	else if( strEQ( name, "stderr" ) ) {
	    handle = PerlIO_stderr();
	}
	else {
	    croak( "Invalid value '%s'", name );
	}
	RETVAL = handle == IoIFP(io);
    OUTPUT:
	RETVAL

d1236 1
a1236 3
	ST(0) = CvCONST(cv) ?
                    make_sv_object(aTHX_ sv_newmortal(),CvXSUBANY(cv).any_ptr) :
                    sv_2mortal(newSViv(CvXSUBANY(cv).any_iv));
a1242 6

MODULE = B	PACKAGE = B::CV		PREFIX = cv_

B::SV
cv_const_sv(cv)
	B::CV	cv
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d52 3
a54 2
    OPc_LOOP,	/* 10 */
    OPc_COP	/* 11 */
d68 1
a72 15
static size_t opsizes[] = {
    0,	
    sizeof(OP),
    sizeof(UNOP),
    sizeof(BINOP),
    sizeof(LOGOP),
    sizeof(LISTOP),
    sizeof(PMOP),
    sizeof(SVOP),
    sizeof(PADOP),
    sizeof(PVOP),
    sizeof(LOOP),
    sizeof(COP)	
};

d98 1
a98 2
    if (o->op_type == OP_GV || o->op_type == OP_GVSV ||
	o->op_type == OP_AELEMFAST || o->op_type == OP_RCATLINE)
a399 38
SV **
oplist(pTHX_ OP *o, SV **SP)
{
    for(; o; o = o->op_next) {
	SV *opsv;
	if (o->op_seq == 0) 
	    break;
	o->op_seq = 0;
	opsv = sv_newmortal();
	sv_setiv(newSVrv(opsv, cc_opclassname(aTHX_ (OP*)o)), PTR2IV(o));
	XPUSHs(opsv);
        switch (o->op_type) {
	case OP_SUBST:
            SP = oplist(aTHX_ cPMOPo->op_pmreplstart, SP);
            continue;
	case OP_SORT:
	    if (o->op_flags & OPf_STACKED && o->op_flags & OPf_SPECIAL) {
		OP *kid = cLISTOPo->op_first->op_sibling;   /* pass pushmark */
		kid = kUNOP->op_first;                      /* pass rv2gv */
		kid = kUNOP->op_first;                      /* pass leave */
		SP = oplist(aTHX_ kid->op_next, SP);
	    }
	    continue;
        }
	switch (PL_opargs[o->op_type] & OA_CLASS_MASK) {
	case OA_LOGOP:
	    SP = oplist(aTHX_ cLOGOPo->op_other, SP);
	    break;
	case OA_LOOP:
	    SP = oplist(aTHX_ cLOOPo->op_lastop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_nextop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_redoop, SP);
	    break;
	}
    }
    return SP;
}

a419 1
typedef SV	*B__FM;
a448 2
#define B_inc_gv()	PL_incgv
#define B_check_av()	PL_checkav_save
a453 3
#define B_defstash()	PL_defstash
#define B_curstash()	PL_curstash
#define B_dowarn()	PL_dowarn
a457 1
#define B_formfeed()	PL_formfeed
a465 3
B_check_av()

B::AV
a470 3
B::GV
B_inc_gv()

d502 1
a502 16
B::HV
B_curstash()

B::HV
B_defstash()

U8
B_dowarn()

B::SV
B_formfeed()

void
B_warnhook()
    CODE:
	ST(0) = make_sv_object(aTHX_ sv_newmortal(), PL_warnhook);
a503 6
void
B_diehook()
    CODE:
	ST(0) = make_sv_object(aTHX_ sv_newmortal(), PL_diehook);

MODULE = B	PACKAGE = B
a644 8
size_t
OP_size(o)
	B::OP		o
    CODE:
	RETVAL = opsizes[cc_opclass(aTHX_ o)];
    OUTPUT:
	RETVAL

a699 6
void
OP_oplist(o)
	B::OP		o
    PPCODE:
	SP = oplist(aTHX_ o, SP);

a744 3
#define PMOP_pmstashpv(o)	o->op_pmstashpv
#else
#define PMOP_pmstash(o)		o->op_pmstash
a786 10
char*
PMOP_pmstashpv(o)
	B::PMOP		o

#else

B::HV
PMOP_pmstash(o)
	B::PMOP		o

d825 1
a825 1
#define PADOP_sv(o)	(o->op_padix ? PAD_SVl(o->op_padix) : Nullsv)
d827 2
a828 2
			  && SvTYPE(PAD_SVl(o->op_padix)) == SVt_PVGV) \
			 ? (GV*)PAD_SVl(o->op_padix) : Nullgv)
a890 1
#define COP_filegv(o)	CopFILEGV(o)
a894 1
#define COP_io(o)	o->cop_io
a913 5
B::GV
COP_filegv(o)
       B::COP  o


d922 1
a922 1
U32
a929 17
B::SV
COP_io(o)
	B::COP	o

MODULE = B	PACKAGE = B::SV

U32
SvTYPE(sv)
	B::SV	sv

#define object_2svref(sv)	sv
#define SVREF SV *
	
SVREF
object_2svref(sv)
	B::SV	sv

a939 12
U32
SvPOK(sv)
	B::SV	sv

U32
SvROK(sv)
	B::SV	sv

U32
SvMAGICAL(sv)
	B::SV	sv

a1038 9
void
SvPVBM(sv)
	B::PV	sv
    CODE:
        ST(0) = sv_newmortal();
	sv_setpvn(ST(0), SvPVX(sv),
	    SvCUR(sv) + (SvTYPE(sv) == SVt_PVBM ? 257 : 0));


a1075 9
     CODE:
	if( MgMOREMAGIC(mg) ) {
	    RETVAL = MgMOREMAGIC(mg);
	}
	else {
	    XSRETURN_UNDEF;
	}
     OUTPUT:
	RETVAL
d1092 9
d1142 3
a1144 3
		} else if (mg->mg_len == HEf_SVKEY) {
			ST(0) = make_sv_object(aTHX_
				    sv_newmortal(), (SV*)mg->mg_ptr);
a1205 4
void*
GvGP(gv)
	B::GV	gv

d1218 1
a1218 1
B::FM
a1220 4
    CODE:
	RETVAL = (SV*)GvFORM(gv);
    OUTPUT:
	RETVAL
d1242 1
a1242 1
U32
a1369 11
void
AvARRAYelt(av, idx)
	B::AV	av
	int	idx
    PPCODE:
    	if (idx >= 0 && AvFILL(av) >= 0 && idx <= AvFILL(av))
	    XPUSHs(make_sv_object(aTHX_ sv_newmortal(), (AvARRAY(av)[idx])));
	else
	    XPUSHs(make_sv_object(aTHX_ sv_newmortal(), NULL));

				   
a1375 6
MODULE = B	PACKAGE = B::FM		PREFIX = Fm

IV
FmLINES(form)
	B::FM	form

a1377 4
U32
CvCONST(cv)
	B::CV	cv

a1409 4
U32
CvOUTSIDE_SEQ(cv)
	B::CV	cv

d1422 2
a1423 2
	    make_sv_object(aTHX_ sv_newmortal(),CvXSUBANY(cv).any_ptr) :
	    sv_2mortal(newSViv(CvXSUBANY(cv).any_iv));
@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@a31 3
#if PERL_VERSION >= 9
    "B::GV",
#endif
a35 1
#if PERL_VERSION <= 8
a36 1
#endif
d419 1
a419 6
#if PERL_VERSION >= 9
	if (o->op_opt == 0)
	    break;
	o->op_opt = 0;
#else
	if (o->op_seq == 0)
a421 1
#endif
a496 3
#if PERL_VERSION <= 8
#  define CVf_ASSERTION	0
#endif
d710 1
a710 2
#if PERL_VERSION <= 8
# ifdef USE_5005THREADS
a716 1
# endif
d719 1
d725 1
a725 6
#if PERL_VERSION >= 9
#  define OP_opt(o)	o->op_opt
#  define OP_static(o)	o->op_static
#else
#  define OP_seq(o)	o->op_seq
#endif
a727 1
#define OP_spare(o)	o->op_spare
a781 12
#if PERL_VERSION >= 9

U8
OP_opt(o)
	B::OP		o

U8
OP_static(o)
	B::OP		o

#else

a785 2
#endif

a792 8

#if PERL_VERSION >= 9

U8
OP_spare(o)
	B::OP		o

#endif
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d104 1
a104 1
cc_opclass(pTHX_ const OP *o)
d212 1
a212 1
cc_opclassname(pTHX_ const OP *o)
d249 3
d255 2
a256 1
    else if (perlstyle && SvUTF8(sv)) {
d258 3
a260 3
	const STRLEN len = SvCUR(sv);
	const char *s = sv_uni_display(tmpsv, sv, 8*len, UNI_DISPLAY_QQ);
	sv_setpvn(sstr,"\"",1);
d264 1
a264 1
		sv_catpvn(sstr, "\\\"", 2);
d266 1
a266 1
		sv_catpvn(sstr, "\\$", 2);
d268 1
a268 1
		sv_catpvn(sstr, "\\@@", 2);
d274 1
a274 1
		    sv_catpvn(sstr, "\\\\", 2);
d286 1
a286 2
	STRLEN len;
	const char *s = SvPV(sv, len);
d296 2
a297 2
            else if (!perlstyle && *s == '?' && len>=3 && s[1] == '?') {
		char escbuff[5]; /* to fit backslash, 3 octals + trailing \0 */
d328 1
a328 2
		char escbuff[5]; /* to fit backslash, 3 octals + trailing \0 */
		const unsigned char c = (unsigned char) *s;
d343 2
a344 1
    const char *s = SvPV_nolen(sv);
d347 1
a347 1
	sv_catpvn(sstr, "\\'", 2);
d349 1
a349 1
	sv_catpvn(sstr, "\\\\", 2);
d357 1
a357 1
	sv_catpvn(sstr, "\\n", 2);
d359 1
a359 1
	sv_catpvn(sstr, "\\r", 2);
d361 1
a361 1
	sv_catpvn(sstr, "\\t", 2);
d363 1
a363 1
	sv_catpvn(sstr, "\\a", 2);
d365 1
a365 1
	sv_catpvn(sstr, "\\b", 2);
d367 1
a367 1
	sv_catpvn(sstr, "\\f", 2);
d369 1
a369 1
	sv_catpvn(sstr, "\\v", 2);
d379 1
a379 1
    sv_catpvn(sstr, "'", 1);
d383 2
a384 2
static void
walkoptree(pTHX_ SV *opsv, const char *method)
d411 1
a411 1
    if (o && (cc_opclass(aTHX_ o) == OPc_PMOP) && o->op_type != OP_PUSHRE
d414 1
a414 1
	sv_setiv(newSVrv(opsv, cc_opclassname(aTHX_ kid)), PTR2IV(kid));
d419 1
a419 1
static SV **
d608 1
a608 1
	const char *	method
d640 1
a640 1
const char *	name
d673 1
d677 1
a677 1
	const char *s = SvPV(sv, len);
d727 1
a727 1
	const STRLEN len = strlen(PL_threadsv_names);
d1014 2
a1015 2
	    const short* const tbl = (short*)o->op_pv;
	    const short entries = 257 + tbl[256];
d1161 1
a1161 1
	    const IV iv = SvIVX(sv);
d1221 2
a1222 10
        if( SvPOK(sv) ) {
	    /* FIXME - we need a better way for B to identify PVs that are
	       in the pads as variable names.  */
	    if((SvLEN(sv) && SvCUR(sv) >= SvLEN(sv))) {
		/* It claims to be longer than the space allocated for it -
		   presuambly it's a variable name in the pad  */
		sv_setpv(ST(0), SvPV_nolen_const(sv));
	    } else {
		sv_setpvn(ST(0), SvPVX_const(sv), SvCUR(sv));
	    }
d1236 1
a1236 1
	sv_setpvn(ST(0), SvPVX_const(sv),
d1522 1
a1522 1
	const char*	name
d1656 1
a1656 1
	    make_sv_object(aTHX_ sv_newmortal(),(SV *)CvXSUBANY(cv).any_ptr) :
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d22 1
a22 1
static const char* const svclassnames[] = {
a23 3
#if PERL_VERSION >= 9
    "B::BIND",
#endif
a30 1
#if PERL_VERSION <= 8
a31 1
#endif
d61 1
a61 1
static const char* const opclassnames[] = {
d76 1
a76 1
static const size_t opsizes[] = {
a114 11
    if (o->op_type == OP_AELEMFAST) {
	if (o->op_flags & OPf_SPECIAL)
	    return OPc_BASEOP;
	else
#ifdef USE_ITHREADS
	    return OPc_PADOP;
#else
	    return OPc_SVOP;
#endif
    }
    
d117 1
a117 1
	o->op_type == OP_RCATLINE)
d214 1
a214 1
    return (char *)opclassnames[cc_opclass(aTHX_ o)];
d220 1
a220 1
    const char *type = 0;
a237 65
#if PERL_VERSION >= 9
static SV *
make_temp_object(pTHX_ SV *arg, SV *temp)
{
    SV *target;
    const char *const type = svclassnames[SvTYPE(temp)];
    const IV iv = PTR2IV(temp);

    target = newSVrv(arg, type);
    sv_setiv(target, iv);

    /* Need to keep our "temp" around as long as the target exists.
       Simplest way seems to be to hang it from magic, and let that clear
       it up.  No vtable, so won't actually get in the way of anything.  */
    sv_magicext(target, temp, PERL_MAGIC_sv, NULL, NULL, 0);
    /* magic object has had its reference count increased, so we must drop
       our reference.  */
    SvREFCNT_dec(temp);
    return arg;
}

static SV *
make_warnings_object(pTHX_ SV *arg, STRLEN *warnings)
{
    const char *type = 0;
    dMY_CXT;
    IV iv = sizeof(specialsv_list)/sizeof(SV*);

    /* Counting down is deliberate. Before the split between make_sv_object
       and make_warnings_obj there appeared to be a bug - Nullsv and pWARN_STD
       were both 0, so you could never get a B::SPECIAL for pWARN_STD  */

    while (iv--) {
	if ((SV*)warnings == specialsv_list[iv]) {
	    type = "B::SPECIAL";
	    break;
	}
    }
    if (type) {
	sv_setiv(newSVrv(arg, type), iv);
	return arg;
    } else {
	/* B assumes that warnings are a regular SV. Seems easier to keep it
	   happy by making them into a regular SV.  */
	return make_temp_object(aTHX_ arg,
				newSVpvn((char *)(warnings + 1), *warnings));
    }
}

static SV *
make_cop_io_object(pTHX_ SV *arg, COP *cop)
{
    SV *const value = newSV(0);

    Perl_emulate_cop_io(aTHX_ cop, value);

    if(SvOK(value)) {
	return make_temp_object(aTHX_ arg, newSVsv(value));
    } else {
	SvREFCNT_dec(value);
	return make_sv_object(aTHX_ arg, NULL);
    }
}
#endif

d409 1
a409 6
#if PERL_VERSION >= 9
	    && (kid = cPMOPo->op_pmreplrootu.op_pmreplroot)
#else
	    && (kid = cPMOPo->op_pmreplroot)
#endif
	)
a434 3
#if PERL_VERSION >= 9
            SP = oplist(aTHX_ cPMOPo->op_pmstashstartu.op_pmreplstart, SP);
#else
a435 1
#endif
a487 4
typedef HE      *B__HE;
#if PERL_VERSION >= 9
typedef struct refcounted_he	*B__RHE;
#endif
d495 1
a495 1
    HV *stash = gv_stashpvn("B", 1, GV_ADD);
d502 3
a504 3
    specialsv_list[4] = (SV *) pWARN_ALL;
    specialsv_list[5] = (SV *) pWARN_NONE;
    specialsv_list[6] = (SV *) pWARN_STD;
d506 1
a506 1
#  define OPpPAD_STATE 0
a514 5
#if PERL_VERSION > 8
#  define B_unitcheck_av()	PL_unitcheckav_save
#else
#  define B_unitcheck_av()	NULL
#endif
a519 1
#define B_sub_generation()	PL_sub_generation
a537 7
#if PERL_VERSION >= 9

B::AV
B_unitcheck_av()

#endif

a565 3
long
B_sub_generation()

d733 1
a733 1
#define OP_desc(o)	(char *)PL_op_desc[o->op_type]
d738 1
d768 1
a768 1
	RETVAL = (char *)PL_op_name[o->op_type];
d805 4
d878 2
a879 7
#if PERL_VERSION >= 9
#  define PMOP_pmreplstart(o)	o->op_pmstashstartu.op_pmreplstart
#else
#  define PMOP_pmreplstart(o)	o->op_pmreplstart
#  define PMOP_pmpermflags(o)	o->op_pmpermflags
#  define PMOP_pmdynflags(o)      o->op_pmdynflags
#endif
d884 1
a884 1
#define PMOP_pmstashpv(o)	PmopSTASHPV(o);
d886 1
a886 1
#define PMOP_pmstash(o)		PmopSTASH(o);
d889 2
a893 2
#if PERL_VERSION <= 8

d903 1
a903 1
#  ifdef USE_ITHREADS
d905 1
a905 1
#  else
d909 1
a909 1
#  endif
a914 25
#else

void
PMOP_pmreplroot(o)
	B::PMOP		o
    CODE:
	ST(0) = sv_newmortal();
	if (o->op_type == OP_PUSHRE) {
#  ifdef USE_ITHREADS
            sv_setiv(ST(0), o->op_pmreplrootu.op_pmtargetoff);
#  else
	    GV *const target = o->op_pmreplrootu.op_pmtargetgv;
	    sv_setiv(newSVrv(ST(0), target ?
			     svclassnames[SvTYPE((SV*)target)] : "B::SV"),
		     PTR2IV(target));
#  endif
	}
	else {
	    OP *const root = o->op_pmreplrootu.op_pmreplroot; 
	    sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ root)),
		     PTR2IV(root));
	}

#endif

a918 2
#if PERL_VERSION < 9

a922 2
#endif

a944 2
#if PERL_VERSION < 9

a952 2
#endif

a962 14
#if PERL_VERSION >= 9

void
PMOP_reflags(o)
	B::PMOP		o
	REGEXP *	rx = NO_INIT
    CODE:
	ST(0) = sv_newmortal();
	rx = PM_GETRE(o);
	if (rx)
	    sv_setuv(ST(0), rx->extflags);

#endif

d1045 1
a1045 1
#define COP_arybase(o)	CopARYBASE_get(o)
d1047 2
a1048 5
#define COP_hints(o)	CopHINTS_get(o)
#if PERL_VERSION < 9
#  define COP_warnings(o)  o->cop_warnings
#  define COP_io(o)	o->cop_io
#endif
a1084 26
#if PERL_VERSION >= 9

void
COP_warnings(o)
	B::COP	o
	PPCODE:
	ST(0) = make_warnings_object(aTHX_ sv_newmortal(), o->cop_warnings);
	XSRETURN(1);

void
COP_io(o)
	B::COP	o
	PPCODE:
	ST(0) = make_cop_io_object(aTHX_ sv_newmortal(), o);
	XSRETURN(1);

B::RHE
COP_hints_hash(o)
	B::COP o
    CODE:
	RETVAL = o->cop_hints_hash;
    OUTPUT:
	RETVAL

#else

a1092 6
#endif

U32
COP_hints(o)
	B::COP	o

a1186 16
U32
COP_SEQ_RANGE_LOW(sv)
	B::NV	sv

U32
COP_SEQ_RANGE_HIGH(sv)
	B::NV	sv

U32
PARENT_PAD_INDEX(sv)
	B::NV	sv

U32
PARENT_FAKELEX_FLAGS(sv)
	B::NV	sv

a1234 3
# This used to read 257. I think that that was buggy - should have been 258.
# (The "\0", the flags byte, and 256 for the table.  Not that anything
# anywhere calls this method.  NWC.
d1241 1
a1241 1
	    SvCUR(sv) + (SvVALID(sv) ? 256 + PERL_FBM_TABLE_OFFSET : 0));
d1311 1
a1311 1
        if(mg->mg_type == PERL_MAGIC_qr) {
d1324 1
a1324 1
        if (mg->mg_type == PERL_MAGIC_qr) {
a1325 1
            RETVAL = Nullsv;
d1377 1
a1377 1
U32
d1393 1
a1393 1
	ST(0) = sv_2mortal(newSVpvn(str + len + PERL_FBM_TABLE_OFFSET, 256));
a1410 12
bool
isGV_with_GP(gv)
	B::GV	gv
    CODE:
#if PERL_VERSION >= 9
	RETVAL = isGV_with_GP(gv) ? TRUE : FALSE;
#else
	RETVAL = TRUE; /* In 5.8 and earlier they all are.  */
#endif
    OUTPUT:
	RETVAL

a1518 2
#if PERL_VERSION <= 8

a1522 2
#endif

a1565 3
#if PERL_VERSION < 9
			   

a1571 2
#endif

a1592 1
#if PERL_VERSION < 9
a1599 2
#endif

a1618 4
    CODE:
	RETVAL = CvISXSUB(cv) ? NULL : CvSTART(cv);
    OUTPUT:
	RETVAL
a1622 4
    CODE:
	RETVAL = CvISXSUB(cv) ? NULL : CvROOT(cv);
    OUTPUT:
	RETVAL
d1652 1
a1652 1
	ST(0) = sv_2mortal(newSViv(CvISXSUB(cv) ? PTR2IV(CvXSUB(cv)) : 0));
d1661 1
a1661 1
	    sv_2mortal(newSViv(CvISXSUB(cv) ? CvXSUBANY(cv).any_iv : 0));
a1697 2
#if PERL_VERSION < 9

a1701 2
#endif

a1716 28

MODULE = B	PACKAGE = B::HE		PREFIX = He

B::SV
HeVAL(he)
	B::HE he

U32
HeHASH(he)
	B::HE he

B::SV
HeSVKEY_force(he)
	B::HE he

MODULE = B	PACKAGE = B::RHE	PREFIX = RHE_

#if PERL_VERSION >= 9

SV*
RHE_HASH(h)
	B::RHE h
    CODE:
	RETVAL = newRV( (SV*)Perl_refcounted_he_chain_2hv(aTHX_ h) );
    OUTPUT:
	RETVAL

#endif
@


1.1.1.9
log
@import perl 5.10.1
@
text
@a28 1
#if PERL_VERSION <= 10
a29 1
#endif
a36 3
#if PERL_VERSION >= 11
    "B::REGEXP",
#endif
a460 10
#if PERL_VERSION >= 9
#  define PMOP_pmreplstart(o)	o->op_pmstashstartu.op_pmreplstart
#  define PMOP_pmreplroot(o)	o->op_pmreplrootu.op_pmreplroot
#else
#  define PMOP_pmreplstart(o)	o->op_pmreplstart
#  define PMOP_pmreplroot(o)	o->op_pmreplroot
#  define PMOP_pmpermflags(o)	o->op_pmpermflags
#  define PMOP_pmdynflags(o)      o->op_pmdynflags
#endif

d490 6
a495 1
           && (kid = PMOP_pmreplroot(cPMOPo)))
d521 5
a525 1
            SP = oplist(aTHX_ PMOP_pmreplstart(cPMOPo), SP);
a566 3
#if PERL_VERSION >= 11
typedef SV	*B__REGEXP;
#endif
d590 1
a590 1
    AV *export_ok = perl_get_av("B::EXPORT_OK", GV_ADD);
d910 1
a910 1
U16
d932 1
a932 1
U16
d983 7
d1104 1
a1104 1
	    sv_setpvn(ST(0), RX_PRECOMP(rx), RX_PRELEN(rx));
d1116 1
a1116 1
	    sv_setuv(ST(0), RX_EXTFLAGS(rx));
d1137 1
a1137 1
			 ? (GV*)PAD_SVl(o->op_padix) : (GV *)NULL)
d1196 1
a1196 1
#define COP_label(o)	CopLABEL(o)
a1211 8
#if PERL_VERSION >= 11

const char *
COP_label(o)
	B::COP	o

#else

a1215 2
#endif

a1368 18

#if PERL_VERSION >= 11

B::SV
RV(sv)
        B::IV   sv
    CODE:
        if( SvROK(sv) ) {
            RETVAL = SvRV(sv);
        }
        else {
            croak( "argument is not SvROK" );
        }
    OUTPUT:
        RETVAL

#endif

a1394 2
#if PERL_VERSION < 11

a1400 2
#endif

a1478 25
MODULE = B	PACKAGE = B::REGEXP

#if PERL_VERSION >= 11

IV
REGEX(sv)
	B::REGEXP	sv
    CODE:
	RETVAL = PTR2IV(((struct xregexp *)SvANY(sv))->xrx_regexp);
    OUTPUT:
        RETVAL

SV*
precomp(sv)
	B::REGEXP	sv
	REGEXP* rx = NO_INIT
    CODE:
	rx = ((struct xregexp *)SvANY(sv))->xrx_regexp;
	/* FIXME - UTF-8? And the equivalent precomp methods? */
	RETVAL = newSVpvn( RX_PRECOMP(rx), RX_PRELEN(rx) );
    OUTPUT:
        RETVAL

#endif

d1539 1
a1539 1
                RETVAL = newSVpvn( RX_PRECOMP(rx), RX_PRELEN(rx) );
d1961 1
a1961 1
		mPUSHp(key, len);
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d334 1
a334 1
    SV *sstr = newSVpvs("");
d337 1
a337 1
	sv_setpvs(sstr, "0");
d342 1
a342 1
	sv_setpvs(sstr,"\"");
d346 1
a346 1
		sv_catpvs(sstr, "\\\"");
d348 1
a348 1
		sv_catpvs(sstr, "\\$");
d350 1
a350 1
		sv_catpvs(sstr, "\\@@");
d356 1
a356 1
		    sv_catpvs(sstr, "\\\\");
d362 1
a362 1
	sv_catpvs(sstr, "\"");
d370 1
a370 1
	sv_catpvs(sstr, "\"");
d375 1
a375 1
		sv_catpvs(sstr, "\\\"");
d377 1
a377 1
		sv_catpvs(sstr, "\\\\");
d381 2
a382 2
		const STRLEN oct_len = my_sprintf(escbuff, "\\%03o", '?');
                sv_catpvn(sstr, escbuff, oct_len);
d385 1
a385 1
		sv_catpvs(sstr, "\\$");
d387 1
a387 1
		sv_catpvs(sstr, "\\@@");
d395 1
a395 1
		sv_catpvs(sstr, "\\n");
d397 1
a397 1
		sv_catpvs(sstr, "\\r");
d399 1
a399 1
		sv_catpvs(sstr, "\\t");
d401 1
a401 1
		sv_catpvs(sstr, "\\a");
d403 1
a403 1
		sv_catpvs(sstr, "\\b");
d405 1
a405 1
		sv_catpvs(sstr, "\\f");
d407 1
a407 1
		sv_catpvs(sstr, "\\v");
d413 2
a414 2
		const STRLEN oct_len = my_sprintf(escbuff, "\\%03o", c);
		sv_catpvn(sstr, escbuff, oct_len);
d418 1
a418 1
	sv_catpvs(sstr, "\"");
d426 1
a426 1
    SV *sstr = newSVpvs("'");
d430 1
a430 1
	sv_catpvs(sstr, "\\'");
d432 1
a432 1
	sv_catpvs(sstr, "\\\\");
d440 1
a440 1
	sv_catpvs(sstr, "\\n");
d442 1
a442 1
	sv_catpvs(sstr, "\\r");
d444 1
a444 1
	sv_catpvs(sstr, "\\t");
d446 1
a446 1
	sv_catpvs(sstr, "\\a");
d448 1
a448 1
	sv_catpvs(sstr, "\\b");
d450 1
a450 1
	sv_catpvs(sstr, "\\f");
d452 1
a452 1
	sv_catpvs(sstr, "\\v");
d459 2
a460 2
	const STRLEN oct_len = my_sprintf(escbuff, "\\%03o", c);
	sv_catpvn(sstr, escbuff, oct_len);
d462 1
a462 1
    sv_catpvs(sstr, "'");
d598 1
a598 1
    HV *stash = gv_stashpvs("B", GV_ADD);
d781 1
a781 1
	    sv_setpvs(ST(0), "pp_");
d794 2
a795 2
	len = my_sprintf(hexhash, "0x%"UVxf, (UV)hash);
	ST(0) = newSVpvn_flags(hexhash, len, SVs_TEMP);
d846 1
a846 1
	    PUSHs(newSVpvn_flags(&PL_threadsv_names[i], 1, SVs_TEMP));
d898 1
a898 1
	sv_setpvs(sv, "PL_ppaddr[OP_");
d902 1
a902 1
	sv_catpvs(sv, "]");
d1171 1
a1171 1
	    ST(0) = newSVpvn_flags(o->op_pv, entries * sizeof(short), SVs_TEMP);
d1174 1
a1174 1
	    ST(0) = newSVpvn_flags(o->op_pv, 256 * sizeof(short), SVs_TEMP);
d1177 1
a1177 1
	    ST(0) = newSVpvn_flags(o->op_pv, strlen(o->op_pv), SVs_TEMP);
d1375 1
a1375 1
	    ST(0) = newSVpvn_flags((char *)wp, 8, SVs_TEMP);
d1378 1
a1378 1
	    ST(0) = newSVpvn_flags((char *)&w, 4, SVs_TEMP);
d1521 1
a1521 2
	/* FIXME - can we code this method more efficiently?  */
	RETVAL = PTR2IV(sv);
d1528 1
d1530 3
a1532 1
	RETVAL = newSVpvn( RX_PRECOMP(sv), RX_PRELEN(sv) );
d1664 1
a1664 1
	ST(0) = newSVpvn_flags(str + len + PERL_FBM_TABLE_OFFSET, 256, SVs_TEMP);
d1672 1
a1672 5
#if PERL_VERSION >= 10
	ST(0) = sv_2mortal(newSVhek(GvNAME_HEK(gv)));
#else
	ST(0) = newSVpvn_flags(GvNAME(gv), GvNAMELEN(gv), SVs_TEMP);
#endif
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a115 2
    bool custom = 0;

a125 1
#if PERL_VERSION <= 14
a128 1
#endif
d142 1
a142 4
    if (o->op_type == OP_CUSTOM)
        custom = 1;

    switch (OP_CLASS(o)) {
d172 1
a172 2
         * the OP is an SVOP (or, under threads, a PADOP),
         * and the SV is a reference to a swash
d175 1
a175 7
	return (!custom &&
		   (o->op_private & (OPpTRANS_TO_UTF|OPpTRANS_FROM_UTF))
	       )
#if  defined(USE_ITHREADS) \
  && (PERL_VERSION > 8 || (PERL_VERSION == 8 && PERL_SUBVERSION >= 9))
		? OPc_PADOP : OPc_PVOP;
#else
a176 1
#endif
d228 1
a228 1
	 OP_NAME(o));
d232 2
a233 2
static SV *
make_op_object(pTHX_ const OP *o)
d235 1
a235 3
    SV *opsv = sv_newmortal();
    sv_setiv(newSVrv(opsv, opclassnames[cc_opclass(aTHX_ o)]), PTR2IV(o));
    return opsv;
d239 1
a239 1
make_sv_object(pTHX_ SV *sv)
a240 1
    SV *const arg = sv_newmortal();
d244 2
a245 2

    for (iv = 0; iv < (IV)(sizeof(specialsv_list)/sizeof(SV*)); iv++) {
d261 1
a261 1
make_temp_object(pTHX_ SV *temp)
a263 1
    SV *arg = sv_newmortal();
d281 1
a281 1
make_warnings_object(pTHX_ const COP *const cop)
a282 1
    const STRLEN *const warnings = cop->cop_warnings;
a297 1
	SV *arg = sv_newmortal();
d303 2
a304 1
	return make_temp_object(aTHX_ newSVpvn((char *)(warnings + 1), *warnings));
d309 1
a309 1
make_cop_io_object(pTHX_ COP *cop)
d316 1
a316 1
	return make_sv_object(aTHX_ value);
d319 1
a319 1
	return make_sv_object(aTHX_ NULL);
d325 1
a325 1
make_mg_object(pTHX_ MAGIC *mg)
a326 1
    SV *arg = sv_newmortal();
d334 1
a334 1
    SV *sstr;
d337 2
a338 5
	return newSVpvs_flags("0", SVs_TEMP);

    sstr = newSVpvs_flags("\"", SVs_TEMP);

    if (perlstyle && SvUTF8(sv)) {
d342 1
d362 2
d370 1
d380 3
a382 1
                Perl_sv_catpvf(aTHX_ sstr, "\\%03o", '?');
d411 1
d413 2
a414 1
		Perl_sv_catpvf(aTHX_ sstr, "\\%03o", c);
d418 1
a419 1
    sv_catpvs(sstr, "\"");
d426 1
a426 1
    SV *sstr = newSVpvs_flags("'", SVs_TEMP);
a427 2
    /* Don't want promotion of a signed -1 char in sprintf args */
    const unsigned char c = (unsigned char) *s;
d429 1
a429 1
    if (c == '\'')
d431 1
a431 1
    else if (c == '\\')
d434 1
a434 1
    else if (isPRINT(c))
d436 1
a436 1
    else if (c >= ' ' && c < 127)
d439 1
a439 1
    else if (c == '\n')
d441 1
a441 1
    else if (c == '\r')
d443 1
a443 1
    else if (c == '\t')
d445 1
a445 1
    else if (c == '\a')
d447 1
a447 1
    else if (c == '\b')
d449 1
a449 1
    else if (c == '\f')
d451 1
a451 1
    else if (c == '\v')
d454 8
a461 1
	Perl_sv_catpvf(aTHX_ sstr, "\\%03o", c);
d476 2
a477 2
static SV *
walkoptree(pTHX_ OP *o, const char *method, SV *ref)
d480 1
a480 3
    OP *kid;
    SV *object;
    const char *const classname = opclassnames[cc_opclass(aTHX_ o)];
d483 4
a486 15
    /* Check that no-one has changed our reference, or is holding a reference
       to it.  */
    if (SvREFCNT(ref) == 1 && SvROK(ref) && SvTYPE(ref) == SVt_RV
	&& (object = SvRV(ref)) && SvREFCNT(object) == 1
	&& SvTYPE(object) == SVt_PVMG && SvIOK_only(object)
	&& !SvMAGICAL(object) && !SvMAGIC(object) && SvSTASH(object)) {
	/* Looks good, so rebless it for the class we need:  */
	sv_bless(ref, gv_stashpv(classname, GV_ADD));
    } else {
	/* Need to make a new one. */
	ref = sv_newmortal();
	object = newSVrv(ref, classname);
    }
    sv_setiv(object, PTR2IV(o));

d489 1
a489 1
	XPUSHs(ref);
d494 1
a494 1
    XPUSHs(ref);
d499 3
a501 1
	    ref = walkoptree(aTHX_ kid, method, ref);
d507 2
a508 1
	ref = walkoptree(aTHX_ kid, method, ref);
a509 1
    return ref;
d516 1
d526 3
a528 1
	XPUSHs(make_op_object(aTHX_ o));
d592 1
a592 32
#ifdef MULTIPLICITY
#  define ASSIGN_COMMON_ALIAS(prefix, var) \
    STMT_START { XSANY.any_i32 = offsetof(struct interpreter, prefix##var); } STMT_END
#else
#  define ASSIGN_COMMON_ALIAS(prefix, var) \
    STMT_START { XSANY.any_ptr = (void *)&PL_##var; } STMT_END
#endif

/* This needs to be ALIASed in a custom way, hence can't easily be defined as
   a regular XSUB.  */
static XSPROTO(intrpvar_sv_common); /* prototype to pass -Wmissing-prototypes */
static XSPROTO(intrpvar_sv_common)
{
    dVAR;
    dXSARGS;
    SV *ret;
    if (items != 0)
       croak_xs_usage(cv,  "");
#ifdef MULTIPLICITY
    ret = *(SV **)(XSANY.any_i32 + (char *)my_perl);
#else
    ret = *(SV **)(XSANY.any_ptr);
#endif
    ST(0) = make_sv_object(aTHX_ ret);
    XSRETURN(1);
}

#include "const-c.inc"

MODULE = B	PACKAGE = B

INCLUDE: const-xs.inc
d598 2
a599 2
    CV *cv;
    const char *file = __FILE__;
d608 39
a646 5
    
    cv = newXS("B::init_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, initav);
    cv = newXS("B::check_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, checkav_save);
d648 4
a651 2
    cv = newXS("B::unitcheck_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, unitcheckav_save);
d653 10
a662 14
    cv = newXS("B::begin_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, beginav_save);
    cv = newXS("B::end_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, endav);
    cv = newXS("B::main_cv", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, main_cv);
    cv = newXS("B::inc_gv", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, incgv);
    cv = newXS("B::defstash", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, defstash);
    cv = newXS("B::curstash", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, curstash);
    cv = newXS("B::formfeed", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, formfeed);
d664 4
a667 2
    cv = newXS("B::regex_padav", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, regex_padav);
d669 9
a677 5
    cv = newXS("B::warnhook", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, warnhook);
    cv = newXS("B::diehook", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, diehook);
}
d680 25
a704 5
amagic_generation()
    CODE:
	RETVAL = PL_amagic_generation;
    OUTPUT:
	RETVAL
d706 2
a707 5
void
comppadlist()
    PPCODE:
	PUSHs(make_sv_object(aTHX_ (SV *)(PL_main_cv ? CvPADLIST(PL_main_cv)
						     : CvPADLIST(PL_compcv))));
d710 3
a712 8
sv_undef()
    ALIAS:
	sv_no = 1
	sv_yes = 2
    PPCODE:
	PUSHs(make_sv_object(aTHX_ ix > 1 ? &PL_sv_yes
					  : ix < 1 ? &PL_sv_undef
						   : &PL_sv_no));
d715 3
a717 5
main_root()
    ALIAS:
	main_start = 1
    PPCODE:
	PUSHs(make_op_object(aTHX_ ix ? PL_main_start : PL_main_root));
d719 1
a719 8
UV
sub_generation()
    ALIAS:
	dowarn = 1
    CODE:
	RETVAL = ix ? PL_dowarn : PL_sub_generation;
    OUTPUT:
	RETVAL
d722 2
a723 2
walkoptree(op, method)
	B::OP op
d726 1
a726 1
	(void) walkoptree(aTHX_ op, method, &PL_sv_undef);
d744 1
a744 1
void
d747 1
a747 1
    PPCODE:
d750 3
a752 1
	PUSHs(make_sv_object(aTHX_ SvRV(sv)));
d780 4
a783 2
	if (opnum >= 0 && opnum < PL_maxo)
	    Perl_sv_setpvf(aTHX_ ST(0), "pp_%s", PL_op_name[opnum]);
d791 2
a792 1
	const char *s = SvPVbyte(sv, len);
d794 2
a795 1
	ST(0) = sv_2mortal(Perl_newSVpvf(aTHX_ "0x%"UVxf, (UV)hash));
a803 2
    ALIAS:
	save_BEGINs = 1
d805 1
a805 4
	if (ix)
	    PL_savebegin = TRUE;
	else
	    PL_minus_c = TRUE;
d808 5
d815 20
a834 5
    ALIAS:
	perlstring = 1
	cchar = 2
    PPCODE:
	PUSHs(ix == 2 ? cchar(aTHX_ sv) : cstring(aTHX_ sv, (bool)ix));
d850 5
a854 42
#define SVp		0x00000
#define U32p		0x10000
#define line_tp		0x20000
#define OPp		0x30000
#define PADOFFSETp	0x40000
#define U8p		0x50000
#define IVp		0x60000
#define char_pp		0x70000

#define OP_next_ix		OPp | offsetof(struct op, op_next)
#define OP_sibling_ix		OPp | offsetof(struct op, op_sibling)
#define UNOP_first_ix		OPp | offsetof(struct unop, op_first)
#define BINOP_last_ix		OPp | offsetof(struct binop, op_last)
#define LOGOP_other_ix		OPp | offsetof(struct logop, op_other)
#if PERL_VERSION >= 9
#  define PMOP_pmreplstart_ix \
		OPp | offsetof(struct pmop, op_pmstashstartu.op_pmreplstart)
#else
#  define PMOP_pmreplstart_ix	OPp | offsetof(struct pmop, op_pmreplstart)
#endif
#define LOOP_redoop_ix		OPp | offsetof(struct loop, op_redoop)
#define LOOP_nextop_ix		OPp | offsetof(struct loop, op_nextop)
#define LOOP_lastop_ix		OPp | offsetof(struct loop, op_lastop)

#define OP_targ_ix		PADOFFSETp | offsetof(struct op, op_targ)
#define OP_flags_ix		U8p | offsetof(struct op, op_flags)
#define OP_private_ix		U8p | offsetof(struct op, op_private)

#define PMOP_pmflags_ix		U32p | offsetof(struct pmop, op_pmflags)

#ifdef USE_ITHREADS
#define PMOP_pmoffset_ix	IVp | offsetof(struct pmop, op_pmoffset)
#endif

#  Yes, B::SV::sv and B::SV::gv really do end up generating identical code.
#define SVOP_sv_ix		SVp | offsetof(struct svop, op_sv)
#define SVOP_gv_ix		SVp | offsetof(struct svop, op_sv)

#define PADOP_padix_ix		PADOFFSETp | offsetof(struct padop, op_padix)

#define COP_seq_ix		U32p | offsetof(struct cop, cop_seq)
#define COP_line_ix		line_tp | offsetof(struct cop, cop_line)
d856 1
a856 8
#define COP_hints_ix		U32p | offsetof(struct cop, cop_hints)
#else
#define COP_hints_ix		U8p | offsetof(struct cop, op_private)
#endif

#ifdef USE_ITHREADS
#define COP_stashpv_ix		char_pp | offsetof(struct cop, cop_stashpv)
#define COP_file_ix		char_pp | offsetof(struct cop, cop_file)
d858 1
a858 2
#define COP_stash_ix		SVp | offsetof(struct cop, cop_stash)
#define COP_filegv_ix		SVp | offsetof(struct cop, cop_filegv)
d860 3
d864 1
a864 1
MODULE = B	PACKAGE = B::OP
d867 1
a867 1
size(o)
d874 2
a875 5
# The type checking code in B has always been identical for all OP types,
# irrespective of whether the action is actually defined on that OP.
# We should fix this
void
next(o)
a876 54
    ALIAS:
	B::OP::next = OP_next_ix
	B::OP::sibling = OP_sibling_ix
	B::OP::targ = OP_targ_ix
	B::OP::flags = OP_flags_ix
	B::OP::private = OP_private_ix
	B::UNOP::first = UNOP_first_ix
	B::BINOP::last = BINOP_last_ix
	B::LOGOP::other = LOGOP_other_ix
	B::PMOP::pmreplstart = PMOP_pmreplstart_ix
	B::LOOP::redoop = LOOP_redoop_ix
	B::LOOP::nextop = LOOP_nextop_ix
	B::LOOP::lastop = LOOP_lastop_ix
	B::PMOP::pmflags = PMOP_pmflags_ix
	B::SVOP::sv = SVOP_sv_ix
	B::SVOP::gv = SVOP_gv_ix
	B::PADOP::padix = PADOP_padix_ix
	B::COP::cop_seq = COP_seq_ix
	B::COP::line = COP_line_ix
	B::COP::hints = COP_hints_ix
    PREINIT:
	char *ptr;
	SV *ret;
    PPCODE:
	ptr = (ix & 0xFFFF) + (char *)o;
	switch ((U8)(ix >> 16)) {
	case (U8)(OPp >> 16):
	    ret = make_op_object(aTHX_ *((OP **)ptr));
	    break;
	case (U8)(PADOFFSETp >> 16):
	    ret = sv_2mortal(newSVuv(*((PADOFFSET*)ptr)));
	    break;
	case (U8)(U8p >> 16):
	    ret = sv_2mortal(newSVuv(*((U8*)ptr)));
	    break;
	case (U8)(U32p >> 16):
	    ret = sv_2mortal(newSVuv(*((U32*)ptr)));
	    break;
	case (U8)(SVp >> 16):
	    ret = make_sv_object(aTHX_ *((SV **)ptr));
	    break;
	case (U8)(line_tp >> 16):
	    ret = sv_2mortal(newSVuv(*((line_t *)ptr)));
	    break;
#ifdef USE_ITHREADS
	case (U8)(IVp >> 16):
	    ret = sv_2mortal(newSViv(*((IV*)ptr)));
	    break;
	case (U8)(char_pp >> 16):
	    ret = sv_2mortal(newSVpv(*((char **)ptr), 0));
	    break;
#endif
	default:
	    croak("Illegal alias 0x%08x for B::*next", (unsigned)ix);
d878 3
a880 3
	}
	ST(0) = ret;
	XSRETURN(1);
d883 1
a883 1
name(o)
a884 2
    ALIAS:
	desc = 1
d886 1
a886 1
	RETVAL = (char *)(ix ? OP_DESC(o) : OP_NAME(o));
d890 1
d892 1
a892 1
ppaddr(o)
d896 1
a896 1
	SV *sv;
d898 2
a899 2
	sv = sv_2mortal(Perl_newSVpvf(aTHX_ "PL_ppaddr[OP_%s]",
				      PL_op_name[o->op_type]));
d902 1
d905 12
d918 3
a920 3
#  These 3 are all bitfields, so we can't take their addresses.
UV
type(o)
a921 16
    ALIAS:
	opt = 1
	spare = 2
    CODE:
	switch(ix) {
	  case 1:
	    RETVAL = o->op_opt;
	    break;
	  case 2:
	    RETVAL = o->op_spare;
	    break;
	  default:
	    RETVAL = o->op_type;
	}
    OUTPUT:
	RETVAL
d925 18
a942 2
UV
type(o)
a943 12
    ALIAS:
	seq = 1
    CODE:
	switch(ix) {
	  case 1:
	    RETVAL = o->op_seq;
	    break;
	  default:
	    RETVAL = o->op_type;
	}
    OUTPUT:
	RETVAL
d948 1
a948 1
oplist(o)
d953 25
a977 1
MODULE = B	PACKAGE = B::LISTOP
d980 1
a980 1
children(o)
d990 11
a1000 1
	RETVAL
d1011 1
a1014 1
	    ST(0) = sv_newmortal();
d1024 1
a1024 1
	    ST(0) = make_op_object(aTHX_ root);
d1033 1
a1035 1
	    ST(0) = sv_newmortal();
a1038 1
	    ST(0) = sv_newmortal();
d1046 2
a1047 1
	    ST(0) = make_op_object(aTHX_ root);
d1052 12
d1065 4
a1068 1
#define PMOP_pmstashpv(o)	PmopSTASHPV(o);
d1076 1
a1076 1
void
a1078 2
    PPCODE:
	PUSHs(make_sv_object(aTHX_ (SV *) PmopSTASH(o)));
d1082 4
a1087 6
void
PMOP_pmnext(o)
	B::PMOP		o
    PPCODE:
	PUSHs(make_op_object(aTHX_ o->op_pmnext));

d1101 1
a1101 3
    PREINIT:
	dXSI32;
	REGEXP *rx;
d1103 1
d1105 10
d1116 4
a1119 5
	if (rx) {
#if PERL_VERSION >= 9
	    if (ix) {
		sv_setuv(ST(0), RX_EXTFLAGS(rx));
	    } else
a1120 4
	    {
		sv_setpvn(ST(0), RX_PRECOMP(rx), RX_PRELEN(rx));
	    }
	}
d1122 24
a1145 21
BOOT:
{
	CV *cv;
#ifdef USE_ITHREADS
        cv = newXS("B::PMOP::pmoffset", XS_B__OP_next, __FILE__);
        XSANY.any_i32 = PMOP_pmoffset_ix;
        cv = newXS("B::COP::stashpv", XS_B__OP_next, __FILE__);
        XSANY.any_i32 = COP_stashpv_ix;
        cv = newXS("B::COP::file", XS_B__OP_next, __FILE__);
        XSANY.any_i32 = COP_file_ix;
#else
        cv = newXS("B::COP::stash", XS_B__OP_next, __FILE__);
        XSANY.any_i32 = COP_stash_ix;
        cv = newXS("B::COP::filegv", XS_B__OP_next, __FILE__);
        XSANY.any_i32 = COP_filegv_ix;
#endif
#if PERL_VERSION >= 9
        cv = newXS("B::PMOP::reflags", XS_B__PMOP_precomp, __FILE__);
        XSANY.any_i32 = 1;
#endif
}
d1147 3
a1149 1
MODULE = B	PACKAGE = B::PADOP
d1151 2
a1152 2
void
sv(o)
a1153 17
    PREINIT:
	SV *ret;
    ALIAS:
	gv = 1
    PPCODE:
	/* It happens that the output typemaps for B::SV and B::GV are
	   identical. The "smarts" are in make_sv_object(), which determines
	   which class to use based on SvTYPE(), rather than anything baked in
	   at compile time.  */	   
	if (o->op_padix) {
	    ret = PAD_SVl(o->op_padix);
	    if (ix && SvTYPE(ret) != SVt_PVGV)
		ret = NULL;
	} else {
	    ret = NULL;
	}
	PUSHs(make_sv_object(aTHX_ ret));
d1155 1
a1155 1
MODULE = B	PACKAGE = B::PVOP
d1158 1
a1158 1
pv(o)
d1165 1
a1165 1
	if ((o->op_type == OP_TRANS || o->op_type == OP_TRANSR) &&
d1173 1
a1173 1
	else if (o->op_type == OP_TRANS || o->op_type == OP_TRANSR) {
d1179 19
d1199 11
a1209 2
#ifdef CopSTASH_len
#define COP_stashlen(o)	CopSTASH_len(o)
d1214 2
d1220 1
a1220 6
# Both pairs of accessors are provided for both ithreads and not, but for each,
# one pair is direct structure access, and 1 pair "faked up" with a more complex
# macro. We implement the direct structure access pair using the common code
# above (B::OP::next)
 
#ifdef USE_ITHREADS
d1222 2
a1223 2
void
COP_stash(o)
a1224 5
    ALIAS:
	filegv = 1
    PPCODE:
	PUSHs(make_sv_object(aTHX_
			     ix ? (SV *)CopFILEGV(o) : (SV *)CopSTASH(o)));
d1226 1
a1226 1
#ifdef CopSTASH_len
d1228 2
a1229 2
U32
COP_stashlen(o)
d1232 3
a1234 3
#endif

#else
d1237 1
a1237 1
COP_stashpv(o)
a1238 6
    ALIAS:
	file = 1
    CODE:
	RETVAL = ix ? CopFILE(o) : CopSTASHPV(o);
    OUTPUT:
	RETVAL
d1240 8
a1247 1
#endif
d1252 6
a1257 4
    CODE:
	RETVAL = 0;
    OUTPUT:
	RETVAL
d1262 2
a1263 8
    ALIAS:
	io = 1
    PPCODE:
#if PERL_VERSION >= 9
	ST(0) = ix ? make_cop_io_object(aTHX_ o) : make_warnings_object(aTHX_ o);
#else
	ST(0) = make_sv_object(aTHX_ ix ? o->cop_io : o->cop_warnings);
#endif
d1266 6
a1271 1
#if PERL_VERSION >= 9
d1277 1
a1277 1
	RETVAL = CopHINTHASH_get(o);
d1281 10
d1293 4
a1298 2
#define MAGICAL_FLAG_BITS (SVs_GMG|SVs_SMG|SVs_RMG)

d1300 1
a1300 1
REFCNT(sv)
a1301 10
    ALIAS:
	FLAGS = 0xFFFFFFFF
	SvTYPE = SVTYPEMASK
	POK = SVf_POK
	ROK = SVf_ROK
	MAGICAL = MAGICAL_FLAG_BITS
    CODE:
	RETVAL = ix ? (SvFLAGS(sv) & (U32)ix) : SvREFCNT(sv);
    OUTPUT:
	RETVAL
d1303 4
a1306 1
void
a1308 5
    PPCODE:
	ST(0) = sv_2mortal(newRV(sv));
	XSRETURN(1);
	
MODULE = B	PACKAGE = B::IV		PREFIX = Sv
d1310 5
a1314 3
IV
SvIV(sv)
	B::IV	sv
d1316 3
a1318 1
MODULE = B	PACKAGE = B::IV
d1320 3
a1322 16
#define sv_SVp		0x00000
#define sv_IVp		0x10000
#define sv_UVp		0x20000
#define sv_STRLENp	0x30000
#define sv_U32p		0x40000
#define sv_U8p		0x50000
#define sv_char_pp	0x60000
#define sv_NVp		0x70000
#define sv_char_p	0x80000
#define sv_SSize_tp	0x90000
#define sv_I32p		0xA0000
#define sv_U16p		0xB0000

#define IV_ivx_ix	sv_IVp | offsetof(struct xpviv, xiv_iv)
#define IV_uvx_ix	sv_UVp | offsetof(struct xpvuv, xuv_uv)
#define NV_nvx_ix	sv_NVp | offsetof(struct xpvnv, xnv_u.xnv_nv)
d1324 3
a1326 19
#if PERL_VERSION >= 10
#define NV_cop_seq_range_low_ix \
			sv_U32p | offsetof(struct xpvnv, xnv_u.xpad_cop_seq.xlow)
#define NV_cop_seq_range_high_ix \
			sv_U32p | offsetof(struct xpvnv, xnv_u.xpad_cop_seq.xhigh)
#define NV_parent_pad_index_ix \
			sv_U32p | offsetof(struct xpvnv, xnv_u.xpad_cop_seq.xlow)
#define NV_parent_fakelex_flags_ix \
			sv_U32p | offsetof(struct xpvnv, xnv_u.xpad_cop_seq.xhigh)
#else
#define NV_cop_seq_range_low_ix \
			sv_NVp | offsetof(struct xpvnv, xnv_nv)
#define NV_cop_seq_range_high_ix \
			sv_UVp | offsetof(struct xpvnv, xuv_uv)
#define NV_parent_pad_index_ix \
			sv_NVp | offsetof(struct xpvnv, xnv_nv)
#define NV_parent_fakelex_flags_ix \
			sv_UVp | offsetof(struct xpvnv, xuv_uv)
#endif
d1328 3
a1330 2
#define PV_cur_ix	sv_STRLENp | offsetof(struct xpv, xpv_cur)
#define PV_len_ix	sv_STRLENp | offsetof(struct xpv, xpv_len)
d1332 1
a1332 1
#define PVMG_stash_ix	sv_SVp | offsetof(struct xpvmg, xmg_stash)
d1334 3
a1336 14
#if PERL_VERSION >= 10
#  if PERL_VERSION > 14
#    define PVBM_useful_ix	sv_I32p | offsetof(struct xpvgv, xnv_u.xbm_s.xbm_useful)
#    define PVBM_previous_ix	sv_UVp | offsetof(struct xpvuv, xuv_uv)
#  else
#define PVBM_useful_ix	sv_I32p | offsetof(struct xpvgv, xiv_u.xivu_i32)
#define PVBM_previous_ix    sv_U32p | offsetof(struct xpvgv, xnv_u.xbm_s.xbm_previous)
#  endif
#define PVBM_rare_ix	sv_U8p | offsetof(struct xpvgv, xnv_u.xbm_s.xbm_rare)
#else
#define PVBM_useful_ix	sv_I32p | offsetof(struct xpvbm, xbm_useful)
#define PVBM_previous_ix    sv_U16p | offsetof(struct xpvbm, xbm_previous)
#define PVBM_rare_ix	sv_U8p | offsetof(struct xpvbm, xbm_rare)
#endif
d1338 3
a1340 4
#define PVLV_targoff_ix	sv_U32p | offsetof(struct xpvlv, xlv_targoff)
#define PVLV_targlen_ix	sv_U32p | offsetof(struct xpvlv, xlv_targlen)
#define PVLV_targ_ix	sv_SVp | offsetof(struct xpvlv, xlv_targ)
#define PVLV_type_ix	sv_char_p | offsetof(struct xpvlv, xlv_type)
d1342 4
a1345 34
#if PERL_VERSION >= 10
#define PVGV_stash_ix	sv_SVp | offsetof(struct xpvgv, xnv_u.xgv_stash)
#define PVGV_flags_ix	sv_STRLENp | offsetof(struct xpvgv, xpv_cur)
#define PVIO_lines_ix	sv_IVp | offsetof(struct xpvio, xiv_iv)
#else
#define PVGV_stash_ix	sv_SVp | offsetof(struct xpvgv, xgv_stash)
#define PVGV_flags_ix	sv_U8p | offsetof(struct xpvgv, xgv_flags)
#define PVIO_lines_ix	sv_IVp | offsetof(struct xpvio, xio_lines)
#endif

#define PVIO_page_ix	    sv_IVp | offsetof(struct xpvio, xio_page)
#define PVIO_page_len_ix    sv_IVp | offsetof(struct xpvio, xio_page_len)
#define PVIO_lines_left_ix  sv_IVp | offsetof(struct xpvio, xio_lines_left)
#define PVIO_top_name_ix    sv_char_pp | offsetof(struct xpvio, xio_top_name)
#define PVIO_top_gv_ix	    sv_SVp | offsetof(struct xpvio, xio_top_gv)
#define PVIO_fmt_name_ix    sv_char_pp | offsetof(struct xpvio, xio_fmt_name)
#define PVIO_fmt_gv_ix	    sv_SVp | offsetof(struct xpvio, xio_fmt_gv)
#define PVIO_bottom_name_ix sv_char_pp | offsetof(struct xpvio, xio_bottom_name)
#define PVIO_bottom_gv_ix   sv_SVp | offsetof(struct xpvio, xio_bottom_gv)
#define PVIO_type_ix	    sv_char_p | offsetof(struct xpvio, xio_type)
#define PVIO_flags_ix	    sv_U8p | offsetof(struct xpvio, xio_flags)

#define PVAV_max_ix	sv_SSize_tp | offsetof(struct xpvav, xav_max)

#define PVFM_lines_ix	sv_IVp | offsetof(struct xpvfm, xfm_lines)

#define PVCV_stash_ix	sv_SVp | offsetof(struct xpvcv, xcv_stash) 
#define PVCV_gv_ix	sv_SVp | offsetof(struct xpvcv, xcv_gv)
#define PVCV_file_ix	sv_char_pp | offsetof(struct xpvcv, xcv_file)
#define PVCV_depth_ix	sv_I32p | offsetof(struct xpvcv, xcv_depth)
#define PVCV_padlist_ix	sv_SVp | offsetof(struct xpvcv, xcv_padlist)
#define PVCV_outside_ix	sv_SVp | offsetof(struct xpvcv, xcv_outside)
#define PVCV_outside_seq_ix sv_U32p | offsetof(struct xpvcv, xcv_outside_seq)
#define PVCV_flags_ix	sv_U16p | offsetof(struct xpvcv, xcv_flags)
d1347 1
a1347 1
#define PVHV_max_ix	sv_STRLENp | offsetof(struct xpvhv, xhv_max)
d1349 1
a1349 5
#if PERL_VERSION > 12
#define PVHV_keys_ix	sv_STRLENp | offsetof(struct xpvhv, xhv_keys)
#else
#define PVHV_keys_ix	sv_IVp | offsetof(struct xpvhv, xhv_keys)
#endif
d1351 3
a1353 97
# The type checking code in B has always been identical for all SV types,
# irrespective of whether the action is actually defined on that SV.
# We should fix this
void
IVX(sv)
	B::SV		sv
    ALIAS:
	B::IV::IVX = IV_ivx_ix
	B::IV::UVX = IV_uvx_ix
	B::NV::NVX = NV_nvx_ix
	B::NV::COP_SEQ_RANGE_LOW = NV_cop_seq_range_low_ix
	B::NV::COP_SEQ_RANGE_HIGH = NV_cop_seq_range_high_ix
	B::NV::PARENT_PAD_INDEX = NV_parent_pad_index_ix
	B::NV::PARENT_FAKELEX_FLAGS = NV_parent_fakelex_flags_ix
	B::PV::CUR = PV_cur_ix
	B::PV::LEN = PV_len_ix
	B::PVMG::SvSTASH = PVMG_stash_ix
	B::PVLV::TARGOFF = PVLV_targoff_ix
	B::PVLV::TARGLEN = PVLV_targlen_ix
	B::PVLV::TARG = PVLV_targ_ix
	B::PVLV::TYPE = PVLV_type_ix
	B::GV::STASH = PVGV_stash_ix
	B::GV::GvFLAGS = PVGV_flags_ix
	B::BM::USEFUL = PVBM_useful_ix
	B::BM::PREVIOUS = PVBM_previous_ix
	B::BM::RARE = PVBM_rare_ix
	B::IO::LINES =  PVIO_lines_ix
	B::IO::PAGE = PVIO_page_ix
	B::IO::PAGE_LEN = PVIO_page_len_ix
	B::IO::LINES_LEFT = PVIO_lines_left_ix
	B::IO::TOP_NAME = PVIO_top_name_ix
	B::IO::TOP_GV = PVIO_top_gv_ix
	B::IO::FMT_NAME = PVIO_fmt_name_ix
	B::IO::FMT_GV = PVIO_fmt_gv_ix
	B::IO::BOTTOM_NAME = PVIO_bottom_name_ix
	B::IO::BOTTOM_GV = PVIO_bottom_gv_ix
	B::IO::IoTYPE = PVIO_type_ix
	B::IO::IoFLAGS = PVIO_flags_ix
	B::AV::MAX = PVAV_max_ix
	B::FM::LINES = PVFM_lines_ix
	B::CV::STASH = PVCV_stash_ix
	B::CV::GV = PVCV_gv_ix
	B::CV::FILE = PVCV_file_ix
	B::CV::DEPTH = PVCV_depth_ix
	B::CV::PADLIST = PVCV_padlist_ix
	B::CV::OUTSIDE = PVCV_outside_ix
	B::CV::OUTSIDE_SEQ = PVCV_outside_seq_ix
	B::CV::CvFLAGS = PVCV_flags_ix
	B::HV::MAX = PVHV_max_ix
	B::HV::KEYS = PVHV_keys_ix
    PREINIT:
	char *ptr;
	SV *ret;
    PPCODE:
	ptr = (ix & 0xFFFF) + (char *)SvANY(sv);
	switch ((U8)(ix >> 16)) {
	case (U8)(sv_SVp >> 16):
	    ret = make_sv_object(aTHX_ *((SV **)ptr));
	    break;
	case (U8)(sv_IVp >> 16):
	    ret = sv_2mortal(newSViv(*((IV *)ptr)));
	    break;
	case (U8)(sv_UVp >> 16):
	    ret = sv_2mortal(newSVuv(*((UV *)ptr)));
	    break;
	case (U8)(sv_STRLENp >> 16):
	    ret = sv_2mortal(newSVuv(*((STRLEN *)ptr)));
	    break;
	case (U8)(sv_U32p >> 16):
	    ret = sv_2mortal(newSVuv(*((U32 *)ptr)));
	    break;
	case (U8)(sv_U8p >> 16):
	    ret = sv_2mortal(newSVuv(*((U8 *)ptr)));
	    break;
	case (U8)(sv_char_pp >> 16):
	    ret = sv_2mortal(newSVpv(*((char **)ptr), 0));
	    break;
	case (U8)(sv_NVp >> 16):
	    ret = sv_2mortal(newSVnv(*((NV *)ptr)));
	    break;
	case (U8)(sv_char_p >> 16):
	    ret = newSVpvn_flags((char *)ptr, 1, SVs_TEMP);
	    break;
	case (U8)(sv_SSize_tp >> 16):
	    ret = sv_2mortal(newSViv(*((SSize_t *)ptr)));
	    break;
	case (U8)(sv_I32p >> 16):
	    ret = sv_2mortal(newSVuv(*((I32 *)ptr)));
	    break;
	case (U8)(sv_U16p >> 16):
	    ret = sv_2mortal(newSVuv(*((U16 *)ptr)));
	    break;
	default:
	    croak("Illegal alias 0x%08x for B::*IVX", (unsigned)ix);
	}
	ST(0) = ret;
	XSRETURN(1);
a1357 2
    ALIAS:
	needs64bits = 1
d1359 1
a1359 3
	if (ix) {
	    ST(0) = boolSV((I32)SvIVX(sv) != SvIVX(sv));
	} else if (sizeof(IV) == 8) {
d1381 18
d1405 20
d1429 1
a1429 1
void
a1431 2
    PPCODE:
	PUSHs(make_sv_object(aTHX_ SvRV(sv)));
d1433 1
a1433 1
#else
d1435 1
a1435 1
MODULE = B	PACKAGE = B::REGEXP
d1437 3
a1439 13
void
REGEX(sv)
	B::REGEXP	sv
    ALIAS:
	precomp = 1
    PPCODE:
	if (ix) {
	    PUSHs(newSVpvn_flags(RX_PRECOMP(sv), RX_PRELEN(sv), SVs_TEMP));
	} else {
	    dXSTARG;
	    /* FIXME - can we code this method more efficiently?  */
	    PUSHi(PTR2IV(sv));
	}
d1441 2
a1442 6
#endif

MODULE = B	PACKAGE = B::PV

void
RV(sv)
d1444 5
a1448 2
    PPCODE:
        if (!SvROK(sv))
d1450 3
a1452 1
	PUSHs(make_sv_object(aTHX_ SvRV(sv)));
d1455 1
a1455 1
PV(sv)
d1457 6
a1462 58
    ALIAS:
	PVX = 1
	PVBM = 2
	B::BM::TABLE = 3
    PREINIT:
	const char *p;
	STRLEN len = 0;
	U32 utf8 = 0;
    CODE:
	if (ix == 3) {
#ifndef PERL_FBM_TABLE_OFFSET
	    const MAGIC *const mg = mg_find(sv, PERL_MAGIC_bm);

	    if (!mg)
                croak("argument to B::BM::TABLE is not a PVBM");
	    p = mg->mg_ptr;
	    len = mg->mg_len;
#else
	    p = SvPV(sv, len);
	    /* Boyer-Moore table is just after string and its safety-margin \0 */
	    p += len + PERL_FBM_TABLE_OFFSET;
	    len = 256;
#endif
	} else if (ix == 2) {
	    /* This used to read 257. I think that that was buggy - should have
	       been 258. (The "\0", the flags byte, and 256 for the table.)
	       The only user of this method is B::Bytecode in B::PV::bsave.
	       I'm guessing that nothing tested the runtime correctness of
	       output of bytecompiled string constant arguments to index (etc).

	       Note the start pointer is and has always been SvPVX(sv), not
	       SvPVX(sv) + SvCUR(sv) PVBM was added in 651aa52ea1faa806, and
	       first used by the compiler in 651aa52ea1faa806. It's used to
	       get a "complete" dump of the buffer at SvPVX(), not just the
	       PVBM table. This permits the generated bytecode to "load"
	       SvPVX in "one" hit.

	       5.15 and later store the BM table via MAGIC, so the compiler
	       should handle this just fine without changes if PVBM now
	       always returns the SvPVX() buffer.  */
	    p = SvPVX_const(sv);
#ifdef PERL_FBM_TABLE_OFFSET
	    len = SvCUR(sv) + (SvVALID(sv) ? 256 + PERL_FBM_TABLE_OFFSET : 0);
#else
	    len = SvCUR(sv);
#endif
	} else if (ix) {
	    p = SvPVX(sv);
	    len = strlen(p);
	} else if (SvPOK(sv)) {
	    len = SvCUR(sv);
	    p = SvPVX_const(sv);
	    utf8 = SvUTF8(sv);
#if PERL_VERSION < 10
	    /* Before 5.10 (well 931b58fb28fa5ca7), PAD_COMPNAME_GEN was stored
	       in SvCUR(), which meant we had to attempt this special casing
	       to avoid tripping up over variable names in the pads.  */
	    if((SvLEN(sv) && len >= SvLEN(sv))) {
d1464 4
a1467 2
		   presumably it's a variable name in the pad  */
		len = strlen(p);
d1469 1
a1469 1
#endif
d1474 1
a1474 1
	    p = NULL;
a1475 1
	ST(0) = newSVpvn_flags(p, len, SVs_TEMP | utf8);
d1477 21
a1497 1
MODULE = B	PACKAGE = B::PVMG
d1500 1
a1500 1
MAGIC(sv)
d1505 57
a1561 1
	    XPUSHs(make_mg_object(aTHX_ mg));
d1563 24
a1586 1
MODULE = B	PACKAGE = B::MAGIC
d1588 20
d1609 1
a1609 1
MOREMAGIC(mg)
d1611 5
a1615 34
    ALIAS:
	PRIVATE = 1
	TYPE = 2
	FLAGS = 3
	LENGTH = 4
	OBJ = 5
	PTR = 6
	REGEX = 7
	precomp = 8
    PPCODE:
	switch (ix) {
	case 0:
	    XPUSHs(mg->mg_moremagic ? make_mg_object(aTHX_ mg->mg_moremagic)
				    : &PL_sv_undef);
	    break;
	case 1:
	    mPUSHu(mg->mg_private);
	    break;
	case 2:
	    PUSHs(newSVpvn_flags(&(mg->mg_type), 1, SVs_TEMP));
	    break;
	case 3:
	    mPUSHu(mg->mg_flags);
	    break;
	case 4:
	    mPUSHi(mg->mg_len);
	    break;
	case 5:
	    PUSHs(make_sv_object(aTHX_ mg->mg_obj));
	    break;
	case 6:
	    if (mg->mg_ptr) {
		if (mg->mg_len >= 0) {
		    PUSHs(newSVpvn_flags(mg->mg_ptr, mg->mg_len, SVs_TEMP));
d1617 3
a1619 22
		    PUSHs(make_sv_object(aTHX_ (SV*)mg->mg_ptr));
		} else
		    PUSHs(sv_newmortal());
	    } else
		PUSHs(sv_newmortal());
	    break;
	case 7:
	    if(mg->mg_type == PERL_MAGIC_qr) {
                mPUSHi(PTR2IV(mg->mg_obj));
	    } else {
		croak("REGEX is only meaningful on r-magic");
	    }
	    break;
	case 8:
	    if (mg->mg_type == PERL_MAGIC_qr) {
		REGEXP *rx = (REGEXP *)mg->mg_obj;
		PUSHs(newSVpvn_flags(rx ? RX_PRECOMP(rx) : NULL,
				     rx ? RX_PRELEN(rx) : 0, SVs_TEMP));
	    } else {
		croak( "precomp is only meaningful on r-magic" );
	    }
	    break;
d1622 42
a1668 3
    ALIAS:
	FILE = 1
	B::HV::NAME = 2
d1671 1
a1671 3
	ST(0) = sv_2mortal(newSVhek(!ix ? GvNAME_HEK(gv)
					: (ix == 1 ? GvFILE_HEK(gv)
						   : HvNAME_HEK((HV *)gv))));
d1673 1
a1673 2
	ST(0) = !ix ? newSVpvn_flags(GvNAME(gv), GvNAMELEN(gv), SVs_TEMP)
		    : sv_2mortal(newSVpv(ix == 1 ? GvFILE(gv) : HvNAME((HV *)gv), 0))
a1678 2
    ALIAS:
	isGV_with_GP = 1
d1680 8
a1687 1
	if (ix) {
d1689 1
a1689 1
	    RETVAL = isGV_with_GP(gv) ? TRUE : FALSE;
d1691 1
a1691 1
	    RETVAL = TRUE; /* In 5.8 and earlier they all are.  */
a1692 3
	} else {
            RETVAL = GvGP(gv) == Null(GP*);
	}
d1694 1
a1694 1
        RETVAL
d1700 51
a1750 10
#define GP_sv_ix	SVp | offsetof(struct gp, gp_sv)
#define GP_io_ix	SVp | offsetof(struct gp, gp_io)
#define GP_cv_ix	SVp | offsetof(struct gp, gp_cv)
#define GP_cvgen_ix	U32p | offsetof(struct gp, gp_cvgen)
#define GP_refcnt_ix	U32p | offsetof(struct gp, gp_refcnt)
#define GP_hv_ix	SVp | offsetof(struct gp, gp_hv)
#define GP_av_ix	SVp | offsetof(struct gp, gp_av)
#define GP_form_ix	SVp | offsetof(struct gp, gp_form)
#define GP_egv_ix	SVp | offsetof(struct gp, gp_egv)
#define GP_line_ix	line_tp | offsetof(struct gp, gp_line)
d1752 4
a1755 2
void
SV(gv)
a1756 37
    ALIAS:
	SV = GP_sv_ix
	IO = GP_io_ix
	CV = GP_cv_ix
	CVGEN = GP_cvgen_ix
	GvREFCNT = GP_refcnt_ix
	HV = GP_hv_ix
	AV = GP_av_ix
	FORM = GP_form_ix
	EGV = GP_egv_ix
	LINE = GP_line_ix
    PREINIT:
	GP *gp;
	char *ptr;
	SV *ret;
    PPCODE:
	gp = GvGP(gv);
	if (!gp) {
	    const GV *const gv = CvGV(cv);
	    Perl_croak(aTHX_ "NULL gp in B::GV::%s", gv ? GvNAME(gv) : "???");
	}
	ptr = (ix & 0xFFFF) + (char *)gp;
	switch ((U8)(ix >> 16)) {
	case (U8)(SVp >> 16):
	    ret = make_sv_object(aTHX_ *((SV **)ptr));
	    break;
	case (U8)(U32p >> 16):
	    ret = sv_2mortal(newSVuv(*((U32*)ptr)));
	    break;
	case (U8)(line_tp >> 16):
	    ret = sv_2mortal(newSVuv(*((line_t *)ptr)));
	    break;
	default:
	    croak("Illegal alias 0x%08x for B::*SV", (unsigned)ix);
	}
	ST(0) = ret;
	XSRETURN(1);
d1758 2
a1759 2
void
FILEGV(gv)
a1760 2
    PPCODE:
	PUSHs(make_sv_object(aTHX_ (SV *)GvFILEGV(gv)));
d1764 40
d1835 10
d1851 15
d1874 1
a1874 1
		XPUSHs(make_sv_object(aTHX_ svp[i]));
d1883 1
a1883 1
	    XPUSHs(make_sv_object(aTHX_ (AvARRAY(av)[idx])));
d1885 1
a1885 1
	    XPUSHs(make_sv_object(aTHX_ NULL));
a1888 6
#define AvOFF(av) ((XPVAV*)SvANY(av))->xof_off

IV
AvOFF(av)
	B::AV	av

d1897 6
d1909 5
a1913 1
void
d1916 36
a1951 5
    ALIAS:
	ROOT = 1
    PPCODE:
	PUSHs(make_op_object(aTHX_ CvISXSUB(cv) ? NULL
			     : ix ? CvROOT(cv) : CvSTART(cv)));
a1955 2
    ALIAS:
	XSUBANY = 1
d1957 2
a1958 6
	ST(0) = ix && CvCONST(cv)
	    ? make_sv_object(aTHX_ (SV *)CvXSUBANY(cv).any_ptr)
	    : sv_2mortal(newSViv(CvISXSUB(cv)
				 ? (ix ? CvXSUBANY(cv).any_iv
				       : PTR2IV(CvXSUB(cv)))
				 : 0));
d1961 1
a1961 1
const_sv(cv)
d1963 17
a1979 2
    PPCODE:
	PUSHs(make_sv_object(aTHX_ (SV *)cv_const_sv(cv)));
d1987 8
d1999 4
a2007 2
    PPCODE:
	PUSHs(make_op_object(aTHX_ HvPMROOT(hv)));
d2015 1
a2015 1
	if (HvUSEDKEYS(hv) > 0) {
d2020 1
a2020 1
	    EXTEND(sp, HvUSEDKEYS(hv) * 2);
d2023 1
a2023 1
		PUSHs(make_sv_object(aTHX_ sv));
d2029 1
a2029 1
void
a2031 4
    ALIAS:
	SVKEY_force = 1
    PPCODE:
	PUSHs(make_sv_object(aTHX_ ix ? HeSVKEY_force(he) : HeVAL(he)));
d2037 5
a2041 1
MODULE = B	PACKAGE = B::RHE
d2046 1
a2046 1
HASH(h)
d2049 1
a2049 1
	RETVAL = newRV( (SV*)cophh_2hv(h, 0) );
@


1.1.1.12
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d24 1
d26 1
d36 3
d42 1
d44 1
d49 3
d186 2
a187 1
#if  defined(USE_ITHREADS)
a254 32

static SV *
get_overlay_object(pTHX_ const OP *o, const char * const name, U32 namelen)
{
    HE *he;
    SV **svp;
    SV *key;
    SV *sv =get_sv("B::overlay", 0);
    if (!sv || !SvROK(sv))
	return NULL;
    sv = SvRV(sv);
    if (SvTYPE(sv) != SVt_PVHV)
	return NULL;
    key = newSViv(PTR2IV(o));
    he = hv_fetch_ent((HV*)sv, key, 0, 0);
    SvREFCNT_dec(key);
    if (!he)
	return NULL;
    sv = HeVAL(he);
    if (!sv || !SvROK(sv))
	return NULL;
    sv = SvRV(sv);
    if (SvTYPE(sv) != SVt_PVHV)
	return NULL;
    svp = hv_fetch((HV*)sv, name, namelen, 0);
    if (!svp)
	return NULL;
    sv = *svp;
    return sv;
}


d277 1
d342 1
d406 1
d408 3
d451 1
d453 3
d477 9
a485 2
#define PMOP_pmreplstart(o)	o->op_pmstashstartu.op_pmreplstart
#define PMOP_pmreplroot(o)	o->op_pmreplrootu.op_pmreplroot
d538 1
d542 5
d607 1
a608 2
#ifdef PadlistARRAY
typedef PADLIST	*B__PADLIST;
a637 86


#define SVp            0x00000
#define U32p           0x10000
#define line_tp        0x20000
#define OPp            0x30000
#define PADOFFSETp     0x40000
#define U8p            0x50000
#define IVp            0x60000
#define char_pp        0x70000

/* table that drives most of the B::*OP methods */

struct OP_methods {
    const char *name;
    STRLEN namelen;
    I32    type;
    size_t offset; /* if -1, access is handled on a case-by-case basis */
} op_methods[] = {
    STR_WITH_LEN("next"),    OPp,    offsetof(struct op, op_next),       /* 0*/
    STR_WITH_LEN("sibling"), OPp,    offsetof(struct op, op_sibling),    /* 1*/
    STR_WITH_LEN("targ"),    PADOFFSETp, offsetof(struct op, op_targ),   /* 2*/
    STR_WITH_LEN("flags"),   U8p,    offsetof(struct op, op_flags),      /* 3*/
    STR_WITH_LEN("private"), U8p,    offsetof(struct op, op_private),    /* 4*/
    STR_WITH_LEN("first"),   OPp,    offsetof(struct unop, op_first),     /* 5*/
    STR_WITH_LEN("last"),    OPp,    offsetof(struct binop, op_last),    /* 6*/
    STR_WITH_LEN("other"),   OPp,    offsetof(struct logop, op_other),   /* 7*/
    STR_WITH_LEN("pmreplstart"), 0, -1,                                  /* 8*/
    STR_WITH_LEN("redoop"),  OPp,    offsetof(struct loop, op_redoop),   /* 9*/
    STR_WITH_LEN("nextop"),  OPp,    offsetof(struct loop, op_nextop),   /*10*/
    STR_WITH_LEN("lastop"),  OPp,    offsetof(struct loop, op_lastop),   /*11*/
    STR_WITH_LEN("pmflags"), U32p,   offsetof(struct pmop, op_pmflags),  /*12*/
#if PERL_VERSION >= 17
    STR_WITH_LEN("code_list"),OPp,   offsetof(struct pmop, op_code_list),/*13*/
#else
    STR_WITH_LEN("code_list"),0,     -1,
#endif
    STR_WITH_LEN("sv"),      SVp,     offsetof(struct svop, op_sv),      /*14*/
    STR_WITH_LEN("gv"),      SVp,     offsetof(struct svop, op_sv),      /*15*/
    STR_WITH_LEN("padix"),   PADOFFSETp,offsetof(struct padop, op_padix),/*16*/
    STR_WITH_LEN("cop_seq"), U32p,    offsetof(struct cop, cop_seq),     /*17*/
    STR_WITH_LEN("line"),    line_tp, offsetof(struct cop, cop_line),    /*18*/
    STR_WITH_LEN("hints"),   U32p,    offsetof(struct cop, cop_hints),   /*19*/
#ifdef USE_ITHREADS
    STR_WITH_LEN("pmoffset"),IVp,     offsetof(struct pmop, op_pmoffset),/*20*/
    STR_WITH_LEN("filegv"),  0,       -1,                                /*21*/
    STR_WITH_LEN("file"),    char_pp, offsetof(struct cop, cop_file),    /*22*/
    STR_WITH_LEN("stash"),   0,       -1,                                /*23*/
#  if PERL_VERSION < 17
    STR_WITH_LEN("stashpv"), char_pp, offsetof(struct cop, cop_stashpv), /*24*/
    STR_WITH_LEN("stashoff"),0,       -1,                                /*25*/
#  else
    STR_WITH_LEN("stashpv"), 0,       -1,                                /*24*/
    STR_WITH_LEN("stashoff"),PADOFFSETp,offsetof(struct cop, cop_stashoff),/*25*/
#  endif
#else
    STR_WITH_LEN("pmoffset"),0,       -1,                                /*20*/
    STR_WITH_LEN("filegv"),  SVp,     offsetof(struct cop, cop_filegv),  /*21*/
    STR_WITH_LEN("file"),    0,       -1,                                /*22*/
    STR_WITH_LEN("stash"),   SVp,     offsetof(struct cop, cop_stash),   /*23*/
    STR_WITH_LEN("stashpv"), 0,       -1,                                /*24*/
    STR_WITH_LEN("stashoff"),0,       -1,                                /*25*/
#endif
    STR_WITH_LEN("size"),    0,       -1,                                /*26*/
    STR_WITH_LEN("name"),    0,       -1,                                /*27*/
    STR_WITH_LEN("desc"),    0,       -1,                                /*28*/
    STR_WITH_LEN("ppaddr"),  0,       -1,                                /*29*/
    STR_WITH_LEN("type"),    0,       -1,                                /*30*/
    STR_WITH_LEN("opt"),     0,       -1,                                /*31*/
    STR_WITH_LEN("spare"),   0,       -1,                                /*32*/
    STR_WITH_LEN("children"),0,       -1,                                /*33*/
    STR_WITH_LEN("pmreplroot"), 0,    -1,                                /*34*/
    STR_WITH_LEN("pmstashpv"), 0,     -1,                                /*35*/
    STR_WITH_LEN("pmstash"), 0,       -1,                                /*36*/
    STR_WITH_LEN("precomp"), 0,       -1,                                /*37*/
    STR_WITH_LEN("reflags"), 0,       -1,                                /*38*/
    STR_WITH_LEN("sv"),      0,       -1,                                /*39*/
    STR_WITH_LEN("gv"),      0,       -1,                                /*40*/
    STR_WITH_LEN("pv"),      0,       -1,                                /*41*/
    STR_WITH_LEN("label"),   0,       -1,                                /*42*/
    STR_WITH_LEN("arybase"), 0,       -1,                                /*43*/
    STR_WITH_LEN("warnings"),0,       -1,                                /*44*/
    STR_WITH_LEN("io"),      0,       -1,                                /*45*/
    STR_WITH_LEN("hints_hash"),0,     -1,                                /*46*/
};

d663 1
d666 1
a678 1
#ifdef PL_formfeed
a680 1
#endif
a690 9
#ifndef PL_formfeed

void
formfeed()
    PPCODE:
	PUSHs(make_sv_object(aTHX_ GvSV(gv_fetchpvs("\f", GV_ADD, SVt_PV))));

#endif

a699 2
    PREINIT:
	PADLIST *padlist = CvPADLIST(PL_main_cv ? PL_main_cv : PL_compcv);
d701 2
a702 10
#ifdef PadlistARRAY
	{
	    SV * const rv = sv_newmortal();
	    sv_setiv(newSVrv(rv, padlist ? "B::PADLIST" : "B::NULL"),
		     PTR2IV(padlist));
	    PUSHs(rv);
	}
#else
	PUSHs(make_sv_object(aTHX_ (SV *)padlist));
#endif
d827 44
d872 3
d876 1
d878 15
d896 7
d911 19
a929 47
	B::OP::next          =  0
	B::OP::sibling       =  1
	B::OP::targ          =  2
	B::OP::flags         =  3
	B::OP::private       =  4
	B::UNOP::first       =  5
	B::BINOP::last       =  6
	B::LOGOP::other      =  7
	B::PMOP::pmreplstart =  8
	B::LOOP::redoop      =  9
	B::LOOP::nextop      = 10
	B::LOOP::lastop      = 11
	B::PMOP::pmflags     = 12
	B::PMOP::code_list   = 13
	B::SVOP::sv          = 14
	B::SVOP::gv          = 15
	B::PADOP::padix      = 16
	B::COP::cop_seq      = 17
	B::COP::line         = 18
	B::COP::hints        = 19
	B::PMOP::pmoffset    = 20
	B::COP::filegv       = 21
	B::COP::file         = 22
	B::COP::stash        = 23
	B::COP::stashpv      = 24
	B::COP::stashoff     = 25
	B::OP::size          = 26
	B::OP::name          = 27
	B::OP::desc          = 28
	B::OP::ppaddr        = 29
	B::OP::type          = 30
	B::OP::opt           = 31
	B::OP::spare         = 32
	B::LISTOP::children  = 33
	B::PMOP::pmreplroot  = 34
	B::PMOP::pmstashpv   = 35
	B::PMOP::pmstash     = 36
	B::PMOP::precomp     = 37
	B::PMOP::reflags     = 38
	B::PADOP::sv         = 39
	B::PADOP::gv         = 40
	B::PVOP::pv          = 41
	B::COP::label        = 42
	B::COP::arybase      = 43
	B::COP::warnings     = 44
	B::COP::io           = 45
	B::COP::hints_hash   = 46
a932 3
	I32 type;
	I32 offset;
	STRLEN len;
d934 3
a936 189
	if (ix < 0 || ix > 46)
	    croak("Illegal alias %d for B::*OP::next", (int)ix);
	ret = get_overlay_object(aTHX_ o,
			    op_methods[ix].name, op_methods[ix].namelen);
	if (ret) {
	    ST(0) = ret;
	    XSRETURN(1);
	}

	/* handle non-direct field access */

	offset = op_methods[ix].offset;
	if (offset < 0) {
	    switch (ix) {
	    case 8: /* pmreplstart */
		ret = make_op_object(aTHX_
				cPMOPo->op_type == OP_SUBST
				    ?  cPMOPo->op_pmstashstartu.op_pmreplstart
				    : NULL
		      );
		break;
#ifdef USE_ITHREADS
	    case 21: /* filegv */
		ret = make_sv_object(aTHX_ (SV *)CopFILEGV((COP*)o));
		break;
#endif
#ifndef USE_ITHREADS
	    case 22: /* file */
		ret = sv_2mortal(newSVpv(CopFILE((COP*)o), 0));
		break;
#endif
#ifdef USE_ITHREADS
	    case 23: /* stash */
		ret = make_sv_object(aTHX_ (SV *)CopSTASH((COP*)o));
		break;
#endif
#if PERL_VERSION >= 17 || !defined USE_ITHREADS
	    case 24: /* stashpv */
#  if PERL_VERSION >= 17
		ret = sv_2mortal(CopSTASH((COP*)o)
				&& SvTYPE(CopSTASH((COP*)o)) == SVt_PVHV
		    ? newSVhek(HvNAME_HEK(CopSTASH((COP*)o)))
		    : &PL_sv_undef);
#  else
		ret = sv_2mortal(newSVpv(CopSTASHPV((COP*)o), 0));
#  endif
		break;
#endif
	    case 26: /* size */
		ret = sv_2mortal(newSVuv((UV)(opsizes[cc_opclass(aTHX_ o)])));
		break;
	    case 27: /* name */
	    case 28: /* desc */
		ret = sv_2mortal(newSVpv(
			    (char *)(ix == 28 ? OP_DESC(o) : OP_NAME(o)), 0));
		break;
	    case 29: /* ppaddr */
		{
		    int i;
		    ret = sv_2mortal(Perl_newSVpvf(aTHX_ "PL_ppaddr[OP_%s]",
						  PL_op_name[o->op_type]));
		    for (i=13; (STRLEN)i < SvCUR(ret); ++i)
			SvPVX(ret)[i] = toUPPER(SvPVX(ret)[i]);
		}
		break;
	    case 30: /* type  */
	    case 31: /* opt   */
	    case 32: /* spare */
	    /* These 3 are all bitfields, so we can't take their addresses */
		ret = sv_2mortal(newSVuv((UV)(
				      ix == 30 ? o->op_type
		                    : ix == 31 ? o->op_opt
		                    :            o->op_spare)));
		break;
	    case 33: /* children */
		{
		    OP *kid;
		    UV i = 0;
		    for (kid = ((LISTOP*)o)->op_first; kid; kid = kid->op_sibling)
			i++;
		    ret = sv_2mortal(newSVuv(i));
		}
		break;
	    case 34: /* pmreplroot */
		if (cPMOPo->op_type == OP_PUSHRE) {
#ifdef USE_ITHREADS
		    ret = sv_newmortal();
		    sv_setiv(ret, cPMOPo->op_pmreplrootu.op_pmtargetoff);
#else
		    GV *const target = cPMOPo->op_pmreplrootu.op_pmtargetgv;
		    ret = sv_newmortal();
		    sv_setiv(newSVrv(ret, target ?
				     svclassnames[SvTYPE((SV*)target)] : "B::SV"),
			     PTR2IV(target));
#endif
		}
		else {
		    OP *const root = cPMOPo->op_pmreplrootu.op_pmreplroot;
		    ret = make_op_object(aTHX_ root);
		}
		break;
#ifdef USE_ITHREADS
	    case 35: /* pmstashpv */
		ret = sv_2mortal(newSVpv(PmopSTASHPV(cPMOPo),0));
		break;
#else
	    case 36: /* pmstash */
		ret = make_sv_object(aTHX_ (SV *) PmopSTASH(cPMOPo));
		break;
#endif
	    case 37: /* precomp */
	    case 38: /* reflags */
		{
		    REGEXP *rx = PM_GETRE(cPMOPo);
		    ret = sv_newmortal();
		    if (rx) {
			if (ix==38) {
			    sv_setuv(ret, RX_EXTFLAGS(rx));
			}
			else {
			    sv_setpvn(ret, RX_PRECOMP(rx), RX_PRELEN(rx));
			}
		    }
		}
		break;
	    case 39: /* sv */
	    case 40: /* gv */
		/* It happens that the output typemaps for B::SV and B::GV
		 * are identical. The "smarts" are in make_sv_object(),
		 * which determines which class to use based on SvTYPE(),
		 * rather than anything baked in at compile time.  */
		if (cPADOPo->op_padix) {
		    ret = PAD_SVl(cPADOPo->op_padix);
		    if (ix == 40 && SvTYPE(ret) != SVt_PVGV)
			ret = NULL;
		} else {
		    ret = NULL;
		}
		ret = make_sv_object(aTHX_ ret);
		break;
	    case 41: /* pv */
		/* OP_TRANS uses op_pv to point to a table of 256 or >=258
		 * shorts whereas other PVOPs point to a null terminated
		 * string.  */
		if (    (cPVOPo->op_type == OP_TRANS
			|| cPVOPo->op_type == OP_TRANSR) &&
			(cPVOPo->op_private & OPpTRANS_COMPLEMENT) &&
			!(cPVOPo->op_private & OPpTRANS_DELETE))
		{
		    const short* const tbl = (short*)cPVOPo->op_pv;
		    const short entries = 257 + tbl[256];
		    ret = newSVpvn_flags(cPVOPo->op_pv, entries * sizeof(short), SVs_TEMP);
		}
		else if (cPVOPo->op_type == OP_TRANS || cPVOPo->op_type == OP_TRANSR) {
		    ret = newSVpvn_flags(cPVOPo->op_pv, 256 * sizeof(short), SVs_TEMP);
		}
		else
		    ret = newSVpvn_flags(cPVOPo->op_pv, strlen(cPVOPo->op_pv), SVs_TEMP);
		break;
	    case 42: /* label */
		ret = sv_2mortal(newSVpv(CopLABEL(cCOPo),0));
		break;
	    case 43: /* arybase */
		ret = sv_2mortal(newSVuv(0));
		break;
	    case 44: /* warnings */
		ret = make_warnings_object(aTHX_ cCOPo);
		break;
	    case 45: /* io */
		ret = make_cop_io_object(aTHX_ cCOPo);
		break;
	    case 46: /* hints_hash */
		ret = sv_newmortal();
		sv_setiv(newSVrv(ret, "B::RHE"),
			PTR2IV(CopHINTHASH_get(cCOPo)));
		break;
	    default:
		croak("method %s not implemented", op_methods[ix].name);
	    }
	    ST(0) = ret;
	    XSRETURN(1);
	}

	/* do a direct structure offset lookup */

	ptr  = (char *)o + offset;
	type = op_methods[ix].type;
	switch ((U8)(type >> 16)) {
	case  (U8)(OPp >> 16):
d939 1
a939 1
	case  (U8)(PADOFFSETp >> 16):
d954 1
d961 1
d963 1
a963 2
	    croak("Illegal type 0x%08x for B::*OP::%s",
		    (unsigned)type, op_methods[ix].name);
d969 64
d1040 270
d1361 1
d1370 10
d1386 2
a1387 1
#if PERL_VERSION > 14
d1390 1
a1390 1
#else
d1393 6
a1400 2
#define PVBM_rare_ix	sv_U8p | offsetof(struct xpvgv, xnv_u.xbm_s.xbm_rare)

d1406 1
d1410 5
d1430 2
d1433 1
a1433 5
#if PERL_VERSION > 17 || (PERL_VERSION == 17 && PERL_SUBVERSION >= 3)
# define PVCV_gv_ix	sv_SVp | offsetof(struct xpvcv, xcv_gv_u.xcv_gv)
#else
# define PVCV_gv_ix	sv_SVp | offsetof(struct xpvcv, xcv_gv)
#endif
d1435 2
d1488 1
d1490 1
d1492 2
a1665 5
#ifdef isREGEXP
	    p = isREGEXP(sv)
		 ? RX_WRAPPED_const((REGEXP*)sv)
		 : SvPVX_const(sv);
#else
a1666 1
#endif
a1672 3
#ifdef isREGEXP
	    p = isREGEXP(sv) ? RX_WRAPPED((REGEXP*)sv) : SvPVX(sv);
#else
a1673 1
#endif
d1679 10
a1689 7
#ifdef isREGEXP
	else if (isREGEXP(sv)) {
	    len = SvCUR(sv);
	    p = RX_WRAPPED_const((REGEXP*)sv);
	    utf8 = SvUTF8(sv);
	}
#endif
d1780 1
d1784 4
d1796 1
d1798 3
d1871 7
d1929 3
d1933 3
a1935 1
MODULE = B	PACKAGE = B::FM		PREFIX = Fm
d1937 1
a1937 2
#undef FmLINES
#define FmLINES(sv) 0
d1939 5
a1943 3
IV
FmLINES(form)
	B::FM	form
a1959 21
I32
CvDEPTH(cv)
        B::CV   cv

#ifdef PadlistARRAY

B::PADLIST
CvPADLIST(cv)
	B::CV	cv

#else

B::AV
CvPADLIST(cv)
	B::CV	cv
    PPCODE:
	PUSHs(make_sv_object(aTHX_ (SV *)CvPADLIST(cv)));


#endif

a1978 18
void
GV(cv)
	B::CV cv
    CODE:
	ST(0) = make_sv_object(aTHX_ (SV*)CvGV(cv));

#if PERL_VERSION > 17

SV *
NAME_HEK(cv)
	B::CV cv
    CODE:
	RETVAL = CvNAMED(cv) ? newSVhek(CvNAME_HEK(cv)) : &PL_sv_undef;
    OUTPUT:
	RETVAL

#endif

d1989 10
d2031 2
a2037 40
    OUTPUT:
	RETVAL


#ifdef PadlistARRAY

MODULE = B	PACKAGE = B::PADLIST	PREFIX = Padlist

SSize_t
PadlistMAX(padlist)
	B::PADLIST	padlist

void
PadlistARRAY(padlist)
	B::PADLIST	padlist
    PPCODE:
	if (PadlistMAX(padlist) >= 0) {
	    PAD **padp = PadlistARRAY(padlist);
	    PADOFFSET i;
	    for (i = 0; i <= PadlistMAX(padlist); i++)
		XPUSHs(make_sv_object(aTHX_ (SV *)padp[i]));
	}

void
PadlistARRAYelt(padlist, idx)
	B::PADLIST	padlist
	PADOFFSET	idx
    PPCODE:
	if (PadlistMAX(padlist) >= 0
	 && idx <= PadlistMAX(padlist))
	    XPUSHs(make_sv_object(aTHX_
				  (SV *)PadlistARRAY(padlist)[idx]));
	else
	    XPUSHs(make_sv_object(aTHX_ NULL));

U32
PadlistREFCNT(padlist)
	B::PADLIST	padlist
    CODE:
	RETVAL = PadlistREFCNT(padlist);
@


1.1.1.13
log
@Import perl-5.20.1
@
text
@a23 1
#if PERL_VERSION < 19
a24 1
#endif
a30 3
#if PERL_VERSION >= 19
    "B::INVLIST",
#endif
d639 8
a646 10
#define SVp                 0x0
#define U32p                0x1
#define line_tp             0x2
#define OPp                 0x3
#define PADOFFSETp          0x4
#define U8p                 0x5
#define IVp                 0x6
#define char_pp             0x7
/* Keep this last:  */
#define op_offset_special   0x8
d652 3
a654 3
    U8 namelen;
    U8    type; /* if op_offset_special, access is handled on a case-by-case basis */
    U16 offset;
d656 13
a668 13
  { STR_WITH_LEN("next"),    OPp,    offsetof(struct op, op_next),     },/* 0*/
  { STR_WITH_LEN("sibling"), OPp,    offsetof(struct op, op_sibling),  },/* 1*/
  { STR_WITH_LEN("targ"),    PADOFFSETp, offsetof(struct op, op_targ), },/* 2*/
  { STR_WITH_LEN("flags"),   U8p,    offsetof(struct op, op_flags),    },/* 3*/
  { STR_WITH_LEN("private"), U8p,    offsetof(struct op, op_private),  },/* 4*/
  { STR_WITH_LEN("first"),   OPp,    offsetof(struct unop, op_first),  },/* 5*/
  { STR_WITH_LEN("last"),    OPp,    offsetof(struct binop, op_last),  },/* 6*/
  { STR_WITH_LEN("other"),   OPp,    offsetof(struct logop, op_other), },/* 7*/
  { STR_WITH_LEN("pmreplstart"), op_offset_special, 0,                 },/* 8*/
  { STR_WITH_LEN("redoop"),  OPp,    offsetof(struct loop, op_redoop), },/* 9*/
  { STR_WITH_LEN("nextop"),  OPp,    offsetof(struct loop, op_nextop), },/*10*/
  { STR_WITH_LEN("lastop"),  OPp,    offsetof(struct loop, op_lastop), },/*11*/
  { STR_WITH_LEN("pmflags"), U32p,   offsetof(struct pmop, op_pmflags),},/*12*/
d670 1
a670 1
  { STR_WITH_LEN("code_list"),OPp,   offsetof(struct pmop, op_code_list),},/*13*/
d672 1
a672 1
  { STR_WITH_LEN("code_list"),op_offset_special, 0,
d674 6
a679 6
  { STR_WITH_LEN("sv"),      SVp,     offsetof(struct svop, op_sv),    },/*14*/
  { STR_WITH_LEN("gv"),      SVp,     offsetof(struct svop, op_sv),    },/*15*/
  { STR_WITH_LEN("padix"),   PADOFFSETp,offsetof(struct padop, op_padix),},/*16*/
  { STR_WITH_LEN("cop_seq"), U32p,    offsetof(struct cop, cop_seq),   },/*17*/
  { STR_WITH_LEN("line"),    line_tp, offsetof(struct cop, cop_line),  },/*18*/
  { STR_WITH_LEN("hints"),   U32p,    offsetof(struct cop, cop_hints), },/*19*/
d681 4
a684 4
  { STR_WITH_LEN("pmoffset"),IVp,     offsetof(struct pmop, op_pmoffset),},/*20*/
  { STR_WITH_LEN("filegv"),  op_offset_special, 0,                     },/*21*/
  { STR_WITH_LEN("file"),    char_pp, offsetof(struct cop, cop_file),  },/*22*/
  { STR_WITH_LEN("stash"),   op_offset_special, 0,                     },/*23*/
d686 2
a687 2
  { STR_WITH_LEN("stashpv"), char_pp, offsetof(struct cop, cop_stashpv),}, /*24*/
  { STR_WITH_LEN("stashoff"),op_offset_special, 0,                     },/*25*/
d689 2
a690 2
  { STR_WITH_LEN("stashpv"), op_offset_special, 0,                     },/*24*/
  { STR_WITH_LEN("stashoff"),PADOFFSETp,offsetof(struct cop,cop_stashoff),},/*25*/
d693 28
a720 36
  { STR_WITH_LEN("pmoffset"),op_offset_special, 0,                     },/*20*/
  { STR_WITH_LEN("filegv"),  SVp,     offsetof(struct cop, cop_filegv),},/*21*/
  { STR_WITH_LEN("file"),    op_offset_special, 0,                     },/*22*/
  { STR_WITH_LEN("stash"),   SVp,     offsetof(struct cop, cop_stash), },/*23*/
  { STR_WITH_LEN("stashpv"), op_offset_special, 0,                     },/*24*/
  { STR_WITH_LEN("stashoff"),op_offset_special, 0,                     },/*25*/
#endif
  { STR_WITH_LEN("size"),    op_offset_special, 0,                     },/*26*/
  { STR_WITH_LEN("name"),    op_offset_special, 0,                     },/*27*/
  { STR_WITH_LEN("desc"),    op_offset_special, 0,                     },/*28*/
  { STR_WITH_LEN("ppaddr"),  op_offset_special, 0,                     },/*29*/
  { STR_WITH_LEN("type"),    op_offset_special, 0,                     },/*30*/
  { STR_WITH_LEN("opt"),     op_offset_special, 0,                     },/*31*/
  { STR_WITH_LEN("spare"),   op_offset_special, 0,                     },/*32*/
  { STR_WITH_LEN("children"),op_offset_special, 0,                     },/*33*/
  { STR_WITH_LEN("pmreplroot"), op_offset_special, 0,                  },/*34*/
  { STR_WITH_LEN("pmstashpv"), op_offset_special, 0,                   },/*35*/
  { STR_WITH_LEN("pmstash"), op_offset_special, 0,                     },/*36*/
  { STR_WITH_LEN("precomp"), op_offset_special, 0,                     },/*37*/
  { STR_WITH_LEN("reflags"), op_offset_special, 0,                     },/*38*/
  { STR_WITH_LEN("sv"),      op_offset_special, 0,                     },/*39*/
  { STR_WITH_LEN("gv"),      op_offset_special, 0,                     },/*40*/
  { STR_WITH_LEN("pv"),      op_offset_special, 0,                     },/*41*/
  { STR_WITH_LEN("label"),   op_offset_special, 0,                     },/*42*/
  { STR_WITH_LEN("arybase"), op_offset_special, 0,                     },/*43*/
  { STR_WITH_LEN("warnings"),op_offset_special, 0,                     },/*44*/
  { STR_WITH_LEN("io"),      op_offset_special, 0,                     },/*45*/
  { STR_WITH_LEN("hints_hash"),op_offset_special, 0,                   },/*46*/
#if PERL_VERSION >= 17
  { STR_WITH_LEN("slabbed"), op_offset_special, 0,                     },/*47*/
  { STR_WITH_LEN("savefree"),op_offset_special, 0,                     },/*48*/
  { STR_WITH_LEN("static"),  op_offset_special, 0,                     },/*49*/
#  if PERL_VERSION >= 19
  { STR_WITH_LEN("folded"),  op_offset_special, 0,                     },/*50*/
#  endif
#endif
a991 4
	B::OP::slabbed       = 47
	B::OP::savefree      = 48
	B::OP::static        = 49
	B::OP::folded        = 50
d993 1
d995 3
d999 1
a999 1
	if (ix < 0 || (U32)ix >= C_ARRAY_LENGTH(op_methods))
d1010 2
a1011 1
	if (op_methods[ix].type == op_offset_special)
d1067 1
a1067 9
#if PERL_VERSION >= 17
	    case 47: /* slabbed  */
	    case 48: /* savefree */
	    case 49: /* static   */
#if PERL_VERSION >= 19
	    case 50: /* folded   */
#endif
#endif
	    /* These are all bitfields, so we can't take their addresses */
a1070 4
		                    : ix == 47 ? o->op_slabbed
		                    : ix == 48 ? o->op_savefree
		                    : ix == 49 ? o->op_static
		                    : ix == 50 ? o->op_folded
a1119 2
                            if (RX_UTF8(rx))
                                SvUTF8_on(ret);
a1176 31
	} else {
	    /* do a direct structure offset lookup */
	    const char *const ptr = (char *)o + op_methods[ix].offset;
	    switch (op_methods[ix].type) {
	    case OPp:
		ret = make_op_object(aTHX_ *((OP **)ptr));
		break;
	    case PADOFFSETp:
		ret = sv_2mortal(newSVuv(*((PADOFFSET*)ptr)));
		break;
	    case U8p:
		ret = sv_2mortal(newSVuv(*((U8*)ptr)));
		break;
	    case U32p:
		ret = sv_2mortal(newSVuv(*((U32*)ptr)));
		break;
	    case SVp:
		ret = make_sv_object(aTHX_ *((SV **)ptr));
		break;
	    case line_tp:
		ret = sv_2mortal(newSVuv(*((line_t *)ptr)));
		break;
	    case IVp:
		ret = sv_2mortal(newSViv(*((IV*)ptr)));
		break;
	    case char_pp:
		ret = sv_2mortal(newSVpv(*((char **)ptr), 0));
		break;
	    default:
		croak("Illegal type 0x%x for B::*OP::%s",
		      (unsigned)op_methods[ix].type, op_methods[ix].name);
d1178 37
d1291 1
a1291 3
#if PERL_VERSION > 18
#    define PVBM_useful_ix	sv_IVp | offsetof(struct xpviv, xiv_u.xivu_iv)
#elif PERL_VERSION > 14
d1293 1
d1296 1
d1299 2
d1333 1
a1333 1
#define PVCV_flags_ix	sv_U32p | offsetof(struct xpvcv, xcv_flags)
d1367 2
a1667 26
MODULE = B	PACKAGE = B::BM		PREFIX = Bm

U32
BmPREVIOUS(sv)
	B::BM	sv
    CODE:
#if PERL_VERSION >= 19
        PERL_UNUSED_VAR(sv);
#endif
	RETVAL = BmPREVIOUS(sv);
    OUTPUT:
        RETVAL


U8
BmRARE(sv)
	B::BM	sv
    CODE:
#if PERL_VERSION >= 19
        PERL_UNUSED_VAR(sv);
#endif
	RETVAL = BmRARE(sv);
    OUTPUT:
        RETVAL


d1699 10
a1708 10
#define GP_sv_ix	(SVp << 16) | offsetof(struct gp, gp_sv)
#define GP_io_ix	(SVp << 16) | offsetof(struct gp, gp_io)
#define GP_cv_ix	(SVp << 16) | offsetof(struct gp, gp_cv)
#define GP_cvgen_ix	(U32p << 16) | offsetof(struct gp, gp_cvgen)
#define GP_refcnt_ix	(U32p << 16) | offsetof(struct gp, gp_refcnt)
#define GP_hv_ix	(SVp << 16) | offsetof(struct gp, gp_hv)
#define GP_av_ix	(SVp << 16) | offsetof(struct gp, gp_av)
#define GP_form_ix	(SVp << 16) | offsetof(struct gp, gp_form)
#define GP_egv_ix	(SVp << 16) | offsetof(struct gp, gp_egv)
#define GP_line_ix	(line_tp << 16) | offsetof(struct gp, gp_line)
d1736 1
a1736 1
	case SVp:
d1739 1
a1739 1
	case U32p:
d1742 1
a1742 1
	case line_tp:
d1813 3
d1817 2
a1818 8
FmLINES(format)
	B::FM	format
    CODE:
        PERL_UNUSED_VAR(format);
       RETVAL = 0;
    OUTPUT:
        RETVAL

d1908 3
a1910 1
	    HE *he;
d1913 3
a1915 9
	    while ((he = hv_iternext(hv))) {
                if (HeSVKEY(he)) {
                    mPUSHs(HeSVKEY(he));
                } else if (HeKUTF8(he)) {
                    PUSHs(newSVpvn_flags(HeKEY(he), HeKLEN(he), SVf_UTF8|SVs_TEMP));
                } else {
                    mPUSHp(HeKEY(he), HeKLEN(he));
                }
		PUSHs(make_sv_object(aTHX_ HeVAL(he)));
d1958 1
a1958 1
            SSize_t i;
d1966 1
a1966 1
	SSize_t 	idx
a1978 1
        PERL_UNUSED_VAR(padlist);
@


