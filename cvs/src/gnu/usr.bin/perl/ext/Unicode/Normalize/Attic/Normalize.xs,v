head	1.2;
access;
symbols
	OPENBSD_4_6:1.1.1.6.0.6
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.2
	OPENBSD_4_5_BASE:1.1.1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.8
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.6
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.4
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2009.10.12.18.24.36;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.04.07.21.13.09;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.46.34;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.25;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.25;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Merge in perl 5.10.1
@
text
@
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* These 5 files are prepared by mkheader */
#include "unfcmb.h"
#include "unfcan.h"
#include "unfcpt.h"
#include "unfcmp.h"
#include "unfexc.h"

/* Perl 5.6.1 ? */
#ifndef uvuni_to_utf8
#define uvuni_to_utf8   uv_to_utf8
#endif /* uvuni_to_utf8 */ 

/* Perl 5.6.1 ? */
#ifndef utf8n_to_uvuni
#define utf8n_to_uvuni  utf8_to_uv
#endif /* utf8n_to_uvuni */ 

/* At present, char > 0x10ffff are unaffected without complaint, right? */
#define VALID_UTF_MAX    (0x10ffff)
#define OVER_UTF_MAX(uv) (VALID_UTF_MAX < (uv))

/* HANGUL_H */
#define Hangul_SBase  0xAC00
#define Hangul_SFinal 0xD7A3
#define Hangul_SCount  11172

#define Hangul_NCount    588

#define Hangul_LBase  0x1100
#define Hangul_LFinal 0x1112
#define Hangul_LCount     19

#define Hangul_VBase  0x1161
#define Hangul_VFinal 0x1175
#define Hangul_VCount     21

#define Hangul_TBase  0x11A7
#define Hangul_TFinal 0x11C2
#define Hangul_TCount     28

#define Hangul_IsS(u)  ((Hangul_SBase <= (u)) && ((u) <= Hangul_SFinal))
#define Hangul_IsN(u)  (((u) - Hangul_SBase) % Hangul_TCount == 0)
#define Hangul_IsLV(u) (Hangul_IsS(u) && Hangul_IsN(u))
#define Hangul_IsL(u)  ((Hangul_LBase <= (u)) && ((u) <= Hangul_LFinal))
#define Hangul_IsV(u)  ((Hangul_VBase <= (u)) && ((u) <= Hangul_VFinal))
#define Hangul_IsT(u)  ((Hangul_TBase  < (u)) && ((u) <= Hangul_TFinal))
/* HANGUL_H */

/* this is used for canonical ordering of combining characters (c.c.). */
typedef struct {
    U8 cc;	/* combining class */
    UV uv;	/* codepoint */
    STRLEN pos; /* position */
} UNF_cc;

int compare_cc(const void *a, const void *b)
{
    int ret_cc;
    ret_cc = (*(UNF_cc*)a).cc - (*(UNF_cc*)b).cc;
    if (ret_cc)
	return ret_cc;
    return (*(UNF_cc*)a).pos - (*(UNF_cc*)b).pos;
}

U8* dec_canonical (UV uv)
{
    U8 ***plane, **row;
    if (OVER_UTF_MAX(uv))
	return NULL;
    plane = (U8***)UNF_canon[uv >> 16];
    if (! plane)
	return NULL;
    row = plane[(uv >> 8) & 0xff];
    return row ? row[uv & 0xff] : NULL;
}

U8* dec_compat (UV uv)
{
    U8 ***plane, **row;
    if (OVER_UTF_MAX(uv))
	return NULL;
    plane = (U8***)UNF_compat[uv >> 16];
    if (! plane)
	return NULL;
    row = plane[(uv >> 8) & 0xff];
    return row ? row[uv & 0xff] : NULL;
}

UV composite_uv (UV uv, UV uv2)
{
    UNF_complist ***plane, **row, *cell, *i;

    if (! uv2 || OVER_UTF_MAX(uv) || OVER_UTF_MAX(uv2))
	return 0;

    if (Hangul_IsL(uv) && Hangul_IsV(uv2)) {
	uv  -= Hangul_LBase; /* lindex */
	uv2 -= Hangul_VBase; /* vindex */
	return(Hangul_SBase + (uv * Hangul_VCount + uv2) * Hangul_TCount);
    }
    if (Hangul_IsLV(uv) && Hangul_IsT(uv2)) {
	uv2 -= Hangul_TBase; /* tindex */
	return(uv + uv2);
    }
    plane = UNF_compos[uv >> 16];
    if (! plane)
	return 0;
    row = plane[(uv >> 8) & 0xff];
    if (! row)
	return 0;
    cell = row[uv & 0xff];
    if (! cell)
	return 0;
    for (i = cell; i->nextchar; i++) {
	if (uv2 == i->nextchar)
	    return i->composite;
    }
    return 0;
}

U8 getCombinClass (UV uv)
{
    U8 **plane, *row;
    if (OVER_UTF_MAX(uv))
	return 0;
    plane = (U8**)UNF_combin[uv >> 16];
    if (! plane)
	return 0;
    row = plane[(uv >> 8) & 0xff];
    return row ? row[uv & 0xff] : 0;
}

void sv_cat_decompHangul (SV* sv, UV uv)
{
    UV sindex, lindex, vindex, tindex;
    U8 *t, tmp[3 * UTF8_MAXLEN + 1];

    if (! Hangul_IsS(uv))
	return;

    sindex =  uv - Hangul_SBase;
    lindex =  sindex / Hangul_NCount;
    vindex = (sindex % Hangul_NCount) / Hangul_TCount;
    tindex =  sindex % Hangul_TCount;

    t = tmp;
    t = uvuni_to_utf8(t, (lindex + Hangul_LBase));
    t = uvuni_to_utf8(t, (vindex + Hangul_VBase));
    if (tindex)
	t = uvuni_to_utf8(t, (tindex + Hangul_TBase));
    *t = '\0';
    sv_catpvn(sv, (char *)tmp, strlen((char *)tmp));
}

MODULE = Unicode::Normalize	PACKAGE = Unicode::Normalize

SV*
decompose(arg, compat = &PL_sv_no)
    SV * arg
    SV * compat
  PROTOTYPE: $;$
  PREINIT:
    UV uv;
    SV *src, *dst;
    STRLEN srclen, retlen;
    U8 *s, *e, *p, *r;
    bool iscompat;
  CODE:
    if (SvUTF8(arg)) {
	src = arg;
    } else {
	src = sv_mortalcopy(arg);
	sv_utf8_upgrade(src);
    }
    iscompat = SvTRUE(compat);

    dst = newSV(1);
    (void)SvPOK_only(dst);
    SvUTF8_on(dst);

    s = (U8*)SvPV(src,srclen);
    e = s + srclen;
    for (p = s; p < e;) {
	uv = utf8n_to_uvuni(p, e - p, &retlen, 0);
	p += retlen;
	if (Hangul_IsS(uv))
	    sv_cat_decompHangul(dst, uv);
	else {
	    r = iscompat ? dec_compat(uv) : dec_canonical(uv);
	    if (r)
		sv_catpv(dst, (char *)r);
	    else
		sv_catpvn(dst, (char *)p - retlen, retlen);
	}
    }
    RETVAL = dst;
  OUTPUT:
    RETVAL



SV*
reorder(arg)
    SV * arg
  PROTOTYPE: $
  PREINIT:
    SV *src, *dst;
    STRLEN srclen, dstlen, retlen, stk_cc_max;
    U8 *s, *e, *p, *d, curCC;
    UV uv;
    UNF_cc * stk_cc;
  CODE:
    if (SvUTF8(arg)) {
	src = arg;
    } else {
	src = sv_mortalcopy(arg);
	sv_utf8_upgrade(src);
    }

    s = (U8*)SvPV(src, srclen);

    dstlen = srclen + 1;
    dst = newSV(dstlen);
    sv_setpvn(dst,(const char*)s,srclen);
    SvUTF8_on(dst);

    stk_cc_max = 10; /* enough as an initial value? */
    New(0, stk_cc, stk_cc_max, UNF_cc);

    d = (U8*)SvPV(dst,dstlen);
    e = d + dstlen;

    for (p = d; p < e;) {
	U8 *cc_in;
	STRLEN cc_len, cc_iter, cc_pos;

	uv = utf8n_to_uvuni(p, e - p, &retlen, 0);
	curCC = getCombinClass(uv);
	p += retlen;

	if (! (curCC && p < e))
	    continue;
	else
	    cc_in = p - retlen;

	cc_pos = 0;
	stk_cc[cc_pos].cc  = curCC;
	stk_cc[cc_pos].uv  = uv;
	stk_cc[cc_pos].pos = cc_pos;

	while (p < e) {
	    uv = utf8n_to_uvuni(p, e - p, &retlen, 0);
	    curCC = getCombinClass(uv);
	    if (!curCC)
		break;
	    p += retlen;
	    cc_pos++;
	    if (stk_cc_max <= cc_pos) { /* extend if need */
		stk_cc_max = cc_pos + 1;
		Renew(stk_cc, stk_cc_max, UNF_cc);
	    }
	    stk_cc[cc_pos].cc  = curCC;
	    stk_cc[cc_pos].uv  = uv;
	    stk_cc[cc_pos].pos = cc_pos;
	}

	 /* only one c.c. in cc_len from cc_in, no need of reordering */
	if (!cc_pos)
	    continue;

	qsort((void*)stk_cc, cc_pos + 1, sizeof(UNF_cc), compare_cc);

	cc_len = p - cc_in;
	p = cc_in;
	for (cc_iter = 0; cc_iter <= cc_pos; cc_iter++) {
	    p = uvuni_to_utf8(p, stk_cc[cc_iter].uv);
	}
    }
    Safefree(stk_cc);
    RETVAL = dst;
  OUTPUT:
    RETVAL



SV*
compose(arg)
    SV * arg
  PROTOTYPE: $
  PREINIT:
    SV  *src, *dst, *tmp;
    U8  *s, *p, *e, *d, *t, *tmp_start, curCC, preCC;
    UV uv, uvS, uvComp;
    STRLEN srclen, dstlen, tmplen, retlen;
    bool beginning = TRUE;
  CODE:
    if (SvUTF8(arg)) {
	src = arg;
    } else {
	src = sv_mortalcopy(arg);
	sv_utf8_upgrade(src);
    }

    s = (U8*)SvPV(src, srclen);
    e = s + srclen;
    dstlen = srclen + 1;
    dst = newSV(dstlen);
    (void)SvPOK_only(dst);
    SvUTF8_on(dst);
    d = (U8*)SvPVX(dst);

  /* for uncomposed combining char */
    tmp = sv_2mortal(newSV(dstlen));
    (void)SvPOK_only(tmp);
    SvUTF8_on(tmp);

    for (p = s; p < e;) {
	if (beginning) {
	    uvS = utf8n_to_uvuni(p, e - p, &retlen, 0);
	    p += retlen;

            if (getCombinClass(uvS)) { /* no Starter found yet */
		d = uvuni_to_utf8(d, uvS);
		continue;
	    }
            beginning = FALSE;
	}

    /* Starter */
	t = tmp_start = (U8*)SvPVX(tmp);
	preCC = 0;

    /* to the next Starter */
	while (p < e) {
	    uv = utf8n_to_uvuni(p, e - p, &retlen, 0);
	    p += retlen;
	    curCC = getCombinClass(uv);

	    if (preCC && preCC == curCC) {
		preCC = curCC;
		t = uvuni_to_utf8(t, uv);
	    } else {
		uvComp = composite_uv(uvS, uv);

		if (uvComp && ! isExclusion(uvComp) && preCC <= curCC) {
		    STRLEN leftcur, rightcur, dstcur;
		    leftcur  = UNISKIP(uvComp);
		    rightcur = UNISKIP(uvS) + UNISKIP(uv);

		    if (leftcur > rightcur) {
			dstcur = d - (U8*)SvPVX(dst);
			dstlen += leftcur - rightcur;
			d = (U8*)SvGROW(dst,dstlen) + dstcur;
		    }
		    /* preCC not changed to curCC */
		    uvS = uvComp;
	        } else if (! curCC && p < e) { /* blocked */
		    break;
		} else {
		    preCC = curCC;
		    t = uvuni_to_utf8(t, uv);
		}
	    }
	}
	d = uvuni_to_utf8(d, uvS); /* starter (composed or not) */
	tmplen = t - tmp_start;
	if (tmplen) { /* uncomposed combining char */
	    t = (U8*)SvPVX(tmp);
	    while (tmplen--)
		*d++ = *t++;
	}
	uvS = uv;
    } /* for */
    SvCUR_set(dst, d - (U8*)SvPVX(dst));
    RETVAL = dst;
  OUTPUT:
    RETVAL



void
checkNFD(arg)
    SV * arg
  PROTOTYPE: $
  ALIAS:
    checkNFKD = 1
  PREINIT:
    UV uv;
    SV *src;
    STRLEN srclen, retlen;
    U8 *s, *e, *p, curCC, preCC;
  PPCODE:
    if (SvUTF8(arg)) {
	src = arg;
    } else {
	src = sv_mortalcopy(arg);
	sv_utf8_upgrade(src);
    }
    
    s = (U8*)SvPV(src,srclen);
    e = s + srclen;

    preCC = 0;
    for (p = s; p < e; p += retlen) {
	uv = utf8n_to_uvuni(p, e - p, &retlen, 0);
	curCC = getCombinClass(uv);
	if (preCC > curCC && curCC != 0) /* canonical ordering violated */
	    XSRETURN_NO;
	if (Hangul_IsS(uv) || (ix ? dec_compat(uv) : dec_canonical(uv)))
	    XSRETURN_NO;
	preCC = curCC;
    }
    XSRETURN_YES;



void
checkNFC(arg)
    SV * arg
  PROTOTYPE: $
  ALIAS:
    checkNFKC = 1
  PREINIT:
    UV uv;
    SV *src;
    STRLEN srclen, retlen;
    U8 *s, *e, *p, curCC, preCC;
    bool isMAYBE;
  PPCODE:
    if (SvUTF8(arg)) {
	src = arg;
    } else {
	src = sv_mortalcopy(arg);
	sv_utf8_upgrade(src);
    }
    
    s = (U8*)SvPV(src,srclen);
    e = s + srclen;

    preCC = 0;
    isMAYBE = FALSE;
    for (p = s; p < e; p += retlen) {
	uv = utf8n_to_uvuni(p, e - p, &retlen, 0);
	curCC = getCombinClass(uv);

	if (preCC > curCC && curCC != 0) /* canonical ordering violated */
	    XSRETURN_NO;

	/* get NFC/NFKC property */
	if (Hangul_IsS(uv)) /* Hangul syllables are canonical composites */
	    ; /* YES */
	else if (isExclusion(uv) || isSingleton(uv) || isNonStDecomp(uv))
	    XSRETURN_NO;
	else if (isComp2nd(uv))
	    isMAYBE = TRUE;
	else if (ix) {
	    char *canon, *compat;
	 /*
	  * NFKC_NO when having compatibility mapping;
	  * i.e. dec_compat(uv) defined & different with dec_canonical(uv).
	  */
	    canon  = (char *) dec_canonical(uv);
	    compat = (char *) dec_compat(uv);
	    if (compat && (!canon || strNE(canon, compat)))
		XSRETURN_NO;
	} /* end of get NFC/NFKC property */

	preCC = curCC;
    }
    if (isMAYBE)
	XSRETURN_UNDEF;
    else
	XSRETURN_YES;



U8
getCombinClass(uv)
    UV uv
  PROTOTYPE: $

bool
isExclusion(uv)
    UV uv
  PROTOTYPE: $

bool
isSingleton(uv)
    UV uv
  PROTOTYPE: $

bool
isNonStDecomp(uv)
    UV uv
  PROTOTYPE: $

bool
isComp2nd(uv)
    UV uv
  PROTOTYPE: $
  ALIAS:
    isNFC_MAYBE  = 1
    isNFKC_MAYBE = 2



void
isNFD_NO(uv)
    UV uv
  PROTOTYPE: $
  ALIAS:
    isNFKD_NO = 1
  PPCODE:
    if (Hangul_IsS(uv) || (ix ? dec_compat(uv) : dec_canonical(uv)))
	XSRETURN_YES; /* NFD_NO or NFKD_NO */
    else
	XSRETURN_NO;



void
isComp_Ex(uv)
    UV uv
  PROTOTYPE: $
  ALIAS:
    isNFC_NO  = 0
    isNFKC_NO = 1
  PPCODE:
    if (isExclusion(uv) || isSingleton(uv) || isNonStDecomp(uv))
	XSRETURN_YES; /* NFC_NO or NFKC_NO */
    else if (ix) {
	char *canon, *compat;
	canon  = (char *) dec_canonical(uv);
	compat = (char *) dec_compat(uv);
	if (compat && (!canon || strNE(canon, compat)))
	    XSRETURN_YES; /* NFC_NO or NFKC_NO */
	else
	    XSRETURN_NO;
    }
    else
	XSRETURN_NO;



SV*
getComposite(uv, uv2)
    UV uv
    UV uv2
  PROTOTYPE: $$
  PREINIT:
    UV composite;
  CODE:
    composite = composite_uv(uv, uv2);
    RETVAL = composite ? newSVuv(composite) : &PL_sv_undef;
  OUTPUT:
    RETVAL



SV*
getCanon(uv)
    UV uv
  PROTOTYPE: $
  ALIAS:
    getCompat = 1
  PREINIT:
    U8 * rstr;
  CODE:
    if (Hangul_IsS(uv)) {
	SV * dst;
	dst = newSV(1);
	(void)SvPOK_only(dst);
	sv_cat_decompHangul(dst, uv);
	RETVAL = dst;
    } else {
	rstr = ix ? dec_compat(uv) : dec_canonical(uv);
	if (!rstr)
	    XSRETURN_UNDEF;
	RETVAL = newSVpvn((char *)rstr, strlen((char *)rstr));
    }
    SvUTF8_on(RETVAL);
  OUTPUT:
    RETVAL

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d16 1
a16 1
#endif /* uvuni_to_utf8 */
d21 1
a21 7
#endif /* utf8n_to_uvuni */

/* if utf8n_to_uvuni() sets retlen to 0 when flags = 0 */
#define ErrRetlenIsZero "panic (Unicode::Normalize): zero-length character"

/* utf8_hop() hops back before start. Maybe broken UTF-8 */
#define ErrHopBeforeStart "panic (Unicode::Normalize): hopping before start"
d61 1
a61 1
int compare_cc (const void *a, const void *b)
d64 1
a64 1
    ret_cc = ((UNF_cc*) a)->cc - ((UNF_cc*) b)->cc;
d67 1
a67 3

    return ( ((UNF_cc*) a)->pos > ((UNF_cc*) b)->pos )
	 - ( ((UNF_cc*) a)->pos < ((UNF_cc*) b)->pos );
d188 1
a188 1
    for (p = s; p < e; p += retlen) {
d190 1
a190 3
	if (!retlen)
	    croak(ErrRetlenIsZero);

d198 1
a198 1
		sv_catpvn(dst, (char *)p, retlen);
d243 1
a243 2
	if (!retlen)
	    croak(ErrRetlenIsZero);
a245 3
	

	curCC = getCombinClass(uv);
a257 4
	    if (!retlen)
		croak(ErrRetlenIsZero);
	    p += retlen;

d261 1
a261 1

a294 2
  ALIAS:
    composeContiguous = 1
a324 2
	    if (!retlen)
		croak(ErrRetlenIsZero);
a340 2
	    if (!retlen)
		croak(ErrRetlenIsZero);
a341 1

d350 1
a350 2
		if (uvComp && ! isExclusion(uvComp) &&
			(ix ? (t == tmp_start) : (preCC <= curCC))) {
d362 1
a362 1
		} else if (! curCC && p < e) { /* blocked */
a378 1
    *d = '\0';
d385 1
d397 1
a397 1
  CODE:
a410 3
	if (!retlen)
	    croak(ErrRetlenIsZero);

d434 1
a434 1
  CODE:
a448 3
	if (!retlen)
	    croak(ErrRetlenIsZero);

d463 4
a466 1
	  /* NFKC_NO when having compatibility mapping. */
d469 1
a469 1
	    if (compat && !(canon && strEQ(canon, compat)))
a481 72
void
checkFCD(arg)
    SV * arg
  PROTOTYPE: $
  ALIAS:
    checkFCC = 1
  PREINIT:
    UV uv, uvLead, uvTrail;
    SV *src;
    STRLEN srclen, retlen, canlen, canret;
    U8 *s, *e, *p, curCC, preCC;
    U8 *sCan, *pCan, *eCan;
    bool isMAYBE;
  CODE:
    if (SvUTF8(arg)) {
	src = arg;
    } else {
	src = sv_mortalcopy(arg);
	sv_utf8_upgrade(src);
    }
    
    s = (U8*)SvPV(src,srclen);
    e = s + srclen;

    preCC = 0;
    isMAYBE = FALSE;
    for (p = s; p < e; p += retlen) {
	uv = utf8n_to_uvuni(p, e - p, &retlen, 0);
	if (!retlen)
	    croak(ErrRetlenIsZero);

	sCan = (U8*) dec_canonical(uv);

	if (sCan) {
	    canlen = (STRLEN)strlen((char *) sCan);
	    uvLead = utf8n_to_uvuni(sCan, canlen, &canret, 0);
	}
	else {
	    uvLead = uv;
	}

	curCC = getCombinClass(uvLead);

	if (curCC != 0 && curCC < preCC) /* canonical ordering violated */
	    XSRETURN_NO;

	if (ix) {
	    if (isExclusion(uv) || isSingleton(uv) || isNonStDecomp(uv))
		XSRETURN_NO;
	    else if (isComp2nd(uv))
		isMAYBE = TRUE;
	}

	if (sCan) {
	    eCan = sCan + canlen;
	    pCan = utf8_hop(eCan, -1);
	    if (pCan < sCan)
		croak(ErrHopBeforeStart);
	    uvTrail = utf8n_to_uvuni(pCan, eCan - pCan, &canret, 0);
	    preCC = getCombinClass(uvTrail);
	}
	else {
	    preCC = curCC;
	}
    }
    if (isMAYBE)
	XSRETURN_UNDEF;
    else
	XSRETURN_YES;



d518 1
a518 1
  CODE:
d533 1
a533 1
  CODE:
a588 37


void
splitOnLastStarter(arg)
    SV * arg
  PREINIT:
    UV uv;
    SV *src, *svp;
    STRLEN srclen, retlen;
    U8 *s, *e, *p;
  PPCODE:
    if (SvUTF8(arg)) {
	src = arg;
    } else {
	src = sv_mortalcopy(arg);
	sv_utf8_upgrade(src);
    }

    s = (U8*)SvPV(src,srclen);
    e = s + srclen;

    for (p = e; s < p; ) {
	p = utf8_hop(p, -1);
	if (p < s)
	    croak(ErrHopBeforeStart);
	uv = utf8n_to_uvuni(p, e - p, &retlen, 0);
	if (getCombinClass(uv) == 0) /* Last Starter found */
	    break;
    }

    svp = sv_2mortal(newSVpvn((char*)s, p - s));
    SvUTF8_on(svp);
    XPUSHs(svp);

    svp = sv_2mortal(newSVpvn((char*)p, e - p));
    SvUTF8_on(svp);
    XPUSHs(svp);
@


1.1.1.3
log
@perl 5.8.3 from CPAN
@
text
@d23 1
a23 8
/* UTF8_ALLOW_BOM is used before Perl 5.8.0 */
#ifdef UTF8_ALLOW_BOM
#define AllowAnyUTF (UTF8_ALLOW_SURROGATE|UTF8_ALLOW_BOM|UTF8_ALLOW_FFFF)
#else 
#define AllowAnyUTF (UTF8_ALLOW_SURROGATE|UTF8_ALLOW_FFFF)
#endif

/* if utf8n_to_uvuni() sets retlen to 0 (?) */
d67 1
a67 1
static int compare_cc (const void *a, const void *b)
d78 1
a78 1
static U8* dec_canonical (UV uv)
d90 1
a90 1
static U8* dec_compat (UV uv)
d102 1
a102 1
static UV composite_uv (UV uv, UV uv2)
d134 1
a134 1
static U8 getCombinClass (UV uv)
d146 1
a146 1
static void sv_cat_decompHangul (SV* sv, UV uv)
d165 1
a165 11
    sv_catpvn(sv, (char *)tmp, t - tmp);
}

static void sv_cat_uvuni (SV* sv, UV uv)
{
    U8 *t, tmp[UTF8_MAXLEN + 1];

    t = tmp;
    t = uvuni_to_utf8(t, uv);
    *t = '\0';
    sv_catpvn(sv, (char *)tmp, t - tmp);
d197 1
a197 1
	uv = utf8n_to_uvuni(p, e - p, &retlen, AllowAnyUTF);
d208 1
a208 1
		sv_cat_uvuni(dst, uv);
d225 1
a225 1
    UV uv, uvlast;
a226 2
    STRLEN i, cc_pos;
    bool valid_uvlast;
d236 1
a236 1
    e = s + srclen;
d239 1
a239 1
    (void)SvPOK_only(dst);
a240 1
    d = (U8*)SvPVX(dst);
d245 8
a252 2
    for (p = s; p < e;) {
	uv = utf8n_to_uvuni(p, e - p, &retlen, AllowAnyUTF);
d257 2
d260 1
a260 2
	if (curCC == 0) {
	    d = uvuni_to_utf8(d, uv);
d262 2
a263 1
	}
a269 1
	valid_uvlast = FALSE;
d271 1
a271 1
	    uv = utf8n_to_uvuni(p, e - p, &retlen, AllowAnyUTF);
d277 1
a277 3
	    if (curCC == 0) {
		uvlast = uv;
		valid_uvlast = TRUE;
a278 1
	    }
d290 5
a294 4
	/* reordered if there are two c.c.'s */
	if (cc_pos) {
	    qsort((void*)stk_cc, cc_pos + 1, sizeof(UNF_cc), compare_cc);
	}
d296 4
a299 6
	for (i = 0; i <= cc_pos; i++) {
	    d = uvuni_to_utf8(d, stk_cc[i].uv);
	}
	if (valid_uvlast)
	{
	    d = uvuni_to_utf8(d, uvlast);
a301 2
    *d = '\0';
    SvCUR_set(dst, d - (U8*)SvPVX(dst));
d344 1
a344 1
	    uvS = utf8n_to_uvuni(p, e - p, &retlen, AllowAnyUTF);
d362 1
a362 1
	    uv = utf8n_to_uvuni(p, e - p, &retlen, AllowAnyUTF);
d436 1
a436 1
	uv = utf8n_to_uvuni(p, e - p, &retlen, AllowAnyUTF);
d477 1
a477 1
	uv = utf8n_to_uvuni(p, e - p, &retlen, AllowAnyUTF);
d538 1
a538 1
	uv = utf8n_to_uvuni(p, e - p, &retlen, AllowAnyUTF);
d546 1
a546 1
	    uvLead = utf8n_to_uvuni(sCan, canlen, &canret, AllowAnyUTF);
d569 1
a569 1
	    uvTrail = utf8n_to_uvuni(pCan, eCan - pCan, &canret, AllowAnyUTF);
d715 1
a715 1
	uv = utf8n_to_uvuni(p, e - p, &retlen, AllowAnyUTF);
@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@a184 16
static char * sv_2pvunicode(SV *sv, STRLEN *lp)
{
    char *s;
    STRLEN len;
    s = (char*)SvPV(sv,len);
    if (!SvUTF8(sv)) {
	SV* tmpsv = sv_mortalcopy(sv);
	if (!SvPOK(tmpsv))
	    (void)sv_pvn_force(tmpsv,&len);
	sv_utf8_upgrade(tmpsv);
	s = (char*)SvPV(tmpsv,len);
    }
    *lp = len;
    return s;
}

d188 2
a189 2
decompose(src, compat = &PL_sv_no)
    SV * src
d193 2
a194 1
    SV *dst;
a196 1
    UV uv;
d199 6
a205 2
    s = (U8*)sv_2pvunicode(src,&srclen);
    e = s + srclen;
d211 2
d235 2
a236 2
reorder(src)
    SV * src
d239 1
a239 1
    SV *dst;
d247 8
a254 1
    s = (U8*)sv_2pvunicode(src,&srclen);
a255 1

d329 2
a330 2
compose(src)
    SV * src
d335 1
a335 1
    SV  *dst, *tmp;
d341 8
a348 1
    s = (U8*)sv_2pvunicode(src,&srclen);
a349 1

d432 2
a433 2
checkNFD(src)
    SV * src
d438 2
a441 1
    UV uv;
d443 8
a450 1
    s = (U8*)sv_2pvunicode(src,&srclen);
d471 2
a472 2
checkNFC(src)
    SV * src
d477 2
a480 1
    UV uv;
d483 8
a490 1
    s = (U8*)sv_2pvunicode(src,&srclen);
d531 2
a532 2
checkFCD(src)
    SV * src
d537 2
a540 1
    UV uv, uvLead, uvTrail;
d544 8
a551 1
    s = (U8*)sv_2pvunicode(src,&srclen);
d712 2
a713 2
splitOnLastStarter(src)
    SV * src
d715 2
a716 1
    SV *svp;
a718 1
    UV uv;
d720 8
a727 1
    s = (U8*)sv_2pvunicode(src,&srclen);
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d26 1
a26 1
#else
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d31 1
a31 1
#define ErrRetlenIsZero "panic (Unicode::Normalize %s): zero-length character"
a35 8
/* It should never happen as there is no instance in UTF-8 and UTF-EBCDIC;
   according to Versioning and Stability in UAX#15, no new composition
   should come in future. */
#define ErrLongerThanSrc "panic (Unicode::Normalize %s): longer than source"

/* uvuni_to_utf8 wants UTF8_MAXBYTES free bytes available */
#define ErrTargetNotEnough "panic (Unicode::Normalize %s): target not enough"

d40 1
a40 6
/* size of array for combining characters */
/* enough as an initial value? */
#define CC_SEQ_SIZE (10)
#define CC_SEQ_STEP  (5)

/* HANGUL begin */
d65 1
a65 1
/* HANGUL end */
d74 1
a74 1
static int compare_cc(const void *a, const void *b)
d85 1
a85 1
static U8* dec_canonical(UV uv)
d97 1
a97 1
static U8* dec_compat(UV uv)
d109 1
a109 1
static UV composite_uv(UV uv, UV uv2)
d113 1
a113 1
    if (!uv2 || OVER_UTF_MAX(uv) || OVER_UTF_MAX(uv2))
d117 3
a119 4
	UV lindex = uv  - Hangul_LBase;
	UV vindex = uv2 - Hangul_VBase;
	return(Hangul_SBase + (lindex * Hangul_VCount + vindex) *
	       Hangul_TCount);
d122 2
a123 2
	UV tindex = uv2 - Hangul_TBase;
	return(uv + tindex);
d141 1
a141 1
static U8 getCombinClass(UV uv)
d153 1
a153 1
static U8* pv_cat_decompHangul(U8* d, UV uv)
d155 2
a156 4
    UV sindex =  uv - Hangul_SBase;
    UV lindex =  sindex / Hangul_NCount;
    UV vindex = (sindex % Hangul_NCount) / Hangul_TCount;
    UV tindex =  sindex % Hangul_TCount;
d159 1
a159 1
	return d;
d161 8
a168 2
    d = uvuni_to_utf8(d, (lindex + Hangul_LBase));
    d = uvuni_to_utf8(d, (vindex + Hangul_VBase));
d170 13
a182 2
	d = uvuni_to_utf8(d, (tindex + Hangul_TBase));
    return d;
d185 1
a185 1
static char* sv_2pvunicode(SV *sv, STRLEN *lp)
d189 1
a189 1
    s = SvPV(sv,len);
d191 1
a191 1
	SV* tmpsv = sv_2mortal(newSVpvn(s, len));
d193 1
a193 1
	    s = SvPV_force(tmpsv,len);
d195 1
a195 1
	s = SvPV(tmpsv,len);
d197 1
a197 2
    if (lp)
	*lp = len;
d201 1
a201 14
static
U8* pv_utf8_decompose(U8* s, STRLEN slen, U8** dp, STRLEN dlen, bool iscompat)
{
    U8* p = s;
    U8* e = s + slen;
    U8* dstart = *dp;
    U8* d = dstart;

    while (p < e) {
	STRLEN retlen;
	UV uv = utf8n_to_uvuni(p, e - p, &retlen, AllowAnyUTF);
	if (!retlen)
	    croak(ErrRetlenIsZero, "decompose");
	p += retlen;
d203 15
a217 2
	if (Hangul_IsS(uv)) {
	    STRLEN cur = d - dstart;
d219 3
a221 9
	    if (dlen < cur + UTF8_MAXLEN * 3) {
		dlen += UTF8_MAXLEN * 3;
		Renew(dstart, dlen+1, U8);
		d = dstart + cur;
	    }
	    d = pv_cat_decompHangul(d, uv);
	}
	else {
	    U8* r = iscompat ? dec_compat(uv) : dec_canonical(uv);
d223 4
a226 13
	    if (r) {
		STRLEN len = (STRLEN)strlen((char *)r);
		STRLEN cur = d - dstart;
		if (dlen < cur + len) {
		    dlen += len;
		    Renew(dstart, dlen+1, U8);
		    d = dstart + cur;
		}
		while (len--)
		    *d++ = *r++;
	    }
	    else {
		STRLEN cur = d - dstart;
d228 8
a235 7
		if (dlen < cur + UTF8_MAXLEN) {
		    dlen += UTF8_MAXLEN;
		    Renew(dstart, dlen+1, U8);
		    d = dstart + cur;
		}
		d = uvuni_to_utf8(d, uv);
	    }
d238 3
a240 3
    *dp = dstart;
    return d;
}
a241 24
static
U8* pv_utf8_reorder(U8* s, STRLEN slen, U8* d, STRLEN dlen)
{
    U8* p = s;
    U8* e = s + slen;
    U8* dend = d + dlen;

    UNF_cc  seq_ary[CC_SEQ_SIZE];
    UNF_cc* seq_ptr = seq_ary; /* use array at the beginning */
    UNF_cc* seq_ext = NULL; /* extend if need */
    STRLEN seq_max = CC_SEQ_SIZE;
    STRLEN cc_pos = 0;

    if (dlen < slen || dlen < slen + UTF8_MAXLEN)
	croak(ErrTargetNotEnough, "reorder");
    dend -= UTF8_MAXLEN; /* safety */

    while (p < e) {
	U8 curCC;
	STRLEN retlen;
	UV uv = utf8n_to_uvuni(p, e - p, &retlen, AllowAnyUTF);
	if (!retlen)
	    croak(ErrRetlenIsZero, "reorder");
	p += retlen;
a242 1
	curCC = getCombinClass(uv);
d244 15
a258 14
	if (curCC != 0) {
	    if (seq_max < cc_pos + 1) { /* extend if need */
		seq_max = cc_pos + CC_SEQ_STEP; /* new size */
		if (CC_SEQ_SIZE == cc_pos) { /* seq_ary full */
		    STRLEN i;
		    New(0, seq_ext, seq_max, UNF_cc);
		    for (i = 0; i < cc_pos; i++)
			seq_ext[i] = seq_ary[i];
		}
		else {
		    Renew(seq_ext, seq_max, UNF_cc);
		}
		seq_ptr = seq_ext; /* use seq_ext from now */
	    }
d260 5
a264 4
	    seq_ptr[cc_pos].cc  = curCC;
	    seq_ptr[cc_pos].uv  = uv;
	    seq_ptr[cc_pos].pos = cc_pos;
	    ++cc_pos;
d266 2
a267 3
	    if (p < e)
		continue;
	}
d269 5
a273 13
	if (cc_pos) {
	    STRLEN i;

	    if (cc_pos > 1) /* reordered if there are two c.c.'s */
		qsort((void*)seq_ptr, cc_pos, sizeof(UNF_cc), compare_cc);

	    for (i = 0; i < cc_pos; i++) {
		d = uvuni_to_utf8(d, seq_ptr[i].uv);
		if (dend < d) /* real end is dend + UTF8_MAXLEN */
		    croak(ErrLongerThanSrc, "reorder");
	    }
	    cc_pos = 0;
	}
d275 1
d278 1
a278 2
	    if (dend < d) /* real end is dend + UTF8_MAXLEN */
		croak(ErrLongerThanSrc, "reorder");
a279 34
    }
    if (seq_ext)
	Safefree(seq_ext);
    return d;
}

static
U8* pv_utf8_compose(U8* s, STRLEN slen, U8* d, STRLEN dlen, bool iscontig)
{
    U8* p = s;
    U8* e = s + slen;
    U8* dend = d + dlen;

    UV uvS = 0; /* code point of the starter */
    bool valid_uvS = FALSE; /* if FALSE, uvS isn't initialized yet */
    U8 preCC = 0;

    UV  seq_ary[CC_SEQ_SIZE];
    UV* seq_ptr = seq_ary; /* use array at the beginning */
    UV* seq_ext = NULL; /* extend if need */
    STRLEN seq_max = CC_SEQ_SIZE;
    STRLEN cc_pos = 0;

    if (dlen < slen || dlen < slen + UTF8_MAXLEN)
	croak(ErrTargetNotEnough, "compose");
    dend -= UTF8_MAXLEN; /* safety */

    while (p < e) {
	U8 curCC;
	STRLEN retlen;
	UV uv = utf8n_to_uvuni(p, e - p, &retlen, AllowAnyUTF);
	if (!retlen)
	    croak(ErrRetlenIsZero, "compose");
	p += retlen;
d281 11
a291 1
	curCC = getCombinClass(uv);
d293 1
a293 1
	if (!valid_uvS) {
d295 3
a297 40
		uvS = uv; /* the first Starter is found */
		valid_uvS = TRUE;
		if (p < e)
		    continue;
	    }
	    else {
		d = uvuni_to_utf8(d, uv);
		if (dend < d) /* real end is dend + UTF8_MAXLEN */
		    croak(ErrLongerThanSrc, "compose");
		continue;
	    }
	}
	else {
	    bool composed;

	    /* blocked */
	    if (iscontig && cc_pos || /* discontiguous combination */
		 curCC != 0 && preCC == curCC || /* blocked by same CC */
		 preCC > curCC) /* blocked by higher CC: revised D2 */
		composed = FALSE;

	    /* not blocked:
		 iscontig && cc_pos == 0      -- contiguous combination
		 curCC == 0 && preCC == 0     -- starter + starter
		 curCC != 0 && preCC < curCC  -- lower CC */
	    else {
		/* try composition */
		UV uvComp = composite_uv(uvS, uv);

		if (uvComp && !isExclusion(uvComp))  {
		    uvS = uvComp;
		    composed = TRUE;

		    /* preCC should not be changed to curCC */
		    /* e.g. 1E14 = 0045 0304 0300 where CC(0304) == CC(0300) */
		    if (p < e)
			continue;
		}
		else
		    composed = FALSE;
d300 4
a303 19
	    if (!composed) {
		preCC = curCC;
		if (curCC != 0 || !(p < e)) {
		    if (seq_max < cc_pos + 1) { /* extend if need */
			seq_max = cc_pos + CC_SEQ_STEP; /* new size */
			if (CC_SEQ_SIZE == cc_pos) { /* seq_ary full */
			    New(0, seq_ext, seq_max, UV);
			    Copy(seq_ary, seq_ext, cc_pos, UV);
			}
			else {
			    Renew(seq_ext, seq_max, UV);
			}
			seq_ptr = seq_ext; /* use seq_ext from now */
		    }
		    seq_ptr[cc_pos] = uv;
		    ++cc_pos;
		}
		if (curCC != 0 && p < e)
		    continue;
d305 3
d310 1
a310 4
	d = uvuni_to_utf8(d, uvS); /* starter (composed or not) */
	if (dend < d) /* real end is dend + UTF8_MAXLEN */
	    croak(ErrLongerThanSrc, "compose");

d312 2
a313 1
	    STRLEN i;
d315 6
a320 6
	    for (i = 0; i < cc_pos; i++) {
		d = uvuni_to_utf8(d, seq_ptr[i]);
		if (dend < d) /* real end is dend + UTF8_MAXLEN */
		    croak(ErrLongerThanSrc, "compose");
	    }
	    cc_pos = 0;
a321 2

	uvS = uv;
d323 3
a325 25
    if (seq_ext)
	Safefree(seq_ext);
    return d;
}

MODULE = Unicode::Normalize	PACKAGE = Unicode::Normalize

SV*
decompose(src, compat = &PL_sv_no)
    SV * src
    SV * compat
  PROTOTYPE: $;$
  PREINIT:
    SV* dst;
    U8 *s, *d, *dend;
    STRLEN slen, dlen;
  CODE:
    s = (U8*)sv_2pvunicode(src,&slen);
    dst = newSVpvn("", 0);
    dlen = slen;
    New(0, d, dlen+1, U8);
    dend = pv_utf8_decompose(s, slen, &d, dlen, (bool)SvTRUE(compat));
    sv_setpvn(dst, (char *)d, dend - d);
    SvUTF8_on(dst);
    Safefree(d);
d330 1
a330 20
SV*
reorder(src)
    SV * src
  PROTOTYPE: $
  PREINIT:
    SV* dst;
    U8 *s, *d, *dend;
    STRLEN slen, dlen;
  CODE:
    s = (U8*)sv_2pvunicode(src,&slen);
    dst = newSVpvn("", 0);
    dlen = slen + UTF8_MAXLEN;
    d = (U8*)SvGROW(dst,dlen+1);
    SvUTF8_on(dst);
    dend = pv_utf8_reorder(s, slen, d, dlen);
    *dend = '\0';
    SvCUR_set(dst, dend - d);
    RETVAL = dst;
  OUTPUT:
    RETVAL
d339 5
a343 3
    SV* dst;
    U8 *s, *d, *dend;
    STRLEN slen, dlen;
d345 6
a350 4
    s = (U8*)sv_2pvunicode(src,&slen);
    dst = newSVpvn("", 0);
    dlen = slen + UTF8_MAXLEN;
    d = (U8*)SvGROW(dst,dlen+1);
d352 31
a382 6
    dend = pv_utf8_compose(s, slen, d, dlen, (bool)ix);
    *dend = '\0';
    SvCUR_set(dst, dend - d);
    RETVAL = dst;
  OUTPUT:
    RETVAL
d384 1
a384 27
SV*
NFD(src)
    SV * src
  PROTOTYPE: $
  ALIAS:
    NFKD = 1
  PREINIT:
    SV *dst;
    U8 *s, *t, *tend, *d, *dend;
    STRLEN slen, tlen, dlen;
  CODE:
    /* decompose */
    s = (U8*)sv_2pvunicode(src,&slen);
    tlen = slen;
    New(0, t, tlen+1, U8);
    tend = pv_utf8_decompose(s, slen, &t, tlen, (bool)ix);
    *tend = '\0';
    tlen = tend - t; /* no longer know real tlen */

    /* reorder */
    dst = newSVpvn("", 0);
    dlen = tlen + UTF8_MAXLEN;
    d = (U8*)SvGROW(dst,dlen+1);
    SvUTF8_on(dst);
    dend = pv_utf8_reorder(t, tlen, d, dlen);
    *dend = '\0';
    SvCUR_set(dst, dend - d);
d386 38
a423 2
    /* return */
    Safefree(t);
a427 42
SV*
NFC(src)
    SV * src
  PROTOTYPE: $
  ALIAS:
    NFKC = 1
    FCC  = 2
  PREINIT:
    SV *dst;
    U8 *s, *t, *tend, *u, *uend, *d, *dend;
    STRLEN slen, tlen, ulen, dlen;
  CODE:
    /* decompose */
    s = (U8*)sv_2pvunicode(src,&slen);
    tlen = slen;
    New(0, t, tlen+1, U8);
    tend = pv_utf8_decompose(s, slen, &t, tlen, (bool)(ix==1));
    *tend = '\0';
    tlen = tend - t; /* no longer know real tlen */

    /* reorder */
    ulen = tlen + UTF8_MAXLEN;
    New(0, u, ulen+1, U8);
    uend = pv_utf8_reorder(t, tlen, u, ulen);
    *uend = '\0';
    ulen = uend - u;

    /* compose */
    dst = newSVpvn("", 0);
    dlen = ulen + UTF8_MAXLEN;
    d = (U8*)SvGROW(dst,dlen+1);
    SvUTF8_on(dst);
    dend = pv_utf8_compose(u, ulen, d, dlen, (bool)(ix==2));
    *dend = '\0';
    SvCUR_set(dst, dend - d);

    /* return */
    Safefree(t);
    Safefree(u);
    RETVAL = dst;
  OUTPUT:
    RETVAL
d429 1
a429 1
SV*
d438 1
a438 1
    bool result = TRUE;
d445 1
a445 1
	UV uv = utf8n_to_uvuni(p, e - p, &retlen, AllowAnyUTF);
d447 1
a447 1
	    croak(ErrRetlenIsZero, "checkNFD or -NFKD");
d450 4
a453 8
	if (preCC > curCC && curCC != 0) { /* canonical ordering violated */
	    result = FALSE;
	    break;
	}
	if (Hangul_IsS(uv) || (ix ? dec_compat(uv) : dec_canonical(uv))) {
	    result = FALSE;
	    break;
	}
d456 2
a457 3
    RETVAL = boolSV(result);
  OUTPUT:
    RETVAL
d460 1
a460 1
SV*
d469 2
a470 2
    bool result = TRUE;
    bool isMAYBE = FALSE;
d476 1
d478 1
a478 1
	UV uv = utf8n_to_uvuni(p, e - p, &retlen, AllowAnyUTF);
d480 1
a480 1
	    croak(ErrRetlenIsZero, "checkNFC or -NFKC");
d483 3
a485 4
	if (preCC > curCC && curCC != 0) { /* canonical ordering violated */
	    result = FALSE;
	    break;
	}
d490 2
a491 4
	else if (isExclusion(uv) || isSingleton(uv) || isNonStDecomp(uv)) {
	    result = FALSE;
	    break;
	}
d499 2
a500 4
	    if (compat && !(canon && strEQ(canon, compat))) {
		result = FALSE;
		break;
	    }
d505 1
a505 1
    if (isMAYBE && result) /* NO precedes MAYBE */
d507 3
a509 3
    RETVAL = boolSV(result);
  OUTPUT:
    RETVAL
d512 1
a512 1
SV*
d519 1
a519 1
    STRLEN srclen, retlen;
d521 3
a523 2
    bool result = TRUE;
    bool isMAYBE = FALSE;
d527 1
d529 1
d531 1
a531 4
	U8 *sCan;
	UV uvLead;
	STRLEN canlen = 0;
	UV uv = utf8n_to_uvuni(p, e - p, &retlen, AllowAnyUTF);
d533 1
a533 1
	    croak(ErrRetlenIsZero, "checkFCD or -FCC");
a537 1
	    STRLEN canret;
a539 2
	    if (!canret)
		croak(ErrRetlenIsZero, "checkFCD or -FCC");
d547 2
a548 4
	if (curCC != 0 && curCC < preCC) { /* canonical ordering violated */
	    result = FALSE;
	    break;
	}
d551 2
a552 4
	    if (isExclusion(uv) || isSingleton(uv) || isNonStDecomp(uv)) {
		result = FALSE;
		break;
	    }
d558 2
a559 4
	    STRLEN canret;
	    UV uvTrail;
	    U8* eCan = sCan + canlen;
	    U8* pCan = utf8_hop(eCan, -1);
a562 2
	    if (!canret)
		croak(ErrRetlenIsZero, "checkFCD or -FCC");
d569 1
a569 1
    if (isMAYBE && result) /* NO precedes MAYBE */
d571 3
a573 3
    RETVAL = boolSV(result);
  OUTPUT:
    RETVAL
d606 1
a606 1
SV*
a611 2
  PREINIT:
    bool result = FALSE;
d614 4
a617 4
	result = TRUE; /* NFD_NO or NFKD_NO */
    RETVAL = boolSV(result);
  OUTPUT:
    RETVAL
d620 1
a620 1
SV*
a626 2
  PREINIT:
    bool result = FALSE;
d629 1
a629 1
	result = TRUE; /* NFC_NO or NFKC_NO */
d635 3
a637 1
	    result = TRUE; /* NFC_NO or NFKC_NO */
d639 4
a642 3
    RETVAL = boolSV(result);
  OUTPUT:
    RETVAL
d665 2
d669 5
a673 4
	U8 tmp[3 * UTF8_MAXLEN + 1];
	U8 *t = tmp;
	U8 *e = pv_cat_decompHangul(t, uv);
	RETVAL = newSVpvn((char *)t, e - t);
d675 1
a675 1
	U8* rstr = ix ? dec_compat(uv) : dec_canonical(uv);
d690 1
a690 1
    STRLEN srclen;
d692 1
d696 2
a697 3
    p = e;
    while (s < p) {
	UV uv;
d701 1
a701 1
	uv = utf8n_to_uvuni(p, e - p, NULL, AllowAnyUTF);
@


