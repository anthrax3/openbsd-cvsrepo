head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.6
	OPENBSD_6_2_BASE:1.12
	PERL_5_24_2:1.1.1.11
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.10
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.8.0.10
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.8
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2017.02.05.00.32.13;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	cxJ08BvJA9Pt2PTM;

1.11
date	2014.11.17.20.57.06;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	QP75iYx42Uo7mMxO;

1.10
date	2014.03.24.15.05.27;	author afresh1;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.25.20.40.54;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.24.15.06.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.05;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.03;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.23;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.14;	author millert;	state Exp;
branches
	1.4.4.1
	1.4.6.1;
next	1.3;

1.3
date	2000.04.06.17.05.26;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.32;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.55.37;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.38.52;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.17;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.54;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.18;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.23;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.48.49;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.08.45;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.24.14.59.02;	author afresh1;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.11.17.20.53.06;	author afresh1;	state Exp;
branches;
next	1.1.1.11;
commitid	B31cAbBIXiCqnL97;

1.1.1.11
date	2017.08.14.13.46.11;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;

1.4.4.1
date	2003.01.22.23.55.51;	author miod;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2003.01.24.00.30.30;	author miod;	state Exp;
branches;
next	;

1.4.6.1
date	2003.01.21.15.42.52;	author jason;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2003.01.23.19.09.22;	author margarida;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package Opcode;

use 5.006_001;

use strict;

our($VERSION, @@ISA, @@EXPORT_OK);

$VERSION = "1.34";

use Carp;
use Exporter ();
use XSLoader;

BEGIN {
    @@ISA = qw(Exporter);
    @@EXPORT_OK = qw(
	opset ops_to_opset
	opset_to_ops opset_to_hex invert_opset
	empty_opset full_opset
	opdesc opcodes opmask define_optag
	opmask_add verify_opset opdump
    );
}

sub opset (;@@);
sub opset_to_hex ($);
sub opdump (;$);
use subs @@EXPORT_OK;

XSLoader::load();

_init_optags();

sub ops_to_opset { opset @@_ }	# alias for old name

sub opset_to_hex ($) {
    return "(invalid opset)" unless verify_opset($_[0]);
    unpack("h*",$_[0]);
}

sub opdump (;$) {
	my $pat = shift;
    # handy utility: perl -MOpcode=opdump -e 'opdump File'
    foreach(opset_to_ops(full_opset)) {
        my $op = sprintf "  %12s  %s\n", $_, opdesc($_);
		next if defined $pat and $op !~ m/$pat/i;
		print $op;
    }
}



sub _init_optags {
    my(%all, %seen);
    @@all{opset_to_ops(full_opset)} = (); # keys only

    local($_);
    local($/) = "\n=cut"; # skip to optags definition section
    <DATA>;
    $/ = "\n=";		# now read in 'pod section' chunks
    while(<DATA>) {
	next unless m/^item\s+(:\w+)/;
	my $tag = $1;

	# Split into lines, keep only indented lines
	my @@lines = grep { m/^\s/    } split(/\n/);
	foreach (@@lines) { s/(?:\t|--).*//  } # delete comments
	my @@ops   = map  { split ' ' } @@lines; # get op words

	foreach(@@ops) {
	    warn "$tag - $_ already tagged in $seen{$_}\n" if $seen{$_};
	    $seen{$_} = $tag;
	    delete $all{$_};
	}
	# opset will croak on invalid names
	define_optag($tag, opset(@@ops));
    }
    close(DATA);
    warn "Untagged opnames: ".join(' ',keys %all)."\n" if %all;
}


1;

__DATA__

=head1 NAME

Opcode - Disable named opcodes when compiling perl code

=head1 SYNOPSIS

  use Opcode;


=head1 DESCRIPTION

Perl code is always compiled into an internal format before execution.

Evaluating perl code (e.g. via "eval" or "do 'file'") causes
the code to be compiled into an internal format and then,
provided there was no error in the compilation, executed.
The internal format is based on many distinct I<opcodes>.

By default no opmask is in effect and any code can be compiled.

The Opcode module allow you to define an I<operator mask> to be in
effect when perl I<next> compiles any code.  Attempting to compile code
which contains a masked opcode will cause the compilation to fail
with an error. The code will not be executed.

=head1 NOTE

The Opcode module is not usually used directly. See the ops pragma and
Safe modules for more typical uses.

=head1 WARNING

The authors make B<no warranty>, implied or otherwise, about the
suitability of this software for safety or security purposes.

The authors shall not in any case be liable for special, incidental,
consequential, indirect or other similar damages arising from the use
of this software.

Your mileage will vary. If in any doubt B<do not use it>.


=head1 Operator Names and Operator Lists

The canonical list of operator names is the contents of the array
PL_op_name defined and initialised in file F<opcode.h> of the Perl
source distribution (and installed into the perl library).

Each operator has both a terse name (its opname) and a more verbose or
recognisable descriptive name. The opdesc function can be used to
return a list of descriptions for a list of operators.

Many of the functions and methods listed below take a list of
operators as parameters. Most operator lists can be made up of several
types of element. Each element can be one of

=over 8

=item an operator name (opname)

Operator names are typically small lowercase words like enterloop,
leaveloop, last, next, redo etc. Sometimes they are rather cryptic
like gv2cv, i_ncmp and ftsvtx.

=item an operator tag name (optag)

Operator tags can be used to refer to groups (or sets) of operators.
Tag names always begin with a colon. The Opcode module defines several
optags and the user can define others using the define_optag function.

=item a negated opname or optag

An opname or optag can be prefixed with an exclamation mark, e.g., !mkdir.
Negating an opname or optag means remove the corresponding ops from the
accumulated set of ops at that point.

=item an operator set (opset)

An I<opset> as a binary string of approximately 44 bytes which holds a
set or zero or more operators.

The opset and opset_to_ops functions can be used to convert from
a list of operators to an opset and I<vice versa>.

Wherever a list of operators can be given you can use one or more opsets.
See also Manipulating Opsets below.

=back


=head1 Opcode Functions

The Opcode package contains functions for manipulating operator names
tags and sets. All are available for export by the package.

=over 8

=item opcodes

In a scalar context opcodes returns the number of opcodes in this
version of perl (around 350 for perl-5.7.0).

In a list context it returns a list of all the operator names.
(Not yet implemented, use @@names = opset_to_ops(full_opset).)

=item opset (OP, ...)

Returns an opset containing the listed operators.

=item opset_to_ops (OPSET)

Returns a list of operator names corresponding to those operators in
the set.

=item opset_to_hex (OPSET)

Returns a string representation of an opset. Can be handy for debugging.

=item full_opset

Returns an opset which includes all operators.

=item empty_opset

Returns an opset which contains no operators.

=item invert_opset (OPSET)

Returns an opset which is the inverse set of the one supplied.

=item verify_opset (OPSET, ...)

Returns true if the supplied opset looks like a valid opset (is the
right length etc) otherwise it returns false. If an optional second
parameter is true then verify_opset will croak on an invalid opset
instead of returning false.

Most of the other Opcode functions call verify_opset automatically
and will croak if given an invalid opset.

=item define_optag (OPTAG, OPSET)

Define OPTAG as a symbolic name for OPSET. Optag names always start
with a colon C<:>.

The optag name used must not be defined already (define_optag will
croak if it is already defined). Optag names are global to the perl
process and optag definitions cannot be altered or deleted once
defined.

It is strongly recommended that applications using Opcode should use a
leading capital letter on their tag names since lowercase names are
reserved for use by the Opcode module. If using Opcode within a module
you should prefix your tags names with the name of your module to
ensure uniqueness and thus avoid clashes with other modules.

=item opmask_add (OPSET)

Adds the supplied opset to the current opmask. Note that there is
currently I<no> mechanism for unmasking ops once they have been masked.
This is intentional.

=item opmask

Returns an opset corresponding to the current opmask.

=item opdesc (OP, ...)

This takes a list of operator names and returns the corresponding list
of operator descriptions.

=item opdump (PAT)

Dumps to STDOUT a two column list of op names and op descriptions.
If an optional pattern is given then only lines which match the
(case insensitive) pattern will be output.

It's designed to be used as a handy command line utility:

	perl -MOpcode=opdump -e opdump
	perl -MOpcode=opdump -e 'opdump Eval'

=back

=head1 Manipulating Opsets

Opsets may be manipulated using the perl bit vector operators & (and), | (or),
^ (xor) and ~ (negate/invert).

However you should never rely on the numerical position of any opcode
within the opset. In other words both sides of a bit vector operator
should be opsets returned from Opcode functions.

Also, since the number of opcodes in your current version of perl might
not be an exact multiple of eight, there may be unused bits in the last
byte of an upset. This should not cause any problems (Opcode functions
ignore those extra bits) but it does mean that using the ~ operator
will typically not produce the same 'physical' opset 'string' as the
invert_opset function.


=head1 TO DO (maybe)

    $bool = opset_eq($opset1, $opset2)	true if opsets are logically
					equivalent
    $yes = opset_can($opset, @@ops)	true if $opset has all @@ops set

    @@diff = opset_diff($opset1, $opset2) => ('foo', '!bar', ...)

=cut

# the =cut above is used by _init_optags() to get here quickly

=head1 Predefined Opcode Tags

=over 5

=item :base_core

    null stub scalar pushmark wantarray const defined undef

    rv2sv sassign

    rv2av aassign aelem aelemfast aelemfast_lex aslice kvaslice
    av2arylen

    rv2hv helem hslice kvhslice each values keys exists delete
    aeach akeys avalues multideref

    preinc i_preinc predec i_predec postinc i_postinc
    postdec i_postdec int hex oct abs pow multiply i_multiply
    divide i_divide modulo i_modulo add i_add subtract i_subtract

    left_shift right_shift bit_and bit_xor bit_or nbit_and
    nbit_xor nbit_or sbit_and sbit_xor sbit_or negate i_negate not
    complement ncomplement scomplement

    lt i_lt gt i_gt le i_le ge i_ge eq i_eq ne i_ne ncmp i_ncmp
    slt sgt sle sge seq sne scmp

    substr vec stringify study pos length index rindex ord chr

    ucfirst lcfirst uc lc fc quotemeta trans transr chop schop
    chomp schomp

    match split qr

    list lslice splice push pop shift unshift reverse

    cond_expr flip flop andassign orassign dorassign and or dor xor

    warn die lineseq nextstate scope enter leave

    rv2cv anoncode prototype coreargs anonconst

    entersub leavesub leavesublv return method method_named
    method_super method_redir method_redir_super
     -- XXX loops via recursion?

    leaveeval -- needed for Safe to operate, is safe
		 without entereval

=item :base_mem

These memory related ops are not included in :base_core because they
can easily be used to implement a resource attack (e.g., consume all
available memory).

    concat repeat join range

    anonlist anonhash

Note that despite the existence of this optag a memory resource attack
may still be possible using only :base_core ops.

Disabling these ops is a I<very> heavy handed way to attempt to prevent
a memory resource attack. It's probable that a specific memory limit
mechanism will be added to perl in the near future.

=item :base_loop

These loop ops are not included in :base_core because they can easily be
used to implement a resource attack (e.g., consume all available CPU time).

    grepstart grepwhile
    mapstart mapwhile
    enteriter iter
    enterloop leaveloop unstack
    last next redo
    goto

=item :base_io

These ops enable I<filehandle> (rather than filename) based input and
output. These are safe on the assumption that only pre-existing
filehandles are available for use.  Usually, to create new filehandles
other ops such as open would need to be enabled, if you don't take into
account the magical open of ARGV.

    readline rcatline getc read

    formline enterwrite leavewrite

    print say sysread syswrite send recv

    eof tell seek sysseek

    readdir telldir seekdir rewinddir

=item :base_orig

These are a hotchpotch of opcodes still waiting to be considered

    gvsv gv gelem

    padsv padav padhv padcv padany padrange introcv clonecv

    once

    rv2gv refgen srefgen ref refassign lvref lvrefslice lvavref

    bless -- could be used to change ownership of objects
	     (reblessing)

    pushre regcmaybe regcreset regcomp subst substcont

    sprintf prtf -- can core dump

    crypt

    tie untie

    dbmopen dbmclose
    sselect select
    pipe_op sockpair

    getppid getpgrp setpgrp getpriority setpriority
    localtime gmtime

    entertry leavetry -- can be used to 'hide' fatal errors

    entergiven leavegiven
    enterwhen leavewhen
    break continue
    smartmatch

    custom -- where should this go

=item :base_math

These ops are not included in :base_core because of the risk of them being
used to generate floating point exceptions (which would have to be caught
using a $SIG{FPE} handler).

    atan2 sin cos exp log sqrt

These ops are not included in :base_core because they have an effect
beyond the scope of the compartment.

    rand srand

=item :base_thread

These ops are related to multi-threading.

    lock

=item :default

A handy tag name for a I<reasonable> default set of ops.  (The current ops
allowed are unstable while development continues. It will change.)

    :base_core :base_mem :base_loop :base_orig :base_thread

This list used to contain :base_io prior to Opcode 1.07.

If safety matters to you (and why else would you be using the Opcode module?)
then you should not rely on the definition of this, or indeed any other, optag!

=item :filesys_read

    stat lstat readlink

    ftatime ftblk ftchr ftctime ftdir fteexec fteowned
    fteread ftewrite ftfile ftis ftlink ftmtime ftpipe
    ftrexec ftrowned ftrread ftsgid ftsize ftsock ftsuid
    fttty ftzero ftrwrite ftsvtx

    fttext ftbinary

    fileno

=item :sys_db

    ghbyname ghbyaddr ghostent shostent ehostent      -- hosts
    gnbyname gnbyaddr gnetent snetent enetent         -- networks
    gpbyname gpbynumber gprotoent sprotoent eprotoent -- protocols
    gsbyname gsbyport gservent sservent eservent      -- services

    gpwnam gpwuid gpwent spwent epwent getlogin       -- users
    ggrnam ggrgid ggrent sgrent egrent                -- groups

=item :browse

A handy tag name for a I<reasonable> default set of ops beyond the
:default optag.  Like :default (and indeed all the other optags) its
current definition is unstable while development continues. It will change.

The :browse tag represents the next step beyond :default. It it a
superset of the :default ops and adds :filesys_read the :sys_db.
The intent being that scripts can access more (possibly sensitive)
information about your system but not be able to change it.

    :default :filesys_read :sys_db

=item :filesys_open

    sysopen open close
    umask binmode

    open_dir closedir -- other dir ops are in :base_io

=item :filesys_write

    link unlink rename symlink truncate

    mkdir rmdir

    utime chmod chown

    fcntl -- not strictly filesys related, but possibly as
	     dangerous?

=item :subprocess

    backtick system

    fork

    wait waitpid

    glob -- access to Cshell via <`rm *`>

=item :ownprocess

    exec exit kill

    time tms -- could be used for timing attacks (paranoid?)

=item :others

This tag holds groups of assorted specialist opcodes that don't warrant
having optags defined for them.

SystemV Interprocess Communications:

    msgctl msgget msgrcv msgsnd

    semctl semget semop

    shmctl shmget shmread shmwrite

=item :load

This tag holds opcodes related to loading modules and getting information
about calling environment and args.

    require dofile 
    caller runcv

=item :still_to_be_decided

    chdir
    flock ioctl

    socket getpeername ssockopt
    bind connect listen accept shutdown gsockopt getsockname

    sleep alarm -- changes global timer state and signal handling
    sort -- assorted problems including core dumps
    tied -- can be used to access object implementing a tie
    pack unpack -- can be used to create/use memory pointers

    hintseval -- constant op holding eval hints

    entereval -- can be used to hide code from initial compile

    reset

    dbstate -- perl -d version of nextstate(ment) opcode

=item :dangerous

This tag is simply a bucket for opcodes that are unlikely to be used via
a tag name but need to be tagged for completeness and documentation.

    syscall dump chroot

=back

=head1 SEE ALSO

L<ops> -- perl pragma interface to Opcode module.

L<Safe> -- Opcode and namespace limited execution compartments

=head1 AUTHORS

Originally designed and implemented by Malcolm Beattie,
mbeattie@@sable.ox.ac.uk as part of Safe version 1.

Split out from Safe module version 1, named opcode tags and other
changes added by Tim Bunce.

=cut

@


1.11
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d9 1
a9 1
$VERSION = "1.27";
d315 1
a315 1
    aeach akeys avalues reach rvalues rkeys
d321 3
a323 2
    left_shift right_shift bit_and bit_xor bit_or negate i_negate
    not complement
d341 1
a341 1
    rv2cv anoncode prototype coreargs
d344 1
d407 1
a407 1
    rv2gv refgen srefgen ref
@


1.10
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d9 1
a9 1
$VERSION = "1.25";
d311 2
a312 1
    rv2av aassign aelem aelemfast aelemfast_lex aslice av2arylen
d314 2
a315 2
    rv2hv helem hslice each values keys exists delete aeach akeys
    avalues reach rvalues rkeys
@


1.9
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d9 1
a9 1
$VERSION = "1.23";
d68 1
a68 1
	foreach (@@lines) { s/--.*//  } # delete comments
d291 2
a292 2
    $bool = opset_eq($opset1, $opset2)	true if opsets are logically eqiv

d313 2
a314 2
    rv2hv helem hslice each values keys exists delete aeach akeys avalues
    boolkeys reach rvalues rkeys
d316 3
a318 3
    preinc i_preinc predec i_predec postinc i_postinc postdec i_postdec
    int hex oct abs pow multiply i_multiply divide i_divide
    modulo i_modulo add i_add subtract i_subtract
d328 2
a329 1
    ucfirst lcfirst uc lc fc quotemeta trans transr chop schop chomp schomp
d341 2
a342 1
    entersub leavesub leavesublv return method method_named -- XXX loops via recursion?
d344 2
a345 1
    leaveeval -- needed for Safe to operate, is safe without entereval
d400 1
a400 1
    padsv padav padhv padany
d406 2
a407 1
    bless -- could be used to change ownership of objects (reblessing)
d421 2
a422 1
    getppid getpgrp setpgrp getpriority setpriority localtime gmtime
d468 4
a471 3
    ftatime ftblk ftchr ftctime ftdir fteexec fteowned fteread
    ftewrite ftfile ftis ftlink ftmtime ftpipe ftrexec ftrowned
    ftrread ftsgid ftsize ftsock ftsuid fttty ftzero ftrwrite ftsvtx
d515 2
a516 1
    fcntl -- not strictly filesys related, but possibly as dangerous?
@


1.8
log
@merge in perl 5.12.2 plus local changes
@
text
@d9 1
a9 1
$VERSION = "1.15";
d13 1
a13 1
use XSLoader ();
d31 1
a31 1
XSLoader::load 'Opcode', $VERSION;
d311 1
a311 1
    rv2av aassign aelem aelemfast aslice av2arylen
d314 1
a314 1
    boolkeys
d328 1
a328 1
    ucfirst lcfirst uc lc quotemeta trans chop schop chomp schomp
d338 1
a338 1
    rv2cv anoncode prototype
d546 1
a546 1
    caller
@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d9 1
a9 1
$VERSION = "1.11";
d313 2
a314 1
    rv2hv helem hslice each values keys exists delete
d336 1
a336 1
    warn die lineseq nextstate scope enter leave setstate
d560 2
@


1.6
log
@merge in perl 5.8.8
@
text
@d7 1
a7 1
our($VERSION, $XS_VERSION, @@ISA, @@EXPORT_OK);
d9 1
a9 2
$VERSION = "1.06";
$XS_VERSION = "1.03";
d31 1
a31 1
XSLoader::load 'Opcode', $XS_VERSION;
d333 1
a333 1
    cond_expr flip flop andassign orassign and or xor
d376 3
a378 2
filehandles are available for use.  To create new filehandles other ops
such as open would need to be enabled.
d384 1
a384 1
    print sysread syswrite send recv
d398 2
d420 5
d444 1
a444 1
    lock threadsv
d451 3
a453 1
    :base_core :base_mem :base_loop :base_io :base_orig :base_thread
a457 1

d539 8
a560 3
    require dofile 

    caller -- get info about calling environment and args
a572 1

d577 1
a577 1
ops(3) -- perl pragma interface to Opcode module.
d579 1
a579 1
Safe(3) -- Opcode and namespace limited execution compartments
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d9 1
a9 1
$VERSION = "1.05";
d354 1
a354 1
Note that despite the existance of this optag a memory resource attack
d556 1
a556 1
a tag name but need to be tagged for completness and documentation.
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 3
a5 1
require 5.005_64;
d9 1
a9 1
$VERSION = "1.04";
a11 1
use strict;
a14 1
@@ISA = qw(Exporter);
d17 1
d417 2
@


1.4.4.1
log
@Pull in patch from current:
Fix (margarida):
Bug Fix
Update Safe module to version 2.09
@
text
@d3 1
a3 3
use 5.006_001;

use strict;
d7 1
a7 1
$VERSION = "1.05";
d10 1
d14 1
a16 1
    @@ISA = qw(Exporter);
a415 2

    custom -- where should this go
@


1.4.4.2
log
@Back out unwanted Opcode.pm commit, and correctly apply the Safe.pm fix to
Safe.pm.
From angry margarida@@ and her rolling pin. Ouch, head hurts.
@
text
@d3 3
a5 1
require 5.005_64;
d9 1
a9 1
$VERSION = "1.04";
a11 1
use strict;
a14 1
@@ISA = qw(Exporter);
d17 1
d417 2
@


1.4.6.1
log
@Pull in patch from current:
Fix (margarida):
Bug Fix
Update Safe module to version 2.09

millert@@ ok
@
text
@d3 1
a3 3
use 5.006_001;

use strict;
d7 1
a7 1
$VERSION = "1.05";
d10 1
d14 1
a16 1
    @@ISA = qw(Exporter);
a415 2

    custom -- where should this go
@


1.4.6.2
log
@back out erroneous previous commit
@
text
@d3 3
a5 1
require 5.005_64;
d9 1
a9 1
$VERSION = "1.04";
a11 1
use strict;
a14 1
@@ISA = qw(Exporter);
d17 1
d417 2
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d166 1
a166 1
An I<opset> as a binary string of approximately 43 bytes which holds a
d188 1
a188 1
version of perl (around 340 for perl5.002).
@


1.2
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
require 5.002;
d5 1
a5 1
use vars qw($VERSION $XS_VERSION @@ISA @@EXPORT_OK);
d13 2
a14 2
use DynaLoader ();
@@ISA = qw(Exporter DynaLoader);
d31 1
a31 1
bootstrap Opcode $XS_VERSION;
d133 1
a133 1
op_name defined and initialised in file F<opcode.h> of the Perl
d335 1
a335 1
    warn die lineseq nextstate unstack scope enter leave
d339 1
a339 1
    entersub leavesub return method -- XXX loops via recursion?
d368 1
a368 1
    enterloop leaveloop
@


1.1
log
@perl 5.004_04
@
text
@d8 1
a8 1
$XS_VERSION = "1.02";
d155 1
a155 1
Tag names always being with a colon. The Opcode module defines several
d329 1
a329 1
    match split
d401 1
a401 1
    pushre regcmaybe regcomp subst substcont
d430 6
d441 1
a441 1
    :base_core :base_mem :base_loop :base_io :base_orig
d572 1
a572 1
changes added by Tim Bunce E<lt>F<Tim.Bunce@@ig.co.uk>E<gt>.
@


1.1.1.1
log
@perl5.005_03
@
text
@d8 1
a8 1
$XS_VERSION = "1.03";
d155 1
a155 1
Tag names always begin with a colon. The Opcode module defines several
d329 1
a329 1
    match split qr
d401 1
a401 1
    pushre regcmaybe regcreset regcomp subst substcont
a429 6
=item :base_thread

These ops are related to multi-threading.

    lock threadsv

d435 1
a435 1
    :base_core :base_mem :base_loop :base_io :base_orig :base_thread
d566 1
a566 1
changes added by Tim Bunce.
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
require 5.005_64;
d5 1
a5 1
our($VERSION, $XS_VERSION, @@ISA, @@EXPORT_OK);
d13 2
a14 2
use XSLoader ();
@@ISA = qw(Exporter);
d31 1
a31 1
XSLoader::load 'Opcode', $XS_VERSION;
d133 1
a133 1
PL_op_name defined and initialised in file F<opcode.h> of the Perl
d335 1
a335 1
    warn die lineseq nextstate scope enter leave setstate
d339 1
a339 1
    entersub leavesub leavesublv return method method_named -- XXX loops via recursion?
d368 1
a368 1
    enterloop leaveloop unstack
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d166 1
a166 1
An I<opset> as a binary string of approximately 44 bytes which holds a
d188 1
a188 1
version of perl (around 350 for perl-5.7.0).
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 3
use 5.006_001;

use strict;
d7 1
a7 1
$VERSION = "1.05";
d10 1
d14 1
a16 1
    @@ISA = qw(Exporter);
a415 2

    custom -- where should this go
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d9 1
a9 1
$VERSION = "1.06";
d354 1
a354 1
Note that despite the existence of this optag a memory resource attack
d556 1
a556 1
a tag name but need to be tagged for completeness and documentation.
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d7 1
a7 1
our($VERSION, @@ISA, @@EXPORT_OK);
d9 2
a10 1
$VERSION = "1.11";
d32 1
a32 1
XSLoader::load 'Opcode', $VERSION;
d334 1
a334 1
    cond_expr flip flop andassign orassign dorassign and or dor xor
d377 2
a378 3
filehandles are available for use.  Usually, to create new filehandles
other ops such as open would need to be enabled, if you don't take into
account the magical open of ARGV.
d384 1
a384 1
    print say sysread syswrite send recv
a397 2
    once

a417 5
    entergiven leavegiven
    enterwhen leavewhen
    break continue
    smartmatch

d437 1
a437 1
    lock
d444 1
a444 3
    :base_core :base_mem :base_loop :base_orig :base_thread

This list used to contain :base_io prior to Opcode 1.07.
d449 1
a530 8
=item :load

This tag holds opcodes related to loading modules and getting information
about calling environment and args.

    require dofile 
    caller

d545 3
d560 1
d565 1
a565 1
L<ops> -- perl pragma interface to Opcode module.
d567 1
a567 1
L<Safe> -- Opcode and namespace limited execution compartments
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d9 1
a9 1
$VERSION = "1.15";
d313 1
a313 2
    rv2hv helem hslice each values keys exists delete aeach akeys avalues
    boolkeys
d335 1
a335 1
    warn die lineseq nextstate scope enter leave
a558 2

    hintseval -- constant op holding eval hints
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d9 1
a9 1
$VERSION = "1.23";
d13 1
a13 1
use XSLoader;
d31 1
a31 1
XSLoader::load();
d311 1
a311 1
    rv2av aassign aelem aelemfast aelemfast_lex aslice av2arylen
d314 1
a314 1
    boolkeys reach rvalues rkeys
d328 1
a328 1
    ucfirst lcfirst uc lc fc quotemeta trans transr chop schop chomp schomp
d338 1
a338 1
    rv2cv anoncode prototype coreargs
d546 1
a546 1
    caller runcv
@


1.1.1.9
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d9 1
a9 1
$VERSION = "1.25";
d68 1
a68 1
	foreach (@@lines) { s/(?:\t|--).*//  } # delete comments
d291 2
a292 2
    $bool = opset_eq($opset1, $opset2)	true if opsets are logically
					equivalent
d313 2
a314 2
    rv2hv helem hslice each values keys exists delete aeach akeys
    avalues reach rvalues rkeys
d316 3
a318 3
    preinc i_preinc predec i_predec postinc i_postinc
    postdec i_postdec int hex oct abs pow multiply i_multiply
    divide i_divide modulo i_modulo add i_add subtract i_subtract
d328 1
a328 2
    ucfirst lcfirst uc lc fc quotemeta trans transr chop schop
    chomp schomp
d340 1
a340 2
    entersub leavesub leavesublv return method method_named
     -- XXX loops via recursion?
d342 1
a342 2
    leaveeval -- needed for Safe to operate, is safe
		 without entereval
d397 1
a397 1
    padsv padav padhv padcv padany padrange introcv clonecv
d403 1
a403 2
    bless -- could be used to change ownership of objects
	     (reblessing)
d417 1
a417 2
    getppid getpgrp setpgrp getpriority setpriority
    localtime gmtime
d463 3
a465 4
    ftatime ftblk ftchr ftctime ftdir fteexec fteowned
    fteread ftewrite ftfile ftis ftlink ftmtime ftpipe
    ftrexec ftrowned ftrread ftsgid ftsize ftsock ftsuid
    fttty ftzero ftrwrite ftsvtx
d509 1
a509 2
    fcntl -- not strictly filesys related, but possibly as
	     dangerous?
@


1.1.1.10
log
@Import perl-5.20.1
@
text
@d9 1
a9 1
$VERSION = "1.27";
d311 1
a311 2
    rv2av aassign aelem aelemfast aelemfast_lex aslice kvaslice
    av2arylen
d313 2
a314 2
    rv2hv helem hslice kvhslice each values keys exists delete
    aeach akeys avalues reach rvalues rkeys
@


1.1.1.11
log
@Import perl-5.24.2
@
text
@d9 1
a9 1
$VERSION = "1.34";
d315 1
a315 1
    aeach akeys avalues multideref
d321 2
a322 3
    left_shift right_shift bit_and bit_xor bit_or nbit_and
    nbit_xor nbit_or sbit_and sbit_xor sbit_or negate i_negate not
    complement ncomplement scomplement
d340 1
a340 1
    rv2cv anoncode prototype coreargs anonconst
a342 1
    method_super method_redir method_redir_super
d405 1
a405 1
    rv2gv refgen srefgen ref refassign lvref lvrefslice lvavref
@


