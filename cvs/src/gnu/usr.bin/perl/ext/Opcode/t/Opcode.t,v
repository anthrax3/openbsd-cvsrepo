head	1.2;
access;
symbols
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.4
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.3.0.16
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.10
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.12
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.4
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.8
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.3.0.6
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.2
	OPENBSD_5_4_BASE:1.1.1.3
	PERL_5_16_3:1.1.1.3
	OPENBSD_5_3:1.1.1.2.0.10
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.8
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.6
	OPENBSD_5_0:1.1.1.2.0.4
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.13;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2003.12.03.02.43.52;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.03.02.43.52;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.09.24.14.48.49;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.03.25.20.08.45;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2017.08.14.13.46.11;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

$|=1;

BEGIN {
    require Config; import Config;
    if ($Config{'extensions'} !~ /\bOpcode\b/ && $Config{'osname'} ne 'VMS') {
        print "1..0\n";
        exit 0;
    }
}

use strict;
use Test::More;

{
    my @@warnings;

    BEGIN {
	local $SIG{__WARN__} = sub {
	    push @@warnings, "@@_";
	};

	use_ok('Opcode', qw(
	opcodes opdesc opmask verify_opset
	opset opset_to_ops opset_to_hex invert_opset
	opmask_add full_opset empty_opset define_optag
			   ));
    }

    is_deeply(\@@warnings, [], "No warnings loading Opcode");
}

# --- opset_to_ops and opset

my @@empty_l = opset_to_ops(empty_opset);
is_deeply (\@@empty_l, []);

my @@full_l1  = opset_to_ops(full_opset);
is (scalar @@full_l1, scalar opcodes());

{
    local $::TODO = "opcodes in list context not yet implemented";
    my @@full_l2 = eval {opcodes()};
    is($@@, '');
    is_deeply(\@@full_l1, \@@full_l2);
}

@@empty_l = opset_to_ops(opset(':none'));
is_deeply(\@@empty_l, []);

my @@full_l3 = opset_to_ops(opset(':all'));
is_deeply(\@@full_l1, \@@full_l3);

my $s1 = opset(      'padsv');
my $s2 = opset($s1,  'padav');
my $s3 = opset($s2, '!padav');
isnt($s1, $s2);
is($s1, $s3);

# --- define_optag

is(eval { opset(':_tst_') }, undef);
like($@@, qr/Unknown operator tag ":_tst_"/);
define_optag(":_tst_", opset(qw(padsv padav padhv)));
isnt(eval { opset(':_tst_') }, undef);
is($@@, '');

# --- opdesc and opcodes

is(opdesc("gv"), "glob value");
my @@desc = opdesc(':_tst_','stub');
is_deeply(\@@desc, ['private variable', 'private array', 'private hash', 'stub']);
isnt(opcodes(), 0);

# --- invert_opset

$s1 = opset(qw(fileno padsv padav));
my @@o1 = opset_to_ops(invert_opset($s1));
is(scalar @@o1, opcodes-3);

# --- opmask

is(opmask(), empty_opset());
is(length opmask(), int((opcodes()+7)/8));

# --- verify_opset

is(verify_opset($s1), 1);
is(verify_opset(42), 0);

# --- opmask_add

opmask_add(opset(qw(fileno)));	# add to global op_mask
is(eval 'fileno STDOUT', undef);
like($@@, qr/'fileno' trapped/);

# --- check use of bit vector ops on opsets

$s1 = opset('padsv');
$s2 = opset('padav');
$s3 = opset('padsv', 'padav', 'padhv');

# Non-negated
is(($s1 | $s2), opset($s1,$s2));
is(($s2 & $s3), opset($s2));
is(($s2 ^ $s3), opset('padsv','padhv'));

# Negated, e.g., with possible extra bits in last byte beyond last op bit.
# The extra bits mean we can't just say ~mask eq invert_opset(mask).

@@o1 = opset_to_ops(           ~ $s3);
my @@o2 = opset_to_ops(invert_opset $s3);
is_deeply(\@@o1, \@@o2);

# --- test context of undocumented _safe_call_sv (used by Safe.pm)

my %inc = %INC;
my $expect;
sub f {
    %INC = %inc;
    no warnings 'uninitialized';
    is wantarray, $expect,
       sprintf "_safe_call_sv gives %s context",
		qw[void scalar list][$expect + defined $expect]
};
Opcode::_safe_call_sv("main", empty_opset, \&f);
$expect = !1;
$_ = Opcode::_safe_call_sv("main", empty_opset, \&f);
$expect = !0;
() = Opcode::_safe_call_sv("main", empty_opset, \&f);

# --- finally, check some opname assertions

foreach my $opname (@@full_l1) {
    unlike($opname, qr/\W/, "opname $opname has no non-'word' characters");
    unlike($opname, qr/^\d/, "opname $opname does not start with a digit");
}

done_testing();
@


1.1
log
@Initial revision
@
text
@a5 2
    chdir 't' if -d 't';
    @@INC = '../lib';
d13 12
a24 1
use Opcode qw(
d28 2
a29 1
);
d31 2
a32 8
use strict;

my $t = 1;
my $last_test; # initalised at end
print "1..$last_test\n";

my($s1, $s2, $s3);
my(@@o1, @@o2, @@o3);
d37 1
a37 1
print @@empty_l == 0 ?   "ok $t\n" : "not ok $t\n"; $t++;
d40 8
a47 3
print @@full_l1 == opcodes() ? "ok $t\n" : "not ok $t\n"; $t++;
my @@full_l2 = @@full_l1;	# = opcodes();	# XXX to be fixed
print "@@full_l1" eq "@@full_l2" ? "ok $t\n" : "not ok $t\n"; $t++;
d50 1
a50 1
print @@empty_l == 0 ?   "ok $t\n" : "not ok $t\n"; $t++;
d53 1
a53 2
print  @@full_l1  ==  @@full_l3  ? "ok $t\n" : "not ok $t\n"; $t++;
print "@@full_l1" eq "@@full_l3" ? "ok $t\n" : "not ok $t\n"; $t++;
d55 5
a59 6
die $t unless $t == 7;
$s1 = opset(      'padsv');
$s2 = opset($s1,  'padav');
$s3 = opset($s2, '!padav');
print $s1 eq $s2 ? "not ok $t\n" : "ok $t\n"; ++$t;
print $s1 eq $s3 ? "ok $t\n" : "not ok $t\n"; ++$t;
d63 2
a64 1
print eval { opset(':_tst_') } ? "not ok $t\n" : "ok $t\n"; ++$t;
d66 2
a67 1
print eval { opset(':_tst_') } ? "ok $t\n" : "not ok $t\n"; ++$t;
d71 1
a71 2
die $t unless $t == 11;
print opdesc("gv") eq "glob value" ? "ok $t\n" : "not ok $t\n"; $t++;
d73 2
a74 4
print "@@desc" eq "private variable private array private hash stub"
				    ? "ok $t\n" : "not ok $t\n#@@desc\n"; $t++;
print opcodes() ? "ok $t\n" : "not ok $t\n"; $t++;
print "ok $t\n"; ++$t;
d79 2
a80 2
@@o2 = opset_to_ops(invert_opset($s1));
print @@o2 == opcodes-3 ? "ok $t\n" : "not ok $t\n"; $t++;
d84 2
a85 3
die $t unless $t == 16;
print opmask() eq empty_opset() ? "ok $t\n" : "not ok $t\n"; $t++;	# work
print length opmask() == int((opcodes()+7)/8) ? "ok $t\n" : "not ok $t\n"; $t++;
d89 2
a90 1
print verify_opset($s1) && !verify_opset(42) ? "ok $t\n":"not ok $t\n"; $t++;
d95 2
a96 2
print eval 'fileno STDOUT' ? "not ok $t\n" : "ok $t\n";	$t++; # fail
print $@@ =~ /'fileno' trapped/ ? "ok $t\n" : "not ok $t\n# $@@\n"; $t++;
d105 3
a107 3
print (($s1 | $s2) eq opset($s1,$s2) ? "ok $t\n":"not ok $t\n"); $t++;
print (($s2 & $s3) eq opset($s2)     ? "ok $t\n":"not ok $t\n"); $t++;
print (($s2 ^ $s3) eq opset('padsv','padhv') ? "ok $t\n":"not ok $t\n"); $t++;
d113 19
a131 2
@@o2 = opset_to_ops(invert_opset $s3);
print "@@o1" eq "@@o2" ? "ok $t\n":"not ok $t\n"; $t++;
d135 4
a138 1
foreach(@@full_l1) { die "bad opname: $_" if /\W/ or /^\d/ }
d140 1
a140 2
print "ok $last_test\n";
BEGIN { $last_test = 25 }
@


1.1.1.1
log
@perl 5.8.2 from CPAN
@
text
@@


1.1.1.2
log
@Perl 5.12.2 from CPAN
@
text
@d6 2
@


1.1.1.3
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d13 1
a13 12
use strict;
use Test::More;

{
    my @@warnings;

    BEGIN {
	local $SIG{__WARN__} = sub {
	    push @@warnings, "@@_";
	};

	use_ok('Opcode', qw(
d17 1
a17 2
			   ));
    }
d19 8
a26 2
    is_deeply(\@@warnings, [], "No warnings loading Opcode");
}
d31 1
a31 1
is_deeply (\@@empty_l, []);
d34 3
a36 8
is (scalar @@full_l1, scalar opcodes());

{
    local $::TODO = "opcodes in list context not yet implemented";
    my @@full_l2 = eval {opcodes()};
    is($@@, '');
    is_deeply(\@@full_l1, \@@full_l2);
}
d39 1
a39 1
is_deeply(\@@empty_l, []);
d42 2
a43 1
is_deeply(\@@full_l1, \@@full_l3);
d45 6
a50 5
my $s1 = opset(      'padsv');
my $s2 = opset($s1,  'padav');
my $s3 = opset($s2, '!padav');
isnt($s1, $s2);
is($s1, $s3);
d54 1
a54 2
is(eval { opset(':_tst_') }, undef);
like($@@, qr/Unknown operator tag ":_tst_"/);
d56 1
a56 2
isnt(eval { opset(':_tst_') }, undef);
is($@@, '');
d60 2
a61 1
is(opdesc("gv"), "glob value");
d63 4
a66 2
is_deeply(\@@desc, ['private variable', 'private array', 'private hash', 'stub']);
isnt(opcodes(), 0);
d71 2
a72 2
my @@o1 = opset_to_ops(invert_opset($s1));
is(scalar @@o1, opcodes-3);
d76 3
a78 2
is(opmask(), empty_opset());
is(length opmask(), int((opcodes()+7)/8));
d82 1
a82 2
is(verify_opset($s1), 1);
is(verify_opset(42), 0);
d87 2
a88 2
is(eval 'fileno STDOUT', undef);
like($@@, qr/'fileno' trapped/);
d97 3
a99 3
is(($s1 | $s2), opset($s1,$s2));
is(($s2 & $s3), opset($s2));
is(($s2 ^ $s3), opset('padsv','padhv'));
d105 2
a106 2
my @@o2 = opset_to_ops(invert_opset $s3);
is_deeply(\@@o1, \@@o2);
d110 1
a110 4
foreach my $opname (@@full_l1) {
    unlike($opname, qr/\W/, "opname $opname has no non-'word' characters");
    unlike($opname, qr/^\d/, "opname $opname does not start with a digit");
}
d112 2
a113 1
done_testing();
@


1.1.1.4
log
@Import perl-5.24.2
@
text
@a115 17
# --- test context of undocumented _safe_call_sv (used by Safe.pm)

my %inc = %INC;
my $expect;
sub f {
    %INC = %inc;
    no warnings 'uninitialized';
    is wantarray, $expect,
       sprintf "_safe_call_sv gives %s context",
		qw[void scalar list][$expect + defined $expect]
};
Opcode::_safe_call_sv("main", empty_opset, \&f);
$expect = !1;
$_ = Opcode::_safe_call_sv("main", empty_opset, \&f);
$expect = !0;
() = Opcode::_safe_call_sv("main", empty_opset, \&f);

@


