head	1.2;
access;
symbols
	OPENBSD_4_6:1.1.1.4.0.16
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.12
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2009.10.12.18.24.27;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.43;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.04.07.21.13.00;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.48.00;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Merge in perl 5.10.1
@
text
@require 5.004;
use strict;
use Config qw(%Config);
use ExtUtils::MakeMaker;

my @@extra;

unless ($Config{d_u32align}) {
    @@extra = (DEFINE => "-DU32_ALIGNMENT_REQUIRED")
	if !($Config{'byteorder'} eq '1234' ||
	     $Config{'byteorder'} eq '4321');
}
my @@optimize = ();
if ($^O eq 'VMS') {
    if (defined($Config{ccname})) {
        if (grep(/VMS_VAX/, @@INC) && ($Config{ccname} eq 'DEC')) {
            # VAX compiler optimizer even as late as v6.4 gets stuck
            @@optimize = ("OPTIMIZE","/Optimize=(NODISJOINT)");
        }
    }
}

WriteMakefile(
    'NAME'	   => 'Digest::MD5',
    'VERSION_FROM' => 'MD5.pm',
    MAN3PODS    => {},  # Pods will be built by installman.
    @@extra,
    'dist'         => { COMPRESS => 'gzip -9f', SUFFIX => 'gz', },
    @@optimize
);
exit;

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@a6 1
@@extra = (DEFINE => "-DU32_ALIGNMENT_REQUIRED") unless free_u32_alignment();
d8 6
d18 1
a18 1
            push(@@extra, OPTIMIZE => "/Optimize=(NODISJOINT)");
a22 2
push(@@extra, 'INSTALLDIRS'  => 'perl') if $] >= 5.008;

d29 1
d31 1
a32 8


sub free_u32_alignment
{
    return 0 if $Config{d_u32align};
    return 1 if $Config{'byteorder'} eq '1234' || $Config{'byteorder'} eq '4321';
    return 0;
}
@


1.1.1.3
log
@perl 5.8.3 from CPAN
@
text
@d1 1
a1 3
#!perl -w

BEGIN { require 5.004 }
a5 2
my $PERL_CORE = grep $_ eq "PERL_CORE=1", @@ARGV;

a18 1
push(@@extra, 'MAN3PODS' => {}) if $PERL_CORE; # Pods built by installman.
d23 1
a23 3
    'PREREQ_PM'    => { 'File::Spec' => 0,
			'Digest::base' => '1.00',
		      },
d32 2
a33 110
    $|=1;
    if (exists $Config{d_u32align}) {
       print "Perl's config says that U32 access must ";
       print "not " unless $Config{d_u32align};
       print "be aligned.\n";
       return !$Config{d_u32align};
    }
    
    if ($^O eq 'VMS' || $^O eq 'MSWin32') {
       print "Assumes that $^O implies free alignment for U32 access.\n";
       return 1;
    }
    
    if ($^O eq 'hpux' && $Config{osvers} < 11.0) {
       print "Will not test for free alignment on older HP-UX.\n";
       return 0;
    }
    
    print "Testing alignment requirements for U32... ";
    open(ALIGN_TEST, ">u32align.c") or die "$!";
    print ALIGN_TEST <<'EOT'; close(ALIGN_TEST);
/*--------------------------------------------------------------*/
/*  This program allocates a buffer of U8 (char) and then tries */
/*  to access it through a U32 pointer at every offset.  The    */
/*  program  is expected to die with a bus error/seg fault for  */
/*  machines that do not support unaligned integer read/write   */
/*--------------------------------------------------------------*/

#include <stdio.h>
#include "EXTERN.h"
#include "perl.h"

#ifdef printf
 #undef printf
#endif

int main(int argc, char** argv, char** env)
{
#if BYTEORDER == 0x1234 || BYTEORDER == 0x4321
    U8 buf[] = "\0\0\0\1\0\0\0\0";
    U32 *up;
    int i;

    if (sizeof(U32) != 4) {
	printf("sizeof(U32) is not 4, but %d\n", sizeof(U32));
	exit(1);
    }

    fflush(stdout);

    for (i = 0; i < 4; i++) {
	up = (U32*)(buf + i);
	if (! ((*up == 1 << (8*i)) ||   /* big-endian */
	       (*up == 1 << (8*(3-i)))  /* little-endian */
	      )
	   )
	{
	    printf("read failed (%x)\n", *up);
	    exit(2);
	}
    }

    /* write test */
    for (i = 0; i < 4; i++) {
	up = (U32*)(buf + i);
	*up = 0xBeef;
	if (*up != 0xBeef) {
	    printf("write failed (%x)\n", *up);
	    exit(3);
	}
    }

    printf("no restrictions\n");
    exit(0);
#else
    printf("unusual byteorder, playing safe\n");
    exit(1);
#endif
    return 0;
}
/*--------------------------------------------------------------*/
EOT

    my $cc_cmd = "$Config{cc} $Config{ccflags} -I$Config{archlibexp}/CORE";
    my $exe = "u32align$Config{exe_ext}";
    $cc_cmd .= " -o $exe";
    my $rc;
    $rc = system("$cc_cmd $Config{ldflags} u32align.c $Config{libs}");
    if ($rc) {
	print "Can't compile test program.  Will ensure alignment to play safe.\n\n";
	unlink("u32align.c", $exe, "u32align$Config{obj_ext}");
	return 0;
    }

    $rc = system("./$exe");
    unlink("u32align.c", $exe, "u32align$Config{obj_ext}");

    return 1 unless $rc;

    if ($rc > 0x80) {
	$rc >>= 8;
	print "Test program exit status was $rc\n";
    } else {
	if ($rc & 0x80) {
	    $rc &= ~0x80;
	    print "Core dump deleted\n";
	    unlink("core");
	}
	print "signal $rc\n";
    }
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
BEGIN { require 5.006 }
d139 9
a147 6
	(my $cp = $rc) >>= 8;
	print "Test program exit status was $cp\n";
    }
    if ($rc & 0x80) {
	$rc &= ~0x80;
	unlink("core") && print "Core dump deleted\n";
a148 1
    print "signal $rc\n" if $rc && $rc < 0x80;
@


