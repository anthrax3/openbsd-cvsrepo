head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.3.0.26
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.22
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.24
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.20
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.18
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.16
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.14
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.12
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.10
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.28;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.53;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.46.28;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#!./perl -w
#
#  Copyright 2002, Larry Wall.
#  
#  You may redistribute only under the same terms as Perl 5, as specified
#  in the README file that comes with the distribution.
#

sub BEGIN {
    chdir('t') if -d 't';
    if ($ENV{PERL_CORE}){
	@@INC = ('.', '../lib', '../ext/Storable/t');
        require Config;
        if ($Config::Config{'extensions'} !~ /\bStorable\b/) {
            print "1..0 # Skip: Storable was not built\n";
            exit 0;
        }
    } else {
        unless (eval "require Hash::Util") {
            if ($@@ =~ /Can\'t locate Hash\/Util\.pm in \@@INC/) {
                print "1..0 # Skip: No Hash::Util\n";
                exit 0;
            } else {
                die;
            }
        }
	unshift @@INC, 't';
    }
    require 'st-dump.pl';
}


use Storable qw(dclone);
use Hash::Util qw(lock_hash unlock_value);

print "1..16\n";

my %hash = (question => '?', answer => 42, extra => 'junk', undef => undef);
lock_hash %hash;
unlock_value %hash, 'answer';
unlock_value %hash, 'extra';
delete $hash{'extra'};

my $test;

package Restrict_Test;

sub me_second {
  return (undef, $_[0]);
}

package main;

sub testit {
  my $hash = shift;
  my $copy = dclone $hash;

  my @@in_keys = sort keys %$hash;
  my @@out_keys = sort keys %$copy;
  unless (ok ++$test, "@@in_keys" eq "@@out_keys") {
    print "# Failed: keys mis-match after deep clone.\n";
    print "# Original keys: @@in_keys\n";
    print "# Copy's keys: @@out_keys\n";
  }

  # $copy = $hash;	# used in initial debug of the tests

  ok ++$test, Internals::SvREADONLY(%$copy), "cloned hash restricted?";

  ok ++$test, Internals::SvREADONLY($copy->{question}),
    "key 'question' not locked in copy?";

  ok ++$test, !Internals::SvREADONLY($copy->{answer}),
    "key 'answer' not locked in copy?";

  eval { $copy->{extra} = 15 } ;
  unless (ok ++$test, !$@@, "Can assign to reserved key 'extra'?") {
    my $diag = $@@;
    $diag =~ s/\n.*\z//s;
    print "# \$\@@: $diag\n";
  }

  eval { $copy->{nono} = 7 } ;
  ok ++$test, $@@, "Can not assign to invalid key 'nono'?";

  ok ++$test, exists $copy->{undef},
    "key 'undef' exists";

  ok ++$test, !defined $copy->{undef},
    "value for key 'undef' is undefined";
}

for $Storable::canonical (0, 1) {
  print "# \$Storable::canonical = $Storable::canonical\n";
  testit (\%hash);
  my $object = \%hash;
  # bless {}, "Restrict_Test";
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d19 3
a21 8
	if ($] < 5.005) {
	    print "1..0 # Skip: No Hash::Util pre 5.005\n";
	    exit 0;
	    # And doing this seems on 5.004 seems to create bogus warnings about
	    # unitialized variables, or coredumps in Perl_pp_padsv
	} elsif (!eval "require Hash::Util") {
            if ($@@ =~ /Can\'t locate Hash\/Util\.pm in \@@INC/s) {
                print "1..0 # Skip: No Hash::Util:\n";
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@d38 1
a38 1
use Storable qw(dclone freeze thaw);
d41 1
a41 1
print "1..100\n";
a58 5
sub freeze_thaw {
  my $temp = freeze $_[0];
  return thaw $temp;
}

d61 1
a61 2
  my $cloner = shift;
  my $copy = &$cloner($hash);
d99 4
a102 25
  for my $cloner (\&dclone, \&freeze_thaw) {
    print "# \$Storable::canonical = $Storable::canonical\n";
    testit (\%hash, $cloner);
    my $object = \%hash;
    # bless {}, "Restrict_Test";

    my %hash2;
    $hash2{"k$_"} = "v$_" for 0..16;
    lock_hash %hash2;
    for (0..16) {
      unlock_value %hash2, "k$_";
      delete $hash2{"k$_"};
    }
    my $copy = &$cloner(\%hash2);

    for (0..16) {
      my $k = "k$_";
      eval { $copy->{$k} = undef } ;
      unless (ok ++$test, !$@@, "Can assign to reserved key '$k'?") {
	my $diag = $@@;
	$diag =~ s/\n.*\z//s;
	print "# \$\@@: $diag\n";
      }
    }
  }
@


