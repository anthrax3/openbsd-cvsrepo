head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.4
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.3.0.10
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.4
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.6
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.8
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.12;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2010.09.24.14.48.49;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.49;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.08.45;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.11.17.20.53.06;	author afresh1;	state Exp;
branches;
next	1.1.1.4;
commitid	B31cAbBIXiCqnL97;

1.1.1.4
date	2017.08.14.13.46.11;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

BEGIN {
    require Config; import Config;
    if (!$Config{'d_fork'}
       # open2/3 supported on win32
       && $^O ne 'MSWin32' && $^O ne 'NetWare')
    {
	print "1..0\n";
	exit 0;
    }
    # make warnings fatal
    $SIG{__WARN__} = sub { die @@_ };
}

use strict;
use Test::More tests => 45;

use IO::Handle;
use IPC::Open3;
use POSIX ":sys_wait_h";

my $perl = $^X;

sub cmd_line {
	if ($^O eq 'MSWin32' || $^O eq 'NetWare') {
		my $cmd = shift;
		$cmd =~ tr/\r\n//d;
		$cmd =~ s/"/\\"/g;
		return qq/"$cmd"/;
	}
	else {
		return $_[0];
	}
}

my ($pid, $reaped_pid);
STDOUT->autoflush;
STDERR->autoflush;

# basic
$pid = open3 'WRITE', 'READ', 'ERROR', $perl, '-e', cmd_line(<<'EOF');
    $| = 1;
    print scalar <STDIN>;
    print STDERR "hi error\n";
EOF
cmp_ok($pid, '!=', 0);
isnt((print WRITE "hi kid\n"), 0);
like(scalar <READ>, qr/^hi kid\r?\n$/);
like(scalar <ERROR>, qr/^hi error\r?\n$/);
is(close(WRITE), 1) or diag($!);
is(close(READ), 1) or diag($!);
is(close(ERROR), 1) or diag($!);
$reaped_pid = waitpid $pid, 0;
is($reaped_pid, $pid);
is($?, 0);

my $desc = "read and error together, both named";
$pid = open3 'WRITE', 'READ', 'READ', $perl, '-e', cmd_line(<<'EOF');
    $| = 1;
    print scalar <STDIN>;
    print STDERR scalar <STDIN>;
EOF
print WRITE "$desc\n";
like(scalar <READ>, qr/\A$desc\r?\n\z/);
print WRITE "$desc [again]\n";
like(scalar <READ>, qr/\A$desc \[again\]\r?\n\z/);
waitpid $pid, 0;

$desc = "read and error together, error empty";
$pid = open3 'WRITE', 'READ', '', $perl, '-e', cmd_line(<<'EOF');
    $| = 1;
    print scalar <STDIN>;
    print STDERR scalar <STDIN>;
EOF
print WRITE "$desc\n";
like(scalar <READ>, qr/\A$desc\r?\n\z/);
print WRITE "$desc [again]\n";
like(scalar <READ>, qr/\A$desc \[again\]\r?\n\z/);
waitpid $pid, 0;

is(pipe(PIPE_READ, PIPE_WRITE), 1);
$pid = open3 '<&PIPE_READ', 'READ', '',
		    $perl, '-e', cmd_line('print scalar <STDIN>');
close PIPE_READ;
print PIPE_WRITE "dup writer\n";
close PIPE_WRITE;
like(scalar <READ>, qr/\Adup writer\r?\n\z/);
waitpid $pid, 0;

my $TB = Test::Builder->new();
my $test = $TB->current_test;
# dup reader
$pid = open3 'WRITE', '>&STDOUT', 'ERROR',
		    $perl, '-e', cmd_line('print scalar <STDIN>');
++$test;
print WRITE "ok $test\n";
waitpid $pid, 0;

{
    package YAAH;
    $pid = IPC::Open3::open3('QWACK_WAAK_WAAK', '>&STDOUT', 'ERROR',
			     $perl, '-e', main::cmd_line('print scalar <STDIN>'));
    ++$test;
    no warnings 'once';
    print QWACK_WAAK_WAAK "ok $test # filenames qualified to their package\n";
    waitpid $pid, 0;
}

# dup error:  This particular case, duping stderr onto the existing
# stdout but putting stdout somewhere else, is a good case because it
# used not to work.
$pid = open3 'WRITE', 'READ', '>&STDOUT',
		    $perl, '-e', cmd_line('print STDERR scalar <STDIN>');
++$test;
print WRITE "ok $test\n";
waitpid $pid, 0;

foreach (['>&STDOUT', 'both named'],
	 ['', 'error empty'],
	) {
    my ($err, $desc) = @@$_;
    $pid = open3 'WRITE', '>&STDOUT', $err, $perl, '-e', cmd_line(<<'EOF');
    $| = 1;
    print STDOUT scalar <STDIN>;
    print STDERR scalar <STDIN>;
EOF
    printf WRITE "ok %d # dup reader and error together, $desc\n", ++$test
	for 0, 1;
    waitpid $pid, 0;
}

# command line in single parameter variant of open3
# for understanding of Config{'sh'} test see exec description in camel book
my $cmd = 'print(scalar(<STDIN>))';
$cmd = $Config{'sh'} =~ /sh/ ? "'$cmd'" : cmd_line($cmd);
$pid = eval { open3 'WRITE', '>&STDOUT', 'ERROR', "$perl -e " . $cmd; };
if ($@@) {
	print "error $@@\n";
	++$test;
	print WRITE "not ok $test\n";
}
else {
	++$test;
	print WRITE "ok $test\n";
	waitpid $pid, 0;
}
$TB->current_test($test);

# RT 72016
{
    local $::TODO = "$^O returns a pid and doesn't throw an exception"
	if $^O eq 'MSWin32';
    $pid = eval { open3 'WRITE', 'READ', 'ERROR', '/non/existent/program'; };
    isnt($@@, '',
	 'open3 of a non existent program fails with an exception in the parent')
	or do {waitpid $pid, 0};
    SKIP: {
	skip 'open3 returned, our responsibility to reap', 1 unless $@@;
	is(waitpid(-1, WNOHANG), -1, 'failed exec child is reaped');
    }
}

$pid = eval { open3 'WRITE', '', 'ERROR', '/non/existent/program'; };
like($@@, qr/^open3: Modification of a read-only value attempted at /,
     'open3 faults read-only parameters correctly') or do {waitpid $pid, 0};

package NoFetch;

my $fetchcount = 1;

sub TIESCALAR {
  my $class = shift;
  my $instance = shift || undef;
  return bless \$instance => $class;
}

sub FETCH {
    my $cmd; #dont let "@@args = @@DB::args;" in Carp::caller_info fire this die
    #fetchcount may need to be increased to 2 if this code is being stepped with
    #a perl debugger
    if($fetchcount == 1 && (caller(1))[3] ne 'Carp::caller_info') {
	#Carp croak reports the errors as being in IPC-Open3.t, so it is
	#unacceptable for testing where the FETCH failure occured, we dont want
	#it failing in a $foo = $_[0]; #later# system($foo), where the failure
	#is supposed to be triggered in the inner most syscall, aka system()
	my ($package, $filename, $line, $subroutine) = caller(2);

	die("FETCH not allowed in ".((caller(1))[3])." in ".((caller(2))[3])."\n");
    } else {
	$fetchcount++;
	return tie($cmd, 'NoFetch');
    }
}

package main;

{
    my $cmd;
    tie($cmd, 'NoFetch');

    $pid = eval { open3 'WRITE', 'READ', 'ERROR', $cmd; };
    like($@@, qr/^(?:open3: IO::Pipe: Can't spawn-NOWAIT: FETCH not allowed in \(eval\) (?x:
         )in IPC::Open3::spawn_with_handles|FETCH not allowed in \(eval\) in IPC::Open3::_open3)/,
     'dieing inside Tied arg propagates correctly') or do {waitpid $pid, 0};
}

foreach my $handle (qw (DUMMY STDIN STDOUT STDERR)) {
    local $::{$handle};
    my $out = IO::Handle->new();
    my $pid = eval {
	local $SIG{__WARN__} = sub {
	    open my $fh, '>/dev/tty';
	    return if "@@_" =~ m!^Use of uninitialized value \$fd.*IO/Handle\.pm!;
	    print $fh "@@_";
	    die @@_
	};
	open3 undef, $out, undef, $perl, '-le', "print q _# ${handle}_"
    };
    is($@@, '', "No errors with localised $handle");
    cmp_ok($pid, '>', 0, "Got a pid with localised $handle");
    if ($handle eq 'STDOUT') {
	is(<$out>, undef, "Expected no output with localised $handle");
    } else {
	like(<$out>, qr/\A# $handle\r?\n\z/,
	     "Expected output with localised $handle");
    }
    waitpid $pid, 0;
}

# Test that tied STDIN, STDOUT, and STDERR do not cause open3 any discomfort.
# In particular, tied STDERR used to be able to prevent open3 from working
# correctly.  RT #119843.
SKIP: {
    if (&IPC::Open3::DO_SPAWN) {
      skip "Calling open3 with tied filehandles does not work here", 6
    }

    {	# This just throws things out
	package My::Tied::FH;
	sub TIEHANDLE { bless \my $self }
	sub PRINT {}
	# Note the absence of OPEN and FILENO
    }
    my $message = "japh\n";
    foreach my $handle (*STDIN, *STDOUT, *STDERR) {
	tie $handle, 'My::Tied::FH';
	my ($in, $out);
	my $pid = eval {
	    open3 $in, $out, undef, $perl, '-ne', 'print';
	};
	is($@@, '', "no errors calling open3 with tied $handle");
	print $in $message;
	close $in;
	my $japh = <$out>;
	waitpid $pid, 0;
	is($japh, $message, "read input correctly");
	untie $handle;
    }
}
@


1.1
log
@Initial revision
@
text
@d6 2
a7 2
       # open2/3 supported on win32 (but not Borland due to CRT bugs)
       && (($^O ne 'MSWin32' && $^O ne 'NetWare') || $Config{'cc'} =~ /^bcc/i))
d17 2
d21 1
a21 1
#require 'open3.pl'; use subs 'open3';
a24 11
sub ok {
    my ($n, $result, $info) = @@_;
    if ($result) {
	print "ok $n\n";
    }
    else {
	print "not ok $n\n";
	print "# $info\n" if $info;
    }
}

a40 2
print "1..22\n";

d42 1
a42 1
ok 1, $pid = open3 'WRITE', 'READ', 'ERROR', $perl, '-e', cmd_line(<<'EOF');
d47 7
a53 6
ok 2, print WRITE "hi kid\n";
ok 3, <READ> =~ /^hi kid\r?\n$/;
ok 4, <ERROR> =~ /^hi error\r?\n$/;
ok 5, close(WRITE), $!;
ok 6, close(READ), $!;
ok 7, close(ERROR), $!;
d55 2
a56 2
ok 8, $reaped_pid == $pid, $reaped_pid;
ok 9, $? == 0, $?;
d58 1
a58 1
# read and error together, both named
d64 4
a67 4
print WRITE "ok 10\n";
print scalar <READ>;
print WRITE "ok 11\n";
print scalar <READ>;
d70 1
a70 1
# read and error together, error empty
d76 4
a79 4
print WRITE "ok 12\n";
print scalar <READ>;
print WRITE "ok 13\n";
print scalar <READ>;
d82 1
a82 2
# dup writer
ok 14, pipe PIPE_READ, PIPE_WRITE;
d86 1
a86 1
print PIPE_WRITE "ok 15\n";
d88 1
a88 1
print scalar <READ>;
d91 2
d96 2
a97 1
print WRITE "ok 16\n";
d100 10
d115 2
a116 1
print WRITE "ok 17\n";
d119 5
a123 2
# dup reader and error together, both named
$pid = open3 'WRITE', '>&STDOUT', '>&STDOUT', $perl, '-e', cmd_line(<<'EOF');
d128 4
a131 13
print WRITE "ok 18\n";
print WRITE "ok 19\n";
waitpid $pid, 0;

# dup reader and error together, error empty
$pid = open3 'WRITE', '>&STDOUT', '', $perl, '-e', cmd_line(<<'EOF');
    $| = 1;
    print STDOUT scalar <STDIN>;
    print STDERR scalar <STDIN>;
EOF
print WRITE "ok 20\n";
print WRITE "ok 21\n";
waitpid $pid, 0;
d137 1
a137 1
eval{$pid = open3 'WRITE', '>&STDOUT', 'ERROR', "$perl -e " . $cmd; };
d140 2
a141 1
	print "not ok 22\n";
d144 112
a255 1
	print WRITE "ok 22\n";
d257 3
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d6 2
a7 2
       # open2/3 supported on win32
       && $^O ne 'MSWin32' && $^O ne 'NetWare')
a16 2
use Test::More tests => 37;

d19 1
d23 11
d50 2
d53 1
a53 1
$pid = open3 'WRITE', 'READ', 'ERROR', $perl, '-e', cmd_line(<<'EOF');
d58 6
a63 7
cmp_ok($pid, '!=', 0);
isnt((print WRITE "hi kid\n"), 0);
like(scalar <READ>, qr/^hi kid\r?\n$/);
like(scalar <ERROR>, qr/^hi error\r?\n$/);
is(close(WRITE), 1) or diag($!);
is(close(READ), 1) or diag($!);
is(close(ERROR), 1) or diag($!);
d65 2
a66 2
is($reaped_pid, $pid);
is($?, 0);
d68 1
a68 1
my $desc = "read and error together, both named";
d74 4
a77 4
print WRITE "$desc\n";
like(scalar <READ>, qr/\A$desc\r?\n\z/);
print WRITE "$desc [again]\n";
like(scalar <READ>, qr/\A$desc \[again\]\r?\n\z/);
d80 1
a80 1
$desc = "read and error together, error empty";
d86 4
a89 4
print WRITE "$desc\n";
like(scalar <READ>, qr/\A$desc\r?\n\z/);
print WRITE "$desc [again]\n";
like(scalar <READ>, qr/\A$desc \[again\]\r?\n\z/);
d92 2
a93 1
is(pipe(PIPE_READ, PIPE_WRITE), 1);
d97 1
a97 1
print PIPE_WRITE "dup writer\n";
d99 1
a99 1
like(scalar <READ>, qr/\Adup writer\r?\n\z/);
a101 2
my $TB = Test::Builder->new();
my $test = $TB->current_test;
d105 1
a105 2
++$test;
print WRITE "ok $test\n";
a107 10
{
    package YAAH;
    $pid = IPC::Open3::open3('QWACK_WAAK_WAAK', '>&STDOUT', 'ERROR',
			     $perl, '-e', main::cmd_line('print scalar <STDIN>'));
    ++$test;
    no warnings 'once';
    print QWACK_WAAK_WAAK "ok $test # filenames qualified to their package\n";
    waitpid $pid, 0;
}

d113 1
a113 2
++$test;
print WRITE "ok $test\n";
d116 2
a117 5
foreach (['>&STDOUT', 'both named'],
	 ['', 'error empty'],
	) {
    my ($err, $desc) = @@$_;
    $pid = open3 'WRITE', '>&STDOUT', $err, $perl, '-e', cmd_line(<<'EOF');
d122 13
a134 4
    printf WRITE "ok %d # dup reader and error together, $desc\n", ++$test
	for 0, 1;
    waitpid $pid, 0;
}
d140 1
a140 1
$pid = eval { open3 'WRITE', '>&STDOUT', 'ERROR', "$perl -e " . $cmd; };
d143 1
a143 2
	++$test;
	print WRITE "not ok $test\n";
d146 1
a146 2
	++$test;
	print WRITE "ok $test\n";
a147 38
}
$TB->current_test($test);

# RT 72016
{
    local $::TODO = "$^O returns a pid and doesn't throw an exception"
	if $^O eq 'MSWin32';
    $pid = eval { open3 'WRITE', 'READ', 'ERROR', '/non/existent/program'; };
    isnt($@@, '',
	 'open3 of a non existent program fails with an exception in the parent')
	or do {waitpid $pid, 0};
}

$pid = eval { open3 'WRITE', '', 'ERROR', '/non/existent/program'; };
like($@@, qr/^open3: Modification of a read-only value attempted at /,
     'open3 faults read-only parameters correctly') or do {waitpid $pid, 0};

foreach my $handle (qw (DUMMY STDIN STDOUT STDERR)) {
    local $::{$handle};
    my $out = IO::Handle->new();
    my $pid = eval {
	local $SIG{__WARN__} = sub {
	    open my $fh, '>/dev/tty';
	    return if "@@_" =~ m!^Use of uninitialized value \$fd.*IO/Handle\.pm!;
	    print $fh "@@_";
	    die @@_
	};
	open3 undef, $out, undef, $perl, '-le', "print q _# ${handle}_"
    };
    is($@@, '', "No errors with localised $handle");
    cmp_ok($pid, '>', 0, "Got a pid with localised $handle");
    if ($handle eq 'STDOUT') {
	is(<$out>, undef, "Expected no output with localised $handle");
    } else {
	like(<$out>, qr/\A# $handle\r?\n\z/,
	     "Expected output with localised $handle");
    }
    waitpid $pid, 0;
@


1.1.1.3
log
@Import perl-5.20.1
@
text
@d17 1
a17 1
use Test::More tests => 38;
a20 1
use POSIX ":sys_wait_h";
a156 4
    SKIP: {
	skip 'open3 returned, our responsibility to reap', 1 unless $@@;
	is(waitpid(-1, WNOHANG), -1, 'failed exec child is reaped');
    }
@


1.1.1.4
log
@Import perl-5.24.2
@
text
@d17 1
a17 1
use Test::More tests => 45;
a167 40
package NoFetch;

my $fetchcount = 1;

sub TIESCALAR {
  my $class = shift;
  my $instance = shift || undef;
  return bless \$instance => $class;
}

sub FETCH {
    my $cmd; #dont let "@@args = @@DB::args;" in Carp::caller_info fire this die
    #fetchcount may need to be increased to 2 if this code is being stepped with
    #a perl debugger
    if($fetchcount == 1 && (caller(1))[3] ne 'Carp::caller_info') {
	#Carp croak reports the errors as being in IPC-Open3.t, so it is
	#unacceptable for testing where the FETCH failure occured, we dont want
	#it failing in a $foo = $_[0]; #later# system($foo), where the failure
	#is supposed to be triggered in the inner most syscall, aka system()
	my ($package, $filename, $line, $subroutine) = caller(2);

	die("FETCH not allowed in ".((caller(1))[3])." in ".((caller(2))[3])."\n");
    } else {
	$fetchcount++;
	return tie($cmd, 'NoFetch');
    }
}

package main;

{
    my $cmd;
    tie($cmd, 'NoFetch');

    $pid = eval { open3 'WRITE', 'READ', 'ERROR', $cmd; };
    like($@@, qr/^(?:open3: IO::Pipe: Can't spawn-NOWAIT: FETCH not allowed in \(eval\) (?x:
         )in IPC::Open3::spawn_with_handles|FETCH not allowed in \(eval\) in IPC::Open3::_open3)/,
     'dieing inside Tied arg propagates correctly') or do {waitpid $pid, 0};
}

a188 31
}

# Test that tied STDIN, STDOUT, and STDERR do not cause open3 any discomfort.
# In particular, tied STDERR used to be able to prevent open3 from working
# correctly.  RT #119843.
SKIP: {
    if (&IPC::Open3::DO_SPAWN) {
      skip "Calling open3 with tied filehandles does not work here", 6
    }

    {	# This just throws things out
	package My::Tied::FH;
	sub TIEHANDLE { bless \my $self }
	sub PRINT {}
	# Note the absence of OPEN and FILENO
    }
    my $message = "japh\n";
    foreach my $handle (*STDIN, *STDOUT, *STDERR) {
	tie $handle, 'My::Tied::FH';
	my ($in, $out);
	my $pid = eval {
	    open3 $in, $out, undef, $perl, '-ne', 'print';
	};
	is($@@, '', "no errors calling open3 with tied $handle");
	print $in $message;
	close $in;
	my $japh = <$out>;
	waitpid $pid, 0;
	is($japh, $message, "read input correctly");
	untie $handle;
    }
@


