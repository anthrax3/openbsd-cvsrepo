head	1.6;
access;
symbols
	OPENBSD_6_2_BASE:1.6
	PERL_5_24_2:1.1.1.5
	OPENBSD_6_1:1.6.0.4
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.5.0.10
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.4
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.2.0.10
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.8
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.6
date	2017.02.05.00.32.12;	author afresh1;	state Exp;
branches;
next	1.5;
commitid	cxJ08BvJA9Pt2PTM;

1.5
date	2014.11.17.20.57.05;	author afresh1;	state Exp;
branches;
next	1.4;
commitid	QP75iYx42Uo7mMxO;

1.4
date	2014.03.24.15.05.27;	author afresh1;	state Exp;
branches;
next	1.3;

1.3
date	2013.03.25.20.40.54;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2010.09.24.15.06.57;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.24.14.48.49;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.49;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.08.45;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.53.06;	author afresh1;	state Exp;
branches;
next	1.1.1.5;
commitid	B31cAbBIXiCqnL97;

1.1.1.5
date	2017.08.14.13.46.11;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.6
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package IPC::Open3;

use strict;
no strict 'refs'; # because users pass me bareword filehandles
our ($VERSION, @@ISA, @@EXPORT);

require Exporter;

use Carp;
use Symbol qw(gensym qualify);

$VERSION	= '1.20';
@@ISA		= qw(Exporter);
@@EXPORT		= qw(open3);

=head1 NAME

IPC::Open3 - open a process for reading, writing, and error handling using open3()

=head1 SYNOPSIS

    $pid = open3(\*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR,
		    'some cmd and args', 'optarg', ...);

    my($wtr, $rdr, $err);
    use Symbol 'gensym'; $err = gensym;
    $pid = open3($wtr, $rdr, $err,
		    'some cmd and args', 'optarg', ...);

    waitpid( $pid, 0 );
    my $child_exit_status = $? >> 8;

=head1 DESCRIPTION

Extremely similar to open2(), open3() spawns the given $cmd and
connects CHLD_OUT for reading from the child, CHLD_IN for writing to
the child, and CHLD_ERR for errors.  If CHLD_ERR is false, or the
same file descriptor as CHLD_OUT, then STDOUT and STDERR of the child
are on the same filehandle (this means that an autovivified lexical
cannot be used for the STDERR filehandle, see SYNOPSIS).  The CHLD_IN
will have autoflush turned on.

If CHLD_IN begins with C<< <& >>, then CHLD_IN will be closed in the
parent, and the child will read from it directly.  If CHLD_OUT or
CHLD_ERR begins with C<< >& >>, then the child will send output
directly to that filehandle.  In both cases, there will be a dup(2)
instead of a pipe(2) made.

If either reader or writer is the null string, this will be replaced
by an autogenerated filehandle.  If so, you must pass a valid lvalue
in the parameter slot so it can be overwritten in the caller, or
an exception will be raised.

The filehandles may also be integers, in which case they are understood
as file descriptors.

open3() returns the process ID of the child process.  It doesn't return on
failure: it just raises an exception matching C</^open3:/>.  However,
C<exec> failures in the child (such as no such file or permission denied),
are just reported to CHLD_ERR under Windows and OS/2, as it is not possible
to trap them.

If the child process dies for any reason, the next write to CHLD_IN is
likely to generate a SIGPIPE in the parent, which is fatal by default.
So you may wish to handle this signal.

Note if you specify C<-> as the command, in an analogous fashion to
C<open(FOO, "-|")> the child process will just be the forked Perl
process rather than an external command.  This feature isn't yet
supported on Win32 platforms.

open3() does not wait for and reap the child process after it exits.
Except for short programs where it's acceptable to let the operating system
take care of this, you need to do this yourself.  This is normally as
simple as calling C<waitpid $pid, 0> when you're done with the process.
Failing to do this can result in an accumulation of defunct or "zombie"
processes.  See L<perlfunc/waitpid> for more information.

If you try to read from the child's stdout writer and their stderr
writer, you'll have problems with blocking, which means you'll want
to use select() or the IO::Select, which means you'd best use
sysread() instead of readline() for normal stuff.

This is very dangerous, as you may block forever.  It assumes it's
going to talk to something like B<bc>, both writing to it and reading
from it.  This is presumably safe because you "know" that commands
like B<bc> will read a line at a time and output a line at a time.
Programs like B<sort> that read their entire input stream first,
however, are quite apt to cause deadlock.

The big problem with this approach is that if you don't have control
over source code being run in the child process, you can't control
what it does with pipe buffering.  Thus you can't just open a pipe to
C<cat -v> and continually read and write a line from it.

=head1 See Also

=over 4

=item L<IPC::Open2>

Like Open3 but without STDERR capture.

=item L<IPC::Run>

This is a CPAN module that has better error handling and more facilities
than Open3.

=back

=head1 WARNING

The order of arguments differs from that of open2().

=cut

# &open3: Marc Horowitz <marc@@mit.edu>
# derived mostly from &open2 by tom christiansen, <tchrist@@convex.com>
# fixed for 5.001 by Ulrich Kunitz <kunitz@@mai-koeln.com>
# ported to Win32 by Ron Schmidt, Merrill Lynch almost ended my career
# fixed for autovivving FHs, tchrist again
# allow fd numbers to be used, by Frank Tobin
# allow '-' as command (c.f. open "-|"), by Adam Spiers <perl@@adamspiers.org>
#
# usage: $pid = open3('wtr', 'rdr', 'err' 'some cmd and args', 'optarg', ...);
#
# spawn the given $cmd and connect rdr for
# reading, wtr for writing, and err for errors.
# if err is '', or the same as rdr, then stdout and
# stderr of the child are on the same fh.  returns pid
# of child (or dies on failure).


# if wtr begins with '<&', then wtr will be closed in the parent, and
# the child will read from it directly.  if rdr or err begins with
# '>&', then the child will send output directly to that fd.  In both
# cases, there will be a dup() instead of a pipe() made.


# WARNING: this is dangerous, as you may block forever
# unless you are very careful.
#
# $wtr is left unbuffered.
#
# abort program if
#   rdr or wtr are null
#   a system call fails

our $Me = 'open3 (bug)';	# you should never see this, it's always localized

# Fatal.pm needs to be fixed WRT prototypes.

sub xpipe {
    pipe $_[0], $_[1] or croak "$Me: pipe($_[0], $_[1]) failed: $!";
}

# I tried using a * prototype character for the filehandle but it still
# disallows a bareword while compiling under strict subs.

sub xopen {
    open $_[0], $_[1], @@_[2..$#_] and return;
    local $" = ', ';
    carp "$Me: open(@@_) failed: $!";
}

sub xclose {
    $_[0] =~ /\A=?(\d+)\z/
	? do { my $fh; open($fh, $_[1] . '&=' . $1) and close($fh); }
	: close $_[0]
	or croak "$Me: close($_[0]) failed: $!";
}

sub xfileno {
    return $1 if $_[0] =~ /\A=?(\d+)\z/;  # deal with fh just being an fd
    return fileno $_[0];
}

use constant FORCE_DEBUG_SPAWN => 0;
use constant DO_SPAWN => $^O eq 'os2' || $^O eq 'MSWin32' || FORCE_DEBUG_SPAWN;

sub _open3 {
    local $Me = shift;

    # simulate autovivification of filehandles because
    # it's too ugly to use @@_ throughout to make perl do it for us
    # tchrist 5-Mar-00

    # Historically, open3(undef...) has silently worked, so keep
    # it working.
    splice @@_, 0, 1, undef if \$_[0] == \undef;
    splice @@_, 1, 1, undef if \$_[1] == \undef;
    unless (eval  {
	$_[0] = gensym unless defined $_[0] && length $_[0];
	$_[1] = gensym unless defined $_[1] && length $_[1];
	1; })
    {
	# must strip crud for croak to add back, or looks ugly
	$@@ =~ s/(?<=value attempted) at .*//s;
	croak "$Me: $@@";
    }

    my @@handles = ({ mode => '<', handle => \*STDIN },
		   { mode => '>', handle => \*STDOUT },
		   { mode => '>', handle => \*STDERR },
		  );

    foreach (@@handles) {
	$_->{parent} = shift;
	$_->{open_as} = gensym;
    }

    if (@@_ > 1 and $_[0] eq '-') {
	croak "Arguments don't make sense when the command is '-'"
    }

    $handles[2]{parent} ||= $handles[1]{parent};
    $handles[2]{dup_of_out} = $handles[1]{parent} eq $handles[2]{parent};

    my $package;
    foreach (@@handles) {
	$_->{dup} = ($_->{parent} =~ s/^[<>]&//);

	if ($_->{parent} !~ /\A=?(\d+)\z/) {
	    # force unqualified filehandles into caller's package
	    $package //= caller 1;
	    $_->{parent} = qualify $_->{parent}, $package;
	}

	next if $_->{dup} or $_->{dup_of_out};
	if ($_->{mode} eq '<') {
	    xpipe $_->{open_as}, $_->{parent};
	} else {
	    xpipe $_->{parent}, $_->{open_as};
	}
    }

    my $kidpid;
    if (!DO_SPAWN) {
	# Used to communicate exec failures.
	xpipe my $stat_r, my $stat_w;

	$kidpid = fork;
	croak "$Me: fork failed: $!" unless defined $kidpid;
	if ($kidpid == 0) {  # Kid
	    eval {
		# A tie in the parent should not be allowed to cause problems.
		untie *STDIN;
		untie *STDOUT;
		untie *STDERR;

		close $stat_r;
		require Fcntl;
		my $flags = fcntl $stat_w, &Fcntl::F_GETFD, 0;
		croak "$Me: fcntl failed: $!" unless $flags;
		fcntl $stat_w, &Fcntl::F_SETFD, $flags|&Fcntl::FD_CLOEXEC
		    or croak "$Me: fcntl failed: $!";

		# If she wants to dup the kid's stderr onto her stdout I need to
		# save a copy of her stdout before I put something else there.
		if (!$handles[2]{dup_of_out} && $handles[2]{dup}
			&& xfileno($handles[2]{parent}) == fileno \*STDOUT) {
		    my $tmp = gensym;
		    xopen($tmp, '>&', $handles[2]{parent});
		    $handles[2]{parent} = $tmp;
		}

		foreach (@@handles) {
		    if ($_->{dup_of_out}) {
			xopen \*STDERR, ">&STDOUT"
			    if defined fileno STDERR && fileno STDERR != fileno STDOUT;
		    } elsif ($_->{dup}) {
			xopen $_->{handle}, $_->{mode} . '&', $_->{parent}
			    if fileno $_->{handle} != xfileno($_->{parent});
		    } else {
			xclose $_->{parent}, $_->{mode};
			xopen $_->{handle}, $_->{mode} . '&=',
			    fileno $_->{open_as};
		    }
		}
		return 1 if ($_[0] eq '-');
		exec @@_ or do {
		    local($")=(" ");
		    croak "$Me: exec of @@_ failed: $!";
		};
	    } and do {
                close $stat_w;
                return 0;
            };

	    my $bang = 0+$!;
	    my $err = $@@;
	    utf8::encode $err if $] >= 5.008;
	    print $stat_w pack('IIa*', $bang, length($err), $err);
	    close $stat_w;

	    eval { require POSIX; POSIX::_exit(255); };
	    exit 255;
	}
	else {  # Parent
	    close $stat_w;
	    my $to_read = length(pack('I', 0)) * 2;
	    my $bytes_read = read($stat_r, my $buf = '', $to_read);
	    if ($bytes_read) {
		(my $bang, $to_read) = unpack('II', $buf);
		read($stat_r, my $err = '', $to_read);
		waitpid $kidpid, 0; # Reap child which should have exited
		if ($err) {
		    utf8::decode $err if $] >= 5.008;
		} else {
		    $err = "$Me: " . ($! = $bang);
		}
		$! = $bang;
		die($err);
	    }
	}
    }
    else {  # DO_SPAWN
	# All the bookkeeping of coincidence between handles is
	# handled in spawn_with_handles.

	my @@close;

	foreach (@@handles) {
	    if ($_->{dup_of_out}) {
		$_->{open_as} = $handles[1]{open_as};
	    } elsif ($_->{dup}) {
		$_->{open_as} = $_->{parent} =~ /\A[0-9]+\z/
		    ? $_->{parent} : \*{$_->{parent}};
		push @@close, $_->{open_as};
	    } else {
		push @@close, \*{$_->{parent}}, $_->{open_as};
	    }
	}
	require IO::Pipe;
	$kidpid = eval {
	    spawn_with_handles(\@@handles, \@@close, @@_);
	};
	die "$Me: $@@" if $@@;
    }

    foreach (@@handles) {
	next if $_->{dup} or $_->{dup_of_out};
	xclose $_->{open_as}, $_->{mode};
    }

    # If the write handle is a dup give it away entirely, close my copy
    # of it.
    xclose $handles[0]{parent}, $handles[0]{mode} if $handles[0]{dup};

    select((select($handles[0]{parent}), $| = 1)[0]); # unbuffer pipe
    $kidpid;
}

sub open3 {
    if (@@_ < 4) {
	local $" = ', ';
	croak "open3(@@_): not enough arguments";
    }
    return _open3 'open3', @@_
}

sub spawn_with_handles {
    my $fds = shift;		# Fields: handle, mode, open_as
    my $close_in_child = shift;
    my ($fd, %saved, @@errs);

    foreach $fd (@@$fds) {
	$fd->{tmp_copy} = IO::Handle->new_from_fd($fd->{handle}, $fd->{mode});
	$saved{fileno $fd->{handle}} = $fd->{tmp_copy} if $fd->{tmp_copy};
    }
    foreach $fd (@@$fds) {
	bless $fd->{handle}, 'IO::Handle'
	    unless eval { $fd->{handle}->isa('IO::Handle') } ;
	# If some of handles to redirect-to coincide with handles to
	# redirect, we need to use saved variants:
    my $open_as = $fd->{open_as};
    my $fileno = fileno($open_as);
    $fd->{handle}->fdopen(defined($fileno)
                  ? $saved{$fileno} || $open_as
                  : $open_as,
                  $fd->{mode});
    }
    unless ($^O eq 'MSWin32') {
	require Fcntl;
	# Stderr may be redirected below, so we save the err text:
	foreach $fd (@@$close_in_child) {
	    next unless fileno $fd;
	    fcntl($fd, Fcntl::F_SETFD(), 1) or push @@errs, "fcntl $fd: $!"
		unless $saved{fileno $fd}; # Do not close what we redirect!
	}
    }

    my $pid;
    unless (@@errs) {
	if (FORCE_DEBUG_SPAWN) {
	    pipe my $r, my $w or die "Pipe failed: $!";
	    $pid = fork;
	    die "Fork failed: $!" unless defined $pid;
	    if (!$pid) {
		{ no warnings; exec @@_ }
		print $w 0 + $!;
		close $w;
		require POSIX;
		POSIX::_exit(255);
	    }
	    close $w;
	    my $bad = <$r>;
	    if (defined $bad) {
		$! = $bad;
		undef $pid;
	    }
	} else {
	    $pid = eval { system 1, @@_ }; # 1 == P_NOWAIT
	}
	if($@@) {
	    push @@errs, "IO::Pipe: Can't spawn-NOWAIT: $@@";
	} elsif(!$pid || $pid < 0) {
	    push @@errs, "IO::Pipe: Can't spawn-NOWAIT: $!";
	}
    }

    # Do this in reverse, so that STDERR is restored first:
    foreach $fd (reverse @@$fds) {
	$fd->{handle}->fdopen($fd->{tmp_copy}, $fd->{mode});
    }
    foreach (values %saved) {
	$_->close or croak "Can't close: $!";
    }
    croak join "\n", @@errs if @@errs;
    return $pid;
}

1; # so require is happy
@


1.5
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d12 1
a12 1
$VERSION	= '1.16';
d249 1
d283 1
a283 1
		    croak "$Me: exec of @@_ failed";
d365 1
a365 1
    my ($fd, $pid, @@saved_fh, $saved, %saved, @@errs);
d376 6
a381 4
	$fd->{handle}->fdopen(defined fileno $fd->{open_as}
			      ? $saved{fileno $fd->{open_as}} || $fd->{open_as}
			      : $fd->{open_as},
			      $fd->{mode});
d393 1
d415 5
a419 1
	push @@errs, "IO::Pipe: Can't spawn-NOWAIT: $!" if !$pid || $pid < 0;
@


1.4
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d12 1
a12 1
$VERSION	= '1.13';
d60 2
a61 1
are just reported to CHLD_ERR, as it is not possible to trap them.
d102 1
a102 1
Like Open3 but without STDERR catpure.
d188 4
d305 1
@


1.3
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d12 1
a12 1
$VERSION	= '1.12';
d166 3
a168 1
    $_[0] =~ /\A=?(\d+)\z/ ? eval { require POSIX; POSIX::close($1); } : close $_[0]
d269 1
a269 1
			xclose $_->{parent};
d336 1
a336 1
	xclose $_->{open_as};
d341 1
a341 1
    xclose $handles[0]{parent} if $handles[0]{dup};
@


1.2
log
@merge in perl 5.12.2 plus local changes
@
text
@d12 1
a12 1
$VERSION	= 1.05;
d51 1
a51 1
in the parameter slot so it can be overwritten in the caller, or 
d71 1
a71 1
open3() does not wait for and reap the child process after it exits.  
d73 1
a73 1
take care of this, you need to do this yourself.  This is normally as 
a123 2
# $Id: open3.pl,v 1.1 1993/11/23 06:26:15 marc Exp $
#
a151 6
sub xfork {
    my $pid = fork;
    defined $pid or croak "$Me: fork failed: $!";
    return $pid;
}

d157 1
a157 1
# disallows a bearword while compiling under strict subs.
d160 3
a162 1
    open $_[0], $_[1] or croak "$Me: open($_[0], $_[1]) failed: $!";
d166 2
a167 5
    close $_[0] or croak "$Me: close($_[0]) failed: $!";
}

sub fh_is_fd {
    return $_[0] =~ /\A=?(\d+)\z/;
d175 2
a176 1
use constant DO_SPAWN => $^O eq 'os2' || $^O eq 'MSWin32';
a179 6
    my($package, $dad_wtr, $dad_rdr, $dad_err, @@cmd) = @@_;
    my($dup_wtr, $dup_rdr, $dup_err, $kidpid);

    if (@@cmd > 1 and $cmd[0] eq '-') {
	croak "Arguments don't make sense when the command is '-'"
    }
d186 3
a188 3
	$dad_wtr = $_[1] = gensym unless defined $dad_wtr && length $dad_wtr;
	$dad_rdr = $_[2] = gensym unless defined $dad_rdr && length $dad_rdr;
	1; }) 
d193 11
a203 1
    } 
d205 3
a207 1
    $dad_err ||= $dad_rdr;
d209 11
a219 29
    $dup_wtr = ($dad_wtr =~ s/^[<>]&//);
    $dup_rdr = ($dad_rdr =~ s/^[<>]&//);
    $dup_err = ($dad_err =~ s/^[<>]&//);

    # force unqualified filehandles into caller's package
    $dad_wtr = qualify $dad_wtr, $package unless fh_is_fd($dad_wtr);
    $dad_rdr = qualify $dad_rdr, $package unless fh_is_fd($dad_rdr);
    $dad_err = qualify $dad_err, $package unless fh_is_fd($dad_err);

    my $kid_rdr = gensym;
    my $kid_wtr = gensym;
    my $kid_err = gensym;

    xpipe $kid_rdr, $dad_wtr if !$dup_wtr;
    xpipe $dad_rdr, $kid_wtr if !$dup_rdr;
    xpipe $dad_err, $kid_err if !$dup_err && $dad_err ne $dad_rdr;

    $kidpid = DO_SPAWN ? -1 : xfork;
    if ($kidpid == 0) {		# Kid
	# A tie in the parent should not be allowed to cause problems.
	untie *STDIN;
	untie *STDOUT;
	# If she wants to dup the kid's stderr onto her stdout I need to
	# save a copy of her stdout before I put something else there.
	if ($dad_rdr ne $dad_err && $dup_err
		&& xfileno($dad_err) == fileno(STDOUT)) {
	    my $tmp = gensym;
	    xopen($tmp, ">&$dad_err");
	    $dad_err = $tmp;
d222 3
a224 2
	if ($dup_wtr) {
	    xopen \*STDIN,  "<&$dad_wtr" if fileno(STDIN) != xfileno($dad_wtr);
d226 1
a226 2
	    xclose $dad_wtr;
	    xopen \*STDIN,  "<&=" . fileno $kid_rdr;
d228 62
a289 5
	if ($dup_rdr) {
	    xopen \*STDOUT, ">&$dad_rdr" if fileno(STDOUT) != xfileno($dad_rdr);
	} else {
	    xclose $dad_rdr;
	    xopen \*STDOUT, ">&=" . fileno $kid_wtr;
d291 14
a304 10
	if ($dad_rdr ne $dad_err) {
	    if ($dup_err) {
		# I have to use a fileno here because in this one case
		# I'm doing a dup but the filehandle might be a reference
		# (from the special case above).
		xopen \*STDERR, ">&" . xfileno($dad_err)
		    if fileno(STDERR) != xfileno($dad_err);
	    } else {
		xclose $dad_err;
		xopen \*STDERR, ">&=" . fileno $kid_err;
a305 2
	} else {
	    xopen \*STDERR, ">&STDOUT" if fileno(STDERR) != fileno(STDOUT);
d307 2
a308 8
	return 0 if ($cmd[0] eq '-');
	local($")=(" ");
	exec @@cmd or do {
	    carp "$Me: exec of @@cmd failed";
	    eval { require POSIX; POSIX::_exit(255); };
	    exit 255;
	};
    } elsif (DO_SPAWN) {
d313 8
a320 16
	if ($dup_wtr) {
	  $kid_rdr = \*{$dad_wtr};
	  push @@close, $kid_rdr;
	} else {
	  push @@close, \*{$dad_wtr}, $kid_rdr;
	}
	if ($dup_rdr) {
	  $kid_wtr = \*{$dad_rdr};
	  push @@close, $kid_wtr;
	} else {
	  push @@close, \*{$dad_rdr}, $kid_wtr;
	}
	if ($dad_rdr ne $dad_err) {
	    if ($dup_err) {
	      $kid_err = \*{$dad_err};
	      push @@close, $kid_err;
d322 1
a322 1
	      push @@close, \*{$dad_err}, $kid_err;
a323 2
	} else {
	  $kid_err = $kid_wtr;
d327 1
a327 10
	    spawn_with_handles( [ { mode => 'r',
				    open_as => $kid_rdr,
				    handle => \*STDIN },
				  { mode => 'w',
				    open_as => $kid_wtr,
				    handle => \*STDOUT },
				  { mode => 'w',
				    open_as => $kid_err,
				    handle => \*STDERR },
				], \@@close, @@cmd);
d332 5
a336 3
    xclose $kid_rdr if !$dup_wtr;
    xclose $kid_wtr if !$dup_rdr;
    xclose $kid_err if !$dup_err && $dad_rdr ne $dad_err;
d339 1
a339 1
    xclose $dad_wtr if $dup_wtr;
d341 1
a341 1
    select((select($dad_wtr), $| = 1)[0]); # unbuffer pipe
d350 1
a350 1
    return _open3 'open3', scalar caller, @@_
a356 1
    require Fcntl;
d360 1
a360 1
	$saved{fileno $fd->{handle}} = $fd->{tmp_copy};
d367 3
a369 1
	$fd->{handle}->fdopen($saved{fileno $fd->{open_as}} || $fd->{open_as},
d373 1
d376 1
d383 20
a402 1
	$pid = eval { system 1, @@_ }; # 1 == P_NOWAIT
d406 2
a407 1
    foreach $fd (@@$fds) {
d409 3
a411 1
	$fd->{tmp_copy}->close or croak "Can't close: $!";
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d12 1
a12 1
$VERSION	= '1.12';
d51 1
a51 1
in the parameter slot so it can be overwritten in the caller, or
d71 1
a71 1
open3() does not wait for and reap the child process after it exits.
d73 1
a73 1
take care of this, you need to do this yourself.  This is normally as
d124 2
d154 6
d165 1
a165 1
# disallows a bareword while compiling under strict subs.
d168 1
a168 3
    open $_[0], $_[1], @@_[2..$#_] and return;
    local $" = ', ';
    carp "$Me: open(@@_) failed: $!";
d172 5
a176 2
    $_[0] =~ /\A=?(\d+)\z/ ? eval { require POSIX; POSIX::close($1); } : close $_[0]
	or croak "$Me: close($_[0]) failed: $!";
d184 1
a184 2
use constant FORCE_DEBUG_SPAWN => 0;
use constant DO_SPAWN => $^O eq 'os2' || $^O eq 'MSWin32' || FORCE_DEBUG_SPAWN;
d188 6
d200 3
a202 3
	$_[0] = gensym unless defined $_[0] && length $_[0];
	$_[1] = gensym unless defined $_[1] && length $_[1];
	1; })
d207 1
a207 11
    }

    my @@handles = ({ mode => '<', handle => \*STDIN },
		   { mode => '>', handle => \*STDOUT },
		   { mode => '>', handle => \*STDERR },
		  );

    foreach (@@handles) {
	$_->{parent} = shift;
	$_->{open_as} = gensym;
    }
d209 1
a209 3
    if (@@_ > 1 and $_[0] eq '-') {
	croak "Arguments don't make sense when the command is '-'"
    }
d211 29
a239 11
    $handles[2]{parent} ||= $handles[1]{parent};
    $handles[2]{dup_of_out} = $handles[1]{parent} eq $handles[2]{parent};

    my $package;
    foreach (@@handles) {
	$_->{dup} = ($_->{parent} =~ s/^[<>]&//);

	if ($_->{parent} !~ /\A=?(\d+)\z/) {
	    # force unqualified filehandles into caller's package
	    $package //= caller 1;
	    $_->{parent} = qualify $_->{parent}, $package;
d242 2
a243 3
	next if $_->{dup} or $_->{dup_of_out};
	if ($_->{mode} eq '<') {
	    xpipe $_->{open_as}, $_->{parent};
d245 2
a246 1
	    xpipe $_->{parent}, $_->{open_as};
d248 5
a252 62
    }

    my $kidpid;
    if (!DO_SPAWN) {
	# Used to communicate exec failures.
	xpipe my $stat_r, my $stat_w;

	$kidpid = fork;
	croak "$Me: fork failed: $!" unless defined $kidpid;
	if ($kidpid == 0) {  # Kid
	    eval {
		# A tie in the parent should not be allowed to cause problems.
		untie *STDIN;
		untie *STDOUT;

		close $stat_r;
		require Fcntl;
		my $flags = fcntl $stat_w, &Fcntl::F_GETFD, 0;
		croak "$Me: fcntl failed: $!" unless $flags;
		fcntl $stat_w, &Fcntl::F_SETFD, $flags|&Fcntl::FD_CLOEXEC
		    or croak "$Me: fcntl failed: $!";

		# If she wants to dup the kid's stderr onto her stdout I need to
		# save a copy of her stdout before I put something else there.
		if (!$handles[2]{dup_of_out} && $handles[2]{dup}
			&& xfileno($handles[2]{parent}) == fileno \*STDOUT) {
		    my $tmp = gensym;
		    xopen($tmp, '>&', $handles[2]{parent});
		    $handles[2]{parent} = $tmp;
		}

		foreach (@@handles) {
		    if ($_->{dup_of_out}) {
			xopen \*STDERR, ">&STDOUT"
			    if defined fileno STDERR && fileno STDERR != fileno STDOUT;
		    } elsif ($_->{dup}) {
			xopen $_->{handle}, $_->{mode} . '&', $_->{parent}
			    if fileno $_->{handle} != xfileno($_->{parent});
		    } else {
			xclose $_->{parent};
			xopen $_->{handle}, $_->{mode} . '&=',
			    fileno $_->{open_as};
		    }
		}
		return 1 if ($_[0] eq '-');
		exec @@_ or do {
		    local($")=(" ");
		    croak "$Me: exec of @@_ failed";
		};
	    } and do {
                close $stat_w;
                return 0;
            };

	    my $bang = 0+$!;
	    my $err = $@@;
	    utf8::encode $err if $] >= 5.008;
	    print $stat_w pack('IIa*', $bang, length($err), $err);
	    close $stat_w;

	    eval { require POSIX; POSIX::_exit(255); };
	    exit 255;
d254 10
a263 14
	else {  # Parent
	    close $stat_w;
	    my $to_read = length(pack('I', 0)) * 2;
	    my $bytes_read = read($stat_r, my $buf = '', $to_read);
	    if ($bytes_read) {
		(my $bang, $to_read) = unpack('II', $buf);
		read($stat_r, my $err = '', $to_read);
		if ($err) {
		    utf8::decode $err if $] >= 5.008;
		} else {
		    $err = "$Me: " . ($! = $bang);
		}
		$! = $bang;
		die($err);
d265 2
d268 8
a275 2
    }
    else {  # DO_SPAWN
d280 16
a295 8

	foreach (@@handles) {
	    if ($_->{dup_of_out}) {
		$_->{open_as} = $handles[1]{open_as};
	    } elsif ($_->{dup}) {
		$_->{open_as} = $_->{parent} =~ /\A[0-9]+\z/
		    ? $_->{parent} : \*{$_->{parent}};
		push @@close, $_->{open_as};
d297 1
a297 1
		push @@close, \*{$_->{parent}}, $_->{open_as};
d299 2
d304 10
a313 1
	    spawn_with_handles(\@@handles, \@@close, @@_);
d318 3
a320 5
    foreach (@@handles) {
	next if $_->{dup} or $_->{dup_of_out};
	xclose $_->{open_as};
    }

d323 1
a323 1
    xclose $handles[0]{parent} if $handles[0]{dup};
d325 1
a325 1
    select((select($handles[0]{parent}), $| = 1)[0]); # unbuffer pipe
d334 1
a334 1
    return _open3 'open3', @@_
d341 1
d345 1
a345 1
	$saved{fileno $fd->{handle}} = $fd->{tmp_copy} if $fd->{tmp_copy};
d352 1
a352 3
	$fd->{handle}->fdopen(defined fileno $fd->{open_as}
			      ? $saved{fileno $fd->{open_as}} || $fd->{open_as}
			      : $fd->{open_as},
a355 1
	require Fcntl;
a357 1
	    next unless fileno $fd;
d364 1
a364 20
	if (FORCE_DEBUG_SPAWN) {
	    pipe my $r, my $w or die "Pipe failed: $!";
	    $pid = fork;
	    die "Fork failed: $!" unless defined $pid;
	    if (!$pid) {
		{ no warnings; exec @@_ }
		print $w 0 + $!;
		close $w;
		require POSIX;
		POSIX::_exit(255);
	    }
	    close $w;
	    my $bad = <$r>;
	    if (defined $bad) {
		$! = $bad;
		undef $pid;
	    }
	} else {
	    $pid = eval { system 1, @@_ }; # 1 == P_NOWAIT
	}
d368 1
a368 2
    # Do this in reverse, so that STDERR is restored first:
    foreach $fd (reverse @@$fds) {
d370 1
a370 3
    }
    foreach (values %saved) {
	$_->close or croak "Can't close: $!";
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d12 1
a12 1
$VERSION	= '1.13';
d166 1
a166 3
    $_[0] =~ /\A=?(\d+)\z/
	? do { my $fh; open($fh, $_[1] . '&=' . $1) and close($fh); }
	: close $_[0]
d267 1
a267 1
			xclose $_->{parent}, $_->{mode};
d334 1
a334 1
	xclose $_->{open_as}, $_->{mode};
d339 1
a339 1
    xclose $handles[0]{parent}, $handles[0]{mode} if $handles[0]{dup};
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@d12 1
a12 1
$VERSION	= '1.16';
d60 1
a60 2
are just reported to CHLD_ERR under Windows and OS/2, as it is not possible
to trap them.
d101 1
a101 1
Like Open3 but without STDERR capture.
a186 4
    # Historically, open3(undef...) has silently worked, so keep
    # it working.
    splice @@_, 0, 1, undef if \$_[0] == \undef;
    splice @@_, 1, 1, undef if \$_[1] == \undef;
a299 1
		waitpid $kidpid, 0; # Reap child which should have exited
@


1.1.1.5
log
@Import perl-5.24.2
@
text
@d12 1
a12 1
$VERSION	= '1.20';
a248 1
		untie *STDERR;
d282 1
a282 1
		    croak "$Me: exec of @@_ failed: $!";
d364 1
a364 1
    my ($fd, %saved, @@errs);
d375 4
a378 6
    my $open_as = $fd->{open_as};
    my $fileno = fileno($open_as);
    $fd->{handle}->fdopen(defined($fileno)
                  ? $saved{$fileno} || $open_as
                  : $open_as,
                  $fd->{mode});
a389 1
    my $pid;
d411 1
a411 5
	if($@@) {
	    push @@errs, "IO::Pipe: Can't spawn-NOWAIT: $@@";
	} elsif(!$pid || $pid < 0) {
	    push @@errs, "IO::Pipe: Can't spawn-NOWAIT: $!";
	}
@


