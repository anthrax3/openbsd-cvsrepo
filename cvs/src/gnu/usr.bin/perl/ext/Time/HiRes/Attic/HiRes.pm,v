head	1.7;
access;
symbols
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.7
date	2009.10.12.18.24.35;	author millert;	state dead;
branches;
next	1.6;

1.6
date	2008.09.29.17.36.06;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.28.19.23.04;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.15.21.30.29;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.09.18.09.25;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.03.03.02.34;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.46.32;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.01.15.21.17.02;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.24;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.25;	author millert;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge in perl 5.10.1
@
text
@package Time::HiRes;

use strict;
use vars qw($VERSION $XS_VERSION @@ISA @@EXPORT @@EXPORT_OK $AUTOLOAD);

require Exporter;
require DynaLoader;

@@ISA = qw(Exporter DynaLoader);

@@EXPORT = qw( );
@@EXPORT_OK = qw (usleep sleep ualarm alarm gettimeofday time tv_interval
		 getitimer setitimer nanosleep clock_gettime clock_getres
		 clock clock_nanosleep
		 CLOCK_HIGHRES CLOCK_MONOTONIC CLOCK_PROCESS_CPUTIME_ID
		 CLOCK_REALTIME CLOCK_SOFTTIME CLOCK_THREAD_CPUTIME_ID
		 CLOCK_TIMEOFDAY CLOCKS_PER_SEC
		 ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF
		 TIMER_ABSTIME
		 d_usleep d_ualarm d_gettimeofday d_getitimer d_setitimer
		 d_nanosleep d_clock_gettime d_clock_getres
		 d_clock d_clock_nanosleep
		 stat
		);
	
$VERSION = '1.9711';
$XS_VERSION = $VERSION;
$VERSION = eval $VERSION;

sub AUTOLOAD {
    my $constname;
    ($constname = $AUTOLOAD) =~ s/.*:://;
    # print "AUTOLOAD: constname = $constname ($AUTOLOAD)\n";
    die "&Time::HiRes::constant not defined" if $constname eq 'constant';
    my ($error, $val) = constant($constname);
    # print "AUTOLOAD: error = $error, val = $val\n";
    if ($error) {
        my (undef,$file,$line) = caller;
        die "$error at $file line $line.\n";
    }
    {
	no strict 'refs';
	*$AUTOLOAD = sub { $val };
    }
    goto &$AUTOLOAD;
}

sub import {
    my $this = shift;
    for my $i (@@_) {
	if (($i eq 'clock_getres'    && !&d_clock_getres)    ||
	    ($i eq 'clock_gettime'   && !&d_clock_gettime)   ||
	    ($i eq 'clock_nanosleep' && !&d_clock_nanosleep) ||
	    ($i eq 'clock'           && !&d_clock)           ||
	    ($i eq 'nanosleep'       && !&d_nanosleep)       ||
	    ($i eq 'usleep'          && !&d_usleep)          ||
	    ($i eq 'ualarm'          && !&d_ualarm)) {
	    require Carp;
	    Carp::croak("Time::HiRes::$i(): unimplemented in this platform");
	}
    }
    Time::HiRes->export_to_level(1, $this, @@_);
}

bootstrap Time::HiRes;

# Preloaded methods go here.

sub tv_interval {
    # probably could have been done in C
    my ($a, $b) = @@_;
    $b = [gettimeofday()] unless defined($b);
    (${$b}[0] - ${$a}[0]) + ((${$b}[1] - ${$a}[1]) / 1_000_000);
}

# Autoload methods go after =cut, and are processed by the autosplit program.

1;
__END__

=head1 NAME

Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers

=head1 SYNOPSIS

  use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep
		      clock_gettime clock_getres clock_nanosleep clock
                      stat );

  usleep ($microseconds);
  nanosleep ($nanoseconds);

  ualarm ($microseconds);
  ualarm ($microseconds, $interval_microseconds);

  $t0 = [gettimeofday];
  ($seconds, $microseconds) = gettimeofday;

  $elapsed = tv_interval ( $t0, [$seconds, $microseconds]);
  $elapsed = tv_interval ( $t0, [gettimeofday]);
  $elapsed = tv_interval ( $t0 );

  use Time::HiRes qw ( time alarm sleep );

  $now_fractions = time;
  sleep ($floating_seconds);
  alarm ($floating_seconds);
  alarm ($floating_seconds, $floating_interval);

  use Time::HiRes qw( setitimer getitimer );

  setitimer ($which, $floating_seconds, $floating_interval );
  getitimer ($which);

  use Time::HiRes qw( clock_gettime clock_getres clock_nanosleep
		      ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF );

  $realtime   = clock_gettime(CLOCK_REALTIME);
  $resolution = clock_getres(CLOCK_REALTIME);

  clock_nanosleep(CLOCK_REALTIME, 1.5e9);
  clock_nanosleep(CLOCK_REALTIME, time()*1e9 + 10e9, TIMER_ABSTIME);

  my $ticktock = clock();

  use Time::HiRes qw( stat );

  my @@stat = stat("file");
  my @@stat = stat(FH);

=head1 DESCRIPTION

The C<Time::HiRes> module implements a Perl interface to the
C<usleep>, C<nanosleep>, C<ualarm>, C<gettimeofday>, and
C<setitimer>/C<getitimer> system calls, in other words, high
resolution time and timers. See the L</EXAMPLES> section below and the
test scripts for usage; see your system documentation for the
description of the underlying C<nanosleep> or C<usleep>, C<ualarm>,
C<gettimeofday>, and C<setitimer>/C<getitimer> calls.

If your system lacks C<gettimeofday()> or an emulation of it you don't
get C<gettimeofday()> or the one-argument form of C<tv_interval()>.
If your system lacks all of C<nanosleep()>, C<usleep()>,
C<select()>, and C<poll>, you don't get C<Time::HiRes::usleep()>,
C<Time::HiRes::nanosleep()>, or C<Time::HiRes::sleep()>.
If your system lacks both C<ualarm()> and C<setitimer()> you don't get
C<Time::HiRes::ualarm()> or C<Time::HiRes::alarm()>.

If you try to import an unimplemented function in the C<use> statement
it will fail at compile time.

If your subsecond sleeping is implemented with C<nanosleep()> instead
of C<usleep()>, you can mix subsecond sleeping with signals since
C<nanosleep()> does not use signals.  This, however, is not portable,
and you should first check for the truth value of
C<&Time::HiRes::d_nanosleep> to see whether you have nanosleep, and
then carefully read your C<nanosleep()> C API documentation for any
peculiarities.

If you are using C<nanosleep> for something else than mixing sleeping
with signals, give some thought to whether Perl is the tool you should
be using for work requiring nanosecond accuracies.

Remember that unless you are working on a I<hard realtime> system,
any clocks and timers will be imprecise, especially so if you are working
in a pre-emptive multiuser system.  Understand the difference between
I<wallclock time> and process time (in UNIX-like systems the sum of
I<user> and I<system> times).  Any attempt to sleep for X seconds will
most probably end up sleeping B<more> than that, but don't be surpised
if you end up sleeping slightly B<less>.

The following functions can be imported from this module.
No functions are exported by default.

=over 4

=item gettimeofday ()

In array context returns a two-element array with the seconds and
microseconds since the epoch.  In scalar context returns floating
seconds like C<Time::HiRes::time()> (see below).

=item usleep ( $useconds )

Sleeps for the number of microseconds (millionths of a second)
specified.  Returns the number of microseconds actually slept.
Can sleep for more than one second, unlike the C<usleep> system call.
Can also sleep for zero seconds, which often works like a I<thread yield>.
See also C<Time::HiRes::usleep()>, C<Time::HiRes::sleep()>, and
C<Time::HiRes::clock_nanosleep()>.

Do not expect usleep() to be exact down to one microsecond.

=item nanosleep ( $nanoseconds )

Sleeps for the number of nanoseconds (1e9ths of a second) specified.
Returns the number of nanoseconds actually slept (accurate only to
microseconds, the nearest thousand of them).  Can sleep for more than
one second.  Can also sleep for zero seconds, which often works like
a I<thread yield>.  See also C<Time::HiRes::sleep()>,
C<Time::HiRes::usleep()>, and C<Time::HiRes::clock_nanosleep()>.

Do not expect nanosleep() to be exact down to one nanosecond.
Getting even accuracy of one thousand nanoseconds is good.

=item ualarm ( $useconds [, $interval_useconds ] )

Issues a C<ualarm> call; the C<$interval_useconds> is optional and
will be zero if unspecified, resulting in C<alarm>-like behaviour.

ualarm(0) will cancel an outstanding ualarm().

Note that the interaction between alarms and sleeps is unspecified.

=item tv_interval 

tv_interval ( $ref_to_gettimeofday [, $ref_to_later_gettimeofday] )

Returns the floating seconds between the two times, which should have
been returned by C<gettimeofday()>. If the second argument is omitted,
then the current time is used.

=item time ()

Returns a floating seconds since the epoch. This function can be
imported, resulting in a nice drop-in replacement for the C<time>
provided with core Perl; see the L</EXAMPLES> below.

B<NOTE 1>: This higher resolution timer can return values either less
or more than the core C<time()>, depending on whether your platform
rounds the higher resolution timer values up, down, or to the nearest second
to get the core C<time()>, but naturally the difference should be never
more than half a second.  See also L</clock_getres>, if available
in your system.

B<NOTE 2>: Since Sunday, September 9th, 2001 at 01:46:40 AM GMT, when
the C<time()> seconds since epoch rolled over to 1_000_000_000, the
default floating point format of Perl and the seconds since epoch have
conspired to produce an apparent bug: if you print the value of
C<Time::HiRes::time()> you seem to be getting only five decimals, not
six as promised (microseconds).  Not to worry, the microseconds are
there (assuming your platform supports such granularity in the first
place).  What is going on is that the default floating point format of
Perl only outputs 15 digits.  In this case that means ten digits
before the decimal separator and five after.  To see the microseconds
you can use either C<printf>/C<sprintf> with C<"%.6f">, or the
C<gettimeofday()> function in list context, which will give you the
seconds and microseconds as two separate values.

=item sleep ( $floating_seconds )

Sleeps for the specified amount of seconds.  Returns the number of
seconds actually slept (a floating point value).  This function can
be imported, resulting in a nice drop-in replacement for the C<sleep>
provided with perl, see the L</EXAMPLES> below.

Note that the interaction between alarms and sleeps is unspecified.

=item alarm ( $floating_seconds [, $interval_floating_seconds ] )

The C<SIGALRM> signal is sent after the specified number of seconds.
Implemented using C<ualarm()>.  The C<$interval_floating_seconds> argument
is optional and will be zero if unspecified, resulting in C<alarm()>-like
behaviour.  This function can be imported, resulting in a nice drop-in
replacement for the C<alarm> provided with perl, see the L</EXAMPLES> below.

B<NOTE 1>: With some combinations of operating systems and Perl
releases C<SIGALRM> restarts C<select()>, instead of interrupting it.
This means that an C<alarm()> followed by a C<select()> may together
take the sum of the times specified for the the C<alarm()> and the
C<select()>, not just the time of the C<alarm()>.

Note that the interaction between alarms and sleeps is unspecified.

=item setitimer ( $which, $floating_seconds [, $interval_floating_seconds ] )

Start up an interval timer: after a certain time, a signal ($which) arrives,
and more signals may keep arriving at certain intervals.  To disable
an "itimer", use C<$floating_seconds> of zero.  If the
C<$interval_floating_seconds> is set to zero (or unspecified), the
timer is disabled B<after> the next delivered signal.

Use of interval timers may interfere with C<alarm()>, C<sleep()>,
and C<usleep()>.  In standard-speak the "interaction is unspecified",
which means that I<anything> may happen: it may work, it may not.

In scalar context, the remaining time in the timer is returned.

In list context, both the remaining time and the interval are returned.

There are usually three or four interval timers (signals) available: the
C<$which> can be C<ITIMER_REAL>, C<ITIMER_VIRTUAL>, C<ITIMER_PROF>, or
C<ITIMER_REALPROF>.  Note that which ones are available depends: true
UNIX platforms usually have the first three, but (for example) Win32
and Cygwin have only C<ITIMER_REAL>, and only Solaris seems to have
C<ITIMER_REALPROF> (which is used to profile multithreaded programs).

C<ITIMER_REAL> results in C<alarm()>-like behaviour.  Time is counted in
I<real time>; that is, wallclock time.  C<SIGALRM> is delivered when
the timer expires.

C<ITIMER_VIRTUAL> counts time in (process) I<virtual time>; that is,
only when the process is running.  In multiprocessor/user/CPU systems
this may be more or less than real or wallclock time.  (This time is
also known as the I<user time>.)  C<SIGVTALRM> is delivered when the
timer expires.

C<ITIMER_PROF> counts time when either the process virtual time or when
the operating system is running on behalf of the process (such as I/O).
(This time is also known as the I<system time>.)  (The sum of user
time and system time is known as the I<CPU time>.)  C<SIGPROF> is
delivered when the timer expires.  C<SIGPROF> can interrupt system calls.

The semantics of interval timers for multithreaded programs are
system-specific, and some systems may support additional interval
timers.  For example, it is unspecified which thread gets the signals.
See your C<setitimer()> documentation.

=item getitimer ( $which )

Return the remaining time in the interval timer specified by C<$which>.

In scalar context, the remaining time is returned.

In list context, both the remaining time and the interval are returned.
The interval is always what you put in using C<setitimer()>.

=item clock_gettime ( $which )

Return as seconds the current value of the POSIX high resolution timer
specified by C<$which>.  All implementations that support POSIX high
resolution timers are supposed to support at least the C<$which> value
of C<CLOCK_REALTIME>, which is supposed to return results close to the
results of C<gettimeofday>, or the number of seconds since 00:00:00:00
January 1, 1970 Greenwich Mean Time (GMT).  Do not assume that
CLOCK_REALTIME is zero, it might be one, or something else.
Another potentially useful (but not available everywhere) value is
C<CLOCK_MONOTONIC>, which guarantees a monotonically increasing time
value (unlike time(), which can be adjusted).  See your system
documentation for other possibly supported values.

=item clock_getres ( $which )

Return as seconds the resolution of the POSIX high resolution timer
specified by C<$which>.  All implementations that support POSIX high
resolution timers are supposed to support at least the C<$which> value
of C<CLOCK_REALTIME>, see L</clock_gettime>.

=item clock_nanosleep ( $which, $nanoseconds, $flags = 0)

Sleeps for the number of nanoseconds (1e9ths of a second) specified.
Returns the number of nanoseconds actually slept.  The $which is the
"clock id", as with clock_gettime() and clock_getres().  The flags
default to zero but C<TIMER_ABSTIME> can specified (must be exported
explicitly) which means that C<$nanoseconds> is not a time interval
(as is the default) but instead an absolute time.  Can sleep for more
than one second.  Can also sleep for zero seconds, which often works
like a I<thread yield>.  See also C<Time::HiRes::sleep()>,
C<Time::HiRes::usleep()>, and C<Time::HiRes::nanosleep()>.

Do not expect clock_nanosleep() to be exact down to one nanosecond.
Getting even accuracy of one thousand nanoseconds is good.

=item clock()

Return as seconds the I<process time> (user + system time) spent by
the process since the first call to clock() (the definition is B<not>
"since the start of the process", though if you are lucky these times
may be quite close to each other, depending on the system).  What this
means is that you probably need to store the result of your first call
to clock(), and subtract that value from the following results of clock().

The time returned also includes the process times of the terminated
child processes for which wait() has been executed.  This value is
somewhat like the second value returned by the times() of core Perl,
but not necessarily identical.  Note that due to backward
compatibility limitations the returned value may wrap around at about
2147 seconds or at about 36 minutes.

=item stat

=item stat FH

=item stat EXPR

As L<perlfunc/stat> but with the access/modify/change file timestamps
in subsecond resolution, if the operating system and the filesystem
both support such timestamps.  To override the standard stat():

    use Time::HiRes qw(stat);

Test for the value of &Time::HiRes::d_hires_stat to find out whether
the operating system supports subsecond file timestamps: a value
larger than zero means yes. There are unfortunately no easy
ways to find out whether the filesystem supports such timestamps.
UNIX filesystems often do; NTFS does; FAT doesn't (FAT timestamp
granularity is B<two> seconds).

A zero return value of &Time::HiRes::d_hires_stat means that
Time::HiRes::stat is a no-op passthrough for CORE::stat(),
and therefore the timestamps will stay integers.  The same
thing will happen if the filesystem does not do subsecond timestamps,
even if the &Time::HiRes::d_hires_stat is non-zero.

In any case do not expect nanosecond resolution, or even a microsecond
resolution.  Also note that the modify/access timestamps might have
different resolutions, and that they need not be synchronized, e.g.
if the operations are

    write
    stat # t1
    read
    stat # t2

the access time stamp from t2 need not be greater-than the modify
time stamp from t1: it may be equal or I<less>.

=back

=head1 EXAMPLES

  use Time::HiRes qw(usleep ualarm gettimeofday tv_interval);

  $microseconds = 750_000;
  usleep($microseconds);

  # signal alarm in 2.5s & every .1s thereafter
  ualarm(2_500_000, 100_000);
  # cancel that ualarm
  ualarm(0);

  # get seconds and microseconds since the epoch
  ($s, $usec) = gettimeofday();

  # measure elapsed time 
  # (could also do by subtracting 2 gettimeofday return values)
  $t0 = [gettimeofday];
  # do bunch of stuff here
  $t1 = [gettimeofday];
  # do more stuff here
  $t0_t1 = tv_interval $t0, $t1;

  $elapsed = tv_interval ($t0, [gettimeofday]);
  $elapsed = tv_interval ($t0);	# equivalent code

  #
  # replacements for time, alarm and sleep that know about
  # floating seconds
  #
  use Time::HiRes;
  $now_fractions = Time::HiRes::time;
  Time::HiRes::sleep (2.5);
  Time::HiRes::alarm (10.6666666);

  use Time::HiRes qw ( time alarm sleep );
  $now_fractions = time;
  sleep (2.5);
  alarm (10.6666666);

  # Arm an interval timer to go off first at 10 seconds and
  # after that every 2.5 seconds, in process virtual time

  use Time::HiRes qw ( setitimer ITIMER_VIRTUAL time );

  $SIG{VTALRM} = sub { print time, "\n" };
  setitimer(ITIMER_VIRTUAL, 10, 2.5);

  use Time::HiRes qw( clock_gettime clock_getres CLOCK_REALTIME );
  # Read the POSIX high resolution timer.
  my $high = clock_getres(CLOCK_REALTIME);
  # But how accurate we can be, really?
  my $reso = clock_getres(CLOCK_REALTIME);

  use Time::HiRes qw( clock_nanosleep TIMER_ABSTIME );
  clock_nanosleep(CLOCK_REALTIME, 1e6);
  clock_nanosleep(CLOCK_REALTIME, 2e9, TIMER_ABSTIME);

  use Time::HiRes qw( clock );
  my $clock0 = clock();
  ... # Do something.
  my $clock1 = clock();
  my $clockd = $clock1 - $clock0;

  use Time::HiRes qw( stat );
  my ($atime, $mtime, $ctime) = (stat("istics"))[8, 9, 10];

=head1 C API

In addition to the perl API described above, a C API is available for
extension writers.  The following C functions are available in the
modglobal hash:

  name             C prototype
  ---------------  ----------------------
  Time::NVtime     double (*)()
  Time::U2time     void (*)(pTHX_ UV ret[2])

Both functions return equivalent information (like C<gettimeofday>)
but with different representations.  The names C<NVtime> and C<U2time>
were selected mainly because they are operating system independent.
(C<gettimeofday> is Unix-centric, though some platforms like Win32 and
VMS have emulations for it.)

Here is an example of using C<NVtime> from C:

  double (*myNVtime)(); /* Returns -1 on failure. */
  SV **svp = hv_fetch(PL_modglobal, "Time::NVtime", 12, 0);
  if (!svp)         croak("Time::HiRes is required");
  if (!SvIOK(*svp)) croak("Time::NVtime isn't a function pointer");
  myNVtime = INT2PTR(double(*)(), SvIV(*svp));
  printf("The current time is: %f\n", (*myNVtime)());

=head1 DIAGNOSTICS

=head2 useconds or interval more than ...

In ualarm() you tried to use number of microseconds or interval (also
in microseconds) more than 1_000_000 and setitimer() is not available
in your system to emulate that case.

=head2 negative time not invented yet

You tried to use a negative time argument.

=head2 internal error: useconds < 0 (unsigned ... signed ...)

Something went horribly wrong-- the number of microseconds that cannot
become negative just became negative.  Maybe your compiler is broken?

=head1 CAVEATS

Notice that the core C<time()> maybe rounding rather than truncating.
What this means is that the core C<time()> may be reporting the time
as one second later than C<gettimeofday()> and C<Time::HiRes::time()>.

Adjusting the system clock (either manually or by services like ntp)
may cause problems, especially for long running programs that assume
a monotonously increasing time (note that all platforms do not adjust
time as gracefully as UNIX ntp does).  For example in Win32 (and derived
platforms like Cygwin and MinGW) the Time::HiRes::time() may temporarily
drift off from the system clock (and the original time())  by up to 0.5
seconds. Time::HiRes will notice this eventually and recalibrate.
Note that since Time::HiRes 1.77 the clock_gettime(CLOCK_MONOTONIC)
might help in this (in case your system supports CLOCK_MONOTONIC).

=head1 SEE ALSO

Perl modules L<BSD::Resource>, L<Time::TAI64>.

Your system documentation for C<clock>, C<clock_gettime>,
C<clock_getres>, C<clock_nanosleep>, C<clock_settime>, C<getitimer>,
C<gettimeofday>, C<setitimer>, C<sleep>, C<stat>, C<ualarm>.

=head1 AUTHORS

D. Wegscheid <wegscd@@whirlpool.com>
R. Schertler <roderick@@argon.org>
J. Hietaniemi <jhi@@iki.fi>
G. Aas <gisle@@aas.no>

=head1 COPYRIGHT AND LICENSE

Copyright (c) 1996-2002 Douglas E. Wegscheid.  All rights reserved.

Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007 Jarkko Hietaniemi.  All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
@


1.6
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@@


1.5
log
@merge in perl 5.8.8
@
text
@d22 3
a24 1
		 d_clock d_clock_nanosleep);
d26 1
a26 1
$VERSION = '1.86';
d88 2
a89 1
		      clock_gettime clock_getres clock_nanosleep clock );
d111 1
a111 2
  use Time::HiRes qw( setitimer getitimer
		      ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF );
d116 3
d122 2
a123 2
  clock_nanosleep(CLOCK_REALTIME, 1.5);
  clock_nanosleep(CLOCK_REALTIME, time() + 10, TIMER_ABSTIME);
d127 5
d165 8
d187 3
a189 3
specified.  Returns the number of microseconds actually slept.  Can
sleep for more than one second, unlike the C<usleep> system call. Can
also sleep for zero seconds, which often works like a I<thread yield>.
d200 2
a201 2
one second.  Can also sleep for zero seconds, which often works like a
I<thread yield>.  See also C<Time::HiRes::sleep()>,
d212 2
d278 1
a278 1
Start up an interval timer: after a certain time, a signal arrives,
d292 1
a292 1
There are usually three or four interval timers available: the
d317 2
a318 1
timers.  See your C<setitimer()> documentation.
d350 1
a350 1
=item clock_nanosleep ( $which, $seconds, $flags = 0)
d352 2
a353 2
Sleeps for the number of seconds (1e9ths of a second) specified.
Returns the number of seconds actually slept.  The $which is the
d381 38
d430 2
d485 3
d516 6
d551 3
a553 2
Your system documentation for C<clock_gettime>, C<clock_settime>,
C<gettimeofday>, C<getitimer>, C<setitimer>, C<ualarm>.
d566 1
a566 1
Copyright (c) 2002, 2003, 2004, 2005 Jarkko Hietaniemi.  All rights reserved.
@


1.4
log
@sync in-tree perl with 5.8.6
@
text
@d13 5
a17 1
		 getitimer setitimer
d19 1
d21 2
a22 1
		 d_nanosleep);
d24 1
a24 1
$VERSION = '1.65';
d31 1
d34 5
a38 1
    if ($error) { die $error; }
d46 17
d85 2
a86 1
  use Time::HiRes qw( usleep ualarm gettimeofday tv_interval );
d89 1
d114 8
d125 6
a130 6
C<usleep>, C<ualarm>, C<gettimeofday>, and C<setitimer>/C<getitimer>
system calls, in other words, high resolution time and timers. See the
L</EXAMPLES> section below and the test scripts for usage; see your
system documentation for the description of the underlying
C<nanosleep> or C<usleep>, C<ualarm>, C<gettimeofday>, and
C<setitimer>/C<getitimer> calls.
d134 5
a138 5
If your system lacks all of C<nanosleep()>, C<usleep()>, and
C<select()>, you don't get C<Time::HiRes::usleep()> or
C<Time::HiRes::sleep()>.  If your system lacks both C<ualarm()> and
C<setitimer()> you don't get C<Time::HiRes::ualarm()> or
C<Time::HiRes::alarm()>.
d149 5
a153 7
peculiarities.  (There is no separate interface to call
C<nanosleep()>; just use C<Time::HiRes::sleep()> or
C<Time::HiRes::usleep()> with small enough values.)

Unless using C<nanosleep> for mixing sleeping with signals, give
some thought to whether Perl is the tool you should be using for
work requiring nanosecond accuracies.
d168 20
a187 3
Sleeps for the number of microseconds specified.  Returns the number
of microseconds actually slept.  Can sleep for more than one second,
unlike the C<usleep> system call. See also C<Time::HiRes::sleep()> below.
d194 1
a194 1
Note that the interaction between alarms and sleeps are unspecified.
d214 2
a215 1
more than half a second.
d238 1
a238 1
Note that the interaction between alarms and sleeps are unspecified.
d254 1
a254 1
Note that the interaction between alarms and sleeps are unspecified.
d279 1
a279 1
C<ITIMER_REAL> results in C<alarm()>-like behavior.  Time is counted in
d308 52
d367 1
a367 1
  usleep $microseconds;
d370 1
a370 1
  ualarm 2_500_000, 100_000;	
d373 1
a373 1
  ($s, $usec) = gettimeofday;
d408 16
d433 1
a433 1
  Time::U2time     void (*)(UV ret[2])
d438 2
a439 2
(C<gettimeofday> is Unix-centric, though some platforms like VMS have
emulations for it.)
d443 1
a443 1
  double (*myNVtime)();
d474 9
d495 1
a495 1
Copyright (c) 2002,2003,2004 Jarkko Hietaniemi.  All rights reserved.
@


1.3
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d18 1
a18 1
$VERSION = '1.59';
d86 7
a92 6
The C<Time::HiRes> module implements a Perl interface to the C<usleep>,
C<ualarm>, C<gettimeofday>, and C<setitimer>/C<getitimer> system calls, in other
words, high resolution time and timers. See the L</EXAMPLES> section below
and the test scripts for usage; see your system documentation for the
description of the underlying C<nanosleep> or C<usleep>, C<ualarm>,
C<gettimeofday>, and C<setitimer>/C<getitimer> calls.
d95 6
a100 5
get C<gettimeofday()> or the one-argument form of C<tv_interval()>.  If your system lacks all of 
C<nanosleep()>, C<usleep()>, and C<select()>, you don't get
C<Time::HiRes::usleep()> or C<Time::HiRes::sleep()>.  If your system lacks both
C<ualarm()> and C<setitimer()> you don't get
C<Time::HiRes::ualarm()> or C<Time::HiRes::alarm()>.
d105 9
a113 8
If your subsecond sleeping is implemented with C<nanosleep()> instead of
C<usleep()>, you can mix subsecond sleeping with signals since
C<nanosleep()> does not use signals.  This, however is unportable, and you
should first check for the truth value of C<&Time::HiRes::d_nanosleep> to
see whether you have nanosleep, and then carefully read your
C<nanosleep()> C API documentation for any peculiarities.  (There is no
separate interface to call C<nanosleep()>; just use C<Time::HiRes::sleep()>
or C<Time::HiRes::usleep()> with small enough values.)
d116 2
a117 2
some thought to whether Perl is the tool you should be using for work
requiring nanosecond accuracies.
d141 2
d167 9
a175 9
C<Time::HiRes::time()> you seem to be getting only five decimals, not six
as promised (microseconds).  Not to worry, the microseconds are there
(assuming your platform supports such granularity in first place).
What is going on is that the default floating point format of Perl
only outputs 15 digits.  In this case that means ten digits before the
decimal separator and five after.  To see the microseconds you can use
either C<printf>/C<sprintf> with C<"%.6f">, or the C<gettimeofday()> function in
list context, which will give you the seconds and microseconds as two
separate values.
d180 2
a181 2
seconds actually slept (a floating point value).  This function can be
imported, resulting in a nice drop-in replacement for the C<sleep>
d184 2
d194 7
a200 5
B<NOTE 1>: With some operating system and Perl release combinations
C<SIGALRM> restarts C<select()>, instead of interuping it.  
This means that an C<alarm()> followed by a C<select()>
may together take the sum of the times specified for the
C<alarm()> and the C<select()>, not just the time of the C<alarm()>.
d205 4
a208 4
and more signals may keep arriving at certain intervals.  To disable a
timer, use C<$floating_seconds> of zero.  If the C<$interval_floating_seconds>
is set to zero (or unspecified), the timer is disabled B<after> the
next delivered signal.
d218 6
a223 6
There are usually three or four interval timers available: the C<$which>
can be C<ITIMER_REAL>, C<ITIMER_VIRTUAL>, C<ITIMER_PROF>, or C<ITIMER_REALPROF>.
Note that which ones are available depends: true UNIX platforms usually
have the first three, but (for example) Win32 and Cygwin have only
C<ITIMER_REAL>, and only Solaris seems to have C<ITIMER_REALPROF> (which is
used to profile multithreaded programs).
d229 5
a233 4
C<ITIMER_VIRTUAL> counts time in (process) I<virtual time>; that is, only
when the process is running.  In multiprocessor/user/CPU systems this
may be more or less than real or wallclock time.  (This time is also
known as the I<user time>.)  C<SIGVTALRM> is delivered when the timer expires.
@


1.2
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d18 1
a18 1
$VERSION = '1.52';
d332 10
a341 2
What this means is that the core C<time()> may be reporting the time as one second
later than C<gettimeofday()> and C<Time::HiRes::time()>.
d354 1
a354 1
Copyright (c) 2002,2003 Jarkko Hietaniemi.  All rights reserved.
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
use XSLoader;
d9 1
a9 1
@@ISA = qw(Exporter);
d13 6
a18 3
		 getitimer setitimer ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF);

$VERSION = '1.20_00';
d24 4
a27 6
    ($constname= $AUTOLOAD) =~ s/.*:://;
    my $val = constant($constname, @@_ ? $_[0] : 0);
    if ($!) {
	my ($pack,$file,$line) = caller;
	die "Your vendor has not defined Time::HiRes macro $constname, used at $file line $line.\n";
    }
d35 1
a35 1
XSLoader::load 'Time::HiRes', $XS_VERSION;
d79 1
a79 1
		      ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF );
d86 29
a114 12
The C<Time::HiRes> module implements a Perl interface to the usleep,
ualarm, gettimeofday, and setitimer/getitimer system calls. See the
EXAMPLES section below and the test scripts for usage; see your system
documentation for the description of the underlying usleep, ualarm,
gettimeofday, and setitimer/getitimer calls.

If your system lacks gettimeofday(2) or an emulation of it you don't
get gettimeofday() or the one-arg form of tv_interval().
If you don't have usleep(3) or select(2) you don't get usleep()
or sleep().  If your system don't have ualarm(3) or setitimer(2) you
don't get ualarm() or alarm().  If you try to import an unimplemented
function in the C<use> statement it will fail at compile time.
d123 1
a123 1
In array context returns a 2 element array with the seconds and
d125 1
a125 1
seconds like Time::HiRes::time() (see below).
d130 2
a131 2
of microseconds actually slept.  Can sleep for more than one second
unlike the usleep system call. See also Time::HiRes::sleep() below.
d135 2
a136 2
Issues a ualarm call; interval_useconds is optional and will be 0 if 
unspecified, resulting in alarm-like behaviour.
d140 1
a140 1
C<tv_interval ( $ref_to_gettimeofday [, $ref_to_later_gettimeofday] )>
d143 1
a143 1
been returned by gettimeofday(). If the second argument is omitted,
d150 1
a150 1
provided with core Perl, see the EXAMPLES below.
d152 11
a162 11
B<NOTE 1>: this higher resolution timer can return values either less or
more than the core time(), depending on whether your platforms rounds
the higher resolution timer values up, down, or to the nearest to get
the core time(), but naturally the difference should be never more than
half a second.

B<NOTE 2>: Since Sunday, September 9th, 2001 at 01:46:40 AM GMT
(when the time() seconds since epoch rolled over to 1_000_000_000),
the default floating point format of Perl and the seconds since epoch
have conspired to produce an apparent bug: if you print the value of
Time::HiRes::time() you seem to be getting only five decimals, not six
d164 6
a169 6
(assuming your platform supports such granularity).  What is going on
is that the default floating point format of Perl only outputs 15
digits.  In this case that means ten digits before the decimal
separator and five after.  To see the microseconds you can use either
printf/sprintf with C<%.6f>, or the gettimeofday() function in list
context, which will give you the seconds and microseconds as two
d177 1
a177 1
provided with perl, see the EXAMPLES below.
d181 3
a183 3
The SIGALRM signal is sent after the specfified number of seconds.
Implemented using ualarm().  The $interval_floating_seconds argument
is optional and will be 0 if unspecified, resulting in alarm()-like
d185 1
a185 1
replacement for the C<alarm> provided with perl, see the EXAMPLES below.
d187 5
a191 1
=item setitimer 
d193 1
a193 1
C<setitimer ( $which, $floating_seconds [, $interval_floating_seconds ] )>
d196 8
a203 7
and more signals may keep arriving at certain intervals.  To disable
a timer, use time of zero.  If interval is set to zero (or unspecified),
the timer is disabled B<after> the next delivered signal.

Use of interval timers may interfere with alarm(), sleep(), and usleep().
In standard-speak the "interaction is unspecified", which means that
I<anything> may happen: it may work, it may not.
d209 6
a214 2
There are three interval timers: the $which can be ITIMER_REAL,
ITIMER_VIRTUAL, or ITIMER_PROF.
d216 2
a217 2
ITIMER_REAL results in alarm()-like behavior.  Time is counted in
I<real time>, that is, wallclock time.  SIGALRM is delivered when
d220 1
a220 1
ITIMER_VIRTUAL counts time in (process) I<virtual time>, that is, only
d223 1
a223 1
known as the I<user time>.)  SIGVTALRM is delivered when the timer expires.
d225 5
a229 5
ITIMER_PROF counts time when either the process virtual time or when
the operating system is running on behalf of the process (such as
I/O).  (This time is also known as the I<system time>.)  (Collectively
these times are also known as the I<CPU time>.)  SIGPROF is delivered
when the timer expires.  SIGPROF can interrupt system calls.
d233 1
a233 1
timers.  See your setitimer() documentation.
d237 1
a237 1
Return the remaining time in the interval timer specified by $which.
d242 1
a242 1
The interval is always what you put in using setitimer().
d266 1
a266 1
  
d278 1
a278 1
 
d289 1
a289 1
  $SIG{VTLARM} = sub { print time, "\n" };
d306 2
a307 1
(C<gettimeofday> is Un*x-centric.)
d309 1
a309 1
Here is an example of using NVtime from C:
d318 11
d331 3
a333 3
Notice that the core time() maybe rounding rather than truncating.
What this means that the core time() may be giving time one second
later than gettimeofday(), also known as Time::HiRes::time().
d342 1
a342 44
=head1 REVISION

$Id: HiRes.pm,v 1.20 1999/03/16 02:26:13 wegscd Exp $

$Log: HiRes.pm,v $
Revision 1.20  1999/03/16 02:26:13  wegscd
Add documentation for NVTime and U2Time.

Revision 1.19  1998/09/30 02:34:42  wegscd
No changes, bump version.

Revision 1.18  1998/07/07 02:41:35  wegscd
No changes, bump version.

Revision 1.17  1998/07/02 01:45:13  wegscd
Bump version to 1.17

Revision 1.16  1997/11/13 02:06:36  wegscd
version bump to accomodate HiRes.xs fix.

Revision 1.15  1997/11/11 02:17:59  wegscd
POD editing, courtesy of Gisle Aas.

Revision 1.14  1997/11/06 03:14:35  wegscd
Update version # for Makefile.PL and HiRes.xs changes.

Revision 1.13  1997/11/05 05:36:25  wegscd
change version # for Makefile.pl and HiRes.xs changes.

Revision 1.12  1997/10/13 20:55:33  wegscd
Force a new version for Makefile.PL changes.

Revision 1.11  1997/09/05 19:59:33  wegscd
New version to bump version for README and Makefile.PL fixes.
Fix bad RCS log.

Revision 1.10  1997/05/23 01:11:38  wegscd
Conditional compilation; EXPORT_FAIL fixes.

Revision 1.2  1996/12/30 13:28:40  wegscd
Update documentation for what to do when missing ualarm() and friends.

Revision 1.1  1996/10/17 20:53:31  wegscd
Fix =head1 being next to __END__ so pod2man works
d344 1
a344 2
Revision 1.0  1996/09/03 18:25:15  wegscd
Initial revision
d346 1
a346 1
=head1 COPYRIGHT
d348 2
a349 3
Copyright (c) 1996-1997 Douglas E. Wegscheid.
All rights reserved. This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d7 1
a7 1
require DynaLoader;
d9 1
a9 1
@@ISA = qw(Exporter DynaLoader);
d13 3
a15 6
		 getitimer setitimer
		 ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF
		 d_usleep d_ualarm d_gettimeofday d_getitimer d_setitimer
		 d_nanosleep);
	
$VERSION = '1.52';
d21 6
a26 4
    ($constname = $AUTOLOAD) =~ s/.*:://;
    die "&Time::HiRes::constant not defined" if $constname eq 'constant';
    my ($error, $val) = constant($constname);
    if ($error) { die $error; }
d34 1
a34 1
bootstrap Time::HiRes;
d78 1
a78 1
		      ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF );
d85 12
a96 29
The C<Time::HiRes> module implements a Perl interface to the C<usleep>,
C<ualarm>, C<gettimeofday>, and C<setitimer>/C<getitimer> system calls, in other
words, high resolution time and timers. See the L</EXAMPLES> section below
and the test scripts for usage; see your system documentation for the
description of the underlying C<nanosleep> or C<usleep>, C<ualarm>,
C<gettimeofday>, and C<setitimer>/C<getitimer> calls.

If your system lacks C<gettimeofday()> or an emulation of it you don't
get C<gettimeofday()> or the one-argument form of C<tv_interval()>.  If your system lacks all of 
C<nanosleep()>, C<usleep()>, and C<select()>, you don't get
C<Time::HiRes::usleep()> or C<Time::HiRes::sleep()>.  If your system lacks both
C<ualarm()> and C<setitimer()> you don't get
C<Time::HiRes::ualarm()> or C<Time::HiRes::alarm()>.

If you try to import an unimplemented function in the C<use> statement
it will fail at compile time.

If your subsecond sleeping is implemented with C<nanosleep()> instead of
C<usleep()>, you can mix subsecond sleeping with signals since
C<nanosleep()> does not use signals.  This, however is unportable, and you
should first check for the truth value of C<&Time::HiRes::d_nanosleep> to
see whether you have nanosleep, and then carefully read your
C<nanosleep()> C API documentation for any peculiarities.  (There is no
separate interface to call C<nanosleep()>; just use C<Time::HiRes::sleep()>
or C<Time::HiRes::usleep()> with small enough values.)

Unless using C<nanosleep> for mixing sleeping with signals, give
some thought to whether Perl is the tool you should be using for work
requiring nanosecond accuracies.
d105 1
a105 1
In array context returns a two-element array with the seconds and
d107 1
a107 1
seconds like C<Time::HiRes::time()> (see below).
d112 2
a113 2
of microseconds actually slept.  Can sleep for more than one second,
unlike the C<usleep> system call. See also C<Time::HiRes::sleep()> below.
d117 2
a118 2
Issues a C<ualarm> call; the C<$interval_useconds> is optional and
will be zero if unspecified, resulting in C<alarm>-like behaviour.
d122 1
a122 1
tv_interval ( $ref_to_gettimeofday [, $ref_to_later_gettimeofday] )
d125 1
a125 1
been returned by C<gettimeofday()>. If the second argument is omitted,
d132 1
a132 1
provided with core Perl; see the L</EXAMPLES> below.
d134 11
a144 11
B<NOTE 1>: This higher resolution timer can return values either less
or more than the core C<time()>, depending on whether your platform
rounds the higher resolution timer values up, down, or to the nearest second
to get the core C<time()>, but naturally the difference should be never
more than half a second.

B<NOTE 2>: Since Sunday, September 9th, 2001 at 01:46:40 AM GMT, when
the C<time()> seconds since epoch rolled over to 1_000_000_000, the
default floating point format of Perl and the seconds since epoch have
conspired to produce an apparent bug: if you print the value of
C<Time::HiRes::time()> you seem to be getting only five decimals, not six
d146 6
a151 6
(assuming your platform supports such granularity in first place).
What is going on is that the default floating point format of Perl
only outputs 15 digits.  In this case that means ten digits before the
decimal separator and five after.  To see the microseconds you can use
either C<printf>/C<sprintf> with C<"%.6f">, or the C<gettimeofday()> function in
list context, which will give you the seconds and microseconds as two
d159 1
a159 1
provided with perl, see the L</EXAMPLES> below.
d163 3
a165 3
The C<SIGALRM> signal is sent after the specified number of seconds.
Implemented using C<ualarm()>.  The C<$interval_floating_seconds> argument
is optional and will be zero if unspecified, resulting in C<alarm()>-like
d167 1
a167 1
replacement for the C<alarm> provided with perl, see the L</EXAMPLES> below.
d169 1
a169 5
B<NOTE 1>: With some operating system and Perl release combinations
C<SIGALRM> restarts C<select()>, instead of interuping it.  
This means that an C<alarm()> followed by a C<select()>
may together take the sum of the times specified for the the
C<alarm()> and the C<select()>, not just the time of the C<alarm()>.
d171 1
a171 1
=item setitimer ( $which, $floating_seconds [, $interval_floating_seconds ] )
d174 7
a180 8
and more signals may keep arriving at certain intervals.  To disable a
timer, use C<$floating_seconds> of zero.  If the C<$interval_floating_seconds>
is set to zero (or unspecified), the timer is disabled B<after> the
next delivered signal.

Use of interval timers may interfere with C<alarm()>, C<sleep()>,
and C<usleep()>.  In standard-speak the "interaction is unspecified",
which means that I<anything> may happen: it may work, it may not.
d186 2
a187 6
There are usually three or four interval timers available: the C<$which>
can be C<ITIMER_REAL>, C<ITIMER_VIRTUAL>, C<ITIMER_PROF>, or C<ITIMER_REALPROF>.
Note that which ones are available depends: true UNIX platforms usually
have the first three, but (for example) Win32 and Cygwin have only
C<ITIMER_REAL>, and only Solaris seems to have C<ITIMER_REALPROF> (which is
used to profile multithreaded programs).
d189 2
a190 2
C<ITIMER_REAL> results in C<alarm()>-like behavior.  Time is counted in
I<real time>; that is, wallclock time.  C<SIGALRM> is delivered when
d193 1
a193 1
C<ITIMER_VIRTUAL> counts time in (process) I<virtual time>; that is, only
d196 1
a196 1
known as the I<user time>.)  C<SIGVTALRM> is delivered when the timer expires.
d198 5
a202 5
C<ITIMER_PROF> counts time when either the process virtual time or when
the operating system is running on behalf of the process (such as I/O).
(This time is also known as the I<system time>.)  (The sum of user
time and system time is known as the I<CPU time>.)  C<SIGPROF> is
delivered when the timer expires.  C<SIGPROF> can interrupt system calls.
d206 1
a206 1
timers.  See your C<setitimer()> documentation.
d210 1
a210 1
Return the remaining time in the interval timer specified by C<$which>.
d215 1
a215 1
The interval is always what you put in using C<setitimer()>.
d239 1
a239 1

d251 1
a251 1

d262 1
a262 1
  $SIG{VTALRM} = sub { print time, "\n" };
d279 1
a279 2
(C<gettimeofday> is Unix-centric, though some platforms like VMS have
emulations for it.)
d281 1
a281 1
Here is an example of using C<NVtime> from C:
a289 11
=head1 DIAGNOSTICS

=head2 negative time not invented yet

You tried to use a negative time argument.

=head2 internal error: useconds < 0 (unsigned ... signed ...)

Something went horribly wrong-- the number of microseconds that cannot
become negative just became negative.  Maybe your compiler is broken?

d292 3
a294 3
Notice that the core C<time()> maybe rounding rather than truncating.
What this means is that the core C<time()> may be reporting the time as one second
later than C<gettimeofday()> and C<Time::HiRes::time()>.
d303 44
a346 1
=head1 COPYRIGHT AND LICENSE
d348 2
a349 1
Copyright (c) 1996-2002 Douglas E. Wegscheid.  All rights reserved.
d351 1
a351 1
Copyright (c) 2002,2003 Jarkko Hietaniemi.  All rights reserved.
d353 3
a355 2
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@d18 1
a18 1
$VERSION = '1.59';
d190 1
a190 1
may together take the sum of the times specified for the
d332 2
a333 10
What this means is that the core C<time()> may be reporting the time
as one second later than C<gettimeofday()> and C<Time::HiRes::time()>.

Adjusting the system clock (either manually or by services like ntp)
may cause problems, especially for long running programs that assume
a monotonously increasing time (note that all platforms do not adjust
time as gracefully as UNIX ntp does).  For example in Win32 (and derived
platforms like Cygwin and MinGW) the Time::HiRes::time() may temporarily
drift off from the system clock (and the original time())  by up to 0.5
seconds. Time::HiRes will notice this eventually and recalibrate.
d346 1
a346 1
Copyright (c) 2002,2003,2004 Jarkko Hietaniemi.  All rights reserved.
@


1.1.1.4
log
@perl 5.8.6 from CPAN
@
text
@d18 1
a18 1
$VERSION = '1.65';
d86 6
a91 7
The C<Time::HiRes> module implements a Perl interface to the
C<usleep>, C<ualarm>, C<gettimeofday>, and C<setitimer>/C<getitimer>
system calls, in other words, high resolution time and timers. See the
L</EXAMPLES> section below and the test scripts for usage; see your
system documentation for the description of the underlying
C<nanosleep> or C<usleep>, C<ualarm>, C<gettimeofday>, and
C<setitimer>/C<getitimer> calls.
d94 5
a98 6
get C<gettimeofday()> or the one-argument form of C<tv_interval()>.
If your system lacks all of C<nanosleep()>, C<usleep()>, and
C<select()>, you don't get C<Time::HiRes::usleep()> or
C<Time::HiRes::sleep()>.  If your system lacks both C<ualarm()> and
C<setitimer()> you don't get C<Time::HiRes::ualarm()> or
C<Time::HiRes::alarm()>.
d103 8
a110 9
If your subsecond sleeping is implemented with C<nanosleep()> instead
of C<usleep()>, you can mix subsecond sleeping with signals since
C<nanosleep()> does not use signals.  This, however, is not portable,
and you should first check for the truth value of
C<&Time::HiRes::d_nanosleep> to see whether you have nanosleep, and
then carefully read your C<nanosleep()> C API documentation for any
peculiarities.  (There is no separate interface to call
C<nanosleep()>; just use C<Time::HiRes::sleep()> or
C<Time::HiRes::usleep()> with small enough values.)
d113 2
a114 2
some thought to whether Perl is the tool you should be using for
work requiring nanosecond accuracies.
a137 2
Note that the interaction between alarms and sleeps are unspecified.

d162 9
a170 9
C<Time::HiRes::time()> you seem to be getting only five decimals, not
six as promised (microseconds).  Not to worry, the microseconds are
there (assuming your platform supports such granularity in the first
place).  What is going on is that the default floating point format of
Perl only outputs 15 digits.  In this case that means ten digits
before the decimal separator and five after.  To see the microseconds
you can use either C<printf>/C<sprintf> with C<"%.6f">, or the
C<gettimeofday()> function in list context, which will give you the
seconds and microseconds as two separate values.
d175 2
a176 2
seconds actually slept (a floating point value).  This function can
be imported, resulting in a nice drop-in replacement for the C<sleep>
a178 2
Note that the interaction between alarms and sleeps are unspecified.

d187 5
a191 7
B<NOTE 1>: With some combinations of operating systems and Perl
releases C<SIGALRM> restarts C<select()>, instead of interrupting it.
This means that an C<alarm()> followed by a C<select()> may together
take the sum of the times specified for the the C<alarm()> and the
C<select()>, not just the time of the C<alarm()>.

Note that the interaction between alarms and sleeps are unspecified.
d196 4
a199 4
and more signals may keep arriving at certain intervals.  To disable
an "itimer", use C<$floating_seconds> of zero.  If the
C<$interval_floating_seconds> is set to zero (or unspecified), the
timer is disabled B<after> the next delivered signal.
d209 6
a214 6
There are usually three or four interval timers available: the
C<$which> can be C<ITIMER_REAL>, C<ITIMER_VIRTUAL>, C<ITIMER_PROF>, or
C<ITIMER_REALPROF>.  Note that which ones are available depends: true
UNIX platforms usually have the first three, but (for example) Win32
and Cygwin have only C<ITIMER_REAL>, and only Solaris seems to have
C<ITIMER_REALPROF> (which is used to profile multithreaded programs).
d220 4
a223 5
C<ITIMER_VIRTUAL> counts time in (process) I<virtual time>; that is,
only when the process is running.  In multiprocessor/user/CPU systems
this may be more or less than real or wallclock time.  (This time is
also known as the I<user time>.)  C<SIGVTALRM> is delivered when the
timer expires.
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d13 1
a13 5
		 getitimer setitimer nanosleep clock_gettime clock_getres
		 clock clock_nanosleep
		 CLOCK_HIGHRES CLOCK_MONOTONIC CLOCK_PROCESS_CPUTIME_ID
		 CLOCK_REALTIME CLOCK_SOFTTIME CLOCK_THREAD_CPUTIME_ID
		 CLOCK_TIMEOFDAY CLOCKS_PER_SEC
a14 1
		 TIMER_ABSTIME
d16 1
a16 2
		 d_nanosleep d_clock_gettime d_clock_getres
		 d_clock d_clock_nanosleep);
d18 1
a18 1
$VERSION = '1.86';
a24 1
    # print "AUTOLOAD: constname = $constname ($AUTOLOAD)\n";
d27 1
a27 5
    # print "AUTOLOAD: error = $error, val = $val\n";
    if ($error) {
        my (undef,$file,$line) = caller;
        die "$error at $file line $line.\n";
    }
a34 17
sub import {
    my $this = shift;
    for my $i (@@_) {
	if (($i eq 'clock_getres'    && !&d_clock_getres)    ||
	    ($i eq 'clock_gettime'   && !&d_clock_gettime)   ||
	    ($i eq 'clock_nanosleep' && !&d_clock_nanosleep) ||
	    ($i eq 'clock'           && !&d_clock)           ||
	    ($i eq 'nanosleep'       && !&d_nanosleep)       ||
	    ($i eq 'usleep'          && !&d_usleep)          ||
	    ($i eq 'ualarm'          && !&d_ualarm)) {
	    require Carp;
	    Carp::croak("Time::HiRes::$i(): unimplemented in this platform");
	}
    }
    Time::HiRes->export_to_level(1, $this, @@_);
}

d57 1
a57 2
  use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep
		      clock_gettime clock_getres clock_nanosleep clock );
a59 1
  nanosleep ($nanoseconds);
a83 8
  $realtime   = clock_gettime(CLOCK_REALTIME);
  $resolution = clock_getres(CLOCK_REALTIME);

  clock_nanosleep(CLOCK_REALTIME, 1.5);
  clock_nanosleep(CLOCK_REALTIME, time() + 10, TIMER_ABSTIME);

  my $ticktock = clock();

d87 6
a92 6
C<usleep>, C<nanosleep>, C<ualarm>, C<gettimeofday>, and
C<setitimer>/C<getitimer> system calls, in other words, high
resolution time and timers. See the L</EXAMPLES> section below and the
test scripts for usage; see your system documentation for the
description of the underlying C<nanosleep> or C<usleep>, C<ualarm>,
C<gettimeofday>, and C<setitimer>/C<getitimer> calls.
d96 5
a100 5
If your system lacks all of C<nanosleep()>, C<usleep()>,
C<select()>, and C<poll>, you don't get C<Time::HiRes::usleep()>,
C<Time::HiRes::nanosleep()>, or C<Time::HiRes::sleep()>.
If your system lacks both C<ualarm()> and C<setitimer()> you don't get
C<Time::HiRes::ualarm()> or C<Time::HiRes::alarm()>.
d111 7
a117 5
peculiarities.

If you are using C<nanosleep> for something else than mixing sleeping
with signals, give some thought to whether Perl is the tool you should
be using for work requiring nanosecond accuracies.
d132 3
a134 20
Sleeps for the number of microseconds (millionths of a second)
specified.  Returns the number of microseconds actually slept.  Can
sleep for more than one second, unlike the C<usleep> system call. Can
also sleep for zero seconds, which often works like a I<thread yield>.
See also C<Time::HiRes::usleep()>, C<Time::HiRes::sleep()>, and
C<Time::HiRes::clock_nanosleep()>.

Do not expect usleep() to be exact down to one microsecond.

=item nanosleep ( $nanoseconds )

Sleeps for the number of nanoseconds (1e9ths of a second) specified.
Returns the number of nanoseconds actually slept (accurate only to
microseconds, the nearest thousand of them).  Can sleep for more than
one second.  Can also sleep for zero seconds, which often works like a
I<thread yield>.  See also C<Time::HiRes::sleep()>,
C<Time::HiRes::usleep()>, and C<Time::HiRes::clock_nanosleep()>.

Do not expect nanosleep() to be exact down to one nanosecond.
Getting even accuracy of one thousand nanoseconds is good.
d141 1
a141 1
Note that the interaction between alarms and sleeps is unspecified.
d161 1
a161 2
more than half a second.  See also L</clock_getres>, if available
in your system.
d184 1
a184 1
Note that the interaction between alarms and sleeps is unspecified.
d200 1
a200 1
Note that the interaction between alarms and sleeps is unspecified.
d225 1
a225 1
C<ITIMER_REAL> results in C<alarm()>-like behaviour.  Time is counted in
a253 52
=item clock_gettime ( $which )

Return as seconds the current value of the POSIX high resolution timer
specified by C<$which>.  All implementations that support POSIX high
resolution timers are supposed to support at least the C<$which> value
of C<CLOCK_REALTIME>, which is supposed to return results close to the
results of C<gettimeofday>, or the number of seconds since 00:00:00:00
January 1, 1970 Greenwich Mean Time (GMT).  Do not assume that
CLOCK_REALTIME is zero, it might be one, or something else.
Another potentially useful (but not available everywhere) value is
C<CLOCK_MONOTONIC>, which guarantees a monotonically increasing time
value (unlike time(), which can be adjusted).  See your system
documentation for other possibly supported values.

=item clock_getres ( $which )

Return as seconds the resolution of the POSIX high resolution timer
specified by C<$which>.  All implementations that support POSIX high
resolution timers are supposed to support at least the C<$which> value
of C<CLOCK_REALTIME>, see L</clock_gettime>.

=item clock_nanosleep ( $which, $seconds, $flags = 0)

Sleeps for the number of seconds (1e9ths of a second) specified.
Returns the number of seconds actually slept.  The $which is the
"clock id", as with clock_gettime() and clock_getres().  The flags
default to zero but C<TIMER_ABSTIME> can specified (must be exported
explicitly) which means that C<$nanoseconds> is not a time interval
(as is the default) but instead an absolute time.  Can sleep for more
than one second.  Can also sleep for zero seconds, which often works
like a I<thread yield>.  See also C<Time::HiRes::sleep()>,
C<Time::HiRes::usleep()>, and C<Time::HiRes::nanosleep()>.

Do not expect clock_nanosleep() to be exact down to one nanosecond.
Getting even accuracy of one thousand nanoseconds is good.

=item clock()

Return as seconds the I<process time> (user + system time) spent by
the process since the first call to clock() (the definition is B<not>
"since the start of the process", though if you are lucky these times
may be quite close to each other, depending on the system).  What this
means is that you probably need to store the result of your first call
to clock(), and subtract that value from the following results of clock().

The time returned also includes the process times of the terminated
child processes for which wait() has been executed.  This value is
somewhat like the second value returned by the times() of core Perl,
but not necessarily identical.  Note that due to backward
compatibility limitations the returned value may wrap around at about
2147 seconds or at about 36 minutes.

d261 1
a261 1
  usleep($microseconds);
d264 1
a264 1
  ualarm(2_500_000, 100_000);
d267 1
a267 1
  ($s, $usec) = gettimeofday();
a301 16
  use Time::HiRes qw( clock_gettime clock_getres CLOCK_REALTIME );
  # Read the POSIX high resolution timer.
  my $high = clock_getres(CLOCK_REALTIME);
  # But how accurate we can be, really?
  my $reso = clock_getres(CLOCK_REALTIME);

  use Time::HiRes qw( clock_nanosleep TIMER_ABSTIME );
  clock_nanosleep(CLOCK_REALTIME, 1e6);
  clock_nanosleep(CLOCK_REALTIME, 2e9, TIMER_ABSTIME);

  use Time::HiRes qw( clock );
  my $clock0 = clock();
  ... # Do something.
  my $clock1 = clock();
  my $clockd = $clock1 - $clock0;

d311 1
a311 1
  Time::U2time     void (*)(pTHX_ UV ret[2])
d316 2
a317 2
(C<gettimeofday> is Unix-centric, though some platforms like Win32 and
VMS have emulations for it.)
d321 1
a321 1
  double (*myNVtime)(); /* Returns -1 on failure. */
a351 9
Note that since Time::HiRes 1.77 the clock_gettime(CLOCK_MONOTONIC)
might help in this (in case your system supports CLOCK_MONOTONIC).

=head1 SEE ALSO

Perl modules L<BSD::Resource>, L<Time::TAI64>.

Your system documentation for C<clock_gettime>, C<clock_settime>,
C<gettimeofday>, C<getitimer>, C<setitimer>, C<ualarm>.
d364 1
a364 1
Copyright (c) 2002, 2003, 2004, 2005 Jarkko Hietaniemi.  All rights reserved.
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d22 1
a22 3
		 d_clock d_clock_nanosleep
		 stat
		);
d24 1
a24 1
$VERSION = '1.9711';
d86 1
a86 2
		      clock_gettime clock_getres clock_nanosleep clock
                      stat );
d108 2
a109 1
  use Time::HiRes qw( setitimer getitimer );
a113 3
  use Time::HiRes qw( clock_gettime clock_getres clock_nanosleep
		      ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF );

d117 2
a118 2
  clock_nanosleep(CLOCK_REALTIME, 1.5e9);
  clock_nanosleep(CLOCK_REALTIME, time()*1e9 + 10e9, TIMER_ABSTIME);
a121 5
  use Time::HiRes qw( stat );

  my @@stat = stat("file");
  my @@stat = stat(FH);

a154 8
Remember that unless you are working on a I<hard realtime> system,
any clocks and timers will be imprecise, especially so if you are working
in a pre-emptive multiuser system.  Understand the difference between
I<wallclock time> and process time (in UNIX-like systems the sum of
I<user> and I<system> times).  Any attempt to sleep for X seconds will
most probably end up sleeping B<more> than that, but don't be surpised
if you end up sleeping slightly B<less>.

d169 3
a171 3
specified.  Returns the number of microseconds actually slept.
Can sleep for more than one second, unlike the C<usleep> system call.
Can also sleep for zero seconds, which often works like a I<thread yield>.
d182 2
a183 2
one second.  Can also sleep for zero seconds, which often works like
a I<thread yield>.  See also C<Time::HiRes::sleep()>,
a193 2
ualarm(0) will cancel an outstanding ualarm().

d258 1
a258 1
Start up an interval timer: after a certain time, a signal ($which) arrives,
d272 1
a272 1
There are usually three or four interval timers (signals) available: the
d297 1
a297 2
timers.  For example, it is unspecified which thread gets the signals.
See your C<setitimer()> documentation.
d329 1
a329 1
=item clock_nanosleep ( $which, $nanoseconds, $flags = 0)
d331 2
a332 2
Sleeps for the number of nanoseconds (1e9ths of a second) specified.
Returns the number of nanoseconds actually slept.  The $which is the
a359 38
=item stat

=item stat FH

=item stat EXPR

As L<perlfunc/stat> but with the access/modify/change file timestamps
in subsecond resolution, if the operating system and the filesystem
both support such timestamps.  To override the standard stat():

    use Time::HiRes qw(stat);

Test for the value of &Time::HiRes::d_hires_stat to find out whether
the operating system supports subsecond file timestamps: a value
larger than zero means yes. There are unfortunately no easy
ways to find out whether the filesystem supports such timestamps.
UNIX filesystems often do; NTFS does; FAT doesn't (FAT timestamp
granularity is B<two> seconds).

A zero return value of &Time::HiRes::d_hires_stat means that
Time::HiRes::stat is a no-op passthrough for CORE::stat(),
and therefore the timestamps will stay integers.  The same
thing will happen if the filesystem does not do subsecond timestamps,
even if the &Time::HiRes::d_hires_stat is non-zero.

In any case do not expect nanosecond resolution, or even a microsecond
resolution.  Also note that the modify/access timestamps might have
different resolutions, and that they need not be synchronized, e.g.
if the operations are

    write
    stat # t1
    read
    stat # t2

the access time stamp from t2 need not be greater-than the modify
time stamp from t1: it may be equal or I<less>.

a370 2
  # cancel that ualarm
  ualarm(0);
a423 3
  use Time::HiRes qw( stat );
  my ($atime, $mtime, $ctime) = (stat("istics"))[8, 9, 10];

a451 6
=head2 useconds or interval more than ...

In ualarm() you tried to use number of microseconds or interval (also
in microseconds) more than 1_000_000 and setitimer() is not available
in your system to emulate that case.

d481 2
a482 3
Your system documentation for C<clock>, C<clock_gettime>,
C<clock_getres>, C<clock_nanosleep>, C<clock_settime>, C<getitimer>,
C<gettimeofday>, C<setitimer>, C<sleep>, C<stat>, C<ualarm>.
d495 1
a495 1
Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007 Jarkko Hietaniemi.  All rights reserved.
@


