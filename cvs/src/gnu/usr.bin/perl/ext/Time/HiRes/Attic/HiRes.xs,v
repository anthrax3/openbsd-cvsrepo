head	1.2;
access;
symbols
	OPENBSD_4_6:1.1.1.6.0.6
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.2
	OPENBSD_4_5_BASE:1.1.1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.6
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.4
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.2
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2009.10.12.18.24.35;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.56;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.46.33;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.01.15.21.17.02;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.24;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.25;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Merge in perl 5.10.1
@
text
@#ifdef __cplusplus
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifdef WIN32
#include <time.h>
#else
#include <sys/time.h>
#endif
#ifdef HAS_SELECT
# ifdef I_SYS_SELECT
#  include <sys/select.h>
# endif
#endif
#ifdef __cplusplus
}
#endif

static IV
constant(char *name, int arg)
{
    errno = 0;
    switch (*name) {
    case 'I':
      if (strEQ(name, "ITIMER_REAL"))
#ifdef ITIMER_REAL
	return ITIMER_REAL;
#else
	goto not_there;
#endif
      if (strEQ(name, "ITIMER_REALPROF"))
#ifdef ITIMER_REALPROF
	return ITIMER_REALPROF;
#else
	goto not_there;
#endif
      if (strEQ(name, "ITIMER_VIRTUAL"))
#ifdef ITIMER_VIRTUAL
	return ITIMER_VIRTUAL;
#else
	goto not_there;
#endif
      if (strEQ(name, "ITIMER_PROF"))
#ifdef ITIMER_PROF
	return ITIMER_PROF;
#else
	goto not_there;
#endif
      break;
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}

#if !defined(HAS_GETTIMEOFDAY) && defined(WIN32)
#define HAS_GETTIMEOFDAY

/* shows up in winsock.h?
struct timeval {
 long tv_sec;
 long tv_usec;
}
*/

typedef union {
    unsigned __int64	ft_i64;
    FILETIME		ft_val;
} FT_t;

/* Number of 100 nanosecond units from 1/1/1601 to 1/1/1970 */
#ifdef __GNUC__
#define Const64(x) x##LL
#else
#define Const64(x) x##i64
#endif
#define EPOCH_BIAS  Const64(116444736000000000)

/* NOTE: This does not compute the timezone info (doing so can be expensive,
 * and appears to be unsupported even by glibc) */
int
gettimeofday (struct timeval *tp, void *not_used)
{
    FT_t ft;

    /* this returns time in 100-nanosecond units  (i.e. tens of usecs) */
    GetSystemTimeAsFileTime(&ft.ft_val);

    /* seconds since epoch */
    tp->tv_sec = (long)((ft.ft_i64 - EPOCH_BIAS) / Const64(10000000));

    /* microseconds remaining */
    tp->tv_usec = (long)((ft.ft_i64 / Const64(10)) % Const64(1000000));

    return 0;
}
#endif

#if !defined(HAS_GETTIMEOFDAY) && defined(VMS)
#define HAS_GETTIMEOFDAY

#include <lnmdef.h>
#include <time.h> /* gettimeofday */
#include <stdlib.h> /* qdiv */
#include <starlet.h> /* sys$gettim */
#include <descrip.h>
#ifdef __VAX
#include <lib$routines.h> /* lib$ediv() */
#endif

/*
        VMS binary time is expressed in 100 nano-seconds since
        system base time which is 17-NOV-1858 00:00:00.00
*/

#define DIV_100NS_TO_SECS  10000000L
#define DIV_100NS_TO_USECS 10L

/* 
        gettimeofday is supposed to return times since the epoch
        so need to determine this in terms of VMS base time
*/
static $DESCRIPTOR(dscepoch,"01-JAN-1970 00:00:00.00");

#ifdef __VAX
static long base_adjust[2]={0L,0L};
#else
static __int64 base_adjust=0;
#endif

/* 

   If we don't have gettimeofday, then likely we are on a VMS machine that
   operates on local time rather than UTC...so we have to zone-adjust.
   This code gleefully swiped from VMS.C 

*/
/* method used to handle UTC conversions:
 *   1 == CRTL gmtime();  2 == SYS$TIMEZONE_DIFFERENTIAL;  3 == no correction
 */
static int gmtime_emulation_type;
/* number of secs to add to UTC POSIX-style time to get local time */
static long int utc_offset_secs;
static struct dsc$descriptor_s fildevdsc = 
  { 12, DSC$K_DTYPE_T, DSC$K_CLASS_S, "LNM$FILE_DEV" };
static struct dsc$descriptor_s *fildev[] = { &fildevdsc, NULL };

static time_t toutc_dst(time_t loc) {
  struct tm *rsltmp;

  if ((rsltmp = localtime(&loc)) == NULL) return -1;
  loc -= utc_offset_secs;
  if (rsltmp->tm_isdst) loc -= 3600;
  return loc;
}

static time_t toloc_dst(time_t utc) {
  struct tm *rsltmp;

  utc += utc_offset_secs;
  if ((rsltmp = localtime(&utc)) == NULL) return -1;
  if (rsltmp->tm_isdst) utc += 3600;
  return utc;
}

#define _toutc(secs)  ((secs) == (time_t) -1 ? (time_t) -1 : \
       ((gmtime_emulation_type || timezone_setup()), \
       (gmtime_emulation_type == 1 ? toutc_dst(secs) : \
       ((secs) - utc_offset_secs))))

#define _toloc(secs)  ((secs) == (time_t) -1 ? (time_t) -1 : \
       ((gmtime_emulation_type || timezone_setup()), \
       (gmtime_emulation_type == 1 ? toloc_dst(secs) : \
       ((secs) + utc_offset_secs))))

static int
timezone_setup(void) 
{
  struct tm *tm_p;

  if (gmtime_emulation_type == 0) {
    int dstnow;
    time_t base = 15 * 86400; /* 15jan71; to avoid month/year ends between    */
                              /* results of calls to gmtime() and localtime() */
                              /* for same &base */

    gmtime_emulation_type++;
    if ((tm_p = gmtime(&base)) == NULL) { /* CRTL gmtime() is a fake */
      char off[LNM$C_NAMLENGTH+1];;

      gmtime_emulation_type++;
      if (!Perl_vmstrnenv("SYS$TIMEZONE_DIFFERENTIAL",off,0,fildev,0)) {
        gmtime_emulation_type++;
        utc_offset_secs = 0;
        Perl_warn(aTHX_ "no UTC offset information; assuming local time is UTC");
      }
      else { utc_offset_secs = atol(off); }
    }
    else { /* We've got a working gmtime() */
      struct tm gmt, local;

      gmt = *tm_p;
      tm_p = localtime(&base);
      local = *tm_p;
      utc_offset_secs  = (local.tm_mday - gmt.tm_mday) * 86400;
      utc_offset_secs += (local.tm_hour - gmt.tm_hour) * 3600;
      utc_offset_secs += (local.tm_min  - gmt.tm_min)  * 60;
      utc_offset_secs += (local.tm_sec  - gmt.tm_sec);
    }
  }
  return 1;
}


int
gettimeofday (struct timeval *tp, void *tpz)
{
 long ret;
#ifdef __VAX
 long quad[2];
 long quad1[2];
 long div_100ns_to_secs;
 long div_100ns_to_usecs;
 long quo,rem;
 long quo1,rem1;
#else
 __int64 quad;
 __qdiv_t ans1,ans2;
#endif
/*
        In case of error, tv_usec = 0 and tv_sec = VMS condition code.
        The return from function is also set to -1.
        This is not exactly as per the manual page.
*/

 tp->tv_usec = 0;

#ifdef __VAX
 if (base_adjust[0]==0 && base_adjust[1]==0) {
#else
 if (base_adjust==0) { /* Need to determine epoch adjustment */
#endif
        ret=sys$bintim(&dscepoch,&base_adjust);
        if (1 != (ret &&1)) {
                tp->tv_sec = ret;
                return -1;
        }
 }

 ret=sys$gettim(&quad); /* Get VMS system time */
 if ((1 && ret) == 1) {
#ifdef __VAX
        quad[0] -= base_adjust[0]; /* convert to epoch offset */
        quad[1] -= base_adjust[1]; /* convert 2nd half of quadword */
        div_100ns_to_secs = DIV_100NS_TO_SECS;
        div_100ns_to_usecs = DIV_100NS_TO_USECS;
        lib$ediv(&div_100ns_to_secs,&quad,&quo,&rem);
        quad1[0] = rem;
        quad1[1] = 0L;
        lib$ediv(&div_100ns_to_usecs,&quad1,&quo1,&rem1);
        tp->tv_sec = quo; /* Whole seconds */
        tp->tv_usec = quo1; /* Micro-seconds */
#else
        quad -= base_adjust; /* convert to epoch offset */
        ans1=qdiv(quad,DIV_100NS_TO_SECS);
        ans2=qdiv(ans1.rem,DIV_100NS_TO_USECS);
        tp->tv_sec = ans1.quot; /* Whole seconds */
        tp->tv_usec = ans2.quot; /* Micro-seconds */
#endif
 } else {
        tp->tv_sec = ret;
        return -1;
 }
# ifdef VMSISH_TIME
# ifdef RTL_USES_UTC
  if (VMSISH_TIME) tp->tv_sec = _toloc(tp->tv_sec);
# else
  if (!VMSISH_TIME) tp->tv_sec = _toutc(tp->tv_sec);
# endif
# endif
 return 0;
}
#endif

#if !defined(HAS_USLEEP) && defined(HAS_SELECT)
#ifndef SELECT_IS_BROKEN
#define HAS_USLEEP
#define usleep hrt_usleep  /* could conflict with ncurses for static build */

void
hrt_usleep(unsigned long usec)
{
    struct timeval tv;
    tv.tv_sec = 0;
    tv.tv_usec = usec;
    select(0, (Select_fd_set_t)NULL, (Select_fd_set_t)NULL,
		(Select_fd_set_t)NULL, &tv);
}
#endif
#endif

#if !defined(HAS_USLEEP) && defined(WIN32)
#define HAS_USLEEP
#define usleep hrt_usleep  /* could conflict with ncurses for static build */

void
hrt_usleep(unsigned long usec)
{
    long msec;
    msec = usec / 1000;
    Sleep (msec);
}
#endif


#if !defined(HAS_UALARM) && defined(HAS_SETITIMER)
#define HAS_UALARM
#define ualarm hrt_ualarm  /* could conflict with ncurses for static build */

int
hrt_ualarm(int usec, int interval)
{
   struct itimerval itv;
   itv.it_value.tv_sec = usec / 1000000;
   itv.it_value.tv_usec = usec % 1000000;
   itv.it_interval.tv_sec = interval / 1000000;
   itv.it_interval.tv_usec = interval % 1000000;
   return setitimer(ITIMER_REAL, &itv, 0);
}
#endif

#if !defined(HAS_UALARM) && defined(VMS)
#define HAS_UALARM
#define ualarm vms_ualarm 

#include <lib$routines.h>
#include <ssdef.h>
#include <starlet.h>
#include <descrip.h>
#include <signal.h>
#include <jpidef.h>
#include <psldef.h>

#define VMSERR(s)   (!((s)&1))

static void
us_to_VMS(useconds_t mseconds, unsigned long v[])
{
    int iss;
    unsigned long qq[2];

    qq[0] = mseconds;
    qq[1] = 0;
    v[0] = v[1] = 0;

    iss = lib$addx(qq,qq,qq);
    if (VMSERR(iss)) lib$signal(iss);
    iss = lib$subx(v,qq,v);
    if (VMSERR(iss)) lib$signal(iss);
    iss = lib$addx(qq,qq,qq);
    if (VMSERR(iss)) lib$signal(iss);
    iss = lib$subx(v,qq,v);
    if (VMSERR(iss)) lib$signal(iss);
    iss = lib$subx(v,qq,v);
    if (VMSERR(iss)) lib$signal(iss);
}

static int
VMS_to_us(unsigned long v[])
{
    int iss;
    unsigned long div=10,quot, rem;

    iss = lib$ediv(&div,v,&quot,&rem);
    if (VMSERR(iss)) lib$signal(iss);

    return quot;
}

typedef unsigned short word;
typedef struct _ualarm {
    int function;
    int repeat;
    unsigned long delay[2];
    unsigned long interval[2];
    unsigned long remain[2];
} Alarm;


static int alarm_ef;
static Alarm *a0, alarm_base;
#define UAL_NULL   0
#define UAL_SET    1
#define UAL_CLEAR  2
#define UAL_ACTIVE 4
static void ualarm_AST(Alarm *a);

static int 
vms_ualarm(int mseconds, int interval)
{
    Alarm *a, abase;
    struct item_list3 {
        word length;
        word code;
        void *bufaddr;
        void *retlenaddr;
    } ;
    static struct item_list3 itmlst[2];
    static int first = 1;
    unsigned long asten;
    int iss, enabled;

    if (first) {
        first = 0;
        itmlst[0].code       = JPI$_ASTEN;
        itmlst[0].length     = sizeof(asten);
        itmlst[0].retlenaddr = NULL;
        itmlst[1].code       = 0;
        itmlst[1].length     = 0;
        itmlst[1].bufaddr    = NULL;
        itmlst[1].retlenaddr = NULL;

        iss = lib$get_ef(&alarm_ef);
        if (VMSERR(iss)) lib$signal(iss);

        a0 = &alarm_base;
        a0->function = UAL_NULL;
    }
    itmlst[0].bufaddr    = &asten;
    
    iss = sys$getjpiw(0,0,0,itmlst,0,0,0);
    if (VMSERR(iss)) lib$signal(iss);
    if (!(asten&0x08)) return -1;

    a = &abase;
    if (mseconds) {
        a->function = UAL_SET;
    } else {
        a->function = UAL_CLEAR;
    }

    us_to_VMS(mseconds, a->delay);
    if (interval) {
        us_to_VMS(interval, a->interval);
        a->repeat = 1;
    } else 
        a->repeat = 0;

    iss = sys$clref(alarm_ef);
    if (VMSERR(iss)) lib$signal(iss);

    iss = sys$dclast(ualarm_AST,a,0);
    if (VMSERR(iss)) lib$signal(iss);

    iss = sys$waitfr(alarm_ef);
    if (VMSERR(iss)) lib$signal(iss);

    if (a->function == UAL_ACTIVE) 
        return VMS_to_us(a->remain);
    else
        return 0;
}



static void
ualarm_AST(Alarm *a)
{
    int iss;
    unsigned long now[2];

    iss = sys$gettim(now);
    if (VMSERR(iss)) lib$signal(iss);

    if (a->function == UAL_SET || a->function == UAL_CLEAR) {
        if (a0->function == UAL_ACTIVE) {
            iss = sys$cantim(a0,PSL$C_USER);
            if (VMSERR(iss)) lib$signal(iss);

            iss = lib$subx(a0->remain, now, a->remain);
            if (VMSERR(iss)) lib$signal(iss);

            if (a->remain[1] & 0x80000000) 
                a->remain[0] = a->remain[1] = 0;
        }

        if (a->function == UAL_SET) {
            a->function = a0->function;
            a0->function = UAL_ACTIVE;
            a0->repeat = a->repeat;
            if (a0->repeat) {
                a0->interval[0] = a->interval[0];
                a0->interval[1] = a->interval[1];
            }
            a0->delay[0] = a->delay[0];
            a0->delay[1] = a->delay[1];

            iss = lib$subx(now, a0->delay, a0->remain);
            if (VMSERR(iss)) lib$signal(iss);

            iss = sys$setimr(0,a0->delay,ualarm_AST,a0);
            if (VMSERR(iss)) lib$signal(iss);
        } else {
            a->function = a0->function;
            a0->function = UAL_NULL;
        }
        iss = sys$setef(alarm_ef);
        if (VMSERR(iss)) lib$signal(iss);
    } else if (a->function == UAL_ACTIVE) {
        if (a->repeat) {
            iss = lib$subx(now, a->interval, a->remain);
            if (VMSERR(iss)) lib$signal(iss);

            iss = sys$setimr(0,a->interval,ualarm_AST,a);
            if (VMSERR(iss)) lib$signal(iss);
        } else {
            a->function = UAL_NULL;
        }
        iss = sys$wake(0,0);
        if (VMSERR(iss)) lib$signal(iss);
        lib$signal(SS$_ASTFLT);
    } else {
        lib$signal(SS$_BADPARAM);
    }
}

#endif /* !HAS_UALARM && VMS */



#ifdef HAS_GETTIMEOFDAY

static int
myU2time(UV *ret)
{
  struct timeval Tp;
  int status;
  status = gettimeofday (&Tp, NULL);
  ret[0] = Tp.tv_sec;
  ret[1] = Tp.tv_usec;
  return status;
}

static NV
myNVtime()
{
  struct timeval Tp;
  int status;
  status = gettimeofday (&Tp, NULL);
  return status == 0 ? Tp.tv_sec + (Tp.tv_usec / 1000000.) : -1.0;
}

#endif

MODULE = Time::HiRes            PACKAGE = Time::HiRes

PROTOTYPES: ENABLE

BOOT:
#ifdef HAS_GETTIMEOFDAY
{
  UV auv[2];
  hv_store(PL_modglobal, "Time::NVtime", 12, newSViv(PTR2IV(myNVtime)), 0);
  if (myU2time(auv) == 0)
    hv_store(PL_modglobal, "Time::U2time", 12, newSViv((IV) auv[0]), 0);
}
#endif

IV
constant(name, arg)
	char *		name
	int		arg

#if defined(HAS_USLEEP) && defined(HAS_GETTIMEOFDAY)

NV
usleep(useconds)
        NV useconds
	PREINIT:
	struct timeval Ta, Tb;
	CODE:
	gettimeofday(&Ta, NULL);
	if (items > 0) {
	    if (useconds > 1E6) {
		IV seconds = (IV) (useconds / 1E6);
		/* If usleep() has been implemented using setitimer()
		 * then this contortion is unnecessary-- but usleep()
		 * may be implemented in some other way, so let's contort. */
		if (seconds) {
		    sleep(seconds);
		    useconds -= 1E6 * seconds;
		}
	    } else if (useconds < 0.0)
	        croak("Time::HiRes::usleep(%"NVgf"): negative time not invented yet", useconds);
	    usleep((U32)useconds);
	} else
	    PerlProc_pause();
	gettimeofday(&Tb, NULL);
#if 0
	printf("[%ld %ld] [%ld %ld]\n", Tb.tv_sec, Tb.tv_usec, Ta.tv_sec, Ta.tv_usec);
#endif
	RETVAL = 1E6*(Tb.tv_sec-Ta.tv_sec)+(NV)((IV)Tb.tv_usec-(IV)Ta.tv_usec);

	OUTPUT:
	RETVAL

NV
sleep(...)
	PREINIT:
	struct timeval Ta, Tb;
	CODE:
	gettimeofday(&Ta, NULL);
	if (items > 0) {
	    NV seconds  = SvNV(ST(0));
	    if (seconds >= 0.0) {
	         UV useconds = (UV)(1E6 * (seconds - (UV)seconds));
		 if (seconds >= 1.0)
		     sleep((U32)seconds);
		 usleep(useconds);
	    } else
	        croak("Time::HiRes::sleep(%"NVgf"): negative time not invented yet", seconds);
	} else
	    PerlProc_pause();
	gettimeofday(&Tb, NULL);
#if 0
	printf("[%ld %ld] [%ld %ld]\n", Tb.tv_sec, Tb.tv_usec, Ta.tv_sec, Ta.tv_usec);
#endif
	RETVAL = (NV)(Tb.tv_sec-Ta.tv_sec)+0.000001*(NV)(Tb.tv_usec-Ta.tv_usec);

	OUTPUT:
	RETVAL

#endif

#ifdef HAS_UALARM

int
ualarm(useconds,interval=0)
	int useconds
	int interval
	CODE:
	if (useconds < 0 || interval < 0)
	    croak("Time::HiRes::ualarm(%d, %d): negative time not invented yet", useconds, interval);
	RETVAL = ualarm(useconds, interval);

	OUTPUT:
	RETVAL

NV
alarm(seconds,interval=0)
	NV seconds
	NV interval
	CODE:
	if (seconds < 0.0 || interval < 0.0)
	    croak("Time::HiRes::alarm(%"NVgf", %"NVgf"): negative time not invented yet", seconds, interval);
	RETVAL = (NV)ualarm(seconds  * 1000000,
			    interval * 1000000) / 1E6;

	OUTPUT:
	RETVAL

#endif

#ifdef HAS_GETTIMEOFDAY
#    ifdef MACOS_TRADITIONAL	/* fix epoch TZ and use unsigned time_t */
void
gettimeofday()
        PREINIT:
        struct timeval Tp;
        struct timezone Tz;
        PPCODE:
        int status;
        status = gettimeofday (&Tp, &Tz);
        Tp.tv_sec += Tz.tz_minuteswest * 60;	/* adjust for TZ */

        if (GIMME == G_ARRAY) {
             EXTEND(sp, 2);
             /* Mac OS (Classic) has unsigned time_t */
             PUSHs(sv_2mortal(newSVuv(Tp.tv_sec)));
             PUSHs(sv_2mortal(newSViv(Tp.tv_usec)));
        } else {
             EXTEND(sp, 1);
             PUSHs(sv_2mortal(newSVnv(Tp.tv_sec + (Tp.tv_usec / 1000000.0))));
        }

NV
time()
        PREINIT:
        struct timeval Tp;
        struct timezone Tz;
        CODE:
        int status;
        status = gettimeofday (&Tp, &Tz);
        Tp.tv_sec += Tz.tz_minuteswest * 60;	/* adjust for TZ */
        RETVAL = Tp.tv_sec + (Tp.tv_usec / 1000000.0);
	OUTPUT:
	RETVAL

#    else	/* MACOS_TRADITIONAL */
void
gettimeofday()
        PREINIT:
        struct timeval Tp;
        PPCODE:
	int status;
        status = gettimeofday (&Tp, NULL);
        if (GIMME == G_ARRAY) {
	     EXTEND(sp, 2);
             PUSHs(sv_2mortal(newSViv(Tp.tv_sec)));
             PUSHs(sv_2mortal(newSViv(Tp.tv_usec)));
        } else {
             EXTEND(sp, 1);
             PUSHs(sv_2mortal(newSVnv(Tp.tv_sec + (Tp.tv_usec / 1000000.0))));
        }

NV
time()
        PREINIT:
        struct timeval Tp;
        CODE:
	int status;
        status = gettimeofday (&Tp, NULL);
        RETVAL = Tp.tv_sec + (Tp.tv_usec / 1000000.);
	OUTPUT:
	RETVAL

#    endif	/* MACOS_TRADITIONAL */
#endif

#if defined(HAS_GETITIMER) && defined(HAS_SETITIMER)

#define TV2NV(tv) ((NV)((tv).tv_sec) + 0.000001 * (NV)((tv).tv_usec))

void
setitimer(which, seconds, interval = 0)
	int which
	NV seconds
	NV interval
    PREINIT:
	struct itimerval newit;
	struct itimerval oldit;
    PPCODE:
	if (seconds < 0.0 || interval < 0.0)
	    croak("Time::HiRes::setitimer(%"IVdf", %"NVgf", %"NVgf"): negative time not invented yet", (IV)which, seconds, interval);
	newit.it_value.tv_sec  = seconds;
	newit.it_value.tv_usec =
	  (seconds  - (NV)newit.it_value.tv_sec)    * 1000000.0;
	newit.it_interval.tv_sec  = interval;
	newit.it_interval.tv_usec =
	  (interval - (NV)newit.it_interval.tv_sec) * 1000000.0;
	if (setitimer(which, &newit, &oldit) == 0) {
	  EXTEND(sp, 1);
	  PUSHs(sv_2mortal(newSVnv(TV2NV(oldit.it_value))));
	  if (GIMME == G_ARRAY) {
	    EXTEND(sp, 1);
	    PUSHs(sv_2mortal(newSVnv(TV2NV(oldit.it_interval))));
	  }
	}

void
getitimer(which)
	int which
    PREINIT:
	struct itimerval nowit;
    PPCODE:
	if (getitimer(which, &nowit) == 0) {
	  EXTEND(sp, 1);
	  PUSHs(sv_2mortal(newSVnv(TV2NV(nowit.it_value))));
	  if (GIMME == G_ARRAY) {
	    EXTEND(sp, 1);
	    PUSHs(sv_2mortal(newSVnv(TV2NV(nowit.it_interval))));
	  }
	}

#endif

# $Id: HiRes.xs,v 1.11 1999/03/16 02:27:38 wegscd Exp wegscd $

# $Log: HiRes.xs,v $
# Revision 1.11  1999/03/16 02:27:38  wegscd
# Add U2time, NVtime. Fix symbols for static link.
#
# Revision 1.10  1998/09/30 02:36:25  wegscd
# Add VMS changes.
#
# Revision 1.9  1998/07/07 02:42:06  wegscd
# Win32 usleep()
#
# Revision 1.8  1998/07/02 01:47:26  wegscd
# Add Win32 code for gettimeofday.
#
# Revision 1.7  1997/11/13 02:08:12  wegscd
# Add missing EXTEND in gettimeofday() scalar code.
#
# Revision 1.6  1997/11/11 02:32:35  wegscd
# Do something useful when calling gettimeofday() in a scalar context.
# The patch is courtesy of Gisle Aas.
#
# Revision 1.5  1997/11/06 03:10:47  wegscd
# Fake ualarm() if we have setitimer.
#
# Revision 1.4  1997/11/05 05:41:23  wegscd
# Turn prototypes ON (suggested by Gisle Aas)
#
# Revision 1.3  1997/10/13 20:56:15  wegscd
# Add PROTOTYPES: DISABLE
#
# Revision 1.2  1997/05/23 01:01:38  wegscd
# Conditional compilation, depending on what the OS gives us.
#
# Revision 1.1  1996/09/03 18:26:35  wegscd
# Initial revision
#
#
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d21 9
a29 45
#ifndef aTHX_
#    define aTHX_
#    define pTHX_
#endif         

#ifndef NVTYPE
#   if defined(USE_LONG_DOUBLE) && defined(HAS_LONG_DOUBLE)
#       define NVTYPE long double
#   else
#       define NVTYPE double
#   endif
typedef NVTYPE NV;
#endif

#ifndef IVdf
#  ifdef IVSIZE
#      if IVSIZE == LONGSIZE
#           define	IVdf		"ld"
#           define	UVuf		"lu"
#       else
#           if IVSIZE == INTSIZE
#               define	IVdf	"d"
#               define	UVuf	"u"
#           endif
#       endif
#   else
#       define	IVdf	"ld"
#       define	UVuf	"lu"
#   endif
#endif

#ifndef NVef
#   if defined(USE_LONG_DOUBLE) && defined(HAS_LONG_DOUBLE) && \
	defined(PERL_PRIgldbl) /* Not very likely, but let's try anyway. */ 
#       define NVgf		PERL_PRIgldbl
#   else
#       define NVgf		"g"
#   endif
#endif

#ifndef INT2PTR

#if (IVSIZE == PTRSIZE) && (UVSIZE == PTRSIZE)
#  define PTRV                  UV
#  define INT2PTR(any,d)        (any)(d)
d31 1
a31 6
#  if PTRSIZE == LONGSIZE
#    define PTRV                unsigned long
#  else
#    define PTRV                unsigned
#  endif
#  define INT2PTR(any,d)        (any)(PTRV)(d)
d33 5
a37 14
#define PTR2IV(p)       INT2PTR(IV,p)

#endif /* !INT2PTR */

#ifndef SvPV_nolen
static char *
sv_2pv_nolen(pTHX_ register SV *sv)
{
    STRLEN n_a;
    return sv_2pv(sv, &n_a);
}
#   define SvPV_nolen(sv) \
        ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
         ? SvPVX(sv) : sv_2pv_nolen(sv))
d39 5
a43 3

#ifndef PerlProc_pause
#   define PerlProc_pause() Pause()
d45 5
a49 9

/* Though the cpp define ITIMER_VIRTUAL is available the functionality
 * is not supported in Cygwin as of August 2002, ditto for Win32.
 * Neither are ITIMER_PROF or ITIMER_REALPROF implemented.  --jhi
 */
#if defined(__CYGWIN__) || defined(WIN32)
#   undef ITIMER_VIRTUAL
#   undef ITIMER_PROF
#   undef ITIMER_REALPROF
d51 4
d56 4
a59 8
/* 5.004 doesn't define PL_sv_undef */
#ifndef ATLEASTFIVEOHOHFIVE
#ifndef PL_sv_undef
#define PL_sv_undef sv_undef
#endif
#endif

#include "const-c.inc"
a289 19

 /* Do not use H A S _ N A N O S L E E P
  * so that Perl Configure doesn't scan for it.
  * The TIME_HIRES_NANOSLEEP is set by Makefile.PL. */
#if !defined(HAS_USLEEP) && defined(TIME_HIRES_NANOSLEEP)
#define HAS_USLEEP
#define usleep hrt_nanosleep  /* could conflict with ncurses for static build */

void
hrt_nanosleep(unsigned long usec)
{
    struct timespec res;
    res.tv_sec = usec/1000/1000;
    res.tv_nsec = ( usec - res.tv_sec*1000*1000 ) * 1000;
    nanosleep(&res, NULL);
}
#endif


d534 2
a564 1
#ifdef ATLEASTFIVEOHOHFIVE
a572 1
#endif
d574 4
a577 1
INCLUDE: const-xs.inc
a623 11
		 if ((IV)useconds < 0) {
#if defined(__sparc64__) && defined(__GNUC__)
		   /* Sparc64 gcc 2.95.3 (e.g. on NetBSD) has a bug
		    * where (0.5 - (UV)(0.5)) will under certain
		    * circumstances (if the double is cast to UV more
		    * than once?) evaluate to -0.5, instead of 0.5. */
		   useconds = -(IV)useconds;
#endif
		   if ((IV)useconds < 0)
		     croak("Time::HiRes::sleep(%"NVgf"): internal error: useconds < 0 (unsigned %"UVuf" signed %"IVdf")", seconds, useconds, (IV)useconds);
		 }
d782 38
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@a3 1
#define PERL_NO_GET_CONTEXT
a20 7
#ifndef NOOP
#    define NOOP (void)0
#endif
#ifndef dNOOP
#    define dNOOP extern int Perl___notused
#endif

d24 1
a24 18
#    define dTHX dNOOP
#endif

#ifdef START_MY_CXT
#  ifndef MY_CXT_CLONE
#    define MY_CXT_CLONE                                                \
	dMY_CXT_SV;							\
	my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
	Copy(INT2PTR(my_cxt_t*, SvUV(my_cxt_sv)), my_cxtp, 1, my_cxt_t); \
	sv_setuv(my_cxt_sv, PTR2UV(my_cxtp))
#  endif
#else
#    define START_MY_CXT static my_cxt_t my_cxt;
#    define dMY_CXT	 dNOOP
#    define MY_CXT_INIT	 NOOP
#    define MY_CXT_CLONE NOOP
#    define MY_CXT	 my_cxt
#endif
d113 2
a114 5
#ifdef WIN32

#ifndef HAS_GETTIMEOFDAY
#   define HAS_GETTIMEOFDAY
#endif
a127 11
#define MY_CXT_KEY "Time::HiRes_" XS_VERSION

typedef struct {
    unsigned long run_count;
    unsigned __int64 base_ticks;
    unsigned __int64 tick_frequency;
    FT_t base_systime_as_filetime;
} my_cxt_t;

START_MY_CXT

d138 2
a139 15

/* dMY_CXT needs a Perl context and we don't want to call PERL_GET_CONTEXT
   for performance reasons */

#undef gettimeofday
#define gettimeofday(tp, not_used) _gettimeofday(aTHX_ tp, not_used)

/* If the performance counter delta drifts more than 0.5 seconds from the
 * system time then we recalibrate to the system time.  This means we may
 * move *backwards* in time! */

#define MAX_DIFF Const64(5000000)

static int
_gettimeofday(pTHX_ struct timeval *tp, void *not_used)
a140 3
    dMY_CXT;

    unsigned __int64 ticks;
d143 2
a144 21
    if (MY_CXT.run_count++) {
	__int64 diff;
	FT_t filtim;
	GetSystemTimeAsFileTime(&filtim.ft_val);
        QueryPerformanceCounter((LARGE_INTEGER*)&ticks);
        ticks -= MY_CXT.base_ticks;
        ft.ft_i64 = MY_CXT.base_systime_as_filetime.ft_i64
                    + Const64(10000000) * (ticks / MY_CXT.tick_frequency)
                    +(Const64(10000000) * (ticks % MY_CXT.tick_frequency)) / MY_CXT.tick_frequency;
	diff = ft.ft_i64 - MY_CXT.base_systime_as_filetime.ft_i64;
	if (diff < -MAX_DIFF || diff > MAX_DIFF) {
	     MY_CXT.base_ticks = ticks;
	     ft.ft_i64 = filtim.ft_i64;
	}
    }
    else {
        QueryPerformanceFrequency((LARGE_INTEGER*)&MY_CXT.tick_frequency);
        QueryPerformanceCounter((LARGE_INTEGER*)&MY_CXT.base_ticks);
        GetSystemTimeAsFileTime(&MY_CXT.base_systime_as_filetime.ft_val);
        ft.ft_i64 = MY_CXT.base_systime_as_filetime.ft_i64;
    }
a155 9
#if defined(WIN32) && !defined(ATLEASTFIVEOHOHFIVE)
static unsigned int
sleep(unsigned int t)
{
    Sleep(t*1000);
    return 0;
}
#endif

d608 1
a608 1
myU2time(pTHX_ UV *ret)
a620 3
#ifdef WIN32
    dTHX;
#endif
a633 4
{
#ifdef MY_CXT_KEY
  MY_CXT_INIT;
#endif
d636 6
a641 7
  {
    UV auv[2];
    hv_store(PL_modglobal, "Time::NVtime", 12, newSViv(PTR2IV(myNVtime)), 0);
    if (myU2time(aTHX_ auv) == 0)
      hv_store(PL_modglobal, "Time::U2time", 12, newSViv((IV) auv[0]), 0);
  }
#endif
a642 9
}

#if defined(USE_ITHREADS) && defined(MY_CXT_KEY)

void
CLONE(...)
    CODE:
    MY_CXT_CLONE;

@


1.1.1.4
log
@perl 5.8.6 from CPAN
@
text
@a7 5
#include "ppport.h"
#if defined(__CYGWIN__) && defined(HAS_W32API_WINDOWS_H)
# include <w32api/windows.h>
# define CYGWIN_WITH_W32API
#endif
d9 1
a9 1
# include <time.h>
d11 1
a11 1
# include <sys/time.h>
d22 5
a26 2
#ifndef PerlProc_pause
#   define PerlProc_pause() Pause()
d29 62
a90 2
#ifdef HAS_PAUSE
#   define Pause   pause
d92 25
a116 1
#   define Pause() sleep(~0) /* Zzz for a long time. */
d120 1
a120 1
 * is not supported in Cygwin as of August 2004, ditto for Win32.
d131 3
a133 3
# ifndef PL_sv_undef
#  define PL_sv_undef sv_undef
# endif
d138 1
a138 1
#if defined(WIN32) || defined(CYGWIN_WITH_W32API)
a162 1
    unsigned __int64 reset_time;
d169 1
a169 1
# define Const64(x) x##LL
d171 1
a171 1
# define Const64(x) x##i64
a186 1
#define MAX_PERF_COUNTER_SKEW Const64(5000000) /* 0.5 seconds */
d188 1
a188 3
/* Reset reading from the performance counter every five minutes.
 * Many PC clocks just seem to be so bad. */
#define MAX_PERF_COUNTER_TICKS Const64(300000000) /* 300 seconds */
d198 1
a198 9
    if (MY_CXT.run_count++ == 0 ||
	MY_CXT.base_systime_as_filetime.ft_i64 > MY_CXT.reset_time) {
        QueryPerformanceFrequency((LARGE_INTEGER*)&MY_CXT.tick_frequency);
        QueryPerformanceCounter((LARGE_INTEGER*)&MY_CXT.base_ticks);
        GetSystemTimeAsFileTime(&MY_CXT.base_systime_as_filetime.ft_val);
        ft.ft_i64 = MY_CXT.base_systime_as_filetime.ft_i64;
	MY_CXT.reset_time = ft.ft_i64 + MAX_PERF_COUNTER_TICKS;
    }
    else {
d200 2
d208 3
a210 4
	if (diff < -MAX_PERF_COUNTER_SKEW || diff > MAX_PERF_COUNTER_SKEW) {
	    MY_CXT.base_ticks += ticks;
            GetSystemTimeAsFileTime(&MY_CXT.base_systime_as_filetime.ft_val);
            ft.ft_i64 = MY_CXT.base_systime_as_filetime.ft_i64;
d213 6
d705 1
a705 1
  dTHX;
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@a0 10
/*
 * 
 * Copyright (c) 1996-2002 Douglas E. Wegscheid.  All rights reserved.
 * 
 * Copyright (c) 2002,2003,2004,2005 Jarkko Hietaniemi.  All rights reserved.
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the same terms as Perl itself.
 */

a22 3
#if defined(TIME_HIRES_CLOCK_GETTIME_SYSCALL) || defined(TIME_HIRES_CLOCK_GETRES_SYSCALL)
#include <syscall.h>
#endif
a33 1
#   undef Pause /* In case perl.h did it already. */
d54 1
a54 11
#if defined(TIME_HIRES_CLOCK_GETTIME) && defined(_STRUCT_ITIMERSPEC)

/* HP-UX has CLOCK_XXX values but as enums, not as defines.
 * The only way to detect these would be to test compile for each. */
# ifdef __hpux
#  define CLOCK_REALTIME CLOCK_REALTIME
#  define CLOCK_VIRTUAL  CLOCK_VIRTUAL
#  define CLOCK_PROFILE  CLOCK_PROFILE
# endif /* # ifdef __hpux */

#endif /* #if defined(TIME_HIRES_CLOCK_GETTIME) && defined(_STRUCT_ITIMERSPEC) */
d350 1
a350 3
  * so that Perl Configure doesn't scan for it (and pull in -lrt and
  * the like which are not usually good ideas for the default Perl).
  * (We are part of the core perl now.)
d357 1
a357 1
hrt_nanosleep(unsigned long usec) /* This is used to emulate usleep. */
d364 1
a365 1
#endif /* #if !defined(HAS_USLEEP) && defined(TIME_HIRES_NANOSLEEP) */
d382 1
a382 1
#endif /* #if !defined(HAS_USLEEP) && defined(HAS_SELECT) */
d395 1
a395 5
#endif /* #if !defined(HAS_USLEEP) && defined(WIN32) */

#if !defined(HAS_USLEEP) && defined(TIME_HIRES_NANOSLEEP)
#define HAS_USLEEP
#define usleep hrt_usleep  /* could conflict with ncurses for static build */
a396 23
void
hrt_usleep(unsigned long usec)
{
	struct timespec ts1;
	ts1.tv_sec  = usec * 1000; /* Ignoring wraparound. */
	ts1.tv_nsec = 0;
	nanosleep(&ts1, NULL);
}

#endif /* #if !defined(HAS_USLEEP) && defined(TIME_HIRES_NANOSLEEP) */

#if !defined(HAS_USLEEP) && defined(HAS_POLL)
#define HAS_USLEEP
#define usleep hrt_usleep  /* could conflict with ncurses for static build */

void
hrt_usleep(unsigned long usec)
{
    int msec = usec / 1000;
    poll(0, 0, msec);
}

#endif /* #if !defined(HAS_USLEEP) && defined(HAS_POLL) */
d412 1
a412 1
#endif /* #if !defined(HAS_UALARM) && defined(HAS_SETITIMER) */
d609 1
a609 1
#endif /* #if !defined(HAS_UALARM) && defined(VMS) */
d636 1
a636 3
#endif /* #ifdef HAS_GETTIMEOFDAY */

#include "const-c.inc"
d650 1
d652 2
a653 1
    hv_store(PL_modglobal, "Time::U2time", 12, newSViv(PTR2IV(myU2time)), 0);
a702 44
#if defined(TIME_HIRES_NANOSLEEP)

NV
nanosleep(nsec)
        NV nsec
	PREINIT:
	int status = -1;
	struct timeval Ta, Tb;
	CODE:
	gettimeofday(&Ta, NULL);
	if (items > 0) {
	    struct timespec ts1;
	    if (nsec > 1E9) {
		IV sec = (IV) (nsec / 1E9);
		if (sec) {
		    sleep(sec);
		    nsec -= 1E9 * sec;
		}
	    } else if (nsec < 0.0)
	        croak("Time::HiRes::nanosleep(%"NVgf"): negative time not invented yet", nsec);
	    ts1.tv_sec  = (IV) (nsec / 1E9);
	    ts1.tv_nsec = (IV) nsec - ts1.tv_sec * 1E9;
	    status = nanosleep(&ts1, NULL);
	} else {
	    PerlProc_pause();
	    status = 0;
	}
	gettimeofday(&Tb, NULL);
	RETVAL = status == 0 ? 1E3*(1E6*(Tb.tv_sec-Ta.tv_sec)+(NV)((IV)Tb.tv_usec-(IV)Ta.tv_usec)) : -1;

	OUTPUT:
	RETVAL

#else  /* #if defined(TIME_HIRES_NANOSLEEP) */

NV
nanosleep(nsec)
        NV nsec
    CODE:
        croak("Time::HiRes::nanosleep(): unimplemented in this platform");
        RETVAL = 0.0;

#endif /* #if defined(TIME_HIRES_NANOSLEEP) */

d722 1
a722 1
#endif /* #if defined(__sparc64__) && defined(__GNUC__) */
d740 1
a740 10
#else  /* #if defined(HAS_USLEEP) && defined(HAS_GETTIMEOFDAY) */

NV
usleep(useconds)
        NV useconds
    CODE:
        croak("Time::HiRes::usleep(): unimplemented in this platform");
        RETVAL = 0.0;

#endif /* #if defined(HAS_USLEEP) && defined(HAS_GETTIMEOFDAY) */
d769 1
a769 19
#else

int
ualarm(useconds,interval=0)
	int useconds
	int interval
    CODE:
        croak("Time::HiRes::ualarm(): unimplemented in this platform");
	RETVAL = -1;

NV
alarm(seconds,interval=0)
	NV seconds
	NV interval
    CODE:
        croak("Time::HiRes::alarm(): unimplemented in this platform");
	RETVAL = 0.0;

#endif /* #ifdef HAS_UALARM */
d781 1
d783 8
a790 11
	if (status == 0) {
	     Tp.tv_sec += Tz.tz_minuteswest * 60;	/* adjust for TZ */
             if (GIMME == G_ARRAY) {
                 EXTEND(sp, 2);
                 /* Mac OS (Classic) has unsigned time_t */
                 PUSHs(sv_2mortal(newSVuv(Tp.tv_sec)));
                 PUSHs(sv_2mortal(newSViv(Tp.tv_usec)));
             } else {
                 EXTEND(sp, 1);
                 PUSHs(sv_2mortal(newSVnv(Tp.tv_sec + (Tp.tv_usec / 1000000.0))));
	     }
d801 2
a802 6
	if (status == 0) {
            Tp.tv_sec += Tz.tz_minuteswest * 60;	/* adjust for TZ */
	    RETVAL = Tp.tv_sec + (Tp.tv_usec / 1000000.0);
        } else {
	    RETVAL = -1.0;
	}
d814 7
a820 9
	if (status == 0) {
	     if (GIMME == G_ARRAY) {
	         EXTEND(sp, 2);
                 PUSHs(sv_2mortal(newSViv(Tp.tv_sec)));
                 PUSHs(sv_2mortal(newSViv(Tp.tv_usec)));
             } else {
                 EXTEND(sp, 1);
                 PUSHs(sv_2mortal(newSVnv(Tp.tv_sec + (Tp.tv_usec / 1000000.0))));
             }
d830 1
a830 5
	if (status == 0) {
            RETVAL = Tp.tv_sec + (Tp.tv_usec / 1000000.);
	} else {
	    RETVAL = -1.0;
	}
d835 1
a835 1
#endif /* #ifdef HAS_GETTIMEOFDAY */
a881 45
#endif /* #if defined(HAS_GETITIMER) && defined(HAS_SETITIMER) */

#if defined(TIME_HIRES_CLOCK_GETTIME)

NV
clock_gettime(clock_id = CLOCK_REALTIME)
	int clock_id
    PREINIT:
	struct timespec ts;
	int status = -1;
    CODE:
#ifdef TIME_HIRES_CLOCK_GETTIME_SYSCALL
	status = syscall(SYS_clock_gettime, clock_id, &ts);
#else
	status = clock_gettime(clock_id, &ts);
#endif
	RETVAL = status == 0 ? ts.tv_sec + (NV) ts.tv_nsec / (NV) 1e9 : -1;

    OUTPUT:
	RETVAL

#else  /* if defined(TIME_HIRES_CLOCK_GETTIME) */

NV
clock_gettime(clock_id = 0)
	int clock_id
    CODE:
        croak("Time::HiRes::clock_gettime(): unimplemented in this platform");
        RETVAL = 0.0;

#endif /*  #if defined(TIME_HIRES_CLOCK_GETTIME) */

#if defined(TIME_HIRES_CLOCK_GETRES)

NV
clock_getres(clock_id = CLOCK_REALTIME)
	int clock_id
    PREINIT:
	int status = -1;
	struct timespec ts;
    CODE:
#ifdef TIME_HIRES_CLOCK_GETRES_SYSCALL
	status = syscall(SYS_clock_getres, clock_id, &ts);
#else
	status = clock_getres(clock_id, &ts);
a882 75
	RETVAL = status == 0 ? ts.tv_sec + (NV) ts.tv_nsec / (NV) 1e9 : -1;

    OUTPUT:
	RETVAL

#else  /* if defined(TIME_HIRES_CLOCK_GETRES) */

NV
clock_getres(clock_id = 0)
	int clock_id
    CODE:
        croak("Time::HiRes::clock_getres(): unimplemented in this platform");
        RETVAL = 0.0;

#endif /*  #if defined(TIME_HIRES_CLOCK_GETRES) */

#if defined(TIME_HIRES_CLOCK_NANOSLEEP) && defined(TIMER_ABSTIME)

NV
clock_nanosleep(clock_id = CLOCK_REALTIME, sec = 0.0, flags = 0)
	int clock_id
	NV  sec
	int flags
    PREINIT:
	int status = -1;
	struct timespec ts;
	struct timeval Ta, Tb;
    CODE:
	gettimeofday(&Ta, NULL);
	if (items > 1) {
	    ts.tv_sec  = (IV) sec;
	    ts.tv_nsec = (sec - (NV) ts.tv_sec) * (NV) 1E9;
	    status = clock_nanosleep(clock_id, flags, &ts, NULL);
	} else {
	    PerlProc_pause();
	    status = 0;
	}
	gettimeofday(&Tb, NULL);
	RETVAL = status == 0 ? 1E3*(1E6*(Tb.tv_sec-Ta.tv_sec)+(NV)((IV)Tb.tv_usec-(IV)Ta.tv_usec)) : -1;

    OUTPUT:
	RETVAL

#else  /* if defined(TIME_HIRES_CLOCK_NANOSLEEP) && defined(TIMER_ABSTIME) */

NV
clock_nanosleep()
    CODE:
        croak("Time::HiRes::clock_nanosleep(): unimplemented in this platform");
        RETVAL = 0.0;

#endif /*  #if defined(TIME_HIRES_CLOCK_NANOSLEEP) && defined(TIMER_ABSTIME) */

#if defined(TIME_HIRES_CLOCK) && defined(CLOCKS_PER_SEC)

NV
clock()
    PREINIT:
	clock_t clocks;
    CODE:
	clocks = clock();
	RETVAL = clocks == -1 ? -1 : (NV)clocks / (NV)CLOCKS_PER_SEC;

    OUTPUT:
	RETVAL

#else  /* if defined(TIME_HIRES_CLOCK) && defined(CLOCKS_PER_SEC) */

NV
clock()
    CODE:
        croak("Time::HiRes::clock(): unimplemented in this platform");
        RETVAL = 0.0;

#endif /*  #if defined(TIME_HIRES_CLOCK) && defined(CLOCKS_PER_SEC) */
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d5 1
a5 1
 * Copyright (c) 2002,2003,2004,2005,2006,2007 Jarkko Hietaniemi.  All rights reserved.
a39 8
#define IV_1E6 1000000
#define IV_1E7 10000000
#define IV_1E9 1000000000

#define NV_1E6 1000000.0
#define NV_1E7 10000000.0
#define NV_1E9 1000000000.0

d61 7
a117 12
#ifdef Const64
# ifdef __GNUC__
#  define IV_1E6LL  1000000LL /* Needed because of Const64() ##-appends LL (or i64). */
#  define IV_1E7LL  10000000LL
#  define IV_1E9LL  1000000000LL
# else
#  define IV_1E6i64 1000000i64
#  define IV_1E7i64 10000000i64
#  define IV_1E9i64 1000000000i64
# endif
#endif

d157 2
a158 2
                    + Const64(IV_1E7) * (ticks / MY_CXT.tick_frequency)
                    +(Const64(IV_1E7) * (ticks % MY_CXT.tick_frequency)) / MY_CXT.tick_frequency;
d168 1
a168 1
    tp->tv_sec = (long)((ft.ft_i64 - EPOCH_BIAS) / Const64(IV_1E7));
d171 1
a171 1
    tp->tv_usec = (long)((ft.ft_i64 / Const64(10)) % Const64(IV_1E6));
d386 2
a387 2
    res.tv_sec = usec / IV_1E6;
    res.tv_nsec = ( usec - res.tv_sec * IV_1E6 ) * 1000;
d451 4
a454 1
#if defined(HAS_SETITIMER) && defined(ITIMER_REAL)
d456 1
a456 1
hrt_ualarm_itimer(int usec, int interval)
d459 4
a462 4
   itv.it_value.tv_sec = usec / IV_1E6;
   itv.it_value.tv_usec = usec % IV_1E6;
   itv.it_interval.tv_sec = interval / IV_1E6;
   itv.it_interval.tv_usec = interval % IV_1E6;
a464 7
#ifdef HAS_UALARM
int
hrt_ualarm(int usec, int interval) /* for binary compat before 1.91 */
{
   return hrt_ualarm_itimer(usec, interval);
}
#endif /* #ifdef HAS_UALARM */
a466 5
#if !defined(HAS_UALARM) && defined(HAS_SETITIMER)
#define HAS_UALARM
#define ualarm hrt_ualarm_itimer  /* could conflict with ncurses for static build */
#endif

d686 1
a686 1
  return status == 0 ? Tp.tv_sec + (Tp.tv_usec / NV_1E6) : -1.0;
a690 36
static void
hrstatns(UV atime, UV mtime, UV ctime, UV *atime_nsec, UV *mtime_nsec, UV *ctime_nsec)
{
  dTHXR;
  *atime_nsec = 0;
  *mtime_nsec = 0;
  *ctime_nsec = 0;
#ifdef TIME_HIRES_STAT
#if TIME_HIRES_STAT == 1
  *atime_nsec = PL_statcache.st_atimespec.tv_nsec;
  *mtime_nsec = PL_statcache.st_mtimespec.tv_nsec;
  *ctime_nsec = PL_statcache.st_ctimespec.tv_nsec;
#endif
#if TIME_HIRES_STAT == 2
  *atime_nsec = PL_statcache.st_atimensec;
  *mtime_nsec = PL_statcache.st_mtimensec;
  *ctime_nsec = PL_statcache.st_ctimensec;
#endif
#if TIME_HIRES_STAT == 3
  *atime_nsec = PL_statcache.st_atime_n;
  *mtime_nsec = PL_statcache.st_mtime_n;
  *ctime_nsec = PL_statcache.st_ctime_n;
#endif
#if TIME_HIRES_STAT == 4
  *atime_nsec = PL_statcache.st_atim.tv_nsec;
  *mtime_nsec = PL_statcache.st_mtim.tv_nsec;
  *ctime_nsec = PL_statcache.st_ctim.tv_nsec;
#endif
#if TIME_HIRES_STAT == 5
  *atime_nsec = PL_statcache.st_uatime * 1000;
  *mtime_nsec = PL_statcache.st_umtime * 1000;
  *ctime_nsec = PL_statcache.st_uctime * 1000;
#endif
#endif
}

d703 1
a703 1
#   ifdef HAS_GETTIMEOFDAY
d708 1
a708 1
#   endif
d762 2
a763 1
	struct timespec sleepfor, unslept;
d765 14
a778 6
	if (nsec < 0.0)
	    croak("Time::HiRes::nanosleep(%"NVgf"): negative time not invented yet", nsec);
	sleepfor.tv_sec = (Time_t)(nsec / 1e9);
	sleepfor.tv_nsec = (long)(nsec - ((NV)sleepfor.tv_sec) * 1e9);
	if (!nanosleep(&sleepfor, &unslept)) {
	    RETVAL = nsec;
d780 2
a781 7
	    sleepfor.tv_sec -= unslept.tv_sec;
	    sleepfor.tv_nsec -= unslept.tv_nsec;
	    if (sleepfor.tv_nsec < 0) {
		sleepfor.tv_sec--;
		sleepfor.tv_nsec += 1000000000;
	    }
	    RETVAL = ((NV)sleepfor.tv_sec) * 1e9 + ((NV)sleepfor.tv_nsec);
d783 4
a786 1
    OUTPUT:
d857 1
a857 8
	if (useconds >= IV_1E6 || interval >= IV_1E6)
#if defined(HAS_SETITIMER) && defined(ITIMER_REAL)
		RETVAL = hrt_ualarm_itimer(useconds, interval);
#else
		croak("Time::HiRes::ualarm(%d, %d): useconds or interval equal or more than %"IVdf, useconds, interval, IV_1E6);
#endif
	else
		RETVAL = ualarm(useconds, interval);
d869 2
a870 2
	RETVAL = (NV)ualarm((IV)(seconds  * IV_1E6),
			    (IV)(interval * IV_1E6)) / NV_1E6;
d915 1
a915 1
                 PUSHs(sv_2mortal(newSVnv(Tp.tv_sec + (Tp.tv_usec / NV_1E6))));
d929 1
a929 1
	    RETVAL = Tp.tv_sec + (Tp.tv_usec / NV_1E6);
d951 1
a951 1
                 PUSHs(sv_2mortal(newSVnv(Tp.tv_sec + (Tp.tv_usec / NV_1E6))));
d963 1
a963 1
            RETVAL = Tp.tv_sec + (Tp.tv_usec / NV_1E6);
d988 1
a988 1
	newit.it_value.tv_sec  = (IV)seconds;
d990 2
a991 2
	  (IV)((seconds  - (NV)newit.it_value.tv_sec)    * NV_1E6);
	newit.it_interval.tv_sec  = (IV)interval;
d993 1
a993 1
	  (IV)((interval - (NV)newit.it_interval.tv_sec) * NV_1E6);
d1083 1
a1083 1
clock_nanosleep(clock_id, nsec, flags = 0)
d1085 1
a1085 1
	NV  nsec
d1088 3
a1090 1
	struct timespec sleepfor, unslept;
d1092 5
a1096 6
	if (nsec < 0.0)
	    croak("Time::HiRes::clock_nanosleep(..., %"NVgf"): negative time not invented yet", nsec);
	sleepfor.tv_sec = (Time_t)(nsec / 1e9);
	sleepfor.tv_nsec = (long)(nsec - ((NV)sleepfor.tv_sec) * 1e9);
	if (!clock_nanosleep(clock_id, flags, &sleepfor, &unslept)) {
	    RETVAL = nsec;
d1098 2
a1099 7
	    sleepfor.tv_sec -= unslept.tv_sec;
	    sleepfor.tv_nsec -= unslept.tv_nsec;
	    if (sleepfor.tv_nsec < 0) {
		sleepfor.tv_sec--;
		sleepfor.tv_nsec += 1000000000;
	    }
	    RETVAL = ((NV)sleepfor.tv_sec) * 1e9 + ((NV)sleepfor.tv_nsec);
d1101 3
a1139 32
void
stat(...)
PROTOTYPE: ;$
    PPCODE:
	PUSHMARK(SP);
	XPUSHs(sv_2mortal(newSVsv(items == 1 ? ST(0) : DEFSV)));
	PUTBACK;
	ENTER;
	PL_laststatval = -1;
	(void)*(PL_ppaddr[OP_STAT])(aTHXR);
	SPAGAIN;
	LEAVE;
	if (PL_laststatval == 0) {
	  /* We assume that pp_stat() left us with 13 valid stack items,
	   * and that the timestamps are at offsets 8, 9, and 10. */
	  UV atime = SvUV(ST( 8));
	  UV mtime = SvUV(ST( 9));
	  UV ctime = SvUV(ST(10));
	  UV atime_nsec;
	  UV mtime_nsec;
	  UV ctime_nsec;
	  hrstatns(atime, mtime, ctime,
		   &atime_nsec, &mtime_nsec, &ctime_nsec);
	  if (atime_nsec)
	    ST( 8) = sv_2mortal(newSVnv(atime + 1e-9 * (NV) atime_nsec));
	  if (mtime_nsec)
	    ST( 9) = sv_2mortal(newSVnv(mtime + 1e-9 * (NV) mtime_nsec));
	  if (ctime_nsec)
	    ST(10) = sv_2mortal(newSVnv(ctime + 1e-9 * (NV) ctime_nsec));
	  XSRETURN(13);
	}
	XSRETURN(0);
@


