head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.14
	OPENBSD_6_2_BASE:1.1.1.1
	PERL_5_24_2:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.18
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.16
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.10
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.12
	OPENBSD_5_8_BASE:1.1.1.1
	PERL_5_20_2:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.4
	OPENBSD_5_7_BASE:1.1.1.1
	PERL_5_20_1:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.8
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.6
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.2
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2013.03.25.20.08.47;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.03.25.20.08.47;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!/usr/bin/perl

use warnings;
use strict;
use Test::More tests => 17;

use XS::APItest;
use t::BHK ();      # make sure it gets compiled early

BEGIN { package XS::APItest; *main::bhkav = \@@XS::APItest::bhkav }

# 'use t::BHK' switches on recording hooks, and clears @@bhkav.
# 'no t::BHK' switches recording off again.
# 'use t::BHK push => "foo"' pushes onto @@bhkav

use t::BHK;
    1;
no t::BHK;

BEGIN { is_deeply \@@bhkav, [], "no blocks" }

use t::BHK;
    {
        1;
    }
no t::BHK;

BEGIN { is_deeply \@@bhkav, 
    [[start => 1], qw/pre_end post_end/], 
    "plain block";
}

use t::BHK;
    if (1) { 1 }
no t::BHK;

BEGIN { is_deeply \@@bhkav,
    [
        [start => 1],
        [start => 0],
        qw/pre_end post_end/,
        qw/pre_end post_end/,
    ], 
    "if block";
}

use t::BHK;
    for (1) { 1 }
no t::BHK;

BEGIN { is_deeply \@@bhkav,
    [
        [start => 1],
        [start => 0],
        qw/pre_end post_end/,
        qw/pre_end post_end/,
    ],
    "for loop";
}

use t::BHK;
    {
        { 1; }
    }
no t::BHK;

BEGIN { is_deeply \@@bhkav,
    [
        [start => 1],
        [start => 1],
        qw/pre_end post_end/,
        qw/pre_end post_end/,
    ],
    "nested blocks";
}

use t::BHK;
    use t::BHK push => "before";
    {
        use t::BHK push => "inside";
    }
    use t::BHK push => "after";
no t::BHK;

BEGIN { is_deeply \@@bhkav,
    [
        "before",
        [start => 1],
        "inside",
        qw/pre_end post_end/,
        "after"
    ],
    "hooks called in the correct places";
}

use t::BHK;
    BEGIN { 1 }
no t::BHK;

BEGIN { is_deeply \@@bhkav,
    [
        [start => 1],
        qw/pre_end post_end/,
    ],
    "BEGIN block";
}

use t::BHK; t::BHK->import;
    eval "1";
no t::BHK; t::BHK->unimport;

BEGIN { is_deeply \@@bhkav, [], "string eval (compile)" }
is_deeply \@@bhkav, 
    [
        [eval => "entereval"],
        [start => 1],
        qw/pre_end post_end/,
    ], 
    "string eval (run)";

delete @@INC{qw{t/Null.pm t/Block.pm}};

t::BHK->import;
    do "t/Null.pm";
t::BHK->unimport;

is_deeply \@@bhkav,
    [
        [eval => "dofile"],
        [start => 1],
        qw/pre_end post_end/,
    ],
    "do file (null)";

t::BHK->import;
    do "t/Block.pm";
t::BHK->unimport;

is_deeply \@@bhkav,
    [
        [eval => "dofile"],
        [start => 1],
        [start => 1],
        qw/pre_end post_end/,
        qw/pre_end post_end/,
    ],
    "do file (single block)";

delete @@INC{qw{t/Null.pm t/Block.pm}};

t::BHK->import;
    require t::Null;
t::BHK->unimport;

is_deeply \@@bhkav,
    [
        [eval => "require"],
        [start => 1],
        qw/pre_end post_end/,
    ],
    "require (null)";

t::BHK->import;
    require t::Block;
t::BHK->unimport;

is_deeply \@@bhkav,
    [
        [eval => "require"],
        [start => 1],
        [start => 1],
        qw/pre_end post_end/,
        qw/pre_end post_end/,
    ],
    "require (single block)";

BEGIN { delete $INC{"t/Block.pm"} }

use t::BHK;
    use t::Block;
no t::BHK;

BEGIN { is_deeply \@@bhkav,
    [
        [eval => "require"],
        [start => 1],
        [start => 1],
        qw/pre_end post_end/,
        qw/pre_end post_end/,
    ],
    "use (single block)";
}

BEGIN { delete $INC{"t/Markers.pm"} }

use t::BHK;
    use t::BHK push => "compile/main/before";
    use t::Markers;
    use t::BHK push => "compile/main/after";
no t::BHK;

BEGIN { is_deeply \@@bhkav,
    [
        "compile/main/before",
        [eval => "require"],
        [start => 1],
            "compile/pm/before",
            [start => 1],
                "compile/pm/inside",
            qw/pre_end post_end/,
            "compile/pm/after",
        qw/pre_end post_end/,
        "run/pm",
        "run/import",
        "compile/main/after",
    ],
    "use with markers";
}

# OK, now some *really* evil stuff...

BEGIN {
    package EvalDestroy;

    sub DESTROY { $_[0]->() }
}

use t::BHK;
    {
        BEGIN {
            # grumbleSCOPECHECKgrumble
            push @@XS::APItest::COMPILE_SCOPE_CONTAINER, 
                bless sub {
                    push @@bhkav, "DESTROY";
                }, "EvalDestroy";
        }
        1;
    }
no t::BHK;

BEGIN { is_deeply \@@bhkav,
    [
        [start => 1],                   # block
            [start => 1],               # BEGIN
                [start => 1],           # sub
                qw/pre_end post_end/,
            qw/pre_end post_end/,
        "pre_end",
            "DESTROY", 
        "post_end",
    ],
    "compile-time DESTROY comes between pre_ and post_end";
}

use t::BHK;
    {
        BEGIN { 
            push @@XS::APItest::COMPILE_SCOPE_CONTAINER, 
                bless sub {
                    eval "{1}";
                }, "EvalDestroy";
        }
        1;
    }
no t::BHK;

BEGIN { is_deeply \@@bhkav,
    [
        [start => 1],                   # block
            [start => 1],               # BEGIN
                [start => 1],           # sub
                qw/pre_end post_end/,
            qw/pre_end post_end/,
        "pre_end",
            [eval => "entereval"],
            [start => 1],               # eval
                [start => 1],           # block inside eval
                qw/pre_end post_end/,
            qw/pre_end post_end/,
        "post_end",
    ],
    "evil eval-in-DESTROY tricks";
}
@


1.1.1.1
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@@
