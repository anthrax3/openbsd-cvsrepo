head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.16
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.10
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.12
	OPENBSD_5_8_BASE:1.1.1.1
	PERL_5_20_2:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.4
	OPENBSD_5_7_BASE:1.1.1.1
	PERL_5_20_1:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.8
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.6
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.2
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2013.03.25.20.08.47;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.03.25.20.08.47;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!perl -w

use strict;
use Test::More;

BEGIN {use_ok('XS::APItest')};
my (%sigils);
BEGIN {
    %sigils = (
	       '$' => 'sv',
	       '@@' => 'av',
	       '%' => 'hv',
	       '&' => 'cv',
	       '*' => 'gv'
	      );
}
my %types = map {$_, eval "&to_${_}_amg()"} values %sigils;

{
    package None;
}

{
    package Other;
    use overload 'eq' => sub {no overloading; $_[0] == $_[1]},
	'""' =>  sub {no overloading; "$_[0]"},
	'~' => sub {return "Perl rules"};
}

{
    package Same;
    use overload 'eq' => sub {no overloading; $_[0] == $_[1]},
	'""' =>  sub {no overloading; "$_[0]"},
	map {$_ . '{}', sub {return $_[0]}} keys %sigils;
}

{
    package Chain;
    use overload 'eq' => sub {no overloading; $_[0] == $_[1]},
	'""' =>  sub {no overloading; "$_[0]"},
	map {$_ . '{}', sub {no overloading; return $_[0][0]}} keys %sigils;
}

my @@non_ref = (['undef', undef],
		 ['number', 42],
		 ['string', 'Pie'],
		);

my @@ref = (['unblessed SV', do {\my $whap}],
	   ['unblessed AV', []],
	   ['unblessed HV', {}],
	   ['unblessed CV', sub {}],
	   ['unblessed GV', \*STDOUT],
	   ['no overloading', bless {}, 'None'],
	   ['other overloading', bless {}, 'Other'],
	   ['same overloading', bless {}, 'Same'],
	  );

while (my ($type, $enum) = each %types) {
    foreach ([amagic_deref_call => \&amagic_deref_call],
	     [tryAMAGICunDEREF_var => \&tryAMAGICunDEREF_var],
	    ) {
	my ($name, $func) = @@$_;
	foreach (@@non_ref, @@ref,
		) {
	    my ($desc, $input) = @@$_;
	    my $got = &$func($input, $enum);
	    is($got, $input, "$name: expect no change for to_$type $desc");
	}
	foreach (@@non_ref) {
	    my ($desc, $sucker) = @@$_;
	    my $input = bless [$sucker], 'Chain';
	    is(eval {&$func($input, $enum)}, undef,
	       "$name: chain to $desc for to_$type");
	    like($@@, qr/Overloaded dereference did not return a reference/,
		 'expected error');
	}
	foreach (@@ref,
		) {
	    my ($desc, $sucker) = @@$_;
	    my $input = bless [$sucker], 'Chain';
	    my $got = &$func($input, $enum);
	    is($got, $sucker, "$name: chain to $desc for to_$type");
	    $input = bless [bless [$sucker], 'Chain'], 'Chain';
	    $got = &$func($input, $enum);
	    is($got, $sucker, "$name: chain to chain to $desc for to_$type");
	}
    }
}

done_testing;
@


1.1.1.1
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@@
