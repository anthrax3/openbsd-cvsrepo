head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.2
	OPENBSD_6_2_BASE:1.3
	PERL_5_24_2:1.1.1.15
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.14.0.2
	OPENBSD_5_9_BASE:1.1.1.14
	OPENBSD_5_8:1.1.1.14.0.4
	OPENBSD_5_8_BASE:1.1.1.14
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.1.1.13.0.2
	OPENBSD_5_7_BASE:1.1.1.13
	PERL_5_20_1:1.1.1.13
	OPENBSD_5_6:1.1.1.12.0.4
	OPENBSD_5_6_BASE:1.1.1.12
	PERL_5_18_2:1.1.1.12
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.11.0.6
	OPENBSD_5_5_BASE:1.1.1.11
	OPENBSD_5_4:1.1.1.11.0.2
	OPENBSD_5_4_BASE:1.1.1.11
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.1.1.10.0.14
	OPENBSD_5_3_BASE:1.1.1.10
	OPENBSD_5_2:1.1.1.10.0.12
	OPENBSD_5_2_BASE:1.1.1.10
	OPENBSD_5_1_BASE:1.1.1.10
	OPENBSD_5_1:1.1.1.10.0.10
	OPENBSD_5_0:1.1.1.10.0.8
	OPENBSD_5_0_BASE:1.1.1.10
	OPENBSD_4_9:1.1.1.10.0.6
	OPENBSD_4_9_BASE:1.1.1.10
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.1.1.10.0.4
	OPENBSD_4_8_BASE:1.1.1.10
	OPENBSD_4_7:1.1.1.10.0.2
	OPENBSD_4_7_BASE:1.1.1.10
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.1.1.9.0.6
	OPENBSD_4_6_BASE:1.1.1.9
	OPENBSD_4_5:1.1.1.9.0.2
	OPENBSD_4_5_BASE:1.1.1.9
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.1.1.8.0.10
	OPENBSD_4_4_BASE:1.1.1.8
	OPENBSD_4_3:1.1.1.8.0.8
	OPENBSD_4_3_BASE:1.1.1.8
	OPENBSD_4_2:1.1.1.8.0.6
	OPENBSD_4_2_BASE:1.1.1.8
	OPENBSD_4_1:1.1.1.8.0.4
	OPENBSD_4_1_BASE:1.1.1.8
	OPENBSD_4_0:1.1.1.8.0.2
	OPENBSD_4_0_BASE:1.1.1.8
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.1.1.7.0.6
	OPENBSD_3_9_BASE:1.1.1.7
	OPENBSD_3_8:1.1.1.7.0.4
	OPENBSD_3_8_BASE:1.1.1.7
	OPENBSD_3_7:1.1.1.7.0.2
	OPENBSD_3_7_BASE:1.1.1.7
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.1.1.6.0.2
	OPENBSD_3_6_BASE:1.1.1.6
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.32.12;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2016.07.03.01.08.00;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	GzHqjSTnBjdF7Wcw;

1.1
date	99.04.29.22.38.43;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.38.43;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.11;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.48;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.49;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.46.17;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.01.15.21.16.55;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.48.14;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.21;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.11.15;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.08.44;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.11.17.20.53.05;	author afresh1;	state Exp;
branches;
next	1.1.1.14;
commitid	B31cAbBIXiCqnL97;

1.1.1.14
date	2015.04.25.19.10.36;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.15
date	2017.08.14.13.46.11;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@use ExtUtils::MakeMaker;
use Config;
use strict;

our $VERSION = "1.25";

my %err = ();

# Symbian cross-compiling environment.
my $IsSymbian = exists $ENV{SDK} && -d "$ENV{SDK}\\epoc32";

my $IsMSWin32 = $^O eq 'MSWin32' && !$IsSymbian;

unlink "Errno.pm" if -f "Errno.pm";
unlink "Errno.tmp" if -f "Errno.tmp";
open OUT, ">Errno.tmp" or die "Cannot open Errno.tmp: $!";
select OUT;
my $file;
my @@files = get_files();
if ($Config{gccversion} ne '' && $^O eq 'MSWin32') {
    # MinGW complains "warning: #pragma system_header ignored outside include
    # file" if the header files are processed individually, so include them
    # all in .c file and process that instead.
    open INCS, '>includes.c' or
	die "Cannot open includes.c";
    foreach $file (@@files) {
	next if $file eq 'errno.c';
	next unless -f $file;
	print INCS qq[#include "$file"\n];
    }
    close INCS;
    process_file('includes.c');
    unlink 'includes.c';
}
else {
    foreach $file (@@files) {
	process_file($file);
    }
}
write_errno_pm();
unlink "errno.c" if -f "errno.c";
close OUT or die "Error closing Errno.tmp: $!";
select STDOUT;
rename "Errno.tmp", "Errno.pm" or die "Cannot rename Errno.tmp to Errno.pm: $!";

sub process_file {
    my($file) = @@_;

    # for win32 perl under cygwin, we need to get a windows pathname
    if ($^O eq 'MSWin32' && $Config{cc} =~ /\B-mno-cygwin\b/ &&
        defined($file) && !-f $file) {
        chomp($file = `cygpath -w "$file"`);
    }

    return unless defined $file and -f $file;
#    warn "Processing $file\n";

    local *FH;
    if (($^O eq 'VMS') && ($Config{vms_cc_type} ne 'gnuc')) {
	unless(open(FH," LIBRARY/EXTRACT=ERRNO/OUTPUT=SYS\$OUTPUT $file |")) {
            warn "Cannot open '$file'";
            return;
	}     
    } elsif ($Config{gccversion} ne '' && $^O ne 'darwin' ) {
	# With the -dM option, gcc outputs every #define it finds
	unless(open(FH,"$Config{cc} -E -dM $Config{cppflags} $file |")) {
            warn "Cannot open '$file'";
            return;
	}     
    } else {
	unless(open(FH,"< $file")) {
	    # This file could be a temporary file created by cppstdin
	    # so only warn under -w, and return
            warn "Cannot open '$file'" if $^W;
            return;
	}
    }
    
    my $pat;
    if ($IsMSWin32) {
	$pat = '^\s*#\s*define\s+((?:WSA)?E\w+)\s+';
    }
    else {
	$pat = '^\s*#\s*define\s+(E\w+)\s+';
    }
    while(<FH>) {
	$err{$1} = 1
	    if /$pat/;
    }

    close(FH);
}

my $cppstdin;

sub default_cpp {
    unless (defined $cppstdin) {
	use File::Spec;
	$cppstdin = $Config{cppstdin};
	my $upup_cppstdin = File::Spec->catfile(File::Spec->updir,
						File::Spec->updir,
						"cppstdin");
	my $cppstdin_is_wrapper =
	    ($cppstdin eq 'cppstdin'
		and -f $upup_cppstdin
		    and -x $upup_cppstdin);
	$cppstdin = $upup_cppstdin if $cppstdin_is_wrapper;
    }
    return "$cppstdin $Config{cppflags} $Config{cppminus}";
}

sub get_files {
    my %file = ();
    # VMS keeps its include files in system libraries
    if ($^O eq 'VMS') {
	$file{'Sys$Library:DECC$RTLDEF.TLB'} = 1;
    } elsif ($^O eq 'os390') {
	# OS/390 C compiler doesn't generate #file or #line directives
	$file{'/usr/include/errno.h'} = 1;
    } elsif ($Config{archname} eq 'arm-riscos') {
	# Watch out for cross compiling for RISC OS
	my $dep = `echo "#include <errno.h>" | gcc -E -M -`;
	if ($dep =~ /(\S+errno\.h)/) {
	     $file{$1} = 1;
	}
    } elsif ($^O eq 'linux' &&
	      $Config{gccversion} ne '' && 
	      $Config{gccversion} !~ /intel/i
	      # might be using, say, Intel's icc
	     ) {
    # When cross-compiling we may store a path for gcc's "sysroot" option:
    my $sysroot = $Config{sysroot} || '';
	# Some Linuxes have weird errno.hs which generate
	# no #file or #line directives
	my ($linux_errno_h) = grep { -e $_ } map { "$_/errno.h" }
	    "$sysroot/usr/include", "$sysroot/usr/local/include",
	    split / / => $Config{locincpth} or
		die "Cannot find errno.h";
	$file{$linux_errno_h} = 1;
    } elsif ($^O eq 'haiku') {
	# hidden in a special place
	$file{'/boot/develop/headers/posix/errno.h'} = 1;

    } elsif ($^O eq 'vos') {
	# avoid problem where cpp returns non-POSIX pathnames
	$file{'/system/include_library/errno.h'} = 1;
    } elsif ($IsSymbian) {
        my $SDK = $ENV{SDK};
        $SDK =~ s!\\!/!g;
	$file{"$SDK/epoc32/include/libc/sys/errno.h"} = 1;
    } else {
	open(CPPI,"> errno.c") or
	    die "Cannot open errno.c";

	if ($^O eq 'NetWare') {
	    print CPPI "#include <nwerrno.h>\n";
	} else {
	    print CPPI "#include <errno.h>\n";
	    if ($IsMSWin32) {
		print CPPI qq[#include "../../win32/include/sys/errno2.h"\n];
	    }
	}

	close(CPPI);

	# invoke CPP and read the output
	if ($IsMSWin32 || $^O eq 'NetWare') {
	    open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
		die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
	} else {
	    my $cpp = default_cpp();
	    open(CPPO,"$cpp < errno.c |") or
		die "Cannot exec $cpp";
	}

	my $pat = '^#\s*(?:line)?\s*\d+\s+"([^"]+)"';
	while(<CPPO>) {
	    if ($^O eq 'os2' or $IsMSWin32 or $^O eq 'NetWare') {
		if (/$pat/o) {
		   my $f = $1;
		   $f =~ s,\\\\,/,g;
		   $file{$f} = 1;
		}
	    }
	    else {
		$file{$1} = 1 if /$pat/o;
	    }
	}
	close(CPPO);
    }
    return keys %file;
}

sub write_errno_pm {
    my $err;

    # quick sanity check

    die "No error definitions found" unless keys %err;

    # create the CPP input

    open(CPPI,"> errno.c") or
	die "Cannot open errno.c";

    if ($^O eq 'NetWare') {
	print CPPI "#include <nwerrno.h>\n";
	} 
    else {
	print CPPI "#include <errno.h>\n";
    }
    if ($IsMSWin32) {
	print CPPI qq[#include "../../win32/include/sys/errno2.h"\n];
    }
 
    foreach $err (keys %err) {
	print CPPI '"',$err,'" [[',$err,']]',"\n";
    }

    close(CPPI);

    {	# BeOS (support now removed) did not enter this block
    # invoke CPP and read the output

	my $inhibit_linemarkers = '';
	if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
	    # GCC 5.0 interleaves expanded macros with line numbers breaking
	    # each line into multiple lines. RT#123784
	    $inhibit_linemarkers = ' -P';
	}

	if ($^O eq 'VMS') {
	    my $cpp = "$Config{cppstdin} $Config{cppflags}" .
		$inhibit_linemarkers . " $Config{cppminus}";
	    $cpp =~ s/sys\$input//i;
	    open(CPPO,"$cpp  errno.c |") or
		die "Cannot exec $Config{cppstdin}";
	} elsif ($IsMSWin32 || $^O eq 'NetWare') {
	    my $cpp = "$Config{cpprun} $Config{cppflags}" .
		$inhibit_linemarkers;
	    open(CPPO,"$cpp errno.c |") or
		die "Cannot run '$cpp errno.c'";
	} elsif ($IsSymbian) {
            my $cpp = "gcc -E -I$ENV{SDK}\\epoc32\\include\\libc" .
		$inhibit_linemarkers ." -";
	    open(CPPO,"$cpp < errno.c |")
		or die "Cannot exec $cpp";
        } else {
	    my $cpp = default_cpp() . $inhibit_linemarkers;
	    open(CPPO,"$cpp < errno.c |")
		or die "Cannot exec $cpp";
	}

	%err = ();

	while(<CPPO>) {
	    my($name,$expr);
	    next unless ($name, $expr) = /"(.*?)"\s*\[\s*\[\s*(.*?)\s*\]\s*\]/;
	    next if $name eq $expr;
	    $expr =~ s/\(?\(\s*[a-z_]\w*\s*\)\(?([^\)]+)\)?\)?/$1/i; # ((type)0xcafebabe) at alia
	    $expr =~ s/\b((?:0x)?[0-9a-f]+)[LU]+\b/$1/gi; # 2147483647L et alia
	    next if $expr =~ m/\b[a-z_]\w*\b/i; # skip expressions containing function names etc
	    if($expr =~ m/^0[xX]/) {
		$err{$name} = hex $expr;
	    }
	    else {
		$err{$name} = eval $expr;
	    }
	    delete $err{$name} unless defined $err{$name};
	}
	close(CPPO);
    }

    # escape $Config{'archname'}
    my $archname = $Config{'archname'};
    $archname =~ s/([@@%\$])/\\$1/g;

    # Write Errno.pm

    print <<"EDQ";
# -*- buffer-read-only: t -*-
#
# This file is auto-generated. ***ANY*** changes here will be lost
#

package Errno;
require Exporter;
use strict;

EDQ

    # Errno only needs Config to make sure it hasn't changed platforms.
    # If someone set $ENV{PERL_BUILD_EXPAND_CONFIG_VARS} at build time,
    # they've already declared perl doesn't need to worry about this risk.
    if(!$ENV{'PERL_BUILD_EXPAND_CONFIG_VARS'}) {
        print <<"CONFIG_CHECK_END";
use Config;
"\$Config{'archname'}-\$Config{'osvers'}" eq
"$archname-$Config{'osvers'}" or
	die "Errno architecture ($archname-$Config{'osvers'}) does not match executable architecture (\$Config{'archname'}-\$Config{'osvers'})";

CONFIG_CHECK_END
}

    print <<"EDQ";
our \$VERSION = "$VERSION";
\$VERSION = eval \$VERSION;
our \@@ISA = 'Exporter';

my %err;

BEGIN {
    %err = (
EDQ

    my @@err = sort { $err{$a} <=> $err{$b} || $a cmp $b }
	grep { $err{$_} =~ /-?\d+$/ } keys %err;

    foreach $err (@@err) {
	print "\t$err => $err{$err},\n";
    }

print <<'ESQ';
    );
    # Generate proxy constant subroutines for all the values.
    # Well, almost all the values. Unfortunately we can't assume that at this
    # point that our symbol table is empty, as code such as if the parser has
    # seen code such as C<exists &Errno::EINVAL>, it will have created the
    # typeglob.
    # Doing this before defining @@EXPORT_OK etc means that even if a platform is
    # crazy enough to define EXPORT_OK as an error constant, everything will
    # still work, because the parser will upgrade the PCS to a real typeglob.
    # We rely on the subroutine definitions below to update the internal caches.
    # Don't use %each, as we don't want a copy of the value.
    foreach my $name (keys %err) {
        if ($Errno::{$name}) {
            # We expect this to be reached fairly rarely, so take an approach
            # which uses the least compile time effort in the common case:
            eval "sub $name() { $err{$name} }; 1" or die $@@;
        } else {
            $Errno::{$name} = \$err{$name};
        }
    }
}

our @@EXPORT_OK = keys %err;

our %EXPORT_TAGS = (
    POSIX => [qw(
ESQ

    my $k = join(" ", grep { exists $err{$_} } 
	qw(E2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT
	EAGAIN EALREADY EBADF EBUSY ECHILD ECONNABORTED
	ECONNREFUSED ECONNRESET EDEADLK EDESTADDRREQ EDOM EDQUOT
	EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH EINPROGRESS
	EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK
	EMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH
	ENFILE ENOBUFS ENODEV ENOENT ENOEXEC ENOLCK ENOMEM
	ENOPROTOOPT ENOSPC ENOSYS ENOTBLK ENOTCONN ENOTDIR
	ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM
	EPFNOSUPPORT EPIPE EPROCLIM EPROTONOSUPPORT EPROTOTYPE
	ERANGE EREMOTE ERESTART EROFS ESHUTDOWN ESOCKTNOSUPPORT
	ESPIPE ESRCH ESTALE ETIMEDOUT ETOOMANYREFS ETXTBSY
	EUSERS EWOULDBLOCK EXDEV));

    $k =~ s/(.{50,70})\s/$1\n\t/g;
    print "\t",$k,"\n    )],\n";

    if ($IsMSWin32) {
	print "    WINSOCK => [qw(\n";
	$k = join(" ", grep { /^WSAE/ } keys %err);
	$k =~ s/(.{50,70})\s/$1\n\t/g;
	print "\t",$k,"\n    )],\n";
    }

    print ");\n\n";

    print <<'ESQ';
sub TIEHASH { bless \%err }

sub FETCH {
    my (undef, $errname) = @@_;
    return "" unless exists $err{$errname};
    my $errno = $err{$errname};
    return $errno == $! ? $errno : 0;
}

sub STORE {
    require Carp;
    Carp::confess("ERRNO hash is read only!");
}

*CLEAR = *DELETE = \*STORE; # Typeglob aliasing uses less space

sub NEXTKEY {
    each %err;
}

sub FIRSTKEY {
    my $s = scalar keys %err;	# initialize iterator
    each %err;
}

sub EXISTS {
    my (undef, $errname) = @@_;
    exists $err{$errname};
}

tie %!, __PACKAGE__; # Returns an object, objects are true.

__END__

=head1 NAME

Errno - System errno constants

=head1 SYNOPSIS

    use Errno qw(EINTR EIO :POSIX);

=head1 DESCRIPTION

C<Errno> defines and conditionally exports all the error constants
defined in your system F<errno.h> include file. It has a single export
tag, C<:POSIX>, which will export all POSIX defined error numbers.

On Windows, C<Errno> also defines and conditionally exports all the
Winsock error constants defined in your system F<WinError.h> include
file. These are included in a second export tag, C<:WINSOCK>.

C<Errno> also makes C<%!> magic such that each element of C<%!> has a
non-zero value only if C<$!> is set to that value. For example:

    use Errno;

    unless (open(FH, "/fangorn/spouse")) {
        if ($!{ENOENT}) {
            warn "Get a wife!\n";
        } else {
            warn "This path is barred: $!";
        } 
    } 

If a specified constant C<EFOO> does not exist on the system, C<$!{EFOO}>
returns C<"">.  You may use C<exists $!{EFOO}> to check whether the
constant is available on the system.

=head1 CAVEATS

Importing a particular constant may not be very portable, because the
import will fail on platforms that do not have that constant.  A more
portable way to set C<$!> to a valid value is to use:

    if (exists &Errno::EFOO) {
        $! = &Errno::EFOO;
    }

=head1 AUTHOR

Graham Barr <gbarr@@pobox.com>

=head1 COPYRIGHT

Copyright (c) 1997-8 Graham Barr. All rights reserved.
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

# ex: set ro:
ESQ

}
@


1.2
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d5 1
a5 1
our $VERSION = "1.20_06";
d64 1
a64 5
    } elsif ($Config{gccversion} ne ''
             # OpenSTEP has gcc 2.7.2.1 which recognizes but
	     # doesn't implement the -dM flag.
	     && $^O ne 'openstep' && $^O ne 'next' && $^O ne 'darwin'
	     ) { 
d79 7
d88 1
a88 1
	    if /^\s*#\s*define\s+(E\w+)\s+/;
d114 1
a114 1
    # VMS keeps its include files in system libraries (well, except for Gcc)
d116 1
a116 7
	if ($Config{vms_cc_type} eq 'decc') {
	    $file{'Sys$Library:DECC$RTLDEF.TLB'} = 1;
	} elsif ($Config{vms_cc_type} eq 'vaxc') {
	    $file{'Sys$Library:vaxcdef.tlb'} = 1;
	} elsif ($Config{vms_cc_type} eq 'gcc') {
	    $file{'gnu_cc_include:[000000]errno.h'} = 1;
	}
a287 1
use Config;
d290 8
d302 4
d368 10
a377 1
    print "\t",$k,"\n    )]\n);\n\n";
d425 1
a425 1
defined in your system C<errno.h> include file. It has a single export
d427 4
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
use vars qw($VERSION);
d7 4
a10 1
$VERSION = "1.111";
d12 1
a12 1
my %err = ();
d15 2
a16 1
open OUT, ">Errno.pm" or die "Cannot open Errno.pm: $!";
d19 20
a38 2
foreach $file (get_files()) {
    process_file($file);
d42 3
d49 6
d56 1
d64 10
d82 1
d86 3
a88 2
   }
   close(FH);
d123 31
a153 3
    } elsif ($^O eq 'vmesa') {
	# OS/390 C compiler doesn't generate #file or #line directives
	$file{'../../vmesa/errno.h'} = 1;
d158 8
a165 1
	print CPPI "#include <errno.h>\n";
d170 1
a170 1
	if ($^O eq 'MSWin32') {
d179 1
a179 7
	my $pat;
	if ($^O eq 'MSWin32' and $Config{cc} =~ /^bcc/i) {
	    $pat = '^/\*\s+(.+)\s+\d+\s*:\s+\*/';
	}
	else {
	    $pat = '^#(?:line)?\s*\d+\s+"([^"]+)"';
	}
d181 1
a181 1
	    if ($^O eq 'os2' or $^O eq 'MSWin32') {
d209 10
a218 2
    print CPPI "#include <errno.h>\n";

d225 1
d228 28
a255 13
    if ($^O eq 'VMS') {
	my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
	$cpp =~ s/sys\$input//i;
	open(CPPO,"$cpp  errno.c |") or
          die "Cannot exec $Config{cppstdin}";
    } elsif ($^O eq 'MSWin32') {
	open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
	    die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
    } else {
	my $cpp = default_cpp();
	open(CPPO,"$cpp < errno.c |")
	    or die "Cannot exec $cpp";
    }
d257 1
a257 1
    %err = ();
d259 16
a274 5
    while(<CPPO>) {
	my($name,$expr);
	next unless ($name, $expr) = /"(.*?)"\s*\[\s*\[\s*(.*?)\s*\]\s*\]/;
	next if $name eq $expr;
	$err{$name} = eval $expr;
d276 4
a279 1
    close(CPPO);
d284 1
d290 1
a290 2
use vars qw(\@@EXPORT_OK \%EXPORT_TAGS \@@ISA \$VERSION \%errno \$AUTOLOAD);
use Exporter ();
d294 7
a300 2
\$Config{'myarchname'} eq "$Config{'myarchname'}" or
	die "Errno architecture ($Config{'myarchname'}) does not match executable architecture (\$Config{'myarchname'})";
d302 1
a302 2
\$VERSION = "$VERSION";
\@@ISA = qw(Exporter);
d304 2
d307 7
a313 8
   
    my $len = 0;
    my @@err = sort { $err{$a} <=> $err{$b} } keys %err;
    map { $len = length if length > $len } @@err;

    my $j = "\@@EXPORT_OK = qw(" . join(" ",keys %err) . ");\n";
    $j =~ s/(.{50,70})\s/$1\n\t/g;
    print $j,"\n";
d316 25
a340 1
%EXPORT_TAGS = (
a361 4
    foreach $err (@@err) {
	printf "sub %s () { %d }\n",,$err,$err{$err};
    }

d363 1
a363 2

sub TIEHASH { bless [] }
d366 5
a370 9
    my ($self, $errname) = @@_;
    my $proto = prototype("Errno::$errname");
    if (defined($proto) && $proto eq "") {
	no strict 'refs';
        return $! == &$errname;
    }
    require Carp;
    Carp::confess("No errno $errname");
} 
d377 1
a377 2
*CLEAR = \&STORE;
*DELETE = \&STORE;
d380 1
a380 7
    my($k,$v);
    while(($k,$v) = each %Errno::) {
	my $proto = prototype("Errno::$k");
	last if (defined($proto) && $proto eq "");
	
    }
    $k
d384 2
a385 2
    my $s = scalar keys %Errno::;
    goto &NEXTKEY;
d389 2
a390 3
    my ($self, $errname) = @@_;
    my $proto = prototype($errname);
    defined($proto) && $proto eq "";
d393 1
a393 1
tie %!, __PACKAGE__;
a394 1
1;
d411 2
a412 2
C<Errno> also makes C<%!> magic such that each element of C<%!> has a non-zero
value only if C<$!> is set to that value, eg
d415 1
a415 1
    
d424 14
d450 1
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d183 2
a184 3
"\$Config{'archname'}-\$Config{'osvers'}" eq
"$Config{'archname'}-$Config{'osvers'}" or
	die "Errno architecture ($Config{'archname'}-$Config{'osvers'}) does not match executable architecture (\$Config{'archname'}-\$Config{'osvers'})";
a232 1
    my $errno = "";
d235 1
a235 2
	$errno = &$errname;
        $errno = 0 unless $! == $errno;
d237 3
a239 2
    return $errno;
}
d254 1
d260 1
a260 1
    my $s = scalar keys %Errno::;	# initialize iterator
d289 2
a290 2
C<Errno> also makes C<%!> magic such that each element of C<%!> has a
non-zero value only if C<$!> is set to that value. For example:
d293 1
a293 1

a300 14

If a specified constant C<EFOO> does not exist on the system, C<$!{EFOO}>
returns C<"">.  You may use C<exists $!{EFOO}> to check whether the
constant is available on the system.

=head1 CAVEATS

Importing a particular constant may not be very portable, because the
import will fail on platforms that do not have that constant.  A more
portable way to set C<$!> to a valid value is to use:

    if (exists &Errno::EFOO) {
        $! = &Errno::EFOO;
    }
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@a31 8
    } elsif ($Config{gccversion} ne '') { 
	# With the -dM option, gcc outputs every #define it finds
	my $ccopts = "-E -dM ";
	$ccopts .= "-traditional-cpp " if $^O eq 'darwin';
	unless(open(FH,"$Config{cc} $ccopts $file |")) {
            warn "Cannot open '$file'";
            return;
	}     
d40 5
a44 13

    if ($^O eq 'MacOS') {
	while(<FH>) {
	    $err{$1} = $2
		if /^\s*#\s*define\s+(E\w+)\s+(\d+)/;
	}
    } else {
	while(<FH>) {
	    $err{$1} = 1
		if /^\s*#\s*define\s+(E\w+)\s+/;
	}
    }
    close(FH);
a81 12
    } elsif ($Config{archname} eq 'epoc') {
	# Watch out for cross compiling for EPOC (usually done on linux)
	$file{'/usr/local/epoc/include/libc/sys/errno.h'} = 1;
    } elsif ($^O eq 'linux') {
	# Some Linuxes have weird errno.hs which generate
	# no #file or #line directives
	$file{'/usr/include/errno.h'} = 1;
    } elsif ($^O eq 'MacOS') {
	# note that we are only getting the GUSI errno's here ...
	# we might miss out on compiler-specific ones
	$file{"$ENV{GUSI}include:sys:errno.h"} = 1;

d105 1
a105 1
	    $pat = '^#\s*(?:line)?\s*\d+\s+"([^"]+)"';
a143 1
    unless ($^O eq 'MacOS') {	# trust what we have
d146 13
a158 13
	if ($^O eq 'VMS') {
	    my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
	    $cpp =~ s/sys\$input//i;
	    open(CPPO,"$cpp  errno.c |") or
		die "Cannot exec $Config{cppstdin}";
	} elsif ($^O eq 'MSWin32') {
	    open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
		die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
	} else {
	    my $cpp = default_cpp();
	    open(CPPO,"$cpp < errno.c |")
		or die "Cannot exec $cpp";
	}
d160 1
a160 1
	%err = ();
d162 5
a166 7
	while(<CPPO>) {
	    my($name,$expr);
	    next unless ($name, $expr) = /"(.*?)"\s*\[\s*\[\s*(.*?)\s*\]\s*\]/;
	    next if $name eq $expr;
	    $err{$name} = eval $expr;
	}
	close(CPPO);
d168 1
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d5 3
a7 1
our $VERSION = "1.09_00";
a9 1
my %wsa = ();
a24 1
#   warn "Processing $file\n";
d32 1
a32 5
    } elsif ($Config{gccversion} ne ''
             # OpenSTEP has gcc 2.7.2.1 which recognizes but
	     # doesn't implement the -dM flag.
	     && $^O ne 'openstep' && $^O ne 'next' && $^O ne 'darwin'
	     ) { 
d34 3
a36 1
	unless(open(FH,"$Config{cc} -E -dM $Config{cppflags} $file |")) {
a57 4
            if ($^O eq 'MSWin32') {
	        $wsa{$1} = 1
	    	    if /^\s*#\s*define\s+WSA(E\w+)\s+/;
            }
d100 2
a101 4
	$file{'/usr/local/epocemx/epocsdk/include/libc/sys/errno.h'} = 1;
    } elsif ($^O eq 'linux' &&
	     $Config{gccversion} ne '' # might be using, say, Intel's icc
	     ) {
a109 7
    } elsif ($^O eq 'beos') {
	# hidden in a special place
	$file{'/boot/develop/headers/posix/errno.h'} = 1;

    } elsif ($^O eq 'vos') {
	# avoid problem where cpp returns non-POSIX pathnames
	$file{'/system/include_library/errno.h'} = 1;
d114 1
a114 9
	if ($^O eq 'NetWare') {
	    print CPPI "#include <nwerrno.h>\n";
	} else {
	    print CPPI "#include <errno.h>\n";
	    if ($^O eq 'MSWin32') {
		print CPPI "#define _WINSOCKAPI_\n"; # don't drag in everything
		print CPPI "#include <winsock.h>\n";
	    }
	}
d119 1
a119 1
	if ($^O eq 'MSWin32' || $^O eq 'NetWare') {
d129 1
a129 1
	if (($^O eq 'MSWin32' || $^O eq 'NetWare') and $Config{cc} =~ /^bcc/i) {
d136 1
a136 1
	    if ($^O eq 'os2' or $^O eq 'MSWin32' or $^O eq 'NetWare') {
d164 2
a165 16
    if ($^O eq 'NetWare') {
	print CPPI "#include <nwerrno.h>\n";
	} 
    else {
	print CPPI "#include <errno.h>\n";
    }
    if ($^O eq 'MSWin32') {
	print CPPI "#include <winsock.h>\n";
	foreach $err (keys %wsa) {
	    print CPPI "#ifndef $err\n";
	    print CPPI "#define $err WSA$err\n";
	    print CPPI "#endif\n";
	    $err{$err} = 1;
	}
    }
 
d180 1
a180 1
	} elsif ($^O eq 'MSWin32' || $^O eq 'NetWare') {
a194 1
	    $expr =~ s/(\d+)[LU]+\b/$1/g; # 2147483647L et alia
a199 34
    # Many of the E constants (including ENOENT, which is being
    # used in the Perl test suite a lot), are available only as
    # enums in BeOS, so compiling and executing some code is about
    # only way to find out what the numeric Evalues are.

    if ($^O eq 'beos') {
	if (open(C, ">errno.c")) {
	    my @@zero = grep { !$err{$_} } keys %err;
	    print C <<EOF;
#include <errno.h>
#include <stdio.h>
int main() {
EOF
            for (@@zero) {
		print C qq[printf("$_ %d\n", $_);]
	    }
            print C "}\n";
            close C;
            system("cc -o errno errno.c");
            unlink("errno.c");
            if (open(C, "./errno|")) {
		while (<C>) {
		    if (/^(\w+) (-?\d+)$/) { $err{$1} = $2 }
		}
		close(C);
	    } else {
		die "failed to execute ./errno: $!\n";
	    }
            unlink("errno");
        } else {
	    die "failed to create errno.c: $!\n";
	}
    }

d208 1
a208 1
our (\@@EXPORT_OK,\%EXPORT_TAGS,\@@ISA,\$VERSION,\%errno,\$AUTOLOAD);
a217 1
\$VERSION = eval \$VERSION;
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d232 1
a232 7
	    $expr =~ s/\(?\(\w+\)([^\)]*)\)?/$1/; # ((type)0xcafebabe) at alia
	    $expr =~ s/((?:0x)?[0-9a-fA-F]+)[LU]+\b/$1/g; # 2147483647L et alia
	    next if $expr =~ m/^[a-zA-Z]+$/; # skip some Win32 functions
	    if($expr =~ m/^0[xX]/) {
		$err{$name} = hex $expr;
	    }
	    else {
a233 2
	}
	    delete $err{$name} unless defined $err{$name};
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d112 1
a112 3
	my $linux_errno_h = -e '/usr/include/errno.h' ?
	    '/usr/include/errno.h' : '/usr/local/include/errno.h';
	$file{$linux_errno_h} = 1;
@


1.1.1.7
log
@perl 5.8.6 from CPAN
@
text
@d380 1
a380 2
    my $r = ref $errname;
    my $proto = !$r || $r eq 'CODE' ? prototype($errname) : undef;
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d5 1
a5 1
our $VERSION = "1.09_01";
d14 2
a15 20
my @@files = get_files();
if ($Config{gccversion} ne '' && $^O eq 'MSWin32') {
    # MinGW complains "warning: #pragma system_header ignored outside include
    # file" if the header files are processed individually, so include them
    # all in .c file and process that instead.
    open INCS, '>includes.c' or
	die "Cannot open includes.c";
    foreach $file (@@files) {
	next if $file eq 'errno.c';
	next unless -f $file;
	print INCS qq[#include "$file"\n];
    }
    close INCS;
    process_file('includes.c');
    unlink 'includes.c';
}
else {
    foreach $file (@@files) {
	process_file($file);
    }
a22 6
    # for win32 perl under cygwin, we need to get a windows pathname
    if ($^O eq 'MSWin32' && $Config{cc} =~ /\B-mno-cygwin\b/ &&
        defined($file) && !-f $file) {
        chomp($file = `cygpath -w "$file"`);
    }

d211 1
a211 1
    unless ($^O eq 'MacOS' || $^O eq 'beos') {	# trust what we have / get later
d234 1
a234 1
	    $expr =~ s/\(?\([a-z_]\w*\)([^\)]*)\)?/$1/i; # ((type)0xcafebabe) at alia
d251 1
a251 3
    # only way to find out what the numeric Evalues are. In fact above, we
    # didn't even bother to get the values of the ones that have numeric
    # values, since we can get all of them here, anyway.
d255 1
a255 1
	    my @@allerrs = keys %err;
d261 1
a261 1
            for (@@allerrs) {
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d5 1
a5 1
our $VERSION = "1.10";
a9 5
# Symbian cross-compiling environment.
my $IsSymbian = exists $ENV{SDK} && -d "$ENV{SDK}\\epoc32";

my $IsMSWin32 = $^O eq 'MSWin32' && !$IsSymbian;

d48 1
a48 1
#    warn "Processing $file\n";
d74 1
a74 1
    
d84 1
a84 1
            if ($IsMSWin32) {
a89 1

a130 6
    } elsif ($Config{archname} eq 'arm-riscos') {
	# Watch out for cross compiling for RISC OS
	my $dep = `echo "#include <errno.h>" | gcc -E -M -`;
	if ($dep =~ /(\S+errno\.h)/) {
	     $file{$1} = 1;
	}
d132 1
a132 3
	      $Config{gccversion} ne '' && 
	      $Config{gccversion} !~ /intel/i
	      # might be using, say, Intel's icc
a150 4
    } elsif ($IsSymbian) {
        my $SDK = $ENV{SDK};
        $SDK =~ s!\\!/!g;
	$file{"$SDK/epoc32/include/libc/sys/errno.h"} = 1;
d159 1
a159 1
	    if ($IsMSWin32) {
d168 1
a168 1
	if ($IsMSWin32 || $^O eq 'NetWare') {
d178 1
a178 1
	if (($IsMSWin32 || $^O eq 'NetWare') and $Config{cc} =~ /^bcc/i) {
d185 1
a185 1
	    if ($^O eq 'os2' or $IsMSWin32 or $^O eq 'NetWare') {
d219 1
a219 1
    if ($IsMSWin32) {
d243 1
a243 1
	} elsif ($IsMSWin32 || $^O eq 'NetWare') {
d246 1
a246 5
	} elsif ($IsSymbian) {
            my $cpp = "gcc -E -I$ENV{SDK}\\epoc32\\include\\libc -";
	    open(CPPO,"$cpp < errno.c |")
		or die "Cannot exec $cpp";
        } else {
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d5 1
a5 1
our $VERSION = "1.11";
d16 1
a16 2
unlink "Errno.tmp" if -f "Errno.tmp";
open OUT, ">Errno.tmp" or die "Cannot open Errno.tmp: $!";
a41 3
close OUT or die "Error closing Errno.tmp: $!";
select STDOUT;
rename "Errno.tmp", "Errno.pm" or die "Cannot rename Errno.tmp to Errno.pm: $!";
d158 1
a158 1
    } elsif ($^O eq 'beos' || $^O eq 'haiku') {
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d5 1
a5 1
our $VERSION = "1.15";
d84 13
a96 6
    while(<FH>) {
	$err{$1} = 1
	    if /^\s*#\s*define\s+(E\w+)\s+/;
	if ($IsMSWin32) {
	    $wsa{$1} = 1
		if /^\s*#\s*define\s+WSA(E\w+)\s+/;
d157 5
d199 7
a205 1
	my $pat = '^#\s*(?:line)?\s*\d+\s+"([^"]+)"';
a243 3
	    print CPPI "#if defined($err) && $err >= 100\n";
	    print CPPI "#undef $err\n";
	    print CPPI "#endif\n";
d257 1
a257 1
    unless ($^O eq 'beos') {	# trust what we have / get later
a333 4
    # escape $Config{'archname'}
    my $archname = $Config{'archname'};
    $archname =~ s/([@@%\$])/\\\1/g;

a336 1
# -*- buffer-read-only: t -*-
d342 2
a343 1
require Exporter;
d348 2
a349 2
"$archname-$Config{'osvers'}" or
	die "Errno architecture ($archname-$Config{'osvers'}) does not match executable architecture (\$Config{'archname'}-\$Config{'osvers'})";
d351 1
a351 1
our \$VERSION = "$VERSION";
d353 1
a353 3
our \@@ISA = 'Exporter';

my %err;
a354 2
BEGIN {
    %err = (
d356 8
a363 7

    my @@err = sort { $err{$a} <=> $err{$b} }
	grep { $err{$_} =~ /-?\d+$/ } keys %err;

    foreach $err (@@err) {
	print "\t$err => $err{$err},\n";
    }
d366 1
a366 25
    );
    # Generate proxy constant subroutines for all the values.
    # Well, almost all the values. Unfortunately we can't assume that at this
    # point that our symbol table is empty, as code such as if the parser has
    # seen code such as C<exists &Errno::EINVAL>, it will have created the
    # typeglob.
    # Doing this before defining @@EXPORT_OK etc means that even if a platform is
    # crazy enough to define EXPORT_OK as an error constant, everything will
    # still work, because the parser will upgrade the PCS to a real typeglob.
    # We rely on the subroutine definitions below to update the internal caches.
    # Don't use %each, as we don't want a copy of the value.
    foreach my $name (keys %err) {
        if ($Errno::{$name}) {
            # We expect this to be reached fairly rarely, so take an approach
            # which uses the least compile time effort in the common case:
            eval "sub $name() { $err{$name} }; 1" or die $@@;
        } else {
            $Errno::{$name} = \$err{$name};
        }
    }
}

our @@EXPORT_OK = keys %err;

our %EXPORT_TAGS = (
d388 4
d393 2
a394 1
sub TIEHASH { bless \%err }
d397 9
a405 4
    my (undef, $errname) = @@_;
    return "" unless exists $err{$errname};
    my $errno = $err{$errname};
    return $errno == $! ? $errno : 0;
d413 2
a414 1
*CLEAR = *DELETE = \*STORE; # Typeglob aliasing uses less space
d417 6
a422 1
    each %err;
d426 2
a427 2
    my $s = scalar keys %err;	# initialize iterator
    each %err;
d431 4
a434 2
    my (undef, $errname) = @@_;
    exists $err{$errname};
d437 1
a437 1
tie %!, __PACKAGE__; # Returns an object, objects are true.
d439 1
a494 1
# ex: set ro:
@


1.1.1.12
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d5 1
a5 1
our $VERSION = "1.18";
d128 6
d150 1
a150 1
    } elsif ($^O eq 'haiku') {
d242 1
a242 1
    {	# BeOS (support now removed) did not enter this block
d281 36
@


1.1.1.13
log
@Import perl-5.20.1
@
text
@d5 1
a5 1
our $VERSION = "1.20_03";
d8 1
d87 4
a138 2
    # When cross-compiling we may store a path for gcc's "sysroot" option:
    my $sysroot = $Config{sysroot} || '';
d141 2
a142 4
	my ($linux_errno_h) = grep { -e $_ } map { "$_/errno.h" }
	    "$sysroot/usr/include", "$sysroot/usr/local/include",
	    split / / => $Config{locincpth} or
		die "Cannot find errno.h";
d164 2
a165 1
		print CPPI qq[#include "../../win32/include/sys/errno2.h"\n];
d218 10
a227 1
	print CPPI qq[#include "../../win32/include/sys/errno2.h"\n];
d263 2
a264 2
	    $expr =~ s/\(?\(\s*[a-z_]\w*\s*\)([^\)]*)\)?/$1/i; # ((type)0xcafebabe) at alia
	    $expr =~ s/((?:0x)?[0-9a-fA-F]+)[luLU]+\b/$1/g; # 2147483647L et alia
d270 2
a271 2
		$err{$name} = eval $expr;
	    }
d279 1
a279 1
    $archname =~ s/([@@%\$])/\\$1/g;
d308 1
a308 1
    my @@err = sort { $err{$a} <=> $err{$b} || $a cmp $b }
@


1.1.1.14
log
@Import perl-5.20.2
@
text
@d5 1
a5 1
our $VERSION = "1.20_05";
d252 3
a254 3
	    $expr =~ s/\(?\(\s*[a-z_]\w*\s*\)\(?([^\)]+)\)?\)?/$1/i; # ((type)0xcafebabe) at alia
	    $expr =~ s/\b((?:0x)?[0-9a-f]+)[LU]+\b/$1/gi; # 2147483647L et alia
	    next if $expr =~ m/\b[a-z_]\w*\b/i; # skip expressions containing function names etc
@


1.1.1.15
log
@Import perl-5.24.2
@
text
@d5 1
a5 1
our $VERSION = "1.25";
d64 5
a68 1
    } elsif ($Config{gccversion} ne '' && $^O ne 'darwin' ) {
a82 7
    my $pat;
    if ($IsMSWin32) {
	$pat = '^\s*#\s*define\s+((?:WSA)?E\w+)\s+';
    }
    else {
	$pat = '^\s*#\s*define\s+(E\w+)\s+';
    }
d85 1
a85 1
	    if /$pat/;
d111 1
a111 1
    # VMS keeps its include files in system libraries
d113 7
a119 1
	$file{'Sys$Library:DECC$RTLDEF.TLB'} = 1;
a227 7
	my $inhibit_linemarkers = '';
	if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
	    # GCC 5.0 interleaves expanded macros with line numbers breaking
	    # each line into multiple lines. RT#123784
	    $inhibit_linemarkers = ' -P';
	}

d229 1
a229 2
	    my $cpp = "$Config{cppstdin} $Config{cppflags}" .
		$inhibit_linemarkers . " $Config{cppminus}";
d234 2
a235 4
	    my $cpp = "$Config{cpprun} $Config{cppflags}" .
		$inhibit_linemarkers;
	    open(CPPO,"$cpp errno.c |") or
		die "Cannot run '$cpp errno.c'";
d237 1
a237 2
            my $cpp = "gcc -E -I$ENV{SDK}\\epoc32\\include\\libc" .
		$inhibit_linemarkers ." -";
d241 1
a241 1
	    my $cpp = default_cpp() . $inhibit_linemarkers;
d280 1
a282 8
EDQ

    # Errno only needs Config to make sure it hasn't changed platforms.
    # If someone set $ENV{PERL_BUILD_EXPAND_CONFIG_VARS} at build time,
    # they've already declared perl doesn't need to worry about this risk.
    if(!$ENV{'PERL_BUILD_EXPAND_CONFIG_VARS'}) {
        print <<"CONFIG_CHECK_END";
use Config;
a286 4
CONFIG_CHECK_END
}

    print <<"EDQ";
d349 1
a349 10
    print "\t",$k,"\n    )],\n";

    if ($IsMSWin32) {
	print "    WINSOCK => [qw(\n";
	$k = join(" ", grep { /^WSAE/ } keys %err);
	$k =~ s/(.{50,70})\s/$1\n\t/g;
	print "\t",$k,"\n    )],\n";
    }

    print ");\n\n";
d397 1
a397 1
defined in your system F<errno.h> include file. It has a single export
a398 4

On Windows, C<Errno> also defines and conditionally exports all the
Winsock error constants defined in your system F<WinError.h> include
file. These are included in a second export tag, C<:WINSOCK>.
@


