head	1.1;
branch	1.1.1;
access;
symbols
	PERL_5_24_2:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.18
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.16
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.10
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.12
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.4
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.8
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.3.0.6
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.2
	OPENBSD_5_4_BASE:1.1.1.3
	PERL_5_16_3:1.1.1.3
	OPENBSD_5_3:1.1.1.2.0.10
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.8
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.6
	OPENBSD_5_0:1.1.1.2.0.4
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.8
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.4
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2008.09.29.17.18.21;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.29.17.18.21;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.09.24.14.48.49;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.03.25.20.08.44;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

plan tests => 2;

use File::Temp;
use Fcntl qw(:mode);

my $tmpfile = File::Temp->new;
my $mode = (stat "$tmpfile")[2];
ok( S_ISREG($mode), " S_ISREG tmpfile");
ok(!S_ISDIR($mode), "!S_ISDIR tmpfile");
@


1.1.1.1
log
@import perl 5.10.0 from CPAN
@
text
@@


1.1.1.2
log
@Perl 5.12.2 from CPAN
@
text
@d4 3
a6 1
    require 'test.pl';
@


1.1.1.3
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d3 5
a7 1
use Test::More;
a9 2
use File::Spec;

d13 3
a15 82
my @@tests = (
	     ['REG', 'tmpfile', (stat "$tmpfile")[2]],
	     ['DIR', 'dir', (stat '.')[2]]
	    );

$devnull = File::Spec->devnull();
if (-c $devnull) {
    push @@tests, ['CHR', $devnull, (stat $devnull)[2]];
}

plan(tests => 34 + 6 + 9 * @@tests);
foreach (@@tests) {
    my ($type, $name, $mode) = @@$_;

    if ($type eq 'REG') {
	ok( S_ISREG($mode), " S_ISREG $name");
    } else {
	ok(!S_ISREG($mode), "!S_ISREG $name");
    }

    if ($type eq 'DIR') {
	ok( S_ISDIR($mode), " S_ISDIR $name");
    } else {
	ok(!S_ISDIR($mode), "!S_ISDIR $name");
    }

 SKIP: {
	skip 'No S_IFCHR', 1 unless defined eval {S_IFCHR};
	if ($type eq 'CHR') {
	    ok( S_ISCHR($mode), " S_ISCHR $name");
	} else {
	    ok(!S_ISCHR($mode), "!S_ISCHR $name");
	}
    }

 SKIP: {
	skip 'No S_IFLNK', 1 unless defined eval {S_IFLNK};
	ok(!S_ISLNK($mode), "!S_ISLNK $name");
    }
 SKIP: {
	skip 'No S_IFSOCK', 1 unless defined eval {S_IFSOCK};
	ok(!S_ISSOCK($mode), "!S_ISSOCK $name");
    }
 SKIP: {
	skip 'No S_IFBLK', 1 unless defined eval {S_IFBLK};
	ok(!S_ISBLK($mode), "!S_ISBLK $name");
    }
 SKIP: {
	skip 'No S_IFFIFO', 1 unless defined eval {S_IFFIFO};
	ok(!S_ISFIFO($mode), "!S_ISFIFO $name");
    }
 SKIP: {
	skip 'No S_IFWHT', 1 unless defined eval {S_IFWHT};
	ok(!S_ISWHT($mode), "!S_ISWHT $name");
    }
 SKIP: {
	skip 'No S_ENFMT', 1 unless defined eval {S_ENFMT};
	ok(!S_ISENFMT($mode), "!S_ISENFMT $name");
    }
}

foreach ([S_ISREG => \&S_ISREG],
	 [S_IMODE => \&S_IMODE],
	) {
    my ($name, $func) = @@$_;
    my @@warnings;
    my $ret;

    {
	local $SIG{__WARN__} = sub { push @@warnings, "@@_" };
	$ret = &$func();
    }
    ok(!$ret, "$name() is false");
    is(scalar @@warnings, 1, '1 warning');
    like($warnings[0], qr/^Use of uninitialized value/, 'expected warning');
}

is (S_IFMT(), _S_IFMT(), 'S_IFMT()');
is (S_IFMT(0), 0, 'S_IFMT(0)');
for my $shift (0..31) {
    is (S_IFMT(1 << $shift), ((1 << $shift) & _S_IFMT()), "S_IFMT(1 << $shift)");
}
@


