head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.18
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.16
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.10
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.12
	OPENBSD_5_8_BASE:1.7
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.7.0.8
	OPENBSD_5_6_BASE:1.7
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.6.0.42
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.40
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.38
	OPENBSD_5_0:1.6.0.36
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.34
	OPENBSD_4_9_BASE:1.6
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.6.0.32
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.28
	OPENBSD_4_7_BASE:1.6
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.6.0.30
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.26
	OPENBSD_4_5_BASE:1.6
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.6.0.24
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.22
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.20
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.18
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.16
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.6.0.14
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.7
date	2013.03.25.20.40.54;	author sthen;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.22;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.10;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.05.15;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.28;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.55.17;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.04;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.04;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.38.43;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.12;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.48;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.54;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.08.44;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.7
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#ifdef VMS
#  include <file.h>
#else
#if defined(__GNUC__) && defined(__cplusplus) && defined(WIN32)
#define _NO_OLDNAMES
#endif 
#  include <fcntl.h>
#if defined(__GNUC__) && defined(__cplusplus) && defined(WIN32)
#undef _NO_OLDNAMES
#endif 
#endif

#ifdef I_UNISTD
#include <unistd.h>
#endif

/* This comment is a kludge to get metaconfig to see the symbols
    VAL_O_NONBLOCK
    VAL_EAGAIN
    RD_NODATA
    EOF_NONBLOCK
   and include the appropriate metaconfig unit
   so that Configure will test how to turn on non-blocking I/O
   for a file descriptor.  See config.h for how to use these
   in your extension. 
   
   While I'm at it, I'll have metaconfig look for HAS_POLL too.
   --AD  October 16, 1995
*/

static void
XS_Fcntl_S_ISREG(pTHX_ CV* cv)
{
    dVAR;
    dXSARGS;
    dXSI32;
    /* Preserve the semantics of the perl code, which was:
       sub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }
    */
    SV *mode;

    PERL_UNUSED_VAR(cv); /* -W */
    SP -= items;

    if (items > 0)
	mode = ST(0);
    else {
	mode = &PL_sv_undef;
	EXTEND(SP, 1);
    }
    PUSHs(((SvUV(mode) & S_IFMT) == (UV)ix) ? &PL_sv_yes : &PL_sv_no);
    PUTBACK;
}

#include "const-c.inc"

MODULE = Fcntl		PACKAGE = Fcntl

INCLUDE: const-xs.inc

void
S_IMODE(...)
    PREINIT:
	dXSTARG;
	SV *mode;
    PPCODE:
	if (items > 0)
	   mode = ST(0);
	else {
	     mode = &PL_sv_undef;
 	     EXTEND(SP, 1);
	}
	PUSHu(SvUV(mode) & 07777);

void
S_IFMT(...)
    PREINIT:
	dXSTARG;
    PPCODE:
	PUSHu(items ? (SvUV(ST(0)) & S_IFMT) : S_IFMT);

BOOT:
    {
        CV *cv;
#ifdef S_IFREG
        cv = newXS("Fcntl::S_ISREG", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_IFREG;
#endif
#ifdef S_IFDIR
        cv = newXS("Fcntl::S_ISDIR", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_IFDIR;
#endif
#ifdef S_IFLNK
        cv = newXS("Fcntl::S_ISLNK", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_IFLNK;
#endif
#ifdef S_IFSOCK
        cv = newXS("Fcntl::S_ISSOCK", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_IFSOCK;
#endif
#ifdef S_IFBLK
        cv = newXS("Fcntl::S_ISBLK", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_IFBLK;
#endif
#ifdef S_IFCHR
        cv = newXS("Fcntl::S_ISCHR", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_IFCHR;
#endif
#ifdef S_IFIFO
        cv = newXS("Fcntl::S_ISFIFO", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_IFIFO;
#endif
#ifdef S_IFWHT
        cv = newXS("Fcntl::S_ISWHT", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_IFWHT;
#endif
#ifdef S_ENFMT
        cv = newXS("Fcntl::S_ISENFMT", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_ENFMT;
#endif
    }
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d36 24
d65 62
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d36 1
a36 737
static double
constant(char *name, int arg)
{
    errno = 0;
    switch (*name) {
    case '_':
	if (strEQ(name, "_S_IFMT")) /* Yes, on name _S_IFMT return S_IFMT. */
#ifdef S_IFMT
	  return S_IFMT;
#else
	  goto not_there;
#endif
	break;
    case 'F':
	if (strnEQ(name, "F_", 2)) {
	    if (strEQ(name, "F_ALLOCSP"))
#ifdef F_ALLOCSP
	        return F_ALLOCSP;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_ALLOCSP64"))
#ifdef F_ALLOCSP64
	        return F_ALLOCSP64;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_COMPAT"))
#ifdef F_COMPAT
	        return F_COMPAT;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_DUP2FD"))
#ifdef F_DUP2FD
	        return F_DUP2FD;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_DUPFD"))
#ifdef F_DUPFD
	        return F_DUPFD;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_EXLCK"))
#ifdef F_EXLCK
	        return F_EXLCK;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_FREESP"))
#ifdef F_FREESP
	        return F_FREESP;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_FREESP64"))
#ifdef F_FREESP64
	        return F_FREESP64;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_FSYNC"))
#ifdef F_FSYNC
	        return F_FSYNC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_FSYNC64"))
#ifdef F_FSYNC64
	        return F_FSYNC64;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_GETFD"))
#ifdef F_GETFD
	        return F_GETFD;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_GETFL"))
#ifdef F_GETFL
	        return F_GETFL;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_GETLK"))
#ifdef F_GETLK
	        return F_GETLK;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_GETLK64"))
#ifdef F_GETLK64
	        return F_GETLK64;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_GETOWN"))
#ifdef F_GETOWN
	        return F_GETOWN;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_NODNY"))
#ifdef F_NODNY
	        return F_NODNY;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_POSIX"))
#ifdef F_POSIX
	        return F_POSIX;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_RDACC"))
#ifdef F_RDACC
	        return F_RDACC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_RDDNY"))
#ifdef F_RDDNY
	        return F_RDDNY;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_RDLCK"))
#ifdef F_RDLCK
	        return F_RDLCK;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_RWACC"))
#ifdef F_RWACC
	        return F_RWACC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_RWDNY"))
#ifdef F_RWDNY
	        return F_RWDNY;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_SETFD"))
#ifdef F_SETFD
	        return F_SETFD;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_SETFL"))
#ifdef F_SETFL
	        return F_SETFL;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_SETLK"))
#ifdef F_SETLK
	        return F_SETLK;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_SETLK64"))
#ifdef F_SETLK64
	        return F_SETLK64;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_SETLKW"))
#ifdef F_SETLKW
	        return F_SETLKW;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_SETLKW64"))
#ifdef F_SETLKW64
	        return F_SETLKW64;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_SETOWN"))
#ifdef F_SETOWN
	        return F_SETOWN;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_SHARE"))
#ifdef F_SHARE
	        return F_SHARE;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_SHLCK"))
#ifdef F_SHLCK
	        return F_SHLCK;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_UNLCK"))
#ifdef F_UNLCK
	        return F_UNLCK;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_UNSHARE"))
#ifdef F_UNSHARE
	        return F_UNSHARE;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_WRACC"))
#ifdef F_WRACC
	        return F_WRACC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_WRDNY"))
#ifdef F_WRDNY
	        return F_WRDNY;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_WRLCK"))
#ifdef F_WRLCK
	        return F_WRLCK;
#else
	        goto not_there;
#endif
	    errno = EINVAL;
	    return 0;
	}
        if (strEQ(name, "FAPPEND"))
#ifdef FAPPEND
            return FAPPEND;
#else
            goto not_there;
#endif
        if (strEQ(name, "FASYNC"))
#ifdef FASYNC
            return FASYNC;
#else
            goto not_there;
#endif
        if (strEQ(name, "FCREAT"))
#ifdef FCREAT
            return FCREAT;
#else
            goto not_there;
#endif
	if (strEQ(name, "FD_CLOEXEC"))
#ifdef FD_CLOEXEC
	    return FD_CLOEXEC;
#else
	    goto not_there;
#endif
	if (strEQ(name, "FDEFER"))
#ifdef FDEFER
	    return FDEFER;
#else
	    goto not_there;
#endif
        if (strEQ(name, "FDSYNC"))
#ifdef FDSYNC
            return FDSYNC;
#else
            goto not_there;
#endif
        if (strEQ(name, "FEXCL"))
#ifdef FEXCL
            return FEXCL;
#else
            goto not_there;
#endif
        if (strEQ(name, "FLARGEFILE"))
#ifdef FLARGEFILE
            return FLARGEFILE;
#else
            goto not_there;
#endif
        if (strEQ(name, "FNDELAY"))
#ifdef FNDELAY
            return FNDELAY;
#else
            goto not_there;
#endif
        if (strEQ(name, "FNONBLOCK"))
#ifdef FNONBLOCK
            return FNONBLOCK;
#else
            goto not_there;
#endif
        if (strEQ(name, "FRSYNC"))
#ifdef FRSYNC
            return FRSYNC;
#else
            goto not_there;
#endif
        if (strEQ(name, "FSYNC"))
#ifdef FSYNC
            return FSYNC;
#else
            goto not_there;
#endif
        if (strEQ(name, "FTRUNC"))
#ifdef FTRUNC
            return FTRUNC;
#else
            goto not_there;
#endif
	break;
    case 'L':
    	if (strnEQ(name, "LOCK_", 5)) {
	    /* We support flock() on systems which don't have it, so
	       always supply the constants. */
	    if (strEQ(name, "LOCK_SH"))
#ifdef LOCK_SH
		return LOCK_SH;
#else
		return 1;
#endif
	    if (strEQ(name, "LOCK_EX"))
#ifdef LOCK_EX
		return LOCK_EX;
#else
		return 2;
#endif
    	    if (strEQ(name, "LOCK_NB"))
#ifdef LOCK_NB
		return LOCK_NB;
#else
		return 4;
#endif
    	    if (strEQ(name, "LOCK_UN"))
#ifdef LOCK_UN
    	    	return LOCK_UN;
#else
    	    	return 8;
#endif
	} else
	  goto not_there;
    	break;
    case 'O':
	if (strnEQ(name, "O_", 2)) {
	    if (strEQ(name, "O_ACCMODE"))
#ifdef O_ACCMODE
	        return O_ACCMODE;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_APPEND"))
#ifdef O_APPEND
	        return O_APPEND;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_ASYNC"))
#ifdef O_ASYNC
	        return O_ASYNC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_BINARY"))
#ifdef O_BINARY
	        return O_BINARY;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_CREAT"))
#ifdef O_CREAT
	        return O_CREAT;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_DEFER"))
#ifdef O_DEFER
	        return O_DEFER;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_DIRECT"))
#ifdef O_DIRECT
	        return O_DIRECT;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_DIRECTORY"))
#ifdef O_DIRECTORY
	        return O_DIRECTORY;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_DSYNC"))
#ifdef O_DSYNC
	        return O_DSYNC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_EXCL"))
#ifdef O_EXCL
	        return O_EXCL;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_EXLOCK"))
#ifdef O_EXLOCK
	        return O_EXLOCK;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_LARGEFILE"))
#ifdef O_LARGEFILE
	        return O_LARGEFILE;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_NDELAY"))
#ifdef O_NDELAY
	        return O_NDELAY;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_NOCTTY"))
#ifdef O_NOCTTY
	        return O_NOCTTY;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_NOFOLLOW"))
#ifdef O_NOFOLLOW
	        return O_NOFOLLOW;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_NOINHERIT"))
#ifdef O_NOINHERIT
	        return O_NOINHERIT;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_NONBLOCK"))
#ifdef O_NONBLOCK
	        return O_NONBLOCK;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_RANDOM"))
#ifdef O_RANDOM
	        return O_RANDOM;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_RAW"))
#ifdef O_RAW
	        return O_RAW;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_RDONLY"))
#ifdef O_RDONLY
	        return O_RDONLY;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_RDWR"))
#ifdef O_RDWR
	        return O_RDWR;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_RSYNC"))
#ifdef O_RSYNC
	        return O_RSYNC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_SEQUENTIAL"))
#ifdef O_SEQUENTIAL
	        return O_SEQUENTIAL;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_SHLOCK"))
#ifdef O_SHLOCK
	        return O_SHLOCK;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_SYNC"))
#ifdef O_SYNC
	        return O_SYNC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_TEMPORARY"))
#ifdef O_TEMPORARY
	        return O_TEMPORARY;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_TEXT"))
#ifdef O_TEXT
	        return O_TEXT;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_TRUNC"))
#ifdef O_TRUNC
	        return O_TRUNC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_WRONLY"))
#ifdef O_WRONLY
	        return O_WRONLY;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_ALIAS"))
#ifdef O_ALIAS
	        return O_ALIAS;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_RSRC"))
#ifdef O_RSRC
	        return O_RSRC;
#else
	        goto not_there;
#endif
	} else
	  goto not_there;
	break;
    case 'S':
      switch (name[1]) {
      case '_':
	if (strEQ(name, "S_ISUID"))
#ifdef S_ISUID
	  return S_ISUID;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_ISGID"))
#ifdef S_ISGID
	  return S_ISGID;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_ISVTX"))
#ifdef S_ISVTX
	  return S_ISVTX;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_ISTXT"))
#ifdef S_ISTXT
	  return S_ISTXT;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IFREG"))
#ifdef S_IFREG
	  return S_IFREG;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IFDIR"))
#ifdef S_IFDIR
	  return S_IFDIR;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IFLNK"))
#ifdef S_IFLNK
	  return S_IFLNK;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IFSOCK"))
#ifdef S_IFSOCK
	  return S_IFSOCK;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IFBLK"))
#ifdef S_IFBLK
	  return S_IFBLK;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IFCHR"))
#ifdef S_IFCHR
	  return S_IFCHR;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IFIFO"))
#ifdef S_IFIFO
	  return S_IFIFO;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IFWHT"))
#ifdef S_IFWHT
	  return S_IFWHT;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_ENFMT"))
#ifdef S_ENFMT
	  return S_ENFMT;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IRUSR"))
#ifdef S_IRUSR
	  return S_IRUSR;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IWUSR"))
#ifdef S_IWUSR
	  return S_IWUSR;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IXUSR"))
#ifdef S_IXUSR
	  return S_IXUSR;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IRWXU"))
#ifdef S_IRWXU
	  return S_IRWXU;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IRGRP"))
#ifdef S_IRGRP
	  return S_IRGRP;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IWGRP"))
#ifdef S_IWGRP
	  return S_IWGRP;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IXGRP"))
#ifdef S_IXGRP
	  return S_IXGRP;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IRWXG"))
#ifdef S_IRWXG
	  return S_IRWXG;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IROTH"))
#ifdef S_IROTH
	  return S_IROTH;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IWOTH"))
#ifdef S_IWOTH
	  return S_IWOTH;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IXOTH"))
#ifdef S_IXOTH
	  return S_IXOTH;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IRWXO"))
#ifdef S_IRWXO
	  return S_IRWXO;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IREAD"))
#ifdef S_IREAD
	  return S_IREAD;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IWRITE"))
#ifdef S_IWRITE
	  return S_IWRITE;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IEXEC"))
#ifdef S_IEXEC
	  return S_IEXEC;
#else
	  goto not_there;
#endif
	break;
      case 'E':
	  if (strEQ(name, "SEEK_CUR"))
#ifdef SEEK_CUR
	    return SEEK_CUR;
#else
	    return 1;
#endif
	if (strEQ(name, "SEEK_END"))
#ifdef SEEK_END
	    return SEEK_END;
#else
	    return 2;
#endif
	if (strEQ(name, "SEEK_SET"))
#ifdef SEEK_SET
	    return SEEK_SET;
#else
	    return 0;
#endif
	break;
      }    
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}

d40 1
a40 5
double
constant(name,arg)
	char *		name
	int		arg

@


1.4
log
@perl-5.6.0 + local changes
@
text
@a35 7
static int
not_here(char *s)
{
    croak("%s not implemented on this architecture", s);
    return -1;
}

@


1.3
log
@perl5.005_03 (stock)
@
text
@d1 1
d18 4
d48 8
d58 24
d94 24
d136 6
d148 6
d160 12
d178 12
d208 6
d220 6
d232 6
d250 18
d307 6
d319 6
d337 6
d425 12
d455 6
d473 12
d491 12
d521 6
d539 6
d563 12
d578 193
@


1.2
log
@perl 5.004_04
@
text
@d8 3
d12 3
d32 1
a32 2
not_here(s)
char *s;
d39 1
a39 3
constant(name, arg)
char *name;
int arg;
d51 6
d63 6
d81 3
a83 3
	    if (strEQ(name, "F_SETFD"))
#ifdef F_SETFD
	        return F_SETFD;
d87 3
a89 3
	    if (strEQ(name, "F_GETFL"))
#ifdef F_GETFL
	        return F_GETFL;
d93 3
a95 3
	    if (strEQ(name, "F_POSIX"))
#ifdef F_POSIX
	        return F_POSIX;
d123 3
a125 3
	    if (strEQ(name, "F_RDLCK"))
#ifdef F_RDLCK
	        return F_RDLCK;
d168 6
d238 24
d268 12
d286 3
a288 3
	    if (strEQ(name, "O_NOCTTY"))
#ifdef O_NOCTTY
	        return O_NOCTTY;
d292 3
a294 3
	    if (strEQ(name, "O_TRUNC"))
#ifdef O_TRUNC
	        return O_TRUNC;
d298 3
a300 3
	    if (strEQ(name, "O_APPEND"))
#ifdef O_APPEND
	        return O_APPEND;
a309 6
	    if (strEQ(name, "O_NDELAY"))
#ifdef O_NDELAY
	        return O_NDELAY;
#else
	        goto not_there;
#endif
d322 3
a324 15
	    if (strEQ(name, "O_WRONLY"))
#ifdef O_WRONLY
	        return O_WRONLY;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_BINARY"))
#ifdef O_BINARY
	        return O_BINARY;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_EXLOCK"))
#ifdef O_EXLOCK
	        return O_EXLOCK;
d334 3
a336 3
	    if (strEQ(name, "O_ASYNC"))
#ifdef O_ASYNC
	        return O_ASYNC;
d340 3
a342 3
	    if (strEQ(name, "O_DSYNC"))
#ifdef O_DSYNC
	        return O_DSYNC;
d346 3
a348 3
	    if (strEQ(name, "O_RSYNC"))
#ifdef O_RSYNC
	        return O_RSYNC;
d352 3
a354 9
	    if (strEQ(name, "O_SYNC"))
#ifdef O_SYNC
	        return O_SYNC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_DEFER"))
#ifdef O_DEFER
	        return O_DEFER;
@


1.1
log
@Initial revision
@
text
@d60 6
d78 6
d102 6
d128 20
a147 2
	} else
	  if (strEQ(name, "FD_CLOEXEC"))
d153 30
d184 31
d280 42
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a7 3
#if defined(__GNUC__) && defined(__cplusplus) && defined(WIN32)
#define _NO_OLDNAMES
#endif 
a8 3
#if defined(__GNUC__) && defined(__cplusplus) && defined(WIN32)
#undef _NO_OLDNAMES
#endif 
d26 2
a27 1
not_here(char *s)
d34 3
a36 1
constant(char *name, int arg)
a47 6
	    if (strEQ(name, "F_EXLCK"))
#ifdef F_EXLCK
	        return F_EXLCK;
#else
	        goto not_there;
#endif
a53 6
	    if (strEQ(name, "F_GETFL"))
#ifdef F_GETFL
	        return F_GETFL;
#else
	        goto not_there;
#endif
d60 3
a62 3
	    if (strEQ(name, "F_GETOWN"))
#ifdef F_GETOWN
	        return F_GETOWN;
d66 3
a68 15
	    if (strEQ(name, "F_POSIX"))
#ifdef F_POSIX
	        return F_POSIX;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_RDLCK"))
#ifdef F_RDLCK
	        return F_RDLCK;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_SETFD"))
#ifdef F_SETFD
	        return F_SETFD;
d90 3
a92 9
	    if (strEQ(name, "F_SETOWN"))
#ifdef F_SETOWN
	        return F_SETOWN;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_SHLCK"))
#ifdef F_SHLCK
	        return F_SHLCK;
d110 2
a111 20
	}
        if (strEQ(name, "FAPPEND"))
#ifdef FAPPEND
            return FAPPEND;
#else
            goto not_there;
#endif
        if (strEQ(name, "FASYNC"))
#ifdef FASYNC
            return FASYNC;
#else
            goto not_there;
#endif
        if (strEQ(name, "FCREAT"))
#ifdef FCREAT
            return FCREAT;
#else
            goto not_there;
#endif
	if (strEQ(name, "FD_CLOEXEC"))
a116 36
	if (strEQ(name, "FDEFER"))
#ifdef FDEFER
	    return FDEFER;
#else
	    goto not_there;
#endif
        if (strEQ(name, "FEXCL"))
#ifdef FEXCL
            return FEXCL;
#else
            goto not_there;
#endif
        if (strEQ(name, "FNDELAY"))
#ifdef FNDELAY
            return FNDELAY;
#else
            goto not_there;
#endif
        if (strEQ(name, "FNONBLOCK"))
#ifdef FNONBLOCK
            return FNONBLOCK;
#else
            goto not_there;
#endif
        if (strEQ(name, "FSYNC"))
#ifdef FSYNC
            return FSYNC;
#else
            goto not_there;
#endif
        if (strEQ(name, "FTRUNC"))
#ifdef FTRUNC
            return FTRUNC;
#else
            goto not_there;
#endif
a117 31
    case 'L':
    	if (strnEQ(name, "LOCK_", 5)) {
	    /* We support flock() on systems which don't have it, so
	       always supply the constants. */
	    if (strEQ(name, "LOCK_SH"))
#ifdef LOCK_SH
		return LOCK_SH;
#else
		return 1;
#endif
	    if (strEQ(name, "LOCK_EX"))
#ifdef LOCK_EX
		return LOCK_EX;
#else
		return 2;
#endif
    	    if (strEQ(name, "LOCK_NB"))
#ifdef LOCK_NB
		return LOCK_NB;
#else
		return 4;
#endif
    	    if (strEQ(name, "LOCK_UN"))
#ifdef LOCK_UN
    	    	return LOCK_UN;
#else
    	    	return 8;
#endif
	} else
	  goto not_there;
    	break;
a119 24
	    if (strEQ(name, "O_ACCMODE"))
#ifdef O_ACCMODE
	        return O_ACCMODE;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_APPEND"))
#ifdef O_APPEND
	        return O_APPEND;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_ASYNC"))
#ifdef O_ASYNC
	        return O_ASYNC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_BINARY"))
#ifdef O_BINARY
	        return O_BINARY;
#else
	        goto not_there;
#endif
a125 12
	    if (strEQ(name, "O_DEFER"))
#ifdef O_DEFER
	        return O_DEFER;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_DSYNC"))
#ifdef O_DSYNC
	        return O_DSYNC;
#else
	        goto not_there;
#endif
d132 3
a134 3
	    if (strEQ(name, "O_EXLOCK"))
#ifdef O_EXLOCK
	        return O_EXLOCK;
d138 3
a140 3
	    if (strEQ(name, "O_NDELAY"))
#ifdef O_NDELAY
	        return O_NDELAY;
d144 3
a146 3
	    if (strEQ(name, "O_NOCTTY"))
#ifdef O_NOCTTY
	        return O_NOCTTY;
d156 6
d174 3
a176 3
	    if (strEQ(name, "O_RSYNC"))
#ifdef O_RSYNC
	        return O_RSYNC;
d180 3
a182 27
	    if (strEQ(name, "O_SHLOCK"))
#ifdef O_SHLOCK
	        return O_SHLOCK;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_SYNC"))
#ifdef O_SYNC
	        return O_SYNC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_TEXT"))
#ifdef O_TEXT
	        return O_TEXT;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_TRUNC"))
#ifdef O_TRUNC
	        return O_TRUNC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_WRONLY"))
#ifdef O_WRONLY
	        return O_WRONLY;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a0 1
#define PERL_NO_GET_CONTEXT
a16 4
#ifdef I_UNISTD
#include <unistd.h>
#endif

a42 8
    case '_':
	if (strEQ(name, "_S_IFMT")) /* Yes, on name _S_IFMT return S_IFMT. */
#ifdef S_IFMT
	  return S_IFMT;
#else
	  goto not_there;
#endif
	break;
a44 24
	    if (strEQ(name, "F_ALLOCSP"))
#ifdef F_ALLOCSP
	        return F_ALLOCSP;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_ALLOCSP64"))
#ifdef F_ALLOCSP64
	        return F_ALLOCSP64;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_COMPAT"))
#ifdef F_COMPAT
	        return F_COMPAT;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_DUP2FD"))
#ifdef F_DUP2FD
	        return F_DUP2FD;
#else
	        goto not_there;
#endif
a56 24
	    if (strEQ(name, "F_FREESP"))
#ifdef F_FREESP
	        return F_FREESP;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_FREESP64"))
#ifdef F_FREESP64
	        return F_FREESP64;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_FSYNC"))
#ifdef F_FSYNC
	        return F_FSYNC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_FSYNC64"))
#ifdef F_FSYNC64
	        return F_FSYNC64;
#else
	        goto not_there;
#endif
a74 6
	    if (strEQ(name, "F_GETLK64"))
#ifdef F_GETLK64
	        return F_GETLK64;
#else
	        goto not_there;
#endif
a80 6
	    if (strEQ(name, "F_NODNY"))
#ifdef F_NODNY
	        return F_NODNY;
#else
	        goto not_there;
#endif
a86 12
	    if (strEQ(name, "F_RDACC"))
#ifdef F_RDACC
	        return F_RDACC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_RDDNY"))
#ifdef F_RDDNY
	        return F_RDDNY;
#else
	        goto not_there;
#endif
a92 12
	    if (strEQ(name, "F_RWACC"))
#ifdef F_RWACC
	        return F_RWACC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_RWDNY"))
#ifdef F_RWDNY
	        return F_RWDNY;
#else
	        goto not_there;
#endif
a110 6
	    if (strEQ(name, "F_SETLK64"))
#ifdef F_SETLK64
	        return F_SETLK64;
#else
	        goto not_there;
#endif
a116 6
	    if (strEQ(name, "F_SETLKW64"))
#ifdef F_SETLKW64
	        return F_SETLKW64;
#else
	        goto not_there;
#endif
a122 6
	    if (strEQ(name, "F_SHARE"))
#ifdef F_SHARE
	        return F_SHARE;
#else
	        goto not_there;
#endif
a134 18
	    if (strEQ(name, "F_UNSHARE"))
#ifdef F_UNSHARE
	        return F_UNSHARE;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_WRACC"))
#ifdef F_WRACC
	        return F_WRACC;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "F_WRDNY"))
#ifdef F_WRDNY
	        return F_WRDNY;
#else
	        goto not_there;
#endif
a173 6
        if (strEQ(name, "FDSYNC"))
#ifdef FDSYNC
            return FDSYNC;
#else
            goto not_there;
#endif
a179 6
        if (strEQ(name, "FLARGEFILE"))
#ifdef FLARGEFILE
            return FLARGEFILE;
#else
            goto not_there;
#endif
a191 6
        if (strEQ(name, "FRSYNC"))
#ifdef FRSYNC
            return FRSYNC;
#else
            goto not_there;
#endif
a273 12
	    if (strEQ(name, "O_DIRECT"))
#ifdef O_DIRECT
	        return O_DIRECT;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_DIRECTORY"))
#ifdef O_DIRECTORY
	        return O_DIRECTORY;
#else
	        goto not_there;
#endif
a291 6
	    if (strEQ(name, "O_LARGEFILE"))
#ifdef O_LARGEFILE
	        return O_LARGEFILE;
#else
	        goto not_there;
#endif
a303 12
	    if (strEQ(name, "O_NOFOLLOW"))
#ifdef O_NOFOLLOW
	        return O_NOFOLLOW;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_NOINHERIT"))
#ifdef O_NOINHERIT
	        return O_NOINHERIT;
#else
	        goto not_there;
#endif
a309 12
	    if (strEQ(name, "O_RANDOM"))
#ifdef O_RANDOM
	        return O_RANDOM;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_RAW"))
#ifdef O_RAW
	        return O_RAW;
#else
	        goto not_there;
#endif
a327 6
	    if (strEQ(name, "O_SEQUENTIAL"))
#ifdef O_SEQUENTIAL
	        return O_SEQUENTIAL;
#else
	        goto not_there;
#endif
a339 6
	    if (strEQ(name, "O_TEMPORARY"))
#ifdef O_TEMPORARY
	        return O_TEMPORARY;
#else
	        goto not_there;
#endif
a357 12
	    if (strEQ(name, "O_ALIAS"))
#ifdef O_ALIAS
	        return O_ALIAS;
#else
	        goto not_there;
#endif
	    if (strEQ(name, "O_RSRC"))
#ifdef O_RSRC
	        return O_RSRC;
#else
	        goto not_there;
#endif
a360 193
    case 'S':
      switch (name[1]) {
      case '_':
	if (strEQ(name, "S_ISUID"))
#ifdef S_ISUID
	  return S_ISUID;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_ISGID"))
#ifdef S_ISGID
	  return S_ISGID;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_ISVTX"))
#ifdef S_ISVTX
	  return S_ISVTX;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_ISTXT"))
#ifdef S_ISTXT
	  return S_ISTXT;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IFREG"))
#ifdef S_IFREG
	  return S_IFREG;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IFDIR"))
#ifdef S_IFDIR
	  return S_IFDIR;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IFLNK"))
#ifdef S_IFLNK
	  return S_IFLNK;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IFSOCK"))
#ifdef S_IFSOCK
	  return S_IFSOCK;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IFBLK"))
#ifdef S_IFBLK
	  return S_IFBLK;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IFCHR"))
#ifdef S_IFCHR
	  return S_IFCHR;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IFIFO"))
#ifdef S_IFIFO
	  return S_IFIFO;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IFWHT"))
#ifdef S_IFWHT
	  return S_IFWHT;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_ENFMT"))
#ifdef S_ENFMT
	  return S_ENFMT;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IRUSR"))
#ifdef S_IRUSR
	  return S_IRUSR;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IWUSR"))
#ifdef S_IWUSR
	  return S_IWUSR;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IXUSR"))
#ifdef S_IXUSR
	  return S_IXUSR;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IRWXU"))
#ifdef S_IRWXU
	  return S_IRWXU;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IRGRP"))
#ifdef S_IRGRP
	  return S_IRGRP;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IWGRP"))
#ifdef S_IWGRP
	  return S_IWGRP;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IXGRP"))
#ifdef S_IXGRP
	  return S_IXGRP;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IRWXG"))
#ifdef S_IRWXG
	  return S_IRWXG;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IROTH"))
#ifdef S_IROTH
	  return S_IROTH;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IWOTH"))
#ifdef S_IWOTH
	  return S_IWOTH;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IXOTH"))
#ifdef S_IXOTH
	  return S_IXOTH;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IRWXO"))
#ifdef S_IRWXO
	  return S_IRWXO;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IREAD"))
#ifdef S_IREAD
	  return S_IREAD;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IWRITE"))
#ifdef S_IWRITE
	  return S_IWRITE;
#else
	  goto not_there;
#endif
	if (strEQ(name, "S_IEXEC"))
#ifdef S_IEXEC
	  return S_IEXEC;
#else
	  goto not_there;
#endif
	break;
      case 'E':
	  if (strEQ(name, "SEEK_CUR"))
#ifdef SEEK_CUR
	    return SEEK_CUR;
#else
	    return 1;
#endif
	if (strEQ(name, "SEEK_END"))
#ifdef SEEK_END
	    return SEEK_END;
#else
	    return 2;
#endif
	if (strEQ(name, "SEEK_SET"))
#ifdef SEEK_SET
	    return SEEK_SET;
#else
	    return 0;
#endif
	break;
      }    
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d36 7
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d36 737
a772 1
#include "const-c.inc"
d776 5
a780 1
INCLUDE: const-xs.inc
@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a35 24
static void
XS_Fcntl_S_ISREG(pTHX_ CV* cv)
{
    dVAR;
    dXSARGS;
    dXSI32;
    /* Preserve the semantics of the perl code, which was:
       sub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }
    */
    SV *mode;

    PERL_UNUSED_VAR(cv); /* -W */
    SP -= items;

    if (items > 0)
	mode = ST(0);
    else {
	mode = &PL_sv_undef;
	EXTEND(SP, 1);
    }
    PUSHs(((SvUV(mode) & S_IFMT) == (UV)ix) ? &PL_sv_yes : &PL_sv_no);
    PUTBACK;
}

a40 62

void
S_IMODE(...)
    PREINIT:
	dXSTARG;
	SV *mode;
    PPCODE:
	if (items > 0)
	   mode = ST(0);
	else {
	     mode = &PL_sv_undef;
 	     EXTEND(SP, 1);
	}
	PUSHu(SvUV(mode) & 07777);

void
S_IFMT(...)
    PREINIT:
	dXSTARG;
    PPCODE:
	PUSHu(items ? (SvUV(ST(0)) & S_IFMT) : S_IFMT);

BOOT:
    {
        CV *cv;
#ifdef S_IFREG
        cv = newXS("Fcntl::S_ISREG", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_IFREG;
#endif
#ifdef S_IFDIR
        cv = newXS("Fcntl::S_ISDIR", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_IFDIR;
#endif
#ifdef S_IFLNK
        cv = newXS("Fcntl::S_ISLNK", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_IFLNK;
#endif
#ifdef S_IFSOCK
        cv = newXS("Fcntl::S_ISSOCK", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_IFSOCK;
#endif
#ifdef S_IFBLK
        cv = newXS("Fcntl::S_ISBLK", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_IFBLK;
#endif
#ifdef S_IFCHR
        cv = newXS("Fcntl::S_ISCHR", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_IFCHR;
#endif
#ifdef S_IFIFO
        cv = newXS("Fcntl::S_ISFIFO", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_IFIFO;
#endif
#ifdef S_IFWHT
        cv = newXS("Fcntl::S_ISWHT", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_IFWHT;
#endif
#ifdef S_ENFMT
        cv = newXS("Fcntl::S_ISENFMT", XS_Fcntl_S_ISREG, file);
        XSANY.any_i32 = S_ENFMT;
#endif
    }
@


