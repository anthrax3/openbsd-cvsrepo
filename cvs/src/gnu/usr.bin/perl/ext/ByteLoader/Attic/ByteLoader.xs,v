head	1.2;
access;
symbols
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.10
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.8
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.6
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.4
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.2
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2008.09.29.17.36.02;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2000.04.06.16.09.04;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.09.04;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.22.41;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.53;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.43.41;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.47.55;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "byterun.h"

static int
xgetc(PerlIO *io)
{
    dTHX;
    return PerlIO_getc(io);
}

static int
xfread(char *buf, size_t size, size_t n, PerlIO *io)
{
    dTHX;
    int i = PerlIO_read(io, buf, n * size);
    if (i > 0)
	i /= size;
    return i;
}

static void
freadpv(U32 len, void *data, XPV *pv)
{
    dTHX;
    New(666, pv->xpv_pv, len, char);
    PerlIO_read((PerlIO*)data, (void*)pv->xpv_pv, len);
    pv->xpv_len = len;
    pv->xpv_cur = len - 1;
}

static I32
byteloader_filter(pTHXo_ int idx, SV *buf_sv, int maxlen)
{
    dTHR;
    OP *saveroot = PL_main_root;
    OP *savestart = PL_main_start;
    struct bytestream bs;

    bs.data = PL_rsfp;
    bs.pfgetc = (int(*) (void*))xgetc;
    bs.pfread = (int(*) (char*,size_t,size_t,void*))xfread;
    bs.pfreadpv = freadpv;

    byterun(aTHXo_ bs);

    if (PL_in_eval) {
        OP *o;

        PL_eval_start = PL_main_start;

        o = newSVOP(OP_CONST, 0, newSViv(1));
        PL_eval_root = newLISTOP(OP_LINESEQ, 0, PL_main_root, o);
        PL_main_root->op_next = o;
        PL_eval_root = newUNOP(OP_LEAVEEVAL, 0, PL_eval_root);
        o->op_next = PL_eval_root;
    
        PL_main_root = saveroot;
        PL_main_start = savestart;
    }

    return 0;
}

MODULE = ByteLoader		PACKAGE = ByteLoader

PROTOTYPES:	ENABLE

void
import(...)
  PPCODE:
    filter_add(byteloader_filter, NULL);

void
unimport(...)
  PPCODE:
    filter_del(byteloader_filter);
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d7 6
a12 2
/* Something arbitary for a buffer size */
#define BYTELOADER_BUFFER 8096
d14 2
a15 2
int
bl_getc(struct byteloader_fdata *data)
d18 4
a21 17
    if (SvCUR(data->datasv) <= data->next_out) {
      int result;
      /* Run out of buffered data, so attempt to read some more */
      *(SvPV_nolen (data->datasv)) = '\0';
      SvCUR_set (data->datasv, 0);
      data->next_out = 0;
      result = FILTER_READ (data->idx + 1, data->datasv, BYTELOADER_BUFFER);

      /* Filter returned error, or we got EOF and no data, then return EOF.
	 Not sure if filter is allowed to return EOF and add data simultaneously
	 Think not, but will bullet proof against it. */
      if (result < 0 || SvCUR(data->datasv) == 0)
	return EOF;
      /* Else there must be at least one byte present, which is good enough */
    }

    return *((char *) SvPV_nolen (data->datasv) + data->next_out++);
d24 2
a25 2
int
bl_read(struct byteloader_fdata *data, char *buf, size_t size, size_t n)
d28 4
a31 38
    char *start;
    STRLEN len;
    size_t wanted = size * n;

    start = SvPV (data->datasv, len);
    if (len < (data->next_out + wanted)) {
      int result;

      /* Shuffle data to start of buffer */
      len -= data->next_out;
      if (len) {
	memmove (start, start + data->next_out, len + 1);
	SvCUR_set (data->datasv, len);
      } else {
	*start = '\0';	/* Avoid call to memmove. */
	SvCUR_set (data->datasv, 0);
      }
      data->next_out = 0;

      /* Attempt to read more data. */
      do {
	result = FILTER_READ (data->idx + 1, data->datasv, BYTELOADER_BUFFER);
	
	start = SvPV (data->datasv, len);
      } while (result > 0 && len < wanted);
      /* Loop while not (EOF || error) and short reads */

      /* If not enough data read, truncate copy */
      if (wanted > len)
	wanted = len;
    }

    if (wanted > 0) {
      memcpy (buf, start + data->next_out, wanted);
	data->next_out += wanted;
      wanted /= size;
    }
    return (int) wanted;
d37 1
d40 1
a40 2
    struct byteloader_state bstate;
    struct byteloader_fdata data;
d42 4
a45 9
    data.next_out = 0;
    data.datasv = FILTER_DATA(idx);
    data.idx = idx;

    bstate.bs_fdata = &data;
    bstate.bs_obj_list = Null(void**);
    bstate.bs_obj_list_fill = -1;
    bstate.bs_sv = Nullsv;
    bstate.bs_iv_overflows = 0;
d47 1
a47 1
    byterun(aTHXo_ &bstate);
a72 2
  PREINIT:
    SV *sv = newSVpvn ("", 0);
d74 1
a74 3
    if (!sv)
      croak ("Could not allocate ByteLoader buffers");
    filter_add(byteloader_filter, sv);
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d14 1
a14 1
    if (SvCUR(data->datasv) <= (STRLEN)data->next_out) {
d78 1
a78 1
byteloader_filter(pTHX_ int idx, SV *buf_sv, int maxlen)
d95 1
a95 1
    byterun(aTHX_ &bstate);
d120 1
a120 2
import(package="ByteLoader", ...)
  char *package
d129 1
a129 2
unimport(package="ByteLoader", ...)
  char *package
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d1 1
d30 1
a30 1
    return *((U8 *) SvPV_nolen (data->datasv) + data->next_out++);
a83 1
    int len;
d95 1
a95 8
/* KLUDGE */
    if (byterun(aTHX_ &bstate)
	    && (len = SvCUR(data.datasv) - (STRLEN)data.next_out))
    {
	PerlIO_seek(PL_rsfp, -len, SEEK_CUR);
	PL_rsfp = NULL;
    }
    filter_del(byteloader_filter);
d128 6
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d48 1
d51 1
a52 1
      SvCUR_set(data->datasv, len);
a83 2
    (void)buf_sv;
    (void)maxlen;
@


