head	1.5;
access;
symbols
	OPENBSD_4_8:1.4.0.2
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	PERL_5_10_1:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2010.09.24.14.59.27;	author millert;	state dead;
branches;
next	1.4;

1.4
date	2010.06.28.18.18.11;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.12.18.24.34;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.55.54;	author millert;	state dead;
branches;
next	1.1;

1.1
date	96.08.19.10.12.15;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.15;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.10.12.18.11.12;	author millert;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package Safe;

use 5.003_11;
use strict;
use Scalar::Util qw(reftype);

$Safe::VERSION = "2.27";

# *** Don't declare any lexicals above this point ***
#
# This function should return a closure which contains an eval that can't
# see any lexicals in scope (apart from __ExPr__ which is unavoidable)

sub lexless_anon_sub {
                 # $_[0] is package;
                 # $_[1] is strict flag;
    my $__ExPr__ = $_[2];   # must be a lexical to create the closure that
                            # can be used to pass the value into the safe
                            # world

    # Create anon sub ref in root of compartment.
    # Uses a closure (on $__ExPr__) to pass in the code to be executed.
    # (eval on one line to keep line numbers as expected by caller)
    eval sprintf
    'package %s; %s strict; sub { @@_=(); eval q[my $__ExPr__;] . $__ExPr__; }',
                $_[0], $_[1] ? 'use' : 'no';
}

use Carp;
BEGIN { eval q{
    use Carp::Heavy;
} }

use B ();
BEGIN {
    no strict 'refs';
    if (defined &B::sub_generation) {
        *sub_generation = \&B::sub_generation;
    }
    else {
        # fake sub generation changing for perls < 5.8.9
        my $sg; *sub_generation = sub { ++$sg };
    }
}

use Opcode 1.01, qw(
    opset opset_to_ops opmask_add
    empty_opset full_opset invert_opset verify_opset
    opdesc opcodes opmask define_optag opset_to_hex
);

*ops_to_opset = \&opset;   # Temporary alias for old Penguins

# Regular expressions and other unicode-aware code may need to call
# utf8->SWASHNEW (via perl's utf8.c).  That will fail unless we share the
# SWASHNEW method.
# Sadly we can't just add utf8::SWASHNEW to $default_share because perl's
# utf8.c code does a fetchmethod on SWASHNEW to check if utf8.pm is loaded,
# and sharing makes it look like the method exists.
# The simplest and most robust fix is to ensure the utf8 module is loaded when
# Safe is loaded. Then we can add utf8::SWASHNEW to $default_share.
require utf8;
# we must ensure that utf8_heavy.pl, where SWASHNEW is defined, is loaded
# but without depending on knowledge of that implementation detail.
# This code (//i on a unicode string) ensures utf8 is fully loaded
# and also loads the ToFold SWASH.
# (Swashes are cached internally by perl in PL_utf8_* variables
# independent of being inside/outside of Safe. So once loaded they can be)
do { my $a = pack('U',0xC4); my $b = chr 0xE4; utf8::upgrade $b; $a =~ /$b/i };
# now we can safely include utf8::SWASHNEW in $default_share defined below.

my $default_root  = 0;
# share *_ and functions defined in universal.c
# Don't share stuff like *UNIVERSAL:: otherwise code from the
# compartment can 0wn functions in UNIVERSAL
my $default_share = [qw[
    *_
    &PerlIO::get_layers
    &UNIVERSAL::isa
    &UNIVERSAL::can
    &UNIVERSAL::VERSION
    &utf8::is_utf8
    &utf8::valid
    &utf8::encode
    &utf8::decode
    &utf8::upgrade
    &utf8::downgrade
    &utf8::native_to_unicode
    &utf8::unicode_to_native
    &utf8::SWASHNEW
    $version::VERSION
    $version::CLASS
    $version::STRICT
    $version::LAX
    @@version::ISA
], ($] < 5.010 && qw[
    &utf8::SWASHGET
]), ($] >= 5.008001 && qw[
    &Regexp::DESTROY
]), ($] >= 5.010 && qw[
    &re::is_regexp
    &re::regname
    &re::regnames
    &re::regnames_count
    &Tie::Hash::NamedCapture::FETCH
    &Tie::Hash::NamedCapture::STORE
    &Tie::Hash::NamedCapture::DELETE
    &Tie::Hash::NamedCapture::CLEAR
    &Tie::Hash::NamedCapture::EXISTS
    &Tie::Hash::NamedCapture::FIRSTKEY
    &Tie::Hash::NamedCapture::NEXTKEY
    &Tie::Hash::NamedCapture::SCALAR
    &Tie::Hash::NamedCapture::flags
    &UNIVERSAL::DOES
    &version::()
    &version::new
    &version::(""
    &version::stringify
    &version::(0+
    &version::numify
    &version::normal
    &version::(cmp
    &version::(<=>
    &version::vcmp
    &version::(bool
    &version::boolean
    &version::(nomethod
    &version::noop
    &version::is_alpha
    &version::qv
    &version::vxs::declare
    &version::vxs::qv
    &version::vxs::_VERSION
    &version::vxs::stringify
    &version::vxs::new
    &version::vxs::parse
]), ($] >= 5.011 && qw[
    &re::regexp_pattern
])];

sub new {
    my($class, $root, $mask) = @@_;
    my $obj = {};
    bless $obj, $class;

    if (defined($root)) {
        croak "Can't use \"$root\" as root name"
            if $root =~ /^main\b/ or $root !~ /^\w[:\w]*$/;
        $obj->{Root}  = $root;
        $obj->{Erase} = 0;
    }
    else {
        $obj->{Root}  = "Safe::Root".$default_root++;
        $obj->{Erase} = 1;
    }

    # use permit/deny methods instead till interface issues resolved
    # XXX perhaps new Safe 'Root', mask => $mask, foo => bar, ...;
    croak "Mask parameter to new no longer supported" if defined $mask;
    $obj->permit_only(':default');

    # We must share $_ and @@_ with the compartment or else ops such
    # as split, length and so on won't default to $_ properly, nor
    # will passing argument to subroutines work (via @@_). In fact,
    # for reasons I don't completely understand, we need to share
    # the whole glob *_ rather than $_ and @@_ separately, otherwise
    # @@_ in non default packages within the compartment don't work.
    $obj->share_from('main', $default_share);

    Opcode::_safe_pkg_prep($obj->{Root}) if($Opcode::VERSION > 1.04);

    return $obj;
}

sub DESTROY {
    my $obj = shift;
    $obj->erase('DESTROY') if $obj->{Erase};
}

sub erase {
    my ($obj, $action) = @@_;
    my $pkg = $obj->root();
    my ($stem, $leaf);

    no strict 'refs';
    $pkg = "main::$pkg\::";     # expand to full symbol table name
    ($stem, $leaf) = $pkg =~ m/(.*::)(\w+::)$/;

    # The 'my $foo' is needed! Without it you get an
    # 'Attempt to free unreferenced scalar' warning!
    my $stem_symtab = *{$stem}{HASH};

    #warn "erase($pkg) stem=$stem, leaf=$leaf";
    #warn " stem_symtab hash ".scalar(%$stem_symtab)."\n";
    # ", join(', ', %$stem_symtab),"\n";

#    delete $stem_symtab->{$leaf};

    my $leaf_glob   = $stem_symtab->{$leaf};
    my $leaf_symtab = *{$leaf_glob}{HASH};
#    warn " leaf_symtab ", join(', ', %$leaf_symtab),"\n";
    %$leaf_symtab = ();
    #delete $leaf_symtab->{'__ANON__'};
    #delete $leaf_symtab->{'foo'};
    #delete $leaf_symtab->{'main::'};
#    my $foo = undef ${"$stem\::"}{"$leaf\::"};

    if ($action and $action eq 'DESTROY') {
        delete $stem_symtab->{$leaf};
    } else {
        $obj->share_from('main', $default_share);
    }
    1;
}


sub reinit {
    my $obj= shift;
    $obj->erase;
    $obj->share_redo;
}

sub root {
    my $obj = shift;
    croak("Safe root method now read-only") if @@_;
    return $obj->{Root};
}


sub mask {
    my $obj = shift;
    return $obj->{Mask} unless @@_;
    $obj->deny_only(@@_);
}

# v1 compatibility methods
sub trap   { shift->deny(@@_)   }
sub untrap { shift->permit(@@_) }

sub deny {
    my $obj = shift;
    $obj->{Mask} |= opset(@@_);
}
sub deny_only {
    my $obj = shift;
    $obj->{Mask} = opset(@@_);
}

sub permit {
    my $obj = shift;
    # XXX needs testing
    $obj->{Mask} &= invert_opset opset(@@_);
}
sub permit_only {
    my $obj = shift;
    $obj->{Mask} = invert_opset opset(@@_);
}


sub dump_mask {
    my $obj = shift;
    print opset_to_hex($obj->{Mask}),"\n";
}


sub share {
    my($obj, @@vars) = @@_;
    $obj->share_from(scalar(caller), \@@vars);
}


sub share_from {
    my $obj = shift;
    my $pkg = shift;
    my $vars = shift;
    my $no_record = shift || 0;
    my $root = $obj->root();
    croak("vars not an array ref") unless ref $vars eq 'ARRAY';
    no strict 'refs';
    # Check that 'from' package actually exists
    croak("Package \"$pkg\" does not exist")
        unless keys %{"$pkg\::"};
    my $arg;
    foreach $arg (@@$vars) {
        # catch some $safe->share($var) errors:
        my ($var, $type);
        $type = $1 if ($var = $arg) =~ s/^(\W)//;
        # warn "share_from $pkg $type $var";
        for (1..2) { # assign twice to avoid any 'used once' warnings
            *{$root."::$var"} = (!$type)   ? \&{$pkg."::$var"}
                          : ($type eq '&') ? \&{$pkg."::$var"}
                          : ($type eq '$') ? \${$pkg."::$var"}
                          : ($type eq '@@') ? \@@{$pkg."::$var"}
                          : ($type eq '%') ? \%{$pkg."::$var"}
                          : ($type eq '*') ?  *{$pkg."::$var"}
                          : croak(qq(Can't share "$type$var" of unknown type));
        }
    }
    $obj->share_record($pkg, $vars) unless $no_record or !$vars;
}


sub share_record {
    my $obj = shift;
    my $pkg = shift;
    my $vars = shift;
    my $shares = \%{$obj->{Shares} ||= {}};
    # Record shares using keys of $obj->{Shares}. See reinit.
    @@{$shares}{@@$vars} = ($pkg) x @@$vars if @@$vars;
}


sub share_redo {
    my $obj = shift;
    my $shares = \%{$obj->{Shares} ||= {}};
    my($var, $pkg);
    while(($var, $pkg) = each %$shares) {
        # warn "share_redo $pkg\:: $var";
        $obj->share_from($pkg,  [ $var ], 1);
    }
}


sub share_forget {
    delete shift->{Shares};
}


sub varglob {
    my ($obj, $var) = @@_;
    no strict 'refs';
    return *{$obj->root()."::$var"};
}

sub _clean_stash {
    my ($root, $saved_refs) = @@_;
    $saved_refs ||= [];
    no strict 'refs';
    foreach my $hook (qw(DESTROY AUTOLOAD), grep /^\(/, keys %$root) {
        push @@$saved_refs, \*{$root.$hook};
        delete ${$root}{$hook};
    }

    for (grep /::$/, keys %$root) {
        next if \%{$root.$_} eq \%$root;
        _clean_stash($root.$_, $saved_refs);
    }
}

sub reval {
    my ($obj, $expr, $strict) = @@_;
    my $root = $obj->{Root};

    my $evalsub = lexless_anon_sub($root, $strict, $expr);
    # propagate context
    my $sg = sub_generation();
    my @@subret = (wantarray)
               ?        Opcode::_safe_call_sv($root, $obj->{Mask}, $evalsub)
               : scalar Opcode::_safe_call_sv($root, $obj->{Mask}, $evalsub);
    _clean_stash($root.'::') if $sg != sub_generation();
    $obj->wrap_code_refs_within(@@subret);
    return (wantarray) ? @@subret : $subret[0];
}


sub wrap_code_refs_within {
    my $obj = shift;

    $obj->_find_code_refs('wrap_code_ref', @@_);
}


sub _find_code_refs {
    my $obj = shift;
    my $visitor = shift;

    for my $item (@@_) {
        my $reftype = $item && reftype $item
            or next;
        if ($reftype eq 'ARRAY') {
            $obj->_find_code_refs($visitor, @@$item);
        }
        elsif ($reftype eq 'HASH') {
            $obj->_find_code_refs($visitor, values %$item);
        }
        # XXX GLOBs?
        elsif ($reftype eq 'CODE') {
            $item = $obj->$visitor($item);
        }
    }
}


sub wrap_code_ref {
    my ($obj, $sub) = @@_;

    # wrap code ref $sub with _safe_call_sv so that, when called, the
    # execution will happen with the compartment fully 'in effect'.

    croak "Not a CODE reference"
        if reftype $sub ne 'CODE';

    my $ret = sub {
        my @@args = @@_; # lexical to close over
        my $sub_with_args = sub { $sub->(@@args) };

        my @@subret;
        my $error;
        do {
            local $@@;  # needed due to perl_call_sv(sv, G_EVAL|G_KEEPERR)
            my $sg = sub_generation();
            @@subret = (wantarray)
                ?        Opcode::_safe_call_sv($obj->{Root}, $obj->{Mask}, $sub_with_args)
                : scalar Opcode::_safe_call_sv($obj->{Root}, $obj->{Mask}, $sub_with_args);
            $error = $@@;
            _clean_stash($obj->{Root}.'::') if $sg != sub_generation();
        };
        if ($error) { # rethrow exception
            $error =~ s/\t\(in cleanup\) //; # prefix added by G_KEEPERR
            die $error;
        }
        return (wantarray) ? @@subret : $subret[0];
    };

    return $ret;
}


sub rdo {
    my ($obj, $file) = @@_;
    my $root = $obj->{Root};

    my $sg = sub_generation();
    my $evalsub = eval
            sprintf('package %s; sub { @@_ = (); do $file }', $root);
    my @@subret = (wantarray)
               ?        Opcode::_safe_call_sv($root, $obj->{Mask}, $evalsub)
               : scalar Opcode::_safe_call_sv($root, $obj->{Mask}, $evalsub);
    _clean_stash($root.'::') if $sg != sub_generation();
    $obj->wrap_code_refs_within(@@subret);
    return (wantarray) ? @@subret : $subret[0];
}


1;

__END__

=head1 NAME

Safe - Compile and execute code in restricted compartments

=head1 SYNOPSIS

  use Safe;

  $compartment = new Safe;

  $compartment->permit(qw(time sort :browse));

  $result = $compartment->reval($unsafe_code);

=head1 DESCRIPTION

The Safe extension module allows the creation of compartments
in which perl code can be evaluated. Each compartment has

=over 8

=item a new namespace

The "root" of the namespace (i.e. "main::") is changed to a
different package and code evaluated in the compartment cannot
refer to variables outside this namespace, even with run-time
glob lookups and other tricks.

Code which is compiled outside the compartment can choose to place
variables into (or I<share> variables with) the compartment's namespace
and only that data will be visible to code evaluated in the
compartment.

By default, the only variables shared with compartments are the
"underscore" variables $_ and @@_ (and, technically, the less frequently
used %_, the _ filehandle and so on). This is because otherwise perl
operators which default to $_ will not work and neither will the
assignment of arguments to @@_ on subroutine entry.

=item an operator mask

Each compartment has an associated "operator mask". Recall that
perl code is compiled into an internal format before execution.
Evaluating perl code (e.g. via "eval" or "do 'file'") causes
the code to be compiled into an internal format and then,
provided there was no error in the compilation, executed.
Code evaluated in a compartment compiles subject to the
compartment's operator mask. Attempting to evaluate code in a
compartment which contains a masked operator will cause the
compilation to fail with an error. The code will not be executed.

The default operator mask for a newly created compartment is
the ':default' optag.

It is important that you read the L<Opcode> module documentation
for more information, especially for detailed definitions of opnames,
optags and opsets.

Since it is only at the compilation stage that the operator mask
applies, controlled access to potentially unsafe operations can
be achieved by having a handle to a wrapper subroutine (written
outside the compartment) placed into the compartment. For example,

    $cpt = new Safe;
    sub wrapper {
        # vet arguments and perform potentially unsafe operations
    }
    $cpt->share('&wrapper');

=back


=head1 WARNING

The authors make B<no warranty>, implied or otherwise, about the
suitability of this software for safety or security purposes.

The authors shall not in any case be liable for special, incidental,
consequential, indirect or other similar damages arising from the use
of this software.

Your mileage will vary. If in any doubt B<do not use it>.


=head1 METHODS

To create a new compartment, use

    $cpt = new Safe;

Optional argument is (NAMESPACE), where NAMESPACE is the root namespace
to use for the compartment (defaults to "Safe::Root0", incremented for
each new compartment).

Note that version 1.00 of the Safe module supported a second optional
parameter, MASK.  That functionality has been withdrawn pending deeper
consideration. Use the permit and deny methods described below.

The following methods can then be used on the compartment
object returned by the above constructor. The object argument
is implicit in each case.


=head2 permit (OP, ...)

Permit the listed operators to be used when compiling code in the
compartment (in I<addition> to any operators already permitted).

You can list opcodes by names, or use a tag name; see
L<Opcode/"Predefined Opcode Tags">.

=head2 permit_only (OP, ...)

Permit I<only> the listed operators to be used when compiling code in
the compartment (I<no> other operators are permitted).

=head2 deny (OP, ...)

Deny the listed operators from being used when compiling code in the
compartment (other operators may still be permitted).

=head2 deny_only (OP, ...)

Deny I<only> the listed operators from being used when compiling code
in the compartment (I<all> other operators will be permitted, so you probably
don't want to use this method).

=head2 trap (OP, ...)

=head2 untrap (OP, ...)

The trap and untrap methods are synonyms for deny and permit
respectfully.

=head2 share (NAME, ...)

This shares the variable(s) in the argument list with the compartment.
This is almost identical to exporting variables using the L<Exporter>
module.

Each NAME must be the B<name> of a non-lexical variable, typically
with the leading type identifier included. A bareword is treated as a
function name.

Examples of legal names are '$foo' for a scalar, '@@foo' for an
array, '%foo' for a hash, '&foo' or 'foo' for a subroutine and '*foo'
for a glob (i.e.  all symbol table entries associated with "foo",
including scalar, array, hash, sub and filehandle).

Each NAME is assumed to be in the calling package. See share_from
for an alternative method (which C<share> uses).

=head2 share_from (PACKAGE, ARRAYREF)

This method is similar to share() but allows you to explicitly name the
package that symbols should be shared from. The symbol names (including
type characters) are supplied as an array reference.

    $safe->share_from('main', [ '$foo', '%bar', 'func' ]);

Names can include package names, which are relative to the specified PACKAGE.
So these two calls have the same effect:

    $safe->share_from('Scalar::Util', [ 'reftype' ]);
    $safe->share_from('main', [ 'Scalar::Util::reftype' ]);

=head2 varglob (VARNAME)

This returns a glob reference for the symbol table entry of VARNAME in
the package of the compartment. VARNAME must be the B<name> of a
variable without any leading type marker. For example:

    ${$cpt->varglob('foo')} = "Hello world";

has the same effect as:

    $cpt = new Safe 'Root';
    $Root::foo = "Hello world";

but avoids the need to know $cpt's package name.


=head2 reval (STRING, STRICT)

This evaluates STRING as perl code inside the compartment.

The code can only see the compartment's namespace (as returned by the
B<root> method). The compartment's root package appears to be the
C<main::> package to the code inside the compartment.

Any attempt by the code in STRING to use an operator which is not permitted
by the compartment will cause an error (at run-time of the main program
but at compile-time for the code in STRING).  The error is of the form
"'%s' trapped by operation mask...".

If an operation is trapped in this way, then the code in STRING will
not be executed. If such a trapped operation occurs or any other
compile-time or return error, then $@@ is set to the error message, just
as with an eval().

If there is no error, then the method returns the value of the last
expression evaluated, or a return statement may be used, just as with
subroutines and B<eval()>. The context (list or scalar) is determined
by the caller as usual.

If the return value of reval() is (or contains) any code reference,
those code references are wrapped to be themselves executed always
in the compartment. See L</wrap_code_refs_within>.

The formerly undocumented STRICT argument sets strictness: if true
'use strict;' is used, otherwise it uses 'no strict;'. B<Note>: if
STRICT is omitted 'no strict;' is the default.

Some points to note:

If the entereval op is permitted then the code can use eval "..." to
'hide' code which might use denied ops. This is not a major problem
since when the code tries to execute the eval it will fail because the
opmask is still in effect. However this technique would allow clever,
and possibly harmful, code to 'probe' the boundaries of what is
possible.

Any string eval which is executed by code executing in a compartment,
or by code called from code executing in a compartment, will be eval'd
in the namespace of the compartment. This is potentially a serious
problem.

Consider a function foo() in package pkg compiled outside a compartment
but shared with it. Assume the compartment has a root package called
'Root'. If foo() contains an eval statement like eval '$foo = 1' then,
normally, $pkg::foo will be set to 1.  If foo() is called from the
compartment (by whatever means) then instead of setting $pkg::foo, the
eval will actually set $Root::pkg::foo.

This can easily be demonstrated by using a module, such as the Socket
module, which uses eval "..." as part of an AUTOLOAD function. You can
'use' the module outside the compartment and share an (autoloaded)
function with the compartment. If an autoload is triggered by code in
the compartment, or by any code anywhere that is called by any means
from the compartment, then the eval in the Socket module's AUTOLOAD
function happens in the namespace of the compartment. Any variables
created or used by the eval'd code are now under the control of
the code in the compartment.

A similar effect applies to I<all> runtime symbol lookups in code
called from a compartment but not compiled within it.

=head2 rdo (FILENAME)

This evaluates the contents of file FILENAME inside the compartment.
See above documentation on the B<reval> method for further details.

=head2 root (NAMESPACE)

This method returns the name of the package that is the root of the
compartment's namespace.

Note that this behaviour differs from version 1.00 of the Safe module
where the root module could be used to change the namespace. That
functionality has been withdrawn pending deeper consideration.

=head2 mask (MASK)

This is a get-or-set method for the compartment's operator mask.

With no MASK argument present, it returns the current operator mask of
the compartment.

With the MASK argument present, it sets the operator mask for the
compartment (equivalent to calling the deny_only method).

=head2 wrap_code_ref (CODEREF)

Returns a reference to an anonymous subroutine that, when executed, will call
CODEREF with the Safe compartment 'in effect'.  In other words, with the
package namespace adjusted and the opmask enabled.

Note that the opmask doesn't affect the already compiled code, it only affects
any I<further> compilation that the already compiled code may try to perform.

This is particularly useful when applied to code references returned from reval().

(It also provides a kind of workaround for RT#60374: "Safe.pm sort {} bug with
-Dusethreads". See L<http://rt.perl.org/rt3//Public/Bug/Display.html?id=60374>
for I<much> more detail.)

=head2 wrap_code_refs_within (...)

Wraps any CODE references found within the arguments by replacing each with the
result of calling L</wrap_code_ref> on the CODE reference. Any ARRAY or HASH
references in the arguments are inspected recursively.

Returns nothing.

=head1 RISKS

This section is just an outline of some of the things code in a compartment
might do (intentionally or unintentionally) which can have an effect outside
the compartment.

=over 8

=item Memory

Consuming all (or nearly all) available memory.

=item CPU

Causing infinite loops etc.

=item Snooping

Copying private information out of your system. Even something as
simple as your user name is of value to others. Much useful information
could be gleaned from your environment variables for example.

=item Signals

Causing signals (especially SIGFPE and SIGALARM) to affect your process.

Setting up a signal handler will need to be carefully considered
and controlled.  What mask is in effect when a signal handler
gets called?  If a user can get an imported function to get an
exception and call the user's signal handler, does that user's
restricted mask get re-instated before the handler is called?
Does an imported handler get called with its original mask or
the user's one?

=item State Changes

Ops such as chdir obviously effect the process as a whole and not just
the code in the compartment. Ops such as rand and srand have a similar
but more subtle effect.

=back

=head1 AUTHOR

Originally designed and implemented by Malcolm Beattie.

Reworked to use the Opcode module and other changes added by Tim Bunce.

Currently maintained by the Perl 5 Porters, <perl5-porters@@perl.org>.

=cut

@


1.4
log
@Update the Safe module to version 2.2.7 for CVE-2010-1168 and
CVE-2010-1447.  From Ian McWilliam
@
text
@@


1.3
log
@Merge in perl 5.10.1
@
text
@d5 1
d7 1
a7 1
$Safe::VERSION = "2.18";
d15 2
a16 2
		 # $_[0] is package;
		 # $_[1] is strict flag;
d18 2
a19 2
			    # can be used to pass the value into the safe
			    # world
d26 1
a26 1
		$_[0], $_[1] ? 'use' : 'no';
d34 12
d54 17
d90 1
d93 2
d96 3
a98 1
], ($] >= 5.008001 && qw[
d131 6
d147 4
a150 4
	croak "Can't use \"$root\" as root name"
	    if $root =~ /^main\b/ or $root !~ /^\w[:\w]*$/;
	$obj->{Root}  = $root;
	$obj->{Erase} = 0;
d153 2
a154 2
	$obj->{Root}  = "Safe::Root".$default_root++;
	$obj->{Erase} = 1;
d169 1
d171 1
d186 1
a186 1
    $pkg = "main::$pkg\::";	# expand to full symbol table name
d195 1
a195 1
	# ", join(', ', %$stem_symtab),"\n";
a265 1

d271 1
d282 1
a282 1
	unless keys %{"$pkg\::"};
d285 13
a297 13
	# catch some $safe->share($var) errors:
	my ($var, $type);
	$type = $1 if ($var = $arg) =~ s/^(\W)//;
	# warn "share_from $pkg $type $var";
	for (1..2) { # assign twice to avoid any 'used once' warnings
	    *{$root."::$var"} = (!$type)       ? \&{$pkg."::$var"}
			  : ($type eq '&') ? \&{$pkg."::$var"}
			  : ($type eq '$') ? \${$pkg."::$var"}
			  : ($type eq '@@') ? \@@{$pkg."::$var"}
			  : ($type eq '%') ? \%{$pkg."::$var"}
			  : ($type eq '*') ?  *{$pkg."::$var"}
			  : croak(qq(Can't share "$type$var" of unknown type));
	}
d302 1
d311 2
d318 2
a319 2
	# warn "share_redo $pkg\:: $var";
	$obj->share_from($pkg,  [ $var ], 1);
d322 2
d328 1
d335 14
d354 9
a362 2
    my $evalsub = lexless_anon_sub($root,$strict, $expr);
    return Opcode::_safe_call_sv($root, $obj->{Mask}, $evalsub);
d365 64
d433 1
d435 7
a441 2
	    sprintf('package %s; sub { @@_ = (); do $file }', $root);
    return Opcode::_safe_call_sv($root, $obj->{Mask}, $evalsub);
d533 1
a533 9
=head2 RECENT CHANGES

The interface to the Safe module has changed quite dramatically since
version 1 (as supplied with Perl5.002). Study these pages carefully if
you have code written to use Safe version 1 because you will need to
makes changes.


=head2 Methods in class Safe
d552 1
a552 3
=over 8

=item permit (OP, ...)
d560 1
a560 1
=item permit_only (OP, ...)
d565 1
a565 1
=item deny (OP, ...)
d570 1
a570 1
=item deny_only (OP, ...)
d573 2
a574 1
in the compartment (I<all> other operators will be permitted).
d576 1
a576 1
=item trap (OP, ...)
d578 1
a578 1
=item untrap (OP, ...)
d583 1
a583 1
=item share (NAME, ...)
d599 1
a599 1
for an alternative method (which share uses).
d601 1
a601 1
=item share_from (PACKAGE, ARRAYREF)
d609 5
d615 1
a615 1
=item varglob (VARNAME)
d619 5
a623 1
variable without any leading type marker. For example,
d627 2
a628 2
    # Equivalent version which doesn't need to know $cpt's package name:
    ${$cpt->varglob('foo')} = "Hello world";
d631 1
a631 1
=item reval (STRING, STRICT)
d654 3
a656 3
This behaviour differs from the beta distribution of the Safe extension
where earlier versions of perl made it hard to mimic the return
behaviour of the eval() command and the context was always scalar.
d696 1
a696 3


=item rdo (FILENAME)
d701 1
a701 1
=item root (NAMESPACE)
d710 1
a710 1
=item mask (MASK)
d720 20
a739 1
=back
d741 1
d743 1
a743 1
=head2 Some Safety Issues
d745 3
a747 3
This section is currently just an outline of some of the things code in
a compartment might do (intentionally or unintentionally) which can
have an effect outside the compartment.
d785 1
a785 1
=head2 AUTHOR
@


1.2
log
@perl 5.004_04
@
text
@d3 24
a26 1
use vars qw($VERSION @@ISA @@EXPORT_OK);
a27 2
require Exporter;
require DynaLoader;
d29 279
a307 4
$VERSION = "1.00";
@@ISA = qw(Exporter DynaLoader);
@@EXPORT_OK = qw(op_mask ops_to_mask mask_to_ops opcode opname opdesc
		MAXO emptymask fullmask);
d311 11
a321 1
Safe - Safe extension module for Perl
d335 6
a340 4
glob lookups and other tricks. Code which is compiled outside
the compartment can choose to place variables into (or share
variables with) the compartment's namespace and only that
data will be visible to code evaluated in the compartment.
d343 4
a346 4
"underscore" variables $_ and @@_ (and, technically, the much less
frequently used %_, the _ filehandle and so on). This is because
otherwise perl operators which default to $_ will not work and neither
will the assignment of arguments to @@_ on subroutine entry.
d355 2
a356 2
Code evaulated in a compartment compiles subject to the
compartment's operator mask. Attempting to evaulate code in a
d360 6
a365 8
By default, the operator mask for a newly created compartment masks
out all operations which give "access to the system" in some sense.
This includes masking off operators such as I<system>, I<open>,
I<chown>, and I<shmget> but does not mask off operators such as
I<print>, I<sysread> and I<E<lt>HANDLE<gt>>. Those file operators
are allowed since for the code in the compartment to have access
to a filehandle, the code outside the compartment must have explicitly
placed the filehandle variable inside the compartment.
a379 1
=head2 Operator masks
d381 4
a384 12
An operator mask exists at user-level as a string of bytes of length
MAXO, each of which is either 0x00 or 0x01. Here, MAXO is the number
of operators in the current version of perl. The subroutine MAXO()
(available for export by package Safe) returns the number of operators
in the current version of perl. Note that, unlike the beta versions of
the Safe extension, this is a reliable count of the number of
operators in the currently running perl executable. The presence of a
0x01 byte at offset B<n> of the string indicates that operator number
B<n> should be masked (i.e. disallowed).  The Safe extension makes
available routines for converting from operator names to operator
numbers (and I<vice versa>) and for converting from a list of operator
names to the corresponding mask (and I<vice versa>).
d386 3
a388 1
=head2 Methods in class Safe
d390 1
a390 1
To create a new compartment, use
a391 1
    $cpt = new Safe;
d393 1
a393 1
Optional arguments are (NAMESPACE, MASK), where
d395 4
a398 1
=over 8
a399 1
=item NAMESPACE
d401 1
a401 2
is the root namespace to use for the compartment (defaults to
"Safe::Root000000000", auto-incremented for each new compartment); and
d403 1
a403 1
=item MASK
d405 1
a405 1
is the operator mask to use (defaults to a fairly restrictive set).
d407 7
a413 1
=back
d419 1
d422 14
a435 1
=item root (NAMESPACE)
d437 2
a438 4
This is a get-or-set method for the compartment's namespace. With the
NAMESPACE argument present, it sets the root namespace for the
compartment. With no NAMESPACE argument present, it returns the
current root namespace of the compartment.
d440 1
a440 1
=item mask (MASK)
d442 2
a443 4
This is a get-or-set method for the compartment's operator mask.
With the MASK argument present, it sets the operator mask for the
compartment. With no MASK argument present, it returns the
current operator mask of the compartment.
a446 6
This sets bits in the compartment's operator mask corresponding
to each operator named in the list of arguments. Each OP can be
either the name of an operation or its number. See opcode.h or
opcode.pl in the main perl distribution for a canonical list of
operator names.

d449 2
a450 5
This resets bits in the compartment's operator mask corresponding
to each operator named in the list of arguments. Each OP can be
either the name of an operation or its number. See opcode.h or
opcode.pl in the main perl distribution for a canonical list of
operator names.
d452 1
a452 1
=item share (VARNAME, ...)
d455 2
a456 5
Each VARNAME must be the B<name> of a variable with a leading type
identifier included. Examples of legal variable names are '$foo' for
a scalar, '@@foo' for an array, '%foo' for a hash, '&foo' for a
subroutine and '*foo' for a glob (i.e. all symbol table entries
associated with "foo", including scalar, array, hash, sub and filehandle).
d458 3
a460 1
=item varglob (VARNAME)
d462 4
a465 3
This returns a glob for the symbol table entry of VARNAME in the package
of the compartment. VARNAME must be the B<name> of a variable without
any leading type marker. For example,
d467 2
a468 4
    $cpt = new Safe 'Root';
    $Root::foo = "Hello world";
    # Equivalent version which doesn't need to know $cpt's package name:
    ${$cpt->varglob('foo')} = "Hello world";
d470 1
d472 3
a474 1
=item reval (STRING)
d476 1
a476 15
This evaluates STRING as perl code inside the compartment. The code
can only see the compartment's namespace (as returned by the B<root>
method). Any attempt by code in STRING to use an operator which is
in the compartment's mask will cause an error (at run-time of the
main program but at compile-time for the code in STRING). The error
is of the form "%s trapped by operation mask operation...". If an
operation is trapped in this way, then the code in STRING will not
be executed. If such a trapped operation occurs or any other
compile-time or return error, then $@@ is set to the error message,
just as with an eval(). If there is no error, then the method returns
the value of the last expression evaluated, or a return statement may
be used, just as with subroutines and B<eval()>. Note that this
behaviour differs from the beta distribution of the Safe extension
where earlier versions of perl made it hard to mimic the return
behaviour of the eval() command.
a477 1
=item rdo (FILENAME)
d479 1
a479 2
This evaluates the contents of file FILENAME inside the compartment.
See above documentation on the B<reval> method for further details.
d481 3
a483 1
=back
d485 4
a488 1
=head2 Subroutines in package Safe
a489 5
The Safe package contains subroutines for manipulating operator
names and operator masks. All are available for export by the package.
The canonical list of operator names is the contents of the array
op_name defined and initialised in file F<opcode.h> of the Perl
source distribution.
d491 1
a491 1
=over 8
d493 1
a493 1
=item ops_to_mask (OP, ...)
d495 18
a512 2
This takes a list of operator names and returns an operator mask
with precisely those operators masked.
d514 3
a516 1
=item mask_to_ops (MASK)
d518 34
a551 2
This takes an operator mask and returns a list of operator names
corresponding to those operators which are masked in MASK.
d553 2
a554 1
=item opcode (OP, ...)
a555 2
This takes a list of operator names and returns the corresponding
list of opcodes (which can then be used as byte offsets into a mask).
a556 1
=item opname (OP, ...)
d558 1
a558 2
This takes a list of opcodes and returns the corresponding list of
operator names.
d560 2
a561 1
=item fullmask
d563 1
a563 2
This just returns a mask which has all operators masked.
It returns the string "\1" x MAXO().
d565 2
a566 1
=item emptymask
d568 3
a570 4
This just returns a mask which has all operators unmasked.
It returns the string "\0" x MAXO(). This is useful if you
want a compartment to make use of the namespace protection
features but do not want the default restrictive mask.
d572 1
a572 1
=item MAXO
d574 1
a574 6
This returns the number of operators (and hence the length of an
operator mask). Note that, unlike the beta distributions of the
Safe extension, this is derived from a genuine integer variable
in the perl executable and not from a preprocessor constant.
This means that the Safe extension is more robust in the presence
of mismatched versions of the perl executable and the Safe extension.
d576 2
a577 1
=item op_mask
d579 2
a580 3
This returns the operator mask which is actually in effect at the
time the invocation to the subroutine is compiled. In general,
this is probably not terribly useful.
a583 1
=head2 AUTHOR
d585 1
a585 1
Malcolm Beattie, mbeattie@@sable.ox.ac.uk.
d587 3
a589 1
=cut
d591 1
a591 1
my $default_root = 'Root000000000';
d593 1
a593 1
my $default_mask;
d595 1
a595 33
sub new {
    my($class, $root, $mask) = @@_;
    my $obj = {};
    bless $obj, $class;
    $obj->root(defined($root) ? $root : ("Safe::".$default_root++));
    $obj->mask(defined($mask) ? $mask : $default_mask);
    # We must share $_ and @@_ with the compartment or else ops such
    # as split, length and so on won't default to $_ properly, nor
    # will passing argument to subroutines work (via @@_). In fact,
    # for reasons I don't completely understand, we need to share
    # the whole glob *_ rather than $_ and @@_ separately, otherwise
    # @@_ in non default packages within the compartment don't work.
    *{$obj->root . "::_"} = *_;
    return $obj;
}

sub DESTROY {
    my($obj) = @@_;
    my $root = $obj->root();
    if ($root =~ /^Safe::(Root\d+)$/){
	$root = $1;
	delete $ {"Safe::"}{"$root\::"};
    }
}

sub root {
    my $obj = shift;
    if (@@_) {
	$obj->{Root} = $_[0];
    } else {
	return $obj->{Root};
    }
}
d597 1
a597 8
sub mask {
    my $obj = shift;
    if (@@_) {
	$obj->{Mask} = verify_mask($_[0]);
    } else {
	return $obj->{Mask};
    }
}
d599 1
a599 7
sub verify_mask {
    my($mask) = @@_;
    if (length($mask) != MAXO() || $mask !~ /^[\0\1]+$/) {
	croak("argument is not a mask");
    }
    return $mask;
}
d601 1
a601 4
sub trap {
    my $obj = shift;
    $obj->setmaskel("\1", @@_);
}
d603 3
a605 4
sub untrap {
    my $obj = shift;
    $obj->setmaskel("\0", @@_);
}
d607 1
a607 2
sub emptymask { "\0" x MAXO() }
sub fullmask { "\1" x MAXO() }
d609 1
a609 11
sub setmaskel {
    my $obj = shift;
    my $val = shift;
    croak("bad value for mask element") unless $val eq "\0" || $val eq "\1";
    my $maskref = \$obj->{Mask};
    my ($op, $opcode);
    foreach $op (@@_) {
	$opcode = ($op =~ /^\d/) ? $op : opcode($op);
	substr($$maskref, $opcode, 1) = $val;
    }
}
d611 7
a617 16
sub share {
    my $obj = shift;
    my $root = $obj->root();
    my ($arg);
    foreach $arg (@@_) {
	my $var;
	($var = $arg) =~ s/^(.)//;
	my $caller = caller;
	*{$root."::$var"} = ($1 eq '$') ? \${$caller."::$var"}
			  : ($1 eq '@@') ? \@@{$caller."::$var"}
			  : ($1 eq '%') ? \%{$caller."::$var"}
			  : ($1 eq '*') ? *{$caller."::$var"}
			  : ($1 eq '&') ? \&{$caller."::$var"}
			  : croak(qq(No such variable type for "$1$var"));
    }
}
d619 1
a619 4
sub varglob {
    my ($obj, $var) = @@_;
    return *{$obj->root()."::$var"};
}
d621 3
a623 5
sub reval {
    my ($obj, $expr) = @@_;
    my $root = $obj->{Root};
    my $mask = $obj->{Mask};
    verify_mask($mask);
d625 1
a625 8
    my $evalsub = eval sprintf(<<'EOT', $root);
	package %s;
	sub {
	    eval $expr;
	}
EOT
    return safe_call_sv($root, $mask, $evalsub);
}
d627 1
a627 5
sub rdo {
    my ($obj, $file) = @@_;
    my $root = $obj->{Root};
    my $mask = $obj->{Mask};
    verify_mask($mask);
d629 1
a629 9
    $file =~ s/"/\\"/g; # just in case the filename contains any double quotes
    my $evalsub = eval sprintf(<<'EOT', $root, $file);
	package %s;
	sub {
	    do "%s";
	}
EOT
    return safe_call_sv($root, $mask, $evalsub);
}
d631 1
a631 1
bootstrap Safe $VERSION;
d633 1
a633 8
$default_mask = fullmask;
my $name;
while (defined ($name = <DATA>)) {
    chomp $name;
    next if $name =~ /^#/;
    my $code = opcode($name);
    substr($default_mask, $code, 1) = "\0";
}
d635 1
a635 1
1;
a636 268
__DATA__
null
stub
scalar
pushmark
wantarray
const
gvsv
gv
gelem
padsv
padav
padhv
padany
pushre
rv2gv
rv2sv
av2arylen
rv2cv
anoncode
prototype
refgen
srefgen
ref
bless
glob
readline
rcatline
regcmaybe
regcomp
match
subst
substcont
trans
sassign
aassign
chop
schop
chomp
schomp
defined
undef
study
pos
preinc
i_preinc
predec
i_predec
postinc
i_postinc
postdec
i_postdec
pow
multiply
i_multiply
divide
i_divide
modulo
i_modulo
repeat
add
i_add
subtract
i_subtract
concat
stringify
left_shift
right_shift
lt
i_lt
gt
i_gt
le
i_le
ge
i_ge
eq
i_eq
ne
i_ne
ncmp
i_ncmp
slt
sgt
sle
sge
seq
sne
scmp
bit_and
bit_xor
bit_or
negate
i_negate
not
complement
atan2
sin
cos
rand
srand
exp
log
sqrt
int
hex
oct
abs
length
substr
vec
index
rindex
sprintf
formline
ord
chr
crypt
ucfirst
lcfirst
uc
lc
quotemeta
rv2av
aelemfast
aelem
aslice
each
values
keys
delete
exists
rv2hv
helem
hslice
split
join
list
lslice
anonlist
anonhash
splice
push
pop
shift
unshift
reverse
grepstart
grepwhile
mapstart
mapwhile
range
flip
flop
and
or
xor
cond_expr
andassign
orassign
method
entersub
leavesub
caller
warn
die
reset
lineseq
nextstate
dbstate
unstack
enter
leave
scope
enteriter
iter
enterloop
leaveloop
return
last
next
redo
goto
close
fileno
tie
untie
dbmopen
dbmclose
sselect
select
getc
read
enterwrite
leavewrite
prtf
print
sysread
syswrite
send
recv
eof
tell
seek
truncate
fcntl
ioctl
sockpair
bind
connect
listen
accept
shutdown
gsockopt
ssockopt
getsockname
ftrwrite
ftsvtx
open_dir
readdir
telldir
seekdir
rewinddir
kill
getppid
getpgrp
setpgrp
getpriority
setpriority
time
tms
localtime
alarm
dofile
entereval
leaveeval
entertry
leavetry
ghbyname
ghbyaddr
ghostent
gnbyname
gnbyaddr
gnetent
gpbyname
gpbynumber
gprotoent
gsbyname
gsbyport
gservent
shostent
snetent
sprotoent
sservent
ehostent
enetent
eprotoent
eservent
gpwnam
gpwuid
gpwent
spwent
epwent
ggrnam
ggrgid
ggrent
sgrent
egrent
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@import perl 5.10.1
@
text
@d3 1
a3 24
use 5.003_11;
use strict;

$Safe::VERSION = "2.18";

# *** Don't declare any lexicals above this point ***
#
# This function should return a closure which contains an eval that can't
# see any lexicals in scope (apart from __ExPr__ which is unavoidable)

sub lexless_anon_sub {
		 # $_[0] is package;
		 # $_[1] is strict flag;
    my $__ExPr__ = $_[2];   # must be a lexical to create the closure that
			    # can be used to pass the value into the safe
			    # world

    # Create anon sub ref in root of compartment.
    # Uses a closure (on $__ExPr__) to pass in the code to be executed.
    # (eval on one line to keep line numbers as expected by caller)
    eval sprintf
    'package %s; %s strict; sub { @@_=(); eval q[my $__ExPr__;] . $__ExPr__; }',
		$_[0], $_[1] ? 'use' : 'no';
}
d5 2
d8 4
a11 279
BEGIN { eval q{
    use Carp::Heavy;
} }

use Opcode 1.01, qw(
    opset opset_to_ops opmask_add
    empty_opset full_opset invert_opset verify_opset
    opdesc opcodes opmask define_optag opset_to_hex
);

*ops_to_opset = \&opset;   # Temporary alias for old Penguins


my $default_root  = 0;
# share *_ and functions defined in universal.c
# Don't share stuff like *UNIVERSAL:: otherwise code from the
# compartment can 0wn functions in UNIVERSAL
my $default_share = [qw[
    *_
    &PerlIO::get_layers
    &UNIVERSAL::isa
    &UNIVERSAL::can
    &UNIVERSAL::VERSION
    &utf8::is_utf8
    &utf8::valid
    &utf8::encode
    &utf8::decode
    &utf8::upgrade
    &utf8::downgrade
    &utf8::native_to_unicode
    &utf8::unicode_to_native
    $version::VERSION
    $version::CLASS
    @@version::ISA
], ($] >= 5.008001 && qw[
    &Regexp::DESTROY
]), ($] >= 5.010 && qw[
    &re::is_regexp
    &re::regname
    &re::regnames
    &re::regnames_count
    &Tie::Hash::NamedCapture::FETCH
    &Tie::Hash::NamedCapture::STORE
    &Tie::Hash::NamedCapture::DELETE
    &Tie::Hash::NamedCapture::CLEAR
    &Tie::Hash::NamedCapture::EXISTS
    &Tie::Hash::NamedCapture::FIRSTKEY
    &Tie::Hash::NamedCapture::NEXTKEY
    &Tie::Hash::NamedCapture::SCALAR
    &Tie::Hash::NamedCapture::flags
    &UNIVERSAL::DOES
    &version::()
    &version::new
    &version::(""
    &version::stringify
    &version::(0+
    &version::numify
    &version::normal
    &version::(cmp
    &version::(<=>
    &version::vcmp
    &version::(bool
    &version::boolean
    &version::(nomethod
    &version::noop
    &version::is_alpha
    &version::qv
]), ($] >= 5.011 && qw[
    &re::regexp_pattern
])];

sub new {
    my($class, $root, $mask) = @@_;
    my $obj = {};
    bless $obj, $class;

    if (defined($root)) {
	croak "Can't use \"$root\" as root name"
	    if $root =~ /^main\b/ or $root !~ /^\w[:\w]*$/;
	$obj->{Root}  = $root;
	$obj->{Erase} = 0;
    }
    else {
	$obj->{Root}  = "Safe::Root".$default_root++;
	$obj->{Erase} = 1;
    }

    # use permit/deny methods instead till interface issues resolved
    # XXX perhaps new Safe 'Root', mask => $mask, foo => bar, ...;
    croak "Mask parameter to new no longer supported" if defined $mask;
    $obj->permit_only(':default');

    # We must share $_ and @@_ with the compartment or else ops such
    # as split, length and so on won't default to $_ properly, nor
    # will passing argument to subroutines work (via @@_). In fact,
    # for reasons I don't completely understand, we need to share
    # the whole glob *_ rather than $_ and @@_ separately, otherwise
    # @@_ in non default packages within the compartment don't work.
    $obj->share_from('main', $default_share);
    Opcode::_safe_pkg_prep($obj->{Root}) if($Opcode::VERSION > 1.04);
    return $obj;
}

sub DESTROY {
    my $obj = shift;
    $obj->erase('DESTROY') if $obj->{Erase};
}

sub erase {
    my ($obj, $action) = @@_;
    my $pkg = $obj->root();
    my ($stem, $leaf);

    no strict 'refs';
    $pkg = "main::$pkg\::";	# expand to full symbol table name
    ($stem, $leaf) = $pkg =~ m/(.*::)(\w+::)$/;

    # The 'my $foo' is needed! Without it you get an
    # 'Attempt to free unreferenced scalar' warning!
    my $stem_symtab = *{$stem}{HASH};

    #warn "erase($pkg) stem=$stem, leaf=$leaf";
    #warn " stem_symtab hash ".scalar(%$stem_symtab)."\n";
	# ", join(', ', %$stem_symtab),"\n";

#    delete $stem_symtab->{$leaf};

    my $leaf_glob   = $stem_symtab->{$leaf};
    my $leaf_symtab = *{$leaf_glob}{HASH};
#    warn " leaf_symtab ", join(', ', %$leaf_symtab),"\n";
    %$leaf_symtab = ();
    #delete $leaf_symtab->{'__ANON__'};
    #delete $leaf_symtab->{'foo'};
    #delete $leaf_symtab->{'main::'};
#    my $foo = undef ${"$stem\::"}{"$leaf\::"};

    if ($action and $action eq 'DESTROY') {
        delete $stem_symtab->{$leaf};
    } else {
        $obj->share_from('main', $default_share);
    }
    1;
}


sub reinit {
    my $obj= shift;
    $obj->erase;
    $obj->share_redo;
}

sub root {
    my $obj = shift;
    croak("Safe root method now read-only") if @@_;
    return $obj->{Root};
}


sub mask {
    my $obj = shift;
    return $obj->{Mask} unless @@_;
    $obj->deny_only(@@_);
}

# v1 compatibility methods
sub trap   { shift->deny(@@_)   }
sub untrap { shift->permit(@@_) }

sub deny {
    my $obj = shift;
    $obj->{Mask} |= opset(@@_);
}
sub deny_only {
    my $obj = shift;
    $obj->{Mask} = opset(@@_);
}

sub permit {
    my $obj = shift;
    # XXX needs testing
    $obj->{Mask} &= invert_opset opset(@@_);
}
sub permit_only {
    my $obj = shift;
    $obj->{Mask} = invert_opset opset(@@_);
}


sub dump_mask {
    my $obj = shift;
    print opset_to_hex($obj->{Mask}),"\n";
}



sub share {
    my($obj, @@vars) = @@_;
    $obj->share_from(scalar(caller), \@@vars);
}

sub share_from {
    my $obj = shift;
    my $pkg = shift;
    my $vars = shift;
    my $no_record = shift || 0;
    my $root = $obj->root();
    croak("vars not an array ref") unless ref $vars eq 'ARRAY';
    no strict 'refs';
    # Check that 'from' package actually exists
    croak("Package \"$pkg\" does not exist")
	unless keys %{"$pkg\::"};
    my $arg;
    foreach $arg (@@$vars) {
	# catch some $safe->share($var) errors:
	my ($var, $type);
	$type = $1 if ($var = $arg) =~ s/^(\W)//;
	# warn "share_from $pkg $type $var";
	for (1..2) { # assign twice to avoid any 'used once' warnings
	    *{$root."::$var"} = (!$type)       ? \&{$pkg."::$var"}
			  : ($type eq '&') ? \&{$pkg."::$var"}
			  : ($type eq '$') ? \${$pkg."::$var"}
			  : ($type eq '@@') ? \@@{$pkg."::$var"}
			  : ($type eq '%') ? \%{$pkg."::$var"}
			  : ($type eq '*') ?  *{$pkg."::$var"}
			  : croak(qq(Can't share "$type$var" of unknown type));
	}
    }
    $obj->share_record($pkg, $vars) unless $no_record or !$vars;
}

sub share_record {
    my $obj = shift;
    my $pkg = shift;
    my $vars = shift;
    my $shares = \%{$obj->{Shares} ||= {}};
    # Record shares using keys of $obj->{Shares}. See reinit.
    @@{$shares}{@@$vars} = ($pkg) x @@$vars if @@$vars;
}
sub share_redo {
    my $obj = shift;
    my $shares = \%{$obj->{Shares} ||= {}};
    my($var, $pkg);
    while(($var, $pkg) = each %$shares) {
	# warn "share_redo $pkg\:: $var";
	$obj->share_from($pkg,  [ $var ], 1);
    }
}
sub share_forget {
    delete shift->{Shares};
}

sub varglob {
    my ($obj, $var) = @@_;
    no strict 'refs';
    return *{$obj->root()."::$var"};
}


sub reval {
    my ($obj, $expr, $strict) = @@_;
    my $root = $obj->{Root};

    my $evalsub = lexless_anon_sub($root,$strict, $expr);
    return Opcode::_safe_call_sv($root, $obj->{Mask}, $evalsub);
}

sub rdo {
    my ($obj, $file) = @@_;
    my $root = $obj->{Root};

    my $evalsub = eval
	    sprintf('package %s; sub { @@_ = (); do $file }', $root);
    return Opcode::_safe_call_sv($root, $obj->{Mask}, $evalsub);
}


1;

__END__
d15 1
a15 11
Safe - Compile and execute code in restricted compartments

=head1 SYNOPSIS

  use Safe;

  $compartment = new Safe;

  $compartment->permit(qw(time sort :browse));

  $result = $compartment->reval($unsafe_code);
d29 4
a32 6
glob lookups and other tricks.

Code which is compiled outside the compartment can choose to place
variables into (or I<share> variables with) the compartment's namespace
and only that data will be visible to code evaluated in the
compartment.
d35 4
a38 4
"underscore" variables $_ and @@_ (and, technically, the less frequently
used %_, the _ filehandle and so on). This is because otherwise perl
operators which default to $_ will not work and neither will the
assignment of arguments to @@_ on subroutine entry.
d47 2
a48 2
Code evaluated in a compartment compiles subject to the
compartment's operator mask. Attempting to evaluate code in a
d52 8
a59 6
The default operator mask for a newly created compartment is
the ':default' optag.

It is important that you read the L<Opcode> module documentation
for more information, especially for detailed definitions of opnames,
optags and opsets.
d74 1
d76 12
a87 1
=head1 WARNING
d89 1
a89 2
The authors make B<no warranty>, implied or otherwise, about the
suitability of this software for safety or security purposes.
d91 1
a91 3
The authors shall not in any case be liable for special, incidental,
consequential, indirect or other similar damages arising from the use
of this software.
d93 1
a93 1
Your mileage will vary. If in any doubt B<do not use it>.
d95 1
d97 1
a97 1
=head2 RECENT CHANGES
d99 1
a99 4
The interface to the Safe module has changed quite dramatically since
version 1 (as supplied with Perl5.002). Study these pages carefully if
you have code written to use Safe version 1 because you will need to
makes changes.
d101 2
d104 1
a104 1
=head2 Methods in class Safe
d106 1
a106 1
To create a new compartment, use
d108 1
a108 9
    $cpt = new Safe;

Optional argument is (NAMESPACE), where NAMESPACE is the root namespace
to use for the compartment (defaults to "Safe::Root0", incremented for
each new compartment).

Note that version 1.00 of the Safe module supported a second optional
parameter, MASK.  That functionality has been withdrawn pending deeper
consideration. Use the permit and deny methods described below.
a113 1

d116 1
a116 1
=item permit (OP, ...)
d118 4
a121 2
Permit the listed operators to be used when compiling code in the
compartment (in I<addition> to any operators already permitted).
d123 1
a123 2
You can list opcodes by names, or use a tag name; see
L<Opcode/"Predefined Opcode Tags">.
d125 4
a128 1
=item permit_only (OP, ...)
d130 1
a130 4
Permit I<only> the listed operators to be used when compiling code in
the compartment (I<no> other operators are permitted).

=item deny (OP, ...)
d132 5
a136 9
Deny the listed operators from being used when compiling code in the
compartment (other operators may still be permitted).

=item deny_only (OP, ...)

Deny I<only> the listed operators from being used when compiling code
in the compartment (I<all> other operators will be permitted).

=item trap (OP, ...)
d140 5
a144 2
The trap and untrap methods are synonyms for deny and permit
respectfully.
d146 1
a146 1
=item share (NAME, ...)
d149 5
a153 2
This is almost identical to exporting variables using the L<Exporter>
module.
d155 1
a155 3
Each NAME must be the B<name> of a non-lexical variable, typically
with the leading type identifier included. A bareword is treated as a
function name.
d157 3
a159 4
Examples of legal names are '$foo' for a scalar, '@@foo' for an
array, '%foo' for a hash, '&foo' or 'foo' for a subroutine and '*foo'
for a glob (i.e.  all symbol table entries associated with "foo",
including scalar, array, hash, sub and filehandle).
d161 4
a164 2
Each NAME is assumed to be in the calling package. See share_from
for an alternative method (which share uses).
a165 1
=item share_from (PACKAGE, ARRAYREF)
d167 1
a167 3
This method is similar to share() but allows you to explicitly name the
package that symbols should be shared from. The symbol names (including
type characters) are supplied as an array reference.
d169 15
a183 1
    $safe->share_from('main', [ '$foo', '%bar', 'func' ]);
d185 1
d187 2
a188 1
=item varglob (VARNAME)
d190 1
a190 3
This returns a glob reference for the symbol table entry of VARNAME in
the package of the compartment. VARNAME must be the B<name> of a
variable without any leading type marker. For example,
d192 1
a192 4
    $cpt = new Safe 'Root';
    $Root::foo = "Hello world";
    # Equivalent version which doesn't need to know $cpt's package name:
    ${$cpt->varglob('foo')} = "Hello world";
d194 5
d200 1
a200 1
=item reval (STRING, STRICT)
d202 1
a202 1
This evaluates STRING as perl code inside the compartment.
d204 2
a205 18
The code can only see the compartment's namespace (as returned by the
B<root> method). The compartment's root package appears to be the
C<main::> package to the code inside the compartment.

Any attempt by the code in STRING to use an operator which is not permitted
by the compartment will cause an error (at run-time of the main program
but at compile-time for the code in STRING).  The error is of the form
"'%s' trapped by operation mask...".

If an operation is trapped in this way, then the code in STRING will
not be executed. If such a trapped operation occurs or any other
compile-time or return error, then $@@ is set to the error message, just
as with an eval().

If there is no error, then the method returns the value of the last
expression evaluated, or a return statement may be used, just as with
subroutines and B<eval()>. The context (list or scalar) is determined
by the caller as usual.
d207 1
a207 3
This behaviour differs from the beta distribution of the Safe extension
where earlier versions of perl made it hard to mimic the return
behaviour of the eval() command and the context was always scalar.
d209 2
a210 34
The formerly undocumented STRICT argument sets strictness: if true
'use strict;' is used, otherwise it uses 'no strict;'. B<Note>: if
STRICT is omitted 'no strict;' is the default.

Some points to note:

If the entereval op is permitted then the code can use eval "..." to
'hide' code which might use denied ops. This is not a major problem
since when the code tries to execute the eval it will fail because the
opmask is still in effect. However this technique would allow clever,
and possibly harmful, code to 'probe' the boundaries of what is
possible.

Any string eval which is executed by code executing in a compartment,
or by code called from code executing in a compartment, will be eval'd
in the namespace of the compartment. This is potentially a serious
problem.

Consider a function foo() in package pkg compiled outside a compartment
but shared with it. Assume the compartment has a root package called
'Root'. If foo() contains an eval statement like eval '$foo = 1' then,
normally, $pkg::foo will be set to 1.  If foo() is called from the
compartment (by whatever means) then instead of setting $pkg::foo, the
eval will actually set $Root::pkg::foo.

This can easily be demonstrated by using a module, such as the Socket
module, which uses eval "..." as part of an AUTOLOAD function. You can
'use' the module outside the compartment and share an (autoloaded)
function with the compartment. If an autoload is triggered by code in
the compartment, or by any code anywhere that is called by any means
from the compartment, then the eval in the Socket module's AUTOLOAD
function happens in the namespace of the compartment. Any variables
created or used by the eval'd code are now under the control of
the code in the compartment.
d212 1
a212 2
A similar effect applies to I<all> runtime symbol lookups in code
called from a compartment but not compiled within it.
d214 2
d217 1
d219 2
a220 1
=item rdo (FILENAME)
d222 1
a222 2
This evaluates the contents of file FILENAME inside the compartment.
See above documentation on the B<reval> method for further details.
d224 2
a225 1
=item root (NAMESPACE)
d227 1
a227 2
This method returns the name of the package that is the root of the
compartment's namespace.
d229 4
a232 3
Note that this behaviour differs from version 1.00 of the Safe module
where the root module could be used to change the namespace. That
functionality has been withdrawn pending deeper consideration.
d234 1
a234 1
=item mask (MASK)
d236 6
a241 1
This is a get-or-set method for the compartment's operator mask.
d243 1
a243 2
With no MASK argument present, it returns the current operator mask of
the compartment.
d245 3
a247 2
With the MASK argument present, it sets the operator mask for the
compartment (equivalent to calling the deny_only method).
d251 1
d253 1
a253 1
=head2 Some Safety Issues
d255 1
a255 3
This section is currently just an outline of some of the things code in
a compartment might do (intentionally or unintentionally) which can
have an effect outside the compartment.
d257 19
a275 1
=over 8
d277 8
a284 1
=item Memory
d286 8
a293 1
Consuming all (or nearly all) available memory.
d295 8
a302 1
=item CPU
d304 7
a310 1
Causing infinite loops etc.
d312 4
a315 1
=item Snooping
d317 4
a320 3
Copying private information out of your system. Even something as
simple as your user name is of value to others. Much useful information
could be gleaned from your environment variables for example.
d322 2
a323 1
=item Signals
d325 11
a335 1
Causing signals (especially SIGFPE and SIGALARM) to affect your process.
d337 16
a352 7
Setting up a signal handler will need to be carefully considered
and controlled.  What mask is in effect when a signal handler
gets called?  If a user can get an imported function to get an
exception and call the user's signal handler, does that user's
restricted mask get re-instated before the handler is called?
Does an imported handler get called with its original mask or
the user's one?
d354 4
a357 1
=item State Changes
d359 5
a363 3
Ops such as chdir obviously effect the process as a whole and not just
the code in the compartment. Ops such as rand and srand have a similar
but more subtle effect.
d365 8
a372 1
=back
d374 5
a378 1
=head2 AUTHOR
d380 9
a388 1
Originally designed and implemented by Malcolm Beattie.
d390 1
a390 1
Reworked to use the Opcode module and other changes added by Tim Bunce.
d392 8
a399 1
Currently maintained by the Perl 5 Porters, <perl5-porters@@perl.org>.
d401 1
a401 1
=cut
d403 268
@

