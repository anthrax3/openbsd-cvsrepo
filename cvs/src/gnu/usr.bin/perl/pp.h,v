head	1.16;
access;
symbols
	PERL_5_24_2:1.1.1.15
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.10
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.16
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	cxJ08BvJA9Pt2PTM;

1.15
date	2014.11.17.20.56.48;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	QP75iYx42Uo7mMxO;

1.14
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.24.15.06.42;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.35.58;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.22.58;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.56;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.18;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.55;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.17;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.09;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.46;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.46;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.43;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.44;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.17;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.49;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.34;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.45;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.47.37;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.08;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.33;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.48.26;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.06.31;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.58.46;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.52.38;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	B31cAbBIXiCqnL97;

1.1.1.15
date	2017.08.14.13.45.28;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.16
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    pp.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#define PP(s) OP * Perl_##s(pTHX)

/*
=head1 Stack Manipulation Macros

=for apidoc AmU||SP
Stack pointer.  This is usually handled by C<xsubpp>.  See C<L</dSP>> and
C<SPAGAIN>.

=for apidoc AmU||MARK
Stack marker variable for the XSUB.  See C<L</dMARK>>.

=for apidoc Am|void|PUSHMARK|SP
Opening bracket for arguments on a callback.  See C<L</PUTBACK>> and
L<perlcall>.

=for apidoc Ams||dSP
Declares a local copy of perl's stack pointer for the XSUB, available via
the C<SP> macro.  See C<L</SP>>.

=for apidoc ms||djSP

Declare Just C<SP>.  This is actually identical to C<dSP>, and declares
a local copy of perl's stack pointer, available via the C<SP> macro.
See C<L<perlapi/SP>>.  (Available for backward source code compatibility with
the old (Perl 5.005) thread model.)

=for apidoc Ams||dMARK
Declare a stack marker variable, C<mark>, for the XSUB.  See C<L</MARK>> and
C<L</dORIGMARK>>.

=for apidoc Ams||dORIGMARK
Saves the original stack mark for the XSUB.  See C<L</ORIGMARK>>.

=for apidoc AmU||ORIGMARK
The original stack mark for the XSUB.  See C<L</dORIGMARK>>.

=for apidoc Ams||SPAGAIN
Refetch the stack pointer.  Used after a callback.  See L<perlcall>.

=cut */

#undef SP /* Solaris 2.7 i386 has this in /usr/include/sys/reg.h */
#define SP sp
#define MARK mark
#define TARG targ

#if defined(DEBUGGING) && defined(PERL_USE_GCC_BRACE_GROUPS)

#  define PUSHMARK(p) \
    STMT_START {                                                      \
        I32 * mark_stack_entry;                                       \
        if (UNLIKELY((mark_stack_entry = ++PL_markstack_ptr)          \
                                           == PL_markstack_max))      \
	    mark_stack_entry = markstack_grow();                      \
        *mark_stack_entry  = (I32)((p) - PL_stack_base);              \
        DEBUG_s(DEBUG_v(PerlIO_printf(Perl_debug_log,                 \
                "MARK push %p %"IVdf"\n",                             \
                PL_markstack_ptr, (IV)*mark_stack_entry)));           \
    } STMT_END

#  define TOPMARK \
    ({                                                                \
        DEBUG_s(DEBUG_v(PerlIO_printf(Perl_debug_log,                 \
                "MARK top  %p %"IVdf"\n",                             \
                PL_markstack_ptr, (IV)*PL_markstack_ptr)));           \
        *PL_markstack_ptr;                                            \
    })

#  define POPMARK \
    ({                                                                \
        DEBUG_s(DEBUG_v(PerlIO_printf(Perl_debug_log,                 \
                "MARK pop  %p %"IVdf"\n",                             \
                (PL_markstack_ptr-1), (IV)*(PL_markstack_ptr-1))));   \
        assert((PL_markstack_ptr > PL_markstack) || !"MARK underflow");\
        *PL_markstack_ptr--;                                          \
    })

#  define INCMARK \
    ({                                                                \
        DEBUG_s(DEBUG_v(PerlIO_printf(Perl_debug_log,                 \
                "MARK inc  %p %"IVdf"\n",                             \
                (PL_markstack_ptr+1), (IV)*(PL_markstack_ptr+1))));   \
        *PL_markstack_ptr++;                                          \
    })

#else

#  define PUSHMARK(p)                                                   \
    STMT_START {					              \
        I32 * mark_stack_entry;                                       \
        if (UNLIKELY((mark_stack_entry = ++PL_markstack_ptr) == PL_markstack_max)) \
	    mark_stack_entry = markstack_grow();                      \
        *mark_stack_entry  = (I32)((p) - PL_stack_base);              \
    } STMT_END
#  define TOPMARK                (*PL_markstack_ptr)
#  define POPMARK                (*PL_markstack_ptr--)
#  define INCMARK                (*PL_markstack_ptr++)
#endif

#define dSP		SV **sp = PL_stack_sp
#define djSP		dSP
#define dMARK		SV **mark = PL_stack_base + POPMARK
#define dORIGMARK	const I32 origmark = (I32)(mark - PL_stack_base)
#define ORIGMARK	(PL_stack_base + origmark)

#define SPAGAIN		sp = PL_stack_sp
#define MSPAGAIN	STMT_START { sp = PL_stack_sp; mark = ORIGMARK; } STMT_END

#define GETTARGETSTACKED targ = (PL_op->op_flags & OPf_STACKED ? POPs : PAD_SV(PL_op->op_targ))
#define dTARGETSTACKED SV * GETTARGETSTACKED

#define GETTARGET targ = PAD_SV(PL_op->op_targ)
#define dTARGET SV * GETTARGET

#define GETATARGET targ = (PL_op->op_flags & OPf_STACKED ? sp[-1] : PAD_SV(PL_op->op_targ))
#define dATARGET SV * GETATARGET

#define dTARG SV *targ

#define NORMAL PL_op->op_next
#define DIE return Perl_die

/*
=for apidoc Ams||PUTBACK
Closing bracket for XSUB arguments.  This is usually handled by C<xsubpp>.
See C<L</PUSHMARK>> and L<perlcall> for other uses.

=for apidoc Amn|SV*|POPs
Pops an SV off the stack.

=for apidoc Amn|char*|POPp
Pops a string off the stack.

=for apidoc Amn|char*|POPpx
Pops a string off the stack.  Identical to POPp.  There are two names for
historical reasons.

=for apidoc Amn|char*|POPpbytex
Pops a string off the stack which must consist of bytes i.e. characters < 256.

=for apidoc Amn|NV|POPn
Pops a double off the stack.

=for apidoc Amn|IV|POPi
Pops an integer off the stack.

=for apidoc Amn|UV|POPu
Pops an unsigned integer off the stack.

=for apidoc Amn|long|POPl
Pops a long off the stack.

=for apidoc Amn|long|POPul
Pops an unsigned long off the stack.

=cut
*/

#define PUTBACK		PL_stack_sp = sp
#define RETURN		return (PUTBACK, NORMAL)
#define RETURNOP(o)	return (PUTBACK, o)
#define RETURNX(x)	return (x, PUTBACK, NORMAL)

#define POPs		(*sp--)
#define POPp		POPpx
#define POPpx		(SvPVx_nolen(POPs))
#define POPpconstx	(SvPVx_nolen_const(POPs))
#define POPpbytex	(SvPVbytex_nolen(POPs))
#define POPn		(SvNVx(POPs))
#define POPi		((IV)SvIVx(POPs))
#define POPu		((UV)SvUVx(POPs))
#define POPl		((long)SvIVx(POPs))
#define POPul		((unsigned long)SvIVx(POPs))

#define TOPs		(*sp)
#define TOPm1s		(*(sp-1))
#define TOPp1s		(*(sp+1))
#define TOPp		TOPpx
#define TOPpx		(SvPV_nolen(TOPs))
#define TOPn		(SvNV(TOPs))
#define TOPi		((IV)SvIV(TOPs))
#define TOPu		((UV)SvUV(TOPs))
#define TOPl		((long)SvIV(TOPs))
#define TOPul		((unsigned long)SvUV(TOPs))

/* Go to some pains in the rare event that we must extend the stack. */

/*
=for apidoc Am|void|EXTEND|SP|SSize_t nitems
Used to extend the argument stack for an XSUB's return values.  Once
used, guarantees that there is room for at least C<nitems> to be pushed
onto the stack.

=for apidoc Am|void|PUSHs|SV* sv
Push an SV onto the stack.  The stack must have room for this element.
Does not handle 'set' magic.  Does not use C<TARG>.  See also
C<L</PUSHmortal>>, C<L</XPUSHs>>, and C<L</XPUSHmortal>>.

=for apidoc Am|void|PUSHp|char* str|STRLEN len
Push a string onto the stack.  The stack must have room for this element.
The C<len> indicates the length of the string.  Handles 'set' magic.  Uses
C<TARG>, so C<dTARGET> or C<dXSTARG> should be called to declare it.  Do not
call multiple C<TARG>-oriented macros to return lists from XSUB's - see
C<L</mPUSHp>> instead.  See also C<L</XPUSHp>> and C<L</mXPUSHp>>.

=for apidoc Am|void|PUSHn|NV nv
Push a double onto the stack.  The stack must have room for this element.
Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be
called to declare it.  Do not call multiple C<TARG>-oriented macros to
return lists from XSUB's - see C<L</mPUSHn>> instead.  See also C<L</XPUSHn>>
and C<L</mXPUSHn>>.

=for apidoc Am|void|PUSHi|IV iv
Push an integer onto the stack.  The stack must have room for this element.
Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be
called to declare it.  Do not call multiple C<TARG>-oriented macros to 
return lists from XSUB's - see C<L</mPUSHi>> instead.  See also C<L</XPUSHi>>
and C<L</mXPUSHi>>.

=for apidoc Am|void|PUSHu|UV uv
Push an unsigned integer onto the stack.  The stack must have room for this
element.  Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG>
should be called to declare it.  Do not call multiple C<TARG>-oriented
macros to return lists from XSUB's - see C<L</mPUSHu>> instead.  See also
C<L</XPUSHu>> and C<L</mXPUSHu>>.

=for apidoc Am|void|XPUSHs|SV* sv
Push an SV onto the stack, extending the stack if necessary.  Does not
handle 'set' magic.  Does not use C<TARG>.  See also C<L</XPUSHmortal>>,
C<PUSHs> and C<PUSHmortal>.

=for apidoc Am|void|XPUSHp|char* str|STRLEN len
Push a string onto the stack, extending the stack if necessary.  The C<len>
indicates the length of the string.  Handles 'set' magic.  Uses C<TARG>, so
C<dTARGET> or C<dXSTARG> should be called to declare it.  Do not call
multiple C<TARG>-oriented macros to return lists from XSUB's - see
C<L</mXPUSHp>> instead.  See also C<L</PUSHp>> and C<L</mPUSHp>>.

=for apidoc Am|void|XPUSHn|NV nv
Push a double onto the stack, extending the stack if necessary.  Handles
'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be called to
declare it.  Do not call multiple C<TARG>-oriented macros to return lists
from XSUB's - see C<L</mXPUSHn>> instead.  See also C<L</PUSHn>> and
C<L</mPUSHn>>.

=for apidoc Am|void|XPUSHi|IV iv
Push an integer onto the stack, extending the stack if necessary.  Handles
'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be called to
declare it.  Do not call multiple C<TARG>-oriented macros to return lists
from XSUB's - see C<L</mXPUSHi>> instead.  See also C<L</PUSHi>> and
C<L</mPUSHi>>.

=for apidoc Am|void|XPUSHu|UV uv
Push an unsigned integer onto the stack, extending the stack if necessary.
Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be
called to declare it.  Do not call multiple C<TARG>-oriented macros to
return lists from XSUB's - see C<L</mXPUSHu>> instead.  See also C<L</PUSHu>> and
C<L</mPUSHu>>.

=for apidoc Am|void|mPUSHs|SV* sv
Push an SV onto the stack and mortalizes the SV.  The stack must have room
for this element.  Does not use C<TARG>.  See also C<L</PUSHs>> and
C<L</mXPUSHs>>.

=for apidoc Am|void|PUSHmortal
Push a new mortal SV onto the stack.  The stack must have room for this
element.  Does not use C<TARG>.  See also C<L</PUSHs>>, C<L</XPUSHmortal>> and
C<L</XPUSHs>>.

=for apidoc Am|void|mPUSHp|char* str|STRLEN len
Push a string onto the stack.  The stack must have room for this element.
The C<len> indicates the length of the string.  Does not use C<TARG>.
See also C<L</PUSHp>>, C<L</mXPUSHp>> and C<L</XPUSHp>>.

=for apidoc Am|void|mPUSHn|NV nv
Push a double onto the stack.  The stack must have room for this element.
Does not use C<TARG>.  See also C<L</PUSHn>>, C<L</mXPUSHn>> and C<L</XPUSHn>>.

=for apidoc Am|void|mPUSHi|IV iv
Push an integer onto the stack.  The stack must have room for this element.
Does not use C<TARG>.  See also C<L</PUSHi>>, C<L</mXPUSHi>> and C<L</XPUSHi>>.

=for apidoc Am|void|mPUSHu|UV uv
Push an unsigned integer onto the stack.  The stack must have room for this
element.  Does not use C<TARG>.  See also C<L</PUSHu>>, C<L</mXPUSHu>> and
C<L</XPUSHu>>.

=for apidoc Am|void|mXPUSHs|SV* sv
Push an SV onto the stack, extending the stack if necessary and mortalizes
the SV.  Does not use C<TARG>.  See also C<L</XPUSHs>> and C<L</mPUSHs>>.

=for apidoc Am|void|XPUSHmortal
Push a new mortal SV onto the stack, extending the stack if necessary.
Does not use C<TARG>.  See also C<L</XPUSHs>>, C<L</PUSHmortal>> and
C<L</PUSHs>>.

=for apidoc Am|void|mXPUSHp|char* str|STRLEN len
Push a string onto the stack, extending the stack if necessary.  The C<len>
indicates the length of the string.  Does not use C<TARG>.  See also
C<L</XPUSHp>>, C<mPUSHp> and C<PUSHp>.

=for apidoc Am|void|mXPUSHn|NV nv
Push a double onto the stack, extending the stack if necessary.
Does not use C<TARG>.  See also C<L</XPUSHn>>, C<L</mPUSHn>> and C<L</PUSHn>>.

=for apidoc Am|void|mXPUSHi|IV iv
Push an integer onto the stack, extending the stack if necessary.
Does not use C<TARG>.  See also C<L</XPUSHi>>, C<L</mPUSHi>> and C<L</PUSHi>>.

=for apidoc Am|void|mXPUSHu|UV uv
Push an unsigned integer onto the stack, extending the stack if necessary.
Does not use C<TARG>.  See also C<L</XPUSHu>>, C<L</mPUSHu>> and C<L</PUSHu>>.

=cut
*/

/* _EXTEND_SAFE_N(n): private helper macro for EXTEND().
 * Tests whether the value of n would be truncated when implicitly cast to
 * SSize_t as an arg to stack_grow(). If so, sets it to -1 instead to
 * trigger a panic. It will be constant folded on platforms where this
 * can't happen.
 */

#define _EXTEND_SAFE_N(n) \
        (sizeof(n) > sizeof(SSize_t) && ((SSize_t)(n) != (n)) ? -1 : (n))

#ifdef STRESS_REALLOC
# define EXTEND(p,n)   STMT_START {                                     \
                           sp = stack_grow(sp,p,_EXTEND_SAFE_N(n));     \
                           PERL_UNUSED_VAR(sp);                         \
                       } STMT_END
/* Same thing, but update mark register too. */
# define MEXTEND(p,n)   STMT_START {                                    \
                            const SSize_t markoff = mark - PL_stack_base; \
                            sp = stack_grow(sp,p,_EXTEND_SAFE_N(n));    \
                            mark = PL_stack_base + markoff;             \
                            PERL_UNUSED_VAR(sp);                        \
                        } STMT_END
#else

/* _EXTEND_NEEDS_GROW(p,n): private helper macro for EXTEND().
 * Tests to see whether n is too big and we need to grow the stack. Be
 * very careful if modifying this. There are many ways to get things wrong
 * (wrapping, truncating etc) that could cause a false negative and cause
 * the call to stack_grow() to be skipped. On the other hand, false
 * positives are safe.
 * Bear in mind that sizeof(p) may be less than, equal to, or greater
 * than sizeof(n), and while n is documented to be signed, someone might
 * pass an unsigned value or expression. In general don't use casts to
 * avoid warnings; instead expect the caller to fix their code.
 * It is legal for p to be greater than PL_stack_max.
 * If the allocated stack is already very large but current usage is
 * small, then PL_stack_max - p might wrap round to a negative value, but
 * this just gives a safe false positive
 */

#  define _EXTEND_NEEDS_GROW(p,n) ( (n) < 0 || PL_stack_max - p < (n))

#  define EXTEND(p,n)   STMT_START {                                    \
                         if (UNLIKELY(_EXTEND_NEEDS_GROW(p,n))) {       \
                           sp = stack_grow(sp,p,_EXTEND_SAFE_N(n));     \
                           PERL_UNUSED_VAR(sp);                         \
                         } } STMT_END
/* Same thing, but update mark register too. */
#  define MEXTEND(p,n)  STMT_START {                                    \
                         if (UNLIKELY(_EXTEND_NEEDS_GROW(p,n))) {       \
                           const SSize_t markoff = mark - PL_stack_base;\
                           sp = stack_grow(sp,p,_EXTEND_SAFE_N(n));     \
                           mark = PL_stack_base + markoff;              \
                           PERL_UNUSED_VAR(sp);                         \
                         } } STMT_END
#endif

/* set TARG to the IV value i. If do_taint is false,
 * assume that PL_tainted can never be true */
#define TARGi(i, do_taint) \
    STMT_START {                                                        \
        IV TARGi_iv = i;                                                \
        if (LIKELY(                                                     \
              ((SvFLAGS(TARG) & (SVTYPEMASK|SVf_THINKFIRST|SVf_IVisUV)) == SVt_IV) \
            & (do_taint ? !TAINT_get : 1)))                             \
        {                                                               \
            /* Cheap SvIOK_only().                                      \
             * Assert that flags which SvIOK_only() would test or       \
             * clear can't be set, because we're SVt_IV */              \
            assert(!(SvFLAGS(TARG) &                                    \
                (SVf_OOK|SVf_UTF8|(SVf_OK & ~(SVf_IOK|SVp_IOK)))));     \
            SvFLAGS(TARG) |= (SVf_IOK|SVp_IOK);                         \
            /* SvIV_set() where sv_any points to head */                \
            TARG->sv_u.svu_iv = TARGi_iv;                               \
        }                                                               \
        else                                                            \
            sv_setiv_mg(targ, TARGi_iv);                                \
    } STMT_END

/* set TARG to the UV value u. If do_taint is false,
 * assume that PL_tainted can never be true */
#define TARGu(u, do_taint) \
    STMT_START {                                                        \
        UV TARGu_uv = u;                                                \
        if (LIKELY(                                                     \
              ((SvFLAGS(TARG) & (SVTYPEMASK|SVf_THINKFIRST|SVf_IVisUV)) == SVt_IV) \
            & (do_taint ? !TAINT_get : 1)                               \
            & (TARGu_uv <= (UV)IV_MAX)))                                \
        {                                                               \
            /* Cheap SvIOK_only().                                      \
             * Assert that flags which SvIOK_only() would test or       \
             * clear can't be set, because we're SVt_IV */              \
            assert(!(SvFLAGS(TARG) &                                    \
                (SVf_OOK|SVf_UTF8|(SVf_OK & ~(SVf_IOK|SVp_IOK)))));     \
            SvFLAGS(TARG) |= (SVf_IOK|SVp_IOK);                         \
            /* SvIV_set() where sv_any points to head */                \
            TARG->sv_u.svu_iv = TARGu_uv;                               \
        }                                                               \
        else                                                            \
            sv_setuv_mg(targ, TARGu_uv);                                \
    } STMT_END

/* set TARG to the NV value n. If do_taint is false,
 * assume that PL_tainted can never be true */
#define TARGn(n, do_taint) \
    STMT_START {                                                        \
        NV TARGn_nv = n;                                                \
        if (LIKELY(                                                     \
              ((SvFLAGS(TARG) & (SVTYPEMASK|SVf_THINKFIRST)) == SVt_NV) \
            & (do_taint ? !TAINT_get : 1)))                             \
        {                                                               \
            /* Cheap SvNOK_only().                                      \
             * Assert that flags which SvNOK_only() would test or       \
             * clear can't be set, because we're SVt_NV */              \
            assert(!(SvFLAGS(TARG) &                                    \
                (SVf_OOK|SVf_UTF8|(SVf_OK & ~(SVf_NOK|SVp_NOK)))));     \
            SvFLAGS(TARG) |= (SVf_NOK|SVp_NOK);                         \
            SvNV_set(TARG, TARGn_nv);                                   \
        }                                                               \
        else                                                            \
            sv_setnv_mg(targ, TARGn_nv);                                \
    } STMT_END

#define PUSHs(s)	(*++sp = (s))
#define PUSHTARG	STMT_START { SvSETMAGIC(TARG); PUSHs(TARG); } STMT_END
#define PUSHp(p,l)	STMT_START { sv_setpvn(TARG, (p), (l)); PUSHTARG; } STMT_END
#define PUSHn(n)	STMT_START { TARGn(n,1); PUSHs(TARG); } STMT_END
#define PUSHi(i)	STMT_START { TARGi(i,1); PUSHs(TARG); } STMT_END
#define PUSHu(u)	STMT_START { TARGu(u,1); PUSHs(TARG); } STMT_END

#define XPUSHs(s)	STMT_START { EXTEND(sp,1); *++sp = (s); } STMT_END
#define XPUSHTARG	STMT_START { SvSETMAGIC(TARG); XPUSHs(TARG); } STMT_END
#define XPUSHp(p,l)	STMT_START { sv_setpvn(TARG, (p), (l)); XPUSHTARG; } STMT_END
#define XPUSHn(n)	STMT_START { TARGn(n,1); XPUSHs(TARG); } STMT_END
#define XPUSHi(i)	STMT_START { TARGi(i,1); XPUSHs(TARG); } STMT_END
#define XPUSHu(u)	STMT_START { TARGu(u,1); XPUSHs(TARG); } STMT_END
#define XPUSHundef	STMT_START { SvOK_off(TARG); XPUSHs(TARG); } STMT_END

#define mPUSHs(s)	PUSHs(sv_2mortal(s))
#define PUSHmortal	PUSHs(sv_newmortal())
#define mPUSHp(p,l)	PUSHs(newSVpvn_flags((p), (l), SVs_TEMP))
#define mPUSHn(n)	sv_setnv(PUSHmortal, (NV)(n))
#define mPUSHi(i)	sv_setiv(PUSHmortal, (IV)(i))
#define mPUSHu(u)	sv_setuv(PUSHmortal, (UV)(u))

#define mXPUSHs(s)	XPUSHs(sv_2mortal(s))
#define XPUSHmortal	XPUSHs(sv_newmortal())
#define mXPUSHp(p,l)	STMT_START { EXTEND(sp,1); mPUSHp((p), (l)); } STMT_END
#define mXPUSHn(n)	STMT_START { EXTEND(sp,1); sv_setnv(PUSHmortal, (NV)(n)); } STMT_END
#define mXPUSHi(i)	STMT_START { EXTEND(sp,1); sv_setiv(PUSHmortal, (IV)(i)); } STMT_END
#define mXPUSHu(u)	STMT_START { EXTEND(sp,1); sv_setuv(PUSHmortal, (UV)(u)); } STMT_END

#define SETs(s)		(*sp = s)
#define SETTARG		STMT_START { SvSETMAGIC(TARG); SETs(TARG); } STMT_END
#define SETp(p,l)	STMT_START { sv_setpvn(TARG, (p), (l)); SETTARG; } STMT_END
#define SETn(n)		STMT_START { TARGn(n,1); SETs(TARG); } STMT_END
#define SETi(i)		STMT_START { TARGi(i,1); SETs(TARG); } STMT_END
#define SETu(u)		STMT_START { TARGu(u,1); SETs(TARG); } STMT_END

#define dTOPss		SV *sv = TOPs
#define dPOPss		SV *sv = POPs
#define dTOPnv		NV value = TOPn
#define dPOPnv		NV value = POPn
#define dPOPnv_nomg	NV value = (sp--, SvNV_nomg(TOPp1s))
#define dTOPiv		IV value = TOPi
#define dPOPiv		IV value = POPi
#define dTOPuv		UV value = TOPu
#define dPOPuv		UV value = POPu

#define dPOPXssrl(X)	SV *right = POPs; SV *left = CAT2(X,s)
#define dPOPXnnrl(X)	NV right = POPn; NV left = CAT2(X,n)
#define dPOPXiirl(X)	IV right = POPi; IV left = CAT2(X,i)

#define USE_LEFT(sv) \
	(SvOK(sv) || !(PL_op->op_flags & OPf_STACKED))
#define dPOPXiirl_ul_nomg(X) \
    IV right = (sp--, SvIV_nomg(TOPp1s));		\
    SV *leftsv = CAT2(X,s);				\
    IV left = USE_LEFT(leftsv) ? SvIV_nomg(leftsv) : 0

#define dPOPPOPssrl	dPOPXssrl(POP)
#define dPOPPOPnnrl	dPOPXnnrl(POP)
#define dPOPPOPiirl	dPOPXiirl(POP)

#define dPOPTOPssrl	dPOPXssrl(TOP)
#define dPOPTOPnnrl	dPOPXnnrl(TOP)
#define dPOPTOPnnrl_nomg \
    NV right = SvNV_nomg(TOPs); NV left = (sp--, SvNV_nomg(TOPs))
#define dPOPTOPiirl	dPOPXiirl(TOP)
#define dPOPTOPiirl_ul_nomg dPOPXiirl_ul_nomg(TOP)
#define dPOPTOPiirl_nomg \
    IV right = SvIV_nomg(TOPs); IV left = (sp--, SvIV_nomg(TOPs))

#define RETPUSHYES	RETURNX(PUSHs(&PL_sv_yes))
#define RETPUSHNO	RETURNX(PUSHs(&PL_sv_no))
#define RETPUSHUNDEF	RETURNX(PUSHs(&PL_sv_undef))

#define RETSETYES	RETURNX(SETs(&PL_sv_yes))
#define RETSETNO	RETURNX(SETs(&PL_sv_no))
#define RETSETUNDEF	RETURNX(SETs(&PL_sv_undef))
#define RETSETTARG	STMT_START { SETTARG; RETURN; } STMT_END

#define ARGTARG		PL_op->op_targ

#define MAXARG		(PL_op->op_private & OPpARG4_MASK)

#define SWITCHSTACK(f,t) \
    STMT_START {							\
	AvFILLp(f) = sp - PL_stack_base;				\
	PL_stack_base = AvARRAY(t);					\
	PL_stack_max = PL_stack_base + AvMAX(t);			\
	sp = PL_stack_sp = PL_stack_base + AvFILLp(t);			\
	PL_curstack = t;						\
    } STMT_END

#define EXTEND_MORTAL(n) \
    STMT_START {						\
	SSize_t eMiX = PL_tmps_ix + (n);			\
	if (UNLIKELY(eMiX >= PL_tmps_max))			\
	    (void)Perl_tmps_grow_p(aTHX_ eMiX);			\
    } STMT_END

#define AMGf_noright	1
#define AMGf_noleft	2
#define AMGf_assign	4
#define AMGf_unary	8
#define AMGf_numeric	0x10	/* for Perl_try_amagic_bin */
#define AMGf_set	0x20	/* for Perl_try_amagic_bin */
#define AMGf_want_list	0x40
#define AMGf_numarg	0x80


/* do SvGETMAGIC on the stack args before checking for overload */

#define tryAMAGICun_MG(method, flags) STMT_START { \
	if ( UNLIKELY((SvFLAGS(TOPs) & (SVf_ROK|SVs_GMG))) \
		&& Perl_try_amagic_un(aTHX_ method, flags)) \
	    return NORMAL; \
    } STMT_END
#define tryAMAGICbin_MG(method, flags) STMT_START { \
	if ( UNLIKELY(((SvFLAGS(TOPm1s)|SvFLAGS(TOPs)) & (SVf_ROK|SVs_GMG))) \
		&& Perl_try_amagic_bin(aTHX_ method, flags)) \
	    return NORMAL; \
    } STMT_END

#define AMG_CALLunary(sv,meth) \
    amagic_call(sv,&PL_sv_undef, meth, AMGf_noright | AMGf_unary)

/* No longer used in core. Use AMG_CALLunary instead */
#define AMG_CALLun(sv,meth) AMG_CALLunary(sv, CAT2(meth,_amg))

#define tryAMAGICunTARGETlist(meth, jump)			\
    STMT_START {						\
	dSP;							\
	SV *tmpsv;						\
	SV *arg= *sp;						\
        U8 gimme = GIMME_V;                                    \
	if (UNLIKELY(SvAMAGIC(arg) &&				\
	    (tmpsv = amagic_call(arg, &PL_sv_undef, meth,	\
				 AMGf_want_list | AMGf_noright	\
				|AMGf_unary))))                 \
        {                                       		\
	    SPAGAIN;						\
            if (gimme == G_VOID) {                              \
                NOOP;                                           \
            }                                                   \
            else if (gimme == G_ARRAY) {			\
                SSize_t i;                                      \
                SSize_t len;                                    \
                assert(SvTYPE(tmpsv) == SVt_PVAV);              \
                len = av_tindex((AV *)tmpsv) + 1;               \
                (void)POPs; /* get rid of the arg */            \
                EXTEND(sp, len);                                \
                for (i = 0; i < len; ++i)                       \
                    PUSHs(av_shift((AV *)tmpsv));               \
            }                                                   \
            else { /* AMGf_want_scalar */                       \
                dATARGET; /* just use the arg's location */     \
                sv_setsv(TARG, tmpsv);                          \
                if (opASSIGN)                                   \
                    sp--;                                       \
                SETTARG;                                        \
            }                                                   \
	    PUTBACK;						\
	    if (jump) {						\
	        OP *jump_o = NORMAL->op_next;                   \
		while (jump_o->op_type == OP_NULL)		\
		    jump_o = jump_o->op_next;			\
		assert(jump_o->op_type == OP_ENTERSUB);		\
		(void)POPMARK;                                        \
		return jump_o->op_next;				\
	    }							\
	    return NORMAL;					\
	}							\
    } STMT_END

/* This is no longer used anywhere in the core. You might wish to consider
   calling amagic_deref_call() directly, as it has a cleaner interface.  */
#define tryAMAGICunDEREF(meth)						\
    STMT_START {							\
	sv = amagic_deref_call(*sp, CAT2(meth,_amg));			\
	SPAGAIN;							\
    } STMT_END


#define opASSIGN (PL_op->op_flags & OPf_STACKED)

/*
=for apidoc mU||LVRET
True if this op will be the return value of an lvalue subroutine

=cut */
#define LVRET ((PL_op->op_private & OPpMAYBE_LVSUB) && is_lvalue_sub())

#define SvCANEXISTDELETE(sv) \
 (!SvRMAGICAL(sv)            \
  || !(mg = mg_find((const SV *) sv, PERL_MAGIC_tied))           \
  || (   (stash = SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(sv), mg)))) \
      && gv_fetchmethod_autoload(stash, "EXISTS", TRUE)          \
      && gv_fetchmethod_autoload(stash, "DELETE", TRUE)          \
     )                       \
  )

#ifdef PERL_CORE

/* These are just for Perl_tied_method(), which is not part of the public API.
   Use 0x04 rather than the next available bit, to help the compiler if the
   architecture can generate more efficient instructions.  */
#  define TIED_METHOD_MORTALIZE_NOT_NEEDED	0x04
#  define TIED_METHOD_ARGUMENTS_ON_STACK	0x08
#  define TIED_METHOD_SAY			0x10

/* Used in various places that need to dereference a glob or globref */
#  define MAYBE_DEREF_GV_flags(sv,phlags)                          \
    (                                                               \
	(void)(phlags & SV_GMAGIC && (SvGETMAGIC(sv),0)),            \
	isGV_with_GP(sv)                                              \
	  ? (GV *)(sv)                                                \
	  : SvROK(sv) && SvTYPE(SvRV(sv)) <= SVt_PVLV &&               \
	    (SvGETMAGIC(SvRV(sv)), isGV_with_GP(SvRV(sv)))              \
	     ? (GV *)SvRV(sv)                                            \
	     : NULL                                                       \
    )
#  define MAYBE_DEREF_GV(sv)      MAYBE_DEREF_GV_flags(sv,SV_GMAGIC)
#  define MAYBE_DEREF_GV_nomg(sv) MAYBE_DEREF_GV_flags(sv,0)

#  define FIND_RUNCV_padid_eq	1
#  define FIND_RUNCV_level_eq	2

#endif

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.15
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d17 1
a17 1
Stack pointer.  This is usually handled by C<xsubpp>.  See C<dSP> and
d21 1
a21 1
Stack marker variable for the XSUB.  See C<dMARK>.
d24 1
a24 1
Opening bracket for arguments on a callback.  See C<PUTBACK> and
d29 1
a29 1
the C<SP> macro.  See C<SP>.
d35 2
a36 2
See C<SP>.  (Available for backward source code compatibility with the
old (Perl 5.005) thread model.)
d39 2
a40 2
Declare a stack marker variable, C<mark>, for the XSUB.  See C<MARK> and
C<dORIGMARK>.
d43 1
a43 1
Saves the original stack mark for the XSUB.  See C<ORIGMARK>.
d46 1
a46 1
The original stack mark for the XSUB.  See C<dORIGMARK>.
d58 1
a58 6
#define PUSHMARK(p)	\
	STMT_START {					\
	    if (UNLIKELY(++PL_markstack_ptr == PL_markstack_max))	\
	    markstack_grow();				\
	    *PL_markstack_ptr = (I32)((p) - PL_stack_base);\
	} STMT_END
d60 50
a109 2
#define TOPMARK		(*PL_markstack_ptr)
#define POPMARK		(*PL_markstack_ptr--)
d137 1
a137 1
See C<PUSHMARK> and L<perlcall> for other uses.
d158 3
d164 3
d207 2
a208 2
Does not handle 'set' magic.  Does not use C<TARG>.  See also C<PUSHmortal>,
C<XPUSHs> and C<XPUSHmortal>.
d215 1
a215 1
C<mPUSHp> instead.  See also C<XPUSHp> and C<mXPUSHp>.
d221 2
a222 2
return lists from XSUB's - see C<mPUSHn> instead.  See also C<XPUSHn> and
C<mXPUSHn>.
d228 2
a229 2
return lists from XSUB's - see C<mPUSHi> instead.  See also C<XPUSHi> and
C<mXPUSHi>.
d235 2
a236 2
macros to return lists from XSUB's - see C<mPUSHu> instead.  See also
C<XPUSHu> and C<mXPUSHu>.
d240 1
a240 1
handle 'set' magic.  Does not use C<TARG>.  See also C<XPUSHmortal>,
d248 1
a248 1
C<mXPUSHp> instead.  See also C<PUSHp> and C<mPUSHp>.
d254 2
a255 1
from XSUB's - see C<mXPUSHn> instead.  See also C<PUSHn> and C<mPUSHn>.
d261 2
a262 1
from XSUB's - see C<mXPUSHi> instead.  See also C<PUSHi> and C<mPUSHi>.
d268 2
a269 2
return lists from XSUB's - see C<mXPUSHu> instead.  See also C<PUSHu> and
C<mPUSHu>.
d273 2
a274 1
for this element.  Does not use C<TARG>.  See also C<PUSHs> and C<mXPUSHs>.
d278 2
a279 1
element.  Does not use C<TARG>.  See also C<PUSHs>, C<XPUSHmortal> and C<XPUSHs>.
d284 1
a284 1
See also C<PUSHp>, C<mXPUSHp> and C<XPUSHp>.
d288 1
a288 1
Does not use C<TARG>.  See also C<PUSHn>, C<mXPUSHn> and C<XPUSHn>.
d292 1
a292 1
Does not use C<TARG>.  See also C<PUSHi>, C<mXPUSHi> and C<XPUSHi>.
d296 2
a297 1
element.  Does not use C<TARG>.  See also C<PUSHu>, C<mXPUSHu> and C<XPUSHu>.
d301 1
a301 1
the SV.  Does not use C<TARG>.  See also C<XPUSHs> and C<mPUSHs>.
d305 2
a306 1
Does not use C<TARG>.  See also C<XPUSHs>, C<PUSHmortal> and C<PUSHs>.
d310 2
a311 2
indicates the length of the string.  Does not use C<TARG>.  See also C<XPUSHp>,
C<mPUSHp> and C<PUSHp>.
d315 1
a315 1
Does not use C<TARG>.  See also C<XPUSHn>, C<mPUSHn> and C<PUSHn>.
d319 1
a319 1
Does not use C<TARG>.  See also C<XPUSHi>, C<mPUSHi> and C<PUSHi>.
d323 1
a323 1
Does not use C<TARG>.  See also C<XPUSHu>, C<mPUSHu> and C<PUSHu>.
d328 10
d339 4
a342 1
# define EXTEND(p,n)	(void)(sp = stack_grow(sp,p, (SSize_t)(n)))
d344 6
a349 5
# define MEXTEND(p,n)	STMT_START {					\
			    const int markoff = mark - PL_stack_base;	\
			    sp = stack_grow(sp,p,(SSize_t) (n));	\
			    mark = PL_stack_base + markoff;		\
			} STMT_END
a350 2
# define EXTEND(p,n)   (void)(UNLIKELY(PL_stack_max - p < (SSize_t)(n)) &&     \
			    (sp = stack_grow(sp,p, (SSize_t) (n))))
d352 23
d376 7
a382 5
# define MEXTEND(p,n)  STMT_START {if (UNLIKELY(PL_stack_max - p < (int)(n))) {\
                           const int markoff = mark - PL_stack_base;           \
                           sp = stack_grow(sp,p,(SSize_t) (n));                \
                           mark = PL_stack_base + markoff;                     \
                       } } STMT_END
d385 66
d454 3
a456 3
#define PUSHn(n)	STMT_START { sv_setnv(TARG, (NV)(n)); PUSHTARG; } STMT_END
#define PUSHi(i)	STMT_START { sv_setiv(TARG, (IV)(i)); PUSHTARG; } STMT_END
#define PUSHu(u)	STMT_START { sv_setuv(TARG, (UV)(u)); PUSHTARG; } STMT_END
d458 1
a458 1
#define XPUSHs(s)	(EXTEND(sp,1), *++sp = (s))
d461 3
a463 3
#define XPUSHn(n)	STMT_START { sv_setnv(TARG, (NV)(n)); XPUSHTARG; } STMT_END
#define XPUSHi(i)	STMT_START { sv_setiv(TARG, (IV)(i)); XPUSHTARG; } STMT_END
#define XPUSHu(u)	STMT_START { sv_setuv(TARG, (UV)(u)); XPUSHTARG; } STMT_END
d483 3
a485 3
#define SETn(n)		STMT_START { sv_setnv(TARG, (NV)(n)); SETTARG; } STMT_END
#define SETi(i)		STMT_START { sv_setiv(TARG, (IV)(i)); SETTARG; } STMT_END
#define SETu(u)		STMT_START { sv_setuv(TARG, (UV)(u)); SETTARG; } STMT_END
d528 1
d532 1
a532 2
    /* See OPpTARGET_MY: */
#define MAXARG		(PL_op->op_private & 15)
d544 4
a547 3
    STMT_START {							\
	if (UNLIKELY(PL_tmps_ix + (n) >= PL_tmps_max))			\
	    tmps_grow(n);						\
d557 1
d584 1
a584 1
        int gimme = GIMME_V;                                    \
d592 1
a592 1
                (void)POPs; /* XXX ??? */                       \
d617 1
a617 1
		PL_markstack_ptr--;				\
a633 9
#define SETsv(sv)	STMT_START {					\
		if (opASSIGN || (SvFLAGS(TARG) & SVs_PADMY))		\
		   { sv_setsv(TARG, (sv)); SETTARG; }			\
		else SETs(sv); } STMT_END

#define SETsvUN(sv)	STMT_START {					\
		if (SvFLAGS(TARG) & SVs_PADMY)		\
		   { sv_setsv(TARG, (sv)); SETTARG; }			\
		else SETs(sv); } STMT_END
a679 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.14
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d33 1
a33 1
Declare Just C<SP>. This is actually identical to C<dSP>, and declares
d60 1
a60 1
	    if (++PL_markstack_ptr == PL_markstack_max)	\
a135 4
#ifdef HAS_QUAD
#define POPq		((Quad_t)SvIVx(POPs))
#define POPuq		((Uquad_t)SvUVx(POPs))
#endif
a146 4
#ifdef HAS_QUAD
#define TOPq		((Quad_t)SvIV(TOPs))
#define TOPuq		((Uquad_t)SvUV(TOPs))
#endif
d151 2
a152 2
=for apidoc Am|void|EXTEND|SP|int nitems
Used to extend the argument stack for an XSUB's return values. Once
d273 11
a283 2
#define EXTEND(p,n)    (void)(UNLIKELY(PL_stack_max - p < (int)(n)) &&         \
			    (sp = stack_grow(sp,p, (int) (n))))
d286 1
a286 1
#define MEXTEND(p,n)   STMT_START {if (UNLIKELY(PL_stack_max - p < (int)(n))) {\
d288 1
a288 1
                           sp = stack_grow(sp,p,(int) (n));                    \
d291 1
a337 6
#ifdef HAS_QUAD
#define dTOPqv		Quad_t value = TOPu
#define dPOPqv		Quad_t value = POPu
#define dTOPuqv		Uquad_t value = TOPuq
#define dPOPuqv		Uquad_t value = POPuq
#endif
d403 1
a403 1
	if ( (SvFLAGS(TOPs) & (SVf_ROK|SVs_GMG)) \
d408 1
a408 1
	if ( ((SvFLAGS(TOPm1s)|SvFLAGS(TOPs)) & (SVf_ROK|SVs_GMG)) \
d425 1
a425 1
	if (SvAMAGIC(arg) &&					\
d428 2
a429 1
				|AMGf_unary))) {		\
d435 2
a436 2
                int i;                                          \
                I32 len;                                        \
d438 1
a438 1
                len = av_len((AV *)tmpsv) + 1;                  \
@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d70 1
a70 1
#define dMARK		register SV **mark = PL_stack_base + POPMARK
d100 1
a100 1
Pops a string off the stack. Deprecated. New code should use POPpx.
d103 2
a104 1
Pops a string off the stack.
d127 1
a127 1
#define POPp		(SvPVx(POPs, PL_na))		/* deprecated */
d144 1
a144 1
#define TOPp		(SvPV(TOPs, PL_na))		/* deprecated */
d281 2
a282 3
#define EXTEND(p,n)	STMT_START { if (PL_stack_max - p < (int)(n)) {		\
			    sp = stack_grow(sp,p, (int) (n));		\
			} } STMT_END
d285 5
a289 5
#define MEXTEND(p,n)	STMT_START {if (PL_stack_max - p < (int)(n)) {	\
			    const int markoff = mark - PL_stack_base;	\
			    sp = stack_grow(sp,p,(int) (n));		\
			    mark = PL_stack_base + markoff;		\
			} } STMT_END
d298 1
a298 1
#define XPUSHs(s)	STMT_START { EXTEND(sp,1); (*++sp = (s)); } STMT_END
d391 1
a391 1
	if (PL_tmps_ix + (n) >= PL_tmps_max)				\
d401 1
d423 1
a423 1
#define tryAMAGICunTARGET(meth, shift, jump)			\
a424 1
	dATARGET;						\
d427 2
a428 1
	SV *arg= sp[shift];					\
d431 2
a432 1
				 AMGf_noright | AMGf_unary))) {	\
d434 20
a453 5
	    sp += shift;					\
	    sv_setsv(TARG, tmpsv);				\
	    if (opASSIGN)					\
		sp--;						\
	    SETTARG;						\
d496 2
a497 2
  || ((mg = mg_find((const SV *) sv, PERL_MAGIC_tied))           \
      && (stash = SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(sv), mg)))) \
d517 1
a517 1
	  ? (GV *)sv                                                   \
d526 3
d535 1
a535 1
 * indent-tabs-mode: t
d538 1
a538 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@d89 1
a89 1
#define DIE Perl_die
d331 1
d348 3
a350 3
	(SvOK(sv) || SvGMAGICAL(sv) || !(PL_op->op_flags & OPf_STACKED))
#define dPOPXnnrl_ul(X)	\
    NV right = POPn;				\
d352 1
a352 5
    NV left = USE_LEFT(leftsv) ? SvNV(leftsv) : 0.0
#define dPOPXiirl_ul(X) \
    IV right = POPi;					\
    SV *leftsv = CAT2(X,s);				\
    IV left = USE_LEFT(leftsv) ? SvIV(leftsv) : 0
a355 1
#define dPOPPOPnnrl_ul	dPOPXnnrl_ul(POP)
a356 1
#define dPOPPOPiirl_ul	dPOPXiirl_ul(POP)
d360 2
a361 1
#define dPOPTOPnnrl_ul	dPOPXnnrl_ul(TOP)
d363 3
a365 1
#define dPOPTOPiirl_ul	dPOPXiirl_ul(TOP)
d399 3
d403 11
a413 66
#define tryAMAGICbinW_var(meth_enum,assign,set) STMT_START { \
	    SV* const left = *(sp-1); \
	    SV* const right = *(sp); \
	    if ((SvAMAGIC(left)||SvAMAGIC(right))) {\
		SV * const tmpsv = amagic_call(left, \
				   right, \
				   (meth_enum), \
				   (assign)? AMGf_assign: 0); \
		if (tmpsv) { \
		    SPAGAIN; \
		    (void)POPs; set(tmpsv); RETURN; } \
		} \
	} STMT_END

#define tryAMAGICbinW(meth,assign,set) \
    tryAMAGICbinW_var(CAT2(meth,_amg),assign,set)

#define tryAMAGICbin_var(meth_enum,assign) \
		tryAMAGICbinW_var(meth_enum,assign,SETsv)
#define tryAMAGICbin(meth,assign) \
		tryAMAGICbin_var(CAT2(meth,_amg),assign)

#define tryAMAGICbinSET(meth,assign) tryAMAGICbinW(meth,assign,SETs)

#define tryAMAGICbinSET_var(meth_enum,assign) \
    tryAMAGICbinW_var(meth_enum,assign,SETs)

#define AMG_CALLun_var(sv,meth_enum) amagic_call(sv,&PL_sv_undef,  \
					meth_enum,AMGf_noright | AMGf_unary)
#define AMG_CALLun(sv,meth) AMG_CALLun_var(sv,CAT2(meth,_amg))

#define AMG_CALLbinL(left,right,meth) \
            amagic_call(left,right,CAT2(meth,_amg),AMGf_noright)

#define tryAMAGICunW_var(meth_enum,set,shift,ret) STMT_START { \
	    SV* tmpsv; \
	    SV* arg= sp[shift]; \
          if(0) goto am_again;  /* shut up unused warning */ \
	  am_again: \
	    if ((SvAMAGIC(arg))&&\
		(tmpsv=AMG_CALLun_var(arg,(meth_enum)))) {\
	       SPAGAIN; if (shift) sp += shift; \
	       set(tmpsv); ret; } \
	} STMT_END
#define tryAMAGICunW(meth,set,shift,ret) \
	tryAMAGICunW_var(CAT2(meth,_amg),set,shift,ret)

#define FORCE_SETs(sv) STMT_START { sv_setsv(TARG, (sv)); SETTARG; } STMT_END

#define tryAMAGICun_var(meth_enum) tryAMAGICunW_var(meth_enum,SETsvUN,0,RETURN)
#define tryAMAGICun(meth)	tryAMAGICun_var(CAT2(meth,_amg))
#define tryAMAGICunSET(meth)	tryAMAGICunW(meth,SETs,0,RETURN)
#define tryAMAGICunTARGET(meth, shift)					\
	STMT_START { dSP; sp--; 	/* get TARGET from below PL_stack_sp */		\
	    { dTARGETSTACKED; 						\
		{ dSP; tryAMAGICunW(meth,FORCE_SETs,shift,RETURN);}}} STMT_END

#define setAGAIN(ref)	\
    STMT_START {					\
	sv = ref;					\
	if (!SvROK(ref))				\
	    Perl_croak(aTHX_ "Overloaded dereference did not return a reference");	\
	if (ref != arg && SvRV(ref) != SvRV(arg)) {	\
	    arg = ref;					\
	    goto am_again;				\
	}						\
d416 40
a455 32
#define tryAMAGICunDEREF(meth) tryAMAGICunW(meth,setAGAIN,0,(void)0)
#define tryAMAGICunDEREF_var(meth_enum) \
	tryAMAGICunW_var(meth_enum,setAGAIN,0,(void)0)

#define tryAMAGICftest(chr)				\
    STMT_START {					\
	assert(chr != '?');				\
	if ((PL_op->op_flags & OPf_KIDS)		\
		&& SvAMAGIC(TOPs)) {			\
	    const char tmpchr = (chr);			\
	    SV * const tmpsv = amagic_call(TOPs,	\
		newSVpvn_flags(&tmpchr, 1, SVs_TEMP),	\
		ftest_amg, AMGf_unary);			\
							\
	    if (tmpsv) {				\
		const OP *next = PL_op->op_next;	\
							\
		SPAGAIN;				\
							\
		if (next->op_type >= OP_FTRREAD &&	\
		    next->op_type <= OP_FTBINARY &&	\
		    next->op_private & OPpFT_STACKED	\
		) {					\
		    if (SvTRUE(tmpsv))			\
			/* leave the object alone */	\
			RETURN;				\
		}					\
							\
		SETs(tmpsv);				\
		RETURN;					\
	    }						\
	}						\
a469 11
/* newSVsv does not behave as advertised, so we copy missing
 * information by hand */

/* SV* ref causes confusion with the member variable
   changed SV* ref to SV* tmpRef */
#define RvDEEPCP(rv) STMT_START { SV* tmpRef=SvRV(rv); SV* rv_copy;     \
  if (SvREFCNT(tmpRef)>1 && (rv_copy = AMG_CALLun(rv,copy))) {          \
    SvRV_set(rv, rv_copy);		    \
    SvREFCNT_dec(tmpRef);                   \
  } } STMT_END

d485 25
@


1.11
log
@Merge in perl 5.10.1
@
text
@d89 1
a89 1
#define DIE return Perl_die
d474 31
d533 9
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d227 4
d233 1
a233 2
element.  Does not handle 'set' magic.  Does not use C<TARG>.  See also
C<PUSHs>, C<XPUSHmortal> and C<XPUSHs>.
d237 2
a238 2
The C<len> indicates the length of the string.  Handles 'set' magic.  Does
not use C<TARG>.  See also C<PUSHp>, C<mXPUSHp> and C<XPUSHp>.
d242 1
a242 2
Handles 'set' magic.  Does not use C<TARG>.  See also C<PUSHn>, C<mXPUSHn>
and C<XPUSHn>.
d246 1
a246 2
Handles 'set' magic.  Does not use C<TARG>.  See also C<PUSHi>, C<mXPUSHi>
and C<XPUSHi>.
d250 5
a254 2
element.  Handles 'set' magic.  Does not use C<TARG>.  See also C<PUSHu>,
C<mXPUSHu> and C<XPUSHu>.
d257 2
a258 3
Push a new mortal SV onto the stack, extending the stack if necessary.  Does
not handle 'set' magic.  Does not use C<TARG>.  See also C<XPUSHs>,
C<PUSHmortal> and C<PUSHs>.
d262 2
a263 2
indicates the length of the string.  Handles 'set' magic.  Does not use
C<TARG>.  See also C<XPUSHp>, C<mPUSHp> and C<PUSHp>.
d266 2
a267 3
Push a double onto the stack, extending the stack if necessary.  Handles
'set' magic.  Does not use C<TARG>.  See also C<XPUSHn>, C<mPUSHn> and
C<PUSHn>.
d270 2
a271 3
Push an integer onto the stack, extending the stack if necessary.  Handles
'set' magic.  Does not use C<TARG>.  See also C<XPUSHi>, C<mPUSHi> and
C<PUSHi>.
d275 1
a275 2
Handles 'set' magic.  Does not use C<TARG>.  See also C<XPUSHu>, C<mPUSHu>
and C<PUSHu>.
d306 1
d308 4
a311 4
#define mPUSHp(p,l)	sv_setpvn_mg(PUSHmortal, (p), (l))
#define mPUSHn(n)	sv_setnv_mg(PUSHmortal, (NV)(n))
#define mPUSHi(i)	sv_setiv_mg(PUSHmortal, (IV)(i))
#define mPUSHu(u)	sv_setuv_mg(PUSHmortal, (UV)(u))
d313 1
d315 4
a318 4
#define mXPUSHp(p,l)	STMT_START { EXTEND(sp,1); sv_setpvn_mg(PUSHmortal, (p), (l)); } STMT_END
#define mXPUSHn(n)	STMT_START { EXTEND(sp,1); sv_setnv_mg(PUSHmortal, (NV)(n)); } STMT_END
#define mXPUSHi(i)	STMT_START { EXTEND(sp,1); sv_setiv_mg(PUSHmortal, (IV)(i)); } STMT_END
#define mXPUSHu(u)	STMT_START { EXTEND(sp,1); sv_setuv_mg(PUSHmortal, (UV)(u)); } STMT_END
d490 3
a492 3
#define RvDEEPCP(rv) STMT_START { SV* tmpRef=SvRV(rv);      \
  if (SvREFCNT(tmpRef)>1) {                 \
    SvRV_set(rv, AMG_CALLun(rv,copy));	\
@


1.9
log
@merge in perl 5.8.8
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005 by Larry Wall and others
a10 8
#ifdef USE_5005THREADS
#define ARGS thr
#define dARGS struct perl_thread *thr;
#else
#define ARGS
#define dARGS
#endif /* USE_5005THREADS */

d62 1
a62 1
	    *PL_markstack_ptr = (p) - PL_stack_base;	\
d68 1
a68 1
#define dSP		register SV **sp = PL_stack_sp
d71 1
a71 1
#define dORIGMARK	const I32 origmark = mark - PL_stack_base
a89 3
#ifndef PERL_CORE
#  define DIE_NULL return DieNull
#endif
d121 3
a123 3
#define RETURN		return PUTBACK, NORMAL
#define RETURNOP(o)	return PUTBACK, o
#define RETURNX(x)	return x, PUTBACK, NORMAL
d400 5
a404 6
#define tryAMAGICbinW(meth,assign,set) STMT_START { \
          if (PL_amagic_generation) { \
	    SV* tmpsv; \
	    SV* const right= *(sp); SV* const left= *(sp-1);\
	    if ((SvAMAGIC(left)||SvAMAGIC(right))&&\
		(tmpsv=amagic_call(left, \
d406 6
a411 5
				   CAT2(meth,_amg), \
				   (assign)? AMGf_assign: 0))) {\
	       SPAGAIN;	\
	       (void)POPs; set(tmpsv); RETURN; } \
	  } \
d414 8
a421 1
#define tryAMAGICbin(meth,assign) tryAMAGICbinW(meth,assign,SETsv)
d424 7
a430 2
#define AMG_CALLun(sv,meth) amagic_call(sv,&PL_sv_undef,  \
					CAT2(meth,_amg),AMGf_noright | AMGf_unary)
d434 1
a434 2
#define tryAMAGICunW(meth,set,shift,ret) STMT_START { \
          if (PL_amagic_generation) { \
d440 1
a440 1
		(tmpsv=AMG_CALLun(arg,meth))) {\
a442 1
	  } \
d444 2
d449 2
a450 1
#define tryAMAGICun(meth)	tryAMAGICunW(meth,SETsvUN,0,RETURN)
d469 2
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d4 1
a4 1
 *    2000, 2001, by Larry Wall and others
d66 6
a71 3
#define PUSHMARK(p) if (++PL_markstack_ptr == PL_markstack_max)	\
			markstack_grow();			\
		    *PL_markstack_ptr = (p) - PL_stack_base
d79 1
a79 2
#define dORIGMARK	I32 origmark = mark - PL_stack_base
#define SETORIGMARK	origmark = mark - PL_stack_base
d83 1
a83 1
#define MSPAGAIN	sp = PL_stack_sp; mark = ORIGMARK
d98 3
d111 1
a111 2
Pops a string off the stack. Deprecated. New code should provide
a STRLEN n_a and use POPpx.
a114 1
Requires a variable STRLEN n_a in scope.
a117 1
Requires a variable STRLEN n_a in scope.
d138 3
a140 2
#define POPpx		(SvPVx(POPs, n_a))
#define POPpbytex	(SvPVbytex(POPs, n_a))
d155 1
a155 1
#define TOPpx		(SvPV(TOPs, n_a))
d296 2
a297 2
#define MEXTEND(p,n)	STMT_START {if (PL_stack_max - p < (int)(n)) {		\
			    int markoff = mark - PL_stack_base;		\
d414 1
a414 1
	    SV* right= *(sp); SV* left= *(sp-1);\
d451 1
a451 1
	{ dSP; sp--; 	/* get TARGET from below PL_stack_sp */		\
d453 1
a453 1
		{ dSP; tryAMAGICunW(meth,FORCE_SETs,shift,RETURN);}}}
d455 10
a464 7
#define setAGAIN(ref) sv = ref;							\
  if (!SvROK(ref))								\
      Perl_croak(aTHX_ "Overloaded dereference did not return a reference");	\
  if (ref != arg && SvRV(ref) != SvRV(arg)) {					\
      arg = ref;								\
      goto am_again;								\
  }
d486 1
a486 1
    SvRV(rv)=AMG_CALLun(rv,copy);	\
d496 10
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d31 1
a31 1
=for apidoc Ams||PUSHMARK
d173 2
a174 1
Does not handle 'set' magic.  See C<XPUSHs>.
d178 4
a181 2
The C<len> indicates the length of the string.  Handles 'set' magic.  See
C<XPUSHp>.
d185 4
a188 1
Handles 'set' magic.  See C<XPUSHn>.
d192 4
a195 1
Handles 'set' magic.  See C<XPUSHi>.
d199 4
a202 1
element.  See C<XPUSHu>.
d206 2
a207 1
handle 'set' magic.  See C<PUSHs>.
d211 4
a214 2
indicates the length of the string.  Handles 'set' magic.  See
C<PUSHp>.
d218 3
a220 1
'set' magic.  See C<PUSHn>.
d224 3
a226 1
'set' magic. See C<PUSHi>.
d230 54
a283 1
See C<PUSHu>.
d313 12
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d216 1
a216 1
#define EXTEND(p,n)	STMT_START { if (PL_stack_max - p < (n)) {		\
d221 1
a221 1
#define MEXTEND(p,n)	STMT_START {if (PL_stack_max - p < (n)) {		\
d396 1
a397 1
    SvRV(rv)=AMG_CALLun(rv,copy);        \
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d10 1
a10 1
#ifdef USE_THREADS
d16 1
a16 1
#endif /* USE_THREADS */
d21 2
d38 7
d58 1
a58 2
=cut
*/
d105 4
d110 5
d136 1
d148 2
d349 1
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d52 1
d64 2
a65 2
#define djSP		register SV **sp = PL_stack_sp
#define dSP		dTHR; djSP
d147 1
a147 1
used, guarrantees that there is room for at least C<nitems> to be pushed
d151 1
a151 1
Push an SV onto the stack.  The stack must have room for this element. 
d189 1
a189 1
Push an unsigned integer onto the stack, extending the stack if necessary. 
d346 2
a347 2
#define setAGAIN(ref) sv = arg = ref;					\
  if (!SvROK(ref))							\
d349 4
a352 1
  goto am_again;
d377 7
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d17 34
a50 5
#ifdef PERL_OBJECT
#define PP(s) OP * CPerlObj::s(ARGSproto)
#else
#define PP(s) OP * s(ARGSproto)
#endif
d85 24
a108 1
#define DIE return die
d122 5
d135 5
d142 52
d208 1
a208 1
#define PUSHn(n)	STMT_START { sv_setnv(TARG, (double)(n)); PUSHTARG; } STMT_END
d215 1
a215 1
#define XPUSHn(n)	STMT_START { sv_setnv(TARG, (double)(n)); XPUSHTARG; } STMT_END
d218 1
d223 1
a223 1
#define SETn(n)		STMT_START { sv_setnv(TARG, (double)(n)); SETTARG; } STMT_END
d229 2
a230 2
#define dTOPnv		double value = TOPn
#define dPOPnv		double value = POPn
d235 6
d243 1
a243 1
#define dPOPXnnrl(X)	double right = POPn; double left = CAT2(X,n)
d249 1
a249 1
    double right = POPn;				\
d251 1
a251 1
    double left = USE_LEFT(leftsv) ? SvNV(leftsv) : 0.0
d278 3
a280 1
#define MAXARG		PL_op->op_private
d284 1
a284 1
	AvFILLp(f) = sp - PL_stack_base;					\
d286 1
a286 1
	PL_stack_max = PL_stack_base + AvMAX(t);				\
d288 1
a288 1
	PL_curstack = t;							\
d292 4
a295 6
	STMT_START { \
	    if (PL_tmps_ix + (n) >= PL_tmps_max) \
		Renew(PL_tmps_stack, PL_tmps_max = PL_tmps_ix + (n) + 1, SV*); \
	} STMT_END

#ifdef OVERLOAD
d324 1
a324 1
#define tryAMAGICunW(meth,set) STMT_START { \
d327 2
a328 1
	    SV* arg= *(sp); \
d331 2
a332 2
	       SPAGAIN;	\
	       set(tmpsv); RETURN; } \
d336 15
a350 2
#define tryAMAGICun	tryAMAGICunSET
#define tryAMAGICunSET(meth) tryAMAGICunW(meth,SETs)
d354 7
a360 1
		if (opASSIGN) { sv_setsv(TARG, (sv)); SETTARG; }	\
a372 8
#else

#define tryAMAGICbin(a,b)
#define tryAMAGICbinSET(a,b)
#define tryAMAGICun(a)
#define tryAMAGICunSET(a)

#endif /* OVERLOAD */
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d10 4
a14 1
#define ARGSproto void
d16 6
a21 1
#define PP(s) OP* s(ARGS) dARGS
d27 1
a27 1
#define PUSHMARK(p) if (++markstack_ptr == markstack_max)	\
d29 1
a29 1
		    *markstack_ptr = (p) - stack_base
d31 2
a32 2
#define TOPMARK		(*markstack_ptr)
#define POPMARK		(*markstack_ptr--)
d34 6
a39 5
#define dSP		register SV **sp = stack_sp
#define dMARK		register SV **mark = stack_base + POPMARK
#define dORIGMARK	I32 origmark = mark - stack_base
#define SETORIGMARK	origmark = mark - stack_base
#define ORIGMARK	(stack_base + origmark)
d41 2
a42 2
#define SPAGAIN		sp = stack_sp
#define MSPAGAIN	sp = stack_sp; mark = ORIGMARK
d44 1
a44 1
#define GETTARGETSTACKED targ = (op->op_flags & OPf_STACKED ? POPs : PAD_SV(op->op_targ))
d47 1
a47 1
#define GETTARGET targ = PAD_SV(op->op_targ)
d50 1
a50 1
#define GETATARGET targ = (op->op_flags & OPf_STACKED ? sp[-1] : PAD_SV(op->op_targ))
d55 1
a55 1
#define NORMAL op->op_next
d58 1
a58 1
#define PUTBACK		stack_sp = sp
d64 2
a65 1
#define POPp		(SvPVx(POPs, na))
d72 2
a73 1
#define TOPp		(SvPV(TOPs, na))
d80 1
a80 1
#define EXTEND(p,n)	STMT_START { if (stack_max - p < (n)) {		\
d85 2
a86 2
#define MEXTEND(p,n)	STMT_START {if (stack_max - p < (n)) {		\
			    int markoff = mark - stack_base;		\
d88 1
a88 1
			    mark = stack_base + markoff;		\
d126 1
a126 1
	(SvOK(sv) || SvGMAGICAL(sv) || !(op->op_flags & OPf_STACKED))
d148 19
a166 16
#define RETPUSHYES	RETURNX(PUSHs(&sv_yes))
#define RETPUSHNO	RETURNX(PUSHs(&sv_no))
#define RETPUSHUNDEF	RETURNX(PUSHs(&sv_undef))

#define RETSETYES	RETURNX(SETs(&sv_yes))
#define RETSETNO	RETURNX(SETs(&sv_no))
#define RETSETUNDEF	RETURNX(SETs(&sv_undef))

#define ARGTARG		op->op_targ
#define MAXARG		op->op_private

#define SWITCHSTACK(f,t)	AvFILL(f) = sp - stack_base;		\
				stack_base = AvARRAY(t);		\
				stack_max = stack_base + AvMAX(t);	\
				sp = stack_sp = stack_base + AvFILL(t);	\
				curstack = t;
d170 2
a171 2
	    if (tmps_ix + (n) >= tmps_max) \
		Renew(tmps_stack, tmps_max = tmps_ix + (n) + 1, SV*); \
d182 1
a182 1
          if (amagic_generation) { \
d198 1
a198 1
#define AMG_CALLun(sv,meth) amagic_call(sv,&sv_undef,  \
d204 1
a204 1
          if (amagic_generation) { \
d217 1
a217 1
#define opASSIGN (op->op_flags & OPf_STACKED)
d225 5
a229 4

#define RvDEEPCP(rv) STMT_START { SV* ref=SvRV(rv);      \
  if (SvREFCNT(ref)>1) {                 \
    SvREFCNT_dec(ref);                   \
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d58 1
d65 1
d69 2
a70 2
#define EXTEND(p,n)	STMT_START { if (stack_max - p < (n)) {		  	    \
			    sp = stack_grow(sp,p, (int) (n));		    \
d74 4
a77 4
#define MEXTEND(p,n)	STMT_START {if (stack_max - p < (n)) {			    \
			    int markoff = mark - stack_base;		    \
			    sp = stack_grow(sp,p,(int) (n));		    \
			    mark = stack_base + markoff;		    \
d85 1
d92 1
d99 1
a99 4

#ifdef OVERLOAD
#define SETsv(sv)	STMT_START { sv_setsv(TARG, (sv)); SETTARG; } STMT_END
#endif /* OVERLOAD */
d107 2
d110 26
a135 7
#define dPOPPOPssrl	SV *right = POPs; SV *left = POPs
#define dPOPPOPnnrl	double right = POPn; double left = POPn
#define dPOPPOPiirl	IV right = POPi; IV left = POPi

#define dPOPTOPssrl	SV *right = POPs; SV *left = TOPs
#define dPOPTOPnnrl	double right = POPn; double left = TOPn
#define dPOPTOPiirl	IV right = POPi; IV left = TOPi
d152 7
a158 1
				stack = t;
d200 1
a200 1
#define tryAMAGICun(meth) tryAMAGICunW(meth,SETsv)
d204 3
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
a9 4
#ifdef USE_THREADS
#define ARGS thr
#define dARGS struct perl_thread *thr;
#else
d11 1
d13 1
a13 6
#endif /* USE_THREADS */
#ifdef PERL_OBJECT
#define PP(s) OP * CPerlObj::s(ARGSproto)
#else
#define PP(s) OP * s(ARGSproto)
#endif
d19 1
a19 1
#define PUSHMARK(p) if (++PL_markstack_ptr == PL_markstack_max)	\
d21 1
a21 1
		    *PL_markstack_ptr = (p) - PL_stack_base
d23 2
a24 2
#define TOPMARK		(*PL_markstack_ptr)
#define POPMARK		(*PL_markstack_ptr--)
d26 5
a30 6
#define djSP		register SV **sp = PL_stack_sp
#define dSP		dTHR; djSP
#define dMARK		register SV **mark = PL_stack_base + POPMARK
#define dORIGMARK	I32 origmark = mark - PL_stack_base
#define SETORIGMARK	origmark = mark - PL_stack_base
#define ORIGMARK	(PL_stack_base + origmark)
d32 2
a33 2
#define SPAGAIN		sp = PL_stack_sp
#define MSPAGAIN	sp = PL_stack_sp; mark = ORIGMARK
d35 1
a35 1
#define GETTARGETSTACKED targ = (PL_op->op_flags & OPf_STACKED ? POPs : PAD_SV(PL_op->op_targ))
d38 1
a38 1
#define GETTARGET targ = PAD_SV(PL_op->op_targ)
d41 1
a41 1
#define GETATARGET targ = (PL_op->op_flags & OPf_STACKED ? sp[-1] : PAD_SV(PL_op->op_targ))
d46 1
a46 1
#define NORMAL PL_op->op_next
d49 1
a49 1
#define PUTBACK		PL_stack_sp = sp
d55 1
a55 2
#define POPp		(SvPVx(POPs, PL_na))		/* deprecated */
#define POPpx		(SvPVx(POPs, n_a))
a57 1
#define POPu		((UV)SvUVx(POPs))
d61 1
a61 2
#define TOPp		(SvPV(TOPs, PL_na))		/* deprecated */
#define TOPpx		(SvPV(TOPs, n_a))
a63 1
#define TOPu		((UV)SvUV(TOPs))
d67 2
a68 2
#define EXTEND(p,n)	STMT_START { if (PL_stack_max - p < (n)) {		\
			    sp = stack_grow(sp,p, (int) (n));		\
d72 4
a75 4
#define MEXTEND(p,n)	STMT_START {if (PL_stack_max - p < (n)) {		\
			    int markoff = mark - PL_stack_base;		\
			    sp = stack_grow(sp,p,(int) (n));		\
			    mark = PL_stack_base + markoff;		\
a82 1
#define PUSHu(u)	STMT_START { sv_setuv(TARG, (UV)(u)); PUSHTARG; } STMT_END
a88 1
#define XPUSHu(u)	STMT_START { sv_setuv(TARG, (UV)(u)); XPUSHTARG; } STMT_END
d95 4
a98 1
#define SETu(u)		STMT_START { sv_setuv(TARG, (UV)(u)); SETTARG; } STMT_END
a105 2
#define dTOPuv		UV value = TOPu
#define dPOPuv		UV value = POPu
d107 24
a130 52
#define dPOPXssrl(X)	SV *right = POPs; SV *left = CAT2(X,s)
#define dPOPXnnrl(X)	double right = POPn; double left = CAT2(X,n)
#define dPOPXiirl(X)	IV right = POPi; IV left = CAT2(X,i)

#define USE_LEFT(sv) \
	(SvOK(sv) || SvGMAGICAL(sv) || !(PL_op->op_flags & OPf_STACKED))
#define dPOPXnnrl_ul(X)	\
    double right = POPn;				\
    SV *leftsv = CAT2(X,s);				\
    double left = USE_LEFT(leftsv) ? SvNV(leftsv) : 0.0
#define dPOPXiirl_ul(X) \
    IV right = POPi;					\
    SV *leftsv = CAT2(X,s);				\
    IV left = USE_LEFT(leftsv) ? SvIV(leftsv) : 0

#define dPOPPOPssrl	dPOPXssrl(POP)
#define dPOPPOPnnrl	dPOPXnnrl(POP)
#define dPOPPOPnnrl_ul	dPOPXnnrl_ul(POP)
#define dPOPPOPiirl	dPOPXiirl(POP)
#define dPOPPOPiirl_ul	dPOPXiirl_ul(POP)

#define dPOPTOPssrl	dPOPXssrl(TOP)
#define dPOPTOPnnrl	dPOPXnnrl(TOP)
#define dPOPTOPnnrl_ul	dPOPXnnrl_ul(TOP)
#define dPOPTOPiirl	dPOPXiirl(TOP)
#define dPOPTOPiirl_ul	dPOPXiirl_ul(TOP)

#define RETPUSHYES	RETURNX(PUSHs(&PL_sv_yes))
#define RETPUSHNO	RETURNX(PUSHs(&PL_sv_no))
#define RETPUSHUNDEF	RETURNX(PUSHs(&PL_sv_undef))

#define RETSETYES	RETURNX(SETs(&PL_sv_yes))
#define RETSETNO	RETURNX(SETs(&PL_sv_no))
#define RETSETUNDEF	RETURNX(SETs(&PL_sv_undef))

#define ARGTARG		PL_op->op_targ
#define MAXARG		PL_op->op_private

#define SWITCHSTACK(f,t) \
    STMT_START {							\
	AvFILLp(f) = sp - PL_stack_base;					\
	PL_stack_base = AvARRAY(t);					\
	PL_stack_max = PL_stack_base + AvMAX(t);				\
	sp = PL_stack_sp = PL_stack_base + AvFILLp(t);			\
	PL_curstack = t;							\
    } STMT_END

#define EXTEND_MORTAL(n) \
	STMT_START { \
	    if (PL_tmps_ix + (n) >= PL_tmps_max) \
		Renew(PL_tmps_stack, PL_tmps_max = PL_tmps_ix + (n) + 1, SV*); \
	} STMT_END
d140 1
a140 1
          if (PL_amagic_generation) { \
d156 1
a156 1
#define AMG_CALLun(sv,meth) amagic_call(sv,&PL_sv_undef,  \
d162 1
a162 1
          if (PL_amagic_generation) { \
d172 1
a172 1
#define tryAMAGICun	tryAMAGICunSET
d175 1
a175 4
#define opASSIGN (PL_op->op_flags & OPf_STACKED)
#define SETsv(sv)	STMT_START {					\
		if (opASSIGN) { sv_setsv(TARG, (sv)); SETTARG; }	\
		else SETs(sv); } STMT_END
d180 4
a183 5
/* SV* ref causes confusion with the member variable
   changed SV* ref to SV* tmpRef */
#define RvDEEPCP(rv) STMT_START { SV* tmpRef=SvRV(rv);      \
  if (SvREFCNT(tmpRef)>1) {                 \
    SvREFCNT_dec(tmpRef);                   \
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d17 5
a21 34

#define PP(s) OP * Perl_##s(pTHX)

/*
=for apidoc AmU||SP
Stack pointer.  This is usually handled by C<xsubpp>.  See C<dSP> and
C<SPAGAIN>.

=for apidoc AmU||MARK
Stack marker variable for the XSUB.  See C<dMARK>.

=for apidoc Ams||PUSHMARK
Opening bracket for arguments on a callback.  See C<PUTBACK> and
L<perlcall>.

=for apidoc Ams||dSP
Declares a local copy of perl's stack pointer for the XSUB, available via
the C<SP> macro.  See C<SP>.

=for apidoc Ams||dMARK
Declare a stack marker variable, C<mark>, for the XSUB.  See C<MARK> and
C<dORIGMARK>.

=for apidoc Ams||dORIGMARK
Saves the original stack mark for the XSUB.  See C<ORIGMARK>.

=for apidoc AmU||ORIGMARK
The original stack mark for the XSUB.  See C<dORIGMARK>.

=for apidoc Ams||SPAGAIN
Refetch the stack pointer.  Used after a callback.  See L<perlcall>.

=cut
*/
d56 1
a56 24
#define DIE return Perl_die

/*
=for apidoc Ams||PUTBACK
Closing bracket for XSUB arguments.  This is usually handled by C<xsubpp>.
See C<PUSHMARK> and L<perlcall> for other uses.

=for apidoc Amn|SV*|POPs
Pops an SV off the stack.

=for apidoc Amn|char*|POPp
Pops a string off the stack.

=for apidoc Amn|NV|POPn
Pops a double off the stack.

=for apidoc Amn|IV|POPi
Pops an integer off the stack.

=for apidoc Amn|long|POPl
Pops a long off the stack.

=cut
*/
a69 5
#define POPul		((unsigned long)SvIVx(POPs))
#ifdef HAS_QUAD
#define POPq		((Quad_t)SvIVx(POPs))
#define POPuq		((Uquad_t)SvUVx(POPs))
#endif
a77 5
#define TOPul		((unsigned long)SvUV(TOPs))
#ifdef HAS_QUAD
#define TOPq		((Quad_t)SvIV(TOPs))
#define TOPuq		((Uquad_t)SvUV(TOPs))
#endif
a79 52

/*
=for apidoc Am|void|EXTEND|SP|int nitems
Used to extend the argument stack for an XSUB's return values. Once
used, guarrantees that there is room for at least C<nitems> to be pushed
onto the stack.

=for apidoc Am|void|PUSHs|SV* sv
Push an SV onto the stack.  The stack must have room for this element. 
Does not handle 'set' magic.  See C<XPUSHs>.

=for apidoc Am|void|PUSHp|char* str|STRLEN len
Push a string onto the stack.  The stack must have room for this element.
The C<len> indicates the length of the string.  Handles 'set' magic.  See
C<XPUSHp>.

=for apidoc Am|void|PUSHn|NV nv
Push a double onto the stack.  The stack must have room for this element.
Handles 'set' magic.  See C<XPUSHn>.

=for apidoc Am|void|PUSHi|IV iv
Push an integer onto the stack.  The stack must have room for this element.
Handles 'set' magic.  See C<XPUSHi>.

=for apidoc Am|void|PUSHu|UV uv
Push an unsigned integer onto the stack.  The stack must have room for this
element.  See C<XPUSHu>.

=for apidoc Am|void|XPUSHs|SV* sv
Push an SV onto the stack, extending the stack if necessary.  Does not
handle 'set' magic.  See C<PUSHs>.

=for apidoc Am|void|XPUSHp|char* str|STRLEN len
Push a string onto the stack, extending the stack if necessary.  The C<len>
indicates the length of the string.  Handles 'set' magic.  See
C<PUSHp>.

=for apidoc Am|void|XPUSHn|NV nv
Push a double onto the stack, extending the stack if necessary.  Handles
'set' magic.  See C<PUSHn>.

=for apidoc Am|void|XPUSHi|IV iv
Push an integer onto the stack, extending the stack if necessary.  Handles
'set' magic. See C<PUSHi>.

=for apidoc Am|void|XPUSHu|UV uv
Push an unsigned integer onto the stack, extending the stack if necessary. 
See C<PUSHu>.

=cut
*/

d94 1
a94 1
#define PUSHn(n)	STMT_START { sv_setnv(TARG, (NV)(n)); PUSHTARG; } STMT_END
d101 1
a101 1
#define XPUSHn(n)	STMT_START { sv_setnv(TARG, (NV)(n)); XPUSHTARG; } STMT_END
a103 1
#define XPUSHundef	STMT_START { SvOK_off(TARG); XPUSHs(TARG); } STMT_END
d108 1
a108 1
#define SETn(n)		STMT_START { sv_setnv(TARG, (NV)(n)); SETTARG; } STMT_END
d114 2
a115 2
#define dTOPnv		NV value = TOPn
#define dPOPnv		NV value = POPn
a119 6
#ifdef HAS_QUAD
#define dTOPqv		Quad_t value = TOPu
#define dPOPqv		Quad_t value = POPu
#define dTOPuqv		Uquad_t value = TOPuq
#define dPOPuqv		Uquad_t value = POPuq
#endif
d122 1
a122 1
#define dPOPXnnrl(X)	NV right = POPn; NV left = CAT2(X,n)
d128 1
a128 1
    NV right = POPn;				\
d130 1
a130 1
    NV left = USE_LEFT(leftsv) ? SvNV(leftsv) : 0.0
d157 1
a157 3

    /* See OPpTARGET_MY: */
#define MAXARG		(PL_op->op_private & 15)
d161 1
a161 1
	AvFILLp(f) = sp - PL_stack_base;				\
d163 1
a163 1
	PL_stack_max = PL_stack_base + AvMAX(t);			\
d165 1
a165 1
	PL_curstack = t;						\
d169 6
a174 4
    STMT_START {							\
	if (PL_tmps_ix + (n) >= PL_tmps_max)				\
	    tmps_grow(n);						\
    } STMT_END
d203 1
a203 1
#define tryAMAGICunW(meth,set,shift,ret) STMT_START { \
d206 1
a206 2
	    SV* arg= sp[shift]; \
	  am_again: \
d209 2
a210 2
	       SPAGAIN; if (shift) sp += shift; \
	       set(tmpsv); ret; } \
d214 2
a215 15
#define FORCE_SETs(sv) STMT_START { sv_setsv(TARG, (sv)); SETTARG; } STMT_END

#define tryAMAGICun(meth)	tryAMAGICunW(meth,SETsvUN,0,RETURN)
#define tryAMAGICunSET(meth)	tryAMAGICunW(meth,SETs,0,RETURN)
#define tryAMAGICunTARGET(meth, shift)					\
	{ dSP; sp--; 	/* get TARGET from below PL_stack_sp */		\
	    { dTARGETSTACKED; 						\
		{ dSP; tryAMAGICunW(meth,FORCE_SETs,shift,RETURN);}}}

#define setAGAIN(ref) sv = arg = ref;					\
  if (!SvROK(ref))							\
      Perl_croak(aTHX_ "Overloaded dereference did not return a reference");	\
  goto am_again;

#define tryAMAGICunDEREF(meth) tryAMAGICunW(meth,setAGAIN,0,(void)0)
d219 1
a219 7
		if (opASSIGN || (SvFLAGS(TARG) & SVs_PADMY))		\
		   { sv_setsv(TARG, (sv)); SETTARG; }			\
		else SETs(sv); } STMT_END

#define SETsvUN(sv)	STMT_START {					\
		if (SvFLAGS(TARG) & SVs_PADMY)		\
		   { sv_setsv(TARG, (sv)); SETTARG; }			\
d232 8
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
a51 1
#undef SP /* Solaris 2.7 i386 has this in /usr/include/sys/reg.h */
d63 2
a64 2
#define dSP		register SV **sp = PL_stack_sp
#define djSP		dSP
d146 1
a146 1
used, guarantees that there is room for at least C<nitems> to be pushed
d150 1
a150 1
Push an SV onto the stack.  The stack must have room for this element.
d188 1
a188 1
Push an unsigned integer onto the stack, extending the stack if necessary.
d345 2
a346 2
#define setAGAIN(ref) sv = ref;							\
  if (!SvROK(ref))								\
d348 1
a348 4
  if (ref != arg && SvRV(ref) != SvRV(arg)) {					\
      arg = ref;								\
      goto am_again;								\
  }
a372 7

/*
=for apidoc mU||LVRET
True if this op will be the return value of an lvalue subroutine

=cut */
#define LVRET ((PL_op->op_private & OPpMAYBE_LVSUB) && is_lvalue_sub())
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
d10 1
a10 1
#ifdef USE_5005THREADS
d16 1
a16 1
#endif /* USE_5005THREADS */
a20 2
=head1 Stack Manipulation Macros

a35 7
=for apidoc ms||djSP

Declare Just C<SP>. This is actually identical to C<dSP>, and declares
a local copy of perl's stack pointer, available via the C<SP> macro.
See C<SP>.  (Available for backward source code compatibility with the
old (Perl 5.005) thread model.)

d49 2
a50 1
=cut */
a96 4
Pops a string off the stack. Deprecated. New code should provide
a STRLEN n_a and use POPpx.

=for apidoc Amn|char*|POPpx
a97 5
Requires a variable STRLEN n_a in scope.

=for apidoc Amn|char*|POPpbytex
Pops a string off the stack which must consist of bytes i.e. characters < 256.
Requires a variable STRLEN n_a in scope.
a118 1
#define POPpbytex	(SvPVbytex(POPs, n_a))
a129 2
#define TOPm1s		(*(sp-1))
#define TOPp1s		(*(sp+1))
a328 1
          if(0) goto am_again;  /* shut up unused warning */ \
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
 *    2000, 2001, by Larry Wall and others
d215 1
a215 1
#define EXTEND(p,n)	STMT_START { if (PL_stack_max - p < (int)(n)) {		\
d220 1
a220 1
#define MEXTEND(p,n)	STMT_START {if (PL_stack_max - p < (int)(n)) {		\
a394 1
    SvRV(rv)=AMG_CALLun(rv,copy);	\
d396 1
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d31 1
a31 1
=for apidoc Am|void|PUSHMARK|SP
d173 1
a173 2
Does not handle 'set' magic.  Does not use C<TARG>.  See also C<PUSHmortal>,
C<XPUSHs> and C<XPUSHmortal>.
d177 2
a178 4
The C<len> indicates the length of the string.  Handles 'set' magic.  Uses
C<TARG>, so C<dTARGET> or C<dXSTARG> should be called to declare it.  Do not
call multiple C<TARG>-oriented macros to return lists from XSUB's - see
C<mPUSHp> instead.  See also C<XPUSHp> and C<mXPUSHp>.
d182 1
a182 4
Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be
called to declare it.  Do not call multiple C<TARG>-oriented macros to
return lists from XSUB's - see C<mPUSHn> instead.  See also C<XPUSHn> and
C<mXPUSHn>.
d186 1
a186 4
Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be
called to declare it.  Do not call multiple C<TARG>-oriented macros to 
return lists from XSUB's - see C<mPUSHi> instead.  See also C<XPUSHi> and
C<mXPUSHi>.
d190 1
a190 4
element.  Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG>
should be called to declare it.  Do not call multiple C<TARG>-oriented
macros to return lists from XSUB's - see C<mPUSHu> instead.  See also
C<XPUSHu> and C<mXPUSHu>.
d194 1
a194 2
handle 'set' magic.  Does not use C<TARG>.  See also C<XPUSHmortal>,
C<PUSHs> and C<PUSHmortal>.
d198 2
a199 4
indicates the length of the string.  Handles 'set' magic.  Uses C<TARG>, so
C<dTARGET> or C<dXSTARG> should be called to declare it.  Do not call
multiple C<TARG>-oriented macros to return lists from XSUB's - see
C<mXPUSHp> instead.  See also C<PUSHp> and C<mPUSHp>.
d203 1
a203 3
'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be called to
declare it.  Do not call multiple C<TARG>-oriented macros to return lists
from XSUB's - see C<mXPUSHn> instead.  See also C<PUSHn> and C<mPUSHn>.
d207 1
a207 3
'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be called to
declare it.  Do not call multiple C<TARG>-oriented macros to return lists
from XSUB's - see C<mXPUSHi> instead.  See also C<PUSHi> and C<mPUSHi>.
d211 1
a211 54
Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be
called to declare it.  Do not call multiple C<TARG>-oriented macros to
return lists from XSUB's - see C<mXPUSHu> instead.  See also C<PUSHu> and
C<mPUSHu>.

=for apidoc Am|void|PUSHmortal
Push a new mortal SV onto the stack.  The stack must have room for this
element.  Does not handle 'set' magic.  Does not use C<TARG>.  See also
C<PUSHs>, C<XPUSHmortal> and C<XPUSHs>.

=for apidoc Am|void|mPUSHp|char* str|STRLEN len
Push a string onto the stack.  The stack must have room for this element.
The C<len> indicates the length of the string.  Handles 'set' magic.  Does
not use C<TARG>.  See also C<PUSHp>, C<mXPUSHp> and C<XPUSHp>.

=for apidoc Am|void|mPUSHn|NV nv
Push a double onto the stack.  The stack must have room for this element.
Handles 'set' magic.  Does not use C<TARG>.  See also C<PUSHn>, C<mXPUSHn>
and C<XPUSHn>.

=for apidoc Am|void|mPUSHi|IV iv
Push an integer onto the stack.  The stack must have room for this element.
Handles 'set' magic.  Does not use C<TARG>.  See also C<PUSHi>, C<mXPUSHi>
and C<XPUSHi>.

=for apidoc Am|void|mPUSHu|UV uv
Push an unsigned integer onto the stack.  The stack must have room for this
element.  Handles 'set' magic.  Does not use C<TARG>.  See also C<PUSHu>,
C<mXPUSHu> and C<XPUSHu>.

=for apidoc Am|void|XPUSHmortal
Push a new mortal SV onto the stack, extending the stack if necessary.  Does
not handle 'set' magic.  Does not use C<TARG>.  See also C<XPUSHs>,
C<PUSHmortal> and C<PUSHs>.

=for apidoc Am|void|mXPUSHp|char* str|STRLEN len
Push a string onto the stack, extending the stack if necessary.  The C<len>
indicates the length of the string.  Handles 'set' magic.  Does not use
C<TARG>.  See also C<XPUSHp>, C<mPUSHp> and C<PUSHp>.

=for apidoc Am|void|mXPUSHn|NV nv
Push a double onto the stack, extending the stack if necessary.  Handles
'set' magic.  Does not use C<TARG>.  See also C<XPUSHn>, C<mPUSHn> and
C<PUSHn>.

=for apidoc Am|void|mXPUSHi|IV iv
Push an integer onto the stack, extending the stack if necessary.  Handles
'set' magic.  Does not use C<TARG>.  See also C<XPUSHi>, C<mPUSHi> and
C<PUSHi>.

=for apidoc Am|void|mXPUSHu|UV uv
Push an unsigned integer onto the stack, extending the stack if necessary.
Handles 'set' magic.  Does not use C<TARG>.  See also C<XPUSHu>, C<mPUSHu>
and C<PUSHu>.
a240 12

#define PUSHmortal	PUSHs(sv_newmortal())
#define mPUSHp(p,l)	sv_setpvn_mg(PUSHmortal, (p), (l))
#define mPUSHn(n)	sv_setnv_mg(PUSHmortal, (NV)(n))
#define mPUSHi(i)	sv_setiv_mg(PUSHmortal, (IV)(i))
#define mPUSHu(u)	sv_setuv_mg(PUSHmortal, (UV)(u))

#define XPUSHmortal	XPUSHs(sv_newmortal())
#define mXPUSHp(p,l)	STMT_START { EXTEND(sp,1); sv_setpvn_mg(PUSHmortal, (p), (l)); } STMT_END
#define mXPUSHn(n)	STMT_START { EXTEND(sp,1); sv_setnv_mg(PUSHmortal, (NV)(n)); } STMT_END
#define mXPUSHi(i)	STMT_START { EXTEND(sp,1); sv_setiv_mg(PUSHmortal, (IV)(i)); } STMT_END
#define mXPUSHu(u)	STMT_START { EXTEND(sp,1); sv_setuv_mg(PUSHmortal, (UV)(u)); } STMT_END
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005 by Larry Wall and others
d66 3
a68 6
#define PUSHMARK(p)	\
	STMT_START {					\
	    if (++PL_markstack_ptr == PL_markstack_max)	\
	    markstack_grow();				\
	    *PL_markstack_ptr = (p) - PL_stack_base;	\
	} STMT_END
d76 2
a77 1
#define dORIGMARK	const I32 origmark = mark - PL_stack_base
d81 1
a81 1
#define MSPAGAIN	STMT_START { sp = PL_stack_sp; mark = ORIGMARK; } STMT_END
a95 3
#ifndef PERL_CORE
#  define DIE_NULL return DieNull
#endif
d106 2
a107 1
Pops a string off the stack. Deprecated. New code should use POPpx.
d111 1
d115 1
d136 2
a137 3
#define POPpx		(SvPVx_nolen(POPs))
#define POPpconstx	(SvPVx_nolen_const(POPs))
#define POPpbytex	(SvPVbytex_nolen(POPs))
d152 1
a152 1
#define TOPpx		(SvPV_nolen(TOPs))
d293 2
a294 2
#define MEXTEND(p,n)	STMT_START {if (PL_stack_max - p < (int)(n)) {	\
			    const int markoff = mark - PL_stack_base;	\
d411 1
a411 1
	    SV* const right= *(sp); SV* const left= *(sp-1);\
d448 1
a448 1
	STMT_START { dSP; sp--; 	/* get TARGET from below PL_stack_sp */		\
d450 1
a450 1
		{ dSP; tryAMAGICunW(meth,FORCE_SETs,shift,RETURN);}}} STMT_END
d452 7
a458 10
#define setAGAIN(ref)	\
    STMT_START {					\
	sv = ref;					\
	if (!SvROK(ref))				\
	    Perl_croak(aTHX_ "Overloaded dereference did not return a reference");	\
	if (ref != arg && SvRV(ref) != SvRV(arg)) {	\
	    arg = ref;					\
	    goto am_again;				\
	}						\
    } STMT_END
d480 1
a480 1
    SvRV_set(rv, AMG_CALLun(rv,copy));	\
a489 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d11 8
d70 1
a70 1
	    *PL_markstack_ptr = (I32)((p) - PL_stack_base);\
d76 1
a76 1
#define dSP		SV **sp = PL_stack_sp
d79 1
a79 1
#define dORIGMARK	const I32 origmark = (I32)(mark - PL_stack_base)
d98 3
d132 3
a134 3
#define RETURN		return (PUTBACK, NORMAL)
#define RETURNOP(o)	return (PUTBACK, o)
#define RETURNX(x)	return (x, PUTBACK, NORMAL)
d411 6
a416 5
#define tryAMAGICbinW_var(meth_enum,assign,set) STMT_START { \
	    SV* const left = *(sp-1); \
	    SV* const right = *(sp); \
	    if ((SvAMAGIC(left)||SvAMAGIC(right))) {\
		SV * const tmpsv = amagic_call(left, \
d418 5
a422 6
				   (meth_enum), \
				   (assign)? AMGf_assign: 0); \
		if (tmpsv) { \
		    SPAGAIN; \
		    (void)POPs; set(tmpsv); RETURN; } \
		} \
d425 1
a425 8
#define tryAMAGICbinW(meth,assign,set) \
    tryAMAGICbinW_var(CAT2(meth,_amg),assign,set)

#define tryAMAGICbin_var(meth_enum,assign) \
		tryAMAGICbinW_var(meth_enum,assign,SETsv)
#define tryAMAGICbin(meth,assign) \
		tryAMAGICbin_var(CAT2(meth,_amg),assign)

d428 2
a429 7
#define tryAMAGICbinSET_var(meth_enum,assign) \
    tryAMAGICbinW_var(meth_enum,assign,SETs)

#define AMG_CALLun_var(sv,meth_enum) amagic_call(sv,&PL_sv_undef,  \
					meth_enum,AMGf_noright | AMGf_unary)
#define AMG_CALLun(sv,meth) AMG_CALLun_var(sv,CAT2(meth,_amg))

d433 2
a434 1
#define tryAMAGICunW_var(meth_enum,set,shift,ret) STMT_START { \
d440 1
a440 1
		(tmpsv=AMG_CALLun_var(arg,(meth_enum)))) {\
d443 1
a444 2
#define tryAMAGICunW(meth,set,shift,ret) \
	tryAMAGICunW_var(CAT2(meth,_amg),set,shift,ret)
d448 1
a448 2
#define tryAMAGICun_var(meth_enum) tryAMAGICunW_var(meth_enum,SETsvUN,0,RETURN)
#define tryAMAGICun(meth)	tryAMAGICun_var(CAT2(meth,_amg))
a466 2
#define tryAMAGICunDEREF_var(meth_enum) \
	tryAMAGICunW_var(meth_enum,setAGAIN,0,(void)0)
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
a226 4
=for apidoc Am|void|mPUSHs|SV* sv
Push an SV onto the stack and mortalizes the SV.  The stack must have room
for this element.  Does not use C<TARG>.  See also C<PUSHs> and C<mXPUSHs>.

d229 2
a230 1
element.  Does not use C<TARG>.  See also C<PUSHs>, C<XPUSHmortal> and C<XPUSHs>.
d234 2
a235 2
The C<len> indicates the length of the string.  Does not use C<TARG>.
See also C<PUSHp>, C<mXPUSHp> and C<XPUSHp>.
d239 2
a240 1
Does not use C<TARG>.  See also C<PUSHn>, C<mXPUSHn> and C<XPUSHn>.
d244 2
a245 1
Does not use C<TARG>.  See also C<PUSHi>, C<mXPUSHi> and C<XPUSHi>.
d249 2
a250 5
element.  Does not use C<TARG>.  See also C<PUSHu>, C<mXPUSHu> and C<XPUSHu>.

=for apidoc Am|void|mXPUSHs|SV* sv
Push an SV onto the stack, extending the stack if necessary and mortalizes
the SV.  Does not use C<TARG>.  See also C<XPUSHs> and C<mPUSHs>.
d253 3
a255 2
Push a new mortal SV onto the stack, extending the stack if necessary.
Does not use C<TARG>.  See also C<XPUSHs>, C<PUSHmortal> and C<PUSHs>.
d259 2
a260 2
indicates the length of the string.  Does not use C<TARG>.  See also C<XPUSHp>,
C<mPUSHp> and C<PUSHp>.
d263 3
a265 2
Push a double onto the stack, extending the stack if necessary.
Does not use C<TARG>.  See also C<XPUSHn>, C<mPUSHn> and C<PUSHn>.
d268 3
a270 2
Push an integer onto the stack, extending the stack if necessary.
Does not use C<TARG>.  See also C<XPUSHi>, C<mPUSHi> and C<PUSHi>.
d274 2
a275 1
Does not use C<TARG>.  See also C<XPUSHu>, C<mPUSHu> and C<PUSHu>.
a305 1
#define mPUSHs(s)	PUSHs(sv_2mortal(s))
d307 4
a310 4
#define mPUSHp(p,l)	PUSHs(newSVpvn_flags((p), (l), SVs_TEMP))
#define mPUSHn(n)	sv_setnv(PUSHmortal, (NV)(n))
#define mPUSHi(i)	sv_setiv(PUSHmortal, (IV)(i))
#define mPUSHu(u)	sv_setuv(PUSHmortal, (UV)(u))
a311 1
#define mXPUSHs(s)	XPUSHs(sv_2mortal(s))
d313 4
a316 4
#define mXPUSHp(p,l)	STMT_START { EXTEND(sp,1); mPUSHp((p), (l)); } STMT_END
#define mXPUSHn(n)	STMT_START { EXTEND(sp,1); sv_setnv(PUSHmortal, (NV)(n)); } STMT_END
#define mXPUSHi(i)	STMT_START { EXTEND(sp,1); sv_setiv(PUSHmortal, (IV)(i)); } STMT_END
#define mXPUSHu(u)	STMT_START { EXTEND(sp,1); sv_setuv(PUSHmortal, (UV)(u)); } STMT_END
d488 3
a490 3
#define RvDEEPCP(rv) STMT_START { SV* tmpRef=SvRV(rv); SV* rv_copy;     \
  if (SvREFCNT(tmpRef)>1 && (rv_copy = AMG_CALLun(rv,copy))) {          \
    SvRV_set(rv, rv_copy);		    \
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d89 1
a89 1
#define DIE Perl_die
a473 31
#define tryAMAGICftest(chr)				\
    STMT_START {					\
	assert(chr != '?');				\
	if ((PL_op->op_flags & OPf_KIDS)		\
		&& SvAMAGIC(TOPs)) {			\
	    const char tmpchr = (chr);			\
	    SV * const tmpsv = amagic_call(TOPs,	\
		newSVpvn_flags(&tmpchr, 1, SVs_TEMP),	\
		ftest_amg, AMGf_unary);			\
							\
	    if (tmpsv) {				\
		const OP *next = PL_op->op_next;	\
							\
		SPAGAIN;				\
							\
		if (next->op_type >= OP_FTRREAD &&	\
		    next->op_type <= OP_FTBINARY &&	\
		    next->op_private & OPpFT_STACKED	\
		) {					\
		    if (SvTRUE(tmpsv))			\
			/* leave the object alone */	\
			RETURN;				\
		}					\
							\
		SETs(tmpsv);				\
		RETURN;					\
	    }						\
	}						\
    } STMT_END


a501 9

#define SvCANEXISTDELETE(sv) \
 (!SvRMAGICAL(sv)            \
  || ((mg = mg_find((const SV *) sv, PERL_MAGIC_tied))           \
      && (stash = SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(sv), mg)))) \
      && gv_fetchmethod_autoload(stash, "EXISTS", TRUE)          \
      && gv_fetchmethod_autoload(stash, "DELETE", TRUE)          \
     )                       \
  )
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d89 1
a89 1
#define DIE return Perl_die
a330 1
#define dPOPnv_nomg	NV value = (sp--, SvNV_nomg(TOPp1s))
d347 3
a349 3
	(SvOK(sv) || !(PL_op->op_flags & OPf_STACKED))
#define dPOPXiirl_ul_nomg(X) \
    IV right = (sp--, SvIV_nomg(TOPp1s));		\
d351 5
a355 1
    IV left = USE_LEFT(leftsv) ? SvIV_nomg(leftsv) : 0
d359 1
d361 1
d365 1
a365 2
#define dPOPTOPnnrl_nomg \
    NV right = SvNV_nomg(TOPs); NV left = (sp--, SvNV_nomg(TOPs))
d367 1
a367 3
#define dPOPTOPiirl_ul_nomg dPOPXiirl_ul_nomg(TOP)
#define dPOPTOPiirl_nomg \
    IV right = SvIV_nomg(TOPs); IV left = (sp--, SvIV_nomg(TOPs))
a400 3
#define AMGf_numeric	0x10	/* for Perl_try_amagic_bin */
#define AMGf_set	0x20	/* for Perl_try_amagic_bin */

d402 66
a467 11
/* do SvGETMAGIC on the stack args before checking for overload */

#define tryAMAGICun_MG(method, flags) STMT_START { \
	if ( (SvFLAGS(TOPs) & (SVf_ROK|SVs_GMG)) \
		&& Perl_try_amagic_un(aTHX_ method, flags)) \
	    return NORMAL; \
    } STMT_END
#define tryAMAGICbin_MG(method, flags) STMT_START { \
	if ( ((SvFLAGS(TOPm1s)|SvFLAGS(TOPs)) & (SVf_ROK|SVs_GMG)) \
		&& Perl_try_amagic_bin(aTHX_ method, flags)) \
	    return NORMAL; \
d470 32
a501 40
#define AMG_CALLunary(sv,meth) \
    amagic_call(sv,&PL_sv_undef, meth, AMGf_noright | AMGf_unary)

/* No longer used in core. Use AMG_CALLunary instead */
#define AMG_CALLun(sv,meth) AMG_CALLunary(sv, CAT2(meth,_amg))

#define tryAMAGICunTARGET(meth, shift, jump)			\
    STMT_START {						\
	dATARGET;						\
	dSP;							\
	SV *tmpsv;						\
	SV *arg= sp[shift];					\
	if (SvAMAGIC(arg) &&					\
	    (tmpsv = amagic_call(arg, &PL_sv_undef, meth,	\
				 AMGf_noright | AMGf_unary))) {	\
	    SPAGAIN;						\
	    sp += shift;					\
	    sv_setsv(TARG, tmpsv);				\
	    if (opASSIGN)					\
		sp--;						\
	    SETTARG;						\
	    PUTBACK;						\
	    if (jump) {						\
	        OP *jump_o = NORMAL->op_next;                   \
		while (jump_o->op_type == OP_NULL)		\
		    jump_o = jump_o->op_next;			\
		assert(jump_o->op_type == OP_ENTERSUB);		\
		PL_markstack_ptr--;				\
		return jump_o->op_next;				\
	    }							\
	    return NORMAL;					\
	}							\
    } STMT_END

/* This is no longer used anywhere in the core. You might wish to consider
   calling amagic_deref_call() directly, as it has a cleaner interface.  */
#define tryAMAGICunDEREF(meth)						\
    STMT_START {							\
	sv = amagic_deref_call(*sp, CAT2(meth,_amg));			\
	SPAGAIN;							\
d516 11
a541 25

#ifdef PERL_CORE

/* These are just for Perl_tied_method(), which is not part of the public API.
   Use 0x04 rather than the next available bit, to help the compiler if the
   architecture can generate more efficient instructions.  */
#  define TIED_METHOD_MORTALIZE_NOT_NEEDED	0x04
#  define TIED_METHOD_ARGUMENTS_ON_STACK	0x08
#  define TIED_METHOD_SAY			0x10

/* Used in various places that need to dereference a glob or globref */
#  define MAYBE_DEREF_GV_flags(sv,phlags)                          \
    (                                                               \
	(void)(phlags & SV_GMAGIC && (SvGETMAGIC(sv),0)),            \
	isGV_with_GP(sv)                                              \
	  ? (GV *)sv                                                   \
	  : SvROK(sv) && SvTYPE(SvRV(sv)) <= SVt_PVLV &&               \
	    (SvGETMAGIC(SvRV(sv)), isGV_with_GP(SvRV(sv)))              \
	     ? (GV *)SvRV(sv)                                            \
	     : NULL                                                       \
    )
#  define MAYBE_DEREF_GV(sv)      MAYBE_DEREF_GV_flags(sv,SV_GMAGIC)
#  define MAYBE_DEREF_GV_nomg(sv) MAYBE_DEREF_GV_flags(sv,0)

#endif
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d70 1
a70 1
#define dMARK		SV **mark = PL_stack_base + POPMARK
d100 1
a100 1
Pops a string off the stack.
d103 1
a103 2
Pops a string off the stack.  Identical to POPp.  There are two names for
historical reasons.
d126 1
a126 1
#define POPp		POPpx
d143 1
a143 1
#define TOPp		TOPpx
d280 3
a282 2
#define EXTEND(p,n)    (void)(UNLIKELY(PL_stack_max - p < (int)(n)) &&         \
			    (sp = stack_grow(sp,p, (int) (n))))
d285 5
a289 5
#define MEXTEND(p,n)   STMT_START {if (UNLIKELY(PL_stack_max - p < (int)(n))) {\
                           const int markoff = mark - PL_stack_base;           \
                           sp = stack_grow(sp,p,(int) (n));                    \
                           mark = PL_stack_base + markoff;                     \
                       } } STMT_END
d298 1
a298 1
#define XPUSHs(s)	(EXTEND(sp,1), *++sp = (s))
d391 1
a391 1
	if (UNLIKELY(PL_tmps_ix + (n) >= PL_tmps_max))			\
a400 1
#define AMGf_want_list	0x40
d422 1
a422 1
#define tryAMAGICunTARGETlist(meth, jump)			\
d424 1
d427 1
a427 2
	SV *arg= *sp;						\
        int gimme = GIMME_V;                                    \
d430 1
a430 2
				 AMGf_want_list | AMGf_noright	\
				|AMGf_unary))) {		\
d432 5
a436 20
            if (gimme == G_VOID) {                              \
                (void)POPs; /* XXX ??? */                       \
            }                                                   \
            else if (gimme == G_ARRAY) {			\
                int i;                                          \
                I32 len;                                        \
                assert(SvTYPE(tmpsv) == SVt_PVAV);              \
                len = av_len((AV *)tmpsv) + 1;                  \
                (void)POPs; /* get rid of the arg */            \
                EXTEND(sp, len);                                \
                for (i = 0; i < len; ++i)                       \
                    PUSHs(av_shift((AV *)tmpsv));               \
            }                                                   \
            else { /* AMGf_want_scalar */                       \
                dATARGET; /* just use the arg's location */     \
                sv_setsv(TARG, tmpsv);                          \
                if (opASSIGN)                                   \
                    sp--;                                       \
                SETTARG;                                        \
            }                                                   \
d479 2
a480 2
  || !(mg = mg_find((const SV *) sv, PERL_MAGIC_tied))           \
  || (   (stash = SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(sv), mg)))) \
d500 1
a500 1
	  ? (GV *)(sv)                                                \
a508 3
#  define FIND_RUNCV_padid_eq	1
#  define FIND_RUNCV_level_eq	2

d515 1
a515 1
 * indent-tabs-mode: nil
d518 1
a518 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d33 1
a33 1
Declare Just C<SP>.  This is actually identical to C<dSP>, and declares
d60 1
a60 1
	    if (UNLIKELY(++PL_markstack_ptr == PL_markstack_max))	\
d136 4
d151 4
d159 2
a160 2
=for apidoc Am|void|EXTEND|SP|SSize_t nitems
Used to extend the argument stack for an XSUB's return values.  Once
d281 2
a282 11
#ifdef STRESS_REALLOC
# define EXTEND(p,n)	(void)(sp = stack_grow(sp,p, (SSize_t)(n)))
/* Same thing, but update mark register too. */
# define MEXTEND(p,n)	STMT_START {					\
			    const int markoff = mark - PL_stack_base;	\
			    sp = stack_grow(sp,p,(SSize_t) (n));	\
			    mark = PL_stack_base + markoff;		\
			} STMT_END
#else
# define EXTEND(p,n)   (void)(UNLIKELY(PL_stack_max - p < (SSize_t)(n)) &&     \
			    (sp = stack_grow(sp,p, (SSize_t) (n))))
d285 1
a285 1
# define MEXTEND(p,n)  STMT_START {if (UNLIKELY(PL_stack_max - p < (int)(n))) {\
d287 1
a287 1
                           sp = stack_grow(sp,p,(SSize_t) (n));                \
a289 1
#endif
d336 6
d407 1
a407 1
	if ( UNLIKELY((SvFLAGS(TOPs) & (SVf_ROK|SVs_GMG))) \
d412 1
a412 1
	if ( UNLIKELY(((SvFLAGS(TOPm1s)|SvFLAGS(TOPs)) & (SVf_ROK|SVs_GMG))) \
d429 1
a429 1
	if (UNLIKELY(SvAMAGIC(arg) &&				\
d432 1
a432 2
				|AMGf_unary))))                 \
        {                                       		\
d438 2
a439 2
                SSize_t i;                                      \
                SSize_t len;                                    \
d441 1
a441 1
                len = av_tindex((AV *)tmpsv) + 1;               \
@


1.1.1.15
log
@Import perl-5.24.2
@
text
@d17 1
a17 1
Stack pointer.  This is usually handled by C<xsubpp>.  See C<L</dSP>> and
d21 1
a21 1
Stack marker variable for the XSUB.  See C<L</dMARK>>.
d24 1
a24 1
Opening bracket for arguments on a callback.  See C<L</PUTBACK>> and
d29 1
a29 1
the C<SP> macro.  See C<L</SP>>.
d35 2
a36 2
See C<L<perlapi/SP>>.  (Available for backward source code compatibility with
the old (Perl 5.005) thread model.)
d39 2
a40 2
Declare a stack marker variable, C<mark>, for the XSUB.  See C<L</MARK>> and
C<L</dORIGMARK>>.
d43 1
a43 1
Saves the original stack mark for the XSUB.  See C<L</ORIGMARK>>.
d46 1
a46 1
The original stack mark for the XSUB.  See C<L</dORIGMARK>>.
d58 6
a63 1
#if defined(DEBUGGING) && defined(PERL_USE_GCC_BRACE_GROUPS)
d65 2
a66 50
#  define PUSHMARK(p) \
    STMT_START {                                                      \
        I32 * mark_stack_entry;                                       \
        if (UNLIKELY((mark_stack_entry = ++PL_markstack_ptr)          \
                                           == PL_markstack_max))      \
	    mark_stack_entry = markstack_grow();                      \
        *mark_stack_entry  = (I32)((p) - PL_stack_base);              \
        DEBUG_s(DEBUG_v(PerlIO_printf(Perl_debug_log,                 \
                "MARK push %p %"IVdf"\n",                             \
                PL_markstack_ptr, (IV)*mark_stack_entry)));           \
    } STMT_END

#  define TOPMARK \
    ({                                                                \
        DEBUG_s(DEBUG_v(PerlIO_printf(Perl_debug_log,                 \
                "MARK top  %p %"IVdf"\n",                             \
                PL_markstack_ptr, (IV)*PL_markstack_ptr)));           \
        *PL_markstack_ptr;                                            \
    })

#  define POPMARK \
    ({                                                                \
        DEBUG_s(DEBUG_v(PerlIO_printf(Perl_debug_log,                 \
                "MARK pop  %p %"IVdf"\n",                             \
                (PL_markstack_ptr-1), (IV)*(PL_markstack_ptr-1))));   \
        assert((PL_markstack_ptr > PL_markstack) || !"MARK underflow");\
        *PL_markstack_ptr--;                                          \
    })

#  define INCMARK \
    ({                                                                \
        DEBUG_s(DEBUG_v(PerlIO_printf(Perl_debug_log,                 \
                "MARK inc  %p %"IVdf"\n",                             \
                (PL_markstack_ptr+1), (IV)*(PL_markstack_ptr+1))));   \
        *PL_markstack_ptr++;                                          \
    })

#else

#  define PUSHMARK(p)                                                   \
    STMT_START {					              \
        I32 * mark_stack_entry;                                       \
        if (UNLIKELY((mark_stack_entry = ++PL_markstack_ptr) == PL_markstack_max)) \
	    mark_stack_entry = markstack_grow();                      \
        *mark_stack_entry  = (I32)((p) - PL_stack_base);              \
    } STMT_END
#  define TOPMARK                (*PL_markstack_ptr)
#  define POPMARK                (*PL_markstack_ptr--)
#  define INCMARK                (*PL_markstack_ptr++)
#endif
d94 1
a94 1
See C<L</PUSHMARK>> and L<perlcall> for other uses.
a114 3
=for apidoc Amn|UV|POPu
Pops an unsigned integer off the stack.

a117 3
=for apidoc Amn|long|POPul
Pops an unsigned long off the stack.

d158 2
a159 2
Does not handle 'set' magic.  Does not use C<TARG>.  See also
C<L</PUSHmortal>>, C<L</XPUSHs>>, and C<L</XPUSHmortal>>.
d166 1
a166 1
C<L</mPUSHp>> instead.  See also C<L</XPUSHp>> and C<L</mXPUSHp>>.
d172 2
a173 2
return lists from XSUB's - see C<L</mPUSHn>> instead.  See also C<L</XPUSHn>>
and C<L</mXPUSHn>>.
d179 2
a180 2
return lists from XSUB's - see C<L</mPUSHi>> instead.  See also C<L</XPUSHi>>
and C<L</mXPUSHi>>.
d186 2
a187 2
macros to return lists from XSUB's - see C<L</mPUSHu>> instead.  See also
C<L</XPUSHu>> and C<L</mXPUSHu>>.
d191 1
a191 1
handle 'set' magic.  Does not use C<TARG>.  See also C<L</XPUSHmortal>>,
d199 1
a199 1
C<L</mXPUSHp>> instead.  See also C<L</PUSHp>> and C<L</mPUSHp>>.
d205 1
a205 2
from XSUB's - see C<L</mXPUSHn>> instead.  See also C<L</PUSHn>> and
C<L</mPUSHn>>.
d211 1
a211 2
from XSUB's - see C<L</mXPUSHi>> instead.  See also C<L</PUSHi>> and
C<L</mPUSHi>>.
d217 2
a218 2
return lists from XSUB's - see C<L</mXPUSHu>> instead.  See also C<L</PUSHu>> and
C<L</mPUSHu>>.
d222 1
a222 2
for this element.  Does not use C<TARG>.  See also C<L</PUSHs>> and
C<L</mXPUSHs>>.
d226 1
a226 2
element.  Does not use C<TARG>.  See also C<L</PUSHs>>, C<L</XPUSHmortal>> and
C<L</XPUSHs>>.
d231 1
a231 1
See also C<L</PUSHp>>, C<L</mXPUSHp>> and C<L</XPUSHp>>.
d235 1
a235 1
Does not use C<TARG>.  See also C<L</PUSHn>>, C<L</mXPUSHn>> and C<L</XPUSHn>>.
d239 1
a239 1
Does not use C<TARG>.  See also C<L</PUSHi>>, C<L</mXPUSHi>> and C<L</XPUSHi>>.
d243 1
a243 2
element.  Does not use C<TARG>.  See also C<L</PUSHu>>, C<L</mXPUSHu>> and
C<L</XPUSHu>>.
d247 1
a247 1
the SV.  Does not use C<TARG>.  See also C<L</XPUSHs>> and C<L</mPUSHs>>.
d251 1
a251 2
Does not use C<TARG>.  See also C<L</XPUSHs>>, C<L</PUSHmortal>> and
C<L</PUSHs>>.
d255 2
a256 2
indicates the length of the string.  Does not use C<TARG>.  See also
C<L</XPUSHp>>, C<mPUSHp> and C<PUSHp>.
d260 1
a260 1
Does not use C<TARG>.  See also C<L</XPUSHn>>, C<L</mPUSHn>> and C<L</PUSHn>>.
d264 1
a264 1
Does not use C<TARG>.  See also C<L</XPUSHi>>, C<L</mPUSHi>> and C<L</PUSHi>>.
d268 1
a268 1
Does not use C<TARG>.  See also C<L</XPUSHu>>, C<L</mPUSHu>> and C<L</PUSHu>>.
a272 10
/* _EXTEND_SAFE_N(n): private helper macro for EXTEND().
 * Tests whether the value of n would be truncated when implicitly cast to
 * SSize_t as an arg to stack_grow(). If so, sets it to -1 instead to
 * trigger a panic. It will be constant folded on platforms where this
 * can't happen.
 */

#define _EXTEND_SAFE_N(n) \
        (sizeof(n) > sizeof(SSize_t) && ((SSize_t)(n) != (n)) ? -1 : (n))

d274 1
a274 4
# define EXTEND(p,n)   STMT_START {                                     \
                           sp = stack_grow(sp,p,_EXTEND_SAFE_N(n));     \
                           PERL_UNUSED_VAR(sp);                         \
                       } STMT_END
d276 5
a280 6
# define MEXTEND(p,n)   STMT_START {                                    \
                            const SSize_t markoff = mark - PL_stack_base; \
                            sp = stack_grow(sp,p,_EXTEND_SAFE_N(n));    \
                            mark = PL_stack_base + markoff;             \
                            PERL_UNUSED_VAR(sp);                        \
                        } STMT_END
d282 2
a284 23
/* _EXTEND_NEEDS_GROW(p,n): private helper macro for EXTEND().
 * Tests to see whether n is too big and we need to grow the stack. Be
 * very careful if modifying this. There are many ways to get things wrong
 * (wrapping, truncating etc) that could cause a false negative and cause
 * the call to stack_grow() to be skipped. On the other hand, false
 * positives are safe.
 * Bear in mind that sizeof(p) may be less than, equal to, or greater
 * than sizeof(n), and while n is documented to be signed, someone might
 * pass an unsigned value or expression. In general don't use casts to
 * avoid warnings; instead expect the caller to fix their code.
 * It is legal for p to be greater than PL_stack_max.
 * If the allocated stack is already very large but current usage is
 * small, then PL_stack_max - p might wrap round to a negative value, but
 * this just gives a safe false positive
 */

#  define _EXTEND_NEEDS_GROW(p,n) ( (n) < 0 || PL_stack_max - p < (n))

#  define EXTEND(p,n)   STMT_START {                                    \
                         if (UNLIKELY(_EXTEND_NEEDS_GROW(p,n))) {       \
                           sp = stack_grow(sp,p,_EXTEND_SAFE_N(n));     \
                           PERL_UNUSED_VAR(sp);                         \
                         } } STMT_END
d286 5
a290 7
#  define MEXTEND(p,n)  STMT_START {                                    \
                         if (UNLIKELY(_EXTEND_NEEDS_GROW(p,n))) {       \
                           const SSize_t markoff = mark - PL_stack_base;\
                           sp = stack_grow(sp,p,_EXTEND_SAFE_N(n));     \
                           mark = PL_stack_base + markoff;              \
                           PERL_UNUSED_VAR(sp);                         \
                         } } STMT_END
a292 66
/* set TARG to the IV value i. If do_taint is false,
 * assume that PL_tainted can never be true */
#define TARGi(i, do_taint) \
    STMT_START {                                                        \
        IV TARGi_iv = i;                                                \
        if (LIKELY(                                                     \
              ((SvFLAGS(TARG) & (SVTYPEMASK|SVf_THINKFIRST|SVf_IVisUV)) == SVt_IV) \
            & (do_taint ? !TAINT_get : 1)))                             \
        {                                                               \
            /* Cheap SvIOK_only().                                      \
             * Assert that flags which SvIOK_only() would test or       \
             * clear can't be set, because we're SVt_IV */              \
            assert(!(SvFLAGS(TARG) &                                    \
                (SVf_OOK|SVf_UTF8|(SVf_OK & ~(SVf_IOK|SVp_IOK)))));     \
            SvFLAGS(TARG) |= (SVf_IOK|SVp_IOK);                         \
            /* SvIV_set() where sv_any points to head */                \
            TARG->sv_u.svu_iv = TARGi_iv;                               \
        }                                                               \
        else                                                            \
            sv_setiv_mg(targ, TARGi_iv);                                \
    } STMT_END

/* set TARG to the UV value u. If do_taint is false,
 * assume that PL_tainted can never be true */
#define TARGu(u, do_taint) \
    STMT_START {                                                        \
        UV TARGu_uv = u;                                                \
        if (LIKELY(                                                     \
              ((SvFLAGS(TARG) & (SVTYPEMASK|SVf_THINKFIRST|SVf_IVisUV)) == SVt_IV) \
            & (do_taint ? !TAINT_get : 1)                               \
            & (TARGu_uv <= (UV)IV_MAX)))                                \
        {                                                               \
            /* Cheap SvIOK_only().                                      \
             * Assert that flags which SvIOK_only() would test or       \
             * clear can't be set, because we're SVt_IV */              \
            assert(!(SvFLAGS(TARG) &                                    \
                (SVf_OOK|SVf_UTF8|(SVf_OK & ~(SVf_IOK|SVp_IOK)))));     \
            SvFLAGS(TARG) |= (SVf_IOK|SVp_IOK);                         \
            /* SvIV_set() where sv_any points to head */                \
            TARG->sv_u.svu_iv = TARGu_uv;                               \
        }                                                               \
        else                                                            \
            sv_setuv_mg(targ, TARGu_uv);                                \
    } STMT_END

/* set TARG to the NV value n. If do_taint is false,
 * assume that PL_tainted can never be true */
#define TARGn(n, do_taint) \
    STMT_START {                                                        \
        NV TARGn_nv = n;                                                \
        if (LIKELY(                                                     \
              ((SvFLAGS(TARG) & (SVTYPEMASK|SVf_THINKFIRST)) == SVt_NV) \
            & (do_taint ? !TAINT_get : 1)))                             \
        {                                                               \
            /* Cheap SvNOK_only().                                      \
             * Assert that flags which SvNOK_only() would test or       \
             * clear can't be set, because we're SVt_NV */              \
            assert(!(SvFLAGS(TARG) &                                    \
                (SVf_OOK|SVf_UTF8|(SVf_OK & ~(SVf_NOK|SVp_NOK)))));     \
            SvFLAGS(TARG) |= (SVf_NOK|SVp_NOK);                         \
            SvNV_set(TARG, TARGn_nv);                                   \
        }                                                               \
        else                                                            \
            sv_setnv_mg(targ, TARGn_nv);                                \
    } STMT_END

d296 3
a298 3
#define PUSHn(n)	STMT_START { TARGn(n,1); PUSHs(TARG); } STMT_END
#define PUSHi(i)	STMT_START { TARGi(i,1); PUSHs(TARG); } STMT_END
#define PUSHu(u)	STMT_START { TARGu(u,1); PUSHs(TARG); } STMT_END
d300 1
a300 1
#define XPUSHs(s)	STMT_START { EXTEND(sp,1); *++sp = (s); } STMT_END
d303 3
a305 3
#define XPUSHn(n)	STMT_START { TARGn(n,1); XPUSHs(TARG); } STMT_END
#define XPUSHi(i)	STMT_START { TARGi(i,1); XPUSHs(TARG); } STMT_END
#define XPUSHu(u)	STMT_START { TARGu(u,1); XPUSHs(TARG); } STMT_END
d325 3
a327 3
#define SETn(n)		STMT_START { TARGn(n,1); SETs(TARG); } STMT_END
#define SETi(i)		STMT_START { TARGi(i,1); SETs(TARG); } STMT_END
#define SETu(u)		STMT_START { TARGu(u,1); SETs(TARG); } STMT_END
a369 1
#define RETSETTARG	STMT_START { SETTARG; RETURN; } STMT_END
d373 2
a374 1
#define MAXARG		(PL_op->op_private & OPpARG4_MASK)
d386 3
a388 4
    STMT_START {						\
	SSize_t eMiX = PL_tmps_ix + (n);			\
	if (UNLIKELY(eMiX >= PL_tmps_max))			\
	    (void)Perl_tmps_grow_p(aTHX_ eMiX);			\
a397 1
#define AMGf_numarg	0x80
d424 1
a424 1
        U8 gimme = GIMME_V;                                    \
d432 1
a432 1
                NOOP;                                           \
d457 1
a457 1
		(void)POPMARK;                                        \
d474 9
d529 6
@


