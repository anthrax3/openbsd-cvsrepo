head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.7.0.12
	OPENBSD_6_1_BASE:1.1.1.7
	OPENBSD_6_0:1.1.1.7.0.10
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.4
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.6
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.6.0.8
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.6
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.2
	OPENBSD_5_4_BASE:1.1.1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.1.1.5.0.10
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.8
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.6
	OPENBSD_5_0:1.1.1.5.0.4
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.2
	OPENBSD_4_9_BASE:1.1.1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.1.1.4.0.4
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.2
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.10
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.8
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.6
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.4
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.2
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2003.12.03.02.43.36;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.03.02.43.36;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.03.28.18.47.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.10.12.18.10.33;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.09.24.14.48.33;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.06.39;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.11.17.20.52.39;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@#!/usr/bin/perl -w
require 5.003;	# keep this compatible, an old perl is all we may have before
                # we build the new one

# The idea is to move the regen_headers target out of the Makefile so that
# it is possible to rebuild the headers before the Makefile is available.
# (and the Makefile is unavailable until after Configure is run, and we may
# wish to make a clean source tree but with current headers without running
# anything else.

use strict;
my $perl = $^X;

require 'regen_lib.pl';
# keep warnings.pl in sync with the CPAN distribution by not requiring core
# changes
safer_unlink ("warnings.h", "lib/warnings.pm");

my %gen = (
	   'autodoc.pl'  => [qw[pod/perlapi.pod pod/perlintern.pod]],
	   'bytecode.pl' => [qw[ext/ByteLoader/byterun.h
				ext/ByteLoader/byterun.c
				ext/B/B/Asmdata.pm]],
	   'embed.pl'    => [qw[proto.h embed.h embedvar.h global.sym
				perlapi.h perlapi.c]],
	   'keywords.pl' => [qw[keywords.h]],
	   'opcode.pl'   => [qw[opcode.h opnames.h pp_proto.h pp.sym]],
	   'regcomp.pl'  => [qw[regnodes.h]],
	   'warnings.pl' => [qw[warnings.h lib/warnings.pm]]
	   );

sub do_cksum {
    my $pl = shift;
    my %cksum;
    for my $f (@@{ $gen{$pl} }) {
	local *FH;
	if (open(FH, $f)) {
	    local $/;
	    $cksum{$f} = unpack("%32C*", <FH>);
	    close FH;
	} else {
	    warn "$0: $f: $!\n";
	}
    }
    return %cksum;
}

foreach my $pl (qw (keywords.pl opcode.pl embed.pl bytecode.pl
		    regcomp.pl warnings.pl autodoc.pl)) {
  print "$^X $pl\n";
  my %cksum0;
  %cksum0 = do_cksum($pl) unless $pl eq 'warnings.pl'; # the files were removed
  system "$^X $pl";
  next if $pl eq 'warnings.pl'; # the files were removed
  my %cksum1 = do_cksum($pl);
  my @@chg;
  for my $f (@@{ $gen{$pl} }) {
      push(@@chg, $f)
	  if !defined($cksum0{$f}) ||
	     !defined($cksum1{$f}) ||
	     $cksum0{$f} ne $cksum1{$f};
  }
  print "Changed: @@chg\n" if @@chg;
}
@


1.1.1.1
log
@perl 5.8.2 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.8 import
@
text
@d29 1
a29 2
	   'warnings.pl' => [qw[warnings.h lib/warnings.pm]],
	   'reentr.pl' => [qw[reentr.c reentr.h]],
d49 1
a49 1
		    regcomp.pl warnings.pl autodoc.pl reentr.pl)) {
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d21 3
d30 1
a30 2
	   'reentr.pl'   => [qw[reentr.c reentr.h]],
	   'overload.pl' => [qw[overload.h]],
d49 1
a49 1
foreach my $pl (qw (keywords.pl opcode.pl embed.pl
@


1.1.1.4
log
@import perl 5.10.1
@
text
@a1 3
#
# regen.pl - a wrapper that runs all *.pl scripts to to autogenerate files

d14 1
d16 2
a17 19
# changes.  Um, what ?
# safer_unlink ("warnings.h", "lib/warnings.pm");

# Which scripts to run. Note the ordering: embed.pl must run after
# opcode.pl, since it depends on pp.sym

my @@scripts = qw(
warnings.pl
regcomp.pl
reentr.pl
overload.pl
opcode.pl
keywords.pl
embed.pl
);

# Which files are (re)generated by each script.
# *** We no longer need these values, as the "changed" message is
# now generated by regen_lib.pl, so should we just drop them?
d20 1
d28 1
a28 1
	   'overload.pl' => [qw[overload.c overload.h lib/overload/numbers.pm]],
d47 16
a62 4
foreach my $pl (@@scripts) {
  my @@command =  ($^X, $pl, @@ARGV);
  print "@@command\n";
  system @@command;
@


1.1.1.5
log
@Perl 5.12.2 from CPAN
@
text
@d25 5
a30 6
opcode.pl
overload.pl
reentr.pl
regcomp.pl
warnings.pl

@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d5 1
a5 1
require 5.004;	# keep this compatible, an old perl is all we may have before
d15 1
d17 6
a22 1
# Which scripts to run.
d25 1
a25 1
mg_vtable.pl
d31 1
a32 1
feature.pl
d35 32
a66 2
my $tap = $ARGV[0] && $ARGV[0] eq '--tap' ? '# ' : '';
foreach my $pl (map {"regen/$_"} @@scripts) {
d68 1
a68 1
  print "$tap@@command\n";
@


1.1.1.7
log
@Import perl-5.20.1
@
text
@d3 1
a3 1
# regen.pl - a wrapper that runs all *.pl scripts to autogenerate files
d16 1
a16 7
my $tap = $ARGV[0] && $ARGV[0] eq '--tap' ? '# ' : '';
foreach my $pl (map {chomp; "regen/$_"} <DATA>) {
  my @@command =  ($^X, $pl, @@ARGV);
  print "$tap@@command\n";
  system @@command
    and die "@@command failed: $?" 
}
d18 1
a18 1
__END__
d27 8
@


