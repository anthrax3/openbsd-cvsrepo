head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.6
	OPENBSD_6_2_BASE:1.3
	PERL_5_24_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.32.01;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2013.03.25.20.40.50;	author sthen;	state dead;
branches;
next	1.1;

1.1
date	2010.09.24.14.49.00;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.00;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2017.08.14.13.45.59;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package Math::BigInt;

#
# "Mike had an infinite amount to do and a negative amount of time in which
# to do it." - Before and After
#

# The following hash values are used:
#   value: unsigned int with actual value (as a Math::BigInt::Calc or similar)
#   sign : +,-,NaN,+inf,-inf
#   _a   : accuracy
#   _p   : precision
#   _f   : flags, used by MBF to flag parts of a float as untouchable

# Remember not to take shortcuts ala $xs = $x->{value}; $CALC->foo($xs); since
# underlying lib might change the reference!

use 5.006001;
use strict;
use warnings;

our $VERSION = '1.999715';
$VERSION = eval $VERSION;

our @@ISA = qw(Exporter);
our @@EXPORT_OK = qw(objectify bgcd blcm);

# _trap_inf and _trap_nan are internal and should never be accessed from the
# outside
our ($round_mode, $accuracy, $precision, $div_scale, $rnd_mode,
     $upgrade, $downgrade, $_trap_nan, $_trap_inf);

my $class = "Math::BigInt";

# Inside overload, the first arg is always an object. If the original code had
# it reversed (like $x = 2 * $y), then the third parameter is true.
# In some cases (like add, $x = $x + 2 is the same as $x = 2 + $x) this makes
# no difference, but in some cases it does.

# For overloaded ops with only one argument we simple use $_[0]->copy() to
# preserve the argument.

# Thus inheritance of overload operators becomes possible and transparent for
# our subclasses without the need to repeat the entire overload section there.

# We register ops that are not registerable yet, so suppress warnings
{ no warnings;
use overload
'='     =>      sub { $_[0]->copy(); },

# some shortcuts for speed (assumes that reversed order of arguments is routed
# to normal '+' and we thus can always modify first arg. If this is changed,
# this breaks and must be adjusted.)
'+='    =>      sub { $_[0]->badd($_[1]); },
'-='    =>      sub { $_[0]->bsub($_[1]); },
'*='    =>      sub { $_[0]->bmul($_[1]); },
'/='    =>      sub { scalar $_[0]->bdiv($_[1]); },
'%='    =>      sub { $_[0]->bmod($_[1]); },
'^='    =>      sub { $_[0]->bxor($_[1]); },
'&='    =>      sub { $_[0]->band($_[1]); },
'|='    =>      sub { $_[0]->bior($_[1]); },

'**='   =>      sub { $_[0]->bpow($_[1]); },
'<<='   =>      sub { $_[0]->blsft($_[1]); },
'>>='   =>      sub { $_[0]->brsft($_[1]); },

# not supported by Perl yet
'..'    =>      \&_pointpoint,

'<=>'   =>      sub { my $rc = $_[2] ?
                      ref($_[0])->bcmp($_[1],$_[0]) :
                      $_[0]->bcmp($_[1]);
                      $rc = 1 unless defined $rc;
                      $rc <=> 0;
                },
# we need '>=' to get things like "1 >= NaN" right:
'>='    =>      sub { my $rc = $_[2] ?
                      ref($_[0])->bcmp($_[1],$_[0]) :
                      $_[0]->bcmp($_[1]);
                      # if there was a NaN involved, return false
                      return '' unless defined $rc;
                      $rc >= 0;
                },
'cmp'   =>      sub {
         $_[2] ?
               "$_[1]" cmp $_[0]->bstr() :
               $_[0]->bstr() cmp "$_[1]" },

'cos'   =>      sub { $_[0]->copy->bcos(); },
'sin'   =>      sub { $_[0]->copy->bsin(); },
'atan2' =>      sub { $_[2] ?
                        ref($_[0])->new($_[1])->batan2($_[0]) :
                        $_[0]->copy()->batan2($_[1]) },

# are not yet overloadable
#'hex'  =>      sub { print "hex"; $_[0]; },
#'oct'  =>      sub { print "oct"; $_[0]; },

# log(N) is log(N, e), where e is Euler's number
'log'   =>      sub { $_[0]->copy()->blog(); },
'exp'   =>      sub { $_[0]->copy()->bexp($_[1]); },
'int'   =>      sub { $_[0]->copy(); },
'neg'   =>      sub { $_[0]->copy()->bneg(); },
'abs'   =>      sub { $_[0]->copy()->babs(); },
'sqrt'  =>      sub { $_[0]->copy()->bsqrt(); },
'~'     =>      sub { $_[0]->copy()->bnot(); },

# for subtract it's a bit tricky to not modify b: b-a => -a+b
'-'     =>      sub { my $c = $_[0]->copy; $_[2] ?
                        $c->bneg()->badd( $_[1]) :
                        $c->bsub( $_[1]) },
'+'     =>      sub { $_[0]->copy()->badd($_[1]); },
'*'     =>      sub { $_[0]->copy()->bmul($_[1]); },

'/'     =>      sub {
   $_[2] ? ref($_[0])->new($_[1])->bdiv($_[0]) : $_[0]->copy->bdiv($_[1]);
  },
'%'     =>      sub {
   $_[2] ? ref($_[0])->new($_[1])->bmod($_[0]) : $_[0]->copy->bmod($_[1]);
  },
'**'    =>      sub {
   $_[2] ? ref($_[0])->new($_[1])->bpow($_[0]) : $_[0]->copy->bpow($_[1]);
  },
'<<'    =>      sub {
   $_[2] ? ref($_[0])->new($_[1])->blsft($_[0]) : $_[0]->copy->blsft($_[1]);
  },
'>>'    =>      sub {
   $_[2] ? ref($_[0])->new($_[1])->brsft($_[0]) : $_[0]->copy->brsft($_[1]);
  },
'&'     =>      sub {
   $_[2] ? ref($_[0])->new($_[1])->band($_[0]) : $_[0]->copy->band($_[1]);
  },
'|'     =>      sub {
   $_[2] ? ref($_[0])->new($_[1])->bior($_[0]) : $_[0]->copy->bior($_[1]);
  },
'^'     =>      sub {
   $_[2] ? ref($_[0])->new($_[1])->bxor($_[0]) : $_[0]->copy->bxor($_[1]);
  },

# can modify arg of ++ and --, so avoid a copy() for speed, but don't
# use $_[0]->bone(), it would modify $_[0] to be 1!
'++'    =>      sub { $_[0]->binc() },
'--'    =>      sub { $_[0]->bdec() },

# if overloaded, O(1) instead of O(N) and twice as fast for small numbers
'bool'  =>      sub {
  # this kludge is needed for perl prior 5.6.0 since returning 0 here fails :-/
  # v5.6.1 dumps on this: return !$_[0]->is_zero() || undef;                :-(
  my $t = undef;
  $t = 1 if !$_[0]->is_zero();
  $t;
  },

# the original qw() does not work with the TIESCALAR below, why?
# Order of arguments insignificant
'""' => sub { $_[0]->bstr(); },
'0+' => sub { $_[0]->numify(); }
;
} # no warnings scope

##############################################################################
# global constants, flags and accessory

# These vars are public, but their direct usage is not recommended, use the
# accessor methods instead

$round_mode = 'even'; # one of 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'
$accuracy   = undef;
$precision  = undef;
$div_scale  = 40;

$upgrade = undef;                       # default is no upgrade
$downgrade = undef;                     # default is no downgrade

# These are internally, and not to be used from the outside at all

$_trap_nan = 0;                         # are NaNs ok? set w/ config()
$_trap_inf = 0;                         # are infs ok? set w/ config()
my $nan = 'NaN';                        # constants for easier life

my $CALC = 'Math::BigInt::Calc';        # module to do the low level math
                                        # default is Calc.pm
my $IMPORT = 0;                         # was import() called yet?
                                        # used to make require work
my %WARN;                               # warn only once for low-level libs
my %CAN;                                # cache for $CALC->can(...)
my %CALLBACKS;                          # callbacks to notify on lib loads
my $EMU_LIB = 'Math/BigInt/CalcEmu.pm'; # emulate low-level math

##############################################################################
# the old code had $rnd_mode, so we need to support it, too

$rnd_mode   = 'even';
sub TIESCALAR  { my ($class) = @@_; bless \$round_mode, $class; }
sub FETCH      { return $round_mode; }
sub STORE      { $rnd_mode = $_[0]->round_mode($_[1]); }

BEGIN
  {
  # tie to enable $rnd_mode to work transparently
  tie $rnd_mode, 'Math::BigInt';

  # set up some handy alias names
  *as_int = \&as_number;
  *is_pos = \&is_positive;
  *is_neg = \&is_negative;
  }

##############################################################################

sub round_mode
  {
  no strict 'refs';
  # make Class->round_mode() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  if (defined $_[0])
    {
    my $m = shift;
    if ($m !~ /^(even|odd|\+inf|\-inf|zero|trunc|common)$/)
      {
      require Carp; Carp::croak ("Unknown round mode '$m'");
      }
    return ${"${class}::round_mode"} = $m;
    }
  ${"${class}::round_mode"};
  }

sub upgrade
  {
  no strict 'refs';
  # make Class->upgrade() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  # need to set new value?
  if (@@_ > 0)
    {
    return ${"${class}::upgrade"} = $_[0];
    }
  ${"${class}::upgrade"};
  }

sub downgrade
  {
  no strict 'refs';
  # make Class->downgrade() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  # need to set new value?
  if (@@_ > 0)
    {
    return ${"${class}::downgrade"} = $_[0];
    }
  ${"${class}::downgrade"};
  }

sub div_scale
  {
  no strict 'refs';
  # make Class->div_scale() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  if (defined $_[0])
    {
    if ($_[0] < 0)
      {
      require Carp; Carp::croak ('div_scale must be greater than zero');
      }
    ${"${class}::div_scale"} = $_[0];
    }
  ${"${class}::div_scale"};
  }

sub accuracy
  {
  # $x->accuracy($a);           ref($x) $a
  # $x->accuracy();             ref($x)
  # Class->accuracy();          class
  # Class->accuracy($a);        class $a

  my $x = shift;
  my $class = ref($x) || $x || __PACKAGE__;

  no strict 'refs';
  # need to set new value?
  if (@@_ > 0)
    {
    my $a = shift;
    # convert objects to scalars to avoid deep recursion. If object doesn't
    # have numify(), then hopefully it will have overloading for int() and
    # boolean test without wandering into a deep recursion path...
    $a = $a->numify() if ref($a) && $a->can('numify');

    if (defined $a)
      {
      # also croak on non-numerical
      if (!$a || $a <= 0)
        {
        require Carp;
        Carp::croak ('Argument to accuracy must be greater than zero');
        }
      if (int($a) != $a)
        {
        require Carp;
        Carp::croak ('Argument to accuracy must be an integer');
        }
      }
    if (ref($x))
      {
      # $object->accuracy() or fallback to global
      $x->bround($a) if $a;             # not for undef, 0
      $x->{_a} = $a;                    # set/overwrite, even if not rounded
      delete $x->{_p};                  # clear P
      $a = ${"${class}::accuracy"} unless defined $a;   # proper return value
      }
    else
      {
      ${"${class}::accuracy"} = $a;     # set global A
      ${"${class}::precision"} = undef; # clear global P
      }
    return $a;                          # shortcut
    }

  my $a;
  # $object->accuracy() or fallback to global
  $a = $x->{_a} if ref($x);
  # but don't return global undef, when $x's accuracy is 0!
  $a = ${"${class}::accuracy"} if !defined $a;
  $a;
  }

sub precision
  {
  # $x->precision($p);          ref($x) $p
  # $x->precision();            ref($x)
  # Class->precision();         class
  # Class->precision($p);       class $p

  my $x = shift;
  my $class = ref($x) || $x || __PACKAGE__;

  no strict 'refs';
  if (@@_ > 0)
    {
    my $p = shift;
    # convert objects to scalars to avoid deep recursion. If object doesn't
    # have numify(), then hopefully it will have overloading for int() and
    # boolean test without wandering into a deep recursion path...
    $p = $p->numify() if ref($p) && $p->can('numify');
    if ((defined $p) && (int($p) != $p))
      {
      require Carp; Carp::croak ('Argument to precision must be an integer');
      }
    if (ref($x))
      {
      # $object->precision() or fallback to global
      $x->bfround($p) if $p;            # not for undef, 0
      $x->{_p} = $p;                    # set/overwrite, even if not rounded
      delete $x->{_a};                  # clear A
      $p = ${"${class}::precision"} unless defined $p;  # proper return value
      }
    else
      {
      ${"${class}::precision"} = $p;    # set global P
      ${"${class}::accuracy"} = undef;  # clear global A
      }
    return $p;                          # shortcut
    }

  my $p;
  # $object->precision() or fallback to global
  $p = $x->{_p} if ref($x);
  # but don't return global undef, when $x's precision is 0!
  $p = ${"${class}::precision"} if !defined $p;
  $p;
  }

sub config
  {
  # return (or set) configuration data as hash ref
  my $class = shift || 'Math::BigInt';

  no strict 'refs';
  if (@@_ > 1 || (@@_ == 1 && (ref($_[0]) eq 'HASH')))
    {
    # try to set given options as arguments from hash

    my $args = $_[0];
    if (ref($args) ne 'HASH')
      {
      $args = { @@_ };
      }
    # these values can be "set"
    my $set_args = {};
    foreach my $key (
     qw/trap_inf trap_nan
        upgrade downgrade precision accuracy round_mode div_scale/
     )
      {
      $set_args->{$key} = $args->{$key} if exists $args->{$key};
      delete $args->{$key};
      }
    if (keys %$args > 0)
      {
      require Carp;
      Carp::croak ("Illegal key(s) '",
       join("','",keys %$args),"' passed to $class\->config()");
      }
    foreach my $key (keys %$set_args)
      {
      if ($key =~ /^trap_(inf|nan)\z/)
        {
        ${"${class}::_trap_$1"} = ($set_args->{"trap_$1"} ? 1 : 0);
        next;
        }
      # use a call instead of just setting the $variable to check argument
      $class->$key($set_args->{$key});
      }
    }

  # now return actual configuration

  my $cfg = {
    lib => $CALC,
    lib_version => ${"${CALC}::VERSION"},
    class => $class,
    trap_nan => ${"${class}::_trap_nan"},
    trap_inf => ${"${class}::_trap_inf"},
    version => ${"${class}::VERSION"},
    };
  foreach my $key (qw/
     upgrade downgrade precision accuracy round_mode div_scale
     /)
    {
    $cfg->{$key} = ${"${class}::$key"};
    };
  if (@@_ == 1 && (ref($_[0]) ne 'HASH'))
    {
    # calls of the style config('lib') return just this value
    return $cfg->{$_[0]};
    }
  $cfg;
  }

sub _scale_a
  {
  # select accuracy parameter based on precedence,
  # used by bround() and bfround(), may return undef for scale (means no op)
  my ($x,$scale,$mode) = @@_;

  $scale = $x->{_a} unless defined $scale;

  no strict 'refs';
  my $class = ref($x);

  $scale = ${ $class . '::accuracy' } unless defined $scale;
  $mode = ${ $class . '::round_mode' } unless defined $mode;

  if (defined $scale)
    {
    $scale = $scale->can('numify') ? $scale->numify()
                                   : "$scale" if ref($scale);
    $scale = int($scale);
    }

  ($scale,$mode);
  }

sub _scale_p
  {
  # select precision parameter based on precedence,
  # used by bround() and bfround(), may return undef for scale (means no op)
  my ($x,$scale,$mode) = @@_;

  $scale = $x->{_p} unless defined $scale;

  no strict 'refs';
  my $class = ref($x);

  $scale = ${ $class . '::precision' } unless defined $scale;
  $mode = ${ $class . '::round_mode' } unless defined $mode;

  if (defined $scale)
    {
    $scale = $scale->can('numify') ? $scale->numify()
                                   : "$scale" if ref($scale);
    $scale = int($scale);
    }

  ($scale,$mode);
  }

##############################################################################
# constructors

sub copy {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    # If called as a class method, the object to copy is the next argument.

    $self = shift() unless $selfref;

    my $copy = bless {}, $class;

    $copy->{sign}  = $self->{sign};
    $copy->{value} = $CALC->_copy($self->{value});
    $copy->{_a}    = $self->{_a} if exists $self->{_a};
    $copy->{_p}    = $self->{_p} if exists $self->{_p};

    return $copy;
}

sub new {
    # Create a new Math::BigInt object from a string or another Math::BigInt
    # object. See hash keys documented at top.

    # The argument could be an object, so avoid ||, && etc. on it. This would
    # cause costly overloaded code to be called. The only allowed ops are ref()
    # and defined.

    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    my ($wanted, $a, $p, $r) = @@_;

    # If called as a class method, initialize a new object.

    $self = bless {}, $class unless $selfref;

    unless (defined $wanted) {
        require Carp;
        Carp::carp("Use of uninitialized value in new");
        return $self->bzero($a, $p, $r);
    }

    if (ref($wanted) && $wanted->isa($class)) {         # MBI or subclass
        # Using "$copy = $wanted -> copy()" here fails some tests. Fixme!
        my $copy = $class -> copy($wanted);
        if ($selfref) {
            %$self = %$copy;
        } else {
            $self = $copy;
        }
        return $self;
    }

    $class->import() if $IMPORT == 0;           # make require work

    # Shortcut for non-zero scalar integers with no non-zero exponent.

    if (!ref($wanted) &&
        $wanted =~ / ^
                     ([+-]?)            # optional sign
                     ([1-9][0-9]*)      # non-zero significand
                     (\.0*)?            # ... with optional zero fraction
                     ([Ee][+-]?0+)?     # optional zero exponent
                     \z
                   /x)
    {
        my $sgn = $1;
        my $abs = $2;
        $self->{sign} = $sgn || '+';
        $self->{value} = $CALC->_new($abs);

        no strict 'refs';
        if (defined($a) || defined($p)
            || defined(${"${class}::precision"})
            || defined(${"${class}::accuracy"}))
        {
            $self->round($a, $p, $r)
              unless @@_ == 4 && !defined $a && !defined $p;
        }

        return $self;
    }

    # Handle Infs.

    if ($wanted =~ /^\s*([+-]?)inf(inity)?\s*\z/i) {
        my $sgn = $1 || '+';
        $self->{sign} = $sgn . 'inf';   # set a default sign for bstr()
        return $self->binf($sgn);
    }

    # Handle explicit NaNs (not the ones returned due to invalid input).

    if ($wanted =~ /^\s*([+-]?)nan\s*\z/i) {
        return $self->bnan();
    }

    if ($wanted =~ /^\s*[+-]?0[Xx]/) {
        return $class -> from_hex($wanted);
    }

    if ($wanted =~ /^\s*[+-]?0[Bb]/) {
        return $class -> from_bin($wanted);
    }

    # Split string into mantissa, exponent, integer, fraction, value, and sign.
    my ($mis, $miv, $mfv, $es, $ev) = _split($wanted);
    if (!ref $mis) {
        if ($_trap_nan) {
            require Carp; Carp::croak("$wanted is not a number in $class");
        }
        $self->{value} = $CALC->_zero();
        $self->{sign} = $nan;
        return $self;
    }

    if (!ref $miv) {
        # _from_hex or _from_bin
        $self->{value} = $mis->{value};
        $self->{sign} = $mis->{sign};
        return $self;   # throw away $mis
    }

    # Make integer from mantissa by adjusting exponent, then convert to a
    # Math::BigInt.
    $self->{sign} = $$mis;           # store sign
    $self->{value} = $CALC->_zero(); # for all the NaN cases
    my $e = int("$$es$$ev");         # exponent (avoid recursion)
    if ($e > 0) {
        my $diff = $e - CORE::length($$mfv);
        if ($diff < 0) {         # Not integer
            if ($_trap_nan) {
                require Carp; Carp::croak("$wanted not an integer in $class");
            }
            #print "NOI 1\n";
            return $upgrade->new($wanted, $a, $p, $r) if defined $upgrade;
            $self->{sign} = $nan;
        } else {                 # diff >= 0
            # adjust fraction and add it to value
            #print "diff > 0 $$miv\n";
            $$miv = $$miv . ($$mfv . '0' x $diff);
        }
    }

    else {
        if ($$mfv ne '') {       # e <= 0
            # fraction and negative/zero E => NOI
            if ($_trap_nan) {
                require Carp; Carp::croak("$wanted not an integer in $class");
            }
            #print "NOI 2 \$\$mfv '$$mfv'\n";
            return $upgrade->new($wanted, $a, $p, $r) if defined $upgrade;
            $self->{sign} = $nan;
        } elsif ($e < 0) {
            # xE-y, and empty mfv
            # Split the mantissa at the decimal point. E.g., if
            # $$miv = 12345 and $e = -2, then $frac = 45 and $$miv = 123.

            my $frac = substr($$miv, $e); # $frac is fraction part
            substr($$miv, $e) = "";       # $$miv is now integer part

            if ($frac =~ /[^0]/) {
                if ($_trap_nan) {
                    require Carp; Carp::croak("$wanted not an integer in $class");
                }
                #print "NOI 3\n";
                return $upgrade->new($wanted, $a, $p, $r) if defined $upgrade;
                $self->{sign} = $nan;
            }
        }
    }

    unless ($self->{sign} eq $nan) {
        $self->{sign} = '+' if $$miv eq '0';            # normalize -0 => +0
        $self->{value} = $CALC->_new($$miv) if $self->{sign} =~ /^[+-]$/;
    }

    # If any of the globals are set, use them to round, and store them inside
    # $self. Do not round for new($x, undef, undef) since that is used by MBF
    # to signal no rounding.

    $self->round($a, $p, $r) unless @@_ == 4 && !defined $a && !defined $p;
    $self;
}

sub bnan
  {
  # create a bigint 'NaN', if given a BigInt, set it to 'NaN'
  my $self = shift;
  $self = $class if !defined $self;
  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  no strict 'refs';
  if (${"${class}::_trap_nan"})
    {
    require Carp;
    Carp::croak ("Tried to set $self to NaN in $class\::bnan()");
    }
  $self->import() if $IMPORT == 0;              # make require work
  return if $self->modify('bnan');
  if ($self->can('_bnan'))
    {
    # use subclass to initialize
    $self->_bnan();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_zero();
    }
  $self->{sign} = $nan;
  delete $self->{_a}; delete $self->{_p};       # rounding NaN is silly
  $self;
  }

sub binf
  {
  # create a bigint '+-inf', if given a BigInt, set it to '+-inf'
  # the sign is either '+', or if given, used from there
  my $self = shift;
  my $sign = shift; $sign = '+' if !defined $sign || $sign !~ /^-(inf)?$/;
  $self = $class if !defined $self;
  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  no strict 'refs';
  if (${"${class}::_trap_inf"})
    {
    require Carp;
    Carp::croak ("Tried to set $self to +-inf in $class\::binf()");
    }
  $self->import() if $IMPORT == 0;              # make require work
  return if $self->modify('binf');
  if ($self->can('_binf'))
    {
    # use subclass to initialize
    $self->_binf();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_zero();
    }
  $sign = $sign . 'inf' if $sign !~ /inf$/;     # - => -inf
  $self->{sign} = $sign;
  ($self->{_a},$self->{_p}) = @@_;               # take over requested rounding
  $self;
  }

sub bzero
  {
  # create a bigint '+0', if given a BigInt, set it to 0
  my $self = shift;
  $self = __PACKAGE__ if !defined $self;

  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  $self->import() if $IMPORT == 0;              # make require work
  return if $self->modify('bzero');

  if ($self->can('_bzero'))
    {
    # use subclass to initialize
    $self->_bzero();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_zero();
    }
  $self->{sign} = '+';
  if (@@_ > 0)
    {
    if (@@_ > 3)
      {
      # call like: $x->bzero($a,$p,$r,$y);
      ($self,$self->{_a},$self->{_p}) = $self->_find_round_parameters(@@_);
      }
    else
      {
      $self->{_a} = $_[0]
       if ( (!defined $self->{_a}) || (defined $_[0] && $_[0] > $self->{_a}));
      $self->{_p} = $_[1]
       if ( (!defined $self->{_p}) || (defined $_[1] && $_[1] > $self->{_p}));
      }
    }
  $self;
  }

sub bone
  {
  # create a bigint '+1' (or -1 if given sign '-'),
  # if given a BigInt, set it to +1 or -1, respectively
  my $self = shift;
  my $sign = shift; $sign = '+' if !defined $sign || $sign ne '-';
  $self = $class if !defined $self;

  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  $self->import() if $IMPORT == 0;              # make require work
  return if $self->modify('bone');

  if ($self->can('_bone'))
    {
    # use subclass to initialize
    $self->_bone();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_one();
    }
  $self->{sign} = $sign;
  if (@@_ > 0)
    {
    if (@@_ > 3)
      {
      # call like: $x->bone($sign,$a,$p,$r,$y);
      ($self,$self->{_a},$self->{_p}) = $self->_find_round_parameters(@@_);
      }
    else
      {
      # call like: $x->bone($sign,$a,$p,$r);
      $self->{_a} = $_[0]
       if ( (!defined $self->{_a}) || (defined $_[0] && $_[0] > $self->{_a}));
      $self->{_p} = $_[1]
       if ( (!defined $self->{_p}) || (defined $_[1] && $_[1] > $self->{_p}));
      }
    }
  $self;
  }

##############################################################################
# string conversion

sub bsstr
  {
  # (ref to BFLOAT or num_str ) return num_str
  # Convert number from internal format to scientific string format.
  # internal format is always normalized (no leading zeros, "-0E0" => "+0E0")
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    return $x->{sign} unless $x->{sign} eq '+inf';      # -inf, NaN
    return 'inf';                                       # +inf
    }
  my ($m,$e) = $x->parts();
  #$m->bstr() . 'e+' . $e->bstr();      # e can only be positive in BigInt
  # 'e+' because E can only be positive in BigInt
  $m->bstr() . 'e+' . $CALC->_str($e->{value});
  }

sub bstr
  {
  # make a string from bigint object
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    return $x->{sign} unless $x->{sign} eq '+inf';      # -inf, NaN
    return 'inf';                                       # +inf
    }
  my $es = ''; $es = $x->{sign} if $x->{sign} eq '-';
  $es.$CALC->_str($x->{value});
  }

sub numify
  {
  # Make a Perl scalar number from a Math::BigInt object.
  my $x = shift; $x = $class->new($x) unless ref $x;

  if ($x -> is_nan()) {
      require Math::Complex;
      my $inf = Math::Complex::Inf();
      return $inf - $inf;
  }

  if ($x -> is_inf()) {
      require Math::Complex;
      my $inf = Math::Complex::Inf();
      return $x -> is_negative() ? -$inf : $inf;
  }

  my $num = 0 + $CALC->_num($x->{value});
  return $x->{sign} eq '-' ? -$num : $num;
  }

##############################################################################
# public stuff (usually prefixed with "b")

sub sign
  {
  # return the sign of the number: +/-/-inf/+inf/NaN
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  $x->{sign};
  }

sub _find_round_parameters {
    # After any operation or when calling round(), the result is rounded by
    # regarding the A & P from arguments, local parameters, or globals.

    # !!!!!!! If you change this, remember to change round(), too! !!!!!!!!!!

    # This procedure finds the round parameters, but it is for speed reasons
    # duplicated in round. Otherwise, it is tested by the testsuite and used
    # by bdiv().

    # returns ($self) or ($self,$a,$p,$r) - sets $self to NaN of both A and P
    # were requested/defined (locally or globally or both)

    my ($self, $a, $p, $r, @@args) = @@_;
    # $a accuracy, if given by caller
    # $p precision, if given by caller
    # $r round_mode, if given by caller
    # @@args all 'other' arguments (0 for unary, 1 for binary ops)

    my $class = ref($self);       # find out class of argument(s)
    no strict 'refs';

    # convert to normal scalar for speed and correctness in inner parts
    $a = $a->can('numify') ? $a->numify() : "$a" if defined $a && ref($a);
    $p = $p->can('numify') ? $p->numify() : "$p" if defined $p && ref($p);

    # now pick $a or $p, but only if we have got "arguments"
    if (!defined $a) {
        foreach ($self, @@args) {
            # take the defined one, or if both defined, the one that is smaller
            $a = $_->{_a} if (defined $_->{_a}) && (!defined $a || $_->{_a} < $a);
        }
    }
    if (!defined $p) {
        # even if $a is defined, take $p, to signal error for both defined
        foreach ($self, @@args) {
            # take the defined one, or if both defined, the one that is bigger
            # -2 > -3, and 3 > 2
            $p = $_->{_p} if (defined $_->{_p}) && (!defined $p || $_->{_p} > $p);
        }
    }

    # if still none defined, use globals (#2)
    $a = ${"$class\::accuracy"}  unless defined $a;
    $p = ${"$class\::precision"} unless defined $p;

    # A == 0 is useless, so undef it to signal no rounding
    $a = undef if defined $a && $a == 0;

    # no rounding today?
    return ($self) unless defined $a || defined $p; # early out

    # set A and set P is an fatal error
    return ($self->bnan()) if defined $a && defined $p; # error

    $r = ${"$class\::round_mode"} unless defined $r;
    if ($r !~ /^(even|odd|[+-]inf|zero|trunc|common)$/) {
        require Carp; Carp::croak ("Unknown round mode '$r'");
    }

    $a = int($a) if defined $a;
    $p = int($p) if defined $p;

    ($self, $a, $p, $r);
}

sub round {
    # Round $self according to given parameters, or given second argument's
    # parameters or global defaults

    # for speed reasons, _find_round_parameters is embedded here:

    my ($self, $a, $p, $r, @@args) = @@_;
    # $a accuracy, if given by caller
    # $p precision, if given by caller
    # $r round_mode, if given by caller
    # @@args all 'other' arguments (0 for unary, 1 for binary ops)

    my $class = ref($self);       # find out class of argument(s)
    no strict 'refs';

    # now pick $a or $p, but only if we have got "arguments"
    if (!defined $a) {
        foreach ($self, @@args) {
            # take the defined one, or if both defined, the one that is smaller
            $a = $_->{_a} if (defined $_->{_a}) && (!defined $a || $_->{_a} < $a);
        }
    }
    if (!defined $p) {
        # even if $a is defined, take $p, to signal error for both defined
        foreach ($self, @@args) {
            # take the defined one, or if both defined, the one that is bigger
            # -2 > -3, and 3 > 2
            $p = $_->{_p} if (defined $_->{_p}) && (!defined $p || $_->{_p} > $p);
        }
    }

    # if still none defined, use globals (#2)
    $a = ${"$class\::accuracy"}  unless defined $a;
    $p = ${"$class\::precision"} unless defined $p;

    # A == 0 is useless, so undef it to signal no rounding
    $a = undef if defined $a && $a == 0;

    # no rounding today?
    return $self unless defined $a || defined $p; # early out

    # set A and set P is an fatal error
    return $self->bnan() if defined $a && defined $p;

    $r = ${"$class\::round_mode"} unless defined $r;
    if ($r !~ /^(even|odd|[+-]inf|zero|trunc|common)$/) {
        require Carp; Carp::croak ("Unknown round mode '$r'");
    }

    # now round, by calling either bround or bfround:
    if (defined $a) {
        $self->bround(int($a), $r) if !defined $self->{_a} || $self->{_a} >= $a;
    } else {                  # both can't be undefined due to early out
        $self->bfround(int($p), $r) if !defined $self->{_p} || $self->{_p} <= $p;
    }

    # bround() or bfround() already called bnorm() if nec.
    $self;
}

sub bnorm
  {
  # (numstr or BINT) return BINT
  # Normalize number -- no-op here
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
  $x;
  }

sub babs
  {
  # (BINT or num_str) return BINT
  # make number absolute, or return absolute BINT from string
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return $x if $x->modify('babs');
  # post-normalized abs for internal use (does nothing for NaN)
  $x->{sign} =~ s/^-/+/;
  $x;
  }

sub bsgn {
    # Signum function.

    my $self = shift;

    return $self if $self->modify('bsgn');

    return $self -> bone("+") if $self -> is_pos();
    return $self -> bone("-") if $self -> is_neg();
    return $self;               # zero or NaN
}

sub bneg
  {
  # (BINT or num_str) return BINT
  # negate number or make a negated number from string
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return $x if $x->modify('bneg');

  # for +0 do not negate (to have always normalized +0). Does nothing for 'NaN'
  $x->{sign} =~ tr/+-/-+/ unless ($x->{sign} eq '+' && $CALC->_is_zero($x->{value}));
  $x;
  }

sub bcmp
  {
  # Compares 2 values.  Returns one of undef, <0, =0, >0. (suitable for sort)
  # (BINT or num_str, BINT or num_str) return cond_code

  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@@_);
    }

  return $upgrade->bcmp($x,$y) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # handle +-inf and NaN
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if $x->{sign} eq $y->{sign} && $x->{sign} =~ /^[+-]inf$/;
    return +1 if $x->{sign} eq '+inf';
    return -1 if $x->{sign} eq '-inf';
    return -1 if $y->{sign} eq '+inf';
    return +1;
    }
  # check sign for speed first
  return 1 if $x->{sign} eq '+' && $y->{sign} eq '-';   # does also 0 <=> -y
  return -1 if $x->{sign} eq '-' && $y->{sign} eq '+';  # does also -x <=> 0

  # have same sign, so compare absolute values.  Don't make tests for zero
  # here because it's actually slower than testing in Calc (especially w/ Pari
  # et al)

  # post-normalized compare for internal use (honors signs)
  if ($x->{sign} eq '+')
    {
    # $x and $y both > 0
    return $CALC->_acmp($x->{value},$y->{value});
    }

  # $x && $y both < 0
  $CALC->_acmp($y->{value},$x->{value});        # swapped acmp (lib returns 0,1,-1)
  }

sub bacmp
  {
  # Compares 2 values, ignoring their signs.
  # Returns one of undef, <0, =0, >0. (suitable for sort)
  # (BINT, BINT) return cond_code

  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@@_);
    }

  return $upgrade->bacmp($x,$y) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # handle +-inf and NaN
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} =~ /^[+-]inf$/;
    return 1 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} !~ /^[+-]inf$/;
    return -1;
    }
  $CALC->_acmp($x->{value},$y->{value});        # lib does only 0,1,-1
  }

sub badd
  {
  # add second arg (BINT or string) to first (BINT) (modifies first)
  # return result as BINT

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('badd');
  return $upgrade->badd($upgrade->new($x),$upgrade->new($y),@@r) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  $r[3] = $y;                           # no push!
  # inf and NaN handling
  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # NaN first
    return $x->bnan() if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    # inf handling
    if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))
      {
      # +inf++inf or -inf+-inf => same, rest is NaN
      return $x if $x->{sign} eq $y->{sign};
      return $x->bnan();
      }
    # +-inf + something => +inf
    # something +-inf => +-inf
    $x->{sign} = $y->{sign}, return $x if $y->{sign} =~ /^[+-]inf$/;
    return $x;
    }

  my ($sx, $sy) = ( $x->{sign}, $y->{sign} );           # get signs

  if ($sx eq $sy)
    {
    $x->{value} = $CALC->_add($x->{value},$y->{value}); # same sign, abs add
    }
  else
    {
    my $a = $CALC->_acmp ($y->{value},$x->{value});     # absolute compare
    if ($a > 0)
      {
      $x->{value} = $CALC->_sub($y->{value},$x->{value},1); # abs sub w/ swap
      $x->{sign} = $sy;
      }
    elsif ($a == 0)
      {
      # speedup, if equal, set result to 0
      $x->{value} = $CALC->_zero();
      $x->{sign} = '+';
      }
    else # a < 0
      {
      $x->{value} = $CALC->_sub($x->{value}, $y->{value}); # abs sub
      }
    }
  $x->round(@@r);
  }

sub bsub
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # subtract second arg from first, modify first

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bsub');

  return $upgrade->new($x)->bsub($upgrade->new($y),@@r) if defined $upgrade &&
   ((!$x->isa($self)) || (!$y->isa($self)));

  return $x->round(@@r) if $y->is_zero();

  # To correctly handle the lone special case $x->bsub($x), we note the sign
  # of $x, then flip the sign from $y, and if the sign of $x did change, too,
  # then we caught the special case:
  my $xsign = $x->{sign};
  $y->{sign} =~ tr/+\-/-+/;     # does nothing for NaN
  if ($xsign ne $x->{sign})
    {
    # special case of $x->bsub($x) results in 0
    return $x->bzero(@@r) if $xsign =~ /^[+-]$/;
    return $x->bnan();          # NaN, -inf, +inf
    }
  $x->badd($y,@@r);              # badd does not leave internal zeros
  $y->{sign} =~ tr/+\-/-+/;     # refix $y (does nothing for NaN)
  $x;                           # already rounded by badd() or no round nec.
  }

sub binc
  {
  # increment arg by one
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
  return $x if $x->modify('binc');

  if ($x->{sign} eq '+')
    {
    $x->{value} = $CALC->_inc($x->{value});
    return $x->round($a,$p,$r);
    }
  elsif ($x->{sign} eq '-')
    {
    $x->{value} = $CALC->_dec($x->{value});
    $x->{sign} = '+' if $CALC->_is_zero($x->{value}); # -1 +1 => -0 => +0
    return $x->round($a,$p,$r);
    }
  # inf, nan handling etc
  $x->badd($self->bone(),$a,$p,$r);             # badd does round
  }

sub bdec
  {
  # decrement arg by one
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
  return $x if $x->modify('bdec');

  if ($x->{sign} eq '-')
    {
    # x already < 0
    $x->{value} = $CALC->_inc($x->{value});
    }
  else
    {
    return $x->badd($self->bone('-'),@@r)
        unless $x->{sign} eq '+'; # inf or NaN
    # >= 0
    if ($CALC->_is_zero($x->{value}))
      {
      # == 0
      $x->{value} = $CALC->_one(); $x->{sign} = '-';            # 0 => -1
      }
    else
      {
      # > 0
      $x->{value} = $CALC->_dec($x->{value});
      }
    }
  $x->round(@@r);
  }

sub blog
  {
  # Return the logarithm of the operand. If a second operand is defined, that
  # value is used as the base, otherwise the base is assumed to be Euler's
  # constant.

  # Don't objectify the base, since an undefined base, as in $x->blog() or
  # $x->blog(undef) signals that the base is Euler's number.

  # set up parameters
  my ($self,$x,$base,@@r) = (undef,@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1]))) {
      ($self,$x,$base,@@r) = objectify(1,@@_);
  }

  return $x if $x->modify('blog');

  # Handle all exception cases and all trivial cases. I have used Wolfram Alpha
  # (http://www.wolframalpha.com) as the reference for these cases.

  return $x -> bnan() if $x -> is_nan();

  if (defined $base) {
      $base = $self -> new($base) unless ref $base;
      if ($base -> is_nan() || $base -> is_one()) {
          return $x -> bnan();
      } elsif ($base -> is_inf() || $base -> is_zero()) {
          return $x -> bnan() if $x -> is_inf() || $x -> is_zero();
          return $x -> bzero();
      } elsif ($base -> is_negative()) {            # -inf < base < 0
          return $x -> bzero() if $x -> is_one();   #     x = 1
          return $x -> bone()  if $x == $base;      #     x = base
          return $x -> bnan();                      #     otherwise
      }
      return $x -> bone() if $x == $base;           # 0 < base && 0 < x < inf
  }

  # We now know that the base is either undefined or >= 2 and finite.

  return $x -> binf('+') if $x -> is_inf();         #   x = +/-inf
  return $x -> bnan()    if $x -> is_neg();         #   -inf < x < 0
  return $x -> bzero()   if $x -> is_one();         #   x = 1
  return $x -> binf('-') if $x -> is_zero();        #   x = 0

  # At this point we are done handling all exception cases and trivial cases.

  return $upgrade -> blog($upgrade -> new($x), $base, @@r) if defined $upgrade;

  # fix for bug #24969:
  # the default base is e (Euler's number) which is not an integer
  if (!defined $base)
    {
    require Math::BigFloat;
    my $u = Math::BigFloat->blog(Math::BigFloat->new($x))->as_int();
    # modify $x in place
    $x->{value} = $u->{value};
    $x->{sign} = $u->{sign};
    return $x;
    }

  my ($rc,$exact) = $CALC->_log_int($x->{value},$base->{value});
  return $x->bnan() unless defined $rc;         # not possible to take log?
  $x->{value} = $rc;
  $x->round(@@r);
  }

sub bnok
  {
  # Calculate n over k (binomial coefficient or "choose" function) as integer.
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bnok');
  return $x->bnan() if $x->{sign} eq 'NaN' || $y->{sign} eq 'NaN';
  return $x->binf() if $x->{sign} eq '+inf';

  # k > n or k < 0 => 0
  my $cmp = $x->bacmp($y);
  return $x->bzero() if $cmp < 0 || $y->{sign} =~ /^-/;
  # k == n => 1
  return $x->bone(@@r) if $cmp == 0;

  if ($CALC->can('_nok'))
    {
    $x->{value} = $CALC->_nok($x->{value},$y->{value});
    }
  else
    {
    # ( 7 )       7!       1*2*3*4 * 5*6*7   5 * 6 * 7       6   7
    # ( - ) = --------- =  --------------- = --------- = 5 * - * -
    # ( 3 )   (7-3)! 3!    1*2*3*4 * 1*2*3   1 * 2 * 3       2   3

    if (!$y->is_zero())
      {
      my $z = $x - $y;
      $z->binc();
      my $r = $z->copy(); $z->binc();
      my $d = $self->new(2);
      while ($z->bacmp($x) <= 0)                # f <= x ?
        {
        $r->bmul($z); $r->bdiv($d);
        $z->binc(); $d->binc();
        }
      $x->{value} = $r->{value}; $x->{sign} = '+';
      }
    else { $x->bone(); }
    }
  $x->round(@@r);
  }

sub bexp
  {
  # Calculate e ** $x (Euler's number to the power of X), truncated to
  # an integer value.
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
  return $x if $x->modify('bexp');

  # inf, -inf, NaN, <0 => NaN
  return $x->bnan() if $x->{sign} eq 'NaN';
  return $x->bone() if $x->is_zero();
  return $x if $x->{sign} eq '+inf';
  return $x->bzero() if $x->{sign} eq '-inf';

  my $u;
  {
    # run through Math::BigFloat unless told otherwise
    require Math::BigFloat unless defined $upgrade;
    local $upgrade = 'Math::BigFloat' unless defined $upgrade;
    # calculate result, truncate it to integer
    $u = $upgrade->bexp($upgrade->new($x),@@r);
  }

  if (!defined $upgrade)
    {
    $u = $u->as_int();
    # modify $x in place
    $x->{value} = $u->{value};
    $x->round(@@r);
    }
  else { $x = $u; }
  }

sub blcm
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # does not modify arguments, but returns new object
  # Lowest Common Multiple

  my $y = shift; my ($x);
  if (ref($y))
    {
    $x = $y->copy();
    }
  else
    {
    $x = $class->new($y);
    }
  my $self = ref($x);
  while (@@_)
    {
    my $y = shift; $y = $self->new($y) if !ref ($y);
    $x = __lcm($x,$y);
    }
  $x;
  }

sub bgcd
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # does not modify arguments, but returns new object
  # GCD -- Euclid's algorithm, variant C (Knuth Vol 3, pg 341 ff)

  my $y = shift;
  $y = $class->new($y) if !ref($y);
  my $self = ref($y);
  my $x = $y->copy()->babs();                   # keep arguments
  return $x->bnan() if $x->{sign} !~ /^[+-]$/;  # x NaN?

  while (@@_)
    {
    $y = shift; $y = $self->new($y) if !ref($y);
    return $x->bnan() if $y->{sign} !~ /^[+-]$/;        # y NaN?
    $x->{value} = $CALC->_gcd($x->{value},$y->{value});
    last if $CALC->_is_one($x->{value});
    }
  $x;
  }

sub bnot
  {
  # (num_str or BINT) return BINT
  # represent ~x as twos-complement number
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  return $x if $x->modify('bnot');
  $x->binc()->bneg();                   # binc already does round
  }

##############################################################################
# is_foo test routines
# we don't need $self, so undef instead of ref($_[0]) make it slightly faster

sub is_zero
  {
  # return true if arg (BINT or num_str) is zero (array '+', '0')
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return 0 if $x->{sign} !~ /^\+$/;                     # -, NaN & +-inf aren't
  $CALC->_is_zero($x->{value});
  }

sub is_nan
  {
  # return true if arg (BINT or num_str) is NaN
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  $x->{sign} eq $nan ? 1 : 0;
  }

sub is_inf
  {
  # return true if arg (BINT or num_str) is +-inf
  my ($self,$x,$sign) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  if (defined $sign)
    {
    $sign = '[+-]inf' if $sign eq '';   # +- doesn't matter, only that's inf
    $sign = "[$1]inf" if $sign =~ /^([+-])(inf)?$/;     # extract '+' or '-'
    return $x->{sign} =~ /^$sign$/ ? 1 : 0;
    }
  $x->{sign} =~ /^[+-]inf$/ ? 1 : 0;            # only +-inf is infinity
  }

sub is_one
  {
  # return true if arg (BINT or num_str) is +1, or -1 if sign is given
  my ($self,$x,$sign) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  $sign = '+' if !defined $sign || $sign ne '-';

  return 0 if $x->{sign} ne $sign;      # -1 != +1, NaN, +-inf aren't either
  $CALC->_is_one($x->{value});
  }

sub is_odd
  {
  # return true when arg (BINT or num_str) is odd, false for even
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return 0 if $x->{sign} !~ /^[+-]$/;                   # NaN & +-inf aren't
  $CALC->_is_odd($x->{value});
  }

sub is_even
  {
  # return true when arg (BINT or num_str) is even, false for odd
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return 0 if $x->{sign} !~ /^[+-]$/;                   # NaN & +-inf aren't
  $CALC->_is_even($x->{value});
  }

sub is_positive
  {
  # return true when arg (BINT or num_str) is positive (> 0)
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return 1 if $x->{sign} eq '+inf';                     # +inf is positive

  # 0+ is neither positive nor negative
  ($x->{sign} eq '+' && !$x->is_zero()) ? 1 : 0;
  }

sub is_negative
  {
  # return true when arg (BINT or num_str) is negative (< 0)
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  $x->{sign} =~ /^-/ ? 1 : 0;           # -inf is negative, but NaN is not
  }

sub is_int
  {
  # return true when arg (BINT or num_str) is an integer
  # always true for BigInt, but different for BigFloats
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  $x->{sign} =~ /^[+-]$/ ? 1 : 0;               # inf/-inf/NaN aren't
  }

###############################################################################

sub bmul
  {
  # multiply the first number by the second number
  # (BINT or num_str, BINT or num_str) return BINT

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bmul');

  return $x->bnan() if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero();
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/);
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/);
    return $x->binf('-');
    }

  return $upgrade->bmul($x,$upgrade->new($y),@@r)
   if defined $upgrade && !$y->isa($self);

  $r[3] = $y;                           # no push here

  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-'; # +1 * +1 or -1 * -1 => +

  $x->{value} = $CALC->_mul($x->{value},$y->{value});   # do actual math
  $x->{sign} = '+' if $CALC->_is_zero($x->{value});     # no -0

  $x->round(@@r);
  }

sub bmuladd
  {
  # multiply two numbers and then add the third to the result
  # (BINT or num_str, BINT or num_str, BINT or num_str) return BINT

  # set up parameters
  my ($self,$x,$y,$z,@@r) = objectify(3,@@_);

  return $x if $x->modify('bmuladd');

  return $x->bnan() if  ($x->{sign} eq $nan) ||
                        ($y->{sign} eq $nan) ||
                        ($z->{sign} eq $nan);

  # inf handling of x and y
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero();
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/);
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/);
    return $x->binf('-');
    }
  # inf handling x*y and z
  if (($z->{sign} =~ /^[+-]inf$/))
    {
    # something +-inf => +-inf
    $x->{sign} = $z->{sign}, return $x if $z->{sign} =~ /^[+-]inf$/;
    }

  return $upgrade->bmuladd($x,$upgrade->new($y),$upgrade->new($z),@@r)
   if defined $upgrade && (!$y->isa($self) || !$z->isa($self) || !$x->isa($self));

  # TODO: what if $y and $z have A or P set?
  $r[3] = $z;                           # no push here

  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-'; # +1 * +1 or -1 * -1 => +

  $x->{value} = $CALC->_mul($x->{value},$y->{value});   # do actual math
  $x->{sign} = '+' if $CALC->_is_zero($x->{value});     # no -0

  my ($sx, $sz) = ( $x->{sign}, $z->{sign} );           # get signs

  if ($sx eq $sz)
    {
    $x->{value} = $CALC->_add($x->{value},$z->{value}); # same sign, abs add
    }
  else
    {
    my $a = $CALC->_acmp ($z->{value},$x->{value});     # absolute compare
    if ($a > 0)
      {
      $x->{value} = $CALC->_sub($z->{value},$x->{value},1); # abs sub w/ swap
      $x->{sign} = $sz;
      }
    elsif ($a == 0)
      {
      # speedup, if equal, set result to 0
      $x->{value} = $CALC->_zero();
      $x->{sign} = '+';
      }
    else # a < 0
      {
      $x->{value} = $CALC->_sub($x->{value}, $z->{value}); # abs sub
      }
    }
  $x->round(@@r);
  }

sub bdiv
  {

    # This does floored division, where the quotient is floored toward negative
    # infinity and the remainder has the same sign as the divisor.

    # Set up parameters.
    my ($self,$x,$y,@@r) = (ref($_[0]),@@_);

    # objectify() is costly, so avoid it if we can.
    if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1]))) {
        ($self,$x,$y,@@r) = objectify(2,@@_);
    }

    return $x if $x->modify('bdiv');

    my $wantarray = wantarray;          # call only once

    # At least one argument is NaN. Return NaN for both quotient and the
    # modulo/remainder.

    if ($x -> is_nan() || $y -> is_nan()) {
        return $wantarray ? ($x -> bnan(), $self -> bnan()) : $x -> bnan();
    }

    # Divide by zero and modulo zero.
    #
    # Division: Use the common convention that x / 0 is inf with the same sign
    # as x, except when x = 0, where we return NaN. This is also what earlier
    # versions did.
    #
    # Modulo: In modular arithmetic, the congruence relation z = x (mod y)
    # means that there is some integer k such that z - x = k y. If y = 0, we
    # get z - x = 0 or z = x. This is also what earlier versions did, except
    # that 0 % 0 returned NaN.
    #
    #     inf / 0 =  inf                     inf % 0 =  inf
    #       5 / 0 =  inf                       5 % 0 =    5
    #       0 / 0 =  NaN                       0 % 0 =    0 (before: NaN)
    #      -5 / 0 = -inf                      -5 % 0 =   -5
    #    -inf / 0 = -inf                    -inf % 0 = -inf

    if ($y -> is_zero()) {
        my ($quo, $rem);
        if ($wantarray) {
                $rem = $x -> copy();
            }
        if ($x -> is_zero()) {
            $quo = $x -> bnan();
        } else {
            $quo = $x -> binf($x -> {sign});
        }
        return $wantarray ? ($quo, $rem) : $quo;
    }

    # Numerator (dividend) is +/-inf, and denominator is finite and non-zero.
    # The divide by zero cases are covered above. In all of the cases listed
    # below we return the same as core Perl.
    #
    #     inf / -inf =  NaN                  inf % -inf =  NaN
    #     inf /   -5 = -inf                  inf %   -5 =  NaN (before: 0)
    #     inf /    5 =  inf                  inf %    5 =  NaN (before: 0)
    #     inf /  inf =  NaN                  inf %  inf =  NaN
    #
    #    -inf / -inf =  NaN                 -inf % -inf =  NaN
    #    -inf /   -5 =  inf                 -inf %   -5 =  NaN (before: 0)
    #    -inf /    5 = -inf                 -inf %    5 =  NaN (before: 0)
    #    -inf /  inf =  NaN                 -inf %  inf =  NaN

    if ($x -> is_inf()) {
        my ($quo, $rem);
        $rem = $self -> bnan() if $wantarray;
        if ($y -> is_inf()) {
            $quo = $x -> bnan();
        } else {
            my $sign = $x -> bcmp(0) == $y -> bcmp(0) ? '+' : '-';
            $quo = $x -> binf($sign);
      }
        return $wantarray ? ($quo, $rem) : $quo;
    }

    # Denominator (divisor) is +/-inf. The cases when the numerator is +/-inf
    # are covered above. In the modulo cases (in the right column) we return
    # the same as core Perl, which does floored division, so for consistency we
    # also do floored division in the division cases (in the left column).
    #
    #      -5 /  inf =   -1 (before: 0)       -5 %  inf =  inf (before: -5)
    #       0 /  inf =    0                    0 %  inf =    0
    #       5 /  inf =    0                    5 %  inf =    5
    #
    #      -5 / -inf =    0                   -5 % -inf =   -5
    #       0 / -inf =    0                    0 % -inf =    0
    #       5 / -inf =   -1 (before: 0)        5 % -inf = -inf (before: 5)

    if ($y -> is_inf()) {
        my ($quo, $rem);
        if ($x -> is_zero() || $x -> bcmp(0) == $y -> bcmp(0)) {
            $rem = $x -> copy() if $wantarray;
            $quo = $x -> bzero();
        } else {
            $rem = $self -> binf($y -> {sign}) if $wantarray;
            $quo = $x -> bone('-');
        }
        return $wantarray ? ($quo, $rem) : $quo;
  }

  # At this point, both the numerator and denominator are finite numbers, and
  # the denominator (divisor) is non-zero.

  return $upgrade->bdiv($upgrade->new($x),$upgrade->new($y),@@r)
   if defined $upgrade;

  $r[3] = $y;                                   # no push!

    # Inialize remainder.

    my $rem = $self->bzero();

    # Are both operands the same object, i.e., like $x -> bdiv($x)?
    # If so, flipping the sign of $y also flips the sign of $x.

    my $xsign = $x->{sign};
    my $ysign = $y->{sign};

    $y->{sign} =~ tr/+-/-+/;            # Flip the sign of $y, and see ...
    my $same = $xsign ne $x->{sign};    # ... if that changed the sign of $x.
    $y->{sign} = $ysign;                # Re-insert the original sign.

    if ($same) {
        $x -> bone();
    } else {
    ($x->{value},$rem->{value}) = $CALC->_div($x->{value},$y->{value});

        if ($CALC -> _is_zero($rem->{value})) {
            if ($xsign eq $ysign || $CALC -> _is_zero($x->{value})) {
                $x->{sign} = '+';
            } else {
                $x->{sign} = '-';
            }
        } else {
            if ($xsign eq $ysign) {
                $x->{sign} = '+';
            } else {
                if ($xsign eq '+') {
                    $x -> badd(1);
                } else {
                    $x -> bsub(1);
                }
                $x->{sign} = '-';
            }
        }
    }

    $x->round(@@r);

    if ($wantarray) {
        unless ($CALC -> _is_zero($rem->{value})) {
            if ($xsign ne $ysign) {
                $rem = $y -> copy() -> babs() -> bsub($rem);
      }
            $rem->{sign} = $ysign;
      }
        $rem->{_a} = $x->{_a};
        $rem->{_p} = $x->{_p};
    $rem->round(@@r);
    return ($x,$rem);
    }

    return $x;
  }

###############################################################################
# modulus functions

sub bmod
  {

    # This is the remainder after floored division, where the quotient is
    # floored toward negative infinity and the remainder has the same sign as
    # the divisor.

    # Set up parameters.
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bmod');
  $r[3] = $y;                                   # no push!

    # At least one argument is NaN.

    if ($x -> is_nan() || $y -> is_nan()) {
        return $x -> bnan();
    }

    # Modulo zero. See documentation for bdiv().

    if ($y -> is_zero()) {
            return $x;
        }

    # Numerator (dividend) is +/-inf.

    if ($x -> is_inf()) {
        return $x -> bnan();
    }

    # Denominator (divisor) is +/-inf.

    if ($y -> is_inf()) {
        if ($x -> is_zero() || $x -> bcmp(0) == $y -> bcmp(0)) {
            return $x;
        } else {
            return $x -> binf($y -> sign());
        }
    }

    # Calc new sign and in case $y == +/- 1, return $x.

  $x->{value} = $CALC->_mod($x->{value},$y->{value});
  if ($CALC -> _is_zero($x->{value}))
    {
        $x->{sign} = '+';       # do not leave -0
    }
  else
    {
    $x->{value} = $CALC->_sub($y->{value},$x->{value},1)        # $y-$x
      if ($x->{sign} ne $y->{sign});
    $x->{sign} = $y->{sign};
    }

  $x->round(@@r);
  }

sub bmodinv
  {
  # Return modular multiplicative inverse:
  #
  #   z is the modular inverse of x (mod y) if and only if
  #
  #       x*z ≡ 1  (mod y)
  #
  # If the modulus y is larger than one, x and z are relative primes (i.e.,
  # their greatest common divisor is one).
  #
  # If no modular multiplicative inverse exists, NaN is returned.

  # set up parameters
  my ($self,$x,$y,@@r) = (undef,@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bmodinv');

  # Return NaN if one or both arguments is +inf, -inf, or nan.

  return $x->bnan() if ($y->{sign} !~ /^[+-]$/ ||
                        $x->{sign} !~ /^[+-]$/);

  # Return NaN if $y is zero; 1 % 0 makes no sense.

  return $x->bnan() if $y->is_zero();

  # Return 0 in the trivial case. $x % 1 or $x % -1 is zero for all finite
  # integers $x.

  return $x->bzero() if ($y->is_one() ||
                         $y->is_one('-'));

  # Return NaN if $x = 0, or $x modulo $y is zero. The only valid case when
  # $x = 0 is when $y = 1 or $y = -1, but that was covered above.
  #
  # Note that computing $x modulo $y here affects the value we'll feed to
  # $CALC->_modinv() below when $x and $y have opposite signs. E.g., if $x =
  # 5 and $y = 7, those two values are fed to _modinv(), but if $x = -5 and
  # $y = 7, the values fed to _modinv() are $x = 2 (= -5 % 7) and $y = 7.
  # The value if $x is affected only when $x and $y have opposite signs.

  $x->bmod($y);
  return $x->bnan() if $x->is_zero();

  # Compute the modular multiplicative inverse of the absolute values. We'll
  # correct for the signs of $x and $y later. Return NaN if no GCD is found.

  ($x->{value}, $x->{sign}) = $CALC->_modinv($x->{value}, $y->{value});
  return $x->bnan() if !defined $x->{value};

  # Library inconsistency workaround: _modinv() in Math::BigInt::GMP versions
  # <= 1.32 return undef rather than a "+" for the sign.

  $x->{sign} = '+' unless defined $x->{sign};

  # When one or both arguments are negative, we have the following
  # relations.  If x and y are positive:
  #
  #   modinv(-x, -y) = -modinv(x, y)
  #   modinv(-x,  y) = y - modinv(x, y)  = -modinv(x, y) (mod y)
  #   modinv( x, -y) = modinv(x, y) - y  =  modinv(x, y) (mod -y)

  # We must swap the sign of the result if the original $x is negative.
  # However, we must compensate for ignoring the signs when computing the
  # inverse modulo. The net effect is that we must swap the sign of the
  # result if $y is negative.

  $x -> bneg() if $y->{sign} eq '-';

  # Compute $x modulo $y again after correcting the sign.

  $x -> bmod($y) if $x->{sign} ne $y->{sign};

  return $x;
  }

sub bmodpow
  {
  # Modular exponentiation. Raises a very large number to a very large exponent
  # in a given very large modulus quickly, thanks to binary exponentiation.
  # Supports negative exponents.
  my ($self,$num,$exp,$mod,@@r) = objectify(3,@@_);

  return $num if $num->modify('bmodpow');

  # When the exponent 'e' is negative, use the following relation, which is
  # based on finding the multiplicative inverse 'd' of 'b' modulo 'm':
  #
  #    b^(-e) (mod m) = d^e (mod m) where b*d = 1 (mod m)

  $num->bmodinv($mod) if ($exp->{sign} eq '-');

  # Check for valid input. All operands must be finite, and the modulus must be
  # non-zero.

  return $num->bnan() if ($num->{sign} =~ /NaN|inf/ ||  # NaN, -inf, +inf
                          $exp->{sign} =~ /NaN|inf/ ||  # NaN, -inf, +inf
                          $mod->{sign} =~ /NaN|inf/);   # NaN, -inf, +inf

  # Modulo zero. See documentation for Math::BigInt's bmod() method.

  if ($mod -> is_zero()) {
      if ($num -> is_zero()) {
          return $self -> bnan();
      } else {
          return $num -> copy();
      }
  }

  # Compute 'a (mod m)', ignoring the signs on 'a' and 'm'. If the resulting
  # value is zero, the output is also zero, regardless of the signs on 'a' and
  # 'm'.

  my $value = $CALC->_modpow($num->{value}, $exp->{value}, $mod->{value});
  my $sign  = '+';

  # If the resulting value is non-zero, we have four special cases, depending
  # on the signs on 'a' and 'm'.

  unless ($CALC->_is_zero($value)) {

      # There is a negative sign on 'a' (= $num**$exp) only if the number we
      # are exponentiating ($num) is negative and the exponent ($exp) is odd.

      if ($num->{sign} eq '-' && $exp->is_odd()) {

          # When both the number 'a' and the modulus 'm' have a negative sign,
          # use this relation:
          #
          #    -a (mod -m) = -(a (mod m))

          if ($mod->{sign} eq '-') {
              $sign = '-';
          }

          # When only the number 'a' has a negative sign, use this relation:
          #
          #    -a (mod m) = m - (a (mod m))

          else {
              # Use copy of $mod since _sub() modifies the first argument.
              my $mod = $CALC->_copy($mod->{value});
              $value = $CALC->_sub($mod, $value);
              $sign  = '+';
          }

      } else {

          # When only the modulus 'm' has a negative sign, use this relation:
          #
          #    a (mod -m) = (a (mod m)) - m
          #               = -(m - (a (mod m)))

          if ($mod->{sign} eq '-') {
              # Use copy of $mod since _sub() modifies the first argument.
              my $mod = $CALC->_copy($mod->{value});
              $value = $CALC->_sub($mod, $value);
              $sign  = '-';
          }

          # When neither the number 'a' nor the modulus 'm' have a negative
          # sign, directly return the already computed value.
          #
          #    (a (mod m))

      }

  }

  $num->{value} = $value;
  $num->{sign}  = $sign;

  return $num;
  }

###############################################################################

sub bfac
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute factorial number from $x, modify $x in place
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  return $x if $x->modify('bfac') || $x->{sign} eq '+inf';      # inf => inf
  return $x->bnan() if $x->{sign} ne '+';                       # NaN, <0 etc => NaN

  $x->{value} = $CALC->_fac($x->{value});
  $x->round(@@r);
  }

sub bpow
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute power of two numbers -- stolen from Knuth Vol 2 pg 233
  # modifies first argument

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bpow');

  return $x->bnan() if $x->{sign} eq $nan || $y->{sign} eq $nan;

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))
      {
      # +-inf ** +-inf
      return $x->bnan();
      }
    # +-inf ** Y
    if ($x->{sign} =~ /^[+-]inf/)
      {
      # +inf ** 0 => NaN
      return $x->bnan() if $y->is_zero();
      # -inf ** -1 => 1/inf => 0
      return $x->bzero() if $y->is_one('-') && $x->is_negative();

      # +inf ** Y => inf
      return $x if $x->{sign} eq '+inf';

      # -inf ** Y => -inf if Y is odd
      return $x if $y->is_odd();
      return $x->babs();
      }
    # X ** +-inf

    # 1 ** +inf => 1
    return $x if $x->is_one();

    # 0 ** inf => 0
    return $x if $x->is_zero() && $y->{sign} =~ /^[+]/;

    # 0 ** -inf => inf
    return $x->binf() if $x->is_zero();

    # -1 ** -inf => NaN
    return $x->bnan() if $x->is_one('-') && $y->{sign} =~ /^[-]/;

    # -X ** -inf => 0
    return $x->bzero() if $x->{sign} eq '-' && $y->{sign} =~ /^[-]/;

    # -1 ** inf => NaN
    return $x->bnan() if $x->{sign} eq '-';

    # X ** inf => inf
    return $x->binf() if $y->{sign} =~ /^[+]/;
    # X ** -inf => 0
    return $x->bzero();
    }

  return $upgrade->bpow($upgrade->new($x),$y,@@r)
   if defined $upgrade && (!$y->isa($self) || $y->{sign} eq '-');

  $r[3] = $y;                                   # no push!

  # cases 0 ** Y, X ** 0, X ** 1, 1 ** Y are handled by Calc or Emu

  my $new_sign = '+';
  $new_sign = $y->is_odd() ? '-' : '+' if ($x->{sign} ne '+');

  # 0 ** -7 => ( 1 / (0 ** 7)) => 1 / 0 => +inf
  return $x->binf()
    if $y->{sign} eq '-' && $x->{sign} eq '+' && $CALC->_is_zero($x->{value});
  # 1 ** -y => 1 / (1 ** |y|)
  # so do test for negative $y after above's clause
  return $x->bnan() if $y->{sign} eq '-' && !$CALC->_is_one($x->{value});

  $x->{value} = $CALC->_pow($x->{value},$y->{value});
  $x->{sign} = $new_sign;
  $x->{sign} = '+' if $CALC->_is_zero($y->{value});
  $x->round(@@r);
  }

sub blsft
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute x << y, base n, y >= 0

  # set up parameters
  my ($self,$x,$y,$n,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$n,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('blsft');
  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);
  return $x->round(@@r) if $y->is_zero();

  $n = 2 if !defined $n; return $x->bnan() if $n <= 0 || $y->{sign} eq '-';

  $x->{value} = $CALC->_lsft($x->{value},$y->{value},$n);
  $x->round(@@r);
  }

sub brsft
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute x >> y, base n, y >= 0

  # set up parameters
  my ($self,$x,$y,$n,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$n,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('brsft');
  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);
  return $x->round(@@r) if $y->is_zero();
  return $x->bzero(@@r) if $x->is_zero();                # 0 => 0

  $n = 2 if !defined $n; return $x->bnan() if $n <= 0 || $y->{sign} eq '-';

   # this only works for negative numbers when shifting in base 2
  if (($x->{sign} eq '-') && ($n == 2))
    {
    return $x->round(@@r) if $x->is_one('-');    # -1 => -1
    if (!$y->is_one())
      {
      # although this is O(N*N) in calc (as_bin!) it is O(N) in Pari et al
      # but perhaps there is a better emulation for two's complement shift...
      # if $y != 1, we must simulate it by doing:
      # convert to bin, flip all bits, shift, and be done
      $x->binc();                       # -3 => -2
      my $bin = $x->as_bin();
      $bin =~ s/^-0b//;                 # strip '-0b' prefix
      $bin =~ tr/10/01/;                # flip bits
      # now shift
      if ($y >= CORE::length($bin))
        {
        $bin = '0';                     # shifting to far right creates -1
                                        # 0, because later increment makes
                                        # that 1, attached '-' makes it '-1'
                                        # because -1 >> x == -1 !
        }
      else
        {
        $bin =~ s/.{$y}$//;             # cut off at the right side
        $bin = '1' . $bin;              # extend left side by one dummy '1'
        $bin =~ tr/10/01/;              # flip bits back
        }
      my $res = $self->new('0b'.$bin);  # add prefix and convert back
      $res->binc();                     # remember to increment
      $x->{value} = $res->{value};      # take over value
      return $x->round(@@r);             # we are done now, magic, isn't?
      }
    # x < 0, n == 2, y == 1
    $x->bdec();                         # n == 2, but $y == 1: this fixes it
    }

  $x->{value} = $CALC->_rsft($x->{value},$y->{value},$n);
  $x->round(@@r);
  }

sub band
  {
  #(BINT or num_str, BINT or num_str) return BINT
  # compute x & y

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('band');

  $r[3] = $y;                           # no push!

  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);

  my $sx = $x->{sign} eq '+' ? 1 : -1;
  my $sy = $y->{sign} eq '+' ? 1 : -1;

  if ($sx == 1 && $sy == 1)
    {
    $x->{value} = $CALC->_and($x->{value},$y->{value});
    return $x->round(@@r);
    }

  if ($CAN{signed_and})
    {
    $x->{value} = $CALC->_signed_and($x->{value},$y->{value},$sx,$sy);
    return $x->round(@@r);
    }

  require $EMU_LIB;
  __emu_band($self,$x,$y,$sx,$sy,@@r);
  }

sub bior
  {
  #(BINT or num_str, BINT or num_str) return BINT
  # compute x | y

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bior');
  $r[3] = $y;                           # no push!

  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);

  my $sx = $x->{sign} eq '+' ? 1 : -1;
  my $sy = $y->{sign} eq '+' ? 1 : -1;

  # the sign of X follows the sign of X, e.g. sign of Y irrelevant for bior()

  # don't use lib for negative values
  if ($sx == 1 && $sy == 1)
    {
    $x->{value} = $CALC->_or($x->{value},$y->{value});
    return $x->round(@@r);
    }

  # if lib can do negative values, let it handle this
  if ($CAN{signed_or})
    {
    $x->{value} = $CALC->_signed_or($x->{value},$y->{value},$sx,$sy);
    return $x->round(@@r);
    }

  require $EMU_LIB;
  __emu_bior($self,$x,$y,$sx,$sy,@@r);
  }

sub bxor
  {
  #(BINT or num_str, BINT or num_str) return BINT
  # compute x ^ y

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bxor');
  $r[3] = $y;                           # no push!

  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);

  my $sx = $x->{sign} eq '+' ? 1 : -1;
  my $sy = $y->{sign} eq '+' ? 1 : -1;

  # don't use lib for negative values
  if ($sx == 1 && $sy == 1)
    {
    $x->{value} = $CALC->_xor($x->{value},$y->{value});
    return $x->round(@@r);
    }

  # if lib can do negative values, let it handle this
  if ($CAN{signed_xor})
    {
    $x->{value} = $CALC->_signed_xor($x->{value},$y->{value},$sx,$sy);
    return $x->round(@@r);
    }

  require $EMU_LIB;
  __emu_bxor($self,$x,$y,$sx,$sy,@@r);
  }

sub length
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  my $e = $CALC->_len($x->{value});
  wantarray ? ($e,0) : $e;
  }

sub digit
  {
  # return the nth decimal digit, negative values count backward, 0 is right
  my ($self,$x,$n) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  $n = $n->numify() if ref($n);
  $CALC->_digit($x->{value},$n||0);
  }

sub _trailing_zeros
  {
  # return the amount of trailing zeros in $x (as scalar)
  my $x = shift;
  $x = $class->new($x) unless ref $x;

  return 0 if $x->{sign} !~ /^[+-]$/;   # NaN, inf, -inf etc

  $CALC->_zeros($x->{value});           # must handle odd values, 0 etc
  }

sub bsqrt
  {
  # calculate square root of $x
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  return $x if $x->modify('bsqrt');

  return $x->bnan() if $x->{sign} !~ /^\+/;     # -x or -inf or NaN => NaN
  return $x if $x->{sign} eq '+inf';            # sqrt(+inf) == inf

  return $upgrade->bsqrt($x,@@r) if defined $upgrade;

  $x->{value} = $CALC->_sqrt($x->{value});
  $x->round(@@r);
  }

sub broot
  {
  # calculate $y'th root of $x

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);

  $y = $self->new(2) unless defined $y;

  # objectify is costly, so avoid it
  if ((!ref($x)) || (ref($x) ne ref($y)))
    {
    ($self,$x,$y,@@r) = objectify(2,$self || $class,@@_);
    }

  return $x if $x->modify('broot');

  # NaN handling: $x ** 1/0, x or y NaN, or y inf/-inf or y == 0
  return $x->bnan() if $x->{sign} !~ /^\+/ || $y->is_zero() ||
         $y->{sign} !~ /^\+$/;

  return $x->round(@@r)
    if $x->is_zero() || $x->is_one() || $x->is_inf() || $y->is_one();

  return $upgrade->new($x)->broot($upgrade->new($y),@@r) if defined $upgrade;

  $x->{value} = $CALC->_root($x->{value},$y->{value});
  $x->round(@@r);
  }

sub exponent
  {
  # return a copy of the exponent (here always 0, NaN or 1 for $m == 0)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    my $s = $x->{sign}; $s =~ s/^[+-]//;  # NaN, -inf,+inf => NaN or inf
    return $self->new($s);
    }
  return $self->bzero() if $x->is_zero();

  # 12300 => 2 trailing zeros => exponent is 2
  $self->new( $CALC->_zeros($x->{value}) );
  }

sub mantissa
  {
  # return the mantissa (compatible to Math::BigFloat, e.g. reduced)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    # for NaN, +inf, -inf: keep the sign
    return $self->new($x->{sign});
    }
  my $m = $x->copy(); delete $m->{_p}; delete $m->{_a};

  # that's a bit inefficient:
  my $zeros = $CALC->_zeros($m->{value});
  $m->brsft($zeros,10) if $zeros != 0;
  $m;
  }

sub parts
  {
  # return a copy of both the exponent and the mantissa
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  ($x->mantissa(),$x->exponent());
  }

##############################################################################
# rounding functions

sub bfround
  {
  # precision: round to the $Nth digit left (+$n) or right (-$n) from the '.'
  # $n == 0 || $n == 1 => round to integer
  my $x = shift; my $self = ref($x) || $x; $x = $self->new($x) unless ref $x;

  my ($scale,$mode) = $x->_scale_p(@@_);

  return $x if !defined $scale || $x->modify('bfround');        # no-op

  # no-op for BigInts if $n <= 0
  $x->bround( $x->length()-$scale, $mode) if $scale > 0;

  delete $x->{_a};      # delete to save memory
  $x->{_p} = $scale;    # store new _p
  $x;
  }

sub _scan_for_nonzero
  {
  # internal, used by bround() to scan for non-zeros after a '5'
  my ($x,$pad,$xs,$len) = @@_;

  return 0 if $len == 1;                # "5" is trailed by invisible zeros
  my $follow = $pad - 1;
  return 0 if $follow > $len || $follow < 1;

  # use the string form to check whether only '0's follow or not
  substr ($xs,-$follow) =~ /[^0]/ ? 1 : 0;
  }

sub fround
  {
  # Exists to make life easier for switch between MBF and MBI (should we
  # autoload fxxx() like MBF does for bxxx()?)
  my $x = shift; $x = $class->new($x) unless ref $x;
  $x->bround(@@_);
  }

sub bround
  {
  # accuracy: +$n preserve $n digits from left,
  #           -$n preserve $n digits from right (f.i. for 0.1234 style in MBF)
  # no-op for $n == 0
  # and overwrite the rest with 0's, return normalized number
  # do not return $x->bnorm(), but $x

  my $x = shift; $x = $class->new($x) unless ref $x;
  my ($scale,$mode) = $x->_scale_a(@@_);
  return $x if !defined $scale || $x->modify('bround'); # no-op

  if ($x->is_zero() || $scale == 0)
    {
    $x->{_a} = $scale if !defined $x->{_a} || $x->{_a} > $scale; # 3 > 2
    return $x;
    }
  return $x if $x->{sign} !~ /^[+-]$/;          # inf, NaN

  # we have fewer digits than we want to scale to
  my $len = $x->length();
  # convert $scale to a scalar in case it is an object (put's a limit on the
  # number length, but this would already limited by memory constraints), makes
  # it faster
  $scale = $scale->numify() if ref ($scale);

  # scale < 0, but > -len (not >=!)
  if (($scale < 0 && $scale < -$len-1) || ($scale >= $len))
    {
    $x->{_a} = $scale if !defined $x->{_a} || $x->{_a} > $scale; # 3 > 2
    return $x;
    }

  # count of 0's to pad, from left (+) or right (-): 9 - +6 => 3, or |-6| => 6
  my ($pad,$digit_round,$digit_after);
  $pad = $len - $scale;
  $pad = abs($scale-1) if $scale < 0;

  # do not use digit(), it is very costly for binary => decimal
  # getting the entire string is also costly, but we need to do it only once
  my $xs = $CALC->_str($x->{value});
  my $pl = -$pad-1;

  # pad:   123: 0 => -1, at 1 => -2, at 2 => -3, at 3 => -4
  # pad+1: 123: 0 => 0,  at 1 => -1, at 2 => -2, at 3 => -3
  $digit_round = '0'; $digit_round = substr($xs,$pl,1) if $pad <= $len;
  $pl++; $pl ++ if $pad >= $len;
  $digit_after = '0'; $digit_after = substr($xs,$pl,1) if $pad > 0;

  # in case of 01234 we round down, for 6789 up, and only in case 5 we look
  # closer at the remaining digits of the original $x, remember decision
  my $round_up = 1;                                     # default round up
  $round_up -- if
    ($mode eq 'trunc')                          ||      # trunc by round down
    ($digit_after =~ /[01234]/)                 ||      # round down anyway,
                                                        # 6789 => round up
    ($digit_after eq '5')                       &&      # not 5000...0000
    ($x->_scan_for_nonzero($pad,$xs,$len) == 0)         &&
    (
     ($mode eq 'even') && ($digit_round =~ /[24680]/) ||
     ($mode eq 'odd')  && ($digit_round =~ /[13579]/) ||
     ($mode eq '+inf') && ($x->{sign} eq '-')   ||
     ($mode eq '-inf') && ($x->{sign} eq '+')   ||
     ($mode eq 'zero')          # round down if zero, sign adjusted below
    );
  my $put_back = 0;                                     # not yet modified

  if (($pad > 0) && ($pad <= $len))
    {
    substr($xs,-$pad,$pad) = '0' x $pad;                # replace with '00...'
    $put_back = 1;                                      # need to put back
    }
  elsif ($pad > $len)
    {
    $x->bzero();                                        # round to '0'
    }

  if ($round_up)                                        # what gave test above?
    {
    $put_back = 1;                                      # need to put back
    $pad = $len, $xs = '0' x $pad if $scale < 0;        # tlr: whack 0.51=>1.0

    # we modify directly the string variant instead of creating a number and
    # adding it, since that is faster (we already have the string)
    my $c = 0; $pad ++;                         # for $pad == $len case
    while ($pad <= $len)
      {
      $c = substr($xs,-$pad,1) + 1; $c = '0' if $c eq '10';
      substr($xs,-$pad,1) = $c; $pad++;
      last if $c != 0;                          # no overflow => early out
      }
    $xs = '1'.$xs if $c == 0;

    }
  $x->{value} = $CALC->_new($xs) if $put_back == 1;     # put back, if needed

  $x->{_a} = $scale if $scale >= 0;
  if ($scale < 0)
    {
    $x->{_a} = $len+$scale;
    $x->{_a} = 0 if $scale < -$len;
    }
  $x;
  }

sub bfloor
  {
  # round towards minus infinity; no-op since it's already integer
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  $x->round(@@r);
  }

sub bceil
  {
  # round towards plus infinity; no-op since it's already int
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  $x->round(@@r);
  }

sub bint {
    # round towards zero; no-op since it's already integer
    my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

    $x->round(@@r);
}

sub as_number
  {
  # An object might be asked to return itself as bigint on certain overloaded
  # operations. This does exactly this, so that sub classes can simple inherit
  # it or override with their own integer conversion routine.
  $_[0]->copy();
  }

sub as_hex
  {
  # return as hex string, with prefixed 0x
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;  # inf, nan etc

  my $s = '';
  $s = $x->{sign} if $x->{sign} eq '-';
  $s . $CALC->_as_hex($x->{value});
  }

sub as_bin
  {
  # return as binary string, with prefixed 0b
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;  # inf, nan etc

  my $s = ''; $s = $x->{sign} if $x->{sign} eq '-';
  return $s . $CALC->_as_bin($x->{value});
  }

sub as_oct
  {
  # return as octal string, with prefixed 0
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;  # inf, nan etc

  my $oct = $CALC->_as_oct($x->{value});
  return $x->{sign} eq '-' ? "-$oct" : $oct;
  }

##############################################################################
# private stuff (internal use only)

sub objectify {
    # Convert strings and "foreign objects" to the objects we want.

    # The first argument, $count, is the number of following arguments that
    # objectify() looks at and converts to objects. The first is a classname.
    # If the given count is 0, all arguments will be used.

    # After the count is read, objectify obtains the name of the class to which
    # the following arguments are converted. If the second argument is a
    # reference, use the reference type as the class name. Otherwise, if it is
    # a string that looks like a class name, use that. Otherwise, use $class.

    # Caller:                        Gives us:
    #
    # $x->badd(1);                => ref x, scalar y
    # Class->badd(1,2);           => classname x (scalar), scalar x, scalar y
    # Class->badd(Class->(1),2);  => classname x (scalar), ref x, scalar y
    # Math::BigInt::badd(1,2);    => scalar x, scalar y

    # A shortcut for the common case $x->unary_op():

    return (ref($_[1]), $_[1]) if (@@_ == 2) && ($_[0]||0 == 1) && ref($_[1]);

    # Check the context.

    unless (wantarray) {
        require Carp;
        Carp::croak ("${class}::objectify() needs list context");
    }

    # Get the number of arguments to objectify.

    my $count = shift;
    $count ||= @@_;

    # Initialize the output array.

    my @@a = @@_;

    # If the first argument is a reference, use that reference type as our
    # class name. Otherwise, if the first argument looks like a class name,
    # then use that as our class name. Otherwise, use the default class name.

    {
        if (ref($a[0])) {               # reference?
            unshift @@a, ref($a[0]);
            last;
        }
        if ($a[0] =~ /^[A-Z].*::/) {    # string with class name?
            last;
        }
        unshift @@a, $class;             # default class name
    }

    no strict 'refs';

    # What we upgrade to, if anything.

    my $up = ${"$a[0]::upgrade"};

    # Disable downgrading, because Math::BigFloat -> foo('1.0','2.0') needs
    # floats.

    my $down;
    if (defined ${"$a[0]::downgrade"}) {
        $down = ${"$a[0]::downgrade"};
        ${"$a[0]::downgrade"} = undef;
    }

    for my $i (1 .. $count) {
        my $ref = ref $a[$i];

        # Perl scalars are fed to the appropriate constructor.

        unless ($ref) {
            $a[$i] = $a[0] -> new($a[$i]);
            next;
        }

        # If it is an object of the right class, all is fine.

        next if $ref -> isa($a[0]);

        # Upgrading is OK, so skip further tests if the argument is upgraded.

        if (defined $up && $ref -> isa($up)) {
            next;
        }

        # See if we can call one of the as_xxx() methods. We don't know whether
        # the as_xxx() method returns an object or a scalar, so re-check
        # afterwards.

        my $recheck = 0;

        if ($a[0] -> isa('Math::BigInt')) {
            if ($a[$i] -> can('as_int')) {
                $a[$i] = $a[$i] -> as_int();
                $recheck = 1;
            } elsif ($a[$i] -> can('as_number')) {
                $a[$i] = $a[$i] -> as_number();
                $recheck = 1;
            }
        }

        elsif ($a[0] -> isa('Math::BigFloat')) {
            if ($a[$i] -> can('as_float')) {
                $a[$i] = $a[$i] -> as_float();
                $recheck = $1;
            }
        }

        # If we called one of the as_xxx() methods, recheck.

        if ($recheck) {
            $ref = ref($a[$i]);

            # Perl scalars are fed to the appropriate constructor.

            unless ($ref) {
                $a[$i] = $a[0] -> new($a[$i]);
                next;
            }

            # If it is an object of the right class, all is fine.

            next if $ref -> isa($a[0]);
        }

        # Last resort.

        $a[$i] = $a[0] -> new($a[$i]);
    }

    # Reset the downgrading.

    ${"$a[0]::downgrade"} = $down;

    return @@a;
}

sub _register_callback
  {
  my ($class,$callback) = @@_;

  if (ref($callback) ne 'CODE')
    {
    require Carp;
    Carp::croak ("$callback is not a coderef");
    }
  $CALLBACKS{$class} = $callback;
  }

sub import
  {
  my $self = shift;

  $IMPORT++;                            # remember we did import()
  my @@a; my $l = scalar @@_;
  my $warn_or_die = 0;                  # 0 - no warn, 1 - warn, 2 - die
  for ( my $i = 0; $i < $l ; $i++ )
    {
    if ($_[$i] eq ':constant')
      {
      # this causes overlord er load to step in
      overload::constant
        integer => sub { $self->new(shift) },
        binary => sub { $self->new(shift) };
      }
    elsif ($_[$i] eq 'upgrade')
      {
      # this causes upgrading
      $upgrade = $_[$i+1];              # or undef to disable
      $i++;
      }
    elsif ($_[$i] =~ /^(lib|try|only)\z/)
      {
      # this causes a different low lib to take care...
      $CALC = $_[$i+1] || '';
      # lib => 1 (warn on fallback), try => 0 (no warn), only => 2 (die on fallback)
      $warn_or_die = 1 if $_[$i] eq 'lib';
      $warn_or_die = 2 if $_[$i] eq 'only';
      $i++;
      }
    else
      {
      push @@a, $_[$i];
      }
    }
  # any non :constant stuff is handled by our parent, Exporter
  if (@@a > 0)
    {
    require Exporter;

    $self->SUPER::import(@@a);                   # need it for subclasses
    $self->export_to_level(1,$self,@@a);         # need it for MBF
    }

  # try to load core math lib
  my @@c = split /\s*,\s*/,$CALC;
  foreach (@@c)
    {
    $_ =~ tr/a-zA-Z0-9://cd;                    # limit to sane characters
    }
  push @@c, \'Calc'                              # if all fail, try these
    if $warn_or_die < 2;                        # but not for "only"
  $CALC = '';                                   # signal error
  foreach my $l (@@c)
    {
    # fallback libraries are "marked" as \'string', extract string if nec.
    my $lib = $l; $lib = $$l if ref($l);

    next if ($lib || '') eq '';
    $lib = 'Math::BigInt::'.$lib if $lib !~ /^Math::BigInt/i;
    $lib =~ s/\.pm$//;
    if ($] < 5.006)
      {
      # Perl < 5.6.0 dies with "out of memory!" when eval("") and ':constant' is
      # used in the same script, or eval("") inside import().
      my @@parts = split /::/, $lib;             # Math::BigInt => Math BigInt
      my $file = pop @@parts; $file .= '.pm';    # BigInt => BigInt.pm
      require File::Spec;
      $file = File::Spec->catfile (@@parts, $file);
      eval { require "$file"; $lib->import( @@c ); }
      }
    else
      {
      eval "use $lib qw/@@c/;";
      }
    if ($@@ eq '')
      {
      my $ok = 1;
      # loaded it ok, see if the api_version() is high enough
      if ($lib->can('api_version') && $lib->api_version() >= 1.0)
        {
        $ok = 0;
        # api_version matches, check if it really provides anything we need
        for my $method (qw/
                one two ten
                str num
                add mul div sub dec inc
                acmp len digit is_one is_zero is_even is_odd
                is_two is_ten
                zeros new copy check
                from_hex from_oct from_bin as_hex as_bin as_oct
                rsft lsft xor and or
                mod sqrt root fac pow modinv modpow log_int gcd
         /)
          {
          if (!$lib->can("_$method"))
            {
            if (($WARN{$lib}||0) < 2)
              {
              require Carp;
              Carp::carp ("$lib is missing method '_$method'");
              $WARN{$lib} = 1;          # still warn about the lib
              }
            $ok++; last;
            }
          }
        }
      if ($ok == 0)
        {
        $CALC = $lib;
        if ($warn_or_die > 0 && ref($l))
          {
          require Carp;
          my $msg =
        "Math::BigInt: couldn't load specified math lib(s), fallback to $lib";
          Carp::carp ($msg) if $warn_or_die == 1;
          Carp::croak ($msg) if $warn_or_die == 2;
          }
        last;                   # found a usable one, break
        }
      else
        {
        if (($WARN{$lib}||0) < 2)
          {
          my $ver = eval "\$$lib\::VERSION" || 'unknown';
          require Carp;
          Carp::carp ("Cannot load outdated $lib v$ver, please upgrade");
          $WARN{$lib} = 2;              # never warn again
          }
        }
      }
    }
  if ($CALC eq '')
    {
    require Carp;
    if ($warn_or_die == 2)
      {
      Carp::croak(
          "Couldn't load specified math lib(s) and fallback disallowed");
      }
    else
      {
      Carp::croak(
          "Couldn't load any math lib(s), not even fallback to Calc.pm");
      }
    }

  # notify callbacks
  foreach my $class (keys %CALLBACKS)
    {
    &{$CALLBACKS{$class}}($CALC);
    }

  # Fill $CAN with the results of $CALC->can(...) for emulating lower math lib
  # functions

  %CAN = ();
  for my $method (qw/ signed_and signed_or signed_xor /)
    {
    $CAN{$method} = $CALC->can("_$method") ? 1 : 0;
    }

  # import done
  }

# Create a Math::BigInt from a hexadecimal string.

sub from_hex {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    my $str = shift;

    # If called as a class method, initialize a new object.

    $self = $class -> bzero() unless $selfref;

    if ($str =~ s/
                     ^
                     ( [+-]? )
                     (0?x)?
                     (
                         [0-9a-fA-F]*
                         ( _ [0-9a-fA-F]+ )*
                     )
                     $
                 //x)
    {
        # Get a "clean" version of the string, i.e., non-emtpy and with no
        # underscores or invalid characters.

        my $sign = $1;
        my $chrs = $3;
        $chrs =~ tr/_//d;
        $chrs = '0' unless CORE::length $chrs;

        # The library method requires a prefix.

        $self->{value} = $CALC->_from_hex('0x' . $chrs);

        # Place the sign.

        if ($sign eq '-' && ! $CALC->_is_zero($self->{value})) {
            $self->{sign} = '-';
        }

        return $self;
    }

    # CORE::hex() parses as much as it can, and ignores any trailing garbage.
    # For backwards compatibility, we return NaN.

    return $self->bnan();
}

# Create a Math::BigInt from an octal string.

sub from_oct {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    my $str = shift;

    # If called as a class method, initialize a new object.

    $self = $class -> bzero() unless $selfref;

    if ($str =~ s/
                     ^
                     ( [+-]? )
                     (
                         [0-7]*
                         ( _ [0-7]+ )*
                     )
                     $
                 //x)
    {
        # Get a "clean" version of the string, i.e., non-emtpy and with no
        # underscores or invalid characters.

        my $sign = $1;
        my $chrs = $2;
        $chrs =~ tr/_//d;
        $chrs = '0' unless CORE::length $chrs;

        # The library method requires a prefix.

        $self->{value} = $CALC->_from_oct('0' . $chrs);

        # Place the sign.

        if ($sign eq '-' && ! $CALC->_is_zero($self->{value})) {
            $self->{sign} = '-';
        }

        return $self;
    }

    # CORE::oct() parses as much as it can, and ignores any trailing garbage.
    # For backwards compatibility, we return NaN.

    return $self->bnan();
}

# Create a Math::BigInt from a binary string.

sub from_bin {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    my $str = shift;

    # If called as a class method, initialize a new object.

    $self = $class -> bzero() unless $selfref;

    if ($str =~ s/
                     ^
                     ( [+-]? )
                     (0?b)?
                     (
                         [01]*
                         ( _ [01]+ )*
                     )
                     $
                 //x)
    {
        # Get a "clean" version of the string, i.e., non-emtpy and with no
        # underscores or invalid characters.

        my $sign = $1;
        my $chrs = $3;
        $chrs =~ tr/_//d;
        $chrs = '0' unless CORE::length $chrs;

        # The library method requires a prefix.

        $self->{value} = $CALC->_from_bin('0b' . $chrs);

        # Place the sign.

        if ($sign eq '-' && ! $CALC->_is_zero($self->{value})) {
            $self->{sign} = '-';
        }

        return $self;
    }

    # For consistency with from_hex() and from_oct(), we return NaN when the
    # input is invalid.

    return $self->bnan();
}

sub _split_dec_string {
    my $str = shift;

    if ($str =~ s/
                     ^

                     # leading whitespace
                     ( \s* )

                     # optional sign
                     ( [+-]? )

                     # significand
                     (
                         \d+ (?: _ \d+ )*
                         (?:
                             \.
                             (?: \d+ (?: _ \d+ )* )?
                         )?
                     |
                         \.
                         \d+ (?: _ \d+ )*
                     )

                     # optional exponent
                     (?:
                         [Ee]
                         ( [+-]? )
                         ( \d+ (?: _ \d+ )* )
                     )?

                     # trailing stuff
                     ( \D .*? )?

                     \z
                 //x)
    {
        my $leading         = $1;
        my $significand_sgn = $2 || '+';
        my $significand_abs = $3;
        my $exponent_sgn    = $4 || '+';
        my $exponent_abs    = $5 || '0';
        my $trailing        = $6;

        # Remove underscores and leading zeros.

        $significand_abs =~ tr/_//d;
        $exponent_abs    =~ tr/_//d;

        $significand_abs =~ s/^0+(.)/$1/;
        $exponent_abs    =~ s/^0+(.)/$1/;

        # If the significand contains a dot, remove it and adjust the exponent
        # accordingly. E.g., "1234.56789e+3" -> "123456789e-2"

        my $idx = index $significand_abs, '.';
        if ($idx > -1) {
            $significand_abs =~ s/0+\z//;
            substr($significand_abs, $idx, 1) = '';
            my $exponent = $exponent_sgn . $exponent_abs;
            $exponent .= $idx - CORE::length($significand_abs);
            $exponent_abs = abs $exponent;
            $exponent_sgn = $exponent < 0 ? '-' : '+';
        }

        return($leading,
               $significand_sgn, $significand_abs,
               $exponent_sgn, $exponent_abs,
               $trailing);
    }

    return undef;
}

sub _split
  {
  # input: num_str; output: undef for invalid or
  # (\$mantissa_sign,\$mantissa_value,\$mantissa_fraction,
  # \$exp_sign,\$exp_value)
  # Internal, take apart a string and return the pieces.
  # Strip leading/trailing whitespace, leading zeros, underscore and reject
  # invalid input.
  my $x = shift;

  # strip white space at front, also extraneous leading zeros
  $x =~ s/^\s*([-]?)0*([0-9])/$1$2/g;   # will not strip '  .2'
  $x =~ s/^\s+//;                       # but this will
  $x =~ s/\s+$//g;                      # strip white space at end

  # shortcut, if nothing to split, return early
  if ($x =~ /^[+-]?[0-9]+\z/)
    {
    $x =~ s/^([+-])0*([0-9])/$2/; my $sign = $1 || '+';
    return (\$sign, \$x, \'', \'', \0);
    }

  # invalid starting char?
  return if $x !~ /^[+-]?(\.?[0-9]|0b[0-1]|0x[0-9a-fA-F])/;

  return Math::BigInt->from_hex($x) if $x =~ /^[+-]?0x/;        # hex string
  return Math::BigInt->from_bin($x) if $x =~ /^[+-]?0b/;        # binary string

  # strip underscores between digits
  $x =~ s/([0-9])_([0-9])/$1$2/g;
  $x =~ s/([0-9])_([0-9])/$1$2/g;               # do twice for 1_2_3

  # some possible inputs:
  # 2.1234 # 0.12        # 1          # 1E1 # 2.134E1 # 434E-10 # 1.02009E-2
  # .2     # 1_2_3.4_5_6 # 1.4E1_2_3  # 1e3 # +.2     # 0e999

  my ($m,$e,$last) = split /[Ee]/,$x;
  return if defined $last;              # last defined => 1e2E3 or others
  $e = '0' if !defined $e || $e eq "";

  # sign,value for exponent,mantint,mantfrac
  my ($es,$ev,$mis,$miv,$mfv);
  # valid exponent?
  if ($e =~ /^([+-]?)0*([0-9]+)$/)      # strip leading zeros
    {
    $es = $1; $ev = $2;
    # valid mantissa?
    return if $m eq '.' || $m eq '';
    my ($mi,$mf,$lastf) = split /\./,$m;
    return if defined $lastf;           # lastf defined => 1.2.3 or others
    $mi = '0' if !defined $mi;
    $mi .= '0' if $mi =~ /^[\-\+]?$/;
    $mf = '0' if !defined $mf || $mf eq '';
    if ($mi =~ /^([+-]?)0*([0-9]+)$/)           # strip leading zeros
      {
      $mis = $1||'+'; $miv = $2;
      return unless ($mf =~ /^([0-9]*?)0*$/);   # strip trailing zeros
      $mfv = $1;
      # handle the 0e999 case here
      $ev = 0 if $miv eq '0' && $mfv eq '';
      return (\$mis,\$miv,\$mfv,\$es,\$ev);
      }
    }
  return; # NaN, not a number
  }

##############################################################################
# internal calculation routines (others are in Math::BigInt::Calc etc)

sub __lcm
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # does modify first argument
  # LCM

  my ($x,$ty) = @@_;
  return $x->bnan() if ($x->{sign} eq $nan) || ($ty->{sign} eq $nan);
  my $method = ref($x) . '::bgcd';
  no strict 'refs';
  $x * $ty / &$method($x,$ty);
  }

###############################################################################
# trigonometric functions

sub bpi
  {
  # Calculate PI to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer, that is, always returns '3'.
  my ($self,$n) = @@_;
  if (@@_ == 1)
    {
    # called like Math::BigInt::bpi(10);
    $n = $self; $self = $class;
    }
  $self = ref($self) if ref($self);

  return $upgrade->new($n) if defined $upgrade;

  # hard-wired to "3"
  $self->new(3);
  }

sub bcos
  {
  # Calculate cosinus(x) to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer.
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  return $x if $x->modify('bcos');

  return $x->bnan() if $x->{sign} !~ /^[+-]\z/; # -inf +inf or NaN => NaN

  return $upgrade->new($x)->bcos(@@r) if defined $upgrade;

  require Math::BigFloat;
  # calculate the result and truncate it to integer
  my $t = Math::BigFloat->new($x)->bcos(@@r)->as_int();

  $x->bone() if $t->is_one();
  $x->bzero() if $t->is_zero();
  $x->round(@@r);
  }

sub bsin
  {
  # Calculate sinus(x) to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer.
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  return $x if $x->modify('bsin');

  return $x->bnan() if $x->{sign} !~ /^[+-]\z/; # -inf +inf or NaN => NaN

  return $upgrade->new($x)->bsin(@@r) if defined $upgrade;

  require Math::BigFloat;
  # calculate the result and truncate it to integer
  my $t = Math::BigFloat->new($x)->bsin(@@r)->as_int();

  $x->bone() if $t->is_one();
  $x->bzero() if $t->is_zero();
  $x->round(@@r);
  }

sub batan2
  {
  # calculate arcus tangens of ($y/$x)

  # set up parameters
  my ($self,$y,$x,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$y,$x,@@r) = objectify(2,@@_);
    }

  return $y if $y->modify('batan2');

  return $y->bnan() if ($y->{sign} eq $nan) || ($x->{sign} eq $nan);

  # Y    X
  # != 0 -inf result is +- pi
  if ($x->is_inf() || $y->is_inf())
    {
    # upgrade to BigFloat etc.
    return $upgrade->new($y)->batan2($upgrade->new($x),@@r) if defined $upgrade;
    if ($y->is_inf())
      {
      if ($x->{sign} eq '-inf')
        {
        # calculate 3 pi/4 => 2.3.. => 2
        $y->bone( substr($y->{sign},0,1) );
        $y->bmul($self->new(2));
        }
      elsif ($x->{sign} eq '+inf')
        {
        # calculate pi/4 => 0.7 => 0
        $y->bzero();
        }
      else
        {
        # calculate pi/2 => 1.5 => 1
        $y->bone( substr($y->{sign},0,1) );
        }
      }
    else
      {
      if ($x->{sign} eq '+inf')
        {
        # calculate pi/4 => 0.7 => 0
        $y->bzero();
        }
      else
        {
        # PI => 3.1415.. => 3
        $y->bone( substr($y->{sign},0,1) );
        $y->bmul($self->new(3));
        }
      }
    return $y;
    }

  return $upgrade->new($y)->batan2($upgrade->new($x),@@r) if defined $upgrade;

  require Math::BigFloat;
  my $r = Math::BigFloat->new($y)
                        ->batan2(Math::BigFloat->new($x),@@r)
                        ->as_int();

  $x->{value} = $r->{value};
  $x->{sign} = $r->{sign};

  $x;
  }

sub batan
  {
  # Calculate arcus tangens of x to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer.
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  return $x if $x->modify('batan');

  return $x->bnan() if $x->{sign} !~ /^[+-]\z/; # -inf +inf or NaN => NaN

  return $upgrade->new($x)->batan(@@r) if defined $upgrade;

  # calculate the result and truncate it to integer
  my $t = Math::BigFloat->new($x)->batan(@@r);

  $x->{value} = $CALC->_new( $x->as_int()->bstr() );
  $x->round(@@r);
  }

###############################################################################
# this method returns 0 if the object can be modified, or 1 if not.
# We use a fast constant sub() here, to avoid costly calls. Subclasses
# may override it with special code (f.i. Math::BigInt::Constant does so)

sub modify () { 0; }

1;
__END__

=pod

=head1 NAME

Math::BigInt - Arbitrary size integer/float math package

=head1 SYNOPSIS

  use Math::BigInt;

  # or make it faster with huge numbers: install (optional)
  # Math::BigInt::GMP and always use (it will fall back to
  # pure Perl if the GMP library is not installed):
  # (See also the L<MATH LIBRARY> section!)

  # will warn if Math::BigInt::GMP cannot be found
  use Math::BigInt lib => 'GMP';

  # to suppress the warning use this:
  # use Math::BigInt try => 'GMP';

  # dies if GMP cannot be loaded:
  # use Math::BigInt only => 'GMP';

  my $str = '1234567890';
  my @@values = (64,74,18);
  my $n = 1; my $sign = '-';

  # Number creation
  my $x = Math::BigInt->new($str);      # defaults to 0
  my $y = $x->copy();                   # make a true copy
  my $nan  = Math::BigInt->bnan();      # create a NotANumber
  my $zero = Math::BigInt->bzero();     # create a +0
  my $inf = Math::BigInt->binf();       # create a +inf
  my $inf = Math::BigInt->binf('-');    # create a -inf
  my $one = Math::BigInt->bone();       # create a +1
  my $mone = Math::BigInt->bone('-');   # create a -1

  my $pi = Math::BigInt->bpi();         # returns '3'
                                        # see Math::BigFloat::bpi()

  $h = Math::BigInt->new('0x123');      # from hexadecimal
  $b = Math::BigInt->new('0b101');      # from binary
  $o = Math::BigInt->from_oct('0101');  # from octal
  $h = Math::BigInt->from_hex('cafe');  # from hexadecimal
  $b = Math::BigInt->from_bin('0101');  # from binary

  # Testing (don't modify their arguments)
  # (return true if the condition is met, otherwise false)

  $x->is_zero();        # if $x is +0
  $x->is_nan();         # if $x is NaN
  $x->is_one();         # if $x is +1
  $x->is_one('-');      # if $x is -1
  $x->is_odd();         # if $x is odd
  $x->is_even();        # if $x is even
  $x->is_pos();         # if $x > 0
  $x->is_neg();         # if $x < 0
  $x->is_inf($sign);    # if $x is +inf, or -inf (sign is default '+')
  $x->is_int();         # if $x is an integer (not a float)

  # comparing and digit/sign extraction
  $x->bcmp($y);         # compare numbers (undef,<0,=0,>0)
  $x->bacmp($y);        # compare absolutely (undef,<0,=0,>0)
  $x->sign();           # return the sign, either +,- or NaN
  $x->digit($n);        # return the nth digit, counting from right
  $x->digit(-$n);       # return the nth digit, counting from left

  # The following all modify their first argument. If you want to pre-
  # serve $x, use $z = $x->copy()->bXXX($y); See under L<CAVEATS> for
  # why this is necessary when mixing $a = $b assignments with non-over-
  # loaded math.

  $x->bzero();          # set $x to 0
  $x->bnan();           # set $x to NaN
  $x->bone();           # set $x to +1
  $x->bone('-');        # set $x to -1
  $x->binf();           # set $x to inf
  $x->binf('-');        # set $x to -inf

  $x->bneg();           # negation
  $x->babs();           # absolute value
  $x->bsgn();           # sign function (-1, 0, 1, or NaN)
  $x->bnorm();          # normalize (no-op in BigInt)
  $x->bnot();           # two's complement (bit wise not)
  $x->binc();           # increment $x by 1
  $x->bdec();           # decrement $x by 1

  $x->badd($y);         # addition (add $y to $x)
  $x->bsub($y);         # subtraction (subtract $y from $x)
  $x->bmul($y);         # multiplication (multiply $x by $y)
  $x->bdiv($y);         # divide, set $x to quotient
                        # return (quo,rem) or quo if scalar

  $x->bmuladd($y,$z);   # $x = $x * $y + $z

  $x->bmod($y);         # modulus (x % y)
  $x->bmodpow($y,$mod); # modular exponentiation (($x ** $y) % $mod)
  $x->bmodinv($mod);    # modular multiplicative inverse
  $x->bpow($y);         # power of arguments (x ** y)
  $x->blsft($y);        # left shift in base 2
  $x->brsft($y);        # right shift in base 2
                        # returns (quo,rem) or quo if in sca-
                        # lar context
  $x->blsft($y,$n);     # left shift by $y places in base $n
  $x->brsft($y,$n);     # right shift by $y places in base $n
                        # returns (quo,rem) or quo if in sca-
                        # lar context

  $x->band($y);         # bitwise and
  $x->bior($y);         # bitwise inclusive or
  $x->bxor($y);         # bitwise exclusive or
  $x->bnot();           # bitwise not (two's complement)

  $x->bsqrt();          # calculate square-root
  $x->broot($y);        # $y'th root of $x (e.g. $y == 3 => cubic root)
  $x->bfac();           # factorial of $x (1*2*3*4*..$x)

  $x->bnok($y);         # x over y (binomial coefficient n over k)

  $x->blog();           # logarithm of $x to base e (Euler's number)
  $x->blog($base);      # logarithm of $x to base $base (f.i. 2)
  $x->bexp();           # calculate e ** $x where e is Euler's number

  $x->round($A,$P,$mode);  # round to accuracy or precision using
                           # mode $mode
  $x->bround($n);          # accuracy: preserve $n digits
  $x->bfround($n);         # $n > 0: round $nth digits,
                           # $n < 0: round to the $nth digit after the
                           # dot, no-op for BigInts

  # The following do not modify their arguments in BigInt (are no-ops),
  # but do so in BigFloat:

  $x->bfloor();            # round towards minus infinity
  $x->bceil();             # round towards plus infinity
  $x->bint();              # round towards zero

  # The following do not modify their arguments:

  # greatest common divisor (no OO style)
  my $gcd = Math::BigInt::bgcd(@@values);
  # lowest common multiple (no OO style)
  my $lcm = Math::BigInt::blcm(@@values);

  $x->length();            # return number of digits in number
  ($xl,$f) = $x->length(); # length of number and length of fraction
                           # part, latter is always 0 digits long
                           # for BigInts

  $x->exponent();         # return exponent as BigInt
  $x->mantissa();         # return (signed) mantissa as BigInt
  $x->parts();            # return (mantissa,exponent) as BigInt
  $x->copy();             # make a true copy of $x (unlike $y = $x;)
  $x->as_int();           # return as BigInt (in BigInt: same as copy())
  $x->numify();           # return as scalar (might overflow!)

  # conversion to string (do not modify their argument)
  $x->bstr();         # normalized string (e.g. '3')
  $x->bsstr();        # norm. string in scientific notation (e.g. '3E0')
  $x->as_hex();       # as signed hexadecimal string with prefixed 0x
  $x->as_bin();       # as signed binary string with prefixed 0b
  $x->as_oct();       # as signed octal string with prefixed 0


  # precision and accuracy (see section about rounding for more)
  $x->precision();       # return P of $x (or global, if P of $x undef)
  $x->precision($n);     # set P of $x to $n
  $x->accuracy();        # return A of $x (or global, if A of $x undef)
  $x->accuracy($n);      # set A $x to $n

  # Global methods
  Math::BigInt->precision();   # get/set global P for all BigInt objects
  Math::BigInt->accuracy();    # get/set global A for all BigInt objects
  Math::BigInt->round_mode();  # get/set global round mode, one of
                               # 'even', 'odd', '+inf', '-inf', 'zero',
                               # 'trunc' or 'common'
  Math::BigInt->config();      # return hash containing configuration

=head1 DESCRIPTION

All operators (including basic math operations) are overloaded if you
declare your big integers as

  $i = Math::BigInt -> new('123_456_789_123_456_789');

Operations with overloaded operators preserve the arguments which is
exactly what you expect.

=head2 Input

Input values to these routines may be any string, that looks like a number
and results in an integer, including hexadecimal and binary numbers.

Scalars holding numbers may also be passed, but note that non-integer numbers
may already have lost precision due to the conversion to float. Quote
your input if you want BigInt to see all the digits:

        $x = Math::BigInt->new(12345678890123456789);   # bad
        $x = Math::BigInt->new('12345678901234567890'); # good

You can include one underscore between any two digits.

This means integer values like 1.01E2 or even 1000E-2 are also accepted.
Non-integer values result in NaN.

Hexadecimal (prefixed with "0x") and binary numbers (prefixed with "0b")
are accepted, too. Please note that octal numbers are not recognized
by new(), so the following will print "123":

        perl -MMath::BigInt -le 'print Math::BigInt->new("0123")'

To convert an octal number, use from_oct();

        perl -MMath::BigInt -le 'print Math::BigInt->from_oct("0123")'

Currently, Math::BigInt::new() defaults to 0, while Math::BigInt::new('')
results in 'NaN'. This might change in the future, so use always the following
explicit forms to get a zero or NaN:

        $zero = Math::BigInt->bzero();
        $nan = Math::BigInt->bnan();

C<bnorm()> on a BigInt object is now effectively a no-op, since the numbers
are always stored in normalized form. If passed a string, creates a BigInt
object from the input.

=head2 Output

Output values are BigInt objects (normalized), except for the methods which
return a string (see L</SYNOPSIS>).

Some routines (C<is_odd()>, C<is_even()>, C<is_zero()>, C<is_one()>,
C<is_nan()>, etc.) return true or false, while others (C<bcmp()>, C<bacmp()>)
return either undef (if NaN is involved), <0, 0 or >0 and are suited for sort.

=head1 METHODS

Each of the methods below (except config(), accuracy() and precision())
accepts three additional parameters. These arguments C<$A>, C<$P> and C<$R>
are C<accuracy>, C<precision> and C<round_mode>. Please see the section about
L</ACCURACY and PRECISION> for more information.

=over

=item config()

    use Data::Dumper;

    print Dumper ( Math::BigInt->config() );
    print Math::BigInt->config()->{lib},"\n";

Returns a hash containing the configuration, e.g. the version number, lib
loaded etc. The following hash keys are currently filled in with the
appropriate information.

    key           Description
                  Example
    ============================================================
    lib           Name of the low-level math library
                  Math::BigInt::Calc
    lib_version   Version of low-level math library (see 'lib')
                  0.30
    class         The class name of config() you just called
                  Math::BigInt
    upgrade       To which class math operations might be
                  upgraded Math::BigFloat
    downgrade     To which class math operations might be
                  downgraded undef
    precision     Global precision
                  undef
    accuracy      Global accuracy
                  undef
    round_mode    Global round mode
                  even
    version       version number of the class you used
                  1.61
    div_scale     Fallback accuracy for div
                  40
    trap_nan      If true, traps creation of NaN via croak()
                  1
    trap_inf      If true, traps creation of +inf/-inf via croak()
                  1

The following values can be set by passing C<config()> a reference to a hash:

        trap_inf trap_nan
        upgrade downgrade precision accuracy round_mode div_scale

Example:

        $new_cfg = Math::BigInt->config(
            { trap_inf => 1, precision => 5 }
        );

=item accuracy()

    $x->accuracy(5);         # local for $x
    CLASS->accuracy(5);      # global for all members of CLASS
                             # Note: This also applies to new()!

    $A = $x->accuracy();     # read out accuracy that affects $x
    $A = CLASS->accuracy();  # read out global accuracy

Set or get the global or local accuracy, aka how many significant digits the
results have. If you set a global accuracy, then this also applies to new()!

Warning! The accuracy I<sticks>, e.g. once you created a number under the
influence of C<< CLASS->accuracy($A) >>, all results from math operations with
that number will also be rounded.

In most cases, you should probably round the results explicitly using one of
L</round()>, L</bround()> or L</bfround()> or by passing the desired accuracy
to the math operation as additional parameter:

    my $x = Math::BigInt->new(30000);
    my $y = Math::BigInt->new(7);
    print scalar $x->copy()->bdiv($y, 2);               # print 4300
    print scalar $x->copy()->bdiv($y)->bround(2);       # print 4300

Please see the section about L</ACCURACY and PRECISION> for further details.

Value must be greater than zero. Pass an undef value to disable it:

    $x->accuracy(undef);
    Math::BigInt->accuracy(undef);

Returns the current accuracy. For C<< $x->accuracy() >> it will return either
the local accuracy, or if not defined, the global. This means the return value
represents the accuracy that will be in effect for $x:

    $y = Math::BigInt->new(1234567);       # unrounded
    print Math::BigInt->accuracy(4),"\n";  # set 4, print 4
    $x = Math::BigInt->new(123456);        # $x will be automatic-
                                           # ally rounded!
    print "$x $y\n";                       # '123500 1234567'
    print $x->accuracy(),"\n";             # will be 4
    print $y->accuracy(),"\n";             # also 4, since
                                           # global is 4
    print Math::BigInt->accuracy(5),"\n";  # set to 5, print 5
    print $x->accuracy(),"\n";             # still 4
    print $y->accuracy(),"\n";             # 5, since global is 5

Note: Works also for subclasses like Math::BigFloat. Each class has it's own
globals separated from Math::BigInt, but it is possible to subclass
Math::BigInt and make the globals of the subclass aliases to the ones from
Math::BigInt.

=item precision()

    $x->precision(-2);          # local for $x, round at the second
                                # digit right of the dot
    $x->precision(2);           # ditto, round at the second digit
                                # left of the dot

    CLASS->precision(5);        # Global for all members of CLASS
                                # This also applies to new()!
    CLASS->precision(-5);       # ditto

    $P = CLASS->precision();    # read out global precision
    $P = $x->precision();       # read out precision that affects $x

Note: You probably want to use L</accuracy()> instead. With L</accuracy()> you
set the number of digits each result should have, with L</precision()> you
set the place where to round!

C<precision()> sets or gets the global or local precision, aka at which digit
before or after the dot to round all results. A set global precision also
applies to all newly created numbers!

In Math::BigInt, passing a negative number precision has no effect since no
numbers have digits after the dot. In L<Math::BigFloat>, it will round all
results to P digits after the dot.

Please see the section about L</ACCURACY and PRECISION> for further details.

Pass an undef value to disable it:

    $x->precision(undef);
    Math::BigInt->precision(undef);

Returns the current precision. For C<< $x->precision() >> it will return either
the local precision of $x, or if not defined, the global. This means the return
value represents the prevision that will be in effect for $x:

    $y = Math::BigInt->new(1234567);        # unrounded
    print Math::BigInt->precision(4),"\n";  # set 4, print 4
    $x = Math::BigInt->new(123456);  # will be automatically rounded
    print $x;                               # print "120000"!

Note: Works also for subclasses like L<Math::BigFloat>. Each class has its
own globals separated from Math::BigInt, but it is possible to subclass
Math::BigInt and make the globals of the subclass aliases to the ones from
Math::BigInt.

=item brsft()

    $x->brsft($y,$n);

Shifts $x right by $y in base $n. Default is base 2, used are usually 10 and
2, but others work, too.

Right shifting usually amounts to dividing $x by $n ** $y and truncating the
result:


    $x = Math::BigInt->new(10);
    $x->brsft(1);                       # same as $x >> 1: 5
    $x = Math::BigInt->new(1234);
    $x->brsft(2,10);                    # result 12

There is one exception, and that is base 2 with negative $x:


    $x = Math::BigInt->new(-5);
    print $x->brsft(1);

This will print -3, not -2 (as it would if you divide -5 by 2 and truncate the
result).

=item new()

    $x = Math::BigInt->new($str,$A,$P,$R);

Creates a new BigInt object from a scalar or another BigInt object. The
input is accepted as decimal, hex (with leading '0x') or binary (with leading
'0b').

See L</Input> for more info on accepted input formats.

=item from_oct()

    $x = Math::BigInt->from_oct("0775");      # input is octal

Interpret the input as an octal string and return the corresponding value. A
"0" (zero) prefix is optional. A single underscore character may be placed
right after the prefix, if present, or between any two digits. If the input is
invalid, a NaN is returned.

=item from_hex()

    $x = Math::BigInt->from_hex("0xcafe");    # input is hexadecimal

Interpret input as a hexadecimal string. A "0x" or "x" prefix is optional. A
single underscore character may be placed right after the prefix, if present,
or between any two digits. If the input is invalid, a NaN is returned.

=item from_bin()

    $x = Math::BigInt->from_bin("0b10011");   # input is binary

Interpret the input as a binary string. A "0b" or "b" prefix is optional. A
single underscore character may be placed right after the prefix, if present,
or between any two digits. If the input is invalid, a NaN is returned.

=item bnan()

    $x = Math::BigInt->bnan();

Creates a new BigInt object representing NaN (Not A Number).
If used on an object, it will set it to NaN:

    $x->bnan();

=item bzero()

    $x = Math::BigInt->bzero();

Creates a new BigInt object representing zero.
If used on an object, it will set it to zero:

    $x->bzero();

=item binf()

    $x = Math::BigInt->binf($sign);

Creates a new BigInt object representing infinity. The optional argument is
either '-' or '+', indicating whether you want infinity or minus infinity.
If used on an object, it will set it to infinity:

    $x->binf();
    $x->binf('-');

=item bone()

    $x = Math::BigInt->binf($sign);

Creates a new BigInt object representing one. The optional argument is
either '-' or '+', indicating whether you want one or minus one.
If used on an object, it will set it to one:

    $x->bone();         # +1
    $x->bone('-');              # -1

=item is_one()/is_zero()/is_nan()/is_inf()

    $x->is_zero();              # true if arg is +0
    $x->is_nan();               # true if arg is NaN
    $x->is_one();               # true if arg is +1
    $x->is_one('-');            # true if arg is -1
    $x->is_inf();               # true if +inf
    $x->is_inf('-');            # true if -inf (sign is default '+')

These methods all test the BigInt for being one specific value and return
true or false depending on the input. These are faster than doing something
like:

    if ($x == 0)

=item is_pos()/is_neg()/is_positive()/is_negative()

    $x->is_pos();                       # true if > 0
    $x->is_neg();                       # true if < 0

The methods return true if the argument is positive or negative, respectively.
C<NaN> is neither positive nor negative, while C<+inf> counts as positive, and
C<-inf> is negative. A C<zero> is neither positive nor negative.

These methods are only testing the sign, and not the value.

C<is_positive()> and C<is_negative()> are aliases to C<is_pos()> and
C<is_neg()>, respectively. C<is_positive()> and C<is_negative()> were
introduced in v1.36, while C<is_pos()> and C<is_neg()> were only introduced
in v1.68.

=item is_odd()/is_even()/is_int()

    $x->is_odd();               # true if odd, false for even
    $x->is_even();              # true if even, false for odd
    $x->is_int();               # true if $x is an integer

The return true when the argument satisfies the condition. C<NaN>, C<+inf>,
C<-inf> are not integers and are neither odd nor even.

In BigInt, all numbers except C<NaN>, C<+inf> and C<-inf> are integers.

=item bcmp()

    $x->bcmp($y);

Compares $x with $y and takes the sign into account.
Returns -1, 0, 1 or undef.

=item bacmp()

    $x->bacmp($y);

Compares $x with $y while ignoring their sign. Returns -1, 0, 1 or undef.

=item sign()

    $x->sign();

Return the sign, of $x, meaning either C<+>, C<->, C<-inf>, C<+inf> or NaN.

If you want $x to have a certain sign, use one of the following methods:

    $x->babs();                 # '+'
    $x->babs()->bneg();         # '-'
    $x->bnan();                 # 'NaN'
    $x->binf();                 # '+inf'
    $x->binf('-');              # '-inf'

=item digit()

    $x->digit($n);       # return the nth digit, counting from right

If C<$n> is negative, returns the digit counting from left.

=item bneg()

    $x->bneg();

Negate the number, e.g. change the sign between '+' and '-', or between '+inf'
and '-inf', respectively. Does nothing for NaN or zero.

=item babs()

    $x->babs();

Set the number to its absolute value, e.g. change the sign from '-' to '+'
and from '-inf' to '+inf', respectively. Does nothing for NaN or positive
numbers.

=item bsgn()

    $x->bsgn();

Signum function. Set the number to -1, 0, or 1, depending on whether the
number is negative, zero, or positive, respectively. Does not modify NaNs.

=item bnorm()

    $x->bnorm();                        # normalize (no-op)

=item bnot()

    $x->bnot();

Two's complement (bitwise not). This is equivalent to

    $x->binc()->bneg();

but faster.

=item binc()

    $x->binc();                 # increment x by 1

=item bdec()

    $x->bdec();                 # decrement x by 1

=item badd()

    $x->badd($y);               # addition (add $y to $x)

=item bsub()

    $x->bsub($y);               # subtraction (subtract $y from $x)

=item bmul()

    $x->bmul($y);               # multiplication (multiply $x by $y)

=item bmuladd()

    $x->bmuladd($y,$z);

Multiply $x by $y, and then add $z to the result,

This method was added in v1.87 of Math::BigInt (June 2007).

=item bdiv()

    $x->bdiv($y);               # divide, set $x to quotient

Returns $x divided by $y. In list context, does floored division (F-division),
where the quotient is the greatest integer less than or equal to the quotient
of the two operands. Consequently, the remainder is either zero or has the same
sign as the second operand. In scalar context, only the quotient is returned.

=item bmod()

    $x->bmod($y);               # modulus (x % y)

Returns $x modulo $y. When $x is finite, and $y is finite and non-zero, the
result is identical to the remainder after floored division (F-division), i.e.,
identical to the result from Perl's % operator.

=item bmodinv()

    $x->bmodinv($mod);          # modular multiplicative inverse

Returns the multiplicative inverse of C<$x> modulo C<$mod>. If

    $y = $x -> copy() -> bmodinv($mod)

then C<$y> is the number closest to zero, and with the same sign as C<$mod>,
satisfying

    ($x * $y) % $mod = 1 % $mod

If C<$x> and C<$y> are non-zero, they must be relative primes, i.e.,
C<bgcd($y, $mod)==1>. 'C<NaN>' is returned when no modular multiplicative
inverse exists.

=item bmodpow()

    $num->bmodpow($exp,$mod);           # modular exponentiation
                                        # ($num**$exp % $mod)

Returns the value of C<$num> taken to the power C<$exp> in the modulus
C<$mod> using binary exponentiation.  C<bmodpow> is far superior to
writing

    $num ** $exp % $mod

because it is much faster - it reduces internal variables into
the modulus whenever possible, so it operates on smaller numbers.

C<bmodpow> also supports negative exponents.

    bmodpow($num, -1, $mod)

is exactly equivalent to

    bmodinv($num, $mod)

=item bpow()

    $x->bpow($y);                     # power of arguments (x ** y)

=item blog()

    $x->blog($base, $accuracy);   # logarithm of x to the base $base

If C<$base> is not defined, Euler's number (e) is used:

    print $x->blog(undef, 100);       # log(x) to 100 digits

=item bexp()

    $x->bexp($accuracy);              # calculate e ** X

Calculates the expression C<e ** $x> where C<e> is Euler's number.

This method was added in v1.82 of Math::BigInt (April 2007).

See also L</blog()>.

=item bnok()

    $x->bnok($y);         # x over y (binomial coefficient n over k)

Calculates the binomial coefficient n over k, also called the "choose"
function. The result is equivalent to:

        ( n )      n!
        | - |  = -------
        ( k )    k!(n-k)!

This method was added in v1.84 of Math::BigInt (April 2007).

=item bpi()

    print Math::BigInt->bpi(100), "\n";         # 3

Returns PI truncated to an integer, with the argument being ignored. This means
under BigInt this always returns C<3>.

If upgrading is in effect, returns PI, rounded to N digits with the
current rounding mode:

    use Math::BigFloat;
    use Math::BigInt upgrade => Math::BigFloat;
    print Math::BigInt->bpi(3), "\n";           # 3.14
    print Math::BigInt->bpi(100), "\n";         # 3.1415....

This method was added in v1.87 of Math::BigInt (June 2007).

=item bcos()

    my $x = Math::BigInt->new(1);
    print $x->bcos(100), "\n";

Calculate the cosinus of $x, modifying $x in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=item bsin()

    my $x = Math::BigInt->new(1);
    print $x->bsin(100), "\n";

Calculate the sinus of $x, modifying $x in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=item batan2()

    my $x = Math::BigInt->new(1);
    my $y = Math::BigInt->new(1);
    print $y->batan2($x), "\n";

Calculate the arcus tangens of C<$y> divided by C<$x>, modifying $y in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=item batan()

    my $x = Math::BigFloat->new(0.5);
    print $x->batan(100), "\n";

Calculate the arcus tangens of $x, modifying $x in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=item blsft()

    $x->blsft($y);              # left shift in base 2
    $x->blsft($y,$n);           # left shift, in base $n (like 10)

=item brsft()

    $x->brsft($y);              # right shift in base 2
    $x->brsft($y,$n);           # right shift, in base $n (like 10)

=item band()

    $x->band($y);               # bitwise and

=item bior()

    $x->bior($y);               # bitwise inclusive or

=item bxor()

    $x->bxor($y);               # bitwise exclusive or

=item bnot()

    $x->bnot();                 # bitwise not (two's complement)

=item bsqrt()

    $x->bsqrt();                # calculate square-root

=item broot()

    $x->broot($N);

Calculates the N'th root of C<$x>.

=item bfac()

    $x->bfac();                 # factorial of $x (1*2*3*4*..$x)

=item round()

    $x->round($A,$P,$round_mode);

Round $x to accuracy C<$A> or precision C<$P> using the round mode
C<$round_mode>.

=item bround()

    $x->bround($N);               # accuracy: preserve $N digits

=item bfround()

    $x->bfround($N);

If N is > 0, rounds to the Nth digit from the left. If N < 0, rounds to
the Nth digit after the dot. Since BigInts are integers, the case N < 0
is a no-op for them.

Examples:

        Input           N               Result
        ===================================================
        123456.123456   3               123500
        123456.123456   2               123450
        123456.123456   -2              123456.12
        123456.123456   -3              123456.123

=item bfloor()

    $x->bfloor();

Round $x towards minus infinity (i.e., set $x to the largest integer less than
or equal to $x). This is a no-op in BigInt, but changes $x in BigFloat, if $x
is not an integer.

=item bceil()

    $x->bceil();

Round $x towards plus infinity (i.e., set $x to the smallest integer greater
than or equal to $x). This is a no-op in BigInt, but changes $x in BigFloat, if
$x is not an integer.

=item bint()

    $x->bint();

Round $x towards zero. This is a no-op in BigInt, but changes $x in BigFloat,
if $x is not an integer.

=item bgcd()

    bgcd(@@values);           # greatest common divisor (no OO style)

=item blcm()

    blcm(@@values);           # lowest common multiple (no OO style)

=item length()

    $x->length();
    ($xl,$fl) = $x->length();

Returns the number of digits in the decimal representation of the number.
In list context, returns the length of the integer and fraction part. For
BigInt's, the length of the fraction part will always be 0.

=item exponent()

    $x->exponent();

Return the exponent of $x as BigInt.

=item mantissa()

    $x->mantissa();

Return the signed mantissa of $x as BigInt.

=item parts()

    $x->parts();        # return (mantissa,exponent) as BigInt

=item copy()

    $x->copy();         # make a true copy of $x (unlike $y = $x;)

=item as_int()

=item as_number()

These methods are called when Math::BigInt encounters an object it doesn't know
how to handle. For instance, assume $x is a Math::BigInt, or subclass thereof,
and $y is defined, but not a Math::BigInt, or subclass thereof. If you do

    $x -> badd($y);

$y needs to be converted into an object that $x can deal with. This is done by
first checking if $y is something that $x might be upgraded to. If that is the
case, no further attempts are made. The next is to see if $y supports the
method C<as_int()>. If it does, C<as_int()> is called, but if it doesn't, the
next thing is to see if $y supports the method C<as_number()>. If it does,
C<as_number()> is called. The method C<as_int()> (and C<as_number()>) is
expected to return either an object that has the same class as $x, a subclass
thereof, or a string that C<ref($x)-E<gt>new()> can parse to create an object.

C<as_number()> is an alias to C<as_int()>. C<as_number> was introduced in
v1.22, while C<as_int()> was introduced in v1.68.

In Math::BigInt, C<as_int()> has the same effect as C<copy()>.

=item bstr()

    $x->bstr();

Returns a normalized string representation of C<$x>.

=item bsstr()

    $x->bsstr();     # normalized string in scientific notation

=item as_hex()

    $x->as_hex();    # as signed hexadecimal string with prefixed 0x

=item as_bin()

    $x->as_bin();    # as signed binary string with prefixed 0b

=item as_oct()

    $x->as_oct();    # as signed octal string with prefixed 0

=item numify()

        print $x->numify();

This returns a normal Perl scalar from $x. It is used automatically
whenever a scalar is needed, for instance in array index operations.

This loses precision, to avoid this use L</as_int()> instead.

=item modify()

    $x->modify('bpowd');

This method returns 0 if the object can be modified with the given
operation, or 1 if not.

This is used for instance by L<Math::BigInt::Constant>.

=item upgrade()/downgrade()

Set/get the class for downgrade/upgrade operations. Thuis is used
for instance by L<bignum>. The defaults are '', thus the following
operation will create a BigInt, not a BigFloat:

        my $i = Math::BigInt->new(123);
        my $f = Math::BigFloat->new('123.1');

        print $i + $f,"\n";                     # print 246

=item div_scale()

Set/get the number of digits for the default precision in divide
operations.

=item round_mode()

Set/get the current round mode.

=back

=head1 ACCURACY and PRECISION

Since version v1.33, Math::BigInt and Math::BigFloat have full support for
accuracy and precision based rounding, both automatically after every
operation, as well as manually.

This section describes the accuracy/precision handling in Math::Big* as it
used to be and as it is now, complete with an explanation of all terms and
abbreviations.

Not yet implemented things (but with correct description) are marked with '!',
things that need to be answered are marked with '?'.

In the next paragraph follows a short description of terms used here (because
these may differ from terms used by others people or documentation).

During the rest of this document, the shortcuts A (for accuracy), P (for
precision), F (fallback) and R (rounding mode) will be used.

=head2 Precision P

A fixed number of digits before (positive) or after (negative)
the decimal point. For example, 123.45 has a precision of -2. 0 means an
integer like 123 (or 120). A precision of 2 means two digits to the left
of the decimal point are zero, so 123 with P = 1 becomes 120. Note that
numbers with zeros before the decimal point may have different precisions,
because 1200 can have p = 0, 1 or 2 (depending on what the initial value
was). It could also have p < 0, when the digits after the decimal point
are zero.

The string output (of floating point numbers) will be padded with zeros:

        Initial value   P       A       Result          String
        ------------------------------------------------------------
        1234.01         -3              1000            1000
        1234            -2              1200            1200
        1234.5          -1              1230            1230
        1234.001        1               1234            1234.0
        1234.01         0               1234            1234
        1234.01         2               1234.01         1234.01
        1234.01         5               1234.01         1234.01000

For BigInts, no padding occurs.

=head2 Accuracy A

Number of significant digits. Leading zeros are not counted. A
number may have an accuracy greater than the non-zero digits
when there are zeros in it or trailing zeros. For example, 123.456 has
A of 6, 10203 has 5, 123.0506 has 7, 123.450000 has 8 and 0.000123 has 3.

The string output (of floating point numbers) will be padded with zeros:

        Initial value   P       A       Result          String
        ------------------------------------------------------------
        1234.01                 3       1230            1230
        1234.01                 6       1234.01         1234.01
        1234.1                  8       1234.1          1234.1000

For BigInts, no padding occurs.

=head2 Fallback F

When both A and P are undefined, this is used as a fallback accuracy when
dividing numbers.

=head2 Rounding mode R

When rounding a number, different 'styles' or 'kinds'
of rounding are possible. (Note that random rounding, as in
Math::Round, is not implemented.)

=over

=item 'trunc'

truncation invariably removes all digits following the
rounding place, replacing them with zeros. Thus, 987.65 rounded
to tens (P=1) becomes 980, and rounded to the fourth sigdig
becomes 987.6 (A=4). 123.456 rounded to the second place after the
decimal point (P=-2) becomes 123.46.

All other implemented styles of rounding attempt to round to the
"nearest digit." If the digit D immediately to the right of the
rounding place (skipping the decimal point) is greater than 5, the
number is incremented at the rounding place (possibly causing a
cascade of incrementation): e.g. when rounding to units, 0.9 rounds
to 1, and -19.9 rounds to -20. If D < 5, the number is similarly
truncated at the rounding place: e.g. when rounding to units, 0.4
rounds to 0, and -19.4 rounds to -19.

However the results of other styles of rounding differ if the
digit immediately to the right of the rounding place (skipping the
decimal point) is 5 and if there are no digits, or no digits other
than 0, after that 5. In such cases:

=item 'even'

rounds the digit at the rounding place to 0, 2, 4, 6, or 8
if it is not already. E.g., when rounding to the first sigdig, 0.45
becomes 0.4, -0.55 becomes -0.6, but 0.4501 becomes 0.5.

=item 'odd'

rounds the digit at the rounding place to 1, 3, 5, 7, or 9 if
it is not already. E.g., when rounding to the first sigdig, 0.45
becomes 0.5, -0.55 becomes -0.5, but 0.5501 becomes 0.6.

=item '+inf'

round to plus infinity, i.e. always round up. E.g., when
rounding to the first sigdig, 0.45 becomes 0.5, -0.55 becomes -0.5,
and 0.4501 also becomes 0.5.

=item '-inf'

round to minus infinity, i.e. always round down. E.g., when
rounding to the first sigdig, 0.45 becomes 0.4, -0.55 becomes -0.6,
but 0.4501 becomes 0.5.

=item 'zero'

round to zero, i.e. positive numbers down, negative ones up.
E.g., when rounding to the first sigdig, 0.45 becomes 0.4, -0.55
becomes -0.5, but 0.4501 becomes 0.5.

=item 'common'

round up if the digit immediately to the right of the rounding place
is 5 or greater, otherwise round down. E.g., 0.15 becomes 0.2 and
0.149 becomes 0.1.

=back

The handling of A & P in MBI/MBF (the old core code shipped with Perl
versions <= 5.7.2) is like this:

=over

=item Precision

  * bfround($p) is able to round to $p number of digits after the decimal
    point
  * otherwise P is unused

=item Accuracy (significant digits)

  * bround($a) rounds to $a significant digits
  * only bdiv() and bsqrt() take A as (optional) parameter
    + other operations simply create the same number (bneg etc), or
      more (bmul) of digits
    + rounding/truncating is only done when explicitly calling one
      of bround or bfround, and never for BigInt (not implemented)
  * bsqrt() simply hands its accuracy argument over to bdiv.
  * the documentation and the comment in the code indicate two
    different ways on how bdiv() determines the maximum number
    of digits it should calculate, and the actual code does yet
    another thing
    POD:
      max($Math::BigFloat::div_scale,length(dividend)+length(divisor))
    Comment:
      result has at most max(scale, length(dividend), length(divisor)) digits
    Actual code:
      scale = max(scale, length(dividend)-1,length(divisor)-1);
      scale += length(divisor) - length(dividend);
    So for lx = 3, ly = 9, scale = 10, scale will actually be 16 (10
    So for lx = 3, ly = 9, scale = 10, scale will actually be 16
    (10+9-3). Actually, the 'difference' added to the scale is cal-
    culated from the number of "significant digits" in dividend and
    divisor, which is derived by looking at the length of the man-
    tissa. Which is wrong, since it includes the + sign (oops) and
    actually gets 2 for '+100' and 4 for '+101'. Oops again. Thus
    124/3 with div_scale=1 will get you '41.3' based on the strange
    assumption that 124 has 3 significant digits, while 120/7 will
    get you '17', not '17.1' since 120 is thought to have 2 signif-
    icant digits. The rounding after the division then uses the
    remainder and $y to determine whether it must round up or down.
 ?  I have no idea which is the right way. That's why I used a slightly more
 ?  simple scheme and tweaked the few failing testcases to match it.

=back

This is how it works now:

=over

=item Setting/Accessing

  * You can set the A global via Math::BigInt->accuracy() or
    Math::BigFloat->accuracy() or whatever class you are using.
  * You can also set P globally by using Math::SomeClass->precision()
    likewise.
  * Globals are classwide, and not inherited by subclasses.
  * to undefine A, use Math::SomeCLass->accuracy(undef);
  * to undefine P, use Math::SomeClass->precision(undef);
  * Setting Math::SomeClass->accuracy() clears automatically
    Math::SomeClass->precision(), and vice versa.
  * To be valid, A must be > 0, P can have any value.
  * If P is negative, this means round to the P'th place to the right of the
    decimal point; positive values mean to the left of the decimal point.
    P of 0 means round to integer.
  * to find out the current global A, use Math::SomeClass->accuracy()
  * to find out the current global P, use Math::SomeClass->precision()
  * use $x->accuracy() respective $x->precision() for the local
    setting of $x.
  * Please note that $x->accuracy() respective $x->precision()
    return eventually defined global A or P, when $x's A or P is not
    set.

=item Creating numbers

  * When you create a number, you can give the desired A or P via:
    $x = Math::BigInt->new($number,$A,$P);
  * Only one of A or P can be defined, otherwise the result is NaN
  * If no A or P is give ($x = Math::BigInt->new($number) form), then the
    globals (if set) will be used. Thus changing the global defaults later on
    will not change the A or P of previously created numbers (i.e., A and P of
    $x will be what was in effect when $x was created)
  * If given undef for A and P, NO rounding will occur, and the globals will
    NOT be used. This is used by subclasses to create numbers without
    suffering rounding in the parent. Thus a subclass is able to have its own
    globals enforced upon creation of a number by using
    $x = Math::BigInt->new($number,undef,undef):

        use Math::BigInt::SomeSubclass;
        use Math::BigInt;

        Math::BigInt->accuracy(2);
        Math::BigInt::SomeSubClass->accuracy(3);
        $x = Math::BigInt::SomeSubClass->new(1234);

    $x is now 1230, and not 1200. A subclass might choose to implement
    this otherwise, e.g. falling back to the parent's A and P.

=item Usage

  * If A or P are enabled/defined, they are used to round the result of each
    operation according to the rules below
  * Negative P is ignored in Math::BigInt, since BigInts never have digits
    after the decimal point
  * Math::BigFloat uses Math::BigInt internally, but setting A or P inside
    Math::BigInt as globals does not tamper with the parts of a BigFloat.
    A flag is used to mark all Math::BigFloat numbers as 'never round'.

=item Precedence

  * It only makes sense that a number has only one of A or P at a time.
    If you set either A or P on one object, or globally, the other one will
    be automatically cleared.
  * If two objects are involved in an operation, and one of them has A in
    effect, and the other P, this results in an error (NaN).
  * A takes precedence over P (Hint: A comes before P).
    If neither of them is defined, nothing is used, i.e. the result will have
    as many digits as it can (with an exception for bdiv/bsqrt) and will not
    be rounded.
  * There is another setting for bdiv() (and thus for bsqrt()). If neither of
    A or P is defined, bdiv() will use a fallback (F) of $div_scale digits.
    If either the dividend's or the divisor's mantissa has more digits than
    the value of F, the higher value will be used instead of F.
    This is to limit the digits (A) of the result (just consider what would
    happen with unlimited A and P in the case of 1/3 :-)
  * bdiv will calculate (at least) 4 more digits than required (determined by
    A, P or F), and, if F is not used, round the result
    (this will still fail in the case of a result like 0.12345000000001 with A
    or P of 5, but this can not be helped - or can it?)
  * Thus you can have the math done by on Math::Big* class in two modi:
    + never round (this is the default):
      This is done by setting A and P to undef. No math operation
      will round the result, with bdiv() and bsqrt() as exceptions to guard
      against overflows. You must explicitly call bround(), bfround() or
      round() (the latter with parameters).
      Note: Once you have rounded a number, the settings will 'stick' on it
      and 'infect' all other numbers engaged in math operations with it, since
      local settings have the highest precedence. So, to get SaferRound[tm],
      use a copy() before rounding like this:

        $x = Math::BigFloat->new(12.34);
        $y = Math::BigFloat->new(98.76);
        $z = $x * $y;                           # 1218.6984
        print $x->copy()->bround(3);            # 12.3 (but A is now 3!)
        $z = $x * $y;                           # still 1218.6984, without
                                                # copy would have been 1210!

    + round after each op:
      After each single operation (except for testing like is_zero()), the
      method round() is called and the result is rounded appropriately. By
      setting proper values for A and P, you can have all-the-same-A or
      all-the-same-P modes. For example, Math::Currency might set A to undef,
      and P to -2, globally.

 ?Maybe an extra option that forbids local A & P settings would be in order,
 ?so that intermediate rounding does not 'poison' further math?

=item Overriding globals

  * you will be able to give A, P and R as an argument to all the calculation
    routines; the second parameter is A, the third one is P, and the fourth is
    R (shift right by one for binary operations like badd). P is used only if
    the first parameter (A) is undefined. These three parameters override the
    globals in the order detailed as follows, i.e. the first defined value
    wins:
    (local: per object, global: global default, parameter: argument to sub)
      + parameter A
      + parameter P
      + local A (if defined on both of the operands: smaller one is taken)
      + local P (if defined on both of the operands: bigger one is taken)
      + global A
      + global P
      + global F
  * bsqrt() will hand its arguments to bdiv(), as it used to, only now for two
    arguments (A and P) instead of one

=item Local settings

  * You can set A or P locally by using $x->accuracy() or
    $x->precision()
    and thus force different A and P for different objects/numbers.
  * Setting A or P this way immediately rounds $x to the new value.
  * $x->accuracy() clears $x->precision(), and vice versa.

=item Rounding

  * the rounding routines will use the respective global or local settings.
    bround() is for accuracy rounding, while bfround() is for precision
  * the two rounding functions take as the second parameter one of the
    following rounding modes (R):
    'even', 'odd', '+inf', '-inf', 'zero', 'trunc', 'common'
  * you can set/get the global R by using Math::SomeClass->round_mode()
    or by setting $Math::SomeClass::round_mode
  * after each operation, $result->round() is called, and the result may
    eventually be rounded (that is, if A or P were set either locally,
    globally or as parameter to the operation)
  * to manually round a number, call $x->round($A,$P,$round_mode);
    this will round the number by using the appropriate rounding function
    and then normalize it.
  * rounding modifies the local settings of the number:

        $x = Math::BigFloat->new(123.456);
        $x->accuracy(5);
        $x->bround(4);

    Here 4 takes precedence over 5, so 123.5 is the result and $x->accuracy()
    will be 4 from now on.

=item Default values

  * R: 'even'
  * F: 40
  * A: undef
  * P: undef

=item Remarks

  * The defaults are set up so that the new code gives the same results as
    the old code (except in a few cases on bdiv):
    + Both A and P are undefined and thus will not be used for rounding
      after each operation.
    + round() is thus a no-op, unless given extra parameters A and P

=back

=head1 Infinity and Not a Number

While BigInt has extensive handling of inf and NaN, certain quirks remain.

=over

=item oct()/hex()

These perl routines currently (as of Perl v.5.8.6) cannot handle passed
inf.

        te@@linux:~> perl -wle 'print 2 ** 3333'
        Inf
        te@@linux:~> perl -wle 'print 2 ** 3333 == 2 ** 3333'
        1
        te@@linux:~> perl -wle 'print oct(2 ** 3333)'
        0
        te@@linux:~> perl -wle 'print hex(2 ** 3333)'
        Illegal hexadecimal digit 'I' ignored at -e line 1.
        0

The same problems occur if you pass them Math::BigInt->binf() objects. Since
overloading these routines is not possible, this cannot be fixed from BigInt.

=item ==, !=, <, >, <=, >= with NaNs

BigInt's bcmp() routine currently returns undef to signal that a NaN was
involved in a comparison. However, the overload code turns that into
either 1 or '' and thus operations like C<< NaN != NaN >> might return
wrong values.

=item log(-inf)

C<< log(-inf) >> is highly weird. Since log(-x)=pi*i+log(x), then
log(-inf)=pi*i+inf. However, since the imaginary part is finite, the real
infinity "overshadows" it, so the number might as well just be infinity.
However, the result is a complex number, and since BigInt/BigFloat can only
have real numbers as results, the result is NaN.

=item exp(), cos(), sin(), atan2()

These all might have problems handling infinity right.

=back

=head1 INTERNALS

The actual numbers are stored as unsigned big integers (with separate sign).

You should neither care about nor depend on the internal representation; it
might change without notice. Use B<ONLY> method calls like C<< $x->sign(); >>
instead relying on the internal representation.

=head2 MATH LIBRARY

Math with the numbers is done (by default) by a module called
C<Math::BigInt::Calc>. This is equivalent to saying:

        use Math::BigInt try => 'Calc';

You can change this backend library by using:

        use Math::BigInt try => 'GMP';

B<Note>: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.

If your script works with huge numbers and Calc is too slow for them,
you can also for the loading of one of these libraries and if none
of them can be used, the code will die:

        use Math::BigInt only => 'GMP,Pari';

The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:

        use Math::BigInt try => 'Foo,Math::BigInt::Bar';

The library that is loaded last will be used. Note that this can be
overwritten at any time by loading a different library, and numbers
constructed with different libraries cannot be used in math operations
together.

=head3 What library to use?

B<Note>: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.

L<Math::BigInt::GMP> and L<Math::BigInt::Pari> are in cases involving big
numbers much faster than Calc, however it is slower when dealing with very
small numbers (less than about 20 digits) and when converting very large
numbers to decimal (for instance for printing, rounding, calculating their
length in decimal etc).

So please select carefully what library you want to use.

Different low-level libraries use different formats to store the numbers.
However, you should B<NOT> depend on the number having a specific format
internally.

See the respective math library module documentation for further details.

=head2 SIGN

The sign is either '+', '-', 'NaN', '+inf' or '-inf'.

A sign of 'NaN' is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '-inf' represent plus respectively
minus infinity. You will get '+inf' when dividing a positive number by 0, and
'-inf' when dividing any negative number by 0.

=head2 mantissa(), exponent() and parts()

C<mantissa()> and C<exponent()> return the said parts of the BigInt such
that:

        $m = $x->mantissa();
        $e = $x->exponent();
        $y = $m * ( 10 ** $e );
        print "ok\n" if $x == $y;

C<< ($m,$e) = $x->parts() >> is just a shortcut that gives you both of them
in one go. Both the returned mantissa and exponent have a sign.

Currently, for BigInts C<$e> is always 0, except +inf and -inf, where it is
C<+inf>; and for NaN, where it is C<NaN>; and for C<$x == 0>, where it is C<1>
(to be compatible with Math::BigFloat's internal representation of a zero as
C<0E1>).

C<$m> is currently just a copy of the original number. The relation between
C<$e> and C<$m> will stay always the same, though their real values might
change.

=head1 EXAMPLES

  use Math::BigInt;

  sub bigint { Math::BigInt->new(shift); }

  $x = Math::BigInt->bstr("1234")       # string "1234"
  $x = "$x";                            # same as bstr()
  $x = Math::BigInt->bneg("1234");      # BigInt "-1234"
  $x = Math::BigInt->babs("-12345");    # BigInt "12345"
  $x = Math::BigInt->bnorm("-0.00");    # BigInt "0"
  $x = bigint(1) + bigint(2);           # BigInt "3"
  $x = bigint(1) + "2";                 # ditto (auto-BigIntify of "2")
  $x = bigint(1);                       # BigInt "1"
  $x = $x + 5 / 2;                      # BigInt "3"
  $x = $x ** 3;                         # BigInt "27"
  $x *= 2;                              # BigInt "54"
  $x = Math::BigInt->new(0);            # BigInt "0"
  $x--;                                 # BigInt "-1"
  $x = Math::BigInt->badd(4,5)          # BigInt "9"
  print $x->bsstr();                    # 9e+0

Examples for rounding:

  use Math::BigFloat;
  use Test::More;

  $x = Math::BigFloat->new(123.4567);
  $y = Math::BigFloat->new(123.456789);
  Math::BigFloat->accuracy(4);          # no more A than 4

  is ($x->copy()->bround(),123.4);      # even rounding
  print $x->copy()->bround(),"\n";      # 123.4
  Math::BigFloat->round_mode('odd');    # round to odd
  print $x->copy()->bround(),"\n";      # 123.5
  Math::BigFloat->accuracy(5);          # no more A than 5
  Math::BigFloat->round_mode('odd');    # round to odd
  print $x->copy()->bround(),"\n";      # 123.46
  $y = $x->copy()->bround(4),"\n";      # A = 4: 123.4
  print "$y, ",$y->accuracy(),"\n";     # 123.4, 4

  Math::BigFloat->accuracy(undef);      # A not important now
  Math::BigFloat->precision(2);         # P important
  print $x->copy()->bnorm(),"\n";       # 123.46
  print $x->copy()->bround(),"\n";      # 123.46

Examples for converting:

  my $x = Math::BigInt->new('0b1'.'01' x 123);
  print "bin: ",$x->as_bin()," hex:",$x->as_hex()," dec: ",$x,"\n";

=head1 Autocreating constants

After C<use Math::BigInt ':constant'> all the B<integer> decimal, hexadecimal
and binary constants in the given scope are converted to C<Math::BigInt>.
This conversion happens at compile time.

In particular,

  perl -MMath::BigInt=:constant -e 'print 2**100,"\n"'

prints the integer value of C<2**100>. Note that without conversion of
constants the expression 2**100 will be calculated as perl scalar.

Please note that strings and floating point constants are not affected,
so that

        use Math::BigInt qw/:constant/;

        $x = 1234567890123456789012345678901234567890
                + 123456789123456789;
        $y = '1234567890123456789012345678901234567890'
                + '123456789123456789';

do not work. You need an explicit Math::BigInt->new() around one of the
operands. You should also quote large constants to protect loss of precision:

        use Math::BigInt;

        $x = Math::BigInt->new('1234567889123456789123456789123456789');

Without the quotes Perl would convert the large number to a floating point
constant at compile time and then hand the result to BigInt, which results in
an truncated result or a NaN.

This also applies to integers that look like floating point constants:

        use Math::BigInt ':constant';

        print ref(123e2),"\n";
        print ref(123.2e2),"\n";

will print nothing but newlines. Use either L<bignum> or L<Math::BigFloat>
to get this to work.

=head1 PERFORMANCE

Using the form $x += $y; etc over $x = $x + $y is faster, since a copy of $x
must be made in the second case. For long numbers, the copy can eat up to 20%
of the work (in the case of addition/subtraction, less for
multiplication/division). If $y is very small compared to $x, the form
$x += $y is MUCH faster than $x = $x + $y since making the copy of $x takes
more time then the actual addition.

With a technique called copy-on-write, the cost of copying with overload could
be minimized or even completely avoided. A test implementation of COW did show
performance gains for overloaded math, but introduced a performance loss due
to a constant overhead for all other operations. So Math::BigInt does currently
not COW.

The rewritten version of this module (vs. v0.01) is slower on certain
operations, like C<new()>, C<bstr()> and C<numify()>. The reason are that it
does now more work and handles much more cases. The time spent in these
operations is usually gained in the other math operations so that code on
the average should get (much) faster. If they don't, please contact the author.

Some operations may be slower for small numbers, but are significantly faster
for big numbers. Other operations are now constant (O(1), like C<bneg()>,
C<babs()> etc), instead of O(N) and thus nearly always take much less time.
These optimizations were done on purpose.

If you find the Calc module to slow, try to install any of the replacement
modules and see if they help you.

=head2 Alternative math libraries

You can use an alternative library to drive Math::BigInt. See the section
L</MATH LIBRARY> for more information.

For more benchmark results see L<http://bloodgate.com/perl/benchmarks.html>.

=head1 SUBCLASSING

=head2 Subclassing Math::BigInt

The basic design of Math::BigInt allows simple subclasses with very little
work, as long as a few simple rules are followed:

=over

=item *

The public API must remain consistent, i.e. if a sub-class is overloading
addition, the sub-class must use the same name, in this case badd(). The
reason for this is that Math::BigInt is optimized to call the object methods
directly.

=item *

The private object hash keys like C<< $x->{sign} >> may not be changed, but
additional keys can be added, like C<< $x->{_custom} >>.

=item *

Accessor functions are available for all existing object hash keys and should
be used instead of directly accessing the internal hash keys. The reason for
this is that Math::BigInt itself has a pluggable interface which permits it
to support different storage methods.

=back

More complex sub-classes may have to replicate more of the logic internal of
Math::BigInt if they need to change more basic behaviors. A subclass that
needs to merely change the output only needs to overload C<bstr()>.

All other object methods and overloaded functions can be directly inherited
from the parent class.

At the very minimum, any subclass will need to provide its own C<new()> and can
store additional hash keys in the object. There are also some package globals
that must be defined, e.g.:

  # Globals
  $accuracy = undef;
  $precision = -2;       # round to 2 decimal places
  $round_mode = 'even';
  $div_scale = 40;

Additionally, you might want to provide the following two globals to allow
auto-upgrading and auto-downgrading to work correctly:

  $upgrade = undef;
  $downgrade = undef;

This allows Math::BigInt to correctly retrieve package globals from the
subclass, like C<$SubClass::precision>.  See t/Math/BigInt/Subclass.pm or
t/Math/BigFloat/SubClass.pm completely functional subclass examples.

Don't forget to

        use overload;

in your subclass to automatically inherit the overloading from the parent. If
you like, you can change part of the overloading, look at Math::String for an
example.

=head1 UPGRADING

When used like this:

        use Math::BigInt upgrade => 'Foo::Bar';

certain operations will 'upgrade' their calculation and thus the result to
the class Foo::Bar. Usually this is used in conjunction with Math::BigFloat:

        use Math::BigInt upgrade => 'Math::BigFloat';

As a shortcut, you can use the module L<bignum>:

        use bignum;

Also good for one-liners:

        perl -Mbignum -le 'print 2 ** 255'

This makes it possible to mix arguments of different classes (as in 2.5 + 2)
as well es preserve accuracy (as in sqrt(3)).

Beware: This feature is not fully implemented yet.

=head2 Auto-upgrade

The following methods upgrade themselves unconditionally; that is if upgrade
is in effect, they will always hand up their work:

=over

=item bsqrt()

=item div()

=item blog()

=item bexp()

=item bpi()

=item bcos()

=item bsin()

=item batan2()

=item batan()

=back

All other methods upgrade themselves only when one (or all) of their
arguments are of the class mentioned in $upgrade.

=head1 EXPORTS

C<Math::BigInt> exports nothing by default, but can export the following methods:

        bgcd
        blcm

=head1 CAVEATS

Some things might not work as you expect them. Below is documented what is
known to be troublesome:

=over

=item bstr(), bsstr() and 'cmp'

Both C<bstr()> and C<bsstr()> as well as automated stringify via overload now
drop the leading '+'. The old code would return '+3', the new returns '3'.
This is to be consistent with Perl and to make C<cmp> (especially with
overloading) to work as you expect. It also solves problems with C<Test.pm>
and L<Test::More>, which stringify arguments before comparing them.

Mark Biggar said, when asked about to drop the '+' altogether, or make only
C<cmp> work:

        I agree (with the first alternative), don't add the '+' on positive
        numbers.  It's not as important anymore with the new internal
        form for numbers.  It made doing things like abs and neg easier,
        but those have to be done differently now anyway.

So, the following examples will now work all as expected:

        use Test::More tests => 1;
        use Math::BigInt;

        my $x = Math::BigInt -> new(3*3);
        my $y = Math::BigInt -> new(3*3);

        is ($x,3*3, 'multiplication');
        print "$x eq 9" if $x eq $y;
        print "$x eq 9" if $x eq '9';
        print "$x eq 9" if $x eq 3*3;

Additionally, the following still works:

        print "$x == 9" if $x == $y;
        print "$x == 9" if $x == 9;
        print "$x == 9" if $x == 3*3;

There is now a C<bsstr()> method to get the string in scientific notation aka
C<1e+2> instead of C<100>. Be advised that overloaded 'eq' always uses bstr()
for comparison, but Perl will represent some numbers as 100 and others
as 1e+308. If in doubt, convert both arguments to Math::BigInt before
comparing them as strings:

        use Test::More tests => 3;
        use Math::BigInt;

        $x = Math::BigInt->new('1e56'); $y = 1e56;
        is ($x,$y);                     # will fail
        is ($x->bsstr(),$y);            # okay
        $y = Math::BigInt->new($y);
        is ($x,$y);                     # okay

Alternatively, simply use C<< <=> >> for comparisons, this will get it
always right. There is not yet a way to get a number automatically represented
as a string that matches exactly the way Perl represents it.

See also the section about L<Infinity and Not a Number> for problems in
comparing NaNs.

=item int()

C<int()> will return (at least for Perl v5.7.1 and up) another BigInt, not a
Perl scalar:

        $x = Math::BigInt->new(123);
        $y = int($x);                           # BigInt 123
        $x = Math::BigFloat->new(123.45);
        $y = int($x);                           # BigInt 123

In all Perl versions you can use C<as_number()> or C<as_int> for the same
effect:

        $x = Math::BigFloat->new(123.45);
        $y = $x->as_number();                   # BigInt 123
        $y = $x->as_int();                      # ditto

This also works for other subclasses, like Math::String.

If you want a real Perl scalar, use C<numify()>:

        $y = $x->numify();                      # 123 as scalar

This is seldom necessary, though, because this is done automatically, like
when you access an array:

        $z = $array[$x];                        # does work automatically

=item length()

The following will probably not do what you expect:

        $c = Math::BigInt->new(123);
        print $c->length(),"\n";                # prints 30

It prints both the number of digits in the number and in the fraction part
since print calls C<length()> in list context. Use something like:

        print scalar $c->length(),"\n";         # prints 3

=item bdiv()

The following will probably not do what you expect:

        print $c->bdiv(10000),"\n";

It prints both quotient and remainder since print calls C<bdiv()> in list
context. Also, C<bdiv()> will modify $c, so be careful. You probably want
to use

        print $c / 10000,"\n";

or, if you want to  modify $c instead,

        print scalar $c->bdiv(10000),"\n";

The quotient is always the greatest integer less than or equal to the
real-valued quotient of the two operands, and the remainder (when it is
non-zero) always has the same sign as the second operand; so, for
example,

          1 / 4  => ( 0, 1)
          1 / -4 => (-1,-3)
         -3 / 4  => (-1, 1)
         -3 / -4 => ( 0,-3)
        -11 / 2  => (-5,1)
         11 /-2  => (-5,-1)

As a consequence, the behavior of the operator % agrees with the
behavior of Perl's built-in % operator (as documented in the perlop
manpage), and the equation

        $x == ($x / $y) * $y + ($x % $y)

holds true for any $x and $y, which justifies calling the two return
values of bdiv() the quotient and remainder. The only exception to this rule
are when $y == 0 and $x is negative, then the remainder will also be
negative. See below under "infinity handling" for the reasoning behind this.

Perl's 'use integer;' changes the behaviour of % and / for scalars, but will
not change BigInt's way to do things. This is because under 'use integer' Perl
will do what the underlying C thinks is right and this is different for each
system. If you need BigInt's behaving exactly like Perl's 'use integer', bug
the author to implement it ;)

=item infinity handling

Here are some examples that explain the reasons why certain results occur while
handling infinity:

The following table shows the result of the division and the remainder, so that
the equation above holds true. Some "ordinary" cases are strewn in to show more
clearly the reasoning:

        A /  B  =   C,     R so that C *    B +    R =    A
     =========================================================
        5 /   8 =   0,     5         0 *    8 +    5 =    5
        0 /   8 =   0,     0         0 *    8 +    0 =    0
        0 / inf =   0,     0         0 *  inf +    0 =    0
        0 /-inf =   0,     0         0 * -inf +    0 =    0
        5 / inf =   0,     5         0 *  inf +    5 =    5
        5 /-inf =   0,     5         0 * -inf +    5 =    5
        -5/ inf =   0,    -5         0 *  inf +   -5 =   -5
        -5/-inf =   0,    -5         0 * -inf +   -5 =   -5
       inf/   5 =  inf,    0       inf *    5 +    0 =  inf
      -inf/   5 = -inf,    0      -inf *    5 +    0 = -inf
       inf/  -5 = -inf,    0      -inf *   -5 +    0 =  inf
      -inf/  -5 =  inf,    0       inf *   -5 +    0 = -inf
         5/   5 =    1,    0         1 *    5 +    0 =    5
        -5/  -5 =    1,    0         1 *   -5 +    0 =   -5
       inf/ inf =    1,    0         1 *  inf +    0 =  inf
      -inf/-inf =    1,    0         1 * -inf +    0 = -inf
       inf/-inf =   -1,    0        -1 * -inf +    0 =  inf
      -inf/ inf =   -1,    0         1 * -inf +    0 = -inf
         8/   0 =  inf,    8       inf *    0 +    8 =    8
       inf/   0 =  inf,  inf       inf *    0 +  inf =  inf
         0/   0 =  NaN

These cases below violate the "remainder has the sign of the second of the two
arguments", since they wouldn't match up otherwise.

        A /  B  =   C,     R so that C *    B +    R =    A
     ========================================================
      -inf/   0 = -inf, -inf      -inf *    0 +  inf = -inf
        -8/   0 = -inf,   -8      -inf *    0 +    8 = -8

=item Modifying and =

Beware of:

        $x = Math::BigFloat->new(5);
        $y = $x;

It will not do what you think, e.g. making a copy of $x. Instead it just makes
a second reference to the B<same> object and stores it in $y. Thus anything
that modifies $x (except overloaded operators) will modify $y, and vice versa.
Or in other words, C<=> is only safe if you modify your BigInts only via
overloaded math. As soon as you use a method call it breaks:

        $x->bmul(2);
        print "$x, $y\n";       # prints '10, 10'

If you want a true copy of $x, use:

        $y = $x->copy();

You can also chain the calls like this, this will make first a copy and then
multiply it by 2:

        $y = $x->copy()->bmul(2);

See also the documentation for overload.pm regarding C<=>.

=item bpow

C<bpow()> (and the rounding functions) now modifies the first argument and
returns it, unlike the old code which left it alone and only returned the
result. This is to be consistent with C<badd()> etc. The first three will
modify $x, the last one won't:

        print bpow($x,$i),"\n";         # modify $x
        print $x->bpow($i),"\n";        # ditto
        print $x **= $i,"\n";           # the same
        print $x ** $i,"\n";            # leave $x alone

The form C<$x **= $y> is faster than C<$x = $x ** $y;>, though.

=item Overloading -$x

The following:

        $x = -$x;

is slower than

        $x->bneg();

since overload calls C<sub($x,0,1);> instead of C<neg($x)>. The first variant
needs to preserve $x since it does not know that it later will get overwritten.
This makes a copy of $x and takes O(N), but $x->bneg() is O(1).

=item Mixing different object types

With overloaded operators, it is the first (dominating) operand that determines
which method is called. Here are some examples showing what actually gets
called in various cases.

        use Math::BigInt;
        use Math::BigFloat;

        $mbf  = Math::BigFloat->new(5);
        $mbi2 = Math::BigInt->new(5);
        $mbi  = Math::BigInt->new(2);
                                        # what actually gets called:
        $float = $mbf + $mbi;           # $mbf->badd($mbi)
        $float = $mbf / $mbi;           # $mbf->bdiv($mbi)
        $integer = $mbi + $mbf;         # $mbi->badd($mbf)
        $integer = $mbi2 / $mbi;        # $mbi2->bdiv($mbi)
        $integer = $mbi2 / $mbf;        # $mbi2->bdiv($mbf)

For instance, Math::BigInt->bdiv() will always return a Math::BigInt, regardless of
whether the second operant is a Math::BigFloat. To get a Math::BigFloat you
either need to call the operation manually, make sure each operand already is a
Math::BigFloat, or cast to that type via Math::BigFloat->new():

        $float = Math::BigFloat->new($mbi2) / $mbi;     # = 2.5

Beware of casting the entire expression, as this would cast the
result, at which point it is too late:

        $float = Math::BigFloat->new($mbi2 / $mbi);     # = 2

Beware also of the order of more complicated expressions like:

        $integer = ($mbi2 + $mbi) / $mbf;               # int / float => int
        $integer = $mbi2 / Math::BigFloat->new($mbi);   # ditto

If in doubt, break the expression into simpler terms, or cast all operands
to the desired resulting type.

Scalar values are a bit different, since:

        $float = 2 + $mbf;
        $float = $mbf + 2;

will both result in the proper type due to the way the overloaded math works.

This section also applies to other overloaded math packages, like Math::String.

One solution to you problem might be autoupgrading|upgrading. See the
pragmas L<bignum>, L<bigint> and L<bigrat> for an easy way to do this.

=item bsqrt()

C<bsqrt()> works only good if the result is a big integer, e.g. the square
root of 144 is 12, but from 12 the square root is 3, regardless of rounding
mode. The reason is that the result is always truncated to an integer.

If you want a better approximation of the square root, then use:

        $x = Math::BigFloat->new(12);
        Math::BigFloat->precision(0);
        Math::BigFloat->round_mode('even');
        print $x->copy->bsqrt(),"\n";           # 4

        Math::BigFloat->precision(2);
        print $x->bsqrt(),"\n";                 # 3.46
        print $x->bsqrt(3),"\n";                # 3.464

=item brsft()

For negative numbers in base see also L<brsft|/brsft()>.

=back

=head1 BUGS

Please report any bugs or feature requests to
C<bug-math-bigint at rt.cpan.org>, or through the web interface at
L<https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt>
(requires login).
We will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Math::BigInt

You can also look for information at:

=over 4

=item * RT: CPAN's request tracker

L<https://rt.cpan.org/Public/Dist/Display.html?Name=Math-BigInt>

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Math-BigInt>

=item * CPAN Ratings

L<http://cpanratings.perl.org/dist/Math-BigInt>

=item * Search CPAN

L<http://search.cpan.org/dist/Math-BigInt/>

=item * CPAN Testers Matrix

L<http://matrix.cpantesters.org/?dist=Math-BigInt>

=item * The Bignum mailing list

=over 4

=item * Post to mailing list

C<bignum at lists.scsys.co.uk>

=item * View mailing list

L<http://lists.scsys.co.uk/pipermail/bignum/>

=item * Subscribe/Unsubscribe

L<http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/bignum>

=back

=back

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.

=head1 SEE ALSO

L<Math::BigFloat> and L<Math::BigRat> as well as the backends
L<Math::BigInt::FastCalc>, L<Math::BigInt::GMP>, and L<Math::BigInt::Pari>.

The pragmas L<bignum>, L<bigint> and L<bigrat> also might be of interest
because they solve the autoupgrading/downgrading issue, at least partly.

=head1 AUTHORS

=over 4

=item *

Mark Biggar, overloaded interface by Ilya Zakharevich, 1996-2001.

=item *

Completely rewritten by Tels L<http://bloodgate.com>, 2001-2008.

=item *

Florian Ragwitz E<lt>flora@@cpan.orgE<gt>, 2010.

=item *

Peter John Acklam E<lt>pjacklam@@online.noE<gt>, 2011-.

=back

Many people contributed in one or more ways to the final beast, see the file
CREDITS for an (incomplete) list. If you miss your name, please drop me a
mail. Thank you!

=cut
@


1.2
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d9 1
a9 1
#   value: unsigned int with actual value (as a Math::BigInt::Calc or similiar)
d18 3
a20 2
my $class = "Math::BigInt";
use 5.006;
d22 2
a23 1
$VERSION = '1.89_01';
d25 2
a26 2
@@ISA = qw(Exporter);
@@EXPORT_OK = qw(objectify bgcd blcm); 
d30 4
a33 3
use vars qw/$round_mode $accuracy $precision $div_scale $rnd_mode 
	    $upgrade $downgrade $_trap_nan $_trap_inf/;
use strict;
d36 1
a36 1
# it reversed (like $x = 2 * $y), then the third paramater is true.
d46 2
d54 12
a65 12
'+='	=>	sub { $_[0]->badd($_[1]); },
'-='	=>	sub { $_[0]->bsub($_[1]); },
'*='	=>	sub { $_[0]->bmul($_[1]); },
'/='	=>	sub { scalar $_[0]->bdiv($_[1]); },
'%='	=>	sub { $_[0]->bmod($_[1]); },
'^='	=>	sub { $_[0]->bxor($_[1]); },
'&='	=>	sub { $_[0]->band($_[1]); },
'|='	=>	sub { $_[0]->bior($_[1]); },

'**='	=>	sub { $_[0]->bpow($_[1]); },
'<<='	=>	sub { $_[0]->blsft($_[1]); },
'>>='	=>	sub { $_[0]->brsft($_[1]); },
d68 1
a68 1
'..'	=>	\&_pointpoint,
d70 6
a75 6
'<=>'	=>	sub { my $rc = $_[2] ?
                      ref($_[0])->bcmp($_[1],$_[0]) : 
                      $_[0]->bcmp($_[1]); 
		      $rc = 1 unless defined $rc;
		      $rc <=> 0;
		},
d77 2
a78 2
'>='	=>	sub { my $rc = $_[2] ?
                      ref($_[0])->bcmp($_[1],$_[0]) : 
d80 6
a85 6
		      # if there was a NaN involved, return false
		      return '' unless defined $rc;
		      $rc >= 0;
		},
'cmp'	=>	sub {
         $_[2] ? 
d89 5
a93 5
'cos'	=>	sub { $_[0]->copy->bcos(); }, 
'sin'	=>	sub { $_[0]->copy->bsin(); }, 
'atan2'	=>	sub { $_[2] ?
			ref($_[0])->new($_[1])->batan2($_[0]) :
			$_[0]->copy()->batan2($_[1]) },
d96 2
a97 2
#'hex'	=>	sub { print "hex"; $_[0]; }, 
#'oct'	=>	sub { print "oct"; $_[0]; }, 
d100 7
a106 7
'log'	=>	sub { $_[0]->copy()->blog($_[1], undef); }, 
'exp'	=>	sub { $_[0]->copy()->bexp($_[1]); }, 
'int'	=>	sub { $_[0]->copy(); }, 
'neg'	=>	sub { $_[0]->copy()->bneg(); }, 
'abs'	=>	sub { $_[0]->copy()->babs(); },
'sqrt'  =>	sub { $_[0]->copy()->bsqrt(); },
'~'	=>	sub { $_[0]->copy()->bnot(); },
d109 5
a113 5
'-'	=>	sub { my $c = $_[0]->copy; $_[2] ?
			$c->bneg()->badd( $_[1]) :
			$c->bsub( $_[1]) },
'+'	=>	sub { $_[0]->copy()->badd($_[1]); },
'*'	=>	sub { $_[0]->copy()->bmul($_[1]); },
d115 1
a115 1
'/'	=>	sub { 
d117 2
a118 2
  }, 
'%'	=>	sub { 
d120 2
a121 2
  }, 
'**'	=>	sub { 
d123 2
a124 2
  }, 
'<<'	=>	sub { 
d126 2
a127 2
  }, 
'>>'	=>	sub { 
d129 2
a130 2
  }, 
'&'	=>	sub { 
d132 2
a133 2
  }, 
'|'	=>	sub { 
d135 2
a136 2
  }, 
'^'	=>	sub { 
d138 1
a138 1
  }, 
d142 2
a143 2
'++'	=>	sub { $_[0]->binc() },
'--'	=>	sub { $_[0]->bdec() },
d146 1
a146 1
'bool'  =>	sub {
d148 1
a148 1
  # v5.6.1 dumps on this: return !$_[0]->is_zero() || undef;		    :-(
d155 1
a155 1
# Order of arguments unsignificant
d159 1
d172 2
a173 2
$upgrade = undef;			# default is no upgrade
$downgrade = undef;			# default is no downgrade
d177 12
a188 12
$_trap_nan = 0;				# are NaNs ok? set w/ config()
$_trap_inf = 0;				# are infs ok? set w/ config()
my $nan = 'NaN'; 			# constants for easier life

my $CALC = 'Math::BigInt::FastCalc';	# module to do the low level math
					# default is FastCalc.pm
my $IMPORT = 0;				# was import() called yet?
					# used to make require work
my %WARN;				# warn only once for low-level libs
my %CAN;				# cache for $CALC->can(...)
my %CALLBACKS;				# callbacks to notify on lib loads
my $EMU_LIB = 'Math/BigInt/CalcEmu.pm';	# emulate low-level math
d199 1
a199 1
  { 
d201 1
a201 1
  tie $rnd_mode, 'Math::BigInt'; 
d209 1
a209 1
############################################################################## 
d276 4
a279 4
  # $x->accuracy($a);		ref($x)	$a
  # $x->accuracy();		ref($x)
  # Class->accuracy();		class
  # Class->accuracy($a);	class $a
d300 1
a300 1
	Carp::croak ('Argument to accuracy must be greater than zero');
d305 1
a305 1
	Carp::croak ('Argument to accuracy must be an integer');
d311 3
a313 3
      $x->bround($a) if $a;		# not for undef, 0
      $x->{_a} = $a;			# set/overwrite, even if not rounded
      delete $x->{_p};			# clear P
d318 2
a319 2
      ${"${class}::accuracy"} = $a;	# set global A
      ${"${class}::precision"} = undef;	# clear global P
d321 1
a321 1
    return $a;				# shortcut
d334 4
a337 4
  # $x->precision($p);		ref($x)	$p
  # $x->precision();		ref($x)
  # Class->precision();		class
  # Class->precision($p);	class $p
d357 3
a359 3
      $x->bfround($p) if $p;		# not for undef, 0
      $x->{_p} = $p;			# set/overwrite, even if not rounded
      delete $x->{_a};			# clear A
d364 2
a365 2
      ${"${class}::precision"} = $p;	# set global P
      ${"${class}::accuracy"} = undef;	# clear global A
d367 1
a367 1
    return $p;				# shortcut
d446 1
a446 1
  { 
d461 2
a462 1
    $scale = $scale->can('numify') ? $scale->numify() : "$scale" if ref($scale);
d470 1
a470 1
  { 
d474 1
a474 1
  
d485 2
a486 1
    $scale = $scale->can('numify') ? $scale->numify() : "$scale" if ref($scale);
d496 80
a575 9
sub copy
  {
  # if two arguments, the first one is the class to "swallow" subclasses
  if (@@_ > 1)
    {
    my  $self = bless {
	sign => $_[1]->{sign}, 
	value => $CALC->_copy($_[1]->{value}),
    }, $_[0] if @@_ > 1;
d577 1
a577 3
    $self->{_a} = $_[1]->{_a} if defined $_[1]->{_a};
    $self->{_p} = $_[1]->{_p} if defined $_[1]->{_p};
    return $self;
d580 1
a580 4
  my $self = bless {
	sign => $_[0]->{sign}, 
	value => $CALC->_copy($_[0]->{value}),
	}, ref($_[0]);
d582 5
a586 4
  $self->{_a} = $_[0]->{_a} if defined $_[0]->{_a};
  $self->{_p} = $_[0]->{_p} if defined $_[0]->{_p};
  $self;
  }
d588 1
a588 4
sub new 
  {
  # create a new BigInt object from a string or another BigInt object. 
  # see hash keys documented at top
d590 2
a591 39
  # the argument could be an object, so avoid ||, && etc on it, this would
  # cause costly overloaded code to be called. The only allowed ops are
  # ref() and defined.

  my ($class,$wanted,$a,$p,$r) = @@_;
 
  # avoid numify-calls by not using || on $wanted!
  return $class->bzero($a,$p) if !defined $wanted;	# default to 0
  return $class->copy($wanted,$a,$p,$r)
   if ref($wanted) && $wanted->isa($class);		# MBI or subclass

  $class->import() if $IMPORT == 0;		# make require work
  
  my $self = bless {}, $class;

  # shortcut for "normal" numbers
  if ((!ref $wanted) && ($wanted =~ /^([+-]?)[1-9][0-9]*\z/))
    {
    $self->{sign} = $1 || '+';

    if ($wanted =~ /^[+-]/)
     {
      # remove sign without touching wanted to make it work with constants
      my $t = $wanted; $t =~ s/^[+-]//;
      $self->{value} = $CALC->_new($t);
      }
    else
      {
      $self->{value} = $CALC->_new($wanted);
      }
    no strict 'refs';
    if ( (defined $a) || (defined $p) 
        || (defined ${"${class}::precision"})
        || (defined ${"${class}::accuracy"}) 
       )
      {
      $self->round($a,$p,$r) unless (@@_ == 4 && !defined $a && !defined $p);
      }
    return $self;
d594 2
a595 5
  # handle '+inf', '-inf' first
  if ($wanted =~ /^[+-]?inf\z/)
    {
    $self->{sign} = $wanted;		# set a default sign for bstr()
    return $self->binf($wanted);
d597 3
a599 11
  # split str in m mantissa, e exponent, i integer, f fraction, v value, s sign
  my ($mis,$miv,$mfv,$es,$ev) = _split($wanted);
  if (!ref $mis)
    {
    if ($_trap_nan)
      {
      require Carp; Carp::croak("$wanted is not a number in $class");
      }
    $self->{value} = $CALC->_zero();
    $self->{sign} = $nan;
    return $self;
d601 6
a606 19
  if (!ref $miv)
    {
    # _from_hex or _from_bin
    $self->{value} = $mis->{value};
    $self->{sign} = $mis->{sign};
    return $self;	# throw away $mis
    }
  # make integer from mantissa by adjusting exp, then convert to bigint
  $self->{sign} = $$mis;			# store sign
  $self->{value} = $CALC->_zero();		# for all the NaN cases
  my $e = int("$$es$$ev");			# exponent (avoid recursion)
  if ($e > 0)
    {
    my $diff = $e - CORE::length($$mfv);
    if ($diff < 0)				# Not integer
      {
      if ($_trap_nan)
        {
        require Carp; Carp::croak("$wanted not an integer in $class");
d608 3
a610 10
      #print "NOI 1\n";
      return $upgrade->new($wanted,$a,$p,$r) if defined $upgrade;
      $self->{sign} = $nan;
      }
    else					# diff >= 0
      {
      # adjust fraction and add it to value
      #print "diff > 0 $$miv\n";
      $$miv = $$miv . ($$mfv . '0' x $diff);
      }
d612 26
a637 8
  else
    {
    if ($$mfv ne '')				# e <= 0
      {
      # fraction and negative/zero E => NOI
      if ($_trap_nan)
        {
        require Carp; Carp::croak("$wanted not an integer in $class");
d639 27
a665 18
      #print "NOI 2 \$\$mfv '$$mfv'\n";
      return $upgrade->new($wanted,$a,$p,$r) if defined $upgrade;
      $self->{sign} = $nan;
      }
    elsif ($e < 0)
      {
      # xE-y, and empty mfv
      #print "xE-y\n";
      $e = abs($e);
      if ($$miv !~ s/0{$e}$//)		# can strip so many zero's?
        {
        if ($_trap_nan)
          {
          require Carp; Carp::croak("$wanted not an integer in $class");
          }
        #print "NOI 3\n";
        return $upgrade->new($wanted,$a,$p,$r) if defined $upgrade;
        $self->{sign} = $nan;
a666 1
      }
d668 13
a680 8
  $self->{sign} = '+' if $$miv eq '0';			# normalize -0 => +0
  $self->{value} = $CALC->_new($$miv) if $self->{sign} =~ /^[+-]$/;
  # if any of the globals is set, use them to round and store them inside $self
  # do not round for new($x,undef,undef) since that is used by MBF to signal
  # no rounding
  $self->round($a,$p,$r) unless @@_ == 4 && !defined $a && !defined $p;
  $self;
  }
d697 1
a697 1
  $self->import() if $IMPORT == 0;		# make require work
d710 1
a710 1
  delete $self->{_a}; delete $self->{_p};	# rounding NaN is silly
d731 1
a731 1
  $self->import() if $IMPORT == 0;		# make require work
d743 1
a743 1
  $sign = $sign . 'inf' if $sign !~ /inf$/;	# - => -inf
d745 1
a745 1
  ($self->{_a},$self->{_p}) = @@_;		# take over requested rounding
d754 1
a754 1
 
d759 1
a759 1
  $self->import() if $IMPORT == 0;		# make require work
d761 1
a761 1
  
d803 1
a803 1
  $self->import() if $IMPORT == 0;		# make require work
d837 1
a837 1
# string conversation
d844 1
a844 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_); 
d848 2
a849 2
    return $x->{sign} unless $x->{sign} eq '+inf';	# -inf, NaN
    return 'inf';					# +inf
d852 1
a852 1
  #$m->bstr() . 'e+' . $e->bstr(); 	# e can only be positive in BigInt
d854 1
a854 1
  $m->bstr() . 'e+' . $CALC->_str($e->{value}); 
d857 1
a857 1
sub bstr 
d860 1
a860 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_); 
d864 2
a865 2
    return $x->{sign} unless $x->{sign} eq '+inf';	# -inf, NaN
    return 'inf';					# +inf
d871 1
a871 1
sub numify 
d873 1
a873 1
  # Make a "normal" scalar from a BigInt object
d876 14
a889 4
  return $x->bstr() if $x->{sign} !~ /^[+-]$/;
  my $num = $CALC->_num($x->{value});
  return -$num if $x->{sign} eq '-';
  $num;
d898 2
a899 2
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_); 
  
d903 18
a920 4
sub _find_round_parameters
  {
  # After any operation or when calling round(), the result is rounded by
  # regarding the A & P from arguments, local parameters, or globals.
d922 2
a923 1
  # !!!!!!! If you change this, remember to change round(), too! !!!!!!!!!!
d925 19
a943 15
  # This procedure finds the round parameters, but it is for speed reasons
  # duplicated in round. Otherwise, it is tested by the testsuite and used
  # by fdiv().
 
  # returns ($self) or ($self,$a,$p,$r) - sets $self to NaN of both A and P
  # were requested/defined (locally or globally or both)
  
  my ($self,$a,$p,$r,@@args) = @@_;
  # $a accuracy, if given by caller
  # $p precision, if given by caller
  # $r round_mode, if given by caller
  # @@args all 'other' arguments (0 for unary, 1 for binary ops)

  my $c = ref($self);				# find out class of argument(s)
  no strict 'refs';
d945 3
a947 3
  # convert to normal scalar for speed and correctness in inner parts
  $a = $a->can('numify') ? $a->numify() : "$a" if defined $a && ref($a);
  $p = $p->can('numify') ? $p->numify() : "$p" if defined $p && ref($p);
d949 2
a950 22
  # now pick $a or $p, but only if we have got "arguments"
  if (!defined $a)
    {
    foreach ($self,@@args)
      {
      # take the defined one, or if both defined, the one that is smaller
      $a = $_->{_a} if (defined $_->{_a}) && (!defined $a || $_->{_a} < $a);
      }
    }
  if (!defined $p)
    {
    # even if $a is defined, take $p, to signal error for both defined
    foreach ($self,@@args)
      {
      # take the defined one, or if both defined, the one that is bigger
      # -2 > -3, and 3 > 2
      $p = $_->{_p} if (defined $_->{_p}) && (!defined $p || $_->{_p} > $p);
      }
    }
  # if still none defined, use globals (#2)
  $a = ${"$c\::accuracy"} unless defined $a;
  $p = ${"$c\::precision"} unless defined $p;
d952 2
a953 5
  # A == 0 is useless, so undef it to signal no rounding
  $a = undef if defined $a && $a == 0;
 
  # no rounding today? 
  return ($self) unless defined $a || defined $p;		# early out
d955 2
a956 2
  # set A and set P is an fatal error
  return ($self->bnan()) if defined $a && defined $p;		# error
d958 3
a960 4
  $r = ${"$c\::round_mode"} unless defined $r;
  if ($r !~ /^(even|odd|\+inf|\-inf|zero|trunc|common)$/)
    {
    require Carp; Carp::croak ("Unknown round mode '$r'");
d963 2
a964 2
  $a = int($a) if defined $a;
  $p = int($p) if defined $p;
d966 2
a967 2
  ($self,$a,$p,$r);
  }
d969 3
a971 4
sub round
  {
  # Round $self according to given parameters, or given second argument's
  # parameters or global defaults 
d973 1
a973 1
  # for speed reasons, _find_round_parameters is embeded here:
d975 5
a979 5
  my ($self,$a,$p,$r,@@args) = @@_;
  # $a accuracy, if given by caller
  # $p precision, if given by caller
  # $r round_mode, if given by caller
  # @@args all 'other' arguments (0 for unary, 1 for binary ops)
d981 2
a982 2
  my $c = ref($self);				# find out class of argument(s)
  no strict 'refs';
d984 6
a989 8
  # now pick $a or $p, but only if we have got "arguments"
  if (!defined $a)
    {
    foreach ($self,@@args)
      {
      # take the defined one, or if both defined, the one that is smaller
      $a = $_->{_a} if (defined $_->{_a}) && (!defined $a || $_->{_a} < $a);
      }
d991 7
a997 9
  if (!defined $p)
    {
    # even if $a is defined, take $p, to signal error for both defined
    foreach ($self,@@args)
      {
      # take the defined one, or if both defined, the one that is bigger
      # -2 > -3, and 3 > 2
      $p = $_->{_p} if (defined $_->{_p}) && (!defined $p || $_->{_p} > $p);
      }
a998 9
  # if still none defined, use globals (#2)
  $a = ${"$c\::accuracy"} unless defined $a;
  $p = ${"$c\::precision"} unless defined $p;
 
  # A == 0 is useless, so undef it to signal no rounding
  $a = undef if defined $a && $a == 0;
  
  # no rounding today? 
  return $self unless defined $a || defined $p;		# early out
d1000 6
a1005 2
  # set A and set P is an fatal error
  return $self->bnan() if defined $a && defined $p;
d1007 9
a1015 4
  $r = ${"$c\::round_mode"} unless defined $r;
  if ($r !~ /^(even|odd|\+inf|\-inf|zero|trunc|common)$/)
    {
    require Carp; Carp::croak ("Unknown round mode '$r'");
d1018 5
a1022 4
  # now round, by calling either fround or ffround:
  if (defined $a)
    {
    $self->bround(int($a),$r) if !defined $self->{_a} || $self->{_a} >= $a;
d1024 4
a1027 7
  else # both can't be undefined due to early out
    {
    $self->bfround(int($p),$r) if !defined $self->{_p} || $self->{_p} <= $p;
    }
  # bround() or bfround() already callled bnorm() if nec.
  $self;
  }
d1030 1
a1030 1
  { 
d1037 1
a1037 1
sub babs 
d1049 14
a1062 2
sub bneg 
  { 
d1066 1
a1066 1
  
d1069 1
a1069 1
  # for +0 dont negate (to have always normalized +0). Does nothing for 'NaN'
d1074 1
a1074 1
sub bcmp 
d1078 1
a1078 1
  
d1082 1
a1082 1
  # objectify is costly, so avoid it 
d1102 2
a1103 2
  return 1 if $x->{sign} eq '+' && $y->{sign} eq '-';	# does also 0 <=> -y
  return -1 if $x->{sign} eq '-' && $y->{sign} eq '+';  # does also -x <=> 0 
d1105 3
a1107 2
  # have same sign, so compare absolute values. Don't make tests for zero here
  # because it's actually slower than testin in Calc (especially w/ Pari et al)
d1110 1
a1110 1
  if ($x->{sign} eq '+') 
d1117 1
a1117 1
  $CALC->_acmp($y->{value},$x->{value});	# swaped acmp (lib returns 0,1,-1)
d1120 1
a1120 1
sub bacmp 
d1122 1
a1122 1
  # Compares 2 values, ignoring their signs. 
d1125 1
a1125 1
  
d1128 1
a1128 1
  # objectify is costly, so avoid it 
d1145 1
a1145 1
  $CALC->_acmp($x->{value},$y->{value});	# lib does only 0,1,-1
d1148 1
a1148 1
sub badd 
d1155 1
a1155 1
  # objectify is costly, so avoid it 
d1165 1
a1165 1
  $r[3] = $y;				# no push!
a1182 2
    
  my ($sx, $sy) = ( $x->{sign}, $y->{sign} ); 		# get signs
d1184 3
a1186 1
  if ($sx eq $sy)  
d1188 1
a1188 1
    $x->{value} = $CALC->_add($x->{value},$y->{value});	# same sign, abs add
d1190 1
a1190 1
  else 
d1192 2
a1193 2
    my $a = $CALC->_acmp ($y->{value},$x->{value});	# absolute compare
    if ($a > 0)                           
d1197 1
a1197 1
      } 
d1212 1
a1212 1
sub bsub 
d1216 1
a1216 1
  
d1237 1
a1237 1
  $y->{sign} =~ tr/+\-/-+/; 	# does nothing for NaN
d1244 3
a1246 3
  $x->badd($y,@@r); 		# badd does not leave internal zeros
  $y->{sign} =~ tr/+\-/-+/; 	# refix $y (does nothing for NaN)
  $x;				# already rounded by badd() or no round nec.
d1267 1
a1267 1
  $x->badd($self->bone(),$a,$p,$r);		# badd does round
d1275 1
a1275 1
  
d1280 1
a1280 1
    } 
d1283 2
a1284 1
    return $x->badd($self->bone('-'),@@r) unless $x->{sign} eq '+'; 	# inf or NaN
d1289 1
a1289 1
      $x->{value} = $CALC->_one(); $x->{sign} = '-';		# 0 => -1
d1302 6
a1307 2
  # calculate $x = $a ** $base + $b and return $a (e.g. the log() to base
  # $base of $x)
d1312 3
a1314 4
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$base,@@r) = objectify(1,ref($x),@@_);
    }
d1318 19
a1336 1
  $base = $self->new($base) if defined $base && !ref $base;
d1338 8
a1345 3
  # inf, -inf, NaN, <0 => NaN
  return $x->bnan()
   if $x->{sign} ne '+' || (defined $base && $base->{sign} ne '+');
d1347 1
a1347 2
  return $upgrade->blog($upgrade->new($x),$base,@@r) if 
    defined $upgrade;
d1360 1
a1360 1
  
d1362 1
a1362 1
  return $x->bnan() unless defined $rc;		# not possible to take log?
d1395 5
a1399 7
    # ( 7 )    7!          7*6*5 * 4*3*2*1   7 * 6 * 5
    # ( - ) = --------- =  --------------- = ---------
    # ( 3 )   3! (7-3)!    3*2*1 * 4*3*2*1   3 * 2 * 1 

    # compute n - k + 2 (so we start with 5 in the example above)
    my $z = $x - $y;
    if (!$z->is_one())
d1401 1
d1405 1
a1405 1
      while ($z->bacmp($x) <= 0)		# f < x ?
d1449 2
a1450 2
sub blcm 
  { 
d1453 1
a1453 1
  # Lowest Common Multiplicator
d1465 1
a1465 1
  while (@@_) 
d1469 1
a1469 1
    } 
d1473 2
a1474 2
sub bgcd 
  { 
d1477 1
a1477 1
  # GCD -- Euclids algorithm, variant C (Knuth Vol 3, pg 341 ff)
d1482 2
a1483 2
  my $x = $y->copy()->babs();			# keep arguments
  return $x->bnan() if $x->{sign} !~ /^[+-]$/;	# x NaN?
d1488 1
a1488 1
    return $x->bnan() if $y->{sign} !~ /^[+-]$/;	# y NaN?
d1495 1
a1495 1
sub bnot 
d1501 1
a1501 1
 
d1503 1
a1503 1
  $x->binc()->bneg();			# binc already does round
d1514 2
a1515 2
  
  return 0 if $x->{sign} !~ /^\+$/;			# -, NaN & +-inf aren't
d1534 2
a1535 2
    $sign = '[+-]inf' if $sign eq '';	# +- doesn't matter, only that's inf
    $sign = "[$1]inf" if $sign =~ /^([+-])(inf)?$/;	# extract '+' or '-'
d1538 1
a1538 1
  $x->{sign} =~ /^[+-]inf$/ ? 1 : 0;		# only +-inf is infinity
d1545 1
a1545 1
    
d1547 2
a1548 2
 
  return 0 if $x->{sign} ne $sign; 	# -1 != +1, NaN, +-inf aren't either
d1557 1
a1557 1
  return 0 if $x->{sign} !~ /^[+-]$/;			# NaN & +-inf aren't
d1566 1
a1566 1
  return 0 if $x->{sign} !~ /^[+-]$/;			# NaN & +-inf aren't
d1572 1
a1572 1
  # return true when arg (BINT or num_str) is positive (>= 0)
d1575 2
a1576 2
  return 1 if $x->{sign} eq '+inf';			# +inf is positive
 
d1578 1
a1578 1
  ($x->{sign} eq '+' && !$x->is_zero()) ? 1 : 0;	
d1585 2
a1586 2
  
  $x->{sign} =~ /^-/ ? 1 : 0; 		# -inf is negative, but NaN is not
d1594 2
a1595 2
  
  $x->{sign} =~ /^[+-]$/ ? 1 : 0;		# inf/-inf/NaN aren't
d1600 2
a1601 2
sub bmul 
  { 
d1624 2
a1625 2
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/); 
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/); 
d1631 2
a1632 2
  
  $r[3] = $y;				# no push here
d1636 2
a1637 2
  $x->{value} = $CALC->_mul($x->{value},$y->{value});	# do actual math
  $x->{sign} = '+' if $CALC->_is_zero($x->{value}); 	# no -0
d1643 1
a1643 1
  { 
d1648 1
a1648 6
  my ($self,$x,$y,$z,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$z,@@r) = objectify(3,@@_);
    }
d1653 2
a1654 2
			($y->{sign} eq $nan) ||
			($z->{sign} eq $nan);
d1663 2
a1664 2
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/); 
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/); 
d1676 1
a1676 1
 
d1678 1
a1678 1
  $r[3] = $z;				# no push here
d1682 2
a1683 2
  $x->{value} = $CALC->_mul($x->{value},$y->{value});	# do actual math
  $x->{sign} = '+' if $CALC->_is_zero($x->{value}); 	# no -0
d1685 1
a1685 1
  my ($sx, $sz) = ( $x->{sign}, $z->{sign} ); 		# get signs
d1687 1
a1687 1
  if ($sx eq $sz)  
d1689 1
a1689 1
    $x->{value} = $CALC->_add($x->{value},$z->{value});	# same sign, abs add
d1691 1
a1691 1
  else 
d1693 2
a1694 2
    my $a = $CALC->_acmp ($z->{value},$x->{value});	# absolute compare
    if ($a > 0)                           
d1698 1
a1698 1
      } 
d1713 1
a1713 1
sub _div_inf
a1714 2
  # helper function that handles +-inf cases for bdiv()/bmod() to reuse code
  my ($self,$x,$y) = @@_;
d1716 50
a1765 9
  # NaN if x == NaN or y == NaN or x==y==0
  return wantarray ? ($x->bnan(),$self->bnan()) : $x->bnan()
   if (($x->is_nan() || $y->is_nan())   ||
       ($x->is_zero() && $y->is_zero()));
 
  # +-inf / +-inf == NaN, reminder also NaN
  if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))
    {
    return wantarray ? ($x->bnan(),$self->bnan()) : $x->bnan();
d1767 50
a1816 28
  # x / +-inf => 0, remainder x (works even if x == 0)
  if ($y->{sign} =~ /^[+-]inf$/)
    {
    my $t = $x->copy();		# bzero clobbers up $x
    return wantarray ? ($x->bzero(),$t) : $x->bzero()
    }
  
  # 5 / 0 => +inf, -6 / 0 => -inf
  # +inf / 0 = inf, inf,  and -inf / 0 => -inf, -inf 
  # exception:   -8 / 0 has remainder -8, not 8
  # exception: -inf / 0 has remainder -inf, not inf
  if ($y->is_zero())
    {
    # +-inf / 0 => special case for -inf
    return wantarray ?  ($x,$x->copy()) : $x if $x->is_inf();
    if (!$x->is_zero() && !$x->is_inf())
      {
      my $t = $x->copy();		# binf clobbers up $x
      return wantarray ?
       ($x->binf($x->{sign}),$t) : $x->binf($x->{sign})
      }
    }
  
  # last case: +-inf / ordinary number
  my $sign = '+inf';
  $sign = '-inf' if substr($x->{sign},0,1) ne $y->{sign};
  $x->{sign} = $sign;
  return wantarray ? ($x,$self->bzero()) : $x;
d1819 9
a1827 12
sub bdiv 
  {
  # (dividend: BINT or num_str, divisor: BINT or num_str) return 
  # (BINT,BINT) (quo,rem) or BINT (only rem)
  
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it 
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    } 
d1829 1
a1829 1
  return $x if $x->modify('bdiv');
d1831 2
a1832 2
  return $self->_div_inf($x,$y)
   if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/) || $y->is_zero());
d1834 2
a1835 4
  return $upgrade->bdiv($upgrade->new($x),$upgrade->new($y),@@r)
   if defined $upgrade;
   
  $r[3] = $y;					# no push!
d1837 3
a1839 3
  # calc new sign and in case $y == +/- 1, return $x
  my $xsign = $x->{sign};				# keep
  $x->{sign} = ($x->{sign} ne $y->{sign} ? '-' : '+'); 
d1841 3
a1843 3
  if (wantarray)
    {
    my $rem = $self->bzero(); 
d1845 21
a1865 3
    $x->{sign} = '+' if $CALC->_is_zero($x->{value});
    $rem->{_a} = $x->{_a};
    $rem->{_p} = $x->{_p};
d1867 5
a1871 4
    if (! $CALC->_is_zero($rem->{value}))
      {
      $rem->{sign} = $y->{sign};
      $rem = $y->copy()->bsub($rem) if $xsign ne $y->{sign}; # one of them '-'
d1873 1
a1873 3
    else
      {
      $rem->{sign} = '+';			# dont leave -0
d1875 2
d1881 1
a1881 4
  $x->{value} = $CALC->_div($x->{value},$y->{value});
  $x->{sign} = '+' if $CALC->_is_zero($x->{value});

  $x->round(@@r);
d1887 1
a1887 1
sub bmod 
d1889 6
a1894 4
  # modulus (or remainder)
  # (BINT or num_str, BINT or num_str) return BINT
  
  # set up parameters
d1896 1
d1904 28
a1931 7
  $r[3] = $y;					# no push!
  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/) || $y->is_zero())
    {
    my ($d,$r) = $self->_div_inf($x,$y);
    $x->{sign} = $r->{sign};
    $x->{value} = $r->{value};
    return $x->round(@@r);
d1934 2
a1935 1
  # calc new sign and in case $y == +/- 1, return $x
d1937 5
a1941 1
  if (!$CALC->_is_zero($x->{value}))
d1943 1
a1943 1
    $x->{value} = $CALC->_sub($y->{value},$x->{value},1) 	# $y-$x
d1947 1
a1947 4
   else
    {
    $x->{sign} = '+';				# dont leave -0
    }
d1953 10
a1962 4
  # Modular inverse.  given a number which is (hopefully) relatively
  # prime to the modulus, calculate its inverse using Euclid's
  # alogrithm.  If the number is not relatively prime to the modulus
  # (i.e. their gcd is not one) then NaN is returned.
d1974 53
a2026 5
  return $x->bnan()
        if ($y->{sign} ne '+'                           # -, NaN, +inf, -inf
         || $x->is_zero()                               # or num == 0
         || $x->{sign} !~ /^[+-]$/                      # or num NaN, inf, -inf
        );
d2028 1
a2028 2
  # put least residue into $x if $x was negative, and thus make it positive
  $x->bmod($y) if $x->{sign} eq '-';
d2030 1
a2030 7
  my $sign;
  ($x->{value},$sign) = $CALC->_modinv($x->{value},$y->{value});
  return $x->bnan() if !defined $x->{value};		# in case no GCD found
  return $x if !defined $sign;			# already real result
  $x->{sign} = $sign;				# flip/flop see below
  $x->bmod($y);					# calc real result
  $x;
d2035 3
a2037 3
  # takes a very large number to a very large exponent in a given very
  # large modulus, quickly, thanks to binary exponentation. Supports
  # negative exponents.
d2042 74
a2115 3
  # check modulus for valid values
  return $num->bnan() if ($mod->{sign} ne '+'		# NaN, - , -inf, +inf
                       || $mod->is_zero());
d2117 6
a2122 6
  # check exponent for valid values
  if ($exp->{sign} =~ /\w/) 
    {
    # i.e., if it's NaN, +inf, or -inf...
    return $num->bnan();
    }
d2124 1
a2124 1
  $num->bmodinv ($mod) if ($exp->{sign} eq '-');
d2126 2
a2127 2
  # check num for valid values (also NaN if there was no inverse but $exp < 0)
  return $num->bnan() if $num->{sign} !~ /^[+-]$/;
d2129 1
a2129 3
  # $mod is positive, sign on $exp is ignored, result also positive
  $num->{value} = $CALC->_modpow($num->{value},$exp->{value},$mod->{value});
  $num;
d2140 2
a2141 2
  return $x if $x->modify('bfac') || $x->{sign} eq '+inf';	# inf => inf
  return $x->bnan() if $x->{sign} ne '+';			# NaN, <0 etc => NaN
d2146 2
a2147 2
 
sub bpow 
d2192 1
a2192 1
    
d2217 1
a2217 1
  $r[3] = $y;					# no push!
d2222 1
a2222 1
  $new_sign = $y->is_odd() ? '-' : '+' if ($x->{sign} ne '+'); 
d2224 2
a2225 2
  # 0 ** -7 => ( 1 / (0 ** 7)) => 1 / 0 => +inf 
  return $x->binf() 
d2237 1
a2237 1
sub blsft 
d2241 1
a2241 1
 
d2260 1
a2260 1
sub brsft 
d2264 1
a2264 1
  
d2276 1
a2276 1
  return $x->bzero(@@r) if $x->is_zero();		# 0 => 0
d2283 1
a2283 1
    return $x->round(@@r) if $x->is_one('-');	# -1 => -1
d2290 1
a2290 1
      $x->binc();			# -3 => -2
d2292 2
a2293 2
      $bin =~ s/^-0b//;			# strip '-0b' prefix
      $bin =~ tr/10/01/;		# flip bits
d2297 5
a2301 5
	$bin = '0'; 			# shifting to far right creates -1
					# 0, because later increment makes 
					# that 1, attached '-' makes it '-1'
					# because -1 >> x == -1 !
        } 
d2303 9
a2311 9
	{
	$bin =~ s/.{$y}$//;		# cut off at the right side
        $bin = '1' . $bin;		# extend left side by one dummy '1'
        $bin =~ tr/10/01/;		# flip bits back
	}
      my $res = $self->new('0b'.$bin);	# add prefix and convert back
      $res->binc();			# remember to increment
      $x->{value} = $res->{value};	# take over value
      return $x->round(@@r);		# we are done now, magic, isn't?
d2314 1
a2314 1
    $x->bdec();				# n == 2, but $y == 1: this fixes it
d2321 1
a2321 1
sub band 
d2325 1
a2325 1
 
d2333 1
a2333 1
  
d2336 1
a2336 1
  $r[3] = $y;				# no push!
d2342 1
a2342 1
  
d2348 1
a2348 1
  
d2354 1
a2354 1
 
d2359 1
a2359 1
sub bior 
d2363 1
a2363 1
  
d2373 1
a2373 1
  $r[3] = $y;				# no push!
d2381 1
a2381 1
  
d2400 1
a2400 1
sub bxor 
d2404 1
a2404 1
  
d2414 1
a2414 1
  $r[3] = $y;				# no push!
d2417 1
a2417 1
  
d2427 1
a2427 1
  
d2443 1
a2443 1
  my $e = $CALC->_len($x->{value}); 
d2462 1
a2462 1
  return 0 if $x->{sign} !~ /^[+-]$/;	# NaN, inf, -inf etc
d2464 1
a2464 1
  $CALC->_zeros($x->{value});		# must handle odd values, 0 etc
d2474 2
a2475 2
  return $x->bnan() if $x->{sign} !~ /^\+/;	# -x or -inf or NaN => NaN
  return $x if $x->{sign} eq '+inf';		# sqrt(+inf) == inf
d2486 1
a2486 1
 
d2517 1
a2517 1
 
d2523 1
a2523 1
  return $self->bone() if $x->is_zero();
d2554 1
a2554 1
   
d2566 1
a2566 1
  return $x if !defined $scale || $x->modify('bfround');	# no-op
d2571 2
a2572 2
  delete $x->{_a};	# delete to save memory
  $x->{_p} = $scale;	# store new _p
d2580 2
a2581 2
 
  return 0 if $len == 1;		# "5" is trailed by invisible zeros
d2607 2
a2608 2
  return $x if !defined $scale || $x->modify('bround');	# no-op
  
d2614 1
a2614 1
  return $x if $x->{sign} !~ /^[+-]$/;		# inf, NaN
d2627 1
a2627 1
    return $x; 
d2629 1
a2629 1
   
d2648 1
a2648 1
  my $round_up = 1;					# default round up
d2650 5
a2654 5
    ($mode eq 'trunc')				||	# trunc by round down
    ($digit_after =~ /[01234]/)			|| 	# round down anyway,
							# 6789 => round up
    ($digit_after eq '5')			&&	# not 5000...0000
    ($x->_scan_for_nonzero($pad,$xs,$len) == 0)		&&
d2660 1
a2660 1
     ($mode eq 'zero')		# round down if zero, sign adjusted below
d2662 2
a2663 2
  my $put_back = 0;					# not yet modified
	
d2666 2
a2667 2
    substr($xs,-$pad,$pad) = '0' x $pad;		# replace with '00...'
    $put_back = 1;					# need to put back
d2671 1
a2671 1
    $x->bzero();					# round to '0'
d2674 1
a2674 1
  if ($round_up)					# what gave test above?
d2676 2
a2677 2
    $put_back = 1;					# need to put back
    $pad = $len, $xs = '0' x $pad if $scale < 0;	# tlr: whack 0.51=>1.0	
d2681 1
a2681 1
    my $c = 0; $pad ++;				# for $pad == $len case
d2686 1
a2686 1
      last if $c != 0;				# no overflow => early out
d2691 1
a2691 1
  $x->{value} = $CALC->_new($xs) if $put_back == 1;	# put back, if needed
d2704 1
a2704 1
  # return integer less or equal then number; no-op since it's already integer
d2712 1
a2712 1
  # return integer greater or equal then number; no-op since it's already int
d2718 7
d2738 1
a2738 1
  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, nan etc
d2750 1
a2750 1
  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, nan etc
d2761 1
a2761 1
  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, nan etc
d2763 2
a2764 2
  my $s = ''; $s = $x->{sign} if $x->{sign} eq '-';
  return $s . $CALC->_as_oct($x->{value});
d2770 28
a2797 35
sub objectify
  {
  # check for strings, if yes, return objects instead
 
  # the first argument is number of args objectify() should look at it will
  # return $count+1 elements, the first will be a classname. This is because
  # overloaded '""' calls bstr($object,undef,undef) and this would result in
  # useless objects being created and thrown away. So we cannot simple loop
  # over @@_. If the given count is 0, all arguments will be used.
 
  # If the second arg is a ref, use it as class.
  # If not, try to use it as classname, unless undef, then use $class 
  # (aka Math::BigInt). The latter shouldn't happen,though.

  # caller:			   gives us:
  # $x->badd(1);                => ref x, scalar y
  # Class->badd(1,2);           => classname x (scalar), scalar x, scalar y
  # Class->badd( Class->(1),2); => classname x (scalar), ref x, scalar y
  # Math::BigInt::badd(1,2);    => scalar x, scalar y
  # In the last case we check number of arguments to turn it silently into
  # $class,1,2. (We can not take '1' as class ;o)
  # badd($class,1) is not supported (it should, eventually, try to add undef)
  # currently it tries 'Math::BigInt' + 1, which will not work.

  # some shortcut for the common cases
  # $x->unary_op();
  return (ref($_[1]),$_[1]) if (@@_ == 2) && ($_[0]||0 == 1) && ref($_[1]);

  my $count = abs(shift || 0);
  
  my (@@a,$k,$d);		# resulting array, temp, and downgrade 
  if (ref $_[0])
    {
    # okay, got object as first
    $a[0] = ref $_[0];
d2799 14
a2812 1
  else
d2814 8
a2821 3
    # nope, got 1,2 (Class->xxx(1) => Class,1 and not supported)
    $a[0] = $class;
    $a[0] = shift if $_[0] =~ /^[A-Z].*::/;	# classname as first?
d2824 13
a2836 6
  no strict 'refs';
  # disable downgrading, because Math::BigFLoat->foo('1.0','2.0') needs floats
  if (defined ${"$a[0]::downgrade"})
    {
    $d = ${"$a[0]::downgrade"};
    ${"$a[0]::downgrade"} = undef;
d2839 41
a2879 10
  my $up = ${"$a[0]::upgrade"};
  # print STDERR "# Now in objectify, my class is today $a[0], count = $count\n";
  if ($count == 0)
    {
    while (@@_)
      {
      $k = shift;
      if (!ref($k))
        {
        $k = $a[0]->new($k);
d2881 16
a2896 17
      elsif (!defined $up && ref($k) ne $a[0])
	{
	# foreign object, try to convert to integer
        $k->can('as_number') ?  $k = $k->as_number() : $k = $a[0]->new($k);
	}
      push @@a,$k;
      }
    }
  else
    {
    while ($count > 0)
      {
      $count--; 
      $k = shift;
      if (!ref($k))
        {
        $k = $a[0]->new($k);
d2898 4
a2901 8
      elsif (!defined $up && ref($k) ne $a[0])
	{
	# foreign object, try to convert to integer
        $k->can('as_number') ? $k = $k->as_number() : $k = $a[0]->new($k);
	}
      push @@a,$k;
      }
    push @@a,@@_;		# return other params, too
d2903 7
a2909 7
  if (! wantarray)
    {
    require Carp; Carp::croak ("$class objectify needs list context");
    }
  ${"$a[0]::downgrade"} = $d;
  @@a;
  }
d2916 1
a2916 1
    { 
d2923 1
a2923 1
sub import 
d2927 1
a2927 1
  $IMPORT++;				# remember we did import()
d2929 1
a2929 1
  my $warn_or_die = 0;			# 0 - no warn, 1 - warn, 2 - die
d2935 3
a2937 3
      overload::constant 
	integer => sub { $self->new(shift) },
      	binary => sub { $self->new(shift) };
d2942 1
a2942 1
      $upgrade = $_[$i+1];		# or undef to disable
d2963 3
a2965 3
 
    $self->SUPER::import(@@a);			# need it for subclasses
    $self->export_to_level(1,$self,@@a);		# need it for MBF
d2972 1
a2972 1
    $_ =~ tr/a-zA-Z0-9://cd;			# limit to sane characters
d2974 3
a2976 3
  push @@c, \'FastCalc', \'Calc'			# if all fail, try these
    if $warn_or_die < 2;			# but not for "only"
  $CALC = '';					# signal error
d3004 3
a3006 3
	{
	$ok = 0;
	# api_version matches, check if it really provides anything we need
d3008 10
a3017 10
		one two ten
		str num
		add mul div sub dec inc
		acmp len digit is_one is_zero is_even is_odd
		is_two is_ten
		zeros new copy check
		from_hex from_oct from_bin as_hex as_bin as_oct
		rsft lsft xor and or
		mod sqrt root fac pow modinv modpow log_int gcd
	 /)
d3019 10
a3028 10
	  if (!$lib->can("_$method"))
	    {
	    if (($WARN{$lib}||0) < 2)
	      {
	      require Carp;
	      Carp::carp ("$lib is missing method '_$method'");
	      $WARN{$lib} = 1;		# still warn about the lib
	      }
            $ok++; last; 
	    }
d3030 1
a3030 1
	}
d3032 7
a3038 6
	{
	$CALC = $lib;
	if ($warn_or_die > 0 && ref($l))
	  {
	  require Carp;
	  my $msg = "Math::BigInt: couldn't load specified math lib(s), fallback to $lib";
d3041 3
a3043 3
	  }
        last;			# found a usable one, break
	}
d3045 8
a3052 8
	{
	if (($WARN{$lib}||0) < 2)
	  {
	  my $ver = eval "\$$lib\::VERSION" || 'unknown';
	  require Carp;
	  Carp::carp ("Cannot load outdated $lib v$ver, please upgrade");
	  $WARN{$lib} = 2;		# never warn again
	  }
d3061 2
a3062 1
      Carp::croak ("Couldn't load specified math lib(s) and fallback disallowed");
d3066 2
a3067 1
      Carp::croak ("Couldn't load any math lib(s), not even fallback to Calc.pm");
d3089 100
a3188 4
sub from_hex
  {
  # create a bigint from a hexadecimal string
  my ($self, $hs) = @@_;
d3190 1
a3190 1
  my $rc = __from_hex($hs);
d3192 4
a3195 1
  return $self->bnan() unless defined $rc;
d3197 1
a3197 2
  $rc;
  }  
d3199 1
a3199 4
sub from_bin
  {
  # create a bigint from a hexadecimal string
  my ($self, $bs) = @@_;
d3201 1
a3201 1
  my $rc = __from_bin($bs);
d3203 13
a3215 1
  return $self->bnan() unless defined $rc;
d3217 4
a3220 2
  $rc;
  }  
d3222 1
a3222 4
sub from_oct
  {
  # create a bigint from a hexadecimal string
  my ($self, $os) = @@_;
d3224 1
a3224 7
  my $x = $self->bzero();
  
  # strip underscores
  $os =~ s/([0-7])_([0-7])/$1$2/g;	
  $os =~ s/([0-7])_([0-7])/$1$2/g;	
  
  return $x->bnan() if $os !~ /^[\-\+]?0[0-7]+\z/;
d3226 1
a3226 1
  my $sign = '+'; $sign = '-' if $os =~ /^-/;
d3228 3
a3230 5
  $os =~ s/^[+-]//;						# strip sign
  $x->{value} = $CALC->_from_oct($os);
  $x->{sign} = $sign unless $CALC->_is_zero($x->{value}); 	# no '-0'
  $x;
  }
d3232 2
a3233 21
sub __from_hex
  {
  # internal
  # convert a (ref to) big hex string to BigInt, return undef for error
  my $hs = shift;

  my $x = Math::BigInt->bzero();
  
  # strip underscores
  $hs =~ s/([0-9a-fA-F])_([0-9a-fA-F])/$1$2/g;	
  $hs =~ s/([0-9a-fA-F])_([0-9a-fA-F])/$1$2/g;	
  
  return $x->bnan() if $hs !~ /^[\-\+]?0x[0-9A-Fa-f]+$/;

  my $sign = '+'; $sign = '-' if $hs =~ /^-/;

  $hs =~ s/^[+-]//;						# strip sign
  $x->{value} = $CALC->_from_hex($hs);
  $x->{sign} = $sign unless $CALC->_is_zero($x->{value}); 	# no '-0'
  $x;
  }
d3235 2
a3236 5
sub __from_bin
  {
  # internal
  # convert a (ref to) big binary string to BigInt, return undef for error
  my $bs = shift;
d3238 2
a3239 1
  my $x = Math::BigInt->bzero();
d3241 64
a3304 4
  # strip underscores
  $bs =~ s/([01])_([01])/$1$2/g;	
  $bs =~ s/([01])_([01])/$1$2/g;	
  return $x->bnan() if $bs !~ /^[+-]?0b[01]+$/;
d3306 5
a3310 2
  my $sign = '+'; $sign = '-' if $bs =~ /^\-/;
  $bs =~ s/^[+-]//;						# strip sign
d3312 2
a3313 4
  $x->{value} = $CALC->_from_bin($bs);
  $x->{sign} = $sign unless $CALC->_is_zero($x->{value}); 	# no '-0'
  $x;
  }
d3318 2
a3319 1
  # (\$mantissa_sign,\$mantissa_value,\$mantissa_fraction,\$exp_sign,\$exp_value)
d3325 1
a3325 1
  # strip white space at front, also extranous leading zeros
d3340 3
a3342 3
  return __from_hex($x) if $x =~ /^[\-\+]?0x/;		# hex string
  return __from_bin($x) if $x =~ /^[\-\+]?0b/;		# binary string
  
d3345 1
a3345 1
  $x =~ s/([0-9])_([0-9])/$1$2/g;		# do twice for 1_2_3
d3347 3
a3349 3
  # some possible inputs: 
  # 2.1234 # 0.12        # 1 	      # 1E1 # 2.134E1 # 434E-10 # 1.02009E-2 
  # .2 	   # 1_2_3.4_5_6 # 1.4E1_2_3  # 1e3 # +.2     # 0e999	
d3352 1
a3352 1
  return if defined $last;		# last defined => 1e2E3 or others
d3358 1
a3358 1
  if ($e =~ /^([+-]?)0*([0-9]+)$/)	# strip leading zeros
d3364 1
a3364 1
    return if defined $lastf;		# lastf defined => 1.2.3 or others
d3368 1
a3368 1
    if ($mi =~ /^([+-]?)0*([0-9]+)$/)		# strip leading zeros
d3371 1
a3371 1
      return unless ($mf =~ /^([0-9]*?)0*$/);	# strip trailing zeros
d3384 2
a3385 2
sub __lcm 
  { 
d3389 1
a3389 1
 
d3426 1
a3426 1
  return $x->bnan() if $x->{sign} !~ /^[+-]\z/;	# -inf +inf or NaN => NaN
d3447 1
a3447 1
  return $x->bnan() if $x->{sign} !~ /^[+-]\z/;	# -inf +inf or NaN => NaN
d3461 1
a3461 1
  { 
d3463 1
a3463 1
 
d3521 3
a3523 1
  my $r = Math::BigFloat->new($y)->batan2(Math::BigFloat->new($x),@@r)->as_int();
d3539 1
a3539 1
  return $x->bnan() if $x->{sign} !~ /^[+-]\z/;	# -inf +inf or NaN => NaN
d3578 1
a3578 1
  # to supress the warning use this:
d3588 18
a3605 16
  # Number creation	
  my $x = Math::BigInt->new($str);	# defaults to 0
  my $y = $x->copy();			# make a true copy
  my $nan  = Math::BigInt->bnan(); 	# create a NotANumber
  my $zero = Math::BigInt->bzero();	# create a +0
  my $inf = Math::BigInt->binf();	# create a +inf
  my $inf = Math::BigInt->binf('-');	# create a -inf
  my $one = Math::BigInt->bone();	# create a +1
  my $mone = Math::BigInt->bone('-');	# create a -1

  my $pi = Math::BigInt->bpi();		# returns '3'
					# see Math::BigFloat::bpi()

  $h = Math::BigInt->new('0x123');	# from hexadecimal
  $b = Math::BigInt->new('0b101');	# from binary
  $o = Math::BigInt->from_oct('0101');	# from octal
d3610 10
a3619 10
  $x->is_zero();	# if $x is +0
  $x->is_nan();		# if $x is NaN
  $x->is_one();		# if $x is +1
  $x->is_one('-');	# if $x is -1
  $x->is_odd();		# if $x is odd
  $x->is_even();	# if $x is even
  $x->is_pos();		# if $x >= 0
  $x->is_neg();		# if $x <  0
  $x->is_inf($sign);	# if $x is +inf, or -inf (sign is default '+')
  $x->is_int();		# if $x is an integer (not a float)
d3622 68
a3689 64
  $x->bcmp($y);		# compare numbers (undef,<0,=0,>0)
  $x->bacmp($y);	# compare absolutely (undef,<0,=0,>0)
  $x->sign();		# return the sign, either +,- or NaN
  $x->digit($n);	# return the nth digit, counting from right
  $x->digit(-$n);	# return the nth digit, counting from left

  # The following all modify their first argument. If you want to preserve
  # $x, use $z = $x->copy()->bXXX($y); See under L<CAVEATS> for why this is
  # necessary when mixing $a = $b assignments with non-overloaded math.

  $x->bzero();		# set $x to 0
  $x->bnan();		# set $x to NaN
  $x->bone();		# set $x to +1
  $x->bone('-');	# set $x to -1
  $x->binf();		# set $x to inf
  $x->binf('-');	# set $x to -inf

  $x->bneg();		# negation
  $x->babs();		# absolute value
  $x->bnorm();		# normalize (no-op in BigInt)
  $x->bnot();		# two's complement (bit wise not)
  $x->binc();		# increment $x by 1
  $x->bdec();		# decrement $x by 1
  
  $x->badd($y);		# addition (add $y to $x)
  $x->bsub($y);		# subtraction (subtract $y from $x)
  $x->bmul($y);		# multiplication (multiply $x by $y)
  $x->bdiv($y);		# divide, set $x to quotient
			# return (quo,rem) or quo if scalar

  $x->bmuladd($y,$z);	# $x = $x * $y + $z

  $x->bmod($y);		   # modulus (x % y)
  $x->bmodpow($exp,$mod);  # modular exponentation (($num**$exp) % $mod))
  $x->bmodinv($mod);	   # the inverse of $x in the given modulus $mod

  $x->bpow($y);		   # power of arguments (x ** y)
  $x->blsft($y);	   # left shift in base 2
  $x->brsft($y);	   # right shift in base 2
			   # returns (quo,rem) or quo if in scalar context
  $x->blsft($y,$n);	   # left shift by $y places in base $n
  $x->brsft($y,$n);	   # right shift by $y places in base $n
			   # returns (quo,rem) or quo if in scalar context
  
  $x->band($y);		   # bitwise and
  $x->bior($y);		   # bitwise inclusive or
  $x->bxor($y);		   # bitwise exclusive or
  $x->bnot();		   # bitwise not (two's complement)

  $x->bsqrt();		   # calculate square-root
  $x->broot($y);	   # $y'th root of $x (e.g. $y == 3 => cubic root)
  $x->bfac();		   # factorial of $x (1*2*3*4*..$x)

  $x->bnok($y);		   # x over y (binomial coefficient n over k)

  $x->blog();		   # logarithm of $x to base e (Euler's number)
  $x->blog($base);	   # logarithm of $x to base $base (f.i. 2)
  $x->bexp();		   # calculate e ** $x where e is Euler's number
  
  $x->round($A,$P,$mode);  # round to accuracy or precision using mode $mode
  $x->bround($n);	   # accuracy: preserve $n digits
  $x->bfround($n);	   # $n > 0: round $nth digits,
			   # $n < 0: round to the $nth digit after the
			   # dot, no-op for BigInts
d3694 4
a3697 3
  $x->bfloor();		   # return integer less or equal than $x
  $x->bceil();		   # return integer greater or equal than $x
  
d3702 21
a3722 20
  # lowest common multiplicator (no OO style)
  my $lcm = Math::BigInt::blcm(@@values);	
 
  $x->length();		   # return number of digits in number
  ($xl,$f) = $x->length(); # length of number and length of fraction part,
			   # latter is always 0 digits long for BigInts

  $x->exponent();	   # return exponent as BigInt
  $x->mantissa();	   # return (signed) mantissa as BigInt
  $x->parts();		   # return (mantissa,exponent) as BigInt
  $x->copy();		   # make a true copy of $x (unlike $y = $x;)
  $x->as_int();		   # return as BigInt (in BigInt: same as copy())
  $x->numify();		   # return as scalar (might overflow!)
  
  # conversation to string (do not modify their argument)
  $x->bstr();		   # normalized string (e.g. '3')
  $x->bsstr();		   # norm. string in scientific notation (e.g. '3E0')
  $x->as_hex();		   # as signed hexadecimal string with prefixed 0x
  $x->as_bin();		   # as signed binary string with prefixed 0b
  $x->as_oct();		   # as signed octal string with prefixed 0
d3726 4
a3729 4
  $x->precision();	   # return P of $x (or global, if P of $x undef)
  $x->precision($n);	   # set P of $x to $n
  $x->accuracy();	   # return A of $x (or global, if A of $x undef)
  $x->accuracy($n);	   # set A $x to $n
d3732 6
a3737 5
  Math::BigInt->precision();	# get/set global P for all BigInt objects
  Math::BigInt->accuracy(); 	# get/set global A for all BigInt objects
  Math::BigInt->round_mode();	# get/set global round mode, one of
				# 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'
  Math::BigInt->config();	# return hash containing configuration
d3744 1
a3744 1
  $i = new Math::BigInt '123_456_789_123_456_789';
d3749 1
a3749 3
=over 2

=item Input
d3755 1
a3755 1
may already have lost precision due to the conversation to float. Quote
d3758 2
a3759 2
	$x = Math::BigInt->new(12345678890123456789);	# bad
	$x = Math::BigInt->new('12345678901234567890');	# good
d3770 2
a3771 2
	perl -MMath::BigInt -le 'print Math::BigInt->new("0123")'
	
d3774 1
a3774 1
	perl -MMath::BigInt -le 'print Math::BigInt->from_oct("0123")'
d3780 2
a3781 2
	$zero = Math::BigInt->bzero(); 
	$nan = Math::BigInt->bnan(); 
d3783 2
a3784 2
C<bnorm()> on a BigInt object is now effectively a no-op, since the numbers 
are always stored in normalized form. If passed a string, creates a BigInt 
d3787 1
a3787 1
=item Output
d3790 1
a3790 1
return a string (see L<SYNOPSIS>).
a3795 2
=back

d3801 1
a3801 1
L<ACCURACY and PRECISION> for more information.
d3803 1
a3803 1
=head2 config()
d3805 1
a3805 1
	use Data::Dumper;
d3807 4
a3810 2
	print Dumper ( Math::BigInt->config() );
	print Math::BigInt->config()->{lib},"\n";
d3816 27
a3842 27
	key		Description
			Example
	============================================================
	lib		Name of the low-level math library
			Math::BigInt::Calc
	lib_version 	Version of low-level math library (see 'lib')
			0.30
	class		The class name of config() you just called
			Math::BigInt
	upgrade		To which class math operations might be upgraded
			Math::BigFloat
	downgrade	To which class math operations might be downgraded
			undef
	precision	Global precision
			undef
	accuracy	Global accuracy
			undef
	round_mode	Global round mode
			even
	version		version number of the class you used
			1.61
	div_scale	Fallback accuracy for div
			40
	trap_nan	If true, traps creation of NaN via croak()
			1
	trap_inf	If true, traps creation of +inf/-inf via croak()
			1
d3846 1
a3846 1
	trap_inf trap_nan
a3849 2
	
	$new_cfg = Math::BigInt->config( { trap_inf => 1, precision => 5 } );
d3851 5
a3855 1
=head2 accuracy()
d3857 3
a3859 3
	$x->accuracy(5);		# local for $x
	CLASS->accuracy(5);		# global for all members of CLASS
					# Note: This also applies to new()!
d3861 2
a3862 2
	$A = $x->accuracy();		# read out accuracy that affects $x
	$A = CLASS->accuracy();		# read out global accuracy
d3869 1
a3869 1
that number will also be rounded. 
d3872 1
a3872 1
L<round()>, L<bround()> or L<bfround()> or by passing the desired accuracy
d3875 4
a3878 4
        my $x = Math::BigInt->new(30000);
        my $y = Math::BigInt->new(7);
        print scalar $x->copy()->bdiv($y, 2);		# print 4300
        print scalar $x->copy()->bdiv($y)->bround(2);	# print 4300
d3880 1
a3880 1
Please see the section about L<ACCURACY AND PRECISION> for further details.
d3884 2
a3885 2
	$x->accuracy(undef);
	Math::BigInt->accuracy(undef);
d3887 2
a3888 2
Returns the current accuracy. For C<$x->accuracy()> it will return either the
local accuracy, or if not defined, the global. This means the return value
d3891 11
a3901 9
	$y = Math::BigInt->new(1234567);	# unrounded
	print Math::BigInt->accuracy(4),"\n";	# set 4, print 4
	$x = Math::BigInt->new(123456);		# $x will be automatically rounded!
	print "$x $y\n";			# '123500 1234567'
	print $x->accuracy(),"\n";		# will be 4
	print $y->accuracy(),"\n";		# also 4, since global is 4
	print Math::BigInt->accuracy(5),"\n";	# set to 5, print 5
	print $x->accuracy(),"\n";		# still 4
	print $y->accuracy(),"\n";		# 5, since global is 5
d3908 1
a3908 4
=head2 precision()

	$x->precision(-2);	# local for $x, round at the second digit right of the dot
	$x->precision(2);	# ditto, round at the second digit left of the dot
d3910 8
a3917 3
	CLASS->precision(5);	# Global for all members of CLASS
				# This also applies to new()!
	CLASS->precision(-5);	# ditto
d3919 2
a3920 2
	$P = CLASS->precision();	# read out global precision 
	$P = $x->precision();		# read out precision that affects $x
d3922 2
a3923 2
Note: You probably want to use L<accuracy()> instead. With L<accuracy> you
set the number of digits each result should have, with L<precision> you
d3934 1
a3934 1
Please see the section about L<ACCURACY AND PRECISION> for further details.
d3938 2
a3939 2
	$x->precision(undef);
	Math::BigInt->precision(undef);
d3941 2
a3942 2
Returns the current precision. For C<$x->precision()> it will return either the
local precision of $x, or if not defined, the global. This means the return
d3945 4
a3948 4
	$y = Math::BigInt->new(1234567);	# unrounded
	print Math::BigInt->precision(4),"\n";	# set 4, print 4
	$x = Math::BigInt->new(123456);		# will be automatically rounded
	print $x;				# print "120000"!
d3955 1
a3955 1
=head2 brsft()
d3957 1
a3957 1
	$x->brsft($y,$n);		
d3966 4
a3969 4
	$x = Math::BigInt->new(10);
	$x->brsft(1);			# same as $x >> 1: 5
	$x = Math::BigInt->new(1234);
	$x->brsft(2,10);		# result 12
d3974 2
a3975 2
	$x = Math::BigInt->new(-5);
	print $x->brsft(1);
d3980 1
a3980 1
=head2 new()
d3982 1
a3982 1
  	$x = Math::BigInt->new($str,$A,$P,$R);
d3988 3
a3990 1
See L<Input> for more info on accepted input formats.
d3992 1
a3992 1
=head2 from_oct()
d3994 4
a3997 1
	$x = Math::BigInt->from_oct("0775");	# input is octal
d3999 1
a3999 1
=head2 from_hex()
d4001 1
a4001 1
	$x = Math::BigInt->from_hex("0xcafe");	# input is hexadecimal
d4003 3
a4005 1
=head2 from_bin()
d4007 1
a4007 1
	$x = Math::BigInt->from_oct("0x10011");	# input is binary
d4009 1
a4009 1
=head2 bnan()
d4011 7
a4017 1
  	$x = Math::BigInt->bnan();
d4022 1
a4022 1
	$x->bnan();
d4024 1
a4024 1
=head2 bzero()
d4026 1
a4026 1
  	$x = Math::BigInt->bzero();
d4031 1
a4031 1
	$x->bzero();
d4033 1
a4033 1
=head2 binf()
d4035 1
a4035 1
  	$x = Math::BigInt->binf($sign);
d4041 2
a4042 2
	$x->binf();
	$x->binf('-');
d4044 1
a4044 1
=head2 bone()
d4046 1
a4046 1
  	$x = Math::BigInt->binf($sign);
d4052 2
a4053 2
	$x->bone();		# +1
	$x->bone('-');		# -1
d4055 1
a4055 1
=head2 is_one()/is_zero()/is_nan()/is_inf()
d4057 6
a4062 7
  
	$x->is_zero();			# true if arg is +0
	$x->is_nan();			# true if arg is NaN
	$x->is_one();			# true if arg is +1
	$x->is_one('-');		# true if arg is -1
	$x->is_inf();			# true if +inf
	$x->is_inf('-');		# true if -inf (sign is default '+')
d4068 1
a4068 1
	if ($x == 0)
d4070 4
a4073 4
=head2 is_pos()/is_neg()/is_positive()/is_negative()
	
	$x->is_pos();			# true if > 0
	$x->is_neg();			# true if < 0
d4086 1
a4086 1
=head2 is_odd()/is_even()/is_int()
d4088 3
a4090 3
	$x->is_odd();			# true if odd, false for even
	$x->is_even();			# true if even, false for odd
	$x->is_int();			# true if $x is an integer
d4097 1
a4097 1
=head2 bcmp()
d4099 1
a4099 1
	$x->bcmp($y);
d4104 1
a4104 1
=head2 bacmp()
d4106 1
a4106 1
	$x->bacmp($y);
d4108 1
a4108 1
Compares $x with $y while ignoring their. Returns -1, 0, 1 or undef.
d4110 1
a4110 1
=head2 sign()
d4112 1
a4112 1
	$x->sign();
d4118 5
a4122 5
	$x->babs();		# '+'
	$x->babs()->bneg();	# '-'
	$x->bnan();		# 'NaN'
	$x->binf();		# '+inf'
	$x->binf('-');		# '-inf'
d4124 1
a4124 1
=head2 digit()
d4126 1
a4126 1
	$x->digit($n);		# return the nth digit, counting from right
d4130 1
a4130 1
=head2 bneg()
d4132 1
a4132 1
	$x->bneg();
d4137 1
a4137 1
=head2 babs()
d4139 1
a4139 1
	$x->babs();
d4145 3
a4147 1
=head2 bnorm()
d4149 2
a4150 1
	$x->bnorm();			# normalize (no-op)
d4152 1
a4152 1
=head2 bnot()
d4154 5
a4158 1
	$x->bnot();			
d4162 1
a4162 1
	$x->binc()->bneg();
d4166 1
a4166 1
=head2 binc()
d4168 1
a4168 1
	$x->binc();			# increment x by 1
d4170 1
a4170 1
=head2 bdec()
d4172 1
a4172 1
	$x->bdec();			# decrement x by 1
d4174 1
a4174 1
=head2 badd()
d4176 1
a4176 1
	$x->badd($y);			# addition (add $y to $x)
d4178 1
a4178 1
=head2 bsub()
d4180 1
a4180 1
	$x->bsub($y);			# subtraction (subtract $y from $x)
d4182 1
a4182 1
=head2 bmul()
d4184 1
a4184 1
	$x->bmul($y);			# multiplication (multiply $x by $y)
d4186 1
a4186 1
=head2 bmuladd()
d4188 1
a4188 1
	$x->bmuladd($y,$z);
d4194 8
a4201 1
=head2 bdiv()
d4203 1
a4203 2
	$x->bdiv($y);			# divide, set $x to quotient
					# return (quo,rem) or quo if scalar
d4205 1
a4205 1
=head2 bmod()
d4207 3
a4209 1
	$x->bmod($y);			# modulus (x % y)
d4211 1
a4211 1
=head2 bmodinv()
d4213 1
a4213 1
	num->bmodinv($mod);		# modular inverse
d4215 1
a4215 3
Returns the inverse of C<$num> in the given modulus C<$mod>.  'C<NaN>' is
returned unless C<$num> is relatively prime to C<$mod>, i.e. unless
C<bgcd($num, $mod)==1>.
d4217 1
a4217 1
=head2 bmodpow()
d4219 13
a4231 2
	$num->bmodpow($exp,$mod);	# modular exponentation
					# ($num**$exp % $mod)
d4234 1
a4234 1
C<$mod> using binary exponentation.  C<bmodpow> is far superior to
d4237 1
a4237 1
	$num ** $exp % $mod
d4244 1
a4244 1
	bmodpow($num, -1, $mod)
d4248 1
a4248 1
	bmodinv($num, $mod)
d4250 1
a4250 1
=head2 bpow()
d4252 1
a4252 1
	$x->bpow($y);			# power of arguments (x ** y)
d4254 1
a4254 1
=head2 blog()
d4256 1
a4256 1
	$x->blog($base, $accuracy);	# logarithm of x to the base $base
d4260 1
a4260 1
	print $x->blog(undef, 100);	# log(x) to 100 digits
d4262 1
a4262 1
=head2 bexp()
d4264 1
a4264 1
	$x->bexp($accuracy);		# calculate e ** X
d4270 1
a4270 1
See also L<blog()>.
d4272 1
a4272 1
=head2 bnok()
d4274 1
a4274 1
	$x->bnok($y);		   # x over y (binomial coefficient n over k)
d4279 3
a4281 3
	( n )      n!
	| - |  = -------
	( k )    k!(n-k)!
d4285 1
a4285 1
=head2 bpi()
d4287 1
a4287 1
	print Math::BigInt->bpi(100), "\n";		# 3
d4295 4
a4298 4
	use Math::BigFloat;
	use Math::BigInt upgrade => Math::BigFloat;
	print Math::BigInt->bpi(3), "\n";		# 3.14
	print Math::BigInt->bpi(100), "\n";		# 3.1415....
d4302 1
a4302 1
=head2 bcos()
d4304 2
a4305 2
	my $x = Math::BigInt->new(1);
	print $x->bcos(100), "\n";
d4314 1
a4314 1
=head2 bsin()
d4316 2
a4317 2
	my $x = Math::BigInt->new(1);
	print $x->bsin(100), "\n";
d4326 1
a4326 1
=head2 batan2()
d4328 3
a4330 3
	my $x = Math::BigInt->new(1);
	my $y = Math::BigInt->new(1);
	print $y->batan2($x), "\n";
d4339 1
a4339 1
=head2 batan()
d4341 2
a4342 2
	my $x = Math::BigFloat->new(0.5);
	print $x->batan(100), "\n";
d4351 1
a4351 1
=head2 blsft()
d4353 2
a4354 2
	$x->blsft($y);		# left shift in base 2
	$x->blsft($y,$n);	# left shift, in base $n (like 10)
d4356 1
a4356 1
=head2 brsft()
d4358 2
a4359 2
	$x->brsft($y);		# right shift in base 2
	$x->brsft($y,$n);	# right shift, in base $n (like 10)
d4361 1
a4361 1
=head2 band()
d4363 1
a4363 1
	$x->band($y);			# bitwise and
d4365 1
a4365 1
=head2 bior()
d4367 1
a4367 1
	$x->bior($y);			# bitwise inclusive or
d4369 1
a4369 1
=head2 bxor()
d4371 1
a4371 1
	$x->bxor($y);			# bitwise exclusive or
d4373 1
a4373 1
=head2 bnot()
d4375 1
a4375 1
	$x->bnot();			# bitwise not (two's complement)
d4377 1
a4377 1
=head2 bsqrt()
d4379 1
a4379 1
	$x->bsqrt();			# calculate square-root
d4381 1
a4381 1
=head2 broot()
d4383 1
a4383 1
	$x->broot($N);
d4387 1
a4387 1
=head2 bfac()
d4389 1
a4389 1
	$x->bfac();			# factorial of $x (1*2*3*4*..$x)
d4391 3
a4393 1
=head2 round()
a4394 2
	$x->round($A,$P,$round_mode);
	
d4398 1
a4398 1
=head2 bround()
d4400 1
a4400 1
	$x->bround($N);               # accuracy: preserve $N digits
d4402 1
a4402 1
=head2 bfround()
d4404 1
a4404 1
	$x->bfround($N);
d4412 14
a4425 6
	Input		N		Result
	===================================================
	123456.123456	3		123500
	123456.123456	2		123450
	123456.123456	-2		123456.12
	123456.123456	-3		123456.123
d4427 1
a4427 1
=head2 bfloor()
d4429 1
a4429 1
	$x->bfloor();			
d4431 3
a4433 2
Set $x to the integer less or equal than $x. This is a no-op in BigInt, but
does change $x in BigFloat.
d4435 1
a4435 1
=head2 bceil()
d4437 1
a4437 1
	$x->bceil();
d4439 2
a4440 2
Set $x to the integer greater or equal than $x. This is a no-op in BigInt, but
does change $x in BigFloat.
d4442 1
a4442 1
=head2 bgcd()
d4444 1
a4444 1
	bgcd(@@values);		# greatest common divisor (no OO style)
d4446 1
a4446 1
=head2 blcm()
d4448 1
a4448 3
	blcm(@@values);		# lowest common multiplicator (no OO style)
 
head2 length()
d4450 4
a4453 2
	$x->length();
        ($xl,$fl) = $x->length();
d4459 1
a4459 1
=head2 exponent()
d4461 1
a4461 1
	$x->exponent();
d4465 1
a4465 1
=head2 mantissa()
d4467 1
a4467 1
	$x->mantissa();
d4471 7
a4477 1
=head2 parts()
d4479 1
a4479 1
	$x->parts();		# return (mantissa,exponent) as BigInt
d4481 1
a4481 1
=head2 copy()
d4483 3
a4485 1
	$x->copy();		# make a true copy of $x (unlike $y = $x;)
d4487 1
a4487 1
=head2 as_int()/as_number()
d4489 8
a4496 1
	$x->as_int();	
d4498 2
a4499 2
Returns $x as a BigInt (truncated towards zero). In BigInt this is the same as
C<copy()>. 
d4501 1
a4501 4
C<as_number()> is an alias to this method. C<as_number> was introduced in
v1.22, while C<as_int()> was only introduced in v1.68.
  
=head2 bstr()
d4503 3
a4505 1
	$x->bstr();
d4509 1
a4509 1
=head2 bsstr()
d4511 1
a4511 1
	$x->bsstr();		# normalized string in scientific notation
d4513 1
a4513 1
=head2 as_hex()
d4515 1
a4515 1
	$x->as_hex();		# as signed hexadecimal string with prefixed 0x
d4517 1
a4517 1
=head2 as_bin()
d4519 1
a4519 1
	$x->as_bin();		# as signed binary string with prefixed 0b
d4521 1
a4521 1
=head2 as_oct()
d4523 1
a4523 1
	$x->as_oct();		# as signed octal string with prefixed 0
d4525 1
a4525 1
=head2 numify()
d4527 1
a4527 1
	print $x->numify();
d4532 1
a4532 1
This loses precision, to avoid this use L<as_int()> instead.
d4534 1
a4534 1
=head2 modify()
d4536 1
a4536 1
	$x->modify('bpowd');
d4539 1
a4539 1
peration, or 1 if not.
d4543 1
a4543 1
=head2 upgrade()/downgrade()
d4549 2
a4550 2
	my $i = Math::BigInt->new(123);
	my $f = Math::BigFloat->new('123.1');
d4552 1
a4552 1
	print $i + $f,"\n";			# print 246
d4554 1
a4554 1
=head2 div_scale()
d4559 1
a4559 1
=head2 round_mode()
d4563 2
d4591 1
a4591 1
because 1200 can have p = 0, 1 or 2 (depending on what the inital value
d4596 10
a4605 10
 
	Initial value   P       A	Result          String
	------------------------------------------------------------
	1234.01         -3      	1000            1000
	1234            -2      	1200            1200
	1234.5          -1      	1230            1230
	1234.001        1       	1234            1234.0
	1234.01         0       	1234            1234
	1234.01         2       	1234.01		1234.01
	1234.01         5       	1234.01		1234.01000
d4618 5
a4622 5
	Initial value   P       A	Result          String
	------------------------------------------------------------
	1234.01			3	1230		1230
	1234.01			6	1234.01		1234.01
	1234.1			8	1234.1		1234.1000
d4637 1
a4637 1
=over 2
d4702 1
a4702 1
=over 2
d4706 1
a4706 1
  * ffround($p) is able to round to $p number of digits after the decimal
d4712 11
a4722 10
  * fround($a) rounds to $a significant digits
  * only fdiv() and fsqrt() take A as (optional) paramater
    + other operations simply create the same number (fneg etc), or more (fmul)
      of digits
    + rounding/truncating is only done when explicitly calling one of fround
      or ffround, and never for BigInt (not implemented)
  * fsqrt() simply hands its accuracy argument over to fdiv.
  * the documentation and the comment in the code indicate two different ways
    on how fdiv() determines the maximum number of digits it should calculate,
    and the actual code does yet another thing
d4730 12
a4741 10
    So for lx = 3, ly = 9, scale = 10, scale will actually be 16 (10+9-3).
    Actually, the 'difference' added to the scale is calculated from the
    number of "significant digits" in dividend and divisor, which is derived
    by looking at the length of the mantissa. Which is wrong, since it includes
    the + sign (oops) and actually gets 2 for '+100' and 4 for '+101'. Oops
    again. Thus 124/3 with div_scale=1 will get you '41.3' based on the strange
    assumption that 124 has 3 significant digits, while 120/7 will get you
    '17', not '17.1' since 120 is thought to have 2 significant digits.
    The rounding after the division then uses the remainder and $y to determine
    wether it must round up or down.
d4749 1
a4749 1
=over 2
d4753 3
a4755 3
  * You can set the A global via C<< Math::BigInt->accuracy() >> or
    C<< Math::BigFloat->accuracy() >> or whatever class you are using.
  * You can also set P globally by using C<< Math::SomeClass->precision() >>
d4758 4
a4761 4
  * to undefine A, use C<< Math::SomeCLass->accuracy(undef); >>
  * to undefine P, use C<< Math::SomeClass->precision(undef); >>
  * Setting C<< Math::SomeClass->accuracy() >> clears automatically
    C<< Math::SomeClass->precision() >>, and vice versa.
d4766 6
a4771 6
  * to find out the current global A, use C<< Math::SomeClass->accuracy() >>
  * to find out the current global P, use C<< Math::SomeClass->precision() >>
  * use C<< $x->accuracy() >> respective C<< $x->precision() >> for the local
    setting of C<< $x >>.
  * Please note that C<< $x->accuracy() >> respective C<< $x->precision() >>
    return eventually defined global A or P, when C<< $x >>'s A or P is not
d4783 2
a4784 2
  * If given undef for A and P, B<no> rounding will occur, and the globals will
    B<not> be used. This is used by subclasses to create numbers without
d4787 1
a4787 1
    C<< $x = Math::BigInt->new($number,undef,undef) >>:
d4789 2
a4790 2
	use Math::BigInt::SomeSubclass;
	use Math::BigInt;
d4792 3
a4794 3
	Math::BigInt->accuracy(2);
	Math::BigInt::SomeSubClass->accuracy(3);
	$x = Math::BigInt::SomeSubClass->new(1234);	
d4818 1
a4818 1
    as many digits as it can (with an exception for fdiv/fsqrt) and will not
d4820 2
a4821 2
  * There is another setting for fdiv() (and thus for fsqrt()). If neither of
    A or P is defined, fdiv() will use a fallback (F) of $div_scale digits.
d4826 1
a4826 1
  * fdiv will calculate (at least) 4 more digits than required (determined by
d4833 1
a4833 1
      will round the result, with fdiv() and fsqrt() as exceptions to guard
d4844 1
a4844 1
        print $x->copy()->fround(3);            # 12.3 (but A is now 3!)
d4856 1
a4856 1
 ?so that intermediate rounding does not 'poison' further math? 
d4874 1
a4874 1
  * fsqrt() will hand its arguments to fdiv(), as it used to, only now for two
d4879 2
a4880 2
  * You can set A or P locally by using C<< $x->accuracy() >> or
    C<< $x->precision() >>
d4883 1
a4883 1
  * C<< $x->accuracy() >> clears C<< $x->precision() >>, and vice versa.
d4888 1
a4888 2
    fround()/bround() is for accuracy rounding, while ffround()/bfround()
    is for precision
d4892 3
a4894 3
  * you can set/get the global R by using C<< Math::SomeClass->round_mode() >>
    or by setting C<< $Math::SomeClass::round_mode >>
  * after each operation, C<< $result->round() >> is called, and the result may
d4897 1
a4897 1
  * to manually round a number, call C<< $x->round($A,$P,$round_mode); >>
d4919 1
a4919 1
    the old code (except in a few cases on fdiv):
d4930 1
a4930 1
=over 2
d4937 9
a4945 9
	te@@linux:~> perl -wle 'print 2 ** 3333'
	inf
	te@@linux:~> perl -wle 'print 2 ** 3333 == 2 ** 3333'
	1
	te@@linux:~> perl -wle 'print oct(2 ** 3333)'
	0
	te@@linux:~> perl -wle 'print hex(2 ** 3333)'
	Illegal hexadecimal digit 'i' ignored at -e line 1.
	0
d4968 1
a4968 1
 
d4973 1
a4973 1
The actual numbers are stored as unsigned big integers (with seperate sign).
d4984 1
a4984 1
	use Math::BigInt try => 'Calc';
d4988 1
a4988 1
	use Math::BigInt try => 'GMP';
d4997 1
a4997 1
	use Math::BigInt only => 'GMP,Pari';
d5002 1
a5002 1
	use Math::BigInt try => 'Foo,Math::BigInt::Bar';
d5020 1
a5020 1
So please select carefully what libary you want to use.
d5060 1
a5060 1
 
d5063 1
a5063 1
  sub bint { Math::BigInt->new(shift); }
d5065 15
a5079 15
  $x = Math::BigInt->bstr("1234")      	# string "1234"
  $x = "$x";                         	# same as bstr()
  $x = Math::BigInt->bneg("1234");   	# BigInt "-1234"
  $x = Math::BigInt->babs("-12345"); 	# BigInt "12345"
  $x = Math::BigInt->bnorm("-0.00"); 	# BigInt "0"
  $x = bint(1) + bint(2);            	# BigInt "3"
  $x = bint(1) + "2";                	# ditto (auto-BigIntify of "2")
  $x = bint(1);                      	# BigInt "1"
  $x = $x + 5 / 2;                   	# BigInt "3"
  $x = $x ** 3;                      	# BigInt "27"
  $x *= 2;                           	# BigInt "54"
  $x = Math::BigInt->new(0);       	# BigInt "0"
  $x--;                              	# BigInt "-1"
  $x = Math::BigInt->badd(4,5)		# BigInt "9"
  print $x->bsstr();			# 9e+0
d5084 1
a5084 1
  use Test;
d5088 1
a5088 1
  Math::BigFloat->accuracy(4);		# no more A than 4
d5090 14
a5103 14
  ok ($x->copy()->fround(),123.4);	# even rounding
  print $x->copy()->fround(),"\n";	# 123.4
  Math::BigFloat->round_mode('odd');	# round to odd
  print $x->copy()->fround(),"\n";	# 123.5
  Math::BigFloat->accuracy(5);		# no more A than 5
  Math::BigFloat->round_mode('odd');	# round to odd
  print $x->copy()->fround(),"\n";	# 123.46
  $y = $x->copy()->fround(4),"\n";	# A = 4: 123.4
  print "$y, ",$y->accuracy(),"\n";	# 123.4, 4

  Math::BigFloat->accuracy(undef);	# A not important now
  Math::BigFloat->precision(2); 	# P important
  print $x->copy()->bnorm(),"\n";	# 123.46
  print $x->copy()->fround(),"\n";	# 123.46
d5114 1
a5114 1
This conversion happens at compile time. 
d5120 1
a5120 1
prints the integer value of C<2**100>. Note that without conversion of 
d5126 1
a5126 1
  	use Math::BigInt qw/:constant/;
d5128 4
a5131 4
	$x = 1234567890123456789012345678901234567890
		+ 123456789123456789;
	$y = '1234567890123456789012345678901234567890'
		+ '123456789123456789';
d5136 1
a5136 1
	use Math::BigInt;
d5138 1
a5138 1
	$x = Math::BigInt->new('1234567889123456789123456789123456789');
d5146 1
a5146 1
	use Math::BigInt ':constant';
d5148 2
a5149 2
	print ref(123e2),"\n";
	print ref(123.2e2),"\n";
d5181 1
a5181 1
modules and see if they help you. 
d5186 1
a5186 1
L<MATH LIBRARY> for more information.
d5190 1
a5190 1
=head2 SUBCLASSING
d5192 1
a5192 1
=head1 Subclassing Math::BigInt
d5197 1
a5197 1
=over 2
d5208 2
a5209 2
The private object hash keys like C<$x->{sign}> may not be changed, but
additional keys can be added, like C<$x->{_custom}>.
d5222 1
a5222 1
needs to merely change the output only needs to overload C<bstr()>. 
d5243 1
a5243 1
This allows Math::BigInt to correctly retrieve package globals from the 
d5247 1
a5247 1
Don't forget to 
d5249 1
a5249 1
	use overload;
d5259 1
a5259 1
	use Math::BigInt upgrade => 'Foo::Bar';
d5264 1
a5264 1
	use Math::BigInt upgrade => 'Math::BigFloat';
d5266 1
a5266 1
As a shortcut, you can use the module C<bignum>:
d5268 1
a5268 1
	use bignum;
d5270 1
a5270 1
Also good for oneliners:
d5272 1
a5272 1
	perl -Mbignum -le 'print 2 ** 255'
d5284 1
a5284 1
=over 2
d5294 10
a5305 2
Beware: This list is not complete.

d5307 1
a5307 2
arguments are of the class mentioned in $upgrade (This might change in later
versions to a more sophisticated scheme):
d5313 2
a5314 2
	bgcd
	blcm
d5321 1
a5321 1
=over 1
d5328 2
a5329 2
overloading) to work as you expect. It also solves problems with C<Test.pm>,
because its C<ok()> uses 'eq' internally. 
d5334 4
a5337 4
	I agree (with the first alternative), don't add the '+' on positive
	numbers.  It's not as important anymore with the new internal 
	form for numbers.  It made doing things like abs and neg easier,
	but those have to be done differently now anyway.
d5341 10
a5350 11
	use Test;
        BEGIN { plan tests => 1 }
	use Math::BigInt;

	my $x = new Math::BigInt 3*3;
	my $y = new Math::BigInt 3*3;

	ok ($x,3*3);
	print "$x eq 9" if $x eq $y;
	print "$x eq 9" if $x eq '9';
	print "$x eq 9" if $x eq 3*3;
d5353 4
a5356 4
	
	print "$x == 9" if $x == $y;
	print "$x == 9" if $x == 9;
	print "$x == 9" if $x == 3*3;
d5361 1
a5361 1
as 1e+308. If in doubt, convert both arguments to Math::BigInt before 
d5364 8
a5371 9
	use Test;
        BEGIN { plan tests => 3 }
	use Math::BigInt;

	$x = Math::BigInt->new('1e56'); $y = 1e56;
	ok ($x,$y);			# will fail
	ok ($x->bsstr(),$y);		# okay
	$y = Math::BigInt->new($y);
	ok ($x,$y);			# okay
d5373 1
a5373 1
Alternatively, simple use C<< <=> >> for comparisons, this will get it
d5382 1
a5382 1
C<int()> will return (at least for Perl v5.7.1 and up) another BigInt, not a 
d5385 4
a5388 4
	$x = Math::BigInt->new(123);
	$y = int($x);				# BigInt 123
	$x = Math::BigFloat->new(123.45);
	$y = int($x);				# BigInt 123
d5393 3
a5395 3
	$x = Math::BigFloat->new(123.45);
	$y = $x->as_number();			# BigInt 123
	$y = $x->as_int();			# ditto
d5401 1
a5401 1
	$y = $x->numify();			# 123 as scalar
d5406 1
a5406 1
	$z = $array[$x];			# does work automatically
d5408 1
a5408 1
=item length
d5412 2
a5413 2
	$c = Math::BigInt->new(123);
	print $c->length(),"\n";		# prints 30
d5416 1
a5416 3
since print calls C<length()> in list context. Use something like: 
	
	print scalar $c->length(),"\n";		# prints 3 
d5418 3
a5420 1
=item bdiv
d5424 1
a5424 1
	print $c->bdiv(10000),"\n";
a5428 3
	
	print $c / 10000,"\n";
	print scalar $c->bdiv(10000),"\n";  # or if you want to modify $c
d5430 5
a5434 1
instead.
d5438 1
a5438 1
nonzero) always has the same sign as the second operand; so, for
d5441 6
a5446 6
	  1 / 4  => ( 0, 1)
	  1 / -4 => (-1,-3)
	 -3 / 4  => (-1, 1)
	 -3 / -4 => ( 0,-3)
	-11 / 2  => (-5,1)
	 11 /-2  => (-5,-1)
d5452 1
a5452 1
	$x == ($x / $y) * $y + ($x % $y)
d5474 1
a5474 1
	A /  B  =   C,     R so that C *    B +    R =    A
d5476 9
a5484 9
	5 /   8 =   0,     5 	     0 *    8 +    5 =    5
	0 /   8 =   0,     0	     0 *    8 +    0 =    0
	0 / inf =   0,     0	     0 *  inf +    0 =    0
	0 /-inf =   0,     0	     0 * -inf +    0 =    0
	5 / inf =   0,     5	     0 *  inf +    5 =    5
	5 /-inf =   0,     5	     0 * -inf +    5 =    5
	-5/ inf =   0,    -5	     0 *  inf +   -5 =   -5
	-5/-inf =   0,    -5	     0 * -inf +   -5 =   -5
       inf/   5 =  inf,    0	   inf *    5 +    0 =  inf
d5486 1
a5486 1
       inf/  -5 = -inf,    0	  -inf *   -5 +    0 =  inf
d5488 2
a5489 2
	 5/   5 =    1,    0         1 *    5 +    0 =    5
	-5/  -5 =    1,    0         1 *   -5 +    0 =   -5
d5494 2
a5495 2
	 8/   0 =  inf,    8       inf *    0 +    8 =    8 
       inf/   0 =  inf,  inf       inf *    0 +  inf =  inf 
d5501 1
a5501 1
	A /  B  =   C,     R so that C *    B +    R =    A
d5503 2
a5504 2
      -inf/   0 = -inf, -inf      -inf *    0 +  inf = -inf 
	-8/   0 = -inf,   -8      -inf *    0 +    8 = -8 
d5540 4
a5543 4
	print bpow($x,$i),"\n"; 	# modify $x
	print $x->bpow($i),"\n"; 	# ditto
	print $x **= $i,"\n";		# the same
	print $x ** $i,"\n";		# leave $x alone 
d5551 1
a5551 1
	$x = -$x;
d5555 1
a5555 1
	$x->bneg();
d5563 21
a5583 1
In Perl you will get a floating point value if you do one of the following:
d5585 1
a5585 30
	$float = 5.0 + 2;
	$float = 2 + 5.0;
	$float = 5 / 2;

With overloaded math, only the first two variants will result in a BigFloat:

	use Math::BigInt;
	use Math::BigFloat;
	
	$mbf = Math::BigFloat->new(5);
	$mbi2 = Math::BigInteger->new(5);
	$mbi = Math::BigInteger->new(2);

					# what actually gets called:
	$float = $mbf + $mbi;		# $mbf->badd()
	$float = $mbf / $mbi;		# $mbf->bdiv()
	$integer = $mbi + $mbf;		# $mbi->badd()
	$integer = $mbi2 / $mbi;	# $mbi2->bdiv()
	$integer = $mbi2 / $mbf;	# $mbi2->bdiv()

This is because math with overloaded operators follows the first (dominating)
operand, and the operation of that is called and returns thus the result. So,
Math::BigInt::bdiv() will always return a Math::BigInt, regardless whether
the result should be a Math::BigFloat or the second operant is one.

To get a Math::BigFloat you either need to call the operation manually,
make sure the operands are already of the proper type or casted to that type
via Math::BigFloat->new():
	
	$float = Math::BigFloat->new($mbi2) / $mbi;	# = 2.5
d5587 2
a5588 2
Beware of simple "casting" the entire expression, this would only convert
the already computed result:
d5590 1
a5590 1
	$float = Math::BigFloat->new($mbi2 / $mbi);	# = 2.0 thus wrong!
d5594 2
a5595 2
	$integer = ($mbi2 + $mbi) / $mbf;		# int / float => int
	$integer = $mbi2 / Math::BigFloat->new($mbi);	# ditto
d5601 3
a5603 3
	
	$float = 2 + $mbf;
	$float = $mbf + 2;
d5620 8
a5627 8
	$x = Math::BigFloat->new(12);
	Math::BigFloat->precision(0);
	Math::BigFloat->round_mode('even');
	print $x->copy->bsqrt(),"\n";		# 4

	Math::BigFloat->precision(2);
	print $x->bsqrt(),"\n";			# 3.46
	print $x->bsqrt(3),"\n";		# 3.464
d5631 60
a5690 1
For negative numbers in base see also L<brsft|brsft>.
d5701 2
a5702 2
L<Math::BigFloat>, L<Math::BigRat> and L<Math::Big> as well as
L<Math::BigInt::BitVect>, L<Math::BigInt::Pari> and  L<Math::BigInt::GMP>.
d5707 15
a5721 4
The package at
L<http://search.cpan.org/search?mode=module&query=Math%3A%3ABigInt> contains
more documentation including a full version history, testcases, empty
subclass files and benchmarks.
d5723 3
a5725 1
=head1 AUTHORS
d5727 1
a5727 3
Original code by Mark Biggar, overloaded interface by Ilya Zakharevich.
Completely rewritten by Tels http://bloodgate.com in late 2000, 2001 - 2006
and still at it in 2007.
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@Import perl-5.24.2
@
text
@d9 1
a9 1
#   value: unsigned int with actual value (as a Math::BigInt::Calc or similar)
d18 2
a19 3
use 5.006001;
use strict;
use warnings;
d21 1
a21 2
our $VERSION = '1.999715';
$VERSION = eval $VERSION;
d23 2
a24 2
our @@ISA = qw(Exporter);
our @@EXPORT_OK = qw(objectify bgcd blcm);
d28 3
a30 4
our ($round_mode, $accuracy, $precision, $div_scale, $rnd_mode,
     $upgrade, $downgrade, $_trap_nan, $_trap_inf);

my $class = "Math::BigInt";
d33 1
a33 1
# it reversed (like $x = 2 * $y), then the third parameter is true.
a42 2
# We register ops that are not registerable yet, so suppress warnings
{ no warnings;
d49 12
a60 12
'+='    =>      sub { $_[0]->badd($_[1]); },
'-='    =>      sub { $_[0]->bsub($_[1]); },
'*='    =>      sub { $_[0]->bmul($_[1]); },
'/='    =>      sub { scalar $_[0]->bdiv($_[1]); },
'%='    =>      sub { $_[0]->bmod($_[1]); },
'^='    =>      sub { $_[0]->bxor($_[1]); },
'&='    =>      sub { $_[0]->band($_[1]); },
'|='    =>      sub { $_[0]->bior($_[1]); },

'**='   =>      sub { $_[0]->bpow($_[1]); },
'<<='   =>      sub { $_[0]->blsft($_[1]); },
'>>='   =>      sub { $_[0]->brsft($_[1]); },
d63 1
a63 1
'..'    =>      \&_pointpoint,
d65 6
a70 6
'<=>'   =>      sub { my $rc = $_[2] ?
                      ref($_[0])->bcmp($_[1],$_[0]) :
                      $_[0]->bcmp($_[1]);
                      $rc = 1 unless defined $rc;
                      $rc <=> 0;
                },
d72 2
a73 2
'>='    =>      sub { my $rc = $_[2] ?
                      ref($_[0])->bcmp($_[1],$_[0]) :
d75 6
a80 6
                      # if there was a NaN involved, return false
                      return '' unless defined $rc;
                      $rc >= 0;
                },
'cmp'   =>      sub {
         $_[2] ?
d84 5
a88 5
'cos'   =>      sub { $_[0]->copy->bcos(); },
'sin'   =>      sub { $_[0]->copy->bsin(); },
'atan2' =>      sub { $_[2] ?
                        ref($_[0])->new($_[1])->batan2($_[0]) :
                        $_[0]->copy()->batan2($_[1]) },
d91 2
a92 2
#'hex'  =>      sub { print "hex"; $_[0]; },
#'oct'  =>      sub { print "oct"; $_[0]; },
d95 7
a101 7
'log'   =>      sub { $_[0]->copy()->blog(); },
'exp'   =>      sub { $_[0]->copy()->bexp($_[1]); },
'int'   =>      sub { $_[0]->copy(); },
'neg'   =>      sub { $_[0]->copy()->bneg(); },
'abs'   =>      sub { $_[0]->copy()->babs(); },
'sqrt'  =>      sub { $_[0]->copy()->bsqrt(); },
'~'     =>      sub { $_[0]->copy()->bnot(); },
d104 5
a108 5
'-'     =>      sub { my $c = $_[0]->copy; $_[2] ?
                        $c->bneg()->badd( $_[1]) :
                        $c->bsub( $_[1]) },
'+'     =>      sub { $_[0]->copy()->badd($_[1]); },
'*'     =>      sub { $_[0]->copy()->bmul($_[1]); },
d110 1
a110 1
'/'     =>      sub {
d112 2
a113 2
  },
'%'     =>      sub {
d115 2
a116 2
  },
'**'    =>      sub {
d118 2
a119 2
  },
'<<'    =>      sub {
d121 2
a122 2
  },
'>>'    =>      sub {
d124 2
a125 2
  },
'&'     =>      sub {
d127 2
a128 2
  },
'|'     =>      sub {
d130 2
a131 2
  },
'^'     =>      sub {
d133 1
a133 1
  },
d137 2
a138 2
'++'    =>      sub { $_[0]->binc() },
'--'    =>      sub { $_[0]->bdec() },
d141 1
a141 1
'bool'  =>      sub {
d143 1
a143 1
  # v5.6.1 dumps on this: return !$_[0]->is_zero() || undef;                :-(
d150 1
a150 1
# Order of arguments insignificant
a153 1
} # no warnings scope
d166 2
a167 2
$upgrade = undef;                       # default is no upgrade
$downgrade = undef;                     # default is no downgrade
d171 12
a182 12
$_trap_nan = 0;                         # are NaNs ok? set w/ config()
$_trap_inf = 0;                         # are infs ok? set w/ config()
my $nan = 'NaN';                        # constants for easier life

my $CALC = 'Math::BigInt::Calc';        # module to do the low level math
                                        # default is Calc.pm
my $IMPORT = 0;                         # was import() called yet?
                                        # used to make require work
my %WARN;                               # warn only once for low-level libs
my %CAN;                                # cache for $CALC->can(...)
my %CALLBACKS;                          # callbacks to notify on lib loads
my $EMU_LIB = 'Math/BigInt/CalcEmu.pm'; # emulate low-level math
d193 1
a193 1
  {
d195 1
a195 1
  tie $rnd_mode, 'Math::BigInt';
d203 1
a203 1
##############################################################################
d270 4
a273 4
  # $x->accuracy($a);           ref($x) $a
  # $x->accuracy();             ref($x)
  # Class->accuracy();          class
  # Class->accuracy($a);        class $a
d294 1
a294 1
        Carp::croak ('Argument to accuracy must be greater than zero');
d299 1
a299 1
        Carp::croak ('Argument to accuracy must be an integer');
d305 3
a307 3
      $x->bround($a) if $a;             # not for undef, 0
      $x->{_a} = $a;                    # set/overwrite, even if not rounded
      delete $x->{_p};                  # clear P
d312 2
a313 2
      ${"${class}::accuracy"} = $a;     # set global A
      ${"${class}::precision"} = undef; # clear global P
d315 1
a315 1
    return $a;                          # shortcut
d328 4
a331 4
  # $x->precision($p);          ref($x) $p
  # $x->precision();            ref($x)
  # Class->precision();         class
  # Class->precision($p);       class $p
d351 3
a353 3
      $x->bfround($p) if $p;            # not for undef, 0
      $x->{_p} = $p;                    # set/overwrite, even if not rounded
      delete $x->{_a};                  # clear A
d358 2
a359 2
      ${"${class}::precision"} = $p;    # set global P
      ${"${class}::accuracy"} = undef;  # clear global A
d361 1
a361 1
    return $p;                          # shortcut
d440 1
a440 1
  {
d455 1
a455 2
    $scale = $scale->can('numify') ? $scale->numify()
                                   : "$scale" if ref($scale);
d463 1
a463 1
  {
d467 1
a467 1

d478 1
a478 2
    $scale = $scale->can('numify') ? $scale->numify()
                                   : "$scale" if ref($scale);
d488 9
a496 4
sub copy {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;
d498 4
a501 1
    # If called as a class method, the object to copy is the next argument.
d503 4
a506 1
    $self = shift() unless $selfref;
d508 4
a511 1
    my $copy = bless {}, $class;
d513 4
a516 4
    $copy->{sign}  = $self->{sign};
    $copy->{value} = $CALC->_copy($self->{value});
    $copy->{_a}    = $self->{_a} if exists $self->{_a};
    $copy->{_p}    = $self->{_p} if exists $self->{_p};
d518 40
a557 2
    return $copy;
}
d559 5
a563 22
sub new {
    # Create a new Math::BigInt object from a string or another Math::BigInt
    # object. See hash keys documented at top.

    # The argument could be an object, so avoid ||, && etc. on it. This would
    # cause costly overloaded code to be called. The only allowed ops are ref()
    # and defined.

    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    my ($wanted, $a, $p, $r) = @@_;

    # If called as a class method, initialize a new object.

    $self = bless {}, $class unless $selfref;

    unless (defined $wanted) {
        require Carp;
        Carp::carp("Use of uninitialized value in new");
        return $self->bzero($a, $p, $r);
d565 11
a575 10

    if (ref($wanted) && $wanted->isa($class)) {         # MBI or subclass
        # Using "$copy = $wanted -> copy()" here fails some tests. Fixme!
        my $copy = $class -> copy($wanted);
        if ($selfref) {
            %$self = %$copy;
        } else {
            $self = $copy;
        }
        return $self;
d577 17
a593 23

    $class->import() if $IMPORT == 0;           # make require work

    # Shortcut for non-zero scalar integers with no non-zero exponent.

    if (!ref($wanted) &&
        $wanted =~ / ^
                     ([+-]?)            # optional sign
                     ([1-9][0-9]*)      # non-zero significand
                     (\.0*)?            # ... with optional zero fraction
                     ([Ee][+-]?0+)?     # optional zero exponent
                     \z
                   /x)
    {
        my $sgn = $1;
        my $abs = $2;
        $self->{sign} = $sgn || '+';
        $self->{value} = $CALC->_new($abs);

        no strict 'refs';
        if (defined($a) || defined($p)
            || defined(${"${class}::precision"})
            || defined(${"${class}::accuracy"}))
d595 1
a595 2
            $self->round($a, $p, $r)
              unless @@_ == 4 && !defined $a && !defined $p;
d597 10
a606 2

        return $self;
d608 8
a615 28

    # Handle Infs.

    if ($wanted =~ /^\s*([+-]?)inf(inity)?\s*\z/i) {
        my $sgn = $1 || '+';
        $self->{sign} = $sgn . 'inf';   # set a default sign for bstr()
        return $self->binf($sgn);
    }

    # Handle explicit NaNs (not the ones returned due to invalid input).

    if ($wanted =~ /^\s*([+-]?)nan\s*\z/i) {
        return $self->bnan();
    }

    if ($wanted =~ /^\s*[+-]?0[Xx]/) {
        return $class -> from_hex($wanted);
    }

    if ($wanted =~ /^\s*[+-]?0[Bb]/) {
        return $class -> from_bin($wanted);
    }

    # Split string into mantissa, exponent, integer, fraction, value, and sign.
    my ($mis, $miv, $mfv, $es, $ev) = _split($wanted);
    if (!ref $mis) {
        if ($_trap_nan) {
            require Carp; Carp::croak("$wanted is not a number in $class");
d617 17
a633 1
        $self->{value} = $CALC->_zero();
a634 28
        return $self;
    }

    if (!ref $miv) {
        # _from_hex or _from_bin
        $self->{value} = $mis->{value};
        $self->{sign} = $mis->{sign};
        return $self;   # throw away $mis
    }

    # Make integer from mantissa by adjusting exponent, then convert to a
    # Math::BigInt.
    $self->{sign} = $$mis;           # store sign
    $self->{value} = $CALC->_zero(); # for all the NaN cases
    my $e = int("$$es$$ev");         # exponent (avoid recursion)
    if ($e > 0) {
        my $diff = $e - CORE::length($$mfv);
        if ($diff < 0) {         # Not integer
            if ($_trap_nan) {
                require Carp; Carp::croak("$wanted not an integer in $class");
            }
            #print "NOI 1\n";
            return $upgrade->new($wanted, $a, $p, $r) if defined $upgrade;
            $self->{sign} = $nan;
        } else {                 # diff >= 0
            # adjust fraction and add it to value
            #print "diff > 0 $$miv\n";
            $$miv = $$miv . ($$mfv . '0' x $diff);
d636 1
d638 8
a645 41

    else {
        if ($$mfv ne '') {       # e <= 0
            # fraction and negative/zero E => NOI
            if ($_trap_nan) {
                require Carp; Carp::croak("$wanted not an integer in $class");
            }
            #print "NOI 2 \$\$mfv '$$mfv'\n";
            return $upgrade->new($wanted, $a, $p, $r) if defined $upgrade;
            $self->{sign} = $nan;
        } elsif ($e < 0) {
            # xE-y, and empty mfv
            # Split the mantissa at the decimal point. E.g., if
            # $$miv = 12345 and $e = -2, then $frac = 45 and $$miv = 123.

            my $frac = substr($$miv, $e); # $frac is fraction part
            substr($$miv, $e) = "";       # $$miv is now integer part

            if ($frac =~ /[^0]/) {
                if ($_trap_nan) {
                    require Carp; Carp::croak("$wanted not an integer in $class");
                }
                #print "NOI 3\n";
                return $upgrade->new($wanted, $a, $p, $r) if defined $upgrade;
                $self->{sign} = $nan;
            }
        }
    }

    unless ($self->{sign} eq $nan) {
        $self->{sign} = '+' if $$miv eq '0';            # normalize -0 => +0
        $self->{value} = $CALC->_new($$miv) if $self->{sign} =~ /^[+-]$/;
    }

    # If any of the globals are set, use them to round, and store them inside
    # $self. Do not round for new($x, undef, undef) since that is used by MBF
    # to signal no rounding.

    $self->round($a, $p, $r) unless @@_ == 4 && !defined $a && !defined $p;
    $self;
}
d662 1
a662 1
  $self->import() if $IMPORT == 0;              # make require work
d675 1
a675 1
  delete $self->{_a}; delete $self->{_p};       # rounding NaN is silly
d696 1
a696 1
  $self->import() if $IMPORT == 0;              # make require work
d708 1
a708 1
  $sign = $sign . 'inf' if $sign !~ /inf$/;     # - => -inf
d710 1
a710 1
  ($self->{_a},$self->{_p}) = @@_;               # take over requested rounding
d719 1
a719 1

d724 1
a724 1
  $self->import() if $IMPORT == 0;              # make require work
d726 1
a726 1

d768 1
a768 1
  $self->import() if $IMPORT == 0;              # make require work
d802 1
a802 1
# string conversion
d809 1
a809 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
d813 2
a814 2
    return $x->{sign} unless $x->{sign} eq '+inf';      # -inf, NaN
    return 'inf';                                       # +inf
d817 1
a817 1
  #$m->bstr() . 'e+' . $e->bstr();      # e can only be positive in BigInt
d819 1
a819 1
  $m->bstr() . 'e+' . $CALC->_str($e->{value});
d822 1
a822 1
sub bstr
d825 1
a825 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
d829 2
a830 2
    return $x->{sign} unless $x->{sign} eq '+inf';      # -inf, NaN
    return 'inf';                                       # +inf
d836 1
a836 1
sub numify
d838 1
a838 1
  # Make a Perl scalar number from a Math::BigInt object.
d841 4
a844 14
  if ($x -> is_nan()) {
      require Math::Complex;
      my $inf = Math::Complex::Inf();
      return $inf - $inf;
  }

  if ($x -> is_inf()) {
      require Math::Complex;
      my $inf = Math::Complex::Inf();
      return $x -> is_negative() ? -$inf : $inf;
  }

  my $num = 0 + $CALC->_num($x->{value});
  return $x->{sign} eq '-' ? -$num : $num;
d853 2
a854 2
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

d858 19
a876 18
sub _find_round_parameters {
    # After any operation or when calling round(), the result is rounded by
    # regarding the A & P from arguments, local parameters, or globals.

    # !!!!!!! If you change this, remember to change round(), too! !!!!!!!!!!

    # This procedure finds the round parameters, but it is for speed reasons
    # duplicated in round. Otherwise, it is tested by the testsuite and used
    # by bdiv().

    # returns ($self) or ($self,$a,$p,$r) - sets $self to NaN of both A and P
    # were requested/defined (locally or globally or both)

    my ($self, $a, $p, $r, @@args) = @@_;
    # $a accuracy, if given by caller
    # $p precision, if given by caller
    # $r round_mode, if given by caller
    # @@args all 'other' arguments (0 for unary, 1 for binary ops)
d878 6
a883 2
    my $class = ref($self);       # find out class of argument(s)
    no strict 'refs';
d885 8
a892 10
    # convert to normal scalar for speed and correctness in inner parts
    $a = $a->can('numify') ? $a->numify() : "$a" if defined $a && ref($a);
    $p = $p->can('numify') ? $p->numify() : "$p" if defined $p && ref($p);

    # now pick $a or $p, but only if we have got "arguments"
    if (!defined $a) {
        foreach ($self, @@args) {
            # take the defined one, or if both defined, the one that is smaller
            $a = $_->{_a} if (defined $_->{_a}) && (!defined $a || $_->{_a} < $a);
        }
d894 9
a902 7
    if (!defined $p) {
        # even if $a is defined, take $p, to signal error for both defined
        foreach ($self, @@args) {
            # take the defined one, or if both defined, the one that is bigger
            # -2 > -3, and 3 > 2
            $p = $_->{_p} if (defined $_->{_p}) && (!defined $p || $_->{_p} > $p);
        }
d904 3
d908 5
a912 3
    # if still none defined, use globals (#2)
    $a = ${"$class\::accuracy"}  unless defined $a;
    $p = ${"$class\::precision"} unless defined $p;
d914 2
a915 2
    # A == 0 is useless, so undef it to signal no rounding
    $a = undef if defined $a && $a == 0;
d917 4
a920 9
    # no rounding today?
    return ($self) unless defined $a || defined $p; # early out

    # set A and set P is an fatal error
    return ($self->bnan()) if defined $a && defined $p; # error

    $r = ${"$class\::round_mode"} unless defined $r;
    if ($r !~ /^(even|odd|[+-]inf|zero|trunc|common)$/) {
        require Carp; Carp::croak ("Unknown round mode '$r'");
d923 2
a924 2
    $a = int($a) if defined $a;
    $p = int($p) if defined $p;
d926 2
a927 2
    ($self, $a, $p, $r);
}
d929 4
a932 3
sub round {
    # Round $self according to given parameters, or given second argument's
    # parameters or global defaults
d934 1
a934 1
    # for speed reasons, _find_round_parameters is embedded here:
d936 5
a940 5
    my ($self, $a, $p, $r, @@args) = @@_;
    # $a accuracy, if given by caller
    # $p precision, if given by caller
    # $r round_mode, if given by caller
    # @@args all 'other' arguments (0 for unary, 1 for binary ops)
d942 2
a943 2
    my $class = ref($self);       # find out class of argument(s)
    no strict 'refs';
d945 8
a952 6
    # now pick $a or $p, but only if we have got "arguments"
    if (!defined $a) {
        foreach ($self, @@args) {
            # take the defined one, or if both defined, the one that is smaller
            $a = $_->{_a} if (defined $_->{_a}) && (!defined $a || $_->{_a} < $a);
        }
d954 9
a962 7
    if (!defined $p) {
        # even if $a is defined, take $p, to signal error for both defined
        foreach ($self, @@args) {
            # take the defined one, or if both defined, the one that is bigger
            # -2 > -3, and 3 > 2
            $p = $_->{_p} if (defined $_->{_p}) && (!defined $p || $_->{_p} > $p);
        }
d964 9
d974 2
a975 3
    # if still none defined, use globals (#2)
    $a = ${"$class\::accuracy"}  unless defined $a;
    $p = ${"$class\::precision"} unless defined $p;
d977 5
a981 2
    # A == 0 is useless, so undef it to signal no rounding
    $a = undef if defined $a && $a == 0;
d983 4
a986 9
    # no rounding today?
    return $self unless defined $a || defined $p; # early out

    # set A and set P is an fatal error
    return $self->bnan() if defined $a && defined $p;

    $r = ${"$class\::round_mode"} unless defined $r;
    if ($r !~ /^(even|odd|[+-]inf|zero|trunc|common)$/) {
        require Carp; Carp::croak ("Unknown round mode '$r'");
d988 3
a990 6

    # now round, by calling either bround or bfround:
    if (defined $a) {
        $self->bround(int($a), $r) if !defined $self->{_a} || $self->{_a} >= $a;
    } else {                  # both can't be undefined due to early out
        $self->bfround(int($p), $r) if !defined $self->{_p} || $self->{_p} <= $p;
d992 3
a994 4

    # bround() or bfround() already called bnorm() if nec.
    $self;
}
d997 1
a997 1
  {
d1004 1
a1004 1
sub babs
d1016 2
a1017 14
sub bsgn {
    # Signum function.

    my $self = shift;

    return $self if $self->modify('bsgn');

    return $self -> bone("+") if $self -> is_pos();
    return $self -> bone("-") if $self -> is_neg();
    return $self;               # zero or NaN
}

sub bneg
  {
d1021 1
a1021 1

d1024 1
a1024 1
  # for +0 do not negate (to have always normalized +0). Does nothing for 'NaN'
d1029 1
a1029 1
sub bcmp
d1033 1
a1033 1

d1037 1
a1037 1
  # objectify is costly, so avoid it
d1057 2
a1058 2
  return 1 if $x->{sign} eq '+' && $y->{sign} eq '-';   # does also 0 <=> -y
  return -1 if $x->{sign} eq '-' && $y->{sign} eq '+';  # does also -x <=> 0
d1060 2
a1061 3
  # have same sign, so compare absolute values.  Don't make tests for zero
  # here because it's actually slower than testing in Calc (especially w/ Pari
  # et al)
d1064 1
a1064 1
  if ($x->{sign} eq '+')
d1071 1
a1071 1
  $CALC->_acmp($y->{value},$x->{value});        # swapped acmp (lib returns 0,1,-1)
d1074 1
a1074 1
sub bacmp
d1076 1
a1076 1
  # Compares 2 values, ignoring their signs.
d1079 1
a1079 1

d1082 1
a1082 1
  # objectify is costly, so avoid it
d1099 1
a1099 1
  $CALC->_acmp($x->{value},$y->{value});        # lib does only 0,1,-1
d1102 1
a1102 1
sub badd
d1109 1
a1109 1
  # objectify is costly, so avoid it
d1119 1
a1119 1
  $r[3] = $y;                           # no push!
d1137 2
d1140 1
a1140 3
  my ($sx, $sy) = ( $x->{sign}, $y->{sign} );           # get signs

  if ($sx eq $sy)
d1142 1
a1142 1
    $x->{value} = $CALC->_add($x->{value},$y->{value}); # same sign, abs add
d1144 1
a1144 1
  else
d1146 2
a1147 2
    my $a = $CALC->_acmp ($y->{value},$x->{value});     # absolute compare
    if ($a > 0)
d1151 1
a1151 1
      }
d1166 1
a1166 1
sub bsub
d1170 1
a1170 1

d1191 1
a1191 1
  $y->{sign} =~ tr/+\-/-+/;     # does nothing for NaN
d1198 3
a1200 3
  $x->badd($y,@@r);              # badd does not leave internal zeros
  $y->{sign} =~ tr/+\-/-+/;     # refix $y (does nothing for NaN)
  $x;                           # already rounded by badd() or no round nec.
d1221 1
a1221 1
  $x->badd($self->bone(),$a,$p,$r);             # badd does round
d1229 1
a1229 1

d1234 1
a1234 1
    }
d1237 1
a1237 2
    return $x->badd($self->bone('-'),@@r)
        unless $x->{sign} eq '+'; # inf or NaN
d1242 1
a1242 1
      $x->{value} = $CALC->_one(); $x->{sign} = '-';            # 0 => -1
d1255 2
a1256 6
  # Return the logarithm of the operand. If a second operand is defined, that
  # value is used as the base, otherwise the base is assumed to be Euler's
  # constant.

  # Don't objectify the base, since an undefined base, as in $x->blog() or
  # $x->blog(undef) signals that the base is Euler's number.
d1261 4
a1264 3
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1]))) {
      ($self,$x,$base,@@r) = objectify(1,@@_);
  }
d1268 1
a1268 2
  # Handle all exception cases and all trivial cases. I have used Wolfram Alpha
  # (http://www.wolframalpha.com) as the reference for these cases.
d1270 3
a1272 16
  return $x -> bnan() if $x -> is_nan();

  if (defined $base) {
      $base = $self -> new($base) unless ref $base;
      if ($base -> is_nan() || $base -> is_one()) {
          return $x -> bnan();
      } elsif ($base -> is_inf() || $base -> is_zero()) {
          return $x -> bnan() if $x -> is_inf() || $x -> is_zero();
          return $x -> bzero();
      } elsif ($base -> is_negative()) {            # -inf < base < 0
          return $x -> bzero() if $x -> is_one();   #     x = 1
          return $x -> bone()  if $x == $base;      #     x = base
          return $x -> bnan();                      #     otherwise
      }
      return $x -> bone() if $x == $base;           # 0 < base && 0 < x < inf
  }
d1274 2
a1275 10
  # We now know that the base is either undefined or >= 2 and finite.

  return $x -> binf('+') if $x -> is_inf();         #   x = +/-inf
  return $x -> bnan()    if $x -> is_neg();         #   -inf < x < 0
  return $x -> bzero()   if $x -> is_one();         #   x = 1
  return $x -> binf('-') if $x -> is_zero();        #   x = 0

  # At this point we are done handling all exception cases and trivial cases.

  return $upgrade -> blog($upgrade -> new($x), $base, @@r) if defined $upgrade;
d1288 1
a1288 1

d1290 1
a1290 1
  return $x->bnan() unless defined $rc;         # not possible to take log?
d1323 7
a1329 5
    # ( 7 )       7!       1*2*3*4 * 5*6*7   5 * 6 * 7       6   7
    # ( - ) = --------- =  --------------- = --------- = 5 * - * -
    # ( 3 )   (7-3)! 3!    1*2*3*4 * 1*2*3   1 * 2 * 3       2   3

    if (!$y->is_zero())
a1330 1
      my $z = $x - $y;
d1334 1
a1334 1
      while ($z->bacmp($x) <= 0)                # f <= x ?
d1378 2
a1379 2
sub blcm
  {
d1382 1
a1382 1
  # Lowest Common Multiple
d1394 1
a1394 1
  while (@@_)
d1398 1
a1398 1
    }
d1402 2
a1403 2
sub bgcd
  {
d1406 1
a1406 1
  # GCD -- Euclid's algorithm, variant C (Knuth Vol 3, pg 341 ff)
d1411 2
a1412 2
  my $x = $y->copy()->babs();                   # keep arguments
  return $x->bnan() if $x->{sign} !~ /^[+-]$/;  # x NaN?
d1417 1
a1417 1
    return $x->bnan() if $y->{sign} !~ /^[+-]$/;        # y NaN?
d1424 1
a1424 1
sub bnot
d1430 1
a1430 1

d1432 1
a1432 1
  $x->binc()->bneg();                   # binc already does round
d1443 2
a1444 2

  return 0 if $x->{sign} !~ /^\+$/;                     # -, NaN & +-inf aren't
d1463 2
a1464 2
    $sign = '[+-]inf' if $sign eq '';   # +- doesn't matter, only that's inf
    $sign = "[$1]inf" if $sign =~ /^([+-])(inf)?$/;     # extract '+' or '-'
d1467 1
a1467 1
  $x->{sign} =~ /^[+-]inf$/ ? 1 : 0;            # only +-inf is infinity
d1474 1
a1474 1

d1476 2
a1477 2

  return 0 if $x->{sign} ne $sign;      # -1 != +1, NaN, +-inf aren't either
d1486 1
a1486 1
  return 0 if $x->{sign} !~ /^[+-]$/;                   # NaN & +-inf aren't
d1495 1
a1495 1
  return 0 if $x->{sign} !~ /^[+-]$/;                   # NaN & +-inf aren't
d1501 1
a1501 1
  # return true when arg (BINT or num_str) is positive (> 0)
d1504 2
a1505 2
  return 1 if $x->{sign} eq '+inf';                     # +inf is positive

d1507 1
a1507 1
  ($x->{sign} eq '+' && !$x->is_zero()) ? 1 : 0;
d1514 2
a1515 2

  $x->{sign} =~ /^-/ ? 1 : 0;           # -inf is negative, but NaN is not
d1523 2
a1524 2

  $x->{sign} =~ /^[+-]$/ ? 1 : 0;               # inf/-inf/NaN aren't
d1529 2
a1530 2
sub bmul
  {
d1553 2
a1554 2
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/);
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/);
d1560 2
a1561 2

  $r[3] = $y;                           # no push here
d1565 2
a1566 2
  $x->{value} = $CALC->_mul($x->{value},$y->{value});   # do actual math
  $x->{sign} = '+' if $CALC->_is_zero($x->{value});     # no -0
d1572 1
a1572 1
  {
d1577 6
a1582 1
  my ($self,$x,$y,$z,@@r) = objectify(3,@@_);
d1587 2
a1588 2
                        ($y->{sign} eq $nan) ||
                        ($z->{sign} eq $nan);
d1597 2
a1598 2
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/);
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/);
d1610 1
a1610 1

d1612 1
a1612 1
  $r[3] = $z;                           # no push here
d1616 2
a1617 2
  $x->{value} = $CALC->_mul($x->{value},$y->{value});   # do actual math
  $x->{sign} = '+' if $CALC->_is_zero($x->{value});     # no -0
d1619 1
a1619 1
  my ($sx, $sz) = ( $x->{sign}, $z->{sign} );           # get signs
d1621 1
a1621 1
  if ($sx eq $sz)
d1623 1
a1623 1
    $x->{value} = $CALC->_add($x->{value},$z->{value}); # same sign, abs add
d1625 1
a1625 1
  else
d1627 2
a1628 2
    my $a = $CALC->_acmp ($z->{value},$x->{value});     # absolute compare
    if ($a > 0)
d1632 1
a1632 1
      }
d1647 1
a1647 1
sub bdiv
d1649 2
d1652 39
a1690 2
    # This does floored division, where the quotient is floored toward negative
    # infinity and the remainder has the same sign as the divisor.
d1692 12
a1703 2
    # Set up parameters.
    my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
d1705 1
a1705 45
    # objectify() is costly, so avoid it if we can.
    if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1]))) {
        ($self,$x,$y,@@r) = objectify(2,@@_);
    }

    return $x if $x->modify('bdiv');

    my $wantarray = wantarray;          # call only once

    # At least one argument is NaN. Return NaN for both quotient and the
    # modulo/remainder.

    if ($x -> is_nan() || $y -> is_nan()) {
        return $wantarray ? ($x -> bnan(), $self -> bnan()) : $x -> bnan();
    }

    # Divide by zero and modulo zero.
    #
    # Division: Use the common convention that x / 0 is inf with the same sign
    # as x, except when x = 0, where we return NaN. This is also what earlier
    # versions did.
    #
    # Modulo: In modular arithmetic, the congruence relation z = x (mod y)
    # means that there is some integer k such that z - x = k y. If y = 0, we
    # get z - x = 0 or z = x. This is also what earlier versions did, except
    # that 0 % 0 returned NaN.
    #
    #     inf / 0 =  inf                     inf % 0 =  inf
    #       5 / 0 =  inf                       5 % 0 =    5
    #       0 / 0 =  NaN                       0 % 0 =    0 (before: NaN)
    #      -5 / 0 = -inf                      -5 % 0 =   -5
    #    -inf / 0 = -inf                    -inf % 0 = -inf

    if ($y -> is_zero()) {
        my ($quo, $rem);
        if ($wantarray) {
                $rem = $x -> copy();
            }
        if ($x -> is_zero()) {
            $quo = $x -> bnan();
        } else {
            $quo = $x -> binf($x -> {sign});
        }
        return $wantarray ? ($quo, $rem) : $quo;
    }
d1707 2
a1708 53
    # Numerator (dividend) is +/-inf, and denominator is finite and non-zero.
    # The divide by zero cases are covered above. In all of the cases listed
    # below we return the same as core Perl.
    #
    #     inf / -inf =  NaN                  inf % -inf =  NaN
    #     inf /   -5 = -inf                  inf %   -5 =  NaN (before: 0)
    #     inf /    5 =  inf                  inf %    5 =  NaN (before: 0)
    #     inf /  inf =  NaN                  inf %  inf =  NaN
    #
    #    -inf / -inf =  NaN                 -inf % -inf =  NaN
    #    -inf /   -5 =  inf                 -inf %   -5 =  NaN (before: 0)
    #    -inf /    5 = -inf                 -inf %    5 =  NaN (before: 0)
    #    -inf /  inf =  NaN                 -inf %  inf =  NaN

    if ($x -> is_inf()) {
        my ($quo, $rem);
        $rem = $self -> bnan() if $wantarray;
        if ($y -> is_inf()) {
            $quo = $x -> bnan();
        } else {
            my $sign = $x -> bcmp(0) == $y -> bcmp(0) ? '+' : '-';
            $quo = $x -> binf($sign);
      }
        return $wantarray ? ($quo, $rem) : $quo;
    }

    # Denominator (divisor) is +/-inf. The cases when the numerator is +/-inf
    # are covered above. In the modulo cases (in the right column) we return
    # the same as core Perl, which does floored division, so for consistency we
    # also do floored division in the division cases (in the left column).
    #
    #      -5 /  inf =   -1 (before: 0)       -5 %  inf =  inf (before: -5)
    #       0 /  inf =    0                    0 %  inf =    0
    #       5 /  inf =    0                    5 %  inf =    5
    #
    #      -5 / -inf =    0                   -5 % -inf =   -5
    #       0 / -inf =    0                    0 % -inf =    0
    #       5 / -inf =   -1 (before: 0)        5 % -inf = -inf (before: 5)

    if ($y -> is_inf()) {
        my ($quo, $rem);
        if ($x -> is_zero() || $x -> bcmp(0) == $y -> bcmp(0)) {
            $rem = $x -> copy() if $wantarray;
            $quo = $x -> bzero();
        } else {
            $rem = $self -> binf($y -> {sign}) if $wantarray;
            $quo = $x -> bone('-');
        }
        return $wantarray ? ($quo, $rem) : $quo;
  }

  # At this point, both the numerator and denominator are finite numbers, and
  # the denominator (divisor) is non-zero.
d1712 2
d1715 3
a1717 1
  $r[3] = $y;                                   # no push!
d1719 3
a1721 17
    # Inialize remainder.

    my $rem = $self->bzero();

    # Are both operands the same object, i.e., like $x -> bdiv($x)?
    # If so, flipping the sign of $y also flips the sign of $x.

    my $xsign = $x->{sign};
    my $ysign = $y->{sign};

    $y->{sign} =~ tr/+-/-+/;            # Flip the sign of $y, and see ...
    my $same = $xsign ne $x->{sign};    # ... if that changed the sign of $x.
    $y->{sign} = $ysign;                # Re-insert the original sign.

    if ($same) {
        $x -> bone();
    } else {
d1723 3
a1725 21

        if ($CALC -> _is_zero($rem->{value})) {
            if ($xsign eq $ysign || $CALC -> _is_zero($x->{value})) {
                $x->{sign} = '+';
            } else {
                $x->{sign} = '-';
            }
        } else {
            if ($xsign eq $ysign) {
                $x->{sign} = '+';
            } else {
                if ($xsign eq '+') {
                    $x -> badd(1);
                } else {
                    $x -> bsub(1);
                }
                $x->{sign} = '-';
            }
        }
    }

d1727 4
a1730 5

    if ($wantarray) {
        unless ($CALC -> _is_zero($rem->{value})) {
            if ($xsign ne $ysign) {
                $rem = $y -> copy() -> babs() -> bsub($rem);
d1732 3
a1734 1
            $rem->{sign} = $ysign;
a1735 2
        $rem->{_a} = $x->{_a};
        $rem->{_p} = $x->{_p};
d1740 4
a1743 1
    return $x;
d1749 1
a1749 1
sub bmod
d1751 4
a1754 6

    # This is the remainder after floored division, where the quotient is
    # floored toward negative infinity and the remainder has the same sign as
    # the divisor.

    # Set up parameters.
a1755 1

d1763 7
a1769 6
  $r[3] = $y;                                   # no push!

    # At least one argument is NaN.

    if ($x -> is_nan() || $y -> is_nan()) {
        return $x -> bnan();
d1772 1
a1772 24
    # Modulo zero. See documentation for bdiv().

    if ($y -> is_zero()) {
            return $x;
        }

    # Numerator (dividend) is +/-inf.

    if ($x -> is_inf()) {
        return $x -> bnan();
    }

    # Denominator (divisor) is +/-inf.

    if ($y -> is_inf()) {
        if ($x -> is_zero() || $x -> bcmp(0) == $y -> bcmp(0)) {
            return $x;
        } else {
            return $x -> binf($y -> sign());
        }
    }

    # Calc new sign and in case $y == +/- 1, return $x.

d1774 1
a1774 1
  if ($CALC -> _is_zero($x->{value}))
d1776 3
a1778 1
        $x->{sign} = '+';       # do not leave -0
d1780 1
a1780 1
  else
d1782 1
a1782 3
    $x->{value} = $CALC->_sub($y->{value},$x->{value},1)        # $y-$x
      if ($x->{sign} ne $y->{sign});
    $x->{sign} = $y->{sign};
a1783 1

d1789 4
a1792 10
  # Return modular multiplicative inverse:
  #
  #   z is the modular inverse of x (mod y) if and only if
  #
  #       x*z ≡ 1  (mod y)
  #
  # If the modulus y is larger than one, x and z are relative primes (i.e.,
  # their greatest common divisor is one).
  #
  # If no modular multiplicative inverse exists, NaN is returned.
d1804 5
a1808 1
  # Return NaN if one or both arguments is +inf, -inf, or nan.
d1810 2
a1811 2
  return $x->bnan() if ($y->{sign} !~ /^[+-]$/ ||
                        $x->{sign} !~ /^[+-]$/);
d1813 7
a1819 52
  # Return NaN if $y is zero; 1 % 0 makes no sense.

  return $x->bnan() if $y->is_zero();

  # Return 0 in the trivial case. $x % 1 or $x % -1 is zero for all finite
  # integers $x.

  return $x->bzero() if ($y->is_one() ||
                         $y->is_one('-'));

  # Return NaN if $x = 0, or $x modulo $y is zero. The only valid case when
  # $x = 0 is when $y = 1 or $y = -1, but that was covered above.
  #
  # Note that computing $x modulo $y here affects the value we'll feed to
  # $CALC->_modinv() below when $x and $y have opposite signs. E.g., if $x =
  # 5 and $y = 7, those two values are fed to _modinv(), but if $x = -5 and
  # $y = 7, the values fed to _modinv() are $x = 2 (= -5 % 7) and $y = 7.
  # The value if $x is affected only when $x and $y have opposite signs.

  $x->bmod($y);
  return $x->bnan() if $x->is_zero();

  # Compute the modular multiplicative inverse of the absolute values. We'll
  # correct for the signs of $x and $y later. Return NaN if no GCD is found.

  ($x->{value}, $x->{sign}) = $CALC->_modinv($x->{value}, $y->{value});
  return $x->bnan() if !defined $x->{value};

  # Library inconsistency workaround: _modinv() in Math::BigInt::GMP versions
  # <= 1.32 return undef rather than a "+" for the sign.

  $x->{sign} = '+' unless defined $x->{sign};

  # When one or both arguments are negative, we have the following
  # relations.  If x and y are positive:
  #
  #   modinv(-x, -y) = -modinv(x, y)
  #   modinv(-x,  y) = y - modinv(x, y)  = -modinv(x, y) (mod y)
  #   modinv( x, -y) = modinv(x, y) - y  =  modinv(x, y) (mod -y)

  # We must swap the sign of the result if the original $x is negative.
  # However, we must compensate for ignoring the signs when computing the
  # inverse modulo. The net effect is that we must swap the sign of the
  # result if $y is negative.

  $x -> bneg() if $y->{sign} eq '-';

  # Compute $x modulo $y again after correcting the sign.

  $x -> bmod($y) if $x->{sign} ne $y->{sign};

  return $x;
d1824 3
a1826 3
  # Modular exponentiation. Raises a very large number to a very large exponent
  # in a given very large modulus quickly, thanks to binary exponentiation.
  # Supports negative exponents.
d1831 3
a1833 4
  # When the exponent 'e' is negative, use the following relation, which is
  # based on finding the multiplicative inverse 'd' of 'b' modulo 'm':
  #
  #    b^(-e) (mod m) = d^e (mod m) where b*d = 1 (mod m)
d1835 6
a1840 76
  $num->bmodinv($mod) if ($exp->{sign} eq '-');

  # Check for valid input. All operands must be finite, and the modulus must be
  # non-zero.

  return $num->bnan() if ($num->{sign} =~ /NaN|inf/ ||  # NaN, -inf, +inf
                          $exp->{sign} =~ /NaN|inf/ ||  # NaN, -inf, +inf
                          $mod->{sign} =~ /NaN|inf/);   # NaN, -inf, +inf

  # Modulo zero. See documentation for Math::BigInt's bmod() method.

  if ($mod -> is_zero()) {
      if ($num -> is_zero()) {
          return $self -> bnan();
      } else {
          return $num -> copy();
      }
  }

  # Compute 'a (mod m)', ignoring the signs on 'a' and 'm'. If the resulting
  # value is zero, the output is also zero, regardless of the signs on 'a' and
  # 'm'.

  my $value = $CALC->_modpow($num->{value}, $exp->{value}, $mod->{value});
  my $sign  = '+';

  # If the resulting value is non-zero, we have four special cases, depending
  # on the signs on 'a' and 'm'.

  unless ($CALC->_is_zero($value)) {

      # There is a negative sign on 'a' (= $num**$exp) only if the number we
      # are exponentiating ($num) is negative and the exponent ($exp) is odd.

      if ($num->{sign} eq '-' && $exp->is_odd()) {

          # When both the number 'a' and the modulus 'm' have a negative sign,
          # use this relation:
          #
          #    -a (mod -m) = -(a (mod m))

          if ($mod->{sign} eq '-') {
              $sign = '-';
          }

          # When only the number 'a' has a negative sign, use this relation:
          #
          #    -a (mod m) = m - (a (mod m))

          else {
              # Use copy of $mod since _sub() modifies the first argument.
              my $mod = $CALC->_copy($mod->{value});
              $value = $CALC->_sub($mod, $value);
              $sign  = '+';
          }

      } else {

          # When only the modulus 'm' has a negative sign, use this relation:
          #
          #    a (mod -m) = (a (mod m)) - m
          #               = -(m - (a (mod m)))

          if ($mod->{sign} eq '-') {
              # Use copy of $mod since _sub() modifies the first argument.
              my $mod = $CALC->_copy($mod->{value});
              $value = $CALC->_sub($mod, $value);
              $sign  = '-';
          }

          # When neither the number 'a' nor the modulus 'm' have a negative
          # sign, directly return the already computed value.
          #
          #    (a (mod m))

      }
d1842 1
a1842 1
  }
d1844 2
a1845 2
  $num->{value} = $value;
  $num->{sign}  = $sign;
d1847 3
a1849 1
  return $num;
d1860 2
a1861 2
  return $x if $x->modify('bfac') || $x->{sign} eq '+inf';      # inf => inf
  return $x->bnan() if $x->{sign} ne '+';                       # NaN, <0 etc => NaN
d1866 2
a1867 2

sub bpow
d1912 1
a1912 1

d1937 1
a1937 1
  $r[3] = $y;                                   # no push!
d1942 1
a1942 1
  $new_sign = $y->is_odd() ? '-' : '+' if ($x->{sign} ne '+');
d1944 2
a1945 2
  # 0 ** -7 => ( 1 / (0 ** 7)) => 1 / 0 => +inf
  return $x->binf()
d1957 1
a1957 1
sub blsft
d1961 1
a1961 1

d1980 1
a1980 1
sub brsft
d1984 1
a1984 1

d1996 1
a1996 1
  return $x->bzero(@@r) if $x->is_zero();                # 0 => 0
d2003 1
a2003 1
    return $x->round(@@r) if $x->is_one('-');    # -1 => -1
d2010 1
a2010 1
      $x->binc();                       # -3 => -2
d2012 2
a2013 2
      $bin =~ s/^-0b//;                 # strip '-0b' prefix
      $bin =~ tr/10/01/;                # flip bits
d2017 5
a2021 5
        $bin = '0';                     # shifting to far right creates -1
                                        # 0, because later increment makes
                                        # that 1, attached '-' makes it '-1'
                                        # because -1 >> x == -1 !
        }
d2023 9
a2031 9
        {
        $bin =~ s/.{$y}$//;             # cut off at the right side
        $bin = '1' . $bin;              # extend left side by one dummy '1'
        $bin =~ tr/10/01/;              # flip bits back
        }
      my $res = $self->new('0b'.$bin);  # add prefix and convert back
      $res->binc();                     # remember to increment
      $x->{value} = $res->{value};      # take over value
      return $x->round(@@r);             # we are done now, magic, isn't?
d2034 1
a2034 1
    $x->bdec();                         # n == 2, but $y == 1: this fixes it
d2041 1
a2041 1
sub band
d2045 1
a2045 1

d2053 1
a2053 1

d2056 1
a2056 1
  $r[3] = $y;                           # no push!
d2062 1
a2062 1

d2068 1
a2068 1

d2074 1
a2074 1

d2079 1
a2079 1
sub bior
d2083 1
a2083 1

d2093 1
a2093 1
  $r[3] = $y;                           # no push!
d2101 1
a2101 1

d2120 1
a2120 1
sub bxor
d2124 1
a2124 1

d2134 1
a2134 1
  $r[3] = $y;                           # no push!
d2137 1
a2137 1

d2147 1
a2147 1

d2163 1
a2163 1
  my $e = $CALC->_len($x->{value});
d2182 1
a2182 1
  return 0 if $x->{sign} !~ /^[+-]$/;   # NaN, inf, -inf etc
d2184 1
a2184 1
  $CALC->_zeros($x->{value});           # must handle odd values, 0 etc
d2194 2
a2195 2
  return $x->bnan() if $x->{sign} !~ /^\+/;     # -x or -inf or NaN => NaN
  return $x if $x->{sign} eq '+inf';            # sqrt(+inf) == inf
d2206 1
a2206 1

d2237 1
a2237 1

d2243 1
a2243 1
  return $self->bzero() if $x->is_zero();
d2274 1
a2274 1

d2286 1
a2286 1
  return $x if !defined $scale || $x->modify('bfround');        # no-op
d2291 2
a2292 2
  delete $x->{_a};      # delete to save memory
  $x->{_p} = $scale;    # store new _p
d2300 2
a2301 2

  return 0 if $len == 1;                # "5" is trailed by invisible zeros
d2327 2
a2328 2
  return $x if !defined $scale || $x->modify('bround'); # no-op

d2334 1
a2334 1
  return $x if $x->{sign} !~ /^[+-]$/;          # inf, NaN
d2347 1
a2347 1
    return $x;
d2349 1
a2349 1

d2368 1
a2368 1
  my $round_up = 1;                                     # default round up
d2370 5
a2374 5
    ($mode eq 'trunc')                          ||      # trunc by round down
    ($digit_after =~ /[01234]/)                 ||      # round down anyway,
                                                        # 6789 => round up
    ($digit_after eq '5')                       &&      # not 5000...0000
    ($x->_scan_for_nonzero($pad,$xs,$len) == 0)         &&
d2380 1
a2380 1
     ($mode eq 'zero')          # round down if zero, sign adjusted below
d2382 2
a2383 2
  my $put_back = 0;                                     # not yet modified

d2386 2
a2387 2
    substr($xs,-$pad,$pad) = '0' x $pad;                # replace with '00...'
    $put_back = 1;                                      # need to put back
d2391 1
a2391 1
    $x->bzero();                                        # round to '0'
d2394 1
a2394 1
  if ($round_up)                                        # what gave test above?
d2396 2
a2397 2
    $put_back = 1;                                      # need to put back
    $pad = $len, $xs = '0' x $pad if $scale < 0;        # tlr: whack 0.51=>1.0
d2401 1
a2401 1
    my $c = 0; $pad ++;                         # for $pad == $len case
d2406 1
a2406 1
      last if $c != 0;                          # no overflow => early out
d2411 1
a2411 1
  $x->{value} = $CALC->_new($xs) if $put_back == 1;     # put back, if needed
d2424 1
a2424 1
  # round towards minus infinity; no-op since it's already integer
d2432 1
a2432 1
  # round towards plus infinity; no-op since it's already int
a2437 7
sub bint {
    # round towards zero; no-op since it's already integer
    my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

    $x->round(@@r);
}

d2451 1
a2451 1
  return $x->bstr() if $x->{sign} !~ /^[+-]$/;  # inf, nan etc
d2463 1
a2463 1
  return $x->bstr() if $x->{sign} !~ /^[+-]$/;  # inf, nan etc
d2474 1
a2474 1
  return $x->bstr() if $x->{sign} !~ /^[+-]$/;  # inf, nan etc
d2476 2
a2477 2
  my $oct = $CALC->_as_oct($x->{value});
  return $x->{sign} eq '-' ? "-$oct" : $oct;
d2483 35
a2517 28
sub objectify {
    # Convert strings and "foreign objects" to the objects we want.

    # The first argument, $count, is the number of following arguments that
    # objectify() looks at and converts to objects. The first is a classname.
    # If the given count is 0, all arguments will be used.

    # After the count is read, objectify obtains the name of the class to which
    # the following arguments are converted. If the second argument is a
    # reference, use the reference type as the class name. Otherwise, if it is
    # a string that looks like a class name, use that. Otherwise, use $class.

    # Caller:                        Gives us:
    #
    # $x->badd(1);                => ref x, scalar y
    # Class->badd(1,2);           => classname x (scalar), scalar x, scalar y
    # Class->badd(Class->(1),2);  => classname x (scalar), ref x, scalar y
    # Math::BigInt::badd(1,2);    => scalar x, scalar y

    # A shortcut for the common case $x->unary_op():

    return (ref($_[1]), $_[1]) if (@@_ == 2) && ($_[0]||0 == 1) && ref($_[1]);

    # Check the context.

    unless (wantarray) {
        require Carp;
        Carp::croak ("${class}::objectify() needs list context");
d2519 1
a2519 14

    # Get the number of arguments to objectify.

    my $count = shift;
    $count ||= @@_;

    # Initialize the output array.

    my @@a = @@_;

    # If the first argument is a reference, use that reference type as our
    # class name. Otherwise, if the first argument looks like a class name,
    # then use that as our class name. Otherwise, use the default class name.

d2521 3
a2523 8
        if (ref($a[0])) {               # reference?
            unshift @@a, ref($a[0]);
            last;
        }
        if ($a[0] =~ /^[A-Z].*::/) {    # string with class name?
            last;
        }
        unshift @@a, $class;             # default class name
d2526 6
a2531 13
    no strict 'refs';

    # What we upgrade to, if anything.

    my $up = ${"$a[0]::upgrade"};

    # Disable downgrading, because Math::BigFloat -> foo('1.0','2.0') needs
    # floats.

    my $down;
    if (defined ${"$a[0]::downgrade"}) {
        $down = ${"$a[0]::downgrade"};
        ${"$a[0]::downgrade"} = undef;
d2534 10
a2543 8
    for my $i (1 .. $count) {
        my $ref = ref $a[$i];

        # Perl scalars are fed to the appropriate constructor.

        unless ($ref) {
            $a[$i] = $a[0] -> new($a[$i]);
            next;
d2545 17
a2561 9

        # If it is an object of the right class, all is fine.

        next if $ref -> isa($a[0]);

        # Upgrading is OK, so skip further tests if the argument is upgraded.

        if (defined $up && $ref -> isa($up)) {
            next;
d2563 12
a2574 44

        # See if we can call one of the as_xxx() methods. We don't know whether
        # the as_xxx() method returns an object or a scalar, so re-check
        # afterwards.

        my $recheck = 0;

        if ($a[0] -> isa('Math::BigInt')) {
            if ($a[$i] -> can('as_int')) {
                $a[$i] = $a[$i] -> as_int();
                $recheck = 1;
            } elsif ($a[$i] -> can('as_number')) {
                $a[$i] = $a[$i] -> as_number();
                $recheck = 1;
            }
        }

        elsif ($a[0] -> isa('Math::BigFloat')) {
            if ($a[$i] -> can('as_float')) {
                $a[$i] = $a[$i] -> as_float();
                $recheck = $1;
            }
        }

        # If we called one of the as_xxx() methods, recheck.

        if ($recheck) {
            $ref = ref($a[$i]);

            # Perl scalars are fed to the appropriate constructor.

            unless ($ref) {
                $a[$i] = $a[0] -> new($a[$i]);
                next;
            }

            # If it is an object of the right class, all is fine.

            next if $ref -> isa($a[0]);
        }

        # Last resort.

        $a[$i] = $a[0] -> new($a[$i]);
d2576 3
a2578 7

    # Reset the downgrading.

    ${"$a[0]::downgrade"} = $down;

    return @@a;
}
d2585 1
a2585 1
    {
d2592 1
a2592 1
sub import
d2596 1
a2596 1
  $IMPORT++;                            # remember we did import()
d2598 1
a2598 1
  my $warn_or_die = 0;                  # 0 - no warn, 1 - warn, 2 - die
d2604 3
a2606 3
      overload::constant
        integer => sub { $self->new(shift) },
        binary => sub { $self->new(shift) };
d2611 1
a2611 1
      $upgrade = $_[$i+1];              # or undef to disable
d2632 3
a2634 3

    $self->SUPER::import(@@a);                   # need it for subclasses
    $self->export_to_level(1,$self,@@a);         # need it for MBF
d2641 1
a2641 1
    $_ =~ tr/a-zA-Z0-9://cd;                    # limit to sane characters
d2643 3
a2645 3
  push @@c, \'Calc'                              # if all fail, try these
    if $warn_or_die < 2;                        # but not for "only"
  $CALC = '';                                   # signal error
d2673 3
a2675 3
        {
        $ok = 0;
        # api_version matches, check if it really provides anything we need
d2677 10
a2686 10
                one two ten
                str num
                add mul div sub dec inc
                acmp len digit is_one is_zero is_even is_odd
                is_two is_ten
                zeros new copy check
                from_hex from_oct from_bin as_hex as_bin as_oct
                rsft lsft xor and or
                mod sqrt root fac pow modinv modpow log_int gcd
         /)
d2688 10
a2697 10
          if (!$lib->can("_$method"))
            {
            if (($WARN{$lib}||0) < 2)
              {
              require Carp;
              Carp::carp ("$lib is missing method '_$method'");
              $WARN{$lib} = 1;          # still warn about the lib
              }
            $ok++; last;
            }
d2699 1
a2699 1
        }
d2701 6
a2706 7
        {
        $CALC = $lib;
        if ($warn_or_die > 0 && ref($l))
          {
          require Carp;
          my $msg =
        "Math::BigInt: couldn't load specified math lib(s), fallback to $lib";
d2709 3
a2711 3
          }
        last;                   # found a usable one, break
        }
d2713 8
a2720 8
        {
        if (($WARN{$lib}||0) < 2)
          {
          my $ver = eval "\$$lib\::VERSION" || 'unknown';
          require Carp;
          Carp::carp ("Cannot load outdated $lib v$ver, please upgrade");
          $WARN{$lib} = 2;              # never warn again
          }
d2729 1
a2729 2
      Carp::croak(
          "Couldn't load specified math lib(s) and fallback disallowed");
d2733 1
a2733 2
      Carp::croak(
          "Couldn't load any math lib(s), not even fallback to Calc.pm");
d2755 4
a2758 1
# Create a Math::BigInt from a hexadecimal string.
d2760 1
a2760 4
sub from_hex {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;
d2762 1
a2762 1
    my $str = shift;
d2764 2
a2765 1
    # If called as a class method, initialize a new object.
d2767 4
a2770 1
    $self = $class -> bzero() unless $selfref;
d2772 1
a2772 13
    if ($str =~ s/
                     ^
                     ( [+-]? )
                     (0?x)?
                     (
                         [0-9a-fA-F]*
                         ( _ [0-9a-fA-F]+ )*
                     )
                     $
                 //x)
    {
        # Get a "clean" version of the string, i.e., non-emtpy and with no
        # underscores or invalid characters.
d2774 1
a2774 4
        my $sign = $1;
        my $chrs = $3;
        $chrs =~ tr/_//d;
        $chrs = '0' unless CORE::length $chrs;
d2776 2
a2777 1
        # The library method requires a prefix.
d2779 4
a2782 1
        $self->{value} = $CALC->_from_hex('0x' . $chrs);
d2784 7
a2790 1
        # Place the sign.
d2792 1
a2792 3
        if ($sign eq '-' && ! $CALC->_is_zero($self->{value})) {
            $self->{sign} = '-';
        }
d2794 5
a2798 2
        return $self;
    }
d2800 21
a2820 2
    # CORE::hex() parses as much as it can, and ignores any trailing garbage.
    # For backwards compatibility, we return NaN.
d2822 5
a2826 2
    return $self->bnan();
}
d2828 1
a2828 1
# Create a Math::BigInt from an octal string.
d2830 4
a2833 4
sub from_oct {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;
d2835 2
a2836 1
    my $str = shift;
d2838 4
a2841 165
    # If called as a class method, initialize a new object.

    $self = $class -> bzero() unless $selfref;

    if ($str =~ s/
                     ^
                     ( [+-]? )
                     (
                         [0-7]*
                         ( _ [0-7]+ )*
                     )
                     $
                 //x)
    {
        # Get a "clean" version of the string, i.e., non-emtpy and with no
        # underscores or invalid characters.

        my $sign = $1;
        my $chrs = $2;
        $chrs =~ tr/_//d;
        $chrs = '0' unless CORE::length $chrs;

        # The library method requires a prefix.

        $self->{value} = $CALC->_from_oct('0' . $chrs);

        # Place the sign.

        if ($sign eq '-' && ! $CALC->_is_zero($self->{value})) {
            $self->{sign} = '-';
        }

        return $self;
    }

    # CORE::oct() parses as much as it can, and ignores any trailing garbage.
    # For backwards compatibility, we return NaN.

    return $self->bnan();
}

# Create a Math::BigInt from a binary string.

sub from_bin {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    my $str = shift;

    # If called as a class method, initialize a new object.

    $self = $class -> bzero() unless $selfref;

    if ($str =~ s/
                     ^
                     ( [+-]? )
                     (0?b)?
                     (
                         [01]*
                         ( _ [01]+ )*
                     )
                     $
                 //x)
    {
        # Get a "clean" version of the string, i.e., non-emtpy and with no
        # underscores or invalid characters.

        my $sign = $1;
        my $chrs = $3;
        $chrs =~ tr/_//d;
        $chrs = '0' unless CORE::length $chrs;

        # The library method requires a prefix.

        $self->{value} = $CALC->_from_bin('0b' . $chrs);

        # Place the sign.

        if ($sign eq '-' && ! $CALC->_is_zero($self->{value})) {
            $self->{sign} = '-';
        }

        return $self;
    }

    # For consistency with from_hex() and from_oct(), we return NaN when the
    # input is invalid.

    return $self->bnan();
}

sub _split_dec_string {
    my $str = shift;

    if ($str =~ s/
                     ^

                     # leading whitespace
                     ( \s* )

                     # optional sign
                     ( [+-]? )

                     # significand
                     (
                         \d+ (?: _ \d+ )*
                         (?:
                             \.
                             (?: \d+ (?: _ \d+ )* )?
                         )?
                     |
                         \.
                         \d+ (?: _ \d+ )*
                     )

                     # optional exponent
                     (?:
                         [Ee]
                         ( [+-]? )
                         ( \d+ (?: _ \d+ )* )
                     )?

                     # trailing stuff
                     ( \D .*? )?

                     \z
                 //x)
    {
        my $leading         = $1;
        my $significand_sgn = $2 || '+';
        my $significand_abs = $3;
        my $exponent_sgn    = $4 || '+';
        my $exponent_abs    = $5 || '0';
        my $trailing        = $6;

        # Remove underscores and leading zeros.

        $significand_abs =~ tr/_//d;
        $exponent_abs    =~ tr/_//d;

        $significand_abs =~ s/^0+(.)/$1/;
        $exponent_abs    =~ s/^0+(.)/$1/;

        # If the significand contains a dot, remove it and adjust the exponent
        # accordingly. E.g., "1234.56789e+3" -> "123456789e-2"

        my $idx = index $significand_abs, '.';
        if ($idx > -1) {
            $significand_abs =~ s/0+\z//;
            substr($significand_abs, $idx, 1) = '';
            my $exponent = $exponent_sgn . $exponent_abs;
            $exponent .= $idx - CORE::length($significand_abs);
            $exponent_abs = abs $exponent;
            $exponent_sgn = $exponent < 0 ? '-' : '+';
        }

        return($leading,
               $significand_sgn, $significand_abs,
               $exponent_sgn, $exponent_abs,
               $trailing);
    }

    return undef;
}
d2846 1
a2846 2
  # (\$mantissa_sign,\$mantissa_value,\$mantissa_fraction,
  # \$exp_sign,\$exp_value)
d2852 1
a2852 1
  # strip white space at front, also extraneous leading zeros
d2867 3
a2869 3
  return Math::BigInt->from_hex($x) if $x =~ /^[+-]?0x/;        # hex string
  return Math::BigInt->from_bin($x) if $x =~ /^[+-]?0b/;        # binary string

d2872 1
a2872 1
  $x =~ s/([0-9])_([0-9])/$1$2/g;               # do twice for 1_2_3
d2874 3
a2876 3
  # some possible inputs:
  # 2.1234 # 0.12        # 1          # 1E1 # 2.134E1 # 434E-10 # 1.02009E-2
  # .2     # 1_2_3.4_5_6 # 1.4E1_2_3  # 1e3 # +.2     # 0e999
d2879 1
a2879 1
  return if defined $last;              # last defined => 1e2E3 or others
d2885 1
a2885 1
  if ($e =~ /^([+-]?)0*([0-9]+)$/)      # strip leading zeros
d2891 1
a2891 1
    return if defined $lastf;           # lastf defined => 1.2.3 or others
d2895 1
a2895 1
    if ($mi =~ /^([+-]?)0*([0-9]+)$/)           # strip leading zeros
d2898 1
a2898 1
      return unless ($mf =~ /^([0-9]*?)0*$/);   # strip trailing zeros
d2911 2
a2912 2
sub __lcm
  {
d2916 1
a2916 1

d2953 1
a2953 1
  return $x->bnan() if $x->{sign} !~ /^[+-]\z/; # -inf +inf or NaN => NaN
d2974 1
a2974 1
  return $x->bnan() if $x->{sign} !~ /^[+-]\z/; # -inf +inf or NaN => NaN
d2988 1
a2988 1
  {
d2990 1
a2990 1

d3048 1
a3048 3
  my $r = Math::BigFloat->new($y)
                        ->batan2(Math::BigFloat->new($x),@@r)
                        ->as_int();
d3064 1
a3064 1
  return $x->bnan() if $x->{sign} !~ /^[+-]\z/; # -inf +inf or NaN => NaN
d3103 1
a3103 1
  # to suppress the warning use this:
d3113 16
a3128 18
  # Number creation
  my $x = Math::BigInt->new($str);      # defaults to 0
  my $y = $x->copy();                   # make a true copy
  my $nan  = Math::BigInt->bnan();      # create a NotANumber
  my $zero = Math::BigInt->bzero();     # create a +0
  my $inf = Math::BigInt->binf();       # create a +inf
  my $inf = Math::BigInt->binf('-');    # create a -inf
  my $one = Math::BigInt->bone();       # create a +1
  my $mone = Math::BigInt->bone('-');   # create a -1

  my $pi = Math::BigInt->bpi();         # returns '3'
                                        # see Math::BigFloat::bpi()

  $h = Math::BigInt->new('0x123');      # from hexadecimal
  $b = Math::BigInt->new('0b101');      # from binary
  $o = Math::BigInt->from_oct('0101');  # from octal
  $h = Math::BigInt->from_hex('cafe');  # from hexadecimal
  $b = Math::BigInt->from_bin('0101');  # from binary
d3133 10
a3142 10
  $x->is_zero();        # if $x is +0
  $x->is_nan();         # if $x is NaN
  $x->is_one();         # if $x is +1
  $x->is_one('-');      # if $x is -1
  $x->is_odd();         # if $x is odd
  $x->is_even();        # if $x is even
  $x->is_pos();         # if $x > 0
  $x->is_neg();         # if $x < 0
  $x->is_inf($sign);    # if $x is +inf, or -inf (sign is default '+')
  $x->is_int();         # if $x is an integer (not a float)
d3145 64
a3208 68
  $x->bcmp($y);         # compare numbers (undef,<0,=0,>0)
  $x->bacmp($y);        # compare absolutely (undef,<0,=0,>0)
  $x->sign();           # return the sign, either +,- or NaN
  $x->digit($n);        # return the nth digit, counting from right
  $x->digit(-$n);       # return the nth digit, counting from left

  # The following all modify their first argument. If you want to pre-
  # serve $x, use $z = $x->copy()->bXXX($y); See under L<CAVEATS> for
  # why this is necessary when mixing $a = $b assignments with non-over-
  # loaded math.

  $x->bzero();          # set $x to 0
  $x->bnan();           # set $x to NaN
  $x->bone();           # set $x to +1
  $x->bone('-');        # set $x to -1
  $x->binf();           # set $x to inf
  $x->binf('-');        # set $x to -inf

  $x->bneg();           # negation
  $x->babs();           # absolute value
  $x->bsgn();           # sign function (-1, 0, 1, or NaN)
  $x->bnorm();          # normalize (no-op in BigInt)
  $x->bnot();           # two's complement (bit wise not)
  $x->binc();           # increment $x by 1
  $x->bdec();           # decrement $x by 1

  $x->badd($y);         # addition (add $y to $x)
  $x->bsub($y);         # subtraction (subtract $y from $x)
  $x->bmul($y);         # multiplication (multiply $x by $y)
  $x->bdiv($y);         # divide, set $x to quotient
                        # return (quo,rem) or quo if scalar

  $x->bmuladd($y,$z);   # $x = $x * $y + $z

  $x->bmod($y);         # modulus (x % y)
  $x->bmodpow($y,$mod); # modular exponentiation (($x ** $y) % $mod)
  $x->bmodinv($mod);    # modular multiplicative inverse
  $x->bpow($y);         # power of arguments (x ** y)
  $x->blsft($y);        # left shift in base 2
  $x->brsft($y);        # right shift in base 2
                        # returns (quo,rem) or quo if in sca-
                        # lar context
  $x->blsft($y,$n);     # left shift by $y places in base $n
  $x->brsft($y,$n);     # right shift by $y places in base $n
                        # returns (quo,rem) or quo if in sca-
                        # lar context

  $x->band($y);         # bitwise and
  $x->bior($y);         # bitwise inclusive or
  $x->bxor($y);         # bitwise exclusive or
  $x->bnot();           # bitwise not (two's complement)

  $x->bsqrt();          # calculate square-root
  $x->broot($y);        # $y'th root of $x (e.g. $y == 3 => cubic root)
  $x->bfac();           # factorial of $x (1*2*3*4*..$x)

  $x->bnok($y);         # x over y (binomial coefficient n over k)

  $x->blog();           # logarithm of $x to base e (Euler's number)
  $x->blog($base);      # logarithm of $x to base $base (f.i. 2)
  $x->bexp();           # calculate e ** $x where e is Euler's number

  $x->round($A,$P,$mode);  # round to accuracy or precision using
                           # mode $mode
  $x->bround($n);          # accuracy: preserve $n digits
  $x->bfround($n);         # $n > 0: round $nth digits,
                           # $n < 0: round to the $nth digit after the
                           # dot, no-op for BigInts
d3213 3
a3215 4
  $x->bfloor();            # round towards minus infinity
  $x->bceil();             # round towards plus infinity
  $x->bint();              # round towards zero

d3220 20
a3239 21
  # lowest common multiple (no OO style)
  my $lcm = Math::BigInt::blcm(@@values);

  $x->length();            # return number of digits in number
  ($xl,$f) = $x->length(); # length of number and length of fraction
                           # part, latter is always 0 digits long
                           # for BigInts

  $x->exponent();         # return exponent as BigInt
  $x->mantissa();         # return (signed) mantissa as BigInt
  $x->parts();            # return (mantissa,exponent) as BigInt
  $x->copy();             # make a true copy of $x (unlike $y = $x;)
  $x->as_int();           # return as BigInt (in BigInt: same as copy())
  $x->numify();           # return as scalar (might overflow!)

  # conversion to string (do not modify their argument)
  $x->bstr();         # normalized string (e.g. '3')
  $x->bsstr();        # norm. string in scientific notation (e.g. '3E0')
  $x->as_hex();       # as signed hexadecimal string with prefixed 0x
  $x->as_bin();       # as signed binary string with prefixed 0b
  $x->as_oct();       # as signed octal string with prefixed 0
d3243 4
a3246 4
  $x->precision();       # return P of $x (or global, if P of $x undef)
  $x->precision($n);     # set P of $x to $n
  $x->accuracy();        # return A of $x (or global, if A of $x undef)
  $x->accuracy($n);      # set A $x to $n
d3249 5
a3253 6
  Math::BigInt->precision();   # get/set global P for all BigInt objects
  Math::BigInt->accuracy();    # get/set global A for all BigInt objects
  Math::BigInt->round_mode();  # get/set global round mode, one of
                               # 'even', 'odd', '+inf', '-inf', 'zero',
                               # 'trunc' or 'common'
  Math::BigInt->config();      # return hash containing configuration
d3260 1
a3260 1
  $i = Math::BigInt -> new('123_456_789_123_456_789');
d3265 3
a3267 1
=head2 Input
d3273 1
a3273 1
may already have lost precision due to the conversion to float. Quote
d3276 2
a3277 2
        $x = Math::BigInt->new(12345678890123456789);   # bad
        $x = Math::BigInt->new('12345678901234567890'); # good
d3288 2
a3289 2
        perl -MMath::BigInt -le 'print Math::BigInt->new("0123")'

d3292 1
a3292 1
        perl -MMath::BigInt -le 'print Math::BigInt->from_oct("0123")'
d3298 2
a3299 2
        $zero = Math::BigInt->bzero();
        $nan = Math::BigInt->bnan();
d3301 2
a3302 2
C<bnorm()> on a BigInt object is now effectively a no-op, since the numbers
are always stored in normalized form. If passed a string, creates a BigInt
d3305 1
a3305 1
=head2 Output
d3308 1
a3308 1
return a string (see L</SYNOPSIS>).
d3314 2
d3321 1
a3321 1
L</ACCURACY and PRECISION> for more information.
d3323 1
a3323 1
=over
d3325 1
a3325 1
=item config()
d3327 2
a3328 4
    use Data::Dumper;

    print Dumper ( Math::BigInt->config() );
    print Math::BigInt->config()->{lib},"\n";
d3334 27
a3360 27
    key           Description
                  Example
    ============================================================
    lib           Name of the low-level math library
                  Math::BigInt::Calc
    lib_version   Version of low-level math library (see 'lib')
                  0.30
    class         The class name of config() you just called
                  Math::BigInt
    upgrade       To which class math operations might be
                  upgraded Math::BigFloat
    downgrade     To which class math operations might be
                  downgraded undef
    precision     Global precision
                  undef
    accuracy      Global accuracy
                  undef
    round_mode    Global round mode
                  even
    version       version number of the class you used
                  1.61
    div_scale     Fallback accuracy for div
                  40
    trap_nan      If true, traps creation of NaN via croak()
                  1
    trap_inf      If true, traps creation of +inf/-inf via croak()
                  1
d3364 1
a3364 1
        trap_inf trap_nan
d3368 2
d3371 1
a3371 5
        $new_cfg = Math::BigInt->config(
            { trap_inf => 1, precision => 5 }
        );

=item accuracy()
d3373 3
a3375 3
    $x->accuracy(5);         # local for $x
    CLASS->accuracy(5);      # global for all members of CLASS
                             # Note: This also applies to new()!
d3377 2
a3378 2
    $A = $x->accuracy();     # read out accuracy that affects $x
    $A = CLASS->accuracy();  # read out global accuracy
d3385 1
a3385 1
that number will also be rounded.
d3388 1
a3388 1
L</round()>, L</bround()> or L</bfround()> or by passing the desired accuracy
d3391 4
a3394 4
    my $x = Math::BigInt->new(30000);
    my $y = Math::BigInt->new(7);
    print scalar $x->copy()->bdiv($y, 2);               # print 4300
    print scalar $x->copy()->bdiv($y)->bround(2);       # print 4300
d3396 1
a3396 1
Please see the section about L</ACCURACY and PRECISION> for further details.
d3400 2
a3401 2
    $x->accuracy(undef);
    Math::BigInt->accuracy(undef);
d3403 2
a3404 2
Returns the current accuracy. For C<< $x->accuracy() >> it will return either
the local accuracy, or if not defined, the global. This means the return value
d3407 9
a3415 11
    $y = Math::BigInt->new(1234567);       # unrounded
    print Math::BigInt->accuracy(4),"\n";  # set 4, print 4
    $x = Math::BigInt->new(123456);        # $x will be automatic-
                                           # ally rounded!
    print "$x $y\n";                       # '123500 1234567'
    print $x->accuracy(),"\n";             # will be 4
    print $y->accuracy(),"\n";             # also 4, since
                                           # global is 4
    print Math::BigInt->accuracy(5),"\n";  # set to 5, print 5
    print $x->accuracy(),"\n";             # still 4
    print $y->accuracy(),"\n";             # 5, since global is 5
d3422 4
a3425 1
=item precision()
d3427 3
a3429 8
    $x->precision(-2);          # local for $x, round at the second
                                # digit right of the dot
    $x->precision(2);           # ditto, round at the second digit
                                # left of the dot

    CLASS->precision(5);        # Global for all members of CLASS
                                # This also applies to new()!
    CLASS->precision(-5);       # ditto
d3431 2
a3432 2
    $P = CLASS->precision();    # read out global precision
    $P = $x->precision();       # read out precision that affects $x
d3434 2
a3435 2
Note: You probably want to use L</accuracy()> instead. With L</accuracy()> you
set the number of digits each result should have, with L</precision()> you
d3446 1
a3446 1
Please see the section about L</ACCURACY and PRECISION> for further details.
d3450 2
a3451 2
    $x->precision(undef);
    Math::BigInt->precision(undef);
d3453 2
a3454 2
Returns the current precision. For C<< $x->precision() >> it will return either
the local precision of $x, or if not defined, the global. This means the return
d3457 4
a3460 4
    $y = Math::BigInt->new(1234567);        # unrounded
    print Math::BigInt->precision(4),"\n";  # set 4, print 4
    $x = Math::BigInt->new(123456);  # will be automatically rounded
    print $x;                               # print "120000"!
d3467 1
a3467 1
=item brsft()
d3469 1
a3469 1
    $x->brsft($y,$n);
d3478 4
a3481 4
    $x = Math::BigInt->new(10);
    $x->brsft(1);                       # same as $x >> 1: 5
    $x = Math::BigInt->new(1234);
    $x->brsft(2,10);                    # result 12
d3486 2
a3487 2
    $x = Math::BigInt->new(-5);
    print $x->brsft(1);
d3492 1
a3492 1
=item new()
d3494 1
a3494 1
    $x = Math::BigInt->new($str,$A,$P,$R);
d3500 1
a3500 3
See L</Input> for more info on accepted input formats.

=item from_oct()
d3502 1
a3502 1
    $x = Math::BigInt->from_oct("0775");      # input is octal
d3504 1
a3504 4
Interpret the input as an octal string and return the corresponding value. A
"0" (zero) prefix is optional. A single underscore character may be placed
right after the prefix, if present, or between any two digits. If the input is
invalid, a NaN is returned.
d3506 1
a3506 1
=item from_hex()
d3508 1
a3508 1
    $x = Math::BigInt->from_hex("0xcafe");    # input is hexadecimal
d3510 1
a3510 3
Interpret input as a hexadecimal string. A "0x" or "x" prefix is optional. A
single underscore character may be placed right after the prefix, if present,
or between any two digits. If the input is invalid, a NaN is returned.
d3512 1
a3512 1
=item from_bin()
d3514 1
a3514 1
    $x = Math::BigInt->from_bin("0b10011");   # input is binary
d3516 1
a3516 7
Interpret the input as a binary string. A "0b" or "b" prefix is optional. A
single underscore character may be placed right after the prefix, if present,
or between any two digits. If the input is invalid, a NaN is returned.

=item bnan()

    $x = Math::BigInt->bnan();
d3521 1
a3521 1
    $x->bnan();
d3523 1
a3523 1
=item bzero()
d3525 1
a3525 1
    $x = Math::BigInt->bzero();
d3530 1
a3530 1
    $x->bzero();
d3532 1
a3532 1
=item binf()
d3534 1
a3534 1
    $x = Math::BigInt->binf($sign);
d3540 2
a3541 2
    $x->binf();
    $x->binf('-');
d3543 1
a3543 1
=item bone()
d3545 1
a3545 1
    $x = Math::BigInt->binf($sign);
d3551 2
a3552 2
    $x->bone();         # +1
    $x->bone('-');              # -1
d3554 1
a3554 1
=item is_one()/is_zero()/is_nan()/is_inf()
d3556 7
a3562 6
    $x->is_zero();              # true if arg is +0
    $x->is_nan();               # true if arg is NaN
    $x->is_one();               # true if arg is +1
    $x->is_one('-');            # true if arg is -1
    $x->is_inf();               # true if +inf
    $x->is_inf('-');            # true if -inf (sign is default '+')
d3568 1
a3568 1
    if ($x == 0)
d3570 4
a3573 4
=item is_pos()/is_neg()/is_positive()/is_negative()

    $x->is_pos();                       # true if > 0
    $x->is_neg();                       # true if < 0
d3586 1
a3586 1
=item is_odd()/is_even()/is_int()
d3588 3
a3590 3
    $x->is_odd();               # true if odd, false for even
    $x->is_even();              # true if even, false for odd
    $x->is_int();               # true if $x is an integer
d3597 1
a3597 1
=item bcmp()
d3599 1
a3599 1
    $x->bcmp($y);
d3604 1
a3604 1
=item bacmp()
d3606 1
a3606 1
    $x->bacmp($y);
d3608 1
a3608 1
Compares $x with $y while ignoring their sign. Returns -1, 0, 1 or undef.
d3610 1
a3610 1
=item sign()
d3612 1
a3612 1
    $x->sign();
d3618 5
a3622 5
    $x->babs();                 # '+'
    $x->babs()->bneg();         # '-'
    $x->bnan();                 # 'NaN'
    $x->binf();                 # '+inf'
    $x->binf('-');              # '-inf'
d3624 1
a3624 1
=item digit()
d3626 1
a3626 1
    $x->digit($n);       # return the nth digit, counting from right
d3630 1
a3630 1
=item bneg()
d3632 1
a3632 1
    $x->bneg();
d3637 1
a3637 1
=item babs()
d3639 1
a3639 1
    $x->babs();
d3645 1
a3645 3
=item bsgn()

    $x->bsgn();
d3647 1
a3647 2
Signum function. Set the number to -1, 0, or 1, depending on whether the
number is negative, zero, or positive, respectively. Does not modify NaNs.
d3649 1
a3649 1
=item bnorm()
d3651 1
a3651 5
    $x->bnorm();                        # normalize (no-op)

=item bnot()

    $x->bnot();
d3655 1
a3655 1
    $x->binc()->bneg();
d3659 1
a3659 1
=item binc()
d3661 1
a3661 1
    $x->binc();                 # increment x by 1
d3663 1
a3663 1
=item bdec()
d3665 1
a3665 1
    $x->bdec();                 # decrement x by 1
d3667 1
a3667 1
=item badd()
d3669 1
a3669 1
    $x->badd($y);               # addition (add $y to $x)
d3671 1
a3671 1
=item bsub()
d3673 1
a3673 1
    $x->bsub($y);               # subtraction (subtract $y from $x)
d3675 1
a3675 1
=item bmul()
d3677 1
a3677 1
    $x->bmul($y);               # multiplication (multiply $x by $y)
d3679 1
a3679 1
=item bmuladd()
d3681 1
a3681 1
    $x->bmuladd($y,$z);
d3687 1
a3687 8
=item bdiv()

    $x->bdiv($y);               # divide, set $x to quotient

Returns $x divided by $y. In list context, does floored division (F-division),
where the quotient is the greatest integer less than or equal to the quotient
of the two operands. Consequently, the remainder is either zero or has the same
sign as the second operand. In scalar context, only the quotient is returned.
d3689 2
a3690 1
=item bmod()
d3692 1
a3692 1
    $x->bmod($y);               # modulus (x % y)
d3694 1
a3694 3
Returns $x modulo $y. When $x is finite, and $y is finite and non-zero, the
result is identical to the remainder after floored division (F-division), i.e.,
identical to the result from Perl's % operator.
d3696 1
a3696 1
=item bmodinv()
d3698 1
a3698 1
    $x->bmodinv($mod);          # modular multiplicative inverse
d3700 3
a3702 1
Returns the multiplicative inverse of C<$x> modulo C<$mod>. If
d3704 1
a3704 1
    $y = $x -> copy() -> bmodinv($mod)
d3706 2
a3707 13
then C<$y> is the number closest to zero, and with the same sign as C<$mod>,
satisfying

    ($x * $y) % $mod = 1 % $mod

If C<$x> and C<$y> are non-zero, they must be relative primes, i.e.,
C<bgcd($y, $mod)==1>. 'C<NaN>' is returned when no modular multiplicative
inverse exists.

=item bmodpow()

    $num->bmodpow($exp,$mod);           # modular exponentiation
                                        # ($num**$exp % $mod)
d3710 1
a3710 1
C<$mod> using binary exponentiation.  C<bmodpow> is far superior to
d3713 1
a3713 1
    $num ** $exp % $mod
d3720 1
a3720 1
    bmodpow($num, -1, $mod)
d3724 1
a3724 1
    bmodinv($num, $mod)
d3726 1
a3726 1
=item bpow()
d3728 1
a3728 1
    $x->bpow($y);                     # power of arguments (x ** y)
d3730 1
a3730 1
=item blog()
d3732 1
a3732 1
    $x->blog($base, $accuracy);   # logarithm of x to the base $base
d3736 1
a3736 1
    print $x->blog(undef, 100);       # log(x) to 100 digits
d3738 1
a3738 1
=item bexp()
d3740 1
a3740 1
    $x->bexp($accuracy);              # calculate e ** X
d3746 1
a3746 1
See also L</blog()>.
d3748 1
a3748 1
=item bnok()
d3750 1
a3750 1
    $x->bnok($y);         # x over y (binomial coefficient n over k)
d3755 3
a3757 3
        ( n )      n!
        | - |  = -------
        ( k )    k!(n-k)!
d3761 1
a3761 1
=item bpi()
d3763 1
a3763 1
    print Math::BigInt->bpi(100), "\n";         # 3
d3771 4
a3774 4
    use Math::BigFloat;
    use Math::BigInt upgrade => Math::BigFloat;
    print Math::BigInt->bpi(3), "\n";           # 3.14
    print Math::BigInt->bpi(100), "\n";         # 3.1415....
d3778 1
a3778 1
=item bcos()
d3780 2
a3781 2
    my $x = Math::BigInt->new(1);
    print $x->bcos(100), "\n";
d3790 1
a3790 1
=item bsin()
d3792 2
a3793 2
    my $x = Math::BigInt->new(1);
    print $x->bsin(100), "\n";
d3802 1
a3802 1
=item batan2()
d3804 3
a3806 3
    my $x = Math::BigInt->new(1);
    my $y = Math::BigInt->new(1);
    print $y->batan2($x), "\n";
d3815 1
a3815 1
=item batan()
d3817 2
a3818 2
    my $x = Math::BigFloat->new(0.5);
    print $x->batan(100), "\n";
d3827 1
a3827 1
=item blsft()
d3829 2
a3830 2
    $x->blsft($y);              # left shift in base 2
    $x->blsft($y,$n);           # left shift, in base $n (like 10)
d3832 1
a3832 1
=item brsft()
d3834 2
a3835 2
    $x->brsft($y);              # right shift in base 2
    $x->brsft($y,$n);           # right shift, in base $n (like 10)
d3837 1
a3837 1
=item band()
d3839 1
a3839 1
    $x->band($y);               # bitwise and
d3841 1
a3841 1
=item bior()
d3843 1
a3843 1
    $x->bior($y);               # bitwise inclusive or
d3845 1
a3845 1
=item bxor()
d3847 1
a3847 1
    $x->bxor($y);               # bitwise exclusive or
d3849 1
a3849 1
=item bnot()
d3851 1
a3851 1
    $x->bnot();                 # bitwise not (two's complement)
d3853 1
a3853 1
=item bsqrt()
d3855 1
a3855 1
    $x->bsqrt();                # calculate square-root
d3857 1
a3857 1
=item broot()
d3859 1
a3859 1
    $x->broot($N);
d3863 1
a3863 1
=item bfac()
d3865 1
a3865 1
    $x->bfac();                 # factorial of $x (1*2*3*4*..$x)
d3867 1
a3867 3
=item round()

    $x->round($A,$P,$round_mode);
d3869 2
d3874 1
a3874 1
=item bround()
d3876 1
a3876 1
    $x->bround($N);               # accuracy: preserve $N digits
d3878 1
a3878 1
=item bfround()
d3880 1
a3880 1
    $x->bfround($N);
d3888 6
a3893 14
        Input           N               Result
        ===================================================
        123456.123456   3               123500
        123456.123456   2               123450
        123456.123456   -2              123456.12
        123456.123456   -3              123456.123

=item bfloor()

    $x->bfloor();

Round $x towards minus infinity (i.e., set $x to the largest integer less than
or equal to $x). This is a no-op in BigInt, but changes $x in BigFloat, if $x
is not an integer.
d3895 1
a3895 1
=item bceil()
d3897 1
a3897 1
    $x->bceil();
d3899 2
a3900 3
Round $x towards plus infinity (i.e., set $x to the smallest integer greater
than or equal to $x). This is a no-op in BigInt, but changes $x in BigFloat, if
$x is not an integer.
d3902 1
a3902 1
=item bint()
d3904 1
a3904 1
    $x->bint();
d3906 2
a3907 2
Round $x towards zero. This is a no-op in BigInt, but changes $x in BigFloat,
if $x is not an integer.
d3909 1
a3909 1
=item bgcd()
d3911 1
a3911 1
    bgcd(@@values);           # greatest common divisor (no OO style)
d3913 1
a3913 1
=item blcm()
d3915 3
a3917 1
    blcm(@@values);           # lowest common multiple (no OO style)
d3919 2
a3920 4
=item length()

    $x->length();
    ($xl,$fl) = $x->length();
d3926 1
a3926 1
=item exponent()
d3928 1
a3928 1
    $x->exponent();
d3932 1
a3932 1
=item mantissa()
d3934 1
a3934 1
    $x->mantissa();
d3938 1
a3938 7
=item parts()

    $x->parts();        # return (mantissa,exponent) as BigInt

=item copy()

    $x->copy();         # make a true copy of $x (unlike $y = $x;)
d3940 1
a3940 1
=item as_int()
d3942 1
a3942 1
=item as_number()
d3944 1
a3944 3
These methods are called when Math::BigInt encounters an object it doesn't know
how to handle. For instance, assume $x is a Math::BigInt, or subclass thereof,
and $y is defined, but not a Math::BigInt, or subclass thereof. If you do
d3946 1
a3946 1
    $x -> badd($y);
d3948 1
a3948 8
$y needs to be converted into an object that $x can deal with. This is done by
first checking if $y is something that $x might be upgraded to. If that is the
case, no further attempts are made. The next is to see if $y supports the
method C<as_int()>. If it does, C<as_int()> is called, but if it doesn't, the
next thing is to see if $y supports the method C<as_number()>. If it does,
C<as_number()> is called. The method C<as_int()> (and C<as_number()>) is
expected to return either an object that has the same class as $x, a subclass
thereof, or a string that C<ref($x)-E<gt>new()> can parse to create an object.
d3950 2
a3951 2
C<as_number()> is an alias to C<as_int()>. C<as_number> was introduced in
v1.22, while C<as_int()> was introduced in v1.68.
d3953 4
a3956 1
In Math::BigInt, C<as_int()> has the same effect as C<copy()>.
d3958 1
a3958 3
=item bstr()

    $x->bstr();
d3962 1
a3962 1
=item bsstr()
d3964 1
a3964 1
    $x->bsstr();     # normalized string in scientific notation
d3966 1
a3966 1
=item as_hex()
d3968 1
a3968 1
    $x->as_hex();    # as signed hexadecimal string with prefixed 0x
d3970 1
a3970 1
=item as_bin()
d3972 1
a3972 1
    $x->as_bin();    # as signed binary string with prefixed 0b
d3974 1
a3974 1
=item as_oct()
d3976 1
a3976 1
    $x->as_oct();    # as signed octal string with prefixed 0
d3978 1
a3978 1
=item numify()
d3980 1
a3980 1
        print $x->numify();
d3985 1
a3985 1
This loses precision, to avoid this use L</as_int()> instead.
d3987 1
a3987 1
=item modify()
d3989 1
a3989 1
    $x->modify('bpowd');
d3992 1
a3992 1
operation, or 1 if not.
d3996 1
a3996 1
=item upgrade()/downgrade()
d4002 2
a4003 2
        my $i = Math::BigInt->new(123);
        my $f = Math::BigFloat->new('123.1');
d4005 1
a4005 1
        print $i + $f,"\n";                     # print 246
d4007 1
a4007 1
=item div_scale()
d4012 1
a4012 1
=item round_mode()
a4015 2
=back

d4042 1
a4042 1
because 1200 can have p = 0, 1 or 2 (depending on what the initial value
d4047 10
a4056 10

        Initial value   P       A       Result          String
        ------------------------------------------------------------
        1234.01         -3              1000            1000
        1234            -2              1200            1200
        1234.5          -1              1230            1230
        1234.001        1               1234            1234.0
        1234.01         0               1234            1234
        1234.01         2               1234.01         1234.01
        1234.01         5               1234.01         1234.01000
d4069 5
a4073 5
        Initial value   P       A       Result          String
        ------------------------------------------------------------
        1234.01                 3       1230            1230
        1234.01                 6       1234.01         1234.01
        1234.1                  8       1234.1          1234.1000
d4088 1
a4088 1
=over
d4153 1
a4153 1
=over
d4157 1
a4157 1
  * bfround($p) is able to round to $p number of digits after the decimal
d4163 10
a4172 11
  * bround($a) rounds to $a significant digits
  * only bdiv() and bsqrt() take A as (optional) parameter
    + other operations simply create the same number (bneg etc), or
      more (bmul) of digits
    + rounding/truncating is only done when explicitly calling one
      of bround or bfround, and never for BigInt (not implemented)
  * bsqrt() simply hands its accuracy argument over to bdiv.
  * the documentation and the comment in the code indicate two
    different ways on how bdiv() determines the maximum number
    of digits it should calculate, and the actual code does yet
    another thing
d4180 10
a4189 12
    So for lx = 3, ly = 9, scale = 10, scale will actually be 16 (10
    So for lx = 3, ly = 9, scale = 10, scale will actually be 16
    (10+9-3). Actually, the 'difference' added to the scale is cal-
    culated from the number of "significant digits" in dividend and
    divisor, which is derived by looking at the length of the man-
    tissa. Which is wrong, since it includes the + sign (oops) and
    actually gets 2 for '+100' and 4 for '+101'. Oops again. Thus
    124/3 with div_scale=1 will get you '41.3' based on the strange
    assumption that 124 has 3 significant digits, while 120/7 will
    get you '17', not '17.1' since 120 is thought to have 2 signif-
    icant digits. The rounding after the division then uses the
    remainder and $y to determine whether it must round up or down.
d4197 1
a4197 1
=over
d4201 3
a4203 3
  * You can set the A global via Math::BigInt->accuracy() or
    Math::BigFloat->accuracy() or whatever class you are using.
  * You can also set P globally by using Math::SomeClass->precision()
d4206 4
a4209 4
  * to undefine A, use Math::SomeCLass->accuracy(undef);
  * to undefine P, use Math::SomeClass->precision(undef);
  * Setting Math::SomeClass->accuracy() clears automatically
    Math::SomeClass->precision(), and vice versa.
d4214 6
a4219 6
  * to find out the current global A, use Math::SomeClass->accuracy()
  * to find out the current global P, use Math::SomeClass->precision()
  * use $x->accuracy() respective $x->precision() for the local
    setting of $x.
  * Please note that $x->accuracy() respective $x->precision()
    return eventually defined global A or P, when $x's A or P is not
d4231 2
a4232 2
  * If given undef for A and P, NO rounding will occur, and the globals will
    NOT be used. This is used by subclasses to create numbers without
d4235 1
a4235 1
    $x = Math::BigInt->new($number,undef,undef):
d4237 2
a4238 2
        use Math::BigInt::SomeSubclass;
        use Math::BigInt;
d4240 3
a4242 3
        Math::BigInt->accuracy(2);
        Math::BigInt::SomeSubClass->accuracy(3);
        $x = Math::BigInt::SomeSubClass->new(1234);
d4266 1
a4266 1
    as many digits as it can (with an exception for bdiv/bsqrt) and will not
d4268 2
a4269 2
  * There is another setting for bdiv() (and thus for bsqrt()). If neither of
    A or P is defined, bdiv() will use a fallback (F) of $div_scale digits.
d4274 1
a4274 1
  * bdiv will calculate (at least) 4 more digits than required (determined by
d4281 1
a4281 1
      will round the result, with bdiv() and bsqrt() as exceptions to guard
d4292 1
a4292 1
        print $x->copy()->bround(3);            # 12.3 (but A is now 3!)
d4304 1
a4304 1
 ?so that intermediate rounding does not 'poison' further math?
d4322 1
a4322 1
  * bsqrt() will hand its arguments to bdiv(), as it used to, only now for two
d4327 2
a4328 2
  * You can set A or P locally by using $x->accuracy() or
    $x->precision()
d4331 1
a4331 1
  * $x->accuracy() clears $x->precision(), and vice versa.
d4336 2
a4337 1
    bround() is for accuracy rounding, while bfround() is for precision
d4341 3
a4343 3
  * you can set/get the global R by using Math::SomeClass->round_mode()
    or by setting $Math::SomeClass::round_mode
  * after each operation, $result->round() is called, and the result may
d4346 1
a4346 1
  * to manually round a number, call $x->round($A,$P,$round_mode);
d4368 1
a4368 1
    the old code (except in a few cases on bdiv):
d4379 1
a4379 1
=over
d4386 9
a4394 9
        te@@linux:~> perl -wle 'print 2 ** 3333'
        Inf
        te@@linux:~> perl -wle 'print 2 ** 3333 == 2 ** 3333'
        1
        te@@linux:~> perl -wle 'print oct(2 ** 3333)'
        0
        te@@linux:~> perl -wle 'print hex(2 ** 3333)'
        Illegal hexadecimal digit 'I' ignored at -e line 1.
        0
d4417 1
a4417 1

d4422 1
a4422 1
The actual numbers are stored as unsigned big integers (with separate sign).
d4433 1
a4433 1
        use Math::BigInt try => 'Calc';
d4437 1
a4437 1
        use Math::BigInt try => 'GMP';
d4446 1
a4446 1
        use Math::BigInt only => 'GMP,Pari';
d4451 1
a4451 1
        use Math::BigInt try => 'Foo,Math::BigInt::Bar';
d4469 1
a4469 1
So please select carefully what library you want to use.
d4509 1
a4509 1

d4512 1
a4512 1
  sub bigint { Math::BigInt->new(shift); }
d4514 15
a4528 15
  $x = Math::BigInt->bstr("1234")       # string "1234"
  $x = "$x";                            # same as bstr()
  $x = Math::BigInt->bneg("1234");      # BigInt "-1234"
  $x = Math::BigInt->babs("-12345");    # BigInt "12345"
  $x = Math::BigInt->bnorm("-0.00");    # BigInt "0"
  $x = bigint(1) + bigint(2);           # BigInt "3"
  $x = bigint(1) + "2";                 # ditto (auto-BigIntify of "2")
  $x = bigint(1);                       # BigInt "1"
  $x = $x + 5 / 2;                      # BigInt "3"
  $x = $x ** 3;                         # BigInt "27"
  $x *= 2;                              # BigInt "54"
  $x = Math::BigInt->new(0);            # BigInt "0"
  $x--;                                 # BigInt "-1"
  $x = Math::BigInt->badd(4,5)          # BigInt "9"
  print $x->bsstr();                    # 9e+0
d4533 1
a4533 1
  use Test::More;
d4537 1
a4537 1
  Math::BigFloat->accuracy(4);          # no more A than 4
d4539 14
a4552 14
  is ($x->copy()->bround(),123.4);      # even rounding
  print $x->copy()->bround(),"\n";      # 123.4
  Math::BigFloat->round_mode('odd');    # round to odd
  print $x->copy()->bround(),"\n";      # 123.5
  Math::BigFloat->accuracy(5);          # no more A than 5
  Math::BigFloat->round_mode('odd');    # round to odd
  print $x->copy()->bround(),"\n";      # 123.46
  $y = $x->copy()->bround(4),"\n";      # A = 4: 123.4
  print "$y, ",$y->accuracy(),"\n";     # 123.4, 4

  Math::BigFloat->accuracy(undef);      # A not important now
  Math::BigFloat->precision(2);         # P important
  print $x->copy()->bnorm(),"\n";       # 123.46
  print $x->copy()->bround(),"\n";      # 123.46
d4563 1
a4563 1
This conversion happens at compile time.
d4569 1
a4569 1
prints the integer value of C<2**100>. Note that without conversion of
d4575 1
a4575 1
        use Math::BigInt qw/:constant/;
d4577 4
a4580 4
        $x = 1234567890123456789012345678901234567890
                + 123456789123456789;
        $y = '1234567890123456789012345678901234567890'
                + '123456789123456789';
d4585 1
a4585 1
        use Math::BigInt;
d4587 1
a4587 1
        $x = Math::BigInt->new('1234567889123456789123456789123456789');
d4595 1
a4595 1
        use Math::BigInt ':constant';
d4597 2
a4598 2
        print ref(123e2),"\n";
        print ref(123.2e2),"\n";
d4630 1
a4630 1
modules and see if they help you.
d4635 1
a4635 1
L</MATH LIBRARY> for more information.
d4639 1
a4639 1
=head1 SUBCLASSING
d4641 1
a4641 1
=head2 Subclassing Math::BigInt
d4646 1
a4646 1
=over
d4657 2
a4658 2
The private object hash keys like C<< $x->{sign} >> may not be changed, but
additional keys can be added, like C<< $x->{_custom} >>.
d4671 1
a4671 1
needs to merely change the output only needs to overload C<bstr()>.
d4692 1
a4692 1
This allows Math::BigInt to correctly retrieve package globals from the
d4696 1
a4696 1
Don't forget to
d4698 1
a4698 1
        use overload;
d4708 1
a4708 1
        use Math::BigInt upgrade => 'Foo::Bar';
d4713 1
a4713 1
        use Math::BigInt upgrade => 'Math::BigFloat';
d4715 1
a4715 1
As a shortcut, you can use the module L<bignum>:
d4717 1
a4717 1
        use bignum;
d4719 1
a4719 1
Also good for one-liners:
d4721 1
a4721 1
        perl -Mbignum -le 'print 2 ** 255'
d4733 1
a4733 1
=over
d4743 1
a4743 3
=item bpi()

=item bcos()
d4745 1
a4745 7
=item bsin()

=item batan2()

=item batan()

=back
d4748 2
a4749 1
arguments are of the class mentioned in $upgrade.
d4755 2
a4756 2
        bgcd
        blcm
d4763 1
a4763 1
=over
d4770 2
a4771 2
overloading) to work as you expect. It also solves problems with C<Test.pm>
and L<Test::More>, which stringify arguments before comparing them.
d4776 4
a4779 4
        I agree (with the first alternative), don't add the '+' on positive
        numbers.  It's not as important anymore with the new internal
        form for numbers.  It made doing things like abs and neg easier,
        but those have to be done differently now anyway.
d4783 11
a4793 10
        use Test::More tests => 1;
        use Math::BigInt;

        my $x = Math::BigInt -> new(3*3);
        my $y = Math::BigInt -> new(3*3);

        is ($x,3*3, 'multiplication');
        print "$x eq 9" if $x eq $y;
        print "$x eq 9" if $x eq '9';
        print "$x eq 9" if $x eq 3*3;
d4796 4
a4799 4

        print "$x == 9" if $x == $y;
        print "$x == 9" if $x == 9;
        print "$x == 9" if $x == 3*3;
d4804 1
a4804 1
as 1e+308. If in doubt, convert both arguments to Math::BigInt before
d4807 9
a4815 8
        use Test::More tests => 3;
        use Math::BigInt;

        $x = Math::BigInt->new('1e56'); $y = 1e56;
        is ($x,$y);                     # will fail
        is ($x->bsstr(),$y);            # okay
        $y = Math::BigInt->new($y);
        is ($x,$y);                     # okay
d4817 1
a4817 1
Alternatively, simply use C<< <=> >> for comparisons, this will get it
d4826 1
a4826 1
C<int()> will return (at least for Perl v5.7.1 and up) another BigInt, not a
d4829 4
a4832 4
        $x = Math::BigInt->new(123);
        $y = int($x);                           # BigInt 123
        $x = Math::BigFloat->new(123.45);
        $y = int($x);                           # BigInt 123
d4837 3
a4839 3
        $x = Math::BigFloat->new(123.45);
        $y = $x->as_number();                   # BigInt 123
        $y = $x->as_int();                      # ditto
d4845 1
a4845 1
        $y = $x->numify();                      # 123 as scalar
d4850 1
a4850 1
        $z = $array[$x];                        # does work automatically
d4852 1
a4852 1
=item length()
d4856 2
a4857 2
        $c = Math::BigInt->new(123);
        print $c->length(),"\n";                # prints 30
d4860 3
a4862 1
since print calls C<length()> in list context. Use something like:
d4864 1
a4864 3
        print scalar $c->length(),"\n";         # prints 3

=item bdiv()
d4868 1
a4868 1
        print $c->bdiv(10000),"\n";
d4873 3
d4877 1
a4877 5
        print $c / 10000,"\n";

or, if you want to  modify $c instead,

        print scalar $c->bdiv(10000),"\n";
d4881 1
a4881 1
non-zero) always has the same sign as the second operand; so, for
d4884 6
a4889 6
          1 / 4  => ( 0, 1)
          1 / -4 => (-1,-3)
         -3 / 4  => (-1, 1)
         -3 / -4 => ( 0,-3)
        -11 / 2  => (-5,1)
         11 /-2  => (-5,-1)
d4895 1
a4895 1
        $x == ($x / $y) * $y + ($x % $y)
d4917 1
a4917 1
        A /  B  =   C,     R so that C *    B +    R =    A
d4919 9
a4927 9
        5 /   8 =   0,     5         0 *    8 +    5 =    5
        0 /   8 =   0,     0         0 *    8 +    0 =    0
        0 / inf =   0,     0         0 *  inf +    0 =    0
        0 /-inf =   0,     0         0 * -inf +    0 =    0
        5 / inf =   0,     5         0 *  inf +    5 =    5
        5 /-inf =   0,     5         0 * -inf +    5 =    5
        -5/ inf =   0,    -5         0 *  inf +   -5 =   -5
        -5/-inf =   0,    -5         0 * -inf +   -5 =   -5
       inf/   5 =  inf,    0       inf *    5 +    0 =  inf
d4929 1
a4929 1
       inf/  -5 = -inf,    0      -inf *   -5 +    0 =  inf
d4931 2
a4932 2
         5/   5 =    1,    0         1 *    5 +    0 =    5
        -5/  -5 =    1,    0         1 *   -5 +    0 =   -5
d4937 2
a4938 2
         8/   0 =  inf,    8       inf *    0 +    8 =    8
       inf/   0 =  inf,  inf       inf *    0 +  inf =  inf
d4944 1
a4944 1
        A /  B  =   C,     R so that C *    B +    R =    A
d4946 2
a4947 2
      -inf/   0 = -inf, -inf      -inf *    0 +  inf = -inf
        -8/   0 = -inf,   -8      -inf *    0 +    8 = -8
d4983 4
a4986 4
        print bpow($x,$i),"\n";         # modify $x
        print $x->bpow($i),"\n";        # ditto
        print $x **= $i,"\n";           # the same
        print $x ** $i,"\n";            # leave $x alone
d4994 1
a4994 1
        $x = -$x;
d4998 1
a4998 1
        $x->bneg();
d5006 1
a5006 21
With overloaded operators, it is the first (dominating) operand that determines
which method is called. Here are some examples showing what actually gets
called in various cases.

        use Math::BigInt;
        use Math::BigFloat;

        $mbf  = Math::BigFloat->new(5);
        $mbi2 = Math::BigInt->new(5);
        $mbi  = Math::BigInt->new(2);
                                        # what actually gets called:
        $float = $mbf + $mbi;           # $mbf->badd($mbi)
        $float = $mbf / $mbi;           # $mbf->bdiv($mbi)
        $integer = $mbi + $mbf;         # $mbi->badd($mbf)
        $integer = $mbi2 / $mbi;        # $mbi2->bdiv($mbi)
        $integer = $mbi2 / $mbf;        # $mbi2->bdiv($mbf)

For instance, Math::BigInt->bdiv() will always return a Math::BigInt, regardless of
whether the second operant is a Math::BigFloat. To get a Math::BigFloat you
either need to call the operation manually, make sure each operand already is a
Math::BigFloat, or cast to that type via Math::BigFloat->new():
d5008 30
a5037 1
        $float = Math::BigFloat->new($mbi2) / $mbi;     # = 2.5
d5039 2
a5040 2
Beware of casting the entire expression, as this would cast the
result, at which point it is too late:
d5042 1
a5042 1
        $float = Math::BigFloat->new($mbi2 / $mbi);     # = 2
d5046 2
a5047 2
        $integer = ($mbi2 + $mbi) / $mbf;               # int / float => int
        $integer = $mbi2 / Math::BigFloat->new($mbi);   # ditto
d5053 3
a5055 3

        $float = 2 + $mbf;
        $float = $mbf + 2;
d5072 8
a5079 8
        $x = Math::BigFloat->new(12);
        Math::BigFloat->precision(0);
        Math::BigFloat->round_mode('even');
        print $x->copy->bsqrt(),"\n";           # 4

        Math::BigFloat->precision(2);
        print $x->bsqrt(),"\n";                 # 3.46
        print $x->bsqrt(3),"\n";                # 3.464
d5083 1
a5083 60
For negative numbers in base see also L<brsft|/brsft()>.

=back

=head1 BUGS

Please report any bugs or feature requests to
C<bug-math-bigint at rt.cpan.org>, or through the web interface at
L<https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt>
(requires login).
We will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Math::BigInt

You can also look for information at:

=over 4

=item * RT: CPAN's request tracker

L<https://rt.cpan.org/Public/Dist/Display.html?Name=Math-BigInt>

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Math-BigInt>

=item * CPAN Ratings

L<http://cpanratings.perl.org/dist/Math-BigInt>

=item * Search CPAN

L<http://search.cpan.org/dist/Math-BigInt/>

=item * CPAN Testers Matrix

L<http://matrix.cpantesters.org/?dist=Math-BigInt>

=item * The Bignum mailing list

=over 4

=item * Post to mailing list

C<bignum at lists.scsys.co.uk>

=item * View mailing list

L<http://lists.scsys.co.uk/pipermail/bignum/>

=item * Subscribe/Unsubscribe

L<http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/bignum>

=back
d5094 2
a5095 2
L<Math::BigFloat> and L<Math::BigRat> as well as the backends
L<Math::BigInt::FastCalc>, L<Math::BigInt::GMP>, and L<Math::BigInt::Pari>.
d5100 5
d5107 3
a5109 19
=over 4

=item *

Mark Biggar, overloaded interface by Ilya Zakharevich, 1996-2001.

=item *

Completely rewritten by Tels L<http://bloodgate.com>, 2001-2008.

=item *

Florian Ragwitz E<lt>flora@@cpan.orgE<gt>, 2010.

=item *

Peter John Acklam E<lt>pjacklam@@online.noE<gt>, 2011-.

=back
@

