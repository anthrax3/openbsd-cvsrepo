head	1.3;
access;
symbols
	PERL_5_24_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.32.01;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2013.03.25.20.40.51;	author sthen;	state dead;
branches;
next	1.1;

1.1
date	2010.09.24.14.49.00;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.00;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2017.08.14.13.45.59;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!/usr/bin/perl

# test rounding, accuracy, precision and fallback, round_mode and mixing
# of classes

use strict;
use warnings;

use Test::More tests => 684             # tests in require'd file
                        + 26;           # tests in this file

use Math::BigInt lib => 'Calc';
use Math::BigFloat;

our $mbi = 'Math::BigInt';
our $mbf = 'Math::BigFloat';

require 't/mbimbf.inc';

# some tests that won't work with subclasses, since the things are only
# guaranteed in the Math::Big(Int|Float) (unless subclass chooses to support
# this)

Math::BigInt->round_mode("even");	# reset for tests
Math::BigFloat->round_mode("even");	# reset for tests

is($Math::BigInt::rnd_mode,   "even", '$Math::BigInt::rnd_mode = "even"');
is($Math::BigFloat::rnd_mode, "even", '$Math::BigFloat::rnd_mode = "even"');

my $x = eval '$mbi->round_mode("huhmbi");';
like($@@, qr/^Unknown round mode 'huhmbi' at/,
     '$mbi->round_mode("huhmbi")');

$x = eval '$mbf->round_mode("huhmbf");';
like($@@, qr/^Unknown round mode 'huhmbf' at/,
     '$mbf->round_mode("huhmbf")');

# old way (now with test for validity)
$x = eval '$Math::BigInt::rnd_mode = "huhmbi";';
like($@@, qr/^Unknown round mode 'huhmbi' at/,
     '$Math::BigInt::rnd_mode = "huhmbi"');
$x = eval '$Math::BigFloat::rnd_mode = "huhmbf";';
like($@@, qr/^Unknown round mode 'huhmbf' at/,
     '$Math::BigFloat::rnd_mode = "huhmbf"');

# see if accessor also changes old variable
$mbi->round_mode('odd');
is($Math::BigInt::rnd_mode, 'odd', '$Math::BigInt::rnd_mode = "odd"');

$mbf->round_mode('odd');
is($Math::BigInt::rnd_mode, 'odd', '$Math::BigInt::rnd_mode = "odd"');

foreach my $class (qw/Math::BigInt Math::BigFloat/) {
    is($class->accuracy(5),  5,     "set A ...");
    is($class->precision(),  undef, "... and now P must be cleared");
    is($class->precision(5), 5,     "set P ...");
    is($class->accuracy(),   undef, "... and now A must be cleared");
}

foreach my $class (qw/Math::BigInt Math::BigFloat/)  {
    $class->accuracy(42);

    # $x gets A of 42, too!
    my $x = $class->new(123);

    # really?
    is($x->accuracy(), 42, '$x has A of 42');

    # $x has no A, but the global is still in effect for $x so the return value
    # of that operation should be 42, not undef
    is($x->accuracy(undef), 42, '$x has A from global');

    # so $x should still have A = 42
    is($x->accuracy(), 42, '$x has still A of 42');

    # reset for further tests
    $class->accuracy(undef);
    $class->precision(undef);
}

# bug with blog(Math::BigFloat, Math::BigInt)
$x = Math::BigFloat->new(100);
$x = $x->blog(Math::BigInt->new(10));

is($x, 2, 'bug with blog(Math::BigFloat, Math::BigInt)');

# bug until v1.88 for sqrt() with enough digits
for my $i (80, 88, 100) {
    $x = Math::BigFloat->new("1." . ("0" x $i) . "1");
    $x = $x->bsqrt;
    is($x, 1, '$x->bsqrt() with many digits');
}
@


1.2
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d1 1
a1 1
#!/usr/bin/perl -w
d3 1
a3 1
# test rounding, accuracy, precicion and fallback, round_mode and mixing
d7 1
a7 1
use Test;
d9 2
a10 31
BEGIN
  {
  $| = 1;
  # to locate the testing files
  my $location = $0; $location =~ s/mbimbf.t//i;
  if ($ENV{PERL_CORE})
    {
    @@INC = qw(../lib); 		# testing with the core distribution
    }
  else
    {
    unshift @@INC, '../lib';	# for testing manually
    }
  if (-d 't')
    {
    chdir 't';
    require File::Spec;
    unshift @@INC, File::Spec->catdir(File::Spec->updir, $location);
    }
  else
    {
    unshift @@INC, $location;
    }
  print "# INC = @@INC\n";

  plan tests => 684 
    + 26;		# own tests
  }

use Math::BigInt 1.70;
use Math::BigFloat 1.43;
d12 2
a13 1
use vars qw/$mbi $mbf/;
d15 2
a16 2
$mbi = 'Math::BigInt';
$mbf = 'Math::BigFloat';
d18 1
a18 1
require 'mbimbf.inc';
d21 1
a21 1
# garantied in the Math::BigInt/BigFloat (unless subclass chooses to support
d24 2
a25 2
Math::BigInt->round_mode('even');	# reset for tests
Math::BigFloat->round_mode('even');	# reset for tests
d27 2
a28 2
ok ($Math::BigInt::rnd_mode,'even');
ok ($Math::BigFloat::rnd_mode,'even');
d31 2
a32 2
print "# Got '$@@'\n" unless
 ok ($@@ =~ /^Unknown round mode 'huhmbi' at/);
d35 2
a36 2
print "# Got '$@@'\n" unless
 ok ($@@ =~ /^Unknown round mode 'huhmbf' at/);
d40 2
a41 2
print "# Got '$@@'\n" unless
 ok ($@@ =~ /^Unknown round mode 'huhmbi' at/);
d43 3
a45 2
print "# Got '$@@'\n" unless
 ok ($@@ =~ /^Unknown round mode 'huhmbf' at/);
d47 33
a79 2
$mbi->round_mode('odd'); ok ($Math::BigInt::rnd_mode,'odd');
$mbf->round_mode('odd'); ok ($Math::BigInt::rnd_mode,'odd');
d81 1
a81 22
foreach my $class (qw/Math::BigInt Math::BigFloat/)
  {
  ok ($class->accuracy(5),5);		# set A
  ok_undef ($class->precision());	# and now P must be cleared
  ok ($class->precision(5),5);		# set P
  ok_undef ($class->accuracy());	# and now A must be cleared
  }

foreach my $class (qw/Math::BigInt Math::BigFloat/)
  {
  $class->accuracy(42);
  my $x = $class->new(123);	# $x gets A of 42, too!
  ok ($x->accuracy(),42);	# really?
  ok ($x->accuracy(undef),42);	# $x has no A, but the
				# global is still in effect for $x
				# so the return value of that operation should
				# be 42, not undef
  ok ($x->accuracy(),42);	# so $x should still have A = 42
  $class->accuracy(undef);	# reset for further tests
  $class->precision(undef);
  }
# bug with flog(Math::BigFloat,Math::BigInt)
d85 1
a85 1
ok ($x,2);
d88 5
a92 6
for my $i (80,88,100)
  {
  $x = Math::BigFloat->new("1." . ("0" x $i) . "1");
  $x = $x->bsqrt;
  ok ($x, 1);
  }
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@Import perl-5.24.2
@
text
@d1 1
a1 1
#!/usr/bin/perl
d3 1
a3 1
# test rounding, accuracy, precision and fallback, round_mode and mixing
d7 1
a7 1
use warnings;
d9 31
a39 2
use Test::More tests => 684             # tests in require'd file
                        + 26;           # tests in this file
d41 1
a41 2
use Math::BigInt lib => 'Calc';
use Math::BigFloat;
d43 2
a44 2
our $mbi = 'Math::BigInt';
our $mbf = 'Math::BigFloat';
d46 1
a46 1
require 't/mbimbf.inc';
d49 1
a49 1
# guaranteed in the Math::Big(Int|Float) (unless subclass chooses to support
d52 2
a53 2
Math::BigInt->round_mode("even");	# reset for tests
Math::BigFloat->round_mode("even");	# reset for tests
d55 2
a56 2
is($Math::BigInt::rnd_mode,   "even", '$Math::BigInt::rnd_mode = "even"');
is($Math::BigFloat::rnd_mode, "even", '$Math::BigFloat::rnd_mode = "even"');
d59 2
a60 2
like($@@, qr/^Unknown round mode 'huhmbi' at/,
     '$mbi->round_mode("huhmbi")');
d63 2
a64 2
like($@@, qr/^Unknown round mode 'huhmbf' at/,
     '$mbf->round_mode("huhmbf")');
d68 2
a69 2
like($@@, qr/^Unknown round mode 'huhmbi' at/,
     '$Math::BigInt::rnd_mode = "huhmbi"');
d71 2
a72 3
like($@@, qr/^Unknown round mode 'huhmbf' at/,
     '$Math::BigFloat::rnd_mode = "huhmbf"');

d74 2
a75 33
$mbi->round_mode('odd');
is($Math::BigInt::rnd_mode, 'odd', '$Math::BigInt::rnd_mode = "odd"');

$mbf->round_mode('odd');
is($Math::BigInt::rnd_mode, 'odd', '$Math::BigInt::rnd_mode = "odd"');

foreach my $class (qw/Math::BigInt Math::BigFloat/) {
    is($class->accuracy(5),  5,     "set A ...");
    is($class->precision(),  undef, "... and now P must be cleared");
    is($class->precision(5), 5,     "set P ...");
    is($class->accuracy(),   undef, "... and now A must be cleared");
}

foreach my $class (qw/Math::BigInt Math::BigFloat/)  {
    $class->accuracy(42);

    # $x gets A of 42, too!
    my $x = $class->new(123);

    # really?
    is($x->accuracy(), 42, '$x has A of 42');

    # $x has no A, but the global is still in effect for $x so the return value
    # of that operation should be 42, not undef
    is($x->accuracy(undef), 42, '$x has A from global');

    # so $x should still have A = 42
    is($x->accuracy(), 42, '$x has still A of 42');

    # reset for further tests
    $class->accuracy(undef);
    $class->precision(undef);
}
d77 22
a98 1
# bug with blog(Math::BigFloat, Math::BigInt)
d102 1
a102 1
is($x, 2, 'bug with blog(Math::BigFloat, Math::BigInt)');
d105 6
a110 5
for my $i (80, 88, 100) {
    $x = Math::BigFloat->new("1." . ("0" x $i) . "1");
    $x = $x->bsqrt;
    is($x, 1, '$x->bsqrt() with many digits');
}
@

