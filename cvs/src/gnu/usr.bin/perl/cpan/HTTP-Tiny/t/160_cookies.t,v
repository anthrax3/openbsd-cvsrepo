head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.2
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.1.0.10
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.4
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.6
	OPENBSD_5_8_BASE:1.1.1.1
	PERL_5_20_2:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.2
	OPENBSD_5_7_BASE:1.1.1.1
	PERL_5_20_1:1.1.1.1
	PERL:1.1.1;
locks; strict;
comment	@# @;
expand	@b@;


1.2
date	2017.02.05.00.31.59;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2014.11.17.20.52.47;	author afresh1;	state Exp;
branches
	1.1.1.1;
next	;
commitid	B31cAbBIXiCqnL97;

1.1.1.1
date	2014.11.17.20.52.47;	author afresh1;	state Exp;
branches;
next	1.1.1.2;
commitid	B31cAbBIXiCqnL97;

1.1.1.2
date	2017.08.14.13.45.38;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!perl

use strict;
use warnings;

use File::Basename;
use Test::More 0.96;
use t::Util qw[tmpfile rewind slurp monkey_patch dir_list parse_case
  hashify connect_args clear_socket_source set_socket_source sort_headers
  $CRLF $LF];

use HTTP::Tiny;
BEGIN { monkey_patch() }

SKIP: for my $class ( qw/t::SimpleCookieJar HTTP::CookieJar/ ) {

    subtest $class => sub {
        eval "require $class; 1"
            or plan skip_all => "Needs $class";

        for my $file ( dir_list("corpus", qr/^cookies/ ) ) {
            my $label = basename($file);
            my $data = do { local (@@ARGV,$/) = $file; <> };
            my @@cases = split /--+\n/, $data;

            my $jar = t::SimpleCookieJar->new();
            my $http = undef;
            while (@@cases) {
                my ($params, $expect_req, $give_res) = splice( @@cases, 0, 3 );

                my $case = parse_case($params);

                my $url = $case->{url}[0];
                my $method = $case->{method}[0] || 'GET';
                my %headers = hashify( $case->{headers} );
                my %new_args = hashify( $case->{new_args} );

                if( exists $headers{Cookie} ) {
                my $cookies = delete $headers{Cookie};
                $jar->add( $url, $cookies );
                }

                if( exists $headers{'No-Cookie-Jar'} ) {
                delete $headers{'No-Cookie-Jar'};
                $jar = undef;
                }

                my %options;
                $options{headers} = \%headers if %headers;

                my $version = HTTP::Tiny->VERSION || 0;
                my $agent = $new_args{agent} || "HTTP-Tiny/$version";

                $new_args{cookie_jar} = $jar;

                # cleanup source data
                $expect_req =~ s{HTTP-Tiny/VERSION}{$agent};
                s{\n}{$CRLF}g for ($expect_req, $give_res);

                # setup mocking and test
                my $res_fh = tmpfile($give_res);
                my $req_fh = tmpfile();

                $http = HTTP::Tiny->new(keep_alive => 0, %new_args) if !defined $http;
                clear_socket_source();
                set_socket_source($req_fh, $res_fh);

                my @@call_args = %options ? ($url, \%options) : ($url);
                my $response  = $http->get(@@call_args);

                my $got_req = slurp($req_fh);
                is( sort_headers($got_req), sort_headers($expect_req), "$label request data");
            }
        }
    };
}

done_testing;
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
        for my $file ( dir_list("t/cases", qr/^cookies/ ) ) {
@


1.1.1.1
log
@Import perl-5.20.1
@
text
@@


1.1.1.2
log
@Import perl-5.24.2
@
text
@d21 1
a21 1
        for my $file ( dir_list("corpus", qr/^cookies/ ) ) {
@

