head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.6
	OPENBSD_6_2_BASE:1.3
	PERL_5_24_2:1.1.1.4
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.3.0.4
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.6
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.4
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.6
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.2
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.31.59;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2016.07.25.10.53.01;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	FHUgABTHZQuYQh2B;

1.1
date	2013.03.25.20.07.43;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.03.25.20.07.43;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.03.24.14.58.52;	author afresh1;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.11.17.20.52.47;	author afresh1;	state Exp;
branches
	1.1.1.3.4.1
	1.1.1.3.6.1;
next	1.1.1.4;
commitid	B31cAbBIXiCqnL97;

1.1.1.4
date	2017.08.14.13.45.38;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;

1.1.1.3.4.1
date	2016.08.05.01.01.37;	author afresh1;	state Exp;
branches;
next	;
commitid	HjAJx2yjL4A8HWon;

1.1.1.3.6.1
date	2016.08.05.01.00.53;	author afresh1;	state Exp;
branches;
next	;
commitid	wK3bUiy9jNch0Key;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@# vim: ts=4 sts=4 sw=4 et:
package HTTP::Tiny;
use strict;
use warnings;
# ABSTRACT: A small, simple, correct HTTP/1.1 client

our $VERSION = '0.056_001';

use Carp ();

#pod =method new
#pod
#pod     $http = HTTP::Tiny->new( %attributes );
#pod
#pod This constructor returns a new HTTP::Tiny object.  Valid attributes include:
#pod
#pod =for :list
#pod * C<agent> —
#pod     A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent> — ends in a space character, the default user-agent string is appended.
#pod * C<cookie_jar> —
#pod     An instance of L<HTTP::CookieJar> — or equivalent class that supports the C<add> and C<cookie_header> methods
#pod * C<default_headers> —
#pod     A hashref of default headers to apply to requests
#pod * C<local_address> —
#pod     The local IP address to bind to
#pod * C<keep_alive> —
#pod     Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)
#pod * C<max_redirect> —
#pod     Maximum number of redirects allowed (defaults to 5)
#pod * C<max_size> —
#pod     Maximum response size in bytes (only when not using a data callback).  If defined, responses larger than this will return an exception.
#pod * C<http_proxy> —
#pod     URL of a proxy server to use for HTTP connections (default is C<$ENV{http_proxy}> — if set)
#pod * C<https_proxy> —
#pod     URL of a proxy server to use for HTTPS connections (default is C<$ENV{https_proxy}> — if set)
#pod * C<proxy> —
#pod     URL of a generic proxy server for both HTTP and HTTPS connections (default is C<$ENV{all_proxy}> — if set)
#pod * C<no_proxy> —
#pod     List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}> —)
#pod * C<timeout> —
#pod     Request timeout in seconds (default is 60)
#pod * C<verify_SSL> —
#pod     A boolean that indicates whether to validate the SSL certificate of an C<https> —
#pod     connection (default is false)
#pod * C<SSL_options> —
#pod     A hashref of C<SSL_*> — options to pass through to L<IO::Socket::SSL>
#pod
#pod Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
#pod prevent getting the corresponding proxies from the environment.
#pod
#pod Exceptions from C<max_size>, C<timeout> or other errors will result in a
#pod pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
#pod content field in the response will contain the text of the exception.
#pod
#pod The C<keep_alive> parameter enables a persistent connection, but only to a
#pod single destination scheme, host and port.  Also, if any connection-relevant
#pod attributes are modified, or if the process ID or thread ID change, the
#pod persistent connection will be dropped.  If you want persistent connections
#pod across multiple destinations, use multiple HTTP::Tiny objects.
#pod
#pod See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
#pod
#pod =cut

my @@attributes;
BEGIN {
    @@attributes = qw(
        cookie_jar default_headers http_proxy https_proxy keep_alive
        local_address max_redirect max_size proxy no_proxy timeout
        SSL_options verify_SSL
    );
    my %persist_ok = map {; $_ => 1 } qw(
        cookie_jar default_headers max_redirect max_size
    );
    no strict 'refs';
    no warnings 'uninitialized';
    for my $accessor ( @@attributes ) {
        *{$accessor} = sub {
            @@_ > 1
                ? do {
                    delete $_[0]->{handle} if !$persist_ok{$accessor} && $_[1] ne $_[0]->{$accessor};
                    $_[0]->{$accessor} = $_[1]
                }
                : $_[0]->{$accessor};
        };
    }
}

sub agent {
    my($self, $agent) = @@_;
    if( @@_ > 1 ){
        $self->{agent} =
            (defined $agent && $agent =~ / $/) ? $agent . $self->_agent : $agent;
    }
    return $self->{agent};
}

sub new {
    my($class, %args) = @@_;

    my $self = {
        max_redirect => 5,
        timeout      => 60,
        keep_alive   => 1,
        verify_SSL   => $args{verify_SSL} || $args{verify_ssl} || 0, # no verification by default
        no_proxy     => $ENV{no_proxy},
    };

    bless $self, $class;

    $class->_validate_cookie_jar( $args{cookie_jar} ) if $args{cookie_jar};

    for my $key ( @@attributes ) {
        $self->{$key} = $args{$key} if exists $args{$key}
    }

    $self->agent( exists $args{agent} ? $args{agent} : $class->_agent );

    $self->_set_proxies;

    return $self;
}

sub _set_proxies {
    my ($self) = @@_;

    # get proxies from %ENV only if not provided; explicit undef will disable
    # getting proxies from the environment

    # generic proxy
    if (! exists $self->{proxy} ) {
        $self->{proxy} = $ENV{all_proxy} || $ENV{ALL_PROXY};
    }

    if ( defined $self->{proxy} ) {
        $self->_split_proxy( 'generic proxy' => $self->{proxy} ); # validate
    }
    else {
        delete $self->{proxy};
    }

    # http proxy
    if (! exists $self->{http_proxy} ) {
        # under CGI, bypass HTTP_PROXY as request sets it from Proxy header
        local $ENV{HTTP_PROXY} if $ENV{REQUEST_METHOD};
        $self->{http_proxy} = $ENV{http_proxy} || $ENV{HTTP_PROXY} || $self->{proxy};
    }

    if ( defined $self->{http_proxy} ) {
        $self->_split_proxy( http_proxy => $self->{http_proxy} ); # validate
        $self->{_has_proxy}{http} = 1;
    }
    else {
        delete $self->{http_proxy};
    }

    # https proxy
    if (! exists $self->{https_proxy} ) {
        $self->{https_proxy} = $ENV{https_proxy} || $ENV{HTTPS_PROXY} || $self->{proxy};
    }

    if ( $self->{https_proxy} ) {
        $self->_split_proxy( https_proxy => $self->{https_proxy} ); # validate
        $self->{_has_proxy}{https} = 1;
    }
    else {
        delete $self->{https_proxy};
    }

    # Split no_proxy to array reference if not provided as such
    unless ( ref $self->{no_proxy} eq 'ARRAY' ) {
        $self->{no_proxy} =
            (defined $self->{no_proxy}) ? [ split /\s*,\s*/, $self->{no_proxy} ] : [];
    }

    return;
}

#pod =method get|head|put|post|delete
#pod
#pod     $response = $http->get($url);
#pod     $response = $http->get($url, \%options);
#pod     $response = $http->head($url);
#pod
#pod These methods are shorthand for calling C<request()> for the given method.  The
#pod URL must have unsafe characters escaped and international domain names encoded.
#pod See C<request()> for valid options and a description of the response.
#pod
#pod The C<success> field of the response will be true if the status code is 2XX.
#pod
#pod =cut

for my $sub_name ( qw/get head put post delete/ ) {
    my $req_method = uc $sub_name;
    no strict 'refs';
    eval <<"HERE"; ## no critic
    sub $sub_name {
        my (\$self, \$url, \$args) = \@@_;
        \@@_ == 2 || (\@@_ == 3 && ref \$args eq 'HASH')
        or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
        return \$self->request('$req_method', \$url, \$args || {});
    }
HERE
}

#pod =method post_form
#pod
#pod     $response = $http->post_form($url, $form_data);
#pod     $response = $http->post_form($url, $form_data, \%options);
#pod
#pod This method executes a C<POST> request and sends the key/value pairs from a
#pod form data hash or array reference to the given URL with a C<content-type> of
#pod C<application/x-www-form-urlencoded>.  If data is provided as an array
#pod reference, the order is preserved; if provided as a hash reference, the terms
#pod are sorted on key and value for consistency.  See documentation for the
#pod C<www_form_urlencode> method for details on the encoding.
#pod
#pod The URL must have unsafe characters escaped and international domain names
#pod encoded.  See C<request()> for valid options and a description of the response.
#pod Any C<content-type> header or content in the options hashref will be ignored.
#pod
#pod The C<success> field of the response will be true if the status code is 2XX.
#pod
#pod =cut

sub post_form {
    my ($self, $url, $data, $args) = @@_;
    (@@_ == 3 || @@_ == 4 && ref $args eq 'HASH')
        or Carp::croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ . "\n");

    my $headers = {};
    while ( my ($key, $value) = each %{$args->{headers} || {}} ) {
        $headers->{lc $key} = $value;
    }
    delete $args->{headers};

    return $self->request('POST', $url, {
            %$args,
            content => $self->www_form_urlencode($data),
            headers => {
                %$headers,
                'content-type' => 'application/x-www-form-urlencoded'
            },
        }
    );
}

#pod =method mirror
#pod
#pod     $response = $http->mirror($url, $file, \%options)
#pod     if ( $response->{success} ) {
#pod         print "$file is up to date\n";
#pod     }
#pod
#pod Executes a C<GET> request for the URL and saves the response body to the file
#pod name provided.  The URL must have unsafe characters escaped and international
#pod domain names encoded.  If the file already exists, the request will include an
#pod C<If-Modified-Since> header with the modification timestamp of the file.  You
#pod may specify a different C<If-Modified-Since> header yourself in the C<<
#pod $options->{headers} >> hash.
#pod
#pod The C<success> field of the response will be true if the status code is 2XX
#pod or if the status code is 304 (unmodified).
#pod
#pod If the file was modified and the server response includes a properly
#pod formatted C<Last-Modified> header, the file modification time will
#pod be updated accordingly.
#pod
#pod =cut

sub mirror {
    my ($self, $url, $file, $args) = @@_;
    @@_ == 3 || (@@_ == 4 && ref $args eq 'HASH')
      or Carp::croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ . "\n");
    if ( -e $file and my $mtime = (stat($file))[9] ) {
        $args->{headers}{'if-modified-since'} ||= $self->_http_date($mtime);
    }
    my $tempfile = $file . int(rand(2**31));

    require Fcntl;
    sysopen my $fh, $tempfile, Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()
       or Carp::croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);
    binmode $fh;
    $args->{data_callback} = sub { print {$fh} $_[0] };
    my $response = $self->request('GET', $url, $args);
    close $fh
        or Carp::croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);

    if ( $response->{success} ) {
        rename $tempfile, $file
            or Carp::croak(qq/Error replacing $file with $tempfile: $!\n/);
        my $lm = $response->{headers}{'last-modified'};
        if ( $lm and my $mtime = $self->_parse_http_date($lm) ) {
            utime $mtime, $mtime, $file;
        }
    }
    $response->{success} ||= $response->{status} eq '304';
    unlink $tempfile;
    return $response;
}

#pod =method request
#pod
#pod     $response = $http->request($method, $url);
#pod     $response = $http->request($method, $url, \%options);
#pod
#pod Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
#pod 'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
#pod international domain names encoded.
#pod
#pod If the URL includes a "user:password" stanza, they will be used for Basic-style
#pod authorization headers.  (Authorization headers will not be included in a
#pod redirected request.) For example:
#pod
#pod     $http->request('GET', 'http://Aladdin:open sesame@@example.com/');
#pod
#pod If the "user:password" stanza contains reserved characters, they must
#pod be percent-escaped:
#pod
#pod     $http->request('GET', 'http://john%40example.com:password@@example.com/');
#pod
#pod A hashref of options may be appended to modify the request.
#pod
#pod Valid options are:
#pod
#pod =for :list
#pod * C<headers> —
#pod     A hashref containing headers to include with the request.  If the value for
#pod     a header is an array reference, the header will be output multiple times with
#pod     each value in the array.  These headers over-write any default headers.
#pod * C<content> —
#pod     A scalar to include as the body of the request OR a code reference
#pod     that will be called iteratively to produce the body of the request
#pod * C<trailer_callback> —
#pod     A code reference that will be called if it exists to provide a hashref
#pod     of trailing headers (only used with chunked transfer-encoding)
#pod * C<data_callback> —
#pod     A code reference that will be called for each chunks of the response
#pod     body received.
#pod
#pod The C<Host> header is generated from the URL in accordance with RFC 2616.  It
#pod is a fatal error to specify C<Host> in the C<headers> option.  Other headers
#pod may be ignored or overwritten if necessary for transport compliance.
#pod
#pod If the C<content> option is a code reference, it will be called iteratively
#pod to provide the content body of the request.  It should return the empty
#pod string or undef when the iterator is exhausted.
#pod
#pod If the C<content> option is the empty string, no C<content-type> or
#pod C<content-length> headers will be generated.
#pod
#pod If the C<data_callback> option is provided, it will be called iteratively until
#pod the entire response body is received.  The first argument will be a string
#pod containing a chunk of the response body, the second argument will be the
#pod in-progress response hash reference, as described below.  (This allows
#pod customizing the action of the callback based on the C<status> or C<headers>
#pod received prior to the content body.)
#pod
#pod The C<request> method returns a hashref containing the response.  The hashref
#pod will have the following keys:
#pod
#pod =for :list
#pod * C<success> —
#pod     Boolean indicating whether the operation returned a 2XX status code
#pod * C<url> —
#pod     URL that provided the response. This is the URL of the request unless
#pod     there were redirections, in which case it is the last URL queried
#pod     in a redirection chain
#pod * C<status> —
#pod     The HTTP status code of the response
#pod * C<reason> —
#pod     The response phrase returned by the server
#pod * C<content> —
#pod     The body of the response.  If the response does not have any content
#pod     or if a data callback is provided to consume the response body,
#pod     this will be the empty string
#pod * C<headers> —
#pod     A hashref of header fields.  All header field names will be normalized
#pod     to be lower case. If a header is repeated, the value will be an arrayref;
#pod     it will otherwise be a scalar string containing the value
#pod
#pod On an exception during the execution of the request, the C<status> field will
#pod contain 599, and the C<content> field will contain the text of the exception.
#pod
#pod =cut

my %idempotent = map { $_ => 1 } qw/GET HEAD PUT DELETE OPTIONS TRACE/;

sub request {
    my ($self, $method, $url, $args) = @@_;
    @@_ == 3 || (@@_ == 4 && ref $args eq 'HASH')
      or Carp::croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ . "\n");
    $args ||= {}; # we keep some state in this during _request

    # RFC 2616 Section 8.1.4 mandates a single retry on broken socket
    my $response;
    for ( 0 .. 1 ) {
        $response = eval { $self->_request($method, $url, $args) };
        last unless $@@ && $idempotent{$method}
            && $@@ =~ m{^(?:Socket closed|Unexpected end)};
    }

    if (my $e = $@@) {
        # maybe we got a response hash thrown from somewhere deep
        if ( ref $e eq 'HASH' && exists $e->{status} ) {
            return $e;
        }

        # otherwise, stringify it
        $e = "$e";
        $response = {
            url     => $url,
            success => q{},
            status  => 599,
            reason  => 'Internal Exception',
            content => $e,
            headers => {
                'content-type'   => 'text/plain',
                'content-length' => length $e,
            }
        };
    }
    return $response;
}

#pod =method www_form_urlencode
#pod
#pod     $params = $http->www_form_urlencode( $data );
#pod     $response = $http->get("http://example.com/query?$params");
#pod
#pod This method converts the key/value pairs from a data hash or array reference
#pod into a C<x-www-form-urlencoded> string.  The keys and values from the data
#pod reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
#pod array reference, the key will be repeated with each of the values of the array
#pod reference.  If data is provided as a hash reference, the key/value pairs in the
#pod resulting string will be sorted by key and value for consistent ordering.
#pod
#pod =cut

sub www_form_urlencode {
    my ($self, $data) = @@_;
    (@@_ == 2 && ref $data)
        or Carp::croak(q/Usage: $http->www_form_urlencode(DATAREF)/ . "\n");
    (ref $data eq 'HASH' || ref $data eq 'ARRAY')
        or Carp::croak("form data must be a hash or array reference\n");

    my @@params = ref $data eq 'HASH' ? %$data : @@$data;
    @@params % 2 == 0
        or Carp::croak("form data reference must have an even number of terms\n");

    my @@terms;
    while( @@params ) {
        my ($key, $value) = splice(@@params, 0, 2);
        if ( ref $value eq 'ARRAY' ) {
            unshift @@params, map { $key => $_ } @@$value;
        }
        else {
            push @@terms, join("=", map { $self->_uri_escape($_) } $key, $value);
        }
    }

    return join("&", (ref $data eq 'ARRAY') ? (@@terms) : (sort @@terms) );
}

#pod =method can_ssl
#pod
#pod     $ok         = HTTP::Tiny->can_ssl;
#pod     ($ok, $why) = HTTP::Tiny->can_ssl;
#pod     ($ok, $why) = $http->can_ssl;
#pod
#pod Indicates if SSL support is available.  When called as a class object, it
#pod checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
#pod When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
#pod is set in C<SSL_options>, it checks that a CA file is available.
#pod
#pod In scalar context, returns a boolean indicating if SSL is available.
#pod In list context, returns the boolean and a (possibly multi-line) string of
#pod errors indicating why SSL isn't available.
#pod
#pod =cut

sub can_ssl {
    my ($self) = @@_;

    my($ok, $reason) = (1, '');

    # Need IO::Socket::SSL 1.42 for SSL_create_ctx_callback
    local @@INC = @@INC;
    pop @@INC if $INC[-1] eq '.';
    unless (eval {require IO::Socket::SSL; IO::Socket::SSL->VERSION(1.42)}) {
        $ok = 0;
        $reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/;
    }

    # Need Net::SSLeay 1.49 for MODE_AUTO_RETRY
    unless (eval {require Net::SSLeay; Net::SSLeay->VERSION(1.49)}) {
        $ok = 0;
        $reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/;
    }

    # If an object, check that SSL config lets us get a CA if necessary
    if ( ref($self) && ( $self->{verify_SSL} || $self->{SSL_options}{SSL_verify_mode} ) ) {
        my $handle = HTTP::Tiny::Handle->new(
            SSL_options => $self->{SSL_options},
            verify_SSL  => $self->{verify_SSL},
        );
        unless ( eval { $handle->_find_CA_file; 1 } ) {
            $ok = 0;
            $reason .= "$@@";
        }
    }

    wantarray ? ($ok, $reason) : $ok;
}

#--------------------------------------------------------------------------#
# private methods
#--------------------------------------------------------------------------#

my %DefaultPort = (
    http => 80,
    https => 443,
);

sub _agent {
    my $class = ref($_[0]) || $_[0];
    (my $default_agent = $class) =~ s{::}{-}g;
    return $default_agent . "/" . $class->VERSION;
}

sub _request {
    my ($self, $method, $url, $args) = @@_;

    my ($scheme, $host, $port, $path_query, $auth) = $self->_split_url($url);

    my $request = {
        method    => $method,
        scheme    => $scheme,
        host      => $host,
        port      => $port,
        host_port => ($port == $DefaultPort{$scheme} ? $host : "$host:$port"),
        uri       => $path_query,
        headers   => {},
    };

    # We remove the cached handle so it is not reused in the case of redirect.
    # If all is well, it will be recached at the end of _request.  We only
    # reuse for the same scheme, host and port
    my $handle = delete $self->{handle};
    if ( $handle ) {
        unless ( $handle->can_reuse( $scheme, $host, $port ) ) {
            $handle->close;
            undef $handle;
        }
    }
    $handle ||= $self->_open_handle( $request, $scheme, $host, $port );

    $self->_prepare_headers_and_cb($request, $args, $url, $auth);
    $handle->write_request($request);

    my $response;
    do { $response = $handle->read_response_header }
        until (substr($response->{status},0,1) ne '1');

    $self->_update_cookie_jar( $url, $response ) if $self->{cookie_jar};

    if ( my @@redir_args = $self->_maybe_redirect($request, $response, $args) ) {
        $handle->close;
        return $self->_request(@@redir_args, $args);
    }

    my $known_message_length;
    if ($method eq 'HEAD' || $response->{status} =~ /^[23]04/) {
        # response has no message body
        $known_message_length = 1;
    }
    else {
        my $data_cb = $self->_prepare_data_cb($response, $args);
        $known_message_length = $handle->read_body($data_cb, $response);
    }

    if ( $self->{keep_alive}
        && $known_message_length
        && $response->{protocol} eq 'HTTP/1.1'
        && ($response->{headers}{connection} || '') ne 'close'
    ) {
        $self->{handle} = $handle;
    }
    else {
        $handle->close;
    }

    $response->{success} = substr( $response->{status}, 0, 1 ) eq '2';
    $response->{url} = $url;
    return $response;
}

sub _open_handle {
    my ($self, $request, $scheme, $host, $port) = @@_;

    my $handle  = HTTP::Tiny::Handle->new(
        timeout         => $self->{timeout},
        SSL_options     => $self->{SSL_options},
        verify_SSL      => $self->{verify_SSL},
        local_address   => $self->{local_address},
        keep_alive      => $self->{keep_alive}
    );

    if ($self->{_has_proxy}{$scheme} && ! grep { $host =~ /\Q$_\E$/ } @@{$self->{no_proxy}}) {
        return $self->_proxy_connect( $request, $handle );
    }
    else {
        return $handle->connect($scheme, $host, $port);
    }
}

sub _proxy_connect {
    my ($self, $request, $handle) = @@_;

    my @@proxy_vars;
    if ( $request->{scheme} eq 'https' ) {
        Carp::croak(qq{No https_proxy defined}) unless $self->{https_proxy};
        @@proxy_vars = $self->_split_proxy( https_proxy => $self->{https_proxy} );
        if ( $proxy_vars[0] eq 'https' ) {
            Carp::croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}});
        }
    }
    else {
        Carp::croak(qq{No http_proxy defined}) unless $self->{http_proxy};
        @@proxy_vars = $self->_split_proxy( http_proxy => $self->{http_proxy} );
    }

    my ($p_scheme, $p_host, $p_port, $p_auth) = @@proxy_vars;

    if ( length $p_auth && ! defined $request->{headers}{'proxy-authorization'} ) {
        $self->_add_basic_auth_header( $request, 'proxy-authorization' => $p_auth );
    }

    $handle->connect($p_scheme, $p_host, $p_port);

    if ($request->{scheme} eq 'https') {
        $self->_create_proxy_tunnel( $request, $handle );
    }
    else {
        # non-tunneled proxy requires absolute URI
        $request->{uri} = "$request->{scheme}://$request->{host_port}$request->{uri}";
    }

    return $handle;
}

sub _split_proxy {
    my ($self, $type, $proxy) = @@_;

    my ($scheme, $host, $port, $path_query, $auth) = eval { $self->_split_url($proxy) };

    unless(
        defined($scheme) && length($scheme) && length($host) && length($port)
        && $path_query eq '/'
    ) {
        Carp::croak(qq{$type URL must be in format http[s]://[auth@@]<host>:<port>/\n});
    }

    return ($scheme, $host, $port, $auth);
}

sub _create_proxy_tunnel {
    my ($self, $request, $handle) = @@_;

    $handle->_assert_ssl;

    my $agent = exists($request->{headers}{'user-agent'})
        ? $request->{headers}{'user-agent'} : $self->{agent};

    my $connect_request = {
        method    => 'CONNECT',
        uri       => "$request->{host}:$request->{port}",
        headers   => {
            host => "$request->{host}:$request->{port}",
            'user-agent' => $agent,
        }
    };

    if ( $request->{headers}{'proxy-authorization'} ) {
        $connect_request->{headers}{'proxy-authorization'} =
            delete $request->{headers}{'proxy-authorization'};
    }

    $handle->write_request($connect_request);
    my $response;
    do { $response = $handle->read_response_header }
        until (substr($response->{status},0,1) ne '1');

    # if CONNECT failed, throw the response so it will be
    # returned from the original request() method;
    unless (substr($response->{status},0,1) eq '2') {
        die $response;
    }

    # tunnel established, so start SSL handshake
    $handle->start_ssl( $request->{host} );

    return;
}

sub _prepare_headers_and_cb {
    my ($self, $request, $args, $url, $auth) = @@_;

    for ($self->{default_headers}, $args->{headers}) {
        next unless defined;
        while (my ($k, $v) = each %$_) {
            $request->{headers}{lc $k} = $v;
        }
    }

    if (exists $request->{headers}{'host'}) {
        die(qq/The 'Host' header must not be provided as header option\n/);
    }

    $request->{headers}{'host'}         = $request->{host_port};
    $request->{headers}{'user-agent'} ||= $self->{agent};
    $request->{headers}{'connection'}   = "close"
        unless $self->{keep_alive};

    if ( defined $args->{content} ) {
        if (ref $args->{content} eq 'CODE') {
            $request->{headers}{'content-type'} ||= "application/octet-stream";
            $request->{headers}{'transfer-encoding'} = 'chunked'
              unless $request->{headers}{'content-length'}
                  || $request->{headers}{'transfer-encoding'};
            $request->{cb} = $args->{content};
        }
        elsif ( length $args->{content} ) {
            my $content = $args->{content};
            if ( $] ge '5.008' ) {
                utf8::downgrade($content, 1)
                    or die(qq/Wide character in request message body\n/);
            }
            $request->{headers}{'content-type'} ||= "application/octet-stream";
            $request->{headers}{'content-length'} = length $content
              unless $request->{headers}{'content-length'}
                  || $request->{headers}{'transfer-encoding'};
            $request->{cb} = sub { substr $content, 0, length $content, '' };
        }
        $request->{trailer_cb} = $args->{trailer_callback}
            if ref $args->{trailer_callback} eq 'CODE';
    }

    ### If we have a cookie jar, then maybe add relevant cookies
    if ( $self->{cookie_jar} ) {
        my $cookies = $self->cookie_jar->cookie_header( $url );
        $request->{headers}{cookie} = $cookies if length $cookies;
    }

    # if we have Basic auth parameters, add them
    if ( length $auth && ! defined $request->{headers}{authorization} ) {
        $self->_add_basic_auth_header( $request, 'authorization' => $auth );
    }

    return;
}

sub _add_basic_auth_header {
    my ($self, $request, $header, $auth) = @@_;
    require MIME::Base64;
    $request->{headers}{$header} =
        "Basic " . MIME::Base64::encode_base64($auth, "");
    return;
}

sub _prepare_data_cb {
    my ($self, $response, $args) = @@_;
    my $data_cb = $args->{data_callback};
    $response->{content} = '';

    if (!$data_cb || $response->{status} !~ /^2/) {
        if (defined $self->{max_size}) {
            $data_cb = sub {
                $_[1]->{content} .= $_[0];
                die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)
                  if length $_[1]->{content} > $self->{max_size};
            };
        }
        else {
            $data_cb = sub { $_[1]->{content} .= $_[0] };
        }
    }
    return $data_cb;
}

sub _update_cookie_jar {
    my ($self, $url, $response) = @@_;

    my $cookies = $response->{headers}->{'set-cookie'};
    return unless defined $cookies;

    my @@cookies = ref $cookies ? @@$cookies : $cookies;

    $self->cookie_jar->add( $url, $_ ) for @@cookies;

    return;
}

sub _validate_cookie_jar {
    my ($class, $jar) = @@_;

    # duck typing
    for my $method ( qw/add cookie_header/ ) {
        Carp::croak(qq/Cookie jar must provide the '$method' method\n/)
            unless ref($jar) && ref($jar)->can($method);
    }

    return;
}

sub _maybe_redirect {
    my ($self, $request, $response, $args) = @@_;
    my $headers = $response->{headers};
    my ($status, $method) = ($response->{status}, $request->{method});
    if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))
        and $headers->{location}
        and ++$args->{redirects} <= $self->{max_redirect}
    ) {
        my $location = ($headers->{location} =~ /^\//)
            ? "$request->{scheme}://$request->{host_port}$headers->{location}"
            : $headers->{location} ;
        return (($status eq '303' ? 'GET' : $method), $location);
    }
    return;
}

sub _split_url {
    my $url = pop;

    # URI regex adapted from the URI module
    my ($scheme, $host, $path_query) = $url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)>
      or die(qq/Cannot parse URL: '$url'\n/);

    $scheme     = lc $scheme;
    $path_query = "/$path_query" unless $path_query =~ m<\A/>;

    my $auth = '';
    if ( (my $i = index $host, '@@') != -1 ) {
        # user:pass@@host
        $auth = substr $host, 0, $i, ''; # take up to the @@ for auth
        substr $host, 0, 1, '';          # knock the @@ off the host

        # userinfo might be percent escaped, so recover real auth info
        $auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
    }
    my $port = $host =~ s/:(\d*)\z// && length $1 ? $1
             : $scheme eq 'http'                  ? 80
             : $scheme eq 'https'                 ? 443
             : undef;

    return ($scheme, (length $host ? lc $host : "localhost") , $port, $path_query, $auth);
}

# Date conversions adapted from HTTP::Date
my $DoW = "Sun|Mon|Tue|Wed|Thu|Fri|Sat";
my $MoY = "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";
sub _http_date {
    my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($_[1]);
    return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
        substr($DoW,$wday*4,3),
        $mday, substr($MoY,$mon*4,3), $year+1900,
        $hour, $min, $sec
    );
}

sub _parse_http_date {
    my ($self, $str) = @@_;
    require Time::Local;
    my @@tl_parts;
    if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/) {
        @@tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
    }
    elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/ ) {
        @@tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
    }
    elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/ ) {
        @@tl_parts = ($5, $4, $3, $2, (index($MoY,$1)/4), $6);
    }
    return eval {
        my $t = @@tl_parts ? Time::Local::timegm(@@tl_parts) : -1;
        $t < 0 ? undef : $t;
    };
}

# URI escaping adapted from URI::Escape
# c.f. http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
# perl 5.6 ready UTF-8 encoding adapted from JSON::PP
my %escapes = map { chr($_) => sprintf("%%%02X", $_) } 0..255;
$escapes{' '}="+";
my $unsafe_char = qr/[^A-Za-z0-9\-\._~]/;

sub _uri_escape {
    my ($self, $str) = @@_;
    if ( $] ge '5.008' ) {
        utf8::encode($str);
    }
    else {
        $str = pack("U*", unpack("C*", $str)) # UTF-8 encode a byte string
            if ( length $str == do { use bytes; length $str } );
        $str = pack("C*", unpack("C*", $str)); # clear UTF-8 flag
    }
    $str =~ s/($unsafe_char)/$escapes{$1}/ge;
    return $str;
}

package
    HTTP::Tiny::Handle; # hide from PAUSE/indexers
use strict;
use warnings;

use Errno      qw[EINTR EPIPE];
use IO::Socket qw[SOCK_STREAM];

# PERL_HTTP_TINY_IPV4_ONLY is a private environment variable to force old
# behavior if someone is unable to boostrap CPAN from a new perl install; it is
# not intended for general, per-client use and may be removed in the future
my $SOCKET_CLASS =
    $ENV{PERL_HTTP_TINY_IPV4_ONLY} ? 'IO::Socket::INET' :
    eval { require IO::Socket::IP; IO::Socket::IP->VERSION(0.25) } ? 'IO::Socket::IP' :
    'IO::Socket::INET';

sub BUFSIZE () { 32768 } ## no critic

my $Printable = sub {
    local $_ = shift;
    s/\r/\\r/g;
    s/\n/\\n/g;
    s/\t/\\t/g;
    s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;
    $_;
};

my $Token = qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;

sub new {
    my ($class, %args) = @@_;
    return bless {
        rbuf             => '',
        timeout          => 60,
        max_line_size    => 16384,
        max_header_lines => 64,
        verify_SSL       => 0,
        SSL_options      => {},
        %args
    }, $class;
}

sub connect {
    @@_ == 4 || die(q/Usage: $handle->connect(scheme, host, port)/ . "\n");
    my ($self, $scheme, $host, $port) = @@_;

    if ( $scheme eq 'https' ) {
        $self->_assert_ssl;
    }
    elsif ( $scheme ne 'http' ) {
      die(qq/Unsupported URL scheme '$scheme'\n/);
    }
    $self->{fh} = $SOCKET_CLASS->new(
        PeerHost  => $host,
        PeerPort  => $port,
        $self->{local_address} ?
            ( LocalAddr => $self->{local_address} ) : (),
        Proto     => 'tcp',
        Type      => SOCK_STREAM,
        Timeout   => $self->{timeout},
        KeepAlive => !!$self->{keep_alive}
    ) or die(qq/Could not connect to '$host:$port': $@@\n/);

    binmode($self->{fh})
      or die(qq/Could not binmode() socket: '$!'\n/);

    $self->start_ssl($host) if $scheme eq 'https';

    $self->{scheme} = $scheme;
    $self->{host} = $host;
    $self->{port} = $port;
    $self->{pid} = $$;
    $self->{tid} = _get_tid();

    return $self;
}

sub start_ssl {
    my ($self, $host) = @@_;

    # As this might be used via CONNECT after an SSL session
    # to a proxy, we shut down any existing SSL before attempting
    # the handshake
    if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
        unless ( $self->{fh}->stop_SSL ) {
            my $ssl_err = IO::Socket::SSL->errstr;
            die(qq/Error halting prior SSL connection: $ssl_err/);
        }
    }

    my $ssl_args = $self->_ssl_args($host);
    IO::Socket::SSL->start_SSL(
        $self->{fh},
        %$ssl_args,
        SSL_create_ctx_callback => sub {
            my $ctx = shift;
            Net::SSLeay::CTX_set_mode($ctx, Net::SSLeay::MODE_AUTO_RETRY());
        },
    );

    unless ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
        my $ssl_err = IO::Socket::SSL->errstr;
        die(qq/SSL connection failed for $host: $ssl_err\n/);
    }
}

sub close {
    @@_ == 1 || die(q/Usage: $handle->close()/ . "\n");
    my ($self) = @@_;
    CORE::close($self->{fh})
      or die(qq/Could not close socket: '$!'\n/);
}

sub write {
    @@_ == 2 || die(q/Usage: $handle->write(buf)/ . "\n");
    my ($self, $buf) = @@_;

    if ( $] ge '5.008' ) {
        utf8::downgrade($buf, 1)
            or die(qq/Wide character in write()\n/);
    }

    my $len = length $buf;
    my $off = 0;

    local $SIG{PIPE} = 'IGNORE';

    while () {
        $self->can_write
          or die(qq/Timed out while waiting for socket to become ready for writing\n/);
        my $r = syswrite($self->{fh}, $buf, $len, $off);
        if (defined $r) {
            $len -= $r;
            $off += $r;
            last unless $len > 0;
        }
        elsif ($! == EPIPE) {
            die(qq/Socket closed by remote server: $!\n/);
        }
        elsif ($! != EINTR) {
            if ($self->{fh}->can('errstr')){
                my $err = $self->{fh}->errstr();
                die (qq/Could not write to SSL socket: '$err'\n /);
            }
            else {
                die(qq/Could not write to socket: '$!'\n/);
            }

        }
    }
    return $off;
}

sub read {
    @@_ == 2 || @@_ == 3 || die(q/Usage: $handle->read(len [, allow_partial])/ . "\n");
    my ($self, $len, $allow_partial) = @@_;

    my $buf  = '';
    my $got = length $self->{rbuf};

    if ($got) {
        my $take = ($got < $len) ? $got : $len;
        $buf  = substr($self->{rbuf}, 0, $take, '');
        $len -= $take;
    }

    while ($len > 0) {
        $self->can_read
          or die(q/Timed out while waiting for socket to become ready for reading/ . "\n");
        my $r = sysread($self->{fh}, $buf, $len, length $buf);
        if (defined $r) {
            last unless $r;
            $len -= $r;
        }
        elsif ($! != EINTR) {
            if ($self->{fh}->can('errstr')){
                my $err = $self->{fh}->errstr();
                die (qq/Could not read from SSL socket: '$err'\n /);
            }
            else {
                die(qq/Could not read from socket: '$!'\n/);
            }
        }
    }
    if ($len && !$allow_partial) {
        die(qq/Unexpected end of stream\n/);
    }
    return $buf;
}

sub readline {
    @@_ == 1 || die(q/Usage: $handle->readline()/ . "\n");
    my ($self) = @@_;

    while () {
        if ($self->{rbuf} =~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x) {
            return $1;
        }
        if (length $self->{rbuf} >= $self->{max_line_size}) {
            die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/);
        }
        $self->can_read
          or die(qq/Timed out while waiting for socket to become ready for reading\n/);
        my $r = sysread($self->{fh}, $self->{rbuf}, BUFSIZE, length $self->{rbuf});
        if (defined $r) {
            last unless $r;
        }
        elsif ($! != EINTR) {
            if ($self->{fh}->can('errstr')){
                my $err = $self->{fh}->errstr();
                die (qq/Could not read from SSL socket: '$err'\n /);
            }
            else {
                die(qq/Could not read from socket: '$!'\n/);
            }
        }
    }
    die(qq/Unexpected end of stream while looking for line\n/);
}

sub read_header_lines {
    @@_ == 1 || @@_ == 2 || die(q/Usage: $handle->read_header_lines([headers])/ . "\n");
    my ($self, $headers) = @@_;
    $headers ||= {};
    my $lines   = 0;
    my $val;

    while () {
         my $line = $self->readline;

         if (++$lines >= $self->{max_header_lines}) {
             die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/);
         }
         elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x) {
             my ($field_name) = lc $1;
             if (exists $headers->{$field_name}) {
                 for ($headers->{$field_name}) {
                     $_ = [$_] unless ref $_ eq "ARRAY";
                     push @@$_, $2;
                     $val = \$_->[-1];
                 }
             }
             else {
                 $val = \($headers->{$field_name} = $2);
             }
         }
         elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x) {
             $val
               or die(qq/Unexpected header continuation line\n/);
             next unless length $1;
             $$val .= ' ' if length $$val;
             $$val .= $1;
         }
         elsif ($line =~ /\A \x0D?\x0A \z/x) {
            last;
         }
         else {
            die(q/Malformed header line: / . $Printable->($line) . "\n");
         }
    }
    return $headers;
}

sub write_request {
    @@_ == 2 || die(q/Usage: $handle->write_request(request)/ . "\n");
    my($self, $request) = @@_;
    $self->write_request_header(@@{$request}{qw/method uri headers/});
    $self->write_body($request) if $request->{cb};
    return;
}

my %HeaderCase = (
    'content-md5'      => 'Content-MD5',
    'etag'             => 'ETag',
    'te'               => 'TE',
    'www-authenticate' => 'WWW-Authenticate',
    'x-xss-protection' => 'X-XSS-Protection',
);

# to avoid multiple small writes and hence nagle, you can pass the method line or anything else to
# combine writes.
sub write_header_lines {
    (@@_ == 2 || @@_ == 3 && ref $_[1] eq 'HASH') || die(q/Usage: $handle->write_header_lines(headers[,prefix])/ . "\n");
    my($self, $headers, $prefix_data) = @@_;

    my $buf = (defined $prefix_data ? $prefix_data : '');
    while (my ($k, $v) = each %$headers) {
        my $field_name = lc $k;
        if (exists $HeaderCase{$field_name}) {
            $field_name = $HeaderCase{$field_name};
        }
        else {
            $field_name =~ /\A $Token+ \z/xo
              or die(q/Invalid HTTP header field name: / . $Printable->($field_name) . "\n");
            $field_name =~ s/\b(\w)/\u$1/g;
            $HeaderCase{lc $field_name} = $field_name;
        }
        for (ref $v eq 'ARRAY' ? @@$v : $v) {
            $_ = '' unless defined $_;
            $buf .= "$field_name: $_\x0D\x0A";
        }
    }
    $buf .= "\x0D\x0A";
    return $self->write($buf);
}

# return value indicates whether message length was defined; this is generally
# true unless there was no content-length header and we just read until EOF.
# Other message length errors are thrown as exceptions
sub read_body {
    @@_ == 3 || die(q/Usage: $handle->read_body(callback, response)/ . "\n");
    my ($self, $cb, $response) = @@_;
    my $te = $response->{headers}{'transfer-encoding'} || '';
    my $chunked = grep { /chunked/i } ( ref $te eq 'ARRAY' ? @@$te : $te ) ;
    return $chunked
        ? $self->read_chunked_body($cb, $response)
        : $self->read_content_body($cb, $response);
}

sub write_body {
    @@_ == 2 || die(q/Usage: $handle->write_body(request)/ . "\n");
    my ($self, $request) = @@_;
    if ($request->{headers}{'content-length'}) {
        return $self->write_content_body($request);
    }
    else {
        return $self->write_chunked_body($request);
    }
}

sub read_content_body {
    @@_ == 3 || @@_ == 4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ . "\n");
    my ($self, $cb, $response, $content_length) = @@_;
    $content_length ||= $response->{headers}{'content-length'};

    if ( defined $content_length ) {
        my $len = $content_length;
        while ($len > 0) {
            my $read = ($len > BUFSIZE) ? BUFSIZE : $len;
            $cb->($self->read($read, 0), $response);
            $len -= $read;
        }
        return length($self->{rbuf}) == 0;
    }

    my $chunk;
    $cb->($chunk, $response) while length( $chunk = $self->read(BUFSIZE, 1) );

    return;
}

sub write_content_body {
    @@_ == 2 || die(q/Usage: $handle->write_content_body(request)/ . "\n");
    my ($self, $request) = @@_;

    my ($len, $content_length) = (0, $request->{headers}{'content-length'});
    while () {
        my $data = $request->{cb}->();

        defined $data && length $data
          or last;

        if ( $] ge '5.008' ) {
            utf8::downgrade($data, 1)
                or die(qq/Wide character in write_content()\n/);
        }

        $len += $self->write($data);
    }

    $len == $content_length
      or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);

    return $len;
}

sub read_chunked_body {
    @@_ == 3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ . "\n");
    my ($self, $cb, $response) = @@_;

    while () {
        my $head = $self->readline;

        $head =~ /\A ([A-Fa-f0-9]+)/x
          or die(q/Malformed chunk head: / . $Printable->($head) . "\n");

        my $len = hex($1)
          or last;

        $self->read_content_body($cb, $response, $len);

        $self->read(2) eq "\x0D\x0A"
          or die(qq/Malformed chunk: missing CRLF after chunk data\n/);
    }
    $self->read_header_lines($response->{headers});
    return 1;
}

sub write_chunked_body {
    @@_ == 2 || die(q/Usage: $handle->write_chunked_body(request)/ . "\n");
    my ($self, $request) = @@_;

    my $len = 0;
    while () {
        my $data = $request->{cb}->();

        defined $data && length $data
          or last;

        if ( $] ge '5.008' ) {
            utf8::downgrade($data, 1)
                or die(qq/Wide character in write_chunked_body()\n/);
        }

        $len += length $data;

        my $chunk  = sprintf '%X', length $data;
           $chunk .= "\x0D\x0A";
           $chunk .= $data;
           $chunk .= "\x0D\x0A";

        $self->write($chunk);
    }
    $self->write("0\x0D\x0A");
    $self->write_header_lines($request->{trailer_cb}->())
        if ref $request->{trailer_cb} eq 'CODE';
    return $len;
}

sub read_response_header {
    @@_ == 1 || die(q/Usage: $handle->read_response_header()/ . "\n");
    my ($self) = @@_;

    my $line = $self->readline;

    $line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) [\x09\x20]+ ([^\x0D\x0A]*) \x0D?\x0A/x
      or die(q/Malformed Status-Line: / . $Printable->($line). "\n");

    my ($protocol, $version, $status, $reason) = ($1, $2, $3, $4);

    die (qq/Unsupported HTTP protocol: $protocol\n/)
        unless $version =~ /0*1\.0*[01]/;

    return {
        status       => $status,
        reason       => $reason,
        headers      => $self->read_header_lines,
        protocol     => $protocol,
    };
}

sub write_request_header {
    @@_ == 4 || die(q/Usage: $handle->write_request_header(method, request_uri, headers)/ . "\n");
    my ($self, $method, $request_uri, $headers) = @@_;

    return $self->write_header_lines($headers, "$method $request_uri HTTP/1.1\x0D\x0A");
}

sub _do_timeout {
    my ($self, $type, $timeout) = @@_;
    $timeout = $self->{timeout}
        unless defined $timeout && $timeout >= 0;

    my $fd = fileno $self->{fh};
    defined $fd && $fd >= 0
      or die(qq/select(2): 'Bad file descriptor'\n/);

    my $initial = time;
    my $pending = $timeout;
    my $nfound;

    vec(my $fdset = '', $fd, 1) = 1;

    while () {
        $nfound = ($type eq 'read')
            ? select($fdset, undef, undef, $pending)
            : select(undef, $fdset, undef, $pending) ;
        if ($nfound == -1) {
            $! == EINTR
              or die(qq/select(2): '$!'\n/);
            redo if !$timeout || ($pending = $timeout - (time - $initial)) > 0;
            $nfound = 0;
        }
        last;
    }
    $! = 0;
    return $nfound;
}

sub can_read {
    @@_ == 1 || @@_ == 2 || die(q/Usage: $handle->can_read([timeout])/ . "\n");
    my $self = shift;
    if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
        return 1 if $self->{fh}->pending;
    }
    return $self->_do_timeout('read', @@_)
}

sub can_write {
    @@_ == 1 || @@_ == 2 || die(q/Usage: $handle->can_write([timeout])/ . "\n");
    my $self = shift;
    return $self->_do_timeout('write', @@_)
}

sub _assert_ssl {
    my($ok, $reason) = HTTP::Tiny->can_ssl();
    die $reason unless $ok;
}

sub can_reuse {
    my ($self,$scheme,$host,$port) = @@_;
    return 0 if
        $self->{pid} != $$
        || $self->{tid} != _get_tid()
        || length($self->{rbuf})
        || $scheme ne $self->{scheme}
        || $host ne $self->{host}
        || $port ne $self->{port}
        || eval { $self->can_read(0) }
        || $@@ ;
        return 1;
}

# Try to find a CA bundle to validate the SSL cert,
# prefer Mozilla::CA or fallback to a system file
sub _find_CA_file {
    my $self = shift();

    if ( $self->{SSL_options}->{SSL_ca_file} ) {
        unless ( -r $self->{SSL_options}->{SSL_ca_file} ) {
            die qq/SSL_ca_file '$self->{SSL_options}->{SSL_ca_file}' not found or not readable\n/;
        }
        return $self->{SSL_options}->{SSL_ca_file};
    }

    local @@INC = @@INC;
    pop @@INC if $INC[-1] eq '.';
    return Mozilla::CA::SSL_ca_file()
        if eval { require Mozilla::CA; 1 };

    # cert list copied from golang src/crypto/x509/root_unix.go
    foreach my $ca_bundle (
        "/etc/ssl/certs/ca-certificates.crt",     # Debian/Ubuntu/Gentoo etc.
        "/etc/pki/tls/certs/ca-bundle.crt",       # Fedora/RHEL
        "/etc/ssl/ca-bundle.pem",                 # OpenSUSE
        "/etc/openssl/certs/ca-certificates.crt", # NetBSD
        "/etc/ssl/cert.pem",                      # OpenBSD
        "/usr/local/share/certs/ca-root-nss.crt", # FreeBSD/DragonFly
        "/etc/pki/tls/cacert.pem",                # OpenELEC
        "/etc/certs/ca-certificates.crt",         # Solaris 11.2+
    ) {
        return $ca_bundle if -e $ca_bundle;
    }

    die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/
      . qq/Try installing Mozilla::CA from CPAN\n/;
}

# for thread safety, we need to know thread id if threads are loaded
sub _get_tid {
    no warnings 'reserved'; # for 'threads'
    return threads->can("tid") ? threads->tid : 0;
}

sub _ssl_args {
    my ($self, $host) = @@_;

    my %ssl_args;

    # This test reimplements IO::Socket::SSL::can_client_sni(), which wasn't
    # added until IO::Socket::SSL 1.84
    if ( Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x01000000 ) {
        $ssl_args{SSL_hostname} = $host,          # Sane SNI support
    }

    if ($self->{verify_SSL}) {
        $ssl_args{SSL_verifycn_scheme}  = 'http'; # enable CN validation
        $ssl_args{SSL_verifycn_name}    = $host;  # set validation hostname
        $ssl_args{SSL_verify_mode}      = 0x01;   # enable cert validation
        $ssl_args{SSL_ca_file}          = $self->_find_CA_file;
    }
    else {
        $ssl_args{SSL_verifycn_scheme}  = 'none'; # disable CN validation
        $ssl_args{SSL_verify_mode}      = 0x00;   # disable cert validation
    }

    # user options override settings from verify_SSL
    for my $k ( keys %{$self->{SSL_options}} ) {
        $ssl_args{$k} = $self->{SSL_options}{$k} if $k =~ m/^SSL_/;
    }

    return \%ssl_args;
}

1;

__END__

=pod

=encoding UTF-8

=head1 NAME

HTTP::Tiny - A small, simple, correct HTTP/1.1 client

=head1 VERSION

version 0.056

=head1 SYNOPSIS

    use HTTP::Tiny;

    my $response = HTTP::Tiny->new->get('http://example.com/');

    die "Failed!\n" unless $response->{success};

    print "$response->{status} $response->{reason}\n";

    while (my ($k, $v) = each %{$response->{headers}}) {
        for (ref $v eq 'ARRAY' ? @@$v : $v) {
            print "$k: $_\n";
        }
    }

    print $response->{content} if length $response->{content};

=head1 DESCRIPTION

This is a very simple HTTP/1.1 client, designed for doing simple
requests without the overhead of a large framework like L<LWP::UserAgent>.

It is more correct and more complete than L<HTTP::Lite>.  It supports
proxies and redirection.  It also correctly resumes after EINTR.

If L<IO::Socket::IP> 0.25 or later is installed, HTTP::Tiny will use it instead
of L<IO::Socket::INET> for transparent support for both IPv4 and IPv6.

Cookie support requires L<HTTP::CookieJar> or an equivalent class.

=head1 METHODS

=head2 new

    $http = HTTP::Tiny->new( %attributes );

This constructor returns a new HTTP::Tiny object.  Valid attributes include:

=over 4

=item *

C<agent> — A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent> — ends in a space character, the default user-agent string is appended.

=item *

C<cookie_jar> — An instance of L<HTTP::CookieJar> — or equivalent class that supports the C<add> and C<cookie_header> methods

=item *

C<default_headers> — A hashref of default headers to apply to requests

=item *

C<local_address> — The local IP address to bind to

=item *

C<keep_alive> — Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)

=item *

C<max_redirect> — Maximum number of redirects allowed (defaults to 5)

=item *

C<max_size> — Maximum response size in bytes (only when not using a data callback).  If defined, responses larger than this will return an exception.

=item *

C<http_proxy> — URL of a proxy server to use for HTTP connections (default is C<$ENV{http_proxy}> — if set)

=item *

C<https_proxy> — URL of a proxy server to use for HTTPS connections (default is C<$ENV{https_proxy}> — if set)

=item *

C<proxy> — URL of a generic proxy server for both HTTP and HTTPS connections (default is C<$ENV{all_proxy}> — if set)

=item *

C<no_proxy> — List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}> —)

=item *

C<timeout> — Request timeout in seconds (default is 60)

=item *

C<verify_SSL> — A boolean that indicates whether to validate the SSL certificate of an C<https> — connection (default is false)

=item *

C<SSL_options> — A hashref of C<SSL_*> — options to pass through to L<IO::Socket::SSL>

=back

Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
prevent getting the corresponding proxies from the environment.

Exceptions from C<max_size>, C<timeout> or other errors will result in a
pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
content field in the response will contain the text of the exception.

The C<keep_alive> parameter enables a persistent connection, but only to a
single destination scheme, host and port.  Also, if any connection-relevant
attributes are modified, or if the process ID or thread ID change, the
persistent connection will be dropped.  If you want persistent connections
across multiple destinations, use multiple HTTP::Tiny objects.

See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.

=head2 get|head|put|post|delete

    $response = $http->get($url);
    $response = $http->get($url, \%options);
    $response = $http->head($url);

These methods are shorthand for calling C<request()> for the given method.  The
URL must have unsafe characters escaped and international domain names encoded.
See C<request()> for valid options and a description of the response.

The C<success> field of the response will be true if the status code is 2XX.

=head2 post_form

    $response = $http->post_form($url, $form_data);
    $response = $http->post_form($url, $form_data, \%options);

This method executes a C<POST> request and sends the key/value pairs from a
form data hash or array reference to the given URL with a C<content-type> of
C<application/x-www-form-urlencoded>.  If data is provided as an array
reference, the order is preserved; if provided as a hash reference, the terms
are sorted on key and value for consistency.  See documentation for the
C<www_form_urlencode> method for details on the encoding.

The URL must have unsafe characters escaped and international domain names
encoded.  See C<request()> for valid options and a description of the response.
Any C<content-type> header or content in the options hashref will be ignored.

The C<success> field of the response will be true if the status code is 2XX.

=head2 mirror

    $response = $http->mirror($url, $file, \%options)
    if ( $response->{success} ) {
        print "$file is up to date\n";
    }

Executes a C<GET> request for the URL and saves the response body to the file
name provided.  The URL must have unsafe characters escaped and international
domain names encoded.  If the file already exists, the request will include an
C<If-Modified-Since> header with the modification timestamp of the file.  You
may specify a different C<If-Modified-Since> header yourself in the C<<
$options->{headers} >> hash.

The C<success> field of the response will be true if the status code is 2XX
or if the status code is 304 (unmodified).

If the file was modified and the server response includes a properly
formatted C<Last-Modified> header, the file modification time will
be updated accordingly.

=head2 request

    $response = $http->request($method, $url);
    $response = $http->request($method, $url, \%options);

Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
international domain names encoded.

If the URL includes a "user:password" stanza, they will be used for Basic-style
authorization headers.  (Authorization headers will not be included in a
redirected request.) For example:

    $http->request('GET', 'http://Aladdin:open sesame@@example.com/');

If the "user:password" stanza contains reserved characters, they must
be percent-escaped:

    $http->request('GET', 'http://john%40example.com:password@@example.com/');

A hashref of options may be appended to modify the request.

Valid options are:

=over 4

=item *

C<headers> — A hashref containing headers to include with the request.  If the value for a header is an array reference, the header will be output multiple times with each value in the array.  These headers over-write any default headers.

=item *

C<content> — A scalar to include as the body of the request OR a code reference that will be called iteratively to produce the body of the request

=item *

C<trailer_callback> — A code reference that will be called if it exists to provide a hashref of trailing headers (only used with chunked transfer-encoding)

=item *

C<data_callback> — A code reference that will be called for each chunks of the response body received.

=back

The C<Host> header is generated from the URL in accordance with RFC 2616.  It
is a fatal error to specify C<Host> in the C<headers> option.  Other headers
may be ignored or overwritten if necessary for transport compliance.

If the C<content> option is a code reference, it will be called iteratively
to provide the content body of the request.  It should return the empty
string or undef when the iterator is exhausted.

If the C<content> option is the empty string, no C<content-type> or
C<content-length> headers will be generated.

If the C<data_callback> option is provided, it will be called iteratively until
the entire response body is received.  The first argument will be a string
containing a chunk of the response body, the second argument will be the
in-progress response hash reference, as described below.  (This allows
customizing the action of the callback based on the C<status> or C<headers>
received prior to the content body.)

The C<request> method returns a hashref containing the response.  The hashref
will have the following keys:

=over 4

=item *

C<success> — Boolean indicating whether the operation returned a 2XX status code

=item *

C<url> — URL that provided the response. This is the URL of the request unless there were redirections, in which case it is the last URL queried in a redirection chain

=item *

C<status> — The HTTP status code of the response

=item *

C<reason> — The response phrase returned by the server

=item *

C<content> — The body of the response.  If the response does not have any content or if a data callback is provided to consume the response body, this will be the empty string

=item *

C<headers> — A hashref of header fields.  All header field names will be normalized to be lower case. If a header is repeated, the value will be an arrayref; it will otherwise be a scalar string containing the value

=back

On an exception during the execution of the request, the C<status> field will
contain 599, and the C<content> field will contain the text of the exception.

=head2 www_form_urlencode

    $params = $http->www_form_urlencode( $data );
    $response = $http->get("http://example.com/query?$params");

This method converts the key/value pairs from a data hash or array reference
into a C<x-www-form-urlencoded> string.  The keys and values from the data
reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
array reference, the key will be repeated with each of the values of the array
reference.  If data is provided as a hash reference, the key/value pairs in the
resulting string will be sorted by key and value for consistent ordering.

=head2 can_ssl

    $ok         = HTTP::Tiny->can_ssl;
    ($ok, $why) = HTTP::Tiny->can_ssl;
    ($ok, $why) = $http->can_ssl;

Indicates if SSL support is available.  When called as a class object, it
checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
is set in C<SSL_options>, it checks that a CA file is available.

In scalar context, returns a boolean indicating if SSL is available.
In list context, returns the boolean and a (possibly multi-line) string of
errors indicating why SSL isn't available.

=for Pod::Coverage SSL_options
agent
cookie_jar
default_headers
http_proxy
https_proxy
keep_alive
local_address
max_redirect
max_size
no_proxy
proxy
timeout
verify_SSL

=head1 SSL SUPPORT

Direct C<https> connections are supported only if L<IO::Socket::SSL> 1.56 or
greater and L<Net::SSLeay> 1.49 or greater are installed. An exception will be
thrown if new enough versions of these modules are not installed or if the SSL
encryption fails. You can also use C<HTTP::Tiny::can_ssl()> utility function
that returns boolean to see if the required modules are installed.

An C<https> connection may be made via an C<http> proxy that supports the CONNECT
command (i.e. RFC 2817).  You may not proxy C<https> via a proxy that itself
requires C<https> to communicate.

SSL provides two distinct capabilities:

=over 4

=item *

Encrypted communication channel

=item *

Verification of server identity

=back

B<By default, HTTP::Tiny does not verify server identity>.

Server identity verification is controversial and potentially tricky because it
depends on a (usually paid) third-party Certificate Authority (CA) trust model
to validate a certificate as legitimate.  This discriminates against servers
with self-signed certificates or certificates signed by free, community-driven
CA's such as L<CAcert.org|http://cacert.org>.

By default, HTTP::Tiny does not make any assumptions about your trust model,
threat level or risk tolerance.  It just aims to give you an encrypted channel
when you need one.

Setting the C<verify_SSL> attribute to a true value will make HTTP::Tiny verify
that an SSL connection has a valid SSL certificate corresponding to the host
name of the connection and that the SSL certificate has been verified by a CA.
Assuming you trust the CA, this will protect against a L<man-in-the-middle
attack|http://en.wikipedia.org/wiki/Man-in-the-middle_attack>.  If you are
concerned about security, you should enable this option.

Certificate verification requires a file containing trusted CA certificates.
If the L<Mozilla::CA> module is installed, HTTP::Tiny will use the CA file
included with it as a source of trusted CA's.  (This means you trust Mozilla,
the author of Mozilla::CA, the CPAN mirror where you got Mozilla::CA, the
toolchain used to install it, and your operating system security, right?)

If that module is not available, then HTTP::Tiny will search several
system-specific default locations for a CA certificate file:

=over 4

=item *

/etc/ssl/certs/ca-certificates.crt

=item *

/etc/pki/tls/certs/ca-bundle.crt

=item *

/etc/ssl/ca-bundle.pem

=back

An exception will be raised if C<verify_SSL> is true and no CA certificate file
is available.

If you desire complete control over SSL connections, the C<SSL_options> attribute
lets you provide a hash reference that will be passed through to
C<IO::Socket::SSL::start_SSL()>, overriding any options set by HTTP::Tiny. For
example, to provide your own trusted CA file:

    SSL_options => {
        SSL_ca_file => $file_path,
    }

The C<SSL_options> attribute could also be used for such things as providing a
client certificate for authentication to a server or controlling the choice of
cipher used for the SSL connection. See L<IO::Socket::SSL> documentation for
details.

=head1 PROXY SUPPORT

HTTP::Tiny can proxy both C<http> and C<https> requests.  Only Basic proxy
authorization is supported and it must be provided as part of the proxy URL:
C<http://user:pass@@proxy.example.com/>.

HTTP::Tiny supports the following proxy environment variables:

=over 4

=item *

http_proxy or HTTP_PROXY

=item *

https_proxy or HTTPS_PROXY

=item *

all_proxy or ALL_PROXY

=back

If the C<REQUEST_METHOD> environment variable is set, then this might be a CGI
process and C<HTTP_PROXY> would be set from the C<Proxy:> header, which is a
security risk.  If C<REQUEST_METHOD> is set, C<HTTP_PROXY> (the upper case
variant only) is ignored.

Tunnelling C<https> over an C<http> proxy using the CONNECT method is
supported.  If your proxy uses C<https> itself, you can not tunnel C<https>
over it.

Be warned that proxying an C<https> connection opens you to the risk of a
man-in-the-middle attack by the proxy server.

The C<no_proxy> environment variable is supported in the format of a
comma-separated list of domain extensions proxy should not be used for.

Proxy arguments passed to C<new> will override their corresponding
environment variables.

=head1 LIMITATIONS

HTTP::Tiny is I<conditionally compliant> with the
L<HTTP/1.1 specifications|http://www.w3.org/Protocols/>:

=over 4

=item *

"Message Syntax and Routing" [RFC7230]

=item *

"Semantics and Content" [RFC7231]

=item *

"Conditional Requests" [RFC7232]

=item *

"Range Requests" [RFC7233]

=item *

"Caching" [RFC7234]

=item *

"Authentication" [RFC7235]

=back

It attempts to meet all "MUST" requirements of the specification, but does not
implement all "SHOULD" requirements.  (Note: it was developed against the
earlier RFC 2616 specification and may not yet meet the revised RFC 7230-7235
spec.)

Some particular limitations of note include:

=over

=item *

HTTP::Tiny focuses on correct transport.  Users are responsible for ensuring
that user-defined headers and content are compliant with the HTTP/1.1
specification.

=item *

Users must ensure that URLs are properly escaped for unsafe characters and that
international domain names are properly encoded to ASCII. See L<URI::Escape>,
L<URI::_punycode> and L<Net::IDN::Encode>.

=item *

Redirection is very strict against the specification.  Redirection is only
automatic for response codes 301, 302, 307 and 308 if the request method is
'GET' or 'HEAD'.  Response code 303 is always converted into a 'GET'
redirection, as mandated by the specification.  There is no automatic support
for status 305 ("Use proxy") redirections.

=item *

There is no provision for delaying a request body using an C<Expect> header.
Unexpected C<1XX> responses are silently ignored as per the specification.

=item *

Only 'chunked' C<Transfer-Encoding> is supported.

=item *

There is no support for a Request-URI of '*' for the 'OPTIONS' request.

=back

Despite the limitations listed above, HTTP::Tiny is considered
feature-complete.  New feature requests should be directed to
L<HTTP::Tiny::UA>.

=head1 SEE ALSO

=over 4

=item *

L<HTTP::Tiny::UA> - Higher level UA features for HTTP::Tiny

=item *

L<HTTP::Thin> - HTTP::Tiny wrapper with L<HTTP::Request>/L<HTTP::Response> compatibility

=item *

L<HTTP::Tiny::Mech> - Wrap L<WWW::Mechanize> instance in HTTP::Tiny compatible interface

=item *

L<IO::Socket::IP> - Required for IPv6 support

=item *

L<IO::Socket::SSL> - Required for SSL support

=item *

L<LWP::UserAgent> - If HTTP::Tiny isn't enough for you, this is the "standard" way to do things

=item *

L<Mozilla::CA> - Required if you want to validate SSL certificates

=item *

L<Net::SSLeay> - Required for SSL support

=back

=for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan

=head1 SUPPORT

=head2 Bugs / Feature Requests

Please report any bugs or feature requests through the issue tracker
at L<https://github.com/chansen/p5-http-tiny/issues>.
You will be notified automatically of any progress on your issue.

=head2 Source Code

This is open source software.  The code repository is available for
public review and contribution under the terms of the license.

L<https://github.com/chansen/p5-http-tiny>

  git clone https://github.com/chansen/p5-http-tiny.git

=head1 AUTHORS

=over 4

=item *

Christian Hansen <chansen@@cpan.org>

=item *

David Golden <dagolden@@cpan.org>

=back

=head1 CONTRIBUTORS

=for stopwords Alan Gardner Alessandro Ghedini Brad Gilbert Chris Nehren Weyl Claes Jakobsson Clinton Gormley Dean Pearce Edward Zborowski James Raspass Jeremy Mates Jess Robinson Lukas Eklund Martin J. Evans Martin-Louis Bright Mike Doherty Olaf Alders Olivier Mengué Petr Písař Sören Kornetzki Syohei YOSHIDA Tatsuhiko Miyagawa Tom Hukins Tony Cook

=over 4

=item *

Alan Gardner <gardner@@pythian.com>

=item *

Alessandro Ghedini <al3xbio@@gmail.com>

=item *

Brad Gilbert <bgills@@cpan.org>

=item *

Chris Nehren <apeiron@@cpan.org>

=item *

Chris Weyl <cweyl@@alumni.drew.edu>

=item *

Claes Jakobsson <claes@@surfar.nu>

=item *

Clinton Gormley <clint@@traveljury.com>

=item *

Dean Pearce <pearce@@pythian.com>

=item *

Edward Zborowski <ed@@rubensteintech.com>

=item *

James Raspass <jraspass@@gmail.com>

=item *

Jeremy Mates <jmates@@cpan.org>

=item *

Jess Robinson <castaway@@desert-island.me.uk>

=item *

Lukas Eklund <leklund@@gmail.com>

=item *

Martin J. Evans <mjegh@@ntlworld.com>

=item *

Martin-Louis Bright <mlbright@@gmail.com>

=item *

Mike Doherty <doherty@@cpan.org>

=item *

Olaf Alders <olaf@@wundersolutions.com>

=item *

Olivier Mengué <dolmen@@cpan.org>

=item *

Petr Písař <ppisar@@redhat.com>

=item *

Sören Kornetzki <soeren.kornetzki@@delti.com>

=item *

Syohei YOSHIDA <syohex@@gmail.com>

=item *

Tatsuhiko Miyagawa <miyagawa@@bulknews.net>

=item *

Tom Hukins <tom@@eborcom.com>

=item *

Tony Cook <tony@@develop-help.com>

=back

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2015 by Christian Hansen.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
@


1.2
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.


ok deraadt@@
@
text
@d6 2
a7 1
our $VERSION = '0.043_01'; # VERSION
d11 53
a63 50
# =method new
#
#     $http = HTTP::Tiny->new( %attributes );
#
# This constructor returns a new HTTP::Tiny object.  Valid attributes include:
#
# =for :list
# * C<agent>
# A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent> ends in a space character, the default user-agent string is appended.
# * C<cookie_jar>
# An instance of L<HTTP::CookieJar> or equivalent class that supports the C<add> and C<cookie_header> methods
# * C<default_headers>
# A hashref of default headers to apply to requests
# * C<local_address>
# The local IP address to bind to
# * C<keep_alive>
# Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)
# * C<max_redirect>
# Maximum number of redirects allowed (defaults to 5)
# * C<max_size>
# Maximum response size (only when not using a data callback).  If defined, responses larger than this will return an exception.
# * C<http_proxy>
# URL of a proxy server to use for HTTP connections (default is C<$ENV{http_proxy}> if set)
# * C<https_proxy>
# URL of a proxy server to use for HTTPS connections (default is C<$ENV{https_proxy}> if set)
# * C<proxy>
# URL of a generic proxy server for both HTTP and HTTPS connections (default is C<$ENV{all_proxy}> if set)
# * C<no_proxy>
# List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}>)
# * C<timeout>
# Request timeout in seconds (default is 60)
# * C<verify_SSL>
# A boolean that indicates whether to validate the SSL certificate of an C<https>
# connection (default is false)
# * C<SSL_options>
# A hashref of C<SSL_*> options to pass through to L<IO::Socket::SSL>
#
# Exceptions from C<max_size>, C<timeout> or other errors will result in a
# pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
# content field in the response will contain the text of the exception.
#
# The C<keep_alive> parameter enables a persistent connection, but only to a
# single destination scheme, host and port.  Also, if any connection-relevant
# attributes are modified, a persistent connection will be dropped.  If you want
# persistent connections across multiple destinations, use multiple HTTP::Tiny
# objects.
#
# See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
#
# =cut
d127 5
a131 1
    if (! $self->{proxy} ) {
a132 6
        if ( defined $self->{proxy} ) {
            $self->_split_proxy( 'generic proxy' => $self->{proxy} ); # validate
        }
        else {
            delete $self->{proxy};
        }
d135 20
a154 9
    if (! $self->{http_proxy} ) {
        $self->{http_proxy} = $ENV{http_proxy} || $self->{proxy};
        if ( defined $self->{http_proxy} ) {
            $self->_split_proxy( http_proxy => $self->{http_proxy} ); # validate
            $self->{_has_proxy}{http} = 1;
        }
        else {
            delete $self->{http_proxy};
        }
d157 2
a158 1
    if (! $self->{https_proxy} ) {
d160 8
a167 7
        if ( $self->{https_proxy} ) {
            $self->_split_proxy( https_proxy => $self->{https_proxy} ); # validate
            $self->{_has_proxy}{https} = 1;
        }
        else {
            delete $self->{https_proxy};
        }
d179 13
a191 13
# =method get|head|put|post|delete
#
#     $response = $http->get($url);
#     $response = $http->get($url, \%options);
#     $response = $http->head($url);
#
# These methods are shorthand for calling C<request()> for the given method.  The
# URL must have unsafe characters escaped and international domain names encoded.
# See C<request()> for valid options and a description of the response.
#
# The C<success> field of the response will be true if the status code is 2XX.
#
# =cut
d206 19
a224 19
# =method post_form
#
#     $response = $http->post_form($url, $form_data);
#     $response = $http->post_form($url, $form_data, \%options);
#
# This method executes a C<POST> request and sends the key/value pairs from a
# form data hash or array reference to the given URL with a C<content-type> of
# C<application/x-www-form-urlencoded>.  If data is provided as an array
# reference, the order is preserved; if provided as a hash reference, the terms
# are sorted on key and value for consistency.  See documentation for the
# C<www_form_urlencode> method for details on the encoding.
#
# The URL must have unsafe characters escaped and international domain names
# encoded.  See C<request()> for valid options and a description of the response.
# Any C<content-type> header or content in the options hashref will be ignored.
#
# The C<success> field of the response will be true if the status code is 2XX.
#
# =cut
d248 22
a269 22
# =method mirror
#
#     $response = $http->mirror($url, $file, \%options)
#     if ( $response->{success} ) {
#         print "$file is up to date\n";
#     }
#
# Executes a C<GET> request for the URL and saves the response body to the file
# name provided.  The URL must have unsafe characters escaped and international
# domain names encoded.  If the file already exists, the request will include an
# C<If-Modified-Since> header with the modification timestamp of the file.  You
# may specify a different C<If-Modified-Since> header yourself in the C<<
# $options->{headers} >> hash.
#
# The C<success> field of the response will be true if the status code is 2XX
# or if the status code is 304 (unmodified).
#
# If the file was modified and the server response includes a properly
# formatted C<Last-Modified> header, the file modification time will
# be updated accordingly.
#
# =cut
d302 84
a385 80
# =method request
#
#     $response = $http->request($method, $url);
#     $response = $http->request($method, $url, \%options);
#
# Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
# 'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
# international domain names encoded.
#
# If the URL includes a "user:password" stanza, they will be used for Basic-style
# authorization headers.  (Authorization headers will not be included in a
# redirected request.) For example:
#
#     $http->request('GET', 'http://Aladdin:open sesame@@example.com/');
#
# If the "user:password" stanza contains reserved characters, they must
# be percent-escaped:
#
#     $http->request('GET', 'http://john%40example.com:password@@example.com/');
#
# A hashref of options may be appended to modify the request.
#
# Valid options are:
#
# =for :list
# * C<headers>
# A hashref containing headers to include with the request.  If the value for
# a header is an array reference, the header will be output multiple times with
# each value in the array.  These headers over-write any default headers.
# * C<content>
# A scalar to include as the body of the request OR a code reference
# that will be called iteratively to produce the body of the request
# * C<trailer_callback>
# A code reference that will be called if it exists to provide a hashref
# of trailing headers (only used with chunked transfer-encoding)
# * C<data_callback>
# A code reference that will be called for each chunks of the response
# body received.
#
# If the C<content> option is a code reference, it will be called iteratively
# to provide the content body of the request.  It should return the empty
# string or undef when the iterator is exhausted.
#
# If the C<content> option is the empty string, no C<content-type> or
# C<content-length> headers will be generated.
#
# If the C<data_callback> option is provided, it will be called iteratively until
# the entire response body is received.  The first argument will be a string
# containing a chunk of the response body, the second argument will be the
# in-progress response hash reference, as described below.  (This allows
# customizing the action of the callback based on the C<status> or C<headers>
# received prior to the content body.)
#
# The C<request> method returns a hashref containing the response.  The hashref
# will have the following keys:
#
# =for :list
# * C<success>
# Boolean indicating whether the operation returned a 2XX status code
# * C<url>
# URL that provided the response. This is the URL of the request unless
# there were redirections, in which case it is the last URL queried
# in a redirection chain
# * C<status>
# The HTTP status code of the response
# * C<reason>
# The response phrase returned by the server
# * C<content>
# The body of the response.  If the response does not have any content
# or if a data callback is provided to consume the response body,
# this will be the empty string
# * C<headers>
# A hashref of header fields.  All header field names will be normalized
# to be lower case. If a header is repeated, the value will be an arrayref;
# it will otherwise be a scalar string containing the value
#
# On an exception during the execution of the request, the C<status> field will
# contain 599, and the C<content> field will contain the text of the exception.
#
# =cut
d426 13
a438 13
# =method www_form_urlencode
#
#     $params = $http->www_form_urlencode( $data );
#     $response = $http->get("http://example.com/query?$params");
#
# This method converts the key/value pairs from a data hash or array reference
# into a C<x-www-form-urlencoded> string.  The keys and values from the data
# reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
# array reference, the key will be repeated with each of the values of the array
# reference.  If data is provided as a hash reference, the key/value pairs in the
# resulting string will be sorted by key and value for consistent ordering.
#
# =cut
d465 51
d528 1
a528 1
    return $default_agent . "/" . ($class->VERSION || 0);
d540 1
d677 1
a677 1
        uri       => $request->{host_port},
d679 1
a679 1
            host => $request->{host_port},
d715 5
d820 1
a820 1
    if (($status eq '303' or ($status =~ /^30[127]/ && $method =~ /^GET|HEAD$/))
d836 1
a836 1
    my ($scheme, $authority, $path_query) = $url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)>
d842 6
a847 4
    my ($auth,$host);
    $authority = (length($authority)) ? $authority : 'localhost';
    if ( $authority =~ /@@/ ) {
        ($auth,$host) = $authority =~ m/\A([^@@]*)@@(.*)\z/;   # user:pass@@host
d851 4
a854 10
    else {
        $host = $authority;
        $auth = '';
    }
    $host = lc $host;
    my $port = do {
       $host =~ s/:([0-9]*)\z// && length $1
         ? $1
         : ($scheme eq 'http' ? 80 : $scheme eq 'https' ? 443 : undef);
    };
d856 1
a856 1
    return ($scheme, $host, $port, $path_query, $auth);
d982 2
d1209 1
a1209 2
            /[^\x0D\x0A]/
              or die(qq/Invalid HTTP header field value ($field_name): / . $Printable->($_). "\n");
d1282 1
a1282 1
      or die(qq/Content-Length missmatch (got: $len expected: $content_length)\n/);
d1416 2
a1417 6
    # Need IO::Socket::SSL 1.42 for SSL_create_ctx_callback
    die(qq/IO::Socket::SSL 1.42 must be installed for https support\n/)
        unless eval {require IO::Socket::SSL; IO::Socket::SSL->VERSION(1.42)};
    # Need Net::SSLeay 1.49 for MODE_AUTO_RETRY
    die(qq/Net::SSLeay 1.49 must be installed for https support\n/)
        unless eval {require Net::SSLeay; Net::SSLeay->VERSION(1.49)};
d1423 3
a1425 1
         length($self->{rbuf})
d1439 6
a1444 2
    return $self->{SSL_options}->{SSL_ca_file}
        if $self->{SSL_options}->{SSL_ca_file} and -e $self->{SSL_options}->{SSL_ca_file};
d1449 1
a1449 1
        if eval { require Mozilla::CA };
d1451 10
a1460 5
    foreach my $ca_bundle (qw{
        /etc/ssl/certs/ca-certificates.crt
        /etc/pki/tls/certs/ca-bundle.crt
        /etc/ssl/ca-bundle.pem
        }
d1469 6
d1519 1
a1519 1
version 0.043
d1564 1
a1564 3
C<agent>

A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent> ends in a space character, the default user-agent string is appended.
d1568 1
a1568 3
C<cookie_jar>

An instance of L<HTTP::CookieJar> or equivalent class that supports the C<add> and C<cookie_header> methods
d1572 1
a1572 3
C<default_headers>

A hashref of default headers to apply to requests
d1576 1
a1576 3
C<local_address>

The local IP address to bind to
d1580 1
a1580 3
C<keep_alive>

Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)
d1584 1
a1584 3
C<max_redirect>

Maximum number of redirects allowed (defaults to 5)
d1588 1
a1588 3
C<max_size>

Maximum response size (only when not using a data callback).  If defined, responses larger than this will return an exception.
d1592 1
a1592 3
C<http_proxy>

URL of a proxy server to use for HTTP connections (default is C<$ENV{http_proxy}> if set)
d1596 1
a1596 3
C<https_proxy>

URL of a proxy server to use for HTTPS connections (default is C<$ENV{https_proxy}> if set)
d1600 1
a1600 3
C<proxy>

URL of a generic proxy server for both HTTP and HTTPS connections (default is C<$ENV{all_proxy}> if set)
d1604 1
a1604 3
C<no_proxy>

List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}>)
d1608 1
a1608 3
C<timeout>

Request timeout in seconds (default is 60)
d1612 1
a1612 4
C<verify_SSL>

A boolean that indicates whether to validate the SSL certificate of an C<https>
connection (default is false)
d1616 1
a1616 1
C<SSL_options>
d1618 1
a1618 1
A hashref of C<SSL_*> options to pass through to L<IO::Socket::SSL>
d1620 2
a1621 1
=back
d1629 3
a1631 3
attributes are modified, a persistent connection will be dropped.  If you want
persistent connections across multiple destinations, use multiple HTTP::Tiny
objects.
d1714 1
a1714 5
C<headers>

A hashref containing headers to include with the request.  If the value for
a header is an array reference, the header will be output multiple times with
each value in the array.  These headers over-write any default headers.
d1718 1
a1718 4
C<content>

A scalar to include as the body of the request OR a code reference
that will be called iteratively to produce the body of the request
d1722 1
a1722 4
C<trailer_callback>

A code reference that will be called if it exists to provide a hashref
of trailing headers (only used with chunked transfer-encoding)
d1726 1
a1726 1
C<data_callback>
d1728 1
a1728 2
A code reference that will be called for each chunks of the response
body received.
d1730 3
a1732 1
=back
d1755 1
a1755 3
C<success>

Boolean indicating whether the operation returned a 2XX status code
d1759 1
a1759 5
C<url>

URL that provided the response. This is the URL of the request unless
there were redirections, in which case it is the last URL queried
in a redirection chain
d1763 1
a1763 3
C<status>

The HTTP status code of the response
d1767 1
a1767 3
C<reason>

The response phrase returned by the server
d1771 1
a1771 5
C<content>

The body of the response.  If the response does not have any content
or if a data callback is provided to consume the response body,
this will be the empty string
d1775 1
a1775 5
C<headers>

A hashref of header fields.  All header field names will be normalized
to be lower case. If a header is repeated, the value will be an arrayref;
it will otherwise be a scalar string containing the value
d1794 15
d1828 7
a1834 4
thrown if a new enough versions of these modules not installed or if the SSL
encryption fails. An C<https> connection may be made via an C<http> proxy that
supports the CONNECT command (i.e. RFC 2817).  You may not proxy C<https> via
a proxy that itself requires C<https> to communicate.
d1923 1
a1923 1
http_proxy
d1935 5
d1956 30
a1985 1
L<HTTP/1.1 specification|http://www.w3.org/Protocols/rfc2616/rfc2616.html>.
d1987 3
a1989 1
implement all "SHOULD" requirements.
d2010 4
a2013 4
automatic for response codes 301, 302 and 307 if the request method is 'GET' or
'HEAD'.  Response code 303 is always converted into a 'GET' redirection, as
mandated by the specification.  There is no automatic support for status 305
("Use proxy") redirections.
d2107 2
d2141 1
a2141 1
Craig Berry <cberry@@cpan.org>
d2145 1
a2145 1
David Mitchell <davem@@iabyn.com>
d2149 5
a2153 1
Edward Zborowski <ed@@rubensteintech.com>
d2177 8
d2189 1
a2189 1
Serguei Trouchelle <stro@@cpan.org>
d2197 8
d2211 1
a2211 1
This software is copyright (c) 2014 by Christian Hansen.
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
our $VERSION = '0.017'; # VERSION
d10 50
d63 8
a70 1
    @@attributes = qw(agent default_headers max_redirect max_size proxy timeout);
d72 1
d75 6
a80 1
            @@_ > 1 ? $_[0]->{$accessor} = $_[1] : $_[0]->{$accessor};
d85 9
d96 1
a96 1
    (my $agent = $class) =~ s{::}{-}g;
a97 1
        agent        => $agent . "/" . ($class->VERSION || 0),
d100 3
d104 5
d113 14
a126 4
    # Never override proxy argument as this breaks backwards compat.
    if (!exists $self->{proxy} && (my $http_proxy = $ENV{http_proxy})) {
        if ($http_proxy =~ m{\Ahttp://[^/?#:@@]+:\d+/?\z}) {
            $self->{proxy} = $http_proxy;
d129 1
a129 1
            Carp::croak(qq{Environment 'http_proxy' must be in format http://<host>:<port>/\n});
d133 29
a161 1
    return bless $self, $class;
d164 13
d191 19
d233 22
d264 4
a267 2
    open my $fh, ">", $tempfile
        or Carp::croak(qq/Error: Could not open temporary file $tempfile for downloading: $!\n/);
d272 2
a273 1
        or Carp::croak(qq/Error: Could not close temporary file $tempfile: $!\n/);
d287 80
d384 8
a391 1
    if (my $e = "$@@") {
d393 1
d407 13
d426 1
a426 1
        or Carp::croak("form data must be a hash or array reference");
d443 1
a443 1
    return join("&", sort @@terms);
d455 6
d464 1
a464 1
    my ($scheme, $host, $port, $path_query) = $self->_split_url($url);
d469 1
d475 9
a483 10
    my $handle  = HTTP::Tiny::Handle->new(timeout => $self->{timeout});

    if ($self->{proxy}) {
        $request->{uri} = "$scheme://$request->{host_port}$path_query";
        die(qq/HTTPS via proxy is not supported\n/)
            if $request->{scheme} eq 'https';
        $handle->connect(($self->_split_url($self->{proxy}))[0..2]);
    }
    else {
        $handle->connect($scheme, $host, $port);
d485 1
d487 1
a487 1
    $self->_prepare_headers_and_cb($request, $args);
d494 2
d501 1
d504 1
d508 12
a519 1
        $handle->read_body($data_cb, $response);
d522 2
a523 2
    $handle->close;
    $response->{success} = substr($response->{status},0,1) eq '2';
d527 108
d636 1
a636 1
    my ($self, $request, $args) = @@_;
a644 1
    $request->{headers}{'connection'}   = "close";
d646 2
d649 1
a649 2
    if (defined $args->{content}) {
        $request->{headers}{'content-type'} ||= "application/octet-stream";
d651 1
d657 1
a657 1
        else {
d663 1
d672 20
d715 25
d766 12
a777 2
    my $host = (length($authority)) ? lc $authority : 'localhost';
       $host =~ s/\A[^@@]*@@//;   # userinfo
d784 1
a784 1
    return ($scheme, $host, $port, $path_query);
d847 8
d875 2
a880 6
my $ssl_verify_args = {
    check_cn => "when_only",
    wildcards_in_alt => "anywhere",
    wildcards_in_cn => "anywhere"
};

d886 1
a886 4
        eval "require IO::Socket::SSL"
            unless exists $INC{'IO/Socket/SSL.pm'};
        die(qq/IO::Socket::SSL must be installed for https support\n/)
            unless $INC{'IO/Socket/SSL.pm'};
d891 1
a891 2

    $self->{fh} = 'IO::Socket::INET'->new(
d894 2
d898 2
a899 1
        Timeout   => $self->{timeout}
d905 1
a905 7
    if ( $scheme eq 'https') {
        IO::Socket::SSL->start_SSL($self->{fh});
        ref($self->{fh}) eq 'IO::Socket::SSL'
            or die(qq/SSL connection failed for $host\n/);
        $self->{fh}->verify_hostname( $host, $ssl_verify_args )
            or die(qq/SSL certificate not valid for $host\n/);
    }
d907 1
d914 29
d977 8
a984 1
            die(qq/Could not write to socket: '$!'\n/);
d1012 7
a1018 1
            die(qq/Could not read from socket: '$!'\n/);
d1045 7
a1051 1
            die(qq/Could not read from socket: '$!'\n/);
d1116 2
d1119 2
a1120 2
    (@@_ == 2 && ref $_[1] eq 'HASH') || die(q/Usage: $handle->write_header_lines(headers)/ . "\n");
    my($self, $headers) = @@_;
d1122 1
a1122 1
    my $buf = '';
d1144 3
d1151 4
a1154 7
    if ( grep { /chunked/i } ( ref $te eq 'ARRAY' ? @@$te : $te ) ) {
        $self->read_chunked_body($cb, $response);
    }
    else {
        $self->read_content_body($cb, $response);
    }
    return;
d1173 1
a1173 1
    if ( $content_length ) {
d1180 1
d1182 3
a1184 4
    else {
        my $chunk;
        $cb->($chunk, $response) while length( $chunk = $self->read(BUFSIZE, 1) );
    }
d1233 1
a1233 1
    return;
d1282 4
a1285 4
        status   => $status,
        reason   => $reason,
        headers  => $self->read_header_lines,
        protocol => $protocol,
d1293 1
a1293 2
    return $self->write("$method $request_uri HTTP/1.1\x0D\x0A")
         + $self->write_header_lines($headers);
d1330 3
d1342 68
a1409 1
1;
d1411 4
d1416 4
d1422 1
d1425 2
d1433 1
a1433 1
version 0.017
d1455 1
a1455 1
This is a very simple HTTP/1.1 client, designed for doing simple GET
d1459 6
a1464 2
proxies (currently only non-authenticating ones) and redirection.  It
also correctly resumes after EINTR.
d1480 7
a1486 1
A user-agent string (defaults to 'HTTP::Tiny/$VERSION')
d1496 12
d1516 13
a1528 2
Maximum response size (only when not using a data callback).  If defined,
responses larger than this will return an exception.
d1534 7
a1540 1
URL of a proxy server to use (default is C<$ENV{http_proxy}> if set)
d1548 13
d1567 8
d1594 3
a1596 1
C<application/x-www-form-urlencoded>.  See documentation for the
d1614 1
a1614 1
domain names encoded.  If the file already exists, the request will includes an
d1633 14
a1646 2
international domain names encoded.  A hashref of options may be appended to
modify the request.
d1654 1
a1654 1
headers
d1662 1
a1662 1
content
d1665 1
a1665 1
that will be called iteratively to produce the body of the response
d1669 1
a1669 1
trailer_callback
d1676 1
a1676 1
data_callback
d1687 3
d1704 1
a1704 1
success
d1710 9
a1718 1
status
d1724 1
a1724 1
reason
d1730 1
a1730 1
content
d1738 1
a1738 1
headers
d1758 2
a1759 2
reference.  The key/value pairs in the resulting string will be sorted by key
and value.
d1761 3
a1763 1
=for Pod::Coverage agent
d1765 4
d1771 1
d1774 122
d1930 2
a1931 2
Persistent connections are not supported.  The C<Connection> header will
always be set to C<close>.
d1935 1
a1935 4
Direct C<https> connections are supported only if L<IO::Socket::SSL> is
installed.  There is no support for C<https> connections via proxy.
Any SSL certificate that matches the host is accepted -- SSL certificates
are not verified against certificate authorities.
d1939 15
a1953 3
Cookies are not directly supported.  Users that set a C<Cookie> header
should also set C<max_redirect> to zero to ensure cookies are not
inappropriately re-transmitted.
d1957 1
a1957 3
Only the C<http_proxy> environment variable is supported in the format
C<http://HOST:PORT/>.  If a C<proxy> argument is passed to C<new> (including
undef), then the C<http_proxy> environment variable is ignored.
d1961 1
a1961 2
There is no provision for delaying a request body using an C<Expect> header.
Unexpected C<1XX> responses are silently ignored as per the specification.
d1965 1
a1965 1
Only 'chunked' C<Transfer-Encoding> is supported.
d1969 3
a1971 1
There is no support for a Request-URI of '*' for the 'OPTIONS' request.
d1973 1
a1973 1
=back
d1975 1
a1975 1
=head1 SEE ALSO
d1977 1
a1977 1
=over 4
d1981 1
a1981 1
L<LWP::UserAgent>
d1985 1
a1985 1
=for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders
d1992 1
a1992 1
at L<http://rt.cpan.org/Public/Dist/Display.html?Name=HTTP-Tiny>.
d2000 1
a2000 1
L<https://github.com/dagolden/p5-http-tiny>
d2002 1
a2002 1
  git clone https://github.com/dagolden/p5-http-tiny.git
d2018 82
d2102 1
a2102 1
This software is copyright (c) 2012 by Christian Hansen.
a2107 1

@


1.1.1.1
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@@


1.1.1.2
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d6 1
a6 1
our $VERSION = '0.025'; # VERSION
d13 1
a13 1
    @@attributes = qw(agent default_headers local_address max_redirect max_size proxy timeout SSL_options verify_SSL);
d24 1
a24 4

    (my $default_agent = $class) =~ s{::}{-}g;
    $default_agent .= "/" . ($class->VERSION || 0);

d26 1
a26 1
        agent        => $default_agent,
a28 1
        verify_SSL   => $args{verify_SSL} || $args{verify_ssl} || 0, # no verification by default
a29 4

    $args{agent} .= $default_agent
        if defined $args{agent} && $args{agent} =~ / $/;

a131 1
            url     => $url,
d193 1
a193 6
    my $handle  = HTTP::Tiny::Handle->new(
        timeout         => $self->{timeout},
        SSL_options     => $self->{SSL_options},
        verify_SSL      => $self->{verify_SSL},
        local_address   => $self->{local_address},
    );
a226 1
    $response->{url} = $url;
a404 2
        verify_SSL       => 0,
        SSL_options      => {},
d409 6
d420 4
a423 4
        die(qq/IO::Socket::SSL 1.56 must be installed for https support\n/)
            unless eval {require IO::Socket::SSL; IO::Socket::SSL->VERSION(1.56)};
        die(qq/Net::SSLeay 1.49 must be installed for https support\n/)
            unless eval {require Net::SSLeay; Net::SSLeay->VERSION(1.49)};
d428 1
a431 2
        $self->{local_address} ?
            ( LocalAddr => $self->{local_address} ) : (),
d441 5
a445 14
        my $ssl_args = $self->_ssl_args($host);
        IO::Socket::SSL->start_SSL(
            $self->{fh},
            %$ssl_args,
            SSL_create_ctx_callback => sub {
                my $ctx = shift;
                Net::SSLeay::CTX_set_mode($ctx, Net::SSLeay::MODE_AUTO_RETRY());
            },
        );

        unless ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
            my $ssl_err = IO::Socket::SSL->errstr;
            die(qq/SSL connection failed for $host: $ssl_err\n/);
        }
d488 1
a488 8
            if ($self->{fh}->can('errstr')){
                my $err = $self->{fh}->errstr();
                die (qq/Could not write to SSL socket: '$err'\n /);
            }
            else {
                die(qq/Could not write to socket: '$!'\n/);
            }

d516 1
a516 7
            if ($self->{fh}->can('errstr')){
                my $err = $self->{fh}->errstr();
                die (qq/Could not read from SSL socket: '$err'\n /);
            }
            else {
                die(qq/Could not read from socket: '$!'\n/);
            }
d543 1
a543 7
            if ($self->{fh}->can('errstr')){
                my $err = $self->{fh}->errstr();
                die (qq/Could not read from SSL socket: '$err'\n /);
            }
            else {
                die(qq/Could not read from socket: '$!'\n/);
            }
d830 1
a830 30
# Try to find a CA bundle to validate the SSL cert,
# prefer Mozilla::CA or fallback to a system file
sub _find_CA_file {
    my $self = shift();

    return $self->{SSL_options}->{SSL_ca_file}
        if $self->{SSL_options}->{SSL_ca_file} and -e $self->{SSL_options}->{SSL_ca_file};

    return Mozilla::CA::SSL_ca_file()
        if eval { require Mozilla::CA };

    foreach my $ca_bundle (qw{
        /etc/ssl/certs/ca-certificates.crt
        /etc/pki/tls/certs/ca-bundle.crt
        /etc/ssl/ca-bundle.pem
        }
    ) {
        return $ca_bundle if -e $ca_bundle;
    }

    die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/
      . qq/Try installing Mozilla::CA from CPAN\n/;
}

sub _ssl_args {
    my ($self, $host) = @@_;

    my %ssl_args = (
        SSL_hostname        => $host,  # SNI
    );
a831 10
    if ($self->{verify_SSL}) {
        $ssl_args{SSL_verifycn_scheme}  = 'http'; # enable CN validation
        $ssl_args{SSL_verifycn_name}    = $host;  # set validation hostname
        $ssl_args{SSL_verify_mode}      = 0x01;   # enable cert validation
        $ssl_args{SSL_ca_file}          = $self->_find_CA_file;
    }
    else {
        $ssl_args{SSL_verifycn_scheme}  = 'none'; # disable CN validation
        $ssl_args{SSL_verify_mode}      = 0x00;   # disable cert validation
    }
a832 9
    # user options override settings from verify_SSL
    for my $k ( keys %{$self->{SSL_options}} ) {
        $ssl_args{$k} = $self->{SSL_options}{$k} if $k =~ m/^SSL_/;
    }

    return \%ssl_args;
}

1;
a834 1

d843 1
a843 1
version 0.025
d886 1
a886 1
A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent> ends in a space character, the default user-agent string is appended.
a895 6
C<local_address>

The local IP address to bind to

=item *

a918 13
=item *

C<verify_SSL>

A boolean that indicates whether to validate the SSL certificate of an C<https>
connection (default is false)

=item *

C<SSL_options>

A hashref of C<SSL_*> options to pass through to L<IO::Socket::SSL>

a924 2
See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.

d990 1
a990 1
C<headers>
d998 1
a998 1
C<content>
d1001 1
a1001 1
that will be called iteratively to produce the body of the request
d1005 1
a1005 1
C<trailer_callback>
d1012 1
a1012 1
C<data_callback>
d1037 1
a1037 1
C<success>
d1043 1
a1043 9
C<url>

URL that provided the response. This is the URL of the request unless
there were redirections, in which case it is the last URL queried
in a redirection chain

=item *

C<status>
d1049 1
a1049 1
C<reason>
d1055 1
a1055 1
C<content>
d1063 1
a1063 1
C<headers>
a1087 1
local_address
a1091 85
verify_SSL
SSL_options

=head1 SSL SUPPORT

Direct C<https> connections are supported only if L<IO::Socket::SSL> 1.56 or
greater and L<Net::SSLeay> 1.49 or greater are installed. An exception will be
thrown if a new enough versions of these modules not installed or if the SSL
encryption fails. There is no support for C<https> connections via proxy (i.e.
RFC 2817).

SSL provides two distinct capabilities:

=over 4

=item *

Encrypted communication channel

=item *

Verification of server identity

=back

B<By default, HTTP::Tiny does not verify server identity>.

Server identity verification is controversial and potentially tricky because it
depends on a (usually paid) third-party Certificate Authority (CA) trust model
to validate a certificate as legitimate.  This discriminates against servers
with self-signed certificates or certificates signed by free, community-driven
CA's such as L<CAcert.org|http://cacert.org>.

By default, HTTP::Tiny does not make any assumptions about your trust model,
threat level or risk tolerance.  It just aims to give you an encrypted channel
when you need one.

Setting the C<verify_SSL> attribute to a true value will make HTTP::Tiny verify
that an SSL connection has a valid SSL certificate corresponding to the host
name of the connection and that the SSL certificate has been verified by a CA.
Assuming you trust the CA, this will protect against a L<man-in-the-middle
attack|http://en.wikipedia.org/wiki/Man-in-the-middle_attack>.  If you are
concerned about security, you should enable this option.

Certificate verification requires a file containing trusted CA certificates.
If the L<Mozilla::CA> module is installed, HTTP::Tiny will use the CA file
included with it as a source of trusted CA's.  (This means you trust Mozilla,
the author of Mozilla::CA, the CPAN mirror where you got Mozilla::CA, the
toolchain used to install it, and your operating system security, right?)

If that module is not available, then HTTP::Tiny will search several
system-specific default locations for a CA certificate file:

=over 4

=item *

/etc/ssl/certs/ca-certificates.crt

=item *

/etc/pki/tls/certs/ca-bundle.crt

=item *

/etc/ssl/ca-bundle.pem

=back

An exception will be raised if C<verify_SSL> is true and no CA certificate file
is available.

If you desire complete control over SSL connections, the C<SSL_options> attribute
lets you provide a hash reference that will be passed through to
C<IO::Socket::SSL::start_SSL()>, overriding any options set by HTTP::Tiny. For
example, to provide your own trusted CA file:

    SSL_options => {
        SSL_ca_file => $file_path,
    }

The C<SSL_options> attribute could also be used for such things as providing a
client certificate for authentication to a server or controlling the choice of
cipher used for the SSL connection. See L<IO::Socket::SSL> documentation for
details.
d1131 7
a1160 4
=item *

There is no support for IPv6 of any kind.

a1170 12
=item *

L<IO::Socket::SSL>

=item *

L<Mozilla::CA>

=item *

L<Net::SSLeay>

d1173 1
a1173 1
=for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
d1180 1
a1180 1
at L<https://rt.cpan.org/Public/Dist/Display.html?Name=HTTP-Tiny>.
d1188 1
a1188 1
L<https://github.com/dagolden/http-tiny>
d1190 1
a1190 1
  git clone git://github.com/dagolden/http-tiny.git
a1203 4
=item *

Mike Doherty <doherty@@cpan.org>

d1214 1
@


1.1.1.3
log
@Import perl-5.20.1
@
text
@d6 1
a6 1
our $VERSION = '0.043'; # VERSION
a9 50
# =method new
#
#     $http = HTTP::Tiny->new( %attributes );
#
# This constructor returns a new HTTP::Tiny object.  Valid attributes include:
#
# =for :list
# * C<agent>
# A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent> ends in a space character, the default user-agent string is appended.
# * C<cookie_jar>
# An instance of L<HTTP::CookieJar> or equivalent class that supports the C<add> and C<cookie_header> methods
# * C<default_headers>
# A hashref of default headers to apply to requests
# * C<local_address>
# The local IP address to bind to
# * C<keep_alive>
# Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)
# * C<max_redirect>
# Maximum number of redirects allowed (defaults to 5)
# * C<max_size>
# Maximum response size (only when not using a data callback).  If defined, responses larger than this will return an exception.
# * C<http_proxy>
# URL of a proxy server to use for HTTP connections (default is C<$ENV{http_proxy}> if set)
# * C<https_proxy>
# URL of a proxy server to use for HTTPS connections (default is C<$ENV{https_proxy}> if set)
# * C<proxy>
# URL of a generic proxy server for both HTTP and HTTPS connections (default is C<$ENV{all_proxy}> if set)
# * C<no_proxy>
# List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}>)
# * C<timeout>
# Request timeout in seconds (default is 60)
# * C<verify_SSL>
# A boolean that indicates whether to validate the SSL certificate of an C<https>
# connection (default is false)
# * C<SSL_options>
# A hashref of C<SSL_*> options to pass through to L<IO::Socket::SSL>
#
# Exceptions from C<max_size>, C<timeout> or other errors will result in a
# pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
# content field in the response will contain the text of the exception.
#
# The C<keep_alive> parameter enables a persistent connection, but only to a
# single destination scheme, host and port.  Also, if any connection-relevant
# attributes are modified, a persistent connection will be dropped.  If you want
# persistent connections across multiple destinations, use multiple HTTP::Tiny
# objects.
#
# See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
#
# =cut
d13 1
a13 8
    @@attributes = qw(
        cookie_jar default_headers http_proxy https_proxy keep_alive
        local_address max_redirect max_size proxy no_proxy timeout
        SSL_options verify_SSL
    );
    my %persist_ok = map {; $_ => 1 } qw(
        cookie_jar default_headers max_redirect max_size
    );
a14 1
    no warnings 'uninitialized';
d17 1
a17 6
            @@_ > 1
                ? do {
                    delete $_[0]->{handle} if !$persist_ok{$accessor} && $_[1] ne $_[0]->{$accessor};
                    $_[0]->{$accessor} = $_[1]
                }
                : $_[0]->{$accessor};
a21 9
sub agent {
    my($self, $agent) = @@_;
    if( @@_ > 1 ){
        $self->{agent} =
            (defined $agent && $agent =~ / $/) ? $agent . $self->_agent : $agent;
    }
    return $self->{agent};
}

d25 3
d29 1
a31 1
        keep_alive   => 1,
a32 1
        no_proxy     => $ENV{no_proxy},
d35 2
a36 3
    bless $self, $class;

    $class->_validate_cookie_jar( $args{cookie_jar} ) if $args{cookie_jar};
d42 4
a45 25
    $self->agent( exists $args{agent} ? $args{agent} : $class->_agent );

    $self->_set_proxies;

    return $self;
}

sub _set_proxies {
    my ($self) = @@_;

    if (! $self->{proxy} ) {
        $self->{proxy} = $ENV{all_proxy} || $ENV{ALL_PROXY};
        if ( defined $self->{proxy} ) {
            $self->_split_proxy( 'generic proxy' => $self->{proxy} ); # validate
        }
        else {
            delete $self->{proxy};
        }
    }

    if (! $self->{http_proxy} ) {
        $self->{http_proxy} = $ENV{http_proxy} || $self->{proxy};
        if ( defined $self->{http_proxy} ) {
            $self->_split_proxy( http_proxy => $self->{http_proxy} ); # validate
            $self->{_has_proxy}{http} = 1;
d48 1
a48 9
            delete $self->{http_proxy};
        }
    }

    if (! $self->{https_proxy} ) {
        $self->{https_proxy} = $ENV{https_proxy} || $ENV{HTTPS_PROXY} || $self->{proxy};
        if ( $self->{https_proxy} ) {
            $self->_split_proxy( https_proxy => $self->{https_proxy} ); # validate
            $self->{_has_proxy}{https} = 1;
a49 9
        else {
            delete $self->{https_proxy};
        }
    }

    # Split no_proxy to array reference if not provided as such
    unless ( ref $self->{no_proxy} eq 'ARRAY' ) {
        $self->{no_proxy} =
            (defined $self->{no_proxy}) ? [ split /\s*,\s*/, $self->{no_proxy} ] : [];
d52 1
a52 1
    return;
a54 13
# =method get|head|put|post|delete
#
#     $response = $http->get($url);
#     $response = $http->get($url, \%options);
#     $response = $http->head($url);
#
# These methods are shorthand for calling C<request()> for the given method.  The
# URL must have unsafe characters escaped and international domain names encoded.
# See C<request()> for valid options and a description of the response.
#
# The C<success> field of the response will be true if the status code is 2XX.
#
# =cut
a68 19
# =method post_form
#
#     $response = $http->post_form($url, $form_data);
#     $response = $http->post_form($url, $form_data, \%options);
#
# This method executes a C<POST> request and sends the key/value pairs from a
# form data hash or array reference to the given URL with a C<content-type> of
# C<application/x-www-form-urlencoded>.  If data is provided as an array
# reference, the order is preserved; if provided as a hash reference, the terms
# are sorted on key and value for consistency.  See documentation for the
# C<www_form_urlencode> method for details on the encoding.
#
# The URL must have unsafe characters escaped and international domain names
# encoded.  See C<request()> for valid options and a description of the response.
# Any C<content-type> header or content in the options hashref will be ignored.
#
# The C<success> field of the response will be true if the status code is 2XX.
#
# =cut
a91 22
# =method mirror
#
#     $response = $http->mirror($url, $file, \%options)
#     if ( $response->{success} ) {
#         print "$file is up to date\n";
#     }
#
# Executes a C<GET> request for the URL and saves the response body to the file
# name provided.  The URL must have unsafe characters escaped and international
# domain names encoded.  If the file already exists, the request will include an
# C<If-Modified-Since> header with the modification timestamp of the file.  You
# may specify a different C<If-Modified-Since> header yourself in the C<<
# $options->{headers} >> hash.
#
# The C<success> field of the response will be true if the status code is 2XX
# or if the status code is 304 (unmodified).
#
# If the file was modified and the server response includes a properly
# formatted C<Last-Modified> header, the file modification time will
# be updated accordingly.
#
# =cut
d101 2
a102 4

    require Fcntl;
    sysopen my $fh, $tempfile, Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()
       or Carp::croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);
d107 1
a107 2
        or Carp::croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);

a120 80
# =method request
#
#     $response = $http->request($method, $url);
#     $response = $http->request($method, $url, \%options);
#
# Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
# 'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
# international domain names encoded.
#
# If the URL includes a "user:password" stanza, they will be used for Basic-style
# authorization headers.  (Authorization headers will not be included in a
# redirected request.) For example:
#
#     $http->request('GET', 'http://Aladdin:open sesame@@example.com/');
#
# If the "user:password" stanza contains reserved characters, they must
# be percent-escaped:
#
#     $http->request('GET', 'http://john%40example.com:password@@example.com/');
#
# A hashref of options may be appended to modify the request.
#
# Valid options are:
#
# =for :list
# * C<headers>
# A hashref containing headers to include with the request.  If the value for
# a header is an array reference, the header will be output multiple times with
# each value in the array.  These headers over-write any default headers.
# * C<content>
# A scalar to include as the body of the request OR a code reference
# that will be called iteratively to produce the body of the request
# * C<trailer_callback>
# A code reference that will be called if it exists to provide a hashref
# of trailing headers (only used with chunked transfer-encoding)
# * C<data_callback>
# A code reference that will be called for each chunks of the response
# body received.
#
# If the C<content> option is a code reference, it will be called iteratively
# to provide the content body of the request.  It should return the empty
# string or undef when the iterator is exhausted.
#
# If the C<content> option is the empty string, no C<content-type> or
# C<content-length> headers will be generated.
#
# If the C<data_callback> option is provided, it will be called iteratively until
# the entire response body is received.  The first argument will be a string
# containing a chunk of the response body, the second argument will be the
# in-progress response hash reference, as described below.  (This allows
# customizing the action of the callback based on the C<status> or C<headers>
# received prior to the content body.)
#
# The C<request> method returns a hashref containing the response.  The hashref
# will have the following keys:
#
# =for :list
# * C<success>
# Boolean indicating whether the operation returned a 2XX status code
# * C<url>
# URL that provided the response. This is the URL of the request unless
# there were redirections, in which case it is the last URL queried
# in a redirection chain
# * C<status>
# The HTTP status code of the response
# * C<reason>
# The response phrase returned by the server
# * C<content>
# The body of the response.  If the response does not have any content
# or if a data callback is provided to consume the response body,
# this will be the empty string
# * C<headers>
# A hashref of header fields.  All header field names will be normalized
# to be lower case. If a header is repeated, the value will be an arrayref;
# it will otherwise be a scalar string containing the value
#
# On an exception during the execution of the request, the C<status> field will
# contain 599, and the C<content> field will contain the text of the exception.
#
# =cut
d138 1
a138 8
    if (my $e = $@@) {
        # maybe we got a response hash thrown from somewhere deep
        if ( ref $e eq 'HASH' && exists $e->{status} ) {
            return $e;
        }

        # otherwise, stringify it
        $e = "$e";
a153 13
# =method www_form_urlencode
#
#     $params = $http->www_form_urlencode( $data );
#     $response = $http->get("http://example.com/query?$params");
#
# This method converts the key/value pairs from a data hash or array reference
# into a C<x-www-form-urlencoded> string.  The keys and values from the data
# reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
# array reference, the key will be repeated with each of the values of the array
# reference.  If data is provided as a hash reference, the key/value pairs in the
# resulting string will be sorted by key and value for consistent ordering.
#
# =cut
d160 1
a160 1
        or Carp::croak("form data must be a hash or array reference\n");
d177 1
a177 1
    return join("&", (ref $data eq 'ARRAY') ? (@@terms) : (sort @@terms) );
a188 6
sub _agent {
    my $class = ref($_[0]) || $_[0];
    (my $default_agent = $class) =~ s{::}{-}g;
    return $default_agent . "/" . ($class->VERSION || 0);
}

d192 1
a192 1
    my ($scheme, $host, $port, $path_query, $auth) = $self->_split_url($url);
a196 1
        host      => $host,
d202 15
a216 9
    # We remove the cached handle so it is not reused in the case of redirect.
    # If all is well, it will be recached at the end of _request.  We only
    # reuse for the same scheme, host and port
    my $handle = delete $self->{handle};
    if ( $handle ) {
        unless ( $handle->can_reuse( $scheme, $host, $port ) ) {
            $handle->close;
            undef $handle;
        }
a217 1
    $handle ||= $self->_open_handle( $request, $scheme, $host, $port );
d219 1
a219 1
    $self->_prepare_headers_and_cb($request, $args, $url, $auth);
a225 2
    $self->_update_cookie_jar( $url, $response ) if $self->{cookie_jar};

a230 1
    my $known_message_length;
a232 1
        $known_message_length = 1;
d236 1
a236 1
        $known_message_length = $handle->read_body($data_cb, $response);
d239 2
a240 12
    if ( $self->{keep_alive}
        && $known_message_length
        && $response->{protocol} eq 'HTTP/1.1'
        && ($response->{headers}{connection} || '') ne 'close'
    ) {
        $self->{handle} = $handle;
    }
    else {
        $handle->close;
    }

    $response->{success} = substr( $response->{status}, 0, 1 ) eq '2';
a244 108
sub _open_handle {
    my ($self, $request, $scheme, $host, $port) = @@_;

    my $handle  = HTTP::Tiny::Handle->new(
        timeout         => $self->{timeout},
        SSL_options     => $self->{SSL_options},
        verify_SSL      => $self->{verify_SSL},
        local_address   => $self->{local_address},
        keep_alive      => $self->{keep_alive}
    );

    if ($self->{_has_proxy}{$scheme} && ! grep { $host =~ /\Q$_\E$/ } @@{$self->{no_proxy}}) {
        return $self->_proxy_connect( $request, $handle );
    }
    else {
        return $handle->connect($scheme, $host, $port);
    }
}

sub _proxy_connect {
    my ($self, $request, $handle) = @@_;

    my @@proxy_vars;
    if ( $request->{scheme} eq 'https' ) {
        Carp::croak(qq{No https_proxy defined}) unless $self->{https_proxy};
        @@proxy_vars = $self->_split_proxy( https_proxy => $self->{https_proxy} );
        if ( $proxy_vars[0] eq 'https' ) {
            Carp::croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}});
        }
    }
    else {
        Carp::croak(qq{No http_proxy defined}) unless $self->{http_proxy};
        @@proxy_vars = $self->_split_proxy( http_proxy => $self->{http_proxy} );
    }

    my ($p_scheme, $p_host, $p_port, $p_auth) = @@proxy_vars;

    if ( length $p_auth && ! defined $request->{headers}{'proxy-authorization'} ) {
        $self->_add_basic_auth_header( $request, 'proxy-authorization' => $p_auth );
    }

    $handle->connect($p_scheme, $p_host, $p_port);

    if ($request->{scheme} eq 'https') {
        $self->_create_proxy_tunnel( $request, $handle );
    }
    else {
        # non-tunneled proxy requires absolute URI
        $request->{uri} = "$request->{scheme}://$request->{host_port}$request->{uri}";
    }

    return $handle;
}

sub _split_proxy {
    my ($self, $type, $proxy) = @@_;

    my ($scheme, $host, $port, $path_query, $auth) = eval { $self->_split_url($proxy) };

    unless(
        defined($scheme) && length($scheme) && length($host) && length($port)
        && $path_query eq '/'
    ) {
        Carp::croak(qq{$type URL must be in format http[s]://[auth@@]<host>:<port>/\n});
    }

    return ($scheme, $host, $port, $auth);
}

sub _create_proxy_tunnel {
    my ($self, $request, $handle) = @@_;

    $handle->_assert_ssl;

    my $agent = exists($request->{headers}{'user-agent'})
        ? $request->{headers}{'user-agent'} : $self->{agent};

    my $connect_request = {
        method    => 'CONNECT',
        uri       => $request->{host_port},
        headers   => {
            host => $request->{host_port},
            'user-agent' => $agent,
        }
    };

    if ( $request->{headers}{'proxy-authorization'} ) {
        $connect_request->{headers}{'proxy-authorization'} =
            delete $request->{headers}{'proxy-authorization'};
    }

    $handle->write_request($connect_request);
    my $response;
    do { $response = $handle->read_response_header }
        until (substr($response->{status},0,1) ne '1');

    # if CONNECT failed, throw the response so it will be
    # returned from the original request() method;
    unless (substr($response->{status},0,1) eq '2') {
        die $response;
    }

    # tunnel established, so start SSL handshake
    $handle->start_ssl( $request->{host} );

    return;
}

d246 1
a246 1
    my ($self, $request, $args, $url, $auth) = @@_;
d255 1
a256 2
    $request->{headers}{'connection'}   = "close"
        unless $self->{keep_alive};
d258 2
a259 1
    if ( defined $args->{content} ) {
a260 1
            $request->{headers}{'content-type'} ||= "application/octet-stream";
d266 1
a266 1
        elsif ( length $args->{content} ) {
a271 1
            $request->{headers}{'content-type'} ||= "application/octet-stream";
a279 20

    ### If we have a cookie jar, then maybe add relevant cookies
    if ( $self->{cookie_jar} ) {
        my $cookies = $self->cookie_jar->cookie_header( $url );
        $request->{headers}{cookie} = $cookies if length $cookies;
    }

    # if we have Basic auth parameters, add them
    if ( length $auth && ! defined $request->{headers}{authorization} ) {
        $self->_add_basic_auth_header( $request, 'authorization' => $auth );
    }

    return;
}

sub _add_basic_auth_header {
    my ($self, $request, $header, $auth) = @@_;
    require MIME::Base64;
    $request->{headers}{$header} =
        "Basic " . MIME::Base64::encode_base64($auth, "");
a302 25
sub _update_cookie_jar {
    my ($self, $url, $response) = @@_;

    my $cookies = $response->{headers}->{'set-cookie'};
    return unless defined $cookies;

    my @@cookies = ref $cookies ? @@$cookies : $cookies;

    $self->cookie_jar->add( $url, $_ ) for @@cookies;

    return;
}

sub _validate_cookie_jar {
    my ($class, $jar) = @@_;

    # duck typing
    for my $method ( qw/add cookie_header/ ) {
        Carp::croak(qq/Cookie jar must provide the '$method' method\n/)
            unless ref($jar) && ref($jar)->can($method);
    }

    return;
}

d329 2
a330 12
    my ($auth,$host);
    $authority = (length($authority)) ? $authority : 'localhost';
    if ( $authority =~ /@@/ ) {
        ($auth,$host) = $authority =~ m/\A([^@@]*)@@(.*)\z/;   # user:pass@@host
        # userinfo might be percent escaped, so recover real auth info
        $auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
    }
    else {
        $host = $authority;
        $auth = '';
    }
    $host = lc $host;
d337 1
a337 1
    return ($scheme, $host, $port, $path_query, $auth);
a399 8
# PERL_HTTP_TINY_IPV4_ONLY is a private environment variable to force old
# behavior if someone is unable to boostrap CPAN from a new perl install; it is
# not intended for general, per-client use and may be removed in the future
my $SOCKET_CLASS =
    $ENV{PERL_HTTP_TINY_IPV4_ONLY} ? 'IO::Socket::INET' :
    eval { require IO::Socket::IP; IO::Socket::IP->VERSION(0.25) } ? 'IO::Socket::IP' :
    'IO::Socket::INET';

d431 4
a434 1
        $self->_assert_ssl;
d439 1
a439 1
    $self->{fh} = $SOCKET_CLASS->new(
d446 1
a446 2
        Timeout   => $self->{timeout},
        KeepAlive => !!$self->{keep_alive}
d452 10
a461 5
    $self->start_ssl($host) if $scheme eq 'https';

    $self->{scheme} = $scheme;
    $self->{host} = $host;
    $self->{port} = $port;
d463 1
a463 11
    return $self;
}

sub start_ssl {
    my ($self, $host) = @@_;

    # As this might be used via CONNECT after an SSL session
    # to a proxy, we shut down any existing SSL before attempting
    # the handshake
    if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
        unless ( $self->{fh}->stop_SSL ) {
d465 1
a465 1
            die(qq/Error halting prior SSL connection: $ssl_err/);
d469 2
a470 9
    my $ssl_args = $self->_ssl_args($host);
    IO::Socket::SSL->start_SSL(
        $self->{fh},
        %$ssl_args,
        SSL_create_ctx_callback => sub {
            my $ctx = shift;
            Net::SSLeay::CTX_set_mode($ctx, Net::SSLeay::MODE_AUTO_RETRY());
        },
    );
d472 1
a472 4
    unless ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
        my $ssl_err = IO::Socket::SSL->errstr;
        die(qq/SSL connection failed for $host: $ssl_err\n/);
    }
a647 2
# to avoid multiple small writes and hence nagle, you can pass the method line or anything else to
# combine writes.
d649 2
a650 2
    (@@_ == 2 || @@_ == 3 && ref $_[1] eq 'HASH') || die(q/Usage: $handle->write_header_lines(headers[,prefix])/ . "\n");
    my($self, $headers, $prefix_data) = @@_;
d652 1
a652 1
    my $buf = (defined $prefix_data ? $prefix_data : '');
a673 3
# return value indicates whether message length was defined; this is generally
# true unless there was no content-length header and we just read until EOF.
# Other message length errors are thrown as exceptions
d678 7
a684 4
    my $chunked = grep { /chunked/i } ( ref $te eq 'ARRAY' ? @@$te : $te ) ;
    return $chunked
        ? $self->read_chunked_body($cb, $response)
        : $self->read_content_body($cb, $response);
d703 1
a703 1
    if ( defined $content_length ) {
a709 1
        return length($self->{rbuf}) == 0;
d711 4
a714 3

    my $chunk;
    $cb->($chunk, $response) while length( $chunk = $self->read(BUFSIZE, 1) );
d763 1
a763 1
    return 1;
d812 4
a815 4
        status       => $status,
        reason       => $reason,
        headers      => $self->read_header_lines,
        protocol     => $protocol,
d823 2
a824 1
    return $self->write_header_lines($headers, "$method $request_uri HTTP/1.1\x0D\x0A");
a860 3
    if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
        return 1 if $self->{fh}->pending;
    }
a869 21
sub _assert_ssl {
    # Need IO::Socket::SSL 1.42 for SSL_create_ctx_callback
    die(qq/IO::Socket::SSL 1.42 must be installed for https support\n/)
        unless eval {require IO::Socket::SSL; IO::Socket::SSL->VERSION(1.42)};
    # Need Net::SSLeay 1.49 for MODE_AUTO_RETRY
    die(qq/Net::SSLeay 1.49 must be installed for https support\n/)
        unless eval {require Net::SSLeay; Net::SSLeay->VERSION(1.49)};
}

sub can_reuse {
    my ($self,$scheme,$host,$port) = @@_;
    return 0 if
         length($self->{rbuf})
        || $scheme ne $self->{scheme}
        || $host ne $self->{host}
        || $port ne $self->{port}
        || eval { $self->can_read(0) }
        || $@@ ;
        return 1;
}

d897 3
a899 7
    my %ssl_args;

    # This test reimplements IO::Socket::SSL::can_client_sni(), which wasn't
    # added until IO::Socket::SSL 1.84
    if ( Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x01000000 ) {
        $ssl_args{SSL_hostname} = $host,          # Sane SNI support
    }
a925 2
=encoding UTF-8

d932 1
a932 1
version 0.043
d954 1
a954 1
This is a very simple HTTP/1.1 client, designed for doing simple
d958 2
a959 6
proxies and redirection.  It also correctly resumes after EINTR.

If L<IO::Socket::IP> 0.25 or later is installed, HTTP::Tiny will use it instead
of L<IO::Socket::INET> for transparent support for both IPv4 and IPv6.

Cookie support requires L<HTTP::CookieJar> or an equivalent class.
a978 6
C<cookie_jar>

An instance of L<HTTP::CookieJar> or equivalent class that supports the C<add> and C<cookie_header> methods

=item *

a990 6
C<keep_alive>

Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)

=item *

d999 2
a1000 13
Maximum response size (only when not using a data callback).  If defined, responses larger than this will return an exception.

=item *

C<http_proxy>

URL of a proxy server to use for HTTP connections (default is C<$ENV{http_proxy}> if set)

=item *

C<https_proxy>

URL of a proxy server to use for HTTPS connections (default is C<$ENV{https_proxy}> if set)
d1006 1
a1006 7
URL of a generic proxy server for both HTTP and HTTPS connections (default is C<$ENV{all_proxy}> if set)

=item *

C<no_proxy>

List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}>)
a1032 6
The C<keep_alive> parameter enables a persistent connection, but only to a
single destination scheme, host and port.  Also, if any connection-relevant
attributes are modified, a persistent connection will be dropped.  If you want
persistent connections across multiple destinations, use multiple HTTP::Tiny
objects.

d1054 1
a1054 3
C<application/x-www-form-urlencoded>.  If data is provided as an array
reference, the order is preserved; if provided as a hash reference, the terms
are sorted on key and value for consistency.  See documentation for the
d1072 1
a1072 1
domain names encoded.  If the file already exists, the request will include an
d1091 2
a1092 14
international domain names encoded.

If the URL includes a "user:password" stanza, they will be used for Basic-style
authorization headers.  (Authorization headers will not be included in a
redirected request.) For example:

    $http->request('GET', 'http://Aladdin:open sesame@@example.com/');

If the "user:password" stanza contains reserved characters, they must
be percent-escaped:

    $http->request('GET', 'http://john%40example.com:password@@example.com/');

A hashref of options may be appended to modify the request.
a1132 3
If the C<content> option is the empty string, no C<content-type> or
C<content-length> headers will be generated.

d1201 2
a1202 2
reference.  If data is provided as a hash reference, the key/value pairs in the
resulting string will be sorted by key and value for consistent ordering.
d1204 1
a1204 3
=for Pod::Coverage SSL_options
agent
cookie_jar
a1205 3
http_proxy
https_proxy
keep_alive
a1208 1
no_proxy
d1212 1
d1219 2
a1220 3
encryption fails. An C<https> connection may be made via an C<http> proxy that
supports the CONNECT command (i.e. RFC 2817).  You may not proxy C<https> via
a proxy that itself requires C<https> to communicate.
a1296 37
=head1 PROXY SUPPORT

HTTP::Tiny can proxy both C<http> and C<https> requests.  Only Basic proxy
authorization is supported and it must be provided as part of the proxy URL:
C<http://user:pass@@proxy.example.com/>.

HTTP::Tiny supports the following proxy environment variables:

=over 4

=item *

http_proxy

=item *

https_proxy or HTTPS_PROXY

=item *

all_proxy or ALL_PROXY

=back

Tunnelling C<https> over an C<http> proxy using the CONNECT method is
supported.  If your proxy uses C<https> itself, you can not tunnel C<https>
over it.

Be warned that proxying an C<https> connection opens you to the risk of a
man-in-the-middle attack by the proxy server.

The C<no_proxy> environment variable is supported in the format of a
comma-separated list of domain extensions proxy should not be used for.

Proxy arguments passed to C<new> will override their corresponding
environment variables.

d1330 2
a1331 2
There is no provision for delaying a request body using an C<Expect> header.
Unexpected C<1XX> responses are silently ignored as per the specification.
d1335 3
a1337 1
Only 'chunked' C<Transfer-Encoding> is supported.
d1341 3
a1343 1
There is no support for a Request-URI of '*' for the 'OPTIONS' request.
d1345 1
a1345 1
=back
d1347 2
a1348 3
Despite the limitations listed above, HTTP::Tiny is considered
feature-complete.  New feature requests should be directed to
L<HTTP::Tiny::UA>.
d1350 1
a1350 1
=head1 SEE ALSO
d1352 1
a1352 1
=over 4
d1356 1
a1356 1
L<HTTP::Tiny::UA> - Higher level UA features for HTTP::Tiny
d1360 1
a1360 1
L<HTTP::Thin> - HTTP::Tiny wrapper with L<HTTP::Request>/L<HTTP::Response> compatibility
d1362 1
a1362 1
=item *
d1364 1
a1364 1
L<HTTP::Tiny::Mech> - Wrap L<WWW::Mechanize> instance in HTTP::Tiny compatible interface
d1366 1
a1366 3
=item *

L<IO::Socket::IP> - Required for IPv6 support
d1370 1
a1370 1
L<IO::Socket::SSL> - Required for SSL support
d1374 1
a1374 1
L<LWP::UserAgent> - If HTTP::Tiny isn't enough for you, this is the "standard" way to do things
d1378 1
a1378 1
L<Mozilla::CA> - Required if you want to validate SSL certificates
d1382 1
a1382 1
L<Net::SSLeay> - Required for SSL support
d1393 1
a1393 1
at L<https://github.com/chansen/p5-http-tiny/issues>.
d1401 1
a1401 1
L<https://github.com/chansen/p5-http-tiny>
d1403 1
a1403 1
  git clone https://github.com/chansen/p5-http-tiny.git
a1416 62
=back

=head1 CONTRIBUTORS

=over 4

=item *

Alan Gardner <gardner@@pythian.com>

=item *

Alessandro Ghedini <al3xbio@@gmail.com>

=item *

Brad Gilbert <bgills@@cpan.org>

=item *

Chris Nehren <apeiron@@cpan.org>

=item *

Chris Weyl <cweyl@@alumni.drew.edu>

=item *

Claes Jakobsson <claes@@surfar.nu>

=item *

Clinton Gormley <clint@@traveljury.com>

=item *

Craig Berry <cberry@@cpan.org>

=item *

David Mitchell <davem@@iabyn.com>

=item *

Edward Zborowski <ed@@rubensteintech.com>

=item *

Jess Robinson <castaway@@desert-island.me.uk>

=item *

Lukas Eklund <leklund@@gmail.com>

=item *

Martin J. Evans <mjegh@@ntlworld.com>

=item *

Martin-Louis Bright <mlbright@@gmail.com>

a1420 16
=item *

Petr Písař <ppisar@@redhat.com>

=item *

Serguei Trouchelle <stro@@cpan.org>

=item *

Syohei YOSHIDA <syohex@@gmail.com>

=item *

Tony Cook <tony@@develop-help.com>

d1425 1
a1425 1
This software is copyright (c) 2014 by Christian Hansen.
@


1.1.1.4
log
@Import perl-5.24.2
@
text
@d6 1
a6 2

our $VERSION = '0.056_001';
d10 50
a59 53
#pod =method new
#pod
#pod     $http = HTTP::Tiny->new( %attributes );
#pod
#pod This constructor returns a new HTTP::Tiny object.  Valid attributes include:
#pod
#pod =for :list
#pod * C<agent> —
#pod     A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent> — ends in a space character, the default user-agent string is appended.
#pod * C<cookie_jar> —
#pod     An instance of L<HTTP::CookieJar> — or equivalent class that supports the C<add> and C<cookie_header> methods
#pod * C<default_headers> —
#pod     A hashref of default headers to apply to requests
#pod * C<local_address> —
#pod     The local IP address to bind to
#pod * C<keep_alive> —
#pod     Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)
#pod * C<max_redirect> —
#pod     Maximum number of redirects allowed (defaults to 5)
#pod * C<max_size> —
#pod     Maximum response size in bytes (only when not using a data callback).  If defined, responses larger than this will return an exception.
#pod * C<http_proxy> —
#pod     URL of a proxy server to use for HTTP connections (default is C<$ENV{http_proxy}> — if set)
#pod * C<https_proxy> —
#pod     URL of a proxy server to use for HTTPS connections (default is C<$ENV{https_proxy}> — if set)
#pod * C<proxy> —
#pod     URL of a generic proxy server for both HTTP and HTTPS connections (default is C<$ENV{all_proxy}> — if set)
#pod * C<no_proxy> —
#pod     List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}> —)
#pod * C<timeout> —
#pod     Request timeout in seconds (default is 60)
#pod * C<verify_SSL> —
#pod     A boolean that indicates whether to validate the SSL certificate of an C<https> —
#pod     connection (default is false)
#pod * C<SSL_options> —
#pod     A hashref of C<SSL_*> — options to pass through to L<IO::Socket::SSL>
#pod
#pod Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
#pod prevent getting the corresponding proxies from the environment.
#pod
#pod Exceptions from C<max_size>, C<timeout> or other errors will result in a
#pod pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
#pod content field in the response will contain the text of the exception.
#pod
#pod The C<keep_alive> parameter enables a persistent connection, but only to a
#pod single destination scheme, host and port.  Also, if any connection-relevant
#pod attributes are modified, or if the process ID or thread ID change, the
#pod persistent connection will be dropped.  If you want persistent connections
#pod across multiple destinations, use multiple HTTP::Tiny objects.
#pod
#pod See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
#pod
#pod =cut
d123 1
a123 5
    # get proxies from %ENV only if not provided; explicit undef will disable
    # getting proxies from the environment

    # generic proxy
    if (! exists $self->{proxy} ) {
d125 6
d133 9
a141 20
    if ( defined $self->{proxy} ) {
        $self->_split_proxy( 'generic proxy' => $self->{proxy} ); # validate
    }
    else {
        delete $self->{proxy};
    }

    # http proxy
    if (! exists $self->{http_proxy} ) {
        # under CGI, bypass HTTP_PROXY as request sets it from Proxy header
        local $ENV{HTTP_PROXY} if $ENV{REQUEST_METHOD};
        $self->{http_proxy} = $ENV{http_proxy} || $ENV{HTTP_PROXY} || $self->{proxy};
    }

    if ( defined $self->{http_proxy} ) {
        $self->_split_proxy( http_proxy => $self->{http_proxy} ); # validate
        $self->{_has_proxy}{http} = 1;
    }
    else {
        delete $self->{http_proxy};
d144 1
a144 2
    # https proxy
    if (! exists $self->{https_proxy} ) {
d146 7
a152 8
    }

    if ( $self->{https_proxy} ) {
        $self->_split_proxy( https_proxy => $self->{https_proxy} ); # validate
        $self->{_has_proxy}{https} = 1;
    }
    else {
        delete $self->{https_proxy};
d164 13
a176 13
#pod =method get|head|put|post|delete
#pod
#pod     $response = $http->get($url);
#pod     $response = $http->get($url, \%options);
#pod     $response = $http->head($url);
#pod
#pod These methods are shorthand for calling C<request()> for the given method.  The
#pod URL must have unsafe characters escaped and international domain names encoded.
#pod See C<request()> for valid options and a description of the response.
#pod
#pod The C<success> field of the response will be true if the status code is 2XX.
#pod
#pod =cut
d191 19
a209 19
#pod =method post_form
#pod
#pod     $response = $http->post_form($url, $form_data);
#pod     $response = $http->post_form($url, $form_data, \%options);
#pod
#pod This method executes a C<POST> request and sends the key/value pairs from a
#pod form data hash or array reference to the given URL with a C<content-type> of
#pod C<application/x-www-form-urlencoded>.  If data is provided as an array
#pod reference, the order is preserved; if provided as a hash reference, the terms
#pod are sorted on key and value for consistency.  See documentation for the
#pod C<www_form_urlencode> method for details on the encoding.
#pod
#pod The URL must have unsafe characters escaped and international domain names
#pod encoded.  See C<request()> for valid options and a description of the response.
#pod Any C<content-type> header or content in the options hashref will be ignored.
#pod
#pod The C<success> field of the response will be true if the status code is 2XX.
#pod
#pod =cut
d233 22
a254 22
#pod =method mirror
#pod
#pod     $response = $http->mirror($url, $file, \%options)
#pod     if ( $response->{success} ) {
#pod         print "$file is up to date\n";
#pod     }
#pod
#pod Executes a C<GET> request for the URL and saves the response body to the file
#pod name provided.  The URL must have unsafe characters escaped and international
#pod domain names encoded.  If the file already exists, the request will include an
#pod C<If-Modified-Since> header with the modification timestamp of the file.  You
#pod may specify a different C<If-Modified-Since> header yourself in the C<<
#pod $options->{headers} >> hash.
#pod
#pod The C<success> field of the response will be true if the status code is 2XX
#pod or if the status code is 304 (unmodified).
#pod
#pod If the file was modified and the server response includes a properly
#pod formatted C<Last-Modified> header, the file modification time will
#pod be updated accordingly.
#pod
#pod =cut
d287 80
a366 84
#pod =method request
#pod
#pod     $response = $http->request($method, $url);
#pod     $response = $http->request($method, $url, \%options);
#pod
#pod Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
#pod 'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
#pod international domain names encoded.
#pod
#pod If the URL includes a "user:password" stanza, they will be used for Basic-style
#pod authorization headers.  (Authorization headers will not be included in a
#pod redirected request.) For example:
#pod
#pod     $http->request('GET', 'http://Aladdin:open sesame@@example.com/');
#pod
#pod If the "user:password" stanza contains reserved characters, they must
#pod be percent-escaped:
#pod
#pod     $http->request('GET', 'http://john%40example.com:password@@example.com/');
#pod
#pod A hashref of options may be appended to modify the request.
#pod
#pod Valid options are:
#pod
#pod =for :list
#pod * C<headers> —
#pod     A hashref containing headers to include with the request.  If the value for
#pod     a header is an array reference, the header will be output multiple times with
#pod     each value in the array.  These headers over-write any default headers.
#pod * C<content> —
#pod     A scalar to include as the body of the request OR a code reference
#pod     that will be called iteratively to produce the body of the request
#pod * C<trailer_callback> —
#pod     A code reference that will be called if it exists to provide a hashref
#pod     of trailing headers (only used with chunked transfer-encoding)
#pod * C<data_callback> —
#pod     A code reference that will be called for each chunks of the response
#pod     body received.
#pod
#pod The C<Host> header is generated from the URL in accordance with RFC 2616.  It
#pod is a fatal error to specify C<Host> in the C<headers> option.  Other headers
#pod may be ignored or overwritten if necessary for transport compliance.
#pod
#pod If the C<content> option is a code reference, it will be called iteratively
#pod to provide the content body of the request.  It should return the empty
#pod string or undef when the iterator is exhausted.
#pod
#pod If the C<content> option is the empty string, no C<content-type> or
#pod C<content-length> headers will be generated.
#pod
#pod If the C<data_callback> option is provided, it will be called iteratively until
#pod the entire response body is received.  The first argument will be a string
#pod containing a chunk of the response body, the second argument will be the
#pod in-progress response hash reference, as described below.  (This allows
#pod customizing the action of the callback based on the C<status> or C<headers>
#pod received prior to the content body.)
#pod
#pod The C<request> method returns a hashref containing the response.  The hashref
#pod will have the following keys:
#pod
#pod =for :list
#pod * C<success> —
#pod     Boolean indicating whether the operation returned a 2XX status code
#pod * C<url> —
#pod     URL that provided the response. This is the URL of the request unless
#pod     there were redirections, in which case it is the last URL queried
#pod     in a redirection chain
#pod * C<status> —
#pod     The HTTP status code of the response
#pod * C<reason> —
#pod     The response phrase returned by the server
#pod * C<content> —
#pod     The body of the response.  If the response does not have any content
#pod     or if a data callback is provided to consume the response body,
#pod     this will be the empty string
#pod * C<headers> —
#pod     A hashref of header fields.  All header field names will be normalized
#pod     to be lower case. If a header is repeated, the value will be an arrayref;
#pod     it will otherwise be a scalar string containing the value
#pod
#pod On an exception during the execution of the request, the C<status> field will
#pod contain 599, and the C<content> field will contain the text of the exception.
#pod
#pod =cut
d407 13
a419 13
#pod =method www_form_urlencode
#pod
#pod     $params = $http->www_form_urlencode( $data );
#pod     $response = $http->get("http://example.com/query?$params");
#pod
#pod This method converts the key/value pairs from a data hash or array reference
#pod into a C<x-www-form-urlencoded> string.  The keys and values from the data
#pod reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
#pod array reference, the key will be repeated with each of the values of the array
#pod reference.  If data is provided as a hash reference, the key/value pairs in the
#pod resulting string will be sorted by key and value for consistent ordering.
#pod
#pod =cut
a445 51
#pod =method can_ssl
#pod
#pod     $ok         = HTTP::Tiny->can_ssl;
#pod     ($ok, $why) = HTTP::Tiny->can_ssl;
#pod     ($ok, $why) = $http->can_ssl;
#pod
#pod Indicates if SSL support is available.  When called as a class object, it
#pod checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
#pod When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
#pod is set in C<SSL_options>, it checks that a CA file is available.
#pod
#pod In scalar context, returns a boolean indicating if SSL is available.
#pod In list context, returns the boolean and a (possibly multi-line) string of
#pod errors indicating why SSL isn't available.
#pod
#pod =cut

sub can_ssl {
    my ($self) = @@_;

    my($ok, $reason) = (1, '');

    # Need IO::Socket::SSL 1.42 for SSL_create_ctx_callback
    local @@INC = @@INC;
    pop @@INC if $INC[-1] eq '.';
    unless (eval {require IO::Socket::SSL; IO::Socket::SSL->VERSION(1.42)}) {
        $ok = 0;
        $reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/;
    }

    # Need Net::SSLeay 1.49 for MODE_AUTO_RETRY
    unless (eval {require Net::SSLeay; Net::SSLeay->VERSION(1.49)}) {
        $ok = 0;
        $reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/;
    }

    # If an object, check that SSL config lets us get a CA if necessary
    if ( ref($self) && ( $self->{verify_SSL} || $self->{SSL_options}{SSL_verify_mode} ) ) {
        my $handle = HTTP::Tiny::Handle->new(
            SSL_options => $self->{SSL_options},
            verify_SSL  => $self->{verify_SSL},
        );
        unless ( eval { $handle->_find_CA_file; 1 } ) {
            $ok = 0;
            $reason .= "$@@";
        }
    }

    wantarray ? ($ok, $reason) : $ok;
}

d458 1
a458 1
    return $default_agent . "/" . $class->VERSION;
a469 1
        port      => $port,
d606 1
a606 1
        uri       => "$request->{host}:$request->{port}",
d608 1
a608 1
            host => "$request->{host}:$request->{port}",
a643 5

    if (exists $request->{headers}{'host'}) {
        die(qq/The 'Host' header must not be provided as header option\n/);
    }

d744 1
a744 1
    if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))
d760 1
a760 1
    my ($scheme, $host, $path_query) = $url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)>
d766 4
a769 6
    my $auth = '';
    if ( (my $i = index $host, '@@') != -1 ) {
        # user:pass@@host
        $auth = substr $host, 0, $i, ''; # take up to the @@ for auth
        substr $host, 0, 1, '';          # knock the @@ off the host

d773 10
a782 4
    my $port = $host =~ s/:(\d*)\z// && length $1 ? $1
             : $scheme eq 'http'                  ? 80
             : $scheme eq 'https'                 ? 443
             : undef;
d784 1
a784 1
    return ($scheme, (length $host ? lc $host : "localhost") , $port, $path_query, $auth);
a909 2
    $self->{pid} = $$;
    $self->{tid} = _get_tid();
d1135 2
a1136 1
            $_ = '' unless defined $_;
d1209 1
a1209 1
      or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);
d1343 6
a1348 2
    my($ok, $reason) = HTTP::Tiny->can_ssl();
    die $reason unless $ok;
d1354 1
a1354 3
        $self->{pid} != $$
        || $self->{tid} != _get_tid()
        || length($self->{rbuf})
d1368 2
a1369 6
    if ( $self->{SSL_options}->{SSL_ca_file} ) {
        unless ( -r $self->{SSL_options}->{SSL_ca_file} ) {
            die qq/SSL_ca_file '$self->{SSL_options}->{SSL_ca_file}' not found or not readable\n/;
        }
        return $self->{SSL_options}->{SSL_ca_file};
    }
a1370 2
    local @@INC = @@INC;
    pop @@INC if $INC[-1] eq '.';
d1372 1
a1372 1
        if eval { require Mozilla::CA; 1 };
d1374 5
a1378 10
    # cert list copied from golang src/crypto/x509/root_unix.go
    foreach my $ca_bundle (
        "/etc/ssl/certs/ca-certificates.crt",     # Debian/Ubuntu/Gentoo etc.
        "/etc/pki/tls/certs/ca-bundle.crt",       # Fedora/RHEL
        "/etc/ssl/ca-bundle.pem",                 # OpenSUSE
        "/etc/openssl/certs/ca-certificates.crt", # NetBSD
        "/etc/ssl/cert.pem",                      # OpenBSD
        "/usr/local/share/certs/ca-root-nss.crt", # FreeBSD/DragonFly
        "/etc/pki/tls/cacert.pem",                # OpenELEC
        "/etc/certs/ca-certificates.crt",         # Solaris 11.2+
a1386 6
# for thread safety, we need to know thread id if threads are loaded
sub _get_tid {
    no warnings 'reserved'; # for 'threads'
    return threads->can("tid") ? threads->tid : 0;
}

d1431 1
a1431 1
version 0.056
d1476 3
a1478 1
C<agent> — A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent> — ends in a space character, the default user-agent string is appended.
d1482 3
a1484 1
C<cookie_jar> — An instance of L<HTTP::CookieJar> — or equivalent class that supports the C<add> and C<cookie_header> methods
d1488 3
a1490 1
C<default_headers> — A hashref of default headers to apply to requests
d1494 3
a1496 1
C<local_address> — The local IP address to bind to
d1500 3
a1502 1
C<keep_alive> — Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)
d1506 3
a1508 1
C<max_redirect> — Maximum number of redirects allowed (defaults to 5)
d1512 3
a1514 1
C<max_size> — Maximum response size in bytes (only when not using a data callback).  If defined, responses larger than this will return an exception.
d1518 3
a1520 1
C<http_proxy> — URL of a proxy server to use for HTTP connections (default is C<$ENV{http_proxy}> — if set)
d1524 3
a1526 1
C<https_proxy> — URL of a proxy server to use for HTTPS connections (default is C<$ENV{https_proxy}> — if set)
d1530 3
a1532 1
C<proxy> — URL of a generic proxy server for both HTTP and HTTPS connections (default is C<$ENV{all_proxy}> — if set)
d1536 3
a1538 1
C<no_proxy> — List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}> —)
d1542 3
a1544 1
C<timeout> — Request timeout in seconds (default is 60)
d1548 4
a1551 1
C<verify_SSL> — A boolean that indicates whether to validate the SSL certificate of an C<https> — connection (default is false)
d1555 3
a1557 1
C<SSL_options> — A hashref of C<SSL_*> — options to pass through to L<IO::Socket::SSL>
a1560 3
Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
prevent getting the corresponding proxies from the environment.

d1567 3
a1569 3
attributes are modified, or if the process ID or thread ID change, the
persistent connection will be dropped.  If you want persistent connections
across multiple destinations, use multiple HTTP::Tiny objects.
d1652 5
a1656 1
C<headers> — A hashref containing headers to include with the request.  If the value for a header is an array reference, the header will be output multiple times with each value in the array.  These headers over-write any default headers.
d1660 4
a1663 1
C<content> — A scalar to include as the body of the request OR a code reference that will be called iteratively to produce the body of the request
d1667 4
a1670 1
C<trailer_callback> — A code reference that will be called if it exists to provide a hashref of trailing headers (only used with chunked transfer-encoding)
d1674 4
a1677 1
C<data_callback> — A code reference that will be called for each chunks of the response body received.
a1680 4
The C<Host> header is generated from the URL in accordance with RFC 2616.  It
is a fatal error to specify C<Host> in the C<headers> option.  Other headers
may be ignored or overwritten if necessary for transport compliance.

d1702 3
a1704 1
C<success> — Boolean indicating whether the operation returned a 2XX status code
d1708 5
a1712 1
C<url> — URL that provided the response. This is the URL of the request unless there were redirections, in which case it is the last URL queried in a redirection chain
d1716 3
a1718 1
C<status> — The HTTP status code of the response
d1722 3
a1724 1
C<reason> — The response phrase returned by the server
d1728 5
a1732 1
C<content> — The body of the response.  If the response does not have any content or if a data callback is provided to consume the response body, this will be the empty string
d1736 5
a1740 1
C<headers> — A hashref of header fields.  All header field names will be normalized to be lower case. If a header is repeated, the value will be an arrayref; it will otherwise be a scalar string containing the value
a1758 15
=head2 can_ssl

    $ok         = HTTP::Tiny->can_ssl;
    ($ok, $why) = HTTP::Tiny->can_ssl;
    ($ok, $why) = $http->can_ssl;

Indicates if SSL support is available.  When called as a class object, it
checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
is set in C<SSL_options>, it checks that a CA file is available.

In scalar context, returns a boolean indicating if SSL is available.
In list context, returns the boolean and a (possibly multi-line) string of
errors indicating why SSL isn't available.

d1778 4
a1781 7
thrown if new enough versions of these modules are not installed or if the SSL
encryption fails. You can also use C<HTTP::Tiny::can_ssl()> utility function
that returns boolean to see if the required modules are installed.

An C<https> connection may be made via an C<http> proxy that supports the CONNECT
command (i.e. RFC 2817).  You may not proxy C<https> via a proxy that itself
requires C<https> to communicate.
d1870 1
a1870 1
http_proxy or HTTP_PROXY
a1881 5
If the C<REQUEST_METHOD> environment variable is set, then this might be a CGI
process and C<HTTP_PROXY> would be set from the C<Proxy:> header, which is a
security risk.  If C<REQUEST_METHOD> is set, C<HTTP_PROXY> (the upper case
variant only) is ignored.

d1898 1
a1898 30
L<HTTP/1.1 specifications|http://www.w3.org/Protocols/>:

=over 4

=item *

"Message Syntax and Routing" [RFC7230]

=item *

"Semantics and Content" [RFC7231]

=item *

"Conditional Requests" [RFC7232]

=item *

"Range Requests" [RFC7233]

=item *

"Caching" [RFC7234]

=item *

"Authentication" [RFC7235]

=back

d1900 1
a1900 3
implement all "SHOULD" requirements.  (Note: it was developed against the
earlier RFC 2616 specification and may not yet meet the revised RFC 7230-7235
spec.)
d1921 4
a1924 4
automatic for response codes 301, 302, 307 and 308 if the request method is
'GET' or 'HEAD'.  Response code 303 is always converted into a 'GET'
redirection, as mandated by the specification.  There is no automatic support
for status 305 ("Use proxy") redirections.
a2017 2
=for stopwords Alan Gardner Alessandro Ghedini Brad Gilbert Chris Nehren Weyl Claes Jakobsson Clinton Gormley Dean Pearce Edward Zborowski James Raspass Jeremy Mates Jess Robinson Lukas Eklund Martin J. Evans Martin-Louis Bright Mike Doherty Olaf Alders Olivier Mengué Petr Písař Sören Kornetzki Syohei YOSHIDA Tatsuhiko Miyagawa Tom Hukins Tony Cook

d2050 1
a2050 1
Dean Pearce <pearce@@pythian.com>
d2054 1
a2054 1
Edward Zborowski <ed@@rubensteintech.com>
d2058 1
a2058 5
James Raspass <jraspass@@gmail.com>

=item *

Jeremy Mates <jmates@@cpan.org>
a2081 8
Olaf Alders <olaf@@wundersolutions.com>

=item *

Olivier Mengué <dolmen@@cpan.org>

=item *

d2086 1
a2086 1
Sören Kornetzki <soeren.kornetzki@@delti.com>
a2093 8
Tatsuhiko Miyagawa <miyagawa@@bulknews.net>

=item *

Tom Hukins <tom@@eborcom.com>

=item *

d2100 1
a2100 1
This software is copyright (c) 2015 by Christian Hansen.
@


1.1.1.3.4.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d6 1
a6 1
our $VERSION = '0.043_01'; # VERSION
a1370 2
    local @@INC = @@INC;
    pop @@INC if $INC[-1] eq '.';
@


1.1.1.3.6.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d6 1
a6 1
our $VERSION = '0.043_01'; # VERSION
a1370 2
    local @@INC = @@INC;
    pop @@INC if $INC[-1] eq '.';
@


