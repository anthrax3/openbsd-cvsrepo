head	1.4;
access;
symbols
	OPENBSD_6_2_BASE:1.4
	PERL_5_24_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_6_1:1.1.0.4
	OPENBSD_6_1_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.4
date	2017.08.14.13.49.44;	author afresh1;	state Exp;
branches;
next	1.3;
commitid	AOpGtCFzbfdujI88;

1.3
date	2017.08.14.13.48.46;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	CrMEpTqBUsxCMTjx;

1.2
date	2017.06.04.19.26.18;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	KPMVMEcoKRAVAl5t;

1.1
date	2017.02.05.00.31.58;	author afresh1;	state Exp;
branches
	1.1.1.1;
next	;
commitid	cxJ08BvJA9Pt2PTM;

1.1.1.1
date	2017.08.14.13.45.37;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.4
log
@Apply local patches - perl-5.24.2

OK bluhm@@, Reads ok sthen@@
@
text
@use strict;
use Test::More;
use Config;
use lib './t';
use FilePathTest qw(
    _run_for_warning
);
use File::Path qw(rmtree mkpath make_path remove_tree);
use File::Spec::Functions;


my $prereq = prereq();
plan skip_all  => $prereq if defined $prereq;
plan tests     => 11;

my $pwent = max_u();
my $grent = max_g();
my ( $max_uid, $max_user ) = @@{ $pwent };
my ( $max_gid, $max_group ) = @@{ $grent };

my $tmp_base = catdir(
    curdir(),
    sprintf( 'test-%x-%x-%x', time, $$, rand(99999) ),
);

# invent some names
my @@dir = (
    catdir($tmp_base, qw(a b)),
    catdir($tmp_base, qw(a c)),
    catdir($tmp_base, qw(z b)),
    catdir($tmp_base, qw(z c)),
);

# create them
my @@created = mkpath([@@dir]);

my $dir;
my $dir2;

my $dir_stem = $dir = catdir($tmp_base, 'owned-by');

$dir = catdir($dir_stem, 'aaa');
@@created = make_path($dir, {owner => $max_user});
is(scalar(@@created), 2, "created a directory owned by $max_user...");

my $dir_uid = (stat $created[0])[4];
is($dir_uid, $max_uid, "... owned by $max_uid");

$dir = catdir($dir_stem, 'aab');
@@created = make_path($dir, {group => $max_group});
is(scalar(@@created), 1, "created a directory owned by group $max_group...");

my $dir_gid = (stat $created[0])[5];
is($dir_gid, $max_gid, "... owned by group $max_gid");

$dir = catdir($dir_stem, 'aac');
@@created = make_path( $dir, { user => $max_user,
                              group => $max_group});
is(scalar(@@created), 1, "created a directory owned by $max_user:$max_group...");

($dir_uid, $dir_gid) = (stat $created[0])[4,5];
is($dir_uid, $max_uid, "... owned by $max_uid");
is($dir_gid, $max_gid, "... owned by group $max_gid");

{
  # invent a user and group that don't exist
  do { ++$max_user  } while ( getpwnam( $max_user ) );
  do { ++$max_group } while ( getgrnam( $max_group ) );

  $dir = catdir($dir_stem, 'aad');
  my $rv = _run_for_warning( sub {
      make_path(
          $dir,
          { user => $max_user, group => $max_group }
      )
  } );
  like( $rv,
    qr{unable to map $max_user to a uid, ownership not changed:}s,
    "created a directory not owned by $max_user:$max_group...",
  );
  like( $rv,
    qr{unable to map $max_group to a gid, group ownership not changed:}s,
    "created a directory not owned by $max_user:$max_group...",
  );
}

{
    # cleanup
    my $x;
    my $opts = { error => \$x };
    remove_tree($tmp_base, $opts);
    ok(! -d $tmp_base, "directory '$tmp_base' removed, as expected");
    is(scalar(@@{$x}), 0, "no error messages using remove_tree() with \$opts");
}

sub max_u {
  # find the highest uid ('nobody' or similar)
  my $max_uid   = 0;
  my $max_user = undef;
  while (my @@u = getpwent()) {
    if ($max_uid < $u[2]) {
      $max_uid  = $u[2];
      $max_user = $u[0];
    }
  }
  setpwent(); # in case we want to run again later
  return [ $max_uid, $max_user ];
}

sub max_g {
  # find the highest gid ('nogroup' or similar)
  my $max_gid   = 0;
  my $max_group = undef;
  while ( my @@g = getgrent() ) {
    print Dumper @@g;
    if ($max_gid < $g[2]) {
      $max_gid = $g[2];
      $max_group = $g[0];
    }
  }
  setgrent(); # in case we want to run again later
  return [ $max_gid, $max_group ];
}

sub prereq {
  return "getpwent() not implemented on $^O" unless $Config{d_getpwent};
  return "getgrent() not implemented on $^O" unless $Config{d_getgrent};
  return "not running as root" unless $< == 0;
  return "darwin's nobody and nogroup are -1 or -2" if $^O eq 'darwin';

  my $pwent = max_u();
  my $grent = max_g();
  my ( $max_uid, $max_user ) = @@{ $pwent };
  my ( $max_gid, $max_group ) = @@{ $grent };

  return "getpwent() appears to be insane" unless $max_uid > 0;
  return "getgrent() appears to be insane" unless $max_gid > 0;
  return undef;
}
@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.2 dist

OK bluhm@@, Reads ok sthen@@
@
text
@d4 4
a7 2
use lib 't/';
use FilePathTest;
d14 1
a14 1
plan tests     => 8;
d65 1
a65 2
SKIP: {
  skip('Skip until RT 85878 is fixed', 1);
d71 10
a80 3
  my $rv = _run_for_warning( sub { make_path( $dir,
                                              { user => $max_user,
                                                group => $max_group } ) } );
d82 12
a93 4
        qr{\Aunable to map $max_user to a uid, ownership not changed: .* at \S+ line \d+
unable to map $max_group to a gid, group ownership not changed: .* at \S+ line \d+\b},
        "created a directory not owned by $max_user:$max_group..."
      );
@


1.2
log
@Update to perl File::Path 2.13 for security fixes

Reccomended by upstream - jkeenan AT pobox.com

OK sthen@@
@
text
@d4 2
a5 4
use lib './t';
use FilePathTest qw(
    _run_for_warning
);
d12 1
a12 1
plan tests     => 11;
d63 2
a64 1
{
d70 3
a72 10
  my $rv = _run_for_warning( sub {
      make_path(
          $dir,
          { user => $max_user, group => $max_group }
      )
  } );
  like( $rv,
    qr{unable to map $max_user to a uid, ownership not changed:}s,
    "created a directory not owned by $max_user:$max_group...",
  );
d74 4
a77 12
    qr{unable to map $max_group to a gid, group ownership not changed:}s,
    "created a directory not owned by $max_user:$max_group...",
  );
}

{
    # cleanup
    my $x;
    my $opts = { error => \$x };
    remove_tree($tmp_base, $opts);
    ok(! -d $tmp_base, "directory '$tmp_base' removed, as expected");
    is(scalar(@@{$x}), 0, "no error messages using remove_tree() with \$opts");
@


1.1
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@d4 4
a7 2
use lib 't/';
use FilePathTest;
d14 1
a14 1
plan tests     => 8;
d65 1
a65 2
SKIP: {
  skip('Skip until RT 85878 is fixed', 1);
d71 10
a80 3
  my $rv = _run_for_warning( sub { make_path( $dir,
                                              { user => $max_user,
                                                group => $max_group } ) } );
d82 12
a93 4
        qr{\Aunable to map $max_user to a uid, ownership not changed: .* at \S+ line \d+
unable to map $max_group to a gid, group ownership not changed: .* at \S+ line \d+\b},
        "created a directory not owned by $max_user:$max_group..."
      );
@


1.1.1.1
log
@Import perl-5.24.2
@
text
@@


