head	1.5;
access;
symbols
	PERL_5_24_2:1.1.1.2
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.1.0.26
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.20
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.22
	OPENBSD_5_8_BASE:1.1.1.1
	PERL_5_20_2:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.14
	OPENBSD_5_7_BASE:1.1.1.1
	PERL_5_20_1:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.18
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.16
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.12
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2017.08.14.13.49.44;	author afresh1;	state Exp;
branches;
next	1.4;
commitid	AOpGtCFzbfdujI88;

1.4
date	2017.08.14.13.48.46;	author afresh1;	state Exp;
branches;
next	1.3;
commitid	CrMEpTqBUsxCMTjx;

1.3
date	2017.06.04.19.26.18;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	KPMVMEcoKRAVAl5t;

1.2
date	2017.02.05.00.31.58;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2010.09.24.14.49.03;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.03;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2017.08.14.13.45.37;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.5
log
@Apply local patches - perl-5.24.2

OK bluhm@@, Reads ok sthen@@
@
text
@#! /usr/bin/env perl
# Path.t -- tests for module File::Path

use strict;

use Test::More tests => 167;
use Config;
use Fcntl ':mode';
use lib './t';
use FilePathTest qw(
    _run_for_warning
    _run_for_verbose
    _cannot_delete_safe_mode
    _verbose_expected
    create_3_level_subdirs
    cleanup_3_level_subdirs
);
use Errno qw(:POSIX);
use Carp;

BEGIN {
    use_ok('Cwd');
    use_ok('File::Path', qw(rmtree mkpath make_path remove_tree));
    use_ok('File::Spec::Functions');
}

my $Is_VMS = $^O eq 'VMS';

my $fchmod_supported = 0;
if (open my $fh, curdir()) {
    my ($perm) = (stat($fh))[2];
    $perm &= 07777;
    eval { $fchmod_supported = chmod( $perm, $fh); };
}

# first check for stupid permissions second for full, so we clean up
# behind ourselves
for my $perm (0111,0777) {
    my $path = catdir(curdir(), "mhx", "bar");
    mkpath($path);
    chmod $perm, "mhx", $path;

    my $oct = sprintf('0%o', $perm);

    ok(-d "mhx", "mkdir parent dir $oct");
    ok(-d $path, "mkdir child dir $oct");

    rmtree("mhx");

    ok(! -e "mhx", "mhx does not exist $oct");
}

# find a place to work
my ($error, $list, $file, $message);
my $tmp_base = catdir(
    curdir(),
    sprintf( 'test-%x-%x-%x', time, $$, rand(99999) ),
);

# invent some names
my @@dir = (
    catdir($tmp_base, qw(a b)),
    catdir($tmp_base, qw(a c)),
    catdir($tmp_base, qw(z b)),
    catdir($tmp_base, qw(z c)),
);

# create them
my @@created = mkpath([@@dir]);

is(scalar(@@created), 7, "created list of directories");

# pray for no race conditions blowing them out from under us
@@created = mkpath([$tmp_base]);
is(scalar(@@created), 0, "skipped making existing directory")
    or diag("unexpectedly recreated @@created");

# create a file
my $file_name = catfile( $tmp_base, 'a', 'delete.me' );
my $file_count = 0;
if (open OUT, "> $file_name") {
    print OUT "this file may be deleted\n";
    close OUT;
    ++$file_count;
}
else {
    diag( "Failed to create file $file_name: $!" );
}

SKIP: {
    skip "cannot remove a file we failed to create", 1
        unless $file_count == 1;
    my $count = rmtree($file_name);
    is($count, 1, "rmtree'ed a file");
}

@@created = mkpath('');
is(scalar(@@created), 0, "Can't create a directory named ''");

my $dir;
my $dir2;

sub gisle {
    # background info: @@_ = 1; !shift # gives '' not 0
    # Message-Id: <3C820CE6-4400-4E91-AF43-A3D19B356E68@@activestate.com>
    # http://www.nntp.perl.org/group/perl.perl5.porters/2008/05/msg136625.html
    mkpath(shift, !shift, 0755);
}

sub count {
    opendir D, shift or return -1;
    my $count = () = readdir D;
    closedir D or return -1;
    return $count;
}

{
    mkdir 'solo', 0755;
    chdir 'solo';
    open my $f, '>', 'foo.dat';
    close $f;
    my $before = count(curdir());
    cmp_ok($before, '>', 0, "baseline $before");

    gisle('1st', 1);
    is(count(curdir()), $before + 1, "first after $before");

    $before = count(curdir());
    gisle('2nd', 1);

    is(count(curdir()), $before + 1, "second after $before");

    chdir updir();
    rmtree 'solo';
}

{
    mkdir 'solo', 0755;
    chdir 'solo';
    open my $f, '>', 'foo.dat';
    close $f;
    my $before = count(curdir());

    cmp_ok($before, '>', 0, "ARGV $before");
    {
        local @@ARGV = (1);
        mkpath('3rd', !shift, 0755);
    }

    is(count(curdir()), $before + 1, "third after $before");

    $before = count(curdir());
    {
        local @@ARGV = (1);
        mkpath('4th', !shift, 0755);
    }

    is(count(curdir()), $before + 1, "fourth after $before");

    chdir updir();
    rmtree 'solo';
}

SKIP: {
    # tests for rmtree() of ancestor directory
    my $nr_tests = 6;
    my $cwd = getcwd() or skip "failed to getcwd: $!", $nr_tests;
    my $dir  = catdir($cwd, 'remove');
    my $dir2 = catdir($cwd, 'remove', 'this', 'dir');

    skip "failed to mkpath '$dir2': $!", $nr_tests
        unless mkpath($dir2, {verbose => 0});
    skip "failed to chdir dir '$dir2': $!", $nr_tests
        unless chdir($dir2);

    rmtree($dir, {error => \$error});
    my $nr_err = @@$error;

    is($nr_err, 1, "ancestor error");

    if ($nr_err) {
        my ($file, $message) = each %{$error->[0]};

        is($file, $dir, "ancestor named");
        my $ortho_dir = $^O eq 'MSWin32' ? File::Path::_slash_lc($dir2) : $dir2;
        $^O eq 'MSWin32' and $message
            =~ s/\A(cannot remove path when cwd is )(.*)\Z/$1 . File::Path::_slash_lc($2)/e;

        is($message, "cannot remove path when cwd is $ortho_dir", "ancestor reason");

        ok(-d $dir2, "child not removed");

        ok(-d $dir, "ancestor not removed");
    }
    else {
        fail( "ancestor 1");
        fail( "ancestor 2");
        fail( "ancestor 3");
        fail( "ancestor 4");
    }
    chdir $cwd;
    rmtree($dir);

    ok(!(-d $dir), "ancestor now removed");
};

my $count = rmtree({error => \$error});

is( $count, 0, 'rmtree of nothing, count of zero' );

is( scalar(@@$error), 0, 'no diagnostic captured' );

@@created = mkpath($tmp_base, 0);

is(scalar(@@created), 0, "skipped making existing directories (old style 1)")
    or diag("unexpectedly recreated @@created");

$dir = catdir($tmp_base,'C');
# mkpath returns unix syntax filespecs on VMS
$dir = VMS::Filespec::unixify($dir) if $Is_VMS;
@@created = make_path($tmp_base, $dir);

is(scalar(@@created), 1, "created directory (new style 1)");

is($created[0], $dir, "created directory (new style 1) cross-check");

@@created = mkpath($tmp_base, 0, 0700);

is(scalar(@@created), 0, "skipped making existing directories (old style 2)")
    or diag("unexpectedly recreated @@created");

$dir2 = catdir($tmp_base,'D');
# mkpath returns unix syntax filespecs on VMS
$dir2 = VMS::Filespec::unixify($dir2) if $Is_VMS;
@@created = make_path($tmp_base, $dir, $dir2);

is(scalar(@@created), 1, "created directory (new style 2)");

is($created[0], $dir2, "created directory (new style 2) cross-check");

$count = rmtree($dir, 0);

is($count, 1, "removed directory unsafe mode");

my $expected_count = _cannot_delete_safe_mode($dir2) ? 0 : 1;

$count = rmtree($dir2, 0, 1);

is($count, $expected_count, "removed directory safe mode");

# mkdir foo ./E/../Y
# Y should exist
# existence of E is neither here nor there
$dir = catdir($tmp_base, 'E', updir(), 'Y');
@@created =mkpath($dir);

cmp_ok(scalar(@@created), '>=', 1, "made one or more dirs because of ..");

cmp_ok(scalar(@@created), '<=', 2, "made less than two dirs because of ..");

ok( -d catdir($tmp_base, 'Y'), "directory after parent" );

@@created = make_path(catdir(curdir(), $tmp_base));

is(scalar(@@created), 0, "nothing created")
    or diag(@@created);

$dir  = catdir($tmp_base, 'a');
$dir2 = catdir($tmp_base, 'z');

rmtree( $dir, $dir2,
    {
        error     => \$error,
        result    => \$list,
        keep_root => 1,
    }
);


is(scalar(@@$error), 0, "no errors unlinking a and z");

is(scalar(@@$list),  4, "list contains 4 elements")
    or diag("@@$list");

ok(-d $dir,  "dir a still exists");

ok(-d $dir2, "dir z still exists");

$dir = catdir($tmp_base,'F');
# mkpath returns unix syntax filespecs on VMS
$dir = VMS::Filespec::unixify($dir) if $Is_VMS;

@@created = mkpath($dir, undef, 0770);

is(scalar(@@created), 1, "created directory (old style 2 verbose undef)");

is($created[0], $dir, "created directory (old style 2 verbose undef) cross-check");

is(rmtree($dir, undef, 0), 1, "removed directory 2 verbose undef");

@@created = mkpath($dir, undef);

is(scalar(@@created), 1, "created directory (old style 2a verbose undef)");

is($created[0], $dir, "created directory (old style 2a verbose undef) cross-check");

is(rmtree($dir, undef), 1, "removed directory 2a verbose undef");

@@created = mkpath($dir, 0, undef);

is(scalar(@@created), 1, "created directory (old style 3 mode undef)");

is($created[0], $dir, "created directory (old style 3 mode undef) cross-check");

is(rmtree($dir, 0, undef), 1, "removed directory 3 verbose undef");

SKIP: {
    skip "fchmod of directories not supported on this platform", 3 unless $fchmod_supported;
    $dir = catdir($tmp_base,'G');
    $dir = VMS::Filespec::unixify($dir) if $Is_VMS;

    @@created = mkpath($dir, undef, 0400);

    is(scalar(@@created), 1, "created read-only dir");

    is($created[0], $dir, "created read-only directory cross-check");

    is(rmtree($dir), 1, "removed read-only dir");
}

# borderline new-style heuristics
if (chdir $tmp_base) {
    pass("chdir to temp dir");
}
else {
    fail("chdir to temp dir: $!");
}

$dir   = catdir('a', 'd1');
$dir2  = catdir('a', 'd2');

@@created = make_path( $dir, 0, $dir2 );

is(scalar @@created, 3, 'new-style 3 dirs created');

$count = remove_tree( $dir, 0, $dir2, );

is($count, 3, 'new-style 3 dirs removed');

@@created = make_path( $dir, $dir2, 1 );

is(scalar @@created, 3, 'new-style 3 dirs created (redux)');

$count = remove_tree( $dir, $dir2, 1 );

is($count, 3, 'new-style 3 dirs removed (redux)');

@@created = make_path( $dir, $dir2 );

is(scalar @@created, 2, 'new-style 2 dirs created');

$count = remove_tree( $dir, $dir2 );

is($count, 2, 'new-style 2 dirs removed');

$dir = catdir("a\nb", 'd1');
$dir2 = catdir("a\nb", 'd2');

SKIP: {
  # Better to search for *nix derivatives?
  # Not sure what else doesn't support newline in paths
  skip "$^O doesn't allow newline in paths", 2
    if $^O =~ m/^(MSWin32|VMS)$/;

  @@created = make_path( $dir, $dir2 );

  is(scalar @@created, 3, 'new-style 3 dirs created in parent with newline');

  $count = remove_tree( $dir, $dir2 );

  is($count, 2, 'new-style 2 dirs removed in parent with newline');
}

if (chdir updir()) {
    pass("chdir parent");
}
else {
    fail("chdir parent: $!");
}

SKIP: {
    # test bug http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=487319
    skip "Don't need Force_Writeable semantics on $^O", 6
        if grep {$^O eq $_} qw(amigaos dos epoc MSWin32 MacOS os2);
    skip "Symlinks not available", 6 unless $Config{d_symlink};
    $dir  = 'bug487319';
    $dir2 = 'bug487319-symlink';
    @@created = make_path($dir, {mask => 0700});

    is( scalar @@created, 1, 'bug 487319 setup' );
    symlink($dir, $dir2);

    ok(-e $dir2, "debian bug 487319 setup symlink") or diag($dir2);

    chmod 0500, $dir;
    my $mask_initial = (stat $dir)[2];
    remove_tree($dir2);

    my $mask = (stat $dir)[2];

    is( $mask, $mask_initial, 'mask of symlink target dir unchanged (debian bug 487319)');

    # now try a file
    #my $file = catfile($dir, 'file');
    my $file  = 'bug487319-file';
    my $file2 = 'bug487319-file-symlink';
    open my $out, '>', $file;
    close $out;

    ok(-e $file, 'file exists');

    chmod 0500, $file;
    $mask_initial = (stat $file)[2];

    symlink($file, $file2);

    ok(-e $file2, 'file2 exists');
    remove_tree($file2);

    $mask = (stat $file)[2];

    is( $mask, $mask_initial, 'mask of symlink target file unchanged (debian bug 487319)');

    remove_tree($dir);
    remove_tree($file);
}

# see what happens if a file exists where we want a directory
SKIP: {
    my $entry = catfile($tmp_base, "file");
    skip "VMS can have a file and a directory with the same name.", 4
        if $Is_VMS;
    skip "Cannot create $entry", 4 unless open OUT, "> $entry";
    print OUT "test file, safe to delete\n", scalar(localtime), "\n";
    close OUT;
    ok(-e $entry, "file exists in place of directory");

    mkpath( $entry, {error => \$error} );
    is( scalar(@@$error), 1, "caught error condition" );
    ($file, $message) = each %{$error->[0]};
    is( $entry, $file, "and the message is: $message");

    eval {@@created = mkpath($entry, 0, 0700)};
    $error = $@@;
    chomp $error; # just to remove silly # in TAP output
    cmp_ok( $error, 'ne', "", "no directory created (old-style) err=$error" )
        or diag(@@created);
}

{
    $dir = catdir($tmp_base, 'ZZ');
    @@created = mkpath($dir);
    is(scalar(@@created), 1, "create a ZZ directory");

    local @@ARGV = ($dir);
    rmtree( [grep -e $_, @@ARGV], 0, 0 );
    ok(!-e $dir, "blow it away via \@@ARGV");
}

SKIP : {
    my $skip_count = 18;
    # this test will fail on Windows, as per:
    #   http://perldoc.perl.org/perlport.html#chmod

    skip "Windows chmod test skipped", $skip_count
        if $^O eq 'MSWin32';
    skip "fchmod() on directories is not supported on this platform", $skip_count
        unless $fchmod_supported;
    my $mode;
    my $octal_mode;
    my @@inputs = (
      0777, 0700, 0470, 0407,
      0433, 0400, 0430, 0403,
      0111, 0100, 0110, 0101,
      0731, 0713, 0317, 0371,
      0173, 0137);
    my $input;
    my $octal_input;

    foreach (@@inputs) {
        $input = $_;
        $dir = catdir($tmp_base, sprintf("chmod_test%04o", $input));
        # We can skip from here because 0 is last in the list.
        skip "Mode of 0 means assume user defaults on VMS", 1
          if ($input == 0 && $Is_VMS);
        @@created = mkpath($dir, {chmod => $input});
        $mode = (stat($dir))[2];
        $octal_mode = S_IMODE($mode);
        $octal_input = sprintf "%04o", S_IMODE($input);
        SKIP: {
	    skip "permissions are not fully supported by the filesystem", 1
                if (($^O eq 'MSWin32' || $^O eq 'cygwin') && ((Win32::FsType())[1] & 8) == 0);
            is($octal_mode,$input, "create a new directory with chmod $input ($octal_input)");
	    }
        rmtree( $dir );
    }
}

my $dir_base = catdir($tmp_base,'output');
my $dir_a    = catdir($dir_base, 'A');
my $dir_b    = catdir($dir_base, 'B');

is(_run_for_verbose(sub {@@created = mkpath($dir_a, 1)}),
    _verbose_expected('mkpath', $dir_base, 0, 1)
    . _verbose_expected('mkpath', $dir_a, 0),
    'mkpath verbose (old style 1)'
);

is(_run_for_verbose(sub {@@created = mkpath([$dir_b], 1)}),
    _verbose_expected('mkpath', $dir_b, 0),
    'mkpath verbose (old style 2)'
);

my $verbose_expected;

# Must determine expectations while directories still exist.
$verbose_expected = _verbose_expected('rmtree', $dir_a, 1)
                  . _verbose_expected('rmtree', $dir_b, 1);

is(_run_for_verbose(sub {$count = rmtree([$dir_a, $dir_b], 1, 1)}),
    $verbose_expected,
    'rmtree verbose (old style)'
);

# In case we didn't delete them in safe mode.
rmtree($dir_a) if -d $dir_a;
rmtree($dir_b) if -d $dir_b;

is(_run_for_verbose(sub {@@created = mkpath( $dir_a,
                                            {verbose => 1, mask => 0750})}),
    _verbose_expected('mkpath', $dir_a, 0),
    'mkpath verbose (new style 1)'
);

is(_run_for_verbose(sub {@@created = mkpath($dir_b, 1, 0771)}),
    _verbose_expected('mkpath', $dir_b, 0),
    'mkpath verbose (new style 2)'
);

$verbose_expected = _verbose_expected('rmtree', $dir_a, 1)
                  . _verbose_expected('rmtree', $dir_b, 1);

is(_run_for_verbose(sub {$count = rmtree([$dir_a, $dir_b], 1, 1)}),
    $verbose_expected,
    'again: rmtree verbose (old style)'
);

rmtree($dir_a) if -d $dir_a;
rmtree($dir_b) if -d $dir_b;

is(_run_for_verbose(sub {@@created = make_path( $dir_a, $dir_b,
                                               {verbose => 1, mode => 0711});}),
      _verbose_expected('make_path', $dir_a, 1)
    . _verbose_expected('make_path', $dir_b, 1),
    'make_path verbose with final hashref'
);

$verbose_expected = _verbose_expected('remove_tree', $dir_a, 0)
                  . _verbose_expected('remove_tree', $dir_b, 0);

is(_run_for_verbose(sub {@@created = remove_tree( $dir_a, $dir_b,
                                                 {verbose => 1});}),
    $verbose_expected,
    'remove_tree verbose with final hashref'
);

rmtree($dir_a) if -d $dir_a;
rmtree($dir_b) if -d $dir_b;

# Have to re-create these 2 directories so that next block is not skipped.
@@created = make_path(
    $dir_a,
    $dir_b,
    { mode => 0711 }
);
is(@@created, 2, "2 directories created");

SKIP: {
    $file = catfile($dir_b, "file");
    skip "Cannot create $file", 2 unless open OUT, "> $file";
    print OUT "test file, safe to delete\n", scalar(localtime), "\n";
    close OUT;

    $verbose_expected = _verbose_expected('rmtree', $dir_a, 1)
                      . _verbose_expected('unlink', $file, 0)
                      . _verbose_expected('rmtree', $dir_b, 1);

    ok(-e $file, "file created in directory");

    is(_run_for_verbose(sub {$count = rmtree( $dir_a, $dir_b,
                                              {verbose => 1, safe => 1})}),
        $verbose_expected,
        'rmtree safe verbose (new style)'
    );
    rmtree($dir_a) if -d $dir_a;
    rmtree($dir_b) if -d $dir_b;
}

{
    my $base = catdir( $tmp_base, 'output2');
    my $dir  = catdir( $base, 'A');
    my $dir2 = catdir( $base, 'B');

    {
        my $warn = _run_for_warning( sub {
            my @@created = make_path(
                $dir,
                $dir2,
                { mode => 0711, foo => 1, bar => 1 }
            );
        } );
        like($warn,
            qr/Unrecognized option\(s\) passed to mkpath\(\) or make_path\(\):.*?bar.*?foo/,
            'make_path with final hashref warned due to unrecognized options'
        );
    }

    {
        my $warn = _run_for_warning( sub {
            my @@created = remove_tree(
                $dir,
                $dir2,
                { foo => 1, bar => 1 }
            );
        } );
        like($warn,
            qr/Unrecognized option\(s\) passed to remove_tree\(\):.*?bar.*?foo/,
            'remove_tree with final hashref failed due to unrecognized options'
        );
    }
}

SKIP: {
    my $nr_tests = 6;
    my $cwd = getcwd() or skip "failed to getcwd: $!", $nr_tests;
    rmtree($tmp_base, {result => \$list} );
    is(ref($list), 'ARRAY', "received a final list of results");
    ok( !(-d $tmp_base), "test base directory gone" );

    my $p = getcwd();
    my $x = "x$$";
    my $xx = $x . "x";

    # setup
    ok(mkpath($xx), "make $xx");
    ok(chdir($xx), "... and chdir $xx");
    END {
#         ok(chdir($p), "... now chdir $p");
#         ok(rmtree($xx), "... and finally rmtree $xx");
       chdir($p);
       rmtree($xx);
    }

    # create and delete directory
    my $px = catdir($p, $x);
    ok(mkpath($px), 'create and delete directory 2.07');
    ok(rmtree($px), '.. rmtree fails in File-Path-2.07');
    chdir updir();
}

my $windows_dir = 'C:\Path\To\Dir';
my $expect = 'c:/path/to/dir';
is(
    File::Path::_slash_lc($windows_dir),
    $expect,
    "Windows path unixified as expected"
);

{
    my ($x, $message, $object, $expect, $rv, $arg, $error);
    my ($k, $v, $second_error, $third_error);
    local $! = ENOENT;
    $x = $!;

    $message = 'message in a bottle';
    $object = '/path/to/glory';
    $expect = "$message for $object: $x";
    $rv = _run_for_warning( sub {
        File::Path::_error(
            {},
            $message,
            $object
        );
    } );
    like($rv, qr/^$expect/,
        "no \$arg->{error}: defined 2nd and 3rd args: got expected error message");

    $object = undef;
    $expect = "$message: $x";
    $rv = _run_for_warning( sub {
        File::Path::_error(
            {},
            $message,
            $object
        );
    } );
    like($rv, qr/^$expect/,
        "no \$arg->{error}: defined 2nd arg; undefined 3rd arg: got expected error message");

    $message = 'message in a bottle';
    $object = undef;
    $expect = "$message: $x";
    $arg = { error => \$error };
    File::Path::_error(
        $arg,
        $message,
        $object
    );
    is(ref($error->[0]), 'HASH',
        "first element of array inside \$error is hashref");
    ($k, $v) = %{$error->[0]};
    is($k, '', 'key of hash is empty string, since 3rd arg was undef');
    is($v, $expect, "value of hash is 2nd arg: $message");

    $message = '';
    $object = '/path/to/glory';
    $expect = "$message: $x";
    $arg = { error => \$second_error };
    File::Path::_error(
        $arg,
        $message,
        $object
    );
    is(ref($second_error->[0]), 'HASH',
        "first element of array inside \$second_error is hashref");
    ($k, $v) = %{$second_error->[0]};
    is($k, $object, "key of hash is '$object', since 3rd arg was defined");
    is($v, $expect, "value of hash is 2nd arg: $message");

    $message = '';
    $object = undef;
    $expect = "$message: $x";
    $arg = { error => \$third_error };
    File::Path::_error(
        $arg,
        $message,
        $object
    );
    is(ref($third_error->[0]), 'HASH',
        "first element of array inside \$third_error is hashref");
    ($k, $v) = %{$third_error->[0]};
    is($k, '', "key of hash is empty string, since 3rd arg was undef");
    is($v, $expect, "value of hash is 2nd arg: $message");
}

{
    # https://rt.cpan.org/Ticket/Display.html?id=117019
    # remove_tree(): Permit re-use of options hash without issuing a warning

    my ($least_deep, $next_deepest, $deepest) =
        create_3_level_subdirs( qw| a b c | );
    my @@created;
    @@created = File::Path::make_path($deepest, { mode => 0711 });
    is(scalar(@@created), 3, "Created 3 subdirectories");

    my $x = '';
    my $opts = { error => \$x };
    File::Path::remove_tree($deepest, $opts);
    ok(! -d $deepest, "directory '$deepest' removed, as expected");

    my $warn;
    $warn = _run_for_warning( sub { File::Path::remove_tree($next_deepest, $opts); } );
    ok(! $warn, "CPAN 117019: No warning thrown when re-using \$opts");
    ok(! -d $next_deepest, "directory '$next_deepest' removed, as expected");

    $warn = _run_for_warning( sub { File::Path::remove_tree($least_deep, $opts); } );
    ok(! $warn, "CPAN 117019: No warning thrown when re-using \$opts");
    ok(! -d $least_deep, "directory '$least_deep' removed, as expected");
}

{
    # Corner cases with respect to arguments provided to functions
    my $count;

    $count = remove_tree();
    is($count, 0,
        "If not provided with any paths, remove_tree() will return a count of 0 things deleted");

    $count = remove_tree('');
    is($count, 0,
        "If not provided with any paths, remove_tree() will return a count of 0 things deleted");

    my $warn;
    $warn = _run_for_warning( sub { $count = rmtree(); } );
    like($warn, qr/No root path\(s\) specified/s, "Got expected carp");
    is($count, 0,
        "If not provided with any paths, remove_tree() will return a count of 0 things deleted");

    $warn = _run_for_warning( sub {$count = rmtree(undef); } );
    like($warn, qr/No root path\(s\) specified/s, "Got expected carp");
    is($count, 0,
        "If provided only with an undefined value, remove_tree() will return a count of 0 things deleted");

    $warn = _run_for_warning( sub {$count = rmtree(''); } );
    like($warn, qr/No root path\(s\) specified/s, "Got expected carp");
    is($count, 0,
        "If provided with an empty string for a path, remove_tree() will return a count of 0 things deleted");

    $count = make_path();
    is($count, 0,
        "If not provided with any paths, make_path() will return a count of 0 things created");

    $count = mkpath();
    is($count, 0,
        "If not provided with any paths, make_path() will return a count of 0 things created");
}

SKIP: {
    my $skip_count = 5;
    skip "Windows will not set this error condition", $skip_count
        if $^O eq 'MSWin32';

    # mkpath() with hashref:  case of phony user
    my ($least_deep, $next_deepest, $deepest) =
        create_3_level_subdirs( qw| d e f | );
    my (@@created, $error);
    my $user = join('_' => 'foobar', $$);
    @@created = mkpath($deepest, { mode => 0711, user => $user, error => \$error });
    TODO: {
        local $TODO = "Notwithstanding the phony 'user', mkpath will actually create subdirectories; should it?";
        is(scalar(@@created), 0, "No subdirectories created");
    }
    is(scalar(@@$error), 1, "caught error condition" );
    my ($file, $message) = each %{$error->[0]};
    like($message,
        qr/unable to map $user to a uid, ownership not changed/s,
        "Got expected error message for phony user",
    );

    cleanup_3_level_subdirs($least_deep);
}

{
    # mkpath() with hashref:  case of valid uid
    my ($least_deep, $next_deepest, $deepest) =
        create_3_level_subdirs( qw| j k l | );
    my (@@created, $error);
    @@created = mkpath($deepest, { mode => 0711, uid => $>, error => \$error });
    is(scalar(@@created), 3, "Provide valid 'uid' argument: 3 subdirectories created");

    cleanup_3_level_subdirs($least_deep);
}

SKIP: {
    my $skip_count = 3;
    skip "getpwuid() and getgrgid() not implemented on Windows", $skip_count
        if $^O eq 'MSWin32';

    # mkpath() with hashref:  case of valid owner
    my ($least_deep, $next_deepest, $deepest) =
        create_3_level_subdirs( qw| m n o | );
    my (@@created, $error);
    my $name = getpwuid($>);
    @@created = mkpath($deepest, { mode => 0711, owner => $name, error => \$error });
    is(scalar(@@created), 3, "Provide valid 'owner' argument: 3 subdirectories created");

    cleanup_3_level_subdirs($least_deep);
}

SKIP: {
    my $skip_count = 5;
    skip "Windows will not set this error condition", $skip_count
        if $^O eq 'MSWin32';

    # mkpath() with hashref:  case of phony group
    my ($least_deep, $next_deepest, $deepest) =
        create_3_level_subdirs( qw| p q r | );
    my (@@created, $error);
    my $bad_group = join('_' => 'foobarbaz', $$);
    @@created = mkpath($deepest, { mode => 0711, group => $bad_group, error => \$error });
    TODO: {
        local $TODO = "Notwithstanding the phony 'group', mkpath will actually create subdirectories; should it?";
        is(scalar(@@created), 0, "No subdirectories created");
    }
    is(scalar(@@$error), 1, "caught error condition" );
    my ($file, $message) = each %{$error->[0]};
    like($message,
        qr/unable to map $bad_group to a gid, group ownership not changed/s,
        "Got expected error message for phony user",
    );

    cleanup_3_level_subdirs($least_deep);
}

{
    # mkpath() with hashref:  case of valid group
    my ($least_deep, $next_deepest, $deepest) =
        create_3_level_subdirs( qw| s t u | );
    my (@@created, $error);
    @@created = mkpath($deepest, { mode => 0711, group => $(, error => \$error });
    is(scalar(@@created), 3, "Provide valid 'group' argument: 3 subdirectories created");

    cleanup_3_level_subdirs($least_deep);
}

SKIP: {
    my $skip_count = 3;
    skip "getpwuid() and getgrgid() not implemented on Windows", $skip_count
        if $^O eq 'MSWin32';

    # mkpath() with hashref:  case of valid group
    my ($least_deep, $next_deepest, $deepest) =
        create_3_level_subdirs( qw| v w x | );
    my (@@created, $error);
    my $group_name = (getgrgid($())[0];
    @@created = mkpath($deepest, { mode => 0711, group => $group_name, error => \$error });
    is(scalar(@@created), 3, "Provide valid 'group' argument: 3 subdirectories created");

    cleanup_3_level_subdirs($least_deep);
}

SKIP: {
    my $skip_count = 3;
    skip "getpwuid() and getgrgid() not implemented on Windows", $skip_count
        if $^O eq 'MSWin32';

    # mkpath() with hashref:  case of valid owner and group
    my ($least_deep, $next_deepest, $deepest) =
        create_3_level_subdirs( qw| delta epsilon zeta | );
    my (@@created, $error);
    my $name = getpwuid($>);
    my $group_name = (getgrgid($())[0];
    @@created = mkpath($deepest, { mode => 0711, owner => $name, group => $group_name, error => \$error });
    is(scalar(@@created), 3, "Provide valid 'owner' and 'group' 'group' arguments: 3 subdirectories created");

    cleanup_3_level_subdirs($least_deep);
}
@


1.4
log
@Fix merge issues, remove excess files - match perl-5.24.2 dist

OK bluhm@@, Reads ok sthen@@
@
text
@d6 1
a6 1
use Test::More tests => 127;
d9 11
a19 2
use lib 't/';
use FilePathTest;
d29 7
d317 4
a320 2
$dir = catdir($tmp_base,'G');
$dir = VMS::Filespec::unixify($dir) if $Is_VMS;
d322 1
a322 1
@@created = mkpath($dir, undef, 0200);
d324 1
a324 1
is(scalar(@@created), 1, "created write-only dir");
d326 1
a326 1
is($created[0], $dir, "created write-only directory cross-check");
d328 2
a329 1
is(rmtree($dir), 1, "removed write-only dir");
d471 1
a471 1
    my $skip_count = 19;
d477 2
d482 5
a486 5
      0777, 0700, 0070, 0007,
      0333, 0300, 0030, 0003,
      0111, 0100, 0010, 0001,
      0731, 0713, 0317, 0371, 0173, 0137,
      00 );
a488 1
    $dir = catdir($tmp_base, 'chmod_test');
d492 1
d500 5
a504 1
        is($octal_mode,$input, "create a new directory with chmod $input ($octal_input)");
d615 7
a621 8
        my $warn;
        $SIG{__WARN__} = sub { $warn = shift };

        my @@created = make_path(
            $dir,
            $dir2,
            { mode => 0711, foo => 1, bar => 1 }
        );
d623 1
a623 1
            qr/Unrecognized option\(s\) passed to make_path\(\):.*?bar.*?foo/,
d629 7
a635 8
        my $warn;
        $SIG{__WARN__} = sub { $warn = shift };

        my @@created = remove_tree(
            $dir,
            $dir2,
            { foo => 1, bar => 1 }
        );
d682 1
a682 1
    local $! = 2;
d754 183
@


1.3
log
@Update to perl File::Path 2.13 for security fixes

Reccomended by upstream - jkeenan AT pobox.com

OK sthen@@
@
text
@d6 1
a6 1
use Test::More tests => 167;
d9 2
a10 11
use lib './t';
use FilePathTest qw(
    _run_for_warning
    _run_for_verbose
    _cannot_delete_safe_mode
    _verbose_expected
    create_3_level_subdirs
    cleanup_3_level_subdirs
);
use Errno qw(:POSIX);
use Carp;
a19 7
my $fchmod_supported = 0;
if (open my $fh, curdir()) {
    my ($perm) = (stat($fh))[2];
    $perm &= 07777;
    eval { $fchmod_supported = chmod( $perm, $fh); };
}

d301 2
a302 4
SKIP: {
    skip "fchmod of directories not supported on this platform", 3 unless $fchmod_supported;
    $dir = catdir($tmp_base,'G');
    $dir = VMS::Filespec::unixify($dir) if $Is_VMS;
d304 1
a304 1
    @@created = mkpath($dir, undef, 0400);
d306 1
a306 1
    is(scalar(@@created), 1, "created read-only dir");
d308 1
a308 1
    is($created[0], $dir, "created read-only directory cross-check");
d310 1
a310 2
    is(rmtree($dir), 1, "removed read-only dir");
}
d452 1
a452 1
    my $skip_count = 18;
a457 2
    skip "fchmod() on directories is not supported on this platform", $skip_count
        unless $fchmod_supported;
d461 5
a465 5
      0777, 0700, 0470, 0407,
      0433, 0400, 0430, 0403,
      0111, 0100, 0110, 0101,
      0731, 0713, 0317, 0371,
      0173, 0137);
d468 1
a471 1
        $dir = catdir($tmp_base, sprintf("chmod_test%04o", $input));
d479 1
a479 5
        SKIP: {
	    skip "permissions are not fully supported by the filesystem", 1
                if (($^O eq 'MSWin32' || $^O eq 'cygwin') && ((Win32::FsType())[1] & 8) == 0);
            is($octal_mode,$input, "create a new directory with chmod $input ($octal_input)");
	    }
d590 8
a597 7
        my $warn = _run_for_warning( sub {
            my @@created = make_path(
                $dir,
                $dir2,
                { mode => 0711, foo => 1, bar => 1 }
            );
        } );
d599 1
a599 1
            qr/Unrecognized option\(s\) passed to mkpath\(\) or make_path\(\):.*?bar.*?foo/,
d605 8
a612 7
        my $warn = _run_for_warning( sub {
            my @@created = remove_tree(
                $dir,
                $dir2,
                { foo => 1, bar => 1 }
            );
        } );
d659 1
a659 1
    local $! = ENOENT;
a730 183
}

{
    # https://rt.cpan.org/Ticket/Display.html?id=117019
    # remove_tree(): Permit re-use of options hash without issuing a warning

    my ($least_deep, $next_deepest, $deepest) =
        create_3_level_subdirs( qw| a b c | );
    my @@created;
    @@created = File::Path::make_path($deepest, { mode => 0711 });
    is(scalar(@@created), 3, "Created 3 subdirectories");

    my $x = '';
    my $opts = { error => \$x };
    File::Path::remove_tree($deepest, $opts);
    ok(! -d $deepest, "directory '$deepest' removed, as expected");

    my $warn;
    $warn = _run_for_warning( sub { File::Path::remove_tree($next_deepest, $opts); } );
    ok(! $warn, "CPAN 117019: No warning thrown when re-using \$opts");
    ok(! -d $next_deepest, "directory '$next_deepest' removed, as expected");

    $warn = _run_for_warning( sub { File::Path::remove_tree($least_deep, $opts); } );
    ok(! $warn, "CPAN 117019: No warning thrown when re-using \$opts");
    ok(! -d $least_deep, "directory '$least_deep' removed, as expected");
}

{
    # Corner cases with respect to arguments provided to functions
    my $count;

    $count = remove_tree();
    is($count, 0,
        "If not provided with any paths, remove_tree() will return a count of 0 things deleted");

    $count = remove_tree('');
    is($count, 0,
        "If not provided with any paths, remove_tree() will return a count of 0 things deleted");

    my $warn;
    $warn = _run_for_warning( sub { $count = rmtree(); } );
    like($warn, qr/No root path\(s\) specified/s, "Got expected carp");
    is($count, 0,
        "If not provided with any paths, remove_tree() will return a count of 0 things deleted");

    $warn = _run_for_warning( sub {$count = rmtree(undef); } );
    like($warn, qr/No root path\(s\) specified/s, "Got expected carp");
    is($count, 0,
        "If provided only with an undefined value, remove_tree() will return a count of 0 things deleted");

    $warn = _run_for_warning( sub {$count = rmtree(''); } );
    like($warn, qr/No root path\(s\) specified/s, "Got expected carp");
    is($count, 0,
        "If provided with an empty string for a path, remove_tree() will return a count of 0 things deleted");

    $count = make_path();
    is($count, 0,
        "If not provided with any paths, make_path() will return a count of 0 things created");

    $count = mkpath();
    is($count, 0,
        "If not provided with any paths, make_path() will return a count of 0 things created");
}

SKIP: {
    my $skip_count = 5;
    skip "Windows will not set this error condition", $skip_count
        if $^O eq 'MSWin32';

    # mkpath() with hashref:  case of phony user
    my ($least_deep, $next_deepest, $deepest) =
        create_3_level_subdirs( qw| d e f | );
    my (@@created, $error);
    my $user = join('_' => 'foobar', $$);
    @@created = mkpath($deepest, { mode => 0711, user => $user, error => \$error });
    TODO: {
        local $TODO = "Notwithstanding the phony 'user', mkpath will actually create subdirectories; should it?";
        is(scalar(@@created), 0, "No subdirectories created");
    }
    is(scalar(@@$error), 1, "caught error condition" );
    my ($file, $message) = each %{$error->[0]};
    like($message,
        qr/unable to map $user to a uid, ownership not changed/s,
        "Got expected error message for phony user",
    );

    cleanup_3_level_subdirs($least_deep);
}

{
    # mkpath() with hashref:  case of valid uid
    my ($least_deep, $next_deepest, $deepest) =
        create_3_level_subdirs( qw| j k l | );
    my (@@created, $error);
    @@created = mkpath($deepest, { mode => 0711, uid => $>, error => \$error });
    is(scalar(@@created), 3, "Provide valid 'uid' argument: 3 subdirectories created");

    cleanup_3_level_subdirs($least_deep);
}

SKIP: {
    my $skip_count = 3;
    skip "getpwuid() and getgrgid() not implemented on Windows", $skip_count
        if $^O eq 'MSWin32';

    # mkpath() with hashref:  case of valid owner
    my ($least_deep, $next_deepest, $deepest) =
        create_3_level_subdirs( qw| m n o | );
    my (@@created, $error);
    my $name = getpwuid($>);
    @@created = mkpath($deepest, { mode => 0711, owner => $name, error => \$error });
    is(scalar(@@created), 3, "Provide valid 'owner' argument: 3 subdirectories created");

    cleanup_3_level_subdirs($least_deep);
}

SKIP: {
    my $skip_count = 5;
    skip "Windows will not set this error condition", $skip_count
        if $^O eq 'MSWin32';

    # mkpath() with hashref:  case of phony group
    my ($least_deep, $next_deepest, $deepest) =
        create_3_level_subdirs( qw| p q r | );
    my (@@created, $error);
    my $bad_group = join('_' => 'foobarbaz', $$);
    @@created = mkpath($deepest, { mode => 0711, group => $bad_group, error => \$error });
    TODO: {
        local $TODO = "Notwithstanding the phony 'group', mkpath will actually create subdirectories; should it?";
        is(scalar(@@created), 0, "No subdirectories created");
    }
    is(scalar(@@$error), 1, "caught error condition" );
    my ($file, $message) = each %{$error->[0]};
    like($message,
        qr/unable to map $bad_group to a gid, group ownership not changed/s,
        "Got expected error message for phony user",
    );

    cleanup_3_level_subdirs($least_deep);
}

{
    # mkpath() with hashref:  case of valid group
    my ($least_deep, $next_deepest, $deepest) =
        create_3_level_subdirs( qw| s t u | );
    my (@@created, $error);
    @@created = mkpath($deepest, { mode => 0711, group => $(, error => \$error });
    is(scalar(@@created), 3, "Provide valid 'group' argument: 3 subdirectories created");

    cleanup_3_level_subdirs($least_deep);
}

SKIP: {
    my $skip_count = 3;
    skip "getpwuid() and getgrgid() not implemented on Windows", $skip_count
        if $^O eq 'MSWin32';

    # mkpath() with hashref:  case of valid group
    my ($least_deep, $next_deepest, $deepest) =
        create_3_level_subdirs( qw| v w x | );
    my (@@created, $error);
    my $group_name = (getgrgid($())[0];
    @@created = mkpath($deepest, { mode => 0711, group => $group_name, error => \$error });
    is(scalar(@@created), 3, "Provide valid 'group' argument: 3 subdirectories created");

    cleanup_3_level_subdirs($least_deep);
}

SKIP: {
    my $skip_count = 3;
    skip "getpwuid() and getgrgid() not implemented on Windows", $skip_count
        if $^O eq 'MSWin32';

    # mkpath() with hashref:  case of valid owner and group
    my ($least_deep, $next_deepest, $deepest) =
        create_3_level_subdirs( qw| delta epsilon zeta | );
    my (@@created, $error);
    my $name = getpwuid($>);
    my $group_name = (getgrgid($())[0];
    @@created = mkpath($deepest, { mode => 0711, owner => $name, group => $group_name, error => \$error });
    is(scalar(@@created), 3, "Provide valid 'owner' and 'group' 'group' arguments: 3 subdirectories created");

    cleanup_3_level_subdirs($least_deep);
@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@d6 1
a6 1
use Test::More tests => 127;
d9 11
a19 2
use lib 't/';
use FilePathTest;
d29 7
d317 4
a320 2
$dir = catdir($tmp_base,'G');
$dir = VMS::Filespec::unixify($dir) if $Is_VMS;
d322 1
a322 1
@@created = mkpath($dir, undef, 0200);
d324 1
a324 1
is(scalar(@@created), 1, "created write-only dir");
d326 1
a326 1
is($created[0], $dir, "created write-only directory cross-check");
d328 2
a329 1
is(rmtree($dir), 1, "removed write-only dir");
d471 1
a471 1
    my $skip_count = 19;
d477 2
d482 5
a486 5
      0777, 0700, 0070, 0007,
      0333, 0300, 0030, 0003,
      0111, 0100, 0010, 0001,
      0731, 0713, 0317, 0371, 0173, 0137,
      00 );
a488 1
    $dir = catdir($tmp_base, 'chmod_test');
d492 1
d500 5
a504 1
        is($octal_mode,$input, "create a new directory with chmod $input ($octal_input)");
d615 7
a621 8
        my $warn;
        $SIG{__WARN__} = sub { $warn = shift };

        my @@created = make_path(
            $dir,
            $dir2,
            { mode => 0711, foo => 1, bar => 1 }
        );
d623 1
a623 1
            qr/Unrecognized option\(s\) passed to make_path\(\):.*?bar.*?foo/,
d629 7
a635 8
        my $warn;
        $SIG{__WARN__} = sub { $warn = shift };

        my @@created = remove_tree(
            $dir,
            $dir2,
            { foo => 1, bar => 1 }
        );
d682 1
a682 1
    local $! = 2;
d754 183
@


1.1
log
@Initial revision
@
text
@d1 1
d6 1
a6 1
use Test::More tests => 129;
d8 3
a17 3
eval "use Test::Output";
my $has_Test_Output = $@@ ? 0 : 1;

d28 1
d33 1
d114 1
d127 1
d133 1
d141 1
d162 1
d167 1
d172 1
d174 1
d176 1
d187 1
d192 1
d194 1
d198 1
d206 1
d208 1
d212 1
d220 1
d222 1
d226 1
d229 2
d232 2
a233 2
my $removed = $Is_VMS ? 0 : 1;
is($count, $removed, "removed directory safe mode");
d240 1
d242 1
d244 1
d248 1
d263 1
d265 1
d270 1
d278 1
d280 1
d282 1
d286 1
d288 1
d290 1
d294 1
d296 1
d298 1
d305 1
d307 1
d309 1
d324 1
d328 1
d332 1
d336 1
d340 1
d344 1
d347 18
a372 17
    skip "This is not a MSWin32 platform", 1
        unless $^O eq 'MSWin32';

    my $UNC_path_taint = $ENV{PERL_FILE_PATH_UNC_TESTDIR};
    skip "PERL_FILE_PATH_UNC_TESTDIR environment variable not set", 1
        unless defined($UNC_path_taint);

    my ($UNC_path) = ($UNC_path_taint =~ m{^([/\\]{2}\w+[/\\]\w+[/\\]\w+)$});
    
    skip "PERL_FILE_PATH_UNC_TESTDIR environment variable does not point to a directory", 1
        unless -d $UNC_path;
    
    my $removed = rmtree($UNC_path);
    cmp_ok($removed, '>', 0, "removed $removed entries from $UNC_path");
}

SKIP: {
d374 1
a374 1
    skip "Don't need Force_Writeable semantics on $^O", 4
d376 1
a376 1
    skip "Symlinks not available", 4 unless $Config{d_symlink};
d380 2
a381 1
    is(scalar @@created, 1, 'bug 487319 setup');
d383 1
d391 1
d395 3
a397 1
    my $file = catfile($dir, 'file');
d401 2
a405 1
    my $file2 = catfile($dir, 'symlink');
d407 2
d412 1
d416 1
d421 3
a423 1
    my $entry = catdir($tmp_base, "file");
a440 47
my $extra =  catdir(curdir(), qw(EXTRA 1 a));

SKIP: {
    skip "extra scenarios not set up, see eg/setup-extra-tests", 14
        unless -e $extra;
    skip "Symlinks not available", 14 unless $Config{d_symlink};

    my ($list, $err);
    $dir = catdir( 'EXTRA', '1' );
    rmtree( $dir, {result => \$list, error => \$err} );
    is(scalar(@@$list), 2, "extra dir $dir removed");
    is(scalar(@@$err), 1, "one error encountered");

    $dir = catdir( 'EXTRA', '3', 'N' );
    rmtree( $dir, {result => \$list, error => \$err} );
    is( @@$list, 1, q{remove a symlinked dir} );
    is( @@$err,  0, q{with no errors} );

    $dir = catdir('EXTRA', '3', 'S');
    rmtree($dir, {error => \$error});
    is( scalar(@@$error), 1, 'one error for an unreadable dir' );
    eval { ($file, $message) = each %{$error->[0]}};
    is( $file, $dir, 'unreadable dir reported in error' )
        or diag($message);

    $dir = catdir('EXTRA', '3', 'T');
    rmtree($dir, {error => \$error});
    is( scalar(@@$error), 1, 'one error for an unreadable dir T' );
    eval { ($file, $message) = each %{$error->[0]}};
    is( $file, $dir, 'unreadable dir reported in error T' );

    $dir = catdir( 'EXTRA', '4' );
    rmtree($dir,  {result => \$list, error => \$err} );
    is( scalar(@@$list), 0, q{don't follow a symlinked dir} );
    is( scalar(@@$err),  2, q{two errors when removing a symlink in r/o dir} );
    eval { ($file, $message) = each %{$err->[0]} };
    is( $file, $dir, 'symlink reported in error' );

    $dir  = catdir('EXTRA', '3', 'U');
    $dir2 = catdir('EXTRA', '3', 'V');
    rmtree($dir, $dir2, {verbose => 0, error => \$err, result => \$list});
    is( scalar(@@$list),  1, q{deleted 1 out of 2 directories} );
    is( scalar(@@$error), 1, q{left behind 1 out of 2 directories} );
    eval { ($file, $message) = each %{$err->[0]} };
    is( $file, $dir, 'first dir reported in error' );
}

d451 30
a480 21
SKIP: {
    my $skip_count = 8; # DRY
    skip "getpwent() not implemented on $^O", $skip_count
        unless $Config{d_getpwent};
    skip "getgrent() not implemented on $^O", $skip_count
        unless $Config{d_getgrent};
    skip 'not running as root', $skip_count
        unless $< == 0;
    skip "darwin's nobody and nogroup are -1", $skip_count
        if $^O eq 'darwin';

    my $dir_stem = $dir = catdir($tmp_base, 'owned-by');

    # find the highest uid ('nobody' or similar)
    my $max_uid   = 0;
    my $max_user = undef;
    while (my @@u = getpwent()) {
        if ($max_uid < $u[2]) {
            $max_uid  = $u[2];
            $max_user = $u[0];
        }
d482 11
a492 2
    skip 'getpwent() appears to be insane', $skip_count
        unless $max_uid > 0;
d494 25
a518 11
    # find the highest gid ('nogroup' or similar)
    my $max_gid   = 0;
    my $max_group = undef;
    while (my @@g = getgrent()) {
        if ($max_gid < $g[2]) {
            $max_gid = $g[2];
            $max_group = $g[0];
        }
    }
    skip 'getgrent() appears to be insane', $skip_count
        unless $max_gid > 0;
d520 4
a523 36
    $dir = catdir($dir_stem, 'aaa');
    @@created = make_path($dir, {owner => $max_user});
    is(scalar(@@created), 2, "created a directory owned by $max_user...");
    my $dir_uid = (stat $created[0])[4];
    is($dir_uid, $max_uid, "... owned by $max_uid");

    $dir = catdir($dir_stem, 'aab');
    @@created = make_path($dir, {group => $max_group});
    is(scalar(@@created), 1, "created a directory owned by group $max_group...");
    my $dir_gid = (stat $created[0])[5];
    is($dir_gid, $max_gid, "... owned by group $max_gid");

    $dir = catdir($dir_stem, 'aac');
    @@created = make_path($dir, {user => $max_user, group => $max_group});
    is(scalar(@@created), 1, "created a directory owned by $max_user:$max_group...");
    ($dir_uid, $dir_gid) = (stat $created[0])[4,5];
    is($dir_uid, $max_uid, "... owned by $max_uid");
    is($dir_gid, $max_gid, "... owned by group $max_gid");

    SKIP: {
        skip 'Test::Output not available', 1
               unless $has_Test_Output;

        # invent a user and group that don't exist
        do { ++$max_user  } while (getpwnam($max_user));
        do { ++$max_group } while (getgrnam($max_group));

        $dir = catdir($dir_stem, 'aad');
        stderr_like(
            sub {make_path($dir, {user => $max_user, group => $max_group})},
            qr{\Aunable to map $max_user to a uid, ownership not changed: .* at \S+ line \d+
unable to map $max_group to a gid, group ownership not changed: .* at \S+ line \d+\b},
            "created a directory not owned by $max_user:$max_group..."
        );
    }
}
d525 2
a526 3
SKIP: {
    skip 'Test::Output not available', 14
        unless $has_Test_Output;
d528 4
a531 11
    SKIP: {
        $dir = catdir('EXTRA', '3');
        skip "extra scenarios not set up, see eg/setup-extra-tests", 3
            unless -e $dir;

        $dir = catdir('EXTRA', '3', 'U');
        stderr_like( 
            sub {rmtree($dir, {verbose => 0})},
            qr{\Acannot make child directory read-write-exec for [^:]+: .* at \S+ line \d+},
            q(rmtree can't chdir into root dir)
        );
d533 2
a534 9
        $dir = catdir('EXTRA', '3');
        stderr_like( 
            sub {rmtree($dir, {})},
            qr{\Acannot make child directory read-write-exec for [^:]+: .* at (\S+) line (\d+)
cannot make child directory read-write-exec for [^:]+: .* at \1 line \2
cannot make child directory read-write-exec for [^:]+: .* at \1 line \2
cannot remove directory for [^:]+: .* at \1 line \2},
            'rmtree with file owned by root'
        );
d536 6
a541 15
        stderr_like( 
            sub {rmtree('EXTRA', {})},
            qr{\Acannot remove directory for [^:]+: .* at (\S+) line (\d+)
cannot remove directory for [^:]+: .* at \1 line \2
cannot make child directory read-write-exec for [^:]+: .* at \1 line \2
cannot make child directory read-write-exec for [^:]+: .* at \1 line \2
cannot make child directory read-write-exec for [^:]+: .* at \1 line \2
cannot remove directory for [^:]+: .* at \1 line \2
cannot unlink file for [^:]+: .* at \1 line \2
cannot restore permissions to \d+ for [^:]+: .* at \1 line \2
cannot make child directory read-write-exec for [^:]+: .* at \1 line \2
cannot remove directory for [^:]+: .* at \1 line \2},
            'rmtree with insufficient privileges'
        );
    }
d543 2
a544 9
    my $base = catdir($tmp_base,'output');
    $dir  = catdir($base,'A');
    $dir2 = catdir($base,'B');

    stderr_like(
        sub { rmtree( undef, 1 ) },
        qr/\ANo root path\(s\) specified\b/,
        "rmtree of nothing carps sensibly"
    );
d546 5
a550 5
    stderr_like(
        sub { rmtree( '', 1 ) },
        qr/\ANo root path\(s\) specified\b/,
        "rmtree of empty dir carps sensibly"
    );
d552 2
a553 2
    stderr_is( sub { make_path() }, '', "make_path no args does not carp" );
    stderr_is( sub { remove_tree() }, '', "remove_tree no args does not carp" );
d555 7
a561 5
    stdout_is(
        sub {@@created = mkpath($dir, 1)},
        "mkdir $base\nmkdir $dir\n",
        'mkpath verbose (old style 1)'
    );
d563 5
a567 5
    stdout_is(
        sub {@@created = mkpath([$dir2], 1)},
        "mkdir $dir2\n",
        'mkpath verbose (old style 2)'
    );
d569 10
a578 4
    stdout_is(
        sub {$count = rmtree([$dir, $dir2], 1, 1)},
        "rmdir $dir\nrmdir $dir2\n",
        'rmtree verbose (old style)'
d580 3
d584 4
a587 5
    stdout_is(
        sub {@@created = mkpath($dir, {verbose => 1, mask => 0750})},
        "mkdir $dir\n",
        'mkpath verbose (new style 1)'
    );
d589 3
a591 5
    stdout_is(
        sub {@@created = mkpath($dir2, 1, 0771)},
        "mkdir $dir2\n",
        'mkpath verbose (new style 2)'
    );
d593 8
a600 12
    SKIP: {
        $file = catdir($dir2, "file");
        skip "Cannot create $file", 2 unless open OUT, "> $file";
        print OUT "test file, safe to delete\n", scalar(localtime), "\n";
        close OUT;

        ok(-e $file, "file created in directory");

        stdout_is(
            sub {$count = rmtree($dir, $dir2, {verbose => 1, safe => 1})},
            "rmdir $dir\nunlink $file\nrmdir $dir2\n",
            'rmtree safe verbose (new style)'
a602 1
}
d604 3
a606 3
SKIP: {
    skip "extra scenarios not set up, see eg/setup-extra-tests", 11
        unless -d catdir(qw(EXTRA 1));
d608 9
a616 15
    rmtree 'EXTRA', {safe => 0, error => \$error};
    is( scalar(@@$error), 10, 'seven deadly sins' ); # well there used to be 7

    rmtree 'EXTRA', {safe => 1, error => \$error};
    is( scalar(@@$error), 9, 'safe is better' );
    for (@@$error) {
        ($file, $message) = each %$_;
        if ($file =~  /[123]\z/) {
            is(index($message, 'cannot remove directory: '), 0, "failed to remove $file with rmdir")
                or diag($message);
        }
        else {
            like($message, qr(\Acannot (?:restore permissions to \d+|chdir to child|unlink file): ), "failed to remove $file with unlink")
                or diag($message)
        }
d626 1
a626 1
    
d630 1
a630 1
    
d635 4
a638 2
         ok(chdir($p), "... now chdir $p");
         ok(rmtree($xx), "... and finally rmtree $xx");
d640 1
a640 1
    
d645 86
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@Import perl-5.24.2
@
text
@a0 1
#! /usr/bin/env perl
d5 1
a5 1
use Test::More tests => 127;
a6 3
use Fcntl ':mode';
use lib 't/';
use FilePathTest;
d14 3
a26 1

a30 1

a110 1

a122 1

a127 1

a134 1

a154 1

a158 1

a162 1

a163 1

a164 1

a174 1

a178 1

a179 1

a182 1

a189 1

a190 1

a193 1

a200 1

a201 1

a204 1

a206 2
my $expected_count = _cannot_delete_safe_mode($dir2) ? 0 : 1;

d208 2
a209 2

is($count, $expected_count, "removed directory safe mode");
a215 1

a216 1

a217 1

a220 1

a234 1

a235 1

a239 1

a246 1

a247 1

a248 1

a251 1

a252 1

a253 1

a256 1

a257 1

a258 1

a264 1

a265 1

a266 1

a280 1

a283 1

a286 1

a289 1

a292 1

a295 1

a297 18
$dir = catdir("a\nb", 'd1');
$dir2 = catdir("a\nb", 'd2');

SKIP: {
  # Better to search for *nix derivatives?
  # Not sure what else doesn't support newline in paths
  skip "$^O doesn't allow newline in paths", 2
    if $^O =~ m/^(MSWin32|VMS)$/;

  @@created = make_path( $dir, $dir2 );

  is(scalar @@created, 3, 'new-style 3 dirs created in parent with newline');

  $count = remove_tree( $dir, $dir2 );

  is($count, 2, 'new-style 2 dirs removed in parent with newline');
}

d306 17
d324 1
a324 1
    skip "Don't need Force_Writeable semantics on $^O", 6
d326 1
a326 1
    skip "Symlinks not available", 6 unless $Config{d_symlink};
d330 1
a330 2

    is( scalar @@created, 1, 'bug 487319 setup' );
a331 1

a338 1

d342 1
a342 3
    #my $file = catfile($dir, 'file');
    my $file  = 'bug487319-file';
    my $file2 = 'bug487319-file-symlink';
a345 2
    ok(-e $file, 'file exists');

d349 1
a350 2

    ok(-e $file2, 'file2 exists');
a353 1

a356 1
    remove_tree($file);
d361 1
a361 3
    my $entry = catfile($tmp_base, "file");
    skip "VMS can have a file and a directory with the same name.", 4
        if $Is_VMS;
d379 47
d436 21
a456 30
SKIP : {
    my $skip_count = 19;
    # this test will fail on Windows, as per:
    #   http://perldoc.perl.org/perlport.html#chmod

    skip "Windows chmod test skipped", $skip_count
        if $^O eq 'MSWin32';
    my $mode;
    my $octal_mode;
    my @@inputs = (
      0777, 0700, 0070, 0007,
      0333, 0300, 0030, 0003,
      0111, 0100, 0010, 0001,
      0731, 0713, 0317, 0371, 0173, 0137,
      00 );
    my $input;
    my $octal_input;
    $dir = catdir($tmp_base, 'chmod_test');

    foreach (@@inputs) {
        $input = $_;
        # We can skip from here because 0 is last in the list.
        skip "Mode of 0 means assume user defaults on VMS", 1
          if ($input == 0 && $Is_VMS);
        @@created = mkpath($dir, {chmod => $input});
        $mode = (stat($dir))[2];
        $octal_mode = S_IMODE($mode);
        $octal_input = sprintf "%04o", S_IMODE($input);
        is($octal_mode,$input, "create a new directory with chmod $input ($octal_input)");
        rmtree( $dir );
d458 2
a459 1
}
d461 11
a471 9
my $dir_base = catdir($tmp_base,'output');
my $dir_a    = catdir($dir_base, 'A');
my $dir_b    = catdir($dir_base, 'B');

is(_run_for_verbose(sub {@@created = mkpath($dir_a, 1)}),
    _verbose_expected('mkpath', $dir_base, 0, 1)
    . _verbose_expected('mkpath', $dir_a, 0),
    'mkpath verbose (old style 1)'
);
d473 36
a508 4
is(_run_for_verbose(sub {@@created = mkpath([$dir_b], 1)}),
    _verbose_expected('mkpath', $dir_b, 0),
    'mkpath verbose (old style 2)'
);
d510 3
a512 1
my $verbose_expected;
d514 11
a524 8
# Must determine expectations while directories still exist.
$verbose_expected = _verbose_expected('rmtree', $dir_a, 1)
                  . _verbose_expected('rmtree', $dir_b, 1);

is(_run_for_verbose(sub {$count = rmtree([$dir_a, $dir_b], 1, 1)}),
    $verbose_expected,
    'rmtree verbose (old style)'
);
d526 9
a534 9
# In case we didn't delete them in safe mode.
rmtree($dir_a) if -d $dir_a;
rmtree($dir_b) if -d $dir_b;

is(_run_for_verbose(sub {@@created = mkpath( $dir_a,
                                            {verbose => 1, mask => 0750})}),
    _verbose_expected('mkpath', $dir_a, 0),
    'mkpath verbose (new style 1)'
);
d536 15
a550 4
is(_run_for_verbose(sub {@@created = mkpath($dir_b, 1, 0771)}),
    _verbose_expected('mkpath', $dir_b, 0),
    'mkpath verbose (new style 2)'
);
d552 9
a560 2
$verbose_expected = _verbose_expected('rmtree', $dir_a, 1)
                  . _verbose_expected('rmtree', $dir_b, 1);
d562 5
a566 4
is(_run_for_verbose(sub {$count = rmtree([$dir_a, $dir_b], 1, 1)}),
    $verbose_expected,
    'again: rmtree verbose (old style)'
);
d568 2
a569 2
rmtree($dir_a) if -d $dir_a;
rmtree($dir_b) if -d $dir_b;
d571 5
a575 6
is(_run_for_verbose(sub {@@created = make_path( $dir_a, $dir_b,
                                               {verbose => 1, mode => 0711});}),
      _verbose_expected('make_path', $dir_a, 1)
    . _verbose_expected('make_path', $dir_b, 1),
    'make_path verbose with final hashref'
);
d577 5
a581 2
$verbose_expected = _verbose_expected('remove_tree', $dir_a, 0)
                  . _verbose_expected('remove_tree', $dir_b, 0);
d583 5
a587 5
is(_run_for_verbose(sub {@@created = remove_tree( $dir_a, $dir_b,
                                                 {verbose => 1});}),
    $verbose_expected,
    'remove_tree verbose with final hashref'
);
d589 5
a593 10
rmtree($dir_a) if -d $dir_a;
rmtree($dir_b) if -d $dir_b;

# Have to re-create these 2 directories so that next block is not skipped.
@@created = make_path(
    $dir_a,
    $dir_b,
    { mode => 0711 }
);
is(@@created, 2, "2 directories created");
d595 4
a598 16
SKIP: {
    $file = catfile($dir_b, "file");
    skip "Cannot create $file", 2 unless open OUT, "> $file";
    print OUT "test file, safe to delete\n", scalar(localtime), "\n";
    close OUT;

    $verbose_expected = _verbose_expected('rmtree', $dir_a, 1)
                      . _verbose_expected('unlink', $file, 0)
                      . _verbose_expected('rmtree', $dir_b, 1);

    ok(-e $file, "file created in directory");

    is(_run_for_verbose(sub {$count = rmtree( $dir_a, $dir_b,
                                              {verbose => 1, safe => 1})}),
        $verbose_expected,
        'rmtree safe verbose (new style)'
a599 3
    rmtree($dir_a) if -d $dir_a;
    rmtree($dir_b) if -d $dir_b;
}
d601 12
a612 17
{
    my $base = catdir( $tmp_base, 'output2');
    my $dir  = catdir( $base, 'A');
    my $dir2 = catdir( $base, 'B');

    {
        my $warn;
        $SIG{__WARN__} = sub { $warn = shift };

        my @@created = make_path(
            $dir,
            $dir2,
            { mode => 0711, foo => 1, bar => 1 }
        );
        like($warn,
            qr/Unrecognized option\(s\) passed to make_path\(\):.*?bar.*?foo/,
            'make_path with final hashref warned due to unrecognized options'
d615 5
d621 2
a622 3
    {
        my $warn;
        $SIG{__WARN__} = sub { $warn = shift };
d624 12
a635 9
        my @@created = remove_tree(
            $dir,
            $dir2,
            { foo => 1, bar => 1 }
        );
        like($warn,
            qr/Unrecognized option\(s\) passed to remove_tree\(\):.*?bar.*?foo/,
            'remove_tree with final hashref failed due to unrecognized options'
        );
d645 1
a645 1

d649 1
a649 1

d654 2
a655 4
#         ok(chdir($p), "... now chdir $p");
#         ok(rmtree($xx), "... and finally rmtree $xx");
       chdir($p);
       rmtree($xx);
d657 1
a657 1

a661 86
    chdir updir();
}

my $windows_dir = 'C:\Path\To\Dir';
my $expect = 'c:/path/to/dir';
is(
    File::Path::_slash_lc($windows_dir),
    $expect,
    "Windows path unixified as expected"
);

{
    my ($x, $message, $object, $expect, $rv, $arg, $error);
    my ($k, $v, $second_error, $third_error);
    local $! = 2;
    $x = $!;

    $message = 'message in a bottle';
    $object = '/path/to/glory';
    $expect = "$message for $object: $x";
    $rv = _run_for_warning( sub {
        File::Path::_error(
            {},
            $message,
            $object
        );
    } );
    like($rv, qr/^$expect/,
        "no \$arg->{error}: defined 2nd and 3rd args: got expected error message");

    $object = undef;
    $expect = "$message: $x";
    $rv = _run_for_warning( sub {
        File::Path::_error(
            {},
            $message,
            $object
        );
    } );
    like($rv, qr/^$expect/,
        "no \$arg->{error}: defined 2nd arg; undefined 3rd arg: got expected error message");

    $message = 'message in a bottle';
    $object = undef;
    $expect = "$message: $x";
    $arg = { error => \$error };
    File::Path::_error(
        $arg,
        $message,
        $object
    );
    is(ref($error->[0]), 'HASH',
        "first element of array inside \$error is hashref");
    ($k, $v) = %{$error->[0]};
    is($k, '', 'key of hash is empty string, since 3rd arg was undef');
    is($v, $expect, "value of hash is 2nd arg: $message");

    $message = '';
    $object = '/path/to/glory';
    $expect = "$message: $x";
    $arg = { error => \$second_error };
    File::Path::_error(
        $arg,
        $message,
        $object
    );
    is(ref($second_error->[0]), 'HASH',
        "first element of array inside \$second_error is hashref");
    ($k, $v) = %{$second_error->[0]};
    is($k, $object, "key of hash is '$object', since 3rd arg was defined");
    is($v, $expect, "value of hash is 2nd arg: $message");

    $message = '';
    $object = undef;
    $expect = "$message: $x";
    $arg = { error => \$third_error };
    File::Path::_error(
        $arg,
        $message,
        $object
    );
    is(ref($third_error->[0]), 'HASH',
        "first element of array inside \$third_error is hashref");
    ($k, $v) = %{$third_error->[0]};
    is($k, '', "key of hash is empty string, since 3rd arg was undef");
    is($v, $expect, "value of hash is 2nd arg: $message");
@

