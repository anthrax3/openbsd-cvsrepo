head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.4.0.10
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.4
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.6
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.31.56;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2010.09.24.14.49.05;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.05;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.06.48;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.49;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.52.42;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/* Filename: Zlib.xs
 * Author  : Paul Marquess, <pmqs@@cpan.org>
 * Created : 22nd January 1996
 * Version : 2.000
 *
 *   Copyright (c) 1995-2013 Paul Marquess. All rights reserved.
 *   This program is free software; you can redistribute it and/or
 *   modify it under the same terms as Perl itself.
 *
 */

/* Parts of this code are based on the files gzio.c and gzappend.c from 
 * the standard zlib source distribution. Below are the copyright statements
 * from each. 
 */

/* gzio.c -- IO on .gz files
 * Copyright (C) 1995 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* gzappend -- command to append to a gzip file

  Copyright (C) 2003 Mark Adler, all rights reserved
  version 1.1, 4 Nov 2003
*/


#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "zlib.h" 

/* zlib prior to 1.06 doesn't know about z_off_t */
#ifndef z_off_t
#  define z_off_t   long
#endif

#if  ! defined(ZLIB_VERNUM) || ZLIB_VERNUM < 0x1200
#  define NEED_DUMMY_BYTE_AT_END 
#endif

#if  defined(ZLIB_VERNUM) && ZLIB_VERNUM >= 0x1210
#  define MAGIC_APPEND
#  define AT_LEAST_ZLIB_1_2_1
#endif

#if  defined(ZLIB_VERNUM) && ZLIB_VERNUM >= 0x1221
#  define AT_LEAST_ZLIB_1_2_2_1
#endif

#if  defined(ZLIB_VERNUM) && ZLIB_VERNUM >= 0x1222
#  define AT_LEAST_ZLIB_1_2_2_2
#endif

#if  defined(ZLIB_VERNUM) && ZLIB_VERNUM >= 0x1223
#  define AT_LEAST_ZLIB_1_2_2_3
#endif

#if  defined(ZLIB_VERNUM) && ZLIB_VERNUM >= 0x1230
#  define AT_LEAST_ZLIB_1_2_3
#endif

#if  defined(ZLIB_VERNUM) && ZLIB_VERNUM >= 0x1252
/* 
    Use Z_SOLO to build source means need own malloc/free
 */
#  define AT_LEAST_ZLIB_1_2_5_2
#endif

#if  defined(ZLIB_VERNUM) && ZLIB_VERNUM >= 0x1280
#  define AT_LEAST_ZLIB_1_2_8
#endif

#ifdef USE_PPPORT_H
#  define NEED_sv_2pvbyte
#  define NEED_sv_2pv_nolen
#  define NEED_sv_pvn_force_flags
#  include "ppport.h"
#endif

#if PERL_REVISION == 5 && PERL_VERSION == 9
    /* For Andreas */
#   define sv_pvbyte_force(sv,lp) sv_pvbyten_force(sv,lp)
#endif

#if PERL_REVISION == 5 && (PERL_VERSION < 8 || (PERL_VERSION == 8 && PERL_SUBVERSION < 4 ))

#    ifdef SvPVbyte_force
#        undef SvPVbyte_force
#    endif

#    define SvPVbyte_force(sv,lp) SvPV_force(sv,lp)

#endif

#ifndef SvPVbyte_nolen
#    define SvPVbyte_nolen SvPV_nolen
#endif



#if 0
#  ifndef SvPVbyte_nolen
#    define SvPVbyte_nolen SvPV_nolen
#  endif

#  ifndef SvPVbyte_force
#    define SvPVbyte_force(sv,lp) SvPV_force(sv,lp)
#  endif
#endif

#if PERL_REVISION == 5 && (PERL_VERSION >= 8 || (PERL_VERSION == 8 && PERL_SUBVERSION < 4 ))
#    define UTF8_AVAILABLE
#endif

typedef int                     DualType ;
typedef int                     int_undef ;

typedef struct di_stream {
    int      flags ;
#define FLAG_APPEND             1
#define FLAG_CRC32              2
#define FLAG_ADLER32            4
#define FLAG_CONSUME_INPUT      8
#define FLAG_LIMIT_OUTPUT       16
    uLong    crc32 ;
    uLong    adler32 ;
    z_stream stream;
    uLong     bufsize; 
    SV *     dictionary ;
    uLong    dict_adler ;
    int      last_error ;
    bool     zip_mode ;
#define SETP_BYTE
#ifdef SETP_BYTE
    bool     deflateParams_out_valid ;
    Bytef    deflateParams_out_byte;
#else
#define deflateParams_BUFFER_SIZE       0x4000
    uLong    deflateParams_out_length;
    Bytef*   deflateParams_out_buffer;
#endif
    int      Level;
    int      Method;
    int      WindowBits;
    int      MemLevel;
    int      Strategy;
    uLong    bytesInflated ;
    uLong    compressedBytes ;
    uLong    uncompressedBytes ;
#ifdef MAGIC_APPEND

#define WINDOW_SIZE 32768U

    bool     matchedEndBlock;
    Bytef*   window ;
    int      window_lastbit,  window_left,  window_full;
    unsigned window_have;
    off_t    window_lastoff, window_end;
    off_t    window_endOffset;

    uLong    lastBlockOffset ;
    unsigned char window_lastByte ;
                

#endif
} di_stream;

typedef di_stream * deflateStream ;
typedef di_stream * Compress__Raw__Zlib__deflateStream ;
typedef di_stream * inflateStream ;
typedef di_stream * Compress__Raw__Zlib__inflateStream ;
typedef di_stream * Compress__Raw__Zlib__inflateScanStream ;

#define ZMALLOC(to, typ) ((to = (typ *)safemalloc(sizeof(typ))), \
                                Zero(to,1,typ))

/* Figure out the Operating System */
#ifdef MSDOS
#  define OS_CODE  0x00
#endif

#if defined(AMIGA) || defined(AMIGAOS) || defined(__amigaos4__)
#  define OS_CODE  0x01
#endif
 
#if defined(VAXC) || defined(VMS)
#  define OS_CODE  0x02
#endif

#if 0 /* VM/CMS */
#  define OS_CODE  0x04
#endif
 
#if defined(ATARI) || defined(atarist)
#  define OS_CODE  0x05
#endif
 
#ifdef OS2
#  define OS_CODE  0x06
#endif
 
#if defined(MACOS) || defined(TARGET_OS_MAC)
#  define OS_CODE  0x07
#endif

#if 0 /* Z-System */
#  define OS_CODE  0x08
#endif
 
#if 0 /* CP/M */
#  define OS_CODE  0x09
#endif
 
#ifdef TOPS20
#  define OS_CODE  0x0a
#endif

#ifdef WIN32 /* Window 95 & Windows NT */
#  define OS_CODE  0x0b
#endif
 
#if 0 /* QDOS */
#  define OS_CODE  0x0c
#endif
 
#if 0 /* Acorn RISCOS */
#  define OS_CODE  0x0d
#endif
 
#if 0 /* ???  */
#  define OS_CODE  0x0e
#endif
 
#ifdef __50SERIES /* Prime/PRIMOS */
#  define OS_CODE  0x0F
#endif
 
/* Default to UNIX */ 
#ifndef OS_CODE
#  define OS_CODE  0x03  /* assume Unix */
#endif

#ifndef GZIP_OS_CODE
#  define GZIP_OS_CODE OS_CODE
#endif

#define adlerInitial adler32(0L, Z_NULL, 0)
#define crcInitial crc32(0L, Z_NULL, 0)

/* static const char * const my_z_errmsg[] = { */
static const char my_z_errmsg[][32] = {
    "need dictionary",     /* Z_NEED_DICT     2 */
    "stream end",          /* Z_STREAM_END    1 */
    "",                    /* Z_OK            0 */
    "file error",          /* Z_ERRNO        (-1) */
    "stream error",        /* Z_STREAM_ERROR (-2) */
    "data error",          /* Z_DATA_ERROR   (-3) */
    "insufficient memory", /* Z_MEM_ERROR    (-4) */
    "buffer error",        /* Z_BUF_ERROR    (-5) */
    "incompatible version",/* Z_VERSION_ERROR(-6) */
    ""};

#define setDUALstatus(var, err)                                         \
                sv_setnv(var, (double)err) ;                            \
                sv_setpv(var, ((err) ? GetErrorString(err) : "")) ;     \
                SvNOK_on(var);

   
#if defined(__SYMBIAN32__)
# define NO_WRITEABLE_DATA
#endif

/* Set TRACE_DEFAULT to a non-zero value to enable tracing */
#define TRACE_DEFAULT 0

#if defined(NO_WRITEABLE_DATA) || TRACE_DEFAULT == 0
#  define trace TRACE_DEFAULT
#else
  static int trace = TRACE_DEFAULT ;
#endif

/* Dodge PerlIO hiding of these functions. */
#undef printf

static char *
#ifdef CAN_PROTOTYPE
GetErrorString(int error_no)
#else
GetErrorString(error_no)
int error_no ;
#endif
{
    dTHX;
    char * errstr ;
  
    if (error_no == Z_ERRNO) {
        errstr = Strerror(errno) ;
    }
    else
        /* errstr = gzerror(fil, &error_no) ; */
        errstr = (char*) my_z_errmsg[2 - error_no]; 

    return errstr ;
}


#ifdef MAGIC_APPEND

/*
   The following two functions are taken almost directly from
   examples/gzappend.c. Only cosmetic changes have been made to conform to
   the coding style of the rest of the code in this file.
*/


/* return the greatest common divisor of a and b using Euclid's algorithm,
   modified to be fast when one argument much greater than the other, and
   coded to avoid unnecessary swapping */
static unsigned 
#ifdef CAN_PROTOTYPE
gcd(unsigned a, unsigned b)
#else
gcd(a, b)
    unsigned a;
    unsigned b;
#endif
{
    unsigned c;

    while (a && b)
        if (a > b) {
            c = b;
            while (a - c >= c)
                c <<= 1;
            a -= c;
        }
        else {
            c = a;
            while (b - c >= c)
                c <<= 1;
            b -= c;
        }
    return a + b;
}

/* rotate list[0..len-1] left by rot positions, in place */
static void 
#ifdef CAN_PROTOTYPE
rotate(unsigned char *list, unsigned len, unsigned rot)
#else
rotate(list, len, rot)
    unsigned char *list;
    unsigned len ;
    unsigned rot;
#endif
{
    unsigned char tmp;
    unsigned cycles;
    unsigned char *start, *last, *to, *from;

    /* normalize rot and handle degenerate cases */
    if (len < 2) return;
    if (rot >= len) rot %= len;
    if (rot == 0) return;

    /* pointer to last entry in list */
    last = list + (len - 1);

    /* do simple left shift by one */
    if (rot == 1) {
        tmp = *list;
        memmove(list, list + 1, len - 1);
        *last = tmp;
        return;
    }

    /* do simple right shift by one */
    if (rot == len - 1) {
        tmp = *last;
        memmove(list + 1, list, len - 1);
        *list = tmp;
        return;
    }

    /* otherwise do rotate as a set of cycles in place */
    cycles = gcd(len, rot);             /* number of cycles */
    do {
        start = from = list + cycles;   /* start index is arbitrary */
        tmp = *from;                    /* save entry to be overwritten */
        for (;;) {
            to = from;                  /* next step in cycle */
            from += rot;                /* go right rot positions */
            if (from > last) from -= len;   /* (pointer better not wrap) */
            if (from == start) break;   /* all but one shifted */
            *to = *from;                /* shift left */
        }
        *to = tmp;                      /* complete the circle */
    } while (--cycles);
}

#endif /* MAGIC_APPEND */

static void
#ifdef CAN_PROTOTYPE
DispHex(void * ptr, int length)
#else
DispHex(ptr, length)
    void * ptr;
    int length;
#endif
{
    char * p = (char*)ptr;
    int i;
    for (i = 0; i < length; ++i) {
        printf(" %02x", 0xFF & *(p+i));
    }
}


static void
#ifdef CAN_PROTOTYPE
DispStream(di_stream * s, const char * message)
#else
DispStream(s, message)
    di_stream * s;
    const char * message;
#endif
{

#if 0
    if (! trace)
        return ;
#endif

#define EnDis(f) (s->flags & f ? "Enabled" : "Disabled")

    printf("DispStream %p", s) ;
    if (message)
        printf("- %s \n", message) ;
    printf("\n") ;

    if (!s)  {
        printf("    stream pointer is NULL\n");
    }
    else     {
        printf("    stream           %p\n", &(s->stream));
        printf("           zalloc    %p\n", s->stream.zalloc);
        printf("           zfree     %p\n", s->stream.zfree);
        printf("           opaque    %p\n", s->stream.opaque);
        printf("           state     %p\n", s->stream.state);
        if (s->stream.msg)
            printf("           msg       %s\n", s->stream.msg);
        else
            printf("           msg       \n");
        printf("           next_in   %p", s->stream.next_in);
        if (s->stream.next_in){
            printf(" =>");
            DispHex(s->stream.next_in, 4);
        }
        printf("\n");

        printf("           next_out  %p", s->stream.next_out);
        if (s->stream.next_out){
            printf(" =>");
            DispHex(s->stream.next_out, 4);
        }
        printf("\n");

        printf("           avail_in  %lu\n",  (unsigned long)s->stream.avail_in);
        printf("           avail_out %lu\n",  (unsigned long)s->stream.avail_out);
        printf("           total_in  %ld\n",  s->stream.total_in);
        printf("           total_out %ld\n",  s->stream.total_out);
        printf("           adler     %ld\n",  s->stream.adler    );
        printf("    bufsize          %ld\n",  s->bufsize);
        printf("    dictionary       %p\n",   s->dictionary);
        printf("    dict_adler       0x%ld\n",s->dict_adler);
        printf("    zip_mode         %d\n",   s->zip_mode);
        printf("    crc32            0x%x\n", (unsigned)s->crc32);
        printf("    adler32          0x%x\n", (unsigned)s->adler32);
        printf("    flags            0x%x\n", s->flags);
        printf("           APPEND    %s\n",   EnDis(FLAG_APPEND));
        printf("           CRC32     %s\n",   EnDis(FLAG_CRC32));
        printf("           ADLER32   %s\n",   EnDis(FLAG_ADLER32));
        printf("           CONSUME   %s\n",   EnDis(FLAG_CONSUME_INPUT));
        printf("           LIMIT     %s\n",   EnDis(FLAG_LIMIT_OUTPUT));


#ifdef MAGIC_APPEND
        printf("    window           %p\n", s->window);
#endif
        printf("\n");

    }
}

#ifdef AT_LEAST_ZLIB_1_2_5_2
voidpf my_zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    PERL_UNUSED_VAR(opaque);
    return safemalloc(items * size);
}


void my_zcfree (voidpf opaque, voidpf ptr)
{
    PERL_UNUSED_VAR(opaque);
    safefree(ptr);
    return; 
}

#endif

static di_stream *
#ifdef CAN_PROTOTYPE
InitStream(void)
#else
InitStream()
#endif
{
    di_stream *s ;

    ZMALLOC(s, di_stream) ;

#ifdef AT_LEAST_ZLIB_1_2_5_2
    s->stream.zalloc = my_zcalloc;
    s->stream.zfree = my_zcfree;
#endif

    return s ;
}

static void
#ifdef CAN_PROTOTYPE
PostInitStream(di_stream * s, int flags, int bufsize, int windowBits)
#else
PostInitStream(s, flags, bufsize, windowBits)
    di_stream *s ;
    int flags ;
    int bufsize ;
    int windowBits ;
#endif
{
    s->bufsize = bufsize ;
    s->compressedBytes =
    s->uncompressedBytes =
    s->last_error = 0 ;
    s->flags    = flags ;
    s->zip_mode = (windowBits < 0) ;
    if (flags & FLAG_CRC32) 
        s->crc32 = crcInitial ;
    if (flags & FLAG_ADLER32) 
        s->adler32 = adlerInitial ;
}


static SV* 
#ifdef CAN_PROTOTYPE
deRef(SV * sv, const char * string)
#else
deRef(sv, string)
SV * sv ;
char * string;
#endif
{
    dTHX;
    SvGETMAGIC(sv);

    if (SvROK(sv)) {
        sv = SvRV(sv) ;
        SvGETMAGIC(sv);
        switch(SvTYPE(sv)) {
            case SVt_PVAV:
            case SVt_PVHV:
            case SVt_PVCV:
                croak("%s: buffer parameter is not a SCALAR reference", string);
            default:
                break;
        }
        if (SvROK(sv))
            croak("%s: buffer parameter is a reference to a reference", string) ;
    }

    if (!SvOK(sv))
        sv = sv_2mortal(newSVpv("", 0));

    return sv ;
}

static SV*
#ifdef CAN_PROTOTYPE
deRef_l(SV * sv, const char * string)
#else
deRef_l(sv, string)
SV * sv ;
char * string ;
#endif
{
    dTHX;
    bool wipe = 0 ;
    STRLEN na;
    
    SvGETMAGIC(sv);
    wipe = ! SvOK(sv) ;

    if (SvROK(sv)) {
        sv = SvRV(sv) ;
        SvGETMAGIC(sv);
        wipe = ! SvOK(sv) ;

        switch(SvTYPE(sv)) {
            case SVt_PVAV:
            case SVt_PVHV:
            case SVt_PVCV:
                croak("%s: buffer parameter is not a SCALAR reference", string);
            default:
                break;
        }
        if (SvROK(sv))
            croak("%s: buffer parameter is a reference to a reference", string) ;
    }

    if (SvREADONLY(sv) && PL_curcop != &PL_compiling)
        croak("%s: buffer parameter is read-only", string);

    SvUPGRADE(sv, SVt_PV);

    if (wipe)
        sv_setpv(sv, "") ;
    else
        (void)SvPVbyte_force(sv, na) ;

    return sv ;
}


#include "constants.h"

MODULE = Compress::Raw::Zlib PACKAGE = Compress::Raw::Zlib        PREFIX = Zip_

REQUIRE:	1.924
PROTOTYPES:	DISABLE

INCLUDE: constants.xs

BOOT:
    /* Check this version of zlib is == 1 */
    if (zlibVersion()[0] != '1')
	croak("Compress::Raw::Zlib needs zlib version 1.x\n") ;
	
    {
        /* Create the $os_code scalar */
        SV * os_code_sv = perl_get_sv("Compress::Raw::Zlib::gzip_os_code", GV_ADDMULTI) ;
        sv_setiv(os_code_sv, GZIP_OS_CODE) ;
    }


#define Zip_zlib_version()	(const char*)zlib_version
const char*
Zip_zlib_version()

unsigned
ZLIB_VERNUM()
    CODE:
#ifdef ZLIB_VERNUM
        RETVAL = ZLIB_VERNUM ;
#else
        /* 1.1.4 => 0x1140 */
        RETVAL  = (ZLIB_VERSION[0] - '0') << 12 ;
        RETVAL += (ZLIB_VERSION[2] - '0') <<  8 ;
        RETVAL += (ZLIB_VERSION[4] - '0') <<  4 ;
        if (strlen(ZLIB_VERSION) > 5)
            RETVAL += (ZLIB_VERSION[6] - '0')  ;
#endif
    OUTPUT:
        RETVAL


#ifndef AT_LEAST_ZLIB_1_2_1
#define zlibCompileFlags() 0
#endif
uLong
zlibCompileFlags()

MODULE = Compress::Raw::Zlib	PACKAGE = Compress::Raw::Zlib	PREFIX = Zip_

#define Zip_adler32(buf, adler) adler32(adler, buf, (uInt)len)

uLong
Zip_adler32(buf, adler=adlerInitial)
        uLong    adler = NO_INIT
        STRLEN   len = NO_INIT
        Bytef *  buf = NO_INIT
	SV *	 sv = ST(0) ;
	INIT:
    	/* If the buffer is a reference, dereference it */
	sv = deRef(sv, "adler32") ;
#ifdef UTF8_AVAILABLE    
    if (DO_UTF8(sv) && !sv_utf8_downgrade(sv, 1))
         croak("Wide character in Compress::Raw::Zlib::adler32");
#endif         
	buf = (Byte*)SvPVbyte(sv, len) ;

	if (items < 2)
	  adler = adlerInitial;
	else if (SvOK(ST(1)))
	  adler = SvUV(ST(1)) ;
	else
	  adler = adlerInitial;
    OUTPUT:
        RETVAL
 
#define Zip_crc32(buf, crc, offset) crc32(crc, buf+offset, (uInt)len-offset)

uLong
Zip_crc32(buf, crc=crcInitial, offset=0)
        uLong    crc = NO_INIT
        STRLEN   len = NO_INIT
        Bytef *  buf = NO_INIT
        int      offset       
	SV *	 sv = ST(0) ;
	INIT:
    	/* If the buffer is a reference, dereference it */
	sv = deRef(sv, "crc32") ;
#ifdef UTF8_AVAILABLE    
    if (DO_UTF8(sv) && !sv_utf8_downgrade(sv, 1))
         croak("Wide character in Compress::Raw::Zlib::crc32");
#endif         
	buf = (Byte*)SvPVbyte(sv, len) ;

	if (items < 2)
	  crc = crcInitial;
	else if (SvOK(ST(1)))
	  crc = SvUV(ST(1)) ;
	else
	  crc = crcInitial;
 
uLong
crc32_combine(crc1, crc2, len2)
        uLong    crc1 
        uLong    crc2 
        z_off_t   len2 
	CODE:
#ifndef AT_LEAST_ZLIB_1_2_2_1
        crc1 = crc1; crc2 = crc2 ; len2 = len2; /* Silence -Wall */
        croak("crc32_combine needs zlib 1.2.3 or better");
#else
        RETVAL = crc32_combine(crc1, crc2, len2);
#endif
    OUTPUT:
        RETVAL


uLong
adler32_combine(adler1, adler2, len2)
        uLong    adler1 
        uLong    adler2 
        z_off_t   len2 
	CODE:
#ifndef AT_LEAST_ZLIB_1_2_2_1
        adler1 = adler1; adler2 = adler2 ; len2 = len2; /* Silence -Wall */
        croak("adler32_combine needs zlib 1.2.3 or better");
#else
        RETVAL = adler32_combine(adler1, adler2, len2);
#endif
    OUTPUT:
        RETVAL


MODULE = Compress::Raw::Zlib PACKAGE = Compress::Raw::Zlib

void
_deflateInit(flags,level, method, windowBits, memLevel, strategy, bufsize, dictionary)
    int flags
    int	level
    int method
    int windowBits
    int memLevel
    int strategy
    uLong bufsize
    SV* dictionary
  PPCODE:
    int err ;
    deflateStream s ;

    if (trace) 
        warn("in _deflateInit(level=%d, method=%d, windowBits=%d, memLevel=%d, strategy=%d, bufsize=%ld dictionary=%p)\n", 
	level, method, windowBits, memLevel, strategy, bufsize, dictionary) ;
    if ((s = InitStream() )) {

        s->Level      = level;
        s->Method     = method;
        s->WindowBits = windowBits;
        s->MemLevel   = memLevel;
        s->Strategy   = strategy;

        err = deflateInit2(&(s->stream), level, 
			   method, windowBits, memLevel, strategy);

        if (trace) {
            warn(" _deflateInit2 returned %d (state %p)\n", err, s);
            DispStream(s, "INIT");
        }

	/* Check if a dictionary has been specified */
	SvGETMAGIC(dictionary);
	if (err == Z_OK && SvPOK(dictionary) && SvCUR(dictionary)) {
#ifdef UTF8_AVAILABLE    
            if (DO_UTF8(dictionary) && !sv_utf8_downgrade(dictionary, 1))
                croak("Wide character in Compress::Raw::Zlib::Deflate::new dicrionary parameter");
#endif         
	    err = deflateSetDictionary(&(s->stream), (const Bytef*) SvPVX(dictionary), SvCUR(dictionary)) ;
        if (trace) 
            warn("deflateSetDictionary returned %d\n", err);
	    s->dict_adler = s->stream.adler ;
	}

        if (err != Z_OK) {
            Safefree(s) ;
            s = NULL ;
	}
	else
	    PostInitStream(s, flags, bufsize, windowBits) ;
        
    }
    else
        err = Z_MEM_ERROR ;

    {
        SV* obj = sv_setref_pv(sv_newmortal(), 
            "Compress::Raw::Zlib::deflateStream", (void*)s);
        XPUSHs(obj);
    }
    if (GIMME == G_ARRAY) {
        SV * sv = sv_2mortal(newSViv(err)) ;
	setDUALstatus(sv, err);
        XPUSHs(sv) ;
    }

void
_inflateInit(flags, windowBits, bufsize, dictionary)
    int flags
    int windowBits
    uLong bufsize
    SV * dictionary
  ALIAS:
    _inflateScanInit = 1
  PPCODE:
 
    int err = Z_OK ;
    inflateStream s ;
#ifndef MAGIC_APPEND
    if (ix == 1)
        croak("inflateScanInit needs zlib 1.2.1 or better");
#endif
    if (trace)
        warn("in _inflateInit(windowBits=%d, bufsize=%lu, dictionary=%lu\n",
                windowBits, bufsize, (unsigned long)SvCUR(dictionary)) ;
    if ((s = InitStream() )) {

        s->WindowBits = windowBits;

        err = inflateInit2(&(s->stream), windowBits);
        if (err != Z_OK) {
            Safefree(s) ;
            s = NULL ;
	}
	else if (sv_len(dictionary)) {
#ifdef AT_LEAST_ZLIB_1_2_2_1
        /* Zlib 1.2.2.1 or better allows a dictionary with raw inflate */
        if (s->WindowBits < 0) {
            STRLEN dlen;
            const Bytef* b = (const Bytef*)SvPVbyte(dictionary, dlen);
            err = inflateSetDictionary(&(s->stream), 
                b, dlen);
            if (err != Z_OK) {
                Safefree(s) ;
                s = NULL ;
            }
        }
        else
#endif
            /* Dictionary specified - take a copy for use in inflate */
	    s->dictionary = newSVsv(dictionary) ;
	}
	if (s) {
	    PostInitStream(s, flags, bufsize, windowBits) ;
#ifdef MAGIC_APPEND
            if (ix == 1)
            {
                s->window = (unsigned char *)safemalloc(WINDOW_SIZE);
            }
#endif
        }
    }
    else
	err = Z_MEM_ERROR ;

    {
        SV* obj = sv_setref_pv(sv_newmortal(), 
                   ix == 1 
                   ? "Compress::Raw::Zlib::inflateScanStream" 
                   :  "Compress::Raw::Zlib::inflateStream",
                   (void*)s);
        XPUSHs(obj);
    }
    if (GIMME == G_ARRAY) {
        SV * sv = sv_2mortal(newSViv(err)) ;
	setDUALstatus(sv, err);
        XPUSHs(sv) ;
    }
 


MODULE = Compress::Raw::Zlib PACKAGE = Compress::Raw::Zlib::deflateStream

void
DispStream(s, message=NULL)
    Compress::Raw::Zlib::deflateStream   s
    const char *  message

DualType
deflateReset(s)
    Compress::Raw::Zlib::deflateStream   s
  CODE:
      RETVAL = deflateReset(&(s->stream)) ;
      if (RETVAL == Z_OK) {
	  PostInitStream(s, s->flags, s->bufsize, s->WindowBits) ;
      }
    OUTPUT:
      RETVAL

DualType 
deflate (s, buf, output)
    Compress::Raw::Zlib::deflateStream	s
    SV *	buf
    SV * 	output 
    uInt	cur_length = NO_INIT
    uInt	increment = NO_INIT
    uInt	prefix    = NO_INIT
    int		RETVAL = 0;
    uLong     bufinc = NO_INIT
    STRLEN    origlen = NO_INIT
  CODE:
    bufinc = s->bufsize;

    /* If the input buffer is a reference, dereference it */
    buf = deRef(buf, "deflate") ;
 
    /* initialise the input buffer */
#ifdef UTF8_AVAILABLE    
    if (DO_UTF8(buf) && !sv_utf8_downgrade(buf, 1))
         croak("Wide character in Compress::Raw::Zlib::Deflate::deflate input parameter");
#endif         
    s->stream.next_in = (Bytef*)SvPV_nomg(buf, origlen) ;
    s->stream.avail_in = origlen;
    
    if (s->flags & FLAG_CRC32)
        s->crc32 = crc32(s->crc32, s->stream.next_in, s->stream.avail_in) ;

    if (s->flags & FLAG_ADLER32)
        s->adler32 = adler32(s->adler32, s->stream.next_in, s->stream.avail_in) ;

    /* and retrieve the output buffer */
    output = deRef_l(output, "deflate") ;
#ifdef UTF8_AVAILABLE    
    if (DO_UTF8(output) && !sv_utf8_downgrade(output, 1))
         croak("Wide character in Compress::Raw::Zlib::Deflate::deflate output parameter");
#endif         

    if((s->flags & FLAG_APPEND) != FLAG_APPEND) {
        SvCUR_set(output, 0);
        /* sv_setpvn(output, "", 0); */
    }
    prefix = cur_length =  SvCUR(output) ;
    s->stream.next_out = (Bytef*) SvPVX(output) + cur_length;
    increment =  SvLEN(output) -  cur_length;
    s->stream.avail_out =  increment;
#ifdef SETP_BYTE
    /* Check for saved output from deflateParams */
    if (s->deflateParams_out_valid) {
	*(s->stream.next_out) = s->deflateParams_out_byte;
	++ s->stream.next_out;
	-- s->stream.avail_out ;
	s->deflateParams_out_valid = FALSE;
    }
#else
    /* Check for saved output from deflateParams */
    if (s->deflateParams_out_length) {
        uLong plen = s->deflateParams_out_length ;
        /* printf("Copy %d bytes saved data\n", plen);*/
        if (s->stream.avail_out < plen) {
            /*printf("GROW from %d to %d\n", s->stream.avail_out,
                        SvLEN(output) + plen - s->stream.avail_out); */
            Sv_Grow(output, SvLEN(output) + plen - s->stream.avail_out) ;
        }
        
        Copy(s->stream.next_out, s->deflateParams_out_buffer, plen, Bytef) ;	
        cur_length = cur_length + plen;
        SvCUR_set(output, cur_length);
	s->stream.next_out += plen ;
	s->stream.avail_out = SvLEN(output) - cur_length ;
	increment = s->stream.avail_out;
	s->deflateParams_out_length = 0;
    }
#endif
    RETVAL = Z_OK ;
    while (s->stream.avail_in != 0) {

        if (s->stream.avail_out == 0) {
	    /* out of space in the output buffer so make it bigger */
            s->stream.next_out = (Bytef*) Sv_Grow(output, SvLEN(output) + bufinc) ;
            cur_length += increment ;
            s->stream.next_out += cur_length ;
            increment = bufinc ;
            s->stream.avail_out = increment;
            bufinc *= 2 ;
        }

        if (trace) {
          printf("DEFLATE Avail In %d, Out %d\n", s->stream.avail_in, s->stream.avail_out); 
          DispStream(s, "BEFORE");
          /* Perl_sv_dump(output); */
        }

        RETVAL = deflate(&(s->stream), Z_NO_FLUSH);
    
        if (trace) {
            printf("DEFLATE returned %d %s, avail in %d, out %d\n", RETVAL,
           GetErrorString(RETVAL), s->stream.avail_in, s->stream.avail_out); 
            DispStream(s, "AFTER");
        }

        if (RETVAL != Z_OK) 
            break;
    }

    s->compressedBytes += cur_length + increment - prefix - s->stream.avail_out ;
    s->uncompressedBytes  += origlen - s->stream.avail_in  ;

    s->last_error = RETVAL ;
    if (RETVAL == Z_OK) {
        SvPOK_only(output);
        SvCUR_set(output, cur_length + increment - s->stream.avail_out) ;
        SvSETMAGIC(output);
    }
    OUTPUT:
	RETVAL
  

void
DESTROY(s)
    Compress::Raw::Zlib::deflateStream	s
  CODE:
    if (trace)
        printf("Compress::Raw::Zlib::deflateStream::DESTROY %p\n", s);
    deflateEnd(&s->stream) ;
    if (s->dictionary)
	SvREFCNT_dec(s->dictionary) ;
#ifndef SETP_BYTE
    if (s->deflateParams_out_buffer)
        Safefree(s->deflateParams_out_buffer);
#endif
    Safefree(s) ;


DualType
flush(s, output, f=Z_FINISH)
    Compress::Raw::Zlib::deflateStream	s
    SV * output 
    int  f
    uInt	cur_length = NO_INIT
    uInt	increment = NO_INIT
    uInt	prefix    = NO_INIT
    uLong     bufinc = NO_INIT
    uLong     availableout = NO_INIT    
  CODE:
    bufinc = s->bufsize;
  
    s->stream.avail_in = 0; /* should be zero already anyway */
  
    /* retrieve the output buffer */
    output = deRef_l(output, "flush") ;
#ifdef UTF8_AVAILABLE    
    if (DO_UTF8(output) && !sv_utf8_downgrade(output, 1))
         croak("Wide character in Compress::Raw::Zlib::Deflate::flush input parameter");
#endif         
    if(! s->flags & FLAG_APPEND) {
        SvCUR_set(output, 0);
        /* sv_setpvn(output, "", 0); */
    }
    prefix = cur_length =  SvCUR(output) ;
    s->stream.next_out = (Bytef*) SvPVX(output) + cur_length;
    increment =  SvLEN(output) -  cur_length;
    s->stream.avail_out =  increment;
#ifdef SETP_BYTE
    /* Check for saved output from deflateParams */
    if (s->deflateParams_out_valid) {
	*(s->stream.next_out) = s->deflateParams_out_byte;
	++ s->stream.next_out;
	-- s->stream.avail_out ;
	s->deflateParams_out_valid = FALSE;
    }
#else
    /* Check for saved output from deflateParams */
    if (s->deflateParams_out_length) {
        uLong plen = s->deflateParams_out_length ;
        /* printf("Copy %d bytes saved data\n", plen); */
        if (s->stream.avail_out < plen) {
            /* printf("GROW from %d to %d\n", s->stream.avail_out, 
                        SvLEN(output) + plen - s->stream.avail_out); */
            Sv_Grow(output, SvLEN(output) + plen - s->stream.avail_out) ;
        }
        
        Copy(s->stream.next_out, s->deflateParams_out_buffer, plen, Bytef) ;	
        cur_length = cur_length + plen;
        SvCUR_set(output, cur_length);
	s->stream.next_out += plen ;
	s->stream.avail_out = SvLEN(output) - cur_length ;
	increment = s->stream.avail_out;
	s->deflateParams_out_length = 0;
    }
#endif

    for (;;) {
        if (s->stream.avail_out == 0) {        
            /* consumed all the available output, so extend it */
            s->stream.next_out = (Bytef*) Sv_Grow(output, SvLEN(output) + bufinc) ;
            cur_length += increment ;
            s->stream.next_out += cur_length ;
            increment = bufinc ;
            s->stream.avail_out = increment;
            bufinc *= 2 ;
        }
        
        availableout = s->stream.avail_out ;
        
        if (trace) {
          printf("flush (%d) DEFLATE Avail In %d, Out %d\n", f, s->stream.avail_in, s->stream.avail_out); 
          DispStream(s, "BEFORE");
          /* Perl_sv_dump(output); */
        }

        RETVAL = deflate(&(s->stream), f);
    
        if (trace) {
            printf("flush DEFLATE returned %d %s, avail in %d, out %d\n", RETVAL,
            GetErrorString(RETVAL), s->stream.avail_in, s->stream.avail_out); 
            DispStream(s, "AFTER");
        }

        /* Ignore the second of two consecutive flushes: */
        if (availableout == s->stream.avail_out && RETVAL == Z_BUF_ERROR) 
            RETVAL = Z_OK; 
        
        /* deflate has finished flushing only when it hasn't used up
         * all the available space in the output buffer: 
         */
        if (s->stream.avail_out != 0 || RETVAL != Z_OK )
            break;
    }
  
    RETVAL =  (RETVAL == Z_STREAM_END ? Z_OK : RETVAL) ;
    s->last_error = RETVAL ;

    s->compressedBytes    += cur_length + increment - prefix - s->stream.avail_out ;
  
    if (RETVAL == Z_OK) {
        SvPOK_only(output);
        SvCUR_set(output, cur_length + increment - s->stream.avail_out) ;
        SvSETMAGIC(output);
    }
    OUTPUT:
	RETVAL


DualType
_deflateParams(s, flags, level, strategy, bufsize)
  	Compress::Raw::Zlib::deflateStream	s
	int 	flags
	int	level
	int	strategy
    	uLong	bufsize
    CODE:
	/* printf("_deflateParams(Flags %d Level %d Strategy %d Bufsize %d)\n", flags, level, strategy, bufsize); 
	printf("Before -- Level %d, Strategy %d, Bufsize %d\n", s->Level, s->Strategy, s->bufsize); */
	if (flags & 1)
	    s->Level = level ;
	if (flags & 2)
	    s->Strategy = strategy ;
        if (flags & 4) {
            s->bufsize = bufsize; 
	}
	/* printf("After --  Level %d, Strategy %d, Bufsize %d\n", s->Level, s->Strategy, s->bufsize);*/
#ifdef SETP_BYTE
        s->stream.avail_in = 0; 
        s->stream.next_out = &(s->deflateParams_out_byte) ;
        s->stream.avail_out = 1;
	RETVAL = deflateParams(&(s->stream), s->Level, s->Strategy);
	s->deflateParams_out_valid = 
		(RETVAL == Z_OK && s->stream.avail_out == 0) ;
	/* printf("RETVAL %d, avail out %d, byte %c\n", RETVAL, s->stream.avail_out, s->deflateParams_out_byte); */
#else
	/* printf("Level %d Strategy %d, Prev Len %d\n", 
                s->Level, s->Strategy, s->deflateParams_out_length); */
        s->stream.avail_in = 0; 
        if (s->deflateParams_out_buffer == NULL)
            s->deflateParams_out_buffer = safemalloc(deflateParams_BUFFER_SIZE);
        s->stream.next_out = s->deflateParams_out_buffer ;
        s->stream.avail_out = deflateParams_BUFFER_SIZE;

	RETVAL = deflateParams(&(s->stream), s->Level, s->Strategy);
	s->deflateParams_out_length = deflateParams_BUFFER_SIZE - s->stream.avail_out;
	/* printf("RETVAL %d, length out %d, avail %d\n", 
                    RETVAL, s->deflateParams_out_length, s->stream.avail_out ); */
#endif
    OUTPUT:
	RETVAL


int
get_Level(s)
        Compress::Raw::Zlib::deflateStream   s
    CODE:
	RETVAL = s->Level ;
    OUTPUT:
	RETVAL

int
get_Strategy(s)
        Compress::Raw::Zlib::deflateStream   s
    CODE:
	RETVAL = s->Strategy ;
    OUTPUT:
	RETVAL


uLong
get_Bufsize(s)
        Compress::Raw::Zlib::deflateStream   s
    CODE:
	RETVAL = s->bufsize ;
    OUTPUT:
	RETVAL


int
status(s)
        Compress::Raw::Zlib::deflateStream   s
    CODE:
	RETVAL = s->last_error ;
    OUTPUT:
	RETVAL

uLong
crc32(s)
        Compress::Raw::Zlib::deflateStream   s
    CODE:
	RETVAL = s->crc32 ;
    OUTPUT:
	RETVAL

uLong
dict_adler(s)
        Compress::Raw::Zlib::deflateStream   s
    CODE:
	RETVAL = s->dict_adler ;
    OUTPUT:
	RETVAL

uLong
adler32(s)
        Compress::Raw::Zlib::deflateStream   s
    CODE:
	RETVAL = s->adler32 ;
    OUTPUT:
	RETVAL

uLong
compressedBytes(s)
    Compress::Raw::Zlib::deflateStream	s
    CODE:
        RETVAL = s->compressedBytes;
  OUTPUT:
	RETVAL

uLong
uncompressedBytes(s)
    Compress::Raw::Zlib::deflateStream	s
    CODE:
        RETVAL = s->uncompressedBytes;
  OUTPUT:
	RETVAL

uLong
total_in(s)
        Compress::Raw::Zlib::deflateStream   s
    CODE:
        RETVAL = s->stream.total_in ;
    OUTPUT:
	RETVAL

uLong
total_out(s)
        Compress::Raw::Zlib::deflateStream   s
    CODE:
        RETVAL = s->stream.total_out ;
    OUTPUT:
	RETVAL

char*
msg(s)
        Compress::Raw::Zlib::deflateStream   s
    CODE:
	RETVAL = s->stream.msg;
    OUTPUT:
	RETVAL

int 
deflateTune(s, good_length, max_lazy, nice_length, max_chain)
            Compress::Raw::Zlib::deflateStream   s
            int good_length
            int max_lazy
            int nice_length
            int max_chain
    CODE:
#ifndef AT_LEAST_ZLIB_1_2_2_3
        good_length = good_length; max_lazy = max_lazy ; /* Silence -Wall */
        nice_length = nice_length; max_chain = max_chain; /* Silence -Wall */
        croak("deflateTune needs zlib 1.2.2.3 or better");
#else
	RETVAL = deflateTune(&(s->stream), good_length, max_lazy, nice_length, max_chain);
#endif
    OUTPUT:
	RETVAL
    

MODULE = Compress::Raw::Zlib PACKAGE = Compress::Raw::Zlib::inflateStream

void
DispStream(s, message=NULL)
    Compress::Raw::Zlib::inflateStream   s
    const char *  message

DualType
inflateReset(s)
    Compress::Raw::Zlib::inflateStream   s
  CODE:
      RETVAL = inflateReset(&(s->stream)) ;
      if (RETVAL == Z_OK) {
	  PostInitStream(s, s->flags, s->bufsize, s->WindowBits) ;
      }
    OUTPUT:
      RETVAL

DualType 
inflate (s, buf, output, eof=FALSE)
    Compress::Raw::Zlib::inflateStream	s
    SV *	buf
    SV * 	output 
    bool 	eof 
    uInt	cur_length = 0;
    uInt	prefix_length = 0;
    int	    increment = 0;
    uLong   bufinc = NO_INIT
    STRLEN  na = NO_INIT ;
  PREINIT:
#ifdef UTF8_AVAILABLE    
    bool	out_utf8  = FALSE;
#endif    
    STRLEN	origlen;
  CODE: 
    bufinc = s->bufsize;
    /* If the buffer is a reference, dereference it */
    buf = deRef(buf, "inflate") ;

    if (s->flags & FLAG_CONSUME_INPUT) {
        if (SvREADONLY(buf))
            croak("Compress::Raw::Zlib::Inflate::inflate input parameter cannot be read-only when ConsumeInput is specified");
        SvPV_force(buf, na);
    }
#ifdef UTF8_AVAILABLE    
    if (DO_UTF8(buf) && !sv_utf8_downgrade(buf, 1))
         croak("Wide character in Compress::Raw::Zlib::Inflate::inflate input parameter");
#endif         
    
    /* initialise the input buffer */
    s->stream.next_in = (Bytef*)SvPV_nomg(buf, origlen) ;
    s->stream.avail_in = origlen ;
	
    /* and retrieve the output buffer */
    output = deRef_l(output, "inflate") ;
#ifdef UTF8_AVAILABLE    
    if (DO_UTF8(output))
         out_utf8 = TRUE ;
    if (DO_UTF8(output) && !sv_utf8_downgrade(output, 1))
         croak("Wide character in Compress::Raw::Zlib::Inflate::inflate output parameter");
#endif         
    if((s->flags & FLAG_APPEND) != FLAG_APPEND) {
        SvCUR_set(output, 0);
    }
   
    /* Assume no output buffer - the code below will update if there is any available */
    s->stream.avail_out = 0;


    if (SvLEN(output)) {
        prefix_length = cur_length =  SvCUR(output) ;
    
        if (s->flags & FLAG_LIMIT_OUTPUT && SvLEN(output) - cur_length - 1 < bufinc)
        {
            Sv_Grow(output, bufinc + cur_length + 1) ;
        }
    
        /* Only setup the stream output pointers if there is spare 
           capacity in the outout SV
        */
        if (SvLEN(output) > cur_length + 1)
        {
            s->stream.next_out = (Bytef*) SvPV_nomg_nolen(output) + cur_length;
            increment = SvLEN(output) -  cur_length - 1;
            s->stream.avail_out = increment;
        }
    }
    

    s->bytesInflated = 0;
    
    RETVAL = Z_OK;

    while (RETVAL == Z_OK) {
        if (s->stream.avail_out == 0) {
	    /* out of space in the output buffer so make it bigger */
            s->stream.next_out = (Bytef*) Sv_Grow(output, SvLEN(output) + bufinc +1) ;
            cur_length += increment ;
            s->stream.next_out += cur_length ;
            increment = bufinc ;
            s->stream.avail_out = increment;
            bufinc *= 2 ; 
        }

        /* printf("INFLATE Availl In %d, Out %d\n", s->stream.avail_in,
 s->stream.avail_out); 
DispStream(s, "BEFORE");
Perl_sv_dump(output); */
        RETVAL = inflate(&(s->stream), Z_SYNC_FLUSH);
        /* printf("INFLATE returned %d %s, avail in %d, out %d\n", RETVAL,
 GetErrorString(RETVAL), s->stream.avail_in, s->stream.avail_out); */

    
        if (RETVAL == Z_NEED_DICT && s->dictionary) {
            STRLEN dlen;
            const Bytef* b = (const Bytef*)SvPV(s->dictionary, dlen) ;
            s->dict_adler = s->stream.adler ;
            RETVAL = inflateSetDictionary(&(s->stream), 
                b, dlen);
            if (RETVAL == Z_OK)
                continue;
        }
        
        if (s->flags & FLAG_LIMIT_OUTPUT && 
                (RETVAL == Z_OK || RETVAL == Z_BUF_ERROR )) {
            if (s->stream.avail_out == 0)
                RETVAL = Z_BUF_ERROR;
            break;
        }
        if (s->flags & FLAG_LIMIT_OUTPUT && 
                (RETVAL == Z_OK || RETVAL == Z_BUF_ERROR ))
            break;

        if (RETVAL == Z_STREAM_ERROR || RETVAL == Z_MEM_ERROR ||
            RETVAL == Z_DATA_ERROR   || RETVAL == Z_STREAM_END )
            break ;

        if (RETVAL == Z_BUF_ERROR) {
            if (s->stream.avail_out == 0)
                continue ;
            if (s->stream.avail_in == 0) {
                RETVAL = Z_OK ;
                break ;
            }
        }
    }
#ifdef NEED_DUMMY_BYTE_AT_END 
    if (eof && RETVAL == Z_OK && s->flags & FLAG_LIMIT_OUTPUT == 0) {
        Bytef* nextIn =  s->stream.next_in;
        uInt availIn =  s->stream.avail_in;
        s->stream.next_in = (Bytef*) " ";
        s->stream.avail_in = 1;
        if (s->stream.avail_out == 0) {
	    /* out of space in the output buffer so make it bigger */
            s->stream.next_out = Sv_Grow(output, SvLEN(output) + bufinc) ;
            cur_length += increment ;
            s->stream.next_out += cur_length ;
            increment = bufinc ;
            s->stream.avail_out = increment;
            bufinc *= 2 ;
        }
        RETVAL = inflate(&(s->stream), Z_SYNC_FLUSH);
        s->stream.next_in = nextIn ;
        s->stream.avail_in  = availIn ;
    }
#else
    PERL_UNUSED_VAR(eof);
#endif
    
    s->last_error = RETVAL ;
    if (RETVAL == Z_OK || RETVAL == Z_STREAM_END || RETVAL == Z_BUF_ERROR || RETVAL == Z_DATA_ERROR) {
	   unsigned in ;

        s->bytesInflated = cur_length + increment - s->stream.avail_out - prefix_length;
        s->uncompressedBytes += s->bytesInflated ;
        s->compressedBytes   += origlen - s->stream.avail_in  ;

        SvPOK_only(output);
        SvCUR_set(output, prefix_length + s->bytesInflated) ;
	*SvEND(output) = '\0';
#ifdef UTF8_AVAILABLE    
        if (out_utf8)
            sv_utf8_upgrade(output);
#endif        
        SvSETMAGIC(output);

        if (s->flags & FLAG_CRC32 )
            s->crc32 = crc32(s->crc32, 
				(const Bytef*)SvPVX(output)+prefix_length, 
            			SvCUR(output)-prefix_length) ;

        if (s->flags & FLAG_ADLER32) 
            s->adler32 = adler32(s->adler32, 
				(const Bytef*)SvPVX(output)+prefix_length, 
            			SvCUR(output)-prefix_length) ;

	/* fix the input buffer */
	if (s->flags & FLAG_CONSUME_INPUT || s->flags & FLAG_LIMIT_OUTPUT) {
	    in = s->stream.avail_in ;
	    SvCUR_set(buf, in) ;
	    if (in)
	        Move(s->stream.next_in, SvPVX(buf), in, char) ;	
            *SvEND(buf) = '\0';
            SvSETMAGIC(buf);
	}

    }
    OUTPUT:
	RETVAL

uLong
inflateCount(s)
    Compress::Raw::Zlib::inflateStream	s
    CODE:
        RETVAL = s->bytesInflated;
  OUTPUT:
	RETVAL

uLong
compressedBytes(s)
    Compress::Raw::Zlib::inflateStream	s
    CODE:
        RETVAL = s->compressedBytes;
  OUTPUT:
	RETVAL

uLong
uncompressedBytes(s)
    Compress::Raw::Zlib::inflateStream	s
    CODE:
        RETVAL = s->uncompressedBytes;
  OUTPUT:
	RETVAL


DualType 
inflateSync (s, buf)
    Compress::Raw::Zlib::inflateStream	s
    SV *	buf
  CODE:
  
    /* If the buffer is a reference, dereference it */
    buf = deRef(buf, "inflateSync") ;
#ifdef UTF8_AVAILABLE    
    if (DO_UTF8(buf) && !sv_utf8_downgrade(buf, 1))
         croak("Wide character in Compress::Raw::Zlib::Inflate::inflateSync");
#endif         
    
    /* initialise the input buffer */
    s->stream.next_in = (Bytef*)SvPV_force_nomg_nolen(buf) ;
    s->stream.avail_in = SvCUR(buf) ;
	
    /* inflateSync doesn't create any output */
    s->stream.next_out = (Bytef*) NULL;
    s->stream.avail_out = 0;

    RETVAL = inflateSync(&(s->stream));
    s->last_error = RETVAL ;

    /* fix the input buffer */
    {
	unsigned in = s->stream.avail_in ;
 	SvCUR_set(buf, in) ;
 	if (in)
     	    Move(s->stream.next_in, SvPVX(buf), in, char) ;	
        *SvEND(buf) = '\0';
        SvSETMAGIC(buf);
    }
    OUTPUT:
	RETVAL

void
DESTROY(s)
    Compress::Raw::Zlib::inflateStream	s
  CODE:
    inflateEnd(&s->stream) ;
    if (s->dictionary)
	SvREFCNT_dec(s->dictionary) ;
#ifndef SETP_BYTE
    if (s->deflateParams_out_buffer)
        Safefree(s->deflateParams_out_buffer);
#endif
#ifdef MAGIC_APPEND
    if (s->window)
        Safefree(s->window);
#endif
    Safefree(s) ;


uLong
status(s)
        Compress::Raw::Zlib::inflateStream   s
    CODE:
	RETVAL = s->last_error ;
    OUTPUT:
	RETVAL

uLong
crc32(s)
        Compress::Raw::Zlib::inflateStream   s
    CODE:
	RETVAL = s->crc32 ;
    OUTPUT:
	RETVAL

uLong
dict_adler(s)
        Compress::Raw::Zlib::inflateStream   s
    CODE:
	RETVAL = s->dict_adler ;
    OUTPUT:
	RETVAL

uLong
total_in(s)
        Compress::Raw::Zlib::inflateStream   s
    CODE:
        RETVAL = s->stream.total_in ;
    OUTPUT:
	RETVAL

uLong
adler32(s)
        Compress::Raw::Zlib::inflateStream   s
    CODE:
	RETVAL = s->adler32 ;
    OUTPUT:
	RETVAL

uLong
total_out(s)
        Compress::Raw::Zlib::inflateStream   s
    CODE:
        RETVAL = s->stream.total_out ;
    OUTPUT:
	RETVAL

char*
msg(s)
	Compress::Raw::Zlib::inflateStream   s
    CODE:
	RETVAL = s->stream.msg;
    OUTPUT:
	RETVAL


uLong
get_Bufsize(s)
        Compress::Raw::Zlib::inflateStream   s
    CODE:
	RETVAL = s->bufsize ;
    OUTPUT:
	RETVAL

bool
set_Append(s, mode)
        Compress::Raw::Zlib::inflateStream   s
	bool	mode
    CODE:
        RETVAL = ((s->flags & FLAG_APPEND) == FLAG_APPEND);
	if (mode)
	    s->flags |= FLAG_APPEND ;
	else
	    s->flags &= ~FLAG_APPEND ;
    OUTPUT:
        RETVAL

MODULE = Compress::Raw::Zlib PACKAGE = Compress::Raw::Zlib::inflateScanStream

void
DESTROY(s)
    Compress::Raw::Zlib::inflateScanStream	s
  CODE:
    inflateEnd(&s->stream) ;
    if (s->dictionary)
	SvREFCNT_dec(s->dictionary) ;
#ifndef SETP_BYTE
    if (s->deflateParams_out_buffer)
        Safefree(s->deflateParams_out_buffer);
#endif
#ifdef MAGIC_APPEND
    if (s->window)
        Safefree(s->window);
#endif
    Safefree(s) ;

void
DispStream(s, message=NULL)
    Compress::Raw::Zlib::inflateScanStream   s
    const char *  message

DualType
inflateReset(s)
    Compress::Raw::Zlib::inflateScanStream   s
  CODE:
      RETVAL = inflateReset(&(s->stream)) ;
      if (RETVAL == Z_OK) {
	  PostInitStream(s, s->flags, s->bufsize, s->WindowBits) ;
      }
    OUTPUT:
      RETVAL

DualType 
scan(s, buf, out=NULL, eof=FALSE)
    Compress::Raw::Zlib::inflateScanStream	s
    SV *	buf
    SV *	out
    bool	eof
    bool	eof_mode = FALSE;
    int    start_len = NO_INIT
  CODE:
    PERL_UNUSED_VAR(out);
    PERL_UNUSED_VAR(eof);
    /* If the input buffer is a reference, dereference it */
#ifndef MAGIC_APPEND
        buf = buf;
        croak("scan needs zlib 1.2.1 or better");
#else
    buf = deRef(buf, "inflateScan") ;
#ifdef UTF8_AVAILABLE    
    if (DO_UTF8(buf) && !sv_utf8_downgrade(buf, 1))
        croak("Wide character in Compress::Raw::Zlib::InflateScan::scan input parameter");
#endif         
    /* initialise the input buffer */
    s->stream.next_in = (Bytef*)SvPV_force_nomg_nolen(buf) ;
    s->stream.avail_in = SvCUR(buf) ;
    start_len = s->stream.avail_in ;
    s->bytesInflated = 0 ; 
    do
    {
        if (s->stream.avail_in == 0) {
            RETVAL = Z_OK ;
            break ;
        }

        /* set up output to next available section of sliding window */
        s->stream.avail_out = WINDOW_SIZE - s->window_have;
        s->stream.next_out = s->window + s->window_have;

        /* DispStream(s, "before inflate\n"); */

        /* inflate and check for errors */
        RETVAL = inflate(&(s->stream), Z_BLOCK);

        if (start_len > 1 && ! eof_mode)
            s->window_lastByte = *(s->stream.next_in - 1 ) ;

        if (RETVAL == Z_STREAM_ERROR || RETVAL == Z_MEM_ERROR ||
            RETVAL == Z_DATA_ERROR )
            break ;

        if (s->flags & FLAG_CRC32 )
            s->crc32 = crc32(s->crc32, s->window + s->window_have, 
                             WINDOW_SIZE - s->window_have - s->stream.avail_out);

        if (s->flags & FLAG_ADLER32) 
            s->adler32 = adler32(s->adler32, s->window + s->window_have, 
                                 WINDOW_SIZE - s->window_have - s->stream.avail_out);

        s->uncompressedBytes =
        s->bytesInflated += WINDOW_SIZE - s->window_have - s->stream.avail_out;

        if (s->stream.avail_out)
            s->window_have = WINDOW_SIZE - s->stream.avail_out;
        else {
            s->window_have = 0;
            s->window_full = 1;
        }

        /* process end of block */
        if (s->stream.data_type & 128) {
            if (s->stream.data_type & 64) {
                s->window_left = s->stream.data_type & 0x1f;
            }
            else {
                s->window_lastbit = s->stream.data_type & 0x1f;
                s->lastBlockOffset = s->stream.total_in;
            }
        }

    } while (RETVAL != Z_STREAM_END);

    s->last_error = RETVAL ;
    s->window_lastoff = s->stream.total_in ;
    s->compressedBytes += SvCUR(buf) - s->stream.avail_in  ;

    if (RETVAL == Z_STREAM_END)
    {
        s->matchedEndBlock = 1 ;

        /* save the location of the end of the compressed data */
        s->window_end = SvCUR(buf) - s->stream.avail_in - 1 ;
        s->window_endOffset = s->stream.total_in ;
        if (s->window_left)
        {
            -- s->window_endOffset ;
        }

        /* if window wrapped, build dictionary from window by rotating */
        if (s->window_full) {
            rotate(s->window, WINDOW_SIZE, s->window_have);
            s->window_have = WINDOW_SIZE;
        }

        /* if (s->flags & FLAG_CONSUME_INPUT) { */
        if (1) {
            unsigned in = s->stream.avail_in ;
            SvCUR_set(buf, in) ;
            if (in)
                Move(s->stream.next_in, SvPVX(buf), in, char) ;	
            *SvEND(buf) = '\0';
            SvSETMAGIC(buf);
        }
    }
#endif
  OUTPUT:
	RETVAL


uLong
getEndOffset(s)
    Compress::Raw::Zlib::inflateScanStream	s
    CODE:
#ifndef MAGIC_APPEND
        croak("getEndOffset needs zlib 1.2.1 or better");
#else
        RETVAL = s->window_endOffset;
#endif
  OUTPUT:
	RETVAL

uLong
inflateCount(s)
    Compress::Raw::Zlib::inflateScanStream	s
    CODE:
#ifndef MAGIC_APPEND
        croak("inflateCount needs zlib 1.2.1 or better");
#else
        RETVAL = s->bytesInflated;
#endif
  OUTPUT:
	RETVAL

uLong
compressedBytes(s)
    Compress::Raw::Zlib::inflateScanStream	s
    CODE:
        RETVAL = s->compressedBytes;
  OUTPUT:
	RETVAL

uLong
uncompressedBytes(s)
    Compress::Raw::Zlib::inflateScanStream	s
    CODE:
        RETVAL = s->uncompressedBytes;
  OUTPUT:
	RETVAL


uLong
getLastBlockOffset(s)
    Compress::Raw::Zlib::inflateScanStream	s
    CODE:
#ifndef MAGIC_APPEND
        croak("getLastBlockOffset needs zlib 1.2.1 or better");
#else
        RETVAL = s->lastBlockOffset - (s->window_lastbit != 0);
#endif
  OUTPUT:
	RETVAL

uLong
getLastBufferOffset(s)
    Compress::Raw::Zlib::inflateScanStream	s
    CODE:
#ifndef MAGIC_APPEND
        croak("getLastBufferOffset needs zlib 1.2.1 or better");
#else
        RETVAL = s->window_lastoff;
#endif
  OUTPUT:
	RETVAL

void
resetLastBlockByte(s, byte)
    Compress::Raw::Zlib::inflateScanStream	s
    unsigned char*                      byte
    CODE:
#ifndef MAGIC_APPEND
        croak("resetLastBlockByte needs zlib 1.2.1 or better");
#else
        if (byte != NULL)
            *byte = *byte ^ (1 << ((8 - s->window_lastbit) & 7));
#endif


void
_createDeflateStream(inf_s, flags,level, method, windowBits, memLevel, strategy, bufsize)
    Compress::Raw::Zlib::inflateScanStream	inf_s
    int flags
    int	level
    int method
    int windowBits
    int memLevel
    int strategy
    uLong bufsize
  PPCODE:
  {
#ifndef MAGIC_APPEND
        flags = flags;
        level = level ;
        method = method;
        windowBits = windowBits;
        memLevel = memLevel;
        strategy = strategy;
        bufsize= bufsize;
        croak("_createDeflateStream needs zlib 1.2.1 or better");
#else
    int err ;
    deflateStream s ;

    if (trace)
        warn("in _createDeflateStream(level=%d, method=%d, windowBits=%d, memLevel=%d, strategy=%d, bufsize=%lu\n",
	level, method, windowBits, memLevel, strategy, bufsize) ;
    if ((s = InitStream() )) {

        s->Level      = level;
        s->Method     = method;
        s->WindowBits = windowBits;
        s->MemLevel   = memLevel;
        s->Strategy   = strategy;

        err = deflateInit2(&(s->stream), level, 
			   method, windowBits, memLevel, strategy);

	if (err == Z_OK) {
	    err = deflateSetDictionary(&(s->stream), inf_s->window, inf_s->window_have);
	    s->dict_adler = s->stream.adler ;
	}

        if (err != Z_OK) {
            Safefree(s) ;
            s = NULL ;
	}
	else {
	    PostInitStream(s, flags, bufsize, windowBits) ;
            s->crc32            = inf_s->crc32;
            s->adler32          = inf_s->adler32;
            s->stream.adler     = inf_s->stream.adler ;
            /* s->stream.total_out = inf_s->bytesInflated ; */
            s->stream.total_in  = inf_s->stream.total_out ;
            if (inf_s->window_left) {
                /* printf("** window_left %d, window_lastByte %d\n", inf_s->window_left, inf_s->window_lastByte); */
                deflatePrime(&(s->stream), 8 - inf_s->window_left, inf_s->window_lastByte);
            }
        }
    }
    else
        err = Z_MEM_ERROR ;

    XPUSHs(sv_setref_pv(sv_newmortal(), 
            "Compress::Raw::Zlib::deflateStream", (void*)s));
    if (GIMME == G_ARRAY) {
        SV * sv = sv_2mortal(newSViv(err)) ;
        setDUALstatus(sv, err);
        XPUSHs(sv) ;
    }
#endif
  }

DualType
status(s)
        Compress::Raw::Zlib::inflateScanStream   s
    CODE:
	RETVAL = s->last_error ;
    OUTPUT:
	RETVAL

uLong
crc32(s)
        Compress::Raw::Zlib::inflateScanStream   s
    CODE:
	RETVAL = s->crc32 ;
    OUTPUT:
	RETVAL


uLong
adler32(s)
        Compress::Raw::Zlib::inflateScanStream   s
    CODE:
	RETVAL = s->adler32 ;
    OUTPUT:
	RETVAL

@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
 *   Copyright (c) 1995-2010 Paul Marquess. All rights reserved.
d29 1
a29 1

d34 1
a34 1
#include <zlib.h> 
d47 1
d66 11
d80 1
d186 1
a186 1
#if defined(AMIGA) || defined(AMIGAOS) 
d277 1
d280 1
a280 1
#ifdef NO_WRITEABLE_DATA
d376 1
a376 1
        memcpy(list, list + 1, len - 1);
d426 1
a426 1
DispStream(di_stream * s, char * message)
d430 1
a430 1
    char * message;
d441 1
a441 1
    printf("DispStream 0x%p", s) ;
d450 5
a454 4
        printf("    stream           0x%p\n", &(s->stream));
        printf("           zalloc    0x%p\n", s->stream.zalloc);
        printf("           zfree     0x%p\n", s->stream.zfree);
        printf("           opaque    0x%p\n", s->stream.opaque);
d459 1
a459 1
        printf("           next_in   0x%p", s->stream.next_in);
d466 1
a466 1
        printf("           next_out  0x%p", s->stream.next_out);
d479 1
a479 1
        printf("    dictionary       0x%p\n", s->dictionary);
d493 1
a493 1
        printf("    window           0x%p\n", s->window);
d500 17
d528 5
a533 1
    
d587 2
a588 3
    if (!SvOK(sv)) { 
        sv = newSVpv("", 0);
    }
d604 1
d632 3
a634 4
        SvCUR_set(sv, 0);
    
    SvOOK_off(sv);
    SvPOK_only(sv);
d675 2
d681 7
d716 1
a716 1
#define Zip_crc32(buf, crc) crc32(crc, buf, (uInt)len)
d719 1
a719 1
Zip_crc32(buf, crc=crcInitial)
d723 1
d740 1
a740 2


d803 5
d809 2
a810 2

	if (err == Z_OK && SvCUR(dictionary)) {
d812 2
a813 2
        if (DO_UTF8(dictionary) && !sv_utf8_downgrade(dictionary, 1))
             croak("Wide character in Compress::Raw::Zlib::Deflate::new dicrionary parameter");
d815 3
a817 2
	    err = deflateSetDictionary(&(s->stream), (const Bytef*) SvPVbyte_nolen(dictionary), 
					SvCUR(dictionary)) ;
d871 1
a871 1
	else if (SvCUR(dictionary)) {
d875 2
d878 1
a878 2
                (const Bytef*)SvPVbyte_nolen(dictionary),
                SvCUR(dictionary));
d885 1
a885 1
#endif   
d923 1
a923 1
    char *  message
d946 1
d958 2
a959 2
    s->stream.next_in = (Bytef*)SvPVbyte_nolen(buf) ;
    s->stream.avail_in = SvCUR(buf) ;
d979 1
a979 1
    s->stream.next_out = (Bytef*) SvPVbyte_nolen(output) + cur_length;
d1010 1
d1015 1
a1015 1
            Sv_Grow(output, SvLEN(output) + bufinc) ;
d1017 1
a1017 1
            s->stream.next_out = (Bytef*) SvPVbyte_nolen(output) + cur_length ;
d1023 6
d1030 7
d1042 1
a1042 1
    s->uncompressedBytes  += SvCUR(buf) - s->stream.avail_in  ;
d1058 2
d1079 1
d1096 1
a1096 1
    s->stream.next_out = (Bytef*) SvPVbyte_nolen(output) + cur_length;
d1129 3
a1131 3
        if (s->stream.avail_out == 0) {
	    /* consumed all the available output, so extend it */
            Sv_Grow(output, SvLEN(output) + bufinc) ;
d1133 1
a1133 1
            s->stream.next_out = (Bytef*) SvPVbyte_nolen(output) + cur_length ;
d1138 9
d1149 10
d1346 1
a1346 1
    char *  message
d1368 2
a1369 2
    STRLEN  stmp    = NO_INIT
    uLong     bufinc = NO_INIT
d1374 2
a1375 1
  CODE:
d1380 5
a1384 2
    if (s->flags & FLAG_CONSUME_INPUT && SvREADONLY(buf))
        croak("Compress::Raw::Zlib::Inflate::inflate input parameter cannot be read-only when ConsumeInput is specified");
d1391 2
a1392 2
    s->stream.next_in = (Bytef*)SvPVbyte_force(buf, stmp) ;
    s->stream.avail_in = SvCUR(buf) ;
d1423 1
a1423 1
            s->stream.next_out = (Bytef*) SvPVbyte_nolen(output) + cur_length;
d1437 1
a1437 1
            Sv_Grow(output, SvLEN(output) + bufinc +1) ;
d1439 1
a1439 1
            s->stream.next_out = (Bytef*) SvPVbyte_nolen(output) + cur_length ;
d1455 2
d1459 1
a1459 2
            (const Bytef*)SvPVbyte_nolen(s->dictionary),
            SvCUR(s->dictionary));
d1465 6
d1495 1
a1495 1
            Sv_Grow(output, SvLEN(output) + bufinc) ;
d1497 1
a1497 1
            s->stream.next_out = (Bytef*) SvPVbyte_nolen(output) + cur_length ;
d1506 2
d1516 1
a1516 1
        s->compressedBytes   += SvCUR(buf) - s->stream.avail_in  ;
d1529 1
a1529 1
				(const Bytef*)SvPVbyte_nolen(output)+prefix_length, 
d1534 1
a1534 1
				(const Bytef*)SvPVbyte_nolen(output)+prefix_length, 
d1542 1
a1542 1
	        Move(s->stream.next_in, SvPVbyte_nolen(buf), in, char) ;	
d1590 1
a1590 1
    s->stream.next_in = (Bytef*)SvPVbyte_nolen(buf) ;
d1605 1
a1605 1
     	    Move(s->stream.next_in, SvPVbyte_nolen(buf), in, char) ;	
d1730 1
a1730 1
    char *  message
a1750 1
    STRLEN stmp      = NO_INIT
d1752 2
d1765 1
a1765 1
    s->stream.next_in = (Bytef*)SvPVbyte_force(buf, stmp) ;
d1850 3
a1852 3
                Move(s->stream.next_in, SvPVbyte_nolen(buf), in, char) ;	
                *SvEND(buf) = '\0';
                SvSETMAGIC(buf);
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d34 1
a34 1
#include "zlib.h" 
a46 1
#  define AT_LEAST_ZLIB_1_2_1
a64 7
#if  defined(ZLIB_VERNUM) && ZLIB_VERNUM >= 0x1252
/* 
    Use Z_SOLO to build source means need own malloc/free
 */
#  define AT_LEAST_ZLIB_1_2_5_2
#endif

a484 14
#ifdef AT_LEAST_ZLIB_1_2_5_2
voidpf my_zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    return safemalloc(items * size);
}


void my_zcfree (voidpf opaque, voidpf ptr)
{
    return safefree(ptr);
}

#endif

a495 5
#ifdef AT_LEAST_ZLIB_1_2_5_2
    s->stream.zalloc = my_zcalloc;
    s->stream.zfree = my_zcfree;
#endif

d497 1
a639 2
        if (strlen(ZLIB_VERSION) > 5)
            RETVAL += (ZLIB_VERSION[6] - '0')  ;
a643 7

#ifndef AT_LEAST_ZLIB_1_2_1
#define zlibCompileFlags() 0
#endif
uLong
zlibCompileFlags()

d672 1
a672 1
#define Zip_crc32(buf, crc, offset) crc32(crc, buf+offset, (uInt)len-offset)
d675 1
a675 1
Zip_crc32(buf, crc=crcInitial, offset=0)
a678 1
        int      offset       
d695 2
a696 1
 
a758 3
        if (trace) 
            warn(" _deflateInit2 returned %d\n", err);

a1010 1
    uLong     availableout = NO_INIT    
d1060 2
a1061 2
        if (s->stream.avail_out == 0) {        
            /* consumed all the available output, so extend it */
a1068 3
        
        availableout = s->stream.avail_out ;
        
a1070 4
        /* Ignore the second of two consecutive flushes: */
        if (availableout == s->stream.avail_out && RETVAL == Z_BUF_ERROR) 
            RETVAL = Z_OK; 
        
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d6 1
a6 1
 *   Copyright (c) 1995-2013 Paul Marquess. All rights reserved.
d29 1
a29 1
#define PERL_NO_GET_CONTEXT
d435 1
a435 1
    printf("DispStream %p", s) ;
d444 4
a447 5
        printf("    stream           %p\n", &(s->stream));
        printf("           zalloc    %p\n", s->stream.zalloc);
        printf("           zfree     %p\n", s->stream.zfree);
        printf("           opaque    %p\n", s->stream.opaque);
        printf("           state     %p\n", s->stream.state);
d452 1
a452 1
        printf("           next_in   %p", s->stream.next_in);
d459 1
a459 1
        printf("           next_out  %p", s->stream.next_out);
d472 1
a472 1
        printf("    dictionary       %p\n",   s->dictionary);
d486 1
a486 1
        printf("    window           %p\n", s->window);
d502 1
a502 2
    safefree(ptr);
    return; 
d577 3
a579 2
    if (!SvOK(sv))
        sv = sv_2mortal(newSVpv("", 0));
a594 1
    STRLEN na;
d622 4
a625 3
        sv_setpv(sv, "") ;
    else
        (void)SvPVbyte_force(sv, na) ;
d794 2
a795 4
        if (trace) {
            warn(" _deflateInit2 returned %d (state %p)\n", err, s);
            DispStream(s, "INIT");
        }
d798 2
a799 2
	SvGETMAGIC(dictionary);
	if (err == Z_OK && SvPOK(dictionary) && SvCUR(dictionary)) {
d801 2
a802 2
            if (DO_UTF8(dictionary) && !sv_utf8_downgrade(dictionary, 1))
                croak("Wide character in Compress::Raw::Zlib::Deflate::new dicrionary parameter");
d804 2
a805 3
	    err = deflateSetDictionary(&(s->stream), (const Bytef*) SvPVX(dictionary), SvCUR(dictionary)) ;
        if (trace) 
            warn("deflateSetDictionary returned %d\n", err);
d872 1
a872 1
#endif
d944 1
a944 1
    s->stream.next_in = (Bytef*)SvPV_nomg_nolen(buf) ;
d965 1
a965 1
    s->stream.next_out = (Bytef*) SvPVX(output) + cur_length;
a995 1
    RETVAL = Z_OK ;
d1000 1
a1000 1
            s->stream.next_out = (Bytef*) Sv_Grow(output, SvLEN(output) + bufinc) ;
d1002 1
a1002 1
            s->stream.next_out += cur_length ;
a1007 6
        if (trace) {
          printf("DEFLATE Avail In %d, Out %d\n", s->stream.avail_in, s->stream.avail_out); 
          DispStream(s, "BEFORE");
          /* Perl_sv_dump(output); */
        }

a1008 7
    
        if (trace) {
            printf("DEFLATE returned %d %s, avail in %d, out %d\n", RETVAL,
           GetErrorString(RETVAL), s->stream.avail_in, s->stream.avail_out); 
            DispStream(s, "AFTER");
        }

a1029 2
    if (trace)
        printf("Compress::Raw::Zlib::deflateStream::DESTROY %p\n", s);
d1066 1
a1066 1
    s->stream.next_out = (Bytef*) SvPVX(output) + cur_length;
d1101 1
a1101 1
            s->stream.next_out = (Bytef*) Sv_Grow(output, SvLEN(output) + bufinc) ;
d1103 1
a1103 1
            s->stream.next_out += cur_length ;
a1110 6
        if (trace) {
          printf("flush (%d) DEFLATE Avail In %d, Out %d\n", f, s->stream.avail_in, s->stream.avail_out); 
          DispStream(s, "BEFORE");
          /* Perl_sv_dump(output); */
        }

a1112 6
        if (trace) {
            printf("flush DEFLATE returned %d %s, avail in %d, out %d\n", RETVAL,
            GetErrorString(RETVAL), s->stream.avail_in, s->stream.avail_out); 
            DispStream(s, "AFTER");
        }

d1326 2
a1327 2
    uLong   bufinc = NO_INIT
    STRLEN  na = NO_INIT ;
d1332 1
a1332 1
  CODE: 
d1337 2
a1338 5
    if (s->flags & FLAG_CONSUME_INPUT) {
        if (SvREADONLY(buf))
            croak("Compress::Raw::Zlib::Inflate::inflate input parameter cannot be read-only when ConsumeInput is specified");
        SvPV_force(buf, na);
    }
d1345 1
a1345 1
    s->stream.next_in = (Bytef*)SvPV_nomg_nolen(buf) ;
d1377 1
a1377 1
            s->stream.next_out = (Bytef*) SvPV_nomg_nolen(output) + cur_length;
d1391 1
a1391 1
            s->stream.next_out = (Bytef*) Sv_Grow(output, SvLEN(output) + bufinc +1) ;
d1393 1
a1393 1
            s->stream.next_out += cur_length ;
d1411 1
a1411 1
            (const Bytef*)SvPVX(s->dictionary),
d1442 1
a1442 1
            s->stream.next_out = Sv_Grow(output, SvLEN(output) + bufinc) ;
d1444 1
a1444 1
            s->stream.next_out += cur_length ;
d1474 1
a1474 1
				(const Bytef*)SvPVX(output)+prefix_length, 
d1479 1
a1479 1
				(const Bytef*)SvPVX(output)+prefix_length, 
d1487 1
a1487 1
	        Move(s->stream.next_in, SvPVX(buf), in, char) ;	
d1535 1
a1535 1
    s->stream.next_in = (Bytef*)SvPV_nomg_nolen(buf) ;
d1550 1
a1550 1
     	    Move(s->stream.next_in, SvPVX(buf), in, char) ;	
d1696 1
d1709 1
a1709 1
    s->stream.next_in = (Bytef*)SvPV_nomg_nolen(buf) ;
d1794 1
a1794 1
                Move(s->stream.next_in, SvPVX(buf), in, char) ;	
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@a72 4
#if  defined(ZLIB_VERNUM) && ZLIB_VERNUM >= 0x1280
#  define AT_LEAST_ZLIB_1_2_8
#endif

a75 1
#  define NEED_sv_pvn_force_flags
d420 1
a420 1
DispStream(di_stream * s, const char * message)
d424 1
a424 1
    const char * message;
d863 1
a863 1
	else if (sv_len(dictionary)) {
a866 2
            STRLEN dlen;
            const Bytef* b = (const Bytef*)SvPVbyte(dictionary, dlen);
d868 2
a869 1
                b, dlen);
d914 1
a914 1
    const char *  message
a936 1
    STRLEN    origlen = NO_INIT
d948 2
a949 2
    s->stream.next_in = (Bytef*)SvPV_nomg(buf, origlen) ;
    s->stream.avail_in = origlen;
d1032 1
a1032 1
    s->uncompressedBytes  += origlen - s->stream.avail_in  ;
d1336 1
a1336 1
    const char *  message
a1363 1
    STRLEN	origlen;
d1380 2
a1381 2
    s->stream.next_in = (Bytef*)SvPV_nomg(buf, origlen) ;
    s->stream.avail_in = origlen ;
a1443 2
            STRLEN dlen;
            const Bytef* b = (const Bytef*)SvPV(s->dictionary, dlen) ;
d1446 2
a1447 1
                b, dlen);
a1452 6
                (RETVAL == Z_OK || RETVAL == Z_BUF_ERROR )) {
            if (s->stream.avail_out == 0)
                RETVAL = Z_BUF_ERROR;
            break;
        }
        if (s->flags & FLAG_LIMIT_OUTPUT && 
d1496 1
a1496 1
        s->compressedBytes   += origlen - s->stream.avail_in  ;
d1570 1
a1570 1
    s->stream.next_in = (Bytef*)SvPV_force_nomg_nolen(buf) ;
d1710 1
a1710 1
    const char *  message
@


