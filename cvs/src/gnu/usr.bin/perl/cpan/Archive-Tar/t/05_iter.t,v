head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.2
	PERL_5_24_2:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.18
	OPENBSD_6_1_BASE:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.16
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.10
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.12
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.4
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.8
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2010.09.24.14.48.56;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.56;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.06.44;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@BEGIN {
    if( $ENV{PERL_CORE} ) {
        chdir '../lib/Archive/Tar' if -d '../lib/Archive/Tar';
    }       
    use lib '../../..';
}

BEGIN { chdir 't' if -d 't' }

use Test::More 'no_plan';
use strict;
use lib '../lib';

my $Class   = 'Archive::Tar';
my $FClass  = 'Archive::Tar::File';
my $File    = 'src/long/bar.tar';
my @@Expect = (
    qr|^c$|,
    qr|^d$|,
    qr|^directory/$|,
    qr|^directory/really.*name/$|,
    qr|^directory/.*/myfile$|,
);

use_ok( $Class );

### crazy ref to special case 'all'
for my $index ( \0, 0 .. $#Expect ) {   

    my %opts    = ();
    my @@expect  = ();
    
    ### do a full test vs individual filters
    if( not ref $index ) {
        my $regex       = $Expect[$index];
        $opts{'filter'} = $regex;
        @@expect         = ($regex);
    } else {
        @@expect         = @@Expect;
    }        

    my $next = $Class->iter( $File, 0, \%opts );
    
    my $pp_opts = join " => ", %opts;
    ok( $next,                  "Iterator created from $File ($pp_opts)" );
    isa_ok( $next, "CODE",      "   Iterator" );

    my @@names;
    while( my $f = $next->() ) {
        ok( $f,                 "       File object retrieved" );
        isa_ok( $f, $FClass,    "           Object" );

        push @@names, $f->name;
    }
    
    is( scalar(@@names), scalar(@@expect),
                                "   Found correct number of files" );
    
    my $i = 0;
    for my $name ( @@names ) {
        ok( 1,                  "   Inspecting '$name' " );
        like($name, $expect[$i],"       Matches $Expect[$i]" );
        $i++;
    }        
}
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d1 7
d28 1
a28 1
for my $index ( \0, 0 .. $#Expect ) {
d32 1
a32 28

    my $dotest = sub {
	my $desc = shift;
	my $next = $Class->iter( $File, 0, \%opts );

	my $pp_opts = join " => ", %opts;
	ok( $next,                  "Iterator created from $File ($pp_opts $desc)" );
	isa_ok( $next, "CODE",      "   Iterator $desc" );

	my @@names;
	while( my $f = $next->() ) {
	    ok( $f,                 "       File object retrieved $desc" );
	    isa_ok( $f, $FClass,    "           Object $desc" );

	    push @@names, $f->name;
	}

	is( scalar(@@names), scalar(@@expect),
				    "   Found correct number of files $desc" );

	my $i = 0;
	for my $name ( @@names ) {
	    ok( 1,                  "   Inspecting '$name'  $desc" );
	    like($name, $expect[$i],"       Matches $Expect[$i] $desc" );
	    $i++;
	}
    };

d36 1
a37 4
	%opts		= ( filter => $regex );
	$dotest->("filter $regex");
	%opts		= ( filter_cb => sub { my ($entry) = @@_; $entry->name() =~ /$regex/ } );
	$dotest->("filter_cb $regex");
d40 14
a53 1
	$dotest->("all");
d55 10
@

