head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.3.0.8
	OPENBSD_6_2_BASE:1.1.1.3
	PERL_5_24_2:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.12
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.10
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.4
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.6
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.8
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2010.09.24.14.48.56;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.56;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.06.44;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.11.17.20.52.41;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@BEGIN {
    if( $ENV{PERL_CORE} ) {
        chdir '../lib/Archive/Tar' if -d '../lib/Archive/Tar';
    }       
    use lib '../../..';
}

BEGIN { chdir 't' if -d 't' }

use Test::More      'no_plan';
use File::Basename  'basename';
use strict;
use lib '../lib';

my $NO_UNLINK   = @@ARGV ? 1 : 0;

my $Class       = 'Archive::Tar';
my $FileClass   = $Class . '::File';

use_ok( $Class );
use_ok( $FileClass );

### bug #13636
### tests for @@longlink behaviour on files that have a / at the end
### of their shortened path, making them appear to be directories
{   ok( 1,                      "Testing bug 13636" );

    ### dont use the prefix, otherwise A::T will not use @@longlink
    ### encoding style
    local $Archive::Tar::DO_NOT_USE_PREFIX = 1;
    local $Archive::Tar::DO_NOT_USE_PREFIX = 1;
    
    my $dir =   'Catalyst-Helper-Controller-Scaffold-HTML-Template-0_03/' . 
                'lib/Catalyst/Helper/Controller/Scaffold/HTML/';
    my $file =  'Template.pm';
    my $out =   $$ . '.tar';
    
    ### first create the file
    {   my $tar = $Class->new;
        
        isa_ok( $tar, $Class,   "   Object" );
        ok( $tar->add_data( $dir.$file => $$ ),
                                "       Added long file" );
        
        ok( $tar->write($out),  "       File written to $out" );
    }
    
    ### then read it back in
    {   my $tar = $Class->new;
        isa_ok( $tar, $Class,   "   Object" );
        ok( $tar->read( $out ), "       Read in $out again" );
        
        my @@files = $tar->get_files;
        is( scalar(@@files), 1,  "       Only 1 entry found" );
        
        my $entry = shift @@files;
        ok( $entry->is_file,    "       Entry is a file" );
        is( $entry->name, $dir.$file,
                                "       With the proper name" );
    }                                
    
    ### remove the file
    unless( $NO_UNLINK ) { 1 while unlink $out }
}    

### bug #14922
### There's a bug in Archive::Tar that causes a file like: foo/foo.txt 
### to be stored in the tar file as: foo/.txt
### XXX could not be reproduced in 1.26 -- leave test to be sure
{   ok( 1,                      "Testing bug 14922" );

    my $dir     = $$ . '/';
    my $file    = $$ . '.txt';
    my $out     = $$ . '.tar';
    
    ### first create the file
    {   my $tar = $Class->new;
        
        isa_ok( $tar, $Class,   "   Object" );
        ok( $tar->add_data( $dir.$file => $$ ),
                                "       Added long file" );
        
        ok( $tar->write($out),  "       File written to $out" );
    }

    ### then read it back in
    {   my $tar = $Class->new;
        isa_ok( $tar, $Class,   "   Object" );
        ok( $tar->read( $out ), "       Read in $out again" );
        
        my @@files = $tar->get_files;
        is( scalar(@@files), 1,  "       Only 1 entry found" );
        
        my $entry = shift @@files;
        ok( $entry->is_file,    "       Entry is a file" );
        is( $entry->full_path, $dir.$file,
                                "       With the proper name" );
    }                                
    
    ### remove the file
    unless( $NO_UNLINK ) { 1 while unlink $out }
}    
    
### bug #30380: directory traversal vulnerability in Archive-Tar    
### Archive::Tar allowed files to be extracted to a dir outside
### it's cwd(), effectively allowing you to overwrite any files
### on the system, given the right permissions.
{   ok( 1,                      "Testing bug 30880" );

    my $tar = $Class->new;
    isa_ok( $tar, $Class,       "   Object" );    
    
    ### absolute paths are already taken care of. Only relative paths
    ### matter
    my $in_file     = basename($0);
    my $out_file    = '../' . $in_file . "_$$";
    
    ok( $tar->add_files( $in_file ), 
                                "       Added '$in_file'" );
    ok( $tar->rename( $in_file, $out_file ),
                                "       Renamed to '$out_file'" );
    
    ### first, test with strict extract permissions on
    {   local $Archive::Tar::INSECURE_EXTRACT_MODE = 0;

        ### we quell the error on STDERR
        local $Archive::Tar::WARN = 0;
        local $Archive::Tar::WARN = 0;

        ok( 1,                  "   Extracting in secure mode" );

        ok( ! $tar->extract_file( $out_file ),
                                "       File not extracted" );
        ok( ! -e $out_file,     "       File '$out_file' does not exist" );
    
        ok( $tar->error,        "       Error message stored" );
        like( $tar->error, qr/attempting to leave/,
                                "           Proper violation detected" );
    }
    
    ### now disable those
    {   local $Archive::Tar::INSECURE_EXTRACT_MODE = 1;
        ok( 1,                  "   Extracting in insecure mode" );
    
        ok( $tar->extract_file( $out_file ),
                                "       File extracted" );
        ok( -e $out_file,       "       File '$out_file' exists" );
        
        ### and clean up
        unless( $NO_UNLINK ) { 1 while unlink $out_file };
    }    
}

### bug #43513: [PATCH] Accept wrong checksums from SunOS and HP-UX tar
### like GNU tar does. See here for details:
### http://www.gnu.org/software/tar/manual/tar.html#SEC139
{   ok( 1,                      "Testing bug 43513" );
    
    my $src = File::Spec->catfile( qw[src header signed.tar] );
    my $tar = $Class->new;
    
    isa_ok( $tar, $Class,       "   Object" );
    ok( $tar->read( $src ),     "   Read non-Posix file with signed Checksum" );
        
    for my $file ( $tar->get_files ) {
        ok( $file,              "       File object retrieved" );
        ok( $file->validate,    "           File validates" );
    }        
}

### return error properly on corrupted archives
### Addresses RT #44680: Improve error reporting on short corrupted archives
{   ok( 1,                      "Testing bug 44680" );

    {   ### XXX whitebox test -- resetting the error string
        no warnings 'once'; 
        $Archive::Tar::error = "";
    }

    my $src = File::Spec->catfile( qw[src short b] );
    my $tar = $Class->new;
    
    isa_ok( $tar, $Class,       "   Object" );
    
    
    ### we quell the error on STDERR
    local $Archive::Tar::WARN = 0;

    ok( !$tar->read( $src ),    "   No files in the corrupted archive" );
    like( $tar->error, qr/enough bytes/,
                                "       Expected error reported" );
}

@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d1 7
d32 2
a33 2

    my $dir =   'Catalyst-Helper-Controller-Scaffold-HTML-Template-0_03/' .
d37 1
a37 1

d40 1
a40 1

d44 1
a44 1

d47 1
a47 1

d52 1
a52 1

d55 1
a55 1

d60 2
a61 2
    }

d64 1
a64 1
}
d67 1
a67 1
### There's a bug in Archive::Tar that causes a file like: foo/foo.txt
d75 1
a75 1

d78 1
a78 1

d82 1
a82 1

d90 1
a90 1

d93 1
a93 1

d98 2
a99 2
    }

d102 3
a104 3
}

### bug #30380: directory traversal vulnerability in Archive-Tar
d111 2
a112 2
    isa_ok( $tar, $Class,       "   Object" );

d117 2
a118 2

    ok( $tar->add_files( $in_file ),
a119 10

    ok( $tar->chmod( $in_file, '1777'),
                                "       chmod 177 $in_file" );

    ok( $tar->chown( $in_file, 'root' ),
                                "       chown to root" );

    ok( $tar->chown( $in_file, 'root', 'root' ),
                                "       chown to root:root" );

d122 1
a122 1

d135 1
a135 1

d140 1
a140 1

d144 1
a144 1

d148 1
a148 1

d151 1
a151 1
    }
d158 1
a158 1

d161 1
a161 1

d164 1
a164 1

d168 1
a168 1
    }
d176 1
a176 1
        no warnings 'once';
d182 1
a182 1

d184 2
a185 2


@


1.1.1.3
log
@Import perl-5.20.1
@
text
@a196 53
### bug #78030
### tests for symlinks with relative paths
### seen on MSWin32
{   ok( 1,                      "Testing bug 78030" );
		my $archname = 'tmp-symlink.tar.gz';
		{	#build archive
			unlink $archname if -e $archname;
			local $Archive::Tar::DO_NOT_USE_PREFIX = 1;
			my $t=Archive::Tar->new;
			my $f = $t->add_data( 'tmp/a/b/link.txt', '',
				{
					linkname => '../c/ori.txt',
					type     => 2,
				} );
			#why doesn't it keep my wish?
			$f->{name}   = 'tmp/a/b/link.txt';
			$f->{prefix} = '';
			$t->add_data( 'tmp/a/c/ori.txt', 'test case' );
			$t->write( $archname, 1 );
		}

    { #use case 1 - in memory extraction
			my $t=Archive::Tar->new;
			$t->read( $archname );
			my $r = eval{ $t->extract };
			ok( $r && !$@@,            "   In memory extraction/symlinks" );
			ok((stat 'tmp/a/b/link.txt')[7] == 9,
			                          "       Linked content" ) unless $r;
			clean_78030();
		}

		{ #use case 2 - iter extraction
		  #$DB::single = 2;
			my $next=Archive::Tar->iter( $archname, 1 );
			my $failed = 0;
			#use Data::Dumper;
			while(my $f = $next->() ){
			#  print "\$f = ", Dumper( $f ), $/;
				eval{ $f->extract } or $failed++;
			}
			ok( !$failed,             "   From disk extraction/symlinks" );
			ok((stat 'tmp/a/b/link.txt')[7] == 9,
			                          "       Linked content" ) unless $failed;
		}

    #remove tmp files
		sub clean_78030{
			unlink for ('tmp/a/c/ori.txt', 'tmp/a/b/link.txt');
			rmdir for ('tmp/a/c', 'tmp/a/b', 'tmp/a', 'tmp');
		}
		clean_78030();
		unlink $archname;
}
@


