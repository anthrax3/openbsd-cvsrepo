head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.4
	OPENBSD_6_0:1.1.1.4.0.10
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.4
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.6
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2010.09.24.14.49.04;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.04;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.07.56;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.55;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.52.57;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@package Module::Load;

$VERSION = '0.16';

use strict;
use File::Spec ();

sub import {
    my $who = _who();

    {   no strict 'refs';
        *{"${who}::load"} = *load;
    }
}

sub load (*;@@)  {
    my $mod = shift or return;
    my $who = _who();

    if( _is_file( $mod ) ) {
        require $mod;
    } else {
        LOAD: {
            my $err;
            for my $flag ( qw[1 0] ) {
                my $file = _to_file( $mod, $flag);
                eval { require $file };
                $@@ ? $err .= $@@ : last LOAD;
            }
            die $err if $err;
        }
    }
    
    ### This addresses #41883: Module::Load cannot import 
    ### non-Exporter module. ->import() routines weren't
    ### properly called when load() was used.
    {   no strict 'refs';
        my $import;
        if (@@_ and $import = $mod->can('import')) {
            unshift @@_, $mod;
            goto &$import;
        }
    }
}

sub _to_file{
    local $_    = shift;
    my $pm      = shift || '';

    my @@parts = split /::/;

    ### because of [perl #19213], see caveats ###
    my $file = $^O eq 'MSWin32'
                    ? join "/", @@parts
                    : File::Spec->catfile( @@parts );

    $file   .= '.pm' if $pm;
    
    ### on perl's before 5.10 (5.9.5@@31746) if you require
    ### a file in VMS format, it's stored in %INC in VMS
    ### format. Therefor, better unixify it first
    ### Patch in reply to John Malmbergs patch (as mentioned
    ### above) on p5p Tue 21 Aug 2007 04:55:07
    $file = VMS::Filespec::unixify($file) if $^O eq 'VMS';

    return $file;
}

sub _who { (caller(1))[0] }

sub _is_file {
    local $_ = shift;
    return  /^\./               ? 1 :
            /[^\w:']/           ? 1 :
            undef
    #' silly bbedit..
}


1;

__END__

=pod

=head1 NAME

Module::Load - runtime require of both modules and files

=head1 SYNOPSIS

	use Module::Load;

    my $module = 'Data:Dumper';
    load Data::Dumper;      # loads that module
    load 'Data::Dumper';    # ditto
    load $module            # tritto
    
    my $script = 'some/script.pl'
    load $script;
    load 'some/script.pl';	# use quotes because of punctuations
    
    load thing;             # try 'thing' first, then 'thing.pm'

    load CGI, ':standard'   # like 'use CGI qw[:standard]'
    

=head1 DESCRIPTION

C<load> eliminates the need to know whether you are trying to require
either a file or a module.

If you consult C<perldoc -f require> you will see that C<require> will
behave differently when given a bareword or a string.

In the case of a string, C<require> assumes you are wanting to load a
file. But in the case of a bareword, it assumes you mean a module.

This gives nasty overhead when you are trying to dynamically require
modules at runtime, since you will need to change the module notation
(C<Acme::Comment>) to a file notation fitting the particular platform
you are on.

C<load> eliminates the need for this overhead and will just DWYM.

=head1 Rules

C<load> has the following rules to decide what it thinks you want:

=over 4

=item *

If the argument has any characters in it other than those matching
C<\w>, C<:> or C<'>, it must be a file

=item *

If the argument matches only C<[\w:']>, it must be a module

=item *

If the argument matches only C<\w>, it could either be a module or a
file. We will try to find C<file> first in C<@@INC> and if that fails,
we will try to find C<file.pm> in @@INC.
If both fail, we die with the respective error messages.

=back

=head1 Caveats

Because of a bug in perl (#19213), at least in version 5.6.1, we have
to hardcode the path separator for a require on Win32 to be C</>, like
on Unix rather than the Win32 C<\>. Otherwise perl will not read its
own %INC accurately double load files if they are required again, or
in the worst case, core dump.

C<Module::Load> cannot do implicit imports, only explicit imports.
(in other words, you always have to specify explicitly what you wish
to import from a module, even if the functions are in that modules'
C<@@EXPORT>)

=head1 ACKNOWLEDGEMENTS

Thanks to Jonas B. Nielsen for making explicit imports work.

=head1 BUG REPORTS

Please report bugs or other issues to E<lt>bug-module-load@@rt.cpan.org<gt>.

=head1 AUTHOR

This module by Jos Boumans E<lt>kane@@cpan.orgE<gt>.

=head1 COPYRIGHT

This library is free software; you may redistribute and/or modify it 
under the same terms as Perl itself.


=cut                               
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d3 1
a3 1
$VERSION = '0.22';
d33 2
a34 2

    ### This addresses #41883: Module::Load cannot import
d50 1
a50 4
    ## trailing blanks ignored by default. [rt #69886]
    my @@parts = split /::/, $_, -1;
    ## make sure that we can't hop out of @@INC
    shift @@parts if @@parts && !$parts[0];
d58 1
a58 1

d98 1
a98 1

d102 1
a102 1

d106 1
a106 1

d144 3
a146 3
file. We will try to find C<file.pm> first in C<@@INC> and if that
fails, we will try to find C<file> in @@INC.  If both fail, we die with
the respective error messages.
d177 1
a177 1
This library is free software; you may redistribute and/or modify it
d181 1
a181 1
=cut
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d3 1
a3 1
$VERSION = '0.24';
d51 1
a51 1
    my @@parts = split /::|'/, $_, -1;
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@d3 1
a3 1
$VERSION = '0.32';
a5 1
use warnings;
a9 1
    my $h; shift;
d12 1
a12 24

        @@_ or (
            *{"${who}::load"} = \&load, # compat to prev version
            *{"${who}::autoload"} = \&autoload,
            return
        );

        map { $h->{$_} = () if defined $_ } @@_;

        (exists $h->{none} or exists $h->{''})
            and shift, last;

        ((exists $h->{autoload} and shift,1) or (exists $h->{all} and shift))
            and *{"${who}::autoload"} = \&autoload;

        ((exists $h->{load} and shift,1) or exists $h->{all})
            and *{"${who}::load"} = \&load;

        ((exists $h->{load_remote} and shift,1) or exists $h->{all})
            and *{"${who}::load_remote"} = \&load_remote;

        ((exists $h->{autoload_remote} and shift,1) or exists $h->{all})
            and *{"${who}::autoload_remote"} = \&autoload_remote;

a13 17

}

sub load(*;@@){
    goto &_load;
}

sub autoload(*;@@){
    unshift @@_, 'autoimport';
    goto &_load;
}

sub load_remote($$;@@){
    my ($dst, $src, @@exp) = @@_;

    eval "package $dst;Module::Load::load('$src', qw/@@exp/);";
    $@@ && die "$@@";
d16 1
a16 9
sub autoload_remote($$;@@){
    my ($dst, $src, @@exp) = @@_;

    eval "package $dst;Module::Load::autoload('$src', qw/@@exp/);";
    $@@ && die "$@@";
}

sub _load{
    my $autoimport = $_[0] eq 'autoimport' and shift;
a36 1

d39 4
a42 9

    ((@@_ or $autoimport) and (
        $import = $mod->can('import')
        ) and (
        unshift(@@_, $mod),
        goto &$import,
        return
        )
    );
a43 1

d95 1
a95 6
  use Module::Load;

  my $module = 'Data::Dumper';

  load Data::Dumper;     # loads that module, but not import any functions
                         # -> cannot use 'Dumper' function
d97 4
a100 2
  load 'Data::Dumper';   # ditto
  load $module           # tritto
d102 3
a104 2
  autoload Data::Dumper; # loads that module and imports the default functions
                         # -> can use 'Dumper' function
d106 1
a106 3
  my $script = 'some/script.pl'
  load $script;
  load 'some/script.pl';  # use quotes because of punctuations
d108 1
a108 1
  load thing;             # try 'thing' first, then 'thing.pm'
a109 1
  load CGI, ':all';       # like 'use CGI qw[:standard]'
d113 2
a114 2
C<Module::Load> eliminates the need to know whether you are trying
to require either a file or a module.
d127 1
a127 69
C<Module::Load> eliminates the need for this overhead and will
just DWYM.

=head2 Difference between C<load> and C<autoload>

C<Module::Load> imports the two functions - C<load> and C<autoload>

C<autoload> imports the default functions automatically,
but C<load> do not import any functions.

C<autoload> is usable under C<BEGIN{};>.

Both the functions can import the functions that are specified.

Following codes are same.

  load File::Spec::Functions, qw/splitpath/;

  autoload File::Spec::Functions, qw/splitpath/;

=head1 FUNCTIONS

=over 4

=item load

Loads a specified module.

See L</Rules> for detailed loading rule.

=item autoload

Loads a specified module and imports the default functions.

Except importing the functions, 'autoload' is same as 'load'.

=item load_remote

Loads a specified module to the specified package.

  use Module::Load 'load_remote';

  my $pkg = 'Other::Package';

  load_remote $pkg, 'Data::Dumper'; # load a module to 'Other::Package'
                                    # but do not import 'Dumper' function

A module for loading must be quoted.

Except specifing the package and quoting module name,
'load_remote' is same as 'load'.

=item autoload_remote

Loads a specified module and imports the default functions to the specified package.

  use Module::Load 'autoload_remote';

  my $pkg = 'Other::Package';

  autoload_remote $pkg, 'Data::Dumper'; # load a module to 'Other::Package'
                                        # and imports 'Dumper' function

A module for loading must be quoted.

Except specifing the package and quoting module name,
'autoload_remote' is same as 'load_remote'.

=back
d131 1
a131 2
All functions have the following rules to decide what it thinks
you want:
a152 40
=head1 IMPORTS THE FUNCTIONS

'load' and 'autoload' are imported by default, but 'load_remote' and
'autoload_remote' are not imported.

To use 'load_remote' or 'autoload_remote', specify at 'use'.

=over 4

=item "load","autoload","load_remote","autoload_remote"

Imports the selected functions.

  # imports 'load' and 'autoload' (default)
  use Module::Load;

  # imports 'autoload' only
  use Module::Load 'autoload';

  # imports 'autoload' and 'autoload_remote', but don't import 'load';
  use Module::Load qw/autoload autoload_remote/;

=item 'all'

Imports all the functions.

  use Module::Load 'all'; # imports load, autoload, load_remote, autoload_remote

=item '','none',undef

Not import any functions (C<load> and C<autoload> are not imported).

  use Module::Load '';

  use Module::Load 'none';

  use Module::Load undef;

=back

d182 1
@


