head	1.5;
access;
symbols
	OPENBSD_6_0:1.4.0.10
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.4
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.3.0.8
	OPENBSD_5_6_BASE:1.3
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.2.0.10
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.8
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2017.02.05.00.31.56;	author afresh1;	state Exp;
branches;
next	1.4;
commitid	cxJ08BvJA9Pt2PTM;

1.4
date	2014.11.17.20.56.58;	author afresh1;	state Exp;
branches;
next	1.3;
commitid	QP75iYx42Uo7mMxO;

1.3
date	2013.03.25.20.40.48;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2010.09.24.15.06.46;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.24.14.49.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.01;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.06.59;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.11.17.20.52.43;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.5
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!/usr/bin/perl -w
################################################################################
#
#  apicheck.pl -- generate C source for automated API check
#
################################################################################
#
#  Version 3.x, Copyright (C) 2004-2013, Marcus Holland-Moritz.
#  Version 2.x, Copyright (C) 2001, Paul Marquess.
#  Version 1.x, Copyright (C) 1999, Kenneth Albanowski.
#
#  This program is free software; you can redistribute it and/or
#  modify it under the same terms as Perl itself.
#
################################################################################

use strict;
require 'parts/ppptools.pl';

if (@@ARGV) {
  my $file = pop @@ARGV;
  open OUT, ">$file" or die "$file: $!\n";
}
else {
  *OUT = \*STDOUT;
}

my @@f = parse_embed(qw( parts/embed.fnc parts/apidoc.fnc parts/ppport.fnc ));

my %todo = %{&parse_todo};

my %tmap = (
  void => 'int',
);

my %amap = (
  SP   => 'SP',
  type => 'int',
  cast => 'int',
);

my %void = (
  void     => 1,
  Free_t   => 1,
  Signal_t => 1,
);

my %castvoid = (
  map { ($_ => 1) } qw(
    Nullav
    Nullcv
    Nullhv
    Nullch
    Nullsv
    HEf_SVKEY
    SP
    MARK
    SVt_PV
    SVt_IV
    SVt_NV
    SVt_PVMG
    SVt_PVAV
    SVt_PVHV
    SVt_PVCV
    SvUOK
    G_SCALAR
    G_ARRAY
    G_VOID
    G_DISCARD
    G_EVAL
    G_NOARGS
    XS_VERSION
  ),
);

my %ignorerv = (
  map { ($_ => 1) } qw(
    newCONSTSUB
  ),
);

my %stack = (
  ORIGMARK       => ['dORIGMARK;'],
  POPpx          => ['STRLEN n_a;'],
  POPpbytex      => ['STRLEN n_a;'],
  PUSHp          => ['dTARG;'],
  PUSHn          => ['dTARG;'],
  PUSHi          => ['dTARG;'],
  PUSHu          => ['dTARG;'],
  XPUSHp         => ['dTARG;'],
  XPUSHn         => ['dTARG;'],
  XPUSHi         => ['dTARG;'],
  XPUSHu         => ['dTARG;'],
  UNDERBAR       => ['dUNDERBAR;'],
  XCPT_TRY_START => ['dXCPT;'],
  XCPT_TRY_END   => ['dXCPT;'],
  XCPT_CATCH     => ['dXCPT;'],
  XCPT_RETHROW   => ['dXCPT;'],
);

my %ignore = (
  map { ($_ => 1) } qw(
    svtype
    items
    ix
    dXSI32
    XS
    CLASS
    THIS
    RETVAL
    StructCopy
  ),
);

print OUT <<HEAD;
/*
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by $0.
 * Any changes made here will be lost!
 */

#include "EXTERN.h"
#include "perl.h"

#define NO_XSLOCKS
#include "XSUB.h"

#ifdef DPPP_APICHECK_NO_PPPORT_H

/* This is just to avoid too many baseline failures with perls < 5.6.0 */

#ifndef dTHX
#  define dTHX extern int Perl___notused
#endif

#else

#define NEED_PL_signals
#define NEED_PL_parser
#define NEED_caller_cx
#define NEED_eval_pv
#define NEED_grok_bin
#define NEED_grok_hex
#define NEED_grok_number
#define NEED_grok_numeric_radix
#define NEED_grok_oct
#define NEED_load_module
#define NEED_my_snprintf
#define NEED_my_sprintf
#define NEED_mg_findext
#define NEED_my_strlcat
#define NEED_my_strlcpy
#define NEED_newCONSTSUB
#define NEED_newRV_noinc
#define NEED_newSV_type
#define NEED_newSVpvn_share
#define NEED_pv_display
#define NEED_pv_escape
#define NEED_pv_pretty
#define NEED_sv_2pv_flags
#define NEED_sv_2pvbyte
#define NEED_sv_catpvf_mg
#define NEED_sv_catpvf_mg_nocontext
#define NEED_sv_pvn_force_flags
#define NEED_sv_setpvf_mg
#define NEED_sv_setpvf_mg_nocontext
#define NEED_sv_unmagicext
#define NEED_vload_module
#define NEED_vnewSVpvf
#define NEED_warner
#define NEED_newSVpvn_flags

#include "ppport.h"

#endif

static int    VARarg1;
static char  *VARarg2;
static double VARarg3;

#if defined(PERL_BCDVERSION) && (PERL_BCDVERSION < 0x5009005)
/* needed to make PL_parser apicheck work */
typedef void yy_parser;
#endif

HEAD

if (@@ARGV) {
  my %want = map { ($_ => 0) } @@ARGV;
  @@f = grep { exists $want{$_->{name}} } @@f;
  for (@@f) { $want{$_->{name}}++ }
  for (keys %want) {
    die "nothing found for '$_'\n" unless $want{$_};
  }
}

my $f;
for $f (@@f) {
  $ignore{$f->{name}} and next;
  $f->{flags}{A} or next;  # only public API members

  $ignore{$f->{name}} = 1; # ignore duplicates

  my $Perl_ = $f->{flags}{p} ? 'Perl_' : '';

  my $stack = '';
  my @@arg;
  my $aTHX = '';

  my $i = 1;
  my $ca;
  my $varargs = 0;
  for $ca (@@{$f->{args}}) {
    my $a = $ca->[0];
    if ($a eq '...') {
      $varargs = 1;
      push @@arg, qw(VARarg1 VARarg2 VARarg3);
      last;
    }
    my($n, $p, $d) = $a =~ /^ (\w+(?:\s+\w+)*)\s*  # type name  => $n
                              (\**)                # pointer    => $p
                              (?:\s*const\s*)?     # const
                              ((?:\[[^\]]*\])*)    # dimension  => $d
                            $/x
                     or die "$0 - cannot parse argument: [$a]\n";
    if (exists $amap{$n}) {
      push @@arg, $amap{$n};
      next;
    }
    $n = $tmap{$n} || $n;
    if ($n eq 'const char' and $p eq '*' and !$f->{flags}{f}) {
      push @@arg, '"foo"';
    }
    else {
      my $v = 'arg' . $i++;
      push @@arg, $v;
      $stack .= "  static $n $p$v$d;\n";
    }
  }

  unless ($f->{flags}{n} || $f->{flags}{'m'}) {
    $stack = "  dTHX;\n$stack";
    $aTHX = @@arg ? 'aTHX_ ' : 'aTHX';
  }

  if ($stack{$f->{name}}) {
    my $s = '';
    for (@@{$stack{$f->{name}}}) {
      $s .= "  $_\n";
    }
    $stack = "$s$stack";
  }

  my $args = join ', ', @@arg;
  my $rvt = $f->{ret} || 'void';
  my $ret;
  if ($void{$rvt}) {
    $ret = $castvoid{$f->{name}} ? '(void) ' : '';
  }
  else {
    $stack .= "  $rvt rval;\n";
    $ret = $ignorerv{$f->{name}} ? '(void) ' : "rval = ";
  }
  my $aTHX_args = "$aTHX$args";

  if (!$f->{flags}{'m'} or $f->{flags}{'b'} or @@arg > 0) {
    $args = "($args)";
    $aTHX_args = "($aTHX_args)";
  }

  print OUT <<HEAD;
/******************************************************************************
*
*  $f->{name}
*
******************************************************************************/

HEAD

  if ($todo{$f->{name}}) {
    my($ver,$sub) = $todo{$f->{name}} =~ /^5\.(\d{3})(\d{3})$/ or die;
    for ($ver, $sub) {
      s/^0+(\d)/$1/
    }
    if ($ver < 6 && $sub > 0) {
      $sub =~ s/0$// or die;
    }
    print OUT "#if PERL_VERSION > $ver || (PERL_VERSION == $ver && PERL_SUBVERSION >= $sub) /* TODO */\n";
  }

  my $final = $varargs
              ? "$Perl_$f->{name}$aTHX_args"
              : "$f->{name}$args";

  $f->{cond} and print OUT "#if $f->{cond}\n";

  print OUT <<END;
void _DPPP_test_$f->{name} (void)
{
  dXSARGS;
$stack
  {
#ifdef $f->{name}
    $ret$f->{name}$args;
#endif
  }

  {
#ifdef $f->{name}
    $ret$final;
#else
    $ret$Perl_$f->{name}$aTHX_args;
#endif
  }
}
END

  $f->{cond} and print OUT "#endif\n";
  $todo{$f->{name}} and print OUT "#endif\n";

  print OUT "\n";
}

@@ARGV and close OUT;
@


1.4
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d140 1
d150 1
d167 1
d180 5
@


1.3
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d8 1
a8 7
#  $Revision: 37 $
#  $Author: mhx $
#  $Date: 2010/03/07 13:15:43 +0100 $
#
################################################################################
#
#  Version 3.x, Copyright (C) 2004-2010, Marcus Holland-Moritz.
a316 1

@


1.2
log
@merge in perl 5.12.2 plus local changes
@
text
@d8 1
a8 1
#  $Revision: 35 $
d10 1
a10 1
#  $Date: 2009/06/12 12:29:35 +0200 $
d14 1
a14 1
#  Version 3.x, Copyright (C) 2004-2009, Marcus Holland-Moritz.
d264 1
a264 1
  unless ($f->{flags}{'m'} and @@arg == 0) {
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d8 1
a8 1
#  $Revision: 37 $
d10 1
a10 1
#  $Date: 2010/03/07 13:15:43 +0100 $
d14 1
a14 1
#  Version 3.x, Copyright (C) 2004-2010, Marcus Holland-Moritz.
d264 1
a264 1
  if (!$f->{flags}{'m'} or $f->{flags}{'b'} or @@arg > 0) {
@


1.1.1.3
log
@Import perl-5.20.1
@
text
@d8 7
a14 1
#  Version 3.x, Copyright (C) 2004-2013, Marcus Holland-Moritz.
d323 1
@


