head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.10
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.4
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.6
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.8
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2010.09.24.14.49.00;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.00;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.08.15;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.11.17.20.52.59;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@#!/usr/bin/perl -w

use strict;
use lib 't/lib';

use Test::More tests => 76;

use File::Spec;
use TAP::Parser;
use TAP::Parser::IteratorFactory;
use Config;

sub array_ref_from {
    my $string = shift;
    my @@lines = split /\n/ => $string;
    return \@@lines;
}

# we slurp __DATA__ and then reset it so we don't have to duplicate our TAP
my $offset = tell DATA;
my $tap = do { local $/; <DATA> };
seek DATA, $offset, 0;

my $did_setup    = 0;
my $did_teardown = 0;

my $setup    = sub { $did_setup++ };
my $teardown = sub { $did_teardown++ };

package NoForkProcess;
use vars qw( @@ISA );
@@ISA = qw( TAP::Parser::Iterator::Process );

sub _use_open3 {return}

package main;

my @@schedule = (
    {   name     => 'Process',
        subclass => 'TAP::Parser::Iterator::Process',
        source   => {
            command => [
                $^X,
                File::Spec->catfile(
                    't',
                    'sample-tests',
                    'out_err_mix'
                )
            ],
            merge    => 1,
            setup    => $setup,
            teardown => $teardown,
        },
        after => sub {
            is $did_setup,    1, "setup called";
            is $did_teardown, 1, "teardown called";
        },
        need_open3 => 15,
    },
    {   name     => 'Array',
        subclass => 'TAP::Parser::Iterator::Array',
        source   => array_ref_from($tap),
    },
    {   name     => 'Stream',
        subclass => 'TAP::Parser::Iterator::Stream',
        source   => \*DATA,
    },
    {   name     => 'Process (Perl -e)',
        subclass => 'TAP::Parser::Iterator::Process',
        source =>
          { command => [ $^X, '-e', 'print qq/one\ntwo\n\nthree\n/' ] },
    },
    {   name     => 'Process (NoFork)',
        subclass => 'TAP::Parser::Iterator::Process',
        class    => 'NoForkProcess',
        source =>
          { command => [ $^X, '-e', 'print qq/one\ntwo\n\nthree\n/' ] },
    },
);

sub _can_open3 {
    return $Config{d_fork};
}

my $factory = TAP::Parser::IteratorFactory->new;
for my $test (@@schedule) {
    SKIP: {
        my $name       = $test->{name};
        my $need_open3 = $test->{need_open3};
        skip "No open3", $need_open3 if $need_open3 && !_can_open3();
        my $subclass = $test->{subclass};
        my $source   = $test->{source};
        my $class    = $test->{class};
        my $iter
          = $class
          ? $class->new($source)
          : $factory->make_iterator($source);
        ok $iter,     "$name: We should be able to create a new iterator";
        isa_ok $iter, 'TAP::Parser::Iterator',
          '... and the object it returns';
        isa_ok $iter, $subclass, '... and the object it returns';

        can_ok $iter, 'exit';
        ok !defined $iter->exit,
          "$name: ... and it should be undef before we are done ($subclass)";

        can_ok $iter, 'next';
        is $iter->next, 'one', "$name: next() should return the first result";

        is $iter->next, 'two',
          "$name: next() should return the second result";

        is $iter->next, '', "$name: next() should return the third result";

        is $iter->next, 'three',
          "$name: next() should return the fourth result";

        ok !defined $iter->next,
          "$name: next() should return undef after it is empty";

        is $iter->exit, 0,
          "$name: ... and exit should now return 0 ($subclass)";

        is $iter->wait, 0, "$name: wait should also now return 0 ($subclass)";

        if ( my $after = $test->{after} ) {
            $after->();
        }
    }
}

{

    # coverage tests for the ctor

    my $stream = $factory->make_iterator( IO::Handle->new );

    isa_ok $stream, 'TAP::Parser::Iterator::Stream';

    my @@die;

    eval {
        local $SIG{__DIE__} = sub { push @@die, @@_ };

        $factory->make_iterator( \1 );    # a ref to a scalar
    };

    is @@die, 1, 'coverage of error case';

    like pop @@die, qr/Can't iterate with a SCALAR/,
      '...and we died as expected';
}

{

    # coverage test for VMS case

    my $stream = $factory->make_iterator(
        [   'not ',
            'ok 1 - I hate VMS',
        ]
    );

    is $stream->next, 'not ok 1 - I hate VMS',
      'coverage of VMS line-splitting case';

    # coverage test for VMS case - nothing after 'not'

    $stream = $factory->make_iterator(
        [   'not ',
        ]
    );

    is $stream->next, 'not ', '...and we find "not" by itself';
}

SKIP: {
    skip "No open3", 4 unless _can_open3();

    # coverage testing for TAP::Parser::Iterator::Process ctor

    my @@die;

    eval {
        local $SIG{__DIE__} = sub { push @@die, @@_ };

        $factory->make_iterator( {} );
    };

    is @@die, 1, 'coverage testing for TPI::Process';

    like pop @@die, qr/Must supply a command to execute/,
      '...and we died as expected';

    my $parser = $factory->make_iterator(
        {   command => [
                $^X,
                File::Spec->catfile( 't', 'sample-tests', 'out_err_mix' )
            ],
            merge => 1,
        }
    );

    is $parser->{err}, '',    'confirm we set err to empty string';
    is $parser->{sel}, undef, '...and selector to undef';

    # And then we read from the parser to sidestep the Mac OS / open3
    # bug which frequently throws an error here otherwise.
    $parser->next;
}
__DATA__
one
two

three
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d10 1
a10 1
use TAP::Parser::Iterator::Array;
d85 1
d94 1
a94 1
        my $iterator
d97 3
a99 4
          : make_iterator($source);

        ok $iterator,     "$name: We should be able to create a new iterator";
        isa_ok $iterator, 'TAP::Parser::Iterator',
d101 1
a101 1
        isa_ok $iterator, $subclass, '... and the object it returns';
d103 2
a104 2
        can_ok $iterator, 'exit';
        ok !defined $iterator->exit,
d107 2
a108 3
        can_ok $iterator, 'next';
        is $iterator->next, 'one',
          "$name: next() should return the first result";
d110 1
a110 1
        is $iterator->next, 'two',
d113 1
a113 2
        is $iterator->next, '',
          "$name: next() should return the third result";
d115 1
a115 1
        is $iterator->next, 'three',
d118 1
a118 1
        ok !defined $iterator->next,
d121 1
a121 1
        is $iterator->exit, 0,
d124 1
a124 2
        is $iterator->wait, 0,
          "$name: wait should also now return 0 ($subclass)";
d136 1
a136 1
    my $iterator = make_iterator( IO::Handle->new );
d138 1
a138 1
    isa_ok $iterator, 'TAP::Parser::Iterator::Stream';
d144 2
a145 1
        make_iterator( \1 );    # a ref to a scalar
d158 1
a158 1
    my $iterator = make_iterator(
d164 1
a164 1
    is $iterator->next, 'not ok 1 - I hate VMS',
d169 1
a169 1
    $iterator = make_iterator(
d174 1
a174 1
    is $iterator->next, 'not ', '...and we find "not" by itself';
d186 2
a187 1
        make_iterator( {} );
d195 1
a195 1
    my $parser = make_iterator(
a210 18

sub make_iterator {
    my $thing = shift;
    my $ref   = ref $thing;
    if ( $ref eq 'GLOB' || UNIVERSAL::isa( $ref, 'IO::Handle' ) ) {
        return TAP::Parser::Iterator::Stream->new($thing);
    }
    elsif ( $ref eq 'ARRAY' ) {
        return TAP::Parser::Iterator::Array->new($thing);
    }
    elsif ( $ref eq 'HASH' ) {
        return TAP::Parser::Iterator::Process->new($thing);
    }
    else {
        die "Can't iterate with a $ref";
    }
}

@


1.1.1.3
log
@Import perl-5.20.1
@
text
@a3 1
use warnings;
d31 2
a32 1
use base qw( TAP::Parser::Iterator::Process );
@


