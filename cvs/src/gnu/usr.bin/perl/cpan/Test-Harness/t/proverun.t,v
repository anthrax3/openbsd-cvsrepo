head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.3.0.8
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.10
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.4
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.6
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.8
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2010.09.24.14.49.00;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.00;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.08.16;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.11.17.20.52.59;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@#!/usr/bin/perl -w

BEGIN {
    unshift @@INC, 't/lib';
}

use strict;
use Test::More;
use File::Spec;
use App::Prove;

my @@SCHEDULE;

BEGIN {

    # to add a new test to proverun, just list the name of the file in
    # t/sample-tests and a name for the test.  The rest is handled
    # automatically.
    my @@tests = (
        {   file => 'simple',
            name => 'Create empty',
        },
        {   file => 'todo_inline',
            name => 'Passing TODO',
        },
    );
    foreach my $test (@@tests) {

        # let's fully expand that filename
        $test->{file} = File::Spec->catfile(
            't',
            'sample-tests',
            $test->{file}
        );
    }
    @@SCHEDULE = (
        map {
            {   name   => $_->{name},
                args   => [ $_->{file} ],
                expect => [
                    [   'new',
                        'TAP::Parser::Iterator::Process',
                        {   merge   => undef,
                            command => [
                                'PERL',
                                $_->{file},
                            ],
                            setup    => \'CODE',
                            teardown => \'CODE',

                        }
                    ]
                ]
            }
          } @@tests
    );

    plan tests => @@SCHEDULE * 3;
}

# Waaaaay too much boilerplate

package FakeProve;
use vars qw( @@ISA );

@@ISA = qw( App::Prove );

sub new {
    my $class = shift;
    my $self  = $class->SUPER::new(@@_);
    $self->{_log} = [];
    return $self;
}

sub get_log {
    my $self = shift;
    my @@log  = @@{ $self->{_log} };
    $self->{_log} = [];
    return @@log;
}

package main;

{
    use TAP::Parser::Iterator::Process;
    use TAP::Formatter::Console;

    # Patch TAP::Parser::Iterator::Process
    my @@call_log = ();

    local $^W;    # no warnings

    my $orig_new = TAP::Parser::Iterator::Process->can('new');

    # Avoid "used only once" warning
    *TAP::Parser::Iterator::Process::new
      = *TAP::Parser::Iterator::Process::new = sub {
        push @@call_log, [ 'new', @@_ ];

        # And then new turns round and tramples on our args...
        $_[1] = { %{ $_[1] } };
        $orig_new->(@@_);
      };

    # Patch TAP::Formatter::Console;
    my $orig_output = \&TAP::Formatter::Console::_output;
    *TAP::Formatter::Console::_output = sub {

        # push @@call_log, [ '_output', @@_ ];
    };

    sub get_log {
        my @@log = @@call_log;
        @@call_log = ();
        return @@log;
    }
}

sub _slacken {
    my $obj = shift;
    if ( my $ref = ref $obj ) {
        if ( 'HASH' eq ref $obj ) {
            return { map { $_ => _slacken( $obj->{$_} ) } keys %$obj };
        }
        elsif ( 'ARRAY' eq ref $obj ) {
            return [ map { _slacken($_) } @@$obj ];
        }
        elsif ( 'SCALAR' eq ref $obj ) {
            return $obj;
        }
        else {
            return \$ref;
        }
    }
    else {
        return $obj;
    }
}

sub is_slackly($$$) {
    my ( $got, $want, $msg ) = @@_;
    return is_deeply _slacken($got), _slacken($want), $msg;
}

# ACTUAL TEST
for my $test (@@SCHEDULE) {
    my $name = $test->{name};

    my $app = FakeProve->new;
    $app->process_args( '--norc', @@{ $test->{args} } );

    # Why does this make the output from the test spew out of
    # our STDOUT?
    ok eval { $app->run }, 'run returned true';
    ok !$@@, 'no errors' or diag $@@;

    my @@log = get_log();

    # Bodge: we don't know what pathname will be used for the exe so we
    # obliterate it here. Need to test that it's sane.
    for my $call (@@log) {
        if ( 'HASH' eq ref $call->[2] && exists $call->[2]->{command} ) {
            $call->[2]->{command}->[0] = 'PERL';
        }
    }

    is_slackly \@@log, $test->{expect}, "$name: command args OK";

    # use Data::Dumper;
    # diag Dumper(
    #     {   got    => \@@log,
    #         expect => $test->{expect}
    #     }
    # );
}

@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a10 1
use TAP::Parser::Utils qw( split_shell );
a14 1
    my $t_dir = File::Spec->catdir('t');
d27 1
a27 5

    # TODO: refactor this and add in a test for:
    # prove --source 'File: {extensions: [.1]}' t/source_tests/source.1

    for my $test (@@tests) {
d30 5
a34 2
        $test->{file}
          = File::Spec->catfile( $t_dir, 'sample-tests', $test->{file} );
a45 3
                                $ENV{HARNESS_PERL_SWITCHES}
                                ? split_shell( $ENV{HARNESS_PERL_SWITCHES} )
                                : (),
d55 1
a55 1
          } @@tests,
@


1.1.1.3
log
@Import perl-5.20.1
@
text
@a7 1
use warnings;
d11 1
a11 1
use Text::ParseWords qw(shellwords);
d50 1
a50 1
                                ? shellwords( $ENV{HARNESS_PERL_SWITCHES} )
d70 1
d72 1
a72 1
use base qw( App::Prove );
d97 1
a97 1
    no warnings qw(redefine once);
d101 3
a103 1
    *TAP::Parser::Iterator::Process::new = sub {
@


