head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.5
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.4.0.10
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.4
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.6
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.04;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2010.09.24.14.49.00;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.00;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.08.16;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.57;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.52.59;	author afresh1;	state Exp;
branches;
next	1.1.1.5;
commitid	B31cAbBIXiCqnL97;

1.1.1.5
date	2017.08.14.13.46.03;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!/usr/bin/perl -w

BEGIN {
    unshift @@INC, 't/lib';
}

use strict;
use warnings;

use Test::More;
use File::Spec;

use App::Prove;
use Getopt::Long;

use Text::ParseWords qw(shellwords);

package FakeProve;

use base qw( App::Prove );

sub new {
    my $class = shift;
    my $self  = $class->SUPER::new(@@_);
    $self->{_log} = [];
    return $self;
}

sub _color_default {0}

sub _runtests {
    my $self = shift;
    push @@{ $self->{_log} }, [ '_runtests', @@_ ];
}

sub get_log {
    my $self = shift;
    my @@log  = @@{ $self->{_log} };
    $self->{_log} = [];
    return @@log;
}

sub _shuffle {
    my $self = shift;
    s/^/xxx/ for @@_;
}

package main;

sub mabs {
    my $ar = shift;
    return [ map { File::Spec->rel2abs($_) } @@$ar ];
}

{
    my @@import_log = ();
    sub test_log_import { push @@import_log, [@@_] }

    sub get_import_log {
        my @@log = @@import_log;
        @@import_log = ();
        return @@log;
    }

    my @@plugin_load_log = ();
    sub test_log_plugin_load { push @@plugin_load_log, [@@_] }

    sub get_plugin_load_log {
        my @@log = @@plugin_load_log;
        @@plugin_load_log = ();
        return @@log;
    }
}

my ( @@ATTR, %DEFAULT_ASSERTION, @@SCHEDULE, $HAS_YAML );

# see the "ACTUAL TEST" section at the bottom

BEGIN {    # START PLAN
    $HAS_YAML = 0;
    eval { require YAML; $HAS_YAML = 1; };

    # list of attributes
    @@ATTR = qw(
      archive argv blib color directives exec extensions failures
      formatter harness includes lib merge parse quiet really_quiet
      recurse backwards shuffle taint_fail taint_warn verbose
      warnings_fail warnings_warn
    );

    # what we expect if the 'expect' hash does not define it
    %DEFAULT_ASSERTION = map { $_ => undef } @@ATTR;

    $DEFAULT_ASSERTION{includes} = $DEFAULT_ASSERTION{argv}
      = sub { 'ARRAY' eq ref shift };

    my @@dummy_tests = map { File::Spec->catdir( 't', 'sample-tests', $_ ) }
      qw(simple simple_yaml);
    my $dummy_test = $dummy_tests[0];

    ########################################################################
 # declarations - this drives all of the subtests.
 # The cheatsheet follows.
 # required: name, expect
 # optional:
 #   args       - arguments to constructor
 #   switches   - command-line switches
 #   runlog     - expected results of internal calls to _runtests, must
 #                match FakeProve's _log attr
 #   run_error  - depends on 'runlog' (if missing, asserts no error)
 #   extra      - follow-up check to handle exceptional cleanup / verification
 #   class      - The App::Prove subclass to test. Defaults to FakeProve
    @@SCHEDULE = (
        {   name   => 'Create empty',
            expect => {}
        },
        {   name => 'Set all options via constructor',
            args => {
                archive       => 1,
                argv          => [qw(one two three)],
                blib          => 2,
                color         => 3,
                directives    => 4,
                exec          => 5,
                failures      => 7,
                formatter     => 8,
                harness       => 9,
                includes      => [qw(four five six)],
                lib           => 10,
                merge         => 11,
                parse         => 13,
                quiet         => 14,
                really_quiet  => 15,
                recurse       => 16,
                backwards     => 17,
                shuffle       => 18,
                taint_fail    => 19,
                taint_warn    => 20,
                verbose       => 21,
                warnings_fail => 22,
                warnings_warn => 23,
            },
            expect => {
                archive       => 1,
                argv          => [qw(one two three)],
                blib          => 2,
                color         => 3,
                directives    => 4,
                exec          => 5,
                failures      => 7,
                formatter     => 8,
                harness       => 9,
                includes      => [qw(four five six)],
                lib           => 10,
                merge         => 11,
                parse         => 13,
                quiet         => 14,
                really_quiet  => 15,
                recurse       => 16,
                backwards     => 17,
                shuffle       => 18,
                taint_fail    => 19,
                taint_warn    => 20,
                verbose       => 21,
                warnings_fail => 22,
                warnings_warn => 23,
            }
        },
        {   name   => 'Call with defaults',
            args   => { argv => [qw( one two three )] },
            expect => {},
            runlog => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },

        # Test all options individually

        # {   name => 'Just archive',
        #     args => {
        #         argv    => [qw( one two three )],
        #         archive => 1,
        #     },
        #     expect => {
        #         archive => 1,
        #     },
        #     runlog => [
        #         [   {   archive => 1,
        #             },
        #             'one', 'two',
        #             'three'
        #         ]
        #     ],
        # },
        {   name => 'Just argv',
            args => {
                argv => [qw( one two three )],
            },
            expect => {
                argv => [qw( one two three )],
            },
            runlog => [
                [   '_runtests',
                    { verbosity => 0, show_count => 1 },
                    'one', 'two',
                    'three'
                ]
            ],
        },
        {   name => 'Just blib',
            args => {
                argv => [qw( one two three )],
                blib => 1,
            },
            expect => {
                blib => 1,
            },
            runlog => [
                [   '_runtests',
                    {   lib => mabs( [ 'blib/lib', 'blib/arch' ] ),
                        verbosity  => 0,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },

        {   name => 'Just color',
            args => {
                argv  => [qw( one two three )],
                color => 1,
            },
            expect => {
                color => 1,
            },
            runlog => [
                [   '_runtests',
                    {   color      => 1,
                        verbosity  => 0,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },

        {   name => 'Just directives',
            args => {
                argv       => [qw( one two three )],
                directives => 1,
            },
            expect => {
                directives => 1,
            },
            runlog => [
                [   '_runtests',
                    {   directives => 1,
                        verbosity  => 0,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },
        {   name => 'Just exec',
            args => {
                argv => [qw( one two three )],
                exec => 1,
            },
            expect => {
                exec => 1,
            },
            runlog => [
                [   '_runtests',
                    {   exec       => [1],
                        verbosity  => 0,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },
        {   name => 'Just failures',
            args => {
                argv     => [qw( one two three )],
                failures => 1,
            },
            expect => {
                failures => 1,
            },
            runlog => [
                [   '_runtests',
                    {   failures   => 1,
                        verbosity  => 0,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },

        {   name => 'Just formatter',
            args => {
                argv      => [qw( one two three )],
                formatter => 'TAP::Harness',
            },
            expect => {
                formatter => 'TAP::Harness',
            },
            runlog => [
                [   '_runtests',
                    {   formatter_class => 'TAP::Harness',
                        verbosity       => 0,
                        show_count      => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },

        {   name => 'Just includes',
            args => {
                argv     => [qw( one two three )],
                includes => [qw( four five six )],
            },
            expect => {
                includes => [qw( four five six )],
            },
            runlog => [
                [   '_runtests',
                    {   lib => mabs( [qw( four five six )] ),
                        verbosity  => 0,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },
        {   name => 'Just lib',
            args => {
                argv => [qw( one two three )],
                lib  => 1,
            },
            expect => {
                lib => 1,
            },
            runlog => [
                [   '_runtests',
                    {   lib => mabs( ['lib'] ),
                        verbosity  => 0,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },
        {   name => 'Just merge',
            args => {
                argv  => [qw( one two three )],
                merge => 1,
            },
            expect => {
                merge => 1,
            },
            runlog => [
                [   '_runtests',
                    {   merge      => 1,
                        verbosity  => 0,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },
        {   name => 'Just parse',
            args => {
                argv  => [qw( one two three )],
                parse => 1,
            },
            expect => {
                parse => 1,
            },
            runlog => [
                [   '_runtests',
                    {   errors     => 1,
                        verbosity  => 0,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },
        {   name => 'Just quiet',
            args => {
                argv  => [qw( one two three )],
                quiet => 1,
            },
            expect => {
                quiet => 1,
            },
            runlog => [
                [   '_runtests',
                    {   verbosity  => -1,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },
        {   name => 'Just really_quiet',
            args => {
                argv         => [qw( one two three )],
                really_quiet => 1,
            },
            expect => {
                really_quiet => 1,
            },
            runlog => [
                [   '_runtests',
                    {   verbosity  => -2,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },
        {   name => 'Just recurse',
            args => {
                argv    => [qw( one two three )],
                recurse => 1,
            },
            expect => {
                recurse => 1,
            },
            runlog => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },
        {   name => 'Just reverse',
            args => {
                argv      => [qw( one two three )],
                backwards => 1,
            },
            expect => {
                backwards => 1,
            },
            runlog => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                    'three', 'two', 'one'
                ]
            ],
        },

        {   name => 'Just shuffle',
            args => {
                argv    => [qw( one two three )],
                shuffle => 1,
            },
            expect => {
                shuffle => 1,
            },
            runlog => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                    'xxxone', 'xxxtwo',
                    'xxxthree'
                ]
            ],
        },
        {   name => 'Just taint_fail',
            args => {
                argv       => [qw( one two three )],
                taint_fail => 1,
            },
            expect => {
                taint_fail => 1,
            },
            runlog => [
                [   '_runtests',
                    {   switches   => ['-T'],
                        verbosity  => 0,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },
        {   name => 'Just taint_warn',
            args => {
                argv       => [qw( one two three )],
                taint_warn => 1,
            },
            expect => {
                taint_warn => 1,
            },
            runlog => [
                [   '_runtests',
                    {   switches   => ['-t'],
                        verbosity  => 0,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },
        {   name => 'Just verbose',
            args => {
                argv    => [qw( one two three )],
                verbose => 1,
            },
            expect => {
                verbose => 1,
            },
            runlog => [
                [   '_runtests',
                    {   verbosity  => 1,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },
        {   name => 'Just warnings_fail',
            args => {
                argv          => [qw( one two three )],
                warnings_fail => 1,
            },
            expect => {
                warnings_fail => 1,
            },
            runlog => [
                [   '_runtests',
                    {   switches   => ['-W'],
                        verbosity  => 0,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },
        {   name => 'Just warnings_warn',
            args => {
                argv          => [qw( one two three )],
                warnings_warn => 1,
            },
            expect => {
                warnings_warn => 1,
            },
            runlog => [
                [   '_runtests',
                    {   switches   => ['-w'],
                        verbosity  => 0,
                        show_count => 1,
                    },
                    'one', 'two', 'three'
                ]
            ],
        },

        # Command line parsing
        {   name => 'Switch -v',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '-v', $dummy_test ],
            expect   => {
                verbose => 1,
            },
            runlog => [
                [   '_runtests',
                    {   verbosity  => 1,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch --verbose',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '--verbose', $dummy_test ],
            expect   => {
                verbose => 1,
            },
            runlog => [
                [   '_runtests',
                    {   verbosity  => 1,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch -f',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '-f', $dummy_test ],
            expect => { failures => 1 },
            runlog => [
                [   '_runtests',
                    {   failures   => 1,
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch --failures',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '--failures', $dummy_test ],
            expect => { failures => 1 },
            runlog => [
                [   '_runtests',
                    {   failures   => 1,
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch -l',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '-l', $dummy_test ],
            expect => { lib => 1 },
            runlog => [
                [   '_runtests',
                    {   lib => mabs( ['lib'] ),
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch --lib',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '--lib', $dummy_test ],
            expect => { lib => 1 },
            runlog => [
                [   '_runtests',
                    {   lib => mabs( ['lib'] ),
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch -b',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '-b', $dummy_test ],
            expect => { blib => 1 },
            runlog => [
                [   '_runtests',
                    {   lib => mabs( [ 'blib/lib', 'blib/arch' ] ),
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch --blib',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '--blib', $dummy_test ],
            expect => { blib => 1 },
            runlog => [
                [   '_runtests',
                    {   lib => mabs( [ 'blib/lib', 'blib/arch' ] ),
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch -s',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '-s', $dummy_test ],
            expect => { shuffle => 1 },
            runlog => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                    "xxx$dummy_test"
                ]
            ],
        },

        {   name => 'Switch --shuffle',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '--shuffle', $dummy_test ],
            expect => { shuffle => 1 },
            runlog => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                    "xxx$dummy_test"
                ]
            ],
        },

        {   name => 'Switch -c',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '-c', $dummy_test ],
            expect => { color => 1 },
            runlog => [
                [   '_runtests',
                    {   color      => 1,
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch -r',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '-r', $dummy_test ],
            expect => { recurse => 1 },
            runlog => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch --recurse',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '--recurse', $dummy_test ],
            expect => { recurse => 1 },
            runlog => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch --reverse',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '--reverse', @@dummy_tests ],
            expect => { backwards => 1 },
            runlog => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                    reverse @@dummy_tests
                ]
            ],
        },

        {   name => 'Switch -p',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '-p', $dummy_test ],
            expect   => {
                parse => 1,
            },
            runlog => [
                [   '_runtests',
                    {   errors     => 1,
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch --parse',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '--parse', $dummy_test ],
            expect   => {
                parse => 1,
            },
            runlog => [
                [   '_runtests',
                    {   errors     => 1,
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch -q',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '-q', $dummy_test ],
            expect => { quiet => 1 },
            runlog => [
                [   '_runtests',
                    {   verbosity  => -1,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch --quiet',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '--quiet', $dummy_test ],
            expect => { quiet => 1 },
            runlog => [
                [   '_runtests',
                    {   verbosity  => -1,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch -Q',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '-Q', $dummy_test ],
            expect => { really_quiet => 1 },
            runlog => [
                [   '_runtests',
                    {   verbosity  => -2,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch --QUIET',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '--QUIET', $dummy_test ],
            expect => { really_quiet => 1 },
            runlog => [
                [   '_runtests',
                    {   verbosity  => -2,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch -m',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '-m', $dummy_test ],
            expect => { merge => 1 },
            runlog => [
                [   '_runtests',
                    {   merge      => 1,
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch --merge',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '--merge', $dummy_test ],
            expect => { merge => 1 },
            runlog => [
                [   '_runtests',
                    {   merge      => 1,
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch --directives',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '--directives', $dummy_test ],
            expect => { directives => 1 },
            runlog => [
                [   '_runtests',
                    {   directives => 1,
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        # .proverc
        {   name => 'Empty exec in .proverc',
            args => {
                argv => [qw( one two three )],
            },
            proverc  => 't/proverc/emptyexec',
            switches => [$dummy_test],
            expect   => { exec => '' },
            runlog   => [
                [   '_runtests',
                    {   exec       => [],
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        # Executing one word (why would it be a -s though?)
        {   name => 'Switch --exec -s',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '--exec', '-s', $dummy_test ],
            expect => { exec => '-s' },
            runlog => [
                [   '_runtests',
                    {   exec       => ['-s'],
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        # multi-part exec
        {   name => 'Switch --exec "/foo/bar/perl -Ilib"',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '--exec', '/foo/bar/perl -Ilib', $dummy_test ],
            expect => { exec => '/foo/bar/perl -Ilib' },
            runlog => [
                [   '_runtests',
                    {   exec       => [qw(/foo/bar/perl -Ilib)],
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        # null exec (run tests as compiled binaries)
        {   name     => 'Switch --exec ""',
            switches => [ '--exec', '', $dummy_test ],
            expect   => {
                exec =>   # ick, must workaround the || default bit with a sub
                  sub { my $val = shift; defined($val) and !length($val) }
            },
            runlog => [
                [   '_runtests',
                    {   exec       => [],
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        # Specify an oddball extension
        {   name     => 'Switch --ext=.wango',
            switches => ['--ext=.wango'],
            expect   => { extensions => ['.wango'] },
            runlog   => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                ]
            ],
        },

        # Handle multiple extensions
        {   name     => 'Switch --ext=.foo --ext=.bar',
            switches => [ '--ext=.foo', '--ext=.bar', ],
            expect   => { extensions => [ '.foo', '.bar' ] },
            runlog   => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                ]
            ],
        },

        # Source handlers
        {   name     => 'Switch --source simple',
            args     => { argv => [qw( one two three )] },
            switches => [ '--source', 'MyCustom', $dummy_test ],
            expect   => {
                sources => {
                    MyCustom => {},
                },
            },
            runlog => [
                [   '_runtests',
                    {   sources => {
                            MyCustom => {},
                        },
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch --sources with config',
            args => { argv => [qw( one two three )] },
            skip => $Getopt::Long::VERSION >= 2.28 && $HAS_YAML ? 0 : 1,
            skip_reason => "YAML not available or Getopt::Long too old",
            switches    => [
                '--source',      'Perl',
                '--perl-option', 'foo=bar baz',
                '--perl-option', 'avg=0.278',
                '--source',      'MyCustom',
                '--source',      'File',
                '--file-option', 'extensions=.txt',
                '--file-option', 'extensions=.tmp',
                '--file-option', 'hash=this=that',
                '--file-option', 'hash=foo=bar',
                '--file-option', 'sep=foo\\=bar',
                $dummy_test
            ],
            expect => {
                sources => {
                    Perl     => { foo => 'bar baz', avg => 0.278 },
                    MyCustom => {},
                    File     => {
                        extensions => [ '.txt', '.tmp' ],
                        hash => { this => 'that', foo => 'bar' },
                        sep  => 'foo=bar',
                    },
                },
            },
            runlog => [
                [   '_runtests',
                    {   sources => {
                            Perl     => { foo => 'bar baz', avg => 0.278 },
                            MyCustom => {},
                            File     => {
                                extensions => [ '.txt', '.tmp' ],
                                hash => { this => 'that', foo => 'bar' },
                                sep  => 'foo=bar',
                            },
                        },
                        verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        # Plugins
        {   name     => 'Load plugin',
            switches => [ '-P', 'Dummy', $dummy_test ],
            args     => {
                argv => [qw( one two three )],
            },
            expect => {
                plugins => ['Dummy'],
            },
            extra => sub {
                my @@loaded = get_import_log();
                is_deeply \@@loaded, [ ['App::Prove::Plugin::Dummy'] ],
                  "Plugin loaded OK";
            },
            plan   => 1,
            runlog => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name     => 'Load plugin (args)',
            switches => [ '-P', 'Dummy=cracking,cheese,gromit', $dummy_test ],
            args     => {
                argv => [qw( one two three )],
            },
            expect => {
                plugins => ['Dummy'],
            },
            extra => sub {
                my @@loaded = get_import_log();
                is_deeply \@@loaded,
                  [ [   'App::Prove::Plugin::Dummy', 'cracking', 'cheese',
                        'gromit'
                    ]
                  ],
                  "Plugin loaded OK";
            },
            plan   => 1,
            runlog => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name     => 'Load plugin (explicit path)',
            switches => [ '-P', 'App::Prove::Plugin::Dummy', $dummy_test ],
            args     => {
                argv => [qw( one two three )],
            },
            expect => {
                plugins => ['Dummy'],
            },
            extra => sub {
                my @@loaded = get_import_log();
                is_deeply \@@loaded, [ ['App::Prove::Plugin::Dummy'] ],
                  "Plugin loaded OK";
            },
            plan   => 1,
            runlog => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name     => 'Load plugin (args + call load method)',
            switches => [ '-P', 'Dummy2=fou,du,fafa', $dummy_test ],
            args     => {
                argv => [qw( one two three )],
            },
            expect => {
                plugins => ['Dummy2'],
            },
            extra => sub {
                my @@import = get_import_log();
                is_deeply \@@import,
                  [ [ 'App::Prove::Plugin::Dummy2', 'fou', 'du', 'fafa' ] ],
                  "Plugin loaded OK";

                my @@loaded = get_plugin_load_log();
                is( scalar @@loaded, 1, 'Plugin->load called OK' );
                my ( $plugin_class, $args ) = @@{ shift @@loaded };
                is( $plugin_class, 'App::Prove::Plugin::Dummy2',
                    'plugin_class passed'
                );
                isa_ok(
                    $args->{app_prove}, 'App::Prove',
                    'app_prove object passed'
                );
                is_deeply(
                    $args->{args}, [qw( fou du fafa )],
                    'expected args passed'
                );
            },
            plan   => 5,
            runlog => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        {   name     => 'Load module',
            switches => [ '-M', 'App::Prove::Plugin::Dummy', $dummy_test ],
            args     => {
                argv => [qw( one two three )],
            },
            expect => {
                plugins => ['Dummy'],
            },
            extra => sub {
                my @@loaded = get_import_log();
                is_deeply \@@loaded, [ ['App::Prove::Plugin::Dummy'] ],
                  "Plugin loaded OK";
            },
            plan   => 1,
            runlog => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                    $dummy_test
                ]
            ],
        },

        # TODO
        # Hmm, that doesn't work...
        # {   name => 'Switch -h',
        #     args => {
        #         argv => [qw( one two three )],
        #     },
        #     switches => [ '-h', $dummy_test ],
        #     expect   => {},
        #     runlog   => [
        #         [   '_runtests',
        #             {},
        #             $dummy_test
        #         ]
        #     ],
        # },

        # {   name => 'Switch --help',
        #     args => {
        #         argv => [qw( one two three )],
        #     },
        #     switches => [ '--help', $dummy_test ],
        #     expect   => {},
        #     runlog   => [
        #         [   {},
        #             $dummy_test
        #         ]
        #     ],
        # },
        # {   name => 'Switch -?',
        #     args => {
        #         argv => [qw( one two three )],
        #     },
        #     switches => [ '-?', $dummy_test ],
        #     expect   => {},
        #     runlog   => [
        #         [   {},
        #             $dummy_test
        #         ]
        #     ],
        # },
        #
        # {   name => 'Switch -H',
        #     args => {
        #         argv => [qw( one two three )],
        #     },
        #     switches => [ '-H', $dummy_test ],
        #     expect   => {},
        #     runlog   => [
        #         [   {},
        #             $dummy_test
        #         ]
        #     ],
        # },
        #
        # {   name => 'Switch --man',
        #     args => {
        #         argv => [qw( one two three )],
        #     },
        #     switches => [ '--man', $dummy_test ],
        #     expect   => {},
        #     runlog   => [
        #         [   {},
        #             $dummy_test
        #         ]
        #     ],
        # },
        #
        # {   name => 'Switch -V',
        #     args => {
        #         argv => [qw( one two three )],
        #     },
        #     switches => [ '-V', $dummy_test ],
        #     expect   => {},
        #     runlog   => [
        #         [   {},
        #             $dummy_test
        #         ]
        #     ],
        # },
        #
        # {   name => 'Switch --version',
        #     args => {
        #         argv => [qw( one two three )],
        #     },
        #     switches => [ '--version', $dummy_test ],
        #     expect   => {},
        #     runlog   => [
        #         [   {},
        #             $dummy_test
        #         ]
        #     ],
        # },
        #
        # {   name => 'Switch --color!',
        #     args => {
        #         argv => [qw( one two three )],
        #     },
        #     switches => [ '--color!', $dummy_test ],
        #     expect   => {},
        #     runlog   => [
        #         [   {},
        #             $dummy_test
        #         ]
        #     ],
        # },
        #
        {   name => 'Switch -I=s@@',
            args => {
                argv => [qw( one two three )],
            },
            switches => [ '-Ilib', $dummy_test ],
            expect   => {
                includes => sub {
                    my ( $val, $attr ) = @@_;
                    return
                         'ARRAY' eq ref $val
                      && 1 == @@$val
                      && $val->[0] =~ /lib$/;
                },
            },
        },

        # {   name => 'Switch -a',
        #     args => {
        #         argv => [qw( one two three )],
        #     },
        #     switches => [ '-a', $dummy_test ],
        #     expect   => {},
        #     runlog   => [
        #         [   {},
        #             $dummy_test
        #         ]
        #     ],
        # },
        #
        # {   name => 'Switch --archive=-s',
        #     args => {
        #         argv => [qw( one two three )],
        #     },
        #     switches => [ '--archive=-s', $dummy_test ],
        #     expect   => {},
        #     runlog   => [
        #         [   {},
        #             $dummy_test
        #         ]
        #     ],
        # },
        #
        # {   name => 'Switch --formatter=-s',
        #     args => {
        #         argv => [qw( one two three )],
        #     },
        #     switches => [ '--formatter=-s', $dummy_test ],
        #     expect   => {},
        #     runlog   => [
        #         [   {},
        #             $dummy_test
        #         ]
        #     ],
        # },
        #
        # {   name => 'Switch -e',
        #     args => {
        #         argv => [qw( one two three )],
        #     },
        #     switches => [ '-e', $dummy_test ],
        #     expect   => {},
        #     runlog   => [
        #         [   {},
        #             $dummy_test
        #         ]
        #     ],
        # },
        #
        # {   name => 'Switch --harness=-s',
        #     args => {
        #         argv => [qw( one two three )],
        #     },
        #     switches => [ '--harness=-s', $dummy_test ],
        #     expect   => {},
        #     runlog   => [
        #         [   {},
        #             $dummy_test
        #         ]
        #     ],
        # },

    );

    # END SCHEDULE
    ########################################################################

    my $extra_plan = 0;
    for my $test (@@SCHEDULE) {
        my $plan = 0;
        $plan += $test->{plan} || 0;
        $plan += 2 if $test->{runlog};
        $plan += 1 if $test->{switches};
        $test->{_planned} = $plan + 3 + @@ATTR;
        $extra_plan += $plan;
    }

    plan tests => @@SCHEDULE * ( 3 + @@ATTR ) + $extra_plan;
}    # END PLAN

# ACTUAL TEST
for my $test (@@SCHEDULE) {
    my $name = $test->{name};
    my $class = $test->{class} || 'FakeProve';

    SKIP:
    {
        skip $test->{skip_reason}, $test->{_planned} if $test->{skip};

        local $ENV{HARNESS_TIMER};

        ok my $app = $class->new( exists $test->{args} ? $test->{args} : () ),
          "$name: App::Prove created OK";

        isa_ok $app, 'App::Prove';
        isa_ok $app, $class;

        # Optionally parse command args
        if ( my $switches = $test->{switches} ) {
            if ( my $proverc = $test->{proverc} ) {
                $app->add_rc_file(
                    File::Spec->catfile( split /\//, $proverc ) );
            }
            eval { $app->process_args( '--norc', @@$switches ) };
            if ( my $err_pattern = $test->{parse_error} ) {
                like $@@, $err_pattern, "$name: expected parse error";
            }
            else {
                ok !$@@, "$name: no parse error";
            }
        }

        my $expect = $test->{expect} || {};
        for my $attr ( sort @@ATTR ) {
            my $val = $app->$attr();
            my $assertion
              = exists $expect->{$attr}
              ? $expect->{$attr}
              : $DEFAULT_ASSERTION{$attr};
            my $is_ok = undef;

            if ( 'CODE' eq ref $assertion ) {
                $is_ok = ok $assertion->( $val, $attr ),
                  "$name: $attr has the expected value";
            }
            elsif ( 'Regexp' eq ref $assertion ) {
                $is_ok = like $val, $assertion,
                  "$name: $attr matches $assertion";
            }
            else {
                $is_ok = is_deeply $val, $assertion,
                  "$name: $attr has the expected value";
            }

            unless ($is_ok) {
                diag "got $val for $attr";
            }
        }

        if ( my $runlog = $test->{runlog} ) {
            eval { $app->run };
            if ( my $err_pattern = $test->{run_error} ) {
                like $@@, $err_pattern, "$name: expected error OK";
                pass;
                pass for 1 .. $test->{plan};
            }
            else {
                unless ( ok !$@@, "$name: no error OK" ) {
                    diag "$name: error: $@@\n";
                }

                my $gotlog = [ $app->get_log ];

                if ( my $extra = $test->{extra} ) {
                    $extra->($gotlog);
                }

                # adapt our expectations if HARNESS_PERL_SWITCHES is set
                push @@{ $runlog->[0][1]{switches} },
                  shellwords( $ENV{HARNESS_PERL_SWITCHES} )
                  if $ENV{HARNESS_PERL_SWITCHES};

                unless (
                    is_deeply $gotlog, $runlog,
                    "$name: run results match"
                  )
                {
                    use Data::Dumper;
                    diag Dumper( { wanted => $runlog, got => $gotlog } );
                }
            }
        }

    }    # SKIP
}

@


1.1
log
@Initial revision
@
text
@d8 1
d14 3
a18 1
use vars qw( @@ISA );
d20 1
a20 1
@@ISA = qw( App::Prove );
d75 1
a75 1
my ( @@ATTR, %DEFAULT_ASSERTION, @@SCHEDULE );
d80 2
d85 1
a85 1
      archive argv blib color directives exec extension failures
a176 1
                    'TAP::Harness',
a194 1
        #             'TAP::Harness',
a209 1
                    'TAP::Harness',
a228 1
                    'TAP::Harness',
a247 1
                    'TAP::Harness',
a266 1
                    'TAP::Harness',
a284 1
                    'TAP::Harness',
a302 1
                    'TAP::Harness',
a321 1
                    'TAP::Harness',
a340 1
                    'TAP::Harness',
a358 1
                    'TAP::Harness',
a376 1
                    'TAP::Harness',
a394 1
                    'TAP::Harness',
a411 1
                    'TAP::Harness',
a428 1
                    'TAP::Harness',
a445 1
                    'TAP::Harness',
a462 1
                    'TAP::Harness',
a480 1
                    'TAP::Harness',
a499 1
                    'TAP::Harness',
a517 1
                    'TAP::Harness',
a534 1
                    'TAP::Harness',
a552 1
                    'TAP::Harness',
a570 1
                    'TAP::Harness',
a589 1
                    'TAP::Harness',
a607 1
                    'TAP::Harness',
a624 1
                    'TAP::Harness',
a641 1
                    'TAP::Harness',
a658 1
                    'TAP::Harness',
a675 1
                    'TAP::Harness',
a692 1
                    'TAP::Harness',
a709 1
                    'TAP::Harness',
a725 1
                    'TAP::Harness',
a741 1
                    'TAP::Harness',
a758 1
                    'TAP::Harness',
a774 1
                    'TAP::Harness',
a790 1
                    'TAP::Harness',
a806 1
                    'TAP::Harness',
a825 1
                    'TAP::Harness',
a844 1
                    'TAP::Harness',
a860 1
                    'TAP::Harness',
a876 1
                    'TAP::Harness',
a892 1
                    'TAP::Harness',
a908 1
                    'TAP::Harness',
a925 1
                    'TAP::Harness',
a942 1
                    'TAP::Harness',
a959 1
                    'TAP::Harness',
a978 1
                    'TAP::Harness',
a996 1
                    'TAP::Harness',
a1014 1
                    'TAP::Harness',
d1033 95
a1127 1
                    'TAP::Harness',
a1152 1
                    'TAP::Harness',
a1180 1
                    'TAP::Harness',
a1204 1
                    'TAP::Harness',
a1244 1
                    'TAP::Harness',
a1268 1
                    'TAP::Harness',
a1284 1
        #             'TAP::Harness',
a1297 1
        #             'TAP::Harness',
a1309 1
        #             'TAP::Harness',
a1322 1
        #             'TAP::Harness',
a1335 1
        #             'TAP::Harness',
a1348 1
        #             'TAP::Harness',
a1361 1
        #             'TAP::Harness',
a1374 1
        #             'TAP::Harness',
a1403 1
        #             'TAP::Harness',
a1416 1
        #             'TAP::Harness',
a1429 1
        #             'TAP::Harness',
a1442 1
        #             'TAP::Harness',
a1455 1
        #             'TAP::Harness',
d1468 6
a1473 3
        $extra_plan += $test->{plan} || 0;
        $extra_plan += 2 if $test->{runlog};
        $extra_plan += 1 if $test->{switches};
d1484 25
a1508 16
    local $ENV{HARNESS_TIMER};

    ok my $app = $class->new( exists $test->{args} ? $test->{args} : () ),
      "$name: App::Prove created OK";

    isa_ok $app, 'App::Prove';
    isa_ok $app, $class;

    # Optionally parse command args
    if ( my $switches = $test->{switches} ) {
        if ( my $proverc = $test->{proverc} ) {
            $app->add_rc_file( File::Spec->catfile( split /\//, $proverc ) );
        }
        eval { $app->process_args( '--norc', @@$switches ) };
        if ( my $err_pattern = $test->{parse_error} ) {
            like $@@, $err_pattern, "$name: expected parse error";
a1509 4
        else {
            ok !$@@, "$name: no parse error";
        }
    }
d1511 21
a1531 20
    my $expect = $test->{expect} || {};
    for my $attr ( sort @@ATTR ) {
        my $val = $app->$attr();
        my $assertion
          = exists $expect->{$attr}
          ? $expect->{$attr}
          : $DEFAULT_ASSERTION{$attr};
        my $is_ok = undef;

        if ( 'CODE' eq ref $assertion ) {
            $is_ok = ok $assertion->( $val, $attr ),
              "$name: $attr has the expected value";
        }
        elsif ( 'Regexp' eq ref $assertion ) {
            $is_ok = like $val, $assertion, "$name: $attr matches $assertion";
        }
        else {
            $is_ok = is_deeply $val, $assertion,
              "$name: $attr has the expected value";
        }
d1533 3
a1535 2
        unless ($is_ok) {
            diag "got $val for $attr";
a1536 1
    }
d1538 6
a1543 10
    if ( my $runlog = $test->{runlog} ) {
        eval { $app->run };
        if ( my $err_pattern = $test->{run_error} ) {
            like $@@, $err_pattern, "$name: expected error OK";
            pass;
            pass for 1 .. $test->{plan};
        }
        else {
            unless ( ok !$@@, "$name: no error OK" ) {
                diag "$name: error: $@@\n";
d1545 24
a1568 5

            my $gotlog = [ $app->get_log ];

            if ( my $extra = $test->{extra} ) {
                $extra->($gotlog);
d1570 1
d1572 1
a1572 10
            unless (
                is_deeply $gotlog, $runlog,
                "$name: run results match"
              )
            {
                use Data::Dumper;
                diag Dumper( { wanted => $runlog, got => $gotlog } );
            }
        }
    }
d1574 1
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a12 3
use Getopt::Long;

use TAP::Parser::Utils qw( split_shell );
d72 1
a72 1
my ( @@ATTR, %DEFAULT_ASSERTION, @@SCHEDULE, $HAS_YAML );
a76 2
    $HAS_YAML = 0;
    eval { require YAML; $HAS_YAML = 1; };
d80 1
a80 1
      archive argv blib color directives exec extensions failures
a1082 99
        # Specify an oddball extension
        {   name => 'Switch --ext=.wango',
            switches => [ '--ext=.wango' ],
            expect => { extensions => ['.wango'] },
            runlog => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                    'TAP::Harness',
                ]
            ],
        },

        # Handle multiple extensions
        {   name => 'Switch --ext=.foo --ext=.bar',
            switches => [ '--ext=.foo', '--ext=.bar', ],
            expect => { extensions => ['.foo','.bar'] },
            runlog => [
                [   '_runtests',
                    {   verbosity  => 0,
                        show_count => 1,
                    },
                    'TAP::Harness',
                ]
            ],
        },

        # Source handlers
        {   name     => 'Switch --source simple',
            args     => { argv => [qw( one two three )] },
            switches => [ '--source', 'MyCustom', $dummy_test ],
            expect   => {
                sources => {
                    MyCustom => {},
                },
            },
            runlog => [
                [   '_runtests',
                    {   sources => {
                            MyCustom => {},
                        },
                        verbosity  => 0,
                        show_count => 1,
                    },
                    'TAP::Harness',
                    $dummy_test
                ]
            ],
        },

        {   name => 'Switch --sources with config',
            args => { argv => [qw( one two three )] },
            skip => $Getopt::Long::VERSION >= 2.28 && $HAS_YAML ? 0 : 1,
            skip_reason => "YAML not available or Getopt::Long too old",
            switches    => [
                '--source',      'Perl',
                '--perl-option', 'foo=bar baz',
                '--perl-option', 'avg=0.278',
                '--source',      'MyCustom',
                '--source',      'File',
                '--file-option', 'extensions=.txt',
                '--file-option', 'extensions=.tmp',
                '--file-option', 'hash=this=that',
                '--file-option', 'hash=foo=bar',
                '--file-option', 'sep=foo\\=bar',
                $dummy_test
            ],
            expect => {
                sources => {
                    Perl     => { foo => 'bar baz', avg => 0.278 },
                    MyCustom => {},
                    File => {
                        extensions => [ '.txt', '.tmp' ],
                        hash => { this => 'that', foo => 'bar'},
                        sep => 'foo=bar',
                    },
                },
            },
            runlog => [
                [   '_runtests',
                    {   sources => {
                            Perl     => { foo => 'bar baz', avg => 0.278 },
                            MyCustom => {},
                            File => {
                                extensions => [ '.txt', '.tmp' ],
                                hash => { this => 'that', foo => 'bar'},
                                sep => 'foo=bar',
                            },
                        },
                        verbosity  => 0,
                        show_count => 1,
                    },
                    'TAP::Harness',
                    $dummy_test
                ]
            ],
        },

d1436 3
a1438 6
        my $plan = 0;
        $plan += $test->{plan} || 0;
        $plan += 2 if $test->{runlog};
        $plan += 1 if $test->{switches};
        $test->{_planned} = $plan + 3 + @@ATTR;
        $extra_plan += $plan;
d1449 45
a1493 25
    SKIP:
    {
        skip $test->{skip_reason}, $test->{_planned} if $test->{skip};

        local $ENV{HARNESS_TIMER};

        ok my $app = $class->new( exists $test->{args} ? $test->{args} : () ),
          "$name: App::Prove created OK";

        isa_ok $app, 'App::Prove';
        isa_ok $app, $class;

        # Optionally parse command args
        if ( my $switches = $test->{switches} ) {
            if ( my $proverc = $test->{proverc} ) {
                $app->add_rc_file(
                    File::Spec->catfile( split /\//, $proverc ) );
            }
            eval { $app->process_args( '--norc', @@$switches ) };
            if ( my $err_pattern = $test->{parse_error} ) {
                like $@@, $err_pattern, "$name: expected parse error";
            }
            else {
                ok !$@@, "$name: no parse error";
            }
d1495 1
d1497 10
a1506 20
        my $expect = $test->{expect} || {};
        for my $attr ( sort @@ATTR ) {
            my $val = $app->$attr();
            my $assertion
              = exists $expect->{$attr}
              ? $expect->{$attr}
              : $DEFAULT_ASSERTION{$attr};
            my $is_ok = undef;

            if ( 'CODE' eq ref $assertion ) {
                $is_ok = ok $assertion->( $val, $attr ),
                  "$name: $attr has the expected value";
            }
            elsif ( 'Regexp' eq ref $assertion ) {
                $is_ok = like $val, $assertion,
                  "$name: $attr matches $assertion";
            }
            else {
                $is_ok = is_deeply $val, $assertion,
                  "$name: $attr has the expected value";
d1509 4
a1512 2
            unless ($is_ok) {
                diag "got $val for $attr";
a1513 1
        }
d1515 7
a1521 31
        if ( my $runlog = $test->{runlog} ) {
            eval { $app->run };
            if ( my $err_pattern = $test->{run_error} ) {
                like $@@, $err_pattern, "$name: expected error OK";
                pass;
                pass for 1 .. $test->{plan};
            }
            else {
                unless ( ok !$@@, "$name: no error OK" ) {
                    diag "$name: error: $@@\n";
                }

                my $gotlog = [ $app->get_log ];

                if ( my $extra = $test->{extra} ) {
                    $extra->($gotlog);
                }

                # adapt our expectations if HARNESS_PERL_SWITCHES is set
                push @@{ $runlog->[0][1]{switches} },
                  split_shell( $ENV{HARNESS_PERL_SWITCHES} )
                  if $ENV{HARNESS_PERL_SWITCHES};

                unless (
                    is_deeply $gotlog, $runlog,
                    "$name: run results match"
                  )
                {
                    use Data::Dumper;
                    diag Dumper( { wanted => $runlog, got => $gotlog } );
                }
d1524 1
a1524 2

    }    # SKIP
a1525 1

@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d1089 4
a1092 4
        {   name     => 'Switch --ext=.wango',
            switches => ['--ext=.wango'],
            expect   => { extensions => ['.wango'] },
            runlog   => [
d1103 1
a1103 1
        {   name     => 'Switch --ext=.foo --ext=.bar',
d1105 2
a1106 2
            expect   => { extensions => [ '.foo', '.bar' ] },
            runlog   => [
d1160 1
a1160 1
                    File     => {
d1162 2
a1163 2
                        hash => { this => 'that', foo => 'bar' },
                        sep  => 'foo=bar',
d1172 1
a1172 1
                            File     => {
d1174 2
a1175 2
                                hash => { this => 'that', foo => 'bar' },
                                sep  => 'foo=bar',
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@a7 1
use warnings;
d15 1
a15 1
use Text::ParseWords qw(shellwords);
d18 1
d20 1
a20 1
use base qw( App::Prove );
d1630 1
a1630 1
                  shellwords( $ENV{HARNESS_PERL_SWITCHES} )
@


1.1.1.5
log
@Import perl-5.24.2
@
text
@d177 1
d196 1
d212 1
d232 1
d252 1
d272 1
d291 1
d310 1
d330 1
d350 1
d369 1
d388 1
d407 1
d425 1
d443 1
d461 1
d479 1
d498 1
d518 1
d537 1
d555 1
d574 1
d593 1
d613 1
d632 1
d650 1
d668 1
d686 1
d704 1
d722 1
d740 1
d757 1
d774 1
d792 1
d809 1
d826 1
d843 1
d863 1
d883 1
d900 1
d917 1
d934 1
d951 1
d969 1
d987 1
d1005 1
d1025 1
d1044 1
d1063 1
d1082 1
d1097 1
d1111 1
d1133 1
d1181 1
d1207 1
d1236 1
d1261 1
d1302 1
d1327 1
d1344 1
d1358 1
d1371 1
d1385 1
d1399 1
d1413 1
d1427 1
d1441 1
d1471 1
d1485 1
d1499 1
d1513 1
d1527 1
@


