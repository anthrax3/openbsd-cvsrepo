head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.1
	PERL_5_24_2:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.28
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.26
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.20
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.22
	OPENBSD_5_8_BASE:1.1.1.1
	PERL_5_20_2:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.14
	OPENBSD_5_7_BASE:1.1.1.1
	PERL_5_20_1:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.18
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.16
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.12
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2010.09.24.14.49.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.01;	author millert;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@

use strict;
use Test;
BEGIN { plan tests => 33 };

#use Pod::Simple::Debug (6);

ok 1;

use Pod::Simple::SimpleTree;
print "# Pod::Simple version $Pod::Simple::VERSION\n";

my $hashes_dont_matter = 0;


my $x = 'Pod::Simple::SimpleTree';
sub x {
 my $p = $x->new;
 $p->merge_text(1);
 $p->parse_string_document( shift )->root;
}

ok 1;

print "# a bit of meta-testing...\n";
&ok( deq( 1,     1     ));
&ok(!deq( 2,     1     ));

&ok( deq( undef, undef ));
&ok(!deq( undef, 1     ));
&ok(!deq( 1,     undef ));

&ok( deq( [ ],   [ ]    ));
&ok(!deq( [ ],   1      ));
&ok(!deq( 1,     [ ]    ));

&ok( deq( [1],   [1]    ));
&ok(!deq( [1],   1      ));
&ok(!deq( 1,     [1]    ));
&ok(!deq( [1],   [ ]    ));
&ok(!deq( [ ],   [1]    ));
&ok(!deq( [1],   [2]    ));
&ok(!deq( [2],   [1]    ));

&ok( deq( [ ],   [ ]    ));
&ok(!deq( [ ],   1      ));
&ok(!deq( 1,     [ ]    ));

&ok( deq( {},    {}     ));
&ok(!deq( {},    1      ));
&ok(!deq( 1,     {}     ));
&ok(!deq( {1,2}, {}     ));
&ok(!deq( {},    {1,2}  ));
&ok( deq( {1,2}, {1,2}  ));
&ok(!deq( {2,1}, {1,2}  ));




print '# ', Pod::Simple::pretty(x( "=pod\n\nI like pie.\n" )), "\n";
print "# Making sure we get a tree at all...\n";
ok x( "=pod\n\nI like pie.\n" );


print "# Some real tests...\n";
&ok( deq( x( "=pod\n\nI like pie.\n"),
  [ "Document", {"start_line"=>1},
    [ "Para",   {"start_line"=>3},
      "I like pie."
    ]
  ]
));

$hashes_dont_matter = 1;

&ok( deq( x("=pod\n\nB<foo\t>\n"),
  [ "Document", {},
    [ "Para",   {},
      ["B",     {},
        "foo "
      ]
    ]
  ]
));


&ok( deq( x("=pod\n\nB<pieF<zorch>X<foo>I<pling>>\n"),
  [ "Document", {},
    [ "Para",   {},
      ["B",     {},
        "pie",
        ['F',{}, 'zorch'],
        ['X',{}, 'foo'  ],
        ['I',{}, 'pling'],
      ]
    ]
  ]
));

&ok( deq( x("=over\n\n=item B<pieF<zorch>X<foo>I<pling>>!\n\n=back"),
  [ "Document", {},
    [ "over-text", {},
      [ "item-text", {},
        ["B",     {},
          "pie",
          ['F',{}, 'zorch'],
          ['X',{}, 'foo'  ],
          ['I',{}, 'pling'],
        ],
        '!'
      ]
    ]
  ]
));

print "# Wrapping up... one for the road...\n";
ok 1;
print "# --- Done with ", __FILE__, " --- \n";

sub deq { # deep-equals
  #print "# deq ", Pod::Simple::pretty($_[0], $_[1]), "\n";
  return 1 unless defined $_[0] or defined $_[1]; # two undefs = same
  return '' if defined $_[0] xor defined $_[1];
  return '' if ref($_[0]) ne ref($_[1]); # unequal referentiality
  return $_[0] eq $_[1] unless ref $_[0];
  # So it's a ref:
  if(UNIVERSAL::isa($_[0], 'ARRAY')) {
    return '' unless @@{$_[0]} == @@{$_[1]};
    for(my $i = 0; $i < @@{$_[0]}; $i++) {
      print("# NEQ ", Pod::Simple::pretty($_[0]),
          "\n#  != ", Pod::Simple::pretty($_[1]), "\n"),
       return '' unless deq($_[0][$i], $_[1][$i]); # recurse!
    }
    return 1;
  } elsif(UNIVERSAL::isa($_[0], 'HASH')) {
    return 1 if $hashes_dont_matter;
    return '' unless keys %{$_[0]} == keys %{$_[1]};
    foreach my $k (keys %{$_[0]}) {
      return '' unless exists $_[1]{$k};
      return '' unless deq($_[0]{$k}, $_[1]{$k});
    }
    return 1;
  } else {
    print "# I don't know how to deque $_[0] & $_[1]\n";
    return 1;
  }
}


@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@
