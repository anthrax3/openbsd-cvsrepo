head	1.2;
access;
symbols
	OPENBSD_5_6:1.1.1.2.0.8
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2014.11.17.20.57.03;	author afresh1;	state dead;
branches;
next	1.1;
commitid	QP75iYx42Uo7mMxO;

1.1
date	2010.09.24.14.49.03;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.03;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.08.13;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@### Term::UI test suite ###

use strict;
use lib qw[../lib lib];
use Test::More tests => 19;
use Term::ReadLine;

use_ok( 'Term::UI' );

### make sure we can do this automatically ###
$Term::UI::AUTOREPLY    = $Term::UI::AUTOREPLY  = 1;
$Term::UI::VERBOSE      = $Term::UI::VERBOSE    = 0;

### enable warnings
$^W = 1;

### perl core gets upset if we print stuff to STDOUT...
if( $ENV{PERL_CORE} ) {
    *STDOUT_SAVE = *STDOUT_SAVE = *STDOUT;
    close *STDOUT;
    open *STDOUT, ">termui.$$" or diag("Could not open tempfile");
}
END { close *STDOUT && unlink "termui.$$" if $ENV{PERL_CORE} }


### so T::RL doesn't go nuts over no console
BEGIN{ $ENV{LINES}=25; $ENV{COLUMNS}=80; }
my $term = Term::ReadLine->new('test')
                or diag "Could not create a new term. Dying", die;

my $tmpl = {
        prompt  => "What is your favourite colour?",
        choices => [qw|blue red green|],
        default => 'blue',
    };

{
    my $args = \%{ $tmpl };

    is( $term->get_reply( %$args ), 'blue', q[Checking reply with defaults and choices] );
}

{
    my $args = \%{ $tmpl };
    delete $args->{choices};

    is( $term->get_reply( %$args ), 'blue', q[Checking reply with defaults] );
}

{
    my $args = {
        prompt  => 'Do you like cookies?',
        default => 'y',
    };

    is( $term->ask_yn( %$args ), 1, q[Asking yes/no with 'yes' as default] );
}

{
    my $args = {
        prompt  => 'Do you like Python?',
        default => 'n',
    };

    is( $term->ask_yn( %$args ), 0, q[Asking yes/no with 'no' as default] );
}


# used to print: Use of uninitialized value in length at Term/UI.pm line 141.
# [#13412]
{   my $args = {
        prompt  => 'Uninit warning on empty default',
    };
    
    my $warnings = '';
    local $SIG{__WARN__} = sub { $warnings .= "@@_" };
    
    my $res = $term->get_reply( %$args );

    ok( !$res,                  "Empty result on autoreply without default" );
    is( $warnings, '',          "   No warnings with empty default" );
    unlike( $warnings, qr|Term.UI|,
                                "   No warnings from Term::UI" );

}
 
# used to print: Use of uninitialized value in string at Params/Check.pm
# [#13412]
{   my $args = {
        prompt  => 'Undef warning on failing allow',
        allow   => sub { 0 },
    };
    
    my $warnings = '';
    local $SIG{__WARN__} = sub { $warnings .= "@@_" };
    
    my $res = $term->get_reply( %$args );

    ok( !$res,                  "Empty result on autoreply without default" );
    is( $warnings, '',          "   No warnings with failing allow" );
    unlike( $warnings, qr|Params.Check|,
                                "   No warnings from Params::Check" );

}

#### test parse_options   
{
    my $str =   q[command --no-foo --baz --bar=0 --quux=bleh ] .
                q[--option="some'thing" -one-dash -single=blah' foo bar-zot];

    my $munged = 'command foo bar-zot';
    my $expected = {
            foo         => 0,
            baz         => 1,
            bar         => 0,
            quux        => 'bleh',
            option      => q[some'thing],
            'one-dash'  => 1,
            single      => q[blah'],
    };

    my ($href,$rest) = $term->parse_options( $str );

    is_deeply($href, $expected, qq[Parsing options] );
    is($rest, $munged,          qq[Remaining unparsed string '$munged'] );
}

### more parse_options tests
{   my @@map = (
        [ 'x --update_source'   => 'x', { update_source => 1 } ],
        [ '--update_source'     => '',  { update_source => 1 } ],
    );
    
    for my $aref ( @@map ) {
        my( $input, $munged, $expect ) = @@$aref;
        
        my($href,$rest) = $term->parse_options( $input );
        
        ok( $href,              "Parsed '$input'" );
        is_deeply( $href, $expect,
                                "   Options parsed correctly" );
        is( $rest, $munged,     "   Command parsed correctly" );
    }
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a13 5
# SKIP tests if we aren't on a terminal
SKIP: {

skip 'not on a terminal', 18 unless -t;

d74 1
a74 1

d77 1
a77 1

d86 1
a86 1

d93 1
a93 1

d96 1
a96 1

d106 1
a106 1
#### test parse_options
d133 1
a133 1

d136 1
a136 1

d138 1
a138 1

a144 2

} # End SKIP block
@

