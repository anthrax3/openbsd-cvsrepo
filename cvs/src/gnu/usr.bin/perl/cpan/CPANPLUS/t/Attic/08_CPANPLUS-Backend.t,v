head	1.2;
access;
symbols
	OPENBSD_5_6:1.1.1.2.0.8
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2014.11.17.20.56.57;	author afresh1;	state dead;
branches;
next	1.1;
commitid	QP75iYx42Uo7mMxO;

1.1
date	2010.09.24.14.49.04;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.04;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.06.57;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@### make sure we can find our conf.pl file
BEGIN { 
    use FindBin; 
    require "$FindBin::Bin/inc/conf.pl";
}

use strict;
use Test::More      'no_plan';
use File::Basename  'dirname';

use Data::Dumper;
use CPANPLUS::Error;
use CPANPLUS::Internals::Constants;

my $conf = gimme_conf();

my $Class = 'CPANPLUS::Backend';
### D::C has troubles with the 'use_ok' -- it finds the wrong paths.
### for now, do a 'use' instead
#use_ok( $Class ) or diag "$Class not found";
use CPANPLUS::Backend;

my $cb = $Class->new( $conf );
isa_ok( $cb, $Class );

my $mt = $cb->module_tree;
my $at = $cb->author_tree;
ok( scalar keys %$mt,       "Module tree has entries" ); 
ok( scalar keys %$at,       "Author tree has entries" ); 

### module_tree tests ###
my $Name = TEST_CONF_MODULE;
my $mod  = $cb->module_tree($Name);

### XXX SOURCEFILES FIX
{   my @@mods = $cb->module_tree($Name,$Name);
    my $none = $cb->module_tree( TEST_CONF_INVALID_MODULE );
    
    ok( IS_MODOBJ->(mod => $mod),           "Module object found" );
    is( scalar(@@mods), 2,                   "   Module list found" );
    ok( IS_MODOBJ->(mod => $mods[0]),       "   ISA module object" );
    ok( !IS_MODOBJ->(mod => $none),         "   Bogus module detected");
}

### author_tree tests ###
{   my @@auths = $cb->author_tree( $mod->author->cpanid,
                                  $mod->author->cpanid );
    my $none  = $cb->author_tree( 'fnurk' );
    
    ok( IS_AUTHOBJ->(auth => $mod->author), "Author object found" );
    is( scalar(@@auths), 2,                  "   Author list found" );
    ok( IS_AUTHOBJ->( author => $auths[0] ),"   ISA author object" );
    is( $mod->author, $auths[0],            "   Objects are identical" );
    ok( !IS_AUTHOBJ->( author => $none ),   "   Bogus author detected" );
}

my $conf_obj = $cb->configure_object;
ok( IS_CONFOBJ->(conf => $conf_obj),    "Configure object found" );


### parse_module tests ###
{   my @@map = (                                  
        $Name => [ 
            $mod->author->cpanid,   # author
            $mod->package_name,     # package name
            $mod->version,          # version
        ],
        $mod => [ 
            $mod->author->cpanid,  
            $mod->package_name, 
            $mod->version, 
        ],
        'Foo-Bar-EU-NOXS' => [ 
            $mod->author->cpanid,  
            $mod->package_name, 
            $mod->version,
        ],
        'Foo-Bar-EU-NOXS-0.01' => [ 
            $mod->author->cpanid,  
            $mod->package_name, 
            '0.01',
        ],
        'EUNOXS/Foo-Bar-EU-NOXS' => [ 
            'EUNOXS',
            $mod->package_name, 
            $mod->version,
        ],
        'EUNOXS/Foo-Bar-EU-NOXS-0.01' => [ 
            'EUNOXS',              
            $mod->package_name, 
            '0.01',
        ],
        ### existing module, no extension given
        ### this used to create a modobj with no package extension
        'EUNOXS/Foo-Bar-0.02' => [ 
            'EUNOXS',              
            'Foo-Bar',
            '0.02',
        ],
        'Foo-Bar-EU-NOXS-0.09' => [ 
            $mod->author->cpanid,  
            $mod->package_name, 
            '0.09',
        ],
        'MBXS/Foo-Bar-EU-NOXS-0.01' => [ 
            'MBXS',                
            $mod->package_name, 
            '0.01',
        ],
        'EUNOXS/Foo-Bar-EU-NOXS-0.09' => [ 
            'EUNOXS',
            $mod->package_name, 
            '0.09',
        ],
        'EUNOXS/Foo-Bar-EU-NOXS-0.09.zip' => [ 
            'EUNOXS',
            $mod->package_name, 
            '0.09',
        ],
        'FROO/Flub-Flob-1.1.zip' => [ 
            'FROO',    
            'Flub-Flob',    
            '1.1',  
        ],
        'G/GO/GOYALI/SMS_API_3_01.tar.gz' => [ 
            'GOYALI',  
            'SMS_API',      
            '3_01', 
        ],
        'E/EY/EYCK/Net/Lite/Net-Lite-FTP-0.091' => [ 
            'EYCK',    
            'Net-Lite-FTP', 
            '0.091',
        ],
        'EYCK/Net/Lite/Net-Lite-FTP-0.091' => [ 
            'EYCK',
            'Net-Lite-FTP', 
            '0.091',
        ],
        'M/MA/MAXDB/DBD-MaxDB-7.5.0.24a' => [ 
            'MAXDB',
            'DBD-MaxDB',
            '7.5.0.24a', 
        ],
        'EUNOXS/perl5.005_03.tar.gz' => [ 
            'EUNOXS',  
            'perl',
            '5.005_03',
        ],
        'FROO/Flub-Flub-v1.1.0.tbz' => [ 
            'FROO',    
            'Flub-Flub',       
            'v1.1.0', 
        ],
        'FROO/Flub-Flub-1.1_2.tbz' => [ 
            'FROO',    
            'Flub-Flub',       
            '1.1_2',
        ],   
        'LDS/CGI.pm-3.27.tar.gz' => [ 
            'LDS',
            'CGI',
            '3.27', 
        ],
        'FROO/Text-Tabs+Wrap-2006.1117.tar.gz' => [ 
            'FROO',    
            'Text-Tabs+Wrap',
            '2006.1117',                                                      
        ],   
        'JETTERO/Crypt-PBC-0.7.20.0-0.4.9' => [ 
            'JETTERO',
            'Crypt-PBC',
            '0.7.20.0-0.4.9' ,
        ],
        'GRICHTER/HTML-Embperl-1.2.1.tar.gz' => [ 
            'GRICHTER',            
            'HTML-Embperl', 
            '1.2.1',
        ],
        'KANE/File-Fetch-0.15_03' => [
            'KANE',
            'File-Fetch',
            '0.15_03',
        ],
        'AUSCHUTZ/IO-Stty-.02.tar.gz' => [
            'AUSCHUTZ',
            'IO-Stty',
            '.02',
        ],            
        '.' => [
            'CPANPLUS',
            't',
            '',
        ],            
    );       

    while ( my($guess, $attr) = splice @@map, 0, 2 ) {
        my( $author, $pkg_name, $version ) = @@$attr;

        ok( $guess,             "Attempting to parse $guess" );

        my $obj = $cb->parse_module( module => $guess );
        
        ok( $obj,               "   Result returned" );
        ok( IS_MODOBJ->( mod => $obj ), 
                                "   parse_module success by '$guess'" );     
        
        is( $obj->version, $version,
                                "   Proper version found: $version" );
        is( $obj->package_version, $version,
                                "       Found in package_version as well" );

        ### VMS doesn't preserve case, so match them after normalizing case
        is( uc($obj->package_name), uc($pkg_name),
                                "   Proper package_name found: $pkg_name" );
        unlike( $obj->package_name, qr/\d/,
                                "       No digits in package name" );
        {   my $ext = $obj->package_extension;
            ok( $ext,           "       Has extension as well: $ext" );
        }
        
        like( $obj->author->cpanid, "/$author/i", 
                                "   Proper author found: $author");
        like( $obj->path,           "/$author/i", 
                                "   Proper path found: " . $obj->path );
    }


    ### test for things that look like real modules, but aren't ###
    {   my @@map = (
            [  $Name . $$ => [
                [qr/does not contain an author/,"Missing author part detected"],
                [qr/Cannot find .+? in the module tree/,"Unable to find module"]
            ] ],
            [ {}, => [
                [ qr/module string from reference/,"Unable to parse ref"] 
            ] ],
        );

        for my $entry ( @@map ) {
            my($mod,$aref) = @@$entry;
            
            my $none = $cb->parse_module( module => $mod );
            ok( !IS_MODOBJ->(mod => $none),     
                                "Non-existant module detected" );
            ok( !IS_FAKE_MODOBJ->(mod => $none),
                                "Non-existant fake module detected" );
        
            my $str = CPANPLUS::Error->stack_as_string;
            for my $pair (@@$aref) {
                my($re,$diag) = @@$pair;
                like( $str, $re,"   $diag" );
            }
        }    
    }
    
    ### test parsing of arbitrary URI
    for my $guess ( qw[ http://foo/bar.gz
                        http://a/b/c/d/e/f/g/h/i/j
                        flub://floo ]
    ) {
        my $obj = $cb->parse_module( module => $guess );
        ok( IS_FAKE_MODOBJ->(mod => $obj), 
                                "parse_module success by '$guess'" );
        is( $obj->status->_fetch_from, $guess,
                                "   Fetch from set ok" );
    }                                       
}         

### RV tests ###
{   my $method = 'readme';
    my %args   = ( modules => [$Name] );  
    
    my $rv = $cb->$method( %args );
    ok( IS_RVOBJ->( $rv ),              "Got an RV object" );
    ok( $rv->ok,                        "   Overall OK" );
    cmp_ok( $rv, '==', 1,               "   Overload OK" );
    is( $rv->function, $method,         "   Function stored OK" );     
    is_deeply( $rv->args, \%args,       "   Arguments stored OK" );
    is( $rv->rv->{$Name}, $mod->readme, "   RV as expected" );
}

### reload_indices tests ###
{
    my $file = File::Spec->catfile( $conf->get_conf('base'),
                                    $conf->_get_source('mod'),
                                );
  
    ok( $cb->reload_indices( update_source => 0 ),  "Rebuilding trees" );                              
    my $age = -M $file;
    
    ### make sure we are 'newer' on faster machines with a sleep..
    ### apparently Win32's FAT isn't granual enough on intervals
    ### < 2 seconds, so it may give the same answer before and after
    ### the sleep, causing the test to fail. so sleep atleast 2 seconds.
    sleep 2;
    ok( $cb->reload_indices( update_source => 1 ),  
                                    "Rebuilding and refetching trees" );
    cmp_ok( $age, '>', -M $file,    "    Source file '$file' updated" );                                      
}

### flush tests ###
{
    for my $cache( qw[methods hosts modules lib all] ) {
        ok( $cb->flush($cache), "Cache $cache flushed ok" );
    }
}

### installed tests ###
{   ok( scalar($cb->installed), "Found list of installed modules" );
}    
                
### autobudle tests ###
{
    my $where = $cb->autobundle;
    ok( $where,     "Autobundle written" );
    ok( -s $where,  "   File has size" );
}

### local_mirror tests ###
{   ### turn off md5 checks for the 'fake' packages we have 
    my $old_md5 = $conf->get_conf('md5');
    $conf->set_conf( md5 => 0 );

    ### otherwise 'status->fetch' might be undef! ###
    my $rv = $cb->local_mirror( path => 'dummy-localmirror' );
    ok( $rv,                        "Local mirror created" );
    
    for my $mod ( values %{ $cb->module_tree } ) {
        my $name    = $mod->module;
        
        my $cksum   = File::Spec->catfile(
                        dirname($mod->status->fetch),
                        CHECKSUMS );
        ok( -e $mod->status->fetch, "   Module '$name' fetched" );
        ok( -s _,                   "       Module '$name' has size" );
        ok( -e $cksum,              "   Checksum fetched for '$name'" );
        ok( -s _,                   "       Checksum for '$name' has size" );
    }      

    $conf->set_conf( md5 => $old_md5 );
}    

### check ENV variable
{   ### process id
    {   my $name = 'PERL5_CPANPLUS_IS_RUNNING';
        ok( $ENV{$name},            "Env var '$name' set" );
        is( $ENV{$name}, $$,        "   Set to current process id" );
    }

    ### Version    
    {   my $name = 'PERL5_CPANPLUS_IS_VERSION';
        ok( $ENV{$name},            "Env var '$name' set" );

        ### version.pm formats ->VERSION output... *sigh*
        is( $ENV{$name}, $Class->VERSION,        
                                    "   Set to current process version" );
    }
    
}

__END__    
                                          
# Local variables:
# c-indentation-style: bsd
# c-basic-offset: 4
# indent-tabs-mode: nil
# End:
# vim: expandtab shiftwidth=4:                    
                    
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d2 2
a3 2
BEGIN {
    use FindBin;
d28 2
a29 2
ok( scalar keys %$mt,       "Module tree has entries" );
ok( scalar keys %$at,       "Author tree has entries" );
d38 1
a38 1

d49 1
a49 1

d62 2
a63 2
{   my @@map = (
        $Name => [
d68 8
a75 3
        $mod => [
            $mod->author->cpanid,
            $mod->package_name,
d78 3
a80 8
        'Foo-Bar-EU-NOXS' => [
            $mod->author->cpanid,
            $mod->package_name,
            $mod->version,
        ],
        'Foo-Bar-EU-NOXS-0.01' => [
            $mod->author->cpanid,
            $mod->package_name,
d83 1
a83 1
        'EUNOXS/Foo-Bar-EU-NOXS' => [
d85 1
a85 1
            $mod->package_name,
d88 3
a90 3
        'EUNOXS/Foo-Bar-EU-NOXS-0.01' => [
            'EUNOXS',
            $mod->package_name,
d95 2
a96 2
        'EUNOXS/Foo-Bar-0.02' => [
            'EUNOXS',
d100 3
a102 3
        'Foo-Bar-EU-NOXS-0.09' => [
            $mod->author->cpanid,
            $mod->package_name,
d105 3
a107 3
        'MBXS/Foo-Bar-EU-NOXS-0.01' => [
            'MBXS',
            $mod->package_name,
d110 1
a110 1
        'EUNOXS/Foo-Bar-EU-NOXS-0.09' => [
d112 1
a112 1
            $mod->package_name,
d115 1
a115 1
        'EUNOXS/Foo-Bar-EU-NOXS-0.09.zip' => [
d117 1
a117 1
            $mod->package_name,
d120 13
a132 13
        'FROO/Flub-Flob-1.1.zip' => [
            'FROO',
            'Flub-Flob',
            '1.1',
        ],
        'G/GO/GOYALI/SMS_API_3_01.tar.gz' => [
            'GOYALI',
            'SMS_API',
            '3_01',
        ],
        'E/EY/EYCK/Net/Lite/Net-Lite-FTP-0.091' => [
            'EYCK',
            'Net-Lite-FTP',
d135 1
a135 1
        'EYCK/Net/Lite/Net-Lite-FTP-0.091' => [
d137 1
a137 1
            'Net-Lite-FTP',
d140 1
a140 1
        'M/MA/MAXDB/DBD-MaxDB-7.5.0.24a' => [
d143 1
a143 1
            '7.5.0.24a',
d145 2
a146 2
        'EUNOXS/perl5.005_03.tar.gz' => [
            'EUNOXS',
d150 8
a157 8
        'FROO/Flub-Flub-v1.1.0.tbz' => [
            'FROO',
            'Flub-Flub',
            'v1.1.0',
        ],
        'FROO/Flub-Flub-1.1_2.tbz' => [
            'FROO',
            'Flub-Flub',
d159 2
a160 2
        ],
        'LDS/CGI.pm-3.27.tar.gz' => [
d163 1
a163 1
            '3.27',
d165 2
a166 2
        'FROO/Text-Tabs+Wrap-2006.1117.tar.gz' => [
            'FROO',
d168 3
a170 3
            '2006.1117',
        ],
        'JETTERO/Crypt-PBC-0.7.20.0-0.4.9' => [
d175 3
a177 3
        'GRICHTER/HTML-Embperl-1.2.1.tar.gz' => [
            'GRICHTER',
            'HTML-Embperl',
d189 1
a189 1
        ],
d194 2
a195 7
        ],
        'Foo/Bar.pm' => [
            $mod->author->cpanid,   # author
            $mod->package_name,     # package name
            $mod->version,          # version
        ],
    );
d203 1
a203 1

d205 3
a207 3
        ok( IS_MODOBJ->( mod => $obj ),
                                "   parse_module success by '$guess'" );

d221 2
a222 2

        like( $obj->author->cpanid, "/$author/i",
d224 1
a224 1
        like( $obj->path,           "/$author/i",
d236 1
a236 1
                [ qr/module string from reference/,"Unable to parse ref"]
d242 1
a242 1

d244 2
a245 2
            ok( !IS_MODOBJ->(mod => $none),
                                "Non-existent module detected" );
d247 2
a248 2
                                "Non-existent fake module detected" );

d254 1
a254 1
        }
d256 1
a256 1

d263 1
a263 1
        ok( IS_FAKE_MODOBJ->(mod => $obj),
d267 2
a268 2
    }
}
d272 2
a273 2
    my %args   = ( modules => [$Name] );

d278 1
a278 1
    is( $rv->function, $method,         "   Function stored OK" );
d288 2
a289 2

    ok( $cb->reload_indices( update_source => 0 ),  "Rebuilding trees" );
d291 1
a291 1

d297 1
a297 1
    ok( $cb->reload_indices( update_source => 1 ),
d299 1
a299 1
    cmp_ok( $age, '>', -M $file,    "    Source file '$file' updated" );
d311 2
a312 2
}

d321 1
a321 1
{   ### turn off md5 checks for the 'fake' packages we have
d328 1
a328 1

d331 1
a331 1

d339 1
a339 1
    }
d342 1
a342 1
}
d351 1
a351 1
    ### Version
d356 1
a356 1
        is( $ENV{$name}, $Class->VERSION,
d359 1
a359 1

d362 2
a363 2
__END__

d369 2
a370 2
# vim: expandtab shiftwidth=4:

@

