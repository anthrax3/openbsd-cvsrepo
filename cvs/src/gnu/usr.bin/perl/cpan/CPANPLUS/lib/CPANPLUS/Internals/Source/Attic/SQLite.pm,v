head	1.2;
access;
symbols
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2014.11.17.20.56.57;	author afresh1;	state dead;
branches;
next	1.1;
commitid	QP75iYx42Uo7mMxO;

1.1
date	2010.09.24.14.49.03;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.03;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.06.57;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.50;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@package CPANPLUS::Internals::Source::SQLite;

use strict;
use warnings;

use base 'CPANPLUS::Internals::Source';

use CPANPLUS::Error;
use CPANPLUS::Internals::Constants;
use CPANPLUS::Internals::Source::SQLite::Tie;

use Data::Dumper;
use DBIx::Simple;
use DBD::SQLite;

use Params::Check               qw[allow check];
use Locale::Maketext::Simple    Class => 'CPANPLUS', Style => 'gettext';

use constant TXN_COMMIT => 1000;

=head1 NAME 

CPANPLUS::Internals::Source::SQLite - SQLite implementation

=cut

{   my $Dbh;
    my $DbFile;

    sub __sqlite_file { 
        return $DbFile if $DbFile;

        my $self = shift;
        my $conf = $self->configure_object;

        $DbFile = File::Spec->catdir( 
                        $conf->get_conf('base'),
                        SOURCE_SQLITE_DB
            );
    
        return $DbFile;
    };

    sub __sqlite_dbh { 
        return $Dbh if $Dbh;
        
        my $self = shift;
        $Dbh     = DBIx::Simple->connect(
                        "dbi:SQLite:dbname=" . $self->__sqlite_file,
                        '', '',
                        { AutoCommit => 1 }
                    );
        #$Dbh->dbh->trace(1);

        return $Dbh;        
    };
}

{   my $used_old_copy = 0;

    sub _init_trees {
        my $self = shift;
        my $conf = $self->configure_object;
        my %hash = @@_;
    
        my($path,$uptodate,$verbose,$use_stored);
        my $tmpl = {
            path        => { default => $conf->get_conf('base'), store => \$path },
            verbose     => { default => $conf->get_conf('verbose'), store => \$verbose },
            uptodate    => { required => 1, store => \$uptodate },
            use_stored  => { default  => 1, store => \$use_stored },
        };
    
        check( $tmpl, \%hash ) or return;

        ### if it's not uptodate, or the file doesn't exist, we need to create
        ### a new sqlite db
        if( not $uptodate or not -e $self->__sqlite_file ) {        
            $used_old_copy = 0;

            ### chuck the file
            1 while unlink $self->__sqlite_file;
        
            ### and create a new one
            $self->__sqlite_create_db or do {
                error(loc("Could not create new SQLite DB"));
                return;    
            }            
        } else {
            $used_old_copy = 1;
        }            
    
        ### set up the author tree
        {   my %at;
            tie %at, 'CPANPLUS::Internals::Source::SQLite::Tie',
                dbh => $self->__sqlite_dbh, table => 'author', 
                key => 'cpanid',            cb => $self;
                
            $self->_atree( \%at  );
        }

        ### set up the author tree
        {   my %mt;
            tie %mt, 'CPANPLUS::Internals::Source::SQLite::Tie',
                dbh => $self->__sqlite_dbh, table => 'module', 
                key => 'module',            cb => $self;

            $self->_mtree( \%mt  );
        }
        
        ### start a transaction
        $self->__sqlite_dbh->query('BEGIN');
        
        return 1;        
        
    }
    
    sub _standard_trees_completed   { return $used_old_copy }
    sub _custom_trees_completed     { return }
    ### finish transaction
    sub _finalize_trees             { $_[0]->__sqlite_dbh->query('COMMIT'); return 1 }

    ### saves current memory state, but not implemented in sqlite
    sub _save_state                 { 
        error(loc("%1 has not implemented writing state to disk", __PACKAGE__)); 
        return;
    }
}

{   my $txn_count = 0;

    ### XXX move this outside the sub, so we only compute it once
    my $class;
    my @@keys    = qw[ author cpanid email ];
    my $tmpl    = {
        class   => { default => 'CPANPLUS::Module::Author', store => \$class },
        map { $_ => { required => 1 } } @@keys
     };
    
    ### dbix::simple's expansion of (??) is REALLY expensive, so do it manually
    my $ph      = join ',', map { '?' } @@keys;


    sub _add_author_object {
        my $self = shift;
        my %hash = @@_;
        my $dbh  = $self->__sqlite_dbh;
    
        my $href = do {
            local $Params::Check::NO_DUPLICATES         = 1;            
            local $Params::Check::SANITY_CHECK_TEMPLATE = 0;
            check( $tmpl, \%hash ) or return;
        };

        ### keep counting how many we inserted
        unless( ++$txn_count % TXN_COMMIT ) {
            #warn "Committing transaction $txn_count";
            $dbh->query('COMMIT') or error( $dbh->error ); # commit previous transaction
            $dbh->query('BEGIN')  or error( $dbh->error ); # and start a new one
        }
        
        $dbh->query( 
            "INSERT INTO author (". join(',',keys(%$href)) .") VALUES ($ph)",
            values %$href
        ) or do {
            error( $dbh->error );
            return;
        };
        
        return 1;
     }
}

{   my $txn_count = 0;

    ### XXX move this outside the sub, so we only compute it once
    my $class;    
    my @@keys = qw[ module version path comment author package description dslip mtime ];
    my $tmpl = {
        class   => { default => 'CPANPLUS::Module', store => \$class },
        map { $_ => { required => 1 } } @@keys
    };
    
    ### dbix::simple's expansion of (??) is REALLY expensive, so do it manually
    my $ph      = join ',', map { '?' } @@keys;

    sub _add_module_object {
        my $self = shift;
        my %hash = @@_;
        my $dbh  = $self->__sqlite_dbh;
    
        my $href = do {
            local $Params::Check::NO_DUPLICATES         = 1;
            local $Params::Check::SANITY_CHECK_TEMPLATE = 0;
            check( $tmpl, \%hash ) or return;
        };
        
        ### fix up author to be 'plain' string
        $href->{'author'} = $href->{'author'}->cpanid;

        ### keep counting how many we inserted
        unless( ++$txn_count % TXN_COMMIT ) {
            #warn "Committing transaction $txn_count";
            $dbh->query('COMMIT') or error( $dbh->error ); # commit previous transaction
            $dbh->query('BEGIN')  or error( $dbh->error ); # and start a new one
        }
        
        $dbh->query( 
            "INSERT INTO module (". join(',',keys(%$href)) .") VALUES ($ph)", 
            values %$href
        ) or do {
            error( $dbh->error );
            return;
        };
        
        return 1;
    }
}

{   my %map = (
        _source_search_module_tree  
            => [ module => module => 'CPANPLUS::Module' ],
        _source_search_author_tree  
            => [ author => cpanid => 'CPANPLUS::Module::Author' ],
    );        

    while( my($sub, $aref) = each %map ) {
        no strict 'refs';
        
        my($table, $key, $class) = @@$aref;
        *$sub = sub {
            my $self = shift;
            my %hash = @@_;
            my $dbh  = $self->__sqlite_dbh;
            
            my($list,$type);
            my $tmpl = {
                allow   => { required   => 1, default   => [ ], strict_type => 1,
                             store      => \$list },
                type    => { required   => 1, allow => [$class->accessors()],
                             store      => \$type },
            };
        
            check( $tmpl, \%hash ) or return;
        
        
            ### we aliased 'module' to 'name', so change that here too
            $type = 'module' if $type eq 'name';
        
            my $res = $dbh->query( "SELECT * from $table" );
            
            my $meth = $table .'_tree';
            my @@rv = map  { $self->$meth( $_->{$key} ) } 
                     grep { allow( $_->{$type} => $list ) } $res->hashes;
        
            return @@rv;
        }
    }
}



sub __sqlite_create_db {
    my $self = shift;
    my $dbh  = $self->__sqlite_dbh;
    
    ### we can ignore the result/error; not all sqlite implemantation
    ### support this    
    $dbh->query( qq[
        DROP TABLE IF EXISTS author;
        \n]
     ) or do {
        msg( $dbh->error );
    }; 
    $dbh->query( qq[
        DROP TABLE IF EXISTS module;
        \n]
     ) or do {
        msg( $dbh->error );
    }; 


    
    $dbh->query( qq[
        /* the author information */
        CREATE TABLE author (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            
            author  varchar(255),
            email   varchar(255),
            cpanid  varchar(255)
        );
        \n]

    ) or do {
        error( $dbh->error );
        return;
    };

    $dbh->query( qq[
        /* the module information */
        CREATE TABLE module (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            
            module      varchar(255),
            version     varchar(255),
            path        varchar(255),
            comment     varchar(255),
            author      varchar(255),
            package     varchar(255),
            description varchar(255),
            dslip       varchar(255),
            mtime       varchar(255)
        );
        
        \n]

    ) or do {
        error( $dbh->error );
        return;
    };        
        
    return 1;    
}

1;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d21 1
a21 1
=head1 NAME
d30 1
a30 1
    sub __sqlite_file {
d36 1
a36 1
        $DbFile = File::Spec->catdir(
d40 1
a40 1

d44 1
a44 1
    sub __sqlite_dbh {
d46 1
a46 1

a53 1
        $Dbh->query(qq{PRAGMA synchronous = OFF});
d55 1
a55 1
        return $Dbh;
a56 7

    sub __sqlite_disconnect {
      return unless $Dbh;
      $Dbh->disconnect;
      $Dbh = undef;
      return;
    }
d65 1
a65 1

d73 1
a73 1

d78 1
a78 1
        if( not $uptodate or not -e $self->__sqlite_file ) {
a81 1
            $self->__sqlite_disconnect;
d83 1
a83 1

d87 2
a88 2
                return;
            }
d91 2
a92 2
        }

d96 1
a96 1
                dbh => $self->__sqlite_dbh, table => 'author',
d98 1
a98 1

d105 1
a105 1
                dbh => $self->__sqlite_dbh, table => 'module',
d110 1
a110 1

d113 3
a115 3

        return 1;

d117 1
a117 1

d121 1
a121 1
    sub _finalize_trees             { $_[0]->__sqlite_dbh->commit; return 1 }
d124 2
a125 2
    sub _save_state                 {
        error(loc("%1 has not implemented writing state to disk", __PACKAGE__));
d139 1
a139 1

d148 1
a148 1

d150 1
a150 1
            local $Params::Check::NO_DUPLICATES         = 1;
d158 2
a159 2
            $dbh->commit or error( $dbh->error ); # commit previous transaction
            $dbh->begin_work  or error( $dbh->error ); # and start a new one
d161 2
a162 2

        $dbh->query(
d169 1
a169 1

d177 1
a177 1
    my $class;
d183 1
a183 1

d191 1
a191 1

d197 1
a197 1

d204 2
a205 2
            $dbh->commit or error( $dbh->error ); # commit previous transaction
            $dbh->begin_work  or error( $dbh->error ); # and start a new one
d207 3
a209 3

        $dbh->query(
            "INSERT INTO module (". join(',',keys(%$href)) .") VALUES ($ph)",
d215 1
a215 1

d221 1
a221 1
        _source_search_module_tree
d223 1
a223 1
        _source_search_author_tree
d225 1
a225 1
    );
d229 1
a229 1

d235 1
a235 1

d243 1
a243 1

d245 2
a246 2


d249 1
a249 1

d251 1
a251 1

d253 1
a253 1
            my @@rv = map  { $self->$meth( $_->{$key} ) }
d255 1
a255 1

d266 3
a268 3

    ### we can ignore the result/error; not all sqlite implementations
    ### support this
d274 1
a274 1
    };
d280 1
a280 2
    };

d283 1
d288 1
a288 1

d304 1
a304 1

d315 1
a315 40

        \n]

    ) or do {
        error( $dbh->error );
        return;
    };

    $dbh->query( qq[
        /* the module index */
        CREATE INDEX IX_module_module ON module (
            module
        );

        \n]

    ) or do {
        error( $dbh->error );
        return;
    };

    $dbh->query( qq[
        /* the version index */
        CREATE INDEX IX_module_version ON module (
            version
        );

        \n]

    ) or do {
        error( $dbh->error );
        return;
    };

    $dbh->query( qq[
        /* the module-version index */
        CREATE INDEX IX_module_module_version ON module (
            module, version
        );

d321 3
a323 3
    };

    return 1;
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a1 1
use deprecate;
a18 3
use vars qw[$VERSION];
$VERSION = "0.9135";

d243 1
a258 7
            my $meth = $table .'_tree';

            {
              my $throw = $self->$meth;
            }

            my $dbh  = $self->__sqlite_dbh;
d261 1
@


