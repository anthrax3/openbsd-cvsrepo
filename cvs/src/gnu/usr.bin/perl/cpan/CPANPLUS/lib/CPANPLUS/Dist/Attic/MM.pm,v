head	1.5;
access;
symbols
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.2.0.10
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.8
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2014.11.17.20.56.56;	author afresh1;	state dead;
branches;
next	1.4;
commitid	QP75iYx42Uo7mMxO;

1.4
date	2014.03.24.15.05.23;	author afresh1;	state Exp;
branches;
next	1.3;

1.3
date	2013.03.25.20.40.46;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2010.09.24.15.06.45;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.24.14.49.03;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.03;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.06.56;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.50;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@package CPANPLUS::Dist::MM;
use deprecate;

use strict;
use warnings;
use vars    qw[@@ISA $STATUS $VERSION];
use base    'CPANPLUS::Dist::Base';
$VERSION = "0.9135";

use CPANPLUS::Internals::Constants;
use CPANPLUS::Internals::Constants::Report;
use CPANPLUS::Error;
use FileHandle;
use Cwd;

use IPC::Cmd                    qw[run];
use Params::Check               qw[check];
use File::Basename              qw[dirname];
use Module::Load::Conditional   qw[can_load check_install];
use Locale::Maketext::Simple    Class => 'CPANPLUS', Style => 'gettext';

local $Params::Check::VERBOSE = 1;

=pod

=head1 NAME

CPANPLUS::Dist::MM - distribution class for MakeMaker related modules

=head1 SYNOPSIS

    $mm = CPANPLUS::Dist::MM->new( module => $modobj );

    $mm->create;        # runs make && make test
    $mm->install;       # runs make install


=head1 DESCRIPTION

C<CPANPLUS::Dist::MM> is a distribution class for MakeMaker related
modules.
Using this package, you can create, install and uninstall perl
modules. It inherits from C<CPANPLUS::Dist>.

=head1 ACCESSORS

=over 4

=item parent()

Returns the C<CPANPLUS::Module> object that parented this object.

=item status()

Returns the C<Object::Accessor> object that keeps the status for
this module.

=back

=head1 STATUS ACCESSORS

All accessors can be accessed as follows:
    $mm->status->ACCESSOR

=over 4

=item makefile ()

Location of the Makefile (or Build file).
Set to 0 explicitly if something went wrong.

=item make ()

BOOL indicating if the C<make> (or C<Build>) command was successful.

=item test ()

BOOL indicating if the C<make test> (or C<Build test>) command was
successful.

=item prepared ()

BOOL indicating if the C<prepare> call exited successfully
This gets set after C<perl Makefile.PL>

=item distdir ()

Full path to the directory in which the C<prepare> call took place,
set after a call to C<prepare>.

=item created ()

BOOL indicating if the C<create> call exited successfully. This gets
set after C<make> and C<make test>.

=item installed ()

BOOL indicating if the module was installed. This gets set after
C<make install> (or C<Build install>) exits successfully.

=item uninstalled ()

BOOL indicating if the module was uninstalled properly.

=item _create_args ()

Storage of the arguments passed to C<create> for this object. Used
for recursive calls when satisfying prerequisites.

=item _install_args ()

Storage of the arguments passed to C<install> for this object. Used
for recursive calls when satisfying prerequisites.

=back

=cut

=head1 METHODS

=head2 $bool = $dist->format_available();

Returns a boolean indicating whether or not you can use this package
to create and install modules in your environment.

=cut

### check if the format is available ###
sub format_available {
    my $dist = shift;

    ### we might be called as $class->format_available =/
    require CPANPLUS::Internals;
    my $cb   = CPANPLUS::Internals->_retrieve_id(
                    CPANPLUS::Internals->_last_id );
    my $conf = $cb->configure_object;

    my $mod = "ExtUtils::MakeMaker";
    unless( can_load( modules => { $mod => 0.0 } ) ) {
        error( loc( "You do not have '%1' -- '%2' not available",
                    $mod, __PACKAGE__ ) );
        return;
    }

    for my $pgm ( qw[make] ) {
        unless( $conf->get_program( $pgm ) ) {
            error(loc(
                "You do not have '%1' in your path -- '%2' not available\n" .
                "Please check your config entry for '%1'",
                $pgm, __PACKAGE__ , $pgm
            ));
            return;
        }
    }

    return 1;
}

=pod

=head2 $bool = $dist->init();

Sets up the C<CPANPLUS::Dist::MM> object for use.
Effectively creates all the needed status accessors.

Called automatically whenever you create a new C<CPANPLUS::Dist> object.

=cut

sub init {
    my $dist    = shift;
    my $status  = $dist->status;

    $status->mk_accessors(qw[makefile make test created installed uninstalled
                             bin_make _prepare_args _create_args _install_args]
                        );

    return 1;
}

=pod

=head2 $bool = $dist->prepare([perl => '/path/to/perl', makemakerflags => 'EXTRA=FLAGS', force => BOOL, verbose => BOOL])

C<prepare> preps a distribution for installation. This means it will
run C<perl Makefile.PL> and determine what prerequisites this distribution
declared.

If you set C<force> to true, it will go over all the stages of the
C<prepare> process again, ignoring any previously cached results.

When running C<perl Makefile.PL>, the environment variable
C<PERL5_CPANPLUS_IS_EXECUTING> will be set to the full path of the
C<Makefile.PL> that is being executed. This enables any code inside
the C<Makefile.PL> to know that it is being installed via CPANPLUS.

Returns true on success and false on failure.

You may then call C<< $dist->create >> on the object to create the
installable files.

=cut

sub prepare {
    ### just in case you already did a create call for this module object
    ### just via a different dist object
    my $dist = shift;
    my $self = $dist->parent;

    ### we're also the cpan_dist, since we don't need to have anything
    ### prepared
    $dist    = $self->status->dist_cpan if      $self->status->dist_cpan;
    $self->status->dist_cpan( $dist )   unless  $self->status->dist_cpan;

    my $cb   = $self->parent;
    my $conf = $cb->configure_object;
    my %hash = @@_;

    my $dir;
    unless( $dir = $self->status->extract ) {
        error( loc( "No dir found to operate on!" ) );
        return;
    }

    my $args;
    my( $force, $verbose, $perl, $mmflags, $prereq_target, $prereq_format,
        $prereq_build );
    {   local $Params::Check::ALLOW_UNKNOWN = 1;
        my $tmpl = {
            perl            => {    default => $^X, store => \$perl },
            makemakerflags  => {    default =>
                                        $conf->get_conf('makemakerflags') || '',
                                    store => \$mmflags },
            force           => {    default => $conf->get_conf('force'),
                                    store   => \$force },
            verbose         => {    default => $conf->get_conf('verbose'),
                                    store   => \$verbose },
            prereq_target   => {    default => '', store => \$prereq_target },
            prereq_format   => {    default => '',
                                    store   => \$prereq_format },
            prereq_build    => {    default => 0, store => \$prereq_build },
        };

        $args = check( $tmpl, \%hash ) or return;
    }

    my @@mmflags = $dist->_split_like_shell( $mmflags );

    ### maybe we already ran a create on this object? ###
    return 1 if $dist->status->prepared && !$force;

    ### store the arguments, so ->install can use them in recursive loops ###
    $dist->status->_prepare_args( $args );

    ### chdir to work directory ###
    my $orig = cwd();
    unless( $cb->_chdir( dir => $dir ) ) {
        error( loc( "Could not chdir to build directory '%1'", $dir ) );
        return;
    }

    my $fail;
    RUN: {

        ### we resolve 'configure requires' here, so we can run the 'perl
        ### Makefile.PL' command
        ### XXX for tests: mock f_c_r to something that *can* resolve and
        ### something that *doesn't* resolve. Check the error log for ok
        ### on this step or failure
        ### XXX make a separate tarball to test for this scenario: simply
        ### containing a makefile.pl/build.pl for test purposes?
        {   my $configure_requires = $dist->find_configure_requires;
            my $ok = $dist->_resolve_prereqs(
                            format          => $prereq_format,
                            verbose         => $verbose,
                            prereqs         => $configure_requires,
                            target          => $prereq_target,
                            force           => $force,
                            prereq_build    => $prereq_build,
                    );

            unless( $ok ) {

                #### use $dist->flush to reset the cache ###
                error( loc( "Unable to satisfy '%1' for '%2' " .
                            "-- aborting install",
                            'configure_requires', $self->module ) );
                $dist->status->prepared(0);
                $fail++;
                last RUN;
            }
            ### end of prereq resolving ###
        }



        ### don't run 'perl makefile.pl' again if there's a makefile already
        if( -e MAKEFILE->() && (-M MAKEFILE->() < -M $dir) && !$force ) {
            msg(loc("'%1' already exists, not running '%2 %3' again ".
                    " unless you force",
                    MAKEFILE->(), $perl, MAKEFILE_PL->() ), $verbose );

        } else {
            unless( -e MAKEFILE_PL->() ) {
                msg(loc("No '%1' found - attempting to generate one",
                        MAKEFILE_PL->() ), $verbose );

                $dist->write_makefile_pl(
                            verbose => $verbose,
                            force   => $force
                        );

                ### bail out if there's no makefile.pl ###
                unless( -e MAKEFILE_PL->() ) {
                    error( loc( "Could not find '%1' - cannot continue",
                                MAKEFILE_PL->() ) );

                    ### mark that we screwed up ###
                    $dist->status->makefile(0);
                    $fail++; last RUN;
                }
            }

            ### you can turn off running this verbose by changing
            ### the config setting below, although it is really not
            ### recommended
            my $run_verbose = $verbose ||
                              $conf->get_conf('allow_build_interactivity') ||
                              0;

            ### this makes MakeMaker use defaults if possible, according
            ### to schwern. See ticket 8047 for details.
            local $ENV{PERL_MM_USE_DEFAULT} = 1 unless $run_verbose;

            ### turn off our PERL5OPT so no modules from CPANPLUS::inc get
            ### included in the makefile.pl -- it should build without
            ### also, modules that run in taint mode break if we leave
            ### our code ref in perl5opt
            ### XXX we've removed the ENV settings from cp::inc, so only need
            ### to reset the @@INC
            #local $ENV{PERL5OPT} = CPANPLUS::inc->original_perl5opt || '';

            ### make sure it's a string, so that mmflags that have more than
            ### one key value pair are passed as is, rather than as:
            ### perl Makefile.PL "key=val key=>val"


            #### XXX this needs to be the absolute path to the Makefile.PL
            ### since cpanp-run-perl uses 'do' to execute the file, and do()
            ### checks your @@INC.. so, if there's _another_ makefile.pl in
            ### your @@INC, it will execute that one...
            my $makefile_pl = MAKEFILE_PL->( $cb->_safe_path( path => $dir ) );

            ### setting autoflush to true fixes issue from rt #8047
            ### XXX this means that we need to keep the path to CPANPLUS
            ### in @@INC, stopping us from resolving dependencies on CPANPLUS
            ### at bootstrap time properly.

            my @@run_perl    = ( '-e', PERL_WRAPPER );
            my $cmd         = [$perl, @@run_perl, $makefile_pl, @@mmflags];

            ### set ENV var to tell underlying code this is what we're
            ### executing.
            my $captured;
            my $rv = do {
                my $env = ENV_CPANPLUS_IS_EXECUTING;
                local $ENV{$env} = $makefile_pl;
                scalar run( command => $cmd,
                            buffer  => \$captured,
                            verbose => $run_verbose, # may be interactive
                        );
            };

            unless( $rv ) {
                error( loc( "Could not run '%1 %2': %3 -- cannot continue",
                            $perl, MAKEFILE_PL->(), $captured ) );

                $dist->status->makefile(0);
                $fail++; last RUN;
            }

            ### put the output on the stack, don't print it
            msg( $captured, 0 );
        }

        ### so, nasty feature in Module::Build, that when a Makefile.PL
        ### is a disguised Build.PL, it generates a Build file, not a
        ### Makefile. this breaks everything :( see rt bug #19741
        if( not -e MAKEFILE->( $dir ) and -e BUILD_PL->( $dir ) ) {
            error(loc(
                    "We just ran '%1' without errors, but no '%2' is ".
                    "present. However, there is a '%3' file, so this may ".
                    "be related to bug #19741 in %4, which describes a ".
                    "fake '%5' which generates a '%6' file instead of a '%7'. ".
                    "You could try to work around this issue by setting '%8' ".
                    "to false and trying again. This will attempt to use the ".
                    "'%9' instead.",
                    "$^X ".MAKEFILE_PL->(), MAKEFILE->(), BUILD_PL->(),
                    'Module::Build', MAKEFILE_PL->(), 'Build', MAKEFILE->(),
                    'prefer_makefile', BUILD_PL->()
            ));

            $fail++, last RUN;
        }

        ### if we got here, we managed to make a 'makefile' ###
        $dist->status->makefile( MAKEFILE->($dir) );

        ### Make (haha) sure that Makefile.PL is older than the Makefile
        ### we just generated.
        eval {
          my $makestat = ( stat MAKEFILE->( $dir ) )[9];
          my $mplstat = ( stat MAKEFILE_PL->( $cb->_safe_path( path => $dir ) ) )[9];
          if ( $makestat < $mplstat ) {
            my $ftime = $makestat - 60;
            utime $ftime, $ftime, MAKEFILE_PL->( $cb->_safe_path( path => $dir ) );
          }
        };

        ### start resolving prereqs ###
        my $prereqs = $self->status->prereqs;

        ### a hashref of prereqs on success, undef on failure ###
        $prereqs    ||= $dist->_find_prereqs(
                                    verbose => $verbose,
                                    file    => $dist->status->makefile
                                );

        unless( $prereqs ) {
            error( loc( "Unable to scan '%1' for prereqs",
                        $dist->status->makefile ) );

            $fail++; last RUN;
        }
    }

	unless( $cb->_chdir( dir => $orig ) ) {
        error( loc( "Could not chdir back to start dir '%1'", $orig ) );
    }

    ### save where we wrote this stuff -- same as extract dir in normal
    ### installer circumstances
    $dist->status->distdir( $self->status->extract );

    return $dist->status->prepared( $fail ? 0 : 1);
}

=pod

=head2 $href = $dist->_find_prereqs( file => '/path/to/Makefile', [verbose => BOOL])

Parses a C<Makefile> for C<PREREQ_PM> entries and distills from that
any prerequisites mentioned in the C<Makefile>

Returns a hash with module-version pairs on success and false on
failure.

=cut

sub _find_prereqs {
    my $dist = shift;
    my $self = $dist->parent;
    my $cb   = $self->parent;
    my $conf = $cb->configure_object;
    my %hash = @@_;

    my ($verbose, $file);
    my $tmpl = {
        verbose => { default => $conf->get_conf('verbose'), store => \$verbose },
        file    => { required => 1, allow => FILE_READABLE, store => \$file },
    };

    my $args = check( $tmpl, \%hash ) or return;

    ### see if we got prereqs from MYMETA
    my $prereqs = $dist->find_mymeta_requires();

    ### we found some prereqs, we'll trust MYMETA
    ### but we do need to run it through the callback
    return $cb->_callbacks->filter_prereqs->( $cb, $prereqs ) if keys %$prereqs;

    my $fh = FileHandle->new();
    unless( $fh->open( $file ) ) {
        error( loc( "Cannot open '%1': %2", $file, $! ) );
        return;
    }

    my %p;
    while( local $_ = <$fh> ) {
        my ($found) = m|^[\#]\s+PREREQ_PM\s+=>\s+(.+)|;

        next unless $found;

        while( $found =~ m/(?:\s)([\w\:]+)=>(?:q\[(.*?)\],?|undef)/g ) {
            if( defined $p{$1} ) {
                my $ver = $cb->_version_to_number(version => $2);
                $p{$1} = $ver
                  if $cb->_vcmp( $ver, $p{$1} ) > 0;
            }
            else {
                $p{$1} = $cb->_version_to_number(version => $2);
            }
        }
        last;
    }

    my $href = $cb->_callbacks->filter_prereqs->( $cb, \%p );

    $self->status->prereqs( $href );

    ### just to make sure it's not the same reference ###
    return { %$href };
}

=pod

=head2 $bool = $dist->create([perl => '/path/to/perl', make => '/path/to/make', makeflags => 'EXTRA=FLAGS', prereq_target => TARGET, skiptest => BOOL, force => BOOL, verbose => BOOL])

C<create> creates the files necessary for installation. This means
it will run C<make> and C<make test>.  This will also scan for and
attempt to satisfy any prerequisites the module may have.

If you set C<skiptest> to true, it will skip the C<make test> stage.
If you set C<force> to true, it will go over all the stages of the
C<make> process again, ignoring any previously cached results. It
will also ignore a bad return value from C<make test> and still allow
the operation to return true.

Returns true on success and false on failure.

You may then call C<< $dist->install >> on the object to actually
install it.

=cut

sub create {
    ### just in case you already did a create call for this module object
    ### just via a different dist object
    my $dist = shift;
    my $self = $dist->parent;

    ### we're also the cpan_dist, since we don't need to have anything
    ### prepared
    $dist    = $self->status->dist_cpan if      $self->status->dist_cpan;
    $self->status->dist_cpan( $dist )   unless  $self->status->dist_cpan;

    my $cb   = $self->parent;
    my $conf = $cb->configure_object;
    my %hash = @@_;

    my $dir;
    unless( $dir = $self->status->extract ) {
        error( loc( "No dir found to operate on!" ) );
        return;
    }

    my $args;
    my( $force, $verbose, $make, $makeflags, $skiptest, $prereq_target, $perl,
        @@mmflags, $prereq_format, $prereq_build);
    {   local $Params::Check::ALLOW_UNKNOWN = 1;
        my $tmpl = {
            perl            => {    default => $^X, store => \$perl },
            force           => {    default => $conf->get_conf('force'),
                                    store   => \$force },
            verbose         => {    default => $conf->get_conf('verbose'),
                                    store   => \$verbose },
            make            => {    default => $conf->get_program('make'),
                                    store   => \$make },
            makeflags       => {    default => $conf->get_conf('makeflags'),
                                    store   => \$makeflags },
            skiptest        => {    default => $conf->get_conf('skiptest'),
                                    store   => \$skiptest },
            prereq_target   => {    default => '', store => \$prereq_target },
            ### don't set the default prereq format to 'makemaker' -- wrong!
            prereq_format   => {    #default => $self->status->installer_type,
                                    default => '',
                                    store   => \$prereq_format },
            prereq_build    => {    default => 0, store => \$prereq_build },
        };

        $args = check( $tmpl, \%hash ) or return;
    }

    my @@makeflags = $dist->_split_like_shell( $makeflags );

    ### maybe we already ran a create on this object?
    ### make sure we add to include path again, just in case we came from
    ### ->save_state, at which point we need to restore @@INC/$PERL5LIB
    if( $dist->status->created && !$force ) {
        $self->add_to_includepath;
        return 1;
    }

    ### store the arguments, so ->install can use them in recursive loops ###
    $dist->status->_create_args( $args );

    unless( $dist->status->prepared ) {
        error( loc( "You have not successfully prepared a '%2' distribution ".
                    "yet -- cannot create yet", __PACKAGE__ ) );
        return;
    }


    ### chdir to work directory ###
    my $orig = cwd();
    unless( $cb->_chdir( dir => $dir ) ) {
        error( loc( "Could not chdir to build directory '%1'", $dir ) );
        return;
    }

    my $fail; my $prereq_fail; my $test_fail;
    my $status = { };
    RUN: {
        ### this will set the directory back to the start
        ### dir, so we must chdir /again/
        my $ok = $dist->_resolve_prereqs(
                            format          => $prereq_format,
                            verbose         => $verbose,
                            prereqs         => $self->status->prereqs,
                            target          => $prereq_target,
                            force           => $force,
                            prereq_build    => $prereq_build,
                    );

        unless( $cb->_chdir( dir => $dir ) ) {
            error( loc( "Could not chdir to build directory '%1'", $dir ) );
            return;
        }

        unless( $ok ) {

            #### use $dist->flush to reset the cache ###
            error( loc( "Unable to satisfy prerequisites for '%1' " .
                        "-- aborting install", $self->module ) );
            $dist->status->make(0);
            $fail++; $prereq_fail++;
            last RUN;
        }
        ### end of prereq resolving ###

        my $captured;

        ### 'make' section ###
        if( -d BLIB->($dir) && (-M BLIB->($dir) < -M $dir) && !$force ) {
            msg(loc("Already ran '%1' for this module [%2] -- " .
                    "not running again unless you force",
                    $make, $self->module ), $verbose );
        } else {
            unless(scalar run(  command => [$make, @@makeflags],
                                buffer  => \$captured,
                                verbose => $verbose )
            ) {
                error( loc( "MAKE failed: %1 %2", $!, $captured ) );
                if ( $conf->get_conf('cpantest') ) {
                  $status->{stage} = 'build';
                  $status->{capture} = $captured;
                }
                $dist->status->make(0);
                $fail++; last RUN;
            }

            ### put the output on the stack, don't print it
            msg( $captured, 0 );

            $dist->status->make(1);

            ### add this directory to your lib ###
            $self->add_to_includepath();

            ### dont bail out here, there's a conditional later on
            #last RUN if $skiptest;
        }

        ### 'make test' section ###
        unless( $skiptest ) {

            ### turn off our PERL5OPT so no modules from CPANPLUS::inc get
            ### included in make test -- it should build without
            ### also, modules that run in taint mode break if we leave
            ### our code ref in perl5opt
            ### XXX CPANPLUS::inc functionality is now obsolete.
            #local $ENV{PERL5OPT} = CPANPLUS::inc->original_perl5opt || '';

            ### you can turn off running this verbose by changing
            ### the config setting below, although it is really not
            ### recommended
            my $run_verbose =
                        $verbose ||
                        $conf->get_conf('allow_build_interactivity') ||
                        0;

            ### XXX need to add makeflags here too?
            ### yes, but they should really be split out -- see bug #4143
            if( scalar run(
                        command => [$make, 'test', @@makeflags],
                        buffer  => \$captured,
                        verbose => $run_verbose,
            ) ) {
                ### tests might pass because it doesn't have any tests defined
                ### log this occasion non-verbosely, so our test reporter can
                ### pick up on this
                if ( NO_TESTS_DEFINED->( $captured ) ) {
                    msg( NO_TESTS_DEFINED->( $captured ), 0 )
                } else {
                    msg( loc( "MAKE TEST passed: %1", $captured ), 0 );
                }

                if ( $conf->get_conf('cpantest') ) {
                  $status->{stage} = 'test';
                  $status->{capture} = $captured;
                }

                $dist->status->test(1);
            } else {
                error( loc( "MAKE TEST failed: %1", $captured ), ( $run_verbose ? 0 : 1 ) );

                if ( $conf->get_conf('cpantest') ) {
                  $status->{stage} = 'test';
                  $status->{capture} = $captured;
                }

                ### send out error report here? or do so at a higher level?
                ### --higher level --kane.
                $dist->status->test(0);

                ### mark specifically *test* failure.. so we dont
                ### send success on force...
                $test_fail++;

                if( !$force and !$cb->_callbacks->proceed_on_test_failure->(
                                      $self, $captured )
                ) {
                    $fail++; last RUN;
                }
            }
        }
    } #</RUN>

    unless( $cb->_chdir( dir => $orig ) ) {
        error( loc( "Could not chdir back to start dir '%1'", $orig ) );
    }

    ### TODO: Add $stage to _send_report()
    ### send out test report?
    ### only do so if the failure is this module, not its prereq
    if( $conf->get_conf('cpantest') and not $prereq_fail) {
        $cb->_send_report(
            module  => $self,
            failed  => $test_fail || $fail,
            buffer  => CPANPLUS::Error->stack_as_string,
            status  => $status,
            verbose => $verbose,
            force   => $force,
        ) or error(loc("Failed to send test report for '%1'",
                    $self->module ) );
    }

    return $dist->status->created( $fail ? 0 : 1);
}

=pod

=head2 $bool = $dist->install([make => '/path/to/make',  makemakerflags => 'EXTRA=FLAGS', force => BOOL, verbose => BOOL])

C<install> runs the following command:
    make install

Returns true on success, false on failure.

=cut

sub install {

    ### just in case you did the create with ANOTHER dist object linked
    ### to the same module object
    my $dist = shift();
    my $self = $dist->parent;
    $dist    = $self->status->dist_cpan if $self->status->dist_cpan;

    my $cb   = $self->parent;
    my $conf = $cb->configure_object;
    my %hash = @@_;


    unless( $dist->status->created ) {
        error(loc("You have not successfully created a '%2' distribution yet " .
                  "-- cannot install yet", __PACKAGE__ ));
        return;
    }

    my $dir;
    unless( $dir = $self->status->extract ) {
        error( loc( "No dir found to operate on!" ) );
        return;
    }

    my $args;
    my($force,$verbose,$make,$makeflags);
    {   local $Params::Check::ALLOW_UNKNOWN = 1;
        my $tmpl = {
            force       => {    default => $conf->get_conf('force'),
                                store   => \$force },
            verbose     => {    default => $conf->get_conf('verbose'),
                                store   => \$verbose },
            make        => {    default => $conf->get_program('make'),
                                store   => \$make },
            makeflags   => {    default => $conf->get_conf('makeflags'),
                                store   => \$makeflags },
        };

        $args = check( $tmpl, \%hash ) or return;
    }

    ### value set and false -- means failure ###
    if( defined $self->status->installed &&
        !$self->status->installed && !$force
    ) {
        error( loc( "Module '%1' has failed to install before this session " .
                    "-- aborting install", $self->module ) );
        return;
    }

    my @@makeflags = $dist->_split_like_shell( $makeflags );

    $dist->status->_install_args( $args );

    my $orig = cwd();
    unless( $cb->_chdir( dir => $dir ) ) {
        error( loc( "Could not chdir to build directory '%1'", $dir ) );
        return;
    }

    my $fail; my $captured;

    ### 'make install' section ###
    ### XXX need makeflags here too?
    ### yes, but they should really be split out.. see bug #4143
    my $cmd     = [$make, 'install', @@makeflags];
    my $sudo    = $conf->get_program('sudo');
    unshift @@$cmd, $sudo if $sudo and $>;

    $cb->flush('lib');
    unless(scalar run(  command => $cmd,
                        verbose => $verbose,
                        buffer  => \$captured,
    ) ) {
        error( loc( "MAKE INSTALL failed: %1 %2", $!, $captured ) );
        $fail++;
    }

    ### put the output on the stack, don't print it
    msg( $captured, 0 );

    unless( $cb->_chdir( dir => $orig ) ) {
        error( loc( "Could not chdir back to start dir '%1'", $orig ) );
    }

    return $dist->status->installed( $fail ? 0 : 1 );

}

=pod

=head2 $bool = $dist->write_makefile_pl([force => BOOL, verbose => BOOL])

This routine can write a C<Makefile.PL> from the information in a
module object. It is used to write a C<Makefile.PL> when the original
author forgot it (!!).

Returns 1 on success and false on failure.

The file gets written to the directory the module's been extracted
to.

=cut

sub write_makefile_pl {
    ### just in case you already did a call for this module object
    ### just via a different dist object
    my $dist = shift;
    my $self = $dist->parent;
    $dist    = $self->status->dist_cpan if      $self->status->dist_cpan;
    $self->status->dist_cpan( $dist )   unless  $self->status->dist_cpan;

    my $cb   = $self->parent;
    my $conf = $cb->configure_object;
    my %hash = @@_;

    my $dir;
    unless( $dir = $self->status->extract ) {
        error( loc( "No dir found to operate on!" ) );
        return;
    }

    my ($force, $verbose);
    my $tmpl = {
        force           => {    default => $conf->get_conf('force'),
                                store => \$force },
        verbose         => {    default => $conf->get_conf('verbose'),
                                store => \$verbose },
    };

    my $args = check( $tmpl, \%hash ) or return;

    my $file = MAKEFILE_PL->($dir);
    if( -s $file && !$force ) {
        msg(loc("Already created '%1' - not doing so again without force",
                $file ), $verbose );
        return 1;
    }

    ### due to a bug with AS perl 5.8.4 built 810 (and maybe others)
    ### opening files with content in them already does nasty things;
    ### seek to pos 0 and then print, but not truncating the file
    ### bug reported to activestate on 19 sep 2004:
    ### http://bugs.activestate.com/show_bug.cgi?id=34051
    unlink $file if $force;

    my $fh = new FileHandle;
    unless( $fh->open( ">$file" ) ) {
        error( loc( "Could not create file '%1': %2", $file, $! ) );
        return;
    }

    my $mf      = MAKEFILE_PL->();
    my $name    = $self->module;
    my $version = $self->version;
    my $author  = $self->author->author;
    my $href    = $self->status->prereqs;
    my $prereqs = join ",\n", map {
                                (' ' x 25) . "'$_'\t=> '$href->{$_}'"
                            } keys %$href;
    $prereqs ||= ''; # just in case there are none;

    print $fh qq|
    ### Auto-generated $mf by CPANPLUS ###

    use ExtUtils::MakeMaker;

    WriteMakefile(
        NAME        => '$name',
        VERSION     => '$version',
        AUTHOR      => '$author',
        PREREQ_PM   => {
$prereqs
                    },
    );
    \n|;

    $fh->close;
    return 1;
}

sub dist_dir {
    ### just in case you already did a call for this module object
    ### just via a different dist object
    my $dist = shift;
    my $self = $dist->parent;
    $dist    = $self->status->dist_cpan if      $self->status->dist_cpan;
    $self->status->dist_cpan( $dist )   unless  $self->status->dist_cpan;

    my $cb   = $self->parent;
    my $conf = $cb->configure_object;
    my %hash = @@_;

    my $make; my $verbose;
    {   local $Params::Check::ALLOW_UNKNOWN = 1;
        my $tmpl = {
            make    => {    default => $conf->get_program('make'),
                                    store => \$make },
            verbose => {    default => $conf->get_conf('verbose'),
                                    store   => \$verbose },
        };

        check( $tmpl, \%hash ) or return;
    }


    my $dir;
    unless( $dir = $self->status->extract ) {
        error( loc( "No dir found to operate on!" ) );
        return;
    }

    ### chdir to work directory ###
    my $orig = cwd();
    unless( $cb->_chdir( dir => $dir ) ) {
        error( loc( "Could not chdir to build directory '%1'", $dir ) );
        return;
    }

    my $fail; my $distdir;
    TRY: {
        $dist->prepare( @@_ ) or (++$fail, last TRY);


        my $captured;
            unless(scalar run(  command => [$make, 'distdir'],
                            buffer  => \$captured,
                            verbose => $verbose )
        ) {
            error( loc( "MAKE DISTDIR failed: %1 %2", $!, $captured ) );
            ++$fail, last TRY;
        }

        ### /path/to/Foo-Bar-1.2/Foo-Bar-1.2
        $distdir = File::Spec->catdir( $dir, $self->package_name . '-' .
                                                $self->package_version );

        unless( -d $distdir ) {
            error(loc("Do not know where '%1' got created", 'distdir'));
            ++$fail, last TRY;
        }
    }

    unless( $cb->_chdir( dir => $orig ) ) {
        error( loc( "Could not chdir to start directory '%1'", $orig ) );
        return;
    }

    return if $fail;
    return $distdir;
}

sub _split_like_shell {
  my ($self, $string) = @@_;

  return () unless defined($string);
  return @@$string if ref $string eq 'ARRAY';
  $string =~ s/^\s+|\s+$//g;
  return () unless length($string);

  require Text::ParseWords;
  return Text::ParseWords::shellwords($string);
}

1;

# Local variables:
# c-indentation-style: bsd
# c-basic-offset: 4
# indent-tabs-mode: nil
# End:
# vim: expandtab shiftwidth=4:
@


1.4
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@@


1.3
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d2 1
d4 1
d6 1
a6 2
use strict;
use vars    qw[@@ISA $STATUS];
d8 1
d226 1
a226 1
    my( $force, $verbose, $perl, @@mmflags, $prereq_target, $prereq_format,
d233 1
a233 1
                                    store => \$mmflags[0] },
d247 1
d584 2
d649 1
a649 1
            unless(scalar run(  command => [$make, $makeflags],
d695 1
a695 1
                        command => [$make, 'test', $makeflags],
d823 1
d838 1
a838 1
    my $cmd     = [$make, 'install', $makeflags];
d1025 11
@


1.2
log
@merge in perl 5.12.2 plus local changes
@
text
@d31 1
a31 1
    
d35 1
a35 1
    
d40 1
a40 1
Using this package, you can create, install and uninstall perl 
d58 1
a58 1
=head1 STATUS ACCESSORS 
d67 1
a67 1
Location of the Makefile (or Build file). 
d76 1
a76 1
BOOL indicating if the C<make test> (or C<Build test>) command was 
d81 1
a81 1
BOOL indicating if the C<prepare> call exited succesfully
d87 1
a87 1
set after a call to C<prepare>. 
d91 1
a91 1
BOOL indicating if the C<create> call exited succesfully. This gets
d129 1
a129 1
  
d132 1
a132 1
    my $cb   = CPANPLUS::Internals->_retrieve_id( 
d135 1
a135 1
  
d139 1
a139 1
                    $mod, __PACKAGE__ ) ); 
d142 1
a142 1
    
d144 1
a144 1
        unless( $conf->get_program( $pgm ) ) { 
d147 1
a147 1
                "Please check your config entry for '%1'", 
d149 1
a149 1
            )); 
d154 1
a154 1
    return 1;     
d157 3
a159 1
=pod $bool = $dist->init();
d161 1
a161 1
Sets up the C<CPANPLUS::Dist::MM> object for use. 
d171 1
a171 1
   
d175 1
a175 1
    
d177 3
a179 1
}    
d181 1
a181 1
=pod $bool = $dist->prepare([perl => '/path/to/perl', makemakerflags => 'EXTRA=FLAGS', force => BOOL, verbose => BOOL])
d183 1
a183 1
C<prepare> preps a distribution for installation. This means it will 
d187 2
a188 2
If you set C<force> to true, it will go over all the stages of the 
C<prepare> process again, ignoring any previously cached results. 
d207 1
a207 1
    
d209 3
a211 3
    ### prepared 
    $dist    = $self->status->dist_cpan if      $self->status->dist_cpan;     
    $self->status->dist_cpan( $dist )   unless  $self->status->dist_cpan;    
d222 1
a222 1
    
d232 1
a232 1
            force           => {    default => $conf->get_conf('force'), 
d234 1
a234 1
            verbose         => {    default => $conf->get_conf('verbose'), 
d236 1
a236 1
            prereq_target   => {    default => '', store => \$prereq_target }, 
d238 3
a240 3
                                    store   => \$prereq_format },   
            prereq_build    => {    default => 0, store => \$prereq_build },     
        };                                            
d244 2
a245 2
    
    
d248 1
a248 1
        
d251 1
a251 1
    
d258 2
a259 2
    
    my $fail; 
d265 1
a265 1
        ### something that *doesnt* resolve. Check the error log for ok
d267 1
a267 1
        ### XXX make a seperate tarball to test for this scenario: simply
d269 1
a269 1
        {   my $configure_requires = $dist->find_configure_requires;     
d277 2
a278 2
                    );    
    
d280 1
a280 1
           
d283 2
a284 2
                            "-- aborting install", 
                            'configure_requires', $self->module ) );    
d286 1
a286 1
                $fail++; 
d288 1
a288 1
            } 
a290 1
        
d293 2
a294 1
        ### don't run 'perl makefile.pl' again if there's a makefile already 
d299 1
a299 1
            
d304 4
a307 4
                        
                $dist->write_makefile_pl( 
                            verbose => $verbose, 
                            force   => $force 
d309 1
a309 1
                
d312 1
a312 1
                    error( loc( "Could not find '%1' - cannot continue", 
d314 1
a314 1
        
d319 2
a320 2
            }    
    
d324 1
a324 1
            my $run_verbose = $verbose || 
d327 1
a327 1
    
d330 2
a331 2
            local $ENV{PERL_MM_USE_DEFAULT} = 1 unless $run_verbose; 
    
d338 2
a339 2
            #local $ENV{PERL5OPT} = CPANPLUS::inc->original_perl5opt || ''; 
    
d343 2
a344 2
            
            
d350 1
a350 1
            
d356 2
a357 14
            ### XXX this fails under ipc::run due to the extra quotes,
            ### but it works in ipc::open3. however, ipc::open3 doesn't work
            ### on win32/cygwin. XXX TODO get a windows box and sort this out
            # my $cmd =  qq[$perl -MEnglish -le ] . 
            #            QUOTE_PERL_ONE_LINER->(
            #                qq[\$OUTPUT_AUTOFLUSH++,do(q($makefile_pl))]
            #            ) 
            #            . $mmflags;

            # my $flush = OPT_AUTOFLUSH;
            # my $cmd     = "$perl $flush $makefile_pl $mmflags";

            my $run_perl    = $conf->get_program('perlwrapper');
            my $cmd         = [$perl, $run_perl, $makefile_pl, @@mmflags];
d361 1
a361 1
            my $captured; 
d367 1
a367 1
                            verbose => $run_verbose, # may be interactive   
d370 1
a370 1
    
d374 1
a374 1
                
d382 1
a382 1
        
d398 2
a399 2
            ));           
            
d402 1
a402 1
        
d404 13
a416 2
        $dist->status->makefile( MAKEFILE->($dir) );               
        
d419 1
a419 1
       
d421 1
a421 1
        $prereqs    ||= $dist->_find_prereqs( 
d423 1
a423 1
                                    file    => $dist->status->makefile 
d425 1
a425 1
        
d427 1
a427 1
            error( loc( "Unable to scan '%1' for prereqs", 
d433 1
a433 1
   
d436 2
a437 2
    }   
   
d441 1
a441 1
   
d469 2
a470 2
    
    my $args = check( $tmpl, \%hash ) or return;      
d474 1
a474 1
    
d478 1
a478 1
    
d484 1
a484 1
    
d487 2
a488 2
        my ($found) = m|^[\#]\s+PREREQ_PM\s+=>\s+(.+)|;         
        
d490 1
a490 1
        
d498 1
a498 1
                $p{$1} = $cb->_version_to_number(version => $2);                  
d507 1
a507 1
    
d509 2
a510 2
    return { %$href };                              
}     
d516 3
a518 3
C<create> creates the files necessary for installation. This means 
it will run C<make> and C<make test>.  This will also scan for and 
attempt to satisfy any prerequisites the module may have. 
d521 3
a523 3
If you set C<force> to true, it will go over all the stages of the 
C<make> process again, ignoring any previously cached results. It 
will also ignore a bad return value from C<make test> and still allow 
d538 1
a538 1
    
d540 3
a542 3
    ### prepared 
    $dist    = $self->status->dist_cpan if      $self->status->dist_cpan;     
    $self->status->dist_cpan( $dist )   unless  $self->status->dist_cpan;    
d553 1
a553 1
    
d555 1
a555 1
    my( $force, $verbose, $make, $makeflags, $skiptest, $prereq_target, $perl, 
d560 1
a560 1
            force           => {    default => $conf->get_conf('force'), 
d562 1
a562 1
            verbose         => {    default => $conf->get_conf('verbose'), 
d564 1
a564 1
            make            => {    default => $conf->get_program('make'), 
d566 1
a566 1
            makeflags       => {    default => $conf->get_conf('makeflags'), 
d568 1
a568 1
            skiptest        => {    default => $conf->get_conf('skiptest'), 
d570 1
a570 1
            prereq_target   => {    default => '', store => \$prereq_target }, 
d574 3
a576 3
                                    store   => \$prereq_format },   
            prereq_build    => {    default => 0, store => \$prereq_build },                                    
        };                                            
d580 1
a580 1
    
d587 2
a588 2
    }        
    
d591 1
a591 1
    
d597 2
a598 2
    
    
d605 1
a605 1
    
d607 1
d610 1
a610 1
        ### dir, so we must chdir /again/           
d619 1
a619 1
        
d623 2
a624 2
        }       
                  
d626 1
a626 1
       
d629 1
a629 1
                        "-- aborting install", $self->module ) );    
d633 3
a635 3
        } 
        ### end of prereq resolving ###    
        
d638 1
a638 1
        ### 'make' section ###    
d641 1
a641 1
                    "not running again unless you force", 
d646 1
a646 1
                                verbose => $verbose ) 
d649 4
d656 1
a656 1
            
d664 1
a664 1
            
d668 2
a669 2
        
        ### 'make test' section ###                                           
d680 1
a680 1
            ### the config setting below, although it is really not 
d682 2
a683 2
            my $run_verbose =   
                        $verbose || 
d687 1
a687 1
            ### XXX need to add makeflags here too? 
d689 1
a689 1
            if( scalar run( 
d702 6
a707 1
            
d710 7
a716 2
                error( loc( "MAKE TEST failed: %1 %2", $!, $captured ) );
            
d720 1
a720 1
               
d724 1
a724 1
                
d726 1
a726 1
                                      $self, $captured ) 
d728 1
a728 1
                    $fail++; last RUN;     
d733 1
a733 1
      
d736 3
a738 2
    }  
    
d742 1
a742 1
        $cb->_send_report( 
d746 1
d751 2
a752 2
    }            
            
d754 1
a754 1
} 
d763 1
a763 1
Returns true on success, false on failure.    
d773 2
a774 2
    $dist    = $self->status->dist_cpan if $self->status->dist_cpan;       
   
d778 2
a779 2
    
    
d785 1
a785 1
 
d791 1
a791 1
    
d796 1
a796 1
            force       => {    default => $conf->get_conf('force'), 
d798 1
a798 1
            verbose     => {    default => $conf->get_conf('verbose'), 
d800 1
a800 1
            make        => {    default => $conf->get_program('make'), 
d802 1
a802 1
            makeflags   => {    default => $conf->get_conf('makeflags'), 
d804 2
a805 2
        };      
    
d810 2
a811 2
    if( defined $self->status->installed && 
        !$self->status->installed && !$force 
d818 1
a818 1
            
d820 1
a820 1
    
d826 1
a826 1
    
d828 1
a828 1
    
d830 1
a830 1
    ### XXX need makeflags here too? 
d840 1
a840 1
    ) ) {                   
d842 2
a843 2
        $fail++; 
    }       
d847 1
a847 1
    
d850 2
a851 2
    }   
    
d853 1
a853 1
    
d860 1
a860 1
This routine can write a C<Makefile.PL> from the information in a 
d866 1
a866 1
The file gets written to the directory the module's been extracted 
d876 3
a878 3
    $dist    = $self->status->dist_cpan if      $self->status->dist_cpan;     
    $self->status->dist_cpan( $dist )   unless  $self->status->dist_cpan;    
 
d888 1
a888 1
    
d891 1
a891 1
        force           => {    default => $conf->get_conf('force'),   
d893 5
a897 3
        verbose         => {    default => $conf->get_conf('verbose'), 
                                store => \$verbose },   
    };                                          
a898 2
    my $args = check( $tmpl, \%hash ) or return;    
    
d901 1
a901 1
        msg(loc("Already created '%1' - not doing so again without force", 
d904 1
a904 1
    }     
d918 1
a918 1
    
d924 5
a928 5
    my $prereqs = join ",\n", map { 
                                (' ' x 25) . "'$_'\t=> '$href->{$_}'" 
                            } keys %$href;  
    $prereqs ||= ''; # just in case there are none;                         
                             
d931 1
a931 1
    
d933 1
a933 1
    
d939 1
a939 1
$prereqs                       
d942 2
a943 2
    \n|;   
    
d946 2
a947 2
}                         
        
d953 3
a955 3
    $dist    = $self->status->dist_cpan if      $self->status->dist_cpan;     
    $self->status->dist_cpan( $dist )   unless  $self->status->dist_cpan;    
 
d959 1
a959 1
    
d964 2
a965 2
                                    store => \$make },                 
            verbose => {    default => $conf->get_conf('verbose'), 
d967 3
a969 3
        };  
    
        check( $tmpl, \%hash ) or return;    
d978 1
a978 1
    
d987 1
a987 1
    TRY: {    
d991 1
a991 1
        my $captured;             
d994 1
a994 1
                            verbose => $verbose ) 
d1017 1
a1017 1
}    
@


1.1
log
@Initial revision
@
text
@d26 1
a26 1
CPANPLUS::Dist::MM
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d26 1
a26 1
CPANPLUS::Dist::MM - distribution class for MakeMaker related modules
d31 1
a31 1

d35 1
a35 1

d40 1
a40 1
Using this package, you can create, install and uninstall perl
d58 1
a58 1
=head1 STATUS ACCESSORS
d67 1
a67 1
Location of the Makefile (or Build file).
d76 1
a76 1
BOOL indicating if the C<make test> (or C<Build test>) command was
d81 1
a81 1
BOOL indicating if the C<prepare> call exited successfully
d87 1
a87 1
set after a call to C<prepare>.
d91 1
a91 1
BOOL indicating if the C<create> call exited successfully. This gets
d129 1
a129 1

d132 1
a132 1
    my $cb   = CPANPLUS::Internals->_retrieve_id(
d135 1
a135 1

d139 1
a139 1
                    $mod, __PACKAGE__ ) );
d142 1
a142 1

d144 1
a144 1
        unless( $conf->get_program( $pgm ) ) {
d147 1
a147 1
                "Please check your config entry for '%1'",
d149 1
a149 1
            ));
d154 1
a154 1
    return 1;
d157 1
a157 3
=pod

=head2 $bool = $dist->init();
d159 1
a159 1
Sets up the C<CPANPLUS::Dist::MM> object for use.
d169 1
a169 1

d173 1
a173 1

d175 1
a175 3
}

=pod
d177 1
a177 1
=head2 $bool = $dist->prepare([perl => '/path/to/perl', makemakerflags => 'EXTRA=FLAGS', force => BOOL, verbose => BOOL])
d179 1
a179 1
C<prepare> preps a distribution for installation. This means it will
d183 2
a184 2
If you set C<force> to true, it will go over all the stages of the
C<prepare> process again, ignoring any previously cached results.
d203 1
a203 1

d205 3
a207 3
    ### prepared
    $dist    = $self->status->dist_cpan if      $self->status->dist_cpan;
    $self->status->dist_cpan( $dist )   unless  $self->status->dist_cpan;
d218 1
a218 1

d228 1
a228 1
            force           => {    default => $conf->get_conf('force'),
d230 1
a230 1
            verbose         => {    default => $conf->get_conf('verbose'),
d232 1
a232 1
            prereq_target   => {    default => '', store => \$prereq_target },
d234 3
a236 3
                                    store   => \$prereq_format },
            prereq_build    => {    default => 0, store => \$prereq_build },
        };
d240 2
a241 2


d244 1
a244 1

d247 1
a247 1

d254 2
a255 2

    my $fail;
d261 1
a261 1
        ### something that *doesn't* resolve. Check the error log for ok
d263 1
a263 1
        ### XXX make a separate tarball to test for this scenario: simply
d265 1
a265 1
        {   my $configure_requires = $dist->find_configure_requires;
d273 2
a274 2
                    );

d276 1
a276 1

d279 2
a280 2
                            "-- aborting install",
                            'configure_requires', $self->module ) );
d282 1
a282 1
                $fail++;
d284 1
a284 1
            }
d287 1
d290 1
a290 2

        ### don't run 'perl makefile.pl' again if there's a makefile already
d295 1
a295 1

d300 4
a303 4

                $dist->write_makefile_pl(
                            verbose => $verbose,
                            force   => $force
d305 1
a305 1

d308 1
a308 1
                    error( loc( "Could not find '%1' - cannot continue",
d310 1
a310 1

d315 2
a316 2
            }

d320 1
a320 1
            my $run_verbose = $verbose ||
d323 1
a323 1

d326 2
a327 2
            local $ENV{PERL_MM_USE_DEFAULT} = 1 unless $run_verbose;

d334 2
a335 2
            #local $ENV{PERL5OPT} = CPANPLUS::inc->original_perl5opt || '';

d339 2
a340 2


d346 1
a346 1

d352 14
a365 2
            my @@run_perl    = ( '-e', PERL_WRAPPER );
            my $cmd         = [$perl, @@run_perl, $makefile_pl, @@mmflags];
d369 1
a369 1
            my $captured;
d375 1
a375 1
                            verbose => $run_verbose, # may be interactive
d378 1
a378 1

d382 1
a382 1

d390 1
a390 1

d406 2
a407 2
            ));

d410 1
a410 1

d412 2
a413 13
        $dist->status->makefile( MAKEFILE->($dir) );

        ### Make (haha) sure that Makefile.PL is older than the Makefile
        ### we just generated.
        eval {
          my $makestat = ( stat MAKEFILE->( $dir ) )[9];
          my $mplstat = ( stat MAKEFILE_PL->( $cb->_safe_path( path => $dir ) ) )[9];
          if ( $makestat < $mplstat ) {
            my $ftime = $makestat - 60;
            utime $ftime, $ftime, MAKEFILE_PL->( $cb->_safe_path( path => $dir ) );
          }
        };

d416 1
a416 1

d418 1
a418 1
        $prereqs    ||= $dist->_find_prereqs(
d420 1
a420 1
                                    file    => $dist->status->makefile
d422 1
a422 1

d424 1
a424 1
            error( loc( "Unable to scan '%1' for prereqs",
d430 1
a430 1

d433 2
a434 2
    }

d438 1
a438 1

d466 2
a467 2

    my $args = check( $tmpl, \%hash ) or return;
d471 1
a471 1

d475 1
a475 1

d481 1
a481 1

d484 2
a485 2
        my ($found) = m|^[\#]\s+PREREQ_PM\s+=>\s+(.+)|;

d487 1
a487 1

d495 1
a495 1
                $p{$1} = $cb->_version_to_number(version => $2);
d504 1
a504 1

d506 2
a507 2
    return { %$href };
}
d513 3
a515 3
C<create> creates the files necessary for installation. This means
it will run C<make> and C<make test>.  This will also scan for and
attempt to satisfy any prerequisites the module may have.
d518 3
a520 3
If you set C<force> to true, it will go over all the stages of the
C<make> process again, ignoring any previously cached results. It
will also ignore a bad return value from C<make test> and still allow
d535 1
a535 1

d537 3
a539 3
    ### prepared
    $dist    = $self->status->dist_cpan if      $self->status->dist_cpan;
    $self->status->dist_cpan( $dist )   unless  $self->status->dist_cpan;
d550 1
a550 1

d552 1
a552 1
    my( $force, $verbose, $make, $makeflags, $skiptest, $prereq_target, $perl,
d557 1
a557 1
            force           => {    default => $conf->get_conf('force'),
d559 1
a559 1
            verbose         => {    default => $conf->get_conf('verbose'),
d561 1
a561 1
            make            => {    default => $conf->get_program('make'),
d563 1
a563 1
            makeflags       => {    default => $conf->get_conf('makeflags'),
d565 1
a565 1
            skiptest        => {    default => $conf->get_conf('skiptest'),
d567 1
a567 1
            prereq_target   => {    default => '', store => \$prereq_target },
d571 3
a573 3
                                    store   => \$prereq_format },
            prereq_build    => {    default => 0, store => \$prereq_build },
        };
d577 1
a577 1

d584 2
a585 2
    }

d588 1
a588 1

d594 2
a595 2


d602 1
a602 1

a603 1
    my $status = { };
d606 1
a606 1
        ### dir, so we must chdir /again/
d615 1
a615 1

d619 2
a620 2
        }

d622 1
a622 1

d625 1
a625 1
                        "-- aborting install", $self->module ) );
d629 3
a631 3
        }
        ### end of prereq resolving ###

d634 1
a634 1
        ### 'make' section ###
d637 1
a637 1
                    "not running again unless you force",
d642 1
a642 1
                                verbose => $verbose )
a644 4
                if ( $conf->get_conf('cpantest') ) {
                  $status->{stage} = 'build';
                  $status->{capture} = $captured;
                }
d648 1
a648 1

d656 1
a656 1

d660 2
a661 2

        ### 'make test' section ###
d672 1
a672 1
            ### the config setting below, although it is really not
d674 2
a675 2
            my $run_verbose =
                        $verbose ||
d679 1
a679 1
            ### XXX need to add makeflags here too?
d681 1
a681 1
            if( scalar run(
d694 1
a694 6

                if ( $conf->get_conf('cpantest') ) {
                  $status->{stage} = 'test';
                  $status->{capture} = $captured;
                }

d697 2
a698 7
                error( loc( "MAKE TEST failed: %1", $captured ), ( $run_verbose ? 0 : 1 ) );

                if ( $conf->get_conf('cpantest') ) {
                  $status->{stage} = 'test';
                  $status->{capture} = $captured;
                }

d702 1
a702 1

d706 1
a706 1

d708 1
a708 1
                                      $self, $captured )
d710 1
a710 1
                    $fail++; last RUN;
d715 1
a715 1

d718 2
a719 3
    }

    ### TODO: Add $stage to _send_report()
d723 1
a723 1
        $cb->_send_report(
a726 1
            status  => $status,
d731 2
a732 2
    }

d734 1
a734 1
}
d743 1
a743 1
Returns true on success, false on failure.
d753 2
a754 2
    $dist    = $self->status->dist_cpan if $self->status->dist_cpan;

d758 2
a759 2


d765 1
a765 1

d771 1
a771 1

d776 1
a776 1
            force       => {    default => $conf->get_conf('force'),
d778 1
a778 1
            verbose     => {    default => $conf->get_conf('verbose'),
d780 1
a780 1
            make        => {    default => $conf->get_program('make'),
d782 1
a782 1
            makeflags   => {    default => $conf->get_conf('makeflags'),
d784 2
a785 2
        };

d790 2
a791 2
    if( defined $self->status->installed &&
        !$self->status->installed && !$force
d798 1
a798 1

d800 1
a800 1

d806 1
a806 1

d808 1
a808 1

d810 1
a810 1
    ### XXX need makeflags here too?
d820 1
a820 1
    ) ) {
d822 2
a823 2
        $fail++;
    }
d827 1
a827 1

d830 2
a831 2
    }

d833 1
a833 1

d840 1
a840 1
This routine can write a C<Makefile.PL> from the information in a
d846 1
a846 1
The file gets written to the directory the module's been extracted
d856 3
a858 3
    $dist    = $self->status->dist_cpan if      $self->status->dist_cpan;
    $self->status->dist_cpan( $dist )   unless  $self->status->dist_cpan;

d868 1
a868 1

d871 1
a871 1
        force           => {    default => $conf->get_conf('force'),
d873 3
a875 5
        verbose         => {    default => $conf->get_conf('verbose'),
                                store => \$verbose },
    };

    my $args = check( $tmpl, \%hash ) or return;
d877 2
d881 1
a881 1
        msg(loc("Already created '%1' - not doing so again without force",
d884 1
a884 1
    }
d898 1
a898 1

d904 5
a908 5
    my $prereqs = join ",\n", map {
                                (' ' x 25) . "'$_'\t=> '$href->{$_}'"
                            } keys %$href;
    $prereqs ||= ''; # just in case there are none;

d911 1
a911 1

d913 1
a913 1

d919 1
a919 1
$prereqs
d922 2
a923 2
    \n|;

d926 2
a927 2
}

d933 3
a935 3
    $dist    = $self->status->dist_cpan if      $self->status->dist_cpan;
    $self->status->dist_cpan( $dist )   unless  $self->status->dist_cpan;

d939 1
a939 1

d944 2
a945 2
                                    store => \$make },
            verbose => {    default => $conf->get_conf('verbose'),
d947 3
a949 3
        };

        check( $tmpl, \%hash ) or return;
d958 1
a958 1

d967 1
a967 1
    TRY: {
d971 1
a971 1
        my $captured;
d974 1
a974 1
                            verbose => $verbose )
d997 1
a997 1
}
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a1 1
use deprecate;
d3 1
d5 1
a5 2
use warnings;
use vars    qw[@@ISA $STATUS $VERSION];
a6 1
$VERSION = "0.9135";
d224 1
a224 1
    my( $force, $verbose, $perl, $mmflags, $prereq_target, $prereq_format,
d231 1
a231 1
                                    store => \$mmflags },
a244 1
    my @@mmflags = $dist->_split_like_shell( $mmflags );
a580 2
    my @@makeflags = $dist->_split_like_shell( $makeflags );

d644 1
a644 1
            unless(scalar run(  command => [$make, @@makeflags],
d690 1
a690 1
                        command => [$make, 'test', @@makeflags],
a817 1
    my @@makeflags = $dist->_split_like_shell( $makeflags );
d832 1
a832 1
    my $cmd     = [$make, 'install', @@makeflags];
a1018 11
sub _split_like_shell {
  my ($self, $string) = @@_;

  return () unless defined($string);
  return @@$string if ref $string eq 'ARRAY';
  $string =~ s/^\s+|\s+$//g;
  return () unless length($string);

  require Text::ParseWords;
  return Text::ParseWords::shellwords($string);
}
@


