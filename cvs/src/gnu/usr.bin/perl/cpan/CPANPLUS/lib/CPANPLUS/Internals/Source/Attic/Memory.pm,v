head	1.5;
access;
symbols
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.2.0.10
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.8
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2014.11.17.20.56.57;	author afresh1;	state dead;
branches;
next	1.4;
commitid	QP75iYx42Uo7mMxO;

1.4
date	2014.03.24.15.05.23;	author afresh1;	state Exp;
branches;
next	1.3;

1.3
date	2013.03.25.20.40.46;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2010.09.24.15.06.45;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.24.14.49.03;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.03;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.06.57;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.50;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@package CPANPLUS::Internals::Source::Memory;
use deprecate;

use base 'CPANPLUS::Internals::Source';

use strict;

use CPANPLUS::Error;
use CPANPLUS::Module;
use CPANPLUS::Module::Fake;
use CPANPLUS::Module::Author;
use CPANPLUS::Internals::Constants;

use File::Fetch;
use Archive::Extract;

use IPC::Cmd                    qw[can_run];
use File::Temp                  qw[tempdir];
use File::Basename              qw[dirname];
use Params::Check               qw[allow check];
use Module::Load::Conditional   qw[can_load];
use Locale::Maketext::Simple    Class => 'CPANPLUS', Style => 'gettext';

use vars qw[$VERSION];
$VERSION = "0.9135";

$Params::Check::VERBOSE = 1;

=head1 NAME

CPANPLUS::Internals::Source::Memory - In memory implementation

=cut

### flag to show if init_trees got its' data from storable. This allows
### us to not write an existing stored file back to disk
{   my $from_storable;

    sub _init_trees {
        my $self = shift;
        my $conf = $self->configure_object;
        my %hash = @@_;

        my($path,$uptodate,$verbose,$use_stored);
        my $tmpl = {
            path        => { default => $conf->get_conf('base'), store => \$path },
            verbose     => { default => $conf->get_conf('verbose'), store => \$verbose },
            uptodate    => { required => 1, store => \$uptodate },
            use_stored  => { default  => 1, store => \$use_stored },
        };

        check( $tmpl, \%hash ) or return;

        ### retrieve the stored source files ###
        my $stored      = $self->__memory_retrieve_source(
                                path        => $path,
                                uptodate    => $uptodate && $use_stored,
                                verbose     => $verbose,
                            ) || {};

        ### we got this from storable if $stored has keys..
        $from_storable = keys %$stored ? 1 : 0;

        ### set up the trees
        $self->_atree( $stored->{_atree} || {} );
        $self->_mtree( $stored->{_mtree} || {} );

        return 1;
    }

    sub _standard_trees_completed { return $from_storable }
    sub _custom_trees_completed   { return $from_storable }

    sub _finalize_trees {
        my $self = shift;
        my $conf = $self->configure_object;
        my %hash = @@_;

        my($path,$uptodate,$verbose);
        my $tmpl = {
            path        => { default => $conf->get_conf('base'), store => \$path },
            verbose     => { default => $conf->get_conf('verbose'), store => \$verbose },
            uptodate    => { required => 1, store => \$uptodate },
        };

        {   local $Params::Check::ALLOW_UNKNOWN = 1;
            check( $tmpl, \%hash ) or return;
        }

        ### write the stored files to disk, so we can keep using them
        ### from now on, till they become invalid
        ### write them if the original sources weren't uptodate, or
        ### we didn't just load storable files
        $self->__memory_save_source() if !$uptodate or not $from_storable;

        return 1;
    }

    ### saves current memory state
    sub _save_state {
        my $self = shift;
        return $self->_finalize_trees( @@_, uptodate => 0 );
    }
}

sub _add_author_object {
    my $self = shift;
    my %hash = @@_;

    my $class;
    my $tmpl = {
        class   => { default => 'CPANPLUS::Module::Author', store => \$class },
        map { $_ => { required => 1 } }
            qw[ author cpanid email ]
    };

    my $href = do {
        local $Params::Check::NO_DUPLICATES = 1;
        check( $tmpl, \%hash ) or return;
    };

    my $obj = $class->new( %$href, _id => $self->_id );

    $self->author_tree->{ $href->{'cpanid'} } = $obj or return;

    return $obj;
}

{
    my $tmpl = {
        class => { default => 'CPANPLUS::Module' },
        map { $_ => { required => 1 } } qw[
           module version path comment author package description dslip mtime
        ],
    };

    sub _add_module_object {
        my $self = shift;
        my %hash = @@_;

        my $href = do {
            local $Params::Check::SANITY_CHECK_TEMPLATE = 0;
            check( $tmpl, \%hash ) or return;
        };
        my $class = delete $href->{class};

        my $obj = $class->new( %$href, _id => $self->_id );

        ### Every module get's stored as a module object ###
        $self->module_tree->{ $href->{module} } = $obj or return;

        return $obj;
    }
}

{   my %map = (
        _source_search_module_tree  => [ module_tree => 'CPANPLUS::Module' ],
        _source_search_author_tree  => [ author_tree => 'CPANPLUS::Module::Author' ],
    );

    while( my($sub, $aref) = each %map ) {
        no strict 'refs';

        my($meth, $class) = @@$aref;

        *$sub = sub {
            my $self = shift;
            my $conf = $self->configure_object;
            my %hash = @@_;

            my($authors,$list,$verbose,$type);
            my $tmpl = {
                data    => { default    => [],
                             strict_type=> 1, store     => \$authors },
                allow   => { required   => 1, default   => [ ], strict_type => 1,
                             store      => \$list },
                verbose => { default    => $conf->get_conf('verbose'),
                             store      => \$verbose },
                type    => { required   => 1, allow => [$class->accessors()],
                             store      => \$type },
            };

            my $args = check( $tmpl, \%hash ) or return;

            my @@rv;
            for my $obj ( values %{ $self->$meth } ) {
                #push @@rv, $auth if check(
                #                        { $type => { allow => $list } },
                #                        { $type => $auth->$type }
                #                    );
                push @@rv, $obj if allow( $obj->$type() => $list );
            }

            return @@rv;
        }
    }
}

=pod

=head2 $cb->__memory_retrieve_source(name => $name, [path => $path, uptodate => BOOL, verbose => BOOL])

This method retrieves a I<storable>d tree identified by C<$name>.

It takes the following arguments:

=over 4

=item name

The internal name for the source file to retrieve.

=item uptodate

A flag indicating whether the file-cache is up-to-date or not.

=item path

The absolute path to the directory holding the source files.

=item verbose

A boolean flag indicating whether or not to be verbose.

=back

Will get information from the config file by default.

Returns a tree on success, false on failure.

=cut

sub __memory_retrieve_source {
    my $self = shift;
    my %hash = @@_;
    my $conf = $self->configure_object;

    my $tmpl = {
        path     => { default => $conf->get_conf('base') },
        verbose  => { default => $conf->get_conf('verbose') },
        uptodate => { default => 0 },
    };

    my $args = check( $tmpl, \%hash ) or return;

    ### check if we can retrieve a frozen data structure with storable ###
    my $storable = can_load( modules => {'Storable' => '0.0'} )
                        if $conf->get_conf('storable');

    return unless $storable;

    ### $stored is the name of the frozen data structure ###
    my $stored = $self->__memory_storable_file( $args->{path} );

    if ($storable && -e $stored && -s _ && $args->{'uptodate'}) {
        msg( loc("Retrieving %1", $stored), $args->{'verbose'} );

        my $href = Storable::retrieve($stored);
        return $href;
    } else {
        return;
    }
}

=pod

=head2 $cb->__memory_save_source([verbose => BOOL, path => $path])

This method saves all the parsed trees in I<storable>d format if
C<Storable> is available.

It takes the following arguments:

=over 4

=item path

The absolute path to the directory holding the source files.

=item verbose

A boolean flag indicating whether or not to be verbose.

=back

Will get information from the config file by default.

Returns true on success, false on failure.

=cut

sub __memory_save_source {
    my $self = shift;
    my %hash = @@_;
    my $conf = $self->configure_object;


    my $tmpl = {
        path     => { default => $conf->get_conf('base'), allow => DIR_EXISTS },
        verbose  => { default => $conf->get_conf('verbose') },
        force    => { default => 1 },
    };

    my $args = check( $tmpl, \%hash ) or return;

    my $aref = [qw[_mtree _atree]];

    ### check if we can retrieve a frozen data structure with storable ###
    my $storable;
    $storable = can_load( modules => {'Storable' => '0.0'} )
                    if $conf->get_conf('storable');
    return unless $storable;

    my $to_write = {};
    foreach my $key ( @@$aref ) {
        next unless ref( $self->$key );
        $to_write->{$key} = $self->$key;
    }

    return unless keys %$to_write;

    ### $stored is the name of the frozen data structure ###
    my $stored = $self->__memory_storable_file( $args->{path} );

    if (-e $stored && not -w $stored) {
        msg( loc("%1 not writable; skipped.", $stored), $args->{'verbose'} );
        return;
    }

    msg( loc("Writing compiled source information to disk. This might take a little while."),
	    $args->{'verbose'} );

    my $flag;
    unless( Storable::nstore( $to_write, $stored ) ) {
        error( loc("could not store %1!", $stored) );
        $flag++;
    }

    return $flag ? 0 : 1;
}

sub __memory_storable_file {
    my $self = shift;
    my $conf = $self->configure_object;
    my $path = shift or return;

    ### check if we can retrieve a frozen data structure with storable ###
    my $storable = $conf->get_conf('storable')
                        ? can_load( modules => {'Storable' => '0.0'} )
                        : 0;

    return unless $storable;

    ### $stored is the name of the frozen data structure ###
    ### changed to use File::Spec->catfile -jmb
    my $stored = File::Spec->rel2abs(
        File::Spec->catfile(
            $path,                          #base dir
            $conf->_get_source('stored')    #file
            . '.s' .
            $Storable::VERSION              #the version of storable
            . '.c' .
            $self->VERSION                  #the version of CPANPLUS
            . STORABLE_EXT                  #append a suffix
        )
    );

    return $stored;
}




# Local variables:
# c-indentation-style: bsd
# c-basic-offset: 4
# indent-tabs-mode: nil
# End:
# vim: expandtab shiftwidth=4:

1;
@


1.4
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@@


1.3
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d2 1
d24 3
d129 1
a129 5
sub _add_module_object {
    my $self = shift;
    my %hash = @@_;

    my $class;
d131 4
a134 3
        class   => { default => 'CPANPLUS::Module', store => \$class },
        map { $_ => { required => 1 } }
            qw[ module version path comment author package description dslip mtime ]
d137 9
a145 4
    my $href = do {
        local $Params::Check::NO_DUPLICATES = 1;
        check( $tmpl, \%hash ) or return;
    };
d147 1
a147 1
    my $obj = $class->new( %$href, _id => $self->_id );
d149 2
a150 2
    ### Every module get's stored as a module object ###
    $self->module_tree->{ $href->{module} } = $obj or return;
d152 2
a153 1
    return $obj;
@


1.2
log
@merge in perl 5.12.2 plus local changes
@
text
@d25 1
a25 1
=head1 NAME 
d39 1
a39 1
    
d47 1
a47 1
    
d49 1
a49 1
    
d56 1
a56 1
    
d59 1
a59 1
    
d61 1
a61 1
        $self->_atree( $stored->{_atree} || {} );                    
d74 1
a74 1
    
d82 1
a82 1
        {   local $Params::Check::ALLOW_UNKNOWN = 1;    
d85 1
a85 1
        
d91 1
a91 1
    
d94 1
a94 1
    
d99 1
a99 1
    }        
d105 1
a105 1
    
d109 1
a109 1
        map { $_ => { required => 1 } } 
d117 1
a117 1
    
d119 1
a119 1
    
d129 1
a129 1
    my $class;    
d132 1
a132 1
        map { $_ => { required => 1 } } 
d140 1
a140 1
    
d142 1
a142 1
    
d146 1
a146 1
    return $obj;    
d152 1
a152 1
    );        
d156 1
a156 1
        
d158 1
a158 1
        
d163 1
a163 1
        
d175 3
a177 3
        
            my $args = check( $tmpl, \%hash ) or return;            
        
d185 2
a186 2
            }        
        
a193 2
=head1 SYNOPSIS

d346 1
a346 1
    
d354 1
a354 1
            $Storable::VERSION              #the version of storable 
@


1.1
log
@Initial revision
@
text
@d194 2
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d25 1
a25 1
=head1 NAME
d39 1
a39 1

d47 1
a47 1

d49 1
a49 1

d56 1
a56 1

d59 1
a59 1

d61 1
a61 1
        $self->_atree( $stored->{_atree} || {} );
d74 1
a74 1

d82 1
a82 1
        {   local $Params::Check::ALLOW_UNKNOWN = 1;
d85 1
a85 1

d91 1
a91 1

d94 1
a94 1

d99 1
a99 1
    }
d105 1
a105 1

d109 1
a109 1
        map { $_ => { required => 1 } }
d117 1
a117 1

d119 1
a119 1

d129 1
a129 1
    my $class;
d132 1
a132 1
        map { $_ => { required => 1 } }
d140 1
a140 1

d142 1
a142 1

d146 1
a146 1
    return $obj;
d152 1
a152 1
    );
d156 1
a156 1

d158 1
a158 1

d163 1
a163 1

d175 3
a177 3

            my $args = check( $tmpl, \%hash ) or return;

d185 2
a186 2
            }

d346 1
a346 1

d354 1
a354 1
            $Storable::VERSION              #the version of storable
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a1 1
use deprecate;
a22 3
use vars qw[$VERSION];
$VERSION = "0.9135";

d125 5
a129 1
{
d131 3
a133 4
        class => { default => 'CPANPLUS::Module' },
        map { $_ => { required => 1 } } qw[
           module version path comment author package description dslip mtime
        ],
d136 4
a139 3
    sub _add_module_object {
        my $self = shift;
        my %hash = @@_;
d141 1
a141 5
        my $href = do {
            local $Params::Check::SANITY_CHECK_TEMPLATE = 0;
            check( $tmpl, \%hash ) or return;
        };
        my $class = delete $href->{class};
d143 2
a144 1
        my $obj = $class->new( %$href, _id => $self->_id );
d146 1
a146 5
        ### Every module get's stored as a module object ###
        $self->module_tree->{ $href->{module} } = $obj or return;

        return $obj;
    }
@


