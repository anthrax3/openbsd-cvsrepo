head	1.2;
access;
symbols
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2014.11.17.20.56.57;	author afresh1;	state dead;
branches;
next	1.1;
commitid	QP75iYx42Uo7mMxO;

1.1
date	2010.09.24.14.49.03;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.03;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.06.57;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.50;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@package CPANPLUS::Internals::Source::SQLite::Tie;

use strict;
use warnings;

use CPANPLUS::Error;
use CPANPLUS::Module;
use CPANPLUS::Module::Fake;
use CPANPLUS::Module::Author::Fake;
use CPANPLUS::Internals::Constants;


use Params::Check               qw[check];
use Module::Load::Conditional   qw[can_load];
use Locale::Maketext::Simple    Class => 'CPANPLUS', Style => 'gettext';


use Data::Dumper;
$Data::Dumper::Indent = 1;

require Tie::Hash;
use vars qw[@@ISA];
push @@ISA, 'Tie::StdHash';


sub TIEHASH {
    my $class = shift;
    my %hash  = @@_;
    
    my $tmpl = {
        dbh     => { required => 1 },
        table   => { required => 1 },
        key     => { required => 1 },
        cb      => { required => 1 },
        offset  => { default  => 0 },
    };
    
    my $args = check( $tmpl, \%hash ) or return;
    my $obj  = bless { %$args, store => {} } , $class;

    return $obj;
}    

sub FETCH {
    my $self    = shift;
    my $key     = shift or return;
    my $dbh     = $self->{dbh};
    my $cb      = $self->{cb};
    my $table   = $self->{table};
    
    
    ### did we look this one up before?
    if( my $obj = $self->{store}->{$key} ) {
        return $obj;
    }
    
    my $res  = $dbh->query(
                    "SELECT * from $table where $self->{key} = ?", $key
                ) or do {
                    error( $dbh->error );
                    return;
                };
                    
    my $href = $res->hash;
    
    ### get rid of the primary key
    delete $href->{'id'};
    
    ### no results?
    return unless keys %$href;
    
    ### expand author if needed
    ### XXX no longer generic :(
    if( $table eq 'module' ) {
        $href->{author} = $cb->author_tree( $href->{author } ) or return;
    }

    my $class = {
        module  => 'CPANPLUS::Module',
        author  => 'CPANPLUS::Module::Author',
    }->{ $table };

    my $obj = $self->{store}->{$key} = $class->new( %$href, _id => $cb->_id );   
    
    return $obj;
}

sub STORE { 
    my $self = shift;
    my $key  = shift;
    my $val  = shift;
    
    $self->{store}->{$key} = $val;
}

1;

sub FIRSTKEY {
    my $self = shift;
    my $dbh  = $self->{'dbh'};

    my $res  = $dbh->query(
                    "select $self->{key} from $self->{table} order by $self->{key} limit 1"
               );

    $self->{offset} = 0;
    
    my $key = $res->flat->[0];

    return $key;
}

sub NEXTKEY {
    my $self = shift;
    my $dbh  = $self->{'dbh'};

    my $res  = $dbh->query(
                    "select $self->{key} from $self->{table} ".
                    "order by $self->{key} limit 1 offset $self->{offset}"
               );

    $self->{offset} +=1;

    my $key = $res->flat->[0];
    my $val = $self->FETCH( $key );

    ### use each() semantics
    return wantarray ? ( $key, $val ) : $key;
}

sub EXISTS   { !!$_[0]->FETCH( $_[1] ) }

sub SCALAR   { 
    my $self = shift;
    my $dbh  = $self->{'dbh'};

    my $res  = $dbh->query( "select count(*) from $self->{table}" );

    return $res->flat;
}

### intentionally left blank
sub DELETE   {  }
sub CLEAR    {  }

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d29 1
a29 1

d37 1
a37 1

d42 1
a42 1
}
d50 2
a51 2


d56 1
a56 1

d63 1
a63 1

d65 1
a65 1

d68 1
a68 1

d71 1
a71 1

d83 2
a84 2
    my $obj = $self->{store}->{$key} = $class->new( %$href, _id => $cb->_id );

d88 1
a88 1
sub STORE {
d92 1
a92 1

d107 1
a107 1

d133 1
a133 1
sub SCALAR   {
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a1 1
use deprecate;
d12 1
d17 3
a19 2
use vars qw[@@ISA $VERSION];
$VERSION = "0.9135";
d22 1
@


