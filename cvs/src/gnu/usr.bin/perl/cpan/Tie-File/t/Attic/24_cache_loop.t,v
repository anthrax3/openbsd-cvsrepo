head	1.2;
access;
symbols
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2013.03.25.20.40.52;	author sthen;	state dead;
branches;
next	1.1;

1.1
date	2010.09.24.14.48.59;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.59;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@#!/usr/bin/perl
#
# Tests for various caching errors
#

use Config;
my $file = "tf$$.txt";
unless ($Config{d_alarm}) {
  print "1..0\n"; exit;
}

$: = Tie::File::_default_recsep();
my $data = join $:, "record0" .. "record9", "";
my $V = $ENV{INTEGRITY};        # Verbose integrity checking?

print "1..3\n";

my $N = 1;
use Tie::File;
print "ok $N\n"; $N++;

open F, "> $file" or die $!;
binmode F;
print F $data;
close F;

# Limit cache size to 30 bytes 
my $MAX = 30;
#  -- that's enough space for 3 records, but not 4, on both \n and \r\n systems
my $o = tie @@a, 'Tie::File', $file, memory => $MAX, autodefer => 1;
print $o ? "ok $N\n" : "not ok $N\n";
$N++;

# (3) In 0.50 this goes into an infinite loop.  Explanation:
#
#   Suppose you overfill the defer buffer by so much that the memory
#   limit is also exceeded.  You'll go into _splice to prepare to
#   write out the defer buffer, and _splice will call _fetch, which
#   will then try to flush the read cache---but the read cache is
#   already empty, so you're stuck in an infinite loop.
#
# Five seconds should be plenty of time for it to complete if it works.
alarm 5 unless $^P;
@@a = "record0" .. "record9";
print "ok 3\n";
alarm 0;

END {
  undef $o;
  untie @@a;
  1 while unlink $file;
}



@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@
