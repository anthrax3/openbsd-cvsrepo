head	1.2;
access;
symbols
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2014.11.17.20.56.55;	author afresh1;	state dead;
branches;
next	1.1;
commitid	QP75iYx42Uo7mMxO;

1.1
date	2010.09.24.14.49.04;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.04;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.06.43;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.48;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@BEGIN { 
    if( $ENV{PERL_CORE} ) {
        chdir '../lib/Archive/Extract' if -d '../lib/Archive/Extract';
        unshift @@INC, '../../..', '../../../..';
    }
}    

BEGIN { chdir 't' if -d 't' };
BEGIN { mkdir 'out' unless -d 'out' };

### left behind, at least on Win32. See core patch #31904
END   { rmtree('out') };        

use strict;
use lib qw[../lib];

use constant IS_WIN32   => $^O eq 'MSWin32' ? 1 : 0;
use constant IS_CYGWIN  => $^O eq 'cygwin'  ? 1 : 0;
use constant IS_VMS     => $^O eq 'VMS'     ? 1 : 0;

use Cwd                         qw[cwd];
use Test::More                  qw[no_plan];
use File::Spec;
use File::Spec::Unix;
use File::Path;
use Data::Dumper;
use File::Basename              qw[basename];
use Module::Load::Conditional   qw[check_install];

### uninitialized value in File::Spec warnings come from A::Zip:
# t/01_Archive-Extract....ok 135/0Use of uninitialized value in concatenation (.) or string at /opt/lib/perl5/5.8.3/File/Spec/Unix.pm line 313.
#         File::Spec::Unix::catpath('File::Spec','','','undef') called at /opt/lib/perl5/site_perl/5.8.3/Archive/Zip.pm line 473
#         Archive::Zip::_asLocalName('') called at /opt/lib/perl5/site_perl/5.8.3/Archive/Zip.pm line 652
#         Archive::Zip::Archive::extractMember('Archive::Zip::Archive=HASH(0x9679c8)','Archive::Zip::ZipFileMember=HASH(0x9678fc)') called at ../lib/Archive/Extract.pm line 753
#         Archive::Extract::_unzip_az('Archive::Extract=HASH(0x966eac)') called at ../lib/Archive/Extract.pm line 674
#         Archive::Extract::_unzip('Archive::Extract=HASH(0x966eac)') called at ../lib/Archive/Extract.pm line 275
#         Archive::Extract::extract('Archive::Extract=HASH(0x966eac)','to','/Users/kane/sources/p4/other/archive-extract/t/out') called at t/01_Archive-Extract.t line 180
#BEGIN { $SIG{__WARN__} = sub { require Carp; Carp::cluck(@@_) } };

if ((IS_WIN32 or IS_CYGWIN) && ! $ENV{PERL_CORE}) {
    diag( "Older versions of Archive::Zip may cause File::Spec warnings" );
    diag( "See bug #19713 in rt.cpan.org. It is safe to ignore them" );
}

my $Me      = basename( $0 );
my $Class   = 'Archive::Extract';

use_ok($Class);

### debug will always be enabled on dev versions
my $Debug   = (not $ENV{PERL_CORE} and 
              ($ARGV[0] or $Archive::Extract::VERSION =~ /_/))
                ? 1 
                : 0;

my $Self    = File::Spec->rel2abs( 
                    IS_WIN32 ? &Win32::GetShortPathName( cwd() ) : cwd() 
                );
my $SrcDir  = File::Spec->catdir( $Self,'src' );
my $OutDir  = File::Spec->catdir( $Self,'out' );

### stupid stupid silly stupid warnings silly! ###
$Archive::Extract::DEBUG    = $Archive::Extract::DEBUG  = $Debug;
$Archive::Extract::WARN     = $Archive::Extract::WARN   = $Debug;

diag( "\n\n*** DEBUG INFORMATION ENABLED ***\n\n" ) if $Debug;

# Be as evil as possible to print
$\ = "ORS_FLAG";
$, = "OFS_FLAG";
$" = "LISTSEP_FLAG";

my $tmpl = {
    ### plain files
    'x.bz2' => {    programs    => [qw[bunzip2]],
                    modules     => [qw[IO::Uncompress::Bunzip2]],
                    method      => 'is_bz2',
                    outfile     => 'a',
                },
    'x.tgz' => {    programs    => [qw[gzip tar]],
                    modules     => [qw[Archive::Tar IO::Zlib]],
                    method      => 'is_tgz',
                    outfile     => 'a',
                },
    'x.tar.gz' => { programs    => [qw[gzip tar]],
                    modules     => [qw[Archive::Tar IO::Zlib]],
                    method      => 'is_tgz',
                    outfile     => 'a',
                },
    'x.tar' => {    programs    => [qw[tar]],
                    modules     => [qw[Archive::Tar]],
                    method      => 'is_tar',
                    outfile     => 'a',
                },
    'x.gz'  => {    programs    => [qw[gzip]],
                    modules     => [qw[Compress::Zlib]],
                    method      => 'is_gz',
                    outfile     => 'a',
                },
    'x.Z'   => {    programs    => [qw[uncompress]],
                    modules     => [qw[Compress::Zlib]],
                    method      => 'is_Z',
                    outfile     => 'a',
                },
    'x.zip' => {    programs    => [qw[unzip]],
                    modules     => [qw[Archive::Zip]],
                    method      => 'is_zip',
                    outfile     => 'a',
                },
    'x.jar' => {    programs    => [qw[unzip]],
                    modules     => [qw[Archive::Zip]],
                    method      => 'is_zip',
                    outfile     => 'a',
                },                
    'x.par' => {    programs    => [qw[unzip]],
                    modules     => [qw[Archive::Zip]],
                    method      => 'is_zip',
                    outfile     => 'a',
                },                
    'x.lzma' => {   programs    => [qw[unlzma]],
                    modules     => [qw[Compress::unLZMA]],
                    method      => 'is_lzma',
                    outfile     => 'a',
                },
    ### with a directory
    'y.tbz'     => {    programs    => [qw[bunzip2 tar]],
                        modules     => [qw[Archive::Tar 
                                           IO::Uncompress::Bunzip2]],
                        method      => 'is_tbz',
                        outfile     => 'z',
                        outdir      => 'y',
                    },
    'y.tar.bz2' => {    programs    => [qw[bunzip2 tar]],
                        modules     => [qw[Archive::Tar 
                                           IO::Uncompress::Bunzip2]],
                        method      => 'is_tbz',
                        outfile     => 'z',
                        outdir      => 'y'
                    },    
    'y.tgz'     => {    programs    => [qw[gzip tar]],
                        modules     => [qw[Archive::Tar IO::Zlib]],
                        method      => 'is_tgz',
                        outfile     => 'z',
                        outdir      => 'y'
                    },
    'y.tar.gz' => {     programs    => [qw[gzip tar]],
                        modules     => [qw[Archive::Tar IO::Zlib]],
                        method      => 'is_tgz',
                        outfile     => 'z',
                        outdir      => 'y'
                    },
    'y.tar' => {    programs    => [qw[tar]],
                    modules     => [qw[Archive::Tar]],
                    method      => 'is_tar',
                    outfile     => 'z',
                    outdir      => 'y'
                },
    'y.zip' => {    programs    => [qw[unzip]],
                    modules     => [qw[Archive::Zip]],
                    method      => 'is_zip',
                    outfile     => 'z',
                    outdir      => 'y'
                },
    'y.par' => {    programs    => [qw[unzip]],
                    modules     => [qw[Archive::Zip]],
                    method      => 'is_zip',
                    outfile     => 'z',
                    outdir      => 'y'
                },
    'y.jar' => {    programs    => [qw[unzip]],
                    modules     => [qw[Archive::Zip]],
                    method      => 'is_zip',
                    outfile     => 'z',
                    outdir      => 'y'
                },
    ### with non-same top dir
    'double_dir.zip' => {
                    programs    => [qw[unzip]],
                    modules     => [qw[Archive::Zip]],
                    method      => 'is_zip',
                    outfile     => 'w',
                    outdir      => 'x'
                },
};

### XXX special case: on older solaris boxes (8),
### bunzip2 is version 0.9.x. Older versions (pre 1),
### only extract files that end in .bz2, and nothing
### else. So remove that test case if we have an older
### bunzip2 :(
{   if( $Class->have_old_bunzip2 ) {
        delete $tmpl->{'y.tbz'};
        diag "Old bunzip2 detected, skipping .tbz test";
    }
}    

### show us the tools IPC::Cmd will use to run binary programs
if( $Debug ) {
    diag( "IPC::Run enabled: $IPC::Cmd::USE_IPC_RUN " );
    diag( "IPC::Run available: " . IPC::Cmd->can_use_ipc_run );
    diag( "IPC::Run vesion: $IPC::Run::VERSION" );
    diag( "IPC::Open3 enabled: $IPC::Cmd::USE_IPC_OPEN3 " );
    diag( "IPC::Open3 available: " . IPC::Cmd->can_use_ipc_open3 );
    diag( "IPC::Open3 vesion: $IPC::Open3::VERSION" );
}

### test all type specifications to new()
### this tests bug #24578: Wrong check for `type' argument
{   my $meth = 'types';

    can_ok( $Class, $meth );

    my @@types = $Class->$meth;
    ok( scalar(@@types),         "   Got a list of types" );
    
    for my $type ( @@types ) {
        my $obj = $Class->new( archive => $Me, type => $type );
        ok( $obj,               "   Object created based on '$type'" );
        ok( !$obj->error,       "       No error logged" );
    }
    
    ### test unknown type
    {   ### must turn on warnings to catch error here
        local $Archive::Extract::WARN = 1;
        
        my $warnings;
        local $SIG{__WARN__} = sub { $warnings .= "@@_" };
        
        my $ae = $Class->new( archive => $Me );
        ok( !$ae,               "   No archive created based on '$Me'" );
        ok( !$Class->error,     "       Error not captured in class method" );
        ok( $warnings,          "       Error captured as warning" );
        like( $warnings, qr/Cannot determine file type for/,
                                "           Error is: unknown file type" );
    }                                
}    

### test multiple errors
### XXX whitebox test
{   ### grab a random file from the template, so we can make an object
    my $ae = Archive::Extract->new( 
                archive =>  File::Spec->catfile($SrcDir,[keys %$tmpl]->[0]) 
             );
    ok( $ae,                    "Archive created" );
    ok( not($ae->error),        "   No errors yet" );

    ### log a few errors
    {   local $Archive::Extract::WARN = 0;
        $ae->_error( $_ ) for 1..5;
    }

    my $err = $ae->error;
    ok( $err,                   "   Errors retrieved" );
    
    my $expect = join $/, 1..5;
    is( $err, $expect,          "       As expected" );

    ### this resets the errors
    ### override the 'check' routine to return false, so we bail out of 
    ### extract() early and just run the error reset code;
    {   no warnings qw[once redefine];
        local *Archive::Extract::check = sub { return }; 
        $ae->extract;
    }
    ok( not($ae->error),        "   Errors erased after ->extract() call" );
}

### XXX whitebox test
### test __get_extract_dir 
SKIP: {   my $meth = '__get_extract_dir';

    ### get the right separator -- File::Spec does clean ups for
    ### paths, so we need to join ourselves.
    my $sep  = [ split '', File::Spec->catfile( 'a', 'b' ) ]->[1];
    
    ### bug #23999: Attempt to generate Makefile.PL gone awry
    ### showed that dirs in the style of './dir/' were reported
    ### to be unpacked in '.' rather than in 'dir'. here we test
    ### for this.
    for my $prefix ( '', '.' ) {
        skip "Prepending ./ to a valid path doesn't give you another valid path on VMS", 2
            if IS_VMS && length($prefix);

        my $dir = basename( $SrcDir );

        ### build a list like [dir, dir/file] and [./dir ./dir/file]
        ### where the dir and file actually exist, which is important
        ### for the method call
        my @@files = map { length $prefix 
                                ? join $sep, $prefix, $_
                                : $_
                      } $dir, File::Spec->catfile( $dir, [keys %$tmpl]->[0] );
        
        my $res = $Class->$meth( \@@files );
        $res = &Win32::GetShortPathName( $res ) if IS_WIN32;

        ok( $res,               "Found extraction dir '$res'" );
        is( $res, $SrcDir,      "   Is expected dir '$SrcDir'" );
    }        
}

### configuration to run in: allow perl or allow binaries
for my $switch ( [0,1], [1,0] ) {
    my $cfg = "PP: $switch->[0] Bin: $switch->[1]";

    local $Archive::Extract::_ALLOW_PURE_PERL   = $switch->[0];
    local $Archive::Extract::_ALLOW_BIN         = $switch->[1];
    
    diag("Running extract with configuration: $cfg") if $Debug;

    for my $archive (keys %$tmpl) {

        ### check first if we can do the proper

        my $ae = Archive::Extract->new(
                        archive => File::Spec->catfile($SrcDir,$archive) );

        ### Do an extra run with _ALLOW_TAR_ITER = 0 if it's a tar file of some
        ### sort
        my @@with_tar_iter = ( 1 );
        push @@with_tar_iter, 0 if grep { $ae->$_ } qw[is_tbz is_tgz is_tar];

        for my $tar_iter (@@with_tar_iter) { SKIP: {

            ### Doesn't matter unless .tar, .tbz, .tgz
            local $Archive::Extract::_ALLOW_TAR_ITER = $tar_iter; 
        
            diag("Archive::Tar->iter: $tar_iter") if $Debug;

            isa_ok( $ae, $Class );

            my $method = $tmpl->{$archive}->{method};
            ok( $ae->$method(),         "Archive type recognized properly" );

        
            my $file        = $tmpl->{$archive}->{outfile};
            my $dir         = $tmpl->{$archive}->{outdir};  # can be undef
            my $rel_path    = File::Spec->catfile( grep { defined } $dir, $file );
            my $abs_path    = File::Spec->catfile( $OutDir, $rel_path );
            my $abs_dir     = File::Spec->catdir( 
                                grep { defined } $OutDir, $dir );
            my $nix_path    = File::Spec::Unix->catfile(
                                grep { defined } $dir, $file );

            ### check if we can run this test ###
            my $pgm_fail; my $mod_fail;
            for my $pgm ( @@{$tmpl->{$archive}->{programs}} ) {
                ### no binary extract method
                $pgm_fail++, next unless $pgm;

                ### we dont have the program
                $pgm_fail++ unless $Archive::Extract::PROGRAMS->{$pgm} &&
                                   $Archive::Extract::PROGRAMS->{$pgm};

            }

            for my $mod ( @@{$tmpl->{$archive}->{modules}} ) {
                ### no module extract method
                $mod_fail++, next unless $mod;

                ### we dont have the module
                $mod_fail++ unless check_install( module => $mod );
            }

            ### where to extract to -- try both dir and file for gz files
            ### XXX test me!
            #my @@outs = $ae->is_gz ? ($abs_path, $OutDir) : ($OutDir);
            my @@outs = $ae->is_gz || $ae->is_bz2 || $ae->is_Z || $ae->is_lzma
                            ? ($abs_path) 
                            : ($OutDir);

            ### 10 tests from here on down ###
            if( ($mod_fail && ($pgm_fail || !$Archive::Extract::_ALLOW_BIN))
                ||
                ($pgm_fail && ($mod_fail || !$Archive::Extract::_ALLOW_PURE_PERL))
            ) {                
                skip "No binaries or modules to extract ".$archive, 
                    (10 * scalar @@outs);
            }

            ### we dont warnings spewed about missing modules, that might
            ### be a problem...
            local $IPC::Cmd::WARN = 0;
            local $IPC::Cmd::WARN = 0;
            
            for my $use_buffer ( IPC::Cmd->can_capture_buffer , 0 ) {

                ### test buffers ###
                my $turn_off = !$use_buffer && !$pgm_fail &&
                                $Archive::Extract::_ALLOW_BIN;

                ### whitebox test ###
                ### stupid warnings ###
                local $IPC::Cmd::USE_IPC_RUN    = 0 if $turn_off;
                local $IPC::Cmd::USE_IPC_RUN    = 0 if $turn_off;
                local $IPC::Cmd::USE_IPC_OPEN3  = 0 if $turn_off;
                local $IPC::Cmd::USE_IPC_OPEN3  = 0 if $turn_off;


                ### try extracting ###
                for my $to ( @@outs ) {

                    diag("Extracting to: $to")                  if $Debug;
                    diag("Buffers enabled: ".!$turn_off)        if $Debug;
      
                    my $rv = $ae->extract( to => $to );
        
                    SKIP: {
                        my $re  = qr/^No buffer captured/;
                        my $err = $ae->error || '';
                  
                        ### skip buffer tests if we dont have buffers or
                        ### explicitly turned them off
                        skip "No buffers available", 8
                            if ( $turn_off || !IPC::Cmd->can_capture_buffer)
                                && $err =~ $re;

                        ### skip tests if we dont have an extractor
                        skip "No extractor available", 8 
                            if $err =~ /Extract failed; no extractors available/;
                            
                        ### win32 + bin utils is notorious, and none of them are
                        ### officially supported by strawberry. So if we 
                        ### encounter an error while extracting whlie running 
                        ### with $PREFER_BIN on win32, just skip the tests.
                        ### See rt#46948: unable to install install on win32
                        ### for details on the pain
                        skip "Binary tools on Win32 are very unreliable", 8
                            if $err and $Archive::Extract::_ALLOW_BIN 
                                    and IS_WIN32;
        
                        ok( $rv, "extract() for '$archive' reports success ($cfg)");
        
                        diag("Extractor was: " . $ae->_extractor)   if $Debug;
        
                        ### if we /should/ have buffers, there should be
                        ### no errors complaining we dont have them...
                        unlike( $err, $re,
                                        "No errors capturing buffers" );
        
                        ### might be 1 or 2, depending wether we extracted 
                        ### a dir too
                        my $files    = $ae->files || [];
                        my $file_cnt = grep { defined } $file, $dir;
                        is( scalar @@$files, $file_cnt,
                                        "Found correct number of output files (@@$files)" );
                        
                        ### due to prototypes on is(), if there's no -1 index on
                        ### the array ref, it'll give a fatal exception:
                        ### "Modification of non-creatable array value attempted,
                        ### subscript -1 at -e line 1." So wrap it in do { }
                        is( do { $files->[-1] }, $nix_path,
                                        "Found correct output file '$nix_path'" );
        
                        ok( -e $abs_path,
                                        "Output file '$abs_path' exists" );
                        ok( $ae->extract_path,
                                        "Extract dir found" );
                        ok( -d $ae->extract_path,
                                        "Extract dir exists" );
                        is( $ae->extract_path, $abs_dir,
                                        "Extract dir is expected '$abs_dir'" );
                    }

                    SKIP: {
                        skip "Unlink tests are unreliable on Win32", 3 if IS_WIN32;

                        1 while unlink $abs_path;
                        ok( !(-e $abs_path), "Output file successfully removed" );
            
                        SKIP: {
                            skip "No extract path captured, can't remove paths", 2
                                unless $ae->extract_path;
            
                            ### if something went wrong with determining the out
                            ### path, don't go deleting stuff.. might be Really Bad
                            my $out_re = quotemeta( $OutDir );
                            
                            ### VMS directory layout is different. Craig Berry
                            ### explains:
                            ### the test is trying to determine if C</disk1/foo/bar>
                            ### is part of C</disk1/foo/bar/baz>.  Except in VMS
                            ### syntax, that would mean trying to determine whether
                            ### C<disk1:[foo.bar]> is part of C<disk1:[foo.bar.baz]>
                            ### Because we have both a directory delimiter
                            ### (dot) and a directory spec terminator (right 
                            ### bracket), we have to trim the right bracket from 
                            ### the first one to make it successfully match the
                            ### second one.  Since we're asserting the same truth --
                            ### that one path spec is the leading part of the other
                            ### -- it seems to me ok to have this in the test only.
                            ### 
                            ### so we strip the ']' of the back of the regex
                            $out_re =~ s/\\\]// if IS_VMS; 
                            
                            if( $ae->extract_path !~ /^$out_re/ ) {   
                                ok( 0, "Extractpath WRONG (".$ae->extract_path.")"); 
                                skip(  "Unsafe operation -- skip cleanup!!!" ), 1;
                            }                    
            
                            eval { rmtree( $ae->extract_path ) }; 
                            ok( !$@@,        "   rmtree gave no error" );
                            ok( !(-d $ae->extract_path ),
                                            "   Extract dir succesfully removed" );
                        }
                    }
                }
            }
        } }
    }
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d1 7
d114 1
a114 11
                }, 
    'x.ear' => {    programs    => [qw[unzip]],
                    modules     => [qw[Archive::Zip]],
                    method      => 'is_zip',
                    outfile     => 'a',
                },
    'x.war' => {    programs    => [qw[unzip]],
                    modules     => [qw[Archive::Zip]],
                    method      => 'is_zip',
                    outfile     => 'a',
                },               
a124 17
    'x.xz'   => {   programs    => [qw[unxz]],
                    modules     => [qw[IO::Uncompress::UnXz]],
                    method      => 'is_xz',
                    outfile     => 'a',
                },
    'x.txz'  => {   programs    => [qw[unxz tar]],
                    modules     => [qw[Archive::Tar
                                           IO::Uncompress::UnXz]],
                    method      => 'is_txz',
                    outfile     => 'a',
                },
    'x.tar.xz'=> {  programs    => [qw[unxz tar]],
                    modules     => [qw[Archive::Tar
                                           IO::Uncompress::UnXz]],
                    method      => 'is_txz',
                    outfile     => 'a',
                },
a139 14
    'y.txz'     => {    programs    => [qw[unxz tar]],
                        modules     => [qw[Archive::Tar 
                                           IO::Uncompress::UnXz]],
                        method      => 'is_txz',
                        outfile     => 'z',
                        outdir      => 'y',
                    },
    'y.tar.xz'  => {    programs    => [qw[unxz tar]],
                        modules     => [qw[Archive::Tar 
                                           IO::Uncompress::UnXz]],
                        method      => 'is_txz',
                        outfile     => 'z',
                        outdir      => 'y'
                    },    
a175 12
    'y.ear' => {    programs    => [qw[unzip]],
                    modules     => [qw[Archive::Zip]],
                    method      => 'is_zip',
                    outfile     => 'z',
                    outdir      => 'y'
                },
    'y.war' => {    programs    => [qw[unzip]],
                    modules     => [qw[Archive::Zip]],
                    method      => 'is_zip',
                    outfile     => 'z',
                    outdir      => 'y'
              },
a311 1
        diag("Archive : $archive") if $Debug;
d321 1
a321 1
        push @@with_tar_iter, 0 if grep { $ae->$_ } qw[is_tbz is_tgz is_txz is_tar];
d325 1
a325 1
            ### Doesn't matter unless .tar, .tbz, .tgz, .txz
d333 2
a334 1
            ok( $ae->$method(),         "Archive type $method recognized properly" );
d368 1
a368 1
            my @@outs = $ae->is_gz || $ae->is_bz2 || $ae->is_Z || $ae->is_lzma || $ae->is_xz
d424 1
a424 1
                        ### encounter an error while extracting while running
d441 1
a441 1
                        ### might be 1 or 2, depending whether we extracted
d504 1
a504 1
                                            "   Extract dir successfully removed" );
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d5 1
a5 1
END   { rmtree('out') };
d44 1
a44 1
my $Debug   = (not $ENV{PERL_CORE} and
d46 1
a46 1
                ? 1
d49 2
a50 2
my $Self    = File::Spec->rel2abs(
                    IS_WIN32 ? &Win32::GetShortPathName( cwd() ) : cwd()
d107 1
a107 1
                },
d117 1
a117 1
                },
d122 1
a122 1
                },
d147 1
a147 1
                        modules     => [qw[Archive::Tar
d154 1
a154 1
                        modules     => [qw[Archive::Tar
d159 1
a159 1
                    },
d161 1
a161 1
                        modules     => [qw[Archive::Tar
d168 1
a168 1
                        modules     => [qw[Archive::Tar
d173 1
a173 1
                    },
d241 1
a241 1
}
d261 1
a261 1

d267 1
a267 1

d271 1
a271 1

d274 1
a274 1

d281 2
a282 2
    }
}
d287 2
a288 2
    my $ae = Archive::Extract->new(
                archive =>  File::Spec->catfile($SrcDir,[keys %$tmpl]->[0])
d300 1
a300 1

d305 1
a305 1
    ### override the 'check' routine to return false, so we bail out of
d308 1
a308 1
        local *Archive::Extract::check = sub { return };
d315 1
a315 1
### test __get_extract_dir
d321 1
a321 1

d335 1
a335 1
        my @@files = map { length $prefix
d339 1
a339 1

d345 1
a345 1
    }
d354 1
a354 1

d373 2
a374 2
            local $Archive::Extract::_ALLOW_TAR_ITER = $tar_iter;

d381 1
a381 1

d386 1
a386 1
            my $abs_dir     = File::Spec->catdir(
d415 1
a415 1
                            ? ($abs_path)
d422 2
a423 2
            ) {
                skip "No binaries or modules to extract ".$archive,
d431 1
a431 1

d451 1
a451 1

d453 1
a453 1

d457 1
a457 1

d465 1
a465 1
                        skip "No extractor available", 8
d467 1
a467 1

d469 1
a469 1
                        ### officially supported by strawberry. So if we
d475 1
a475 1
                            if $err and $Archive::Extract::_ALLOW_BIN
d477 1
a477 1

d479 1
a479 1

d481 1
a481 1

d486 1
a486 1

d493 1
a493 1

d500 1
a500 1

d516 1
a516 1

d520 1
a520 1

d524 1
a524 1

d532 2
a533 2
                            ### (dot) and a directory spec terminator (right
                            ### bracket), we have to trim the right bracket from
d538 1
a538 1
                            ###
d540 4
a543 4
                            $out_re =~ s/\\\]// if IS_VMS;

                            if( $ae->extract_path !~ /^$out_re/ ) {
                                ok( 0, "Extractpath WRONG (".$ae->extract_path.")");
d545 3
a547 3
                            }

                            eval { rmtree( $ae->extract_path ) };
@


