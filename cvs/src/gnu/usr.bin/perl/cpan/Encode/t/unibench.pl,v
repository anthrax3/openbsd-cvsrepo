head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.30
	OPENBSD_6_2_BASE:1.1.1.1
	PERL_5_24_2:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.28
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.26
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.20
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.22
	OPENBSD_5_8_BASE:1.1.1.1
	PERL_5_20_2:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.14
	OPENBSD_5_7_BASE:1.1.1.1
	PERL_5_20_1:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.18
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.16
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.12
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2010.09.24.14.49.00;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.00;	author millert;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl

use strict;
use Encode;
use Benchmark qw(:all);

my $Count = shift @@ARGV;
$Count ||= 16;
my @@sizes = @@ARGV || (1, 4, 16);

my %utf8_seed;
for my $i (0x00..0xff){
    my $c = chr($i);
    $utf8_seed{BMP} .= ($c =~ /^\p{IsPrint}/o) ? $c : " ";
}
utf8::upgrade($utf8_seed{BMP});

for my $i (0x00..0xff){
    my $c = chr(0x10000+$i);
    $utf8_seed{HIGH} .= ($c =~ /^\p{IsPrint}/o) ? $c : " ";
}
utf8::upgrade($utf8_seed{HIGH});

my %S;
for my $i (@@sizes){
    my $sz = 256 * $i;
    for my $cp (qw(BMP HIGH)){
    $S{utf8}{$sz}{$cp}  = $utf8_seed{$cp} x $i;
    $S{utf16}{$sz}{$cp} = encode('UTF-16BE', $S{utf8}{$sz}{$cp});
    }
}

for my $i (@@sizes){
    my $sz = $i * 256;
    my $count = $Count * int(256/$i);
    for my $cp (qw(BMP HIGH)){
    for my $op (qw(encode decode)){
        my ($meth, $from, $to) = ($op eq 'encode') ?
        (\&encode, 'utf8', 'utf16') : (\&decode, 'utf16', 'utf8');
        my $XS = sub {
        Encode::Unicode::set_transcoder("xs");  
        $meth->('UTF-16BE', $S{$from}{$sz}{$cp})
             eq $S{$to}{$sz}{$cp} 
             or die "$op,$from,$to,$sz,$cp";
        };
        my $modern = sub {
        Encode::Unicode::set_transcoder("modern");  
        $meth->('UTF-16BE', $S{$from}{$sz}{$cp})
             eq $S{$to}{$sz}{$cp} 
             or die "$op,$from,$to,$sz,$cp";
        };
        my $classic = sub {
        Encode::Unicode::set_transcoder("classic");  
        $meth->('UTF-16BE', $S{$from}{$sz}{$cp})
             eq $S{$to}{$sz}{$cp} or 
             die "$op,$from,$to,$sz,$cp";
        };
        print "---- $op length=$sz/range=$cp ----\n";
        my $r = timethese($count,
             {
              "XS"      => $XS,
              "Modern"  => $modern,
              "Classic" => $classic,
             },
             'none',
            );
        cmpthese($r);
    }
    }
}
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@
