head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.4
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.5.0.10
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.4
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.2.0.10
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.8
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.6
date	2017.02.05.00.31.57;	author afresh1;	state Exp;
branches;
next	1.5;
commitid	cxJ08BvJA9Pt2PTM;

1.5
date	2014.11.17.20.56.59;	author afresh1;	state Exp;
branches;
next	1.4;
commitid	QP75iYx42Uo7mMxO;

1.4
date	2014.03.24.15.05.24;	author afresh1;	state Exp;
branches;
next	1.3;

1.3
date	2013.03.25.20.40.49;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2010.09.24.15.06.46;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.24.14.48.59;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.59;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.07.03;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.51;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.52.44;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.6
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@# $Id: encoding.pm,v 2.17 2015/09/15 13:53:27 dankogai Exp dankogai $
package encoding;
our $VERSION = sprintf "%d.%02d", q$Revision: 2.17 $ =~ /(\d+)/g;

use Encode;
use strict;
use warnings;

use constant {
    DEBUG => !!$ENV{PERL_ENCODE_DEBUG},
    HAS_PERLIO => eval { require PerlIO::encoding; PerlIO::encoding->VERSION(0.02) },
    PERL_5_21_7 => $^V && $^V ge v5.21.7,
};

sub _exception {
    my $name = shift;
    $] > 5.008 and return 0;    # 5.8.1 or higher then no
    my %utfs = map { $_ => 1 }
      qw(utf8 UCS-2BE UCS-2LE UTF-16 UTF-16BE UTF-16LE
      UTF-32 UTF-32BE UTF-32LE);
    $utfs{$name} or return 0;    # UTFs or no
    require Config;
    Config->import();
    our %Config;
    return $Config{perl_patchlevel} ? 0 : 1    # maintperl then no
}

sub in_locale { $^H & ( $locale::hint_bits || 0 ) }

sub _get_locale_encoding {
    my $locale_encoding;

    if ($^O eq 'MSWin32') {
        my @@tries = (
            # First try to get the OutputCP. This will work only if we
            # are attached to a console
            'Win32.pm' => 'Win32::GetConsoleOutputCP',
            'Win32/Console.pm' => 'Win32::Console::OutputCP',
            # If above failed, this means that we are a GUI app
            # Let's assume that the ANSI codepage is what matters
            'Win32.pm' => 'Win32::GetACP',
        );
        while (@@tries) {
            my $cp = eval {
                require $tries[0];
                no strict 'refs';
                &{$tries[1]}()
            };
            if ($cp) {
                if ($cp == 65001) { # Code page for UTF-8
                    $locale_encoding = 'UTF-8';
                } else {
                    $locale_encoding = 'cp' . $cp;
                }
                return $locale_encoding;
            }
            splice(@@tries, 0, 2)
        }
    }

    # I18N::Langinfo isn't available everywhere
    $locale_encoding = eval {
        require I18N::Langinfo;
        find_encoding(
            I18N::Langinfo::langinfo( I18N::Langinfo::CODESET() )
        )->name
    };
    return $locale_encoding if defined $locale_encoding;

    eval {
        require POSIX;
        # Get the current locale
        # Remember that MSVCRT impl is quite different from Unixes
        my $locale = POSIX::setlocale(POSIX::LC_CTYPE());
        if ( $locale =~ /^([^.]+)\.([^.@@]+)(?:@@.*)?$/ ) {
            my $country_language;
            ( $country_language, $locale_encoding ) = ( $1, $2 );

            # Could do more heuristics based on the country and language
            # since we have Locale::Country and Locale::Language available.
            # TODO: get a database of Language -> Encoding mappings
            # (the Estonian database at http://www.eki.ee/letter/
            # would be excellent!) --jhi
            if (lc($locale_encoding) eq 'euc') {
                if ( $country_language =~ /^ja_JP|japan(?:ese)?$/i ) {
                    $locale_encoding = 'euc-jp';
                }
                elsif ( $country_language =~ /^ko_KR|korean?$/i ) {
                    $locale_encoding = 'euc-kr';
                }
                elsif ( $country_language =~ /^zh_CN|chin(?:a|ese)$/i ) {
                    $locale_encoding = 'euc-cn';
                }
                elsif ( $country_language =~ /^zh_TW|taiwan(?:ese)?$/i ) {
                    $locale_encoding = 'euc-tw';
                }
                else {
                    require Carp;
                    Carp::croak(
                        "encoding: Locale encoding '$locale_encoding' too ambiguous"
                    );
                }
            }
        }
    };

    return $locale_encoding;
}

sub import {

    if ( ord("A") == 193 ) {
        require Carp;
        Carp::croak("encoding: pragma does not support EBCDIC platforms");
    }

    if ($] >= 5.017) {
	warnings::warnif("deprecated",
			 "Use of the encoding pragma is deprecated")
    }
    my $class = shift;
    my $name  = shift;
    if (!$name){
	require Carp;
        Carp::croak("encoding: no encoding specified.");
    }
    if ( $name eq ':_get_locale_encoding' ) {    # used by lib/open.pm
        my $caller = caller();
        {
            no strict 'refs';
            *{"${caller}::_get_locale_encoding"} = \&_get_locale_encoding;
        }
        return;
    }
    $name = _get_locale_encoding() if $name eq ':locale';
    my %arg = @@_;
    $name = $ENV{PERL_ENCODING} unless defined $name;
    my $enc = find_encoding($name);
    unless ( defined $enc ) {
        require Carp;
        Carp::croak("encoding: Unknown encoding '$name'");
    }
    $name = $enc->name;    # canonize
    unless ( $arg{Filter} ) {
        DEBUG and warn "_exception($name) = ", _exception($name);
        if (! _exception($name)) {
            if (!PERL_5_21_7) {
                ${^ENCODING} = $enc;
            }
            else {
                # Starting with 5.21.7, this pragma uses a shadow variable
                # designed explicitly for it, ${^E_NCODING}, to enforce
                # lexical scope; instead of ${^ENCODING}.
                $^H{'encoding'} = 1;
                ${^E_NCODING} = $enc;
            }
        }
        HAS_PERLIO or return 1;
    }
    else {
        defined( ${^ENCODING} ) and undef ${^ENCODING};
        undef ${^E_NCODING} if PERL_5_21_7;

        # implicitly 'use utf8'
        require utf8;      # to fetch $utf8::hint_bits;
        $^H |= $utf8::hint_bits;
        eval {
            require Filter::Util::Call;
            Filter::Util::Call->import;
            filter_add(
                sub {
                    my $status = filter_read();
                    if ( $status > 0 ) {
                        $_ = $enc->decode( $_, 1 );
                        DEBUG and warn $_;
                    }
                    $status;
                }
            );
        };
        $@@ eq '' and DEBUG and warn "Filter installed";
    }
    defined ${^UNICODE} and ${^UNICODE} != 0 and return 1;
    for my $h (qw(STDIN STDOUT)) {
        if ( $arg{$h} ) {
            unless ( defined find_encoding( $arg{$h} ) ) {
                require Carp;
                Carp::croak(
                    "encoding: Unknown encoding for $h, '$arg{$h}'");
            }
            eval { binmode( $h, ":raw :encoding($arg{$h})" ) };
        }
        else {
            unless ( exists $arg{$h} ) {
                eval {
                    no warnings 'uninitialized';
                    binmode( $h, ":raw :encoding($name)" );
                };
            }
        }
        if ($@@) {
            require Carp;
            Carp::croak($@@);
        }
    }
    return 1;    # I doubt if we need it, though
}

sub unimport {
    no warnings;
    undef ${^ENCODING};
    undef ${^E_NCODING} if PERL_5_21_7;
    if (HAS_PERLIO) {
        binmode( STDIN,  ":raw" );
        binmode( STDOUT, ":raw" );
    }
    else {
        binmode(STDIN);
        binmode(STDOUT);
    }
    if ( $INC{"Filter/Util/Call.pm"} ) {
        eval { filter_del() };
    }
}

1;
__END__

=pod

=head1 NAME

encoding - allows you to write your script in non-ASCII and non-UTF-8

=head1 WARNING

This module has been deprecated since perl v5.18.  See L</DESCRIPTION> and
L</BUGS>.

=head1 SYNOPSIS

  use encoding "greek";  # Perl like Greek to you?
  use encoding "euc-jp"; # Jperl!

  # or you can even do this if your shell supports your native encoding

  perl -Mencoding=latin2 -e'...' # Feeling centrally European?
  perl -Mencoding=euc-kr -e'...' # Or Korean?

  # more control

  # A simple euc-cn => utf-8 converter
  use encoding "euc-cn", STDOUT => "utf8";  while(<>){print};

  # "no encoding;" supported
  no encoding;

  # an alternate way, Filter
  use encoding "euc-jp", Filter=>1;
  # now you can use kanji identifiers -- in euc-jp!

  # encode based on the current locale - specialized purposes only;
  # fraught with danger!!
  use encoding ':locale';

=head1 DESCRIPTION

This pragma is used to enable a Perl script to be written in encodings that
aren't strictly ASCII nor UTF-8.  It translates all or portions of the Perl
program script from a given encoding into UTF-8, and changes the PerlIO layers
of C<STDIN> and C<STDOUT> to the encoding specified.

This pragma dates from the days when UTF-8-enabled editors were uncommon.  But
that was long ago, and the need for it is greatly diminished.  That, coupled
with the fact that it doesn't work with threads, along with other problems,
(see L</BUGS>) have led to its being deprecated.  It is planned to remove this
pragma in a future Perl version.  New code should be written in UTF-8, and the
C<use utf8> pragma used instead (see L<perluniintro> and L<utf8> for details).
Old code should be converted to UTF-8, via something like the recipe in the
L</SYNOPSIS> (though this simple approach may require manual adjustments
afterwards).

The only legitimate use of this pragma is almost certainly just one per file,
near the top, with file scope, as the file is likely going to only be written
in one encoding.  Further restrictions apply in Perls before v5.22 (see
L</Prior to Perl v5.22>).

There are two basic modes of operation (plus turning if off):

=over 4

=item C<use encoding ['I<ENCNAME>'] ;>

This is the normal operation.  It translates various literals encountered in
the Perl source file from the encoding I<ENCNAME> into UTF-8, and similarly
converts character code points.  This is used when the script is a combination
of ASCII (for the variable names and punctuation, I<etc>), but the literal
data is in the specified encoding.

I<ENCNAME> is optional.  If omitted, the encoding specified in the environment
variable L<C<PERL_ENCODING>|perlrun/PERL_ENCODING> is used.  If this isn't
set, or the resolved-to encoding is not known to C<L<Encode>>, the error
C<Unknown encoding 'I<ENCNAME>'> will be thrown.

Starting in Perl v5.8.6 (C<Encode> version 2.0.1), I<ENCNAME> may be the
name C<:locale>.  This is for very specialized applications, and is documented
in L</The C<:locale> sub-pragma> below.

The literals that are converted are C<q//, qq//, qr//, qw///, qx//>, and
starting in v5.8.1, C<tr///>.  Operations that do conversions include C<chr>,
C<ord>, C<utf8::upgrade> (but not C<utf8::downgrade>), and C<chomp>.

Also starting in v5.8.1, the C<DATA> pseudo-filehandle is translated from the
encoding into UTF-8.

For example, you can write code in EUC-JP as follows:

  my $Rakuda = "\xF1\xD1\xF1\xCC"; # Camel in Kanji
               #<-char-><-char->   # 4 octets
  s/\bCamel\b/$Rakuda/;

And with C<use encoding "euc-jp"> in effect, it is the same thing as
that code in UTF-8:

  my $Rakuda = "\x{99F1}\x{99DD}"; # two Unicode Characters
  s/\bCamel\b/$Rakuda/;

See L</EXAMPLE> below for a more complete example.

Unless C<${^UNICODE}> (available starting in v5.8.2) exists and is non-zero, the
PerlIO layers of C<STDIN> and C<STDOUT> are set to "C<:encoding(I<ENCNAME>)>".
Therefore,

  use encoding "euc-jp";
  my $message = "Camel is the symbol of perl.\n";
  my $Rakuda = "\xF1\xD1\xF1\xCC"; # Camel in Kanji
  $message =~ s/\bCamel\b/$Rakuda/;
  print $message;

will print

 "\xF1\xD1\xF1\xCC is the symbol of perl.\n"

not

 "\x{99F1}\x{99DD} is the symbol of perl.\n"

You can override this by giving extra arguments; see below.

Note that C<STDERR> WILL NOT be changed, regardless.

Also note that non-STD file handles remain unaffected.  Use C<use
open> or C<binmode> to change the layers of those.

=item C<use encoding I<ENCNAME> Filter=E<gt>1;>

This operates as above, but the C<Filter> argument with a non-zero
value causes the entire script, and not just literals, to be translated from
the encoding into UTF-8.  This allows identifiers in the source to be in that
encoding as well.  (Problems may occur if the encoding is not a superset of
ASCII; imagine all your semi-colons being translated into something
different.)  One can use this form to make

 ${"\x{4eba}"}++

work.  (This is equivalent to C<$I<human>++>, where I<human> is a single Han
ideograph).

This effectively means that your source code behaves as if it were written in
UTF-8 with C<'use utf8>' in effect.  So even if your editor only supports
Shift_JIS, for example, you can still try examples in Chapter 15 of
C<Programming Perl, 3rd Ed.>.

This option is significantly slower than the other one.

=item C<no encoding;>

Unsets the script encoding. The layers of C<STDIN>, C<STDOUT> are
reset to "C<:raw>" (the default unprocessed raw stream of bytes).

=back

=head1 OPTIONS

=head2 Setting C<STDIN> and/or C<STDOUT> individually

The encodings of C<STDIN> and C<STDOUT> are individually settable by parameters to
the pragma:

 use encoding 'euc-tw', STDIN => 'greek'  ...;

In this case, you cannot omit the first I<ENCNAME>.  C<< STDIN => undef >>
turns the I/O transcoding completely off for that filehandle.

When C<${^UNICODE}> (available starting in v5.8.2) exists and is non-zero,
these options will be completely ignored.  See L<perlvar/C<${^UNICODE}>> and
L<"C<-C>" in perlrun|perlrun/-C [numberE<sol>list]> for details.

=head2 The C<:locale> sub-pragma

Starting in v5.8.6, the encoding name may be C<:locale>.  This means that the
encoding is taken from the current locale, and not hard-coded by the pragma.
Since a script really can only be encoded in exactly one encoding, this option
is dangerous.  It makes sense only if the script itself is written in ASCII,
and all the possible locales that will be in use when the script is executed
are supersets of ASCII.  That means that the script itself doesn't get
changed, but the I/O handles have the specified encoding added, and the
operations like C<chr> and C<ord> use that encoding.

The logic of finding which locale C<:locale> uses is as follows:

=over 4

=item 1.

If the platform supports the C<langinfo(CODESET)> interface, the codeset
returned is used as the default encoding for the open pragma.

=item 2.

If 1. didn't work but we are under the locale pragma, the environment
variables C<LC_ALL> and C<LANG> (in that order) are matched for encodings
(the part after "C<.>", if any), and if any found, that is used
as the default encoding for the open pragma.

=item 3.

If 1. and 2. didn't work, the environment variables C<LC_ALL> and C<LANG>
(in that order) are matched for anything looking like UTF-8, and if
any found, C<:utf8> is used as the default encoding for the open
pragma.

=back

If your locale environment variables (C<LC_ALL>, C<LC_CTYPE>, C<LANG>)
contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching),
the default encoding of your C<STDIN>, C<STDOUT>, and C<STDERR>, and of
B<any subsequent file open>, is UTF-8.

=head1 CAVEATS

=head2 SIDE EFFECTS

=over

=item *

If the C<encoding> pragma is in scope then the lengths returned are
calculated from the length of C<$/> in Unicode characters, which is not
always the same as the length of C<$/> in the native encoding.

=item *

Without this pragma, if strings operating under byte semantics and strings
with Unicode character data are concatenated, the new string will
be created by decoding the byte strings as I<ISO 8859-1 (Latin-1)>.

The B<encoding> pragma changes this to use the specified encoding
instead.  For example:

    use encoding 'utf8';
    my $string = chr(20000); # a Unicode string
    utf8::encode($string);   # now it's a UTF-8 encoded byte string
    # concatenate with another Unicode string
    print length($string . chr(20000));

Will print C<2>, because C<$string> is upgraded as UTF-8.  Without
C<use encoding 'utf8';>, it will print C<4> instead, since C<$string>
is three octets when interpreted as Latin-1.

=back

=head2 DO NOT MIX MULTIPLE ENCODINGS

Notice that only literals (string or regular expression) having only
legacy code points are affected: if you mix data like this

    \x{100}\xDF
    \xDF\x{100}

the data is assumed to be in (Latin 1 and) Unicode, not in your native
encoding.  In other words, this will match in "greek":

    "\xDF" =~ /\x{3af}/

but this will not

    "\xDF\x{100}" =~ /\x{3af}\x{100}/

since the C<\xDF> (ISO 8859-7 GREEK SMALL LETTER IOTA WITH TONOS) on
the left will B<not> be upgraded to C<\x{3af}> (Unicode GREEK SMALL
LETTER IOTA WITH TONOS) because of the C<\x{100}> on the left.  You
should not be mixing your legacy data and Unicode in the same string.

This pragma also affects encoding of the 0x80..0xFF code point range:
normally characters in that range are left as eight-bit bytes (unless
they are combined with characters with code points 0x100 or larger,
in which case all characters need to become UTF-8 encoded), but if
the C<encoding> pragma is present, even the 0x80..0xFF range always
gets UTF-8 encoded.

After all, the best thing about this pragma is that you don't have to
resort to \x{....} just to spell your name in a native encoding.
So feel free to put your strings in your encoding in quotes and
regexes.

=head2 Prior to Perl v5.22

The pragma was a per script, not a per block lexical.  Only the last
C<use encoding> or C<no encoding> mattered, and it affected
B<the whole script>.  However, the C<no encoding> pragma was supported and
C<use encoding> could appear as many times as you want in a given script
(though only the last was effective).

Since the scope wasn't lexical, other modules' use of C<chr>, C<ord>, I<etc.>
were affected.  This leads to spooky, incorrect action at a distance that is
hard to debug.

This means you would have to be very careful of the load order:

  # called module
  package Module_IN_BAR;
  use encoding "bar";
  # stuff in "bar" encoding here
  1;

  # caller script
  use encoding "foo"
  use Module_IN_BAR;
  # surprise! use encoding "bar" is in effect.

The best way to avoid this oddity is to use this pragma RIGHT AFTER
other modules are loaded.  i.e.

  use Module_IN_BAR;
  use encoding "foo";

=head2 Prior to Encode version 1.87

=over

=item *

C<STDIN> and C<STDOUT> were not set under the filter option.
And C<< STDIN=>I<ENCODING> >> and C<< STDOUT=>I<ENCODING> >> didn't work like
non-filter version.

=item *

C<use utf8> wasn't implicitly declared so you have to C<use utf8> to do

 ${"\x{4eba}"}++

=back

=head2 Prior to Perl v5.8.1

=over

=item "NON-EUC" doublebyte encodings

Because perl needs to parse the script before applying this pragma, such
encodings as Shift_JIS and Big-5 that may contain C<'\'> (BACKSLASH;
C<\x5c>) in the second byte fail because the second byte may
accidentally escape the quoting character that follows.

=item C<tr///>

The B<encoding> pragma works by decoding string literals in
C<q//,qq//,qr//,qw///, qx//> and so forth.  In perl v5.8.0, this
does not apply to C<tr///>.  Therefore,

  use encoding 'euc-jp';
  #....
  $kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/;
  #           -------- -------- -------- --------

Does not work as

  $kana =~ tr/\x{3041}-\x{3093}/\x{30a1}-\x{30f3}/;

=over

=item Legend of characters above

  utf8     euc-jp   charnames::viacode()
  -----------------------------------------
  \x{3041} \xA4\xA1 HIRAGANA LETTER SMALL A
  \x{3093} \xA4\xF3 HIRAGANA LETTER N
  \x{30a1} \xA5\xA1 KATAKANA LETTER SMALL A
  \x{30f3} \xA5\xF3 KATAKANA LETTER N

=back

This counterintuitive behavior has been fixed in perl v5.8.1.

In perl v5.8.0, you can work around this as follows;

  use encoding 'euc-jp';
  #  ....
  eval qq{ \$kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/ };

Note the C<tr//> expression is surrounded by C<qq{}>.  The idea behind
this is the same as the classic idiom that makes C<tr///> 'interpolate':

   tr/$from/$to/;            # wrong!
   eval qq{ tr/$from/$to/ }; # workaround.

=back

=head1 EXAMPLE - Greekperl

    use encoding "iso 8859-7";

    # \xDF in ISO 8859-7 (Greek) is \x{3af} in Unicode.

    $a = "\xDF";
    $b = "\x{100}";

    printf "%#x\n", ord($a); # will print 0x3af, not 0xdf

    $c = $a . $b;

    # $c will be "\x{3af}\x{100}", not "\x{df}\x{100}".

    # chr() is affected, and ...

    print "mega\n"  if ord(chr(0xdf)) == 0x3af;

    # ... ord() is affected by the encoding pragma ...

    print "tera\n" if ord(pack("C", 0xdf)) == 0x3af;

    # ... as are eq and cmp ...

    print "peta\n" if "\x{3af}" eq  pack("C", 0xdf);
    print "exa\n"  if "\x{3af}" cmp pack("C", 0xdf) == 0;

    # ... but pack/unpack C are not affected, in case you still
    # want to go back to your native encoding

    print "zetta\n" if unpack("C", (pack("C", 0xdf))) == 0xdf;

=head1 BUGS

=over

=item Thread safety

C<use encoding ...> is not thread-safe (i.e., do not use in threaded
applications).

=item Can't be used by more than one module in a single program.

Only one encoding is allowed.  If you combine modules in a program that have
different encodings, only one will be actually used.

=item Other modules using C<STDIN> and C<STDOUT> get the encoded stream

They may be expecting something completely different.

=item literals in regex that are longer than 127 bytes

For native multibyte encodings (either fixed or variable length),
the current implementation of the regular expressions may introduce
recoding errors for regular expression literals longer than 127 bytes.

=item EBCDIC

The encoding pragma is not supported on EBCDIC platforms.

=item C<format>

This pragma doesn't work well with C<format> because PerlIO does not
get along very well with it.  When C<format> contains non-ASCII
characters it prints funny or gets "wide character warnings".
To understand it, try the code below.

  # Save this one in utf8
  # replace *non-ascii* with a non-ascii string
  my $camel;
  format STDOUT =
  *non-ascii*@@>>>>>>>
  $camel
  .
  $camel = "*non-ascii*";
  binmode(STDOUT=>':encoding(utf8)'); # bang!
  write;              # funny
  print $camel, "\n"; # fine

Without binmode this happens to work but without binmode, print()
fails instead of write().

At any rate, the very use of C<format> is questionable when it comes to
unicode characters since you have to consider such things as character
width (i.e. double-width for ideographs) and directions (i.e. BIDI for
Arabic and Hebrew).

=item See also L</CAVEATS>

=back

=head1 HISTORY

This pragma first appeared in Perl v5.8.0.  It has been enhanced in later
releases as specified above.

=head1 SEE ALSO

L<perlunicode>, L<Encode>, L<open>, L<Filter::Util::Call>,

Ch. 15 of C<Programming Perl (3rd Edition)>
by Larry Wall, Tom Christiansen, Jon Orwant;
O'Reilly & Associates; ISBN 0-596-00027-8

=cut
@


1.5
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d1 1
a1 1
# $Id: encoding.pm,v 2.12 2013/04/26 18:30:46 dankogai Exp $
d3 1
a3 1
our $VERSION = sprintf "%d.%02d", q$Revision: 2.12 $ =~ /(\d+)/g;
d9 5
a13 14
use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};

BEGIN {
    if ( ord("A") == 193 ) {
        require Carp;
        Carp::croak("encoding: pragma does not support EBCDIC platforms");
    }
}

our $HAS_PERLIO = 0;
eval { require PerlIO::encoding };
unless ($@@) {
    $HAS_PERLIO = ( PerlIO::encoding->VERSION >= 0.02 );
}
d33 28
d62 1
a62 1
    eval {
d64 3
a66 2
        I18N::Langinfo->import(qw(langinfo CODESET));
        $locale_encoding = langinfo( CODESET() );
d68 1
d70 7
a76 6
    my $country_language;

    no warnings 'uninitialized';

    if ( (not $locale_encoding) && in_locale() ) {
        if ( $ENV{LC_ALL} =~ /^([^.]+)\.([^.@@]+)(@@.*)?$/ ) {
a77 4
        }
        elsif ( $ENV{LANG} =~ /^([^.]+)\.([^.@@]+)(@@.*)?$/ ) {
            ( $country_language, $locale_encoding ) = ( $1, $2 );
        }
d79 25
a103 7
        # LANGUAGE affects only LC_MESSAGES only on glibc
    }
    elsif ( not $locale_encoding ) {
        if (   $ENV{LC_ALL} =~ /\butf-?8\b/i
            || $ENV{LANG} =~ /\butf-?8\b/i )
        {
            $locale_encoding = 'utf8';
d105 1
a105 31

        # Could do more heuristics based on the country and language
        # parts of LC_ALL and LANG (the parts before the dot (if any)),
        # since we have Locale::Country and Locale::Language available.
        # TODO: get a database of Language -> Encoding mappings
        # (the Estonian database at http://www.eki.ee/letter/
        # would be excellent!) --jhi
    }
    if (   defined $locale_encoding
        && lc($locale_encoding) eq 'euc'
        && defined $country_language )
    {
        if ( $country_language =~ /^ja_JP|japan(?:ese)?$/i ) {
            $locale_encoding = 'euc-jp';
        }
        elsif ( $country_language =~ /^ko_KR|korean?$/i ) {
            $locale_encoding = 'euc-kr';
        }
        elsif ( $country_language =~ /^zh_CN|chin(?:a|ese)$/i ) {
            $locale_encoding = 'euc-cn';
        }
        elsif ( $country_language =~ /^zh_TW|taiwan(?:ese)?$/i ) {
            $locale_encoding = 'euc-tw';
        }
        else {
            require Carp;
            Carp::croak(
                "encoding: Locale encoding '$locale_encoding' too ambiguous"
            );
        }
    }
d111 6
d146 13
a158 2
        _exception($name) or ${^ENCODING} = $enc;
        $HAS_PERLIO or return 1;
d162 1
d212 2
a213 1
    if ($HAS_PERLIO) {
d233 1
a233 1
encoding - allows you to write your script in non-ascii or non-utf8
d237 2
a238 10
This module is deprecated under perl 5.18.  It uses a mechanism provided by
perl that is deprecated under 5.18 and higher, and may be removed in a
future version.

The easiest and the best alternative is to write your script in UTF-8
and declear:

  use utf8; # not use encoding ':utf8';

See L<perluniintro> and L<utf8> for details.
d255 1
a255 1
  # "no encoding;" supported (but not scoped!)
d262 2
a263 6
  # switch on locale -
  # note that this probably means that unless you have a complete control
  # over the environments the application is ever going to be run, you should
  # NOT use the feature of encoding pragma allowing you to write your script
  # in any recognized encoding because changing locale settings will wreck
  # the script; you can of course still use the other features of the pragma.
d266 1
a266 1
=head1 ABSTRACT
d268 19
a286 11
Let's start with a bit of history: Perl 5.6.0 introduced Unicode
support.  You could apply C<substr()> and regexes even to complex CJK
characters -- so long as the script was written in UTF-8.  But back
then, text editors that supported UTF-8 were still rare and many users
instead chose to write scripts in legacy encodings, giving up a whole
new feature of Perl 5.6.

Rewind to the future: starting from perl 5.8.0 with the B<encoding>
pragma, you can write your script in any encoding you like (so long
as the C<Encode> module supports it) and still enjoy Unicode support.
This pragma achieves that by doing the following:
d288 1
a288 1
=over
d290 1
a290 1
=item *
d292 1
a292 3
Internally converts all literals (C<q//,qq//,qr//,qw///, qx//>) from
the encoding specified to utf8.  In Perl 5.8.1 and later, literals in
C<tr///> and C<DATA> pseudo-filehandle are also converted.
d294 18
a311 1
=item *
d313 2
a314 2
Changing PerlIO layers of C<STDIN> and C<STDOUT> to the encoding
 specified.
d316 1
a316 5
=back

=head2 Literal Conversions

You can write code in EUC-JP as follows:
d323 1
a323 1
the code in UTF-8:
d328 1
a328 1
=head2 PerlIO layers for C<STD(IN|OUT)>
d330 3
a332 2
The B<encoding> pragma also modifies the filehandle layers of
STDIN and STDOUT to the specified encoding.  Therefore,
d340 1
a340 2
Will print "\xF1\xD1\xF1\xCC is the symbol of perl.\n",
not "\x{99F1}\x{99DD} is the symbol of perl.\n".
d342 1
a342 1
You can override this by giving extra arguments; see below.
d344 1
a344 1
=head2 Implicit upgrading for byte strings
d346 1
a346 3
By default, if strings operating under byte semantics and strings
with Unicode character data are concatenated, the new string will
be created by decoding the byte strings as I<ISO 8859-1 (Latin-1)>.
d348 1
a348 2
The B<encoding> pragma changes this to use the specified encoding
instead.  For example:
d350 1
a350 5
    use encoding 'utf8';
    my $string = chr(20000); # a Unicode string
    utf8::encode($string);   # now it's a UTF-8 encoded byte string
    # concatenate with another Unicode string
    print length($string . chr(20000));
d352 2
a353 3
Will print C<2>, because C<$string> is upgraded as UTF-8.  Without
C<use encoding 'utf8';>, it will print C<4> instead, since C<$string>
is three octets when interpreted as Latin-1.
d355 1
a355 1
=head2 Side effects
d357 6
a362 3
If the C<encoding> pragma is in scope then the lengths returned are
calculated from the length of C<$/> in Unicode characters, which is not
always the same as the length of C<$/> in the native encoding.
d364 1
a364 1
This pragma affects utf8::upgrade, but not utf8::downgrade.
d366 2
a367 1
=head1 FEATURES THAT REQUIRE 5.8.1
d369 4
a372 5
Some of the features offered by this pragma requires perl 5.8.1.  Most
of these are done by Inaba Hiroto.  Any other features and changes
are good for 5.8.0.

=over
d374 1
a374 1
=item "NON-EUC" doublebyte encodings
d376 1
a376 5
Because perl needs to parse script before applying this pragma, such
encodings as Shift_JIS and Big-5 that may contain '\' (BACKSLASH;
\x5c) in the second byte fails because the second byte may
accidentally escape the quoting character that follows.  Perl 5.8.1
or later fixes this problem.
d378 2
a379 1
=item tr//
d381 1
a381 4
C<tr//> was overlooked by Perl 5 porters when they released perl 5.8.0
See the section below for details.

=item DATA pseudo-filehandle
d383 1
a383 1
Another feature that was overlooked was C<DATA>.
d385 1
a385 1
=back
d387 2
a388 1
=head1 USAGE
d390 1
a390 1
=over 4
d392 2
a393 1
=item use encoding [I<ENCNAME>] ;
d395 3
a397 3
Sets the script encoding to I<ENCNAME>.  And unless ${^UNICODE}
exists and non-zero, PerlIO layers of STDIN and STDOUT are set to
":encoding(I<ENCNAME>)".
d399 1
a399 1
Note that STDERR WILL NOT be changed.
d401 8
a408 2
Also note that non-STD file handles remain unaffected.  Use C<use
open> or C<binmode> to change layers of those.
d410 1
a410 3
If no encoding is specified, the environment variable L<PERL_ENCODING>
is consulted.  If no encoding can be found, the error C<Unknown encoding
'I<ENCNAME>'> will be thrown.
d412 1
a412 1
=item use encoding I<ENCNAME> [ STDIN =E<gt> I<ENCNAME_IN> ...] ;
d414 1
a414 4
You can also individually set encodings of STDIN and STDOUT via the
C<< STDIN => I<ENCNAME> >> form.  In this case, you cannot omit the
first I<ENCNAME>.  C<< STDIN => undef >> turns the IO transcoding
completely off.
d416 2
a417 4
When ${^UNICODE} exists and non-zero, these options will completely
ignored.  ${^UNICODE} is a variable introduced in perl 5.8.1.  See
L<perlrun> see L<perlvar/"${^UNICODE}"> and L<perlrun/"-C"> for
details (perl 5.8.1 and later).
d419 1
a419 1
=item use encoding I<ENCNAME> Filter=E<gt>1;
d421 4
a424 4
This turns the encoding pragma into a source filter.  While the
default approach just decodes interpolated literals (in qq() and
qr()), this will apply a source filter to the entire source code.  See
L</"The Filter Option"> below for details.
d426 1
a426 1
=item no encoding;
d428 4
a431 2
Unsets the script encoding. The layers of STDIN, STDOUT are
reset to ":raw" (the default unprocessed raw stream of bytes).
d435 4
a438 1
=head1 The Filter Option
d440 1
a440 10
The magic of C<use encoding> is not applied to the names of
identifiers.  In order to make C<${"\x{4eba}"}++> ($human++, where human
is a single Han ideograph) work, you still need to write your script
in UTF-8 -- or use a source filter.  That's what 'Filter=>1' does.

What does this mean?  Your source code behaves as if it is written in
UTF-8 with 'use utf8' in effect.  So even if your editor only supports
Shift_JIS, for example, you can still try examples in Chapter 15 of
C<Programming Perl, 3rd Ed.>.  For instance, you can use UTF-8
identifiers.
d442 1
a442 5
This option is significantly slower and (as of this writing) non-ASCII
identifiers are not very stable WITHOUT this option and with the
source code written in UTF-8.

=head2 Filter-related changes at Encode version 1.87
d448 3
a450 3
The Filter option now sets STDIN and STDOUT like non-filter options.
And C<< STDIN=>I<ENCODING> >> and C<< STDOUT=>I<ENCODING> >> work like
non-filter version.
d454 3
a456 2
C<use utf8> is implicitly declared so you no longer have to C<use
utf8> to C<${"\x{4eba}"}++>.
d458 2
a459 1
=back
d461 5
a465 1
=head1 CAVEATS
d467 3
a469 1
=head2 NOT SCOPED
d471 1
a471 29
The pragma is a per script, not a per block lexical.  Only the last
C<use encoding> or C<no encoding> matters, and it affects
B<the whole script>.  However, the <no encoding> pragma is supported and
B<use encoding> can appear as many times as you want in a given script.
The multiple use of this pragma is discouraged.

By the same reason, the use this pragma inside modules is also
discouraged (though not as strongly discouraged as the case above.
See below).

If you still have to write a module with this pragma, be very careful
of the load order.  See the codes below;

  # called module
  package Module_IN_BAR;
  use encoding "bar";
  # stuff in "bar" encoding here
  1;

  # caller script
  use encoding "foo"
  use Module_IN_BAR;
  # surprise! use encoding "bar" is in effect.

The best way to avoid this oddity is to use this pragma RIGHT AFTER
other modules are loaded.  i.e.

  use Module_IN_BAR;
  use encoding "foo";
d478 1
d507 61
a567 1
=head2 tr/// with ranges
d570 1
a570 1
C<q//,qq//,qr//,qw///, qx//> and so forth.  In perl 5.8.0, this
d595 1
a595 1
This counterintuitive behavior has been fixed in perl 5.8.1.
d597 1
a597 3
=head3 workaround to tr///;

In perl 5.8.0, you can work around as follows;
d604 1
a604 1
is the same as classic idiom that makes C<tr///> 'interpolate'.
d609 1
a609 3
Nevertheless, in case of B<encoding> pragma even C<q//> is affected so
C<tr///> not being decoded was obviously against the will of Perl5
Porters so it has been fixed in Perl 5.8.1 or later.
d644 1
a644 1
=head1 KNOWN PROBLEMS
d648 14
a670 2
(Porters who are willing and able to remove this limitation are
welcome.)
d672 1
a672 1
=item format
d674 2
a675 2
This pragma doesn't work well with format because PerlIO does not
get along very well with it.  When format contains non-ascii
d694 1
a694 1
At any rate, the very use of format is questionable when it comes to
d699 1
a699 4
=item Thread safety

C<use encoding ...> is not thread-safe (i.e., do not use in threaded
applications).
a702 32
=head2 The Logic of :locale

The logic of C<:locale> is as follows:

=over 4

=item 1.

If the platform supports the langinfo(CODESET) interface, the codeset
returned is used as the default encoding for the open pragma.

=item 2.

If 1. didn't work but we are under the locale pragma, the environment
variables LC_ALL and LANG (in that order) are matched for encodings
(the part after C<.>, if any), and if any found, that is used
as the default encoding for the open pragma.

=item 3.

If 1. and 2. didn't work, the environment variables LC_ALL and LANG
(in that order) are matched for anything looking like UTF-8, and if
any found, C<:utf8> is used as the default encoding for the open
pragma.

=back

If your locale environment variables (LC_ALL, LC_CTYPE, LANG)
contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching),
the default encoding of your STDIN, STDOUT, and STDERR, and of
B<any subsequent file open>, is UTF-8.

d705 2
a706 4
This pragma first appeared in Perl 5.8.0.  For features that require
5.8.1 and better, see above.

The C<:locale> subpragma was implemented in 2.01, or Perl 5.8.6.
@


1.4
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d1 1
a1 1
# $Id: encoding.pm,v 2.11 2013/02/18 02:23:56 dankogai Exp $
d3 1
a3 1
our $VERSION = '2.6_01';
d215 7
@


1.3
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d1 1
a1 1
# $Id: encoding.pm,v 2.9 2011/08/09 07:49:44 dankogai Exp dankogai $
d105 4
d111 4
d209 6
@


1.2
log
@merge in perl 5.12.2 plus local changes
@
text
@d1 1
a1 1
# $Id: encoding.pm,v 2.8 2009/02/15 17:44:13 dankogai Exp $
d9 1
a9 1
sub DEBUG () { 0 }
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d1 1
a1 1
# $Id: encoding.pm,v 2.9 2011/08/09 07:49:44 dankogai Exp dankogai $
d9 1
a9 1
use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d1 1
a1 1
# $Id: encoding.pm,v 2.11 2013/02/18 02:23:56 dankogai Exp $
a104 4
    if ($] >= 5.017) {
	warnings::warnif("deprecated",
			 "Use of the encoding pragma is deprecated")
    }
a106 4
    if (!$name){
	require Carp;
        Carp::croak("encoding: no encoding specified.");
    }
a200 6

=head1 WARNING

This module is deprecated under perl 5.18.  It uses a mechanism provided by
perl that is deprecated under 5.18 and higher, and may be removed in a
future version.
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@d1 1
a1 1
# $Id: encoding.pm,v 2.12 2013/04/26 18:30:46 dankogai Exp $
d3 1
a3 1
our $VERSION = sprintf "%d.%02d", q$Revision: 2.12 $ =~ /(\d+)/g;
a214 7

The easiest and the best alternative is to write your script in UTF-8
and declear:

  use utf8; # not use encoding ':utf8';

See L<perluniintro> and L<utf8> for details.
@


