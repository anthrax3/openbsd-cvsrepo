head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.4
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.4.0.4
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.3.0.4
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_8_BASE:1.3
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.2.0.18
	OPENBSD_5_6_BASE:1.2
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.2.0.16
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.12
	OPENBSD_5_4_BASE:1.2
	PERL_5_16_3:1.1.1.1
	OPENBSD_5_3:1.2.0.10
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.8
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2017.02.05.00.31.57;	author afresh1;	state Exp;
branches;
next	1.4;
commitid	cxJ08BvJA9Pt2PTM;

1.4
date	2016.07.25.10.53.01;	author afresh1;	state Exp;
branches;
next	1.3;
commitid	FHUgABTHZQuYQh2B;

1.3
date	2014.11.17.20.56.59;	author afresh1;	state Exp;
branches
	1.3.4.1
	1.3.6.1;
next	1.2;
commitid	QP75iYx42Uo7mMxO;

1.2
date	2010.09.24.15.06.47;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.24.14.48.59;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.59;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.11.17.20.52.44;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;

1.3.4.1
date	2016.08.05.01.01.37;	author afresh1;	state Exp;
branches;
next	;
commitid	HjAJx2yjL4A8HWon;

1.3.6.1
date	2016.08.05.01.00.53;	author afresh1;	state Exp;
branches;
next	;
commitid	wK3bUiy9jNch0Key;


desc
@@


1.5
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl
# $Id: piconv,v 2.7 2014/05/31 09:48:48 dankogai Exp $
#
BEGIN { pop @@INC if $INC[-1] eq '.' }
use 5.8.0;
use strict;
use Encode ;
use Encode::Alias;
my %Scheme =  map {$_ => 1} qw(from_to decode_encode perlio);

use File::Basename;
my $name = basename($0);

use Getopt::Long qw(:config no_ignore_case);

my %Opt;

help()
    unless
      GetOptions(\%Opt,
         'from|f=s',
         'to|t=s',
         'list|l',
         'string|s=s',
         'check|C=i',
         'c',
         'perlqq|p',
         'htmlcref',
         'xmlcref',
         'debug|D',
         'scheme|S=s',
         'resolve|r=s',
         'help',
         );

$Opt{help} and help();
$Opt{list} and list_encodings();
my $locale = $ENV{LC_CTYPE} || $ENV{LC_ALL} || $ENV{LANG};
defined $Opt{resolve} and resolve_encoding($Opt{resolve});
$Opt{from} || $Opt{to} || help();
my $from = $Opt{from} || $locale or help("from_encoding unspecified");
my $to   = $Opt{to}   || $locale or help("to_encoding unspecified");
$Opt{string} and Encode::from_to($Opt{string}, $from, $to) and print $Opt{string} and exit;
my $scheme = do {
    if (defined $Opt{scheme}) {
	if (!exists $Scheme{$Opt{scheme}}) {
	    warn "Unknown scheme '$Opt{scheme}', fallback to 'from_to'.\n";
	    'from_to';
	} else {
	    $Opt{scheme};
	}
    } else {
	'from_to';
    }
};

$Opt{check} ||= $Opt{c};
$Opt{perlqq}   and $Opt{check} = Encode::PERLQQ;
$Opt{htmlcref} and $Opt{check} = Encode::HTMLCREF;
$Opt{xmlcref}  and $Opt{check} = Encode::XMLCREF;

my $efrom = Encode->getEncoding($from) || die "Unknown encoding '$from'";
my $eto   = Encode->getEncoding($to)   || die "Unknown encoding '$to'";

my $cfrom = $efrom->name;
my $cto   = $eto->name;

if ($Opt{debug}){
    print <<"EOT";
Scheme: $scheme
From:   $from => $cfrom
To:     $to => $cto
EOT
}

my %use_bom =
  map { $_ => 1 } qw/UTF-16 UTF-16BE UTF-16LE UTF-32 UTF-32BE UTF-32LE/;

# we do not use <> (or ARGV) for the sake of binmode()
@@ARGV or push @@ARGV, \*STDIN;

unless ( $scheme eq 'perlio' ) {
    binmode STDOUT;
    my $need2slurp = $use_bom{ $eto } || $use_bom{ $efrom };
    for my $argv (@@ARGV) {
        my $ifh = ref $argv ? $argv : undef;
	$ifh or open $ifh, "<", $argv or warn "Can't open $argv: $!" and next;
        $ifh or open $ifh, "<", $argv or next;
        binmode $ifh;
        if ( $scheme eq 'from_to' ) {    # default
	    if ($need2slurp){
		local $/;
		$_ = <$ifh>;
		Encode::from_to( $_, $from, $to, $Opt{check} );
		print;
	    }else{
		while (<$ifh>) {
		    Encode::from_to( $_, $from, $to, $Opt{check} );
		    print;
		}
	    }
        }
        elsif ( $scheme eq 'decode_encode' ) {    # step-by-step
	    if ($need2slurp){
		local $/;
		$_ = <$ifh>;
                my $decoded = decode( $from, $_, $Opt{check} );
                my $encoded = encode( $to, $decoded );
                print $encoded;
	    }else{
		while (<$ifh>) {
		    my $decoded = decode( $from, $_, $Opt{check} );
		    my $encoded = encode( $to, $decoded );
		    print $encoded;
		}
	    }
	}
	else {                                    # won't reach
            die "$name: unknown scheme: $scheme";
        }
    }
}
else {

    # NI-S favorite
    binmode STDOUT => "raw:encoding($to)";
    for my $argv (@@ARGV) {
        my $ifh = ref $argv ? $argv : undef;
	$ifh or open $ifh, "<", $argv or warn "Can't open $argv: $!" and next;
        $ifh or open $ifh, "<", $argv or next;
        binmode $ifh => "raw:encoding($from)";
        print while (<$ifh>);
    }
}

sub list_encodings {
    print join( "\n", Encode->encodings(":all") ), "\n";
    exit 0;
}

sub resolve_encoding {
    if ( my $alias = Encode::resolve_alias( $_[0] ) ) {
        print $alias, "\n";
        exit 0;
    }
    else {
        warn "$name: $_[0] is not known to Encode\n";
        exit 1;
    }
}

sub help {
    my $message = shift;
    $message and print STDERR "$name error: $message\n";
    print STDERR <<"EOT";
$name [-f from_encoding] [-t to_encoding]
      [-p|--perlqq|--htmlcref|--xmlcref] [-C N|-c] [-D] [-S scheme]
      [-s string|file...]
$name -l
$name -r encoding_alias
$name -h
Common options:
  -l,--list
     lists all available encodings
  -r,--resolve encoding_alias
    resolve encoding to its (Encode) canonical name
  -f,--from from_encoding  
     when omitted, the current locale will be used
  -t,--to to_encoding    
     when omitted, the current locale will be used
  -s,--string string         
     "string" will be the input instead of STDIN or files
The following are mainly of interest to Encode hackers:
  -C N | -c           check the validity of the input
  -D,--debug          show debug information
  -S,--scheme scheme  use the scheme for conversion
Those are handy when you can only see ASCII characters:
  -p,--perlqq         transliterate characters missing in encoding to \\x{HHHH}
                      where HHHH is the hexadecimal Unicode code point
  --htmlcref          transliterate characters missing in encoding to &#NNN;
                      where NNN is the decimal Unicode code point
  --xmlcref           transliterate characters missing in encoding to &#xHHHH;
                      where HHHH is the hexadecimal Unicode code point

EOT
    exit;
}

__END__

=head1 NAME

piconv -- iconv(1), reinvented in perl

=head1 SYNOPSIS

  piconv [-f from_encoding] [-t to_encoding]
         [-p|--perlqq|--htmlcref|--xmlcref] [-C N|-c] [-D] [-S scheme]
         [-s string|file...]
  piconv -l
  piconv -r encoding_alias
  piconv -h

=head1 DESCRIPTION

B<piconv> is perl version of B<iconv>, a character encoding converter
widely available for various Unixen today.  This script was primarily
a technology demonstrator for Perl 5.8.0, but you can use piconv in the
place of iconv for virtually any case.

piconv converts the character encoding of either STDIN or files
specified in the argument and prints out to STDOUT.

Here is the list of options.  Some options can be in short format (-f)
or long (--from) one.

=over 4

=item -f,--from I<from_encoding>

Specifies the encoding you are converting from.  Unlike B<iconv>,
this option can be omitted.  In such cases, the current locale is used.

=item -t,--to I<to_encoding>

Specifies the encoding you are converting to.  Unlike B<iconv>,
this option can be omitted.  In such cases, the current locale is used.

Therefore, when both -f and -t are omitted, B<piconv> just acts
like B<cat>.

=item -s,--string I<string>

uses I<string> instead of file for the source of text.

=item -l,--list

Lists all available encodings, one per line, in case-insensitive
order.  Note that only the canonical names are listed; many aliases
exist.  For example, the names are case-insensitive, and many standard
and common aliases work, such as "latin1" for "ISO-8859-1", or "ibm850"
instead of "cp850", or "winlatin1" for "cp1252".  See L<Encode::Supported>
for a full discussion.

=item -r,--resolve I<encoding_alias>

Resolve I<encoding_alias> to Encode canonical encoding name.

=item -C,--check I<N>

Check the validity of the stream if I<N> = 1.  When I<N> = -1, something
interesting happens when it encounters an invalid character.

=item -c

Same as C<-C 1>.

=item -p,--perlqq

Transliterate characters missing in encoding to \x{HHHH} where HHHH is the
hexadecimal Unicode code point.

=item --htmlcref

Transliterate characters missing in encoding to &#NNN; where NNN is the
decimal Unicode code point.

=item --xmlcref

Transliterate characters missing in encoding to &#xHHHH; where HHHH is the
hexadecimal Unicode code point.

=item -h,--help

Show usage.

=item -D,--debug

Invokes debugging mode.  Primarily for Encode hackers.

=item -S,--scheme I<scheme>

Selects which scheme is to be used for conversion.  Available schemes
are as follows:

=over 4

=item from_to

Uses Encode::from_to for conversion.  This is the default.

=item decode_encode

Input strings are decode()d then encode()d.  A straight two-step
implementation.

=item perlio

The new perlIO layer is used.  NI-S' favorite.

You should use this option if you are using UTF-16 and others which
linefeed is not $/.

=back

Like the I<-D> option, this is also for Encode hackers.

=back

=head1 SEE ALSO

L<iconv(1)>
L<locale(3)>
L<Encode>
L<Encode::Supported>
L<Encode::Alias>
L<PerlIO>

=cut
@


1.4
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.


ok deraadt@@
@
text
@d2 1
a2 1
# $Id: piconv,v 2.6 2014/03/28 02:37:42 dankogai Exp $
d62 6
a68 2
    my $cfrom = Encode->getEncoding($from)->name;
    my $cto   = Encode->getEncoding($to)->name;
d84 1
a84 2
    my $need2slurp = $use_bom{ find_encoding($to)->name }
      || $use_bom{ find_encoding($from)->name };
@


1.3
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d4 1
@


1.3.4.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@a3 1
BEGIN { pop @@INC if $INC[-1] eq '.' }
@


1.3.6.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@a3 1
BEGIN { pop @@INC if $INC[-1] eq '.' }
@


1.2
log
@merge in perl 5.12.2 plus local changes
@
text
@d2 1
a2 1
# $Id: piconv,v 2.4 2009/07/08 13:34:15 dankogai Exp $
d71 2
a72 1
my %use_bom = map { $_ => 1 } qw/UTF-16 UTF-32/;
d79 2
a80 1
    my $need2slurp = $use_bom{ find_encoding($to)->name };
d152 3
a154 1
$name [-f from_encoding] [-t to_encoding] [-s string] [files...]
d157 2
d170 1
a171 1
  -C N | -c           check the validity of the input
d173 8
a180 4
Those are handy when you can only see ascii characters:
  -p,--perlqq
  --htmlcref
  --xmlcref
d193 3
a195 1
  piconv [-f from_encoding] [-t to_encoding] [-s string] [files...]
d197 1
a197 4
  piconv [-C N|-c|-p]
  piconv -S scheme ...
  piconv -r encoding
  piconv -D ...
d210 2
a211 2
Here is the list of options.  Each option can be in short format (-f)
or long (--from).
d215 1
a215 1
=item -f,--from from_encoding
d220 1
a220 1
=item -t,--to to_encoding
d241 4
d256 3
d261 3
d266 2
a267 5
Applies PERLQQ, HTMLCREF, XMLCREF, respectively.  Try

  piconv -f utf8 -t ascii --perlqq

To see what it does.
d277 1
a277 1
=item -S,--scheme scheme
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@Import perl-5.20.1
@
text
@d2 1
a2 1
# $Id: piconv,v 2.6 2014/03/28 02:37:42 dankogai Exp $
d71 1
a71 2
my %use_bom =
  map { $_ => 1 } qw/UTF-16 UTF-16BE UTF-16LE UTF-32 UTF-32BE UTF-32LE/;
d78 1
a78 2
    my $need2slurp = $use_bom{ find_encoding($to)->name }
      || $use_bom{ find_encoding($from)->name };
d150 1
a150 3
$name [-f from_encoding] [-t to_encoding]
      [-p|--perlqq|--htmlcref|--xmlcref] [-C N|-c] [-D] [-S scheme]
      [-s string|file...]
a152 2
$name -h
Common options:
d164 1
a165 1
  -D,--debug          show debug information
d167 4
a170 8
Those are handy when you can only see ASCII characters:
  -p,--perlqq         transliterate characters missing in encoding to \\x{HHHH}
                      where HHHH is the hexadecimal Unicode code point
  --htmlcref          transliterate characters missing in encoding to &#NNN;
                      where NNN is the decimal Unicode code point
  --xmlcref           transliterate characters missing in encoding to &#xHHHH;
                      where HHHH is the hexadecimal Unicode code point

d183 1
a183 3
  piconv [-f from_encoding] [-t to_encoding]
         [-p|--perlqq|--htmlcref|--xmlcref] [-C N|-c] [-D] [-S scheme]
         [-s string|file...]
d185 4
a188 1
  piconv -r encoding_alias
d201 2
a202 2
Here is the list of options.  Some options can be in short format (-f)
or long (--from) one.
d206 1
a206 1
=item -f,--from I<from_encoding>
d211 1
a211 1
=item -t,--to I<to_encoding>
a231 4
=item -r,--resolve I<encoding_alias>

Resolve I<encoding_alias> to Encode canonical encoding name.

d243 1
a243 2
Transliterate characters missing in encoding to \x{HHHH} where HHHH is the
hexadecimal Unicode code point.
d245 1
a245 1
=item --htmlcref
d247 1
a247 2
Transliterate characters missing in encoding to &#NNN; where NNN is the
decimal Unicode code point.
d249 1
a249 1
=item --xmlcref
d251 1
a251 2
Transliterate characters missing in encoding to &#xHHHH; where HHHH is the
hexadecimal Unicode code point.
d261 1
a261 1
=item -S,--scheme I<scheme>
@

