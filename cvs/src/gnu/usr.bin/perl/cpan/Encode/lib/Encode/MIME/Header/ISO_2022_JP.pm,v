head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.12
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.10
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.4
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_8_BASE:1.3
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.2.0.18
	OPENBSD_5_6_BASE:1.2
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.2.0.16
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.12
	OPENBSD_5_4_BASE:1.2
	PERL_5_16_3:1.1.1.1
	OPENBSD_5_3:1.2.0.10
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.8
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2014.11.17.20.56.59;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	QP75iYx42Uo7mMxO;

1.2
date	2010.09.24.15.06.47;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.24.14.48.59;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.59;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.11.17.20.52.45;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.3
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@package Encode::MIME::Header::ISO_2022_JP;

use strict;
use warnings;

use parent qw(Encode::MIME::Header);

$Encode::Encoding{'MIME-Header-ISO_2022_JP'} =
  bless { encode => 'B', bpl => 76, Name => 'MIME-Header-ISO_2022_JP' } =>
  __PACKAGE__;

use constant HEAD => '=?ISO-2022-JP?B?';
use constant TAIL => '?=';

use Encode::CJKConstants qw(%RE);

our $VERSION = do { my @@r = ( q$Revision: 1.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @@r };

# I owe the below codes totally to
#   Jcode by Dan Kogai & http://www.din.or.jp/~ohzaki/perl.htm#JP_Base64

sub encode {
    my $self = shift;
    my $str  = shift;

    utf8::encode($str) if ( Encode::is_utf8($str) );
    Encode::from_to( $str, 'utf8', 'euc-jp' );

    my ($trailing_crlf) = ( $str =~ /(\n|\r|\x0d\x0a)$/o );

    $str = _mime_unstructured_header( $str, $self->{bpl} );

    not $trailing_crlf and $str =~ s/(\n|\r|\x0d\x0a)$//o;

    return $str;
}

sub _mime_unstructured_header {
    my ( $oldheader, $bpl ) = @@_;
    my $crlf = $oldheader =~ /\n$/;
    my ( $header, @@words, @@wordstmp, $i ) = ('');

    $oldheader =~ s/\s+$//;

    @@wordstmp = split /\s+/, $oldheader;

    for ( $i = 0 ; $i < $#wordstmp ; $i++ ) {
        if (    $wordstmp[$i] !~ /^[\x21-\x7E]+$/
            and $wordstmp[ $i + 1 ] !~ /^[\x21-\x7E]+$/ )
        {
            $wordstmp[ $i + 1 ] = "$wordstmp[$i] $wordstmp[$i + 1]";
        }
        else {
            push( @@words, $wordstmp[$i] );
        }
    }

    push( @@words, $wordstmp[-1] );

    for my $word (@@words) {
        if ( $word =~ /^[\x21-\x7E]+$/ ) {
            $header =~ /(?:.*\n)*(.*)/;
            if ( length($1) + length($word) > $bpl ) {
                $header .= "\n $word";
            }
            else {
                $header .= $word;
            }
        }
        else {
            $header = _add_encoded_word( $word, $header, $bpl );
        }

        $header =~ /(?:.*\n)*(.*)/;

        if ( length($1) == $bpl ) {
            $header .= "\n ";
        }
        else {
            $header .= ' ';
        }
    }

    $header =~ s/\n? $//mg;

    $crlf ? "$header\n" : $header;
}

sub _add_encoded_word {
    my ( $str, $line, $bpl ) = @@_;
    my $result = '';

    while ( length($str) ) {
        my $target = $str;
        $str = '';

        if (
            length($line) + 22 +
            ( $target =~ /^(?:$RE{EUC_0212}|$RE{EUC_C})/o ) * 8 > $bpl )
        {
            $line =~ s/[ \t\n\r]*$/\n/;
            $result .= $line;
            $line = ' ';
        }

        while (1) {
            my $iso_2022_jp = $target;
            Encode::from_to( $iso_2022_jp, 'euc-jp', 'iso-2022-jp' );

            my $encoded =
              HEAD . MIME::Base64::encode_base64( $iso_2022_jp, '' ) . TAIL;

            if ( length($encoded) + length($line) > $bpl ) {
                $target =~
                  s/($RE{EUC_0212}|$RE{EUC_KANA}|$RE{EUC_C}|$RE{ASCII})$//o;
                $str = $1 . $str;
            }
            else {
                $line .= $encoded;
                last;
            }
        }

    }

    $result . $line;
}

1;
__END__

@


1.2
log
@merge in perl 5.12.2 plus local changes
@
text
@d6 1
a6 1
use base qw(Encode::MIME::Header);
d17 1
a17 1
our $VERSION = do { my @@r = ( q$Revision: 1.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @@r };
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@Import perl-5.20.1
@
text
@d6 1
a6 1
use parent qw(Encode::MIME::Header);
d17 1
a17 1
our $VERSION = do { my @@r = ( q$Revision: 1.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @@r };
@

