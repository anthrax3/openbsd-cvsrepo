head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.2
	PERL_5_24_2:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.14
	OPENBSD_6_1_BASE:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.12
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.6
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.8
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.2
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.4
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.16
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.12
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2010.09.24.14.49.05;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.05;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.03.24.14.58.49;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!/usr/bin/perl -w
use strict;
use warnings;
use autodie::hints;
use Test::More;

use constant PERL510 => ( $] >= 5.010 );

BEGIN {
    if (not PERL510) {
        plan skip_all => "Only subroutine hints supported in 5.8.x";
    }
    else {
        plan 'no_plan';
    }
}

use FindBin;
use lib "$FindBin::Bin/lib";
use Hints_pod_examples qw(
	undef_scalar false_scalar zero_scalar empty_list default_list
	empty_or_false_list undef_n_error_list foo re_fail bar
	think_positive my_system
);
use autodie qw( !
	undef_scalar false_scalar zero_scalar empty_list default_list
	empty_or_false_list undef_n_error_list foo re_fail bar
	think_positive my_system
);

my %scalar_tests = (

    # Test code             # Exception expected?

    'undef_scalar()'        => 1,
    'undef_scalar(1)',      => 0,
    'undef_scalar(0)',      => 0,
    'undef_scalar("")',     => 0,

    'false_scalar(0)',      => 1,
    'false_scalar()',       => 1,
    'false_scalar(undef)',  => 1,
    'false_scalar("")',     => 1,
    'false_scalar(1)',      => 0,
    'false_scalar("1")',    => 0,

    'zero_scalar("0")',     => 1,
    'zero_scalar(0)',       => 1,
    'zero_scalar(1)',       => 0,
    'zero_scalar(undef)',   => 0,
    'zero_scalar("")',      => 0,

    'foo(0)',	            => 1,
    'foo(undef)',	    => 0,
    'foo(1)',	            => 0,

    'bar(0)',	            => 1,
    'bar(undef)',	    => 0,
    'bar(1)',	            => 0,

    're_fail(-1)',          => 0,
    're_fail("FAIL")',      => 1,
    're_fail("_FAIL")',     => 1,
    're_fail("_fail")',     => 0,
    're_fail("fail")',      => 0,

    'think_positive(-1)'    => 1,
    'think_positive(-2)'    => 1,
    'think_positive(0)'     => 0,
    'think_positive(1)'     => 0,
    'think_positive(2)'     => 0,

    'my_system(1)'          => 1,
    'my_system(2)'          => 1,
    'my_system(0)'          => 0,

);

my %list_tests = (

    'empty_list()',         => 1,
    'empty_list(())',       => 1,
    'empty_list([])',       => 0,
    'empty_list(0)',        => 0,
    'empty_list("")',       => 0,
    'empty_list(undef)',    => 0,

    'default_list()',       => 1,
    'default_list(0)',      => 0,
    'default_list("")',     => 0,
    'default_list(undef)',  => 1,
    'default_list(1)',      => 0,
    'default_list("str")',  => 0,
    'default_list(1, 2)',   => 0,

    'empty_or_false_list()',     => 1,
    'empty_or_false_list(())',   => 1,
    'empty_or_false_list(0)',    => 1,
    'empty_or_false_list(undef)',=> 1,
    'empty_or_false_list("")',   => 1,
    'empty_or_false_list("0")',  => 1,
    'empty_or_false_list(1,2)',  => 0,
    'empty_or_false_list("a")',  => 0,

    'undef_n_error_list(undef, 1)'   => 1,
    'undef_n_error_list(undef, "a")' => 1,
    'undef_n_error_list()'           => 0,
    'undef_n_error_list(0, 1)'       => 0,
    'undef_n_error_list("", 1)'      => 0,
    'undef_n_error_list(1)'          => 0,

    'foo(0)',	            => 1,
    'foo(undef)',	    => 0,
    'foo(1)',	            => 0,

    'bar(0)',	            => 1,
    'bar(undef)',	    => 0,
    'bar(1)',	            => 0,

    're_fail(-1)',          => 1,
    're_fail("FAIL")',      => 0,
    're_fail("_FAIL")',     => 0,
    're_fail("_fail")',     => 0,
    're_fail("fail")',      => 0,

    'think_positive(-1)'    => 1,
    'think_positive(-2)'    => 1,
    'think_positive(0)'     => 0,
    'think_positive(1)'     => 0,
    'think_positive(2)'     => 0,

    'my_system(1)'          => 1,
    'my_system(2)'          => 1,
    'my_system(0)'          => 0,

);

# On Perl 5.8, autodie doesn't correctly propagate into string evals.
# The following snippet forces the use of autodie inside the eval if
# we really really have to.  For 5.10+, we don't want to include this
# fix, because the tests will act as a canary if we screw up string
# eval propagation.

my $perl58_fix = (
    PERL510 ?
    q{} :
    q{use autodie qw(
	undef_scalar false_scalar zero_scalar empty_list default_list
	empty_or_false_list undef_n_error_list foo re_fail bar
	think_positive my_system bizarro_system    
    );}
);

# Some of the tests provide different hints for scalar or list context

while (my ($test, $exception_expected) = each %scalar_tests) {
    eval "
        $perl58_fix
        my \$scalar = $test;
    ";

    if ($exception_expected) {
        isnt("$@@", "", "scalar test - $test");
    }
    else {
        is($@@, "", "scalar test - $test");
    }
}

while (my ($test, $exception_expected) = each %list_tests) {
    eval "
        $perl58_fix
        my \@@array = $test;
    ";

    if ($exception_expected) {
        isnt("$@@", "", "array test - $test");
    }
    else {
        is($@@, "", "array test - $test");
    }
}

1;
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a154 13
# NOTE: these tests are sensitive to order (not sure why) therefore
# this loop must use a sorted list of keys . Otherwise there is an occasional
# failure like this:
#
#   Failed test 'scalar test - zero_scalar("")'
#   at cpan/autodie/t/hints_pod_examples.t line 168.
#          got: 'Can't zero_scalar(''):  at cpan/autodie/t/hints_pod_examples.t line 157
# '
#     expected: ''
#
#
#         my $scalar = zero_scalar("");
#         1;
d156 2
a157 4

foreach my $test (sort keys %scalar_tests) {
    my $exception_expected= $scalar_tests{$test};
    my $ok= eval(my $code= "
d160 1
a160 2
        1;
    ");
d163 1
a163 2
        isnt($ok ? "" : "$@@", "", "scalar test - $test")
            or diag($code);
d166 1
a166 2
        is($ok ? "" : "$@@", "", "scalar test - $test")
            or diag($code);
d170 1
a170 4

# this set of test is not *known* to be order dependent however we sort it anyway out caution
foreach my $test (sort keys %list_tests) {
    my $exception_expected= $list_tests{$test};
@

