head	1.3;
access;
symbols
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.5.0.2
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.4
	OPENBSD_5_8_BASE:1.1.1.5
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.31.55;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2016.07.25.10.53.00;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	FHUgABTHZQuYQh2B;

1.1
date	2010.09.24.14.49.06;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.06;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.06.54;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.49;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.52.42;	author afresh1;	state Exp;
branches;
next	1.1.1.5;
commitid	B31cAbBIXiCqnL97;

1.1.1.5
date	2015.04.25.19.10.15;	author afresh1;	state Exp;
branches
	1.1.1.5.2.1
	1.1.1.5.4.1;
next	;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.5.2.1
date	2016.08.05.01.01.36;	author afresh1;	state Exp;
branches;
next	;
commitid	HjAJx2yjL4A8HWon;

1.1.1.5.4.1
date	2016.08.05.01.00.52;	author afresh1;	state Exp;
branches;
next	;
commitid	wK3bUiy9jNch0Key;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@# -*- Mode: cperl; coding: utf-8; cperl-indent-level: 4 -*-
# vim: ts=4 sts=4 sw=4:
=head1 NAME

CPAN::Mirrors - Get CPAN mirror information and select a fast one

=head1 SYNOPSIS

    use CPAN::Mirrors;

    my $mirrors = CPAN::Mirrors->new( $mirrored_by_file );

    my $seen = {};

    my $best_continent = $mirrors->find_best_continents( { seen => $seen } );
    my @@mirrors        = $mirrors->get_mirrors_by_continents( $best_continent );

    my $callback = sub {
        my( $m ) = @@_;
        printf "%s = %s\n", $m->hostname, $m->rtt
        };
    $mirrors->get_mirrors_timings( \@@mirrors, $seen, $callback );

    @@mirrors = sort { $a->rtt <=> $b->rtt } @@mirrors;

    print "Best mirrors are ", map( { $_->rtt } @@mirrors[0..3] ), "\n";

=head1 DESCRIPTION

=over

=cut

package CPAN::Mirrors;
use strict;
use vars qw($VERSION $urllist $silent);
$VERSION = "1.9601";

use Carp;
use FileHandle;
use Fcntl ":flock";
use Net::Ping ();

=item new( LOCAL_FILE_NAME )

Create a new CPAN::Mirrors object from LOCAL_FILE_NAME. This file
should look like that in http://www.cpan.org/MIRRORED.BY .

=cut

sub new {
    my ($class, $file) = @@_;
    croak "CPAN::Mirrors->new requires a filename" unless defined $file;
    croak "The file [$file] was not found" unless -e $file;

    my $self = bless {
        mirrors      => [],
        geography    => {},
    }, $class;

    $self->parse_mirrored_by( $file );

    return $self;
}

sub parse_mirrored_by {
    my ($self, $file) = @@_;
    my $handle = FileHandle->new;
    $handle->open($file)
        or croak "Couldn't open $file: $!";
    flock $handle, LOCK_SH;
    $self->_parse($file,$handle);
    flock $handle, LOCK_UN;
    $handle->close;
}

=item continents()

Return a list of continents based on those defined in F<MIRRORED.BY>.

=cut

sub continents {
    my ($self) = @@_;
    return keys %{$self->{geography}};
}

=item countries( [CONTINENTS] )

Return a list of countries based on those defined in F<MIRRORED.BY>.
It only returns countries for the continents you specify (as defined
in C<continents>). If you don't specify any continents, it returns all
of the countries listed in F<MIRRORED.BY>.

=cut

sub countries {
    my ($self, @@continents) = @@_;
    @@continents = $self->continents unless @@continents;
    my @@countries;
    for my $c (@@continents) {
        push @@countries, keys %{ $self->{geography}{$c} };
    }
    return @@countries;
}

=item mirrors( [COUNTRIES] )

Return a list of mirrors based on those defined in F<MIRRORED.BY>.
It only returns mirrors for the countries you specify (as defined
in C<countries>). If you don't specify any countries, it returns all
of the mirrors listed in F<MIRRORED.BY>.

=cut

sub mirrors {
    my ($self, @@countries) = @@_;
    return @@{$self->{mirrors}} unless @@countries;
    my %wanted = map { $_ => 1 } @@countries;
    my @@found;
    for my $m (@@{$self->{mirrors}}) {
        push @@found, $m if exists $wanted{$m->country};
    }
    return @@found;
}

=item get_mirrors_by_countries( [COUNTRIES] )

A more sensible synonym for mirrors.

=cut

sub get_mirrors_by_countries { &mirrors }

=item get_mirrors_by_continents( [CONTINENTS] )

Return a list of mirrors for all of continents you specify. If you don't
specify any continents, it returns all of the mirrors.

You can specify a single continent or an array reference of continents.

=cut

sub get_mirrors_by_continents {
    my ($self, $continents ) = @@_;
    $continents = [ $continents ] unless ref $continents;

    eval {
        $self->mirrors( $self->get_countries_by_continents( @@$continents ) );
        };
    }

=item get_countries_by_continents( [CONTINENTS] )

A more sensible synonym for countries.

=cut

sub get_countries_by_continents { &countries }

=item default_mirror

Returns the default mirror, http://www.cpan.org/ . This mirror uses
dynamic DNS to give a close mirror.

=cut

sub default_mirror { 'http://www.cpan.org/' }

=item best_mirrors

C<best_mirrors> checks for the best mirrors based on the list of
continents you pass, or, without that, all continents, as defined
by C<CPAN::Mirrored::By>. It pings each mirror, up to the value of
C<how_many>. In list context, it returns up to C<how_many> mirror.
In scalar context, it returns the single best mirror.

Arguments

    how_many   - the number of mirrors to return. Default: 1
    callback   - a callback for find_best_continents
    verbose    - true or false on all the whining and moaning. Default: false
    continents - an array ref of the continents to check

If you don't specify the continents, C<best_mirrors> calls
C<find_best_continents> to get the list of continents to check.

If you don't have L<Net::Ping> v2.13 or later, needed for timings,
this returns the default mirror.

=cut

sub best_mirrors {
    my ($self, %args) = @@_;
    my $how_many      = $args{how_many} || 1;
    my $callback      = $args{callback};
    my $verbose       = defined $args{verbose} ? $args{verbose} : 0;
    my $continents    = $args{continents} || [];
       $continents    = [$continents] unless ref $continents;

    # Old Net::Ping did not do timings at all
    my $min_version = '2.13';
    unless( Net::Ping->VERSION gt $min_version ) {
        carp sprintf "Net::Ping version is %s (< %s). Returning %s",
            Net::Ping->VERSION, $min_version, $self->default_mirror;
        return $self->default_mirror;
    }

    my $seen = {};

    if ( ! @@$continents ) {
        print "Searching for the best continent ...\n" if $verbose;
        my @@best_continents = $self->find_best_continents(
            seen     => $seen,
            verbose  => $verbose,
            callback => $callback,
            );

        # Only add enough continents to find enough mirrors
        my $count = 0;
        for my $continent ( @@best_continents ) {
            push @@$continents, $continent;
            $count += $self->mirrors( $self->countries($continent) );
            last if $count >= $how_many;
        }
    }

    print "Scanning " . join(", ", @@$continents) . " ...\n" if $verbose;

    my $trial_mirrors = $self->get_n_random_mirrors_by_continents( 3 * $how_many, $continents->[0] );

    my $timings = $self->get_mirrors_timings( $trial_mirrors, $seen, $callback );
    return [] unless @@$timings;

    $how_many = @@$timings if $how_many > @@$timings;

    return wantarray ? @@{$timings}[0 .. $how_many-1] : $timings->[0];
}

=item get_n_random_mirrors_by_continents( N, [CONTINENTS] )

Returns up to N random mirrors for the specified continents. Specify the
continents as an array reference.

=cut

sub get_n_random_mirrors_by_continents {
    my( $self, $n, $continents ) = @@_;
    $n ||= 3;
    $continents = [ $continents ] unless ref $continents;

    if ( $n <= 0 ) {
        return wantarray ? () : [];
    }

    my @@long_list = $self->get_mirrors_by_continents( $continents );

    if ( $n eq '*' or $n > @@long_list ) {
        return wantarray ? @@long_list : \@@long_list;
    }

    @@long_list = map  {$_->[0]}
                 sort {$a->[1] <=> $b->[1]}
                 map  {[$_, rand]} @@long_list;

    splice @@long_list, $n; # truncate

    \@@long_list;
}

=item get_mirrors_timings( MIRROR_LIST, SEEN, CALLBACK );

Pings the listed mirrors and returns a list of mirrors sorted in
ascending ping times.

C<MIRROR_LIST> is an anonymous array of C<CPAN::Mirrored::By> objects to
ping.

The optional argument C<SEEN> is a hash reference used to track the
mirrors you've already pinged.

The optional argument C<CALLBACK> is a subroutine reference to call
after each ping. It gets the C<CPAN::Mirrored::By> object after each
ping.

=cut

sub get_mirrors_timings {
    my( $self, $mirror_list, $seen, $callback ) = @@_;

    $seen = {} unless defined $seen;
    croak "The mirror list argument must be an array reference"
        unless ref $mirror_list eq ref [];
    croak "The seen argument must be a hash reference"
        unless ref $seen eq ref {};
    croak "callback must be a subroutine"
        if( defined $callback and ref $callback ne ref sub {} );

    my $timings = [];
    for my $m ( @@$mirror_list ) {
        $seen->{$m->hostname} = $m;
        next unless eval{ $m->http };

        if( $self->_try_a_ping( $seen, $m, ) ) {
            my $ping = $m->ping;
            next unless defined $ping;
            push @@$timings, $m;
            $callback->( $m ) if $callback;
        }
        else {
            push @@$timings, $seen->{$m->hostname}
                if defined $seen->{$m->hostname}->rtt;
        }
    }

    my @@best = sort {
           if( defined $a->rtt and defined $b->rtt )     {
            $a->rtt <=> $b->rtt
            }
        elsif( defined $a->rtt and ! defined $b->rtt )   {
            return -1;
            }
        elsif( ! defined $a->rtt and defined $b->rtt )   {
            return 1;
            }
        elsif( ! defined $a->rtt and ! defined $b->rtt ) {
            return 0;
            }

        } @@$timings;

    return wantarray ? @@best : \@@best;
}

=item find_best_continents( HASH_REF );

C<find_best_continents> goes through each continent and pings C<N>
random mirrors on that continent. It then orders the continents by
ascending median ping time. In list context, it returns the ordered list
of continent. In scalar context, it returns the same list as an
anonymous array.

Arguments:

    n        - the number of hosts to ping for each continent. Default: 3
    seen     - a hashref of cached hostname ping times
    verbose  - true or false for noisy or quiet. Default: false
    callback - a subroutine to run after each ping.
    ping_cache_limit - how long, in seconds, to reuse previous ping times.
        Default: 1 day

The C<seen> hash has hostnames as keys and anonymous arrays as values.
The anonymous array is a triplet of a C<CPAN::Mirrored::By> object, a
ping time, and the epoch time for the measurement.

The callback subroutine gets the C<CPAN::Mirrored::By> object, the ping
time, and measurement time (the same things in the C<seen> hashref) as
arguments. C<find_best_continents> doesn't care what the callback does
and ignores the return value.

With a low value for C<N>, a single mirror might skew the results enough
to choose a worse continent. If you have that problem, try a larger
value.

=cut

sub find_best_continents {
    my ($self, %args) = @@_;

    $args{n}     ||=  3;
    $args{verbose} = 0 unless defined $args{verbose};
    $args{seen}    = {} unless defined $args{seen};
    croak "The seen argument must be a hash reference"
        unless ref $args{seen} eq ref {};
    $args{ping_cache_limit} = 24 * 60 * 60
        unless defined $args{ping_cache_time};
    croak "callback must be a subroutine"
        if( defined $args{callback} and ref $args{callback} ne ref sub {} );

    my %medians;
    CONT: for my $c ( $self->continents ) {
        print "Testing $c\n" if $args{verbose};
        my @@mirrors = $self->mirrors( $self->countries($c) );

        next CONT unless @@mirrors;
        my $n = (@@mirrors < $args{n}) ? @@mirrors : $args{n};

        my @@tests;
        my $tries = 0;
        RANDOM: while ( @@mirrors && @@tests < $n && $tries++ < 15 ) {
            my $m = splice( @@mirrors, int(rand(@@mirrors)), 1 );
           if( $self->_try_a_ping( $args{seen}, $m, $args{ping_cache_limit} ) ) {
                $self->get_mirrors_timings( [ $m ], @@args{qw(seen callback)} );
                next RANDOM unless defined $args{seen}{$m->hostname}->rtt;
            }
            printf "\t%s -> %0.2f ms\n",
                $m->hostname,
                join ' ', 1000 * $args{seen}{$m->hostname}->rtt
                    if $args{verbose};

            push @@tests, $args{seen}{$m->hostname}->rtt;
        }

        my $median = $self->_get_median_ping_time( \@@tests, $args{verbose} );
        $medians{$c} = $median if defined $median;
    }

    my @@best_cont = sort { $medians{$a} <=> $medians{$b} } keys %medians;

    if ( $args{verbose} ) {
        print "Median result by continent:\n";
        for my $c ( @@best_cont ) {
            printf( "  %4d ms  %s\n", int($medians{$c}*1000+.5), $c );
        }
    }

    return wantarray ? @@best_cont : $best_cont[0];
}

# retry if
sub _try_a_ping {
    my ($self, $seen, $mirror, $ping_cache_limit ) = @@_;

    ( ! exists $seen->{$mirror->hostname} )
        or
    (
    ! defined $seen->{$mirror->hostname}->rtt
        or
    time - $seen->{$mirror->hostname}->rtt > $ping_cache_limit
    )
}

sub _get_median_ping_time {
    my ($self, $tests, $verbose ) = @@_;

    my @@sorted = sort { $a <=> $b } @@$tests;

    my $median = do {
           if ( @@sorted == 0 ) { undef }
        elsif ( @@sorted == 1 ) { $sorted[0] }
        elsif ( @@sorted % 2 )  { $sorted[ int(@@sorted / 2) ] }
        else {
            my $mid_high = int(@@sorted/2);
            ($sorted[$mid_high-1] + $sorted[$mid_high])/2;
        }
    };

    printf "\t-->median time: %0.2f ms\n", $median * 1000 if $verbose;

    return $median;
}

# Adapted from Parse::CPAN::MirroredBy by Adam Kennedy
sub _parse {
    my ($self, $file, $handle) = @@_;
    my $output = $self->{mirrors};
    my $geo    = $self->{geography};

    local $/ = "\012";
    my $line = 0;
    my $mirror = undef;
    while ( 1 ) {
        # Next line
        my $string = <$handle>;
        last if ! defined $string;
        $line = $line + 1;

        # Remove the useless lines
        chomp( $string );
        next if $string =~ /^\s*$/;
        next if $string =~ /^\s*#/;

        # Hostname or property?
        if ( $string =~ /^\s/ ) {
            # Property
            unless ( $string =~ /^\s+(\w+)\s+=\s+\"(.*)\"$/ ) {
                croak("Invalid property on line $line");
            }
            my ($prop, $value) = ($1,$2);
            $mirror ||= {};
            if ( $prop eq 'dst_location' ) {
                my (@@location,$continent,$country);
                @@location = (split /\s*,\s*/, $value)
                    and ($continent, $country) = @@location[-1,-2];
                $continent =~ s/\s\(.*//;
                $continent =~ s/\W+$//; # if Jarkko doesn't know latitude/longitude
                $geo->{$continent}{$country} = 1 if $continent && $country;
                $mirror->{continent} = $continent || "unknown";
                $mirror->{country} = $country || "unknown";
            }
            elsif ( $prop eq 'dst_http' ) {
                $mirror->{http} = $value;
            }
            elsif ( $prop eq 'dst_ftp' ) {
                $mirror->{ftp} = $value;
            }
            elsif ( $prop eq 'dst_rsync' ) {
                $mirror->{rsync} = $value;
            }
            else {
                $prop =~ s/^dst_//;
                $mirror->{$prop} = $value;
            }
        } else {
            # Hostname
            unless ( $string =~ /^([\w\.-]+)\:\s*$/ ) {
                croak("Invalid host name on line $line");
            }
            my $current = $mirror;
            $mirror     = { hostname => "$1" };
            if ( $current ) {
                push @@$output, CPAN::Mirrored::By->new($current);
            }
        }
    }
    if ( $mirror ) {
        push @@$output, CPAN::Mirrored::By->new($mirror);
    }

    return;
}

#--------------------------------------------------------------------------#

package CPAN::Mirrored::By;
use strict;
use Net::Ping   ();

sub new {
    my($self,$arg) = @@_;
    $arg ||= {};
    bless $arg, $self;
}
sub hostname  { shift->{hostname}    }
sub continent { shift->{continent}   }
sub country   { shift->{country}     }
sub http      { shift->{http}  || '' }
sub ftp       { shift->{ftp}   || '' }
sub rsync     { shift->{rsync} || '' }
sub rtt       { shift->{rtt}         }
sub ping_time { shift->{ping_time}   }

sub url {
    my $self = shift;
    return $self->{http} || $self->{ftp};
}

sub ping {
    my $self = shift;

    my $ping = Net::Ping->new($^O eq 'VMS' ? 'icmp' : 'tcp', 1);
    my ($proto) = $self->url =~ m{^([^:]+)};
    my $port = $proto eq 'http' ? 80 : 21;
    return unless $port;

    if ( $ping->can('port_number') ) {
        $ping->port_number($port);
    }
    else {
        $ping->{'port_num'} = $port;
    }

    $ping->hires(1) if $ping->can('hires');
    my ($alive,$rtt) = $ping->ping($self->hostname);

    $self->{rtt} = $alive ? $rtt : undef;
    $self->{ping_time} = time;

    $self->rtt;
}


1;

=back

=head1 AUTHOR

Andreas Koenig C<< <andk@@cpan.org> >>, David Golden C<< <dagolden@@cpan.org> >>,
brian d foy C<< <bdfoy@@cpan.org> >>

=head1 LICENSE

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

See L<http://www.perl.com/perl/misc/Artistic.html>

=cut
@


1.2
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.


ok deraadt@@
@
text
@d37 1
a37 1
$VERSION = "1.9601_01";
@


1.1
log
@Initial revision
@
text
@d3 31
d37 1
a37 1
$VERSION = "1.77";
d42 8
d53 6
a58 3
    my $self = bless { 
        mirrors => [], 
        geography => {},
d61 7
d69 1
a69 1
    $handle->open($file) 
d75 3
d79 1
a79 1
    # populate continents & countries
d81 1
a81 2
    return $self
}
d88 9
d107 9
d127 66
d195 13
a207 5
    my $how_many = $args{how_many} || 1;
    my $callback = $args{callback};
    my $verbose = $args{verbose};
    my $conts = $args{continents} || [];
    $conts = [$conts] unless ref $conts;
d211 1
a211 1
    if ( ! @@$conts ) {
d213 5
a217 1
        my @@best = $self->_find_best_continent($seen, $verbose, $callback);
d219 1
a219 2
        # how many continents to find enough mirrors? We should scan
        # more than we need -- arbitrarily, we'll say x2
d221 4
a224 4
        for my $c ( @@best ) {
            push @@$conts, $c;
            $count += $self->mirrors( $self->countries($c) );
            last if $count >= 2 * $how_many;
d228 70
a297 1
    print "Scanning " . join(", ", @@$conts) . " ...\n" if $verbose;
d299 10
a308 7
    my @@timings;
    for my $m ($self->mirrors($self->countries(@@$conts))) {
        next unless $m->ftp;
        my $hostname = $m->hostname;
        if ( $seen->{$hostname}  ) {
            push @@timings, $seen->{$hostname}
                if defined $seen->{$hostname}[1];
d311 2
a312 4
            my $ping = $m->ping;
            next unless defined $ping;
            push @@timings, [$m, $ping];
            $callback->($m,$ping) if $callback;
a314 5
    return unless @@timings;
    $how_many = @@timings if $how_many > @@timings;
    my @@best =
        map  { $_->[0] }
        sort { $a->[1] <=> $b->[1] } @@timings;
d316 17
a332 1
    return wantarray ? @@best[0 .. $how_many-1] : $best[0];
d335 44
a378 2
sub _find_best_continent {
    my ($self, $seen, $verbose, $callback) = @@_;
d380 1
a380 1
    my %median;
d382 1
d384 1
d386 2
a387 2
        my $sample = 9;
        my $n = (@@mirrors < $sample) ? @@mirrors : $sample;
d389 2
a390 1
        RANDOM: while ( @@mirrors && @@tests < $n ) {
d392 10
a401 18
            my $ping = $m->ping;
            $callback->($m,$ping) if $callback;
            # record undef so we don't try again
            $seen->{$m->hostname} = [$m, $ping];
            next RANDOM unless defined $ping;
            push @@tests, $ping;
        }
        next CONT unless @@tests;
        @@tests = sort { $a <=> $b } @@tests;
        if ( @@tests == 1 ) {
            $median{$c} = $tests[0];
        }
        elsif ( @@tests % 2 ) {
            $median{$c} = $tests[ int(@@tests / 2) ];
        }
        else {
            my $mid_high = int(@@tests/2);
            $median{$c} = ($tests[$mid_high-1] + $tests[$mid_high])/2;
d403 3
d408 1
a408 1
    my @@best_cont = sort { $median{$a} <=> $median{$b} } keys %median ;
d410 1
a410 1
    if ( $verbose ) {
d413 1
a413 1
            printf( "  %d ms  %s\n", int($median{$c}*1000+.5), $c );
d420 33
d457 1
a457 1
    my $geo = $self->{geography};
d483 1
a483 1
                @@location = (split /\s*,\s*/, $value) 
d534 8
a541 6
sub hostname { shift->{hostname} }
sub continent { shift->{continent} }
sub country { shift->{country} }
sub http { shift->{http} || '' }
sub ftp { shift->{ftp} || '' }
sub rsync { shift->{rsync} || '' }
d543 1
a543 1
sub url { 
d545 1
a545 1
    return $self->{ftp} || $self->{http};
d550 2
a551 1
    my $ping = Net::Ping->new("tcp",1);
d555 9
a563 2
    $ping->port_number($port);
    $ping->hires(1);
d565 5
a569 1
    return $alive ? $rtt : undef;
d575 15
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a2 32
=head1 NAME

CPAN::Mirrors - Get CPAN miror information and select a fast one

=head1 SYNOPSIS

	use CPAN::Mirrors;

	my $mirrors = CPAN::Mirrors->new;
	$mirrors->parse_from_file( $mirrored_by_file );

	my $seen = {};

	my $best_continent = $mirrors->find_best_continents( { seen => $seen } );
	my @@mirrors        = $mirrors->get_mirrors_by_continents( $best_continent );

	my $callback = sub {
		my( $m ) = @@_;
		printf "%s = %s\n", $m->hostname, $m->rtt
		};
	$mirrors->get_mirrors_timings( \@@mirrors, $seen, $callback );

	@@mirrors = sort { $a->rtt <=> $b->rtt } @@mirrors;

	print "Best mirrors are ", map( { $_->rtt } @@mirrors[0..3] ), "\n";

=head1 DESCRIPTION

=over

=cut

d6 1
a6 1
$VERSION = "1.9600";
a10 5
use Net::Ping ();

=item new( LOCAL_FILE_NAME )

=cut
d14 3
a16 3
    my $self = bless {
        mirrors      => [],
        geography    => {},
a18 9
	if( defined $file ) {
		$self->parse_mirrored_by( $file );
	}

    return $self
}

sub parse_mirrored_by {
	my ($self, $file) = @@_;
d20 1
a20 1
    $handle->open($file)
a25 1
}
d27 1
a27 1
=item continents()
d29 2
a30 3
Return a list of continents based on those defined in F<MIRRORED.BY>.

=cut
a36 9
=item countries( [CONTINENTS] )

Return a list of countries based on those defined in F<MIRRORED.BY>.
It only returns countries for the continents you specify (as defined
in C<continents>). If you don't specify any continents, it returns all
of the countries listed in F<MIRRORED.BY>.

=cut

a46 9
=item mirrors( [COUNTRIES] )

Return a list of mirrors based on those defined in F<MIRRORED.BY>.
It only returns mirrors for the countries you specify (as defined
in C<countries>). If you don't specify any countries, it returns all
of the mirrors listed in F<MIRRORED.BY>.

=cut

a57 48
=item get_mirrors_by_countries( [COUNTRIES] )

A more sensible synonym for mirrors.

=cut

sub get_mirrors_by_countries { &mirrors }

=item get_mirrors_by_continents( [CONTINENTS] )

Return a list of mirrors for all of continents you specify. If you don't
specify any continents, it returns all of the mirrors.

=cut

sub get_mirrors_by_continents {
	my ($self, $continents ) = @@_;

	$self->mirrors( $self->get_countries_by_continents( @@$continents ) );
	}

=item get_countries_by_continents( [CONTINENTS] )

A more sensible synonym for countries.

=cut
sub get_countries_by_continents { &countries }

=item best_mirrors

C<best_mirrors> checks for the best mirrors based on the list of
continents you pass, or, without that, all continents, as defined
by C<CPAN::Mirrored::By>. It pings each mirror, up to the value of
C<how_many>. In list context, it returns up to C<how_many> mirror.
In scalar context, it returns the single best mirror.

Arguments

	how_many   - the number of mirrors to return. Default: 1
	callback   - a callback for find_best_continents
	verbose    - true or false on all the whining and moaning. Default: false
	continents - an array ref of the continents to check

If you don't specify the continents, C<best_mirrors> calls
C<find_best_continents> to get the list of continents to check.

=cut

d60 5
a64 8
    my $how_many      = $args{how_many} || 1;
    my $callback      = $args{callback};
    my $verbose       = defined $args{verbose} ? $args{verbose} : 0;
    my $continents    = $args{continents} || [];
       $continents    = [$continents] unless ref $continents;

    # Old Net::Ping did not do timings at all
    return "http://www.cpan.org/" unless Net::Ping->VERSION gt '2.13';
d68 1
a68 1
    if ( ! @@$continents ) {
d70 1
a70 5
        my @@best_continents = $self->find_best_continents(
        	seen     => $seen,
        	verbose  => $verbose,
        	callback => $callback,
        	);
d72 2
a73 1
        # Only add enough continents to find enough mirrors
d75 4
a78 4
        for my $continent ( @@best_continents ) {
            push @@$continents, $continent;
            $count += $self->mirrors( $self->countries($continent) );
            last if $count >= $how_many;
d82 1
a82 65
    print "Scanning " . join(", ", @@$continents) . " ...\n" if $verbose;

	my $trial_mirrors = $self->get_n_random_mirrors_by_continents( 3 * $how_many, $continents->[0] );

    my $timings = $self->get_mirrors_timings( $trial_mirrors, $seen, $callback );
    return [] unless @@$timings;

    $how_many = @@$timings if $how_many > @@$timings;

    return wantarray ? @@{$timings}[0 .. $how_many-1] : $timings->[0];
}

=item get_n_random_mirrors_by_continents( N, [CONTINENTS]

Returns up to N random mirrors for the specified continents. Specify the
continents as an array reference.

=cut

sub get_n_random_mirrors_by_continents {
	my( $self, $n, $continents ) = @@_;
	$n ||= 3;
	$continents = [ $continents ] unless ref $continents;

    if ( $n <= 0 ) {
    	return wantarray ? () : [];
    }

    my @@long_list = $self->get_mirrors_by_continents( $continents );

    if ( $n eq '*' or $n > @@long_list ) {
    	return wantarray ? @@long_list : \@@long_list;
    }

	@@long_list = map  {$_->[0]}
	             sort {$a->[1] <=> $b->[1]}
                 map  {[$_, rand]} @@long_list;

	splice @@long_list, $n; # truncate

	\@@long_list;
}

=item get_mirrors_timings( MIRROR_LIST, SEEN, CALLBACK );

Pings the listed mirrors and returns a list of mirrors sorted
in ascending ping times.

=cut

sub get_mirrors_timings {
	my( $self, $mirror_list, $seen, $callback ) = @@_;

	$seen = {} unless defined $seen;
	croak "The mirror list argument must be an array reference"
		unless ref $mirror_list eq ref [];
	croak "The seen argument must be a hash reference"
		unless ref $seen eq ref {};
	croak "callback must be a subroutine"
		if( defined $callback and ref $callback ne ref sub {} );

	my $timings = [];
    for my $m ( @@$mirror_list ) {
		$seen->{$m->hostname} = $m;
		next unless eval{ $m->http };
d84 7
a90 5
        if( $self->_try_a_ping( $seen, $m, ) ) {
            my $ping = $m->ping;
			next unless defined $ping;
            push @@$timings, $m;
            $callback->( $m ) if $callback;
d93 4
a96 2
            push @@$timings, $seen->{$m->hostname}
                if defined $seen->{$m->hostname}->rtt;
d99 5
d105 1
a105 17
    my @@best = sort {
    	   if( defined $a->rtt and defined $b->rtt )     {
    		$a->rtt <=> $b->rtt
    		}
    	elsif( defined $a->rtt and ! defined $b->rtt )   {
    		return -1;
    		}
    	elsif( ! defined $a->rtt and defined $b->rtt )   {
    		return 1;
    		}
    	elsif( ! defined $a->rtt and ! defined $b->rtt ) {
    		return 0;
    		}

    	} @@$timings;

    return wantarray ? @@best : \@@best;
d108 2
a109 40
=item find_best_continents( HASH_REF );

C<find_best_continents> goes through each continent and pings C<N> random
mirrors on that continent. It then orders the continents by ascending
median ping time. In list context, it returns the ordered list of
continent. In scalar context, it returns the same list as an anonymous
array.

Arguments:

	n        - the number of hosts to ping for each continent. Default: 3
	seen     - a hashref of cached hostname ping times
	verbose  - true or false for noisy or quiet. Default: false
	callback - a subroutine to run after each ping.
	ping_cache_limit - how long, in seconds, to reuse previous ping times.
		Default: 1 day

The C<seen> hash has hostnames as keys and anonymous arrays as values. The
anonymous array is a triplet of a C<CPAN::Mirrored::By> object, a ping
time, and the epoch time for the measurement.

The callback subroutine gets the C<CPAN::Mirrored::By> object, the ping
time, and measurement time (the same things in the C<seen> hashref) as arguments.
C<find_best_continents> doesn't care what the callback does and ignores the return
value.

=cut

sub find_best_continents {
    my ($self, %args) = @@_;

	$args{n}     ||=  3;
	$args{verbose} = 0 unless defined $args{verbose};
	$args{seen}    = {} unless defined $args{seen};
	croak "The seen argument must be a hash reference"
		unless ref $args{seen} eq ref {};
	$args{ping_cache_limit} = 24 * 60 * 60
		unless defined $args{ping_cache_time};
	croak "callback must be a subroutine"
		if( defined $args{callback} and ref $args{callback} ne ref sub {} );
d111 1
a111 1
    my %medians;
a112 1
    	print "Testing $c\n" if $args{verbose};
a113 1

d115 2
a116 2
        my $n = (@@mirrors < $args{n}) ? @@mirrors : $args{n};

d118 1
a118 2
        my $tries = 0;
        RANDOM: while ( @@mirrors && @@tests < $n && $tries++ < 15 ) {
d120 18
a137 10
           if( $self->_try_a_ping( $args{seen}, $m, $args{ping_cache_limit} ) ) {
				$self->get_mirrors_timings( [ $m ], @@args{qw(seen callback)} );
				next RANDOM unless defined $args{seen}{$m->hostname}->rtt;
            }
            printf "\t%s -> %0.2f ms\n",
            	$m->hostname,
            	join ' ', 1000 * $args{seen}{$m->hostname}->rtt
            		if $args{verbose};

			push @@tests, $args{seen}{$m->hostname}->rtt;
a138 3

		my $median = $self->_get_median_ping_time( \@@tests, $args{verbose} );
		$medians{$c} = $median if defined $median;
d141 1
a141 1
    my @@best_cont = sort { $medians{$a} <=> $medians{$b} } keys %medians;
d143 1
a143 1
    if ( $args{verbose} ) {
d146 1
a146 1
            printf( "  %4d ms  %s\n", int($medians{$c}*1000+.5), $c );
a152 33
# retry if
sub _try_a_ping {
	my ($self, $seen, $mirror, $ping_cache_limit ) = @@_;

	( ! exists $seen->{$mirror->hostname} )
		or
	(
	! defined $seen->{$mirror->hostname}->rtt
		or
	time - $seen->{$mirror->hostname}->rtt > $ping_cache_limit
	)
}

sub _get_median_ping_time {
	my ($self, $tests, $verbose ) = @@_;

	my @@sorted = sort { $a <=> $b } @@$tests;

	my $median = do {
		   if ( @@sorted == 0 ) { undef }
		elsif ( @@sorted == 1 ) { $sorted[0] }
		elsif ( @@sorted % 2 )  { $sorted[ int(@@sorted / 2) ] }
		else {
			my $mid_high = int(@@sorted/2);
			($sorted[$mid_high-1] + $sorted[$mid_high])/2;
		}
	};

	printf "\t-->median time: %0.2f ms\n", $median * 1000 if $verbose;

    return $median;
}

d157 1
a157 1
    my $geo    = $self->{geography};
d183 1
a183 1
                @@location = (split /\s*,\s*/, $value)
d234 6
a239 8
sub hostname  { shift->{hostname}    }
sub continent { shift->{continent}   }
sub country   { shift->{country}     }
sub http      { shift->{http}  || '' }
sub ftp       { shift->{ftp}   || '' }
sub rsync     { shift->{rsync} || '' }
sub rtt       { shift->{rtt}         }
sub ping_time { shift->{ping_time}   }
d241 1
a241 1
sub url {
d243 1
a243 1
    return $self->{http} || $self->{ftp};
a247 1

d252 2
a253 9

	if ( $ping->can('port_number') ) {
        $ping->port_number($port);
    }
    else {
        $ping->{'port_num'} = $port;
    }

    $ping->hires(1) if $ping->can('hires');
d255 1
a255 5

    $self->{rtt} = $alive ? $rtt : undef;
    $self->{ping_time} = time;

    $self->rtt;
a260 17
=back

=head1 AUTHOR

Andreas Koenig C<< <andk@@cpan.org> >>, David Golden C<< <dagolden@@cpan.org> >>,
brian d foy C<< <bdfoy@@cpan.org> >>

=head1 LICENSE

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

See L<http://www.perl.com/perl/misc/Artistic.html>



=cut
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d511 1
a511 1
    my $ping = Net::Ping->new($^O eq 'VMS' ? 'icmp' : 'tcp', 1);
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@d5 1
a5 1
CPAN::Mirrors - Get CPAN mirror information and select a fast one
d9 1
a9 1
    use CPAN::Mirrors;
d11 2
a12 1
    my $mirrors = CPAN::Mirrors->new( $mirrored_by_file );
d14 1
a14 1
    my $seen = {};
d16 2
a17 2
    my $best_continent = $mirrors->find_best_continents( { seen => $seen } );
    my @@mirrors        = $mirrors->get_mirrors_by_continents( $best_continent );
d19 5
a23 5
    my $callback = sub {
        my( $m ) = @@_;
        printf "%s = %s\n", $m->hostname, $m->rtt
        };
    $mirrors->get_mirrors_timings( \@@mirrors, $seen, $callback );
d25 1
a25 1
    @@mirrors = sort { $a->rtt <=> $b->rtt } @@mirrors;
d27 1
a27 1
    print "Best mirrors are ", map( { $_->rtt } @@mirrors[0..3] ), "\n";
a46 3
Create a new CPAN::Mirrors object from LOCAL_FILE_NAME. This file
should look like that in http://www.cpan.org/MIRRORED.BY .

a50 3
    croak "CPAN::Mirrors->new requires a filename" unless defined $file;
    croak "The file [$file] was not found" unless -e $file;

d56 3
a58 1
    $self->parse_mirrored_by( $file );
d60 1
a60 1
    return $self;
d64 1
a64 1
    my ($self, $file) = @@_;
a136 2
You can specify a single continent or an array reference of continents.

d140 1
a140 2
    my ($self, $continents ) = @@_;
    $continents = [ $continents ] unless ref $continents;
d142 2
a143 4
    eval {
        $self->mirrors( $self->get_countries_by_continents( @@$continents ) );
        };
    }
a149 1

a151 9
=item default_mirror

Returns the default mirror, http://www.cpan.org/ . This mirror uses
dynamic DNS to give a close mirror.

=cut

sub default_mirror { 'http://www.cpan.org/' }

d162 4
a165 4
    how_many   - the number of mirrors to return. Default: 1
    callback   - a callback for find_best_continents
    verbose    - true or false on all the whining and moaning. Default: false
    continents - an array ref of the continents to check
a169 3
If you don't have L<Net::Ping> v2.13 or later, needed for timings,
this returns the default mirror.

d181 1
a181 6
    my $min_version = '2.13';
    unless( Net::Ping->VERSION gt $min_version ) {
        carp sprintf "Net::Ping version is %s (< %s). Returning %s",
            Net::Ping->VERSION, $min_version, $self->default_mirror;
        return $self->default_mirror;
    }
d188 4
a191 4
            seen     => $seen,
            verbose  => $verbose,
            callback => $callback,
            );
d204 1
a204 1
    my $trial_mirrors = $self->get_n_random_mirrors_by_continents( 3 * $how_many, $continents->[0] );
d214 1
a214 1
=item get_n_random_mirrors_by_continents( N, [CONTINENTS] )
d222 3
a224 3
    my( $self, $n, $continents ) = @@_;
    $n ||= 3;
    $continents = [ $continents ] unless ref $continents;
d227 1
a227 1
        return wantarray ? () : [];
d233 1
a233 1
        return wantarray ? @@long_list : \@@long_list;
d236 2
a237 2
    @@long_list = map  {$_->[0]}
                 sort {$a->[1] <=> $b->[1]}
d240 1
a240 1
    splice @@long_list, $n; # truncate
d242 1
a242 1
    \@@long_list;
d247 2
a248 12
Pings the listed mirrors and returns a list of mirrors sorted in
ascending ping times.

C<MIRROR_LIST> is an anonymous array of C<CPAN::Mirrored::By> objects to
ping.

The optional argument C<SEEN> is a hash reference used to track the
mirrors you've already pinged.

The optional argument C<CALLBACK> is a subroutine reference to call
after each ping. It gets the C<CPAN::Mirrored::By> object after each
ping.
d253 1
a253 1
    my( $self, $mirror_list, $seen, $callback ) = @@_;
d255 7
a261 7
    $seen = {} unless defined $seen;
    croak "The mirror list argument must be an array reference"
        unless ref $mirror_list eq ref [];
    croak "The seen argument must be a hash reference"
        unless ref $seen eq ref {};
    croak "callback must be a subroutine"
        if( defined $callback and ref $callback ne ref sub {} );
d263 1
a263 1
    my $timings = [];
d265 2
a266 2
        $seen->{$m->hostname} = $m;
        next unless eval{ $m->http };
d270 1
a270 1
            next unless defined $ping;
d281 12
a292 12
           if( defined $a->rtt and defined $b->rtt )     {
            $a->rtt <=> $b->rtt
            }
        elsif( defined $a->rtt and ! defined $b->rtt )   {
            return -1;
            }
        elsif( ! defined $a->rtt and defined $b->rtt )   {
            return 1;
            }
        elsif( ! defined $a->rtt and ! defined $b->rtt ) {
            return 0;
            }
d294 1
a294 1
        } @@$timings;
d301 5
a305 5
C<find_best_continents> goes through each continent and pings C<N>
random mirrors on that continent. It then orders the continents by
ascending median ping time. In list context, it returns the ordered list
of continent. In scalar context, it returns the same list as an
anonymous array.
d309 10
a318 10
    n        - the number of hosts to ping for each continent. Default: 3
    seen     - a hashref of cached hostname ping times
    verbose  - true or false for noisy or quiet. Default: false
    callback - a subroutine to run after each ping.
    ping_cache_limit - how long, in seconds, to reuse previous ping times.
        Default: 1 day

The C<seen> hash has hostnames as keys and anonymous arrays as values.
The anonymous array is a triplet of a C<CPAN::Mirrored::By> object, a
ping time, and the epoch time for the measurement.
d321 2
a322 6
time, and measurement time (the same things in the C<seen> hashref) as
arguments. C<find_best_continents> doesn't care what the callback does
and ignores the return value.

With a low value for C<N>, a single mirror might skew the results enough
to choose a worse continent. If you have that problem, try a larger
d330 9
a338 9
    $args{n}     ||=  3;
    $args{verbose} = 0 unless defined $args{verbose};
    $args{seen}    = {} unless defined $args{seen};
    croak "The seen argument must be a hash reference"
        unless ref $args{seen} eq ref {};
    $args{ping_cache_limit} = 24 * 60 * 60
        unless defined $args{ping_cache_time};
    croak "callback must be a subroutine"
        if( defined $args{callback} and ref $args{callback} ne ref sub {} );
d342 1
a342 1
        print "Testing $c\n" if $args{verbose};
d353 2
a354 2
                $self->get_mirrors_timings( [ $m ], @@args{qw(seen callback)} );
                next RANDOM unless defined $args{seen}{$m->hostname}->rtt;
d357 3
a359 3
                $m->hostname,
                join ' ', 1000 * $args{seen}{$m->hostname}->rtt
                    if $args{verbose};
d361 1
a361 1
            push @@tests, $args{seen}{$m->hostname}->rtt;
d364 2
a365 2
        my $median = $self->_get_median_ping_time( \@@tests, $args{verbose} );
        $medians{$c} = $median if defined $median;
d382 1
a382 1
    my ($self, $seen, $mirror, $ping_cache_limit ) = @@_;
d384 7
a390 7
    ( ! exists $seen->{$mirror->hostname} )
        or
    (
    ! defined $seen->{$mirror->hostname}->rtt
        or
    time - $seen->{$mirror->hostname}->rtt > $ping_cache_limit
    )
d394 1
a394 1
    my ($self, $tests, $verbose ) = @@_;
d396 1
a396 1
    my @@sorted = sort { $a <=> $b } @@$tests;
d398 9
a406 9
    my $median = do {
           if ( @@sorted == 0 ) { undef }
        elsif ( @@sorted == 1 ) { $sorted[0] }
        elsif ( @@sorted % 2 )  { $sorted[ int(@@sorted / 2) ] }
        else {
            my $mid_high = int(@@sorted/2);
            ($sorted[$mid_high-1] + $sorted[$mid_high])/2;
        }
    };
d408 1
a408 1
    printf "\t-->median time: %0.2f ms\n", $median * 1000 if $verbose;
d516 1
a516 1
    if ( $ping->can('port_number') ) {
d548 2
@


1.1.1.5
log
@Import perl-5.20.2
@
text
@d37 1
a37 1
$VERSION = "1.9601";
@


1.1.1.5.2.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d37 1
a37 1
$VERSION = "1.9601_01";
@


1.1.1.5.4.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d37 1
a37 1
$VERSION = "1.9601_01";
@


