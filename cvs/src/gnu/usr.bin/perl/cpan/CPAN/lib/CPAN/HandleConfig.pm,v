head	1.3;
access;
symbols
	PERL_5_24_2:1.1.1.6
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.5.0.2
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.4
	OPENBSD_5_8_BASE:1.1.1.5
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.31.55;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2016.07.25.10.53.00;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	FHUgABTHZQuYQh2B;

1.1
date	2010.09.24.14.49.06;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.06;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.06.54;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.49;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.52.42;	author afresh1;	state Exp;
branches;
next	1.1.1.5;
commitid	B31cAbBIXiCqnL97;

1.1.1.5
date	2015.04.25.19.10.15;	author afresh1;	state Exp;
branches
	1.1.1.5.2.1
	1.1.1.5.4.1;
next	1.1.1.6;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.6
date	2017.08.14.13.45.33;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;

1.1.1.5.2.1
date	2016.08.05.01.01.36;	author afresh1;	state Exp;
branches;
next	;
commitid	HjAJx2yjL4A8HWon;

1.1.1.5.4.1
date	2016.08.05.01.00.52;	author afresh1;	state Exp;
branches;
next	;
commitid	wK3bUiy9jNch0Key;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package CPAN::HandleConfig;
use strict;
use vars qw(%can %keys $loading $VERSION);
use File::Path ();
use File::Spec ();
use File::Basename ();
use Carp ();

=head1 NAME

CPAN::HandleConfig - internal configuration handling for CPAN.pm

=cut 

$VERSION = "5.5006"; # see also CPAN::Config::VERSION at end of file

%can = (
        commit   => "Commit changes to disk",
        defaults => "Reload defaults from disk",
        help     => "Short help about 'o conf' usage",
        init     => "Interactive setting of all options",
);

# Q: where is the "How do I add a new config option" HOWTO?
# A1: svn diff -r 757:758 # where dagolden added test_report [git e997b71de88f1019a1472fc13cb97b1b7f96610f]
# A2: svn diff -r 985:986 # where andk added yaml_module [git 312b6d9b12b1bdec0b6e282d853482145475021f]
# A3: 1. add new config option to %keys below
#     2. add a Pod description in CPAN::FirstTime; it should include a
#        prompt line; see others for examples
#     3. add a "matcher" section in CPAN::FirstTime::init that includes
#        a prompt function; see others for examples
#     4. add config option to documentation section in CPAN.pm

%keys = map { $_ => undef }
    (
     "applypatch",
     "auto_commit",
     "build_cache",
     "build_dir",
     "build_dir_reuse",
     "build_requires_install_policy",
     "bzip2",
     "cache_metadata",
     "check_sigs",
     "colorize_debug",
     "colorize_output",
     "colorize_print",
     "colorize_warn",
     "commandnumber_in_prompt",
     "commands_quote",
     "connect_to_internet_ok",
     "cpan_home",
     "curl",
     "dontload_hash", # deprecated after 1.83_68 (rev. 581)
     "dontload_list",
     "ftp",
     "ftp_passive",
     "ftp_proxy",
     "ftpstats_size",
     "ftpstats_period",
     "getcwd",
     "gpg",
     "gzip",
     "halt_on_failure",
     "histfile",
     "histsize",
     "http_proxy",
     "inactivity_timeout",
     "index_expire",
     "inhibit_startup_message",
     "keep_source_where",
     "load_module_verbosity",
     "lynx",
     "make",
     "make_arg",
     "make_install_arg",
     "make_install_make_command",
     "makepl_arg",
     "mbuild_arg",
     "mbuild_install_arg",
     "mbuild_install_build_command",
     "mbuildpl_arg",
     "ncftp",
     "ncftpget",
     "no_proxy",
     "pager",
     "password",
     "patch",
     "patches_dir",
     "perl5lib_verbosity",
     "plugin_list",
     "prefer_external_tar",
     "prefer_installer",
     "prefs_dir",
     "prerequisites_policy",
     "proxy_pass",
     "proxy_user",
     "randomize_urllist",
     "recommends_policy",
     "scan_cache",
     "shell",
     "show_unparsable_versions",
     "show_upload_date",
     "show_zero_versions",
     "suggests_policy",
     "tar",
     "tar_verbosity",
     "term_is_latin",
     "term_ornaments",
     "test_report",
     "trust_test_report_history",
     "unzip",
     "urllist",
     "use_prompt_default",
     "use_sqlite",
     "username",
     "version_timeout",
     "wait_list",
     "wget",
     "yaml_load_code",
     "yaml_module",
    );

my %prefssupport = map { $_ => 1 }
    (
     "build_requires_install_policy",
     "check_sigs",
     "make",
     "make_install_make_command",
     "prefer_installer",
     "test_report",
    );

# returns true on successful action
sub edit {
    my($self,@@args) = @@_;
    return unless @@args;
    CPAN->debug("self[$self]args[".join(" | ",@@args)."]");
    my($o,$str,$func,$args,$key_exists);
    $o = shift @@args;
    if($can{$o}) {
        my $success = $self->$o(args => \@@args); # o conf init => sub init => sub load
        unless ($success) {
            die "Panic: could not configure CPAN.pm for args [@@args]. Giving up.";
        }
    } else {
        CPAN->debug("o[$o]") if $CPAN::DEBUG;
        unless (exists $keys{$o}) {
            $CPAN::Frontend->mywarn("Warning: unknown configuration variable '$o'\n");
        }
        my $changed;


        # one day I used randomize_urllist for a boolean, so we must
        # list them explicitly --ak
        if (0) {
        } elsif ($o =~ /^(wait_list|urllist|dontload_list|plugin_list)$/) {

            #
            # ARRAYS
            #

            $func = shift @@args;
            $func ||= "";
            CPAN->debug("func[$func]args[@@args]") if $CPAN::DEBUG;
            # Let's avoid eval, it's easier to comprehend without.
            if ($func eq "push") {
                push @@{$CPAN::Config->{$o}}, @@args;
                $changed = 1;
            } elsif ($func eq "pop") {
                pop @@{$CPAN::Config->{$o}};
                $changed = 1;
            } elsif ($func eq "shift") {
                shift @@{$CPAN::Config->{$o}};
                $changed = 1;
            } elsif ($func eq "unshift") {
                unshift @@{$CPAN::Config->{$o}}, @@args;
                $changed = 1;
            } elsif ($func eq "splice") {
                my $offset = shift @@args || 0;
                my $length = shift @@args || 0;
                splice @@{$CPAN::Config->{$o}}, $offset, $length, @@args; # may warn
                $changed = 1;
            } elsif ($func) {
                $CPAN::Config->{$o} = [$func, @@args];
                $changed = 1;
            } else {
                $self->prettyprint($o);
            }
            if ($changed) {
                if ($o eq "urllist") {
                    # reset the cached values
                    undef $CPAN::FTP::Thesite;
                    undef $CPAN::FTP::Themethod;
                    $CPAN::Index::LAST_TIME = 0;
                } elsif ($o eq "dontload_list") {
                    # empty it, it will be built up again
                    $CPAN::META->{dontload_hash} = {};
                }
            }
        } elsif ($o =~ /_hash$/) {

            #
            # HASHES
            #

            if (@@args==1 && $args[0] eq "") {
                @@args = ();
            } elsif (@@args % 2) {
                push @@args, "";
            }
            $CPAN::Config->{$o} = { @@args };
            $changed = 1;
        } else {

            #
            # SCALARS
            #

            if (defined $args[0]) {
                $CPAN::CONFIG_DIRTY = 1;
                $CPAN::Config->{$o} = $args[0];
                $changed = 1;
            }
            $self->prettyprint($o)
                if exists $keys{$o} or defined $CPAN::Config->{$o};
        }
        if ($changed) {
            if ($CPAN::Config->{auto_commit}) {
                $self->commit;
            } else {
                $CPAN::CONFIG_DIRTY = 1;
                $CPAN::Frontend->myprint("Please use 'o conf commit' to ".
                                         "make the config permanent!\n\n");
            }
        }
    }
}

sub prettyprint {
    my($self,$k) = @@_;
    my $v = $CPAN::Config->{$k};
    if (ref $v) {
        my(@@report);
        if (ref $v eq "ARRAY") {
            @@report = map {"\t$_ \[$v->[$_]]\n"} 0..$#$v;
        } else {
            @@report = map
                {
                    sprintf "\t%-18s => %s\n",
                               "[$_]",
                                        defined $v->{$_} ? "[$v->{$_}]" : "undef"
                } keys %$v;
        }
        $CPAN::Frontend->myprint(
                                 join(
                                      "",
                                      sprintf(
                                              "    %-18s\n",
                                              $k
                                             ),
                                      @@report
                                     )
                                );
    } elsif (defined $v) {
        $CPAN::Frontend->myprint(sprintf "    %-18s [%s]\n", $k, $v);
    } else {
        $CPAN::Frontend->myprint(sprintf "    %-18s undef\n", $k);
    }
}

# generally, this should be called without arguments so that the currently
# loaded config file is where changes are committed.
sub commit {
    my($self,@@args) = @@_;
    CPAN->debug("args[@@args]") if $CPAN::DEBUG;
    if ($CPAN::RUN_DEGRADED) {
        $CPAN::Frontend->mydie(
            "'o conf commit' disabled in ".
            "degraded mode. Maybe try\n".
            " !undef \$CPAN::RUN_DEGRADED\n"
        );
    }
    my ($configpm, $must_reload);

    # XXX does anything do this? can it be simplified? -- dagolden, 2011-01-19
    if (@@args) {
      if ($args[0] eq "args") {
        # we have not signed that contract
      } else {
        $configpm = $args[0];
      }
    }

    # use provided name or the current config or create a new MyConfig
    $configpm ||= require_myconfig_or_config() || make_new_config();

    # commit to MyConfig if we can't write to Config
    if ( ! -w $configpm && $configpm =~ m{CPAN/Config\.pm} ) {
        my $myconfig = _new_config_name();
        $CPAN::Frontend->mywarn(
            "Your $configpm file\n".
            "is not writable. I will attempt to write your configuration to\n" .
            "$myconfig instead.\n\n"
        );
        $configpm = make_new_config();
        $must_reload++; # so it gets loaded as $INC{'CPAN/MyConfig.pm'}
    }

    # XXX why not just "-w $configpm"? -- dagolden, 2011-01-19
    my($mode);
    if (-f $configpm) {
        $mode = (stat $configpm)[2];
        if ($mode && ! -w _) {
            _die_cant_write_config($configpm);
        }
    }

    $self->_write_config_file($configpm);
    require_myconfig_or_config() if $must_reload;

    #$mode = 0444 | ( $mode & 0111 ? 0111 : 0 );
    #chmod $mode, $configpm;
###why was that so?    $self->defaults;
    $CPAN::Frontend->myprint("commit: wrote '$configpm'\n");
    $CPAN::CONFIG_DIRTY = 0;
    1;
}

sub _write_config_file {
    my ($self, $configpm) = @@_;
    my $msg;
    $msg = <<EOF if $configpm =~ m{CPAN/Config\.pm};

# This is CPAN.pm's systemwide configuration file. This file provides
# defaults for users, and the values can be changed in a per-user
# configuration file.

EOF
    $msg ||= "\n";
    my($fh) = FileHandle->new;
    rename $configpm, "$configpm~" if -f $configpm;
    open $fh, ">$configpm" or
        $CPAN::Frontend->mydie("Couldn't open >$configpm: $!");
    $fh->print(qq[$msg\$CPAN::Config = \{\n]);
    foreach (sort keys %$CPAN::Config) {
        unless (exists $keys{$_}) {
            # do not drop them: forward compatibility!
            $CPAN::Frontend->mywarn("Unknown config variable '$_'\n");
            next;
        }
        $fh->print(
            "  '$_' => ",
            $self->neatvalue($CPAN::Config->{$_}),
            ",\n"
        );
    }
    $fh->print("};\n1;\n__END__\n");
    close $fh;

    return;
}


# stolen from MakeMaker; not taking the original because it is buggy;
# bugreport will have to say: keys of hashes remain unquoted and can
# produce syntax errors
sub neatvalue {
    my($self, $v) = @@_;
    return "undef" unless defined $v;
    my($t) = ref $v;
    unless ($t) {
        $v =~ s/\\/\\\\/g;
        return "q[$v]";
    }
    if ($t eq 'ARRAY') {
        my(@@m, @@neat);
        push @@m, "[";
        foreach my $elem (@@$v) {
            push @@neat, "q[$elem]";
        }
        push @@m, join ", ", @@neat;
        push @@m, "]";
        return join "", @@m;
    }
    return "$v" unless $t eq 'HASH';
    my(@@m, $key, $val);
    while (($key,$val) = each %$v) {
        last unless defined $key; # cautious programming in case (undef,undef) is true
        push(@@m,"q[$key]=>".$self->neatvalue($val)) ;
    }
    return "{ ".join(', ',@@m)." }";
}

sub defaults {
    my($self) = @@_;
    if ($CPAN::RUN_DEGRADED) {
                             $CPAN::Frontend->mydie(
                                                    "'o conf defaults' disabled in ".
                                                    "degraded mode. Maybe try\n".
                                                    " !undef \$CPAN::RUN_DEGRADED\n"
                                                   );
    }
    my $done;
    for my $config (qw(CPAN/MyConfig.pm CPAN/Config.pm)) {
        if ($INC{$config}) {
            CPAN->debug("INC{'$config'}[$INC{$config}]") if $CPAN::DEBUG;
            CPAN::Shell->_reload_this($config,{reloforce => 1});
            $CPAN::Frontend->myprint("'$INC{$config}' reread\n");
            last;
        }
    }
    $CPAN::CONFIG_DIRTY = 0;
    1;
}

=head2 C<< CLASS->safe_quote ITEM >>

Quotes an item to become safe against spaces
in shell interpolation. An item is enclosed
in double quotes if:

  - the item contains spaces in the middle
  - the item does not start with a quote

This happens to avoid shell interpolation
problems when whitespace is present in
directory names.

This method uses C<commands_quote> to determine
the correct quote. If C<commands_quote> is
a space, no quoting will take place.


if it starts and ends with the same quote character: leave it as it is

if it contains no whitespace: leave it as it is

if it contains whitespace, then

if it contains quotes: better leave it as it is

else: quote it with the correct quote type for the box we're on

=cut

{
    # Instead of patching the guess, set commands_quote
    # to the right value
    my ($quotes,$use_quote)
        = $^O eq 'MSWin32'
            ? ('"', '"')
                : (q{"'}, "'")
                    ;

    sub safe_quote {
        my ($self, $command) = @@_;
        # Set up quote/default quote
        my $quote = $CPAN::Config->{commands_quote} || $quotes;

        if ($quote ne ' '
            and defined($command )
            and $command =~ /\s/
            and $command !~ /[$quote]/) {
            return qq<$use_quote$command$use_quote>
        }
        return $command;
    }
}

sub init {
    my($self,@@args) = @@_;
    CPAN->debug("self[$self]args[".join(",",@@args)."]");
    $self->load(do_init => 1, @@args);
    1;
}

# Loads CPAN::MyConfig or fall-back to CPAN::Config. Will not reload a file
# if already loaded. Returns the path to the file %INC or else the empty string
#
# Note -- if CPAN::Config were loaded and CPAN::MyConfig subsequently
# created, calling this again will leave *both* in %INC

sub require_myconfig_or_config () {
    if (   $INC{"CPAN/MyConfig.pm"} || _try_loading("CPAN::MyConfig", cpan_home())) {
        return $INC{"CPAN/MyConfig.pm"};
    }
    elsif ( $INC{"CPAN/Config.pm"} || _try_loading("CPAN::Config") ) {
        return $INC{"CPAN/Config.pm"};
    }
    else {
        return q{};
    }
}

# Load a module, but ignore "can't locate..." errors
# Optionally take a list of directories to add to @@INC for the load
sub _try_loading {
    my ($module, @@dirs) = @@_;
    (my $file = $module) =~ s{::}{/}g;
    $file .= ".pm";

    local @@INC = @@INC;
    for my $dir ( @@dirs ) {
        if ( -f File::Spec->catfile($dir, $file) ) {
            unshift @@INC, $dir;
            last;
        }
    }

    eval { require $file };
    my $err_myconfig = $@@;
    if ($err_myconfig and $err_myconfig !~ m#locate \Q$file\E#) {
        die "Error while requiring ${module}:\n$err_myconfig";
    }
    return $INC{$file};
}

# prioritized list of possible places for finding "CPAN/MyConfig.pm"
sub cpan_home_dir_candidates {
    my @@dirs;
    my $old_v = $CPAN::Config->{load_module_verbosity};
    $CPAN::Config->{load_module_verbosity} = q[none];
    if ($CPAN::META->has_usable('File::HomeDir')) {
        if ($^O ne 'darwin') {
            push @@dirs, File::HomeDir->my_data;
            # my_data is ~/Library/Application Support on darwin,
            # which causes issues in the toolchain.
        }
        push @@dirs, File::HomeDir->my_home;
    }
    # Windows might not have HOME, so check it first
    push @@dirs, $ENV{HOME} if $ENV{HOME};
    # Windows might have these instead
    push( @@dirs, File::Spec->catpath($ENV{HOMEDRIVE}, $ENV{HOMEPATH}, '') )
      if $ENV{HOMEDRIVE} && $ENV{HOMEPATH};
    push @@dirs, $ENV{USERPROFILE} if $ENV{USERPROFILE};

    $CPAN::Config->{load_module_verbosity} = $old_v;
    my $dotcpan = $^O eq 'VMS' ? '_cpan' : '.cpan';
    @@dirs = map { File::Spec->catdir($_, $dotcpan) } grep { defined } @@dirs;
    return wantarray ? @@dirs : $dirs[0];
}

sub load {
    my($self, %args) = @@_;
    $CPAN::Be_Silent+=0; # protect against 'used only once'
    $CPAN::Be_Silent++ if $args{be_silent}; # do not use; planned to be removed in 2011
    my $do_init = delete $args{do_init} || 0;
    my $make_myconfig = delete $args{make_myconfig};
    $loading = 0 unless defined $loading;

    my $configpm = require_myconfig_or_config;
    my @@miss = $self->missing_config_data;
    CPAN->debug("do_init[$do_init]loading[$loading]miss[@@miss]") if $CPAN::DEBUG;
    return unless $do_init || @@miss;

    # I'm not how we'd ever wind up in a recursive loop, but I'm leaving
    # this here for safety's sake -- dagolden, 2011-01-19
    return if $loading;
    local $loading = ($loading||0) + 1;

    # Warn if we have a config file, but things were found missing
    if ($configpm && @@miss && !$do_init) {
        if ($make_myconfig || ( ! -w $configpm && $configpm =~ m{CPAN/Config\.pm})) {
            $configpm = make_new_config();
            $CPAN::Frontend->myprint(<<END);
The system CPAN configuration file has provided some default values,
but you need to complete the configuration dialog for CPAN.pm.
Configuration will be written to
 <<$configpm>>
END
        }
        else {
            $CPAN::Frontend->myprint(<<END);
Sorry, we have to rerun the configuration dialog for CPAN.pm due to
some missing parameters. Configuration will be written to
 <<$configpm>>

END
        }
    }

    require CPAN::FirstTime;
    return CPAN::FirstTime::init($configpm || make_new_config(), %args);
}

# Creates a new, empty config file at the preferred location
# Any existing will be renamed with a ".bak" suffix if possible
# If the file cannot be created, an exception is thrown
sub make_new_config {
    my $configpm = _new_config_name();
    my $configpmdir = File::Basename::dirname( $configpm );
    File::Path::mkpath($configpmdir) unless -d $configpmdir;

    if ( -w $configpmdir ) {
        #_#_# following code dumped core on me with 5.003_11, a.k.
        if( -f $configpm ) {
            my $configpm_bak = "$configpm.bak";
            unlink $configpm_bak if -f $configpm_bak;
            if( rename $configpm, $configpm_bak ) {
                $CPAN::Frontend->mywarn(<<END);
Old configuration file $configpm
    moved to $configpm_bak
END
            }
        }
        my $fh = FileHandle->new;
        if ($fh->open(">$configpm")) {
            $fh->print("1;\n");
            return $configpm;
        }
    }
    _die_cant_write_config($configpm);
}

sub _die_cant_write_config {
    my ($configpm) = @@_;
    $CPAN::Frontend->mydie(<<"END");
WARNING: CPAN.pm is unable to write a configuration file.  You
must be able to create and write to '$configpm'.

Aborting configuration.
END

}

# From candidate directories, we would like (in descending preference order):
#   * the one that contains a MyConfig file
#   * one that exists (even without MyConfig)
#   * the first one on the list
sub cpan_home {
    my @@dirs = cpan_home_dir_candidates();
    for my $d (@@dirs) {
        return $d if -f "$d/CPAN/MyConfig.pm";
    }
    for my $d (@@dirs) {
        return $d if -d $d;
    }
    return $dirs[0];
}

sub _new_config_name {
    return File::Spec->catfile(cpan_home(), 'CPAN', 'MyConfig.pm');
}

# returns mandatory but missing entries in the Config
sub missing_config_data {
    my(@@miss);
    for (
         "auto_commit",
         "build_cache",
         "build_dir",
         "cache_metadata",
         "cpan_home",
         "ftp_proxy",
         #"gzip",
         "http_proxy",
         "index_expire",
         #"inhibit_startup_message",
         "keep_source_where",
         #"make",
         "make_arg",
         "make_install_arg",
         "makepl_arg",
         "mbuild_arg",
         "mbuild_install_arg",
         ($^O eq "MSWin32" ? "" : "mbuild_install_build_command"),
         "mbuildpl_arg",
         "no_proxy",
         #"pager",
         "prerequisites_policy",
         "scan_cache",
         #"tar",
         #"unzip",
         "urllist",
        ) {
        next unless exists $keys{$_};
        push @@miss, $_ unless defined $CPAN::Config->{$_};
    }
    return @@miss;
}

sub help {
    $CPAN::Frontend->myprint(q[
Known options:
  commit    commit session changes to disk
  defaults  reload default config values from disk
  help      this help
  init      enter a dialog to set all or a set of parameters

Edit key values as in the following (the "o" is a literal letter o):
  o conf build_cache 15
  o conf build_dir "/foo/bar"
  o conf urllist shift
  o conf urllist unshift ftp://ftp.foo.bar/
  o conf inhibit_startup_message 1

]);
    1; #don't reprint CPAN::Config
}

sub cpl {
    my($word,$line,$pos) = @@_;
    $word ||= "";
    CPAN->debug("word[$word] line[$line] pos[$pos]") if $CPAN::DEBUG;
    my(@@words) = split " ", substr($line,0,$pos+1);
    if (
        defined($words[2])
        and
        $words[2] =~ /list$/
        and
        (
        @@words == 3
        ||
        @@words == 4 && length($word)
        )
       ) {
        return grep /^\Q$word\E/, qw(splice shift unshift pop push);
    } elsif (defined($words[2])
             and
             $words[2] eq "init"
             and
            (
             @@words == 3
             ||
             @@words >= 4 && length($word)
            )) {
        return sort grep /^\Q$word\E/, keys %keys;
    } elsif (@@words >= 4) {
        return ();
    }
    my %seen;
    my(@@o_conf) =  sort grep { !$seen{$_}++ }
        keys %can,
            keys %$CPAN::Config,
                keys %keys;
    return grep /^\Q$word\E/, @@o_conf;
}

sub prefs_lookup {
    my($self,$distro,$what) = @@_;

    if ($prefssupport{$what}) {
        return $CPAN::Config->{$what} unless
            $distro
                and $distro->prefs
                    and $distro->prefs->{cpanconfig}
                        and defined $distro->prefs->{cpanconfig}{$what};
        return $distro->prefs->{cpanconfig}{$what};
    } else {
        $CPAN::Frontend->mywarn("Warning: $what not yet officially ".
                                "supported for distroprefs, doing a normal lookup");
        return $CPAN::Config->{$what};
    }
}


{
    package
        CPAN::Config; ####::###### #hide from indexer
    # note: J. Nick Koston wrote me that they are using
    # CPAN::Config->commit although undocumented. I suggested
    # CPAN::Shell->o("conf","commit") even when ugly it is at least
    # documented

    # that's why I added the CPAN::Config class with autoload and
    # deprecated warning

    use strict;
    use vars qw($AUTOLOAD $VERSION);
    $VERSION = "5.5006";

    # formerly CPAN::HandleConfig was known as CPAN::Config
    sub AUTOLOAD { ## no critic
        my $class = shift; # e.g. in dh-make-perl: CPAN::Config
        my($l) = $AUTOLOAD;
        $CPAN::Frontend->mywarn("Dispatching deprecated method '$l' to CPAN::HandleConfig\n");
        $l =~ s/.*:://;
        CPAN::HandleConfig->$l(@@_);
    }
}

1;

__END__

=head1 LICENSE

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut

# Local Variables:
# mode: cperl
# cperl-indent-level: 4
# End:
# vim: ts=4 sts=4 sw=4:
@


1.2
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.


ok deraadt@@
@
text
@d15 1
a15 1
$VERSION = "5.5005_01"; # see also CPAN::Config::VERSION at end of file
d91 1
d157 1
a157 1
        } elsif ($o =~ /^(wait_list|urllist|dontload_list)$/) {
d772 1
a772 1
    $VERSION = "5.5005_01";
@


1.1
log
@Initial revision
@
text
@d4 4
d9 7
a15 1
$VERSION = "5.5001"; # see also CPAN::Config::VERSION at end of file
d25 2
a26 2
# A1: svn diff -r 757:758 # where dagolden added test_report
# A2: svn diff -r 985:986 # where andk added yaml_module
d91 1
d98 1
d104 1
d113 1
d271 2
d277 5
a281 5
                             $CPAN::Frontend->mydie(
                                                    "'o conf commit' disabled in ".
                                                    "degraded mode. Maybe try\n".
                                                    " !undef \$CPAN::RUN_DEGRADED\n"
                                                   );
d283 3
a285 1
    my $configpm;
d293 14
a306 8
    unless (defined $configpm) {
        $configpm ||= $INC{"CPAN/MyConfig.pm"};
        $configpm ||= $INC{"CPAN/Config.pm"};
        $configpm || Carp::confess(q{
CPAN::Config::commit called without an argument.
Please specify a filename where to save the configuration or try
"o conf init" to have an interactive course through configing.
});
d308 2
d314 1
a314 1
            Carp::confess("$configpm is not writable");
d318 13
d332 1
a332 2
    my $home = home();
    $msg = <<EOF unless $configpm =~ /MyConfig/;
d336 1
a336 2
# configuration file. The user-config file is being looked for as
# $home/.cpan/CPAN/MyConfig.pm.
a356 1

d360 1
a360 6
    #$mode = 0444 | ( $mode & 0111 ? 0111 : 0 );
    #chmod $mode, $configpm;
###why was that so?    $self->defaults;
    $CPAN::Frontend->myprint("commit: wrote '$configpm'\n");
    $CPAN::CONFIG_DIRTY = 0;
    1;
d363 1
d473 1
a473 1
    $self->load(doit => 1, @@args);
d477 2
a478 2
# This is a piece of repeated code that is abstracted here for
# maintainability.  RMB
d480 13
a492 25
sub _configpmtest {
    my($configpmdir, $configpmtest) = @@_;
    if (-w $configpmtest) {
        return $configpmtest;
    } elsif (-w $configpmdir) {
        #_#_# following code dumped core on me with 5.003_11, a.k.
        my $configpm_bak = "$configpmtest.bak";
        unlink $configpm_bak if -f $configpm_bak;
        if( -f $configpmtest ) {
            if( rename $configpmtest, $configpm_bak ) {
                $CPAN::Frontend->mywarn(<<END);
Old configuration file $configpmtest
    moved to $configpm_bak
END
            }
        }
        my $fh = FileHandle->new;
        if ($fh->open(">$configpmtest")) {
            $fh->print("1;\n");
            return $configpmtest;
        } else {
            # Should never happen
            Carp::confess("Cannot open >$configpmtest");
        }
    } else { return }
d495 7
a501 2
sub require_myconfig_or_config () {
    return if $INC{"CPAN/MyConfig.pm"};
d503 8
a510 3
    my $home = home();
    unshift @@INC, File::Spec->catdir($home,'.cpan');
    eval { require CPAN::MyConfig };
d512 2
a513 9
    if ($err_myconfig and $err_myconfig !~ m#locate CPAN/MyConfig\.pm#) {
        die "Error while requiring CPAN::MyConfig:\n$err_myconfig";
    }
    unless ($INC{"CPAN/MyConfig.pm"}) { # this guy has settled his needs already
      eval {require CPAN::Config;}; # not everybody has one
      my $err_config = $@@;
      if ($err_config and $err_config !~ m#locate CPAN/Config\.pm#) {
          die "Error while requiring CPAN::Config:\n$err_config";
      }
d515 1
d518 3
a520 10
sub home () {
    my $home;
    # Suppress load messages until we load the config and know whether
    # load messages are desired.  Otherwise, it's unexpected and odd 
    # why one load message pops up even when verbosity is turned off.
    # This means File::HomeDir load messages are never seen, but I
    # think that's probably OK -- DAGOLDEN
    
    # 5.6.2 seemed to segfault localizing a value in a hashref 
    # so do it manually instead
d523 15
a537 12
    if ($CPAN::META->has_usable("File::HomeDir")) {
        if ($^O eq 'darwin') {
            $home = File::HomeDir->my_home; # my_data is ~/Library/Application Support on darwin,
                                            # which causes issues in the toolchain.
        }
        else {
            $home = File::HomeDir->my_data || File::HomeDir->my_home;
       }
    }
    unless (defined $home) {
        $home = $ENV{HOME};
    }
d539 3
a541 1
    $home;
d546 4
a549 3
    $CPAN::Be_Silent++ if $args{be_silent};
    my $doit;
    $doit = delete $args{doit} || 0;
d552 1
a552 2
    use Carp;
    require_myconfig_or_config;
d554 5
a558 2
    CPAN->debug("doit[$doit]loading[$loading]miss[@@miss]") if $CPAN::DEBUG;
    return unless $doit || @@miss;
d562 10
a571 23
    require CPAN::FirstTime;
    my($redo,$configpm,$fh);
    if (defined $INC{"CPAN/Config.pm"} && -w $INC{"CPAN/Config.pm"}) {
        $configpm = $INC{"CPAN/Config.pm"};
        $redo++;
    } elsif (defined $INC{"CPAN/MyConfig.pm"} && -w $INC{"CPAN/MyConfig.pm"}) {
        $configpm = $INC{"CPAN/MyConfig.pm"};
        $redo++;
    } else {
        my($path_to_cpan) = File::Basename::dirname($INC{"CPAN.pm"});
        my($configpmdir) = File::Spec->catdir($path_to_cpan,"CPAN");
        my($configpmtest) = File::Spec->catfile($configpmdir,"Config.pm");
        my $inc_key;
        if (-d $configpmdir or File::Path::mkpath($configpmdir)) {
            $configpm = _configpmtest($configpmdir,$configpmtest);
            $inc_key = "CPAN/Config.pm";
        }
        unless ($configpm) {
            $configpmdir = File::Spec->catdir(home,".cpan","CPAN");
            File::Path::mkpath($configpmdir);
            $configpmtest = File::Spec->catfile($configpmdir,"MyConfig.pm");
            $configpm = _configpmtest($configpmdir,$configpmtest);
            $inc_key = "CPAN/MyConfig.pm";
d573 5
a577 8
        if ($configpm) {
          $INC{$inc_key} = $configpm;
        } else {
          my $myconfigpm = File::Spec->catfile(home,".cpan","CPAN","MyConfig.pm");
          $CPAN::Frontend->mydie(<<"END");
WARNING: CPAN.pm is unable to write a configuration file.  You need write
access to your default perl library directories or you must be able to
create and write to '$myconfigpm'.
a578 1
Aborting configuration.
d581 1
d583 29
d613 8
a620 6
    local($") = ", ";
    if ($redo && !$doit) {
        $CPAN::Frontend->myprint(<<END);
Sorry, we have to rerun the configuration dialog for CPAN.pm due to
some missing parameters...  Will write to
 <<$configpm>>
d622 1
d624 11
a634 1
        $args{args} = \@@miss;
d636 4
a639 2
    my $initialized = CPAN::FirstTime::init($configpm, %args);
    return $initialized;
d642 3
d771 1
a771 1
    $VERSION = "5.5001";
d798 1
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a3 4
use File::Path ();
use File::Spec ();
use File::Basename ();
use Carp ();
d5 1
a5 1
$VERSION = "5.5003"; # see also CPAN::Config::VERSION at end of file
d15 2
a16 2
# A1: svn diff -r 757:758 # where dagolden added test_report [git e997b71de88f1019a1472fc13cb97b1b7f96610f]
# A2: svn diff -r 985:986 # where andk added yaml_module [git 312b6d9b12b1bdec0b6e282d853482145475021f]
a80 1
     "prefer_external_tar",
a256 2
# generally, this should be called without arguments so that the currently
# loaded config file is where changes are committed.
d261 5
a265 5
        $CPAN::Frontend->mydie(
            "'o conf commit' disabled in ".
            "degraded mode. Maybe try\n".
            " !undef \$CPAN::RUN_DEGRADED\n"
        );
d267 1
a267 3
    my ($configpm, $must_reload);

    # XXX does anything do this? can it be simplified? -- dagolden, 2011-01-19
d275 8
a282 14

    # use provided name or the current config or create a new MyConfig
    $configpm ||= require_myconfig_or_config() || make_new_config();

    # commit to MyConfig if we can't write to Config
    if ( ! -w $configpm && $configpm =~ m{CPAN/Config\.pm} ) {
        my $myconfig = _new_config_name();
        $CPAN::Frontend->mywarn(
            "Your $configpm file\n".
            "is not writable. I will attempt to write your configuration to\n" .
            "$myconfig instead.\n\n"
        );
        $configpm = make_new_config();
        $must_reload++; # so it gets loaded as $INC{'CPAN/MyConfig.pm'}
a283 2

    # XXX why not just "-w $configpm"? -- dagolden, 2011-01-19
d288 1
a288 1
            _die_cant_write_config($configpm);
a291 13
    $self->_write_config_file($configpm);
    require_myconfig_or_config() if $must_reload;

    #$mode = 0444 | ( $mode & 0111 ? 0111 : 0 );
    #chmod $mode, $configpm;
###why was that so?    $self->defaults;
    $CPAN::Frontend->myprint("commit: wrote '$configpm'\n");
    $CPAN::CONFIG_DIRTY = 0;
    1;
}

sub _write_config_file {
    my ($self, $configpm) = @@_;
d293 2
a294 1
    $msg = <<EOF if $configpm =~ m{CPAN/Config\.pm};
d298 2
a299 1
# configuration file.
d320 1
d324 6
a329 1
    return;
a331 1

d441 1
a441 1
    $self->load(do_init => 1, @@args);
d445 2
a446 2
# Loads CPAN::MyConfig or fall-back to CPAN::Config. Will not reload a file
# if already loaded. Returns the path to the file %INC or else the empty string
d448 26
a473 2
# Note -- if CPAN::Config were loaded and CPAN::MyConfig subsequently
# created, calling this again will leave *both* in %INC
d476 8
a483 2
    if (   $INC{"CPAN/MyConfig.pm"} || _try_loading("CPAN::MyConfig", cpan_home())) {
        return $INC{"CPAN/MyConfig.pm"};
d485 6
a490 5
    elsif ( $INC{"CPAN/Config.pm"} || _try_loading("CPAN::Config") ) {
        return $INC{"CPAN/Config.pm"};
    }
    else {
        return q{};
d494 16
a509 12
# Load a module, but ignore "can't locate..." errors
# Optionally take a list of directories to add to @@INC for the load
sub _try_loading {
    my ($module, @@dirs) = @@_;
    (my $file = $module) =~ s{::}{/}g;
    $file .= ".pm";

    local @@INC = @@INC;
    for my $dir ( @@dirs ) {
        if ( -f File::Spec->catfile($dir, $file) ) {
            unshift @@INC, $dir;
            last;
d511 3
d515 2
a516 5

    eval { require $file };
    my $err_myconfig = $@@;
    if ($err_myconfig and $err_myconfig !~ m#locate \Q$file\E#) {
        die "Error while requiring ${module}:\n$err_myconfig";
a517 23
    return $INC{$file};
}

# prioritized list of possible places for finding "CPAN/MyConfig.pm"
sub cpan_home_dir_candidates {
    my @@dirs;
    my $old_v = $CPAN::Config->{load_module_verbosity};
    $CPAN::Config->{load_module_verbosity} = q[none];
    if ($CPAN::META->has_usable('File::HomeDir')) {
        if ($^O ne 'darwin') {
            push @@dirs, File::HomeDir->my_data;
            # my_data is ~/Library/Application Support on darwin,
            # which causes issues in the toolchain.
        }
        push @@dirs, File::HomeDir->my_home;
    }
    # Windows might not have HOME, so check it first
    push @@dirs, $ENV{HOME} if $ENV{HOME};
    # Windows might have these instead
    push( @@dirs, File::Spec->catpath($ENV{HOMEDRIVE}, $ENV{HOMEPATH}, '') )
      if $ENV{HOMEDRIVE} && $ENV{HOMEPATH};
    push @@dirs, $ENV{USERPROFILE} if $ENV{USERPROFILE};

d519 1
a519 2
    @@dirs = map { "$_/.cpan" } grep { defined } @@dirs;
    return wantarray ? @@dirs : $dirs[0];
d524 3
a526 4
    $CPAN::Be_Silent+=0; # protect against 'used only once'
    $CPAN::Be_Silent++ if $args{be_silent}; # do not use; planned to be removed in 2011
    my $do_init = delete $args{do_init} || 0;
    my $make_myconfig = delete $args{make_myconfig};
d529 2
a530 1
    my $configpm = require_myconfig_or_config;
d532 2
a533 5
    CPAN->debug("do_init[$do_init]loading[$loading]miss[@@miss]") if $CPAN::DEBUG;
    return unless $do_init || @@miss;

    # I'm not how we'd ever wind up in a recursive loop, but I'm leaving
    # this here for safety's sake -- dagolden, 2011-01-19
d537 23
a559 10
    # Warn if we have a config file, but things were found missing
    if ($configpm && @@miss && !$do_init) {
        if ($make_myconfig || ( ! -w $configpm && $configpm =~ m{CPAN/Config\.pm})) {
            $configpm = make_new_config();
            $CPAN::Frontend->myprint(<<END);
The system CPAN configuration file has provided some default values,
but you need to complete the configuration dialog for CPAN.pm.
Configuration will be written to
 <<$configpm>>
END
d561 8
a568 5
        else {
            $CPAN::Frontend->myprint(<<END);
Sorry, we have to rerun the configuration dialog for CPAN.pm due to
some missing parameters. Configuration will be written to
 <<$configpm>>
d570 1
a572 13
    }

    require CPAN::FirstTime;
    return CPAN::FirstTime::init($configpm || make_new_config(), %args);
}

# Creates a new, empty config file at the preferred location
# Any existing will be renamed with a ".bak" suffix if possible
# If the file cannot be created, an exception is thrown
sub make_new_config {
    my $configpm = _new_config_name();
    my $configpmdir = File::Basename::dirname( $configpm );
    File::Path::mkpath($configpmdir) unless -d $configpmdir;
a573 17
    if ( -w $configpmdir ) {
        #_#_# following code dumped core on me with 5.003_11, a.k.
        if( -f $configpm ) {
            my $configpm_bak = "$configpm.bak";
            unlink $configpm_bak if -f $configpm_bak;
            if( rename $configpm, $configpm_bak ) {
                $CPAN::Frontend->mywarn(<<END);
Old configuration file $configpm
    moved to $configpm_bak
END
            }
        }
        my $fh = FileHandle->new;
        if ($fh->open(">$configpm")) {
            $fh->print("1;\n");
            return $configpm;
        }
d575 6
a580 8
    _die_cant_write_config($configpm);
}

sub _die_cant_write_config {
    my ($configpm) = @@_;
    $CPAN::Frontend->mydie(<<"END");
WARNING: CPAN.pm is unable to write a configuration file.  You
must be able to create and write to '$configpm'.
a581 1
Aborting configuration.
d583 1
a583 11

}

# From candidate directories, we would like (in descending preference order):
#   * the one that contains a MyConfig file
#   * one that exists (even without MyConfig)
#   * the first one on the list
sub cpan_home {
    my @@dirs = cpan_home_dir_candidates();
    for my $d (@@dirs) {
        return $d if -f "$d/CPAN/MyConfig.pm";
d585 2
a586 4
    for my $d (@@dirs) {
        return $d if -d $d;
    }
    return $dirs[0];
a588 3
sub _new_config_name {
    return File::Spec->catfile(cpan_home(), 'CPAN', 'MyConfig.pm');
}
a741 1
# vim: ts=4 sts=4 sw=4:
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a8 6
=head1 NAME

CPAN::HandleConfig - internal configuration handling for CPAN.pm

=cut 

d530 1
a530 2
    my $dotcpan = $^O eq 'VMS' ? '_cpan' : '.cpan';
    @@dirs = map { File::Spec->catdir($_, $dotcpan) } grep { defined } @@dirs;
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@a97 1
     "recommends_policy",
a102 1
     "suggests_policy",
a110 1
     "use_prompt_default",
d768 1
a768 1
    $VERSION = "5.5002";
@


1.1.1.5
log
@Import perl-5.20.2
@
text
@d15 1
a15 1
$VERSION = "5.5005"; # see also CPAN::Config::VERSION at end of file
d771 1
a771 1
    $VERSION = "5.5005";
@


1.1.1.6
log
@Import perl-5.24.2
@
text
@d15 1
a15 1
$VERSION = "5.5006"; # see also CPAN::Config::VERSION at end of file
a90 1
     "plugin_list",
d156 1
a156 1
        } elsif ($o =~ /^(wait_list|urllist|dontload_list|plugin_list)$/) {
d771 1
a771 1
    $VERSION = "5.5006";
@


1.1.1.5.2.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d15 1
a15 1
$VERSION = "5.5005_01"; # see also CPAN::Config::VERSION at end of file
d771 1
a771 1
    $VERSION = "5.5005_01";
@


1.1.1.5.4.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d15 1
a15 1
$VERSION = "5.5005_01"; # see also CPAN::Config::VERSION at end of file
d771 1
a771 1
    $VERSION = "5.5005_01";
@


