head	1.3;
access;
symbols
	PERL_5_24_2:1.1.1.5
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.4.0.4
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.6
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.31.55;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2016.07.25.10.53.00;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	FHUgABTHZQuYQh2B;

1.1
date	2010.09.24.14.49.06;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.06;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.06.51;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.49;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.52.42;	author afresh1;	state Exp;
branches
	1.1.1.4.4.1
	1.1.1.4.6.1;
next	1.1.1.5;
commitid	B31cAbBIXiCqnL97;

1.1.1.5
date	2017.08.14.13.45.33;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;

1.1.1.4.4.1
date	2016.08.05.01.01.36;	author afresh1;	state Exp;
branches;
next	;
commitid	HjAJx2yjL4A8HWon;

1.1.1.4.6.1
date	2016.08.05.01.00.52;	author afresh1;	state Exp;
branches;
next	;
commitid	wK3bUiy9jNch0Key;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package App::Cpan;

use strict;
use warnings;
use vars qw($VERSION);

use if $] < 5.008 => 'IO::Scalar';

$VERSION = '1.63_01';

=head1 NAME

App::Cpan - easily interact with CPAN from the command line

=head1 SYNOPSIS

	# with arguments and no switches, installs specified modules
	cpan module_name [ module_name ... ]

	# with switches, installs modules with extra behavior
	cpan [-cfFimtTw] module_name [ module_name ... ]

	# use local::lib
	cpan -I module_name [ module_name ... ]

	# one time mirror override for faster mirrors
	cpan -p ...

	# with just the dot, install from the distribution in the
	# current directory
	cpan .

	# without arguments, starts CPAN.pm shell
	cpan

	# without arguments, but some switches
	cpan [-ahpruvACDLOP]

=head1 DESCRIPTION

This script provides a command interface (not a shell) to CPAN. At the
moment it uses CPAN.pm to do the work, but it is not a one-shot command
runner for CPAN.pm.

=head2 Options

=over 4

=item -a

Creates a CPAN.pm autobundle with CPAN::Shell->autobundle.

=item -A module [ module ... ]

Shows the primary maintainers for the specified modules.

=item -c module

Runs a `make clean` in the specified module's directories.

=item -C module [ module ... ]

Show the F<Changes> files for the specified modules

=item -D module [ module ... ]

Show the module details. This prints one line for each out-of-date module
(meaning, modules locally installed but have newer versions on CPAN).
Each line has three columns: module name, local version, and CPAN
version.

=item -f

Force the specified action, when it normally would have failed. Use this
to install a module even if its tests fail. When you use this option,
-i is not optional for installing a module when you need to force it:

	% cpan -f -i Module::Foo

=item -F

Turn off CPAN.pm's attempts to lock anything. You should be careful with
this since you might end up with multiple scripts trying to muck in the
same directory. This isn't so much of a concern if you're loading a special
config with C<-j>, and that config sets up its own work directories.

=item -g module [ module ... ]

Downloads to the current directory the latest distribution of the module.

=item -G module [ module ... ]

UNIMPLEMENTED

Download to the current directory the latest distribution of the
modules, unpack each distribution, and create a git repository for each
distribution.

If you want this feature, check out Yanick Champoux's C<Git::CPAN::Patch>
distribution.

=item -h

Print a help message and exit. When you specify C<-h>, it ignores all
of the other options and arguments.

=item -i

Install the specified modules. With no other switches, this switch
is implied.

=item -I

Load C<local::lib> (think like C<-I> for loading lib paths). Too bad
C<-l> was already taken.

=item -j Config.pm

Load the file that has the CPAN configuration data. This should have the
same format as the standard F<CPAN/Config.pm> file, which defines
C<$CPAN::Config> as an anonymous hash.

=item -J

Dump the configuration in the same format that CPAN.pm uses. This is useful
for checking the configuration as well as using the dump as a starting point
for a new, custom configuration.

=item -l

List all installed modules with their versions

=item -L author [ author ... ]

List the modules by the specified authors.

=item -m

Make the specified modules.

=item -M mirror1,mirror2,...

A comma-separated list of mirrors to use for just this run. The C<-P>
option can find them for you automatically.

=item -n

Do a dry run, but don't actually install anything. (unimplemented)

=item -O

Show the out-of-date modules.

=item -p

Ping the configured mirrors and print a report

=item -P

Find the best mirrors you could be using and use them for the current
session.

=item -r

Recompiles dynamically loaded modules with CPAN::Shell->recompile.

=item -t

Run a `make test` on the specified modules.

=item -T

Do not test modules. Simply install them.

=item -u

Upgrade all installed modules. Blindly doing this can really break things,
so keep a backup.

=item -v

Print the script version and CPAN.pm version then exit.

=item -V

Print detailed information about the cpan client.

=item -w

UNIMPLEMENTED

Turn on cpan warnings. This checks various things, like directory permissions,
and tells you about problems you might have.

=back

=head2 Examples

	# print a help message
	cpan -h

	# print the version numbers
	cpan -v

	# create an autobundle
	cpan -a

	# recompile modules
	cpan -r

	# upgrade all installed modules
	cpan -u

	# install modules ( sole -i is optional )
	cpan -i Netscape::Booksmarks Business::ISBN

	# force install modules ( must use -i )
	cpan -fi CGI::Minimal URI

	# install modules but without testing them
	cpan -Ti CGI::Minimal URI

=head2 Environment variables

There are several components in CPAN.pm that use environment variables.
The build tools, L<ExtUtils::MakeMaker> and L<Module::Build> use some,
while others matter to the levels above them. Some of these are specified
by the Perl Toolchain Gang:

Lancaster Concensus: L<https://github.com/Perl-Toolchain-Gang/toolchain-site/blob/master/lancaster-consensus.md>

Oslo Concensus: L<https://github.com/Perl-Toolchain-Gang/toolchain-site/blob/master/oslo-consensus.md>

=over 4

=item NONINTERACTIVE_TESTING

Assume no one is paying attention and skips prompts for distributions
that do that correctly. C<cpan(1)> sets this to C<1> unless it already
has a value (even if that value is false).

=item PERL_MM_USE_DEFAULT

Use the default answer for a prompted questions. C<cpan(1)> sets this
to C<1> unless it already has a value (even if that value is false).

=item CPAN_OPTS

As with C<PERL5OPTS>, a string of additional C<cpan(1)> options to
add to those you specify on the command line.

=item CPANSCRIPT_LOGLEVEL

The log level to use, with either the embedded, minimal logger or
L<Log::Log4perl> if it is installed. Possible values are the same as
the C<Log::Log4perl> levels: C<TRACE>, C<DEBUG>, C<INFO>, C<WARN>,
C<ERROR>, and C<FATAL>. The default is C<INFO>.

=item GIT_COMMAND

The path to the C<git> binary to use for the Git features. The default
is C</usr/local/bin/git>.

=back

=head2 Methods

=over 4

=cut

use autouse Carp => qw(carp croak cluck);
use CPAN 1.80 (); # needs no test
use Config;
use autouse Cwd => qw(cwd);
use autouse 'Data::Dumper' => qw(Dumper);
use File::Spec::Functions;
use File::Basename;
use Getopt::Std;

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Internal constants
use constant TRUE  => 1;
use constant FALSE => 0;


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# The return values
use constant HEY_IT_WORKED              =>   0;
use constant I_DONT_KNOW_WHAT_HAPPENED  =>   1; # 0b0000_0001
use constant ITS_NOT_MY_FAULT           =>   2;
use constant THE_PROGRAMMERS_AN_IDIOT   =>   4;
use constant A_MODULE_FAILED_TO_INSTALL =>   8;


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# set up the order of options that we layer over CPAN::Shell
BEGIN { # most of this should be in methods
use vars qw( @@META_OPTIONS $Default %CPAN_METHODS @@CPAN_OPTIONS  @@option_order
	%Method_table %Method_table_index );

@@META_OPTIONS = qw( h v V I g G M: C A D O l L a r p P j: J w T);

$Default = 'default';

%CPAN_METHODS = ( # map switches to method names in CPAN::Shell
	$Default => 'install',
	'c'      => 'clean',
	'f'      => 'force',
	'i'      => 'install',
	'm'      => 'make',
	't'      => 'test',
	'u'      => 'upgrade',
	'T'      => 'notest',
	);
@@CPAN_OPTIONS = grep { $_ ne $Default } sort keys %CPAN_METHODS;

@@option_order = ( @@META_OPTIONS, @@CPAN_OPTIONS );


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# map switches to the subroutines in this script, along with other information.
# use this stuff instead of hard-coded indices and values
sub NO_ARGS   () { 0 }
sub ARGS      () { 1 }
sub GOOD_EXIT () { 0 }

%Method_table = (
# key => [ sub ref, takes args?, exit value, description ]

	# options that do their thing first, then exit
	h =>  [ \&_print_help,        NO_ARGS, GOOD_EXIT, 'Printing help'                ],
	v =>  [ \&_print_version,     NO_ARGS, GOOD_EXIT, 'Printing version'             ],
	V =>  [ \&_print_details,     NO_ARGS, GOOD_EXIT, 'Printing detailed version'    ],

	# options that affect other options
	j =>  [ \&_load_config,          ARGS, GOOD_EXIT, 'Use specified config file'    ],
	J =>  [ \&_dump_config,       NO_ARGS, GOOD_EXIT, 'Dump configuration to stdout' ],
	F =>  [ \&_lock_lobotomy,     NO_ARGS, GOOD_EXIT, 'Turn off CPAN.pm lock files'  ],
	I =>  [ \&_load_local_lib,    NO_ARGS, GOOD_EXIT, 'Loading local::lib'           ],
	M =>  [ \&_use_these_mirrors,    ARGS, GOOD_EXIT, 'Setting per session mirrors'  ],
	P =>  [ \&_find_good_mirrors, NO_ARGS, GOOD_EXIT, 'Finding good mirrors'         ],
    w =>  [ \&_turn_on_warnings,  NO_ARGS, GOOD_EXIT, 'Turning on warnings'          ],

	# options that do their one thing
	g =>  [ \&_download,          NO_ARGS, GOOD_EXIT, 'Download the latest distro'        ],
	G =>  [ \&_gitify,            NO_ARGS, GOOD_EXIT, 'Down and gitify the latest distro' ],

	C =>  [ \&_show_Changes,         ARGS, GOOD_EXIT, 'Showing Changes file'         ],
	A =>  [ \&_show_Author,          ARGS, GOOD_EXIT, 'Showing Author'               ],
	D =>  [ \&_show_Details,         ARGS, GOOD_EXIT, 'Showing Details'              ],
	O =>  [ \&_show_out_of_date,  NO_ARGS, GOOD_EXIT, 'Showing Out of date'          ],
	l =>  [ \&_list_all_mods,     NO_ARGS, GOOD_EXIT, 'Listing all modules'          ],

	L =>  [ \&_show_author_mods,     ARGS, GOOD_EXIT, 'Showing author mods'          ],
	a =>  [ \&_create_autobundle, NO_ARGS, GOOD_EXIT, 'Creating autobundle'          ],
	p =>  [ \&_ping_mirrors,      NO_ARGS, GOOD_EXIT, 'Pinging mirrors'              ],

	r =>  [ \&_recompile,         NO_ARGS, GOOD_EXIT, 'Recompiling'                  ],
	u =>  [ \&_upgrade,           NO_ARGS, GOOD_EXIT, 'Running `make test`'          ],

	c =>  [ \&_default,              ARGS, GOOD_EXIT, 'Running `make clean`'         ],
	f =>  [ \&_default,              ARGS, GOOD_EXIT, 'Installing with force'        ],
	i =>  [ \&_default,              ARGS, GOOD_EXIT, 'Running `make install`'       ],
   'm' => [ \&_default,              ARGS, GOOD_EXIT, 'Running `make`'               ],
	t =>  [ \&_default,              ARGS, GOOD_EXIT, 'Running `make test`'          ],
	T =>  [ \&_default,              ARGS, GOOD_EXIT, 'Installing with notest'       ],
	);

%Method_table_index = (
	code        => 0,
	takes_args  => 1,
	exit_value  => 2,
	description => 3,
	);
}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# finally, do some argument processing

sub _stupid_interface_hack_for_non_rtfmers
	{
	no warnings 'uninitialized';
	shift @@ARGV if( $ARGV[0] eq 'install' and @@ARGV > 1 )
	}

sub _process_options
	{
	my %options;

	push @@ARGV, grep $_, split /\s+/, $ENV{CPAN_OPTS} || '';

	# if no arguments, just drop into the shell
	if( 0 == @@ARGV ) { CPAN::shell(); exit 0 }
	else
		{
		Getopt::Std::getopts(
		  join( '', @@option_order ), \%options );
		 \%options;
		}
	}

sub _process_setup_options
	{
	my( $class, $options ) = @@_;

	if( $options->{j} )
		{
		$Method_table{j}[ $Method_table_index{code} ]->( $options->{j} );
		delete $options->{j};
		}
	else
		{
		# this is what CPAN.pm would do otherwise
		local $CPAN::Be_Silent = 1;
		CPAN::HandleConfig->load(
			# be_silent  => 1, deprecated
			write_file => 0,
			);
		}

	$class->_turn_off_testing if $options->{T};

	foreach my $o ( qw(F I w P M) )
		{
		next unless exists $options->{$o};
		$Method_table{$o}[ $Method_table_index{code} ]->( $options->{$o} );
		delete $options->{$o};
		}

	if( $options->{o} )
		{
		my @@pairs = map { [ split /=/, $_, 2 ] } split /,/, $options->{o};
		foreach my $pair ( @@pairs )
			{
			my( $setting, $value ) = @@$pair;
			$CPAN::Config->{$setting} = $value;
		#	$logger->debug( "Setting [$setting] to [$value]" );
			}
		delete $options->{o};
		}

	my $option_count = grep { $options->{$_} } @@option_order;
	no warnings 'uninitialized';

	# don't count options that imply installation
	foreach my $opt ( qw(f T) ) { # don't count force or notest
		$option_count -= $options->{$opt};
		}

	# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
	# if there are no options, set -i (this line fixes RT ticket 16915)
	$options->{i}++ unless $option_count;
	}

sub _setup_environment {
# should we override or set defaults? If this were a true interactive
# session, we'd be in the CPAN shell.

# https://github.com/Perl-Toolchain-Gang/toolchain-site/blob/master/lancaster-consensus.md
	$ENV{NONINTERACTIVE_TESTING} = 1 unless defined $ENV{NONINTERACTIVE_TESTING};
	$ENV{PERL_MM_USE_DEFAULT}    = 1 unless defined $ENV{PERL_MM_USE_DEFAULT};
	}

=item run()

Just do it.

The C<run> method returns 0 on success and a positive number on
failure. See the section on EXIT CODES for details on the values.

=cut

my $logger;

sub run
	{
	my $class = shift;

	my $return_value = HEY_IT_WORKED; # assume that things will work

	$logger = $class->_init_logger;
	$logger->debug( "Using logger from @@{[ref $logger]}" );

	$class->_hook_into_CPANpm_report;
	$logger->debug( "Hooked into output" );

	$class->_stupid_interface_hack_for_non_rtfmers;
	$logger->debug( "Patched cargo culting" );

	my $options = $class->_process_options;
	$logger->debug( "Options are @@{[Dumper($options)]}" );

	$class->_process_setup_options( $options );

	$class->_setup_environment( $options );

	OPTION: foreach my $option ( @@option_order )
		{
		next unless $options->{$option};

		my( $sub, $takes_args, $description ) =
			map { $Method_table{$option}[ $Method_table_index{$_} ] }
			qw( code takes_args description );

		unless( ref $sub eq ref sub {} )
			{
			$return_value = THE_PROGRAMMERS_AN_IDIOT;
			last OPTION;
			}

		$logger->info( "$description -- ignoring other arguments" )
			if( @@ARGV && ! $takes_args );

		$return_value = $sub->( \ @@ARGV, $options );

		last;
		}

	return $return_value;
	}

{
package
  Local::Null::Logger; # hide from PAUSE

sub new { bless \ my $x, $_[0] }
sub AUTOLOAD { 1 }
sub DESTROY { 1 }
}

# load a module without searching the default entry for the current
# directory
sub _safe_load_module {
  my $name = shift;

  local @@INC = @@INC;
  pop @@INC if $INC[-1] eq '.';

  eval "require $name; 1";
}

sub _init_logger
	{
	my $log4perl_loaded = _safe_load_module("Log::Log4perl");

    unless( $log4perl_loaded )
        {
        print "Loading internal null logger. Install Log::Log4perl for logging messages\n";
        $logger = Local::Null::Logger->new;
        return $logger;
        }

	my $LEVEL = $ENV{CPANSCRIPT_LOGLEVEL} || 'INFO';

	Log::Log4perl::init( \ <<"HERE" );
log4perl.rootLogger=$LEVEL, A1
log4perl.appender.A1=Log::Log4perl::Appender::Screen
log4perl.appender.A1.layout=PatternLayout
log4perl.appender.A1.layout.ConversionPattern=%m%n
HERE

	$logger = Log::Log4perl->get_logger( 'App::Cpan' );
	}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub _default
	{
	my( $args, $options ) = @@_;

	my $switch = '';

	# choose the option that we're going to use
	# we'll deal with 'f' (force) later, so skip it
	foreach my $option ( @@CPAN_OPTIONS )
		{
		next if ( $option eq 'f' or $option eq 'T' );
		next unless $options->{$option};
		$switch = $option;
		last;
		}

	# 1. with no switches, but arguments, use the default switch (install)
	# 2. with no switches and no args, start the shell
	# 3. With a switch but no args, die! These switches need arguments.
	   if( not $switch and     @@$args ) { $switch = $Default;  }
	elsif( not $switch and not @@$args ) { return CPAN::shell() }
	elsif(     $switch and not @@$args )
		{ die "Nothing to $CPAN_METHODS{$switch}!\n"; }

	# Get and check the method from CPAN::Shell
	my $method = $CPAN_METHODS{$switch};
	die "CPAN.pm cannot $method!\n" unless CPAN::Shell->can( $method );

	# call the CPAN::Shell method, with force or notest if specified
	my $action = do {
		   if( $options->{f} ) { sub { CPAN::Shell->force( $method, @@_ )  } }
		elsif( $options->{T} ) { sub { CPAN::Shell->notest( $method, @@_ ) } }
		else                   { sub { CPAN::Shell->$method( @@_ )         } }
		};

	# How do I handle exit codes for multiple arguments?
	my @@errors = ();

	foreach my $arg ( @@$args )
		{
		_clear_cpanpm_output();
		$action->( $arg );

		my $error = _cpanpm_output_indicates_failure();
		push @@errors, $error if $error;
		}

	return do {
		if( @@errors ) { $errors[0] }
		else { HEY_IT_WORKED }
		};

	}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

=for comment

CPAN.pm sends all the good stuff either to STDOUT, or to a temp
file if $CPAN::Be_Silent is set. I have to intercept that output
so I can find out what happened.

=cut

BEGIN {
my $scalar = '';

sub _hook_into_CPANpm_report
	{
	no warnings 'redefine';

	*CPAN::Shell::myprint = sub {
		my($self,$what) = @@_;
		$scalar .= $what;
		$self->print_ornamented($what,
			$CPAN::Config->{colorize_print}||'bold blue on_white',
			);
		};

	*CPAN::Shell::mywarn = sub {
		my($self,$what) = @@_;
		$scalar .= $what;
		$self->print_ornamented($what,
			$CPAN::Config->{colorize_warn}||'bold red on_white'
			);
		};

	}

sub _clear_cpanpm_output { $scalar = '' }

sub _get_cpanpm_output   { $scalar }

# These are lines I don't care about in CPAN.pm output. If I can
# filter out the informational noise, I have a better chance to
# catch the error signal
my @@skip_lines = (
	qr/^\QWarning \(usually harmless\)/,
	qr/\bwill not store persistent state\b/,
	qr(//hint//),
	qr/^\s+reports\s+/,
	qr/^Try the command/,
	qr/^\s+$/,
	qr/^to find objects/,
	qr/^\s*Database was generated on/,
	qr/^Going to read/,
	qr|^\s+i\s+/|,    # the i /Foo::Whatever/ line when it doesn't know
	);

sub _get_cpanpm_last_line
	{
	my $fh;

	if( $] < 5.008 ) {
		$fh = IO::Scalar->new( \ $scalar );
		}
	else {
		eval q{ open $fh, '<', \\ $scalar; };
		}

	my @@lines = <$fh>;

    # This is a bit ugly. Once we examine a line, we have to
    # examine the line before it and go through all of the same
    # regexes. I could do something fancy, but this works.
    REGEXES: {
	foreach my $regex ( @@skip_lines )
		{
		if( $lines[-1] =~ m/$regex/ )
            {
            pop @@lines;
            redo REGEXES; # we have to go through all of them for every line!
            }
		}
	}

    $logger->debug( "Last interesting line of CPAN.pm output is:\n\t$lines[-1]" );

	$lines[-1];
	}
}

BEGIN {
my $epic_fail_words = join '|',
	qw( Error stop(?:ping)? problems force not unsupported
		fail(?:ed)? Cannot\s+install );

sub _cpanpm_output_indicates_failure
	{
	my $last_line = _get_cpanpm_last_line();

	my $result = $last_line =~ /\b(?:$epic_fail_words)\b/i;
	return A_MODULE_FAILED_TO_INSTALL if $last_line =~ /\b(?:Cannot\s+install)\b/i;

	$result || ();
	}
}

sub _cpanpm_output_indicates_success
	{
	my $last_line = _get_cpanpm_last_line();

	my $result = $last_line =~ /\b(?:\s+-- OK|PASS)\b/;
	$result || ();
	}

sub _cpanpm_output_is_vague
	{
	return FALSE if
		_cpanpm_output_indicates_failure() ||
		_cpanpm_output_indicates_success();

	return TRUE;
	}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
sub _turn_on_warnings {
	carp "Warnings are implemented yet";
	return HEY_IT_WORKED;
	}

sub _turn_off_testing {
	$logger->debug( 'Trusting test report history' );
	$CPAN::Config->{trust_test_report_history} = 1;
	return HEY_IT_WORKED;
	}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
sub _print_help
	{
	$logger->info( "Use perldoc to read the documentation" );
	exec "perldoc $0";
	}

sub _print_version # -v
	{
	$logger->info(
		"$0 script version $VERSION, CPAN.pm version " . CPAN->VERSION );

	return HEY_IT_WORKED;
	}

sub _print_details # -V
	{
	_print_version();

	_check_install_dirs();

	$logger->info( '-' x 50 . "\nChecking configured mirrors..." );
	foreach my $mirror ( @@{ $CPAN::Config->{urllist} } ) {
		_print_ping_report( $mirror );
		}

	$logger->info( '-' x 50 . "\nChecking for faster mirrors..." );

	{
	require CPAN::Mirrors;

      if ( $CPAN::Config->{connect_to_internet_ok} ) {
        $CPAN::Frontend->myprint(qq{Trying to fetch a mirror list from the Internet\n});
        eval { CPAN::FTP->localize('MIRRORED.BY',File::Spec->catfile($CPAN::Config->{keep_source_where},'MIRRORED.BY'),3,1) }
          or $CPAN::Frontend->mywarn(<<'HERE');
We failed to get a copy of the mirror list from the Internet.
You will need to provide CPAN mirror URLs yourself.
HERE
        $CPAN::Frontend->myprint("\n");
      }

	my $mirrors   = CPAN::Mirrors->new(  );
	$mirrors->parse_mirrored_by( File::Spec->catfile($CPAN::Config->{keep_source_where},'MIRRORED.BY') );
	my @@continents = $mirrors->find_best_continents;

	my @@mirrors   = $mirrors->get_mirrors_by_continents( $continents[0] );
	my @@timings   = $mirrors->get_mirrors_timings( \@@mirrors );

	foreach my $timing ( @@timings ) {
		$logger->info( sprintf "%s (%0.2f ms)",
			$timing->hostname, $timing->rtt );
		}
	}

	return HEY_IT_WORKED;
	}

sub _check_install_dirs
	{
	my $makepl_arg   = $CPAN::Config->{makepl_arg};
	my $mbuildpl_arg = $CPAN::Config->{mbuildpl_arg};

	my @@custom_dirs;
	# PERL_MM_OPT
	push @@custom_dirs,
		$makepl_arg   =~ m/INSTALL_BASE\s*=\s*(\S+)/g,
		$mbuildpl_arg =~ m/--install_base\s*=\s*(\S+)/g;

	if( @@custom_dirs ) {
		foreach my $dir ( @@custom_dirs ) {
			_print_inc_dir_report( $dir );
			}
		}

	# XXX: also need to check makepl_args, etc

	my @@checks = (
		[ 'core',         [ grep $_, @@Config{qw(installprivlib installarchlib)}      ] ],
		[ 'vendor',       [ grep $_, @@Config{qw(installvendorlib installvendorarch)} ] ],
		[ 'site',         [ grep $_, @@Config{qw(installsitelib installsitearch)}     ] ],
		[ 'PERL5LIB',     _split_paths( $ENV{PERL5LIB} ) ],
		[ 'PERLLIB',      _split_paths( $ENV{PERLLIB} )  ],
		);

	$logger->info( '-' x 50 . "\nChecking install dirs..." );
	foreach my $tuple ( @@checks ) {
		my( $label ) = $tuple->[0];

		$logger->info( "Checking $label" );
		$logger->info( "\tno directories for $label" ) unless @@{ $tuple->[1] };
		foreach my $dir ( @@{ $tuple->[1] } ) {
			_print_inc_dir_report( $dir );
			}
		}

	}

sub _split_paths
	{
	[ map { _expand_filename( $_ ) } split /$Config{path_sep}/, $_[0] || '' ];
	}


=pod

Stolen from File::Path::Expand

=cut

sub _expand_filename
	{
    my( $path ) = @@_;
    no warnings 'uninitialized';
    $logger->debug( "Expanding path $path\n" );
    $path =~ s{\A~([^/]+)?}{
		_home_of( $1 || $> ) || "~$1"
    	}e;
    return $path;
	}

sub _home_of
	{
	require User::pwent;
    my( $user ) = @@_;
    my $ent = User::pwent::getpw($user) or return;
    return $ent->dir;
	}

sub _get_default_inc
	{
	require Config;

	[ @@Config::Config{ _vars() }, '.' ];
	}

sub _vars {
	qw(
	installarchlib
	installprivlib
	installsitearch
	installsitelib
	);
	}

sub _ping_mirrors {
	my $urls   = $CPAN::Config->{urllist};
	require URI;

	foreach my $url ( @@$urls ) {
		my( $obj ) = URI->new( $url );
		next unless _is_pingable_scheme( $obj );
		my $host = $obj->host;
		_print_ping_report( $obj );
		}

	}

sub _is_pingable_scheme {
	my( $uri ) = @@_;

	$uri->scheme eq 'file'
	}

sub _find_good_mirrors {
	require CPAN::Mirrors;

	my $file = do {
		my $file = 'MIRRORED.BY';
		my $local_path = File::Spec->catfile(
			$CPAN::Config->{keep_source_where}, $file );

		if( -e $local_path ) { $local_path }
		else {
			require CPAN::FTP;
			CPAN::FTP->localize( $file, $local_path, 3, 1 );
			$local_path;
			}
		};
	my $mirrors = CPAN::Mirrors->new( $file );

	my @@mirrors = $mirrors->best_mirrors(
		how_many   => 5,
		verbose    => 1,
		);

	foreach my $mirror ( @@mirrors ) {
		next unless eval { $mirror->can( 'http' ) };
		_print_ping_report( $mirror->http );
		}

	$CPAN::Config->{urllist} = [
		map { $_->http } @@mirrors
		];
	}

sub _print_inc_dir_report
	{
	my( $dir ) = shift;

	my $writeable = -w $dir ? '+' : '!!! (not writeable)';
	$logger->info( "\t$writeable $dir" );
	return -w $dir;
	}

sub _print_ping_report
	{
	my( $mirror ) = @@_;

	my $rtt = eval { _get_ping_report( $mirror ) };
	my $result = $rtt ? sprintf "+ (%4d ms)", $rtt * 1000 : '!';

	$logger->info(
		sprintf "\t%s %s", $result, $mirror
		);
	}

sub _get_ping_report
	{
	require URI;
	my( $mirror ) = @@_;
	my( $url ) = ref $mirror ? $mirror : URI->new( $mirror ); #XXX
	require Net::Ping;

	my $ping = Net::Ping->new( 'tcp', 1 );

	if( $url->scheme eq 'file' ) {
		return -e $url->file;
		}

    my( $port ) = $url->port;

    return unless $port;

    if ( $ping->can('port_number') ) {
        $ping->port_number($port);
    	}
    else {
        $ping->{'port_num'} = $port;
    	}

    $ping->hires(1) if $ping->can( 'hires' );
    my( $alive, $rtt ) = eval{ $ping->ping( $url->host ) };
	$alive ? $rtt : undef;
	}

sub _load_local_lib # -I
	{
	$logger->debug( "Loading local::lib" );

	my $rc = _safe_load_module("local::lib");
	unless( $rc ) {
		$logger->die( "Could not load local::lib" );
		}

	local::lib->import;

	return HEY_IT_WORKED;
	}

sub _use_these_mirrors # -M
	{
	$logger->debug( "Setting per session mirrors" );
	unless( $_[0] ) {
		$logger->die( "The -M switch requires a comma-separated list of mirrors" );
		}

	$CPAN::Config->{urllist} = [ split /,/, $_[0] ];

	$logger->debug( "Mirrors are @@{$CPAN::Config->{urllist}}" );

	}

sub _create_autobundle
	{
	$logger->info(
		"Creating autobundle in $CPAN::Config->{cpan_home}/Bundle" );

	CPAN::Shell->autobundle;

	return HEY_IT_WORKED;
	}

sub _recompile
	{
	$logger->info( "Recompiling dynamically-loaded extensions" );

	CPAN::Shell->recompile;

	return HEY_IT_WORKED;
	}

sub _upgrade
	{
	$logger->info( "Upgrading all modules" );

	CPAN::Shell->upgrade();

	return HEY_IT_WORKED;
	}

sub _load_config # -j
	{
	my $file = shift || '';

	# should I clear out any existing config here?
	$CPAN::Config = {};
	delete $INC{'CPAN/Config.pm'};
	croak( "Config file [$file] does not exist!\n" ) unless -e $file;

	my $rc = eval "require '$file'";

	# CPAN::HandleConfig::require_myconfig_or_config looks for this
	$INC{'CPAN/MyConfig.pm'} = 'fake out!';

	# CPAN::HandleConfig::load looks for this
	$CPAN::Config_loaded = 'fake out';

	croak( "Could not load [$file]: $@@\n") unless $rc;

	return HEY_IT_WORKED;
	}

sub _dump_config # -J
	{
	my $args = shift;
	require Data::Dumper;

	my $fh = $args->[0] || \*STDOUT;

	local $Data::Dumper::Sortkeys = 1;
	my $dd = Data::Dumper->new(
		[$CPAN::Config],
		['$CPAN::Config']
		);

	print $fh $dd->Dump, "\n1;\n__END__\n";

	return HEY_IT_WORKED;
	}

sub _lock_lobotomy # -F
	{
	no warnings 'redefine';

	*CPAN::_flock    = sub { 1 };
	*CPAN::checklock = sub { 1 };

	return HEY_IT_WORKED;
	}

sub _download
	{
	my $args = shift;

	local $CPAN::DEBUG = 1;

	my %paths;

	foreach my $module ( @@$args )
		{
		$logger->info( "Checking $module" );
		my $path = CPAN::Shell->expand( "Module", $module )->cpan_file;

		$logger->debug( "Inst file would be $path\n" );

		$paths{$module} = _get_file( _make_path( $path ) );
		}

	return \%paths;
	}

sub _make_path { join "/", qw(authors id), $_[0] }

sub _get_file
	{
	my $path = shift;

	my $loaded = _safe_load_module("LWP::Simple");
	croak "You need LWP::Simple to use features that fetch files from CPAN\n"
		unless $loaded;

	my $file = substr $path, rindex( $path, '/' ) + 1;
	my $store_path = catfile( cwd(), $file );
	$logger->debug( "Store path is $store_path" );

	foreach my $site ( @@{ $CPAN::Config->{urllist} } )
		{
		my $fetch_path = join "/", $site, $path;
		$logger->debug( "Trying $fetch_path" );
	    last if LWP::Simple::getstore( $fetch_path, $store_path );
		}

	return $store_path;
	}

sub _gitify
	{
	my $args = shift;

	my $loaded = _safe_load_module("Archive::Extract");
	croak "You need Archive::Extract to use features that gitify distributions\n"
		unless $loaded;

	my $starting_dir = cwd();

	foreach my $module ( @@$args )
		{
		$logger->info( "Checking $module" );
		my $path = CPAN::Shell->expand( "Module", $module )->cpan_file;

		my $store_paths = _download( [ $module ] );
		$logger->debug( "gitify Store path is $store_paths->{$module}" );
		my $dirname = dirname( $store_paths->{$module} );

		my $ae = Archive::Extract->new( archive => $store_paths->{$module} );
		$ae->extract( to => $dirname );

		chdir $ae->extract_path;

		my $git = $ENV{GIT_COMMAND} || '/usr/local/bin/git';
		croak "Could not find $git"    unless -e $git;
		croak "$git is not executable" unless -x $git;

		# can we do this in Pure Perl?
		system( $git, 'init'    );
		system( $git, qw( add . ) );
		system( $git, qw( commit -a -m ), 'initial import' );
		}

	chdir $starting_dir;

	return HEY_IT_WORKED;
	}

sub _show_Changes
	{
	my $args = shift;

	foreach my $arg ( @@$args )
		{
		$logger->info( "Checking $arg\n" );

		my $module = eval { CPAN::Shell->expand( "Module", $arg ) };
		my $out = _get_cpanpm_output();

		next unless eval { $module->inst_file };
		#next if $module->uptodate;

		( my $id = $module->id() ) =~ s/::/\-/;

		my $url = "http://search.cpan.org/~" . lc( $module->userid ) . "/" .
			$id . "-" . $module->cpan_version() . "/";

		#print "URL: $url\n";
		_get_changes_file($url);
		}

	return HEY_IT_WORKED;
	}

sub _get_changes_file
	{
	croak "Reading Changes files requires LWP::Simple and URI\n"
		unless _safe_load_module("LWP::Simple") && _safe_load_module("URI");

    my $url = shift;

    my $content = LWP::Simple::get( $url );
    $logger->info( "Got $url ..." ) if defined $content;
	#print $content;

	my( $change_link ) = $content =~ m|<a href="(.*?)">Changes</a>|gi;

	my $changes_url = URI->new_abs( $change_link, $url );
 	$logger->debug( "Change link is: $changes_url" );

	my $changes =  LWP::Simple::get( $changes_url );

	print $changes;

	return HEY_IT_WORKED;
	}

sub _show_Author
	{
	my $args = shift;

	foreach my $arg ( @@$args )
		{
		my $module = CPAN::Shell->expand( "Module", $arg );
		unless( $module )
			{
			$logger->info( "Didn't find a $arg module, so no author!" );
			next;
			}

		my $author = CPAN::Shell->expand( "Author", $module->userid );

		next unless $module->userid;

		printf "%-25s %-8s %-25s %s\n",
			$arg, $module->userid, $author->email, $author->name;
		}

	return HEY_IT_WORKED;
	}

sub _show_Details
	{
	my $args = shift;

	foreach my $arg ( @@$args )
		{
		my $module = CPAN::Shell->expand( "Module", $arg );
		my $author = CPAN::Shell->expand( "Author", $module->userid );

		next unless $module->userid;

		print "$arg\n", "-" x 73, "\n\t";
		print join "\n\t",
			$module->description ? $module->description : "(no description)",
			$module->cpan_file ? $module->cpan_file : "(no cpanfile)",
			$module->inst_file ? $module->inst_file :"(no installation file)" ,
			'Installed: ' . ($module->inst_version ? $module->inst_version : "not installed"),
			'CPAN:      ' . $module->cpan_version . '  ' .
				($module->uptodate ? "" : "Not ") . "up to date",
			$author->fullname . " (" . $module->userid . ")",
			$author->email;
		print "\n\n";

		}

	return HEY_IT_WORKED;
	}

sub _show_out_of_date
	{
	my @@modules = CPAN::Shell->expand( "Module", "/./" );

	printf "%-40s  %6s  %6s\n", "Module Name", "Local", "CPAN";
	print "-" x 73, "\n";

	foreach my $module ( @@modules )
		{
		next unless $module->inst_file;
		next if $module->uptodate;
		printf "%-40s  %.4f  %.4f\n",
			$module->id,
			$module->inst_version ? $module->inst_version : '',
			$module->cpan_version;
		}

	return HEY_IT_WORKED;
	}

sub _show_author_mods
	{
	my $args = shift;

	my %hash = map { lc $_, 1 } @@$args;

	my @@modules = CPAN::Shell->expand( "Module", "/./" );

	foreach my $module ( @@modules )
		{
		next unless exists $hash{ lc $module->userid };
		print $module->id, "\n";
		}

	return HEY_IT_WORKED;
	}

sub _list_all_mods # -l
	{
	require File::Find;

	my $args = shift;


	my $fh = \*STDOUT;

	INC: foreach my $inc ( @@INC )
		{
		my( $wanted, $reporter ) = _generator();
		File::Find::find( { wanted => $wanted }, $inc );

		my $count = 0;
		FILE: foreach my $file ( @@{ $reporter->() } )
			{
			my $version = _parse_version_safely( $file );

			my $module_name = _path_to_module( $inc, $file );
			next FILE unless defined $module_name;

			print $fh "$module_name\t$version\n";

			#last if $count++ > 5;
			}
		}

	return HEY_IT_WORKED;
	}

sub _generator
	{
	my @@files = ();

	sub { push @@files,
		File::Spec->canonpath( $File::Find::name )
		if m/\A\w+\.pm\z/ },
	sub { \@@files },
	}

sub _parse_version_safely # stolen from PAUSE's mldistwatch, but refactored
	{
	my( $file ) = @@_;

	local $/ = "\n";
	local $_; # don't mess with the $_ in the map calling this

	return unless open FILE, "<$file";

	my $in_pod = 0;
	my $version;
	while( <FILE> )
		{
		chomp;
		$in_pod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $in_pod;
		next if $in_pod || /^\s*#/;

		next unless /([\$*])(([\w\:\']*)\bVERSION)\b.*\=/;
		my( $sigil, $var ) = ( $1, $2 );

		$version = _eval_version( $_, $sigil, $var );
		last;
		}
	close FILE;

	return 'undef' unless defined $version;

	return $version;
	}

sub _eval_version
	{
	my( $line, $sigil, $var ) = @@_;

        # split package line to hide from PAUSE
	my $eval = qq{
		package
                  ExtUtils::MakeMaker::_version;

		local $sigil$var;
		\$$var=undef; do {
			$line
			}; \$$var
		};

	my $version = do {
		local $^W = 0;
		no strict;
		eval( $eval );
		};

	return $version;
	}

sub _path_to_module
	{
	my( $inc, $path ) = @@_;
	return if length $path < length $inc;

	my $module_path = substr( $path, length $inc );
	$module_path =~ s/\.pm\z//;

	# XXX: this is cheating and doesn't handle everything right
	my @@dirs = grep { ! /\W/ } File::Spec->splitdir( $module_path );
	shift @@dirs;

	my $module_name = join "::", @@dirs;

	return $module_name;
	}

1;

=back

=head1 EXIT VALUES

The script exits with zero if it thinks that everything worked, or a
positive number if it thinks that something failed. Note, however, that
in some cases it has to divine a failure by the output of things it does
not control. For now, the exit codes are vague:

	1	An unknown error

	2	The was an external problem

	4	There was an internal problem with the script

	8	A module failed to install

=head1 TO DO

* There is initial support for Log4perl if it is available, but I
haven't gone through everything to make the NullLogger work out
correctly if Log4perl is not installed.

* When I capture CPAN.pm output, I need to check for errors and
report them to the user.

* Warnings switch

* Check then exit

* no test option

=head1 BUGS

* none noted

=head1 SEE ALSO

L<CPAN>, L<App::cpanminus>

=head1 SOURCE AVAILABILITY

This code is in Github in the CPAN.pm repository:

	https://github.com/andk/cpanpm

The source used to be tracked separately in another GitHub repo,
but the canonical source is now in the above repo.

=head1 CREDITS

Japheth Cleaver added the bits to allow a forced install (C<-f>).

Jim Brandt suggest and provided the initial implementation for the
up-to-date and Changes features.

Adam Kennedy pointed out that C<exit()> causes problems on Windows
where this script ends up with a .bat extension

David Golden helps integrate this into the C<CPAN.pm> repos.

=head1 AUTHOR

brian d foy, C<< <bdfoy@@cpan.org> >>

=head1 COPYRIGHT

Copyright (c) 2001-2014, brian d foy, All Rights Reserved.

You may redistribute this under the same terms as Perl itself.

=cut
@


1.2
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.


ok deraadt@@
@
text
@d7 1
a7 1
use if $] < 5.008 => "IO::Scalar";
d9 1
a9 1
$VERSION = '1.62_01';
d26 3
d141 5
d156 1
a156 1
Ping the configured mirrors
d160 2
a161 1
Find the best mirrors you could be using (but doesn't configure them just yet)
d220 45
d273 1
a273 1
use CPAN ();
d302 1
a302 1
@@META_OPTIONS = qw( h v V I g G C A D O l L a r p P j: J w T);
d314 1
d341 2
a343 1
    T =>  [ \&_turn_off_testing,  NO_ARGS, GOOD_EXIT, 'Turning off testing'          ],
a357 1
	P =>  [ \&_find_good_mirrors, NO_ARGS, GOOD_EXIT, 'Finding good mirrors'         ],
d367 1
d423 3
a425 1
	foreach my $o ( qw(F I w T) )
d446 5
a450 1
	$option_count -= $options->{'f'}; # don't count force
d457 8
d497 2
d505 1
a505 1
			qw( code takes_args );
d550 1
d581 1
a581 1
		next if $option eq 'f';
d599 1
a599 1
	# call the CPAN::Shell method, with force if specified
d601 3
a603 2
		if( $options->{f} ) { sub { CPAN::Shell->force( $method, @@_ ) } }
		else                { sub { CPAN::Shell->$method( @@_ )        } }
d607 1
a607 1
	my $errors = 0;
d614 2
a615 1
		$errors += defined _cpanpm_output_indicates_failure();
d618 5
a622 1
	$errors ? I_DONT_KNOW_WHAT_HAPPENED : HEY_IT_WORKED;
d664 3
d672 6
d683 7
a689 5
	if ($] < 5.008) {
		$fh = IO::Scalar->new(\ $scalar);
        } else {
		eval q{open $fh, "<", \\ $scalar;};
        }
d715 2
a716 1
	qw( Error stop(?:ping)? problems force not unsupported fail(?:ed)? );
d723 2
a923 1
	my $mirrors = CPAN::Mirrors->new;
d936 1
a936 2

	$mirrors->parse_mirrored_by( $file );
d939 1
a939 1
		how_many   => 3,
d948 3
d967 1
d970 1
a970 1
		sprintf "\t%s (%4d ms) %s", $rtt  ? '+' : '!',  $rtt * 1000, $mirror
d1017 13
d1279 3
a1281 3
			$module->cpan_file,
			$module->inst_file,
			'Installed: ' . $module->inst_version,
d1428 1
a1428 1
	return if length $path< length $inc;
a1469 2
* Support local::lib

a1473 2
* ping mirrors support

d1482 1
a1482 2
Most behaviour, including environment variables and configuration,
comes directly from CPAN.pm.
d1486 3
a1488 1
This code is in Github:
d1490 2
a1491 1
	git://github.com/briandfoy/cpan_script.git
d1511 1
a1511 1
Copyright (c) 2001-2013, brian d foy, All Rights Reserved.
@


1.1
log
@Initial revision
@
text
@d2 1
d7 3
a9 1
$VERSION = '1.5701';
d21 1
a21 1
	cpan [-cfFimt] module_name [ module_name ... ]
d24 2
a25 2
	cpan -l module_name [ module_name ... ]
	
d29 1
a29 1
	
d34 1
a34 1
	cpan [-ahruvACDLO]
d79 1
a79 1
Turn off CPAN.pm's attempts to lock anything. You should be careful with 
d106 7
a112 1
Install the specified modules.
d117 1
a117 1
same format as the standard F<CPAN/Config.pm> file, which defines 
d128 1
a128 1
Use C<local::lib>.
d138 4
d146 12
d162 1
a162 1
=item -r
d164 1
a164 1
Recompiles dynamically loaded modules with CPAN::Shell->recompile.
d175 11
d220 1
a224 1

d227 1
a227 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
d233 1
a233 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
d235 1
a235 1
use constant HEY_IT_WORKED              =>   0; 
d242 1
a242 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
d247 2
a248 2
	
@@META_OPTIONS = qw( h v g G C A D O l L a r j: J );
d266 1
a266 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
d279 1
d285 3
d292 1
a292 1
	
a296 1

d301 3
a311 1

d322 2
a323 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
d331 1
a331 1
	
d335 3
a337 1
	
d343 1
a343 1
		  join( '', @@option_order ), \%options );    
d351 1
a351 1
	
d360 1
d362 1
a362 1
			# be_silent  => 1, # candidate to be ripped out forever
d366 2
a367 2
		
	if( $options->{F} )
d369 15
a383 2
		$Method_table{F}[ $Method_table_index{code} ]->( $options->{F} );
		delete $options->{F};
d389 1
a389 1
	
d400 1
a400 1
The C<run> method returns 0 on success and a postive number on 
d428 1
a428 1
		{	
d431 1
a431 1
		my( $sub, $takes_args, $description ) = 
d443 1
a443 1
		
d453 2
a454 1
package Local::Null::Logger;
d457 1
a457 1
sub AUTOLOAD { shift; print "NullLogger: ", @@_, $/ if $ENV{CPAN_NULL_LOGGER} }
d461 11
d474 2
a475 2
	my $log4perl_loaded = eval "require Log::Log4perl; 1";
	
d481 1
a481 1
	
d483 1
a483 1
	
d490 1
a490 1
	
d493 4
a496 4
	
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
d501 1
a501 1
	
d531 1
a531 1
	
d534 3
a536 3
	
	foreach my $arg ( @@$args ) 
		{		
d546 1
a546 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
d550 3
a552 2
CPAN.pm sends all the good stuff either to STDOUT. I have to intercept
that output so I can find out what happened.
d556 1
a556 1
{
d562 1
a562 1
	
d565 1
a565 1
		$scalar .= $what if defined $what;
d573 2
a574 2
		$scalar .= $what if defined $what;
		$self->print_ornamented($what, 
d580 1
a580 1
	
d582 1
a582 1
	
a584 1
BEGIN {
d594 7
a600 2
	open my($fh), "<", \ $scalar;
	
d602 1
a602 1
	
d615 2
a616 2
    }
    
d618 1
a618 1
    
d626 1
a626 1
	
d630 1
a630 1
	
d635 1
a635 1
	
d639 1
a639 1
	
d643 1
a643 1
	
d646 2
a647 2
	return FALSE if 
		_cpanpm_output_indicates_failure() || 
d653 11
a663 1
}
d665 1
a665 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
d671 2
a672 2
	
sub _print_version
d674 1
a674 1
	$logger->info( 
d679 243
a921 1
	
d924 1
a924 1
	$logger->info( 
d951 1
a951 1
	{	
d953 1
a953 1
	
d958 1
a958 1
	
d963 1
a963 1
	
d966 1
a966 1
	
d968 1
a968 1
	
d972 1
a972 1
sub _dump_config
d976 1
a976 1
	
d978 5
a982 4
		
	my $dd = Data::Dumper->new( 
		[$CPAN::Config], 
		['$CPAN::Config'] 
d984 1
a984 1
		
d986 1
a986 1
	
d990 1
a990 1
sub _lock_lobotomy
d993 1
a993 1
	
d999 1
a999 1
	
d1001 1
a1001 1
	{	
d1003 1
a1003 1
	
d1005 1
a1005 1
	
d1007 1
a1007 1
	
d1012 1
a1012 1
		
d1014 1
a1014 1
		
d1017 1
a1017 1
		
d1022 1
a1022 1
	
d1026 2
a1027 2
	
	my $loaded = eval "require LWP::Simple; 1;";
d1030 1
a1030 1
	
d1048 2
a1049 2
	
	my $loaded = eval "require Archive::Extract; 1;";
d1052 1
a1052 1
	
d1054 1
a1054 1
	
d1062 2
a1063 2
		my $dirname = dirname( $store_paths->{$module} );	
	
d1066 1
a1066 1
		
d1068 1
a1068 1
		
d1072 1
a1072 1
		
d1078 1
a1078 1
	
d1087 1
a1087 1
	
d1091 1
a1091 1
		
d1094 1
a1094 1
		
d1097 1
a1097 1
	
d1099 1
a1099 1
	
d1102 1
a1102 1
	
d1108 2
a1109 2
	}	
	
d1113 2
a1114 2
		unless eval "require LWP::Simple; require URI; 1";
	
d1120 1
a1120 1
	
d1122 1
a1122 1
	
d1132 1
a1132 1
	
d1134 1
a1134 1
	{	
d1136 1
a1136 1
	
d1145 1
a1145 1
			
d1147 1
a1147 1
	
d1149 3
a1151 3
	
		printf "%-25s %-8s %-25s %s\n", 
			$arg, $module->userid, $author->email, $author->fullname;
d1155 1
a1155 1
	}	
d1160 1
a1160 1
	
d1165 1
a1165 1
	
d1167 1
a1167 1
	
d1179 1
a1179 1
		
d1181 1
a1181 1
		
d1183 1
a1183 1
	}	
d1188 1
a1188 1
		
d1191 1
a1191 1
	
d1197 2
a1198 2
			$module->id, 
			$module->inst_version ? $module->inst_version : '', 
d1210 1
a1210 1
	
d1212 1
a1212 1
	
d1218 1
a1218 1
	
d1221 2
a1222 2
	
sub _list_all_mods
d1225 1
a1225 1
	
d1227 2
a1228 2
	
	
d1230 1
a1230 1
	
d1232 1
a1232 1
		{		
d1235 1
a1235 1
		
d1240 1
a1240 1
			
d1243 1
a1243 1
			
d1245 1
a1245 1
			
d1252 1
a1252 1
	
d1254 1
a1254 1
	{			
d1256 3
a1258 3
	
	sub { push @@files, 
		File::Spec->canonpath( $File::Find::name ) 
d1262 1
a1262 1
	
d1266 1
a1266 1
	
d1269 1
a1269 1
	
d1274 1
a1274 1
	while( <FILE> ) 
d1282 1
a1282 1
		
d1289 1
a1289 1
	
d1296 5
a1300 3
	
	my $eval = qq{ 
		package ExtUtils::MakeMaker::_version;
d1307 1
a1307 1
		
d1321 1
a1321 1
	
d1324 1
a1324 1
	
d1328 1
a1328 1
	
d1330 1
a1330 1
	
d1340 1
a1340 1
The script exits with zero if it thinks that everything worked, or a 
d1362 10
d1389 1
a1389 1
Japheth Cleaver added the bits to allow a forced install (-f).
d1394 1
a1394 1
Adam Kennedy pointed out that exit() causes problems on Windows
d1397 2
d1405 1
a1405 1
Copyright (c) 2001-2009, brian d foy, All Rights Reserved.
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d22 1
a22 1

d26 1
a26 1

d76 1
a76 1
Turn off CPAN.pm's attempts to lock anything. You should be careful with
d108 1
a108 1
same format as the standard F<CPAN/Config.pm> file, which defines
d191 1
a191 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
d197 1
a197 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
d199 1
a199 1
use constant HEY_IT_WORKED              =>   0;
d206 1
a206 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
d211 1
a211 1

d230 1
a230 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
d252 1
a252 1

d281 1
a281 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
d289 1
a289 1

d293 1
a293 1

d299 1
a299 1
		  join( '', @@option_order ), \%options );
d307 1
a307 1

d321 1
a321 1

d331 1
a331 1

d342 1
a342 1
The C<run> method returns 0 on success and a postive number on
d370 1
a370 1
		{
d373 1
a373 1
		my( $sub, $takes_args, $description ) =
d385 1
a385 1

d405 1
a405 1

d411 1
a411 1

d413 1
a413 1

d420 1
a420 1

d423 4
a426 4

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
d431 1
a431 1

d461 1
a461 1

d464 3
a466 3

	foreach my $arg ( @@$args )
		{
d476 1
a476 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
d491 1
a491 1

d503 1
a503 1
		$self->print_ornamented($what,
d509 1
a509 1

d511 1
a511 1

d525 1
a525 1

d527 1
a527 1

d541 1
a541 1

d543 1
a543 1

d551 1
a551 1

d555 1
a555 1

d560 1
a560 1

d564 1
a564 1

d568 1
a568 1

d571 2
a572 2
	return FALSE if
		_cpanpm_output_indicates_failure() ||
d580 1
a580 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
d586 1
a586 1

d589 1
a589 1
	$logger->info(
d594 1
a594 1

d597 1
a597 1
	$logger->info(
d624 1
a624 1
	{
d626 1
a626 1

d631 1
a631 1

d636 1
a636 1

d639 1
a639 1

d641 1
a641 1

d649 1
a649 1

d651 4
a654 4

	my $dd = Data::Dumper->new(
		[$CPAN::Config],
		['$CPAN::Config']
d656 1
a656 1

d658 1
a658 1

d665 1
a665 1

d671 1
a671 1

d673 1
a673 1
	{
d675 1
a675 1

d677 1
a677 1

d679 1
a679 1

d684 1
a684 1

d686 1
a686 1

d689 1
a689 1

d694 1
a694 1

d698 1
a698 1

d702 1
a702 1

d720 1
a720 1

d724 1
a724 1

d726 1
a726 1

d734 2
a735 2
		my $dirname = dirname( $store_paths->{$module} );

d738 1
a738 1

d740 1
a740 1

d744 1
a744 1

d750 1
a750 1

d759 1
a759 1

d763 1
a763 1

d766 1
a766 1

d769 1
a769 1

d771 1
a771 1

d774 1
a774 1

d780 2
a781 2
	}

d786 1
a786 1

d792 1
a792 1

d794 1
a794 1

d804 1
a804 1

d806 1
a806 1
	{
d808 1
a808 1

d817 1
a817 1

d819 1
a819 1

d821 2
a822 2

		printf "%-25s %-8s %-25s %s\n",
d827 1
a827 1
	}
d832 1
a832 1

d837 1
a837 1

d839 1
a839 1

d851 1
a851 1

d853 1
a853 1

d855 1
a855 1
	}
d860 1
a860 1

d863 1
a863 1

d869 2
a870 2
			$module->id,
			$module->inst_version ? $module->inst_version : '',
d882 1
a882 1

d884 1
a884 1

d890 1
a890 1

d893 1
a893 1

d897 1
a897 1

d899 2
a900 2


d902 1
a902 1

d904 1
a904 1
		{
d907 1
a907 1

d912 1
a912 1

d915 1
a915 1

d917 1
a917 1

d924 1
a924 1

d926 1
a926 1
	{
d928 3
a930 3

	sub { push @@files,
		File::Spec->canonpath( $File::Find::name )
d934 1
a934 1

d938 1
a938 1

d941 1
a941 1

d946 1
a946 1
	while( <FILE> )
d954 1
a954 1

d961 1
a961 1

d968 2
a969 2

	my $eval = qq{
d977 1
a977 1

d991 1
a991 1

d994 1
a994 1

d998 1
a998 1

d1000 1
a1000 1

d1010 1
a1010 1
The script exits with zero if it thinks that everything worked, or a
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a1 2

use 5.008;
d6 1
a6 1
$VERSION = '1.61';
d18 1
a18 1
	cpan [-cfFimtTw] module_name [ module_name ... ]
d21 1
a21 1
	cpan -I module_name [ module_name ... ]
d31 1
a31 1
	cpan [-ahpruvACDLOP]
d103 1
a103 7
Install the specified modules. With no other switches, this switch
is implied.

=item -I

Load C<local::lib> (think like C<-I> for loading lib paths). Too bad
C<-l> was already taken.
d119 1
a119 1
List all installed modules wth their versions
a128 4
=item -n

Do a dry run, but don't actually install anything. (unimplemented)

d133 1
a133 1
=item -p
d135 1
a135 5
Ping the configured mirrors

=item -P

Find the best mirrors you could be using (but doesn't configure them just yet)
a140 8
=item -t

Run a `make test` on the specified modules.

=item -T

Do not test modules. Simply install them.

a149 11
=item -V

Print detailed information about the cpan client.

=item -w

UNIMPLEMENTED

Turn on cpan warnings. This checks various things, like directory permissions,
and tells you about problems you might have.

a183 1
use Config;
d188 1
d212 1
a212 1
@@META_OPTIONS = qw( h v V I g G C A D O l L a r p P j: J w T);
a242 1
	V =>  [ \&_print_details,     NO_ARGS, GOOD_EXIT, 'Printing detailed version'    ],
a247 3
	I =>  [ \&_load_local_lib,    NO_ARGS, GOOD_EXIT, 'Loading local::lib'           ],
    w =>  [ \&_turn_on_warnings,  NO_ARGS, GOOD_EXIT, 'Turning on warnings'          ],
    T =>  [ \&_turn_off_testing,  NO_ARGS, GOOD_EXIT, 'Turning off testing'          ],
d257 1
a261 3
	p =>  [ \&_ping_mirrors,      NO_ARGS, GOOD_EXIT, 'Pinging mirrors'              ],
	P =>  [ \&_find_good_mirrors, NO_ARGS, GOOD_EXIT, 'Finding good mirrors'         ],

d270 1
a280 1

a293 2
	push @@ARGV, grep $_, split /\s+/, $ENV{CPAN_OPTS} || '';

a315 1
		local $CPAN::Be_Silent = 1;
d317 1
a317 1
			# be_silent  => 1, deprecated
d322 1
a322 8
	foreach my $o ( qw(F I w T) )
		{
		next unless exists $options->{$o};
		$Method_table{$o}[ $Method_table_index{code} ]->( $options->{$o} );
		delete $options->{$o};
		}

	if( $options->{o} )
d324 2
a325 8
		my @@pairs = map { [ split /=/, $_, 2 ] } split /,/, $options->{o};
		foreach my $pair ( @@pairs )
			{
			my( $setting, $value ) = @@$pair;
			$CPAN::Config->{$setting} = $value;
		#	$logger->debug( "Setting [$setting] to [$value]" );
			}
		delete $options->{o};
d395 1
a395 2
package
  Local::Null::Logger; # hide from PAUSE
d398 1
a398 1
sub AUTOLOAD { 1 }
d480 2
a481 3
CPAN.pm sends all the good stuff either to STDOUT, or to a temp
file if $CPAN::Be_Silent is set. I have to intercept that output
so I can find out what happened.
d485 1
a485 1
BEGIN {
d494 1
a494 1
		$scalar .= $what;
d502 1
a502 1
		$scalar .= $what;
d514 1
d540 1
a540 1
	}
d578 1
a578 11
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
sub _turn_on_warnings {
	carp "Warnings are implemented yet";
	return HEY_IT_WORKED;
	}

sub _turn_off_testing {
	$logger->debug( 'Trusting test report history' );
	$CPAN::Config->{trust_test_report_history} = 1;
	return HEY_IT_WORKED;
	}
d587 1
a587 1
sub _print_version # -v
a594 242
sub _print_details # -V
	{
	_print_version();

	_check_install_dirs();

	$logger->info( '-' x 50 . "\nChecking configured mirrors..." );
	foreach my $mirror ( @@{ $CPAN::Config->{urllist} } ) {
		_print_ping_report( $mirror );
		}

	$logger->info( '-' x 50 . "\nChecking for faster mirrors..." );

	{
	require CPAN::Mirrors;

      if ( $CPAN::Config->{connect_to_internet_ok} ) {
        $CPAN::Frontend->myprint(qq{Trying to fetch a mirror list from the Internet\n});
        eval { CPAN::FTP->localize('MIRRORED.BY',File::Spec->catfile($CPAN::Config->{keep_source_where},'MIRRORED.BY'),3,1) }
          or $CPAN::Frontend->mywarn(<<'HERE');
We failed to get a copy of the mirror list from the Internet.
You will need to provide CPAN mirror URLs yourself.
HERE
        $CPAN::Frontend->myprint("\n");
      }

	my $mirrors   = CPAN::Mirrors->new(  );
	$mirrors->parse_mirrored_by( File::Spec->catfile($CPAN::Config->{keep_source_where},'MIRRORED.BY') );
	my @@continents = $mirrors->find_best_continents;

	my @@mirrors   = $mirrors->get_mirrors_by_continents( $continents[0] );
	my @@timings   = $mirrors->get_mirrors_timings( \@@mirrors );

	foreach my $timing ( @@timings ) {
		$logger->info( sprintf "%s (%0.2f ms)",
			$timing->hostname, $timing->rtt );
		}
	}

	return HEY_IT_WORKED;
	}

sub _check_install_dirs
	{
	my $makepl_arg   = $CPAN::Config->{makepl_arg};
	my $mbuildpl_arg = $CPAN::Config->{mbuildpl_arg};

	my @@custom_dirs;
	# PERL_MM_OPT
	push @@custom_dirs,
		$makepl_arg   =~ m/INSTALL_BASE\s*=\s*(\S+)/g,
		$mbuildpl_arg =~ m/--install_base\s*=\s*(\S+)/g;

	if( @@custom_dirs ) {
		foreach my $dir ( @@custom_dirs ) {
			_print_inc_dir_report( $dir );
			}
		}

	# XXX: also need to check makepl_args, etc

	my @@checks = (
		[ 'core',         [ grep $_, @@Config{qw(installprivlib installarchlib)}      ] ],
		[ 'vendor',       [ grep $_, @@Config{qw(installvendorlib installvendorarch)} ] ],
		[ 'site',         [ grep $_, @@Config{qw(installsitelib installsitearch)}     ] ],
		[ 'PERL5LIB',     _split_paths( $ENV{PERL5LIB} ) ],
		[ 'PERLLIB',      _split_paths( $ENV{PERLLIB} )  ],
		);

	$logger->info( '-' x 50 . "\nChecking install dirs..." );
	foreach my $tuple ( @@checks ) {
		my( $label ) = $tuple->[0];

		$logger->info( "Checking $label" );
		$logger->info( "\tno directories for $label" ) unless @@{ $tuple->[1] };
		foreach my $dir ( @@{ $tuple->[1] } ) {
			_print_inc_dir_report( $dir );
			}
		}

	}

sub _split_paths
	{
	[ map { _expand_filename( $_ ) } split /$Config{path_sep}/, $_[0] || '' ];
	}


=pod

Stolen from File::Path::Expand

=cut

sub _expand_filename
	{
    my( $path ) = @@_;
    no warnings 'uninitialized';
    $logger->debug( "Expanding path $path\n" );
    $path =~ s{\A~([^/]+)?}{
		_home_of( $1 || $> ) || "~$1"
    	}e;
    return $path;
	}

sub _home_of
	{
	require User::pwent;
    my( $user ) = @@_;
    my $ent = User::pwent::getpw($user) or return;
    return $ent->dir;
	}

sub _get_default_inc
	{
	require Config;

	[ @@Config::Config{ _vars() }, '.' ];
	}

sub _vars {
	qw(
	installarchlib
	installprivlib
	installsitearch
	installsitelib
	);
	}

sub _ping_mirrors {
	my $urls   = $CPAN::Config->{urllist};
	require URI;

	foreach my $url ( @@$urls ) {
		my( $obj ) = URI->new( $url );
		next unless _is_pingable_scheme( $obj );
		my $host = $obj->host;
		_print_ping_report( $obj );
		}

	}

sub _is_pingable_scheme {
	my( $uri ) = @@_;

	$uri->scheme eq 'file'
	}

sub _find_good_mirrors {
	require CPAN::Mirrors;

	my $mirrors = CPAN::Mirrors->new;
	my $file = do {
		my $file = 'MIRRORED.BY';
		my $local_path = File::Spec->catfile(
			$CPAN::Config->{keep_source_where}, $file );

		if( -e $local_path ) { $local_path }
		else {
			require CPAN::FTP;
			CPAN::FTP->localize( $file, $local_path, 3, 1 );
			$local_path;
			}
		};

	$mirrors->parse_mirrored_by( $file );

	my @@mirrors = $mirrors->best_mirrors(
		how_many   => 3,
		verbose    => 1,
		);

	foreach my $mirror ( @@mirrors ) {
		next unless eval { $mirror->can( 'http' ) };
		_print_ping_report( $mirror->http );
		}

	}

sub _print_inc_dir_report
	{
	my( $dir ) = shift;

	my $writeable = -w $dir ? '+' : '!!! (not writeable)';
	$logger->info( "\t$writeable $dir" );
	return -w $dir;
	}

sub _print_ping_report
	{
	my( $mirror ) = @@_;

	my $rtt = eval { _get_ping_report( $mirror ) };

	$logger->info(
		sprintf "\t%s (%4d ms) %s", $rtt  ? '+' : '!',  $rtt * 1000, $mirror
		);
	}

sub _get_ping_report
	{
	require URI;
	my( $mirror ) = @@_;
	my( $url ) = ref $mirror ? $mirror : URI->new( $mirror ); #XXX
	require Net::Ping;

	my $ping = Net::Ping->new( 'tcp', 1 );

	if( $url->scheme eq 'file' ) {
		return -e $url->file;
		}

    my( $port ) = $url->port;

    return unless $port;

    if ( $ping->can('port_number') ) {
        $ping->port_number($port);
    	}
    else {
        $ping->{'port_num'} = $port;
    	}

    $ping->hires(1) if $ping->can( 'hires' );
    my( $alive, $rtt ) = eval{ $ping->ping( $url->host ) };
	$alive ? $rtt : undef;
	}

sub _load_local_lib # -I
	{
	$logger->debug( "Loading local::lib" );

	my $rc = eval { require local::lib; 1; };
	unless( $rc ) {
		$logger->die( "Could not load local::lib" );
		}

	local::lib->import;

	return HEY_IT_WORKED;
	}

d645 1
a645 1
sub _dump_config # -J
d662 1
a662 1
sub _lock_lobotomy # -F
d823 1
a823 1
			$arg, $module->userid, $author->email, $author->name;
d894 1
a894 1
sub _list_all_mods # -l
a968 1
        # split package line to hide from PAUSE
d970 1
a970 2
		package
                  ExtUtils::MakeMaker::_version;
a1031 10
* Support local::lib

* Warnings switch

* Check then exit

* ping mirrors support

* no test option

d1049 1
a1049 1
Japheth Cleaver added the bits to allow a forced install (C<-f>).
d1054 1
a1054 1
Adam Kennedy pointed out that C<exit()> causes problems on Windows
a1056 2
David Golden helps integrate this into the C<CPAN.pm> repos.

d1063 1
a1063 1
Copyright (c) 2001-2013, brian d foy, All Rights Reserved.
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@d3 1
d8 1
a8 3
use if $] < 5.008 => "IO::Scalar";

$VERSION = '1.62';
d127 1
a127 1
List all installed modules with their versions
d399 1
a399 1
The C<run> method returns 0 on success and a positive number on
d582 1
a582 6
	my $fh;
	if ($] < 5.008) {
		$fh = IO::Scalar->new(\ $scalar);
        } else {
		eval q{open $fh, "<", \\ $scalar;};
        }
a961 1
	local $Data::Dumper::Sortkeys = 1;
@


1.1.1.5
log
@Import perl-5.24.2
@
text
@d7 1
a7 1
use if $] < 5.008 => 'IO::Scalar';
d9 1
a9 1
$VERSION = '1.63_01';
a25 3
	# one time mirror override for faster mirrors
	cpan -p ...

a137 5
=item -M mirror1,mirror2,...

A comma-separated list of mirrors to use for just this run. The C<-P>
option can find them for you automatically.

d148 1
a148 1
Ping the configured mirrors and print a report
d152 1
a152 2
Find the best mirrors you could be using and use them for the current
session.
a210 45
	# install modules but without testing them
	cpan -Ti CGI::Minimal URI

=head2 Environment variables

There are several components in CPAN.pm that use environment variables.
The build tools, L<ExtUtils::MakeMaker> and L<Module::Build> use some,
while others matter to the levels above them. Some of these are specified
by the Perl Toolchain Gang:

Lancaster Concensus: L<https://github.com/Perl-Toolchain-Gang/toolchain-site/blob/master/lancaster-consensus.md>

Oslo Concensus: L<https://github.com/Perl-Toolchain-Gang/toolchain-site/blob/master/oslo-consensus.md>

=over 4

=item NONINTERACTIVE_TESTING

Assume no one is paying attention and skips prompts for distributions
that do that correctly. C<cpan(1)> sets this to C<1> unless it already
has a value (even if that value is false).

=item PERL_MM_USE_DEFAULT

Use the default answer for a prompted questions. C<cpan(1)> sets this
to C<1> unless it already has a value (even if that value is false).

=item CPAN_OPTS

As with C<PERL5OPTS>, a string of additional C<cpan(1)> options to
add to those you specify on the command line.

=item CPANSCRIPT_LOGLEVEL

The log level to use, with either the embedded, minimal logger or
L<Log::Log4perl> if it is installed. Possible values are the same as
the C<Log::Log4perl> levels: C<TRACE>, C<DEBUG>, C<INFO>, C<WARN>,
C<ERROR>, and C<FATAL>. The default is C<INFO>.

=item GIT_COMMAND

The path to the C<git> binary to use for the Git features. The default
is C</usr/local/bin/git>.

=back
d219 1
a219 1
use CPAN 1.80 (); # needs no test
d248 1
a248 1
@@META_OPTIONS = qw( h v V I g G M: C A D O l L a r p P j: J w T);
a259 1
	'T'      => 'notest',
a285 2
	M =>  [ \&_use_these_mirrors,    ARGS, GOOD_EXIT, 'Setting per session mirrors'  ],
	P =>  [ \&_find_good_mirrors, NO_ARGS, GOOD_EXIT, 'Finding good mirrors'         ],
d287 1
d302 1
a311 1
	T =>  [ \&_default,              ARGS, GOOD_EXIT, 'Installing with notest'       ],
d367 1
a367 3
	$class->_turn_off_testing if $options->{T};

	foreach my $o ( qw(F I w P M) )
d388 1
a388 5

	# don't count options that imply installation
	foreach my $opt ( qw(f T) ) { # don't count force or notest
		$option_count -= $options->{$opt};
		}
a394 8
sub _setup_environment {
# should we override or set defaults? If this were a true interactive
# session, we'd be in the CPAN shell.

# https://github.com/Perl-Toolchain-Gang/toolchain-site/blob/master/lancaster-consensus.md
	$ENV{NONINTERACTIVE_TESTING} = 1 unless defined $ENV{NONINTERACTIVE_TESTING};
	$ENV{PERL_MM_USE_DEFAULT}    = 1 unless defined $ENV{PERL_MM_USE_DEFAULT};
	}
a426 2
	$class->_setup_environment( $options );

d433 1
a433 1
			qw( code takes_args description );
a460 11
# load a module without searching the default entry for the current
# directory
sub _safe_load_module {
  my $name = shift;

  local @@INC = @@INC;
  pop @@INC if $INC[-1] eq '.';

  eval "require $name; 1";
}

d463 1
a463 1
	my $log4perl_loaded = _safe_load_module("Log::Log4perl");
a466 1
        print "Loading internal null logger. Install Log::Log4perl for logging messages\n";
d497 1
a497 1
		next if ( $option eq 'f' or $option eq 'T' );
d515 1
a515 1
	# call the CPAN::Shell method, with force or notest if specified
d517 2
a518 3
		   if( $options->{f} ) { sub { CPAN::Shell->force( $method, @@_ )  } }
		elsif( $options->{T} ) { sub { CPAN::Shell->notest( $method, @@_ ) } }
		else                   { sub { CPAN::Shell->$method( @@_ )         } }
d522 1
a522 1
	my @@errors = ();
d529 1
a529 2
		my $error = _cpanpm_output_indicates_failure();
		push @@errors, $error if $error;
d532 1
a532 5
	return do {
		if( @@errors ) { $errors[0] }
		else { HEY_IT_WORKED }
		};

a573 3
# These are lines I don't care about in CPAN.pm output. If I can
# filter out the informational noise, I have a better chance to
# catch the error signal
a578 6
	qr/^Try the command/,
	qr/^\s+$/,
	qr/^to find objects/,
	qr/^\s*Database was generated on/,
	qr/^Going to read/,
	qr|^\s+i\s+/|,    # the i /Foo::Whatever/ line when it doesn't know
d584 5
a588 7

	if( $] < 5.008 ) {
		$fh = IO::Scalar->new( \ $scalar );
		}
	else {
		eval q{ open $fh, '<', \\ $scalar; };
		}
d614 1
a614 2
	qw( Error stop(?:ping)? problems force not unsupported
		fail(?:ed)? Cannot\s+install );
a620 2
	return A_MODULE_FAILED_TO_INSTALL if $last_line =~ /\b(?:Cannot\s+install)\b/i;

d820 1
d833 2
a834 1
	my $mirrors = CPAN::Mirrors->new( $file );
d837 1
a837 1
		how_many   => 5,
a845 3
	$CPAN::Config->{urllist} = [
		map { $_->http } @@mirrors
		];
a861 1
	my $result = $rtt ? sprintf "+ (%4d ms)", $rtt * 1000 : '!';
d864 1
a864 1
		sprintf "\t%s %s", $result, $mirror
d901 1
a901 1
	my $rc = _safe_load_module("local::lib");
a910 13
sub _use_these_mirrors # -M
	{
	$logger->debug( "Setting per session mirrors" );
	unless( $_[0] ) {
		$logger->die( "The -M switch requires a comma-separated list of mirrors" );
		}

	$CPAN::Config->{urllist} = [ split /,/, $_[0] ];

	$logger->debug( "Mirrors are @@{$CPAN::Config->{urllist}}" );

	}

d1016 1
a1016 1
	my $loaded = _safe_load_module("LWP::Simple");
d1038 1
a1038 1
	my $loaded = _safe_load_module("Archive::Extract");
d1102 1
a1102 1
		unless _safe_load_module("LWP::Simple") && _safe_load_module("URI");
d1160 3
a1162 3
			$module->cpan_file ? $module->cpan_file : "(no cpanfile)",
			$module->inst_file ? $module->inst_file :"(no installation file)" ,
			'Installed: ' . ($module->inst_version ? $module->inst_version : "not installed"),
d1309 1
a1309 1
	return if length $path < length $inc;
d1351 2
d1357 2
d1367 2
a1368 1
L<CPAN>, L<App::cpanminus>
d1372 1
a1372 3
This code is in Github in the CPAN.pm repository:

	https://github.com/andk/cpanpm
d1374 1
a1374 2
The source used to be tracked separately in another GitHub repo,
but the canonical source is now in the above repo.
d1394 1
a1394 1
Copyright (c) 2001-2014, brian d foy, All Rights Reserved.
@


1.1.1.4.4.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d9 1
a9 1
$VERSION = '1.62_01';
a460 11
# load a module without searching the default entry for the current
# directory
sub _safe_load_module {
  my $name = shift;

  local @@INC = @@INC;
  pop @@INC if $INC[-1] eq '.';

  eval "require $name; 1";
}

d463 1
a463 1
	my $log4perl_loaded = _safe_load_module("Log::Log4perl");
d901 1
a901 1
	my $rc = _safe_load_module("local::lib");
d1016 1
a1016 1
	my $loaded = _safe_load_module("LWP::Simple");
d1038 1
a1038 1
	my $loaded = _safe_load_module("Archive::Extract");
d1102 1
a1102 1
		unless _safe_load_module("LWP::Simple") && _safe_load_module("URI");
@


1.1.1.4.6.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d9 1
a9 1
$VERSION = '1.62_01';
a460 11
# load a module without searching the default entry for the current
# directory
sub _safe_load_module {
  my $name = shift;

  local @@INC = @@INC;
  pop @@INC if $INC[-1] eq '.';

  eval "require $name; 1";
}

d463 1
a463 1
	my $log4perl_loaded = _safe_load_module("Log::Log4perl");
d901 1
a901 1
	my $rc = _safe_load_module("local::lib");
d1016 1
a1016 1
	my $loaded = _safe_load_module("LWP::Simple");
d1038 1
a1038 1
	my $loaded = _safe_load_module("Archive::Extract");
d1102 1
a1102 1
		unless _safe_load_module("LWP::Simple") && _safe_load_module("URI");
@


