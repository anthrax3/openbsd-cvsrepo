head	1.2;
access;
symbols
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.3
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.2.0.10
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.4
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.6
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.2
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.1.0.8
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.6
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.2
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.05;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2013.03.25.20.08.20;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.03.25.20.08.20;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.11.17.20.53.00;	author afresh1;	state Exp;
branches;
next	1.1.1.3;
commitid	B31cAbBIXiCqnL97;

1.1.1.3
date	2017.08.14.13.46.04;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!perl
#
# This auxiliary script makes five header files
# used for building XSUB of Unicode::Collate.
#
# Usage:
#    <do 'mkheader'> in perl, or <perl mkheader> in command line
#
# Input file:
#    Collate/allkeys.txt
#
# Output file:
#    ucatbl.h
#
use 5.006;
use strict;
use warnings;
use Carp;
use File::Spec;

BEGIN {
    unless ("A" eq pack('U', 0x41)) {
	die "Unicode::Collate cannot stringify a Unicode code point\n";
    }
    unless (0x41 == unpack('U', 'A')) {
	die "Unicode::Collate cannot get a Unicode code point\n";
    }
}

use constant TRUE  => 1;
use constant FALSE => "";
use constant VCE_TEMPLATE => 'Cn4';

sub _getHexArray { map hex, $_[0] =~ /([0-9a-fA-F]+)/g }

our $PACKAGE = 'Unicode::Collate, mkheader';
our $prefix  = "UCA_";

our %SimpleEntries;	# $codepoint => $keys
our @@Rest;

{
    my($f, $fh);
    foreach my $d (File::Spec->curdir()) {
	$f = File::Spec->catfile($d, "Collate", "allkeys.txt");
	last if open($fh, $f);
	$f = undef;
    }
    croak "$PACKAGE: Collate/allkeys.txt is not found" if !defined $f;

    while (my $line = <$fh>) {
	next if $line =~ /^\s*#/;
	if ($line =~ /^\s*\@@/) {
	    push @@Rest, $line;
	    next;
	}

	next if $line !~ /^\s*[0-9A-Fa-f]/; # lines without element

	$line =~ s/[#%]\s*(.*)//; # removing comment (not getting the name)

	# gets element
	my($e, $k) = split /;/, $line;

	croak "Wrong Entry: <charList> must be separated by ';' ".
	      "from <collElement>" if ! $k;

	my @@uv = _getHexArray($e);
	next if !@@uv;

	if (@@uv != 1) {
	    push @@Rest, $line;
	    next;
	    # Contractions of two or more characters will not be compiled.
	}

	my $is_L3_ignorable = TRUE;

	my @@key;
	foreach my $arr ($k =~ /\[([^\[\]]+)\]/g) { # SPACEs allowed
	    my $var = $arr =~ /\*/; # exactly /^\*/ but be lenient.
	    my @@wt = _getHexArray($arr);
	    push @@key, pack(VCE_TEMPLATE, $var, @@wt);
	    $is_L3_ignorable = FALSE
		if $wt[0] || $wt[1] || $wt[2];
	    # Conformance Test for 3.1.1 and 4.0.0 shows Level 3 ignorable
	    # is completely ignorable.
	    # For expansion, an entry $is_L3_ignorable
	    # if and only if "all" CEs are [.0000.0000.0000].
	}
	my $mapping = $is_L3_ignorable ? [] : \@@key;
	my $num = @@$mapping;
	my $str = chr($num).join('', @@$mapping);
	$SimpleEntries{$uv[0]} = stringify($str);
    }
}

sub stringify {
    my $str = shift;
    return sprintf '"%s"', join '',
	   map sprintf("\\x%02x", ord $_), split //, $str;

}

########## writing header files ##########

my $init = '';
{
    my $type = "char* const";
    my $head = $prefix."rest";

    $init .= "static const $type $head [] = {\n";
    for my $line (@@Rest) {
	$line =~ s/\s*\z//;
	next if $line eq '';
	$init .= "/*$line*/\n" if $line =~ /^[A-Za-z0-9_.:;@@\ \[\]]+\z/;
	$init .= stringify($line).",\n";
    }
    $init .= "NULL\n"; # sentinel
    $init .= "};\n\n";
}

my @@tripletable = (
    {
	file => "ucatbl",
	name => "simple",
	type => "char* const",
	hash => \%SimpleEntries,
	null => "NULL",
	init => $init,
    },
);

foreach my $tbl (@@tripletable) {
    my $file = "$tbl->{file}.h";
    my $head = "${prefix}$tbl->{name}";
    my $type = $tbl->{type};
    my $hash = $tbl->{hash};
    my $null = $tbl->{null};
    my $init = $tbl->{init};

    open my $fh_h, ">$file" or croak "$PACKAGE: $file can't be made";
    binmode $fh_h; select $fh_h;
    my %val;

    print << 'EOF';
/*
 * This file is auto-generated by mkheader.
 * Any changes here will be lost!
 */
EOF

    print $init if defined $init;

    foreach my $uv (keys %$hash) {
	croak sprintf("a Unicode code point 0x%04X over 0x10FFFF.", $uv)
	    unless $uv <= 0x10FFFF;
	my @@c = unpack 'CCCC', pack 'N', $uv;
	$val{ $c[1] }{ $c[2] }{ $c[3] } = $hash->{$uv};
	# $c[0] must be 0.
    }

    foreach my $p (sort { $a <=> $b } keys %val) {
	next if ! $val{ $p };
	for (my $r = 0; $r < 256; $r++) {
	    next if ! $val{ $p }{ $r };
	    printf "static const $type ${head}_%02x_%02x [256] = {\n", $p, $r;
	    for (my $c = 0; $c < 256; $c++) {
		print "\t", defined $val{$p}{$r}{$c}
		    ? $val{$p}{$r}{$c}
		    : $null;
		print ','  if $c != 255;
		print "\n" if $c % 8 == 7;
	    }
	    print "};\n\n";
	}
    }
    foreach my $p (sort { $a <=> $b } keys %val) {
	next if ! $val{ $p };
	printf "static const $type* const ${head}_%02x [256] = {\n", $p;
	for (my $r = 0; $r < 256; $r++) {
	    print $val{ $p }{ $r }
		? sprintf("${head}_%02x_%02x", $p, $r)
		: "NULL";
	    print ','  if $r != 255;
	    print "\n" if $val{ $p }{ $r } || ($r+1) % 8 == 0;
	}
	print "};\n\n";
    }
    print "static const $type* const * const $head [] = {\n";
    for (my $p = 0; $p <= 0x10; $p++) {
	print $val{ $p } ? sprintf("${head}_%02x", $p) : "NULL";
	print ','  if $p != 0x10;
	print "\n";
    }
    print "};\n\n";
    close $fh_h;
}

1;
__END__
@


1.1
log
@Initial revision
@
text
@d25 3
d58 1
a58 1
	next if $line !~ /^\s*[0-9A-Fa-f]/;
d74 1
d109 1
a109 1
    my $type = "char*";
d112 1
a112 1
    $init .= "static $type $head [] = {\n";
d117 1
a117 1
	$init .= "($type)".stringify($line).",\n";
d127 1
a127 1
	type => "char*",
d142 2
a143 2
    open FH, ">$file" or croak "$PACKAGE: $file can't be made";
    binmode FH; select FH;
d146 1
a146 1
    print FH << 'EOF';
d160 1
d167 1
a167 1
	    printf "static $type ${head}_%02x_%02x [256] = {\n", $p, $r;
d170 1
a170 1
		    ? "($type)".$val{$p}{$r}{$c}
d180 1
a180 1
	printf "static $type* ${head}_%02x [256] = {\n", $p;
d190 1
a190 1
    print "static $type** $head [] = {\n";
d197 1
a197 1
    close FH;
@


1.1.1.1
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@@


1.1.1.2
log
@Import perl-5.20.1
@
text
@a24 3
    unless (0x41 == unpack('U', 'A')) {
	die "Unicode::Collate cannot get a Unicode code point\n";
    }
d138 2
a139 2
    open my $fh_h, ">$file" or croak "$PACKAGE: $file can't be made";
    binmode $fh_h; select $fh_h;
d142 1
a142 1
    print << 'EOF';
d192 1
a192 1
    close $fh_h;
@


1.1.1.3
log
@Import perl-5.24.2
@
text
@d58 1
a58 1
	next if $line !~ /^\s*[0-9A-Fa-f]/; # lines without element
a73 1
	    # Contractions of two or more characters will not be compiled.
d108 1
a108 1
    my $type = "char* const";
d111 1
a111 1
    $init .= "static const $type $head [] = {\n";
d116 1
a116 1
	$init .= stringify($line).",\n";
d126 1
a126 1
	type => "char* const",
a158 1
	# $c[0] must be 0.
d165 1
a165 1
	    printf "static const $type ${head}_%02x_%02x [256] = {\n", $p, $r;
d168 1
a168 1
		    ? $val{$p}{$r}{$c}
d178 1
a178 1
	printf "static const $type* const ${head}_%02x [256] = {\n", $p;
d188 1
a188 1
    print "static const $type* const * const $head [] = {\n";
@


