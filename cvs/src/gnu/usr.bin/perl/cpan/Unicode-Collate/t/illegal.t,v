head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.6
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.4
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.3.0.10
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.4
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.6
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.8
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.06;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2010.09.24.14.49.04;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.04;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.08.30;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.11.17.20.53.01;	author afresh1;	state Exp;
branches;
next	1.1.1.4;
commitid	B31cAbBIXiCqnL97;

1.1.1.4
date	2017.08.14.13.46.06;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@
BEGIN {
    unless ('A' eq pack('U', 0x41)) {
	print "1..0 # Unicode::Collate cannot pack a Unicode code point\n";
	exit 0;
    }
    unless (0x41 == unpack('U', 'A')) {
	print "1..0 # Unicode::Collate cannot get a Unicode code point\n";
	exit 0;
    }
    if ($ENV{PERL_CORE}) {
	chdir('t') if -d 't';
	@@INC = $^O eq 'MacOS' ? qw(::lib) : qw(../lib);
    }
}


BEGIN {
    use Unicode::Collate;

#    unless (exists &Unicode::Collate::bootstrap or 5.008 <= $]) {
#	print "1..0 # skipped: XSUB, or Perl 5.8.0 or later".
#		" needed for this test\n";
    unless (5.008 <= $]) {
	print "1..0 # skipped: Perl 5.8.0 or later needed for this test\n";
	print $@@;
	exit;
    }
}

use strict;
use warnings;
BEGIN { $| = 1; print "1..136\n"; } # 81 + 5 x @@Versions
my $count = 0;
sub ok ($;$) {
    my $p = my $r = shift;
    if (@@_) {
	my $x = shift;
	$p = !defined $x ? !defined $r : !defined $r ? 0 : $r eq $x;
    }
    print $p ? "ok" : "not ok", ' ', ++$count, "\n";
}

ok(1);

#########################

no warnings 'utf8';

# NULL is tailorable but illegal code points are not.
# illegal code points should be always ingored
# (cf. UCA, 7.1.1 Illegal code points).

my $entry = <<'ENTRIES';
0000  ; [.0020.0000.0000.0000] # [0000] NULL
0001  ; [.0021.0000.0000.0001] # [0001] START OF HEADING
FFFE  ; [.0022.0000.0000.FFFE] # <noncharacter-FFFE> (invalid)
FFFF  ; [.0023.0000.0000.FFFF] # <noncharacter-FFFF> (invalid)
D800  ; [.0024.0000.0000.D800] # <surrogate-D800> (invalid)
DFFF  ; [.0025.0000.0000.DFFF] # <surrogate-DFFF> (invalid)
FDD0  ; [.0026.0000.0000.FDD0] # <noncharacter-FDD0> (invalid)
FDEF  ; [.0027.0000.0000.FDEF] # <noncharacter-FDEF> (invalid)
0002  ; [.0030.0000.0000.0002] # [0002] START OF TEXT
10FFFF; [.0040.0000.0000.10FFFF] # <noncharacter-10FFFF> (invalid)
110000; [.0041.0000.0000.110000] # <out-of-range 110000> (invalid)
0041  ; [.1000.0020.0008.0041] # latin A
0041 0000 ; [.1100.0020.0008.0041] # latin A + NULL
0041 FFFF ; [.1200.0020.0008.0041] # latin A + FFFF (invalid)
ENTRIES

##################

my $illeg = Unicode::Collate->new(
  entry => $entry,
  level => 1,
  table => undef,
  normalization => undef,
  UCA_Version => 20,
);

# 2..12
ok($illeg->lt("", "\x00"));
ok($illeg->lt("", "\x01"));
ok($illeg->eq("", "\x{FFFE}"));
ok($illeg->eq("", "\x{FFFF}"));
ok($illeg->eq("", "\x{D800}"));
ok($illeg->eq("", "\x{DFFF}"));
ok($illeg->eq("", "\x{FDD0}"));
ok($illeg->eq("", "\x{FDEF}"));
ok($illeg->lt("", "\x02"));
ok($illeg->eq("", "\x{10FFFF}"));
ok($illeg->eq("", "\x{110000}"));

# 13..22
ok($illeg->lt("\x00", "\x01"));
ok($illeg->lt("\x01", "\x02"));
ok($illeg->ne("\0", "\x{D800}"));
ok($illeg->ne("\0", "\x{DFFF}"));
ok($illeg->ne("\0", "\x{FDD0}"));
ok($illeg->ne("\0", "\x{FDEF}"));
ok($illeg->ne("\0", "\x{FFFE}"));
ok($illeg->ne("\0", "\x{FFFF}"));
ok($illeg->ne("\0", "\x{10FFFF}"));
ok($illeg->ne("\0", "\x{110000}"));

# 23..26
ok($illeg->eq("A",   "A\x{FFFF}"));
ok($illeg->gt("A\0", "A\x{FFFF}"));
ok($illeg->lt("A",  "A\0"));
ok($illeg->lt("AA", "A\0"));

##################

my $nonch = Unicode::Collate->new(
  entry => $entry,
  level => 1,
  table => undef,
  normalization => undef,
  UCA_Version => 22,
);

# 27..37
ok($nonch->lt("", "\x00"));
ok($nonch->lt("", "\x01"));
ok($nonch->lt("", "\x{FFFE}"));
ok($nonch->lt("", "\x{FFFF}"));
ok($nonch->lt("", "\x{D800}"));
ok($nonch->lt("", "\x{DFFF}"));
ok($nonch->lt("", "\x{FDD0}"));
ok($nonch->lt("", "\x{FDEF}"));
ok($nonch->lt("", "\x02"));
ok($nonch->lt("", "\x{10FFFF}"));
ok($nonch->lt("", "\x{110000}"));

# 38..47
ok($nonch->lt("\x00",     "\x01"));
ok($nonch->lt("\x01",     "\x{FFFE}"));
ok($nonch->lt("\x{FFFE}", "\x{FFFF}"));
ok($nonch->lt("\x{FFFF}", "\x{D800}"));
ok($nonch->lt("\x{D800}", "\x{DFFF}"));
ok($nonch->lt("\x{DFFF}", "\x{FDD0}"));
ok($nonch->lt("\x{FDD0}", "\x{FDEF}"));
ok($nonch->lt("\x{FDEF}", "\x02"));
ok($nonch->lt("\x02",     "\x{10FFFF}"));
ok($nonch->lt("\x{10FFFF}", "\x{110000}"));

# 48..51
ok($nonch->lt("A",   "A\x{FFFF}"));
ok($nonch->lt("A\0", "A\x{FFFF}"));
ok($nonch->lt("A",  "A\0"));
ok($nonch->lt("AA", "A\0"));

##################

my $Collator = Unicode::Collate->new(
  table => 'keys.txt',
  level => 1,
  normalization => undef,
  UCA_Version => 8,
);

my @@ret = (
    "Pe\x{300}\x{301}",
    "Pe\x{300}\0\0\x{301}",
    "Pe\x{DA00}\x{301}\x{DFFF}",
    "Pe\x{FFFF}\x{301}",
    "Pe\x{110000}\x{301}",
    "Pe\x{300}\x{d801}\x{301}",
    "Pe\x{300}\x{ffff}\x{301}",
    "Pe\x{300}\x{110000}\x{301}",
    "Pe\x{D9ab}\x{DFFF}",
    "Pe\x{FFFF}",
    "Pe\x{110000}",
    "Pe\x{300}\x{D800}\x{DFFF}",
    "Pe\x{300}\x{FFFF}",
    "Pe\x{300}\x{110000}",
);

# 52..65
for my $ret (@@ret) {
    my $str = $ret."rl";
    my($match) = $Collator->match($str, "pe");
    ok($match eq $ret);
}

##################

my $out = Unicode::Collate->new(
    level => 1,
    table => undef,
    normalization => undef,
    overrideOut => sub { 0xFFFD },
);

my @@Versions = (8, 9, 11, 14, 16, 18, 20, 22, 24, 26, 28);

for my $v (@@Versions) {
    $out->change(UCA_Version => $v);
    ok($out->cmp('',           "\x{10FFFF}") == ($v >= 22 ? -1 : 0));
    ok($out->cmp('',           "\x{110000}") == ($v >= 22 ? -1 : 0));
    ok($out->cmp('ABC',        "\x{110000}") == ($v >= 22 ? -1 : 1));
    ok($out->cmp("\x{10FFFD}", "\x{110000}") == ($v >= 22 ? -1 : 1));
    ok($out->cmp("\x{11FFFD}", "\x{110000}") == ($v >= 22 ?  0 : 0));
}

# x+66..x+77
ok($out->lt('ABC',      "\x{123456}"));
ok($out->lt("\x{FFFD}", "\x{123456}"));

$out->change(overrideOut => sub {()});

ok($out->eq('',         "\x{123456}"));
ok($out->gt('ABC',      "\x{123456}"));
ok($out->gt("\x{FFFD}", "\x{123456}"));

$out->change(overrideOut => undef);
ok($out->lt('',         "\x{123456}"));
ok($out->eq("\x{FFFD}", "\x{123456}"));

$out->change(overrideOut => sub { 0xFFFD });

ok($out->lt('',         "\x{123456}"));
ok($out->lt('ABC',      "\x{123456}"));
ok($out->lt("\x{FFFD}", "\x{123456}"));

$out->change(overrideOut => 0);
ok($out->lt('',         "\x{123456}"));
ok($out->eq("\x{FFFD}", "\x{123456}"));

$out->change(overrideOut => sub { undef });
ok($out->lt('',         "\x{123456}"));
ok($out->eq("\x{FFFD}", "\x{123456}"));
ok($out->eq("\x{FFFD}", "\x{21FFFFF}"));
ok($out->eq("\x{FFFD}", "\x{2200000}"));

@


1.1
log
@Initial revision
@
text
@d3 6
a8 3
    unless ("A" eq pack('U', 0x41)) {
	print "1..0 # Unicode::Collate " .
	    "cannot stringify a Unicode code point\n";
a16 3
use Test;
use strict;
use warnings;
d21 5
a25 3
    unless (exists &Unicode::Collate::bootstrap or 5.008 <= $]) {
	print "1..0 # skipped: XSUB, or Perl 5.8.0 or later".
		" needed for this test\n";
d31 12
a42 1
BEGIN { plan tests => 40 };
d54 1
a54 2
my $illeg = Unicode::Collate->new(
  entry => <<'ENTRIES',
d70 5
d78 1
d114 40
a153 1
my($match, $str, $sub, $ret);
d159 18
d179 6
a184 1
$sub = "pe";
d186 1
d188 17
a204 69
$str = "Pe\x{300}\x{301}rl";
$ret = "Pe\x{300}\x{301}";
($match) = $Collator->match($str, $sub);
ok($match, $ret);

$str = "Pe\x{300}\0\0\x{301}rl";
$ret = "Pe\x{300}\0\0\x{301}";
($match) = $Collator->match($str, $sub);
ok($match, $ret);

$str = "Pe\x{DA00}\x{301}\x{DFFF}rl";
$ret = "Pe\x{DA00}\x{301}\x{DFFF}";
($match) = $Collator->match($str, $sub);
ok($match, $ret);

$str = "Pe\x{FFFF}\x{301}rl";
$ret = "Pe\x{FFFF}\x{301}";
($match) = $Collator->match($str, $sub);
ok($match, $ret);

$str = "Pe\x{110000}\x{301}rl";
$ret = "Pe\x{110000}\x{301}";
($match) = $Collator->match($str, $sub);
ok($match, $ret);

$str = "Pe\x{300}\x{d801}\x{301}rl";
$ret = "Pe\x{300}\x{d801}\x{301}";
($match) = $Collator->match($str, $sub);
ok($match, $ret);

$str = "Pe\x{300}\x{ffff}\x{301}rl";
$ret = "Pe\x{300}\x{ffff}\x{301}";
($match) = $Collator->match($str, $sub);
ok($match, $ret);

$str = "Pe\x{300}\x{110000}\x{301}rl";
$ret = "Pe\x{300}\x{110000}\x{301}";
($match) = $Collator->match($str, $sub);
ok($match, $ret);

$str = "Pe\x{D9ab}\x{DFFF}rl";
$ret = "Pe\x{D9ab}\x{DFFF}";
($match) = $Collator->match($str, $sub);
ok($match, $ret);

$str = "Pe\x{FFFF}rl";
$ret = "Pe\x{FFFF}";
($match) = $Collator->match($str, $sub);
ok($match, $ret);

$str = "Pe\x{110000}rl";
$ret = "Pe\x{110000}";
($match) = $Collator->match($str, $sub);
ok($match, $ret);

$str = "Pe\x{300}\x{D800}\x{DFFF}rl";
$ret = "Pe\x{300}\x{D800}\x{DFFF}";
($match) = $Collator->match($str, $sub);
ok($match, $ret);

$str = "Pe\x{300}\x{FFFF}rl";
$ret = "Pe\x{300}\x{FFFF}";
($match) = $Collator->match($str, $sub);
ok($match, $ret);

$str = "Pe\x{300}\x{110000}rl";
$ret = "Pe\x{300}\x{110000}";
($match) = $Collator->match($str, $sub);
ok($match, $ret);
d206 29
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d14 3
d29 1
a29 12
use strict;
use warnings;
BEGIN { $| = 1; print "1..65\n"; }
my $count = 0;
sub ok ($;$) {
    my $p = my $r = shift;
    if (@@_) {
	my $x = shift;
	$p = !defined $x ? !defined $r : !defined $r ? 0 : $r eq $x;
    }
    print $p ? "ok" : "not ok", ' ', ++$count, "\n";
}
d41 2
a42 1
my $entry = <<'ENTRIES';
a57 5

##################

my $illeg = Unicode::Collate->new(
  entry => $entry,
a60 1
  UCA_Version => 20,
d96 1
a96 40
my $nonch = Unicode::Collate->new(
  entry => $entry,
  level => 1,
  table => undef,
  normalization => undef,
  UCA_Version => 22,
);

# 27..37
ok($nonch->lt("", "\x00"));
ok($nonch->lt("", "\x01"));
ok($nonch->lt("", "\x{FFFE}"));
ok($nonch->lt("", "\x{FFFF}"));
ok($nonch->lt("", "\x{D800}"));
ok($nonch->lt("", "\x{DFFF}"));
ok($nonch->lt("", "\x{FDD0}"));
ok($nonch->lt("", "\x{FDEF}"));
ok($nonch->lt("", "\x02"));
ok($nonch->lt("", "\x{10FFFF}"));
ok($nonch->eq("", "\x{110000}"));

# 38..47
ok($nonch->lt("\x00",     "\x01"));
ok($nonch->lt("\x01",     "\x{FFFE}"));
ok($nonch->lt("\x{FFFE}", "\x{FFFF}"));
ok($nonch->lt("\x{FFFF}", "\x{D800}"));
ok($nonch->lt("\x{D800}", "\x{DFFF}"));
ok($nonch->lt("\x{DFFF}", "\x{FDD0}"));
ok($nonch->lt("\x{FDD0}", "\x{FDEF}"));
ok($nonch->lt("\x{FDEF}", "\x02"));
ok($nonch->lt("\x02",     "\x{10FFFF}"));
ok($nonch->gt("\x{10FFFF}", "\x{110000}"));

# 48..51
ok($nonch->lt("A",   "A\x{FFFF}"));
ok($nonch->lt("A\0", "A\x{FFFF}"));
ok($nonch->lt("A",  "A\0"));
ok($nonch->lt("AA", "A\0"));

##################
a101 1
  UCA_Version => 8,
d104 72
a175 16
my @@ret = (
    "Pe\x{300}\x{301}",
    "Pe\x{300}\0\0\x{301}",
    "Pe\x{DA00}\x{301}\x{DFFF}",
    "Pe\x{FFFF}\x{301}",
    "Pe\x{110000}\x{301}",
    "Pe\x{300}\x{d801}\x{301}",
    "Pe\x{300}\x{ffff}\x{301}",
    "Pe\x{300}\x{110000}\x{301}",
    "Pe\x{D9ab}\x{DFFF}",
    "Pe\x{FFFF}",
    "Pe\x{110000}",
    "Pe\x{300}\x{D800}\x{DFFF}",
    "Pe\x{300}\x{FFFF}",
    "Pe\x{300}\x{110000}",
);
a176 6
# 52..65
for my $ret (@@ret) {
    my $str = $ret."rl";
    my($match) = $Collator->match($str, "pe");
    ok($match eq $ret);
}
@


1.1.1.3
log
@Import perl-5.20.1
@
text
@d3 3
a5 6
    unless ('A' eq pack('U', 0x41)) {
	print "1..0 # Unicode::Collate cannot pack a Unicode code point\n";
	exit 0;
    }
    unless (0x41 == unpack('U', 'A')) {
	print "1..0 # Unicode::Collate cannot get a Unicode code point\n";
d28 1
a28 1
BEGIN { $| = 1; print "1..136\n"; } # 81 + 5 x @@Versions
d128 1
a128 1
ok($nonch->lt("", "\x{110000}"));
d140 1
a140 1
ok($nonch->lt("\x{10FFFF}", "\x{110000}"));
a179 50

##################

my $out = Unicode::Collate->new(
    level => 1,
    table => undef,
    normalization => undef,
    overrideOut => sub { 0xFFFD },
);

my @@Versions = (8, 9, 11, 14, 16, 18, 20, 22, 24, 26, 28);

for my $v (@@Versions) {
    $out->change(UCA_Version => $v);
    ok($out->cmp('',           "\x{10FFFF}") == ($v >= 22 ? -1 : 0));
    ok($out->cmp('',           "\x{110000}") == ($v >= 22 ? -1 : 0));
    ok($out->cmp('ABC',        "\x{110000}") == ($v >= 22 ? -1 : 1));
    ok($out->cmp("\x{10FFFD}", "\x{110000}") == ($v >= 22 ? -1 : 1));
    ok($out->cmp("\x{11FFFD}", "\x{110000}") == ($v >= 22 ?  0 : 0));
}

# x+66..x+77
ok($out->lt('ABC',      "\x{123456}"));
ok($out->lt("\x{FFFD}", "\x{123456}"));

$out->change(overrideOut => sub {()});

ok($out->eq('',         "\x{123456}"));
ok($out->gt('ABC',      "\x{123456}"));
ok($out->gt("\x{FFFD}", "\x{123456}"));

$out->change(overrideOut => undef);
ok($out->lt('',         "\x{123456}"));
ok($out->eq("\x{FFFD}", "\x{123456}"));

$out->change(overrideOut => sub { 0xFFFD });

ok($out->lt('',         "\x{123456}"));
ok($out->lt('ABC',      "\x{123456}"));
ok($out->lt("\x{FFFD}", "\x{123456}"));

$out->change(overrideOut => 0);
ok($out->lt('',         "\x{123456}"));
ok($out->eq("\x{FFFD}", "\x{123456}"));

$out->change(overrideOut => sub { undef });
ok($out->lt('',         "\x{123456}"));
ok($out->eq("\x{FFFD}", "\x{123456}"));
ok($out->eq("\x{FFFD}", "\x{21FFFFF}"));
ok($out->eq("\x{FFFD}", "\x{2200000}"));
@


1.1.1.4
log
@Import perl-5.24.2
@
text
@d21 3
a23 5
#    unless (exists &Unicode::Collate::bootstrap or 5.008 <= $]) {
#	print "1..0 # skipped: XSUB, or Perl 5.8.0 or later".
#		" needed for this test\n";
    unless (5.008 <= $]) {
	print "1..0 # skipped: Perl 5.8.0 or later needed for this test\n";
@


