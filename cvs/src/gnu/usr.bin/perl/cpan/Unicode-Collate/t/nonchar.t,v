head	1.2;
access;
symbols
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.4
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.3.0.10
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.4
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.6
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.4
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.6
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.2
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.06;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2013.03.25.20.08.31;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.03.25.20.08.31;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.03.24.14.58.59;	author afresh1;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.11.17.20.53.02;	author afresh1;	state Exp;
branches;
next	1.1.1.4;
commitid	B31cAbBIXiCqnL97;

1.1.1.4
date	2017.08.14.13.46.06;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@
BEGIN {
    unless ('A' eq pack('U', 0x41)) {
	print "1..0 # Unicode::Collate cannot pack a Unicode code point\n";
	exit 0;
    }
    unless (0x41 == unpack('U', 'A')) {
	print "1..0 # Unicode::Collate cannot get a Unicode code point\n";
	exit 0;
    }
    if ($ENV{PERL_CORE}) {
	chdir('t') if -d 't';
	@@INC = $^O eq 'MacOS' ? qw(::lib) : qw(../lib);
    }
}


BEGIN {
    use Unicode::Collate;

#    unless (exists &Unicode::Collate::bootstrap or 5.008 <= $]) {
#	print "1..0 # skipped: XSUB, or Perl 5.8.0 or later".
#		" needed for this test\n";
    unless (5.008 <= $]) {
	print "1..0 # skipped: Perl 5.8.0 or later needed for this test\n";
	print $@@;
	exit;
    }
}

use strict;
use warnings;
BEGIN { $| = 1; print "1..90\n"; }
my $count = 0;
sub ok ($;$) {
    my $p = my $r = shift;
    if (@@_) {
	my $x = shift;
	$p = !defined $x ? !defined $r : !defined $r ? 0 : $r eq $x;
    }
    print $p ? "ok" : "not ok", ' ', ++$count, "\n";
}

ok(1);

#########################

no warnings 'utf8';

# Unicode 6.0 Sorting
#
# Special Database Values. The data files for CLDR provide
# special weights for two noncharacters:
#
# 1. A special noncharacter <HIGH> (U+FFFF) for specification of a range
#    in a database, allowing "Sch" <= X <= "Sch<HIGH>" to pick all strings
#    starting with "sch" plus those that sort equivalently.
# 2. A special noncharacter <LOW> (U+FFFE) for merged database fields,
#    allowing "Disi\x{301}lva<LOW>John" to sort next to "Disilva<LOW>John".

my $entry = <<'ENTRIES';
FFFE  ; [.0001.0020.0005.FFFE] # <noncharacter-FFFE>
FFFF  ; [.FFFE.0020.0005.FFFF] # <noncharacter-FFFF>
ENTRIES

my @@disilva = ("di Silva", "diSilva", "di Si\x{301}lva", "diSi\x{301}lva");
my @@dsf = map "$_\x{FFFE}Fred", @@disilva;
my @@dsj = map "$_\x{FFFE}John", @@disilva;
my @@dsJ = map        "$_ John", @@disilva;

for my $norm (undef, 'NFD') {
    if (defined $norm) {
	eval { require Unicode::Normalize };
	if ($@@) {
	    ok(1) for 1..34; # silent skip
	    next;
	}
    }

    my $coll = Unicode::Collate->new(
	table => 'keys.txt',
	level => 1,
	normalization => $norm,
	UCA_Version => 22,
	entry => $entry,
    );

    # 1..4
    ok($coll->lt("\x{FFFD}",   "\x{FFFF}"));
    ok($coll->lt("\x{1FFFD}",  "\x{1FFFF}"));
    ok($coll->lt("\x{2FFFD}",  "\x{2FFFF}"));
    ok($coll->lt("\x{10FFFD}", "\x{10FFFF}"));

    # 5..14
    ok($coll->lt("perl\x{FFFD}",   "perl\x{FFFF}"));
    ok($coll->lt("perl\x{1FFFD}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{1FFFE}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{1FFFF}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{2FFFD}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{2FFFE}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{2FFFF}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{10FFFD}", "perl\x{FFFF}"));
    ok($coll->lt("perl\x{10FFFE}", "perl\x{FFFF}"));
    ok($coll->lt("perl\x{10FFFF}", "perl\x{FFFF}"));

    # 15..16
    ok($coll->gt("perl\x{FFFF}AB", "perl\x{FFFF}"));
    ok($coll->lt("perl\x{FFFF}\x{10FFFF}", "perl\x{FFFF}\x{FFFF}"));

    $coll->change(level => 4);

    # 17..25
    for my $i (0 .. $#disilva - 1) {
	ok($coll->lt($dsf[$i], $dsf[$i+1]));
	ok($coll->lt($dsj[$i], $dsj[$i+1]));
	ok($coll->lt($dsJ[$i], $dsJ[$i+1]));
    }

    # 26
    ok($coll->lt($dsf[-1], $dsj[0]));

    $coll->change(level => 1);

    # 27..34
    for my $i (0 .. $#disilva) {
	ok($coll->lt($dsf[$i], $dsJ[$i]));
	ok($coll->lt($dsj[$i], $dsJ[$i]));
    }
}

# 69

{
    my $coll = Unicode::Collate->new(
	table => 'keys.txt',
	normalization => undef,
	highestFFFF => 1,
	minimalFFFE => 1,
    );

    $coll->change(level => 1);
    ok($coll->lt("perl\x{FFFD}",   "perl\x{FFFF}"));
    ok($coll->lt("perl\x{1FFFD}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{1FFFE}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{1FFFF}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{2FFFD}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{2FFFE}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{2FFFF}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{10FFFD}", "perl\x{FFFF}"));
    ok($coll->lt("perl\x{10FFFE}", "perl\x{FFFF}"));
    ok($coll->lt("perl\x{10FFFF}", "perl\x{FFFF}"));

# 79

    $coll->change(level => 3);
    my @@list = (
	"ab\x{FFFE}a",
	"Ab\x{FFFE}a",
	"ab\x{FFFE}c",
	"Ab\x{FFFE}c",
	"ab\x{FFFE}xyz",
	"abc\x{FFFE}def",
	"abc\x{FFFE}xYz",
	"aBc\x{FFFE}xyz",
	"abcX\x{FFFE}def",
	"abcx\x{FFFE}xyz",
	"b\x{FFFE}aaa",
	"bbb\x{FFFE}a",
    );
    my $p = shift @@list;
    for my $c (@@list) {
	ok($coll->lt($p, $c));
	$p = $c;
    }
}

# 90
@


1.1
log
@Initial revision
@
text
@d3 6
a8 3
    unless ("A" eq pack('U', 0x41)) {
	print "1..0 # Unicode::Collate " .
	    "cannot stringify a Unicode code point\n";
d21 5
a25 3
    unless (exists &Unicode::Collate::bootstrap or 5.008 <= $]) {
	print "1..0 # skipped: XSUB, or Perl 5.8.0 or later".
		" needed for this test\n";
d33 1
a33 1
BEGIN { $| = 1; print "1..61\n"; } # 1 + 30 * 2
d62 1
a62 1
FFFE  ; [*0001.0020.0005.FFFE] # <noncharacter-FFFE>
d75 1
a75 1
	    ok(1) for 1..30; # silent skip
d122 3
a124 1
    # 27..30
d126 1
d131 47
@


1.1.1.1
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@@


1.1.1.2
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d28 1
a28 1
BEGIN { $| = 1; print "1..90\n"; }
d57 1
a57 1
FFFE  ; [.0001.0020.0005.FFFE] # <noncharacter-FFFE>
d70 1
a70 1
	    ok(1) for 1..34; # silent skip
d117 1
a117 3
    $coll->change(level => 1);

    # 27..34
a118 1
	ok($coll->lt($dsf[$i], $dsJ[$i]));
a122 47
# 69

{
    my $coll = Unicode::Collate->new(
	table => 'keys.txt',
	normalization => undef,
	highestFFFF => 1,
	minimalFFFE => 1,
    );

    $coll->change(level => 1);
    ok($coll->lt("perl\x{FFFD}",   "perl\x{FFFF}"));
    ok($coll->lt("perl\x{1FFFD}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{1FFFE}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{1FFFF}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{2FFFD}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{2FFFE}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{2FFFF}",  "perl\x{FFFF}"));
    ok($coll->lt("perl\x{10FFFD}", "perl\x{FFFF}"));
    ok($coll->lt("perl\x{10FFFE}", "perl\x{FFFF}"));
    ok($coll->lt("perl\x{10FFFF}", "perl\x{FFFF}"));

# 79

    $coll->change(level => 3);
    my @@list = (
	"ab\x{FFFE}a",
	"Ab\x{FFFE}a",
	"ab\x{FFFE}c",
	"Ab\x{FFFE}c",
	"ab\x{FFFE}xyz",
	"abc\x{FFFE}def",
	"abc\x{FFFE}xYz",
	"aBc\x{FFFE}xyz",
	"abcX\x{FFFE}def",
	"abcx\x{FFFE}xyz",
	"b\x{FFFE}aaa",
	"bbb\x{FFFE}a",
    );
    my $p = shift @@list;
    for my $c (@@list) {
	ok($coll->lt($p, $c));
	$p = $c;
    }
}

# 90
@


1.1.1.3
log
@Import perl-5.20.1
@
text
@d3 3
a5 6
    unless ('A' eq pack('U', 0x41)) {
	print "1..0 # Unicode::Collate cannot pack a Unicode code point\n";
	exit 0;
    }
    unless (0x41 == unpack('U', 'A')) {
	print "1..0 # Unicode::Collate cannot get a Unicode code point\n";
@


1.1.1.4
log
@Import perl-5.24.2
@
text
@d21 3
a23 5
#    unless (exists &Unicode::Collate::bootstrap or 5.008 <= $]) {
#	print "1..0 # skipped: XSUB, or Perl 5.8.0 or later".
#		" needed for this test\n";
    unless (5.008 <= $]) {
	print "1..0 # skipped: Perl 5.8.0 or later needed for this test\n";
@


