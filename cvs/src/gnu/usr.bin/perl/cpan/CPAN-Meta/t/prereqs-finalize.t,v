head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.1.0.16
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.10
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.12
	OPENBSD_5_8_BASE:1.1.1.1
	PERL_5_20_2:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.4
	OPENBSD_5_7_BASE:1.1.1.1
	PERL_5_20_1:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.8
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.6
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.2
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.31.55;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2013.03.25.20.06.55;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.03.25.20.06.55;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@use strict;
use warnings;
use Test::More 0.88;

use CPAN::Meta::Prereqs;

delete $ENV{$_} for qw/PERL_JSON_BACKEND PERL_YAML_BACKEND/; # use defaults

sub dies_ok (&@@) {
  my ($code, $qr, $comment) = @@_;

  if (eval { $code->(); 1 }) {
    fail("$comment: did not die");
  } else {
    like($@@, $qr, $comment);
  }
}

my $prereqs_struct = {
  runtime => {
    requires => {
      'Config' => '1.234',
      'Cwd'    => '876.5',
      'IO::File'   => 0,
      'perl'       => '5.005_03',
    },
    recommends => {
      'Pod::Text' => 0,
      'YAML'      => '0.35',
    },
  },
  build => {
    requires => {
      'Test' => 0,
    },
  }
};

my $prereqs = CPAN::Meta::Prereqs->new($prereqs_struct);

isa_ok($prereqs, 'CPAN::Meta::Prereqs');

$prereqs->finalize;

ok($prereqs->is_finalized, 'cloned obj is not finalized');

is_deeply($prereqs->as_string_hash, $prereqs_struct, '...and still round-trip');

$prereqs->requirements_for(qw(runtime requires))->add_minimum(Cwd => 10);

pass('...we can add a minimum if it has no effect');

dies_ok
  { $prereqs->requirements_for(qw(runtime requires))->add_minimum(Cwd => 1000) }
  qr{finalized req},
  '...but we die if it would alter a finalized prereqs';

$prereqs->requirements_for(qw(develop suggests));

pass('...we can get a V:R object for a previously unconfigured phase');

dies_ok
  { $prereqs->requirements_for(qw(develop suggests))->add_minimum(Foo => 1) }
  qr{finalized req},
  '...but we die if we try to put anything in it';

my $clone = $prereqs->clone;

isa_ok($clone, 'CPAN::Meta::Prereqs', 'cloned prereqs obj');

ok(! $clone->is_finalized, 'cloned obj is not finalized');

is_deeply($clone->as_string_hash, $prereqs_struct, '...it still round-trips');

$clone->requirements_for(qw(runtime requires))->add_minimum(Cwd => 10);

pass('...we can add minimum if it has no effect');

$clone->requirements_for(qw(runtime requires))->add_minimum(Cwd => 1000);

pass('...or if it has an effect');

$clone->requirements_for(qw(develop suggests));

pass('...we can get a V:R object for a previously unconfigured phase');

$clone->requirements_for(qw(develop suggests))->add_minimum(Foo => 1);

pass('...and we can add stuff to it');

done_testing;
# vim: ts=2 sts=2 sw=2 et :
@


1.1
log
@Initial revision
@
text
@d12 1
a12 3
  my $lived = eval { $code->(); 1 };

  if ($lived) {
d92 1
@


1.1.1.1
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@@
