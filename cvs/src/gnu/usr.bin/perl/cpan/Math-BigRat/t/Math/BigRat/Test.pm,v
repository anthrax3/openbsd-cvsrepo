head	1.3;
access;
symbols
	OPENBSD_6_2_BASE:1.3
	PERL_5_24_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.32.01;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2013.03.25.20.40.51;	author sthen;	state dead;
branches;
next	1.1;

1.1
date	2010.09.24.14.48.56;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.56;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2017.08.14.13.46.00;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package Math::BigRat::Test;

require 5.006;
use strict;
use warnings;

use Exporter;
use Math::BigRat;
use Math::BigFloat;
our ($VERSION, @@ISA, $accuracy, $precision, $round_mode, $div_scale);

@@ISA = qw(Math::BigRat Exporter);
$VERSION = 0.04;

use overload; 		# inherit overload from BigRat

# Globals
$accuracy = $precision = undef;
$round_mode = 'even';
$div_scale = 40;

my $class = 'Math::BigRat::Test';

#sub new {
#    my $proto  = shift;
#    my $class  = ref($proto) || $proto;
#
#    my $value       = shift;
#    my $a = $accuracy; $a = $_[0] if defined $_[0];
#    my $p = $precision; $p = $_[1] if defined $_[1];
#    # Store the floating point value
#    my $self = Math::BigFloat->new($value, $a, $p, $round_mode);
#    bless $self, $class;
#    $self->{'_custom'} = 1;     # make sure this never goes away
#    return $self;
#}

BEGIN {
    *fstr  = \&bstr;
    *fsstr = \&bsstr;
    *objectify = \&Math::BigInt::objectify;
    *AUTOLOAD  = \&Math::BigRat::AUTOLOAD;
    no strict 'refs';
    foreach my $method (qw/div acmp floor ceil root sqrt log fac modpow modinv/) {
        *{'b' . $method} = \&{'Math::BigRat::b' . $method};
    }
}

sub fround {
    my ($x, $a) = @@_;

    #print "$a $accuracy $precision $round_mode\n";
    Math::BigFloat->round_mode($round_mode);
    Math::BigFloat->accuracy($a || $accuracy);
    Math::BigFloat->precision(undef);
    my $y = Math::BigFloat->new($x->bsstr(), undef, undef);
    $class->new($y->fround($a));
}

sub ffround {
    my ($x, $p) = @@_;

    Math::BigFloat->round_mode($round_mode);
    Math::BigFloat->accuracy(undef);
    Math::BigFloat->precision($p || $precision);
    my $y = Math::BigFloat->new($x->bsstr(), undef, undef);
    $class->new($y->ffround($p));
}

sub bstr {
    # calculate a BigFloat compatible string output
    my ($x) = @@_;

    $x = $class->new($x) unless ref $x;

    if ($x->{sign} !~ /^[+-]$/) { # inf, NaN etc
        my $s = $x->{sign};
        $s =~ s/^\+//;          # +inf => inf
        return $s;
    }

    my $s = '';
    $s = $x->{sign} if $x->{sign} ne '+'; # +3 vs 3

    #  print " bstr \$x ", $accuracy || $x->{_a} || 'notset', " ", $precision || $x->{_p} || 'notset', "\n";
    return $s.$x->{_n} if $x->{_d}->is_one();
    my $output = Math::BigFloat->new($x->{_n})->bdiv($x->{_d});
    local $Math::BigFloat::accuracy  = $accuracy  || $x->{_a};
    local $Math::BigFloat::precision = $precision || $x->{_p};
    $s.$output->bstr();
}

sub numify {
    $_[0]->bsstr();
}

sub bsstr {
    # calculate a BigFloat compatible string output
    my ($x) = @@_;

    $x = $class->new($x) unless ref $x;

    if ($x->{sign} !~ /^[+-]$/) {       # inf, NaN etc
        my $s = $x->{sign};
        $s =~ s/^\+//;                  # +inf => inf
        return $s;
    }

    my $s = '';
    $s = $x->{sign} if $x->{sign} ne '+'; # +3 vs 3

    my $output = Math::BigFloat->new($x->{_n})->bdiv($x->{_d});
    return $s.$output->bsstr();
}

1;
@


1.2
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d3 1
a3 1
require 5.005_02;
d5 1
d10 1
a10 2
use vars qw($VERSION @@ISA 
            $accuracy $precision $round_mode $div_scale);
d24 3
a26 4
#ub new
#{
#        my $proto  = shift;
#        my $class  = ref($proto) || $proto;
d28 8
a35 8
#        my $value       = shift;
#	my $a = $accuracy; $a = $_[0] if defined $_[0];
#	my $p = $precision; $p = $_[1] if defined $_[1];
#        # Store the floating point value
#        my $self = Math::BigFloat->new($value,$a,$p,$round_mode);
#        bless $self, $class;
#        $self->{'_custom'} = 1; # make sure this never goes away
#        return $self;
d38 8
a45 10
BEGIN 
  {
  *fstr = \&bstr;
  *fsstr = \&bsstr;
  *objectify = \&Math::BigInt::objectify;
  *AUTOLOAD = \&Math::BigRat::AUTOLOAD;
  no strict 'refs';
  foreach my $method ( qw/ div acmp floor ceil root sqrt log fac modpow modinv/)
    {
    *{'b' . $method} = \&{'Math::BigRat::b' . $method};
d47 1
a47 1
  }
d49 31
a79 34
sub fround
  {
  my ($x,$a) = @@_;

  #print "$a $accuracy $precision $round_mode\n";
  Math::BigFloat->round_mode($round_mode);
  Math::BigFloat->accuracy($a || $accuracy);
  Math::BigFloat->precision(undef);
  my $y = Math::BigFloat->new($x->bsstr(),undef,undef);
  $class->new($y->fround($a));
  }

sub ffround
  {
  my ($x,$p) = @@_;

  Math::BigFloat->round_mode($round_mode);
  Math::BigFloat->accuracy(undef);
  Math::BigFloat->precision($p || $precision);
  my $y = Math::BigFloat->new($x->bsstr(),undef,undef);
  $class->new($y->ffround($p));
  }

sub bstr
  {
  # calculate a BigFloat compatible string output
  my ($x) = @@_;

  $x = $class->new($x) unless ref $x;

  if ($x->{sign} !~ /^[+-]$/)           # inf, NaN etc
    {
    my $s = $x->{sign}; $s =~ s/^\+//;  # +inf => inf
    return $s;
d82 2
a83 1
  my $s = ''; $s = $x->{sign} if $x->{sign} ne '+';     # +3 vs 3
d85 22
a106 24
#  print " bstr \$x ", $accuracy || $x->{_a} || 'notset', " ", $precision || $x->{_p} || 'notset', "\n";
  return $s.$x->{_n} if $x->{_d}->is_one(); 
  my $output = Math::BigFloat->new($x->{_n})->bdiv($x->{_d});
  local $Math::BigFloat::accuracy = $accuracy || $x->{_a};
  local $Math::BigFloat::precision = $precision || $x->{_p};
  $s.$output->bstr();
  }

sub numify
  {
  $_[0]->bsstr();
  }

sub bsstr
  {
  # calculate a BigFloat compatible string output
  my ($x) = @@_;

  $x = $class->new($x) unless ref $x;

  if ($x->{sign} !~ /^[+-]$/)           # inf, NaN etc
    {
    my $s = $x->{sign}; $s =~ s/^\+//;  # +inf => inf
    return $s;
d109 2
a110 1
  my $s = ''; $s = $x->{sign} if $x->{sign} ne '+';     # +3 vs 3
d112 3
a114 3
  my $output = Math::BigFloat->new($x->{_n})->bdiv($x->{_d});
  return $s.$output->bsstr();
  }
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@Import perl-5.24.2
@
text
@d3 1
a3 1
require 5.006;
a4 1
use warnings;
d9 2
a10 1
our ($VERSION, @@ISA, $accuracy, $precision, $round_mode, $div_scale);
d24 4
a27 3
#sub new {
#    my $proto  = shift;
#    my $class  = ref($proto) || $proto;
d29 8
a36 8
#    my $value       = shift;
#    my $a = $accuracy; $a = $_[0] if defined $_[0];
#    my $p = $precision; $p = $_[1] if defined $_[1];
#    # Store the floating point value
#    my $self = Math::BigFloat->new($value, $a, $p, $round_mode);
#    bless $self, $class;
#    $self->{'_custom'} = 1;     # make sure this never goes away
#    return $self;
d39 10
a48 8
BEGIN {
    *fstr  = \&bstr;
    *fsstr = \&bsstr;
    *objectify = \&Math::BigInt::objectify;
    *AUTOLOAD  = \&Math::BigRat::AUTOLOAD;
    no strict 'refs';
    foreach my $method (qw/div acmp floor ceil root sqrt log fac modpow modinv/) {
        *{'b' . $method} = \&{'Math::BigRat::b' . $method};
d50 1
a50 1
}
d52 34
a85 31
sub fround {
    my ($x, $a) = @@_;

    #print "$a $accuracy $precision $round_mode\n";
    Math::BigFloat->round_mode($round_mode);
    Math::BigFloat->accuracy($a || $accuracy);
    Math::BigFloat->precision(undef);
    my $y = Math::BigFloat->new($x->bsstr(), undef, undef);
    $class->new($y->fround($a));
}

sub ffround {
    my ($x, $p) = @@_;

    Math::BigFloat->round_mode($round_mode);
    Math::BigFloat->accuracy(undef);
    Math::BigFloat->precision($p || $precision);
    my $y = Math::BigFloat->new($x->bsstr(), undef, undef);
    $class->new($y->ffround($p));
}

sub bstr {
    # calculate a BigFloat compatible string output
    my ($x) = @@_;

    $x = $class->new($x) unless ref $x;

    if ($x->{sign} !~ /^[+-]$/) { # inf, NaN etc
        my $s = $x->{sign};
        $s =~ s/^\+//;          # +inf => inf
        return $s;
d88 1
a88 2
    my $s = '';
    $s = $x->{sign} if $x->{sign} ne '+'; # +3 vs 3
d90 24
a113 22
    #  print " bstr \$x ", $accuracy || $x->{_a} || 'notset', " ", $precision || $x->{_p} || 'notset', "\n";
    return $s.$x->{_n} if $x->{_d}->is_one();
    my $output = Math::BigFloat->new($x->{_n})->bdiv($x->{_d});
    local $Math::BigFloat::accuracy  = $accuracy  || $x->{_a};
    local $Math::BigFloat::precision = $precision || $x->{_p};
    $s.$output->bstr();
}

sub numify {
    $_[0]->bsstr();
}

sub bsstr {
    # calculate a BigFloat compatible string output
    my ($x) = @@_;

    $x = $class->new($x) unless ref $x;

    if ($x->{sign} !~ /^[+-]$/) {       # inf, NaN etc
        my $s = $x->{sign};
        $s =~ s/^\+//;                  # +inf => inf
        return $s;
d116 1
a116 2
    my $s = '';
    $s = $x->{sign} if $x->{sign} ne '+'; # +3 vs 3
d118 3
a120 3
    my $output = Math::BigFloat->new($x->{_n})->bdiv($x->{_d});
    return $s.$output->bsstr();
}
@

