head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.1.0.26
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.20
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.22
	OPENBSD_5_8_BASE:1.1.1.1
	PERL_5_20_2:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.14
	OPENBSD_5_7_BASE:1.1.1.1
	PERL_5_20_1:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.18
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.16
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.12
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.31.59;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2010.09.24.14.49.05;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.05;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@BEGIN {
    if ($ENV{PERL_CORE}) {
	chdir 't' if -d 't';
	@@INC = ("../lib", "lib/compress");
    }
}

use lib qw(t t/compress);
use strict ;
use warnings;
use bytes;

use Test::More ;
use CompTestUtils;

BEGIN 
{ 
    plan skip_all => "Lengthy Tests Disabled\n" .
                     "set COMPRESS_ZLIB_RUN_ALL to run this test suite"
        unless defined $ENV{COMPRESS_ZLIB_RUN_ALL} ;

    # use Test::NoWarnings, if available
    my $extra = 0 ;
    $extra = 1
        if eval { require Test::NoWarnings ;  import Test::NoWarnings; 1 };

    plan tests => 76 + $extra ;


    use_ok('Compress::Zlib', 2) ;
    use_ok('IO::Compress::Gzip', qw($GzipError)) ;
    use_ok('IO::Uncompress::Gunzip', qw($GunzipError)) ;
    use_ok('IO::Compress::Gzip::Constants');
}

my $compressed ;    
my $expected_crc ;

for my $wrap (0 .. 2)
{
    for my $offset ( -1 .. 1 )
    {
        next if $wrap == 0 && $offset < 0 ;

        title "Wrap $wrap, Offset $offset" ;

        my $size = (GZIP_ISIZE_MAX * $wrap) + $offset ;

        my $expected_isize ;
        if ($wrap == 0) {
            $expected_isize = $offset ;
        }
        elsif ($wrap == 1 && $offset <= 0) {
            $expected_isize = GZIP_ISIZE_MAX + $offset ;
        }
        elsif ($wrap > 1) {
            $expected_isize = GZIP_ISIZE_MAX + $offset - 1;
        }
        else {
            $expected_isize = $offset - 1;
        }
        
        sub gzipClosure
        {
            my $gzip = shift ;
            my $max = shift  ;

            my $index = 0 ;
            my $inc = 1024 * 5000 ;
            my $buff = 'x' x $inc ;
            my $left = $max ;

            return 
                sub {

                    if ($max == 0 && $index == 0) {
                        $expected_crc = crc32('') ;
                        ok $gzip->close(), '  IO::Compress::Gzip::close ok X' ;
                        ++ $index ;
                        $_[0] .= $compressed;
                        return length $compressed ;
                    }

                    return 0 if $index >= $max ;

                    while ( ! length $compressed )
                    {
                        $index += $inc ;

                        if ($index <= $max) {
                            $gzip->write($buff) ;
                            #print "Write " . length($buff) . "\n" ;
                            #print "# LEN Compressed " . length($compressed) . "\n" ;
                            $expected_crc = crc32($buff, $expected_crc) ;
                            $left -= $inc ;
                        }
                        else  {
                            #print "Write $left\n" ;
                            $gzip->write('x' x $left) ;
                            #print "# LEN Compressed " . length($compressed) . "\n" ;
                            $expected_crc = crc32('x' x $left, $expected_crc) ;
                            ok $gzip->close(), '  IO::Compress::Gzip::close ok ' ;
                            last ;
                        }
                    }

                    my $len = length $compressed ;
                    $_[0] .= $compressed ;
                    $compressed = '';
                    #print "# LEN $len\n" if $len <=0 ;

                    return $len ;
                };
        }

        my $gzip = new IO::Compress::Gzip \$compressed,
                                -Append     => 0,
                                -HeaderCRC  => 1;

        ok $gzip, "  Created IO::Compress::Gzip object";

        my $gunzip = new IO::Uncompress::Gunzip gzipClosure($gzip, $size),
                                    -BlockSize  => 1024 * 500 ,
                                    -Append => 0,
                                    -Strict => 1;

        ok $gunzip, "  Created IO::Uncompress::Gunzip object";

        my $inflate = *$gunzip->{Inflate} ;
        my $deflate = *$gzip->{Deflate} ;

        my $status ;
        my $uncompressed;
        my $actual = 0 ;
        while (($status = $gunzip->read($uncompressed)) > 0) {
            #print "# READ $status\n" ;
            $actual += $status ;
        }

        is $status, 0, '  IO::Uncompress::Gunzip::read returned 0'
            or diag "error status is $status, error is $GunzipError" ;

        ok $gunzip->close(), "  IO::Uncompress::Gunzip Closed ok" ;

        is $actual, $size, "  Length of Gunzipped data is $size"
            or diag "Expected $size, got $actual";

        my $gunzip_hdr = $gunzip->getHeaderInfo();

        is $gunzip_hdr->{ISIZE}, $expected_isize, 
            sprintf("  ISIZE is $expected_isize [0x%X]", $expected_isize);
        is $gunzip_hdr->{CRC32}, $expected_crc, 
            sprintf("  CRC32 is $expected_crc [0x%X]", $expected_crc);

        $expected_crc = 0 ;
    }
}

@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
                     "set COMPRESS_ZLIB_RUN_ALL to run this test suite" 
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@
