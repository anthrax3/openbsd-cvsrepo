head	1.3;
access;
symbols
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.4.0.4
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.6
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.31.59;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2016.07.25.10.53.01;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	FHUgABTHZQuYQh2B;

1.1
date	2010.09.24.14.49.04;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.04;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.07.44;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.53;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.52.47;	author afresh1;	state Exp;
branches
	1.1.1.4.4.1
	1.1.1.4.6.1;
next	;
commitid	B31cAbBIXiCqnL97;

1.1.1.4.4.1
date	2016.08.05.01.01.37;	author afresh1;	state Exp;
branches;
next	;
commitid	HjAJx2yjL4A8HWon;

1.1.1.4.6.1
date	2016.08.05.01.00.53;	author afresh1;	state Exp;
branches;
next	;
commitid	wK3bUiy9jNch0Key;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package IO::Compress::Base::Common;

use strict ;
use warnings;
use bytes;

use Carp;
use Scalar::Util qw(blessed readonly);
use File::GlobMapper;

require Exporter;
our ($VERSION, @@ISA, @@EXPORT, %EXPORT_TAGS, $HAS_ENCODE);
@@ISA = qw(Exporter);
$VERSION = '2.069_001';

@@EXPORT = qw( isaFilehandle isaFilename isaScalar
              whatIsInput whatIsOutput 
              isaFileGlobString cleanFileGlobString oneTarget
              setBinModeInput setBinModeOutput
              ckInOutParams 
              createSelfTiedObject
              
              isGeMax32

              MAX32

              WANT_CODE
              WANT_EXT
              WANT_UNDEF
              WANT_HASH

              STATUS_OK
              STATUS_ENDSTREAM
              STATUS_EOF
              STATUS_ERROR
          );  

%EXPORT_TAGS = ( Status => [qw( STATUS_OK
                                 STATUS_ENDSTREAM
                                 STATUS_EOF
                                 STATUS_ERROR
                           )]);

                       
use constant STATUS_OK        => 0;
use constant STATUS_ENDSTREAM => 1;
use constant STATUS_EOF       => 2;
use constant STATUS_ERROR     => -1;
use constant MAX16            => 0xFFFF ;  
use constant MAX32            => 0xFFFFFFFF ;  
use constant MAX32cmp         => 0xFFFFFFFF + 1 - 1; # for 5.6.x on 32-bit need to force an non-IV value 
          

sub isGeMax32
{
    return $_[0] >= MAX32cmp ;
}

sub hasEncode()
{
    if (! defined $HAS_ENCODE) {
        eval
        {
            require Encode;
            Encode->import();
        };

        $HAS_ENCODE = $@@ ? 0 : 1 ;
    }

    return $HAS_ENCODE;
}

sub getEncoding($$$)
{
    my $obj = shift;
    my $class = shift ;
    my $want_encoding = shift ;

    $obj->croakError("$class: Encode module needed to use -Encode")
        if ! hasEncode();

    my $encoding = Encode::find_encoding($want_encoding);

    $obj->croakError("$class: Encoding '$want_encoding' is not available")
       if ! $encoding;

    return $encoding;
}

our ($needBinmode);
$needBinmode = ($^O eq 'MSWin32' || 
                    ($] >= 5.006 && eval ' ${^UNICODE} || ${^UTF8LOCALE} '))
                    ? 1 : 1 ;

sub setBinModeInput($)
{
    my $handle = shift ;

    binmode $handle 
        if  $needBinmode;
}

sub setBinModeOutput($)
{
    my $handle = shift ;

    binmode $handle
        if  $needBinmode;
}

sub isaFilehandle($)
{
    use utf8; # Pragma needed to keep Perl 5.6.0 happy
    return (defined $_[0] and 
             (UNIVERSAL::isa($_[0],'GLOB') or 
              UNIVERSAL::isa($_[0],'IO::Handle') or
              UNIVERSAL::isa(\$_[0],'GLOB')) 
          )
}

sub isaScalar
{
    return ( defined($_[0]) and ref($_[0]) eq 'SCALAR' and defined ${ $_[0] } ) ;
}

sub isaFilename($)
{
    return (defined $_[0] and 
           ! ref $_[0]    and 
           UNIVERSAL::isa(\$_[0], 'SCALAR'));
}

sub isaFileGlobString
{
    return defined $_[0] && $_[0] =~ /^<.*>$/;
}

sub cleanFileGlobString
{
    my $string = shift ;

    $string =~ s/^\s*<\s*(.*)\s*>\s*$/$1/;

    return $string;
}

use constant WANT_CODE  => 1 ;
use constant WANT_EXT   => 2 ;
use constant WANT_UNDEF => 4 ;
#use constant WANT_HASH  => 8 ;
use constant WANT_HASH  => 0 ;

sub whatIsInput($;$)
{
    my $got = whatIs(@@_);
    
    if (defined $got && $got eq 'filename' && defined $_[0] && $_[0] eq '-')
    {
        #use IO::File;
        $got = 'handle';
        $_[0] = *STDIN;
        #$_[0] = new IO::File("<-");
    }

    return $got;
}

sub whatIsOutput($;$)
{
    my $got = whatIs(@@_);
    
    if (defined $got && $got eq 'filename' && defined $_[0] && $_[0] eq '-')
    {
        $got = 'handle';
        $_[0] = *STDOUT;
        #$_[0] = new IO::File(">-");
    }
    
    return $got;
}

sub whatIs ($;$)
{
    return 'handle' if isaFilehandle($_[0]);

    my $wantCode = defined $_[1] && $_[1] & WANT_CODE ;
    my $extended = defined $_[1] && $_[1] & WANT_EXT ;
    my $undef    = defined $_[1] && $_[1] & WANT_UNDEF ;
    my $hash     = defined $_[1] && $_[1] & WANT_HASH ;

    return 'undef'  if ! defined $_[0] && $undef ;

    if (ref $_[0]) {
        return ''       if blessed($_[0]); # is an object
        #return ''       if UNIVERSAL::isa($_[0], 'UNIVERSAL'); # is an object
        return 'buffer' if UNIVERSAL::isa($_[0], 'SCALAR');
        return 'array'  if UNIVERSAL::isa($_[0], 'ARRAY')  && $extended ;
        return 'hash'   if UNIVERSAL::isa($_[0], 'HASH')   && $hash ;
        return 'code'   if UNIVERSAL::isa($_[0], 'CODE')   && $wantCode ;
        return '';
    }

    return 'fileglob' if $extended && isaFileGlobString($_[0]);
    return 'filename';
}

sub oneTarget
{
    return $_[0] =~ /^(code|handle|buffer|filename)$/;
}

sub IO::Compress::Base::Validator::new
{
    my $class = shift ;

    my $Class = shift ;
    my $error_ref = shift ;
    my $reportClass = shift ;

    my %data = (Class       => $Class, 
                Error       => $error_ref,
                reportClass => $reportClass, 
               ) ;

    my $obj = bless \%data, $class ;

    local $Carp::CarpLevel = 1;

    my $inType    = $data{inType}    = whatIsInput($_[0], WANT_EXT|WANT_HASH);
    my $outType   = $data{outType}   = whatIsOutput($_[1], WANT_EXT|WANT_HASH);

    my $oneInput  = $data{oneInput}  = oneTarget($inType);
    my $oneOutput = $data{oneOutput} = oneTarget($outType);

    if (! $inType)
    {
        $obj->croakError("$reportClass: illegal input parameter") ;
        #return undef ;
    }    

#    if ($inType eq 'hash')
#    {
#        $obj->{Hash} = 1 ;
#        $obj->{oneInput} = 1 ;
#        return $obj->validateHash($_[0]);
#    }

    if (! $outType)
    {
        $obj->croakError("$reportClass: illegal output parameter") ;
        #return undef ;
    }    


    if ($inType ne 'fileglob' && $outType eq 'fileglob')
    {
        $obj->croakError("Need input fileglob for outout fileglob");
    }    

#    if ($inType ne 'fileglob' && $outType eq 'hash' && $inType ne 'filename' )
#    {
#        $obj->croakError("input must ne filename or fileglob when output is a hash");
#    }    

    if ($inType eq 'fileglob' && $outType eq 'fileglob')
    {
        $data{GlobMap} = 1 ;
        $data{inType} = $data{outType} = 'filename';
        my $mapper = new File::GlobMapper($_[0], $_[1]);
        if ( ! $mapper )
        {
            return $obj->saveErrorString($File::GlobMapper::Error) ;
        }
        $data{Pairs} = $mapper->getFileMap();

        return $obj;
    }
    
    $obj->croakError("$reportClass: input and output $inType are identical")
        if $inType eq $outType && $_[0] eq $_[1] && $_[0] ne '-' ;

    if ($inType eq 'fileglob') # && $outType ne 'fileglob'
    {
        my $glob = cleanFileGlobString($_[0]);
        my @@inputs = glob($glob);

        if (@@inputs == 0)
        {
            # TODO -- legal or die?
            die "globmap matched zero file -- legal or die???" ;
        }
        elsif (@@inputs == 1)
        {
            $obj->validateInputFilenames($inputs[0])
                or return undef;
            $_[0] = $inputs[0]  ;
            $data{inType} = 'filename' ;
            $data{oneInput} = 1;
        }
        else
        {
            $obj->validateInputFilenames(@@inputs)
                or return undef;
            $_[0] = [ @@inputs ] ;
            $data{inType} = 'filenames' ;
        }
    }
    elsif ($inType eq 'filename')
    {
        $obj->validateInputFilenames($_[0])
            or return undef;
    }
    elsif ($inType eq 'array')
    {
        $data{inType} = 'filenames' ;
        $obj->validateInputArray($_[0])
            or return undef ;
    }

    return $obj->saveErrorString("$reportClass: output buffer is read-only")
        if $outType eq 'buffer' && readonly(${ $_[1] });

    if ($outType eq 'filename' )
    {
        $obj->croakError("$reportClass: output filename is undef or null string")
            if ! defined $_[1] || $_[1] eq ''  ;

        if (-e $_[1])
        {
            if (-d _ )
            {
                return $obj->saveErrorString("output file '$_[1]' is a directory");
            }
        }
    }
    
    return $obj ;
}

sub IO::Compress::Base::Validator::saveErrorString
{
    my $self   = shift ;
    ${ $self->{Error} } = shift ;
    return undef;
    
}

sub IO::Compress::Base::Validator::croakError
{
    my $self   = shift ;
    $self->saveErrorString($_[0]);
    croak $_[0];
}



sub IO::Compress::Base::Validator::validateInputFilenames
{
    my $self = shift ;

    foreach my $filename (@@_)
    {
        $self->croakError("$self->{reportClass}: input filename is undef or null string")
            if ! defined $filename || $filename eq ''  ;

        next if $filename eq '-';

        if (! -e $filename )
        {
            return $self->saveErrorString("input file '$filename' does not exist");
        }

        if (-d _ )
        {
            return $self->saveErrorString("input file '$filename' is a directory");
        }

#        if (! -r _ )
#        {
#            return $self->saveErrorString("cannot open file '$filename': $!");
#        }
    }

    return 1 ;
}

sub IO::Compress::Base::Validator::validateInputArray
{
    my $self = shift ;

    if ( @@{ $_[0] } == 0 )
    {
        return $self->saveErrorString("empty array reference") ;
    }    

    foreach my $element ( @@{ $_[0] } )
    {
        my $inType  = whatIsInput($element);
    
        if (! $inType)
        {
            $self->croakError("unknown input parameter") ;
        }    
        elsif($inType eq 'filename')
        {
            $self->validateInputFilenames($element)
                or return undef ;
        }
        else
        {
            $self->croakError("not a filename") ;
        }
    }

    return 1 ;
}

#sub IO::Compress::Base::Validator::validateHash
#{
#    my $self = shift ;
#    my $href = shift ;
#
#    while (my($k, $v) = each %$href)
#    {
#        my $ktype = whatIsInput($k);
#        my $vtype = whatIsOutput($v, WANT_EXT|WANT_UNDEF) ;
#
#        if ($ktype ne 'filename')
#        {
#            return $self->saveErrorString("hash key not filename") ;
#        }    
#
#        my %valid = map { $_ => 1 } qw(filename buffer array undef handle) ;
#        if (! $valid{$vtype})
#        {
#            return $self->saveErrorString("hash value not ok") ;
#        }    
#    }
#
#    return $self ;
#}

sub createSelfTiedObject
{
    my $class = shift || (caller)[0] ;
    my $error_ref = shift ;

    my $obj = bless Symbol::gensym(), ref($class) || $class;
    tie *$obj, $obj if $] >= 5.005;
    *$obj->{Closed} = 1 ;
    $$error_ref = '';
    *$obj->{Error} = $error_ref ;
    my $errno = 0 ;
    *$obj->{ErrorNo} = \$errno ;

    return $obj;
}



#package Parse::Parameters ;
#
#
#require Exporter;
#our ($VERSION, @@ISA, @@EXPORT);
#$VERSION = '2.000_08';
#@@ISA = qw(Exporter);

$EXPORT_TAGS{Parse} = [qw( ParseParameters 
                           Parse_any Parse_unsigned Parse_signed 
                           Parse_boolean Parse_string
                           Parse_code
                           Parse_writable_scalar
                         )
                      ];              

push @@EXPORT, @@{ $EXPORT_TAGS{Parse} } ;

use constant Parse_any      => 0x01;
use constant Parse_unsigned => 0x02;
use constant Parse_signed   => 0x04;
use constant Parse_boolean  => 0x08;
use constant Parse_string   => 0x10;
use constant Parse_code     => 0x20;

#use constant Parse_store_ref        => 0x100 ;
#use constant Parse_multiple         => 0x100 ;
use constant Parse_writable         => 0x200 ;
use constant Parse_writable_scalar  => 0x400 | Parse_writable ;

use constant OFF_PARSED     => 0 ;
use constant OFF_TYPE       => 1 ;
use constant OFF_DEFAULT    => 2 ;
use constant OFF_FIXED      => 3 ;
#use constant OFF_FIRST_ONLY => 4 ;
#use constant OFF_STICKY     => 5 ;

use constant IxError => 0;
use constant IxGot   => 1 ;

sub ParseParameters
{
    my $level = shift || 0 ; 

    my $sub = (caller($level + 1))[3] ;
    local $Carp::CarpLevel = 1 ;
    
    return $_[1]
        if @@_ == 2 && defined $_[1] && UNIVERSAL::isa($_[1], "IO::Compress::Base::Parameters");
    
    my $p = new IO::Compress::Base::Parameters() ;            
    $p->parse(@@_)
        or croak "$sub: $p->[IxError]" ;

    return $p;
}


use strict;

use warnings;
use Carp;


sub Init
{
    my $default = shift ;
    my %got ;
    
    my $obj = IO::Compress::Base::Parameters::new();
    while (my ($key, $v) = each %$default)
    {
        croak "need 2 params [@@$v]"
            if @@$v != 2 ;

        my ($type, $value) = @@$v ;
#        my ($first_only, $sticky, $type, $value) = @@$v ;
        my $sticky = 0;
        my $x ;
        $obj->_checkType($key, \$value, $type, 0, \$x) 
            or return undef ;

        $key = lc $key;

#        if (! $sticky) {
#            $x = []
#                if $type & Parse_multiple;

#            $got{$key} = [0, $type, $value, $x, $first_only, $sticky] ;
            $got{$key} = [0, $type, $value, $x] ;            
#        }
#
#        $got{$key}[OFF_PARSED] = 0 ;
    }
    
    return bless \%got, "IO::Compress::Base::Parameters::Defaults" ;
}

sub IO::Compress::Base::Parameters::new
{
    #my $class = shift ;

    my $obj;
    $obj->[IxError] = '';
    $obj->[IxGot] = {} ;          

    return bless $obj, 'IO::Compress::Base::Parameters' ;
}

sub IO::Compress::Base::Parameters::setError
{
    my $self = shift ;
    my $error = shift ;
    my $retval = @@_ ? shift : undef ;


    $self->[IxError] = $error ;
    return $retval;
}
          
sub IO::Compress::Base::Parameters::getError
{
    my $self = shift ;
    return $self->[IxError] ;
}
          
sub IO::Compress::Base::Parameters::parse
{
    my $self = shift ;
    my $default = shift ;

    my $got = $self->[IxGot] ;
    my $firstTime = keys %{ $got } == 0 ;

    my (@@Bad) ;
    my @@entered = () ;

    # Allow the options to be passed as a hash reference or
    # as the complete hash.
    if (@@_ == 0) {
        @@entered = () ;
    }
    elsif (@@_ == 1) {
        my $href = $_[0] ;
    
        return $self->setError("Expected even number of parameters, got 1")
            if ! defined $href or ! ref $href or ref $href ne "HASH" ;
 
        foreach my $key (keys %$href) {
            push @@entered, $key ;
            push @@entered, \$href->{$key} ;
        }
    }
    else {
       
        my $count = @@_;
        return $self->setError("Expected even number of parameters, got $count")
            if $count % 2 != 0 ;
        
        for my $i (0.. $count / 2 - 1) {
            push @@entered, $_[2 * $i] ;
            push @@entered, \$_[2 * $i + 1] ;
        }
    }

        foreach my $key (keys %$default)
        {
    
            my ($type, $value) = @@{ $default->{$key} } ;
  
            if ($firstTime) {   
                $got->{$key} = [0, $type, $value, $value] ;               
            }
            else
            {
                $got->{$key}[OFF_PARSED] = 0 ;      
            }               
        }


    my %parsed = ();
    
   
    for my $i (0.. @@entered / 2 - 1) {
        my $key = $entered[2* $i] ;
        my $value = $entered[2* $i+1] ;

        #print "Key [$key] Value [$value]" ;
        #print defined $$value ? "[$$value]\n" : "[undef]\n";

        $key =~ s/^-// ;
        my $canonkey = lc $key;
 
        if ($got->{$canonkey})                                  
        {
            my $type = $got->{$canonkey}[OFF_TYPE] ;
            my $parsed = $parsed{$canonkey};
            ++ $parsed{$canonkey};

            return $self->setError("Muliple instances of '$key' found") 
                if $parsed ; 

            my $s ;
            $self->_checkType($key, $value, $type, 1, \$s)
                or return undef ;

            $value = $$value ;
            $got->{$canonkey} = [1, $type, $value, $s] ;

        }
        else
          { push (@@Bad, $key) }
    }
 
    if (@@Bad) {
        my ($bad) = join(", ", @@Bad) ;
        return $self->setError("unknown key value(s) $bad") ;
    }

    return 1;
}

sub IO::Compress::Base::Parameters::_checkType
{
    my $self = shift ;

    my $key   = shift ;
    my $value = shift ;
    my $type  = shift ;
    my $validate  = shift ;
    my $output  = shift;

    #local $Carp::CarpLevel = $level ;
    #print "PARSE $type $key $value $validate $sub\n" ;

    if ($type & Parse_writable_scalar)
    {
        return $self->setError("Parameter '$key' not writable")
            if  readonly $$value ;

        if (ref $$value) 
        {
            return $self->setError("Parameter '$key' not a scalar reference")
                if ref $$value ne 'SCALAR' ;

            $$output = $$value ;
        }
        else  
        {
            return $self->setError("Parameter '$key' not a scalar")
                if ref $value ne 'SCALAR' ;

            $$output = $value ;
        }

        return 1;
    }


    $value = $$value ;

    if ($type & Parse_any)
    {
        $$output = $value ;
        return 1;
    }
    elsif ($type & Parse_unsigned)
    {
     
        return $self->setError("Parameter '$key' must be an unsigned int, got 'undef'")
            if ! defined $value ;
        return $self->setError("Parameter '$key' must be an unsigned int, got '$value'")
            if $value !~ /^\d+$/;
    
        $$output = defined $value ? $value : 0 ;    
        return 1;
    }
    elsif ($type & Parse_signed)
    {
        return $self->setError("Parameter '$key' must be a signed int, got 'undef'")
            if ! defined $value ;
        return $self->setError("Parameter '$key' must be a signed int, got '$value'")
            if $value !~ /^-?\d+$/;

        $$output = defined $value ? $value : 0 ;    
        return 1 ;
    }
    elsif ($type & Parse_boolean)
    {
        return $self->setError("Parameter '$key' must be an int, got '$value'")
            if defined $value && $value !~ /^\d*$/;

        $$output =  defined $value && $value != 0 ? 1 : 0 ;    
        return 1;
    }

    elsif ($type & Parse_string)
    {
        $$output = defined $value ? $value : "" ;    
        return 1;
    }
    elsif ($type & Parse_code)
    {
        return $self->setError("Parameter '$key' must be a code reference, got '$value'")
            if (! defined $value || ref $value ne 'CODE') ;

        $$output = defined $value ? $value : "" ;    
        return 1;
    }
    
    $$output = $value ;
    return 1;
}

sub IO::Compress::Base::Parameters::parsed
{
    return $_[0]->[IxGot]{$_[1]}[OFF_PARSED] ;
}


sub IO::Compress::Base::Parameters::getValue
{
    return  $_[0]->[IxGot]{$_[1]}[OFF_FIXED] ;
}
sub IO::Compress::Base::Parameters::setValue
{
    $_[0]->[IxGot]{$_[1]}[OFF_PARSED]  = 1;
    $_[0]->[IxGot]{$_[1]}[OFF_DEFAULT] = $_[2] ;
    $_[0]->[IxGot]{$_[1]}[OFF_FIXED]   = $_[2] ;            
}

sub IO::Compress::Base::Parameters::valueRef
{
    return  $_[0]->[IxGot]{$_[1]}[OFF_FIXED]  ;
}

sub IO::Compress::Base::Parameters::valueOrDefault
{
    my $self = shift ;
    my $name = shift ;
    my $default = shift ;

    my $value = $self->[IxGot]{$name}[OFF_DEFAULT] ;
    
    return $value if defined $value ;
    return $default ;
}

sub IO::Compress::Base::Parameters::wantValue
{
    return defined $_[0]->[IxGot]{$_[1]}[OFF_DEFAULT] ;
}

sub IO::Compress::Base::Parameters::clone
{
    my $self = shift ;
    my $obj = [] ;
    my %got ;

    my $hash = $self->[IxGot] ;
    for my $k (keys %{ $hash })
    {
        $got{$k} = [ @@{ $hash->{$k} } ];
    }

    $obj->[IxError] = $self->[IxError];
    $obj->[IxGot] = \%got ;

    return bless $obj, 'IO::Compress::Base::Parameters' ;
}

package U64;

use constant MAX32 => 0xFFFFFFFF ;
use constant HI_1 => MAX32 + 1 ;
use constant LOW   => 0 ;
use constant HIGH  => 1;

sub new
{
    return bless [ 0, 0 ], $_[0]
        if @@_ == 1 ;
        
    return bless [ $_[1], 0 ], $_[0]
        if @@_ == 2 ;
        
    return bless [ $_[2], $_[1] ], $_[0]      
        if @@_ == 3 ;  
}

sub newUnpack_V64
{
    my ($low, $hi) = unpack "V V", $_[0] ;
    bless [ $low, $hi ], "U64";
}

sub newUnpack_V32
{
    my $string = shift;

    my $low = unpack "V", $string ;
    bless [ $low, 0 ], "U64";
}

sub reset
{
    $_[0]->[HIGH] = $_[0]->[LOW] = 0;
}

sub clone
{
    bless [ @@{$_[0]}  ], ref $_[0] ;    
}

sub getHigh
{
    return $_[0]->[HIGH];
}

sub getLow
{
    return $_[0]->[LOW];
}

sub get32bit
{
    return $_[0]->[LOW];
}

sub get64bit
{
    # Not using << here because the result will still be
    # a 32-bit value on systems where int size is 32-bits
    return $_[0]->[HIGH] * HI_1 + $_[0]->[LOW];
}

sub add
{
#    my $self = shift;
    my $value = $_[1];

    if (ref $value eq 'U64') {
        $_[0]->[HIGH] += $value->[HIGH] ;
        $value = $value->[LOW];
    }
    elsif ($value > MAX32) {      
        $_[0]->[HIGH] += int($value / HI_1) ;
        $value = $value % HI_1;
    }
     
    my $available = MAX32 - $_[0]->[LOW] ;
 
    if ($value > $available) {
       ++ $_[0]->[HIGH] ;
       $_[0]->[LOW] = $value - $available - 1;
    }
    else {
       $_[0]->[LOW] += $value ;
    }
}

sub add32
{
#    my $self = shift;
    my $value = $_[1];

    if ($value > MAX32) {      
        $_[0]->[HIGH] += int($value / HI_1) ;
        $value = $value % HI_1;
    }
     
    my $available = MAX32 - $_[0]->[LOW] ;
 
    if ($value > $available) {
       ++ $_[0]->[HIGH] ;
       $_[0]->[LOW] = $value - $available - 1;
    }
    else {
       $_[0]->[LOW] += $value ;
    }
}

sub subtract
{
    my $self = shift;
    my $value = shift;

    if (ref $value eq 'U64') {

        if ($value->[HIGH]) {
            die "bad"
                if $self->[HIGH] == 0 ||
                   $value->[HIGH] > $self->[HIGH] ;

           $self->[HIGH] -= $value->[HIGH] ;
        }

        $value = $value->[LOW] ;
    }

    if ($value > $self->[LOW]) {
       -- $self->[HIGH] ;
       $self->[LOW] = MAX32 - $value + $self->[LOW] + 1 ;
    }
    else {
       $self->[LOW] -= $value;
    }
}

sub equal
{
    my $self = shift;
    my $other = shift;

    return $self->[LOW]  == $other->[LOW] &&
           $self->[HIGH] == $other->[HIGH] ;
}

sub gt
{
    my $self = shift;
    my $other = shift;

    return $self->cmp($other) > 0 ;
}

sub cmp
{
    my $self = shift;
    my $other = shift ;

    if ($self->[LOW] == $other->[LOW]) {
        return $self->[HIGH] - $other->[HIGH] ;
    }
    else {
        return $self->[LOW] - $other->[LOW] ;
    }
}
    

sub is64bit
{
    return $_[0]->[HIGH] > 0 ;
}

sub isAlmost64bit
{
    return $_[0]->[HIGH] > 0 ||  $_[0]->[LOW] == MAX32 ;
}

sub getPacked_V64
{
    return pack "V V", @@{ $_[0] } ;
}

sub getPacked_V32
{
    return pack "V", $_[0]->[LOW] ;
}

sub pack_V64
{
    return pack "V V", $_[0], 0;
}


sub full32 
{
    return $_[0] == MAX32 ;
}

sub Value_VV64
{
    my $buffer = shift;

    my ($lo, $hi) = unpack ("V V" , $buffer);
    no warnings 'uninitialized';
    return $hi * HI_1 + $lo;
}


package IO::Compress::Base::Common;

1;
@


1.2
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.


ok deraadt@@
@
text
@d14 1
a14 1
$VERSION = '2.064_01';
d467 1
a467 1
#$VERSION = '2.000_09';
@


1.1
log
@Initial revision
@
text
@d14 1
a14 1
$VERSION = '2.024';
d16 2
a17 1
@@EXPORT = qw( isaFilehandle isaFilename whatIsInput whatIsOutput 
d22 4
a25 1
              getEncoding
d49 3
d53 6
d108 1
a108 1
    binmode $handle 
d122 5
d379 4
a382 4
        if (! -r _ )
        {
            return $self->saveErrorString("cannot open file '$filename': $!");
        }
d467 1
a467 1
#$VERSION = '2.000_08';
d472 3
a474 2
                           Parse_boolean Parse_custom Parse_string
                           Parse_multiple Parse_writable_scalar
d485 1
a485 1
use constant Parse_custom   => 0x12;
d488 1
a488 1
use constant Parse_multiple         => 0x100 ;
d496 2
a497 3
use constant OFF_FIRST_ONLY => 4 ;
use constant OFF_STICKY     => 5 ;

d499 2
d514 1
a514 1
        or croak "$sub: $p->{Error}" ;
a518 1
#package IO::Compress::Base::Parameters;
d521 1
d525 35
d562 1
a562 1
    my $class = shift ;
d564 3
a566 3
    my $obj = { Error => '',
                Got   => {},
              } ;
a567 1
    #return bless $obj, ref($class) || $class || __PACKAGE__ ;
d577 2
a578 1
    $self->{Error} = $error ;
d582 5
a586 5
#sub getError
#{
#    my $self = shift ;
#    return $self->{Error} ;
#}
a590 1

d593 1
a593 1
    my $got = $self->{Got} ;
a594 1
    my $other;
d616 1
d622 2
a623 7
            if ($_[2 * $i] eq '__xxx__') {
                $other = $_[2 * $i + 1] ;
            }
            else {
                push @@entered, $_[2 * $i] ;
                push @@entered, \$_[2 * $i + 1] ;
            }
d627 12
a638 18

    while (my ($key, $v) = each %$default)
    {
        croak "need 4 params [@@$v]"
            if @@$v != 4 ;

        my ($first_only, $sticky, $type, $value) = @@$v ;
        my $x ;
        $self->_checkType($key, \$value, $type, 0, \$x) 
            or return undef ;

        $key = lc $key;

        if ($firstTime || ! $sticky) {
            $x = []
                if $type & Parse_multiple;

            $got->{$key} = [0, $type, $value, $x, $first_only, $sticky] ;
a640 2
        $got->{$key}[OFF_PARSED] = 0 ;
    }
d644 1
a644 17
    if ($other) 
    {
        for my $key (keys %$default)  
        {
            my $canonkey = lc $key;
            if ($other->parsed($canonkey))
            {
                my $value = $other->value($canonkey);
#print "SET '$canonkey' to $value [$$value]\n";
                ++ $parsed{$canonkey};
                $got->{$canonkey}[OFF_PARSED]  = 1;
                $got->{$canonkey}[OFF_DEFAULT] = $value;
                $got->{$canonkey}[OFF_FIXED]   = $value;
            }
        }
    }
    
d655 1
a655 2
        if ($got->{$canonkey} && ($firstTime ||
                                  ! $got->{$canonkey}[OFF_FIRST_ONLY]  ))
d662 1
a662 1
                if $parsed && $type & Parse_multiple == 0 ;
d669 2
a670 7
            if ($type & Parse_multiple) {
                $got->{$canonkey}[OFF_PARSED] = 1;
                push @@{ $got->{$canonkey}[OFF_FIXED] }, $s ;
            }
            else {
                $got->{$canonkey} = [1, $type, $value, $s] ;
            }
d700 1
a700 1
            if $validate &&  readonly $$value ;
d705 1
a705 1
                if $validate &&  ref $$value ne 'SCALAR' ;
d712 1
a712 1
                if $validate &&  ref $value ne 'SCALAR' ;
a719 8
#    if ($type & Parse_store_ref)
#    {
#        #$value = $$value
#        #    if ref ${ $value } ;
#
#        $$output = $value ;
#        return 1;
#    }
d730 1
d732 1
a732 1
            if $validate && ! defined $value ;
d734 2
a735 2
            if $validate && $value !~ /^\d+$/;

d742 1
a742 1
            if $validate && ! defined $value ;
d744 1
a744 1
            if $validate && $value !~ /^-?\d+$/;
d752 3
a754 2
            if $validate && defined $value && $value !~ /^\d*$/;
        $$output =  defined $value ? $value != 0 : 0 ;    
d757 1
d763 4
d768 4
d776 4
d782 5
a786 1
sub IO::Compress::Base::Parameters::parsed
d788 3
a790 4
    my $self = shift ;
    my $name = shift ;

    return $self->{Got}{lc $name}[OFF_PARSED] ;
d793 1
a793 1
sub IO::Compress::Base::Parameters::value
d795 1
a795 11
    my $self = shift ;
    my $name = shift ;

    if (@@_)
    {
        $self->{Got}{lc $name}[OFF_PARSED]  = 1;
        $self->{Got}{lc $name}[OFF_DEFAULT] = $_[0] ;
        $self->{Got}{lc $name}[OFF_FIXED]   = $_[0] ;
    }

    return $self->{Got}{lc $name}[OFF_FIXED] ;
d804 2
a805 2
    my $value = $self->{Got}{lc $name}[OFF_DEFAULT] ;

d812 1
a812 5
    my $self = shift ;
    my $name = shift ;

    return defined $self->{Got}{lc $name}[OFF_DEFAULT] ;

d818 1
a818 1
    my $obj = { };
d821 4
a824 2
    while (my ($k, $v) = each %{ $self->{Got} }) {
        $got{$k} = [ @@$v ];
d827 2
a828 2
    $obj->{Error} = $self->{Error};
    $obj->{Got} = \%got ;
d842 8
a849 14
    my $class = shift ;

    my $high = 0 ;
    my $low  = 0 ;

    if (@@_ == 2) {
        $high = shift ;
        $low  = shift ;
    }
    elsif (@@_ == 1) {
        $low  = shift ;
    }

    bless [$low, $high], $class;
d854 1
a854 3
    my $string = shift;

    my ($low, $hi) = unpack "V V", $string ;
d868 1
a868 2
    my $self = shift;
    $self->[HIGH] = $self->[LOW] = 0;
d873 1
a873 2
    my $self = shift;
    bless [ @@$self ], ref $self ;
d878 1
a878 2
    my $self = shift;
    return $self->[HIGH];
d883 1
a883 2
    my $self = shift;
    return $self->[LOW];
d888 1
a888 2
    my $self = shift;
    return $self->[LOW];
a892 1
    my $self = shift;
d895 1
a895 1
    return $self->[HIGH] * HI_1 + $self->[LOW];
d900 2
a901 2
    my $self = shift;
    my $value = shift;
d904 1
a904 1
        $self->[HIGH] += $value->[HIGH] ;
d907 4
d912 15
a926 1
    my $available = MAX32 - $self->[LOW] ;
d928 7
d936 2
a937 2
       ++ $self->[HIGH] ;
       $self->[LOW] = $value - $available - 1;
d940 20
a959 1
       $self->[LOW] += $value ;
d962 7
d980 1
a980 1
sub is64bit
d983 3
a985 1
    return $self->[HIGH] > 0 ;
d988 1
a988 1
sub getPacked_V64
d991 20
d1012 3
a1014 1
    return pack "V V", @@$self ;
d1019 8
a1026 1
    my $self = shift;
d1028 3
a1030 1
    return pack "V", $self->[LOW] ;
d1033 1
a1033 1
sub pack_V64
d1035 1
a1035 1
    my $low  = shift;
d1037 3
a1039 1
    return pack "V V", $low, 0;
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d14 1
a14 1
$VERSION = '2.048';
d16 1
a16 2
@@EXPORT = qw( isaFilehandle isaFilename isaScalar
              whatIsInput whatIsOutput 
a22 4
              isGeMax32

              MAX32

a44 3
use constant MAX16            => 0xFFFF ;  
use constant MAX32            => 0xFFFFFFFF ;  
use constant MAX32cmp         => 0xFFFFFFFF + 1 - 1; # for 5.6.x on 32-bit need to force an non-IV value 
a45 6

sub isGeMax32
{
    return $_[0] >= MAX32cmp ;
}

a108 5
sub isaScalar
{
    return ( defined($_[0]) and ref($_[0]) eq 'SCALAR' and defined ${ $_[0] } ) ;
}

d454 1
a454 2
                           Parse_boolean Parse_string
                           Parse_code
d466 1
a466 1
use constant Parse_code     => 0x20;
a501 1

d638 1
a638 1
                if $parsed && ($type & Parse_multiple) == 0 ;
a743 7
    elsif ($type & Parse_code)
    {
        return $self->setError("Parameter '$key' must be a code reference, got '$value'")
            if $validate && (! defined $value || ref $value ne 'CODE') ;
        $$output = defined $value ? $value : "" ;    
        return 1;
    }
a903 4
    elsif ($value > MAX32) {      
        $self->[HIGH] += int($value / HI_1) ;
        $value = $value % HI_1;
    }
d906 1
a906 1
 
a913 6
}

sub subtract
{
    my $self = shift;
    my $value = shift;
a914 20
    if (ref $value eq 'U64') {

        if ($value->[HIGH]) {
            die "bad"
                if $self->[HIGH] == 0 ||
                   $value->[HIGH] > $self->[HIGH] ;

           $self->[HIGH] -= $value->[HIGH] ;
        }

        $value = $value->[LOW] ;
    }

    if ($value > $self->[LOW]) {
       -- $self->[HIGH] ;
       $self->[LOW] = MAX32 - $value + $self->[LOW] + 1 ;
    }
    else {
       $self->[LOW] -= $value;
    }
a925 22
sub gt
{
    my $self = shift;
    my $other = shift;

    return $self->cmp($other) > 0 ;
}

sub cmp
{
    my $self = shift;
    my $other = shift ;

    if ($self->[LOW] == $other->[LOW]) {
        return $self->[HIGH] - $other->[HIGH] ;
    }
    else {
        return $self->[LOW] - $other->[LOW] ;
    }
}
    

a931 6
sub isAlmost64bit
{
    my $self = shift;
    return $self->[HIGH] > 0 ||  $self->[LOW] == MAX32 ;
}

a950 15
}


sub full32 
{
    return $_[0] == MAX32 ;
}

sub Value_VV64
{
    my $buffer = shift;

    my ($lo, $hi) = unpack ("V V" , $buffer);
    no warnings 'uninitialized';
    return $hi * HI_1 + $lo;
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d14 1
a14 1
$VERSION = '2.060';
d22 2
a23 1
              
d109 1
a109 1
    binmode $handle
d380 4
a383 4
#        if (! -r _ )
#        {
#            return $self->saveErrorString("cannot open file '$filename': $!");
#        }
d475 1
a475 1
                           Parse_writable_scalar
d489 1
a489 1
#use constant Parse_multiple         => 0x100 ;
d497 3
a499 2
#use constant OFF_FIRST_ONLY => 4 ;
#use constant OFF_STICKY     => 5 ;
a500 2
use constant IxError => 0;
use constant IxGot   => 1 ;
d514 1
a514 1
        or croak "$sub: $p->[IxError]" ;
d519 1
a525 35

sub Init
{
    my $default = shift ;
    my %got ;
    
    my $obj = IO::Compress::Base::Parameters::new();
    while (my ($key, $v) = each %$default)
    {
        croak "need 2 params [@@$v]"
            if @@$v != 2 ;

        my ($type, $value) = @@$v ;
#        my ($first_only, $sticky, $type, $value) = @@$v ;
        my $sticky = 0;
        my $x ;
        $obj->_checkType($key, \$value, $type, 0, \$x) 
            or return undef ;

        $key = lc $key;

#        if (! $sticky) {
#            $x = []
#                if $type & Parse_multiple;

#            $got{$key} = [0, $type, $value, $x, $first_only, $sticky] ;
            $got{$key} = [0, $type, $value, $x] ;            
#        }
#
#        $got{$key}[OFF_PARSED] = 0 ;
    }
    
    return bless \%got, "IO::Compress::Base::Parameters::Defaults" ;
}

d528 1
a528 1
    #my $class = shift ;
d530 3
a532 3
    my $obj;
    $obj->[IxError] = '';
    $obj->[IxGot] = {} ;          
d534 1
d544 1
a544 2

    $self->[IxError] = $error ;
d548 5
a552 5
sub IO::Compress::Base::Parameters::getError
{
    my $self = shift ;
    return $self->[IxError] ;
}
d557 1
d560 1
a560 1
    my $got = $self->[IxGot] ;
d562 1
a583 1
       
d589 7
a595 2
            push @@entered, $_[2 * $i] ;
            push @@entered, \$_[2 * $i + 1] ;
d599 18
a616 12
        foreach my $key (keys %$default)
        {
    
            my ($type, $value) = @@{ $default->{$key} } ;
  
            if ($firstTime) {   
                $got->{$key} = [0, $type, $value, $value] ;               
            }
            else
            {
                $got->{$key}[OFF_PARSED] = 0 ;      
            }               
d619 2
d624 17
a640 1
   
d651 2
a652 1
        if ($got->{$canonkey})                                  
d659 1
a659 1
                if $parsed ; 
d666 7
a672 2
            $got->{$canonkey} = [1, $type, $value, $s] ;

d702 1
a702 1
            if  readonly $$value ;
d707 1
a707 1
                if ref $$value ne 'SCALAR' ;
d714 1
a714 1
                if ref $value ne 'SCALAR' ;
d722 8
a739 1
     
d741 1
a741 1
            if ! defined $value ;
d743 2
a744 2
            if $value !~ /^\d+$/;
    
d751 1
a751 1
            if ! defined $value ;
d753 1
a753 1
            if $value !~ /^-?\d+$/;
d761 2
a762 3
            if defined $value && $value !~ /^\d*$/;

        $$output =  defined $value && $value != 0 ? 1 : 0 ;    
d765 1
a765 2

    elsif ($type & Parse_string)
d767 2
d772 1
a772 1
    elsif ($type & Parse_code)
a773 3
        return $self->setError("Parameter '$key' must be a code reference, got '$value'")
            if (! defined $value || ref $value ne 'CODE') ;

d777 1
a777 1
    
d782 2
d786 4
a789 1
    return $_[0]->[IxGot]{$_[1]}[OFF_PARSED] ;
d792 4
d797 6
a802 10
sub IO::Compress::Base::Parameters::getValue
{
    return  $_[0]->[IxGot]{$_[1]}[OFF_FIXED] ;
}
sub IO::Compress::Base::Parameters::setValue
{
    $_[0]->[IxGot]{$_[1]}[OFF_PARSED]  = 1;
    $_[0]->[IxGot]{$_[1]}[OFF_DEFAULT] = $_[2] ;
    $_[0]->[IxGot]{$_[1]}[OFF_FIXED]   = $_[2] ;            
}
d804 1
a804 3
sub IO::Compress::Base::Parameters::valueRef
{
    return  $_[0]->[IxGot]{$_[1]}[OFF_FIXED]  ;
d813 2
a814 2
    my $value = $self->[IxGot]{$name}[OFF_DEFAULT] ;
    
d821 5
a825 1
    return defined $_[0]->[IxGot]{$_[1]}[OFF_DEFAULT] ;
d831 1
a831 1
    my $obj = [] ;
d834 2
a835 4
    my $hash = $self->[IxGot] ;
    for my $k (keys %{ $hash })
    {
        $got{$k} = [ @@{ $hash->{$k} } ];
d838 2
a839 2
    $obj->[IxError] = $self->[IxError];
    $obj->[IxGot] = \%got ;
d853 14
a866 8
    return bless [ 0, 0 ], $_[0]
        if @@_ == 1 ;
        
    return bless [ $_[1], 0 ], $_[0]
        if @@_ == 2 ;
        
    return bless [ $_[2], $_[1] ], $_[0]      
        if @@_ == 3 ;  
d871 3
a873 1
    my ($low, $hi) = unpack "V V", $_[0] ;
d887 2
a888 1
    $_[0]->[HIGH] = $_[0]->[LOW] = 0;
d893 2
a894 1
    bless [ @@{$_[0]}  ], ref $_[0] ;    
d899 2
a900 1
    return $_[0]->[HIGH];
d905 2
a906 1
    return $_[0]->[LOW];
d911 2
a912 1
    return $_[0]->[LOW];
d917 1
d920 1
a920 1
    return $_[0]->[HIGH] * HI_1 + $_[0]->[LOW];
d925 2
a926 2
#    my $self = shift;
    my $value = $_[1];
d929 1
a929 1
        $_[0]->[HIGH] += $value->[HIGH] ;
d933 1
a933 22
        $_[0]->[HIGH] += int($value / HI_1) ;
        $value = $value % HI_1;
    }
     
    my $available = MAX32 - $_[0]->[LOW] ;
 
    if ($value > $available) {
       ++ $_[0]->[HIGH] ;
       $_[0]->[LOW] = $value - $available - 1;
    }
    else {
       $_[0]->[LOW] += $value ;
    }
}

sub add32
{
#    my $self = shift;
    my $value = $_[1];

    if ($value > MAX32) {      
        $_[0]->[HIGH] += int($value / HI_1) ;
d937 1
a937 1
    my $available = MAX32 - $_[0]->[LOW] ;
d940 2
a941 2
       ++ $_[0]->[HIGH] ;
       $_[0]->[LOW] = $value - $available - 1;
d944 1
a944 1
       $_[0]->[LOW] += $value ;
d1008 2
a1009 1
    return $_[0]->[HIGH] > 0 ;
d1014 2
a1015 1
    return $_[0]->[HIGH] > 0 ||  $_[0]->[LOW] == MAX32 ;
d1020 3
a1022 1
    return pack "V V", @@{ $_[0] } ;
d1027 3
a1029 1
    return pack "V", $_[0]->[LOW] ;
d1034 3
a1036 1
    return pack "V V", $_[0], 0;
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@d14 1
a14 1
$VERSION = '2.064';
@


1.1.1.4.4.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d14 1
a14 1
$VERSION = '2.064_01';
d467 1
a467 1
#$VERSION = '2.000_09';
@


1.1.1.4.6.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d14 1
a14 1
$VERSION = '2.064_01';
d467 1
a467 1
#$VERSION = '2.000_09';
@


