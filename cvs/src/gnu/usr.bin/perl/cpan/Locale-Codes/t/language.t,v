head	1.1;
branch	1.1.1;
access;
symbols
	PERL_5_24_2:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.18
	OPENBSD_6_1_BASE:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.16
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.10
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.12
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.4
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.8
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2010.09.24.14.49.03;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.03;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.07.50;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl
#
# language.t - tests for Locale::Language
#

BEGIN {
	chdir 't' if -d 't';
	#@@INC = '../lib';
}

use Locale::Language;

no utf8; # we contain Latin-1

#-----------------------------------------------------------------------
# This is an array of tests. Each test is eval'd as an expression.
# If it evaluates to FALSE, then "not ok N" is printed for the test,
# otherwise "ok N".
#-----------------------------------------------------------------------
@@TESTS =
(
	#================================================
	# TESTS FOR code2language
	#================================================

 #---- selection of examples which should all result in undef -----------
 '!defined code2language()',                 # no argument => undef returned
 '!defined code2language(undef)',            # undef arg   => undef returned
 '!defined code2language("zz")',             # illegal code => undef
 '!defined code2language("jp")',             # ja for lang, jp for country

 #---- test recent changes ----------------------------------------------
 'code2language("ae") eq "Avestan"',
 'code2language("bs") eq "Bosnian"',
 'code2language("ch") eq "Chamorro"',
 'code2language("ce") eq "Chechen"',
 'code2language("cu") eq "Church Slavic"',
 'code2language("cv") eq "Chuvash"',
 'code2language("hz") eq "Herero"',
 'code2language("ho") eq "Hiri Motu"',
 'code2language("ki") eq "Kikuyu"',
 'code2language("kj") eq "Kuanyama"',
 'code2language("kv") eq "Komi"',
 'code2language("mh") eq "Marshall"',
 'code2language("nv") eq "Navajo"',
 'code2language("nr") eq "Ndebele, South"',
 'code2language("nd") eq "Ndebele, North"',
 'code2language("ng") eq "Ndonga"',
 'code2language("nn") eq "Norwegian Nynorsk"',
 'code2language("nb") eq "Norwegian Bokmal"',
 'code2language("ny") eq "Chichewa; Nyanja"',
 'code2language("oc") eq "Occitan (post 1500)"',
 'code2language("os") eq "Ossetian; Ossetic"',
 'code2language("pi") eq "Pali"',
 '!defined code2language("sh")',             # Serbo-Croatian withdrawn
 'code2language("se") eq "Sami"',
 'code2language("sc") eq "Sardinian"',
 'code2language("kw") eq "Cornish"',
 'code2language("gv") eq "Manx"',
 'code2language("lb") eq "Letzeburgesch"',
 'code2language("he") eq "Hebrew"',
 '!defined code2language("iw")',             # Hebrew withdrawn
 'code2language("id") eq "Indonesian"',
 '!defined code2language("in")',             # Indonesian withdrawn
 'code2language("iu") eq "Inuktitut"',
 'code2language("ug") eq "Uighur"',
 '!defined code2language("ji")',             # Yiddish withdrawn
 'code2language("yi") eq "Yiddish"',
 'code2language("za") eq "Zhuang"',

 #---- some successful examples -----------------------------------------
 'code2language("DA") eq "Danish"',
 'code2language("eo") eq "Esperanto"',
 'code2language("fi") eq "Finnish"',
 'code2language("en") eq "English"',
 'code2language("aa") eq "Afar"',            # first in DATA segment
 'code2language("zu") eq "Zulu"',            # last in DATA segment

	#================================================
	# TESTS FOR language2code
	#================================================

 #---- selection of examples which should all result in undef -----------
 '!defined language2code()',                 # no argument => undef returned
 '!defined language2code(undef)',            # undef arg   => undef returned
 '!defined language2code("Banana")',         # illegal lang name => undef

 #---- some successful examples -----------------------------------------
 'language2code("Japanese")  eq "ja"',
 'language2code("japanese")  eq "ja"',
 'language2code("japanese")  ne "jp"',
 'language2code("French")    eq "fr"',
 'language2code("Greek")     eq "el"',
 'language2code("english")   eq "en"',
 'language2code("ESTONIAN")  eq "et"',
 'language2code("Afar")      eq "aa"',       # first in DATA segment
 'language2code("Zulu")      eq "zu"',       # last in DATA segment
);

print "1..", int(@@TESTS), "\n";

$testid = 1;
foreach $test (@@TESTS)
{
    eval "print (($test) ? \"ok $testid\\n\" : \"not ok $testid\\n\" )";
    print "not ok $testid\n" if $@@;
    ++$testid;
}

exit 0;
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d1 9
a9 3
#!/usr/bin/perl -w

require 5.002;
d11 1
a11 12
$runtests=shift(@@ARGV);
if ( -f "t/testfunc.pl" ) {
  require "t/testfunc.pl";
  $dir="./lib";
  $tdir="t";
} elsif ( -f "testfunc.pl" ) {
  require "testfunc.pl";
  $dir="../lib";
  $tdir=".";
} else {
  die "ERROR: cannot find testfunc.pl\n";
}
d13 1
a13 2
unshift(@@INC,$dir);
use Locale::Codes::Language;
d15 93
a107 45
%type = ( "LOCALE_LANG_ALPHA_2" => LOCALE_LANG_ALPHA_2,
          "LOCALE_LANG_ALPHA_3" => LOCALE_LANG_ALPHA_3,
          "LOCALE_LANG_TERM"    => LOCALE_LANG_TERM,
        );

sub test {
   my(@@test) = @@_;

   if      ($test[0] eq "rename_language") {
      shift(@@test);
      $test[2]  = $type{$test[2]}
        if (@@test == 3  &&  $test[2]  &&  exists $type{$test[2]});
      return Locale::Codes::Language::rename_language(@@test,"nowarn");

   } elsif ($test[0] eq "add_language") {
      shift(@@test);
      $test[2]  = $type{$test[2]}
        if (@@test == 3  &&  $test[2]  &&  exists $type{$test[2]});
      return Locale::Codes::Language::add_language(@@test,"nowarn");

   } elsif ($test[0] eq "delete_language") {
      shift(@@test);
      $test[1]  = $type{$test[1]}
        if (@@test == 2  &&  $test[1]  &&  exists $type{$test[1]});
      return Locale::Codes::Language::delete_language(@@test,"nowarn");

   } elsif ($test[0] eq "add_language_alias") {
      shift(@@test);
      return Locale::Codes::Language::add_language_alias(@@test,"nowarn");

   } elsif ($test[0] eq "delete_language_alias") {
      shift(@@test);
      return Locale::Codes::Language::delete_language_alias(@@test,"nowarn");

   } elsif ($test[0] eq "language2code") {
      shift(@@test);
      $test[1]  = $type{$test[1]}
        if (@@test == 2  &&  $test[1]  &&  exists $type{$test[1]});
      return language2code(@@test);

   } else {
      $test[1]  = $type{$test[1]}
        if (@@test == 2  &&  $test[1]  &&  exists $type{$test[1]});
      return code2language(@@test);
   }
d110 1
a110 32
$tests = "

zu ~ Zulu

rename_language zu NewName LOCALE_LANG_FOO ~ 0

rename_language zu English LOCALE_LANG_ALPHA_2 ~ 0

rename_language zu NewName LOCALE_LANG_ALPHA_3 ~ 0

zu ~ Zulu

rename_language zu NewName LOCALE_LANG_ALPHA_2 ~ 1

zu ~ NewName

";

print "language (semi-private)...\n";
test_Func(\&test,$tests,$runtests);

1;
# Local Variables:
# mode: cperl
# indent-tabs-mode: nil
# cperl-indent-level: 3
# cperl-continued-statement-offset: 2
# cperl-continued-brace-offset: 0
# cperl-brace-offset: 0
# cperl-brace-imaginary-offset: 0
# cperl-label-offset: -2
# End:
@

