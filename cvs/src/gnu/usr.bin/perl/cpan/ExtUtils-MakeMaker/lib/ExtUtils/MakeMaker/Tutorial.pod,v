head	1.3;
access;
symbols
	PERL_5_24_2:1.1.1.5
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.4.0.4
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.6
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.31.58;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2016.07.25.10.53.01;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	FHUgABTHZQuYQh2B;

1.1
date	2010.09.24.14.48.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.58;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.07.41;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.52;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.52.47;	author afresh1;	state Exp;
branches
	1.1.1.4.4.1
	1.1.1.4.6.1;
next	1.1.1.5;
commitid	B31cAbBIXiCqnL97;

1.1.1.5
date	2017.08.14.13.45.37;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;

1.1.1.4.4.1
date	2016.08.05.01.01.37;	author afresh1;	state Exp;
branches;
next	;
commitid	HjAJx2yjL4A8HWon;

1.1.1.4.6.1
date	2016.08.05.01.00.53;	author afresh1;	state Exp;
branches;
next	;
commitid	wK3bUiy9jNch0Key;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package ExtUtils::MakeMaker::Tutorial;

our $VERSION = '7.10_01';


=head1 NAME

ExtUtils::MakeMaker::Tutorial - Writing a module with MakeMaker

=head1 SYNOPSIS

    use ExtUtils::MakeMaker;

    WriteMakefile(
        NAME            => 'Your::Module',
        VERSION_FROM    => 'lib/Your/Module.pm'
    );

=head1 DESCRIPTION

This is a short tutorial on writing a simple module with MakeMaker.
It's really not that hard.


=head2 The Mantra

MakeMaker modules are installed using this simple mantra

        perl Makefile.PL
        make
        make test
        make install

There are lots more commands and options, but the above will do it.


=head2 The Layout

The basic files in a module look something like this.

        Makefile.PL
        MANIFEST
        lib/Your/Module.pm

That's all that's strictly necessary.  There's additional files you might
want:

        lib/Your/Other/Module.pm
        t/some_test.t
        t/some_other_test.t
        Changes
        README
        INSTALL
        MANIFEST.SKIP
        bin/some_program

=over 4

=item Makefile.PL

When you run Makefile.PL, it makes a Makefile.  That's the whole point of
MakeMaker.  The Makefile.PL is a simple program which loads
ExtUtils::MakeMaker and runs the WriteMakefile() function to generate a
Makefile.

Here's an example of what you need for a simple module:

    use ExtUtils::MakeMaker;

    WriteMakefile(
        NAME            => 'Your::Module',
        VERSION_FROM    => 'lib/Your/Module.pm'
    );

NAME is the top-level namespace of your module.  VERSION_FROM is the file
which contains the $VERSION variable for the entire distribution.  Typically
this is the same as your top-level module.


=item MANIFEST

A simple listing of all the files in your distribution.

        Makefile.PL
        MANIFEST
        lib/Your/Module.pm

File paths in a MANIFEST always use Unix conventions (ie. /) even if you're
not on Unix.

You can write this by hand or generate it with 'make manifest'.

See L<ExtUtils::Manifest> for more details.


=item lib/

This is the directory where the .pm and .pod files you wish to have
installed go.  They are laid out according to namespace.  So Foo::Bar
is F<lib/Foo/Bar.pm>.


=item t/

Tests for your modules go here.  Each test filename ends with a .t.
So F<t/foo.t>/  'make test' will run these tests.  The directory is flat,
you cannot, for example, have t/foo/bar.t run by 'make test'.

Tests are run from the top level of your distribution.  So inside a test
you would refer to ./lib to enter the lib directory, for example.


=item Changes

A log of changes you've made to this module.  The layout is free-form.
Here's an example:

    1.01 Fri Apr 11 00:21:25 PDT 2003
        - thing() does some stuff now
        - fixed the wiggy bug in withit()

    1.00 Mon Apr  7 00:57:15 PDT 2003
        - "Rain of Frogs" now supported


=item README

A short description of your module, what it does, why someone would use it
and its limitations.  CPAN automatically pulls your README file out of
the archive and makes it available to CPAN users, it is the first thing
they will read to decide if your module is right for them.


=item INSTALL

Instructions on how to install your module along with any dependencies.
Suggested information to include here:

    any extra modules required for use
    the minimum version of Perl required
    if only works on certain operating systems


=item MANIFEST.SKIP

A file full of regular expressions to exclude when using 'make
manifest' to generate the MANIFEST.  These regular expressions
are checked against each file path found in the distribution (so
you're matching against "t/foo.t" not "foo.t").

Here's a sample:

    ~$          # ignore emacs and vim backup files
    .bak$       # ignore manual backups
    \#          # ignore CVS old revision files and emacs temp files

Since # can be used for comments, # must be escaped.

MakeMaker comes with a default MANIFEST.SKIP to avoid things like
version control directories and backup files.  Specifying your own
will override this default.


=item bin/


=back

=head1 SEE ALSO

L<perlmodstyle> gives stylistic help writing a module.

L<perlnewmod> gives more information about how to write a module.

There are modules to help you through the process of writing a module:
L<ExtUtils::ModuleMaker>, L<Module::Install>, L<PAR>

=cut

1;
@


1.2
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.


ok deraadt@@
@
text
@d3 1
a3 1
our $VERSION = '6.98_01';
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
our $VERSION = 0.02;
d22 1
a22 1
Its really not that hard.
d98 2
a99 2
This is the directory where your .pm and .pod files you wish to have
installed go.  They are layed out according to namespace.  So Foo::Bar
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d3 1
a3 1
our $VERSION = 6.63_02;
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d3 1
a3 1
our $VERSION = '6.66';
d22 1
a22 1
It's really not that hard.
d98 2
a99 2
This is the directory where the .pm and .pod files you wish to have
installed go.  They are laid out according to namespace.  So Foo::Bar
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@d3 1
a3 1
our $VERSION = '6.98';
@


1.1.1.5
log
@Import perl-5.24.2
@
text
@d3 1
a3 1
our $VERSION = '7.10_01';
@


1.1.1.4.4.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d3 1
a3 1
our $VERSION = '6.98_01';
@


1.1.1.4.6.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d3 1
a3 1
our $VERSION = '6.98_01';
@


