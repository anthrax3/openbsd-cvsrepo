head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.2
	OPENBSD_6_2_BASE:1.3
	PERL_5_24_2:1.1.1.5
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.4.0.4
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.6
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.31.58;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2016.07.25.10.53.01;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	FHUgABTHZQuYQh2B;

1.1
date	2010.09.24.14.48.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.58;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.07.41;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.52;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.52.46;	author afresh1;	state Exp;
branches
	1.1.1.4.4.1
	1.1.1.4.6.1;
next	1.1.1.5;
commitid	B31cAbBIXiCqnL97;

1.1.1.5
date	2017.08.14.13.45.37;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;

1.1.1.4.4.1
date	2016.08.05.01.01.37;	author afresh1;	state Exp;
branches;
next	;
commitid	HjAJx2yjL4A8HWon;

1.1.1.4.6.1
date	2016.08.05.01.00.53;	author afresh1;	state Exp;
branches;
next	;
commitid	wK3bUiy9jNch0Key;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package ExtUtils::Liblist::Kid;

# XXX Splitting this out into its own .pm is a temporary solution.

# This kid package is to be used by MakeMaker.  It will not work if
# $self is not a Makemaker.

use 5.006;

# Broken out of MakeMaker from version 4.11

use strict;
use warnings;
our $VERSION = '7.10_02';

use ExtUtils::MakeMaker::Config;
use Cwd 'cwd';
use File::Basename;
use File::Spec;

sub ext {
    if    ( $^O eq 'VMS' )     { return &_vms_ext; }
    elsif ( $^O eq 'MSWin32' ) { return &_win32_ext; }
    else                       { return &_unix_os2_ext; }
}

sub _unix_os2_ext {
    my ( $self, $potential_libs, $verbose, $give_libs ) = @@_;
    $verbose ||= 0;

    if ( $^O =~ /os2|android/ and $Config{perllibs} ) {

        # Dynamic libraries are not transitive, so we may need including
        # the libraries linked against perl.dll/libperl.so again.

        $potential_libs .= " " if $potential_libs;
        $potential_libs .= $Config{perllibs};
    }
    return ( "", "", "", "", ( $give_libs ? [] : () ) ) unless $potential_libs;
    warn "Potential libraries are '$potential_libs':\n" if $verbose;

    my ( $so ) = $Config{so};
    my ( $libs ) = defined $Config{perllibs} ? $Config{perllibs} : $Config{libs};
    my $Config_libext = $Config{lib_ext} || ".a";
    my $Config_dlext = $Config{dlext};

    # compute $extralibs, $bsloadlibs and $ldloadlibs from
    # $potential_libs
    # this is a rewrite of Andy Dougherty's extliblist in perl

    my ( @@searchpath );    # from "-L/path" entries in $potential_libs
    my ( @@libpath ) = split " ", $Config{'libpth'} || '';
    my ( @@ldloadlibs, @@bsloadlibs, @@extralibs, @@ld_run_path, %ld_run_path_seen );
    my ( @@libs,       %libs_seen );
    my ( $fullname,   @@fullname );
    my ( $pwd )   = cwd();    # from Cwd.pm
    my ( $found ) = 0;

    foreach my $thislib ( split ' ', $potential_libs ) {
        my ( $custom_name ) = '';

        # Handle possible linker path arguments.
        if ( $thislib =~ s/^(-[LR]|-Wl,-R|-Wl,-rpath,)// ) {    # save path flag type
            my ( $ptype ) = $1;
            unless ( -d $thislib ) {
                warn "$ptype$thislib ignored, directory does not exist\n"
                  if $verbose;
                next;
            }
            my ( $rtype ) = $ptype;
            if ( ( $ptype eq '-R' ) or ( $ptype =~ m!^-Wl,-[Rr]! ) ) {
                if ( $Config{'lddlflags'} =~ /-Wl,-[Rr]/ ) {
                    $rtype = '-Wl,-R';
                }
                elsif ( $Config{'lddlflags'} =~ /-R/ ) {
                    $rtype = '-R';
                }
            }
            unless ( File::Spec->file_name_is_absolute( $thislib ) ) {
                warn "Warning: $ptype$thislib changed to $ptype$pwd/$thislib\n";
                $thislib = $self->catdir( $pwd, $thislib );
            }
            push( @@searchpath, $thislib );
            push( @@extralibs,  "$ptype$thislib" );
            push( @@ldloadlibs, "$rtype$thislib" );
            next;
        }

        if ( $thislib =~ m!^-Wl,! ) {
            push( @@extralibs,  $thislib );
            push( @@ldloadlibs, $thislib );
            next;
        }

        # Handle possible library arguments.
        if ( $thislib =~ s/^-l(:)?// ) {
            # Handle -l:foo.so, which means that the library will
            # actually be called foo.so, not libfoo.so.  This
            # is used in Android by ExtUtils::Depends to allow one XS
            # module to link to another.
            $custom_name = $1 || '';
        }
        else {
            warn "Unrecognized argument in LIBS ignored: '$thislib'\n";
            next;
        }

        my ( $found_lib ) = 0;
        foreach my $thispth ( @@searchpath, @@libpath ) {

            # Try to find the full name of the library.  We need this to
            # determine whether it's a dynamically-loadable library or not.
            # This tends to be subject to various os-specific quirks.
            # For gcc-2.6.2 on linux (March 1995), DLD can not load
            # .sa libraries, with the exception of libm.sa, so we
            # deliberately skip them.
            if ((@@fullname =
                 $self->lsdir($thispth, "^\Qlib$thislib.$so.\E[0-9]+")) ||
                (@@fullname =
                 $self->lsdir($thispth, "^\Qlib$thislib.\E[0-9]+\Q\.$so"))) {
                # Take care that libfoo.so.10 wins against libfoo.so.9.
                # Compare two libraries to find the most recent version
                # number.  E.g.  if you have libfoo.so.9.0.7 and
                # libfoo.so.10.1, first convert all digits into two
                # decimal places.  Then we'll add ".00" to the shorter
                # strings so that we're comparing strings of equal length
                # Thus we'll compare libfoo.so.09.07.00 with
                # libfoo.so.10.01.00.  Some libraries might have letters
                # in the version.  We don't know what they mean, but will
                # try to skip them gracefully -- we'll set any letter to
                # '0'.  Finally, sort in reverse so we can take the
                # first element.

                #TODO: iterate through the directory instead of sorting

                $fullname = "$thispth/" . (
                    sort {
                        my ( $ma ) = $a;
                        my ( $mb ) = $b;
                        $ma =~ tr/A-Za-z/0/s;
                        $ma =~ s/\b(\d)\b/0$1/g;
                        $mb =~ tr/A-Za-z/0/s;
                        $mb =~ s/\b(\d)\b/0$1/g;
                        while ( length( $ma ) < length( $mb ) ) { $ma .= ".00"; }
                        while ( length( $mb ) < length( $ma ) ) { $mb .= ".00"; }

                        # Comparison deliberately backwards
                        $mb cmp $ma;
                      } @@fullname
                )[0];
            }
            elsif ( -f ( $fullname = "$thispth/lib$thislib.$so" )
                && ( ( $Config{'dlsrc'} ne "dl_dld.xs" ) || ( $thislib eq "m" ) ) )
            {
            }
            elsif (-f ( $fullname = "$thispth/lib${thislib}_s$Config_libext" )
                && ( $Config{'archname'} !~ /RM\d\d\d-svr4/ )
                && ( $thislib .= "_s" ) )
            {    # we must explicitly use _s version
            }
            elsif ( -f ( $fullname = "$thispth/lib$thislib$Config_libext" ) ) {
            }
            elsif ( defined( $Config_dlext )
                && -f ( $fullname = "$thispth/lib$thislib.$Config_dlext" ) )
            {
            }
            elsif ( -f ( $fullname = "$thispth/$thislib$Config_libext" ) ) {
            }
            elsif ( -f ( $fullname = "$thispth/lib$thislib.dll$Config_libext" ) ) {
            }
            elsif ( $^O eq 'cygwin' && -f ( $fullname = "$thispth/$thislib.dll" ) ) {
            }
            elsif ( -f ( $fullname = "$thispth/Slib$thislib$Config_libext" ) ) {
            }
            elsif ($^O eq 'dgux'
                && -l ( $fullname = "$thispth/lib$thislib$Config_libext" )
                && readlink( $fullname ) =~ /^elink:/s )
            {

                # Some of DG's libraries look like misconnected symbolic
                # links, but development tools can follow them.  (They
                # look like this:
                #
                #    libm.a -> elink:${SDE_PATH:-/usr}/sde/\
                #    ${TARGET_BINARY_INTERFACE:-m88kdgux}/usr/lib/libm.a
                #
                # , the compilation tools expand the environment variables.)
            }
            elsif ( $custom_name && -f ( $fullname = "$thispth/$thislib" ) ) {
            }
            else {
                warn "$thislib not found in $thispth\n" if $verbose;
                next;
            }
            warn "'-l$thislib' found at $fullname\n" if $verbose;
            push @@libs, $fullname unless $libs_seen{$fullname}++;
            $found++;
            $found_lib++;

            # Now update library lists

            # what do we know about this library...
            my $is_dyna = ( $fullname !~ /\Q$Config_libext\E\z/ );
            my $in_perl = ( $libs =~ /\B-l:?\Q${thislib}\E\b/s );

            # include the path to the lib once in the dynamic linker path
            # but only if it is a dynamic lib and not in Perl itself
            my ( $fullnamedir ) = dirname( $fullname );
            push @@ld_run_path, $fullnamedir
              if $is_dyna
                  && !$in_perl
                  && !$ld_run_path_seen{$fullnamedir}++;

            # Do not add it into the list if it is already linked in
            # with the main perl executable.
            # We have to special-case the NeXT, because math and ndbm
            # are both in libsys_s
            unless (
                $in_perl
                || ( $Config{'osname'} eq 'next'
                    && ( $thislib eq 'm' || $thislib eq 'ndbm' ) )
              )
            {
                push( @@extralibs, "-l$custom_name$thislib" );
            }

            # We might be able to load this archive file dynamically
            if (   ( $Config{'dlsrc'} =~ /dl_next/ && $Config{'osvers'} lt '4_0' )
                || ( $Config{'dlsrc'} =~ /dl_dld/ ) )
            {

                # We push -l$thislib instead of $fullname because
                # it avoids hardwiring a fixed path into the .bs file.
                # Mkbootstrap will automatically add dl_findfile() to
                # the .bs file if it sees a name in the -l format.
                # USE THIS, when dl_findfile() is fixed:
                # push(@@bsloadlibs, "-l$thislib");
                # OLD USE WAS while checking results against old_extliblist
                push( @@bsloadlibs, "$fullname" );
            }
            else {
                if ( $is_dyna ) {

                    # For SunOS4, do not add in this shared library if
                    # it is already linked in the main perl executable
                    push( @@ldloadlibs, "-l$custom_name$thislib" )
                      unless ( $in_perl and $^O eq 'sunos' );
                }
                else {
                    push( @@ldloadlibs, "-l$custom_name$thislib" );
                }
            }
            last;    # found one here so don't bother looking further
        }
        warn "Warning (mostly harmless): " . "No library found for -l$thislib\n"
          unless $found_lib > 0;
    }

    unless ( $found ) {
        return ( '', '', '', '', ( $give_libs ? \@@libs : () ) );
    }
    else {
        return ( "@@extralibs", "@@bsloadlibs", "@@ldloadlibs", join( ":", @@ld_run_path ), ( $give_libs ? \@@libs : () ) );
    }
}

sub _win32_ext {

    require Text::ParseWords;

    my ( $self, $potential_libs, $verbose, $give_libs ) = @@_;
    $verbose ||= 0;

    # If user did not supply a list, we punt.
    # (caller should probably use the list in $Config{libs})
    return ( "", "", "", "", ( $give_libs ? [] : () ) ) unless $potential_libs;

    # TODO: make this use MM_Win32.pm's compiler detection
    my %libs_seen;
    my @@extralibs;
    my $cc = $Config{cc} || '';
    my $VC = $cc =~ /\bcl\b/i;
    my $GC = $cc =~ /\bgcc\b/i;

    my $libext     = _win32_lib_extensions();
    my @@searchpath = ( '' );                                    # from "-L/path" entries in $potential_libs
    my @@libpath    = _win32_default_search_paths( $VC, $GC );
    my $pwd        = cwd();                                     # from Cwd.pm
    my $search     = 1;

    # compute @@extralibs from $potential_libs
    my @@lib_search_list = _win32_make_lib_search_list( $potential_libs, $verbose );
    for ( @@lib_search_list ) {

        my $thislib = $_;

        # see if entry is a flag
        if ( /^:\w+$/ ) {
            $search = 0 if lc eq ':nosearch';
            $search = 1 if lc eq ':search';
            _debug( "Ignoring unknown flag '$thislib'\n", $verbose ) if !/^:(no)?(search|default)$/i;
            next;
        }

        # if searching is disabled, do compiler-specific translations
        unless ( $search ) {
            s/^-l(.+)$/$1.lib/ unless $GC;
            s/^-L/-libpath:/ if $VC;
            push( @@extralibs, $_ );
            next;
        }

        # handle possible linker path arguments
        if ( s/^-L// and not -d ) {
            _debug( "$thislib ignored, directory does not exist\n", $verbose );
            next;
        }
        elsif ( -d ) {
            unless ( File::Spec->file_name_is_absolute( $_ ) ) {
                warn "Warning: '$thislib' changed to '-L$pwd/$_'\n";
                $_ = $self->catdir( $pwd, $_ );
            }
            push( @@searchpath, $_ );
            next;
        }

        my @@paths = ( @@searchpath, @@libpath );
        my ( $fullname, $path ) = _win32_search_file( $thislib, $libext, \@@paths, $verbose, $GC );

        if ( !$fullname ) {
            warn "Warning (mostly harmless): No library found for $thislib\n";
            next;
        }

        _debug( "'$thislib' found as '$fullname'\n", $verbose );
        push( @@extralibs, $fullname );
        $libs_seen{$fullname} = 1 if $path;    # why is this a special case?
    }

    my @@libs = keys %libs_seen;

    return ( '', '', '', '', ( $give_libs ? \@@libs : () ) ) unless @@extralibs;

    # make sure paths with spaces are properly quoted
    @@extralibs = map { qq["$_"] } @@extralibs;
    @@libs      = map { qq["$_"] } @@libs;

    my $lib = join( ' ', @@extralibs );

    # normalize back to backward slashes (to help braindead tools)
    # XXX this may break equally braindead GNU tools that don't understand
    # backslashes, either.  Seems like one can't win here.  Cursed be CP/M.
    $lib =~ s,/,\\,g;

    _debug( "Result: $lib\n", $verbose );
    wantarray ? ( $lib, '', $lib, '', ( $give_libs ? \@@libs : () ) ) : $lib;
}

sub _win32_make_lib_search_list {
    my ( $potential_libs, $verbose ) = @@_;

    # If Config.pm defines a set of default libs, we always
    # tack them on to the user-supplied list, unless the user
    # specified :nodefault
    my $libs = $Config{'perllibs'};
    $potential_libs = join( ' ', $potential_libs, $libs ) if $libs and $potential_libs !~ /:nodefault/i;
    _debug( "Potential libraries are '$potential_libs':\n", $verbose );

    $potential_libs =~ s,\\,/,g;    # normalize to forward slashes

    my @@list = Text::ParseWords::quotewords( '\s+', 0, $potential_libs );

    return @@list;
}

sub _win32_default_search_paths {
    my ( $VC, $GC ) = @@_;

    my $libpth = $Config{'libpth'} || '';
    $libpth =~ s,\\,/,g;            # normalize to forward slashes

    my @@libpath = Text::ParseWords::quotewords( '\s+', 0, $libpth );
    push @@libpath, "$Config{installarchlib}/CORE";    # add "$Config{installarchlib}/CORE" to default search path

    push @@libpath, split /;/, $ENV{LIB}          if $VC and $ENV{LIB};
    push @@libpath, split /;/, $ENV{LIBRARY_PATH} if $GC and $ENV{LIBRARY_PATH};

    return @@libpath;
}

sub _win32_search_file {
    my ( $thislib, $libext, $paths, $verbose, $GC ) = @@_;

    my @@file_list = _win32_build_file_list( $thislib, $GC, $libext );

    for my $lib_file ( @@file_list ) {
        for my $path ( @@{$paths} ) {
            my $fullname = $lib_file;
            $fullname = "$path\\$fullname" if $path;

            return ( $fullname, $path ) if -f $fullname;

            _debug( "'$thislib' not found as '$fullname'\n", $verbose );
        }
    }

    return;
}

sub _win32_build_file_list {
    my ( $lib, $GC, $extensions ) = @@_;

    my @@pre_fixed = _win32_build_prefixed_list( $lib, $GC );
    return map _win32_attach_extensions( $_, $extensions ), @@pre_fixed;
}

sub _win32_build_prefixed_list {
    my ( $lib, $GC ) = @@_;

    return $lib if $lib !~ s/^-l//;
    return $lib if $lib =~ /^lib/ and !$GC;

    ( my $no_prefix = $lib ) =~ s/^lib//i;
    $lib = "lib$lib" if $no_prefix eq $lib;

    return ( $lib, $no_prefix ) if $GC;
    return ( $no_prefix, $lib );
}

sub _win32_attach_extensions {
    my ( $lib, $extensions ) = @@_;
    return map _win32_try_attach_extension( $lib, $_ ), @@{$extensions};
}

sub _win32_try_attach_extension {
    my ( $lib, $extension ) = @@_;

    return $lib if $lib =~ /\Q$extension\E$/i;
    return "$lib$extension";
}

sub _win32_lib_extensions {
    my @@extensions;
    push @@extensions, $Config{'lib_ext'} if $Config{'lib_ext'};
    push @@extensions, '.dll.a' if grep { m!^\.a$! } @@extensions;
    push @@extensions, '.lib' unless grep { m!^\.lib$! } @@extensions;
    return \@@extensions;
}

sub _debug {
    my ( $message, $verbose ) = @@_;
    return if !$verbose;
    warn $message;
    return;
}

sub _vms_ext {
    my ( $self, $potential_libs, $verbose, $give_libs ) = @@_;
    $verbose ||= 0;

    my ( @@crtls, $crtlstr );
    @@crtls = ( ( $Config{'ldflags'} =~ m-/Debug-i ? $Config{'dbgprefix'} : '' ) . 'PerlShr/Share' );
    push( @@crtls, grep { not /\(/ } split /\s+/, $Config{'perllibs'} );
    push( @@crtls, grep { not /\(/ } split /\s+/, $Config{'libc'} );

    # In general, we pass through the basic libraries from %Config unchanged.
    # The one exception is that if we're building in the Perl source tree, and
    # a library spec could be resolved via a logical name, we go to some trouble
    # to insure that the copy in the local tree is used, rather than one to
    # which a system-wide logical may point.
    if ( $self->{PERL_SRC} ) {
        my ( $locspec, $type );
        foreach my $lib ( @@crtls ) {
            if ( ( $locspec, $type ) = $lib =~ m{^([\w\$-]+)(/\w+)?} and $locspec =~ /perl/i ) {
                if    ( lc $type eq '/share' )   { $locspec .= $Config{'exe_ext'}; }
                elsif ( lc $type eq '/library' ) { $locspec .= $Config{'lib_ext'}; }
                else                             { $locspec .= $Config{'obj_ext'}; }
                $locspec = $self->catfile( $self->{PERL_SRC}, $locspec );
                $lib = "$locspec$type" if -e $locspec;
            }
        }
    }
    $crtlstr = @@crtls ? join( ' ', @@crtls ) : '';

    unless ( $potential_libs ) {
        warn "Result:\n\tEXTRALIBS: \n\tLDLOADLIBS: $crtlstr\n" if $verbose;
        return ( '', '', $crtlstr, '', ( $give_libs ? [] : () ) );
    }

    my ( %found, @@fndlibs, $ldlib );
    my $cwd = cwd();
    my ( $so, $lib_ext, $obj_ext ) = @@Config{ 'so', 'lib_ext', 'obj_ext' };

    # List of common Unix library names and their VMS equivalents
    # (VMS equivalent of '' indicates that the library is automatically
    # searched by the linker, and should be skipped here.)
    my ( @@flibs, %libs_seen );
    my %libmap = (
        'm'      => '',
        'f77'    => '',
        'F77'    => '',
        'V77'    => '',
        'c'      => '',
        'malloc' => '',
        'crypt'  => '',
        'resolv' => '',
        'c_s'    => '',
        'socket' => '',
        'X11'    => 'DECW$XLIBSHR',
        'Xt'     => 'DECW$XTSHR',
        'Xm'     => 'DECW$XMLIBSHR',
        'Xmu'    => 'DECW$XMULIBSHR'
    );

    warn "Potential libraries are '$potential_libs'\n" if $verbose;

    # First, sort out directories and library names in the input
    my ( @@dirs, @@libs );
    foreach my $lib ( split ' ', $potential_libs ) {
        push( @@dirs, $1 ),   next if $lib =~ /^-L(.*)/;
        push( @@dirs, $lib ), next if $lib =~ /[:>\]]$/;
        push( @@dirs, $lib ), next if -d $lib;
        push( @@libs, $1 ),   next if $lib =~ /^-l(.*)/;
        push( @@libs, $lib );
    }
    push( @@dirs, split( ' ', $Config{'libpth'} ) );

    # Now make sure we've got VMS-syntax absolute directory specs
    # (We don't, however, check whether someone's hidden a relative
    # path in a logical name.)
    foreach my $dir ( @@dirs ) {
        unless ( -d $dir ) {
            warn "Skipping nonexistent Directory $dir\n" if $verbose > 1;
            $dir = '';
            next;
        }
        warn "Resolving directory $dir\n" if $verbose;
        if ( File::Spec->file_name_is_absolute( $dir ) ) {
            $dir = VMS::Filespec::vmspath( $dir );
        }
        else {
            $dir = $self->catdir( $cwd, $dir );
        }
    }
    @@dirs = grep { length( $_ ) } @@dirs;
    unshift( @@dirs, '' );    # Check each $lib without additions first

  LIB: foreach my $lib ( @@libs ) {
        if ( exists $libmap{$lib} ) {
            next unless length $libmap{$lib};
            $lib = $libmap{$lib};
        }

        my ( @@variants, $cand );
        my ( $ctype ) = '';

        # If we don't have a file type, consider it a possibly abbreviated name and
        # check for common variants.  We try these first to grab libraries before
        # a like-named executable image (e.g. -lperl resolves to perlshr.exe
        # before perl.exe).
        if ( $lib !~ /\.[^:>\]]*$/ ) {
            push( @@variants, "${lib}shr", "${lib}rtl", "${lib}lib" );
            push( @@variants, "lib$lib" ) if $lib !~ /[:>\]]/;
        }
        push( @@variants, $lib );
        warn "Looking for $lib\n" if $verbose;
        foreach my $variant ( @@variants ) {
            my ( $fullname, $name );

            foreach my $dir ( @@dirs ) {
                my ( $type );

                $name = "$dir$variant";
                warn "\tChecking $name\n" if $verbose > 2;
                $fullname = VMS::Filespec::rmsexpand( $name );
                if ( defined $fullname and -f $fullname ) {

                    # It's got its own suffix, so we'll have to figure out the type
                    if    ( $fullname =~ /(?:$so|exe)$/i )      { $type = 'SHR'; }
                    elsif ( $fullname =~ /(?:$lib_ext|olb)$/i ) { $type = 'OLB'; }
                    elsif ( $fullname =~ /(?:$obj_ext|obj)$/i ) {
                        warn "Warning (mostly harmless): " . "Plain object file $fullname found in library list\n";
                        $type = 'OBJ';
                    }
                    else {
                        warn "Warning (mostly harmless): " . "Unknown library type for $fullname; assuming shared\n";
                        $type = 'SHR';
                    }
                }
                elsif (-f ( $fullname = VMS::Filespec::rmsexpand( $name, $so ) )
                    or -f ( $fullname = VMS::Filespec::rmsexpand( $name, '.exe' ) ) )
                {
                    $type = 'SHR';
                    $name = $fullname unless $fullname =~ /exe;?\d*$/i;
                }
                elsif (
                    not length( $ctype ) and    # If we've got a lib already,
                                                # don't bother
                    ( -f ( $fullname = VMS::Filespec::rmsexpand( $name, $lib_ext ) ) or -f ( $fullname = VMS::Filespec::rmsexpand( $name, '.olb' ) ) )
                  )
                {
                    $type = 'OLB';
                    $name = $fullname unless $fullname =~ /olb;?\d*$/i;
                }
                elsif (
                    not length( $ctype ) and    # If we've got a lib already,
                                                # don't bother
                    ( -f ( $fullname = VMS::Filespec::rmsexpand( $name, $obj_ext ) ) or -f ( $fullname = VMS::Filespec::rmsexpand( $name, '.obj' ) ) )
                  )
                {
                    warn "Warning (mostly harmless): " . "Plain object file $fullname found in library list\n";
                    $type = 'OBJ';
                    $name = $fullname unless $fullname =~ /obj;?\d*$/i;
                }
                if ( defined $type ) {
                    $ctype = $type;
                    $cand  = $name;
                    last if $ctype eq 'SHR';
                }
            }
            if ( $ctype ) {

                push @@{ $found{$ctype} }, $cand;
                warn "\tFound as $cand (really $fullname), type $ctype\n"
                  if $verbose > 1;
                push @@flibs, $name unless $libs_seen{$fullname}++;
                next LIB;
            }
        }
        warn "Warning (mostly harmless): " . "No library found for $lib\n";
    }

    push @@fndlibs, @@{ $found{OBJ} } if exists $found{OBJ};
    push @@fndlibs, map { "$_/Library" } @@{ $found{OLB} } if exists $found{OLB};
    push @@fndlibs, map { "$_/Share" } @@{ $found{SHR} }   if exists $found{SHR};
    my $lib = join( ' ', @@fndlibs );

    $ldlib = $crtlstr ? "$lib $crtlstr" : $lib;
    $ldlib =~ s/^\s+|\s+$//g;
    warn "Result:\n\tEXTRALIBS: $lib\n\tLDLOADLIBS: $ldlib\n" if $verbose;
    wantarray ? ( $lib, '', $ldlib, '', ( $give_libs ? \@@flibs : () ) ) : $lib;
}

1;
@


1.2
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.


ok deraadt@@
@
text
@d14 1
a14 1
our $VERSION = '6.98_01';
d52 1
a52 1
    my ( @@libpath ) = split " ", $Config{'libpth'};
d60 1
d96 8
a103 1
        unless ( $thislib =~ s/^-l// ) {
d117 4
a120 2
            if ( @@fullname = $self->lsdir( $thispth, "^\Qlib$thislib.$so.\E[0-9]+" ) ) {

d189 2
d204 1
a204 1
            my $in_perl = ( $libs =~ /\B-l\Q${thislib}\E\b/s );
d224 1
a224 1
                push( @@extralibs, "-l$thislib" );
d246 1
a246 1
                    push( @@ldloadlibs, "-l$thislib" )
d250 1
a250 1
                    push( @@ldloadlibs, "-l$thislib" );
d345 2
a346 2
    @@extralibs = map { /\s/ ? qq["$_"] : $_ } @@extralibs;
    @@libs      = map { /\s/ ? qq["$_"] : $_ } @@libs;
a513 1
    if ( $Config{'vms_cc_type'} ne 'decc' ) { $libmap{'curses'} = 'VAXCCURSE'; }
d539 1
a539 1
            $dir = $self->fixpath( $dir, 1 );
d623 1
a623 3
                # This has to precede any other CRTLs, so just make it first
                if ( $cand eq 'VAXCCURSE' ) { unshift @@{ $found{$ctype} }, $cand; }
                else                        { push @@{ $found{$ctype} }, $cand; }
d639 1
@


1.1
log
@Initial revision
@
text
@d9 1
d13 2
a14 1
our $VERSION = 6.56;
d16 1
a16 1
use Config;
d22 3
a24 3
  if   ($^O eq 'VMS')     { return &_vms_ext;      }
  elsif($^O eq 'MSWin32') { return &_win32_ext;    }
  else                    { return &_unix_os2_ext; }
d28 1
a28 1
    my($self,$potential_libs, $verbose, $give_libs) = @@_;
d31 4
a34 3
    if ($^O =~ 'os2' and $Config{perllibs}) { 
	# Dynamic libraries are not transitive, so we may need including
	# the libraries linked against perl.dll again.
d36 2
a37 2
	$potential_libs .= " " if $potential_libs;
	$potential_libs .= $Config{perllibs};
d39 1
a39 1
    return ("", "", "", "", ($give_libs ? [] : ())) unless $potential_libs;
d42 2
a43 2
    my($so)   = $Config{so};
    my($libs) = defined $Config{perllibs} ? $Config{perllibs} : $Config{libs};
d45 1
a45 1

d51 142
a192 113
    my(@@searchpath); # from "-L/path" entries in $potential_libs
    my(@@libpath) = split " ", $Config{'libpth'};
    my(@@ldloadlibs, @@bsloadlibs, @@extralibs, @@ld_run_path, %ld_run_path_seen);
    my(@@libs, %libs_seen);
    my($fullname, @@fullname);
    my($pwd) = cwd(); # from Cwd.pm
    my($found) = 0;

    foreach my $thislib (split ' ', $potential_libs) {

	# Handle possible linker path arguments.
	if ($thislib =~ s/^(-[LR]|-Wl,-R)//){	# save path flag type
	    my($ptype) = $1;
	    unless (-d $thislib){
		warn "$ptype$thislib ignored, directory does not exist\n"
			if $verbose;
		next;
	    }
	    my($rtype) = $ptype;
	    if (($ptype eq '-R') or ($ptype eq '-Wl,-R')) {
		if ($Config{'lddlflags'} =~ /-Wl,-R/) {
		    $rtype = '-Wl,-R';
		} elsif ($Config{'lddlflags'} =~ /-R/) {
		    $rtype = '-R';
		}
	    }
	    unless (File::Spec->file_name_is_absolute($thislib)) {
	      warn "Warning: $ptype$thislib changed to $ptype$pwd/$thislib\n";
	      $thislib = $self->catdir($pwd,$thislib);
	    }
	    push(@@searchpath, $thislib);
	    push(@@extralibs,  "$ptype$thislib");
	    push(@@ldloadlibs, "$rtype$thislib");
	    next;
	}

	# Handle possible library arguments.
	unless ($thislib =~ s/^-l//){
	  warn "Unrecognized argument in LIBS ignored: '$thislib'\n";
	  next;
	}

	my($found_lib)=0;
	foreach my $thispth (@@searchpath, @@libpath) {

		# Try to find the full name of the library.  We need this to
		# determine whether it's a dynamically-loadable library or not.
		# This tends to be subject to various os-specific quirks.
		# For gcc-2.6.2 on linux (March 1995), DLD can not load
		# .sa libraries, with the exception of libm.sa, so we
		# deliberately skip them.
	    if (@@fullname =
		    $self->lsdir($thispth,"^\Qlib$thislib.$so.\E[0-9]+")){
		# Take care that libfoo.so.10 wins against libfoo.so.9.
		# Compare two libraries to find the most recent version
		# number.  E.g.  if you have libfoo.so.9.0.7 and
		# libfoo.so.10.1, first convert all digits into two
		# decimal places.  Then we'll add ".00" to the shorter
		# strings so that we're comparing strings of equal length
		# Thus we'll compare libfoo.so.09.07.00 with
		# libfoo.so.10.01.00.  Some libraries might have letters
		# in the version.  We don't know what they mean, but will
		# try to skip them gracefully -- we'll set any letter to
		# '0'.  Finally, sort in reverse so we can take the
		# first element.

		#TODO: iterate through the directory instead of sorting

		$fullname = "$thispth/" .
		(sort { my($ma) = $a;
			my($mb) = $b;
			$ma =~ tr/A-Za-z/0/s;
			$ma =~ s/\b(\d)\b/0$1/g;
			$mb =~ tr/A-Za-z/0/s;
			$mb =~ s/\b(\d)\b/0$1/g;
			while (length($ma) < length($mb)) { $ma .= ".00"; }
			while (length($mb) < length($ma)) { $mb .= ".00"; }
			# Comparison deliberately backwards
			$mb cmp $ma;} @@fullname)[0];
	    } elsif (-f ($fullname="$thispth/lib$thislib.$so")
		 && (($Config{'dlsrc'} ne "dl_dld.xs") || ($thislib eq "m"))){
	    } elsif (-f ($fullname="$thispth/lib${thislib}_s$Config_libext")
                 && ($Config{'archname'} !~ /RM\d\d\d-svr4/)
		 && ($thislib .= "_s") ){ # we must explicitly use _s version
	    } elsif (-f ($fullname="$thispth/lib$thislib$Config_libext")){
	    } elsif (-f ($fullname="$thispth/$thislib$Config_libext")){
            } elsif (-f ($fullname="$thispth/lib$thislib.dll$Config_libext")){
	    } elsif (-f ($fullname="$thispth/Slib$thislib$Config_libext")){
	    } elsif ($^O eq 'dgux'
		 && -l ($fullname="$thispth/lib$thislib$Config_libext")
		 && readlink($fullname) =~ /^elink:/s) {
		 # Some of DG's libraries look like misconnected symbolic
		 # links, but development tools can follow them.  (They
		 # look like this:
		 #
		 #    libm.a -> elink:${SDE_PATH:-/usr}/sde/\
		 #    ${TARGET_BINARY_INTERFACE:-m88kdgux}/usr/lib/libm.a
		 #
		 # , the compilation tools expand the environment variables.)
	    } else {
		warn "$thislib not found in $thispth\n" if $verbose;
		next;
	    }
	    warn "'-l$thislib' found at $fullname\n" if $verbose;
	    push @@libs, $fullname unless $libs_seen{$fullname}++;
	    $found++;
	    $found_lib++;

	    # Now update library lists

	    # what do we know about this library...
	    my $is_dyna = ($fullname !~ /\Q$Config_libext\E\z/);
	    my $in_perl = ($libs =~ /\B-l\Q${thislib}\E\b/s);
d196 1
a196 1
            my($fullnamedir) = dirname($fullname);
d198 33
a230 2
                 if $is_dyna && !$in_perl &&
                    !$ld_run_path_seen{$fullnamedir}++;
a231 24
	    # Do not add it into the list if it is already linked in
	    # with the main perl executable.
	    # We have to special-case the NeXT, because math and ndbm 
	    # are both in libsys_s
	    unless ($in_perl || 
		($Config{'osname'} eq 'next' &&
		    ($thislib eq 'm' || $thislib eq 'ndbm')) ){
		push(@@extralibs, "-l$thislib");
	    }

	    # We might be able to load this archive file dynamically
	    if ( ($Config{'dlsrc'} =~ /dl_next/ && $Config{'osvers'} lt '4_0')
	    ||   ($Config{'dlsrc'} =~ /dl_dld/) )
	    {
		# We push -l$thislib instead of $fullname because
		# it avoids hardwiring a fixed path into the .bs file.
		# Mkbootstrap will automatically add dl_findfile() to
		# the .bs file if it sees a name in the -l format.
		# USE THIS, when dl_findfile() is fixed: 
		# push(@@bsloadlibs, "-l$thislib");
		# OLD USE WAS while checking results against old_extliblist
		push(@@bsloadlibs, "$fullname");
	    } else {
		if ($is_dyna){
d234 11
a244 11
		    push(@@ldloadlibs, "-l$thislib")
			unless ($in_perl and $^O eq 'sunos');
		} else {
		    push(@@ldloadlibs, "-l$thislib");
		}
	    }
	    last;	# found one here so don't bother looking further
	}
	warn "Note (probably harmless): "
		     ."No library found for -l$thislib\n"
	    unless $found_lib>0;
d247 2
a248 2
    unless( $found ) {
        return ('','','','', ($give_libs ? \@@libs : ()));
d251 1
a251 2
        return ("@@extralibs", "@@bsloadlibs", "@@ldloadlibs",
                join(":",@@ld_run_path), ($give_libs ? \@@libs : ()));
d259 1
a259 1
    my($self, $potential_libs, $verbose, $give_libs) = @@_;
d264 1
a264 1
    return ("", "", "", "", ($give_libs ? [] : ())) unless $potential_libs;
d266 16
a281 14
    my $cc		= $Config{cc};
    my $VC		= $cc =~ /^cl/i;
    my $BC		= $cc =~ /^bcc/i;
    my $GC		= $cc =~ /^gcc/i;
    my $so		= $Config{'so'};
    my $libs		= $Config{'perllibs'};
    my $libpth		= $Config{'libpth'};
    my $libext		= $Config{'lib_ext'} || ".lib";
    my(@@libs, %libs_seen);

    if ($libs and $potential_libs !~ /:nodefault/i) { 
	# If Config.pm defines a set of default libs, we always
	# tack them on to the user-supplied list, unless the user
	# specified :nodefault
d283 1
a283 4
	$potential_libs .= " " if $potential_libs;
	$potential_libs .= $libs;
    }
    warn "Potential libraries are '$potential_libs':\n" if $verbose;
d285 7
a291 3
    # normalize to forward slashes
    $libpth =~ s,\\,/,g;
    $potential_libs =~ s,\\,/,g;
d293 7
a299 1
    # compute $extralibs from $potential_libs
d301 13
a313 8
    my @@searchpath;		    # from "-L/path" in $potential_libs
    my @@libpath		= Text::ParseWords::quotewords('\s+', 0, $libpth);
    my @@extralibs;
    my $pwd		= cwd();    # from Cwd.pm
    my $lib		= '';
    my $found		= 0;
    my $search		= 1;
    my($fullname);
d315 2
a316 2
    # add "$Config{installarchlib}/CORE" to default search path
    push @@libpath, "$Config{installarchlib}/CORE";
d318 8
a325 2
    if ($VC and exists $ENV{LIB} and $ENV{LIB}) {
        push @@libpath, split /;/, $ENV{LIB};
d328 1
a328 1
    foreach (Text::ParseWords::quotewords('\s+', 0, $potential_libs)){
d330 1
a330 1
	my $thislib = $_;
d332 3
a334 81
        # see if entry is a flag
	if (/^:\w+$/) {
	    $search	= 0 if lc eq ':nosearch';
	    $search	= 1 if lc eq ':search';
	    warn "Ignoring unknown flag '$thislib'\n"
		if $verbose and !/^:(no)?(search|default)$/i;
	    next;
	}

	# if searching is disabled, do compiler-specific translations
	unless ($search) {
	    s/^-l(.+)$/$1.lib/ unless $GC;
	    s/^-L/-libpath:/ if $VC;
	    push(@@extralibs, $_);
	    $found++;
	    next;
	}

	# handle possible linker path arguments
	if (s/^-L// and not -d) {
	    warn "$thislib ignored, directory does not exist\n"
		if $verbose;
	    next;
	}
	elsif (-d) {
	    unless (File::Spec->file_name_is_absolute($_)) {
	      warn "Warning: '$thislib' changed to '-L$pwd/$_'\n";
	      $_ = $self->catdir($pwd,$_);
	    }
	    push(@@searchpath, $_);
	    next;
	}

	# handle possible library arguments
	if (s/^-l// and $GC and !/^lib/i) {
	    $_ = "lib$_";
	}
	$_ .= $libext if !/\Q$libext\E$/i;

	my $secondpass = 0;
    LOOKAGAIN:

        # look for the file itself
	if (-f) {
	    warn "'$thislib' found as '$_'\n" if $verbose;
	    $found++;
	    push(@@extralibs, $_);
	    next;
	}

	my $found_lib = 0;
	foreach my $thispth (@@searchpath, @@libpath){
	    unless (-f ($fullname="$thispth\\$_")) {
		warn "'$thislib' not found as '$fullname'\n" if $verbose;
		next;
	    }
	    warn "'$thislib' found as '$fullname'\n" if $verbose;
	    $found++;
	    $found_lib++;
	    push(@@extralibs, $fullname);
	    push @@libs, $fullname unless $libs_seen{$fullname}++;
	    last;
	}

	# do another pass with (or without) leading 'lib' if they used -l
	if (!$found_lib and $thislib =~ /^-l/ and !$secondpass++) {
	    if ($GC) {
		goto LOOKAGAIN if s/^lib//i;
	    }
	    elsif (!/^lib/i) {
		$_ = "lib$_";
		goto LOOKAGAIN;
	    }
	}

	# give up
	warn "Note (probably harmless): "
		     ."No library found for $thislib\n"
	    unless $found_lib>0;

    }
d336 1
a336 6
    return ('','','','', ($give_libs ? \@@libs : ())) unless $found;

    # make sure paths with spaces are properly quoted
    @@extralibs = map { (/\s/ && !/^".*"$/) ? qq["$_"] : $_ } @@extralibs;
    @@libs = map { (/\s/ && !/^".*"$/) ? qq["$_"] : $_ } @@libs;
    $lib = join(' ',@@extralibs);
d343 60
a402 2
    warn "Result: $lib\n" if $verbose;
    wantarray ? ($lib, '', $lib, '', ($give_libs ? \@@libs : ())) : $lib;
d405 39
d446 182
a627 2
  my($self, $potential_libs, $verbose, $give_libs) = @@_;
  $verbose ||= 0;
d629 3
a631 167
  my(@@crtls,$crtlstr);
  @@crtls = ( ($Config{'ldflags'} =~ m-/Debug-i ? $Config{'dbgprefix'} : '')
              . 'PerlShr/Share' );
  push(@@crtls, grep { not /\(/ } split /\s+/, $Config{'perllibs'});
  push(@@crtls, grep { not /\(/ } split /\s+/, $Config{'libc'});
  # In general, we pass through the basic libraries from %Config unchanged.
  # The one exception is that if we're building in the Perl source tree, and
  # a library spec could be resolved via a logical name, we go to some trouble
  # to insure that the copy in the local tree is used, rather than one to
  # which a system-wide logical may point.
  if ($self->{PERL_SRC}) {
    my($locspec,$type);
    foreach my $lib (@@crtls) { 
      if (($locspec,$type) = $lib =~ m{^([\w\$-]+)(/\w+)?} and $locspec =~ /perl/i) {
        if    (lc $type eq '/share')   { $locspec .= $Config{'exe_ext'}; }
        elsif (lc $type eq '/library') { $locspec .= $Config{'lib_ext'}; }
        else                           { $locspec .= $Config{'obj_ext'}; }
        $locspec = $self->catfile($self->{PERL_SRC},$locspec);
        $lib = "$locspec$type" if -e $locspec;
      }
    }
  }
  $crtlstr = @@crtls ? join(' ',@@crtls) : '';

  unless ($potential_libs) {
    warn "Result:\n\tEXTRALIBS: \n\tLDLOADLIBS: $crtlstr\n" if $verbose;
    return ('', '', $crtlstr, '', ($give_libs ? [] : ()));
  }

  my(%found,@@fndlibs,$ldlib);
  my $cwd = cwd();
  my($so,$lib_ext,$obj_ext) = @@Config{'so','lib_ext','obj_ext'};
  # List of common Unix library names and their VMS equivalents
  # (VMS equivalent of '' indicates that the library is automatically
  # searched by the linker, and should be skipped here.)
  my(@@flibs, %libs_seen);
  my %libmap = ( 'm' => '', 'f77' => '', 'F77' => '', 'V77' => '', 'c' => '',
                 'malloc' => '', 'crypt' => '', 'resolv' => '', 'c_s' => '',
                 'socket' => '', 'X11' => 'DECW$XLIBSHR',
                 'Xt' => 'DECW$XTSHR', 'Xm' => 'DECW$XMLIBSHR',
                 'Xmu' => 'DECW$XMULIBSHR');
  if ($Config{'vms_cc_type'} ne 'decc') { $libmap{'curses'} = 'VAXCCURSE'; }

  warn "Potential libraries are '$potential_libs'\n" if $verbose;

  # First, sort out directories and library names in the input
  my(@@dirs, @@libs);
  foreach my $lib (split ' ',$potential_libs) {
    push(@@dirs,$1),   next if $lib =~ /^-L(.*)/;
    push(@@dirs,$lib), next if $lib =~ /[:>\]]$/;
    push(@@dirs,$lib), next if -d $lib;
    push(@@libs,$1),   next if $lib =~ /^-l(.*)/;
    push(@@libs,$lib);
  }
  push(@@dirs,split(' ',$Config{'libpth'}));

  # Now make sure we've got VMS-syntax absolute directory specs
  # (We don't, however, check whether someone's hidden a relative
  # path in a logical name.)
  foreach my $dir (@@dirs) {
    unless (-d $dir) {
      warn "Skipping nonexistent Directory $dir\n" if $verbose > 1;
      $dir = '';
      next;
    }
    warn "Resolving directory $dir\n" if $verbose;
    if (File::Spec->file_name_is_absolute($dir)) { 
        $dir = $self->fixpath($dir,1); 
    }
    else { 
        $dir = $self->catdir($cwd,$dir); 
    }
  }
  @@dirs = grep { length($_) } @@dirs;
  unshift(@@dirs,''); # Check each $lib without additions first

  LIB: foreach my $lib (@@libs) {
    if (exists $libmap{$lib}) {
      next unless length $libmap{$lib};
      $lib = $libmap{$lib};
    }

    my(@@variants,$cand);
    my($ctype) = '';

    # If we don't have a file type, consider it a possibly abbreviated name and
    # check for common variants.  We try these first to grab libraries before
    # a like-named executable image (e.g. -lperl resolves to perlshr.exe
    # before perl.exe).
    if ($lib !~ /\.[^:>\]]*$/) {
      push(@@variants,"${lib}shr","${lib}rtl","${lib}lib");
      push(@@variants,"lib$lib") if $lib !~ /[:>\]]/;
    }
    push(@@variants,$lib);
    warn "Looking for $lib\n" if $verbose;
    foreach my $variant (@@variants) {
      my($fullname, $name);

      foreach my $dir (@@dirs) {
        my($type);

        $name = "$dir$variant";
        warn "\tChecking $name\n" if $verbose > 2;
        $fullname = VMS::Filespec::rmsexpand($name);
        if (defined $fullname and -f $fullname) {
          # It's got its own suffix, so we'll have to figure out the type
          if    ($fullname =~ /(?:$so|exe)$/i)      { $type = 'SHR'; }
          elsif ($fullname =~ /(?:$lib_ext|olb)$/i) { $type = 'OLB'; }
          elsif ($fullname =~ /(?:$obj_ext|obj)$/i) {
            warn "Note (probably harmless): "
                ."Plain object file $fullname found in library list\n";
            $type = 'OBJ';
          }
          else {
            warn "Note (probably harmless): "
                ."Unknown library type for $fullname; assuming shared\n";
            $type = 'SHR';
          }
        }
        elsif (-f ($fullname = VMS::Filespec::rmsexpand($name,$so))      or
               -f ($fullname = VMS::Filespec::rmsexpand($name,'.exe')))     {
          $type = 'SHR';
          $name = $fullname unless $fullname =~ /exe;?\d*$/i;
        }
        elsif (not length($ctype) and  # If we've got a lib already, 
                                       # don't bother
               ( -f ($fullname = VMS::Filespec::rmsexpand($name,$lib_ext)) or
                 -f ($fullname = VMS::Filespec::rmsexpand($name,'.olb'))))  {
          $type = 'OLB';
          $name = $fullname unless $fullname =~ /olb;?\d*$/i;
        }
        elsif (not length($ctype) and  # If we've got a lib already, 
                                       # don't bother
               ( -f ($fullname = VMS::Filespec::rmsexpand($name,$obj_ext)) or
                 -f ($fullname = VMS::Filespec::rmsexpand($name,'.obj'))))  {
          warn "Note (probably harmless): "
		       ."Plain object file $fullname found in library list\n";
          $type = 'OBJ';
          $name = $fullname unless $fullname =~ /obj;?\d*$/i;
        }
        if (defined $type) {
          $ctype = $type; $cand = $name;
          last if $ctype eq 'SHR';
        }
      }
      if ($ctype) { 
        # This has to precede any other CRTLs, so just make it first
        if ($cand eq 'VAXCCURSE') { unshift @@{$found{$ctype}}, $cand; }  
        else                      { push    @@{$found{$ctype}}, $cand; }
        warn "\tFound as $cand (really $fullname), type $ctype\n" 
          if $verbose > 1;
	push @@flibs, $name unless $libs_seen{$fullname}++;
        next LIB;
      }
    }
    warn "Note (probably harmless): "
		 ."No library found for $lib\n";
  }

  push @@fndlibs, @@{$found{OBJ}}                      if exists $found{OBJ};
  push @@fndlibs, map { "$_/Library" } @@{$found{OLB}} if exists $found{OLB};
  push @@fndlibs, map { "$_/Share"   } @@{$found{SHR}} if exists $found{SHR};
  my $lib = join(' ',@@fndlibs);

  $ldlib = $crtlstr ? "$lib $crtlstr" : $lib;
  warn "Result:\n\tEXTRALIBS: $lib\n\tLDLOADLIBS: $ldlib\n" if $verbose;
  wantarray ? ($lib, '', $ldlib, '', ($give_libs ? \@@flibs : ())) : $lib;
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a8 1

d12 1
a12 2
use warnings;
our $VERSION = '6.63_02';
d14 1
a14 1
use ExtUtils::MakeMaker::Config;
d20 3
a22 3
    if    ( $^O eq 'VMS' )     { return &_vms_ext; }
    elsif ( $^O eq 'MSWin32' ) { return &_win32_ext; }
    else                       { return &_unix_os2_ext; }
d26 1
a26 1
    my ( $self, $potential_libs, $verbose, $give_libs ) = @@_;
d29 3
a31 4
    if ( $^O =~ 'os2' and $Config{perllibs} ) {

        # Dynamic libraries are not transitive, so we may need including
        # the libraries linked against perl.dll again.
d33 2
a34 2
        $potential_libs .= " " if $potential_libs;
        $potential_libs .= $Config{perllibs};
d36 1
a36 1
    return ( "", "", "", "", ( $give_libs ? [] : () ) ) unless $potential_libs;
d39 2
a40 2
    my ( $so ) = $Config{so};
    my ( $libs ) = defined $Config{perllibs} ? $Config{perllibs} : $Config{libs};
d42 1
a42 1
    my $Config_dlext = $Config{dlext};
d48 113
a160 134
    my ( @@searchpath );    # from "-L/path" entries in $potential_libs
    my ( @@libpath ) = split " ", $Config{'libpth'};
    my ( @@ldloadlibs, @@bsloadlibs, @@extralibs, @@ld_run_path, %ld_run_path_seen );
    my ( @@libs,       %libs_seen );
    my ( $fullname,   @@fullname );
    my ( $pwd )   = cwd();    # from Cwd.pm
    my ( $found ) = 0;

    foreach my $thislib ( split ' ', $potential_libs ) {

        # Handle possible linker path arguments.
        if ( $thislib =~ s/^(-[LR]|-Wl,-R)// ) {    # save path flag type
            my ( $ptype ) = $1;
            unless ( -d $thislib ) {
                warn "$ptype$thislib ignored, directory does not exist\n"
                  if $verbose;
                next;
            }
            my ( $rtype ) = $ptype;
            if ( ( $ptype eq '-R' ) or ( $ptype eq '-Wl,-R' ) ) {
                if ( $Config{'lddlflags'} =~ /-Wl,-R/ ) {
                    $rtype = '-Wl,-R';
                }
                elsif ( $Config{'lddlflags'} =~ /-R/ ) {
                    $rtype = '-R';
                }
            }
            unless ( File::Spec->file_name_is_absolute( $thislib ) ) {
                warn "Warning: $ptype$thislib changed to $ptype$pwd/$thislib\n";
                $thislib = $self->catdir( $pwd, $thislib );
            }
            push( @@searchpath, $thislib );
            push( @@extralibs,  "$ptype$thislib" );
            push( @@ldloadlibs, "$rtype$thislib" );
            next;
        }

        # Handle possible library arguments.
        unless ( $thislib =~ s/^-l// ) {
            warn "Unrecognized argument in LIBS ignored: '$thislib'\n";
            next;
        }

        my ( $found_lib ) = 0;
        foreach my $thispth ( @@searchpath, @@libpath ) {

            # Try to find the full name of the library.  We need this to
            # determine whether it's a dynamically-loadable library or not.
            # This tends to be subject to various os-specific quirks.
            # For gcc-2.6.2 on linux (March 1995), DLD can not load
            # .sa libraries, with the exception of libm.sa, so we
            # deliberately skip them.
            if ( @@fullname = $self->lsdir( $thispth, "^\Qlib$thislib.$so.\E[0-9]+" ) ) {

                # Take care that libfoo.so.10 wins against libfoo.so.9.
                # Compare two libraries to find the most recent version
                # number.  E.g.  if you have libfoo.so.9.0.7 and
                # libfoo.so.10.1, first convert all digits into two
                # decimal places.  Then we'll add ".00" to the shorter
                # strings so that we're comparing strings of equal length
                # Thus we'll compare libfoo.so.09.07.00 with
                # libfoo.so.10.01.00.  Some libraries might have letters
                # in the version.  We don't know what they mean, but will
                # try to skip them gracefully -- we'll set any letter to
                # '0'.  Finally, sort in reverse so we can take the
                # first element.

                #TODO: iterate through the directory instead of sorting

                $fullname = "$thispth/" . (
                    sort {
                        my ( $ma ) = $a;
                        my ( $mb ) = $b;
                        $ma =~ tr/A-Za-z/0/s;
                        $ma =~ s/\b(\d)\b/0$1/g;
                        $mb =~ tr/A-Za-z/0/s;
                        $mb =~ s/\b(\d)\b/0$1/g;
                        while ( length( $ma ) < length( $mb ) ) { $ma .= ".00"; }
                        while ( length( $mb ) < length( $ma ) ) { $mb .= ".00"; }

                        # Comparison deliberately backwards
                        $mb cmp $ma;
                      } @@fullname
                )[0];
            }
            elsif ( -f ( $fullname = "$thispth/lib$thislib.$so" )
                && ( ( $Config{'dlsrc'} ne "dl_dld.xs" ) || ( $thislib eq "m" ) ) )
            {
            }
            elsif (-f ( $fullname = "$thispth/lib${thislib}_s$Config_libext" )
                && ( $Config{'archname'} !~ /RM\d\d\d-svr4/ )
                && ( $thislib .= "_s" ) )
            {    # we must explicitly use _s version
            }
            elsif ( -f ( $fullname = "$thispth/lib$thislib$Config_libext" ) ) {
            }
            elsif ( defined( $Config_dlext )
                && -f ( $fullname = "$thispth/lib$thislib.$Config_dlext" ) )
            {
            }
            elsif ( -f ( $fullname = "$thispth/$thislib$Config_libext" ) ) {
            }
            elsif ( -f ( $fullname = "$thispth/lib$thislib.dll$Config_libext" ) ) {
            }
            elsif ( -f ( $fullname = "$thispth/Slib$thislib$Config_libext" ) ) {
            }
            elsif ($^O eq 'dgux'
                && -l ( $fullname = "$thispth/lib$thislib$Config_libext" )
                && readlink( $fullname ) =~ /^elink:/s )
            {

                # Some of DG's libraries look like misconnected symbolic
                # links, but development tools can follow them.  (They
                # look like this:
                #
                #    libm.a -> elink:${SDE_PATH:-/usr}/sde/\
                #    ${TARGET_BINARY_INTERFACE:-m88kdgux}/usr/lib/libm.a
                #
                # , the compilation tools expand the environment variables.)
            }
            else {
                warn "$thislib not found in $thispth\n" if $verbose;
                next;
            }
            warn "'-l$thislib' found at $fullname\n" if $verbose;
            push @@libs, $fullname unless $libs_seen{$fullname}++;
            $found++;
            $found_lib++;

            # Now update library lists

            # what do we know about this library...
            my $is_dyna = ( $fullname !~ /\Q$Config_libext\E\z/ );
            my $in_perl = ( $libs =~ /\B-l\Q${thislib}\E\b/s );
d164 1
a164 1
            my ( $fullnamedir ) = dirname( $fullname );
d166 2
a167 33
              if $is_dyna
                  && !$in_perl
                  && !$ld_run_path_seen{$fullnamedir}++;

            # Do not add it into the list if it is already linked in
            # with the main perl executable.
            # We have to special-case the NeXT, because math and ndbm
            # are both in libsys_s
            unless (
                $in_perl
                || ( $Config{'osname'} eq 'next'
                    && ( $thislib eq 'm' || $thislib eq 'ndbm' ) )
              )
            {
                push( @@extralibs, "-l$thislib" );
            }

            # We might be able to load this archive file dynamically
            if (   ( $Config{'dlsrc'} =~ /dl_next/ && $Config{'osvers'} lt '4_0' )
                || ( $Config{'dlsrc'} =~ /dl_dld/ ) )
            {

                # We push -l$thislib instead of $fullname because
                # it avoids hardwiring a fixed path into the .bs file.
                # Mkbootstrap will automatically add dl_findfile() to
                # the .bs file if it sees a name in the -l format.
                # USE THIS, when dl_findfile() is fixed:
                # push(@@bsloadlibs, "-l$thislib");
                # OLD USE WAS while checking results against old_extliblist
                push( @@bsloadlibs, "$fullname" );
            }
            else {
                if ( $is_dyna ) {
d169 24
d195 11
a205 11
                    push( @@ldloadlibs, "-l$thislib" )
                      unless ( $in_perl and $^O eq 'sunos' );
                }
                else {
                    push( @@ldloadlibs, "-l$thislib" );
                }
            }
            last;    # found one here so don't bother looking further
        }
        warn "Note (probably harmless): " . "No library found for -l$thislib\n"
          unless $found_lib > 0;
d208 2
a209 2
    unless ( $found ) {
        return ( '', '', '', '', ( $give_libs ? \@@libs : () ) );
d212 2
a213 1
        return ( "@@extralibs", "@@bsloadlibs", "@@ldloadlibs", join( ":", @@ld_run_path ), ( $give_libs ? \@@libs : () ) );
d221 1
a221 1
    my ( $self, $potential_libs, $verbose, $give_libs ) = @@_;
d226 16
a241 1
    return ( "", "", "", "", ( $give_libs ? [] : () ) ) unless $potential_libs;
d243 13
a255 2
    # TODO: make this use MM_Win32.pm's compiler detection
    my %libs_seen;
d257 5
a261 13
    my $cc = $Config{cc} || '';
    my $VC = $cc =~ /\bcl\b/i;
    my $GC = $cc =~ /\bgcc\b/i;

    my $libext     = _win32_lib_extensions();
    my @@searchpath = ( '' );                                    # from "-L/path" entries in $potential_libs
    my @@libpath    = _win32_default_search_paths( $VC, $GC );
    my $pwd        = cwd();                                     # from Cwd.pm
    my $search     = 1;

    # compute @@extralibs from $potential_libs
    my @@lib_search_list = _win32_make_lib_search_list( $potential_libs, $verbose );
    for ( @@lib_search_list ) {
d263 2
a264 1
        my $thislib = $_;
d266 3
a268 15
        # see if entry is a flag
        if ( /^:\w+$/ ) {
            $search = 0 if lc eq ':nosearch';
            $search = 1 if lc eq ':search';
            _debug( "Ignoring unknown flag '$thislib'\n", $verbose ) if !/^:(no)?(search|default)$/i;
            next;
        }

        # if searching is disabled, do compiler-specific translations
        unless ( $search ) {
            s/^-l(.+)$/$1.lib/ unless $GC;
            s/^-L/-libpath:/ if $VC;
            push( @@extralibs, $_ );
            next;
        }
d270 1
a270 13
        # handle possible linker path arguments
        if ( s/^-L// and not -d ) {
            _debug( "$thislib ignored, directory does not exist\n", $verbose );
            next;
        }
        elsif ( -d ) {
            unless ( File::Spec->file_name_is_absolute( $_ ) ) {
                warn "Warning: '$thislib' changed to '-L$pwd/$_'\n";
                $_ = $self->catdir( $pwd, $_ );
            }
            push( @@searchpath, $_ );
            next;
        }
d272 1
a272 2
        my @@paths = ( @@searchpath, @@libpath );
        my ( $fullname, $path ) = _win32_search_file( $thislib, $libext, \@@paths, $verbose, $GC );
d274 79
a352 4
        if ( !$fullname ) {
            warn "Note (probably harmless): No library found for $thislib\n";
            next;
        }
a353 3
        _debug( "'$thislib' found as '$fullname'\n", $verbose );
        push( @@extralibs, $fullname );
        $libs_seen{$fullname} = 1 if $path;    # why is this a special case?
d356 1
a356 3
    my @@libs = keys %libs_seen;

    return ( '', '', '', '', ( $give_libs ? \@@libs : () ) ) unless @@extralibs;
d359 3
a361 4
    @@extralibs = map { /\s/ ? qq["$_"] : $_ } @@extralibs;
    @@libs      = map { /\s/ ? qq["$_"] : $_ } @@libs;

    my $lib = join( ' ', @@extralibs );
d368 2
a369 85
    _debug( "Result: $lib\n", $verbose );
    wantarray ? ( $lib, '', $lib, '', ( $give_libs ? \@@libs : () ) ) : $lib;
}

sub _win32_make_lib_search_list {
    my ( $potential_libs, $verbose ) = @@_;

    # If Config.pm defines a set of default libs, we always
    # tack them on to the user-supplied list, unless the user
    # specified :nodefault
    my $libs = $Config{'perllibs'};
    $potential_libs = join( ' ', $potential_libs, $libs ) if $libs and $potential_libs !~ /:nodefault/i;
    _debug( "Potential libraries are '$potential_libs':\n", $verbose );

    $potential_libs =~ s,\\,/,g;    # normalize to forward slashes

    my @@list = Text::ParseWords::quotewords( '\s+', 0, $potential_libs );

    return @@list;
}

sub _win32_default_search_paths {
    my ( $VC, $GC ) = @@_;

    my $libpth = $Config{'libpth'} || '';
    $libpth =~ s,\\,/,g;            # normalize to forward slashes

    my @@libpath = Text::ParseWords::quotewords( '\s+', 0, $libpth );
    push @@libpath, "$Config{installarchlib}/CORE";    # add "$Config{installarchlib}/CORE" to default search path

    push @@libpath, split /;/, $ENV{LIB}          if $VC and $ENV{LIB};
    push @@libpath, split /;/, $ENV{LIBRARY_PATH} if $GC and $ENV{LIBRARY_PATH};

    return @@libpath;
}

sub _win32_search_file {
    my ( $thislib, $libext, $paths, $verbose, $GC ) = @@_;

    my @@file_list = _win32_build_file_list( $thislib, $GC, $libext );

    for my $lib_file ( @@file_list ) {
        for my $path ( @@{$paths} ) {
            my $fullname = $lib_file;
            $fullname = "$path\\$fullname" if $path;

            return ( $fullname, $path ) if -f $fullname;

            _debug( "'$thislib' not found as '$fullname'\n", $verbose );
        }
    }

    return;
}

sub _win32_build_file_list {
    my ( $lib, $GC, $extensions ) = @@_;

    my @@pre_fixed = _win32_build_prefixed_list( $lib, $GC );
    return map _win32_attach_extensions( $_, $extensions ), @@pre_fixed;
}

sub _win32_build_prefixed_list {
    my ( $lib, $GC ) = @@_;

    return $lib if $lib !~ s/^-l//;
    return $lib if $lib =~ /^lib/ and !$GC;

    ( my $no_prefix = $lib ) =~ s/^lib//i;
    $lib = "lib$lib" if $no_prefix eq $lib;

    return ( $lib, $no_prefix ) if $GC;
    return ( $no_prefix, $lib );
}

sub _win32_attach_extensions {
    my ( $lib, $extensions ) = @@_;
    return map _win32_try_attach_extension( $lib, $_ ), @@{$extensions};
}

sub _win32_try_attach_extension {
    my ( $lib, $extension ) = @@_;

    return $lib if $lib =~ /\Q$extension\E$/i;
    return "$lib$extension";
a371 13
sub _win32_lib_extensions {
    my %extensions;
    $extensions{ $Config{'lib_ext'} } = 1 if $Config{'lib_ext'};
    $extensions{".lib"} = 1;
    return [ keys %extensions ];
}

sub _debug {
    my ( $message, $verbose ) = @@_;
    return if !$verbose;
    warn $message;
    return;
}
d374 2
a375 182
    my ( $self, $potential_libs, $verbose, $give_libs ) = @@_;
    $verbose ||= 0;

    my ( @@crtls, $crtlstr );
    @@crtls = ( ( $Config{'ldflags'} =~ m-/Debug-i ? $Config{'dbgprefix'} : '' ) . 'PerlShr/Share' );
    push( @@crtls, grep { not /\(/ } split /\s+/, $Config{'perllibs'} );
    push( @@crtls, grep { not /\(/ } split /\s+/, $Config{'libc'} );

    # In general, we pass through the basic libraries from %Config unchanged.
    # The one exception is that if we're building in the Perl source tree, and
    # a library spec could be resolved via a logical name, we go to some trouble
    # to insure that the copy in the local tree is used, rather than one to
    # which a system-wide logical may point.
    if ( $self->{PERL_SRC} ) {
        my ( $locspec, $type );
        foreach my $lib ( @@crtls ) {
            if ( ( $locspec, $type ) = $lib =~ m{^([\w\$-]+)(/\w+)?} and $locspec =~ /perl/i ) {
                if    ( lc $type eq '/share' )   { $locspec .= $Config{'exe_ext'}; }
                elsif ( lc $type eq '/library' ) { $locspec .= $Config{'lib_ext'}; }
                else                             { $locspec .= $Config{'obj_ext'}; }
                $locspec = $self->catfile( $self->{PERL_SRC}, $locspec );
                $lib = "$locspec$type" if -e $locspec;
            }
        }
    }
    $crtlstr = @@crtls ? join( ' ', @@crtls ) : '';

    unless ( $potential_libs ) {
        warn "Result:\n\tEXTRALIBS: \n\tLDLOADLIBS: $crtlstr\n" if $verbose;
        return ( '', '', $crtlstr, '', ( $give_libs ? [] : () ) );
    }

    my ( %found, @@fndlibs, $ldlib );
    my $cwd = cwd();
    my ( $so, $lib_ext, $obj_ext ) = @@Config{ 'so', 'lib_ext', 'obj_ext' };

    # List of common Unix library names and their VMS equivalents
    # (VMS equivalent of '' indicates that the library is automatically
    # searched by the linker, and should be skipped here.)
    my ( @@flibs, %libs_seen );
    my %libmap = (
        'm'      => '',
        'f77'    => '',
        'F77'    => '',
        'V77'    => '',
        'c'      => '',
        'malloc' => '',
        'crypt'  => '',
        'resolv' => '',
        'c_s'    => '',
        'socket' => '',
        'X11'    => 'DECW$XLIBSHR',
        'Xt'     => 'DECW$XTSHR',
        'Xm'     => 'DECW$XMLIBSHR',
        'Xmu'    => 'DECW$XMULIBSHR'
    );
    if ( $Config{'vms_cc_type'} ne 'decc' ) { $libmap{'curses'} = 'VAXCCURSE'; }

    warn "Potential libraries are '$potential_libs'\n" if $verbose;

    # First, sort out directories and library names in the input
    my ( @@dirs, @@libs );
    foreach my $lib ( split ' ', $potential_libs ) {
        push( @@dirs, $1 ),   next if $lib =~ /^-L(.*)/;
        push( @@dirs, $lib ), next if $lib =~ /[:>\]]$/;
        push( @@dirs, $lib ), next if -d $lib;
        push( @@libs, $1 ),   next if $lib =~ /^-l(.*)/;
        push( @@libs, $lib );
    }
    push( @@dirs, split( ' ', $Config{'libpth'} ) );

    # Now make sure we've got VMS-syntax absolute directory specs
    # (We don't, however, check whether someone's hidden a relative
    # path in a logical name.)
    foreach my $dir ( @@dirs ) {
        unless ( -d $dir ) {
            warn "Skipping nonexistent Directory $dir\n" if $verbose > 1;
            $dir = '';
            next;
        }
        warn "Resolving directory $dir\n" if $verbose;
        if ( File::Spec->file_name_is_absolute( $dir ) ) {
            $dir = $self->fixpath( $dir, 1 );
        }
        else {
            $dir = $self->catdir( $cwd, $dir );
        }
    }
    @@dirs = grep { length( $_ ) } @@dirs;
    unshift( @@dirs, '' );    # Check each $lib without additions first

  LIB: foreach my $lib ( @@libs ) {
        if ( exists $libmap{$lib} ) {
            next unless length $libmap{$lib};
            $lib = $libmap{$lib};
        }

        my ( @@variants, $cand );
        my ( $ctype ) = '';

        # If we don't have a file type, consider it a possibly abbreviated name and
        # check for common variants.  We try these first to grab libraries before
        # a like-named executable image (e.g. -lperl resolves to perlshr.exe
        # before perl.exe).
        if ( $lib !~ /\.[^:>\]]*$/ ) {
            push( @@variants, "${lib}shr", "${lib}rtl", "${lib}lib" );
            push( @@variants, "lib$lib" ) if $lib !~ /[:>\]]/;
        }
        push( @@variants, $lib );
        warn "Looking for $lib\n" if $verbose;
        foreach my $variant ( @@variants ) {
            my ( $fullname, $name );

            foreach my $dir ( @@dirs ) {
                my ( $type );

                $name = "$dir$variant";
                warn "\tChecking $name\n" if $verbose > 2;
                $fullname = VMS::Filespec::rmsexpand( $name );
                if ( defined $fullname and -f $fullname ) {

                    # It's got its own suffix, so we'll have to figure out the type
                    if    ( $fullname =~ /(?:$so|exe)$/i )      { $type = 'SHR'; }
                    elsif ( $fullname =~ /(?:$lib_ext|olb)$/i ) { $type = 'OLB'; }
                    elsif ( $fullname =~ /(?:$obj_ext|obj)$/i ) {
                        warn "Note (probably harmless): " . "Plain object file $fullname found in library list\n";
                        $type = 'OBJ';
                    }
                    else {
                        warn "Note (probably harmless): " . "Unknown library type for $fullname; assuming shared\n";
                        $type = 'SHR';
                    }
                }
                elsif (-f ( $fullname = VMS::Filespec::rmsexpand( $name, $so ) )
                    or -f ( $fullname = VMS::Filespec::rmsexpand( $name, '.exe' ) ) )
                {
                    $type = 'SHR';
                    $name = $fullname unless $fullname =~ /exe;?\d*$/i;
                }
                elsif (
                    not length( $ctype ) and    # If we've got a lib already,
                                                # don't bother
                    ( -f ( $fullname = VMS::Filespec::rmsexpand( $name, $lib_ext ) ) or -f ( $fullname = VMS::Filespec::rmsexpand( $name, '.olb' ) ) )
                  )
                {
                    $type = 'OLB';
                    $name = $fullname unless $fullname =~ /olb;?\d*$/i;
                }
                elsif (
                    not length( $ctype ) and    # If we've got a lib already,
                                                # don't bother
                    ( -f ( $fullname = VMS::Filespec::rmsexpand( $name, $obj_ext ) ) or -f ( $fullname = VMS::Filespec::rmsexpand( $name, '.obj' ) ) )
                  )
                {
                    warn "Note (probably harmless): " . "Plain object file $fullname found in library list\n";
                    $type = 'OBJ';
                    $name = $fullname unless $fullname =~ /obj;?\d*$/i;
                }
                if ( defined $type ) {
                    $ctype = $type;
                    $cand  = $name;
                    last if $ctype eq 'SHR';
                }
            }
            if ( $ctype ) {

                # This has to precede any other CRTLs, so just make it first
                if ( $cand eq 'VAXCCURSE' ) { unshift @@{ $found{$ctype} }, $cand; }
                else                        { push @@{ $found{$ctype} }, $cand; }
                warn "\tFound as $cand (really $fullname), type $ctype\n"
                  if $verbose > 1;
                push @@flibs, $name unless $libs_seen{$fullname}++;
                next LIB;
            }
        }
        warn "Note (probably harmless): " . "No library found for $lib\n";
    }

    push @@fndlibs, @@{ $found{OBJ} } if exists $found{OBJ};
    push @@fndlibs, map { "$_/Library" } @@{ $found{OLB} } if exists $found{OLB};
    push @@fndlibs, map { "$_/Share" } @@{ $found{SHR} }   if exists $found{SHR};
    my $lib = join( ' ', @@fndlibs );
d377 167
a543 3
    $ldlib = $crtlstr ? "$lib $crtlstr" : $lib;
    warn "Result:\n\tEXTRALIBS: $lib\n\tLDLOADLIBS: $ldlib\n" if $verbose;
    wantarray ? ( $lib, '', $ldlib, '', ( $give_libs ? \@@flibs : () ) ) : $lib;
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d14 1
a14 1
our $VERSION = '6.66';
d235 1
a235 1
        warn "Warning (mostly harmless): " . "No library found for -l$thislib\n"
d311 1
a311 1
            warn "Warning (mostly harmless): No library found for $thislib\n";
d425 1
a425 2
    $extensions{".dll.a"} = 1 if $extensions{".a"};
    $extensions{".lib"}   = 1;
d562 1
a562 1
                        warn "Warning (mostly harmless): " . "Plain object file $fullname found in library list\n";
d566 1
a566 1
                        warn "Warning (mostly harmless): " . "Unknown library type for $fullname; assuming shared\n";
d591 1
a591 1
                    warn "Warning (mostly harmless): " . "Plain object file $fullname found in library list\n";
d612 1
a612 1
        warn "Warning (mostly harmless): " . "No library found for $lib\n";
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@d14 1
a14 1
our $VERSION = '6.98';
d31 1
a31 1
    if ( $^O =~ /os2|android/ and $Config{perllibs} ) {
d34 1
a34 1
        # the libraries linked against perl.dll/libperl.so again.
d62 1
a62 1
        if ( $thislib =~ s/^(-[LR]|-Wl,-R|-Wl,-rpath,)// ) {    # save path flag type
d70 2
a71 2
            if ( ( $ptype eq '-R' ) or ( $ptype =~ m!^-Wl,-[Rr]! ) ) {
                if ( $Config{'lddlflags'} =~ /-Wl,-[Rr]/ ) {
a87 6
        if ( $thislib =~ m!^-Wl,! ) {
            push( @@extralibs,  $thislib );
            push( @@ldloadlibs, $thislib );
            next;
        }

a154 2
            elsif ( $^O eq 'cygwin' && -f ( $fullname = "$thispth/$thislib.dll" ) ) {
            }
d423 5
a427 5
    my @@extensions;
    push @@extensions, $Config{'lib_ext'} if $Config{'lib_ext'};
    push @@extensions, '.dll.a' if grep { m!^\.a$! } @@extensions;
    push @@extensions, '.lib' unless grep { m!^\.lib$! } @@extensions;
    return \@@extensions;
@


1.1.1.5
log
@Import perl-5.24.2
@
text
@d14 1
a14 1
our $VERSION = '7.10_02';
d52 1
a52 1
    my ( @@libpath ) = split " ", $Config{'libpth'} || '';
a59 1
        my ( $custom_name ) = '';
d95 1
a95 8
        if ( $thislib =~ s/^-l(:)?// ) {
            # Handle -l:foo.so, which means that the library will
            # actually be called foo.so, not libfoo.so.  This
            # is used in Android by ExtUtils::Depends to allow one XS
            # module to link to another.
            $custom_name = $1 || '';
        }
        else {
d109 2
a110 4
            if ((@@fullname =
                 $self->lsdir($thispth, "^\Qlib$thislib.$so.\E[0-9]+")) ||
                (@@fullname =
                 $self->lsdir($thispth, "^\Qlib$thislib.\E[0-9]+\Q\.$so"))) {
a178 2
            elsif ( $custom_name && -f ( $fullname = "$thispth/$thislib" ) ) {
            }
d192 1
a192 1
            my $in_perl = ( $libs =~ /\B-l:?\Q${thislib}\E\b/s );
d212 1
a212 1
                push( @@extralibs, "-l$custom_name$thislib" );
d234 1
a234 1
                    push( @@ldloadlibs, "-l$custom_name$thislib" )
d238 1
a238 1
                    push( @@ldloadlibs, "-l$custom_name$thislib" );
d333 2
a334 2
    @@extralibs = map { qq["$_"] } @@extralibs;
    @@libs      = map { qq["$_"] } @@libs;
d502 1
d528 1
a528 1
            $dir = VMS::Filespec::vmspath( $dir );
d612 3
a614 1
                push @@{ $found{$ctype} }, $cand;
a629 1
    $ldlib =~ s/^\s+|\s+$//g;
@


1.1.1.4.4.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d14 1
a14 1
our $VERSION = '6.98_01';
@


1.1.1.4.6.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d14 1
a14 1
our $VERSION = '6.98_01';
@


