head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.3.0.12
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.6
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.8
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.02;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2010.09.24.14.49.04;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.04;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.08.03;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.55;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@# Testing of Pod::Find
# Author: Marek Rouchal <marek@@saftsack.fs.uni-bayreuth.de>

$| = 1;

BEGIN {
  if ($^O eq 'VMS') {
    print "1..0 # needs upstream patch from https://rt.cpan.org/Ticket/Display.html?id=55121";
    exit 0;
  }
}

use strict;
use Test::More tests => 4;

BEGIN {
  # 1. load successful
  use_ok('Pod::Find', qw(pod_find pod_where));
}

use File::Spec;

require Cwd;
my $THISDIR = Cwd::cwd();
my $VERBOSE = $ENV{PERL_CORE} ? 0 : ($ENV{TEST_VERBOSE} || 0);
my $lib_dir = File::Spec->catdir($THISDIR,'lib');

if ($^O eq 'VMS') {
    $lib_dir = VMS::Filespec::unixify($lib_dir);
}

print "### 2. searching $lib_dir\n";
my %pods = pod_find($lib_dir);
my @@results = values %pods;
print "### found @@results\n";
my @@compare = qw(
    Pod::Find
    Pod::InputObjects
    Pod::ParseUtils
    Pod::Parser
    Pod::PlainText
    Pod::Select
);
if (File::Spec->case_tolerant || $^O eq 'dos') {
    # must downcase before sorting
    map {$_ = lc $_} @@compare;
    map {$_ = lc $_} @@results;
}
my $compare = join(',', sort @@compare);
my $result = join(',', sort @@results);
is($result, $compare);

print "### 3. searching for File::Find\n";
$result = pod_where({ -inc => 1, -verbose => $VERBOSE }, 'File::Find')
  || 'undef - pod not found!';
print "### found $result\n";

require Config;
$compare = $ENV{PERL_CORE} ?
      File::Spec->catfile(File::Spec->updir, File::Spec->updir, 'lib','File','Find.pm')
      : File::Spec->catfile($Config::Config{privlibexp},"File","Find.pm");
my $resfile = _canon($result);
my $cmpfile = _canon($compare);
if($^O =~ /dos|win32/i && $resfile =~ /~\d(?=\\|$)/) {
    # we have ~1 short filenames
    $resfile = quotemeta($resfile);
    $resfile =~ s/\\~\d(?=\\|$)/[^\\\\]+/g;
    ok($cmpfile =~ /^$resfile$/, "pod_where found File::Find (with long filename matching)") ||
      diag("'$cmpfile' does not match /^$resfile\$/");
} elsif($^O =~ /dos|win32/i && $cmpfile =~ /~\d(?=\\|$)/) {
    # we have ~1 short filenames
    $cmpfile = quotemeta($cmpfile);
    $cmpfile =~ s/\\~\d(?=\\|$)/[^\\\\]+/g;
    ok($resfile =~ /^$cmpfile$/, "pod_where found File::Find (with long filename matching)") ||
      diag("'$resfile' does not match /^$cmpfile\$/");
} else {
    is($resfile,$cmpfile,"pod_where found File::Find");
}

# Search for a documentation pod rather than a module
my $searchpod = 'Stuff';
print "### 4. searching for $searchpod.pod\n";
$result = pod_where(
  { -dirs => [ File::Spec->catdir( qw(t), 'pod', 'testpods', 'lib', 'Pod') ],
    -verbose => $VERBOSE }, $searchpod)
  || "undef - $searchpod.pod not found!";
print "### found $result\n";

$compare = File::Spec->catfile(
    qw(t), 'pod', 'testpods', 'lib', 'Pod' ,'Stuff.pm');
is(_canon($result),_canon($compare));


# make the path as generic as possible
sub _canon
{
  my ($path) = @@_;
  $path = File::Spec->canonpath($path);
  my @@comp = File::Spec->splitpath($path);
  my @@dir = File::Spec->splitdir($comp[1]);
  $comp[1] = File::Spec->catdir(@@dir);
  $path = File::Spec->catpath(@@comp);
  $path = uc($path) if File::Spec->case_tolerant;
  print "### general path: $path\n" if $VERBOSE;
  $path;
}

@


1.1
log
@Initial revision
@
text
@d1 107
a107 147
# Testing of Pod::Find
# Author: Marek Rouchal <marek@@saftsack.fs.uni-bayreuth.de>

$| = 1;

BEGIN {
  if ($^O eq 'VMS') {
    print "1..0 # needs upstream patch from https://rt.cpan.org/Ticket/Display.html?id=55121";
    exit 0;
  }
}

use Test::More tests => 4;

BEGIN {
  # 1. load successful
  use_ok('Pod::Find', qw(pod_find pod_where));
}

use File::Spec;

require Cwd;
my $THISDIR = Cwd::cwd();
my $VERBOSE = $ENV{PERL_CORE} ? 0 : ($ENV{TEST_VERBOSE} || 0);
my $lib_dir = File::Spec->catdir($THISDIR,'lib');

my $vms_unix_rpt = 0;
my $vms_efs = 0;
my $unix_mode = 1;

if ($^O eq 'VMS') {
    $lib_dir = VMS::Filespec::unixify(File::Spec->catdir($THISDIR,'-','lib','pod'));
    $Qlib_dir = $lib_dir;
    $Qlib_dir =~ s#\/#::#g;

    $unix_mode = 0;
    if (eval 'require VMS::Feature') {
        $vms_unix_rpt = VMS::Feature::current("filename_unix_report");
        $vms_efs = VMS::Feature::current("efs_charset");
    } else {
        my $unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
        my $efs_charset = $ENV{'DECC$EFS_CHARSET'} || '';
        $vms_unix_rpt = $unix_rpt =~ /^[ET1]/i; 
        $vms_efs = $efs_charset =~ /^[ET1]/i; 
    }

    # Traditional VMS mode only if VMS is not in UNIX compatible mode.
    $unix_mode = ($vms_efs && $vms_unix_rpt);
}

print "### 2. searching $lib_dir\n";
my %pods = pod_find($lib_dir);
my $result = join(',', sort values %pods);
print "### found $result\n";
my $compare = join(',', sort qw(
    Pod::Checker
    Pod::Find
    Pod::InputObjects
    Pod::ParseUtils
    Pod::Parser
    Pod::PlainText
    Pod::Select
    Pod::Usage
));
if ($^O eq 'VMS') {
    $compare = lc($compare);
    my $undollared = $Qlib_dir;
    $undollared =~ s/\$/\\\$/g;
    $undollared =~ s/\-/\\\-/g;
    $result =~ s/$undollared/pod::/g;
    $result =~ s/\$//g;
    my $count = 0;
    my @@result = split(/,/,$result);
    my @@compare = split(/,/,$compare);
    foreach(@@compare) {
        $count += grep {/$_/} @@result;
    }
    is($count/($#result+1)-1,$#compare);
}
elsif (File::Spec->case_tolerant || $^O eq 'dos') {
    is(lc $result,lc $compare);
}
else {
    is($result,$compare);
}

print "### 3. searching for File::Find\n";
$result = pod_where({ -inc => 1, -verbose => $VERBOSE }, 'File::Find')
  || 'undef - pod not found!';
print "### found $result\n";

require Config;
if ($^O eq 'VMS') { # privlib is perl_root:[lib] OK but not under mms
    if ($unix_mode) {
        $compare = "../lib/File/Find.pm";
    } else {
        $compare = "lib.File]Find.pm";
    }
    $result =~ s/perl_root:\[\-?\.?//i;
    $result =~ s/\[\-?\.?//i; # needed under `mms test`
    is($result,$compare);
}
else {
    $compare = $ENV{PERL_CORE} ?
      File::Spec->catfile(File::Spec->updir, File::Spec->updir, 'lib','File','Find.pm')
      : File::Spec->catfile($Config::Config{privlibexp},"File","Find.pm");
    my $resfile = _canon($result);
    my $cmpfile = _canon($compare);
    if($^O =~ /dos|win32/i && $resfile =~ /~\d(?=\\|$)/) {
      # we have ~1 short filenames
      $resfile = quotemeta($resfile);
      $resfile =~ s/\\~\d(?=\\|$)/[^\\\\]+/g;
      ok($cmpfile =~ /^$resfile$/, "pod_where found File::Find (with long filename matching)") ||
        diag("'$cmpfile' does not match /^$resfile\$/");
    } else {
      is($resfile,$cmpfile,"pod_where found File::Find");
    }
}

# Search for a documentation pod rather than a module
my $searchpod = 'Stuff';
print "### 4. searching for $searchpod.pod\n";
$result = pod_where(
  { -dirs => [ File::Spec->catdir( qw(t), 'pod', 'testpods', 'lib', 'Pod') ],
    -verbose => $VERBOSE }, $searchpod)
  || "undef - $searchpod.pod not found!";
print "### found $result\n";

$compare = File::Spec->catfile(
    qw(t), 'pod', 'testpods', 'lib', 'Pod' ,'Stuff.pm');
is(_canon($result),_canon($compare));


# make the path as generic as possible
sub _canon
{
  my ($path) = @@_;
  $path = File::Spec->canonpath($path);
  my @@comp = File::Spec->splitpath($path);
  my @@dir = File::Spec->splitdir($comp[1]);
  $comp[1] = File::Spec->catdir(@@dir);
  $path = File::Spec->catpath(@@comp);
  $path = uc($path) if File::Spec->case_tolerant;
  print "### general path: $path\n" if $VERBOSE;
  $path;
}

@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a12 1
use strict;
d27 4
d32 17
a48 1
    $lib_dir = VMS::Filespec::unixify($lib_dir);
d53 3
a55 3
my @@results = values %pods;
print "### found @@results\n";
my @@compare = qw(
d64 22
a85 9
);
if (File::Spec->case_tolerant || $^O eq 'dos') {
    # must downcase before sorting
    map {$_ = lc $_} @@compare;
    map {$_ = lc $_} @@results;
}
my $compare = join(',', sort @@compare);
my $result = join(',', sort @@results);
is($result, $compare);
d93 12
a104 1
$compare = $ENV{PERL_CORE} ?
d107 11
a117 10
my $resfile = _canon($result);
my $cmpfile = _canon($compare);
if($^O =~ /dos|win32/i && $resfile =~ /~\d(?=\\|$)/) {
    # we have ~1 short filenames
    $resfile = quotemeta($resfile);
    $resfile =~ s/\\~\d(?=\\|$)/[^\\\\]+/g;
    ok($cmpfile =~ /^$resfile$/, "pod_where found File::Find (with long filename matching)") ||
      diag("'$cmpfile' does not match /^$resfile\$/");
} else {
    is($resfile,$cmpfile,"pod_where found File::Find");
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d1 103
a103 101
# Testing of Pod::Find
# Author: Marek Rouchal <marek@@saftsack.fs.uni-bayreuth.de>

$| = 1;

BEGIN {
  if ($^O eq 'VMS') {
    print "1..0 # needs upstream patch from https://rt.cpan.org/Ticket/Display.html?id=55121";
    exit 0;
  }
}

use strict;
use Test::More tests => 4;

BEGIN {
  # 1. load successful
  use_ok('Pod::Find', qw(pod_find pod_where));
}

use File::Spec;

require Cwd;
my $THISDIR = Cwd::cwd();
my $VERBOSE = $ENV{PERL_CORE} ? 0 : ($ENV{TEST_VERBOSE} || 0);
my $lib_dir = File::Spec->catdir($THISDIR,'lib');

if ($^O eq 'VMS') {
    $lib_dir = VMS::Filespec::unixify($lib_dir);
}

print "### 2. searching $lib_dir\n";
my %pods = pod_find($lib_dir);
my @@results = values %pods;
print "### found @@results\n";
my @@compare = qw(
    Pod::Find
    Pod::InputObjects
    Pod::ParseUtils
    Pod::Parser
    Pod::PlainText
    Pod::Select
);
if (File::Spec->case_tolerant || $^O eq 'dos') {
    # must downcase before sorting
    map {$_ = lc $_} @@compare;
    map {$_ = lc $_} @@results;
}
my $compare = join(',', sort @@compare);
my $result = join(',', sort @@results);
is($result, $compare);

print "### 3. searching for File::Find\n";
$result = pod_where({ -inc => 1, -verbose => $VERBOSE }, 'File::Find')
  || 'undef - pod not found!';
print "### found $result\n";

require Config;
$compare = $ENV{PERL_CORE} ?
      File::Spec->catfile(File::Spec->updir, File::Spec->updir, 'lib','File','Find.pm')
      : File::Spec->catfile($Config::Config{privlibexp},"File","Find.pm");
my $resfile = _canon($result);
my $cmpfile = _canon($compare);
if($^O =~ /dos|win32/i && $resfile =~ /~\d(?=\\|$)/) {
    # we have ~1 short filenames
    $resfile = quotemeta($resfile);
    $resfile =~ s/\\~\d(?=\\|$)/[^\\\\]+/g;
    ok($cmpfile =~ /^$resfile$/, "pod_where found File::Find (with long filename matching)") ||
      diag("'$cmpfile' does not match /^$resfile\$/");
} else {
    is($resfile,$cmpfile,"pod_where found File::Find");
}

# Search for a documentation pod rather than a module
my $searchpod = 'Stuff';
print "### 4. searching for $searchpod.pod\n";
$result = pod_where(
  { -dirs => [ File::Spec->catdir( qw(t), 'pod', 'testpods', 'lib', 'Pod') ],
    -verbose => $VERBOSE }, $searchpod)
  || "undef - $searchpod.pod not found!";
print "### found $result\n";

$compare = File::Spec->catfile(
    qw(t), 'pod', 'testpods', 'lib', 'Pod' ,'Stuff.pm');
is(_canon($result),_canon($compare));


# make the path as generic as possible
sub _canon
{
  my ($path) = @@_;
  $path = File::Spec->canonpath($path);
  my @@comp = File::Spec->splitpath($path);
  my @@dir = File::Spec->splitdir($comp[1]);
  $comp[1] = File::Spec->catdir(@@dir);
  $path = File::Spec->catpath(@@comp);
  $path = uc($path) if File::Spec->case_tolerant;
  print "### general path: $path\n" if $VERBOSE;
  $path;
}

@


