head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.2.0.12
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.6
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.8
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.2
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.4
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.16
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.12
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2010.09.24.14.49.00;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.00;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.03.24.14.58.56;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!/usr/bin/perl -w
#
# basic.t -- Basic tests for podlators.
#
# Copyright 2001, 2002, 2004, 2006, 2009 by Russ Allbery <rra@@stanford.edu>
#
# This program is free software; you may redistribute it and/or modify it
# under the same terms as Perl itself.

BEGIN {
    chdir 't' if -d 't';
    if ($ENV{PERL_CORE}) {
        @@INC = '../lib';
    }
    unshift (@@INC, '../blib/lib');
    $| = 1;
}

use strict;

use Test::More tests => 15;

BEGIN {
    use_ok ('Pod::Man');
    use_ok ('Pod::Text');
    use_ok ('Pod::Text::Overstrike');
    use_ok ('Pod::Text::Termcap');
}

# Find the path to the test source files.  This requires some fiddling when
# these tests are run as part of Perl core.
sub source_path {
    my $file = shift;
    if ($ENV{PERL_CORE}) {
        require File::Spec;
        my $updir = File::Spec->updir;
        my $dir = File::Spec->catdir ($updir, 'lib', 'Pod', 't');
        return File::Spec->catfile ($dir, $file);
    } else {
        return $file;
    }
}

# Hard-code a few values to try to get reproducible results.
$ENV{COLUMNS} = 80;
$ENV{TERM} = 'xterm';
$ENV{TERMCAP} = 'xterm:co=80:do=^J:md=\E[1m:us=\E[4m:me=\E[m';

# Map of translators to file extensions to find the formatted output to
# compare against.
my %translators = ('Pod::Man'              => 'man',
                   'Pod::Text'             => 'txt',
                   'Pod::Text::Color'      => 'clr',
                   'Pod::Text::Overstrike' => 'ovr',
                   'Pod::Text::Termcap'    => 'cap');

# Set default options to match those of pod2man and pod2text.
our %options = (sentence => 0);

for my $module (sort keys %translators) {
  SKIP: {
        if ($module eq 'Pod::Text::Color') {
            eval { require Term::ANSIColor };
            skip 'Term::ANSIColor not found', 3 if $@@;
            require_ok ('Pod::Text::Color');
        }
        my $parser = $module->new (%options);
        isa_ok ($parser, $module, 'Parser object');

        # For Pod::Man, strip out the autogenerated header up to the .TH title
        # line.  That means that we don't check those things; oh well.  The
        # header changes with each version change or touch of the input file.
        open (OUT, '> out.tmp') or die "Cannot create out.tmp: $!\n";
        $parser->parse_from_file (source_path ('basic.pod'), \*OUT);
        close OUT;
        if ($module eq 'Pod::Man') {
            open (TMP, 'out.tmp') or die "Cannot open out.tmp: $!\n";
            open (OUTPUT, "> out.$translators{$module}")
                or die "Cannot create out.$translators{$module}: $!\n";
            local $_;
            while (<TMP>) { last if /^\.nh/ }
            print OUTPUT while <TMP>;
            close OUTPUT;
            close TMP;
            1 while unlink 'out.tmp';
        } else {
            rename ('out.tmp', "out.$translators{$module}")
                or die "Cannot rename out.tmp: $!\n";
        }

        # Slurp the output and expected output and compare them.
        my ($master, $output);
        {
            local $/;
            open (MASTER, source_path ("basic.$translators{$module}"))
                or die "Cannot open basic.$translators{$module}: $!\n";
            open (OUTPUT, "out.$translators{$module}")
                or die "Cannot open out.$translators{$module}: $!\n";
            $master = <MASTER>;
            $output = <OUTPUT>;
            close MASTER;
            close OUTPUT;
        }

        # OS/390 is EBCDIC, which uses a different character for ESC
        # apparently.  Try to convert so that the test still works.
        if ($^O eq 'os390' and $module eq 'Pod::Text::Termcap') {
            $output =~ tr/\033/\047/;
        }
        if (ok ($master eq $output, "$module output is correct")) {
            1 while unlink "out.$translators{$module}";
        } else {
            diag ("Non-matching output left in out.$translators{$module}\n");
        }
    }
}
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d5 1
a5 2
# Copyright 2001, 2002, 2004, 2006, 2009, 2012
#     Russ Allbery <rra@@stanford.edu>
d73 1
a73 1
        open (OUT, "> out$$.tmp") or die "Cannot create out$$.tmp: $!\n";
d77 3
a79 3
            open (TMP, "out$$.tmp") or die "Cannot open out$$.tmp: $!\n";
            open (OUTPUT, "> out$$.$translators{$module}")
                or die "Cannot create out$$.$translators{$module}: $!\n";
d85 1
a85 1
            1 while unlink "out$$.tmp";
d87 2
a88 2
            rename ("out$$.tmp", "out$$.$translators{$module}")
                or die "Cannot rename out$$.tmp: $!\n";
d97 2
a98 2
            open (OUTPUT, "out$$.$translators{$module}")
                or die "Cannot open out$$.$translators{$module}: $!\n";
d111 1
a111 1
            1 while unlink "out$$.$translators{$module}";
d113 1
a113 1
            diag ("Non-matching output left in out$$.$translators{$module}\n");
@

