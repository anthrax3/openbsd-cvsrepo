head	1.18;
access;
symbols
	PERL_5_24_2:1.1.1.17
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.10
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.4
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.18
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	cxJ08BvJA9Pt2PTM;

1.17
date	2014.11.17.20.56.48;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	QP75iYx42Uo7mMxO;

1.16
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.24.15.06.42;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.29.17.35.58;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.19.22.58;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.15.21.30.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.08.56;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.00;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.18;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.55;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.18;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.08;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.47;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.47;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.46;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.45;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.18;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.49;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.34;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.12.54;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.45.45;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.32;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.47.38;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.08;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.34;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.29;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.06.32;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.58.46;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.52.38;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	B31cAbBIXiCqnL97;

1.1.1.17
date	2017.08.14.13.45.28;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.18
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    pp_hot.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * Then he heard Merry change the note, and up went the Horn-cry of Buckland,
 * shaking the air.
 *
 *                  Awake!  Awake!  Fear, Fire, Foes!  Awake!
 *                               Fire, Foes!  Awake!
 *
 *     [p.1007 of _The Lord of the Rings_, VI/viii: "The Scouring of the Shire"]
 */

/* This file contains 'hot' pp ("push/pop") functions that
 * execute the opcodes that make up a perl program. A typical pp function
 * expects to find its arguments on the stack, and usually pushes its
 * results onto the stack, hence the 'pp' terminology. Each OP structure
 * contains a pointer to the relevant pp_foo() function.
 *
 * By 'hot', we mean common ops whose execution speed is critical.
 * By gathering them together into a single file, we encourage
 * CPU cache hits on hot code. Also it could be taken as a warning not to
 * change any code in this file unless you're sure it won't affect
 * performance.
 */

#include "EXTERN.h"
#define PERL_IN_PP_HOT_C
#include "perl.h"

/* Hot code. */

PP(pp_const)
{
    dSP;
    XPUSHs(cSVOP_sv);
    RETURN;
}

PP(pp_nextstate)
{
    PL_curcop = (COP*)PL_op;
    TAINT_NOT;		/* Each statement is presumed innocent */
    PL_stack_sp = PL_stack_base + CX_CUR()->blk_oldsp;
    FREETMPS;
    PERL_ASYNC_CHECK();
    return NORMAL;
}

PP(pp_gvsv)
{
    dSP;
    EXTEND(SP,1);
    if (UNLIKELY(PL_op->op_private & OPpLVAL_INTRO))
	PUSHs(save_scalar(cGVOP_gv));
    else
	PUSHs(GvSVn(cGVOP_gv));
    RETURN;
}


/* also used for: pp_lineseq() pp_regcmaybe() pp_scalar() pp_scope() */

PP(pp_null)
{
    return NORMAL;
}

/* This is sometimes called directly by pp_coreargs, pp_grepstart and
   amagic_call. */
PP(pp_pushmark)
{
    PUSHMARK(PL_stack_sp);
    return NORMAL;
}

PP(pp_stringify)
{
    dSP; dTARGET;
    SV * const sv = TOPs;
    SETs(TARG);
    sv_copypv(TARG, sv);
    SvSETMAGIC(TARG);
    /* no PUTBACK, SETs doesn't inc/dec SP */
    return NORMAL;
}

PP(pp_gv)
{
    dSP;
    XPUSHs(MUTABLE_SV(cGVOP_gv));
    RETURN;
}


/* also used for: pp_andassign() */

PP(pp_and)
{
    PERL_ASYNC_CHECK();
    {
	/* SP is not used to remove a variable that is saved across the
	  sv_2bool_flags call in SvTRUE_NN, if a RISC/CISC or low/high machine
	  register or load/store vs direct mem ops macro is introduced, this
	  should be a define block between direct PL_stack_sp and dSP operations,
	  presently, using PL_stack_sp is bias towards CISC cpus */
	SV * const sv = *PL_stack_sp;
	if (!SvTRUE_NN(sv))
	    return NORMAL;
	else {
	    if (PL_op->op_type == OP_AND)
		--PL_stack_sp;
	    return cLOGOP->op_other;
	}
    }
}

PP(pp_sassign)
{
    dSP;
    /* sassign keeps its args in the optree traditionally backwards.
       So we pop them differently.
    */
    SV *left = POPs; SV *right = TOPs;

    if (PL_op->op_private & OPpASSIGN_BACKWARDS) {
	SV * const temp = left;
	left = right; right = temp;
    }
    assert(TAINTING_get || !TAINT_get);
    if (UNLIKELY(TAINT_get) && !SvTAINTED(right))
	TAINT_NOT;
    if (UNLIKELY(PL_op->op_private & OPpASSIGN_CV_TO_GV)) {
        /* *foo =\&bar */
	SV * const cv = SvRV(right);
	const U32 cv_type = SvTYPE(cv);
	const bool is_gv = isGV_with_GP(left);
	const bool got_coderef = cv_type == SVt_PVCV || cv_type == SVt_PVFM;

	if (!got_coderef) {
	    assert(SvROK(cv));
	}

	/* Can do the optimisation if left (LVALUE) is not a typeglob,
	   right (RVALUE) is a reference to something, and we're in void
	   context. */
	if (!got_coderef && !is_gv && GIMME_V == G_VOID) {
	    /* Is the target symbol table currently empty?  */
	    GV * const gv = gv_fetchsv_nomg(left, GV_NOINIT, SVt_PVGV);
	    if (SvTYPE(gv) != SVt_PVGV && !SvOK(gv)) {
		/* Good. Create a new proxy constant subroutine in the target.
		   The gv becomes a(nother) reference to the constant.  */
		SV *const value = SvRV(cv);

		SvUPGRADE(MUTABLE_SV(gv), SVt_IV);
		SvPCS_IMPORTED_on(gv);
		SvRV_set(gv, value);
		SvREFCNT_inc_simple_void(value);
		SETs(left);
		RETURN;
	    }
	}

	/* Need to fix things up.  */
	if (!is_gv) {
	    /* Need to fix GV.  */
	    left = MUTABLE_SV(gv_fetchsv_nomg(left,GV_ADD, SVt_PVGV));
	}

	if (!got_coderef) {
	    /* We've been returned a constant rather than a full subroutine,
	       but they expect a subroutine reference to apply.  */
	    if (SvROK(cv)) {
		ENTER_with_name("sassign_coderef");
		SvREFCNT_inc_void(SvRV(cv));
		/* newCONSTSUB takes a reference count on the passed in SV
		   from us.  We set the name to NULL, otherwise we get into
		   all sorts of fun as the reference to our new sub is
		   donated to the GV that we're about to assign to.
		*/
		SvRV_set(right, MUTABLE_SV(newCONSTSUB(GvSTASH(left), NULL,
						      SvRV(cv))));
		SvREFCNT_dec_NN(cv);
		LEAVE_with_name("sassign_coderef");
	    } else {
		/* What can happen for the corner case *{"BONK"} = \&{"BONK"};
		   is that
		   First:   ops for \&{"BONK"}; return us the constant in the
			    symbol table
		   Second:  ops for *{"BONK"} cause that symbol table entry
			    (and our reference to it) to be upgraded from RV
			    to typeblob)
		   Thirdly: We get here. cv is actually PVGV now, and its
			    GvCV() is actually the subroutine we're looking for

		   So change the reference so that it points to the subroutine
		   of that typeglob, as that's what they were after all along.
		*/
		GV *const upgraded = MUTABLE_GV(cv);
		CV *const source = GvCV(upgraded);

		assert(source);
		assert(CvFLAGS(source) & CVf_CONST);

		SvREFCNT_inc_simple_void_NN(source);
		SvREFCNT_dec_NN(upgraded);
		SvRV_set(right, MUTABLE_SV(source));
	    }
	}

    }
    if (
      UNLIKELY(SvTEMP(left)) && !SvSMAGICAL(left) && SvREFCNT(left) == 1 &&
      (!isGV_with_GP(left) || SvFAKE(left)) && ckWARN(WARN_MISC)
    )
	Perl_warner(aTHX_
	    packWARN(WARN_MISC), "Useless assignment to a temporary"
	);
    SvSetMagicSV(left, right);
    SETs(left);
    RETURN;
}

PP(pp_cond_expr)
{
    dSP;
    PERL_ASYNC_CHECK();
    if (SvTRUEx(POPs))
	RETURNOP(cLOGOP->op_other);
    else
	RETURNOP(cLOGOP->op_next);
}

PP(pp_unstack)
{
    PERL_CONTEXT *cx;
    PERL_ASYNC_CHECK();
    TAINT_NOT;		/* Each statement is presumed innocent */
    cx  = CX_CUR();
    PL_stack_sp = PL_stack_base + cx->blk_oldsp;
    FREETMPS;
    if (!(PL_op->op_flags & OPf_SPECIAL)) {
        assert(CxTYPE(cx) == CXt_BLOCK || CxTYPE_is_LOOP(cx));
	CX_LEAVE_SCOPE(cx);
    }
    return NORMAL;
}

PP(pp_concat)
{
  dSP; dATARGET; tryAMAGICbin_MG(concat_amg, AMGf_assign);
  {
    dPOPTOPssrl;
    bool lbyte;
    STRLEN rlen;
    const char *rpv = NULL;
    bool rbyte = FALSE;
    bool rcopied = FALSE;

    if (TARG == right && right != left) { /* $r = $l.$r */
	rpv = SvPV_nomg_const(right, rlen);
	rbyte = !DO_UTF8(right);
	right = newSVpvn_flags(rpv, rlen, SVs_TEMP);
	rpv = SvPV_const(right, rlen);	/* no point setting UTF-8 here */
	rcopied = TRUE;
    }

    if (TARG != left) { /* not $l .= $r */
        STRLEN llen;
        const char* const lpv = SvPV_nomg_const(left, llen);
	lbyte = !DO_UTF8(left);
	sv_setpvn(TARG, lpv, llen);
	if (!lbyte)
	    SvUTF8_on(TARG);
	else
	    SvUTF8_off(TARG);
    }
    else { /* $l .= $r   and   left == TARG */
	if (!SvOK(left)) {
	    if (left == right && ckWARN(WARN_UNINITIALIZED)) /* $l .= $l */
		report_uninit(right);
	    sv_setpvs(left, "");
	}
        else {
            SvPV_force_nomg_nolen(left);
        }
	lbyte = !DO_UTF8(left);
	if (IN_BYTES)
	    SvUTF8_off(left);
    }

    if (!rcopied) {
	rpv = SvPV_nomg_const(right, rlen);
	rbyte = !DO_UTF8(right);
    }
    if (lbyte != rbyte) {
	if (lbyte)
	    sv_utf8_upgrade_nomg(TARG);
	else {
	    if (!rcopied)
		right = newSVpvn_flags(rpv, rlen, SVs_TEMP);
	    sv_utf8_upgrade_nomg(right);
	    rpv = SvPV_nomg_const(right, rlen);
	}
    }
    sv_catpvn_nomg(TARG, rpv, rlen);

    SETTARG;
    RETURN;
  }
}

/* push the elements of av onto the stack.
 * XXX Note that padav has similar code but without the mg_get().
 * I suspect that the mg_get is no longer needed, but while padav
 * differs, it can't share this function */

STATIC void
S_pushav(pTHX_ AV* const av)
{
    dSP;
    const SSize_t maxarg = AvFILL(av) + 1;
    EXTEND(SP, maxarg);
    if (UNLIKELY(SvRMAGICAL(av))) {
        PADOFFSET i;
        for (i=0; i < (PADOFFSET)maxarg; i++) {
            SV ** const svp = av_fetch(av, i, FALSE);
            /* See note in pp_helem, and bug id #27839 */
            SP[i+1] = svp
                ? SvGMAGICAL(*svp) ? (mg_get(*svp), *svp) : *svp
                : &PL_sv_undef;
        }
    }
    else {
        PADOFFSET i;
        for (i=0; i < (PADOFFSET)maxarg; i++) {
            SV * const sv = AvARRAY(av)[i];
            SP[i+1] = LIKELY(sv) ? sv : &PL_sv_undef;
        }
    }
    SP += maxarg;
    PUTBACK;
}


/* ($lex1,@@lex2,...)   or my ($lex1,@@lex2,...)  */

PP(pp_padrange)
{
    dSP;
    PADOFFSET base = PL_op->op_targ;
    int count = (int)(PL_op->op_private) & OPpPADRANGE_COUNTMASK;
    int i;
    if (PL_op->op_flags & OPf_SPECIAL) {
        /* fake the RHS of my ($x,$y,..) = @@_ */
        PUSHMARK(SP);
        S_pushav(aTHX_ GvAVn(PL_defgv));
        SPAGAIN;
    }

    /* note, this is only skipped for compile-time-known void cxt */
    if ((PL_op->op_flags & OPf_WANT) != OPf_WANT_VOID) {
        EXTEND(SP, count);
        PUSHMARK(SP);
        for (i = 0; i <count; i++)
            *++SP = PAD_SV(base+i);
    }
    if (PL_op->op_private & OPpLVAL_INTRO) {
        SV **svp = &(PAD_SVl(base));
        const UV payload = (UV)(
                      (base << (OPpPADRANGE_COUNTSHIFT + SAVE_TIGHT_SHIFT))
                    | (count << SAVE_TIGHT_SHIFT)
                    | SAVEt_CLEARPADRANGE);
        STATIC_ASSERT_STMT(OPpPADRANGE_COUNTMASK + 1 == (1 << OPpPADRANGE_COUNTSHIFT));
        assert((payload >> (OPpPADRANGE_COUNTSHIFT+SAVE_TIGHT_SHIFT)) == base);
        {
            dSS_ADD;
            SS_ADD_UV(payload);
            SS_ADD_END(1);
        }

        for (i = 0; i <count; i++)
            SvPADSTALE_off(*svp++); /* mark lexical as active */
    }
    RETURN;
}


PP(pp_padsv)
{
    dSP;
    EXTEND(SP, 1);
    {
	OP * const op = PL_op;
	/* access PL_curpad once */
	SV ** const padentry = &(PAD_SVl(op->op_targ));
	{
	    dTARG;
	    TARG = *padentry;
	    PUSHs(TARG);
	    PUTBACK; /* no pop/push after this, TOPs ok */
	}
	if (op->op_flags & OPf_MOD) {
	    if (op->op_private & OPpLVAL_INTRO)
		if (!(op->op_private & OPpPAD_STATE))
		    save_clearsv(padentry);
	    if (op->op_private & OPpDEREF) {
		/* TOPs is equivalent to TARG here.  Using TOPs (SP) rather
		   than TARG reduces the scope of TARG, so it does not
		   span the call to save_clearsv, resulting in smaller
		   machine code. */
		TOPs = vivify_ref(TOPs, op->op_private & OPpDEREF);
	    }
	}
	return op->op_next;
    }
}

PP(pp_readline)
{
    dSP;
    if (TOPs) {
	SvGETMAGIC(TOPs);
	tryAMAGICunTARGETlist(iter_amg, 0);
	PL_last_in_gv = MUTABLE_GV(*PL_stack_sp--);
    }
    else PL_last_in_gv = PL_argvgv, PL_stack_sp--;
    if (!isGV_with_GP(PL_last_in_gv)) {
	if (SvROK(PL_last_in_gv) && isGV_with_GP(SvRV(PL_last_in_gv)))
	    PL_last_in_gv = MUTABLE_GV(SvRV(PL_last_in_gv));
	else {
	    dSP;
	    XPUSHs(MUTABLE_SV(PL_last_in_gv));
	    PUTBACK;
	    Perl_pp_rv2gv(aTHX);
	    PL_last_in_gv = MUTABLE_GV(*PL_stack_sp--);
	    if (PL_last_in_gv == (GV *)&PL_sv_undef)
		PL_last_in_gv = NULL;
	    else
		assert(isGV_with_GP(PL_last_in_gv));
	}
    }
    return do_readline();
}

PP(pp_eq)
{
    dSP;
    SV *left, *right;

    tryAMAGICbin_MG(eq_amg, AMGf_set|AMGf_numeric);
    right = POPs;
    left  = TOPs;
    SETs(boolSV(
	(SvIOK_notUV(left) && SvIOK_notUV(right))
	? (SvIVX(left) == SvIVX(right))
	: ( do_ncmp(left, right) == 0)
    ));
    RETURN;
}


/* also used for: pp_i_preinc() */

PP(pp_preinc)
{
    SV *sv = *PL_stack_sp;

    if (LIKELY(((sv->sv_flags &
                        (SVf_THINKFIRST|SVs_GMG|SVf_IVisUV|
                         SVf_IOK|SVf_NOK|SVf_POK|SVp_NOK|SVp_POK|SVf_ROK))
                == SVf_IOK))
        && SvIVX(sv) != IV_MAX)
    {
	SvIV_set(sv, SvIVX(sv) + 1);
    }
    else /* Do all the PERL_PRESERVE_IVUV and hard cases in sv_inc */
	sv_inc(sv);
    SvSETMAGIC(sv);
    return NORMAL;
}


/* also used for: pp_i_predec() */

PP(pp_predec)
{
    SV *sv = *PL_stack_sp;

    if (LIKELY(((sv->sv_flags &
                        (SVf_THINKFIRST|SVs_GMG|SVf_IVisUV|
                         SVf_IOK|SVf_NOK|SVf_POK|SVp_NOK|SVp_POK|SVf_ROK))
                == SVf_IOK))
        && SvIVX(sv) != IV_MIN)
    {
	SvIV_set(sv, SvIVX(sv) - 1);
    }
    else /* Do all the PERL_PRESERVE_IVUV and hard cases  in sv_dec */
	sv_dec(sv);
    SvSETMAGIC(sv);
    return NORMAL;
}


/* also used for: pp_orassign() */

PP(pp_or)
{
    dSP;
    PERL_ASYNC_CHECK();
    if (SvTRUE(TOPs))
	RETURN;
    else {
	if (PL_op->op_type == OP_OR)
            --SP;
	RETURNOP(cLOGOP->op_other);
    }
}


/* also used for: pp_dor() pp_dorassign() */

PP(pp_defined)
{
    dSP;
    SV* sv;
    bool defined;
    const int op_type = PL_op->op_type;
    const bool is_dor = (op_type == OP_DOR || op_type == OP_DORASSIGN);

    if (is_dor) {
	PERL_ASYNC_CHECK();
        sv = TOPs;
        if (UNLIKELY(!sv || !SvANY(sv))) {
	    if (op_type == OP_DOR)
		--SP;
            RETURNOP(cLOGOP->op_other);
        }
    }
    else {
	/* OP_DEFINED */
        sv = POPs;
        if (UNLIKELY(!sv || !SvANY(sv)))
            RETPUSHNO;
    }

    defined = FALSE;
    switch (SvTYPE(sv)) {
    case SVt_PVAV:
	if (AvMAX(sv) >= 0 || SvGMAGICAL(sv) || (SvRMAGICAL(sv) && mg_find(sv, PERL_MAGIC_tied)))
	    defined = TRUE;
	break;
    case SVt_PVHV:
	if (HvARRAY(sv) || SvGMAGICAL(sv) || (SvRMAGICAL(sv) && mg_find(sv, PERL_MAGIC_tied)))
	    defined = TRUE;
	break;
    case SVt_PVCV:
	if (CvROOT(sv) || CvXSUB(sv))
	    defined = TRUE;
	break;
    default:
	SvGETMAGIC(sv);
	if (SvOK(sv))
	    defined = TRUE;
	break;
    }

    if (is_dor) {
        if(defined) 
            RETURN; 
        if(op_type == OP_DOR)
            --SP;
        RETURNOP(cLOGOP->op_other);
    }
    /* assuming OP_DEFINED */
    if(defined) 
        RETPUSHYES;
    RETPUSHNO;
}



PP(pp_add)
{
    dSP; dATARGET; bool useleft; SV *svl, *svr;

    tryAMAGICbin_MG(add_amg, AMGf_assign|AMGf_numeric);
    svr = TOPs;
    svl = TOPm1s;

#ifdef PERL_PRESERVE_IVUV

    /* special-case some simple common cases */
    if (!((svl->sv_flags|svr->sv_flags) & (SVf_IVisUV|SVs_GMG))) {
        IV il, ir;
        U32 flags = (svl->sv_flags & svr->sv_flags);
        if (flags & SVf_IOK) {
            /* both args are simple IVs */
            UV topl, topr;
            il = SvIVX(svl);
            ir = SvIVX(svr);
          do_iv:
            topl = ((UV)il) >> (UVSIZE * 8 - 2);
            topr = ((UV)ir) >> (UVSIZE * 8 - 2);

            /* if both are in a range that can't under/overflow, do a
             * simple integer add: if the top of both numbers
             * are 00  or 11, then it's safe */
            if (!( ((topl+1) | (topr+1)) & 2)) {
                SP--;
                TARGi(il + ir, 0); /* args not GMG, so can't be tainted */
                SETs(TARG);
                RETURN;
            }
            goto generic;
        }
        else if (flags & SVf_NOK) {
            /* both args are NVs */
            NV nl = SvNVX(svl);
            NV nr = SvNVX(svr);

            if (
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
                !Perl_isnan(nl) && nl == (NV)(il = (IV)nl)
                && !Perl_isnan(nr) && nr == (NV)(ir = (IV)nr)
#else
                nl == (NV)(il = (IV)nl) && nr == (NV)(ir = (IV)nr)
#endif
                )
                /* nothing was lost by converting to IVs */
                goto do_iv;
            SP--;
            TARGn(nl + nr, 0); /* args not GMG, so can't be tainted */
            SETs(TARG);
            RETURN;
        }
    }

  generic:

    useleft = USE_LEFT(svl);
    /* We must see if we can perform the addition with integers if possible,
       as the integer code detects overflow while the NV code doesn't.
       If either argument hasn't had a numeric conversion yet attempt to get
       the IV. It's important to do this now, rather than just assuming that
       it's not IOK as a PV of "9223372036854775806" may not take well to NV
       addition, and an SV which is NOK, NV=6.0 ought to be coerced to
       integer in case the second argument is IV=9223372036854775806
       We can (now) rely on sv_2iv to do the right thing, only setting the
       public IOK flag if the value in the NV (or PV) slot is truly integer.

       A side effect is that this also aggressively prefers integer maths over
       fp maths for integer values.

       How to detect overflow?

       C 99 section 6.2.6.1 says

       The range of nonnegative values of a signed integer type is a subrange
       of the corresponding unsigned integer type, and the representation of
       the same value in each type is the same. A computation involving
       unsigned operands can never overflow, because a result that cannot be
       represented by the resulting unsigned integer type is reduced modulo
       the number that is one greater than the largest value that can be
       represented by the resulting type.

       (the 9th paragraph)

       which I read as "unsigned ints wrap."

       signed integer overflow seems to be classed as "exception condition"

       If an exceptional condition occurs during the evaluation of an
       expression (that is, if the result is not mathematically defined or not
       in the range of representable values for its type), the behavior is
       undefined.

       (6.5, the 5th paragraph)

       I had assumed that on 2s complement machines signed arithmetic would
       wrap, hence coded pp_add and pp_subtract on the assumption that
       everything perl builds on would be happy.  After much wailing and
       gnashing of teeth it would seem that irix64 knows its ANSI spec well,
       knows that it doesn't need to, and doesn't.  Bah.  Anyway, the all-
       unsigned code below is actually shorter than the old code. :-)
    */

    if (SvIV_please_nomg(svr)) {
	/* Unless the left argument is integer in range we are going to have to
	   use NV maths. Hence only attempt to coerce the right argument if
	   we know the left is integer.  */
	UV auv = 0;
	bool auvok = FALSE;
	bool a_valid = 0;

	if (!useleft) {
	    auv = 0;
	    a_valid = auvok = 1;
	    /* left operand is undef, treat as zero. + 0 is identity,
	       Could SETi or SETu right now, but space optimise by not adding
	       lots of code to speed up what is probably a rarish case.  */
	} else {
	    /* Left operand is defined, so is it IV? */
	    if (SvIV_please_nomg(svl)) {
		if ((auvok = SvUOK(svl)))
		    auv = SvUVX(svl);
		else {
		    const IV aiv = SvIVX(svl);
		    if (aiv >= 0) {
			auv = aiv;
			auvok = 1;	/* Now acting as a sign flag.  */
		    } else {
			auv = (aiv == IV_MIN) ? (UV)aiv : (UV)(-aiv);
		    }
		}
		a_valid = 1;
	    }
	}
	if (a_valid) {
	    bool result_good = 0;
	    UV result;
	    UV buv;
	    bool buvok = SvUOK(svr);
	
	    if (buvok)
		buv = SvUVX(svr);
	    else {
		const IV biv = SvIVX(svr);
		if (biv >= 0) {
		    buv = biv;
		    buvok = 1;
		} else
                    buv = (biv == IV_MIN) ? (UV)biv : (UV)(-biv);
	    }
	    /* ?uvok if value is >= 0. basically, flagged as UV if it's +ve,
	       else "IV" now, independent of how it came in.
	       if a, b represents positive, A, B negative, a maps to -A etc
	       a + b =>  (a + b)
	       A + b => -(a - b)
	       a + B =>  (a - b)
	       A + B => -(a + b)
	       all UV maths. negate result if A negative.
	       add if signs same, subtract if signs differ. */

	    if (auvok ^ buvok) {
		/* Signs differ.  */
		if (auv >= buv) {
		    result = auv - buv;
		    /* Must get smaller */
		    if (result <= auv)
			result_good = 1;
		} else {
		    result = buv - auv;
		    if (result <= buv) {
			/* result really should be -(auv-buv). as its negation
			   of true value, need to swap our result flag  */
			auvok = !auvok;
			result_good = 1;
		    }
		}
	    } else {
		/* Signs same */
		result = auv + buv;
		if (result >= auv)
		    result_good = 1;
	    }
	    if (result_good) {
		SP--;
		if (auvok)
		    SETu( result );
		else {
		    /* Negate result */
		    if (result <= (UV)IV_MIN)
                        SETi(result == (UV)IV_MIN
                                ? IV_MIN : -(IV)result);
		    else {
			/* result valid, but out of range for IV.  */
			SETn( -(NV)result );
		    }
		}
		RETURN;
	    } /* Overflow, drop through to NVs.  */
	}
    }

#else
    useleft = USE_LEFT(svl);
#endif

    {
	NV value = SvNV_nomg(svr);
	(void)POPs;
	if (!useleft) {
	    /* left operand is undef, treat as zero. + 0.0 is identity. */
	    SETn(value);
	    RETURN;
	}
	SETn( value + SvNV_nomg(svl) );
	RETURN;
    }
}


/* also used for: pp_aelemfast_lex() */

PP(pp_aelemfast)
{
    dSP;
    AV * const av = PL_op->op_type == OP_AELEMFAST_LEX
	? MUTABLE_AV(PAD_SV(PL_op->op_targ)) : GvAVn(cGVOP_gv);
    const U32 lval = PL_op->op_flags & OPf_MOD;
    SV** const svp = av_fetch(av, (I8)PL_op->op_private, lval);
    SV *sv = (svp ? *svp : &PL_sv_undef);

    if (UNLIKELY(!svp && lval))
        DIE(aTHX_ PL_no_aelem, (int)(I8)PL_op->op_private);

    EXTEND(SP, 1);
    if (!lval && SvRMAGICAL(av) && SvGMAGICAL(sv)) /* see note in pp_helem() */
	mg_get(sv);
    PUSHs(sv);
    RETURN;
}

PP(pp_join)
{
    dSP; dMARK; dTARGET;
    MARK++;
    do_join(TARG, *MARK, MARK, SP);
    SP = MARK;
    SETs(TARG);
    RETURN;
}

PP(pp_pushre)
{
    dSP;
#ifdef DEBUGGING
    /*
     * We ass_u_me that LvTARGOFF() comes first, and that two STRLENs
     * will be enough to hold an OP*.
     */
    SV* const sv = sv_newmortal();
    sv_upgrade(sv, SVt_PVLV);
    LvTYPE(sv) = '/';
    Copy(&PL_op, &LvTARGOFF(sv), 1, OP*);
    XPUSHs(sv);
#else
    XPUSHs(MUTABLE_SV(PL_op));
#endif
    RETURN;
}

/* Oversized hot code. */

/* also used for: pp_say() */

PP(pp_print)
{
    dSP; dMARK; dORIGMARK;
    PerlIO *fp;
    MAGIC *mg;
    GV * const gv
	= (PL_op->op_flags & OPf_STACKED) ? MUTABLE_GV(*++MARK) : PL_defoutgv;
    IO *io = GvIO(gv);

    if (io
	&& (mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar)))
    {
      had_magic:
	if (MARK == ORIGMARK) {
	    /* If using default handle then we need to make space to
	     * pass object as 1st arg, so move other args up ...
	     */
	    MEXTEND(SP, 1);
	    ++MARK;
	    Move(MARK, MARK + 1, (SP - MARK) + 1, SV*);
	    ++SP;
	}
	return Perl_tied_method(aTHX_ SV_CONST(PRINT), mark - 1, MUTABLE_SV(io),
				mg,
				(G_SCALAR | TIED_METHOD_ARGUMENTS_ON_STACK
				 | (PL_op->op_type == OP_SAY
				    ? TIED_METHOD_SAY : 0)), sp - mark);
    }
    if (!io) {
        if ( gv && GvEGVx(gv) && (io = GvIO(GvEGV(gv)))
	    && (mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar)))
            goto had_magic;
	report_evil_fh(gv);
	SETERRNO(EBADF,RMS_IFI);
	goto just_say_no;
    }
    else if (!(fp = IoOFP(io))) {
	if (IoIFP(io))
	    report_wrongway_fh(gv, '<');
	else
	    report_evil_fh(gv);
	SETERRNO(EBADF,IoIFP(io)?RMS_FAC:RMS_IFI);
	goto just_say_no;
    }
    else {
	SV * const ofs = GvSV(PL_ofsgv); /* $, */
	MARK++;
	if (ofs && (SvGMAGICAL(ofs) || SvOK(ofs))) {
	    while (MARK <= SP) {
		if (!do_print(*MARK, fp))
		    break;
		MARK++;
		if (MARK <= SP) {
		    /* don't use 'ofs' here - it may be invalidated by magic callbacks */
		    if (!do_print(GvSV(PL_ofsgv), fp)) {
			MARK--;
			break;
		    }
		}
	    }
	}
	else {
	    while (MARK <= SP) {
		if (!do_print(*MARK, fp))
		    break;
		MARK++;
	    }
	}
	if (MARK <= SP)
	    goto just_say_no;
	else {
	    if (PL_op->op_type == OP_SAY) {
		if (PerlIO_write(fp, "\n", 1) == 0 || PerlIO_error(fp))
		    goto just_say_no;
	    }
            else if (PL_ors_sv && SvOK(PL_ors_sv))
		if (!do_print(PL_ors_sv, fp)) /* $\ */
		    goto just_say_no;

	    if (IoFLAGS(io) & IOf_FLUSH)
		if (PerlIO_flush(fp) == EOF)
		    goto just_say_no;
	}
    }
    SP = ORIGMARK;
    XPUSHs(&PL_sv_yes);
    RETURN;

  just_say_no:
    SP = ORIGMARK;
    XPUSHs(&PL_sv_undef);
    RETURN;
}


/* also used for: pp_rv2hv() */
/* also called directly by pp_lvavref */

PP(pp_rv2av)
{
    dSP; dTOPss;
    const U8 gimme = GIMME_V;
    static const char an_array[] = "an ARRAY";
    static const char a_hash[] = "a HASH";
    const bool is_pp_rv2av = PL_op->op_type == OP_RV2AV
			  || PL_op->op_type == OP_LVAVREF;
    const svtype type = is_pp_rv2av ? SVt_PVAV : SVt_PVHV;

    SvGETMAGIC(sv);
    if (SvROK(sv)) {
	if (UNLIKELY(SvAMAGIC(sv))) {
	    sv = amagic_deref_call(sv, is_pp_rv2av ? to_av_amg : to_hv_amg);
	}
	sv = SvRV(sv);
	if (UNLIKELY(SvTYPE(sv) != type))
	    /* diag_listed_as: Not an ARRAY reference */
	    DIE(aTHX_ "Not %s reference", is_pp_rv2av ? an_array : a_hash);
	else if (UNLIKELY(PL_op->op_flags & OPf_MOD
		&& PL_op->op_private & OPpLVAL_INTRO))
	    Perl_croak(aTHX_ "%s", PL_no_localize_ref);
    }
    else if (UNLIKELY(SvTYPE(sv) != type)) {
	    GV *gv;
	
	    if (!isGV_with_GP(sv)) {
		gv = Perl_softref2xv(aTHX_ sv, is_pp_rv2av ? an_array : a_hash,
				     type, &sp);
		if (!gv)
		    RETURN;
	    }
	    else {
		gv = MUTABLE_GV(sv);
	    }
	    sv = is_pp_rv2av ? MUTABLE_SV(GvAVn(gv)) : MUTABLE_SV(GvHVn(gv));
	    if (PL_op->op_private & OPpLVAL_INTRO)
		sv = is_pp_rv2av ? MUTABLE_SV(save_ary(gv)) : MUTABLE_SV(save_hash(gv));
    }
    if (PL_op->op_flags & OPf_REF) {
		SETs(sv);
		RETURN;
    }
    else if (UNLIKELY(PL_op->op_private & OPpMAYBE_LVSUB)) {
	      const I32 flags = is_lvalue_sub();
	      if (flags && !(flags & OPpENTERSUB_INARGS)) {
		if (gimme != G_ARRAY)
		    goto croak_cant_return;
		SETs(sv);
		RETURN;
	      }
    }

    if (is_pp_rv2av) {
	AV *const av = MUTABLE_AV(sv);
	/* The guts of pp_rv2av  */
	if (gimme == G_ARRAY) {
            SP--;
            PUTBACK;
            S_pushav(aTHX_ av);
            SPAGAIN;
	}
	else if (gimme == G_SCALAR) {
	    dTARGET;
	    const SSize_t maxarg = AvFILL(av) + 1;
	    SETi(maxarg);
	}
    } else {
	/* The guts of pp_rv2hv  */
	if (gimme == G_ARRAY) { /* array wanted */
	    *PL_stack_sp = sv;
	    return Perl_do_kv(aTHX);
	}
	else if ((PL_op->op_private & OPpTRUEBOOL
	      || (  PL_op->op_private & OPpMAYBE_TRUEBOOL
		 && block_gimme() == G_VOID  ))
	      && (!SvRMAGICAL(sv) || !mg_find(sv, PERL_MAGIC_tied)))
	    SETs(HvUSEDKEYS(sv) ? &PL_sv_yes : sv_2mortal(newSViv(0)));
	else if (gimme == G_SCALAR) {
	    dTARG;
	    TARG = Perl_hv_scalar(aTHX_ MUTABLE_HV(sv));
	    SETTARG;
	}
    }
    RETURN;

 croak_cant_return:
    Perl_croak(aTHX_ "Can't return %s to lvalue scalar context",
	       is_pp_rv2av ? "array" : "hash");
    RETURN;
}

STATIC void
S_do_oddball(pTHX_ SV **oddkey, SV **firstkey)
{
    PERL_ARGS_ASSERT_DO_ODDBALL;

    if (*oddkey) {
        if (ckWARN(WARN_MISC)) {
	    const char *err;
	    if (oddkey == firstkey &&
		SvROK(*oddkey) &&
		(SvTYPE(SvRV(*oddkey)) == SVt_PVAV ||
		 SvTYPE(SvRV(*oddkey)) == SVt_PVHV))
	    {
		err = "Reference found where even-sized list expected";
	    }
	    else
		err = "Odd number of elements in hash assignment";
	    Perl_warner(aTHX_ packWARN(WARN_MISC), "%s", err);
	}

    }
}


/* Do a mark and sweep with the SVf_BREAK flag to detect elements which
 * are common to both the LHS and RHS of an aassign, and replace them
 * with copies. All these copies are made before the actual list assign is
 * done.
 *
 * For example in ($a,$b) = ($b,$a), assigning the value of the first RHS
 * element ($b) to the first LH element ($a), modifies $a; when the
 * second assignment is done, the second RH element now has the wrong
 * value. So we initially replace the RHS with ($b, mortalcopy($a)).
 * Note that we don't need to make a mortal copy of $b.
 *
 * The algorithm below works by, for every RHS element, mark the
 * corresponding LHS target element with SVf_BREAK. Then if the RHS
 * element is found with SVf_BREAK set, it means it would have been
 * modified, so make a copy.
 * Note that by scanning both LHS and RHS in lockstep, we avoid
 * unnecessary copies (like $b above) compared with a naive
 * "mark all LHS; copy all marked RHS; unmark all LHS".
 *
 * If the LHS element is a 'my' declaration' and has a refcount of 1, then
 * it can't be common and can be skipped.
 *
 * On DEBUGGING builds it takes an extra boolean, fake. If true, it means
 * that we thought we didn't need to call S_aassign_copy_common(), but we
 * have anyway for sanity checking. If we find we need to copy, then panic.
 */

PERL_STATIC_INLINE void
S_aassign_copy_common(pTHX_ SV **firstlelem, SV **lastlelem,
        SV **firstrelem, SV **lastrelem
#ifdef DEBUGGING
        , bool fake
#endif
)
{
    dVAR;
    SV **relem;
    SV **lelem;
    SSize_t lcount = lastlelem - firstlelem + 1;
    bool marked = FALSE; /* have we marked any LHS with SVf_BREAK ? */
    bool const do_rc1 = cBOOL(PL_op->op_private & OPpASSIGN_COMMON_RC1);
    bool copy_all = FALSE;

    assert(!PL_in_clean_all); /* SVf_BREAK not already in use */
    assert(firstlelem < lastlelem); /* at least 2 LH elements */
    assert(firstrelem < lastrelem); /* at least 2 RH elements */


    lelem = firstlelem;
    /* we never have to copy the first RH element; it can't be corrupted
     * by assigning something to the corresponding first LH element.
     * So this scan does in a loop: mark LHS[N]; test RHS[N+1]
     */
    relem = firstrelem + 1;

    for (; relem <= lastrelem; relem++) {
        SV *svr;

        /* mark next LH element */

        if (--lcount >= 0) {
            SV *svl = *lelem++;

            if (UNLIKELY(!svl)) {/* skip AV alias marker */
                assert (lelem <= lastlelem);
                svl = *lelem++;
                lcount--;
            }

            assert(svl);
            if (SvSMAGICAL(svl)) {
                copy_all = TRUE;
            }
            if (SvTYPE(svl) == SVt_PVAV || SvTYPE(svl) == SVt_PVHV) {
                if (!marked)
                    return;
                /* this LH element will consume all further args;
                 * no need to mark any further LH elements (if any).
                 * But we still need to scan any remaining RHS elements;
                 * set lcount negative to distinguish from  lcount == 0,
                 * so the loop condition continues being true
                 */
                lcount = -1;
                lelem--; /* no need to unmark this element */
            }
            else if (!(do_rc1 && SvREFCNT(svl) == 1) && svl != &PL_sv_undef) {
                assert(!SvIMMORTAL(svl));
                SvFLAGS(svl) |= SVf_BREAK;
                marked = TRUE;
            }
            else if (!marked) {
                /* don't check RH element if no SVf_BREAK flags set yet */
                if (!lcount)
                    break;
                continue;
            }
        }

        /* see if corresponding RH element needs copying */

        assert(marked);
        svr = *relem;
        assert(svr);

        if (UNLIKELY(SvFLAGS(svr) & (SVf_BREAK|SVs_GMG) || copy_all)) {

#ifdef DEBUGGING
            if (fake) {
                /* op_dump(PL_op); */
                Perl_croak(aTHX_
                    "panic: aassign skipped needed copy of common RH elem %"
                        UVuf, (UV)(relem - firstrelem));
            }
#endif

            TAINT_NOT;	/* Each item is independent */

            /* Dear TODO test in t/op/sort.t, I love you.
               (It's relying on a panic, not a "semi-panic" from newSVsv()
               and then an assertion failure below.)  */
            if (UNLIKELY(SvIS_FREED(svr))) {
                Perl_croak(aTHX_ "panic: attempt to copy freed scalar %p",
                           (void*)svr);
            }
            /* avoid break flag while copying; otherwise COW etc
             * disabled... */
            SvFLAGS(svr) &= ~SVf_BREAK;
            /* Not newSVsv(), as it does not allow copy-on-write,
               resulting in wasteful copies.
               Also, we use SV_NOSTEAL in case the SV is used more than
               once, e.g.  (...) = (f())[0,0]
               Where the same SV appears twice on the RHS without a ref
               count bump.  (Although I suspect that the SV won't be
               stealable here anyway - DAPM).
               */
            *relem = sv_mortalcopy_flags(svr,
                                SV_GMAGIC|SV_DO_COW_SVSETSV|SV_NOSTEAL);
            /* ... but restore afterwards in case it's needed again,
             * e.g. ($a,$b,$c) = (1,$a,$a)
             */
            SvFLAGS(svr) |= SVf_BREAK;
        }

        if (!lcount)
            break;
    }

    if (!marked)
        return;

    /*unmark LHS */

    while (lelem > firstlelem) {
        SV * const svl = *(--lelem);
        if (svl)
            SvFLAGS(svl) &= ~SVf_BREAK;
    }
}



PP(pp_aassign)
{
    dVAR; dSP;
    SV **lastlelem = PL_stack_sp;
    SV **lastrelem = PL_stack_base + POPMARK;
    SV **firstrelem = PL_stack_base + POPMARK + 1;
    SV **firstlelem = lastrelem + 1;

    SV **relem;
    SV **lelem;

    SV *sv;
    AV *ary;

    U8 gimme;
    HV *hash;
    SSize_t i;
    int magic;
    U32 lval;
    /* PL_delaymagic is restored by JUMPENV_POP on dieing, so we
     * only need to save locally, not on the save stack */
    U16 old_delaymagic = PL_delaymagic;
#ifdef DEBUGGING
    bool fake = 0;
#endif

    PL_delaymagic = DM_DELAY;		/* catch simultaneous items */

    /* If there's a common identifier on both sides we have to take
     * special care that assigning the identifier on the left doesn't
     * clobber a value on the right that's used later in the list.
     */

    /* at least 2 LH and RH elements, or commonality isn't an issue */
    if (firstlelem < lastlelem && firstrelem < lastrelem) {
        for (relem = firstrelem+1; relem <= lastrelem; relem++) {
            if (SvGMAGICAL(*relem))
                goto do_scan;
        }
        for (lelem = firstlelem; lelem <= lastlelem; lelem++) {
            if (*lelem && SvSMAGICAL(*lelem))
                goto do_scan;
        }
        if ( PL_op->op_private & (OPpASSIGN_COMMON_SCALAR|OPpASSIGN_COMMON_RC1) ) {
            if (PL_op->op_private & OPpASSIGN_COMMON_RC1) {
                /* skip the scan if all scalars have a ref count of 1 */
                for (lelem = firstlelem; lelem <= lastlelem; lelem++) {
                    sv = *lelem;
                    if (!sv || SvREFCNT(sv) == 1)
                        continue;
                    if (SvTYPE(sv) != SVt_PVAV && SvTYPE(sv) != SVt_PVAV)
                        goto do_scan;
                    break;
                }
            }
            else {
            do_scan:
                S_aassign_copy_common(aTHX_
                                      firstlelem, lastlelem, firstrelem, lastrelem
#ifdef DEBUGGING
                    , fake
#endif
                );
            }
        }
    }
#ifdef DEBUGGING
    else {
        /* on debugging builds, do the scan even if we've concluded we
         * don't need to, then panic if we find commonality. Note that the
         * scanner assumes at least 2 elements */
        if (firstlelem < lastlelem && firstrelem < lastrelem) {
            fake = 1;
            goto do_scan;
        }
    }
#endif

    gimme = GIMME_V;
    lval = (gimme == G_ARRAY) ? (PL_op->op_flags & OPf_MOD || LVRET) : 0;

    relem = firstrelem;
    lelem = firstlelem;
    ary = NULL;
    hash = NULL;

    while (LIKELY(lelem <= lastlelem)) {
	bool alias = FALSE;
	TAINT_NOT;		/* Each item stands on its own, taintwise. */
	sv = *lelem++;
	if (UNLIKELY(!sv)) {
	    alias = TRUE;
	    sv = *lelem++;
	    ASSUME(SvTYPE(sv) == SVt_PVAV);
	}
	switch (SvTYPE(sv)) {
	case SVt_PVAV: {
            bool already_copied = FALSE;
	    ary = MUTABLE_AV(sv);
	    magic = SvMAGICAL(ary) != 0;
	    ENTER;
	    SAVEFREESV(SvREFCNT_inc_simple_NN(sv));

            /* We need to clear ary. The is a danger that if we do this,
             * elements on the RHS may be prematurely freed, e.g.
             *   @@a = ($a[0]);
             * In the case of possible commonality, make a copy of each
             * RHS SV *before* clearing the array, and add a reference
             * from the tmps stack, so that it doesn't leak on death.
             * Otherwise, make a copy of each RHS SV only as we're storing
             * it into the array - that way we don't have to worry about
             * it being leaked if we die, but don't incur the cost of
             * mortalising everything.
             */

            if (   (PL_op->op_private & OPpASSIGN_COMMON_AGG)
                && (relem <= lastrelem)
                && (magic || AvFILL(ary) != -1))
            {
                SV **svp;
                EXTEND_MORTAL(lastrelem - relem + 1);
                for (svp = relem; svp <= lastrelem; svp++) {
                    /* see comment in S_aassign_copy_common about SV_NOSTEAL */
                    *svp = sv_mortalcopy_flags(*svp,
                            SV_GMAGIC|SV_DO_COW_SVSETSV|SV_NOSTEAL);
                    TAINT_NOT;
                }
                already_copied = TRUE;
            }

            av_clear(ary);
	    if (relem <= lastrelem)
                av_extend(ary, lastrelem - relem);

	    i = 0;
	    while (relem <= lastrelem) {	/* gobble up all the rest */
		SV **didstore;
		if (LIKELY(!alias)) {
                    if (already_copied)
                        sv = *relem;
                    else {
                        if (LIKELY(*relem))
                            /* before newSV, in case it dies */
                            SvGETMAGIC(*relem);
                        sv = newSV(0);
                        /* see comment in S_aassign_copy_common about
                         * SV_NOSTEAL */
                        sv_setsv_flags(sv, *relem,
                                    (SV_DO_COW_SVSETSV|SV_NOSTEAL));
                        *relem = sv;
                    }
		}
		else {
                    if (!already_copied)
                        SvGETMAGIC(*relem);
		    if (!SvROK(*relem))
			DIE(aTHX_ "Assigned value is not a reference");
		    if (SvTYPE(SvRV(*relem)) > SVt_PVLV)
		   /* diag_listed_as: Assigned value is not %s reference */
			DIE(aTHX_
			   "Assigned value is not a SCALAR reference");
		    if (lval && !already_copied)
			*relem = sv_mortalcopy(*relem);
		    /* XXX else check for weak refs?  */
		    sv = SvREFCNT_inc_NN(SvRV(*relem));
		}
		relem++;
                if (already_copied)
                    SvREFCNT_inc_simple_void_NN(sv); /* undo mortal free */
		didstore = av_store(ary,i++,sv);
		if (magic) {
		    if (!didstore)
			sv_2mortal(sv);
		    if (SvSMAGICAL(sv))
			mg_set(sv);
		}
		TAINT_NOT;
	    }
	    if (UNLIKELY(PL_delaymagic & DM_ARRAY_ISA))
		SvSETMAGIC(MUTABLE_SV(ary));
	    LEAVE;
	    break;
        }

	case SVt_PVHV: {				/* normal hash */
		SV *tmpstr;
                int odd;
                int duplicates = 0;
		SV** topelem = relem;
                SV **firsthashrelem = relem;
                bool already_copied = FALSE;

		hash = MUTABLE_HV(sv);
		magic = SvMAGICAL(hash) != 0;

                odd = ((lastrelem - firsthashrelem)&1)? 0 : 1;
                if (UNLIKELY(odd)) {
                    do_oddball(lastrelem, firsthashrelem);
                    /* we have firstlelem to reuse, it's not needed anymore
		     */
                    *(lastrelem+1) = &PL_sv_undef;
                }

		ENTER;
		SAVEFREESV(SvREFCNT_inc_simple_NN(sv));

                /* We need to clear hash. The is a danger that if we do this,
                 * elements on the RHS may be prematurely freed, e.g.
                 *   %h = (foo => $h{bar});
                 * In the case of possible commonality, make a copy of each
                 * RHS SV *before* clearing the hash, and add a reference
                 * from the tmps stack, so that it doesn't leak on death.
                 */

                if (   (PL_op->op_private & OPpASSIGN_COMMON_AGG)
                    && (relem <= lastrelem)
                    && (magic || HvUSEDKEYS(hash)))
                {
                    SV **svp;
                    EXTEND_MORTAL(lastrelem - relem + 1);
                    for (svp = relem; svp <= lastrelem; svp++) {
                        *svp = sv_mortalcopy_flags(*svp,
                                SV_GMAGIC|SV_DO_COW_SVSETSV|SV_NOSTEAL);
                        TAINT_NOT;
                    }
                    already_copied = TRUE;
                }

		hv_clear(hash);

		while (LIKELY(relem < lastrelem+odd)) {	/* gobble up all the rest */
		    HE *didstore;
                    assert(*relem);
		    /* Copy the key if aassign is called in lvalue context,
		       to avoid having the next op modify our rhs.  Copy
		       it also if it is gmagical, lest it make the
		       hv_store_ent call below croak, leaking the value. */
		    sv = (lval || SvGMAGICAL(*relem)) && !already_copied
			 ? sv_mortalcopy(*relem)
			 : *relem;
		    relem++;
                    assert(*relem);
                    if (already_copied)
                        tmpstr = *relem++;
                    else {
                        SvGETMAGIC(*relem);
                        tmpstr = newSV(0);
                        sv_setsv_nomg(tmpstr,*relem++);	/* value */
                    }

		    if (gimme == G_ARRAY) {
			if (hv_exists_ent(hash, sv, 0))
			    /* key overwrites an existing entry */
			    duplicates += 2;
			else {
			    /* copy element back: possibly to an earlier
			     * stack location if we encountered dups earlier,
			     * possibly to a later stack location if odd */
			    *topelem++ = sv;
			    *topelem++ = tmpstr;
			}
		    }
                    if (already_copied)
                        SvREFCNT_inc_simple_void_NN(tmpstr); /* undo mortal free */
		    didstore = hv_store_ent(hash,sv,tmpstr,0);
		    if (magic) {
			if (!didstore) sv_2mortal(tmpstr);
			SvSETMAGIC(tmpstr);
                    }
		    TAINT_NOT;
		}
		LEAVE;
                if (duplicates && gimme == G_ARRAY) {
                    /* at this point we have removed the duplicate key/value
                     * pairs from the stack, but the remaining values may be
                     * wrong; i.e. with (a 1 a 2 b 3) on the stack we've removed
                     * the (a 2), but the stack now probably contains
                     * (a <freed> b 3), because { hv_save(a,1); hv_save(a,2) }
                     * obliterates the earlier key. So refresh all values. */
                    lastrelem -= duplicates;
                    relem = firsthashrelem;
                    while (relem < lastrelem+odd) {
                        HE *he;
                        he = hv_fetch_ent(hash, *relem++, 0, 0);
                        *relem++ = (he ? HeVAL(he) : &PL_sv_undef);
                    }
                }
                if (odd && gimme == G_ARRAY) lastrelem++;
	    }
	    break;
	default:
	    if (SvIMMORTAL(sv)) {
		if (relem <= lastrelem)
		    relem++;
		break;
	    }
	    if (relem <= lastrelem) {
		if (UNLIKELY(
		  SvTEMP(sv) && !SvSMAGICAL(sv) && SvREFCNT(sv) == 1 &&
		  (!isGV_with_GP(sv) || SvFAKE(sv)) && ckWARN(WARN_MISC)
		))
		    Perl_warner(aTHX_
		       packWARN(WARN_MISC),
		      "Useless assignment to a temporary"
		    );
		sv_setsv(sv, *relem);
		*(relem++) = sv;
	    }
	    else
		sv_setsv(sv, &PL_sv_undef);
	    SvSETMAGIC(sv);
	    break;
	}
    }
    if (UNLIKELY(PL_delaymagic & ~DM_DELAY)) {
	/* Will be used to set PL_tainting below */
	Uid_t tmp_uid  = PerlProc_getuid();
	Uid_t tmp_euid = PerlProc_geteuid();
	Gid_t tmp_gid  = PerlProc_getgid();
	Gid_t tmp_egid = PerlProc_getegid();

        /* XXX $> et al currently silently ignore failures */
	if (PL_delaymagic & DM_UID) {
#ifdef HAS_SETRESUID
	    PERL_UNUSED_RESULT(
               setresuid((PL_delaymagic & DM_RUID) ? PL_delaymagic_uid  : (Uid_t)-1,
                         (PL_delaymagic & DM_EUID) ? PL_delaymagic_euid : (Uid_t)-1,
                         (Uid_t)-1));
#else
#  ifdef HAS_SETREUID
            PERL_UNUSED_RESULT(
                setreuid((PL_delaymagic & DM_RUID) ? PL_delaymagic_uid  : (Uid_t)-1,
                         (PL_delaymagic & DM_EUID) ? PL_delaymagic_euid : (Uid_t)-1));
#  else
#    ifdef HAS_SETRUID
	    if ((PL_delaymagic & DM_UID) == DM_RUID) {
		PERL_UNUSED_RESULT(setruid(PL_delaymagic_uid));
		PL_delaymagic &= ~DM_RUID;
	    }
#    endif /* HAS_SETRUID */
#    ifdef HAS_SETEUID
	    if ((PL_delaymagic & DM_UID) == DM_EUID) {
		PERL_UNUSED_RESULT(seteuid(PL_delaymagic_euid));
		PL_delaymagic &= ~DM_EUID;
	    }
#    endif /* HAS_SETEUID */
	    if (PL_delaymagic & DM_UID) {
		if (PL_delaymagic_uid != PL_delaymagic_euid)
		    DIE(aTHX_ "No setreuid available");
		PERL_UNUSED_RESULT(PerlProc_setuid(PL_delaymagic_uid));
	    }
#  endif /* HAS_SETREUID */
#endif /* HAS_SETRESUID */

	    tmp_uid  = PerlProc_getuid();
	    tmp_euid = PerlProc_geteuid();
	}
        /* XXX $> et al currently silently ignore failures */
	if (PL_delaymagic & DM_GID) {
#ifdef HAS_SETRESGID
	    PERL_UNUSED_RESULT(
                setresgid((PL_delaymagic & DM_RGID) ? PL_delaymagic_gid  : (Gid_t)-1,
                          (PL_delaymagic & DM_EGID) ? PL_delaymagic_egid : (Gid_t)-1,
                          (Gid_t)-1));
#else
#  ifdef HAS_SETREGID
	    PERL_UNUSED_RESULT(
                setregid((PL_delaymagic & DM_RGID) ? PL_delaymagic_gid  : (Gid_t)-1,
                         (PL_delaymagic & DM_EGID) ? PL_delaymagic_egid : (Gid_t)-1));
#  else
#    ifdef HAS_SETRGID
	    if ((PL_delaymagic & DM_GID) == DM_RGID) {
		PERL_UNUSED_RESULT(setrgid(PL_delaymagic_gid));
		PL_delaymagic &= ~DM_RGID;
	    }
#    endif /* HAS_SETRGID */
#    ifdef HAS_SETEGID
	    if ((PL_delaymagic & DM_GID) == DM_EGID) {
		PERL_UNUSED_RESULT(setegid(PL_delaymagic_egid));
		PL_delaymagic &= ~DM_EGID;
	    }
#    endif /* HAS_SETEGID */
	    if (PL_delaymagic & DM_GID) {
		if (PL_delaymagic_gid != PL_delaymagic_egid)
		    DIE(aTHX_ "No setregid available");
		PERL_UNUSED_RESULT(PerlProc_setgid(PL_delaymagic_gid));
	    }
#  endif /* HAS_SETREGID */
#endif /* HAS_SETRESGID */

	    tmp_gid  = PerlProc_getgid();
	    tmp_egid = PerlProc_getegid();
	}
	TAINTING_set( TAINTING_get | (tmp_uid && (tmp_euid != tmp_uid || tmp_egid != tmp_gid)) );
#ifdef NO_TAINT_SUPPORT
        PERL_UNUSED_VAR(tmp_uid);
        PERL_UNUSED_VAR(tmp_euid);
        PERL_UNUSED_VAR(tmp_gid);
        PERL_UNUSED_VAR(tmp_egid);
#endif
    }
    PL_delaymagic = old_delaymagic;

    if (gimme == G_VOID)
	SP = firstrelem - 1;
    else if (gimme == G_SCALAR) {
	dTARGET;
	SP = firstrelem;
	SETi(lastrelem - firstrelem + 1);
    }
    else {
	if (ary || hash)
	    /* note that in this case *firstlelem may have been overwritten
	       by sv_undef in the odd hash case */
	    SP = lastrelem;
	else {
	    SP = firstrelem + (lastlelem - firstlelem);
            lelem = firstlelem + (relem - firstrelem);
            while (relem <= SP)
                *relem++ = (lelem <= lastlelem) ? *lelem++ : &PL_sv_undef;
        }
    }

    RETURN;
}

PP(pp_qr)
{
    dSP;
    PMOP * const pm = cPMOP;
    REGEXP * rx = PM_GETRE(pm);
    SV * const pkg = rx ? CALLREG_PACKAGE(rx) : NULL;
    SV * const rv = sv_newmortal();
    CV **cvp;
    CV *cv;

    SvUPGRADE(rv, SVt_IV);
    /* For a subroutine describing itself as "This is a hacky workaround" I'm
       loathe to use it here, but it seems to be the right fix. Or close.
       The key part appears to be that it's essential for pp_qr to return a new
       object (SV), which implies that there needs to be an effective way to
       generate a new SV from the existing SV that is pre-compiled in the
       optree.  */
    SvRV_set(rv, MUTABLE_SV(reg_temp_copy(NULL, rx)));
    SvROK_on(rv);

    cvp = &( ReANY((REGEXP *)SvRV(rv))->qr_anoncv);
    if (UNLIKELY((cv = *cvp) && CvCLONE(*cvp))) {
	*cvp = cv_clone(cv);
	SvREFCNT_dec_NN(cv);
    }

    if (pkg) {
	HV *const stash = gv_stashsv(pkg, GV_ADD);
	SvREFCNT_dec_NN(pkg);
	(void)sv_bless(rv, stash);
    }

    if (UNLIKELY(RX_ISTAINTED(rx))) {
        SvTAINTED_on(rv);
        SvTAINTED_on(SvRV(rv));
    }
    XPUSHs(rv);
    RETURN;
}

PP(pp_match)
{
    dSP; dTARG;
    PMOP *pm = cPMOP;
    PMOP *dynpm = pm;
    const char *s;
    const char *strend;
    SSize_t curpos = 0; /* initial pos() or current $+[0] */
    I32 global;
    U8 r_flags = 0;
    const char *truebase;			/* Start of string  */
    REGEXP *rx = PM_GETRE(pm);
    bool rxtainted;
    const U8 gimme = GIMME_V;
    STRLEN len;
    const I32 oldsave = PL_savestack_ix;
    I32 had_zerolen = 0;
    MAGIC *mg = NULL;

    if (PL_op->op_flags & OPf_STACKED)
	TARG = POPs;
    else if (ARGTARG)
	GETTARGET;
    else {
	TARG = DEFSV;
	EXTEND(SP,1);
    }

    PUTBACK;				/* EVAL blocks need stack_sp. */
    /* Skip get-magic if this is a qr// clone, because regcomp has
       already done it. */
    truebase = ReANY(rx)->mother_re
	 ? SvPV_nomg_const(TARG, len)
	 : SvPV_const(TARG, len);
    if (!truebase)
	DIE(aTHX_ "panic: pp_match");
    strend = truebase + len;
    rxtainted = (RX_ISTAINTED(rx) ||
		 (TAINT_get && (pm->op_pmflags & PMf_RETAINT)));
    TAINT_NOT;

    /* We need to know this in case we fail out early - pos() must be reset */
    global = dynpm->op_pmflags & PMf_GLOBAL;

    /* PMdf_USED is set after a ?? matches once */
    if (
#ifdef USE_ITHREADS
        SvREADONLY(PL_regex_pad[pm->op_pmoffset])
#else
        pm->op_pmflags & PMf_USED
#endif
    ) {
        DEBUG_r(PerlIO_printf(Perl_debug_log, "?? already matched once"));
	goto nope;
    }

    /* empty pattern special-cased to use last successful pattern if
       possible, except for qr// */
    if (!ReANY(rx)->mother_re && !RX_PRELEN(rx)
     && PL_curpm) {
	pm = PL_curpm;
	rx = PM_GETRE(pm);
    }

    if (RX_MINLEN(rx) >= 0 && (STRLEN)RX_MINLEN(rx) > len) {
        DEBUG_r(PerlIO_printf(Perl_debug_log, "String shorter than min possible regex match (%"
                                              UVuf" < %"IVdf")\n",
                                              (UV)len, (IV)RX_MINLEN(rx)));
	goto nope;
    }

    /* get pos() if //g */
    if (global) {
        mg = mg_find_mglob(TARG);
        if (mg && mg->mg_len >= 0) {
            curpos = MgBYTEPOS(mg, TARG, truebase, len);
            /* last time pos() was set, it was zero-length match */
            if (mg->mg_flags & MGf_MINMATCH)
                had_zerolen = 1;
        }
    }

#ifdef PERL_SAWAMPERSAND
    if (       RX_NPARENS(rx)
            || PL_sawampersand
            || (RX_EXTFLAGS(rx) & (RXf_EVAL_SEEN|RXf_PMf_KEEPCOPY))
            || (dynpm->op_pmflags & PMf_KEEPCOPY)
    )
#endif
    {
	r_flags |= (REXEC_COPY_STR|REXEC_COPY_SKIP_PRE);
        /* in @@a =~ /(.)/g, we iterate multiple times, but copy the buffer
         * only on the first iteration. Therefore we need to copy $' as well
         * as $&, to make the rest of the string available for captures in
         * subsequent iterations */
        if (! (global && gimme == G_ARRAY))
            r_flags |= REXEC_COPY_SKIP_POST;
    };
#ifdef PERL_SAWAMPERSAND
    if (dynpm->op_pmflags & PMf_KEEPCOPY)
        /* handle KEEPCOPY in pmop but not rx, eg $r=qr/a/; /$r/p */
        r_flags &= ~(REXEC_COPY_SKIP_PRE|REXEC_COPY_SKIP_POST);
#endif

    s = truebase;

  play_it_again:
    if (global)
	s = truebase + curpos;

    if (!CALLREGEXEC(rx, (char*)s, (char *)strend, (char*)truebase,
		     had_zerolen, TARG, NULL, r_flags))
	goto nope;

    PL_curpm = pm;
    if (dynpm->op_pmflags & PMf_ONCE)
#ifdef USE_ITHREADS
	SvREADONLY_on(PL_regex_pad[dynpm->op_pmoffset]);
#else
	dynpm->op_pmflags |= PMf_USED;
#endif

    if (rxtainted)
	RX_MATCH_TAINTED_on(rx);
    TAINT_IF(RX_MATCH_TAINTED(rx));

    /* update pos */

    if (global && (gimme != G_ARRAY || (dynpm->op_pmflags & PMf_CONTINUE))) {
        if (!mg)
            mg = sv_magicext_mglob(TARG);
        MgBYTEPOS_set(mg, TARG, truebase, RX_OFFS(rx)[0].end);
        if (RX_ZERO_LEN(rx))
            mg->mg_flags |= MGf_MINMATCH;
        else
            mg->mg_flags &= ~MGf_MINMATCH;
    }

    if ((!RX_NPARENS(rx) && !global) || gimme != G_ARRAY) {
	LEAVE_SCOPE(oldsave);
	RETPUSHYES;
    }

    /* push captures on stack */

    {
	const I32 nparens = RX_NPARENS(rx);
	I32 i = (global && !nparens) ? 1 : 0;

	SPAGAIN;			/* EVAL blocks could move the stack. */
	EXTEND(SP, nparens + i);
	EXTEND_MORTAL(nparens + i);
	for (i = !i; i <= nparens; i++) {
	    PUSHs(sv_newmortal());
	    if (LIKELY((RX_OFFS(rx)[i].start != -1)
                     && RX_OFFS(rx)[i].end   != -1 ))
            {
		const I32 len = RX_OFFS(rx)[i].end - RX_OFFS(rx)[i].start;
		const char * const s = RX_OFFS(rx)[i].start + truebase;
	        if (UNLIKELY(RX_OFFS(rx)[i].end < 0 || RX_OFFS(rx)[i].start < 0
                        || len < 0 || len > strend - s))
		    DIE(aTHX_ "panic: pp_match start/end pointers, i=%ld, "
			"start=%ld, end=%ld, s=%p, strend=%p, len=%"UVuf,
			(long) i, (long) RX_OFFS(rx)[i].start,
			(long)RX_OFFS(rx)[i].end, s, strend, (UV) len);
		sv_setpvn(*SP, s, len);
		if (DO_UTF8(TARG) && is_utf8_string((U8*)s, len))
		    SvUTF8_on(*SP);
	    }
	}
	if (global) {
            curpos = (UV)RX_OFFS(rx)[0].end;
	    had_zerolen = RX_ZERO_LEN(rx);
	    PUTBACK;			/* EVAL blocks may use stack */
	    r_flags |= REXEC_IGNOREPOS | REXEC_NOT_FIRST;
	    goto play_it_again;
	}
	LEAVE_SCOPE(oldsave);
	RETURN;
    }
    NOT_REACHED; /* NOTREACHED */

  nope:
    if (global && !(dynpm->op_pmflags & PMf_CONTINUE)) {
        if (!mg)
            mg = mg_find_mglob(TARG);
        if (mg)
            mg->mg_len = -1;
    }
    LEAVE_SCOPE(oldsave);
    if (gimme == G_ARRAY)
	RETURN;
    RETPUSHNO;
}

OP *
Perl_do_readline(pTHX)
{
    dSP; dTARGETSTACKED;
    SV *sv;
    STRLEN tmplen = 0;
    STRLEN offset;
    PerlIO *fp;
    IO * const io = GvIO(PL_last_in_gv);
    const I32 type = PL_op->op_type;
    const U8 gimme = GIMME_V;

    if (io) {
	const MAGIC *const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    Perl_tied_method(aTHX_ SV_CONST(READLINE), SP, MUTABLE_SV(io), mg, gimme, 0);
	    if (gimme == G_SCALAR) {
		SPAGAIN;
		SvSetSV_nosteal(TARG, TOPs);
		SETTARG;
	    }
	    return NORMAL;
	}
    }
    fp = NULL;
    if (io) {
	fp = IoIFP(io);
	if (!fp) {
	    if (IoFLAGS(io) & IOf_ARGV) {
		if (IoFLAGS(io) & IOf_START) {
		    IoLINES(io) = 0;
		    if (av_tindex(GvAVn(PL_last_in_gv)) < 0) {
			IoFLAGS(io) &= ~IOf_START;
			do_open6(PL_last_in_gv, "-", 1, NULL, NULL, 0);
			SvTAINTED_off(GvSVn(PL_last_in_gv)); /* previous tainting irrelevant */
			sv_setpvs(GvSVn(PL_last_in_gv), "-");
			SvSETMAGIC(GvSV(PL_last_in_gv));
			fp = IoIFP(io);
			goto have_fp;
		    }
		}
		fp = nextargv(PL_last_in_gv, PL_op->op_flags & OPf_SPECIAL);
		if (!fp) { /* Note: fp != IoIFP(io) */
		    (void)do_close(PL_last_in_gv, FALSE); /* now it does*/
		}
	    }
	    else if (type == OP_GLOB)
		fp = Perl_start_glob(aTHX_ POPs, io);
	}
	else if (type == OP_GLOB)
	    SP--;
	else if (IoTYPE(io) == IoTYPE_WRONLY) {
	    report_wrongway_fh(PL_last_in_gv, '>');
	}
    }
    if (!fp) {
	if ((!io || !(IoFLAGS(io) & IOf_START))
	    && ckWARN(WARN_CLOSED)
            && type != OP_GLOB)
	{
	    report_evil_fh(PL_last_in_gv);
	}
	if (gimme == G_SCALAR) {
	    /* undef TARG, and push that undefined value */
	    if (type != OP_RCATLINE) {
		sv_setsv(TARG,NULL);
	    }
	    PUSHTARG;
	}
	RETURN;
    }
  have_fp:
    if (gimme == G_SCALAR) {
	sv = TARG;
	if (type == OP_RCATLINE && SvGMAGICAL(sv))
	    mg_get(sv);
	if (SvROK(sv)) {
	    if (type == OP_RCATLINE)
		SvPV_force_nomg_nolen(sv);
	    else
		sv_unref(sv);
	}
	else if (isGV_with_GP(sv)) {
	    SvPV_force_nomg_nolen(sv);
	}
	SvUPGRADE(sv, SVt_PV);
	tmplen = SvLEN(sv);	/* remember if already alloced */
	if (!tmplen && !SvREADONLY(sv) && !SvIsCOW(sv)) {
            /* try short-buffering it. Please update t/op/readline.t
	     * if you change the growth length.
	     */
	    Sv_Grow(sv, 80);
        }
	offset = 0;
	if (type == OP_RCATLINE && SvOK(sv)) {
	    if (!SvPOK(sv)) {
		SvPV_force_nomg_nolen(sv);
	    }
	    offset = SvCUR(sv);
	}
    }
    else {
	sv = sv_2mortal(newSV(80));
	offset = 0;
    }

    /* This should not be marked tainted if the fp is marked clean */
#define MAYBE_TAINT_LINE(io, sv) \
    if (!(IoFLAGS(io) & IOf_UNTAINT)) { \
	TAINT;				\
	SvTAINTED_on(sv);		\
    }

/* delay EOF state for a snarfed empty file */
#define SNARF_EOF(gimme,rs,io,sv) \
    (gimme != G_SCALAR || SvCUR(sv)					\
     || (IoFLAGS(io) & IOf_NOLINE) || !RsSNARF(rs))

    for (;;) {
	PUTBACK;
	if (!sv_gets(sv, fp, offset)
	    && (type == OP_GLOB
		|| SNARF_EOF(gimme, PL_rs, io, sv)
		|| PerlIO_error(fp)))
	{
	    PerlIO_clearerr(fp);
	    if (IoFLAGS(io) & IOf_ARGV) {
		fp = nextargv(PL_last_in_gv, PL_op->op_flags & OPf_SPECIAL);
		if (fp)
		    continue;
		(void)do_close(PL_last_in_gv, FALSE);
	    }
	    else if (type == OP_GLOB) {
		if (!do_close(PL_last_in_gv, FALSE)) {
		    Perl_ck_warner(aTHX_ packWARN(WARN_GLOB),
				   "glob failed (child exited with status %d%s)",
				   (int)(STATUS_CURRENT >> 8),
				   (STATUS_CURRENT & 0x80) ? ", core dumped" : "");
		}
	    }
	    if (gimme == G_SCALAR) {
		if (type != OP_RCATLINE) {
		    SV_CHECK_THINKFIRST_COW_DROP(TARG);
		    SvOK_off(TARG);
		}
		SPAGAIN;
		PUSHTARG;
	    }
	    MAYBE_TAINT_LINE(io, sv);
	    RETURN;
	}
	MAYBE_TAINT_LINE(io, sv);
	IoLINES(io)++;
	IoFLAGS(io) |= IOf_NOLINE;
	SvSETMAGIC(sv);
	SPAGAIN;
	XPUSHs(sv);
	if (type == OP_GLOB) {
	    const char *t1;
	    Stat_t statbuf;

	    if (SvCUR(sv) > 0 && SvCUR(PL_rs) > 0) {
		char * const tmps = SvEND(sv) - 1;
		if (*tmps == *SvPVX_const(PL_rs)) {
		    *tmps = '\0';
		    SvCUR_set(sv, SvCUR(sv) - 1);
		}
	    }
	    for (t1 = SvPVX_const(sv); *t1; t1++)
#ifdef __VMS
		if (strchr("*%?", *t1))
#else
		if (strchr("$&*(){}[]'\";\\|?<>~`", *t1))
#endif
			break;
	    if (*t1 && PerlLIO_lstat(SvPVX_const(sv), &statbuf) < 0) {
		(void)POPs;		/* Unmatched wildcard?  Chuck it... */
		continue;
	    }
	} else if (SvUTF8(sv)) { /* OP_READLINE, OP_RCATLINE */
	     if (ckWARN(WARN_UTF8)) {
		const U8 * const s = (const U8*)SvPVX_const(sv) + offset;
		const STRLEN len = SvCUR(sv) - offset;
		const U8 *f;

		if (!is_utf8_string_loc(s, len, &f))
		    /* Emulate :encoding(utf8) warning in the same case. */
		    Perl_warner(aTHX_ packWARN(WARN_UTF8),
				"utf8 \"\\x%02X\" does not map to Unicode",
				f < (U8*)SvEND(sv) ? *f : 0);
	     }
	}
	if (gimme == G_ARRAY) {
	    if (SvLEN(sv) - SvCUR(sv) > 20) {
		SvPV_shrink_to_cur(sv);
	    }
	    sv = sv_2mortal(newSV(80));
	    continue;
	}
	else if (gimme == G_SCALAR && !tmplen && SvLEN(sv) - SvCUR(sv) > 80) {
	    /* try to reclaim a bit of scalar space (only on 1st alloc) */
	    const STRLEN new_len
		= SvCUR(sv) < 60 ? 80 : SvCUR(sv)+40; /* allow some slop */
	    SvPV_renew(sv, new_len);
	}
	RETURN;
    }
}

PP(pp_helem)
{
    dSP;
    HE* he;
    SV **svp;
    SV * const keysv = POPs;
    HV * const hv = MUTABLE_HV(POPs);
    const U32 lval = PL_op->op_flags & OPf_MOD || LVRET;
    const U32 defer = PL_op->op_private & OPpLVAL_DEFER;
    SV *sv;
    const bool localizing = PL_op->op_private & OPpLVAL_INTRO;
    bool preeminent = TRUE;

    if (SvTYPE(hv) != SVt_PVHV)
	RETPUSHUNDEF;

    if (localizing) {
	MAGIC *mg;
	HV *stash;

	/* If we can determine whether the element exist,
	 * Try to preserve the existenceness of a tied hash
	 * element by using EXISTS and DELETE if possible.
	 * Fallback to FETCH and STORE otherwise. */
	if (SvCANEXISTDELETE(hv))
	    preeminent = hv_exists_ent(hv, keysv, 0);
    }

    he = hv_fetch_ent(hv, keysv, lval && !defer, 0);
    svp = he ? &HeVAL(he) : NULL;
    if (lval) {
	if (!svp || !*svp || *svp == &PL_sv_undef) {
	    SV* lv;
	    SV* key2;
	    if (!defer) {
		DIE(aTHX_ PL_no_helem_sv, SVfARG(keysv));
	    }
	    lv = sv_newmortal();
	    sv_upgrade(lv, SVt_PVLV);
	    LvTYPE(lv) = 'y';
	    sv_magic(lv, key2 = newSVsv(keysv), PERL_MAGIC_defelem, NULL, 0);
	    SvREFCNT_dec_NN(key2);	/* sv_magic() increments refcount */
	    LvTARG(lv) = SvREFCNT_inc_simple_NN(hv);
	    LvTARGLEN(lv) = 1;
	    PUSHs(lv);
	    RETURN;
	}
	if (localizing) {
	    if (HvNAME_get(hv) && isGV(*svp))
		save_gp(MUTABLE_GV(*svp), !(PL_op->op_flags & OPf_SPECIAL));
	    else if (preeminent)
		save_helem_flags(hv, keysv, svp,
		     (PL_op->op_flags & OPf_SPECIAL) ? 0 : SAVEf_SETMAGIC);
	    else
		SAVEHDELETE(hv, keysv);
	}
	else if (PL_op->op_private & OPpDEREF) {
	    PUSHs(vivify_ref(*svp, PL_op->op_private & OPpDEREF));
	    RETURN;
	}
    }
    sv = (svp && *svp ? *svp : &PL_sv_undef);
    /* Originally this did a conditional C<sv = sv_mortalcopy(sv)>; this
     * was to make C<local $tied{foo} = $tied{foo}> possible.
     * However, it seems no longer to be needed for that purpose, and
     * introduced a new bug: stuff like C<while ($hash{taintedval} =~ /.../g>
     * would loop endlessly since the pos magic is getting set on the
     * mortal copy and lost. However, the copy has the effect of
     * triggering the get magic, and losing it altogether made things like
     * c<$tied{foo};> in void context no longer do get magic, which some
     * code relied on. Also, delayed triggering of magic on @@+ and friends
     * meant the original regex may be out of scope by now. So as a
     * compromise, do the get magic here. (The MGf_GSKIP flag will stop it
     * being called too many times). */
    if (!lval && SvRMAGICAL(hv) && SvGMAGICAL(sv))
	mg_get(sv);
    PUSHs(sv);
    RETURN;
}


/* a stripped-down version of Perl_softref2xv() for use by
 * pp_multideref(), which doesn't use PL_op->op_flags */

STATIC GV *
S_softref2xv_lite(pTHX_ SV *const sv, const char *const what,
		const svtype type)
{
    if (PL_op->op_private & HINT_STRICT_REFS) {
	if (SvOK(sv))
	    Perl_die(aTHX_ PL_no_symref_sv, sv,
		     (SvPOKp(sv) && SvCUR(sv)>32 ? "..." : ""), what);
	else
	    Perl_die(aTHX_ PL_no_usym, what);
    }
    if (!SvOK(sv))
        Perl_die(aTHX_ PL_no_usym, what);
    return gv_fetchsv_nomg(sv, GV_ADD, type);
}


/* Handle one or more aggregate derefs and array/hash indexings, e.g.
 * $h->{foo}  or  $a[0]{$key}[$i]  or  f()->[1]
 *
 * op_aux points to an array of unions of UV / IV / SV* / PADOFFSET.
 * Each of these either contains a set of actions, or an argument, such as
 * an IV to use as an array index, or a lexical var to retrieve.
 * Several actions re stored per UV; we keep shifting new actions off the
 * one UV, and only reload when it becomes zero.
 */

PP(pp_multideref)
{
    SV *sv = NULL; /* init to avoid spurious 'may be used uninitialized' */
    UNOP_AUX_item *items = cUNOP_AUXx(PL_op)->op_aux;
    UV actions = items->uv;

    assert(actions);
    /* this tells find_uninit_var() where we're up to */
    PL_multideref_pc = items;

    while (1) {
        /* there are three main classes of action; the first retrieve
         * the initial AV or HV from a variable or the stack; the second
         * does the equivalent of an unrolled (/DREFAV, rv2av, aelem),
         * the third an unrolled (/DREFHV, rv2hv, helem).
         */
        switch (actions & MDEREF_ACTION_MASK) {

        case MDEREF_reload:
            actions = (++items)->uv;
            continue;

        case MDEREF_AV_padav_aelem:                 /* $lex[...] */
            sv = PAD_SVl((++items)->pad_offset);
            goto do_AV_aelem;

        case MDEREF_AV_gvav_aelem:                  /* $pkg[...] */
            sv = UNOP_AUX_item_sv(++items);
            assert(isGV_with_GP(sv));
            sv = (SV*)GvAVn((GV*)sv);
            goto do_AV_aelem;

        case MDEREF_AV_pop_rv2av_aelem:             /* expr->[...] */
            {
                dSP;
                sv = POPs;
                PUTBACK;
                goto do_AV_rv2av_aelem;
            }

        case MDEREF_AV_gvsv_vivify_rv2av_aelem:     /* $pkg->[...] */
            sv = UNOP_AUX_item_sv(++items);
            assert(isGV_with_GP(sv));
            sv = GvSVn((GV*)sv);
            goto do_AV_vivify_rv2av_aelem;

        case MDEREF_AV_padsv_vivify_rv2av_aelem:     /* $lex->[...] */
            sv = PAD_SVl((++items)->pad_offset);
            /* FALLTHROUGH */

        do_AV_vivify_rv2av_aelem:
        case MDEREF_AV_vivify_rv2av_aelem:           /* vivify, ->[...] */
            /* this is the OPpDEREF action normally found at the end of
             * ops like aelem, helem, rv2sv */
            sv = vivify_ref(sv, OPpDEREF_AV);
            /* FALLTHROUGH */

        do_AV_rv2av_aelem:
            /* this is basically a copy of pp_rv2av when it just has the
             * sKR/1 flags */
            SvGETMAGIC(sv);
            if (LIKELY(SvROK(sv))) {
                if (UNLIKELY(SvAMAGIC(sv))) {
                    sv = amagic_deref_call(sv, to_av_amg);
                }
                sv = SvRV(sv);
                if (UNLIKELY(SvTYPE(sv) != SVt_PVAV))
                    DIE(aTHX_ "Not an ARRAY reference");
            }
            else if (SvTYPE(sv) != SVt_PVAV) {
                if (!isGV_with_GP(sv))
                    sv = (SV*)S_softref2xv_lite(aTHX_ sv, "an ARRAY", SVt_PVAV);
                sv = MUTABLE_SV(GvAVn((GV*)sv));
            }
            /* FALLTHROUGH */

        do_AV_aelem:
            {
                /* retrieve the key; this may be either a lexical or package
                 * var (whose index/ptr is stored as an item) or a signed
                 * integer constant stored as an item.
                 */
                SV *elemsv;
                IV elem = 0; /* to shut up stupid compiler warnings */


                assert(SvTYPE(sv) == SVt_PVAV);

                switch (actions & MDEREF_INDEX_MASK) {
                case MDEREF_INDEX_none:
                    goto finish;
                case MDEREF_INDEX_const:
                    elem  = (++items)->iv;
                    break;
                case MDEREF_INDEX_padsv:
                    elemsv = PAD_SVl((++items)->pad_offset);
                    goto check_elem;
                case MDEREF_INDEX_gvsv:
                    elemsv = UNOP_AUX_item_sv(++items);
                    assert(isGV_with_GP(elemsv));
                    elemsv = GvSVn((GV*)elemsv);
                check_elem:
                    if (UNLIKELY(SvROK(elemsv) && !SvGAMAGIC(elemsv)
                                            && ckWARN(WARN_MISC)))
                        Perl_warner(aTHX_ packWARN(WARN_MISC),
                                "Use of reference \"%"SVf"\" as array index",
                                SVfARG(elemsv));
                    /* the only time that S_find_uninit_var() needs this
                     * is to determine which index value triggered the
                     * undef warning. So just update it here. Note that
                     * since we don't save and restore this var (e.g. for
                     * tie or overload execution), its value will be
                     * meaningless apart from just here */
                    PL_multideref_pc = items;
                    elem = SvIV(elemsv);
                    break;
                }


                /* this is basically a copy of pp_aelem with OPpDEREF skipped */

                if (!(actions & MDEREF_FLAG_last)) {
                    SV** svp = av_fetch((AV*)sv, elem, 1);
                    if (!svp || ! (sv=*svp))
                        DIE(aTHX_ PL_no_aelem, elem);
                    break;
                }

                if (PL_op->op_private &
                    (OPpMULTIDEREF_EXISTS|OPpMULTIDEREF_DELETE))
                {
                    if (PL_op->op_private & OPpMULTIDEREF_EXISTS) {
                        sv = av_exists((AV*)sv, elem) ? &PL_sv_yes : &PL_sv_no;
                    }
                    else {
                        I32 discard = (GIMME_V == G_VOID) ? G_DISCARD : 0;
                        sv = av_delete((AV*)sv, elem, discard);
                        if (discard)
                            return NORMAL;
                        if (!sv)
                            sv = &PL_sv_undef;
                    }
                }
                else {
                    const U32 lval = PL_op->op_flags & OPf_MOD || LVRET;
                    const U32 defer = PL_op->op_private & OPpLVAL_DEFER;
                    const bool localizing = PL_op->op_private & OPpLVAL_INTRO;
                    bool preeminent = TRUE;
                    AV *const av = (AV*)sv;
                    SV** svp;

                    if (UNLIKELY(localizing)) {
                        MAGIC *mg;
                        HV *stash;

                        /* If we can determine whether the element exist,
                         * Try to preserve the existenceness of a tied array
                         * element by using EXISTS and DELETE if possible.
                         * Fallback to FETCH and STORE otherwise. */
                        if (SvCANEXISTDELETE(av))
                            preeminent = av_exists(av, elem);
                    }

                    svp = av_fetch(av, elem, lval && !defer);

                    if (lval) {
                        if (!svp || !(sv = *svp)) {
                            IV len;
                            if (!defer)
                                DIE(aTHX_ PL_no_aelem, elem);
                            len = av_tindex(av);
                            sv = sv_2mortal(newSVavdefelem(av,
                            /* Resolve a negative index now, unless it points
                             * before the beginning of the array, in which
                             * case record it for error reporting in
                             * magic_setdefelem. */
                                elem < 0 && len + elem >= 0
                                    ? len + elem : elem, 1));
                        }
                        else {
                            if (UNLIKELY(localizing)) {
                                if (preeminent) {
                                    save_aelem(av, elem, svp);
                                    sv = *svp; /* may have changed */
                                }
                                else
                                    SAVEADELETE(av, elem);
                            }
                        }
                    }
                    else {
                        sv = (svp ? *svp : &PL_sv_undef);
                        /* see note in pp_helem() */
                        if (SvRMAGICAL(av) && SvGMAGICAL(sv))
                            mg_get(sv);
                    }
                }

            }
          finish:
            {
                dSP;
                XPUSHs(sv);
                RETURN;
            }
            /* NOTREACHED */




        case MDEREF_HV_padhv_helem:                 /* $lex{...} */
            sv = PAD_SVl((++items)->pad_offset);
            goto do_HV_helem;

        case MDEREF_HV_gvhv_helem:                  /* $pkg{...} */
            sv = UNOP_AUX_item_sv(++items);
            assert(isGV_with_GP(sv));
            sv = (SV*)GvHVn((GV*)sv);
            goto do_HV_helem;

        case MDEREF_HV_pop_rv2hv_helem:             /* expr->{...} */
            {
                dSP;
                sv = POPs;
                PUTBACK;
                goto do_HV_rv2hv_helem;
            }

        case MDEREF_HV_gvsv_vivify_rv2hv_helem:     /* $pkg->{...} */
            sv = UNOP_AUX_item_sv(++items);
            assert(isGV_with_GP(sv));
            sv = GvSVn((GV*)sv);
            goto do_HV_vivify_rv2hv_helem;

        case MDEREF_HV_padsv_vivify_rv2hv_helem:    /* $lex->{...} */
            sv = PAD_SVl((++items)->pad_offset);
            /* FALLTHROUGH */

        do_HV_vivify_rv2hv_helem:
        case MDEREF_HV_vivify_rv2hv_helem:           /* vivify, ->{...} */
            /* this is the OPpDEREF action normally found at the end of
             * ops like aelem, helem, rv2sv */
            sv = vivify_ref(sv, OPpDEREF_HV);
            /* FALLTHROUGH */

        do_HV_rv2hv_helem:
            /* this is basically a copy of pp_rv2hv when it just has the
             * sKR/1 flags (and pp_rv2hv is aliased to pp_rv2av) */

            SvGETMAGIC(sv);
            if (LIKELY(SvROK(sv))) {
                if (UNLIKELY(SvAMAGIC(sv))) {
                    sv = amagic_deref_call(sv, to_hv_amg);
                }
                sv = SvRV(sv);
                if (UNLIKELY(SvTYPE(sv) != SVt_PVHV))
                    DIE(aTHX_ "Not a HASH reference");
            }
            else if (SvTYPE(sv) != SVt_PVHV) {
                if (!isGV_with_GP(sv))
                    sv = (SV*)S_softref2xv_lite(aTHX_ sv, "a HASH", SVt_PVHV);
                sv = MUTABLE_SV(GvHVn((GV*)sv));
            }
            /* FALLTHROUGH */

        do_HV_helem:
            {
                /* retrieve the key; this may be either a lexical / package
                 * var or a string constant, whose index/ptr is stored as an
                 * item
                 */
                SV *keysv = NULL; /* to shut up stupid compiler warnings */

                assert(SvTYPE(sv) == SVt_PVHV);

                switch (actions & MDEREF_INDEX_MASK) {
                case MDEREF_INDEX_none:
                    goto finish;

                case MDEREF_INDEX_const:
                    keysv = UNOP_AUX_item_sv(++items);
                    break;

                case MDEREF_INDEX_padsv:
                    keysv = PAD_SVl((++items)->pad_offset);
                    break;

                case MDEREF_INDEX_gvsv:
                    keysv = UNOP_AUX_item_sv(++items);
                    keysv = GvSVn((GV*)keysv);
                    break;
                }

                /* see comment above about setting this var */
                PL_multideref_pc = items;


                /* ensure that candidate CONSTs have been HEKified */
                assert(   ((actions & MDEREF_INDEX_MASK) != MDEREF_INDEX_const)
                       || SvTYPE(keysv) >= SVt_PVMG
                       || !SvOK(keysv)
                       || SvROK(keysv)
                       || SvIsCOW_shared_hash(keysv));

                /* this is basically a copy of pp_helem with OPpDEREF skipped */

                if (!(actions & MDEREF_FLAG_last)) {
                    HE *he = hv_fetch_ent((HV*)sv, keysv, 1, 0);
                    if (!he || !(sv=HeVAL(he)) || sv == &PL_sv_undef)
                        DIE(aTHX_ PL_no_helem_sv, SVfARG(keysv));
                    break;
                }

                if (PL_op->op_private &
                    (OPpMULTIDEREF_EXISTS|OPpMULTIDEREF_DELETE))
                {
                    if (PL_op->op_private & OPpMULTIDEREF_EXISTS) {
                        sv = hv_exists_ent((HV*)sv, keysv, 0)
                                                ? &PL_sv_yes : &PL_sv_no;
                    }
                    else {
                        I32 discard = (GIMME_V == G_VOID) ? G_DISCARD : 0;
                        sv = hv_delete_ent((HV*)sv, keysv, discard, 0);
                        if (discard)
                            return NORMAL;
                        if (!sv)
                            sv = &PL_sv_undef;
                    }
                }
                else {
                    const U32 lval = PL_op->op_flags & OPf_MOD || LVRET;
                    const U32 defer = PL_op->op_private & OPpLVAL_DEFER;
                    const bool localizing = PL_op->op_private & OPpLVAL_INTRO;
                    bool preeminent = TRUE;
                    SV **svp;
                    HV * const hv = (HV*)sv;
                    HE* he;

                    if (UNLIKELY(localizing)) {
                        MAGIC *mg;
                        HV *stash;

                        /* If we can determine whether the element exist,
                         * Try to preserve the existenceness of a tied hash
                         * element by using EXISTS and DELETE if possible.
                         * Fallback to FETCH and STORE otherwise. */
                        if (SvCANEXISTDELETE(hv))
                            preeminent = hv_exists_ent(hv, keysv, 0);
                    }

                    he = hv_fetch_ent(hv, keysv, lval && !defer, 0);
                    svp = he ? &HeVAL(he) : NULL;


                    if (lval) {
                        if (!svp || !(sv = *svp) || sv == &PL_sv_undef) {
                            SV* lv;
                            SV* key2;
                            if (!defer)
                                DIE(aTHX_ PL_no_helem_sv, SVfARG(keysv));
                            lv = sv_newmortal();
                            sv_upgrade(lv, SVt_PVLV);
                            LvTYPE(lv) = 'y';
                            sv_magic(lv, key2 = newSVsv(keysv),
                                                PERL_MAGIC_defelem, NULL, 0);
                            /* sv_magic() increments refcount */
                            SvREFCNT_dec_NN(key2);
                            LvTARG(lv) = SvREFCNT_inc_simple_NN(hv);
                            LvTARGLEN(lv) = 1;
                            sv = lv;
                        }
                        else {
                            if (localizing) {
                                if (HvNAME_get(hv) && isGV(sv))
                                    save_gp(MUTABLE_GV(sv),
                                        !(PL_op->op_flags & OPf_SPECIAL));
                                else if (preeminent) {
                                    save_helem_flags(hv, keysv, svp,
                                         (PL_op->op_flags & OPf_SPECIAL)
                                            ? 0 : SAVEf_SETMAGIC);
                                    sv = *svp; /* may have changed */
                                }
                                else
                                    SAVEHDELETE(hv, keysv);
                            }
                        }
                    }
                    else {
                        sv = (svp && *svp ? *svp : &PL_sv_undef);
                        /* see note in pp_helem() */
                        if (SvRMAGICAL(hv) && SvGMAGICAL(sv))
                            mg_get(sv);
                    }
                }
                goto finish;
            }

        } /* switch */

        actions >>= MDEREF_SHIFT;
    } /* while */
    /* NOTREACHED */
}


PP(pp_iter)
{
    PERL_CONTEXT *cx;
    SV *oldsv;
    SV **itersvp;
    SV *retsv;

    SV *sv;
    AV *av;
    IV ix;
    IV inc;

    cx = CX_CUR();
    itersvp = CxITERVAR(cx);
    assert(itersvp);

    switch (CxTYPE(cx)) {

    case CXt_LOOP_LAZYSV: /* string increment */
    {
        SV* cur = cx->blk_loop.state_u.lazysv.cur;
        SV *end = cx->blk_loop.state_u.lazysv.end;
        /* If the maximum is !SvOK(), pp_enteriter substitutes PL_sv_no.
           It has SvPVX of "" and SvCUR of 0, which is what we want.  */
        STRLEN maxlen = 0;
        const char *max = SvPV_const(end, maxlen);
        if (UNLIKELY(SvNIOK(cur) || SvCUR(cur) > maxlen))
            goto retno;

        oldsv = *itersvp;
        /* NB: on the first iteration, oldsv will have a ref count of at
         * least 2 (one extra from blk_loop.itersave), so the GV or pad
         * slot will get localised; on subsequent iterations the RC==1
         * optimisation may kick in and the SV will be reused. */
         if (oldsv && LIKELY(SvREFCNT(oldsv) == 1 && !SvMAGICAL(oldsv))) {
            /* safe to reuse old SV */
            sv_setsv(oldsv, cur);
        }
        else
        {
            /* we need a fresh SV every time so that loop body sees a
             * completely new SV for closures/references to work as
             * they used to */
            *itersvp = newSVsv(cur);
            SvREFCNT_dec(oldsv);
        }
        if (strEQ(SvPVX_const(cur), max))
            sv_setiv(cur, 0); /* terminate next time */
        else
            sv_inc(cur);
        break;
    }

    case CXt_LOOP_LAZYIV: /* integer increment */
    {
        IV cur = cx->blk_loop.state_u.lazyiv.cur;
	if (UNLIKELY(cur > cx->blk_loop.state_u.lazyiv.end))
	    goto retno;

        oldsv = *itersvp;
	/* see NB comment above */
	if (oldsv && LIKELY(SvREFCNT(oldsv) == 1 && !SvMAGICAL(oldsv))) {
	    /* safe to reuse old SV */

            if (    (SvFLAGS(oldsv) & (SVTYPEMASK|SVf_THINKFIRST|SVf_IVisUV))
                 == SVt_IV)
            {
                /* Cheap SvIOK_only().
                 * Assert that flags which SvIOK_only() would test or
                 * clear can't be set, because we're SVt_IV */
                assert(!(SvFLAGS(oldsv) &
                    (SVf_OOK|SVf_UTF8|(SVf_OK & ~(SVf_IOK|SVp_IOK)))));
                SvFLAGS(oldsv) |= (SVf_IOK|SVp_IOK);
                /* SvIV_set() where sv_any points to head */
                oldsv->sv_u.svu_iv = cur;

            }
            else
                sv_setiv(oldsv, cur);
	}
	else
	{
	    /* we need a fresh SV every time so that loop body sees a
	     * completely new SV for closures/references to work as they
	     * used to */
	    *itersvp = newSViv(cur);
	    SvREFCNT_dec(oldsv);
	}

	if (UNLIKELY(cur == IV_MAX)) {
	    /* Handle end of range at IV_MAX */
	    cx->blk_loop.state_u.lazyiv.end = IV_MIN;
	} else
	    ++cx->blk_loop.state_u.lazyiv.cur;
        break;
    }

    case CXt_LOOP_LIST: /* for (1,2,3) */

        assert(OPpITER_REVERSED == 2); /* so inc becomes -1 or 1 */
        inc = 1 - (PL_op->op_private & OPpITER_REVERSED);
        ix = (cx->blk_loop.state_u.stack.ix += inc);
        if (UNLIKELY(inc > 0
                        ? ix > cx->blk_oldsp
                        : ix <= cx->blk_loop.state_u.stack.basesp)
        )
            goto retno;

        sv = PL_stack_base[ix];
        av = NULL;
        goto loop_ary_common;

    case CXt_LOOP_ARY: /* for (@@ary) */

        av = cx->blk_loop.state_u.ary.ary;
        inc = 1 - (PL_op->op_private & OPpITER_REVERSED);
        ix = (cx->blk_loop.state_u.ary.ix += inc);
        if (UNLIKELY(inc > 0
                        ? ix > AvFILL(av)
                        : ix < 0)
        )
            goto retno;

        if (UNLIKELY(SvRMAGICAL(av))) {
            SV * const * const svp = av_fetch(av, ix, FALSE);
            sv = svp ? *svp : NULL;
        }
        else {
            sv = AvARRAY(av)[ix];
        }

      loop_ary_common:

        if (UNLIKELY(cx->cx_type & CXp_FOR_LVREF)) {
            SvSetMagicSV(*itersvp, sv);
            break;
        }

        if (LIKELY(sv)) {
            if (UNLIKELY(SvIS_FREED(sv))) {
                *itersvp = NULL;
                Perl_croak(aTHX_ "Use of freed value in iteration");
            }
            if (SvPADTMP(sv)) {
                sv = newSVsv(sv);
            }
            else {
                SvTEMP_off(sv);
                SvREFCNT_inc_simple_void_NN(sv);
            }
        }
        else if (av) {
            sv = newSVavdefelem(av, ix, 0);
        }
        else
            sv = &PL_sv_undef;

        oldsv = *itersvp;
        *itersvp = sv;
        SvREFCNT_dec(oldsv);
        break;

    default:
	DIE(aTHX_ "panic: pp_iter, type=%u", CxTYPE(cx));
    }

    retsv = &PL_sv_yes;
    if (0) {
      retno:
        retsv = &PL_sv_no;
    }
    /* pp_enteriter should have pre-extended the stack */
    assert(PL_stack_sp < PL_stack_max);
    *++PL_stack_sp =retsv;

    return PL_op->op_next;
}

/*
A description of how taint works in pattern matching and substitution.

This is all conditional on NO_TAINT_SUPPORT not being defined. Under
NO_TAINT_SUPPORT, taint-related operations should become no-ops.

While the pattern is being assembled/concatenated and then compiled,
PL_tainted will get set (via TAINT_set) if any component of the pattern
is tainted, e.g. /.*$tainted/.  At the end of pattern compilation,
the RXf_TAINTED flag is set on the pattern if PL_tainted is set (via
TAINT_get).  It will also be set if any component of the pattern matches
based on locale-dependent behavior.

When the pattern is copied, e.g. $r = qr/..../, the SV holding the ref to
the pattern is marked as tainted. This means that subsequent usage, such
as /x$r/, will set PL_tainted using TAINT_set, and thus RXf_TAINTED,
on the new pattern too.

RXf_TAINTED_SEEN is used post-execution by the get magic code
of $1 et al to indicate whether the returned value should be tainted.
It is the responsibility of the caller of the pattern (i.e. pp_match,
pp_subst etc) to set this flag for any other circumstances where $1 needs
to be tainted.

The taint behaviour of pp_subst (and pp_substcont) is quite complex.

There are three possible sources of taint
    * the source string
    * the pattern (both compile- and run-time, RXf_TAINTED / RXf_TAINTED_SEEN)
    * the replacement string (or expression under /e)
    
There are four destinations of taint and they are affected by the sources
according to the rules below:

    * the return value (not including /r):
	tainted by the source string and pattern, but only for the
	number-of-iterations case; boolean returns aren't tainted;
    * the modified string (or modified copy under /r):
	tainted by the source string, pattern, and replacement strings;
    * $1 et al:
	tainted by the pattern, and under 'use re "taint"', by the source
	string too;
    * PL_taint - i.e. whether subsequent code (e.g. in a /e block) is tainted:
	should always be unset before executing subsequent code.

The overall action of pp_subst is:

    * at the start, set bits in rxtainted indicating the taint status of
	the various sources.

    * After each pattern execution, update the SUBST_TAINT_PAT bit in
	rxtainted if RXf_TAINTED_SEEN has been set, to indicate that the
	pattern has subsequently become tainted via locale ops.

    * If control is being passed to pp_substcont to execute a /e block,
	save rxtainted in the CXt_SUBST block, for future use by
	pp_substcont.

    * Whenever control is being returned to perl code (either by falling
	off the "end" of pp_subst/pp_substcont, or by entering a /e block),
	use the flag bits in rxtainted to make all the appropriate types of
	destination taint visible; e.g. set RXf_TAINTED_SEEN so that $1
	et al will appear tainted.

pp_match is just a simpler version of the above.

*/

PP(pp_subst)
{
    dSP; dTARG;
    PMOP *pm = cPMOP;
    PMOP *rpm = pm;
    char *s;
    char *strend;
    const char *c;
    STRLEN clen;
    SSize_t iters = 0;
    SSize_t maxiters;
    bool once;
    U8 rxtainted = 0; /* holds various SUBST_TAINT_* flag bits.
			See "how taint works" above */
    char *orig;
    U8 r_flags;
    REGEXP *rx = PM_GETRE(pm);
    STRLEN len;
    int force_on_match = 0;
    const I32 oldsave = PL_savestack_ix;
    STRLEN slen;
    bool doutf8 = FALSE; /* whether replacement is in utf8 */
#ifdef PERL_ANY_COW
    bool was_cow;
#endif
    SV *nsv = NULL;
    /* known replacement string? */
    SV *dstr = (pm->op_pmflags & PMf_CONST) ? POPs : NULL;

    PERL_ASYNC_CHECK();

    if (PL_op->op_flags & OPf_STACKED)
	TARG = POPs;
    else if (ARGTARG)
	GETTARGET;
    else {
	TARG = DEFSV;
	EXTEND(SP,1);
    }

    SvGETMAGIC(TARG); /* must come before cow check */
#ifdef PERL_ANY_COW
    /* note that a string might get converted to COW during matching */
    was_cow = cBOOL(SvIsCOW(TARG));
#endif
    if (!(rpm->op_pmflags & PMf_NONDESTRUCT)) {
#ifndef PERL_ANY_COW
	if (SvIsCOW(TARG))
	    sv_force_normal_flags(TARG,0);
#endif
	if ((SvREADONLY(TARG)
		|| ( ((SvTYPE(TARG) == SVt_PVGV && isGV_with_GP(TARG))
		      || SvTYPE(TARG) > SVt_PVLV)
		     && !(SvTYPE(TARG) == SVt_PVGV && SvFAKE(TARG)))))
	    Perl_croak_no_modify();
    }
    PUTBACK;

    orig = SvPV_nomg(TARG, len);
    /* note we don't (yet) force the var into being a string; if we fail
     * to match, we leave as-is; on successful match however, we *will*
     * coerce into a string, then repeat the match */
    if (!SvPOKp(TARG) || SvTYPE(TARG) == SVt_PVGV || SvVOK(TARG))
	force_on_match = 1;

    /* only replace once? */
    once = !(rpm->op_pmflags & PMf_GLOBAL);

    /* See "how taint works" above */
    if (TAINTING_get) {
	rxtainted  = (
	    (SvTAINTED(TARG) ? SUBST_TAINT_STR : 0)
	  | (RX_ISTAINTED(rx) ? SUBST_TAINT_PAT : 0)
	  | ((pm->op_pmflags & PMf_RETAINT) ? SUBST_TAINT_RETAINT : 0)
	  | ((once && !(rpm->op_pmflags & PMf_NONDESTRUCT))
		? SUBST_TAINT_BOOLRET : 0));
	TAINT_NOT;
    }

  force_it:
    if (!pm || !orig)
	DIE(aTHX_ "panic: pp_subst, pm=%p, orig=%p", pm, orig);

    strend = orig + len;
    slen = DO_UTF8(TARG) ? utf8_length((U8*)orig, (U8*)strend) : len;
    maxiters = 2 * slen + 10;	/* We can match twice at each
				   position, once with zero-length,
				   second time with non-zero. */

    if (!RX_PRELEN(rx) && PL_curpm
     && !ReANY(rx)->mother_re) {
	pm = PL_curpm;
	rx = PM_GETRE(pm);
    }

#ifdef PERL_SAWAMPERSAND
    r_flags = (    RX_NPARENS(rx)
                || PL_sawampersand
                || (RX_EXTFLAGS(rx) & (RXf_EVAL_SEEN|RXf_PMf_KEEPCOPY))
                || (rpm->op_pmflags & PMf_KEEPCOPY)
              )
          ? REXEC_COPY_STR
          : 0;
#else
    r_flags = REXEC_COPY_STR;
#endif

    if (!CALLREGEXEC(rx, orig, strend, orig, 0, TARG, NULL, r_flags))
    {
	SPAGAIN;
	PUSHs(rpm->op_pmflags & PMf_NONDESTRUCT ? TARG : &PL_sv_no);
	LEAVE_SCOPE(oldsave);
	RETURN;
    }
    PL_curpm = pm;

    /* known replacement string? */
    if (dstr) {
	/* replacement needing upgrading? */
	if (DO_UTF8(TARG) && !doutf8) {
	     nsv = sv_newmortal();
	     SvSetSV(nsv, dstr);
	     if (IN_ENCODING)
		  sv_recode_to_utf8(nsv, _get_encoding());
	     else
		  sv_utf8_upgrade(nsv);
	     c = SvPV_const(nsv, clen);
	     doutf8 = TRUE;
	}
	else {
	    c = SvPV_const(dstr, clen);
	    doutf8 = DO_UTF8(dstr);
	}

	if (SvTAINTED(dstr))
	    rxtainted |= SUBST_TAINT_REPL;
    }
    else {
	c = NULL;
	doutf8 = FALSE;
    }
    
    /* can do inplace substitution? */
    if (c
#ifdef PERL_ANY_COW
	&& !was_cow
#endif
        && (I32)clen <= RX_MINLENRET(rx)
        && (  once
           || !(r_flags & REXEC_COPY_STR)
           || (!SvGMAGICAL(dstr) && !(RX_EXTFLAGS(rx) & RXf_EVAL_SEEN))
           )
        && !(RX_EXTFLAGS(rx) & RXf_NO_INPLACE_SUBST)
	&& (!doutf8 || SvUTF8(TARG))
	&& !(rpm->op_pmflags & PMf_NONDESTRUCT))
    {

#ifdef PERL_ANY_COW
        /* string might have got converted to COW since we set was_cow */
	if (SvIsCOW(TARG)) {
	  if (!force_on_match)
	    goto have_a_cow;
	  assert(SvVOK(TARG));
	}
#endif
	if (force_on_match) {
            /* redo the first match, this time with the orig var
             * forced into being a string */
	    force_on_match = 0;
	    orig = SvPV_force_nomg(TARG, len);
	    goto force_it;
	}

	if (once) {
            char *d, *m;
	    if (RX_MATCH_TAINTED(rx)) /* run time pattern taint, eg locale */
		rxtainted |= SUBST_TAINT_PAT;
	    m = orig + RX_OFFS(rx)[0].start;
	    d = orig + RX_OFFS(rx)[0].end;
	    s = orig;
	    if (m - s > strend - d) {  /* faster to shorten from end */
                I32 i;
		if (clen) {
		    Copy(c, m, clen, char);
		    m += clen;
		}
		i = strend - d;
		if (i > 0) {
		    Move(d, m, i, char);
		    m += i;
		}
		*m = '\0';
		SvCUR_set(TARG, m - s);
	    }
	    else {	/* faster from front */
                I32 i = m - s;
		d -= clen;
                if (i > 0)
                    Move(s, d - i, i, char);
		sv_chop(TARG, d-i);
		if (clen)
		    Copy(c, d, clen, char);
	    }
	    SPAGAIN;
	    PUSHs(&PL_sv_yes);
	}
	else {
            char *d, *m;
            d = s = RX_OFFS(rx)[0].start + orig;
	    do {
                I32 i;
		if (UNLIKELY(iters++ > maxiters))
		    DIE(aTHX_ "Substitution loop");
		if (UNLIKELY(RX_MATCH_TAINTED(rx))) /* run time pattern taint, eg locale */
		    rxtainted |= SUBST_TAINT_PAT;
		m = RX_OFFS(rx)[0].start + orig;
		if ((i = m - s)) {
		    if (s != d)
			Move(s, d, i, char);
		    d += i;
		}
		if (clen) {
		    Copy(c, d, clen, char);
		    d += clen;
		}
		s = RX_OFFS(rx)[0].end + orig;
	    } while (CALLREGEXEC(rx, s, strend, orig,
				 s == m, /* don't match same null twice */
				 TARG, NULL,
                     REXEC_NOT_FIRST|REXEC_IGNOREPOS|REXEC_FAIL_ON_UNDERFLOW));
	    if (s != d) {
                I32 i = strend - s;
		SvCUR_set(TARG, d - SvPVX_const(TARG) + i);
		Move(s, d, i+1, char);		/* include the NUL */
	    }
	    SPAGAIN;
	    mPUSHi(iters);
	}
    }
    else {
	bool first;
        char *m;
	SV *repl;
	if (force_on_match) {
            /* redo the first match, this time with the orig var
             * forced into being a string */
	    force_on_match = 0;
	    if (rpm->op_pmflags & PMf_NONDESTRUCT) {
		/* I feel that it should be possible to avoid this mortal copy
		   given that the code below copies into a new destination.
		   However, I suspect it isn't worth the complexity of
		   unravelling the C<goto force_it> for the small number of
		   cases where it would be viable to drop into the copy code. */
		TARG = sv_2mortal(newSVsv(TARG));
	    }
	    orig = SvPV_force_nomg(TARG, len);
	    goto force_it;
	}
#ifdef PERL_ANY_COW
      have_a_cow:
#endif
	if (RX_MATCH_TAINTED(rx)) /* run time pattern taint, eg locale */
	    rxtainted |= SUBST_TAINT_PAT;
	repl = dstr;
        s = RX_OFFS(rx)[0].start + orig;
	dstr = newSVpvn_flags(orig, s-orig,
                    SVs_TEMP | (DO_UTF8(TARG) ? SVf_UTF8 : 0));
	if (!c) {
	    PERL_CONTEXT *cx;
	    SPAGAIN;
            m = orig;
	    /* note that a whole bunch of local vars are saved here for
	     * use by pp_substcont: here's a list of them in case you're
	     * searching for places in this sub that uses a particular var:
	     * iters maxiters r_flags oldsave rxtainted orig dstr targ
	     * s m strend rx once */
	    CX_PUSHSUBST(cx);
	    RETURNOP(cPMOP->op_pmreplrootu.op_pmreplroot);
	}
	first = TRUE;
	do {
	    if (UNLIKELY(iters++ > maxiters))
		DIE(aTHX_ "Substitution loop");
	    if (UNLIKELY(RX_MATCH_TAINTED(rx)))
		rxtainted |= SUBST_TAINT_PAT;
	    if (RX_MATCH_COPIED(rx) && RX_SUBBEG(rx) != orig) {
		char *old_s    = s;
		char *old_orig = orig;
                assert(RX_SUBOFFSET(rx) == 0);

		orig = RX_SUBBEG(rx);
		s = orig + (old_s - old_orig);
		strend = s + (strend - old_s);
	    }
	    m = RX_OFFS(rx)[0].start + orig;
	    sv_catpvn_nomg_maybeutf8(dstr, s, m - s, DO_UTF8(TARG));
	    s = RX_OFFS(rx)[0].end + orig;
	    if (first) {
		/* replacement already stringified */
	      if (clen)
		sv_catpvn_nomg_maybeutf8(dstr, c, clen, doutf8);
	      first = FALSE;
	    }
	    else {
		if (IN_ENCODING) {
		    if (!nsv) nsv = sv_newmortal();
		    sv_copypv(nsv, repl);
		    if (!DO_UTF8(nsv)) sv_recode_to_utf8(nsv, _get_encoding());
		    sv_catsv(dstr, nsv);
		}
		else sv_catsv(dstr, repl);
		if (UNLIKELY(SvTAINTED(repl)))
		    rxtainted |= SUBST_TAINT_REPL;
	    }
	    if (once)
		break;
	} while (CALLREGEXEC(rx, s, strend, orig,
                             s == m,    /* Yields minend of 0 or 1 */
			     TARG, NULL,
                    REXEC_NOT_FIRST|REXEC_IGNOREPOS|REXEC_FAIL_ON_UNDERFLOW));
        assert(strend >= s);
	sv_catpvn_nomg_maybeutf8(dstr, s, strend - s, DO_UTF8(TARG));

	if (rpm->op_pmflags & PMf_NONDESTRUCT) {
	    /* From here on down we're using the copy, and leaving the original
	       untouched.  */
	    TARG = dstr;
	    SPAGAIN;
	    PUSHs(dstr);
	} else {
#ifdef PERL_ANY_COW
	    /* The match may make the string COW. If so, brilliant, because
	       that's just saved us one malloc, copy and free - the regexp has
	       donated the old buffer, and we malloc an entirely new one, rather
	       than the regexp malloc()ing a buffer and copying our original,
	       only for us to throw it away here during the substitution.  */
	    if (SvIsCOW(TARG)) {
		sv_force_normal_flags(TARG, SV_COW_DROP_PV);
	    } else
#endif
	    {
		SvPV_free(TARG);
	    }
	    SvPV_set(TARG, SvPVX(dstr));
	    SvCUR_set(TARG, SvCUR(dstr));
	    SvLEN_set(TARG, SvLEN(dstr));
	    SvFLAGS(TARG) |= SvUTF8(dstr);
	    SvPV_set(dstr, NULL);

	    SPAGAIN;
	    mPUSHi(iters);
	}
    }

    if (!(rpm->op_pmflags & PMf_NONDESTRUCT)) {
	(void)SvPOK_only_UTF8(TARG);
    }

    /* See "how taint works" above */
    if (TAINTING_get) {
	if ((rxtainted & SUBST_TAINT_PAT) ||
	    ((rxtainted & (SUBST_TAINT_STR|SUBST_TAINT_RETAINT)) ==
				(SUBST_TAINT_STR|SUBST_TAINT_RETAINT))
	)
	    (RX_MATCH_TAINTED_on(rx)); /* taint $1 et al */

	if (!(rxtainted & SUBST_TAINT_BOOLRET)
	    && (rxtainted & (SUBST_TAINT_STR|SUBST_TAINT_PAT))
	)
	    SvTAINTED_on(TOPs);  /* taint return value */
	else
	    SvTAINTED_off(TOPs);  /* may have got tainted earlier */

	/* needed for mg_set below */
	TAINT_set(
	  cBOOL(rxtainted & (SUBST_TAINT_STR|SUBST_TAINT_PAT|SUBST_TAINT_REPL))
        );
	SvTAINT(TARG);
    }
    SvSETMAGIC(TARG); /* PL_tainted must be correctly set for this mg_set */
    TAINT_NOT;
    LEAVE_SCOPE(oldsave);
    RETURN;
}

PP(pp_grepwhile)
{
    dSP;

    if (SvTRUEx(POPs))
	PL_stack_base[PL_markstack_ptr[-1]++] = PL_stack_base[*PL_markstack_ptr];
    ++*PL_markstack_ptr;
    FREETMPS;
    LEAVE_with_name("grep_item");					/* exit inner scope */

    /* All done yet? */
    if (UNLIKELY(PL_stack_base + *PL_markstack_ptr > SP)) {
	I32 items;
	const U8 gimme = GIMME_V;

	LEAVE_with_name("grep");					/* exit outer scope */
	(void)POPMARK;				/* pop src */
	items = --*PL_markstack_ptr - PL_markstack_ptr[-1];
	(void)POPMARK;				/* pop dst */
	SP = PL_stack_base + POPMARK;		/* pop original mark */
	if (gimme == G_SCALAR) {
		dTARGET;
		XPUSHi(items);
	}
	else if (gimme == G_ARRAY)
	    SP += items;
	RETURN;
    }
    else {
	SV *src;

	ENTER_with_name("grep_item");					/* enter inner scope */
	SAVEVPTR(PL_curpm);

	src = PL_stack_base[TOPMARK];
	if (SvPADTMP(src)) {
	    src = PL_stack_base[TOPMARK] = sv_mortalcopy(src);
	    PL_tmps_floor++;
	}
	SvTEMP_off(src);
	DEFSV_set(src);

	RETURNOP(cLOGOP->op_other);
    }
}

/* leave_adjust_stacks():
 *
 * Process a scope's return args (in the range from_sp+1 .. PL_stack_sp),
 * positioning them at to_sp+1 onwards, and do the equivalent of a
 * FREEMPS and TAINT_NOT.
 *
 * Not intended to be called in void context.
 *
 * When leaving a sub, eval, do{} or other scope, the things that need
 * doing to process the return args are:
 *    * in scalar context, only return the last arg (or PL_sv_undef if none);
 *    * for the types of return that return copies of their args (such
 *      as rvalue sub return), make a mortal copy of every return arg,
 *      except where we can optimise the copy away without it being
 *      semantically visible;
 *    * make sure that the arg isn't prematurely freed; in the case of an
 *      arg not copied, this may involve mortalising it. For example, in
 *      C<sub f { my $x = ...; $x }>, $x would be freed when we do
 *      CX_LEAVE_SCOPE(cx) unless it's protected or copied.
 *
 * What condition to use when deciding whether to pass the arg through
 * or make a copy, is determined by the 'pass' arg; its valid values are:
 *   0: rvalue sub/eval exit
 *   1: other rvalue scope exit
 *   2: :lvalue sub exit in rvalue context
 *   3: :lvalue sub exit in lvalue context and other lvalue scope exits
 *
 * There is a big issue with doing a FREETMPS. We would like to free any
 * temps created by the last statement which the sub executed, rather than
 * leaving them for the caller. In a situation where a sub call isn't
 * soon followed by a nextstate (e.g. nested recursive calls, a la
 * fibonacci()), temps can accumulate, causing memory and performance
 * issues.
 *
 * On the other hand, we don't want to free any TEMPs which are keeping
 * alive any return args that we skipped copying; nor do we wish to undo
 * any mortalising done here.
 *
 * The solution is to split the temps stack frame into two, with a cut
 * point delineating the two halves. We arrange that by the end of this
 * function, all the temps stack frame entries we wish to keep are in the
 * range  PL_tmps_floor+1.. tmps_base-1, while the ones to free now are in
 * the range  tmps_base .. PL_tmps_ix.  During the course of this
 * function, tmps_base starts off as PL_tmps_floor+1, then increases
 * whenever we find or create a temp that we know should be kept. In
 * general the stuff above tmps_base is undecided until we reach the end,
 * and we may need a sort stage for that.
 *
 * To determine whether a TEMP is keeping a return arg alive, every
 * arg that is kept rather than copied and which has the SvTEMP flag
 * set, has the flag temporarily unset, to mark it. At the end we scan
 * the temps stack frame above the cut for entries without SvTEMP and
 * keep them, while turning SvTEMP on again. Note that if we die before
 * the SvTEMPs flags are set again, its safe: at worst, subsequent use of
 * those SVs may be slightly less efficient.
 *
 * In practice various optimisations for some common cases mean we can
 * avoid most of the scanning and swapping about with the temps stack.
 */

void
Perl_leave_adjust_stacks(pTHX_ SV **from_sp, SV **to_sp, U8 gimme, int pass)
{
    dVAR;
    dSP;
    SSize_t tmps_base; /* lowest index into tmps stack that needs freeing now */
    SSize_t nargs;

    PERL_ARGS_ASSERT_LEAVE_ADJUST_STACKS;

    TAINT_NOT;

    if (gimme == G_ARRAY) {
        nargs = SP - from_sp;
        from_sp++;
    }
    else {
        assert(gimme == G_SCALAR);
        if (UNLIKELY(from_sp >= SP)) {
            /* no return args */
            assert(from_sp == SP);
            EXTEND(SP, 1);
            *++SP = &PL_sv_undef;
            to_sp = SP;
            nargs   = 0;
        }
        else {
            from_sp = SP;
            nargs   = 1;
        }
    }

    /* common code for G_SCALAR and G_ARRAY */

    tmps_base = PL_tmps_floor + 1;

    assert(nargs >= 0);
    if (nargs) {
        /* pointer version of tmps_base. Not safe across temp stack
         * reallocs. */
        SV **tmps_basep;

        EXTEND_MORTAL(nargs); /* one big extend for worst-case scenario */
        tmps_basep = PL_tmps_stack + tmps_base;

        /* process each return arg */

        do {
            SV *sv = *from_sp++;

            assert(PL_tmps_ix + nargs < PL_tmps_max);
#ifdef DEBUGGING
            /* PADTMPs with container set magic shouldn't appear in the
             * wild. This assert is more important for pp_leavesublv(),
             * but by testing for it here, we're more likely to catch
             * bad cases (what with :lvalue subs not being widely
             * deployed). The two issues are that for something like
             *     sub :lvalue { $tied{foo} }
             * or
             *     sub :lvalue { substr($foo,1,2) }
             * pp_leavesublv() will croak if the sub returns a PADTMP,
             * and currently functions like pp_substr() return a mortal
             * rather than using their PADTMP when returning a PVLV.
             * This is because the PVLV will hold a ref to $foo,
             * so $foo would get delayed in being freed while
             * the PADTMP SV remained in the PAD.
             * So if this assert fails it means either:
             *  1) there is pp code similar to pp_substr that is
             *     returning a PADTMP instead of a mortal, and probably
             *     needs fixing, or
             *  2) pp_leavesublv is making unwarranted assumptions
             *     about always croaking on a PADTMP
             */
            if (SvPADTMP(sv) && SvSMAGICAL(sv)) {
                MAGIC *mg;
                for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic) {
                    assert(PERL_MAGIC_TYPE_IS_VALUE_MAGIC(mg->mg_type));
                }
            }
#endif

            if (
               pass == 0 ? (SvTEMP(sv) && !SvMAGICAL(sv) && SvREFCNT(sv) == 1)
             : pass == 1 ? ((SvTEMP(sv) || SvPADTMP(sv)) && !SvMAGICAL(sv) && SvREFCNT(sv) == 1)
             : pass == 2 ? (!SvPADTMP(sv))
             : 1)
            {
                /* pass through: skip copy for logic or optimisation
                 * reasons; instead mortalise it, except that ... */
                *++to_sp = sv;

                if (SvTEMP(sv)) {
                    /* ... since this SV is an SvTEMP , we don't need to
                     * re-mortalise it; instead we just need to ensure
                     * that its existing entry in the temps stack frame
                     * ends up below the cut and so avoids being freed
                     * this time round. We mark it as needing to be kept
                     * by temporarily unsetting SvTEMP; then at the end,
                     * we shuffle any !SvTEMP entries on the tmps stack
                     * back below the cut.
                     * However, there's a significant chance that there's
                     * a 1:1 correspondence between the first few (or all)
                     * elements in the return args stack frame and those
                     * in the temps stack frame; e,g.:
                     *      sub f { ....; map {...} .... },
                     * or if we're exiting multiple scopes and one of the
                     * inner scopes has already made mortal copies of each
                     * return arg.
                     *
                     * If so, this arg sv will correspond to the next item
                     * on the tmps stack above the cut, and so can be kept
                     * merely by moving the cut boundary up one, rather
                     * than messing with SvTEMP.  If all args are 1:1 then
                     * we can avoid the sorting stage below completely.
                     *
                     * If there are no items above the cut on the tmps
                     * stack, then the SvTEMP must comne from an item
                     * below the cut, so there's nothing to do.
                     */
                    if (tmps_basep <= &PL_tmps_stack[PL_tmps_ix]) {
                        if (sv == *tmps_basep)
                            tmps_basep++;
                        else
                            SvTEMP_off(sv);
                    }
                }
                else if (!SvPADTMP(sv)) {
                    /* mortalise arg to avoid it being freed during save
                     * stack unwinding. Pad tmps don't need mortalising as
                     * they're never freed. This is the equivalent of
                     * sv_2mortal(SvREFCNT_inc(sv)), except that:
                     *  * it assumes that the temps stack has already been
                     *    extended;
                     *  * it puts the new item at the cut rather than at
                     *    ++PL_tmps_ix, moving the previous occupant there
                     *    instead.
                     */
                    if (!SvIMMORTAL(sv)) {
                        SvREFCNT_inc_simple_void_NN(sv);
                        SvTEMP_on(sv);
                        /* Note that if there's nothing above the cut,
                         * this copies the garbage one slot above
                         * PL_tmps_ix onto itself. This is harmless (the
                         * stack's already been extended), but might in
                         * theory trigger warnings from tools like ASan
                         */
                        PL_tmps_stack[++PL_tmps_ix] = *tmps_basep;
                        *tmps_basep++ = sv;
                    }
                }
            }
            else {
                /* Make a mortal copy of the SV.
                 * The following code is the equivalent of sv_mortalcopy()
                 * except that:
                 *  * it assumes the temps stack has already been extended;
                 *  * it optimises the copying for some simple SV types;
                 *  * it puts the new item at the cut rather than at
                 *    ++PL_tmps_ix, moving the previous occupant there
                 *    instead.
                 */
                SV *newsv = newSV(0);

                PL_tmps_stack[++PL_tmps_ix] = *tmps_basep;
                /* put it on the tmps stack early so it gets freed if we die */
                *tmps_basep++ = newsv;
                *++to_sp = newsv;

                if (SvTYPE(sv) <= SVt_IV) {
                    /* arg must be one of undef, IV/UV, or RV: skip
                     * sv_setsv_flags() and do the copy directly */
                    U32 dstflags;
                    U32 srcflags = SvFLAGS(sv);

                    assert(!SvGMAGICAL(sv));
                    if (srcflags & (SVf_IOK|SVf_ROK)) {
                        SET_SVANY_FOR_BODYLESS_IV(newsv);

                        if (srcflags & SVf_ROK) {
                            newsv->sv_u.svu_rv = SvREFCNT_inc(SvRV(sv));
                            /* SV type plus flags */
                            dstflags = (SVt_IV|SVf_ROK|SVs_TEMP);
                        }
                        else {
                            /* both src and dst are <= SVt_IV, so sv_any
                             * points to the head; so access the heads
                             * directly rather than going via sv_any.
                             */
                            assert(    &(sv->sv_u.svu_iv)
                                    == &(((XPVIV*) SvANY(sv))->xiv_iv));
                            assert(    &(newsv->sv_u.svu_iv)
                                    == &(((XPVIV*) SvANY(newsv))->xiv_iv));
                            newsv->sv_u.svu_iv = sv->sv_u.svu_iv;
                            /* SV type plus flags */
                            dstflags = (SVt_IV|SVf_IOK|SVp_IOK|SVs_TEMP
                                            |(srcflags & SVf_IVisUV));
                        }
                    }
                    else {
                        assert(!(srcflags & SVf_OK));
                        dstflags = (SVt_NULL|SVs_TEMP); /* SV type plus flags */
                    }
                    SvFLAGS(newsv) = dstflags;

                }
                else {
                    /* do the full sv_setsv() */
                    SSize_t old_base;

                    SvTEMP_on(newsv);
                    old_base = tmps_basep - PL_tmps_stack;
                    SvGETMAGIC(sv);
                    sv_setsv_flags(newsv, sv, SV_DO_COW_SVSETSV);
                    /* the mg_get or sv_setsv might have created new temps
                     * or realloced the tmps stack; regrow and reload */
                    EXTEND_MORTAL(nargs);
                    tmps_basep = PL_tmps_stack + old_base;
                    TAINT_NOT;	/* Each item is independent */
                }

            }
        } while (--nargs);

        /* If there are any temps left above the cut, we need to sort
         * them into those to keep and those to free. The only ones to
         * keep are those for which we've temporarily unset SvTEMP.
         * Work inwards from the two ends at tmps_basep .. PL_tmps_ix,
         * swapping pairs as necessary. Stop when we meet in the middle.
         */
        {
            SV **top = PL_tmps_stack + PL_tmps_ix;
            while (tmps_basep <= top) {
                SV *sv = *top;
                if (SvTEMP(sv))
                    top--;
                else {
                    SvTEMP_on(sv);
                    *top = *tmps_basep;
                    *tmps_basep = sv;
                    tmps_basep++;
                }
            }
        }

        tmps_base = tmps_basep - PL_tmps_stack;
    }

    PL_stack_sp = to_sp;

    /* unrolled FREETMPS() but using tmps_base-1 rather than PL_tmps_floor */
    while (PL_tmps_ix >= tmps_base) {
        SV* const sv = PL_tmps_stack[PL_tmps_ix--];
#ifdef PERL_POISON
        PoisonWith(PL_tmps_stack + PL_tmps_ix + 1, 1, SV *, 0xAB);
#endif
        if (LIKELY(sv)) {
            SvTEMP_off(sv);
            SvREFCNT_dec_NN(sv); /* note, can modify tmps_ix!!! */
        }
    }
}


/* also tail-called by pp_return */

PP(pp_leavesub)
{
    U8 gimme;
    PERL_CONTEXT *cx;
    SV **oldsp;
    OP *retop;

    cx = CX_CUR();
    assert(CxTYPE(cx) == CXt_SUB);

    if (CxMULTICALL(cx)) {
        /* entry zero of a stack is always PL_sv_undef, which
         * simplifies converting a '()' return into undef in scalar context */
        assert(PL_stack_sp > PL_stack_base || *PL_stack_base == &PL_sv_undef);
	return 0;
    }

    gimme = cx->blk_gimme;
    oldsp = PL_stack_base + cx->blk_oldsp; /* last arg of previous frame */

    if (gimme == G_VOID)
        PL_stack_sp = oldsp;
    else
        leave_adjust_stacks(oldsp, oldsp, gimme, 0);

    CX_LEAVE_SCOPE(cx);
    cx_popsub(cx);	/* Stack values are safe: release CV and @@_ ... */
    cx_popblock(cx);
    retop = cx->blk_sub.retop;
    CX_POP(cx);

    return retop;
}


/* clear (if possible) or abandon the current @@_. If 'abandon' is true,
 * forces an abandon */

void
Perl_clear_defarray(pTHX_ AV* av, bool abandon)
{
    const SSize_t fill = AvFILLp(av);

    PERL_ARGS_ASSERT_CLEAR_DEFARRAY;

    if (LIKELY(!abandon && SvREFCNT(av) == 1 && !SvMAGICAL(av))) {
        av_clear(av);
        AvREIFY_only(av);
    }
    else {
        AV *newav = newAV();
        av_extend(newav, fill);
        AvREIFY_only(newav);
        PAD_SVl(0) = MUTABLE_SV(newav);
        SvREFCNT_dec_NN(av);
    }
}


PP(pp_entersub)
{
    dSP; dPOPss;
    GV *gv;
    CV *cv;
    PERL_CONTEXT *cx;
    I32 old_savestack_ix;

    if (UNLIKELY(!sv))
	goto do_die;

    /* Locate the CV to call:
     * - most common case: RV->CV: f(), $ref->():
     *   note that if a sub is compiled before its caller is compiled,
     *   the stash entry will be a ref to a CV, rather than being a GV.
     * - second most common case: CV: $ref->method()
     */

    /* a non-magic-RV -> CV ? */
    if (LIKELY( (SvFLAGS(sv) & (SVf_ROK|SVs_GMG)) == SVf_ROK)) {
        cv = MUTABLE_CV(SvRV(sv));
        if (UNLIKELY(SvOBJECT(cv))) /* might be overloaded */
            goto do_ref;
    }
    else
        cv = MUTABLE_CV(sv);

    /* a CV ? */
    if (UNLIKELY(SvTYPE(cv) != SVt_PVCV)) {
        /* handle all the weird cases */
        switch (SvTYPE(sv)) {
        case SVt_PVLV:
            if (!isGV_with_GP(sv))
                goto do_default;
            /* FALLTHROUGH */
        case SVt_PVGV:
            cv = GvCVu((const GV *)sv);
            if (UNLIKELY(!cv)) {
                HV *stash;
                cv = sv_2cv(sv, &stash, &gv, 0);
                if (!cv) {
                    old_savestack_ix = PL_savestack_ix;
                    goto try_autoload;
                }
            }
            break;

        default:
          do_default:
            SvGETMAGIC(sv);
            if (SvROK(sv)) {
              do_ref:
                if (UNLIKELY(SvAMAGIC(sv))) {
                    sv = amagic_deref_call(sv, to_cv_amg);
                    /* Don't SPAGAIN here.  */
                }
            }
            else {
                const char *sym;
                STRLEN len;
                if (UNLIKELY(!SvOK(sv)))
                    DIE(aTHX_ PL_no_usym, "a subroutine");

                if (UNLIKELY(sv == &PL_sv_yes)) { /* unfound import, ignore */
                    if (PL_op->op_flags & OPf_STACKED) /* hasargs */
                        SP = PL_stack_base + POPMARK;
                    else
                        (void)POPMARK;
                    if (GIMME_V == G_SCALAR)
                        PUSHs(&PL_sv_undef);
                    RETURN;
                }

                sym = SvPV_nomg_const(sv, len);
                if (PL_op->op_private & HINT_STRICT_REFS)
                    DIE(aTHX_ "Can't use string (\"%" SVf32 "\"%s) as a subroutine ref while \"strict refs\" in use", sv, len>32 ? "..." : "");
                cv = get_cvn_flags(sym, len, GV_ADD|SvUTF8(sv));
                break;
            }
            cv = MUTABLE_CV(SvRV(sv));
            if (LIKELY(SvTYPE(cv) == SVt_PVCV))
                break;
            /* FALLTHROUGH */
        case SVt_PVHV:
        case SVt_PVAV:
          do_die:
            DIE(aTHX_ "Not a CODE reference");
        }
    }

    /* At this point we want to save PL_savestack_ix, either by doing a
     * cx_pushsub(), or for XS, doing an ENTER. But we don't yet know the final
     * CV we will be using (so we don't know whether its XS, so we can't
     * cx_pushsub() or ENTER yet), and determining cv may itself push stuff on
     * the save stack. So remember where we are currently on the save
     * stack, and later update the CX or scopestack entry accordingly. */
    old_savestack_ix = PL_savestack_ix;

    /* these two fields are in a union. If they ever become separate,
     * we have to test for both of them being null below */
    assert(cv);
    assert((void*)&CvROOT(cv) == (void*)&CvXSUB(cv));
    while (UNLIKELY(!CvROOT(cv))) {
	GV* autogv;
	SV* sub_name;

	/* anonymous or undef'd function leaves us no recourse */
	if (CvLEXICAL(cv) && CvHASGV(cv))
	    DIE(aTHX_ "Undefined subroutine &%"SVf" called",
		       SVfARG(cv_name(cv, NULL, 0)));
	if (CvANON(cv) || !CvHASGV(cv)) {
	    DIE(aTHX_ "Undefined subroutine called");
	}

	/* autoloaded stub? */
	if (cv != GvCV(gv = CvGV(cv))) {
	    cv = GvCV(gv);
	}
	/* should call AUTOLOAD now? */
	else {
          try_autoload:
	    autogv = gv_autoload_pvn(GvSTASH(gv), GvNAME(gv), GvNAMELEN(gv),
				   GvNAMEUTF8(gv) ? SVf_UTF8 : 0);
            cv = autogv ? GvCV(autogv) : NULL;
	}
	if (!cv) {
            sub_name = sv_newmortal();
            gv_efullname3(sub_name, gv, NULL);
            DIE(aTHX_ "Undefined subroutine &%"SVf" called", SVfARG(sub_name));
        }
    }

    /* unrolled "CvCLONE(cv) && ! CvCLONED(cv)" */
    if (UNLIKELY((CvFLAGS(cv) & (CVf_CLONE|CVf_CLONED)) == CVf_CLONE))
	DIE(aTHX_ "Closure prototype called");

    if (UNLIKELY((PL_op->op_private & OPpENTERSUB_DB) && GvCV(PL_DBsub)
            && !CvNODEBUG(cv)))
    {
	 Perl_get_db_sub(aTHX_ &sv, cv);
	 if (CvISXSUB(cv))
	     PL_curcopdb = PL_curcop;
         if (CvLVALUE(cv)) {
             /* check for lsub that handles lvalue subroutines */
	     cv = GvCV(gv_fetchpvs("DB::lsub", GV_ADDMULTI, SVt_PVCV));
             /* if lsub not found then fall back to DB::sub */
	     if (!cv) cv = GvCV(PL_DBsub);
         } else {
             cv = GvCV(PL_DBsub);
         }

	if (!cv || (!CvXSUB(cv) && !CvSTART(cv)))
	    DIE(aTHX_ "No DB::sub routine defined");
    }

    if (!(CvISXSUB(cv))) {
	/* This path taken at least 75% of the time   */
	dMARK;
	PADLIST *padlist;
        I32 depth;
        bool hasargs;
        U8 gimme;

        /* keep PADTMP args alive throughout the call (we need to do this
         * because @@_ isn't refcounted). Note that we create the mortals
         * in the caller's tmps frame, so they won't be freed until after
         * we return from the sub.
         */
	{
            SV **svp = MARK;
            while (svp < SP) {
                SV *sv = *++svp;
                if (!sv)
                    continue;
                if (SvPADTMP(sv))
                    *svp = sv = sv_mortalcopy(sv);
                SvTEMP_off(sv);
	    }
        }

        gimme = GIMME_V;
	cx = cx_pushblock(CXt_SUB, gimme, MARK, old_savestack_ix);
        hasargs = cBOOL(PL_op->op_flags & OPf_STACKED);
	cx_pushsub(cx, cv, PL_op->op_next, hasargs);

	padlist = CvPADLIST(cv);
	if (UNLIKELY((depth = ++CvDEPTH(cv)) >= 2))
	    pad_push(padlist, depth);
	PAD_SET_CUR_NOSAVE(padlist, depth);
	if (LIKELY(hasargs)) {
	    AV *const av = MUTABLE_AV(PAD_SVl(0));
            SSize_t items;
            AV **defavp;

	    defavp = &GvAV(PL_defgv);
	    cx->blk_sub.savearray = *defavp;
	    *defavp = MUTABLE_AV(SvREFCNT_inc_simple_NN(av));

            /* it's the responsibility of whoever leaves a sub to ensure
             * that a clean, empty AV is left in pad[0]. This is normally
             * done by cx_popsub() */
            assert(!AvREAL(av) && AvFILLp(av) == -1);

            items = SP - MARK;
	    if (UNLIKELY(items - 1 > AvMAX(av))) {
                SV **ary = AvALLOC(av);
                AvMAX(av) = items - 1;
                Renew(ary, items, SV*);
                AvALLOC(av) = ary;
                AvARRAY(av) = ary;
            }

	    Copy(MARK+1,AvARRAY(av),items,SV*);
	    AvFILLp(av) = items - 1;
	}
	if (UNLIKELY((cx->blk_u16 & OPpENTERSUB_LVAL_MASK) == OPpLVAL_INTRO &&
	    !CvLVALUE(cv)))
            DIE(aTHX_ "Can't modify non-lvalue subroutine call of &%"SVf,
                SVfARG(cv_name(cv, NULL, 0)));
	/* warning must come *after* we fully set up the context
	 * stuff so that __WARN__ handlers can safely dounwind()
	 * if they want to
	 */
	if (UNLIKELY(depth == PERL_SUB_DEPTH_WARN
                && ckWARN(WARN_RECURSION)
                && !(PERLDB_SUB && cv == GvCV(PL_DBsub))))
	    sub_crush_depth(cv);
	RETURNOP(CvSTART(cv));
    }
    else {
	SSize_t markix = TOPMARK;
        bool is_scalar;

        ENTER;
        /* pretend we did the ENTER earlier */
	PL_scopestack[PL_scopestack_ix - 1] = old_savestack_ix;

	SAVETMPS;
	PUTBACK;

	if (UNLIKELY(((PL_op->op_private
	       & CX_PUSHSUB_GET_LVALUE_MASK(Perl_is_lvalue_sub)
             ) & OPpENTERSUB_LVAL_MASK) == OPpLVAL_INTRO &&
	    !CvLVALUE(cv)))
            DIE(aTHX_ "Can't modify non-lvalue subroutine call of &%"SVf,
                SVfARG(cv_name(cv, NULL, 0)));

	if (UNLIKELY(!(PL_op->op_flags & OPf_STACKED) && GvAV(PL_defgv))) {
	    /* Need to copy @@_ to stack. Alternative may be to
	     * switch stack to @@_, and copy return values
	     * back. This would allow popping @@_ in XSUB, e.g.. XXXX */
	    AV * const av = GvAV(PL_defgv);
	    const SSize_t items = AvFILL(av) + 1;

	    if (items) {
		SSize_t i = 0;
		const bool m = cBOOL(SvRMAGICAL(av));
		/* Mark is at the end of the stack. */
		EXTEND(SP, items);
		for (; i < items; ++i)
		{
		    SV *sv;
		    if (m) {
			SV ** const svp = av_fetch(av, i, 0);
			sv = svp ? *svp : NULL;
		    }
		    else sv = AvARRAY(av)[i];
		    if (sv) SP[i+1] = sv;
		    else {
			SP[i+1] = newSVavdefelem(av, i, 1);
		    }
		}
		SP += items;
		PUTBACK ;		
	    }
	}
	else {
	    SV **mark = PL_stack_base + markix;
	    SSize_t items = SP - mark;
	    while (items--) {
		mark++;
		if (*mark && SvPADTMP(*mark)) {
		    *mark = sv_mortalcopy(*mark);
                }
	    }
	}
	/* We assume first XSUB in &DB::sub is the called one. */
	if (UNLIKELY(PL_curcopdb)) {
	    SAVEVPTR(PL_curcop);
	    PL_curcop = PL_curcopdb;
	    PL_curcopdb = NULL;
	}
	/* Do we need to open block here? XXXX */

        /* calculate gimme here as PL_op might get changed and then not
         * restored until the LEAVE further down */
        is_scalar = (GIMME_V == G_SCALAR);

	/* CvXSUB(cv) must not be NULL because newXS() refuses NULL xsub address */
	assert(CvXSUB(cv));
	CvXSUB(cv)(aTHX_ cv);

	/* Enforce some sanity in scalar context. */
	if (is_scalar) {
            SV **svp = PL_stack_base + markix + 1;
            if (svp != PL_stack_sp) {
                *svp = svp > PL_stack_sp ? &PL_sv_undef : *PL_stack_sp;
                PL_stack_sp = svp;
            }
	}
	LEAVE;
	return NORMAL;
    }
}

void
Perl_sub_crush_depth(pTHX_ CV *cv)
{
    PERL_ARGS_ASSERT_SUB_CRUSH_DEPTH;

    if (CvANON(cv))
	Perl_warner(aTHX_ packWARN(WARN_RECURSION), "Deep recursion on anonymous subroutine");
    else {
	Perl_warner(aTHX_ packWARN(WARN_RECURSION), "Deep recursion on subroutine \"%"SVf"\"",
		    SVfARG(cv_name(cv,NULL,0)));
    }
}

PP(pp_aelem)
{
    dSP;
    SV** svp;
    SV* const elemsv = POPs;
    IV elem = SvIV(elemsv);
    AV *const av = MUTABLE_AV(POPs);
    const U32 lval = PL_op->op_flags & OPf_MOD || LVRET;
    const U32 defer = PL_op->op_private & OPpLVAL_DEFER;
    const bool localizing = PL_op->op_private & OPpLVAL_INTRO;
    bool preeminent = TRUE;
    SV *sv;

    if (UNLIKELY(SvROK(elemsv) && !SvGAMAGIC(elemsv) && ckWARN(WARN_MISC)))
	Perl_warner(aTHX_ packWARN(WARN_MISC),
		    "Use of reference \"%"SVf"\" as array index",
		    SVfARG(elemsv));
    if (UNLIKELY(SvTYPE(av) != SVt_PVAV))
	RETPUSHUNDEF;

    if (UNLIKELY(localizing)) {
	MAGIC *mg;
	HV *stash;

	/* If we can determine whether the element exist,
	 * Try to preserve the existenceness of a tied array
	 * element by using EXISTS and DELETE if possible.
	 * Fallback to FETCH and STORE otherwise. */
	if (SvCANEXISTDELETE(av))
	    preeminent = av_exists(av, elem);
    }

    svp = av_fetch(av, elem, lval && !defer);
    if (lval) {
#ifdef PERL_MALLOC_WRAP
	 if (SvUOK(elemsv)) {
	      const UV uv = SvUV(elemsv);
	      elem = uv > IV_MAX ? IV_MAX : uv;
	 }
	 else if (SvNOK(elemsv))
	      elem = (IV)SvNV(elemsv);
	 if (elem > 0) {
	      static const char oom_array_extend[] =
		"Out of memory during array extend"; /* Duplicated in av.c */
	      MEM_WRAP_CHECK_1(elem,SV*,oom_array_extend);
	 }
#endif
	if (!svp || !*svp) {
	    IV len;
	    if (!defer)
		DIE(aTHX_ PL_no_aelem, elem);
	    len = av_tindex(av);
	    mPUSHs(newSVavdefelem(av,
	    /* Resolve a negative index now, unless it points before the
	       beginning of the array, in which case record it for error
	       reporting in magic_setdefelem. */
		elem < 0 && len + elem >= 0 ? len + elem : elem,
		1));
	    RETURN;
	}
	if (UNLIKELY(localizing)) {
	    if (preeminent)
		save_aelem(av, elem, svp);
	    else
		SAVEADELETE(av, elem);
	}
	else if (PL_op->op_private & OPpDEREF) {
	    PUSHs(vivify_ref(*svp, PL_op->op_private & OPpDEREF));
	    RETURN;
	}
    }
    sv = (svp ? *svp : &PL_sv_undef);
    if (!lval && SvRMAGICAL(av) && SvGMAGICAL(sv)) /* see note in pp_helem() */
	mg_get(sv);
    PUSHs(sv);
    RETURN;
}

SV*
Perl_vivify_ref(pTHX_ SV *sv, U32 to_what)
{
    PERL_ARGS_ASSERT_VIVIFY_REF;

    SvGETMAGIC(sv);
    if (!SvOK(sv)) {
	if (SvREADONLY(sv))
	    Perl_croak_no_modify();
	prepare_SV_for_RV(sv);
	switch (to_what) {
	case OPpDEREF_SV:
	    SvRV_set(sv, newSV(0));
	    break;
	case OPpDEREF_AV:
	    SvRV_set(sv, MUTABLE_SV(newAV()));
	    break;
	case OPpDEREF_HV:
	    SvRV_set(sv, MUTABLE_SV(newHV()));
	    break;
	}
	SvROK_on(sv);
	SvSETMAGIC(sv);
	SvGETMAGIC(sv);
    }
    if (SvGMAGICAL(sv)) {
	/* copy the sv without magic to prevent magic from being
	   executed twice */
	SV* msv = sv_newmortal();
	sv_setsv_nomg(msv, sv);
	return msv;
    }
    return sv;
}

PERL_STATIC_INLINE HV *
S_opmethod_stash(pTHX_ SV* meth)
{
    SV* ob;
    HV* stash;

    SV* const sv = PL_stack_base + TOPMARK == PL_stack_sp
	? (Perl_croak(aTHX_ "Can't call method \"%"SVf"\" without a "
			    "package or object reference", SVfARG(meth)),
	   (SV *)NULL)
	: *(PL_stack_base + TOPMARK + 1);

    PERL_ARGS_ASSERT_OPMETHOD_STASH;

    if (UNLIKELY(!sv))
       undefined:
	Perl_croak(aTHX_ "Can't call method \"%"SVf"\" on an undefined value",
		   SVfARG(meth));

    if (UNLIKELY(SvGMAGICAL(sv))) mg_get(sv);
    else if (SvIsCOW_shared_hash(sv)) { /* MyClass->meth() */
	stash = gv_stashsv(sv, GV_CACHE_ONLY);
	if (stash) return stash;
    }

    if (SvROK(sv))
	ob = MUTABLE_SV(SvRV(sv));
    else if (!SvOK(sv)) goto undefined;
    else if (isGV_with_GP(sv)) {
	if (!GvIO(sv))
	    Perl_croak(aTHX_ "Can't call method \"%"SVf"\" "
			     "without a package or object reference",
			      SVfARG(meth));
	ob = sv;
	if (SvTYPE(ob) == SVt_PVLV && LvTYPE(ob) == 'y') {
	    assert(!LvTARGLEN(ob));
	    ob = LvTARG(ob);
	    assert(ob);
	}
	*(PL_stack_base + TOPMARK + 1) = sv_2mortal(newRV(ob));
    }
    else {
	/* this isn't a reference */
	GV* iogv;
        STRLEN packlen;
        const char * const packname = SvPV_nomg_const(sv, packlen);
        const U32 packname_utf8 = SvUTF8(sv);
        stash = gv_stashpvn(packname, packlen, packname_utf8 | GV_CACHE_ONLY);
        if (stash) return stash;

	if (!(iogv = gv_fetchpvn_flags(
	        packname, packlen, packname_utf8, SVt_PVIO
	     )) ||
	    !(ob=MUTABLE_SV(GvIO(iogv))))
	{
	    /* this isn't the name of a filehandle either */
	    if (!packlen)
	    {
		Perl_croak(aTHX_ "Can't call method \"%"SVf"\" "
				 "without a package or object reference",
				  SVfARG(meth));
	    }
	    /* assume it's a package name */
	    stash = gv_stashpvn(packname, packlen, packname_utf8);
	    if (stash) return stash;
	    else return MUTABLE_HV(sv);
	}
	/* it _is_ a filehandle name -- replace with a reference */
	*(PL_stack_base + TOPMARK + 1) = sv_2mortal(newRV(MUTABLE_SV(iogv)));
    }

    /* if we got here, ob should be an object or a glob */
    if (!ob || !(SvOBJECT(ob)
		 || (isGV_with_GP(ob)
		     && (ob = MUTABLE_SV(GvIO((const GV *)ob)))
		     && SvOBJECT(ob))))
    {
	Perl_croak(aTHX_ "Can't call method \"%"SVf"\" on unblessed reference",
		   SVfARG((SvSCREAM(meth) && strEQ(SvPV_nolen_const(meth),"isa"))
                                        ? newSVpvs_flags("DOES", SVs_TEMP)
                                        : meth));
    }

    return SvSTASH(ob);
}

PP(pp_method)
{
    dSP;
    GV* gv;
    HV* stash;
    SV* const meth = TOPs;

    if (SvROK(meth)) {
        SV* const rmeth = SvRV(meth);
        if (SvTYPE(rmeth) == SVt_PVCV) {
            SETs(rmeth);
            RETURN;
        }
    }

    stash = opmethod_stash(meth);

    gv = gv_fetchmethod_sv_flags(stash, meth, GV_AUTOLOAD|GV_CROAK);
    assert(gv);

    SETs(isGV(gv) ? MUTABLE_SV(GvCV(gv)) : MUTABLE_SV(gv));
    RETURN;
}

#define METHOD_CHECK_CACHE(stash,cache,meth) 				\
    const HE* const he = hv_fetch_ent(cache, meth, 0, 0);		\
    if (he) {								\
        gv = MUTABLE_GV(HeVAL(he));					\
        if (isGV(gv) && GvCV(gv) && (!GvCVGEN(gv) || GvCVGEN(gv)	\
             == (PL_sub_generation + HvMROMETA(stash)->cache_gen)))	\
        {								\
            XPUSHs(MUTABLE_SV(GvCV(gv)));				\
            RETURN;							\
        }								\
    }									\

PP(pp_method_named)
{
    dSP;
    GV* gv;
    SV* const meth = cMETHOPx_meth(PL_op);
    HV* const stash = opmethod_stash(meth);

    if (LIKELY(SvTYPE(stash) == SVt_PVHV)) {
        METHOD_CHECK_CACHE(stash, stash, meth);
    }

    gv = gv_fetchmethod_sv_flags(stash, meth, GV_AUTOLOAD|GV_CROAK);
    assert(gv);

    XPUSHs(isGV(gv) ? MUTABLE_SV(GvCV(gv)) : MUTABLE_SV(gv));
    RETURN;
}

PP(pp_method_super)
{
    dSP;
    GV* gv;
    HV* cache;
    SV* const meth = cMETHOPx_meth(PL_op);
    HV* const stash = CopSTASH(PL_curcop);
    /* Actually, SUPER doesn't need real object's (or class') stash at all,
     * as it uses CopSTASH. However, we must ensure that object(class) is
     * correct (this check is done by S_opmethod_stash) */
    opmethod_stash(meth);

    if ((cache = HvMROMETA(stash)->super)) {
        METHOD_CHECK_CACHE(stash, cache, meth);
    }

    gv = gv_fetchmethod_sv_flags(stash, meth, GV_AUTOLOAD|GV_CROAK|GV_SUPER);
    assert(gv);

    XPUSHs(isGV(gv) ? MUTABLE_SV(GvCV(gv)) : MUTABLE_SV(gv));
    RETURN;
}

PP(pp_method_redir)
{
    dSP;
    GV* gv;
    SV* const meth = cMETHOPx_meth(PL_op);
    HV* stash = gv_stashsv(cMETHOPx_rclass(PL_op), 0);
    opmethod_stash(meth); /* not used but needed for error checks */

    if (stash) { METHOD_CHECK_CACHE(stash, stash, meth); }
    else stash = MUTABLE_HV(cMETHOPx_rclass(PL_op));

    gv = gv_fetchmethod_sv_flags(stash, meth, GV_AUTOLOAD|GV_CROAK);
    assert(gv);

    XPUSHs(isGV(gv) ? MUTABLE_SV(GvCV(gv)) : MUTABLE_SV(gv));
    RETURN;
}

PP(pp_method_redir_super)
{
    dSP;
    GV* gv;
    HV* cache;
    SV* const meth = cMETHOPx_meth(PL_op);
    HV* stash = gv_stashsv(cMETHOPx_rclass(PL_op), 0);
    opmethod_stash(meth); /* not used but needed for error checks */

    if (UNLIKELY(!stash)) stash = MUTABLE_HV(cMETHOPx_rclass(PL_op));
    else if ((cache = HvMROMETA(stash)->super)) {
         METHOD_CHECK_CACHE(stash, cache, meth);
    }

    gv = gv_fetchmethod_sv_flags(stash, meth, GV_AUTOLOAD|GV_CROAK|GV_SUPER);
    assert(gv);

    XPUSHs(isGV(gv) ? MUTABLE_SV(GvCV(gv)) : MUTABLE_SV(gv));
    RETURN;
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.17
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a41 1
    dVAR;
a48 1
    dVAR;
d51 1
a51 1
    PL_stack_sp = PL_stack_base + cxstack[cxstack_ix].blk_oldsp;
a58 1
    dVAR;
d68 3
a72 1
    dVAR;
d76 2
a77 1
/* This is sometimes called directly by pp_coreargs and pp_grepstart. */
a79 1
    dVAR;
d86 1
a86 1
    dVAR; dSP; dTARGET;
d97 1
a97 1
    dVAR; dSP;
d102 3
a106 1
    dVAR;
d127 1
a127 1
    dVAR; dSP;
d137 2
a138 1
    if (TAINTING_get && UNLIKELY(TAINT_get) && !SvTAINTED(right))
d212 1
a212 1
		SvREFCNT_inc_void(source);
d233 1
a233 1
    dVAR; dSP;
d243 1
a243 1
    dVAR;
d246 2
a247 1
    PL_stack_sp = PL_stack_base + cxstack[cxstack_ix].blk_oldsp;
d250 2
a251 2
	I32 oldsave = PL_scopestack[PL_scopestack_ix - 1];
	LEAVE_SCOPE(oldsave);
d258 1
a258 1
  dVAR; dSP; dATARGET; tryAMAGICbin_MG(concat_amg, AMGf_assign);
a299 3
	if (left == right)
	    /* $r.$r: do magic twice: tied might return different 2nd time */
	    SvGETMAGIC(right);
a303 2
	/* sv_utf8_upgrade_nomg() may reallocate the stack */
	PUTBACK;
a311 1
	SPAGAIN;
d357 1
a357 1
    dVAR; dSP;
d381 1
a381 1
        assert(OPpPADRANGE_COUNTMASK + 1 == (1 <<OPpPADRANGE_COUNTSHIFT));
d398 1
a398 1
    dVAR; dSP;
a427 1
    dVAR;
d444 4
d455 1
a455 1
    dVAR; dSP;
d469 3
d474 28
a501 7
    dVAR; dSP;
    const bool inc =
	PL_op->op_type == OP_PREINC || PL_op->op_type == OP_I_PREINC;
    if (UNLIKELY(SvTYPE(TOPs) >= SVt_PVAV || (isGV_with_GP(TOPs) && !SvFAKE(TOPs))))
	Perl_croak_no_modify();
    if (LIKELY(!SvREADONLY(TOPs) && !SvGMAGICAL(TOPs) && SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs))
        && SvIVX(TOPs) != (inc ? IV_MAX : IV_MIN))
d503 1
a503 2
	SvIV_set(TOPs, SvIVX(TOPs) + (inc ? 1 : -1));
	SvFLAGS(TOPs) &= ~(SVp_NOK|SVp_POK);
d505 3
a507 4
    else /* Do all the PERL_PRESERVE_IVUV conditionals in sv_inc */
	if (inc) sv_inc(TOPs);
	else sv_dec(TOPs);
    SvSETMAGIC(TOPs);
d511 3
d516 1
a516 1
    dVAR; dSP;
d527 3
d532 1
a532 1
    dVAR; dSP;
d588 2
d592 2
a593 1
    dVAR; dSP; dATARGET; bool useleft; SV *svl, *svr;
d598 50
a648 1
#ifdef PERL_PRESERVE_IVUV
d719 2
a720 2
		    } else { /* 2s complement assumption for IV_MIN */
			auv = (UV)-aiv;
d740 1
a740 1
		    buv = (UV)-biv;
d781 2
a782 1
			SETi( -(IV)result );
d792 3
d796 1
d810 3
d815 1
a815 1
    dVAR; dSP;
d834 1
a834 1
    dVAR; dSP; dMARK; dTARGET;
d844 1
a844 1
    dVAR; dSP;
d863 2
d867 1
a867 1
    dVAR; dSP; dMARK; dORIGMARK;
d959 4
d965 2
a966 2
    dVAR; dSP; dTOPss;
    const I32 gimme = GIMME_V;
d969 2
a970 1
    const bool is_pp_rv2av = PL_op->op_type == OP_RV2AV;
d1018 1
a1018 3
	/* The guts of pp_rv2av, with no intending change to preserve history
	   (until such time as we get tools that can do blame annotation across
	   whitespace changes.  */
a1057 2
    dVAR;

d1078 162
d1254 1
a1254 1
    I32 gimme;
d1258 7
a1264 1
    U32 lval = 0;
a1266 3
    gimme = GIMME_V;
    if (gimme == G_ARRAY)
        lval = PL_op->op_flags & OPf_MOD || LVRET;
a1270 1
     * Don't bother if LHS is just an empty hash or array.
d1273 42
a1314 29
    if (    (PL_op->op_private & OPpASSIGN_COMMON)
	&&  (
	       firstlelem != lastlelem
	    || ! ((sv = *firstlelem))
	    || SvMAGICAL(sv)
	    || ! (SvTYPE(sv) == SVt_PVAV || SvTYPE(sv) == SVt_PVHV)
	    || (SvTYPE(sv) == SVt_PVAV && AvFILL((AV*)sv) != -1)
	    || (SvTYPE(sv) == SVt_PVHV && HvUSEDKEYS((HV*)sv) != 0)
	    )
    ) {
	EXTEND_MORTAL(lastrelem - firstrelem + 1);
	for (relem = firstrelem; relem <= lastrelem; relem++) {
	    if (LIKELY((sv = *relem))) {
		TAINT_NOT;	/* Each item is independent */

		/* Dear TODO test in t/op/sort.t, I love you.
		   (It's relying on a panic, not a "semi-panic" from newSVsv()
		   and then an assertion failure below.)  */
		if (UNLIKELY(SvIS_FREED(sv))) {
		    Perl_croak(aTHX_ "panic: attempt to copy freed scalar %p",
			       (void*)sv);
		}
		/* Not newSVsv(), as it does not allow copy-on-write,
		   resulting in wasteful copies.  We need a second copy of
		   a temp here, hence the SV_NOSTEAL.  */
		*relem = sv_mortalcopy_flags(sv,SV_GMAGIC|SV_DO_COW_SVSETSV
					       |SV_NOSTEAL);
	    }
	}
d1316 4
d1327 1
d1330 5
d1336 2
a1337 1
	case SVt_PVAV:
d1342 32
a1373 2
	    av_clear(ary);
	    av_extend(ary, lastrelem - relem);
d1377 32
a1408 5
		if (LIKELY(*relem))
		    SvGETMAGIC(*relem); /* before newSV, in case it dies */
		sv = newSV(0);
		sv_setsv_nomg(sv, *relem);
		*(relem++) = sv;
d1422 2
d1430 1
d1445 23
d1469 1
d1477 1
a1477 1
		    sv = lval || SvGMAGICAL(*relem)
d1482 8
a1489 3
		    SvGETMAGIC(*relem);
                    tmpstr = newSV(0);
		    sv_setsv_nomg(tmpstr,*relem++);	/* value */
d1502 2
d1641 1
a1641 1
    PL_delaymagic = 0;
d1668 1
a1668 1
    dVAR; dSP;
d1708 1
a1708 1
    dVAR; dSP; dTARG;
d1719 1
a1719 1
    const I32 gimme = GIMME;
d1727 1
a1727 1
    else if (PL_op->op_private & OPpTARGET_MY)
d1886 1
a1886 1
    /* NOTREACHED */
d1888 1
a1888 1
nope:
d1904 1
a1904 1
    dVAR; dSP; dTARGETSTACKED;
d1911 1
a1911 1
    const I32 gimme = GIMME_V;
d1942 1
a1942 1
		fp = nextargv(PL_last_in_gv);
d1966 1
a1966 2
		SV_CHECK_THINKFIRST_COW_DROP(TARG);
		SvOK_off(TARG);
d2028 1
a2028 1
		fp = nextargv(PL_last_in_gv);
d2060 1
d2076 1
a2076 1
	    if (*t1 && PerlLIO_lstat(SvPVX_const(sv), &PL_statbuf) < 0) {
d2112 1
a2112 1
    dVAR; dSP;
d2152 1
a2152 1
	    LvTARG(lv) = SvREFCNT_inc_simple(hv);
d2190 7
a2196 1
PP(pp_iter)
d2198 11
a2208 4
    dVAR; dSP;
    PERL_CONTEXT *cx;
    SV *oldsv;
    SV **itersvp;
a2209 3
    EXTEND(SP, 1);
    cx = &cxstack[cxstack_ix];
    itersvp = CxITERVAR(cx);
d2211 41
a2251 1
    switch (CxTYPE(cx)) {
d2253 7
a2259 10
    case CXt_LOOP_LAZYSV: /* string increment */
    {
        SV* cur = cx->blk_loop.state_u.lazysv.cur;
        SV *end = cx->blk_loop.state_u.lazysv.end;
        /* If the maximum is !SvOK(), pp_enteriter substitutes PL_sv_no.
           It has SvPVX of "" and SvCUR of 0, which is what we want.  */
        STRLEN maxlen = 0;
        const char *max = SvPV_const(end, maxlen);
        if (UNLIKELY(SvNIOK(cur) || SvCUR(cur) > maxlen))
            RETPUSHNO;
d2261 35
a2295 19
        oldsv = *itersvp;
        if (LIKELY(SvREFCNT(oldsv) == 1 && !SvMAGICAL(oldsv))) {
            /* safe to reuse old SV */
            sv_setsv(oldsv, cur);
        }
        else
        {
            /* we need a fresh SV every time so that loop body sees a
             * completely new SV for closures/references to work as
             * they used to */
            *itersvp = newSVsv(cur);
            SvREFCNT_dec_NN(oldsv);
        }
        if (strEQ(SvPVX_const(cur), max))
            sv_setiv(cur, 0); /* terminate next time */
        else
            sv_inc(cur);
        break;
    }
d2297 41
a2337 5
    case CXt_LOOP_LAZYIV: /* integer increment */
    {
        IV cur = cx->blk_loop.state_u.lazyiv.cur;
	if (UNLIKELY(cur > cx->blk_loop.state_u.lazyiv.end))
	    RETPUSHNO;
a2338 14
        oldsv = *itersvp;
	/* don't risk potential race */
	if (LIKELY(SvREFCNT(oldsv) == 1 && !SvMAGICAL(oldsv))) {
	    /* safe to reuse old SV */
	    sv_setiv(oldsv, cur);
	}
	else
	{
	    /* we need a fresh SV every time so that loop body sees a
	     * completely new SV for closures/references to work as they
	     * used to */
	    *itersvp = newSViv(cur);
	    SvREFCNT_dec_NN(oldsv);
	}
d2340 1
a2340 7
	if (UNLIKELY(cur == IV_MAX)) {
	    /* Handle end of range at IV_MAX */
	    cx->blk_loop.state_u.lazyiv.end = IV_MIN;
	} else
	    ++cx->blk_loop.state_u.lazyiv.cur;
        break;
    }
d2342 6
a2347 2
    case CXt_LOOP_FOR: /* iterate array */
    {
d2349 314
a2662 13
        AV *av = cx->blk_loop.state_u.ary.ary;
        SV *sv;
        bool av_is_stack = FALSE;
        IV ix;

        if (!av) {
            av_is_stack = TRUE;
            av = PL_curstack;
        }
        if (PL_op->op_private & OPpITER_REVERSED) {
            ix = --cx->blk_loop.state_u.ary.ix;
            if (UNLIKELY(ix <= (av_is_stack ? cx->blk_loop.resetsp : -1)))
                RETPUSHNO;
d2664 7
a2670 4
        else {
            ix = ++cx->blk_loop.state_u.ary.ix;
            if (UNLIKELY(ix > (av_is_stack ? cx->blk_oldsp : AvFILL(av))))
                RETPUSHNO;
d2672 50
d2723 27
a2749 1
        if (UNLIKELY(SvMAGICAL(av) || AvREIFY(av))) {
d2757 7
a2769 1
                assert(!IS_PADGV(sv));
d2777 1
a2777 1
        else if (!av_is_stack) {
a2786 1
    }
d2791 11
a2801 1
    RETPUSHYES;
d2874 1
a2874 1
    dVAR; dSP; dTARG;
d2881 2
a2882 2
    I32 iters = 0;
    I32 maxiters;
d2895 1
a2895 1
    bool is_cow;
d2905 1
a2905 1
    else if (PL_op->op_private & OPpTARGET_MY)
d2914 7
a2920 6
    /* Awooga. Awooga. "bool" types that are actually char are dangerous,
       because they make integers such as 256 "false".  */
    is_cow = SvIsCOW(TARG) ? TRUE : FALSE;
#else
    if (SvIsCOW(TARG))
	sv_force_normal_flags(TARG,0);
d2922 6
a2927 6
    if (!(rpm->op_pmflags & PMf_NONDESTRUCT)
	&& (SvREADONLY(TARG)
	    || ( ((SvTYPE(TARG) == SVt_PVGV && isGV_with_GP(TARG))
		  || SvTYPE(TARG) > SVt_PVLV)
		 && !(SvTYPE(TARG) == SVt_PVGV && SvFAKE(TARG)))))
	Perl_croak_no_modify();
d2932 1
a2932 1
     * to match, we leave as-is; on successful match howeverm, we *will*
d2994 2
a2995 2
	     if (PL_encoding)
		  sv_recode_to_utf8(nsv, PL_encoding);
d3017 1
a3017 1
	&& !is_cow
d3030 1
d3108 1
a3108 1
	    mPUSHi((I32)iters);
d3148 1
a3148 1
	    PUSHSUBST(cx);
d3176 1
a3176 1
		if (PL_encoding) {
d3179 1
a3179 1
		    if (!DO_UTF8(nsv)) sv_recode_to_utf8(nsv, PL_encoding);
d3188 2
a3189 1
	} while (CALLREGEXEC(rx, s, strend, orig, s == m,
d3192 1
d3222 1
a3222 1
	    mPUSHi((I32)iters);
d3259 1
a3259 1
    dVAR; dSP;
d3270 1
a3270 1
	const I32 gimme = GIMME_V;
a3277 6
	    if (PL_op->op_private & OPpGREP_LEX) {
		SV* const sv = sv_newmortal();
		sv_setiv(sv, items);
		PUSHs(sv);
	    }
	    else {
a3279 1
	    }
d3291 1
a3291 1
	src = PL_stack_base[*PL_markstack_ptr];
d3293 1
a3293 2
            assert(!IS_PADGV(src));
	    src = PL_stack_base[*PL_markstack_ptr] = sv_mortalcopy(src);
d3297 1
a3297 4
	if (PL_op->op_private & OPpGREP_LEX)
	    PAD_SVl(PL_op->op_targ) = src;
	else
	    DEFSV_set(src);
d3303 325
d3630 1
a3630 5
    dVAR; dSP;
    SV **mark;
    SV **newsp;
    PMOP *newpm;
    I32 gimme;
d3632 5
a3636 1
    SV *sv;
d3638 4
a3641 1
    if (CxMULTICALL(&cxstack[cxstack_ix]))
d3643 1
d3645 16
a3660 2
    POPBLOCK(cx,newpm);
    cxstack_ix++; /* temporarily protect top context */
d3662 14
a3675 30
    TAINT_NOT;
    if (gimme == G_SCALAR) {
	MARK = newsp + 1;
	if (LIKELY(MARK <= SP)) {
	    if (cx->blk_sub.cv && CvDEPTH(cx->blk_sub.cv) > 1) {
		if (SvTEMP(TOPs) && SvREFCNT(TOPs) == 1
		     && !SvMAGICAL(TOPs)) {
		    *MARK = SvREFCNT_inc(TOPs);
		    FREETMPS;
		    sv_2mortal(*MARK);
		}
		else {
		    sv = SvREFCNT_inc(TOPs);	/* FREETMPS could clobber it */
		    FREETMPS;
		    *MARK = sv_mortalcopy(sv);
		    SvREFCNT_dec_NN(sv);
		}
	    }
	    else if (SvTEMP(TOPs) && SvREFCNT(TOPs) == 1
		     && !SvMAGICAL(TOPs)) {
		*MARK = TOPs;
	    }
	    else
		*MARK = sv_mortalcopy(TOPs);
	}
	else {
	    MEXTEND(MARK, 0);
	    *MARK = &PL_sv_undef;
	}
	SP = MARK;
d3677 6
a3682 8
    else if (gimme == G_ARRAY) {
	for (MARK = newsp + 1; MARK <= SP; MARK++) {
	    if (!SvTEMP(*MARK) || SvREFCNT(*MARK) != 1
		 || SvMAGICAL(*MARK)) {
		*MARK = sv_mortalcopy(*MARK);
		TAINT_NOT;	/* Each item is independent */
	    }
	}
d3684 1
a3684 6
    PUTBACK;

    LEAVE;
    POPSUB(cx,sv);	/* Stack values are safe: release CV and @@_ ... */
    cxstack_ix--;
    PL_curpm = newpm;	/* ... and pop $1 et al */
a3685 3
    LEAVESUB(sv);
    return cx->blk_sub.retop;
}
d3689 1
a3689 1
    dVAR; dSP; dPOPss;
d3693 1
a3693 2
    I32 gimme;
    const bool hasargs = (PL_op->op_flags & OPf_STACKED) != 0;
d3696 21
a3716 3
	DIE(aTHX_ "Not a CODE reference");
    /* This is overwhelmingly the most common case:  */
    if (!LIKELY(SvTYPE(sv) == SVt_PVGV && (cv = GvCVu((const GV *)sv)))) {
d3718 4
d3723 2
a3724 2
          we_have_a_glob:
            if (!(cv = GvCVu((const GV *)sv))) {
d3727 4
a3730 5
            }
            if (!cv) {
                ENTER;
                SAVETMPS;
                goto try_autoload;
d3733 1
a3733 3
        case SVt_PVLV:
            if(isGV_with_GP(sv)) goto we_have_a_glob;
            /*FALLTHROUGH*/
d3735 1
a3735 7
            if (sv == &PL_sv_yes) {		/* unfound import, ignore */
                if (hasargs)
                    SP = PL_stack_base + POPMARK;
                else
                    (void)POPMARK;
                RETURN;
            }
d3738 2
a3739 1
                if (SvAMAGIC(sv)) {
d3747 1
a3747 1
                if (!SvOK(sv))
d3749 11
d3767 1
a3767 1
            if (SvTYPE(cv) == SVt_PVCV)
d3769 1
a3769 1
            /* FALL THROUGH */
d3772 1
a3773 4
            /* This is the second most common case:  */
        case SVt_PVCV:
            cv = MUTABLE_CV(sv);
            break;
d3777 13
a3789 6
    ENTER;

  retry:
    if (UNLIKELY(CvCLONE(cv) && ! CvCLONED(cv)))
	DIE(aTHX_ "Closure prototype called");
    if (UNLIKELY(!CvROOT(cv) && !CvXSUB(cv))) {
d3794 4
a3797 4
	if (CvANON(cv) || !(gv = CvGV(cv))) {
	    if (CvNAMED(cv))
		DIE(aTHX_ "Undefined subroutine &%"HEKf" called",
			   HEKfARG(CvNAME_HEK(cv)));
d3802 1
a3802 1
	if (cv != GvCV(gv)) {
d3807 10
a3816 16
try_autoload:
	    if ((autogv = gv_autoload_pvn(GvSTASH(gv), GvNAME(gv), GvNAMELEN(gv),
				   GvNAMEUTF8(gv) ? SVf_UTF8 : 0)))
	    {
		cv = GvCV(autogv);
	    }
	    else {
	       sorry:
		sub_name = sv_newmortal();
		gv_efullname3(sub_name, gv, NULL);
		DIE(aTHX_ "Undefined subroutine &%"SVf" called", SVfARG(sub_name));
	    }
	}
	if (!cv)
	    goto sorry;
	goto retry;
d3819 4
a3841 2
    gimme = GIMME_V;

d3845 1
a3845 1
	PADLIST * const padlist = CvPADLIST(cv);
d3847 24
d3872 2
a3873 5
	PUSHBLOCK(cx, CXt_SUB, MARK);
	PUSHSUB(cx);
	cx->blk_sub.retop = PL_op->op_next;
	if (UNLIKELY((depth = ++CvDEPTH(cv)) >= 2)) {
	    PERL_STACK_OVERFLOW_CHECK();
a3874 2
	}
	SAVECOMPPAD();
a3880 7
	    if (UNLIKELY(AvREAL(av))) {
		/* @@_ is normally not REAL--this should only ever
		 * happen when DB::sub() calls things that modify @@_ */
		av_clear(av);
		AvREAL_off(av);
		AvREIFY_on(av);
	    }
d3884 6
a3889 2
	    CX_CURPAD_SAVE(cx->blk_sub);
	    cx->blk_sub.argarray = av;
a3890 1

a3900 13
	
	    MARK = AvARRAY(av);
	    while (items--) {
		if (*MARK)
		{
		    if (SvPADTMP(*MARK)) {
                        assert(!IS_PADGV(*MARK));
			*MARK = sv_mortalcopy(*MARK);
                    }
		    SvTEMP_off(*MARK);
		}
		MARK++;
	    }
a3901 1
	SAVETMPS;
d3904 2
a3905 1
	    DIE(aTHX_ "Can't modify non-lvalue subroutine call");
d3918 5
d3928 1
a3928 1
	       & PUSHSUB_GET_LVALUE_MASK(Perl_is_lvalue_sub)
d3931 2
a3932 1
	    DIE(aTHX_ "Can't modify non-lvalue subroutine call");
d3934 1
a3934 1
	if (UNLIKELY(!hasargs && GvAV(PL_defgv))) {
a3968 1
                    assert(!IS_PADGV(*mark));
d3981 4
d3990 1
a3990 1
	if (gimme == G_SCALAR) {
a4009 9
        HEK *const hek = CvNAME_HEK(cv);
        SV *tmpstr;
        if (hek) {
            tmpstr = sv_2mortal(newSVhek(hek));
        }
        else {
            tmpstr = sv_newmortal();
            gv_efullname3(tmpstr, CvGV(cv), NULL);
        }
d4011 1
a4011 1
		    SVfARG(tmpstr));
d4017 1
a4017 1
    dVAR; dSP;
d4128 2
a4129 18
PP(pp_method)
{
    dVAR; dSP;
    SV* const sv = TOPs;

    if (SvROK(sv)) {
	SV* const rsv = SvRV(sv);
	if (SvTYPE(rsv) == SVt_PVCV) {
	    SETs(rsv);
	    RETURN;
	}
    }

    SETs(method_common(sv, NULL));
    RETURN;
}

PP(pp_method_named)
a4130 12
    dVAR; dSP;
    SV* const sv = cSVOP_sv;
    U32 hash = SvSHARED_HASH(sv);

    XPUSHs(method_common(sv, &hash));
    RETURN;
}

STATIC SV *
S_method_common(pTHX_ SV* meth, U32* hashp)
{
    dVAR;
a4131 1
    GV* gv;
d4133 2
a4134 2
    SV *packsv = NULL;
    SV * const sv = PL_stack_base + TOPMARK == PL_stack_sp
d4140 1
a4140 1
    PERL_ARGS_ASSERT_METHOD_COMMON;
d4147 6
a4152 1
    SvGETMAGIC(sv);
d4174 3
a4176 13
        const bool packname_is_utf8 = !!SvUTF8(sv);
        const HE* const he =
	    (const HE *)hv_common(
                PL_stashcache, NULL, packname, packlen,
                packname_is_utf8 ? HVhek_UTF8 : 0, 0, NULL, 0
	    );
	  
        if (he) { 
            stash = INT2PTR(HV*,SvIV(HeVAL(he)));
            DEBUG_o(Perl_deb(aTHX_ "PL_stashcache hit %p for '%"SVf"'\n",
                             stash, sv));
            goto fetch;
        }
d4179 1
a4179 1
	        packname, packlen, SVf_UTF8 * packname_is_utf8, SVt_PVIO
d4191 3
a4193 11
	    stash = gv_stashpvn(packname, packlen, packname_is_utf8 ? SVf_UTF8 : 0);
	    if (!stash)
		packsv = sv;
            else {
	        SV* const ref = newSViv(PTR2IV(stash));
	        (void)hv_store(PL_stashcache, packname,
                                packname_is_utf8 ? -(I32)packlen : (I32)packlen, ref, 0);
                DEBUG_o(Perl_deb(aTHX_ "PL_stashcache caching %p for '%"SVf"'\n",
                                 stash, sv));
	    }
	    goto fetch;
d4211 68
a4278 1
    stash = SvSTASH(ob);
d4280 2
a4281 14
  fetch:
    /* NOTE: stash may be null, hope hv_fetch_ent and
       gv_fetchmethod can cope (it seems they can) */

    /* shortcut for simple names */
    if (hashp) {
	const HE* const he = hv_fetch_ent(stash, meth, 0, *hashp);
	if (he) {
	    gv = MUTABLE_GV(HeVAL(he));
	    if (isGV(gv) && GvCV(gv) &&
		(!GvCVGEN(gv) || GvCVGEN(gv)
                  == (PL_sub_generation + HvMROMETA(stash)->cache_gen)))
		return MUTABLE_SV(GvCV(gv));
	}
d4284 14
a4297 2
    gv = gv_fetchmethod_sv_flags(stash ? stash : MUTABLE_HV(packsv),
			             meth, GV_AUTOLOAD | GV_CROAK);
d4299 4
d4305 23
a4327 1
    return isGV(gv) ? MUTABLE_SV(GvCV(gv)) : MUTABLE_SV(gv);
a4330 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.16
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d64 1
a64 1
    if (PL_op->op_private & OPpLVAL_INTRO)
d136 1
a136 1
    if (TAINTING_get && TAINT_get && !SvTAINTED(right))
d138 2
a139 1
    if (PL_op->op_private & OPpASSIGN_CV_TO_GV) {
d218 1
a218 1
      SvTEMP(left) && !SvSMAGICAL(left) && SvREFCNT(left) == 1 &&
d282 2
a283 2
    else { /* $l .= $r */
	if (!SvOK(TARG)) {
d288 3
a290 1
	SvPV_force_nomg_nolen(left);
d293 1
a293 1
	    SvUTF8_off(TARG);
d332 1
a332 1
    const I32 maxarg = AvFILL(av) + 1;
d334 3
a336 3
    if (SvRMAGICAL(av)) {
        U32 i;
        for (i=0; i < (U32)maxarg; i++) {
d345 5
a349 1
        Copy(AvARRAY(av), SP+1, maxarg, SV*);
d474 1
a474 1
    if (SvTYPE(TOPs) >= SVt_PVAV || (isGV_with_GP(TOPs) && !SvFAKE(TOPs)))
d476 1
a476 1
    if (!SvREADONLY(TOPs) && !SvGMAGICAL(TOPs) && SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)
d513 1
a513 1
        if (!sv || !SvANY(sv)) {
d522 1
a522 1
        if (!sv || !SvANY(sv))
d731 1
a731 1
    SV** const svp = av_fetch(av, PL_op->op_private, lval);
d733 4
d797 1
a797 1
	return Perl_tied_method(aTHX_ "PRINT", mark - 1, MUTABLE_SV(io),
d880 1
a880 1
	if (SvAMAGIC(sv)) {
d884 1
a884 1
	if (SvTYPE(sv) != type)
d887 2
a888 2
	else if (PL_op->op_flags & OPf_MOD
		&& PL_op->op_private & OPpLVAL_INTRO)
d891 1
a891 1
    else if (SvTYPE(sv) != type) {
d911 1
a911 1
    else if (PL_op->op_private & OPpMAYBE_LVSUB) {
d934 1
a934 1
	    const I32 maxarg = AvFILL(av) + 1;
d949 1
a949 1
	    dTARGET;
a950 1
	    SPAGAIN;
d1003 1
a1003 1
    I32 i;
d1030 1
a1030 1
	    if ((sv = *relem)) {
d1036 1
a1036 1
		if (SvIS_FREED(sv)) {
d1054 1
a1054 1
    while (lelem <= lastlelem) {
d1068 2
a1069 2
		assert(*relem);
		SvGETMAGIC(*relem); /* before newSV, in case it dies */
d1082 1
a1082 1
	    if (PL_delaymagic & DM_ARRAY_ISA)
d1097 1
a1097 1
                if ( odd ) {
d1107 1
a1107 1
		while (relem < lastrelem+odd) {	/* gobble up all the rest */
d1167 1
a1167 1
		if (
d1170 1
a1170 1
		)
d1184 1
a1184 1
    if (PL_delaymagic & ~DM_DELAY) {
d1186 4
a1189 4
	UV tmp_uid  = PerlProc_getuid();
	UV tmp_euid = PerlProc_geteuid();
	UV tmp_gid  = PerlProc_getgid();
	UV tmp_egid = PerlProc_getegid();
d1191 1
d1194 4
a1197 3
	    (void)setresuid((PL_delaymagic & DM_RUID) ? PL_delaymagic_uid  : (Uid_t)-1,
			    (PL_delaymagic & DM_EUID) ? PL_delaymagic_euid : (Uid_t)-1,
			    (Uid_t)-1);
d1200 3
a1202 2
	    (void)setreuid((PL_delaymagic & DM_RUID) ? PL_delaymagic_uid  : (Uid_t)-1,
			   (PL_delaymagic & DM_EUID) ? PL_delaymagic_euid : (Uid_t)-1);
d1206 1
a1206 1
		(void)setruid(PL_delaymagic_uid);
d1212 1
a1212 1
		(void)seteuid(PL_delaymagic_euid);
d1219 1
a1219 1
		(void)PerlProc_setuid(PL_delaymagic_uid);
d1223 1
d1227 1
d1230 4
a1233 3
	    (void)setresgid((PL_delaymagic & DM_RGID) ? PL_delaymagic_gid  : (Gid_t)-1,
			    (PL_delaymagic & DM_EGID) ? PL_delaymagic_egid : (Gid_t)-1,
			    (Gid_t)-1);
d1236 3
a1238 2
	    (void)setregid((PL_delaymagic & DM_RGID) ? PL_delaymagic_gid  : (Gid_t)-1,
			   (PL_delaymagic & DM_EGID) ? PL_delaymagic_egid : (Gid_t)-1);
d1242 1
a1242 1
		(void)setrgid(PL_delaymagic_gid);
d1248 1
a1248 1
		(void)setegid(PL_delaymagic_egid);
d1255 1
a1255 1
		(void)PerlProc_setgid(PL_delaymagic_gid);
d1259 1
d1317 1
a1317 1
    if ((cv = *cvp) && CvCLONE(*cvp)) {
d1328 1
a1328 1
    if (RX_ISTAINTED(rx)) {
a1340 1
    const char *t;
d1343 1
d1345 1
a1345 1
    U8 r_flags = REXEC_CHECKED;
a1350 1
    I32 minmatch = 0;
a1351 1
    I32 update_minmatch = 1;
d1353 1
a1353 1
    U32 gpos = 0;
d1367 1
a1367 1
    s = ReANY(rx)->mother_re
d1370 1
a1370 1
    if (!s)
d1372 1
a1372 1
    strend = s + len;
a1376 2
    RX_MATCH_UTF8_set(rx, DO_UTF8(TARG));

d1400 4
a1403 2
    if (RX_MINLEN(rx) > (I32)len) {
        DEBUG_r(PerlIO_printf(Perl_debug_log, "String shorter than min possible regex match\n"));
d1407 1
a1407 3
    truebase = t = s;

    /* XXXX What part of this is needed with true \G-support? */
d1409 7
a1415 17
	RX_OFFS(rx)[0].start = -1;
	if (SvTYPE(TARG) >= SVt_PVMG && SvMAGIC(TARG)) {
	    MAGIC* const mg = mg_find(TARG, PERL_MAGIC_regex_global);
	    if (mg && mg->mg_len >= 0) {
		if (!(RX_EXTFLAGS(rx) & RXf_GPOS_SEEN))
		    RX_OFFS(rx)[0].end = RX_OFFS(rx)[0].start = mg->mg_len;
		else if (RX_EXTFLAGS(rx) & RXf_ANCH_GPOS) {
		    r_flags |= REXEC_IGNOREPOS;
		    RX_OFFS(rx)[0].end = RX_OFFS(rx)[0].start = mg->mg_len;
		} else if (RX_EXTFLAGS(rx) & RXf_GPOS_FLOAT) 
		    gpos = mg->mg_len;
		else 
		    RX_OFFS(rx)[0].end = RX_OFFS(rx)[0].start = mg->mg_len;
		minmatch = (mg->mg_flags & MGf_MINMATCH) ? RX_GOFS(rx) + 1 : 0;
		update_minmatch = 0;
	    }
	}
d1417 1
d1440 2
d1443 2
a1444 14
    if (global && RX_OFFS(rx)[0].start != -1) {
	t = s = RX_OFFS(rx)[0].end + truebase - RX_GOFS(rx);
	if ((s + RX_MINLEN(rx)) > strend || s < truebase) {
	    DEBUG_r(PerlIO_printf(Perl_debug_log, "Regex match can't succeed, so not even tried\n"));
	    goto nope;
	}
	if (update_minmatch++)
	    minmatch = had_zerolen;
    }
    if (RX_EXTFLAGS(rx) & RXf_USE_INTUIT &&
	DO_UTF8(TARG) == (RX_UTF8(rx) != 0)) {
	/* FIXME - can PL_bostr be made const char *?  */
	PL_bostr = (char *)truebase;
	s = CALLREG_INTUIT_START(rx, TARG, (char *)s, (char *)strend, r_flags, NULL);
a1445 10
	if (!s)
	    goto nope;
#ifdef PERL_SAWAMPERSAND
	if ( (RX_EXTFLAGS(rx) & RXf_CHECK_ALL)
	     && !PL_sawampersand
	     && !(RX_EXTFLAGS(rx) & RXf_PMf_KEEPCOPY)
	     && !SvROK(TARG))	/* Cannot trust since INTUIT cannot guess ^ */
	    goto yup;
#endif
    }
d1447 2
a1448 2
		     minmatch, TARG, NUM2PTR(void*, gpos), r_flags))
	goto ret_no;
d1451 1
a1451 1
    if (dynpm->op_pmflags & PMf_ONCE) {
a1456 1
    }
a1457 1
  gotcha:
d1461 21
a1481 1
    if (gimme == G_ARRAY) {
d1490 3
a1492 1
	    if ((RX_OFFS(rx)[i].start != -1) && RX_OFFS(rx)[i].end != -1 ) {
d1494 3
a1496 3
		s = RX_OFFS(rx)[i].start + truebase;
	        if (RX_OFFS(rx)[i].end < 0 || RX_OFFS(rx)[i].start < 0 ||
		    len < 0 || len > strend - s)
d1507 2
a1508 23
	    if (dynpm->op_pmflags & PMf_CONTINUE) {
		MAGIC* mg = NULL;
		if (SvTYPE(TARG) >= SVt_PVMG && SvMAGIC(TARG))
		    mg = mg_find(TARG, PERL_MAGIC_regex_global);
		if (!mg) {
#ifdef PERL_OLD_COPY_ON_WRITE
		    if (SvIsCOW(TARG))
			sv_force_normal_flags(TARG, 0);
#endif
		    mg = sv_magicext(TARG, NULL, PERL_MAGIC_regex_global,
				     &PL_vtbl_mglob, NULL, 0);
		}
		if (RX_OFFS(rx)[0].start != -1) {
		    mg->mg_len = RX_OFFS(rx)[0].end;
		    if (RX_OFFS(rx)[0].start + RX_GOFS(rx) == (UV)RX_OFFS(rx)[0].end)
			mg->mg_flags |= MGf_MINMATCH;
		    else
			mg->mg_flags &= ~MGf_MINMATCH;
		}
	    }
	    had_zerolen = (RX_OFFS(rx)[0].start != -1
			   && (RX_OFFS(rx)[0].start + RX_GOFS(rx)
			       == (UV)RX_OFFS(rx)[0].end));
a1512 2
	else if (!nparens)
	    XPUSHs(&PL_sv_yes);
d1516 1
a1516 105
    else {
	if (global) {
	    MAGIC* mg;
	    if (SvTYPE(TARG) >= SVt_PVMG && SvMAGIC(TARG))
		mg = mg_find(TARG, PERL_MAGIC_regex_global);
	    else
		mg = NULL;
	    if (!mg) {
#ifdef PERL_OLD_COPY_ON_WRITE
		if (SvIsCOW(TARG))
		    sv_force_normal_flags(TARG, 0);
#endif
		mg = sv_magicext(TARG, NULL, PERL_MAGIC_regex_global,
				 &PL_vtbl_mglob, NULL, 0);
	    }
	    if (RX_OFFS(rx)[0].start != -1) {
		mg->mg_len = RX_OFFS(rx)[0].end;
		if (RX_OFFS(rx)[0].start + RX_GOFS(rx) == (UV)RX_OFFS(rx)[0].end)
		    mg->mg_flags |= MGf_MINMATCH;
		else
		    mg->mg_flags &= ~MGf_MINMATCH;
	    }
	}
	LEAVE_SCOPE(oldsave);
	RETPUSHYES;
    }

#ifdef PERL_SAWAMPERSAND
yup:					/* Confirmed by INTUIT */
#endif
    if (rxtainted)
	RX_MATCH_TAINTED_on(rx);
    TAINT_IF(RX_MATCH_TAINTED(rx));
    PL_curpm = pm;
    if (dynpm->op_pmflags & PMf_ONCE) {
#ifdef USE_ITHREADS
        SvREADONLY_on(PL_regex_pad[dynpm->op_pmoffset]);
#else
        dynpm->op_pmflags |= PMf_USED;
#endif
    }
    if (RX_MATCH_COPIED(rx))
	Safefree(RX_SUBBEG(rx));
    RX_MATCH_COPIED_off(rx);
    RX_SUBBEG(rx) = NULL;
    if (global) {
	/* FIXME - should rx->subbeg be const char *?  */
	RX_SUBBEG(rx) = (char *) truebase;
	RX_SUBOFFSET(rx) = 0;
	RX_SUBCOFFSET(rx) = 0;
	RX_OFFS(rx)[0].start = s - truebase;
	if (RX_MATCH_UTF8(rx)) {
	    char * const t = (char*)utf8_hop((U8*)s, RX_MINLENRET(rx));
	    RX_OFFS(rx)[0].end = t - truebase;
	}
	else {
	    RX_OFFS(rx)[0].end = s - truebase + RX_MINLENRET(rx);
	}
	RX_SUBLEN(rx) = strend - truebase;
	goto gotcha;
    }
#ifdef PERL_SAWAMPERSAND
    if (PL_sawampersand || RX_EXTFLAGS(rx) & RXf_PMf_KEEPCOPY)
#endif
    {
	I32 off;
#ifdef PERL_ANY_COW
	if (SvCANCOW(TARG)) {
	    if (DEBUG_C_TEST) {
		PerlIO_printf(Perl_debug_log,
			      "Copy on write: pp_match $& capture, type %d, truebase=%p, t=%p, difference %d\n",
			      (int) SvTYPE(TARG), (void*)truebase, (void*)t,
			      (int)(t-truebase));
	    }
	    RX_SAVED_COPY(rx) = sv_setsv_cow(RX_SAVED_COPY(rx), TARG);
	    RX_SUBBEG(rx)
		= (char *) SvPVX_const(RX_SAVED_COPY(rx)) + (t - truebase);
	    assert (SvPOKp(RX_SAVED_COPY(rx)));
	} else
#endif
	{

	    RX_SUBBEG(rx) = savepvn(t, strend - t);
#ifdef PERL_ANY_COW
	    RX_SAVED_COPY(rx) = NULL;
#endif
	}
	RX_SUBLEN(rx) = strend - t;
	RX_SUBOFFSET(rx) = 0;
	RX_SUBCOFFSET(rx) = 0;
	RX_MATCH_COPIED_on(rx);
	off = RX_OFFS(rx)[0].start = s - t;
	RX_OFFS(rx)[0].end = off + RX_MINLENRET(rx);
    }
#ifdef PERL_SAWAMPERSAND
    else {			/* startp/endp are used by @@- @@+. */
	RX_OFFS(rx)[0].start = s - truebase;
	RX_OFFS(rx)[0].end = s - truebase + RX_MINLENRET(rx);
    }
#endif
    /* match via INTUIT shouldn't have any captures. Let @@-, @@+, $^N know */
    assert(!RX_NPARENS(rx));
    RX_LASTPAREN(rx) = RX_LASTCLOSEPAREN(rx) = 0;
    LEAVE_SCOPE(oldsave);
    RETPUSHYES;
a1518 1
ret_no:
d1520 4
a1523 5
	if (SvTYPE(TARG) >= SVt_PVMG && SvMAGIC(TARG)) {
	    MAGIC* const mg = mg_find(TARG, PERL_MAGIC_regex_global);
	    if (mg)
		mg->mg_len = -1;
	}
d1546 1
a1546 1
	    Perl_tied_method(aTHX_ "READLINE", SP, MUTABLE_SV(io), mg, gimme, 0);
d1562 1
a1562 1
		    if (av_len(GvAVn(PL_last_in_gv)) < 0) {
d1564 1
a1564 1
			do_open(PL_last_in_gv,"-",1,FALSE,O_RDONLY,0,NULL);
d1588 2
a1589 1
	    && ckWARN2(WARN_GLOB, WARN_CLOSED))
d1591 1
a1591 6
	    if (type == OP_GLOB)
		Perl_ck_warner_d(aTHX_ packWARN(WARN_GLOB),
			    "glob failed (can't start child: %s)",
			    Strerror(errno));
	    else
		report_evil_fh(PL_last_in_gv);
d1700 5
a1704 2
		if (!isALPHANUMERIC(*t1) &&
		    strchr("$&*(){}[]'\";\\|?<>~`", *t1))
d1841 1
a1841 1
        if (SvNIOK(cur) || SvCUR(cur) > maxlen)
d1845 1
a1845 1
        if (SvREFCNT(oldsv) == 1 && !SvMAGICAL(oldsv)) {
d1867 1
a1867 1
	if (cur > cx->blk_loop.state_u.lazyiv.end)
d1872 1
a1872 1
	if (SvREFCNT(oldsv) == 1 && !SvMAGICAL(oldsv)) {
d1885 1
a1885 1
	if (cur == IV_MAX) {
d1907 1
a1907 1
            if (ix <= (av_is_stack ? cx->blk_loop.resetsp : -1))
d1912 1
a1912 1
            if (ix > (av_is_stack ? cx->blk_oldsp : AvFILL(av)))
d1916 1
a1916 1
        if (SvMAGICAL(av) || AvREIFY(av)) {
d1924 2
a1925 2
        if (sv) {
            if (SvIS_FREED(sv)) {
d1929 11
a1939 2
            SvTEMP_off(sv);
            SvREFCNT_inc_simple_void_NN(sv);
a1943 10
        if (!av_is_stack && sv == &PL_sv_undef) {
            SV *lv = newSV_type(SVt_PVLV);
            LvTYPE(lv) = 'y';
            sv_magic(lv, NULL, PERL_MAGIC_defelem, NULL, 0);
            LvTARG(lv) = SvREFCNT_inc_simple(av);
            LvTARGOFF(lv) = ix;
            LvTARGLEN(lv) = (STRLEN)UV_MAX;
            sv = lv;
        }

d1966 2
a1967 1
TAINT_get).
a1973 4
At the start of execution of a pattern, the RXf_TAINTED_SEEN flag on the
regex is cleared; during execution, locale-variant ops such as POSIXL may
set RXf_TAINTED_SEEN.

a2030 1
    char *m;
a2031 1
    char *d;
a2034 1
    I32 i;
a2073 3
#ifdef PERL_ANY_COW
	&& !is_cow
#endif
d2081 4
a2084 1
    s = SvPV_nomg(TARG, len);
a2101 2
    RX_MATCH_UTF8_set(rx, DO_UTF8(TARG));

d2103 2
a2104 2
    if (!pm || !s)
	DIE(aTHX_ "panic: pp_subst, pm=%p, s=%p", pm, s);
d2106 2
a2107 2
    strend = s + len;
    slen = RX_MATCH_UTF8(rx) ? utf8_length((U8*)s, (U8*)strend) : len;
d2130 1
a2130 17
    orig = m = s;
    if (RX_EXTFLAGS(rx) & RXf_USE_INTUIT) {
	PL_bostr = orig;
	s = CALLREG_INTUIT_START(rx, TARG, s, strend, r_flags, NULL);

	if (!s)
	    goto ret_no;
	/* How to do it in subst? */
/*	if ( (RX_EXTFLAGS(rx) & RXf_CHECK_ALL)
	     && !PL_sawampersand
	     && !(RX_EXTFLAGS(rx) & RXf_KEEPCOPY))
	    goto yup;
*/
    }

    if (!CALLREGEXEC(rx, s, strend, orig, 0, TARG, NULL,
			 r_flags | REXEC_CHECKED))
a2131 1
      ret_no:
a2136 1

d2171 4
a2174 1
        && (once || !(r_flags & REXEC_COPY_STR))
d2188 2
d2191 1
a2191 1
	    s = SvPV_force_nomg(TARG, len);
d2194 1
a2194 1
	d = s;
d2196 1
d2203 1
d2216 2
a2217 1
	    else if ((i = m - s)) {	/* faster from front */
d2219 2
a2220 2
		m = d;
		Move(s, d - i, i, char);
d2223 1
a2223 9
		    Copy(c, m, clen, char);
	    }
	    else if (clen) {
		d -= clen;
		sv_chop(TARG, d);
		Copy(c, d, clen, char);
	    }
	    else {
		sv_chop(TARG, d);
d2229 2
d2232 2
a2233 1
		if (iters++ > maxiters)
d2235 1
a2235 1
		if (RX_MATCH_TAINTED(rx)) /* run time pattern taint, eg locale */
d2248 2
a2249 1
	    } while (CALLREGEXEC(rx, s, strend, orig, s == m,
d2251 1
a2251 2
				 /* don't match same null twice */
				 REXEC_NOT_FIRST|REXEC_IGNOREPOS));
d2253 1
a2253 1
		i = strend - s;
d2263 1
d2266 2
d2277 1
a2277 1
	    s = SvPV_force_nomg(TARG, len);
d2286 3
a2288 1
	dstr = newSVpvn_flags(m, s-m, SVs_TEMP | (DO_UTF8(TARG) ? SVf_UTF8 : 0));
d2292 1
a2300 1
	r_flags |= REXEC_IGNOREPOS | REXEC_NOT_FIRST;
d2303 1
a2303 1
	    if (iters++ > maxiters)
d2305 1
a2305 1
	    if (RX_MATCH_TAINTED(rx))
d2308 2
a2309 2
		m = s;
		s = orig;
d2311 1
d2313 2
a2314 2
		s = orig + (m - s);
		strend = s + (strend - m);
d2333 1
a2333 1
		if (SvTAINTED(repl))
d2339 2
a2340 1
			     TARG, NULL, r_flags));
d2416 1
a2416 1
    if (PL_stack_base + *PL_markstack_ptr > SP) {
d2447 5
d2481 1
a2481 1
	if (MARK <= SP) {
d2521 1
a2522 1
    POPSUB(cx,sv);	/* Stack values are safe: release CV and @@_ ... */
d2538 1
a2538 1
    if (!sv)
d2540 56
a2595 54
    switch (SvTYPE(sv)) {
	/* This is overwhelming the most common case:  */
    case SVt_PVGV:
      we_have_a_glob:
	if (!(cv = GvCVu((const GV *)sv))) {
	    HV *stash;
	    cv = sv_2cv(sv, &stash, &gv, 0);
	}
	if (!cv) {
	    ENTER;
	    SAVETMPS;
	    goto try_autoload;
	}
	break;
    case SVt_PVLV:
	if(isGV_with_GP(sv)) goto we_have_a_glob;
	/*FALLTHROUGH*/
    default:
	if (sv == &PL_sv_yes) {		/* unfound import, ignore */
	    if (hasargs)
		SP = PL_stack_base + POPMARK;
	    else
		(void)POPMARK;
	    RETURN;
	}
	SvGETMAGIC(sv);
	if (SvROK(sv)) {
	    if (SvAMAGIC(sv)) {
		sv = amagic_deref_call(sv, to_cv_amg);
		/* Don't SPAGAIN here.  */
	    }
	}
	else {
	    const char *sym;
	    STRLEN len;
	    if (!SvOK(sv))
		DIE(aTHX_ PL_no_usym, "a subroutine");
	    sym = SvPV_nomg_const(sv, len);
	    if (PL_op->op_private & HINT_STRICT_REFS)
		DIE(aTHX_ "Can't use string (\"%" SVf32 "\"%s) as a subroutine ref while \"strict refs\" in use", sv, len>32 ? "..." : "");
	    cv = get_cvn_flags(sym, len, GV_ADD|SvUTF8(sv));
	    break;
	}
	cv = MUTABLE_CV(SvRV(sv));
	if (SvTYPE(cv) == SVt_PVCV)
	    break;
	/* FALL THROUGH */
    case SVt_PVHV:
    case SVt_PVAV:
	DIE(aTHX_ "Not a CODE reference");
	/* This is the second most common case:  */
    case SVt_PVCV:
	cv = MUTABLE_CV(sv);
	break;
a2598 1
    SAVETMPS;
d2601 1
a2601 1
    if (CvCLONE(cv) && ! CvCLONED(cv))
d2603 1
a2603 1
    if (!CvROOT(cv) && !CvXSUB(cv)) {
d2639 3
a2641 2
    gimme = GIMME_V;
    if ((PL_op->op_private & OPpENTERSUB_DB) && GvCV(PL_DBsub) && !CvNODEBUG(cv)) {
d2647 1
a2647 1
	     cv = GvCV(gv_HVadd(gv_fetchpvs("DB::lsub", GV_ADDMULTI, SVt_PVHV)));
d2658 2
a2662 1
	I32 items = SP - MARK;
d2664 2
d2669 1
a2669 2
	CvDEPTH(cv)++;
	if (CvDEPTH(cv) >= 2) {
d2671 1
a2671 1
	    pad_push(padlist, CvDEPTH(cv));
d2674 2
a2675 2
	PAD_SET_CUR_NOSAVE(padlist, CvDEPTH(cv));
	if (hasargs) {
d2677 4
a2680 1
	    if (AvREAL(av)) {
d2687 3
a2689 2
	    cx->blk_sub.savearray = GvAV(PL_defgv);
	    GvAV(PL_defgv) = MUTABLE_AV(SvREFCNT_inc_simple(av));
d2692 1
a2692 1
	    ++MARK;
d2694 1
a2694 1
	    if (items - 1 > AvMAX(av)) {
d2702 1
a2702 1
	    Copy(MARK,AvARRAY(av),items,SV*);
d2705 1
d2708 5
d2714 1
d2718 3
a2720 2
	if ((cx->blk_u16 & OPpENTERSUB_LVAL_MASK) == OPpLVAL_INTRO &&
	    !CvLVALUE(cv))
d2726 3
a2728 2
	if (CvDEPTH(cv) == PERL_SUB_DEPTH_WARN && ckWARN(WARN_RECURSION)
	    && !(PERLDB_SUB && cv == GvCV(PL_DBsub)))
d2733 1
a2733 1
	I32 markix = TOPMARK;
d2735 1
d2738 1
a2738 1
	if (((PL_op->op_private
d2741 1
a2741 1
	    !CvLVALUE(cv))
d2744 1
a2744 1
	if (!hasargs) {
d2749 1
a2749 1
	    const I32 items = AvFILLp(av) + 1;   /* @@_ is not tieable */
d2752 2
d2756 13
a2768 1
		Copy(AvARRAY(av), SP + 1, items, SV*);
d2773 11
d2785 1
a2785 1
	if (PL_curcopdb) {
d2797 6
a2802 6
	if (gimme == G_SCALAR && ++markix != PL_stack_sp - PL_stack_base ) {
	    if (markix > PL_stack_sp - PL_stack_base)
		*(PL_stack_base + markix) = &PL_sv_undef;
	    else
		*(PL_stack_base + markix) = *PL_stack_sp;
	    PL_stack_sp = PL_stack_base + markix;
d2839 1
a2839 1
    const U32 defer = (PL_op->op_private & OPpLVAL_DEFER) && (elem > av_len(av));
d2844 1
a2844 1
    if (SvROK(elemsv) && !SvGAMAGIC(elemsv) && ckWARN(WARN_MISC))
d2848 1
a2848 1
    if (SvTYPE(av) != SVt_PVAV)
d2851 1
a2851 1
    if (localizing) {
d2878 2
a2879 2
	if (!svp || *svp == &PL_sv_undef) {
	    SV* lv;
d2882 7
a2888 8
	    lv = sv_newmortal();
	    sv_upgrade(lv, SVt_PVLV);
	    LvTYPE(lv) = 'y';
	    sv_magic(lv, NULL, PERL_MAGIC_defelem, NULL, 0);
	    LvTARG(lv) = SvREFCNT_inc_simple(av);
	    LvTARGOFF(lv) = elem;
	    LvTARGLEN(lv) = 1;
	    PUSHs(lv);
d2891 1
a2891 1
	if (localizing) {
d2987 1
a2987 1
    if (!sv)
d2996 13
d3057 1
a3057 1
    /* if we got here, ob should be a reference or a glob */
d3059 1
a3059 2
		 || (SvTYPE(ob) == SVt_PVGV 
		     && isGV_with_GP(ob)
@


1.15
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d77 1
a77 1
/* This is sometimes called directly by pp_coreargs. */
d88 6
a93 3
    sv_copypv(TARG,TOPs);
    SETTARG;
    RETURN;
d105 1
a105 1
    dVAR; dSP;
d107 14
a120 6
    if (!SvTRUE(TOPs))
	RETURN;
    else {
        if (PL_op->op_type == OP_AND)
	    --SP;
	RETURNOP(cLOGOP->op_other);
d126 5
a130 1
    dVAR; dSP; dPOPTOPssrl;
d136 1
a136 1
    if (PL_tainting && PL_tainted && !SvTAINTED(left))
d139 1
a139 1
	SV * const cv = SvRV(left);
d141 1
a141 1
	const bool is_gv = isGV_with_GP(right);
d148 2
a149 2
	/* Can do the optimisation if right (LVALUE) is not a typeglob,
	   left (RVALUE) is a reference to something, and we're in void
d153 1
a153 1
	    GV * const gv = gv_fetchsv_nomg(right, GV_NOINIT, SVt_PVGV);
d163 1
a163 1
		SETs(right);
d171 1
a171 1
	    right = MUTABLE_SV(gv_fetchsv_nomg(right,GV_ADD, SVt_PVGV));
d185 1
a185 1
		SvRV_set(left, MUTABLE_SV(newCONSTSUB(GvSTASH(right), NULL,
d187 1
a187 1
		SvREFCNT_dec(cv);
d210 2
a211 2
		SvREFCNT_dec(upgraded);
		SvRV_set(left, MUTABLE_SV(source));
d217 2
a218 2
      SvTEMP(right) && !SvSMAGICAL(right) && SvREFCNT(right) == 1 &&
      (!isGV_with_GP(right) || SvFAKE(right)) && ckWARN(WARN_MISC)
d223 2
a224 2
    SvSetMagicSV(right, left);
    SETs(right);
d287 2
a288 2
	lbyte = (SvROK(left) && SvTYPE(SvRV(left)) == SVt_REGEXP)
		    ?  !DO_UTF8(SvRV(left)) : !DO_UTF8(left);
d320 72
d394 23
a416 10
    dVAR; dSP; dTARGET;
    XPUSHs(TARG);
    if (PL_op->op_flags & OPf_MOD) {
	if (PL_op->op_private & OPpLVAL_INTRO)
	    if (!(PL_op->op_private & OPpPAD_STATE))
		SAVECLEARSV(PAD_SVl(PL_op->op_targ));
        if (PL_op->op_private & OPpDEREF) {
	    PUTBACK;
	    TOPs = vivify_ref(TOPs, PL_op->op_private & OPpDEREF);
	    SPAGAIN;
d418 1
a419 1
    RETURN;
d428 1
a428 1
	tryAMAGICunTARGET(iter_amg, 0, 0);
d468 2
a469 2
	Perl_croak_no_modify(aTHX);
    if (!SvREADONLY(TOPs) && SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)
d498 1
a498 1
    register SV* sv;
d608 1
a608 3
    SvIV_please_nomg(svr);

    if (SvIOK(svr)) {
d612 1
a612 1
	register UV auv = 0;
d624 1
a624 2
	    SvIV_please_nomg(svl);
	    if (SvIOK(svl)) {
d628 1
a628 1
		    register const IV aiv = SvIVX(svl);
d642 1
a642 1
	    register UV buv;
d648 1
a648 1
		register const IV biv = SvIVX(svr);
d767 1
a767 1
    register PerlIO *fp;
a875 13
	if (PL_op->op_flags & OPf_REF) {
	    SETs(sv);
	    RETURN;
	}
	else if (PL_op->op_private & OPpMAYBE_LVSUB) {
	  const I32 flags = is_lvalue_sub();
	  if (flags && !(flags & OPpENTERSUB_INARGS)) {
	    if (gimme != G_ARRAY)
		goto croak_cant_return;
	    SETs(sv);
	    RETURN;
	  }
	}
d880 1
a880 14
    else {
	if (SvTYPE(sv) == type) {
	    if (PL_op->op_flags & OPf_REF) {
		SETs(sv);
		RETURN;
	    }
	    else if (LVRET) {
		if (gimme != G_ARRAY)
		    goto croak_cant_return;
		SETs(sv);
		RETURN;
	    }
	}
	else {
d895 2
a896 1
	    if (PL_op->op_flags & OPf_REF) {
d899 2
a900 2
	    }
	    else if (PL_op->op_private & OPpMAYBE_LVSUB) {
a907 2
	    }
	}
d916 4
a919 17
	    const I32 maxarg = AvFILL(av) + 1;
	    (void)POPs;			/* XXXX May be optimized away? */
	    EXTEND(SP, maxarg);
	    if (SvRMAGICAL(av)) {
		U32 i;
		for (i=0; i < (U32)maxarg; i++) {
		    SV ** const svp = av_fetch(av, i, FALSE);
		    /* See note in pp_helem, and bug id #27839 */
		    SP[i+1] = svp
			? SvGMAGICAL(*svp) ? (mg_get(*svp), *svp) : *svp
			: &PL_sv_undef;
		}
	    }
	    else {
		Copy(AvARRAY(av), SP+1, maxarg, SV*);
	    }
	    SP += maxarg;
d932 5
d953 1
a953 1
S_do_oddball(pTHX_ HV *hash, SV **relem, SV **firstrelem)
d959 1
a959 4
    if (*relem) {
	SV *tmpstr;
        const HE *didstore;

d962 4
a965 4
	    if (relem == firstrelem &&
		SvROK(*relem) &&
		(SvTYPE(SvRV(*relem)) == SVt_PVAV ||
		 SvTYPE(SvRV(*relem)) == SVt_PVHV))
a973 9
        tmpstr = newSV(0);
        didstore = hv_store_ent(hash,*relem,tmpstr,0);
        if (SvMAGICAL(hash)) {
            if (SvSMAGICAL(tmpstr))
                mg_set(tmpstr);
            if (!didstore)
                sv_2mortal(tmpstr);
        }
        TAINT_NOT;
d985 2
a986 2
    register SV **relem;
    register SV **lelem;
d988 2
a989 2
    register SV *sv;
    register AV *ary;
d995 1
a995 2
    int duplicates = 0;
    SV **firsthashrelem = NULL;	/* "= 0" keeps gcc 2.95 quiet  */
d999 2
d1030 5
a1034 3
		/* Specifically *not* sv_mortalcopy(), as that will steal TEMPs,
		   and we need a second copy of a temp here.  */
		*relem = sv_2mortal(newSVsv(sv));
d1059 1
d1061 1
a1061 1
		sv_setsv(sv, *relem);
d1065 2
a1068 2
		    if (!didstore)
			sv_2mortal(sv);
d1078 2
d1081 1
d1085 9
d1097 1
a1097 3
		firsthashrelem = relem;

		while (relem < lastrelem) {	/* gobble up all the rest */
d1099 8
a1106 5
		    sv = *relem ? *relem : &PL_sv_no;
		    relem++;
		    tmpstr = newSV(0);
		    if (*relem)
			sv_setsv(tmpstr,*relem);	/* value */
d1108 5
a1112 1
		    if (gimme != G_VOID) {
d1116 1
a1116 2
			else
			if (gimme == G_ARRAY) {
d1118 2
a1119 1
			     * stack location if we encountered dups earlier */
d1126 3
a1128 5
			if (SvSMAGICAL(tmpstr))
			    mg_set(tmpstr);
			if (!didstore)
			    sv_2mortal(tmpstr);
		    }
a1130 4
		if (relem == lastrelem) {
		    do_oddball(hash, relem, firstrelem);
		    relem++;
		}
d1132 16
d1245 7
a1251 1
	PL_tainting |= (tmp_uid && (tmp_euid != tmp_uid || tmp_egid != tmp_gid));
d1260 1
a1260 1
	SETi(lastrelem - firstrelem + 1 - duplicates);
d1263 3
a1265 1
	if (ary)
d1267 1
a1267 20
	else if (hash) {
	    if (duplicates) {
		/* at this point we have removed the duplicate key/value
		 * pairs from the stack, but the remaining values may be
		 * wrong; i.e. with (a 1 a 2 b 3) on the stack we've removed
		 * the (a 2), but the stack now probably contains
		 * (a <freed> b 3), because { hv_save(a,1); hv_save(a,2) }
		 * obliterates the earlier key. So refresh all values. */
		lastrelem -= duplicates;
		relem = firsthashrelem;
		while (relem < lastrelem) {
		    HE *he;
		    sv = *relem++;
		    he = hv_fetch_ent(hash, sv, 0, 0);
		    *relem++ = (he ? HeVAL(he) : &PL_sv_undef);
		}
	    }
	    SP = lastrelem;
	}
	else
d1269 4
a1272 3
	lelem = firstlelem + (relem - firstrelem);
	while (relem <= SP)
	    *relem++ = (lelem <= lastlelem) ? *lelem++ : &PL_sv_undef;
d1281 1
a1281 1
    register PMOP * const pm = cPMOP;
d1285 2
d1298 6
d1306 1
a1306 1
	SvREFCNT_dec(pkg);
d1310 1
a1310 1
    if (RX_EXTFLAGS(rx) & RXf_TAINTED) {
d1321 1
a1321 1
    register PMOP *pm = cPMOP;
d1323 2
a1324 2
    register const char *t;
    register const char *s;
d1329 1
a1329 1
    register REGEXP *rx = PM_GETRE(pm);
d1351 1
a1351 1
    s = ((struct regexp *)SvANY(rx))->mother_re
d1357 2
a1358 2
    rxtainted = ((RX_EXTFLAGS(rx) & RXf_TAINTED) ||
		 (PL_tainted && (pm->op_pmflags & PMf_RETAINT)));
d1363 3
d1374 2
a1375 4
      failure:
	if (gimme == G_ARRAY)
	    RETURN;
	RETPUSHNO;
d1378 4
a1381 4


    /* empty pattern special-cased to use last successful pattern if possible */
    if (!RX_PRELEN(rx) && PL_curpm) {
d1386 4
a1389 2
    if (RX_MINLEN(rx) > (I32)len)
	goto failure;
d1394 1
a1394 1
    if ((global = dynpm->op_pmflags & PMf_GLOBAL)) {
d1413 21
a1433 11
    /* XXX: comment out !global get safe $1 vars after a
       match, BUT be aware that this leads to dramatic slowdowns on
       /g matches against large strings.  So far a solution to this problem
       appears to be quite tricky.
       Test for the unsafe vars are TODO for now. */
    if (       (!global && RX_NPARENS(rx))
	    || SvTEMP(TARG) || SvAMAGIC(TARG) || PL_sawampersand
	    || (RX_EXTFLAGS(rx) & (RXf_EVAL_SEEN|RXf_PMf_KEEPCOPY)))
	r_flags |= REXEC_COPY_STR;
    if (SvSCREAM(TARG))
	r_flags |= REXEC_SCREAM;
d1438 2
a1439 1
	if ((s + RX_MINLEN(rx)) > strend || s < truebase)
d1441 1
d1453 1
a1456 3
	     && ((RX_EXTFLAGS(rx) & RXf_NOSCAN)
		 || !((RX_EXTFLAGS(rx) & RXf_INTUIT_TAIL)
		      && (r_flags & REXEC_SCREAM)))
d1459 1
d1561 1
d1563 1
d1582 2
d1595 4
a1598 1
    if (PL_sawampersand || RX_EXTFLAGS(rx) & RXf_PMf_KEEPCOPY) {
d1600 2
a1601 2
#ifdef PERL_OLD_COPY_ON_WRITE
	if (SvIsCOW(TARG) || (SvFLAGS(TARG) & CAN_COW_MASK) == CAN_COW_FLAGS) {
d1617 1
a1617 1
#ifdef PERL_OLD_COPY_ON_WRITE
d1622 2
d1628 1
d1633 4
a1636 3
    /* including RX_NPARENS(rx) in the below code seems highly suspicious.
       -dmq */
    RX_NPARENS(rx) = RX_LASTPAREN(rx) = RX_LASTCLOSEPAREN(rx) = 0;	/* used by @@-, @@+, and $^N */
d1659 1
a1659 1
    register SV *sv;
d1663 2
a1664 2
    register IO * const io = GvIO(PL_last_in_gv);
    register const I32 type = PL_op->op_type;
d1689 1
d1747 1
a1747 1
	if (!tmplen && !SvREADONLY(sv)) {
d1828 1
a1828 1
		if (!isALPHA(*t1) && !isDIGIT(*t1) &&
a1874 1
    const U32 hash = (SvIsCOW_shared_hash(keysv)) ? SvSHARED_HASH(keysv) : 0;
d1889 1
a1889 1
	if (SvCANEXISTDELETE(hv) || mg_find((const SV *)hv, PERL_MAGIC_env))
d1893 1
a1893 1
    he = hv_fetch_ent(hv, keysv, lval && !defer, hash);
d1906 1
a1906 1
	    SvREFCNT_dec(key2);	/* sv_magic() increments refcount */
d1948 2
a1949 2
    register PERL_CONTEXT *cx;
    SV *sv, *oldsv;
a1950 2
    AV *av = NULL; /* used for LOOP_FOR on arrays and the stack */
    bool av_is_stack = FALSE;
d1954 14
a1967 2
    if (!CxTYPE_is_LOOP(cx))
	DIE(aTHX_ "panic: pp_iter, type=%u", CxTYPE(cx));
d1969 18
a1986 30
    itersvp = CxITERVAR(cx);
    if (CxTYPE(cx) == CXt_LOOP_LAZYSV) {
	    /* string increment */
	    SV* cur = cx->blk_loop.state_u.lazysv.cur;
	    SV *end = cx->blk_loop.state_u.lazysv.end;
	    /* If the maximum is !SvOK(), pp_enteriter substitutes PL_sv_no.
	       It has SvPVX of "" and SvCUR of 0, which is what we want.  */
	    STRLEN maxlen = 0;
	    const char *max = SvPV_const(end, maxlen);
	    if (!SvNIOK(cur) && SvCUR(cur) <= maxlen) {
		if (SvREFCNT(*itersvp) == 1 && !SvMAGICAL(*itersvp)) {
		    /* safe to reuse old SV */
		    sv_setsv(*itersvp, cur);
		}
		else
		{
		    /* we need a fresh SV every time so that loop body sees a
		     * completely new SV for closures/references to work as
		     * they used to */
		    oldsv = *itersvp;
		    *itersvp = newSVsv(cur);
		    SvREFCNT_dec(oldsv);
		}
		if (strEQ(SvPVX_const(cur), max))
		    sv_setiv(cur, 0); /* terminate next time */
		else
		    sv_inc(cur);
		RETPUSHYES;
	    }
	    RETPUSHNO;
d1988 5
a1992 3
    else if (CxTYPE(cx) == CXt_LOOP_LAZYIV) {
	/* integer increment */
	if (cx->blk_loop.state_u.lazyiv.cur > cx->blk_loop.state_u.lazyiv.end)
d1995 1
d1997 1
a1997 1
	if (SvREFCNT(*itersvp) == 1 && !SvMAGICAL(*itersvp)) {
d1999 1
a1999 1
	    sv_setiv(*itersvp, cx->blk_loop.state_u.lazyiv.cur++);
d2006 2
a2007 3
	    oldsv = *itersvp;
	    *itersvp = newSViv(cx->blk_loop.state_u.lazyiv.cur++);
	    SvREFCNT_dec(oldsv);
d2010 10
a2019 7
	/* Handle end of range at IV_MAX */
	if ((cx->blk_loop.state_u.lazyiv.cur == IV_MIN) &&
	    (cx->blk_loop.state_u.lazyiv.end == IV_MAX))
	{
	    cx->blk_loop.state_u.lazyiv.cur++;
	    cx->blk_loop.state_u.lazyiv.end++;
	}
d2021 19
a2039 2
	RETPUSHYES;
    }
d2041 7
a2047 11
    /* iterate array */
    assert(CxTYPE(cx) == CXt_LOOP_FOR);
    av = cx->blk_loop.state_u.ary.ary;
    if (!av) {
	av_is_stack = TRUE;
	av = PL_curstack;
    }
    if (PL_op->op_private & OPpITER_REVERSED) {
	if (cx->blk_loop.state_u.ary.ix <= (av_is_stack
				    ? cx->blk_loop.resetsp + 1 : 0))
	    RETPUSHNO;
d2049 10
a2058 12
	if (SvMAGICAL(av) || AvREIFY(av)) {
	    SV * const * const svp = av_fetch(av, --cx->blk_loop.state_u.ary.ix, FALSE);
	    sv = svp ? *svp : NULL;
	}
	else {
	    sv = AvARRAY(av)[--cx->blk_loop.state_u.ary.ix];
	}
    }
    else {
	if (cx->blk_loop.state_u.ary.ix >= (av_is_stack ? cx->blk_oldsp :
				    AvFILL(av)))
	    RETPUSHNO;
d2060 9
a2068 8
	if (SvMAGICAL(av) || AvREIFY(av)) {
	    SV * const * const svp = av_fetch(av, ++cx->blk_loop.state_u.ary.ix, FALSE);
	    sv = svp ? *svp : NULL;
	}
	else {
	    sv = AvARRAY(av)[++cx->blk_loop.state_u.ary.ix];
	}
    }
d2070 4
a2073 3
    if (sv && SvIS_FREED(sv)) {
	*itersvp = NULL;
	Perl_croak(aTHX_ "Use of freed value in iteration");
d2076 2
a2077 14
    if (sv) {
	SvTEMP_off(sv);
	SvREFCNT_inc_simple_void_NN(sv);
    }
    else
	sv = &PL_sv_undef;
    if (!av_is_stack && sv == &PL_sv_undef) {
	SV *lv = newSV_type(SVt_PVLV);
	LvTYPE(lv) = 'y';
	sv_magic(lv, NULL, PERL_MAGIC_defelem, NULL, 0);
	LvTARG(lv) = SvREFCNT_inc_simple(av);
	LvTARGOFF(lv) = cx->blk_loop.state_u.ary.ix;
	LvTARGLEN(lv) = (STRLEN)UV_MAX;
	sv = lv;
a2078 5

    oldsv = *itersvp;
    *itersvp = sv;
    SvREFCNT_dec(oldsv);

d2085 3
d2089 4
a2092 3
PL_tainted will get set if any component of the pattern is tainted, e.g.
/.*$tainted/.  At the end of pattern compilation, the RXf_TAINTED flag
is set on the pattern if PL_tainted is set.
d2096 2
a2097 1
as /x$r/, will set PL_tainted, and thus RXf_TAINTED, on the new pattern too.
d2099 3
a2101 4
During execution of a pattern, locale-variant ops such as ALNUML set the
local flag RF_tainted. At the end of execution, the engine sets the
RXf_TAINTED_SEEN on the pattern if RF_tainted got set, or clears it
otherwise.
d2103 1
a2103 1
In addition, RXf_TAINTED_SEEN is used post-execution by the get magic code
d2156 1
a2156 1
    register PMOP *pm = cPMOP;
d2158 1
a2158 1
    register char *s;
d2160 1
a2160 1
    register char *m;
d2162 1
a2162 1
    register char *d;
d2166 1
a2166 1
    register I32 i;
d2172 1
a2172 1
    register REGEXP *rx = PM_GETRE(pm);
d2177 2
a2178 2
    bool doutf8 = FALSE;
#ifdef PERL_OLD_COPY_ON_WRITE
d2183 1
a2183 1
    register SV *dstr = (pm->op_pmflags & PMf_CONST) ? POPs : NULL;
d2196 2
a2197 1
#ifdef PERL_OLD_COPY_ON_WRITE
d2206 1
a2206 1
#ifdef PERL_OLD_COPY_ON_WRITE
d2213 1
a2213 1
	Perl_croak_no_modify(aTHX);
d2216 2
a2217 3
  setup_match:
    s = SvPV_mutable(TARG, len);
    if (!SvPOKp(TARG) || SvTYPE(TARG) == SVt_PVGV)
d2224 1
a2224 1
    if (PL_tainting) {
d2227 1
a2227 1
	  | ((RX_EXTFLAGS(rx) & RXf_TAINTED) ? SUBST_TAINT_PAT : 0)
d2246 2
a2247 1
    if (!RX_PRELEN(rx) && PL_curpm) {
d2251 12
a2262 5
    r_flags = (RX_NPARENS(rx) || SvTEMP(TARG) || PL_sawampersand
	    || (RX_EXTFLAGS(rx) & (RXf_EVAL_SEEN|RXf_PMf_KEEPCOPY)) )
	       ? REXEC_COPY_STR : 0;
    if (SvSCREAM(TARG))
	r_flags |= REXEC_SCREAM;
d2274 1
a2274 4
	     && !(RX_EXTFLAGS(rx) & RXf_KEEPCOPY)
	     && ((RX_EXTFLAGS(rx) & RXf_NOSCAN)
		 || !((RX_EXTFLAGS(rx) & RXf_INTUIT_TAIL)
		      && (r_flags & REXEC_SCREAM))))
d2289 2
a2292 19
	if (SvTAINTED(dstr))
	    rxtainted |= SUBST_TAINT_REPL;

	/* Upgrade the source if the replacement is utf8 but the source is not,
	 * but only if it matched; see
	 * http://www.nntp.perl.org/group/perl.perl5.porters/2010/04/msg158809.html
	 */
	if (DO_UTF8(dstr) && ! DO_UTF8(TARG)) {
	    char * const orig_pvx =  SvPVX(TARG);
	    const STRLEN new_len = sv_utf8_upgrade_nomg(TARG);

	    /* If the lengths are the same, the pattern contains only
	     * invariants, can keep going; otherwise, various internal markers
	     * could be off, so redo */
	    if (new_len != len || orig_pvx != SvPVX(TARG)) {
		goto setup_match;
	    }
	}

d2308 3
d2319 1
a2319 1
#ifdef PERL_OLD_COPY_ON_WRITE
d2322 3
a2324 2
	&& (I32)clen <= RX_MINLENRET(rx) && (once || !(r_flags & REXEC_COPY_STR))
	&& !(RX_EXTFLAGS(rx) & RXf_LOOKBEHIND_SEEN)
d2329 1
a2329 1
#ifdef PERL_OLD_COPY_ON_WRITE
d2331 1
a2331 1
	    assert (!force_on_match);
d2333 1
d2338 1
a2338 1
	    s = SvPV_force(TARG, len);
a2341 2
	PL_curpm = pm;
	SvSCREAM_off(TARG);	/* disable possible screamer */
d2411 2
d2423 1
a2423 1
	    s = SvPV_force(TARG, len);
d2426 1
a2426 1
#ifdef PERL_OLD_COPY_ON_WRITE
d2431 1
a2432 1
	PL_curpm = pm;
d2434 1
a2434 1
	    register PERL_CONTEXT *cx;
d2445 1
d2454 1
d2460 1
a2460 4
	    if (doutf8 && !SvUTF8(dstr))
		sv_catpvn_utf8_upgrade(dstr, s, m - s, nsv);
            else
		sv_catpvn(dstr, s, m-s);
d2462 17
a2478 2
	    if (clen)
		sv_catpvn(dstr, c, clen);
d2483 1
a2483 4
	if (doutf8 && !DO_UTF8(TARG))
	    sv_catpvn_utf8_upgrade(dstr, s, strend - s, nsv);
	else
	    sv_catpvn(dstr, s, strend - s);
d2492 1
a2492 1
#ifdef PERL_OLD_COPY_ON_WRITE
d2508 1
a2508 1
	    doutf8 |= DO_UTF8(dstr);
a2517 2
	if (doutf8)
	    SvUTF8_on(TARG);
d2521 1
a2521 1
    if (PL_tainting) {
d2536 3
a2538 2
	PL_tainted =
	  cBOOL(rxtainted & (SUBST_TAINT_STR|SUBST_TAINT_PAT|SUBST_TAINT_REPL));
d2606 1
a2606 1
    register PERL_CONTEXT *cx;
d2630 1
a2630 1
		    SvREFCNT_dec(sv);
d2670 2
a2671 2
    register CV *cv;
    register PERL_CONTEXT *cx;
d2712 2
a2714 2
	    if (!sym)
		DIE(aTHX_ PL_no_usym, "a subroutine");
d2744 4
a2747 1
	if (CvANON(cv) || !(gv = CvGV(cv)))
d2749 1
a2762 1
	    /* sorry */
d2764 1
d2771 1
a2771 1
	    DIE(aTHX_ "Not a CODE reference");
d2796 2
a2797 2
	register I32 items = SP - MARK;
	AV* const padlist = CvPADLIST(cv);
a2801 5
	/* XXX This would be a natural place to set C<PL_compcv = cv> so
	 * that eval'' ops within this sub know the correct lexical space.
	 * Owing the speed considerations, we choose instead to search for
	 * the cv using find_runcv() when calling doeval().
	 */
d2823 8
a2830 13
	    if (items > AvMAX(av) + 1) {
		SV **ary = AvALLOC(av);
		if (AvARRAY(av) != ary) {
		    AvMAX(av) += AvARRAY(av) - AvALLOC(av);
		    AvARRAY(av) = ary;
		}
		if (items > AvMAX(av) + 1) {
		    AvMAX(av) = items - 1;
		    Renew(ary,items,SV*);
		    AvALLOC(av) = ary;
		    AvARRAY(av) = ary;
		}
	    }
d2857 6
d2911 9
a2919 2
	SV* const tmpstr = sv_newmortal();
	gv_efullname3(tmpstr, CvGV(cv), NULL);
d3012 1
a3012 1
	    Perl_croak_no_modify(aTHX);
d3074 5
a3078 1
    SV * const sv = *(PL_stack_base + TOPMARK + 1);
d3083 1
d3090 1
d3092 1
d3095 6
a3100 9
        const char * packname = NULL;
	bool packname_is_utf8 = FALSE;

	/* this isn't a reference */
        if(SvOK(sv) && (packname = SvPV_nomg_const(sv, packlen))) {
          const HE* const he =
	    (const HE *)hv_common_key_len(
	      PL_stashcache, packname,
	      packlen * -(packname_is_utf8 = !!SvUTF8(sv)), 0, NULL, 0
d3103 1
a3103 1
          if (he) { 
d3105 2
a3107 1
          }
d3110 1
a3110 3
	if (!SvOK(sv) ||
	    !(packname) ||
	    !(iogv = gv_fetchpvn_flags(
d3116 1
a3116 5
	    if (!packname ||
		((UTF8_IS_START(*packname) && DO_UTF8(sv))
		    ? !isIDFIRST_utf8((U8*)packname)
		    : !isIDFIRST_L1((U8)*packname)
		))
d3118 3
a3120 5
		/* diag_listed_as: Can't call method "%s" without a package or object reference */
		Perl_croak(aTHX_ "Can't call method \"%"SVf"\" %s",
			   SVfARG(meth),
			   SvOK(sv) ? "without a package or object reference"
				    : "on an undefined value");
d3130 2
d3182 1
a3182 1
 * indent-tabs-mode: t
d3185 1
a3185 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.14
log
@merge in perl 5.12.2 plus local changes
@
text
@d55 1
d77 1
d103 1
d126 1
a126 1
	const U32 gv_type = SvTYPE(right);
d136 1
a136 1
	if (!got_coderef && gv_type != SVt_PVGV && GIMME_V == G_VOID) {
d138 1
a138 1
	    GV * const gv = gv_fetchsv(right, GV_NOINIT, SVt_PVGV);
d154 1
a154 1
	if (gv_type != SVt_PVGV) {
d156 1
a156 1
	    right = MUTABLE_SV(gv_fetchsv(right, GV_ADD, SVt_PVGV));
d201 7
d216 1
d226 1
a226 1
    I32 oldsave;
d230 4
a233 2
    oldsave = PL_scopestack[PL_scopestack_ix - 1];
    LEAVE_SCOPE(oldsave);
d239 1
a239 1
  dVAR; dSP; dATARGET; tryAMAGICbin(concat,opASSIGN);
d248 2
a249 3
    if (TARG == right && right != left) {
	/* mg_get(right) may happen here ... */
	rpv = SvPV_const(right, rlen);
d256 1
a256 1
    if (TARG != left) {
d258 1
a258 1
        const char* const lpv = SvPV_const(left, llen);	/* mg_get(left) may happen here */
d266 1
a266 3
    else { /* TARG == left */
        STRLEN llen;
	SvGETMAGIC(left);		/* or mg_get(left) may happen here */
d268 1
a268 1
	    if (left == right && ckWARN(WARN_UNINITIALIZED))
d272 2
a273 2
	(void)SvPV_nomg_const(left, llen);    /* Needed to set UTF8 flag */
	lbyte = !DO_UTF8(left);
a277 1
    /* or mg_get(right) may happen here */
d279 4
a282 1
	rpv = SvPV_const(right, rlen);
d286 2
d294 1
a294 1
	    rpv = SvPV_const(right, rlen);
d296 1
d315 1
a315 1
	    vivify_ref(PAD_SVl(PL_op->op_targ), PL_op->op_private & OPpDEREF);
d325 7
a331 2
    tryAMAGICunTARGET(iter, 0);
    PL_last_in_gv = MUTABLE_GV(*PL_stack_sp--);
d339 1
a339 1
	    pp_rv2gv();
d348 12
a359 69
    dVAR; dSP; tryAMAGICbinSET(eq,0);
#ifndef NV_PRESERVES_UV
    if (SvROK(TOPs) && !SvAMAGIC(TOPs) && SvROK(TOPm1s) && !SvAMAGIC(TOPm1s)) {
        SP--;
	SETs(boolSV(SvRV(TOPs) == SvRV(TOPp1s)));
	RETURN;
    }
#endif
#ifdef PERL_PRESERVE_IVUV
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	/* Unless the left argument is integer in range we are going
	   to have to use NV maths. Hence only attempt to coerce the
	   right argument if we know the left is integer.  */
      SvIV_please(TOPm1s);
	if (SvIOK(TOPm1s)) {
	    const bool auvok = SvUOK(TOPm1s);
	    const bool buvok = SvUOK(TOPs);
	
	    if (auvok == buvok) { /* ## IV == IV or UV == UV ## */
                /* Casting IV to UV before comparison isn't going to matter
                   on 2s complement. On 1s complement or sign&magnitude
                   (if we have any of them) it could to make negative zero
                   differ from normal zero. As I understand it. (Need to
                   check - is negative zero implementation defined behaviour
                   anyway?). NWC  */
		const UV buv = SvUVX(POPs);
		const UV auv = SvUVX(TOPs);
		
		SETs(boolSV(auv == buv));
		RETURN;
	    }
	    {			/* ## Mixed IV,UV ## */
                SV *ivp, *uvp;
		IV iv;
		
		/* == is commutative so doesn't matter which is left or right */
		if (auvok) {
		    /* top of stack (b) is the iv */
                    ivp = *SP;
                    uvp = *--SP;
                } else {
                    uvp = *SP;
                    ivp = *--SP;
                }
                iv = SvIVX(ivp);
		if (iv < 0)
                    /* As uv is a UV, it's >0, so it cannot be == */
                    SETs(&PL_sv_no);
		else
		    /* we know iv is >= 0 */
		    SETs(boolSV((UV)iv == SvUVX(uvp)));
		RETURN;
	    }
	}
    }
#endif
    {
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
      dPOPTOPnnrl;
      if (Perl_isnan(left) || Perl_isnan(right))
	  RETSETNO;
      SETs(boolSV(left == right));
#else
      dPOPnv;
      SETs(boolSV(TOPn == value));
#endif
      RETURN;
    }
d365 4
a368 2
    if (SvTYPE(TOPs) >= SVt_PVAV || isGV_with_GP(TOPs))
	DIE(aTHX_ "%s", PL_no_modify);
d370 1
a370 1
        && SvIVX(TOPs) != IV_MAX)
d372 1
a372 1
	SvIV_set(TOPs, SvIVX(TOPs) + 1);
d376 2
a377 1
	sv_inc(TOPs);
d385 1
d404 1
d456 4
a459 3
    tryAMAGICbin(add,opASSIGN);
    svl = sv_2num(TOPm1s);
    svr = sv_2num(TOPs);
d508 2
a509 1
    SvIV_please(svr);
d526 1
a526 1
	    SvIV_please(svl);
d609 1
a609 1
	NV value = SvNV(svr);
d616 1
a616 1
	SETn( value + SvNV(svl) );
d624 2
a625 2
    AV * const av = PL_op->op_flags & OPf_SPECIAL
	? MUTABLE_AV(PAD_SV(PL_op->op_targ)) : GvAV(cGVOP_gv);
d630 2
a631 2
    if (!lval && SvGMAGICAL(sv))	/* see note in pp_helem() */
	sv = sv_mortalcopy(sv);
a669 1
    IO *io;
d674 1
d676 1
a676 1
    if (gv && (io = GvIO(gv))
d689 5
a693 16
	PUSHMARK(MARK - 1);
	*MARK = SvTIED_obj(MUTABLE_SV(io), mg);
	PUTBACK;
	ENTER_with_name("call_PRINT");
	if( PL_op->op_type == OP_SAY ) {
		/* local $\ = "\n" */
		SAVEGENERICSV(PL_ors_sv);
		PL_ors_sv = newSVpvs("\n");
	}
	call_method("PRINT", G_SCALAR);
	LEAVE_with_name("call_PRINT");
	SPAGAIN;
	MARK = ORIGMARK + 1;
	*MARK = *SP;
	SP = MARK;
	RETURN;
d695 2
a696 2
    if (!(io = GvIO(gv))) {
        if ((GvEGV(gv)) && (io = GvIO(GvEGV(gv)))
d699 1
a699 2
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
d704 4
a707 6
	if (ckWARN2(WARN_CLOSED, WARN_IO))  {
	    if (IoIFP(io))
		report_evil_fh(gv, io, OP_phoney_INPUT_ONLY);
	    else if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
		report_evil_fh(gv, io, PL_op->op_type);
	}
d770 1
d772 3
a774 3
      wasref:
	tryAMAGICunDEREF_var(is_pp_rv2av ? to_av_amg : to_hv_amg);

d777 1
d783 3
a785 1
	else if (LVRET) {
d790 1
a812 5
		if (SvGMAGICAL(sv)) {
		    mg_get(sv);
		    if (SvROK(sv))
			goto wasref;
		}
d828 3
a830 1
	    else if (LVRET) {
d835 1
d842 1
a842 1
	/* The guts of pp_rv2av, with no intenting change to preserve history
d845 16
a860 12
    if (gimme == G_ARRAY) {
	const I32 maxarg = AvFILL(av) + 1;
	(void)POPs;			/* XXXX May be optimized away? */
	EXTEND(SP, maxarg);
	if (SvRMAGICAL(av)) {
	    U32 i;
	    for (i=0; i < (U32)maxarg; i++) {
		SV ** const svp = av_fetch(av, i, FALSE);
		/* See note in pp_helem, and bug id #27839 */
		SP[i+1] = svp
		    ? SvGMAGICAL(*svp) ? sv_mortalcopy(*svp) : *svp
		    : &PL_sv_undef;
d862 1
d864 4
a867 2
	else {
	    Copy(AvARRAY(av), SP+1, maxarg, SV*);
a868 7
	SP += maxarg;
    }
    else if (gimme == G_SCALAR) {
	dTARGET;
	const I32 maxarg = AvFILL(av) + 1;
	SETi(maxarg);
    }
d871 10
a880 10
    if (gimme == G_ARRAY) { /* array wanted */
	*PL_stack_sp = sv;
	return do_kv();
    }
    else if (gimme == G_SCALAR) {
	dTARGET;
    TARG = Perl_hv_scalar(aTHX_ MUTABLE_HV(sv));
	SPAGAIN;
	SETTARG;
    }
d954 1
d956 11
a966 1
    if (PL_op->op_private & (OPpASSIGN_COMMON)) {
d971 11
a981 1
		*relem = sv_mortalcopy(sv);
d998 2
d1006 2
a1007 1
		sv = newSVsv(*relem);
d1011 1
a1011 5
		    if (SvSMAGICAL(sv)) {
			/* More magic can happen in the mg_set callback, so we
			 * backup the delaymagic for now. */
			U16 dmbak = PL_delaymagic;
			PL_delaymagic = 0;
a1012 2
			PL_delaymagic = dmbak;
		    }
d1018 1
a1018 1
	    if (PL_delaymagic & DM_ARRAY)
d1020 1
d1024 1
d1028 2
d1040 13
a1052 4
		    *(relem++) = tmpstr;
		    if (gimme != G_VOID && hv_exists_ent(hash, sv, 0))
			/* key overwrites an existing entry */
			duplicates += 2;
d1055 1
a1055 3
			if (SvSMAGICAL(tmpstr)) {
			    U16 dmbak = PL_delaymagic;
			    PL_delaymagic = 0;
a1056 2
			    PL_delaymagic = dmbak;
			}
d1066 1
d1076 8
d1089 1
a1089 7

	    if (SvSMAGICAL(sv)) {
		U16 dmbak = PL_delaymagic;
		PL_delaymagic = 0;
		mg_set(sv);
		PL_delaymagic = dmbak;
	    }
d1094 6
d1102 2
a1103 2
	    (void)setresuid((PL_delaymagic & DM_RUID) ? PL_uid  : (Uid_t)-1,
			    (PL_delaymagic & DM_EUID) ? PL_euid : (Uid_t)-1,
d1107 2
a1108 2
	    (void)setreuid((PL_delaymagic & DM_RUID) ? PL_uid  : (Uid_t)-1,
			   (PL_delaymagic & DM_EUID) ? PL_euid : (Uid_t)-1);
d1112 1
a1112 1
		(void)setruid(PL_uid);
d1118 1
a1118 1
		(void)seteuid(PL_euid);
d1123 1
a1123 1
		if (PL_uid != PL_euid)
d1125 1
a1125 1
		(void)PerlProc_setuid(PL_uid);
d1129 2
a1130 2
	    PL_uid = PerlProc_getuid();
	    PL_euid = PerlProc_geteuid();
d1134 2
a1135 2
	    (void)setresgid((PL_delaymagic & DM_RGID) ? PL_gid  : (Gid_t)-1,
			    (PL_delaymagic & DM_EGID) ? PL_egid : (Gid_t)-1,
d1139 2
a1140 2
	    (void)setregid((PL_delaymagic & DM_RGID) ? PL_gid  : (Gid_t)-1,
			   (PL_delaymagic & DM_EGID) ? PL_egid : (Gid_t)-1);
d1144 1
a1144 1
		(void)setrgid(PL_gid);
d1150 1
a1150 1
		(void)setegid(PL_egid);
d1155 1
a1155 1
		if (PL_gid != PL_egid)
d1157 1
a1157 1
		(void)PerlProc_setgid(PL_gid);
d1161 2
a1162 2
	    PL_gid = PerlProc_getgid();
	    PL_egid = PerlProc_getegid();
d1164 1
a1164 1
	PL_tainting |= (PL_uid && (PL_euid != PL_uid || PL_egid != PL_gid));
d1180 6
a1185 4
		/* Removes from the stack the entries which ended up as
		 * duplicated keys in the hash (fix for [perl #24380]) */
		Move(firsthashrelem + duplicates,
			firsthashrelem, duplicates, SV**);
d1187 7
d1226 1
a1226 1
	HV* const stash = gv_stashpv(SvPV_nolen(pkg), GV_ADD);
d1231 1
a1231 1
    if (RX_EXTFLAGS(rx) & RXf_TAINTED)
d1233 2
d1336 3
a1338 3
    if ((  !global && RX_NPARENS(rx)) 
	    || SvTEMP(TARG) || PL_sawampersand ||
	    (RX_EXTFLAGS(rx) & (RXf_EVAL_SEEN|RXf_PMf_KEEPCOPY)))
d1343 1
a1343 1
play_it_again:
d1368 6
a1373 5
    if (CALLREGEXEC(rx, (char*)s, (char *)strend, (char*)truebase,
                    minmatch, TARG, NUM2PTR(void*, gpos), r_flags))
    {
	PL_curpm = pm;
	if (dynpm->op_pmflags & PMf_ONCE) {
d1375 1
a1375 1
            SvREADONLY_on(PL_regex_pad[dynpm->op_pmoffset]);
d1377 1
a1377 1
	    dynpm->op_pmflags |= PMf_USED;
a1378 2
        }
	goto gotcha;
a1379 3
    else
	goto ret_no;
    /*NOTREACHED*/
d1399 4
a1402 1
		    DIE(aTHX_ "panic: pp_match start/end pointers");
d1564 1
a1564 1
	MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d1566 1
a1566 7
	    PUSHMARK(SP);
	    XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
	    PUTBACK;
	    ENTER_with_name("call_READLINE");
	    call_method("READLINE", gimme);
	    LEAVE_with_name("call_READLINE");
	    SPAGAIN;
d1568 3
a1570 3
		SV* const result = POPs;
		SvSetSV_nosteal(TARG, result);
		PUSHTARG;
d1572 1
a1572 1
	    RETURN;
d1601 2
a1602 2
	else if (ckWARN(WARN_IO) && IoTYPE(io) == IoTYPE_WRONLY) {
	    report_evil_fh(PL_last_in_gv, io, OP_phoney_OUTPUT_ONLY);
d1610 1
a1610 1
		Perl_warner(aTHX_ packWARN(WARN_GLOB),
d1614 1
a1614 1
		report_evil_fh(PL_last_in_gv, io, PL_op->op_type);
d1633 1
a1633 1
		SvPV_force_nolen(sv);
d1638 1
a1638 1
	    SvPV_force_nolen(sv);
d1642 6
a1647 2
	if (!tmplen && !SvREADONLY(sv))
	    Sv_Grow(sv, 80);	/* try short-buffering it */
d1651 1
a1651 1
		SvPV_force_nolen(sv);
a1759 25
PP(pp_enter)
{
    dVAR; dSP;
    register PERL_CONTEXT *cx;
    I32 gimme = OP_GIMME(PL_op, -1);

    if (gimme == -1) {
	if (cxstack_ix >= 0) {
	    /* If this flag is set, we're just inside a return, so we should
	     * store the caller's context */
	    gimme = (PL_op->op_flags & OPf_SPECIAL)
		? block_gimme()
		: cxstack[cxstack_ix].blk_gimme;
	} else
	    gimme = G_SCALAR;
    }

    ENTER_with_name("block");

    SAVETMPS;
    PUSHBLOCK(cx, CXt_BLOCK, SP);

    RETURN;
}

d1792 1
a1792 1
	if (!svp || *svp == &PL_sv_undef) {
d1817 4
a1820 2
	else if (PL_op->op_private & OPpDEREF)
	    vivify_ref(*svp, PL_op->op_private & OPpDEREF);
d1822 15
a1836 9
    sv = (svp ? *svp : &PL_sv_undef);
    /* This makes C<local $tied{foo} = $tied{foo}> possible.
     * Pushing the magical RHS on to the stack is useless, since
     * that magic is soon destined to be misled by the local(),
     * and thus the later pp_sassign() will fail to mg_get() the
     * old value.  This should also cure problems with delayed
     * mg_get()s.  GSAR 98-07-03 */
    if (!lval && SvGMAGICAL(sv))
	sv = sv_mortalcopy(sv);
a1840 51
PP(pp_leave)
{
    dVAR; dSP;
    register PERL_CONTEXT *cx;
    SV **newsp;
    PMOP *newpm;
    I32 gimme;

    if (PL_op->op_flags & OPf_SPECIAL) {
	cx = &cxstack[cxstack_ix];
	cx->blk_oldpm = PL_curpm;	/* fake block should preserve $1 et al */
    }

    POPBLOCK(cx,newpm);

    gimme = OP_GIMME(PL_op, (cxstack_ix >= 0) ? gimme : G_SCALAR);

    TAINT_NOT;
    if (gimme == G_VOID)
	SP = newsp;
    else if (gimme == G_SCALAR) {
	register SV **mark;
	MARK = newsp + 1;
	if (MARK <= SP) {
	    if (SvFLAGS(TOPs) & (SVs_PADTMP|SVs_TEMP))
		*MARK = TOPs;
	    else
		*MARK = sv_mortalcopy(TOPs);
	} else {
	    MEXTEND(mark,0);
	    *MARK = &PL_sv_undef;
	}
	SP = MARK;
    }
    else if (gimme == G_ARRAY) {
	/* in case LEAVE wipes old return values */
	register SV **mark;
	for (mark = newsp + 1; mark <= SP; mark++) {
	    if (!(SvFLAGS(*mark) & (SVs_PADTMP|SVs_TEMP))) {
		*mark = sv_mortalcopy(*mark);
		TAINT_NOT;	/* Each item is independent */
	    }
	}
    }
    PL_curpm = newpm;	/* Don't pop $1 et al till now */

    LEAVE_with_name("block");

    RETURN;
}

d1853 1
a1853 1
	DIE(aTHX_ "panic: pp_iter");
d1979 67
d2061 2
a2062 1
    U8 rxtainted;
a2070 1
    I32 matched;
a2074 1

d2077 3
d2097 1
a2097 1
    if (
d2099 1
a2099 1
	!is_cow &&
d2101 5
a2105 5
	(SvREADONLY(TARG)
	 || ( ((SvTYPE(TARG) == SVt_PVGV && isGV_with_GP(TARG))
	       || SvTYPE(TARG) > SVt_PVLV)
	     && !(SvTYPE(TARG) == SVt_PVGV && SvFAKE(TARG)))))
	DIE(aTHX_ "%s", PL_no_modify);
d2108 1
d2112 14
a2125 5
    rxtainted = ((RX_EXTFLAGS(rx) & RXf_TAINTED) ||
		 (PL_tainted && (pm->op_pmflags & PMf_RETAINT)));
    if (PL_tainted)
	rxtainted |= 2;
    TAINT_NOT;
d2131 1
a2131 1
	DIE(aTHX_ "panic: pp_subst");
d2155 1
a2155 1
	    goto nope;
d2167 10
a2176 4
    /* only replace once? */
    once = !(rpm->op_pmflags & PMf_GLOBAL);
    matched = CALLREGEXEC(rx, s, strend, orig, 0, TARG, NULL,
			 r_flags | REXEC_CHECKED);
d2179 19
d2226 4
a2229 8
	&& (!doutf8 || SvUTF8(TARG))) {
	if (!matched)
	{
	    SPAGAIN;
	    PUSHs(&PL_sv_no);
	    LEAVE_SCOPE(oldsave);
	    RETURN;
	}
d2245 2
a2246 1
	    rxtainted |= RX_MATCH_TAINTED(rx);
a2278 1
	    TAINT_IF(rxtainted & 1);
d2286 2
a2287 1
		rxtainted |= RX_MATCH_TAINTED(rx);
a2307 1
	    TAINT_IF(rxtainted & 1);
a2310 12
	(void)SvPOK_only_UTF8(TARG);
	TAINT_IF(rxtainted);
	if (SvSMAGICAL(TARG)) {
	    PUTBACK;
	    mg_set(TARG);
	    SPAGAIN;
	}
	SvTAINT(TARG);
	if (doutf8)
	    SvUTF8_on(TARG);
	LEAVE_SCOPE(oldsave);
	RETURN;
d2312 1
a2312 3

    if (matched)
    {
d2315 8
d2329 3
a2331 3
	rxtainted |= RX_MATCH_TAINTED(rx);
	dstr = newSVpvn_utf8(m, s-m, DO_UTF8(TARG));
	SAVEFREESV(dstr);
d2336 5
d2348 2
a2349 1
	    rxtainted |= RX_MATCH_TAINTED(rx);
d2374 7
d2382 8
a2389 8
	/* The match may make the string COW. If so, brilliant, because that's
	   just saved us one malloc, copy and free - the regexp has donated
	   the old buffer, and we malloc an entirely new one, rather than the
	   regexp malloc()ing a buffer and copying our original, only for
	   us to throw it away here during the substitution.  */
	if (SvIsCOW(TARG)) {
	    sv_force_normal_flags(TARG, SV_COW_DROP_PV);
	} else
d2391 11
a2401 2
	{
	    SvPV_free(TARG);
d2403 1
a2403 5
	SvPV_set(TARG, SvPVX(dstr));
	SvCUR_set(TARG, SvCUR(dstr));
	SvLEN_set(TARG, SvLEN(dstr));
	doutf8 |= DO_UTF8(dstr);
	SvPV_set(dstr, NULL);
d2405 2
a2406 5
	TAINT_IF(rxtainted & 1);
	SPAGAIN;
	mPUSHi((I32)iters);

	(void)SvPOK_only(TARG);
d2409 20
a2428 2
	TAINT_IF(rxtainted);
	SvSETMAGIC(TARG);
a2429 2
	LEAVE_SCOPE(oldsave);
	RETURN;
d2431 2
a2432 6
    goto ret_no;

nope:
ret_no:
    SPAGAIN;
    PUSHs(&PL_sv_no);
d2444 1
d2510 2
a2511 1
		if (SvTEMP(TOPs)) {
d2523 4
d2528 1
a2528 1
		*MARK = SvTEMP(TOPs) ? TOPs : sv_mortalcopy(TOPs);
d2538 2
a2539 1
	    if (!SvTEMP(*MARK)) {
a2555 164
/* This duplicates the above code because the above code must not
 * get any slower by more conditions */
PP(pp_leavesublv)
{
    dVAR; dSP;
    SV **mark;
    SV **newsp;
    PMOP *newpm;
    I32 gimme;
    register PERL_CONTEXT *cx;
    SV *sv;

    if (CxMULTICALL(&cxstack[cxstack_ix]))
	return 0;

    POPBLOCK(cx,newpm);
    cxstack_ix++; /* temporarily protect top context */

    TAINT_NOT;

    if (CxLVAL(cx) & OPpENTERSUB_INARGS) {
	/* We are an argument to a function or grep().
	 * This kind of lvalueness was legal before lvalue
	 * subroutines too, so be backward compatible:
	 * cannot report errors.  */

	/* Scalar context *is* possible, on the LHS of -> only,
	 * as in f()->meth().  But this is not an lvalue. */
	if (gimme == G_SCALAR)
	    goto temporise;
	if (gimme == G_ARRAY) {
	    if (!CvLVALUE(cx->blk_sub.cv))
		goto temporise_array;
	    EXTEND_MORTAL(SP - newsp);
	    for (mark = newsp + 1; mark <= SP; mark++) {
		if (SvTEMP(*mark))
		    NOOP;
		else if (SvFLAGS(*mark) & (SVs_PADTMP | SVf_READONLY))
		    *mark = sv_mortalcopy(*mark);
		else {
		    /* Can be a localized value subject to deletion. */
		    PL_tmps_stack[++PL_tmps_ix] = *mark;
		    SvREFCNT_inc_void(*mark);
		}
	    }
	}
    }
    else if (CxLVAL(cx)) {     /* Leave it as it is if we can. */
	/* Here we go for robustness, not for speed, so we change all
	 * the refcounts so the caller gets a live guy. Cannot set
	 * TEMP, so sv_2mortal is out of question. */
	if (!CvLVALUE(cx->blk_sub.cv)) {
	    LEAVE;
	    cxstack_ix--;
	    POPSUB(cx,sv);
	    PL_curpm = newpm;
	    LEAVESUB(sv);
	    DIE(aTHX_ "Can't modify non-lvalue subroutine call");
	}
	if (gimme == G_SCALAR) {
	    MARK = newsp + 1;
	    EXTEND_MORTAL(1);
	    if (MARK == SP) {
		/* Temporaries are bad unless they happen to be elements
		 * of a tied hash or array */
		if (SvFLAGS(TOPs) & (SVs_TEMP | SVs_PADTMP | SVf_READONLY) &&
		    !(SvRMAGICAL(TOPs) && mg_find(TOPs, PERL_MAGIC_tiedelem))) {
		    LEAVE;
		    cxstack_ix--;
		    POPSUB(cx,sv);
		    PL_curpm = newpm;
		    LEAVESUB(sv);
		    DIE(aTHX_ "Can't return %s from lvalue subroutine",
			SvREADONLY(TOPs) ? (TOPs == &PL_sv_undef) ? "undef"
			: "a readonly value" : "a temporary");
		}
		else {                  /* Can be a localized value
					 * subject to deletion. */
		    PL_tmps_stack[++PL_tmps_ix] = *mark;
		    SvREFCNT_inc_void(*mark);
		}
	    }
	    else {			/* Should not happen? */
		LEAVE;
		cxstack_ix--;
		POPSUB(cx,sv);
		PL_curpm = newpm;
		LEAVESUB(sv);
		DIE(aTHX_ "%s returned from lvalue subroutine in scalar context",
		    (MARK > SP ? "Empty array" : "Array"));
	    }
	    SP = MARK;
	}
	else if (gimme == G_ARRAY) {
	    EXTEND_MORTAL(SP - newsp);
	    for (mark = newsp + 1; mark <= SP; mark++) {
		if (*mark != &PL_sv_undef
		    && SvFLAGS(*mark) & (SVs_TEMP | SVs_PADTMP | SVf_READONLY)) {
		    /* Might be flattened array after $#array =  */
		    PUTBACK;
		    LEAVE;
		    cxstack_ix--;
		    POPSUB(cx,sv);
		    PL_curpm = newpm;
		    LEAVESUB(sv);
		    DIE(aTHX_ "Can't return a %s from lvalue subroutine",
			SvREADONLY(TOPs) ? "readonly value" : "temporary");
		}
		else {
		    /* Can be a localized value subject to deletion. */
		    PL_tmps_stack[++PL_tmps_ix] = *mark;
		    SvREFCNT_inc_void(*mark);
		}
	    }
	}
    }
    else {
	if (gimme == G_SCALAR) {
	  temporise:
	    MARK = newsp + 1;
	    if (MARK <= SP) {
		if (cx->blk_sub.cv && CvDEPTH(cx->blk_sub.cv) > 1) {
		    if (SvTEMP(TOPs)) {
			*MARK = SvREFCNT_inc(TOPs);
			FREETMPS;
			sv_2mortal(*MARK);
		    }
		    else {
			sv = SvREFCNT_inc(TOPs); /* FREETMPS could clobber it */
			FREETMPS;
			*MARK = sv_mortalcopy(sv);
			SvREFCNT_dec(sv);
		    }
		}
		else
		    *MARK = SvTEMP(TOPs) ? TOPs : sv_mortalcopy(TOPs);
	    }
	    else {
		MEXTEND(MARK, 0);
		*MARK = &PL_sv_undef;
	    }
	    SP = MARK;
	}
	else if (gimme == G_ARRAY) {
	  temporise_array:
	    for (MARK = newsp + 1; MARK <= SP; MARK++) {
		if (!SvTEMP(*MARK)) {
		    *MARK = sv_mortalcopy(*MARK);
		    TAINT_NOT;  /* Each item is independent */
		}
	    }
	}
    }
    PUTBACK;

    LEAVE;
    cxstack_ix--;
    POPSUB(cx,sv);	/* Stack values are safe: release CV and @@_ ... */
    PL_curpm = newpm;	/* ... and pop $1 et al */

    LEAVESUB(sv);
    return cx->blk_sub.retop;
}

d2570 1
a2570 2
	if (!isGV_with_GP(sv))
	    DIE(aTHX_ "Not a CODE reference");
d2581 3
d2585 15
a2599 1
	if (!SvROK(sv)) {
d2602 1
a2602 20
	    if (sv == &PL_sv_yes) {		/* unfound import, ignore */
		if (hasargs)
		    SP = PL_stack_base + POPMARK;
		RETURN;
	    }
	    if (SvGMAGICAL(sv)) {
		mg_get(sv);
		if (SvROK(sv))
		    goto got_rv;
		if (SvPOKp(sv)) {
		    sym = SvPVX_const(sv);
		    len = SvCUR(sv);
		} else {
		    sym = NULL;
		    len = 0;
		}
	    }
	    else {
		sym = SvPV_const(sv, len);
            }
d2606 1
a2606 1
		DIE(aTHX_ "Can't use string (\"%.32s\"%s) as a subroutine ref while \"strict refs\" in use", sym, len>32 ? "..." : "");
a2609 5
  got_rv:
	{
	    SV * const * sp = &sv;		/* Used in tryAMAGICunDEREF macro. */
	    tryAMAGICunDEREF(to_cv);
	}	
d2627 2
d2644 2
a2645 2
	    if ((autogv = gv_autoload4(GvSTASH(gv), GvNAME(gv), GvNAMELEN(gv),
				   FALSE)))
d2736 3
d2778 1
a2778 1
	CALL_FPTR(CvXSUB(cv))(aTHX_ cv);
a2824 2
    if (elem > 0)
	elem -= CopARYBASE_get(PL_curcop);
d2875 4
a2878 2
	else if (PL_op->op_private & OPpDEREF)
	    vivify_ref(*svp, PL_op->op_private & OPpDEREF);
d2881 2
a2882 2
    if (!lval && SvGMAGICAL(sv))	/* see note in pp_helem() */
	sv = sv_mortalcopy(sv);
d2887 1
a2887 1
void
d2895 1
a2895 1
	    Perl_croak(aTHX_ "%s", PL_no_modify);
d2910 8
d2919 1
a2955 1
    const char* packname = NULL;
a2956 1
    STRLEN packlen;
d2970 3
d2975 7
a2981 2
        if(SvOK(sv) && (packname = SvPV_const(sv, packlen))) {
          const HE* const he = hv_fetch_ent(PL_stashcache, sv, 0, 0);
d2990 3
a2992 1
	    !(iogv = gv_fetchsv(sv, 0, SVt_PVIO)) ||
d2999 1
a2999 1
		    : !isIDFIRST(*packname)
d3002 1
d3009 1
a3009 1
	    stash = gv_stashpvn(packname, packlen, 0);
d3014 2
a3015 1
	        (void)hv_store(PL_stashcache, packname, packlen, ref, 0);
d3030 4
a3033 4
	const char * const name = SvPV_nolen_const(meth);
	Perl_croak(aTHX_ "Can't call method \"%s\" on unblessed reference",
		   (SvSCREAM(meth) && strEQ(name,"isa")) ? "DOES" :
		   name);
d3054 2
a3055 3
    gv = gv_fetchmethod_flags(stash ? stash : MUTABLE_HV(packsv),
			      SvPV_nolen_const(meth),
			      GV_AUTOLOAD | GV_CROAK);
@


1.13
log
@Merge in perl 5.10.1
@
text
@d44 1
a44 8
    if ( PL_op->op_flags & OPf_SPECIAL )
        /* This is a const op added to hold the hints hash for
           pp_entereval. The hash can be modified by the code
           being eval'ed, so we return a copy instead. */
        mXPUSHs((SV*)Perl_hv_copy_hints_hv(aTHX_ (HV*)cSVOP_sv));
    else
        /* Normal const. */
        XPUSHs(cSVOP_sv);
a75 7
PP(pp_setstate)
{
    dVAR;
    PL_curcop = (COP*)PL_op;
    return NORMAL;
}

d141 1
a141 1
		SvUPGRADE(MUTABLE_SV(gv), SVt_RV);
d160 1
a160 1
		ENTER;
d170 1
a170 1
		LEAVE;
d722 1
a722 1
	ENTER;
d729 1
a729 1
	LEAVE;
d756 1
d758 1
a758 1
	if (PL_ofs_sv && SvOK(PL_ofs_sv)) {
d764 2
a765 1
		    if (!do_print(PL_ofs_sv, fp)) { /* $, */
d1208 1
a1208 1
    SV * const pkg = CALLREG_PACKAGE(rx);
d1210 17
a1226 2
    SV * const sv = newSVrv(rv, SvPV_nolen(pkg));
    SvREFCNT_dec(pkg);
a1228 1
    sv_magic(sv,(SV*)ReREFCNT_inc(rx), PERL_MAGIC_qr,0,0);
d1242 1
a1242 1
    I32 r_flags = REXEC_CHECKED;
d1264 5
a1268 1
    s = SvPV_const(TARG, len);
d1503 4
a1506 3
	    rx->saved_copy = sv_setsv_cow(rx->saved_copy, TARG);
	    RX_SUBBEG(rx) = (char *) SvPVX_const(rx->saved_copy) + (t - truebase);
	    assert (SvPOKp(rx->saved_copy));
d1513 1
a1513 1
	    rx->saved_copy = NULL;
d1564 1
a1564 1
	    ENTER;
d1566 1
a1566 1
	    LEAVE;
d1685 5
a1689 5
		if (!do_close(PL_last_in_gv, FALSE) && ckWARN(WARN_GLOB)) {
		    Perl_warner(aTHX_ packWARN(WARN_GLOB),
			   "glob failed (child exited with status %d%s)",
			   (int)(STATUS_CURRENT >> 8),
			   (STATUS_CURRENT & 0x80) ? ", core dumped" : "");
d1764 7
a1770 3
	if (cxstack_ix >= 0)
	    gimme = cxstack[cxstack_ix].blk_gimme;
	else
d1774 1
a1774 1
    ENTER;
d1793 2
a1794 1
    I32 preeminent = 0;
d1799 1
a1799 1
    if (PL_op->op_private & OPpLVAL_INTRO) {
d1802 7
a1808 13
	/* does the element we're localizing already exist? */
	preeminent = /* can we determine whether it exists? */
	    (    !SvRMAGICAL(hv)
		|| mg_find((const SV *)hv, PERL_MAGIC_env)
		|| (     (mg = mg_find((const SV *)hv, PERL_MAGIC_tied))
			/* Try to preserve the existenceness of a tied hash
			* element by using EXISTS and DELETE if possible.
			* Fallback to FETCH and STORE otherwise */
		    && (stash = SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(hv), mg))))
		    && gv_fetchmethod_autoload(stash, "EXISTS", TRUE)
		    && gv_fetchmethod_autoload(stash, "DELETE", TRUE)
		)
	    ) ? hv_exists_ent(hv, keysv, 0) : 1;
d1810 1
d1830 1
a1830 1
	if (PL_op->op_private & OPpLVAL_INTRO) {
d1833 5
a1837 9
	    else {
		if (!preeminent) {
		    STRLEN keylen;
		    const char * const key = SvPV_const(keysv, keylen);
		    SAVEDELETE(hv, savepvn(key,keylen),
			       SvUTF8(keysv) ? -(I32)keylen : (I32)keylen);
		} else
		    save_helem(hv, keysv, svp);
            }
d1870 1
a1870 7
    gimme = OP_GIMME(PL_op, -1);
    if (gimme == -1) {
	if (cxstack_ix >= 0)
	    gimme = cxstack[cxstack_ix].blk_gimme;
	else
	    gimme = G_SCALAR;
    }
d1901 1
a1901 1
    LEAVE;
a1910 1
    AV* av;
d1912 2
d1917 1
a1917 1
    if (CxTYPE(cx) != CXt_LOOP)
d1921 1
a1921 4
    av = cx->blk_loop.iterary;
    if (SvTYPE(av) != SVt_PVAV) {
	/* iterate ($min .. $max) */
	if (cx->blk_loop.iterlval) {
d1923 2
a1924 1
	    register SV* cur = cx->blk_loop.iterlval;
d1928 1
a1928 1
	    const char *max = SvPV_const((SV*)av, maxlen);
d1950 2
a1951 1
	}
d1953 1
a1953 1
	if (cx->blk_loop.iterix > cx->blk_loop.itermax)
d1959 1
a1959 1
	    sv_setiv(*itersvp, cx->blk_loop.iterix++);
d1967 1
a1967 1
	    *itersvp = newSViv(cx->blk_loop.iterix++);
d1972 2
a1973 2
	if ((cx->blk_loop.iterix == IV_MIN) &&
	    (cx->blk_loop.itermax == IV_MAX))
d1975 2
a1976 2
	    cx->blk_loop.iterix++;
	    cx->blk_loop.itermax++;
d1983 6
d1990 2
a1991 2
	/* In reverse, use itermax as the min :-)  */
	if (cx->blk_loop.iterix <= cx->blk_loop.itermax)
d1995 1
a1995 1
	    SV * const * const svp = av_fetch(av, --cx->blk_loop.iterix, FALSE);
d1999 1
a1999 1
	    sv = AvARRAY(av)[--cx->blk_loop.iterix];
d2003 1
a2003 1
	if (cx->blk_loop.iterix >= (av == PL_curstack ? cx->blk_oldsp :
d2008 1
a2008 1
	    SV * const * const svp = av_fetch(av, ++cx->blk_loop.iterix, FALSE);
d2012 1
a2012 1
	    sv = AvARRAY(av)[++cx->blk_loop.iterix];
d2021 1
a2021 1
    if (sv)
d2023 2
d2027 4
a2030 13
    if (av != PL_curstack && sv == &PL_sv_undef) {
	SV *lv = cx->blk_loop.iterlval;
	if (lv && SvREFCNT(lv) > 1) {
	    SvREFCNT_dec(lv);
	    lv = NULL;
	}
	if (lv)
	    SvREFCNT_dec(LvTARG(lv));
	else {
	    lv = cx->blk_loop.iterlval = newSV_type(SVt_PVLV);
	    LvTYPE(lv) = 'y';
	    sv_magic(lv, NULL, PERL_MAGIC_defelem, NULL, 0);
	}
d2032 1
a2032 1
	LvTARGOFF(lv) = cx->blk_loop.iterix;
d2034 1
a2034 1
	sv = (SV*)lv;
d2038 1
a2038 1
    *itersvp = SvREFCNT_inc_simple_NN(sv);
d2061 1
a2061 1
    I32 r_flags;
d2388 1
a2388 1
    LEAVE;					/* exit inner scope */
d2395 1
a2395 1
	LEAVE;					/* exit outer scope */
d2418 1
a2418 1
	ENTER;					/* enter inner scope */
d2710 1
a2710 1
		DIE(aTHX_ PL_no_symref, sym, "a subroutine");
d2775 1
a2775 1
	     cv = GvCV(gv_HVadd(gv_fetchpv("DB::lsub", GV_ADDMULTI, SVt_PVHV)));
a2849 4
#if 0
	DEBUG_S(PerlIO_printf(Perl_debug_log,
			      "%p entersub returning %p\n", (void*)thr, (void*)CvSTART(cv)));
#endif
d2879 4
a2882 2
	if (CvXSUB(cv)) /* XXX this is supposed to be true */
	    (void)(*CvXSUB(cv))(aTHX_ cv);
d2921 2
d2933 13
d2975 6
a2980 2
	if (PL_op->op_private & OPpLVAL_INTRO)
	    save_aelem(av, elem, svp);
a3050 1
    STRLEN namelen;
a3053 1
    const char * const name = SvPV_const(meth, namelen);
d3059 2
a3060 1
	Perl_croak(aTHX_ "Can't call method \"%s\" on an undefined value", name);
d3089 2
a3090 1
		Perl_croak(aTHX_ "Can't call method \"%s\" %s", name,
d3115 1
d3139 3
a3141 44
    gv = gv_fetchmethod(stash ? stash : MUTABLE_HV(packsv), name);

    if (!gv) {
	/* This code tries to figure out just what went wrong with
	   gv_fetchmethod.  It therefore needs to duplicate a lot of
	   the internals of that function.  We can't move it inside
	   Perl_gv_fetchmethod_autoload(), however, since that would
	   cause UNIVERSAL->can("NoSuchPackage::foo") to croak, and we
	   don't want that.
	*/
	const char* leaf = name;
	const char* sep = NULL;
	const char* p;

	for (p = name; *p; p++) {
	    if (*p == '\'')
		sep = p, leaf = p + 1;
	    else if (*p == ':' && *(p + 1) == ':')
		sep = p, leaf = p + 2;
	}
	if (!sep || ((sep - name) == 5 && strnEQ(name, "SUPER", 5))) {
	    /* the method name is unqualified or starts with SUPER:: */
#ifndef USE_ITHREADS
	    if (sep)
		stash = CopSTASH(PL_curcop);
#else
	    bool need_strlen = 1;
	    if (sep) {
		packname = CopSTASHPV(PL_curcop);
	    }
	    else
#endif
	    if (stash) {
		HEK * const packhek = HvNAME_HEK(stash);
		if (packhek) {
		    packname = HEK_KEY(packhek);
		    packlen = HEK_LEN(packhek);
#ifdef USE_ITHREADS
		    need_strlen = 0;
#endif
		} else {
		    goto croak;
		}
	    }
d3143 1
a3143 9
	    if (!packname) {
	    croak:
		Perl_croak(aTHX_
			   "Can't use anonymous symbol table for method lookup");
	    }
#ifdef USE_ITHREADS
	    if (need_strlen)
		packlen = strlen(packname);
#endif
a3144 20
	}
	else {
	    /* the method name is qualified */
	    packname = name;
	    packlen = sep - name;
	}
	
	/* we're relying on gv_fetchmethod not autovivifying the stash */
	if (gv_stashpvn(packname, packlen, 0)) {
	    Perl_croak(aTHX_
		       "Can't locate object method \"%s\" via package \"%.*s\"",
		       leaf, (int)packlen, packname);
	}
	else {
	    Perl_croak(aTHX_
		       "Can't locate object method \"%s\" via package \"%.*s\""
		       " (perhaps you forgot to load \"%.*s\"?)",
		       leaf, (int)packlen, packname, (int)packlen, packname);
	}
    }
@


1.12
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
d15 4
a18 2
 *            Awake!  Awake!  Fear, Fire, Foes!  Awake!
 *                     Fire, Foes!  Awake!
d48 1
a48 1
        XPUSHs(sv_2mortal((SV*)Perl_hv_copy_hints_hv(aTHX_ (HV*)cSVOP_sv)));
d108 1
a108 1
    XPUSHs((SV*)cGVOP_gv);
d155 1
a155 1
		SvUPGRADE((SV *)gv, SVt_RV);
d167 1
a167 1
	    right = (SV*)gv_fetchsv(right, GV_ADD, SVt_PVGV);
d181 2
a182 2
		SvRV_set(left, (SV *)newCONSTSUB(GvSTASH(right), NULL,
						 SvRV(cv)));
d199 1
a199 1
		GV *const upgraded = (GV *) cv;
d207 1
a207 1
		SvRV_set(left, (SV *)source);
d253 1
a253 1
	right = sv_2mortal(newSVpvn(rpv, rlen));
d274 1
a274 1
	    sv_setpvn(left, "", 0);
d292 1
a292 1
		right = sv_2mortal(newSVpvn(rpv, rlen));
d325 4
a328 4
    PL_last_in_gv = (GV*)(*PL_stack_sp--);
    if (SvTYPE(PL_last_in_gv) != SVt_PVGV) {
	if (SvROK(PL_last_in_gv) && SvTYPE(SvRV(PL_last_in_gv)) == SVt_PVGV)
	    PL_last_in_gv = (GV*)SvRV(PL_last_in_gv);
d331 1
a331 1
	    XPUSHs((SV*)PL_last_in_gv);
d334 1
a334 1
	    PL_last_in_gv = (GV*)(*PL_stack_sp--);
d416 2
a417 2
    if (SvTYPE(TOPs) >= SVt_PVGV && SvTYPE(TOPs) != SVt_PVLV)
	DIE(aTHX_ PL_no_modify);
d668 2
a669 2
    AV * const av = PL_op->op_flags & OPf_SPECIAL ?
		(AV*)PAD_SV(PL_op->op_targ) : GvAV(cGVOP_gv);
d704 1
a704 1
    XPUSHs((SV*)PL_op);
d717 2
a718 1
    GV * const gv = (PL_op->op_flags & OPf_STACKED) ? (GV*)*++MARK : PL_defoutgv;
d721 1
a721 1
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
d734 1
a734 1
	*MARK = SvTIED_obj((SV*)io, mg);
d737 5
d752 1
a752 1
	    && (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
a820 2
    static const char return_array_to_lvalue_scalar[] = "Can't return array to lvalue scalar context";
    static const char return_hash_to_lvalue_scalar[] = "Can't return hash to lvalue scalar context";
d839 1
a839 2
		Perl_croak(aTHX_ is_pp_rv2av ? return_array_to_lvalue_scalar
			   : return_hash_to_lvalue_scalar);
d845 1
a845 1
	    Perl_croak(aTHX_ PL_no_localize_ref);
d855 1
a855 3
		    Perl_croak(aTHX_
			       is_pp_rv2av ? return_array_to_lvalue_scalar
			       : return_hash_to_lvalue_scalar);
d863 1
a863 1
	    if (SvTYPE(sv) != SVt_PVGV) {
d875 1
a875 1
		gv = (GV*)sv;
d877 1
a877 1
	    sv = is_pp_rv2av ? (SV*)GvAVn(gv) : (SV*)GvHVn(gv);
d879 1
a879 1
		sv = is_pp_rv2av ? (SV*)save_ary(gv) : (SV*)save_hash(gv);
d886 1
a886 3
		    Perl_croak(aTHX_
			       is_pp_rv2av ? return_array_to_lvalue_scalar
			       : return_hash_to_lvalue_scalar);
d894 1
a894 1
	AV *const av = (AV*)sv;
d930 1
a930 1
    TARG = Perl_hv_scalar(aTHX_ (HV*)sv);
d936 5
d947 3
d965 1
a965 1
	    Perl_warner(aTHX_ packWARN(WARN_MISC), err);
d1028 1
a1028 1
	    ary = (AV*)sv;
d1040 5
a1044 1
		    if (SvSMAGICAL(sv))
d1046 2
d1054 1
a1054 1
		SvSETMAGIC((SV*)ary);
d1059 1
a1059 1
		hash = (HV*)sv;
d1077 3
a1079 1
			if (SvSMAGICAL(tmpstr))
d1081 2
d1106 7
a1112 1
	    SvSETMAGIC(sv);
d1223 2
a1224 1
    if (rx->extflags & RXf_TAINTED)
d1266 1
a1266 1
    rxtainted = ((rx->extflags & RXf_TAINTED) ||
d1289 1
a1289 1
    if (!rx->prelen && PL_curpm) {
d1294 1
a1294 1
    if (rx->minlen > (I32)len)
d1301 1
a1301 1
	rx->offs[0].start = -1;
d1305 3
a1307 3
		if (!(rx->extflags & RXf_GPOS_SEEN))
		    rx->offs[0].end = rx->offs[0].start = mg->mg_len;
		else if (rx->extflags & RXf_ANCH_GPOS) {
d1309 2
a1310 2
		    rx->offs[0].end = rx->offs[0].start = mg->mg_len;
		} else if (rx->extflags & RXf_GPOS_FLOAT) 
d1313 2
a1314 2
		    rx->offs[0].end = rx->offs[0].start = mg->mg_len;
		minmatch = (mg->mg_flags & MGf_MINMATCH) ? rx->gofs + 1 : 0;
d1324 1
a1324 1
    if ((  !global &&  rx->nparens) 
d1326 1
a1326 1
	    (rx->extflags & (RXf_EVAL_SEEN|RXf_PMf_KEEPCOPY)))
d1332 3
a1334 3
    if (global && rx->offs[0].start != -1) {
	t = s = rx->offs[0].end + truebase - rx->gofs;
	if ((s + rx->minlen) > strend || s < truebase)
d1339 2
a1340 2
    if (rx->extflags & RXf_USE_INTUIT &&
	DO_UTF8(TARG) == ((rx->extflags & RXf_UTF8) != 0)) {
d1347 1
a1347 1
	if ( (rx->extflags & RXf_CHECK_ALL)
d1349 3
a1351 3
	     && !(rx->extflags & RXf_PMf_KEEPCOPY)
	     && ((rx->extflags & RXf_NOSCAN)
		 || !((rx->extflags & RXf_INTUIT_TAIL)
d1356 2
a1357 1
    if (CALLREGEXEC(rx, (char*)s, (char *)strend, (char*)truebase, minmatch, TARG, INT2PTR(void*, gpos), r_flags))
d1378 1
a1378 1
	const I32 nparens = rx->nparens;
d1386 4
a1389 4
	    if ((rx->offs[i].start != -1) && rx->offs[i].end != -1 ) {
		const I32 len = rx->offs[i].end - rx->offs[i].start;
		s = rx->offs[i].start + truebase;
	        if (rx->offs[i].end < 0 || rx->offs[i].start < 0 ||
d1410 3
a1412 3
		if (rx->offs[0].start != -1) {
		    mg->mg_len = rx->offs[0].end;
		    if (rx->offs[0].start + rx->gofs == (UV)rx->offs[0].end)
d1418 3
a1420 3
	    had_zerolen = (rx->offs[0].start != -1
			   && (rx->offs[0].start + rx->gofs
			       == (UV)rx->offs[0].end));
d1445 3
a1447 3
	    if (rx->offs[0].start != -1) {
		mg->mg_len = rx->offs[0].end;
		if (rx->offs[0].start + rx->gofs == (UV)rx->offs[0].end)
d1470 1
a1470 1
	Safefree(rx->subbeg);
d1472 1
a1472 1
    rx->subbeg = NULL;
d1475 2
a1476 2
	rx->subbeg = (char *) truebase;
	rx->offs[0].start = s - truebase;
d1478 2
a1479 2
	    char * const t = (char*)utf8_hop((U8*)s, rx->minlenret);
	    rx->offs[0].end = t - truebase;
d1482 1
a1482 1
	    rx->offs[0].end = s - truebase + rx->minlenret;
d1484 1
a1484 1
	rx->sublen = strend - truebase;
d1487 1
a1487 1
    if (PL_sawampersand || rx->extflags & RXf_PMf_KEEPCOPY) {
d1498 1
a1498 1
	    rx->subbeg = (char *) SvPVX_const(rx->saved_copy) + (t - truebase);
d1504 1
a1504 1
	    rx->subbeg = savepvn(t, strend - t);
d1509 1
a1509 1
	rx->sublen = strend - t;
d1511 2
a1512 2
	off = rx->offs[0].start = s - t;
	rx->offs[0].end = off + rx->minlenret;
d1515 2
a1516 2
	rx->offs[0].start = s - truebase;
	rx->offs[0].end = s - truebase + rx->minlenret;
d1518 1
a1518 1
    /* including rx->nparens in the below code seems highly suspicious.
d1520 1
a1520 1
    rx->nparens = rx->lastparen = rx->lastcloseparen = 0;	/* used by @@-, @@+, and $^N */
d1552 1
a1552 1
	MAGIC * const mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
d1555 1
a1555 1
	    XPUSHs(SvTIED_obj((SV*)io, mg));
d1579 1
a1579 1
			sv_setpvn(GvSVn(PL_last_in_gv), "-", 1);
d1777 1
a1777 1
    HV * const hv = (HV*)POPs;
d1793 2
a1794 2
		|| mg_find((SV*)hv, PERL_MAGIC_env)
		|| (     (mg = mg_find((SV*)hv, PERL_MAGIC_tied))
d1798 1
a1798 1
		    && (stash = SvSTASH(SvRV(SvTIED_obj((SV*)hv, mg))))
d1825 1
a1825 1
		save_gp((GV*)*svp, !(PL_op->op_flags & OPf_SPECIAL));
d1929 2
d1932 1
a1932 3
	    const char *max =
	      SvOK((SV*)av) ?
	      SvPV_const((SV*)av, maxlen) : (const char *)"";
d1973 9
d2063 1
a2063 1
    bool rxtainted;
d2072 1
d2105 1
a2105 1
	DIE(aTHX_ PL_no_modify);
d2111 1
a2111 1
    rxtainted = ((rx->extflags & RXf_TAINTED) ||
d2129 1
a2129 1
    if (!rx->prelen && PL_curpm) {
d2133 2
a2134 2
    r_flags = (rx->nparens || SvTEMP(TARG) || PL_sawampersand
	    || (rx->extflags & (RXf_EVAL_SEEN|RXf_PMf_KEEPCOPY)) )
d2140 1
a2140 1
    if (rx->extflags & RXf_USE_INTUIT) {
d2147 1
a2147 1
/*	if ( (rx->extflags & RXf_CHECK_ALL)
d2149 3
a2151 3
	     && !(rx->extflags & RXf_KEEPCOPY)
	     && ((rx->extflags & RXf_NOSCAN)
		 || !((rx->extflags & RXf_INTUIT_TAIL)
d2159 2
a2160 1

d2189 2
a2190 2
	&& (I32)clen <= rx->minlenret && (once || !(r_flags & REXEC_COPY_STR))
	&& !(rx->extflags & RXf_LOOKBEHIND_SEEN)
d2192 1
a2192 2
	if (!CALLREGEXEC(rx, s, strend, orig, 0, TARG, NULL,
			 r_flags | REXEC_CHECKED))
d2215 2
a2216 2
	    m = orig + rx->offs[0].start;
	    d = orig + rx->offs[0].end;
d2234 1
a2235 3
		s += i;
		while (i--)
		    *--d = *--s;
d2256 1
a2256 1
		m = rx->offs[0].start + orig;
d2266 1
a2266 1
		s = rx->offs[0].end + orig;
d2278 1
a2278 1
	    PUSHs(sv_2mortal(newSViv((I32)iters)));
d2294 1
a2294 2
    if (CALLREGEXEC(rx, s, strend, orig, 0, TARG, NULL,
		    r_flags | REXEC_CHECKED))
d2305 1
a2305 1
	dstr = newSVpvn(m, s-m);
a2306 2
	if (DO_UTF8(TARG))
	    SvUTF8_on(dstr);
d2319 1
a2319 1
	    if (RX_MATCH_COPIED(rx) && rx->subbeg != orig) {
d2322 1
a2322 1
		orig = rx->subbeg;
d2326 1
a2326 1
	    m = rx->offs[0].start + orig;
d2331 1
a2331 1
	    s = rx->offs[0].end + orig;
d2364 1
a2364 1
	PUSHs(sv_2mortal(newSViv((I32)iters)));
d2430 1
a2430 1
	    DEFSV = src;
d2517 1
a2517 1
    if (cx->blk_sub.lval & OPpENTERSUB_INARGS) {
d2544 1
a2544 1
    else if (cx->blk_sub.lval) {     /* Leave it as it is if we can. */
d2675 3
a2677 1
	if (!(cv = GvCVu((GV*)sv))) {
d2723 1
a2723 1
	cv = (CV*)SvRV(sv);
d2732 1
a2732 1
	cv = (CV*)sv;
d2777 8
a2784 1
	 cv = GvCV(PL_DBsub);
d2811 1
a2811 1
	    AV* const av = (AV*)PAD_SVl(0);
d2820 1
a2820 1
	    GvAV(PL_defgv) = (AV*)SvREFCNT_inc_simple(av);
d2851 1
a2851 1
	if (CvDEPTH(cv) == 100 && ckWARN(WARN_RECURSION)
d2906 2
d2924 1
a2924 1
    AV* const av = (AV*)POPs;
d2981 2
d2986 2
a2987 8
	    Perl_croak(aTHX_ PL_no_modify);
	if (SvTYPE(sv) < SVt_RV)
	    sv_upgrade(sv, SVt_RV);
	else if (SvTYPE(sv) >= SVt_PV) {
	    SvPV_free(sv);
            SvLEN_set(sv, 0);
	    SvCUR_set(sv, 0);
	}
d2993 1
a2993 1
	    SvRV_set(sv, (SV*)newAV());
d2996 1
a2996 1
	    SvRV_set(sv, (SV*)newHV());
d3045 2
d3052 1
a3052 1
	ob = (SV*)SvRV(sv);
d3068 1
a3068 1
	    !(ob=(SV*)GvIO(iogv)))
d3092 1
a3092 1
	*(PL_stack_base + TOPMARK + 1) = sv_2mortal(newRV((SV*)iogv));
d3097 3
a3099 1
		 || (SvTYPE(ob) == SVt_PVGV && (ob = (SV*)GvIO((GV*)ob))
d3117 1
a3117 1
	    gv = (GV*)HeVAL(he);
d3121 1
a3121 1
		return (SV*)GvCV(gv);
d3125 1
a3125 1
    gv = gv_fetchmethod(stash ? stash : (HV*)packsv, name);
d3200 1
a3200 1
    return isGV(gv) ? (SV*)GvCV(gv) : (SV*)gv;
@


1.11
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
a37 4
#ifdef USE_5005THREADS
static void unset_cvowner(pTHX_ void *cvarg);
#endif /* USE_5005THREADS */

d40 1
d42 8
a49 1
    XPUSHs(cSVOP_sv);
d55 1
d65 1
d77 1
d83 1
d90 1
d97 1
a97 1
    dSP; dTARGET;
d105 1
a105 1
    dSP;
d112 1
a112 1
    dSP;
d116 2
a117 1
	--SP;
d124 1
a124 1
    dSP; dPOPTOPssrl;
d127 2
a128 2
	SV *temp;
	temp = left; left = right; right = temp;
d132 78
d217 1
a217 1
    dSP;
d226 1
d238 1
a238 1
  dSP; dATARGET; tryAMAGICbin(concat,opASSIGN);
d243 2
a244 2
    const char *rpv = SvPV_const(right, rlen);	/* mg_get(right) happens here */
    const bool rbyte = !DO_UTF8(right);
d248 3
d268 4
a271 3
	if (SvGMAGICAL(left))
	    mg_get(left);		/* or mg_get(left) may happen here */
	if (!SvOK(TARG))
d273 1
d280 4
a283 8
#if defined(PERL_Y2KWARN)
    if ((SvIOK(right) || SvNOK(right)) && ckWARN(WARN_Y2K) && SvOK(TARG)) {
	if (llen >= 2 && lpv[llen - 2] == '1' && lpv[llen - 1] == '9'
	    && (llen == 2 || !isDIGIT(lpv[llen - 3])))
	{
	    Perl_warner(aTHX_ packWARN(WARN_Y2K), "Possible Y2K bug: %s",
			"about to append an integer to '19'");
	}
a284 2
#endif

d304 1
a304 1
    dSP; dTARGET;
d308 3
a310 2
	    SAVECLEARSV(PAD_SVl(PL_op->op_targ));
        else if (PL_op->op_private & OPpDEREF) {
d321 1
d340 1
a340 1
    dSP; tryAMAGICbinSET(eq,0);
d356 2
a357 2
	    bool auvok = SvUOK(TOPm1s);
	    bool buvok = SvUOK(TOPs);
d366 2
a367 2
		UV buv = SvUVX(POPs);
		UV auv = SvUVX(TOPs);
d386 1
a386 1
                if (iv < 0) {
d389 3
a391 4
                    RETURN;
                }
		/* we know iv is >= 0 */
		SETs(boolSV((UV)iv == SvUVX(uvp)));
d398 6
d406 1
d413 2
a414 2
    dSP;
    if (SvTYPE(TOPs) > SVt_PVLV)
d430 1
a430 1
    dSP;
d434 2
a435 1
	--SP;
d440 57
d499 5
a503 2
    dSP; dATARGET; bool useleft; tryAMAGICbin(add,opASSIGN);
    useleft = USE_LEFT(TOPm1s);
d551 2
a552 2
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
d568 4
a571 4
	    SvIV_please(TOPm1s);
	    if (SvIOK(TOPm1s)) {
		if ((auvok = SvUOK(TOPm1s)))
		    auv = SvUVX(TOPm1s);
d573 1
a573 1
		    register const IV aiv = SvIVX(TOPm1s);
d588 1
a588 1
	    bool buvok = SvUOK(TOPs);
d591 1
a591 1
		buv = SvUVX(TOPs);
d593 1
a593 1
		register const IV biv = SvIVX(TOPs);
d651 2
a652 1
	dPOPnv;
d658 1
a658 1
	SETn( value + TOPn );
d665 2
a666 2
    dSP;
    AV *av = PL_op->op_flags & OPf_SPECIAL ?
d669 1
a669 1
    SV** svp = av_fetch(av, PL_op->op_private, lval);
d680 1
a680 1
    dSP; dMARK; dTARGET;
d690 1
a690 1
    dSP;
d696 1
a696 1
    SV* sv = sv_newmortal();
d711 1
a711 2
    dSP; dMARK; dORIGMARK;
    GV *gv;
d715 1
a715 5

    if (PL_op->op_flags & OPf_STACKED)
	gv = (GV*)*++MARK;
    else
	gv = PL_defoutgv;
d786 5
a790 1
	    if (PL_ors_sv && SvOK(PL_ors_sv))
d811 8
a818 2
    dSP; dTOPss;
    AV *av;
d822 1
a822 1
	tryAMAGICunDEREF(to_av);
d824 3
a826 3
	av = (AV*)SvRV(sv);
	if (SvTYPE(av) != SVt_PVAV)
	    DIE(aTHX_ "Not an ARRAY reference");
d828 1
a828 1
	    SETs((SV*)av);
d832 4
a835 3
	    if (GIMME == G_SCALAR)
		Perl_croak(aTHX_ "Can't return array to lvalue scalar context");
	    SETs((SV*)av);
d843 1
a843 2
	if (SvTYPE(sv) == SVt_PVAV) {
	    av = (AV*)sv;
d845 1
a845 1
		SETs((SV*)av);
d849 5
a853 4
		if (GIMME == G_SCALAR)
		    Perl_croak(aTHX_ "Can't return array to lvalue"
			       " scalar context");
		SETs((SV*)av);
a860 3
		char *sym;
		STRLEN len;

d866 4
a869 29
		if (!SvOK(sv)) {
		    if (PL_op->op_flags & OPf_REF ||
		      PL_op->op_private & HINT_STRICT_REFS)
			DIE(aTHX_ PL_no_usym, "an ARRAY");
		    if (ckWARN(WARN_UNINITIALIZED))
			report_uninit();
		    if (GIMME == G_ARRAY) {
			(void)POPs;
			RETURN;
		    }
		    RETSETUNDEF;
		}
		sym = SvPV(sv,len);
		if ((PL_op->op_flags & OPf_SPECIAL) &&
		    !(PL_op->op_flags & OPf_MOD))
		{
		    gv = (GV*)gv_fetchpv(sym, FALSE, SVt_PVAV);
		    if (!gv
			&& (!is_gv_magical(sym,len,0)
			    || !(gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PVAV))))
		    {
			RETSETUNDEF;
		    }
		}
		else {
		    if (PL_op->op_private & HINT_STRICT_REFS)
			DIE(aTHX_ PL_no_symref, sym, "an ARRAY");
		    gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PVAV);
		}
d874 1
a874 1
	    av = GvAVn(gv);
d876 1
a876 1
		av = save_ary(gv);
d878 1
a878 1
		SETs((SV*)av);
d882 5
a886 4
		if (GIMME == G_SCALAR)
		    Perl_croak(aTHX_ "Can't return array to lvalue"
			       " scalar context");
		SETs((SV*)av);
d892 6
a897 1
    if (GIMME == G_ARRAY) {
d904 1
a904 1
		SV **svp = av_fetch(av, i, FALSE);
d916 1
a916 1
    else if (GIMME_V == G_SCALAR) {
d921 2
a922 106
    RETURN;
}

PP(pp_rv2hv)
{
    dSP; dTOPss;
    HV *hv;
    const I32 gimme = GIMME_V;
    static const char return_hash_to_lvalue_scalar[] = "Can't return hash to lvalue scalar context";

    if (SvROK(sv)) {
      wasref:
	tryAMAGICunDEREF(to_hv);

	hv = (HV*)SvRV(sv);
	if (SvTYPE(hv) != SVt_PVHV && SvTYPE(hv) != SVt_PVAV)
	    DIE(aTHX_ "Not a HASH reference");
	if (PL_op->op_flags & OPf_REF) {
	    SETs((SV*)hv);
	    RETURN;
	}
	else if (LVRET) {
	    if (gimme != G_ARRAY)
		Perl_croak(aTHX_ return_hash_to_lvalue_scalar );
	    SETs((SV*)hv);
	    RETURN;
	}
	else if (PL_op->op_flags & OPf_MOD
		&& PL_op->op_private & OPpLVAL_INTRO)
	    Perl_croak(aTHX_ PL_no_localize_ref);
    }
    else {
	if (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV) {
	    hv = (HV*)sv;
	    if (PL_op->op_flags & OPf_REF) {
		SETs((SV*)hv);
		RETURN;
	    }
	    else if (LVRET) {
		if (gimme != G_ARRAY)
		    Perl_croak(aTHX_ return_hash_to_lvalue_scalar );
		SETs((SV*)hv);
		RETURN;
	    }
	}
	else {
	    GV *gv;
	
	    if (SvTYPE(sv) != SVt_PVGV) {
		char *sym;
		STRLEN len;

		if (SvGMAGICAL(sv)) {
		    mg_get(sv);
		    if (SvROK(sv))
			goto wasref;
		}
		if (!SvOK(sv)) {
		    if (PL_op->op_flags & OPf_REF ||
		      PL_op->op_private & HINT_STRICT_REFS)
			DIE(aTHX_ PL_no_usym, "a HASH");
		    if (ckWARN(WARN_UNINITIALIZED))
			report_uninit();
		    if (gimme == G_ARRAY) {
			SP--;
			RETURN;
		    }
		    RETSETUNDEF;
		}
		sym = SvPV(sv,len);
		if ((PL_op->op_flags & OPf_SPECIAL) &&
		    !(PL_op->op_flags & OPf_MOD))
		{
		    gv = (GV*)gv_fetchpv(sym, FALSE, SVt_PVHV);
		    if (!gv
			&& (!is_gv_magical(sym,len,0)
			    || !(gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PVHV))))
		    {
			RETSETUNDEF;
		    }
		}
		else {
		    if (PL_op->op_private & HINT_STRICT_REFS)
			DIE(aTHX_ PL_no_symref, sym, "a HASH");
		    gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PVHV);
		}
	    }
	    else {
		gv = (GV*)sv;
	    }
	    hv = GvHVn(gv);
	    if (PL_op->op_private & OPpLVAL_INTRO)
		hv = save_hash(gv);
	    if (PL_op->op_flags & OPf_REF) {
		SETs((SV*)hv);
		RETURN;
	    }
	    else if (LVRET) {
		if (gimme != G_ARRAY)
		    Perl_croak(aTHX_ return_hash_to_lvalue_scalar );
		SETs((SV*)hv);
		RETURN;
	    }
	}
    }

d924 1
a924 1
	*PL_stack_sp = (SV*)hv;
d929 2
a930 5

	if (SvTYPE(hv) == SVt_PVAV)
	    hv = avhv_keys((AV*)hv);

	TARG = Perl_hv_scalar(aTHX_ hv);
d933 1
a936 45
STATIC int
S_do_maybe_phash(pTHX_ AV *ary, SV **lelem, SV **firstlelem, SV **relem,
		 SV **lastrelem)
{
    OP *leftop;
    I32 i;

    leftop = ((BINOP*)PL_op)->op_last;
    assert(leftop);
    assert(leftop->op_type == OP_NULL && leftop->op_targ == OP_LIST);
    leftop = ((LISTOP*)leftop)->op_first;
    assert(leftop);
    /* Skip PUSHMARK and each element already assigned to. */
    for (i = lelem - firstlelem; i > 0; i--) {
	leftop = leftop->op_sibling;
	assert(leftop);
    }
    if (leftop->op_type != OP_RV2HV)
	return 0;

    /* pseudohash */
    if (av_len(ary) > 0)
	av_fill(ary, 0);		/* clear all but the fields hash */
    if (lastrelem >= relem) {
	while (relem < lastrelem) {	/* gobble up all the rest */
	    SV *tmpstr;
	    assert(relem[0]);
	    assert(relem[1]);
	    /* Avoid a memory leak when avhv_store_ent dies. */
	    tmpstr = sv_newmortal();
	    sv_setsv(tmpstr,relem[1]);	/* value */
	    relem[1] = tmpstr;
	    if (avhv_store_ent(ary,relem[0],tmpstr,0))
		(void)SvREFCNT_inc(tmpstr);
	    if (SvMAGICAL(ary) != 0 && SvSMAGICAL(tmpstr))
		mg_set(tmpstr);
	    relem += 2;
	    TAINT_NOT;
	}
    }
    if (relem == lastrelem)
	return 1;
    return 2;
}

d940 1
d943 3
a945 1
	if (ckWARN(WARN_MISC)) {
d958 10
a967 20
	if (SvTYPE(hash) == SVt_PVAV) {
	    /* pseudohash */
	    tmpstr = sv_newmortal();
	    if (avhv_store_ent((AV*)hash,*relem,tmpstr,0))
		(void)SvREFCNT_inc(tmpstr);
	    if (SvMAGICAL(hash) && SvSMAGICAL(tmpstr))
		mg_set(tmpstr);
	}
	else {
	    HE *didstore;
	    tmpstr = NEWSV(29,0);
	    didstore = hv_store_ent(hash,*relem,tmpstr,0);
	    if (SvMAGICAL(hash)) {
		if (SvSMAGICAL(tmpstr))
		    mg_set(tmpstr);
		if (!didstore)
		    sv_2mortal(tmpstr);
	    }
	}
	TAINT_NOT;
d973 1
a973 1
    dSP;
d990 1
a990 2
    SV **firsthashrelem = 0;	/* "= 0" keeps gcc 2.95 quiet  */

d1011 2
a1012 2
    ary = Null(AV*);
    hash = Null(HV*);
a1020 13
	    if (PL_op->op_private & OPpASSIGN_HASH) {
		switch (do_maybe_phash(ary, lelem, firstlelem, relem,
				       lastrelem))
		{
		case 0:
		    goto normal_array;
		case 1:
		    do_oddball((HV*)ary, relem, firstrelem);
		}
		relem = lastrelem + 1;
		break;
	    }
	normal_array:
d1038 2
d1051 3
a1053 5
		    if (*relem)
			sv = *(relem++);
		    else
			sv = &PL_sv_no, relem++;
		    tmpstr = NEWSV(29,0);
d1186 1
d1192 7
a1198 5
    dSP;
    register PMOP *pm = cPMOP;
    SV *rv = sv_newmortal();
    SV *sv = newSVrv(rv, "Regexp");
    if (pm->op_pmdynflags & PMdf_TAINTED)
d1200 3
a1202 2
    sv_magic(sv,(SV*)ReREFCNT_inc(PM_GETRE(pm)), PERL_MAGIC_qr,0,0);
    RETURNX(PUSHs(rv));
d1207 1
a1207 1
    dSP; dTARG;
d1224 1
d1228 2
d1240 1
a1240 1
    rxtainted = ((pm->op_pmdynflags & PMdf_TAINTED) ||
d1247 7
a1253 1
    if (pm->op_pmdynflags & PMdf_USED) {
d1260 2
d1275 1
a1275 1
	rx->startp[0] = -1;
d1277 1
a1277 1
	    MAGIC* mg = mg_find(TARG, PERL_MAGIC_regex_global);
d1279 3
a1281 3
		if (!(rx->reganch & ROPT_GPOS_SEEN))
		    rx->endp[0] = rx->startp[0] = mg->mg_len;
		else if (rx->reganch & ROPT_ANCH_GPOS) {
d1283 6
a1288 3
		    rx->endp[0] = rx->startp[0] = mg->mg_len;
		}
		minmatch = (mg->mg_flags & MGf_MINMATCH);
d1293 8
a1300 2
    if ((!global && rx->nparens)
	    || SvTEMP(TARG) || PL_sawampersand)
a1304 5
    if (pm->op_pmflags & (PMf_MULTILINE|PMf_SINGLELINE)) {
	SAVEINT(PL_multiline);
	PL_multiline = pm->op_pmflags & PMf_MULTILINE;
    }

d1306 3
a1308 3
    if (global && rx->startp[0] != -1) {
	t = s = rx->endp[0] + truebase;
	if ((s + rx->minlen) > strend)
d1313 2
a1314 2
    if (rx->reganch & RE_USE_INTUIT &&
	DO_UTF8(TARG) == ((rx->reganch & ROPT_UTF8) != 0)) {
d1317 1
a1317 1
	s = CALLREG_INTUIT_START(aTHX_ rx, TARG, (char *)s, (char *)strend, r_flags, NULL);
d1321 1
a1321 1
	if ( (rx->reganch & ROPT_CHECK_ALL)
d1323 3
a1325 2
	     && ((rx->reganch & ROPT_NOSCAN)
		 || !((rx->reganch & RE_INTUIT_TAIL)
d1330 1
a1330 1
    if (CALLREGEXEC(aTHX_ rx, (char*)s, (char *)strend, (char*)truebase, minmatch, TARG, NULL, r_flags))
d1333 7
a1339 2
	if (dynpm->op_pmflags & PMf_ONCE)
	    dynpm->op_pmdynflags |= PMdf_USED;
d1359 4
a1362 4
	    if ((rx->startp[i] != -1) && rx->endp[i] != -1 ) {
		const I32 len = rx->endp[i] - rx->startp[i];
		s = rx->startp[i] + truebase;
	        if (rx->endp[i] < 0 || rx->startp[i] < 0 ||
d1372 1
a1372 1
		MAGIC* mg = 0;
d1376 6
a1381 2
		    sv_magic(TARG, (SV*)0, PERL_MAGIC_regex_global, Nullch, 0);
		    mg = mg_find(TARG, PERL_MAGIC_regex_global);
d1383 3
a1385 3
		if (rx->startp[0] != -1) {
		    mg->mg_len = rx->endp[0];
		    if (rx->startp[0] == rx->endp[0])
d1391 3
a1393 2
	    had_zerolen = (rx->startp[0] != -1
			   && rx->startp[0] == rx->endp[0]);
d1405 1
a1405 1
	    MAGIC* mg = 0;
d1408 2
d1411 6
a1416 2
		sv_magic(TARG, (SV*)0, PERL_MAGIC_regex_global, Nullch, 0);
		mg = mg_find(TARG, PERL_MAGIC_regex_global);
d1418 3
a1420 3
	    if (rx->startp[0] != -1) {
		mg->mg_len = rx->endp[0];
		if (rx->startp[0] == rx->endp[0])
d1435 7
a1441 2
    if (dynpm->op_pmflags & PMf_ONCE)
	dynpm->op_pmdynflags |= PMdf_USED;
d1445 1
a1445 1
    rx->subbeg = Nullch;
d1449 1
a1449 1
	rx->startp[0] = s - truebase;
d1451 2
a1452 2
	    char *t = (char*)utf8_hop((U8*)s, rx->minlen);
	    rx->endp[0] = t - truebase;
d1455 1
a1455 1
	    rx->endp[0] = s - truebase + rx->minlen;
d1460 1
a1460 1
    if (PL_sawampersand) {
d1462 14
d1477 5
a1481 1
	rx->subbeg = savepvn(t, strend - t);
d1484 2
a1485 2
	off = rx->startp[0] = s - t;
	rx->endp[0] = off + rx->minlen;
d1488 2
a1489 2
	rx->startp[0] = s - truebase;
	rx->endp[0] = s - truebase + rx->minlen;
d1491 2
d1501 1
a1501 1
	    MAGIC* mg = mg_find(TARG, PERL_MAGIC_regex_global);
d1515 1
a1515 1
    dSP; dTARGETSTACKED;
a1522 1
    MAGIC *mg;
d1524 16
a1539 12
    if (io && (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar))) {
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)io, mg));
	PUTBACK;
	ENTER;
	call_method("READLINE", gimme);
	LEAVE;
	SPAGAIN;
	if (gimme == G_SCALAR) {
	    SV* result = POPs;
	    SvSetSV_nosteal(TARG, result);
	    PUSHTARG;
a1540 1
	RETURN;
d1542 1
a1542 1
    fp = Nullfp;
d1551 1
a1551 1
			do_open(PL_last_in_gv,"-",1,FALSE,O_RDONLY,0,Nullfp);
d1586 2
a1587 2
	        SV_CHECK_THINKFIRST(TARG);
	        SvOK_off(TARG);
d1596 12
a1607 3
	if (SvROK(sv))
	    sv_unref(sv);
	(void)SvUPGRADE(sv, SVt_PV);
d1620 1
a1620 1
	sv = sv_2mortal(NEWSV(57, 80));
d1660 1
a1660 1
		    SV_CHECK_THINKFIRST(TARG);
a1675 1
	    char *tmps;
d1679 1
a1679 1
		tmps = SvEND(sv) - 1;
d1694 11
a1704 10
	     const U8 *s = (const U8*)SvPVX_const(sv) + offset;
	     const STRLEN len = SvCUR(sv) - offset;
	     const U8 *f;
	     
	     if (ckWARN(WARN_UTF8) &&
		 !Perl_is_utf8_string_loc(aTHX_ (U8 *) s, len, (U8 **) &f))
		  /* Emulate :encoding(utf8) warning in the same case. */
		  Perl_warner(aTHX_ packWARN(WARN_UTF8),
			      "utf8 \"\\x%02X\" does not map to Unicode",
			      f < (U8*)SvEND(sv) ? *f : 0);
d1710 1
a1710 1
	    sv = sv_2mortal(NEWSV(58, 80));
d1725 1
a1725 1
    dSP;
d1746 1
a1746 1
    dSP;
d1749 2
a1750 2
    SV *keysv = POPs;
    HV *hv = (HV*)POPs;
d1757 11
a1767 10
    if (SvTYPE(hv) == SVt_PVHV) {
	if (PL_op->op_private & OPpLVAL_INTRO) {
	    MAGIC *mg;
	    HV *stash;
	    /* does the element we're localizing already exist? */
	    preeminent =  
		/* can we determine whether it exists? */
		(    !SvRMAGICAL(hv)
		  || mg_find((SV*)hv, PERL_MAGIC_env)
		  || (     (mg = mg_find((SV*)hv, PERL_MAGIC_tied))
d1769 7
a1775 19
			 * element by using EXISTS and DELETE if possible.
			 * Fallback to FETCH and STORE otherwise */
			&& (stash = SvSTASH(SvRV(SvTIED_obj((SV*)hv, mg))))
			&& gv_fetchmethod_autoload(stash, "EXISTS", TRUE)
			&& gv_fetchmethod_autoload(stash, "DELETE", TRUE)
		    )
		) ? hv_exists_ent(hv, keysv, 0) : 1;

	}
	he = hv_fetch_ent(hv, keysv, lval && !defer, hash);
	svp = he ? &HeVAL(he) : 0;
    }
    else if (SvTYPE(hv) == SVt_PVAV) {
	if (PL_op->op_private & OPpLVAL_INTRO)
	    DIE(aTHX_ "Can't localize pseudo-hash element");
	svp = avhv_fetch_ent((AV*)hv, keysv, lval && !defer, hash);
    }
    else {
	RETPUSHUNDEF;
d1777 2
d1784 1
a1784 1
		DIE(aTHX_ PL_no_helem_sv, keysv);
d1789 1
a1789 1
	    sv_magic(lv, key2 = newSVsv(keysv), PERL_MAGIC_defelem, Nullch, 0);
d1791 1
a1791 1
	    LvTARG(lv) = SvREFCNT_inc(hv);
d1803 2
a1804 1
		    SAVEDELETE(hv, savepvn(key,keylen), keylen);
d1827 1
a1827 1
    dSP;
d1884 1
a1884 1
    dSP;
d1903 3
a1905 1
	    const char *max = SvOK((SV*)av) ? SvPV_const((SV*)av, maxlen) : "";
a1906 1
#ifndef USE_5005THREADS			  /* don't risk potential race */
a1911 1
#endif
d1932 1
a1932 1
#ifndef USE_5005THREADS			  /* don't risk potential race */
a1937 1
#endif
d1956 2
a1957 2
	    SV ** const svp = av_fetch(av, --cx->blk_loop.iterix, FALSE);
	    sv = svp ? *svp : Nullsv;
d1969 2
a1970 5
	    SV **svp = av_fetch(av, ++cx->blk_loop.iterix, FALSE);
	    if (svp)
		sv = *svp;
	    else
		sv = Nullsv;
d1977 2
a1978 2
    if (sv && SvREFCNT(sv) == 0) {
	*itersvp = Nullsv;
d1990 1
a1990 1
	    lv = Nullsv;
d1995 1
a1995 2
	    lv = cx->blk_loop.iterlval = NEWSV(26, 0);
	    sv_upgrade(lv, SVt_PVLV);
d1997 1
a1997 1
	    sv_magic(lv, Nullsv, PERL_MAGIC_defelem, Nullch, 0);
d1999 1
a1999 1
	LvTARG(lv) = SvREFCNT_inc(av);
d2006 1
a2006 1
    *itersvp = SvREFCNT_inc(sv);
d2014 1
a2014 1
    dSP; dTARG;
a2016 1
    register SV *dstr;
d2033 1
a2033 1
    I32 oldsave = PL_savestack_ix;
d2036 4
a2039 1
    SV *nsv = Nullsv;
d2042 1
a2042 1
    dstr = (pm->op_pmflags & PMf_CONST) ? POPs : Nullsv;
d2045 2
d2052 16
a2067 5
    if (SvFAKE(TARG) && SvREADONLY(TARG))
	sv_force_normal(TARG);
    if (SvREADONLY(TARG)
	|| (SvTYPE(TARG) > SVt_PVLV
	    && !(SvTYPE(TARG) == SVt_PVGV && SvFAKE(TARG))))
d2074 1
a2074 1
    rxtainted = ((pm->op_pmdynflags & PMdf_TAINTED) ||
d2096 3
a2098 2
    r_flags = (rx->nparens || SvTEMP(TARG) || PL_sawampersand)
		? REXEC_COPY_STR : 0;
d2101 1
a2101 4
    if (pm->op_pmflags & (PMf_MULTILINE|PMf_SINGLELINE)) {
	SAVEINT(PL_multiline);
	PL_multiline = pm->op_pmflags & PMf_MULTILINE;
    }
d2103 1
a2103 1
    if (rx->reganch & RE_USE_INTUIT) {
d2105 1
a2105 1
	s = CALLREG_INTUIT_START(aTHX_ rx, TARG, s, strend, r_flags, NULL);
d2110 1
a2110 1
/*	if ( (rx->reganch & ROPT_CHECK_ALL)
d2112 3
a2114 2
	     && ((rx->reganch & ROPT_NOSCAN)
		 || !((rx->reganch & RE_INTUIT_TAIL)
d2142 1
a2142 1
        c = Nullch;
d2147 6
a2152 2
    if (c && (I32)clen <= rx->minlen && (once || !(r_flags & REXEC_COPY_STR))
	&& !(rx->reganch & ROPT_LOOKBEHIND_SEEN)
d2154 1
a2154 1
	if (!CALLREGEXEC(aTHX_ rx, s, strend, orig, 0, TARG, NULL,
d2162 6
d2178 2
a2179 2
	    m = orig + rx->startp[0];
	    d = orig + rx->endp[0];
d2221 1
a2221 1
		m = rx->startp[0] + orig;
d2231 2
a2232 2
		s = rx->endp[0] + orig;
	    } while (CALLREGEXEC(aTHX_ rx, s, strend, orig, s == m,
d2259 1
a2259 1
    if (CALLREGEXEC(aTHX_ rx, s, strend, orig, 0, TARG, NULL,
d2267 3
d2272 1
a2278 1
	    (void)ReREFCNT_inc(rx);
d2280 1
a2280 1
	    RETURNOP(cPMOP->op_pmreplroot);
d2294 1
a2294 1
	    m = rx->startp[0] + orig;
d2299 1
a2299 1
	    s = rx->endp[0] + orig;
d2304 1
a2304 1
	} while (CALLREGEXEC(aTHX_ rx, s, strend, orig, s == m,
d2311 13
a2323 1
	SvPV_free(TARG);
d2328 1
a2328 2
	SvPV_set(dstr, (char*)0);
	sv_free(dstr);
d2355 1
a2355 1
    dSP;
d2365 1
a2365 1
	I32 gimme = GIMME_V;
d2373 9
a2381 2
	    dTARGET;
	    XPUSHi(items);
d2395 4
a2398 1
	DEFSV = src;
d2406 1
a2406 1
    dSP;
d2414 3
d2462 1
a2462 1
    return pop_return();
d2469 1
a2469 1
    dSP;
d2477 3
d2501 1
a2501 1
		    /* empty */ ;
d2507 1
a2507 1
		    (void)SvREFCNT_inc(*mark);
d2544 1
a2544 1
		    (void)SvREFCNT_inc(*mark);
d2576 1
a2576 1
		    (void)SvREFCNT_inc(*mark);
d2626 1
a2626 40
    return pop_return();
}


STATIC CV *
S_get_db_sub(pTHX_ SV **svp, CV *cv)
{
    SV *dbsv = GvSVn(PL_DBsub);

    save_item(dbsv);
    if (!PERLDB_SUB_NN) {
	GV *gv = CvGV(cv);

	if ( (CvFLAGS(cv) & (CVf_ANON | CVf_CLONED))
	     || strEQ(GvNAME(gv), "END")
	     || ((GvCV(gv) != cv) && /* Could be imported, and old sub redefined. */
		 !( (SvTYPE(*svp) == SVt_PVGV) && (GvCV((GV*)*svp) == cv)
		    && (gv = (GV*)*svp) ))) {
	    /* Use GV from the stack as a fallback. */
	    /* GV is potentially non-unique, or contain different CV. */
	    SV * const tmp = newRV((SV*)cv);
	    sv_setsv(dbsv, tmp);
	    SvREFCNT_dec(tmp);
	}
	else {
	    gv_efullname3(dbsv, gv, Nullch);
	}
    }
    else {
	const int type = SvTYPE(dbsv);
	if (type < SVt_PVIV && type != SVt_IV)
	    sv_upgrade(dbsv, SVt_PVIV);
	(void)SvIOK_on(dbsv);
	SvIV_set(dbsv, PTR2IV(cv));	/* Do it the quickest way  */
    }

    if (CvXSUB(cv))
	PL_curcopdb = PL_curcop;
    cv = GvCV(PL_DBsub);
    return cv;
d2631 1
a2631 1
    dSP; dPOPss;
a2632 1
    HV *stash;
d2641 12
d2656 1
d2666 7
a2672 1
		sym = SvPOKp(sv) ? SvPVX_const(sv) : Nullch;
d2675 1
a2675 1
		sym = SvPV_nolen_const(sv);
d2681 1
a2681 1
	    cv = get_cv(sym, TRUE);
d2696 1
a2699 9
    case SVt_PVGV:
	if (!(cv = GvCVu((GV*)sv)))
	    cv = sv_2cv(sv, &stash, &gv, FALSE);
	if (!cv) {
	    ENTER;
	    SAVETMPS;
	    goto try_autoload;
	}
	break;
d2729 2
a2730 2
		gv_efullname3(sub_name, gv, Nullch);
		DIE(aTHX_ "Undefined subroutine &%"SVf" called", sub_name);
d2740 5
a2744 1
	cv = get_db_sub(&sv, cv);
d2749 2
a2750 201
#ifdef USE_5005THREADS
    /*
     * First we need to check if the sub or method requires locking.
     * If so, we gain a lock on the CV, the first argument or the
     * stash (for static methods), as appropriate. This has to be
     * inline because for FAKE_THREADS, COND_WAIT inlines code to
     * reschedule by returning a new op.
     */
    MUTEX_LOCK(CvMUTEXP(cv));
    if (CvFLAGS(cv) & CVf_LOCKED) {
	MAGIC *mg;	
	if (CvFLAGS(cv) & CVf_METHOD) {
	    if (SP > PL_stack_base + TOPMARK)
		sv = *(PL_stack_base + TOPMARK + 1);
	    else {
		AV *av = (AV*)PAD_SVl(0);
		if (hasargs || !av || AvFILLp(av) < 0
		    || !(sv = AvARRAY(av)[0]))
		{
		    MUTEX_UNLOCK(CvMUTEXP(cv));
		    DIE(aTHX_ "no argument for locked method call");
		}
	    }
	    if (SvROK(sv))
		sv = SvRV(sv);
	    else {		
		STRLEN len;
		char *stashname = SvPV(sv, len);
		sv = (SV*)gv_stashpvn(stashname, len, TRUE);
	    }
	}
	else {
	    sv = (SV*)cv;
	}
	MUTEX_UNLOCK(CvMUTEXP(cv));
	mg = condpair_magic(sv);
	MUTEX_LOCK(MgMUTEXP(mg));
	if (MgOWNER(mg) == thr)
	    MUTEX_UNLOCK(MgMUTEXP(mg));
	else {
	    while (MgOWNER(mg))
		COND_WAIT(MgOWNERCONDP(mg), MgMUTEXP(mg));
	    MgOWNER(mg) = thr;
	    DEBUG_S(PerlIO_printf(Perl_debug_log, "%p: pp_entersub lock %p\n",
				  thr, sv));
	    MUTEX_UNLOCK(MgMUTEXP(mg));
	    SAVEDESTRUCTOR_X(Perl_unlock_condpair, sv);
	}
	MUTEX_LOCK(CvMUTEXP(cv));
    }
    /*
     * Now we have permission to enter the sub, we must distinguish
     * four cases. (0) It's an XSUB (in which case we don't care
     * about ownership); (1) it's ours already (and we're recursing);
     * (2) it's free (but we may already be using a cached clone);
     * (3) another thread owns it. Case (1) is easy: we just use it.
     * Case (2) means we look for a clone--if we have one, use it
     * otherwise grab ownership of cv. Case (3) means we look for a
     * clone (for non-XSUBs) and have to create one if we don't
     * already have one.
     * Why look for a clone in case (2) when we could just grab
     * ownership of cv straight away? Well, we could be recursing,
     * i.e. we originally tried to enter cv while another thread
     * owned it (hence we used a clone) but it has been freed up
     * and we're now recursing into it. It may or may not be "better"
     * to use the clone but at least CvDEPTH can be trusted.
     */
    if (CvOWNER(cv) == thr || CvXSUB(cv))
	MUTEX_UNLOCK(CvMUTEXP(cv));
    else {
	/* Case (2) or (3) */
	SV **svp;
	
	/*
	 * XXX Might it be better to release CvMUTEXP(cv) while we
     	 * do the hv_fetch? We might find someone has pinched it
     	 * when we look again, in which case we would be in case
     	 * (3) instead of (2) so we'd have to clone. Would the fact
     	 * that we released the mutex more quickly make up for this?
     	 */
	if ((svp = hv_fetch(thr->cvcache, (char *)cv, sizeof(cv), FALSE)))
	{
	    /* We already have a clone to use */
	    MUTEX_UNLOCK(CvMUTEXP(cv));
	    cv = *(CV**)svp;
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
				  "entersub: %p already has clone %p:%s\n",
				  thr, cv, SvPEEK((SV*)cv)));
	    CvOWNER(cv) = thr;
	    SvREFCNT_inc(cv);
	    if (CvDEPTH(cv) == 0)
		SAVEDESTRUCTOR_X(unset_cvowner, (void*) cv);
	}
	else {
	    /* (2) => grab ownership of cv. (3) => make clone */
	    if (!CvOWNER(cv)) {
		CvOWNER(cv) = thr;
		SvREFCNT_inc(cv);
		MUTEX_UNLOCK(CvMUTEXP(cv));
		DEBUG_S(PerlIO_printf(Perl_debug_log,
			    "entersub: %p grabbing %p:%s in stash %s\n",
			    thr, cv, SvPEEK((SV*)cv), CvSTASH(cv) ?
	    			HvNAME(CvSTASH(cv)) : "(none)"));
	    }
	    else {
		/* Make a new clone. */
		CV *clonecv;
		SvREFCNT_inc(cv); /* don't let it vanish from under us */
		MUTEX_UNLOCK(CvMUTEXP(cv));
		DEBUG_S((PerlIO_printf(Perl_debug_log,
				       "entersub: %p cloning %p:%s\n",
				       thr, cv, SvPEEK((SV*)cv))));
		/*
	    	 * We're creating a new clone so there's no race
		 * between the original MUTEX_UNLOCK and the
		 * SvREFCNT_inc since no one will be trying to undef
		 * it out from underneath us. At least, I don't think
		 * there's a race...
		 */
	     	clonecv = cv_clone(cv);
    		SvREFCNT_dec(cv); /* finished with this */
		hv_store(thr->cvcache, (char*)cv, sizeof(cv), (SV*)clonecv,0);
		CvOWNER(clonecv) = thr;
		cv = clonecv;
		SvREFCNT_inc(cv);
	    }
	    DEBUG_S(if (CvDEPTH(cv) != 0)
			PerlIO_printf(Perl_debug_log, "depth %ld != 0\n",
                                     CvDEPTH(cv)));
	    SAVEDESTRUCTOR_X(unset_cvowner, (void*) cv);
	}
    }
#endif /* USE_5005THREADS */

    if (CvXSUB(cv)) {
#ifdef PERL_XSUB_OLDSTYLE
	if (CvOLDSTYLE(cv)) {
	    I32 (*fp3)(int,int,int);
	    dMARK;
	    register I32 items = SP - MARK;
					/* We dont worry to copy from @@_. */
	    while (SP > mark) {
		SP[1] = SP[0];
		SP--;
	    }
	    PL_stack_sp = mark + 1;
	    fp3 = (I32(*)(int,int,int))CvXSUB(cv);
	    items = (*fp3)(CvXSUBANY(cv).any_i32,
			   MARK - PL_stack_base + 1,
			   items);
	    PL_stack_sp = PL_stack_base + items;
	}
	else
#endif /* PERL_XSUB_OLDSTYLE */
	{
	    I32 markix = TOPMARK;

	    PUTBACK;

	    if (!hasargs) {
		/* Need to copy @@_ to stack. Alternative may be to
		 * switch stack to @@_, and copy return values
		 * back. This would allow popping @@_ in XSUB, e.g.. XXXX */
#ifdef USE_5005THREADS
		AV * const av = (AV*)PAD_SVl(0);
#else
		AV * const av = GvAV(PL_defgv);
#endif /* USE_5005THREADS */		
		const I32 items = AvFILLp(av) + 1;   /* @@_ is not tieable */


		if (items) {
		    /* Mark is at the end of the stack. */
		    EXTEND(SP, items);
		    Copy(AvARRAY(av), SP + 1, items, SV*);
		    SP += items;
		    PUTBACK ;		
		}
	    }
	    /* We assume first XSUB in &DB::sub is the called one. */
	    if (PL_curcopdb) {
		SAVEVPTR(PL_curcop);
		PL_curcop = PL_curcopdb;
		PL_curcopdb = NULL;
	    }
	    /* Do we need to open block here? XXXX */
	    (void)(*CvXSUB(cv))(aTHX_ cv);

	    /* Enforce some sanity in scalar context. */
	    if (gimme == G_SCALAR && ++markix != PL_stack_sp - PL_stack_base ) {
		if (markix > PL_stack_sp - PL_stack_base)
		    *(PL_stack_base + markix) = &PL_sv_undef;
		else
		    *(PL_stack_base + markix) = *PL_stack_sp;
		PL_stack_sp = PL_stack_base + markix;
	    }
	}
	LEAVE;
	return NORMAL;
    }
    else {
d2753 1
a2753 2
	AV* padlist = CvPADLIST(cv);
	push_return(PL_op->op_next);
d2756 1
d2765 1
a2765 1
	    pad_push(padlist, CvDEPTH(cv), 1);
a2766 15
#ifdef USE_5005THREADS
	if (!hasargs) {
	    AV* av = (AV*)PAD_SVl(0);

    /*NOTREACHED*/
	    items = AvFILLp(av) + 1;
	    if (items) {
		/* Mark is at the end of the stack. */
		EXTEND(SP, items);
		Copy(AvARRAY(av), SP + 1, items, SV*);
		SP += items;
		PUTBACK ;		
	    }
	}
#endif /* USE_5005THREADS */		
d2769 2
a2770 12
#ifndef USE_5005THREADS
	if (hasargs)
#endif /* USE_5005THREADS */
	{
	    AV* av;
	    SV** ary;

#if 0
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
	    			  "%p entersub preparing @@_\n", thr));
#endif
	    av = (AV*)PAD_SVl(0);
a2777 1
#ifndef USE_5005THREADS
d2779 1
a2779 2
	    GvAV(PL_defgv) = (AV*)SvREFCNT_inc(av);
#endif /* USE_5005THREADS */
d2785 1
a2785 1
		ary = AvALLOC(av);
d2788 1
a2788 1
		    SvPVX(av) = (char*)ary;
d2794 1
a2794 1
		    SvPVX(av) = (char*)ary;
d2815 1
a2815 1
			      "%p entersub returning %p\n", thr, CvSTART(cv)));
d2819 41
d2869 1
a2869 1
	gv_efullname3(tmpstr, CvGV(cv), Nullch);
d2871 1
a2871 1
		tmpstr);
d2877 1
a2877 1
    dSP;
d2881 1
a2881 1
    AV* av = (AV*)POPs;
d2887 3
a2889 1
	Perl_warner(aTHX_ packWARN(WARN_MISC), "Use of reference \"%"SVf"\" as array index", elemsv);
d2891 1
a2891 1
	elem -= PL_curcop->cop_arybase;
d2916 2
a2917 2
	    sv_magic(lv, Nullsv, PERL_MAGIC_defelem, Nullch, 0);
	    LvTARG(lv) = SvREFCNT_inc(av);
d2938 1
a2938 2
    if (SvGMAGICAL(sv))
	mg_get(sv);
d2951 1
a2951 1
	    SvRV_set(sv, NEWSV(355,0));
d2967 1
a2967 1
    dSP;
d2978 1
a2978 1
    SETs(method_common(sv, Null(U32*)));
d2984 1
a2984 1
    dSP;
d2995 1
d3000 2
a3001 2
    const char* packname = Nullch;
    SV *packsv = Nullsv;
d3009 1
a3009 2
    if (SvGMAGICAL(sv))
	mg_get(sv);
d3026 1
a3026 1
	    !(iogv = gv_fetchpv(packname, FALSE, SVt_PVIO)) ||
d3041 1
a3041 1
	    stash = gv_stashpvn(packname, packlen, FALSE);
d3045 2
a3046 2
	        SV* ref = newSViv(PTR2IV(stash));
	        hv_store(PL_stashcache, packname, packlen, ref, 0);
d3060 1
d3076 2
a3077 1
		(!GvCVGEN(gv) || GvCVGEN(gv) == PL_sub_generation))
d3093 1
a3093 1
	const char* sep = Nullch;
d3103 26
a3128 4
	    /* the method name is unqualified or starts with SUPER:: */ 
	    packname = sep ? CopSTASHPV(PL_curcop) :
		stash ? HvNAME_get(stash) : packname;
	    if (!packname)
d3131 3
a3133 1
	    else
d3135 2
d3145 1
a3145 1
	if (gv_stashpvn(packname, packlen, FALSE)) {
a3158 19

#ifdef USE_5005THREADS
static void
unset_cvowner(pTHX_ void *cvarg)
{
    register CV* cv = (CV *) cvarg;

    DEBUG_S((PerlIO_printf(Perl_debug_log, "%p unsetting CvOWNER of %p:%s\n",
			   thr, cv, SvPEEK((SV*)cv))));
    MUTEX_LOCK(CvMUTEXP(cv));
    DEBUG_S(if (CvDEPTH(cv) != 0)
		PerlIO_printf(Perl_debug_log, "depth %ld != 0\n",
                             CvDEPTH(cv)));
    assert(thr == CvOWNER(cv));
    CvOWNER(cv) = 0;
    MUTEX_UNLOCK(CvMUTEXP(cv));
    SvREFCNT_dec(cv);
}
#endif /* USE_5005THREADS */
@


1.10
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d65 1
a65 1
	PUSHs(GvSV(cGVOP_gv));
a151 2
    STRLEN llen;
    char* lpv;
d154 3
a156 2
    char* rpv = SvPV(right, rlen);	/* mg_get(right) happens here */
    bool rbyte = !DO_UTF8(right), rcopied = FALSE;
d160 1
a160 1
	rpv = SvPV(right, rlen);	/* no point setting UTF-8 here */
d165 2
a166 1
	lpv = SvPV(left, llen);		/* mg_get(left) may happen here */
d175 1
d179 2
a180 2
	    sv_setpv(left, "");
	lpv = SvPV_nomg(left, llen);
d204 1
a204 1
	    rpv = SvPV(right, rlen);
d323 1
a323 1
	++SvIVX(TOPs);
d416 1
a416 1
		    register IV aiv = SvIVX(TOPm1s);
d436 1
a436 1
		register IV biv = SvIVX(TOPs);
d510 1
a510 1
    U32 lval = PL_op->op_flags & OPf_MOD;
d643 1
a643 1
    PUSHs(&PL_sv_yes);
d648 1
a648 1
    PUSHs(&PL_sv_undef);
d756 1
a756 1
	I32 maxarg = AvFILL(av) + 1;
d776 1
a776 1
	I32 maxarg = AvFILL(av) + 1;
d786 2
a787 1
    I32 gimme = GIMME_V;
d802 1
a802 1
		Perl_croak(aTHX_ "Can't return hash to lvalue scalar context");
d819 1
a819 2
		    Perl_croak(aTHX_ "Can't return hash to lvalue"
			       " scalar context");
d878 1
a878 2
		    Perl_croak(aTHX_ "Can't return hash to lvalue"
			       " scalar context");
d952 1
d958 1
a958 2
		Perl_warner(aTHX_ packWARN(WARN_MISC),
			    "Reference found where even-sized list expected");
d961 2
a962 2
		Perl_warner(aTHX_ packWARN(WARN_MISC),
			    "Odd number of elements in hash assignment");
a1018 1
	    /*SUPPRESS 560*/
a1055 1
		sv = NEWSV(28,0);
d1057 1
a1057 1
		sv_setsv(sv,*relem);
d1236 3
a1238 3
    register char *t;
    register char *s;
    char *strend;
d1241 1
a1241 1
    char *truebase;			/* Start of string  */
d1244 1
a1244 1
    I32 gimme = GIMME;
d1247 1
a1247 1
    I32 oldsave = PL_savestack_ix;
d1259 1
a1259 2
    s = SvPV(TARG, len);
    strend = s + len;
d1262 1
d1326 3
a1328 2
	PL_bostr = truebase;
	s = CALLREG_INTUIT_START(aTHX_ rx, TARG, s, strend, r_flags, NULL);
d1340 1
a1340 1
    if (CALLREGEXEC(aTHX_ rx, s, strend, truebase, minmatch, TARG, NULL, r_flags))
d1356 2
a1357 1
	I32 nparens, i, len;
a1358 5
	nparens = rx->nparens;
	if (global && !nparens)
	    i = 1;
	else
	    i = 0;
a1363 1
	    /*SUPPRESS 560*/
d1365 1
a1365 1
		len = rx->endp[i] - rx->startp[i];
d1436 2
a1437 1
	rx->subbeg = truebase;
d1489 3
a1491 3
    register IO *io = GvIO(PL_last_in_gv);
    register I32 type = PL_op->op_type;
    I32 gimme = GIMME_V;
d1519 1
a1519 1
			sv_setpvn(GvSV(PL_last_in_gv), "-", 1);
d1540 3
a1542 2
	if (ckWARN2(WARN_GLOB, WARN_CLOSED)
		&& (!io || !(IoFLAGS(io) & IOf_START))) {
d1572 1
a1572 2
		STRLEN n_a;
		(void)SvPV_force(sv, n_a);
d1635 1
d1639 1
a1639 1
		if (*tmps == *SvPVX(PL_rs)) {
d1641 1
a1641 1
		    SvCUR(sv)--;
d1644 3
a1646 3
	    for (tmps = SvPVX(sv); *tmps; tmps++)
		if (!isALPHA(*tmps) && !isDIGIT(*tmps) &&
		    strchr("$&*(){}[]'\";\\|?<>~`", *tmps))
d1648 1
a1648 1
	    if (*tmps && PerlLIO_lstat(SvPVX(sv), &PL_statbuf) < 0) {
d1653 3
a1655 3
	     U8 *s = (U8*)SvPVX(sv) + offset;
	     STRLEN len = SvCUR(sv) - offset;
	     U8 *f;
d1658 1
a1658 1
		 !Perl_is_utf8_string_loc(aTHX_ s, len, &f))
d1666 1
a1666 2
		SvLEN_set(sv, SvCUR(sv)+1);
		Renew(SvPVX(sv), SvLEN(sv), char);
d1673 3
a1675 5
	    if (SvCUR(sv) < 60)
		SvLEN_set(sv, 80);
	    else
		SvLEN_set(sv, SvCUR(sv)+40);	/* allow some slop */
	    Renew(SvPVX(sv), SvLEN(sv), char);
d1709 2
a1710 2
    U32 lval = PL_op->op_flags & OPf_MOD || LVRET;
    U32 defer = PL_op->op_private & OPpLVAL_DEFER;
d1712 1
a1712 1
    U32 hash = (SvFAKE(keysv) && SvREADONLY(keysv)) ? SvUVX(keysv) : 0;
d1751 1
a1751 2
		STRLEN n_a;
		DIE(aTHX_ PL_no_helem, SvPV(keysv, n_a));
d1764 1
a1764 1
	    if (HvNAME(hv) && isGV(*svp))
d1769 1
a1769 1
		    char *key = SvPV(keysv, keylen);
a1794 1
    register SV **mark;
d1818 1
d1833 1
d1869 1
a1869 1
	    char *max = SvOK((SV*)av) ? SvPV((SV*)av, maxlen) : "";
d1886 1
a1886 1
		if (strEQ(SvPVX(cur), max))
d1923 2
a1924 5
	    SV **svp = av_fetch(av, cx->blk_loop.iterix--, FALSE);
	    if (svp)
		sv = *svp;
	    else
		sv = Nullsv;
d1927 1
a1927 1
	    sv = AvARRAY(av)[cx->blk_loop.iterix--];
d1992 1
a1992 1
    char *c;
d2027 1
a2027 1
    s = SvPV(TARG, len);
d2090 1
a2090 1
	     c = SvPV(nsv, clen);
d2094 1
a2094 1
	    c = SvPV(dstr, clen);
a2140 1
	    /*SUPPRESS 560*/
a2168 1
		/*SUPPRESS 560*/
d2185 1
a2185 1
		SvCUR_set(TARG, d - SvPVX(TARG) + i);
d2215 1
a2215 2
	dstr = NEWSV(25, len);
	sv_setpvn(dstr, m, s-m);
d2222 1
a2222 1
	    ReREFCNT_inc(rx);
d2255 2
a2256 4
	SvOOK_off(TARG);
	if (SvLEN(TARG))
	    Safefree(SvPVX(TARG));
	SvPVX(TARG) = SvPVX(dstr);
d2260 1
a2260 1
	SvPVX(dstr) = 0;
d2445 4
a2448 1
		if (SvFLAGS(TOPs) & (SVs_TEMP | SVs_PADTMP | SVf_READONLY)) {
d2550 1
a2550 1
    SV *dbsv = GvSV(PL_DBsub);
d2552 1
a2555 1
	save_item(dbsv);
d2563 1
a2563 1
	    SV *tmp = newRV((SV*)cv);
d2572 3
a2574 1
	(void)SvUPGRADE(dbsv, SVt_PVIV);
d2576 1
a2576 2
	SAVEIV(SvIVX(dbsv));
	SvIVX(dbsv) = PTR2IV(cv);	/* Do it the quickest way  */
d2593 1
a2593 1
    bool hasargs = (PL_op->op_flags & OPf_STACKED) != 0;
d2600 1
a2600 3
	    char *sym;
	    STRLEN n_a;

d2610 1
a2610 1
		sym = SvPOKp(sv) ? SvPVX(sv) : Nullch;
d2612 3
a2614 2
	    else
		sym = SvPV(sv, n_a);
d2624 1
a2624 1
	    SV **sp = &sv;		/* Used in tryAMAGICunDEREF macro. */
d2687 2
a2688 2
	if (!cv)
	    DIE(aTHX_ "No DBsub routine");
a2853 2
		AV* av;
		I32 items;
d2855 1
a2855 1
		av = (AV*)PAD_SVl(0);
d2857 1
a2857 1
		av = GvAV(PL_defgv);
d2859 2
a2860 1
		items = AvFILLp(av) + 1;   /* @@_ is not tieable */
d2912 1
d2923 2
a2924 1
	PAD_SET_CUR(padlist, CvDEPTH(cv));
d2995 1
a2995 1
	SV* tmpstr = sv_newmortal();
d3006 1
a3006 1
    SV* elemsv = POPs;
d3009 2
a3010 2
    U32 lval = PL_op->op_flags & OPf_MOD || LVRET;
    U32 defer = (PL_op->op_private & OPpLVAL_DEFER) && (elem > AvFILL(av));
a3021 2
	 static const char oom_array_extend[] =
	      "Out of memory during array extend"; /* Duplicated in av.c */
d3023 1
a3023 1
	      UV uv = SvUV(elemsv);
d3028 3
a3030 1
	 if (elem > 0)
d3032 1
d3071 3
a3073 3
	    SvOOK_off(sv);
	    Safefree(SvPVX(sv));
	    SvLEN(sv) = SvCUR(sv) = 0;
d3077 1
a3077 1
	    SvRV(sv) = NEWSV(355,0);
d3080 1
a3080 1
	    SvRV(sv) = (SV*)newAV();
d3083 1
a3083 1
	    SvRV(sv) = (SV*)newHV();
d3094 1
a3094 1
    SV* sv = TOPs;
d3097 1
a3097 1
	SV* rsv = SvRV(sv);
d3111 2
a3112 2
    SV* sv = cSVOP_sv;
    U32 hash = SvUVX(sv);
a3120 1
    SV* sv;
a3123 1
    char* name;
d3125 1
a3125 1
    char* packname = 0;
d3128 2
a3129 3

    name = SvPV(meth, namelen);
    sv = *(PL_stack_base + TOPMARK + 1);
d3142 2
a3143 5
	packname = Nullch;

        if(SvOK(sv) && (packname = SvPV(sv, packlen))) {
          HE* he;
	  he = hv_fetch_ent(PL_stashcache, sv, 0, 0);
d3197 1
a3197 1
	HE* he = hv_fetch_ent(stash, meth, 0, *hashp);
d3216 3
a3218 3
	char* leaf = name;
	char* sep = Nullch;
	char* p;
d3229 6
a3234 2
		stash ? HvNAME(stash) : packname;
	    packlen = strlen(packname);
d3276 10
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d19 13
d251 1
a251 1
    if (SvROK(TOPs) && SvROK(TOPm1s)) {
d1558 1
a1558 1
	        (void)SvOK_off(TARG);
d1624 1
a1624 1
		    (void)SvOK_off(TARG);
d1924 4
a1927 2
    if (cx->blk_loop.iterix >= (av == PL_curstack ? cx->blk_oldsp : AvFILL(av)))
	RETPUSHNO;
d1929 10
a1938 6
    if (SvMAGICAL(av) || AvREIFY(av)) {
	SV **svp = av_fetch(av, ++cx->blk_loop.iterix, FALSE);
	if (svp)
	    sv = *svp;
	else
	    sv = Nullsv;
d1941 14
a1954 1
	sv = AvARRAY(av)[++cx->blk_loop.iterix];
d1956 1
d2268 1
a2268 1
	(void)SvOOK_off(TARG);
d3081 1
a3081 1
	    (void)SvOOK_off(sv);
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d144 1
a144 1
    bool rbyte = !SvUTF8(right), rcopied = FALSE;
d154 1
a154 1
	lbyte = !SvUTF8(left);
d167 3
a169 1
	lbyte = !SvUTF8(left);
d494 2
a495 1
    AV *av = GvAV(cGVOP_gv);
d749 4
a752 1
		SP[i+1] = (svp) ? *svp : &PL_sv_undef;
d1359 1
a1362 1
		s = rx->startp[i] + truebase;
d1846 1
a1846 1
    SV* sv;
d1862 2
a1863 2
	    STRLEN maxlen;
	    char *max = SvPV((SV*)av, maxlen);
d1876 1
a1876 1
		    SvREFCNT_dec(*itersvp);
d1878 1
d1903 1
a1903 1
	    SvREFCNT_dec(*itersvp);
d1905 1
a1913 2
    SvREFCNT_dec(*itersvp);

d1953 1
d1955 2
d2320 1
d2358 2
a2362 1
    LEAVE;
d2380 1
d2416 2
a2419 1
	    LEAVE;
d2428 2
a2431 1
		    LEAVE;
d2444 2
a2447 1
		LEAVE;
d2461 2
a2464 1
		    LEAVE;
d2516 2
a2520 1
    LEAVE;
d2884 1
a2884 3
	if (CvDEPTH(cv) < 2)
	    (void)SvREFCNT_inc(cv);
	else {
d2999 12
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@a872 6
	/* 21394 adds this, but I'm not sure if it's safe in maint:
	if (SvRMAGICAL(hv) && mg_find((SV *)hv, PERL_MAGIC_tied))
	    Perl_croak(aTHX_ "Can't provide tied hash usage; "
		       "use keys(%%hash) to test if empty");
	*/

d876 1
a876 6
	if (HvFILL(hv))
            Perl_sv_setpvf(aTHX_ TARG, "%"IVdf"/%"IVdf,
			   (IV)HvFILL(hv), (IV)HvMAX(hv) + 1);
	else
	    sv_setiv(TARG, 0);
	
d986 3
d991 1
d1058 1
d1070 3
a1172 1
    gimme = GIMME_V;
d1178 1
a1178 1
	SETi(lastrelem - firstrelem + 1);
d1181 10
a1190 1
	if (ary || hash)
d1192 1
d1552 1
a1552 1
	if (!tmplen)
d1583 3
a1585 1
	    && (type == OP_GLOB || SNARF_EOF(gimme, PL_rs, io, sv)))
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d144 1
a144 1
    bool rbyte = !SvUTF8(right);
d148 2
a149 1
	rpv = SvPV(right, rlen);	/* no point setting UTF8 here */
d185 2
d204 1
a204 1
	    SAVECLEARSV(PL_curpad[PL_op->op_targ]);
d207 1
a207 1
	    vivify_ref(PL_curpad[PL_op->op_targ], PL_op->op_private & OPpDEREF);
d578 1
a578 1
	SETERRNO(EBADF,RMS$_IFI);
d588 1
a588 1
	SETERRNO(EBADF,IoIFP(io)?RMS$_FAC:RMS$_IFI);
d657 3
d754 1
a754 1
    else {
d766 1
d780 1
a780 1
	    if (GIMME == G_SCALAR)
d785 3
d797 1
a797 1
		if (GIMME == G_SCALAR)
d822 1
a822 1
		    if (GIMME == G_ARRAY) {
d857 1
a857 1
		if (GIMME == G_SCALAR)
d866 1
a866 1
    if (GIMME == G_ARRAY) { /* array wanted */
d870 1
a870 1
    else {
d872 7
d881 1
a888 1
	RETURN;
d890 1
d1110 3
a1112 1
	    (void)setresuid(PL_uid,PL_euid,(Uid_t)-1);
d1115 2
a1116 1
	    (void)setreuid(PL_uid,PL_euid);
d1126 1
a1126 1
		(void)seteuid(PL_uid);
d1142 3
a1144 1
	    (void)setresgid(PL_gid,PL_egid,(Gid_t)-1);
d1147 2
a1148 1
	    (void)setregid(PL_gid,PL_egid);
d1158 1
a1158 1
		(void)setegid(PL_gid);
d1244 1
a1244 1
    PL_reg_match_utf8 = DO_UTF8(TARG);
d1419 1
a1419 1
	if (PL_reg_match_utf8) {
d1442 1
a1442 1
    rx->nparens = rx->lastparen = 0;	/* used by @@- and @@+ */
d1482 5
a1486 2
	if (gimme == G_SCALAR)
	    SvSetMagicSV_nosteal(TARG, TOPs);
d1530 5
a1534 1
	    (void)SvOK_off(TARG);
d1548 6
a1553 1
	if (type == OP_RCATLINE)
d1555 1
a1555 2
	else
	    offset = 0;
d1595 4
a1598 1
		(void)SvOK_off(TARG);
d1629 11
d1910 5
d1968 1
d1996 1
a1996 1
    PL_reg_match_utf8 = DO_UTF8(TARG);
d2003 1
a2003 1
    slen = PL_reg_match_utf8 ? utf8_length((U8*)s, (U8*)strend) : len;
d2044 1
a2044 1
	     SV *nsv = sv_newmortal();
d2065 2
a2066 1
	&& !(rx->reganch & ROPT_LOOKBEHIND_SEEN)) {
d2185 1
d2202 4
a2205 1
	    sv_catpvn(dstr, s, m-s);
d2213 2
a2214 6
	if (doutf8 && !DO_UTF8(dstr)) {
	    SV* nsv = sv_2mortal(newSVpvn(s, strend - s));
	    
	    sv_utf8_upgrade(nsv);
	    sv_catpvn(dstr, SvPVX(nsv), SvCUR(nsv));
	}
d2219 2
a2220 1
	Safefree(SvPVX(TARG));
d2411 3
a2413 2
		    DIE(aTHX_ "Can't return a %s from lvalue subroutine",
			SvREADONLY(TOPs) ? "readonly value" : "temporary");
d2630 1
a2630 1
		DIE(aTHX_ "Undefined subroutine &%s called", SvPVX(sub_name));
d2660 1
a2660 1
		AV *av = (AV*)PL_curpad[0];
d2811 1
a2811 1
		av = (AV*)PL_curpad[0];
a2849 1
	SV** svp = AvARRAY(padlist);
d2856 2
a2857 2
	 * Owing the speed considerations, we choose to search for the cv
	 * in doeval() instead.
d2861 1
a2861 1
	else {	/* save temporaries on recursion? */
d2863 1
a2863 41
	    if (CvDEPTH(cv) > AvFILLp(padlist)) {
		AV *av;
		AV *newpad = newAV();
		SV **oldpad = AvARRAY(svp[CvDEPTH(cv)-1]);
		I32 ix = AvFILLp((AV*)svp[1]);
		I32 names_fill = AvFILLp((AV*)svp[0]);
		svp = AvARRAY(svp[0]);
		for ( ;ix > 0; ix--) {
		    if (names_fill >= ix && svp[ix] != &PL_sv_undef) {
			char *name = SvPVX(svp[ix]);
			if ((SvFLAGS(svp[ix]) & SVf_FAKE) /* outer lexical? */
			    || *name == '&')		  /* anonymous code? */
			{
			    av_store(newpad, ix, SvREFCNT_inc(oldpad[ix]));
			}
			else {				/* our own lexical */
			    if (*name == '@@')
				av_store(newpad, ix, sv = (SV*)newAV());
			    else if (*name == '%')
				av_store(newpad, ix, sv = (SV*)newHV());
			    else
				av_store(newpad, ix, sv = NEWSV(0,0));
			    SvPADMY_on(sv);
			}
		    }
		    else if (IS_PADGV(oldpad[ix]) || IS_PADCONST(oldpad[ix])) {
			av_store(newpad, ix, sv = SvREFCNT_inc(oldpad[ix]));
		    }
		    else {
			av_store(newpad, ix, sv = NEWSV(0,0));
			SvPADTMP_on(sv);
		    }
		}
		av = newAV();		/* will be @@_ */
		av_extend(av, 0);
		av_store(newpad, 0, (SV*)av);
		AvFLAGS(av) = AVf_REIFY;
		av_store(padlist, CvDEPTH(cv), (SV*)newpad);
		AvFILLp(padlist) = CvDEPTH(cv);
		svp = AvARRAY(padlist);
	    }
d2867 1
a2867 1
	    AV* av = (AV*)PL_curpad[0];
d2879 1
a2879 2
	SAVEVPTR(PL_curpad);
    	PL_curpad = AvARRAY((AV*)svp[CvDEPTH(cv)]);
d2891 1
a2891 1
	    av = (AV*)PL_curpad[0];
d2903 1
a2903 1
	    cx->blk_sub.oldcurpad = PL_curpad;
d2952 2
a2953 2
	Perl_warner(aTHX_ packWARN(WARN_RECURSION), "Deep recursion on subroutine \"%s\"",
		SvPVX(tmpstr));
d2969 1
a2969 1
	Perl_warner(aTHX_ packWARN(WARN_MISC), "Use of reference \"%s\" as array index", SvPV_nolen(elemsv));
d3053 1
a3053 1
    SV* sv = cSVOP->op_sv;
d3070 1
d3088 10
d3099 1
a3099 1
	    !(packname = SvPV(sv, packlen)) ||
d3116 6
d3154 1
a3154 1
    gv = gv_fetchmethod(stash, name);
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d24 3
a26 3
#ifdef USE_THREADS
static void unset_cvowner(pTHXo_ void *cvarg);
#endif /* USE_THREADS */
d75 1
a75 8
    STRLEN len;
    char *s;
    s = SvPV(TOPs,len);
    sv_setpvn(TARG,s,len);
    if (SvUTF8(TOPs))
	SvUTF8_on(TARG);
    else
	SvUTF8_off(TARG);
d138 20
a157 24
    SV* rcopy = Nullsv;

    if (SvGMAGICAL(left))
        mg_get(left);
    if (TARG == right && SvGMAGICAL(right))
        mg_get(right);

    if (TARG == right && left != right)
	/* Clone since otherwise we cannot prepend. */
	rcopy = sv_2mortal(newSVsv(right));

    if (TARG != left)
	sv_setsv(TARG, left);

    if (TARG == right) {
	if (left == right) {
	    /*  $right = $right . $right; */
	    STRLEN rlen;
	    char *rpv = SvPV(right, rlen);

	    sv_catpvn(TARG, rpv, rlen);
	}
	else /* $right = $left  . $right; */
	    sv_catsv(TARG, rcopy);
d159 7
a165 6
    else {
	if (!SvOK(TARG)) /* Avoid warning when concatenating to undef. */
	    sv_setpv(TARG, "");
	/* $other = $left . $right; */
	/* $left  = $left . $right; */
	sv_catsv(TARG, right);
d169 3
a171 5
    if ((SvIOK(right) || SvNOK(right)) && ckWARN(WARN_Y2K)) {
	STRLEN n;
	char *s = SvPV(TARG,n);
	if (n >= 2 && s[n-2] == '1' && s[n-1] == '9'
	    && (n == 2 || !isDIGIT(s[n-3])))
d173 1
a173 1
	    Perl_warner(aTHX_ WARN_Y2K, "Possible Y2K bug: %s",
d179 10
d215 1
a215 1
	if (SvROK(PL_last_in_gv) && SvTYPE(SvRV(PL_last_in_gv)) == SVt_PVGV) 
d231 57
d298 1
a298 1
    if (SvREADONLY(TOPs) || SvTYPE(TOPs) > SVt_PVLV)
d300 2
a301 2
    if (SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs) &&
    	SvIVX(TOPs) != IV_MAX)
d306 1
a306 1
    else
d325 148
a472 1
    dSP; dATARGET; tryAMAGICbin(add,opASSIGN);
d474 8
a481 3
      dPOPTOPnnrl_ul;
      SETn( left + right );
      RETURN;
a536 1
    STRLEN n_a;
d542 4
a545 1
    if ((mg = SvTIED_mg((SV*)gv, 'q'))) {
d548 1
a548 1
	    /* If using default handle then we need to make space to 
d557 1
a557 1
	*MARK = SvTIED_obj((SV*)gv, mg);
d569 2
a570 1
        if ((GvEGV(gv)) && (mg = SvTIED_mg((SV*)GvEGV(gv),'q')))
d579 2
a580 15
	    if (IoIFP(io)) {
		/* integrate with report_evil_fh()? */
	        char *name = NULL;
		if (isGV(gv)) {
		    SV* sv = sv_newmortal();
		    gv_efullname4(sv, gv, Nullch, FALSE);
		    name = SvPV_nolen(sv);
		}
		if (name && *name)
		  Perl_warner(aTHX_ WARN_IO,
			      "Filehandle %s opened only for input", name);
		else
		    Perl_warner(aTHX_ WARN_IO,
				"Filehandle opened only for input");
	    }
d589 1
a589 1
	if (PL_ofslen) {
d595 1
a595 1
		    if (PerlIO_write(fp, PL_ofs, PL_ofslen) == 0 || PerlIO_error(fp)) {
d612 2
a613 2
	    if (PL_orslen)
		if (PerlIO_write(fp, PL_ors, PL_orslen) == 0 || PerlIO_error(fp))
d671 1
a671 1
	    
d734 1
a734 1
	EXTEND(SP, maxarg);          
d736 2
a737 2
	    U32 i; 
	    for (i=0; i < maxarg; i++) {
d741 1
a741 1
	} 
d795 1
a795 1
	    
d930 1
a930 1
		Perl_warner(aTHX_ WARN_MISC,
d934 1
a934 1
		Perl_warner(aTHX_ WARN_MISC,
d1177 3
a1179 1
    sv_magic(sv,(SV*)ReREFCNT_inc(pm->op_pmregexp),'r',0,0);
d1187 1
d1194 1
a1194 1
    register REGEXP *rx = pm->op_pmregexp;
d1209 1
d1219 3
d1229 1
d1232 1
a1232 1
	rx = pm->op_pmregexp;
d1234 3
a1236 1
    if (rx->minlen > len) goto failure;
d1241 1
a1241 1
    if ((global = pm->op_pmflags & PMf_GLOBAL)) {
d1244 1
a1244 1
	    MAGIC* mg = mg_find(TARG, 'g');
d1247 1
a1247 1
		    rx->endp[0] = rx->startp[0] = mg->mg_len; 
d1250 1
a1250 1
		    rx->endp[0] = rx->startp[0] = mg->mg_len; 
d1260 1
a1260 1
    if (SvSCREAM(TARG)) 
d1278 1
d1284 1
a1284 1
	     && !PL_sawampersand 
d1294 2
a1295 2
	if (pm->op_pmflags & PMf_ONCE)
	    pm->op_pmdynflags |= PMdf_USED;
d1307 1
a1307 1
	I32 iters, i, len;
d1309 2
a1310 2
	iters = rx->nparens;
	if (global && !iters)
d1315 3
a1317 3
	EXTEND(SP, iters + i);
	EXTEND_MORTAL(iters + i);
	for (i = !i; i <= iters; i++) {
d1322 3
d1327 1
a1327 1
		if ((pm->op_pmdynflags & PMdf_UTF8) && !IN_BYTE) {
a1328 2
		    sv_utf8_downgrade(*SP, TRUE);
		}
d1332 16
d1354 1
a1354 1
	else if (!iters)
d1363 1
a1363 1
		mg = mg_find(TARG, 'g');
d1365 2
a1366 2
		sv_magic(TARG, (SV*)0, 'g', Nullch, 0);
		mg = mg_find(TARG, 'g');
d1385 2
a1386 2
    if (pm->op_pmflags & PMf_ONCE)
	pm->op_pmdynflags |= PMdf_USED;
d1394 7
a1400 1
	rx->endp[0] = s - truebase + rx->minlen;
d1403 1
a1403 1
    } 
d1423 1
a1423 1
    if (global && !(pm->op_pmflags & PMf_CONTINUE)) {
d1425 1
a1425 1
	    MAGIC* mg = mg_find(TARG, 'g');
d1449 1
a1449 1
    if ((mg = SvTIED_mg((SV*)PL_last_in_gv, 'q'))) {
d1451 1
a1451 1
	XPUSHs(SvTIED_obj((SV*)PL_last_in_gv, mg));
d1482 2
a1483 132
	    else if (type == OP_GLOB) {
		SV *tmpcmd = NEWSV(55, 0);
		SV *tmpglob = POPs;
		ENTER;
		SAVEFREESV(tmpcmd);
#ifdef VMS /* expand the wildcards right here, rather than opening a pipe, */
           /* since spawning off a process is a real performance hit */
		{
#include <descrip.h>
#include <lib$routines.h>
#include <nam.h>
#include <rmsdef.h>
		    char rslt[NAM$C_MAXRSS+1+sizeof(unsigned short int)] = {'\0','\0'};
		    char vmsspec[NAM$C_MAXRSS+1];
		    char *rstr = rslt + sizeof(unsigned short int), *begin, *end, *cp;
		    char tmpfnam[L_tmpnam] = "SYS$SCRATCH:";
		    $DESCRIPTOR(dfltdsc,"SYS$DISK:[]*.*;");
		    PerlIO *tmpfp;
		    STRLEN i;
		    struct dsc$descriptor_s wilddsc
		       = {0, DSC$K_DTYPE_T, DSC$K_CLASS_S, 0};
		    struct dsc$descriptor_vs rsdsc
		       = {sizeof rslt, DSC$K_DTYPE_VT, DSC$K_CLASS_VS, rslt};
		    unsigned long int cxt = 0, sts = 0, ok = 1, hasdir = 0, hasver = 0, isunix = 0;

		    /* We could find out if there's an explicit dev/dir or version
		       by peeking into lib$find_file's internal context at
		       ((struct NAM *)((struct FAB *)cxt)->fab$l_nam)->nam$l_fnb
		       but that's unsupported, so I don't want to do it now and
		       have it bite someone in the future. */
		    strcat(tmpfnam,PerlLIO_tmpnam(NULL));
		    cp = SvPV(tmpglob,i);
		    for (; i; i--) {
		       if (cp[i] == ';') hasver = 1;
		       if (cp[i] == '.') {
		           if (sts) hasver = 1;
		           else sts = 1;
		       }
		       if (cp[i] == '/') {
		          hasdir = isunix = 1;
		          break;
		       }
		       if (cp[i] == ']' || cp[i] == '>' || cp[i] == ':') {
		           hasdir = 1;
		           break;
		       }
		    }
		    if ((tmpfp = PerlIO_open(tmpfnam,"w+","fop=dlt")) != NULL) {
		        Stat_t st;
		        if (!PerlLIO_stat(SvPVX(tmpglob),&st) && S_ISDIR(st.st_mode))
		          ok = ((wilddsc.dsc$a_pointer = tovmspath(SvPVX(tmpglob),vmsspec)) != NULL);
		        else ok = ((wilddsc.dsc$a_pointer = tovmsspec(SvPVX(tmpglob),vmsspec)) != NULL);
		        if (ok) wilddsc.dsc$w_length = (unsigned short int) strlen(wilddsc.dsc$a_pointer);
		        while (ok && ((sts = lib$find_file(&wilddsc,&rsdsc,&cxt,
		                                    &dfltdsc,NULL,NULL,NULL))&1)) {
		            end = rstr + (unsigned long int) *rslt;
		            if (!hasver) while (*end != ';') end--;
		            *(end++) = '\n';  *end = '\0';
		            for (cp = rstr; *cp; cp++) *cp = _tolower(*cp);
		            if (hasdir) {
		              if (isunix) trim_unixpath(rstr,SvPVX(tmpglob),1);
		              begin = rstr;
		            }
		            else {
		                begin = end;
		                while (*(--begin) != ']' && *begin != '>') ;
		                ++begin;
		            }
		            ok = (PerlIO_puts(tmpfp,begin) != EOF);
		        }
		        if (cxt) (void)lib$find_file_end(&cxt);
		        if (ok && sts != RMS$_NMF &&
		            sts != RMS$_DNF && sts != RMS$_FNF) ok = 0;
		        if (!ok) {
		            if (!(sts & 1)) {
		              SETERRNO((sts == RMS$_SYN ? EINVAL : EVMSERR),sts);
		            }
		            PerlIO_close(tmpfp);
		            fp = NULL;
		        }
		        else {
		           PerlIO_rewind(tmpfp);
		           IoTYPE(io) = IoTYPE_RDONLY;
		           IoIFP(io) = fp = tmpfp;
		           IoFLAGS(io) &= ~IOf_UNTAINT;  /* maybe redundant */
		        }
		    }
		}
#else /* !VMS */
#ifdef MACOS_TRADITIONAL
		sv_setpv(tmpcmd, "glob ");
		sv_catsv(tmpcmd, tmpglob);
		sv_catpv(tmpcmd, " |");
#else
#ifdef DOSISH
#ifdef OS2
		sv_setpv(tmpcmd, "for a in ");
		sv_catsv(tmpcmd, tmpglob);
		sv_catpv(tmpcmd, "; do echo \"$a\\0\\c\"; done |");
#else
#ifdef DJGPP
		sv_setpv(tmpcmd, "/dev/dosglob/"); /* File System Extension */
		sv_catsv(tmpcmd, tmpglob);
#else
		sv_setpv(tmpcmd, "perlglob ");
		sv_catsv(tmpcmd, tmpglob);
		sv_catpv(tmpcmd, " |");
#endif /* !DJGPP */
#endif /* !OS2 */
#else /* !DOSISH */
#if defined(CSH)
		sv_setpvn(tmpcmd, PL_cshname, PL_cshlen);
		sv_catpv(tmpcmd, " -cf 'set nonomatch; glob ");
		sv_catsv(tmpcmd, tmpglob);
		sv_catpv(tmpcmd, "' 2>/dev/null |");
#else
		sv_setpv(tmpcmd, "echo ");
		sv_catsv(tmpcmd, tmpglob);
#if 'z' - 'a' == 25
		sv_catpv(tmpcmd, "|tr -s ' \t\f\r' '\\012\\012\\012\\012'|");
#else
		sv_catpv(tmpcmd, "|tr -s ' \t\f\r' '\\n\\n\\n\\n'|");
#endif
#endif /* !CSH */
#endif /* !DOSISH */
#endif /* MACOS_TRADITIONAL */
		(void)do_open(PL_last_in_gv, SvPVX(tmpcmd), SvCUR(tmpcmd),
			      FALSE, O_RDONLY, 0, Nullfp);
		fp = IoIFP(io);
#endif /* !VMS */
		LEAVE;
	    }
d1487 2
a1488 17
	else if (ckWARN(WARN_IO)	/* stdout/stderr or other write fh */
		 && (IoTYPE(io) == IoTYPE_WRONLY || fp == PerlIO_stdout()
		     || fp == PerlIO_stderr()))
	{
	    /* integrate with report_evil_fh()? */
	    char *name = NULL;
	    if (isGV(PL_last_in_gv)) { /* can this ever fail? */
		SV* sv = sv_newmortal();
		gv_efullname4(sv, PL_last_in_gv, Nullch, FALSE);
		name = SvPV_nolen(sv);
	    }
	    if (name && *name)
		Perl_warner(aTHX_ WARN_IO,
			    "Filehandle %s opened only for output", name);
	    else
		Perl_warner(aTHX_ WARN_IO,
			    "Filehandle opened only for output");
d1495 1
a1495 1
		Perl_warner(aTHX_ WARN_GLOB,
d1539 1
d1552 1
a1552 1
		    Perl_warner(aTHX_ WARN_GLOB,
d1560 1
d1570 1
d1642 2
d1646 20
a1665 1
	he = hv_fetch_ent(hv, keysv, lval && !defer, 0);
d1671 1
a1671 1
	svp = avhv_fetch_ent((AV*)hv, keysv, lval && !defer, 0);
d1687 1
a1687 1
	    sv_magic(lv, key2 = newSVsv(keysv), 'y', Nullch, 0);
d1697 8
a1704 2
	    else
		save_helem(hv, keysv, svp);
d1751 1
a1751 1
	if (MARK <= SP)
d1756 1
a1756 1
	else {
d1801 1
a1801 1
#ifndef USE_THREADS			  /* don't risk potential race */
d1806 1
a1806 1
		else 
d1827 1
a1827 1
#ifndef USE_THREADS			  /* don't risk potential race */
d1832 1
a1832 1
	else 
d1850 11
a1860 3
    if ((sv = SvMAGICAL(av)
	      ? *av_fetch(av, ++cx->blk_loop.iterix, FALSE) 
	      : AvARRAY(av)[++cx->blk_loop.iterix]))
d1864 1
a1864 1
    if (av != PL_curstack && SvIMMORTAL(sv)) {
d1876 1
a1876 1
	    sv_magic(lv, Nullsv, 'y', Nullch, 0);
d1893 1
a1893 1
    register SV *dstr, *rstr;
d1907 1
a1907 1
    register REGEXP *rx = pm->op_pmregexp;
a1910 1
    bool do_utf8;
d1912 1
d1915 1
a1915 1
    rstr = (pm->op_pmflags & PMf_CONST) ? POPs : Nullsv;
d1922 1
a1922 1
    do_utf8 = DO_UTF8(TARG);
d1940 2
d1947 1
a1947 1
    slen = do_utf8 ? utf8_length((U8*)s, (U8*)strend) : len;
d1954 1
a1954 1
	rx = pm->op_pmregexp;
d1966 1
d1973 1
a1973 1
	     && !PL_sawampersand 
d1985 22
a2006 2
    c = rstr ? SvPV(rstr, clen) : Nullch;

d2008 1
a2008 2
    if (c && clen <= rx->minlen && (once || !(r_flags & REXEC_COPY_STR))
	&& do_utf8 == DO_UTF8(rstr)
d2105 2
a2113 2
	bool isutf8;

d2122 1
a2122 1
	if (do_utf8)
d2147 1
a2147 1
		sv_catsv(dstr, rstr);
d2150 10
a2159 2
	} while (CALLREGEXEC(aTHX_ rx, s, strend, orig, s == m, TARG, NULL, r_flags));
	sv_catpvn(dstr, s, strend - s);
d2166 1
a2166 1
	isutf8 = DO_UTF8(dstr);
d2175 1
a2175 1
	if (isutf8)
d2186 1
a2186 1
ret_no:         
d2245 1
a2245 1
 
d2281 1
a2281 1
    
d2303 1
a2303 1
 
d2375 2
a2376 1
		if (SvFLAGS(*mark) & (SVs_TEMP | SVs_PADTMP | SVf_READONLY)) {
d2383 2
a2384 5
		    DIE(aTHX_ "Can't return %s from lvalue subroutine",
			(*mark != &PL_sv_undef)
			? (SvREADONLY(TOPs)
			    ? "a readonly value" : "a temporary")
			: "an uninitialized value");
d2432 1
a2432 1
    
d2452 1
a2452 1
	     || strEQ(GvNAME(gv), "END") 
d2504 2
d2517 1
d2586 1
a2586 1
#ifdef USE_THREADS
d2630 1
a2630 1
				  thr, sv);)
d2714 1
a2714 1
				      CvDEPTH(cv)););
d2718 1
a2718 1
#endif /* USE_THREADS */
d2733 1
a2733 1
	    items = (*fp3)(CvXSUBANY(cv).any_i32, 
d2751 1
a2751 1
#ifdef USE_THREADS
d2755 1
a2755 1
#endif /* USE_THREADS */		
d2763 1
a2763 1
		    PUTBACK ;		    
d2773 1
a2773 1
	    (void)(*CvXSUB(cv))(aTHXo_ cv);
d2847 1
a2847 1
#ifdef USE_THREADS
d2857 1
a2857 1
		PUTBACK ;		    
d2860 1
a2860 1
#endif /* USE_THREADS */		
d2863 1
a2863 1
#ifndef USE_THREADS
d2865 1
a2865 1
#endif /* USE_THREADS */
d2882 1
a2882 1
#ifndef USE_THREADS
d2885 1
a2885 1
#endif /* USE_THREADS */
d2905 1
a2905 1
	    
d2931 1
a2931 1
	Perl_warner(aTHX_ WARN_RECURSION, "Deep recursion on anonymous subroutine");
d2935 1
a2935 1
	Perl_warner(aTHX_ WARN_RECURSION, "Deep recursion on subroutine \"%s\"", 
d2944 2
a2945 1
    IV elem = POPi;
d2951 2
d2966 1
a2966 1
	    sv_magic(lv, Nullsv, 'y', Nullch, 0);
d3052 1
a3052 1
    char* packname;
d3062 1
a3062 1
        mg_get(sv);
d3068 1
d3075 1
d3086 2
a3087 1
	    stash = gv_stashpvn(packname, packlen, TRUE);
d3090 1
d3094 1
d3106 3
d3121 1
d3123 7
a3132 1
	GV* gv;
d3141 3
a3143 1
	    packname = sep ? CopSTASHPV(PL_curcop) : HvNAME(stash);
d3147 1
d3151 3
a3153 2
	gv = gv_fetchpv(packname, 0, SVt_PVHV);
	if (gv && isGV(gv)) {
d3155 2
a3156 2
		       "Can't locate object method \"%s\" via package \"%s\"",
		       leaf, packname);
d3160 3
a3162 3
		       "Can't locate object method \"%s\" via package \"%s\""
		       " (perhaps you forgot to load \"%s\"?)",
		       leaf, packname, packname);
d3168 1
a3168 1
#ifdef USE_THREADS
d3170 1
a3170 1
unset_cvowner(pTHXo_ void *cvarg)
d3179 1
a3179 1
			      CvDEPTH(cv)););
d3185 1
a3185 1
#endif /* USE_THREADS */
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a21 4
#ifdef I_UNISTD
#include <unistd.h>
#endif

d30 1
a30 1
    djSP;
d46 1
a46 1
    djSP;
d74 1
a74 1
    djSP; dTARGET;
d79 1
a79 1
    if (SvUTF8(TOPs) && !IN_BYTE)
d81 2
d89 1
a89 1
    djSP;
d96 1
a96 1
    djSP;
d107 1
a107 1
    djSP; dPOPTOPssrl;
d122 1
a122 1
    djSP;
d142 1
a142 1
  djSP; dATARGET; tryAMAGICbin(concat,opASSIGN);
d145 19
a163 2
    STRLEN len;
    char *s;
d165 1
a165 6
    if (TARG != left) {
	s = SvPV(left,len);
	if (TARG == right) {
	    sv_insert(TARG, 0, 0, s, len);
	    SETs(TARG);
	    RETURN;
d167 2
a168 1
	sv_setpvn(TARG,s,len);
d170 6
a175 5
    else if (SvGMAGICAL(TARG))
	mg_get(TARG);
    else if (!SvOK(TARG) && SvTYPE(TARG) <= SVt_PVMG) {
	sv_setpv(TARG, "");	/* Suppress warning. */
	s = SvPV_force(TARG, len);
d177 1
a177 2
    s = SvPV(right,len);
    if (SvOK(TARG)) {
d179 8
a186 9
	if ((SvIOK(right) || SvNOK(right)) && ckWARN(WARN_Y2K)) {
	    STRLEN n;
	    char *s = SvPV(TARG,n);
	    if (n >= 2 && s[n-2] == '1' && s[n-1] == '9'
		&& (n == 2 || !isDIGIT(s[n-3])))
	    {
		Perl_warner(aTHX_ WARN_Y2K, "Possible Y2K bug: %s",
			    "about to append an integer to '19'");
	    }
d188 1
d190 1
a190 13
	if (DO_UTF8(right))
	    sv_utf8_upgrade(TARG);
	sv_catpvn(TARG,s,len);
	if (!IN_BYTE) {
	    if (SvUTF8(right))
		SvUTF8_on(TARG);
	}
	else if (!SvUTF8(right)) {
	    SvUTF8_off(TARG);
	}
    }
    else
	sv_setpvn(TARG,s,len);	/* suppress warning */
d198 1
a198 1
    djSP; dTARGET;
d232 1
a232 1
    djSP; tryAMAGICbinSET(eq,0); 
d242 1
a242 1
    djSP;
d259 1
a259 1
    djSP;
d270 1
a270 1
    djSP; dATARGET; tryAMAGICbin(add,opASSIGN); 
d280 1
a280 1
    djSP;
d294 1
a294 1
    djSP; dMARK; dTARGET;
d304 1
a304 1
    djSP;
d325 1
a325 1
    djSP; dMARK; dORIGMARK;
d337 1
d360 4
a363 6
	if (ckWARN(WARN_UNOPENED)) {
	    SV* sv = sv_newmortal();
	    gv_efullname3(sv, gv, Nullch);
            Perl_warner(aTHX_ WARN_UNOPENED, "Filehandle %s never opened",
			SvPV(sv,n_a));
        }
d370 13
a382 5
		SV* sv = sv_newmortal();
		gv_efullname3(sv, gv, Nullch);
		Perl_warner(aTHX_ WARN_IO,
			    "Filehandle %s opened only for input",
			    SvPV(sv,n_a));
d384 2
a385 2
	    else if (ckWARN(WARN_CLOSED))
		report_closed_fh(gv, io, "print", "filehandle");
d436 1
a436 1
    djSP; dTOPss;
d450 6
d464 7
d477 1
a477 1
		STRLEN n_a;
d496 1
a496 1
		sym = SvPV(sv,n_a);
d501 4
a504 1
		    if (!gv)
d506 1
d524 7
d560 1
a560 1
    djSP; dTOPss;
d574 6
d588 7
d601 1
a601 1
		STRLEN n_a;
d620 1
a620 1
		sym = SvPV(sv,n_a);
d625 4
a628 1
		    if (!gv)
d630 1
d648 7
d765 1
a765 1
    djSP;
d976 1
a976 1
    djSP;
d986 1
a986 1
    djSP; dTARG;
d1013 1
a1013 1
	DIE(aTHX_ "panic: do_match");
d1050 1
a1050 1
    if ((gimme != G_ARRAY && !global && rx->nparens)
d1069 2
a1070 1
    if (rx->reganch & RE_USE_INTUIT) {
d1079 2
a1080 1
		      && (r_flags & REXEC_SCREAM))))
d1333 1
a1333 1
		           IoTYPE(io) = '<';
d1387 1
a1387 1
		 && (IoTYPE(io) == '>' || fp == PerlIO_stdout()
d1390 13
a1402 4
	    SV* sv = sv_newmortal();
	    gv_efullname3(sv, PL_last_in_gv, Nullch);
	    Perl_warner(aTHX_ WARN_IO, "Filehandle %s opened only for output",
			SvPV_nolen(sv));
d1406 2
a1407 1
	if (ckWARN2(WARN_GLOB,WARN_CLOSED) && io && !(IoFLAGS(io) & IOf_START)) {
d1413 1
a1413 1
		report_closed_fh(PL_last_in_gv, io, "readline", "filehandle");
d1440 7
d1450 1
a1450 2
     || !RsSNARF(rs) || (IoFLAGS(io) & IOf_NOLINE)			\
     || ((IoFLAGS(io) |= IOf_NOLINE), FALSE))
d1475 1
d1478 1
a1478 5
	/* This should not be marked tainted if the fp is marked clean */
	if (!(IoFLAGS(io) & IOf_UNTAINT)) {
	    TAINT;
	    SvTAINTED_on(sv);
	}
d1480 1
d1524 1
a1524 1
    djSP;
d1545 1
a1545 1
    djSP;
d1550 1
a1550 1
    U32 lval = PL_op->op_flags & OPf_MOD;
d1608 1
a1608 1
    djSP;
d1664 1
a1664 1
    djSP;
d1766 1
a1766 1
    djSP; dTARG;
d1769 1
a1769 1
    register SV *dstr;
d1787 2
d1791 1
a1791 1
    dstr = (pm->op_pmflags & PMf_CONST) ? POPs : Nullsv;
d1797 4
a1800 1
    }                  
d1818 1
a1818 1
	DIE(aTHX_ "panic: do_subst");
d1821 4
a1824 3
    maxiters = 2*(strend - s) + 10;	/* We can match twice at each 
					   position, once with zero-length,
					   second time with non-zero. */
d1858 1
a1858 1
    c = dstr ? SvPV(dstr, clen) : Nullch;
d1862 1
d1951 1
a1951 1
	(void)SvPOK_only(TARG);
d1966 2
d1976 2
d2001 1
a2001 1
		sv_catpvn(dstr, c, clen);
d2012 1
d2021 2
d2041 1
a2041 1
    djSP;
d2082 1
a2082 1
    djSP;
d2140 1
a2140 1
    djSP;
a2292 1
    dTHR;
d2306 3
a2308 1
	    sv_setsv(dbsv, newRV((SV*)cv));
d2329 1
a2329 1
    djSP; dPOPss;
d2731 1
d2787 1
a2787 1
    djSP;
d2789 1
a2789 1
    I32 elem = POPi;
d2791 1
a2791 1
    U32 lval = PL_op->op_flags & OPf_MOD;
d2860 1
a2860 1
    djSP;
d2877 1
a2877 1
    djSP;
d2900 3
d2916 2
a2917 2
	    if (!packname || 
		((*(U8*)packname >= 0xc0 && DO_UTF8(sv))
d2959 1
d2975 12
a2986 3
	Perl_croak(aTHX_
		   "Can't locate object method \"%s\" via package \"%s\"",
		   leaf, packname);
a2995 3
#ifdef DEBUGGING
    dTHR;
#endif /* DEBUGGING */
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d19 1
a24 6
#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif
d29 1
a29 19
static void
unset_cvowner(void *cvarg)
{
    register CV* cv = (CV *) cvarg;
#ifdef DEBUGGING
    dTHR;
#endif /* DEBUGGING */

    DEBUG_S((PerlIO_printf(PerlIO_stderr(), "%p unsetting CvOWNER of %p:%s\n",
			   thr, cv, SvPEEK((SV*)cv))));
    MUTEX_LOCK(CvMUTEXP(cv));
    DEBUG_S(if (CvDEPTH(cv) != 0)
		PerlIO_printf(PerlIO_stderr(), "depth %ld != 0\n",
			      CvDEPTH(cv)););
    assert(thr == CvOWNER(cv));
    CvOWNER(cv) = 0;
    MUTEX_UNLOCK(CvMUTEXP(cv));
    SvREFCNT_dec(cv);
}
d35 1
a35 1
    XPUSHs(cSVOP->op_sv);
d53 1
a53 1
	PUSHs(save_scalar(cGVOP->op_gv));
d55 1
a55 1
	PUSHs(GvSV(cGVOP->op_gv));
d64 6
d83 2
d92 1
a92 1
    XPUSHs((SV*)cGVOP->op_gv);
a109 1
    MAGIC *mg;
d126 1
a126 1
	RETURNOP(cCONDOP->op_true);
d128 1
a128 1
	RETURNOP(cCONDOP->op_false);
d149 1
d152 5
d166 15
a180 1
    if (SvOK(TARG))
d182 8
d215 1
d217 11
d245 2
a246 2
	croak(no_modify);
    if (SvIOK(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs) &&
d282 1
a282 1
    AV *av = GvAV((GV*)cSVOP->op_sv);
d337 1
a337 1
    if (mg = SvTIED_mg((SV*)gv, 'q')) {
d351 1
a351 1
	perl_call_method("PRINT", G_SCALAR);
d360 1
a360 1
	if (PL_dowarn) {
d362 3
a364 2
            gv_fullname3(sv, gv, Nullch);
            warn("Filehandle %s never opened", SvPV(sv,n_a));
a365 1

d370 10
a379 7
	if (PL_dowarn)  {
	    SV* sv = sv_newmortal();
            gv_fullname3(sv, gv, Nullch);
	    if (IoIFP(io))
		warn("Filehandle %s opened only for input", SvPV(sv,n_a));
	    else
		warn("print on closed filehandle %s", SvPV(sv,n_a));
d430 1
a430 1
    djSP; dPOPss;
d435 2
d439 1
a439 1
	    DIE("Not an ARRAY reference");
d441 1
a441 1
	    PUSHs((SV*)av);
d449 1
a449 1
		PUSHs((SV*)av);
d468 5
a472 4
			DIE(no_usym, "an ARRAY");
		    if (PL_dowarn)
			warn(warn_uninit);
		    if (GIMME == G_ARRAY)
d474 2
a475 1
		    RETPUSHUNDEF;
d478 14
a491 4
		if (PL_op->op_private & HINT_STRICT_REFS)
		    DIE(no_symref, sym, "an ARRAY");
		gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PVAV);
	    } else {
d498 1
a498 1
		PUSHs((SV*)av);
d506 1
d523 1
a523 1
	PUSHi(maxarg);
d535 2
d539 1
a539 1
	    DIE("Not a HASH reference");
d568 3
a570 3
			DIE(no_usym, "a HASH");
		    if (PL_dowarn)
			warn(warn_uninit);
d578 14
a591 4
		if (PL_op->op_private & HINT_STRICT_REFS)
		    DIE(no_symref, sym, "a HASH");
		gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PVHV);
	    } else {
d606 1
a606 1
	return do_kv(ARGS);
d613 2
a614 2
	    sv_setpvf(TARG, "%ld/%ld",
		      (long)HvFILL(hv), (long)HvMAX(hv) + 1);
d623 86
d734 5
a738 4
    if (PL_op->op_private & OPpASSIGN_COMMON) {
        for (relem = firstrelem; relem <= lastrelem; relem++) {
            /*SUPPRESS 560*/
            if (sv = *relem) {
d740 1
a740 1
                *relem = sv_mortalcopy(sv);
d742 1
a742 1
        }
d749 1
d757 13
a769 1
	    
d784 1
a784 1
			SvREFCNT_dec(sv);
d789 1
a789 1
	case SVt_PVHV: {
d811 1
a811 1
			    SvREFCNT_dec(tmpstr);
d816 1
a816 21
		    if (*relem) {
			HE *didstore;
			if (PL_dowarn) {
			    if (relem == firstrelem &&
				SvROK(*relem) &&
				( SvTYPE(SvRV(*relem)) == SVt_PVAV ||
				  SvTYPE(SvRV(*relem)) == SVt_PVHV ) )
				warn("Reference found where even-sized list expected");
			    else
				warn("Odd number of elements in hash assignment");
			}
			tmpstr = NEWSV(29,0);
			didstore = hv_store_ent(hash,*relem,tmpstr,0);
			if (magic) {
			    if (SvSMAGICAL(tmpstr))
				mg_set(tmpstr);
			    if (!didstore)
				SvREFCNT_dec(tmpstr);
			}
			TAINT_NOT;
		    }
d822 4
a825 10
	    if (SvTHINKFIRST(sv)) {
		if (SvREADONLY(sv) && PL_curcop != &PL_compiling) {
		    if (!SvIMMORTAL(sv))
			DIE(no_modify);
		    if (relem <= lastrelem)
			relem++;
		    break;
		}
		if (SvROK(sv))
		    sv_unref(sv);
d859 1
a859 1
		    DIE("No setreuid available");
d864 2
a865 2
	    PL_uid = (int)PerlProc_getuid();
	    PL_euid = (int)PerlProc_geteuid();
d888 1
a888 1
		    DIE("No setregid available");
d893 2
a894 2
	    PL_gid = (int)PerlProc_getgid();
	    PL_egid = (int)PerlProc_getegid();
d938 2
a939 2
    I32 safebase;
    char *truebase;
d947 1
a947 1
    SV *screamer;
d959 1
a959 1
	DIE("panic: do_match");
a976 4
    screamer = ( (SvSCREAM(TARG) && rx->check_substr
		  && SvTYPE(rx->check_substr) == SVt_PVBM
		  && SvVALID(rx->check_substr)) 
		? TARG : Nullsv);
d978 4
a981 2
    if (global = pm->op_pmflags & PMf_GLOBAL) {
	rx->startp[0] = 0;
d985 6
a990 1
		rx->endp[0] = rx->startp[0] = s + mg->mg_len; 
d996 6
a1001 3
    safebase = ((gimme != G_ARRAY && !global && rx->nparens)
		|| SvTEMP(TARG) || PL_sawampersand)
		? REXEC_COPY_STR : 0;
d1008 2
a1009 2
    if (global && rx->startp[0]) {
	t = s = rx->endp[0];
d1013 1
a1013 1
	    minmatch = (s == rx->startp[0]);
d1015 11
a1025 43
    if (rx->check_substr) {
	if (!(rx->reganch & ROPT_NOSCAN)) { /* Floating checkstring. */
	    if ( screamer ) {
		I32 p = -1;
		
		if (PL_screamfirst[BmRARE(rx->check_substr)] < 0)
		    goto nope;
		else if (!(s = screaminstr(TARG, rx->check_substr, 
					   rx->check_offset_min, 0, &p, 0)))
		    goto nope;
		else if ((rx->reganch & ROPT_CHECK_ALL)
			 && !PL_sawampersand && !SvTAIL(rx->check_substr))
		    goto yup;
	    }
	    else if (!(s = fbm_instr((unsigned char*)s + rx->check_offset_min,
				     (unsigned char*)strend, 
				     rx->check_substr, 0)))
		goto nope;
	    else if ((rx->reganch & ROPT_CHECK_ALL) && !PL_sawampersand)
		goto yup;
	    if (s && rx->check_offset_max < s - t) {
		++BmUSEFUL(rx->check_substr);
		s -= rx->check_offset_max;
	    }
	    else
		s = t;
	}
	/* Now checkstring is fixed, i.e. at fixed offset from the
	   beginning of match, and the match is anchored at s. */
	else if (!PL_multiline) {	/* Anchored near beginning of string. */
	    I32 slen;
	    if (*SvPVX(rx->check_substr) != s[rx->check_offset_min]
		|| ((slen = SvCUR(rx->check_substr)) > 1
		    && memNE(SvPVX(rx->check_substr), 
			     s + rx->check_offset_min, slen)))
		goto nope;
	}
	if (!rx->naughty && --BmUSEFUL(rx->check_substr) < 0
	    && rx->check_substr == rx->float_substr) {
	    SvREFCNT_dec(rx->check_substr);
	    rx->check_substr = Nullsv;	/* opt is being useless */
	    rx->float_substr = Nullsv;
	}
d1027 1
a1027 2
    if (CALLREGEXEC(rx, s, strend, truebase, minmatch,
		      screamer, NULL, safebase))
d1056 3
a1058 2
	    if ((s = rx->startp[i]) && rx->endp[i] ) {
		len = rx->endp[i] - s;
d1060 4
d1067 2
a1068 4
	    truebase = rx->subbeg;
	    strend = rx->subend;
	    if (rx->startp[0] && rx->startp[0] == rx->endp[0])
		++rx->endp[0];
d1070 1
d1087 2
a1088 2
	    if (rx->startp[0]) {
		mg->mg_len = rx->endp[0] - rx->subbeg;
d1099 1
a1099 1
yup:					/* Confirmed by check_substr */
a1102 1
    ++BmUSEFUL(rx->check_substr);
d1106 4
a1109 2
    Safefree(rx->subbase);
    rx->subbase = Nullch;
d1112 3
a1114 3
	rx->subend = strend;
	rx->startp[0] = s;
	rx->endp[0] = s + SvCUR(rx->check_substr);
d1116 1
a1116 1
    }
d1118 1
a1118 1
	char *tmps;
d1120 9
a1128 5
	tmps = rx->subbase = savepvn(t, strend-t);
	rx->subbeg = tmps;
	rx->subend = tmps + (strend-t);
	tmps = rx->startp[0] = tmps + (s - t);
	rx->endp[0] = tmps + SvCUR(rx->check_substr);
d1130 1
a1134 3
    if (rx->check_substr)
	++BmUSEFUL(rx->check_substr);

d1150 1
a1150 1
do_readline(void)
d1162 1
a1162 1
    if (mg = SvTIED_mg((SV*)PL_last_in_gv, 'q')) {
d1167 1
a1167 1
	perl_call_method("READLINE", gimme);
a1179 1
		    IoFLAGS(io) &= ~IOf_START;
d1182 1
a1192 1
		    IoFLAGS(io) |= IOf_START;
d1284 5
d1320 1
d1330 9
d1341 8
a1348 2
	if (PL_dowarn && io && !(IoFLAGS(io) & IOf_START))
	    warn("Read on closed filehandle <%s>", GvENAME(PL_last_in_gv));
d1374 1
a1374 1
/* flip-flop EOF state for a snarfed empty file */
d1376 3
a1378 4
    ((gimme != G_SCALAR || SvCUR(sv)					\
      || (IoFLAGS(io) & IOf_NOLINE) || IoLINES(io) || !RsSNARF(rs))	\
	? ((IoFLAGS(io) &= ~IOf_NOLINE), TRUE)				\
	: ((IoFLAGS(io) |= IOf_NOLINE), FALSE))
a1389 1
		IoFLAGS(io) |= IOf_START;
d1392 5
a1396 4
		if (!do_close(PL_last_in_gv, FALSE)) {
		    warn("glob failed (child exited with status %d%s)",
			 STATUS_CURRENT >> 8,
			 (STATUS_CURRENT & 0x80) ? ", core dumped" : "");
d1427 1
a1427 1
	    if (*tmps && PerlLIO_stat(SvPVX(sv), &PL_statbuf) < 0) {
d1490 1
a1490 1
	    DIE("Can't localize pseudo-hash element");
d1502 1
a1502 1
		DIE(no_helem, SvPV(keysv, n_a));
d1598 1
d1603 1
a1603 1
	DIE("panic: pp_iter");
d1605 1
d1616 1
a1616 3
		if (SvREFCNT(*cx->blk_loop.itervar) == 1
		    && !SvMAGICAL(*cx->blk_loop.itervar))
		{
d1618 1
a1618 1
		    sv_setsv(*cx->blk_loop.itervar, cur);
d1626 2
a1627 2
		    SvREFCNT_dec(*cx->blk_loop.itervar);
		    *cx->blk_loop.itervar = newSVsv(cur);
d1642 1
a1642 3
	if (SvREFCNT(*cx->blk_loop.itervar) == 1
	    && !SvMAGICAL(*cx->blk_loop.itervar))
	{
d1644 1
a1644 1
	    sv_setiv(*cx->blk_loop.itervar, cx->blk_loop.iterix++);
d1652 2
a1653 2
	    SvREFCNT_dec(*cx->blk_loop.itervar);
	    *cx->blk_loop.itervar = newSViv(cx->blk_loop.iterix++);
d1662 1
a1662 1
    SvREFCNT_dec(*cx->blk_loop.itervar);
d1664 3
a1666 3
    if (sv = (SvMAGICAL(av)) 
	    ? *av_fetch(av, ++cx->blk_loop.iterix, FALSE) 
	    : AvARRAY(av)[++cx->blk_loop.iterix])
d1686 1
a1686 1
	LvTARGLEN(lv) = (UV) -1;
d1690 1
a1690 1
    *cx->blk_loop.itervar = SvREFCNT_inc(sv);
d1712 1
a1712 1
    I32 safebase;
a1716 2
    I32 update_minmatch = 1;
    SV *screamer;
d1729 1
a1729 1
	croak(no_modify);
d1743 1
a1743 1
	DIE("panic: do_subst");
d1754 1
a1754 5
    screamer = ( (SvSCREAM(TARG) && rx->check_substr
		  && SvTYPE(rx->check_substr) == SVt_PVBM
		  && SvVALID(rx->check_substr)) 
		? TARG : Nullsv);
    safebase = (rx->nparens || SvTEMP(TARG) || PL_sawampersand)
d1756 2
d1763 13
a1775 37
    if (rx->check_substr) {
	if (!(rx->reganch & ROPT_NOSCAN)) { /* It floats. */
	    if (screamer) {
		I32 p = -1;
		
		if (PL_screamfirst[BmRARE(rx->check_substr)] < 0)
		    goto nope;
		else if (!(s = screaminstr(TARG, rx->check_substr, rx->check_offset_min, 0, &p, 0)))
		    goto nope;
	    }
	    else if (!(s = fbm_instr((unsigned char*)s + rx->check_offset_min, 
				     (unsigned char*)strend,
				     rx->check_substr, 0)))
		goto nope;
	    if (s && rx->check_offset_max < s - m) {
		++BmUSEFUL(rx->check_substr);
		s -= rx->check_offset_max;
	    }
	    else
		s = m;
	}
	/* Now checkstring is fixed, i.e. at fixed offset from the
	   beginning of match, and the match is anchored at s. */
	else if (!PL_multiline) { /* Anchored at beginning of string. */
	    I32 slen;
	    if (*SvPVX(rx->check_substr) != s[rx->check_offset_min]
		|| ((slen = SvCUR(rx->check_substr)) > 1
		    && memNE(SvPVX(rx->check_substr), 
			     s + rx->check_offset_min, slen)))
		goto nope;
	}
	if (!rx->naughty && --BmUSEFUL(rx->check_substr) < 0
	    && rx->check_substr == rx->float_substr) {
	    SvREFCNT_dec(rx->check_substr);
	    rx->check_substr = Nullsv;	/* opt is being useless */
	    rx->float_substr = Nullsv;
	}
d1785 1
a1785 1
    if (c && clen <= rx->minlen && (once || !(safebase & REXEC_COPY_STR))
d1787 3
a1789 1
	if (!CALLREGEXEC(rx, s, strend, orig, 0, screamer, NULL, safebase)) {
d1805 2
a1806 7
	    if (rx->subbase) {
		m = orig + (rx->startp[0] - rx->subbase);
		d = orig + (rx->endp[0] - rx->subbase);
	    } else {
		m = rx->startp[0];
		d = rx->endp[0];
	    }
d1822 1
a1822 1
	    else if (i = m - s) {	/* faster from front */
d1847 1
a1847 1
		    DIE("Substitution loop");
d1849 1
a1849 1
		m = rx->startp[0];
d1851 1
a1851 1
		if (i = m - s) {
d1860 5
a1864 3
		s = rx->endp[0];
	    } while (CALLREGEXEC(rx, s, strend, orig, s == m,
			      Nullsv, NULL, 0)); /* don't match same null twice */
d1886 3
a1888 1
    if (CALLREGEXEC(rx, s, strend, orig, 0, screamer, NULL, safebase)) {
d1904 1
d1907 1
a1907 1
		DIE("Substitution loop");
d1909 1
a1909 1
	    if (rx->subbase && rx->subbase != orig) {
d1912 1
a1912 1
		orig = rx->subbase;
d1916 1
a1916 1
	    m = rx->startp[0];
d1918 1
a1918 1
	    s = rx->endp[0];
d1923 1
a1923 1
	} while (CALLREGEXEC(rx, s, strend, orig, s == m, Nullsv, NULL, safebase));
a1947 2
    ++BmUSEFUL(rx->check_substr);

d1986 1
a1986 1
	SAVESPTR(PL_curpm);
d2004 1
a2004 1
    struct block_sub cxsub;
a2006 1
    POPSUB1(cx);	/* Delay POPSUB2 until stack values are safe */
d2012 1
a2012 1
	    if (cxsub.cv && CvDEPTH(cxsub.cv) > 1) {
d2017 3
a2019 1
		} else {
d2021 2
a2022 1
		    *MARK = sv_mortalcopy(TOPs);
d2024 2
a2025 1
	    } else
d2027 2
a2028 1
	} else {
d2044 154
a2197 1
    POPSUB2();		/* Stack values are safe: release CV and @@_ ... */
d2201 1
d2205 1
d2207 1
a2207 1
get_db_sub(SV **svp, CV *cv)
d2230 2
a2231 2
	SvUPGRADE(dbsv, SVt_PVIV);
	SvIOK_on(dbsv);
d2233 1
a2233 1
	SvIVX(dbsv) = (IV)cv;		/* Do it the quickest way  */
d2253 1
a2253 1
	DIE("Not a CODE reference");
d2272 1
a2272 1
		DIE(no_usym, "a subroutine");
d2274 2
a2275 2
		DIE(no_symref, sym, "a subroutine");
	    cv = perl_get_cv(sym, TRUE);
d2278 4
d2288 1
a2288 1
	DIE("Not a CODE reference");
d2294 6
a2299 1
	    cv = sv_2cv(sv, &stash, &gv, TRUE);
a2306 3
    if (!cv)
	DIE("Not a CODE reference");

d2313 2
a2314 1
	    DIE("Undefined subroutine called");
a2317 1
	    goto retry;
d2320 3
a2322 1
	if ((autogv = gv_autoload4(GvSTASH(gv), GvNAME(gv), GvNAMELEN(gv),
d2324 9
a2332 3
	{
	    cv = GvCV(autogv);
	    goto retry;
d2334 3
a2336 4
	/* sorry */
	sub_name = sv_newmortal();
	gv_efullname3(sub_name, gv, Nullch);
	DIE("Undefined subroutine &%s called", SvPVX(sub_name));
d2340 1
a2340 1
    if ((PL_op->op_private & OPpENTERSUB_DB) && GvCV(PL_DBsub) && !CvNODEBUG(cv))
d2342 3
a2344 2
    if (!cv)
	DIE("No DBsub routine");
d2361 7
a2367 2
		MUTEX_UNLOCK(CvMUTEXP(cv));
		croak("no argument for locked method call");
d2389 1
a2389 1
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(), "%p: pp_entersub lock %p\n",
d2392 1
a2392 1
	    save_destructor(unlock_condpair, sv);
d2431 1
a2431 1
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
d2437 1
a2437 1
		SAVEDESTRUCTOR(unset_cvowner, (void*) cv);
d2445 1
a2445 1
		DEBUG_S(PerlIO_printf(PerlIO_stderr(),
d2449 2
a2450 1
	    } else {
d2455 1
a2455 1
		DEBUG_S((PerlIO_printf(PerlIO_stderr(),
d2473 1
a2473 1
			PerlIO_printf(PerlIO_stderr(), "depth %ld != 0\n",
d2475 1
a2475 1
	    SAVEDESTRUCTOR(unset_cvowner, (void*) cv);
d2481 1
d2483 1
a2483 1
	    I32 (*fp3)_((int,int,int));
d2492 1
a2492 1
	    fp3 = (I32(*)_((int,int,int)))CvXSUB(cv);
d2498 3
a2500 1
	else {
d2526 3
a2528 4
	    if (PL_curcopdb) {		/* We assume that the first
					   XSUB in &DB::sub is the
					   called one. */
		SAVESPTR(PL_curcop);
d2533 1
a2533 1
	    (void)(*CvXSUB(cv))(cv _PERL_OBJECT_THIS);
d2564 1
d2570 1
d2573 1
a2573 1
		    if (svp[ix] != &PL_sv_undef) {
d2590 3
d2621 1
a2621 1
	SAVESPTR(PL_curpad);
d2631 1
a2631 1
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
d2636 2
d2640 1
d2675 1
a2675 1
	if (CvDEPTH(cv) == 100 && PL_dowarn
d2679 1
a2679 1
	DEBUG_S(PerlIO_printf(PerlIO_stderr(),
d2687 1
a2687 1
sub_crush_depth(CV *cv)
d2690 1
a2690 1
	warn("Deep recursion on anonymous subroutine");
d2694 2
a2695 1
	warn("Deep recursion on subroutine \"%s\"", SvPVX(tmpstr));
d2718 1
a2718 1
		DIE(no_aelem, elem);
d2742 1
a2742 1
vivify_ref(SV *sv, U32 to_what)
d2748 1
a2748 1
	    croak(no_modify);
d2775 27
d2807 1
d2811 2
a2812 7
    if (SvROK(TOPs)) {
	sv = SvRV(TOPs);
	if (SvTYPE(sv) == SVt_PVCV) {
	    SETs(sv);
	    RETURN;
	}
    }
a2813 3
    name = SvPV(TOPs, packlen);
    sv = *(PL_stack_base + TOPMARK + 1);
    
d2827 10
a2836 4
	    if (!packname || !isIDFIRST(*packname))
		DIE("Can't call method \"%s\" %s", name,
		    SvOK(sv)? "without a package or object reference"
			    : "on an undefined value");
d2843 7
a2849 2
    if (!ob || !SvOBJECT(ob))
	DIE("Can't call method \"%s\" on unblessed reference", name);
d2854 11
d2878 1
a2878 1
	    packname = HvNAME(sep ? PL_curcop->cop_stash : stash);
d2885 3
a2887 2
	DIE("Can't locate object method \"%s\" via package \"%.*s\"",
	    leaf, (int)packlen, packname);
d2889 1
a2889 2
    SETs(isGV(gv) ? (SV*)GvCV(gv) : (SV*)gv);
    RETURN;
d2892 21
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d21 10
d33 22
d57 1
a57 1
    dSP;
d64 1
a64 1
    curcop = (COP*)op;
d66 1
a66 1
    stack_sp = stack_base + cxstack[cxstack_ix].blk_oldsp;
d73 3
a75 3
    dSP;
    EXTEND(sp,1);
    if (op->op_private & OPpLVAL_INTRO)
d89 1
a89 1
    PUSHMARK(stack_sp);
d95 1
a95 1
    dSP; dTARGET;
d106 1
a106 1
    dSP;
d113 1
a113 1
    dSP;
d124 1
a124 1
    dSP; dPOPTOPssrl;
d127 1
a127 1
    if (op->op_private & OPpASSIGN_BACKWARDS) {
d131 1
a131 1
    if (tainting && tainted && !SvTAINTED(left))
d140 1
a140 1
    dSP;
d151 1
a151 1
    stack_sp = stack_base + cxstack[cxstack_ix].blk_oldsp;
d153 1
a153 1
    oldsave = scopestack[scopestack_ix - 1];
d160 1
a160 1
  dSP; dATARGET; tryAMAGICbin(concat,opASSIGN);
d187 1
a187 1
    dSP; dTARGET;
d189 8
a196 5
    if (op->op_flags & OPf_MOD) {
	if (op->op_private & OPpLVAL_INTRO)
	    SAVECLEARSV(curpad[op->op_targ]);
        else if (op->op_private & OPpDEREF)
	    vivify_ref(curpad[op->op_targ], op->op_private & OPpDEREF);
d203 1
a203 1
    last_in_gv = (GV*)(*stack_sp--);
d209 1
a209 1
    dSP; tryAMAGICbinSET(eq,0); 
d219 1
a219 1
    dSP;
d236 1
a236 1
    dSP;
d247 1
a247 1
    dSP; dATARGET; tryAMAGICbin(add,opASSIGN); 
d257 1
a257 1
    dSP;
d259 7
a265 2
    SV** svp = av_fetch(av, op->op_private, op->op_flags & OPf_MOD);
    PUSHs(svp ? *svp : &sv_undef);
d271 1
a271 1
    dSP; dMARK; dTARGET;
d281 1
a281 1
    dSP;
d290 1
a290 1
    Copy(&op, &LvTARGOFF(sv), 1, OP*);
d293 1
a293 1
    XPUSHs((SV*)op);
d302 1
a302 1
    dSP; dMARK; dORIGMARK;
d307 1
d309 1
a309 1
    if (op->op_flags & OPf_STACKED)
d312 2
a313 2
	gv = defoutgv;
    if (SvMAGICAL(gv) && (mg = mg_find((SV*)gv, 'q'))) {
d315 4
a318 1
	    EXTEND(SP, 1);
d324 1
a324 1
	*MARK = mg->mg_obj;
d336 1
a336 1
	if (dowarn) {
d339 1
a339 1
            warn("Filehandle %s never opened", SvPV(sv,na));
d346 1
a346 1
	if (dowarn)  {
d350 1
a350 1
		warn("Filehandle %s opened only for input", SvPV(sv,na));
d352 1
a352 1
		warn("print on closed filehandle %s", SvPV(sv,na));
d359 1
a359 1
	if (ofslen) {
d365 1
a365 1
		    if (PerlIO_write(fp, ofs, ofslen) == 0 || PerlIO_error(fp)) {
d382 2
a383 2
	    if (orslen)
		if (PerlIO_write(fp, ors, orslen) == 0 || PerlIO_error(fp))
d392 1
a392 1
    PUSHs(&sv_yes);
d397 1
a397 1
    PUSHs(&sv_undef);
d403 1
a403 1
    dSP; dPOPss;
d411 1
a411 1
	if (op->op_flags & OPf_REF) {
d419 1
a419 1
	    if (op->op_flags & OPf_REF) {
d429 1
d437 2
a438 2
		    if (op->op_flags & OPf_REF ||
		      op->op_private & HINT_STRICT_REFS)
d440 1
a440 1
		    if (dowarn)
d446 2
a447 2
		sym = SvPV(sv,na);
		if (op->op_private & HINT_STRICT_REFS)
d454 1
a454 1
	    if (op->op_private & OPpLVAL_INTRO)
d456 1
a456 1
	    if (op->op_flags & OPf_REF) {
d465 11
a475 2
	EXTEND(SP, maxarg);
	Copy(AvARRAY(av), SP+1, maxarg, SV*);
d488 1
a488 1
    dSP; dTOPss;
d494 1
a494 1
	if (SvTYPE(hv) != SVt_PVHV)
d496 1
a496 1
	if (op->op_flags & OPf_REF) {
d502 1
a502 1
	if (SvTYPE(sv) == SVt_PVHV) {
d504 1
a504 1
	    if (op->op_flags & OPf_REF) {
d514 1
d522 2
a523 2
		    if (op->op_flags & OPf_REF ||
		      op->op_private & HINT_STRICT_REFS)
d525 1
a525 1
		    if (dowarn)
d533 2
a534 2
		sym = SvPV(sv,na);
		if (op->op_private & HINT_STRICT_REFS)
d541 1
a541 1
	    if (op->op_private & OPpLVAL_INTRO)
d543 1
a543 1
	    if (op->op_flags & OPf_REF) {
d551 1
a551 1
	*stack_sp = (SV*)hv;
d556 2
d563 1
d571 4
a574 4
    dSP;
    SV **lastlelem = stack_sp;
    SV **lastrelem = stack_base + POPMARK;
    SV **firstrelem = stack_base + POPMARK + 1;
d588 1
a588 1
    delaymagic = DM_DELAY;		/* catch simultaneous items */
d594 1
a594 1
    if (op->op_private & OPpASSIGN_COMMON) {
a642 1
		    STRLEN len;
d647 1
a647 1
			sv = &sv_no, relem++;
d661 24
a684 2
		if (relem == lastrelem && dowarn)
		    warn("Odd number of elements in hash list");
d689 2
a690 2
		if (SvREADONLY(sv) && curcop != &compiling) {
		    if (sv != &sv_undef && sv != &sv_yes && sv != &sv_no)
d704 1
a704 1
		sv_setsv(sv, &sv_undef);
d709 2
a710 2
    if (delaymagic & ~DM_DELAY) {
	if (delaymagic & DM_UID) {
d712 1
a712 1
	    (void)setresuid(uid,euid,(Uid_t)-1);
d715 1
a715 1
	    (void)setreuid(uid,euid);
d718 3
a720 3
	    if ((delaymagic & DM_UID) == DM_RUID) {
		(void)setruid(uid);
		delaymagic &= ~DM_RUID;
d724 3
a726 3
	    if ((delaymagic & DM_UID) == DM_EUID) {
		(void)seteuid(uid);
		delaymagic &= ~DM_EUID;
d729 2
a730 2
	    if (delaymagic & DM_UID) {
		if (uid != euid)
d732 1
a732 1
		(void)setuid(uid);
d736 2
a737 2
	    uid = (int)getuid();
	    euid = (int)geteuid();
d739 1
a739 1
	if (delaymagic & DM_GID) {
d741 1
a741 1
	    (void)setresgid(gid,egid,(Gid_t)-1);
d744 1
a744 1
	    (void)setregid(gid,egid);
d747 3
a749 3
	    if ((delaymagic & DM_GID) == DM_RGID) {
		(void)setrgid(gid);
		delaymagic &= ~DM_RGID;
d753 3
a755 3
	    if ((delaymagic & DM_GID) == DM_EGID) {
		(void)setegid(gid);
		delaymagic &= ~DM_EGID;
d758 2
a759 2
	    if (delaymagic & DM_GID) {
		if (gid != egid)
d761 1
a761 1
		(void)setgid(gid);
d765 2
a766 2
	    gid = (int)getgid();
	    egid = (int)getegid();
d768 1
a768 1
	tainting |= (uid && (euid != uid || egid != gid));
d770 1
a770 1
    delaymagic = 0;
d787 1
a787 1
	    *relem++ = (lelem <= lastlelem) ? *lelem++ : &sv_undef;
d792 10
d804 1
a804 1
    dSP; dTARG;
d813 1
d817 1
a817 1
    I32 oldsave = savestack_ix;
d819 1
d821 1
a821 1
    if (op->op_flags & OPf_STACKED)
d824 1
a824 1
	TARG = GvSV(defgv);
d827 1
d832 2
d836 2
a837 1
    if (pm->op_pmflags & PMf_USED) {
d843 2
a844 2
    if (!rx->prelen && curpm) {
	pm = curpm;
d847 6
d865 3
a867 4
    if (!rx->nparens && !global)
	gimme = G_SCALAR;			/* accidental array context? */
    safebase = (((gimme == G_ARRAY) || global || !rx->nparens)
		&& !sawampersand);
d869 2
a870 2
	SAVEINT(multiline);
	multiline = pm->op_pmflags & PMf_MULTILINE;
d881 6
a886 4
    if (pm->op_pmshort) {
	if (pm->op_pmflags & PMf_SCANFIRST) {
	    if (SvSCREAM(TARG)) {
		if (screamfirst[BmRARE(pm->op_pmshort)] < 0)
d888 2
a889 1
		else if (!(s = screaminstr(TARG, pm->op_pmshort)))
d891 2
a892 1
		else if (pm->op_pmflags & PMf_ALL)
d895 3
a897 2
	    else if (!(s = fbm_instr((unsigned char*)s,
	      (unsigned char*)strend, pm->op_pmshort)))
d899 1
a899 1
	    else if (pm->op_pmflags & PMf_ALL)
d901 3
a903 5
	    if (s && rx->regback >= 0) {
		++BmUSEFUL(pm->op_pmshort);
		s -= rx->regback;
		if (s < t)
		    s = t;
d908 8
a915 4
	else if (!multiline) {
	    if (*SvPVX(pm->op_pmshort) != *s
		|| (pm->op_pmslen > 1
		    && memNE(SvPVX(pm->op_pmshort), s, pm->op_pmslen)))
d918 5
a922 3
	if (!rx->naughty && --BmUSEFUL(pm->op_pmshort) < 0) {
	    SvREFCNT_dec(pm->op_pmshort);
	    pm->op_pmshort = Nullsv;	/* opt is being useless */
d925 2
a926 2
    if (pregexec(rx, s, strend, truebase, minmatch,
		 SvSCREAM(TARG) ? TARG : Nullsv, safebase))
d928 1
a928 1
	curpm = pm;
d930 1
a930 1
	    pm->op_pmflags |= PMf_USED;
d938 3
a940 1
    TAINT_IF(rx->exec_tainted);
d949 1
d965 1
d968 2
d994 6
a999 4
yup:
    TAINT_IF(rx->exec_tainted);
    ++BmUSEFUL(pm->op_pmshort);
    curpm = pm;
d1001 1
a1001 1
	pm->op_pmflags |= PMf_USED;
d1008 1
a1008 1
	rx->endp[0] = s + SvCUR(pm->op_pmshort);
d1011 1
a1011 1
    if (sawampersand) {
d1018 1
a1018 1
	rx->endp[0] = tmps + SvCUR(pm->op_pmshort);
d1024 2
a1025 2
    if (pm->op_pmshort)
	++BmUSEFUL(pm->op_pmshort);
d1042 1
a1042 1
do_readline()
d1049 2
a1050 2
    register IO *io = GvIO(last_in_gv);
    register I32 type = op->op_type;
d1054 1
a1054 1
    if (SvMAGICAL(last_in_gv) && (mg = mg_find((SV*)last_in_gv, 'q'))) {
d1056 1
a1056 1
	XPUSHs(mg->mg_obj);
d1074 6
a1079 3
		    if (av_len(GvAVn(last_in_gv)) < 0) {
			SV *tmpstr = newSVpv("-", 1); /* assume stdin */
			av_push(GvAVn(last_in_gv), tmpstr);
d1082 1
a1082 1
		fp = nextargv(last_in_gv);
d1084 1
a1084 1
		    (void)do_close(last_in_gv, FALSE); /* now it does*/
d1118 1
a1118 1
		    strcat(tmpfnam,tmpnam(NULL));
d1136 4
a1139 1
		        ok = ((wilddsc.dsc$a_pointer = tovmsspec(SvPVX(tmpglob),vmsspec)) != NULL);
d1183 4
d1190 1
d1194 1
a1194 1
		sv_setpvn(tmpcmd, cshname, cshlen);
d1208 2
a1209 2
		(void)do_open(last_in_gv, SvPVX(tmpcmd), SvCUR(tmpcmd),
			      FALSE, 0, 0, Nullfp);
d1219 2
a1220 2
	if (dowarn && io && !(IoFLAGS(io) & IOf_START))
	    warn("Read on closed filehandle <%s>", GvENAME(last_in_gv));
d1227 1
d1245 8
d1254 3
a1256 1
	if (!sv_gets(sv, fp, offset)) {
d1259 1
a1259 1
		fp = nextargv(last_in_gv);
d1262 1
a1262 1
		(void)do_close(last_in_gv, FALSE);
d1266 5
a1270 2
		if (do_close(last_in_gv, FALSE) & ~0xFF)
		    warn("internal error: glob failed");
d1289 1
a1289 1
	    if (SvCUR(sv) > 0 && SvCUR(rs) > 0) {
d1291 1
a1291 1
		if (*tmps == *SvPVX(rs)) {
d1300 1
a1300 1
	    if (*tmps && Stat(SvPVX(sv), &statbuf) < 0) {
d1327 3
a1329 3
    dSP;
    register CONTEXT *cx;
    I32 gimme = OP_GIMME(op, -1);
d1341 1
a1341 1
    PUSHBLOCK(cx, CXt_BLOCK, sp);
d1348 1
a1348 1
    dSP;
d1350 1
d1353 14
a1366 4
    U32 lval = op->op_flags & OPf_MOD;
    U32 defer = op->op_private & OPpLVAL_DEFER;

    if (SvTYPE(hv) != SVt_PVHV)
d1368 1
a1368 1
    he = hv_fetch_ent(hv, keysv, lval && !defer, 0);
d1370 1
a1370 1
	if (!he || HeVAL(he) == &sv_undef) {
d1373 4
a1376 2
	    if (!defer)
		DIE(no_helem, SvPV(keysv, na));
d1387 3
a1389 3
	if (op->op_private & OPpLVAL_INTRO) {
	    if (HvNAME(hv) && isGV(HeVAL(he)))
		save_gp((GV*)HeVAL(he), !(op->op_flags & OPf_SPECIAL));
d1391 1
a1391 1
		save_svref(&HeVAL(he));
d1393 2
a1394 2
	else if (op->op_private & OPpDEREF)
	    vivify_ref(HeVAL(he), op->op_private & OPpDEREF);
d1396 10
a1405 1
    PUSHs(he ? HeVAL(he) : &sv_undef);
d1411 2
a1412 2
    dSP;
    register CONTEXT *cx;
d1418 1
a1418 1
    if (op->op_flags & OPf_SPECIAL) {
d1420 1
a1420 1
	cx->blk_oldpm = curpm;	/* fake block should preserve $1 et al */
d1425 1
a1425 1
    gimme = OP_GIMME(op, -1);
d1445 1
a1445 1
	    *MARK = &sv_undef;
d1458 1
a1458 1
    curpm = newpm;	/* Don't pop $1 et al till now */
d1467 2
a1468 2
    dSP;
    register CONTEXT *cx;
d1472 1
a1472 1
    EXTEND(sp, 1);
d1474 1
a1474 1
    if (cx->cx_type != CXt_LOOP)
d1478 57
a1534 1
    if (cx->blk_loop.iterix >= (av == curstack ? cx->blk_oldsp : AvFILL(av)))
d1539 3
a1541 1
    if (sv = AvARRAY(av)[++cx->blk_loop.iterix])
d1544 2
a1545 2
	sv = &sv_undef;
    if (av != curstack && SvIMMORTAL(sv)) {
d1561 1
a1561 1
	LvTARGLEN(lv) = -1;
d1571 1
a1571 1
    dSP; dTARG;
d1591 3
a1593 1
    I32 oldsave = savestack_ix;
d1597 1
a1597 1
    if (op->op_flags & OPf_STACKED)
d1600 1
a1600 1
	TARG = GvSV(defgv);
d1602 1
a1602 1
    }
d1607 2
d1612 4
d1623 3
a1625 1
    maxiters = (strend - s) + 10;
d1627 2
a1628 2
    if (!rx->prelen && curpm) {
	pm = curpm;
d1631 6
a1636 1
    safebase = (!rx->nparens && !sawampersand);
d1638 2
a1639 2
	SAVEINT(multiline);
	multiline = pm->op_pmflags & PMf_MULTILINE;
d1642 6
a1647 4
    if (pm->op_pmshort) {
	if (pm->op_pmflags & PMf_SCANFIRST) {
	    if (SvSCREAM(TARG)) {
		if (screamfirst[BmRARE(pm->op_pmshort)] < 0)
d1649 1
a1649 1
		else if (!(s = screaminstr(TARG, pm->op_pmshort)))
d1652 3
a1654 2
	    else if (!(s = fbm_instr((unsigned char*)s, (unsigned char*)strend,
	      pm->op_pmshort)))
d1656 3
a1658 5
	    if (s && rx->regback >= 0) {
		++BmUSEFUL(pm->op_pmshort);
		s -= rx->regback;
		if (s < m)
		    s = m;
d1663 8
a1670 4
	else if (!multiline) {
	    if (*SvPVX(pm->op_pmshort) != *s
		|| (pm->op_pmslen > 1
		    && memNE(SvPVX(pm->op_pmshort), s, pm->op_pmslen)))
d1673 5
a1677 3
	if (!rx->naughty && --BmUSEFUL(pm->op_pmshort) < 0) {
	    SvREFCNT_dec(pm->op_pmshort);
	    pm->op_pmshort = Nullsv;	/* opt is being useless */
d1688 5
a1692 4
    if (c && clen <= rx->minlen && safebase) {
	if (! pregexec(rx, s, strend, orig, 0,
		       SvSCREAM(TARG) ? TARG : Nullsv, safebase)) {
	    PUSHs(&sv_no);
d1702 1
a1702 1
	curpm = pm;
d1705 8
a1712 3
	    rxtainted = rx->exec_tainted;
	    m = rx->startp[0];
	    d = rx->endp[0];
d1746 3
a1748 2
	    TAINT_IF(rxtainted);
	    PUSHs(&sv_yes);
a1750 1
	    rxtainted = 0;
d1754 1
a1754 1
		rxtainted |= rx->exec_tainted;
d1767 2
a1768 2
	    } while (pregexec(rx, s, strend, orig, s == m,
			      Nullsv, TRUE)); /* don't match same null twice */
d1774 2
a1775 1
	    TAINT_IF(rxtainted);
d1779 6
a1784 1
	SvSETMAGIC(TARG);
d1790 1
a1790 2
    if (pregexec(rx, s, strend, orig, 0,
		 SvSCREAM(TARG) ? TARG : Nullsv, safebase)) {
d1796 2
a1797 2
	rxtainted = rx->exec_tainted;
	dstr = NEWSV(25, sv_len(TARG));
d1799 1
a1799 1
	curpm = pm;
d1801 2
a1802 1
	    register CONTEXT *cx;
d1809 1
a1809 1
	    rxtainted |= rx->exec_tainted;
d1824 1
a1824 1
	} while (pregexec(rx, s, strend, orig, s == m, Nullsv, safebase));
a1826 2
	TAINT_IF(rxtainted);

d1835 4
d1840 1
a1842 1
	PUSHs(sv_2mortal(newSViv((I32)iters)));
d1849 1
a1849 1
    ++BmUSEFUL(pm->op_pmshort);
d1851 3
a1853 2
ret_no:
    PUSHs(&sv_no);
d1860 1
a1860 1
    dSP;
d1863 2
a1864 2
	stack_base[markstack_ptr[-1]++] = stack_base[*markstack_ptr];
    ++*markstack_ptr;
d1868 1
a1868 1
    if (stack_base + *markstack_ptr > sp) {
d1874 1
a1874 1
	items = --*markstack_ptr - markstack_ptr[-1];
d1876 1
a1876 1
	SP = stack_base + POPMARK;		/* pop original mark */
d1889 1
a1889 1
	SAVESPTR(curpm);
d1891 1
a1891 1
	src = stack_base[*markstack_ptr];
d1893 1
a1893 1
	GvSV(defgv) = src;
d1901 1
a1901 1
    dSP;
d1906 1
a1906 1
    register CONTEXT *cx;
d1915 13
a1927 3
	if (MARK <= SP)
	    *MARK = SvTEMP(TOPs) ? TOPs : sv_mortalcopy(TOPs);
	else {
d1929 1
a1929 1
	    *MARK = &sv_undef;
d1944 1
a1944 1
    curpm = newpm;	/* ... and pop $1 et al */
d1950 36
d1988 1
a1988 1
    dSP; dPOPss;
d1992 1
a1992 1
    register CONTEXT *cx;
d1994 1
a1994 1
    bool hasargs = (op->op_flags & OPf_STACKED) != 0;
d2002 1
d2004 1
a2004 1
	    if (sv == &sv_yes) {		/* unfound import, ignore */
d2006 1
a2006 1
		    SP = stack_base + POPMARK;
d2014 1
a2014 1
		sym = SvPV(sv, na);
d2017 1
a2017 1
	    if (op->op_private & HINT_STRICT_REFS)
d2047 1
a2047 1
	SV* subname;
d2065 3
a2067 3
	subname = sv_newmortal();
	gv_efullname3(subname, gv, Nullch);
	DIE("Undefined subroutine &%s called", SvPVX(subname));
d2071 92
a2162 12
    if ((op->op_private & OPpENTERSUB_DB) && GvCV(DBsub) && !CvNODEBUG(cv)) {
	SV *oldsv = sv;
	sv = GvSV(DBsub);
	save_item(sv);
	gv = CvGV(cv);
	if ( (CvFLAGS(cv) & (CVf_ANON | CVf_CLONED))
	     || strEQ(GvNAME(gv), "END") 
	     || ((GvCV(gv) != cv) && /* Could be imported, and old sub redefined. */
		 !( (SvTYPE(oldsv) == SVt_PVGV) && (GvCV((GV*)oldsv) == cv)
		    && (gv = (GV*)oldsv) ))) { /* Use GV from the stack as a fallback. */
	    /* GV is potentially non-unique, or contain different CV. */
	    sv_setsv(sv, newRV((SV*)cv));
d2165 35
a2199 1
	    gv_efullname3(sv, gv, Nullch);
a2200 4
	cv = GvCV(DBsub);
	if (CvXSUB(cv)) curcopdb = curcop;
	if (!cv)
	    DIE("No DBsub routine");
d2202 1
d2210 3
a2212 3
	    while (sp > mark) {
		sp[1] = sp[0];
		sp--;
d2214 1
a2214 1
	    stack_sp = mark + 1;
d2217 1
a2217 1
			   MARK - stack_base + 1,
d2219 1
a2219 1
	    stack_sp = stack_base + items;
d2230 8
a2237 2
		AV* av = GvAV(defgv);
		I32 items = AvFILL(av) + 1;
d2241 3
a2243 3
		    EXTEND(sp, items);
		    Copy(AvARRAY(av), sp + 1, items, SV*);
		    sp += items;
d2247 1
a2247 1
	    if (curcopdb) {		/* We assume that the first
d2250 3
a2252 3
		SAVESPTR(curcop);
		curcop = curcopdb;
		curcopdb = NULL;
d2255 1
a2255 1
	    (void)(*CvXSUB(cv))(cv);
d2258 3
a2260 3
	    if (gimme == G_SCALAR && ++markix != stack_sp - stack_base ) {
		if (markix > stack_sp - stack_base)
		    *(stack_base + markix) = &sv_undef;
d2262 2
a2263 2
		    *(stack_base + markix) = *stack_sp;
		stack_sp = stack_base + markix;
d2274 1
a2274 1
	push_return(op->op_next);
d2278 5
d2286 1
a2286 4
	    if (CvDEPTH(cv) == 100 && dowarn 
		  && !(PERLDB_SUB && cv == GvCV(DBsub)))
		sub_crush_depth(cv);
	    if (CvDEPTH(cv) > AvFILL(padlist)) {
d2290 1
a2290 1
		I32 ix = AvFILL((AV*)svp[1]);
d2293 1
a2293 1
		    if (svp[ix] != &sv_undef) {
d2320 1
a2320 1
		AvFILL(padlist) = CvDEPTH(cv);
d2324 21
a2344 4
	SAVESPTR(curpad);
	curpad = AvARRAY((AV*)svp[CvDEPTH(cv)]);
	if (hasargs) {
	    AV* av = (AV*)curpad[0];
d2347 5
d2356 4
a2359 1
	    cx->blk_sub.savearray = GvAV(defgv);
a2360 1
	    GvAV(defgv) = (AV*)SvREFCNT_inc(av);
d2377 1
a2377 1
	    AvFILL(av) = items - 1;
d2385 11
d2401 1
a2401 2
sub_crush_depth(cv)
CV* cv;
d2414 1
a2414 1
    dSP;
d2418 3
a2420 2
    U32 lval = op->op_flags & OPf_MOD;
    U32 defer = (op->op_private & OPpLVAL_DEFER) && (elem > AvFILL(av));
d2423 1
a2423 1
	elem -= curcop->cop_arybase;
d2428 1
a2428 1
	if (!svp || *svp == &sv_undef) {
d2442 9
a2450 6
	if (op->op_private & OPpLVAL_INTRO)
	    save_svref(svp);
	else if (op->op_private & OPpDEREF)
	    vivify_ref(*svp, op->op_private & OPpDEREF);
    }
    PUSHs(svp ? *svp : &sv_undef);
d2455 1
a2455 3
vivify_ref(sv, to_what)
SV* sv;
U32 to_what;
d2471 1
a2471 1
	    SvRV(sv) = newSV(0);
d2487 1
a2487 1
    dSP;
d2504 2
a2505 2
    name = SvPV(TOPs, na);
    sv = *(stack_base + TOPMARK + 1);
d2521 3
a2523 1
  DIE("Can't call method \"%s\" without a package or object reference", name);
d2527 1
a2527 1
	*(stack_base + TOPMARK + 1) = sv_2mortal(newRV((SV*)iogv));
d2549 1
a2549 1
	    packname = HvNAME(sep ? curcop->cop_stash : stash);
d2562 1
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
a78 58
PP(pp_gelem)
{
    GV *gv;
    SV *sv;
    SV *ref;
    char *elem;
    dSP;

    sv = POPs;
    elem = SvPV(sv, na);
    gv = (GV*)POPs;
    ref = Nullsv;
    sv = Nullsv;
    switch (elem ? *elem : '\0')
    {
    case 'A':
	if (strEQ(elem, "ARRAY"))
	    ref = (SV*)GvAV(gv);
	break;
    case 'C':
	if (strEQ(elem, "CODE"))
	    ref = (SV*)GvCV(gv);
	break;
    case 'F':
	if (strEQ(elem, "FILEHANDLE"))
	    ref = (SV*)GvIOp(gv);
	break;
    case 'G':
	if (strEQ(elem, "GLOB"))
	    ref = (SV*)gv;
	break;
    case 'H':
	if (strEQ(elem, "HASH"))
	    ref = (SV*)GvHV(gv);
	break;
    case 'N':
	if (strEQ(elem, "NAME"))
	    sv = newSVpv(GvNAME(gv), GvNAMELEN(gv));
	break;
    case 'P':
	if (strEQ(elem, "PACKAGE"))
	    sv = newSVpv(HvNAME(GvSTASH(gv)), 0);
	break;
    case 'S':
	if (strEQ(elem, "SCALAR"))
	    ref = GvSV(gv);
	break;
    }
    if (ref)
	sv = newRV(ref);
    if (sv)
	sv_2mortal(sv);
    else
	sv = &sv_undef;
    XPUSHs(sv);
    RETURN;
}

d99 1
a99 3
    if (tainting && tainted && (!SvGMAGICAL(left) || !SvSMAGICAL(left) ||
				!((mg = mg_find(left, 't')) && mg->mg_len & 1)))
    {
d101 1
a101 3
    }
    SvSetSV(right, left);
    SvSETMAGIC(right);
a125 10
PP(pp_seq)
{
    dSP; tryAMAGICbinSET(seq,0); 
    {
      dPOPTOPssrl;
      SETs( sv_eq(left, right) ? &sv_yes : &sv_no );
      RETURN;
    }
}

d139 2
a140 1
    else if (!SvOK(TARG)) {
a141 1
	sv_setpv(TARG, "");	/* Suppress warning. */
d144 4
a147 1
    sv_catpvn(TARG,s,len);
d160 2
a161 2
        else if (op->op_private & (OPpDEREF_HV|OPpDEREF_AV))
	    provide_ref(op, curpad[op->op_targ]);
d177 1
a177 1
      SETs((TOPn == value) ? &sv_yes : &sv_no);
d185 5
a189 1
    if (SvIOK(TOPs)) {
d191 1
a191 1
	SvFLAGS(TOPs) &= ~(SVf_NOK|SVf_POK|SVp_NOK|SVp_POK);
d214 1
a214 1
      dPOPTOPnnrl;
d242 11
d254 1
d265 2
a266 1
    register FILE *fp;
d272 19
d294 1
a294 1
            gv_fullname(sv,gv);
d304 1
a304 1
            gv_fullname(sv,gv);
d321 1
a321 1
		    if (fwrite1(ofs, 1, ofslen, fp) == 0 || ferror(fp)) {
d339 1
a339 1
		if (fwrite1(ors, 1, orslen, fp) == 0 || ferror(fp))
d343 1
a343 1
		if (Fflush(fp) == EOF)
a359 1

a366 2
	if (op->op_private & OPpLVAL_INTRO)
	    av = (AV*)save_svref((SV**)sv);
d381 2
d395 2
d404 3
a406 1
		sv = (SV*)gv_fetchpv(sym, TRUE, SVt_PVAV);
d408 1
a408 1
	    av = GvAVn(sv);
d410 1
a410 1
		av = save_ary(sv);
a433 1

a434 1

a441 2
	if (op->op_private & OPpLVAL_INTRO)
	    hv = (HV*)save_svref((SV**)sv);
d456 2
d470 2
d481 3
a483 1
		sv = (SV*)gv_fetchpv(sym, TRUE, SVt_PVHV);
d485 1
a485 1
	    hv = GvHVn(sv);
d487 1
a487 1
		hv = save_hash(sv);
d501 3
a503 4
	if (HvFILL(hv)) {
	    sprintf(buf, "%d/%d", HvFILL(hv), HvMAX(hv)+1);
	    sv_setpv(TARG, buf);
	}
d525 1
d539 2
a540 1
            if (sv = *relem)
d542 1
d551 1
a551 1
	tainted = 0;		/* Each item stands on its own, taintwise. */
d559 1
d562 1
d567 8
a574 4
		(void)av_store(ary,i++,sv);
		if (magic)
		    mg_set(sv);
		tainted = 0;
a577 1
		char *tmps;
d586 1
a590 1
		    tmps = SvPV(sv, len);
d595 8
a602 4
		    (void)hv_store(hash,tmps,len,tmpstr,0);
		    if (magic)
			mg_set(tmpstr);
		    tainted = 0;
d604 2
d692 10
a701 1
    if (GIMME == G_ARRAY) {
d706 3
a708 8
	RETURN;
    }
    else {
	dTARGET;
	SP = firstrelem;
		
	SETi(lastrelem - firstrelem + 1);
	RETURN;
d710 1
d728 1
d740 1
d760 1
d766 2
a767 1
    safebase = (gimme == G_ARRAY) || global;
d776 1
a776 1
	if (s > strend)
d778 2
a779 1
	minmatch = (s == rx->startp[0]);
d806 4
a809 9
	    if (*SvPVX(pm->op_pmshort) != *s ||
	      bcmp(SvPVX(pm->op_pmshort), s, pm->op_pmslen) ) {
		if (pm->op_pmflags & PMf_FOLD) {
		    if (ibcmp((U8*)SvPVX(pm->op_pmshort), (U8*)s, pm->op_pmslen) )
			goto nope;
		}
		else
		    goto nope;
	    }
d817 2
a818 2
      SvSCREAM(TARG) ? TARG : Nullsv,
      safebase)) {
d829 1
d839 1
d850 1
d868 1
a868 1
		mg->mg_len = rx->endp[0] - truebase;
a873 2
	    else
		mg->mg_len = -1;
d880 1
d885 2
a896 2
	if (rx->subbase)
	    Safefree(rx->subbase);
d911 1
a911 1
    if (global) {
d931 1
a931 1
    FILE *fp;
d934 2
d937 12
d985 1
a985 1
		    FILE *tmpfp;
d1015 1
a1015 1
		    if ((tmpfp = fopen(tmpfnam,"w+","fop=dlt")) != NULL) {
d1025 1
a1025 1
		              if (isunix) trim_unixpath(rstr,SvPVX(tmpglob));
d1033 1
a1033 1
		            ok = (fputs(begin,tmpfp) != EOF);
d1042 1
a1042 1
		            fclose(tmpfp);
d1046 1
a1046 1
		           rewind(tmpfp);
d1049 1
d1055 5
d1063 3
a1065 2
#else
#ifdef CSH
d1079 1
a1079 1
#endif /* !MSDOS */
d1093 1
a1093 1
	if (GIMME == G_SCALAR) {
d1099 1
a1099 5
    if (GIMME == G_ARRAY) {
	sv = sv_2mortal(NEWSV(57, 80));
	offset = 0;
    }
    else {
d1101 2
d1112 4
d1118 1
a1118 1
	    clearerr(fp);
d1127 2
a1128 1
		(void)do_close(last_in_gv, FALSE);
d1130 1
a1130 1
	    if (GIMME == G_SCALAR) {
d1136 5
d1142 1
a1143 4
	if (tainting) {
	    tainted = TRUE;
	    SvTAINT(sv); /* Anything from the outside world...*/
	}
d1163 1
a1163 1
	if (GIMME == G_ARRAY) {
d1171 1
a1171 1
	else if (!tmplen && SvLEN(sv) - SvCUR(sv) > 80) {
d1187 1
a1187 1
    I32 gimme;
d1189 6
a1194 11
    /*
     * We don't just use the GIMME macro here because it assumes there's
     * already a context, which ain't necessarily so at initial startup.
     */

    if (op->op_flags & OPf_KNOW)
	gimme = op->op_flags & OPf_LIST;
    else if (cxstack_ix >= 0)
	gimme = cxstack[cxstack_ix].blk_gimme;
    else
	gimme = G_SCALAR;
d1207 1
a1207 1
    SV** svp;
a1208 2
    STRLEN keylen;
    char *key = SvPV(keysv, keylen);
d1210 2
a1211 1
    I32 lval = op->op_flags & OPf_MOD;
d1215 1
a1215 1
    svp = hv_fetch(hv, key, keylen, lval);
d1217 23
a1239 6
	if (!svp || *svp == &sv_undef)
	    DIE(no_helem, key);
	if (op->op_private & OPpLVAL_INTRO)
	    save_svref(svp);
	else if (op->op_private & (OPpDEREF_HV|OPpDEREF_AV))
	    provide_ref(op, *svp);
d1241 1
a1241 1
    PUSHs(svp ? *svp : &sv_undef);
d1261 7
a1267 6
    if (op->op_flags & OPf_KNOW)
	gimme = op->op_flags & OPf_LIST;
    else if (cxstack_ix >= 0)
	gimme = cxstack[cxstack_ix].blk_gimme;
    else
	gimme = G_SCALAR;
d1269 10
a1278 3
    if (gimme == G_SCALAR) {
	if (op->op_private & OPpLEAVE_VOID)
	    SP = newsp;
d1280 2
a1281 11
	    MARK = newsp + 1;
	    if (MARK <= SP)
		if (SvFLAGS(TOPs) & (SVs_PADTMP|SVs_TEMP))
		    *MARK = TOPs;
		else
		    *MARK = sv_mortalcopy(TOPs);
	    else {
		MEXTEND(mark,0);
		*MARK = &sv_undef;
	    }
	    SP = MARK;
d1283 1
d1285 4
a1288 3
    else {
	for (mark = newsp + 1; mark <= SP; mark++)
	    if (!(SvFLAGS(*mark) & (SVs_PADTMP|SVs_TEMP)))
d1290 3
a1292 1
		/* in case LEAVE wipes old return values */
d1305 1
a1305 1
    SV *sv;
d1312 1
d1314 1
a1314 1
    if (av == stack && cx->blk_loop.iterix >= cx->blk_oldsp)
d1317 1
a1317 2
    if (cx->blk_loop.iterix >= AvFILL(av))
	RETPUSHNO;
d1319 1
a1319 1
    if (sv = AvARRAY(av)[++cx->blk_loop.iterix]) {
d1321 20
a1340 1
	*cx->blk_loop.itervar = sv;
a1341 2
    else
	*cx->blk_loop.itervar = &sv_undef;
d1343 1
d1363 1
d1371 2
a1372 2
    if (pm->op_pmflags & PMf_CONST)	/* known replacement string? */
	dstr = POPs;
d1379 4
d1384 1
a1384 1
    if (!SvPOKp(TARG) || SvREADONLY(TARG) || (SvTYPE(TARG) == SVt_PVGV))
d1386 1
d1399 1
a1399 1
    safebase = ((!rx || !rx->nparens) && !sawampersand);
d1426 4
a1429 9
	    if (*SvPVX(pm->op_pmshort) != *s ||
	      bcmp(SvPVX(pm->op_pmshort), s, pm->op_pmslen) ) {
		if (pm->op_pmflags & PMf_FOLD) {
		    if (ibcmp((U8*)SvPVX(pm->op_pmshort), (U8*)s, pm->op_pmslen) )
			goto nope;
		}
		else
		    goto nope;
	    }
d1436 2
d1439 29
a1467 10
    if (rpm->op_pmflags & PMf_CONST) {	/* known replacement string? */
	c = SvPV(dstr, clen);
	if (clen <= rx->minlen) {
					/* can do inplace substitution */
	    if (pregexec(rx, s, strend, orig, 0,
	      SvSCREAM(TARG) ? TARG : Nullsv, safebase)) {
		if (force_on_match) {
		    force_on_match = 0;
		    s = SvPV_force(TARG, len);
		    goto force_it;
d1469 42
a1510 62
		if (rx->subbase) 	/* oops, no we can't */
		    goto long_way;
		d = s;
		curpm = pm;
		SvSCREAM_off(TARG);	/* disable possible screamer */
		if (once) {
		    m = rx->startp[0];
		    d = rx->endp[0];
		    s = orig;
		    if (m - s > strend - d) {	/* faster to shorten from end */
			if (clen) {
			    Copy(c, m, clen, char);
			    m += clen;
			}
			i = strend - d;
			if (i > 0) {
			    Move(d, m, i, char);
			    m += i;
			}
			*m = '\0';
			SvCUR_set(TARG, m - s);
			(void)SvPOK_only(TARG);
			SvSETMAGIC(TARG);
			PUSHs(&sv_yes);
			LEAVE_SCOPE(oldsave);
			RETURN;
		    }
		    /*SUPPRESS 560*/
		    else if (i = m - s) {	/* faster from front */
			d -= clen;
			m = d;
			sv_chop(TARG, d-i);
			s += i;
			while (i--)
			    *--d = *--s;
			if (clen)
			    Copy(c, m, clen, char);
			(void)SvPOK_only(TARG);
			SvSETMAGIC(TARG);
			PUSHs(&sv_yes);
			LEAVE_SCOPE(oldsave);
			RETURN;
		    }
		    else if (clen) {
			d -= clen;
			sv_chop(TARG, d);
			Copy(c, d, clen, char);
			(void)SvPOK_only(TARG);
			SvSETMAGIC(TARG);
			PUSHs(&sv_yes);
			LEAVE_SCOPE(oldsave);
			RETURN;
		    }
		    else {
			sv_chop(TARG, d);
			(void)SvPOK_only(TARG);
			SvSETMAGIC(TARG);
			PUSHs(&sv_yes);
			LEAVE_SCOPE(oldsave);
			RETURN;
		    }
		    /* NOTREACHED */
d1512 3
a1514 21
		do {
		    if (iters++ > maxiters)
			DIE("Substitution loop");
		    m = rx->startp[0];
		    /*SUPPRESS 560*/
		    if (i = m - s) {
			if (s != d)
			    Move(s, d, i, char);
			d += i;
		    }
		    if (clen) {
			Copy(c, d, clen, char);
			d += clen;
		    }
		    s = rx->endp[0];
		} while (pregexec(rx, s, strend, orig, s == m,
		    Nullsv, TRUE));	/* (don't match same null twice) */
		if (s != d) {
		    i = strend - s;
		    SvCUR_set(TARG, d - SvPVX(TARG) + i);
		    Move(s, d, i+1, char);		/* include the Null */
d1516 7
a1522 5
		(void)SvPOK_only(TARG);
		SvSETMAGIC(TARG);
		PUSHs(sv_2mortal(newSViv((I32)iters)));
		LEAVE_SCOPE(oldsave);
		RETURN;
d1524 2
a1525 3
	    PUSHs(&sv_no);
	    LEAVE_SCOPE(oldsave);
	    RETURN;
d1527 5
d1533 1
a1533 2
    else
	c = Nullch;
d1535 1
a1535 2
      SvSCREAM(TARG) ? TARG : Nullsv, safebase)) {
    long_way:
d1541 1
d1553 1
d1568 1
a1568 2
	} while (pregexec(rx, s, strend, orig, s == m, Nullsv,
	    safebase));
d1571 2
d1583 1
d1588 1
a1588 3
    PUSHs(&sv_no);
    LEAVE_SCOPE(oldsave);
    RETURN;
d1592 2
d1611 1
d1618 1
a1618 1
	if (GIMME != G_ARRAY) {
a1620 1
	    RETURN;
d1622 2
a1623 1
	SP += items;
d1648 1
d1651 3
a1653 2
    POPSUB(cx);

d1657 1
a1657 4
	    if (SvFLAGS(TOPs) & SVs_TEMP)
		*MARK = TOPs;
	    else
		*MARK = sv_mortalcopy(TOPs);
d1659 1
a1659 1
	    MEXTEND(mark,0);
d1664 7
a1670 5
    else {
	for (mark = newsp + 1; mark <= SP; mark++)
	    if (!(SvFLAGS(*mark) & SVs_TEMP))
		*mark = sv_mortalcopy(*mark);
		/* in case LEAVE wipes old return values */
d1672 4
a1675 8

    if (cx->blk_sub.hasargs) {		/* You don't exist; go away. */
	AV* av = cx->blk_sub.argarray;

	av_clear(av);
	AvREAL_off(av);
    }
    curpm = newpm;	/* Don't pop $1 et al till now */
a1677 1
    PUTBACK;
d1689 1
d1698 3
a1700 1
	    if (sv == &sv_yes)		/* unfound import, ignore */
d1702 8
a1709 1
	    if (!SvOK(sv))
a1710 1
	    sym = SvPV(sv,na);
d1727 1
a1727 1
	if (!(cv = GvCV((GV*)sv)))
d1740 17
a1756 23
	if (gv = CvGV(cv)) {
	    SV *tmpstr;
	    GV *ngv;
	    if (SvFAKE(cv) && GvCV(gv) != cv) {	/* autoloaded stub? */
		cv = GvCV(gv);
		if (SvTYPE(sv) == SVt_PVGV) {
		    SvREFCNT_dec(GvCV((GV*)sv));
		    GvCV((GV*)sv) = (CV*)SvREFCNT_inc((SV*)cv);
		}
		goto retry;
	    }
	    tmpstr = sv_newmortal();
	    gv_efullname(tmpstr, gv);
	    ngv = gv_fetchmethod(GvESTASH(gv), "AUTOLOAD");
	    if (ngv && ngv != gv && (cv = GvCV(ngv))) {	/* One more chance... */
		gv = ngv;
		sv_setsv(GvSV(CvGV(cv)), tmpstr);	/* Set CV's $AUTOLOAD */
		if (tainting)
		    sv_unmagic(GvSV(CvGV(cv)), 't');
		goto retry;
	    }
	    else
		DIE("Undefined subroutine &%s called",SvPVX(tmpstr));
d1758 4
a1761 1
	DIE("Undefined subroutine called");
d1764 3
a1766 2
    gimme = GIMME;
    if ((op->op_private & OPpENTERSUB_DB) && !CvXSUB(cv)) {
d1769 7
a1775 2
	if (CvFLAGS(cv) & (CVf_ANON | CVf_CLONED)) {
	    /* GV is potentially non-unique */
d1779 1
a1779 2
	    gv = CvGV(cv);
	    gv_efullname(sv,gv);
d1782 1
d1792 1
d1808 24
a1848 1
	I32 hasargs = (op->op_flags & OPf_STACKED) != 0;
d1858 3
a1860 2
	    if (CvDEPTH(cv) == 100 && dowarn)
		warn("Deep recursion on subroutine \"%s\"",GvENAME(CvGV(cv)));
d1870 4
a1873 3
			if (SvFLAGS(svp[ix]) & SVf_FAKE) { /* outer lexical? */
			    av_store(newpad, ix,
				SvREFCNT_inc(oldpad[ix]) );
d1911 1
a1911 1
	    GvAV(defgv) = cx->blk_sub.argarray;
d1940 13
d1958 3
a1960 2
    AV *av = (AV*)POPs;
    I32 lval = op->op_flags & OPf_MOD;
d1966 1
a1966 1
    svp = av_fetch(av, elem, lval);
d1968 14
a1981 2
	if (!svp || *svp == &sv_undef)
	    DIE(no_aelem, elem);
d1984 2
a1985 2
	else if (op->op_private & (OPpDEREF_HV|OPpDEREF_AV))
	    provide_ref(op, *svp);
d1992 1
a1992 2
provide_ref(op, sv)
OP* op;
d1994 1
d2001 18
a2018 3
	(void)SvUPGRADE(sv, SVt_RV);
	SvRV(sv) = (op->op_private & OPpDEREF_HV ?
		    (SV*)newHV() : (SV*)newAV());
d2030 12
a2041 1
    SV* nm;
d2043 1
a2043 1
    nm = TOPs;
a2045 1
    gv = 0;
a2051 1
	char* packname = 0;
d2053 1
d2055 1
a2055 1
	    !(packname = SvPV(sv, na)) ||
d2059 4
a2062 17
	    char *name = SvPV(nm, na);
	    HV *stash;
	    if (!packname || !isALPHA(*packname))
DIE("Can't call method \"%s\" without a package or object reference", name);
	    if (!(stash = gv_stashpv(packname, FALSE))) {
		if (gv_stashpv("UNIVERSAL", FALSE))
		    stash = gv_stashpv(packname, TRUE);
		else
		    DIE("Can't call method \"%s\" in empty package \"%s\"",
			name, packname);
	    }
	    gv = gv_fetchmethod(stash,name);
	    if (!gv)
		DIE("Can't locate object method \"%s\" via package \"%s\"",
		    name, packname);
	    SETs(gv);
	    RETURN;
d2064 1
a2064 1
	*(stack_base + TOPMARK + 1) = sv_2mortal(newRV(iogv));
d2067 1
a2067 2
    if (!ob || !SvOBJECT(ob)) {
	char *name = SvPV(nm, na);
a2068 1
    }
d2070 25
a2094 6
    if (!gv) {		/* nothing cached */
	char *name = SvPV(nm, na);
	gv = gv_fetchmethod(SvSTASH(ob),name);
	if (!gv)
	    DIE("Can't locate object method \"%s\" via package \"%s\"",
		name, HvNAME(SvSTASH(ob)));
d2096 1
a2096 2

    SETs(gv);
a2098 1

@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
a20 10
#ifdef I_UNISTD
#include <unistd.h>
#endif
#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif

a22 22
#ifdef USE_THREADS
static void
unset_cvowner(void *cvarg)
{
    register CV* cv = (CV *) cvarg;
#ifdef DEBUGGING
    dTHR;
#endif /* DEBUGGING */

    DEBUG_S((PerlIO_printf(PerlIO_stderr(), "%p unsetting CvOWNER of %p:%s\n",
			   thr, cv, SvPEEK((SV*)cv))));
    MUTEX_LOCK(CvMUTEXP(cv));
    DEBUG_S(if (CvDEPTH(cv) != 0)
		PerlIO_printf(PerlIO_stderr(), "depth %ld != 0\n",
			      CvDEPTH(cv)););
    assert(thr == CvOWNER(cv));
    CvOWNER(cv) = 0;
    MUTEX_UNLOCK(CvMUTEXP(cv));
    SvREFCNT_dec(cv);
}
#endif /* USE_THREADS */

d25 1
a25 1
    djSP;
d32 1
a32 1
    PL_curcop = (COP*)PL_op;
d34 1
a34 1
    PL_stack_sp = PL_stack_base + cxstack[cxstack_ix].blk_oldsp;
d41 3
a43 3
    djSP;
    EXTEND(SP,1);
    if (PL_op->op_private & OPpLVAL_INTRO)
d57 1
a57 1
    PUSHMARK(PL_stack_sp);
d63 1
a63 1
    djSP; dTARGET;
d74 1
a74 1
    djSP;
d79 58
d139 1
a139 1
    djSP;
d150 1
a150 1
    djSP; dPOPTOPssrl;
d153 1
a153 1
    if (PL_op->op_private & OPpASSIGN_BACKWARDS) {
d157 3
a159 1
    if (PL_tainting && PL_tainted && !SvTAINTED(left))
d161 3
a163 1
    SvSetMagicSV(right, left);
d170 1
a170 1
    djSP;
d181 1
a181 1
    PL_stack_sp = PL_stack_base + cxstack[cxstack_ix].blk_oldsp;
d183 1
a183 1
    oldsave = PL_scopestack[PL_scopestack_ix - 1];
d188 10
d200 1
a200 1
  djSP; dATARGET; tryAMAGICbin(concat,opASSIGN);
d211 2
a212 1
    else if (!SvOK(TARG) && SvTYPE(TARG) <= SVt_PVMG) {
a213 1
	s = SvPV_force(TARG, len);
d216 1
a216 4
    if (SvOK(TARG))
	sv_catpvn(TARG,s,len);
    else
	sv_setpvn(TARG,s,len);	/* suppress warning */
d224 1
a224 1
    djSP; dTARGET;
d226 5
a230 8
    if (PL_op->op_flags & OPf_MOD) {
	if (PL_op->op_private & OPpLVAL_INTRO)
	    SAVECLEARSV(PL_curpad[PL_op->op_targ]);
        else if (PL_op->op_private & OPpDEREF) {
	    PUTBACK;
	    vivify_ref(PL_curpad[PL_op->op_targ], PL_op->op_private & OPpDEREF);
	    SPAGAIN;
	}
d237 1
a237 1
    PL_last_in_gv = (GV*)(*PL_stack_sp--);
d243 1
a243 1
    djSP; tryAMAGICbinSET(eq,0); 
d246 1
a246 1
      SETs(boolSV(TOPn == value));
d253 2
a254 6
    djSP;
    if (SvREADONLY(TOPs) || SvTYPE(TOPs) > SVt_PVLV)
	croak(no_modify);
    if (SvIOK(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs) &&
    	SvIVX(TOPs) != IV_MAX)
    {
d256 1
a256 1
	SvFLAGS(TOPs) &= ~(SVp_NOK|SVp_POK);
d266 1
a266 1
    djSP;
d277 1
a277 1
    djSP; dATARGET; tryAMAGICbin(add,opASSIGN); 
d279 1
a279 1
      dPOPTOPnnrl_ul;
d287 1
a287 1
    djSP;
d289 2
a290 7
    U32 lval = PL_op->op_flags & OPf_MOD;
    SV** svp = av_fetch(av, PL_op->op_private, lval);
    SV *sv = (svp ? *svp : &PL_sv_undef);
    EXTEND(SP, 1);
    if (!lval && SvGMAGICAL(sv))	/* see note in pp_helem() */
	sv = sv_mortalcopy(sv);
    PUSHs(sv);
d296 1
a296 1
    djSP; dMARK; dTARGET;
d306 2
a307 14
    djSP;
#ifdef DEBUGGING
    /*
     * We ass_u_me that LvTARGOFF() comes first, and that two STRLENs
     * will be enough to hold an OP*.
     */
    SV* sv = sv_newmortal();
    sv_upgrade(sv, SVt_PVLV);
    LvTYPE(sv) = '/';
    Copy(&PL_op, &LvTARGOFF(sv), 1, OP*);
    XPUSHs(sv);
#else
    XPUSHs((SV*)PL_op);
#endif
d315 1
a315 1
    djSP; dMARK; dORIGMARK;
d318 1
a318 3
    register PerlIO *fp;
    MAGIC *mg;
    STRLEN n_a;
d320 1
a320 1
    if (PL_op->op_flags & OPf_STACKED)
d323 1
a323 23
	gv = PL_defoutgv;
    if (mg = SvTIED_mg((SV*)gv, 'q')) {
	if (MARK == ORIGMARK) {
	    /* If using default handle then we need to make space to 
	     * pass object as 1st arg, so move other args up ...
	     */
	    MEXTEND(SP, 1);
	    ++MARK;
	    Move(MARK, MARK + 1, (SP - MARK) + 1, SV*);
	    ++SP;
	}
	PUSHMARK(MARK - 1);
	*MARK = SvTIED_obj((SV*)gv, mg);
	PUTBACK;
	ENTER;
	perl_call_method("PRINT", G_SCALAR);
	LEAVE;
	SPAGAIN;
	MARK = ORIGMARK + 1;
	*MARK = *SP;
	SP = MARK;
	RETURN;
    }
d325 1
a325 1
	if (PL_dowarn) {
d327 2
a328 2
            gv_fullname3(sv, gv, Nullch);
            warn("Filehandle %s never opened", SvPV(sv,n_a));
d335 1
a335 1
	if (PL_dowarn)  {
d337 1
a337 1
            gv_fullname3(sv, gv, Nullch);
d339 1
a339 1
		warn("Filehandle %s opened only for input", SvPV(sv,n_a));
d341 1
a341 1
		warn("print on closed filehandle %s", SvPV(sv,n_a));
d348 1
a348 1
	if (PL_ofslen) {
d354 1
a354 1
		    if (PerlIO_write(fp, PL_ofs, PL_ofslen) == 0 || PerlIO_error(fp)) {
d371 2
a372 2
	    if (PL_orslen)
		if (PerlIO_write(fp, PL_ors, PL_orslen) == 0 || PerlIO_error(fp))
d376 1
a376 1
		if (PerlIO_flush(fp) == EOF)
d381 1
a381 1
    PUSHs(&PL_sv_yes);
d386 1
a386 1
    PUSHs(&PL_sv_undef);
d392 2
a393 1
    djSP; dPOPss;
d401 3
a403 1
	if (PL_op->op_flags & OPf_REF) {
d411 1
a411 1
	    if (PL_op->op_flags & OPf_REF) {
a416 2
	    GV *gv;
	    
a418 1
		STRLEN n_a;
d426 2
a427 2
		    if (PL_op->op_flags & OPf_REF ||
		      PL_op->op_private & HINT_STRICT_REFS)
a428 2
		    if (PL_dowarn)
			warn(warn_uninit);
d433 2
a434 2
		sym = SvPV(sv,n_a);
		if (PL_op->op_private & HINT_STRICT_REFS)
d436 6
a441 8
		gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PVAV);
	    } else {
		gv = (GV*)sv;
	    }
	    av = GvAVn(gv);
	    if (PL_op->op_private & OPpLVAL_INTRO)
		av = save_ary(gv);
	    if (PL_op->op_flags & OPf_REF) {
d450 2
a451 11
	EXTEND(SP, maxarg);          
	if (SvRMAGICAL(av)) {
	    U32 i; 
	    for (i=0; i < maxarg; i++) {
		SV **svp = av_fetch(av, i, FALSE);
		SP[i+1] = (svp) ? *svp : &PL_sv_undef;
	    }
	} 
	else {
	    Copy(AvARRAY(av), SP+1, maxarg, SV*);
	}
d464 3
a466 1
    djSP; dTOPss;
d472 1
a472 1
	if (SvTYPE(hv) != SVt_PVHV && SvTYPE(hv) != SVt_PVAV)
d474 3
a476 1
	if (PL_op->op_flags & OPf_REF) {
d482 1
a482 1
	if (SvTYPE(sv) == SVt_PVHV || SvTYPE(sv) == SVt_PVAV) {
d484 1
a484 1
	    if (PL_op->op_flags & OPf_REF) {
a489 2
	    GV *gv;
	    
a491 1
		STRLEN n_a;
d499 2
a500 2
		    if (PL_op->op_flags & OPf_REF ||
		      PL_op->op_private & HINT_STRICT_REFS)
a501 2
		    if (PL_dowarn)
			warn(warn_uninit);
d508 2
a509 2
		sym = SvPV(sv,n_a);
		if (PL_op->op_private & HINT_STRICT_REFS)
d511 6
a516 8
		gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PVHV);
	    } else {
		gv = (GV*)sv;
	    }
	    hv = GvHVn(gv);
	    if (PL_op->op_private & OPpLVAL_INTRO)
		hv = save_hash(gv);
	    if (PL_op->op_flags & OPf_REF) {
d524 1
a524 1
	*PL_stack_sp = (SV*)hv;
d529 4
a532 5
	if (SvTYPE(hv) == SVt_PVAV)
	    hv = avhv_keys((AV*)hv);
	if (HvFILL(hv))
	    sv_setpvf(TARG, "%ld/%ld",
		      (long)HvFILL(hv), (long)HvMAX(hv) + 1);
a534 1
	
d542 4
a545 4
    djSP;
    SV **lastlelem = PL_stack_sp;
    SV **lastrelem = PL_stack_base + POPMARK;
    SV **firstrelem = PL_stack_base + POPMARK + 1;
a553 1
    I32 gimme;
d558 1
a558 1
    PL_delaymagic = DM_DELAY;		/* catch simultaneous items */
d564 1
a564 1
    if (PL_op->op_private & OPpASSIGN_COMMON) {
d567 1
a567 2
            if (sv = *relem) {
		TAINT_NOT;	/* Each item is independent */
a568 1
	    }
d577 1
a577 1
	TAINT_NOT;		/* Each item stands on its own, taintwise. */
a584 1
	    av_extend(ary, lastrelem - relem);
a586 1
		SV **didstore;
d591 4
a594 8
		didstore = av_store(ary,i++,sv);
		if (magic) {
		    if (SvSMAGICAL(sv))
			mg_set(sv);
		    if (!didstore)
			SvREFCNT_dec(sv);
		}
		TAINT_NOT;
d598 1
d606 1
a606 1
		    HE *didstore;
d610 2
a611 1
			sv = &PL_sv_no, relem++;
d616 4
a619 32
		    didstore = hv_store_ent(hash,sv,tmpstr,0);
		    if (magic) {
			if (SvSMAGICAL(tmpstr))
			    mg_set(tmpstr);
			if (!didstore)
			    SvREFCNT_dec(tmpstr);
		    }
		    TAINT_NOT;
		}
		if (relem == lastrelem) {
		    if (*relem) {
			HE *didstore;
			if (PL_dowarn) {
			    if (relem == firstrelem &&
				SvROK(*relem) &&
				( SvTYPE(SvRV(*relem)) == SVt_PVAV ||
				  SvTYPE(SvRV(*relem)) == SVt_PVHV ) )
				warn("Reference found where even-sized list expected");
			    else
				warn("Odd number of elements in hash assignment");
			}
			tmpstr = NEWSV(29,0);
			didstore = hv_store_ent(hash,*relem,tmpstr,0);
			if (magic) {
			    if (SvSMAGICAL(tmpstr))
				mg_set(tmpstr);
			    if (!didstore)
				SvREFCNT_dec(tmpstr);
			}
			TAINT_NOT;
		    }
		    relem++;
d625 2
a626 2
		if (SvREADONLY(sv) && PL_curcop != &PL_compiling) {
		    if (!SvIMMORTAL(sv))
d640 1
a640 1
		sv_setsv(sv, &PL_sv_undef);
d645 2
a646 2
    if (PL_delaymagic & ~DM_DELAY) {
	if (PL_delaymagic & DM_UID) {
d648 1
a648 1
	    (void)setresuid(PL_uid,PL_euid,(Uid_t)-1);
d651 1
a651 1
	    (void)setreuid(PL_uid,PL_euid);
d654 3
a656 3
	    if ((PL_delaymagic & DM_UID) == DM_RUID) {
		(void)setruid(PL_uid);
		PL_delaymagic &= ~DM_RUID;
d660 3
a662 3
	    if ((PL_delaymagic & DM_UID) == DM_EUID) {
		(void)seteuid(PL_uid);
		PL_delaymagic &= ~DM_EUID;
d665 2
a666 2
	    if (PL_delaymagic & DM_UID) {
		if (PL_uid != PL_euid)
d668 1
a668 1
		(void)PerlProc_setuid(PL_uid);
d672 2
a673 2
	    PL_uid = (int)PerlProc_getuid();
	    PL_euid = (int)PerlProc_geteuid();
d675 1
a675 1
	if (PL_delaymagic & DM_GID) {
d677 1
a677 1
	    (void)setresgid(PL_gid,PL_egid,(Gid_t)-1);
d680 1
a680 1
	    (void)setregid(PL_gid,PL_egid);
d683 3
a685 3
	    if ((PL_delaymagic & DM_GID) == DM_RGID) {
		(void)setrgid(PL_gid);
		PL_delaymagic &= ~DM_RGID;
d689 3
a691 3
	    if ((PL_delaymagic & DM_GID) == DM_EGID) {
		(void)setegid(PL_gid);
		PL_delaymagic &= ~DM_EGID;
d694 2
a695 2
	    if (PL_delaymagic & DM_GID) {
		if (PL_gid != PL_egid)
d697 1
a697 1
		(void)PerlProc_setgid(PL_gid);
d701 2
a702 2
	    PL_gid = (int)PerlProc_getgid();
	    PL_egid = (int)PerlProc_getegid();
d704 1
a704 1
	PL_tainting |= (PL_uid && (PL_euid != PL_uid || PL_egid != PL_gid));
d706 2
a707 11
    PL_delaymagic = 0;

    gimme = GIMME_V;
    if (gimme == G_VOID)
	SP = firstrelem - 1;
    else if (gimme == G_SCALAR) {
	dTARGET;
	SP = firstrelem;
	SETi(lastrelem - firstrelem + 1);
    }
    else {
d712 8
a719 3
	lelem = firstlelem + (relem - firstrelem);
	while (relem <= SP)
	    *relem++ = (lelem <= lastlelem) ? *lelem++ : &PL_sv_undef;
a720 11
    RETURN;
}

PP(pp_qr)
{
    djSP;
    register PMOP *pm = cPMOP;
    SV *rv = sv_newmortal();
    SV *sv = newSVrv(rv, "Regexp");
    sv_magic(sv,(SV*)ReREFCNT_inc(pm->op_pmregexp),'r',0,0);
    RETURNX(PUSHs(rv));
d725 1
a725 1
    djSP; dTARG;
a733 1
    bool rxtainted;
d737 1
a737 3
    I32 oldsave = PL_savestack_ix;
    I32 update_minmatch = 1;
    SV *screamer;
d739 1
a739 1
    if (PL_op->op_flags & OPf_STACKED)
d742 1
a742 1
	TARG = DEFSV;
a744 1
    PUTBACK;				/* EVAL blocks need stack_sp. */
a748 3
    rxtainted = ((pm->op_pmdynflags & PMdf_TAINTED) ||
		 (PL_tainted && (pm->op_pmflags & PMf_RETAINT)));
    TAINT_NOT;
d750 1
a750 2
    if (pm->op_pmdynflags & PMdf_USED) {
      failure:
d756 2
a757 2
    if (!rx->prelen && PL_curpm) {
	pm = PL_curpm;
a759 6
    if (rx->minlen > len) goto failure;

    screamer = ( (SvSCREAM(TARG) && rx->check_substr
		  && SvTYPE(rx->check_substr) == SVt_PVBM
		  && SvVALID(rx->check_substr)) 
		? TARG : Nullsv);
a767 1
		update_minmatch = 0;
d771 3
a773 3
    safebase = ((gimme != G_ARRAY && !global && rx->nparens)
		|| SvTEMP(TARG) || PL_sawampersand)
		? REXEC_COPY_STR : 0;
d775 2
a776 2
	SAVEINT(PL_multiline);
	PL_multiline = pm->op_pmflags & PMf_MULTILINE;
d782 1
a782 1
	if ((s + rx->minlen) > strend)
d784 1
a784 2
	if (update_minmatch++)
	    minmatch = (s == rx->startp[0]);
d786 4
a789 6
    if (rx->check_substr) {
	if (!(rx->reganch & ROPT_NOSCAN)) { /* Floating checkstring. */
	    if ( screamer ) {
		I32 p = -1;
		
		if (PL_screamfirst[BmRARE(rx->check_substr)] < 0)
d791 1
a791 2
		else if (!(s = screaminstr(TARG, rx->check_substr, 
					   rx->check_offset_min, 0, &p, 0)))
d793 1
a793 2
		else if ((rx->reganch & ROPT_CHECK_ALL)
			 && !PL_sawampersand && !SvTAIL(rx->check_substr))
d796 2
a797 3
	    else if (!(s = fbm_instr((unsigned char*)s + rx->check_offset_min,
				     (unsigned char*)strend, 
				     rx->check_substr, 0)))
d799 1
a799 1
	    else if ((rx->reganch & ROPT_CHECK_ALL) && !PL_sawampersand)
d801 5
a805 3
	    if (s && rx->check_offset_max < s - t) {
		++BmUSEFUL(rx->check_substr);
		s -= rx->check_offset_max;
d810 10
a819 9
	/* Now checkstring is fixed, i.e. at fixed offset from the
	   beginning of match, and the match is anchored at s. */
	else if (!PL_multiline) {	/* Anchored near beginning of string. */
	    I32 slen;
	    if (*SvPVX(rx->check_substr) != s[rx->check_offset_min]
		|| ((slen = SvCUR(rx->check_substr)) > 1
		    && memNE(SvPVX(rx->check_substr), 
			     s + rx->check_offset_min, slen)))
		goto nope;
d821 3
a823 5
	if (!rx->naughty && --BmUSEFUL(rx->check_substr) < 0
	    && rx->check_substr == rx->float_substr) {
	    SvREFCNT_dec(rx->check_substr);
	    rx->check_substr = Nullsv;	/* opt is being useless */
	    rx->float_substr = Nullsv;
d826 4
a829 4
    if (CALLREGEXEC(rx, s, strend, truebase, minmatch,
		      screamer, NULL, safebase))
    {
	PL_curpm = pm;
d831 1
a831 1
	    pm->op_pmdynflags |= PMdf_USED;
a838 3
    if (rxtainted)
	RX_MATCH_TAINTED_on(rx);
    TAINT_IF(RX_MATCH_TAINTED(rx));
a846 1
	SPAGAIN;			/* EVAL blocks could move the stack. */
a847 1
	EXTEND_MORTAL(iters + i);
a857 1
	    strend = rx->subend;
a859 1
	    PUTBACK;			/* EVAL blocks may use stack */
a861 2
	else if (!iters)
	    XPUSHs(&PL_sv_yes);
d875 1
a875 1
		mg->mg_len = rx->endp[0] - rx->subbeg;
d881 2
d888 3
a890 6
yup:					/* Confirmed by check_substr */
    if (rxtainted)
	RX_MATCH_TAINTED_on(rx);
    TAINT_IF(RX_MATCH_TAINTED(rx));
    ++BmUSEFUL(rx->check_substr);
    PL_curpm = pm;
d892 1
a892 3
	pm->op_pmdynflags |= PMdf_USED;
    Safefree(rx->subbase);
    rx->subbase = Nullch;
d897 1
a897 1
	rx->endp[0] = s + SvCUR(rx->check_substr);
d900 1
a900 1
    if (PL_sawampersand) {
d903 2
d909 1
a909 1
	rx->endp[0] = tmps + SvCUR(rx->check_substr);
d915 2
a916 2
    if (rx->check_substr)
	++BmUSEFUL(rx->check_substr);
d919 1
a919 1
    if (global && !(pm->op_pmflags & PMf_CONTINUE)) {
d933 1
a933 1
do_readline(void)
d939 3
a941 5
    PerlIO *fp;
    register IO *io = GvIO(PL_last_in_gv);
    register I32 type = PL_op->op_type;
    I32 gimme = GIMME_V;
    MAGIC *mg;
a942 12
    if (mg = SvTIED_mg((SV*)PL_last_in_gv, 'q')) {
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)PL_last_in_gv, mg));
	PUTBACK;
	ENTER;
	perl_call_method("READLINE", gimme);
	LEAVE;
	SPAGAIN;
	if (gimme == G_SCALAR)
	    SvSetMagicSV_nosteal(TARG, TOPs);
	RETURN;
    }
d951 3
a953 6
		    if (av_len(GvAVn(PL_last_in_gv)) < 0) {
			do_open(PL_last_in_gv,"-",1,FALSE,O_RDONLY,0,Nullfp);
			sv_setpvn(GvSV(PL_last_in_gv), "-", 1);
			SvSETMAGIC(GvSV(PL_last_in_gv));
			fp = IoIFP(io);
			goto have_fp;
d956 1
a956 1
		fp = nextargv(PL_last_in_gv);
d958 1
a958 1
		    (void)do_close(PL_last_in_gv, FALSE); /* now it does*/
d979 1
a979 1
		    PerlIO *tmpfp;
d992 1
a992 1
		    strcat(tmpfnam,PerlLIO_tmpnam(NULL));
d1009 2
a1010 5
		    if ((tmpfp = PerlIO_open(tmpfnam,"w+","fop=dlt")) != NULL) {
		        Stat_t st;
		        if (!PerlLIO_stat(SvPVX(tmpglob),&st) && S_ISDIR(st.st_mode))
		          ok = ((wilddsc.dsc$a_pointer = tovmspath(SvPVX(tmpglob),vmsspec)) != NULL);
		        else ok = ((wilddsc.dsc$a_pointer = tovmsspec(SvPVX(tmpglob),vmsspec)) != NULL);
d1019 1
a1019 1
		              if (isunix) trim_unixpath(rstr,SvPVX(tmpglob),1);
d1027 1
a1027 1
		            ok = (PerlIO_puts(tmpfp,begin) != EOF);
d1036 1
a1036 1
		            PerlIO_close(tmpfp);
d1040 1
a1040 1
		           PerlIO_rewind(tmpfp);
a1042 1
		           IoFLAGS(io) &= ~IOf_UNTAINT;  /* maybe redundant */
a1047 9
#ifdef OS2
		sv_setpv(tmpcmd, "for a in ");
		sv_catsv(tmpcmd, tmpglob);
		sv_catpv(tmpcmd, "; do echo \"$a\\0\\c\"; done |");
#else
#ifdef DJGPP
		sv_setpv(tmpcmd, "/dev/dosglob/"); /* File System Extension */
		sv_catsv(tmpcmd, tmpglob);
#else
d1051 3
a1053 5
#endif /* !DJGPP */
#endif /* !OS2 */
#else /* !DOSISH */
#if defined(CSH)
		sv_setpvn(tmpcmd, PL_cshname, PL_cshlen);
d1066 3
a1068 3
#endif /* !DOSISH */
		(void)do_open(PL_last_in_gv, SvPVX(tmpcmd), SvCUR(tmpcmd),
			      FALSE, O_RDONLY, 0, Nullfp);
d1078 3
a1080 3
	if (PL_dowarn && io && !(IoFLAGS(io) & IOf_START))
	    warn("Read on closed filehandle <%s>", GvENAME(PL_last_in_gv));
	if (gimme == G_SCALAR) {
d1086 5
a1090 2
  have_fp:
    if (gimme == G_SCALAR) {
a1091 2
	if (SvROK(sv))
	    sv_unref(sv);
a1100 12
    else {
	sv = sv_2mortal(NEWSV(57, 80));
	offset = 0;
    }

/* flip-flop EOF state for a snarfed empty file */
#define SNARF_EOF(gimme,rs,io,sv) \
    ((gimme != G_SCALAR || SvCUR(sv)					\
      || (IoFLAGS(io) & IOf_NOLINE) || IoLINES(io) || !RsSNARF(rs))	\
	? ((IoFLAGS(io) &= ~IOf_NOLINE), TRUE)				\
	: ((IoFLAGS(io) |= IOf_NOLINE), FALSE))

d1102 2
a1103 4
	if (!sv_gets(sv, fp, offset)
	    && (type == OP_GLOB || SNARF_EOF(gimme, PL_rs, io, sv)))
	{
	    PerlIO_clearerr(fp);
d1105 1
a1105 1
		fp = nextargv(PL_last_in_gv);
d1108 1
a1108 1
		(void)do_close(PL_last_in_gv, FALSE);
d1112 1
a1112 5
		if (!do_close(PL_last_in_gv, FALSE)) {
		    warn("glob failed (child exited with status %d%s)",
			 STATUS_CURRENT >> 8,
			 (STATUS_CURRENT & 0x80) ? ", core dumped" : "");
		}
d1114 1
a1114 1
	    if (gimme == G_SCALAR) {
a1119 5
	/* This should not be marked tainted if the fp is marked clean */
	if (!(IoFLAGS(io) & IOf_UNTAINT)) {
	    TAINT;
	    SvTAINTED_on(sv);
	}
a1120 1
	SvSETMAGIC(sv);
d1122 4
d1129 1
a1129 1
	    if (SvCUR(sv) > 0 && SvCUR(PL_rs) > 0) {
d1131 1
a1131 1
		if (*tmps == *SvPVX(PL_rs)) {
d1140 1
a1140 1
	    if (*tmps && PerlLIO_stat(SvPVX(sv), &PL_statbuf) < 0) {
d1145 1
a1145 1
	if (gimme == G_ARRAY) {
d1153 1
a1153 1
	else if (gimme == G_SCALAR && !tmplen && SvLEN(sv) - SvCUR(sv) > 80) {
d1167 15
a1181 10
    djSP;
    register PERL_CONTEXT *cx;
    I32 gimme = OP_GIMME(PL_op, -1);

    if (gimme == -1) {
	if (cxstack_ix >= 0)
	    gimme = cxstack[cxstack_ix].blk_gimme;
	else
	    gimme = G_SCALAR;
    }
d1186 1
a1186 1
    PUSHBLOCK(cx, CXt_BLOCK, SP);
d1193 2
a1194 3
    djSP;
    HE* he;
    SV **svp;
d1196 2
d1199 1
a1199 3
    U32 lval = PL_op->op_flags & OPf_MOD;
    U32 defer = PL_op->op_private & OPpLVAL_DEFER;
    SV *sv;
d1201 1
a1201 10
    if (SvTYPE(hv) == SVt_PVHV) {
	he = hv_fetch_ent(hv, keysv, lval && !defer, 0);
	svp = he ? &HeVAL(he) : 0;
    }
    else if (SvTYPE(hv) == SVt_PVAV) {
	if (PL_op->op_private & OPpLVAL_INTRO)
	    DIE("Can't localize pseudo-hash element");
	svp = avhv_fetch_ent((AV*)hv, keysv, lval && !defer, 0);
    }
    else {
d1203 1
a1203 1
    }
d1205 6
a1210 25
	if (!svp || *svp == &PL_sv_undef) {
	    SV* lv;
	    SV* key2;
	    if (!defer) {
		STRLEN n_a;
		DIE(no_helem, SvPV(keysv, n_a));
	    }
	    lv = sv_newmortal();
	    sv_upgrade(lv, SVt_PVLV);
	    LvTYPE(lv) = 'y';
	    sv_magic(lv, key2 = newSVsv(keysv), 'y', Nullch, 0);
	    SvREFCNT_dec(key2);	/* sv_magic() increments refcount */
	    LvTARG(lv) = SvREFCNT_inc(hv);
	    LvTARGLEN(lv) = 1;
	    PUSHs(lv);
	    RETURN;
	}
	if (PL_op->op_private & OPpLVAL_INTRO) {
	    if (HvNAME(hv) && isGV(*svp))
		save_gp((GV*)*svp, !(PL_op->op_flags & OPf_SPECIAL));
	    else
		save_helem(hv, keysv, svp);
	}
	else if (PL_op->op_private & OPpDEREF)
	    vivify_ref(*svp, PL_op->op_private & OPpDEREF);
d1212 1
a1212 10
    sv = (svp ? *svp : &PL_sv_undef);
    /* This makes C<local $tied{foo} = $tied{foo}> possible.
     * Pushing the magical RHS on to the stack is useless, since
     * that magic is soon destined to be misled by the local(),
     * and thus the later pp_sassign() will fail to mg_get() the
     * old value.  This should also cure problems with delayed
     * mg_get()s.  GSAR 98-07-03 */
    if (!lval && SvGMAGICAL(sv))
	sv = sv_mortalcopy(sv);
    PUSHs(sv);
d1218 2
a1219 2
    djSP;
    register PERL_CONTEXT *cx;
d1225 1
a1225 1
    if (PL_op->op_flags & OPf_SPECIAL) {
d1227 1
a1227 1
	cx->blk_oldpm = PL_curpm;	/* fake block should preserve $1 et al */
d1232 6
a1237 7
    gimme = OP_GIMME(PL_op, -1);
    if (gimme == -1) {
	if (cxstack_ix >= 0)
	    gimme = cxstack[cxstack_ix].blk_gimme;
	else
	    gimme = G_SCALAR;
    }
d1239 3
a1241 10
    TAINT_NOT;
    if (gimme == G_VOID)
	SP = newsp;
    else if (gimme == G_SCALAR) {
	MARK = newsp + 1;
	if (MARK <= SP)
	    if (SvFLAGS(TOPs) & (SVs_PADTMP|SVs_TEMP))
		*MARK = TOPs;
	    else
		*MARK = sv_mortalcopy(TOPs);
d1243 11
a1253 2
	    MEXTEND(mark,0);
	    *MARK = &PL_sv_undef;
a1254 1
	SP = MARK;
d1256 3
a1258 4
    else if (gimme == G_ARRAY) {
	/* in case LEAVE wipes old return values */
	for (mark = newsp + 1; mark <= SP; mark++) {
	    if (!(SvFLAGS(*mark) & (SVs_PADTMP|SVs_TEMP))) {
d1260 1
a1260 3
		TAINT_NOT;	/* Each item is independent */
	    }
	}
d1262 1
a1262 1
    PL_curpm = newpm;	/* Don't pop $1 et al till now */
d1271 3
a1273 3
    djSP;
    register PERL_CONTEXT *cx;
    SV* sv;
d1276 1
a1276 1
    EXTEND(SP, 1);
d1278 1
a1278 1
    if (CxTYPE(cx) != CXt_LOOP)
a1279 1

d1281 2
a1282 54
    if (SvTYPE(av) != SVt_PVAV) {
	/* iterate ($min .. $max) */
	if (cx->blk_loop.iterlval) {
	    /* string increment */
	    register SV* cur = cx->blk_loop.iterlval;
	    STRLEN maxlen;
	    char *max = SvPV((SV*)av, maxlen);
	    if (!SvNIOK(cur) && SvCUR(cur) <= maxlen) {
#ifndef USE_THREADS			  /* don't risk potential race */
		if (SvREFCNT(*cx->blk_loop.itervar) == 1
		    && !SvMAGICAL(*cx->blk_loop.itervar))
		{
		    /* safe to reuse old SV */
		    sv_setsv(*cx->blk_loop.itervar, cur);
		}
		else 
#endif
		{
		    /* we need a fresh SV every time so that loop body sees a
		     * completely new SV for closures/references to work as
		     * they used to */
		    SvREFCNT_dec(*cx->blk_loop.itervar);
		    *cx->blk_loop.itervar = newSVsv(cur);
		}
		if (strEQ(SvPVX(cur), max))
		    sv_setiv(cur, 0); /* terminate next time */
		else
		    sv_inc(cur);
		RETPUSHYES;
	    }
	    RETPUSHNO;
	}
	/* integer increment */
	if (cx->blk_loop.iterix > cx->blk_loop.itermax)
	    RETPUSHNO;

#ifndef USE_THREADS			  /* don't risk potential race */
	if (SvREFCNT(*cx->blk_loop.itervar) == 1
	    && !SvMAGICAL(*cx->blk_loop.itervar))
	{
	    /* safe to reuse old SV */
	    sv_setiv(*cx->blk_loop.itervar, cx->blk_loop.iterix++);
	}
	else 
#endif
	{
	    /* we need a fresh SV every time so that loop body sees a
	     * completely new SV for closures/references to work as they
	     * used to */
	    SvREFCNT_dec(*cx->blk_loop.itervar);
	    *cx->blk_loop.itervar = newSViv(cx->blk_loop.iterix++);
	}
	RETPUSHYES;
    }
d1284 1
a1284 2
    /* iterate array */
    if (cx->blk_loop.iterix >= (av == PL_curstack ? cx->blk_oldsp : AvFILL(av)))
d1287 1
a1287 5
    SvREFCNT_dec(*cx->blk_loop.itervar);

    if (sv = (SvMAGICAL(av)) 
	    ? *av_fetch(av, ++cx->blk_loop.iterix, FALSE) 
	    : AvARRAY(av)[++cx->blk_loop.iterix])
d1289 2
d1292 1
a1292 20
	sv = &PL_sv_undef;
    if (av != PL_curstack && SvIMMORTAL(sv)) {
	SV *lv = cx->blk_loop.iterlval;
	if (lv && SvREFCNT(lv) > 1) {
	    SvREFCNT_dec(lv);
	    lv = Nullsv;
	}
	if (lv)
	    SvREFCNT_dec(LvTARG(lv));
	else {
	    lv = cx->blk_loop.iterlval = NEWSV(26, 0);
	    sv_upgrade(lv, SVt_PVLV);
	    LvTYPE(lv) = 'y';
	    sv_magic(lv, Nullsv, 'y', Nullch, 0);
	}
	LvTARG(lv) = SvREFCNT_inc(av);
	LvTARGOFF(lv) = cx->blk_loop.iterix;
	LvTARGLEN(lv) = (UV) -1;
	sv = (SV*)lv;
    }
a1293 1
    *cx->blk_loop.itervar = SvREFCNT_inc(sv);
d1299 1
a1299 1
    djSP; dTARG;
a1312 1
    bool rxtainted;
d1318 5
a1322 7
    I32 oldsave = PL_savestack_ix;
    I32 update_minmatch = 1;
    SV *screamer;

    /* known replacement string? */
    dstr = (pm->op_pmflags & PMf_CONST) ? POPs : Nullsv;
    if (PL_op->op_flags & OPf_STACKED)
d1325 1
a1325 1
	TARG = DEFSV;
d1327 1
a1327 7
    }                  
    if (SvREADONLY(TARG)
	|| (SvTYPE(TARG) > SVt_PVLV
	    && !(SvTYPE(TARG) == SVt_PVGV && SvFAKE(TARG))))
	croak(no_modify);
    PUTBACK;

d1329 1
a1329 1
    if (!SvPOKp(TARG) || SvTYPE(TARG) == SVt_PVGV)
a1330 5
    rxtainted = ((pm->op_pmdynflags & PMdf_TAINTED) ||
		 (PL_tainted && (pm->op_pmflags & PMf_RETAINT)));
    if (PL_tainted)
	rxtainted |= 2;
    TAINT_NOT;
d1337 1
a1337 3
    maxiters = 2*(strend - s) + 10;	/* We can match twice at each 
					   position, once with zero-length,
					   second time with non-zero. */
d1339 2
a1340 2
    if (!rx->prelen && PL_curpm) {
	pm = PL_curpm;
d1343 1
a1343 6
    screamer = ( (SvSCREAM(TARG) && rx->check_substr
		  && SvTYPE(rx->check_substr) == SVt_PVBM
		  && SvVALID(rx->check_substr)) 
		? TARG : Nullsv);
    safebase = (rx->nparens || SvTEMP(TARG) || PL_sawampersand)
		? REXEC_COPY_STR : 0;
d1345 2
a1346 2
	SAVEINT(PL_multiline);
	PL_multiline = pm->op_pmflags & PMf_MULTILINE;
d1349 4
a1352 6
    if (rx->check_substr) {
	if (!(rx->reganch & ROPT_NOSCAN)) { /* It floats. */
	    if (screamer) {
		I32 p = -1;
		
		if (PL_screamfirst[BmRARE(rx->check_substr)] < 0)
d1354 1
a1354 1
		else if (!(s = screaminstr(TARG, rx->check_substr, rx->check_offset_min, 0, &p, 0)))
d1357 2
a1358 3
	    else if (!(s = fbm_instr((unsigned char*)s + rx->check_offset_min, 
				     (unsigned char*)strend,
				     rx->check_substr, 0)))
d1360 5
a1364 3
	    if (s && rx->check_offset_max < s - m) {
		++BmUSEFUL(rx->check_substr);
		s -= rx->check_offset_max;
d1369 10
a1378 9
	/* Now checkstring is fixed, i.e. at fixed offset from the
	   beginning of match, and the match is anchored at s. */
	else if (!PL_multiline) { /* Anchored at beginning of string. */
	    I32 slen;
	    if (*SvPVX(rx->check_substr) != s[rx->check_offset_min]
		|| ((slen = SvCUR(rx->check_substr)) > 1
		    && memNE(SvPVX(rx->check_substr), 
			     s + rx->check_offset_min, slen)))
		goto nope;
d1380 3
a1382 5
	if (!rx->naughty && --BmUSEFUL(rx->check_substr) < 0
	    && rx->check_substr == rx->float_substr) {
	    SvREFCNT_dec(rx->check_substr);
	    rx->check_substr = Nullsv;	/* opt is being useless */
	    rx->float_substr = Nullsv;
a1384 2

    /* only replace once? */
d1386 103
a1488 10

    /* known replacement string? */
    c = dstr ? SvPV(dstr, clen) : Nullch;

    /* can do inplace substitution? */
    if (c && clen <= rx->minlen && (once || !(safebase & REXEC_COPY_STR))
	&& !(rx->reganch & ROPT_LOOKBEHIND_SEEN)) {
	if (!CALLREGEXEC(rx, s, strend, orig, 0, screamer, NULL, safebase)) {
	    SPAGAIN;
	    PUSHs(&PL_sv_no);
a1491 92
	if (force_on_match) {
	    force_on_match = 0;
	    s = SvPV_force(TARG, len);
	    goto force_it;
	}
	d = s;
	PL_curpm = pm;
	SvSCREAM_off(TARG);	/* disable possible screamer */
	if (once) {
	    rxtainted |= RX_MATCH_TAINTED(rx);
	    if (rx->subbase) {
		m = orig + (rx->startp[0] - rx->subbase);
		d = orig + (rx->endp[0] - rx->subbase);
	    } else {
		m = rx->startp[0];
		d = rx->endp[0];
	    }
	    s = orig;
	    if (m - s > strend - d) {  /* faster to shorten from end */
		if (clen) {
		    Copy(c, m, clen, char);
		    m += clen;
		}
		i = strend - d;
		if (i > 0) {
		    Move(d, m, i, char);
		    m += i;
		}
		*m = '\0';
		SvCUR_set(TARG, m - s);
	    }
	    /*SUPPRESS 560*/
	    else if (i = m - s) {	/* faster from front */
		d -= clen;
		m = d;
		sv_chop(TARG, d-i);
		s += i;
		while (i--)
		    *--d = *--s;
		if (clen)
		    Copy(c, m, clen, char);
	    }
	    else if (clen) {
		d -= clen;
		sv_chop(TARG, d);
		Copy(c, d, clen, char);
	    }
	    else {
		sv_chop(TARG, d);
	    }
	    TAINT_IF(rxtainted & 1);
	    SPAGAIN;
	    PUSHs(&PL_sv_yes);
	}
	else {
	    do {
		if (iters++ > maxiters)
		    DIE("Substitution loop");
		rxtainted |= RX_MATCH_TAINTED(rx);
		m = rx->startp[0];
		/*SUPPRESS 560*/
		if (i = m - s) {
		    if (s != d)
			Move(s, d, i, char);
		    d += i;
		}
		if (clen) {
		    Copy(c, d, clen, char);
		    d += clen;
		}
		s = rx->endp[0];
	    } while (CALLREGEXEC(rx, s, strend, orig, s == m,
			      Nullsv, NULL, 0)); /* don't match same null twice */
	    if (s != d) {
		i = strend - s;
		SvCUR_set(TARG, d - SvPVX(TARG) + i);
		Move(s, d, i+1, char);		/* include the NUL */
	    }
	    TAINT_IF(rxtainted & 1);
	    SPAGAIN;
	    PUSHs(sv_2mortal(newSViv((I32)iters)));
	}
	(void)SvPOK_only(TARG);
	TAINT_IF(rxtainted);
	if (SvSMAGICAL(TARG)) {
	    PUTBACK;
	    mg_set(TARG);
	    SPAGAIN;
	}
	SvTAINT(TARG);
	LEAVE_SCOPE(oldsave);
	RETURN;
d1493 5
a1497 2

    if (CALLREGEXEC(rx, s, strend, orig, 0, screamer, NULL, safebase)) {
d1503 1
a1503 2
	rxtainted |= RX_MATCH_TAINTED(rx);
	dstr = NEWSV(25, len);
d1505 1
a1505 1
	PL_curpm = pm;
d1507 1
a1507 2
	    register PERL_CONTEXT *cx;
	    SPAGAIN;
a1513 1
	    rxtainted |= RX_MATCH_TAINTED(rx);
d1528 2
a1529 1
	} while (CALLREGEXEC(rx, s, strend, orig, s == m, Nullsv, NULL, safebase));
a1539 4
	TAINT_IF(rxtainted & 1);
	SPAGAIN;
	PUSHs(sv_2mortal(newSViv((I32)iters)));

a1540 1
	TAINT_IF(rxtainted);
d1542 1
a1542 1
	SvTAINT(TARG);
d1546 3
a1548 1
    goto ret_no;
d1551 2
a1552 5
    ++BmUSEFUL(rx->check_substr);

ret_no:         
    SPAGAIN;
    PUSHs(&PL_sv_no);
d1559 1
a1559 1
    djSP;
d1562 2
a1563 2
	PL_stack_base[PL_markstack_ptr[-1]++] = PL_stack_base[*PL_markstack_ptr];
    ++*PL_markstack_ptr;
d1567 1
a1567 1
    if (PL_stack_base + *PL_markstack_ptr > SP) {
a1568 1
	I32 gimme = GIMME_V;
d1572 1
a1572 1
	items = --*PL_markstack_ptr - PL_markstack_ptr[-1];
d1574 2
a1575 2
	SP = PL_stack_base + POPMARK;		/* pop original mark */
	if (gimme == G_SCALAR) {
d1578 1
d1580 1
a1580 2
	else if (gimme == G_ARRAY)
	    SP += items;
d1587 1
a1587 1
	SAVESPTR(PL_curpm);
d1589 1
a1589 1
	src = PL_stack_base[*PL_markstack_ptr];
d1591 1
a1591 1
	DEFSV = src;
d1599 1
a1599 1
    djSP;
d1604 1
a1604 2
    register PERL_CONTEXT *cx;
    struct block_sub cxsub;
d1607 2
a1608 3
    POPSUB1(cx);	/* Delay POPSUB2 until stack values are safe */
 
    TAINT_NOT;
d1611 8
a1618 15
	if (MARK <= SP) {
	    if (cxsub.cv && CvDEPTH(cxsub.cv) > 1) {
		if (SvTEMP(TOPs)) {
		    *MARK = SvREFCNT_inc(TOPs);
		    FREETMPS;
		    sv_2mortal(*MARK);
		} else {
		    FREETMPS;
		    *MARK = sv_mortalcopy(TOPs);
		}
	    } else
		*MARK = SvTEMP(TOPs) ? TOPs : sv_mortalcopy(TOPs);
	} else {
	    MEXTEND(MARK, 0);
	    *MARK = &PL_sv_undef;
d1622 5
a1626 7
    else if (gimme == G_ARRAY) {
	for (MARK = newsp + 1; MARK <= SP; MARK++) {
	    if (!SvTEMP(*MARK)) {
		*MARK = sv_mortalcopy(*MARK);
		TAINT_NOT;	/* Each item is independent */
	    }
	}
a1627 4
    PUTBACK;
    
    POPSUB2();		/* Stack values are safe: release CV and @@_ ... */
    PL_curpm = newpm;	/* ... and pop $1 et al */
d1629 2
a1630 9
    LEAVE;
    return pop_return();
}

STATIC CV *
get_db_sub(SV **svp, CV *cv)
{
    dTHR;
    SV *dbsv = GvSV(PL_DBsub);
d1632 2
a1633 22
    if (!PERLDB_SUB_NN) {
	GV *gv = CvGV(cv);

	save_item(dbsv);
	if ( (CvFLAGS(cv) & (CVf_ANON | CVf_CLONED))
	     || strEQ(GvNAME(gv), "END") 
	     || ((GvCV(gv) != cv) && /* Could be imported, and old sub redefined. */
		 !( (SvTYPE(*svp) == SVt_PVGV) && (GvCV((GV*)*svp) == cv)
		    && (gv = (GV*)*svp) ))) {
	    /* Use GV from the stack as a fallback. */
	    /* GV is potentially non-unique, or contain different CV. */
	    sv_setsv(dbsv, newRV((SV*)cv));
	}
	else {
	    gv_efullname3(dbsv, gv, Nullch);
	}
    }
    else {
	SvUPGRADE(dbsv, SVt_PVIV);
	SvIOK_on(dbsv);
	SAVEIV(SvIVX(dbsv));
	SvIVX(dbsv) = (IV)cv;		/* Do it the quickest way  */
d1635 1
d1637 3
a1639 4
    if (CvXSUB(cv))
	PL_curcopdb = PL_curcop;
    cv = GvCV(PL_DBsub);
    return cv;
d1644 1
a1644 1
    djSP; dPOPss;
d1648 1
a1648 1
    register PERL_CONTEXT *cx;
a1649 1
    bool hasargs = (PL_op->op_flags & OPf_STACKED) != 0;
a1656 1
	    STRLEN n_a;
d1658 1
a1658 3
	    if (sv == &PL_sv_yes) {		/* unfound import, ignore */
		if (hasargs)
		    SP = PL_stack_base + POPMARK;
d1660 1
a1660 8
	    }
	    if (SvGMAGICAL(sv)) {
		mg_get(sv);
		sym = SvPOKp(sv) ? SvPVX(sv) : Nullch;
	    }
	    else
		sym = SvPV(sv, n_a);
	    if (!sym)
d1662 2
a1663 1
	    if (PL_op->op_private & HINT_STRICT_REFS)
d1679 1
a1679 1
	if (!(cv = GvCVu((GV*)sv)))
d1692 23
a1714 17
	GV* autogv;
	SV* sub_name;

	/* anonymous or undef'd function leaves us no recourse */
	if (CvANON(cv) || !(gv = CvGV(cv)))
	    DIE("Undefined subroutine called");
	/* autoloaded stub? */
	if (cv != GvCV(gv)) {
	    cv = GvCV(gv);
	    goto retry;
	}
	/* should call AUTOLOAD now? */
	if ((autogv = gv_autoload4(GvSTASH(gv), GvNAME(gv), GvNAMELEN(gv),
				   FALSE)))
	{
	    cv = GvCV(autogv);
	    goto retry;
d1716 1
a1716 4
	/* sorry */
	sub_name = sv_newmortal();
	gv_efullname3(sub_name, gv, Nullch);
	DIE("Undefined subroutine &%s called", SvPVX(sub_name));
d1719 7
a1725 31
    gimme = GIMME_V;
    if ((PL_op->op_private & OPpENTERSUB_DB) && GvCV(PL_DBsub) && !CvNODEBUG(cv))
	cv = get_db_sub(&sv, cv);
    if (!cv)
	DIE("No DBsub routine");

#ifdef USE_THREADS
    /*
     * First we need to check if the sub or method requires locking.
     * If so, we gain a lock on the CV, the first argument or the
     * stash (for static methods), as appropriate. This has to be
     * inline because for FAKE_THREADS, COND_WAIT inlines code to
     * reschedule by returning a new op.
     */
    MUTEX_LOCK(CvMUTEXP(cv));
    if (CvFLAGS(cv) & CVf_LOCKED) {
	MAGIC *mg;	
	if (CvFLAGS(cv) & CVf_METHOD) {
	    if (SP > PL_stack_base + TOPMARK)
		sv = *(PL_stack_base + TOPMARK + 1);
	    else {
		MUTEX_UNLOCK(CvMUTEXP(cv));
		croak("no argument for locked method call");
	    }
	    if (SvROK(sv))
		sv = SvRV(sv);
	    else {		
		STRLEN len;
		char *stashname = SvPV(sv, len);
		sv = (SV*)gv_stashpvn(stashname, len, TRUE);
	    }
d1728 2
a1729 1
	    sv = (SV*)cv;
d1731 3
a1733 15
	MUTEX_UNLOCK(CvMUTEXP(cv));
	mg = condpair_magic(sv);
	MUTEX_LOCK(MgMUTEXP(mg));
	if (MgOWNER(mg) == thr)
	    MUTEX_UNLOCK(MgMUTEXP(mg));
	else {
	    while (MgOWNER(mg))
		COND_WAIT(MgOWNERCONDP(mg), MgMUTEXP(mg));
	    MgOWNER(mg) = thr;
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(), "%p: pp_entersub lock %p\n",
				  thr, sv);)
	    MUTEX_UNLOCK(MgMUTEXP(mg));
	    save_destructor(unlock_condpair, sv);
	}
	MUTEX_LOCK(CvMUTEXP(cv));
a1734 82
    /*
     * Now we have permission to enter the sub, we must distinguish
     * four cases. (0) It's an XSUB (in which case we don't care
     * about ownership); (1) it's ours already (and we're recursing);
     * (2) it's free (but we may already be using a cached clone);
     * (3) another thread owns it. Case (1) is easy: we just use it.
     * Case (2) means we look for a clone--if we have one, use it
     * otherwise grab ownership of cv. Case (3) means we look for a
     * clone (for non-XSUBs) and have to create one if we don't
     * already have one.
     * Why look for a clone in case (2) when we could just grab
     * ownership of cv straight away? Well, we could be recursing,
     * i.e. we originally tried to enter cv while another thread
     * owned it (hence we used a clone) but it has been freed up
     * and we're now recursing into it. It may or may not be "better"
     * to use the clone but at least CvDEPTH can be trusted.
     */
    if (CvOWNER(cv) == thr || CvXSUB(cv))
	MUTEX_UNLOCK(CvMUTEXP(cv));
    else {
	/* Case (2) or (3) */
	SV **svp;
	
	/*
	 * XXX Might it be better to release CvMUTEXP(cv) while we
     	 * do the hv_fetch? We might find someone has pinched it
     	 * when we look again, in which case we would be in case
     	 * (3) instead of (2) so we'd have to clone. Would the fact
     	 * that we released the mutex more quickly make up for this?
     	 */
	if ((svp = hv_fetch(thr->cvcache, (char *)cv, sizeof(cv), FALSE)))
	{
	    /* We already have a clone to use */
	    MUTEX_UNLOCK(CvMUTEXP(cv));
	    cv = *(CV**)svp;
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
				  "entersub: %p already has clone %p:%s\n",
				  thr, cv, SvPEEK((SV*)cv)));
	    CvOWNER(cv) = thr;
	    SvREFCNT_inc(cv);
	    if (CvDEPTH(cv) == 0)
		SAVEDESTRUCTOR(unset_cvowner, (void*) cv);
	}
	else {
	    /* (2) => grab ownership of cv. (3) => make clone */
	    if (!CvOWNER(cv)) {
		CvOWNER(cv) = thr;
		SvREFCNT_inc(cv);
		MUTEX_UNLOCK(CvMUTEXP(cv));
		DEBUG_S(PerlIO_printf(PerlIO_stderr(),
			    "entersub: %p grabbing %p:%s in stash %s\n",
			    thr, cv, SvPEEK((SV*)cv), CvSTASH(cv) ?
	    			HvNAME(CvSTASH(cv)) : "(none)"));
	    } else {
		/* Make a new clone. */
		CV *clonecv;
		SvREFCNT_inc(cv); /* don't let it vanish from under us */
		MUTEX_UNLOCK(CvMUTEXP(cv));
		DEBUG_S((PerlIO_printf(PerlIO_stderr(),
				       "entersub: %p cloning %p:%s\n",
				       thr, cv, SvPEEK((SV*)cv))));
		/*
	    	 * We're creating a new clone so there's no race
		 * between the original MUTEX_UNLOCK and the
		 * SvREFCNT_inc since no one will be trying to undef
		 * it out from underneath us. At least, I don't think
		 * there's a race...
		 */
	     	clonecv = cv_clone(cv);
    		SvREFCNT_dec(cv); /* finished with this */
		hv_store(thr->cvcache, (char*)cv, sizeof(cv), (SV*)clonecv,0);
		CvOWNER(clonecv) = thr;
		cv = clonecv;
		SvREFCNT_inc(cv);
	    }
	    DEBUG_S(if (CvDEPTH(cv) != 0)
			PerlIO_printf(PerlIO_stderr(), "depth %ld != 0\n",
				      CvDEPTH(cv)););
	    SAVEDESTRUCTOR(unset_cvowner, (void*) cv);
	}
    }
#endif /* USE_THREADS */
d1741 3
a1743 4
					/* We dont worry to copy from @@_. */
	    while (SP > mark) {
		SP[1] = SP[0];
		SP--;
d1745 1
a1745 1
	    PL_stack_sp = mark + 1;
d1748 1
a1748 1
			   MARK - PL_stack_base + 1,
d1750 1
a1750 1
	    PL_stack_sp = PL_stack_base + items;
d1756 1
a1756 31

	    if (!hasargs) {
		/* Need to copy @@_ to stack. Alternative may be to
		 * switch stack to @@_, and copy return values
		 * back. This would allow popping @@_ in XSUB, e.g.. XXXX */
		AV* av;
		I32 items;
#ifdef USE_THREADS
		av = (AV*)PL_curpad[0];
#else
		av = GvAV(PL_defgv);
#endif /* USE_THREADS */		
		items = AvFILLp(av) + 1;   /* @@_ is not tieable */

		if (items) {
		    /* Mark is at the end of the stack. */
		    EXTEND(SP, items);
		    Copy(AvARRAY(av), SP + 1, items, SV*);
		    SP += items;
		    PUTBACK ;		    
		}
	    }
	    if (PL_curcopdb) {		/* We assume that the first
					   XSUB in &DB::sub is the
					   called one. */
		SAVESPTR(PL_curcop);
		PL_curcop = PL_curcopdb;
		PL_curcopdb = NULL;
	    }
	    /* Do we need to open block here? XXXX */
	    (void)(*CvXSUB(cv))(cv _PERL_OBJECT_THIS);
d1759 3
a1761 3
	    if (gimme == G_SCALAR && ++markix != PL_stack_sp - PL_stack_base ) {
		if (markix > PL_stack_sp - PL_stack_base)
		    *(PL_stack_base + markix) = &PL_sv_undef;
d1763 2
a1764 2
		    *(PL_stack_base + markix) = *PL_stack_sp;
		PL_stack_sp = PL_stack_base + markix;
d1773 1
d1776 1
a1776 1
	push_return(PL_op->op_next);
a1779 5
	/* XXX This would be a natural place to set C<PL_compcv = cv> so
	 * that eval'' ops within this sub know the correct lexical space.
	 * Owing the speed considerations, we choose to search for the cv
	 * in doeval() instead.
	 */
d1783 3
a1785 1
	    if (CvDEPTH(cv) > AvFILLp(padlist)) {
d1789 1
a1789 1
		I32 ix = AvFILLp((AV*)svp[1]);
d1792 1
a1792 1
		    if (svp[ix] != &PL_sv_undef) {
d1794 3
a1796 4
			if ((SvFLAGS(svp[ix]) & SVf_FAKE) /* outer lexical? */
			    || *name == '&')		  /* anonymous code? */
			{
			    av_store(newpad, ix, SvREFCNT_inc(oldpad[ix]));
d1818 1
a1818 1
		AvFILLp(padlist) = CvDEPTH(cv);
d1822 4
a1825 21
#ifdef USE_THREADS
	if (!hasargs) {
	    AV* av = (AV*)PL_curpad[0];

	    items = AvFILLp(av) + 1;
	    if (items) {
		/* Mark is at the end of the stack. */
		EXTEND(SP, items);
		Copy(AvARRAY(av), SP + 1, items, SV*);
		SP += items;
		PUTBACK ;		    
	    }
	}
#endif /* USE_THREADS */		
	SAVESPTR(PL_curpad);
    	PL_curpad = AvARRAY((AV*)svp[CvDEPTH(cv)]);
#ifndef USE_THREADS
	if (hasargs)
#endif /* USE_THREADS */
	{
	    AV* av;
a1827 5
#if 0
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
	    			  "%p entersub preparing @@_\n", thr));
#endif
	    av = (AV*)PL_curpad[0];
d1832 1
a1832 4
#ifndef USE_THREADS
	    cx->blk_sub.savearray = GvAV(PL_defgv);
	    GvAV(PL_defgv) = (AV*)SvREFCNT_inc(av);
#endif /* USE_THREADS */
d1834 1
d1851 1
a1851 1
	    AvFILLp(av) = items - 1;
a1858 11
	/* warning must come *after* we fully set up the context
	 * stuff so that __WARN__ handlers can safely dounwind()
	 * if they want to
	 */
	if (CvDEPTH(cv) == 100 && PL_dowarn
	    && !(PERLDB_SUB && cv == GvCV(PL_DBsub)))
	    sub_crush_depth(cv);
#if 0
	DEBUG_S(PerlIO_printf(PerlIO_stderr(),
			      "%p entersub returning %p\n", thr, CvSTART(cv)));
#endif
a1862 12
void
sub_crush_depth(CV *cv)
{
    if (CvANON(cv))
	warn("Deep recursion on anonymous subroutine");
    else {
	SV* tmpstr = sv_newmortal();
	gv_efullname3(tmpstr, CvGV(cv), Nullch);
	warn("Deep recursion on subroutine \"%s\"", SvPVX(tmpstr));
    }
}

d1865 1
a1865 1
    djSP;
d1868 2
a1869 4
    AV* av = (AV*)POPs;
    U32 lval = PL_op->op_flags & OPf_MOD;
    U32 defer = (PL_op->op_private & OPpLVAL_DEFER) && (elem > AvFILL(av));
    SV *sv;
d1872 1
a1872 1
	elem -= PL_curcop->cop_arybase;
d1875 1
a1875 1
    svp = av_fetch(av, elem, lval && !defer);
d1877 8
a1884 23
	if (!svp || *svp == &PL_sv_undef) {
	    SV* lv;
	    if (!defer)
		DIE(no_aelem, elem);
	    lv = sv_newmortal();
	    sv_upgrade(lv, SVt_PVLV);
	    LvTYPE(lv) = 'y';
	    sv_magic(lv, Nullsv, 'y', Nullch, 0);
	    LvTARG(lv) = SvREFCNT_inc(av);
	    LvTARGOFF(lv) = elem;
	    LvTARGLEN(lv) = 1;
	    PUSHs(lv);
	    RETURN;
	}
	if (PL_op->op_private & OPpLVAL_INTRO)
	    save_aelem(av, elem, svp);
	else if (PL_op->op_private & OPpDEREF)
	    vivify_ref(*svp, PL_op->op_private & OPpDEREF);
    }
    sv = (svp ? *svp : &PL_sv_undef);
    if (!lval && SvGMAGICAL(sv))	/* see note in pp_helem() */
	sv = sv_mortalcopy(sv);
    PUSHs(sv);
d1889 3
a1891 1
vivify_ref(SV *sv, U32 to_what)
d1898 3
a1900 18
	if (SvTYPE(sv) < SVt_RV)
	    sv_upgrade(sv, SVt_RV);
	else if (SvTYPE(sv) >= SVt_PV) {
	    (void)SvOOK_off(sv);
	    Safefree(SvPVX(sv));
	    SvLEN(sv) = SvCUR(sv) = 0;
	}
	switch (to_what) {
	case OPpDEREF_SV:
	    SvRV(sv) = NEWSV(355,0);
	    break;
	case OPpDEREF_AV:
	    SvRV(sv) = (SV*)newAV();
	    break;
	case OPpDEREF_HV:
	    SvRV(sv) = (SV*)newHV();
	    break;
	}
d1908 1
a1908 1
    djSP;
d1912 1
a1912 12
    HV* stash;
    char* name;
    char* packname;
    STRLEN packlen;

    if (SvROK(TOPs)) {
	sv = SvRV(TOPs);
	if (SvTYPE(sv) == SVt_PVCV) {
	    SETs(sv);
	    RETURN;
	}
    }
d1914 2
a1915 2
    name = SvPV(TOPs, packlen);
    sv = *(PL_stack_base + TOPMARK + 1);
d1917 1
d1924 1
a1925 1
	packname = Nullch;
d1927 1
a1927 1
	    !(packname = SvPV(sv, packlen)) ||
d1931 17
a1947 6
	    if (!packname || !isIDFIRST(*packname))
		DIE("Can't call method \"%s\" %s", name,
		    SvOK(sv)? "without a package or object reference"
			    : "on an undefined value");
	    stash = gv_stashpvn(packname, packlen, TRUE);
	    goto fetch;
d1949 1
a1949 1
	*(PL_stack_base + TOPMARK + 1) = sv_2mortal(newRV((SV*)iogv));
d1952 2
a1953 1
    if (!ob || !SvOBJECT(ob))
d1955 1
d1957 7
a1963 1
    stash = SvSTASH(ob);
d1965 1
a1965 25
  fetch:
    gv = gv_fetchmethod(stash, name);
    if (!gv) {
	char* leaf = name;
	char* sep = Nullch;
	char* p;

	for (p = name; *p; p++) {
	    if (*p == '\'')
		sep = p, leaf = p + 1;
	    else if (*p == ':' && *(p + 1) == ':')
		sep = p, leaf = p + 2;
	}
	if (!sep || ((sep - name) == 5 && strnEQ(name, "SUPER", 5))) {
	    packname = HvNAME(sep ? PL_curcop->cop_stash : stash);
	    packlen = strlen(packname);
	}
	else {
	    packname = name;
	    packlen = sep - name;
	}
	DIE("Can't locate object method \"%s\" via package \"%.*s\"",
	    leaf, (int)packlen, packname);
    }
    SETs(isGV(gv) ? (SV*)GvCV(gv) : (SV*)gv);
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a18 1
#define PERL_IN_PP_HOT_C
d24 6
d34 19
a52 1
static void unset_cvowner(pTHXo_ void *cvarg);
d58 1
a58 1
    XPUSHs(cSVOP_sv);
d76 1
a76 1
	PUSHs(save_scalar(cGVOP_gv));
d78 1
a78 1
	PUSHs(GvSV(cGVOP_gv));
a86 6
PP(pp_setstate)
{
    PL_curcop = (COP*)PL_op;
    return NORMAL;
}

a99 2
    if (SvUTF8(TOPs) && !IN_BYTE)
	SvUTF8_on(TARG);
d107 1
a107 1
    XPUSHs((SV*)cGVOP_gv);
d125 1
d142 1
a142 1
	RETURNOP(cLOGOP->op_other);
d144 1
a144 1
	RETURNOP(cLOGOP->op_next);
a164 1

a166 5
	if (TARG == right) {
	    sv_insert(TARG, 0, 0, s, len);
	    SETs(TARG);
	    RETURN;
	}
d176 1
a176 15
    if (SvOK(TARG)) {
#if defined(PERL_Y2KWARN)
	if ((SvIOK(right) || SvNOK(right)) && ckWARN(WARN_Y2K)) {
	    STRLEN n;
	    char *s = SvPV(TARG,n);
	    if (n >= 2 && s[n-2] == '1' && s[n-1] == '9'
		&& (n == 2 || !isDIGIT(s[n-3])))
	    {
		Perl_warner(aTHX_ WARN_Y2K, "Possible Y2K bug: %s",
			    "about to append an integer to '19'");
	    }
	}
#endif
	if (DO_UTF8(right))
	    sv_utf8_upgrade(TARG);
a177 8
	if (!IN_BYTE) {
	    if (SvUTF8(right))
		SvUTF8_on(TARG);
	}
	else if (!SvUTF8(right)) {
	    SvUTF8_off(TARG);
	}
    }
a202 1
    tryAMAGICunTARGET(iter, 0);
a203 11
    if (SvTYPE(PL_last_in_gv) != SVt_PVGV) {
	if (SvROK(PL_last_in_gv) && SvTYPE(SvRV(PL_last_in_gv)) == SVt_PVGV) 
	    PL_last_in_gv = (GV*)SvRV(PL_last_in_gv);
	else {
	    dSP;
	    XPUSHs((SV*)PL_last_in_gv);
	    PUTBACK;
	    pp_rv2gv();
	    PL_last_in_gv = (GV*)(*PL_stack_sp--);
	}
    }
d221 2
a222 2
	DIE(aTHX_ PL_no_modify);
    if (SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs) &&
d258 1
a258 1
    AV *av = GvAV(cGVOP_gv);
d313 1
a313 1
    if ((mg = SvTIED_mg((SV*)gv, 'q'))) {
d327 1
a327 1
	call_method("PRINT", G_SCALAR);
d336 1
a336 1
	if (ckWARN(WARN_UNOPENED)) {
d338 2
a339 3
	    gv_efullname3(sv, gv, Nullch);
            Perl_warner(aTHX_ WARN_UNOPENED, "Filehandle %s never opened",
			SvPV(sv,n_a));
d341 1
d346 7
a352 10
	if (ckWARN2(WARN_CLOSED, WARN_IO))  {
	    if (IoIFP(io)) {
		SV* sv = sv_newmortal();
		gv_efullname3(sv, gv, Nullch);
		Perl_warner(aTHX_ WARN_IO,
			    "Filehandle %s opened only for input",
			    SvPV(sv,n_a));
	    }
	    else if (ckWARN(WARN_CLOSED))
		report_closed_fh(gv, io, "print", "filehandle");
d403 1
a403 1
    djSP; dTOPss;
a407 2
	tryAMAGICunDEREF(to_av);

d410 1
a410 1
	    DIE(aTHX_ "Not an ARRAY reference");
d412 1
a412 1
	    SETs((SV*)av);
d420 1
a420 1
		SETs((SV*)av);
d439 4
a442 5
			DIE(aTHX_ PL_no_usym, "an ARRAY");
		    if (ckWARN(WARN_UNINITIALIZED))
			report_uninit();
		    if (GIMME == G_ARRAY) {
			(void)POPs;
d444 1
a444 2
		    }
		    RETSETUNDEF;
d447 4
a450 14
		if ((PL_op->op_flags & OPf_SPECIAL) &&
		    !(PL_op->op_flags & OPf_MOD))
		{
		    gv = (GV*)gv_fetchpv(sym, FALSE, SVt_PVAV);
		    if (!gv)
			RETSETUNDEF;
		}
		else {
		    if (PL_op->op_private & HINT_STRICT_REFS)
			DIE(aTHX_ PL_no_symref, sym, "an ARRAY");
		    gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PVAV);
		}
	    }
	    else {
d457 1
a457 1
		SETs((SV*)av);
a464 1
	(void)POPs;			/* XXXX May be optimized away? */
d481 1
a481 1
	SETi(maxarg);
a492 2
	tryAMAGICunDEREF(to_hv);

d495 1
a495 1
	    DIE(aTHX_ "Not a HASH reference");
d524 3
a526 3
			DIE(aTHX_ PL_no_usym, "a HASH");
		    if (ckWARN(WARN_UNINITIALIZED))
			report_uninit();
d534 4
a537 14
		if ((PL_op->op_flags & OPf_SPECIAL) &&
		    !(PL_op->op_flags & OPf_MOD))
		{
		    gv = (GV*)gv_fetchpv(sym, FALSE, SVt_PVHV);
		    if (!gv)
			RETSETUNDEF;
		}
		else {
		    if (PL_op->op_private & HINT_STRICT_REFS)
			DIE(aTHX_ PL_no_symref, sym, "a HASH");
		    gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PVHV);
		}
	    }
	    else {
d552 1
a552 1
	return do_kv();
d559 2
a560 2
            Perl_sv_setpvf(aTHX_ TARG, "%"IVdf"/%"IVdf,
			   (IV)HvFILL(hv), (IV)HvMAX(hv) + 1);
a568 86
STATIC int
S_do_maybe_phash(pTHX_ AV *ary, SV **lelem, SV **firstlelem, SV **relem,
		 SV **lastrelem)
{
    OP *leftop;
    I32 i;

    leftop = ((BINOP*)PL_op)->op_last;
    assert(leftop);
    assert(leftop->op_type == OP_NULL && leftop->op_targ == OP_LIST);
    leftop = ((LISTOP*)leftop)->op_first;
    assert(leftop);
    /* Skip PUSHMARK and each element already assigned to. */
    for (i = lelem - firstlelem; i > 0; i--) {
	leftop = leftop->op_sibling;
	assert(leftop);
    }
    if (leftop->op_type != OP_RV2HV)
	return 0;

    /* pseudohash */
    if (av_len(ary) > 0)
	av_fill(ary, 0);		/* clear all but the fields hash */
    if (lastrelem >= relem) {
	while (relem < lastrelem) {	/* gobble up all the rest */
	    SV *tmpstr;
	    assert(relem[0]);
	    assert(relem[1]);
	    /* Avoid a memory leak when avhv_store_ent dies. */
	    tmpstr = sv_newmortal();
	    sv_setsv(tmpstr,relem[1]);	/* value */
	    relem[1] = tmpstr;
	    if (avhv_store_ent(ary,relem[0],tmpstr,0))
		(void)SvREFCNT_inc(tmpstr);
	    if (SvMAGICAL(ary) != 0 && SvSMAGICAL(tmpstr))
		mg_set(tmpstr);
	    relem += 2;
	    TAINT_NOT;
	}
    }
    if (relem == lastrelem)
	return 1;
    return 2;
}

STATIC void
S_do_oddball(pTHX_ HV *hash, SV **relem, SV **firstrelem)
{
    if (*relem) {
	SV *tmpstr;
	if (ckWARN(WARN_MISC)) {
	    if (relem == firstrelem &&
		SvROK(*relem) &&
		(SvTYPE(SvRV(*relem)) == SVt_PVAV ||
		 SvTYPE(SvRV(*relem)) == SVt_PVHV))
	    {
		Perl_warner(aTHX_ WARN_MISC,
			    "Reference found where even-sized list expected");
	    }
	    else
		Perl_warner(aTHX_ WARN_MISC,
			    "Odd number of elements in hash assignment");
	}
	if (SvTYPE(hash) == SVt_PVAV) {
	    /* pseudohash */
	    tmpstr = sv_newmortal();
	    if (avhv_store_ent((AV*)hash,*relem,tmpstr,0))
		(void)SvREFCNT_inc(tmpstr);
	    if (SvMAGICAL(hash) && SvSMAGICAL(tmpstr))
		mg_set(tmpstr);
	}
	else {
	    HE *didstore;
	    tmpstr = NEWSV(29,0);
	    didstore = hv_store_ent(hash,*relem,tmpstr,0);
	    if (SvMAGICAL(hash)) {
		if (SvSMAGICAL(tmpstr))
		    mg_set(tmpstr);
		if (!didstore)
		    sv_2mortal(tmpstr);
	    }
	}
	TAINT_NOT;
    }
}

d594 4
a597 5
    if (PL_op->op_private & (OPpASSIGN_COMMON)) {
	EXTEND_MORTAL(lastrelem - firstrelem + 1);
	for (relem = firstrelem; relem <= lastrelem; relem++) {
	    /*SUPPRESS 560*/
	    if ((sv = *relem)) {
d599 1
a599 1
		*relem = sv_mortalcopy(sv);
d601 1
a601 1
	}
a607 1

d615 1
a615 13
	    if (PL_op->op_private & OPpASSIGN_HASH) {
		switch (do_maybe_phash(ary, lelem, firstlelem, relem,
				       lastrelem))
		{
		case 0:
		    goto normal_array;
		case 1:
		    do_oddball((HV*)ary, relem, firstrelem);
		}
		relem = lastrelem + 1;
		break;
	    }
	normal_array:
d630 1
a630 1
			sv_2mortal(sv);
d635 1
a635 1
	case SVt_PVHV: {				/* normal hash */
d657 1
a657 1
			    sv_2mortal(tmpstr);
d662 21
a682 1
		    do_oddball(hash, relem, firstrelem);
d688 10
a697 4
	    if (SvIMMORTAL(sv)) {
		if (relem <= lastrelem)
		    relem++;
		break;
d731 1
a731 1
		    DIE(aTHX_ "No setreuid available");
d736 2
a737 2
	    PL_uid = PerlProc_getuid();
	    PL_euid = PerlProc_geteuid();
d760 1
a760 1
		    DIE(aTHX_ "No setregid available");
d765 2
a766 2
	    PL_gid = PerlProc_getgid();
	    PL_egid = PerlProc_getegid();
d810 2
a811 2
    I32 r_flags = REXEC_CHECKED;
    char *truebase;			/* Start of string  */
d819 1
a819 1
    I32 had_zerolen = 0;
d831 1
a831 1
	DIE(aTHX_ "panic: do_match");
d849 4
d854 2
a855 4

    /* XXXX What part of this is needed with true \G-support? */
    if ((global = pm->op_pmflags & PMf_GLOBAL)) {
	rx->startp[0] = -1;
d859 1
a859 6
		if (!(rx->reganch & ROPT_GPOS_SEEN))
		    rx->endp[0] = rx->startp[0] = mg->mg_len; 
		else if (rx->reganch & ROPT_ANCH_GPOS) {
		    r_flags |= REXEC_IGNOREPOS;
		    rx->endp[0] = rx->startp[0] = mg->mg_len; 
		}
d865 3
a867 6
    if ((gimme != G_ARRAY && !global && rx->nparens)
	    || SvTEMP(TARG) || PL_sawampersand)
	r_flags |= REXEC_COPY_STR;
    if (SvSCREAM(TARG)) 
	r_flags |= REXEC_SCREAM;

d874 2
a875 2
    if (global && rx->startp[0] != -1) {
	t = s = rx->endp[0] + truebase;
d879 1
a879 1
	    minmatch = had_zerolen;
d881 43
a923 11
    if (rx->reganch & RE_USE_INTUIT) {
	s = CALLREG_INTUIT_START(aTHX_ rx, TARG, s, strend, r_flags, NULL);

	if (!s)
	    goto nope;
	if ( (rx->reganch & ROPT_CHECK_ALL)
	     && !PL_sawampersand 
	     && ((rx->reganch & ROPT_NOSCAN)
		 || !((rx->reganch & RE_INTUIT_TAIL)
		      && (r_flags & REXEC_SCREAM))))
	    goto yup;
d925 2
a926 1
    if (CALLREGEXEC(aTHX_ rx, s, strend, truebase, minmatch, TARG, NULL, r_flags))
d955 2
a956 3
	    if ((rx->startp[i] != -1) && rx->endp[i] != -1 ) {
		len = rx->endp[i] - rx->startp[i];
		s = rx->startp[i] + truebase;
a957 4
		if ((pm->op_pmdynflags & PMdf_UTF8) && !IN_BYTE) {
		    SvUTF8_on(*SP);
		    sv_utf8_downgrade(*SP, TRUE);
		}
d961 4
a964 2
	    had_zerolen = (rx->startp[0] != -1
			   && rx->startp[0] == rx->endp[0]);
a965 1
	    r_flags |= REXEC_IGNOREPOS | REXEC_NOT_FIRST;
d982 2
a983 2
	    if (rx->startp[0] != -1) {
		mg->mg_len = rx->endp[0];
d994 1
a994 1
yup:					/* Confirmed by INTUIT */
d998 1
d1002 2
a1003 4
    if (RX_MATCH_COPIED(rx))
	Safefree(rx->subbeg);
    RX_MATCH_COPIED_off(rx);
    rx->subbeg = Nullch;
d1006 3
a1008 3
	rx->startp[0] = s - truebase;
	rx->endp[0] = s - truebase + rx->minlen;
	rx->sublen = strend - truebase;
d1010 1
a1010 1
    } 
d1012 1
a1012 1
	I32 off;
d1014 5
a1018 9
	rx->subbeg = savepvn(t, strend - t);
	rx->sublen = strend - t;
	RX_MATCH_COPIED_on(rx);
	off = rx->startp[0] = s - t;
	rx->endp[0] = off + rx->minlen;
    }
    else {			/* startp/endp are used by @@- @@+. */
	rx->startp[0] = s - truebase;
	rx->endp[0] = s - truebase + rx->minlen;
a1019 1
    rx->nparens = rx->lastparen = 0;	/* used by @@- and @@+ */
d1024 3
d1042 1
a1042 1
Perl_do_readline(pTHX)
d1054 1
a1054 1
    if ((mg = SvTIED_mg((SV*)PL_last_in_gv, 'q'))) {
d1059 1
a1059 1
	call_method("READLINE", gimme);
d1072 1
a1074 1
			IoFLAGS(io) &= ~IOf_START;
d1085 1
a1176 5
#ifdef MACOS_TRADITIONAL
		sv_setpv(tmpcmd, "glob ");
		sv_catsv(tmpcmd, tmpglob);
		sv_catpv(tmpcmd, " |");
#else
a1207 1
#endif /* MACOS_TRADITIONAL */
a1216 9
	else if (ckWARN(WARN_IO)	/* stdout/stderr or other write fh */
		 && (IoTYPE(io) == '>' || fp == PerlIO_stdout()
		     || fp == PerlIO_stderr()))
	{
	    SV* sv = sv_newmortal();
	    gv_efullname3(sv, PL_last_in_gv, Nullch);
	    Perl_warner(aTHX_ WARN_IO, "Filehandle %s opened only for output",
			SvPV_nolen(sv));
	}
d1219 2
a1220 8
	if (ckWARN2(WARN_GLOB,WARN_CLOSED) && io && !(IoFLAGS(io) & IOf_START)) {
	    if (type == OP_GLOB)
		Perl_warner(aTHX_ WARN_GLOB,
			    "glob failed (can't start child: %s)",
			    Strerror(errno));
	    else
		report_closed_fh(PL_last_in_gv, io, "readline", "filehandle");
	}
d1246 1
a1246 1
/* delay EOF state for a snarfed empty file */
d1248 4
a1251 3
    (gimme != G_SCALAR || SvCUR(sv)					\
     || !RsSNARF(rs) || (IoFLAGS(io) & IOf_NOLINE)			\
     || ((IoFLAGS(io) |= IOf_NOLINE), FALSE))
d1263 1
d1266 4
a1269 5
		if (!do_close(PL_last_in_gv, FALSE) && ckWARN(WARN_GLOB)) {
		    Perl_warner(aTHX_ WARN_GLOB,
			   "glob failed (child exited with status %d%s)",
			   (int)(STATUS_CURRENT >> 8),
			   (STATUS_CURRENT & 0x80) ? ", core dumped" : "");
d1300 1
a1300 1
	    if (*tmps && PerlLIO_lstat(SvPVX(sv), &PL_statbuf) < 0) {
d1363 1
a1363 1
	    DIE(aTHX_ "Can't localize pseudo-hash element");
d1375 1
a1375 1
		DIE(aTHX_ PL_no_helem, SvPV(keysv, n_a));
a1470 1
    SV **itersvp;
d1475 1
a1475 1
	DIE(aTHX_ "panic: pp_iter");
a1476 1
    itersvp = CxITERVAR(cx);
d1487 3
a1489 1
		if (SvREFCNT(*itersvp) == 1 && !SvMAGICAL(*itersvp)) {
d1491 1
a1491 1
		    sv_setsv(*itersvp, cur);
d1499 2
a1500 2
		    SvREFCNT_dec(*itersvp);
		    *itersvp = newSVsv(cur);
d1515 3
a1517 1
	if (SvREFCNT(*itersvp) == 1 && !SvMAGICAL(*itersvp)) {
d1519 1
a1519 1
	    sv_setiv(*itersvp, cx->blk_loop.iterix++);
d1527 2
a1528 2
	    SvREFCNT_dec(*itersvp);
	    *itersvp = newSViv(cx->blk_loop.iterix++);
d1537 1
a1537 1
    SvREFCNT_dec(*itersvp);
d1539 3
a1541 3
    if ((sv = SvMAGICAL(av)
	      ? *av_fetch(av, ++cx->blk_loop.iterix, FALSE) 
	      : AvARRAY(av)[++cx->blk_loop.iterix]))
d1561 1
a1561 1
	LvTARGLEN(lv) = (STRLEN)UV_MAX;
d1565 1
a1565 1
    *itersvp = SvREFCNT_inc(sv);
d1587 1
a1587 1
    I32 r_flags;
d1592 2
d1606 1
a1606 1
	DIE(aTHX_ PL_no_modify);
d1620 1
a1620 1
	DIE(aTHX_ "panic: do_subst");
d1631 5
a1635 1
    r_flags = (rx->nparens || SvTEMP(TARG) || PL_sawampersand)
a1636 2
    if (SvSCREAM(TARG))
	r_flags |= REXEC_SCREAM;
d1642 37
a1678 13
    if (rx->reganch & RE_USE_INTUIT) {
	s = CALLREG_INTUIT_START(aTHX_ rx, TARG, s, strend, r_flags, NULL);

	if (!s)
	    goto nope;
	/* How to do it in subst? */
/*	if ( (rx->reganch & ROPT_CHECK_ALL)
	     && !PL_sawampersand 
	     && ((rx->reganch & ROPT_NOSCAN)
		 || !((rx->reganch & RE_INTUIT_TAIL)
		      && (r_flags & REXEC_SCREAM))))
	    goto yup;
*/
d1688 1
a1688 1
    if (c && clen <= rx->minlen && (once || !(r_flags & REXEC_COPY_STR))
d1690 1
a1690 3
	if (!CALLREGEXEC(aTHX_ rx, s, strend, orig, 0, TARG, NULL,
			 r_flags | REXEC_CHECKED))
	{
d1706 7
a1712 2
	    m = orig + rx->startp[0];
	    d = orig + rx->endp[0];
d1728 1
a1728 1
	    else if ((i = m - s)) {	/* faster from front */
d1753 1
a1753 1
		    DIE(aTHX_ "Substitution loop");
d1755 1
a1755 1
		m = rx->startp[0] + orig;
d1757 1
a1757 1
		if ((i = m - s)) {
d1766 3
a1768 5
		s = rx->endp[0] + orig;
	    } while (CALLREGEXEC(aTHX_ rx, s, strend, orig, s == m,
				 TARG, NULL,
				 /* don't match same null twice */
				 REXEC_NOT_FIRST|REXEC_IGNOREPOS));
d1790 1
a1790 3
    if (CALLREGEXEC(aTHX_ rx, s, strend, orig, 0, TARG, NULL,
		    r_flags | REXEC_CHECKED))
    {
a1805 1
	r_flags |= REXEC_IGNOREPOS | REXEC_NOT_FIRST;
d1808 1
a1808 1
		DIE(aTHX_ "Substitution loop");
d1810 1
a1810 1
	    if (RX_MATCH_COPIED(rx) && rx->subbeg != orig) {
d1813 1
a1813 1
		orig = rx->subbeg;
d1817 1
a1817 1
	    m = rx->startp[0] + orig;
d1819 1
a1819 1
	    s = rx->endp[0] + orig;
d1824 1
a1824 1
	} while (CALLREGEXEC(aTHX_ rx, s, strend, orig, s == m, TARG, NULL, r_flags));
d1849 2
d1889 1
a1889 1
	SAVEVPTR(PL_curpm);
d1907 1
a1907 1
    SV *sv;
d1910 1
d1916 1
a1916 1
	    if (cx->blk_sub.cv && CvDEPTH(cx->blk_sub.cv) > 1) {
d1921 1
a1921 3
		}
		else {
		    sv = SvREFCNT_inc(TOPs);	/* FREETMPS could clobber it */
d1923 1
a1923 2
		    *MARK = sv_mortalcopy(sv);
		    SvREFCNT_dec(sv);
d1925 1
a1925 2
	    }
	    else
d1927 1
a1927 2
	}
	else {
d1943 1
a1943 154
    POPSUB(cx,sv);	/* Stack values are safe: release CV and @@_ ... */
    PL_curpm = newpm;	/* ... and pop $1 et al */

    LEAVE;
    LEAVESUB(sv);
    return pop_return();
}

/* This duplicates the above code because the above code must not
 * get any slower by more conditions */
PP(pp_leavesublv)
{
    djSP;
    SV **mark;
    SV **newsp;
    PMOP *newpm;
    I32 gimme;
    register PERL_CONTEXT *cx;
    SV *sv;

    POPBLOCK(cx,newpm);
 
    TAINT_NOT;

    if (cx->blk_sub.lval & OPpENTERSUB_INARGS) {
	/* We are an argument to a function or grep().
	 * This kind of lvalueness was legal before lvalue
	 * subroutines too, so be backward compatible:
	 * cannot report errors.  */

	/* Scalar context *is* possible, on the LHS of -> only,
	 * as in f()->meth().  But this is not an lvalue. */
	if (gimme == G_SCALAR)
	    goto temporise;
	if (gimme == G_ARRAY) {
	    if (!CvLVALUE(cx->blk_sub.cv))
		goto temporise_array;
	    EXTEND_MORTAL(SP - newsp);
	    for (mark = newsp + 1; mark <= SP; mark++) {
		if (SvTEMP(*mark))
		    /* empty */ ;
		else if (SvFLAGS(*mark) & (SVs_PADTMP | SVf_READONLY))
		    *mark = sv_mortalcopy(*mark);
		else {
		    /* Can be a localized value subject to deletion. */
		    PL_tmps_stack[++PL_tmps_ix] = *mark;
		    (void)SvREFCNT_inc(*mark);
		}
	    }
	}
    }
    else if (cx->blk_sub.lval) {     /* Leave it as it is if we can. */
	/* Here we go for robustness, not for speed, so we change all
	 * the refcounts so the caller gets a live guy. Cannot set
	 * TEMP, so sv_2mortal is out of question. */
	if (!CvLVALUE(cx->blk_sub.cv)) {
	    POPSUB(cx,sv);
	    PL_curpm = newpm;
	    LEAVE;
	    LEAVESUB(sv);
	    DIE(aTHX_ "Can't modify non-lvalue subroutine call");
	}
	if (gimme == G_SCALAR) {
	    MARK = newsp + 1;
	    EXTEND_MORTAL(1);
	    if (MARK == SP) {
		if (SvFLAGS(TOPs) & (SVs_TEMP | SVs_PADTMP | SVf_READONLY)) {
		    POPSUB(cx,sv);
		    PL_curpm = newpm;
		    LEAVE;
		    LEAVESUB(sv);
		    DIE(aTHX_ "Can't return a %s from lvalue subroutine",
			SvREADONLY(TOPs) ? "readonly value" : "temporary");
		}
		else {                  /* Can be a localized value
					 * subject to deletion. */
		    PL_tmps_stack[++PL_tmps_ix] = *mark;
		    (void)SvREFCNT_inc(*mark);
		}
	    }
	    else {			/* Should not happen? */
		POPSUB(cx,sv);
		PL_curpm = newpm;
		LEAVE;
		LEAVESUB(sv);
		DIE(aTHX_ "%s returned from lvalue subroutine in scalar context",
		    (MARK > SP ? "Empty array" : "Array"));
	    }
	    SP = MARK;
	}
	else if (gimme == G_ARRAY) {
	    EXTEND_MORTAL(SP - newsp);
	    for (mark = newsp + 1; mark <= SP; mark++) {
		if (SvFLAGS(*mark) & (SVs_TEMP | SVs_PADTMP | SVf_READONLY)) {
		    /* Might be flattened array after $#array =  */
		    PUTBACK;
		    POPSUB(cx,sv);
		    PL_curpm = newpm;
		    LEAVE;
		    LEAVESUB(sv);
		    DIE(aTHX_ "Can't return %s from lvalue subroutine",
			(*mark != &PL_sv_undef)
			? (SvREADONLY(TOPs)
			    ? "a readonly value" : "a temporary")
			: "an uninitialized value");
		}
		else {
		    /* Can be a localized value subject to deletion. */
		    PL_tmps_stack[++PL_tmps_ix] = *mark;
		    (void)SvREFCNT_inc(*mark);
		}
	    }
	}
    }
    else {
	if (gimme == G_SCALAR) {
	  temporise:
	    MARK = newsp + 1;
	    if (MARK <= SP) {
		if (cx->blk_sub.cv && CvDEPTH(cx->blk_sub.cv) > 1) {
		    if (SvTEMP(TOPs)) {
			*MARK = SvREFCNT_inc(TOPs);
			FREETMPS;
			sv_2mortal(*MARK);
		    }
		    else {
			sv = SvREFCNT_inc(TOPs); /* FREETMPS could clobber it */
			FREETMPS;
			*MARK = sv_mortalcopy(sv);
			SvREFCNT_dec(sv);
		    }
		}
		else
		    *MARK = SvTEMP(TOPs) ? TOPs : sv_mortalcopy(TOPs);
	    }
	    else {
		MEXTEND(MARK, 0);
		*MARK = &PL_sv_undef;
	    }
	    SP = MARK;
	}
	else if (gimme == G_ARRAY) {
	  temporise_array:
	    for (MARK = newsp + 1; MARK <= SP; MARK++) {
		if (!SvTEMP(*MARK)) {
		    *MARK = sv_mortalcopy(*MARK);
		    TAINT_NOT;  /* Each item is independent */
		}
	    }
	}
    }
    PUTBACK;
    
    POPSUB(cx,sv);	/* Stack values are safe: release CV and @@_ ... */
a1946 1
    LEAVESUB(sv);
a1949 1

d1951 1
a1951 1
S_get_db_sub(pTHX_ SV **svp, CV *cv)
d1974 2
a1975 2
	(void)SvUPGRADE(dbsv, SVt_PVIV);
	(void)SvIOK_on(dbsv);
d1977 1
a1977 1
	SvIVX(dbsv) = PTR2IV(cv);	/* Do it the quickest way  */
d1997 1
a1997 1
	DIE(aTHX_ "Not a CODE reference");
d2016 1
a2016 1
		DIE(aTHX_ PL_no_usym, "a subroutine");
d2018 2
a2019 2
		DIE(aTHX_ PL_no_symref, sym, "a subroutine");
	    cv = get_cv(sym, TRUE);
a2021 4
	{
	    SV **sp = &sv;		/* Used in tryAMAGICunDEREF macro. */
	    tryAMAGICunDEREF(to_cv);
	}	
d2028 1
a2028 1
	DIE(aTHX_ "Not a CODE reference");
d2034 1
a2034 6
	    cv = sv_2cv(sv, &stash, &gv, FALSE);
	if (!cv) {
	    ENTER;
	    SAVETMPS;
	    goto try_autoload;
	}
d2042 3
d2051 1
a2051 2
	    DIE(aTHX_ "Undefined subroutine called");

d2055 1
d2058 1
a2058 3
	else {
try_autoload:
	    if ((autogv = gv_autoload4(GvSTASH(gv), GvNAME(gv), GvNAMELEN(gv),
d2060 3
a2062 9
	    {
		cv = GvCV(autogv);
	    }
	    /* sorry */
	    else {
		sub_name = sv_newmortal();
		gv_efullname3(sub_name, gv, Nullch);
		DIE(aTHX_ "Undefined subroutine &%s called", SvPVX(sub_name));
	    }
d2064 4
a2067 3
	if (!cv)
	    DIE(aTHX_ "Not a CODE reference");
	goto retry;
d2071 1
a2071 1
    if ((PL_op->op_private & OPpENTERSUB_DB) && GvCV(PL_DBsub) && !CvNODEBUG(cv)) {
d2073 2
a2074 3
	if (!cv)
	    DIE(aTHX_ "No DBsub routine");
    }
d2091 2
a2092 7
		AV *av = (AV*)PL_curpad[0];
		if (hasargs || !av || AvFILLp(av) < 0
		    || !(sv = AvARRAY(av)[0]))
		{
		    MUTEX_UNLOCK(CvMUTEXP(cv));
		    DIE(aTHX_ "no argument for locked method call");
		}
d2114 1
a2114 1
	    DEBUG_S(PerlIO_printf(Perl_debug_log, "%p: pp_entersub lock %p\n",
d2117 1
a2117 1
	    SAVEDESTRUCTOR_X(Perl_unlock_condpair, sv);
d2156 1
a2156 1
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
d2162 1
a2162 1
		SAVEDESTRUCTOR_X(unset_cvowner, (void*) cv);
d2170 1
a2170 1
		DEBUG_S(PerlIO_printf(Perl_debug_log,
d2174 1
a2174 2
	    }
	    else {
d2179 1
a2179 1
		DEBUG_S((PerlIO_printf(Perl_debug_log,
d2197 1
a2197 1
			PerlIO_printf(Perl_debug_log, "depth %ld != 0\n",
d2199 1
a2199 1
	    SAVEDESTRUCTOR_X(unset_cvowner, (void*) cv);
a2204 1
#ifdef PERL_XSUB_OLDSTYLE
d2206 1
a2206 1
	    I32 (*fp3)(int,int,int);
d2215 1
a2215 1
	    fp3 = (I32(*)(int,int,int))CvXSUB(cv);
d2221 1
a2221 3
	else
#endif /* PERL_XSUB_OLDSTYLE */
	{
d2247 4
a2250 3
	    /* We assume first XSUB in &DB::sub is the called one. */
	    if (PL_curcopdb) {
		SAVEVPTR(PL_curcop);
d2255 1
a2255 1
	    (void)(*CvXSUB(cv))(aTHXo_ cv);
a2285 1
	    PERL_STACK_OVERFLOW_CHECK();
a2290 1
		I32 names_fill = AvFILLp((AV*)svp[0]);
d2293 1
a2293 1
		    if (names_fill >= ix && svp[ix] != &PL_sv_undef) {
a2309 3
		    else if (IS_PADGV(oldpad[ix]) || IS_PADCONST(oldpad[ix])) {
			av_store(newpad, ix, sv = SvREFCNT_inc(oldpad[ix]));
		    }
d2338 1
a2338 1
	SAVEVPTR(PL_curpad);
d2348 1
a2348 1
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
a2352 2
		/* @@_ is normally not REAL--this should only ever
		 * happen when DB::sub() calls things that modify @@_ */
a2354 1
		AvREIFY_on(av);
d2389 1
a2389 1
	if (CvDEPTH(cv) == 100 && ckWARN(WARN_RECURSION)
d2393 1
a2393 1
	DEBUG_S(PerlIO_printf(Perl_debug_log,
d2401 1
a2401 1
Perl_sub_crush_depth(pTHX_ CV *cv)
d2404 1
a2404 1
	Perl_warner(aTHX_ WARN_RECURSION, "Deep recursion on anonymous subroutine");
d2408 1
a2408 2
	Perl_warner(aTHX_ WARN_RECURSION, "Deep recursion on subroutine \"%s\"", 
		SvPVX(tmpstr));
d2431 1
a2431 1
		DIE(aTHX_ PL_no_aelem, elem);
d2455 1
a2455 1
Perl_vivify_ref(pTHX_ SV *sv, U32 to_what)
d2461 1
a2461 1
	    Perl_croak(aTHX_ PL_no_modify);
a2487 27
    SV* sv = TOPs;

    if (SvROK(sv)) {
	SV* rsv = SvRV(sv);
	if (SvTYPE(rsv) == SVt_PVCV) {
	    SETs(rsv);
	    RETURN;
	}
    }

    SETs(method_common(sv, Null(U32*)));
    RETURN;
}

PP(pp_method_named)
{
    djSP;
    SV* sv = cSVOP->op_sv;
    U32 hash = SvUVX(sv);

    XPUSHs(method_common(sv, &hash));
    RETURN;
}

STATIC SV *
S_method_common(pTHX_ SV* meth, U32* hashp)
{
a2492 1
    STRLEN namelen;
d2496 9
a2504 1
    name = SvPV(meth, namelen);
d2506 1
a2506 1

d2520 4
a2523 10
	    if (!packname || 
		((*(U8*)packname >= 0xc0 && DO_UTF8(sv))
		    ? !isIDFIRST_utf8((U8*)packname)
		    : !isIDFIRST(*packname)
		))
	    {
		Perl_croak(aTHX_ "Can't call method \"%s\" %s", name,
			   SvOK(sv) ? "without a package or object reference"
				    : "on an undefined value");
	    }
d2530 2
a2531 7
    if (!ob || !(SvOBJECT(ob)
		 || (SvTYPE(ob) == SVt_PVGV && (ob = (SV*)GvIO((GV*)ob))
		     && SvOBJECT(ob))))
    {
	Perl_croak(aTHX_ "Can't call method \"%s\" on unblessed reference",
		   name);
    }
a2535 11
    /* shortcut for simple names */
    if (hashp) {
	HE* he = hv_fetch_ent(stash, meth, 0, *hashp);
	if (he) {
	    gv = (GV*)HeVAL(he);
	    if (isGV(gv) && GvCV(gv) &&
		(!GvCVGEN(gv) || GvCVGEN(gv) == PL_sub_generation))
		return (SV*)GvCV(gv);
	}
    }

d2549 1
a2549 1
	    packname = sep ? CopSTASHPV(PL_curcop) : HvNAME(stash);
d2556 2
a2557 3
	Perl_croak(aTHX_
		   "Can't locate object method \"%s\" via package \"%s\"",
		   leaf, packname);
d2559 2
a2560 1
    return isGV(gv) ? (SV*)GvCV(gv) : (SV*)gv;
a2562 21
#ifdef USE_THREADS
static void
unset_cvowner(pTHXo_ void *cvarg)
{
    register CV* cv = (CV *) cvarg;
#ifdef DEBUGGING
    dTHR;
#endif /* DEBUGGING */

    DEBUG_S((PerlIO_printf(Perl_debug_log, "%p unsetting CvOWNER of %p:%s\n",
			   thr, cv, SvPEEK((SV*)cv))));
    MUTEX_LOCK(CvMUTEXP(cv));
    DEBUG_S(if (CvDEPTH(cv) != 0)
		PerlIO_printf(Perl_debug_log, "depth %ld != 0\n",
			      CvDEPTH(cv)););
    assert(thr == CvOWNER(cv));
    CvOWNER(cv) = 0;
    MUTEX_UNLOCK(CvMUTEXP(cv));
    SvREFCNT_dec(cv);
}
#endif /* USE_THREADS */
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d22 4
d34 1
a34 1
    dSP;
d50 1
a50 1
    dSP;
d78 1
a78 1
    dSP; dTARGET;
d83 1
a83 1
    if (SvUTF8(TOPs))
a84 2
    else
	SvUTF8_off(TARG);
d91 1
a91 1
    dSP;
d98 1
a98 1
    dSP;
d109 1
a109 1
    dSP; dPOPTOPssrl;
d124 1
a124 1
    dSP;
d144 1
a144 1
  dSP; dATARGET; tryAMAGICbin(concat,opASSIGN);
d147 2
a148 1
    SV* rcopy = Nullsv;
d150 6
a155 19
    if (SvGMAGICAL(left))
        mg_get(left);
    if (TARG == right && SvGMAGICAL(right))
        mg_get(right);

    if (TARG == right && left != right)
	/* Clone since otherwise we cannot prepend. */
	rcopy = sv_2mortal(newSVsv(right));

    if (TARG != left)
	sv_setsv(TARG, left);

    if (TARG == right) {
	if (left == right) {
	    /*  $right = $right . $right; */
	    STRLEN rlen;
	    char *rpv = SvPV(right, rlen);

	    sv_catpvn(TARG, rpv, rlen);
d157 1
a157 2
	else /* $right = $left  . $right; */
	    sv_catsv(TARG, rcopy);
d159 5
a163 6
    else {
	if (!SvOK(TARG)) /* Avoid warning when concatenating to undef. */
	    sv_setpv(TARG, "");
	/* $other = $left . $right; */
	/* $left  = $left . $right; */
	sv_catsv(TARG, right);
d165 2
a166 1

d168 20
a187 8
    if ((SvIOK(right) || SvNOK(right)) && ckWARN(WARN_Y2K)) {
	STRLEN n;
	char *s = SvPV(TARG,n);
	if (n >= 2 && s[n-2] == '1' && s[n-1] == '9'
	    && (n == 2 || !isDIGIT(s[n-3])))
	{
	    Perl_warner(aTHX_ WARN_Y2K, "Possible Y2K bug: %s",
			"about to append an integer to '19'");
d190 2
a191 2
#endif

d199 1
a199 1
    dSP; dTARGET;
d233 1
a233 1
    dSP; tryAMAGICbinSET(eq,0);
d243 1
a243 1
    dSP;
d260 1
a260 1
    dSP;
d271 1
a271 1
    dSP; dATARGET; tryAMAGICbin(add,opASSIGN);
d281 1
a281 1
    dSP;
d295 1
a295 1
    dSP; dMARK; dTARGET;
d305 1
a305 1
    dSP;
d326 1
a326 1
    dSP; dMARK; dORIGMARK;
a337 1
      had_magic:
d360 6
a365 4
        if ((GvEGV(gv)) && (mg = SvTIED_mg((SV*)GvEGV(gv),'q')))
            goto had_magic;
	if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	    report_evil_fh(gv, io, PL_op->op_type);
d372 5
a376 13
		/* integrate with report_evil_fh()? */
	        char *name = NULL;
		if (isGV(gv)) {
		    SV* sv = sv_newmortal();
		    gv_efullname4(sv, gv, Nullch, FALSE);
		    name = SvPV_nolen(sv);
		}
		if (name && *name)
		  Perl_warner(aTHX_ WARN_IO,
			      "Filehandle %s opened only for input", name);
		else
		    Perl_warner(aTHX_ WARN_IO,
				"Filehandle opened only for input");
d378 2
a379 2
	    else if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
		report_evil_fh(gv, io, PL_op->op_type);
d430 1
a430 1
    dSP; dTOPss;
a443 6
	else if (LVRET) {
	    if (GIMME == G_SCALAR)
		Perl_croak(aTHX_ "Can't return array to lvalue scalar context");
	    SETs((SV*)av);
	    RETURN;
	}
a451 7
	    else if (LVRET) {
		if (GIMME == G_SCALAR)
		    Perl_croak(aTHX_ "Can't return array to lvalue"
			       " scalar context");
		SETs((SV*)av);
		RETURN;
	    }
d458 1
a458 1
		STRLEN len;
d477 1
a477 1
		sym = SvPV(sv,len);
d482 1
a482 4
		    if (!gv
			&& (!is_gv_magical(sym,len,0)
			    || !(gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PVAV))))
		    {
a483 1
		    }
a500 7
	    else if (LVRET) {
		if (GIMME == G_SCALAR)
		    Perl_croak(aTHX_ "Can't return array to lvalue"
			       " scalar context");
		SETs((SV*)av);
		RETURN;
	    }
d530 1
a530 1
    dSP; dTOPss;
a543 6
	else if (LVRET) {
	    if (GIMME == G_SCALAR)
		Perl_croak(aTHX_ "Can't return hash to lvalue scalar context");
	    SETs((SV*)hv);
	    RETURN;
	}
a551 7
	    else if (LVRET) {
		if (GIMME == G_SCALAR)
		    Perl_croak(aTHX_ "Can't return hash to lvalue"
			       " scalar context");
		SETs((SV*)hv);
		RETURN;
	    }
d558 1
a558 1
		STRLEN len;
d577 1
a577 1
		sym = SvPV(sv,len);
d582 1
a582 4
		    if (!gv
			&& (!is_gv_magical(sym,len,0)
			    || !(gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PVHV))))
		    {
a583 1
		    }
a600 7
	    else if (LVRET) {
		if (GIMME == G_SCALAR)
		    Perl_croak(aTHX_ "Can't return hash to lvalue"
			       " scalar context");
		SETs((SV*)hv);
		RETURN;
	    }
d711 1
a711 1
    dSP;
d922 1
a922 1
    dSP;
d932 1
a932 1
    dSP; dTARG;
d959 1
a959 1
	DIE(aTHX_ "panic: pp_match");
d996 1
a996 1
    if ((!global && rx->nparens)
d1015 1
a1015 2
    if (rx->reganch & RE_USE_INTUIT &&
	DO_UTF8(TARG) == ((rx->reganch & ROPT_UTF8) != 0)) {
d1024 1
a1024 2
		      && (r_flags & REXEC_SCREAM)))
	     && !SvROK(TARG))	/* Cannot trust since INTUIT cannot guess ^ */
d1277 1
a1277 1
		           IoTYPE(io) = IoTYPE_RDONLY;
d1331 1
a1331 1
		 && (IoTYPE(io) == IoTYPE_WRONLY || fp == PerlIO_stdout()
d1334 4
a1337 13
	    /* integrate with report_evil_fh()? */
	    char *name = NULL;
	    if (isGV(PL_last_in_gv)) { /* can this ever fail? */
		SV* sv = sv_newmortal();
		gv_efullname4(sv, PL_last_in_gv, Nullch, FALSE);
		name = SvPV_nolen(sv);
	    }
	    if (name && *name)
		Perl_warner(aTHX_ WARN_IO,
			    "Filehandle %s opened only for output", name);
	    else
		Perl_warner(aTHX_ WARN_IO,
			    "Filehandle opened only for output");
d1341 1
a1341 2
	if (ckWARN2(WARN_GLOB, WARN_CLOSED)
		&& (!io || !(IoFLAGS(io) & IOf_START))) {
d1347 1
a1347 1
		report_evil_fh(PL_last_in_gv, io, PL_op->op_type);
a1373 7
    /* This should not be marked tainted if the fp is marked clean */
#define MAYBE_TAINT_LINE(io, sv) \
    if (!(IoFLAGS(io) & IOf_UNTAINT)) { \
	TAINT;				\
	SvTAINTED_on(sv);		\
    }

d1377 2
a1378 1
     || (IoFLAGS(io) & IOf_NOLINE) || !RsSNARF(rs))
a1402 1
	    MAYBE_TAINT_LINE(io, sv);
d1405 5
a1409 1
	MAYBE_TAINT_LINE(io, sv);
a1410 1
	IoFLAGS(io) |= IOf_NOLINE;
d1454 1
a1454 1
    dSP;
d1475 1
a1475 1
    dSP;
d1480 1
a1480 1
    U32 lval = PL_op->op_flags & OPf_MOD || LVRET;
d1538 1
a1538 1
    dSP;
d1594 1
a1594 1
    dSP;
d1696 1
a1696 1
    dSP; dTARG;
d1699 1
a1699 1
    register SV *dstr, *rstr;
a1716 2
    bool do_utf8;
    STRLEN slen;
d1719 1
a1719 1
    rstr = (pm->op_pmflags & PMf_CONST) ? POPs : Nullsv;
d1725 1
a1725 4
    }
    do_utf8 = DO_UTF8(TARG);
    if (SvFAKE(TARG) && SvREADONLY(TARG))
	sv_force_normal(TARG);
d1743 1
a1743 1
	DIE(aTHX_ "panic: pp_subst");
d1746 3
a1748 4
    slen = do_utf8 ? utf8_length((U8*)s, (U8*)strend) : len;
    maxiters = 2 * slen + 10;	/* We can match twice at each
				   position, once with zero-length,
				   second time with non-zero. */
d1782 1
a1782 1
    c = rstr ? SvPV(rstr, clen) : Nullch;
a1785 1
	&& do_utf8 == DO_UTF8(rstr)
d1874 1
a1874 1
	(void)SvPOK_only_UTF8(TARG);
a1888 2
	bool isutf8;

a1896 2
	if (do_utf8)
	    SvUTF8_on(dstr);
d1920 1
a1920 1
		sv_catsv(dstr, rstr);
a1930 1
	isutf8 = DO_UTF8(dstr);
a1938 2
	if (isutf8)
	    SvUTF8_on(TARG);
d1957 1
a1957 1
    dSP;
d1998 1
a1998 1
    dSP;
d2056 1
a2056 1
    dSP;
d2209 1
d2223 1
a2223 3
	    SV *tmp = newRV((SV*)cv);
	    sv_setsv(dbsv, tmp);
	    SvREFCNT_dec(tmp);
d2244 1
a2244 1
    dSP; dPOPss;
a2645 1
	    cx->blk_sub.oldcurpad = PL_curpad;
d2701 1
a2701 1
    dSP;
d2703 1
a2703 1
    IV elem = POPi;
d2705 1
a2705 1
    U32 lval = PL_op->op_flags & OPf_MOD || LVRET;
d2774 1
a2774 1
    dSP;
d2791 1
a2791 1
    dSP;
a2813 3
    if (!sv)
	Perl_croak(aTHX_ "Can't call method \"%s\" on an undefined value", name);

d2827 2
a2828 2
	    if (!packname ||
		((UTF8_IS_START(*packname) && DO_UTF8(sv))
a2869 1
	GV* gv;
d2885 3
a2887 12
	gv = gv_fetchpv(packname, 0, SVt_PVHV);
	if (gv && isGV(gv)) {
	    Perl_croak(aTHX_
		       "Can't locate object method \"%s\" via package \"%s\"",
		       leaf, packname);
	}
	else {
	    Perl_croak(aTHX_
		       "Can't locate object method \"%s\" via package \"%s\""
		       " (perhaps you forgot to load \"%s\"?)",
		       leaf, packname, packname);
	}
d2897 3
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
d24 3
a26 3
#ifdef USE_5005THREADS
static void unset_cvowner(pTHX_ void *cvarg);
#endif /* USE_5005THREADS */
d75 8
a82 1
    sv_copypv(TARG,TOPs);
d145 24
a168 20
    STRLEN llen;
    char* lpv;
    bool lbyte;
    STRLEN rlen;
    char* rpv = SvPV(right, rlen);	/* mg_get(right) happens here */
    bool rbyte = !SvUTF8(right);

    if (TARG == right && right != left) {
	right = sv_2mortal(newSVpvn(rpv, rlen));
	rpv = SvPV(right, rlen);	/* no point setting UTF8 here */
    }

    if (TARG != left) {
	lpv = SvPV(left, llen);		/* mg_get(left) may happen here */
	lbyte = !SvUTF8(left);
	sv_setpvn(TARG, lpv, llen);
	if (!lbyte)
	    SvUTF8_on(TARG);
	else
	    SvUTF8_off(TARG);
d170 6
a175 7
    else { /* TARG == left */
	if (SvGMAGICAL(left))
	    mg_get(left);		/* or mg_get(left) may happen here */
	if (!SvOK(TARG))
	    sv_setpv(left, "");
	lpv = SvPV_nomg(left, llen);
	lbyte = !SvUTF8(left);
d179 5
a183 3
    if ((SvIOK(right) || SvNOK(right)) && ckWARN(WARN_Y2K) && SvOK(TARG)) {
	if (llen >= 2 && lpv[llen - 2] == '1' && lpv[llen - 1] == '9'
	    && (llen == 2 || !isDIGIT(lpv[llen - 3])))
d185 1
a185 1
	    Perl_warner(aTHX_ packWARN(WARN_Y2K), "Possible Y2K bug: %s",
a190 10
    if (lbyte != rbyte) {
	if (lbyte)
	    sv_utf8_upgrade_nomg(TARG);
	else {
	    sv_utf8_upgrade_nomg(right);
	    rpv = SvPV(right, rlen);
	}
    }
    sv_catpvn_nomg(TARG, rpv, rlen);

d217 1
a217 1
	if (SvROK(PL_last_in_gv) && SvTYPE(SvRV(PL_last_in_gv)) == SVt_PVGV)
a232 57
#ifndef NV_PRESERVES_UV
    if (SvROK(TOPs) && SvROK(TOPm1s)) {
        SP--;
	SETs(boolSV(SvRV(TOPs) == SvRV(TOPp1s)));
	RETURN;
    }
#endif
#ifdef PERL_PRESERVE_IVUV
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	/* Unless the left argument is integer in range we are going
	   to have to use NV maths. Hence only attempt to coerce the
	   right argument if we know the left is integer.  */
      SvIV_please(TOPm1s);
	if (SvIOK(TOPm1s)) {
	    bool auvok = SvUOK(TOPm1s);
	    bool buvok = SvUOK(TOPs);
	
	    if (auvok == buvok) { /* ## IV == IV or UV == UV ## */
                /* Casting IV to UV before comparison isn't going to matter
                   on 2s complement. On 1s complement or sign&magnitude
                   (if we have any of them) it could to make negative zero
                   differ from normal zero. As I understand it. (Need to
                   check - is negative zero implementation defined behaviour
                   anyway?). NWC  */
		UV buv = SvUVX(POPs);
		UV auv = SvUVX(TOPs);
		
		SETs(boolSV(auv == buv));
		RETURN;
	    }
	    {			/* ## Mixed IV,UV ## */
                SV *ivp, *uvp;
		IV iv;
		
		/* == is commutative so doesn't matter which is left or right */
		if (auvok) {
		    /* top of stack (b) is the iv */
                    ivp = *SP;
                    uvp = *--SP;
                } else {
                    uvp = *SP;
                    ivp = *--SP;
                }
                iv = SvIVX(ivp);
                if (iv < 0) {
                    /* As uv is a UV, it's >0, so it cannot be == */
                    SETs(&PL_sv_no);
                    RETURN;
                }
		/* we know iv is >= 0 */
		SETs(boolSV((UV)iv == SvUVX(uvp)));
		RETURN;
	    }
	}
    }
#endif
d243 1
a243 1
    if (SvTYPE(TOPs) > SVt_PVLV)
d245 2
a246 2
    if (!SvREADONLY(TOPs) && SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)
        && SvIVX(TOPs) != IV_MAX)
d251 1
a251 1
    else /* Do all the PERL_PRESERVE_IVUV conditionals in sv_inc */
d270 1
a270 148
    dSP; dATARGET; bool useleft; tryAMAGICbin(add,opASSIGN);
    useleft = USE_LEFT(TOPm1s);
#ifdef PERL_PRESERVE_IVUV
    /* We must see if we can perform the addition with integers if possible,
       as the integer code detects overflow while the NV code doesn't.
       If either argument hasn't had a numeric conversion yet attempt to get
       the IV. It's important to do this now, rather than just assuming that
       it's not IOK as a PV of "9223372036854775806" may not take well to NV
       addition, and an SV which is NOK, NV=6.0 ought to be coerced to
       integer in case the second argument is IV=9223372036854775806
       We can (now) rely on sv_2iv to do the right thing, only setting the
       public IOK flag if the value in the NV (or PV) slot is truly integer.

       A side effect is that this also aggressively prefers integer maths over
       fp maths for integer values.

       How to detect overflow?

       C 99 section 6.2.6.1 says

       The range of nonnegative values of a signed integer type is a subrange
       of the corresponding unsigned integer type, and the representation of
       the same value in each type is the same. A computation involving
       unsigned operands can never overflow, because a result that cannot be
       represented by the resulting unsigned integer type is reduced modulo
       the number that is one greater than the largest value that can be
       represented by the resulting type.

       (the 9th paragraph)

       which I read as "unsigned ints wrap."

       signed integer overflow seems to be classed as "exception condition"

       If an exceptional condition occurs during the evaluation of an
       expression (that is, if the result is not mathematically defined or not
       in the range of representable values for its type), the behavior is
       undefined.

       (6.5, the 5th paragraph)

       I had assumed that on 2s complement machines signed arithmetic would
       wrap, hence coded pp_add and pp_subtract on the assumption that
       everything perl builds on would be happy.  After much wailing and
       gnashing of teeth it would seem that irix64 knows its ANSI spec well,
       knows that it doesn't need to, and doesn't.  Bah.  Anyway, the all-
       unsigned code below is actually shorter than the old code. :-)
    */

    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	/* Unless the left argument is integer in range we are going to have to
	   use NV maths. Hence only attempt to coerce the right argument if
	   we know the left is integer.  */
	register UV auv = 0;
	bool auvok = FALSE;
	bool a_valid = 0;

	if (!useleft) {
	    auv = 0;
	    a_valid = auvok = 1;
	    /* left operand is undef, treat as zero. + 0 is identity,
	       Could SETi or SETu right now, but space optimise by not adding
	       lots of code to speed up what is probably a rarish case.  */
	} else {
	    /* Left operand is defined, so is it IV? */
	    SvIV_please(TOPm1s);
	    if (SvIOK(TOPm1s)) {
		if ((auvok = SvUOK(TOPm1s)))
		    auv = SvUVX(TOPm1s);
		else {
		    register IV aiv = SvIVX(TOPm1s);
		    if (aiv >= 0) {
			auv = aiv;
			auvok = 1;	/* Now acting as a sign flag.  */
		    } else { /* 2s complement assumption for IV_MIN */
			auv = (UV)-aiv;
		    }
		}
		a_valid = 1;
	    }
	}
	if (a_valid) {
	    bool result_good = 0;
	    UV result;
	    register UV buv;
	    bool buvok = SvUOK(TOPs);
	
	    if (buvok)
		buv = SvUVX(TOPs);
	    else {
		register IV biv = SvIVX(TOPs);
		if (biv >= 0) {
		    buv = biv;
		    buvok = 1;
		} else
		    buv = (UV)-biv;
	    }
	    /* ?uvok if value is >= 0. basically, flagged as UV if it's +ve,
	       else "IV" now, independent of how it came in.
	       if a, b represents positive, A, B negative, a maps to -A etc
	       a + b =>  (a + b)
	       A + b => -(a - b)
	       a + B =>  (a - b)
	       A + B => -(a + b)
	       all UV maths. negate result if A negative.
	       add if signs same, subtract if signs differ. */

	    if (auvok ^ buvok) {
		/* Signs differ.  */
		if (auv >= buv) {
		    result = auv - buv;
		    /* Must get smaller */
		    if (result <= auv)
			result_good = 1;
		} else {
		    result = buv - auv;
		    if (result <= buv) {
			/* result really should be -(auv-buv). as its negation
			   of true value, need to swap our result flag  */
			auvok = !auvok;
			result_good = 1;
		    }
		}
	    } else {
		/* Signs same */
		result = auv + buv;
		if (result >= auv)
		    result_good = 1;
	    }
	    if (result_good) {
		SP--;
		if (auvok)
		    SETu( result );
		else {
		    /* Negate result */
		    if (result <= (UV)IV_MIN)
			SETi( -(IV)result );
		    else {
			/* result valid, but out of range for IV.  */
			SETn( -(NV)result );
		    }
		}
		RETURN;
	    } /* Overflow, drop through to NVs.  */
	}
    }
#endif
d272 3
a274 8
	dPOPnv;
	if (!useleft) {
	    /* left operand is undef, treat as zero. + 0.0 is identity. */
	    SETn(value);
	    RETURN;
	}
	SETn( value + TOPn );
	RETURN;
d330 1
d336 1
a336 4

    if (gv && (io = GvIO(gv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
    {
d339 1
a339 1
	    /* If using default handle then we need to make space to
d348 1
a348 1
	*MARK = SvTIED_obj((SV*)io, mg);
d360 1
a360 2
        if ((GvEGV(gv)) && (io = GvIO(GvEGV(gv)))
	    && (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar)))
d369 15
a383 2
	    if (IoIFP(io))
		report_evil_fh(gv, io, OP_phoney_INPUT_ONLY);
d392 1
a392 1
	if (PL_ofs_sv && SvOK(PL_ofs_sv)) {
d398 1
a398 1
		    if (!do_print(PL_ofs_sv, fp)) { /* $, */
d415 2
a416 2
	    if (PL_ors_sv && SvOK(PL_ors_sv))
		if (!do_print(PL_ors_sv, fp)) /* $\ */
d474 1
a474 1
	
d537 1
a537 1
	EXTEND(SP, maxarg);
d539 2
a540 2
	    U32 i;
	    for (i=0; i < (U32)maxarg; i++) {
d544 1
a544 1
	}
d598 1
a598 1
	
d733 1
a733 1
		Perl_warner(aTHX_ packWARN(WARN_MISC),
d737 1
a737 1
		Perl_warner(aTHX_ packWARN(WARN_MISC),
d980 1
a980 3
    if (pm->op_pmdynflags & PMdf_TAINTED)
        SvTAINTED_on(rv);
    sv_magic(sv,(SV*)ReREFCNT_inc(PM_GETRE(pm)), PERL_MAGIC_qr,0,0);
a987 1
    PMOP *dynpm = pm;
d994 1
a994 1
    register REGEXP *rx = PM_GETRE(pm);
a1008 1

a1017 3
    PL_reg_match_utf8 = DO_UTF8(TARG);

    /* PMdf_USED is set after a ?? matches once */
a1024 1
    /* empty pattern special-cased to use last successful pattern if possible */
d1027 1
a1027 1
	rx = PM_GETRE(pm);
d1029 1
a1029 3

    if (rx->minlen > (I32)len)
	goto failure;
d1034 1
a1034 1
    if ((global = dynpm->op_pmflags & PMf_GLOBAL)) {
d1037 1
a1037 1
	    MAGIC* mg = mg_find(TARG, PERL_MAGIC_regex_global);
d1040 1
a1040 1
		    rx->endp[0] = rx->startp[0] = mg->mg_len;
d1043 1
a1043 1
		    rx->endp[0] = rx->startp[0] = mg->mg_len;
d1053 1
a1053 1
    if (SvSCREAM(TARG))
a1070 1
	PL_bostr = truebase;
d1076 1
a1076 1
	     && !PL_sawampersand
d1086 2
a1087 2
	if (dynpm->op_pmflags & PMf_ONCE)
	    dynpm->op_pmdynflags |= PMdf_USED;
d1099 1
a1099 1
	I32 nparens, i, len;
d1101 2
a1102 2
	nparens = rx->nparens;
	if (global && !nparens)
d1107 3
a1109 3
	EXTEND(SP, nparens + i);
	EXTEND_MORTAL(nparens + i);
	for (i = !i; i <= nparens; i++) {
a1113 3
	        if (rx->endp[i] < 0 || rx->startp[i] < 0 ||
		    len < 0 || len > strend - s)
		    DIE(aTHX_ "panic: pp_match start/end pointers");
d1116 1
a1116 1
		if (DO_UTF8(TARG) && is_utf8_string((U8*)s, len))
d1118 2
a1122 16
	    if (dynpm->op_pmflags & PMf_CONTINUE) {
		MAGIC* mg = 0;
		if (SvTYPE(TARG) >= SVt_PVMG && SvMAGIC(TARG))
		    mg = mg_find(TARG, PERL_MAGIC_regex_global);
		if (!mg) {
		    sv_magic(TARG, (SV*)0, PERL_MAGIC_regex_global, Nullch, 0);
		    mg = mg_find(TARG, PERL_MAGIC_regex_global);
		}
		if (rx->startp[0] != -1) {
		    mg->mg_len = rx->endp[0];
		    if (rx->startp[0] == rx->endp[0])
			mg->mg_flags |= MGf_MINMATCH;
		    else
			mg->mg_flags &= ~MGf_MINMATCH;
		}
	    }
d1129 1
a1129 1
	else if (!nparens)
d1138 1
a1138 1
		mg = mg_find(TARG, PERL_MAGIC_regex_global);
d1140 2
a1141 2
		sv_magic(TARG, (SV*)0, PERL_MAGIC_regex_global, Nullch, 0);
		mg = mg_find(TARG, PERL_MAGIC_regex_global);
d1160 2
a1161 2
    if (dynpm->op_pmflags & PMf_ONCE)
	dynpm->op_pmdynflags |= PMdf_USED;
d1169 1
a1169 7
	if (PL_reg_match_utf8) {
	    char *t = (char*)utf8_hop((U8*)s, rx->minlen);
	    rx->endp[0] = t - truebase;
	}
	else {
	    rx->endp[0] = s - truebase + rx->minlen;
	}
d1172 1
a1172 1
    }
d1192 1
a1192 1
    if (global && !(dynpm->op_pmflags & PMf_CONTINUE)) {
d1194 1
a1194 1
	    MAGIC* mg = mg_find(TARG, PERL_MAGIC_regex_global);
d1218 1
a1218 1
    if (io && (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar))) {
d1220 1
a1220 1
	XPUSHs(SvTIED_obj((SV*)io, mg));
d1251 132
a1382 2
	    else if (type == OP_GLOB)
		fp = Perl_start_glob(aTHX_ POPs, io);
d1386 17
a1402 2
	else if (ckWARN(WARN_IO) && IoTYPE(io) == IoTYPE_WRONLY) {
	    report_evil_fh(PL_last_in_gv, io, OP_phoney_OUTPUT_ONLY);
d1409 1
a1409 1
		Perl_warner(aTHX_ packWARN(WARN_GLOB),
a1452 1
	PUTBACK;
d1465 1
a1465 1
		    Perl_warner(aTHX_ packWARN(WARN_GLOB),
a1472 1
		SPAGAIN;
a1481 1
	SPAGAIN;
a1552 2
    U32 hash = (SvFAKE(keysv) && SvREADONLY(keysv)) ? SvUVX(keysv) : 0;
    I32 preeminent = 0;
d1555 1
a1555 20
	if (PL_op->op_private & OPpLVAL_INTRO) {
	    MAGIC *mg;
	    HV *stash;
	    /* does the element we're localizing already exist? */
	    preeminent =  
		/* can we determine whether it exists? */
		(    !SvRMAGICAL(hv)
		  || mg_find((SV*)hv, PERL_MAGIC_env)
		  || (     (mg = mg_find((SV*)hv, PERL_MAGIC_tied))
			/* Try to preserve the existenceness of a tied hash
			 * element by using EXISTS and DELETE if possible.
			 * Fallback to FETCH and STORE otherwise */
			&& (stash = SvSTASH(SvRV(SvTIED_obj((SV*)hv, mg))))
			&& gv_fetchmethod_autoload(stash, "EXISTS", TRUE)
			&& gv_fetchmethod_autoload(stash, "DELETE", TRUE)
		    )
		) ? hv_exists_ent(hv, keysv, 0) : 1;

	}
	he = hv_fetch_ent(hv, keysv, lval && !defer, hash);
d1561 1
a1561 1
	svp = avhv_fetch_ent((AV*)hv, keysv, lval && !defer, hash);
d1577 1
a1577 1
	    sv_magic(lv, key2 = newSVsv(keysv), PERL_MAGIC_defelem, Nullch, 0);
d1587 2
a1588 8
	    else {
		if (!preeminent) {
		    STRLEN keylen;
		    char *key = SvPV(keysv, keylen);
		    SAVEDELETE(hv, savepvn(key,keylen), keylen);
		} else
		    save_helem(hv, keysv, svp);
            }
d1635 1
a1635 1
	if (MARK <= SP) {
d1640 1
a1640 1
	} else {
d1685 1
a1685 1
#ifndef USE_5005THREADS			  /* don't risk potential race */
d1690 1
a1690 1
		else
d1711 1
a1711 1
#ifndef USE_5005THREADS			  /* don't risk potential race */
d1716 1
a1716 1
	else
d1734 3
a1736 11
    if (SvMAGICAL(av) || AvREIFY(av)) {
	SV **svp = av_fetch(av, ++cx->blk_loop.iterix, FALSE);
	if (svp)
	    sv = *svp;
	else
	    sv = Nullsv;
    }
    else {
	sv = AvARRAY(av)[++cx->blk_loop.iterix];
    }
    if (sv)
d1740 1
a1740 1
    if (av != PL_curstack && sv == &PL_sv_undef) {
d1752 1
a1752 1
	    sv_magic(lv, Nullsv, PERL_MAGIC_defelem, Nullch, 0);
d1769 1
a1769 1
    register SV *dstr;
d1783 1
a1783 1
    register REGEXP *rx = PM_GETRE(pm);
d1787 1
a1788 1
    bool doutf8 = FALSE;
d1791 1
a1791 1
    dstr = (pm->op_pmflags & PMf_CONST) ? POPs : Nullsv;
d1798 1
a1798 1

a1815 2
    PL_reg_match_utf8 = DO_UTF8(TARG);

d1821 1
a1821 1
    slen = PL_reg_match_utf8 ? utf8_length((U8*)s, (U8*)strend) : len;
d1828 1
a1828 1
	rx = PM_GETRE(pm);
a1839 1
	PL_bostr = orig;
d1846 1
a1846 1
	     && !PL_sawampersand
d1858 2
a1859 22
    if (dstr) {
	/* replacement needing upgrading? */
	if (DO_UTF8(TARG) && !doutf8) {
	     SV *nsv = sv_newmortal();
	     SvSetSV(nsv, dstr);
	     if (PL_encoding)
		  sv_recode_to_utf8(nsv, PL_encoding);
	     else
		  sv_utf8_upgrade(nsv);
	     c = SvPV(nsv, clen);
	     doutf8 = TRUE;
	}
	else {
	    c = SvPV(dstr, clen);
	    doutf8 = DO_UTF8(dstr);
	}
    }
    else {
        c = Nullch;
	doutf8 = FALSE;
    }
    
d1861 2
a1862 1
    if (c && (I32)clen <= rx->minlen && (once || !(r_flags & REXEC_COPY_STR))
a1958 2
	if (doutf8)
	    SvUTF8_on(TARG);
d1966 2
d1976 1
a1976 1
	if (DO_UTF8(TARG))
d2001 1
a2001 1
		sv_catpvn(dstr, c, clen);
d2004 2
a2005 10
	} while (CALLREGEXEC(aTHX_ rx, s, strend, orig, s == m,
			     TARG, NULL, r_flags));
	if (doutf8 && !DO_UTF8(dstr)) {
	    SV* nsv = sv_2mortal(newSVpvn(s, strend - s));
	    
	    sv_utf8_upgrade(nsv);
	    sv_catpvn(dstr, SvPVX(nsv), SvCUR(nsv));
	}
	else
	    sv_catpvn(dstr, s, strend - s);
d2012 1
a2012 1
	doutf8 |= DO_UTF8(dstr);
d2021 1
a2021 1
	if (doutf8)
d2032 1
a2032 1
ret_no:
d2091 1
a2091 1

d2127 1
a2127 1

d2149 1
a2149 1

d2221 1
a2221 2
		if (*mark != &PL_sv_undef
		    && SvFLAGS(*mark) & (SVs_TEMP | SVs_PADTMP | SVf_READONLY)) {
d2228 5
a2232 2
		    DIE(aTHX_ "Can't return a %s from lvalue subroutine",
			SvREADONLY(TOPs) ? "readonly value" : "temporary");
d2280 1
a2280 1

d2300 1
a2300 1
	     || strEQ(GvNAME(gv), "END")
a2351 2
		if (SvROK(sv))
		    goto got_rv;
a2362 1
  got_rv:
d2431 1
a2431 1
#ifdef USE_5005THREADS
d2475 1
a2475 1
				  thr, sv));
d2559 1
a2559 1
                                     CvDEPTH(cv)));
d2563 1
a2563 1
#endif /* USE_5005THREADS */
d2578 1
a2578 1
	    items = (*fp3)(CvXSUBANY(cv).any_i32,
d2596 1
a2596 1
#ifdef USE_5005THREADS
d2600 1
a2600 1
#endif /* USE_5005THREADS */		
d2608 1
a2608 1
		    PUTBACK ;		
d2618 1
a2618 1
	    (void)(*CvXSUB(cv))(aTHX_ cv);
d2692 1
a2692 1
#ifdef USE_5005THREADS
d2702 1
a2702 1
		PUTBACK ;		
d2705 1
a2705 1
#endif /* USE_5005THREADS */		
d2708 1
a2708 1
#ifndef USE_5005THREADS
d2710 1
a2710 1
#endif /* USE_5005THREADS */
d2727 1
a2727 1
#ifndef USE_5005THREADS
d2730 1
a2730 1
#endif /* USE_5005THREADS */
d2750 1
a2750 1
	
d2776 1
a2776 1
	Perl_warner(aTHX_ packWARN(WARN_RECURSION), "Deep recursion on anonymous subroutine");
d2780 1
a2780 1
	Perl_warner(aTHX_ packWARN(WARN_RECURSION), "Deep recursion on subroutine \"%s\"",
d2789 1
a2789 2
    SV* elemsv = POPs;
    IV elem = SvIV(elemsv);
a2794 2
    if (SvROK(elemsv) && !SvGAMAGIC(elemsv) && ckWARN(WARN_MISC))
	Perl_warner(aTHX_ packWARN(WARN_MISC), "Use of reference \"%s\" as array index", SvPV_nolen(elemsv));
d2808 1
a2808 1
	    sv_magic(lv, Nullsv, PERL_MAGIC_defelem, Nullch, 0);
d2894 1
a2894 1
    char* packname = 0;
d2904 1
a2904 1
	mg_get(sv);
a2909 1
	/* this isn't a reference */
a2915 1
	    /* this isn't the name of a filehandle either */
d2926 1
a2926 2
	    /* assume it's a package name */
	    stash = gv_stashpvn(packname, packlen, FALSE);
a2928 1
	/* it _is_ a filehandle name -- replace with a reference */
a2931 1
    /* if we got here, ob should be a reference or a glob */
a2942 3
    /* NOTE: stash may be null, hope hv_fetch_ent and
       gv_fetchmethod can cope (it seems they can) */

a2954 1

a2955 7
	/* This code tries to figure out just what went wrong with
	   gv_fetchmethod.  It therefore needs to duplicate a lot of
	   the internals of that function.  We can't move it inside
	   Perl_gv_fetchmethod_autoload(), however, since that would
	   cause UNIVERSAL->can("NoSuchPackage::foo") to croak, and we
	   don't want that.
	*/
d2959 1
d2968 1
a2968 3
	    /* the method name is unqualified or starts with SUPER:: */ 
	    packname = sep ? CopSTASHPV(PL_curcop) :
		stash ? HvNAME(stash) : packname;
a2971 1
	    /* the method name is qualified */
d2975 2
a2976 3
	
	/* we're relying on gv_fetchmethod not autovivifying the stash */
	if (gv_stashpvn(packname, packlen, FALSE)) {
d2978 2
a2979 2
		       "Can't locate object method \"%s\" via package \"%.*s\"",
		       leaf, (int)packlen, packname);
d2983 3
a2985 3
		       "Can't locate object method \"%s\" via package \"%.*s\""
		       " (perhaps you forgot to load \"%.*s\"?)",
		       leaf, (int)packlen, packname, (int)packlen, packname);
d2991 1
a2991 1
#ifdef USE_5005THREADS
d2993 1
a2993 1
unset_cvowner(pTHX_ void *cvarg)
d3002 1
a3002 1
                             CvDEPTH(cv)));
d3008 1
a3008 1
#endif /* USE_5005THREADS */
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d143 1
a143 1
    bool rbyte = !SvUTF8(right), rcopied = FALSE;
d147 1
a147 2
	rpv = SvPV(right, rlen);	/* no point setting UTF-8 here */
	rcopied = TRUE;
a182 2
	    if (!rcopied)
		right = sv_2mortal(newSVpvn(rpv, rlen));
d200 1
a200 1
	    SAVECLEARSV(PAD_SVl(PL_op->op_targ));
d203 1
a203 1
	    vivify_ref(PAD_SVl(PL_op->op_targ), PL_op->op_private & OPpDEREF);
d574 1
a574 1
	SETERRNO(EBADF,RMS_IFI);
d584 1
a584 1
	SETERRNO(EBADF,IoIFP(io)?RMS_FAC:RMS_IFI);
a652 3
	else if (PL_op->op_flags & OPf_MOD
		&& PL_op->op_private & OPpLVAL_INTRO)
	    Perl_croak(aTHX_ PL_no_localize_ref);
d747 1
a747 1
    else if (GIMME_V == G_SCALAR) {
a758 1
    I32 gimme = GIMME_V;
d772 1
a772 1
	    if (gimme != G_ARRAY)
a776 3
	else if (PL_op->op_flags & OPf_MOD
		&& PL_op->op_private & OPpLVAL_INTRO)
	    Perl_croak(aTHX_ PL_no_localize_ref);
d786 1
a786 1
		if (gimme != G_ARRAY)
d811 1
a811 1
		    if (gimme == G_ARRAY) {
d846 1
a846 1
		if (gimme != G_ARRAY)
d855 1
a855 1
    if (gimme == G_ARRAY) { /* array wanted */
d859 1
a859 1
    else if (gimme == G_SCALAR) {
a860 7

	/* 21394 adds this, but I'm not sure if it's safe in maint:
	if (SvRMAGICAL(hv) && mg_find((SV *)hv, PERL_MAGIC_tied))
	    Perl_croak(aTHX_ "Can't provide tied hash usage; "
		       "use keys(%%hash) to test if empty");
	*/

a862 1

d870 1
a871 1
    RETURN;
d1091 1
a1091 3
	    (void)setresuid((PL_delaymagic & DM_RUID) ? PL_uid  : (Uid_t)-1,
			    (PL_delaymagic & DM_EUID) ? PL_euid : (Uid_t)-1,
			    (Uid_t)-1);
d1094 1
a1094 2
	    (void)setreuid((PL_delaymagic & DM_RUID) ? PL_uid  : (Uid_t)-1,
			   (PL_delaymagic & DM_EUID) ? PL_euid : (Uid_t)-1);
d1104 1
a1104 1
		(void)seteuid(PL_euid);
d1120 1
a1120 3
	    (void)setresgid((PL_delaymagic & DM_RGID) ? PL_gid  : (Gid_t)-1,
			    (PL_delaymagic & DM_EGID) ? PL_egid : (Gid_t)-1,
			    (Gid_t)-1);
d1123 1
a1123 2
	    (void)setregid((PL_delaymagic & DM_RGID) ? PL_gid  : (Gid_t)-1,
			   (PL_delaymagic & DM_EGID) ? PL_egid : (Gid_t)-1);
d1133 1
a1133 1
		(void)setegid(PL_egid);
d1219 1
a1219 1
    RX_MATCH_UTF8_set(rx, DO_UTF8(TARG));
d1394 1
a1394 1
	if (RX_MATCH_UTF8(rx)) {
d1417 1
a1417 1
    rx->nparens = rx->lastparen = rx->lastcloseparen = 0;	/* used by @@-, @@+, and $^N */
d1457 2
a1458 5
	if (gimme == G_SCALAR) {
	    SV* result = POPs;
	    SvSetSV_nosteal(TARG, result);
	    PUSHTARG;
	}
d1502 1
a1502 5
	    /* undef TARG, and push that undefined value */
	    if (type != OP_RCATLINE) {
	        SV_CHECK_THINKFIRST(TARG);
	        (void)SvOK_off(TARG);
	    }
d1516 1
a1516 6
	offset = 0;
	if (type == OP_RCATLINE && SvOK(sv)) {
	    if (!SvPOK(sv)) {
		STRLEN n_a;
		(void)SvPV_force(sv, n_a);
	    }
d1518 2
a1519 1
	}
d1559 1
a1559 4
		if (type != OP_RCATLINE) {
		    SV_CHECK_THINKFIRST(TARG);
		    (void)SvOK_off(TARG);
		}
a1589 11
	} else if (SvUTF8(sv)) { /* OP_READLINE, OP_RCATLINE */
	     U8 *s = (U8*)SvPVX(sv) + offset;
	     STRLEN len = SvCUR(sv) - offset;
	     U8 *f;
	     
	     if (ckWARN(WARN_UTF8) &&
		 !Perl_is_utf8_string_loc(aTHX_ s, len, &f))
		  /* Emulate :encoding(utf8) warning in the same case. */
		  Perl_warner(aTHX_ packWARN(WARN_UTF8),
			      "utf8 \"\\x%02X\" does not map to Unicode",
			      f < (U8*)SvEND(sv) ? *f : 0);
a1859 5
    if (sv && SvREFCNT(sv) == 0) {
	*itersvp = Nullsv;
	Perl_croak(aTHX_ "Use of freed value in iteration");
    }

a1912 1
    SV *nsv = Nullsv;
d1940 1
a1940 1
    RX_MATCH_UTF8_set(rx, DO_UTF8(TARG));
d1947 1
a1947 1
    slen = RX_MATCH_UTF8(rx) ? utf8_length((U8*)s, (U8*)strend) : len;
d1988 1
a1988 1
	     nsv = sv_newmortal();
d2009 1
a2009 2
	&& !(rx->reganch & ROPT_LOOKBEHIND_SEEN)
	&& (!doutf8 || SvUTF8(TARG))) {
a2127 1
	    ReREFCNT_inc(rx);
d2144 1
a2144 4
	    if (doutf8 && !SvUTF8(dstr))
		sv_catpvn_utf8_upgrade(dstr, s, m - s, nsv);
            else
		sv_catpvn(dstr, s, m-s);
d2152 6
a2157 2
	if (doutf8 && !DO_UTF8(TARG))
	    sv_catpvn_utf8_upgrade(dstr, s, strend - s, nsv);
d2162 1
a2162 2
	if (SvLEN(TARG))
	    Safefree(SvPVX(TARG));
d2353 2
a2354 3
		    DIE(aTHX_ "Can't return %s from lvalue subroutine",
			SvREADONLY(TOPs) ? (TOPs == &PL_sv_undef) ? "undef"
			: "a readonly value" : "a temporary");
d2571 1
a2571 1
		DIE(aTHX_ "Undefined subroutine &%"SVf" called", sub_name);
d2601 1
a2601 1
		AV *av = (AV*)PAD_SVl(0);
d2752 1
a2752 1
		av = (AV*)PAD_SVl(0);
d2791 1
d2798 2
a2799 2
	 * Owing the speed considerations, we choose instead to search for
	 * the cv using find_runcv() when calling doeval().
d2803 1
a2803 1
	else {
d2805 41
a2845 1
	    pad_push(padlist, CvDEPTH(cv), 1);
d2849 1
a2849 1
	    AV* av = (AV*)PAD_SVl(0);
d2861 2
a2862 1
	PAD_SET_CUR(padlist, CvDEPTH(cv));
d2874 1
a2874 1
	    av = (AV*)PAD_SVl(0);
d2886 1
a2886 1
	    CX_CURPAD_SAVE(cx->blk_sub);
d2935 2
a2936 2
	Perl_warner(aTHX_ packWARN(WARN_RECURSION), "Deep recursion on subroutine \"%"SVf"\"",
		tmpstr);
d2952 1
a2952 1
	Perl_warner(aTHX_ packWARN(WARN_MISC), "Use of reference \"%"SVf"\" as array index", elemsv);
d3036 1
a3036 1
    SV* sv = cSVOP_sv;
a3052 1
    SV *packsv = Nullsv;
a3069 10

        if(SvOK(sv) && (packname = SvPV(sv, packlen))) {
          HE* he;
	  he = hv_fetch_ent(PL_stashcache, sv, 0, 0);
          if (he) { 
            stash = INT2PTR(HV*,SvIV(HeVAL(he)));
            goto fetch;
          }
        }

d3071 1
a3071 1
	    !(packname) ||
a3087 6
	    if (!stash)
		packsv = sv;
            else {
	        SV* ref = newSViv(PTR2IV(stash));
	        hv_store(PL_stashcache, packname, packlen, ref, 0);
	    }
d3120 1
a3120 1
    gv = gv_fetchmethod(stash ? stash : (HV*)packsv, name);
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d873 6
d882 6
a887 1
	TARG = Perl_hv_scalar(aTHX_ hv);
a996 3
    int duplicates = 0;
    SV **firsthashrelem = 0;	/* "= 0" keeps gcc 2.95 quiet  */

a998 1
    gimme = GIMME_V;
a1064 1
		firsthashrelem = relem;
a1075 3
		    if (gimme != G_VOID && hv_exists_ent(hash, sv, 0))
			/* key overwrites an existing entry */
			duplicates += 2;
d1176 1
d1182 1
a1182 1
	SETi(lastrelem - firstrelem + 1 - duplicates);
d1185 1
a1185 10
	if (ary)
	    SP = lastrelem;
	else if (hash) {
	    if (duplicates) {
		/* Removes from the stack the entries which ended up as
		 * duplicated keys in the hash (fix for [perl #24380]) */
		Move(firsthashrelem + duplicates,
			firsthashrelem, duplicates, SV**);
		lastrelem -= duplicates;
	    }
a1186 1
	}
d1546 1
a1546 1
	if (!tmplen && !SvREADONLY(sv))
d1577 1
a1577 3
	    && (type == OP_GLOB
		|| SNARF_EOF(gimme, PL_rs, io, sv)
		|| PerlIO_error(fp)))
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d144 1
a144 1
    bool rbyte = !DO_UTF8(right), rcopied = FALSE;
d154 1
a154 1
	lbyte = !DO_UTF8(left);
d167 1
a167 3
	lbyte = !DO_UTF8(left);
	if (IN_BYTES)
	    SvUTF8_off(TARG);
d492 1
a492 2
    AV *av = PL_op->op_flags & OPf_SPECIAL ?
		(AV*)PAD_SV(PL_op->op_targ) : GvAV(cGVOP_gv);
d746 1
a746 4
		/* See note in pp_helem, and bug id #27839 */
		SP[i+1] = svp
		    ? SvGMAGICAL(*svp) ? sv_mortalcopy(*svp) : *svp
		    : &PL_sv_undef;
a1352 1
		s = rx->startp[i] + truebase;
d1356 1
d1840 1
a1840 1
    SV *sv, *oldsv;
d1856 2
a1857 2
	    STRLEN maxlen = 0;
	    char *max = SvOK((SV*)av) ? SvPV((SV*)av, maxlen) : "";
d1870 1
a1870 1
		    oldsv = *itersvp;
a1871 1
		    SvREFCNT_dec(oldsv);
d1896 1
a1896 1
	    oldsv = *itersvp;
a1897 1
	    SvREFCNT_dec(oldsv);
d1906 2
a1946 1
    oldsv = *itersvp;
a1947 2
    SvREFCNT_dec(oldsv);

a2310 1
    cxstack_ix++; /* temporarily protect top context */
a2347 2
    LEAVE;
    cxstack_ix--;
d2351 1
a2368 1
    cxstack_ix++; /* temporarily protect top context */
a2403 2
	    LEAVE;
	    cxstack_ix--;
d2406 1
a2414 2
		    LEAVE;
		    cxstack_ix--;
d2417 1
a2429 2
		LEAVE;
		cxstack_ix--;
d2432 1
a2445 2
		    LEAVE;
		    cxstack_ix--;
d2448 1
a2499 2
    LEAVE;
    cxstack_ix--;
d2503 1
d2867 3
a2869 1
	if (CvDEPTH(cv) >= 2) {
a2983 12
#ifdef PERL_MALLOC_WRAP
	 static const char oom_array_extend[] =
	      "Out of memory during array extend"; /* Duplicated in av.c */
	 if (SvUOK(elemsv)) {
	      UV uv = SvUV(elemsv);
	      elem = uv > IV_MAX ? IV_MAX : uv;
	 }
	 else if (SvNOK(elemsv))
	      elem = (IV)SvNV(elemsv);
	 if (elem > 0)
	      MEM_WRAP_CHECK_1(elem,SV*,oom_array_extend);
#endif
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@a18 13
/* This file contains 'hot' pp ("push/pop") functions that
 * execute the opcodes that make up a perl program. A typical pp function
 * expects to find its arguments on the stack, and usually pushes its
 * results onto the stack, hence the 'pp' terminology. Each OP structure
 * contains a pointer to the relevant pp_foo() function.
 *
 * By 'hot', we mean common ops whose execution speed is critical.
 * By gathering them together into a single file, we encourage
 * CPU cache hits on hot code. Also it could be taken as a warning not to
 * change any code in this file unless you're sure it won't affect
 * performance.
 */

d238 1
a238 1
    if (SvROK(TOPs) && !SvAMAGIC(TOPs) && SvROK(TOPm1s) && !SvAMAGIC(TOPm1s)) {
d1545 1
a1545 1
	        SvOK_off(TARG);
d1611 1
a1611 1
		    SvOK_off(TARG);
d1911 2
a1912 4
    if (PL_op->op_private & OPpITER_REVERSED) {
	/* In reverse, use itermax as the min :-)  */
	if (cx->blk_loop.iterix <= cx->blk_loop.itermax)
	    RETPUSHNO;
d1914 6
a1919 10
	if (SvMAGICAL(av) || AvREIFY(av)) {
	    SV **svp = av_fetch(av, cx->blk_loop.iterix--, FALSE);
	    if (svp)
		sv = *svp;
	    else
		sv = Nullsv;
	}
	else {
	    sv = AvARRAY(av)[cx->blk_loop.iterix--];
	}
d1922 1
a1922 14
	if (cx->blk_loop.iterix >= (av == PL_curstack ? cx->blk_oldsp :
				    AvFILL(av)))
	    RETPUSHNO;

	if (SvMAGICAL(av) || AvREIFY(av)) {
	    SV **svp = av_fetch(av, ++cx->blk_loop.iterix, FALSE);
	    if (svp)
		sv = *svp;
	    else
		sv = Nullsv;
	}
	else {
	    sv = AvARRAY(av)[++cx->blk_loop.iterix];
	}
a1923 1

d2235 1
a2235 1
	SvOOK_off(TARG);
d3048 1
a3048 1
	    SvOOK_off(sv);
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d65 1
a65 1
	PUSHs(GvSVn(cGVOP_gv));
d152 2
d156 2
a157 3
    const char *rpv = SvPV_const(right, rlen);	/* mg_get(right) happens here */
    const bool rbyte = !DO_UTF8(right);
    bool rcopied = FALSE;
d161 1
a161 1
	rpv = SvPV_const(right, rlen);	/* no point setting UTF-8 here */
d166 1
a166 2
        STRLEN llen;
        const char* const lpv = SvPV_const(left, llen);	/* mg_get(left) may happen here */
a174 1
        STRLEN llen;
d178 2
a179 2
	    sv_setpvn(left, "", 0);
	(void)SvPV_nomg_const(left, llen);    /* Needed to set UTF8 flag */
d203 1
a203 1
	    rpv = SvPV_const(right, rlen);
d322 1
a322 1
	SvIV_set(TOPs, SvIVX(TOPs) + 1);
d415 1
a415 1
		    register const IV aiv = SvIVX(TOPm1s);
d435 1
a435 1
		register const IV biv = SvIVX(TOPs);
d509 1
a509 1
    const U32 lval = PL_op->op_flags & OPf_MOD;
d642 1
a642 1
    XPUSHs(&PL_sv_yes);
d647 1
a647 1
    XPUSHs(&PL_sv_undef);
d755 1
a755 1
	const I32 maxarg = AvFILL(av) + 1;
d775 1
a775 1
	const I32 maxarg = AvFILL(av) + 1;
d785 1
a785 2
    const I32 gimme = GIMME_V;
    static const char return_hash_to_lvalue_scalar[] = "Can't return hash to lvalue scalar context";
d800 1
a800 1
		Perl_croak(aTHX_ return_hash_to_lvalue_scalar );
d817 2
a818 1
		    Perl_croak(aTHX_ return_hash_to_lvalue_scalar );
d877 2
a878 1
		    Perl_croak(aTHX_ return_hash_to_lvalue_scalar );
a951 1
	    const char *err;
d957 2
a958 1
		err = "Reference found where even-sized list expected";
d961 2
a962 2
		err = "Odd number of elements in hash assignment";
	    Perl_warner(aTHX_ packWARN(WARN_MISC), err);
d1019 1
d1057 1
d1059 1
a1059 1
		sv = newSVsv(*relem);
d1238 3
a1240 3
    register const char *t;
    register const char *s;
    const char *strend;
d1243 1
a1243 1
    const char *truebase;			/* Start of string  */
d1246 1
a1246 1
    const I32 gimme = GIMME;
d1249 1
a1249 1
    const I32 oldsave = PL_savestack_ix;
d1261 2
a1262 1
    s = SvPV_const(TARG, len);
a1264 1
    strend = s + len;
d1328 2
a1329 3
	/* FIXME - can PL_bostr be made const char *?  */
	PL_bostr = (char *)truebase;
	s = CALLREG_INTUIT_START(aTHX_ rx, TARG, (char *)s, (char *)strend, r_flags, NULL);
d1341 1
a1341 1
    if (CALLREGEXEC(aTHX_ rx, (char*)s, (char *)strend, (char*)truebase, minmatch, TARG, NULL, r_flags))
d1357 1
a1357 2
	const I32 nparens = rx->nparens;
	I32 i = (global && !nparens) ? 1 : 0;
d1359 5
d1369 1
d1371 1
a1371 1
		const I32 len = rx->endp[i] - rx->startp[i];
d1442 1
a1442 2
	/* FIXME - should rx->subbeg be const char *?  */
	rx->subbeg = (char *) truebase;
d1494 3
a1496 3
    register IO * const io = GvIO(PL_last_in_gv);
    register const I32 type = PL_op->op_type;
    const I32 gimme = GIMME_V;
d1524 1
a1524 1
			sv_setpvn(GvSVn(PL_last_in_gv), "-", 1);
d1545 2
a1546 3
	if ((!io || !(IoFLAGS(io) & IOf_START))
	    && ckWARN2(WARN_GLOB, WARN_CLOSED))
	{
d1576 2
a1577 1
		SvPV_force_nolen(sv);
a1639 1
	    const char *t1;
d1643 1
a1643 1
		if (*tmps == *SvPVX_const(PL_rs)) {
d1645 1
a1645 1
		    SvCUR_set(sv, SvCUR(sv) - 1);
d1648 3
a1650 3
	    for (t1 = SvPVX_const(sv); *t1; t1++)
		if (!isALPHA(*t1) && !isDIGIT(*t1) &&
		    strchr("$&*(){}[]'\";\\|?<>~`", *t1))
d1652 1
a1652 1
	    if (*t1 && PerlLIO_lstat(SvPVX_const(sv), &PL_statbuf) < 0) {
d1657 3
a1659 3
	     const U8 *s = (const U8*)SvPVX_const(sv) + offset;
	     const STRLEN len = SvCUR(sv) - offset;
	     const U8 *f;
d1662 1
a1662 1
		 !Perl_is_utf8_string_loc(aTHX_ (U8 *) s, len, (U8 **) &f))
d1670 2
a1671 1
		SvPV_shrink_to_cur(sv);
d1678 5
a1682 3
	    const STRLEN new_len
		= SvCUR(sv) < 60 ? 80 : SvCUR(sv)+40; /* allow some slop */
	    SvPV_renew(sv, new_len);
d1716 2
a1717 2
    const U32 lval = PL_op->op_flags & OPf_MOD || LVRET;
    const U32 defer = PL_op->op_private & OPpLVAL_DEFER;
d1719 1
a1719 1
    const U32 hash = (SvIsCOW_shared_hash(keysv)) ? SvSHARED_HASH(keysv) : 0;
d1758 2
a1759 1
		DIE(aTHX_ PL_no_helem_sv, keysv);
d1772 1
a1772 1
	    if (HvNAME_get(hv) && isGV(*svp))
d1777 1
a1777 1
		    const char * const key = SvPV_const(keysv, keylen);
d1803 1
a1826 1
	register SV **mark;
a1840 1
	register SV **mark;
d1876 1
a1876 1
	    const char *max = SvOK((SV*)av) ? SvPV_const((SV*)av, maxlen) : "";
d1893 1
a1893 1
		if (strEQ(SvPVX_const(cur), max))
d1930 5
a1934 2
	    SV ** const svp = av_fetch(av, --cx->blk_loop.iterix, FALSE);
	    sv = svp ? *svp : Nullsv;
d1937 1
a1937 1
	    sv = AvARRAY(av)[--cx->blk_loop.iterix];
d2002 1
a2002 1
    const char *c;
d2037 1
a2037 1
    s = SvPV_mutable(TARG, len);
d2100 1
a2100 1
	     c = SvPV_const(nsv, clen);
d2104 1
a2104 1
	    c = SvPV_const(dstr, clen);
d2151 1
d2180 1
d2197 1
a2197 1
		SvCUR_set(TARG, d - SvPVX_const(TARG) + i);
d2227 2
a2228 1
	dstr = newSVpvn(m, s-m);
d2235 1
a2235 1
	    (void)ReREFCNT_inc(rx);
d2268 4
a2271 2
	SvPV_free(TARG);
	SvPV_set(TARG, SvPVX(dstr));
d2275 1
a2275 1
	SvPV_set(dstr, (char*)0);
d2460 1
a2460 4
		/* Temporaries are bad unless they happen to be elements
		 * of a tied hash or array */
		if (SvFLAGS(TOPs) & (SVs_TEMP | SVs_PADTMP | SVf_READONLY) &&
		    !(SvRMAGICAL(TOPs) && mg_find(TOPs, PERL_MAGIC_tiedelem))) {
d2562 1
a2562 1
    SV *dbsv = GvSVn(PL_DBsub);
a2563 1
    save_item(dbsv);
d2567 1
d2575 1
a2575 1
	    SV * const tmp = newRV((SV*)cv);
d2584 1
a2584 3
	const int type = SvTYPE(dbsv);
	if (type < SVt_PVIV && type != SVt_IV)
	    sv_upgrade(dbsv, SVt_PVIV);
d2586 2
a2587 1
	SvIV_set(dbsv, PTR2IV(cv));	/* Do it the quickest way  */
d2604 1
a2604 1
    const bool hasargs = (PL_op->op_flags & OPf_STACKED) != 0;
d2611 3
a2613 1
	    const char *sym;
d2623 1
a2623 1
		sym = SvPOKp(sv) ? SvPVX_const(sv) : Nullch;
d2625 2
a2626 3
	    else {
		sym = SvPV_nolen_const(sv);
            }
d2636 1
a2636 1
	    SV * const * sp = &sv;		/* Used in tryAMAGICunDEREF macro. */
d2699 2
a2700 2
	if (!cv || (!CvXSUB(cv) && !CvSTART(cv)))
	    DIE(aTHX_ "No DB::sub routine defined");
d2866 2
d2869 1
a2869 1
		AV * const av = (AV*)PAD_SVl(0);
d2871 1
a2871 1
		AV * const av = GvAV(PL_defgv);
d2873 1
a2873 2
		const I32 items = AvFILLp(av) + 1;   /* @@_ is not tieable */

a2924 1
    /*NOTREACHED*/
d2935 1
a2935 2
	SAVECOMPPAD();
	PAD_SET_CUR_NOSAVE(padlist, CvDEPTH(cv));
d3006 1
a3006 1
	SV* const tmpstr = sv_newmortal();
d3017 1
a3017 1
    SV* const elemsv = POPs;
d3020 2
a3021 2
    const U32 lval = PL_op->op_flags & OPf_MOD || LVRET;
    const U32 defer = (PL_op->op_private & OPpLVAL_DEFER) && (elem > av_len(av));
d3033 2
d3036 1
a3036 1
	      const UV uv = SvUV(elemsv);
d3041 1
a3041 3
	 if (elem > 0) {
	      static const char oom_array_extend[] =
		"Out of memory during array extend"; /* Duplicated in av.c */
a3042 1
	 }
d3081 3
a3083 3
	    SvPV_free(sv);
            SvLEN_set(sv, 0);
	    SvCUR_set(sv, 0);
d3087 1
a3087 1
	    SvRV_set(sv, NEWSV(355,0));
d3090 1
a3090 1
	    SvRV_set(sv, (SV*)newAV());
d3093 1
a3093 1
	    SvRV_set(sv, (SV*)newHV());
d3104 1
a3104 1
    SV* const sv = TOPs;
d3107 1
a3107 1
	SV* const rsv = SvRV(sv);
d3121 2
a3122 2
    SV* const sv = cSVOP_sv;
    U32 hash = SvSHARED_HASH(sv);
d3131 1
d3135 1
d3137 1
a3137 1
    const char* packname = Nullch;
d3140 3
a3142 2
    const char * const name = SvPV_const(meth, namelen);
    SV * const sv = *(PL_stack_base + TOPMARK + 1);
d3155 5
a3159 2
        if(SvOK(sv) && (packname = SvPV_const(sv, packlen))) {
          const HE* const he = hv_fetch_ent(PL_stashcache, sv, 0, 0);
d3213 1
a3213 1
	const HE* const he = hv_fetch_ent(stash, meth, 0, *hashp);
d3232 3
a3234 3
	const char* leaf = name;
	const char* sep = Nullch;
	const char* p;
d3245 2
a3246 6
		stash ? HvNAME_get(stash) : packname;
	    if (!packname)
		Perl_croak(aTHX_
			   "Can't use anonymous symbol table for method lookup");
	    else
		packlen = strlen(packname);
a3287 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
d38 4
a43 1
    dVAR;
d45 1
a45 8
    if ( PL_op->op_flags & OPf_SPECIAL )
        /* This is a const op added to hold the hints hash for
           pp_entereval. The hash can be modified by the code
           being eval'ed, so we return a copy instead. */
        XPUSHs(sv_2mortal((SV*)Perl_hv_copy_hints_hv(aTHX_ (HV*)cSVOP_sv)));
    else
        /* Normal const. */
        XPUSHs(cSVOP_sv);
a50 1
    dVAR;
a59 1
    dVAR;
a70 1
    dVAR;
a75 1
    dVAR;
a81 1
    dVAR;
d88 1
a88 1
    dVAR; dSP; dTARGET;
d96 1
a96 1
    dVAR; dSP;
d103 1
a103 1
    dVAR; dSP;
d107 1
a107 2
        if (PL_op->op_type == OP_AND)
	    --SP;
d114 1
a114 1
    dVAR; dSP; dPOPTOPssrl;
d117 2
a118 2
	SV * const temp = left;
	left = right; right = temp;
a121 78
    if (PL_op->op_private & OPpASSIGN_CV_TO_GV) {
	SV * const cv = SvRV(left);
	const U32 cv_type = SvTYPE(cv);
	const U32 gv_type = SvTYPE(right);
	const bool got_coderef = cv_type == SVt_PVCV || cv_type == SVt_PVFM;

	if (!got_coderef) {
	    assert(SvROK(cv));
	}

	/* Can do the optimisation if right (LVALUE) is not a typeglob,
	   left (RVALUE) is a reference to something, and we're in void
	   context. */
	if (!got_coderef && gv_type != SVt_PVGV && GIMME_V == G_VOID) {
	    /* Is the target symbol table currently empty?  */
	    GV * const gv = gv_fetchsv(right, GV_NOINIT, SVt_PVGV);
	    if (SvTYPE(gv) != SVt_PVGV && !SvOK(gv)) {
		/* Good. Create a new proxy constant subroutine in the target.
		   The gv becomes a(nother) reference to the constant.  */
		SV *const value = SvRV(cv);

		SvUPGRADE((SV *)gv, SVt_RV);
		SvPCS_IMPORTED_on(gv);
		SvRV_set(gv, value);
		SvREFCNT_inc_simple_void(value);
		SETs(right);
		RETURN;
	    }
	}

	/* Need to fix things up.  */
	if (gv_type != SVt_PVGV) {
	    /* Need to fix GV.  */
	    right = (SV*)gv_fetchsv(right, GV_ADD, SVt_PVGV);
	}

	if (!got_coderef) {
	    /* We've been returned a constant rather than a full subroutine,
	       but they expect a subroutine reference to apply.  */
	    if (SvROK(cv)) {
		ENTER;
		SvREFCNT_inc_void(SvRV(cv));
		/* newCONSTSUB takes a reference count on the passed in SV
		   from us.  We set the name to NULL, otherwise we get into
		   all sorts of fun as the reference to our new sub is
		   donated to the GV that we're about to assign to.
		*/
		SvRV_set(left, (SV *)newCONSTSUB(GvSTASH(right), NULL,
						 SvRV(cv)));
		SvREFCNT_dec(cv);
		LEAVE;
	    } else {
		/* What can happen for the corner case *{"BONK"} = \&{"BONK"};
		   is that
		   First:   ops for \&{"BONK"}; return us the constant in the
			    symbol table
		   Second:  ops for *{"BONK"} cause that symbol table entry
			    (and our reference to it) to be upgraded from RV
			    to typeblob)
		   Thirdly: We get here. cv is actually PVGV now, and its
			    GvCV() is actually the subroutine we're looking for

		   So change the reference so that it points to the subroutine
		   of that typeglob, as that's what they were after all along.
		*/
		GV *const upgraded = (GV *) cv;
		CV *const source = GvCV(upgraded);

		assert(source);
		assert(CvFLAGS(source) & CVf_CONST);

		SvREFCNT_inc_void(source);
		SvREFCNT_dec(upgraded);
		SvRV_set(left, (SV *)source);
	    }
	}

    }
d129 1
a129 1
    dVAR; dSP;
a137 1
    dVAR;
d149 1
a149 1
  dVAR; dSP; dATARGET; tryAMAGICbin(concat,opASSIGN);
d154 2
a155 2
    const char *rpv = NULL;
    bool rbyte = FALSE;
a158 3
	/* mg_get(right) may happen here ... */
	rpv = SvPV_const(right, rlen);
	rbyte = !DO_UTF8(right);
d176 3
a178 4
	SvGETMAGIC(left);		/* or mg_get(left) may happen here */
	if (!SvOK(TARG)) {
	    if (left == right && ckWARN(WARN_UNINITIALIZED))
		report_uninit(right);
a179 1
	}
d186 8
a193 4
    /* or mg_get(right) may happen here */
    if (!rcopied) {
	rpv = SvPV_const(right, rlen);
	rbyte = !DO_UTF8(right);
d195 2
d216 1
a216 1
    dVAR; dSP; dTARGET;
d220 2
a221 3
	    if (!(PL_op->op_private & OPpPAD_STATE))
		SAVECLEARSV(PAD_SVl(PL_op->op_targ));
        if (PL_op->op_private & OPpDEREF) {
a231 1
    dVAR;
d250 1
a250 1
    dVAR; dSP; tryAMAGICbinSET(eq,0);
d266 2
a267 2
	    const bool auvok = SvUOK(TOPm1s);
	    const bool buvok = SvUOK(TOPs);
d276 2
a277 2
		const UV buv = SvUVX(POPs);
		const UV auv = SvUVX(TOPs);
d296 1
a296 1
		if (iv < 0)
d299 4
a302 3
		else
		    /* we know iv is >= 0 */
		    SETs(boolSV((UV)iv == SvUVX(uvp)));
a308 6
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
      dPOPTOPnnrl;
      if (Perl_isnan(left) || Perl_isnan(right))
	  RETSETNO;
      SETs(boolSV(left == right));
#else
a310 1
#endif
d317 2
a318 2
    dVAR; dSP;
    if (SvTYPE(TOPs) >= SVt_PVGV && SvTYPE(TOPs) != SVt_PVLV)
d334 1
a334 1
    dVAR; dSP;
d338 1
a338 2
	if (PL_op->op_type == OP_OR)
            --SP;
a342 57
PP(pp_defined)
{
    dVAR; dSP;
    register SV* sv;
    bool defined;
    const int op_type = PL_op->op_type;
    const bool is_dor = (op_type == OP_DOR || op_type == OP_DORASSIGN);

    if (is_dor) {
        sv = TOPs;
        if (!sv || !SvANY(sv)) {
	    if (op_type == OP_DOR)
		--SP;
            RETURNOP(cLOGOP->op_other);
        }
    }
    else {
	/* OP_DEFINED */
        sv = POPs;
        if (!sv || !SvANY(sv))
            RETPUSHNO;
    }

    defined = FALSE;
    switch (SvTYPE(sv)) {
    case SVt_PVAV:
	if (AvMAX(sv) >= 0 || SvGMAGICAL(sv) || (SvRMAGICAL(sv) && mg_find(sv, PERL_MAGIC_tied)))
	    defined = TRUE;
	break;
    case SVt_PVHV:
	if (HvARRAY(sv) || SvGMAGICAL(sv) || (SvRMAGICAL(sv) && mg_find(sv, PERL_MAGIC_tied)))
	    defined = TRUE;
	break;
    case SVt_PVCV:
	if (CvROOT(sv) || CvXSUB(sv))
	    defined = TRUE;
	break;
    default:
	SvGETMAGIC(sv);
	if (SvOK(sv))
	    defined = TRUE;
	break;
    }

    if (is_dor) {
        if(defined) 
            RETURN; 
        if(op_type == OP_DOR)
            --SP;
        RETURNOP(cLOGOP->op_other);
    }
    /* assuming OP_DEFINED */
    if(defined) 
        RETPUSHYES;
    RETPUSHNO;
}

d345 2
a346 5
    dVAR; dSP; dATARGET; bool useleft; SV *svl, *svr;
    tryAMAGICbin(add,opASSIGN);
    svl = sv_2num(TOPm1s);
    svr = sv_2num(TOPs);
    useleft = USE_LEFT(svl);
d394 2
a395 2
    SvIV_please(svr);
    if (SvIOK(svr)) {
d411 4
a414 4
	    SvIV_please(svl);
	    if (SvIOK(svl)) {
		if ((auvok = SvUOK(svl)))
		    auv = SvUVX(svl);
d416 1
a416 1
		    register const IV aiv = SvIVX(svl);
d431 1
a431 1
	    bool buvok = SvUOK(svr);
d434 1
a434 1
		buv = SvUVX(svr);
d436 1
a436 1
		register const IV biv = SvIVX(svr);
d494 1
a494 2
	NV value = SvNV(svr);
	(void)POPs;
d500 1
a500 1
	SETn( value + SvNV(svl) );
d507 2
a508 2
    dVAR; dSP;
    AV * const av = PL_op->op_flags & OPf_SPECIAL ?
d511 1
a511 1
    SV** const svp = av_fetch(av, PL_op->op_private, lval);
d522 1
a522 1
    dVAR; dSP; dMARK; dTARGET;
d532 1
a532 1
    dVAR; dSP;
d538 1
a538 1
    SV* const sv = sv_newmortal();
d553 2
a554 1
    dVAR; dSP; dMARK; dORIGMARK;
d558 5
a562 1
    GV * const gv = (PL_op->op_flags & OPf_STACKED) ? (GV*)*++MARK : PL_defoutgv;
d633 1
a633 5
	    if (PL_op->op_type == OP_SAY) {
		if (PerlIO_write(fp, "\n", 1) == 0 || PerlIO_error(fp))
		    goto just_say_no;
	    }
            else if (PL_ors_sv && SvOK(PL_ors_sv))
d654 2
a655 8
    dVAR; dSP; dTOPss;
    const I32 gimme = GIMME_V;
    static const char return_array_to_lvalue_scalar[] = "Can't return array to lvalue scalar context";
    static const char return_hash_to_lvalue_scalar[] = "Can't return hash to lvalue scalar context";
    static const char an_array[] = "an ARRAY";
    static const char a_hash[] = "a HASH";
    const bool is_pp_rv2av = PL_op->op_type == OP_RV2AV;
    const svtype type = is_pp_rv2av ? SVt_PVAV : SVt_PVHV;
d659 1
a659 1
	tryAMAGICunDEREF_var(is_pp_rv2av ? to_av_amg : to_hv_amg);
d661 3
a663 3
	sv = SvRV(sv);
	if (SvTYPE(sv) != type)
	    DIE(aTHX_ "Not %s reference", is_pp_rv2av ? an_array : a_hash);
d665 1
a665 1
	    SETs(sv);
d669 3
a671 4
	    if (gimme != G_ARRAY)
		Perl_croak(aTHX_ is_pp_rv2av ? return_array_to_lvalue_scalar
			   : return_hash_to_lvalue_scalar);
	    SETs(sv);
d679 2
a680 1
	if (SvTYPE(sv) == type) {
d682 1
a682 1
		SETs(sv);
d686 4
a689 5
		if (gimme != G_ARRAY)
		    Perl_croak(aTHX_
			       is_pp_rv2av ? return_array_to_lvalue_scalar
			       : return_hash_to_lvalue_scalar);
		SETs(sv);
d697 3
d705 29
a733 4
		gv = Perl_softref2xv(aTHX_ sv, is_pp_rv2av ? an_array : a_hash,
				     type, &sp);
		if (!gv)
		    RETURN;
d738 1
a738 1
	    sv = is_pp_rv2av ? (SV*)GvAVn(gv) : (SV*)GvHVn(gv);
d740 1
a740 1
		sv = is_pp_rv2av ? (SV*)save_ary(gv) : (SV*)save_hash(gv);
d742 1
a742 1
		SETs(sv);
d746 4
a749 5
		if (gimme != G_ARRAY)
		    Perl_croak(aTHX_
			       is_pp_rv2av ? return_array_to_lvalue_scalar
			       : return_hash_to_lvalue_scalar);
		SETs(sv);
d755 1
a755 6
    if (is_pp_rv2av) {
	AV *const av = (AV*)sv;
	/* The guts of pp_rv2av, with no intenting change to preserve history
	   (until such time as we get tools that can do blame annotation across
	   whitespace changes.  */
    if (gimme == G_ARRAY) {
d762 1
a762 1
		SV ** const svp = av_fetch(av, i, FALSE);
d774 1
a774 1
    else if (gimme == G_SCALAR) {
d779 106
a884 2
    } else {
	/* The guts of pp_rv2hv  */
d886 1
a886 1
	*PL_stack_sp = sv;
d891 5
a895 2
    TARG = Perl_hv_scalar(aTHX_ (HV*)sv);
	SPAGAIN;
d898 19
d918 26
a943 1
    RETURN;
a948 1
    dVAR;
d951 1
a951 3
        const HE *didstore;

        if (ckWARN(WARN_MISC)) {
d964 20
a983 10

        tmpstr = newSV(0);
        didstore = hv_store_ent(hash,*relem,tmpstr,0);
        if (SvMAGICAL(hash)) {
            if (SvSMAGICAL(tmpstr))
                mg_set(tmpstr);
            if (!didstore)
                sv_2mortal(tmpstr);
        }
        TAINT_NOT;
d989 1
a989 1
    dVAR; dSP;
d1006 2
a1007 1
    SV **firsthashrelem = NULL;	/* "= 0" keeps gcc 2.95 quiet  */
d1028 2
a1029 2
    ary = NULL;
    hash = NULL;
d1038 13
a1067 2
	    if (PL_delaymagic & DM_ARRAY)
		SvSETMAGIC((SV*)ary);
d1079 5
a1083 3
		    sv = *relem ? *relem : &PL_sv_no;
		    relem++;
		    tmpstr = newSV(0);
a1215 1

d1221 5
a1225 7
    dVAR; dSP;
    register PMOP * const pm = cPMOP;
    REGEXP * rx = PM_GETRE(pm);
    SV * const pkg = CALLREG_PACKAGE(rx);
    SV * const rv = sv_newmortal();
    SV * const sv = newSVrv(rv, SvPV_nolen(pkg));
    if (rx->extflags & RXf_TAINTED)
d1227 2
a1228 3
    sv_magic(sv,(SV*)ReREFCNT_inc(rx), PERL_MAGIC_qr,0,0);
    XPUSHs(rv);
    RETURN;
d1233 1
a1233 1
    dVAR; dSP; dTARG;
a1249 1
    U32 gpos = 0;
a1252 2
    else if (PL_op->op_private & OPpTARGET_MY)
	GETTARGET;
d1263 1
a1263 1
    rxtainted = ((rx->extflags & RXf_TAINTED) ||
d1270 1
a1270 7
    if (
#ifdef USE_ITHREADS
        SvREADONLY(PL_regex_pad[pm->op_pmoffset])
#else
        pm->op_pmflags & PMf_USED
#endif
    ) {
a1276 2


d1290 1
a1290 1
	rx->offs[0].start = -1;
d1292 1
a1292 1
	    MAGIC* const mg = mg_find(TARG, PERL_MAGIC_regex_global);
d1294 3
a1296 3
		if (!(rx->extflags & RXf_GPOS_SEEN))
		    rx->offs[0].end = rx->offs[0].start = mg->mg_len;
		else if (rx->extflags & RXf_ANCH_GPOS) {
d1298 3
a1300 6
		    rx->offs[0].end = rx->offs[0].start = mg->mg_len;
		} else if (rx->extflags & RXf_GPOS_FLOAT) 
		    gpos = mg->mg_len;
		else 
		    rx->offs[0].end = rx->offs[0].start = mg->mg_len;
		minmatch = (mg->mg_flags & MGf_MINMATCH) ? rx->gofs + 1 : 0;
d1305 2
a1306 8
    /* XXX: comment out !global get safe $1 vars after a
       match, BUT be aware that this leads to dramatic slowdowns on
       /g matches against large strings.  So far a solution to this problem
       appears to be quite tricky.
       Test for the unsafe vars are TODO for now. */
    if ((  !global &&  rx->nparens) 
	    || SvTEMP(TARG) || PL_sawampersand ||
	    (rx->extflags & (RXf_EVAL_SEEN|RXf_PMf_KEEPCOPY)))
d1311 5
d1317 3
a1319 3
    if (global && rx->offs[0].start != -1) {
	t = s = rx->offs[0].end + truebase - rx->gofs;
	if ((s + rx->minlen) > strend || s < truebase)
d1324 2
a1325 2
    if (rx->extflags & RXf_USE_INTUIT &&
	DO_UTF8(TARG) == ((rx->extflags & RXf_UTF8) != 0)) {
d1328 1
a1328 1
	s = CALLREG_INTUIT_START(rx, TARG, (char *)s, (char *)strend, r_flags, NULL);
d1332 1
a1332 1
	if ( (rx->extflags & RXf_CHECK_ALL)
d1334 2
a1335 3
	     && !(rx->extflags & RXf_PMf_KEEPCOPY)
	     && ((rx->extflags & RXf_NOSCAN)
		 || !((rx->extflags & RXf_INTUIT_TAIL)
d1340 1
a1340 1
    if (CALLREGEXEC(rx, (char*)s, (char *)strend, (char*)truebase, minmatch, TARG, INT2PTR(void*, gpos), r_flags))
d1343 2
a1344 7
	if (dynpm->op_pmflags & PMf_ONCE) {
#ifdef USE_ITHREADS
            SvREADONLY_on(PL_regex_pad[dynpm->op_pmoffset]);
#else
	    dynpm->op_pmflags |= PMf_USED;
#endif
        }
d1364 4
a1367 4
	    if ((rx->offs[i].start != -1) && rx->offs[i].end != -1 ) {
		const I32 len = rx->offs[i].end - rx->offs[i].start;
		s = rx->offs[i].start + truebase;
	        if (rx->offs[i].end < 0 || rx->offs[i].start < 0 ||
d1377 1
a1377 1
		MAGIC* mg = NULL;
d1381 2
a1382 6
#ifdef PERL_OLD_COPY_ON_WRITE
		    if (SvIsCOW(TARG))
			sv_force_normal_flags(TARG, 0);
#endif
		    mg = sv_magicext(TARG, NULL, PERL_MAGIC_regex_global,
				     &PL_vtbl_mglob, NULL, 0);
d1384 3
a1386 3
		if (rx->offs[0].start != -1) {
		    mg->mg_len = rx->offs[0].end;
		    if (rx->offs[0].start + rx->gofs == (UV)rx->offs[0].end)
d1392 2
a1393 3
	    had_zerolen = (rx->offs[0].start != -1
			   && (rx->offs[0].start + rx->gofs
			       == (UV)rx->offs[0].end));
d1405 1
a1405 1
	    MAGIC* mg;
a1407 2
	    else
		mg = NULL;
d1409 2
a1410 6
#ifdef PERL_OLD_COPY_ON_WRITE
		if (SvIsCOW(TARG))
		    sv_force_normal_flags(TARG, 0);
#endif
		mg = sv_magicext(TARG, NULL, PERL_MAGIC_regex_global,
				 &PL_vtbl_mglob, NULL, 0);
d1412 3
a1414 3
	    if (rx->offs[0].start != -1) {
		mg->mg_len = rx->offs[0].end;
		if (rx->offs[0].start + rx->gofs == (UV)rx->offs[0].end)
d1429 2
a1430 7
    if (dynpm->op_pmflags & PMf_ONCE) {
#ifdef USE_ITHREADS
        SvREADONLY_on(PL_regex_pad[dynpm->op_pmoffset]);
#else
        dynpm->op_pmflags |= PMf_USED;
#endif
    }
d1434 1
a1434 1
    rx->subbeg = NULL;
d1438 1
a1438 1
	rx->offs[0].start = s - truebase;
d1440 2
a1441 2
	    char * const t = (char*)utf8_hop((U8*)s, rx->minlenret);
	    rx->offs[0].end = t - truebase;
d1444 1
a1444 1
	    rx->offs[0].end = s - truebase + rx->minlenret;
d1449 1
a1449 1
    if (PL_sawampersand || rx->extflags & RXf_PMf_KEEPCOPY) {
a1450 14
#ifdef PERL_OLD_COPY_ON_WRITE
	if (SvIsCOW(TARG) || (SvFLAGS(TARG) & CAN_COW_MASK) == CAN_COW_FLAGS) {
	    if (DEBUG_C_TEST) {
		PerlIO_printf(Perl_debug_log,
			      "Copy on write: pp_match $& capture, type %d, truebase=%p, t=%p, difference %d\n",
			      (int) SvTYPE(TARG), (void*)truebase, (void*)t,
			      (int)(t-truebase));
	    }
	    rx->saved_copy = sv_setsv_cow(rx->saved_copy, TARG);
	    rx->subbeg = (char *) SvPVX_const(rx->saved_copy) + (t - truebase);
	    assert (SvPOKp(rx->saved_copy));
	} else
#endif
	{
d1452 1
a1452 5
	    rx->subbeg = savepvn(t, strend - t);
#ifdef PERL_OLD_COPY_ON_WRITE
	    rx->saved_copy = NULL;
#endif
	}
d1455 2
a1456 2
	off = rx->offs[0].start = s - t;
	rx->offs[0].end = off + rx->minlenret;
d1459 2
a1460 2
	rx->offs[0].start = s - truebase;
	rx->offs[0].end = s - truebase + rx->minlenret;
a1461 2
    /* including rx->nparens in the below code seems highly suspicious.
       -dmq */
d1470 1
a1470 1
	    MAGIC* const mg = mg_find(TARG, PERL_MAGIC_regex_global);
d1484 1
a1484 1
    dVAR; dSP; dTARGETSTACKED;
d1492 1
d1494 12
a1505 16
    if (io) {
	MAGIC * const mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar);
	if (mg) {
	    PUSHMARK(SP);
	    XPUSHs(SvTIED_obj((SV*)io, mg));
	    PUTBACK;
	    ENTER;
	    call_method("READLINE", gimme);
	    LEAVE;
	    SPAGAIN;
	    if (gimme == G_SCALAR) {
		SV* const result = POPs;
		SvSetSV_nosteal(TARG, result);
		PUSHTARG;
	    }
	    RETURN;
d1507 1
d1509 1
a1509 1
    fp = NULL;
d1518 1
a1518 1
			do_open(PL_last_in_gv,"-",1,FALSE,O_RDONLY,0,NULL);
d1553 2
a1554 2
		SV_CHECK_THINKFIRST_COW_DROP(TARG);
		SvOK_off(TARG);
d1563 3
a1565 12
	if (type == OP_RCATLINE && SvGMAGICAL(sv))
	    mg_get(sv);
	if (SvROK(sv)) {
	    if (type == OP_RCATLINE)
		SvPV_force_nolen(sv);
	    else
		sv_unref(sv);
	}
	else if (isGV_with_GP(sv)) {
	    SvPV_force_nolen(sv);
	}
	SvUPGRADE(sv, SVt_PV);
d1578 1
a1578 1
	sv = sv_2mortal(newSV(80));
d1618 1
a1618 1
		    SV_CHECK_THINKFIRST_COW_DROP(TARG);
d1634 1
d1638 1
a1638 1
		char * const tmps = SvEND(sv) - 1;
d1653 10
a1662 11
	     if (ckWARN(WARN_UTF8)) {
		const U8 * const s = (const U8*)SvPVX_const(sv) + offset;
		const STRLEN len = SvCUR(sv) - offset;
		const U8 *f;

		if (!is_utf8_string_loc(s, len, &f))
		    /* Emulate :encoding(utf8) warning in the same case. */
		    Perl_warner(aTHX_ packWARN(WARN_UTF8),
				"utf8 \"\\x%02X\" does not map to Unicode",
				f < (U8*)SvEND(sv) ? *f : 0);
	     }
d1668 1
a1668 1
	    sv = sv_2mortal(newSV(80));
d1683 1
a1683 1
    dVAR; dSP;
d1704 1
a1704 1
    dVAR; dSP;
d1707 2
a1708 2
    SV * const keysv = POPs;
    HV * const hv = (HV*)POPs;
d1715 29
a1743 1
    if (SvTYPE(hv) != SVt_PVHV)
a1744 17

    if (PL_op->op_private & OPpLVAL_INTRO) {
	MAGIC *mg;
	HV *stash;
	/* does the element we're localizing already exist? */
	preeminent = /* can we determine whether it exists? */
	    (    !SvRMAGICAL(hv)
		|| mg_find((SV*)hv, PERL_MAGIC_env)
		|| (     (mg = mg_find((SV*)hv, PERL_MAGIC_tied))
			/* Try to preserve the existenceness of a tied hash
			* element by using EXISTS and DELETE if possible.
			* Fallback to FETCH and STORE otherwise */
		    && (stash = SvSTASH(SvRV(SvTIED_obj((SV*)hv, mg))))
		    && gv_fetchmethod_autoload(stash, "EXISTS", TRUE)
		    && gv_fetchmethod_autoload(stash, "DELETE", TRUE)
		)
	    ) ? hv_exists_ent(hv, keysv, 0) : 1;
a1745 2
    he = hv_fetch_ent(hv, keysv, lval && !defer, hash);
    svp = he ? &HeVAL(he) : NULL;
d1751 1
a1751 1
		DIE(aTHX_ PL_no_helem_sv, SVfARG(keysv));
d1756 1
a1756 1
	    sv_magic(lv, key2 = newSVsv(keysv), PERL_MAGIC_defelem, NULL, 0);
d1758 1
a1758 1
	    LvTARG(lv) = SvREFCNT_inc_simple(hv);
d1770 1
a1770 2
		    SAVEDELETE(hv, savepvn(key,keylen),
			       SvUTF8(keysv) ? -(I32)keylen : (I32)keylen);
d1793 1
a1793 1
    dVAR; dSP;
d1850 1
a1850 1
    dVAR; dSP;
d1869 1
a1869 3
	    const char *max =
	      SvOK((SV*)av) ?
	      SvPV_const((SV*)av, maxlen) : (const char *)"";
d1871 1
d1877 1
d1898 1
a1898 1
	/* don't risk potential race */
d1904 1
d1923 2
a1924 2
	    SV * const * const svp = av_fetch(av, --cx->blk_loop.iterix, FALSE);
	    sv = svp ? *svp : NULL;
d1936 5
a1940 2
	    SV * const * const svp = av_fetch(av, ++cx->blk_loop.iterix, FALSE);
	    sv = svp ? *svp : NULL;
d1947 2
a1948 2
    if (sv && SvIS_FREED(sv)) {
	*itersvp = NULL;
d1960 1
a1960 1
	    lv = NULL;
d1965 2
a1966 1
	    lv = cx->blk_loop.iterlval = newSV_type(SVt_PVLV);
d1968 1
a1968 1
	    sv_magic(lv, NULL, PERL_MAGIC_defelem, NULL, 0);
d1970 1
a1970 1
	LvTARG(lv) = SvREFCNT_inc_simple(av);
d1977 1
a1977 1
    *itersvp = SvREFCNT_inc_simple_NN(sv);
d1985 1
a1985 1
    dVAR; dSP; dTARG;
d1988 1
d2005 1
a2005 1
    const I32 oldsave = PL_savestack_ix;
d2008 1
a2008 4
#ifdef PERL_OLD_COPY_ON_WRITE
    bool is_cow;
#endif
    SV *nsv = NULL;
d2011 1
a2011 1
    register SV *dstr = (pm->op_pmflags & PMf_CONST) ? POPs : NULL;
a2013 2
    else if (PL_op->op_private & OPpTARGET_MY)
	GETTARGET;
d2019 5
a2023 16
#ifdef PERL_OLD_COPY_ON_WRITE
    /* Awooga. Awooga. "bool" types that are actually char are dangerous,
       because they make integers such as 256 "false".  */
    is_cow = SvIsCOW(TARG) ? TRUE : FALSE;
#else
    if (SvIsCOW(TARG))
	sv_force_normal_flags(TARG,0);
#endif
    if (
#ifdef PERL_OLD_COPY_ON_WRITE
	!is_cow &&
#endif
	(SvREADONLY(TARG)
	 || ( ((SvTYPE(TARG) == SVt_PVGV && isGV_with_GP(TARG))
	       || SvTYPE(TARG) > SVt_PVLV)
	     && !(SvTYPE(TARG) == SVt_PVGV && SvFAKE(TARG)))))
d2030 1
a2030 1
    rxtainted = ((rx->extflags & RXf_TAINTED) ||
d2052 2
a2053 3
    r_flags = (rx->nparens || SvTEMP(TARG) || PL_sawampersand
	    || (rx->extflags & (RXf_EVAL_SEEN|RXf_PMf_KEEPCOPY)) )
	       ? REXEC_COPY_STR : 0;
d2056 4
a2059 1

d2061 1
a2061 1
    if (rx->extflags & RXf_USE_INTUIT) {
d2063 1
a2063 1
	s = CALLREG_INTUIT_START(rx, TARG, s, strend, r_flags, NULL);
d2068 1
a2068 1
/*	if ( (rx->extflags & RXf_CHECK_ALL)
d2070 2
a2071 3
	     && !(rx->extflags & RXf_KEEPCOPY)
	     && ((rx->extflags & RXf_NOSCAN)
		 || !((rx->extflags & RXf_INTUIT_TAIL)
d2099 1
a2099 1
	c = NULL;
d2104 2
a2105 6
    if (c
#ifdef PERL_OLD_COPY_ON_WRITE
	&& !is_cow
#endif
	&& (I32)clen <= rx->minlenret && (once || !(r_flags & REXEC_COPY_STR))
	&& !(rx->extflags & RXf_LOOKBEHIND_SEEN)
d2107 1
a2107 1
	if (!CALLREGEXEC(rx, s, strend, orig, 0, TARG, NULL,
a2114 6
#ifdef PERL_OLD_COPY_ON_WRITE
	if (SvIsCOW(TARG)) {
	    assert (!force_on_match);
	    goto have_a_cow;
	}
#endif
d2125 2
a2126 2
	    m = orig + rx->offs[0].start;
	    d = orig + rx->offs[0].end;
d2168 1
a2168 1
		m = rx->offs[0].start + orig;
d2178 2
a2179 2
		s = rx->offs[0].end + orig;
	    } while (CALLREGEXEC(rx, s, strend, orig, s == m,
d2206 1
a2206 1
    if (CALLREGEXEC(rx, s, strend, orig, 0, TARG, NULL,
a2213 3
#ifdef PERL_OLD_COPY_ON_WRITE
      have_a_cow:
#endif
a2215 1
	SAVEFREESV(dstr);
d2222 1
d2224 1
a2224 1
	    RETURNOP(cPMOP->op_pmreplrootu.op_pmreplroot);
d2238 1
a2238 1
	    m = rx->offs[0].start + orig;
d2243 1
a2243 1
	    s = rx->offs[0].end + orig;
d2248 1
a2248 1
	} while (CALLREGEXEC(rx, s, strend, orig, s == m,
d2255 1
a2255 13
#ifdef PERL_OLD_COPY_ON_WRITE
	/* The match may make the string COW. If so, brilliant, because that's
	   just saved us one malloc, copy and free - the regexp has donated
	   the old buffer, and we malloc an entirely new one, rather than the
	   regexp malloc()ing a buffer and copying our original, only for
	   us to throw it away here during the substitution.  */
	if (SvIsCOW(TARG)) {
	    sv_force_normal_flags(TARG, SV_COW_DROP_PV);
	} else
#endif
	{
	    SvPV_free(TARG);
	}
d2260 2
a2261 1
	SvPV_set(dstr, NULL);
d2288 1
a2288 1
    dVAR; dSP;
d2298 1
a2298 1
	const I32 gimme = GIMME_V;
d2306 2
a2307 9
	    if (PL_op->op_private & OPpGREP_LEX) {
		SV* const sv = sv_newmortal();
		sv_setiv(sv, items);
		PUSHs(sv);
	    }
	    else {
		dTARGET;
		XPUSHi(items);
	    }
d2321 1
a2321 4
	if (PL_op->op_private & OPpGREP_LEX)
	    PAD_SVl(PL_op->op_targ) = src;
	else
	    DEFSV = src;
d2329 1
a2329 1
    dVAR; dSP;
a2336 3
    if (CxMULTICALL(&cxstack[cxstack_ix]))
	return 0;

d2382 1
a2382 1
    return cx->blk_sub.retop;
d2389 1
a2389 1
    dVAR; dSP;
a2396 3
    if (CxMULTICALL(&cxstack[cxstack_ix]))
	return 0;

d2418 1
a2418 1
		    NOOP;
d2424 1
a2424 1
		    SvREFCNT_inc_void(*mark);
d2461 1
a2461 1
		    SvREFCNT_inc_void(*mark);
d2493 1
a2493 1
		    SvREFCNT_inc_void(*mark);
d2543 40
a2582 1
    return cx->blk_sub.retop;
d2587 1
a2587 1
    dVAR; dSP; dPOPss;
d2589 1
a2597 12
	/* This is overwhelming the most common case:  */
    case SVt_PVGV:
	if (!(cv = GvCVu((GV*)sv))) {
	    HV *stash;
	    cv = sv_2cv(sv, &stash, &gv, 0);
	}
	if (!cv) {
	    ENTER;
	    SAVETMPS;
	    goto try_autoload;
	}
	break;
a2600 1
	    STRLEN len;
d2610 1
a2610 7
		if (SvPOKp(sv)) {
		    sym = SvPVX_const(sv);
		    len = SvCUR(sv);
		} else {
		    sym = NULL;
		    len = 0;
		}
d2613 1
a2613 1
		sym = SvPV_const(sv, len);
d2619 1
a2619 1
	    cv = get_cvn_flags(sym, len, GV_ADD|SvUTF8(sv));
a2633 1
	/* This is the second most common case:  */
d2637 9
d2675 2
a2676 2
		gv_efullname3(sub_name, gv, NULL);
		DIE(aTHX_ "Undefined subroutine &%"SVf" called", SVfARG(sub_name));
d2686 1
a2686 5
	 Perl_get_db_sub(aTHX_ &sv, cv);
	 if (CvISXSUB(cv))
	     PL_curcopdb = PL_curcop;
	 cv = GvCV(PL_DBsub);

d2691 201
a2891 2
    if (!(CvISXSUB(cv))) {
	/* This path taken at least 75% of the time   */
d2894 2
a2895 1
	AV* const padlist = CvPADLIST(cv);
a2897 1
	cx->blk_sub.retop = PL_op->op_next;
d2906 1
a2906 1
	    pad_push(padlist, CvDEPTH(cv));
d2908 15
d2925 12
a2936 2
	if (hasargs) {
	    AV* const av = (AV*)PAD_SVl(0);
d2944 1
d2946 2
a2947 1
	    GvAV(PL_defgv) = (AV*)SvREFCNT_inc_simple(av);
d2953 1
a2953 1
		SV **ary = AvALLOC(av);
d2956 1
a2956 1
		    AvARRAY(av) = ary;
d2962 1
a2962 1
		    AvARRAY(av) = ary;
d2983 1
a2983 1
			      "%p entersub returning %p\n", (void*)thr, (void*)CvSTART(cv)));
a2986 41
    else {
	I32 markix = TOPMARK;

	PUTBACK;

	if (!hasargs) {
	    /* Need to copy @@_ to stack. Alternative may be to
	     * switch stack to @@_, and copy return values
	     * back. This would allow popping @@_ in XSUB, e.g.. XXXX */
	    AV * const av = GvAV(PL_defgv);
	    const I32 items = AvFILLp(av) + 1;   /* @@_ is not tieable */

	    if (items) {
		/* Mark is at the end of the stack. */
		EXTEND(SP, items);
		Copy(AvARRAY(av), SP + 1, items, SV*);
		SP += items;
		PUTBACK ;		
	    }
	}
	/* We assume first XSUB in &DB::sub is the called one. */
	if (PL_curcopdb) {
	    SAVEVPTR(PL_curcop);
	    PL_curcop = PL_curcopdb;
	    PL_curcopdb = NULL;
	}
	/* Do we need to open block here? XXXX */
	if (CvXSUB(cv)) /* XXX this is supposed to be true */
	    (void)(*CvXSUB(cv))(aTHX_ cv);

	/* Enforce some sanity in scalar context. */
	if (gimme == G_SCALAR && ++markix != PL_stack_sp - PL_stack_base ) {
	    if (markix > PL_stack_sp - PL_stack_base)
		*(PL_stack_base + markix) = &PL_sv_undef;
	    else
		*(PL_stack_base + markix) = *PL_stack_sp;
	    PL_stack_sp = PL_stack_base + markix;
	}
	LEAVE;
	return NORMAL;
    }
d2996 1
a2996 1
	gv_efullname3(tmpstr, CvGV(cv), NULL);
d2998 1
a2998 1
		    SVfARG(tmpstr));
d3004 1
a3004 1
    dVAR; dSP;
d3008 1
a3008 1
    AV* const av = (AV*)POPs;
d3014 1
a3014 3
	Perl_warner(aTHX_ packWARN(WARN_MISC),
		    "Use of reference \"%"SVf"\" as array index",
		    SVfARG(elemsv));
d3016 1
a3016 1
	elem -= CopARYBASE_get(PL_curcop);
d3041 2
a3042 2
	    sv_magic(lv, NULL, PERL_MAGIC_defelem, NULL, 0);
	    LvTARG(lv) = SvREFCNT_inc_simple(av);
d3063 2
a3064 1
    SvGETMAGIC(sv);
d3077 1
a3077 1
	    SvRV_set(sv, newSV(0));
d3093 1
a3093 1
    dVAR; dSP;
d3104 1
a3104 1
    SETs(method_common(sv, NULL));
d3110 1
a3110 1
    dVAR; dSP;
a3120 1
    dVAR;
d3125 2
a3126 2
    const char* packname = NULL;
    SV *packsv = NULL;
d3134 2
a3135 1
    SvGETMAGIC(sv);
d3152 1
a3152 1
	    !(iogv = gv_fetchsv(sv, 0, SVt_PVIO)) ||
d3167 1
a3167 1
	    stash = gv_stashpvn(packname, packlen, 0);
d3171 2
a3172 2
	        SV* const ref = newSViv(PTR2IV(stash));
	        (void)hv_store(PL_stashcache, packname, packlen, ref, 0);
a3185 1
		   (SvSCREAM(meth) && strEQ(name,"isa")) ? "DOES" :
d3201 1
a3201 2
		(!GvCVGEN(gv) || GvCVGEN(gv)
                  == (PL_sub_generation + HvMROMETA(stash)->cache_gen)))
d3217 1
a3217 1
	const char* sep = NULL;
d3227 4
a3230 26
	    /* the method name is unqualified or starts with SUPER:: */
#ifndef USE_ITHREADS
	    if (sep)
		stash = CopSTASH(PL_curcop);
#else
	    bool need_strlen = 1;
	    if (sep) {
		packname = CopSTASHPV(PL_curcop);
	    }
	    else
#endif
	    if (stash) {
		HEK * const packhek = HvNAME_HEK(stash);
		if (packhek) {
		    packname = HEK_KEY(packhek);
		    packlen = HEK_LEN(packhek);
#ifdef USE_ITHREADS
		    need_strlen = 0;
#endif
		} else {
		    goto croak;
		}
	    }

	    if (!packname) {
	    croak:
d3233 1
a3233 3
	    }
#ifdef USE_ITHREADS
	    if (need_strlen)
a3234 2
#endif

d3243 1
a3243 1
	if (gv_stashpvn(packname, packlen, 0)) {
d3257 19
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d15 2
a16 4
 *                  Awake!  Awake!  Fear, Fire, Foes!  Awake!
 *                               Fire, Foes!  Awake!
 *
 *     [p.1007 of _The Lord of the Rings_, VI/viii: "The Scouring of the Shire"]
d46 1
a46 1
        mXPUSHs((SV*)Perl_hv_copy_hints_hv(aTHX_ (HV*)cSVOP_sv));
d106 1
a106 1
    XPUSHs(MUTABLE_SV(cGVOP_gv));
d153 1
a153 1
		SvUPGRADE(MUTABLE_SV(gv), SVt_RV);
d165 1
a165 1
	    right = MUTABLE_SV(gv_fetchsv(right, GV_ADD, SVt_PVGV));
d179 2
a180 2
		SvRV_set(left, MUTABLE_SV(newCONSTSUB(GvSTASH(right), NULL,
						      SvRV(cv))));
d197 1
a197 1
		GV *const upgraded = MUTABLE_GV(cv);
d205 1
a205 1
		SvRV_set(left, MUTABLE_SV(source));
d251 1
a251 1
	right = newSVpvn_flags(rpv, rlen, SVs_TEMP);
d272 1
a272 1
	    sv_setpvs(left, "");
d290 1
a290 1
		right = newSVpvn_flags(rpv, rlen, SVs_TEMP);
d323 4
a326 4
    PL_last_in_gv = MUTABLE_GV(*PL_stack_sp--);
    if (!isGV_with_GP(PL_last_in_gv)) {
	if (SvROK(PL_last_in_gv) && isGV_with_GP(SvRV(PL_last_in_gv)))
	    PL_last_in_gv = MUTABLE_GV(SvRV(PL_last_in_gv));
d329 1
a329 1
	    XPUSHs(MUTABLE_SV(PL_last_in_gv));
d332 1
a332 1
	    PL_last_in_gv = MUTABLE_GV(*PL_stack_sp--);
d414 2
a415 2
    if (SvTYPE(TOPs) >= SVt_PVAV || isGV_with_GP(TOPs))
	DIE(aTHX_ "%s", PL_no_modify);
d666 2
a667 2
    AV * const av = PL_op->op_flags & OPf_SPECIAL
	? MUTABLE_AV(PAD_SV(PL_op->op_targ)) : GvAV(cGVOP_gv);
d702 1
a702 1
    XPUSHs(MUTABLE_SV(PL_op));
d715 1
a715 2
    GV * const gv
	= (PL_op->op_flags & OPf_STACKED) ? MUTABLE_GV(*++MARK) : PL_defoutgv;
d718 1
a718 1
	&& (mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar)))
d731 1
a731 1
	*MARK = SvTIED_obj(MUTABLE_SV(io), mg);
a733 5
	if( PL_op->op_type == OP_SAY ) {
		/* local $\ = "\n" */
		SAVEGENERICSV(PL_ors_sv);
		PL_ors_sv = newSVpvs("\n");
	}
d744 1
a744 1
	    && (mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar)))
d813 2
d833 2
a834 1
		goto croak_cant_return;
d840 1
a840 1
	    Perl_croak(aTHX_ "%s", PL_no_localize_ref);
d850 3
a852 1
		    goto croak_cant_return;
d860 1
a860 1
	    if (!isGV_with_GP(sv)) {
d872 1
a872 1
		gv = MUTABLE_GV(sv);
d874 1
a874 1
	    sv = is_pp_rv2av ? MUTABLE_SV(GvAVn(gv)) : MUTABLE_SV(GvHVn(gv));
d876 1
a876 1
		sv = is_pp_rv2av ? MUTABLE_SV(save_ary(gv)) : MUTABLE_SV(save_hash(gv));
d883 3
a885 1
		    goto croak_cant_return;
d893 1
a893 1
	AV *const av = MUTABLE_AV(sv);
d929 1
a929 1
    TARG = Perl_hv_scalar(aTHX_ MUTABLE_HV(sv));
a934 5

 croak_cant_return:
    Perl_croak(aTHX_ "Can't return %s to lvalue scalar context",
	       is_pp_rv2av ? "array" : "hash");
    RETURN;
a940 3

    PERL_ARGS_ASSERT_DO_ODDBALL;

d956 1
a956 1
	    Perl_warner(aTHX_ packWARN(WARN_MISC), "%s", err);
d1019 1
a1019 1
	    ary = MUTABLE_AV(sv);
d1031 1
a1031 5
		    if (SvSMAGICAL(sv)) {
			/* More magic can happen in the mg_set callback, so we
			 * backup the delaymagic for now. */
			U16 dmbak = PL_delaymagic;
			PL_delaymagic = 0;
a1032 2
			PL_delaymagic = dmbak;
		    }
d1039 1
a1039 1
		SvSETMAGIC(MUTABLE_SV(ary));
d1044 1
a1044 1
		hash = MUTABLE_HV(sv);
d1062 1
a1062 3
			if (SvSMAGICAL(tmpstr)) {
			    U16 dmbak = PL_delaymagic;
			    PL_delaymagic = 0;
a1063 2
			    PL_delaymagic = dmbak;
			}
d1087 1
a1087 7

	    if (SvSMAGICAL(sv)) {
		U16 dmbak = PL_delaymagic;
		PL_delaymagic = 0;
		mg_set(sv);
		PL_delaymagic = dmbak;
	    }
d1198 1
a1198 2
    SvREFCNT_dec(pkg);
    if (RX_EXTFLAGS(rx) & RXf_TAINTED)
d1240 1
a1240 1
    rxtainted = ((RX_EXTFLAGS(rx) & RXf_TAINTED) ||
d1263 1
a1263 1
    if (!RX_PRELEN(rx) && PL_curpm) {
d1268 1
a1268 1
    if (RX_MINLEN(rx) > (I32)len)
d1275 1
a1275 1
	RX_OFFS(rx)[0].start = -1;
d1279 3
a1281 3
		if (!(RX_EXTFLAGS(rx) & RXf_GPOS_SEEN))
		    RX_OFFS(rx)[0].end = RX_OFFS(rx)[0].start = mg->mg_len;
		else if (RX_EXTFLAGS(rx) & RXf_ANCH_GPOS) {
d1283 2
a1284 2
		    RX_OFFS(rx)[0].end = RX_OFFS(rx)[0].start = mg->mg_len;
		} else if (RX_EXTFLAGS(rx) & RXf_GPOS_FLOAT) 
d1287 2
a1288 2
		    RX_OFFS(rx)[0].end = RX_OFFS(rx)[0].start = mg->mg_len;
		minmatch = (mg->mg_flags & MGf_MINMATCH) ? RX_GOFS(rx) + 1 : 0;
d1298 1
a1298 1
    if ((  !global && RX_NPARENS(rx)) 
d1300 1
a1300 1
	    (RX_EXTFLAGS(rx) & (RXf_EVAL_SEEN|RXf_PMf_KEEPCOPY)))
d1306 3
a1308 3
    if (global && RX_OFFS(rx)[0].start != -1) {
	t = s = RX_OFFS(rx)[0].end + truebase - RX_GOFS(rx);
	if ((s + RX_MINLEN(rx)) > strend || s < truebase)
d1313 2
a1314 2
    if (RX_EXTFLAGS(rx) & RXf_USE_INTUIT &&
	DO_UTF8(TARG) == (RX_UTF8(rx) != 0)) {
d1321 1
a1321 1
	if ( (RX_EXTFLAGS(rx) & RXf_CHECK_ALL)
d1323 3
a1325 3
	     && !(RX_EXTFLAGS(rx) & RXf_PMf_KEEPCOPY)
	     && ((RX_EXTFLAGS(rx) & RXf_NOSCAN)
		 || !((RX_EXTFLAGS(rx) & RXf_INTUIT_TAIL)
d1330 1
a1330 2
    if (CALLREGEXEC(rx, (char*)s, (char *)strend, (char*)truebase,
                    minmatch, TARG, NUM2PTR(void*, gpos), r_flags))
d1351 1
a1351 1
	const I32 nparens = RX_NPARENS(rx);
d1359 4
a1362 4
	    if ((RX_OFFS(rx)[i].start != -1) && RX_OFFS(rx)[i].end != -1 ) {
		const I32 len = RX_OFFS(rx)[i].end - RX_OFFS(rx)[i].start;
		s = RX_OFFS(rx)[i].start + truebase;
	        if (RX_OFFS(rx)[i].end < 0 || RX_OFFS(rx)[i].start < 0 ||
d1383 3
a1385 3
		if (RX_OFFS(rx)[0].start != -1) {
		    mg->mg_len = RX_OFFS(rx)[0].end;
		    if (RX_OFFS(rx)[0].start + RX_GOFS(rx) == (UV)RX_OFFS(rx)[0].end)
d1391 3
a1393 3
	    had_zerolen = (RX_OFFS(rx)[0].start != -1
			   && (RX_OFFS(rx)[0].start + RX_GOFS(rx)
			       == (UV)RX_OFFS(rx)[0].end));
d1418 3
a1420 3
	    if (RX_OFFS(rx)[0].start != -1) {
		mg->mg_len = RX_OFFS(rx)[0].end;
		if (RX_OFFS(rx)[0].start + RX_GOFS(rx) == (UV)RX_OFFS(rx)[0].end)
d1443 1
a1443 1
	Safefree(RX_SUBBEG(rx));
d1445 1
a1445 1
    RX_SUBBEG(rx) = NULL;
d1448 2
a1449 2
	RX_SUBBEG(rx) = (char *) truebase;
	RX_OFFS(rx)[0].start = s - truebase;
d1451 2
a1452 2
	    char * const t = (char*)utf8_hop((U8*)s, RX_MINLENRET(rx));
	    RX_OFFS(rx)[0].end = t - truebase;
d1455 1
a1455 1
	    RX_OFFS(rx)[0].end = s - truebase + RX_MINLENRET(rx);
d1457 1
a1457 1
	RX_SUBLEN(rx) = strend - truebase;
d1460 1
a1460 1
    if (PL_sawampersand || RX_EXTFLAGS(rx) & RXf_PMf_KEEPCOPY) {
d1471 1
a1471 1
	    RX_SUBBEG(rx) = (char *) SvPVX_const(rx->saved_copy) + (t - truebase);
d1477 1
a1477 1
	    RX_SUBBEG(rx) = savepvn(t, strend - t);
d1482 1
a1482 1
	RX_SUBLEN(rx) = strend - t;
d1484 2
a1485 2
	off = RX_OFFS(rx)[0].start = s - t;
	RX_OFFS(rx)[0].end = off + RX_MINLENRET(rx);
d1488 2
a1489 2
	RX_OFFS(rx)[0].start = s - truebase;
	RX_OFFS(rx)[0].end = s - truebase + RX_MINLENRET(rx);
d1491 1
a1491 1
    /* including RX_NPARENS(rx) in the below code seems highly suspicious.
d1493 1
a1493 1
    RX_NPARENS(rx) = RX_LASTPAREN(rx) = RX_LASTCLOSEPAREN(rx) = 0;	/* used by @@-, @@+, and $^N */
d1525 1
a1525 1
	MAGIC * const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d1528 1
a1528 1
	    XPUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
d1552 1
a1552 1
			sv_setpvs(GvSVn(PL_last_in_gv), "-");
d1750 1
a1750 1
    HV * const hv = MUTABLE_HV(POPs);
d1766 2
a1767 2
		|| mg_find((const SV *)hv, PERL_MAGIC_env)
		|| (     (mg = mg_find((const SV *)hv, PERL_MAGIC_tied))
d1771 1
a1771 1
		    && (stash = SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(hv), mg))))
d1798 1
a1798 1
		save_gp(MUTABLE_GV(*svp), !(PL_op->op_flags & OPf_SPECIAL));
a1901 2
	    /* If the maximum is !SvOK(), pp_enteriter substitutes PL_sv_no.
	       It has SvPVX of "" and SvCUR of 0, which is what we want.  */
d1903 3
a1905 1
	    const char *max = SvPV_const((SV*)av, maxlen);
a1945 9

	/* Handle end of range at IV_MAX */
	if ((cx->blk_loop.iterix == IV_MIN) &&
	    (cx->blk_loop.itermax == IV_MAX))
	{
	    cx->blk_loop.iterix++;
	    cx->blk_loop.itermax++;
	}

d2027 1
a2027 1
    U8 rxtainted;
a2035 1
    I32 matched;
d2068 1
a2068 1
	DIE(aTHX_ "%s", PL_no_modify);
d2074 1
a2074 1
    rxtainted = ((RX_EXTFLAGS(rx) & RXf_TAINTED) ||
d2092 1
a2092 1
    if (!RX_PRELEN(rx) && PL_curpm) {
d2096 2
a2097 2
    r_flags = (RX_NPARENS(rx) || SvTEMP(TARG) || PL_sawampersand
	    || (RX_EXTFLAGS(rx) & (RXf_EVAL_SEEN|RXf_PMf_KEEPCOPY)) )
d2103 1
a2103 1
    if (RX_EXTFLAGS(rx) & RXf_USE_INTUIT) {
d2110 1
a2110 1
/*	if ( (RX_EXTFLAGS(rx) & RXf_CHECK_ALL)
d2112 3
a2114 3
	     && !(RX_EXTFLAGS(rx) & RXf_KEEPCOPY)
	     && ((RX_EXTFLAGS(rx) & RXf_NOSCAN)
		 || !((RX_EXTFLAGS(rx) & RXf_INTUIT_TAIL)
d2122 1
a2122 2
    matched = CALLREGEXEC(rx, s, strend, orig, 0, TARG, NULL,
			 r_flags | REXEC_CHECKED);
d2151 2
a2152 2
	&& (I32)clen <= RX_MINLENRET(rx) && (once || !(r_flags & REXEC_COPY_STR))
	&& !(RX_EXTFLAGS(rx) & RXf_LOOKBEHIND_SEEN)
d2154 2
a2155 1
	if (!matched)
d2178 2
a2179 2
	    m = orig + RX_OFFS(rx)[0].start;
	    d = orig + RX_OFFS(rx)[0].end;
a2196 1
		Move(s, d - i, i, char);
d2198 3
d2221 1
a2221 1
		m = RX_OFFS(rx)[0].start + orig;
d2231 1
a2231 1
		s = RX_OFFS(rx)[0].end + orig;
d2243 1
a2243 1
	    mPUSHi((I32)iters);
d2259 2
a2260 1
    if (matched)
d2271 1
a2271 1
	dstr = newSVpvn_utf8(m, s-m, DO_UTF8(TARG));
d2273 2
d2287 1
a2287 1
	    if (RX_MATCH_COPIED(rx) && RX_SUBBEG(rx) != orig) {
d2290 1
a2290 1
		orig = RX_SUBBEG(rx);
d2294 1
a2294 1
	    m = RX_OFFS(rx)[0].start + orig;
d2299 1
a2299 1
	    s = RX_OFFS(rx)[0].end + orig;
d2332 1
a2332 1
	mPUSHi((I32)iters);
d2398 1
a2398 1
	    DEFSV_set(src);
d2485 1
a2485 1
    if (CxLVAL(cx) & OPpENTERSUB_INARGS) {
d2512 1
a2512 1
    else if (CxLVAL(cx)) {     /* Leave it as it is if we can. */
d2643 1
a2643 3
	if (!isGV_with_GP(sv))
	    DIE(aTHX_ "Not a CODE reference");
	if (!(cv = GvCVu((const GV *)sv))) {
d2689 1
a2689 1
	cv = MUTABLE_CV(SvRV(sv));
d2698 1
a2698 1
	cv = MUTABLE_CV(sv);
d2743 1
a2743 8
         if (CvLVALUE(cv)) {
             /* check for lsub that handles lvalue subroutines */
	     cv = GvCV(gv_HVadd(gv_fetchpv("DB::lsub", GV_ADDMULTI, SVt_PVHV)));
             /* if lsub not found then fall back to DB::sub */
	     if (!cv) cv = GvCV(PL_DBsub);
         } else {
             cv = GvCV(PL_DBsub);
         }
d2770 1
a2770 1
	    AV *const av = MUTABLE_AV(PAD_SVl(0));
d2779 1
a2779 1
	    GvAV(PL_defgv) = MUTABLE_AV(SvREFCNT_inc_simple(av));
d2810 1
a2810 1
	if (CvDEPTH(cv) == PERL_SUB_DEPTH_WARN && ckWARN(WARN_RECURSION)
a2864 2
    PERL_ARGS_ASSERT_SUB_CRUSH_DEPTH;

d2881 1
a2881 1
    AV *const av = MUTABLE_AV(POPs);
a2937 2
    PERL_ARGS_ASSERT_VIVIFY_REF;

d2941 8
a2948 2
	    Perl_croak(aTHX_ "%s", PL_no_modify);
	prepare_SV_for_RV(sv);
d2954 1
a2954 1
	    SvRV_set(sv, MUTABLE_SV(newAV()));
d2957 1
a2957 1
	    SvRV_set(sv, MUTABLE_SV(newHV()));
a3005 2
    PERL_ARGS_ASSERT_METHOD_COMMON;

d3011 1
a3011 1
	ob = MUTABLE_SV(SvRV(sv));
d3027 1
a3027 1
	    !(ob=MUTABLE_SV(GvIO(iogv))))
d3051 1
a3051 1
	*(PL_stack_base + TOPMARK + 1) = sv_2mortal(newRV(MUTABLE_SV(iogv)));
d3056 1
a3056 3
		 || (SvTYPE(ob) == SVt_PVGV 
		     && isGV_with_GP(ob)
		     && (ob = MUTABLE_SV(GvIO((const GV *)ob)))
d3074 1
a3074 1
	    gv = MUTABLE_GV(HeVAL(he));
d3078 1
a3078 1
		return MUTABLE_SV(GvCV(gv));
d3082 1
a3082 1
    gv = gv_fetchmethod(stash ? stash : MUTABLE_HV(packsv), name);
d3157 1
a3157 1
    return isGV(gv) ? MUTABLE_SV(GvCV(gv)) : MUTABLE_SV(gv);
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@d44 8
a51 1
    XPUSHs(cSVOP_sv);
d83 7
d155 1
a155 1
		SvUPGRADE(MUTABLE_SV(gv), SVt_IV);
d174 1
a174 1
		ENTER_with_name("sassign_coderef");
d184 1
a184 1
		LEAVE_with_name("sassign_coderef");
d736 1
a736 1
	ENTER_with_name("call_PRINT");
d743 1
a743 1
	LEAVE_with_name("call_PRINT");
a769 1
	SV * const ofs = GvSV(PL_ofsgv); /* $, */
d771 1
a771 1
	if (ofs && (SvGMAGICAL(ofs) || SvOK(ofs))) {
d777 1
a777 2
		    /* don't use 'ofs' here - it may be invalidated by magic callbacks */
		    if (!do_print(GvSV(PL_ofsgv), fp)) {
d1220 1
a1220 1
    SV * const pkg = rx ? CALLREG_PACKAGE(rx) : NULL;
d1222 2
a1223 17

    SvUPGRADE(rv, SVt_IV);
    /* For a subroutine describing itself as "This is a hacky workaround" I'm
       loathe to use it here, but it seems to be the right fix. Or close.
       The key part appears to be that it's essential for pp_qr to return a new
       object (SV), which implies that there needs to be an effective way to
       generate a new SV from the existing SV that is pre-compiled in the
       optree.  */
    SvRV_set(rv, MUTABLE_SV(reg_temp_copy(NULL, rx)));
    SvROK_on(rv);

    if (pkg) {
	HV* const stash = gv_stashpv(SvPV_nolen(pkg), GV_ADD);
	SvREFCNT_dec(pkg);
	(void)sv_bless(rv, stash);
    }

d1226 1
d1240 1
a1240 1
    U8 r_flags = REXEC_CHECKED;
d1262 1
a1262 5
    /* Skip get-magic if this is a qr// clone, because regcomp has
       already done it. */
    s = ((struct regexp *)SvANY(rx))->mother_re
	 ? SvPV_nomg_const(TARG, len)
	 : SvPV_const(TARG, len);
d1497 3
a1499 4
	    RX_SAVED_COPY(rx) = sv_setsv_cow(RX_SAVED_COPY(rx), TARG);
	    RX_SUBBEG(rx)
		= (char *) SvPVX_const(RX_SAVED_COPY(rx)) + (t - truebase);
	    assert (SvPOKp(RX_SAVED_COPY(rx)));
d1506 1
a1506 1
	    RX_SAVED_COPY(rx) = NULL;
d1557 1
a1557 1
	    ENTER_with_name("call_READLINE");
d1559 1
a1559 1
	    LEAVE_with_name("call_READLINE");
d1678 5
a1682 5
		if (!do_close(PL_last_in_gv, FALSE)) {
		    Perl_ck_warner(aTHX_ packWARN(WARN_GLOB),
				   "glob failed (child exited with status %d%s)",
				   (int)(STATUS_CURRENT >> 8),
				   (STATUS_CURRENT & 0x80) ? ", core dumped" : "");
d1757 3
a1759 7
	if (cxstack_ix >= 0) {
	    /* If this flag is set, we're just inside a return, so we should
	     * store the caller's context */
	    gimme = (PL_op->op_flags & OPf_SPECIAL)
		? block_gimme()
		: cxstack[cxstack_ix].blk_gimme;
	} else
d1763 1
a1763 1
    ENTER_with_name("block");
d1782 1
a1782 2
    const bool localizing = PL_op->op_private & OPpLVAL_INTRO;
    bool preeminent = TRUE;
d1787 1
a1787 1
    if (localizing) {
d1790 13
a1802 7

	/* If we can determine whether the element exist,
	 * Try to preserve the existenceness of a tied hash
	 * element by using EXISTS and DELETE if possible.
	 * Fallback to FETCH and STORE otherwise. */
	if (SvCANEXISTDELETE(hv) || mg_find((const SV *)hv, PERL_MAGIC_env))
	    preeminent = hv_exists_ent(hv, keysv, 0);
a1803 1

d1823 1
a1823 1
	if (localizing) {
d1826 9
a1834 5
	    else if (preeminent)
		save_helem_flags(hv, keysv, svp,
		     (PL_op->op_flags & OPf_SPECIAL) ? 0 : SAVEf_SETMAGIC);
	    else
		SAVEHDELETE(hv, keysv);
d1867 7
a1873 1
    gimme = OP_GIMME(PL_op, (cxstack_ix >= 0) ? gimme : G_SCALAR);
d1904 1
a1904 1
    LEAVE_with_name("block");
d1914 1
a1915 2
    AV *av = NULL; /* used for LOOP_FOR on arrays and the stack */
    bool av_is_stack = FALSE;
d1919 1
a1919 1
    if (!CxTYPE_is_LOOP(cx))
d1923 4
a1926 1
    if (CxTYPE(cx) == CXt_LOOP_LAZYSV) {
d1928 1
a1928 2
	    SV* cur = cx->blk_loop.state_u.lazysv.cur;
	    SV *end = cx->blk_loop.state_u.lazysv.end;
d1932 1
a1932 1
	    const char *max = SvPV_const(end, maxlen);
d1954 1
a1954 2
    }
    else if (CxTYPE(cx) == CXt_LOOP_LAZYIV) {
d1956 1
a1956 1
	if (cx->blk_loop.state_u.lazyiv.cur > cx->blk_loop.state_u.lazyiv.end)
d1962 1
a1962 1
	    sv_setiv(*itersvp, cx->blk_loop.state_u.lazyiv.cur++);
d1970 1
a1970 1
	    *itersvp = newSViv(cx->blk_loop.state_u.lazyiv.cur++);
d1975 2
a1976 2
	if ((cx->blk_loop.state_u.lazyiv.cur == IV_MIN) &&
	    (cx->blk_loop.state_u.lazyiv.end == IV_MAX))
d1978 2
a1979 2
	    cx->blk_loop.state_u.lazyiv.cur++;
	    cx->blk_loop.state_u.lazyiv.end++;
a1985 6
    assert(CxTYPE(cx) == CXt_LOOP_FOR);
    av = cx->blk_loop.state_u.ary.ary;
    if (!av) {
	av_is_stack = TRUE;
	av = PL_curstack;
    }
d1987 2
a1988 2
	if (cx->blk_loop.state_u.ary.ix <= (av_is_stack
				    ? cx->blk_loop.resetsp + 1 : 0))
d1992 1
a1992 1
	    SV * const * const svp = av_fetch(av, --cx->blk_loop.state_u.ary.ix, FALSE);
d1996 1
a1996 1
	    sv = AvARRAY(av)[--cx->blk_loop.state_u.ary.ix];
d2000 1
a2000 1
	if (cx->blk_loop.state_u.ary.ix >= (av_is_stack ? cx->blk_oldsp :
d2005 1
a2005 1
	    SV * const * const svp = av_fetch(av, ++cx->blk_loop.state_u.ary.ix, FALSE);
d2009 1
a2009 1
	    sv = AvARRAY(av)[++cx->blk_loop.state_u.ary.ix];
d2018 1
a2018 1
    if (sv) {
a2019 2
	SvREFCNT_inc_simple_void_NN(sv);
    }
d2022 13
a2034 4
    if (!av_is_stack && sv == &PL_sv_undef) {
	SV *lv = newSV_type(SVt_PVLV);
	LvTYPE(lv) = 'y';
	sv_magic(lv, NULL, PERL_MAGIC_defelem, NULL, 0);
d2036 1
a2036 1
	LvTARGOFF(lv) = cx->blk_loop.state_u.ary.ix;
d2038 1
a2038 1
	sv = lv;
d2042 1
a2042 1
    *itersvp = sv;
d2065 1
a2065 1
    U8 r_flags;
d2392 1
a2392 1
    LEAVE_with_name("grep_item");					/* exit inner scope */
d2399 1
a2399 1
	LEAVE_with_name("grep");					/* exit outer scope */
d2422 1
a2422 1
	ENTER_with_name("grep_item");					/* enter inner scope */
d2714 1
a2714 1
		DIE(aTHX_ "Can't use string (\"%.32s\"%s) as a subroutine ref while \"strict refs\" in use", sym, len>32 ? "..." : "");
d2779 1
a2779 1
	     cv = GvCV(gv_HVadd(gv_fetchpvs("DB::lsub", GV_ADDMULTI, SVt_PVHV)));
d2854 4
d2887 2
a2888 4

	/* CvXSUB(cv) must not be NULL because newXS() refuses NULL xsub address */
	assert(CvXSUB(cv));
	CALL_FPTR(CvXSUB(cv))(aTHX_ cv);
a2926 2
    const bool localizing = PL_op->op_private & OPpLVAL_INTRO;
    bool preeminent = TRUE;
a2936 13

    if (localizing) {
	MAGIC *mg;
	HV *stash;

	/* If we can determine whether the element exist,
	 * Try to preserve the existenceness of a tied array
	 * element by using EXISTS and DELETE if possible.
	 * Fallback to FETCH and STORE otherwise. */
	if (SvCANEXISTDELETE(av))
	    preeminent = av_exists(av, elem);
    }

d2966 2
a2967 6
	if (localizing) {
	    if (preeminent)
		save_aelem(av, elem, svp);
	    else
		SAVEADELETE(av, elem);
	}
d3038 1
d3042 1
d3048 1
a3048 2
	Perl_croak(aTHX_ "Can't call method \"%"SVf"\" on an undefined value",
		   SVfARG(meth));
d3077 1
a3077 2
		Perl_croak(aTHX_ "Can't call method \"%"SVf"\" %s",
			   SVfARG(meth),
a3101 1
	const char * const name = SvPV_nolen_const(meth);
d3125 44
a3168 3
    gv = gv_fetchmethod_flags(stash ? stash : MUTABLE_HV(packsv),
			      SvPV_nolen_const(meth),
			      GV_AUTOLOAD | GV_CROAK);
d3170 9
a3178 1
    assert(gv);
d3180 20
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a54 1
    PERL_ASYNC_CHECK();
a75 1
/* This is sometimes called directly by pp_coreargs. */
a100 1
    PERL_ASYNC_CHECK();
d123 1
a123 1
	const bool is_gv = isGV_with_GP(right);
d133 1
a133 1
	if (!got_coderef && !is_gv && GIMME_V == G_VOID) {
d135 1
a135 1
	    GV * const gv = gv_fetchsv_nomg(right, GV_NOINIT, SVt_PVGV);
d151 1
a151 1
	if (!is_gv) {
d153 1
a153 1
	    right = MUTABLE_SV(gv_fetchsv_nomg(right,GV_ADD, SVt_PVGV));
a197 7
    if (
      SvTEMP(right) && !SvSMAGICAL(right) && SvREFCNT(right) == 1 &&
      (!isGV_with_GP(right) || SvFAKE(right)) && ckWARN(WARN_MISC)
    )
	Perl_warner(aTHX_
	    packWARN(WARN_MISC), "Useless assignment to a temporary"
	);
a205 1
    PERL_ASYNC_CHECK();
d215 1
a215 1
    PERL_ASYNC_CHECK();
d219 2
a220 4
    if (!(PL_op->op_flags & OPf_SPECIAL)) {
	I32 oldsave = PL_scopestack[PL_scopestack_ix - 1];
	LEAVE_SCOPE(oldsave);
    }
d226 1
a226 1
  dVAR; dSP; dATARGET; tryAMAGICbin_MG(concat_amg, AMGf_assign);
d235 3
a237 2
    if (TARG == right && right != left) { /* $r = $l.$r */
	rpv = SvPV_nomg_const(right, rlen);
d244 1
a244 1
    if (TARG != left) { /* not $l .= $r */
d246 1
a246 1
        const char* const lpv = SvPV_nomg_const(left, llen);
d254 3
a256 1
    else { /* $l .= $r */
d258 1
a258 1
	    if (left == right && ckWARN(WARN_UNINITIALIZED)) /* $l .= $l */
d262 2
a263 2
	lbyte = (SvROK(left) && SvTYPE(SvRV(left)) == SVt_REGEXP)
		    ?  !DO_UTF8(SvRV(left)) : !DO_UTF8(left);
d268 1
d270 1
a270 4
	if (left == right)
	    /* $r.$r: do magic twice: tied might return different 2nd time */
	    SvGETMAGIC(right);
	rpv = SvPV_nomg_const(right, rlen);
a273 2
	/* sv_utf8_upgrade_nomg() may reallocate the stack */
	PUTBACK;
d280 1
a280 1
	    rpv = SvPV_nomg_const(right, rlen);
a281 1
	SPAGAIN;
d300 1
a300 1
	    TOPs = vivify_ref(TOPs, PL_op->op_private & OPpDEREF);
d310 2
a311 7
    dSP;
    if (TOPs) {
	SvGETMAGIC(TOPs);
	tryAMAGICunTARGET(iter_amg, 0, 0);
	PL_last_in_gv = MUTABLE_GV(*PL_stack_sp--);
    }
    else PL_last_in_gv = PL_argvgv, PL_stack_sp--;
d319 1
a319 1
	    Perl_pp_rv2gv(aTHX);
d328 69
a396 12
    dVAR; dSP;
    SV *left, *right;

    tryAMAGICbin_MG(eq_amg, AMGf_set|AMGf_numeric);
    right = POPs;
    left  = TOPs;
    SETs(boolSV(
	(SvIOK_notUV(left) && SvIOK_notUV(right))
	? (SvIVX(left) == SvIVX(right))
	: ( do_ncmp(left, right) == 0)
    ));
    RETURN;
d402 2
a403 4
    const bool inc =
	PL_op->op_type == OP_PREINC || PL_op->op_type == OP_I_PREINC;
    if (SvTYPE(TOPs) >= SVt_PVAV || (isGV_with_GP(TOPs) && !SvFAKE(TOPs)))
	Perl_croak_no_modify(aTHX);
d405 1
a405 1
        && SvIVX(TOPs) != (inc ? IV_MAX : IV_MIN))
d407 1
a407 1
	SvIV_set(TOPs, SvIVX(TOPs) + (inc ? 1 : -1));
d411 1
a411 2
	if (inc) sv_inc(TOPs);
	else sv_dec(TOPs);
a418 1
    PERL_ASYNC_CHECK();
a436 1
	PERL_ASYNC_CHECK();
d488 3
a490 4
    tryAMAGICbin_MG(add_amg, AMGf_assign|AMGf_numeric);
    svr = TOPs;
    svl = TOPm1s;

d539 1
a539 2
    SvIV_please_nomg(svr);

d556 1
a556 1
	    SvIV_please_nomg(svl);
d639 1
a639 1
	NV value = SvNV_nomg(svr);
d646 1
a646 1
	SETn( value + SvNV_nomg(svl) );
d654 2
a655 2
    AV * const av = PL_op->op_type == OP_AELEMFAST_LEX
	? MUTABLE_AV(PAD_SV(PL_op->op_targ)) : GvAVn(cGVOP_gv);
d660 2
a661 2
    if (!lval && SvRMAGICAL(av) && SvGMAGICAL(sv)) /* see note in pp_helem() */
	mg_get(sv);
d700 1
a704 1
    IO *io = GvIO(gv);
d706 1
a706 1
    if (io
d719 16
a734 5
	return Perl_tied_method(aTHX_ "PRINT", mark - 1, MUTABLE_SV(io),
				mg,
				(G_SCALAR | TIED_METHOD_ARGUMENTS_ON_STACK
				 | (PL_op->op_type == OP_SAY
				    ? TIED_METHOD_SAY : 0)), sp - mark);
d736 2
a737 2
    if (!io) {
        if ( gv && GvEGVx(gv) && (io = GvIO(GvEGV(gv)))
d740 2
a741 1
	report_evil_fh(gv);
d746 6
a751 4
	if (IoIFP(io))
	    report_wrongway_fh(gv, '<');
	else
	    report_evil_fh(gv);
a813 1
    SvGETMAGIC(sv);
d815 3
a817 3
	if (SvAMAGIC(sv)) {
	    sv = amagic_deref_call(sv, is_pp_rv2av ? to_av_amg : to_hv_amg);
	}
a819 1
	    /* diag_listed_as: Not an ARRAY reference */
d825 1
a825 3
	else if (PL_op->op_private & OPpMAYBE_LVSUB) {
	  const I32 flags = is_lvalue_sub();
	  if (flags && !(flags & OPpENTERSUB_INARGS)) {
a829 1
	  }
d852 5
d872 1
a872 3
	    else if (PL_op->op_private & OPpMAYBE_LVSUB) {
	      const I32 flags = is_lvalue_sub();
	      if (flags && !(flags & OPpENTERSUB_INARGS)) {
a876 1
	      }
d883 1
a883 1
	/* The guts of pp_rv2av, with no intending change to preserve history
d886 12
a897 13
	if (gimme == G_ARRAY) {
	    const I32 maxarg = AvFILL(av) + 1;
	    (void)POPs;			/* XXXX May be optimized away? */
	    EXTEND(SP, maxarg);
	    if (SvRMAGICAL(av)) {
		U32 i;
		for (i=0; i < (U32)maxarg; i++) {
		    SV ** const svp = av_fetch(av, i, FALSE);
		    /* See note in pp_helem, and bug id #27839 */
		    SP[i+1] = svp
			? SvGMAGICAL(*svp) ? (mg_get(*svp), *svp) : *svp
			: &PL_sv_undef;
		}
a898 4
	    else {
		Copy(AvARRAY(av), SP+1, maxarg, SV*);
	    }
	    SP += maxarg;
d900 2
a901 4
	else if (gimme == G_SCALAR) {
	    dTARGET;
	    const I32 maxarg = AvFILL(av) + 1;
	    SETi(maxarg);
d903 7
d912 10
a921 10
	if (gimme == G_ARRAY) { /* array wanted */
	    *PL_stack_sp = sv;
	    return Perl_do_kv(aTHX);
	}
	else if (gimme == G_SCALAR) {
	    dTARGET;
	    TARG = Perl_hv_scalar(aTHX_ MUTABLE_HV(sv));
	    SPAGAIN;
	    SETTARG;
	}
a994 1
     * Don't bother if LHS is just an empty hash or array.
d996 1
a996 11

    if (    (PL_op->op_private & OPpASSIGN_COMMON)
	&&  (
	       firstlelem != lastlelem
	    || ! ((sv = *firstlelem))
	    || SvMAGICAL(sv)
	    || ! (SvTYPE(sv) == SVt_PVAV || SvTYPE(sv) == SVt_PVHV)
	    || (SvTYPE(sv) == SVt_PVAV && AvFILL((AV*)sv) != -1)
	    || (SvTYPE(sv) == SVt_PVHV && HvUSEDKEYS((HV*)sv) != 0)
	    )
    ) {
d1001 1
a1001 11

		/* Dear TODO test in t/op/sort.t, I love you.
		   (It's relying on a panic, not a "semi-panic" from newSVsv()
		   and then an assertion failure below.)  */
		if (SvIS_FREED(sv)) {
		    Perl_croak(aTHX_ "panic: attempt to copy freed scalar %p",
			       (void*)sv);
		}
		/* Specifically *not* sv_mortalcopy(), as that will steal TEMPs,
		   and we need a second copy of a temp here.  */
		*relem = sv_2mortal(newSVsv(sv));
a1017 2
	    ENTER;
	    SAVEFREESV(SvREFCNT_inc_simple_NN(sv));
d1024 1
a1024 2
		sv = newSV(0);
		sv_setsv(sv, *relem);
d1028 5
a1032 1
		    if (SvSMAGICAL(sv))
d1034 2
d1041 1
a1041 1
	    if (PL_delaymagic & DM_ARRAY_ISA)
a1042 1
	    LEAVE;
a1045 1
		SV** topelem = relem;
a1048 2
		ENTER;
		SAVEFREESV(SvREFCNT_inc_simple_NN(sv));
d1059 4
a1062 13
		    relem++;
		    if (gimme != G_VOID) {
			if (hv_exists_ent(hash, sv, 0))
			    /* key overwrites an existing entry */
			    duplicates += 2;
			else
			if (gimme == G_ARRAY) {
			    /* copy element back: possibly to an earlier
			     * stack location if we encountered dups earlier */
			    *topelem++ = sv;
			    *topelem++ = tmpstr;
			}
		    }
d1065 3
a1067 1
			if (SvSMAGICAL(tmpstr))
d1069 2
a1079 1
		LEAVE;
a1088 8
		if (
		  SvTEMP(sv) && !SvSMAGICAL(sv) && SvREFCNT(sv) == 1 &&
		  (!isGV_with_GP(sv) || SvFAKE(sv)) && ckWARN(WARN_MISC)
		)
		    Perl_warner(aTHX_
		       packWARN(WARN_MISC),
		      "Useless assignment to a temporary"
		    );
d1094 7
a1100 1
	    SvSETMAGIC(sv);
a1104 6
	/* Will be used to set PL_tainting below */
	UV tmp_uid  = PerlProc_getuid();
	UV tmp_euid = PerlProc_geteuid();
	UV tmp_gid  = PerlProc_getgid();
	UV tmp_egid = PerlProc_getegid();

d1107 2
a1108 2
	    (void)setresuid((PL_delaymagic & DM_RUID) ? PL_delaymagic_uid  : (Uid_t)-1,
			    (PL_delaymagic & DM_EUID) ? PL_delaymagic_euid : (Uid_t)-1,
d1112 2
a1113 2
	    (void)setreuid((PL_delaymagic & DM_RUID) ? PL_delaymagic_uid  : (Uid_t)-1,
			   (PL_delaymagic & DM_EUID) ? PL_delaymagic_euid : (Uid_t)-1);
d1117 1
a1117 1
		(void)setruid(PL_delaymagic_uid);
d1123 1
a1123 1
		(void)seteuid(PL_delaymagic_euid);
d1128 1
a1128 1
		if (PL_delaymagic_uid != PL_delaymagic_euid)
d1130 1
a1130 1
		(void)PerlProc_setuid(PL_delaymagic_uid);
d1134 2
a1135 2
	    tmp_uid  = PerlProc_getuid();
	    tmp_euid = PerlProc_geteuid();
d1139 2
a1140 2
	    (void)setresgid((PL_delaymagic & DM_RGID) ? PL_delaymagic_gid  : (Gid_t)-1,
			    (PL_delaymagic & DM_EGID) ? PL_delaymagic_egid : (Gid_t)-1,
d1144 2
a1145 2
	    (void)setregid((PL_delaymagic & DM_RGID) ? PL_delaymagic_gid  : (Gid_t)-1,
			   (PL_delaymagic & DM_EGID) ? PL_delaymagic_egid : (Gid_t)-1);
d1149 1
a1149 1
		(void)setrgid(PL_delaymagic_gid);
d1155 1
a1155 1
		(void)setegid(PL_delaymagic_egid);
d1160 1
a1160 1
		if (PL_delaymagic_gid != PL_delaymagic_egid)
d1162 1
a1162 1
		(void)PerlProc_setgid(PL_delaymagic_gid);
d1166 2
a1167 2
	    tmp_gid  = PerlProc_getgid();
	    tmp_egid = PerlProc_getegid();
d1169 1
a1169 1
	PL_tainting |= (tmp_uid && (tmp_euid != tmp_uid || tmp_egid != tmp_gid));
d1185 4
a1188 6
		/* at this point we have removed the duplicate key/value
		 * pairs from the stack, but the remaining values may be
		 * wrong; i.e. with (a 1 a 2 b 3) on the stack we've removed
		 * the (a 2), but the stack now probably contains
		 * (a <freed> b 3), because { hv_save(a,1); hv_save(a,2) }
		 * obliterates the earlier key. So refresh all values. */
a1189 7
		relem = firsthashrelem;
		while (relem < lastrelem) {
		    HE *he;
		    sv = *relem++;
		    he = hv_fetch_ent(hash, sv, 0, 0);
		    *relem++ = (he ? HeVAL(he) : &PL_sv_undef);
		}
d1222 1
a1222 1
	HV *const stash = gv_stashsv(pkg, GV_ADD);
d1227 1
a1227 1
    if (RX_EXTFLAGS(rx) & RXf_TAINTED) {
a1228 2
        SvTAINTED_on(SvRV(rv));
    }
d1330 3
a1332 3
    if (       (!global && RX_NPARENS(rx))
	    || SvTEMP(TARG) || SvAMAGIC(TARG) || PL_sawampersand
	    || (RX_EXTFLAGS(rx) & (RXf_EVAL_SEEN|RXf_PMf_KEEPCOPY)))
d1337 1
a1337 1
  play_it_again:
d1362 5
a1366 6
    if (!CALLREGEXEC(rx, (char*)s, (char *)strend, (char*)truebase,
		     minmatch, TARG, NUM2PTR(void*, gpos), r_flags))
	goto ret_no;

    PL_curpm = pm;
    if (dynpm->op_pmflags & PMf_ONCE) {
d1368 1
a1368 1
	SvREADONLY_on(PL_regex_pad[dynpm->op_pmoffset]);
d1370 1
a1370 1
	dynpm->op_pmflags |= PMf_USED;
d1372 2
d1375 3
d1397 1
a1397 4
		    DIE(aTHX_ "panic: pp_match start/end pointers, i=%ld, "
			"start=%ld, end=%ld, s=%p, strend=%p, len=%"UVuf,
			(long) i, (long) RX_OFFS(rx)[i].start,
			(long)RX_OFFS(rx)[i].end, s, strend, (UV) len);
d1559 1
a1559 1
	const MAGIC *const mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar);
d1561 7
a1567 1
	    Perl_tied_method(aTHX_ "READLINE", SP, MUTABLE_SV(io), mg, gimme, 0);
d1569 3
a1571 3
		SPAGAIN;
		SvSetSV_nosteal(TARG, TOPs);
		SETTARG;
d1573 1
a1573 1
	    return NORMAL;
d1602 2
a1603 2
	else if (IoTYPE(io) == IoTYPE_WRONLY) {
	    report_wrongway_fh(PL_last_in_gv, '>');
d1611 1
a1611 1
		Perl_ck_warner_d(aTHX_ packWARN(WARN_GLOB),
d1615 1
a1615 1
		report_evil_fh(PL_last_in_gv);
d1634 1
a1634 1
		SvPV_force_nomg_nolen(sv);
d1639 1
a1639 1
	    SvPV_force_nomg_nolen(sv);
d1643 2
a1644 6
	if (!tmplen && !SvREADONLY(sv)) {
            /* try short-buffering it. Please update t/op/readline.t
	     * if you change the growth length.
	     */
	    Sv_Grow(sv, 80);
        }
d1648 1
a1648 1
		SvPV_force_nomg_nolen(sv);
d1757 25
d1814 1
a1814 1
	if (!svp || !*svp || *svp == &PL_sv_undef) {
d1839 58
a1896 3
	else if (PL_op->op_private & OPpDEREF) {
	    PUSHs(vivify_ref(*svp, PL_op->op_private & OPpDEREF));
	    RETURN;
d1899 4
a1902 16
    sv = (svp && *svp ? *svp : &PL_sv_undef);
    /* Originally this did a conditional C<sv = sv_mortalcopy(sv)>; this
     * was to make C<local $tied{foo} = $tied{foo}> possible.
     * However, it seems no longer to be needed for that purpose, and
     * introduced a new bug: stuff like C<while ($hash{taintedval} =~ /.../g>
     * would loop endlessly since the pos magic is getting set on the
     * mortal copy and lost. However, the copy has the effect of
     * triggering the get magic, and losing it altogether made things like
     * c<$tied{foo};> in void context no longer do get magic, which some
     * code relied on. Also, delayed triggering of magic on @@+ and friends
     * meant the original regex may be out of scope by now. So as a
     * compromise, do the get magic here. (The MGf_GSKIP flag will stop it
     * being called too many times). */
    if (!lval && SvRMAGICAL(hv) && SvGMAGICAL(sv))
	mg_get(sv);
    PUSHs(sv);
d1918 1
a1918 1
	DIE(aTHX_ "panic: pp_iter, type=%u", CxTYPE(cx));
a2043 67
/*
A description of how taint works in pattern matching and substitution.

While the pattern is being assembled/concatenated and then compiled,
PL_tainted will get set if any component of the pattern is tainted, e.g.
/.*$tainted/.  At the end of pattern compilation, the RXf_TAINTED flag
is set on the pattern if PL_tainted is set.

When the pattern is copied, e.g. $r = qr/..../, the SV holding the ref to
the pattern is marked as tainted. This means that subsequent usage, such
as /x$r/, will set PL_tainted, and thus RXf_TAINTED, on the new pattern too.

During execution of a pattern, locale-variant ops such as ALNUML set the
local flag RF_tainted. At the end of execution, the engine sets the
RXf_TAINTED_SEEN on the pattern if RF_tainted got set, or clears it
otherwise.

In addition, RXf_TAINTED_SEEN is used post-execution by the get magic code
of $1 et al to indicate whether the returned value should be tainted.
It is the responsibility of the caller of the pattern (i.e. pp_match,
pp_subst etc) to set this flag for any other circumstances where $1 needs
to be tainted.

The taint behaviour of pp_subst (and pp_substcont) is quite complex.

There are three possible sources of taint
    * the source string
    * the pattern (both compile- and run-time, RXf_TAINTED / RXf_TAINTED_SEEN)
    * the replacement string (or expression under /e)
    
There are four destinations of taint and they are affected by the sources
according to the rules below:

    * the return value (not including /r):
	tainted by the source string and pattern, but only for the
	number-of-iterations case; boolean returns aren't tainted;
    * the modified string (or modified copy under /r):
	tainted by the source string, pattern, and replacement strings;
    * $1 et al:
	tainted by the pattern, and under 'use re "taint"', by the source
	string too;
    * PL_taint - i.e. whether subsequent code (e.g. in a /e block) is tainted:
	should always be unset before executing subsequent code.

The overall action of pp_subst is:

    * at the start, set bits in rxtainted indicating the taint status of
	the various sources.

    * After each pattern execution, update the SUBST_TAINT_PAT bit in
	rxtainted if RXf_TAINTED_SEEN has been set, to indicate that the
	pattern has subsequently become tainted via locale ops.

    * If control is being passed to pp_substcont to execute a /e block,
	save rxtainted in the CXt_SUBST block, for future use by
	pp_substcont.

    * Whenever control is being returned to perl code (either by falling
	off the "end" of pp_subst/pp_substcont, or by entering a /e block),
	use the flag bits in rxtainted to make all the appropriate types of
	destination taint visible; e.g. set RXf_TAINTED_SEEN so that $1
	et al will appear tainted.

pp_match is just a simpler version of the above.

*/

d2059 1
a2059 2
    U8 rxtainted = 0; /* holds various SUBST_TAINT_* flag bits.
			See "how taint works" above */
d2068 1
d2073 1
a2075 3

    PERL_ASYNC_CHECK();

d2093 1
a2093 1
    if (!(rpm->op_pmflags & PMf_NONDESTRUCT)
d2095 1
a2095 1
	&& !is_cow
d2097 5
a2101 5
	&& (SvREADONLY(TARG)
	    || ( ((SvTYPE(TARG) == SVt_PVGV && isGV_with_GP(TARG))
		  || SvTYPE(TARG) > SVt_PVLV)
		 && !(SvTYPE(TARG) == SVt_PVGV && SvFAKE(TARG)))))
	Perl_croak_no_modify(aTHX);
a2103 1
  setup_match:
d2107 5
a2111 14

    /* only replace once? */
    once = !(rpm->op_pmflags & PMf_GLOBAL);

    /* See "how taint works" above */
    if (PL_tainting) {
	rxtainted  = (
	    (SvTAINTED(TARG) ? SUBST_TAINT_STR : 0)
	  | ((RX_EXTFLAGS(rx) & RXf_TAINTED) ? SUBST_TAINT_PAT : 0)
	  | ((pm->op_pmflags & PMf_RETAINT) ? SUBST_TAINT_RETAINT : 0)
	  | ((once && !(rpm->op_pmflags & PMf_NONDESTRUCT))
		? SUBST_TAINT_BOOLRET : 0));
	TAINT_NOT;
    }
d2117 1
a2117 1
	DIE(aTHX_ "panic: pp_subst, pm=%p, s=%p", pm, s);
d2141 1
a2141 1
	    goto ret_no;
d2153 4
a2156 10
    if (!CALLREGEXEC(rx, s, strend, orig, 0, TARG, NULL,
			 r_flags | REXEC_CHECKED))
    {
      ret_no:
	SPAGAIN;
	PUSHs(rpm->op_pmflags & PMf_NONDESTRUCT ? TARG : &PL_sv_no);
	LEAVE_SCOPE(oldsave);
	RETURN;
    }

a2158 19
	if (SvTAINTED(dstr))
	    rxtainted |= SUBST_TAINT_REPL;

	/* Upgrade the source if the replacement is utf8 but the source is not,
	 * but only if it matched; see
	 * http://www.nntp.perl.org/group/perl.perl5.porters/2010/04/msg158809.html
	 */
	if (DO_UTF8(dstr) && ! DO_UTF8(TARG)) {
	    char * const orig_pvx =  SvPVX(TARG);
	    const STRLEN new_len = sv_utf8_upgrade_nomg(TARG);

	    /* If the lengths are the same, the pattern contains only
	     * invariants, can keep going; otherwise, various internal markers
	     * could be off, so redo */
	    if (new_len != len || orig_pvx != SvPVX(TARG)) {
		goto setup_match;
	    }
	}

d2187 8
a2194 4
	&& (!doutf8 || SvUTF8(TARG))
	&& !(rpm->op_pmflags & PMf_NONDESTRUCT))
    {

d2210 1
a2210 2
	    if (RX_MATCH_TAINTED(rx)) /* run time pattern taint, eg locale */
		rxtainted |= SUBST_TAINT_PAT;
d2243 1
d2251 1
a2251 2
		if (RX_MATCH_TAINTED(rx)) /* run time pattern taint, eg locale */
		    rxtainted |= SUBST_TAINT_PAT;
d2272 1
d2276 12
d2289 3
a2291 1
    else {
a2293 8
	    if (rpm->op_pmflags & PMf_NONDESTRUCT) {
		/* I feel that it should be possible to avoid this mortal copy
		   given that the code below copies into a new destination.
		   However, I suspect it isn't worth the complexity of
		   unravelling the C<goto force_it> for the small number of
		   cases where it would be viable to drop into the copy code. */
		TARG = sv_2mortal(newSVsv(TARG));
	    }
d2300 3
a2302 3
	if (RX_MATCH_TAINTED(rx)) /* run time pattern taint, eg locale */
	    rxtainted |= SUBST_TAINT_PAT;
	dstr = newSVpvn_flags(m, s-m, SVs_TEMP | (DO_UTF8(TARG) ? SVf_UTF8 : 0));
a2306 5
	    /* note that a whole bunch of local vars are saved here for
	     * use by pp_substcont: here's a list of them in case you're
	     * searching for places in this sub that uses a particular var:
	     * iters maxiters r_flags oldsave rxtainted orig dstr targ
	     * s m strend rx once */
d2314 1
a2314 2
	    if (RX_MATCH_TAINTED(rx))
		rxtainted |= SUBST_TAINT_PAT;
a2338 7
	if (rpm->op_pmflags & PMf_NONDESTRUCT) {
	    /* From here on down we're using the copy, and leaving the original
	       untouched.  */
	    TARG = dstr;
	    SPAGAIN;
	    PUSHs(dstr);
	} else {
d2340 8
a2347 8
	    /* The match may make the string COW. If so, brilliant, because
	       that's just saved us one malloc, copy and free - the regexp has
	       donated the old buffer, and we malloc an entirely new one, rather
	       than the regexp malloc()ing a buffer and copying our original,
	       only for us to throw it away here during the substitution.  */
	    if (SvIsCOW(TARG)) {
		sv_force_normal_flags(TARG, SV_COW_DROP_PV);
	    } else
d2349 8
a2356 8
	    {
		SvPV_free(TARG);
	    }
	    SvPV_set(TARG, SvPVX(dstr));
	    SvCUR_set(TARG, SvCUR(dstr));
	    SvLEN_set(TARG, SvLEN(dstr));
	    doutf8 |= DO_UTF8(dstr);
	    SvPV_set(dstr, NULL);
d2358 3
a2360 4
	    SPAGAIN;
	    mPUSHi((I32)iters);
	}
    }
d2362 1
a2362 2
    if (!(rpm->op_pmflags & PMf_NONDESTRUCT)) {
	(void)SvPOK_only_UTF8(TARG);
d2365 5
d2371 1
d2373 4
a2376 22
    /* See "how taint works" above */
    if (PL_tainting) {
	if ((rxtainted & SUBST_TAINT_PAT) ||
	    ((rxtainted & (SUBST_TAINT_STR|SUBST_TAINT_RETAINT)) ==
				(SUBST_TAINT_STR|SUBST_TAINT_RETAINT))
	)
	    (RX_MATCH_TAINTED_on(rx)); /* taint $1 et al */

	if (!(rxtainted & SUBST_TAINT_BOOLRET)
	    && (rxtainted & (SUBST_TAINT_STR|SUBST_TAINT_PAT))
	)
	    SvTAINTED_on(TOPs);  /* taint return value */
	else
	    SvTAINTED_off(TOPs);  /* may have got tainted earlier */

	/* needed for mg_set below */
	PL_tainted =
	  cBOOL(rxtainted & (SUBST_TAINT_STR|SUBST_TAINT_PAT|SUBST_TAINT_REPL));
	SvTAINT(TARG);
    }
    SvSETMAGIC(TARG); /* PL_tainted must be correctly set for this mg_set */
    TAINT_NOT;
a2387 1
    FREETMPS;
d2453 1
a2453 2
		if (SvTEMP(TOPs) && SvREFCNT(TOPs) == 1
		     && !SvMAGICAL(TOPs)) {
a2464 4
	    else if (SvTEMP(TOPs) && SvREFCNT(TOPs) == 1
		     && !SvMAGICAL(TOPs)) {
		*MARK = TOPs;
	    }
d2466 1
a2466 1
		*MARK = sv_mortalcopy(TOPs);
d2476 1
a2476 2
	    if (!SvTEMP(*MARK) || SvREFCNT(*MARK) != 1
		 || SvMAGICAL(*MARK)) {
d2493 164
d2671 2
a2672 1
      we_have_a_glob:
a2682 3
    case SVt_PVLV:
	if(isGV_with_GP(sv)) goto we_have_a_glob;
	/*FALLTHROUGH*/
d2684 1
a2684 15
	if (sv == &PL_sv_yes) {		/* unfound import, ignore */
	    if (hasargs)
		SP = PL_stack_base + POPMARK;
	    else
		(void)POPMARK;
	    RETURN;
	}
	SvGETMAGIC(sv);
	if (SvROK(sv)) {
	    if (SvAMAGIC(sv)) {
		sv = amagic_deref_call(sv, to_cv_amg);
		/* Don't SPAGAIN here.  */
	    }
	}
	else {
d2687 20
a2706 1
	    sym = SvPV_nomg_const(sv, len);
d2710 1
a2710 1
		DIE(aTHX_ "Can't use string (\"%" SVf32 "\"%s) as a subroutine ref while \"strict refs\" in use", sv, len>32 ? "..." : "");
d2714 5
a2735 2
    if (CvCLONE(cv) && ! CvCLONED(cv))
	DIE(aTHX_ "Closure prototype called");
d2751 2
a2752 2
	    if ((autogv = gv_autoload_pvn(GvSTASH(gv), GvNAME(gv), GvNAMELEN(gv),
				   GvNAMEUTF8(gv) ? SVf_UTF8 : 0)))
a2842 3
	if ((cx->blk_u16 & OPpENTERSUB_LVAL_MASK) == OPpLVAL_INTRO &&
	    !CvLVALUE(cv))
	    DIE(aTHX_ "Can't modify non-lvalue subroutine call");
d2882 1
a2882 1
	CvXSUB(cv)(aTHX_ cv);
d2929 2
d2981 2
a2982 4
	else if (PL_op->op_private & OPpDEREF) {
	    PUSHs(vivify_ref(*svp, PL_op->op_private & OPpDEREF));
	    RETURN;
	}
d2985 2
a2986 2
    if (!lval && SvRMAGICAL(av) && SvGMAGICAL(sv)) /* see note in pp_helem() */
	mg_get(sv);
d2991 1
a2991 1
SV*
d2999 1
a2999 1
	    Perl_croak_no_modify(aTHX);
a3013 8
	SvGETMAGIC(sv);
    }
    if (SvGMAGICAL(sv)) {
	/* copy the sv without magic to prevent magic from being
	   executed twice */
	SV* msv = sv_newmortal();
	sv_setsv_nomg(msv, sv);
	return msv;
a3014 1
    return sv;
d3051 1
d3053 1
a3066 3
        STRLEN packlen;
        const char * packname = NULL;
	bool packname_is_utf8 = FALSE;
d3069 2
a3070 7
        if(SvOK(sv) && (packname = SvPV_nomg_const(sv, packlen))) {
          const HE* const he =
	    (const HE *)hv_common_key_len(
	      PL_stashcache, packname,
	      packlen * -(packname_is_utf8 = !!SvUTF8(sv)), 0, NULL, 0
	    );
	  
d3079 1
a3079 3
	    !(iogv = gv_fetchpvn_flags(
	        packname, packlen, SVf_UTF8 * packname_is_utf8, SVt_PVIO
	     )) ||
d3086 1
a3086 1
		    : !isIDFIRST_L1((U8)*packname)
a3088 1
		/* diag_listed_as: Can't call method "%s" without a package or object reference */
d3095 1
a3095 1
	    stash = gv_stashpvn(packname, packlen, packname_is_utf8 ? SVf_UTF8 : 0);
d3100 1
a3100 2
	        (void)hv_store(PL_stashcache, packname,
                                packname_is_utf8 ? -(I32)packlen : (I32)packlen, ref, 0);
d3115 4
a3118 4
	Perl_croak(aTHX_ "Can't call method \"%"SVf"\" on unblessed reference",
		   SVfARG((SvSCREAM(meth) && strEQ(SvPV_nolen_const(meth),"isa"))
                                        ? newSVpvs_flags("DOES", SVs_TEMP)
                                        : meth));
d3139 3
a3141 2
    gv = gv_fetchmethod_sv_flags(stash ? stash : MUTABLE_HV(packsv),
			             meth, GV_AUTOLOAD | GV_CROAK);
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d77 1
a77 1
/* This is sometimes called directly by pp_coreargs and pp_grepstart. */
d88 3
a90 6
    SV * const sv = TOPs;
    SETs(TARG);
    sv_copypv(TARG, sv);
    SvSETMAGIC(TARG);
    /* no PUTBACK, SETs doesn't inc/dec SP */
    return NORMAL;
d102 1
a102 1
    dVAR;
d104 6
a109 14
    {
	/* SP is not used to remove a variable that is saved across the
	  sv_2bool_flags call in SvTRUE_NN, if a RISC/CISC or low/high machine
	  register or load/store vs direct mem ops macro is introduced, this
	  should be a define block between direct PL_stack_sp and dSP operations,
	  presently, using PL_stack_sp is bias towards CISC cpus */
	SV * const sv = *PL_stack_sp;
	if (!SvTRUE_NN(sv))
	    return NORMAL;
	else {
	    if (PL_op->op_type == OP_AND)
		--PL_stack_sp;
	    return cLOGOP->op_other;
	}
d115 1
a115 5
    dVAR; dSP;
    /* sassign keeps its args in the optree traditionally backwards.
       So we pop them differently.
    */
    SV *left = POPs; SV *right = TOPs;
d121 1
a121 1
    if (TAINTING_get && TAINT_get && !SvTAINTED(right))
d124 1
a124 1
	SV * const cv = SvRV(right);
d126 1
a126 1
	const bool is_gv = isGV_with_GP(left);
d133 2
a134 2
	/* Can do the optimisation if left (LVALUE) is not a typeglob,
	   right (RVALUE) is a reference to something, and we're in void
d138 1
a138 1
	    GV * const gv = gv_fetchsv_nomg(left, GV_NOINIT, SVt_PVGV);
d148 1
a148 1
		SETs(left);
d156 1
a156 1
	    left = MUTABLE_SV(gv_fetchsv_nomg(left,GV_ADD, SVt_PVGV));
d170 1
a170 1
		SvRV_set(right, MUTABLE_SV(newCONSTSUB(GvSTASH(left), NULL,
d172 1
a172 1
		SvREFCNT_dec_NN(cv);
d195 2
a196 2
		SvREFCNT_dec_NN(upgraded);
		SvRV_set(right, MUTABLE_SV(source));
d202 2
a203 2
      SvTEMP(left) && !SvSMAGICAL(left) && SvREFCNT(left) == 1 &&
      (!isGV_with_GP(left) || SvFAKE(left)) && ckWARN(WARN_MISC)
d208 2
a209 2
    SvSetMagicSV(left, right);
    SETs(left);
d272 2
a273 2
	SvPV_force_nomg_nolen(left);
	lbyte = !DO_UTF8(left);
a304 72
/* push the elements of av onto the stack.
 * XXX Note that padav has similar code but without the mg_get().
 * I suspect that the mg_get is no longer needed, but while padav
 * differs, it can't share this function */

STATIC void
S_pushav(pTHX_ AV* const av)
{
    dSP;
    const I32 maxarg = AvFILL(av) + 1;
    EXTEND(SP, maxarg);
    if (SvRMAGICAL(av)) {
        U32 i;
        for (i=0; i < (U32)maxarg; i++) {
            SV ** const svp = av_fetch(av, i, FALSE);
            /* See note in pp_helem, and bug id #27839 */
            SP[i+1] = svp
                ? SvGMAGICAL(*svp) ? (mg_get(*svp), *svp) : *svp
                : &PL_sv_undef;
        }
    }
    else {
        Copy(AvARRAY(av), SP+1, maxarg, SV*);
    }
    SP += maxarg;
    PUTBACK;
}


/* ($lex1,@@lex2,...)   or my ($lex1,@@lex2,...)  */

PP(pp_padrange)
{
    dVAR; dSP;
    PADOFFSET base = PL_op->op_targ;
    int count = (int)(PL_op->op_private) & OPpPADRANGE_COUNTMASK;
    int i;
    if (PL_op->op_flags & OPf_SPECIAL) {
        /* fake the RHS of my ($x,$y,..) = @@_ */
        PUSHMARK(SP);
        S_pushav(aTHX_ GvAVn(PL_defgv));
        SPAGAIN;
    }

    /* note, this is only skipped for compile-time-known void cxt */
    if ((PL_op->op_flags & OPf_WANT) != OPf_WANT_VOID) {
        EXTEND(SP, count);
        PUSHMARK(SP);
        for (i = 0; i <count; i++)
            *++SP = PAD_SV(base+i);
    }
    if (PL_op->op_private & OPpLVAL_INTRO) {
        SV **svp = &(PAD_SVl(base));
        const UV payload = (UV)(
                      (base << (OPpPADRANGE_COUNTSHIFT + SAVE_TIGHT_SHIFT))
                    | (count << SAVE_TIGHT_SHIFT)
                    | SAVEt_CLEARPADRANGE);
        assert(OPpPADRANGE_COUNTMASK + 1 == (1 <<OPpPADRANGE_COUNTSHIFT));
        assert((payload >> (OPpPADRANGE_COUNTSHIFT+SAVE_TIGHT_SHIFT)) == base);
        {
            dSS_ADD;
            SS_ADD_UV(payload);
            SS_ADD_END(1);
        }

        for (i = 0; i <count; i++)
            SvPADSTALE_off(*svp++); /* mark lexical as active */
    }
    RETURN;
}


d307 10
a316 23
    dVAR; dSP;
    EXTEND(SP, 1);
    {
	OP * const op = PL_op;
	/* access PL_curpad once */
	SV ** const padentry = &(PAD_SVl(op->op_targ));
	{
	    dTARG;
	    TARG = *padentry;
	    PUSHs(TARG);
	    PUTBACK; /* no pop/push after this, TOPs ok */
	}
	if (op->op_flags & OPf_MOD) {
	    if (op->op_private & OPpLVAL_INTRO)
		if (!(op->op_private & OPpPAD_STATE))
		    save_clearsv(padentry);
	    if (op->op_private & OPpDEREF) {
		/* TOPs is equivalent to TARG here.  Using TOPs (SP) rather
		   than TARG reduces the scope of TARG, so it does not
		   span the call to save_clearsv, resulting in smaller
		   machine code. */
		TOPs = vivify_ref(TOPs, op->op_private & OPpDEREF);
	    }
a317 1
	return op->op_next;
d319 1
d328 1
a328 1
	tryAMAGICunTARGETlist(iter_amg, 0);
d368 2
a369 2
	Perl_croak_no_modify();
    if (!SvREADONLY(TOPs) && !SvGMAGICAL(TOPs) && SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)
d398 1
a398 1
    SV* sv;
d508 3
a510 1
    if (SvIV_please_nomg(svr)) {
d514 1
a514 1
	UV auv = 0;
d526 2
a527 1
	    if (SvIV_please_nomg(svl)) {
d531 1
a531 1
		    const IV aiv = SvIVX(svl);
d545 1
a545 1
	    UV buv;
d551 1
a551 1
		const IV biv = SvIVX(svr);
d670 1
a670 1
    PerlIO *fp;
d779 13
d796 14
a809 1
    else if (SvTYPE(sv) != type) {
d824 1
a824 2
    }
    if (PL_op->op_flags & OPf_REF) {
d827 2
a828 2
    }
    else if (PL_op->op_private & OPpMAYBE_LVSUB) {
d836 2
d846 17
a862 4
            SP--;
            PUTBACK;
            S_pushav(aTHX_ av);
            SPAGAIN;
a874 5
	else if ((PL_op->op_private & OPpTRUEBOOL
	      || (  PL_op->op_private & OPpMAYBE_TRUEBOOL
		 && block_gimme() == G_VOID  ))
	      && (!SvRMAGICAL(sv) || !mg_find(sv, PERL_MAGIC_tied)))
	    SETs(HvUSEDKEYS(sv) ? &PL_sv_yes : sv_2mortal(newSViv(0)));
d891 1
a891 1
S_do_oddball(pTHX_ SV **oddkey, SV **firstkey)
d897 4
a900 1
    if (*oddkey) {
d903 4
a906 4
	    if (oddkey == firstkey &&
		SvROK(*oddkey) &&
		(SvTYPE(SvRV(*oddkey)) == SVt_PVAV ||
		 SvTYPE(SvRV(*oddkey)) == SVt_PVHV))
d915 9
d935 2
a936 2
    SV **relem;
    SV **lelem;
d938 2
a939 2
    SV *sv;
    AV *ary;
d945 2
a946 1
    U32 lval = 0;
a949 2
    if (gimme == G_ARRAY)
        lval = PL_op->op_flags & OPf_MOD || LVRET;
d979 3
a981 5
		/* Not newSVsv(), as it does not allow copy-on-write,
		   resulting in wasteful copies.  We need a second copy of
		   a temp here, hence the SV_NOSTEAL.  */
		*relem = sv_mortalcopy_flags(sv,SV_GMAGIC|SV_DO_COW_SVSETSV
					       |SV_NOSTEAL);
a1005 1
		SvGETMAGIC(*relem); /* before newSV, in case it dies */
d1007 1
a1007 1
		sv_setsv_nomg(sv, *relem);
d1011 2
a1014 2
		    if (SvSMAGICAL(sv))
			mg_set(sv);
a1023 2
                int odd;
                int duplicates = 0;
a1024 1
                SV **firsthashrelem = relem;
a1027 9

                odd = ((lastrelem - firsthashrelem)&1)? 0 : 1;
                if ( odd ) {
                    do_oddball(lastrelem, firsthashrelem);
                    /* we have firstlelem to reuse, it's not needed anymore
		     */
                    *(lastrelem+1) = &PL_sv_undef;
                }

d1031 3
a1033 1
		while (relem < lastrelem+odd) {	/* gobble up all the rest */
d1035 5
a1039 8
                    assert(*relem);
		    /* Copy the key if aassign is called in lvalue context,
		       to avoid having the next op modify our rhs.  Copy
		       it also if it is gmagical, lest it make the
		       hv_store_ent call below croak, leaking the value. */
		    sv = lval || SvGMAGICAL(*relem)
			 ? sv_mortalcopy(*relem)
			 : *relem;
d1041 1
a1041 5
                    assert(*relem);
		    SvGETMAGIC(*relem);
                    tmpstr = newSV(0);
		    sv_setsv_nomg(tmpstr,*relem++);	/* value */
		    if (gimme == G_ARRAY) {
d1045 2
a1046 1
			else {
d1048 1
a1048 2
			     * stack location if we encountered dups earlier,
			     * possibly to a later stack location if odd */
d1055 5
a1059 3
			if (!didstore) sv_2mortal(tmpstr);
			SvSETMAGIC(tmpstr);
                    }
d1062 4
a1066 16
                if (duplicates && gimme == G_ARRAY) {
                    /* at this point we have removed the duplicate key/value
                     * pairs from the stack, but the remaining values may be
                     * wrong; i.e. with (a 1 a 2 b 3) on the stack we've removed
                     * the (a 2), but the stack now probably contains
                     * (a <freed> b 3), because { hv_save(a,1); hv_save(a,2) }
                     * obliterates the earlier key. So refresh all values. */
                    lastrelem -= duplicates;
                    relem = firsthashrelem;
                    while (relem < lastrelem+odd) {
                        HE *he;
                        he = hv_fetch_ent(hash, *relem++, 0, 0);
                        *relem++ = (he ? HeVAL(he) : &PL_sv_undef);
                    }
                }
                if (odd && gimme == G_ARRAY) lastrelem++;
d1164 1
a1164 7
	TAINTING_set( TAINTING_get | (tmp_uid && (tmp_euid != tmp_uid || tmp_egid != tmp_gid)) );
#ifdef NO_TAINT_SUPPORT
        PERL_UNUSED_VAR(tmp_uid);
        PERL_UNUSED_VAR(tmp_euid);
        PERL_UNUSED_VAR(tmp_gid);
        PERL_UNUSED_VAR(tmp_egid);
#endif
d1173 1
a1173 1
	SETi(lastrelem - firstrelem + 1);
d1176 19
a1194 3
	if (ary || hash)
	    /* note that in this case *firstlelem may have been overwritten
	       by sv_undef in the odd hash case */
d1196 2
a1197 1
	else {
d1199 3
a1201 4
            lelem = firstlelem + (relem - firstrelem);
            while (relem <= SP)
                *relem++ = (lelem <= lastlelem) ? *lelem++ : &PL_sv_undef;
        }
d1210 1
a1210 1
    PMOP * const pm = cPMOP;
a1213 2
    CV **cvp;
    CV *cv;
a1224 6
    cvp = &( ReANY((REGEXP *)SvRV(rv))->qr_anoncv);
    if ((cv = *cvp) && CvCLONE(*cvp)) {
	*cvp = cv_clone(cv);
	SvREFCNT_dec_NN(cv);
    }

d1227 1
a1227 1
	SvREFCNT_dec_NN(pkg);
d1231 1
a1231 1
    if (RX_ISTAINTED(rx)) {
d1242 1
a1242 1
    PMOP *pm = cPMOP;
d1244 2
a1245 2
    const char *t;
    const char *s;
d1250 1
a1250 1
    REGEXP *rx = PM_GETRE(pm);
d1272 1
a1272 1
    s = ReANY(rx)->mother_re
d1278 2
a1279 2
    rxtainted = (RX_ISTAINTED(rx) ||
		 (TAINT_get && (pm->op_pmflags & PMf_RETAINT)));
a1283 3
    /* We need to know this in case we fail out early - pos() must be reset */
    global = dynpm->op_pmflags & PMf_GLOBAL;

d1292 4
a1295 2
        DEBUG_r(PerlIO_printf(Perl_debug_log, "?? already matched once"));
	goto nope;
d1298 4
a1301 4
    /* empty pattern special-cased to use last successful pattern if
       possible, except for qr// */
    if (!ReANY(rx)->mother_re && !RX_PRELEN(rx)
     && PL_curpm) {
d1306 2
a1307 4
    if (RX_MINLEN(rx) > (I32)len) {
        DEBUG_r(PerlIO_printf(Perl_debug_log, "String shorter than min possible regex match\n"));
	goto nope;
    }
d1312 1
a1312 1
    if (global) {
d1331 11
a1341 21
#ifdef PERL_SAWAMPERSAND
    if (       RX_NPARENS(rx)
            || PL_sawampersand
            || (RX_EXTFLAGS(rx) & (RXf_EVAL_SEEN|RXf_PMf_KEEPCOPY))
            || (dynpm->op_pmflags & PMf_KEEPCOPY)
    )
#endif
    {
	r_flags |= (REXEC_COPY_STR|REXEC_COPY_SKIP_PRE);
        /* in @@a =~ /(.)/g, we iterate multiple times, but copy the buffer
         * only on the first iteration. Therefore we need to copy $' as well
         * as $&, to make the rest of the string available for captures in
         * subsequent iterations */
        if (! (global && gimme == G_ARRAY))
            r_flags |= REXEC_COPY_SKIP_POST;
    };
#ifdef PERL_SAWAMPERSAND
    if (dynpm->op_pmflags & PMf_KEEPCOPY)
        /* handle KEEPCOPY in pmop but not rx, eg $r=qr/a/; /$r/p */
        r_flags &= ~(REXEC_COPY_SKIP_PRE|REXEC_COPY_SKIP_POST);
#endif
d1346 1
a1346 2
	if ((s + RX_MINLEN(rx)) > strend || s < truebase) {
	    DEBUG_r(PerlIO_printf(Perl_debug_log, "Regex match can't succeed, so not even tried\n"));
a1347 1
	}
a1358 1
#ifdef PERL_SAWAMPERSAND
d1362 3
a1366 1
#endif
a1467 1
#ifdef PERL_SAWAMPERSAND
a1468 1
#endif
a1486 2
	RX_SUBOFFSET(rx) = 0;
	RX_SUBCOFFSET(rx) = 0;
d1498 1
a1498 4
#ifdef PERL_SAWAMPERSAND
    if (PL_sawampersand || RX_EXTFLAGS(rx) & RXf_PMf_KEEPCOPY)
#endif
    {
d1500 2
a1501 2
#ifdef PERL_ANY_COW
	if (SvCANCOW(TARG)) {
d1517 1
a1517 1
#ifdef PERL_ANY_COW
a1521 2
	RX_SUBOFFSET(rx) = 0;
	RX_SUBCOFFSET(rx) = 0;
a1525 1
#ifdef PERL_SAWAMPERSAND
d1530 3
a1532 4
#endif
    /* match via INTUIT shouldn't have any captures. Let @@-, @@+, $^N know */
    assert(!RX_NPARENS(rx));
    RX_LASTPAREN(rx) = RX_LASTCLOSEPAREN(rx) = 0;
d1555 1
a1555 1
    SV *sv;
d1559 2
a1560 2
    IO * const io = GvIO(PL_last_in_gv);
    const I32 type = PL_op->op_type;
a1584 1
			SvTAINTED_off(GvSVn(PL_last_in_gv)); /* previous tainting irrelevant */
d1642 1
a1642 1
	if (!tmplen && !SvREADONLY(sv) && !SvIsCOW(sv)) {
d1723 1
a1723 1
		if (!isALPHANUMERIC(*t1) &&
d1770 1
d1785 1
a1785 1
	if (SvCANEXISTDELETE(hv))
d1789 1
a1789 1
    he = hv_fetch_ent(hv, keysv, lval && !defer, 0);
d1802 1
a1802 1
	    SvREFCNT_dec_NN(key2);	/* sv_magic() increments refcount */
d1844 2
a1845 2
    PERL_CONTEXT *cx;
    SV *oldsv;
d1847 2
d1852 3
d1856 29
a1884 32

    switch (CxTYPE(cx)) {

    case CXt_LOOP_LAZYSV: /* string increment */
    {
        SV* cur = cx->blk_loop.state_u.lazysv.cur;
        SV *end = cx->blk_loop.state_u.lazysv.end;
        /* If the maximum is !SvOK(), pp_enteriter substitutes PL_sv_no.
           It has SvPVX of "" and SvCUR of 0, which is what we want.  */
        STRLEN maxlen = 0;
        const char *max = SvPV_const(end, maxlen);
        if (SvNIOK(cur) || SvCUR(cur) > maxlen)
            RETPUSHNO;

        oldsv = *itersvp;
        if (SvREFCNT(oldsv) == 1 && !SvMAGICAL(oldsv)) {
            /* safe to reuse old SV */
            sv_setsv(oldsv, cur);
        }
        else
        {
            /* we need a fresh SV every time so that loop body sees a
             * completely new SV for closures/references to work as
             * they used to */
            *itersvp = newSVsv(cur);
            SvREFCNT_dec_NN(oldsv);
        }
        if (strEQ(SvPVX_const(cur), max))
            sv_setiv(cur, 0); /* terminate next time */
        else
            sv_inc(cur);
        break;
d1886 3
a1888 5

    case CXt_LOOP_LAZYIV: /* integer increment */
    {
        IV cur = cx->blk_loop.state_u.lazyiv.cur;
	if (cur > cx->blk_loop.state_u.lazyiv.end)
a1890 1
        oldsv = *itersvp;
d1892 1
a1892 1
	if (SvREFCNT(oldsv) == 1 && !SvMAGICAL(oldsv)) {
d1894 1
a1894 1
	    sv_setiv(oldsv, cur);
d1901 3
a1903 2
	    *itersvp = newSViv(cur);
	    SvREFCNT_dec_NN(oldsv);
d1906 9
a1914 6
	if (cur == IV_MAX) {
	    /* Handle end of range at IV_MAX */
	    cx->blk_loop.state_u.lazyiv.end = IV_MIN;
	} else
	    ++cx->blk_loop.state_u.lazyiv.cur;
        break;
d1917 11
a1927 2
    case CXt_LOOP_FOR: /* iterate array */
    {
d1929 12
a1940 19
        AV *av = cx->blk_loop.state_u.ary.ary;
        SV *sv;
        bool av_is_stack = FALSE;
        IV ix;

        if (!av) {
            av_is_stack = TRUE;
            av = PL_curstack;
        }
        if (PL_op->op_private & OPpITER_REVERSED) {
            ix = --cx->blk_loop.state_u.ary.ix;
            if (ix <= (av_is_stack ? cx->blk_loop.resetsp : -1))
                RETPUSHNO;
        }
        else {
            ix = ++cx->blk_loop.state_u.ary.ix;
            if (ix > (av_is_stack ? cx->blk_oldsp : AvFILL(av)))
                RETPUSHNO;
        }
d1942 8
a1949 7
        if (SvMAGICAL(av) || AvREIFY(av)) {
            SV * const * const svp = av_fetch(av, ix, FALSE);
            sv = svp ? *svp : NULL;
        }
        else {
            sv = AvARRAY(av)[ix];
        }
d1951 4
a1954 10
        if (sv) {
            if (SvIS_FREED(sv)) {
                *itersvp = NULL;
                Perl_croak(aTHX_ "Use of freed value in iteration");
            }
            SvTEMP_off(sv);
            SvREFCNT_inc_simple_void_NN(sv);
        }
        else
            sv = &PL_sv_undef;
d1956 15
a1970 9
        if (!av_is_stack && sv == &PL_sv_undef) {
            SV *lv = newSV_type(SVt_PVLV);
            LvTYPE(lv) = 'y';
            sv_magic(lv, NULL, PERL_MAGIC_defelem, NULL, 0);
            LvTARG(lv) = SvREFCNT_inc_simple(av);
            LvTARGOFF(lv) = ix;
            LvTARGLEN(lv) = (STRLEN)UV_MAX;
            sv = lv;
        }
d1972 3
a1974 5
        oldsv = *itersvp;
        *itersvp = sv;
        SvREFCNT_dec(oldsv);
        break;
    }
a1975 3
    default:
	DIE(aTHX_ "panic: pp_iter, type=%u", CxTYPE(cx));
    }
a1981 3
This is all conditional on NO_TAINT_SUPPORT not being defined. Under
NO_TAINT_SUPPORT, taint-related operations should become no-ops.

d1983 3
a1985 4
PL_tainted will get set (via TAINT_set) if any component of the pattern
is tainted, e.g. /.*$tainted/.  At the end of pattern compilation,
the RXf_TAINTED flag is set on the pattern if PL_tainted is set (via
TAINT_get).
d1989 1
a1989 2
as /x$r/, will set PL_tainted using TAINT_set, and thus RXf_TAINTED,
on the new pattern too.
d1991 4
a1994 3
At the start of execution of a pattern, the RXf_TAINTED_SEEN flag on the
regex is cleared; during execution, locale-variant ops such as POSIXL may
set RXf_TAINTED_SEEN.
d1996 1
a1996 1
RXf_TAINTED_SEEN is used post-execution by the get magic code
d2049 1
a2049 1
    PMOP *pm = cPMOP;
d2051 1
a2051 1
    char *s;
d2053 1
a2053 1
    char *m;
d2055 1
a2055 1
    char *d;
d2059 1
a2059 1
    I32 i;
d2065 1
a2065 1
    REGEXP *rx = PM_GETRE(pm);
d2070 2
a2071 2
    bool doutf8 = FALSE; /* whether replacement is in utf8 */
#ifdef PERL_ANY_COW
d2076 1
a2076 1
    SV *dstr = (pm->op_pmflags & PMf_CONST) ? POPs : NULL;
d2089 1
a2089 2
    SvGETMAGIC(TARG); /* must come before cow check */
#ifdef PERL_ANY_COW
d2098 1
a2098 1
#ifdef PERL_ANY_COW
d2105 1
a2105 1
	Perl_croak_no_modify();
d2108 3
a2110 2
    s = SvPV_nomg(TARG, len);
    if (!SvPOKp(TARG) || SvTYPE(TARG) == SVt_PVGV || SvVOK(TARG))
d2117 1
a2117 1
    if (TAINTING_get) {
d2120 1
a2120 1
	  | (RX_ISTAINTED(rx) ? SUBST_TAINT_PAT : 0)
d2139 1
a2139 2
    if (!RX_PRELEN(rx) && PL_curpm
     && !ReANY(rx)->mother_re) {
d2143 5
a2147 12

#ifdef PERL_SAWAMPERSAND
    r_flags = (    RX_NPARENS(rx)
                || PL_sawampersand
                || (RX_EXTFLAGS(rx) & (RXf_EVAL_SEEN|RXf_PMf_KEEPCOPY))
                || (rpm->op_pmflags & PMf_KEEPCOPY)
              )
          ? REXEC_COPY_STR
          : 0;
#else
    r_flags = REXEC_COPY_STR;
#endif
d2159 4
a2162 1
	     && !(RX_EXTFLAGS(rx) & RXf_KEEPCOPY))
a2176 2
    PL_curpm = pm;

d2179 19
a2212 3

	if (SvTAINTED(dstr))
	    rxtainted |= SUBST_TAINT_REPL;
d2221 1
a2221 1
#ifdef PERL_ANY_COW
d2224 2
a2225 3
        && (I32)clen <= RX_MINLENRET(rx)
        && (once || !(r_flags & REXEC_COPY_STR))
        && !(RX_EXTFLAGS(rx) & RXf_NO_INPLACE_SUBST)
d2230 1
a2230 1
#ifdef PERL_ANY_COW
d2232 1
a2232 1
	  if (!force_on_match)
a2233 1
	  assert(SvVOK(TARG));
d2238 1
a2238 1
	    s = SvPV_force_nomg(TARG, len);
d2242 2
a2312 2
	bool first;
	SV *repl;
d2323 1
a2323 1
	    s = SvPV_force_nomg(TARG, len);
d2326 1
a2326 1
#ifdef PERL_ANY_COW
a2330 1
	repl = dstr;
d2332 1
d2334 1
a2334 1
	    PERL_CONTEXT *cx;
a2344 1
	first = TRUE;
a2352 1
                assert(RX_SUBOFFSET(rx) == 0);
d2358 4
a2361 1
	    sv_catpvn_nomg_maybeutf8(dstr, s, m - s, DO_UTF8(TARG));
d2363 2
a2364 17
	    if (first) {
		/* replacement already stringified */
	      if (clen)
		sv_catpvn_nomg_maybeutf8(dstr, c, clen, doutf8);
	      first = FALSE;
	    }
	    else {
		if (PL_encoding) {
		    if (!nsv) nsv = sv_newmortal();
		    sv_copypv(nsv, repl);
		    if (!DO_UTF8(nsv)) sv_recode_to_utf8(nsv, PL_encoding);
		    sv_catsv(dstr, nsv);
		}
		else sv_catsv(dstr, repl);
		if (SvTAINTED(repl))
		    rxtainted |= SUBST_TAINT_REPL;
	    }
d2369 4
a2372 1
	sv_catpvn_nomg_maybeutf8(dstr, s, strend - s, DO_UTF8(TARG));
d2381 1
a2381 1
#ifdef PERL_ANY_COW
d2397 1
a2397 1
	    SvFLAGS(TARG) |= SvUTF8(dstr);
d2407 2
d2412 1
a2412 1
    if (TAINTING_get) {
d2427 2
a2428 3
	TAINT_set(
	  cBOOL(rxtainted & (SUBST_TAINT_STR|SUBST_TAINT_PAT|SUBST_TAINT_REPL))
        );
d2496 1
a2496 1
    PERL_CONTEXT *cx;
d2520 1
a2520 1
		    SvREFCNT_dec_NN(sv);
d2560 2
a2561 2
    CV *cv;
    PERL_CONTEXT *cx;
d2602 2
a2603 1
	    if (!SvOK(sv))
a2604 1
	    sym = SvPV_nomg_const(sv, len);
d2634 1
a2634 4
	if (CvANON(cv) || !(gv = CvGV(cv))) {
	    if (CvNAMED(cv))
		DIE(aTHX_ "Undefined subroutine &%"HEKf" called",
			   HEKfARG(CvNAME_HEK(cv)));
a2635 1
	}
d2649 1
a2650 1
	       sorry:
d2657 1
a2657 1
	    goto sorry;
d2682 2
a2683 2
	I32 items = SP - MARK;
	PADLIST * const padlist = CvPADLIST(cv);
d2688 5
d2714 13
a2726 8
	    if (items - 1 > AvMAX(av)) {
                SV **ary = AvALLOC(av);
                AvMAX(av) = items - 1;
                Renew(ary, items, SV*);
                AvALLOC(av) = ary;
                AvARRAY(av) = ary;
            }

a2752 6
	if (((PL_op->op_private
	       & PUSHSUB_GET_LVALUE_MASK(Perl_is_lvalue_sub)
             ) & OPpENTERSUB_LVAL_MASK) == OPpLVAL_INTRO &&
	    !CvLVALUE(cv))
	    DIE(aTHX_ "Can't modify non-lvalue subroutine call");

d2801 2
a2802 9
        HEK *const hek = CvNAME_HEK(cv);
        SV *tmpstr;
        if (hek) {
            tmpstr = sv_2mortal(newSVhek(hek));
        }
        else {
            tmpstr = sv_newmortal();
            gv_efullname3(tmpstr, CvGV(cv), NULL);
        }
d2895 1
a2895 1
	    Perl_croak_no_modify();
d2957 1
a2957 5
    SV * const sv = PL_stack_base + TOPMARK == PL_stack_sp
	? (Perl_croak(aTHX_ "Can't call method \"%"SVf"\" without a "
			    "package or object reference", SVfARG(meth)),
	   (SV *)NULL)
	: *(PL_stack_base + TOPMARK + 1);
a2961 1
       undefined:
a2967 1
    else if (!SvOK(sv)) goto undefined;
a2968 1
	/* this isn't a reference */
d2971 9
a2979 6
        const char * const packname = SvPV_nomg_const(sv, packlen);
        const bool packname_is_utf8 = !!SvUTF8(sv);
        const HE* const he =
	    (const HE *)hv_common(
                PL_stashcache, NULL, packname, packlen,
                packname_is_utf8 ? HVhek_UTF8 : 0, 0, NULL, 0
d2982 1
a2982 1
        if (he) { 
a2983 2
            DEBUG_o(Perl_deb(aTHX_ "PL_stashcache hit %p for '%"SVf"'\n",
                             stash, sv));
d2985 1
d2988 3
a2990 1
	if (!(iogv = gv_fetchpvn_flags(
d2996 5
a3000 1
	    if (!packlen)
d3002 5
a3006 3
		Perl_croak(aTHX_ "Can't call method \"%"SVf"\" "
				 "without a package or object reference",
				  SVfARG(meth));
a3015 2
                DEBUG_o(Perl_deb(aTHX_ "PL_stashcache caching %p for '%"SVf"'\n",
                                 stash, sv));
d3066 1
a3066 1
 * indent-tabs-mode: nil
d3069 1
a3069 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@d64 1
a64 1
    if (UNLIKELY(PL_op->op_private & OPpLVAL_INTRO))
d136 1
a136 1
    if (TAINTING_get && UNLIKELY(TAINT_get) && !SvTAINTED(right))
d138 1
a138 2
    if (UNLIKELY(PL_op->op_private & OPpASSIGN_CV_TO_GV)) {
        /* *foo =\&bar */
d217 1
a217 1
      UNLIKELY(SvTEMP(left)) && !SvSMAGICAL(left) && SvREFCNT(left) == 1 &&
d281 2
a282 2
    else { /* $l .= $r   and   left == TARG */
	if (!SvOK(left)) {
d287 1
a287 3
        else {
            SvPV_force_nomg_nolen(left);
        }
d290 1
a290 1
	    SvUTF8_off(left);
d329 1
a329 1
    const SSize_t maxarg = AvFILL(av) + 1;
d331 3
a333 3
    if (UNLIKELY(SvRMAGICAL(av))) {
        PADOFFSET i;
        for (i=0; i < (PADOFFSET)maxarg; i++) {
d342 1
a342 5
        PADOFFSET i;
        for (i=0; i < (PADOFFSET)maxarg; i++) {
            SV * const sv = AvARRAY(av)[i];
            SP[i+1] = LIKELY(sv) ? sv : &PL_sv_undef;
        }
d467 1
a467 1
    if (UNLIKELY(SvTYPE(TOPs) >= SVt_PVAV || (isGV_with_GP(TOPs) && !SvFAKE(TOPs))))
d469 1
a469 1
    if (LIKELY(!SvREADONLY(TOPs) && !SvGMAGICAL(TOPs) && SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs))
d506 1
a506 1
        if (UNLIKELY(!sv || !SvANY(sv))) {
d515 1
a515 1
        if (UNLIKELY(!sv || !SvANY(sv)))
d724 1
a724 1
    SV** const svp = av_fetch(av, (I8)PL_op->op_private, lval);
a725 4

    if (UNLIKELY(!svp && lval))
        DIE(aTHX_ PL_no_aelem, (int)(I8)PL_op->op_private);

d786 1
a786 1
	return Perl_tied_method(aTHX_ SV_CONST(PRINT), mark - 1, MUTABLE_SV(io),
d869 1
a869 1
	if (UNLIKELY(SvAMAGIC(sv))) {
d873 1
a873 1
	if (UNLIKELY(SvTYPE(sv) != type))
d876 2
a877 2
	else if (UNLIKELY(PL_op->op_flags & OPf_MOD
		&& PL_op->op_private & OPpLVAL_INTRO))
d880 1
a880 1
    else if (UNLIKELY(SvTYPE(sv) != type)) {
d900 1
a900 1
    else if (UNLIKELY(PL_op->op_private & OPpMAYBE_LVSUB)) {
d923 1
a923 1
	    const SSize_t maxarg = AvFILL(av) + 1;
d938 1
a938 1
	    dTARG;
d940 1
d993 1
a993 1
    SSize_t i;
d1020 1
a1020 1
	    if (LIKELY((sv = *relem))) {
d1026 1
a1026 1
		if (UNLIKELY(SvIS_FREED(sv))) {
d1044 1
a1044 1
    while (LIKELY(lelem <= lastlelem)) {
d1058 2
a1059 2
		if (LIKELY(*relem))
		    SvGETMAGIC(*relem); /* before newSV, in case it dies */
d1072 1
a1072 1
	    if (UNLIKELY(PL_delaymagic & DM_ARRAY_ISA))
d1087 1
a1087 1
                if (UNLIKELY(odd)) {
d1097 1
a1097 1
		while (LIKELY(relem < lastrelem+odd)) {	/* gobble up all the rest */
d1157 1
a1157 1
		if (UNLIKELY(
d1160 1
a1160 1
		))
d1174 1
a1174 1
    if (UNLIKELY(PL_delaymagic & ~DM_DELAY)) {
d1176 4
a1179 4
	Uid_t tmp_uid  = PerlProc_getuid();
	Uid_t tmp_euid = PerlProc_geteuid();
	Gid_t tmp_gid  = PerlProc_getgid();
	Gid_t tmp_egid = PerlProc_getegid();
a1180 1
        /* XXX $> et al currently silently ignore failures */
d1183 3
a1185 4
	    PERL_UNUSED_RESULT(
               setresuid((PL_delaymagic & DM_RUID) ? PL_delaymagic_uid  : (Uid_t)-1,
                         (PL_delaymagic & DM_EUID) ? PL_delaymagic_euid : (Uid_t)-1,
                         (Uid_t)-1));
d1188 2
a1189 3
            PERL_UNUSED_RESULT(
                setreuid((PL_delaymagic & DM_RUID) ? PL_delaymagic_uid  : (Uid_t)-1,
                         (PL_delaymagic & DM_EUID) ? PL_delaymagic_euid : (Uid_t)-1));
d1193 1
a1193 1
		PERL_UNUSED_RESULT(setruid(PL_delaymagic_uid));
d1199 1
a1199 1
		PERL_UNUSED_RESULT(seteuid(PL_delaymagic_euid));
d1206 1
a1206 1
		PERL_UNUSED_RESULT(PerlProc_setuid(PL_delaymagic_uid));
a1209 1

a1212 1
        /* XXX $> et al currently silently ignore failures */
d1215 3
a1217 4
	    PERL_UNUSED_RESULT(
                setresgid((PL_delaymagic & DM_RGID) ? PL_delaymagic_gid  : (Gid_t)-1,
                          (PL_delaymagic & DM_EGID) ? PL_delaymagic_egid : (Gid_t)-1,
                          (Gid_t)-1));
d1220 2
a1221 3
	    PERL_UNUSED_RESULT(
                setregid((PL_delaymagic & DM_RGID) ? PL_delaymagic_gid  : (Gid_t)-1,
                         (PL_delaymagic & DM_EGID) ? PL_delaymagic_egid : (Gid_t)-1));
d1225 1
a1225 1
		PERL_UNUSED_RESULT(setrgid(PL_delaymagic_gid));
d1231 1
a1231 1
		PERL_UNUSED_RESULT(setegid(PL_delaymagic_egid));
d1238 1
a1238 1
		PERL_UNUSED_RESULT(PerlProc_setgid(PL_delaymagic_gid));
a1241 1

d1299 1
a1299 1
    if (UNLIKELY((cv = *cvp) && CvCLONE(*cvp))) {
d1310 1
a1310 1
    if (UNLIKELY(RX_ISTAINTED(rx))) {
d1323 1
a1325 1
    SSize_t curpos = 0; /* initial pos() or current $+[0] */
d1327 1
a1327 1
    U8 r_flags = 0;
d1333 1
d1335 1
d1337 1
a1337 1
    MAGIC *mg = NULL;
d1351 1
a1351 1
    truebase = ReANY(rx)->mother_re
d1354 1
a1354 1
    if (!truebase)
d1356 1
a1356 1
    strend = truebase + len;
d1361 2
d1386 2
a1387 4
    if (RX_MINLEN(rx) >= 0 && (STRLEN)RX_MINLEN(rx) > len) {
        DEBUG_r(PerlIO_printf(Perl_debug_log, "String shorter than min possible regex match (%"
                                              UVuf" < %"IVdf")\n",
                                              (UV)len, (IV)RX_MINLEN(rx)));
d1391 3
a1393 1
    /* get pos() if //g */
d1395 17
a1411 7
        mg = mg_find_mglob(TARG);
        if (mg && mg->mg_len >= 0) {
            curpos = MgBYTEPOS(mg, TARG, truebase, len);
            /* last time pos() was set, it was zero-length match */
            if (mg->mg_flags & MGf_MINMATCH)
                had_zerolen = 1;
        }
a1412 1

a1434 2
    s = truebase;

d1436 14
a1449 2
    if (global)
	s = truebase + curpos;
d1451 10
d1462 2
a1463 2
		     had_zerolen, TARG, NULL, r_flags))
	goto nope;
d1466 1
a1466 1
    if (dynpm->op_pmflags & PMf_ONCE)
d1472 1
d1474 1
d1478 1
a1478 21

    /* update pos */

    if (global && (gimme != G_ARRAY || (dynpm->op_pmflags & PMf_CONTINUE))) {
        if (!mg)
            mg = sv_magicext_mglob(TARG);
        MgBYTEPOS_set(mg, TARG, truebase, RX_OFFS(rx)[0].end);
        if (RX_ZERO_LEN(rx))
            mg->mg_flags |= MGf_MINMATCH;
        else
            mg->mg_flags &= ~MGf_MINMATCH;
    }

    if ((!RX_NPARENS(rx) && !global) || gimme != G_ARRAY) {
	LEAVE_SCOPE(oldsave);
	RETPUSHYES;
    }

    /* push captures on stack */

    {
d1487 1
a1487 3
	    if (LIKELY((RX_OFFS(rx)[i].start != -1)
                     && RX_OFFS(rx)[i].end   != -1 ))
            {
d1489 3
a1491 3
		const char * const s = RX_OFFS(rx)[i].start + truebase;
	        if (UNLIKELY(RX_OFFS(rx)[i].end < 0 || RX_OFFS(rx)[i].start < 0
                        || len < 0 || len > strend - s))
d1502 23
a1524 2
            curpos = (UV)RX_OFFS(rx)[0].end;
	    had_zerolen = RX_ZERO_LEN(rx);
d1529 2
d1534 105
a1638 1
    /* NOTREACHED */
d1641 1
d1643 5
a1647 4
        if (!mg)
            mg = mg_find_mglob(TARG);
        if (mg)
            mg->mg_len = -1;
d1670 1
a1670 1
	    Perl_tied_method(aTHX_ SV_CONST(READLINE), SP, MUTABLE_SV(io), mg, gimme, 0);
d1686 1
a1686 1
		    if (av_tindex(GvAVn(PL_last_in_gv)) < 0) {
d1688 1
a1688 1
			do_open6(PL_last_in_gv, "-", 1, NULL, NULL, 0);
d1712 1
a1712 2
	    && ckWARN(WARN_CLOSED)
            && type != OP_GLOB)
d1714 6
a1719 1
	    report_evil_fh(PL_last_in_gv);
d1828 2
a1829 5
#ifdef __VMS
		if (strchr("*%?", *t1))
#else
		if (strchr("$&*(){}[]'\";\\|?<>~`", *t1))
#endif
d1966 1
a1966 1
        if (UNLIKELY(SvNIOK(cur) || SvCUR(cur) > maxlen))
d1970 1
a1970 1
        if (LIKELY(SvREFCNT(oldsv) == 1 && !SvMAGICAL(oldsv))) {
d1992 1
a1992 1
	if (UNLIKELY(cur > cx->blk_loop.state_u.lazyiv.end))
d1997 1
a1997 1
	if (LIKELY(SvREFCNT(oldsv) == 1 && !SvMAGICAL(oldsv))) {
d2010 1
a2010 1
	if (UNLIKELY(cur == IV_MAX)) {
d2032 1
a2032 1
            if (UNLIKELY(ix <= (av_is_stack ? cx->blk_loop.resetsp : -1)))
d2037 1
a2037 1
            if (UNLIKELY(ix > (av_is_stack ? cx->blk_oldsp : AvFILL(av))))
d2041 1
a2041 1
        if (UNLIKELY(SvMAGICAL(av) || AvREIFY(av))) {
d2049 2
a2050 2
        if (LIKELY(sv)) {
            if (UNLIKELY(SvIS_FREED(sv))) {
d2054 2
a2055 11
            if (SvPADTMP(sv)) {
                assert(!IS_PADGV(sv));
                sv = newSVsv(sv);
            }
            else {
                SvTEMP_off(sv);
                SvREFCNT_inc_simple_void_NN(sv);
            }
        }
        else if (!av_is_stack) {
            sv = newSVavdefelem(av, ix, 0);
d2060 10
d2092 1
a2092 2
TAINT_get).  It will also be set if any component of the pattern matches
based on locale-dependent behavior.
d2099 4
d2160 1
d2162 1
d2166 1
d2206 3
d2216 1
a2216 4
    orig = SvPV_nomg(TARG, len);
    /* note we don't (yet) force the var into being a string; if we fail
     * to match, we leave as-is; on successful match howeverm, we *will*
     * coerce into a string, then repeat the match */
d2234 2
d2237 2
a2238 2
    if (!pm || !orig)
	DIE(aTHX_ "panic: pp_subst, pm=%p, orig=%p", pm, orig);
d2240 2
a2241 2
    strend = orig + len;
    slen = DO_UTF8(TARG) ? utf8_length((U8*)orig, (U8*)strend) : len;
d2264 17
a2280 1
    if (!CALLREGEXEC(rx, orig, strend, orig, 0, TARG, NULL, r_flags))
d2282 1
d2288 1
d2323 1
a2323 4
        && (  once
           || !(r_flags & REXEC_COPY_STR)
           || (!SvGMAGICAL(dstr) && !(RX_EXTFLAGS(rx) & RXf_EVAL_SEEN))
           )
a2336 2
            /* redo the first match, this time with the orig var
             * forced into being a string */
d2338 1
a2338 1
	    orig = SvPV_force_nomg(TARG, len);
d2341 1
a2341 1

a2342 1
            char *d, *m;
a2348 1
                I32 i;
d2361 1
a2361 2
	    else {	/* faster from front */
                I32 i = m - s;
d2363 2
a2364 2
                if (i > 0)
                    Move(s, d - i, i, char);
d2367 9
a2375 1
		    Copy(c, d, clen, char);
a2380 2
            char *d, *m;
            d = s = RX_OFFS(rx)[0].start + orig;
d2382 1
a2382 2
                I32 i;
		if (UNLIKELY(iters++ > maxiters))
d2384 1
a2384 1
		if (UNLIKELY(RX_MATCH_TAINTED(rx))) /* run time pattern taint, eg locale */
d2397 1
a2397 2
	    } while (CALLREGEXEC(rx, s, strend, orig,
				 s == m, /* don't match same null twice */
d2399 2
a2400 1
                     REXEC_NOT_FIRST|REXEC_IGNOREPOS|REXEC_FAIL_ON_UNDERFLOW));
d2402 1
a2402 1
                I32 i = strend - s;
a2411 1
        char *m;
a2413 2
            /* redo the first match, this time with the orig var
             * forced into being a string */
d2423 1
a2423 1
	    orig = SvPV_force_nomg(TARG, len);
d2432 1
a2432 3
        s = RX_OFFS(rx)[0].start + orig;
	dstr = newSVpvn_flags(orig, s-orig,
                    SVs_TEMP | (DO_UTF8(TARG) ? SVf_UTF8 : 0));
a2435 1
            m = orig;
d2444 1
d2447 1
a2447 1
	    if (UNLIKELY(iters++ > maxiters))
d2449 1
a2449 1
	    if (UNLIKELY(RX_MATCH_TAINTED(rx)))
d2452 2
a2453 2
		char *old_s    = s;
		char *old_orig = orig;
a2454 1

d2456 2
a2457 2
		s = orig + (old_s - old_orig);
		strend = s + (strend - old_s);
d2476 1
a2476 1
		if (UNLIKELY(SvTAINTED(repl)))
d2482 1
a2482 2
			     TARG, NULL,
                    REXEC_NOT_FIRST|REXEC_IGNOREPOS|REXEC_FAIL_ON_UNDERFLOW));
d2558 1
a2558 1
    if (UNLIKELY(PL_stack_base + *PL_markstack_ptr > SP)) {
a2588 5
	if (SvPADTMP(src)) {
            assert(!IS_PADGV(src));
	    src = PL_stack_base[*PL_markstack_ptr] = sv_mortalcopy(src);
	    PL_tmps_floor++;
	}
d2618 1
a2618 1
	if (LIKELY(MARK <= SP)) {
d2658 1
a2659 1
    cxstack_ix--;
d2675 51
a2725 1
    if (UNLIKELY(!sv))
d2727 4
a2730 56
    /* This is overwhelmingly the most common case:  */
    if (!LIKELY(SvTYPE(sv) == SVt_PVGV && (cv = GvCVu((const GV *)sv)))) {
        switch (SvTYPE(sv)) {
        case SVt_PVGV:
          we_have_a_glob:
            if (!(cv = GvCVu((const GV *)sv))) {
                HV *stash;
                cv = sv_2cv(sv, &stash, &gv, 0);
            }
            if (!cv) {
                ENTER;
                SAVETMPS;
                goto try_autoload;
            }
            break;
        case SVt_PVLV:
            if(isGV_with_GP(sv)) goto we_have_a_glob;
            /*FALLTHROUGH*/
        default:
            if (sv == &PL_sv_yes) {		/* unfound import, ignore */
                if (hasargs)
                    SP = PL_stack_base + POPMARK;
                else
                    (void)POPMARK;
                RETURN;
            }
            SvGETMAGIC(sv);
            if (SvROK(sv)) {
                if (SvAMAGIC(sv)) {
                    sv = amagic_deref_call(sv, to_cv_amg);
                    /* Don't SPAGAIN here.  */
                }
            }
            else {
                const char *sym;
                STRLEN len;
                if (!SvOK(sv))
                    DIE(aTHX_ PL_no_usym, "a subroutine");
                sym = SvPV_nomg_const(sv, len);
                if (PL_op->op_private & HINT_STRICT_REFS)
                    DIE(aTHX_ "Can't use string (\"%" SVf32 "\"%s) as a subroutine ref while \"strict refs\" in use", sv, len>32 ? "..." : "");
                cv = get_cvn_flags(sym, len, GV_ADD|SvUTF8(sv));
                break;
            }
            cv = MUTABLE_CV(SvRV(sv));
            if (SvTYPE(cv) == SVt_PVCV)
                break;
            /* FALL THROUGH */
        case SVt_PVHV:
        case SVt_PVAV:
            DIE(aTHX_ "Not a CODE reference");
            /* This is the second most common case:  */
        case SVt_PVCV:
            cv = MUTABLE_CV(sv);
            break;
        }
d2734 1
d2737 1
a2737 1
    if (UNLIKELY(CvCLONE(cv) && ! CvCLONED(cv)))
d2739 1
a2739 1
    if (UNLIKELY(!CvROOT(cv) && !CvXSUB(cv))) {
d2775 2
a2776 3
    if (UNLIKELY((PL_op->op_private & OPpENTERSUB_DB) && GvCV(PL_DBsub)
            && !CvNODEBUG(cv)))
    {
d2782 1
a2782 1
	     cv = GvCV(gv_fetchpvs("DB::lsub", GV_ADDMULTI, SVt_PVCV));
a2792 2
    gimme = GIMME_V;

d2796 1
a2797 2
        I32 depth;

d2801 2
a2802 1
	if (UNLIKELY((depth = ++CvDEPTH(cv)) >= 2)) {
d2804 1
a2804 1
	    pad_push(padlist, depth);
d2807 2
a2808 2
	PAD_SET_CUR_NOSAVE(padlist, depth);
	if (LIKELY(hasargs)) {
d2810 1
a2810 4
            SSize_t items;
            AV **defavp;

	    if (UNLIKELY(AvREAL(av))) {
d2817 2
a2818 3
	    defavp = &GvAV(PL_defgv);
	    cx->blk_sub.savearray = *defavp;
	    *defavp = MUTABLE_AV(SvREFCNT_inc_simple_NN(av));
d2821 1
a2821 1
            items = SP - MARK;
d2823 1
a2823 1
	    if (UNLIKELY(items - 1 > AvMAX(av))) {
d2831 1
a2831 1
	    Copy(MARK+1,AvARRAY(av),items,SV*);
a2833 1
	    MARK = AvARRAY(av);
a2835 5
		{
		    if (SvPADTMP(*MARK)) {
                        assert(!IS_PADGV(*MARK));
			*MARK = sv_mortalcopy(*MARK);
                    }
a2836 1
		}
d2840 2
a2841 3
	SAVETMPS;
	if (UNLIKELY((cx->blk_u16 & OPpENTERSUB_LVAL_MASK) == OPpLVAL_INTRO &&
	    !CvLVALUE(cv)))
d2847 2
a2848 3
	if (UNLIKELY(depth == PERL_SUB_DEPTH_WARN
                && ckWARN(WARN_RECURSION)
                && !(PERLDB_SUB && cv == GvCV(PL_DBsub))))
d2853 1
a2853 1
	SSize_t markix = TOPMARK;
a2854 1
	SAVETMPS;
d2857 1
a2857 1
	if (UNLIKELY(((PL_op->op_private
d2860 1
a2860 1
	    !CvLVALUE(cv)))
d2863 1
a2863 1
	if (UNLIKELY(!hasargs && GvAV(PL_defgv))) {
d2868 1
a2868 1
	    const SSize_t items = AvFILL(av) + 1;
a2870 2
		SSize_t i = 0;
		const bool m = cBOOL(SvRMAGICAL(av));
d2873 1
a2873 13
		for (; i < items; ++i)
		{
		    SV *sv;
		    if (m) {
			SV ** const svp = av_fetch(av, i, 0);
			sv = svp ? *svp : NULL;
		    }
		    else sv = AvARRAY(av)[i];
		    if (sv) SP[i+1] = sv;
		    else {
			SP[i+1] = newSVavdefelem(av, i, 1);
		    }
		}
a2877 11
	else {
	    SV **mark = PL_stack_base + markix;
	    SSize_t items = SP - mark;
	    while (items--) {
		mark++;
		if (*mark && SvPADTMP(*mark)) {
                    assert(!IS_PADGV(*mark));
		    *mark = sv_mortalcopy(*mark);
                }
	    }
	}
d2879 1
a2879 1
	if (UNLIKELY(PL_curcopdb)) {
d2891 6
a2896 6
	if (gimme == G_SCALAR) {
            SV **svp = PL_stack_base + markix + 1;
            if (svp != PL_stack_sp) {
                *svp = svp > PL_stack_sp ? &PL_sv_undef : *PL_stack_sp;
                PL_stack_sp = svp;
            }
d2933 1
a2933 1
    const U32 defer = PL_op->op_private & OPpLVAL_DEFER;
d2938 1
a2938 1
    if (UNLIKELY(SvROK(elemsv) && !SvGAMAGIC(elemsv) && ckWARN(WARN_MISC)))
d2942 1
a2942 1
    if (UNLIKELY(SvTYPE(av) != SVt_PVAV))
d2945 1
a2945 1
    if (UNLIKELY(localizing)) {
d2972 2
a2973 2
	if (!svp || !*svp) {
	    IV len;
d2976 8
a2983 7
	    len = av_tindex(av);
	    mPUSHs(newSVavdefelem(av,
	    /* Resolve a negative index now, unless it points before the
	       beginning of the array, in which case record it for error
	       reporting in magic_setdefelem. */
		elem < 0 && len + elem >= 0 ? len + elem : elem,
		1));
d2986 1
a2986 1
	if (UNLIKELY(localizing)) {
d3082 1
a3082 1
    if (UNLIKELY(!sv))
a3090 13
    else if (isGV_with_GP(sv)) {
	if (!GvIO(sv))
	    Perl_croak(aTHX_ "Can't call method \"%"SVf"\" "
			     "without a package or object reference",
			      SVfARG(meth));
	ob = sv;
	if (SvTYPE(ob) == SVt_PVLV && LvTYPE(ob) == 'y') {
	    assert(!LvTARGLEN(ob));
	    ob = LvTARG(ob);
	    assert(ob);
	}
	*(PL_stack_base + TOPMARK + 1) = sv_2mortal(newRV(ob));
    }
d3139 1
a3139 1
    /* if we got here, ob should be an object or a glob */
d3141 2
a3142 1
		 || (isGV_with_GP(ob)
@


1.1.1.17
log
@Import perl-5.24.2
@
text
@d42 1
d50 1
d53 1
a53 1
    PL_stack_sp = PL_stack_base + CX_CUR()->blk_oldsp;
d61 1
a70 3

/* also used for: pp_lineseq() pp_regcmaybe() pp_scalar() pp_scope() */

d73 1
d77 1
a77 2
/* This is sometimes called directly by pp_coreargs, pp_grepstart and
   amagic_call. */
d80 1
d87 1
a87 1
    dSP; dTARGET;
d98 1
a98 1
    dSP;
a102 3

/* also used for: pp_andassign() */

d105 1
d126 1
a126 1
    dSP;
d136 1
a136 2
    assert(TAINTING_get || !TAINT_get);
    if (UNLIKELY(TAINT_get) && !SvTAINTED(right))
d210 1
a210 1
		SvREFCNT_inc_simple_void_NN(source);
d231 1
a231 1
    dSP;
d241 1
a241 1
    PERL_CONTEXT *cx;
d244 1
a244 2
    cx  = CX_CUR();
    PL_stack_sp = PL_stack_base + cx->blk_oldsp;
d247 2
a248 2
        assert(CxTYPE(cx) == CXt_BLOCK || CxTYPE_is_LOOP(cx));
	CX_LEAVE_SCOPE(cx);
d255 1
a255 1
  dSP; dATARGET; tryAMAGICbin_MG(concat_amg, AMGf_assign);
d297 3
d304 2
d314 1
d360 1
a360 1
    dSP;
d384 1
a384 1
        STATIC_ASSERT_STMT(OPpPADRANGE_COUNTMASK + 1 == (1 << OPpPADRANGE_COUNTSHIFT));
d401 1
a401 1
    dSP;
d431 1
a447 4
	    if (PL_last_in_gv == (GV *)&PL_sv_undef)
		PL_last_in_gv = NULL;
	    else
		assert(isGV_with_GP(PL_last_in_gv));
d455 1
a455 1
    dSP;
a468 3

/* also used for: pp_i_preinc() */

d471 7
a477 28
    SV *sv = *PL_stack_sp;

    if (LIKELY(((sv->sv_flags &
                        (SVf_THINKFIRST|SVs_GMG|SVf_IVisUV|
                         SVf_IOK|SVf_NOK|SVf_POK|SVp_NOK|SVp_POK|SVf_ROK))
                == SVf_IOK))
        && SvIVX(sv) != IV_MAX)
    {
	SvIV_set(sv, SvIVX(sv) + 1);
    }
    else /* Do all the PERL_PRESERVE_IVUV and hard cases in sv_inc */
	sv_inc(sv);
    SvSETMAGIC(sv);
    return NORMAL;
}


/* also used for: pp_i_predec() */

PP(pp_predec)
{
    SV *sv = *PL_stack_sp;

    if (LIKELY(((sv->sv_flags &
                        (SVf_THINKFIRST|SVs_GMG|SVf_IVisUV|
                         SVf_IOK|SVf_NOK|SVf_POK|SVp_NOK|SVp_POK|SVf_ROK))
                == SVf_IOK))
        && SvIVX(sv) != IV_MIN)
d479 2
a480 1
	SvIV_set(sv, SvIVX(sv) - 1);
d482 4
a485 3
    else /* Do all the PERL_PRESERVE_IVUV and hard cases  in sv_dec */
	sv_dec(sv);
    SvSETMAGIC(sv);
a488 3

/* also used for: pp_orassign() */

d491 1
a491 1
    dSP;
a501 3

/* also used for: pp_dor() pp_dorassign() */

d504 1
a504 1
    dSP;
a559 2


d562 1
a562 2
    dSP; dATARGET; bool useleft; SV *svl, *svr;

d567 1
a568 50

    /* special-case some simple common cases */
    if (!((svl->sv_flags|svr->sv_flags) & (SVf_IVisUV|SVs_GMG))) {
        IV il, ir;
        U32 flags = (svl->sv_flags & svr->sv_flags);
        if (flags & SVf_IOK) {
            /* both args are simple IVs */
            UV topl, topr;
            il = SvIVX(svl);
            ir = SvIVX(svr);
          do_iv:
            topl = ((UV)il) >> (UVSIZE * 8 - 2);
            topr = ((UV)ir) >> (UVSIZE * 8 - 2);

            /* if both are in a range that can't under/overflow, do a
             * simple integer add: if the top of both numbers
             * are 00  or 11, then it's safe */
            if (!( ((topl+1) | (topr+1)) & 2)) {
                SP--;
                TARGi(il + ir, 0); /* args not GMG, so can't be tainted */
                SETs(TARG);
                RETURN;
            }
            goto generic;
        }
        else if (flags & SVf_NOK) {
            /* both args are NVs */
            NV nl = SvNVX(svl);
            NV nr = SvNVX(svr);

            if (
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
                !Perl_isnan(nl) && nl == (NV)(il = (IV)nl)
                && !Perl_isnan(nr) && nr == (NV)(ir = (IV)nr)
#else
                nl == (NV)(il = (IV)nl) && nr == (NV)(ir = (IV)nr)
#endif
                )
                /* nothing was lost by converting to IVs */
                goto do_iv;
            SP--;
            TARGn(nl + nr, 0); /* args not GMG, so can't be tainted */
            SETs(TARG);
            RETURN;
        }
    }

  generic:

    useleft = USE_LEFT(svl);
d639 2
a640 2
		    } else {
			auv = (aiv == IV_MIN) ? (UV)aiv : (UV)(-aiv);
d660 1
a660 1
                    buv = (biv == IV_MIN) ? (UV)biv : (UV)(-biv);
d701 1
a701 2
                        SETi(result == (UV)IV_MIN
                                ? IV_MIN : -(IV)result);
a710 3

#else
    useleft = USE_LEFT(svl);
a711 1

a724 3

/* also used for: pp_aelemfast_lex() */

d727 1
a727 1
    dSP;
d746 1
a746 1
    dSP; dMARK; dTARGET;
d756 1
a756 1
    dSP;
a774 2
/* also used for: pp_say() */

d777 1
a777 1
    dSP; dMARK; dORIGMARK;
a868 4

/* also used for: pp_rv2hv() */
/* also called directly by pp_lvavref */

d871 2
a872 2
    dSP; dTOPss;
    const U8 gimme = GIMME_V;
d875 1
a875 2
    const bool is_pp_rv2av = PL_op->op_type == OP_RV2AV
			  || PL_op->op_type == OP_LVAVREF;
d923 3
a925 1
	/* The guts of pp_rv2av  */
d965 2
a986 162

/* Do a mark and sweep with the SVf_BREAK flag to detect elements which
 * are common to both the LHS and RHS of an aassign, and replace them
 * with copies. All these copies are made before the actual list assign is
 * done.
 *
 * For example in ($a,$b) = ($b,$a), assigning the value of the first RHS
 * element ($b) to the first LH element ($a), modifies $a; when the
 * second assignment is done, the second RH element now has the wrong
 * value. So we initially replace the RHS with ($b, mortalcopy($a)).
 * Note that we don't need to make a mortal copy of $b.
 *
 * The algorithm below works by, for every RHS element, mark the
 * corresponding LHS target element with SVf_BREAK. Then if the RHS
 * element is found with SVf_BREAK set, it means it would have been
 * modified, so make a copy.
 * Note that by scanning both LHS and RHS in lockstep, we avoid
 * unnecessary copies (like $b above) compared with a naive
 * "mark all LHS; copy all marked RHS; unmark all LHS".
 *
 * If the LHS element is a 'my' declaration' and has a refcount of 1, then
 * it can't be common and can be skipped.
 *
 * On DEBUGGING builds it takes an extra boolean, fake. If true, it means
 * that we thought we didn't need to call S_aassign_copy_common(), but we
 * have anyway for sanity checking. If we find we need to copy, then panic.
 */

PERL_STATIC_INLINE void
S_aassign_copy_common(pTHX_ SV **firstlelem, SV **lastlelem,
        SV **firstrelem, SV **lastrelem
#ifdef DEBUGGING
        , bool fake
#endif
)
{
    dVAR;
    SV **relem;
    SV **lelem;
    SSize_t lcount = lastlelem - firstlelem + 1;
    bool marked = FALSE; /* have we marked any LHS with SVf_BREAK ? */
    bool const do_rc1 = cBOOL(PL_op->op_private & OPpASSIGN_COMMON_RC1);
    bool copy_all = FALSE;

    assert(!PL_in_clean_all); /* SVf_BREAK not already in use */
    assert(firstlelem < lastlelem); /* at least 2 LH elements */
    assert(firstrelem < lastrelem); /* at least 2 RH elements */


    lelem = firstlelem;
    /* we never have to copy the first RH element; it can't be corrupted
     * by assigning something to the corresponding first LH element.
     * So this scan does in a loop: mark LHS[N]; test RHS[N+1]
     */
    relem = firstrelem + 1;

    for (; relem <= lastrelem; relem++) {
        SV *svr;

        /* mark next LH element */

        if (--lcount >= 0) {
            SV *svl = *lelem++;

            if (UNLIKELY(!svl)) {/* skip AV alias marker */
                assert (lelem <= lastlelem);
                svl = *lelem++;
                lcount--;
            }

            assert(svl);
            if (SvSMAGICAL(svl)) {
                copy_all = TRUE;
            }
            if (SvTYPE(svl) == SVt_PVAV || SvTYPE(svl) == SVt_PVHV) {
                if (!marked)
                    return;
                /* this LH element will consume all further args;
                 * no need to mark any further LH elements (if any).
                 * But we still need to scan any remaining RHS elements;
                 * set lcount negative to distinguish from  lcount == 0,
                 * so the loop condition continues being true
                 */
                lcount = -1;
                lelem--; /* no need to unmark this element */
            }
            else if (!(do_rc1 && SvREFCNT(svl) == 1) && svl != &PL_sv_undef) {
                assert(!SvIMMORTAL(svl));
                SvFLAGS(svl) |= SVf_BREAK;
                marked = TRUE;
            }
            else if (!marked) {
                /* don't check RH element if no SVf_BREAK flags set yet */
                if (!lcount)
                    break;
                continue;
            }
        }

        /* see if corresponding RH element needs copying */

        assert(marked);
        svr = *relem;
        assert(svr);

        if (UNLIKELY(SvFLAGS(svr) & (SVf_BREAK|SVs_GMG) || copy_all)) {

#ifdef DEBUGGING
            if (fake) {
                /* op_dump(PL_op); */
                Perl_croak(aTHX_
                    "panic: aassign skipped needed copy of common RH elem %"
                        UVuf, (UV)(relem - firstrelem));
            }
#endif

            TAINT_NOT;	/* Each item is independent */

            /* Dear TODO test in t/op/sort.t, I love you.
               (It's relying on a panic, not a "semi-panic" from newSVsv()
               and then an assertion failure below.)  */
            if (UNLIKELY(SvIS_FREED(svr))) {
                Perl_croak(aTHX_ "panic: attempt to copy freed scalar %p",
                           (void*)svr);
            }
            /* avoid break flag while copying; otherwise COW etc
             * disabled... */
            SvFLAGS(svr) &= ~SVf_BREAK;
            /* Not newSVsv(), as it does not allow copy-on-write,
               resulting in wasteful copies.
               Also, we use SV_NOSTEAL in case the SV is used more than
               once, e.g.  (...) = (f())[0,0]
               Where the same SV appears twice on the RHS without a ref
               count bump.  (Although I suspect that the SV won't be
               stealable here anyway - DAPM).
               */
            *relem = sv_mortalcopy_flags(svr,
                                SV_GMAGIC|SV_DO_COW_SVSETSV|SV_NOSTEAL);
            /* ... but restore afterwards in case it's needed again,
             * e.g. ($a,$b,$c) = (1,$a,$a)
             */
            SvFLAGS(svr) |= SVf_BREAK;
        }

        if (!lcount)
            break;
    }

    if (!marked)
        return;

    /*unmark LHS */

    while (lelem > firstlelem) {
        SV * const svl = *(--lelem);
        if (svl)
            SvFLAGS(svl) &= ~SVf_BREAK;
    }
}



d1001 1
a1001 1
    U8 gimme;
d1005 1
a1005 7
    U32 lval;
    /* PL_delaymagic is restored by JUMPENV_POP on dieing, so we
     * only need to save locally, not on the save stack */
    U16 old_delaymagic = PL_delaymagic;
#ifdef DEBUGGING
    bool fake = 0;
#endif
d1008 3
d1015 1
d1018 29
a1046 42
    /* at least 2 LH and RH elements, or commonality isn't an issue */
    if (firstlelem < lastlelem && firstrelem < lastrelem) {
        for (relem = firstrelem+1; relem <= lastrelem; relem++) {
            if (SvGMAGICAL(*relem))
                goto do_scan;
        }
        for (lelem = firstlelem; lelem <= lastlelem; lelem++) {
            if (*lelem && SvSMAGICAL(*lelem))
                goto do_scan;
        }
        if ( PL_op->op_private & (OPpASSIGN_COMMON_SCALAR|OPpASSIGN_COMMON_RC1) ) {
            if (PL_op->op_private & OPpASSIGN_COMMON_RC1) {
                /* skip the scan if all scalars have a ref count of 1 */
                for (lelem = firstlelem; lelem <= lastlelem; lelem++) {
                    sv = *lelem;
                    if (!sv || SvREFCNT(sv) == 1)
                        continue;
                    if (SvTYPE(sv) != SVt_PVAV && SvTYPE(sv) != SVt_PVAV)
                        goto do_scan;
                    break;
                }
            }
            else {
            do_scan:
                S_aassign_copy_common(aTHX_
                                      firstlelem, lastlelem, firstrelem, lastrelem
#ifdef DEBUGGING
                    , fake
#endif
                );
            }
        }
    }
#ifdef DEBUGGING
    else {
        /* on debugging builds, do the scan even if we've concluded we
         * don't need to, then panic if we find commonality. Note that the
         * scanner assumes at least 2 elements */
        if (firstlelem < lastlelem && firstrelem < lastrelem) {
            fake = 1;
            goto do_scan;
        }
a1047 4
#endif

    gimme = GIMME_V;
    lval = (gimme == G_ARRAY) ? (PL_op->op_flags & OPf_MOD || LVRET) : 0;
a1054 1
	bool alias = FALSE;
a1056 5
	if (UNLIKELY(!sv)) {
	    alias = TRUE;
	    sv = *lelem++;
	    ASSUME(SvTYPE(sv) == SVt_PVAV);
	}
d1058 1
a1058 2
	case SVt_PVAV: {
            bool already_copied = FALSE;
d1063 2
a1064 32

            /* We need to clear ary. The is a danger that if we do this,
             * elements on the RHS may be prematurely freed, e.g.
             *   @@a = ($a[0]);
             * In the case of possible commonality, make a copy of each
             * RHS SV *before* clearing the array, and add a reference
             * from the tmps stack, so that it doesn't leak on death.
             * Otherwise, make a copy of each RHS SV only as we're storing
             * it into the array - that way we don't have to worry about
             * it being leaked if we die, but don't incur the cost of
             * mortalising everything.
             */

            if (   (PL_op->op_private & OPpASSIGN_COMMON_AGG)
                && (relem <= lastrelem)
                && (magic || AvFILL(ary) != -1))
            {
                SV **svp;
                EXTEND_MORTAL(lastrelem - relem + 1);
                for (svp = relem; svp <= lastrelem; svp++) {
                    /* see comment in S_aassign_copy_common about SV_NOSTEAL */
                    *svp = sv_mortalcopy_flags(*svp,
                            SV_GMAGIC|SV_DO_COW_SVSETSV|SV_NOSTEAL);
                    TAINT_NOT;
                }
                already_copied = TRUE;
            }

            av_clear(ary);
	    if (relem <= lastrelem)
                av_extend(ary, lastrelem - relem);

d1068 5
a1072 32
		if (LIKELY(!alias)) {
                    if (already_copied)
                        sv = *relem;
                    else {
                        if (LIKELY(*relem))
                            /* before newSV, in case it dies */
                            SvGETMAGIC(*relem);
                        sv = newSV(0);
                        /* see comment in S_aassign_copy_common about
                         * SV_NOSTEAL */
                        sv_setsv_flags(sv, *relem,
                                    (SV_DO_COW_SVSETSV|SV_NOSTEAL));
                        *relem = sv;
                    }
		}
		else {
                    if (!already_copied)
                        SvGETMAGIC(*relem);
		    if (!SvROK(*relem))
			DIE(aTHX_ "Assigned value is not a reference");
		    if (SvTYPE(SvRV(*relem)) > SVt_PVLV)
		   /* diag_listed_as: Assigned value is not %s reference */
			DIE(aTHX_
			   "Assigned value is not a SCALAR reference");
		    if (lval && !already_copied)
			*relem = sv_mortalcopy(*relem);
		    /* XXX else check for weak refs?  */
		    sv = SvREFCNT_inc_NN(SvRV(*relem));
		}
		relem++;
                if (already_copied)
                    SvREFCNT_inc_simple_void_NN(sv); /* undo mortal free */
a1085 2
        }

a1091 1
                bool already_copied = FALSE;
a1105 23

                /* We need to clear hash. The is a danger that if we do this,
                 * elements on the RHS may be prematurely freed, e.g.
                 *   %h = (foo => $h{bar});
                 * In the case of possible commonality, make a copy of each
                 * RHS SV *before* clearing the hash, and add a reference
                 * from the tmps stack, so that it doesn't leak on death.
                 */

                if (   (PL_op->op_private & OPpASSIGN_COMMON_AGG)
                    && (relem <= lastrelem)
                    && (magic || HvUSEDKEYS(hash)))
                {
                    SV **svp;
                    EXTEND_MORTAL(lastrelem - relem + 1);
                    for (svp = relem; svp <= lastrelem; svp++) {
                        *svp = sv_mortalcopy_flags(*svp,
                                SV_GMAGIC|SV_DO_COW_SVSETSV|SV_NOSTEAL);
                        TAINT_NOT;
                    }
                    already_copied = TRUE;
                }

a1106 1

d1114 1
a1114 1
		    sv = (lval || SvGMAGICAL(*relem)) && !already_copied
d1119 3
a1121 8
                    if (already_copied)
                        tmpstr = *relem++;
                    else {
                        SvGETMAGIC(*relem);
                        tmpstr = newSV(0);
                        sv_setsv_nomg(tmpstr,*relem++);	/* value */
                    }

a1133 2
                    if (already_copied)
                        SvREFCNT_inc_simple_void_NN(tmpstr); /* undo mortal free */
d1271 1
a1271 1
    PL_delaymagic = old_delaymagic;
d1298 1
a1298 1
    dSP;
d1338 1
a1338 1
    dSP; dTARG;
d1349 1
a1349 1
    const U8 gimme = GIMME_V;
d1357 1
a1357 1
    else if (ARGTARG)
d1516 1
a1516 1
    NOT_REACHED; /* NOTREACHED */
d1518 1
a1518 1
  nope:
d1534 1
a1534 1
    dSP; dTARGETSTACKED;
d1541 1
a1541 1
    const U8 gimme = GIMME_V;
d1572 1
a1572 1
		fp = nextargv(PL_last_in_gv, PL_op->op_flags & OPf_SPECIAL);
d1596 2
a1597 1
		sv_setsv(TARG,NULL);
d1659 1
a1659 1
		fp = nextargv(PL_last_in_gv, PL_op->op_flags & OPf_SPECIAL);
a1690 1
	    Stat_t statbuf;
d1706 1
a1706 1
	    if (*t1 && PerlLIO_lstat(SvPVX_const(sv), &statbuf) < 0) {
d1742 1
a1742 1
    dSP;
d1782 1
a1782 1
	    LvTARG(lv) = SvREFCNT_inc_simple_NN(hv);
d1820 6
d1827 3
a1829 2
/* a stripped-down version of Perl_softref2xv() for use by
 * pp_multideref(), which doesn't use PL_op->op_flags */
d1831 1
a1831 15
STATIC GV *
S_softref2xv_lite(pTHX_ SV *const sv, const char *const what,
		const svtype type)
{
    if (PL_op->op_private & HINT_STRICT_REFS) {
	if (SvOK(sv))
	    Perl_die(aTHX_ PL_no_symref_sv, sv,
		     (SvPOKp(sv) && SvCUR(sv)>32 ? "..." : ""), what);
	else
	    Perl_die(aTHX_ PL_no_usym, what);
    }
    if (!SvOK(sv))
        Perl_die(aTHX_ PL_no_usym, what);
    return gv_fetchsv_nomg(sv, GV_ADD, type);
}
d1833 10
d1844 19
a1862 41
/* Handle one or more aggregate derefs and array/hash indexings, e.g.
 * $h->{foo}  or  $a[0]{$key}[$i]  or  f()->[1]
 *
 * op_aux points to an array of unions of UV / IV / SV* / PADOFFSET.
 * Each of these either contains a set of actions, or an argument, such as
 * an IV to use as an array index, or a lexical var to retrieve.
 * Several actions re stored per UV; we keep shifting new actions off the
 * one UV, and only reload when it becomes zero.
 */

PP(pp_multideref)
{
    SV *sv = NULL; /* init to avoid spurious 'may be used uninitialized' */
    UNOP_AUX_item *items = cUNOP_AUXx(PL_op)->op_aux;
    UV actions = items->uv;

    assert(actions);
    /* this tells find_uninit_var() where we're up to */
    PL_multideref_pc = items;

    while (1) {
        /* there are three main classes of action; the first retrieve
         * the initial AV or HV from a variable or the stack; the second
         * does the equivalent of an unrolled (/DREFAV, rv2av, aelem),
         * the third an unrolled (/DREFHV, rv2hv, helem).
         */
        switch (actions & MDEREF_ACTION_MASK) {

        case MDEREF_reload:
            actions = (++items)->uv;
            continue;

        case MDEREF_AV_padav_aelem:                 /* $lex[...] */
            sv = PAD_SVl((++items)->pad_offset);
            goto do_AV_aelem;

        case MDEREF_AV_gvav_aelem:                  /* $pkg[...] */
            sv = UNOP_AUX_item_sv(++items);
            assert(isGV_with_GP(sv));
            sv = (SV*)GvAVn((GV*)sv);
            goto do_AV_aelem;
d1864 5
a1868 7
        case MDEREF_AV_pop_rv2av_aelem:             /* expr->[...] */
            {
                dSP;
                sv = POPs;
                PUTBACK;
                goto do_AV_rv2av_aelem;
            }
d1870 14
a1883 35
        case MDEREF_AV_gvsv_vivify_rv2av_aelem:     /* $pkg->[...] */
            sv = UNOP_AUX_item_sv(++items);
            assert(isGV_with_GP(sv));
            sv = GvSVn((GV*)sv);
            goto do_AV_vivify_rv2av_aelem;

        case MDEREF_AV_padsv_vivify_rv2av_aelem:     /* $lex->[...] */
            sv = PAD_SVl((++items)->pad_offset);
            /* FALLTHROUGH */

        do_AV_vivify_rv2av_aelem:
        case MDEREF_AV_vivify_rv2av_aelem:           /* vivify, ->[...] */
            /* this is the OPpDEREF action normally found at the end of
             * ops like aelem, helem, rv2sv */
            sv = vivify_ref(sv, OPpDEREF_AV);
            /* FALLTHROUGH */

        do_AV_rv2av_aelem:
            /* this is basically a copy of pp_rv2av when it just has the
             * sKR/1 flags */
            SvGETMAGIC(sv);
            if (LIKELY(SvROK(sv))) {
                if (UNLIKELY(SvAMAGIC(sv))) {
                    sv = amagic_deref_call(sv, to_av_amg);
                }
                sv = SvRV(sv);
                if (UNLIKELY(SvTYPE(sv) != SVt_PVAV))
                    DIE(aTHX_ "Not an ARRAY reference");
            }
            else if (SvTYPE(sv) != SVt_PVAV) {
                if (!isGV_with_GP(sv))
                    sv = (SV*)S_softref2xv_lite(aTHX_ sv, "an ARRAY", SVt_PVAV);
                sv = MUTABLE_SV(GvAVn((GV*)sv));
            }
            /* FALLTHROUGH */
d1885 7
a1891 41
        do_AV_aelem:
            {
                /* retrieve the key; this may be either a lexical or package
                 * var (whose index/ptr is stored as an item) or a signed
                 * integer constant stored as an item.
                 */
                SV *elemsv;
                IV elem = 0; /* to shut up stupid compiler warnings */


                assert(SvTYPE(sv) == SVt_PVAV);

                switch (actions & MDEREF_INDEX_MASK) {
                case MDEREF_INDEX_none:
                    goto finish;
                case MDEREF_INDEX_const:
                    elem  = (++items)->iv;
                    break;
                case MDEREF_INDEX_padsv:
                    elemsv = PAD_SVl((++items)->pad_offset);
                    goto check_elem;
                case MDEREF_INDEX_gvsv:
                    elemsv = UNOP_AUX_item_sv(++items);
                    assert(isGV_with_GP(elemsv));
                    elemsv = GvSVn((GV*)elemsv);
                check_elem:
                    if (UNLIKELY(SvROK(elemsv) && !SvGAMAGIC(elemsv)
                                            && ckWARN(WARN_MISC)))
                        Perl_warner(aTHX_ packWARN(WARN_MISC),
                                "Use of reference \"%"SVf"\" as array index",
                                SVfARG(elemsv));
                    /* the only time that S_find_uninit_var() needs this
                     * is to determine which index value triggered the
                     * undef warning. So just update it here. Note that
                     * since we don't save and restore this var (e.g. for
                     * tie or overload execution), its value will be
                     * meaningless apart from just here */
                    PL_multideref_pc = items;
                    elem = SvIV(elemsv);
                    break;
                }
d1893 2
d1896 19
a1914 1
                /* this is basically a copy of pp_aelem with OPpDEREF skipped */
d1916 3
a1918 410
                if (!(actions & MDEREF_FLAG_last)) {
                    SV** svp = av_fetch((AV*)sv, elem, 1);
                    if (!svp || ! (sv=*svp))
                        DIE(aTHX_ PL_no_aelem, elem);
                    break;
                }

                if (PL_op->op_private &
                    (OPpMULTIDEREF_EXISTS|OPpMULTIDEREF_DELETE))
                {
                    if (PL_op->op_private & OPpMULTIDEREF_EXISTS) {
                        sv = av_exists((AV*)sv, elem) ? &PL_sv_yes : &PL_sv_no;
                    }
                    else {
                        I32 discard = (GIMME_V == G_VOID) ? G_DISCARD : 0;
                        sv = av_delete((AV*)sv, elem, discard);
                        if (discard)
                            return NORMAL;
                        if (!sv)
                            sv = &PL_sv_undef;
                    }
                }
                else {
                    const U32 lval = PL_op->op_flags & OPf_MOD || LVRET;
                    const U32 defer = PL_op->op_private & OPpLVAL_DEFER;
                    const bool localizing = PL_op->op_private & OPpLVAL_INTRO;
                    bool preeminent = TRUE;
                    AV *const av = (AV*)sv;
                    SV** svp;

                    if (UNLIKELY(localizing)) {
                        MAGIC *mg;
                        HV *stash;

                        /* If we can determine whether the element exist,
                         * Try to preserve the existenceness of a tied array
                         * element by using EXISTS and DELETE if possible.
                         * Fallback to FETCH and STORE otherwise. */
                        if (SvCANEXISTDELETE(av))
                            preeminent = av_exists(av, elem);
                    }

                    svp = av_fetch(av, elem, lval && !defer);

                    if (lval) {
                        if (!svp || !(sv = *svp)) {
                            IV len;
                            if (!defer)
                                DIE(aTHX_ PL_no_aelem, elem);
                            len = av_tindex(av);
                            sv = sv_2mortal(newSVavdefelem(av,
                            /* Resolve a negative index now, unless it points
                             * before the beginning of the array, in which
                             * case record it for error reporting in
                             * magic_setdefelem. */
                                elem < 0 && len + elem >= 0
                                    ? len + elem : elem, 1));
                        }
                        else {
                            if (UNLIKELY(localizing)) {
                                if (preeminent) {
                                    save_aelem(av, elem, svp);
                                    sv = *svp; /* may have changed */
                                }
                                else
                                    SAVEADELETE(av, elem);
                            }
                        }
                    }
                    else {
                        sv = (svp ? *svp : &PL_sv_undef);
                        /* see note in pp_helem() */
                        if (SvRMAGICAL(av) && SvGMAGICAL(sv))
                            mg_get(sv);
                    }
                }

            }
          finish:
            {
                dSP;
                XPUSHs(sv);
                RETURN;
            }
            /* NOTREACHED */




        case MDEREF_HV_padhv_helem:                 /* $lex{...} */
            sv = PAD_SVl((++items)->pad_offset);
            goto do_HV_helem;

        case MDEREF_HV_gvhv_helem:                  /* $pkg{...} */
            sv = UNOP_AUX_item_sv(++items);
            assert(isGV_with_GP(sv));
            sv = (SV*)GvHVn((GV*)sv);
            goto do_HV_helem;

        case MDEREF_HV_pop_rv2hv_helem:             /* expr->{...} */
            {
                dSP;
                sv = POPs;
                PUTBACK;
                goto do_HV_rv2hv_helem;
            }

        case MDEREF_HV_gvsv_vivify_rv2hv_helem:     /* $pkg->{...} */
            sv = UNOP_AUX_item_sv(++items);
            assert(isGV_with_GP(sv));
            sv = GvSVn((GV*)sv);
            goto do_HV_vivify_rv2hv_helem;

        case MDEREF_HV_padsv_vivify_rv2hv_helem:    /* $lex->{...} */
            sv = PAD_SVl((++items)->pad_offset);
            /* FALLTHROUGH */

        do_HV_vivify_rv2hv_helem:
        case MDEREF_HV_vivify_rv2hv_helem:           /* vivify, ->{...} */
            /* this is the OPpDEREF action normally found at the end of
             * ops like aelem, helem, rv2sv */
            sv = vivify_ref(sv, OPpDEREF_HV);
            /* FALLTHROUGH */

        do_HV_rv2hv_helem:
            /* this is basically a copy of pp_rv2hv when it just has the
             * sKR/1 flags (and pp_rv2hv is aliased to pp_rv2av) */

            SvGETMAGIC(sv);
            if (LIKELY(SvROK(sv))) {
                if (UNLIKELY(SvAMAGIC(sv))) {
                    sv = amagic_deref_call(sv, to_hv_amg);
                }
                sv = SvRV(sv);
                if (UNLIKELY(SvTYPE(sv) != SVt_PVHV))
                    DIE(aTHX_ "Not a HASH reference");
            }
            else if (SvTYPE(sv) != SVt_PVHV) {
                if (!isGV_with_GP(sv))
                    sv = (SV*)S_softref2xv_lite(aTHX_ sv, "a HASH", SVt_PVHV);
                sv = MUTABLE_SV(GvHVn((GV*)sv));
            }
            /* FALLTHROUGH */

        do_HV_helem:
            {
                /* retrieve the key; this may be either a lexical / package
                 * var or a string constant, whose index/ptr is stored as an
                 * item
                 */
                SV *keysv = NULL; /* to shut up stupid compiler warnings */

                assert(SvTYPE(sv) == SVt_PVHV);

                switch (actions & MDEREF_INDEX_MASK) {
                case MDEREF_INDEX_none:
                    goto finish;

                case MDEREF_INDEX_const:
                    keysv = UNOP_AUX_item_sv(++items);
                    break;

                case MDEREF_INDEX_padsv:
                    keysv = PAD_SVl((++items)->pad_offset);
                    break;

                case MDEREF_INDEX_gvsv:
                    keysv = UNOP_AUX_item_sv(++items);
                    keysv = GvSVn((GV*)keysv);
                    break;
                }

                /* see comment above about setting this var */
                PL_multideref_pc = items;


                /* ensure that candidate CONSTs have been HEKified */
                assert(   ((actions & MDEREF_INDEX_MASK) != MDEREF_INDEX_const)
                       || SvTYPE(keysv) >= SVt_PVMG
                       || !SvOK(keysv)
                       || SvROK(keysv)
                       || SvIsCOW_shared_hash(keysv));

                /* this is basically a copy of pp_helem with OPpDEREF skipped */

                if (!(actions & MDEREF_FLAG_last)) {
                    HE *he = hv_fetch_ent((HV*)sv, keysv, 1, 0);
                    if (!he || !(sv=HeVAL(he)) || sv == &PL_sv_undef)
                        DIE(aTHX_ PL_no_helem_sv, SVfARG(keysv));
                    break;
                }

                if (PL_op->op_private &
                    (OPpMULTIDEREF_EXISTS|OPpMULTIDEREF_DELETE))
                {
                    if (PL_op->op_private & OPpMULTIDEREF_EXISTS) {
                        sv = hv_exists_ent((HV*)sv, keysv, 0)
                                                ? &PL_sv_yes : &PL_sv_no;
                    }
                    else {
                        I32 discard = (GIMME_V == G_VOID) ? G_DISCARD : 0;
                        sv = hv_delete_ent((HV*)sv, keysv, discard, 0);
                        if (discard)
                            return NORMAL;
                        if (!sv)
                            sv = &PL_sv_undef;
                    }
                }
                else {
                    const U32 lval = PL_op->op_flags & OPf_MOD || LVRET;
                    const U32 defer = PL_op->op_private & OPpLVAL_DEFER;
                    const bool localizing = PL_op->op_private & OPpLVAL_INTRO;
                    bool preeminent = TRUE;
                    SV **svp;
                    HV * const hv = (HV*)sv;
                    HE* he;

                    if (UNLIKELY(localizing)) {
                        MAGIC *mg;
                        HV *stash;

                        /* If we can determine whether the element exist,
                         * Try to preserve the existenceness of a tied hash
                         * element by using EXISTS and DELETE if possible.
                         * Fallback to FETCH and STORE otherwise. */
                        if (SvCANEXISTDELETE(hv))
                            preeminent = hv_exists_ent(hv, keysv, 0);
                    }

                    he = hv_fetch_ent(hv, keysv, lval && !defer, 0);
                    svp = he ? &HeVAL(he) : NULL;


                    if (lval) {
                        if (!svp || !(sv = *svp) || sv == &PL_sv_undef) {
                            SV* lv;
                            SV* key2;
                            if (!defer)
                                DIE(aTHX_ PL_no_helem_sv, SVfARG(keysv));
                            lv = sv_newmortal();
                            sv_upgrade(lv, SVt_PVLV);
                            LvTYPE(lv) = 'y';
                            sv_magic(lv, key2 = newSVsv(keysv),
                                                PERL_MAGIC_defelem, NULL, 0);
                            /* sv_magic() increments refcount */
                            SvREFCNT_dec_NN(key2);
                            LvTARG(lv) = SvREFCNT_inc_simple_NN(hv);
                            LvTARGLEN(lv) = 1;
                            sv = lv;
                        }
                        else {
                            if (localizing) {
                                if (HvNAME_get(hv) && isGV(sv))
                                    save_gp(MUTABLE_GV(sv),
                                        !(PL_op->op_flags & OPf_SPECIAL));
                                else if (preeminent) {
                                    save_helem_flags(hv, keysv, svp,
                                         (PL_op->op_flags & OPf_SPECIAL)
                                            ? 0 : SAVEf_SETMAGIC);
                                    sv = *svp; /* may have changed */
                                }
                                else
                                    SAVEHDELETE(hv, keysv);
                            }
                        }
                    }
                    else {
                        sv = (svp && *svp ? *svp : &PL_sv_undef);
                        /* see note in pp_helem() */
                        if (SvRMAGICAL(hv) && SvGMAGICAL(sv))
                            mg_get(sv);
                    }
                }
                goto finish;
            }

        } /* switch */

        actions >>= MDEREF_SHIFT;
    } /* while */
    /* NOTREACHED */
}


PP(pp_iter)
{
    PERL_CONTEXT *cx;
    SV *oldsv;
    SV **itersvp;
    SV *retsv;

    SV *sv;
    AV *av;
    IV ix;
    IV inc;

    cx = CX_CUR();
    itersvp = CxITERVAR(cx);
    assert(itersvp);

    switch (CxTYPE(cx)) {

    case CXt_LOOP_LAZYSV: /* string increment */
    {
        SV* cur = cx->blk_loop.state_u.lazysv.cur;
        SV *end = cx->blk_loop.state_u.lazysv.end;
        /* If the maximum is !SvOK(), pp_enteriter substitutes PL_sv_no.
           It has SvPVX of "" and SvCUR of 0, which is what we want.  */
        STRLEN maxlen = 0;
        const char *max = SvPV_const(end, maxlen);
        if (UNLIKELY(SvNIOK(cur) || SvCUR(cur) > maxlen))
            goto retno;

        oldsv = *itersvp;
        /* NB: on the first iteration, oldsv will have a ref count of at
         * least 2 (one extra from blk_loop.itersave), so the GV or pad
         * slot will get localised; on subsequent iterations the RC==1
         * optimisation may kick in and the SV will be reused. */
         if (oldsv && LIKELY(SvREFCNT(oldsv) == 1 && !SvMAGICAL(oldsv))) {
            /* safe to reuse old SV */
            sv_setsv(oldsv, cur);
        }
        else
        {
            /* we need a fresh SV every time so that loop body sees a
             * completely new SV for closures/references to work as
             * they used to */
            *itersvp = newSVsv(cur);
            SvREFCNT_dec(oldsv);
        }
        if (strEQ(SvPVX_const(cur), max))
            sv_setiv(cur, 0); /* terminate next time */
        else
            sv_inc(cur);
        break;
    }

    case CXt_LOOP_LAZYIV: /* integer increment */
    {
        IV cur = cx->blk_loop.state_u.lazyiv.cur;
	if (UNLIKELY(cur > cx->blk_loop.state_u.lazyiv.end))
	    goto retno;

        oldsv = *itersvp;
	/* see NB comment above */
	if (oldsv && LIKELY(SvREFCNT(oldsv) == 1 && !SvMAGICAL(oldsv))) {
	    /* safe to reuse old SV */

            if (    (SvFLAGS(oldsv) & (SVTYPEMASK|SVf_THINKFIRST|SVf_IVisUV))
                 == SVt_IV)
            {
                /* Cheap SvIOK_only().
                 * Assert that flags which SvIOK_only() would test or
                 * clear can't be set, because we're SVt_IV */
                assert(!(SvFLAGS(oldsv) &
                    (SVf_OOK|SVf_UTF8|(SVf_OK & ~(SVf_IOK|SVp_IOK)))));
                SvFLAGS(oldsv) |= (SVf_IOK|SVp_IOK);
                /* SvIV_set() where sv_any points to head */
                oldsv->sv_u.svu_iv = cur;

            }
            else
                sv_setiv(oldsv, cur);
	}
	else
	{
	    /* we need a fresh SV every time so that loop body sees a
	     * completely new SV for closures/references to work as they
	     * used to */
	    *itersvp = newSViv(cur);
	    SvREFCNT_dec(oldsv);
	}

	if (UNLIKELY(cur == IV_MAX)) {
	    /* Handle end of range at IV_MAX */
	    cx->blk_loop.state_u.lazyiv.end = IV_MIN;
	} else
	    ++cx->blk_loop.state_u.lazyiv.cur;
        break;
    }

    case CXt_LOOP_LIST: /* for (1,2,3) */

        assert(OPpITER_REVERSED == 2); /* so inc becomes -1 or 1 */
        inc = 1 - (PL_op->op_private & OPpITER_REVERSED);
        ix = (cx->blk_loop.state_u.stack.ix += inc);
        if (UNLIKELY(inc > 0
                        ? ix > cx->blk_oldsp
                        : ix <= cx->blk_loop.state_u.stack.basesp)
        )
            goto retno;

        sv = PL_stack_base[ix];
        av = NULL;
        goto loop_ary_common;

    case CXt_LOOP_ARY: /* for (@@ary) */

        av = cx->blk_loop.state_u.ary.ary;
        inc = 1 - (PL_op->op_private & OPpITER_REVERSED);
        ix = (cx->blk_loop.state_u.ary.ix += inc);
        if (UNLIKELY(inc > 0
                        ? ix > AvFILL(av)
                        : ix < 0)
        )
            goto retno;

        if (UNLIKELY(SvRMAGICAL(av))) {
            SV * const * const svp = av_fetch(av, ix, FALSE);
            sv = svp ? *svp : NULL;
a1923 7
      loop_ary_common:

        if (UNLIKELY(cx->cx_type & CXp_FOR_LVREF)) {
            SvSetMagicSV(*itersvp, sv);
            break;
        }

d1930 1
d1938 1
a1938 1
        else if (av) {
d1948 1
d1953 1
a1953 11

    retsv = &PL_sv_yes;
    if (0) {
      retno:
        retsv = &PL_sv_no;
    }
    /* pp_enteriter should have pre-extended the stack */
    assert(PL_stack_sp < PL_stack_max);
    *++PL_stack_sp =retsv;

    return PL_op->op_next;
d2026 1
a2026 1
    dSP; dTARG;
d2033 2
a2034 2
    SSize_t iters = 0;
    SSize_t maxiters;
d2047 1
a2047 1
    bool was_cow;
d2057 1
a2057 1
    else if (ARGTARG)
d2066 6
a2071 7
    /* note that a string might get converted to COW during matching */
    was_cow = cBOOL(SvIsCOW(TARG));
#endif
    if (!(rpm->op_pmflags & PMf_NONDESTRUCT)) {
#ifndef PERL_ANY_COW
	if (SvIsCOW(TARG))
	    sv_force_normal_flags(TARG,0);
d2073 6
a2078 6
	if ((SvREADONLY(TARG)
		|| ( ((SvTYPE(TARG) == SVt_PVGV && isGV_with_GP(TARG))
		      || SvTYPE(TARG) > SVt_PVLV)
		     && !(SvTYPE(TARG) == SVt_PVGV && SvFAKE(TARG)))))
	    Perl_croak_no_modify();
    }
d2083 1
a2083 1
     * to match, we leave as-is; on successful match however, we *will*
d2145 2
a2146 2
	     if (IN_ENCODING)
		  sv_recode_to_utf8(nsv, _get_encoding());
d2168 1
a2168 1
	&& !was_cow
a2180 1
        /* string might have got converted to COW since we set was_cow */
d2258 1
a2258 1
	    mPUSHi(iters);
d2298 1
a2298 1
	    CX_PUSHSUBST(cx);
d2326 1
a2326 1
		if (IN_ENCODING) {
d2329 1
a2329 1
		    if (!DO_UTF8(nsv)) sv_recode_to_utf8(nsv, _get_encoding());
d2338 1
a2338 2
	} while (CALLREGEXEC(rx, s, strend, orig,
                             s == m,    /* Yields minend of 0 or 1 */
a2340 1
        assert(strend >= s);
d2370 1
a2370 1
	    mPUSHi(iters);
d2407 1
a2407 1
    dSP;
d2418 1
a2418 1
	const U8 gimme = GIMME_V;
d2426 6
d2434 1
d2446 1
a2446 1
	src = PL_stack_base[TOPMARK];
d2448 2
a2449 1
	    src = PL_stack_base[TOPMARK] = sv_mortalcopy(src);
d2453 4
a2456 1
	DEFSV_set(src);
a2461 325
/* leave_adjust_stacks():
 *
 * Process a scope's return args (in the range from_sp+1 .. PL_stack_sp),
 * positioning them at to_sp+1 onwards, and do the equivalent of a
 * FREEMPS and TAINT_NOT.
 *
 * Not intended to be called in void context.
 *
 * When leaving a sub, eval, do{} or other scope, the things that need
 * doing to process the return args are:
 *    * in scalar context, only return the last arg (or PL_sv_undef if none);
 *    * for the types of return that return copies of their args (such
 *      as rvalue sub return), make a mortal copy of every return arg,
 *      except where we can optimise the copy away without it being
 *      semantically visible;
 *    * make sure that the arg isn't prematurely freed; in the case of an
 *      arg not copied, this may involve mortalising it. For example, in
 *      C<sub f { my $x = ...; $x }>, $x would be freed when we do
 *      CX_LEAVE_SCOPE(cx) unless it's protected or copied.
 *
 * What condition to use when deciding whether to pass the arg through
 * or make a copy, is determined by the 'pass' arg; its valid values are:
 *   0: rvalue sub/eval exit
 *   1: other rvalue scope exit
 *   2: :lvalue sub exit in rvalue context
 *   3: :lvalue sub exit in lvalue context and other lvalue scope exits
 *
 * There is a big issue with doing a FREETMPS. We would like to free any
 * temps created by the last statement which the sub executed, rather than
 * leaving them for the caller. In a situation where a sub call isn't
 * soon followed by a nextstate (e.g. nested recursive calls, a la
 * fibonacci()), temps can accumulate, causing memory and performance
 * issues.
 *
 * On the other hand, we don't want to free any TEMPs which are keeping
 * alive any return args that we skipped copying; nor do we wish to undo
 * any mortalising done here.
 *
 * The solution is to split the temps stack frame into two, with a cut
 * point delineating the two halves. We arrange that by the end of this
 * function, all the temps stack frame entries we wish to keep are in the
 * range  PL_tmps_floor+1.. tmps_base-1, while the ones to free now are in
 * the range  tmps_base .. PL_tmps_ix.  During the course of this
 * function, tmps_base starts off as PL_tmps_floor+1, then increases
 * whenever we find or create a temp that we know should be kept. In
 * general the stuff above tmps_base is undecided until we reach the end,
 * and we may need a sort stage for that.
 *
 * To determine whether a TEMP is keeping a return arg alive, every
 * arg that is kept rather than copied and which has the SvTEMP flag
 * set, has the flag temporarily unset, to mark it. At the end we scan
 * the temps stack frame above the cut for entries without SvTEMP and
 * keep them, while turning SvTEMP on again. Note that if we die before
 * the SvTEMPs flags are set again, its safe: at worst, subsequent use of
 * those SVs may be slightly less efficient.
 *
 * In practice various optimisations for some common cases mean we can
 * avoid most of the scanning and swapping about with the temps stack.
 */

void
Perl_leave_adjust_stacks(pTHX_ SV **from_sp, SV **to_sp, U8 gimme, int pass)
{
    dVAR;
    dSP;
    SSize_t tmps_base; /* lowest index into tmps stack that needs freeing now */
    SSize_t nargs;

    PERL_ARGS_ASSERT_LEAVE_ADJUST_STACKS;

    TAINT_NOT;

    if (gimme == G_ARRAY) {
        nargs = SP - from_sp;
        from_sp++;
    }
    else {
        assert(gimme == G_SCALAR);
        if (UNLIKELY(from_sp >= SP)) {
            /* no return args */
            assert(from_sp == SP);
            EXTEND(SP, 1);
            *++SP = &PL_sv_undef;
            to_sp = SP;
            nargs   = 0;
        }
        else {
            from_sp = SP;
            nargs   = 1;
        }
    }

    /* common code for G_SCALAR and G_ARRAY */

    tmps_base = PL_tmps_floor + 1;

    assert(nargs >= 0);
    if (nargs) {
        /* pointer version of tmps_base. Not safe across temp stack
         * reallocs. */
        SV **tmps_basep;

        EXTEND_MORTAL(nargs); /* one big extend for worst-case scenario */
        tmps_basep = PL_tmps_stack + tmps_base;

        /* process each return arg */

        do {
            SV *sv = *from_sp++;

            assert(PL_tmps_ix + nargs < PL_tmps_max);
#ifdef DEBUGGING
            /* PADTMPs with container set magic shouldn't appear in the
             * wild. This assert is more important for pp_leavesublv(),
             * but by testing for it here, we're more likely to catch
             * bad cases (what with :lvalue subs not being widely
             * deployed). The two issues are that for something like
             *     sub :lvalue { $tied{foo} }
             * or
             *     sub :lvalue { substr($foo,1,2) }
             * pp_leavesublv() will croak if the sub returns a PADTMP,
             * and currently functions like pp_substr() return a mortal
             * rather than using their PADTMP when returning a PVLV.
             * This is because the PVLV will hold a ref to $foo,
             * so $foo would get delayed in being freed while
             * the PADTMP SV remained in the PAD.
             * So if this assert fails it means either:
             *  1) there is pp code similar to pp_substr that is
             *     returning a PADTMP instead of a mortal, and probably
             *     needs fixing, or
             *  2) pp_leavesublv is making unwarranted assumptions
             *     about always croaking on a PADTMP
             */
            if (SvPADTMP(sv) && SvSMAGICAL(sv)) {
                MAGIC *mg;
                for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic) {
                    assert(PERL_MAGIC_TYPE_IS_VALUE_MAGIC(mg->mg_type));
                }
            }
#endif

            if (
               pass == 0 ? (SvTEMP(sv) && !SvMAGICAL(sv) && SvREFCNT(sv) == 1)
             : pass == 1 ? ((SvTEMP(sv) || SvPADTMP(sv)) && !SvMAGICAL(sv) && SvREFCNT(sv) == 1)
             : pass == 2 ? (!SvPADTMP(sv))
             : 1)
            {
                /* pass through: skip copy for logic or optimisation
                 * reasons; instead mortalise it, except that ... */
                *++to_sp = sv;

                if (SvTEMP(sv)) {
                    /* ... since this SV is an SvTEMP , we don't need to
                     * re-mortalise it; instead we just need to ensure
                     * that its existing entry in the temps stack frame
                     * ends up below the cut and so avoids being freed
                     * this time round. We mark it as needing to be kept
                     * by temporarily unsetting SvTEMP; then at the end,
                     * we shuffle any !SvTEMP entries on the tmps stack
                     * back below the cut.
                     * However, there's a significant chance that there's
                     * a 1:1 correspondence between the first few (or all)
                     * elements in the return args stack frame and those
                     * in the temps stack frame; e,g.:
                     *      sub f { ....; map {...} .... },
                     * or if we're exiting multiple scopes and one of the
                     * inner scopes has already made mortal copies of each
                     * return arg.
                     *
                     * If so, this arg sv will correspond to the next item
                     * on the tmps stack above the cut, and so can be kept
                     * merely by moving the cut boundary up one, rather
                     * than messing with SvTEMP.  If all args are 1:1 then
                     * we can avoid the sorting stage below completely.
                     *
                     * If there are no items above the cut on the tmps
                     * stack, then the SvTEMP must comne from an item
                     * below the cut, so there's nothing to do.
                     */
                    if (tmps_basep <= &PL_tmps_stack[PL_tmps_ix]) {
                        if (sv == *tmps_basep)
                            tmps_basep++;
                        else
                            SvTEMP_off(sv);
                    }
                }
                else if (!SvPADTMP(sv)) {
                    /* mortalise arg to avoid it being freed during save
                     * stack unwinding. Pad tmps don't need mortalising as
                     * they're never freed. This is the equivalent of
                     * sv_2mortal(SvREFCNT_inc(sv)), except that:
                     *  * it assumes that the temps stack has already been
                     *    extended;
                     *  * it puts the new item at the cut rather than at
                     *    ++PL_tmps_ix, moving the previous occupant there
                     *    instead.
                     */
                    if (!SvIMMORTAL(sv)) {
                        SvREFCNT_inc_simple_void_NN(sv);
                        SvTEMP_on(sv);
                        /* Note that if there's nothing above the cut,
                         * this copies the garbage one slot above
                         * PL_tmps_ix onto itself. This is harmless (the
                         * stack's already been extended), but might in
                         * theory trigger warnings from tools like ASan
                         */
                        PL_tmps_stack[++PL_tmps_ix] = *tmps_basep;
                        *tmps_basep++ = sv;
                    }
                }
            }
            else {
                /* Make a mortal copy of the SV.
                 * The following code is the equivalent of sv_mortalcopy()
                 * except that:
                 *  * it assumes the temps stack has already been extended;
                 *  * it optimises the copying for some simple SV types;
                 *  * it puts the new item at the cut rather than at
                 *    ++PL_tmps_ix, moving the previous occupant there
                 *    instead.
                 */
                SV *newsv = newSV(0);

                PL_tmps_stack[++PL_tmps_ix] = *tmps_basep;
                /* put it on the tmps stack early so it gets freed if we die */
                *tmps_basep++ = newsv;
                *++to_sp = newsv;

                if (SvTYPE(sv) <= SVt_IV) {
                    /* arg must be one of undef, IV/UV, or RV: skip
                     * sv_setsv_flags() and do the copy directly */
                    U32 dstflags;
                    U32 srcflags = SvFLAGS(sv);

                    assert(!SvGMAGICAL(sv));
                    if (srcflags & (SVf_IOK|SVf_ROK)) {
                        SET_SVANY_FOR_BODYLESS_IV(newsv);

                        if (srcflags & SVf_ROK) {
                            newsv->sv_u.svu_rv = SvREFCNT_inc(SvRV(sv));
                            /* SV type plus flags */
                            dstflags = (SVt_IV|SVf_ROK|SVs_TEMP);
                        }
                        else {
                            /* both src and dst are <= SVt_IV, so sv_any
                             * points to the head; so access the heads
                             * directly rather than going via sv_any.
                             */
                            assert(    &(sv->sv_u.svu_iv)
                                    == &(((XPVIV*) SvANY(sv))->xiv_iv));
                            assert(    &(newsv->sv_u.svu_iv)
                                    == &(((XPVIV*) SvANY(newsv))->xiv_iv));
                            newsv->sv_u.svu_iv = sv->sv_u.svu_iv;
                            /* SV type plus flags */
                            dstflags = (SVt_IV|SVf_IOK|SVp_IOK|SVs_TEMP
                                            |(srcflags & SVf_IVisUV));
                        }
                    }
                    else {
                        assert(!(srcflags & SVf_OK));
                        dstflags = (SVt_NULL|SVs_TEMP); /* SV type plus flags */
                    }
                    SvFLAGS(newsv) = dstflags;

                }
                else {
                    /* do the full sv_setsv() */
                    SSize_t old_base;

                    SvTEMP_on(newsv);
                    old_base = tmps_basep - PL_tmps_stack;
                    SvGETMAGIC(sv);
                    sv_setsv_flags(newsv, sv, SV_DO_COW_SVSETSV);
                    /* the mg_get or sv_setsv might have created new temps
                     * or realloced the tmps stack; regrow and reload */
                    EXTEND_MORTAL(nargs);
                    tmps_basep = PL_tmps_stack + old_base;
                    TAINT_NOT;	/* Each item is independent */
                }

            }
        } while (--nargs);

        /* If there are any temps left above the cut, we need to sort
         * them into those to keep and those to free. The only ones to
         * keep are those for which we've temporarily unset SvTEMP.
         * Work inwards from the two ends at tmps_basep .. PL_tmps_ix,
         * swapping pairs as necessary. Stop when we meet in the middle.
         */
        {
            SV **top = PL_tmps_stack + PL_tmps_ix;
            while (tmps_basep <= top) {
                SV *sv = *top;
                if (SvTEMP(sv))
                    top--;
                else {
                    SvTEMP_on(sv);
                    *top = *tmps_basep;
                    *tmps_basep = sv;
                    tmps_basep++;
                }
            }
        }

        tmps_base = tmps_basep - PL_tmps_stack;
    }

    PL_stack_sp = to_sp;

    /* unrolled FREETMPS() but using tmps_base-1 rather than PL_tmps_floor */
    while (PL_tmps_ix >= tmps_base) {
        SV* const sv = PL_tmps_stack[PL_tmps_ix--];
#ifdef PERL_POISON
        PoisonWith(PL_tmps_stack + PL_tmps_ix + 1, 1, SV *, 0xAB);
#endif
        if (LIKELY(sv)) {
            SvTEMP_off(sv);
            SvREFCNT_dec_NN(sv); /* note, can modify tmps_ix!!! */
        }
    }
}


/* also tail-called by pp_return */

d2464 5
a2468 1
    U8 gimme;
d2470 1
a2470 5
    SV **oldsp;
    OP *retop;

    cx = CX_CUR();
    assert(CxTYPE(cx) == CXt_SUB);
d2472 1
a2472 4
    if (CxMULTICALL(cx)) {
        /* entry zero of a stack is always PL_sv_undef, which
         * simplifies converting a '()' return into undef in scalar context */
        assert(PL_stack_sp > PL_stack_base || *PL_stack_base == &PL_sv_undef);
a2473 1
    }
d2475 2
a2476 2
    gimme = cx->blk_gimme;
    oldsp = PL_stack_base + cx->blk_oldsp; /* last arg of previous frame */
d2478 41
a2518 4
    if (gimme == G_VOID)
        PL_stack_sp = oldsp;
    else
        leave_adjust_stacks(oldsp, oldsp, gimme, 0);
d2520 4
a2523 5
    CX_LEAVE_SCOPE(cx);
    cx_popsub(cx);	/* Stack values are safe: release CV and @@_ ... */
    cx_popblock(cx);
    retop = cx->blk_sub.retop;
    CX_POP(cx);
d2525 2
a2526 1
    return retop;
a2528 25

/* clear (if possible) or abandon the current @@_. If 'abandon' is true,
 * forces an abandon */

void
Perl_clear_defarray(pTHX_ AV* av, bool abandon)
{
    const SSize_t fill = AvFILLp(av);

    PERL_ARGS_ASSERT_CLEAR_DEFARRAY;

    if (LIKELY(!abandon && SvREFCNT(av) == 1 && !SvMAGICAL(av))) {
        av_clear(av);
        AvREIFY_only(av);
    }
    else {
        AV *newav = newAV();
        av_extend(newav, fill);
        AvREIFY_only(newav);
        PAD_SVl(0) = MUTABLE_SV(newav);
        SvREFCNT_dec_NN(av);
    }
}


d2531 1
a2531 1
    dSP; dPOPss;
d2535 2
a2536 1
    I32 old_savestack_ix;
d2539 3
a2541 21
	goto do_die;

    /* Locate the CV to call:
     * - most common case: RV->CV: f(), $ref->():
     *   note that if a sub is compiled before its caller is compiled,
     *   the stash entry will be a ref to a CV, rather than being a GV.
     * - second most common case: CV: $ref->method()
     */

    /* a non-magic-RV -> CV ? */
    if (LIKELY( (SvFLAGS(sv) & (SVf_ROK|SVs_GMG)) == SVf_ROK)) {
        cv = MUTABLE_CV(SvRV(sv));
        if (UNLIKELY(SvOBJECT(cv))) /* might be overloaded */
            goto do_ref;
    }
    else
        cv = MUTABLE_CV(sv);

    /* a CV ? */
    if (UNLIKELY(SvTYPE(cv) != SVt_PVCV)) {
        /* handle all the weird cases */
a2542 4
        case SVt_PVLV:
            if (!isGV_with_GP(sv))
                goto do_default;
            /* FALLTHROUGH */
d2544 2
a2545 2
            cv = GvCVu((const GV *)sv);
            if (UNLIKELY(!cv)) {
d2548 5
a2552 4
                if (!cv) {
                    old_savestack_ix = PL_savestack_ix;
                    goto try_autoload;
                }
d2555 3
a2557 1

d2559 7
a2565 1
          do_default:
d2568 1
a2568 2
              do_ref:
                if (UNLIKELY(SvAMAGIC(sv))) {
d2576 1
a2576 1
                if (UNLIKELY(!SvOK(sv)))
a2577 11

                if (UNLIKELY(sv == &PL_sv_yes)) { /* unfound import, ignore */
                    if (PL_op->op_flags & OPf_STACKED) /* hasargs */
                        SP = PL_stack_base + POPMARK;
                    else
                        (void)POPMARK;
                    if (GIMME_V == G_SCALAR)
                        PUSHs(&PL_sv_undef);
                    RETURN;
                }

d2585 1
a2585 1
            if (LIKELY(SvTYPE(cv) == SVt_PVCV))
d2587 1
a2587 1
            /* FALLTHROUGH */
a2589 1
          do_die:
d2591 4
d2598 6
a2603 13
    /* At this point we want to save PL_savestack_ix, either by doing a
     * cx_pushsub(), or for XS, doing an ENTER. But we don't yet know the final
     * CV we will be using (so we don't know whether its XS, so we can't
     * cx_pushsub() or ENTER yet), and determining cv may itself push stuff on
     * the save stack. So remember where we are currently on the save
     * stack, and later update the CX or scopestack entry accordingly. */
    old_savestack_ix = PL_savestack_ix;

    /* these two fields are in a union. If they ever become separate,
     * we have to test for both of them being null below */
    assert(cv);
    assert((void*)&CvROOT(cv) == (void*)&CvXSUB(cv));
    while (UNLIKELY(!CvROOT(cv))) {
d2608 4
a2611 4
	if (CvLEXICAL(cv) && CvHASGV(cv))
	    DIE(aTHX_ "Undefined subroutine &%"SVf" called",
		       SVfARG(cv_name(cv, NULL, 0)));
	if (CvANON(cv) || !CvHASGV(cv)) {
d2616 1
a2616 1
	if (cv != GvCV(gv = CvGV(cv))) {
d2621 16
a2636 10
          try_autoload:
	    autogv = gv_autoload_pvn(GvSTASH(gv), GvNAME(gv), GvNAMELEN(gv),
				   GvNAMEUTF8(gv) ? SVf_UTF8 : 0);
            cv = autogv ? GvCV(autogv) : NULL;
	}
	if (!cv) {
            sub_name = sv_newmortal();
            gv_efullname3(sub_name, gv, NULL);
            DIE(aTHX_ "Undefined subroutine &%"SVf" called", SVfARG(sub_name));
        }
a2638 4
    /* unrolled "CvCLONE(cv) && ! CvCLONED(cv)" */
    if (UNLIKELY((CvFLAGS(cv) & (CVf_CLONE|CVf_CLONED)) == CVf_CLONE))
	DIE(aTHX_ "Closure prototype called");

d2658 2
d2663 1
a2663 1
	PADLIST *padlist;
a2664 24
        bool hasargs;
        U8 gimme;

        /* keep PADTMP args alive throughout the call (we need to do this
         * because @@_ isn't refcounted). Note that we create the mortals
         * in the caller's tmps frame, so they won't be freed until after
         * we return from the sub.
         */
	{
            SV **svp = MARK;
            while (svp < SP) {
                SV *sv = *++svp;
                if (!sv)
                    continue;
                if (SvPADTMP(sv))
                    *svp = sv = sv_mortalcopy(sv);
                SvTEMP_off(sv);
	    }
        }

        gimme = GIMME_V;
	cx = cx_pushblock(CXt_SUB, gimme, MARK, old_savestack_ix);
        hasargs = cBOOL(PL_op->op_flags & OPf_STACKED);
	cx_pushsub(cx, cv, PL_op->op_next, hasargs);
d2666 5
a2670 2
	padlist = CvPADLIST(cv);
	if (UNLIKELY((depth = ++CvDEPTH(cv)) >= 2))
d2672 2
d2680 7
d2690 3
a2693 6
            /* it's the responsibility of whoever leaves a sub to ensure
             * that a clean, empty AV is left in pad[0]. This is normally
             * done by cx_popsub() */
            assert(!AvREAL(av) && AvFILLp(av) == -1);

            items = SP - MARK;
d2704 13
d2718 1
d2721 1
a2721 2
            DIE(aTHX_ "Can't modify non-lvalue subroutine call of &%"SVf,
                SVfARG(cv_name(cv, NULL, 0)));
a2733 5
        bool is_scalar;

        ENTER;
        /* pretend we did the ENTER earlier */
	PL_scopestack[PL_scopestack_ix - 1] = old_savestack_ix;
d2739 1
a2739 1
	       & CX_PUSHSUB_GET_LVALUE_MASK(Perl_is_lvalue_sub)
d2742 1
a2742 2
            DIE(aTHX_ "Can't modify non-lvalue subroutine call of &%"SVf,
                SVfARG(cv_name(cv, NULL, 0)));
d2744 1
a2744 1
	if (UNLIKELY(!(PL_op->op_flags & OPf_STACKED) && GvAV(PL_defgv))) {
d2779 1
a2791 4
        /* calculate gimme here as PL_op might get changed and then not
         * restored until the LEAVE further down */
        is_scalar = (GIMME_V == G_SCALAR);

d2797 1
a2797 1
	if (is_scalar) {
d2817 9
d2827 1
a2827 1
		    SVfARG(cv_name(cv,NULL,0)));
d2833 1
a2833 1
    dSP;
d2944 29
a2972 2
PERL_STATIC_INLINE HV *
S_opmethod_stash(pTHX_ SV* meth)
d2974 1
d2976 1
d2978 2
a2979 2

    SV* const sv = PL_stack_base + TOPMARK == PL_stack_sp
d2985 1
a2985 1
    PERL_ARGS_ASSERT_OPMETHOD_STASH;
d2992 1
a2992 6
    if (UNLIKELY(SvGMAGICAL(sv))) mg_get(sv);
    else if (SvIsCOW_shared_hash(sv)) { /* MyClass->meth() */
	stash = gv_stashsv(sv, GV_CACHE_ONLY);
	if (stash) return stash;
    }

d3014 13
a3026 3
        const U32 packname_utf8 = SvUTF8(sv);
        stash = gv_stashpvn(packname, packlen, packname_utf8 | GV_CACHE_ONLY);
        if (stash) return stash;
d3029 1
a3029 1
	        packname, packlen, packname_utf8, SVt_PVIO
d3041 11
a3051 3
	    stash = gv_stashpvn(packname, packlen, packname_utf8);
	    if (stash) return stash;
	    else return MUTABLE_HV(sv);
d3069 1
a3069 2
    return SvSTASH(ob);
}
d3071 14
a3084 68
PP(pp_method)
{
    dSP;
    GV* gv;
    HV* stash;
    SV* const meth = TOPs;

    if (SvROK(meth)) {
        SV* const rmeth = SvRV(meth);
        if (SvTYPE(rmeth) == SVt_PVCV) {
            SETs(rmeth);
            RETURN;
        }
    }

    stash = opmethod_stash(meth);

    gv = gv_fetchmethod_sv_flags(stash, meth, GV_AUTOLOAD|GV_CROAK);
    assert(gv);

    SETs(isGV(gv) ? MUTABLE_SV(GvCV(gv)) : MUTABLE_SV(gv));
    RETURN;
}

#define METHOD_CHECK_CACHE(stash,cache,meth) 				\
    const HE* const he = hv_fetch_ent(cache, meth, 0, 0);		\
    if (he) {								\
        gv = MUTABLE_GV(HeVAL(he));					\
        if (isGV(gv) && GvCV(gv) && (!GvCVGEN(gv) || GvCVGEN(gv)	\
             == (PL_sub_generation + HvMROMETA(stash)->cache_gen)))	\
        {								\
            XPUSHs(MUTABLE_SV(GvCV(gv)));				\
            RETURN;							\
        }								\
    }									\

PP(pp_method_named)
{
    dSP;
    GV* gv;
    SV* const meth = cMETHOPx_meth(PL_op);
    HV* const stash = opmethod_stash(meth);

    if (LIKELY(SvTYPE(stash) == SVt_PVHV)) {
        METHOD_CHECK_CACHE(stash, stash, meth);
    }

    gv = gv_fetchmethod_sv_flags(stash, meth, GV_AUTOLOAD|GV_CROAK);
    assert(gv);

    XPUSHs(isGV(gv) ? MUTABLE_SV(GvCV(gv)) : MUTABLE_SV(gv));
    RETURN;
}

PP(pp_method_super)
{
    dSP;
    GV* gv;
    HV* cache;
    SV* const meth = cMETHOPx_meth(PL_op);
    HV* const stash = CopSTASH(PL_curcop);
    /* Actually, SUPER doesn't need real object's (or class') stash at all,
     * as it uses CopSTASH. However, we must ensure that object(class) is
     * correct (this check is done by S_opmethod_stash) */
    opmethod_stash(meth);

    if ((cache = HvMROMETA(stash)->super)) {
        METHOD_CHECK_CACHE(stash, cache, meth);
d3087 2
a3088 38
    gv = gv_fetchmethod_sv_flags(stash, meth, GV_AUTOLOAD|GV_CROAK|GV_SUPER);
    assert(gv);

    XPUSHs(isGV(gv) ? MUTABLE_SV(GvCV(gv)) : MUTABLE_SV(gv));
    RETURN;
}

PP(pp_method_redir)
{
    dSP;
    GV* gv;
    SV* const meth = cMETHOPx_meth(PL_op);
    HV* stash = gv_stashsv(cMETHOPx_rclass(PL_op), 0);
    opmethod_stash(meth); /* not used but needed for error checks */

    if (stash) { METHOD_CHECK_CACHE(stash, stash, meth); }
    else stash = MUTABLE_HV(cMETHOPx_rclass(PL_op));

    gv = gv_fetchmethod_sv_flags(stash, meth, GV_AUTOLOAD|GV_CROAK);
    assert(gv);

    XPUSHs(isGV(gv) ? MUTABLE_SV(GvCV(gv)) : MUTABLE_SV(gv));
    RETURN;
}

PP(pp_method_redir_super)
{
    dSP;
    GV* gv;
    HV* cache;
    SV* const meth = cMETHOPx_meth(PL_op);
    HV* stash = gv_stashsv(cMETHOPx_rclass(PL_op), 0);
    opmethod_stash(meth); /* not used but needed for error checks */

    if (UNLIKELY(!stash)) stash = MUTABLE_HV(cMETHOPx_rclass(PL_op));
    else if ((cache = HvMROMETA(stash)->super)) {
         METHOD_CHECK_CACHE(stash, cache, meth);
    }
a3089 1
    gv = gv_fetchmethod_sv_flags(stash, meth, GV_AUTOLOAD|GV_CROAK|GV_SUPER);
d3092 1
a3092 2
    XPUSHs(isGV(gv) ? MUTABLE_SV(GvCV(gv)) : MUTABLE_SV(gv));
    RETURN;
d3096 6
@


